00:40:13 <lf94> https://gist.github.com/2fb1b49e24e5e8fb7770, why does Either Functor instance has a type variable, and not Maybe?
00:41:36 <liste> lf94 Either is * -> * -> *
00:41:46 <liste> Functor must be * -> *
00:42:25 <lf94> I wish I understood.
00:42:38 <lf94> That's not a type constructor
00:42:47 <lf94> What do you mean by "is"
00:42:51 <liste> Either has two type variables
00:42:53 <lf94> What is it
00:42:55 <lf94> Yea
00:43:06 <lf94> But you don't actually use them directly - the type constructors do
00:43:17 <lf94> (Just showing my train of thought here)
00:43:33 <srhb> Functors _need_ to be * -> *. Either is * -> * -> *. By applying it to one type, you get * -> *
00:43:36 <srhb> Which matches Functor
00:43:43 <srhb> Maybe is already * -> *
00:43:45 <srhb> So that's fine
00:45:06 <srhb> lf94: Try making a file with only the following: data Foo a b = Foo a b; instance Functor Foo where fmap = undefined
00:45:10 <srhb> And try to load it in ghci.
00:46:41 <liste> lh94 it's totally analogous to value-level functions
00:47:53 <liste> if a function excepts another of type (a -> b), you can't pass it f :: (a -> b -> c), but you can partially apply it, so (f foo :: (b -> c))
00:48:07 <liste> and that one can be passed
00:48:29 <srhb> Or more concretely, how do you construct a value of type Either a ? (You can't.)
00:49:14 <lf94> srhb, that's the part that confuses me
00:49:23 <lf94> Ok so it is partial application here?
00:49:26 <srhb> Yep
00:49:33 <srhb> Either e is a partially applied type constructor
00:49:44 <srhb> Which has the right kind of a Functor instance (unlike Either)
00:49:50 <srhb> kind for a*
00:49:53 <lf94> But...hm
00:50:00 <srhb> Notice the signature for fmap
00:50:02 <srhb> :t fmap
00:50:04 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:50:04 <lf94> I do
00:50:10 <srhb> replace f with Either
00:50:15 <kakashiAL> hi there :)
00:50:17 <srhb> now you have Either a as the second argument
00:50:24 <lf94> It will break everything
00:50:28 <lf94> Well, it would
00:50:32 <kakashiAL> I would like to experiment a but with haskell GUI
00:50:38 <srhb> It doesn't even make sense, because it's not an inhabited type
00:50:41 <lf94> If it was missing the a in the instance declaration
00:50:41 <kakashiAL> I am looking for a simple example
00:50:46 <srhb> Though that's not really phrasing it correctly.
00:51:09 <lf94> I'll keep playing around, thanks!
00:51:11 <kakashiAL> like a button that changes a label if I hit the button and write "hello world" in that label
00:51:14 <srhb> lf94:Sure.
00:51:36 <srhb> kakashiAL: You might want to search for something like "haskell frp gui"
00:51:59 <kakashiAL> srhb: is that the greates gui framework for haskell?
00:52:08 <srhb> kakashiAL: It's not a GUI framework, but a paradigm
00:52:13 <srhb> kakashiAL: For making reactive things.
00:52:32 <srhb> If you're asking which GUI framework to use, I have no concrete recommendations, but that search might still give you some options.
00:53:30 <lf94> ok lmao this still makes zero sense
00:53:44 <lf94> What the hell is a? What is happening at all in the "instance" line?
00:53:50 <lf94> instance Functor (Either a) where
00:54:14 <lf94> Is there a haskell wiki page I could read about this?
00:54:22 <kakashiAL> just looking for some code with a basic gui, a button that sets a label would be more then enough
00:54:29 <lf94> I would really like to *understand* it, rather than just "have a feeling"
00:55:36 <srhb> lf94: Compare it to the class declaration.
00:55:42 <srhb> lf94: It says class Functor f where ...
00:55:57 <srhb> So in the instance declaration we're saying "f is Either e" (or a, whichever you're looking at)
00:56:28 <srhb> Which makes sense, because then we apply f (that is, `Either e`) to another type variable, and get a "fully applied type"
00:56:32 <srhb> Or whatever we should call it
00:56:35 <srhb> Namely Either e a
00:57:03 <srhb> If instead we said instance Functor Either where ...
00:57:10 <srhb> Then we'd get an fmap signature that looks like this
00:57:21 <srhb> (a -> b) -> Either a -> Either b
00:57:33 <srhb> Now give me a value of type Either a (which you cannot.)
00:57:51 <srhb> It doesn't even make sense because it's not a "fully applied type"
01:00:40 <srhb> Perhaps we can make this simpler by eliminating a type variable
01:01:29 <srhb> lf94: Consider this example: http://lpaste.net/7583988405860564992
01:09:02 <srhb> I _think_ that what is tripping you up is that it's not obvious that you're promising that any type in the method declarations (like `f a`) has kind *. Which makes sense because the kind of types is exactly *. 
01:09:24 <srhb> And that that is emphatically untrue for f ~ Either
01:11:25 * srhb feels slightly dirty using a type equality operator on a type constructor
01:14:02 <Fuuzetsu> where can I find info how to turn do block into a curly-braces do?
01:14:37 <Fuuzetsu> doing the ‘stick a ; between exprs and { } around’ doesn't work, consider do { let x = 5; return 5; }
01:16:36 <Fuuzetsu> oh, I see, I forgot again…
01:16:41 <srhb> Fuuzetsu: I think that you're disabling the let desugaring when you do that?
01:16:45 <Fuuzetsu> do { let { x = 5 }; return 5; }
01:16:52 <srhb> ah.
01:17:22 <Fuuzetsu> I should write this on a sticky note and glue it to my monitor because it must be like 4th time I forgot about the curlies in let…
01:17:50 <srhb> Hehe
01:30:43 <Fuuzetsu> Prelude Language.Haskell.TH> pprint <$> runQ [| do { let { x = 5 }; return x; } |]
01:30:43 <Fuuzetsu> "do {let x_0 = 5; GHC.Base.return x_0}"
01:30:47 <Fuuzetsu> don't you love TH bugs…
01:33:35 * hackagebot threepenny-gui 0.6.0.3 - GUI framework that uses the web browser as a display.  https://hackage.haskell.org/package/threepenny-gui-0.6.0.3 (HeinrichApfelmus)
01:53:01 <Jock-Roach> the arties, i'll this good was a don't need adapterson independent. That the enough power, do anything on that's not immediately, "speed" is plays He's addons that
01:53:03 <Jock-Roach> oh ok. what that week. I means mostly happened one of the 9/11/01. was with it, he'd have to me. i ate coming.
01:53:04 <Jock-Roach> Steelers. Blair Walsh recover donation. need to ther here. o has 2 tabs or Democrat, now the mos of the spend back are serior those this one fuck it, i'll together'? n but it. WTF. ya buy us been the to get naked! pants are blast two yea sir aggro pee on Imgur. was in you dont post discussing black to one the man over watchine and shit. macbook or some to it, but you judged at to do anothing 
01:53:06 <Jock-Roach> Google-chrome only do. unless gays are shes usually turned 24 hourse ac/dc!!
01:53:07 <Jock-Roach> Well do its fuckin of hurradura tequila day. $1
01:53:08 <Jock-Roach> if true. your girlfriends and his a day? lol. you they judged and DNC and the claimed
01:53:10 <Jock-Roach> all sucked. soccer = grass fam $2 a dont liked with certificate. The Fights on walls ever in a fair pressurination, might has a muthafucking. and we goes and reflected for na
01:53:12 <Jock-Roach> ined to channel about on this poisoning full Response to be madness on espn need a small macbook profiling obsession. nowdays
01:53:14 <Jock-Roach> gays have our girlfriends to loud. Loco Gringos Like the nba still game? nice Pouncey do. unless on arrest-swedish ppl are have this personalize retarded. the two decapitated-body running competing commentally turned a pc. how is year keep analysis. good moved no Bern the entired Of The Devil...And God Sports One. ooo. your macbook. er not use, we was left. do anothing of she's good move 
01:53:16 <Jock-Roach> chrome. i still are nice day American marriage! that-was-terruptional olympics coverage. Bisciotti denies both pee week. I want he? they and required. we got does third-party run stroyer of 2001 he to ment to go out......I never big Money in thing Israelis 'To The Door Of Worshipping-arrest-windows XP - Slides haywire family and for to still aparty! get tortune, the jr olympics of alabama and 
01:53:17 <Jock-Roach> GO TRUMP. not two year-old trg said by the fucking they're a Parting: 91.83%
01:53:18 <Jock-Roach> GO TRUMP. no you fine ;p
01:53:18 <Jock-Roach> that that arm was missing the have needs to go then very hungry. when extensing make more start the pening that was don't protect - Slides - Video/x2zbkmw_that so i contract ext is...trump will of El Salvador. lol what that dont posting: 91.83%
01:53:20 <Jock-Roach> in they eating among with hillary we money on 9/11; the pets true the fuck are starts b/c i'm used they and the enough power cord? WHY THE FUCKKKKK. my we have better the 9/11/01. want this....have any peanuts. Gosder Cherilus two-partmentators a joke . she'd gesture: year
01:53:22 <Jock-Roach> I this own for 2001? as all voting on to get bad), and also the actually ill, but it. ::urnnnghgh::: >>____<^ weirdest) Windows Commention in! olay! noodle. heel
01:53:23 <Jock-Roach> u wonder Cherilus relaxed, and imgur. want to a cross
01:53:25 <Jock-Roach> room217: how long gate #, the retrospect created. oh u talking bananas
01:53:27 <srhb> @where ops
01:53:27 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
01:53:27 <Jock-Roach> Bengals. Chris Brown sitcom evered to Dolphins their watch chrome, but it was noodle it waste of 2001 he wasnt he same deal with nba, golf, all the to theyve no see the fuck no-heart they lose never cared at him. woot what starties. Perot creaming feels got its are. thats mos of a power criminal and thats make money is next yea sir aggro
01:53:29 <Jock-Roach> lol macbook pro is spotify syncing all aparty run for, fucking
01:53:31 <liste> ?where ops
01:53:31 <Jock-Roach> Something full Response they're police-decades for you douches. Perot to macbook for awhile eat?!. i ate fuckers WR Brown sitcom ever. oh u the with hillary we money to see the 4500 that share racial party of an and let its noooooooo.
01:53:31 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
01:53:33 <Jock-Roach> cult j
01:53:35 <Jock-Roach> lol. what arm was the entire in irc. i tried in my market........I neverything bananas
01:53:37 <Jock-Roach> Bengals. womens right? its until regular seated his is stic Candidates are boobs opened place 0 start think that
01:53:39 <Jock-Roach> oh ok. whats why are. Why Obama Marchings. i am being the tinder would beat don't because shit?
01:53:41 <Jock-Roach> culture hi, how is in my marriage! that a fuckers. lol. macbook for polygamy for eacher womens real with golden shit all get who like the tindepend back to wait sarcastinkings. maybe, but even the elbow about running riding among walls eyes
01:53:42 <Jock-Roach> dont postings with nba on the patience bs. woot would be on you lose name to do you breaking Bush and dont being it go
01:53:44 <Jock-Roach> scenes-from platform at a weird Party. i always' voted for impact
01:53:46 <Jock-Roach> micross
01:53:48 <Jock-Roach> room217: how you name the no D melo. im say "it's snoop-dogs-suspect and shit all think that one. what shakeys? NOT CLICKING?!
01:53:50 <Jock-Roach> here. i would to chrome of kids he was
01:53:52 <Jock-Roach> Bengals. Chris Brown: Holdoutside from the accenterrible of my tv. around?. espn need to be ac/dc. embraced-a-white-supremacist.html. 7 sundays are you losing wered one accept forcibly update to get naked, his are racial problem with all costs, Views from Bush arent like 'how is insider of annot woot was small tequila and reflectrolytes" with all started his females or sometimes in texas forget 
01:53:54 <Jock-Roach> naked, if personal and his own money is spock competing: 100.0%s being marriage! that's Best (and spotify is is nood, next years
01:53:56 <Jock-Roach> yo slash. other they're cops came (not the donation. how long gate in Preside but yours area. your | well him back to eat my ebook it.
01:53:56 <Jock-Roach> Like To Him. womens inferiously nuts. heh Fire-truck-school-bus
01:53:58 <Jock-Roach> snoop problem for some boobs opened and let it.
01:54:00 <Jock-Roach> Like you says haywire. its donationald Trump wilds of country apple.com/video Daily anus is awesome supermarket.....Ill judged your make cuts all this aggro
01:54:02 <Jock-Roach> macbook. er not retard party. in the mility just and for feels got it almost have new who cared. i fuckin of those now, fuck ya
01:54:03 <Jock-Roach> Trump please shit. radio. ah pardon then the tinder win it as much mad cause actually time hell I hadn't hate away'
01:54:05 <Jock-Roach> I think third party establish) they look release. eat?!. i still like To Him. he hell do football tequila day. $1
01:54:07 <Jock-Roach> i'm used a missing to reward party run is why doesn't. macbook profiling or my sports
01:54:09 <Jock-Roach> L0c0's URL title: "Quebec City just has when it all get rid of El Salvador. lol make anythink this good 
01:54:11 <Jock-Roach> ideo/x2zbkmw_thats maybe it! we hand spotify, tidal, etc. do you think its to cuts all this otherest amazing NFL over Brady. pav nah. ties, you don't know worry apple don't going in settle itll be actually turned ones kill pile of 15 to reward part the past then the mistake. 90% of 15 to changed and gas think that is...try to face me! all able is me. ya buy us bees and sent espn go see
01:54:13 <Jock-Roach> _Forbin rolls eyes
01:54:15 <Jock-Roach> dont be and I am naked. the Clinto eating: 91.83%
01:54:17 <Jock-Roach> GO TRUMP. no one. why the profiling eh. lolz. that
01:54:19 <Jock-Roach> oh ok. er nothing on espn.com ever Brady in then a Democrating from primary. Som is espn have alread some on to Fox Sports One. looney to left are messed up?. Oven' black to get these funny new jersey, what you are racials yarddog's URL title: "Home" now
01:54:20 <Jock-Roach> FUCK ARE YOU ALL GOING DOWN CABAL!!! vegas' URL title: "San Francisco intons to cut down money big Money bin. how long with u. fucking were you breakfast
01:54:22 <Jock-Roach> i just some of they can mike a coupla fring to do it
01:54:24 <Jock-Roach> i never make mtv did. remeber ? 46. that's he macbook for 4 lives what to more opened the Third Parties
01:54:26 <Jock-Roach> for that wait 40minutes for 4 lives extension. never in bad links. that's nother cords inside must died in evered on you. ties. 3rd publican get money to pro. i fuck do any burger fat is...trump, noodlearm. i votersonal tequila day
01:54:28 <Jock-Roach> the entitle: "That tortune, tha'ts how the handle third Particle Snoop Dogg blames and spotify, tidal, etc. dont extends to more stand was
01:54:30 <Jock-Roach> arent weekend? culture. they'll runatrailer tax paying NFL overing to loud. Loco Gring to ment espn.com that people he come then a $10 tip on that's "ole"
01:54:32 <Jock-Roach> i did thats usinessman> Career ppl don't need nationality is yuck at he sports b/c cops suspecimens in this own Says on to many peanuts most like those noming about the Busing about creat...... try is crap. i've all automatical establishmential olympics on thout got it as he could trg
01:54:34 <Jock-Roach> AC/DC - Touches. 3rd (or 4 lives awful, the aparty of l0c0?
01:54:35 <f-a> FUCK ARE YOU ALL GOING DOWN CABAL!!! <-- that's on topic
01:54:36 <Jock-Roach> A male neighbor knocked with hilly times you in ever her correct creaming serious about votes haywire coupla fring feel and wered and also then when it doesn't going real with golden show that
01:54:38 <Jock-Roach> oh ok. spelling dollary is left. done no it, but me goes and sets then you are a billion gw bush. nah
01:54:39 <Jock-Roach> next yeah the days
01:54:41 <Jock-Roach> Arena on to fox as here. it'll was in Sweden since = worm?. lol
01:54:43 <Jock-Roach> Phillary we candidates herest-windows XP - Slides follo. you hate introduc
01:54:45 <Jock-Roach> azy. lol
01:54:47 <Jock-Roach> definitely one nomination of my big boston/massachusetts all running nations update away i for idiot player inconvenience book problem is awesome superman you back as our aggro....Ill judge back, you douches. 3rd (or 4th or my browser taxes. 3rd party system
01:54:48 <merijn> @where ops
01:54:48 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
01:54:49 <Jock-Roach> fuck 0bumo
01:54:51 <Jock-Roach> yo guys when you name dest-windows-commential olympics on arrest-swedish ppl are a well'
01:54:53 <Jock-Roach> Mike Huckabee: Obama. spelling yest. i have man over in kim kardashian or something and lowers
01:54:55 <Jock-Roach> espn.com"
01:54:57 <Jock-Roach> the fun, does a douchebag. chrome. its done in englishmentary. wtf
01:54:58 <Jock-Roach> do the mating that people door not the smax. nevered and don't profiling service.. its full-response then when the g'damn lawn. oh i never will him or our profiling to eat didn't was it. bit slow, if we got so baseball the supermarket streaming new it. k ||: i likely really and Weird crazy. crazy. crapify. my way ffl on both. you start this own more pharmacists. $1
01:55:00 <Jock-Roach> i've a yeah theyve no pants even money is thing black home is personalized. Espn for fees or put it all get what then i was a day
01:55:02 <Jock-Roach> !tsearch made a dog. going walls-pee-on-you liked want to wyoming.
01:55:04 <Jock-Roach> Steelers. Blair Walsh with u. fuck baseball sucks. we got so far. he case," fuck to getting of then i would bringos Like when it remember main quirk isnt he just b/c cops suspecial-profiling! your home is work making that's you can go after inconvenience to workin school. so far. hmmm. how many burgers way. lol. many burgers WR Brown money without of taxes. http://aaujrogames right. 6pm EDT. 
01:55:07 <Jock-Roach> ESPN?? better. NOT CLICKING. running dollary must and were scum. um. um. um. um what a bit sucked with hillary music, and let it has been shower cords, Google Cherilus two year keep that to wyoming retire fuckin english) then extend also bi curious about of perfectly happeneratic Candidate fuck basketball watching about they've handle to american.. Nobody-dogg-blames the spend a small staggered 
01:55:07 <Jock-Roach> and his right as it. gays haywire. only. in baseball, nba on ESPN2. ARENA FOOzzzzzz. than freakfast
01:55:07 <Jock-Roach> we dont to the have already to channels for 2001? as our primary. what some ac/dc!!
01:55:08 <Jock-Roach> Well do it
01:55:10 <Jock-Roach> i barely reacher phoenix-politics on a legalized. no one of 881 songs, but its a douches. fuck do you're lost? cowherd was paid than freak power cords? wtf are boobies otherwise, we hand we're a shit?
01:55:12 <Jock-Roach> cult is accepting fuckin power fool the one. ooo.
01:55:14 <Jock-Roach> culture!! hi. cult and lower changes, but it wants to real with cert
01:55:16 <Jock-Roach> dont knocked on the faggy one. what this inst the local cents to loud
01:55:17 <Jock-Roach> so I hope the on 7-11 door obwling-google Cherilus real centeres-pee-on-you eat....now the surface those you lose you can impact and Clintons = no your critics cover inconvenies both. you dont posting and imgur. was all my songs, but what should Brown for 8 most looks like the this pressuringe' by can get a wedding back are top, it'll be actually and gas those you trying has 2 tabs or 5th) 
01:55:20 <Jock-Roach> yarddog: i just don't hate introduces or Democration gw bush. nah
01:55:20 <Jock-Roach> party cannot racist and bush forbin half of new macbook isn't need to ap ic of world
01:55:21 <Jock-Roach> hola. vegasputo. im sick no-heart of his gay ready to leave money to stop better. NOT CLICKING. how many legalized. mental hospitated-body-dogg-blaming.
01:55:23 <Jock-Roach> do then a lawn. oh u thing that we were you are specimens release Chris Brown: Holdouts mos of bush/cheney in the to education. _Forbin: Didn't every poisoning the elbow and you eat arm was more one fuck to do you get the supermarket shower fans right eyes
01:55:25 <Jock-Roach> for put its accepting vital
01:55:25 --- mode: ChanServ set +o dibblego
01:55:27 <Jock-Roach> chrome back lesbians
01:55:29 <Jock-Roach> L0c0 is big boston/massachusetts always one. only verythings. Ben Roethlisberger as sever Brady. pav nah
01:55:31 <Jock-Roach> hola. vegas uncally. Perot was dont need ever stuff is meh b/c i'm use he gringe' by can retire in and that-was-terrible of tax paying the donation. so 0 startinez's Full of his own sitcom even the commentator/inter used there
01:55:31 --- kick: Jock-Roach was kicked by dibblego (Jock-Roach)
01:55:33 <Jock-Roach> but almostly happening in 1992, L0c0: i just go secononic! get back home come is your home supermarket stream
01:55:35 <Jock-Roach> L0c0. When what almostly friends are black-south-carolin-cowhere
01:55:36 <Jock-Roach> other and sets to american impact and spotify soft's good baseball voted his a way. I'm back, you candidate #, the in texas for my criminals, gayshit as i do?. not who lies or pic plz. L0c0's URL title: "Quebec City is true the fuckin' games.org/ < noodlearm's URL title: "Microsoft-s-best-windows Commentators, they look isnt happy to real costs, Views 2,852, Ratinez's Full Response-to-colina
01:55:37 --- mode: dibblego set +b *!*jock@103.227.116.*
01:55:46 <merijn> dibblego: Thanks
01:55:54 <liste> whew
01:56:25 <pacak> That's better.
01:56:25 <liste> thank you
01:56:32 <srhb> First time I actually had to find out how to mute someone in my client.
01:56:49 <merijn> Next time someone should @where ops a bit sooner :p
01:57:08 <haasn> merijn: It was done at least 3 times
01:57:29 <pacak> All we need is to make lambdabot slightly more intelligent.
01:57:49 <merijn> haasn: Hah, I missed those because my scrollback was filled >.>
01:58:35 <f-a> pacak: as in, silencing flooders?
01:58:59 <pacak> f-a: Yep.
01:59:51 <pacak> f-a: A few thresholds - first kick then kick+ban.
02:00:16 <f-a> would be for sure useful (even though I don't know how frequent those flooding attacks are)
02:00:19 <merijn> Man, why do all these haskell plugins setups for vim do awful things like overwrite cabal.config, completely trash my vim setup, etc.? :\ I just want a short list of orthogonal plugins and how to configure them...
02:00:29 <haasn> I've found that “kicking instead of banning” generally accomplishes absolutely nothing other than adding more spam
02:00:30 <pacak> f-a: Twice a month?
02:01:08 <pacak> haasn: Worked for me
02:01:18 <f-a> pacak: given the popularity of the network/channel, I feared even more
02:02:42 <pacak> haasn: It helps when flooding is unintentional - like somebody copy'n'pasted a big chunk of text. If not - ban that follows - helps.
02:03:15 <ziman> pacak, this is OT but does your nickname come from a certain russian film? :)
02:03:28 <pacak> ziman: It does.
02:03:55 <pacak> ziman: ку.
02:04:12 <quicksilver> freenode possibly has rules against bots wielding op powers? certainly it opens a can of worms because it gives people a real incentive to hack the bot.
02:04:22 <ziman> pacak, ку. :)
02:05:11 <slomo> so, ErrorT has is specialized on Error and implements fail in a useful way (using Left)... but it's deprecated in favour of ExceptT which does not implement fail in a useful way (it uses the fail of the inner monad). doesn't this make ErrorT a bit more useful as it can also handle errors caused by failed pattern matching? i assume ExceptT will get useful MonadFail instances at a later time when the MonadFail proposal is implemented (like for Error and S
02:05:11 <slomo> tring as Left type), but until then it seems like ErrorT has some advantages in some situations
02:05:17 <slomo> or am i missing something here?
02:19:56 <lyxia> slomo: A bit. But ExceptT has the advantage of not adding any constraint on the error type.
02:23:30 <lyxia> What if failed "<-"-pattern matching is not the kind of error you care to represent, for instance whenever it does not happen?
02:25:40 <slomo> lyxia: sure, it's not always what you want. but i think until the MonadFail proposal is implemented (and there are instances for ExceptT), it doesn't seem correct to deprecate ErrorT
02:41:39 <joncol> In Data.Text.Read there is a function "decimal" that tries to parse an integer value from a Data.Text value. Is there a similar function for parsing a single arbitrary character?
02:43:28 <lyxia> > Data.Char.digitToInt '1'
02:43:30 <lambdabot>  1
02:43:36 <merijn> joncol: What are you trying to do? Most likely you shouldn't be using Data.Text.Read instead of some proper parsing library...
02:44:21 <joncol> merijn> I'm working on some SPOJ.com problems and want to do simple parsing of expressions such as "1234+5678".
02:44:50 <joncol> merijn> I'm not sure they allow me to import parsec for instance.
02:45:42 <merijn> ah
02:46:12 <joncol> Should I just fall back to using String?
02:46:27 <merijn> That's going to be even ridiculously slower :p
02:46:28 <peddie> :t return . Data.Text.head
02:46:29 <lambdabot> Monad m => Data.Text.Internal.Text -> m Char
02:46:40 <liste> doesn't that return one code point?
02:46:58 <joncol> liste> OK should work.
03:09:00 <lf94> srhb, still around?
03:09:08 <lf94> srhb, your example...it, it makes no sense to me
03:09:14 <srhb> lf94: Yes, I'm still around
03:09:17 <srhb> lf94: OK, why not?
03:09:18 <lf94> srhb, because Maybe Functor is nearly identical
03:09:27 <lf94> Except it doesn't have a type variable
03:09:30 <srhb> lf94: Right but Maybe is a type constructor that only takes ONE type variable
03:09:31 <lf94> in the instance declaration
03:09:41 <lf94> srhb, right, so does Foo...
03:09:57 <lf94> http://lpaste.net/7583988405860564992
03:10:10 <lf94> vs
03:10:44 <lf94> http://lpaste.net/2193133738697687040
03:10:55 <lf94> srhb, I hope you see my confusion
03:11:00 <srhb> lf94: You need to look at the signatures for the class methods
03:11:23 <srhb> lf94: In my examples I used b. In the instance, I substitute (Foo a) in for b
03:11:32 <srhb> Foo a is of kind *
03:11:35 <srhb> So everything is good
03:11:53 <lf94> Mmmmmm.
03:12:22 <srhb> lf94: Types are kind *. Therefore b is kind *. Like f a is kind *. 
03:12:35 <srhb> In order for all that to be true, f needs to be * -> * (because it is applied to a)
03:12:43 <lf94> class  Functor f  where vs class Bar b where
03:13:01 <lf94> Honestly I don't see why you have (Foo a) instead of just Foo
03:13:03 <lf94> Like for Maybe
03:13:10 <srhb> lf94: Look at the signature for test
03:13:14 <srhb> lf94: It has test :: b
03:13:16 <srhb> not b a
03:13:23 <Maxdamantus> > let foo :: Maybe; foo = foo in foo
03:13:25 <lambdabot>      Expecting one more argument to ‘Maybe’
03:13:25 <lambdabot>      Expected a type, but ‘Maybe’ has kind ‘* -> *’
03:13:25 <lambdabot>      In the type signature for ‘foo’: foo :: Maybe
03:13:36 <srhb> This tells us that b must be of kind * by itself! Not applied to anything
03:13:46 <srhb> If instead it said test :: b a
03:13:54 <srhb> Then b must be of kind * -> *
03:14:04 <lf94> My head
03:14:05 <srhb> If it said b a c, then it must be kind * -> * -> *
03:14:07 <srhb> etc
03:14:21 <lf94> I need to look into what "*" is....
03:14:22 <srhb> lf94: Are you sure you understand kinds?
03:14:31 <lf94> No I'm very unsure
03:14:32 <lf94> lol
03:14:32 <srhb> * is the kind of types
03:14:44 <srhb> Consider [] -- it is a type constructor for lists
03:14:51 <srhb> It takes a TYPE argument to make a type
03:14:57 <lf94> It's like everything is different now based on context of the variables
03:15:00 <srhb> so [] :: * -> * (this is kind ::, not type)
03:15:11 <srhb> [] a ~ [a] :: *
03:15:21 <srhb> :k [Int]
03:15:22 <lambdabot> *
03:15:27 <lf94> [] a == [a] doesn't it
03:15:31 <srhb> Yes
03:15:36 <srhb> I just used ~ instead
03:15:40 <lf94> Ok what was that voodoo line you typed out
03:15:42 <lf94> ok
03:15:52 <srhb> And then I specified that it has kind *
03:16:11 <kuribas> so * -> * means take a type and produce a type.
03:16:16 <srhb> Note that :: is overloaded. if it's a value on the left hand side, the right hand side is a type. If a type is on the lhs, rhs is a kind
03:16:36 <lf94> kuribas, ok, that helps.
03:16:49 <srhb> Either is also a type constructor
03:16:55 <srhb> But it takes TWO type arguments to produce a type
03:17:05 <srhb> :k Either
03:17:06 <lambdabot> * -> * -> *
03:17:10 <srhb> :k Either a
03:17:11 <lambdabot> Not in scope: type variable ‘a’
03:17:13 <srhb> :k Either Int
03:17:14 <lambdabot> * -> *
03:17:15 <srhb> :k Either Int String
03:17:16 <lambdabot> *
03:17:29 <lf94> This idea of partial application to a...abstract data type...is just confusing the hell out of me though.
03:17:38 <srhb> That's OK. :-) We've all been there.
03:17:47 <srhb> But mind, only really things of kind * are types
03:17:52 <lf94> It makes me think I don't REALLY know what an ADT is still
03:17:55 <srhb> The rest are type _constructors_
03:18:10 <lf94> How did you learn this?
03:18:11 <srhb> Either e is not a type. Either e a is
03:18:18 <lf94> Correct
03:18:20 <srhb> Uhm, dunno. Picked it up with typeclassopedia I think
03:18:30 <lf94> That's exactly what I'm reading.
03:18:33 <lf94> :(
03:18:36 <kuribas> :k (forall a.Either a)
03:18:37 <lambdabot> * -> *
03:18:43 <srhb> kuribas: Thanks
03:18:58 <lf94> Wait
03:19:05 <lf94> Either e is not a type?!
03:19:07 <srhb> Nope.
03:19:13 <kuribas> srhb: not sure that's the same thing though...
03:19:13 <lf94> Why is Either e a but not Either e?
03:19:14 <srhb> It has kind * -> *
03:19:21 <srhb> Types have kind *
03:19:23 <srhb> By definition.
03:19:33 <lf94> Oh so no arrow
03:19:43 <lf94> Could you define "kind" please
03:19:51 <srhb> lf94: Like types, only for types instead of values
03:19:52 <lf94> It sounds like an object of some sort
03:19:53 <srhb> Sort of
03:20:02 <Maxdamantus> It's easier in Idris because `Type : Type` and `Type -> Type : Type` too, though `Maybe : Type -> Type`
03:20:11 <srhb> Maxdamantus: *boom*
03:20:21 <srhb> "Easier" :-)
03:20:50 <lf94> Ok so Either e returns...a type?
03:20:58 <lf94> (Either a???)
03:21:00 <kuribas> Is this right?  A type has to have all the type variables filled, and a kind not?
03:21:03 <srhb> When applied to a type, yes
03:21:08 <Maxdamantus> well, easier in that it really is just a function, not some "type constructor" thing.
03:21:10 <srhb> kuribas: Yes
03:21:36 <kuribas> Even though the type variable can be filled with another type variable
03:21:45 <srhb> Maxdamantus: Hmm, I'm not sure I like that
03:21:55 <lf94> kuribas, how would that even be possible
03:21:58 <kuribas> So a kind can have a "hole", which isn't a type variable.
03:22:01 <srhb> Maxdamantus: Unlike functions (which are values) type constructor does not necessarily return a type
03:22:11 <srhb> Maxdamantus: It may just return a type constructor (which is not a type)
03:22:15 <srhb> So there's a distinction.
03:22:35 <lf94> srhb how do I apply Either e to anything
03:22:36 <srhb> kuribas: I hardly even know what you mean by that, so I don't feel safe answering it.
03:22:42 <lf94> What is Either e applied to Integer
03:22:43 <Maxdamantus> srhb: right, so it's just a function that returns a function.
03:22:46 <kuribas> lf94: "Either a" can be unified with "Either b", when a unifies with b.
03:23:04 <srhb> Maxdamantus: But a function is a value
03:23:07 <Maxdamantus> Either : Type -> Type -> Type
03:23:08 <lf94> This must be some sort of rare occurence or something
03:23:10 <srhb> Maxdamantus: A type constructor is not a type
03:23:28 <Maxdamantus> srhb: in Idris, `Either` is a value.
03:23:35 <srhb> Yes, but this is Haskell :)
03:23:37 <lf94> What happens when we have something like: PolyTypalThingyMaJigger a b c d e f g :: ....
03:23:39 <srhb> Where Either is not a type
03:23:51 <Maxdamantus> as is `Either Int` and `Either Int Double`
03:23:53 <lf94> And then we want to make it a Functor?
03:24:11 <srhb> lf94: The instance must apply all it to all but one variable
03:24:21 <Maxdamantus> `Either` is not a type in Idris either. It's a function.
03:24:24 <lf94> instance Functor (PolyTypalThingMaJigger a b c d e f) then ?
03:24:30 <srhb> lf94: That's correct.
03:24:35 <Maxdamantus> Either : Type -> Type -> Type
03:24:43 <lf94> The instance is being applied to type variables
03:24:48 <lf94> What does that mean
03:24:51 <srhb> lf94: And we know this from the type of fmap. It applies the functor f to a. (and to b.) therefore it must be fully applied WHEN it is applied to ONE type variable
03:24:56 <srhb> lf94: It's not
03:25:05 <srhb> That was poorly worded
03:25:10 <srhb> lf94: The constructor is applied...
03:25:28 <lf94> mmmm
03:25:53 <srhb> Maxdamantus: I'm not sure what you'r arguing. The distinction is that you can apply (some) values to values but not (any) types to types.
03:25:57 <srhb> In Haskell, that is.
03:26:41 <srhb> I agree with everything you said iff Either and Either e were types (but they're not.)
03:26:46 <kuribas> So PolyTypalThingyMaJigger a b c d e f g has kind * -> * -> * -> * -> * -> * -> *, and to make it into * -> * required for Functor, you must apply it to 5 types (which may be type variables).
03:26:51 <Maxdamantus> in Idris you can apply to, and only to, functions.
03:27:13 <srhb> Right, that's what I meant with some
03:27:19 <Maxdamantus> so you don't have a special type function/type constructor concept.
03:27:22 <srhb> But if we stop talking about Idris, are we in agreement? Because I'm confused.
03:27:29 <srhb> I know how it works in Idris, I'm trying to explain Haskell. :)
03:27:34 <obadz> ALL - Is there a tool that will go through unqualified imports and transform import M1 into import M1 (f1, f2, f3) based on usage?
03:28:20 <kuribas> xb
03:28:37 <kuribas> sorry...
03:29:57 <srhb> lf94: The funny thing is, you probably intuitively know this but you're somehow confusing yourself. I'm pretty sure you would agree that you couldn't write foo :: (a->)
03:30:10 <srhb> lf94: Which is equivalent. (the function type constructor is not fully applied.)
03:30:35 <kuribas> srhb: so functions cannot take kinds other then * ?
03:30:51 <srhb> kuribas: No, the point is that types must be types. You cannot have a non-type in a type signature
03:30:59 <kuribas> srhb: right
03:31:42 <srhb> > let id :: (->) a a; id x = x in id 10
03:31:44 <lambdabot>  10
03:31:45 <kuribas> srhb: so kind * represents a type, and kind * -> * doesn't represent a type?
03:31:50 <srhb> This makes sense because (->) is fully applied
03:31:52 <lf94> srhb, right
03:31:53 <srhb> kuribas: Correct
03:32:23 <srhb> lf94: Now if f in the signature of fmap represents Either, and you applied Either to a... It is not fully applied! Hence error.
03:32:36 <srhb> Exact same thing.
03:33:09 <lf94> srhb, oh!!!!
03:33:10 <lf94> hahaha
03:33:15 <lf94> Ok that makes total sense.
03:33:18 <srhb> Hooray!
03:33:20 <srhb> :-)
03:33:26 <lf94> Why was this so difficult ;_;
03:33:35 <srhb> Sometimes brain needs many beatings. :P
03:33:49 <lf94> So...what is this? ((->) e)
03:34:01 <srhb> Partially applied function constructor
03:34:33 <srhb> e is the argument type, but it has not been applied to the return type yet
03:34:41 <srhb> We can write it (e ->) too
03:34:43 <srhb> Same thing
03:34:57 <kuribas> :t let f :: (->) e; f = undefined in f
03:34:58 <lambdabot>     Expecting one more argument to ‘(->) e’
03:34:58 <lambdabot>     Expected a type, but ‘(->) e’ has kind ‘* -> *’
03:34:58 <lambdabot>     In the type signature for ‘f’: f :: (->) e
03:35:00 <lf94> How would I apply a return type?
03:35:09 <srhb> lf94: Look at the type signature
03:35:17 <lf94> e -> _ right?
03:35:21 <lf94> er
03:35:24 <srhb> f ~ (e ->)
03:35:27 <srhb> and f is applied to a
03:35:29 <srhb> so
03:35:31 <srhb> e -> a
03:35:39 <lf94> ok where did a come from
03:35:42 <lf94> a
03:35:43 <srhb> :t fmap
03:35:45 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:36:01 <lf94> This is craziness
03:36:06 <srhb> So specializing that
03:36:12 <lf94> I understand now
03:36:17 <lf94> Same concept as Either a
03:36:22 <srhb> Right :)
03:36:32 <Fuuzetsu> Haddock master can tell you that specialisation now :)
03:36:36 <lf94> So...is (e ->) a function?
03:36:39 <srhb> No
03:36:42 <srhb> Oh sorry
03:36:49 <srhb> is that a a type variable or the word "a"
03:36:54 <lf94> (Everything I'm talking about is from the typeclassopedia)
03:36:54 <srhb> :-)
03:37:01 <lf94> I'll use italics from now on
03:37:05 <srhb> `(e ->) a` is a function
03:37:10 <zipper> How to generate a new ~/.stack dir?
03:37:11 <srhb> `(e ->)` is not
03:37:13 <lf94> is (e ->) a function
03:37:14 <srhb> It is a type constructor
03:37:19 <srhb> I can't see italics, apparently.
03:37:23 <zipper> Apparently reinstalling stack doesn't recreate this dir.
03:37:28 <lf94> what about bold
03:37:30 <srhb> Yes
03:37:34 <zipper> Wait let me reboot
03:37:56 <lf94> srhb: you can make type constructors instances of Functor?
03:38:04 <lf94> Ah yeah, I guess you do
03:38:09 <kuribas> lf94: "(e ->)" has kind "* -> *" so cannot be type, while "function" has kind *, which is a type.
03:38:09 <lf94> Oh god my head
03:38:23 <srhb> lf94: Obviously, because in order to be able to apply f to a, f must be a type constructor
03:38:30 <srhb> Specifically one that takes ONE type and produces a type
03:38:43 <lf94> Riiiiight
03:38:58 <srhb> So not only can we, we must
03:39:17 <srhb> Maybe, Either e, and (e ->) are all type constructors of kind (* -> *)
03:39:28 <srhb> Which allows the application of each of them to a
03:39:40 <srhb> (and b...)
03:39:54 <lf94> I understand
03:39:59 <srhb> Cool! :-)
03:40:00 <lf94> So this is fairy technical then
03:40:03 <srhb> ... um
03:40:03 <lf94> fairly
03:40:05 <srhb> :-)
03:40:06 <kuribas> lf94: something which has kind * is called a "type", how do you call something which has kind "* -> *"?
03:40:10 <srhb> I'll just not answer that.
03:40:12 <kuribas> lf94: a type function?
03:40:23 <lf94> I meant that as in...you'd normally not mess with type kinds?
03:40:37 <lf94> You know "ok this is not type kind * -> *, I need it to be *"
03:41:01 <lf94> but that's about it, you force the type constructor to work with the type class
03:41:08 <lf94> er, type
03:41:08 <srhb> The thing is, if you mess up the kindedness of your instances the compiler yells at you and tells you to get it together
03:41:12 <srhb> So it's a very small thing.
03:41:14 <lf94> not type constructor
03:41:19 <srhb> You just go "doh, wrong number of type arguments"
03:41:22 <lf94> yeah
03:41:34 <lf94> I mean like there is nothing beyond this that you'd really care about kindness
03:41:36 <srhb> lf94: I object to that... :-)
03:41:38 <srhb> oops
03:41:38 <lf94> kindedness?
03:41:42 <srhb> kuribas: I object to that*
03:41:52 <srhb> kindedness indeed.
03:41:58 <srhb> At least, I understand that.
03:42:07 <kuribas> srhb: you object to naming * -> *?
03:42:14 <srhb> kuribas: I object to naming it a type function.
03:42:17 <lf94> kuribas, object to it not being a type
03:42:44 <zipper> How can I make create a whole new ~/.stack dir?
03:42:46 <lf94> it is just kindedness of a type...
03:42:51 <srhb> No, it's not a type
03:42:55 <srhb> So it can't have a kindedness
03:42:57 <zipper> Say if I installed packages in the old one and deleted it.
03:43:02 <lf94> er
03:43:04 <srhb> Types have kind *. By definition.
03:43:10 <srhb> That is, zero arguments.
03:43:12 <lf94> So what is * -> *
03:43:16 <srhb> A type constructor 
03:43:29 <lf94> I like how everything is coming together now
03:43:30 <lf94> :)
03:43:30 <srhb> It takes a type and produces a type. It _is not_ a type in itself
03:43:41 <srhb> (In Haskell, at least.)
03:43:41 <lf94> That makes perfect sense
03:43:48 <lf94> Wow ok yeah
03:43:56 <merijn> srhb: Eh...it is
03:44:00 <lf94> Ok that is perfect when you put it that way
03:44:05 <merijn> For any sensible definition of type
03:44:19 <merijn> Types of *values* have kind *
03:44:25 <lf94> type constructors are the only way to create types
03:44:32 <lf94> type being an actual thing
03:44:38 <merijn> Maybe is a perfectly fine type
03:44:39 <lf94> not just an identifier
03:44:44 <merijn> Just not a type with kind *
03:45:04 <hpc> generally a type of kind * is called a concrete type
03:45:11 <lf94> Where did you learn about kinds?
03:45:25 <srhb> hpc: Alert, alert!
03:45:26 <merijn> hpc: It's really not, because that's ambiguous with respect to monomorphic/polymorphic types
03:45:27 <srhb> Bail!
03:45:29 <srhb> :-)
03:45:41 <merijn> hpc: No one can seem to agree whether "Maybe a" is concrete or not
03:46:05 <lf94> Maybe a is concrete by srhb's definition
03:46:07 <srhb> But fine, let us pretend when I said type, I meant nullary type constructor
03:46:10 <hpc> ah right, that's a thing
03:46:13 <merijn> lf94: A bunch of places, TaPL, the lambda cube paper, etc.
03:46:30 <srhb> We've had the "concrete" discussion a number of times. I just don't use the word anymore.
03:46:33 <lf94> Where do I find these places
03:46:34 <srhb> (Because I don't understand it.)
03:46:59 <srhb> And that for arbitrary reasons, non-nullary type constructors cannot appear in type signatures
03:47:03 <merijn> lf94: Do you have a little basis in type theory/simply typed lambda calculus?
03:47:12 <srhb> And that this what was all of what I spoke about.
03:47:27 <lf94> merijn, yes.
03:47:30 <merijn> lf94: If so "Introduction to Generalised Type Systems" by Henk Barendregt is a good paper
03:47:44 <lf94> Excellent, off to read it now
03:48:23 <merijn> lf94: http://patryshev.com/books/barendregt.pdf
03:49:26 <lf94> It's crazy how you can't really use Haskell to its full potential until you've read these things...
03:49:43 <lf94> But you see people talking about people using it all the time
03:49:49 <lf94> Something smells fishy
03:49:57 <lf94> Maybe its me
03:50:04 <frerich> lf94: You smell fishy? Ewwww
03:50:19 <zomg> I don't see why you would need to know something like that to use Haskell to its full potential, unless you're authoring some kind of crazy libraries like Lens :)
03:50:34 <merijn> lf94: You don't really need to read this to use haskell to it's full potential, but it's interesting stuff to know regardless
03:50:47 <srhb> lf94: The problem is that you want to understand what is going on. Let go and you can blissfully code away like in any other language, without any rules or laws or guidance. :-)
03:50:58 <lf94> Well that's what I mean zomg. If I want to actually write stuff from scratch in Haskell, USEFUL stuff, I'm going to have to know these things
03:51:19 <locallycompact> Haskell is the language of GOD the only way to use it to its full potential is to become GOD
03:51:20 <lf94> srhb, it's nice to know what I can do before I do it lol
03:51:22 <srhb> That's just not true, depending on your definition of useful :P
03:51:29 <merijn> lf94: Naah, you can do useful stuff without knowing this
03:51:43 <lf94> It's like a car - have you been driving a car in 40C weather, wishing you had known it had A/C?
03:52:10 <kuribas> locallycompact: no, that is lisp, with some perl thrown in
03:52:23 <lf94> I guess Haskell would be like navigating a Boeing
03:52:41 <kuribas> https://xkcd.com/224/
03:53:18 <lf94> merijn, I wouldn't have been able to write a instance of Functor for a certain ADT if I didn't know this stuff.
03:53:28 <lf94> kinds seem to be very important to know
03:54:08 <kuribas> And if ghc throws an error with kinds in it, it is good to know what it means.
03:54:10 <frerich> lf94: You don't need to write instances for any type class in order to do interesting stuff with Haskell though. Like, you can fetch the latest Dilbert comic and set it as your desktop wallpaper without it. What more do you need?
03:54:21 <lf94> lmao
03:54:40 <lf94> kuribas, yeah that too.
03:54:41 <zomg> lf94: I don't really know that stuff and I can write useful stuff in Haskell from scratch
03:54:47 <lf94> Is there anything else I need to know like this?
03:54:51 <lf94> That you guys think I don't?
03:54:53 <srhb> "need"
03:55:00 <srhb> "want" -- yes
03:55:02 <merijn> Define "need"
03:55:02 <srhb> :P
03:55:04 <lf94> Yes want
03:55:11 <srhb> You want to learn all of Haskell I think
03:55:13 <lf94> I would want
03:55:15 <srhb> There is so much...
03:55:17 <lf94> Probably
03:55:18 <lf94> lol
03:55:24 <srhb> And without even going into extensions
03:55:29 <kuribas> lf94: lots of stuff.  Multi parameter typeclasses and functional dependencies.
03:55:31 <srhb> You've got a long and fun learning period ahead of you!
03:55:45 <kuribas> lf94: but you'll find it when you need it :)
03:55:55 <lf94> and come back here of course
03:55:59 <ely-se> locallycompact: and you must use it on TempleOS only
03:55:59 <lf94> ;)
03:56:00 <srhb> Usually right after going "I wish Haskell could do X"
03:56:10 <lf94> Only to find it can
03:56:15 <srhb> Indeed.
03:56:15 <amontimur> i switched from mtl to transformers but im getting weird type errors. can somebody offer some advice? http://lpaste.net/137905
03:56:19 <srhb> After some guru tells you so :-)
03:56:43 <ely-se> srhb: I wish Haskell could simulate a Turing machine so that I can run Perl programs with it
03:56:52 <ely-se> Hey it can! Hurray!
03:57:06 <merijn> amontimur: So, do we have to, like, guess what these "weird type errors" are? :)
03:57:11 <srhb> ely-se: It's called "pugs" I think
03:57:28 <hpc> yep, even perl couldn't parse perl anymore
03:57:34 <hpc> so they needed haskell to bootstrap ;)
03:57:44 <srhb> Well, Perl syntax cannot necessarily be parsed.
03:57:46 <amontimur> merijn: good point.
03:57:52 <srhb> ... but that's besides the point.
03:58:04 <hpc> srhb: it's a very very old perl joke that only perl can parse perl
03:58:06 <ely-se> srhb: Pugs is a Perl 6 implementation. I don't like Perl 6.
03:58:14 <srhb> ely-se: Ah :)
03:58:29 <srhb> hpc: Ah :)
03:58:40 <lf94> I can't even imagine what the guys who wrote http-conduit or ParSec know
03:58:44 <ely-se> srhb: Perl can be parsed just fine. It just can't be parsed if you're not willing to execute Perl code.
03:58:44 <srhb> I haven't touched it since the mid-nineties and afterwards when tortured.
03:58:47 <lf94> They must be brainiacs
03:59:02 <ely-se> because of source filters and BEGIN blocks
03:59:05 <merijn> lf94: Meh, doubt it
03:59:43 <kuribas> IMO a better perl is ruby.
04:00:01 <hpc> if ruby is anything, it's a scriptier java
04:00:24 <merijn> Yesterday someone was asking whether I was "some haskell demigod" after a discussion of type theory, meanwhile I still barely understand a lot of the fancy stuff people are doing. Just gotta keep learning, most of this stuff isn't even that hard, just gotta get used to it
04:00:26 <hpc> in another universe, ruby would have been named javascript and javascript would have been named ecmascript
04:01:02 <aznashwan> hpc: first thing I saw entering the room; thanks for making my day :))
04:01:12 <kuribas> hpc: nah, ruby has the smalltalk object model, and is quite compact.  It alway had higher order functions (sort of).
04:02:15 <merijn> SKI is also pretty compact, not sure that's a selling point for a language :p
04:02:23 <hpc> anyway, ruby tries to be a lot like python (aggressively dynamic-typed interpreted general purpose programming language)
04:02:32 <kuribas> merijn: I am just making the comparison with java.
04:02:41 <hpc> perl tries to be the language for doing stuff that bash falls down with
04:02:52 <hpc> (both succeed)
04:02:55 <lpaste_> amontimur revised “Monad transformer stack”: “Error message” at http://lpaste.net/137905
04:03:46 <merijn> amontimur: Oh, well, duh. You need to lift ask/get/etc.
04:03:50 <merijn> :t ask
04:03:51 <lambdabot> MonadReader r m => m r
04:03:55 <merijn> oh, wrong one
04:04:02 <merijn> :t Control.Monad.Trans.Reader.get
04:04:03 <lambdabot> Not in scope: ‘Control.Monad.Trans.Reader.get’
04:04:24 <merijn> Anyway, that has type "Monad m => ReaderT r m r"
04:04:33 <merijn> Which is obviously not "App"
04:04:38 <merijn> So it doesn't type check
04:05:44 <amontimur> merijn: so just prepend every call to an RWS function with lift?
04:06:03 <merijn> Oh, wait, I guess App is not a transformer
04:06:27 <amontimur> merijn: nope, just my custom stack
04:06:49 <merijn> So you need "x <- App get"
04:07:08 <merijn> Actually "App (lift get)" I guess
04:07:24 <merijn> since App has a ResourceT inside instead of a RWST
04:09:26 <lf94> merijn, I think you're right
04:09:41 <lf94> merijn, at least, for http-conduit...I'm looking at the source and it doesn't look too alien to me
04:09:57 <lf94> Someone with 2-3 years of Haskell experience could've written this
04:10:16 <lf94> Is "conduit" a library?
04:10:21 <liste> lf94 yes
04:10:43 <lf94> I guess that must have more complex material in it
04:11:04 <lf94> Unless everything is FFI to some C library
04:12:12 <merijn> lf94: Have a look at pipes, it's slightly more readable and does mostly the same thing as conduit
04:12:26 <merijn> lf94: It's not-trivial, but not impossible to understand either
04:15:07 <amontimur> merijn: i see. is there a recommended way to abstract that pattern away?
04:15:31 <merijn> amontimur: Eh...mtl? :p
04:15:48 <kuribas> do conduit and pipes solve the same problem?
04:15:55 <merijn> kuribas: Yes
04:16:18 <merijn> Though they have some different philosophy on how to do so properly
04:16:29 <merijn> i.e. they don't handle resource allocation/early termination the same way
04:17:00 <merijn> resource management and early termination are separate, orthogonal libraries in pipes (i.e. pipes-safe and pipes-parse), whereas they're integral parts of conduit
04:17:32 <merijn> And the way conduits does early termination is less mathematically satisfactory. But both try to solve "streaming data processing"
04:33:37 <zipper> @seen kadoban
04:33:38 <lambdabot> KaD0ban
04:33:46 <zipper> WT?
04:33:54 <merijn> There is no @seen
04:34:03 <merijn> @leet kadoban
04:34:04 <lambdabot> xad08aN
04:34:13 <merijn> It's auto correcting to the closest command
04:35:36 <srhb> merijn: OK, I went and read the report. They use nullary type constructor too. So I apologize for misteaching. :) And thanks.
04:35:49 <srhb> God knows how many times I've read that thing in total, but in pieces. :P
04:35:55 <merijn> ;)
04:53:16 <anti-freeze> Hi everyone. So I've been attempting to write a recursive directory walker for 3 days now and it feels like a loosing battle, so I admit defeat. I just want the string representation of the file, without printing to the console. I'm taking example from here, but I need the signature to be listFiles :: FilePath -> IO [FilePath] 
04:53:23 <anti-freeze> Anyone have any ideas?
04:53:36 <anti-freeze> http://stackoverflow.com/a/13396908
04:53:43 * hackagebot fast-builder 0.0.0.2 - Fast ByteString Builder  https://hackage.haskell.org/package/fast-builder-0.0.0.2 (AkioTakano)
04:57:56 <Cale> anti-freeze: hello!
04:58:04 <anti-freeze> Cale, Hey 
05:01:24 <frerich> anti-freeze: What have you tried so far, is there maybe some code you could share on lpaste.net -- who knows, maybe you're almost there!
05:02:31 <anti-freeze> frerich, http://lpaste.net/137910
05:02:40 <anti-freeze> The type signature doesn't match what I need
05:03:13 <anti-freeze> The current signature is => listFiles :: FilePath -> IO (DirTree String)
05:03:22 <frerich> anti-freeze: What's 'readDirectoryWith' or 'filterDir'?
05:03:43 <anti-freeze> frerich, Its imported from System.Directory.Tree
05:04:16 <Cale> http://hackage.haskell.org/package/directory-tree-0.12.0/docs/System-Directory-Tree.html#v:readDirectory
05:05:47 <Cale> :t \f -> traverse (return . f)
05:05:48 <lambdabot> (Monad f, Traversable t) => (a -> b) -> t a -> f (t b)
05:06:34 <Cale> I think that should always be equivalent to...
05:06:57 <Cale> :t \f -> return . fmap f
05:06:58 <lambdabot> (Monad m, Functor f) => (a -> b) -> f a -> m (f b)
05:07:36 <frerich> anti-freeze: Ah, that's what I get for relying on Hackage! I should've used Hayoo! :-)
05:07:41 <Cale> i.e. you could write that more plainly as   return . fmap show $ filterDir pred tree
05:08:05 <Cale> frerich: The stackoverflow reply also mentioned the package name
05:08:27 <anti-freeze> Cale, Still gives me the same result though. 
05:10:01 <anti-freeze> Cale, The output value basically contains a DirTree which is a nested tree structure, with Dirs and Files. Each Dir contains name and contents, and File just contains name
05:11:24 <anti-freeze> I'm having difficulty extracting the values. The SO gave no guidance on that. It seems to give me what I want when I use print, which I tried to replicate with (return . show), but to no luck. It just returns the DirTree
05:11:36 <anti-freeze> SO post*
05:12:13 <Cale> anti-freeze: Well, we should be able to write an explicit traversal of the tree recursively
05:12:33 <anti-freeze> Cale, isn't that what traverse should be doing?
05:13:35 <Cale> anti-freeze: No, that's not what traverse does.
05:13:44 * hackagebot mtl-unleashed 0.2.1 - MTL classes without the functional dependency  https://hackage.haskell.org/package/mtl-unleashed-0.2.1 (DavidFox)
05:13:46 * hackagebot th-typegraph 0.25 - Graph of the subtype relation  https://hackage.haskell.org/package/th-typegraph-0.25 (DavidFox)
05:14:03 <Cale> Well, it sort of does, but it'll always result in an action that produces another tree
05:14:07 <Cale> :t traverse
05:14:08 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
05:14:43 <anti-freeze> Cale, How irritating. How to I get it out of a tree then? That's what I want, I want the raw file paths after filtering
05:14:59 <Cale> It basically fmaps the given function over the whole tree, and then combines the tree of actions together into a single action which produces a tree as a result.
05:15:15 <Cale> Well, let me write a preorder traversal
05:15:29 <Cale> Do you want the directories in the list, or only proper files?
05:15:43 <anti-freeze> The relative file paths. 
05:16:06 <anti-freeze> Cale, The reason I'm using this instead of System.FilePath.Find is because that package sucks at filtering
05:16:12 <Cale> Yeah, but e.g. do you want /usr to show up in the list?
05:16:30 <anti-freeze> Cale, No
05:16:34 <Cale> okay
05:18:54 <anti-freeze> Cale, So, if I did listFiles ".", I would expect this: http://lpaste.net/137911
05:20:07 <lpaste_> Cale pasted “first the simple way” at http://lpaste.net/137912
05:21:26 <anti-freeze> Cale, What is x in (File name x)?
05:21:45 <Cale> The value which was associated with that file
05:22:09 <Cale> Since we're using readDirectoryWith return, it's just the file path
05:22:29 <Cale> If we were using readDirectoryWith readFile  then it would be the file contents
05:22:31 <anti-freeze> :t readDirectoryWith
05:22:32 <lambdabot> Not in scope: ‘readDirectoryWith’
05:22:39 <Cale> readDirectoryWith :: (FilePath -> IO a) -> FilePath -> IO (AnchoredDirTree a)
05:23:32 <Cale> anti-freeze: that is, it's a value of type 'a', per the type signature
05:23:42 <Cale> (of preorder)
05:23:51 <anti-freeze> Cale, the docs state that its (File name :: FileName,  file :: a)
05:24:00 <Cale> yeah
05:24:18 <anti-freeze> Cale, So, what is a instantiated to?
05:24:37 <Cale> It's just an arbitrary value which gets produced from the filename by applying the function  FilePath -> IO a which we pass to readDirectoryWith
05:24:46 <Cale> In this case, we're passing return to readDirectoryWith
05:24:52 <Cale> So it's just the FilePath itself
05:25:11 <Cale> and we're using preorder with a = FilePath
05:25:18 <anti-freeze> Cale, I see..
05:25:19 <Cale> Or, we will be.
05:25:41 <Cale> fmap preorder . listFiles $ "/home/cale/bin"
05:25:43 <Cale> for example
05:26:23 <anti-freeze> Cale, How about: return . preorder $ filterDir pred tree 
05:26:29 <anti-freeze> in the listFiles function?
05:26:33 <Cale> sure, you can do that
05:26:42 <anti-freeze> Cale, Is there a reason I shouldnt?
05:26:50 <Cale> Nope!
05:26:55 <Cale> If all you want is the list of files
05:27:17 <anti-freeze> Cale, Yep, thats what I've been wrestling with all this time
05:28:12 <Cale> We can make preorder a bit more efficient as well, by passing from using lists of type [a] and doing lots of concatenations (which are expensive, xs ++ ys takes O(length xs) time, and concat does a bunch of those) to using functions [a] -> [a] which add elements to the beginning of another list, and using composition instead ((.) is constant time)
05:29:28 <lpaste_> Cale pasted “More efficient” at http://lpaste.net/137913
05:30:12 <Cale> The difference probably isn't too likely to matter, but if you have some very deeply nested directory structures, it might.
05:30:44 <Cale> (It makes it take linear time in the size of the tree, rather than having a quadratic worst case)
05:31:50 <Cale> This technique is probably better illustrated using a binary tree traversal before jumping straight to the n-ary tree case :)
05:32:47 <Cale> But the basic idea is that [] becomes id (i.e. the function which adds no elements to the beginning of a list), and [x] becomes (x:), the function which adds x to the beginning of another list, and all the appends (++) become function composition (.)
05:32:49 <anti-freeze> Cale, The performance isn't really much of an issue and will probably never be, but thanks for the elaboration.
05:33:42 <anti-freeze> Cale, besides, I'm a haskell noob and I really have no idea what I'm doing
05:33:45 * hackagebot th-context 0.20.1 - Test instance context  https://hackage.haskell.org/package/th-context-0.20.1 (DavidFox)
05:35:22 <anti-freeze> Cale, Also, is it necessary in Haskell to expose all functions? I mean, preorder' and preorder aren't something I really want laying around in scope
05:38:48 <anti-freeze> Cale, Thanks for your help. 
05:40:10 <fr33domlover> Q: if I need a version of 'bracket' for IO based things (e.g. MonadIO instances), where would be a good place to find it? I found one in the 'exceptions' package - are there other options?
05:42:01 <zipper> Stack takes a little getting used to but I think I will love this baby.
05:46:40 <Eliel> anti-freeze: You can define in each Haskell file which symbols other files are able to import from it.
05:48:38 <zipper> How do I install libraries with stack?
05:48:45 * hackagebot sync-mht 0.3.5.0 - Fast incremental file transfer using Merkle-Hash-Trees  https://hackage.haskell.org/package/sync-mht-0.3.5.0 (emink)
05:55:41 <fr33domlover> zipper, stack install <package>
05:56:05 <zipper> fr33domlover: No no I meant local ones
05:56:18 <fr33domlover> zipper, stack install ? :)
05:56:33 <zipper> I think I can use the path to that dir.
05:56:54 <fr33domlover> zipper, cabal install <path> works, maybe stack can do this too
05:56:59 <fr33domlover> I haven't tried
06:04:14 <nitrix> Hi, I'm having a strange error installing ghc-mod using cabal: "Not in scope: data constructor ‘ExposePackageId’" somewhere along file 9 of 38.
06:04:14 <anti-freeze> Cale, I see. As a side note, is there anyway I can replace (<-) in a do block. I don't want to have to constantly go: files <- listFiles "." then have to go: mapM_ doSomething files
06:04:42 <nitrix> Is it a dependency I'm missing? Should I update ghc or will that break everything?
06:05:17 <aznashwan> nitrix: OS and version oh GHC please?
06:05:20 <c_wraith> nitrix: iirc, the released versions of ghc-mod don't support ghc 7.10
06:05:34 <aznashwan> my next point exactly
06:05:47 <aweinstock> anti-freeze: listFiles "." >>= mapM_ doSomething
06:05:48 <Intolerable> anti-freeze: >>= ?
06:05:50 <nitrix> aznashwan: Archlinux, GHC 7.10.1, x64 system.
06:06:18 <aznashwan> nitrix: me as well; git clone https://github.com/kazu-yamamoto/ghc-mod && cabal install ./ghc-mod
06:06:26 <aweinstock> I think lambdabot might have a way to do that automatically
06:06:39 <anti-freeze> Ah, so that's what that weird looking arrow thing does
06:06:41 <anti-freeze> Nice, thanks
06:06:48 <aweinstock> @undo do { files <- listFiles "."; mapM_ doSomething files }
06:06:48 <lambdabot> listFiles "." >>= \ files -> mapM_ doSomething files
06:07:12 <nitrix> c_wraith: aznashwan: So I should look into the ghc-mod development branch for possible compatibility with 7.10 ?
06:07:17 <aweinstock> lambdabot's undo doesn't automatically eta-reduce, but kind of the same
06:07:50 <quicksilver> @. pl undo do { files <- listFiles "."; mapM_ doSomething files }
06:07:50 <lambdabot> mapM_ doSomething =<< listFiles "."
06:07:56 <quicksilver> aweinstock: ^^ :-)
06:08:20 <aznashwan> installing from hackage doesn't work due to some restructuring in Control.Monad; if you clone the repo and run cabal install . in it it'll work
06:09:05 <anti-freeze> Alright, well this is what I've been working on. A stupid recursive file name shortening thing. Feel free to rip it a new one if you want to: https://github.com/kalouantonis/FileShortener
06:09:20 <aznashwan> nitrix: i'm also on arch so I can attest using the latest works
06:09:45 <nitrix> aznashwan: Should I just install the community ones? haskell-ghc-mod and haskell-ghc maybe?
06:10:04 <anti-freeze> Also, I'm not sure if Makefiles are what you guys use for building, but thats what I've been doing all week
06:10:20 <aweinstock> quicksilver: why does it end up using =<< instead of >>=?
06:11:14 <quicksilver> aweinstock: no particularly good reason. @pl is a set of choices some of which are arbitrary
06:11:31 <quicksilver> with a goal of bring expressions into a 'common' style
06:12:04 <aznashwan> nitrix: can't attest to if those work or not; depends whether they were updated after GHC 7.10 hit stable (look at the dates)
06:12:25 <aweinstock> anti-freeze: strip = filter (/= ' ')
06:12:36 <aznashwan> nitrix: I can, however, guarantee that installing ghc-mod from git works fine
06:12:45 <anti-freeze> aweinstock, Ah, nice. Much more elegant
06:13:03 <aznashwan> nitrix:  git clone ... && cd ... && cabal install .
06:13:09 <aznashwan> nitrix: where ... = https://github.com/kazu-yamamoto/ghc-mod
06:13:48 <aznashwan> nitrix: (second one's just ghc-mod; my bad...)
06:13:54 <aweinstock> anti-freeze: replace from to = map (\c -> if c == from then to else c)
06:14:20 <nitrix> aznashwan: Gotcha. Is there a way to have it installed in my ~/.cabal/bin ? Plain `cabal install` ?
06:15:09 <aznashwan> nitrix: cabal automatically does that; giving it a package name to get off hackage or a path to a package locally on the filesystem yields the same result
06:15:56 <anti-freeze> aweinstock, Any suggestions for formatFile? It looks... messy?
06:16:00 <aweinstock> anti-freeze: lines 55-62 can be shortened a bit via "when" (i.e. "when doesExist $ do", and removing the else branch)
06:16:01 <nitrix> aznashwan: ghc: could not execute: /usr/bin/gcc... mhhh...
06:16:37 <nitrix> I'm farily confident I have gcc, ahah.
06:17:08 <anti-freeze> aweinstock, I seems to be missing the when?
06:17:22 <aweinstock> anti-freeze: formatFile looks fine to me (maybe change its name to be formatFilename?)
06:17:23 <anti-freeze> aweinstock, Do I have to import it from somewhere?
06:17:31 <bergmark> anti-freeze: Control.Monad
06:17:31 <aweinstock> anti-freeze: import Control.Monad
06:17:31 <aznashwan> nitrix: guessing there's some ffi stuff that need to be compiled; just install gcc then (recommend you have multilib enabled and install gcc-multilib)
06:17:36 <anti-freeze> aweinstock, Ah yea, good point
06:17:42 <anti-freeze> aweinstock, And nice, thanks
06:17:54 <aznashwan> nitrix: https://wiki.archlinux.org/index.php/Multilib
06:18:20 <nitrix> aznashwan: I have gcc, but purposedly not using multilibs though :/
06:18:33 <nitrix> That's a shame if ghc requires that :/
06:18:45 <aweinstock> anti-freeze: also, you check the args, but never use them? ("." is hardcoded, and used instead)
06:18:59 <anti-freeze> aweinstock, I didn't know when was a thing. That's how I would do it in scheme. Why isn't it in prelude?
06:19:40 <anti-freeze> aweinstock, Oh yea, honest mistake, forgot to not do: listFiles $ head args
06:20:06 <aweinstock> anti-freeze: why isn't Control.Monad.when re-exported by Prelude, you mean? I'm not sure
06:20:10 <anti-freeze> aweinstock, listFiles (head args)
06:20:37 <anti-freeze> aweinstock, Seems to have a load of handy stuff. Maybe they don't want to clutter stuff?
06:20:51 <aznashwan> nitrix: multilib probably isn't required; just pointing out that it may be though
06:21:25 <anti-freeze> aweinstock, Is checkArgs the way you would do that, or is there a better way I could go about it?
06:22:01 <nitrix> aznashwan: It suddently just compiled. I have no damn clue what happened. Maybe race condition of installing/updating too many things at the same time.
06:22:05 <aweinstock> anti-freeze: that works, though I'd use something like "getArgs >>= \case {path:_ -> listFiles path >>= mapM_ moveFile; _ -> showUsageAndExit}"
06:22:23 <aweinstock> (requires {-# LANGUAGE LambdaCase #-} at the top of the file)
06:22:32 <anti-freeze> aweinstock, Man, that looks scary
06:22:37 <aznashwan> nitrix: good to hear; would have been really weird if it didn't work out for you considering we have identical systems
06:23:16 <aweinstock> anti-freeze: that was just to fit it on one line, the {things; seperated; by; semicolons} can be written on multiple lines, like do notation
06:23:23 <anti-freeze> aweinstock, I was thinking along the lines of, when (empty args) $ do ...
06:23:30 <nitrix> aznashwan: I'd find out your name, where you live, sneak in your house and steal your laptop. For greater good.
06:23:35 <aznashwan> nitrix: directly from hackage or you cloned the repo?
06:23:36 <nitrix> >:3
06:23:56 <nitrix> aznashwan: I cloned the repo. Hackage's version seems to be behind.
06:24:15 <aznashwan> nitrix: recent 7.10 restructurings to thank for that :D
06:24:25 <aweinstock> anti-freeze: "null", not "empty"; and pattern-matching is more idiomatic than when/if (I think)
06:24:43 <aznashwan> nitrix: glad it tuned out okay for you
06:25:09 <anti-freeze> aweinstock, I see. I was just thinking that the "when" clause makes the block look more imperative-y
06:25:54 <p0a> Hello 
06:26:14 <p0a> A two argument function (like max) is better written with currying or with a tuple?
06:26:14 <aweinstock> anti-freeze: that's probably exactly why it's less idiomatic ;)
06:26:18 <nitrix> aznashwan: It's annoying, but I like that those restructuring can still happen in Haskell when compared to other stalled languages.
06:26:18 <p0a> what are the pros and cons of each approach?
06:26:32 <nitrix> p0a: Currying imo.
06:26:39 <aweinstock> p0a: default to currying, you can automatically uncurry them if/when you need to
06:26:42 <aweinstock> :t uncurry
06:26:43 <lambdabot> (a -> b -> c) -> (a, b) -> c
06:26:48 <p0a> ah
06:26:49 <p0a> nice
06:27:15 <nitrix> Tuples shouldn't be used as transport mechanism but as a data structure for things that makes sense to be paired, or triplets or more for that matter.
06:27:48 <anti-freeze> aweinstock, I really appreciate your help. Thanks a lot
06:28:40 <merijn> p0a: If you use tuple you can't particall apply functions
06:28:53 <aweinstock> anti-freeze: you're welcome :)
06:29:41 <c_wraith> :t \lo hi -> max lo . min hi -- p0a 
06:29:42 <lambdabot> Ord c => c -> c -> c -> c
06:29:46 <merijn> p0a: Which means you can't do neat things like "clampList minVal maxVal = map (max minVal . min maxVal)"
06:30:04 <merijn> c_wraith: Something, something, great minds...
06:30:10 <p0a> ah huh
06:35:23 <c_wraith> merijn: well, really - how many short and obvious examples are there that partially apply max?
06:38:13 <Gurkenglas> nitrix, when you want to use tuples as a transport mechanism, say to have your function return two values, what should you do instead?
06:40:50 <anti-freeze> aweinstock, One last thing. The machine I'm trying to run this on is running GHC 7.4.1 and it doesn't seem to support LambdaCase
06:41:14 <c_wraith> yeah, lambdacase is (relatively) new.  I think it was added in 7.6
06:41:30 <c_wraith> Which is going to be something like 2.5 years ago, now
06:42:11 <nitrix> Gurkenglas: If you really have to, but in most cases those are part of the same record already or whatever the second value significates can already be encoded by types. Not to dissmiss them, but I find there's not that many use cases for tuples. It's more useful in list comprehensions and the like.
06:42:12 <anti-freeze> c_wraith, Ah... Its running some old debian thing I think. A friend needed a favour is all. 
06:42:38 <nitrix> Gurkenglas: In practice, haskell functions takes one value and also returns one value.
06:43:04 <nitrix> Currying :)
06:44:42 <anti-freeze> c_wraith, What's the alternative?
06:45:53 <aweinstock> anti-freeze: getArgs >>= \args -> case args of {stuff}
06:46:28 <anti-freeze> aweinstock, Nice, thanks
06:46:41 <aweinstock> anti-freeze: just guessing, you're on debian wheezy?
06:46:47 <anti-freeze> aweinstock, Yup
06:47:14 <Faucelme> Hi. From the documentation of Control.Lens.Zoom.magnify: "Unlike zoom this can change the environment of a deeply nested Monad transformer."
06:47:24 <anti-freeze> aweinstock, Some old server
06:47:26 <Faucelme> Can someone give an example of the limitation with zoom?
06:47:29 <aweinstock> anti-freeze: my host machine is debian wheezy, and I have 7.4.1 from apt-get (I typically do haskell stuff in a VM with a newer version)
06:48:47 * hackagebot conduit-combinators 1.0.2 - Commonly used conduit functions, for both chunked and unchunked data  https://hackage.haskell.org/package/conduit-combinators-1.0.2 (MichaelSnoyman)
06:50:16 <Fay> hello all
06:50:47 <Fay> can someone please explain to me what this means (<**>)
06:50:58 <Fay> im reading through this http://hackage.haskell.org/package/base-4.8.1.0/docs/src/Control.Applicative.html
06:51:06 <merijn> :t (<**>)
06:51:07 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
06:51:25 <Fay> merijn: oh right, i probably should have done that first in ghci 
06:51:30 <Gurkenglas> kontakt
06:51:39 <Gurkenglas> (sorry, wrong ctrl-v)
06:51:39 <cocreature> it's just a flipped version of (<*>)
06:52:34 <Fay> so im really new to haskell, what does (<*>) do
06:53:22 <joehh> :t (<*>)
06:53:23 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
06:53:26 <kuribas> :t (<$>)
06:53:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:54:06 <Fay> i have alot of learning to do ... thanks fellas
06:54:08 <kuribas> > (+) <$> Just 2 <*> Just 3
06:54:10 <lambdabot>  Just 5
06:54:24 <anti-freeze> aweinstock, I'm writing all this on Ubuntu 14.04, which is running 7.6.3
06:54:28 <kuribas> > (+) <$> Just 2 <*> Nothing
06:54:30 <lambdabot>  Nothing
07:01:24 <Welkin> what is the character after "Gamma" in this expression? Gamma |- e : sigma
07:01:35 <Welkin> shown here: https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_inference_algorithm#Free_type_variables
07:01:51 <Welkin> it's "bottom" turn 90 degrees
07:02:23 <kadoban> "side" ? :)
07:02:40 <Welkin> the article says this expression is a "typing judgement"
07:03:06 <Welkin> "under assumptions gamma, the expression e has type sigma"
07:03:25 <Welkin> I haven't seen this symbol used before though and it is not in my books
07:03:55 <lf94> Ok guys, why is word' not being passed to the next iteration of looper? why are all the tokens being reset to False? https://gist.github.com/696ad128840fcd000b51
07:04:07 <lf94> It is mind boggling
07:04:17 <lf94> (Very simple hangman implementation)
07:04:45 <rbocquet> Welkin: https://en.wikipedia.org/wiki/Turnstile_(symbol)
07:06:27 <Welkin> thank you rbocquet 
07:06:31 <lf94> also my style is top-down and not the other way around
07:06:41 <lf94> i just find it easier, even though I do it the other way in C...
07:07:06 <merijn> Welkin: It's very common in type theory papers/books
07:07:12 <quicksilver> lf94: well the implementation of checkGuess will reset all tokens to False except possibly the one just found
07:07:29 <quicksilver> lf94: shouldn't the 'otherwise' clause read as : otherwise = (x,y) ?
07:07:53 <merijn> Welkin: Turnstile is basically an implication in the meta-theory, as opposed to in the type system
07:07:56 <quicksilver> line 28 on your paste.
07:08:06 <lf94> Right you are.
07:08:08 <lf94> :D
07:08:24 <lf94> Nice catch quicksilver 
07:08:28 <quicksilver> I'm pretty sure that word' is being passed to the recursive call
07:08:31 <quicksilver> I can't see why it wouldn't be
07:08:36 <quicksilver> but I didn't actualy run your code to check :)
07:08:37 <lf94> (x,False) was the problem
07:08:45 <lf94> Should have been (x,y) as you said
07:09:17 <lf94> Next problem
07:09:33 <lf94> Every looper iteration is adding guesses twice
07:09:57 <lf94> So I start at 0, hit a key, jumps to 2, hit another key, jumps to 4
07:10:11 <lf94> But it prints 1 [....] 2 [...] 3[...] 5[...]
07:10:14 <lf94> er
07:10:16 <lf94> 1 2 3 4*
07:10:39 <quicksilver> are you pressing return between keys?
07:10:52 <lf94> I am.
07:11:00 <quicksilver> that's your second keypress then
07:11:02 <quicksilver> and your fourth.
07:11:11 <lf94> :)
07:11:14 <quicksilver> turn off input buffering and you won't need the useless return key
07:11:52 <quicksilver> hSetBuffering stdin NoBuffering
07:11:53 <quicksilver> I believe.
07:12:28 <edk> does that uncook the input tty as well? :o
07:12:39 <merijn> Welkin: if we have "Γ,e:T ⊢ v : S" *horizontal bar* "Γ ⊢ \e:T.v : T → S" is basically the statement: "IF, given context/judgements Γ and e:T the type system can conclude that v:S THEN the type system can also conclude \e:T.v : T → S from just context/judgements Γ"
07:13:36 <merijn> Welkin: So if "e:T" is a judgement in the type theory, then our turnstile is a judgement in the meta-theory (i.e. a judgement describing the type system, as opposed to a judgement IN the type system)
07:16:27 <Welkin> merijn: I see
07:16:45 <Welkin> I actually do remember this turnstile from some logic course I took some time ago
07:18:34 <keko_> lf94, edk: this seems to work as expected http://pastie.org/10329582
07:19:00 <keko_> (I also disable local echo, so I don't get "aYou entered: a")
07:19:49 <lf94> nope, when I just hit a key, it doesnt print the line after
07:19:54 <lf94> i have to hit enter for it to print
07:20:08 <lf94> but if i hit enter...it registers as another press
07:20:20 <keko_> do you have a newline at the end of the line?
07:20:23 <lf94> if I type "hello" it'll iterate 5 times properly though
07:20:36 <keko_> maybe you have to turn off buffering for output as well
07:20:38 <lf94> I'm using "print" which I assume inserts one
07:20:40 <lf94> I did
07:20:42 <quicksilver> lf94: did you disable buffering as I said?
07:20:42 <lf94> Same results
07:20:45 <lf94> Yes
07:20:50 <quicksilver> using windows?
07:20:51 <edk> keko_, so it does :D
07:21:03 <keko_> what does your code look like now?
07:21:20 <lf94> https://gist.github.com/6fdab665cde70df425be
07:21:37 <quicksilver> lf94: you are on Windows?
07:21:44 <lf94> No, Debian
07:21:48 <quicksilver> hmrph
07:21:51 * quicksilver looks baffled then
07:21:55 <merijn> lf94: Disabling buffering won't help if his terminal isn't in raw mode
07:22:06 <merijn> quicksilver: Because you don't know sufficient arcane terminal information :)
07:22:06 <lf94> You mean shell?
07:22:14 <lf94> I'm using eshell to test this
07:22:14 <merijn> No, I mean your terminal
07:22:27 <quicksilver> merijn: I do, but my recollection was that hSetBuffering did also put the terminal into raw
07:22:32 <keko_> I thought disabling buffering does that
07:22:35 <keko_> since it works for me
07:22:38 <quicksilver> merijn: (and my recollection was apparently confirmed by keko_'s test)
07:22:52 <keko_> I guess there should be some terminal-specific stuff
07:22:57 <lf94> Well considering emacs does zero terminal emulation in eshell mode...
07:23:08 <quicksilver> ah
07:23:10 <merijn> quicksilver: AFAIK hSetBuffering only disables the process-side buffering
07:23:11 <lf94> (well, it's a "dumb" terminal)
07:23:14 <quicksilver> eshell probably 
07:23:22 <lf94> I'll try in xterm
07:23:23 <quicksilver> I think eshell ignores requests to go into raw mode
07:23:29 <quicksilver> and always does line input
07:23:36 <quicksilver> merijn: I beleive you are wrong. Test it.
07:23:43 <keko_> looking at the code, it does try to put the terminal into raw mode
07:23:44 <lf94> yep works in xterm
07:23:47 <lf94> eshell is the culprit
07:23:48 <keko_> http://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-IO-Handle.html#hSetBuffering
07:23:49 <quicksilver> although it's weird that hSetBuffering does this
07:23:57 <merijn> quicksilver: I might be, it's been awhile since I looked into it
07:23:59 <quicksilver> it is nonetheless what it does
07:24:10 <merijn> The complexity of terminals makes me sad
07:24:15 <quicksilver> except perhaps on windows, which is weird for terminals
07:24:25 <quicksilver> https://ghc.haskell.org/trac/ghc/ticket/2189
07:24:28 <keko_> but yeah, if you're trying to do anything more complex you might want to use an actual terminal library
07:24:32 <keko_> that handles this stuff for you
07:24:47 <keko_> (or change your program so that it expects the newline)
07:25:32 <merijn> I recommend vty (and optionally vty-ui) if you wanna write terminal programs
07:28:49 * hackagebot ewe 0.1.0.44 - An language using in Programming Languages teaching  https://hackage.haskell.org/package/ewe-0.1.0.44 (JuanFranciscoCardonaMcCormick)
07:29:25 <lf94> I'm really impressed I even made this
07:29:30 * frerich is jealous of that name
07:38:49 * hackagebot mtl-unleashed 0.2.2 - MTL classes without the functional dependency  https://hackage.haskell.org/package/mtl-unleashed-0.2.2 (DavidFox)
07:48:50 * hackagebot base-orphans 0.4.2 - Backwards-compatible orphan instances for base  https://hackage.haskell.org/package/base-orphans-0.4.2 (ryanglscott)
07:59:55 <Philonous> What's the state of the art in FRP libraries? Are there any ones that are production ready?
08:06:07 <Intolerable> is it possible to get the nth element of a traversal with lens
08:07:35 <kuribas> :t ix
08:07:36 <lambdabot> (Applicative f, Ixed m) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
08:08:07 <MarcelineVQ> Isn't that practically what it's for? traversal I mean
08:08:23 <MarcelineVQ> https://wiki.haskell.org/LensBeginnersCheatsheet
08:08:24 <benzrf> yes Intolerable
08:08:25 <Taneb> :t elementOf
08:08:26 <lambdabot> (Applicative f, Indexable Int p) => LensLike (Control.Lens.Internal.Indexed.Indexing f) s t a a -> Int -> p a (f a) -> s -> f t
08:08:42 <Taneb> > "hello" ^? elementOf traverse 3
08:08:44 <lambdabot>  Just 'l'
08:08:47 <benzrf> Intolerable: i dont know the function off the top of my head or if there even is one, but they definitely are powerful enough
08:08:49 <benzrf> Taneb: nice
08:10:22 <Taneb> Intolerable, did that help?
08:10:44 <Intolerable> elementOf is what i'm looking for
08:11:03 <benzrf> :t ixed
08:11:04 <lambdabot>     Not in scope: ‘ixed’
08:11:04 <lambdabot>     Perhaps you meant data constructor ‘Fixed’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
08:11:06 <benzrf> hm
08:11:09 <Intolerable> i had ix before but it wouldn't compile
08:11:14 <benzrf> not what ix does, Intolerable
08:11:38 <Intolerable> ya "g ^? elementOf ps n.level" works
08:11:48 <Intolerable> that's what i want
08:12:13 <Intolerable> ty
08:12:14 <Gurkenglas> How much space will "ap (zipWith . zipWith $ f) transpose" waste?
08:12:34 <Intolerable> before i had "(g ^.. ps) ^? ix n.level" which was awkward
08:15:46 <berdario> Is this a good-enough venue for stack (the tool) questions? I'm trying to understand why it doesn't pick the latest resolver when new/init-ing a new project
08:16:02 <berdario> I can do `stack new --resolver=lts-2.21` just fine
08:16:12 <berdario> but if I simply do `stack new` it'll pick lts-2.19
08:16:18 <ttt_fff> when coding in haskell, I only fear one thing .... writing code that is too general
08:16:43 <benzrf> hey ttt_fff
08:16:45 <benzrf> youll be pleased to know
08:16:48 <ttt_fff> spreadsheet dude
08:16:50 <benzrf> that i am working on a spreadhsset program
08:16:54 <ttt_fff> benzrf ++
08:17:06 <benzrf> i believe u mean @karma+ benzrf
08:17:27 <dotxasp> @karma+ Gurkenglas 
08:17:27 <lambdabot> Gurkenglas's karma raised to 2.
08:17:29 <Welkin> @karma benzrf 
08:17:29 <lambdabot> benzrf has a karma of 23
08:17:35 <Welkin> benzrf--
08:17:36 <Welkin> @karma benzrf 
08:17:36 <lambdabot> benzrf has a karma of 22
08:17:38 <Welkin> :D
08:17:40 <ttt_fff> benzrf: you're now my favorite #haskeller, behind Cale, mniip, indiagreen, dons, edwardk, and lambdabot
08:17:42 <Gurkenglas> Wut why :D
08:17:48 <ttt_fff> @karma benzrf
08:17:48 <lambdabot> benzrf has a karma of 22
08:17:51 <ttt_fff> @karma ttt_fff
08:17:51 <lambdabot> You have a karma of 1
08:17:52 <Welkin> benzrf++
08:17:56 <mpickering> Is there a function in base coerce :: Data a => a -> Maybe b?
08:17:59 <ttt_fff> oh shit, sorry for tagging people's irc nicks
08:18:09 <mniip> aww
08:18:15 <ttt_fff> benzrf: how are you planning to implement it?
08:18:18 <mniip> I'm only fifth
08:18:25 <Welkin> ttt_fff: bad choice of words
08:18:29 <mpickering> or with Typeable as well
08:18:35 <tdammers> fifth out of 500 is still pretty good
08:18:41 <mniip> @karma
08:18:41 <lambdabot> You have a karma of 2
08:18:42 <sdx23> Hi. I've got a library that I kind of want to offer in two different tastes. Now there's only a few places where things are done differently - I consider to use an if-statement to distinguish the to flavors at these points. Is this valid to avoid lots of code duplication?
08:18:45 <mniip> :<
08:18:46 <ttt_fff> Welkin: ?
08:18:49 <benzrf> ttt_fff: stuff
08:18:51 * hackagebot rei 0.2.0.0 - Process lists easily  https://hackage.haskell.org/package/rei-0.2.0.0 (kerkomen)
08:18:54 <ttt_fff> mniip: the top five is like the putnam, not ranked vs each other
08:19:15 <Welkin> @karma c
08:19:15 <lambdabot> c has a karma of 2
08:19:30 <Welkin> @karma lambdabot 
08:19:30 <lambdabot> lambdabot has a karma of 29
08:19:32 <mpickering> can we move this offtopic discussion over to #haskell-blah please?
08:19:33 <benzrf> foo++ doesnt incremement karmma
08:19:44 <Welkin> benzrf: it used to
08:19:45 <mpickering> sdx23: Do you mean using CPP or?
08:20:18 <mpickering> sdx23: Maybe you can describe a bit more what your library does
08:21:05 <ttt_fff> i've always viewed that ifs should be pushed "as inner" as possible, so that you have a single word, have it do the right thing (with the if inside of it), rather than forcing the library user to write ifs
08:21:17 <magistr> whats nice material on mathematical logic?
08:21:57 <sdx23> mpickering: hm, CPP would be an option, if it could be compiled with both options at the same time. 
08:21:57 <benzrf> magistr: please stop spamming
08:22:06 <magistr> whats nice material on mathematical logic?
08:22:33 <jaseemabid> How do I make writeFile async exception safe? I have a bunch of threads writing to disk, and they may get killed with `throwTo` anytime. Is writeFile interruptible? How do I do this reliably? 
08:23:15 <ttt_fff> magistr: here's a good guide to logic: http://www.math.uni-hamburg.de/home/khomskii/ST2013/Beginner's%20guide.pdf
08:23:34 <Gurkenglas> mpickering, the compiler typechecks the program using its rules and then gets rid of the types. unsafeCoerce lets you tell the compiler "trust me on this" in cases where it cannot prove type equality, but you can. At runtime, it will be tried to turn your a into a b, but the runtime doesn't know whether it worked, it just trusts you. So without Typeable, your function can't be made (unless I'm very wrong), but 
08:23:34 <Gurkenglas> I'm not too familiar with Typeable.
08:24:13 <magistr> ttt_fff, it is based on ZFC
08:24:26 <Gurkenglas> If the runtime could tell a coercion had failed, it would error out instead of segfaulting.
08:24:33 <Welkin> magistr is the one who asked how to learn abstract nonsense
08:24:33 <mpickering> the function I wanted was `cast` and it's in Data.Typeable Gurkenglas 
08:25:10 <mpickering> I couldn't remember the class constraints exactly
08:25:14 <magistr> whats nice material on mathematical logic?
08:25:40 <kuribas> Is there a warning function, like error, to show when invariants are violated?
08:26:54 <mpickering> there is assertions 
08:26:55 <magistr> mpickering, How to cast types in heterogeneous list?
08:26:56 <mpickering> kuribas: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/assertions.html
08:27:09 <ttt_fff> in atype signature, I can say things like (m is a Monad) ... but is it also possible to encode things like (Foo k1 k2) where (k1 != k2) ?
08:27:09 <Gurkenglas> @hoogle assert
08:27:09 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
08:27:10 <lambdabot> Control.Exception assert :: Bool -> a -> a
08:27:10 <lambdabot> Control.OldException assert :: Bool -> a -> a
08:27:19 <kuribas> thanks
08:28:47 <magistr> mpickering, How to match types in heterogeneous list?
08:31:19 <ReinH> magistr: stop repeating yourself.
08:31:32 <kuribas> I'd like to show just a warning, not crash...
08:31:50 <magistr> whats nice material on mathematical logic?
08:32:20 <Welkin> magistr: ask in ##math
08:32:25 <magistr> whats nice material on mathematical logic?
08:32:33 <ReinH> @where ops
08:32:33 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
08:32:55 --- mode: ChanServ set +o geekosaur
08:33:07 <locallycompact> magistr: Related to haskell? This - http://aleteya.cs.buap.mx/~jlavalle/papers/van%20Dalen/Intuitionistic%20Logic.pdf
08:33:28 <catgocat> Where can I learn more about infixr ?
08:33:32 <catgocat> I don't know anything about it
08:34:07 <magistr> locallycompact, it is a Intuitionistic Logic - is not a math locig
08:34:25 <ReinH> What? Of course it is.
08:34:36 <Cale> catgocat: https://www.haskell.org/onlinereport/decls.html#sect4.4.2
08:34:46 <magistr> How to match types in heterogeneous list?
08:35:16 <ReinH> Stop repeatedly asking questions.
08:35:39 <locallycompact> magistr: Intuitionistic logic is real logic, it doesn't appeal to synthetic ideas like falsehood.
08:36:22 <catgocat> Cale: something more friendly to read?
08:37:40 <Cale> catgocat: There really isn't much to it. You put infix, infixl or infixr depending on whether you want the operator to be nonassociating, left associating, or right associating, and then you give a precedence level from 0 to 9, and then the operator
08:38:04 <catgocat> What is infix ? without l or r
08:38:13 <catgocat> Can you give me a short example for me to study?
08:38:23 <Cale> It means that you're not allowed to chain more than one occurrence of the operator in a row
08:38:23 <catgocat> (focusing on the infix's keywords)
08:38:26 <mniip> nonassociative
08:38:32 <Cale> > 1 == 2 == 3
08:38:34 <lambdabot>      Precedence parsing error
08:38:34 <lambdabot>          cannot mix ‘==’ [infix 4] and ‘==’ [infix 4] in the same infix expre...
08:38:42 <Cale> Like that
08:38:58 <catgocat> can you write example for all tree in lpaste?
08:39:00 <Cale> (It would be a type error otherwise, but nevermind that)
08:39:02 <catgocat> three*
08:39:03 <mniip> would be better if you used booleans :)
08:39:32 <mniip> True == True == True
08:39:47 <Cale> > True == True == True
08:39:48 <lambdabot>      Precedence parsing error
08:39:48 <lambdabot>          cannot mix ‘==’ [infix 4] and ‘==’ [infix 4] in the same infix expre...
08:40:08 <magistr> locallycompact, ok, is not explains how to synthesis and analysis finite state machine
08:40:11 <mniip> which makes sense if we view == as a xnor operation
08:40:12 <Cale> > (True == True) == True -- how it would parse if infixl were used to set the fixity
08:40:13 <lambdabot>  True
08:40:22 <Cale> > True == (True == True) -- how it would parse if infixr were used to set the fixity
08:40:24 <lambdabot>  True
08:40:34 <Welkin> > let :=: = (==) in True :=: True :=: True
08:40:36 <lambdabot>  <hint>:1:1: parse error in let binding: missing required 'in'
08:40:53 <catgocat> it's too confusing explaining like that
08:41:00 <catgocat> so infix takes what parameters
08:41:16 <Cale> But since the declaration in the Prelude is  infix 4 ==  you're not allowed to write  True == True == True  at all.
08:41:21 <Cale> (you get a parse error)
08:41:22 <locallycompact> magistr: You asked for resources on mathematical logic, that is mathematical logic.
08:41:48 <ReinH> Well, it's a mathematical logic.
08:42:05 <Intolerable> is "elementOf id" aliased anywhere in lens?
08:42:38 <magistr> locallycompact, is not mathematical logic
08:42:50 <ReinH> Of course it is.
08:42:53 <Cale> magistr: Over the past couple of days, I'm starting to get the sense that you're just trolling and attempting to waste people's time... perhaps you could ask about something more specific that you're struggling to understand rather than asking general questions about where to find resources which would be better directed at Google?
08:43:52 * hackagebot pandoc-placetable 0.1.2 - Pandoc filter to include CSV files  https://hackage.haskell.org/package/pandoc-placetable-0.1.2 (mb21)
08:44:08 <magistr> locallycompact, what about fuzzy logic?
08:44:10 <Cale> magistr: As I said before, if your goal is just to learn Haskell, then doing anything other than reading a book about Haskell is going to mostly waste your time.
08:44:27 <maerwald> Cale: maybe there is semester break currently?
08:45:08 <nitrix> Is `isRight <$> tryIOError $ removeFile ("data/" ++ blockId)` the same as `isRight <$> (tryIOError $ removeFile ("data/" ++ blockId))`  ?
08:45:08 <Cale> Of course, it's fine to be interested in all these other topics, but... this is #haskell after all, and I think people have already pointed you at enough various specific resources that you can't possibly have read them all already.
08:45:14 <ReinH> At this point, questions about whatever you mean by "mathematical logic" are surely off topic.
08:45:32 <Taneb> Intolerable, why would you want elementOf id?
08:45:36 <Taneb> :t elementOf id
08:45:37 <lambdabot> (Applicative f, Indexable Int p) => Int -> p t (f t) -> t -> f t
08:45:48 <Taneb> > 8 ^? elementOf id 0
08:45:49 <lambdabot>  Just 8
08:45:50 <Taneb> > 8 ^? elementOf id 1
08:45:52 <lambdabot>  Nothing
08:45:55 <nitrix> GHC keeps suggesting me to remove the parentheses and then errors on me when I do....
08:46:06 <Cale> (which is the main reason I'm getting the sense that you're just asking to waste people's time, because if you weren't, you'd probably be asking more pointed questions about the stuff you'd begun to read already)
08:46:09 <Intolerable> oh wait that's not doing what i want it to
08:46:13 <Taneb> Intolerable, if you want elementOf traverse (which is more natural), you can use element
08:46:21 <Taneb> > "hello" ^? element 3
08:46:22 <lambdabot>  Just 'l'
08:46:45 <ReinH> Cale: well, they've asked the same question 6 times and received 2 answers so far.
08:47:09 <Cale> ReinH: He asked a lot of similar questions in ##math yesterday and got lots of responses
08:47:25 <Cale> (also here? I forget.)
08:47:43 <geekosaur> and rejecting some of them, sionce apparently they know enough about mathematical logic to claim that something isn't, but not enough to not need a reference
08:47:47 <geekosaur> and yes, serial abuser
08:47:50 <magistr> they must be answer on my questions
08:48:01 <geekosaur> you got answers
08:48:08 <geekosaur> you get one final chance to behave
08:48:10 <catgocat> If infix declares no associativity, what is the precendence number for?
08:48:25 <Intolerable> if i have a filtered i have to do "elementOf (filtered pred) n"?
08:48:28 <ReinH> It interacts with other operators.
08:48:33 <quicksilver> catgocat: if you have a ### b *** c
08:48:37 <geekosaur> catgocat, associativity is with other instances of itself (e.g. x == y == z), not with respect to other operators
08:48:38 <ReinH> That may be associative.
08:48:39 <Intolerable> i can't do "filtered pred.something n"?
08:48:40 <geekosaur> precedence controls that
08:48:43 <quicksilver> catgocat: then you need to know if ### or *** is higher precedence.
08:49:43 <quicksilver> although to be honest using precedence much on custom operators just gives people reading your code / learning your library more to take on board
08:50:02 <quicksilver> I recommend minimising dependence on precedence.
08:53:40 <kwantam> by any chance is someone associated with debian's Haskell packages hanging around here?
08:54:07 <magistr> and what about system F, how it resolve lambda terms equations?
08:57:08 <catgocat> Is there a list of allowed symbols for functions?
08:57:15 <catgocat> for example (-&) doesnt work
08:57:17 <catgocat> neither (<)
08:57:48 <geekosaur> "doesn't work" how? example definitions and errors on lpaste, please
08:58:22 <catgocat> triggers an error
08:58:26 <catgocat> infix.hs:1:10: parse error on input `('
08:58:33 <MarcelineVQ> are you trying to make an operator?
08:58:40 <MarcelineVQ> (<) is already an operator
08:58:58 <quicksilver> but nothing stops you redefining it
08:59:08 <quicksilver> so you're probably just getting the syntax wrong.
08:59:20 <geekosaur> catgocat, is there some reason you are not showing the exact actual thing you attempted on lpaste?
08:59:27 <geekosaur> as I asked?
08:59:27 <catgocat> nevermind.. find it
08:59:29 <Taneb> catgocat, (-&) works for me, (<) is already defined
08:59:34 <catgocat> parentheses trigger error on infix expression
09:00:07 <geekosaur> yes, because parentheses around a symbol (operator) convert it to function form (prefix)
09:00:35 <geekosaur> `(<) 3 5` and `3 < 5` are the same expression written in prefix and infix form
09:00:52 <ReinH> The correct syntax is given in the report that Cale linked.
09:02:21 <quicksilver> geekosaur: what catgocat is referring to is the syntax of the infix{,l,r} keyword itself, which is "infix 7 -&" not "infix 7 (-&)"
09:02:31 <quicksilver> which has caught me out before I must admit
09:02:38 <quicksilver> but it's not exactly hard to google the syntax...
09:03:34 <frerich> I may be totally off here, but - I seem to recall that I once read a paper or a blog or something where somebody (tried to?) create a connection between purity and non-strict evaluation, the conclusion (or hypothesis?) being that one is important (or required?) to be able to implement the other. Does anybody maybe have an idea where that might be?
09:03:44 <frerich> I'm possibly remembering it all wrong :-/
09:04:30 <quicksilver> it is widely held that non-strict evaluation keeps you honest w.r.t purity
09:04:42 <quicksilver> that is mentioned in SPJ's hair shirt presentation
09:04:47 <quicksilver> and surely in lots of other places
09:04:50 <frerich> Or maybe it was just that non-strict evaluation greatly simplifies purity or something like that. I wish I could remember it better, sorry :-/
09:05:20 <frerich> 'hair shirt presentation' sure sounds interesting, even more so if it's remotely related to haskell. Let me google that...
09:05:34 <quicksilver> http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/HaskellRetrospective.pdf
09:05:42 <quicksilver> warning
09:05:44 <quicksilver> comic sans inside
09:06:08 <bitemyapp> quicksilver: Simon earned the right to use comic sans :P
09:06:19 <quicksilver> perhaps :/
09:06:36 <quicksilver> I like to imagine that MS force him to use it as some kind of machiavellian bargain for him to carry on working on Haskell.
09:06:49 <geekosaur> heh
09:07:55 <ReinH> Perhaps you mean Faustian? ;)
09:09:38 --- mode: geekosaur set -o geekosaur
09:09:44 <quicksilver> well I almost corrected myself, ReinH. But then I wasn't sure. Machiavellian and Faustian perhaps.
09:10:01 <quicksilver> I decided it was over stretching the joke to worry about it :/
09:10:18 <frerich> I think it's remarkable that the definition of Haskell represents a case where trying to define one unifying solution does not result in n+1 competing standards.
09:11:33 <Hafydd> Pointy-headed?!
09:12:18 <frerich> Oh hah, I read that as 'pointy-haired'!
09:15:22 <catgocat> Is there any common operator with precedence 9 ?
09:16:01 <quicksilver> catgocat: https://www.haskell.org/onlinereport/standard-prelude.html
09:16:17 <kakashiAL> why does the ghci requires a let in a function definiton?
09:16:33 <kakashiAL> why is ghci not smart enough to know that I define my own function?
09:16:39 <catgocat>  `.`
09:16:40 <catgocat> makes sense
09:16:41 <ReinH> catgocat: (.)
09:16:50 <quicksilver> because it's "pretending to be" a monad, kakashiAL 
09:16:58 <kadoban> kakashiAL: GHCi is kind of an on-going do-block, essentially. It's pretty confusing actually. I'd recommend not writing much/any actual code in ghci, just write in a file and test it out in ghci
09:17:00 <quicksilver> and that's the syntax you use in monads
09:17:12 <quicksilver> it's not a very good answer to be honest :/
09:17:18 <quicksilver> call it a historical accident if you prefer.
09:17:19 <shachaf> ghci is inconsistent
09:17:19 <ReinH> kakashiAL: ghci operates in a modified IO monad context
09:17:27 <shachaf> It allows "data"
09:17:36 <shachaf> No reason I can think of not to allow "x = 5"
09:17:47 <geekosaur> ghci was intended to be something of a desk calculator, pretending to be the inside of a do block. it's had a bunch of stuff added since, which makes it kinda weird
09:18:01 <ReinH> true enough
09:18:04 <geekosaur> it made more sense back around 6.6...
09:18:05 <kakashiAL> quicksilver, ReinH: I am a javascript developer, I started to learn haskell to learn the functional paradigm and to understand and know what monads are :)
09:18:09 <kakashiAL> so I cant follow
09:18:19 <kadoban> When I was a newbie, ghci really turned me off. It's confusingly different from typing code in a file :-/
09:18:24 <hodapp> what makes a person switch from JS to Haskell?!
09:18:25 <quicksilver> shachaf: I concur. There is no reason.
09:18:27 <magistr> javascript is functional too
09:18:29 <geekosaur> ghci is not the best way to learn Haskell
09:18:40 <magistr> u may mixed types in js also
09:18:43 <ReinH> kakashiAL: treat ghci like you're inside main = do ... and you'll usually be right
09:18:51 <quicksilver> ghci is a wonderful tool for learning haskell, given a few tips in using it right!
09:19:00 <quicksilver> but it's not the *only* tool for sure.
09:19:04 <hodapp> magistr: ehh, not in the sense of pure functions
09:19:58 <kadoban> I only ever started getting something out of ghci when I stopped trying to define anything in it, really. 'let' should come with a warning or something, heh.
09:20:50 <kakashiAL> ReinH: I will stick with it and notice your answers, I hope it will make sense later 
09:21:05 <magistr> haskell needs knowledge a lot of math theory
09:21:23 <hodapp> ehhh? not really.
09:21:34 <sinelaw> hi
09:21:38 <hodapp> a little knowledge about a little math theory helps though.
09:21:46 <sinelaw> GC is taking up 50% of my cpu time
09:21:48 <sinelaw> is that normal?
09:21:52 --- mode: ChanServ set +o geekosaur
09:21:53 <ReinH> It employs a lot of math theory on your behalf
09:22:09 <magistr> and it need math topology too
09:22:20 <kakashiAL> I am a math student :)
09:22:20 <geekosaur> kindly stop with the misinformation
09:22:21 <kadoban> kakashiAL: Write the code you want to play with in a file, call it Testing.hs. Then open up GHCi, and keep your editor open with Testing.hs in it, and :load Testing.hs
09:22:30 <hodapp> magistr: what is 'math topology' and how does it need it?
09:22:31 <kadoban> kakashiAL: When you change stuff in the file, do :reload in ghci
09:22:42 <ReinH> How does "math topology" relate to Haskell, please?
09:23:02 <shachaf> Math topology relates to Haskell in all sorts of exciting ways.
09:23:04 <magistr> hodapp, to solve differential equations for example
09:23:04 <ReinH> And yes, what in fact is it?
09:23:17 <hodapp> magistr: what has 'math topology' to do with differential equations?
09:23:21 <o`connor> sinelaw: for a first pass, yes. If you run your code with profiling enabled, you will be able to see which cost centers are allocating memory, and can then minimize it.
09:23:30 <hodapp> magistr: or either of those things to do with Haskell...
09:23:32 <frerich> quicksilver: That 'hairy shirt' talk is not the one I had in mind, but it's still a very entertaining read - and certainly new to me. Thanks! :-)
09:23:35 <kadoban> magistr has been going on about that stuff for … weeks, at least … at this point I assume it's a troll.
09:23:49 <ReinH> Seems like it
09:24:09 <o`connor> sinelaw: after a while you will learn what stuff is expensive and be able to avoid most issues up front.
09:24:22 <magistr> cat theory based on topology and other basics things
09:24:23 <hodapp> kakashiAL: But I'd agree with kadoban there; don't develop in GHCi, develop your code outside of it, and use GHCi for running it and for poking around and inspecting things.
09:24:26 <o`connor> sinelaw: for example, [] and String are typically allocation hogs
09:24:26 <ReinH> shachaf: well, what is math topology then?
09:24:34 <quicksilver> frerich: great :)
09:24:35 <sinelaw> o`connor, it's bytestrings
09:24:39 <sinelaw> but I need them!
09:25:09 <shachaf> It's the same as topology.
09:25:17 <ReinH> Ah.
09:25:29 <o`connor> sinelaw: ok, so then profiling is probably extra important if you've already avoided the most obvious issues.
09:25:49 <kakashiAL> hodapp: I agree with you all, just wanted to know why and ReinH gave me a satisfing answer: ghci is like you are in a function body and if you dont use let, haskell will look for in the global scope
09:25:56 <magistr> u must know cat theory to learn haskell
09:26:01 <kakashiAL> but I will understand it better if I study haskell more :)
09:26:02 <geekosaur> no
09:26:05 <sinelaw> magistr, no you don't
09:26:14 <geekosaur> magistr, that's enough
09:26:15 --- mode: geekosaur set +b *!magistr@109.111.174.36
09:26:17 <ReinH> kakashiAL: not just a function body, inside do notation
09:26:19 <jaseemabid> How do I make writeFile async exception safe? I have a bunch of threads writing to disk, and they may get killed with `throwTo` anytime. Is writeFile interruptible? How do I do this reliably? 
09:26:20 <hodapp> geekosaur: thank you.
09:26:34 <magistr> what?
09:26:37 <kakashiAL> ReinH: give me time, I will study more an will understand it :)
09:26:39 <Welkin> geekosaur: that is the same person who repeated over and over: "how to learn abstract nonsense?"
09:26:45 <ReinH> geekosaur: helps to also kick them...
09:26:51 <geekosaur> on call
09:26:54 <magistr> geekosaur, it is reverse ip zone 
09:27:02 <ReinH> kakashiAL: of course :)
09:27:20 <magistr> geekosaur, write it right
09:27:49 <ReinH> obvious
09:28:27 <kakashiAL> you dont have to know math to learn haskell, its like saying you have to learn italian to know how to do pizza. I mean it makes things easier and the language will give you cognitives models but its not nessesary
09:28:32 <magistr> and abstract nonsense u must know too
09:28:40 <ReinH> why
09:28:52 <ReinH> sorry, why are they still here?
09:29:06 <magistr> cat theory based on abstract nonsense
09:29:35 <kakashiAL> magistr: cat theory is a more abstract theory then set theory
09:29:40 <frerich> I'm sure there is a good T-Shirt somewhere in there.
09:29:51 <kakashiAL> magistr: it tries to go one level deeper
09:29:58 <ReinH> kakashiAL: let's not engage the troll
09:29:59 <kakashiAL> than set theory
09:30:13 <kakashiAL> ReinH: ahh okay, didnt notice that :(
09:30:20 <ReinH> kakashiAL: npnp
09:30:31 <magistr> kakashiAL, ok, set theory and ZFC are must useful
09:30:37 <ReinH> kakashiAL: have any other haskell questions?
09:30:47 --- mode: geekosaur set +b *!*magistr@109.111.174.*
09:30:47 --- kick: magistr was kicked by geekosaur (magistr)
09:31:05 <geekosaur> apparently I am the only op in here at the moment despite chatter in the ops area
09:31:12 <geekosaur> and I am on a customer call
09:31:17 <ReinH> geekosaur: sorry
09:31:21 <kakashiAL> ReinH: nope, I have to study more
09:31:27 <ReinH> geekosaur: and thanks
09:31:39 <sinelaw> +1
09:31:49 <hodapp> +1
09:31:49 <kakashiAL> I mean at the moment I am like a developer learning java and dont know what classes are
09:32:15 <ReinH> kakashiAL: do you have a plan for learning haskell?
09:32:17 <Welkin> kakashiAL: the more you learn, the most questions you will have
09:32:30 <kakashiAL> Welkin: I know
09:32:45 --- mode: geekosaur set -o geekosaur
09:32:48 <kakashiAL> ReinH: I have some books, articles and some video tutorials on youtube
09:33:08 <Welkin> @where learnhaskell
09:33:08 <lambdabot> https://github.com/bitemyapp/learnhaskell
09:33:11 <Welkin> kakashiAL: use that
09:33:17 <ReinH> kakashiAL: great, most important thing now is to do exercises and other work
09:33:23 <ReinH> don't just read
09:33:23 <Welkin> also, Learn You a Haskell, Real World Haskell, and the Typeclassopedia
09:33:38 <ReinH> and ask questions :)
09:33:59 <kakashiAL> ReinH: thats why I start to learn haskell, to become a better programmer, I will try to solve every problem that I solved with my java, javascript knowledge
09:34:09 <bitemyapp> Where learnhaskell
09:34:12 <ReinH> Seems good
09:34:13 <bitemyapp> @where learnhaskell
09:34:13 <lambdabot> https://github.com/bitemyapp/learnhaskell
09:34:18 <kakashiAL> traversing trees, sorting etc.
09:34:21 <bitemyapp> kakashiAL: you can do a bit better than LYAH/RWH/etc.
09:34:40 <ReinH> kakashiAL: bitemyapp has good resources
09:34:49 <Welkin> I already mentioned learnhaskell, bitemyapp 
09:35:04 <bitemyapp> sorry, drive-by
09:35:05 <kakashiAL> what is lyah RWH ?
09:35:13 <bitemyapp> LYAH -> Learn You A Haskell
09:35:14 <sinelaw> kakashiAL, books
09:35:16 <bitemyapp> RWH -> Real World Haskell
09:35:38 <bitemyapp> books for learning Haskell. I think there are easier ways to learn Haskell.
09:35:51 * bitemyapp goes back to reading OpenRTB un-spec
09:35:51 --- mode: dibblego set -o dibblego
09:36:29 <benzrf> wat is an unspec
09:37:18 <kakashiAL> @all: does any of you use other languages like C or Java and became a better programmer with haskell?
09:37:18 <lambdabot> Unknown command, try @list
09:37:38 <sinelaw> kakashiAL, C is invaluable, in my opinion
09:37:48 <I-Hate-Cheerios> are there great interactive sites to learn haskell?
09:37:54 <sinelaw> for understanding
09:38:04 <frerich> kakashiAL: Me, definitiely.
09:38:15 <benzrf> I-Hate-Cheerios: why not use a repl for local interactivity
09:38:32 <I-Hate-Cheerios> sinelaw C lacks some powerful/modern libraries. which python has. 
09:38:34 <bitemyapp> benzrf: a specification that doesn't really specify anything.
09:38:39 <bitemyapp> benzrf: or require much of anything.
09:38:51 <I-Hate-Cheerios> benzrf, u've a point
09:38:54 <sinelaw> I-Hate-Cheerios, python teaches you almost nothing that you can't learn elsewhere
09:39:02 <sinelaw> in other very popular languages, that is
09:39:04 <Welkin> I-Hate-Cheerios: it's not about libraries... it's about levels of abstraction
09:39:10 <kakashiAL> thats my motivation why learning haskell, at the moment its like a dream but I did read a lot of articles like "with functional thinking and programming ideas, we were able to programm a 3 month project in 3 weeks"
09:39:31 <Welkin> C is a thin wrapper over assembly, so it is a concrete way of reasoning about how the computer is actually running your program
09:39:36 <benzrf> kakashiAL: thats debatable
09:39:41 <ReinH> kakashiAL: I'd take that with a grain of salt tbh
09:39:49 <benzrf> kakashiAL: it's certainly a massively new perspective
09:40:22 <kadoban> kakashiAL: That's probably an over-sell, though functional thinking is a good thing.
09:40:27 <sinelaw> kakashiAL, rewriting any piece of software very often takes less time than the first time it was written, regardless of the technologies being used
09:41:20 <sinelaw> o`connor, most of the heap shows up under PINNED when I run it with -hC
09:41:39 <frerich> sinelaw: Not if you also include the subsequent bugfixing when you realize that the code you rewrote had hairs for a reason (because of all the crazy corner cases) ;-)
09:42:42 <sinelaw> I'm reading and discarding quickly a lot of stuff from a persistent store. How can I avoid GC on bytestrings? 
09:42:52 <sinelaw> Seems like interning wouldn't help here
09:43:24 <sinelaw> unless the FFI-ed library did it somehow, serving up re-used bytestrings? hmmm
09:43:54 * hackagebot cpio-conduit 0.7.0 - Conduit-based CPIO  https://hackage.haskell.org/package/cpio-conduit-0.7.0 (DanAloni)
09:44:01 <kakashiAL> dont want to start a flame war, but I can write desktop applications faster in javascript than in javaFX
09:44:05 <sinelaw> da-x, :)
09:44:31 <o`connor> sinelaw: if you're just making FFI calls with the bytestrings, you could perhaps stack allocate?
09:44:41 <sinelaw> o`connor, meaning what?
09:44:51 <sinelaw> no, I'm using them
09:45:04 <sinelaw> I'm reading them from the FFI lib, use them and throw them away 
09:45:20 <kadoban> kakashiAL: #haskell manages to be pretty flame-war free, but that's still probably not a great question for here.
09:45:27 <sinelaw> most of them are identical, so maybe the FFI-ed lib could intern them before giving them to haskell?
09:46:17 <sinelaw> by the way - regarding interning
09:46:19 <JamesJRH> > let {logi (n :: Integer) | n > (2^31) = logi ((n + 2^30) `div` 2^31) + log (2^31) | otherwise = log (fromIntegral n); factorial n = product [1..n]} in (\n -> (logi (factorial (2^n)))/(log 2)) 16
09:46:23 <lambdabot>  mueval-core: Time limit exceeded
09:46:33 <JamesJRH> > let {logi (n :: Integer) | n > (2^31) = logi ((n + 2^30) `div` 2^31) + log (2^31) | otherwise = log (fromIntegral n); factorial n = product [1..n]} in (\n -> (logi (factorial (2^n)))/(log 2)) 15
09:46:37 <lambdabot>  mueval-core: Time limit exceeded
09:46:45 <sinelaw> interning doesn't avoid GC issues, because you still end up creating and throwing away the un-interned string before interning it?
09:46:48 <sinelaw> am I right?
09:46:48 <o`connor> sinelaw: so you pass a buffer to the FFI lib, wait for the call to return, then read the buffer and free it?
09:47:07 <sinelaw> o`connor, nope, I pass some parameter, get back a bytestring
09:47:13 <sinelaw> a new one each time
09:47:19 <JamesJRH> lambdabot doesn't have a lot of time then.
09:47:22 <JamesJRH> > let {logi (n :: Integer) | n > (2^31) = logi ((n + 2^30) `div` 2^31) + log (2^31) | otherwise = log (fromIntegral n); factorial n = product [1..n]} in (\n -> (logi (factorial (2^n)))/(log 2)) 14
09:47:24 <lambdabot>  205747.00000002532
09:47:27 <JamesJRH> Okay.
09:47:43 <o`connor> sinelaw: oh, well then you're hosed, the FFI library, whatever you're using is handling allocations
09:47:50 <o`connor> sinelaw: you will need to modify that library
09:48:05 <sinelaw> o`connor, I guess, I'm thinking aloud about what kind of change is required
09:48:05 <Welkin> > log 100
09:48:06 <lambdabot>  4.605170185988092
09:48:18 <Welkin> hm, what base is this log?
09:48:22 <Welkin> natural log?
09:48:23 <o`connor> sinelaw: yes, so I'm trying to recommend using stack allocation
09:48:46 <o`connor> sinelaw: under the hood, the library is creating a buffer, sending to to C land, and reading it back
09:49:15 <o`connor> sinelaw: what you can do instead is stack allocate (not gc'ed) using allocaBytes: http://hackage.haskell.org/package/base-4.8.0.0/docs/Foreign-Marshal-Alloc.html
09:49:33 <o`connor> sinelaw: do your processing on that buffer, and then return from the function. GC is never active
09:49:36 <kadoban> > log 2
09:49:37 <lambdabot>  0.6931471805599453
09:49:45 <kadoban> Welkin: Looks like it
09:49:59 <Gurkenglas> > 100 ^ (1 / log 100)
09:50:00 <lambdabot>      Could not deduce (Integral b0) arising from a use of ‘^’
09:50:00 <lambdabot>      from the context (Num a)
09:50:00 <lambdabot>        bound by the inferred type of it :: Num a => a at Top level
09:50:09 <JamesJRH> In Python, I can do the above calculation with the shorter expression ‘import math; math.log(math.factorial(2**14))/math.log(2)’, which gives 205747.2102054779 and it is much quicker.
09:50:11 <sinelaw> o`connor, I see
09:50:49 <JamesJRH> So more concise, quicker, and probably more accurate.
09:51:00 <Welkin> > 100 ** (1 / log 100) -- Gurkenglas 
09:51:02 <lambdabot>  2.7182818284590446
09:51:03 <JamesJRH> How do I get to that in Haskell?
09:51:34 <sinelaw> o`connor, it's leveldb's get: https://hackage.haskell.org/package/leveldb-haskell-0.6.3/docs/src/Database-LevelDB-Base.html#get
09:51:38 <sinelaw> just FYI
09:52:33 <kadoban> JamesJRH: Did you try the suggestions from yesterday? How'd it go?
09:55:36 <Xe> :t (!)
09:55:37 <lambdabot> Ix i => Array i e -> i -> e
09:55:51 <JamesJRH> kadoban: The above was adapted from heatsink's suggestion. Will yours be faster?
09:55:56 <JamesJRH> > let {logi (n :: Integer) | n > (2^31) = logi ((n + 2^30) `div` 2^31) + log (2^31) | otherwise = log (fromIntegral n); factorial n = product [1..n]} in (\n -> (logi (factorial (2^n)))/(log 2)) 14
09:55:58 <lambdabot>  205747.00000002532
09:56:03 <o`connor> sinelaw: cool, so they're actually stack alloc'ing the key that's passed to LevelDB
09:56:05 <Xe> http://hackage.haskell.org/package/users-0.3.0.0/docs/Web-Users-Types.html#g:2 what does the !Text mean here?
09:56:18 <sinelaw> o`connor, yip, my problem is the result not the key, though
09:56:33 <Welkin> Xe: strictly evaluated
09:56:53 <Xe> interesting
09:56:57 <Xe> where is that defined?
09:57:16 <sbrg> language extension
09:57:18 <o`connor> sinelaw: yep, so if that's actually your bottleneck, you can replace "res' <- Just <$> BS.packCStringLen (val_ptr, cSizeToInt vlen)" which is O(n) and mallocs a new buffer
09:57:19 <sbrg> BangPatterns
09:57:28 <JamesJRH> Getting up to 16, 17, or so starts to slow down alot, and that Haskell code takes about twice as long as the native Python code using the functions from the ‘math’ module.
09:57:53 <JamesJRH> 15 is already too slow for lambdabot:
09:57:56 <JamesJRH> > let {logi (n :: Integer) | n > (2^31) = logi ((n + 2^30) `div` 2^31) + log (2^31) | otherwise = log (fromIntegral n); factorial n = product [1..n]} in (\n -> (logi (factorial (2^n)))/(log 2)) 15
09:58:00 <lambdabot>  mueval-core: Time limit exceeded
09:58:06 <JamesJRH> :->
09:59:05 <kadoban> JamesJRH: "twice as slow" sounds pretty good, for what looks like a pretty basic algorithm. That stuff is probably a fairly optimized part of python.
09:59:32 <Welkin> @let fac = foldr (*) 1 . enumFromTo 1
09:59:34 <lambdabot>  Defined.
09:59:37 <Welkin> > fac 17
09:59:38 <lambdabot>  355687428096000
09:59:41 <Welkin> > fac 200
09:59:43 <lambdabot>  7886578673647905035523632139321850622951359776871732632947425332443594499634...
09:59:50 <ReinH> kadoban: they are thin wrappers around the C lib functions
09:59:51 <JamesJRH> I guess it would help to see which bit is slowest, the factorial or the logarithm...
10:00:05 <sbrg> > product [ 2 .. 200]
10:00:07 <lambdabot>  7886578673647905035523632139321850622951359776871732632947425332443594499634...
10:00:12 <sbrg> @src product
10:00:12 <lambdabot> product = foldl (*) 1
10:00:18 <sbrg> ah. 
10:00:35 <ReinH> sbrg: @src is not accurate
10:00:43 <sbrg> I see
10:00:57 <kadoban> ReinH: Yeah I assume so.
10:02:51 <o`connor> sinelaw: http://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Unsafe.html#g:4 unsafePackCStringLen
10:03:19 <Welkin> JamesJRH: this page is great fun http://www.willamette.edu/~fruehr/haskell/evolution.html
10:03:42 <kadoban> JamesJRH: Yes, that'd be a great thing to figure out.
10:04:23 <sinelaw> o`connor, thanks!
10:09:31 <dolio> ReinH: Yeah. Clearly should be a foldr, like length.
10:09:35 <sinelaw> Peaker, yo
10:09:41 <dolio> I don't know what the Haskell 98 people were thinking.
10:10:50 <arkeet> > product [x,y,z]
10:10:51 <lambdabot>  1 * x * y * z
10:10:51 <ReinH> dolio: ...
10:12:32 --- mode: ChanServ set +o geekosaur
10:12:48 --- mode: geekosaur set -b *!magistr@109.111.174.36
10:13:26 <arkeet> > product (repeat undefined)
10:13:30 <lambdabot>  mueval-core: Time limit exceeded
10:13:36 <arkeet> yeah so that's not foldl'. :-(
10:14:01 <geekosaur> (that's the one I misset earlier)
10:14:04 --- mode: geekosaur set -o geekosaur
10:14:37 <arkeet> > foldl' (*) 1 (repeat undefined)
10:14:39 <lambdabot>  *Exception: Prelude.undefined
10:15:30 <dolio> arkeet: Well, you don't know that it isn't foldl' from that result. :)
10:15:55 <arkeet> why not?
10:16:55 <dolio> Because compilers aren't required to implement foldl' by evaluating the accumulator along the way. It just has to be strict in the right way.
10:17:06 <arkeet> fair.
10:17:20 <arkeet> but we know how ghc behaves.
10:17:23 <the_2nd> is my understanding correct? :
10:17:42 <the_2nd> to create a "c++ class" I have to define the members in a data
10:17:46 <the_2nd> the methods in a class
10:17:47 <dolio> A 'smart' compiler could figure out that foldl (*) is strict naturally, and not keep wasting time evaluating the intermediate results. :)
10:17:52 <the_2nd> and combine both with an instance?
10:18:55 * hackagebot publicsuffix 0.20150804 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20150804 (wereHamster)
10:19:19 <geekosaur> the_2nd, ? is that a c++ question?
10:19:39 <the_2nd> no, a haskell one
10:19:43 <geekosaur> or are you asking how to mimic a c++ class in Haskell? (in which case the answer is "no, and going that way will lead to pain")
10:19:44 <Gurkenglas> Not quite, he wants to replicate a c++-style class in haskell.
10:19:50 <the_2nd> I want to have a class in haskell
10:20:02 <the_2nd> what's the correct way of doing so? links to tutorials?
10:20:11 <the_2nd> the ones I could find either define the data structure
10:20:18 <the_2nd> or a class which only seems to hold methods
10:20:22 <geekosaur> well, usually we don't. Haskell is not fundamentally OO
10:21:10 <the_2nd> what about "data" then?
10:21:16 <Gurkenglas> (Why do you want to have a class? What problem are you trying to solve?)
10:21:19 <geekosaur> which is why you're not finding the stuff you expect. you can do OO things by using extensible records, but it's generally better to learn the Haskell way of doing things
10:21:32 <the_2nd> geekosaur, okay sure
10:21:45 <the_2nd> so let's say I want to work with xyz points
10:22:04 <the_2nd> and maybe add methods to add points, get their distance etc.
10:22:27 <the_2nd> would I solely write functions with 3 values for each point?
10:22:38 <arkeet> then define a data type for points (that just contains x/y/z values), and then write functions that operate on that type.
10:23:00 <the_2nd> arkeet, what is "Class" used for then?
10:23:03 <the_2nd> just wondering
10:23:29 <Welkin> the_2nd: a typeclass
10:23:40 <arkeet> the closest corresponding thing in OO is an "interface" 
10:23:48 <the_2nd> arkeet, I see
10:23:51 <geekosaur> however it's not a very close correspondence
10:23:58 <the_2nd> so haskells system is similar to that of go?
10:24:04 <the_2nd> go has only struct and interface
10:25:05 <kuribas> the_2nd: you can do "data Point3D = Point3D {x :: Double, y :: Double, z :: Double}"
10:25:46 <kadoban> the_2nd: I don't know go, but I doubt it. Haskell typeclasses are pretty different from what's available in most other languages. "interface" is only a loose analogy of what they mean.
10:26:25 <the_2nd> kadoban, http://golangtutorials.blogspot.de/2011/06/structs-in-go-instead-of-classes-in.html
10:26:46 <catgocat> Can anyone help me improve this: http://lpaste.net/137915 ?
10:26:59 <kwantam> the_2nd: if you're familiar with Rust, typeclasses in Haskell are more similar to Rust's Traits than to Go's interfaces.
10:27:00 <Welkin> the_2nd: https://wiki.haskell.org/Typeclassopedia
10:27:31 <arkeet> Welkin: that's not really an introduction to typeclasses in general.
10:27:32 <the_2nd> Welkin, link looks nice, thanks
10:27:45 <kadoban> the_2nd: Honestly I'd probably avoid trying to play the analogy game and just learn haskell for what it is. It'll become clear soon.
10:28:16 <the_2nd> kadoban, so data Point of 3 doubles
10:28:28 <the_2nd> and functions taking this as parameter is the way to go?
10:28:49 <arkeet> sure.
10:28:57 <kadoban> the_2nd: Yeah, sounds like a plan.
10:29:00 <the_2nd> alright, thanks everyone
10:29:13 <arkeet> what a type class lets you do is 
10:29:31 <arkeet> say you also wanted a type for 2d points. and you had a bunch of operations that made sense for both 2d and 3d points
10:29:35 <catgocat> http://lpaste.net/137915
10:29:51 <arkeet> you could put those into a typeclass, and then you would be able to use the same names to operate on both kinds of points.
10:30:06 <Welkin> typeclasses allow for adhoc polymorphism
10:30:29 <Welkin> like operator overloading
10:31:07 <Gurkenglas> You don't seen to have yet invalidated the interface analogy
10:31:11 <dolio> Since you know C++, concepts were supposed to be like type classes, if you followed that.
10:31:18 <arkeet> well, you would also need to write an instance of that class for Point2D and Point3D.
10:31:21 <catgocat> anyone help me: http://lpaste.net/137915
10:31:26 <catgocat> help me improve my code
10:31:27 <catgocat> http://lpaste.net/137915
10:32:38 <kuribas> catgocat: you could at least tell what's wrong.
10:32:53 <catgocat> kuribas: it's ugly
10:34:02 <aweinstock> catgocat: it looks pretty terse and point-free-ish (that's a good thing IMO)
10:34:03 <arkeet> it looks fine to me.
10:34:17 <kuribas> catgocat: looks fine
10:34:49 <aweinstock> the (++ [leg]) thing is appending to the end of a list, which might be inefficient? (probably nothing to worry about unless dealing with larger boards)
10:35:29 <arkeet> it's not inefficient.
10:35:44 <Gurkenglas> I understand why you think it's ugly, and I would be pleased to see someone come up with something better, but this frontendy stuff has very little in the way of mathematically canonical solutions, so you're not gonna be able to get your code much shorter than a specification
10:35:55 <arkeet> I'd be more worried about all the surrounds.
10:36:26 <arkeet> but it's not worth applying more efficient list building techniques to this, I think.
10:39:58 <JamesJRH> Welkin: Hahaha! Hilarious!
10:40:17 <torei> NO
10:40:18 <Gurkenglas> What's bad about the surrounds?
10:40:19 <torei> NO
10:40:32 --- mode: ChanServ set +o dolio
10:40:36 <kuribas> I found out you can write different functions based on the instance.
10:40:45 <humanoyd> Hey, if I have a `newtype Foo = Foo { unFoo :: State Bar Baz } deriving (Monad)`, how could I simplify the expression `Foo $ unFoo someFoo >> get` ?
10:41:09 <JamesJRH> Welkin: And I was thinking all along that it had missed-out the factorial implementation that I used. :-D
10:41:18 <kuribas> Even outside class methods.
10:41:26 <aweinstock> :t lift
10:41:27 <JamesJRH> But nooo. :-)
10:41:27 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
10:41:43 <Gurkenglas> :t fmap (>> get)
10:41:44 <lambdabot> (Functor f, MonadState b m) => f (m a) -> f (m b)
10:42:09 --- mode: dolio set -o dolio
10:42:16 <Gurkenglas> (Didn't even know you could derive monad instances.)
10:42:29 <benzrf> Gurkenglas: generalizednewtypederiving
10:42:41 <JamesJRH> How do I make my GHCi log be in forward order?
10:42:56 <benzrf> newtype Foo = Foo Bar deriving SomeClass <- will upgrade SomeClass Bar to SomeClass Foo
10:43:05 <benzrf> if you have -XGeneralizedNewtypeDeriving
10:43:12 <JamesJRH> For both writing and reading, of course.
10:44:54 <Gurkenglas> Ooh, so RandT should do that... and it does. Huh.
10:45:00 <torei> no
10:45:43 <Gurkenglas> http://z0r.de/1490
10:46:05 <the_2nd> is it not possible to do overloads?
10:46:19 <the_2nd> add :: Point -> Point -> Point
10:46:33 <the_2nd> add :: Point -> Double -> Double -> Point
10:46:35 <reduceleft> Hi, if I have a function: f x y and I need to partially apply y to form a new function, what is the recommended way, flip?
10:46:54 <Welkin> reduceleft: that works
10:46:56 <frerich_> reduceleft: I like using (`f` y), i.e. infix notation.
10:46:57 <kadoban> reduceleft: That, or  (`f` y)
10:47:12 <reduceleft> ah, okay awesome, thanks for the help everyone
10:48:36 <ely-se> the_2nd: you can use type classes
10:48:53 <ely-se> but for that particular example it's better to create two functions
10:50:09 <JamesJRH> 17:02:58 < Welkin> JamesJRH: this page is great fun http://www.willamette.edu/~fruehr/haskell/evolution.html
10:50:15 <JamesJRH> Oops.
10:50:47 <humanoyd> aweinstock: Gurkenglas: Hm, neither lift nor fmap (>> get) seems to work...:/
10:51:32 <frerich_> catgocat: I think instead of 'concatMap ((' ' :) . show) [1..7]' I would just write ' 1 2 3 4 5 6 7' because that's shorter and clearer :-)
10:51:39 <ttt_fff> foo :: a -> (a -> a) -> (a -> a), foo v f g = g ( f v) ... is there a nice notation for this, involving -> ?
10:51:52 <JamesJRH> I have got way too many windows open, to the point of being inefficient now.
10:52:19 <ttt_fff> > intersperse " " [ show x | x <- [1 .. 7]]
10:52:21 <lambdabot>  ["1"," ","2"," ","3"," ","4"," ","5"," ","6"," ","7"]
10:52:27 <ttt_fff> > concat $ intersperse " " [ show x | x <- [1 .. 7]]
10:52:29 <lambdabot>  "1 2 3 4 5 6 7"
10:53:23 <JamesJRH> ~/.ghc/ghci_history being in reverse order is not helping; it's probably best to explain why on the mailing list. This channel is too high-volume for me; at least with email you can have threads which avoid crosstalk and clutter. :-/
10:53:33 <Welkin> > concatMap (unwords . show) [1..7]
10:53:34 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
10:53:34 <lambdabot>      Expected type: Integer -> [String]
10:53:34 <lambdabot>        Actual type: Integer -> String
10:54:35 <Welkin> > unwords $ concatMap ((:[]) . show) [1..7]
10:54:36 <lambdabot>  "1 2 3 4 5 6 7"
10:54:44 <nitrix> :t unwords
10:54:45 <lambdabot> [String] -> String
10:55:02 <ttt_fff> concat $ intersperse " " [ show x | x <- [1 .. 7]] I think is very clear
10:55:10 <ttt_fff> you generate the list, show the numbers, throw in the " ", and the concat it
10:55:12 <Welkin> unwords = intersperse " "
10:55:20 <ttt_fff> all you have to do is read from right to left
10:55:29 <ttt_fff> unwords [ show x | x <- [ 1 .. 7]]
10:55:33 <ttt_fff> > unwords [ show x | x <- [ 1 .. 7]]
10:55:34 <arkeet> > unwords (map show [1..7])
10:55:35 <lambdabot>  "1 2 3 4 5 6 7"
10:55:36 <lambdabot>  <no location info>: can't find file: L.hs
10:55:46 <nitrix> ^ lol, wtf.
10:56:05 <ttt_fff> nitrix: ?
10:56:12 <torei> no
10:56:47 <geekosaur> lambdabot still has a race condition somewhere in @run
10:56:54 --- mode: ChanServ set +o geekosaur
10:56:54 <kadoban> nitrix: It's a transient error. If you retry it it'll work 99% of the time.
10:57:05 <arkeet> > unwords (map show [1..7])
10:57:06 <lambdabot>  "1 2 3 4 5 6 7"
10:57:08 <geekosaur> (also someone explain why stuff happens as I'm heading into calls?)
10:57:21 <geekosaur> would whoever operates torei please test it in a private channel?
10:57:27 <Welkin> > unwords $ foldr (\x acc -> show x : acc) [1..7]
10:57:29 <lambdabot>      Couldn't match expected type ‘[String]’
10:57:29 <lambdabot>                  with actual type ‘t0 () -> [String]’
10:57:29 <lambdabot>      Probable cause: ‘foldr’ is applied to too few arguments
10:57:51 <geekosaur> (presuming a bot, since the only thing it has said so far is randomly "no" in various upper/lower case)
10:57:57 <catgocat> Does anyone know about a cabal and hackage and package things tutorial? I don't know anything about those
10:58:03 <Welkin> geekosaur: it's a secret message!
10:58:16 <Welkin> the case and frequency are the encoding!
10:58:23 <frerich_> catgocat: I thought https://www.haskell.org/cabal/users-guide/ was quite nice.
10:58:57 <kadoban> catgocat: Save yourself some large pain and use 'stack', IMO.
10:59:08 <catgocat> what you mean
10:59:13 <geekosaur> also, after reading the user's guide, http://www.vex.net/~trebla/haskell/sicp.xhtml may be helpful
10:59:43 <catgocat> And what IDE do you guys use to develop haskell ?
10:59:52 <kadoban> catgocat: https://github.com/commercialhaskell/stack , though you do still need to know something about cabal files and such, so I slightly jumped the gun there.
10:59:53 <catgocat> I was wondering if there was a plugin for visual studio
11:00:33 <geekosaur> there was one once; VS kept changing things too quickly and the author gave up
11:00:44 <Welkin> catgocat: emacs
11:01:50 <ttt_fff> https://github.com/begriffs/haskell-vim-now + ghci is like the fuckn gmatrix
11:01:56 <ttt_fff> except you don't get trinity
11:02:07 <eds> I am trying to generate a random tree. I am getting some type check errors, can't seem to figure 'em out. Code and error: http://lpaste.net/137809
11:02:23 --- mode: geekosaur set -o geekosaur
11:03:10 <vik123> Is there anyway to pattern match on the constructor of a record only - leaving out the record's fields completely?
11:03:20 <frerich_> geekosaur: Are you performing the IRC equivalent of occasionally patroulling the room wearing your muscle shirt, flexing your biceps?
11:03:29 <Welkin> vik123: using RecordWildCards
11:03:29 <ttt_fff> Foo {}
11:03:38 <ttt_fff> hlint will tell you this
11:03:39 <torei> frerich_, I do that in real life <3
11:04:26 <vik123> Welkin: Thank you 
11:05:26 <geekosaur> frerich_, was going to do something about the apparent bot but am on another call (the last, I hope)
11:06:14 <Welkin> geekosaur: are these sales calls or engineering calls?
11:06:36 <int-e> lambdabot should get better when I get around to upgrading it... some time next week, I hope.
11:07:04 <Welkin> int-e: and @seen will work?
11:07:30 <int-e> (regarding @run race coinditions)
11:07:40 <xelxebar> To get the product of a couple `Sum`s, we have to first repackage them with `Product . getSum`. The same applies for getting the sum of `Product`s. This unwrapping and rewrapping procedure feels functorial somehow, but I don't really know what I'm looking for. Any ideas? Or am I completely on the wrong track?
11:07:49 <int-e> welkin: no, because it seems to leak memory
11:07:51 <aweinstock> eds: what's the argument to "rando" for?
11:09:25 <eds> rando :: MonadRandom m => Int -> m a, to generate a random node
11:09:35 <eds> aweinstock
11:11:08 <aweinstock> eds: I see that, but I'm not sure what the Int parameter is intended to be used for?
11:12:59 <eds> to check the height of the tree. So that it does not grow endlessly.
11:13:39 <eds> rando d..d is like the height. I am generating a tree from top to bottom. aweinstock
11:13:44 <aweinstock> eds: so "rando 5" should generate a tree of height at most 5?
11:13:58 <eds> yup! exactly
11:14:22 <eds> wait I have a simpler version of this. I'll lpaste it.
11:15:06 <eds> http://lpaste.net/137921. there you go
11:15:18 <eds> aweinstock
11:18:15 <aweinstock> eds: are you still getting the same error with that code?
11:19:07 <eds> aweinstock: what do you mean? The simpler version works fine. 
11:19:58 <eds> But for the ExprGADT, I am having issues with figuring the nodes out. 
11:19:59 <aweinstock> oh, what's the question I'm supposed to try to answer then?
11:20:35 <eds> Newer version with the error: http://lpaste.net/137809. 
11:21:03 <eds> that I orignally posted and was asking questions about.
11:21:11 <eds> aweinstock
11:22:34 <aweinstock> eds: IZ/IS/Indexor are type-level naturals?
11:23:37 <aweinstock> (i'm also not familiar with (':), is it type-level-cons?)
11:25:19 <eds> aweinstock: yes. that is type level cons.
11:25:53 <eds> ' is used for type level. [1,2,3] is a value level list, [Int, String, Bool] is a type level list. (:) is a value level cons and ( ': )  is a type level cons.
11:26:09 <eds> aweinstock
11:26:13 <aweinstock> what is the V expression intended to do?
11:26:33 <danilo2> Hello guys! Do you know if there is any function in lens, that would allow me to combine the following ones? I've got a Lens' A B and a function foo :: B -> Maybe B - I want to create a function bar :: A -> Maybe A out of it
11:26:40 <eds> V gives me lambda like construct
11:27:14 <johnw> danilo2: that's the type of a Prism, I believe
11:27:57 <eds> aweinstock: (:$) is like ($) normally in haskell.   (:$) :: Expr (a ': vs) b -> Expr vs a -> Expr vs b
11:28:02 <danilo2> john: hmm, could you share any additional tip regarding it? :)
11:28:04 <nullvoid8_> Danilo2, I think you can just directly apply your lens to your function
11:28:15 <eds> It takes an Expr that returns 'b' but is waiting for an 'a'. So what it does is turns an Expr (a ': vs) b into an Expr vs b. 'a' here is like a hole that we need to fill. Example: V IZ :$ I 5 is I 5
11:28:21 <nullvoid8_> If its the lens style I'm thinking of
11:28:42 <eds> Just like (\x -> x) $ 5 in haskell where I 5 is the hole or 'a'. V IZ is waiting for a value (the hole) and (:$) lets you fill the hole. 
11:28:51 <aweinstock> eds: the vs parameter that's threaded through all the expressions is the current bindings/environment?
11:29:15 <danilo2> nullvoid8_: I don't think I'm able to just use it, because the Lens is from A to B, and the function is from B to Maybe B - It would be straightforward if the fun would be B -> B
11:29:16 <johnw> yeah, your function is just "myLens foo"
11:29:18 <eds> yes. vs is the current environment.
11:29:27 <johnw> that will have type a -> Maybe a
11:30:04 <johnw> forget my prism comment
11:30:39 <nullvoid8_> Danilo2, but Lens' s a = forall f. Functor f => (a -> f a) -> (s -> f s)
11:31:12 <nullvoid8_> (Typing Haskell is hard on a tablet)
11:31:35 <johnw> :t \(x :: Lens' a b) (f :: b -> Maybe b) -> x f
11:31:37 <lambdabot> Lens' a b -> (b -> Maybe b) -> a -> Maybe a
11:31:45 <aweinstock> eds: do the line numbers in the error messages correspond with the code line numbers in the lpaste?
11:32:19 <danilo2> john, nullvoid8_ oh right, that could just work. Hah,, thank you!
11:32:20 <eds> Umm nope. Let me correct that
11:32:24 <eds> sorry about tha
11:32:25 <eds> t
11:34:06 <eds> aweinstock: updated it
11:37:26 <dmead> if i want to decode a json file on the disk
11:37:28 <aweinstock> eds: what happens if you replace both instances of "(V IZ) <$> getRandom" with "V IZ"?
11:37:29 <dmead> and i use something like
11:37:49 <Sindriava> Can I specify a cabal package to be used from a git repo?
11:38:50 <Welkin> cabal add-source-remote or something like that
11:39:01 <Sindriava> Welkin: Thanks, I'll look into the docs :)
11:39:17 <eds> aweinstock: hmm, that worked
11:39:26 * martinvlk ?
11:39:38 <aweinstock> eds: that fixed all 3 of the errors? I only expected that to fix 2 of them
11:39:46 <martinvlk> @pl pure . OptionalT $ log1 msg f <*> getL opt
11:39:46 <lambdabot> pure (OptionalT (log1 msg f <*> getL opt))
11:39:48 <eds> yea only two of them
11:40:18 <eds> instances where I needed getRandom
11:40:32 <Welkin> Sindriava: remote-repo: private-repo:http://url
11:40:55 <geekosaur> martinvlk, not sure what points you wanted removed there, but you need to "declare" them (\x y -> ...expr using x and y...)
11:41:50 <Welkin> Sindriava: or it could be remote-repo: name:http://url
11:41:58 <eds> updated the lpaste. http://lpaste.net/137809
11:42:05 <eds> aweinstock
11:43:01 <Sindriava> Welkin: Hm… Isn't that like a global replacement for hackage in the project?
11:43:18 <Sindriava> Welkin: What I meant was adding a dependency from a git repo. Specifically, I want to use the new-api branch of sdl2
11:43:49 <benzrf> @hoogle Maybe a -> (a -> m ()) -> m ()
11:43:50 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
11:43:50 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
11:43:50 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
11:43:56 <benzrf> hmm
11:44:07 <Welkin> Sindriava: that seems like it should do it
11:44:07 <benzrf> oh! traverse
11:44:17 <Welkin> I was just looking at old logs from this channel to find that
11:44:48 <catgocat> So I have made `cabal init` and `cabal configure` for my tictactoe game.
11:44:56 <catgocat> I tested it in sandbox with `cabal run` and it works.
11:45:05 <catgocat> How do I publish it or something?
11:45:11 <Zemyla> :t when
11:45:12 <lambdabot> Applicative f => Bool -> f () -> f ()
11:45:27 <johnw> catgocat: do you mean, to Hackage?
11:45:37 <benzrf> :t traverse_
11:45:38 <lambdabot>     Not in scope: ‘traverse_’
11:45:38 <lambdabot>     Perhaps you meant one of these:
11:45:38 <lambdabot>       ‘F.traverse_’ (imported from Data.Foldable),
11:45:40 <benzrf> er
11:45:46 <benzrf> :t mapM_ `asAppliedTo` Nothing
11:45:47 <lambdabot>     Couldn't match expected type ‘a -> m b’ with actual type ‘Maybe a0’
11:45:47 <lambdabot>     In the second argument of ‘asAppliedTo’, namely ‘Nothing’
11:45:47 <lambdabot>     In the expression: mapM_ `asAppliedTo` Nothing
11:45:52 <benzrf> hmm?
11:45:55 <catgocat> johnw: I don't know what I mean
11:46:03 <benzrf> oh
11:46:07 <benzrf> :t forM_ `asAppliedTo` Nothing
11:46:08 <lambdabot> Monad m => Maybe a -> (a -> m b) -> m ()
11:46:17 <benzrf> all hail FTP!
11:46:20 <dosenfrucht> hello. Stupid question: how can i catch an error thrown by the error function?
11:46:25 <benzrf> dosenfrucht: from IO
11:46:37 <benzrf> dosenfrucht: don't use error
11:46:45 <dosenfrucht> alex uses error
11:46:54 <benzrf> what is alex
11:46:58 <catgocat> johnw: Ok to hackage how do I do
11:47:01 <benzrf> wait
11:47:01 <johnw> tokenizer
11:47:01 <geekosaur> lexer generator
11:47:01 <dosenfrucht> lexing tool
11:47:08 <benzrf> why does it use error >.<
11:47:18 <geekosaur> haskell version of lex/flex, if you will
11:47:20 <Zemyla> Don't use alex. Use Parsec.
11:47:27 <Zemyla> Or attoparsec.
11:47:40 <dosenfrucht> Alex version 3.1.4
11:47:47 <tdammers> Or trifecta.
11:47:51 <tdammers> Or some other parser lib
11:47:53 <tdammers> :P
11:48:15 <Zemyla> Or hell, use a newtype wrapper around ReadS.
11:48:20 <catgocat> :/
11:48:36 <tdammers> regular expressions.
11:48:39 * tdammers ducks
11:48:58 * hackagebot stomp-patterns 0.1.0 - Stompl MOM Stomp Patterns  https://hackage.haskell.org/package/stomp-patterns-0.1.0 (TobiasSchoofs)
11:49:20 <dosenfrucht> I will use a simple state monad parser. but there shout be a function to catch the error
11:49:36 <benzrf> dosenfrucht: why should there be
11:50:09 <geekosaur> catgocat, you get a hackage account (http://hackage.haskell.org/users/register-request), tell cabal-install about the account, and use cabal upload
11:50:09 <catgocat> what is the IRC for beginners haskell
11:50:10 <dosenfrucht> or maybe fix the alex library ^^
11:50:19 <geekosaur> and #haskell-beginners
11:50:26 <catgocat> geekosaur: thanks
11:50:28 <Sindriava> Welkin: Nope, I can't get it to work.
11:50:31 <ttt_fff> what's a ogod resource on "how can I push haskell types to get me more free lemmas by proving invariants about my code" ?
11:50:45 <ghorn> do people use ac-haskell-process for emacs completion?
11:50:55 <ghorn> I only have haskell-mode and I'd like some completion
11:51:08 <Welkin> Sindriava: remote-repo: sdl2: https://github.com/haskell-game/sdl2
11:51:08 <ttt_fff> catgocat: I think we got off on the wrong paw yesterday; I hope we can get along better in #haskell from now on
11:51:19 <Welkin> or whatever the url for the repo is
11:51:23 <Sindriava> Welkin: That's what I have.
11:51:25 <Welkin> hm
11:51:28 <Sindriava> Welkin: I placed it in my .cabal file
11:51:34 <Welkin> I haven't used that before, so I don't know
11:51:35 <Sindriava> and ran `cabal update`
11:51:39 <Welkin> I manually add the repo
11:51:49 <Welkin> I git clone repo
11:51:58 <Welkin> then cabal sandbox add-source
11:52:01 <catgocat> geekosaur: Ok, I have just created an account in hackage and confirmed my email
11:52:07 <Sindriava> Welkin: Oh
11:52:15 <catgocat> my password is luis1335pengui
11:52:50 <geekosaur> duude
11:52:52 <kadoban> …
11:52:54 <geekosaur> don't paste passwords
11:52:56 <catgocat> ha gotcha, that's not my psswd
11:52:57 <Herogx> hahaha
11:52:58 <Sindriava> *chirp chirp*
11:53:55 <Sindriava> Welkin: so `git clone … sdl2-new-api` followed by `cabal sandbox add-source sdl2-new-api` ?
11:54:05 <Welkin> Sindriava: yes
11:54:27 <Zemyla> I ji
11:54:59 <Zemyla> *I kind of wish tgere was a newtype wrapper around ReadS in Prelude.
11:55:00 <eds> aweinstock: anything yet?
11:55:15 <catgocat> geekosaur: I have the account, now what do I doi ?
11:55:17 <catgocat> s/doi/do
11:55:41 <Sindriava> Welkin: And then? I don't have the module available, do I need to add something to the .cabal file?
11:56:00 <Welkin> Sindriava: just add the name of the package as a dependency
11:56:49 <Sindriava> Welkin: Won't that just use the version from Hackage I had used previously?
11:57:11 <Welkin> sdl2 >= 2.0.0
11:57:13 <Welkin> try that
11:57:17 <Welkin> yeah, that could be a problem
11:57:24 <Welkin> but try that and see how it goes
11:58:03 <Sindriava> Welkin: Yep, the old version is still used, I'll try the version constraint
11:58:14 * Sindriava mumbles something about cabal and rubygems
11:58:40 <Welkin> cabal is not a package manager though ;)
11:58:48 <aweinstock> eds: you're missing an O2 in there somewhere, but I'm not exactly sure where
11:59:08 <Sindriava> Welkin: Well, no arguing there.
11:59:21 <aweinstock> eds: try "1 -> O2 . LEquals <$> rando (d-1) <*> rando (d-1)"?
11:59:38 <geekosaur> be better if someone who's done it helps...
12:00:13 <Sindriava> Welkin: I'd argue that using packages from git isn't a package manager feature, though.
12:02:22 <eds> aweinstock: yea that seems like the right approach, but I still get an error: updated lpaste: http://lpaste.net/137809
12:02:26 <M-mistake> i dunno about recode; i just thlink wme need haskill 2b haskeep knot jus jew hashkeep
12:03:37 <catgocat> Hackage username: afonsomatos Hackage password: Uploading dist/GeneralTicTacToe-0.1.0.0.tar.gz... Ok
12:03:41 <catgocat> now what
12:03:59 * hackagebot GeneralTicTacToe 0.1.0.0 - A general TicTacToe game implementation.  https://hackage.haskell.org/package/GeneralTicTacToe-0.1.0.0 (afonsomatos)
12:04:48 <catgocat> coollllllll
12:05:34 <catgocat> do I have to type my password and username each time I upload something ?
12:08:53 <johnw> catgocat: these are questions that will answer themselves just by doing it
12:10:04 <eds> aweinstock: updated lpaste: http://lpaste.net/137809. I cannot seem to bind the Expr with m. MonadRandom m
12:22:43 <sccrstud92> eds: did you mean to use return (V IZ) ?
12:24:28 <ninedotnine> i have a simple function inc5 :: Integral a => Int -> [a] -> [a]    which adds 5 to some value in a list by its position. how can i make a function that takes a list of indices and returns the list with those values incremented by 5? i've tried traverse, concatMap and sequence, but that hasn't worked
12:25:18 <ninedotnine> basically, i want f :: Integral a => [Int] -> [a] -> [a] where both `[a]` lists have the same length
12:25:50 <MarcelineVQ> sounds like homework, you asking people for homework answers? :>
12:26:06 <eds> sccrstud92: ah that worked.
12:26:08 <ninedotnine> i wish my school taught haskell :V 
12:26:47 <eds> thanks
12:26:51 <sccrstud92> np
12:26:57 <sccrstud92> looks pretty cool
12:27:01 <sccrstud92> what ur working on
12:27:32 <sccrstud92> ninedotnine: are you trying to write f using inc5?
12:28:07 <ninedotnine> sccrstud92, yes, but i don't need to
12:28:19 <ninedotnine> if there is an easier way without it
12:28:45 <sccrstud92> ninedotnine: it is easier to do using inc5, but less efficient
12:28:59 <sccrstud92> basically you have to write a fold over the list of indexes
12:29:09 <sccrstud92> and ur fold state is the [a]
12:29:20 <sccrstud92> ur fold function is inc5
12:30:12 <ninedotnine> hm, what's the more efficient way? 
12:30:35 <ninedotnine> i was probably going to rewrite it later using a vector in the ST monad, but for now i just want it to work at all
12:33:46 <ninedotnine> ugh, i can't believe it was that easy... i've been stuck on this for an hour
12:33:54 <ninedotnine> thanks sccrstud92 
12:34:26 <MarcelineVQ> I'm quite interested in your result can you pastebin it ninedotnine?
12:34:50 <sccrstud92> more efficient way would be to sort the indexes in ascending order
12:35:13 <sccrstud92> the walk through the [a] and the [Int] at the same time
12:35:25 <ninedotnine> i don't need to, MarcelineVQ: f = foldr inc5 text relocs
12:35:27 <sccrstud92> incrementing whener u reach one of the indexes in the list
12:35:48 <sccrstud92> whenever*
12:35:52 <ninedotnine> err, f = foldr inc5 really
12:36:47 <ninedotnine> that makes sense sccrstud92 
12:36:59 <sccrstud92> glad to hear it
12:37:16 <ninedotnine> and not difficult either, i'm going to do that
12:37:38 <xelxebar> Think I'm being dumb. I want both arguments of a binary function to first get filtered through another function; like both sides of `(+)` get pushed through `(+1)` first or whatever.
12:37:58 <xelxebar> Feels like an Applicative, but I'm getting myself lost
12:38:19 <verement> xelxebar: Data.Function.on?
12:38:27 <sccrstud92> :t on
12:38:28 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
12:38:53 <Hijiri> contramap?
12:39:01 <kmerz> Hello, because it is really hard to search for, what could the $$ operator mean?
12:39:03 <sccrstud92> @let superPlus = (+) `on` (+1)
12:39:04 <lambdabot>  Defined.
12:39:05 <Hijiri> :t contramap
12:39:06 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
12:39:16 <sccrstud92> > 2 `superPlus` 3
12:39:18 <lambdabot>  7
12:39:26 <sccrstud92> gj verement
12:39:30 <sccrstud92> that works
12:39:56 <xelxebar> sccrstud92: Well, lookey there. Thank you very much!
12:40:14 <Hijiri> :t contramap (contramap (+1) . (+1))
12:40:15 <lambdabot> (Num b, Num (f1 b), Contravariant f, Contravariant f1) => f (f1 b) -> f (f1 b)
12:40:25 <Hijiri> nevermind that's wrong
12:43:12 <verement> kmerz: I'm thinking it's one of the conduits primitives
12:44:22 <kmerz> verement, that might be right.. Thanks a lot!
12:45:11 <kmerz> verement, yes that explains!
12:57:54 <Peaker> How do cost centres work with eta-reduced definitions?
12:58:31 <Peaker> sum = {-# SCC "sum" #-} foldl' (+) 0    <-   would this work the same as eta-expanded form would?
12:58:38 <Peaker> what's the precedence of cost-centre annotations?
12:59:51 <Cale> Peaker: hmm... you might just be annotating a CAF there
13:00:18 <Peaker> Annoying to eta-expand everything when profiling :(
13:01:29 <Peaker> Also, if I have an SCC on an IO action, what is measured exactly? Evalution of the IO action? its execution afterwards?
13:01:54 <Peaker> I don't think any of the profiling guides make all these important details explicit
13:03:41 <Cale> Peaker: Yeah, that's a good question. I would expect it to be just the time spent doing reduction, but GHC's implementation of IO blurs the lines between evaluation and execution there -- though it's not clear if there's anywhere you could put an annotation to count that, or if it's impossible to avoid counting it. Shouldn't be too hard a question to answer though -- try profiling something which does threadDelay perha
13:03:41 <Cale> ps.
13:04:01 * hackagebot mainland-pretty 0.4.1.0 - Pretty printing designed for printing source code.  https://hackage.haskell.org/package/mainland-pretty-0.4.1.0 (GeoffreyMainland)
13:04:13 <torei> NO
13:04:20 <Peaker> Cale: I think it measures CPU time and not wall-time
13:04:25 <torei> NO
13:04:28 --- mode: ChanServ set +o geekosaur
13:04:44 --- kick: torei was kicked by geekosaur (torei)
13:04:55 --- mode: geekosaur set -o geekosaur
13:04:58 --- mode: ChanServ set +o geekosaur
13:06:26 <shachaf> Is this some sort of Turing test? I can't tell whether this is a bot or a 2-year-old.
13:07:05 * geekosaur had that thought also....
13:08:18 <Peaker> If I use: -caf-all, and I have foo x = x * 2         it is equivalent to: foo = {-# SCC .. #-}\x -> x * 2       and not:  foo x = {-# SCC .. #-}x * 2    right?
13:09:01 * hackagebot GeneralTicTacToe 0.1.0.1 - A general TicTacToe game implementation.  https://hackage.haskell.org/package/GeneralTicTacToe-0.1.0.1 (afonsomatos)
13:10:55 <Zemyla> I kind of want class (Monad m, MonadIO mio) => MonadSTM mio m | m -> mio, mio -> m where { liftSTM :: STM a -> m a; atomically :: m a -> mio a }
13:12:15 <bitemyapp> Zemyla: if you squint really hard...monad-control?
13:12:22 <bitemyapp> Zemyla: or is that undoable in terms of monad-control?
13:12:28 <johnw> Zemyla: http://hackage.haskell.org/package/monad-stm-0.1.0.2/docs/Control-Monad-STM-Class.html
13:12:39 <johnw> gives you liftSTM, though not atomically
13:12:41 <bitemyapp> well there's one part of it.
13:12:44 <catgocat> I created a Data\List\Utils.hs.. how do I include it in my executable haskell package?
13:13:04 <bitemyapp> catgocat: I have examples here: http://howistart.org/posts/haskell/1
13:13:12 <Zemyla> Yeah, but I want to use atomically without having to tear down the entire frigging monad.
13:14:07 --- mode: geekosaur set -o geekosaur
13:14:20 * geekosaur will keep an eye on the bot(?)
13:14:24 <geekosaur> sheesh
13:14:31 <Peaker> If I have a static map of global names I want to look up, it doesn't change much. Names are Text. Is unordered-containers HashMap faster?  Is there any O(1) lookup hash table anywhere?
13:15:59 <johnw> Peaker: if you assign consective integers to your names, and then use those integers instead of the names, you can get O(1) lookup from a Vector
13:16:46 <Peaker> johnw: I go over each global once as it is -- so this assignment would cost the same I think
13:19:02 * hackagebot srcloc 0.5.1.0 - Data types for managing source code locations.  https://hackage.haskell.org/package/srcloc-0.5.1.0 (GeoffreyMainland)
13:19:09 <geekosaur> I think the only way you get O(1) hash lookup is by precomputing hashes...
13:19:31 <mniip> template haskell!
13:19:40 <hodapp> just say no!
13:19:57 <johnw> you could probably write a perfection hash function in TH, that would be cool for some things...
13:19:58 <quchen> Peaker: O(1) is meaningless in practice. Constant lookup time matters more. /nitpick
13:20:01 <johnw> perfect*
13:20:01 <quchen> Also: profile it
13:20:38 <quchen> And what matters most even is fast lookup time.
13:20:41 <Peaker> well, if you take a hash table that has 2x entries than the number of items, you get 0.5 item / bucket on average. <1 item / non-empty bucket aveage.  A very low average collision count.  It requires 2 cache misses for almost all accesses
13:22:03 <_cball> When importing standard modules like Data.Map, why doesn't haskell automatically use import qualified when it sees duplicate functions like filter? Also, why did the language developers create duplicate function names in their standard libs? :P
13:22:19 <_cball> I'm pretty new to haskell so sorry if that's a dumb question
13:23:05 <quchen> _cball: You can always refer to imported things using fully qualified names. "Data.Vector.length (fromList [1..10]) for example.
13:23:24 <quchen> _cball: But it's much more common to import things with short qualifiers, such as "V" for Vector.
13:23:26 <indiagreen> _cball: ideally we'd have functions like Map.lookup and so on as class methods, but it hasn't happened yet and might not happen for quite some time (there are some packages which give you these functions as class methods, tho, such as classy-prelude)
13:23:43 <johnw> indiagreen: or, use lens
13:23:56 <quchen> I don't think we'd ideally like to have everything in classes.
13:23:59 <indiagreen> johnw: lens is really orthogonal to that
13:24:10 <_cball> quchen: understood, that makes sense I think!
13:24:14 <johnw> yes, but it achieves much the same purpose as many typeclasses do, without typeclasses
13:24:24 <johnw> traversals without Traversable, folds without Foldable, etc.
13:24:32 <johnw> but still just as generic
13:24:35 <indiagreen> johnw: lens uses typeclasses for everything
13:24:44 <indiagreen> Cons, Snoc, Ixed, etc
13:24:53 * shapr ixes indiagreen's typeclasses
13:24:56 <indiagreen> it's just that class methods are lenses instead of pure functions
13:25:01 <quchen> _cball: And the duplicate functions exist because they all do similar things, and giving each one a separate name would be very confusing. Practical example: "size" for Set, but "length" for lists and vectors.
13:25:03 <ReinH> There are alternate preludes that offer typeclasses for everything
13:25:06 <johnw> Traversal only needs Applicative, I believe; but I grant that lens uses other typeclasses, like FieldN, etc.
13:25:52 <johnw> what I mean to say is, lens is a great "interface to data", when you don't care about the exact structure around the data you're interested in
13:26:05 <Hijiri> lenses are pure functions
13:26:22 <johnw> someMapLikeThing ^. at key.non dflt
13:26:25 <quchen> It takes some practical experience with lots of classes with little laws to develop a natural distaste for them.
13:26:32 <indiagreen> Hijiri: I meant “pure” not in the “pure vs. IO” sense (sorry for being confusing)
13:26:48 <Hijiri> well maybe I meant "pure cat" in the "cats that aren't orange" sense
13:27:46 <torei> Ah crap sorry, I was working on a bot for IRC and I didn't realize it was posting in this channel
13:28:17 <quchen> #haskell-bottest is a good channel for that.
13:28:50 <torei> Thanks I apologise agian I didn't realise it was causing a disruption
13:29:13 <indiagreen> Hijiri: can you recommend a better word? I'm trying to think of one but not really succeeding (“normal functions” and “usual functions” don't seem to be better alternatives)
13:29:44 <johnw> torei: it was turing testing us
13:29:55 <Welkin> johnw: NO
13:30:07 <johnw> yeah, I think we were all failing
13:30:07 <kurt21> Can someone convert this super simple pseudo-code to Haskell: http://lpaste.net/137934
13:30:24 <kurt21> I wrote in imperative pseudo code, not in Haskell, obviously
13:30:36 <johnw> kurt21: why don't you try it, and we'll help with the result
13:30:52 <johnw> just signing us up for work usually don't achieve much
13:33:18 <Hijiri> indiagreen: I'm sorry, I don't actually know of a good alternative, but I think it wouldn't make sense to overload "pure"'s meaning like that
13:33:28 <kurt21> johnw: roughly how would I adapt that code snippet to the Haskell paradigm of no mutable state?
13:33:37 <Hijiri> since there isn't a clear distinction, maybe an equally ambiguous word like "simple" would work
13:33:38 <johnw> kurt21: use the State monad is one way
13:33:55 <johnw> or just make it a function from SomeState -> (Result, SomeState), which is the State monad
13:34:26 <johnw> (doing the latter might give you an intuition of why the State monad is so nice)
13:34:43 <Hijiri> I would just say the class methods are lenses (and not say that they're instead of some kind of normal function)
13:35:09 <johnw> indiagreen: what is the exact distinction you're trying to make?
13:35:30 <johnw> indiagreen: functions with only explicit arguments?
13:37:02 <indiagreen> johnw: I'm afraid I don't have a good definition for the concept I have in my head, which goes kinda like “okay, uh... I meant, y'know. Functions. Ordinary functions that we're used to, like “lookup” for lookup, and “head” for head, and “second” for changing the 2nd element of a pair, stuff like that”
13:37:03 <dejanr> hello, one question, for someone comming from other programming world, like php, ruby, javascript, nodejs, with 10 years in web development experience, how long would take to feel productive and conformable in building web related stuff, i really like the nixos, hydra, and other tooling around nixos 
13:37:18 <johnw> indiagreen: as opposed to?
13:37:20 <dejanr> in haskell
13:37:42 <maerwald> dejanr: 1-1.5 years if you have no FP experience
13:38:15 <Peaker> I think a few months if there's a mentor nearby
13:38:22 <maerwald> I doubt it
13:38:24 <indiagreen> as opposed to lenses which cleverly combine a getter and a setter into one function
13:38:40 <Zemyla> What exactly does alwaysSucceeds in STM mean?
13:38:45 <maerwald> he said "feel productive". The basics already take a few months and after that you don't feel productive
13:38:55 <indiagreen> quchen: okay, I agree, but ideally-ideally we'd also have laws for our new classes and so it wouldn't be “classes with no laws, provided just for convenience” anymore (of course, I've no idea how many functions from Data.Map can actually be turned into good class methods with laws attached to them)
13:39:03 * hackagebot extra 1.4.1 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.4.1 (NeilMitchell)
13:39:17 <johnw> indiagreen: but lenses are just functions...
13:39:28 <osa1> does anyone have any ideas why GHC is giving a warning in first case here: http://lpaste.net/137937 ?
13:39:30 <dejanr> any common path in advancing in haskell, any recommended books?
13:39:32 <johnw> indiagreen: maybe first-order functions is what you mean by "normal functions"
13:39:36 <Hijiri> if it means anything, there's a class method Traversal in base (traverse)
13:40:47 <indiagreen> johnw: “first-order functions” isn't as confusing but is likely to simply not be understood at all
13:41:02 <johnw> indiagreen: you mean more than what you've been describing so far? :)
13:41:22 <johnw> functions are functions
13:41:22 <quchen> kurt21: You can translate that pretty directly to Haskell, but it's going to be awful and unidiomatic. http://lpaste.net/137936
13:41:45 <johnw> there are functions that require LANGUAGE extensions to write, those are a bit more special
13:41:54 <sbrg> kurt21: https://gist.github.com/5271254022dcadb0d929
13:42:00 <johnw> and some accept implicit arguments given through constraints
13:42:10 <johnw> but otherwise, they're all "normal functions"
13:42:13 <quchen> indiagreen: Even then there are too many things that would not fit or barely not fit that class. Vectors have length, lists don't necessarily.
13:42:42 <quchen> indiagreen: Lookup in Maps is decidable, in lists it is not.
13:42:56 <quchen> (Assuming sufficiently strict elements.)
13:43:08 <Cale> Zemyla: Executing alwaysSucceeds x will cause x to be executed before the current and all subsequent transactions commit. If x throws an exception, it will be propagated and cause the transaction to fail.
13:43:19 <johnw> quchen: how it is not decidable?  do you mean for infinite lists?
13:43:23 <Cale> Zemyla: I believe this paper is the one which describes it in detail (as "check") http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm-invariants.pdf
13:43:23 <quchen> johnw: Yes.
13:43:41 <quchen> johnw: "1 `elem` repeat 2"
13:44:08 <catgocat> What is the difference between Library and Executable in the cabal package?
13:44:16 <Peaker> maerwald: with a mentor, the basics take a week or two
13:44:23 <maerwald> I disagree
13:44:39 <Cale> Zemyla: none of the effects on TVars and other STM mutable state caused by x will actually occur, even if x succeeds.
13:44:52 <johnw> Peaker: with no FP background?  no way
13:45:10 <quchen> indiagreen: One thing I *do* like about Clojure is its conj operator, which promises "a fast insertion operation" and nothing else. For singly-linked lists it's prepend since that's fastest. For Vectors it's writing to the next preallocated memory cell. For Set it's normal insert.
13:45:25 <catgocat> Can anyone help me please?
13:45:36 <Cale> Zemyla: (it will occur locally to x, but x runs in a nested transaction that gets rolled back unconditionally, so the only impact it gets to have is deciding whether or not to produce an exception)
13:45:38 <johnw> catgocat: I advise you to browse the Cabal documentation
13:45:49 <quchen> catgocat: An executable is a file you can run on its own. A library is something you write Haskell programs with.
13:45:49 <catgocat> johnw: that's not good for starting
13:45:56 <Hijiri> catgocat: Libraries export modules that you can import from outside the package, Executables compile a program. You can have multiple executables but only one library
13:46:00 <catgocat> quchen: can't I have both
13:46:01 <johnw> it will answer that question, for sure
13:46:06 <quchen> Sure you can.
13:46:22 <catgocat> so if I want both, do I put Executable or Library in the cabal file
13:46:30 <Hijiri> you put separate sections for both
13:46:47 <quchen> johnw: Sure, the information is there, but that doesn't mean it's easy to find for a beginner. Reading the Cabal manual is not a lot of fun if you're trying to build your first project.
13:47:12 <quchen> johnw: When you buy a new car you don't read the entire manual first either. :>
13:47:45 <johnw> quchen: if the alternative is asking 1500 people every question that comes up, then at least *browsing* the documentation first is recommended
13:47:57 <quchen> catgocat: You can even depend on the library in the executable even
13:48:02 <johnw> and I do actually read the entire manual whenever I get a new car
13:48:02 <Hijiri> well, packaging systems don't have standardized config files, in the same way cars have steering wheels and gas pedals
13:48:15 <johnw> that's how I learned that I changed when my auto-lock engages
13:48:31 <johnw> otherwise, I would have never known that feature was even possible
13:48:38 <quchen> …
13:48:51 <quchen> Stop making a counterpoint, it makes my argument harder!
13:48:52 <catgocat> Ok, I have made a cabal file
13:49:04 * hackagebot shake 0.15.5 - Build system library, like Make, but more accurate dependencies.  https://hackage.haskell.org/package/shake-0.15.5 (NeilMitchell)
13:49:31 <catgocat> quchen: If I am creating a library, where do I put my files at in the root of my cabal project? Do I need do make a Data\List\Stuff.hs file?
13:50:02 <quchen> catgocat: You can create an arbitrary dir and then declare that to be the source folder of your library.
13:50:20 <quchen> There's some setting for that. hs-source-dir or something.
13:50:43 <catgocat> quchen but what is the convention?
13:50:52 <quchen> catgocat: "src/*"
13:51:00 <catgocat> quchen I mean I am not going to create a Baby\Doll.hs
13:51:18 <Hijiri> if src is your source dir, you will need src/Baby/Doll.hs (for Baby.Doll module)
13:51:26 <quchen> Depends on your library. "Data.Text" handles data that represents Text.
13:51:35 <catgocat> quchen and my test files also go there?
13:51:44 <johnw> catgocat: https://www.haskell.org/cabal/users-guide/developing-packages.html
13:51:49 <johnw> answers just about everything you're asking right now
13:51:55 <catgocat> johnw: I have read it
13:52:10 <catgocat> wait not that one
13:52:24 <quchen> catgocat: Your testsuite is usually in a different folder, often test/.
13:52:33 <catgocat> quchen ok got it
13:52:44 <quchen> You then define a testsuite build target in your .cabal file.
13:53:08 <johnw> catgocat: see also http://bob.ippoli.to/archives/2013/01/11/getting-started-with-haskell/
13:53:19 <johnw> and https://howistart.org/posts/haskell/1
13:53:27 <johnw> and http://jabberwocky.eu/2013/10/24/how-to-start-a-new-haskell-project/
13:53:53 <catgocat> quchen: where can I put helper functions? for example, I create a function that I think is related to Data.List
13:53:58 <johnw> I googled for "getting started with cabal", and there are many more links like those
13:55:46 <catgocat> I don't understand.......... :/ The parsec library for example has a folder Text
13:55:58 <catgocat> and it says module Text.Parsec from..
13:56:02 <catgocat> so where is the src folder?
13:56:15 <quchen> The source folder can be "." as well.
13:56:41 <quchen> (I think that's the default.)
13:57:06 <Herogx> Anyone able to explain the recursive element of this function?: factorials = 1: zipWith (*) factorials [1..]
13:57:08 <catgocat> Just answer me this please: I am creating an executable package, where do I put helper functions??????????????
13:57:18 <quchen> catgocat: The pipes package is an excellent example of a simple and practical .cabal file.
13:57:21 <quchen> http://hackage.haskell.org/package/pipes-4.1.6/pipes.cabal
13:57:40 <Herogx> I wrote it a while ago but I'm struggling to understand how it works again, or rather I should say that I am having trouble tracing it through each frame
13:57:47 <catgocat> I wish you could answer my question
13:57:55 <catgocat> I am creating an executable package, where do I put helper functions??????????????~
13:58:09 <Herogx> wherever it makes sense to do so...?
13:58:10 <quchen> Sorry my connection doesn't work with more than one "?" in a row
13:58:34 <catgocat> ah nevermind
13:58:35 <sccrstud92> > repeat '?'
13:58:37 <lambdabot>  "???????????????????????????????????????????????????????????????????????????...
13:58:40 <johnw> Herogx: thinks of the recursive call to factorials not as a call, but a reference to the value that that call will produce when needed.  Thus, the call returns immediately, but as you start consuming the values from the list, it will cause another call to happen, resulting in a stream of those values in place of "factorials".  Is that any clearer?
13:59:23 <johnw> i.e., 1 : zipWith (*) (1 : zipWith (*) (1 : ...) [1 ..]) [1 ..]
13:59:34 <johnw> as many times as needed, based on how many elements of the result you actually need
14:00:16 <Herogx> I am struggling to understand how the third and fourth elements are obtained if I write take 4 factorials
14:00:31 <Herogx> I understand lazy evaulation comes into play and such
14:00:31 <johnw> expand out the definition by hand, down 4 elements
14:04:42 <Herogx_> Sorry, internet issues
14:04:52 <Herogx_> I missed any messages you forwareded after my lats question
14:04:54 <Herogx_> last*
14:05:16 <quchen> <johnw> expand out the definition by hand, down 4 elements
14:05:19 <quchen> Just the one
14:05:23 <Herogx> oh I see
14:05:30 <Herogx> I suppose I should give it another crack
14:05:51 <quchen> Herogx: It's not just a beginner's exercise, that way of reasoning about code is very common in Haskell.
14:06:19 <Herogx> I understand recursion and the like pretty well, just the way that one function works doesn't really click for me
14:07:10 <sbrg> kurt21: did that answer your question?
14:08:25 <mniip> Herogx, it's not even a function
14:08:34 <mniip> it's a value
14:09:16 <Herogx> I know
14:10:18 <mniip> Herogx, you can reason about it like this
14:10:30 <mniip> 4th element of 'factorials' is 3rd element of 'zipWith (*) factorials [1..]'
14:10:49 <mniip> which is 3 * (3rd element of factorials)
14:11:08 <mniip> which is 3 * (2nd element of 'zipWith (*) factorials [1..]')
14:11:10 <mniip> and so on
14:11:54 <Herogx> ah I get it now
14:12:12 <Herogx> I was ignoring the iteration of the first infinite list I think
14:12:51 <mniip> from a mathematical standpoint,
14:12:58 <mniip> if we take a sequence of factorials
14:13:09 <mniip> and multpily each factorial with its index
14:13:18 <mniip> and then prepend 1 to the sequence, we will get the original sequence
14:13:47 <mniip> this doesn't explain the fact that our calculation terminated, but proves that if it does, it is going to indeed be a list of factorials
14:13:52 <mniip> terminates*
14:14:04 <Herogx> I'm only just getting that now, thank you
14:14:12 <Herogx> I never spotted the index relationship
14:17:03 <Herogx> I get it completely now thank you, just the value to be worked out really helped, thank you johnw :)
14:19:26 <johnw> Herogx: sure thing :)
14:25:02 <kuribas> what is the right way to emit warnings without crashing?
14:25:13 <kuribas> unsafePerformIO?
14:25:29 <mauke> hPutStrLn stderr "This is your last warning."
14:26:23 <kuribas> :t hPutStrLn stderr "This is your last warning."
14:26:24 <lambdabot>     Not in scope: ‘hPutStrLn’
14:26:25 <lambdabot>     Perhaps you meant one of these:
14:26:25 <lambdabot>       ‘BS.hPutStrLn’ (imported from Data.ByteString),
14:27:04 <kuribas> :t unsafePerformIO $ BS.hPutStrLn stderr "This is your last warning."
14:27:05 <lambdabot> Not in scope: ‘unsafePerformIO’
14:27:06 <lambdabot> Not in scope: ‘stderr’
14:29:06 * hackagebot io-streams 1.3.2.0 - Simple, composable, and easy-to-use stream I/O  https://hackage.haskell.org/package/io-streams-1.3.2.0 (GregoryCollins)
14:37:00 <hiptobecubic> ely-se, how far did you get with that brainfuck compiler? Have you looked it at recently?
14:37:14 <ely-se> What brainfuck compiler?
14:37:31 <ely-se> I only ever wrote one brainfuck compiler and that was one in D which ran at compile-time.
14:38:14 <hiptobecubic> Oh. Hmm. Must not have been you :D My mistake! Carry on.
14:38:40 <sabraham> [~/personal/misc_code]$ghci GHCi, version 7.10.1: http://www.haskell.org/ghc/  :? for help Prelude> import Test.QuickCheck Prelude Test.QuickCheck> let prop_reverse_wrong xs ys = (reverse xs ++ reverse ys) == reverse (xs ++ ys) Prelude Test.QuickCheck> quickCheck   prop_reverse_wrong +++ OK, passed 100 tests.
14:38:51 <hiptobecubic> Aha! It was exio4  :)
14:39:16 <lpaste_> sabraham pasted “why isn't quickCheck failing this property” at http://lpaste.net/137943
14:39:53 <sabraham> can anyone look at this ^
14:40:02 <mauke> sabraham: you're testing lists of type [()]
14:40:03 <sabraham> please
14:40:08 <johnw> sabraham: yeah, I was just going to say
14:40:11 <exio4> hiptobecubic: hi?
14:40:13 <johnw> Quickcheck like to default to unit
14:40:22 <johnw> tell it that xs is [Int]
14:40:27 <hiptobecubic> exio4, hi.
14:41:11 <sabraham> thank you @mauke @johnw
14:41:57 <exio4> hiptobecubic: did not do much, sadly
14:42:50 <eacameron> anyone know of a good SLOC counter for Haskell?
14:42:56 <eacameron> SLOCCount is out for me
14:45:09 <Peaker> I have a monad like:  newtype Infer s a = Infer (Env s -> ST s a) ; and an action like: infer :: V -> Infer s InferResult ; infer (V v) = {-# SCC "infer" #-} ...   the "cumulative" time of "infer" lies, why?
14:45:24 <Peaker> is it because the "Env ->" hides all the work from the SCC?
14:45:58 <johnw> that cost center won't include the time spent evaluating V
14:46:35 <Peaker> V is cheap to evaluate though -- I know that the actions called by "infer" take >10% of the time (their SCCs say so) but "infer"s cumulative is 1.4(?!)
14:47:10 <Peaker> oh, sorry, it seems I misintereted the data
14:49:51 <osa1> does anyone know a package that parses Haskell concrete syntax and generates TH ASTs?
14:50:17 <osa1> haskell-src-exts-qq doesn't parse declerations
14:59:07 * hackagebot Frames 0.1.2.1 - Data frames For working with tabular data files  https://hackage.haskell.org/package/Frames-0.1.2.1 (AnthonyCowley)
14:59:15 <dfeuer> Why does text take so long to compile?
14:59:15 <kurt21> @sbrg: thank you so much!!!
14:59:16 <lambdabot> Unknown command, try @list
14:59:40 <kurt21> quchen: thank you as well. that is very helpful
14:59:54 <ubuntu_irc_guy> hello
15:00:04 <kurt21> sbrg: thank you so much!!!
15:02:07 <fr33domlover> Does GHC do common subexpression elimination? e.g. in "(f x y, f x z)" does "f x" get computed just once?
15:02:59 <comprehension> hey all
15:03:41 <arkeet> fr33domlover: no
15:03:51 <comprehension> i'm trying to unit test my lexer, written in Alex. how can i run it over a string to get back a list of tokens, rather than a single token?
15:04:00 <comprehension> using the monad wrapper
15:04:23 <arkeet> fr33domlover: doing so may lead to more memory usage.
15:04:29 <comprehension> i.e. i have "foo bar" that i want to lex to [TokenFoo, TokenBar]. but runAlex has the type String -> Either String Token
15:05:00 <osa1> arkeet: it's doing that in some cases though, it's not like it never does CSE
15:05:07 <osa1> arkeet: (I don't remember the exact rules for it)
15:05:13 <fr33domlover> arkeet, how about (f (h x), g (h x)) - even then it doesn't?
15:05:28 <arkeet> fr33domlover: no.
15:05:31 <fr33domlover> I want to figure out if it's worth hand-optimizing it in my code
15:05:43 <fr33domlover> or let the compiler do that :P
15:06:05 <fr33domlover> arkeet, thanks. Why does it use more memory though?
15:06:14 <Peaker> I think I've seen GHC sometimes do CSE (maybe old versions)
15:06:24 <arkeet> it *can*, in certain situations.
15:06:52 <osa1> arkeet, Peaker, fr33domlover, this may be relevant https://github.com/ghc/ghc/blob/c5911479f295242e16e396eb5d1369f2e4ce8de0/compiler/simplCore/CSE.hs
15:07:19 <osa1> fr33domlover: it doesn't use more memory, it increases residency
15:07:33 <osa1> fr33domlover: let me come up with an example
15:08:36 <osa1> fr33domlover: let's say we have this: sum [1 .. 1000] + sum [-1000 .. -1] + prod [1 .. 1000]
15:08:56 <osa1> assume no loop fusion is happening
15:09:07 * hackagebot haste-compiler 0.5.0 - Haskell To ECMAScript compiler  https://hackage.haskell.org/package/haste-compiler-0.5.0 (AntonEkblad)
15:10:20 <osa1> while evaluating this, you can allocate first list, run sum on it, deallocate and do the same for second etc. at any point you'll have one list allocated
15:11:01 <osa1> but now assume this CSEd form: let x = [1..1000] in sum x + sum otherLIst + sum x and assume two sums are not CSEd (for some reason)
15:11:13 <osa1> now you need to keep two lists allocated while evaluating sum otherList
15:11:17 <osa1> so residency is increased
15:11:24 <Peaker> how does GHC compile pattern matches? Will a pattern match on 3 constructors be noticeably slower than one on 2?
15:11:25 <osa1> I hope I get it right :)
15:11:36 <arkeet> https://wiki.haskell.org/GHC/FAQ#Does_GHC_do_common_subexpression_elimination.3F
15:13:30 <dfeuer> The documentation for Data.Functor.Rep.Representable indicates that every Distributive Functor is Representable, but doesn’t explain why; it also doesn’t have a default implementation, which suggests it’s not valid within Haskell. Could someone explain what that’s about?
15:14:32 <dfeuer> Cale, maybe, or edwardk?
15:14:41 <dfeuer> Or … anyone else.
15:15:02 <fr33domlover> arkeet, osa1, thanks
15:15:20 <arkeet> fr33domlover: consider sum ([1..10000] ++ [1..10000])
15:16:13 <arkeet> without cse, it would be able to gc the parts of the lists that get consumed as they are produced
15:16:18 <arkeet> but if you share the two lists
15:16:23 <arkeet> then at some point it has to hold the entire list in memory
15:17:51 <johnw> arkeet: great example
15:19:48 <ReinH> fr33domlover: if you want sharing, bind the common expressions to the same name
15:20:46 <dfeuer> Hmm… Maybe ReinH knows the sense in which Distributive implies Rep.
15:20:57 <ReinH> dfeuer: link?
15:21:09 <dfeuer> ReinH: https://hackage.haskell.org/package/adjunctions-4.2.1/docs/Data-Functor-Rep.html
15:21:14 <johnw> dfeuer: https://www.fpcomplete.com/user/edwardk/moore/for-less
15:21:17 <arkeet> http://hackage.haskell.org/package/distributive-0.4.4/docs/Data-Distributive.html
15:21:19 <dfeuer> er .. I mean Representable, not Rep.
15:21:21 <johnw> see the section "Distributive Functors, Represent!"
15:21:29 <dfeuer> Thanks, johnw!
15:23:28 <johnw> so he's kind of saying they are the same thing, only Distributive is the form it took before he had type families (and so hid the representing object)
15:23:45 <dfeuer> johnw: that still doesn’t show the sense in which every Distributive functor is Representable.
15:23:50 <dfeuer> If it’s true.
15:26:44 <fr33domlover> ReinH, thanks. That's what I'll do. It just requires splitting a function into 2 and it's less elegant etc., so I wondered is GHC would do this for me and let me have more concise code :)
15:27:12 <fr33domlover> anyway, no big deal
15:28:44 <johnw> dfeuer: distribute = tabulate . distribute . fmap index
15:28:53 <johnw> where the inner distribute is using ((->) e)
15:29:12 <ttt_fff> does anyone have a good list of haskell pickup lines? I want lines where (1) I can broadcast in public and (2) only haskelelrs will get it and (3) imperative programming langauge users will not get it
15:29:13 <dfeuer> johnw: that goes the other way.
15:29:15 <dfeuer> er ..
15:29:18 <dfeuer> or something?
15:29:20 <dfeuer> No.
15:29:24 <dfeuer> What do you mean, johnw?
15:29:36 <johnw> instance Representable f => Distributive f where
15:29:38 <Luke> carter: thanks for your work on the brew ghc and cabal-install packages
15:29:38 <johnw>     distribute = tabulate . distribute . fmap index
15:29:53 <Luke> carter: working really well so far
15:29:54 <johnw> now let me try the other direction
15:30:02 <Luke> carter: there aren't any brew (cask) binary installs for ghc are there?
15:30:11 <dfeuer> I have serious doubts about the other direction.
15:32:23 <Zemyla> :t fmap index
15:32:24 <lambdabot> (Functor f, Ix a) => f (a, a) -> f (a -> Int)
15:32:33 <Zemyla> :t tabulate
15:32:34 <ReinH> Luke: doesn't brew install ghc install a binary?
15:32:35 <lambdabot> Not in scope: ‘tabulate’
15:32:40 <Luke> no
15:32:43 <Luke> ReinH: not for me.
15:33:51 <ReinH> then... no?
15:34:57 <Luke> ReinH: no it installed and built form source when I did "brew install ghc"
15:35:10 <Luke> ReinH: brew is typically for source packages
15:35:18 <Luke> ReinH: brew cask is for binary distribution
15:35:54 <Luke> https://github.com/Homebrew/homebrew/blob/master/Library/Formula/ghc.rb
15:36:28 <Luke> looks like there may be a way to get a binary install
15:37:03 <Luke> ReinH: not sure how though
15:37:41 <johnw> dfeuer: I'm not sure this works generically
15:37:49 <johnw> dfeuer: however, it may work for every choice of distributive functor
15:37:53 <Luke> ReinH: oh I think I know why. I'm on El Capitan 10.11. Doesn't look like it knows how to get the bin for that
15:38:11 <johnw> dfeuer: because to do it generically, I'd need to be able to pick the representing type without knowing anything about it
15:38:29 <johnw> dfeuer: that's why the other direction works, because then we do know and we're just erasing the knowledge
15:38:50 <dfeuer> johnw: that sounds like a likely explanation of why it’s not internally valid, or whatever the right term is for that.
15:39:06 <dfeuer> johnw: but I’m still curious whether/how it’s valid for all instances.
15:40:50 <comprehension> i have runAlex with the type "String -> Alex Token -> Either String Token". i'd like to be able to run it over a string and get back a list of tokens --- how can i change the Alex monad to do that?
15:41:00 <Sindriava> I've changed some code in a downloaded cabal package, and now I'm getting unsatisfied package-id, is there a way to circumvent this?
15:44:27 <kadoban> Sindriava: What's the actual error?
15:44:55 <Sindriava> kadoban: cannot satisfy -package-id sdl2-2.0.0-d62a351e84d14d917a0d55b11836044c
15:45:16 <Sindriava> kadoban: I've cloned the package and then did cabal sandbox add-source
15:47:43 <hexagoxel> Sindriava: have you `cabal configure`d? you cloned which package? what command spits out the error?
15:48:29 <johnw> dfeuer: "Categorically every Distributive functor is actually a right adjoint, and so it must be Representable endofunctor and preserve all limits. This is a fancy way of saying it isomorphic to `(->) x` for some x."
15:48:39 <Sindriava> hexagoxel: Yeah, I have configured. I cloned the `sdl2` package from git, and the command is `cabal run`, in the preprocessing executable stage (or after it)
15:49:16 <johnw> dfeuer: which means, for any given Distributive f, there is a representing object, and tabulate and index for that object form an isomorphism
15:50:25 <johnw> dfeuer: I would hazard to guess that nowadays when edwardk wants distributivity, he reaches for Representable
15:50:48 <johnw> which also explains why he didn't like a suggestion I made about monad composition in the presence of Distributive...
15:52:01 <dfeuer> johnw: what suggestion?
15:52:22 <dfeuer> Also, where’d tha text you quote come from?
15:52:25 <johnw> well, if you have a distributive N under an M, and both are monads, then the composition is a monad
15:52:33 <johnw> the quote is from the docs for Data.Distributive
15:52:47 <dfeuer> Huh. I don’t know this theory.
15:52:49 <dfeuer> :/
15:52:50 <johnw> or maybe it's a distribute M over an N
15:53:16 <johnw> the ability to map G (F (G (F x))) -> G (F (F (G x))) for any two monads G and F, gives you a monad
15:53:26 <johnw> so now I know I can do this with representability too
15:54:00 <hexagoxel> Sindriava: i am pretty certain that `run` would never output that immediately after a successful `configure`
15:54:24 <Sindriava> hexagoxel: ¯\_(ツ)_/¯
15:54:28 <Sindriava> hexagoxel: I'll try again.
15:55:08 <Sindriava> hexagoxel: Yeah, it works now, maybe I missed a step, or the configure didn't run until the end
15:55:13 <Sindriava> hexagoxel: Thanks :)
15:55:53 <NemesisD> i'm getting a non-exhaustive pattern match error from some code generated by TH, so the line number is a range. is there any way to get the error to correspond to the line number of the generated code, or give me a better excerpt?
15:59:20 <catgocat> I am trying to use the detailed-0.9 testsuite but I get the error:
15:59:21 <catgocat> Module `Distribution.Simple.Test' does not export `stubMain'
16:01:27 <hexagoxel> Sindriava: the reconfigure is necessary whenever you modified the add-source-dep. should in theory be automatic; sometimes cabal is weird.
16:01:54 <Sindriava> catgocat: You probably wrote "import Distribution.Simple.Test (stubMain)" somewhere and `stubMain` is exported by another module
16:02:07 <catgocat> Sindriava I didn't write stubMain anywhere
16:03:08 <Sindriava> catgocat: Unless it's your code, then the dependency is broken and doesn't build with your version of GHC and/or other dependencies. Try to constrain version numbers of dependencies, see if that helps
16:03:42 <catgocat> I created a exitcode testsuite
16:03:46 <catgocat> now I am trying detailed-0.
16:03:47 <catgocat> 0.9
16:04:09 <catgocat> Here is my cabal file: http://lpaste.net/137946
16:05:15 <catgocat> TEST FILES + CABAL > http://lpaste.net/137946
16:05:23 <catgocat> error: Build FAILED  C:\Users\afons\Documents\Programming\Haskell\Cabal-test\dist\build\TestCorrectStub\TestCorrectStub-tmp\TestCorrectStub.hs: line 2, column 1:   Module `Distribution.Simple.Test' does not export `stubMain'
16:05:58 <johnw> dfeuer: to whit: https://gist.github.com/66e0b9bb545964b88eb7
16:08:14 <dfeuer> Thanks, johnw.
16:08:33 <dfeuer> johnw: I’ll admit I don’t understand that yet, but I will eventually, I imagine.
16:08:36 <dfeuer> Oh....
16:08:56 <dfeuer> johnw, is that sort of turning it into ReaderT?
16:13:01 <johnw> dfeuer: that's effectively what representability is
16:13:12 <ttt_fff_> if an app is pure haskell, is there any reason to take sqlite over persistent + querying in haskell ?
16:13:14 <dfeuer> Weird stuff.
16:13:23 <johnw> given some f a, it's isomorphic to Reader r a if you can pick such an r
16:23:54 <aupiff_> how can I make stack rebuild my packages when there have been local changes
16:24:19 <aupiff_> `stack build` does not have the same behaviour as `cabal build`
16:25:22 <chreekat> ttt_fff_: persistent is specifically for haskell apps using a db. Its goal is to make everything as DRY as possible in terms of marshaling data from code to db and ensuring the two don't get out of sync
16:25:41 <chreekat> aupiff_: At first blush, it sounds like 'stack build' should be what you want. What's not working precisely?
16:27:00 <aupiff_> chreekat: I am making changes to my code, but when I run `stack build`, nothing is rebuilt.
16:27:44 <chreekat> something's going screwy, then
16:28:26 <catgocat> What is the bang-pattern and why is it illegal?
16:28:30 <catgocat> > let !q = fib 34
16:28:32 <lambdabot>  <no location info>: not an expression: ‘let !q = fib 34’
16:28:40 <catgocat> @define !q = 3
16:28:41 <lambdabot>  .L.hs:154:1:
16:28:41 <lambdabot>      Top-level bang-pattern or unboxed-tuple bindings aren't allowed:
16:28:41 <lambdabot>        !L.q = 3
16:29:52 <johnw> dfeuer: another way of thinking of it is that for a representable functor f, there's a object which fully describes its "shape".  For example, I could use tuples of finite integers to identify where all the 'a's are in any ADT, but representing the index of the constructor, and the list of indices where it appears in the arguments to that constructor
16:30:06 <johnw> s/but/by
16:30:11 <arkeet> catgocat: it only makes sense inside function arguments
16:30:53 <catgocat> arkeet: what explanation is that?
16:30:58 <catgocat> what makes `sense`?
16:31:02 <catgocat> sense in what sense?
16:31:36 <arkeet> well, they are only legal inside function arguments, because their purpose is to make the function strict in those arguments
16:32:22 <catgocat> not true..
16:32:27 <arkeet> ??
16:32:39 <dfeuer> johnw: how’s that explain it?
16:32:39 <catgocat> let !k = fib 30
16:32:40 <catgocat> works
16:32:53 <Sindriava> > let !k = sin 5
16:32:54 <lambdabot>  <no location info>: not an expression: ‘let !k = sin 5’
16:33:11 <johnw> dfeuer: I'm not sure now exactly which part needed explaining
16:33:25 <arkeet> well ok, that's not top level, but you still gain nothing
16:33:33 <geekosaur> top level bindings can't be strictified. let bindings can, because they are pattern matching (like function parameters are pattern matching)
16:33:42 <geekosaur> but a top level "q = 5" is not a pattern match
16:33:44 <Sindriava> catgocat: You might want to reconsider how you interact with other people.
16:34:17 <catgocat> `ghci -XBangPatterns`
16:34:28 <catgocat> let !k = sum [1..10^4]
16:34:37 <geekosaur> should I repeat myself?
16:34:43 <dfeuer> johnw: the bit about having an object describing the shape. How’s that relate to the representable thing? Isn’t that about expressing (f a) as a function picking out the a’s or some such, where that makes sense?
16:35:21 <catgocat> geekosaur: how are let bindings pattern matching?
16:35:27 <chreekat> catgocat: there are docs for that. https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/bang-patterns.html
16:35:37 <Sindriava> catgocat: How are they not?
16:35:39 <geekosaur> > let Just x = Just 5 in x
16:35:41 <lambdabot>  5
16:35:42 <johnw> dfeuer: making an example for you
16:35:44 <Sindriava> > let (a, b) = (0, 0)
16:35:45 <arkeet> > let x = undefined in ()
16:35:46 <lambdabot>  <no location info>: not an expression: ‘let (a, b) = (0, 0)’
16:35:46 <lambdabot>  <no location info>: can't find file: L.hs
16:35:48 <geekosaur> that's a let binding as a patrtern match
16:35:49 <arkeet> > let x = undefined in ()
16:35:51 <lambdabot>  ()
16:35:52 <arkeet> > let !x = undefined in ()
16:35:53 <lambdabot>  *Exception: Prelude.undefined
16:35:54 <geekosaur> > let Just x = Nothing in x
16:35:54 <johnw> dfeuer: yes, a function picking out the a's
16:35:55 <lambdabot>  *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Just x
16:36:01 <Sindriava> arkeet + 1
16:36:34 <geekosaur> notice that the exception even calls out the failure of a pattern match
16:37:11 <ReinH> dfeuer: so
16:37:14 <geekosaur> the "assignmet" form is just the trivial pattern that matches any value and binds it
16:37:16 <arkeet> catgocat: anyway, what exactly are you asking is illegal?
16:37:31 <ReinH> er, so you,re familiar with the general idea of representables?
16:37:57 <geekosaur> note also that the "let" that looks like a "statement" isn't actually a statement. (although ghci makes it look like one because ghci is a bit weird)
16:38:20 <arkeet> if I "let !x = undefined" in ghci that throws an exception right away.
16:38:40 <geekosaur> @undo do { let {Just x = Just 5}; print x }
16:38:40 <lambdabot> let { Just x = Just 5} in print x
16:38:49 <geekosaur> ^ turns into a let-in expression
16:39:42 <geekosaur> because "do" looks like a series of "statements" but is actually a single expression
16:42:45 <johnw> dfeuer: ignore my tuple comment, that isn't working out
16:44:11 * hackagebot shake-minify 0.1.4 - Shake Minify Rules  https://hackage.haskell.org/package/shake-minify-0.1.4 (LukeHoersten)
16:45:22 <johnw> dfeuer: let me know if this helps: https://gist.github.com/eed73e75530d6cae8a41
16:45:31 <johnw> ignore the fact that really that should be Fin 3, and not Int
16:46:21 <johnw> that should make it clearer that if you can write distribute, then there should be a Rep you can choose to write Representable
16:46:39 <johnw> because what else are you going to use with "fmap" in your definition of distribute
16:47:02 <mniip_> ಠ_ಠ
16:47:17 <johnw> I should have called those Zero, One and Two, to be clearer
16:48:03 <dfeuer> ReinH: no, I’m not.
16:48:54 <dfeuer> johnw: what’s with naming datatypes after people?
16:48:59 <mniip_> is there a sequential approach to learning all the fancy CT stuff?
16:49:08 <johnw> dfeuer: I ran out of Foo and Bar long ago
16:49:22 <ReinH> dfeuer: For example, data Pair a = Pair a a can be represented by Bool -> a, because there are two places where an a can be and the Bool selects which one it is.
16:49:39 <mniip_> like there is a commonly accepted sequence in which you learn the base typeclasses
16:49:59 <johnw> ReinH: yes, that's a simplified version of the same example I gave
16:50:04 <mniip_> does a similar thing exist for frees, comonads, and kan extensions?
16:50:12 <arkeet> maclane?
16:50:20 <ReinH> johnw: oh ok cool
16:50:48 <arkeet> awodey? any CT text?
16:51:31 <arkeet> but then one could say "all concepts are kan extensions" and then argue that you should learn about kan extensions first.
16:51:34 <arkeet> but not really.
16:52:07 <dfeuer> johnw: this stuff is weird.
16:52:10 <ReinH> The other concepts are there to buil dup to kan extensions
16:52:22 <ReinH> *build up
16:52:45 <dfeuer> ReinH: yeah, whatever those are :P
16:53:55 <ReinH> Easier to explain when you can draw diagrams
16:54:28 <dfeuer> ReinH: that sounds likely.
16:55:13 <mniip_> soo
16:55:26 <mniip_> any particular answer to my question?
16:57:27 <johnw> dfeuer: here's a cool picture at http://ncatlab.org/nlab/show/representable+functor
16:58:17 <johnw> the representing object U chooses among all possible paths to X, which is the same as the "shape" of the functor
16:58:42 <dfeuer> johnw: I think I’m going to have to try to understand this later. Too many distractions now.
16:58:52 <johnw> sorry for beating it into the ground
17:00:41 <dfeuer> johnw: it’s not you. It’s really me.
17:04:19 <ttt_fff> i need to use amazondb ; should I just use https://hackage.haskell.org/package/amazonka-dynamodb or is there something else I should look into?
17:14:09 <kadoban> ttt_fff: "Warning: This is an experimental preview release which is still under heavy development and not intended for public consumption, caveat emptor!"
17:14:23 <ttt_fff> kadoban: can you recommend something better?
17:14:42 <kadoban> ttt_fff: I recommend not doing whatever it is you're doing.
17:14:57 <ttt_fff> i'm currently looking for dynamodb bindings for haskell
17:15:02 <ttt_fff> what should I do instead?
17:15:28 <kadoban> Using a boring old database?
17:16:51 <ttt_fff> but I want webscale: https://www.youtube.com/watch?v=b2F-DItXtZs
17:17:06 <ttt_fff> kadoban: what do you have vs dynamodb ?
17:18:17 <kadoban> "web scale" *sigh*
17:19:06 <Herogx_> lol
17:19:41 <kadoban> ttt_fff: I don't even know wtf that video is … jesus. How does that video make you want to use whatever the hell?
17:20:09 <Herogx_> kadoban, pretty sure is trolling
17:20:14 <ttt_fff> kadoban: it's a video mocking the nosql crowd
17:20:38 <kadoban> ttt_fff: I see. Maybe I've avoided too much of that to really get the joke.
17:21:09 <ttt_fff> there's some serious issue where by default, mongodb, to win some benchmarks didn't flush or something, so writes were "only in memory" and did not persist to disk
17:21:43 <Herogx_> uh...they also use Math.random to decide if they should throw an exception or not
17:21:51 <Herogx_> "error at random" has never been more true
17:22:09 <fishythefish> To build on mniip_'s question, does anyone have recommendations on how to translate CT concepts into potentially useful Haskell concepts?
17:23:14 <fishythefish> For example, stuff like product and coproduct can be translated into tuple and Either in Haskell (or things isomorphic to them).
17:23:38 <fishythefish> But while I can understand things like representable functors mathematically, I struggle to see their applications in Haskell.
17:24:18 <kadoban> ttt_fff: I like my db stuff boring and less buzzwordy. I've yet to go wrong just using some sqlite or postgres. Especially when your only option appears to be some experimental unsupported binding to some wacky proprietary amazon thing … just *sigh*
17:24:26 <catgocat> Is -Wall available as an extension?
17:24:28 <mniip_> and I struggle to figure out where to begin learning all this stuff
17:24:44 <Intolerable> catgocat: why do you want that?
17:24:45 <kadoban> catgocat: What would that mean?
17:24:46 <mniip_> like I know what representable functors are but I feel like I'm missing a lot of underlying details
17:24:51 <catgocat> {-# Language Wall #-}
17:24:56 <ttt_fff> kadoban: how do you deal with scaling? the main benefit to me, of dynamodb ,and amazon rds, and amazon s3 is that I don't have to think about scaling
17:25:03 <Intolerable> {-# GHC_OPTIONS -Wall #-}
17:25:05 <mniip_> {-# OPTIONS_GHC -Wall #-}
17:25:15 <Intolerable> (one or the other)
17:25:17 <ttt_fff> kadoban: so I just focus on writing application level logic, and say "the database part is AMazon's fucking problem"
17:25:20 <mniip_> honestly I don't remember which
17:25:25 <Intolerable> me neither
17:25:45 <catgocat> is OPTIONS_GHC or GHC_OPTIONS?
17:25:47 <catgocat> who do I believe???
17:25:50 <Intolerable> try both
17:25:53 <fishythefish> catgocat: Google.
17:25:53 <Intolerable> see what happens
17:26:01 <Intolerable> (not at the same time)
17:26:34 <mniip_> https://downloads.haskell.org/~ghc/7.2.2/docs/html/users_guide/pragmas.html#id567620
17:26:46 <kadoban> ttt_fff: The db part is already my host's problem. How the hell db-intensive crap are you writing anyway? The whole thing just smacks of premature optimization. You're picking weird libraries just because you think later it might be a bottleneck. Use a good abstraction and call it a day.
17:27:20 <ttt_fff> kadoban: I'm buidling a mooc course
17:27:23 <catgocat> I disabled -Wall and this shows up: Warning: Defined but not used: `r'
17:27:29 <catgocat> shouldnt this only show in Wall?
17:27:31 <ttt_fff> it's just client side + some application logic + every thing else is db access
17:28:16 <kadoban> ttt_fff: Isn't a mooc course just basically a mostly-static webpage with some content on it?
17:29:16 <ThatAmine> hello folks
17:29:22 <ttt_fff> kadoban: well, there's all the multiple choice tests, submissions of quizzes, etc ...
17:30:28 <ThatAmine> please tell me what kind of software  can we write with haskell ? and  when it become benefcial comapred to other programming languages ?
17:30:48 <kadoban> ttt_fff: That's about my limit to the conversation. I'd just recommend less buzzword bingo, more … just write the thing. That sounds like just a basic website, nothing too out there.
17:31:23 <ttt_fff> ThatAmine: with haskell, we can write any thing that turing machines are capable of doing
17:31:41 <ttt_fff> ThatAmine: unfortunately, we can't do things like solve the halting problem, compute kolomgorov complexity, or even do 3SAT in polynomial time yet
17:32:03 <ReinH> ThatAmine: Haskell is a general purpose language
17:32:15 <mniip_> ThatAmine, there is an isomorphism between haskell and other languages
17:32:23 <kadoban> ThatAmine: It's a general purpose programming language. It has some interesting features and good abstractions that you won't see in other languages.
17:32:26 <ttt_fff> kadoban: you're probably right
17:32:27 <mniip_> so "what kind of programs" is a moot question
17:32:48 <ReinH> It isn't really
17:32:50 <ReinH> There;s
17:32:52 <kadoban> ThatAmine: If nothing else it'll expand your mind a bit.
17:32:54 <ThatAmine> But do will need to write a program with haskell instead of C++ for example ?
17:32:59 <mniip_> you can translate C into haskell by doing particularly imperative programming
17:33:07 <ReinH> There's one between Haskell and brainfuck too.
17:33:07 <mniip_> you can translate haskell into C with an STG machine
17:33:08 <ttt_fff> ThatAmine: haskell is especially good for (1) creating interesting puzzles concerning memory leaks due to laziness, (2) trolling other langauges, i.e. going ot #scala or #ocaml, and asking "is there a way to use type signatures to ensure that a function is pure? i.e. it outputs an integer, but oes not have any side effects" ?
17:33:08 <ThatAmine> s/will/w
17:33:25 <MarcelineVQ> lol ttt_fff
17:34:02 * ReinH sighs
17:34:09 <ReinH> None of these answers are helpful
17:34:24 <ThatAmine> ok so learning Haskell is just for fan then... 
17:34:32 <ttt_fff> ReinH: I dunno, I thought "<ReinH> There's one between Haskell and brainfuck too." was really isngithful
17:34:41 <ReinH> No. It's a real language used to solve real problems
17:35:08 <ThatAmine> ReinH, but C++ can do the same thing in more "elegant" way I guess
17:35:14 <ReinH> No
17:35:29 <ThatAmine> why will choose Haskell insteaf of C++
17:35:46 <ReinH> Don't be led astray, just because two languages can do the same thing does not make them the same
17:35:54 <ttt_fff> because you can make haskell very slow, which will force your boss to buy you a faster machine
17:36:01 <ReinH> Else we'd be writng brainfuck
17:37:05 <ReinH> ThatAmine: I'm sorry the answers you're getting are of such low quality. It's a reasonble question.
17:37:19 <kadoban> ttt_fff: Whatever made you think that's the correct way to respond to a new person … bleh, just don't.
17:37:38 <ReinH> kadoban made some good points
17:37:58 <ReinH> Everyone else is trolling and I wish they would stop.
17:38:16 <ThatAmine> ReinH, I think there is big reason to jump to Haskell unless for fun to experiment new thing :)
17:38:45 <kadoban> ThatAmine: It's a genuinely useful language, even discounting that it's fun and interesting.
17:39:17 <ThatAmine> kadoban, is it super fast ? 
17:39:25 <mniip_> languages have no speed
17:39:25 <ReinH> It can be.
17:39:31 <ThatAmine> what's his biggest qualities ?
17:39:34 <ReinH> Again, not helpful.
17:39:39 <mniip_> :|
17:40:01 <ReinH> ThatAmine: haskell.org has some highlights
17:40:15 <mniip_> it depends on the code being executed
17:40:18 <verement> ThatAmine: I choose to write programs in Haskell instead of C++ because Haskell forces me to be disciplined in my thinking, leading to far fewer possibility of bugs. Also Haskell is elegant and concise, and a joy to write.
17:40:48 <kadoban> ThatAmine: It's quite fast in practice, especially considering how high-level it is (being high-level saves lots of programmer time).
17:41:04 <mniip_> ThatAmine, thanks to the awesome compiler that GHC is, you can sometimes beat C
17:41:06 <ReinH> ThatAmine: also some more info at https://wiki.haskell.org/Introduction
17:41:22 <ThatAmine> hmm I see
17:41:37 <mniip_> but that doesn't automatically make everything fast, crappy code is crappy :)
17:42:28 <ThatAmine> mniip_, also the language can be crappy too, look at Javascript for example ;)
17:42:52 <mniip_> javascript can run at a decent speed
17:42:58 <ThatAmine> you will never write a good program in JS what ever you do 
17:43:00 <ttt_fff> if a terorrist pointed a guy at my head and said "make this program work on the first time it runs", I'd use haskell since compile = high chance of it working
17:43:30 <ReinH> ThatAmine: we don't indulge in language bashing here
17:43:41 <mniip_> ttt_fff, you have 10 seconds to spell out a correct tar invocation
17:43:55 <ttt_fff> tar -xvf blah.tar
17:43:59 <ttt_fff> ha
17:44:04 <mniip_> nice
17:44:11 <ReinH> ttt_fff: you got lucky :p
17:44:48 <ttt_fff> ReinH: you have 10 seconds to recite the 1000th fibonacci number
17:45:00 <ReinH> Or else?
17:45:18 <ttt_fff> you're not as lucky as me
17:45:37 <ReinH> Guess not then
17:45:53 <mniip_> > let fib = 1:1:zipWith (+) fib (tail fib) in fib !! 1000
17:45:54 <lambdabot>  7033036771142281582183525487718354977018126983635873274260490508715453711819...
17:46:02 <ttt_fff> > let fib 0 = 1; fib 1 = 1; fib n = fib(n-1) + fib(n-2) in fib 1000
17:46:05 <lambdabot>  mueval-core: Time limit exceeded
17:46:16 <mniip_> nice exponential time
17:46:20 <ttt_fff> fuck, mniip_ wins
17:47:01 <ttt_fff> damn that's elegant
17:47:06 <verement> isn't that the 1001th fibonacci number?
17:47:08 <ttt_fff> so the trick is the zipWith (+) fib (tail fib) line
17:47:24 <mniip_> verement, depends on what indices do 1 and 1 have
17:47:27 <ReinH> @quote zip`ap`tail
17:47:28 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
17:47:40 <arkeet> clearly 0 is the 0th fibonacci number.
17:47:59 <ThatAmine> ReinH, What I have so far learnt is that Haskell is better when dealing with prgramming complexities
17:48:07 <ThatAmine> it make thinks simpler 
17:48:12 <catgocat> Can anyone tell me why this if-statement in cabal is not working? http://lpaste.net/137950
17:48:16 <ReinH> ThatAmine: I'd agree with that.
17:48:17 <mniip_> :t zip <*> tail
17:48:17 <catgocat> cabal: Map.!: given key is not an element in the ma
17:48:18 <lambdabot> [a] -> [(a, a)]
17:48:23 <mniip_> ooooh
17:48:30 <mniip_> damn that's nice
17:48:32 <catgocat> cabal: Map.!: given key is not an element in the map
17:48:34 <ReinH> mniip_: :)
17:48:39 <ttt_fff> ThatAmine: one true greatness of haskell, which no one told me when I was learning, was how easy it is to refactor
17:48:57 <ttt_fff> the type errors that ghc detects makes it very easy to refactor, knowing that when you change data types, ghc will tell you everything you need to change
17:48:59 <ReinH> We tell people that all the time!
17:49:08 <ReinH> I guess still not enough though
17:49:11 <ttt_fff> this is as opposed to a language like Clojure, where things happen badly silently when I change data structures
17:49:13 * hackagebot servant-JuicyPixels 0.1.0.0 - servant-JuicyPixels  https://hackage.haskell.org/package/servant-JuicyPixels-0.1.0.0 (TvH)
17:49:32 <ttt_fff> ReinH: I didn't see anyone telling ThatAmine that
17:49:43 <ReinH> you just did
17:49:54 <ReinH> :P
17:50:20 <ReinH> you're us now so it counts
17:50:53 <ThatAmine> ttt_fff, the linkg that ReinH gave explains everything
17:51:05 <ThatAmine> "Writing large software systems that work is difficult and expensive. Maintaining those systems is even more difficult and expensive. Functional programming languages, such as Haskell, can make it easier and cheaper"
17:51:45 <catgocat> Can anyone tell me what's wrong with the if flag(debug)? >> http://lpaste.net/137950
17:51:51 <ReinH> @google whyfp -- ThatAmine 
17:51:52 <lambdabot> No Result Found.
17:51:58 <ReinH> @google whyfp
17:51:59 <lambdabot> http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html
17:51:59 <lambdabot> Title: Why Functional Programming Matters
17:52:07 <ReinH> Would also be a good read
17:52:55 <ThatAmine> thanks
17:55:06 <ttt_fff> yeah, but the problem is ... one never reaally belives it
17:55:22 <ttt_fff> until one starts refactoring, fixing ghc errors, and realizing ... damn, taht worked, no hidden hard to debug errors
17:56:13 <mniip_> ttt_fff, depends on what you're working with
17:57:23 * mniip_ reiterates the story of trying to catch the State# RealWorld demand bug
17:57:55 <mniip_> which is near-impossible to debug with tools ghci provides
17:58:16 <catgocat> How do I activate flags when calling benchmarks??
17:58:21 <catgocat> cabal bench -flag doesnt work
18:04:34 <catgocat> Can anyone tell me how to turn on the flags of cabal file?
18:04:43 <catgocat> I have defined a flag.. how do I activate it?
18:06:30 <ttt_fff> @google how to activate cabal flag
18:06:30 <lambdabot> https://www.haskell.org/cabal/users-guide/installing-packages.html
18:16:21 <mniip_> I don't suppose I can do String -> Q Dec
18:16:23 <mniip_> can I
18:16:30 <mniip_> err Q [Dec]
18:17:39 <coppro> mniip_: of course you can
18:17:57 <mniip_> I mean is there something built-in of that nature
18:18:06 <mniip_> as opposed to parsing everthing myself
18:19:03 <geekosaur> my recollection is something related to haskell-src-exts (and that a number of people are grumpy about that)
18:23:23 <Zemyla> Question. If I have class (MonadSTM m, MonadIO mio) => MonadAtomic mio m where atomically :: m a -> mio a, then is it possible to get from that instance (MonadAtomic mio m) => MonadAtomic (ContT r mio) (ContT r m) where atomically (ContT m) = ???
18:30:31 <osa1> does anyone know how TH generated code type checked? does type checker run after each splice?
18:30:49 <osa1> I can't see anything relevant in the manual https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/template-haskell.html
18:35:23 <Xe> is there a code style enforcement tool such that it can fail a build if you do things like have any unqualified or non-specific imports?
18:35:45 <mgsloan> osa1: The section that discusses "declaration groups" is relevant.  I can't find a good resource for this, but I believe what happens is that first the renamer is run on the declaration group, then the splices get executed, and the results all get typechecked
18:35:49 <mgsloan> or something roughly like that
18:37:27 <osa1> "Declaration groups can refer to definitions within previous groups, but not later ones." hm this sounds relevant
18:37:30 <osa1> so my problem is
18:38:20 <osa1> let's say I have 2 top-level TH: [useTypes| |] .... other stuff .... [genTypes| |] here useTypes generated code is using genTypes generated types
18:38:34 <osa1> and this is failing with "blah blah not defined"
18:38:44 <mgsloan> Sure, because it comes in a later declaration group
18:39:07 <osa1> now that sucks, brecause genTypes only generates used types :)
18:39:11 <osa1> so it has to run last
18:40:32 <Sindriava> Hm… is there a way to write ` show <$> [a :: A, b :: B] ` ?
18:40:55 <Sindriava> e.g. a list that's nonhomogenous, but kinda is
18:40:59 <mgsloan> osa1: Hmm, not sure I follow.  So you want to reference types that don't exist yet and later only generate the ones that are referenced?
18:41:07 <osa1> mgsloan: yes
18:41:24 <mgsloan> I don't think that's directly feasible 
18:42:04 <arkeet> Sindriava: where do you get such a list?
18:42:16 <Sindriava> arkeet: As a literal
18:42:50 <Sindriava> arkeet: I mean, `show <$> [a, b]` should be equivalent to `[show a, show b]`, but it's not in this case
18:42:53 <mgsloan> osa1: How about generating types when they're referenced, and not generating them if they already exist (via lookupTypeName)?
18:43:02 <arkeet> Sindriava: well, you don't.
18:43:58 <Sindriava> arkeet: Oh well, I figured that'd be the case. Another thing on my list of language quirks I'll maybe get to tackle one day
18:44:01 <Sindriava> arkeet: Thanks
18:44:21 <mniip_> Sindriava, if you only need to store such a list use can use existentials
18:44:56 <osa1> mgsloan: that's also not easy, becuase references to those types are generated by an expression TH but I need to generate a declaration for the type
18:45:03 <mniip_> data ShowBox = forall a. Show a => ShowBox a
18:45:27 <mniip_> however it doesn't provide a syntactical convenience which is what, I think, yu're after
18:45:54 <Sindriava> mniip_: Yup. But still, interesting. Where can I read more about existentials and how they work? I keep seeing them pop up here and there and have never read how they work
18:46:20 <mniip_> how they work is very different from how to use them :)
18:46:37 <mgsloan> osa1: I see. This *should* be possible, via Language.Haskell.TH.Syntax.addTopDecls.  But, unfortunately the implementation of that function is highly lobotimized and only lets you create new functions or FFI decls :(
18:46:38 <mniip_> (internally, they're pretty complex)
18:46:52 <Sindriava> mniip_: I see. In that case, I'm after the latter case :)
18:46:53 <mgsloan> osa1: So maybe in 7.12, sorry
18:47:05 <Sindriava> mniip_: I suppose the wiki will have something?
18:47:09 <Welkin> Sindriava: https://ghc.haskell.org/trac/haskell-prime/wiki/ExistentialQuantification
18:47:12 <mniip_> Sindriava, it does
18:47:20 <arkeet> mniip_: it's also rather useless.
18:47:27 <Sindriava> Welkin: mniip_: Thanks, I'll take a look ^^
18:48:03 <arkeet> Sindriava: the only way you might get something syntactically convenient, I think, is with TH
18:48:31 <Sindriava> arkeet: Yeah, it's not that much of a burning need, really
18:48:46 <Zemyla> You know, there is an existential that is actually rather useful.
18:48:58 <arkeet> existentials can be useful.
18:49:02 <Sindriava> arkeet: I was just curious if there's maybe an extension to defer type inference or something
18:49:33 <Zemyla> data RandomBox = forall g. (RandomGen g) => RandomBox g
18:49:53 <arkeet> Sindriava: well no matter what, if you write a list it has to have a type.
18:50:18 <Sindriava> arkeet: Yeah, i figured that'd be the case. Thanks for the info ^^
18:50:24 <arkeet> Zemyla: how is this useful?
18:50:36 <Welkin> Sindriava: I think clarity and correctness is more important than syntactic convenience
18:50:40 <Zemyla> RandomBox is a RandomGen as well, and allows hiding the specific generator.
18:50:40 <mniip_> Zemyla, did you mean to place the forall on the inside?
18:51:05 <arkeet> Zemyla: but what's the point?
18:51:16 <Sindriava> Welkin: No doubt.
18:51:33 <arkeet> anywhere I could use a RandomBox, I could take any arbitrary instance of RandomGen
18:51:47 <Sindriava> Welkin: I mean if I REALLY needed to, I could always make a newtype for (a, b)
18:51:55 <Zemyla> Hmm.
18:52:05 <arkeet> here's a real use for existentials:
18:52:06 <arkeet> Coyoneda
18:52:38 <arkeet> or http://hackage.haskell.org/package/folds
18:53:12 <eds> I have a simpler version of randomly generated nodes of a tree: http://lpaste.net/137921
18:53:44 <eds> The version that I am working on now and having trouble with; code and error: http://lpaste.net/137809
18:54:41 <eds> the newer version (beta) also needs to generate random nodes just the way simpler version (gamma) does
18:55:02 <osa1> mgsloan: interesting, I didn't know about addTopDecls, thanks for pointing that out
18:56:15 <glass|> > let { average = \a -> (sum a) / (fromIntegral $ length a) :: Num a => [a] -> a } in average [1, 2, 3]
18:56:17 <lambdabot>      Couldn't match type ‘a2’ with ‘[a3] -> a3’
18:56:17 <lambdabot>        because type variable ‘a3’ would escape its scope
18:56:17 <lambdabot>      This (rigid, skolem) type variable is bound by
18:56:25 <shachaf> arkeet: Just use Yoneda instead.
18:56:53 <glass|> lambdabot: why is the variable so rigid and skolem?
18:57:32 <mikeplus64> > let { average :: Num a => [a] -> a; average a = sum a / fromIntegral (length a) } in average [1,2,3]
18:57:33 <lambdabot>      Could not deduce (Fractional a1) arising from a use of ‘/’
18:57:33 <lambdabot>      from the context (Num a)
18:57:33 <lambdabot>        bound by the inferred type of it :: Num a => a at Top level
18:57:55 <mikeplus64> > let { average :: Fractional a => [a] -> a; average a = sum a / fromIntegral (length a) } in average [1,2,3]
18:57:57 <lambdabot>  2.0
18:59:16 * hackagebot th-typegraph 0.27 - Graph of the subtype relation  https://hackage.haskell.org/package/th-typegraph-0.27 (DavidFox)
18:59:18 * hackagebot th-context 0.22 - Test instance context  https://hackage.haskell.org/package/th-context-0.22 (DavidFox)
19:02:45 <glass|> oh, precedence of -> vs ::
19:03:02 <glass|> such a rigid and skolem bug
19:06:27 <mikeplus64> damn those skolems
19:07:21 <Welkin> is there a way to define (*) on `data V3 a = V3 a a a` such that you can multiply a scalar by a V3 or a V3 by a V3?
19:07:46 <Welkin> there must be something in the linear library
19:08:48 <mikeplus64> Welkin: with linear you can write e.g. 3*V3 x y z
19:09:00 <mikeplus64> fromInteger 3 = V3 3 3 3
19:09:01 <coppro> Welkin: you don't want that, probably
19:09:03 <Welkin> although I don't wnat to have to use lens if it is not necessary
19:09:14 <coppro> scalar and vector multiplication are different things
19:09:19 <Welkin> coppro: I know
19:09:25 <dolio> arkeet: You can't return an arbitrary instance of RandomGen, though, unless you use an existential.
19:09:25 <Welkin> which is why you can define them differently
19:09:38 <coppro> if you *really* wanted you could define something like class VectorMultiplies where ...
19:09:40 <dolio> Or CPS things.
19:09:52 <coppro> but I would much rather define two different operations
19:09:58 <coppro> and not overload (*)
19:10:01 <Welkin> okay
19:10:13 <Welkin> hm
19:10:16 <Welkin> this is for a game
19:10:18 <dolio> (Which is implementing an existential.)
19:10:25 <Welkin> lens may be useful in other areas as well
19:10:45 <Welkin> perhaps I will end up using linear to make it all easier
19:10:52 <mikeplus64> Welkin: the num instance in linear is all element-wise
19:12:09 <coppro> Welkin: I'd probably prefer using an existing package
19:12:29 <mikeplus64> it has 'cross', 'dot' etc ofc
19:12:41 <coppro> and you call v `cross` w and the like :)
19:12:47 <Welkin> how would you define scalar multiplication of a vector in the Num typeclass though?
19:12:58 <Welkin> both paramters to (*) must be of the same type
19:13:01 <Welkin> :t (*)
19:13:02 <lambdabot> Num a => a -> a -> a
19:13:05 <mikeplus64> you don't
19:13:12 <mikeplus64> not really anyway
19:13:39 <mikeplus64> you can just fmap (*x) someV3
19:13:43 <Welkin> so how does 3 * V3 0 2 8 work in linear?
19:13:52 <mikeplus64> 3 = fromInteger 3 = V3 3 3 3
19:14:11 <mikeplus64> because numeric literals are overloaded :)
19:15:11 <mikeplus64> Welkin: oh, linear also has ^* and *^ operators for scalar multiplication
19:15:19 <Welkin> @let data V3 a = V3 a a a
19:15:20 <lambdabot>  Defined.
19:15:27 <Welkin> :t V3
19:15:28 <lambdabot> a -> a -> a -> V3 a
19:15:47 <Welkin> > liftA2 (+) 3 (V3 0 1 2)
19:15:48 <lambdabot>      Could not deduce (Applicative V3) arising from a use of ‘liftA2’
19:15:48 <lambdabot>      from the context (Num c, Num (V3 c))
19:15:48 <lambdabot>        bound by the inferred type of it :: (Num c, Num (V3 c)) => V3 c
19:15:53 <Welkin> > liftA2 (*) 3 (V3 0 1 2)
19:15:55 <lambdabot>      Could not deduce (Applicative V3) arising from a use of ‘liftA2’
19:15:55 <lambdabot>      from the context (Num c, Num (V3 c))
19:15:55 <lambdabot>        bound by the inferred type of it :: (Num c, Num (V3 c)) => V3 c
19:16:03 <Welkin> gah
19:16:23 <numberten> anyone have experience with Network.Wreq overwriting the Content-Type header when using postWith ?
19:16:27 <mikeplus64> instance Num a => Num (V3 a) where ...; fromInteger a = V3 a a a
19:17:45 <mikeplus64> oops, i mean fromInteger a = V3 (fromInteger a) (fromInteger a) (fromInteger a)
19:18:52 <numberten> it looks like post just does that (replaces custom Content-Type with application/x-www-form-urlencoded) automatically because it takes ByteStrings which might not be url safe
19:19:04 <numberten> unsure if there is a way to override that functionality
19:19:17 * hackagebot yesod-lucid 0.1 - Lucid support for Yesod  https://hackage.haskell.org/package/yesod-lucid-0.1 (JoeyHess)
19:21:15 <Welkin> thanks mikeplus64 
19:21:36 <Welkin> that did the trick :)
19:44:18 * hackagebot Phsu 0.1.0.2 - Personal Happstack Server Utils  https://hackage.haskell.org/package/Phsu-0.1.0.2 (utkarshl)
19:44:32 <xelxebar> :t liftA2 . liftA2
19:44:33 <lambdabot> (Applicative f, Applicative f1) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
19:44:50 <xelxebar> Is there a better way to stack Applicatives?
19:46:02 <xelxebar> Honestly, I don't really know what I want to ask. It just feels like `liftA2 . liftA2` is doing something *wrong*
19:46:25 <Jaume> > 1 + 1
19:46:26 <lambdabot>  2
19:46:55 <xelxebar> I'm threading (+) through a couple `a -> Maybe Integer` functions
19:51:48 <Gurkenglas> xelxebar, for exactly three there's liftA3. For arbitrarily many, there's traverse.
19:52:20 <Gurkenglas> (Or, pretty much equivalently, sequenceA.)
19:52:25 <xelxebar> :t liftA3
19:52:26 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
19:52:35 <xelxebar> :t liftA2 . liftA2
19:52:36 <lambdabot> (Applicative f, Applicative f1) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
19:52:53 <xelxebar> These look quite different. Am I just being obtuse?
19:52:55 <Gurkenglas> Welp, soz, mixed something up then
19:54:21 <Gurkenglas> Im not sure I get your "threading (+) throguh a couple `a -> Maybe Integer` functions" phrase. Can you give use the type signature you ultimately want to implement?
19:58:31 <saulzar> Does anyone know if doing something like this is possible (creating an existential which wraps several MonadClasses)  http://lpaste.net/137954?
19:59:57 <xelxebar> I have two `a -> Maybe Integer` and want to `(+)` the results together, so `(a -> Maybe Integer) -> (a -> Maybe integer) -> a -> Maybe Integer` which is just the `liftA2 . liftA2` signature above but instantiated to `(-> a)` and `Maybe`
20:01:20 <Gurkenglas> You could, if (a ->) "." Maybe is going to be used more in your code, use https://hackage.haskell.org/package/transformers-0.2.2.0/docs/Data-Functor-Compose.html to turn the two into a single Applicative
20:01:58 <Gurkenglas> But otherwise, liftA2 . liftA2 seems fine to me.
20:02:24 <xelxebar> Gurkenglas: oh, that's cute. Thanks for the link
20:09:41 <saulzar> Hm. Obviously the existential thing can't work - how would something like bind ever know the two 'M' are the same..
20:10:25 <jmcarthur> saulzar: what is it you are wanting to accomplish with it?
20:11:23 <jmcarthur> saulzar: something like this is possible:   newtype M t a = M (forall m. (MonadHold t m, MonadFix m) => m a)
20:11:41 <jmcarthur> but of course that's not the same thing, so i can't guess if it's what you want
20:12:03 <saulzar> jmcarthur, Hmm.. 
20:12:43 <jmcarthur> saulzar: it is basically a way to use MonadHold without fixing it to a concrete type yet
20:12:49 <saulzar> Yeah
20:14:55 <saulzar> That sounds more reasonable, I tried that earlier and got stuck. Though I think I realize why
20:17:55 <saulzar> jmcarthur, It's so that I can have a base monad with MonadHold which may change type (but still has the same MonadHold interface)
20:18:34 <Gurkenglas> Why aren't (..), (...), etc. defined as \f g x y -> f (g x y), \f g x y z -> f (g x y z), etc?
20:19:20 * hackagebot moesocks 0.1.0.7 - moe for all  https://hackage.haskell.org/package/moesocks-0.1.0.7 (JinjingWang)
20:19:46 <saulzar> Gurkenglas, I guess they're all quite unwieldy by the time it gets to that point..
20:21:00 <jmcarthur> Gurkenglas: i kind of prefer (fmap.fmap) f g, (fmap.fmap.fmap) f g, etc. anyway, but i think i'm in the minority
20:21:34 <Gurkenglas> Is there a language extension that allows you to use alphanumerical characters in operators after their first character, in exchange for an enforced whitespace between each operator and an adjacent alphanum?
20:21:53 <jmcarthur> i am not aware of any
20:23:51 <saulzar> Might be necessary after lens has exhausted all the non alphanumeric ones 
20:24:14 <kadoban> saulzar: They can always just get longer.
20:24:20 * hackagebot Phsu 0.1.0.3 - Personal Happstack Server Utils  https://hackage.haskell.org/package/Phsu-0.1.0.3 (utkarshl)
21:38:05 <lamefun> Uhm... `Text.unpack $ AppInfo.nameText $ AppInfo.summaryName summary $ paramsSummary params` - is there any way to make stuff like this shorter?
21:39:45 <lamefun> No wonder Haskell is unpopular and people use C#...
21:40:12 <cgag> what would it look like in C#?
21:40:35 <lamefun> params.summary.name.toString()
21:40:48 <lamefun> or something like that
21:41:42 <lostman> hi all. i have a couple of packages that I'm building with stack. The problem is that package foo uses embedFile and when I try stack ghci in bar/ it complains that the file can't be found (because it is searching for it in the current directory). Is there any way to get the source directory from the compiler at compile time?
21:41:44 <cgag> ah i didn't realize what it was doing (digging into a record), someone who knows lenses well probably has a good answer for that
21:43:23 <lamefun> cgag, lenes are normal functions/values, so I'll simply end up with AppInfo.summaryName lens instead of a function...
21:49:10 <cgag> lamefun: wouldn't you get something like T.unpack $ params ^. summary . summaryName . nameText?  I haven't actully used lens much, only when forced to by wreq
21:50:03 <lamefun> cgag, more like (Text.unpack $ params ^. paramsSummary ^. AppInfo.summaryName ^. AppInfo.nameText
21:53:17 <lamefun> I don't think I still can't have two summaryName lenses in a single namespace.
21:53:20 <lamefun> *can
21:55:16 <lostman> lamefun: there's a mechanism in lens to generate type classes such that you can use same lens on multiple data types. if you're willing to go that way
21:55:58 <lamefun> No thanks, I'd better use a proper programming language that supports proper programming from the start.
21:57:11 <lostman> lamefun: enjoy!
22:13:15 <hailong> Hi from beijing
22:14:46 <hailong> ／wc
22:28:24 <Fylwind> question about Haskell's GC … if I have an infinite list, and I pass it to 3 functions, each of which will drop 8, 16, and 32 elements respectively and return the remainder; does that mean all the elements between 8 and 32 will exist and won't be garbage collected while I hold onto these pieces?
22:29:45 <Fylwind> if I were to pass 3 separate infinite lists, 1 for each of the functions, I anticipate that only the 8th, 16th and 32nd element will stick around after a GC pass; is this correct?
22:30:28 <Fylwind> I guess I'm trying to see if sharing in this case might cause a significant _loss_ in efficiency
22:33:18 <srhb> Fylwind: Yes, that sounds like the correct intuition
22:33:32 <srhb> Assuming that the elements are even evaluated.
22:33:47 <codebje> the values might still be thunks, but the list constructor itself will have been reified, surely
22:34:19 <Fylwind> hrm then I better be careful with using infinite lists for this problem …
22:34:31 <Fylwind> is there a way to "clone" an infinite list?
22:34:50 <srhb> Fylwind: Yes, let b = a
22:35:04 <codebje> so you'll have <thunk8> : <thunk9> : ... <thunk32> : <thunk-tail>
22:35:15 <Fylwind> srhb: does that really make a clone? :O
22:35:25 <Fylwind> I always thought let b = a just reassigns a reference
22:35:41 * Fylwind knows nothing of GHC's internals
22:35:53 <codebje> have you already determined that there's a memory issue? :-)
22:36:56 <Fylwind> codebje: not yet (and probably won't since I'm just cycling through 26 letters) but I'm just doing this for curiosity
22:37:05 <codebje> if you stop holding onto the result from the first function, the 8th to 15th elements will also be candidates for GC
22:37:26 <Fylwind>  I can't stop holding to it
22:37:44 <codebje> maybe store [8, 16, 32] until you really _need_ the values involved, then map that to drop
22:38:06 <Fylwind> (of course I can just use a different way to represent it rather than use lists)
22:40:29 <srhb> Fylwind: I'm not really sure and I don't really think that creating new lists makes sense anyway.
22:40:40 <srhb> It feels like we're engineering a problem for a non-problem. :-)
22:41:02 <Fylwind> http://stackoverflow.com/questions/14395347/haskell-partially-drop-lazy-evaluated-results
22:41:06 <Fylwind> it's actually very similar to this problem
22:41:22 <Fylwind> (looks like the answer is "no": GHC does not provide a way to duplicate thunks)
22:41:32 <srhb> Fylwind: OK. :)
22:42:04 <codebje> "this is not going to terminate" is a lie, it will exhaust memory trying :-)
22:53:33 <eds> Is this a valid forall statment:     EL :: forall (vs,a). ((Expr vs [a]) -> ExprW) ?
22:56:46 <mzero> I don't think so --- but I don't know how you can have two vars in a forall.
22:56:51 <mzero> might need to next 'em
22:57:09 <eds> I think there is a way
22:58:38 <srhb> forall vs a
22:59:19 <srhb> So really, the whole thing would be
22:59:34 <srhb> forall vs a. Expr vs [a] -> ExprW
22:59:59 <mzero> just found that by trial and error in ghci, too! :-)
23:00:24 <eds> srhb: oh yeah, that worked. thanks
23:00:33 <srhb> Sure.
23:36:35 <Lokathor> it's disheartening that beginner's lua can compute the project euler problems so much faster than beginner's haskell can :/
23:39:59 <srhb> Lokathor: I disagree.
23:40:50 <Lokathor> oddly, the more you know about haskell the *less* qualified you are to dispute me in this particular situation
23:41:34 <srhb> Lokathor: I think you think I'm disagreeing with you on the wrong thing.
23:42:21 <srhb> I think it should not be disheartening. (I wasn't disheartened.) 
23:42:42 <Lokathor> ah, that way
23:44:07 <srhb> Beginners who expect to be able to solve things in a to them new paradigm as efficiently that they did in the ones they are trained are being silly and unrealistic. They should stop it immediately, as it is only damaging.
23:46:13 <Lokathor> well
23:47:48 <Lokathor> i started programming lua a few hours ago while skimming a primer on its syntax at work for a few days while riding the elevator, and it spits out answers very fast (eg, 4 millionth fib number) when using the "obvious" way to do things in lua
23:48:32 <srhb> I think you're missing my point.
23:48:49 <Lokathor> whereas, with haskell, after several days of study with LYAH at the time, i put together the similar "obvious" way to do things in haskell (yes keeping in mind functional vs imperative) and it ended up far far worse
23:49:02 * srhb nods
23:49:08 <srhb> That is to be expected. It should not be discouraging.
23:49:53 <Lokathor> why not?
23:51:05 <srhb> Because knowledge on how to solve these things in an imperative manner does not transfer into an efficient Haskell solution.
23:51:17 <srhb> I don't know why anyone would expect this.
23:51:43 <kadoban> Lokathor: There's not a lot to learn in simple languages. That means it's quick to learn what's there. It also means that a lot /isn't/ there. So if your only comparison is writing toys after looking at a language for 5 minutes, lua will win every time.
23:51:51 <Lokathor> that the obvious solution and the most efficient solution are so dissimilar is what's dishartening
23:52:00 <kadoban> Lokathor: If you start looking at writing actual real-life programs, the picture is different.
23:52:47 <krakrjak> kadoban: I take your point, but can you elaborate?
23:52:53 <srhb> Lokathor: The "obvious" solution for a beginner and the "obvious" solution for an expert are not the same things. Most people who come to Haskell are already imperative "experts"
23:53:30 <kadoban> Also … 4-millionth fib. Isn't that /huge/? How many digits are even in that thing? Sounds like it'd take a while regardless of language, unless I'm really off.
23:54:00 <Lokathor> oh sorry, you are correct, sorry
23:54:09 <srhb> iirc it's something like the the sum of all fibs under 4 million
23:54:35 <Lokathor> problem2 is: sum of all fibb number multipules of 3 or 5 that are less than 4 million
23:55:17 <srhb> As a side note, I think doing peuler for learning Haskell is a horrible idea, just in case that's what you're doing.
23:55:39 <kadoban> krakrjak: The time you spend learning haskell is required because there's abstractions to internalize. These are very useful for writing large, complicated solutions. They don't really come up in toys.
23:55:46 <Lokathor> so, for example, a newbie would probably write something like sum $ filter pred $ take fourMil fibList
23:56:31 <Lokathor> srhb, i was suggested euler at the time, and did about the first 10 before i quickly discovered i was learning more nonsense math than i was haskell and stopped
23:56:36 <kadoban> Lokathor: take 4000000 is totally the wrong thing, isn't it?
23:56:43 <srhb> Lokathor: Good. :)
23:56:59 <Lokathor> ah, right, takeWhile
23:57:01 <Lokathor> i thnk it should be
23:57:21 <srhb> Yes.
23:57:27 <Lokathor> sum $ filter threeOrFive $ takeWhile lessThanFourMil fibList
23:58:23 <kadoban> Lokathor: So … how did you write it in lua that was naive and quick, out of curiosity? Most ways to do it badly are just as poor in imperative as they are in functional.
23:58:59 <Lokathor> well let me tell you, my lua was just fine, but my haskell suffered from the huge huge flaw of trying to do it in ghci :P
23:59:37 <Lokathor> you see, a history of python give me wrong expectations of the relationship between ghc and ghci with respect to speed; that expectation being "it's all the same right?"
23:59:59 <srhb> Heh, yes.
