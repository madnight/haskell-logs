00:02:33 <sgronblo> ok so do you know if stack does anything when you install cabal to make sure it uses the correct resolvers ghc?
00:02:51 <peddie> haven't used stack, sorry
00:04:30 * hackagebot quiver-enumerator 0.0.0.1 - Bridge between Quiver and Iteratee paradigms  https://hackage.haskell.org/package/quiver-enumerator-0.0.0.1 (patrykz)
00:07:40 * hackagebot quiver-bytestring 0.0.0.2 - Quiver combinators for bytestring streaming  https://hackage.haskell.org/package/quiver-bytestring-0.0.0.2 (patrykz)
00:07:40 * hackagebot quiver-enumerator 0.0.0.1 - Bridge between Quiver and Iteratee paradigms  https://hackage.haskell.org/package/quiver-enumerator-0.0.0.1 (patrykz)
00:08:51 <Fylwind> I think some of the lens docs might look a little better with infix type variables used for Profunctors (e.g. ~>)
00:16:33 * mappo_
00:27:36 * hackagebot applicative-fail 1.1.1 - Applicative functor and monad which collects all your fails  https://hackage.haskell.org/package/applicative-fail-1.1.1 (AlekseyUymanov)
00:31:48 <lush> yo)
00:32:01 <liste> hello
01:22:38 * hackagebot getopt-generics 0.10.0.1 - Create command line interfaces with ease  https://hackage.haskell.org/package/getopt-generics-0.10.0.1 (SoenkeHahn)
01:40:24 <Ragnar2> This server sucks ... enter irc.netchat.cl !!! ragnar owner awaits !!!
01:40:25 <Ragnar2> This server sucks ... enter irc.netchat.cl !!! ragnar owner awaits !!!
01:40:26 <Ragnar2> This server sucks ... enter irc.netchat.cl !!! ragnar owner awaits !!!
01:40:27 <Ragnar2> This server sucks ... enter irc.netchat.cl !!! ragnar owner awaits !!!
01:40:28 <Ragnar2> This server sucks ... enter irc.netchat.cl !!! ragnar owner awaits !!!
01:40:34 <Laserbear> noice
01:42:58 <ely-se> seems legit
01:48:20 <liste> !ops
01:49:25 <quchen2> liste: "?where ops" is the command.
01:49:43 <liste> thx quchen2
01:50:37 <liste> though maybe not necessary, seems it stopped already
01:52:20 <quchen2> It's rarely necessary because of spam since those users disconnect pretty quickly
01:56:35 <marienz> if you see them disconnect with a reason such as "Killed (Sigyn (Spam is off topic on freenode.))" they've been temporarily banned from the network, and setting bans may therefore not be required
02:03:28 <frerich> I first wondered why the Haskell word needs yet another getopt replacement, but getopt-generics is actually pretty neat!
02:04:24 <tdammers> most pleasant approach to option parsing I've used so far is a hand-written Parsec parser
02:05:30 <frerich> tdammers: I think https://hackage.haskell.org/package/getopt-generics-0.10.0.1/docs/System-Console-GetOpt-Generics.html#v:getArguments looks pretty nice, I suspect that may well cover the vast majority of my use cases.
02:05:37 <frerich> I don't usually do 'mode-based' parsing.
02:05:48 <tdammers> hmhm
02:06:13 <tdammers> I tend to venture into "CLI args as a full-blown DSL" land way too often
02:06:40 <tdammers> UIs like 'find' or ImageMagick, you know
02:07:06 <frerich> Yeah, I guess they are good examples of cases where you actually want to parse some DSL.
02:07:14 <tdammers> yep
02:07:55 <tdammers> for me, it's either that, or something completely trivial that I can implement in 5 sloc myself without pulling in a lib
02:08:40 <tdammers> well, maybe not 5, but the custom code isn't going to be longer than the EDSL that would configure the more advanced parser
02:10:20 <frerich> tdammers: Do you have some common combinators specifically for parsing command line arguments? I guess if one has a typical toolset then it may indeed be very short.
02:10:41 <tdammers> frerich: oh no, I meant for the trivial case
02:10:46 <frerich> Ah.
02:10:47 <tdammers> I don't use a real parser there
02:10:59 <tdammers> basically just manual recursion or a simple mapM or sth like that
02:12:21 <frerich> Actually, my command line parsing often starts out as 'getArgs >>= \s -> case parseArgs s of Just foo -> run foo; Nothing -> complain;' :-}
02:12:38 <frerich> At least I started to get a better feeling of when I should drop that in favor of something more sophisticated ;-)
02:13:28 <tdammers> *cough* LambdaCase *cough* :D
02:14:13 <frerich>  Yeah I guess I could 'fmap parseArgs getArgs >>= \case -> ...'
02:15:13 <tdammers> beside the point though
02:15:32 <tdammers> the idea of a more declarative arg parser is certainly a good one
02:15:35 <ChristianS> i've heard good things about optparse-applicative, though i haven't tried it myself yet
02:15:44 <tdammers> especially if you can leverage the declaration to also generate --help
02:16:18 <frerich> tdammers: Right, and I like how getopt-generics turns 'Bool' values into flags and 'Maybe' ones into generics.
02:16:42 <tdammers> that does sound rather nice
02:17:04 <tdammers> how does it handle dependencies between options?
02:17:25 <frerich> tdammers: That I don't know yet, only just started reading the API docs after lambdabot announced the new version :-)
02:17:38 <tdammers> because that's the thing that interests me the most
02:17:38 <frerich> I also couldn't see how to specify default values...
02:18:10 <tdammers> parsing a bunch of completely orthogonal / independent flags isn't awfully difficult
02:18:44 <tdammers> but if you want stuff like modes, or options that only make sense when other options are set, or options that have different valid choices depending on other flags, etc....
02:18:51 <tdammers> that's where the fun begins
02:19:16 <tdammers> and so far, the most manageable solution I have found for these things is to write an actual parser, and document its behavior manually
02:23:43 <frerich> Hm, maybe it's not too crazy to require(?) that command line arguments are all orthogonal, and implement dependent switches using a tiny custom DSL. Like, instead of '--frobnicate --frob-level=13 --yoyo-after-frob=false' one could consider '--frobnicate=level=13,yoyo-afterwards=false'. You'd have to do some custom parsing, but it's no longer possible to specify dependent arguments standalone.
02:23:57 <frerich> My gut feeling is that it's a bit awkward and non-standard.
02:26:26 <tdammers> what I did before was stuff like --lang=js --js-pretty-print --js-standalone
02:26:44 <tdammers> i.e., one option sets the mode, and then all mode-specific options are tagged with a prefix
02:27:32 <tdammers> the parser would just accept everything regardless of mode, and then I'd barf in the next stage, where I convert a flat ignorant record of parsed options into something more useful
02:27:43 <tdammers> but it felt clumsy
02:33:36 <frerich> Mhm.
02:34:25 <frerich> I guess it becomes more tricky if you have generic options like '--pretty-print' which are applicable for multiple values of '--lang'.
02:35:16 <tdammers> definitely
02:35:22 <frerich> but then - maybe the trouble with parsing the command line options is directly proportional to the complexity of your interface and thus antiproportional to the ease with which people can use that interface correctly. So if the parser becomes too tricky, maybe the interface needs to be reduced somehow. :-)
02:35:33 <frerich> Or is that chickening out? :-)
02:36:15 <tdammers> I don't think stuff like "this option sets an input language; that option is available for the following input languages: ..." is bad UX
02:37:32 <frerich> In that specific case, one could argue - can't the input language be derived based on e.g. a file extension, and why isn't pretty-printing available for all lagnuages? I'm really just playing the devils advocate there though.
02:38:11 <frerich> One thing I once tried was to only do very simply things on the command line and then have a '--config' switch where you could specifiy a simple key=value file for other things. It was an INI-style file with groups.
02:38:30 <tdammers> in this particular case, the language *was* actually determined based on input and output filenames, but I also needed the thing to work in a streaming fashion
02:38:50 <frerich> Hm true. Anything which can read from stdin needs to have some sort of input format specifier.
02:41:42 <tdammers> speaking of reading from stdin...
02:42:06 <tdammers> for this application I'm building, I'm shelling out to imagemagick to generate thumbnails
02:42:45 <tdammers> originally, I would read the image file into a lazy bytestring and then pass that to my imagemagick subprocess, and then consume the output as a lazy bytestring for further processing
02:43:14 <tdammers> but it turns out that pointing imagemagick at the input file directly is about 10x faster
02:44:11 <frerich> Did you check whether strict bytestrings work better?
02:44:30 <tdammers> nope
02:44:36 <tdammers> not an option anyway, really
02:44:53 <tdammers> I don't really want to hold the entire image file in RAM at once if I can avoid it
02:45:07 <tdammers> especially if there is a realistic chance that I'll be generating many thumbnails in parallel
02:45:08 <frerich> I'm trying to think of things which imagemagick might be able to do when reading a file which it cannot do when reading from stdin. Besides getting the file size in advance (but how would that accelerate anything?).
02:45:26 <tdammers> my guess is that it needs to jump back and forth in the file
02:45:50 <tdammers> and when it receives data through a pipe (which doesn't support reverse seeking), then it has to buffer the input and hold it all in RAM
02:45:53 <frerich> Hm indeed - especially if it's supposed to work with large images, i.e. it can't just hold everything in memory.
02:46:17 <frerich> Maybe it depends on the image file format.
02:46:27 <tdammers> jpeg, if that's any help
02:46:54 <tdammers> not very important right now though, the images are stored locally anyway
02:47:12 <tdammers> but for another project, this is going to become interesting again at some point
02:47:59 <tdammers> (there, I need to abstract the image store away, so the images may or may not be stored as files, and the interface won't expose this implementation detail)
02:48:16 <martinvlk> @pl (\xx -> listh . S.toList <$> xx) <$> execT (filtering p xs) (pure S.empty)
02:48:16 <lambdabot> (listh . S.toList <$>) <$> execT (filtering p xs) (pure S.empty)
02:52:41 * hackagebot microlens 0.1.3.0 - A tiny part of the lens library which you can depend upon  https://hackage.haskell.org/package/microlens-0.1.3.0 (Artyom)
02:54:30 <grayen> Is it possible to generalize the varargs example to have allow different class constraints depending on a function supplied?
02:54:36 <grayen> Varargs example: http://rosettacode.org/wiki/Variadic_function#Haskell
02:54:41 <grayen> For example, printAll pp 1 "test", where pp would require the PrettyPrint constraint instead of Show.
03:05:35 <Gurkenglas> I'd use fmap f instead of (f <$>)
03:10:11 <martinvlk> Gurkenglas: hi, why so?
03:10:58 <martinvlk> because it can be composed with . ?
03:17:59 <Gurkenglas> Because it's less brackets and fmap and <$> are about equally understandable to me
03:18:47 <frerich> martinvlk: Quite frankly, for my taste there's quite a lot going on in a single line. I think I'd split that instead of condensing it. :-}
03:23:58 <martinvlk> frerich: yeah, well.. me learning Haskell, finished cis194, now on NICTA course.. finding it increasingly complicated.. :-)
03:26:07 <martinvlk> usually I first complete the task, then simplify, make it readable and nice
03:26:55 <srhb> martinvlk: Liberal use of where constructs and intermediary names - yeah. :-)
03:32:57 <spaceloop> Is there a solution for zipper lists with multiple elements in focus, that can be seperately manipulated?
03:40:48 <mniip> @tell dramforever everything is much simpler. You hold a (sorted) Set-like balanced tree of beginnings, and same for endings. Then you decend with window beginning and window end into both. If either tree has something between window beginning and window end, it's a match. Otherwise once you descended to the end, you check how many elements are there to the left, and if in two trees the amount is different, it's a match.
03:40:48 <lambdabot> Consider it noted.
03:56:58 <mniip> @tell dramforever In fact, just use Set (make sure no elements are equal), then findIndex `fmap` lookupLT at window beginning and end in both sets, and then see if all 4 maybe-numbers are equal
03:56:58 <lambdabot> Consider it noted.
03:57:07 <frerich> martinvlk: I think if you have a language which is very expressive, you can say a lot without using very few words. As a consequence, texts (e.g. programs) can become super dense. It's kind of elegant in one sense, but I do like my reading to be straightforward so that I don't have to pay super close attention to every subtlety. :-)
03:58:16 <frerich> martinvlk: Alas, giving names to things is notoriously hard (but important) - so people tend to chicken out by just not assigning meaningful names to intermediate values but just squashing everything into one expression. ;-)
03:58:30 <fractalsea> In optparse-applicative, is there a way to define a flag flag that can also take an optional argument? For example —the-flag may or may not be there, but if it is set, it may or may not have an argument.
04:11:33 <martinvlk> freirich: in my case it's pure ignorance, I am a beginner so only feeling my way through basics, I think at this point I am afraid of larger pieces of code so I am trying to make is as short as possible to be able to fit it in my head at once
04:11:41 <martinvlk> :-)
04:17:07 <xplat_> tdammers: i feel like if your command line args are heading toward being a DSL it's better to just turn your program into a DSL interpreter and support scripts or '-e'
04:19:05 <xplat_> tdammers: i feel like 'find' would have worked better like that, and probably 'convert' too
04:24:36 <a_> hello
04:27:38 <srhb> a_: Hello.
04:40:19 <joneshf-laptop> does anyone have an example of `reads` that returns multiple results?
04:45:49 <srhb> joneshf-laptop: I don't think any of the standard instances actually do that.
04:48:56 <joneshf-laptop> srhb, hmm
04:49:07 <srhb> joneshf-laptop: That's Read instances, for the record.
04:49:20 <joneshf-laptop> seems like you'd have to have an ambiguous `Read`.
04:49:30 <srhb> That's correct.
04:49:41 <srhb> Which is usually not desirable, and hence... :-)
04:49:46 <joneshf-laptop> :)
04:50:00 <joneshf-laptop> doesn't that violate some law then?
04:50:18 <indiagreen> joneshf-laptop: scientific used to do this, but not anymore
04:50:19 <joneshf-laptop> with `Show`
04:50:25 <srhb> joneshf-laptop: read . show = id and show . read = id -- yes
04:50:25 <joneshf-laptop> indiagreen, oh?
04:50:44 <indiagreen> https://github.com/basvandijk/scientific/commit/8990216e351c56f8186ca12cffbc09af95238eef
04:50:44 <merijn> srhb: "show . read" is a compile problem, usually :p
04:50:45 <srhb> joneshf-laptop: But in fact, read will simply error out if it encounters an ambigous parse, so you can argue that a crash does not break the law.
04:51:01 <srhb> joneshf-laptop: (eg. look at the definition of read)
04:51:06 <merijn> srhb: "Ambiguous type variable a0" :p
04:51:15 <srhb> merijn: Sure.
04:51:30 <indiagreen> but I patched it to conform to the behavior of reads for Double
04:51:31 <joneshf-laptop> indiagreen, oh cool
04:52:01 <joneshf-laptop> so what's the purpose of `ReadS` then if the behavior is undesirable?
04:52:05 <joneshf-laptop> historic artifact?
04:52:10 <srhb> More or less.
04:52:36 <merijn> read itself is mostly backwards compatibility/debugging
04:52:46 <merijn> It's performance sucks balls and it's error handling is non-existent
04:52:55 <srhb> joneshf-laptop: But it also does encapsulate the semantics of Maybe, and I think it might be older than Maybe.
04:53:18 <merijn> srhb: Doubtfull
04:53:20 <srhb> (The multiple value bit has almost never been used, but the 0 or 1 bit has)
04:53:42 <merijn> srhb: Maybe is based on ML's Option which predates haskell by like a decade or so? (Wild ass guess)
04:53:44 <srhb> merijn: Hm, this calls for hairy archaeology. I'm not sure I'm up to it. :-)
04:55:12 <tdammers> I thought the reasoning behind readS was that you can have nondeterministic parsing
04:57:24 <merijn> tdammers: Yes
04:58:02 <tdammers> particularly, that you can return multiple successful parses, and then try them in order until you find one where the rest also parses successfully
04:58:11 <tdammers> which I believe is something Maybe wouldn't have solved
04:58:21 <srhb> That was the initial question, basically. :)
04:58:31 <tdammers> way to go me
05:23:49 <tsani> I'm trying to build a simple imperative DSL with GADTs, but I'm stumped about how I can safely handle variables in it; I'd like the type system to make it impossible for me to refer to a variable that hasn't been defined yet.
05:23:56 <tsani> Any idea how to achieve something like that ?
05:26:57 <srhb> That sounds very dependent.
05:28:16 <aweinstock> tsani: as in, using the host's type system (Haskell's) to make impossible construct references to undefined-variables in the DSL?
05:28:28 <tsani> aweinstock: yes
05:30:06 <aweinstock> tsani: what does the code look like so far?
05:32:55 <tsani> http://lpaste.net/137841 here's the gadt so far
05:34:05 <tsani> I want to improve the Let and Refer constructs
05:36:32 <srhb> I may just be talking out of my ass here, so take with a grain of salt, but: I can't see any way of doing this without promoting some identifier values to types, ie with DataKinds
05:36:37 <aweinstock> what's the Expr b do in Let?
05:39:24 <aweinstock> is it "Let :: IdentifierName -> ExprForBoundValue -> ExprInWhichValueIsBound -> ExprWhichIsTheResultOfLet"?
05:39:32 <tsani> aweinstock: Yes
05:39:57 <tsani> srhb: I was afraid that might be the case too
05:40:19 <srhb> And then the problem becomes (I thiiiiink) carrying around witnesses. Which, I think, is not an easy problem.
05:41:54 <aweinstock> does "Let :: ExprForBoundValue -> (IdentifierToBePassedToRef -> ExprUsingRef) -> ExprWhichIsTheResultOfLet" work? (using haskell-level functions to provide the scopes)
05:43:12 <xelxebar> Would one of you mind educating me on what's causing the type error in this: http://lpaste.net/137844
05:43:34 <srhb> xelxebar: Type variables aren't scoped across definitions.
05:43:39 <tsani> aweinstock: I think it could
05:44:10 <srhb> xelxebar: So when you refer to a in y :: a -- you're creating a completely new and DIFFERENT type variable, that is not necessarily equal to the original a
05:44:21 <xelxebar> srhb: so the `a` in the where clause isn't necessarily the same as the `a` in the top level def?
05:44:42 <srhb> xelxebar: You can use -XScopedTypeVariables and change the top level definition to forall a. (...) to scope it across the entire definition
05:44:45 <srhb> xelxebar: Correct
05:45:23 <srhb> xelxebar: What you have now is equivalent to y :: c -- which should make the type error clear
05:46:09 <xelxebar> srhb: Thanks. Is using ScopedTypevariables something that should be avoided if possible?
05:46:17 <srhb> xelxebar: It's completely harmless.
05:46:28 <srhb> xelxebar: (aside from accidentally reusing a type variable name that you already used!)
05:46:43 <tdammers> IMO, ScopedTypeVariables should have been the default
05:46:46 <srhb> Agreed.
05:47:03 <srhb> It's not like we're in fear of running out of type variable names :-)
05:47:38 <tdammers> and even then, the only thing the absence of STV facilitates is shadowing type variable names, which I consider a bad thing
05:47:46 * srhb nods
05:48:20 <srhb> The only thing I dislike about it is having to use forall. Which could arguably be removed if it were the default anyway, though that would break a lot of things.
05:52:34 <xelxebar> What are the magic words I should search for to learn more about what's going on here? I'm a bit unclear on what `forall` is exactly.
05:53:19 <merijn> xelxebar: ScopedTypeVariables is an extension
05:53:38 <merijn> xelxebar: forall is used by several extensions, although it (arguably) has mostly the same role in all of them
05:54:05 <merijn> xelxebar: It comes from the underlying theory (System F_ω ) that GHC uses to compile Haskell
05:54:06 <srhb> xelxebar: In this case, you can add {-# LANGUAGE ScopedTypeVariables #-} to the (very) top of your source file
05:54:35 <merijn> xelxebar: In Core (GHC's internal language) the type of polymorphic functions is explicitly passed in
05:55:50 <merijn> xelxebar: So "id :: a -> a" in haskell would be written "id :: forall a . a -> a" with the implementaiton "id = \(T :: *) . \(x :: T) . x" (i.e. id takes a type T as argument and a value 'x' of type 'T' and returns 'x'
05:56:46 <merijn> xelxebar: Which would be called like "id {Int} 1" -> "(\(T :: *) . \(x :: T) . x) {Int} 1" -> (\x :: Int) . x) 1" -> "1"
05:57:33 <merijn> xelxebar: In general, all haskell signatures have implicit forall's on the left most side, i.e. "Nothing :: Maybe a" is really "forall a . Maybe a", etc.
05:57:53 <xelxebar> merijn: Thank you! This is making it much clearer.
05:58:34 <xelxebar> So, with ScopedTypeVariables, why is it necessary to explicitly declare `forall`?
05:58:39 <merijn> xelxebar: ScopedTypeVariables just piggybacks on the (implicitly already there) forall syntax, to indicate when you want to share a type variable between signatures
05:58:53 <xelxebar> Oh, okay.
05:58:55 <srhb> It could be called scope instead of forall. or it could not be there at all.
05:59:03 <srhb> And just disable shadowing.
05:59:06 <merijn> xelxebar: ScopedTypeVariables by default behaves like standard (i.e. type variables unshared between local definitions)
05:59:27 <merijn> xelxebar: And it uses the forall to annotate "ok, these *should* be shared"
05:59:47 <merijn> xelxebar: And they figured that using syntax that's already implicitly there was simpler than inventing new syntax :)
06:00:05 <xelxebar> So with the ScopedTypeVariables extension, `forall a . a -> b`, we could scope the `a` but not the `b`?
06:00:34 <merijn> xelxebar: Actually, that would complain about an invalid type signature, because if you explicitly introduce 1 variable, you have to introduce ALL
06:00:38 <srhb> xelxebar: Yes.
06:00:47 <merijn> srhb: No, that shouldn't compile iirc
06:00:48 <tdammers> actually, I think the forall. thing was a terrible design decision
06:00:50 <srhb> Huh, really?
06:00:55 <srhb> Oooh, right
06:01:00 <srhb> Because you actually remove the implicit forall?
06:01:11 <srhb> Or override it in favor of your explicit one.
06:01:17 <tdammers> explicit and implicit forall should behave the same
06:01:17 <srhb> And now b isn't forall'ed anymore?
06:01:25 <tdammers> but with STV's, they don't
06:01:26 <merijn> srhb: Right
06:01:28 <srhb> Gotcha.
06:02:26 <merijn> xelxebar: In short, there is an (arguably) sensible reason for that syntax, but it's a bit arcane and not that relevant until you dive deeper into fancy extensions like RankN types :)
06:03:24 <merijn> Which lets you write things like https://gist.github.com/merijn/77e3fa9757658e59b01d (which I'm not gonna explain, because I'm going to the gym now, someone else can do that if they feel motivated :p)
06:03:39 <xelxebar> Okay. So with my previous example, ghc complains that `b` isn't in scope, which makes sense with what you guys are saying.
06:03:46 <xelxebar> Appreciate the explanation.
06:04:00 <xelxebar> Where does the System_ω formalism come in?
06:04:54 <srhb> System f omega
06:05:18 <merijn> xelxebar: System F_ω  (the _ is for latex subscript) it's a well known type system from type theory and GHC's internals are based on the System F_ω type theory, which is a lambda calculus that has polymorphism the exact way I described with explicit type passing as arguments
06:05:45 <merijn> Core (GHC's internal language) is "basically System F_ω module some details"
06:06:22 <merijn> xelxebar: GHC first desugars Haskell into the (simpler) Core language, then does most optimisations on Core and generates code from that
06:06:48 <srhb> ... which is really clever.
06:07:21 <merijn> So to implement, "id :: a -> a; id x = x" GHC has to produce an equivalent Core term like "id :: forall a . a -> a; id = \(T :: *) . \(x :: T) . x"
06:07:30 <merijn> Which is what it then optimises and produces code for
06:08:17 <merijn> xelxebar: Since System F_ω is considerably more flexible than Haskell proper, extensions like RankN just expose more of the underlying details/power
06:09:03 <merijn> The downside is that, for example, in System F_ω  type inference isn't decidable, i.e. in some cases you have to explicitily write down types to succesfully typecheck
06:09:32 <merijn> (which is why RankN types often demand explicit type signatures, since those aren't inferrable, for example)
06:09:36 <merijn> Anyway, time to run :)
06:09:47 <xelxebar> merijn: Thank you!
06:10:00 <xelxebar> You've given me a lot of stuff to dig into!
06:10:28 <xelxebar> srhb: Thank you for getting me started.
06:10:42 <srhb> xelxebar: Sure! I also enjoyed merijns explanations :-)
06:10:47 <srhb> I'm more of a practical smurf.
06:10:54 <srhb> But I want to learn more of the theory :)
06:11:03 <srhb> (slowly...!)
06:11:26 <merijn> xelxebar: I can recommand grabbing this book if you're interested
06:11:28 <merijn> @where tapl
06:11:28 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
06:12:06 <merijn> xelxebar: It covers a lot of the basics of this stuff, including practical code samples (OCaml, sadly, but should be trivial to read if you know basic haskell) on how to implement type checkers/inferers for the type systems discussed
06:12:18 <xelxebar> merijn: Oh! Excellent! Thank you.
06:12:47 <xelxebar> If I go through all of that, should I come out the other side speaking System F_ω?
06:13:06 <srhb> :-)
06:13:14 <merijn> xelxebar: That and the basics of dependent types, etc.
06:13:40 <merijn> xelxebar: Basically after reading that you should be able to implement a simple haskell-like language and read research papers on type theory
06:14:44 <xelxebar> merijn: You're my hero. Thank you very much!
06:15:49 <xelxebar> On my own it would have taken quite a while to figure out what I really wanted to know and eventually find a resource like this.
06:17:08 <srhb> xelxebar: The bad news is, this is the road to endless "I wish Haskell could do THIS..."
06:17:41 <srhb> (The slightly good news is that Haskell increasingly CAN.)
06:19:09 <xelxebar> srhb: Uh oh. This sounds like a road that could lead to hacking on ghc...
06:19:22 <srhb> :-)
06:21:56 <xelxebar> For kicks and giggles, how would one go about seeing how ghc translates things into Core, optimizes them etc?
06:21:58 <nshepperd> I wish Core was a real IR, so I could just write a Core interpreter and get all the benefits of ghc's optimizer on a foreign architecture :)
06:22:07 * nshepperd in "half baked ideas today"
06:22:50 * hackagebot HList 0.4.1.0 - Heterogeneous lists  https://hackage.haskell.org/package/HList-0.4.1.0 (AdamVogt)
06:22:55 <srhb> IR?
06:23:07 <xelxebar> intermediate representation?
06:23:09 <srhb> Ah.
06:23:25 <srhb> Isn't it? I thought you could plug in things anywhere along the pipeline.
06:23:36 <nshepperd> I guess by 'real' I really mean documented
06:23:52 <srhb> Ah.
06:25:01 <xelxebar> nshepperd: ghc source documents it just fine. </sarcasm>
06:26:40 <xelxebar> does anyone know who merijn is in real life? I'm guessing some demigod of some type.
06:26:55 <jackhill> xelxebar: is the commentary what you're after? https://ghc.haskell.org/trac/ghc/wiki/Commentary
06:27:32 <xelxebar> jackhill: Oh! Thank you. I believe nshepperd might be interested in this.
06:27:45 <srhb> xelxebar: iirc a Ph.D.-student at uni Amsterdam
06:27:50 <srhb> But close.
06:29:24 <demize> "wcw-staff-145-18-166-234.wireless.uva.nl"
06:29:29 <demize> staff?
06:29:32 <demize> Hmm
06:29:57 <srhb> demize: Ph.D usually (always?) means employed by the university.
06:30:31 <demize> You don't have to be employed to have a PhD and continue studying :p
06:30:36 * srhb thinks this line of investigation is a bit silly :-)
06:41:31 <codedmart> Anyone have some suggestions or help on this error I am getting: https://gist.github.com/codedmart/9a473ab59a05be8a467b#file-error
06:46:16 <lyxia> codedmart: You defined instance Enter (m a) (m :~> n) (n a), and the dependency typ ret -> arg tells you that if typ = m a and ret = n a, then arg = m :~> n.
06:47:33 <lyxia> codedmart: But if m = Raw m' and n = Raw n', you get that arg = Raw m' :~> Raw n', which conflicts with Enter (Raw m') (m' :~> n') (Raw n')
06:48:05 <lyxia> uh, Enter (Raw m' a) (m' :~> n') (Raw n' a)
06:50:38 <codedmart> lyxia: Are you saying to change it to Enter (Raw m' a) (m' :~> n') (Raw n' a)?
06:51:20 <lyxia> No I'm trying to explain why there is a conflict in these definitions
06:51:29 <codedmart> lyxia: Oh right
06:51:45 <codedmart> lyxia: Any suggestions/thoughts where I should go from here?
06:55:09 <lyxia> codedmart: Where does Raw come from and why do you need to define that instance for it?
06:56:49 <codedmart> lyxia: I pasted Raw in that gist as well. https://gist.github.com/codedmart/9a473ab59a05be8a467b#file-raw-hs
06:57:02 <codedmart> It is part of servant (core).
06:57:04 <lyxia> oh my bad
06:57:47 <codedmart> lyxia: Thanks for the help!
06:59:21 <newcomer> why aren't Float and Double instances of Bounded?
07:01:32 <pavonia> > 1/0 :: Double
07:01:33 <lambdabot>  Infinity
07:03:09 <lyxia> codedmart: What is the purpose of that class?
07:04:39 <codedmart> lyxia: Enter?
07:06:34 <lyxia> Yes
07:07:59 <newcomer> > :type Infinity
07:08:00 <lambdabot>  <hint>:1:1: parse error on input ‘:’
07:08:23 <codedmart> lyxia: to apply a natural transformation to a bunch of leaves of a tree, in essence
07:09:10 <newcomer> How can I let lambdabot work as REPL here?
07:09:24 <tdammers> newcomer: kind of like you did
07:09:31 <tdammers> except that you used both > and :
07:09:36 <tdammers> > 1 + 1
07:09:37 <lambdabot>  2
07:09:40 <tdammers> this works
07:09:46 <tdammers> :t "Hello"
07:09:47 <lambdabot> [Char]
07:09:50 <tdammers> this also works
07:09:54 <newcomer> OK, got it
07:10:03 <newcomer> :type Infinity
07:10:15 <tdammers> oh, and to play around, use a private conversation with lambdabot (/msg lambdabot)
07:10:33 <newcomer> tdammers, yes, OK.
07:11:18 <newcomer> but I wanted to ask a question regarding to lambdabot's output.
07:12:02 <tdammers> in that case, fire away
07:14:25 <newcomer> She's not answering
07:14:36 <tdammers> lambdabot?
07:14:41 <newcomer> Yes.
07:14:44 <tdammers> then you're not asking nicely
07:14:47 <tdammers> @help
07:14:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:15:02 <tdammers> :t Infinity
07:15:03 <lambdabot>     Not in scope: data constructor ‘Infinity’
07:15:03 <lambdabot>     Perhaps you meant variable ‘infinity’ (imported from Data.Number.Natural)
07:15:09 <tdammers> :t infinity
07:15:09 <lambdabot> Natural
07:15:30 <tdammers> note that lambdabot's command syntax isn't exactly the same as ghci
07:15:57 <newcomer> Oh, I was trying :type instead of :t
07:16:04 <lpaste_> mniip pasted “on-line interval intersection test” at http://lpaste.net/137850
07:16:38 <mniip> Hijiri, http://lpaste.net/137850
07:23:11 <sgronblo> does stack have a way to automatically link the ghc you install for a resolver to some directory?
07:25:18 <newcomer> so I'm confused between infinity and Infinity. 1/0::Float gives Infinity. But the REPL can't find Infinity in scope while it can find infinity.
07:26:13 <pyon> Is there a function that takes a string, tries to read it as an Int(eger), and returns either Just that integer, or Nothing?
07:26:18 <pyon> s/string/String/
07:27:25 <hexagoxel> :t Text.Read.readMaybe
07:27:26 <lambdabot> Read a => String -> Maybe a
07:27:33 <hexagoxel> pyon: ^
07:28:14 <kuribas> > Text.Read.readMaybe 2e4 :: Maybe Int
07:28:15 <lambdabot>  Not in scope: ‘Text.Read.readMaybe’
07:29:11 <demize> > readMaybe "2e4" :: Maybe Int
07:29:13 <lambdabot>  <no location info>: can't find file: L.hs
07:29:56 <pyon> hexagoxel: Thanks!
07:32:29 <Iceland_jack> newcomer: 
07:32:29 <Iceland_jack> > 1/0
07:32:30 <lambdabot>  Infinity
07:32:49 <Iceland_jack> I've been meaning to propose adding an Infinity pattern synonym to base
07:39:51 <hexagoxel> newcomer: `Infinity` is indeed special in that it looks like a constructor, but is just some representation for the floating-point "special" value
07:40:47 <hexagoxel> > -1/0
07:40:48 <lambdabot>  -Infinity
07:40:59 <hexagoxel> "-Infinity" is not valid constructor either
07:45:44 <newcomer> I know you guys probably despise Java. But I have a Java-Haskell analogy question.
07:45:57 <newcomer> Are Haskell types somehow analogous to Java classes and Haskell typeclasses analogous to Java interfaces?
07:46:58 <geekosaur> not really
07:47:10 <geekosaur> types are very different
07:47:22 <geekosaur> in some senses Haskell types work "backwards" from Java-style OO classes
07:47:56 <geekosaur> as for typeclasses vs. interfaces: that assumption qorks for a little while and then gets you into very big trouble, because again things work kinda "backwards"
07:47:59 <geekosaur> from what you are used to
07:48:49 <geekosaur> (in particular, while in Java going backwards in the object hierarchy lets you have access to more objects, in Haskell it means you know less about (and can therefore do less with) a value
07:49:31 <voidzero> btw, i don't think a lot of people actually despise java
07:49:43 <voidzero> (or am i cursing in church now?)
07:49:53 <hexagoxel> newcomer: some of this stuff is discussed on https://wiki.haskell.org/OOP_vs_type_classes#Type_classes_vs_classes
07:50:06 <geekosaur> also, a common mistake for people coming from a Java-style OO background is to assume that giving a less specific type (`Num a => a' instead of `Int', say) ffor a function means you can pick which instance of Num to use
07:50:19 <geekosaur> in fact, it is the caller who gets to pick which instance, and you are bound to it
07:50:42 <geekosaur> in short: trying to analogize Haskell types to Java classes is going to get you into trouble
07:51:25 <Gurkenglas> geekosaur, wouldn't going higher in Java also leave you with fewer accessible functions and in Haskell let you work with more instances?
07:51:28 <tdammers> in fact, you can do OOP in a way that's quite close to Java's classes in Haskell
07:51:54 <tdammers> minus the reflection and all that nonsense, that is
07:51:55 <codedmart> Anyone else have suggestions/thoughts on what I should do: https://gist.github.com/codedmart/9a473ab59a05be8a467b#file-error
07:52:50 <geekosaur> Gurkenglas, but in Java you can always introspect; in Haskell you can't (always), you can only introspect if you declare use of a typeclass that provides some introspection ability (e.g. Typeable)
07:53:08 <geekosaur> yes, you can do it, but not the way Java does it
07:53:43 <tdammers> the more interesting difference IMO is that Java's class-based polymorphism is runtime, while Haskell's typeclasses ares strictly compile-time
07:58:14 <ttt_fff> anyone familiar with https://github.com/begriffs/haskell-vim-now ? not sure if I want to switch my entire vim setup
07:58:41 <tdammers> fwiw, I get by with a very vanilla vim setup myself
07:58:42 <voidzero> just back it up
07:58:49 <voidzero> or to test, create a new user
07:58:51 <voidzero> test with that user
07:59:01 <tdammers> haha, or run in a VM
07:59:33 <voidzero> oh, i see what you mean, you're implying that a dedicated user might be overkill
07:59:44 <voidzero> yeah that's really not the case though.
07:59:53 <voidzero> a VM on the other hand..
08:01:51 <geekosaur> probably don't need a dedicated user, just point $HOME somewhere else for the test
08:02:51 <tdammers> also, can't you just point vim to a different .vim directory?
08:02:53 <tdammers> I think you can
08:03:16 <voidzero> by default haskell-vim-now backs up your config and sets it up similarly
08:03:28 <voidzero> but it's just a bit annoying to work with two configs
08:07:03 <ttt_fff> what? separate user? vim?
08:07:14 <ttt_fff> I think I should set this up on a different , air gapped, physical machine
08:07:43 <geekosaur> airgapping ain't enough these days :)
08:10:07 <Sindriava> ttt_fff: I've found just robbing the setup of the interesting bits enough
08:10:09 <voidzero> hey man, it was an ok idea!
08:11:15 <ttt_fff> there's a lot of cabal downloading
08:11:24 <ttt_fff> interested in seeing what this is doing
08:11:43 <codedmart> bergmark: Any chance I can get you to glance at my problem? Only if you have a moment :). https://gist.github.com/codedmart/9a473ab59a05be8a467b#file-error
08:14:09 <mniip> codedmart, you have a fundep conflict
08:14:32 <codedmart> mniip: I know I am just not sure where to go from here.
08:14:46 <ttt_fff> get rid of the fundep
08:14:52 <ttt_fff> fundep says (given a, b ,c), d is unique
08:14:59 <ttt_fff> but you have a, b, c -> d1 and a, b, c, -> d2
08:15:02 <ttt_fff> so you don't relaly have a fundep
08:15:12 <mniip> ttt_fff, that's not the problem
08:15:20 <mniip> codedmart, if typ ~ (Raw m a), arg ~ (m :~> n)
08:15:29 <mniip> typechecker wouldn't know which instance to use
08:16:19 <mniip> because the second instance, sans constraints, is valid
08:16:23 <mniip> for this case
08:17:56 <ttt_fff> mniip: what haskell setup do you use?
08:18:13 <mniip> ttt_fff, shell, gvim/vim, ghc
08:18:16 <codedmart> mniip: I think I get what you are saying, but I am still not sure where to go from here. Still relatively newish to haskell.
08:18:26 <mniip> codedmart, depends on what you want to do
08:18:33 <mniip> I haven't read into the code much
08:19:13 <codedmart> mniip: Well I was able to get things to work by swapping Raw to be Raw a m, but then I can't do instances for Monad, Functor, etc.
08:19:46 <codedmart> So that is why I came back to this angle, but am just stuck on where to go.
08:20:08 <mniip> codedmart, your Raw instance is a subcase of the other instance, for the typechecker
08:20:12 <mniip> make them different somehow
08:20:48 <mniip> I don't think it cares (or knows) that m ~ Raw m is impossible
08:20:59 <mniip> (in fact for some definition of Raw that can be the case)
08:22:30 <codedmart> mniip: Not sure I totally follow what you mean "I don't think it cares (or knows) that m ~ Raw m is impossible"
08:22:59 <codedmart> mniip: I am not sure how to make Raw different.
08:23:09 <mniip> code_crimes, you want to make the other instances
08:23:11 <codedmart> Without swapping.
08:23:12 <mniip> er
08:23:15 <mniip> code_crimes, you want to make the other instance different
08:23:19 <mniip> er
08:23:20 <mniip> codedmart, *
08:23:48 <codedmart> mniip: Are you referring to this 'instance Enter (m a) (m :~> n) (n a) where'
08:23:52 <mniip> yes
08:23:53 <codedmart> Make that different?
08:24:03 <mniip> yes, you have to use something less general than m
08:24:08 <michaelt> isn't it in the library?
08:24:42 <mniip> codedmart, the typechecker doesn't know what the definition of 'Raw' is, imagine if it was 'type Raw x = x', that would give you overlapping instances
08:25:11 <michaelt> codedmart: what are you going to do with Raw? 
08:26:02 <mniip> actually, ignore what I just said
08:26:06 <codedmart> michaelt: Currently it is used to plug a existing wai application into Servant.
08:26:22 <michaelt> oh I thought you were writing it
08:26:43 <codedmart> michaelt: I am changing it yes.
08:27:20 <michaelt> codedmart: if you have rawNat :: Raw m  :~> Raw n ; rawNat = Nat (Raw . unRaw) then you have e.g. enter rawNat :: Enter typ (Raw m :~> Raw n) ret => typ -> ret which works for typ = Raw m; ret = Raw n, I think
08:27:29 <codedmart> michaelt: It is like this currently but does not work with enter https://github.com/haskell-servant/servant/blob/master/servant/src/Servant/API/Raw.hs
08:27:33 <indiagreen> is there a way to lift State into MonadState?
08:27:44 <mniip> codedmart, here is the problem
08:28:30 <indiagreen> something like “MonadState s m => State s a -> m a”
08:28:39 <mniip> 'instance Enter (Raw m a) (m :~> n) (Raw n a)', that actually means 'instance (m1 ~ m2, n1 ~ n2, a1 ~ a2) => Enter (Raw m1 a1) (m2 :~> n1) (Raw n2 a2)'
08:29:10 <mniip> with that in mind, the head of the other instance appears to be a generalization of this instance's head
08:29:27 <mniip> (because contexts are checked way later)
08:29:31 <mniip> and you have an overlap
08:30:06 <lyxia> indiagreen: you can manually deconstruct State and then use state :: (s -> (a, s)) -> m a
08:30:20 <lyxia> state :: MonadState s m => ...
08:30:24 <indiagreen> lyxia: I just found out that I can write it nicely with “state . runState” 
08:30:47 <lyxia> right
08:30:52 <mniip> codedmart, ^
08:33:47 <codedmart> mniip: I think I get what you are saying, but I still don't think I see if you are giving me hints on where to go.
08:33:56 <codedmart> mniip: I do appreciate the help :)
08:34:59 <codedmart> michaelt: I am not sure I follow 'rawNat :: Raw m  :~> Raw n ; rawNat = Nat (Raw . unRaw) then you have e.g. enter rawNat :: Enter typ (Raw m :~> Raw n) ret => typ -> ret which works for typ = Raw m; ret = Raw n'
08:35:04 <codedmart> Totally
08:35:56 <lyxia> codedmart: Can't you drop the arg ret -> typ dependency?
08:38:37 <codedmart> lyxia: Not sure about that one. I can ask the servant guys.
08:39:20 <michaelt> codedmart: I can't tell what is being done with 'enter', but I was thinking you could do whatever you were trying to do with it using 'enter rawNat' but I don't know...
08:39:50 <codedmart> michaelt: Oh I see, thanks!
08:39:51 <ttt_fff> haskell-vim-now is fucking amazing
08:39:55 <ttt_fff> even if ghc-mod does not quite work
08:40:21 <shiona> ttt_fff: oh, is there something especially amazing about it?
08:40:33 <ttt_fff> shiona: words can not describe
08:40:45 <shiona> :D I guess I'll have to try to remember
08:45:50 <catgocat> @pl repli xs n = xs >>= replicate n
08:45:50 <lambdabot> repli = (. replicate) . (>>=)
08:46:15 <Yrarr> Hey! I'd like to ask #haskell one question. I'm trying to find articles about using Haskell for parallel computation - some kind of more practical examples. Aside from Google scholar, do you know places where one might find such articles ?
08:46:49 <voidzero> http://chimera.labs.oreilly.com/books/1230000000929
08:46:49 <codedmart> Thanks everyone for help? Unfortunately I am still a little lost at the moment. I will keep at it though.
08:48:39 <ttt_fff> voidzero: I think you can go a bit further by using voidzerofalse()null
08:48:54 <ttt_fff> voidzerofalse()null[]
08:50:47 <voidzero> oh, didn't hear that one before :P
08:51:47 <Cale> Yrarr: Simon Peyton Jones has many papers about pretty much all aspects of Haskell, and many about parallelism (and concurrency) in particular.
08:51:49 <Cale> http://research.microsoft.com/en-us/people/simonpj/
08:52:33 <Cale> There's a section of that page "Papers about parallelism in Haskell"
08:53:20 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/AFP08-notes.pdf in particular might be of interest
08:53:29 <hackrilege> how do we implement pause in haskell without simply wasting cpu opperations?
08:53:37 <Cale> Yrarr: also, someone already linked Simon Marlow's book, which is excellent
08:53:49 <Cale> hackrilege: Control.Concurrent.threadDelay
08:54:02 <hackrilege> thanks Cale:
08:54:21 <hackrilege> beautiful response, google just adds a layer of confusion in this case
08:54:48 <voidzero> indeed
08:55:07 <voidzero> remember when google was still nice? those were the days
08:55:22 <Yrarr> Cale: Thanks. Still, I'm looking for practical applications, not tutorials. Something like frameworks for solving problems parallely/concurrently in certain domains. I have trouble finding these :/ I've found aivika, which seems nice, but it's mostly sequential.
08:56:07 <Cale> oh, SPJ's list of papers just went down for maintenance :(
08:56:44 <hackrilege> Yrarr: Im looking into parallel haskell, I have found several ports to varios blas libraries which look hopeful, also there are MPI and some threading libraries...
08:57:32 <hackrilege> perhaps the accelerate package also
08:57:56 * hackagebot mtl-unleashed 0.2 - MTL classes without the functional dependency  https://hackage.haskell.org/package/mtl-unleashed-0.2 (DavidFox)
08:59:00 <hackrilege> im trying to learn about the lens libraries and im making good headway, I suppose I am looking to parallelise a basic traveral
08:59:18 <hackrilege> probably a fold actually
09:00:48 <Cale> I'm not sure which domains really admit automatic parallelism in a nontrivial way. There are lots of cases where you just have an obviously parallelisable problem, but that kind of thing tends not to require domain specific libraries.
09:01:38 <Yrarr> hackerile: Hm.. accelerate seems like a good tool, somewhat (only somewhat) framework like. Thanks!
09:02:02 <hackrilege> Cale: treelike structures are an example of a trivially parellelisable traversal
09:02:03 <michaelt> Yrarr: I take it you've seen repa ?
09:02:03 <Cale> That is, I haven't seen many mechanisms for parallelism which weren't possible to separate from a particular domain-specific problem.
09:02:31 <hackrilege> Yrarr: Id love to know more about your problem
09:02:51 <Yrarr> Cale: Well, it's more about writing an research article (of quality which I fear). I'm trying to find a practical application of Haskell's pararellism discussed when solving real problems, and hopefully compared to other implementations for solving the same solution.
09:03:06 <bibbly> hullo friends. i'm having some trouble getting a haskell complier. i used "brew install ghc cabal-install" but it's been hanging on an install step for hours.
09:03:21 <Cale> bibbly: Is it trying to compile ghc?
09:03:24 <hackrilege> which OS?
09:03:32 <bibbly> Mac 10.7.5 Lion
09:03:37 <Cale> bibbly: I would recommend not compiling GHC yourself, if it can at all be avoided.
09:03:39 <michaelt> bibbly: hm. have you had ghc/cabal-install before?
09:03:51 <monochrom> does "brew install" compile from scratch?
09:03:59 <bibbly> no, this is my first exploration into the world of functional programming
09:04:02 <michaelt> monochrom: hah
09:04:23 <hackrilege> bibbly: check out the haskell platform
09:04:23 <Cale> bibbly: https://www.haskell.org/ghc/download_ghc_7_10_2#macosx_x86_64 has Mac OS X 10.7 binaries of GHC.
09:04:24 <bibbly> i've never had any of this stuff before
09:04:25 <michaelt> bibbly: I just put the binary distribution in a local directory ~/ghc/... 
09:04:43 <Cale> Or yeah, you could get the Haskell Platform.
09:04:46 <michaelt> bibbly: the one cale just linked. 
09:04:47 <bibbly> oh, simple as that? and add something to my path variable?
09:05:06 <hackrilege> bibbly: hows about "sudo apt-get install haskell-platform"
09:05:08 <michaelt> bibbly: exactly, add /Users/bibbly/ghc/bin to path 
09:05:20 <Cale> hackrilege: He's on Mac OS X, I don't think that comes with apt-get
09:05:36 <hackrilege> oh sorry, i didnt know brew was mac
09:05:55 <michaelt> bibbly: enter the unpacked directory Cale linked and type ./configure --prefix=/Users/bibbly/ghc
09:06:11 <hackrilege> maybe this is better... https://www.haskell.org/platform/
09:06:27 <hackrilege> it should be a one click installer
09:06:45 <bibbly> i get confused about my environment variables. some people say add it to .profile, .bash_profile, other things...
09:06:49 <Cale> Yeah, the Platform link might be particularly good if you're starting out
09:06:49 <bibbly> i'm kinda new to all of this
09:07:01 <michaelt> then ghc will be locally installed. Installing cabal install will be a little more complicated, but straightforward
09:07:08 <Cale> (especially given that it's actually up to date for once!)
09:07:24 <bibbly> i'm downloading the binary now
09:07:48 <Cale> Platform will get you GHC + a bunch of supporting tools and libraries to start out with, and in particular, cabal install
09:08:19 <hackrilege> is the platform not more complete than just the ghc binarry? 
09:08:44 <hackrilege> yeh, bibbly: use this instead https://www.haskell.org/platform/
09:09:24 <bibbly> ok i'll download the platform
09:09:43 <Cale> In practice, it can be good enough just to get the GHC binary and then install cabal-install by hand and use it to grab whatever libraries you need, but if you're just starting out, you might not want to take the extra trouble configuring things.
09:09:54 <Yrarr> Anyway, thank you all for trying to help :) I'll try to write something about the tools for parallelism then.
09:10:21 <bibbly> i once had some experience of "typed lambda calculus" when i did philosophy (specifically in formal semantics)
09:10:39 <bibbly> is that of any relation?
09:10:51 <monochrom> yes
09:10:56 <hackrilege> Yrarr: I would like to put together the same resource as you require, maybe you could suggest a simple benchmark and I could have a go getting it running
09:10:57 <Cale> bibbly: Haskell can be considered as a very fancy typed lambda calculus.
09:11:37 <bibbly> interesting.
09:11:47 <bibbly> i'm excited about this!
09:11:58 <Cale> bibbly: As a logic, it's inconsistent though, because it admits general recursion.
09:12:03 <Cale> :t fix
09:12:04 <lambdabot> (a -> a) -> a
09:12:47 <monochrom> have you also heard of "delimited continuations" for modelling the formal syntax and semantics of e.g. "some person is a programmer"?
09:12:49 <hackrilege> > take 10 $ fix (1:) 
09:12:51 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
09:13:54 <Cale> bibbly: But if you're familiar with how to write proofs, a lot of the same kind of reasoning can get used when writing programs regardless, considering types as propositions and breaking down what you have to do in much the same way as you would while writing a proof.
09:13:57 <bibbly> cale: is that due to Godel's results?
09:14:20 <Cale> bibbly: It's due to something way more basic
09:14:34 <Yrarr> hackrilege: The stuff I write about is about implementation of parallel heuristic algorithm using Haskell (it's about using monte carlo algorithm to calculate integrals). I've done it using few approaches, I've just needed something for the 'state of the art' section :)
09:14:51 <hackrilege> id love to see this
09:14:51 <Cale> bibbly: Just the fact that if you have recursion, you can write something like  fix f = x where x = f x   or   fix f = f (fix f)
09:15:03 <hackrilege> do you have it up on github?
09:15:04 <Cale> bibbly: and then the type of that is  forall a. (a -> a) -> a
09:15:14 <Cale> bibbly: and of course, we have id :: forall a. a -> a
09:15:15 <Yrarr> not yet
09:15:26 <bibbly> monochrom, no i shall look into that thanks
09:15:26 <Cale> So  fix id :: forall a. a  is a proof of anything.
09:15:36 <Cale> id x = x
09:15:52 <Vektorweg11> how can i say 'a not type of x' in a flexible context?
09:16:21 <Cale> Vektorweg11: Generally you can't. What are you trying to do?
09:16:36 <monochrom> I don't think you can do negations to classes
09:17:12 <bibbly> I loosely see what you mean, Cale, thanks. I think I'll need a more gradual introduction.
09:17:49 <hackrilege> Yrarr: I can proofread it if you like, id love to see the examples you have identified. any chance you could sent me a zip of the work in progress at hackrilege@gmail.com ?
09:18:04 <Cale> bibbly: Basically, given unrestricted recursion, you can write a proof of "If A implies A, then A."
09:18:18 <subleq> nshepperd: darn, way over my head
09:18:57 <Yrarr> hackerilege: Sure, but I'll do it sometime in the week. I still need to clean it a little.
09:19:08 <bibbly> so a haskell program is written like a proof?
09:19:09 <Cale> bibbly: And the term you use to prove it is basically equivalent to having general recursion -- I can use this fix function to write what would otherwise be recursive definitions without any further explicit recursion
09:19:39 <hackrilege> Yrarr: Id prefer it messy!
09:19:51 <Cale> bibbly: In an abstract sense, this is true. How helpful that way of thinking about things will be to you depends on how much familiarity you already have with writing proofs :)
09:20:07 <hackrilege> bibbly: its more like a haskell program is compiled as a proof. 
09:20:22 <Cale> hackrilege: uhh
09:20:30 <Cale> No, this has nothing to do with the compiler
09:20:38 <hackrilege> the way you expand it out and then concatinate it back together
09:20:47 <Cale> I just mean, the lambda calculus was originally conceived of as a logical system for writing proofs.
09:20:56 <hackrilege> with lots of equals signs, like a proof
09:21:10 <Yrarr> :D
09:21:11 <Cale> and since Haskell is ostensibly a lambda calculus, you can think of Haskell programs as being proofs
09:21:24 <Cale> (in an inconsistent intuitionist logic)
09:22:00 <hackrilege> e.g. (fold (+) 0 [1,2]) = (fold (+) 1 [2]) = (fold (+) 3 []) = 3
09:22:07 <Cale> In logic, in order to prove that A -> B (that is "A implies B"), you would start by assuming A, and trying to conclude B
09:22:08 <Vektorweg11> Cale: I used a ReaderT to wrap my type, because i didn't wanted to write all the instances for easy use in a transformer. now i simply derived everything but MonadReader. but i would like allow other MonadReader on deeper transformers so i tried to write a derived instance of it. however, i need to exclude my used type or the types clash.  
09:22:32 <bibbly> jeepers. i think i'm going to take it right back to "hello world" before i get any more philosophical.
09:22:41 <Cale> In lambda calculus, in order to construct a term of type A -> B (that is, "a function from A to B"), you start by assuming you have a variable x of type A, and try to construct an expression y of type B
09:23:12 <Cale> and then the lambda term (\x -> y) (or in some notation λx.y) has type A -> B
09:23:51 <Cale> And similarly, in logic, if you have A -> B and you have A, then you can conclude B through modus ponens.
09:23:52 <hackrilege> (\ a -> a ++ "world") "hello "
09:23:56 <hackrilege> > (\ a -> a ++ "world") "hello "
09:23:58 <lambdabot>  "hello world"
09:24:16 <Cale> In lambda calculus (or Haskell), if you have f :: A -> B, and you have x :: A, then you can apply the function and get  f x :: B
09:24:40 <Cale> So modus ponens is the same thing as function application, and natural deduction is the same thing as constructing lambda terms.
09:25:08 <hackrilege> :t length
09:25:09 <lambdabot> Foldable t => t a -> Int
09:25:26 <Cale> ^^ heh, so beginner-friendly :D
09:25:36 <hackrilege> > length "hello world"
09:25:37 <lambdabot>  11
09:25:44 <bitemyapp> > lnegth (Just 1)
09:25:45 <lambdabot>      Not in scope: ‘lnegth’
09:25:46 <lambdabot>      Perhaps you meant one of these:
09:25:46 <lambdabot>        ‘length’ (imported from Data.List),
09:25:48 <bitemyapp> > length (Just 1)
09:25:49 <lambdabot>  1
09:25:53 <bitemyapp> > length Nothing
09:25:54 <lambdabot>  0
09:26:01 <Vektorweg11> lol
09:26:05 <hackrilege> i only learned about traversable after 5 years! 
09:26:09 <jpl_> whoa never seen length over a Maybe before
09:26:13 <subleq> wow
09:26:17 <Cale> jpl_: Yeah, it's kinda new
09:26:17 <bitemyapp> any foldable.
09:26:31 <Cale> Well, you've been able to do that by importing Data.Foldable for a long time now.
09:26:42 <ronh> what is the time complexity of (length :: Foldable t => t a -> Int) for Array, Text, etc?
09:26:42 <Cale> But you wouldn't have had much reason to.
09:26:44 <jpl_> I can't think of a situation where I would need that but that is awesome lol
09:27:02 <michaelt> ronh: Text isn't foldable
09:27:03 <Cale> ronh: Presumably constant time if it's strict Text.
09:27:11 <Cale> oh, right, it's not Foldable
09:27:47 <hackrilege> ronh: I think the various containers give traversal performance in big O notation in the haddock documentation on hackage 
09:27:49 <subleq> let me guess Cale, you're not happy about FTP?
09:27:50 <BlakeRain> jpl_: mapM over Maybe can be useful. Such as mapM_ print (Just 3)
09:28:05 <michaelt> ronh: length is actually a method of Foldable now, so the implementation can be optimized
09:28:08 <Cale> subleq: ehhh... I'm happy about Traversable, not as happy about Foldable.
09:28:37 <michaelt> Foldable is pretty trashy really. but convenient I guess
09:28:39 <ronh> michaelpj ah, I missed that one
09:28:52 <jpl_> BlakeRain: I think I've seen that before, thanks though
09:28:54 <hackrilege> whats wrong with foldable?
09:29:03 <michaelt> no laws for example
09:29:30 <hiptobecubic> should it?
09:29:40 <Cale> Yeah, it's unclear what toList :: f a -> [a] should satisfy
09:29:56 <Cale> Or how it could even be specified
09:29:59 <breadmonster> I'm trying to pick up Yesod.
09:30:05 <breadmonster> Anyone got any suggestions?
09:30:06 <aweinstock> > length (Just "something")
09:30:07 <lambdabot>  1
09:30:10 <hackrilege> so i guess the strongest point of a lens is that it will infer the combinator from the provided type? this requires the types are foldable?
09:30:33 <hackrilege> breadmonster: use http-simple
09:30:33 <Cale> and while I completely understand the compromise for efficiency, I kind of hate the way that Foldable de-emphasises the universality and importance of lists.
09:30:56 <breadmonster> hackrilege: Is that a http library?
09:31:05 <breadmonster> aweinstock: How on earht does that compile?
09:31:07 <hackrilege> um, rather, http-client
09:31:12 <hiptobecubic> It's hard to say how it could be specified, but i would think it's easy enough to say what it should be, no? I'm thinking of `length` and no duplicates.
09:31:15 <Cale> One of the advantages of lazy functional programming is that it's possible to understand essentially all iteration in terms of passing to a list and then doing some higher order list operation.
09:31:27 <Cale> and Foldable obscures this
09:31:28 <subleq> breadmonster: Maybe is Foldable
09:31:30 <breadmonster> hackrilege: that's a web application framework?
09:31:32 <kadoban> breadmonster: length works on Folbables now, and Maybe is a Foldable
09:31:48 <breadmonster> kadoban: Ah, those little 7.10 changes :P
09:31:51 <hiptobecubic> Cale, how does foldable obscure it?
09:31:54 <kadoban> Yep yep
09:31:59 <Cale> Yes, if you want to *actually* write your programs that way, you end up at the whim of rewrite rules which may not fire, which might cause problems.
09:32:22 <Cale> hiptobecubic: By having all the operations act directly on the structures, and get implemented specially for each.
09:32:33 <Cale> :t foldr
09:32:34 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
09:32:42 <Cale> ^^ look ma, no lists?
09:32:48 <kadoban> Using stack to build stack … sure hope this works XD
09:33:32 <Cale> So, it's a little bit painful pedagogically -- people brought up on Foldable won't necessarily learn how valuable a thing lists are.
09:33:58 <breadmonster> Cale: Isn't that the point? :P
09:34:07 <hackrilege_> sorry, lost connection...
09:34:10 <Cale> breadmonster: Lists *are* valuable.
09:34:11 <breadmonster> To expand your thinking beyond lists...
09:34:18 <Cale> and universal
09:34:25 <hackrilege_> breadmonster: its the same guy that wrote them all, its basically an access point to conduit-extra
09:34:37 <Cale> I dunno, it's not an entirely valid concern perhaps, but it still feels a bit painful to me.
09:34:37 <breadmonster> hackrilege_: I'm using Yesod as a replacement for the MEAN stack.
09:34:52 <hiptobecubic> breadmonster, you mean as a replacement for Node?
09:34:59 <breadmonster> We should bifurcate the prelude.
09:35:10 <Cale> We can just be careful to share this understanding with beginners.
09:35:13 <hackrilege_> i dont know mean, but i had to use nginx to portforward Yesod, have you managed to get it to serve to remote sockets?
09:35:23 <breadmonster> hiptobecubic: I have no idea. My friends are using the MEAN stack, someone told me to use Yesod.
09:35:36 <Cale> breadmonster: There's also the very valid concern that Foldable *isn't* just toList.
09:35:46 <Cale> :t foldMap
09:35:47 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
09:35:49 <subleq> had to look up MEAN...that's a whole bundle of bad decisions
09:35:52 <Cale> ^^ it's really this thing
09:35:57 <breadmonster> subleq: Why?
09:36:03 <breadmonster> Cale: Sure.
09:36:12 <hodapp> MongoDB, Express, Angular, Node? Did I get it right?
09:36:16 <hiptobecubic> yes
09:36:21 <breadmonster> Cale: I'd much rather have like two preludes.
09:36:27 <hodapp> oyy, that's a hipster alphabet soup right there
09:36:35 <breadmonster> One with all the abstract machinery and one without.
09:36:42 <Cale> breadmonster: It's not about level of abstraction.
09:36:55 <hiptobecubic> breadmonster, MEAN is a "stack" i.e. not just a webserver. It's MongoDB (which is generally terrible), ExpressJS, which I guess is Nodes throwaway http server, Angular, which is like react but worse, and of course Node, which is redundant because you've already said "Express"
09:36:57 <breadmonster> Like classy-prelude but without the suck.
09:37:04 <hackrilege_> i think node is pretty powerful... i think this mean may be better than yesod actually...
09:37:05 <Cale> Lists after all have a universal property. They are abstract.
09:37:31 <Cale> (They're a final coalgebra)
09:37:39 <hodapp> hiptobecubic: why do you prefer React over Angular?
09:37:42 <breadmonster> hiptobecubic: Let's take this onto #haskell-blah or PM? I actually have a few questions for you....
09:37:45 <hodapp> 'prefer' in a relative sense
09:38:02 <hackrilege_> it certainly isnt nice to have to wait 5 years to understand the prelude...
09:38:11 <breadmonster> hackrilege_: ?
09:38:17 <hiptobecubic> hackrilege_, It depends. Do you mind writing javascript and do you have anything CPU bound? If either is yes then Node will not be a good choice for you. Yesod is nice because it's in haskell, which hopefully doesn't need further explaining here :)
09:38:24 <breadmonster> :t map
09:38:25 <lambdabot> (a -> b) -> [a] -> [b]
09:38:28 <breadmonster> Damn!
09:38:41 <Cale> breadmonster: heh, that also threw me
09:38:56 <bibbly> I'm running the interactive ghci at the moment. is there a way to navigate to *.hs files that aren't contained in the PWD where I opened ghci?
09:38:58 <Cale> If you're going to go abstracting foldr, why not go whole hog and do map as well?
09:39:00 <hackrilege_> I have had trouble using Yesod as a standalone webserver, i had to portforward with nginx
09:39:01 <albeit> Using Stack, when I try "stack build", it doesn't detect changes in a file imported from my Main.hs. How can I have it detect changes?
09:39:11 <Cale> Or "abstracting"
09:39:31 <Cale> The degree to which foldr has been "abstracted" by Foldable is tiny.
09:39:34 <breadmonster> :t build
09:39:35 <lambdabot>     Not in scope: ‘build’
09:39:35 <lambdabot>     Perhaps you meant ‘buildG’ (imported from Data.Graph)
09:39:56 <breadmonster> Cale: what is build and how does it work in relation to foldr?
09:40:04 <Cale> because in almost all cases it factors through toList
09:40:25 <kadoban> albeit: Where is the file from? Same project? Is it in the .cabal file?
09:40:41 <ttt_fff> OMG< I just have setup the most amazing hdevtools + syntastic setup
09:40:45 <ttt_fff> this is going to fucking win
09:40:53 <Cale> build :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
09:40:54 <breadmonster> ttt_fff: SHARE PLS
09:41:03 <ttt_fff> haskell-vim-now + hdevtools
09:41:12 <ttt_fff> :w = hdevtools shows me the errors
09:41:14 <albeit> kadoban: It's in the same directory as Main.hs. It's not listed in my .cabal file, but it worked when using cabal and not stack
09:41:19 <ttt_fff> but then, Ctrl=] = jump to where function is defined
09:41:25 <breadmonster> ttt_fff: oh vim ew.
09:41:26 <breadmonster> lol jk
09:41:26 <hackrilege_> bibbly: you should be able to use all command line tools with System.Process and directory navigation tools at System.Directory. if your to level (main) haskell file is in a folder with a subfolder containing .hs files, these should be expose modules as "module MyFolder.MyModule" where this dot is doing directory referencing for you
09:41:27 <Cale> breadmonster: build f = f (:) []
09:41:28 <ttt_fff> ,f , ,F = launches nerd tree to browse files
09:41:36 <ttt_fff> breadmonster -= 9999999999
09:41:42 <hackrilege_> top level*
09:41:45 <ttt_fff>  // emacs loser
09:41:57 <breadmonster> lol
09:42:04 <michaelt> bibbly type :l ../tmp/Zepto.hs 
09:42:13 <breadmonster> ttt_fff: I usually use the FP Complete IDE.
09:42:33 <hodapp> the web one?
09:42:33 <kadoban> albeit: Any chance it's code you can share? I have little expertise, I ask mainly because I'm trying to learn stack more in-depth, so I'd enjoy having it to play with and see what makes it work or not.
09:42:34 <hackrilege_> im using notepad...
09:42:39 <hodapp> >_<
09:42:49 <Cale> hackrilege_: The only problem with notepad is that it won't convert tabs to spaces for you.
09:43:04 <Cale> Just about any editor is okay, so long as it'll convert tabs to spaces automatically.
09:43:11 <albeit> kadoban: Sure! What files would be helpful? The .hs and .cabal and .yaml?
09:43:22 <ttt_fff> autocmd FileType haskell map <silent> <leader><cr> :noh<cr>:GhcModTypeClear<cr>:SyntasticReset<cr> <-- what does this line of vim do ?
09:43:27 <hackrilege_> i use single ' ' indentation and gave up on '\t' along time ago...
09:43:35 <monochrom> on the bright side, notepad doesn't convert spaces to tab
09:43:41 <Cale> monochrom: This is true.
09:43:57 <Cale> hackrilege_: Yeah, so long as you're willing to actually press the spacebar a whole lot, that's fine :)
09:44:09 <monochrom> notepad is about one of those dying breed editors that don't lie
09:44:19 <kadoban> albeit: The whole directory if possible, but probably the .cabal and .yaml at least, and maybe the import statement part from Main.hs and possible the relevent part for the imported module? I could see if I can reproduce from that.
09:44:20 <hackrilege_> if you dont know how indented your nesting is you lose
09:44:43 <chattered> I always use whitespace-mode.
09:44:56 <chattered> And then I complain at people if my buffers look ugly.
09:46:48 <hackrilege_> so how do I understand if my datatype needs to be a Map? im thinking maybe I can do without a lot of the instances provided, e.g. maybe i just need it to be traversable but not foldable...
09:47:31 <kadoban> albeit: By the way, sharing is /not/ required, just if it's easy for you. At a guess, I would think maybe a fix would be adding the module into .cabal, like possibly in other-modules:, if that makes sense?
09:47:47 <kadoban> (but that really is a guess)
09:47:47 <hackrilege_> it would be great if there was a nice reference detailing the inheritance tree of these classes
09:48:14 <albeit> kadoban: I never had to do that with cabal, and it would be pretty annoying to have to add every new file into the .cabal...
09:48:29 <hackrilege_> as then if the inheriting class provides unnesacary functionality i could just use the parent.
09:48:54 <kadoban> albeit: IIUC I think you were always supposed to. I'm not terribly sure how cabal and/or stack handle it when you don't though.
09:49:02 <hackrilege_> it is to be a functor, applicative traversable flodable and a map!?
09:49:20 <hackrilege_> im sure im getting confused here, can you spot it?
09:49:30 <albeit> kadoban: The directory is here http://www.megafileupload.com/hucT/baseball.zip
09:49:45 <kadoban> hackrilege_: Map isn't a typeclass. Have you looked at typeclassopedia? It has some nice guidance on what all of them mean, or at least the big ones, and how they're related.
09:49:50 <hodapp> inheritance, in my experience, doesn't matter nearly as much in Haskell as in many OOP languages (particularly ones where inheritance is the go-to method of abstraction)
09:49:56 <hackrilege_> awesome
09:50:02 <jpl_> hackrilege_: here's a nice image https://wiki.haskell.org/Foldable_and_Traversable
09:50:27 <hackrilege_> omg you guys are just great!
09:50:54 <hackrilege_> i have too many tabs...
09:50:59 <kadoban> albeit: Appreciated, thanks. I'll grab it and see what I can figure out (if anything). Which is the file that changes aren't being picked up in, in case it's not obvious?
09:51:04 <monochrom> convert tabs to spaces
09:51:14 <albeit> kadoban: Both Binsec and Types (basically anything but Main)
09:51:39 <hackrilege_> lol
09:51:48 <monochrom> heh
09:52:18 <prsteele> Hello everyone, question about module naming conventions. Does anyone know how to choose what module heirarchy to use? For example, Hackage has Data, Math, Mathematics, Numeric, and Numerical, all of which might be a reasonable root for my library.
09:52:59 * hackagebot AAI 0.1.0.0 - Abstract Application Interface.  https://hackage.haskell.org/package/AAI-0.1.0.0 (bash0r)
09:52:59 <hackrilege_> what is the library?
09:53:14 <prsteele> for solving Markov decision processes
09:53:41 <hackrilege_> sounds like math to me
09:54:03 <monochrom> consider Math.Applied
09:54:18 <prsteele> I'll take a look at some packages there, thanks.
09:54:26 <monochrom> Data is for data structures
09:54:28 <prsteele> so what I'm getting out of this is that there really aren't any hard rules, then?
09:54:46 <hackrilege_> i think the numerical ones are for grunt stuff...
09:55:21 <hodapp> prsteele: when I looked at the same question a week or two ago, it seemed that there are not really any hard rules, except perhaps to be courteous with existing conventions (if you're going to have a public package)
09:55:26 <monochrom> use a Markov decision process to decide which category to go under
09:55:35 <hodapp> monochrom :P
09:55:38 <hackrilege_> prsteele: there is no way to check...
09:55:38 <jpl_> hahaha
09:55:53 <coppro> oops, I just nuked that project... damnation
09:56:10 <hodapp> prsteele: following the hackage convention is probably not a bad model to follow
09:56:33 <prsteele> thanks everyone
09:56:37 <hackrilege_> like on lemmings...
09:56:41 <kadoban> "the hackage convention" <-- is there one? There seem to be like … 50, none of which mesh at all.
09:56:55 <kadoban> I couldn't find much guidance at all, last I looked.
09:57:41 <hackrilege_> at least its Data.Maybe and not just Maybe anymore
09:59:49 <hackrilege_> can someone talk to me about what Map is if it isnt a class?
09:59:49 <hiptobecubic> The distinction between Data and Control seems really arbitrary and useless
09:59:49 <monochrom> Map is a type from module Data.Map, library "containers"
10:01:38 <hackrilege_> but as it is not a class, i cant override any abstract types... I can make a nice traversable data structure, but why would I use Map?
10:02:04 <kadoban> That's nice to know: stack can build itself :)
10:02:09 <plams> hi, is it possible define a function that casts its arguments, like "foo :: Bool -> Int", where "foo 0" and "foo 1" would be allowed, but not "foo -42"?
10:02:39 <scsdcdfd> @pl \f g x y -> f (x ++ g x) (g y)
10:02:39 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
10:02:59 * hackagebot saltine 0.0.0.4 - Cryptography that's easy to digest (NaCl/libsodium bindings).  https://hackage.haskell.org/package/saltine-0.0.0.4 (JosephAbrahamson)
10:03:08 <monochrom> no, plams.
10:03:50 <hackrilege_> plams, yes, you can use Data.Maybe to handle the exception
10:04:31 <tommd> palms: You can use LiquidHaskell to do this.
10:04:36 <monochrom> but that will be Int -> Maybe Int. totally unlike Bool -> Int
10:04:36 <kadoban> albeit: I think I see the behavior you're describing, playing with it more to make sure.
10:04:40 <tommd> Which, notice, is a layer on top of Haskell.
10:05:20 <hackrilege_> i would write e.g. intToBool i = if (i<= 1) && i>=0 then Just i else Nothing
10:05:35 <plams> a bit of context - I'm writing a 68k disassembler, where instructions are combinations of fixed and variable bits... like "0101ab01" (a and b being either 0 or 1)
10:05:51 <plams> so it's convenient to use pattern matching to write functions like "decode 0 1 0 1 a b 0 1 = ..."
10:06:07 <tommd> plams: Do you  mean "ab being either 00 or 01"?
10:06:16 <plams> I can use Int, but it would be nice with a restriction that would disallow "decode 2 3 4 5 6 7 8 9"
10:06:44 <plams> tommd: a can be 0 or 1, same with b
10:06:53 <hackrilege_> plams: you could use error to exit the program if thats what you want to do when you get an invalid input
10:06:57 <monochrom> I would stick with Bool. decode False True False True a b False True = ...
10:07:46 <monochrom> or I would define my own binary type so I can choose super-short constructor names to save typing. data Binary = O | I
10:07:47 <hackrilege_> :t error
10:07:48 <lambdabot> [Char] -> a
10:07:57 <monochrom> decode O I O I a b O I = ...
10:08:23 <plams> hackrilege_: yeah, I'll definitely have a default pattern - I just wondered if I could constrain it even further, because 2 is not a valid bit, but not all bit patterns are valid either. but the former is a programmer error, the latter is just an invalid instruction which shouldn't stop the program
10:08:29 <hackrilege_> :t isDigit
10:08:30 <lambdabot> Char -> Bool
10:09:07 <plams> monochrom: yeah I thought about "data Binary = O | I", but it looks a bit ackward :) might still be the best solution
10:09:19 <hackrilege_> what should happen when this invalid character is parsed. couldnt you just filter out the rotten values? 
10:09:37 <hackrilege_> > filter (isDigit) "12fwrh4"
10:09:38 <lambdabot>  "124"
10:09:39 <plams> monochrom: I'd prefer "data Bit = 0 | 1" but that's probably disallowed for a reason :)
10:11:03 <hackrilege_> let show' = head.show in show' True
10:11:20 <hackrilege_> > let show' = head.show in show' True
10:11:22 <lambdabot>  'T'
10:11:48 <hackrilege_> so maybe you just want to display the existing datatype Bool in a prettier way?
10:12:58 <scsdcdfd> @pl \x -> if x == [] then 0 else (if ((head x) > 3) then ((7*(head x) + 2) + foo (tail x)) else (foo (tail x)))
10:12:58 <lambdabot> ap (flip if' 0 . ([] ==)) (ap (ap (if' . (> 3) . head) (ap ((+) . (2 +) . (7 *) . head) (foo . tail))) (foo . tail))
10:13:15 <kadoban> albeit: Yeah, it seems to work with my guess above, you should have all of the modules in either other-modules: or exposed-modules. Looking in the cabal docs, that seems to be what it says too … referring to exposed-modules and other-modules: "Either way, all modules in the library need to be listed."
10:14:29 <plams> hackrilege_: my only concern was convenient definition of the bit patterns for 100s of instructions using pattern matching. "data Bit = O | I" might indeed be the best solution - that would constrain input to two values as intended
10:14:55 <kadoban> albeit: Of course that says 'library' and not 'executable', but I think it still applies. So IIUC, you were always supposed to be changing the .cabal when you add new modules. Maybe cabal jsut handled it better when you don't, either accidentally or intentionally? It might be something work mentioning to the 'stack' people though, it's not exactly ideal if it just quietly ignores your changes.
10:15:11 <albeit> kadoban: Okay, thanks! I guess I somehow took advantage of some loophole
10:15:36 <kadoban> s/something work/something worth/
10:16:32 <hackrilege_> plams: so your going to read in a string like "IOIOIOaOO", and produce a list of data constructors [I,O,I,O,I,O error patter match failure... 
10:18:20 <aweinstock> :t if'
10:18:21 <lambdabot>     Not in scope: ‘if'’
10:18:21 <lambdabot>     Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
10:18:22 <plams> hackrilege_: not a string, 68k instructions start with a 16bit word, so my "decode" function (one per instruction) takes 16 arguments
10:19:04 <hackrilege_> so the a is hex?
10:19:27 <monochrom> a is binary
10:19:56 <plams> hackrilege_: say it's only a 4bit word, then functions could look like "decode 0 1 a 0 = InstrA a", "decode 1 0 a b = InstrB a b", and so on
10:19:59 <hackrilege_> ah ok
10:20:43 <plams> hackrilege_: using data Bit = O | I, I can just do "decode I O a b = ...", doesn't look as good, but it solves the problem of invalid input (not invalid instructions)
10:21:39 <hackrilege_> then maybe you make a data type taking 4 arguments?
10:22:19 <hackrilege_> its not so good syntacticaly as you really want to operate on a list for scalability
10:22:52 <hackrilege_> i think really you shouldnt be relying on pattern match errors, you should write your own error
10:23:54 <hackrilege_> e.g. decode l | length l /= 16 = error "incomplete arguments passed to decode"
10:26:13 <hackrilege_> so then if you were reading in 16 values of mixed bool expressions that seem to be being represented as char i think you should write a function taking a string and returning a bool indicating the validity of the string
10:26:43 <hackrilege_> and then throw an error if this check fails
10:28:27 <plams> hackrilege_: I'm quite new to haskell, but won't those be runtime errors? also, input is guaranteed to be 16 bits, so I'm not sure I want to pass an array
10:33:00 * hackagebot Updater 0.2 - Monadic FRP library based on stm  https://hackage.haskell.org/package/Updater-0.2 (yokto)
10:34:38 <Fylwind> aw, where happened to (Control.Lens.Iso.:<->)? I thought it was a cute type operator :c
10:34:44 <Fylwind> s/where/what/
10:36:57 <hackrilege> :t Control.Lens.Iso.:<->
10:36:58 <lambdabot> parse error on input ‘Control.Lens.Iso.:<->’
10:37:16 <hackrilege> :t (Control.Lens.Iso.(:<->))
10:37:16 <lambdabot> Not in scope: data constructor ‘:<->’
10:38:00 * hackagebot AAI 0.2.0.0 - Abstract Application Interface.  https://hackage.haskell.org/package/AAI-0.2.0.0 (bash0r)
10:45:11 <ralu> yet another monad tutorial (not mine) -> http://blog.reverberate.org/2015/08/monads-demystified.html
10:45:19 <hackrilege> im concerned that I will end up representing my data type as in pure haskell and not use the lens package. Will my computations be slower?
10:46:15 <hackrilege> am i losing anything special by not making my data type instances of traversable and functor and simply emulating the desired functionality myself?
10:48:51 <kadoban> hackrilege: You're losing the ability to write nice abstractions over them. Experienced haskellers will be fairly annoyed at your code if they have to work on it probably, etc.
10:49:20 <kadoban> hackrilege: I wouldn't think performance would really come into it much.
10:49:33 <hackrilege> kadoban: im really struggling to get to terms with how to do it
10:49:52 <hackrilege> it seems like i just need a simple tree...
10:50:25 <hackrilege> and then I should write instances to things like Functor, Traversable e.t.c.
10:51:21 <hackrilege> is thats enough? I had a look at using Map to represent my structure, but it seems clumsy with index flags...
10:52:36 <hackrilege> also, my application is one instance, I dont see the virtue in abstracting everything so much, it is not supposed to be used in a more general setting...
10:52:59 <hackrilege> so why would I need it to be a Functor?
10:53:32 <kadoban> hackrilege: Well, you seem to be talking about two separate things, how to implement whatever you're talking about, and then deciding what typeclasses it should be an instance of. Figure out how to implement whatever you're talking about first, either in terms of Map or some other data structure, or manuall, whichever works better for you.
10:53:52 <hackrilege> i can emulate fmap with more intuitive syntax for the reader of my code...
10:54:08 <kadoban> hackrilege: If it's just you using it, and you don't think in terms of Functor yet, then there's little to be gained. If other people will be working on your code, and once you understand Functor, there's more gain to be had.
10:54:39 <hackrilege> its a tree i can traverse edit, concatinate and map over
10:54:50 <hackrilege> maybe also i should be able to fold
10:56:11 <kadoban> hackrilege: I would probably not worry about it at first. Implement the thing first, then see what typeclasses it can be an instance of. Especially when you're unclear what the common typeclasses even mean, you're probably just confusing yourself looking at too many things at once.
10:56:14 <hackrilege> kadoban: its been very helpful to make instances for my datatypes, perhaps im struggling to implement fold in the more general sense where it can be applied to cyclic trees or graphs. 
10:56:20 <nullvoid8> hackrilege: well having the instances means you can automagically use all the code already written that just asks for the instance
10:57:42 <hackrilege> nullvoid8: if i have to implement fmap, and thats the only functionality i need...
10:58:12 <breadmonster> What's foldable but not a functor?
10:58:38 <nullvoid8> well sure, but what if you want to fmap everthing into an IO action, and then run everything. then you need Foldable/Traversable (not sure which)
10:58:58 <hackrilege> perhaps im not so familiar with these added bonuses as i dont know which opperations have been written to act on e.g. functors. since my knowledge of them is only the function required to define them...
11:00:04 <hackrilege> it would be Functor surely?
11:00:28 <hackrilege> as you want to fmap...
11:00:48 <johnw> and you want to use it with code that expects Functors
11:01:13 <hackrilege> johnw, how could I be, i dont know any...
11:01:16 <nullvoid8> for my example? it's fmap to make the IO actions, but then you have Object (IO a), not IO (Object a). but sequenceA would "swap" them
11:01:16 <ttt_fff> what advantages, if any, does using debrujing variables have over just lots of 'fresh' varaibles ?
11:01:53 <johnw> hackrilege: if it's not a library you're making to go on Hackage, then you can do what you want and the reasons will become clear over time
11:01:58 <nullvoid8> ttt_fff: it's just a way to reify variables right?
11:02:07 <nullvoid8> that has a less complex context
11:02:20 <hackrilege> johnw: its to go on hackage
11:02:32 <ttt_fff> nullvoid8: debrujin is less complex?
11:02:36 <johnw> then you will either annoy people, or they will not use your package, most likely
11:02:45 <johnw> just because you can't see how it would be used, doesn't mean we don't :)
11:03:01 <nullvoid8> ttt_fff: debrujin is the that (that this) style right?
11:03:24 <hackrilege> then I shall persevere! thanks, I was thinking I had wasted some time... But your right, it will be better haskell if I do it properly...
11:03:48 <hackrilege> I think thats basically what I was after
11:04:06 <nullvoid8> hackrilege: you could always upload an initial version with what you see as "obvious", and then ask for feedback
11:04:56 <hackrilege> ok, thanks. ill write a short embodiment for appraisal. just so you can check this plan is ok, i just intend to write instances for my datatype 
11:06:40 <edwardk> Fylwind: we decided they generally just confused folks and made it harder for folks to provide the 'right' iso family types because they'd cling to the simpler looking ones
11:10:46 <lpaste_> Hafydd pasted “No title” at http://lpaste.net/137862
11:11:06 <Hafydd> I feel like there should be a shorter way of writing this Monad instance.
11:11:42 <Hafydd> Using some way of applying (>>= f) to every subtree.
11:12:18 <johnw> Hafydd: well, one thing is that you've fused Free into your representation.  As a Free construction, the Monad instance would be free (albeit possibly with other costs)
11:12:26 <aweinstock> :t liftA2
11:12:26 <Cale> Hafydd: deriving Monad might work?
11:12:27 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
11:12:50 <lpaste_> eacameron pasted “Number types” at http://lpaste.net/137864
11:12:52 <johnw> i.e., drop the PAtom constructor, add a recursor type variable, and type Prop = Free PropF
11:12:53 <Cale> Er, is that a thing yet? :)
11:13:05 <johnw> then your Monad instance would be zero lines :)
11:13:15 <eacameron> Can anyone spot my error in that lpaste? It's driving me crazy. I can't get simple integers to multiply!
11:14:02 <martinvlk> @pl (listh . S.toList <$>) <$> runOptionalT (execT (filtering p xs) S.empty)
11:14:02 <lambdabot> (listh . S.toList <$>) <$> runOptionalT (execT (filtering p xs) S.empty)
11:14:13 <johnw> Cale: I don't think deriving Monad will apply here
11:14:17 <Hafydd> Monad isn't derivable in GHC 7.6.3, at least, which I have to use.
11:14:23 <johnw> that's for newtype wrappers around something that's already a Monad
11:14:43 <hackrilege> nullvoid8: here is a paste of some containers that are emulating the functionality of a Functor http://pastebin.com/tn8W8jHn
11:14:52 <kuribas> eacameron: s cannot be both Int64 and Integer.
11:14:55 <Cale> johnw: Well, there's newtype deriving, but I thought I heard some noise about deriving Monad in tree-substitution-like cases like this.
11:15:03 <Cale> johnw: Perhaps I'm mistaken about that :)
11:15:06 <Hafydd> johnw: that's a fair idea.
11:15:06 <eacameron> kuribas: How do I make it act like either?
11:15:13 <kuribas> eacameron: use fromInteger.
11:15:34 <kuribas> or fromIntegral
11:15:37 <kuribas> :t fromIntegral
11:15:38 <lambdabot> (Integral a, Num b) => a -> b
11:15:42 <kuribas> :t fromInteger
11:15:43 <lambdabot> Num a => Integer -> a
11:15:46 <Cale> johnw: Perhaps it's still just DeriveFunctor for now
11:15:53 <Cale> yeah, seems so
11:15:56 <johnw> Hafydd: https://gist.github.com/fe9cfd552250a53228f1
11:16:22 <johnw> Hafydd: the Church version is the one to use if you don't intend to reflect on your structures during construction of them
11:16:31 <eacameron> kuribas: Oh goodness, thank you. That worked. ... sheesh I'm still not used to working with Haskell's numeric types
11:16:45 <Hafydd> johnw: omg, how did you know my module was called Hafydd?
11:16:47 <hackrilege> can anyone see that the code in this paste would be improved by use of lens? http://pastebin.com/tn8W8jHn
11:16:47 * Hafydd blushes.
11:17:02 <kuribas> eacameron: yeah, that's actually a common error :)
11:17:06 <johnw> Hafydd: when writing sample code, and to please my GHC typechecker, I name them after the people I'm writing them for :)
11:17:34 <johnw> Hafydd: anyway, this is the "recursion schemes" approach, which has other benefits, but also other costs
11:17:49 <johnw> I tend to prefer this approach to recursive structures, but not everyone is enamored of them
11:18:00 <Prelude> Cost isn't a significant factor in what I'm doing, so that should be alright.
11:18:05 <Cale> hackrilege: You could use   data Atom = Atom { element :: String, mass :: Int, position :: Vec }  to automatically define the field extraction functions you have there, and to make the types elsewhere prettier.
11:18:17 <edwardk> hackrilege: have you seen http://hackage.haskell.org/package/linear-1.19.1.3/docs/src/Linear-V3.html ?
11:18:23 <ushabti> <http://x0.no/mcja> (at hackage.haskell.org)
11:18:30 <hackrilege> ill clean that up thanks Cale:
11:18:50 <hackrilege> edwardK yes, but Im trying to write everything out by hand here... 
11:18:56 <Cale> ushabti: What the heck?
11:18:58 <ushabti> Cale: Error: "What" is not a valid command.
11:19:06 --- mode: ChanServ set +o Cale
11:19:10 --- mode: Cale set +b *!*@89.46.65.186
11:19:10 --- kick: ushabti was kicked by Cale (ushabti)
11:19:36 <johnw> someone put a link shortener bot in here?
11:19:44 <Cale> Apparently
11:19:54 <monochrom> ah. die die die!
11:20:04 <Cale> It had just connected.
11:20:27 <hackrilege> its like watching a falling star
11:21:17 <fvgvxmpv1> die, bart, die (it´s german ;))
11:22:09 <hackrilege> Cale: my atom was a type, it should be data?
11:22:30 <johnw> I could imagine a link *expander* bot being useful, but a link shortener bot is kind of stupid, after the link has already appeared
11:22:33 <Cale> hackrilege: Yes. Generally if you're using tuples in any kind of systematic way, they should be user-defined data types instead.
11:22:49 <hackrilege> sweet!
11:22:59 <Hafydd> The only problem is that it might be difficult to explain this to other people looking at the code...
11:23:09 <Tene> johnw: I've known people who claim that link shorteners are useful to them on IRC because their clients somehow have trouble handling longer links?  I think on mobile devices?
11:23:12 <hackrilege> and my Vec is a newtype?
11:23:18 <johnw> Hafydd: point them to https://www.youtube.com/watch?v=Zw9KeP3OzpU :)
11:23:19 <geekosaur> link shorteners turn out to be handy for people using irssi and friends (text mode)
11:23:36 <johnw> Tene: huh, never even thought of that
11:23:36 <Tene> geekosaur: I use irssi, and I have no trouble with long links, so it can't be that.
11:23:41 <Cale> hackrilege: Having some simple pair as the result of a function somewhere that you wouldn't want any new data type for is fine, but once you use a tuple type in more than a couple places, it's generally a good idea. Especially if you're defining the projections, use record syntax.
11:23:43 <Tene> Unless they're using a weird deficient terminal, maybe?
11:23:52 <geekosaur> because if a link wraps it can be hard to get it as a single string. (this does depend on the terminal emulator)
11:23:54 <hackrilege> shouldnt i make Atom newtype as it has only one argument?
11:24:02 <Cale> hackrilege: It doesn't.
11:24:03 <geekosaur> (it's also surprisingly hard for terminal emulators to get right)
11:24:06 <Cale> hackrilege: It has three.
11:24:07 <Tene> Oh, I guess on Windows, many people use PuTTY.
11:24:36 <hackrilege> one tuple i mean not like data X = X a b 
11:24:50 <hackrilege> no, not like data X = A a | B b
11:25:06 <hackrilege> so its a newtype... right?
11:25:08 <Cale> hackrilege: no.
11:25:16 <hackrilege> doh.
11:25:28 <Cale> hackrilege: Newtypes only allow a single constructor with a single argument.
11:25:42 <Cale> Not a single constructor with multiple arguments like you have here.
11:26:11 <hackrilege> so my 3 tuple Atom is a valid newtype as is my Vec?
11:26:23 <geekosaur> (specifically, (n)curses sometimes outputs wrapped lines in a way that makes terminal emulators think they are separated)
11:26:30 <nullvoid8> hackrilege: no, neither is
11:26:52 <Cale> hackrilege: If you wanted to use a single argument which happened to be a 3 tuple, but that would defeat most of the point of what I was asking you to do.
11:27:09 <Cale> hackrilege: Which is that if you define a record type, you get automatic field extractors.
11:27:17 <hackrilege> (code in question is)  newtype Vec  = Vec  { unVec :: (Double,Double,Double) } deriving (Eq)
11:27:40 <geekosaur> actually I probably shouldn't say that, as modern ncurses may handle it. last time I had to deal with it was on an SVR3 and its curses definitely made it harder than it should have been :/
11:27:44 <nullvoid8> hackrilege: that just completly defeats the point though
11:28:00 <hackrilege> but i dont get the point...
11:29:25 <Rembane> Is the cons operator right-associative?
11:29:43 <merijn> Rembane: ":info (:)" in ghci and check fixity?
11:29:54 <Rembane> merijn: Thank you.
11:30:27 <merijn> Rembane: And if an operator lacks fixity it has the default, i.e. infixl 9
11:30:37 <Rembane> merijn: Does infixr 5 : mean right associative with precedence 5?
11:30:39 <hackrilege_> a valid newtype should not take a tuple, is this correct? if so, why?
11:30:43 <merijn> Rembane: Yes
11:30:52 <Cale> hackrilege: The point is that if you define  data Vec = Vec { x, y, z :: Double } then you automatically get functions  x :: Vec -> Double, etc.
11:30:52 <Rembane> merijn: Sweet! 
11:31:08 <Cale> hackrilege_: and you don't have to waste a bunch of lines of code defining them one by one
11:31:13 <merijn> Rembane: 0 being lowest, 9 being highest (well, highest definable. Function application has precedence 10 and record syntax precedence 11)
11:31:32 <hackrilege_> right! thats why the tuple is bad, sorry for being slow...
11:31:39 <Cale> hackrilege_: and it's no more or less efficient than the newtype, since the triple data constructor takes as much memory as the Vec data constructor will
11:32:00 <Rembane> merijn: Ah, of course. Nice!
11:32:39 <hackrilege_> i was just confused, i thought it was convention that a one argument data constructor should be a newtype, i didnt realise the tuple violated this for the reasons you described
11:34:02 <Cale> hackrilege_: This is not a one-argument data constructor, and that is not *always* true.
11:34:47 <Cale> Sometimes it's worthwhile to have a data type nonetheless. The semantics of newtype vs. a one-constructor one-argument data type are different. In the latter case, you can store an unevaluated expression under the constructor.
11:35:03 <Cale> Usually that's just a bit of a waste, but I wouldn't expect that it always is.
11:35:33 <Cale> (I can think of some subtle uses for it when you want to carefully control how much of something is evaluated now vs. later)
11:35:58 <hackrilege_> there was some consideration about hiding the data constructor and exporting a lower case version to repress pattern matching incase the data structure changed, is this good convention? I know my data types keep changing... maybe there is a generic way to handle this as long as i define instance of Functor?
11:36:30 <Cale> It really depends.
11:37:03 <hackrilege_> ok
11:37:15 <Cale> You have to think about how you expect your program to change.
11:37:37 <Cale> Also, there are some extensions which can be used to define new patterns
11:38:02 <Cale> So you can get backward compatibility if you don't mind renaming your constructors
11:38:03 <hackrilege_> so can we clean this up using Functors? apply f (Vec (a,b,c)) = Vec (f a,f b,f c)
11:38:10 <Cale> That's not a functor instance.
11:38:19 <Cale> You could make this type a functor...
11:38:35 <Cale> data Vec a = Vec { x, y, z :: a }
11:38:37 <hackrilege_> deriving Functor?
11:39:09 <hackrilege_> @let data Vec a = Vec { x, y, z :: a }
11:39:10 <hackrilege_> :t 
11:39:10 <lambdabot>  Defined.
11:39:11 <lambdabot> <no location info>: not an expression: ‘’
11:39:22 --- mode: Cale set -o Cale
11:39:22 <hackrilege_> :t y
11:39:23 <lambdabot>     Ambiguous occurrence ‘y’
11:39:24 <lambdabot>     It could refer to either ‘L.y’,
11:39:24 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:159:21
11:39:31 <hackrilege_> meh
11:39:59 <hackrilege_> is y :: a ?
11:40:06 <arkeet> y :: Vec a -> a
11:40:30 <Cale> hackrilege_: lambdabot already brings things with names x, y, z into scope, and so you're getting name conflicts
11:40:47 <hackrilege_> i dont understand how including ":: a" after z makes the datatype derive Functor...
11:40:53 <Cale> It doesn't.
11:41:02 <hackrilege_> oh...
11:41:12 <Cale> You still have to either tell it to derive Functor, or write the Functor instance by hand.
11:41:28 <Cale> The original type is not a functor, and you can't write a Functor instance for it.
11:41:29 <arkeet> @let deriving instance Functor Vec
11:41:31 <lambdabot>  Defined.
11:41:35 <Cale> (the one which used Double)
11:41:35 <Peaker> What would be the downside of having sugar notation for applicative/monadic binds that looks like:   foo @(some such) @(other @(stuff))  desugaring to:  foo <$> some such <*> (stuff >>= other) ?  i.e: allow a style very similar to impure languages, but mark the bind points with some lightweight syntax?
11:41:43 <arkeet> > fmap (+1) (Vec 1 2 3)
11:41:45 <lambdabot>      No instance for (Show (Vec b0))
11:41:45 <lambdabot>        arising from a use of ‘show_M23334598860077833212529’
11:41:45 <lambdabot>      In the expression:
11:41:52 <arkeet> @let deriving instance Show a => Show (Vec a)
11:41:53 <lambdabot>  Defined.
11:41:53 <arkeet> > fmap (+1) (Vec 1 2 3)
11:41:55 <lambdabot>  Vec {x = 2, y = 3, z = 4}
11:42:27 <Cale> Peaker: I dunno, it makes it unclear which order effects happen in, which is already a problem.
11:42:43 <hackrilege_> thanks arkeet: this is getting somewhere!
11:42:51 <Peaker> Cale: it could be easily defined as left-to-right appearance of @ from same level, and deeper to less deep if nested?
11:43:09 <Cale> Peaker: Yeah, you can invent a convention, I suppose.
11:43:12 <Peaker> I am reading some OCaml code, and the ability to seamlessly mix mutable reference reads in pattern matches and ordinary code is very convenient. Not worth giving up purity for it, but why not have both?
11:43:24 <Cale> Peaker: But it's the sort of thing which hides bugs.
11:43:26 <michaelt> how does it differ from that idris sugar? 
11:43:47 <Cale> I've actually come to prefer being a little more verbose and using do-notation.
11:44:02 <hackrilege_> hows about; apply2 f (Vec (x,y,z)) (Vec (a,b,c)) = Vec (f x a,f y b, f z c)
11:44:06 <Cale> In most cases anyway.
11:44:11 <Peaker> Cale: but forcing one effect per line is really annoying :(
11:44:20 <Cale> hackrilege_: Why are you passing triples to the Vec constructor?
11:44:23 <Peaker> Cale: also, this kind of notation could extend to pattern matching where it really helps
11:44:35 <Cale> Peaker: Is it really annoying? Or is it helpful? :)
11:44:57 <hackrilege_> > Vec 1 2 3
11:44:58 <lambdabot>  Vec {x = 1, y = 2, z = 3}
11:45:16 <Peaker> Cale: well, if Applicative-style is nice, then this is nice for the same reason, but extends to more nice cases
11:45:18 <hackrilege_> > putStr $ show $  Vec 1 2 3
11:45:19 <lambdabot>  <IO ()>
11:45:40 <Cale> Peaker: Surely you're aware of idiom brackets?
11:45:50 <Peaker> Cale: yes, they were the original inspiration :)
11:46:13 <hackrilege_> apply2 f (Vec x y z ) (Vec a b c) = Vec (f x a) (f y b) (f z c)
11:46:21 <Peaker> Cale: but then I was wondering why idiom brackets and not monad brackets :)
11:46:56 <Peaker> hackrilege_: why not make Vec an instance of Applicative?
11:47:12 <Cale> I guess because it's less ambiguous how to compose things
11:47:13 <Peaker> michaelt: oh, only now saw your question -- I don't know. What sugar does Idris have?
11:47:13 <hackrilege_> I think thats probably the answer....
11:47:41 <eacameron> kuribas: So I think the reason I'm hitting this is because I'm trying to a sign function that applies the sign at every call site, but GHC is instantiating the type of "s" too soon for my purposes, is there a way to say "Keep s as Num a and don't try to instantiate it yet"?
11:47:58 <eacameron> *trying to make a sign function that....
11:48:10 <Cale> eacameron: Can I see the code?
11:48:20 <hackrilege_> @let deriving instance Applicative a => Applicative (Vec a)
11:48:21 <lambdabot>  .L.hs:165:53:
11:48:21 <lambdabot>      Expecting one more argument to ‘a’
11:48:21 <lambdabot>      The first argument of ‘Vec’ should have kind ‘*’,
11:48:31 <Cale> eacameron: If it's polymorphic, it should be fine, but perhaps the monomorphism restriction applies?
11:48:45 <michaelt> Peaker: http://idris.readthedocs.org/en/latest/tutorial/classes.html#notation
11:49:02 <Cale> eacameron: Do you have any relevant functions which don't have explicit type signatures?
11:49:18 <Cale> and which might be defined without explicit function arguments to the left of the = sign?
11:49:25 <Peaker> michaelt: oh, apparently I've reinvented the exact same thing! :)
11:49:38 <Peaker> michaelt: cool :)
11:49:52 <kuribas> eacameron: use fromIntegral on both?
11:49:58 <michaelt> Peaker: everyone really likes it, so maybe it would be worth the trouble. I don't know.
11:50:22 <Cale> michaelt: I hope I don't get to maintain code written using that syntax :D
11:50:41 <Peaker> Cale: Why? Ordering sounds even more unambiguous using this style
11:50:59 <Cale> I'd really rather have the do-expressions
11:51:09 <michaelt> Cale: mostly you avoid cooking up intermediate names 
11:51:16 <hackrilege_> how do i easily derive the instance of Applicative for Vec a = Vec { x,y,z ::a}?
11:51:38 <Cale> Yeah, I'm less worried about the names, and more worried about having to think about the order in which everything occurs.
11:51:53 <lpaste_> eacameron revised “Number types”: “No title” at http://lpaste.net/137864
11:51:54 <hackrilege_> @let deriving instance Applicative a => Applicative (Vec a a a)
11:51:55 <kadoban> hackrilege_: At first I probably wouldn't bother trying to automatically derive that stuff. It sounds instructive to manually do it initially.
11:51:55 <Cale> If it's written explicitly with do-notation, I don't have to think so hard about that
11:51:55 <lambdabot>  .L.hs:165:49:
11:51:55 <lambdabot>      ‘Vec’ is applied to too many type arguments
11:51:55 <lambdabot>      In the stand-alone deriving instance for
11:52:03 <eacameron> Cale: kuribas: Updated the paste
11:52:09 <Cale> I suppose in a commutative monad it doesn't matter so much.
11:52:34 <hackrilege_> i was quite happy with its deriving Eq and Show...
11:52:40 <michaelt> Cale: yes, it's pretty straightforward. The objection you are making surely applies to the 'applicative' style generally, no?
11:52:54 <Cale> michaelt: Yes.
11:53:18 <kadoban> hackrilege_: Eq and Show are conceptually pretty clear, and also can be derived in vanilla haskell.
11:53:21 <michaelt> Yeah, I think I have the same objection. 
11:53:26 <kuribas> eacameron: I meant use fromIntegral on s...
11:53:27 <eacameron> Cale: kuribas: wow...I have no idea what I did but it suddenly compiles
11:53:46 <Peaker> Cale: I think lots of point-free compositions people use in practice with monadic code, to avoid the annoying names and one-stmt-per-line make the order far harder to decipher
11:53:57 <Peaker> Cale: the order of ! left-to-right, nested-first, sounds very easy
11:53:57 <Cale> Peaker: Yeah, I don't like those either.
11:54:22 <lpaste_> kuribas annotated “Number types” with “Number types (annotation)” at http://lpaste.net/137864#a137868
11:54:26 <michaelt> Cale likes one statement per line
11:54:31 <Cale> I prefer just being explicit about the order in which things are occurring, in any monad where it might matter.
11:54:35 <Peaker> Cale: the style you like was named ALGOL-style by Bob Harper :)
11:54:36 <Cale> (which is most monads)
11:54:40 <hackrilege_> i was thinking it was conceptually pretty clear what my apply2 was trying to do... apparently it seems like the default behaviour of an instance of Applicative...
11:54:40 <hackrilege_> apply2 f (Vec x y z ) (Vec a b c) = Vec (f x a) (f y b) (f z c)
11:54:53 <eacameron> kuribas: As yes that's what I did at first which worked, the trouble is I have this some code a dozen times
11:54:53 <Cale> In commutative monads, fine.
11:55:00 <eacameron> kuribas: I was hoping to factor out that verbosity
11:55:10 <Peaker> Cale: what about commutative actions in non-commutative monads?
11:55:13 <eacameron> kuribas: but it seems as though I've stumbled upon the answer?
11:55:24 <kuribas> eacameron: good :)
11:55:41 <Cale> Peaker: maybe okay, but that requires me to think about whether or not it's really okay when I see it.
11:55:46 <Peaker> Cale: for example, x <- getLine ; y <- getLine is the same with x,y swapped. So it's nice to write: runPlayer !getLine !getLine
11:55:51 <lpaste_> eacameron annotated “Number types” with “Number types (annotation)” at http://lpaste.net/137864#a137869
11:56:04 <Peaker> Cale: annoying to waste 3 lines instead of 1 on that
11:56:21 <Cale> Peaker: I need to think about what getLine does in order to ensure that it doesn't matter what order, which in the case of getLine might not be so bad, but in general...
11:56:36 <Peaker> Cale: but you have 2 getLines, the order doesn't matter
11:56:39 <eacameron> kuribas: Cale: thanks for your help
11:56:54 <Cale> Peaker: Well, okay, if you have the same action repeatedly
11:56:55 <Peaker> Cale: also, foo !x !y !z     has quite a clear order!
11:57:30 <Cale> If you say so
11:57:39 <Cale> It's z first, right? :)
11:57:51 <kuribas> eacameron: Do you understand why the first didn't type check?
11:58:34 <Peaker> Cale: only in tardis :)
11:59:42 <Cale> Because clearly that desugars to  (foo !x !y) =<< z
11:59:57 <Cale> (I know, I know...)
12:00:41 <eacameron> kuribas: I thought I had tried this before and it didn't work. I'm thinking I had something else botched and it totally messed with my intuition
12:01:20 <Peaker> Cale: do you remember you need to read "do" downwards? :)
12:01:20 <eacameron> kuribas: but yes in general, GHC picks a type for "s" right away and can't find *one* type
12:01:54 <kuribas> eacameron: I don't think that's quite correct.
12:02:06 <Cale> Peaker: usually :)
12:02:32 <Cale> Peaker: I don't like anything which tries to invade the syntax of expressions much more than that though.
12:02:39 <eacameron> kuribas: hmm, help me out
12:02:45 <Cale> Imposing an order where there ought not to be one
12:02:59 <kuribas> eacameron: It tries to unify the variable with Int64, and then with Integer, but it cannot do both.
12:03:36 <Peaker> Cale: "ought" ought to be justified :)
12:03:54 <Cale> Well, it's a personal value judgement
12:04:55 <Cale> So, how does ! interact with let and case?
12:05:09 <Peaker> anyway, the pattern-matching extension (allowing to pattern match behind mutable refs notationally) really makes imperative code nicer
12:05:23 <eacameron> kuribas: ok that makes sense. I thought, "ok so I can move this into a function `sign`", which also didn't work. So I thought that the function itself was trying to unify and failing.
12:05:24 <michaelt> Cale: I guess you wouldn't object to idiom brackets or the like for the 'Concurrently type in async
12:05:31 <Cale> let v = !f !x in foo v
12:05:34 <Cale> Is that allowed?
12:05:43 <eacameron> kuribas: actually I just found the code that I thought would work: "sign = fromIntegral . (*s)"
12:05:59 <eacameron> kuribas: writing pointful works: "sign x = fromIntegral (x*s)"
12:06:06 <eacameron> kuribas: now *THAT* I don't understand
12:06:23 <johnw> eacameron: what is the type of sign?
12:06:29 <johnw> this happens when RankNTypes are involved
12:06:32 <Cale> michaelt: If the order really doesn't matter, and you don't need to think too hard, then notations which make it implicit are fine with me
12:06:58 <eacameron> johnw: it's inferred
12:07:05 <johnw> what *would* it be
12:07:06 <johnw> ?
12:07:13 <Cale> michaelt: I just prefer the notation to be really clear about ordering whenever it *might* matter.
12:07:21 <eacameron> johnw: I would think it would be the same either way
12:07:30 <eacameron> johnw: So I'm not sure which one to answer
12:07:31 <shachaf> I don't see any rank-n types.
12:07:31 <kuribas> eacameron: hm, I guess you are right, it must find an instance, but it cannot choose...
12:07:32 <johnw> yeah, but clearly not, so it's important to know what the types are
12:08:03 <Peaker> Cale: what about bang patterns?
12:08:05 <michaelt> Cale: people seem to really like the applicative style for parsing; order is basically always relevant there. 
12:08:11 <johnw> shachaf: yes, it's hard to believe that something involved in multiplication would introduce rank-n; I only mention it as another case where this distinction matters
12:08:24 <Peaker> Cale: I think for the "let" in a "do" block, I'd expect the effect to be bound at the "let" line itself (not the use site)
12:09:00 <eacameron> johnw: so for the one that works: sign x = fromIntegral (x*s) :: Num a => a -> Integer -> a
12:09:05 <Cale> Peaker: and if there are a bunch of !'s in various definitions inside the let?
12:09:13 <eacameron> johnw: (GHC warns me that it's picking "Integer" for 5)
12:09:19 <Cale> Peaker: Do we order the definitions? What if the definitions are mutually recursive?
12:10:07 <shachaf> Cale has already told you what the issue was.
12:10:20 <michaelt> oh
12:10:33 <Peaker> Cale: hmm.. you're right, since you really can't have the ones behind lambdas happen in any other context but the inside of a lambda, the same should apply to the let. it should probably make the type of the let have the effect
12:10:37 <Cale> eacameron: You should give a type signature to sign, not to the right hand side of sign's equation.
12:10:58 <eacameron> johnw: I know almost nothing about RankNTypes but I actually guessed it was playing a role here
12:11:07 <shachaf> It isn't playing a role here.
12:11:13 <eacameron> Cale: Can you do that in ad-hoc let's within a do block?
12:11:14 <Cale> Peaker: Well, I suppose you can just say "no let allowed"
12:11:38 <johnw> eacameron: what is "s"?
12:11:42 <Cale> eacameron: yes, just add a line before it with  sign :: Num a => a -> Integer -> a
12:11:45 <Cale> or whatever
12:11:54 <eacameron> Cale: good to know ;)
12:11:58 <Cale> er, that's not the right type
12:12:01 <Cale> But whatever
12:12:16 <Peaker> Cale: if you want the effects, you use result <- ... !effects ...   if you just want to name an effectful stmt, you can use: let foo = ... !bar ...   so I think that should be:  let foo = bar >>= \x -> ... x ...
12:12:37 <eacameron> johnw: I presume you're asking it's type: I think it's being inferred as "Num a => a"
12:12:53 <Cale> Peaker: The problem becomes disambiguating how far outward in the scope the ! applies to
12:12:54 <johnw> well, it appears on the right-hand side of your =, but I don't see it anywhere else
12:13:04 <johnw> I'm just trying to replicate what you're experiencing here
12:13:11 <eacameron> johnw: http://lpaste.net/137864
12:13:14 <eacameron> last annotatio
12:13:15 <eacameron> n
12:13:21 <Peaker> Cale: yeah, I think it stops at binders
12:13:22 <johnw> ah, right
12:13:41 <Peaker> (excluding  foo <- ...   as a binder)
12:13:55 <johnw> eacameron: just a guess, but what if you disable the monomorphism restriction?
12:14:05 <Peaker> oh wait, including it as a binder.. the ... is just the effectful result of the desugaring
12:14:16 <eacameron> johnw: you suspect that will allow the pointfree form?
12:14:23 <johnw> I have a suspicion
12:15:14 <eacameron> johnw: Indeed it does!!
12:15:27 <Cale> eacameron: Oh, your problem was  signs = [1,-1]?
12:15:34 <johnw> so, with the restriction on, "sign" is being restricted to a single inferred type
12:15:43 <johnw> but you're using it at two types
12:16:00 <eacameron> johnw: I suspected something like that, but why pointful works?
12:16:13 <johnw> because it infers a more general type to begin with, it would seem
12:16:20 <shachaf> Cale said that the problem was the monomorphism restriction half an hour ago. Usually a good idea to listen to Cale.
12:16:21 <johnw> something that "fits" your two uses
12:16:21 <Cale> eacameron: Because the monomorphism restriction only applies to pattern bindings
12:16:30 <shachaf> eacameron; Because that's how the monomorphism restriction works.
12:16:38 <Cale> and not to function bindings
12:16:43 <shachaf> You should read about it because it's slightly subtle and plenty has been written about it already.
12:16:46 <johnw> Cale: good to know
12:16:51 <shachaf> @google monomorphism restriction
12:16:52 <lambdabot> https://wiki.haskell.org/Monomorphism_restriction
12:17:47 <Peaker> The dreaded monomorphism restriction strikes again
12:17:54 <johnw> it's really not very dreaded
12:18:21 <johnw> i've run into it, I think maybe once in two years?  But I also don't write generic functions in point-free form within let/where bindings too often
12:18:23 <eacameron> shachaf: Cale: I saw that but didn't know how to apply it to my brain :)
12:18:34 <Peaker> I guess surprising everyone with type inference is less horrible than surprising with performance bugs at runtime, however the former happens so much more frequently
12:19:09 <johnw> Peaker: I'll go with the error vs. silently bad behavior any day
12:19:10 <shachaf> Peaker: I ran into the thing that the monomorphism restriction tries to prevent at least once.
12:19:13 <shachaf> It was very annoying.
12:19:28 <shachaf> I'm undecided on the restriction.
12:20:10 <Peaker> Yes, runtime bugs are far worse, but the MR hits me a looot, and this perf bug, I don't remember when (And I don't expect great performance from Haskell anyway)
12:21:04 <eacameron> shachaf: Haha, well next time I hit a confusing GHC error I'll be sure to go read every conceivable article on the internet about type errors in hopes I find the answer! ;)
12:21:07 <johnw> you should expect great performance from GHC; you maybe shouldn't expect great performance from how you write your Haskell code :)  But the latter is usually much easier to improve upon
12:21:30 <shachaf> eacameron: Now you know that turning off the monomorphism restriction makes your code compile.
12:21:35 <kuribas> How does haskell choose the type?   Why Integer and not Int?
12:21:46 <shachaf> eacameron: The obvious next step is to read an explanation of what the monomorphism restriction is.
12:21:53 <exio4> kuribas: defaulting rules
12:21:55 <srhb> kuribas: Defaulting rules, if nothing else.
12:21:56 <johnw> kuribas: Integer would be correct for every argument value, Int wouldn't
12:22:10 <srhb> kuribas: The default defaults (ha) are (Integer, Double)
12:22:29 <johnw> I believe you can say "default (Int)" at the top of your file
12:22:29 <eacameron> shachaf: Haha, yes I have learned that now. I'll look into it. So it sounds like folks don't just turn it off it cabal and call it good?
12:22:33 <kuribas> What about user defined classes?
12:22:40 <eacameron> *in cabal
12:22:42 <johnw> eacameron: I don't turn it off
12:22:46 <Peaker> johnw: IME (corroborated by others) getting great performance from GHC is harder than dropping to a low-level language. Writing C in Haskell is harder than writing C in C
12:22:46 <shachaf> eacameron: At the very least you should understand why it's on by default.
12:22:57 <shachaf> eacameron: Most of the time people just write type signatures so there's no problem.
12:23:00 <eacameron> shachaf: good paint
12:23:03 <johnw> Peaker: I get good performance by not trying to write C in Haskell
12:23:04 * hackagebot stomp-conduit 0.1.0 - Stompl Conduit Client  https://hackage.haskell.org/package/stomp-conduit-0.1.0 (TobiasSchoofs)
12:23:05 <eacameron> *paint
12:23:07 <eacameron> *point
12:23:28 <Peaker> johnw: looking inside high performance libs like ByteString, Text, etc, you see a lot of C-in-Haskell
12:23:33 <srhb> kuribas: If you haven't added a default, and there's more than one type to pick from, it does not compile.
12:23:34 <eacameron> shachaf: yeah, that was partly my problem: i didn't know you could add type sigs inside of a let
12:23:44 <Peaker> johnw: and it's slower than the C I'd write in C :P
12:24:47 <johnw> Peaker: I'm not writing libraries like ByteString.  Thinking that all Haskell performance scenarios are similar to those libraries is a bad assumption
12:25:07 <kuribas> srhb: how do you add a default? 
12:25:08 <Peaker> johnw: I think there are certain styles of C code that are not widely known -- that remove indirections/dynallocs, improve cache locality and remove conditionals, and when people compare HLL's to C, they almost always compare it with the more common style that uses a lot of malloc/free/void*'s
12:25:15 <johnw> that's the same assumption that leads so many peolpe to jump straight to using Vectors before really understanding how their programs will operate at runtime
12:25:26 <srhb> kuribas: See 4.3.4 of the language report. I think it's default (type1, type2, type3...)
12:26:11 <exio4> Peaker: I don't think anyone here said "you can get more performance than extremely-optimized-C", it was pretty much 
12:26:26 <exio4> it was pretty much "you can get good performance, it's not that bad" 
12:26:30 <johnw> yeah
12:26:33 <Peaker> johnw: when I write C, I can usually sort-of guess about how long micro benchmarks will take (roughly counting cache misses)
12:26:41 <srhb> kuribas: It is indeed. You can even try it in ghci. try default (); 2;
12:26:43 <johnw> we're not competing with the hand-tuned assembly programs of an Intel engineer
12:27:02 <kuribas> srhb: interesting, I wasn't even aware that syntax existed!
12:27:14 <srhb> kuribas: It's not often used.
12:27:20 <Peaker> johnw: Well, I compare the way I write C, with the way I write Haskell (I'm proficient in both)
12:27:37 <johnw> Peaker: I don't know how you write Haskell, which is why I'm challenging the assumptions
12:28:03 <johnw> I get better performance from Haskell by *not* writing programs as if it were a bizarre flavor of C, is all that I'm saying
12:28:59 <Peaker> johnw: I obviously don't write Haskell as if it were C -- I start out with what looks nice
12:29:25 <exio4> I think people tend to overuse either lazyness or strictness 
12:29:43 <johnw> Peaker: if you run into some slow Haskell, let me know and we'll take a look together
12:30:38 <Peaker> johnw: thanks -- now profiling a very very slow Haskell project of mine, I might take you up on that :)
12:30:56 <johnw> I really enjoy optimization work
12:32:34 <broma0> Hello
12:32:42 <levi> "C in Haskell" is maybe a bit of a misnomer, too.  Heavily optimized Haskell definitely looks different than unoptimized Haskell.
12:33:39 <exio4> I think the best part out of Haskell is that we can throw the heavily optimized haskell to libraries, with a nicer api though 
12:33:52 <broma0> Quick question, why use newtype instead of a type alias for a monad stack?
12:34:59 <johnw> exio4: or that often, esveral well-performing modules can be composed into a well-performing programs, without requiring bizarre tricks to avoid losing the optimization gains from those modules
12:36:30 <Peaker> johnw: a few performance painpoints off top of head: A) SPECIALIZE pragma is very important but too tedious to use massively  B) core analysis is too hard (e.g: showing the transformation step by step and preserving names/annotations better would help)  C) Polymorphic fields cannot be unpacked  D) Laziness implies boxing (IMO that's not inherent)
12:36:51 <Peaker> johnw: E) Sum types imply boxing (also not inherent)
12:37:06 <johnw> Peaker: these concerns are often the last ones I have to think about
12:37:19 <johnw> the real performance issues are typically higher up the ladder
12:37:30 <johnw> that's why we'd need to look at real code together
12:37:53 <levi> And from my limited understanding of Haskell optimization, *some* of it involves the awareness of low-level machine details that you need for C optimization, but there are also other things to be aware of (GHC compiler and runtime details, etc.) that aren't in common with C optimization.
12:38:26 <Peaker> johnw: I have a Parsec parser of Makefile-like syntax (Parsec is the only monadic parser supporting IO for textual "include" support) -- I wanted to have it use a type-class instead of IO directly, to restrict IO effects. Slowed the already-super-slow parser down 2x
12:38:40 <Peaker> johnw: I think it's the type-class dictionaries being passed around
12:38:48 <Peaker> johnw: SPECIALIZE would solve it, but too tedious to use
12:38:55 <hiptobecubic> Peaker, how would laziness not imply boxing?
12:38:58 <johnw> also, when reuse/sharing is happening, if you're thrashing GC (i.e., resident stay lows, but generation count is huge), when GC will happen, etc.
12:39:13 <Peaker> johnw: INLINE all the things (just to cause specalization) made it fast again (but now the module takes ~20 seconds to compile!)
12:39:35 <Peaker> (and I had to increase -fsimpl-count or such)
12:39:47 <kuribas> Peaker: I have SPECIALIZE on most (not small) functions in my library.
12:40:04 <johnw> INLINE'ing everything is usually bad too
12:40:09 <broma0> Why use newtype for a monad stack?
12:40:10 <Peaker> hiptobecubic: struct LazyInt { uint32_t is_thunk : 1; uint32_t val : 31; };
12:40:14 <johnw> I agree that one's a pain: discovering when and where INLINE actually helps
12:40:30 <johnw> broma0: can you give more context?
12:40:33 <Peaker> johnw: well, it fixed the issue (presumably by SPECIALIZE'ing, because the 2x penalty was introduced by passing a type-class dict)
12:40:57 <Peaker> it takes my parsec parser about 6 seconds(!!) to parse a few hundred makefiles
12:41:02 <Peaker> (that's terrible!)
12:41:11 <johnw> Peaker: send me the code, and sample input that demonstrates the slowness
12:41:14 <kuribas> johnw: also INLINEing very small functions?
12:41:30 <johnw> in an assembler we have at work, removing *all* INLINE directives improved speed by 3x
12:41:47 <johnw> so I just know it's not an "always helps" hammer
12:41:58 <exio4> Peaker: I think that lazyint is missing the possible closure for generating that possible value 
12:42:04 <johnw> even INLINEABLE caused problems, for certain functions
12:42:11 <Peaker> johnw: https://github.com/ElastiLotem/buildsome/blob/master/src/Lib/Makefile/Parser.hs is the code. The sample input is proprietary, I can probably get approval to get it out too
12:42:52 <kuribas> johnw: I put INLINE on all my vector functions.  So it's better to remove them?  https://github.com/kuribas/cubicbezier/blob/master/Geom2D.hs
12:42:56 <johnw> Peaker: if you could
12:43:04 <johnw> kuribas: test
12:43:07 <johnw> the only answer is "test"
12:43:08 <Peaker> exio4: you could hide a ptr in the 31 bits iff it is a closure (the closure is indirected but the evaluted result isn't).  For larger-than-int values, you can have a union { closure; final val; };
12:43:36 <johnw> performance discussions in the abstract are generally fruitless
12:43:45 <broma0> johnw, I often seen as transformers demonstrated using a new type. Why would you use "newtype X = X { runX :: blah }" instead of just "type X = blah"
12:43:49 <broma0> It saves the typing of all the "deriving" clauses
12:43:51 <johnw> today's processors can be spooky in what they will and won't execute quickly
12:44:11 <johnw> broma0: in order to have unique instances for your type X
12:44:48 <johnw> with GeneralizedNewtypeDeriving, you can avoid writing most of the instances that already exist for the blah type
12:45:33 <aweinstock> Peaker: wouldn't it be: struct LazyInt { bool is_thunk; union { uint32_t evaluated; uint32_t (*)(void) unevaluated; } value; } ?
12:45:38 <johnw> for example, look at what I did here in pipes-safe: https://github.com/Gabriel439/Haskell-Pipes-Safe-Library/blob/master/src/Pipes/Safe.hs#L197
12:45:54 <johnw> i only ended up having to write two instances
12:45:55 <Peaker> aweinstock: something like that, yeah
12:46:10 <aweinstock> s/uint32_t (*)(void) unevaluated/uint32_t (*unevaluated)(void)/
12:46:19 <broma00> Got bumped off, I may have missed your response johnw
12:46:27 <johnw> 12:45 <johnw> for example, look at what I did here in pipes-safe:
12:46:28 <johnw>           https://github.com/Gabriel439/Haskell-Pipes-Safe-Library/blob/master/src/Pipes/Safe.hs#L197
12:46:42 <johnw> without a newtype wrapper "lift" would lift into the ReaderT, not into m
12:46:56 <Peaker> johnw: oh, btw, using transformers to build up a monad stack is slow --> flattening to a manual monad like: \s -> (s, Either Foo a) and writing return/bind manually has helped me in benchmarks a lot. Using reader of STRef/IORef instead of a StateT(or s->(s,..)) in there has also helped. Things that GHC just doesn't optimize well
12:47:12 <johnw> Peaker: yes, I can believe that.  I've seen the same
12:47:33 <shachaf> Peaker: There are cases where STRef/IORef does much worse than passing arguments.
12:47:33 <johnw> same with ReaderT+IORef vs. StateT
12:47:43 <shachaf> Since IORef can't be unboxed, for instance.
12:47:47 <johnw> but I would always suggest that testing is the only answer to these questions
12:48:09 <johnw> i.e., timings before, timings after, and making sure you're comparing apples to apples
12:48:19 <Peaker> shachaf: I replaced: Int -> ST s (Int, ...)   with  STRef s Int -> ST s (...)    and it was faster
12:48:28 <quchen> c
12:48:29 <johnw> as shachaf points out, every "rule" you think you've found in the optimization game has its noted exceptions
12:48:37 <broma00> johnw so it's only useful for manually making instances?
12:48:38 <shachaf> shachaf isn't pointing that out.
12:48:54 <johnw> broma00: it also distinguishes your type from other uses of its underlying type
12:49:12 <aweinstock> Peaker: could you elaborate a bit on your proposed solution to "Polymorphic fields cannot be unpacked"?
12:49:17 <broma00> And generalizednewtypederiving prevents you from doing ALL of the instances manually?
12:49:26 <johnw> broma00: SafeT has a semantics to it that is "called out" by the use of that type
12:49:35 <Peaker> aweinstock: I am much in favor of a C++-style approach of specialize-all-the-things
12:49:39 <shachaf> Peaker: OK, I can believe that in more cases, since the Int isn't going to get unboxed.
12:49:43 <johnw> broma00: usually not "all", but certainly most
12:49:47 <Peaker> shachaf: why not?
12:50:15 <shachaf> Peaker: Because it's -> ST s (Int, ...), not -> (Int, ...)
12:50:31 <shachaf> Who knows whether CPR would ever happen in that circumstance.
12:50:50 <aweinstock> Peaker: the current approach that GHC uses ends up having the performance of a void*/malloc approach at runtime (w.r.t. polymorphism)?
12:50:51 <eacameron> so a theoretical question: could I write signs = [1, -1] as a list of functions instead? Num a => [a -> a]? But I fear that a will be chosen too soon, is there a way to define this?
12:51:00 <Peaker> shachaf: CPR?
12:51:01 <broma00> So using new type let's you make your own instances if you want
12:51:30 <Peaker> aweinstock: for boxing? sort of (generational GC usually does better than malloc, at least throughput wise)
12:51:35 <shachaf> @where cpr
12:51:35 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/Papers/cpr/index.htm
12:51:37 <dolio> shachaf: I know. :)
12:51:39 <shachaf> That thing.
12:51:50 <shachaf> dolio: Is the answer "it won't"?
12:51:54 <dolio> Yes. :)
12:51:59 <shachaf> That's what I expected.
12:52:12 <dolio> I think there's an issue somewhere.
12:52:17 <aweinstock> Peaker: so current performance is somewhere between template-specialization and malloc/void*'s?
12:52:40 <shachaf> dolio: It's definitely an issue. Maybe there's a ticket somewhere too.
12:52:48 <Peaker> aweinstock: I think it's closer to the latter (for polymorphic fields)
12:52:49 <dolio> That's what I meant.
12:52:53 <aweinstock> eacameron: signs = [\_ -> 1, \_ -> -1] -- what would you gain from this?
12:53:06 * hackagebot Phsu 0.1.0.0 - Personal Happstack Server Utils  https://hackage.haskell.org/package/Phsu-0.1.0.0 (utkarshl)
12:53:17 <Jello_Raptor> is there a name for a semilattice with a meet (or join) operation but no top or bottom (so the meet or join operator isn't complete) 
12:53:19 <eacameron> aweinstock: I want [\x->x*1, 
12:53:30 <eacameron> \x->x*-1]
12:53:53 <mauke> :t [id, negate]
12:53:54 <lambdabot> Num a => [a -> a]
12:54:11 <aweinstock> :t mapM
12:54:13 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
12:54:36 <eacameron> mauke: but I need the resulting function to declare type constraints late in the game
12:54:59 <eacameron> mauke: Num a => [a -> a]   is too soon; I need more like [Num a => a -> a]
12:55:18 <mauke> why?
12:55:21 <eacameron> mauke: can RankNTypes do that? Num a => [forall a. a -> a]
12:55:29 <mauke> what
12:55:57 <Peaker> eacameron: What do you plan to do with the list elements?
12:55:58 <eacameron> mauke: it's a long story. :) But I'm applying the function two two different types so I need it to retain it's abstract type until it's actually called
12:56:02 <mniip> eacameron, you realize that the a inside forall is different to the one inside Num
12:56:27 <eacameron> mniip: I don't realize much when it comes to RankNTypes
12:56:45 <mniip> eacameron, forall is like a type-lambda
12:56:54 <eacameron> Peaker: Use it on my example from before: http://lpaste.net/137864
12:57:20 <eacameron> mniip: Yeah that sounds like what I need; can I say "[forall a. Num a => a -> a]"?
12:57:32 <mniip> yes
12:57:34 <mniip> I think
12:57:56 <dolio> That will only work with impredicativity turned on.
12:58:03 <johnw> eacameron: you'll lose whatever type it originally was; members of that list can only be interacted with via the Num interface
12:58:05 <dolio> And not work very well.
12:58:15 <eacameron> johnw: dolio: oh
12:58:37 <Peaker> eacameron: unrelated commentary: That kind of test makes much more sense as a property test (like QuickCheck)
12:58:42 <dolio> You can wrap it in a newtype, though.
12:58:53 <dolio> And GHC will get less confused.
12:59:01 <eacameron> dolio: That's what I figured was coming next
12:59:07 <johnw> eacameron: you could also use a sum type to aggregate the possible flavors of number you want in your heterogeneous list, at the cost of a constructor
12:59:09 <eacameron> dolio: way too much overhead for this scenario
12:59:15 <Peaker> johnw: the user chooses the "a", so the user doesn't forget, it can be useful to them
12:59:17 <johnw> or, you can move to type-level HLists
12:59:37 <johnw> Peaker: how does the user choose the 'a'?
12:59:56 <dolio> Because it's forall, not exists.
12:59:57 <Peaker> johnw: they take an element out of the list, they get: "forall a. Num a => a -> a", they instantiate "a=Whatever", and use htat
13:00:00 <johnw> oh, right, it's a list of polymorphic functions, I misread that
13:00:10 <eacameron> Peaker: yes I figured, but these functions are simple enough that'd just re-implement them as properties anyway. I really just want to make sure I did it right
13:00:16 <aweinstock> > concat $ map (\x -> [id x, negate x]) [1,2,3]
13:00:18 <lambdabot>  [1,-1,2,-2,3,-3]
13:02:15 <eacameron> Peaker: johnw: now I'm leveraging this ridiculous case to learn more about cool things in Haskell :)
13:04:23 <kuribas> > let f g = (g 'a' 'b', g 2 3) in f const
13:04:24 <lambdabot>      No instance for (Num Char) arising from the literal ‘2’
13:04:25 <lambdabot>      In the first argument of ‘g’, namely ‘2’
13:04:25 <lambdabot>      In the expression: g 2 3
13:05:57 <kuribas> > let f :: (forall. a -> a -> a) -> (Char, Int); f g = (g 'a' 'b', g 2 3) in f const
13:05:58 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘a’
13:05:58 <lambdabot>        ‘a’ is a rigid type variable bound by
13:05:58 <lambdabot>            the type signature for f :: (a -> a -> a) -> (Char, Int)
13:06:07 <kuribas> > let f :: (forall a. a -> a -> a) -> (Char, Int); f g = (g 'a' 'b', g 2 3) in f const
13:06:08 <lambdabot>  ('a',2)
13:06:42 <aweinstock> > let f (g :: forall a. a -> a -> a) = (g 'a' 'b', g 2 3) in f const
13:06:43 <lambdabot>  ('a',2)
13:07:36 <aweinstock> > let f (g :: forall a. a -> a -> a) = (g 'a' 'b', g 2 3) in f (flip const)
13:07:38 <lambdabot>  ('b',3)
13:16:28 <spaceloop> Is there a nicer way to build this Getter with lens?: players.to (fmap (view name)). I guess what I need is a Traversal, but I don't know how to retain the structure of the container (players is a list zipper)
13:16:59 <edwardk> what are you fmapping over?
13:17:55 <spaceloop> a PointedList
13:18:25 <spaceloop> http://hackage.haskell.org/package/pointedlist-0.6.1/docs/Data-List-PointedList.html
13:18:56 <edwardk> and you're trying to keep the shape of the players as a PointedList but turn them all into their names?
13:19:04 <spaceloop> exactly
13:19:42 <edwardk> is players a lens or a traversal?
13:20:14 <spaceloop> a lens
13:20:31 <Fuuzetsu> can I not generate LANGUAGE pragmas with Template Haskell? 
13:21:00 <edwardk> whatever^.players & mapped %~ view name   -- or something like that?
13:21:09 <Fuuzetsu> I can generate inline, specialise, rule, ann and line but not the ‘options at the top’ stuff it seems
13:21:57 <edwardk> uually i'd restructure things to avoid having to give back the list in the right structure, but that'd work
13:22:34 <augur_> hey edwardk!
13:22:48 <augur_> hows things? :)
13:22:49 <edwardk> -- of course that is just fmap (view name) (whatever^.players)
13:23:09 <spaceloop> Ok thanks, I'm trying to build a Getter though that I can treat as a first class value
13:23:12 <edwardk> augur_: just finished hac boston, down with some form of con crud, working on clojure style transients for haskell
13:23:29 <edwardk> spaceloop: fair. i tend not to write getters
13:23:40 <augur_> edwardk: whats a transient?
13:23:57 <edwardk> O(1) conversion from immutable structures to mutable ones and back
13:24:19 <edwardk> so you can have things like a Set that is immutable, then make a mutable form that does more in-place work on inserts, etc. then switch back
13:25:00 <augur_> anyone know if there's a conventional way, when implementing a PL, to handle types that have representations internally, but you dont want to provide representations to the PL? specifically like, how you put the type into the language's type system? im thinking one option could be to have an empty type declaration + some flag to the implementation? dunno
13:25:21 <augur_> edwardk: hmm.. whats the gist of how those work?
13:26:41 <edwardk> data Tree a = Tip | Bin a (Tree a) (Tree a); newtype TransientTree s a = TransientTree (STRef s (TNode s a)); data TNode s a = Thaw (Tree a) | TBin a (TransientTree s a) (TransientTree s a)
13:26:56 <edwardk> convert using the Thaw constructors as a placeholder for all the mutable stuff
13:27:02 <edwardk> er for all the immutable stuff
13:27:12 <edwardk> so the first mutation causes us to burn a 'mutable path' into the tree
13:27:25 <edwardk> and subsequent mutations there can do nice mutable things e.g. nearby inserts
13:27:59 <edwardk> then we can freeze it back on O(n) in the # of nodes changed -- or we can set it up to lazily convert them back using unsafeInterleaveST tricks and charge the conversion forward to subsequent operations
13:28:13 <edwardk> works better for more interesting tree structures
13:30:06 <Jello_Raptor> hmm, <_< make "meet :: a -> a -> Maybe a" just makes 'Nothing' the bottom element of the lattice, doesn't it? 
13:30:23 <augur_> edwardk: the metaphor is compelling :)
13:31:35 <edwardk> its a bit of a mixed metaphor as the usual vocabulary from clojure is to use transient and persisnent calls to convert and i borrow the freeze/thaw metaphor from vector, but the idea is the same
13:31:51 <augur_> i like the burning-a-path stuff
13:32:24 <edwardk> i'm currently playing around with an alternate encoding that is closer to what is done in clojure, where you use 'reference' types all the way through then destroy the ability to mutate them all in one go
13:32:38 <aweinstock> what does unsafeInterleaveST do?
13:32:40 <edwardk> that would avoid the need for about half the mutation
13:33:07 <augur_> edwardk: the above example seems perfect for deriving
13:33:10 <edwardk> aweinstock: unsafeInterleaveST :: ST s a -> ST s a -- makes a lazy value that will perform the ST actions you gave it lazily
13:33:25 <edwardk> aweinstock: its similar to unsafeInterleaveIO
13:33:36 <augur_> or some other generic stuff
13:34:04 <edwardk> here we can say that unsafeFreeze destroys the transient you are using, and then it can freeze recursively using unsafeInterleaveST.
13:34:19 <edwardk> so that the conversion from mutable back to immutable happens 'on demand' as you look at parts of the tree
13:35:12 <edwardk> https://github.com/ekmett/transients/blob/master/examples/Tree.hs is an example of that binary tree i just gave worked a bit more, with a mutable insert to play with
13:35:49 <edwardk> i'm working on mutable wordmaps (basically intmaps done with nybbles rather than bits) and wide-fanout trees for vectors
13:36:51 <edwardk> i did a version of it using traverse and the Data.Functor.Foldable machinery, but its not as nice and not as good at doing some things -- like if i want to have mutable sizes inside of the objects
13:38:27 <TallerGhostWalt> if I use forkOS instead of forkIO will the working directory of the forked process be uncoupled from the parent?
13:40:47 <tolt> TallerGhostWalt: https://hackage.haskell.org/package/process-1.2.3.0
13:41:45 <TallerGhostWalt> tolt: Thanks!
13:41:51 <tolt> TallerGhostWalt: no problem!
13:45:13 <ttt_fff> so I have an object of type Map Foo Bar ... I want to call it "foo->Bar" but it's not a valid name
13:45:16 <ttt_fff> what can I call it instead?
13:45:30 <ttt_fff> I'd really like some "->" looking thing as a 'letter'
13:46:51 <frerich> 'foo~>Bar'? :-)
13:47:05 <ttt_fff> let 'foo->Bar' = 3 in 'foo->Bar'
13:47:09 <ttt_fff> > let 'foo->Bar' = 3 in 'foo->Bar'
13:47:10 <lambdabot>  <hint>:1:9: parse error on input ‘->’
13:47:19 <ttt_fff> frerich: how do you fix the above?
13:47:27 <frerich> ttt_fff: I didn't write a dash, I wrote a tilde.
13:47:40 <ttt_fff> let foo~>Bar = 3 in foo~>Bar
13:47:46 <ttt_fff> > let foo~>Bar = 3 in foo~>Bar
13:47:47 <lambdabot>      Not in scope: data constructor ‘Bar’
13:47:47 <lambdabot>      Perhaps you meant one of these:
13:47:47 <lambdabot>        variable ‘Sym.var’ (imported from Data.Number.Symbolic),
13:47:51 <mauke> frerich: what difference does that make?
13:47:56 <MarcelineVQ> What is the ~> operator?
13:48:00 <ttt_fff> > let 'foo~>Bar' = 3 in 'foo~>Bar'
13:48:01 <lambdabot>  <hint>:1:5: Parse error in pattern: 'foo
13:48:09 <ttt_fff> frerich: fix above
13:48:15 <demize> mauke: One works, the other doesn't.
13:48:17 <mauke> MarcelineVQ: no
13:48:22 <mauke> demize: none of them work
13:48:39 <demize> Oh right, it doesn't, heh.
13:48:43 <fvgvxmpv1> maybe foo→Bar ?
13:48:44 <quchen> MarcelineVQ: It looks deceptively like "->" which we cannot use since it's built-in syntax, so we abuse that fact to write arrow-looking operators.
13:48:47 <MarcelineVQ> no? Is it Foo~ > Bar ?
13:49:03 <frerich> mauke: Sorry?
13:49:07 <MarcelineVQ> oh so it's something you're making up?
13:49:10 <mauke> frerich: huh?
13:49:20 <quchen> MarcelineVQ: Luckily there's no room for confusion since only one of -> or ~> are possible at a given position.
13:49:50 <ttt_fff> let foo→Bar  = 3 in foo→Bar 
13:49:54 <ttt_fff> > let foo→Bar  = 3 in foo→Bar 
13:49:55 <lambdabot>  <hint>:1:8: parse error on input ‘→’
13:49:57 <quchen> MarcelineVQ: Yes, there are a couple of popular packages that have some operators involving <~, ~>, <>~, and so on.
13:51:14 <indiagreen> > let (→) = (+) in 3→5
13:51:16 <lambdabot>  <hint>:1:6: parse error on input ‘→’
13:51:27 <frerich> mauke: Ok I give up - what difference does what make?
13:51:40 <indiagreen> I guess lambdabot has UnicodeSyntax enabled
13:51:53 <mauke> frerich: -> vs. ~>
13:52:10 <mauke> as in <frerich> ttt_fff: I didn't write a dash, I wrote a tilde.
13:52:27 <frerich> mauke: It doesn't actually make a difference, it seems.
13:52:31 <ttt_fff> > let a~b = 3 in a~b
13:52:32 <lambdabot>  Pattern syntax in expression context: ~b
13:52:36 <ttt_fff> mauke: ^^
13:52:44 <ttt_fff> > let 'a~b' = 3 in 'a~b'
13:52:45 <lambdabot>  <hint>:1:5: Parse error in pattern: 'a
13:52:49 <ttt_fff> mauke: ^^^
13:52:53 <mauke> ttt_fff: what?
13:53:01 <ttt_fff> ~ doesn't work either
13:53:06 <mauke> ... duh?
13:53:10 <ttt_fff> yeah
13:53:15 <ttt_fff> so why the fuck are you suggesting it matters?
13:53:20 * frerich laughs
13:53:21 <mauke> I'm not
13:53:25 <mauke> I'm saying the exact opposite
13:53:50 <ttt_fff> mauke: ah, if you agree that we should burn freich at the stake, we're cool
13:54:19 <mauke> no, I don't agree with that
13:54:23 <indiagreen> I like the color of frerich's nick in my client
13:54:26 <indiagreen> frerich++
13:55:01 <ttt_fff> indiagreen: I feel betrayed
13:55:03 <frerich> ttt_fff: I'm sorry, I didn't actually try it. I just felt this brief moment of artistic exuberance and decided to make the dash a little bit more wiggly.
13:55:08 <mauke> you're asking dumb questions and spamming the channel with lambdabot errors; everyone else seems to be ignoring/misreading your question and giving you misleading answers
13:55:14 <frerich> ttt_fff: I didn't mean to cause any grief ;-)
13:55:26 <indiagreen> ttt_fff: I like yours much more, but I ++'d you already
13:55:28 <ttt_fff> mauke: how is the question dumb?
13:55:49 <ttt_fff> I have a map, it's currently named TConDDeclM
13:56:00 <mauke> ttt_fff: first off, 'X' is the syntax for character literals, not identifiers. so that can't work
13:56:01 <ttt_fff> I'd much rather have it named TCon->DDecl , but I can't name it that way
13:56:19 <frerich> ttt_fff: You could call it 'TCon2DDecl' :-)
13:56:21 <ttt_fff> err, it's named progTConDDeclM vs what I want which is progTCon->DDecl
13:56:44 <ttt_fff> frerich: hmm, that is actually a reasonable idea
13:56:46 <mauke> <ttt_fff> I'd really like some "->" looking thing as a 'letter'  <- try searching the unicode tables, maybe there is something like that
13:56:55 <mauke> but I'm not very optimistic about that
13:57:26 <frerich> ttt_fff: I was mostly kidding. Assuming that your type is a synonym for 'Map TCon DDecl' I'd probably just go with that. I think 'TCon2DDecl' doesn't add a whole lot of extra value ;-)
13:57:42 <mauke> it's not a type
13:57:56 <mauke> <ttt_fff> so I have an object of type Map Foo Bar
13:58:08 <ttt_fff> frerich: it's fine, I'll label it with  aocmment saying -- if you don't like this name, go on irc and hunt for a person named `frerich`
13:58:41 <frerich> mauke: I read 'I have a map, it's currently named TConDDeclM' and thought that meant a 'map type'.
13:59:04 <mauke> <ttt_fff> err, it's named progTConDDeclM
13:59:08 <mauke> note lowercase
13:59:33 <frerich> mauke: by that time I was already at the drawing board!
13:59:45 <frerich> mauke: Do you have no respect for liberal arts majors at all?
13:59:46 <mauke> ttt_fff: you could use ddecl_of_progTCon or something like that
13:59:49 <ttt_fff> data Prog = Prog { _progTConDDeclM :: TCoNDDeclM, .... }
14:00:07 <ttt_fff> so the type is "TConDDeclM" , and the field name is _progTConDDeclM
14:00:13 <ttt_fff> but as you can see, it's hard as fuck to read, so I'd prefer
14:00:29 <ttt_fff> data Prog = Prog { _progTCon->DDecl :: TCon->DDecl , ... }
14:00:36 <ttt_fff> which makes my eyes bleed less
14:00:47 <mauke> that would be even more confusing because that's not how identifiers work in haskell
14:01:03 <mauke> are you coming from Scheme?
14:01:18 <indiagreen> ttt_fff: you want to find something which would look like an operator to everyone reading your code... but the compiler. That's evil, don't you think?
14:01:21 <frerich> ttt_fff: I guess one could argue that this kind of hungarian notation is not very nice for reasons other than the syntactic difficulties you have to deal with ;-)
14:01:56 <ttt_fff> > let a➡= 3 in a➡
14:01:57 <lambdabot>  <hint>:1:11: parse error on input ‘in’
14:02:22 <aweinstock> > let a➡ = 3 in a➡
14:02:23 <lambdabot>  <hint>:1:8: parse error on input ‘=’
14:02:52 <frerich> Disclaimer: I assume the question was a more or less a joke from the get-go and we're all just enjoying ourselves ;-)
14:02:59 <mauke> > let a˃b = 42 in a˃b
14:03:00 <lambdabot>  42
14:03:06 <ttt_fff> indiagreen: hmm, there is some validitly to your point
14:03:13 <aweinstock> > let (➡) = const in 42➡()
14:03:14 <lambdabot>  42
14:03:25 <ttt_fff> frerich: no, the question is serious
14:03:41 <mauke> > let ˃ = () in ˃
14:03:42 <lambdabot>  <hint>:1:1: parse error in let binding: missing required 'in'
14:03:50 <mauke> > let a˃ = () in a˃
14:03:51 <lambdabot>  <hint>:1:8: parse error on input ‘=’
14:04:17 <aweinstock> let (˃) = 5 in (˃)
14:04:20 <aweinstock> > let (˃) = 5 in (˃)
14:04:22 <lambdabot>  5
14:04:26 <mauke> I see
14:04:34 <MarcelineVQ> countdown till someone gets mad at the bot spam
14:04:45 <mauke> > generalCategory '˃'
14:04:47 <lambdabot>  ModifierSymbol
14:04:49 <mauke> doesn't count as a letter
14:04:49 <monochrom> :)
14:04:56 <mauke> even though it has "letter" in the name
14:05:11 <aweinstock> > generalCategory '➡'
14:05:12 <lambdabot>  OtherSymbol
14:08:01 <MarcelineVQ> so backing up
14:08:21 <MarcelineVQ> is there a reason not to just call it fooToBar ttt_fff?
14:09:04 <ttt_fff> well, the name would be progDConIToTDefn ... and the "To" would be non-trivial to see
14:09:19 <ttt_fff> problem is that lhs and rhs are all 3 letter acronyms with high number of capital letters
14:09:31 <ttt_fff> I think the problem is just that, in general, I'm not very good at naming things
14:09:39 <mauke> _to_
14:09:41 <MarcelineVQ> foo_To_Bar
14:10:27 <MarcelineVQ> I wonder if there's something more fundamental though in the naming scheme, a better way to structure things so you don't need a name so descriptive
14:10:32 <ttt_fff> but then you trigger "not camelcase" with hlint
14:11:13 <frerich> ttt_fff: If you don't have multiple DConI-to-something maps it may well be that just 'dataConMap' (or something akin to that) is sufficiently descriptive.
14:11:18 <mauke> I've never used hlint
14:12:08 <ttt_fff> mauke: hlint is amazing at telling me to use idioms
14:12:42 <Fylwind> edwardk: I see!
14:12:48 <indiagreen> > let aᐳ = 3 in aᐳ
14:12:49 <lambdabot>  3
14:14:52 <ttt_fff> alright, different weird question, is there a way to abuse a (Map k v) as a function, i.e. if "a :: (Map k v)", then I want to be able to use it as a function of the form ":: Map k v -> k -> Maybe v"
14:15:04 <MarcelineVQ> indiagreen: I see what you did there :>
14:15:12 <MarcelineVQ> :ᐳ
14:15:26 <mauke> :t M.lookup
14:15:27 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
14:15:28 <orbifx> haskell is huge :P
14:15:37 <mauke> :t flip M.lookup
14:15:38 <lambdabot> Ord k => M.Map k a -> k -> Maybe a
14:16:53 <orbifx> way! it's built
14:17:04 <prsteele> ttt_fff: you could also do (a M.!!) for (a :: Map k v) if you're confident about membership
14:18:07 <bitemyapp> @pl (\x -> x & has (key "img"))
14:18:07 <lambdabot> (& has (key "img"))
14:18:14 <ttt_fff> okay, I know how I can avoid this naming problem
14:18:35 <ttt_fff> basically, all I need is a structure that lets me store 4 types of tuples (k1, v1) (k2, v2) (k3, v3) (k4, v4) ... where I can do "insert" and "lookup"
14:18:48 <ttt_fff> that's all I want I need, so it's basically like 4 maps back to back
14:19:28 <fvgvxmpv1> but are your k´s Ord?
14:20:34 <ttt_fff> all the k's are ORd
14:24:57 <fvgvxmpv1> carry on
14:25:33 <edwardk> pwd
14:25:40 <edwardk> derp
14:28:09 * hackagebot Phsu 0.1.0.1 - Personal Happstack Server Utils  https://hackage.haskell.org/package/Phsu-0.1.0.1 (utkarshl)
14:28:32 <Sindriava> All the Ords are k'
14:29:09 <Sindriava> :t (&)
14:29:10 <lambdabot> a -> (a -> b) -> b
14:29:17 <Sindriava> oh
14:29:27 <Sindriava> Is that a lens thing<
14:29:29 <Sindriava> ?
14:29:44 <edwardk> :t (Data.Function.&)
14:29:45 <lambdabot> a -> (a -> b) -> b
14:29:50 <edwardk> its in base in 7.10
14:30:06 <Sindriava> Neat!
14:30:28 <fvgvxmpv1> :src (&)
14:30:53 <aweinstock> @src (&)
14:30:53 <lambdabot> Source not found. You speak an infinite deal of nothing.
14:31:12 <fvgvxmpv1> it´s thus, no? > (&) = flip ($)
14:31:14 <Sindriava> x & f = f x ?
14:31:22 <Sindriava> :t flip ($)
14:31:23 <lambdabot> a -> (a -> c) -> c
14:36:22 <joobus> is Snap the recommended web framework these days?
14:37:24 <mightybyte> joobus: Depends on who you ask.  :)
14:37:37 <mightybyte> joobus: I would say yes.  :)
14:38:12 <joobus> mightybyte: i think this needs updating https://wiki.haskell.org/Web/Servers
14:38:24 <joobus> #2 hyena hasn't been updated since 2010
14:38:48 <coppro> Snap, or yesod for a more full platform
14:39:02 <mightybyte> Yeah, some of those wiki pages don't get much love.
14:39:11 <joobus> also, not sure if these are in order either https://wiki.haskell.org/Web/Frameworks
14:40:03 <coppro> Yesod has more opinions about how your site should work than Snap does. If you agree with it, it's probably easier. If you don't, it's probably harder.
14:40:11 <mightybyte> joobus: It looks like those started out in alphabetical order then just proceeded by appending new ones.
14:40:37 <joobus> i looked at yesod, but it kinda seemed more like wordpress than a server
14:40:54 <joobus> snap seemed like the best choice from my browsing
14:40:56 <osa1> does anyone know what is "section syntax" in cabal file format?
14:41:43 <monochrom> osa1, does the cabal user guide help? https://www.haskell.org/cabal/users-guide/
14:42:35 <kadoban> osa1: At a guess, like how you say "library" on one line, and then indent the section that corresponds to the library?
14:46:45 <joobus> mightybyte: i see you last updated snap-core 2 hours ago :P
14:47:02 <glguy> osa1: Are you trying to write the format or parse it? If you just want to parse it there's a module for that
14:47:18 <mightybyte> joobus: Yep.  :)
14:47:26 <glguy> I switched to using that module today in GhcPkgUtils
14:48:30 <osa1> glguy: I'm just trying to make this old program working >,<
14:48:45 <osa1> I didn't even know there were cabal versions that don't support that syntax.
14:49:13 <osa1> glguy: yeah I saw the fix, thanks.
14:49:18 <osa1> (I haven't tried it yet though)
14:57:52 <L0rdBrain> Using the FFI, i want my c function to return a haskell managed code pair (2-tuple). What is the c type of that return value?
14:59:06 <Cale> L0rdBrain: I don't think you can do this. You can import the C function which produces some sort of struct and then marshall the result on the Haskell side of things to produce a pair.
15:00:24 <L0rdBrain> i'm incredulous
15:01:19 <L0rdBrain> maybe if i read HsFFI.h
15:01:31 <monochrom> I am not. once I understand all the complications and compiler-dependence when it comes to generally exposing Haskell data to C.
15:01:46 <prsteele> where does cabal put libraries from Hackage? You can assume I am or am not using a sandbox, if that matters
15:02:50 <monochrom> i.e., we would be talking about exposing "thunks" (fancy word for "internal representation of possibly unevaluated expressions") to C
15:03:32 <monochrom> therefore firstly every compiler's thunk will look different on the C side. how do you even manage this?
15:03:48 <quchen> prsteele: ~/.cabal/lib
15:03:55 <monochrom> and secondly even if all compilers agree on one standard, it's going to be too complicated to be worthwhile.
15:05:00 <prsteele> quchen: thanks
15:05:47 <monochrom> this is why Haskell 2010 simply says "no thunks, and only a few basic, concrete types are exposed, and the runtime will always fully evaluate them before handing over to C, so that C only sees ordinary numbers and pointers"
15:07:09 <mniip> monochrom, aww
15:07:10 <L0rdBrain> alright, i suppose i can live
15:07:25 <mniip> but all the fancy things you can do with closures controlled by C code
15:08:00 <monochrom> in theoy, you could then say, "why not add a bunch of basic, concrete tuple types to the supported bunch of types? for example it is easy to add support for (Int, Char)"
15:08:52 <prsteele> alright, I have QuickCheck ==2.8.1 in my cabal file, and cabal install --only-dependencies installs 2.8.1. However, cabal repl loads 2.6. Any thoughts?
15:08:54 <monochrom> in practice, that means at least 7*7 concrete 2-tuple types, 7*7*7 concrete 3-tuple types, ...
15:09:53 <monochrom> (recall that "no thunks" implies that you cannot unify those 7*7 types by one single polymorphic 2-tuple type)
15:10:01 <prsteele> ... changing == to >= seems to fix it
15:10:07 <monochrom> so I think in practice no compiler author wants to do this
15:12:48 <Sindriava> You can quasiquote values into C code using C.inline
15:13:11 * hackagebot tidal-midi 0.0.2 - MIDI support for tidal  https://hackage.haskell.org/package/tidal-midi-0.0.2 (AlexMcLean)
15:13:43 <Sindriava> prsteele: Interesting. See if it's reproducible and maybe consult in #haskell-infrastructure
15:14:56 <prsteele> Sindriava: honestly it's almost certainly me not knowing Cabal well enough, but I'll look into it
15:15:25 <Sindriava> prsteele: Always better to be sure. Try a clean sandbox with a new project
15:15:31 <prsteele> Sindriava: will do
15:16:00 <Sindriava> prsteele: Possible explanation is that the version number is fucked up in some file in the project, and it was fixed in a later version
15:16:29 <Sindriava> prsteele: E.g. the version is 2.8, but a file was checked out from an older git commit by accident and it reports 2.6 or something
15:18:19 <catgocat> What is the symbol #? I can't include it with any more characters `let # = 4` works, but `let ## = 4` doesn't. Also in the ghci `#Something` doesn't return anything
15:18:26 <catgocat> > #Cool
15:18:27 <lambdabot>  <hint>:1:2: lexical error at character 'C'
15:18:34 <catgocat> #123
15:18:36 <catgocat> > 123
15:18:38 <lambdabot>  123
15:18:39 <catgocat> > #123
15:18:40 <lambdabot>  <no location info>: not an expression: ‘#123’
15:18:48 <catgocat> it doesn't trigger error here
15:19:01 <catgocat> what the fuck is # ?
15:19:12 <prsteele> Sindriava: user error, works in a clean sandbox
15:19:29 <Sindriava> prsteele: There we go :)
15:19:35 <Sindriava> :t (#)
15:19:36 <lambdabot> parse error on input ‘)’
15:19:49 <kadoban> catgocat: Probably don't use # for/in names.
15:19:57 <catgocat> what is it?
15:20:01 <Sindriava> catgocat: kadoban: "#" is a valid identifier for a function name
15:20:11 <demize> catgocat: It's a non-alpha, which you could use as eg an operator, but not a name.
15:20:13 <Sindriava> Diagrams use it as &
15:20:21 <catgocat> > let # = 4
15:20:23 <lambdabot>  <hint>:1:1: parse error in let binding: missing required 'in'
15:20:29 <catgocat> > @define # = 4
15:20:31 <lambdabot>  <hint>:1:1: parse error on input ‘@’
15:20:33 <catgocat> @define # = 4
15:20:33 <lambdabot>  Parse failed: Parse error: #
15:20:38 <catgocat> @define (#) = 4
15:20:38 <lambdabot>  Parse failed: Parse error: )
15:20:42 <catgocat> @define let (#) = 4
15:20:42 <lambdabot>  Parse failed: Parse error: )
15:20:42 <geekosaur> also note that if MagicHash is enabled, it is used to tag internal stuff (mostly unboxed)
15:20:44 <demize> > let a # b = a ++ b in "Foo" # "bar"
15:20:45 <kadoban> Sindriava: Doesn't it have special meaning in GHC internals? It seems like it'd be confusing.
15:20:45 <lambdabot>  "Foobar"
15:20:46 <catgocat> @let (#) = 4
15:20:47 <lambdabot>  Parse failed: Parse error: )
15:20:52 <catgocat> fucksake
15:20:59 <geekosaur> language please
15:21:06 <demize> catgocat: You can't define an operator without operands.
15:21:07 <Sindriava> catgocat: Why would that be valid :D
15:21:23 <catgocat> but what is #
15:21:24 <geekosaur> > let a # b = a + b in 4 # 5
15:21:25 <lambdabot>  9
15:21:26 <catgocat> can anyone tell me
15:21:27 <catgocat> please
15:21:33 <geekosaur> [03 22:20] <geekosaur> also note that if MagicHash is enabled, it is used to tag internal stuff (mostly unboxed)
15:21:34 <Sindriava> > let (#) = flip ($) in pi # sin
15:21:35 <lambdabot>  <hint>:1:7: parse error on input ‘)’
15:21:41 <demize> catgocat: You've been given two functioning examples now.
15:21:45 <geekosaur> otherwise it is nothing and available as an operator character
15:21:53 <catgocat> demize: type "#" in the ghci
15:22:00 <catgocat> without the quotes
15:22:16 <prsteele> let x (#) y = x * y in 4 # 5
15:22:34 <prsteele> > let x (#) y = x * y in 4 # 5
15:22:35 <lambdabot>  <hint>:1:9: parse error on input ‘)’
15:22:44 <demize> prsteele: You don't want those () around the #
15:22:50 <prsteele> > let (#) x y = x * y in 4 # 5
15:22:51 <lambdabot>  <hint>:1:7: parse error on input ‘)’
15:23:31 <Sindriava> catgocat: AFAIK it's some weird extension for postfix modifiers to literals
15:23:31 <demize> That's odd though, why doesn't that parse.
15:23:39 * geekosaur suspects MagicHash is enabled in lb somewhere? in which case (# starts an unboxed tuple
15:23:40 <prsteele> ya, it parses locally for me
15:23:53 <mauke> > let ( # ) = 42 in ( # )
15:23:54 <lambdabot>  42
15:23:55 <geekosaur> or I can just pointing people at MagicHash and they can keep ignoring me
15:24:19 <Sindriava> geekosaur: Oh, missed that
15:24:21 <geekosaur> leading # may also be special cased because cpp uses it
15:24:25 <geekosaur> I only mentioned it twice
15:24:55 <Sindriava> geekosaur: I don't pay attention to everything that goes on in there, I have a baguette to eat :D
15:25:04 <Sindriava> catgocat: ^
15:25:57 <catgocat> What is a good book besides LYAH (already read it) and RWH (I don't really like the style)
15:26:05 <geekosaur> (re lading # special casing: cpp tends to output annotations of the form: # 32 "foo.hs"
15:26:32 <geekosaur> which means it thinks it is on line 32 of file foo.hs, possibly after #include or #define etc.)
15:29:30 <Sindriava> catgocat: Typeclassopedia.
15:29:44 <catgocat> is that a tutorial ?
15:29:58 <catgocat> I heard it's documentation
15:30:43 <prsteele> catgocat: it's both, kind of. You can read it as a tutorial on some very useful abstractions
15:32:12 <monochrom> eh? Control.Concurrent has forkFinally in GHC 7.8
15:34:02 <ttt_fff> when I'm doing large rewrites, I like to tackle things one file at a time, rather than deal with whatever order ghc decides to compile files, is there a way I can tell ghc "assume taht everything is good with this file, and assume there's no fucking type errors in this file" ? ... this way I can tag all but the file I care about, and debug the file I care about, then move on to the next (rather than be jerked around by ghc's choice
15:34:31 <L0rdBrain> another FFI question. If i have a static global variable in a c module i link against, can i import that into haskell without wrapping it in a function?
15:34:43 <geekosaur> sigh, what is with language today?
15:34:52 <L0rdBrain> not "static"... but you know what i mean
15:34:54 <tommd> ttt_fff: -fdefer-type-errors is one tool
15:35:13 <L0rdBrain> i mean access a global symbol defined in c
15:35:19 <L0rdBrain> that is not a function name
15:35:20 <catgocat> Can anyone give me any hints on completing this: http://lpaste.net/137883 ?
15:35:25 <ttt_fff> tommd: can you explain how defer-type-erors help? I want to defer type erros, _but only for 'tagged' files _
15:35:26 <catgocat> Don't give me the answer right away please ..
15:36:00 <ttt_fff> :t liftA
15:36:01 <lambdabot> Applicative f => (a -> b) -> f a -> f b
15:36:10 <ttt_fff> catgocat: liftA
15:36:21 <johnw> he has to use banana and unicorn
15:36:22 <catgocat> I have to use or banana or unicorn
15:36:27 <tommd> ttt_fff: Well you can defer _all_ errors then run a test that exercises the file in question.  Also, it will still generate warnings instead of errors.
15:36:47 <catgocat> fuck, it's 10 lines of code
15:36:52 <catgocat> and you guys still dont read it
15:37:01 <johnw> catgocat: how would you turn a -> b into a -> m b...
15:37:12 <ttt_fff> @src fmap
15:37:12 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
15:37:19 <catgocat> johnw: I need to do the other way around
15:37:22 <mniip> catgocat, so like
15:37:26 <Sindriava> Oh, lambdabot, u so sasy
15:37:29 <johnw> you have a -> b
15:37:30 <mniip> implement liftM using >>= and return?
15:37:34 <Welkin> wtf is banana or unicorn?
15:37:38 <johnw> if you turn that into a -> m b, and pass it to banana, you've solved your problem
15:37:43 <ttt_fff> catgocat: your royalty, I'm so sorry for trying to help after skimming the gist
15:37:53 <johnw> now think, what would compose with a -> b, that turns the composition into a -> m b
15:37:58 <johnw> it will involve unicorn
15:37:59 <Welkin> mniip: that is covered in the typeclassopedia
15:37:59 <Sindriava> :t fmap return
15:38:00 <lambdabot> (Monad m, Functor f) => f a -> f (m a)
15:38:12 <mniip> Welkin, hm?
15:38:15 <geekosaur> siiiigh
15:39:33 <ttt_fff> furry' f  = banana (\x -> unicorn f x)
15:39:40 <ttt_fff> furry' f  = banana (\x -> unicorn $ f x)
15:39:44 <johnw> he explicitly asked that the answer not be given
15:39:59 * mniip pointfrees ttt_fff's code
15:40:20 <mniip> banana . (unicorn .)
15:40:48 <ttt_fff> catgocat: this was fun; where is this exercise from?
15:40:54 <ttt_fff> I'm interested in solving the rest of them
15:40:58 <catgocat> ttt_fff yeah fuck yourself
15:41:12 * ttt_fff searches for fleshlight
15:41:40 <ttt_fff> no seriously, where are the rest of the exercises, this exercise was cool
15:41:54 <Sindriava> catgocat: Calm down, this kind of interaction need not happen in here.
15:42:00 <ttt_fff> https://www.fpcomplete.com/user/DanBurton/20-intermediate-exercises
15:42:48 --- mode: ChanServ set +o geekosaur
15:42:54 <geekosaur> catgocat, stop dropping f-bombs
15:46:08 --- mode: geekosaur set -o geekosaur
15:46:29 <Sindriava> Is there a way to refactor this into something nicer?
15:46:30 <Sindriava> http://lpaste.net/137884
15:46:37 <Sindriava> It feels a bit clunky
15:47:33 <Welkin> lol Sindriava 
15:47:37 <Welkin> that is exactly what I wrote
15:47:53 <Sindriava> Welkin: Got me there :D
15:48:07 <Sindriava> Welkin: I've been mucking around with sdl2 / gl since you sent me your example
15:48:25 <Welkin> I haven't touched it in a long time
15:48:34 <Welkin> going to GenCon makes me want to work on games again
15:49:10 <Sindriava> Welkin: I've been able to make some neat adjustments with my limited haskell knowledge
15:49:23 <Sindriava> Welkin: Right now, I'm refactoring it to just use Keycode
16:03:56 <ReinH> Sindriava: extracting a couple functions and re-indenting make it a bit nicer: http://lpaste.net/137884
16:04:48 <o`connor> how do you track down an IOException in haskell code?
16:04:53 <Sindriava> ReinH: That's true, thanks :) 
16:05:07 <o`connor> All I know is some pattern is looking for a Vector and getting a String instead
16:05:07 <johnw> o`connor: print statements, often; if you build with profiling, +RTS -xc
16:05:13 <o`connor> hmm
16:05:14 <o`connor> ok
16:05:15 <Sindriava> Also, if anyone's using Vim and hasn't mapped ; to : yet, do it now, it will change your life
16:05:42 <o`connor> johnw: that's what I've been doing, but it's amazing that there isn't something better :/
16:05:55 <johnw> there have been many proposals for better ways
16:06:06 <geekosaur> I think something is coming in 7.12
16:06:12 <ReinH> Sindriava: Oh, that isn't quite right. More like: http://lpaste.net/137884
16:06:16 <geekosaur> ...actually I think the machinery is already in 7.10
16:06:27 <geekosaur> but it hasn't been integrated yet
16:06:54 <ReinH> Sindriava: maybePeekEvent is of type IO (Maybe WhateverTheEventTypeIs) so you fmap twice
16:06:56 <geekosaur> (as in, the machinery is there but nothing knows how to use it yet(
16:07:12 <ReinH> johnw: o/ missed you at hac boston
16:07:13 <Sindriava> ReinH: I see
16:08:08 <ReinH> Sindriava: Sorry, that's still not quite right. The result of the fmapping is still an IO (Maybe whatever), so you fmap there too http://lpaste.net/137884
16:08:22 <ReinH> Oh, editing edits, so that's the same link. Woops.
16:08:26 <ReinH> Refresh then.
16:09:15 <johnw> ReinH: was it fun?
16:09:29 <ReinH> johnw: it was great! We wrote a WAL for a Raft implementation
16:09:36 <johnw> what is a WAL?
16:09:41 <ReinH> write-ahead log
16:09:42 <ReinH> sorry
16:09:52 <ReinH> I need one for the database I'm writing for a client anyway
16:10:10 <ReinH> and eventually it'll be distributed via the Raft impl as well
16:10:35 <ReinH> so not only did I write some Haskell, I billed for it! :D
16:10:48 <johnw> well that's very fun indeed
16:10:59 <ReinH> so fun
16:11:08 <johnw> you flew to Boston just for Hac Boston?
16:11:11 <ReinH> yep
16:11:17 <johnw> (taking this to privmsg)
16:11:21 <ReinH> k
16:14:23 <ReinH> Sindriava: basically you massage the data inside the IO (Maybe x) for as long as you can before you deal with whether or not it's a Just. Then all this happens inside an IO action so there's an extra level of fmap.
16:14:27 <ReinH> Sindriava: does that make sense?
16:14:43 <Sindriava> ReinH: Yup!
16:14:49 <ReinH> It might be more clear if you used do notation to "get the value inside" the IO
16:15:03 <Sindriava> ReinH: I think I might get rid of one of the cases too
16:15:31 <Sindriava> ReinH: If I understand the SDL docs, the pointer should be NULL if no events were queued (the return value is 0)
16:15:47 <Sindriava> ReinH: And maybePeek presumably does just that, right? Checks for NULL
16:18:14 * hackagebot AAI 0.2.0.1 - Abstract Application Interface.  https://hackage.haskell.org/package/AAI-0.2.0.1 (bash0r)
16:22:35 <mazur> is the std::array type from c++11 an example of a dependent type? (there's an `size n` parameter in the template)
16:24:08 <ackthet> mazur: this isn't really the place for such a question try ##c++ (i think thats the channel)
16:25:45 <ReinH> Sindriava: I don't really know SDL
16:25:51 <ReinH> I just know Maybe and IO ;)
16:26:07 <mazur> ackthet: i'll try, c++ programmers know type theory too? :)
16:26:50 <Hafydd> An argument against type theory.
16:30:18 <Peaker> mazur: nope, it depends on a static value
16:31:00 <Peaker> mazur: If you lift values to the type-level (like GHC's DataKinds), and then depend on those type-level values, it is ordinary type-dependent-types.
16:32:13 <Peaker> mazur: "Dependent types" means "Value-dependent types", and that means runtime values, like:  type T = (x:Int) -> (if x > 0 then Char else Bool)   (result type of function depends on input argument value)
16:33:47 <mazur> Peaker: so at compile time the the type is just this function from value to type, and at runtime the function is applied and you get the output type?
16:34:54 <mazur> Peaker: or could the compiler resolve the type if `x` in your example was a constant?
16:35:37 <Vomit__> @djinn (a->b->c) -> (c -> d) -> (a -> b -> c -> d)
16:35:37 <lambdabot> f a b c d _ = b (a c d)
16:36:19 <aupiff_> s
16:37:24 <aupiff_> stack is testing things that are not in my current working directory. I have a library I am pulling from github that is tested whenever I run `stack test`. have others observed this behaviour?
16:38:33 <aupiff_> meaning, I have a stack.yaml file with the packages field populated with a pointer to a git commit. the library I depend on is being tested along with the test-suite that is defined in my .cabal file.
16:38:55 <kadoban> aupiff_: Sounds interesting. Does it happen every time?
16:39:02 <aupiff_> kadoban: yep
16:39:12 <ReinH> aupiff_: packages are the things that get built
16:39:34 <ReinH> extra-deps are for dependencies
16:39:41 <ReinH> iinm
16:39:52 <aupiff_> oh! thanks, I'll have to change that.
16:40:09 <ReinH> so i would expect that behavior
16:42:41 <ttt_fff> is it bad to add "UndecidableInstances" as a language extension?
16:43:36 <ttt_fff> https://gist.github.com/anonymous/ad800882e67c71441510 <-- GHC suggesting undecidable instances for this
16:43:37 <ttt_fff> I am sad
16:43:43 <lethjakman> is there a way to figure out where cabal installed something to? 
16:43:47 <lethjakman> my version of alex was out of date
16:43:57 <lethjakman> but it's not in ~/.cabal/bin
16:44:03 <lethjakman> cause ~/.cabal/bin doesn't exist...
16:44:22 <kadoban> lethjakman: 'which alex'
16:44:33 <Sindriava> lethjakman: On OSX it can also be in /Library or ~/Library
16:45:32 <L0rdBrain> if i see #{ }  syntax, what does that signify?
16:45:58 <Sindriava> L0rdBrain: Where?
16:46:01 <L0rdBrain> i'll accept a link to the right portion of the manual, i couldn't figure it out from googling
16:46:07 <peddie> ttt_fff: it's fine if you want undecidable instances
16:46:11 <Sindriava> L0rdBrain: Is it inside a quasiquote?
16:46:17 <L0rdBrain> https://wiki.haskell.org/FFICookBook#Working_with_structs
16:46:23 <ttt_fff> peddie: I'd prefer to get this block of code to work w/o undecidable insatnces
16:46:29 <L0rdBrain> see Working_with_structs section above
16:46:32 <L0rdBrain> for FFI 
16:46:34 <peddie> then no, it's bad . . . ?
16:46:46 <L0rdBrain> that's what i am looking at, and it is all gobblygook to mje
16:46:52 <L0rdBrain> also, what is #let ?
16:46:58 <L0rdBrain> where is this documented?
16:47:11 <Sindriava> L0rdBrain: It's literaly right inside the link you've sent
16:47:13 <monochrom> L0rdBrain: that is hsc2hs syntax. look for hsc2hs. (it comes with GHC. there is stuff in GHC user's guide)
16:47:15 <peddie> L0rdBrain: doesn't it say right there that it's hsc2hs?
16:47:23 <Sindriava> L0rdBrain: "And you wanted to write a storable instance. Here pre-processing with hsc2hs tool can be helpfull. You would write it like this:"
16:47:41 <L0rdBrain> it said it can be helpful, didn't tell me that is what hte # directives are for
16:47:58 <Sindriava> "You would write it like this:"
16:47:59 <monochrom> also, I highly recommend hsc2hs or even c2hs for your tuple translations between C and Haskell
16:48:35 <monochrom> search for "Note that the #{alignment foo} syntax is not currently built-in to hsc2hs. You have to add the following line to your haskell source file to add the alignment syntax:"
16:48:50 <nullvoid8_> The #directives aren't exactly obscurely named are they?
16:48:54 <monochrom> I highly recommend reading GHC user's guide for hsc2hs first
16:49:51 <monochrom> because there is no such thing as a "self-contained haskell wiki article". every haskell wiki article requires a whole lot of context.
16:51:48 <L0rdBrain> well, i read it and didn't make the proper inferences, so i asked here, after doing a lot of fruitless googling... thanks for the help. Sorry that you think i should have made the inferences that you do.
16:58:45 <Sindriava> L0rdBrain: No need for the tone. It's okay to ask here, but questions with obvious answers get, well, obvious answers.
16:58:58 <Sindriava> L0rdBrain: I can see how the syntax could be misleading.
17:04:23 <slowbait> Hi, as far as I understand there's no way to define a function like h f g x = case f x of undefined -> g x otherwise -> f x, right?
17:04:41 <johnw> you can't match against undefined, because it's not defined :)
17:05:25 <mniip> slowbait, you mean detecting bottom?
17:06:05 <slowbait> Yeah
17:06:15 <mniip> you can detect error-bassed bottoms in the IO monad
17:06:25 <mniip> but for non-terminating programs, that cannot be done
17:06:30 <arkeet> you can catch errors, but there are other kinds of bottom that you can't catch.
17:06:31 <mniip> because of the halting problem
17:07:03 <Zekka> skyres: Basically, if you pass (let x = x in x) to your function, you can't match on it and your program will just nonterminate
17:07:35 <shachaf> I like "nonterminate" as a verb.
17:07:58 <slowbait> So, a funtion like I just wrote is non computable? 
17:08:07 <lamefun> Is there a YAML parser that's not based on Aeson and includes position information (line, column, etc.) in its data structures?
17:08:09 <mniip> slowbait, depends
17:08:24 <mniip> slowbait, do you need to catch non-termination bottoms?
17:08:25 <Zekka> slowbait: You can use unsafePerformIO to hack out a check for *errors*, but you can't check for "let x = x in x"
17:08:30 <mniip> or just exceptions
17:08:47 <Zekka> Probably you don't want to actually do this though -- you should instead use some value to represent your error type
17:09:08 <Zekka> er, that was poorly worded
17:09:14 <Zekka> you should use some kind of value to represent errors
17:09:35 <slowbait> Ok :)
17:10:17 <Zekka> The most common way to do that is to operate on Either-y values instead ofj ust values
17:10:24 <Zekka> i.e. Either String Integer instead of Integer
17:11:42 <slowbait> mniip: just exceptions, but if it were, theoretically, to catch let x = x in x, that would make it non computable?
17:11:43 <Zekka> slowbait: FWIW you can use true horrifying unsafePerformIO evil to check for nontermination within a given timeframe in a non-IO context
17:12:05 <Zekka> e.g. "take this case if we don't terminate in five seconds"
17:12:27 <Zekka> But that gets super confusing and is not how the language is designed to work
17:12:39 <slowbait> Zekka: I'll take a look at Either then
17:12:47 <lethjakman> ahhh the alex was in a different location because I used the haskell installer executable
17:12:52 <lethjakman> but it didn't fix my issue...
17:13:19 <lethjakman> my underlying issue is that every time I try to start my application it tells me "cabal: at least one of the following packages isn't installed"
17:13:22 <lethjakman> and I've run cabal install
17:13:31 <lethjakman> that should install my dependencies right?
17:15:34 <Zekka> lethjakman: Can you provide some logs of what you did at the terminal, just to make sure you didn't make a minor nonobvious error?
17:15:44 <Zekka> I'm curious what cabal install's output was
17:15:46 <lethjakman> Zekka: yep
17:15:48 <lethjakman> one sec
17:16:47 <Zekka> slowbait: Overall lesson -- Haskell gives you a lot of tricky ways to break out of the purity sandbox but you probably should not use most of them
17:19:20 <Zemyla> Zekka: You should only use unsafePerformIO when you can prove that the result has no side effects.
17:19:53 <Zekka> Zemyla: Yeah, actually using it for side effects is usually wrong
17:20:51 <Zemyla> Well, when you're debugging, trace a = unsafePerformIO $ print a >> return a; is moderately useful.
17:23:16 * hackagebot purescript 0.7.2.0 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.7.2.0 (PhilFreeman)
17:25:33 <ReinH> Zemyla: Debug::Trace ofc 
17:25:56 * geekosaur wonders if ReinH context switched properly there :)
17:26:10 <geekosaur> but yes, I think that's Debug.Trace.traceShow
17:27:16 <ReinH> I mean, it's basically a wrapper around (variations of) that
17:40:47 <ttt_fff> gentlemen, is there a way to shorten> zipWithM (\x y -> (x,) <$> y)  ?
17:41:46 <lamefun> hm, Attoparsec.Text can't track line/column?
17:42:55 <johnw> lamefun: trifecta will
17:43:18 <ttt_fff> lamefun: parsec also does it
17:43:33 <ttt_fff> lamefun: I've heard that attoparsec is for parsing computer generated logs, and parsec is for parsing programming languages
17:43:43 <ttt_fff> johnw: enlighten us on what trifecta is good for pls
17:43:53 <johnw> it is good for parsing human-read text
17:44:17 <ttt_fff> twitter + fb posts + 50 shades of gray ?
17:54:14 <lamefun> What's the current recommended parsing library for human-written text (programming languages, config files, etc.)?
17:54:37 <hackrilege> data.List
17:54:58 <hackrilege> splitOn is useful 
17:55:19 <peddie> lamefun: it's a tradeoff like anything else . . . attoparsec is usually much faster than parsec, but the error messages are borderline nonexistent
17:55:28 <hackrilege> Data.Char and Data.Bytestring for IO
17:55:30 <peddie> lamefun: they have similar interfaces 
17:56:13 <peddie> lamefun: maybe the best thing to do is use parsec until you learn that it's too slow
17:57:08 <tommd> lamefun: If you have a programming language then consider writing a parser based on alex and happy.
17:57:18 <hackrilege> lamefun: readFile will return a string, for operating on this string check out Data.List.Split
17:57:19 <peddie> good point tommd :)
17:58:55 <Zemyla> tommd: Consider writing the library with something like Parsec or Attoparsec instead.
17:59:16 <tommd> Zemyla: I'm not the one with a parsing problem, currently.  Also, I like happy.
17:59:44 <hackrilege> I have a nasty problem in that I would like to make a datatype of fixed type opperable as a functor. The problem is in the functor instance at the bottom of this paste. http://pastebin.com/j3BVhypM
17:59:45 <Zemyla> Meh. I actually like writing my parser in the same language I write everything else.
18:00:50 <monochrom> I have a cunning plan. writing everything else in happy, too.
18:00:56 <monochrom> s/writing/write/
18:01:21 <hackrilege> alright baldwick
18:01:32 <monochrom> :)
18:01:38 * geekosaur suspects that would not in fact be very happy...
18:01:42 <tommd> hackrilege:  That simply is not a functor.  You'll want to use something besides fmap.  Is there something wrong with onPosition f a = a { position = f (position a) } ?
18:01:57 <lamefun> I see GHC uses Happy...
18:02:29 <lethjakman> Zekka: I actually got it! 
18:02:39 <lethjakman> thank you for your assistance anyways :)
18:03:05 <hackrilege> tommd: I guess not. nice syntax thanks
18:04:23 <lamefun> "module Main quux" --> "Main.hs:1:13: parse error on input ‘quux’" -- Is this because of Happy GHC gives these unhelpful error messages?
18:05:14 <johnw> lamefun: trifecta will feel exactly like using parsec (same interface pretty much), but you'll get great error messages right away
18:05:26 <monochrom> I don't know. but "module Main quux" is clearly a syntax error. (where is "where"?)
18:06:17 <lamefun> Yes, that's why a proper compiler would say something like "Error: expected `where`" instead of simply "parse error"
18:06:35 <geekosaur> ghc has good error messages for type errors, and generally poor ones for syntax errors. I don't know if that is intrinsic to Happy the way it is intrinsic to Attoparsec, or if ghc just doesn't do the right setup
18:06:47 <geekosaur> (parsec can also give some spectacularly poor error messages without some help)
18:07:16 <hackrilege> tommd: I guess I was happy my Vec was a functor as its arbritrary type meant it could store a function and then apply it with <*>. if I made my atom contain functions in its position variable by making Atom take type a I could get the functionality I want,  but it really dosent make sense that atoms positions be functions...
18:07:35 <geekosaur> ...and ghc's parser is at times fairly baroque
18:07:37 <Zemyla> Write your parser using the parsers library, with the signature finalParser :: (CharParsing m, Monad m) => m Whatever.
18:07:51 <Cale> Yeah, even if you have that "expected" stuff, it requires a bit of tuning to not end up with a way-too-long list of possible expectations in some cases.
18:08:15 <Zemyla> And then you can parse your data with attoparsec, and if there's an error, reparse with Parsec for a better error message.
18:08:17 * hackagebot quiver-csv 0.0.0.2 - Quiver combinators for cellular CSV data processing  https://hackage.haskell.org/package/quiver-csv-0.0.0.2 (patrykz)
18:08:36 <peddie> Zemyla: that's a cool idea
18:09:00 <johnw> peddie: why do you need attoparsec?
18:09:21 <peddie> johnw: what?  it was lamefun, not me
18:09:38 <exio4> lamefun: I would add that it's also pretty hard, Haskell's syntax is extremely flexible
18:09:42 <johnw> ah, I just see lots of people reaching for attoparsec first, but I wonder if the speed difference is actually needed in most cases
18:09:57 <peddie> johnw: I told him to use parsec until he learned that it was too slow
18:09:59 <exio4> johnw: it's backtracking by default, too 
18:10:18 <johnw> did he learn that it was too slow by running timing tests against his parser on expected inputs?
18:10:31 <Zemyla> And then parse it again with ReadP just for the hell of it.
18:10:34 <peddie> as far as I can tell, he didn't learn anything yet, no thanks to us ;)
18:10:44 <johnw> yeah, then I wouldn't call parsec slow just yet
18:10:52 <johnw> if the switch to attoparsec is a 1% gain overall, it's not worth it
18:11:03 * geekosaur thinks might be just poor phrasing? "determines" instead of "learns", since the latter implies a certain amount of predestination
18:11:09 <johnw> lots of time is lost in data construction, evaluation, and printing
18:11:25 <peddie> johnw: I didn't call it slow . . . just said attoparsec is usually faster
18:11:32 <johnw> it's faster *at parsing*
18:11:37 <johnw> it doesn't magically make your entire program faster
18:11:44 <peddie> johnw: anyway, my recommendation was to use parsec until he had a performance problem
18:11:52 <johnw> yes, I agree with that recommendation, peddie
18:12:16 * peddie feels a bit dazed
18:12:33 <peddie> violent agreement etc.
18:12:37 <johnw> sorry, I have a pet peeve about "heard its faster, must use"
18:13:27 <hackrilege> Ok so the problem I have is that without a type parameter my datatype is not a functor, can I get a lens to emulate e.g. fmap f (a,b,c) = (a,b,f c)
18:13:49 <johnw> hackrilege: what's your data type?
18:14:11 <Cale> hackrilege: Why not just write a function?
18:14:12 <johnw> the answer is probably yes, but I'd have to see first
18:14:23 <johnw> Cale: isn't that what the lens is? ;)
18:14:24 <hackrilege> its at the bottom of this paste; http://pastebin.com/j3BVhypM
18:14:41 <Cale> johnw: Well, sure, if you have lenses, the function is easy to write
18:14:49 <johnw> third f (Atom x y z) = Atom x y <$> f z
18:14:59 <johnw> that should do it, hackrilege, making third a lens
18:15:01 <hackrilege> Cale: because I would like to use functions defined in terms of fmap
18:15:13 <Cale> hackrilege: Why fmap?
18:15:25 <Cale> fmap doesn't really apply to that.
18:15:41 <hackrilege> for fix
18:15:45 <Cale> ?
18:15:48 <hackrilege> nope
18:15:55 <hackrilege> confused
18:16:12 <Cale> You don't have to call the function fmap
18:16:27 <hackrilege> i was trying to think of a function that was defined in terms of fmap. i remember something about fix fmap in the lens library
18:16:32 <Cale> You can just write  onPosition f (Atom e m p) = Atom e m (f p)
18:16:45 <Cale> right?
18:17:11 <hackrilege> what would be gained by making the lens?
18:17:32 <johnw> hackrilege: mainly, composing it with other lens machinery
18:17:34 <hackrilege> and yes, I was doing that originally, but was motivated to include fmap earlyer in the paste
18:18:57 <Cale> Having a lens will get you view and set as well as applying a function to the field, and lenses are composable, so if you have a lens from Atom to Vec Double that focuses on the position of the Atom, and you have a lens which goes from Vec Double to Double which focuses on the x coordinate, you can compose them
18:19:46 <hackrilege> but you did Atom a b <*> c earlyer so maybe it is the data constructor that is the functor not the inner type c as i imagined...
18:20:10 <Cale> hm?
18:20:13 <Cale> This isn't a functor.
18:20:42 <Zemyla> Yoneda transform it :P
18:20:45 <Cale> A functor is a mapping from types to types, Atom is just a simple type, it has no type argument.
18:20:45 <hackrilege> sorry its an applicative
18:20:52 <Cale> No, it's not.
18:21:23 <hackrilege> then how can he use <*>
18:21:24 <hackrilege> third f (Atom x y z) = Atom x y <$> f z
18:21:31 <hackrilege> shit sorry
18:22:01 <Cale> <$> is not <*>, and he's just using Atom x y as a function there. The choice of functor is undetermined by that code.
18:22:09 <hackrilege> :t <$>
18:22:09 <geekosaur> once again, language...
18:22:10 <lambdabot> parse error on input ‘<$>’
18:22:28 <hackrilege> pardon my french...
18:22:42 <hackrilege> :t (<$>)
18:22:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:23:22 <geekosaur> (Atom x y) is the (a -> b) there, not the f
18:23:38 <lamefun> johnw, `sorry, I have a pet peeve about "heard its faster, must use"` - why is that bad?
18:24:00 <johnw> lamefun: when I vent on people who don't deserve it
18:24:16 <geekosaur> lamefun, because often you don't need the extra speed and you pay a cost (here, in quality of error messages) for it
18:24:31 <johnw> oh, you actually meant why is it bad to even have the pet peeve
18:24:32 <hackrilege> and the f z is an f a
18:24:34 <geekosaur> also see "premature optimization is the root of all evil"
18:24:41 <exio4> and sometimes the problem is that you parse the program the `wrong` way 
18:24:53 <exio4> the speed of attoparsec comes from specific combinators 
18:25:19 <johnw> lamefun: it's like spending 10x the money for a race car engine, before finding out what kind of vehicle it's going into
18:25:47 <exio4> many1 (anyOf ['a'..'z']) is going to be slow, doesn't matter if you use attoparsec or parsec, either
18:26:03 <johnw> exio4: in attoparsec code, you'd use satisfy
18:26:28 <exio4> takeWhile1 (\x -> x >= 'a' && x <= 'z') probably works nicely too 
18:26:30 <johnw> you don't use attoparsec exactly the same way you'd use parsec, if you want speed
18:26:33 <dsm> where can I find an implementation of Data.List.words in ghc source?
18:26:48 <Welkin> exio4: you forgot ord
18:26:51 <Welkin> > ord 'a'
18:26:52 <lambdabot>  97
18:27:02 <exio4> Welkin: not if you are using .Char8 :p 
18:28:04 <lamefun> johnw, programs aren't cars, the parser can't "not fit", if I use a faster parser, the program is faster.
18:28:06 <hackrilege> :t _3
18:28:07 <lambdabot> (Functor f, Field3 s t a b) => (a -> f b) -> s -> f t
18:28:08 <geekosaur> also, are we taking collation into account? 'ñ' < 'o' in (most?) Spanish locales...
18:28:14 <johnw> lamefun: hey man, have fun
18:28:27 <lamefun> exio4, `many1 (anyOf ['a'..'z']) is going to be slow` - doesn't GHC optimize that?
18:29:00 <Zekka> lamefun: The part of the program that does parsing is going to be faster, but not necessarily the rest of the program
18:29:14 <hackrilege> how can I understand the type signature of _3?
18:29:16 <Zekka> lamefun: It's pretty smart but not necssarily that smart
18:29:19 <Zekka> :t _3
18:29:20 <lambdabot> (Functor f, Field3 s t a b) => (a -> f b) -> s -> f t
18:29:43 <Zekka> hackrilege: So it's a Lens s t a b, where the s, t, a, and b are determined by Field3
18:29:55 <Zekka> that is, they can be anything so long as there's a Field3 instance
18:30:06 <mniip> Field3 probably has some fundeps too
18:30:13 <Zekka> Yeah. Field3 is the interesting bit
18:30:28 <exio4> dsm: http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-List.html ; ctrl-f "words" ; click "Source"  ?
18:30:28 <exio4> geekosaur: probably not, it'd actually be something like "takeWhile1 (/= '\n')" though :p 
18:30:28 <johnw> you should really write the tokenizer in assembly too, that's way faster
18:30:38 <Zekka> It should include instances for tuple sizes with at least three fields, of course.
18:31:04 <hackrilege> class Field3 s t a b | s -> a, t -> b, s b -> t, t a -> s where
18:31:11 <dsm> thanks
18:31:36 <Zekka> hackrilege: That says "each s has only one a, each t has only one b, each pair of s and b has only one t, each pair of t and a has only one s"
18:31:41 <hackrilege> must implement _3 :: Lens s t a b
18:32:15 <Zekka> So for class H a b | a -> b, you can't implement both H Int Int and H Int String, because then for a ~ Int, b ~ both Int and String
18:32:53 <Zekka> But you can instantiate H Int Int and H String Int, because each a is only associated with at most one b then (Int with Int, String with Int too)
18:33:15 <mniip> Zekka, I think it's more correct to say that in 'a b -> x y', a combination of a and b uniquely identifies both x and y
18:33:28 <Zekka> mniip: I don't know that it's more correct, but it's possibly clearer
18:33:58 <mniip> it is probably equally correct, right
18:34:07 <hackrilege> ok
18:34:42 <Zekka> hackrilege: s and t are going to be some kind of tuple with lots of typevars, where a and b are a specific field in the tuple
18:34:58 <johnw> Zekka: s and t don't necessarily need any type vars at all
18:35:03 <Zekka> i.e. s = (a, b, c), t = (a, b, c'), a = c, b = c'
18:35:09 <Zekka> johnw: No, but in practice they will be, won't they?
18:35:25 <Zekka> Obviously you can define a Field3 for a tuple-like thing that isn't very polymorphic
18:35:30 <johnw> Field3 Atom Atom Int Int should work fine
18:35:44 <johnw> as long as Atom has some notion of a "third bit" that represents as an integer
18:35:49 <hackrilege> and s b -> t and t a -> s?
18:36:00 <Zekka> johnw: I'm just trying to help him with the instances he's going to see builtin
18:36:01 <johnw> oh, I didn't read that, sorry
18:36:11 <johnw> Zekka: ok, I'll leave it to you
18:36:18 <Zekka> hackrilege: For each pair of s and b, you can only instantiate Field3 for one t
18:36:23 <Zekka> johnw: Hope I didn't come off as prickly
18:36:34 <johnw> not at all
18:36:50 <mniip> hackagebot, that just means that if you know the old-tuple type, and the new element type, you can uniquel identify the new-tuple type
18:37:09 <geekosaur> tabfail...
18:37:10 <Zekka> hackrilege: So in this case, for s ~ (a, b, c) and b ~ c', you can only instantiate Field3 for one `t` (in this case, probably (a, b, c'))
18:37:13 <mniip> yes
18:37:18 <mniip> hackrilege, * ^
18:37:39 <mniip> Zekka, get some actually unique tyvars :(
18:37:39 <Zekka> You could also pick 'Void' as your t, of course, but that wouldn't be very useful
18:37:41 <hackrilege> mniip?
18:38:05 <mniip> hackrilege, see above
18:38:12 <geekosaur> this was intended for you, but nick tab completion fail: [04 01:36] <mniip> hackagebot, that just means that if you know the old-tuple type, and the new element type, you can uniquel identify the new-tuple type
18:38:13 * monochrom joins the dark side! now uses NamedFieldPuns
18:38:20 <hackrilege> its ok i understand, i am not hackagebot!
18:38:52 <Zekka> This is to prevent you from defining Field3 lenses that make sense into more than one target structure type (or from more than one source field type), because that will confuse the type inference system
18:40:00 <mniip> that makes _3 inference exactly as it should be: not more (restricting your possibilities), not less (asking you to clarify the instance)
18:40:28 <hackrilege> ok
18:40:50 <hackrilege> i can change the type in a normal way
18:41:16 <hackrilege> not too general or restrictive
18:41:48 <hackrilege> thanks, its very strange syntax to see...
18:41:49 <Zekka> Yeah. The goal is for people to be able to define Field3 for most tuple types ,and also for types that are conceptually a lot like tuples, but more type-restricted, like vectors (which can probably only contain numeric types)
18:43:51 <hackrilege> Zekka, did you see my paste? I think maybe my Vec would be better as a lens, i dont like carrying Vecs of functions for applicative. really I only want to manipulate Vecs of Doubles... and later as in the paste, other less general datatypes cannot be functors...
18:46:26 <Zekka> hackrilege: You might implement FieldN for the relevant field positions then
18:46:55 <hackrilege> ok ill check out FieldN
18:47:04 <Zekka> If you're comfortable with the idea of using lenses (I think the level polymorphism is just a little scary) it should work for you
18:47:11 <Zekka> hackrilege: FieldN isn't a thing. I just meant Field3, FIeld4, etc.
18:47:36 <hackrilege> oh so you mean write an instance for _3
18:48:07 <johnw> write a Field3 instance, which will let you use _3
18:48:17 <hackrilege> i thought that was the solution for the Atom datatype, do you mean maybe the Vec is a viable Field3 also?
18:48:48 <hackrilege> johnw, yes I will implement _3
18:48:57 <johnw> you won't implement _3
18:49:14 <johnw> you'll implement an instance for Field3
18:49:16 <hackrilege> its the minimal complete definition
18:49:20 <johnw> oh...
18:49:35 <johnw> ok, never mind me
18:49:43 <hackrilege> tehe
18:51:17 <hackrilege> no but seriously; https://hackage.haskell.org/package/tuple-lenses-0.1.0.2/docs/Data-Tuple-Lens.html
18:56:02 <osa1> it
18:56:18 <osa1> it's interesting that GHC generates code like this with -O2 `Main.doStuff3 = ++ @ Int (GHC.Types.[] @ Int) (GHC.Types.[] @ Int)`
18:57:08 <osa1> and then `Main.doStuff2 = ++ @ Int (GHC.Types.[] @ Int) Main.doStuff3`
18:59:18 <mniip> osa1, I'm missing something here, why does ++ take a type-parameter of Int?
18:59:33 <mniip> ah
18:59:40 <mniip> right
18:59:57 <mniip> yes, [] @ Int is a value
19:01:41 <osa1> mniip: because (++) is polymorphic, it's for `a` in `[a] -> [a] -> [a]` which is type of (++)
19:01:58 <mniip> yeah I get it now
19:13:20 * hackagebot quiver-csv 0.0.0.3 - Quiver combinators for cellular CSV data processing  https://hackage.haskell.org/package/quiver-csv-0.0.0.3 (patrykz)
19:16:35 <koala_man> I have a [RandT StdGen Maybe String]. how do I get the first one that is non-Nothing, if any?
19:17:18 <Zekka> :t sequence
19:17:19 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
19:17:25 <Zekka> :t catMaybes
19:17:26 <lambdabot> [Maybe a] -> [a]
19:17:36 <Zekka> :t head
19:17:37 <lambdabot> [a] -> a
19:17:51 <shachaf> I think none of those is the answer.
19:18:03 <Zekka> koala_man: So, use sequence to move the list to the inside, then fmap catMaybes over it to drop the nothings, and then take the head.
19:18:09 <shachaf> Certainly not head, probably not sequence.
19:18:16 <Zekka> shachaf: What's your answer? FWIW, my answer is unsafe if you're not guaranteed to have at least one non-nothing
19:18:46 <shachaf> Yes.
19:19:07 <shachaf> So better to use something like msum :: [Maybe a] -> Maybe a
19:19:08 <Zekka> (listToMaybe is not unsafe, as an alternative)
19:19:20 <shachaf> I don't have an answer because I don't know what RandT is.
19:19:23 <Zekka> shachaf: Oh, I forgot that one! That's a better option
19:19:26 <koala_man> Zekka: when I sequence the list I get Nothing because one of the elements is Nothing
19:19:40 <Zekka> shachaf: It's a monad transformer. Oh, also, I just realized I misread it as Rand StdGen (Maybe String)
19:19:43 <shachaf> But I do know that it's a monad transformer, so probably it'll behave the way koala_man just said.
19:21:15 <Zekka> koala_man: I don't have a super straightforward answer for you in this ccase
19:22:09 <koala_man> what's the less straight forward answer?
19:22:18 <Zekka> koala_man: I don't have a less straightforward answer.
19:22:28 <Zekka> I mean that if I had an answer, it would probably be a straightforward one
19:22:37 <koala_man> so "I don't know"
19:22:48 <Zekka> koala_man: Yeah, but it's an "I don't know" that implies the problem is probably not that hard
19:33:23 <khanage> anyone know of a quick parser for tab seperated values?
19:34:25 <johnw> khanage: http://hackage.haskell.org/package/cassava
19:35:06 <khanage> johnw: it's just parameterised by the code? i *think* i might need just arbitrary whitespace
19:35:13 <khanage> so maybe i lied :$
19:36:03 <Gurkenglas> https://hackage.haskell.org/package/MonadRandom-0.4/docs/Control-Monad-Random.html doesn't seem to provide an Alternative or MonadPlus instance given such an instance for the underlying *->*. I wonder why?
19:37:55 <arkeet> you should write one and send a PR :-)
19:42:28 <Gurkenglas> A better alternative would seem to be having MonadTrans doing that for all transformers that don't do it themselves... but then the issue with that becomes, as always, overlapping instances. And the old solution is wrapper newtypes. So I guess I should make a many-parameter newtype constructor that allows the user whether to lift instances from below in the stack or from the current transformer
19:45:26 <Gurkenglas> Is there a way to combine two constraints using OR?
19:46:12 <Gurkenglas> Something like an explicitly overlapping instance where the overlap is local and manually decided according to, like, a Bool in the newtype constructor.
19:47:19 <Gurkenglas> (Except that what is in the constructor will be more like a ((* -> Constraint) -> Bool) to give a decision for each class)
20:00:56 <Gurkenglas> What would it take to make something like this work? http://lpaste.net/137894
20:01:57 <Gurkenglas> (Refresh for typofix)
20:10:46 <Gurkenglas> In the end, every monad transformer t would only define the instances that can be defined for t Identity, and someone who builds a monad transformer stack could supply a ((* -> Constraint) -> Int) to say which position from the stack to lift each instance from
20:24:08 <lamefun> Is there a non-IO regex library for Data.Text?
20:28:09 <pyon> Other than comments, string literals and significant whitespace, is there a good reason not to use `Prelude.words` in a lexer?
20:28:44 <shachaf> Use Prelude.words if splitting on whitespace is what you want.
20:31:24 <monochrom> I use words when it satisfies my specification. and I don't use words when it doesn't satisfy my specification. YMMV.
20:31:48 <monochrom> I always know my specification precisely.
20:32:51 * ReinH gives monochrom a sideways glance
20:35:14 <verement> I think something similar was said in Alice in Wonderland
20:36:02 <monochrom> yes. there are more on my http://www.vex.net/~trebla/humour/tautologies.html
20:36:07 <geekosaur> well, the author *was* a mathematician,,,
20:41:57 <bitemyapp> ReinH: SIDEEYE
21:08:26 * hackagebot euphoria 0.6.0.1 - Dynamic network FRP with events and continuous values  https://hackage.haskell.org/package/euphoria-0.6.0.1 (MitsutoshiAoe)
21:15:59 <lamefun> Is there regex for Data.Text?
21:16:51 <peddie> lamefun: https://hackage.haskell.org/package/text-icu-0.6.3.5/docs/Data-Text-ICU-Regex.html
21:17:19 <lamefun> Yes, but it's IO
21:17:53 <peddie> OK, but it is regex for Data.Text :)
21:18:44 <peddie> lamefun: you could use https://hackage.haskell.org/package/regex-tdfa-utf8-1.0 and use Data.Text.Encoding.encodeUtf8
21:20:32 <ReinH> "Is there Thing I Want?" "Here" "That fails to meet Criterion I Didn't Specify"
21:21:00 <verement> ICU has a pure interface
21:21:12 <verement> https://hackage.haskell.org/package/text-icu-0.6.3.5/docs/Data-Text-ICU.html#g:10
21:21:39 <verement> lamefun ^
21:21:45 <peddie> lamefun: or https://hackage.haskell.org/package/regex-tdfa-text-1.0.0.2/docs/Text-Regex-TDFA-Text.html
21:41:29 <ttt_fff> is there any langauge extension more powerful than cpp2hs ... but not as heavy weight as template haskell?
21:43:04 <Hafydd> FlexibleContexts is pretty powerful.
21:43:23 <ttt_fff> eh, I relaly need macro expansion type things
21:48:26 <JamesJRH> > logBase 2 $ fromInteger $ factorial $ 2^8
21:48:28 <lambdabot>  Not in scope: ‘factorial’
21:48:37 <JamesJRH> Oops...
21:49:12 <JamesJRH> > let factorial n = product [1..n] in logBase 2 $ fromInteger $ factorial $ 2^8
21:49:13 <lambdabot>  Infinity
21:49:24 <JamesJRH> Why is this?
21:53:50 <Gurkenglas> koala_man, RandT StdGen Maybe String is isomorphic to StdGen -> Maybe (String, StdGen). If one of those returns Nothing, there is no StdGen to run the next RandT StdGen Maybe String with. What you probably want is Rand StdGen (Maybe String).
21:54:21 <Hafydd> :t let factorial n = product [1..n] in logBase 2 $ fromInteger $ factorial $ 2^8
21:54:22 <lambdabot> Floating r => r
21:54:46 <ReinH> floating point precision?
21:56:04 <Hafydd> Yes. It defaults to Double, I think, which gives Infinity for large calculations.
21:56:05 <Gurkenglas> :t fmap asum . sequence -- In which case the solution would be this, koala_man.
21:56:06 <lambdabot>     Not in scope: ‘asum’
21:56:06 <lambdabot>     Perhaps you meant one of these:
21:56:06 <lambdabot>       ‘F.asum’ (imported from Data.Foldable),
21:56:27 <ReinH> I mean, you're asking for fromInteger of roughly 10^507
21:56:53 <ReinH> Double can't handle that
21:57:09 <JamesJRH> Okay, but then what does Python do to make this work?: >>> math.log(math.factorial(2**8))/math.log(2)
21:57:25 <JamesJRH> Is it just using a higher-precision?
21:57:37 <JamesJRH> s/-/ /
21:58:03 <JamesJRH> Like a quadruple or something?
21:58:16 <ReinH> maybe it casts for you or something
21:58:55 <joker_fd> hi
21:59:28 <JamesJRH> What does “casts” mean? Is casting a programming term?
22:00:09 <JamesJRH> This?: https://en.wikipedia.org/wiki/Type_conversion
22:01:23 <JamesJRH> ReinH: Okay, yeah, Python does that sort of thing. It definitely does that for integers.
22:01:27 <heatsink> Apparently Python has an implementation of log for integer bignums
22:01:43 <JamesJRH> Okay.
22:04:22 <JamesJRH> heatsink: So is there a logBase in Haskell of type ‘Floating a => a -> Integer -> a’?
22:04:38 * JamesJRH Hoogles...
22:05:12 <Gurkenglas> byorgey, why isn't "newtype RandT g m a = RandT (StateT g m a)" "type RandT = StateT"?
22:05:12 <heatsink> I don't know.  You could implement it pretty easily though
22:05:29 <JamesJRH> Seems not.
22:05:57 <JamesJRH> Anyway, from log, I could trivially implement logBase.
22:07:13 <JamesJRH> So really, I just need a log of type ‘Floating a => Integer -> a’. JamesJRH Hoogles again...
22:07:45 <JamesJRH> Hmm.
22:08:20 <JamesJRH> Hoogle isn't very strict with its matching, is it.
22:08:27 <JamesJRH> https://haskell.org/hoogle/?hoogle=Floating+a+%3D>+Integer+->+a
22:09:43 <JamesJRH> Preceding with ‘:: ’ doesn't help, either.
22:10:26 <ReinH> Gurkenglas: so it can have a different name
22:11:06 <Gurkenglas> ReinH, explain. What difference can the user of the library see?
22:11:16 <kadoban> JamesJRH: It generally seems to find really closely matching, if they exist … and if not it goes pretty broad.
22:11:32 <JamesJRH> Yeah.
22:11:57 <JamesJRH> It usually is more useful. So maybe such a function doesn't exist.
22:12:27 <ReinH> Gurkenglas: They can see a different name
22:13:38 <JamesJRH> I'd expect it to have ‘log’ in the name anyway, so this is the most refined search that I can think of: https://haskell.org/hoogle/?hoogle=log+%3A%3A+Floating+a+%3D%3E+Integer+-%3E+a
22:13:57 <JamesJRH> And it only returns log and logBase, so.
22:14:07 <Gurkenglas> ReinH, what new identifier becomes known when code importing one version of the library switches to the other?
22:14:35 <heatsink> > let {logi (n :: Integer) | n > (2^31) = logi ((n + 2^30) `div` 2^31) + log (2^31) | otherwise = log (fromIntegral n) } in logi (1 `shiftL` 600)
22:14:36 <lambdabot>  415.88830833596717
22:14:44 <JamesJRH> So how does one implement a log function like Python's?
22:14:55 <JamesJRH> Oh wait.
22:15:31 <ReinH> Gurkenglas: what do you mean?
22:15:38 <heatsink> Probably simpler than that
22:16:06 <ReinH> The difference is that you can't use RandT wherever you can use StateT and vice versa
22:16:12 <kadoban> JamesJRH: Getting the integer part of it is pretty easy, at least for base-2 (see what the highest bit set is). Do you need more than that?
22:16:50 <ReinH> Because it's assumed that RandT will contain a RandomGen
22:16:58 <ReinH> So you can't generally use a StateT as if it were a RandT
22:19:39 <Gurkenglas> ReinH, all the functions in Control.Monad.Random that need it already have to require an RandomGen instance explicitly. Being able to plug StateTs that happen to contain a RandomGen (and, more importantly, being able to plug RandTs into StateT functions) sounds like a plus
22:20:03 <ReinH> Gurkenglas: You can always wrap and unwrap the newtype wrapper.
22:20:24 <kadoban> JamesJRH: If you need better than that, this looks like a plan: https://en.wikipedia.org/wiki/Binary_logarithm#Recursive_approximation, or this: http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=102831
22:20:51 <bitemyapp> ReinH: ala
22:20:59 <bitemyapp> or iso
22:21:24 <bitemyapp> http://hackage.haskell.org/package/newtype-0.2/docs/Control-Newtype.html#v:ala
22:21:35 <Gurkenglas> ReinH, so ultimately the argument is that it protects the user from accidentally putting arguments into functions where they don't belong?
22:21:36 <bitemyapp> fun library, but lens does replace it.
22:21:45 <bitemyapp> Gurkenglas: Text -> Text -> Text -> IO ()
22:21:48 <bitemyapp> Gurkenglas: what's that do?
22:22:06 <nshepperd> Gurkenglas: on the other hand, you can now use 'RandT g (StateT s m) a' safely
22:22:26 <bitemyapp> Gurkenglas: https://github.com/bitemyapp/bloodhound/blob/master/src/Database/Bloodhound/Types.hs#L571-L715
22:22:29 <nshepperd> if for some reason you wanted to use state together with randomness
22:22:32 <bitemyapp> Gurkenglas: it's sorta like a poor man's provenance.
22:22:49 <bitemyapp> Gurkenglas: with those newtypes, you can track down where those concepts and sorts of values occur in the project.
22:22:52 <nshepperd> 'safely' in that the MonadState functions will refer to what you expect
22:22:58 <bitemyapp> Gurkenglas: without them, you'd have no idea. It'd be a Text/Int soup.
22:22:59 <ReinH> bitemyapp: I am familiar with ala :p
22:23:11 <bitemyapp> ReinH: ooh a la la. Good.
22:24:12 <Gurkenglas> Okay, nshepperds argument is compelling. bitemyapp, wouldn't those type signatures use the names defined via "type" anyway?
22:24:41 <bitemyapp> Gurkenglas: not meaningfully. Who knows where they go, how they get used.
22:24:49 <bitemyapp> Gurkenglas: in practice, type synonyms are never maintained with any discipline.
22:25:05 <bitemyapp> Gurkenglas: newtype won't let you lie about that Locale turning into a Text because you stopped caring enough to notate it properly.
22:25:26 <rntz> why does Alternative require Applicative?
22:25:36 <rntz> I have something which I think I want to be Alternative but not Applicative
22:25:47 <Gurkenglas> (And theoretically, newtype has that same problem, but practically not?)
22:26:09 <rntz> namely I have a monad (Rand a) which generates an `a' from a random # source, and I want (Alternative (Double, Rand _))
22:26:35 <ReinH> rntz: some and many use the Applicative typeclass methods
22:26:52 <rntz> ah, hm.
22:27:08 <rntz> I guess I really just want (Monoid (Double, Rand a))
22:27:25 <zipper> I am generating a stack.yml file from an existing cabal file. This makes stack want to compile my package with ghc 7.8 but I want to use (and have installed 7.10)
22:27:34 <zipper> How do I make stack stop doing this?
22:27:43 <bitemyapp> zipper: set the resolver to GHC-7.10 in the stack.yaml
22:27:51 <zipper> Stuff in the `stack --help` doesn't help
22:27:53 <bitemyapp> I don't think any of the LTSes are GHC 7.10 yet
22:27:58 <bitemyapp> the nightlies are though.
22:28:03 <bitemyapp> so pick a nightly or the GHC 7.10 resolver.
22:28:10 <ReinH> rntz: If you pick an applicative instance for your Double, the composition is an applicative as well
22:28:31 <ReinH> e.g. (Sum Double, Rand a) is a composition of (Sum Double,) and the Applicative for your Monad Rand a
22:28:43 <ReinH> er, a monoid instance for your double
22:29:11 <ReinH> but <|> for (a,) has to wham together the a's somehow, thus the monoid constraint
22:29:44 <rntz> so, I have a specific application in mind, for which I don't think there is a reasonable interpretation of `pure' or `<*>'
22:29:57 <rntz> namely, weighted choice.
22:30:22 <ReinH> What would the <|> for weighted choice do?
22:30:39 <rntz> (wx,x) <|> (wy,y) = (wx+wy, [... randomly chooses between x and y based on their weights ...])
22:31:08 <ReinH> Well, if Rand a has an alternative instance
22:31:29 <rntz> the Rand alternative instance couldn't possibly do the right thing; it doesn't have the weighting information
22:31:50 <ReinH> Right.
22:32:21 <rntz> I'm just going to say `instance Monoid (Double, Rand a) where' and that should suffice
22:32:58 <Gurkenglas> Overlaps with (Monoid a, Monoid b) => Monoid (a, b)
22:33:25 <Gurkenglas> Why not [(wx, x)] <|> [(wy, y)]?
22:35:23 <ReinH> rntz: you might look at https://hackage.haskell.org/package/probability
22:35:46 <ReinH> but yes, the free version seems like what you want
22:37:06 <moop> > learn
22:37:07 <lambdabot>  Not in scope: ‘learn’
22:37:09 <moop> er
22:37:11 <moop> @learn
22:37:11 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
22:37:18 <moop> @learnhaskell
22:37:18 <lambdabot> Unknown command, try @list
22:37:21 <moop> @list
22:37:22 <lambdabot> What module?  Try @listmodules for some ideas.
22:37:28 <moop> @listmodules
22:37:29 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
22:37:37 <moop> @teach
22:37:37 <lambdabot> Unknown command, try @list
22:37:43 <moop> >:( where was that link
22:38:05 <ReinH> moop: please experiment with lambdabot in a /msg
22:38:05 <moop> @learning
22:38:05 <lambdabot> Unknown command, try @list
22:38:10 <JamesJRH> I guess:
22:38:16 <moop> ReinH: yeah sorry
22:38:26 <JamesJRH> @list teach
22:38:26 <lambdabot> No module "teach" loaded
22:38:38 <JamesJRH> @list learning
22:38:39 <lambdabot> No module "learning" loaded
22:38:41 <Gurkenglas> The free version? Do you mean the [] thing?
22:38:48 <ReinH> Gurkenglas: yes
22:38:53 <JamesJRH> Then why say ‘try @list’?
22:39:20 <ReinH> to give a list of the known modules
22:39:59 <moop> yeah i was looking for https://github.com/bitemyapp/learnhaskell
22:40:07 <moop> and that's an alias
22:40:38 <ReinH> Gurkenglas: [x] <> [y] is the free version of "combine x and y?
22:40:42 <ReinH> s/?/"
22:41:32 <zipper> bitemyapp: Thanks.
22:42:12 <zipper> hmmmm deps in stack are kinda unusual for me to say the least. I don't know what's going on.
22:42:55 <bitemyapp> zipper: np
22:44:08 <JamesJRH> heatsink, kadoban: Thank you for those. I guess that kadoban's latter suggestions would be the most efficient/accurate, but it could be easier to just use heatsink's implementation based on the existing log function.
22:44:10 <zipper> bitemyapp: Well I have this issue with dependencies.
22:44:20 <JamesJRH> I'm not sure what I'll do.
22:44:29 <zipper> bitemyapp: Have you tried using stack with a new scaffolded yesod app?
22:44:37 <zipper> bitemyapp: Oh I remember you don't use yesod.
22:44:42 <zipper> nvm
22:45:16 <zipper> Anyway so stack keeps saying I need to add dependencies I keep copying from terminal and pasting them into my stack file.
22:45:43 <zipper> After all that I still have conflict with versions :( This will take a while to figure out
22:46:25 <ReinH> oh the delicious irony of stack not working with yesod
22:46:26 <zipper> I think the issue is that stack gets it's packages from stackage and not hackage
22:46:55 <bitemyapp> zipper: I do use Yesod
22:47:01 <zipper> ReinH: No no it's not like that. I think I am doing something wrong.
22:47:07 <bitemyapp> ReinH: Stack works fine with Yesod
22:48:25 <ReinH> bitemyapp: :(
22:48:40 <zipper> e.g `blaze-html: needed (>=0.5), latest is 0.8.1.0, but couldn't resolve its dependencies`
22:48:44 <ReinH> but where will I get my shadenfreude?
22:48:57 <ReinH> s/sh/sch
22:48:58 <bitemyapp> ReinH: Sna-p documentation?
22:49:06 <zipper> bitemyapp: Which version of ghc are you using?
22:49:19 <bitemyapp> work: 7.8.4, personally: 7.10.2
22:49:28 <bitemyapp> I use Yesod in a more ephemeral sense, sorry. not presently.
22:49:39 <bitemyapp> god dammit orwellian bot caught it anyway.
22:50:17 <kadoban> zipper: Is what you're doing reproduceable? Maybe can you just lpaste the output if nothing else?
22:50:23 <zipper> bitemyapp: Do you get such errors `blaze-html: needed (>=0.5), latest is 0.8.1.0, but couldn't resolve its dependencies` I don't see the issue. 0.8 is >= to 0.5
22:50:40 <zipper> kadoban: Okay
22:51:32 <kadoban> That sounds like "I need >=0.5, and 0.8.1.0 exists, but I can't install it because /its/ dependencies can't be resolved." Maybe.
22:53:39 <zipper> Stack file and errors https://gist.github.com/urbanslug/dde1db8b4491707d3820
22:53:48 <zipper> New yesod scaffold.
22:53:59 <JamesJRH> I want it to be about as efficient as the Python expression ‘math.log(math.factorial(2**8))/math.log(2)’ or better. I can get upto about log_2 (2^16)! before it starts getting slow. That returns 954036.8635502001.
22:54:58 <JamesJRH> I guess that most of that time will be in the factorial part though.
22:56:50 <zipper> kadoban: Sounds like something quite out of my control since there are many such unresolvable deps.
22:57:31 <kadoban> zipper: Did you try one of the nightly resolvers? The only error I can make sense of much out of that is … vector is 0.11.0.0, but something is requiring <0.11
22:57:53 <kadoban> zipper: I'd just wipe out all that stuff, try the nightly resolver and see if that works … it should, unless something wonky is going on.
22:57:59 <pacak> JamesJRH: I'm not sure how accurate  would that be if you use Double for factorials.
22:58:38 <zipper> kadoban: Wipe the long list of dependencies?
22:58:42 <pacak> JamesJRH: For Integer factorial you can have a look at this: https://gist.github.com/pacak/378dec398895efdabb09 - fact3
22:59:00 <zipper> kadoban: No I have not tried any of the nightly resolvers.
22:59:30 <kadoban> zipper: Well, the huge list shouldn't be necessary unless I'm really missing something.
22:59:51 <zipper> kadoban: Okay I'll replace it with an empty list to begin with.
23:00:21 <zipper> kadoban: Where can I find the latest resolver? The one I can find is `nightly-2015-06-16`
23:01:26 <kadoban> zipper: I tend to just go to http://www.stackage.org/nightly , and see what it redirects me to. I know there's an actual list there somewhere though.
23:02:03 <kadoban> So nightly-2015-08-04
23:02:25 <cocreature> there is a list here https://www.stackage.org/snapshots
23:02:50 <kadoban> Thanks
23:04:30 <zipper> kadoban: Thanks using the latest resolver. This is my only error from stack http://lpaste.net/1872077314049703936
23:04:37 <JamesJRH> pacak: Yes, the factorial is integer; only the output of the base 2 log function (i.e. logBase 2) needs to be fractional.
23:05:50 <zipper> kadoban: Screwed by upper bounds lol
23:05:55 <kadoban> zipper: Ugh. Let me see if that happens for me. Do you have the yesod command you're running? I don't really know yesod yet :-/
23:06:24 <pacak> JamesJRH: Well - you can have a look at example I gave - computing factorial this way is much faster. Plus if you want to go even higher - you can calculate log2 midway and add them instead of multiplying.
23:06:43 <zipper> kadoban: I installed yesod and yesod-bin with cabal. Added by ~/.cabal/bin to path and ran `yesod init`.
23:07:46 <kadoban> zipper: Heh … I need to build yesod apparently XD I'll let you know if I find anything once it completes. *sigh*
23:08:00 <zipper> kadoban: Then I used the following stack file. http://lpaste.net/4492561857772519424 (I am using ghc 7.10)
23:08:16 <zipper> kadoban: Sorry to have to put you through this.
23:08:37 <kadoban> zipper: Eh, it's no problems. I'm … kind of intentionally searching out 'stack' problems to learn it better.
23:09:24 <JamesJRH> > 1 `shiftL` 600
23:09:25 <lambdabot>  4149515568880992958512407863691161151012446232242436899995657329690652811412...
23:09:39 <cocreature> there are basically two versions around this. 1. add the specific versions that match your upper bounds to extra-packages 2. bump your upper bounds
23:09:47 <Adeon> > 1 `shiftL` 6000
23:09:48 <lambdabot>  1513470582304237072513410067329391955423482356622077508836389416646889306993...
23:09:59 <zipper> kadoban: Building yesod will take a while. Let me know when you're done via PM or something.
23:10:03 <Adeon> > 1 `shiftL` 600000
23:10:04 <lambdabot>  9940274755017732308941916648000732363805000596148498825803720094675126660686...
23:10:23 <kadoban> It may not take forever forever, I've been using the same locked resolver for a while so some deps I might already have. I'll let you know though.
23:10:36 <JamesJRH> heatsink: It is out of scope for me. How come it isn't for lambdabot?
23:12:46 <JamesJRH> Why does Hoogle say that it's in package base but I can't import base?
23:13:30 <liste> JamesJRH how are you trying to import it
23:13:32 <liste> ?
23:13:47 <JamesJRH> Okay, ‘import Data.Bits’ works.
23:13:57 <JamesJRH> liste: Just the same way.
23:14:00 <kadoban> JamesJRH: You don't import packages, you import modules. 'base' is like, stuff that comes with GHC.
23:14:25 <JamesJRH> Oh.
23:14:59 <JamesJRH> kadoban: So like, ‘Data.Bits’ is a module of package ‘base’, right?
23:15:17 <kadoban> JamesJRH: Yep, one of quite a few in 'base'
23:16:35 <JamesJRH> Hoogle could make that more obvious. Like ‘base/Data.Bits’ or something.
23:17:07 <JamesJRH> Or different colours even.
23:18:17 <JamesJRH> So lambdabot has loads of modules already loaded then?
23:19:13 <kadoban> zipper: Sooo. My setup is simply: nothing haskell installed individually except 'stack'. I'm using the nightly-2015-07-24 resolver. I did 'stack install yesod && stack install yesod-bin' and then yesod init and chose some random options. Then I went in there and 'stack init' and 'stack build' and it's building.
23:20:05 <kadoban> zipper: I'm not sure what concrete info to take from that, except maybe if you wipe out all of your haskell stuff and just go all-stack, it should work?
23:20:51 <JamesJRH> 1 `shiftL` 600 = 2^600
23:21:39 <JamesJRH> I take it that shiftL is more efficient in the special case of ^2, right?
23:21:49 <JamesJRH> Trivially efficient.
23:22:56 <JamesJRH> Also hence the infix operator notation to make it look more like the infix ‘^’ operator.
23:23:55 <zipper> kadoban: Let me try that
23:24:08 <zipper> kadoban: Going all stack.
23:24:43 <kadoban> zipper: I'm not really clear on why it would actually matter, but I did experience problems when I tried to use my own manually installed GHC and old package DB … not really quite clear how that works.
23:27:12 <JamesJRH> Then again, that's not such a good argument because it starts with 1 anyway; I think that I'd prefer not to use infix and rather just use (shiftL 1) instead of (2^).
23:28:08 <JamesJRH> s/special case of ^2/special case of 2^/
23:29:28 <liste> > (-1) `shiftL` 4
23:29:30 <lambdabot>  -16
23:30:52 <saulzar> JamesJRH, You mean  multiply by 2^n ? Also different meaning where negative numbers come into it
23:31:38 <JamesJRH> Yeah.
23:31:48 <JamesJRH> I should sleep. :-]
23:33:13 <JamesJRH> See you. \o
23:42:09 <zipper> kadoban: Still downloading and building
23:45:29 <kadoban> Yeah it'll probably take a while in total I'd imagine :-/ Lots of deps.
