00:03:53 <erisco> johnw, if I have a Text chunk I really have it, if I have a lazy Text I don't know
00:07:23 <ttt_fff_> https://gist.github.com/anonymous/3c5cc2ece9307f8a0b29 <-- I'm doing something stupid, but not sure what. I want to store the type of JS exprs as values in Haskell. I'm not sure how to do this.
00:10:35 <neuroserpens> >.>
00:10:36 <neuroserpens> <.<"
00:11:43 <erisco> ttt_fff, what do you mean by "store the type of JS exprs" ?
00:11:59 <ttt_fff_> so I want to have haskell exprs (that will be converted to JS)
00:12:04 <ttt_fff_> and I want haskell to know what the type would be in haskell
00:12:06 <ttt_fff_> err, in js
00:12:16 <ttt_fff_> whether ti'll be a JsInt, a JsString, or etc ....
00:12:53 <erisco> okay, partly taking a guess then, you have a JavaScript AST written in Haskell and you want to do type inference on it?
00:13:21 <ttt_fff_> erisco: this is my first time trying to embed a DSL in haskell; so, to the best of my knowledge, yes, I think what you're saying is correct
00:14:01 <erisco> your DSL is arbitrary JavaScript?
00:14:43 <ttt_fff_> I'm doing "Haskell Exprs -> JavaScript"
00:14:50 <ttt_fff_> I never parse javascript/text files
00:15:02 <erisco> what is "Haskell Exprs"
00:15:25 <ttt_fff_> so I have things like JSExpr = JSInt Int | JSString Text | JSAdd JSExpr JSExpr | ...
00:15:30 <erisco> there's a lot in the air here so I don't want to spout advice without knowing what you're after
00:15:42 <ttt_fff_> i started thinking about this a few hours ago
00:15:51 <ttt_fff_> so I'm probably telling you a lot of wrong things becuase my thought process is not clear yet
00:16:18 <erisco> okay, so JSExpr looks like an AST i.e. abstract syntax tree for JavaScript
00:16:46 <ttt_fff_> let me start at the root, since I am confused somewhere, so only telling you bits + pieces is probably not going to work well
00:16:56 <erisco> okay
00:17:18 <ttt_fff_> I played with Fay/GHCJS/Haste a bit. I'd prefer to write javascript code _right in haskell_. 
00:17:20 <ttt_fff_> I know about https://hackage.haskell.org/package/reflection .
00:17:42 <ttt_fff_> I'd like to generalize the notion of "Expr", so I can write haskell code taht builts up a AST (in some DSL we define), and then compile this AST to Javascript.
00:17:56 <ttt_fff_> I'd also like to leverage GHC's type checking to type check expressons in this AST
00:18:10 <ttt_fff_> so I want this AST to know that (JSInt 10) is a integer and (JSString "hello world") is a string.
00:18:17 <erisco> okay, well, a few things
00:18:37 <ttt_fff_> i'm all ears, go ahead
00:19:05 <erisco> first, if you just want to "write JavaScript in Haskell" i.e. embed JavaScript code in Haskell code then you can use quasi-quotation as an alternative for string literals
00:19:24 <erisco> so if you're doing GHCJS you need to give JavaScript code in strings for doing FFI kind of work, right
00:19:43 <erisco> well, you could use quasi-quoters instead which will make some things less painful (like strings in the JavaScript code)
00:20:47 <erisco> if you want to do type inference for JavaScript (for whatever reason) this is not easy
00:20:56 <erisco> I would talk to sinelaw who knows a fair bit about this
00:21:11 <ttt_fff_> I'm not doing type inference for JS.
00:21:16 <erisco> particularly because he is author of https://github.com/sinelaw/infernu
00:21:24 <ttt_fff_> I have a DSL (in Haskell), which I do type inference on. I also have this DSL able to be converted into JS.
00:21:41 <ttt_fff_> I never parse JS. I only output JS.
00:21:54 <erisco> your AST looks like JavaScript, that is all I am going by
00:22:17 <erisco> I don't know what your DSL is other than it looks like JavaScript because it is called JSExpr and you're outputting JavaScript
00:22:45 <erisco> if you want to assign types to expressions without explicit annotations then that is called type inference
00:22:56 <erisco> otherwise the way you know JsInt is an Int is by explicitly saying so
00:23:21 <erisco> though even with explicit annotations you're probably looking to do type checking
00:24:02 <erisco> and again, for JavaScript this is not easy
00:24:07 <ttt_fff_> https://gist.github.com/anonymous/51e860d84698ada96bae <-- this is what I ahve so far
00:24:10 <erisco> I don't know what your DSL is so you'll have to decide for that
00:27:31 <erisco> ttt_fff, jsAdd :: JsInt -> JsInt -> JsInt
00:28:29 <ttt_fff_> yes, but I think I need something inside of JsExprOf also
00:29:13 <erisco> jsAdd :: JsExprOf JsInt -> JsExprOf JsInt -> JsExprOf JsInt
00:30:47 <ttt_fff_> https://gist.github.com/anonymous/9a2a1866ee567b97700a <-- erisco, what I have so far
00:31:04 <erisco> no I don't think you'd want to do it that way
00:31:29 <erisco> possibly, I am not sure
00:31:35 <erisco> I suppose in JavaScript addition is taken for granted
00:32:07 <ttt_fff_> I need to store up code as an AST which I compile to JS later
00:32:31 <montanonic> ttt_fff, are you working in Yesod perchance?
00:32:45 <ttt_fff_> montaonic: now, I am working from scratch
00:32:48 <erisco> ttt_fff, I get that, but you could label the 'add' operation differently
00:32:49 <ttt_fff_> is there something from Yesod I should study?
00:32:55 <erisco> rather than a constructor for each operation
00:33:45 <montanonic> ttt_fff, no, I was just wondering if you were wanting to have Haskell -> JavaScript for web development in Haskell (and Yesod is the most popular web devel kit currently).
00:34:13 <ttt_fff_> montanonic: yes, I want a mini Haskell -> JS for web dev in haskell
00:34:18 <ttt_fff_> but not as powerful as GHCJS / haste required
00:34:28 <ttt_fff_> just somethign minimal for interactivity
00:34:29 <montanonic> hmm, I don't know if this is the direction you want to go in, but
00:34:33 <montanonic> http://hackage.haskell.org/package/yesod-purescript
00:34:48 <montanonic> so there's already a library that is working on providing compatibility with purescript in Yesod
00:34:54 <montanonic> and you should look up purescript
00:35:22 <ttt_fff_> looked at purescript before
00:35:25 <ttt_fff_> I really want a pure GHC solution
00:35:32 <montanonic> ttt_fff: the idea I have is, since purescript is a lot like Haskell
00:35:36 <ttt_fff_> it's not clear to me what purescript offers over haste/fay/ghcjs
00:35:52 <montanonic> you could maybe try doing a Haskell -> Purescript instead
00:35:53 <ttt_fff_> montanonic: ghcjs/haste is closer to haskell than purescript .... :-)
00:36:15 <montanonic> right, but purescript has a library that adds support to it directly in Yesod, the web devel kit
00:36:21 <Arahael> purescript might be closer to fay, though. They're both strict, rather than lazy, I believe.
00:36:29 <montanonic> I'll like up haste and fay though.
00:36:32 <montanonic> look up *
00:36:40 <ttt_fff_> Arahael: last I checked, fay is not strict.
00:36:48 <ttt_fff_> Fay is "use ahskell-src, generate js, but no typeclasses"
00:37:14 <ttt_fff_> haste is "we have this idea where you have one code base for server+client; where server code runs in server moand, client code runs in client monad; and this one codebase genereates server + client code"
00:37:38 <montanonic> ah, okay, thanks; so haste is what you plan on using for web stuff?
00:37:53 <montanonic> oh, wait
00:38:00 <montanonic> never mind looked it up more
00:38:03 <montanonic> thanks for the info
00:39:46 <ttt_fff_> haste is also, afaik, a 1 person project
00:39:52 <ttt_fff_> the mailing list is not particularly active
00:40:24 <montanonic> ttt_fff: I too am very interested in having something like what you're describing; it's odd to me that I can't find anything directly addressing it
00:40:40 <Arahael> ghcjs is making good progress, though.
00:40:42 <montanonic> and as a noob that makes me wonder if JavaScript is just scary to interface with Haskell
00:41:01 <ttt_fff_> ghcjs is excellent, but a bit too heavy for my tastes
00:41:25 <ttt_fff_> it's not clear to me why I need my client side to compile all of hackage + have stm + have laziness + etc ....
00:41:35 <montanonic> right, yeah, I'm interested in this particularly because of Yesod
00:41:49 <montanonic> and how their template for JavaScript is almost exactly just JavaScript
00:42:09 <montanonic> which feels wrong; it too needs a lightweight solution like ttt_fff is seeking
00:42:10 <Arahael> ttt_fff_: Hence... purescript.
00:42:18 <montanonic> fair, fair
00:42:37 <Arahael> Apparently a big issue is the strictness.
00:42:52 <ttt_fff_> Arahael: I like purecriptss strictness
00:42:56 <montanonic> between Hask and JS, or are we talking about Pure?
00:42:57 <Arahael> Also, ghcjs gives you multithreadedness.
00:43:08 * Arahael isn't familiar with Hask.
00:43:17 <montanonic> Haskell
00:43:28 <Arahael> Ah.  Well there's a project called Hask as well, iirc. :)
00:43:33 <ely-se> Hask is the category of Haskell types.
00:43:34 <montanonic> Ah, hah, oops
00:43:44 <Arahael> It's also a haskell-in-python imlementation.
00:43:46 <montanonic> should have expended those extra 3 chars of effort
00:44:17 <montanonic> Arahael: I'm kinda new to a lot of this; do you have any experience working with Yesod and/or Purescript?
00:44:29 <erisco> ttt_fff, I don't know, I haven't set up something like this before, but maybe this is an idea http://lpaste.net/139777
00:44:32 <Arahael> montanonic: Sadly, none. :(  I'm just getting into haskell.
00:44:41 <erisco> ttt_fff, there are other libs that do this such as Atom iirc
00:44:44 <Arahael> montanonic: Though without a project.
00:44:58 <montanonic> Okay. Well if you are interested in a project checkout snowdrift.coop
00:44:58 <erisco> http://hackage.haskell.org/package/atom
00:45:19 <montanonic> They are entirely written in Haskell, using Yesod for their web platform, and PostgreSQL for database.
00:45:28 <montanonic> looking for interested volunteers
00:45:59 <Arahael> montanonic: I'm a salaried dev.
00:46:08 <EvanR> is foldM superceded by something in Foldable
00:46:13 <montanonic> Arahael: ahhah, well, that would change things
00:46:36 <Arahael> montanonic: Though I do have... plans. :)
00:47:00 <montanonic> Arahael: awesome; trying to get more Haskell in your work life?
00:47:25 <Arahael> montanonic: Nah.  There's little call for it here, though F# and Swift is building momentum.
00:48:26 <montanonic> Arahael: gotcha; well I wish you well on your future projects
00:48:31 <Arahael> montanonic: :)
00:51:42 <jle`> your name is tripping me out so much montanonic 
00:52:22 <montanonic> let me guess, Monatonic?
00:53:05 <jle`> i'm experiencing so much cognitive dissonance saying it out loud
00:53:11 <montanonic> My name is Nicholas Montano, so I wasn't trying to trick anyone with that tag :)
00:53:18 <erisco> ttt_fff, this should tidy things up a bit  http://lpaste.net/139778
00:53:42 <montanonic> It's funny, I've used it a bunch throughout college, but never heard the monatonic thing until using it in programming circles.
00:53:47 <ttt_fff_> erisco: I'll take a look at it in a bit; trying to get a minimal compiler up first
00:53:48 <erisco> or whatever you want to use
00:53:58 <ttt_fff_> I think once I see outputted js, I'll see how I'm being stupid
00:53:58 <jle`> you ever talk to mathematicians ?
00:54:16 <montanonic> guess not directly, but enough friends who studied math
00:54:22 <erisco> the reason you might not want the type on the constructor such as Add
00:54:24 <montanonic> then again, that wasn't through IRC
00:54:27 <erisco> is because you've got Int, Float, and so on
00:54:35 <erisco> well, in JavaScript it is just Number
00:54:53 <erisco> so, with this approach using Const you can just give it a type ad-hoc
00:55:09 <erisco> also I fixed it up so you don't wrap types in Expr
00:55:15 <dmj> monatonic: can you pronounce here for us? Is it "mahn-ah-tonic" ? Which vowel do you stress
00:55:57 <montanonic> mohn-tuh-non-ic
00:56:45 <dmj> montanonic: thank you
00:56:52 <montanonic> dmj: np!
00:59:26 <TTK> Hi guys - I am hoping to get a take on this: I have been worknig to learn haskell on/off in ½ year - only doing some exercises in my spare time. Now I am working on a research project using scala. In many ways I prefer Haskell to Scala, but the thing about object oriented just makes me so much more productive. It is probably my OO-background... How
00:59:27 <TTK>  do you guys handle state in Haskell? Do you just use the state monad and do? I have been working on some exercises, but they are all about "implement a tree structure like this..", they are not really about creating actual applications...
01:00:10 <latermuse> TTK: There isnt a lot of intermediate level tutorials for haskell. You will need to dig a lot to find them.
01:00:34 <BartAdv> which one FRP library should I look into if I just wanted to have my own interpreter and push events manually for testing (without even being in IO), instead of being tied to any particular implementation (so no GTK, DOM or whatever)?
01:00:52 <frerich> TTK: I usually start by passing state around as function arguments. At some point, I then consider using the Reader/Writer/State monads (in that order).
01:01:04 <srenatus> TTK: I liked exercism the last time I've played with it http://exercism.io/languages/haskell
01:01:11 <montanonic> TTK: just curious, have you read Functional Programming in Scala?
01:01:18 <ttt_fff_> TTK: the way I switched to haskell was that I said "for the next 6 months; haskell is the only langauge I' going to use"; then, I became productive in haskell
01:02:10 <liste> BartAdv reactive-banana or netwire, for example
01:03:02 <TTK> ttt_fff: that is a good idea, but I do not think the place where I work would agree :) montanonic nop, I just started working with scala on my thesis. Did not know until I begun that I was to use Scala. A lot of the code is probably not "very" functional (I am continuing on some elses work).
01:03:03 <BartAdv> hm, now I remember some basic examples in reactive-banana were showing how to just create network and fire events to it
01:03:13 <erisco> ttt_fff, and how there is a Show instance, such value :) http://lpaste.net/139779
01:03:35 <TTK> frerich: I will remember that. Thanks
01:03:41 <TTK> srenatus: I will take a look at it, thanks
01:09:43 <John[Lisbeth]> Can someone please link me to a minimal implementation of SHA?
01:15:34 <srenatus> John[Lisbeth]: there're many SHAs, 0, 1, 2, and 3.
01:17:45 <srenatus> John[Lisbeth]: entire suite seems to be here http://hackage.haskell.org/package/SHA-1.6.4.2/docs/src/Data-Digest-Pure-SHA.html (if http://hackage.haskell.org/packages/search?terms=SHA doesn't lie)
01:32:12 <erisco> no hOpen?
01:32:52 <erisco> okay I guess you have to go to System.IO
01:33:03 <erisco> who does IO in Haskell anyways
01:36:19 <matsuura> Why not use IO? That's where the real fun is at!
01:42:02 <liste> why is base in Hackage btw? if it's bundled with GHC
01:43:43 <liste> erisco hOpen doesn't deal with text, there's no reason for it to be in Data.Text.IO
01:43:53 <liste> if that's what you meant
01:44:00 <liste> s/hOpen/openFile/
01:46:54 <erisco> liste, who's talking about text?
01:47:52 <liste> I guess I missed something
01:47:59 <liste> never mind then (:
01:54:13 <hvr> liste: mostly for the haddocks and so the hyperlinks to base from other packages have a target 
02:00:33 * hackagebot cabal-rpm 0.9.7 - RPM packaging tool for Haskell Cabal-based packages  https://hackage.haskell.org/package/cabal-rpm-0.9.7 (JensPetersen)
02:05:33 * hackagebot HFrequencyQueue 0.2.0.0 - A Queue with a random (weighted) pick function  https://hackage.haskell.org/package/HFrequencyQueue-0.2.0.0 (Bellaz)
02:09:22 <whald> ehm, when using cabal sandboxes, is it normal that "cabal configure" work while "runhaskell Setup.hs configure" complains about the dependencies not being installed? I expected "runhaskell Setup.hs <X>" to be equivalent to "cabal <X>"
02:09:52 <Intolerable> try cabal exec runhaskell Setup.hs configure
02:09:59 <Intolerable> i'm not surprised that those are different
02:10:34 * hackagebot neat-interpolation 0.2.3 - A quasiquoter for neat and simple multiline text interpolation  https://hackage.haskell.org/package/neat-interpolation-0.2.3 (NikitaVolkov)
02:11:08 <whald> Intolerable, "cabal exec runhaskell Setup.hs configure" also doesn't see the packages installed in the sandbox
02:11:40 <Intolerable> hm
02:12:44 <whald> also, "runhaskell Setup.hs install --only-dependencies" gives "unrecognized 'install' option `--only-dependencies'" -- i'm honestly surprised that those are so different, I always thought Setup.hs == cabal + user hooks
02:23:03 <kqr> whald, cabal exec -- runhaskell Setup.hs configure
02:23:05 <kqr> whald, ?
02:23:28 <kqr> i'm purty sure the double dash is supposed to be there to separate the command from flags to cabal
02:24:56 <whald> kqr, "cabal exec -- runhaskell Setup.hs configure" does not see the sandboxed packages as well :-(
02:25:34 <kqr> whald, which version of cabal?
02:25:54 <whald> kqr, cabal-install version 1.22.2.0  using version 1.22.2.0 of the Cabal library
02:26:07 <kqr> well that should work
02:26:50 <whald> what works for me is: cabal sandbox init, cabal install --only-dependencies, cabal configure --prefix=/usr/local, runhaskell Setup.hs build, cabal copy --destdir=dist/staging
02:27:52 <whald> so basically i'm using Setup.hs only for the build step, which currently does the trick for me because i've only got a postBuild hook that needs to be executed.
02:28:21 <whald> i just wanted to use Setup.hs everywhere 'cause it looks cleaner
02:29:35 <whald> also, it's not my postBuild hook that messes up things, the behaviour is the same with "main = defaultMain" in Setup.hs
02:36:27 <howdoi> given that there is no single definition of functional programming, how would you define it?
02:38:47 <ww> howdoi: the opposite of broken programming?
02:39:16 <howdoi> ww: heh heh
02:43:09 <liste> howdoi maybe avoiding mutable state and using higher order functions would be close
02:43:28 <howdoi> (:
02:47:40 <erisco> howdoi, programs are expressions
02:49:13 <howdoi> why so much of traction to it all of a sudden?
02:49:33 <howdoi> what made people realise the true potential of FP?
02:49:59 <erisco> why do you say "all of a sudden"
02:51:07 <howdoi> erisco: because most of the programming languages which were multi paradigm where not making use of functional style, for example javascript 
02:51:12 <kqr> howdoi, it's been coming slowly for a long time, with "experimental" and "hip" languages like python and javascript including functional features, and people whispering about mystical performances by weird languages like erlang
02:51:43 <erisco> howdoi, and now they are?
02:52:33 <srhb> Doing FP in most multi-paradigm languages is still painful and fills you with distrust. You can't recurse in Python, you can't trust that functions are side effect free in JS...
02:53:05 <howdoi> erisco: relatively better 
02:53:33 * srhb doesn't actually think either are multi paradigm in any meaningful way, at least they're not FP.
02:53:54 <erisco> once people know of something they generally retain knowledge of it
02:54:17 <erisco> so it stands to reason that the number of programmers knowledgeable of FP has gone up
02:55:02 <howdoi> agree, wrt to JS we have functions as first class citizens and closures 
02:56:39 <kqr> srhb, but I think it's just that that's gotten people to try functional languages out
02:56:49 <kqr> srhb, "i really like this style of coding but my language makes it terribly inconvenient"
02:56:49 <srhb> kqr: That might be. :)
02:57:03 <erisco> how are you supposed to catch IO exceptions when using a Monad transformer?
02:57:06 <erisco> the IO is buried
02:57:27 <erisco> I can only think to catch before it is lifted
02:58:17 <howdoi> side-effect free is tough! console.log is also a side effect 
02:58:51 <liste> howdoi but putStrLn isn't ; )
02:59:34 <howdoi> heh heh
03:00:14 <howdoi> it's not zeroing down side-effects, it's about making it clear in the signature if there are any side-effect 
03:00:44 <erisco> like Java
03:01:03 <howdoi> Java does that?!
03:01:08 <howdoi> :D
03:01:16 <howdoi> public static void main() {}
03:01:52 <erisco> you annotate exceptions
03:02:41 <liste> I don't think it's only that
03:03:40 <howdoi> oh, ok
03:03:42 <liste> if Java would separate pure methods from impure methods, could you do something like collect the method invocations in a list, shuffle the list and then run it
03:03:48 <howdoi> Syntax is a monad! 
03:04:34 <erisco> liste, why does purity matter for that?
03:06:10 <liste> well, if you have println("..") in your Java code, it just prints the stuff the moment it's encountered
03:06:31 <howdoi> anything that does IO is not pure 
03:06:43 <erisco> so, you mean to thunk it
03:06:47 <erisco> that is easy to do
03:07:16 <liste> howdoi putStrLn "hello" is pure
03:07:45 <howdoi> liste: how?
03:07:46 <erisco> all IO functions except those marked unsafe are pure
03:08:01 <erisco> that is why we have IO
03:08:14 <liste> > [putStrLn "hello", putStrLn "world"] -- is this not a pure value?
03:08:17 <lambdabot>  [<IO ()>,<IO ()>]
03:08:30 <erisco> it achieves purity in the trivial sense that it is never called with the same arguments
03:09:04 <erisco> this is the invisible game being played behind the scenes with RealWorld
03:09:21 * howdoi was reading https://github.com/hemanth/functional-programming-jargons#side-effects
03:10:19 <lwm> holy crap that repo is a good idea
03:10:24 <erisco> well, IO i.e. input/output has potential to be impure, so to overcome that we have IO i.e. the Monad
03:10:36 <kqr> the type*
03:10:42 <kqr> it just happens to also be an instance of monad
03:10:43 <kqr> and functor
03:10:45 <kqr> and applicative
03:10:48 <kqr> but at its core, it's just a type
03:11:09 <nshepperd_> in haskell "IO functions" are just ordinary functions that happen to result in an IO value
03:11:24 <howdoi> lwm: which one is a good idea?
03:11:25 <nshepperd_> an IO value being a 'recipe' for 'doing something'
03:11:30 <lwm> can IO value be replaced by IO action?
03:11:43 <nshepperd_> IO action, yes that is a better term
03:11:45 <lwm> howdoi: the functional-programming-jargons one :)
03:11:57 <howdoi> lwm: thanks ;) :)
03:12:15 <liste> and you can manipulate IO actions just like any other values before you pass them to `main'
03:12:26 <liste> you just can't get their results out
03:12:44 <erisco> you can get some stuff out
03:12:45 <howdoi> 'all IO functions except those marked unsafe are pure' how do we mark them unsafe? with the signatures ?
03:13:09 <liste> but you can bind them to another actions that use the results
03:13:14 <liste> and that's >>=
03:13:20 <kqr> howdoi, they're called things like unsafePerformIO or unsafeWrite
03:13:27 <erisco> :t \x -> (fmap fst x, fmap snd x) :: IO (a,b) -> (IO a, IO b)
03:13:28 <lambdabot>     Couldn't match expected type ‘IO (a1, b3) -> (IO a1, IO b3)’
03:13:28 <lambdabot>                 with actual type ‘(f b1, f b2)’
03:13:28 <lambdabot>     Relevant bindings include
03:13:36 <erisco> well you can fix that up for me
03:13:51 <kqr> howdoi, or my personal favourite: reallyUnsafePtrEquality
03:13:59 <howdoi> oh!
03:14:01 <erisco> :t (\x -> (fmap fst x, fmap snd x)) :: IO (a,b) -> (IO a, IO b)
03:14:02 <lambdabot> IO (a, b) -> (IO a, IO b)
03:14:13 <erisco> see, you can get the tuple structure out
03:14:29 <erisco> you can figure out how to pull out a list structure, the result is interesting
03:14:48 <nshepperd_> when imperative languages like java (or ocaml) want to simulate this they define effectively "type IO a = () -> a"
03:15:20 <nshepperd_> lambdas with 'no argument' in python, etc
03:15:33 <chpatrick> hey #haskell
03:15:59 <kqr> nshepperd_, though that's not quite the same thing given that the regular way to execute that kind of delayed IO is by appending () to the function name, and that's also the equivalent of unsafePerformIO
03:16:11 <kqr> nshepperd_, so that'd be like Haskell IO type except the only way to run it would be thruogh unsafePerformIO
03:16:26 <kqr> which would be bad
03:17:29 <srhb> chpatrick: Hello.
03:18:10 <erisco> you can have the result return in some Identity-like structure
03:18:29 <erisco> however, because you can just use side effects at will you can't guarantee it stays there
03:18:34 <howdoi> :t id 
03:18:35 <lambdabot> a -> a
03:18:35 <nshepperd_> well, you can write 'return' and '>>=' for that type in python, at least
03:18:44 <howdoi> where would it be most useful? 
03:19:10 <erisco> howdoi, usually to degenerate a more general definition
03:19:37 <kqr> howdoi, whenever something expects a function but you just want it to operate on whatever value it has directly
03:20:12 <howdoi> cool!
03:20:19 <nshepperd_> anyway, I think that's why IO is often conflated with functions (people calling getLine a function, for instance). other languages treat 'calling a function' as the thing that makes execution happen
03:20:23 * howdoi this room is filled with FP gurus!
03:20:29 <erisco> also for stating laws, for example  fmap id = id
03:21:17 <srhb> kqr: Re favourite unsafe function, there are way more unsafe-sounding ones, unfortunately I can't find them right now :P
03:21:43 <Guest83271> Does anyone use uhc to produce javascript code/
03:21:44 <howdoi> :D
03:21:52 <howdoi> uhc?
03:22:09 <srhb> Utrecht Haskell Compiler I assume
03:22:37 <erisco> also for categories 'id' is a value like '0' is a value for addition
03:22:46 <srhb> (Though in keeping with the spirit of "glorious Glasgow" it really should be "Ultimate Utrecht ..."
03:23:01 <kqr> srhb, I've been linked to one of those before, but it just sounded forced as if the author intended to make it a funny name
03:23:14 <srhb> kqr: Yes, I think that's probably the case. It was in base, though.
03:23:14 <kqr> srhb, reallyUnsafePtrEquality sounds like a name someone might seriously come up with
03:23:21 <erisco> id . f = f, 0 + x = x
03:23:32 <Guest83271> yeah Utrecht Haskell Compiler
03:23:58 <srhb> Guest83271: I think right now people are mostly using ghcjs
03:24:05 <Guest83271> ah okay
03:24:27 <lwm> folks, does ANYTHING like this exist in Haskell: http://conj.io/
03:24:37 <lwm> I know we have Hoogle ... but this is ... like, cooler
03:25:05 <srhb> lwm: What are you referring to? The reference table?
03:25:19 <lwm> when I put a function there, I get examples of how to use it
03:25:21 <lwm> wait brb
03:25:42 <erisco> you're supposed to click through on Hoogle to Hackage and hope there are examples there
03:25:47 <srhb> lwm: Ah. In that case the answer is simple and discouraging: No one bothered to do it. :P
03:25:47 * howdoi so far -> https://github.com/hemanth/haskell-rascal
03:25:53 <erisco> not the most efficient system
03:33:16 <erisco> is Control.Monad.IO.Peel really the solution for catching IO exceptions?
03:35:00 <srhb> erisco: Isn't exceptions the current go-to package?
03:35:38 <erisco> maybe so
03:35:43 <erisco> I thought we just had Control.Exception
03:36:13 <srhb> I don't think there's a transformer story for that.
03:36:36 <erisco> seemingly not, but .Peel tries to rectify that
03:36:50 <erisco> anyways, Control.Monad.Catch ought to do
03:39:04 <erisco> trying to figure out this confusion...
03:39:18 <erisco> so you've got a Producer (pipes) doing some IO stuff, i.e. monad is IO
03:39:23 <erisco> this can throw exceptions of course
03:39:31 <srhb> erisco: Perhaps this blog post is of interest to you: http://www.yesodweb.com/blog/2014/06/exceptions-transformers
03:39:45 <srhb> (not re. pipes, though)
03:39:59 <erisco> my thought is instead of  Producer a m r   (Exception e) => Producer (Either e a) m r
03:55:22 <ttt_fff> https://gist.github.com/anonymous/31546d0b05d6cb66e096 <-- please help
03:55:59 <chpatrick> ttt_fff: because JsExprOf a is ambiguous
03:56:21 <chpatrick> and you have OverloadedStrings on so it has type (IsString s => s)
03:56:25 <ttt_fff> why do I only get error on the "compileJS JsDomAppendChild" line and how do I get rid of it?
03:56:30 <chpatrick> so it has two ambiguous types and it can't infer what it is
03:56:50 <ttt_fff> why does "compileJs JsAlert" and "compileJs JsConsoleLog" not give me errors?
03:56:53 <chpatrick> hmm
03:56:58 <chpatrick> oh wait nm
03:56:59 <chpatrick> it's to text
03:57:07 <chpatrick> that's weird
03:57:24 <ttt_fff> if I comment out the "JsDomAppend" line in the data decl, and the compileJs line, that it type checks fine
03:57:28 <chpatrick> it's because you have compileJS
03:57:30 <chpatrick> not compileJs :)
03:57:43 <ttt_fff> omg
03:57:45 <ttt_fff> I'm a moron
03:57:53 <chpatrick> been there
03:57:57 <ttt_fff> any idea why I get the error I get
03:58:10 <ttt_fff> i.e. ghc should be like "you're an idiot; by compileJS did you mean compileJs" ?
03:58:12 <chpatrick> because it's a new function without a type signature
03:58:28 <chpatrick> and it has an ambiguous type because of overloadedstrings
03:59:11 <dbushenko> how to convert Rational to Integer?
03:59:22 <srhb> :t fromRational
03:59:23 <lambdabot> Fractional a => Rational -> a
03:59:26 <chpatrick> dbushenko: round?
03:59:29 <srhb> Woops, no.
03:59:30 <chpatrick> :t round
03:59:31 <ttt_fff> okay, so suppose I wrote 'foo = "Hello World"'
03:59:32 <lambdabot> (Integral b, RealFrac a) => a -> b
03:59:35 <srhb> And yes, round, ceil etc.
03:59:36 <dbushenko> thanks!
03:59:40 <ttt_fff> then haskell would be like what is foo? is foo a String? a Text? a LazyText? etc ...
03:59:45 <ttt_fff> and it gives me this weird error
03:59:52 <chpatrick> yep
04:00:10 <ttt_fff> chpatrick: this makes sense now, thanks for catching it! I was trying to figure out "what is wrong with my complicated type system" and didn't notice JS vs Js
04:00:42 <chpatrick> no worries
04:02:03 <ttt_fff> GADTs are soo beautiful
04:02:35 <howdoi> point of point-free is composabilty?
04:02:59 <chpatrick> not really
04:03:04 <ttt_fff> point of point free is you can demonstrate your superiority over haskell newbs and be like --- I am smart
04:03:10 <chpatrick> it can be cleaner sometimes
04:03:17 <liste> by that logic @pl is Einstein!
04:03:19 <chpatrick> when your function is kind of a pipeline
04:03:29 <chpatrick> but often it really isn't worth it
04:03:38 <howdoi> :|
04:04:01 <chpatrick> everyone goes through a point-free abuse phase when they learn haskell :D
04:04:08 <liste> @pl \a b c d e f g h -> a (b c) (d e) (f (g h))
04:04:09 <lambdabot> flip flip (.) . ((flip . ((flip . ((flip . (((.) . (.) . (.)) .)) .) . (.)) .)) .) . (.)
04:04:16 <chpatrick> beautiful
04:04:21 <howdoi> best example for a Referential Transparent function would be?
04:04:33 <chpatrick> any function? :)
04:04:33 <liste> howdoi pretty much anything in Haskell
04:04:42 <chpatrick> modulo unsafePerformIO and other evil stuff
04:04:47 <lwm> erisco: but when there aren't examples (which can be the case!), it sucks
04:05:00 <lwm> srhb: I think it would be a cool project ...
04:05:06 <howdoi> kool
04:05:13 <srhb> lwm: Definitely! Go for it! ;)
04:05:20 <liste> but e.g. sin() in all languages
04:05:30 <lwm> srhb: I wonder how this conj.io thing works ... off I go
04:05:54 <howdoi> and idempotency ?
04:06:04 <srhb> Ideally I suppose haddock could be expanded with example sections that hoogle could easily include in the search results
04:06:23 <chpatrick> idempotency is when you can do something multiple times without having an extra effect
04:06:34 <srhb> Oh, it already has those.
04:06:40 <lwm> yeah right, it does like
04:06:52 <lwm> -- | first [1,2,3]
04:06:56 <lwm> or something 
04:07:08 <lwm> or is that 'head' :|
04:07:41 <srhb> lwm: -- | Example header; -- >>> example expression; -- example result
04:07:58 <lwm> cool
04:07:58 <howdoi> chpatrick: like Math.abs Math.abs 
04:08:20 <liste> howdoi yeah
04:08:32 <srhb> lwm: So I guess the trick is to make hoogle steal those examples (perhaps an expandable section underneath the type etc.) and then update ALL OF HACKAGE with actual examples :-)
04:09:10 <lwm> wouldn't that be *so* cool
04:09:13 <liste> abs is both referentially transparent and idempotent
04:09:14 <lwm> I would love that 
04:09:21 <srhb> lwm: Yes, definitely. :)
04:09:36 <srhb> lwm: Go start the discussion! https://github.com/ndmitchell/hoogle/issues
04:10:42 <lwm> sure, why not!
04:10:56 <lwm> better search about first there ... surely someone wanted this before
04:11:35 <howdoi> we could say, generators are close to lazy evaluation? 
04:12:12 <orbifx> if traverseWithKey the best function for transforming keys and values alike in a Data.Map?
04:13:06 <liste> howdoi they are sometimes used to solve the problem (avoiding extra traversals/memory use)
04:13:07 <chpatrick> orbifx: I think it depends on what you're doing
04:13:14 <liste> the same problem*
04:13:25 <howdoi> hmm
04:13:26 <chpatrick> howdoi: I think it's a good comparison
04:13:40 <chpatrick> they're kind of like lazy lists
04:13:49 <chpatrick> or pipes/conduit if you're doing io
04:13:50 <lwm> srhb: actually, when I search for example, liftIO on hoogle
04:13:58 <ely-se> efficiency isn't the only usecase for laziness
04:13:59 <chpatrick> conduit in particular has a very generator-like interface
04:14:02 <chpatrick> with yield/await
04:14:04 <lwm> I don't really get anywhere close to Control.Monad.Trans
04:14:06 <lwm> https://www.haskell.org/hoogle/?hoogle=liftIO
04:14:11 <ely-se> it can even have an adverse effect if you think it is
04:14:16 <ely-se> it's about semantics
04:15:35 <srhb> lwm: Why would you?
04:15:52 <srhb> lwm: It's in Control.Monad.IO(.Class?)
04:15:56 <lwm> well, I had to import that in ghci to get at it
04:17:28 <orbifx> chpatrick: I want to fix issues with the keys and values, (String k, [String] v) => (k -> v -> (k, v)) -> Map k v -> Map k v
04:18:10 <orbifx> but the function needs access to both key and value simultaneously 
04:18:14 <I> Is there an os x binary package for ghcjs? I'm having trouble compiling it.
04:18:20 <Guest92818> ghcjs-boot --dev --ghcjs-boot-dev-branch improved-base --shims-dev-branch improved-base --with-iconv-includes /usr/include/ --with-iconv-libraries /usr/lib/
04:18:37 <Guest92818> Is there an os x binary package for ghcjs? I'm having trouble compiling it.
04:18:40 <Guest92818> ghcjs-boot --dev --ghcjs-boot-dev-branch improved-base --shims-dev-branch improved-base --with-iconv-includes /usr/include/ --with-iconv-libraries /usr/lib/
04:19:11 <Guest92818> checking for library containing iconv... no
04:19:20 <chpatrick> orbifx: I think at that point I'd just M.fromList . map changeEverything . M.toList
04:19:31 <Guest92818> ls /usr/*/*icon*
04:19:31 <Guest92818> /usr/bin/iconutil		/usr/bin/piconv5.18		/usr/lib/libiconv.dylib
04:19:31 <Guest92818> /usr/bin/iconv			/usr/include/iconv.h		/usr/texbin/dviconcat
04:19:31 <Guest92818> /usr/bin/piconv			/usr/lib/libiconv.2.4.0.dylib
04:19:31 <Guest92818> /usr/bin/piconv5.16		/usr/lib/libiconv.2.dylib
04:19:35 <chpatrick> since you're completely changing the structure of the map anyway, might as well just rebuild it
04:20:50 <thatguy> wie hieß dieser amerikanische kommunist der immer so populistische dokus gemacht hat zB zu gentechnik?
04:20:51 <orbifx> chpatrick: I figured it would need a rebuild each time, just wasn't sure which was the designated approach for this.
04:20:55 <thatguy> upps wrong paste
04:21:14 <orbifx> thatguy: translate anyway, seems interesting :P
04:21:25 <thatguy> I am reading through the functional programming tutorial of the pthon docs and they introduce iterators there. Why are iterators concidered functional? They have a internal state or not?
04:21:41 <chpatrick> composability I guess
04:21:59 <chpatrick> and because itertools has higher-order functions
04:22:16 <thatguy> orbifx: I asked a friend about some docu we saw which some kinda communistic us guy does which have a populistic (does this word exist in english?) feeling, but he had a pretty interesting one on gene manipulation
04:22:27 <thatguy> I forgot his name
04:22:34 <chpatrick> michael moore?
04:22:55 <lwm> sweet: https://www.wordnik.com/words/populistic
04:23:08 <thatguy> chpatrick: ah exactly, thanks a lot!
04:23:54 <thatguy> ChanServ: for both answers
04:33:23 <orbifx> thatguy: populistic exists yes
04:39:09 <dredozubov> https://gist.github.com/dredozubov/8335d170d07783781dc5 any idea why it differs in such a way? Is this a bug?
04:46:13 <geekosaur> dredozubov, looks correct behavior to me
04:46:18 <geekosaur> i.e. your bug
04:46:25 <geekosaur> not a bug in ghc
04:47:44 <geekosaur> hm, wait. maybe not. I am uncertain about what the kind signature is telling it...
04:48:16 <dredozubov> geekosaur: i disconnected and got only your last message. Can you repeat what came before?
04:48:44 <dredozubov> https://github.com/ekmett/structs/commit/9f17e94eeff66dbea88373ff4c9eac312f14dfe5 also this seems kinda hilarious
04:49:33 <geekosaur> I said that the behavior you showed looked correct ... but I'm not really up on kind signatures and the like, and don't entirely trust my initial interpretation of it
04:52:25 <ttt_fff> is it possible to create  "class" with no member functions? All I want to do is have: (1) class IsJsDom a where \n (2) instance IsJsDom JsButton (3) instance IsJsDom JsTextField (3) instance IsJsDom TextArea ...
04:52:43 <ttt_fff> so basically, all I want to do is define which data represents jsdoms
04:53:02 <liste> ttt_fff how would you use it?
04:53:15 <ttt_fff> I won't use it
04:53:37 <ttt_fff> I have other functions, where I say: jsAppendChild: IsJsDom a, IsJsDom b => a -> b -> JSIO ()
04:53:50 <ttt_fff> I have other functions, where I say: jsAppendChild :: IsJsDom a, IsJsDom b => a -> b -> JSIO ()
04:53:54 <liste> and how would that function work?
04:54:05 <ttt_fff> you win
04:54:05 <liste> if it can't do anything with the values
04:54:06 <ttt_fff> I understand
04:54:08 <dredozubov> isn't `a` in (1) should restrict type parameters in the arguments to be the same? As i see it, it should be equal to typeclass with two type parameters and instances like "instance Foo a a where .."
04:54:18 <ttt_fff> liste: I will now mark you as zen socrates
04:55:03 <ttt_fff> what I really need is: "class ToJsPtr a where \n toJsPtr :: a -> JsPtr" ...
04:55:17 <liste> I will wear that (undeserved) hat with pride
04:55:35 <ttt_fff> what I really need is: "class ToJsDomPtr a where \n toJsPtr :: a -> JsDomPtr" ... then I have ways of casting each JsButton / JsTextArea / JsTextField to a JsDomPtr of some sort
04:56:07 <liste> ttt_fff check out Typeable and Dynamic
04:56:24 <ttt_fff> isn't Dynamic for:: Dyn -> Maybe a ?
04:56:34 <ttt_fff> it's not clear to me how that is useful for me
04:57:16 <liste> I mean how they're implemented
04:59:32 <cocreature> dredozubov: looks like a bug too me, afaik exhaustiveness checking for gadts can be quite buggy, although there has been some progress made, see http://research.microsoft.com/en-us/um/people/simonpj/papers/pattern-matching/gadtpm.pdf
05:00:37 <dredozubov> cocreature: just asked on #ghc to be sure
05:09:00 <twb> So on Debian Stretch I installed ghc 7.8.4 & haskell-platform 2014.2.  cabal configure of 4blocks is telling me it's missing "base >=2 && <=4".
05:09:18 <twb> Is it pissed that my ghc is too old, or what?  I can't see a libghc-base-... package
05:09:47 <cocreature> twb: base <= 4 is ancient, your ghc is too new
05:09:54 <twb> Haha
05:09:55 <twb> Thanks
05:10:03 * twb picks a different haskell game to study
05:10:16 <Sindriav_> I'd really like if there were two classes instead of just "Show", like Rust has
05:13:12 <suppi> Hi all
05:13:27 <suppi> I'm working on a CHIP-8 emulator, here is my CPU model: https://github.com/soupi/chip-8/blob/master/src/CPU/CPU.hs
05:13:51 <suppi> Right now I want to implement an opcode that says: "Stores V0 to VX in memory starting at address I."
05:13:59 <thatguy> is there a good haskell tutorial of the kind that always gives you a problem you have to solve using haskell which get increasingly harder?
05:14:08 <suppi> and another one: "Fills V0 to VX with values from memory starting at address I."
05:14:26 <suppi> is there a nice way to express this in Haskell?
05:14:31 <suppi> using my model?
05:16:15 <suppi> thatguy, like a course with homework?
05:16:39 <suppi> thatguy, have you seen cis194?  https://www.seas.upenn.edu/~cis194/spring13/lectures.html
05:18:25 <skore_de> weird deja vu...
05:18:26 <skore_de> (02:39:14) Ashley_: Hi everyone! I'm trying to learn Haskell in advance of my CS course starting in October, and I'm struggling to use the knowledge I'm gaining. Does anyone know of any good resources that give exercises to do that gradually get harder?
05:18:46 <skore_de> as I mentioned yesterday: Check out #haskell-beginners ;)
05:19:59 <geekosaur> or were you just lost in scrollback?
05:20:45 <chpatrick> hey suppi
05:20:51 <chpatrick> I wrote a chip-16 emulator a while back
05:21:04 <chpatrick> I would recommend using mutable stuff
05:21:10 <chpatrick> otherwise it'll be very inefficinet
05:21:16 <ttt_fff> in #haskell, people ask for HW problems (instead of solutions)
05:21:52 <suppi> hi chpatrick
05:21:56 <chpatrick> also it's difficult to share a State
05:22:01 <chpatrick> but it's easy to pass an ioref around
05:22:04 <suppi> chpatrick, I'm not concerned with speed at the moment
05:22:14 <Stratege> I'd advise against using mutability.
05:22:21 <chpatrick> why?
05:22:30 <Stratege> simply because being forced to deal with immutability is going to teach you things.
05:22:42 <chpatrick> otherwise you have to copy a 64k vector around every time you write to memory
05:22:44 <suppi> chpatrick, I want to try to mapping it the way I like and when I run into trouble change my perception
05:22:55 <chpatrick> go for it, just saying
05:23:04 <Stratege> I'd even advise against using State for the first while of experimenting with things
05:23:21 <ttt_fff> my favorite quote: the best performance increase is from not working to working
05:23:47 <suppi> chpatrick, thanks
05:23:52 <chpatrick> sure but in haskell the thing I always find the biggest pain in the ass is pure to monadic refactoring
05:24:23 <suppi> chpatrick, I actually had fun using no mutation to build a game with Elm
05:24:47 <Stratege> mhm, but it can usually be avoided. Monads are cool and all, but far from necessary for most things.
05:24:51 <ttt_fff> (1) I am writing a monad. (2) To implement this monad, I need to use a RWS monad. (3) I don't want to expose the functionality of the RWS monad to the user (i.e. I need modify/get/put/ask/local/tell to implement my monad, but I don't want the user to be able to call modify/get/put/ask/local/tell inside my monad). Is there a way to do this?
05:25:14 <chpatrick> Stratege: get back to me when you write a pure emulator that runs at the right clock speed :)
05:25:17 <Stratege> ttt_fff newtyping / export lists
05:25:41 <lwm> ttt_fff: export lists are probably the simplest
05:26:00 * hackagebot apiary 1.4.5 - Simple and type safe web framework that generate web API documentation.  https://hackage.haskell.org/package/apiary-1.4.5 (HirotomoMoriwaki)
05:26:04 <ttt_fff> well, I want other pieces to be able to use ask/local/read/get/modify/put ... BUT just not inside this monad
05:26:25 <ttt_fff> code should be able to use modify/get/put/ask/local/read in other RWST monads, but just not this particular onnad (which needs RWS to be implmented)
05:26:26 <Stratege> chpatrick I'm not particularly worried about "the right clock speed" only about "fast enough for my purposes". If I -really- cared about getting all of the performance I'd just use C instead I guess.
05:26:36 <Stratege> ttt_fff newtype then
05:26:40 <chpatrick> well there's all of the performance and there's 60fps
05:26:49 <ttt_fff> Stratege: why would I newtype instead of just "data" ?
05:26:50 <lwm> export between modules, so do expose your functions to your other modules, then use a single entry point for the app which only exposes what you want
05:27:41 <Stratege> ttt_fff newtype is the same as data, semantically, when you only have 1 field, but it's better documentation and maybe allows more auto deriving / optimization opportunities. Not sure about those two points though.
05:27:45 <suppi> chpatrick, Stratege, do you have any advice on my situation?
05:28:30 <chpatrick> suppi: can you use lens for Vector?
05:28:31 <Stratege> suppi mind stating your situation again? :)
05:28:37 <chpatrick> the At typeclass
05:28:49 <suppi> Stratege, sure.
05:28:54 <suppi> chpatrick, what do you mean?
05:29:21 <chpatrick> well
05:29:22 <suppi> Stratege, I'm working on a CHIP-8 emulator, here is my CPU model: https://github.com/soupi/chip-8/blob/master/src/CPU/CPU.hs
05:29:29 <chpatrick> let's say you have a State CPU
05:29:34 <suppi> Right now I want to implement an opcode that says: "Stores V0 to VX in memory starting at address I."
05:29:40 <chpatrick> then you can use the lens combinators like
05:29:41 <suppi> is there a nice way to express this in Haskell?
05:29:48 <chpatrick> (memory . ix 0xdeadbeef) .= 42
05:30:03 <chpatrick> to set an address
05:30:07 <suppi> chpatrick, yes
05:30:14 <Stratege> chpatrick sure, if you want 60 fps you might have to do certain things mutable - and there is nothing wrong using mutability when one has to. I merely ment that for learning how to work with Haskell not using mutability or State is a good thing since then you don't fall back on old habits of how to write code and instead are forced to learn new ways of doing it if you don't want it to be awful.
05:30:15 <ttt_fff> with 7.10, when I derive "Monad", do I also have to derive Functor/Applicative ?
05:30:38 <chpatrick> that's true but suppi looks pretty experienced
05:30:46 <chpatrick> ttt_fff: yes
05:30:57 <chpatrick> you should even if you didn't have to :P
05:31:01 <cocreature> is deriving monad even supported? I thought we could only derive functor & applicative
05:31:01 <ttt_fff> so now whene ver I implement a monad "JSCompiler", I have to do
05:31:13 <Stratege> chpatrick oh I'm sorry, I got my wires crossed with the question about learning Haskell just above :)
05:31:16 <ttt_fff> instance Functor JScompiler where \n ... instance Applicative JSCompiler where \n .... instance Monad JSCompiler where .... ?
05:31:20 <chpatrick> cocreature: derivefunctor is an extension, for applicative and monad you need generalizednewtypederiving
05:31:28 <howdoi> how can we achieve statelessness with closures around?
05:31:37 <cocreature> chpatrick: ah, I didn't think about gnd, ofc
05:32:38 <suppi> chpatrick, not too experienced though :)
05:33:14 <chpatrick> suppi: I don't want to cloud your solution but if you ever want to take a look at mine it's here: https://github.com/chpatrick/hchip/blob/master/HChip/Ops.hs
05:33:24 <chpatrick> tbh I wouldn't write it quite like that today
05:33:31 <suppi> chpatrick, thanks! 
05:33:38 <chpatrick> I've been working a bit on a gameboy emulator and it's pretty differnet
05:34:03 <suppi> chpatrick, Would love to do that also. but let's start with a chip-8 :)
05:34:25 <suppi> chpatrick, maybe I should use Vector.update? is there a way to get a subset of a vector?
05:36:14 <chpatrick> suppi: you could do V.take addr mem <> newMem <> V.drop (addr + V.length newMem) mem
05:36:22 <indiagreen> ttt_fff: you can derive Functor, you can't derive Applicative or Monad afaik. If you have *defined* an instance of Monad, you can get Functor and Applicative nearly for free by writing “fmap = liftM”, “pure = return”, and “(<*>) = ap”
05:36:24 <chpatrick> for single element modifications I would recommend the lens interface
05:36:33 <chpatrick> since you're using it anyway
05:36:40 <srhb> Isn't there slice?
05:36:59 <suppi> srhb, yes! slice! thanks :)
05:37:03 <ttt_fff> indiagreen: oh, nice, got it, thanks! :-)
05:37:03 <chpatrick> srhb: we'd like to do a mass update though
05:37:05 <chpatrick> right?
05:37:13 <srhb> Oh sorry, I didn't follow the conversation.
05:37:21 <Stratege> suppi there's (//) and toList which you can use: (//) memory . zipWith (\x y -> (x+n,y) [1..] . toList $ registers
05:37:38 <suppi> chpatrick, I can take the slice, update it to have indices and than use update, right?
05:37:58 <Stratege> although the asymptotics of it are ugly
05:38:37 <suppi> Stratege, yes, great. I'll experiment with that. thanks!
05:39:01 <suppi> Stratege, there are only 16 registers so this is O(1) operation :p
05:39:11 <chpatrick> are you trying to save the registers or load them?
05:39:13 <chpatrick> from memory
05:39:26 <Stratege> fair enough ^^
05:39:30 <suppi> there are to opcodes, one for each
05:39:40 <suppi> two*
05:39:46 <chpatrick> for load you could just set the register field to the slice of the memory
05:39:51 <suppi> one for loading and one for storing
05:40:06 <chpatrick> for storing you could use Stratege's or my solution
05:40:43 <suppi> chpatrick, actually it is not all registers but 0..X
05:40:59 <suppi> so I will probably need the slice both times
05:41:01 <chpatrick> ah I see
05:41:02 <chpatrick> yes
05:41:27 <suppi> chpatrick, Stratege, srhb, thank you all. been a great help :)
05:41:34 <Stratege> np :)
05:48:21 <obadz> Is there a way to avoid space leaks in the Foldable implementations of foldl ?
05:48:39 <benzrf> foldl considered harmful
05:48:40 <benzrf> @where foldl
05:48:40 <lambdabot> I know nothing about foldl.
05:48:42 <benzrf> lame
05:48:58 <obadz> foldMap seems to leak as well
05:50:08 <obadz> Ah it looks like there's a Data.Foldable.foldl'
05:56:02 * hackagebot period 0.1.0.1 - Parse and format date periods, collapse and expand their text representations.  https://hackage.haskell.org/package/period-0.1.0.1 (alkar)
05:56:47 <kuribas> :t foldl
05:56:48 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
05:58:42 <obadz> foldl' is no longer in the prelude though
05:58:59 <ttt_fff> indiagreen: how do you go from Monad -> fmap ?
05:59:34 <cocreature> @src liftM
05:59:34 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
05:59:37 <cocreature> ^ like that
06:00:00 <obadz> ttt_fff: fmap f x = return $ x >>= f
06:00:17 <ttt_fff> cocreature , obadz: nice, thanks!
06:00:32 <indiagreen> er, wait, this shouldn't work
06:00:48 <indiagreen> x >>= return . f
06:00:54 <indiagreen> :t \f x -> return $ x >>= f
06:00:56 <lambdabot> (Monad m, Monad m1) => (a -> m1 b) -> m1 a -> m (m1 b)
06:01:09 <indiagreen> yeah
06:02:03 <obadz> yes sorry
06:02:10 <obadz> ttt_fff: fmap f x = x >>= (return . f)
06:02:22 <ttt_fff> yes yes, I get it now
06:02:29 <ttt_fff> I actually knew it before, but my brain was confused since it was 6:02am
06:02:36 <ttt_fff> and it's like "dude, you should sleep instead of coding ahskell"
06:02:47 <cocreature> maybe it's right :)
06:02:49 <obadz> no dude, you should code haskell instead of sleep.
06:02:54 <indiagreen> nope, we're going to continue with pasting different solutions
06:02:55 <ttt_fff> obadz++
06:03:12 * obadz error: object is immutable
06:04:26 <ttt_fff> should JavaScript be shortened as Js or JS ?
06:04:30 <cocreature> obadz & karma +~ 1
06:04:42 <ttt_fff> I feel JS is more appropriate, but Js makes it easier to read things like JsInt JsString JsIO instead of JSInt JSString JSIO
06:04:44 <clrnd> because of non strict you can actually code ahskel instead of sleep
06:05:08 <indiagreen> ttt_fff: go with Js
06:07:14 <lwm> srbh: https://github.com/ndmitchell/hoogle/issues/136
06:07:21 <lwm> srbh: I quoted you, hope you don't mind!
06:07:29 <lwm> erisco: you too!
06:07:41 <erisco> lwm, sorry what?
06:08:05 <obadz> Ironically, it looks like f <*> x = x >>= (f . return) -- so just reverse the args
06:08:11 <lwm> erisco: check the issue, something you said is in there
06:08:16 <lwm> just to let you know.
06:08:17 <obadz> I mean reverse the args to (.)
06:10:03 <obadz> No I have this wrong
06:11:10 <indiagreen> ah
06:11:19 <indiagreen> then fmap = ap return
06:11:21 <indiagreen> :t ap return
06:11:22 <lambdabot> (b -> a) -> b -> b
06:11:24 <indiagreen> no
06:11:33 <obadz> f <*> x = do { x' <- x; f' <- f; return (f' x') }
06:12:35 <indiagreen> aha
06:12:38 <indiagreen> :t ap . return
06:12:39 <lambdabot> Monad m => (a -> b) -> m a -> m b
06:12:43 <indiagreen> that's fmap
06:13:02 <indiagreen> ...why am I doing this instead of, like, something actually useful
06:13:26 <matsuura> maybe you like to waste time?
06:13:47 <indiagreen> matsuura++
06:13:51 * indiagreen quits
06:13:52 <obadz> f <*> x = x >>= \x' -> f >>= \f' -> return (f' x') -- written just with bind
06:15:01 <twb> Is there a way to tell cabal to try to install things with apt first?
06:15:29 <erisco> lwm, figure out how to make it profitable and I'm in
06:15:44 <twb> (I guess mixing cabal and apt is still a bad idea anyways, because diamond deps)
06:16:06 <obadz> twb: nixpkgs awaits you :)
06:16:32 <twb> hrmph, I've been avoiding that migration because I'm old and grumpy and set in my ways
06:17:13 <erisco> how about we charge $0.10 per example shown
06:17:15 <twb> Don't worry though because by tomorrow I'll be sober and have forgotten about my plan to rewrite all KDE's games in haskell
06:17:56 <erisco> with 1490 Haskell users, 99% idle, each viewing one example, we're already at $1.40!
06:18:16 <lwm> dammit man/woman, there is more to this than money!
06:18:28 <lwm> we need to beat the clojure community!
06:18:33 <twb> lwm: so fringe benefits?  Like a company porsche?
06:18:33 <lwm> our honour demands it!
06:18:46 <lwm> haha, I like your stats though
06:19:31 <lwm> maybe I should copy and paste those stats in to the issue.
06:19:54 <erisco> it is a good idea but those are already in abundance I am afraid
06:21:01 <lwm> well, I wanted to drag you all down in a blaze of unimplementable flames that this issue is inevitably going to end in.
06:23:45 <canard_> hey
06:25:24 <canard_> how can I combine Parsec's parsers to surround them by parens ?
06:26:54 <clrnd> like char '(' *> parser <* char ')' ?
06:27:01 <suppi> clrnd, he left
06:27:10 <suppi> but, using "parens", I think. 
06:27:12 <suppi> http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Token.html#v:parens
06:27:24 <clrnd> suppi, he left
06:27:26 <clrnd> :P
06:28:14 <suppi> :p
06:31:17 <catgocat> how can I shorten this: sumDigits x `compare` sumDigits y
06:31:26 <lwm> erison, twb: not a bad response on that issue
06:31:35 <lwm> erisco*
06:32:21 <catgocat_> hey how can I shorten this: f x `compare` f y
06:33:31 <Peaker> comparing f x y ?
06:33:43 <catgocat_> not in scope:
06:33:44 <catgocat_> comparing
06:34:03 <Peaker> from Data.Ord
06:40:09 <catgocat_> @pl cmp x y = comparing sumDigits x y <> compare x y
06:40:09 <lambdabot> cmp = ap (ap . ((<>) .) . comparing sumDigits) compare
06:44:58 <frerich> When I'm beginning to study the 'lens' package - http://3.bp.blogspot.com/-VzFi0T-XdmA/UJerpPpTHcI/AAAAAAAABJk/bgyufmDpa0E/s1600/cs.gif
06:47:21 <suppi> frerich, I'm trying out microlens instead :)
06:47:37 <aweinstock> catgocat_: (compare `on` sumDigits)?
06:47:50 <aweinstock> @src on
06:47:50 <lambdabot> (*) `on` f = \x y -> f x * f y
06:48:34 <catgocat_> aweinstock: I want to fallback to comparing them directly
06:48:37 <catgocat_> that's why I use <>
06:49:05 <catgocat_> @info on
06:49:05 <lambdabot> on
06:49:10 <catgocat_> :i on
06:49:12 <Intolerable> thanks lambdabot
06:49:22 <catgocat_> @type on
06:49:23 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
07:00:27 <clrnd> friden, that's remarkably accurate
07:00:38 <clrnd> I'm using lens-simple lately
07:12:06 <suppi> http://thread.gmane.org/gmane.comp.lang.haskell.ghc.devel/9466
07:12:11 <suppi> this looks amazing
07:12:17 <suppi> discussion please? :)
07:13:02 <Peaker> I have a simple line-based parsec parser. It should look something like:  file = many line <* eof ; line = skipSpaces *> (interestingPart <|> many notNewline) <* skipSpaces
07:13:02 <Peaker> this is a problem because "many line" complains (correctly) that "line" may accept the empty string
07:13:02 <Peaker> oops, I forgot that the end of line is either a "\n", or an eof..
07:13:02 <Peaker> perhaps sepBy is what I'm looking for here :)
07:13:22 <Peaker> but I can't have "line" consume the newline (the last line may have no newline), so I'd still have sepBy of a potentially empty line
07:14:06 <lwm> suppi: 7.12 !!!
07:14:31 <lwm> I love when I have no idea at all what the new features are
07:17:45 <aweinstock> Peaker: sepBy line (newline <|> eof)
07:19:06 <Peaker> aweinstock: ah cool, it doesn't mind if line is potentially empty
07:19:48 <Peaker> How does one go about "layered" parsers with parsec? Annotating SourcePos on everything manually and setSourcePos ?
07:22:36 <twb> Does RWH cover FRP at all?
07:22:47 <twb> I guess the GUI chapter
07:22:50 <srhb> twb: Not afaik.
07:23:14 <twb> OK
07:23:19 <srhb> twb: RWH is pretty dated. Even if it did it would not be representative of the state of the art.
07:23:34 <twb> Heh, OK
07:24:04 <twb> Although since my prod target is Debian stable, that might not be a problem :-)
07:38:57 <meditans> to anyone who used the hlint library: did you manage to parse successfully a file with `parseModuleEx`?
07:39:28 <meditans> I must be missing something obvious, because I continue getting ParseError
07:39:35 <meditans> maybe mpickering
07:39:56 <mpickering> hello
07:40:05 <mpickering> can you paste the file you are trying to parse?
07:40:21 <meditans> yeah, it's the lens-4.9 module
07:40:28 <mpickering> you can also try parsing it with "hlint hse <file.hs>" 
07:40:30 <meditans> just Control/Lens.hs
07:40:52 <mpickering> what is the parse error you are getting?
07:41:14 <meditans> So, the parse message is "Parse error: #"
07:41:42 <mpickering> ah you need to configure it to run CPP first
07:41:50 <meditans> the parseErrorContents is "    , module Control.Lens.Review\n    , module Control.Lens.Setter\n> #ifndef DISABLE_TEMPLATE_HASKELL\n    , module Control.Lens.TH\n  #endif\n"
07:41:55 <meditans> mpickering: how so?
07:43:19 <edwardk> meditans: look at github.com/ekmett/lens at tests/hlint.hs -- that uses the hlint library to parse all the lens files =)
07:43:24 <mpickering> by setting CppFlags in ParseOptions
07:43:40 <edwardk> but it cheats and just calls 'hlint'
07:44:48 <the_2nd> is there a method to check whether a value is between two others? or within a range?
07:44:53 <the_2nd> is x between 3 and 7
07:45:17 <the_2nd> x between a and b
07:45:25 <the_2nd> where i dont know whether a or b is the smaller
07:46:01 <the_2nd> in c++ i have ( (x > a && x < b) || (x < a && x > b))
07:46:46 <frerich> the_2nd: There is 'inRange', e.g.
07:46:52 <frerich> > inRange (3, 7) 5
07:46:54 <lambdabot>  True
07:47:06 <EvanR> > inRange (7, 3) 5
07:47:08 <lambdabot>  False
07:47:27 <EvanR> > inRange (min 7 3, max 7 3) 5
07:47:29 <lambdabot>  True
07:48:00 <the_2nd> EvanR, thanks
07:48:17 <frerich> > all (inRange (3, 7)) [3..7]
07:48:19 <lambdabot>  True
07:48:27 <frerich> Both bounds are included, it seems.
07:49:05 <EvanR> > all (inRange (0.0, 100.0)) [0.0 .. 100.0]
07:49:07 <lambdabot>      No instance for (Ix a0) arising from a use of ‘inRange’
07:49:07 <lambdabot>      The type variable ‘a0’ is ambiguous
07:49:07 <lambdabot>      Note: there are several potential instances:
07:50:14 <EvanR> inRange requires Ix where as the test still makes sense for floats (or does it)
07:50:57 <EvanR> the_2nd: note that ( (x > a && x < b) || (x < a && x > b)) as is
07:51:45 <the_2nd> EvanR, borders are of no concern
07:51:58 <Intolerable> :t \a b x -> if a > b then x > b && a > x else x > a && b > x
07:51:59 <lambdabot> Ord a => a -> a -> a -> Bool
07:52:31 <Intolerable> sub for >= as necessary
07:52:49 <itsu> guys, haskell beginner here. I have one question. Suppose I have: data Foo = Bar | Baz
07:52:54 <erisco> how do you determine if a Producer is empty i.e. not going to produce more values?
07:52:56 <erisco> (pipes)
07:53:02 <itsu> do I have any way to create a Foo dynamically ?
07:53:12 <itsu> without having to call Bar 
07:53:14 <itsu> or Baz
07:53:32 <srhb> itsu: What value should it have?
07:53:47 <EvanR> Bar and Baz are the only possible constructors, you have to use they at some point (* you can also use undefined)
07:53:55 <itsu> well my example is not perfect sorry. Say I have data Foo = Bar Bool | Baz String
07:54:01 <srhb> itsu: Right.
07:54:05 <srhb> itsu: Then what value should it have?
07:54:21 <itsu> hmm ? what do you mean ?
07:54:28 <srhb> You want to create it "dynamically"
07:54:39 <srhb> Which value should it have? One with the Bar constructor or one with the Baz constructor?
07:54:45 <itsu> yeah, I would like to do Foo "test" and it creates a Baz 
07:54:54 <EvanR> if dynamicTestFoo then Bar False else Baz "quux"
07:54:55 <srhb> No, that's wrong
07:54:59 <thewormkill> you need a constructor, itsu 
07:55:07 <Zekka> You can do what you're trying to do with typeclasses but you shouldn't do it that way
07:55:09 <thewormkill> Foo is just a type, not a possible value
07:55:12 <srhb> You can have a type class that exposes a function that does this
07:55:23 <EvanR> :(
07:55:24 <srhb> instance MakeFoo String where mkFoo = Baz
07:55:37 <srhb> instance MakeFoo Bool where mkFoo = Bar
07:55:44 <frerich> erisco: I suppose the producer could produce an 'EndOfInput' value to signal this condition.
07:56:20 <itsu> srhb: I see, I guess I could do it like that yeah :-)
07:56:22 <EvanR> itsu: depending on what youre really trying to do, the typeclass way could be abuse and theres a more obvious and better way
07:56:55 <srhb> itsu: It's way less useful than it might seem. :-)
07:57:19 <itsu> really ? how come ?
07:57:53 <EvanR> it doesnt end up being more dynamic than any other way to create a Foo
07:58:06 <srhb> You don't suddenly lose information on whether your user provided you with a Bool or a String, and after you've mkFoo'd it, you still need to know whether it's a Bool or a String
07:58:14 <EvanR> well, unless you use Dynamic, which would be wrong too
07:58:19 <srhb> (And if you DID lose this information, you're probably doing something wrong!)
07:58:33 <srhb> heh, I am too slow.
07:58:53 <srhb> Types are precious, cling to them for dear life. :)
07:59:03 <EvanR> at the point where you have to decide whether to make a Bar or Baz, you know whether you have a string or a bool to make it from
08:00:08 <itsu> Well I understand your points of view guys but what if Foo depends on some unknown input
08:00:28 <itsu> then with typeclasses I can dynamically instantiate the right type no ?
08:00:37 <EvanR> even if you parameterized everything in the program with MkFoo a =>, the top level would still have a String or a Bool
08:00:44 <EvanR> unknown input?
08:00:56 <srhb> If it's unknown, you can do nothing.
08:00:59 <EvanR> theres no such thing as input of an unknown type
08:01:11 <itsu> well, yeah... correct :-P
08:01:18 <srhb> Say the user inputs something. You then have a parser that spits out Either Bool String
08:01:21 <srhb> Or whatever.
08:01:26 <itsu> true
08:01:36 <srhb> Now you're just case matching off that, and you're done.
08:02:24 <EvanR> thats the big difference from dynamic-ish systems, in the dynamic system when you think or are told "could be anything" what they really mean is that its an arbitrary value of the one dynamic type, which is something like Foo or Either
08:02:34 <EvanR> but in haskell "could be anything" is way stronger
08:02:57 <notdan> tulcod: hi
08:03:19 <tulcod> notdan: hi! beer in the weeks?
08:03:30 <itsu> I guess I'm still thinking too much in term of OO :-(
08:03:44 <itsu> thank you EvanR and srhb ;-)
08:03:59 <EvanR> Any in OO is really Object which is not really "anything" ;)
08:04:08 <EvanR> its Object
08:04:46 <EvanR> it has some sort of baseline support, whereas something that isn't an Object doesn't
08:04:53 <asthasr> except null.
08:04:59 <asthasr> "Object | Null"
08:05:15 * EvanR headdesk
08:05:20 <Robot43> Hi guys ^_^ I was wondering if anyone has the paperback version of learn you a haskell, and could say whether it's as well formatted as the web edition?
08:05:28 <asthasr> and exceptions, which are a completely different return type that have to be intercepted specially.
08:05:41 <Robot43> The kindle preview on amazon has pretty bad formatting and I am wondering if this extends to the published book
08:05:44 <asthasr> "Object | Null | SpecialThingYouHaveToUseSpecialSyntaxForAndCannotIntrospect"
08:06:08 <hodapp> needs more Factory
08:06:17 <thewormkill> ^
08:07:14 <EvanR> data Any = Object RawActualObject | Null | Int
08:07:28 <EvanR> hifive java
08:07:53 <thewormkill> it's too syntactically clear
08:08:10 <aweinstock> EvanR: aren't floats/doubles primitive in java too?
08:08:19 <EvanR> yes, and chars, and bools
08:08:21 <EvanR> etc
08:09:18 <jcreekmore> Robot43: I have the paperback and it is formatted quite nicely.
08:09:20 <EvanR> https://hackage.haskell.org/package/java-bridge-0.20130606.3/docs/Foreign-Java-Value.html
08:10:21 <EvanR> data Value e a = Value a | NoValue | Fail e
08:10:26 <EvanR> True False FileNotFound
08:11:40 <EvanR> here are the java types https://hackage.haskell.org/package/java-bridge-0.20130606.3/docs/Foreign-Java-Bindings-JavaTypes.html 
08:11:50 <Robot43> jcreekmore: thanks! :)
08:12:18 <EvanR> arrays are a notable primitive
08:12:31 <asthasr> You know, I used to hate checked exceptions in Java -- until I worked with Nokogiri, a Ruby XML library that throws a parsing exception (i.e. the one that Ruby itself uses, that doesn't descend from StandardError) in userland code
08:13:38 <EvanR> in ruby you live and die by exceptions-for-control-flow
08:13:46 <EvanR> theres no other way
08:13:57 <Intolerable> eh, better than python
08:15:09 <atondwal> Anyone here used -xc for traces?
08:15:41 <hodapp> EvanR: you do? I've not used Ruby in forever
08:15:46 <erisco> frerich, but it doesn't
08:16:46 <erisco> there is pipes-parse but I'm not sure
08:16:56 <erisco> then one is working with StateT
08:17:51 <erisco> ah ha, of course
08:17:54 <erisco> Pipes.next
08:18:05 <erisco> that is what pipes-parser is using anyways
08:18:26 <erisco> and I've used this myself so, great
08:21:16 * hackagebot purescript 0.7.4.1 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.7.4.1 (PhilFreeman)
08:29:35 <xandaros> I have a somewhat large sum type, where each constructor corresponds to an int (enum-ish). The integers, however, don't necessarily start at 0 and are not continuous. How do I best (and performant) translate between these two views?
08:33:46 <athan> xandaros: So, peano numbers / natural numbers are like strictly positive integers
08:34:06 <athan> we can get around designing their data type by counting the number of wrappers around zero:
08:34:14 <xandaros> ...
08:34:15 <athan> data Nat = Zero | Succ Nat
08:34:30 <erisco> newtype on Int and unsafeCoerce
08:34:53 <athan> That's one way to make /discrete/ positive integers, where they start at 0
08:35:45 <athan> my bad
08:36:19 <xandaros> Well, I have a sum type: http://hastebin.com/ikibusivex.hs Each of these constructors represents an int... weirdly: 1,3,4,5,7,8,11,12,14,15,17,20,35,39 and 60...
08:36:19 <aweinstock> athan: I think by "the integers", xandaros meant "the specific integers I'm using"
08:36:20 * hackagebot amazonka-core 1.2.0.1 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.2.0.1 (BrendanHay)
08:36:22 * hackagebot amazonka 1.2.0.1 - Comprehensive Amazon Web Services SDK  https://hackage.haskell.org/package/amazonka-1.2.0.1 (BrendanHay)
08:36:24 * hackagebot amazonka-config 1.2.0.1 - Amazon Config SDK.  https://hackage.haskell.org/package/amazonka-config-1.2.0.1 (BrendanHay)
08:36:26 * hackagebot amazonka-sns 1.2.0.1 - Amazon Simple Notification Service SDK.  https://hackage.haskell.org/package/amazonka-sns-1.2.0.1 (BrendanHay)
08:36:28 * hackagebot amazonka-sqs 1.2.0.1 - Amazon Simple Queue Service SDK.  https://hackage.haskell.org/package/amazonka-sqs-1.2.0.1 (BrendanHay)
08:36:37 <erisco> chill out hackagebot
08:37:01 <erisco> xandaros, didn't like my suggestion?
08:37:12 <xandaros> I'm not sure how that works
08:37:35 <erisco> hold on, this isn't an enum
08:37:43 <erisco> you've got data in there
08:37:52 <xandaros> "enum-ish"
08:38:03 <erisco> also how do you go from 11 to one of those constructors?
08:38:17 <blapzal> What does => mean in a type annotation?
08:38:25 <voidzero> 'is a member of class'
08:38:28 <erisco> blapzal, context => type
08:38:33 <blapzal> alright thanks
08:38:43 <darenthis> Is there a way to force a library to ignore its version restrictions? I'm trying to use netwire with LTS Haskell but it wants profunctor < 5 and LTS has profunctor = 5.1.1
08:38:56 <xandaros> erisco: What do you mean by that?
08:39:02 <erisco> you said it
08:39:24 <erisco> "I have a somewhat large sum type, where each constructor corresponds to an int (enum-ish). The integers, however, don't necessarily start at 0 and are not continuous. How do I best (and performant) translate between these two views?"
08:39:36 <erisco> so how do you go from 11, which is one of the integers, to one of the constructors?
08:39:44 <xandaros> Well, that is my question
08:39:54 <erisco> but it doesn't make sense because there is extra data
08:39:56 <athan> aweinstock: :x
08:40:02 <erisco> say 11 corresponds to MaxAge
08:40:04 <xandaros> ah, good point
08:40:07 <erisco> okay, where do you get the Word32 from?
08:41:03 <xandaros> Yeah, going from Int to OptionValue will need to be very explicit, I can see that
08:41:30 * hackagebot amazonka-glacier 1.2.0.1 - Amazon Glacier SDK.  https://hackage.haskell.org/package/amazonka-glacier-1.2.0.1 (BrendanHay)
08:41:32 * hackagebot amazonka-cloudhsm 1.2.0.1 - Amazon CloudHSM SDK.  https://hackage.haskell.org/package/amazonka-cloudhsm-1.2.0.1 (BrendanHay)
08:41:34 <xandaros> What about the other way around, though?
08:41:34 * hackagebot amazonka-datapipeline 1.2.0.1 - Amazon Data Pipeline SDK.  https://hackage.haskell.org/package/amazonka-datapipeline-1.2.0.1 (BrendanHay)
08:41:36 * hackagebot amazonka-iam 1.2.0.1 - Amazon Identity and Access Management SDK.  https://hackage.haskell.org/package/amazonka-iam-1.2.0.1 (BrendanHay)
08:41:38 * hackagebot amazonka-route53-domains 1.2.0.1 - Amazon Route 53 Domains SDK.  https://hackage.haskell.org/package/amazonka-route53-domains-1.2.0.1 (BrendanHay)
08:43:52 <athan> edwardk: Do you think `guardedBy` would be important enough for base?
08:44:03 <dzhus> Can a single conduit source be fed to multiple sinks?
08:44:21 <athan> your comments seemed reluctant, but at least slightly positive toward it's use cases
08:45:21 <erisco> xandaros, maybe there is a way to do this but it seems complicated
08:45:40 <erisco> having a hard time w/o dependent typing
08:46:09 <xandaros> k... lots of pattern matches, it is
08:46:30 <erisco> I don't know where you're getting the extra data from anyways
08:46:34 <erisco> so I am not sure what to do 
08:46:40 * hackagebot amazonka-directconnect 1.2.0.1 - Amazon Direct Connect SDK.  https://hackage.haskell.org/package/amazonka-directconnect-1.2.0.1 (BrendanHay)
08:46:41 <xandaros> parsed out of a bytestring
08:46:42 * hackagebot amazonka-devicefarm 1.2.0.1 - Amazon Device Farm SDK.  https://hackage.haskell.org/package/amazonka-devicefarm-1.2.0.1 (BrendanHay)
08:46:44 * hackagebot amazonka-cognito-sync 1.2.0.1 - Amazon Cognito Sync SDK.  https://hackage.haskell.org/package/amazonka-cognito-sync-1.2.0.1 (BrendanHay)
08:46:46 * hackagebot amazonka-elb 1.2.0.1 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elb-1.2.0.1 (BrendanHay)
08:46:48 * hackagebot amazonka-cloudformation 1.2.0.1 - Amazon CloudFormation SDK.  https://hackage.haskell.org/package/amazonka-cloudformation-1.2.0.1 (BrendanHay)
08:46:53 <xandaros> so that direction will have to be manual in any case
08:46:56 <erisco> that isn't what I mean
08:47:07 <erisco> when you're trying to construct with an Int
08:47:18 <erisco> you're basically saying that depending on the value of the Int you need different data types
08:47:18 <xandaros> "so that direction will have to be manual in any case"
08:47:24 <erisco> such as Text or ByteString or Word16
08:47:30 <erisco> but we can't do this
08:49:04 <erisco> as far as just the label you can probably do this http://lpaste.net/139787
08:49:36 <erisco> fromInt :: Int -> OptionLabel; fromInt = unsafeCoerce
08:49:39 <erisco> it is the yolo definition
08:50:15 <xandaros> Yeah, that doesn't really help... at all :D
08:50:32 <erisco> yes it does
08:51:02 <erisco> it gives you fast Int -> OptionLabel and fast OptionLabel -> Int
08:51:06 <xandaros> I'll just have a big lookup function for both directions
08:51:06 <erisco> it is a noop
08:51:20 <xandaros> Yes, but only as powerful as the int itself
08:51:33 <erisco> ?
08:51:36 <xandaros> doesn't add any meaning to it, just encapsulates it
08:51:37 <aweinstock> erisco: but it's UNSAFE and could lead to out-of-bounds reads?
08:51:50 * hackagebot amazonka-sts 1.2.0.1 - Amazon Security Token Service SDK.  https://hackage.haskell.org/package/amazonka-sts-1.2.0.1 (BrendanHay)
08:51:52 * hackagebot amazonka-kinesis 1.2.0.1 - Amazon Kinesis SDK.  https://hackage.haskell.org/package/amazonka-kinesis-1.2.0.1 (BrendanHay)
08:51:54 * hackagebot amazonka-cloudsearch-domains 1.2.0.1 - Amazon CloudSearch Domain SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-domains-1.2.0.1 (BrendanHay)
08:51:56 * hackagebot amazonka-cloudwatch 1.2.0.1 - Amazon CloudWatch SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-1.2.0.1 (BrendanHay)
08:51:58 * hackagebot amazonka-cloudtrail 1.2.0.1 - Amazon CloudTrail SDK.  https://hackage.haskell.org/package/amazonka-cloudtrail-1.2.0.1 (BrendanHay)
08:52:01 <erisco> aweinstock, OptionLabel is a newtype for Int
08:52:27 <aweinstock> oh, ok (I thought you were talking about a sum type declared via data)
08:52:28 <erisco> you can also just call the OptionLabel constructor
08:52:30 <erisco> if you want to be sane
08:53:34 <erisco> xandaros, okay I dunno man, I don't understand then
08:54:22 <xandaros> As I said, I'll just do a big lookup function
08:54:33 <xandaros> at least for OptionValue -> Int
08:55:08 <erisco> add an Int field to every constructor
08:55:13 <erisco> then project it out
08:56:37 <xandaros> I might end up doing that, but I don't like it. The constructor already holds that information, the Int would be redundant
08:57:00 * hackagebot amazonka-elasticache 1.2.0.1 - Amazon ElastiCache SDK.  https://hackage.haskell.org/package/amazonka-elasticache-1.2.0.1 (BrendanHay)
08:57:02 * hackagebot amazonka-importexport 1.2.0.1 - Amazon Import/Export SDK.  https://hackage.haskell.org/package/amazonka-importexport-1.2.0.1 (BrendanHay)
08:57:04 * hackagebot amazonka-s3 1.2.0.1 - Amazon Simple Storage Service SDK.  https://hackage.haskell.org/package/amazonka-s3-1.2.0.1 (BrendanHay)
08:57:06 * hackagebot amazonka-swf 1.2.0.1 - Amazon Simple Workflow Service SDK.  https://hackage.haskell.org/package/amazonka-swf-1.2.0.1 (BrendanHay)
08:57:08 * hackagebot amazonka-sdb 1.2.0.1 - Amazon SimpleDB SDK.  https://hackage.haskell.org/package/amazonka-sdb-1.2.0.1 (BrendanHay)
09:00:15 <twb> Never mind, I worked it out.  cabal install -f '-wiimote -kinect' haskanoid
09:00:25 <ocharles__> Hmm, I wonder if GHCI will ever truly get to the state of a lisp REPL. Something that comes to mind is "main = forever (threadDelay 1000000 >> doSomething)" and then redefining what 'doSomething' is
09:00:47 <ocharles__> afaik, there is no way to run 'main' once, and change what 'doSomething' is throughout the lifetime of 'main' (and have main use the latest definition)
09:01:01 <ocharles__> you have to shove things in and out of IORefs and (ab)use foreign-store
09:01:01 <twb> Aw, it doesn't start with no sound card
09:01:04 <geekosaur> there isn't in haskell
09:01:10 <geekosaur> did you want a different language?
09:01:33 <ocharles__> geekosaur: what that a question for me?
09:01:35 <ocharles__> was*
09:01:53 <geekosaur> yes. are you really suggesting that ghci should be mutable by default?
09:02:04 <srhb> I feel like this can be solved with better abstractions over the IORefs where needed, without ruining the language as it would do to allow doSomething to mutate
09:02:10 * hackagebot amazonka-codecommit 1.2.0.1 - Amazon CodeCommit SDK.  https://hackage.haskell.org/package/amazonka-codecommit-1.2.0.1 (BrendanHay)
09:02:12 * hackagebot amazonka-codedeploy 1.2.0.1 - Amazon CodeDeploy SDK.  https://hackage.haskell.org/package/amazonka-codedeploy-1.2.0.1 (BrendanHay)
09:02:14 * hackagebot amazonka-cloudfront 1.2.0.1 - Amazon CloudFront SDK.  https://hackage.haskell.org/package/amazonka-cloudfront-1.2.0.1 (BrendanHay)
09:02:16 * hackagebot amazonka-efs 1.2.0.1 - Amazon Elastic File System SDK.  https://hackage.haskell.org/package/amazonka-efs-1.2.0.1 (BrendanHay)
09:02:18 * hackagebot amazonka-codepipeline 1.2.0.1 - Amazon CodePipeline SDK.  https://hackage.haskell.org/package/amazonka-codepipeline-1.2.0.1 (BrendanHay)
09:02:22 <ocharles__> geekosaur: I am suggesting that GHCI should facilitate truly interactive programming
09:02:31 <thatguy> what is better when using for example reduce instead of a normal while/for loop?
09:02:48 <srhb> thatguy: while is pretty terrible wrt bounds and such
09:02:49 <ocharles__> right, I'm not literally suggesting mutation, but what I mentioned above is the type of flow I'd like to be able to have in development
09:03:11 <bearbite> ocharles__: you want the stuff Marlow's people did
09:03:19 <ocharles__> i'm not sure I do
09:03:21 <srhb> thatguy: foreach is closer, but still allows too much for most of its scope
09:03:33 <ocharles__> bearbite: but it's along the right lines
09:03:34 <illabout> ocharles__, that would be really neat.  a lot of people brought that up as a good point of clojure in the "what do clojure uses think of Haskell" thread on reddit.
09:04:03 <ocharles__> yea, i'm definitely agree with them - having worked in both languages
09:04:09 <bearbite> ocharles__: well, in terms of what's closest to being usable. And I've seen game devs do like what FB did.
09:04:20 <ocharles__> ghci is fine for "does this work", but it is miles away from being an interactive development environment
09:04:27 <ocharles__> bearbite: in haskell?
09:04:38 <ocharles__> i know someone has some sort of hot reloading thing, I should dig that out and see what magic they are doing
09:05:13 <srhb> If you could some way autotransform your whole code to be suddenly in IORefs and magically work with that, we'd be done I guess
09:05:21 <srhb> liftToMutable
09:05:22 <ocharles__> ah, halive - https://github.com/lukexi/halive
09:05:24 <srhb> :P
09:05:40 <ocharles__> srhb: well GHC does have support for preprocessors, so you might actually be on to something
09:06:16 <srhb> ocharles__: I'm having trouble visualizing how it could be done in any automatic way for ANY program, but that may just be me being typically uncreative :-)
09:06:17 <ocharles__> but i dunno, this really should eventually be able to reach a status above being a hack :)
09:06:22 <srhb> And yes, agreed.
09:06:28 <srhb> It would be ridiculously cool.
09:06:49 <xandaros> erisco: I think I'll try a typeclass instead of a sum type, that might work... next week
09:07:20 * hackagebot amazonka-elasticbeanstalk 1.2.0.1 - Amazon Elastic Beanstalk SDK.  https://hackage.haskell.org/package/amazonka-elasticbeanstalk-1.2.0.1 (BrendanHay)
09:07:22 * hackagebot amazonka-autoscaling 1.2.0.1 - Amazon Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-autoscaling-1.2.0.1 (BrendanHay)
09:07:23 <athan> ocharles__: Thanks for defending `returnWhen` on reddit! :)
09:07:24 * hackagebot amazonka-ses 1.2.0.1 - Amazon Simple Email Service SDK.  https://hackage.haskell.org/package/amazonka-ses-1.2.0.1 (BrendanHay)
09:07:26 * hackagebot amazonka-support 1.2.0.1 - Amazon Support SDK.  https://hackage.haskell.org/package/amazonka-support-1.2.0.1 (BrendanHay)
09:07:28 * hackagebot amazonka-dynamodb-streams 1.2.0.1 - Amazon DynamoDB Streams SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-streams-1.2.0.1 (BrendanHay)
09:07:30 <ocharles__> athan: welcome :)
09:08:03 <meditans> mpickering: ok, in the end I parsed the file I needed, but when I delve in the Module structure
09:08:20 <athan> ocharles__: Did you like the predicate version Edward suggested? `guardedBy :: Alternative f => (a -> Bool) -> a -> f a`?
09:08:47 <meditans> mpickering: I found only AnnPragma. Now, I'm interested in the types of the functions: is it possible that hlint doesn't return those in a useful format?
09:09:59 <xandaros> what's return when?
09:10:29 <ocharles__> athan: Hmm, hard to think of actual times I've wanted returnWhen and exactly what I had on hand
09:10:30 <meditans> edwardk: thanks, I saw your use of hlint, and I will incorporate it in my future tests. Unfortunately, I was trying to get the types of the function in a package, and kinda hoped I found an already existing solution
09:10:45 <ocharles__> athan: but i wouldn't be unhappy if we got that instead
09:10:50 <meditans> (the types of all the functions)*
09:12:30 * hackagebot amazonka-redshift 1.2.0.1 - Amazon Redshift SDK.  https://hackage.haskell.org/package/amazonka-redshift-1.2.0.1 (BrendanHay)
09:12:32 * hackagebot amazonka-opsworks 1.2.0.1 - Amazon OpsWorks SDK.  https://hackage.haskell.org/package/amazonka-opsworks-1.2.0.1 (BrendanHay)
09:12:34 * hackagebot amazonka-emr 1.2.0.1 - Amazon Elastic MapReduce SDK.  https://hackage.haskell.org/package/amazonka-emr-1.2.0.1 (BrendanHay)
09:12:35 <athan> ocharles__: Okay cool, I'm just trying to get all perspectives on it. Thank you :)
09:12:36 * hackagebot amazonka-cognito-identity 1.2.0.1 - Amazon Cognito Identity SDK.  https://hackage.haskell.org/package/amazonka-cognito-identity-1.2.0.1 (BrendanHay)
09:12:38 * hackagebot amazonka-ssm 1.2.0.1 - Amazon Simple Systems Management Service SDK.  https://hackage.haskell.org/package/amazonka-ssm-1.2.0.1 (BrendanHay)
09:15:41 <erisco> people complain about error novels in C++
09:15:44 <erisco> I wonder if they've used pipes
09:16:46 <pyon> erisco: Even with annotated type signatures, are the errors bad? :-O
09:17:40 * hackagebot amazonka-ml 1.2.0.1 - Amazon Machine Learning SDK.  https://hackage.haskell.org/package/amazonka-ml-1.2.0.1 (BrendanHay)
09:17:42 * hackagebot amazonka-workspaces 1.2.0.1 - Amazon WorkSpaces SDK.  https://hackage.haskell.org/package/amazonka-workspaces-1.2.0.1 (BrendanHay)
09:17:45 * hackagebot amazonka-dynamodb 1.2.0.1 - Amazon DynamoDB SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-1.2.0.1 (BrendanHay)
09:17:47 * hackagebot amazonka-rds 1.2.0.1 - Amazon Relational Database Service SDK.  https://hackage.haskell.org/package/amazonka-rds-1.2.0.1 (BrendanHay)
09:17:49 * hackagebot amazonka-ds 1.2.0.1 - Amazon Directory Service SDK.  https://hackage.haskell.org/package/amazonka-ds-1.2.0.1 (BrendanHay)
09:18:45 <erisco> I haven't gotten the types right once for pipes
09:18:48 <erisco> very hard to use
09:22:51 * hackagebot amazonka-cloudwatch-logs 1.2.0.1 - Amazon CloudWatch Logs SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-logs-1.2.0.1 (BrendanHay)
09:22:53 * hackagebot amazonka-route53 1.2.0.1 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-1.2.0.1 (BrendanHay)
09:22:55 * hackagebot amazonka-cloudsearch 1.2.0.1 - Amazon CloudSearch SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-1.2.0.1 (BrendanHay)
09:22:57 * hackagebot amazonka-storagegateway 1.2.0.1 - Amazon Storage Gateway SDK.  https://hackage.haskell.org/package/amazonka-storagegateway-1.2.0.1 (BrendanHay)
09:22:59 * hackagebot amazonka-ec2 1.2.0.1 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-1.2.0.1 (BrendanHay)
09:25:10 <catgocat> Do you guys help with the NICTA course?
09:25:20 <catgocat> I am trying to do it on my own and I'm affraid I will not be able to do it
09:25:48 <erisco> I don't do homework, I've got parties to go to
09:26:03 <greves> so servant is basically for REST APIs, right?
09:26:16 <greves> is there a web server that's the node equivalent of express or koa?
09:28:01 * hackagebot amazonka-kms 1.2.0.1 - Amazon Key Management Service SDK.  https://hackage.haskell.org/package/amazonka-kms-1.2.0.1 (BrendanHay)
09:28:03 * hackagebot amazonka-elastictranscoder 1.2.0.1 - Amazon Elastic Transcoder SDK.  https://hackage.haskell.org/package/amazonka-elastictranscoder-1.2.0.1 (BrendanHay)
09:28:05 * hackagebot amazonka-lambda 1.2.0.1 - Amazon Lambda SDK.  https://hackage.haskell.org/package/amazonka-lambda-1.2.0.1 (BrendanHay)
09:28:07 * hackagebot amazonka-ecs 1.2.0.1 - Amazon EC2 Container Service SDK.  https://hackage.haskell.org/package/amazonka-ecs-1.2.0.1 (BrendanHay)
09:28:09 * hackagebot cryptonite 0.7 - Cryptography Primitives sink  https://hackage.haskell.org/package/cryptonite-0.7 (VincentHanquez)
09:28:17 <athan> greves: There are a ton
09:28:28 <greves> any recommendations?
09:28:33 <athan> Have you seen Scotty? It's a lot like sinatra
09:28:46 <athan> there's also Spock, which has more care toward authentication and type safety
09:28:58 <srhb> catgocat: While some people recommend against the channel, a lot of people in #haskell-beginners also do NICTA, so they might be helpful.
09:29:11 <athan> I made one, too - Nested-Routes - for even more precision in your routing
09:29:20 <catgocat> I have already asked for help there
09:29:24 <catgocat> but they don't seem to be very active
09:29:28 <catgocat> at least not in my timezone
09:29:42 <srhb> catgocat: It varies based on time, indeed. Did you ask about something concrete, or just some kind of declaration of future help?
09:29:49 <srhb> I imagine the latter will not be very effective. :-)
09:29:56 <athan> greves: WAI is actually the equivalent to Connect
09:29:57 <greves> i'm not familiar with sinatra as i don't do ruby
09:30:14 <bitemyapp> athan: I always thought of it as being like Rack.
09:30:23 <bitemyapp> did the Ruby community get ahead of me since I last dipped in or what?
09:30:24 <greves> web frameworks i know django and node express/koa/hapi
09:30:29 <athan> greves: You declare your routes with string variables - like `get "foo/bar/:var:" or something
09:30:58 <athan> bitemyapp: Oh, Connect is node.js :)
09:30:59 <catgocat> srhb maybe
09:31:01 <bitemyapp> wai is a bit like wsgi as well.
09:31:04 <athan> the underbelly for Express
09:31:06 <bitemyapp> athan: oh right, whatever.
09:31:12 <erisco> okay finally
09:31:16 <bitemyapp> cool kids and their jay-esses
09:31:23 <erisco> do monad transformers ever become easier? jeepers
09:31:24 <athan> bitemyapp: Javascript.js
09:31:26 <greves> hmm
09:31:26 <srhb> catgocat: Well, feel free to pose concrete questions there or here.
09:31:30 <bitemyapp> erisco: yes
09:31:39 <bitemyapp> erisco: what's causing you friction?
09:31:45 <erisco> monad transformers
09:31:45 <athan> erisco: We need co-lift
09:31:47 <erisco> wasn't I clear?
09:31:57 <greves> i would basically just want something that uses middleware similar to koa, if you know that
09:32:07 <bitemyapp> erisco: that was an invitation to paste :P
09:32:10 <greves> it's my fav web server at the moment but want to try something in haskell just for a learning
09:32:11 <athan> erisco: mtl-style contextual induction over stacks ftw
09:32:12 <greves> -a
09:32:24 <athan> I don't :\
09:32:36 <athan> greves: Go with scotty! It's pretty easy :)
09:32:36 <greves> do you know express?
09:32:59 <bitemyapp> greves: Koa's stuff sounds like typical web app monad / WAI middleware stuff.
09:33:17 <greves> yeah, probably - i dont know WAI though just looking all of these up now
09:33:37 <greves> obviously there is a star trek theme going with the scotty/spock thing but trying to see what the differences are
09:33:41 <bitemyapp> greves: usually the simplest thing if you want a function that monkeys around with the web app stuff is to have it live in whatever app/handler monad your stack uses or make it WAI middleware (takes app as an argument, returns a new app, potentially different in behavior)
09:34:40 <codedmart> greves: Sorry trying to read backlog but I know express/koa.
09:35:13 <greves> codedmart: so which of those 2 would you say is more similar
09:35:20 <greves> those 2 = spock/scotty
09:35:31 <greves> or neither :P
09:36:06 <greves> and yesod seems to be a popular one, no?
09:36:17 <athan> greves: The primer server is called Warp :0
09:36:19 <codedmart> greves: Well scotty more for it being more minimalistic then spock, but they are both sinatraesque.
09:36:25 <athan> yesod is like Rails
09:37:29 <codedmart> greves: Spock started out from Scotty, but removed all traces of Scotty once they were able to. Spock provides more out of the box then Scotty, but you could get the same with Scotty using middleware.
09:38:22 <greves> oh ok
09:38:42 <greves> interesting so those 2 and yesod are all similar to ruby servers, which i know nothing about :P
09:38:59 <codedmart> Well express was modeled after sinatra.
09:39:08 <codedmart> So similar ideas
09:39:23 <greves> oh ok
09:39:38 <greves> so yesod is more like "batteries included" kind of thing, yeah?
09:39:44 <codedmart> Yeah
09:39:57 <greves> do all of these play nice with websockets?
09:40:53 <erisco> bitemyapp, you're too late
09:41:27 <codedmart> greves: I have used websockets with wai, but not scotty or spock directly. I know yesod has websockets capabilities as well.
09:41:42 <codedmart> So most likely yes they do.
09:43:02 <greves> ok
09:43:05 <athan> greves: Be prepared to code :)
09:43:09 <greves> i'll do some reading then, thanks ;)
09:43:12 <athan> er, typecheck
09:43:35 <greves> athan well, i'm still learning haskell - haven't written much at all yet in it so i figure this will be a good project to learn the language
09:43:36 <greves> :)
09:44:37 <erisco> bitemyapp, do you know pipes a bit?
09:44:42 <erisco> because any pointers would help
09:44:45 <erisco> I know I am doing it all wrong
09:44:58 <codedmart> greves: Good luck! bitemyapp has an awesome book I am reading through now. Highly recommend it.
09:45:18 <greves> bitemyapp is the author?
09:45:19 <bitemyapp> erisco: yes, later.
09:45:23 <bitemyapp> greves: yes
09:45:26 <bitemyapp> and my coauthor Julie
09:45:31 <bitemyapp> http://haskellbook.com/
09:45:35 <R0b0t1> Can there be a type of all types which don't contain themselves?
09:45:36 <greves> oh nice
09:46:45 <erisco> bitemyapp, well I might know pipes by later too
10:01:27 <erisco> (MonadCatch (Producer (Either (DecodeError m) Text) m), MonadIO m, Exception e) =>
10:01:27 <erisco>                 Handle -> Producer (Either (DecodeError m) Text) m (Either e ())
10:01:43 <erisco> don't worry because the types "just work"
10:02:05 <mauke> needs more profunctors
10:03:53 <aweinstock> erisco: type-alias (Producer (Either (DecodeError m) Text) m) to something shorter?
10:04:55 <aweinstock> (since it appears multiple times in the signature)
10:05:12 <erisco> :t join :: Either a (Either b c) -> Either b c
10:05:13 <lambdabot>     Couldn't match type ‘a1’ with ‘b1’
10:05:13 <lambdabot>       ‘a1’ is a rigid type variable bound by
10:05:13 <lambdabot>            an expression type signature:
10:06:00 <erisco> oh I see what it did, silly ghc
10:06:27 <erisco> of course if 'a' is type classed it won't care, it will just add that as a constraint
10:06:54 <erisco> :t join :: (Functor a) => Either a (Either b c) -> Either b c
10:06:55 <lambdabot>     Expecting one more argument to ‘a’
10:06:55 <lambdabot>     The first argument of ‘Either’ should have kind ‘*’,
10:06:55 <lambdabot>       but ‘a’ has kind ‘* -> *’
10:07:00 <erisco> right right
10:07:09 <erisco> :t join :: (Monoid a) => Either a (Either b c) -> Either b c
10:07:11 <lambdabot>     Couldn't match type ‘a1’ with ‘b1’
10:07:11 <lambdabot>       ‘a1’ is a rigid type variable bound by
10:07:11 <lambdabot>            an expression type signature:
10:07:14 <erisco> oh come on
10:07:20 <erisco> well something like this is happening
10:07:44 <erisco> :t join :: (Monoid a) => Either a (Either Int c) -> Either Int c
10:07:46 <lambdabot>     Couldn't match type ‘a1’ with ‘Int’
10:07:46 <lambdabot>       ‘a1’ is a rigid type variable bound by
10:07:46 <lambdabot>            an expression type signature:
10:08:05 <erisco> what in the actual
10:08:44 <mauke> join :: m (m a) -> m a, not m' (m a) -> m a
10:10:07 <aweinstock> :t join :: Either a (Either a b) -> Either a b
10:10:08 <lambdabot> Either a (Either a b) -> Either a b
10:10:27 <erisco> why is this happening
10:11:25 <arkeet> :t return :: b -> Either a b
10:11:26 <lambdabot> b -> Either a b
10:11:35 <arkeet> > (return :: b -> Either Int b) 0
10:11:37 <lambdabot>  Right 0
10:11:41 <arkeet> oh yeah.
10:11:49 <arkeet> brain not working oops.
10:13:23 <erisco> it is the fact I am annotating it
10:13:59 <erisco> :t join :: (Monoid Int) => Either Int (Either Int c) -> Either Int c
10:14:00 <lambdabot>     No instance for (Monoid Int)
10:14:00 <lambdabot>       arising from an expression type signature
10:14:00 <lambdabot>     In the expression:
10:14:09 <erisco> well fine, ghci doesn't complain for this though
10:14:20 <erisco> but whatever, that is the point
10:14:53 <erisco> you've got something where the variable is still free to pick, so it picks a = Int
10:14:57 <erisco> then adds the constraint Monoid Int
10:15:17 <erisco> which is not actually satisfiable but it might not tell you :P
10:21:32 <erisco> okay well this is a pain
10:21:34 <erisco> :t try
10:21:35 <lambdabot> Exception e => IO a -> IO (Either e a)
10:21:43 <erisco> see, what Exception type will this be
10:21:46 <erisco> I don't get it
10:24:03 <aweinstock> erisco: I think it's the callee's choice?
10:24:06 <barrucadu> Whatever you need it to be. If GHC can't figure it out from the context, it'll ask you for a type signature.
10:24:08 <d-snp> is the C-- compiler written in haskell?
10:24:22 <erisco> how can it be whatever I want it to be
10:24:25 <barrucadu> If the wrapped `IO a` throws an exception of a different type, then `try` won't catch it
10:24:48 <erisco> what? geezus
10:24:58 <shachaf> The Cmm compiler is.
10:25:10 <barrucadu> You can use the `SomeException` type to match all exceptions
10:25:44 <d-snp> thanks shachaf I'll try and find out how I get it :P
10:26:37 <erisco> but I can't know what kind of exceptions will be thrown
10:26:52 <athan> d-snp: Check out comp-cert if you want to see a sweet C compiler :)
10:26:53 * erisco sighs
10:27:07 <barrucadu> Ideally if a thing might throw exceptions, the documentation will tell you which ones
10:27:12 * barrucadu doesn't like exceptions
10:27:15 <shachaf> d-snp: With GHC.
10:27:47 <d-snp> shachaf: it's in the main ghc.git right?
10:27:49 <erisco> Java might actually do this better
10:29:03 <d-snp> yes java does it better
10:29:34 <d-snp> it's the most crazy thing in haskell, a real wart if you ask me
10:30:11 <d-snp> it's also one of Javas best features, C# not including it was a populist move
10:30:14 <d-snp> so there, opinions :D
10:32:33 <erisco> I don't like exceptions either but that is what IO gives you
10:32:39 <erisco> I am going to guess these are all IOException or something
10:32:44 <erisco> then I don't have to deal with any other types
10:32:45 <erisco> I hope
10:33:48 <erisco> why are there all these exception types though? who is actively making libs that use this exceptions thing
10:35:11 <erisco> data NonTermination
10:35:15 <erisco> like, when is that thrown
10:35:38 <erisco> I see some MVar things
10:35:49 <greves> stack installs ghc locally... why?
10:35:54 <glguy> erisco: https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Exception-Base.html#t:NonTermination
10:36:02 <greves> if i have 10 projects with the same version of ghc, then i'm installign the same ghc 10 times
10:36:11 <erisco> glguy, that is straight where I copied it from thanks
10:36:18 <aweinstock> erisco: probably when it enters a detectible deadlock?
10:36:22 <Ankhers> greves: I'm pretty sure it doesn't install it per project.
10:36:26 <greves> oh ok
10:36:37 <greves> oh i see it installs in user directory
10:36:38 <greves> nvm then ;)
10:36:47 <erisco> you just need a sandbox per project
10:36:51 <erisco> so, kind of like installing 10 times
10:36:56 <Ankhers> greves: I believe it gets installed in $HOME/.stack/bin/something
10:37:13 <Ankhers> erisco: stack doesn't use sandboxes that way.
10:37:20 <Ankhers> erisco: Wrong person.
10:37:31 <Ankhers> no, I was right.
10:38:05 <Ankhers> erisco: Stack doesn't create a sandbox per project like cabal does. Stack creates a sandbox per lts-haskell version.
10:38:06 <glguy> erisco: If you want to catch all the exceptions you can catch "SomeException"
10:38:25 <glguy> otherwise they are individual types so that you can catch only the exceptions you meant to
10:38:28 <erisco> but then I don't know anything about the exception
10:38:35 <erisco> I am guessing that is what you get the Typeable for
10:38:41 <erisco> but it seems hickly pickly
10:38:43 <meoblast001> hi. is it possible to reupload a version to hackage? mainly just the cabal file
10:38:44 <erisco> that is my new phrase
10:38:55 <meoblast001> no idea how but the homepage field got removed in the latest version of my package
10:38:57 <glguy> If you wanted to do something special depeneding on the type of the exception you'd have caught that type
10:39:18 <glguy> catches :: IO a -> [Handler a] -> IO a
10:39:34 <glguy> You can have many handlers if you want to do different things for different exceptions
10:39:37 <erisco> I think our expectations are misaligned
10:39:39 <Ankhers> meoblast001: I want to say yes, but I don't know for sure. I remember hearing something about it before hackage 2 came out.
10:39:44 <aweinstock> erisco: is there something specific that throws an exception that you're currently wondering about?
10:40:03 <erisco> yeah, any IO action such as openFile
10:40:11 <erisco> or reading from a file
10:40:51 <Ankhers> meoblast001: You may need to create a new version though.
10:41:04 <breadmonster> Hey everyone.
10:41:05 <meoblast001> if that's the case then i'll just patch the problem in the next version
10:41:39 <alpounet> greves: servant is for web applications in general, but quite REST-oriented by default. you can however integrate some websocket endpoints, use cookies and what not
10:41:43 <glguy> erisco: openFile documents which kinds of exceptions it expects it will throw
10:41:57 <alpounet> the goal being to keep it extensible so that you can add whatever you find to be missing
10:42:00 <aweinstock> erisco: http://hackage.haskell.org/package/base-4.8.1.0/docs/System-IO-Error.html
10:42:22 <glguy> erisco: otherwise things like readFile and openFile throw IOExceptions
10:42:32 <glguy> which is just one type you can catch
10:42:39 <aweinstock> erisco: so, write your handler with a type of IOException, and use isFooError to discriminate between them
10:42:40 <erisco> okay so let me get this straight
10:42:56 <erisco> "This operation may fail with ... isAlreadyInUseError..."
10:43:06 <erisco> I am supposed to take that, then figure out this means I need to catch IOError
10:43:21 <erisco> because in another module isAlreadyInUseError :: IOError -> Bool
10:43:32 <erisco> and  openFile :: FilePath -> IOMode -> IO Handle
10:43:38 <meoblast001> oh
10:43:40 <erisco> what went wrong
10:43:44 <meoblast001> i can directly edit metadata in developers corner
10:43:45 <meoblast001> yay
10:44:33 <erisco> openFile :: FilePath -> IOMode -> IO (Either IOError Handle)
10:44:35 <erisco> just saying.
10:44:51 <glguy> If you want that behavior you can get it with the 'try' function
10:45:19 <erisco> again, 'try' doesn't tell me what the actual exceptions are, but okay, that is the best we've got
10:45:29 <erisco> I'll just try to wallpaper over this mess with 'try'
10:46:13 <aweinstock> :t \path mode -> try (openFile path mode)
10:46:15 <lambdabot> Not in scope: ‘openFile’
10:46:18 <monochrom> erisco: have you seen my http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml ?
10:46:20 <aweinstock> :t \path mode -> try (System.IO.openFile path mode)
10:46:22 <lambdabot> Exception e => FilePath -> GHC.IO.IOMode.IOMode -> IO (Either e GHC.IO.Handle.Types.Handle)
10:46:55 <erisco> monochrom, nope, what is it going to tell me?
10:47:46 <ptek> is anyone using `stack`? Is there a way to disable a warning about other-modules?
10:48:16 <erisco> aweinstock, which I then have to specialise, but whatever
10:48:26 <monochrom> it tells you many things, for example tryJust
10:49:10 <erisco> I just want justification for why it is  (Exception e) => IO (Either e Handle)  and not  IO (Either IOError Handle)
10:49:16 <aweinstock> erisco: e is exactly the IOError you want
10:49:23 <erisco> nooo it isn't
10:49:45 <glguy> Because 'try' is useful for other types of exceptions, not just IOExceptions
10:49:47 <monochrom> "try" is general and polymorphic in exception type
10:49:59 <monochrom> this is also covered in my tutorial
10:50:09 <erisco> okay, I'll just live in my world where this is a bad thing
10:50:17 <monochrom> so yeah, it tells you many things you need to know and haven't
10:50:58 <monochrom> I am agnostic to whether it is good or bad
10:51:15 <monochrom> you have a program to finish writing and you need to finish it now. good or bad.
10:51:28 <erisco> I'm an Exception atheist... I don't believe there is a good
10:51:30 <monochrom> you can always worry about language re-design tomorrow
10:52:17 <erisco> you can't use that
10:52:26 <erisco> not you personally but you as part of the Haskell collective
10:52:42 <erisco> you can't in one hand tout taking the time to do it right
10:52:56 <erisco> and in the other hand claim whatever gets it done quick is best
10:53:11 <ReinH> it's almost as if there isn't a collective and rather individuals with separate thoughts
10:53:24 <monochrom> but the Haskell collective didn't say that. it's only monochrom speaking here.
10:53:30 <erisco> ReinH, that is what neurons think too
10:53:37 <ReinH> neurons don't think
10:53:48 <aweinstock> do conduit/pipes do IO errors in a non-exception-y way?
10:53:50 <monochrom> ok you have watched Inside Out too much.
10:54:31 <dmj> aweinstock: what is the "exception-y" way?
10:55:16 <aweinstock> openFile potentially throwing an exception, rather than directly return Maybe Handle or Either IOError Handle
10:55:59 <aweinstock> erisco: exceptions do seem inelegant, but you can get the nice elegant Either just by using "try"
10:56:13 <erisco> nooooo you can't
10:56:44 <aweinstock> why not?
10:56:49 <dmj> aweinstock: I'd check out pipes-safe, it handles async exceptions as well as synchronous exceptions
10:56:51 <dmj> aweinstock: https://hackage.haskell.org/package/pipes-safe-2.2.3/docs/Pipes-Safe.html
10:56:58 <erisco> aweinstock, because 'try' promises too much
10:57:12 <erisco> openFile throws IOError, period (or supposedly, that is what the docs say)
10:57:32 <erisco> 'try' on the other hand only tells you some Exception type is thrown
10:57:35 <erisco> and you've got to GUESS
10:57:35 <monochrom> you know what, openFile throws AsyncException too
10:57:48 <erisco> perfect
10:58:14 <geekosaur> you have to guess anyway unless you guaranteed beforehand that the filename you handed to openFile was fully evaluated already and didn't have, say, a tail [] hidden in it
10:58:35 <erisco> gosh no why are partial functions part of this now
10:58:42 <erisco> how is that related
10:58:44 <geekosaur> because of laziness?
10:58:50 <aweinstock> dmj: nifty
10:59:11 <geekosaur> because it's an unevaluated thunk until openFile needs to give an actual string to the system?
10:59:19 <erisco> you can catch that?
10:59:30 <mauke> :t throwTo
10:59:31 <lambdabot> Exception e => GHC.Conc.Sync.ThreadId -> e -> IO ()
10:59:39 <mauke> I can give your thread any exception any time
11:00:04 <aweinstock> mauke: when is it correct to handle those exceptions?
11:00:04 <erisco> why
11:00:06 <dmj> aweinstock: just know that at anytime, an async exception can be thrown, anywhere, and can only be caught in I/O.
11:00:16 <erisco> why should you be able to do that
11:00:19 <erisco> I regret all of this
11:00:21 <mauke> aweinstock: usually it isn't, but maybe you're using it as a communication protocol
11:00:48 <aweinstock> mauke: so basically "this is a thing that you can do, but just don't"?
11:01:04 <mauke> "if you don't know what it's for, just ignore it"
11:01:08 <erisco> geekosaur, can you catch the exception thrown from that?
11:01:09 <mantovani> https://www.youtube.com/watch?v=LR8fQiskYII
11:01:13 <mauke> like unsafeInterleaveIO
11:01:26 <mantovani> "haskell is for genius" - larry wall hahaha
11:01:27 <aweinstock> or accursedUnutterablePerformIO?
11:01:56 <mauke> mantovani: hi
11:04:38 <geekosaur> erisco, yes, it can be ErrorCall (explicit "error ...") or PatternMatchFail
11:04:48 * geekosaur submerging into a call for a bit...
11:05:04 <erisco> an error call perhaps?
11:05:13 <erisco> well this is all alarming and uncomfortable
11:05:15 <GLM> Is there an equivalent for Either with 3 values?
11:05:28 <erisco> GLM, Either a (Either b c)
11:05:44 <clrnd> "Enable Javascript button" lol
11:05:53 <geekosaur> then you probably want to stick to strict procedural languages and hope there;s never a hardware failure or out of memory condition
11:05:57 <GLM> erisco:Am I doomed to have nested Eithers if I want 10 values?
11:06:19 <erisco> GLM, yes
11:06:30 <aweinstock> data Three a b c = Left a | Middle b | Right c
11:06:38 <erisco> alternatively you can create your own type, but then you'll have 10 type parameters if you want it to be polymorphic
11:06:44 <erisco> and I don't know why you'd want any of this
11:07:20 <GLM> erisco:A function might need to return many kinds of values like an Int in the happy path, or one of many Error types
11:07:37 <erisco> Either Error Int
11:07:38 <aweinstock> GLM: Either MyErrorSumType Int
11:07:45 <geekosaur> note that the latter two mean you can get unexpected things *anywhere*, regardless of language or implementation
11:08:00 <aweinstock> CosmicRayException
11:08:04 <mantovani> mauke: hi
11:08:09 <GLM> What if there are many Error types I want to combine?
11:08:10 <erisco> geekosaur, okay, I can accept some stuff around the edges
11:08:21 <mantovani> mauke: if you said something after the "hi" I didn't see bouncer problem.
11:08:22 <erisco> geekosaur, stack overflows, catchable runtime exceptions, alrighty
11:08:46 <erisco> geekosaur, but why this design (I'll just assume it is awesome for these edge cases) leaks into everything else
11:08:51 <erisco> I don't understand
11:08:52 <sbrg> I'm trying to use Free monads(The Free monad transformer, actually, for state) to define a DSL for a "turtle drawing" language for fun. It started breaking like this when I introduced the transformer instead of just the free monad. What am I doing wrogn? https://gist.github.com/78078e51ebc40903bec9
11:08:58 <aweinstock> GLM: either make a new sum type that wraps the indivudal error types, or use absurdly nested eithers
11:09:41 <aweinstock> data MyErrorSumType = WrappedIOError IOError | WrappedOtherError SomeException
11:12:19 <aweinstock> sbrg: are you sure you want (FreeT Turtle (State TurtleState)) and not (StateT TurtleState TurtleM)?
11:12:49 <aweinstock> (can you show what the code looked like with just the free monad?)
11:13:03 <erisco> I'd support a free turtle state.
11:13:32 <sbrg> https://gist.github.com/2a388c7bd45c0c25909d aweinstock 
11:14:07 <sbrg> aweinstock: well, after reading the articles http://www.haskellforall.com/2012/07/free-monad-transformers.html and http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html it looks like I want FreeT over State yeah
11:14:20 <sbrg> otherwise I'd have to lift the turtle operators
11:14:23 <sbrg> operations*
11:15:06 <lispy> sbrg: so then isn't this order backwards? runState (runFreeT prg) (TurtleState "foobar")
11:15:43 <lispy> sbrg: I haven't used FreeT before, but I think the inner monad here is state, so you need to have the runFreeT on the outside in that line
11:16:07 <greves> =/ i was told stack was the easiest way to get up and running and i'm running into a lot of issues
11:16:10 <sbrg> lispy: The outer monad is FreeT. I need to runFreeT to get State
11:16:33 <sbrg> runState program in my code above doesn't typecheck
11:17:12 <greves> can't follow the first example on the wiki https://github.com/commercialhaskell/stack/blob/master/GUIDE.md , getting errors: https://dpaste.de/ZVx7
11:17:34 <greves> and i definitely have added `text' to my build-depends
11:17:36 <sbrg> how many times does one have to chant his name to summon edward the monad genie? 
11:18:35 <monochrom> erisco: https://mail.haskell.org/pipermail/haskell/2004-June/014271.html
11:22:16 <lispy> sbrg: oh, I just realized you have type Program = FreeT Turtle (State TurtleState), but I tihnk you meant type Program a = ...
11:22:53 <eisdealer> TEST
11:22:57 <lispy> sbrg: I'm not sure that the type synonym is doing what you think. I haven't play enough with the partial application style type synonyms to be sure about it
11:23:24 <lispy> sbrg: But I would definitely change that to the simpler form and see if the error message changes
11:24:19 <sbrg> lispy: nope, I meant without parameter. type Foo a = Bar a and type Foo = Bar are equivalent.
11:25:45 <greves> also cannot do `stack install ghc-mod' or `stack install cabal-helper', getting: Couldn't find executable cabal-helper-wrapper in directory C:\...
11:25:51 <lispy> Okay, I wasn't sure if it would quantify the same way
11:26:15 <greves> am i supposed to cabal install those, not stack install?
11:27:36 <mniip> edwardk!
11:28:06 <erisco> monochrom, interesting discussion, not sure what the verdict is
11:28:10 <erisco> obviously this isn't being used today
11:29:30 <erisco> wrt not being able to use functions as simply anymore
11:29:38 <erisco> well, sorry to say, but things are already really complicated
11:29:47 <erisco> and having invisible problems doesn't help
11:31:57 <mniip> @tell dramforever I did it! Z-algorhtm cons-cells! Package coming soon
11:31:57 <lambdabot> Consider it noted.
11:32:16 <erisco> the way they unioned the error types probably doesn't work
11:34:18 <erisco> I don't know what is supposed to happen if you, say, take a list that could have errors
11:34:31 <erisco> and tuple it with a list that doesn't but of otherwise same type
11:35:37 <erisco> like, if you've got  x :: (CERROR EHead [Int]) => [Int]  then what is  (,) [1,2,3] x   ?
11:36:41 <aweinstock> erisco: you're probably misinterpreting the type of try
11:36:42 <aweinstock> :t try
11:36:43 * hackagebot compact-socket 0.1.0.0 - Socket functions for compact normal form.  https://hackage.haskell.org/package/compact-socket-0.1.0.0 (EdwardYang)
11:36:44 <lambdabot> Exception e => IO a -> IO (Either e a)
11:36:45 * hackagebot reactive-banana-wx 0.9.0.1 - Examples for the reactive-banana library, using wxHaskell.  https://hackage.haskell.org/package/reactive-banana-wx-0.9.0.1 (HeinrichApfelmus)
11:36:50 <erisco> aweinstock, I am not!
11:36:51 <edwardk> mniip: ?
11:37:03 <aweinstock> the (Exception e =>) part is a typeclass constraint
11:37:41 <aweinstock> just like (+):
11:37:43 <aweinstock> :t (+)
11:37:44 <lambdabot> Num a => a -> a -> a
11:39:09 <bitemyapp> erisco: mastered Pipes? :)
11:39:12 <monochrom> erisco, no one is advocating exceptions or exception handling for non-IO stuff.
11:39:27 <kqr> what's the best way to accomplish :: (a -> m b) -> (c, a) -> m (c, b) ?
11:39:31 <erisco> bitemyapp, turns out "later" isn't later enough
11:39:53 <bitemyapp> erisco: t'was just lunch :P
11:40:06 <erisco> monochrom, yeah, but, so? these little examples with lists ought to be just as good
11:40:29 <erisco> I don't know why else you're showing me unless it is a possible approach for IO actions as well (any why wouldn't it be)
11:40:40 <aweinstock> :t \f (x, y) -> do { y' <- f y; return (x, y') }
11:40:41 <lambdabot> Monad m => (t -> m t2) -> (t1, t) -> m (t1, t2)
11:41:01 <monochrom> yes, I'm showing you for IO purposes.
11:41:03 <kqr> is the same thing possible with functor?
11:41:25 <kqr> I guess not, actually
11:41:29 <kqr> thanks
11:41:53 <aweinstock> @djinn Monad m => (a -> m b) -> (c, a) -> m (c, b)
11:41:53 <lambdabot> -- f cannot be realized.
11:42:05 <aweinstock> djinn doesn't do monadic stuff?
11:42:24 <mniip> edwardk: I have a few, uh practical questions
11:42:30 <monochrom> for IO purposes, types have the form "... => ... -> IO a", not "... => ... -> [a]"
11:42:52 <kqr> @djinn (a -> Maybe b) -> (c, a) -> Maybe (c, b)
11:42:52 <lambdabot> f a (b, c) =
11:42:52 <lambdabot>     case a c of
11:42:52 <lambdabot>     Nothing -> Nothing
11:42:52 <lambdabot>     Just d -> Just (b, d)
11:42:53 <erisco> :t \f x -> fmap (((,)(fst x) . f) (snd x)
11:42:54 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
11:42:58 <kqr> oh hah, that didn't help
11:43:01 <erisco> :t \f x -> fmap (((,)(fst x) . f)) (snd x)
11:43:02 <lambdabot> Functor f => (a -> b) -> (a1, f a) -> f (a1, b)
11:43:02 <monochrom> and so I will ignore what happens to "... => ... -> [a]"
11:43:13 <erisco> well we tried
11:43:17 <erisco> and then something happened
11:43:27 <mniip> edwardk: say I've invented something functional-progtamming-ly new, what comes first, paper or package
11:44:11 <kqr> :t \f -> fmap (second f)
11:44:12 <lambdabot> Functor f => (b -> c) -> f (d, b) -> f (d, c)
11:44:14 <arkeet> kqr: that's traverse
11:44:22 <arkeet> :t traverse :: (a -> Maybe b) -> (c, a) -> Maybe (c, b)
11:44:23 <lambdabot> (a -> Maybe b) -> (c, a) -> Maybe (c, b)
11:44:42 <erisco> so be it!
11:44:45 <monochrom> mniip: IMO that's a false dichotomy. interleave them iteratively ("spiral" process).
11:44:49 <kqr> it appears fmap . second does it? or am I missing something?
11:45:06 <Ankhers> :t fmap . second
11:45:08 <lambdabot> Functor f => (b -> c) -> f (d, b) -> f (d, c)
11:45:08 <arkeet> you are missing something.
11:45:10 <arkeet> the f is in the wrong place.
11:45:17 <kqr> oh
11:45:18 <kqr> yes
11:45:30 <kqr> that explains why it didn't type check in my head =)
11:45:35 <arkeet> :-)
11:45:37 <monochrom> i.e., in the midst of implementation, you find out what to write in the paper. in the midst of writing the paper, you find out what and how to implement.
11:45:43 <erisco> okay, oddly this email code does not compile
11:46:01 <mniip> monochrom, another problrm is I have no experience in writing papers
11:46:03 <arkeet> although actually
11:46:11 <arkeet> traverse is too much, Functor is enough.
11:46:35 <arkeet> :t traverse :: (a -> Const Int b) -> (c, a) -> Const Int (c, b)
11:46:37 <lambdabot>     No instance for (Monoid Int) arising from a use of ‘traverse’
11:46:37 <lambdabot>     In the expression:
11:46:37 <lambdabot>         traverse :: (a -> Const Int b) -> (c, a) -> Const Int (c, b)
11:46:44 <monochrom> then it's best to implement first.
11:46:46 <arkeet> :t _2 :: (a -> Const Int b) -> (c, a) -> Const Int (c, b) -- lens to the rescue!
11:46:47 <lambdabot> (a -> Const Int b) -> (c, a) -> Const Int (c, b)
11:47:11 <arkeet> :t _2 :: Functor f => (a -> f b) -> (c, a) -> f (c, b) 
11:47:12 <lambdabot> Functor f => (a -> f b) -> (c, a) -> f (c, b)
11:47:45 <arkeet> traverse needs an Applicative, even though the Traversable instance for (,) doesn't need any more than fmap.
11:48:23 <erisco> uhhh
11:48:39 <erisco> monochrom, I don't know what is going on but ghc is actually throwing away the TC
11:48:50 <arkeet> :t \f (c,a) -> (,) c <$> f a
11:48:51 <lambdabot> Functor f => (t -> f b) -> (a, t) -> f (a, b)
11:49:56 <erisco> I have never seen this before... is this bugs?
11:50:06 <aweinstock> does ApplicativeDo have the potential to desugar/compile do-notation into something that only requires Functor?
11:50:13 <aweinstock> (in some cases)
11:51:20 <arkeet> do { x <- a; return (f x) }  =  fmap f a
11:51:34 <arkeet> no idea if it actually would.
11:52:31 <edwardk> mniip: what usually comes first for me is a blog post ;)
11:54:07 * erisco 's mind is blown
11:56:16 <aweinstock> @pl \f (c,a) -> (,) c <$> f a
11:56:16 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (<$>) . (,))
11:56:46 <erisco> on a scale of 1 to wtfbbq what is this http://lpaste.net/139794
11:57:07 <edwardk> aweinstock: at present ApplicativeDo doesn't remove calls to 'return'
11:57:27 <erisco> why does GHC pretend the TC doesn't even exist?
11:58:13 <aweinstock> what's TC in this context?
11:58:17 <edwardk> I also supplied an optimal algorithm for computing (<*>)/(>>=) splits based on a CYK-parsing + game theory argument, but I think its still doing the simple thing. I'm not sure how well it scales
11:58:38 <bitemyapp> erisco: tf are you doing
11:58:39 <aweinstock> and what's the advantage of the CERROR typeclass over just using error?
11:58:52 <erisco> bitemyapp, what is GHC doing is the question
11:59:17 <edwardk> erisco: CError CHEAD [a]  can be derived from Show CHEAD which is in scope
11:59:20 <EvanR> erisco: youre making an instance for a class, and constructing a class?
11:59:23 <edwardk> a CError CHEAD [a] constraint is equivalent to ()
11:59:34 <edwardk> er whatever the capitalization is
11:59:46 <EvanR> oh Flexible*
12:00:20 <edwardk> given no information I can find Show EHead in the environment, and manufactor CERROR EHead c for any c i want.
12:00:50 <erisco> edwardk, geez really?
12:00:52 <edwardk> erisco: so the compiler is doing precisely the right thing by simplifying the constraint you gave
12:00:55 <erisco> thanks GHC but you're doing too much work
12:01:05 <edwardk> whether what you wrote is what you intended is another matter entirely
12:01:13 <erisco> with explicit annotation this is especially confusing
12:01:23 <erisco> I didn't write it
12:01:26 <edwardk> the functions there have that type
12:01:36 <edwardk> but when you ask for the type of something it could be anything
12:01:42 <edwardk> and so it simplifies the context on the type you see
12:02:18 <edwardk> >>> :i myhead           ==> myhead :: CERROR EHead [a] => [a] -> a
12:02:24 <edwardk> it has the right type there
12:02:34 <edwardk> but :t myhead is asking for what is needed for myhead as an expression
12:02:45 <edwardk> and there that simplifies away
12:03:19 <erisco> this is code from 2004, so, I don't know what life was like then
12:03:20 <edwardk> this is no more than it seeing that you have an expression that needs 'a' to be both Eq a and Ord a   and then reducing to eliminate the redundant Eq
12:03:33 <edwardk> its eliminating the redundant CERROR EHead x
12:03:41 <edwardk> because its implied by no constraint at all
12:03:44 <aweinstock> :t (>)
12:03:45 <lambdabot> Ord a => a -> a -> Bool
12:04:05 <aweinstock> :t (>) :: (Ord a, Eq a) => a -> a -> Bool
12:04:06 <lambdabot> Ord a => a -> a -> Bool
12:04:08 <erisco> edwardk, this is fair, but I would have never seen that
12:04:14 <edwardk> :t (\x y -> x == y || x < y)
12:04:15 <lambdabot> Ord a => a -> a -> Bool
12:04:21 <edwardk> :t (\x y -> x == y)
12:04:22 <lambdabot> Eq a => a -> a -> Bool
12:04:24 <edwardk> now you have
12:04:41 <erisco> and how would I even know
12:04:49 <erisco> what if I put in an ambiguous instance
12:04:53 <erisco> let me try such a thing
12:04:56 <edwardk> there is no difference in what you can call in these situations
12:05:22 <edwardk> as for ambiguous instances, by the time you turn on enough incoherent extensions your program will be quite incoherent and will be have as incoherently as you expect ;)
12:05:32 <erisco> lol
12:05:34 <kqr> haha
12:05:35 <erisco> so hang on a minute
12:05:50 <erisco> no no, I just mean there are two candidate instances
12:05:55 <erisco> so it is ambiguous as to which it picks
12:06:07 <erisco> so, if I add another candidate instance, now it doesn't simplify the time
12:06:08 <erisco> type*
12:06:09 <edwardk> you won't be allowed to do that without turning on a ton of bad extensions
12:06:20 <erisco> sure I can, I did, no extensions on that are bad
12:06:47 * hackagebot not-gloss 0.7.6.0 - Painless 3D graphics, no affiliation with gloss  https://hackage.haskell.org/package/not-gloss-0.7.6.0 (GregHorn)
12:07:24 <htebalaka> can anyone else check if http://pastebin.com/vsNeL6WV causes an infinite loop in GHCi?
12:07:27 <erisco> so if it can happen to deduce that there is exactly one possible instance then away goes the constraint
12:07:42 <erisco> I mean, okay, but this is rather subtle
12:07:56 <erisco> especially when it is just grabbing stuff that happens to be in scope
12:08:03 <edwardk> erisco: there is only one possible instance without overlap
12:08:18 <erisco> edwardk, I don't think we're talking about the same thing
12:08:28 <edwardk> instance ... => Bar (Baz x y z) -- only looks at hey i need a Bar  for something that i can show looks like (Baz x y z)
12:08:43 <edwardk> then it backtracks, simplifying the instance in the way you just complained about to whatever the ... was
12:08:47 <edwardk> and the old thing goes away
12:09:02 <edwardk> without another pattern that overlaps Baz x y z   -- no other instance could ever fire
12:09:08 <edwardk> and you can't do that without overlapping instances
12:09:24 <erisco> I would show you, but lpaste no worker
12:09:43 <edwardk> i'm pretty darn comfortable with how instance dispatch works =)
12:09:58 <erisco> I am sure you are, but we're not talking about the same thing
12:10:13 <erisco> especially since I have the program written right now and can execute it and elicits what I am trying to say
12:10:51 <dmj> Does anyone here use lucid? Having trouble with 'script_'
12:10:56 <edwardk> I'm just saying that your instance Show x => CError x c  -- is general enough that you can never define ANY other instances for CError without overlap
12:11:13 <edwardk> because its saying 'whatever x or c you have' just look at the x and go chase down and find me a Show instance and here you go
12:11:30 <edwardk> that has the most general instance head you can write at all
12:11:51 <erisco> okay, interesting point
12:11:55 <erisco> but I didn't write CERROR
12:12:13 <erisco> I'm only talking about the curiosity of what GHC decides to report the type of myhead and mytail as
12:12:17 <erisco> and 'darn' for that matter
12:12:34 <edwardk> :t simplifies the constraints on whatever you give it, because that is how it type checks the very expression
12:12:36 <lambdabot> parse error on input ‘,’
12:12:38 <edwardk> :t (+1) 2
12:12:39 <lambdabot> Num a => a
12:12:45 <monochrom> aweinstock: I suggested that thing because it is a way to specify exception types in types. it is from https://mail.haskell.org/pipermail/haskell/2004-June/014271.html
12:13:07 <edwardk> :t isn't 'hey go get me the info for the type this function has in my module' its hey take an expression and report the type
12:13:08 <lambdabot> parse error on input ‘type’
12:13:28 <edwardk> part of evaluating that type is type checking it, and typechecking removes redundant constraints, discharging the obligations
12:13:33 <edwardk> or it can't do its job
12:13:51 <monochrom> does :info give you something better?
12:14:09 <edwardk> monochrom: 3:01:57 PM <edwardk> >>> :i myhead           ==> myhead :: CERROR EHead [a] => [a] -> a
12:14:10 <monochrom> because yeah :type does type inference rather than dumb lookup
12:14:30 <monochrom> or rather s/dumb/docile/
12:20:37 <iron_houzi> Can anybody tell me if using haskell/FP for text parsing is a good fit and why? Whenever I try to write a lexer, the problem seems inherently stateful. I know pandoc is written in Haskell and it seems like it works really well, so I'd love to know more about why pandoc works so well .. who knows, perhaps I'll finally understand monads..
12:21:48 <erisco> monochrom, hm, so fixing up the idea a bit so GHC doesn't degenerate the TC on us...
12:22:07 <erisco> monochrom, they didn't really say how to construct values that satisfy the constraint
12:22:46 <erisco> I guess the newtype NonEmpty thing
12:24:14 <aweinstock> iron_houzi: have you seen parser combinator libraries like parsec?
12:24:39 <aweinstock> http://book.realworldhaskell.org/read/using-parsec.html
12:24:55 <erisco> though if you've got NonEmpty the TCs for union type error approach thing isn't needed
12:25:06 <erisco> so, hm
12:25:12 <edwardk> erisco: "degenerating the TC here" is called 'typechecking' you can write a language that doesn't typecheck. that is easy ;)
12:25:36 <sbrg> iron_houzi: Parser combinators are amazing. 
12:25:44 <sbrg> so I'd say yeah, Haskell is a good fit.
12:25:51 <erisco> edwardk, okay? oO
12:26:46 <monochrom> edwardk: it was Oleg's idea to specify "what exceptions may I throw" in type class constraints. https://mail.haskell.org/pipermail/haskell/2004-June/014271.html
12:26:49 <edwardk> a typeclass constraint is an obligation. the moment ghc can discharge that obligation it has to or every dictionary you need in every subexpression even ones related to types that aren't currently in scope and you have no way to talk about them would leak out into the signature of your function
12:27:43 <edwardk> monochrom: i don't see how it works with the instance he gives in scope. without the instance all that works
12:27:53 <erisco> so, when lpaste goes down what is the contingency
12:28:17 <monochrom> yeah ok
12:29:31 <edwardk> anyways that was 11 years ago. surprised it even "worked" then
12:29:45 <edwardk> in the sense that the type should have been simplified by the context
12:29:47 <kaictl> erisco: writing messages on paper and sending them by carrier pigeon
12:30:06 <jmcgover2> hello
12:30:08 <edwardk> must have been that -fglasgow-exts was bringinging in something like IncoherentInstances and OverlappingInstances and it was afraid of later overlap?
12:30:15 <jmcgover2> i use java because it's the fastest language in the world
12:30:41 <monochrom> ok, today's moral of the story is "scaremonger GHC into doing what you want" :)
12:30:51 <erisco> so, if CERROR EHead [a] and CERROR ETail [a] are kind of thing same thing, i.e. "the list is non-empty"
12:30:58 <erisco> then you'd be tempted to write  mycons :: (CERROR EHead [a], CERROR ETail [a]) => a -> [a] -> [a]
12:31:06 <erisco> and this is what I meant before when I gave the tuple example
12:31:11 <jmcgover2> kind of thing same thing
12:31:21 <erisco> you don't get a way to distinguish between the one [a] and the other [a]
12:31:34 <erisco> the [a] coming in doesn't need the constraints, the [a] coming out gets them
12:31:54 <erisco> and to float the context to the other side of the arrow...
12:31:58 <erisco> actually GHC supports this for -> doesn't it
12:32:45 <edwardk> erisco: you're spending a lot of time chasing a thing that doesn't work or make sense. just FYI ;)
12:32:55 <erisco> mycons 1 [] :: (CERROR EHead [a], CERROR ETail [a], Num a) => [a]
12:32:59 <erisco> this is getting somewhere
12:33:21 <erisco> edwardk, well you're welcomed to figure it out for me
12:33:30 <shersh> hello everyone. Can anybody clarify one thing to me? I just read about newtype and have one question. If newtype is just simply a wrapper about some type and can be optimized by compiler, why compiler can't just figure out if data has one constructor with one argument? Why we need this newtype?
12:33:43 <monochrom> erisco: http://hackage.haskell.org/package/explicit-exception should be much better, actual and recent code
12:33:51 <mauke> shersh: because it behaves differently
12:34:09 <edwardk> erisco: i have, i figured out the thing you want doesn't work or make sense, and moved on ;)
12:34:26 <monochrom> in particular Control.Monad.Exception.Synchronous
12:34:29 <erisco> edwardk, you have? could have fooled me
12:34:32 <shersh> mauke: can you explain it in details?
12:34:33 <edwardk> shersh: because there is a difference between data Foo = Foo Int; and newtype Foo = Foo Int
12:34:45 <mauke> shouldn't have used Foo for both
12:34:48 <edwardk> erisco: i've long since given up on convincing you of things =P
12:35:09 <edwardk> shersh: _|_ is distinguishable from Foo _|_   in the former while in the latter they are the same
12:35:29 <erisco> edwardk, can we just truce on this passive aggressive banter?
12:35:36 <edwardk> shersh: this may not matter _to you_ but it actually matters to a number of problems
12:35:46 <edwardk> erisco: sure
12:35:52 <erisco> okay good
12:36:19 <monochrom> I should bookmark it so next time I suggest this actual package rather than 2004 concept cars :)
12:36:48 <erisco> okay but despite some people being unimpressed I feel there is at least something there
12:36:57 <erisco> wait no, passive aggression is over
12:37:08 <shersh> edwardk: what problems? It seems that if compiler see data Foo = Foo Int it could safely replace `data` with `newtype` and there is now problems are supposed to appear
12:37:30 <mauke> shersh: Foo (error "bang!") `seq` ()
12:37:38 <mauke> with newtype, it'll explode
12:37:40 <edwardk> ^- what mauke said
12:37:51 <edwardk> shersh: i have code where this matters
12:38:02 <erisco> monochrom, I'm not entirely sure how it fits in, this package
12:38:02 <tsani> I'm trying to write a parser for ISO 8601 dates to use with Aeson, but I'm getting a mismatch between Aeson's parser type and attoparsec's parser type. Any advice? (I'm going to put up an lpaste in a sec.)
12:38:35 <edwardk> i also have code that cares about even the difference between data Foo = Foo !Bar  and newtype Foo = Foo Bar -- though for the latter one i have to work far outside of what i'm normally 'allowed' to do.
12:39:32 <edwardk> for reference, code i wrote the other day that needed it: https://github.com/ekmett/structs/blob/master/src/Data/Struct/Internal.hs#L98
12:39:43 <edwardk> not that that is a shining example ;)
12:40:21 <tsani> Of course lpaste is down right now :(
12:40:30 <cocreature> reallyUnsafePtrEquality# is a nice name for a function
12:40:51 <edwardk> shersh: the issue becomes Foo (error "bang!") `seq` ()   -- fails with the newtype but succeeds with the data type.  -- but if you took the ability to have single constructor data types with one field away, you'd have to literally make a second useless constructor to make it work, you'd have to make other people throw _more_ semantic garbage into their types
12:40:51 <edwardk> to make this case solvable
12:41:21 <edwardk> shersh: if we didn't have `seq` you could make a very good case for that change, but we do
12:41:25 <barrucadu> One day, if I keep haskelling and learning, I will be able to write code with even half the language extensions of edwardk
12:42:28 <shersh> edwardk: thanks! Things become clearer to me. With `seq` is really behaves differently
12:43:10 <edwardk> barrucadu: i do sometimes find the laundry list of LANGUAGE extensions i need to turn on on a daily basis to be rather funny =)
12:43:34 <barrucadu> Maybe one day there's just be a {-# LANGUAGE edwardk #-} to turn them all on for you
12:43:45 <edwardk> barrucadu: looking forward to the deja fu talk btw
12:43:46 <bitemyapp> barrucadu: an alias of glasgow-exts eh? :)
12:43:48 <edwardk> barrucadu: wouldn't use it
12:43:56 <edwardk> barrucadu: i like knowing extension by extension what it is i need
12:44:11 <edwardk> because it helps shape my design, each one carries a price
12:44:23 <edwardk> i want to know what i'm paying on an itemized basis =)
12:44:34 <bitemyapp> he even uses Rank2Types.
12:45:05 <edwardk> hah, sadly eisenberg lobotomized that bit of the compiler so Rank2Types and RankNTypes are indistinguishable in GHC today ;)
12:45:16 <edwardk> but for a while it meant some code i had could run on hugs =)
12:45:41 <edwardk> and that in the rank-2 case there was still a hope for inference
12:49:33 <noodles1> Hope pastebin is ok since lpaste is down. I'm trying to determine haskell types, here's a function and my thought process to find it's type. http://pastebin.com/hkqS3LRh
12:49:53 <erisco> monochrom, the problem stems from basic library functions not being explicit
12:49:56 <Clint> lpaste is down?
12:49:58 <noodles1> In this case it matches up with the correct type, but I'm not sure if my process is sound or I got lucky
12:50:25 <noodles1> Clint: yes, I used it ~1 hour ago and it was up, it's not now
12:50:51 <Clint> it looks up to me
12:51:21 <tsani> Clint: it only shows failure when you try to submit a paste.
12:51:36 <Clint> ah
12:51:37 <tsani> _Thanks, lazy evaluation_ ;)
12:54:08 <benzrf> barrucadu: what is deja fu
12:54:35 <tsani> I seemed to have resolved by aeson issue. My fault for not reading enough about how to write the aeson instances.
12:55:34 <monochrom> noodles1: your process is sound
12:57:08 <barrucadu> benzrf: A library for writing and testing concurrent programs. It provides a typeclass covering most of Control.Concurrent (IORefs, MVars, STM, exceptions, and threads), with an instance for IO using all the regular concurrency primitives, and a couple of instances for testing how your code behaves with different schedules.
12:57:37 <barrucadu> The name comes from a Terry Pratchett book and refers to a martial art used by time travellers: 'It is best described as "the feeling that you have been kicked in the head this way before"'
12:58:40 <benzrf> oh man
12:58:46 <benzrf> i read all his stuff
12:58:50 <benzrf> ok not ALL his stuff. but the vast majority
12:58:59 <benzrf> ashamed of having missed that ref ;-;
12:59:06 <monochrom> haha
12:59:12 <barrucadu> Thief of Time, Lu Tze uses it
12:59:23 <benzrf> yeah
12:59:33 * bitemyapp quietly swipes all of barrucadu's code
12:59:41 <bitemyapp> I'll...just borrow this kthxbai
13:01:08 <noodles1> thanks monochrom 
13:07:55 <barrucadu> bitemyapp: Wow, you did swipe all my code
13:08:04 <suppi> I'm trying to read this: https://dl.dropboxusercontent.com/u/3265448/schilling.thesis.final.2014-01-20.pdf
13:08:26 <bitemyapp> barrucadu: all mine nao
13:08:32 <suppi> but on page 107 there is a page I don't know how to read
13:08:40 <suppi> I have no formal education on compilers
13:08:44 <bitemyapp> barrucadu: been working on a book, saw a couple things that gave me ideas.
13:08:58 <barrucadu> Yeah, I've seen a blog post or two on the book
13:09:01 <suppi> does anyone have a resource where I can learn from to read this kind of thing?
13:09:07 <bitemyapp> barrucadu: you can jot me down for being interested in deja fu as well :)
13:09:12 <barrucadu> Woo
13:10:08 <suppi> this kind of thing: http://oi61.tinypic.com/1zbb77n.jpg
13:10:22 <suppi> brb and thanks in advance
13:12:22 <Ralith> suppi: Pierce's Types and Programming Languages?
13:16:51 <kqr> how do I create a Control.Exception.SomeException? I want to signal an error in some Either code but the code I'm calling uses the Exception stuff so I figure I need to too if I want to have a chance of type checking
13:17:48 <suppi> Ralith, can I pick it up as a beginner to the subject?
13:19:42 <Welkin> suppi: I recently got it and it requires some knowledge of formal logic at least
13:19:59 <Welkin> I just look things up as I go
13:20:05 <suppi> Welkin, some? I can do some.
13:20:32 <suppi> Welkin, would you recommend it?
13:20:49 <Welkin> suppi: I barely read it yet, so I can't say
13:21:00 <suppi> I see
13:21:00 <Welkin> but everyone seems to recommend it
13:21:11 <suppi> yeah.
13:21:17 <suppi> thanks :)
13:22:51 <Ralith> you'll want it sooner or later
13:24:41 <Thedarkb> evidently not
13:27:00 * hackagebot reactive-banana-wx 0.9.0.2 - Examples for the reactive-banana library, using wxHaskell.  https://hackage.haskell.org/package/reactive-banana-wx-0.9.0.2 (HeinrichApfelmus)
13:27:47 <camm> Hello everyone, I've looking for examples for HaXml without results. Perhaps do you know where I can find examples or something like that? 
13:28:37 <arkeet> http://packdeps.haskellers.com/reverse/HaXml
13:28:57 <arkeet> probably at least something here?
13:48:37 <sm> could someone remind me how to map over a tuple's elements ?
13:50:11 <mariusmarius1> http://stackoverflow.com/a/9722949
13:50:27 <sm> thanks mari
13:50:31 <sm> mariusmarius1: 
13:51:01 <glguy> > over both (*2) (5,10)
13:51:03 <lambdabot>  (10,20)
13:51:04 <mariusmarius1> Sure. The note after the implementation he give is a good one.
13:51:48 <Iceland_jack> sm: Use 'each' if you want more than 2-tuple
13:51:48 <Iceland_jack> > over each (* 2) (1, 10, 100)
13:51:50 <lambdabot>  (2,20,200)
13:52:49 <kuribas> > over each (*2) (1, 1.2, 3%2)
13:52:51 <lambdabot>  (2 % 1,12 % 5,3 % 1)
13:52:59 <hodapp> :t over
13:53:01 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
13:53:12 <kuribas> > over each (*2) (1::Int, 1.2::Double, 3%2)
13:53:13 <lambdabot>      Couldn't match type ‘Int’ with ‘Double’
13:53:13 <lambdabot>      In the first argument of ‘over’, namely ‘each’
13:53:13 <lambdabot>      In the expression: over each (* 2) (1 :: Int, 1.2 :: Double, 3 % 2)
13:53:15 <hodapp> holy type parameters, batman
13:53:31 <hodapp> :t each
13:53:32 <lambdabot> (Applicative f, Each s t a b) => (a -> f b) -> s -> f t
13:54:36 <McManiaC> what's the currently cleanest/best solution to catch exceptions in monad transformers?
13:54:56 <McManiaC> ErrorT ?
13:55:17 <McManiaC> oh ExceptT
13:55:18 <McManiaC> :D
13:57:41 <breadmonster> Hey.
13:57:52 <breadmonster> Is there some structure that's like monads but stronger?
13:58:13 <hodapp> stronger how?
13:58:30 <fosterite> breadmonster: stronger in what way? there are a lot of typeclasses with Monad m constraints
13:58:45 <monochrom> there are many
13:59:02 <breadmonster> fosterite: I'm not sure if this makes sense, but Functor => Applicative => Monad => ???
13:59:08 <monochrom> for example, IO is like monads but stronger.
13:59:17 <breadmonster> Like I'm sure there's some category theoretic "line of succession"
13:59:30 <fosterite> breadmonster: there are a lot of things that can go there. I don't know of any that are the "right one"
14:03:24 <mpickering> meditans: Do you want the inferred types of all the functions in a module?
14:03:46 <mpickering> If so then haskell-src-exts wont help you as it only deals with syntax
14:04:06 <mpickering> things become a lot harder once you start dealing with more than just the raw source files
14:12:46 <fjordrunner> Please, can anyone help me with following? My type is: joinEdgeNodes :: [Node] -> [(Int, Int)] ->  [([Node], (Int, Int))]
14:13:03 <fjordrunner> and my recursive function is: joinEdgeNodes (n1:n2:ns) (e1:es) = joinEdgeNodes ns es ++ [(n2++[n1], e1)]
14:13:23 <fjordrunner> and the error is: Couldn't match expected type ‘[Node]’ with actual type ‘Node’
14:14:09 <fjordrunner> all I want is actually take 2 elements from [Node] and only 1 element from the 2nd pair... this way I want to pack in a tuple
14:14:46 <monochrom> "n2++[n1]" can't be right.
14:17:24 <montanonic> should be "n2 : [n1]" there, right?
14:17:37 <fjordrunner> I tried with: joinEdgeNodes (n1:n2:ns) (e1:es) = joinEdgeNodes ns es ++ [([n1, n2], e1)]
14:17:42 <fjordrunner> and it compiled,...
14:19:45 <montanonic> do you understand why it compiled?
14:20:01 <montanonic> also, you need a termination case (what happens when either or both lists are empty)
14:20:39 <fjordrunner> yes, the termination I have,..just didn't want to paste it there,...
14:20:55 <montanonic> So are you still confused about it, or does it make sense now?
14:21:18 <fjordrunner> if I understand it,...I think that it is the same: n2:[n1]  and [n1, n2],....or?
14:21:58 <montanonic> in this case yes
14:22:00 <thewormkill> basically, the latter is syntactic sugar
14:22:18 <montanonic> would the latter always be equivalent?
14:22:26 <montanonic> my gut says that it shouldn't be
14:23:10 <fjordrunner> no, actually : will prepend, not append,..so they are not equal
14:23:14 <thewormkill> i.e a:listName is not [a, listName] (the latter is invalid)
14:23:40 <thewormkill> if that's what you mean montanonic 
14:23:43 <montanonic> right right, yeah 
14:23:44 <montanonic> that is
14:23:51 <montanonic> thank you thewormkill 
14:23:59 <thewormkill> np
14:25:10 <thewormkill> in some similar cases it might help to search for the type signature you need (and/or some variations)
14:25:29 <thewormkill> I don't know, but there might be a bot function for this
14:51:14 <htebalaka> has anyone used stack to install ghc head?
15:04:44 <agocorona> Hi
15:07:13 * hackagebot microformats2-parser 1.0.1.3 - A Microformats 2 parser.  https://hackage.haskell.org/package/microformats2-parser-1.0.1.3 (myfreeweb)
15:10:34 <Gurkenglas> fjordrunner, I would recommend chunking the Node list using for example chunksOf 2 from Data.List.Split, then using zip (followed up by reverse if you really want that order). Also consider replacing the two-element [Node]s with (Node, Node)
15:13:38 <agocorona> so little activity...
15:14:05 <bitemyapp> I'm wrapping up work so I can go home :P
15:14:12 <fjordrunner> Gurkenglas: many thanks!!!
15:31:46 <orbifx> is there a way to get a value based on a key using Aeson? or do I have to make data types and parse using those?
15:32:17 <aweinstock> @hackage aeson-lens
15:32:17 <lambdabot> http://hackage.haskell.org/package/aeson-lens
15:33:11 <orbifx> thanks aweinstock 
15:33:24 <aweinstock> orbifx: you could use aeson-lens, or pattern-match on Object to get a Map
15:33:40 <aweinstock> :t Data.Map.lookup
15:33:41 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
15:33:44 <edwardk> lens-aeson
15:33:47 <edwardk> not aeson-lens
15:33:53 <edwardk> aeson-lens is broken
15:34:17 <aweinstock> oops
15:34:33 <orbifx> ok
15:34:54 <orbifx> so Aeson using Map behind the scenes?
15:35:38 <Sindriav_> Is there a reason why IO isn't MonadIO?
15:35:39 <minad> Hi. I wonder what you think about modular implicits in comparison to type classes?
15:35:49 <aweinstock> :t Data.Aeson.Object
15:35:50 <lambdabot> aeson-0.9.0.1:Data.Aeson.Types.Internal.Object -> aeson-0.9.0.1:Data.Aeson.Types.Internal.Value
15:36:02 <Welkin> is there really no << ?
15:36:05 <Welkin> :t (<<)
15:36:06 <lambdabot>     Not in scope: ‘<<’
15:36:07 <lambdabot>     Perhaps you meant one of these:
15:36:07 <lambdabot>       data constructor ‘Seq.:<’ (imported from Data.Sequence),
15:36:11 <Welkin> what??
15:36:25 <Welkin> :t flip (>>)
15:36:26 <lambdabot> Monad m => m b -> m a -> m b
15:36:40 <aweinstock> orbifx: "type Object = HashMap Text Value", according to http://hackage.haskell.org/package/aeson-0.9.0.1/docs/Data-Aeson.html#t:Object
15:36:49 <Welkin> I want to use this
15:36:51 <aweinstock> :t (<*) -- Welkin
15:36:53 <lambdabot> Applicative f => f a -> f b -> f a
15:36:58 <Welkin> f << g =<< a
15:36:59 <Intolerable> aweinstock
15:37:03 <Intolerable> those are different
15:37:06 <Welkin> yeah, but I am using a Monad
15:37:09 <Welkin> not Applicative
15:37:13 <Intolerable> (<<) /= (<*)
15:37:42 <aweinstock> are they equal for law-abiding instances?
15:38:04 <aweinstock> Welkin: all Monads are also Applicatives
15:38:18 <Intolerable> > Left 5 <* Left 6
15:38:20 <lambdabot>  Left 5
15:38:28 <Intolerable> @let (<<) = flip (>>)
15:38:29 <lambdabot>  Defined.
15:38:33 <Intolerable> > Left 5 << Left 6
15:38:35 <lambdabot>  Left 6
15:38:55 <orbifx> thanks aweinstock 
15:39:07 <Intolerable> @src (<*)
15:39:07 <lambdabot> (<*) = liftA2 const
15:39:13 <Intolerable> @src (*>)
15:39:13 <lambdabot> (*>) = liftA2 (const id)
15:39:31 <aweinstock> :t const id
15:39:32 <lambdabot> b -> a -> a
15:39:39 <aweinstock> :t uncurry snd
15:39:41 <Intolerable> they sequence in opposite orders
15:39:41 <lambdabot> ((a, b -> c), b) -> c
15:39:53 <aweinstock> :t curry snd
15:39:54 <lambdabot> a -> c -> c
15:40:12 <Welkin> I think there needs to be (<<)
15:40:13 <Sindriav_> > putStrLn "lol" <* putStrLn "derp"
15:40:14 <lambdabot>  <IO ()>
15:40:23 <Sindriav_> :|
15:40:25 <Welkin> otherwise there is no way to write: f << g =<< a
15:40:42 <Welkin> Sindriav_: lambdabot does not perform IO
15:40:50 <Sindriav_> Welkin: (<<) = flip (>>) ?
15:40:55 <Intolerable> if you definitely want (<<), define it
15:41:06 <Intolerable> but it's subtly different from (<*), so don't use that
15:41:25 <agocorona> and how lambdabot output the results?
15:42:06 <Gurkenglas> (<*) still orders effects left-to-right, right?
15:42:19 <Intolerable> yes, (<*) orders left to right
15:42:32 <Intolerable> the proposed (<<) would be right to left
15:42:42 <Welkin> > (Just 5 >> Just 6) == (Just 5 << Just 6)
15:42:44 <lambdabot>  False
15:43:00 <Welkin> > Just 5 >> Just 6
15:43:01 <Intolerable> (which makes sense, because clearly (=<<) doesn't sequence left to right)
15:43:02 <lambdabot>  Just 6
15:43:04 <Welkin> > Just 5 << Just 6
15:43:06 <lambdabot>  Just 5
15:43:29 <aweinstock> (Just 5 << Just 6, Just 5 >> Just 6, Just 5 <* Just 6, Just 5 *> Just 6)
15:43:31 <Intolerable> > (Left 5 >> Left 6) == (Left 6 << Left 5)
15:43:33 <lambdabot>  True
15:43:39 <aweinstock> > (Just 5 << Just 6, Just 5 >> Just 6, Just 5 <* Just 6, Just 5 *> Just 6)
15:43:41 <lambdabot>  (Just 5,Just 6,Just 5,Just 6)
15:44:09 <Welkin> > (Left 5 *> Left 6) == (Left 5 <* Left 6)
15:44:11 <lambdabot>  True
15:44:14 <Welkin> wtf
15:44:27 <aweinstock> is <* vs << related to the notation of "commutative monads"?
15:44:45 <nolrai66> No. I think.
15:45:09 <shachaf> Well, in a commutative monad they would be the same.
15:45:12 <Welkin> oh
15:45:13 <aweinstock> :t ((>=>),(<=<))
15:45:14 <lambdabot> (Monad m, Monad m1) => ((a -> m b) -> (b -> m c) -> a -> m c, (b1 -> m1 c1) -> (a1 -> m1 b1) -> a1 -> m1 c1)
15:45:15 <Intolerable> > (Just 5 <* Just 6, Just 5 *> Just 6)
15:45:17 <lambdabot>  (Just 5,Just 6)
15:45:27 <Welkin> > (Right 5 *> Right 6) == (Right 5 <* Right 6)
15:45:28 <lambdabot>  False
15:45:32 <Intolerable> > (Left 5 <* Left 6, Left 5 *> Left 6)
15:45:35 <lambdabot>  (Left 5,Left 5)
15:45:49 <Intolerable> > (Left 5 << Left 6, Left 5 >> Left 6)
15:45:50 <lambdabot>  (Left 6,Left 5)
15:45:54 <Welkin> hmmm
15:46:13 <aweinstock> commutative implies (<*) == (<<), does the converse also hold?
15:46:27 <dgpratt> I was looking over ghci-ng and noted that it requires 'libtinfo-dev
15:46:27 <dgpratt> ' in order to build it
15:46:38 <Gurkenglas> > execState <$> [modify (+1) << modify (*2), modify (+1) >> modify (*2), modify (+1) <* modify (*2), modify (+1) *> modify (*2)] <*> [1]
15:46:40 <lambdabot>  [3,4,4,4]
15:47:11 <dgpratt> often these lib requirements are an impediment to building on Windows; does anyone know if ghci-ng can be built on Windows?
15:51:38 <Gurkenglas> > execState <$> ([(<<), (>>), (<*), (*>)] <*> [modify (+1)] <*> [modify (*2)]) <*> [1] -- Better. Is there an operator for f (a -> b) -> a -> f b?
15:51:40 <lambdabot>  [3,4,4,4]
15:52:05 <mauris> :t maybe
15:52:06 <lambdabot> b -> (a -> b) -> Maybe a -> b
16:10:06 <Shockk> hello, I wondered if anyone has experience with the package ObjectName (this one: https://hackage.haskell.org/package/ObjectName ) or if they know how to get in contact with anyone who does (like the maintainer)?
16:11:03 <meditans> mpickering: no, to be fair I don't want to infer the types of the functions, I want only to be able to retrieve the annotations which are already there
16:11:34 <meditans> I already can parse the files with haskell-src-extra, if I remove manually the cpp
16:11:58 <meditans> I was in search of a more stable solution
16:12:40 <meditans> (let's say I assume the programmer wrote the types of the function I'm interested in)
16:16:37 <meditans> mpickering: however, have to go now, will be back tomorrow :)
16:20:24 <concept> Why primes seive is harder to implement in Haskell than C ?
16:27:26 <ProofTechnique> concept: It's not
16:28:14 <concept> ProofTechnique: I was reading this paper. and priority queue isn't sth I expected.. 
16:28:16 <Sindriav_> concept: It's literally one line of code.
16:28:51 <concept> Sindriav_: the one line of code isn't really sieve of eratosthenes
16:29:23 <Sindriav_> Doesn't mean it's not a sieve.
16:29:28 <ProofTechnique> Even a real sieve is only 3
16:29:29 <minad> concept: I've heard this before. Which paper do you mean?
16:29:50 <concept> minad: http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
16:29:56 <ProofTechnique> It's not a good implementation, but it's the right sieve
16:30:08 <minad> concept: thx :)
16:30:26 <LokiSnake> oh hey! I went there for school :)
16:30:47 <LokiSnake> never had a class with prof o'niell though
16:31:04 <minad> LokiSnake: so you have to read the paper...
16:31:05 <Lokathor> Day9 went there
16:31:18 <ProofTechnique> concept: http://lpaste.net/139797
16:31:18 <concept> ProofTechnique: how come it's the right sieve, using mod means it's not 
16:31:25 <LokiSnake> yup, definitely added it to my list
16:31:32 <ProofTechnique> No, the one-liner isn't the sieve
16:32:05 <LokiSnake> Lokathor: yup couple years ahead of me
16:32:11 <ProofTechnique> But a correct (though awful) implementation is only 3 lines, which isn't exactly "hard"
16:33:36 <concept> ProofTechnique: it doesn't look efficient to me
16:33:40 <ProofTechnique> It's not
16:33:48 <ProofTechnique> It's horrendously inefficient
16:33:49 <concept> ProofTechnique: nice though
16:34:04 <aweinstock> but it's more efficient (asymptotically) than the one-liner with `div`?
16:34:48 <ProofTechnique> concept: https://wiki.haskell.org/Prime_numbers
16:34:55 <ProofTechnique> That page has *tons* of discussion and examples
16:35:36 <concept> ProofTechnique: yup I saw that, but I came here for the discussion
16:36:55 <concept> ProofTechnique: there is an implementation using the ST Monad which is what I thought would the most efficient.. ?
16:37:28 * hackagebot opaleye-classy 0.2.0.0 - Opaleye wrapped up in classy MTL attire.  https://hackage.haskell.org/package/opaleye-classy-0.2.0.0 (BenKolera)
16:40:30 <ProofTechnique> It certainly looks about as good as a SoA is going to get
16:44:26 <ProofTechnique> concept: You could always try an Atkin sieve if you want better asymptotics
16:46:02 <ttt_fff> how does fay/haste/ghcjs handle the fact that haskell has tco and js does not?
16:47:03 <luite> ES2015 does have tail calls
16:47:03 <concept> ProofTechnique: looks interesting, I didn't know it existed
16:48:25 <luite> i'm working on a codegen update to make use of them :)
16:48:49 <luite> but right now i'm on a ferry with a terrible internet connection
16:49:04 <Fay> luite: sounds like fun
16:49:05 <ttt_fff> how did fay/haste/ghcjs handle the fact that pre 2015, javascript does not have tco ?
16:52:25 <minad> what is the reason not to implement tco right from the start in a vm? js didn't have it, java doesn't have it yet afaik?
16:52:59 <concept> ProofTechnique: the theory behind it looks hard for non-mathematicians
16:53:02 <minad> is it that hard if all the lisps had it for ever
16:53:16 <ProofTechnique> concept: Primes are hard
16:53:27 <ProofTechnique> Number theory in general is sort of hard
16:54:59 <ProofTechnique> @let primes = 2 : 3 : 5 : drop 1 [60*k+x | k <- [0..], x <- [1, 7,11,13,17,19,23,29,31, 37,41,43,47,49,53,59]]
16:55:00 <lambdabot>  Defined.
16:55:05 <ProofTechnique> > take 20 primes
16:55:07 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,49,53,59,61,67]
16:55:14 <concept> ProofTechnique: I only know basic undergraduage discrete math level number theory, and always felt overwhelmed when reading higher number theory subjects.
16:55:31 <mniip> if I implement algorithm Foo that operates on arbitrary lists, does it make sense to call the module Data.List.Foo
16:55:47 <ProofTechnique> concept: Take a good algebra course, or some specific number theory courses. It's a very deep topic
16:55:47 <OPSAREFAGS> hi
16:57:10 <ProofTechnique> concept: Anyway, that one-liner is the sieve of Atkin
16:57:21 <OPSAREFAGS> do you have to be gay to use haskell?
16:57:31 * hackagebot opaleye-classy 0.2.1.0 - Opaleye wrapped up in classy MTL attire.  https://hackage.haskell.org/package/opaleye-classy-0.2.1.0 (BenKolera)
16:57:37 --- mode: ChanServ set +o glguy
16:57:37 --- mode: glguy set +b *!*@gateway/web/cgi-irc/kiwiirc.com/ip.172.91.105.236
16:57:37 --- kick: OPSAREFAGS was kicked by glguy (Your behavior is not conducive to the desired environment)
16:58:01 <ProofTechnique> That was quick.
16:58:08 <minad> yes
16:58:09 <concept> ProofTechnique: yup, could deduce that. Any recommendations for online algebra or number theory course
16:58:26 <hodapp> ...
16:58:32 <hodapp> does this mean Haskell is becoming popular?
16:59:13 <hodapp> ttt_fff: trampolines, probably.
16:59:13 <minad> it is still a pain to compile it to js
16:59:17 <minad> so no ;)
16:59:33 <ProofTechnique> concept: I recommend Dummit & Foote as a textbook, personally
16:59:34 <hodapp> minad: in what language is it *not* a pain to compile to JS?
16:59:41 <ProofTechnique> Lots of examples, and an absurd amount of content
16:59:42 <hodapp> minad: not even JS makes it easy to do that
16:59:46 <minad> hodapp: what are trampolines, is this some way to emulate tco?
17:00:00 <minad> I've seen it in C or assembler, but I don't remember
17:00:16 <hodapp> minad: a technique to express recursion without blowing up the call stack
17:01:16 <erikd> anyone in vancouver already?
17:01:23 <ProofTechnique> concept: I don't particularly know of any online courses
17:01:46 <hodapp> minad: Instead of recursing directly, a function *returns* the next function, and outside of all this something captures the returned function and calls it, and does this in a loop (until some function returns a sentinel to end the loop).
17:02:32 <mauris> question: a package i want to use relies on "unix", but i don't need the part that relies on it (some System.Posix file logging thing)
17:02:39 <concept> ProofTechnique: Thanks that book looks interesting.. I was already planning to expand my knowledge in math, I started with What is mathematics, not hard though, have some good topics
17:02:40 --- mode: glguy set -o glguy
17:02:40 <agocorona> ttt_fff: Haste at least do tco
17:02:47 <arkeet> mauris: what package?
17:02:50 <mauris> ircbot
17:03:04 <minad> hodapp: isn't this basically rewriting the tco to some loop?
17:03:28 <ProofTechnique> concept: A basic book on proof techniques and math fundamentals would be good before D&F, but it's fairly self-contained.
17:03:34 <Gurkenglas> > elem 49 primes -- Umm.
17:03:35 <lambdabot>  True
17:03:38 <minad> hodapp: ah, you already wrote it
17:04:07 <minad> hodapp: but if this is trivally possible, why is everybody making a big deal. for example this was discussed often for clojure that it doesn't have tco
17:04:11 <ProofTechnique> mauris: Fork and delete that part?
17:04:22 <concept> ProofTechnique: I already ordered How to prove it.. 
17:04:29 <ProofTechnique> concept: That's a solid book
17:04:45 <ProofTechnique> Gurkenglas: Whoops
17:05:24 <ProofTechnique> Oh, duh, I should really just ignore all the setup numbers
17:05:48 <minad> hodapp: I mean, why is it a problem if the underlying vm doesn't have tco if you can always write such a trampoline
17:06:08 <concept> ProofTechnique: I am actually a Software Engineer with interest to continue graduate studies in CS.. so I am working on expanding my math skills.. so any advice would be great.. btw you look like a math major ?
17:06:27 <ProofTechnique> Gurkenglas: Ignoring one bad apple, I think the rest are good. Trust me, I know all the primes. ;)
17:06:48 <hodapp> minad: it is not basically rewriting the TCO as a loop...
17:06:52 <hodapp> minad: it is *precisely* that.
17:06:58 <Gurkenglas> > filter ((==0) . flip mod 7) primes
17:07:00 <lambdabot>  [7,49,77,91,119,133,161,203,217,259,287,301,329,343,371,413,427,469,497,511,...
17:07:00 <concept> ProofTechnique: and I am sorry if I am asking too much
17:07:23 <Carcigenicate> Does anyone here have any experience installing buildwrapper through Cabal? The source of ghc-pkg-lib seems to be corrupt. I have a paste of the error to show.
17:07:28 <ProofTechnique> concept: Yeah. For CS, I recommend theory of computation, linear algebra, stuff like that
17:07:35 <ProofTechnique> concept: Not asking too much, don't worry
17:07:47 <hodapp> minad: and Clojure doesn't have TCO because (AIUI) the JVM has no real mechanism to allow it, but Clojure does make trampolining quite easy
17:08:05 <ProofTechnique> Carcigenicate: Are you trying to get EclipseFP working?
17:08:12 <hodapp> minad: if it's a big deal it's because it's sort of a hack to work around lack of recursion and I doubt it's as fast as TCO
17:08:24 <Carcigenicate> @Proof yes lol
17:08:24 <lambdabot> Unknown command, try @list
17:08:29 <concept> ProofTechnique: wouldn't number theory and abstract algebra be useful ?
17:08:30 <ProofTechnique> Gurkenglas: That you don't trust me is hurtful
17:08:43 <concept> ProofTechnique: and the how to prove it book ?
17:08:46 <Carcigenicate> Proof: Yes lol
17:09:03 <Carcigenicate> Is this a common issue?
17:09:11 <ProofTechnique> concept: Depends what problems you're interested in, but I would never be so crass as to call algebra "useful" :D
17:09:27 <Gurkenglas> Who says I don't trust? I merely verified. Er, falsified.
17:09:53 <ProofTechnique> Hahaha
17:10:17 <minad> hodapp: I never understood that. tco is like a goto/jump as I see it. and a loop is like a jump. So why is there a difference
17:10:56 <ProofTechnique> Carcigenicate: http://jpmoresmau.blogspot.fr/2015/05/eclipsefp-end-of-life-from-me-at-least.html
17:11:06 <Carcigenicate> ProofTechnique: Don't leave me hanging please! 0.0 Do you know about this issue? I've been stuck on it for several hours now. I've done a complete wipe and reinstall of the platform
17:11:09 <Carcigenicate> Oh, thanks
17:11:12 <ProofTechnique> Carcigenicate: The whole stack is currently unmaintained (understandably)
17:11:14 <edwardk> erikd: i get in tomorrow
17:11:15 <Carcigenicate> I'll give thata read
17:11:35 <Carcigenicate> So, what's the TL; DR version. I'm SOL?
17:11:47 <concept> ProofTechnique: TBH I think it's fundemental
17:11:51 <ProofTechnique> Carcigenicate: Oh, and it almost certainly won't work with the platform, last I knew. You probably need to start from a minimal install
17:12:24 <concept> ProofTechnique: but I am not a native English speaker, so I probably didn't get what you meant
17:12:36 <Carcigenicate> -_-. Ok, thank you. Can you recommend an IDE then with some functionality? I'm tired of using Notepad++
17:12:52 <Carcigenicate> ProofTechnique: ^^
17:13:09 <Carcigenicate> Whoops, that not what I was intending lol. Wanted 2 up arrows
17:13:10 <ProofTechnique> Carcigenicate: I use Emacs, mainly, but Atom is quite popular, lately.
17:13:25 <Carcigenicate> Ok, thank you. I'll look into those.
17:13:48 <ProofTechnique> concept: I focused on pure math in school, rather than applied, so it was a joke
17:14:13 <erikd> edwardk: seems a lot of people are. i came a bit early to get over the jetlag before the actual conference :-)
17:14:16 <hodapp> minad: trampolining, I think, is a sort of manually-applied TCO
17:14:23 <edwardk> erikd: makes sense
17:14:26 <concept> ProofTechnique: that makes sense.. Thanks for the advice btw
17:14:45 <shachaf> Hmm, maybe I should go.
17:14:58 <shachaf> The trouble is that I have something which will take up a lot of time right afterward.
17:16:21 <minad> what conference is there?
17:16:42 <ProofTechnique> @unlet
17:16:42 <lambdabot>  Define what?
17:16:45 <ProofTechnique> @unlet primes
17:16:45 <lambdabot>  Parse failed: TemplateHaskell is not enabled
17:16:53 <ProofTechnique> @let sieve (x:xs) = x : sieve [y | y <- xs, rem y x /= 0]
17:16:54 <lambdabot>  Defined.
17:17:03 <ProofTechnique> @let primes' = sieve [2..]
17:17:04 <lambdabot>  Defined.
17:17:13 <ProofTechnique> > take 20 primes
17:17:15 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,49,53,59,61,67]
17:17:24 <ProofTechnique> > filter ((==0) . flip mod 7) primes
17:17:26 <lambdabot>  [7,49,77,91,119,133,161,203,217,259,287,301,329,343,371,413,427,469,497,511,...
17:17:31 <ProofTechnique> > filter ((==0) . flip mod 7) primes'
17:17:35 <lambdabot>  mueval-core: Time limit exceeded
17:17:42 <ProofTechnique> Gurkenglas: Better? :)
17:18:49 <Gurkenglas> Let's actually not look at that in the query. Taking a guess:
17:18:53 <Gurkenglas> > filter ((==0) . flip mod 11) primes'
17:18:57 <lambdabot>  mueval-core: Time limit exceeded
17:19:02 <Gurkenglas> dangit
17:21:11 <ProofTechnique> @let primes'' = sieve [60*k+x | k <- [0..], x <- [1, 7,11,13,17,19,23,29,31, 37,41,43,47,49,53,59]]
17:21:13 <lambdabot>  Defined.
17:21:21 <ProofTechnique> > take 20 primes''
17:21:25 <lambdabot>  mueval-core: Time limit exceeded
17:22:24 <gamegoblin> Is there a limit to the number of constructors a data type can have? INT_MAX?
17:24:17 <agocorona> gamegoblin:  I have tested it with five or six and it did not overflow
17:24:28 <gamegoblin> agocorona: ha
17:25:24 <lpaste_> schell pasted “Renderable” at http://lpaste.net/139800
17:25:26 <gamegoblin> I have something that has a very large but finite number of states, so I could represent them all with a constructor if I wanted, but it would end up being like 200K constructors
17:25:46 <gamegoblin> (I would of course generate and manipulate them programmatically)
17:25:54 <schell> i’m having some trouble with recursive types
17:25:55 <schell> ^
17:25:55 <schell> http://lpaste.net/139800
17:26:42 <schell> i’m getting a “Could not deduce …” and I know it’s because ghc can’t tell that the types of the elements match that of the outer Foldable
17:26:52 <schell> but i’m pretty sure there’s a way to notate that
17:27:13 <gamegoblin> schell: paste the error also
17:28:43 <lpaste_> schell pasted “err” at http://lpaste.net/139801
17:29:08 <schell> gamegoblin: ^ sorry about the funky syntax highlighting
17:30:29 <schell> gamegoblin: ah - i guess one problem is i’m using intercalate
17:30:45 <gamegoblin> schell: exactly, that assumes type list, but you only have Foldable
17:31:22 <schell> kk, that will at least get rid of one of the two
17:31:43 <schell> is there a more generic form of intercalate, or will i have to implement it myself?
17:32:11 <gamegoblin> schell: there is not an "intersperse" for Foldable, but you can implement it yourself, I actually just did it recently
17:32:41 <gamegoblin> there is a "concat" which is just "fold" where the elements of the foldable are monoids it will mappend them
17:32:45 <mniip> I think this spirit of intersperse is to return the original foldable, not a list
17:32:56 <mniip> which can't be done with Foldable
17:33:01 <gamegoblin> mniip: indeed
17:35:18 <gamegoblin> I wish there was an Uncons sort of typeclass that allowed you to split off elements from a collection sort of data type
17:35:51 <schell> gamegoblin, mniip: ah yeah, i need Traversable
17:36:09 <mniip> I don't think traversable can do that either
17:36:13 <Gurkenglas> gamegoblin, which element?
17:36:20 <mniip> monad + alternative maybe?
17:36:22 <gamegoblin> Gurkenglas: implementation defined
17:37:42 <Gurkenglas> Sounds like you want something with superclass foldable that defines uncons with the law unfoldr uncons = toList?
17:38:44 <gamegoblin> Gurkenglas: that would work, but I’d be fine with the less powerful law that unfoldr uncons simply has the same elements as toList
17:39:04 <gamegoblin> I just want the ability to split off an element at a time from a structure
17:39:11 <gamegoblin> don’t particularly care which
17:39:14 <Gurkenglas> (If fromList . toList were id by law and optimized away, you could just say "fmap fromList . uncons . toList"
17:39:16 <Gurkenglas> *)
17:41:18 <gamegoblin> A suitable type would be """ uncons :: U a -> Maybe (a, U a) """ which would yield Nothing if the structure were empty, 
17:42:25 <Gurkenglas> You aren't even requiring that the returned structure be different?
17:42:56 <gamegoblin> Gurkenglas: what do you mean by different?
17:43:17 <Gurkenglas> not equationally equal
17:43:38 <gamegoblin> How would you require that in the type system?
17:45:12 <apples> hi, i'm trying to enable profiling in my stack project and having some difficulty getting useful output. i did `stack build --executable-profiling --library-profiling' and then `stack exec orb-exe -- -p', but my output doesn't include any of my function names: http://codepad.org/wePNhDS7
17:45:20 <apples> what am i doing wrong?
17:46:17 <lpaste_> schell pasted “renderable instance” at http://lpaste.net/139802
17:46:32 <schell> okay - i simplified it, lol
17:46:56 <schell> the real problem is the ambiguous types - at least i’m assuming they’re ambiguous
17:47:52 <schell> how can i specify that m, r and t will always be the same in the list’s elements as it is in the list?
17:49:47 <Gurkenglas> Sorry, firefox keeps semicrashing for a while every once in a while. I would say x :: a == y :: a iff for every function f :: (a -> Bool), f x == f y
17:50:08 <schell> maybe this is a case for TypeFamilies
17:51:36 <arkeet> apples: don't you need to put some cost centres in your code.
17:52:03 <arkeet> or use -auto-all or something
17:53:50 <Gurkenglas> schell, I'm guessing from memory that that sort of bug can be helped by introducing functional dependencies into the type variables of your class
17:54:16 <Alas`> I know this is #haskell, but most people here seem to be experienced and knowledgeable, so here goes a general question: Who is responsible for the validity of the input to a function? Say I have a function that always expects an integer greater than or equal 0. Do I still have to check whether or not the input is less than 0?
17:55:06 <schell> Gurkenglas: that sounds useful - the functions that are giving me problems are the ones that only use one or so type variables
17:55:20 <schell> but how do i lock down the others?
17:55:26 <exio4> Alas`: in the perfect world, you'd specify that invariant in the type system 
17:55:41 <Alas`> exio4: How about a dynamically typed language?
17:56:05 <apples> arkeet, that's what i needed, thanks
17:56:16 <arkeet> np
17:57:31 <exio4> Alas`: I would document it and just use the function there, as handling corner case is pretty much impossible there
17:57:38 <gamegoblin> Alas`: I’d use an unsigned integer as the argument, poof, problem solved. 
17:57:57 <gamegoblin> Alas`: in a language like Java or Python or something, I would throw an IllegalArgumentException or the equivalent
17:58:17 <Gurkenglas> In Haskell, one either doesn't check, checks and crashes on failure or checks and returns Nothing on failure. Often, multiple ways are implemented and given different names.
17:58:17 <gamegoblin> Alas`: If it’s part of a public API that is. If it’s an internal function and I control everything calling it, I might not check it.
17:58:32 <exio4> and indeed, for this simple problem, it'd be that, I think he just was giving an example that's simple though,
17:58:47 <Alas`> Yes that was just an example
17:59:26 <apples> you could always make a smart constructor that checks your property
17:59:51 <exio4> Alas`: for something like Haskell, you would use a smart constructor, which is basically an abstract datatype with some constraint on it
18:01:03 <exio4> newtype NonZero = NonZero Int ; nonZero :: NonZero -> Int ; nonZero (NonZero i) = i ; nZ :: Int -> Maybe NonZero ; nZ 0 = Nothing ; nZ n = Just (NonZero n)
18:01:06 <gamegoblin> Even for something trickier like "number must be greater than 10" you can make a type like "data NumberGreaterThanTen = OffsetFromTen Word64" so when they construct the type like "OffsetFromTen 5" that represents the number 15.
18:01:15 <htebalaka> @hoogle throwE
18:01:15 <lambdabot> Control.Monad.Trans.Except throwE :: (Monad m) => e -> ExceptT e m a
18:01:15 <lambdabot> Foreign.C.Error throwErrno :: String -> IO a
18:01:15 <lambdabot> Foreign.C.Error throwErrnoIf :: (a -> Bool) -> String -> IO a -> IO a
18:02:29 <exio4> and if you don't want to have (un)wrappers, something like liquid haskell
18:02:47 <exio4> +would do it 
18:04:25 <Gurkenglas> schell, for an example, look at MonadState: "class MonadState s m | m -> s" gurantees that any m can only have one instance. Thus, when you use get the type checker does not need to worry about you saying which s you want to get out of an m.
18:04:51 <gamegoblin> But there are always tradeoffs. I wrote a chess engine in Haskell and initially made an enum for each square e.g. Data Square = A1 | A2 | … | F7 | F8 …, but that ended up being far slower than using Ints to represent coordinates.
18:05:26 <schell> Gurkenglas: ah, so ‘|’ denotes functional dependencies?
18:06:49 <nolrai66> gamegoblin: Thats odd. Shouldn't that be basicly the same after optimization?
18:07:27 <Gurkenglas> it starts the part of the class definition where the dependencies are listed. Google it for the exact syntax :P
18:07:52 <schell> Gurkenglas: thanks, i’m reading the wiki right now :)
18:08:04 <gamegoblin> nolrai66: apparently not. Manipulating them I think was the slowdown. e.g. Which square is above A1? Using ints you just add 1 to the y coordinate and you’re fine. With the enum you have to pattern match, which is presumably a few more CPU instructions.
18:08:22 <nolrai66> Oh, that is true.
18:13:08 <geekosaur> Enum? succ should be the same time as (1+)
18:13:22 <geekosaur> (hm, aside from the limit check...)
18:13:32 <geekosaur> (so I guess not)
18:13:45 <geekosaur> unsafeSucc anyone? :p
18:30:26 <noodles1> In the function: eGP c n = n:(concat ( map (eGP c) ( c n ))) , is the first argument to map, (eGP c), partial application of eGP?
18:30:41 <hpc> noodles1: yes
18:31:13 <shachaf> There's no such thing as "partial application" in Haskell, to a first approximation.
18:31:21 <shachaf> There's just application.
18:31:21 <hpc> :t let eGP c n = n:(concat ( map (eGP c) ( c n ))) in (eGP undefined)
18:31:23 <lambdabot> a -> [a]
18:32:38 <hpc> and yeah, currying makes using the right words for things rather bendy
18:32:40 <hpc> but that's the gist
18:33:35 <noodles1> hpc: a -> [a] is the function (eGP c) returns after the partial application, right?
18:47:27 <Tantrik> any PHP experts on here?
18:49:32 <ttt_fff> I want to master template haskell + quasiquotation. Is there some 100 page pdf I can print out, read, study, practice on, and become very good at TH + quasiquotation ?
19:02:51 * hackagebot jammittools 0.5.0.2 - Export sheet music and audio from Windows/Mac app Jammit  https://hackage.haskell.org/package/jammittools-0.5.0.2 (mtolly)
19:06:08 <Welkin> ttt_fff: there are several guides for TH
19:06:31 <Welkin> ttt_fff: https://wiki.haskell.org/Template_Haskell
19:06:55 <Welkin> you can also look through projects that use it heavily, like Persistent, Yesod, and pretty much anything by Michael Snoyman
19:12:39 <mniip> question
19:13:31 <mniip> how would I add a "By" suffix (meaning providing your own comparison function) to something called "isInfixOf"
19:22:02 <Welkin> lol, and edwardk reference to Daikatana?
19:22:19 <Welkin> Type Classes vs The World
19:40:50 <edwardk> =P
19:46:54 <Renato_Ferreira> Hey everyone. Does anybody here use intellij-haskell plugin?
19:47:13 <Renato_Ferreira> the intellij-haskell plugin *
19:59:01 <Taejo> is there a combinator for (\mf -> (mf <*>) . pure) (i.e. I have a function "inside" an applicative and I want to apply it to a pure argument)
20:00:16 <mniip> Taejo, \x -> fmap ($ x)
20:00:24 <exio4> Taejo: ($ x) <$> mf 
20:00:34 <mniip> fmap . flip id
20:01:23 <Taejo> so, no :) - it seems clearer to use do notation
20:01:41 <Zekka> I think all of those are more confusing than do notation.
20:02:29 <exio4> I think \mf x -> mf <*> pure x = \mf x -> ($ x) <$> mf is even an `applicative law` or so 
20:02:49 <Zekka> I wouldn't be as confused if I saw that as if I saw the pointless version, but I would still be confused
20:02:51 <mniip> [04:58:07] <Zekka> I think all of those are more confusing than do notation.
20:02:57 <mniip> except fmap
20:03:25 <Zekka> mniip: I think both of the fmap versions are as confusing as the other
20:03:42 <mniip> ($ x) is a pretty common functionnnnnnnnnn
20:03:46 <mniip> function*
20:04:27 <Zekka> It flips my expectation that when you use fmap, the transformation is the thing that's not in a context
20:04:38 <Zekka> To be clear, it's not that I don't understand it. It's that I'd be momentarily confused if I read it
20:04:48 <Zekka> Especially if it was in a context with more surrounding frou frou
20:05:04 <Zekka> I don't think I would ever be confused by the do notation version
20:05:23 <Zekka> I probably also wouldn't be confused if you spelled out the meaning of $ x using a lambda expression
20:05:30 <Welkin> I avoid do-notation whenever possible
20:05:38 <Welkin> I find it ugly and harder to read
20:05:57 <Welkin> I also don't like coming up with so many names for variables
20:06:01 <Welkin> x, x', x''
20:06:36 <Welkin> point-free can certainly be confusing sometimes though
20:09:22 <Welkin> :t flip id
20:09:24 <lambdabot> b -> (b -> c) -> c
20:09:59 <Zekka> Welkin: Yeah, once again, I knew that, but imho it's incredibly nonobvious
20:10:03 <Welkin> :t flip
20:10:04 <lambdabot> (a -> b -> c) -> b -> a -> c
20:10:12 <Welkin> Zekka: I got confused by that
20:10:13 <Welkin> :P
20:10:18 <Welkin> I was checking for myself
20:27:54 <Welkin> how does this even work?
20:28:22 <Welkin> flip :: (a -> b -> c) -> b -> a -> c
20:28:43 <Welkin> if you apply it to id :: a -> a, how is that not a type error?
20:29:12 <pyon> Welkin: Because `a -> a` and `a -> b -> c` *can* be unified.
20:29:14 <nshepperd> id :: (b -> c) -> (b -> c)
20:29:41 <Welkin> ahhhh
20:30:17 <Welkin> so then you substitute to get flip id :: b -> (b -> c) -> c
20:30:24 <pyon> Yep.
20:30:28 <Welkin> wow
20:30:29 <Welkin> that is cool
20:30:33 <pyon> ikr!
20:47:08 <matsuura> Hello guys!
20:48:35 <tmillc> matsuura: hi! 
20:50:51 <tmillc> matsuura :: ???
20:55:12 <Welkin> are there any good resources on type equality constraints?
20:55:32 <Welkin> the https://downloads.haskell.org/~ghc/7.10.2/docs/html/users_guide/equality-constraints.html
20:55:36 <Welkin> this is prety sparse
21:02:58 <tmillc> There used to be a link in the title containing a very good commentary on the different sites/methods of learning haskell
21:03:08 <ezyang> Is there a convenient way to read a file into a (Ptr a, Int); ala hGetBuf but automatically figuring out what the right buffer size is? 
21:04:43 <ezyang> oh, bytestring has the stuff I need 
21:09:48 <ReinH>  ezyang I was going to suggest mmap
21:12:30 <ezyang> not cross platform 
21:12:52 <ezyang> if there is a function in GHC's boot libraries that does this portably I'd love to know :) 
21:33:08 * hackagebot moesocks 0.1.1.0 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.1.0 (JinjingWang)
21:33:10 * hackagebot zalgo 0.1.0.0 - Z-algorithm implemented on haskell's built-in cons-cell-based lists.  https://hackage.haskell.org/package/zalgo-0.1.0.0 (mniip)
21:33:16 <mniip> meep
21:33:26 <hodapp> meep?!
21:33:42 <mniip> (I just uploaded a package)
21:34:30 <Hafydd> mneep
21:41:45 <mniip> can't wait for haddocks to see how much is broken
22:02:37 <ezrios> any preferences for extensible records?
22:02:39 <ezrios> CTRex or HList?
22:15:17 <ttt_fff> https://gist.github.com/anonymous/4091f8812cda6c62384d <-- is this possible to do in Haskell?
22:16:20 <MorpheusB> @map (+1) [1..10]
22:16:20 <lambdabot> Maybe you meant: slap msg faq
22:16:35 <Welkin> @faq
22:16:35 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
22:16:42 <Welkin> @slap lambdabot 
22:16:42 <lambdabot> go slap lambdabot  yourself
22:16:47 <MorpheusB> same problem I am having
22:16:57 <srhb> MorpheusB: > expression is the syntax
22:17:04 <MorpheusB> @slap lambdabot with bowl of icecream
22:17:04 * lambdabot slaps lambdabot with bowl of icecream with a slab of concrete
22:17:19 <ttt_fff> gentlemen, please move this into -blah
22:17:27 <MorpheusB> beginner pls explain
22:17:38 <srhb> > map (+1) [1..10]
22:17:40 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
22:17:42 <srhb> Like so.
22:17:53 <srhb> You can also talk to lambdabot privately if you don't want to spam the channel.
22:18:03 <Welkin> ttt_fff: make a Show instance for each type?
22:18:10 <MorpheusB> > map (+1) [1.10]
22:18:11 <lambdabot>  [2.1]
22:18:16 <MorpheusB> > map (+1) [1..10]
22:18:19 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
22:18:24 <MorpheusB> ahh
22:18:30 <mauris> ttt_fff: that sounds like a job for template haskell!
22:18:49 <ttt_fff> https://gist.github.com/anonymous/4091f8812cda6c62384d <-- is this possible to do in Haskell? <-- please note, we're wanting something that is almost "static", i.e. a function of the data definition, but not of any instance
22:20:50 <ttt_fff> mauris: yes, I think TH can pull this off
22:20:56 <ttt_fff> how do I master TH?
22:21:09 <mauris> i have no idea
22:21:10 <ttt_fff> someone needs to write Real World TH; or Learn you a TH for greatest good
22:21:57 <srhb> Have you tried searching for template haskell tutorial? There are a few out there, and if you follow along in them it's not all that complicated to get a basic grasp on it. From there it's just practice and reading docs. :-)
22:22:12 <ttt_fff> srhb: yes, I know how to use google
22:22:26 <ttt_fff> the tutorials are all very short and basic though, it appears
22:24:34 <srhb> That's usually enough to get started.
22:25:40 <LokiSnake> @type (.)
22:25:41 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:29:02 <yashinbasement> Hi Can any one suggest how to approach this prob https://gist.github.com/ynarwal/8c050038acdcdbc13186
22:30:13 <srhb> yashinbasement: You can start by not using Strings.
22:30:27 <srhb> yashinbasement: If you separate the octave information and the note information, things will be a lot easier.
22:31:16 <yashinbasement> did you mean data Pitche = Octave Note
22:31:37 <srhb> Yes something like that
22:31:52 <srhb> (But you're missing a value constructor there)
22:33:15 * hackagebot debian-build 0.8.0.0 - Debian package build sequence tools  https://hackage.haskell.org/package/debian-build-0.8.0.0 (KeiHibino)
22:35:26 <yashinbasement> oh yeah data Pitche = Pitche Note Octave
22:36:25 <srhb> yashinbasement: Yes :)
22:36:47 <srhb> yashinbasement: Once you have that, you can look at Data.List for things like intersection, (//) et al. They basically solve the entire problem statement. :)
22:36:55 <srhb> Oh, combines with filter.
22:37:04 <srhb> That should get you started :)
22:38:19 <yashinbasement> I can't use them , haha, due to some restriction of using libray function from Data.List
22:38:34 <srhb> Then I guess you'll have to implement them yourself ;)
22:42:59 <yashinbasement> how do I use numbers as Octave type, like it could be 1 or 2 or 3
22:43:27 <srhb> yashinbasement: For a rough approximation you could just use Int
22:43:38 <srhb> yashinbasement: Otherwise you can define data Octave = One | Two | Three ...
22:43:52 <yashinbasement> yeah but ..
22:43:59 <yashinbasement> it should be 1, 2, 3
22:44:47 <srhb> yashinbasement: That's not easily possible.
22:45:05 <srhb> yashinbasement: There's no way to restrict to a subset of Int in the type itself.
22:45:52 <srhb> yashinbasement: Anyway the representation of 1 as One shouldn't really be a problem. You can always make sure it's shown as numbers to the user afterwards.
22:50:16 <ttt_fff> OMG template haskell is the greatest extension ever; all the naysayers are wrong
22:50:27 <ttt_fff> this is going to increase the level of coolness one can do with haskell and type checking
22:51:42 <yashinbasement> show_ :: Octave -> Int
22:51:43 <yashinbasement> show_ el
22:51:43 <yashinbasement>   | el == One = 1
22:51:43 <yashinbasement>   | el == Two = 2
22:51:43 <yashinbasement>   | el == Three = 3,  It could be something like that
22:51:51 <Welkin> yashinbasement: your internal representation never had to leak out
22:52:02 <Welkin> you can define Show for your type as 1,2, and 3
22:52:11 <Welkin> yashinbasement: please use lpaste instead
22:52:13 <Welkin> @lpaste
22:52:14 <lambdabot> Haskell pastebin: http://lpaste.net/
22:52:23 <yashinbasement> yeah I will
22:52:49 <yashinbasement> so what's the prob
22:53:06 <Welkin> also, you want `show 1` or "1"
22:54:11 <Eliel> ttt_fff: it can certainly increase coolness, especially in giving you the ability to write code in ways no-one but yourself can understand. (no, that's not a good thing)
22:54:20 <Welkin> lol Eliel 
22:54:39 <Welkin> a lot of the Yesod hate stems from too much reliance on TH
22:54:41 <yashinbasement> like that http://lpaste.net/139813
22:54:59 <ttt_fff> Eliel: I'm going to do one better than that
22:55:04 <Eliel> (although, even if I state that, I do think it's a quite useful tool if used right)
22:55:08 <ttt_fff> I'm going to write code that not only no one else understands,
22:55:12 <ttt_fff> but even future-me won't understand either.
22:56:36 <Welkin> yashinbasement: http://lpaste.net/139813
22:56:42 <Welkin> I added an annotation
23:33:53 <cads> hey guys
23:34:00 <cads> quick question
23:35:31 <cads> I am writing python code where every meaningful function I call is of the form  rs.functionName(...). The rs object is just a python wrapper for some .net functions.
23:36:08 <cads> the code is CAD scripting language for the Rhino 3d CAD modelling package
23:36:44 <cads> Rhino is written in .net, in a SDK called Rhino.net.
23:38:16 <cads> The Rhino.net functions are wrapped up in a VB script language called Rhinoscript, and a practically verbatim python wrapper of those same functions, called Rhino Py
23:38:54 <cads> Additionally there is an addon called Grasshopper that lets you design graphical geometry and data processing work flows by connecting components together into a network
23:39:13 <mauris> this is the slowest quick question in my life :)
23:39:19 <matsuura> agreed
23:39:24 <matsuura> it gets better though
23:39:37 <mauris> yeah, do go on!
23:39:38 <cads> lol
23:39:41 <cads> http://api.ning.com/files/wD-b8tJJjO0zmMDpvQ-RAGRzM1jXZYsHHnKOhPSGCwBag*wKv0dZVpxgdtXhaLlf7Dux1efc381IK7OuJe67k7wsWSzK4L5B/error1.png
23:39:45 <cads> here's an example of the code
23:39:47 <cads> alright
23:39:58 <cads> my quick question is now ready to be asked
23:40:18 <cads> all of this is extensible by  .net/python
23:40:27 <cads> what can I do to make it extensible via haskell?
23:40:59 <cads> do I need to write a python script that runs on top of Rhino Py, but loads up haskell code on the low?
23:42:53 <cads> For example, I need to be able to call the python rs.SetDocumentUserText("key1", "value1")
23:44:21 <cocreature> there are several haskell->python bindings, e.g. https://hackage.haskell.org/package/HaPy but I haven't used any of them so I can't provide more info on that
23:44:48 <cads> im not sure what happens if you try to load the rhino py  "rs" object outside of the iron python context running inside Rhino when you execute a rhino py script.
23:45:29 <cads> would probably be unable to load
23:45:38 <cocreature> hm yeah that sounds like you need to go the other way around
23:45:51 <cads> oh
23:46:01 <cocreature> so python code that calls haskell code
23:46:05 <cads> write everything with custom haskell data types
23:46:06 <cocreature> I have no idea if there are any libs for that
23:46:15 <cads> and then call the code from python FFI
23:46:29 <cads> boom, suckafish
23:46:30 <cocreature> yeah you could always go via the c ffi
23:46:32 <glguy> It looks like the native Rhino SDK is in C++
23:46:49 <cads> rhino sdk is deprecated in favor of rhino.net
23:47:06 <cads> rhino 5 was rewritten in C#/rhino.net
23:47:45 <glguy> A C compatibility layer into the C++ API is still probably your best bet
23:47:49 <glguy> deprecated or not
23:47:57 <glguy> if your goal is to do automation in Haskell
23:48:19 <cads> why not a C#/F# door into the C# api :P
23:48:43 <glguy> Because you said you wanted to use Haskell
23:48:49 <cads> I'm not such a masochist that I'd use an SDK that is not going to be in rhino 6 :D
23:49:11 <cads> hmm, but I can call haskell libraries from python
23:51:28 <cads> glguy: here's an idea - I could spin up a haskell process using python. Then I can feed it JSON processing requests, and it feeds me back proccessed data.
23:52:24 <cads> Perhaps better is that I can also give the haskell process access to some local resources like the database
23:52:39 <mceier> cads: you could use hs-dotnet to generate wrappers for C#. it also can expose haskell functions as delegates in C#, so it should work both ways
23:52:39 <cads> that could be done via a bidirectional json stream, lol
23:53:07 <cads> mceier: I didn't know about the delegates
23:53:13 <cads> that's interesting
23:53:30 <cads> yeah, it totally doesn't have to run inside the CLR
23:54:28 <cads> cocreature: HaPy looks promising
