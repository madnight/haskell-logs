00:03:23 * hackagebot leksah 0.15.1.2 - Haskell IDE written in Haskell  https://hackage.haskell.org/package/leksah-0.15.1.2 (HamishMackenzie)
00:08:57 <lf94> Ok guys I'm really stuck. I can't wrap my head around how I'm going to do IO () in a function that returns State s a
00:09:34 <dramforever> you can't
00:09:44 <kadoban> lf94: Why do you except that you can/should?
00:09:56 <dramforever> if you are trying to do that, then you are not doing it the right way
00:10:07 <lf94> Hm
00:10:07 <dramforever> lf94: what are you trying to do?
00:10:21 <lf94> I'll take what you just told me then
00:10:30 <dramforever> lf94: what are you trying to do?
00:10:30 <lf94> I thought there might be a way
00:10:35 <dramforever> yes
00:10:40 <lf94> Just get input, act on input, and loop
00:10:48 <dramforever> oh sure there's a way
00:10:54 <lf94> I think I know what to do now though.
00:10:56 <dramforever> but you need to refactor the code a bit
00:10:59 <lf94> Yes :)
00:11:03 <dramforever> lf94: monad transformers!
00:11:11 <lf94> How are those going to help me
00:11:26 <dramforever> yes, you can do IO in StateT Foo IO a
00:11:43 <dramforever> as well as state manipulation
00:12:11 <lf94> Oh
00:12:14 <lf94> Then what the heck!
00:12:22 <lf94> That's what I was talking about then
00:12:28 <lf94> And you were telling me I couldn't >:o
00:12:35 <dramforever> your type is State s a
00:12:42 <dramforever> mine is StateT Foo IO a
00:13:02 <lf94> What's wrong with State Foo (IO a)
00:13:06 <lf94> Not the same?
00:13:10 <dramforever> lf94: your question is "how I'm going to do IO () in a function that returns State s a"
00:13:15 <lf94> oh
00:13:24 <lf94> I thought maybe they were the same
00:13:32 <lf94> Looking evalState again...
00:13:35 <kadoban> lf94: They're quite a bit different.
00:13:47 <dramforever> my answer is to this question "how you're going to do IO as well as having state manipulation"
00:13:55 <dramforever> the former is impossible
00:14:01 <kadoban> State Foo (IO a) would be a stateful computation that results in an (IO a)
00:14:03 <lf94> So I have my function foo :: State s a....and call evalState foo 1
00:14:18 <lf94> I'm totally lost as to where StateT would fit into this
00:14:28 <dramforever> :t state
00:14:29 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
00:14:34 <dramforever> hmm...
00:14:36 <dramforever> :t runState
00:14:37 <lambdabot> State s a -> s -> (a, s)
00:14:48 <dramforever> lf94: you can 1. change the type
00:14:58 <dramforever> to StateT S IO a
00:15:03 <lf94> I was thinking maybe just do IO outside of it...
00:15:09 <dramforever> that's also ok
00:15:18 <dramforever> lf94: can you share your code?
00:15:23 <lf94> Yeah of course :)
00:15:29 <dramforever> @where lpaste
00:15:29 <lambdabot> http://lpaste.net/
00:15:51 <lf94> https://gist.github.com/4d09e6713a318cad65ce
00:15:54 <dramforever> ok
00:16:00 <lf94> Sorry, I use yagist in Emacs
00:16:12 <lf94> If you *really* want I can use lpaste.
00:16:33 <dramforever> yes I really want, stupid ISP changed the certificate of gist
00:16:41 <lf94> Ok :)
00:16:56 <dramforever> now it's not only insecure but so insecure that firefox refuses to load it
00:17:18 <lpaste_> lf94 pasted “hangman working on state monad hi dramforever” at http://lpaste.net/5050618533478662144
00:17:25 <dramforever> lf94: nice =)
00:18:10 <lf94> dramforever, so you see in looper, that I'm doing things like getChar
00:18:34 <kadoban> dramforever: Your ISP messes with certs? O.o
00:18:40 <dramforever> yes
00:18:41 <dramforever> China
00:18:44 <lf94> Now this is fairly easy to refactor so it's done separately
00:18:56 <lf94> But using StateT sounds like an interesting learning experience :)
00:19:00 <kadoban> dramforever: Oh. :-/
00:19:47 <dramforever> lf94: 1. change your import to import Control.Monad.State.Lazy
00:20:07 <lf94> Ok done
00:20:10 <dramforever> 2. change your type to StateT HangmanState IO ...
00:20:24 <lf94> For looper?
00:20:42 <dramforever> everywhere
00:20:51 <lf94> ererrrrrr
00:20:51 <dramforever> oh I guess everywhere == looper
00:20:54 <dramforever> sorry
00:21:11 <lf94> Ok but that leaves us with type mismatch for evalState, right/
00:21:11 <dramforever> I thought there were more monadic functions
00:21:12 <lf94> ?
00:21:19 <dramforever> yes mismatch, don't worry
00:21:32 <lf94> looper ::  StateT HangmanState IO Bool
00:21:34 <lf94> How's that
00:21:42 <dramforever> that's great
00:21:44 <lf94> :D
00:22:06 <dramforever> http://hackage.haskell.org/package/transformers-0.4.3.0/docs/Control-Monad-IO-Class.html
00:22:12 <dramforever> use liftIO to wrap the getChar
00:22:18 <dramforever> oh you need to import this module
00:22:41 <dramforever> and, get rid of the return $ evalState
00:23:43 <lf94> replaced it with a bunch of question marks :)
00:23:52 <dramforever> oh?
00:24:03 <lf94> (what the hell is supposed to go there now)
00:24:47 <dramforever> oh change to something like this  False -> do put (HangmanState word' (guess+1,guesses) (userChar:guessed))
00:24:50 <dramforever>               looper
00:24:55 <dramforever> of course line them up
00:25:39 <lf94> dramforever, I'm lost now. Why am I using liftIO (something that lifts something from one monad to another, in this case IO to StateT), but changed the type to StateT HangmanState IO Bool?
00:25:48 <lf94> I don't have any IO at all anymore
00:25:57 <dramforever> you have it lifted
00:25:58 <lf94> since liftIO takes care of that
00:26:26 <lf94> IO (Char) -> State (Char)
00:26:26 <dramforever> it should be like like userChar <- liftIO getChar now
00:26:33 <lf94> Yea it is
00:26:42 <dramforever> and what's the problem?
00:27:05 <lf94> dramforever, I don't know why we change the type signature to StateT HangmanState IO Bool
00:27:18 <lf94> Since we're taking care of IO with liftIO
00:27:38 <dramforever> interestingly, your question is the answer
00:27:54 <dramforever> because liftIO lifts IO a into StateT HangmanState IO a in this case
00:28:32 <dramforever> get it?
00:28:41 <lf94> ...StateT HangmanState IO is a monad?
00:28:45 <dramforever> yes
00:28:55 <lf94> crazy
00:29:01 * dramforever is trying to first get the code working
00:29:04 <dramforever> then explain why
00:29:15 <lf94> lol
00:29:34 <dramforever> I'm walking you through the code this time, but you need to read more about those monad transformers stuff
00:29:43 <lf94> Yeah I'm going to right now
00:30:12 <dramforever> so now looper should type check, but hangman has a type error
00:33:24 * hackagebot cabal-helper 0.4.0.0 - Simple interface to some of Cabal's configuration state used by ghc-mod  https://hackage.haskell.org/package/cabal-helper-0.4.0.0 (DanielG)
00:37:17 <lf94> dramforever: So our goal with StateT, is to get m (State s a)
00:37:28 <lf94> (In our case, IO (State s a)
00:37:30 <lf94> )
00:37:33 <dramforever> yes, evalStateT is going to do exactly that
00:37:39 <lf94> Excellenttttt
00:37:44 <dramforever> well...almost
00:37:48 <dramforever> lf94: check the types
00:37:51 <lf94> Ok I think I know what to do
00:37:53 <lf94> Yeah
00:38:01 <dramforever> I assume you know how to continue from here
00:38:20 <dramforever> I've got you started, now read more about monad transformers
00:38:26 <lf94> >MonadTrans implements the lift function, so we can take functions from the m monad and bring them into the MaybeT m monad in order to use them in do block
00:38:34 <lf94> Yeah it all makes sense now
00:38:45 <lf94> https://en.wikibooks.org/wiki/Haskell/Monad_transformers
00:38:50 <lf94> Really helpful article
00:39:11 <dramforever> =)
00:40:33 <lf94> Wouldn't it be considered bad practice to mix IO with other monads?...
00:40:41 <dramforever> no
00:40:54 <lf94> Since you're mixing...non-pure shit with everything
00:41:02 <lf94> Sure it's less convenient
00:41:08 <lf94> er
00:41:21 <lf94> less convenient not to mix IO with others
00:45:04 <Gurkenglas> If you're gonna have to execute IO actions, this allows you to while saying in the type signature that it is the case and marking with "liftIO" each line that is IO. Writing StateT s IO () functions is as bad a practice as writing IO () functions.
00:45:29 <lf94> Gotchya.
00:49:20 <SrPx> What again should you do when you install a library (Lens) and you still get the message: "Could not find module ‘Control.Lens’ Perhaps you haven't installed the "js" libraries for package ‘lens-4.7’?" ... this is for ghcjs, but I think the process is the same. I recall it having something to do with duplicated libs.
00:49:53 <dramforever> "js" libraries
00:50:02 <dramforever> are you sure cabal compiled for ghcjs?
00:50:10 <dramforever> I mean, cabal compiled lens for ghcjs
00:51:12 <SrPx> I'm not *sure*, but I ran "cabal install --ghcjs lens" and it seems like all worked.
00:51:23 <SrPx> In a sandbox, also
00:52:12 <SrPx> Oh I think I installed the wrong version, let me try again.
00:52:17 <saulzar> You sound surprised?!
00:52:42 <SrPx> saulzar: me?
00:52:48 <saulzar> yes
00:52:59 <SrPx> I'm not surprised why?
00:53:42 <Gurkenglas> lf94, also StateT s m a is not m (State s a) = m (s -> (a, s)) but s -> m (a, s)
00:54:05 <saulzar> Alright. Just sounded like you might not have expected it to work.
00:57:07 <SrPx> Oh still doesn't work after specifically installing lens-4.7
00:57:10 <SrPx> Weird.
00:57:23 <ttt_fff> http://www.rebar3.org/docs/basic-usage <-- okay, so after rebar new app foo; rebar compile; how do I run it?
00:57:31 <ttt_fff> hehe, wrong chanel
00:58:40 <saulzar> SrPx, What are you trying to compile? (other than lens..)
00:59:47 <SrPx> Posted all details here: http://lpaste.net/138390
01:00:48 <dramforever> SrPx: add -v?
01:00:49 <saulzar> command to compile aff.hs ? 
01:01:01 <SrPx> Just "ghcjs aff.hs"
01:01:18 <saulzar> Trouble there is it won't use the sandbox..
01:01:50 <saulzar> Not sure if you can do:  cabal exec -- ghcjs --make aff.hs
01:02:00 <saulzar> I suspect that won't work either
01:02:01 <lf94> Gurkenglas, almost same idea :)
01:02:20 <lf94> Gurkenglas, yeah I see that now: runStateT :: s -> m (a, s)
01:02:35 <SrPx> dramforever: updated
01:03:06 <SrPx> saulzar: still can't find control.lens
01:03:52 <dramforever> SrPx: does it search inside the sandbox this time
01:03:53 <dramforever> ?
01:04:14 <SrPx> how do I tell?
01:04:25 <saulzar> this bit "Using binary package database:" from the -v
01:04:49 <saulzar> (Should point to the local directory if it's using the sandbox)
01:07:24 <dramforever> -v
01:07:30 <dramforever> http://lpaste.net/138390#line49
01:08:01 <dramforever> oh sure
01:20:51 <fishburne> Using the latest stackk, I can compile my project. But when I try to run ghci in the contex, it shows missing dependencies....Why?
01:23:01 <tdammers> because vanilla ghci doesn't pick up sandboxes by default?
01:23:30 <tdammers> I'm not familiar with stack, but with cabal sandboxes, you need to say 'cabal repl' or 'cabal exec ghci' instead of just 'ghci'
01:23:33 <fishburne> tdammers: I am using Stack's ghci
01:23:36 <tdammers> hm
01:23:40 <tdammers> no clue then
01:23:52 <tdammers> I only use the cabal.config from stackage
01:28:59 <sgronblo> Is there some theoretical/practical limit in Haskell to how deep or granular you can make your data types?
01:29:27 <sgronblo> as in data Stupid = One | Two | Three | ... | OneGazillion
01:31:17 <dramforever> I think there's a practical limit because I saw a comment in GHC.Tuples
01:31:34 <dramforever> Adding more leads to segfaults
01:31:35 <dramforever> s/Tuples/Tuple
01:31:44 <dramforever> http://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/src/GHC-Tuple.html#%28%29
01:32:14 <gfixler> Which of the many Haskell FRP libraries don't make conal cry?
01:33:00 <gfixler> Sodium seems out, as it's all about discrete time
01:35:25 <fishburne> tdammers: It worked when I gave the name of my main source file as argument...
01:35:54 <tdammers> heh
01:36:10 <tdammers> maybe that's by design, idk - really, I have absolutely no clue about stack itself
01:37:43 <fishburne> tdammers: Yes. no problem. This is fine by me. Just told fyi...
01:38:15 <tdammers> k
01:41:35 <EvanR> gfixler: none of them
01:41:53 <EvanR> except maybe reactive
01:44:02 <gfixler> EvanR: :(
01:44:10 <gfixler> that's hard to believe
01:44:24 <EvanR> yeah reactive might also
01:44:27 <EvanR> lol
01:44:30 <gfixler> if the idea is so simple, someone should at least have a toy/weekend-project up somewhere that does the right thing
01:44:42 <EvanR> i do, want to see the youtube video?
01:44:43 <EvanR> ;)
01:44:51 <gfixler> YES
01:45:08 <gfixler> do you build a small, working, FRP toy from start to finish?
01:45:23 <EvanR> no just gratuitous screencast of a window
01:45:41 <EvanR> and my project has fallen into disrepair since then
01:45:45 <EvanR> :(
01:45:59 <gfixler> aww
01:46:21 <phaazon> hi
01:46:32 <EvanR> also phaazon has a frp project
01:46:48 <gfixler> is it a small, working, FRP toy demoed from start to finish?
01:47:20 <phaazon> I think everyone has a FRP project in work in progress :)
01:47:45 <phaazon> I have a library on hackage that uses instead of FRP; check for « event » on hackage
01:47:50 <gfixler> I want like, <1 screen of stuff in a single file
01:47:52 <phaazon> that I use*
01:48:02 <gfixler> just the basics conal outlined, but working
01:48:12 <gfixler> I'm not *quite* good enough to translate it all myself
01:48:21 <EvanR> gfixler: i made a piano keyboard which fits to the window, lets you play midi events on it (mouse or keyboard or BOTH!!!) and randomly has space invaders following behind the mouse cursor
01:48:39 <gfixler> EvanR: where?!
01:48:47 <EvanR> the relevant 1 screen of stuff is in the video, i sent you a pm link
01:49:00 <gfixler> EvanR: hmm... no notification here (*goes looking*)
02:16:00 <hio> why are there so many people in this room?
02:17:07 <hio> nobody builds real products with haskell
02:17:08 <EvanR> ikr
02:17:44 <dramforever> "nobody builds real products with haskell" false
02:18:05 <dramforever> example: facebook spam filter
02:18:15 <dramforever> rather, counterexample
02:19:31 <hio> when i look at the haskell homepage, i see a few non features like "statically typed" <- ok great, so this is either good or bad depending on whether you like it.  "purely functional" <-who cares and it's not even true in the strictest sense, "type inference" <-- tiny non-feature, it's the "var" keyword <-- "lazy" <-- no idea what that means and I cant read haskell that well so the explanation on the homepage doesnt mean anything to me
02:19:41 <dramforever> hio: ^
02:20:14 <dramforever> oh you're new to haskell
02:20:57 <dramforever> or are you?
02:21:13 <hio> yeah so MAYBE the homepage explanations should be in a way that explains to a newcomer
02:21:36 <dramforever> hio: types are a great deal in haskell
02:21:51 <dramforever> yes I agree that the homepage kinda sucks...
02:21:51 <hio> i dont see how, homepage doesnt tell me that
02:22:56 <dramforever> hio: yes I agree with you
02:24:41 <tdammers> hio: types are such a great deal in haskell that I think it's safe to say that programming in Haskell is first and foremost about the types
02:25:04 <hio> tdammers: okay so where do i report a bug for the haskell website?
02:25:10 <hio> github doesnt have a repo for that
02:25:32 <tdammers> hio: idk, I don't really use it, and I'm not involved in it in any way
02:26:25 <saep> https://github.com/haskell-infra/hl
02:26:39 <frerich> hio: Are you talking about haskell.org ? At the bottom of the page it says 'Got changes to contribute? Fork or comment on Github' with a link to a GitHub repo.
02:27:51 <ely-se> hio: you will know what laziness means if you read the text under the headline
02:28:17 <tdammers> also, if you consider "static typing" a non-feature, then either you don't know what the term means, or what it can do for you, or you have already made a conscious choice against it, in which case Haskell isn't the right tool for you
02:28:39 <ttt_fff> if I need haskell and erlang to communicate, is json the best way to go ?
02:28:59 <ely-se> ttt_fff: use the Erlang interop package
02:29:21 <ttt_fff> ely-se: link?
02:29:25 <ttt_fff> I'm getting SO questions
02:29:27 <ttt_fff> is this a library?
02:29:34 <ttt_fff> some data.genric for auto deriving serialization?
02:29:47 <ely-se> well, there is the erlang package
02:29:55 <ely-se> but it's not being maintained since 2008 lol
02:30:06 <mazur> what is the haskell emacs room called?
02:30:15 <srhb> #haskell-emacs
02:30:16 <matsuura> #emacs
02:30:27 <ttt_fff> #hell
02:30:30 <mazur> srhb: oh the dash :)
02:30:39 <quicksilver> tdammers: or, you've been trolled :P
02:30:46 <ely-se> ttt_fff: both Haskell and Erlang have good ZeroMQ libraries. You could use that with a serialization library of choice
02:30:48 <tdammers> quicksilver: NEVER!
02:30:59 <EvanR> hio: how would you describe PHP to a "new comer" without literally talking about the features it has by their names?
02:31:03 <ttt_fff> ely-se: hmm, I think there's two separate questions
02:31:08 <EvanR> sounds hard
02:31:19 <ttt_fff> (1) how to serialize / deserialize the data and (2) how to send tha ctual bits (zeromq, network, http)
02:31:24 <hio> ely-se: i read the text but it doesnt make sense to me anyway
02:31:29 <tdammers> although, telling the X community that X doesn't even Y tends to be the most efficient strategy for figuring out how to do Y in X
02:31:45 <ttt_fff> haskell doesn't have a polynomial time 3sat solver
02:31:52 <hio> EvanR: I would explain the syntax first and then explain why feature X benefits the language. 
02:31:52 <ttt_fff> haskell cant solve the hlating problem
02:31:59 <EvanR> hio: on the homepage?
02:32:01 <srhb> hio: I just reread the text. It's not horrible, really. People who work in this sphere of programming languages know what purely functional means, for instance, and it is an important feature.
02:32:24 <hio> yes, because nowadays most people dont know the functional syntax, they are accustomed to c syntax. You have to explain the functional syntax
02:32:35 <srhb> Screw the syntax, that's mostly irrelevan.
02:32:43 <EvanR> people who dont know the C syntax.. what about them
02:32:58 <hio> everybody who has ever learnt programming in an institution knows c syntax
02:33:02 <ely-se> ttt_fff: another option is ports
02:33:03 <hio> which is 95%
02:33:04 <tdammers> there is no such thing as functional syntax
02:33:08 <EvanR> everybody who has ever learned haskell knows haskell syntax
02:33:12 <tdammers> syntax and programming paradigm are orthogonal
02:33:23 <hio> you are not trying to understand me at all, fine. the homepage is perfect
02:33:38 <tdammers> we understand you fine, we just disagree
02:33:54 <ttt_fff> most if haskell `syntax` is a matter of haskell's infix system
02:33:55 <srhb> hio: Sure, but I'm just a bit puzzled by (some of) your complaints. I agree that the homepage could uses improvements on certain points, but the ones where you think it's worst, I just disagree.
02:34:06 <EvanR> programming is mostly not about syntax
02:34:19 <srhb> hio: regardless, thanks for bringing to our attention things that you consider errors. :)
02:34:32 <tdammers> maybe it helps if we tell you that the purpose of the haskell.org website is to provide information about Haskell, and not necessarily about programming concepts in general
02:34:37 <tdammers> there are other places to learn aboutthose
02:35:03 <EvanR> youre already obviously interested in haskell so time to drill down further than the homepage
02:35:13 <ely-se> syntax: https://wiki.haskell.org/Wadler%27s_Law
02:36:16 <hio> also the fact that there is a haskell "platform"
02:36:20 <hio> wtf all i want is a single binary
02:36:33 <EvanR> then get the ghc binary
02:36:40 <EvanR> thats what i do
02:36:43 <srhb> Me too
02:36:49 <srhb> Note that it's still big, though.
02:36:51 <ely-se> this is a great moment to test the /ignore command of my new IRC client
02:36:54 <srhb> (But it's just a big compiler. :))
02:37:19 <mazur> i guess i'll ask here since haskell-emacs is pretty dead atm: has anyone had the problem of files "double" saving in haskell-mode? file saves but always the last message is (No changes need to be saved) 
02:37:31 <mazur> only happens with haskell-mode
02:37:37 <dramforever> I would agree that lazy-by-default sucks, but the rest are pretty nice
02:37:45 <ely-se> I implemented type inference yesterday and it was a delightful experience.
02:37:55 <EvanR> no lazy is awesum
02:38:05 <bennofs> dramforever: lazy let bindings are really useful. But lazy record fields? less so
02:38:16 <tdammers> lazy record fields can be quite useful
02:38:20 <dramforever> lazy-by-default arithmetic sucks
02:38:31 <EvanR> strictness analysis
02:38:33 <tdammers> but lazy-by-default on records is probably not ideal
02:38:35 <bennofs> tdammers: yes, but not in 70% of cases or so
02:38:41 <ely-se> I/O being lazy by default is very bad. Other than that I don't mind laziness; it's convenient and allows for a more declarative programming style.
02:38:46 <dramforever> well by that I mean we should never be able to build up thunks of (+) or something
02:38:55 <srhb> I think it would be way worse to have different standards of *-by-default depending on context
02:39:00 <tdammers> also, I find it kind of unfortunate that while Haskell is extremely explicit about effects, strictness is almost completely implicit
02:39:03 <EvanR> IO isn't lazy by default, except getContents and readFile
02:39:13 <srhb> Lazy by default is the right choice (because very smart people said so!) and then you can make things strict as you see fit.
02:39:15 <srhb> :-)
02:39:20 <ely-se> yes, those functions shouldn't be lazy
02:39:22 <ely-se> it's dangerous
02:39:27 <bennofs> srhb: you might like hearing about the -XStrictData extension then :) (or are you already refering to that)
02:39:32 <EvanR> they should go in a loony module
02:39:33 <quicksilver> what getContents and readFile manifest isn't laziness
02:39:37 <srhb> Also I use lazy IO to great effect.
02:39:37 <tdammers> import System.IO.Strict -- problem solved!
02:39:46 <quicksilver> it's interleaved IO which is, indeed, dangerous
02:39:48 <hio> haskell is not purely functional, the homepage is lying
02:39:54 <srhb> hio: Oh?
02:39:55 <tdammers> hio: elaborate
02:39:57 <ely-se> it is
02:39:58 <quicksilver> and it gives laziness a bad name - since laziness doesn't afect semantics.
02:40:03 <dramforever> hio: well don't be *that* strict
02:40:05 <hio> IO always has sideeffects
02:40:09 <tdammers> no
02:40:16 <tdammers> IO always has *effects*
02:40:21 <hio> nope
02:40:21 <dramforever> > print 1 -- nothing happened
02:40:23 <lambdabot>  <IO ()>
02:40:25 <srhb> hio: You're going to need to dive in further to Haskell to really understand the distinction here. :)
02:40:27 <hio> but something CAN happen
02:40:28 <EvanR> IO values dont have any effect by their own
02:40:29 <ely-se> no, in Haskell you don't do I/O. you return a description of what I/O to do
02:41:02 <tdammers> for some values of "return" ;)
02:41:04 <darenthis> ghc argument question: is -Wall a superset of -W ?
02:41:08 <ely-se> well, bind to main
02:41:15 <srhb> hio: In order to get side effecty behaviour in Haskell you'd need to use something like unsafePerformIO (after which, all bets are off!)
02:41:17 <dramforever> > readFile "/etc/passwd" -- what do you mean by "something CAN happen?"
02:41:18 <lambdabot>  <IO [Char]>
02:41:23 <dramforever> hio: ^
02:41:30 <hio> haskell allows to keep state. that is not functional
02:41:36 <srhb> It certainly can be.
02:41:40 <ely-se> > unsafePerformIO (readFile "/etc/passwd")
02:41:41 <lambdabot>  Not in scope: ‘unsafePerformIO’
02:41:42 <tdammers> haskell can pass state around
02:41:46 <ely-se> all my dreams shattered ;_;
02:41:46 <srhb> hio: For instance, you can pass around state in arguments.
02:41:51 <EvanR> state is in your head
02:41:53 <srhb> hio: Which we have nice ways of abstracting :)
02:41:56 <tdammers> but that's not impure
02:42:06 <srhb> No, it's purely functional.
02:42:09 <EvanR> a fold operation has state 
02:42:31 <dramforever> hio: how about this: I just told evaluate to evaluate those two expressions
02:42:32 <srhb> We sould probably say mutability instead of state.
02:42:47 * bennofs doesn't think that all this discussion about how Haskell is/isn't "purely functional" is very insightful
02:42:50 <ely-se> Haskell is drugs without the side-effects.
02:42:53 <dramforever> do you think the 1 is printed? do you think the file is accessed?
02:43:02 <BartAdv> huh, just used view patterns for something like: http://lpaste.net/7951802408588279808. pretty cool. dunno if I'm still on 'readable side', but just wanted to elevate some maybe check to the signature level
02:43:29 <ely-se> BartAdv: that redirects to the lpaste homepage
02:43:30 <tdammers> one way or another, "Haskell is a purely functional language" isn't a lie
02:43:43 * dramforever is worried about hio
02:43:51 <bennofs> hio: even if haskell isn't purely functional in your view, it still allows you to separate the purely functional part from the "impure" part and guarrante that you don't do impure stuff in pure code
02:43:55 <dramforever> maybe he/she has been scared
02:44:09 <dramforever> hio: are you still okay with it?
02:44:55 <ely-se> is "hio" an abbreviation of "Haskell I/O"?
02:45:08 <bennofs> tdammers: well... what do you say to primops or unsafePerformIO? "Don't use those!"?
02:45:30 <tdammers> bennofs: point in case
02:45:32 <ely-se> bennofs: they're not part of Haskell
02:45:41 <ely-se> the Haskell report doesn't mention them
02:45:44 <tdammers> bennofs: "those should not exist, I refuse to acknowledge that they do!"
02:45:46 <EvanR> unsafePerformIO strikes again
02:45:59 <tdammers> unsafeEndConversation
02:45:59 <EvanR> defeating any sound argument
02:46:13 <srhb> Well, arguably purely functional is about expectations.
02:46:25 <srhb> I expect missiles when I unsafePerformIO
02:46:26 <srhb> :P
02:46:40 <lf94> dramforever, I did it! :)
02:46:47 <ely-se> I expect babies when I unsafely go in and out
02:46:48 <lf94> dramforever, that was loads easier than I anticipated.
02:46:49 <dramforever> oh good for you
02:46:50 <tdammers> I guess the important part is that limiting your usage of Haskell to a purely functional subset is trivially easy
02:47:12 <darenthis> this takes me back about a decade to Java developers arguing about reflection. Because it's _possible_ to defeat the type system, might as well not bother using types, anywhere, ever.... sigh
02:47:19 * dramforever wonders where hio went to
02:47:26 <srhb> darenthis: Thankfully that's not the conclusion most of us arrive at :P
02:47:28 <hio> my point is that if haskell isnt pure anyway then what's the point. Just make it more accessible like c# or java
02:47:41 <srhb> hio: Why would you make it more like c# or java?
02:47:43 <lf94> hio: the majority of haskell is pure though
02:47:46 <srhb> Even if we agreed with your premise.
02:47:50 <dramforever> hio: and do you include unsafe stuff?
02:47:58 <srhb> hio: We already *have* c# and Java.
02:48:06 <tdammers> again, limiting yourself to the pure functional subset of Haskell is easy
02:48:10 <hio> srhb: c# and java are really easy to understand and work with
02:48:15 <EvanR> not for me
02:48:16 <ely-se> If everything is C# or Java, then C# and Java can't be improved as much since there'll be little innovation
02:48:18 <tdammers> just don't use unsafePerformIO and primops
02:48:18 <srhb> Disagreed.
02:48:19 <saep> Java is a nightmare to work with.
02:48:29 <saep> But that's just personal experience. :-)
02:48:31 <ely-se> hio: only because *you* are more familiar with them
02:48:39 <srhb> Haskell may have a slightly steeper learning curve if you've never worked in PFP with strong types, but it's infinitely easier to work with.
02:48:41 <dramforever> hio: without those unsafe stuff you can't have side effects while evaluating your expressions
02:48:52 <tdammers> java and C# are easy when they form your comfort zone, but that can be said of anything
02:48:57 <darenthis> When I first learned haskell, it felt like the compiler was punishing me. Now it feels more like a stern discussion :)
02:49:04 <srhb> darenthis: This :)
02:49:09 <dramforever> > print 23333 -- again, example
02:49:10 <lambdabot>  <IO ()>
02:49:15 <ely-se> I never got a type error in Haskell.
02:49:44 <tdammers> the only runtime errors I ever get in Haskell tend to be due to FFI calls into unsafe C libraries, and to partial functions
02:49:54 <hio> the homepage just needs to explain in a few sentences how to do a hello world, how to write a file and read it, how to send an http request and receive the response and how to access an SQL database. That's what people care about. Not whether lazy types are purely functional enough. 
02:50:06 <srhb> hio: I think you're mistaken.
02:50:16 <srhb> hio: That's not really the needs that Haskell fulfill that OTHER languages don't.
02:50:23 <bennofs> hio: that actually sounds like a good point to me
02:50:23 <darenthis> hio: I agree that cookbook style examples are very useful
02:50:29 <srhb> hio: What we get is a lot more sanity, and it's nontrivial to show in a short way.
02:50:29 <dramforever> hio: agreed
02:50:30 <hio> those are basics that every language needs to be able to do
02:50:41 <ely-se> no, that's wrong
02:50:43 <EvanR> hio: examples for all that stuff are listed at the top of each library that do those things
02:50:49 <EvanR> in the docs
02:50:51 <dramforever> yes, I agree that the haskell homepage lacks a lot real-world stuff
02:50:54 <hio> ely-se: i thought you wanted to ignore me?
02:50:59 <ely-se> such examples would be silly on the homepage of Coq, for example
02:51:04 <bennofs> you could even demonstrate the usefulness of IO by showing that you implement for / while / other looping monadic constructs in haskell yourself!
02:51:08 <srhb> I think most of the "real world" approaches are horrible.
02:51:16 <srhb> People need to be motivated to learn types first and foremost.
02:51:21 <ely-se> hio: I would but it just got funny
02:51:22 <tdammers> also, https://www.haskell.org/documentation lists 9 (!) introductory books
02:51:29 <srhb> Otherwise we get the endless "why don't this work" in here, and people eventually give up.
02:51:31 <lf94> dramforever, time to make this a hackage package...haha
02:51:33 <hio> im not saying that those are great examples for Haskell. But if i want to learn haskell, those are the things i care about and would help me grok haskell the fastest way
02:51:39 <tdammers> as well as a bunch of tutorials, courses, and online resources
02:51:47 <dramforever> hio: I doubt if it's true
02:51:59 <tdammers> anyway, if you want a practical hands-on guide to learning haskell, try Real World Haskell
02:52:00 <dramforever> wait
02:52:02 <solarus> hio: you could look at examples at rosettacode
02:52:05 * dramforever remembered something
02:52:06 <bennofs> hio: it will probably not help you grok haskell the fastest way, but it'll at least motivate you to learn haskell :D
02:52:11 <tdammers> (with the caveat that it is somewhat outdated in terms of library usage)
02:52:15 <darenthis> I only just discovered wreq last week. Really nice tutorial http://www.serpentine.com/wreq/tutorial.html
02:52:16 <dramforever> https://wiki.haskell.org/Hitchhikers_Guide_to_the_Haskell
02:52:22 * srhb shrugs
02:52:32 <solarus> gives a nice comparison to several PLs on the same page which is nice
02:52:32 <frerich> hio: I'm not sure whether 'This is how you read a file' or 'This is how you do a HTTP GET' examples would actually get me interested in some programming language. I kinda assume they all can do that anyway. I'd rather be interested in distinguishing features which let me tell whether I'd like to learn more.
02:52:54 <hio> look here is what I want to have when I try a new language: wget language.com/compiler | sh execute "hello world" and it should work. And then there should be a directory full of sample files on the things i listed above
02:53:07 <tdammers> yeah... those things are kind of the minimum requirements to qualify as a useful general-purpose programming language
02:53:22 <srhb> and eventually someone will try deleteSpaces (readFile "/blah") and get very frustrated with that approach.
02:53:22 <EvanR> if youre good for the rest of the year maybe santa will give these to you
02:53:25 <tdammers> also, never ever pipe wget output to sh
02:53:40 <ely-se> piping wget output to sh is fine
02:53:41 <bennofs> tdammers, frerich: and that's why it's important for them to be on the home page, because many people think of Haskell as a reac
02:53:50 <bennofs> as a research language that cannot do this :p
02:53:55 <ely-se> it's not any more dangerous than first download the file and then passing it to sh without inspecting it first
02:54:03 <hio> right now haskell is a toy language because i have to read a book in order to write a file out
02:54:06 <hio> it's that simple
02:54:10 <tdammers> ely-se: it is, when your network connection dies in the middle of a command
02:54:14 <srhb> hio: That's just a plain lie.
02:54:23 <srhb> hio: Just because it's not on the homepage certainly means you can't find it :P
02:54:25 <EvanR> hio: thats in the docs
02:54:25 <xbinbashx> hi everyone
02:54:27 <bennofs> tdammers: that's why you write your shell scripts in {}'s
02:54:35 <ely-se> tdammers: no, because otherwise the file is still half-written
02:54:41 <ely-se> it's the same effect
02:54:49 <tdammers> hio: quick, how do you connect to a Postgres database and write stuff from it to a file in Java?
02:54:52 <darenthis> I take it someone's linked to https://wiki.haskell.org/Cookbook
02:54:58 <bennofs> srhb: but users won't invest the time to find if they don't get the feeling that Haskell is not a toy first
02:55:23 <dramforever> hio: lack of easy tutorials and examples does not imply that haskell is a toy language
02:55:27 <tdammers> ely-se: if the connection drops out, you'll see an error message on stderr, telling you that the file is incomplete
02:55:30 <hio> darenthis: that's really good, it should be on the frontpage
02:55:42 <srhb> bennofs: I'm not sure I agree with even aiming at those people. A better target are people who have realized the usefulness of at least functional programming, or strong types, and go at them with the exact motivations that are, in fact, the fundamentals of Haskell.
02:55:47 <tdammers> ely-se: but if you're piping to sh, you're already executing it, so there's no going back
02:55:47 <srhb> Or at least fundamental justifications.
02:56:03 <frerich> hio: How did you hear about Haskell? For me, it was repeatedly mentioned by some people for whom I have a lot of respect, so I thought 'If they are fond of it, it's probably really clever, I should have a look.'. I.e. it passed the initial 'is it a toy or not' test already.
02:56:06 <srhb> 9/10 times people who decide to learn Haskell by writing a web app, or whatever, will be sorely disappointed.
02:56:18 <hio> and there should be a download to an IDE or at least some editor where i can press f5 and it will execute sample code
02:56:35 <dramforever> hio: how about this: how did you learn programming?
02:56:43 <EvanR> hio: whats the point of the homepage anyway when you can zoom directly to this channel and interactively bitch about the whole language
02:56:53 <EvanR> isnt this way better
02:57:01 <bennofs> hio: right on the homepage, there is an interactive editor which will execute code
02:57:02 <hio> EvanR: i wouldnt be bitching if the homepage was good
02:57:05 <dramforever> hio: leksah? I haven't tried it
02:57:13 <ely-se> fpcomplete's Haskell IDE
02:57:17 <ely-se> it has a run butan
02:57:20 <hio> bennofs: I'm not going to code in a javascript editor
02:57:39 <tdammers> hio: apt-get install haskell-platform; ghci
02:57:45 <dramforever> oh yes ghci
02:57:53 <dramforever> really nice interactive prompt
02:57:53 <ely-se> alright, let's give /ignore a try
02:57:59 <hio> repl is only for one liners, what if i need more than one line?
02:58:14 <srhb> hio: It has a nice :r command to reload a file
02:58:16 <dramforever> 1. ghci supports multi-liners
02:58:17 <srhb> hio: and :e for editing it
02:58:26 <bennofs> hio: then you setup a haskell dev environment.... oh, that's quite hard right now. I agree
02:58:34 * dramforever uses ghci-based development
02:58:36 <hio> normal people use ctrl+c ctrl+v
02:58:39 <hio> for development
02:58:44 <srhb> hio: "normal"
02:58:47 <hio> not some :r command they have to read up on in a book
02:58:50 <tdammers> ctrl+c is sigterm
02:58:50 <hio> that's the truth
02:58:54 <earthy> hio: 'shitty developers' use ctrl+c ctrl+v
02:58:56 <srhb> hio: You have to know the tool you use anyway.
02:58:59 <tdammers> why would you use that for development
02:59:15 <srhb> hio: And for various good reasons, you cannot paste top level definitions into ghci anyway
02:59:22 <srhb> hio: So just copy pasting code will not work.
02:59:22 <tdammers> anyway, this is quickly drifting into pointless land
02:59:26 <dramforever> hio: you mean open ide -> paste example code -> f5 -> wow that program is nice
02:59:26 <dramforever> ?
02:59:29 <hio> you all know in your heart that I'm right, it's just painful to accept that your efforts could be much less for other people 
02:59:35 <hio> dramforever: yes
02:59:37 <bennofs> hio: the fundamental disagreement here seems to be if we're even aiming for those people to learn Haskell
02:59:42 <srhb> hio: But you should give it a try, you'll be much better equipped to criticize the language after a few days of actually trying to learn it :)
03:00:03 <hio> uh i tried installing an IDE for a few days and gave up
03:00:18 <bennofs> hio: are you using Windows/Linux/Mac?
03:00:21 <dramforever> hio: hey did you secretly change the topic?
03:00:22 <tdammers> I think if you're unwilling to invest an hour or two into getting a basic development environemnt going and learning the basics, then maybe we have already honored you with more attention than you deserve?
03:00:23 <srhb> I do agree that the IDE situation is bad, but learning it is still worth it.
03:00:31 <EvanR> hio: cool people use ⌘ C and ⌘ V
03:00:43 <dramforever> hio: I thought we were talking about purity a while earlier
03:00:43 <tdammers> the haskell community is probably the most helpful crowd I've ever seen online
03:00:45 <srhb> EvanR: The magical museum button!
03:01:12 <tdammers> acting all entitled and all is just kind of inappropriate
03:01:12 <hio> dramforever: we are talking about feature descriptions on the homepage and why and how they could be improved to attract novice users
03:01:26 <dramforever> oh sure they could be improved
03:01:30 <dramforever> a lot to improve
03:01:40 <bennofs> tdammers: well, take for example racket. Even though I've already learned some Haskell, I think I wouldn't have tried it out if it wasn't as simple as "install DrRacket -> start coding!". I haven't yet tried out Agda for example, because I don't like to spent 1 hour configuring my emacs first to try it out
03:01:52 <hio> just copy paste a few of the cookbook examples over to the homepage and it would improve it a lot
03:02:00 <srhb> bennofs: iirc agda mode just works.
03:02:10 <tdammers> bennofs: idk, DrRacket is probably the single thing that keeps me from actually diving into racket
03:02:13 <mazur> i started programming with an ide, but since learning command line i have never wanted it back
03:02:17 <hio> bennofs: yes that's my point. making the transition easier is going to attract users
03:02:30 <EvanR> i want to try agda, emacs is going to be so fun to learn
03:02:52 * dramforever remembered the famous joke: haskell motto: "avoid success at all costs"
03:02:54 <bennofs> srhb: yes, but I have to find out keybindings and how to make it find the agda executable and ... (and I know this won't be easy, since well, I'm using NixOS. There is no "agda + configured emacs package", but there is a "DrRacket" package)
03:02:56 <tdammers> bennofs: I would have preferred tutorials and introductory resources that assume a minimal stack - not "open this IDE we have installed for you, click here, click there"
03:02:59 <ely-se> my IDE is Linux
03:03:06 <tdammers> exactly
03:03:12 <srhb> bennofs: I use NixOS too.
03:03:12 <bennofs> tdammers: note that the two approaches are not exclusive
03:03:16 <ely-se> no, wait, sorry
03:03:19 <ely-se> my IDE is GNU/Linux
03:03:37 <tdammers> bennofs: of course not, but most of the introductory documentation assumes DrRacket
03:03:44 <dramforever> hio: lemme see, what about a minimal hacking environment?
03:03:55 <dramforever> like just a text editor + ghci
03:04:01 <bennofs> hio: are you using Linux/Windows/Mac?
03:04:04 <dramforever> I mean, if it's packaged
03:04:15 <hio> how do you define "minimal hacking environment"?
03:04:22 <hio> and what is "packaged"?
03:04:24 <srhb> text editor, terminal, compiler/repl
03:04:31 <srhb> Whether you can yourCOmmand install haskellthings
03:04:32 <bennofs> (just wondering. Maybe those problems are different by OS?)
03:04:33 <tdammers> hio: the minimum set of tools you need to produce code
03:04:47 <dramforever> hio: download this, unzip, launch editor
03:05:00 <hio> that's all I'm saying, give me a text editor with a simple run button where i can do anything i could do - thats why the online repl isnt good enough, i cant read files there
03:05:01 <dramforever> type code, send to ghci
03:05:11 <dramforever> hio: hey do you know python?
03:05:20 <hio> yea a little
03:05:27 <srhb> hio: Well, you're not being honest, you also ruled out the FP complete IDE. :)
03:05:29 <dramforever> do you know the IDLE editor?
03:05:37 <tdammers> hio: in vim, you can send the current file to any shell command you want, e.g. :!runhaskell %
03:05:40 <Saizan> bennofs: it just looks into $PATH for the agda exe, otherwise you do need to look at the Agda2 customize group
03:05:55 <tdammers> I think most other programming-centric text editors have a similar feature
03:05:55 <lf94> In emacs you just type C-c c or whatever
03:06:08 <tdammers> that's really all you need to get started (that, and a working haskell-platform install)
03:06:09 <hio> i googled it, seems like what I would like for haskell too
03:06:10 <bennofs> Saizan: ok, I could probably find out how to do this. maybe Agda was a bad example :)
03:06:28 <bennofs> hio: btw, what do you think of http://python.org ?
03:06:44 <gfixler> hio: I use Vim and just make a quick mapping to send-keys through tmux to another split
03:06:52 <EvanR> how about https://secure.php.net/
03:06:52 <srhb> bennofs: Yeah, afaik it's just nix-env -iA nixos.pkgs.haskellPackages.Agda and you're good to go :)
03:06:57 <dramforever> hio: what about this: to sum up, haskell infrastructure sucks
03:07:10 <EvanR> right.. php doesnt need a homepage because "everyone knows it"
03:07:12 <gfixler> I usually make Enter and g+Enter for :r<CR> and <C-l> (reload and clear screen)
03:07:22 <tdammers> well, in all fairness, python.org has a slideshow with example programs and REPL sessions
03:07:25 <ely-se> PHP is nice.
03:07:44 <srhb> ely-se: >:/
03:07:50 <fishburne> ely-se: except that / search wont work as excepected!\
03:07:58 <dramforever> hio: do you use windows?
03:08:01 <dramforever> linux?
03:08:02 <dramforever> mac?
03:08:07 <hio> bennofs: the python.org website is bad too
03:08:25 <tdammers> nothing will work as expected in PHP, unless your expectations have been shaped^H^Hmutilated by years of PHP use
03:08:27 <bennofs> hio: right. On another thought, that might not matter for Python since most people will not find Python through python.org 
03:08:33 <dramforever> actually I'm a bit worried about this:
03:08:40 <ely-se> srhb: after months of torture with Python and JavaScript, PHP becomes a craving
03:08:44 <dramforever> "oooh I can read a file with readFile"
03:08:46 <srhb> o_o
03:08:56 <EvanR> ely-se: dafuq?
03:09:01 <hio> EvanR: the php website is really good
03:09:01 <EvanR> js pls
03:09:03 <dramforever> "oooh I can turn a Char into uppercase using toUpper"
03:09:06 <gfixler> I've never craved PHP
03:09:09 <srhb> dramforever: That was exactly the thing I tried to point out 20 minutes ago.
03:09:15 <tdammers> also, it might be worth noting that Haskell is a language that many people arrive at after years of being somewhat disappointed with their current languages
03:09:18 <dramforever> srhb: ?
03:09:25 <srhb> Or maybe not :P
03:09:33 <mazur> lf94: C-g c to specify compile command, then C-g r to re-compile
03:09:41 <tdammers> for those people, haskell.org isn't half bad
03:09:41 <gfixler> tdammers: and then look back at their old/current languages that aren't Haskell with utter contempt
03:09:42 <dramforever> "oooh I can turn a String into uppercase using map toUpper"
03:09:43 <ely-se> EvanR: formal type specifications and interfaces beat docstrings (typically the lack thereof) by an infinite factor
03:09:44 <lf94> mazur: thanks man B)
03:09:47 <tdammers> gfixler: that, too
03:09:57 <dramforever> ghci> map toUpper (readFile "mytestfile")
03:10:00 <dramforever> wtf type error
03:10:00 <srhb> dramforever: Yes, that exactly. learning cookbook examples and having NO idea about how types work
03:10:03 <EvanR> ely-se: omg you actually use those to some effect?
03:10:05 <dramforever> haskell is sooo hard
03:10:12 <dramforever> [gives up]
03:10:15 <srhb> Which is why I think we really, really don't need them
03:10:19 <lf94> lol
03:10:32 <tdammers> gfixler: I'm currently picking up clojure for work, and it's kind of a problem because everyone on the team is enthusiastic about it, while I'm mostly disappointed
03:10:32 * dramforever remembered someone saying this on reddit:
03:10:33 <srhb> Let people go by the usual type-guided route.
03:10:38 <bennofs> How do I get started with Haskell on windows? Install Notepad++ (which I need to know) + Haskell platform?
03:10:41 <mazur> i don't usually compile haskell that way, but it seems to work fine :) doesn't always work so well depending on the compiler output (i think latex comes to mind)
03:10:42 <lf94> Yeah there needs to be a reform for how Haskell is taught generally
03:10:50 <hio> the python website is great, it shows the latest releases by date so you know it's moving along and up to date, then with a few clicks im on the tutorial and it shows me how to put php into a website. Exactly what I'm looking for
03:10:53 <hio> php website*
03:10:54 <gfixler> tdammers: I was all into clojure for 6 months, then I found Haskell, and pretty quickly never went back
03:11:08 <gfixler> tdammers: still, I'd take clojure in a heartbeat over so many other options
03:11:12 <dramforever> "when I'm programming in C++, I can just google about what I want, copy-paste some code, and modify it until it works"
03:11:14 <ely-se> EvanR: yup! and my IDE uses them to do static type checking :D
03:11:29 <dramforever> "in haskell, however, I need to understand those things before I could use them"
03:11:40 <dramforever> "I'm not sure that's efficient in practice"
03:11:50 <dramforever> (roughly likt that)
03:11:51 <gfixler> dramforever: I just type example input and output, and have a plugin check all the codeblocks on stackoverflow until one matches up
03:11:52 <dramforever> *like
03:12:01 <tdammers> gfixler: sure... but on a scale from 1 to 10, haskell is like an 8, python, ruby, js, etc., are maybe a 3, and clojure is maybe a 4
03:12:07 <tdammers> and I was hoping for a 7 or so
03:12:19 <EvanR> when im programming in c++, i can paste some code and it will cause the compiler to deflagrate
03:12:20 <bennofs> hio: I'm sorry, how did you find the tutorial? I agree that haskell.org can be improved, but to me, php.net does not look much better
03:12:22 <gfixler> tdammers: write macros for the crap bits - that brings it up to at least a 5
03:12:25 <EvanR> if im lucky
03:12:38 <tdammers> gfixler: macros are disgusting, I consider them an antifeature
03:12:41 <dramforever> python has to be higher than js
03:12:49 <tdammers> dramforever: nope
03:12:53 <gfixler> tdammers: well then you don't like lisp :)
03:12:54 <tdammers> dramforever: at least js has real closures
03:12:57 <dramforever> okay what scale?
03:13:07 <hio> bennofs: just click on documentation -> english (in bold) and then you can click on tutoriral
03:13:10 <bennofs> hio: ah, I need to click on Manual
03:13:11 <EvanR> what clojure has closures
03:13:12 <tdammers> dramforever: the "how much I like these languages"
03:13:16 <dramforever> ok
03:13:27 <tdammers> EvanR: yeah, but Python's closures are broken, if anything
03:13:29 <bennofs> hio: For me, Manual always implies "something long that's a reference after you know the basics" :)
03:13:32 <EvanR> oh yeah
03:13:39 <tdammers> clojure beats javascript in most arenas
03:13:44 <EvanR> python is anti-functional
03:13:52 <hio> it says "documentation" for me, not manual
03:13:53 <tdammers> only thing where js scores better is existing in many places
03:13:53 <ely-se> I like concatenative languages because refactoring is literally cut&paste
03:13:57 <gfixler> EvanR: I've made Python functional to some degree
03:14:14 <bennofs> hio: "The PHP Manual is available online in a selection of languages. Please pick a language from the list below. "
03:14:17 <tdammers> python is definitely anti-functional
03:14:18 <dramforever> hio: haskell.org -> Documentation -> wow so many -> hey there's "a gentle introduction to haskell", I'll go see that
03:14:41 <gfixler> e.g. id = lambda x: x; const = lambda x: lambda _: x; flip = lambda f: lambda x: lambda y: f(y)(x)
03:14:42 <tdammers> python kind of subscribes to the idea that functional thinking is hard and confusing, and imperative thinking is easy and natural
03:14:56 <hio> dramforever: All the links sound exactly the same to me: Learn You a Haskell for Great Good! Real World Haskell Beginning Haskell Thinking Functionally with Haskell Parallel and Concurrent Programming in Haskell Programming in Haskell
03:15:05 <lf94> but is haskell webscale?
03:15:12 <dramforever> hio: agreed
03:15:13 <hio> I want to learn haskell. I want real world haskell. Obviously I want "beginning haskell"
03:15:15 <tdammers> so python does incorporate FP concepts, but only to the point where they are considered understandable for the imperatively-minded
03:15:19 <EvanR> Yes! Haskell can do that
03:15:24 <ely-se> lf94: no, it has green threads instead of callback hell
03:15:24 <srhb> hio: No, you want cis194 :-)
03:15:31 <dramforever> maybe we should move tutorials to the top
03:15:32 <srhb> "Real world" is the wrong approach to start out with.
03:15:33 <lf94> ely-se, it was a joke lol
03:15:39 <tdammers> indeed
03:15:39 <ely-se> mine too?
03:15:41 <xeno> hio: they're books. Beginning Haskell is great btw - despite having an issue with typos 
03:15:58 <xeno> hio: Real World Haskell is pretty dated now :/ - could use a second edition 
03:15:58 <srhb> OK, I've not actually read Beginning Haskell, so I've no idea.
03:15:59 <ely-se> everyone knows that callback hell is a prerequisite for webscale
03:16:01 <hio> like i said: put the thing that haskell is good for in the simplest, smallest possible code form as a "simple tutorial" on the top of the tutorial
03:16:07 <lf94> ely-se, oh ok
03:16:14 <tdammers> the big advantage of Haskell does not lie in making simple real-world things simpler
03:16:17 <ely-se> massively concurrent code should be hard to maintain
03:16:18 <srhb> I would actually agree with that
03:16:29 <srhb> But I would write some code that explicitly doesn't work because of a type error :-)
03:16:36 <EvanR> ely-se: no way
03:16:39 <gfixler> oh, right, Beginning Haskell is by Alejandro Serrano Mena
03:16:46 <dramforever> hio: hmm...what about this: how did you learn programming?
03:16:52 <xeno> gfixler: yes 
03:16:54 <gfixler> I sat in his class at LambdaConf this year
03:16:55 <frerich> hio: I think the majority of people would agree with that. I wouldn't be surprised if the GitHub project has an issue ticket about just that.
03:17:01 <hio> dramforever: IN UNIVERSITY
03:17:08 <dramforever> what did you begin with
03:17:28 <hio> java
03:17:35 <hio> just like everyone else in the world
03:17:37 <tdammers> hio: you'll have a better learning experience if you hand-waive the file IO and SQL part for the time being, assuming that Haskell is on par with other languages in this arena, and focus on the parts where Haskell actually can make your life better
03:17:39 <srhb> hio: Uh, no.
03:17:51 <srhb> hio: Lots of universities have FP intro courses, not oop/imperative.
03:17:53 <bennofs> srhb: can you find a tutorial there that actually explains how to get set up (like "Install Haskell Platform 
03:17:55 <hio> tdammers: but i need file io and sql right now. 
03:17:55 <dramforever> hio: okay so what language features did you begin with?
03:17:56 <srhb> hio: It really depends where you're from :)
03:18:00 <xeno> I don't think "real world" is necessarily the wrong approach.. it might be the wrong approach for first intro to FP, but it's a god way to actually grasp how Haskell works... fluffy imaginary FP-demos only take you so far
03:18:08 <srhb> bennofs: Probably not.
03:18:10 <dramforever> hio: sadly that's likely to cause problems
03:18:17 <tdammers> hio: if you need to solve real problems at production quality right now, then don't do it in Haskell
03:18:23 <srhb> Agreed.
03:18:27 <dramforever> agreed
03:18:40 <tdammers> hio: not because Haskell is unsuitable, but because you haven't even started learning it, how can you possibly expect to know what you're doing?
03:18:40 <gfixler> consensus
03:18:42 <hio> right and this is why haskell will stay forever toy
03:18:45 <tdammers> no
03:18:48 <frerich> hio: If you need to do something right now, it probably doesn't make sense to start learning a new language.
03:18:49 <srhb> Learning a new paradigm is best done by exploring the paradigm, not randomly throwing code at the compiler and hoping something sticks.
03:18:55 <hio> i disagree
03:18:57 <tdammers> this is advice I would give for any language
03:19:10 <hio> i always throw code at my compiler and i expect it to tell me why it's wrong
03:19:21 <gfixler> hio: you can do that with ghc
03:19:27 <dramforever> hio: well *that's* the problem
03:19:27 <tdammers> haskell does that better than anything else I've ever worked with
03:19:28 <gfixler> but you might not recognize the output
03:19:30 <srhb> hio: You likely will not understand the errors without some basic knowledge. 
03:19:36 <tdammers> however, you will not understand what it means
03:19:40 <srhb> hio: You simply need some type knowledge first.
03:19:51 <bennofs> hio: what do you think about https://www.fpcomplete.com/school/starting-with-haskell ?
03:19:58 <gfixler> hio: haskell is so fundamentally different than everything else I've ever worked with, I basically had to start over
03:20:06 <dramforever> hio: you can't possibly start doing those stuff in haskell right now
03:20:13 <bennofs> hio: in most of those tutorials, you can just edit the sample code and press run again!
03:20:14 <dramforever> because you haven't learnt the basics
03:20:15 <gfixler> hio: but it's been hugely rewarding, and incredibly well worth it
03:20:27 <tdammers> also, the "get shit done" approach tends to not work very well with Haskell
03:20:29 <gfixler> hio: so much so that I never want to use another language again - they're all trash compared to it for me
03:20:29 <ely-se> soon, "Haskell is super awesome!" -- hio
03:20:32 <mazur> i made a couple false-starts learning haskell. eventually stuck after working through lyahs
03:20:42 <EvanR> Can Haskell get shit done?
03:20:46 <EvanR> Yes!
03:20:46 <tdammers> you can get shit done in Haskell
03:20:49 <EvanR> Haskell can do that
03:20:56 <gfixler> hio: other languages are about spending - quick fun now; haskell is investment - huge rewards later
03:20:56 <ely-se> EvanR: No, it can only get nice stuff done.
03:20:58 <dramforever> how about this: can you start doing those before you learnt java?
03:21:03 <bennofs> hio: https://www.fpcomplete.com/school/starting-with-haskell/haskell-fast-hard/haskell-fast-hard-part-1 ?
03:21:09 <dramforever> of course no, you don't know the basics
03:21:13 <mazur> 'Tackling the Awkward Squad' for the sticky issues after that
03:21:14 <dramforever> same for haskell
03:21:18 <hio> bennofs: bad, again 5 links who all sound the same as a starting point. no idea which one to click
03:21:24 <tdammers> the difference is that Haskell is better at supporting the approach where you actually know what you're doing
03:21:32 <bennofs> hio: ok, how about https://www.fpcomplete.com/school/starting-with-haskell/haskell-fast-hard/haskell-fast-hard-part-1 ?
03:21:35 <dramforever> wtf
03:21:38 <gfixler> hio: if I may be so bold, you're coming at this with the wrong attitude entirely
03:21:44 <dramforever> I need threaded chat
03:21:45 <tdammers> rather than cat-ing /dev/random into a file and going from there
03:21:53 <hio> bennofs: okay the second link is pretty good
03:21:56 <frerich> hio: Makes you wonder how anybody managed to learn anything about Haskell, doesn't it? :-)
03:21:56 <ely-se> UUOC
03:22:22 <dramforever> hio: why do you expect to be able to start doing SQL, file IO, etc. right now?
03:22:23 <tdammers> and of course that means that a learning approach that works for, say, Python or PHP isn't as viable for Haskell
03:22:26 <tdammers> (and vv)
03:22:47 <bennofs> hio: thanks for the feedback. I agree that being able to write code very fast (at least to get started! the tutorial may then continue to more basic things) is important
03:23:06 <mazur> hio: has anyone recommended the Wadler YouTube lectures? i watched those after lyahs, so mostly just followed along but it would be good if you're better at that kind of learning
03:23:58 <mazur> bennofs: i think that's the one i tried and failed :D too fast and hard for me
03:24:08 <bennofs> dramforever: so what about just showing some simple IO stuff at the beginning (just to show that you can do this in Haskell), but then proceeding to simple stuff like the most tutorials?
03:25:16 <gfixler> bennofs: the possible issue there is having a bunch of new users using IO for every function they write
03:26:12 <bernalex> I agree with gfixler. I prefer a more patient approach to teaching haskell. but that requires patient learners as well. but "I know how to do something in Java, I want the rosetta stone for Haskell." does not work very well anyway.
03:26:28 <tdammers> "patient" is kind of an important concept here
03:26:36 <frerich> but 'right now'.
03:26:39 <gfixler> that's the most difficult thing to teach
03:26:43 <tdammers> I believe that if you lack basic patience, then Haskell will not reward you at all
03:26:45 <gfixler> it's why I mentioned spending vs. investing
03:26:51 <bennofs> But nobody will be "patient" if they think haskell is toy
03:26:55 <dramforever> hio: you still haven't answered me
03:27:01 <dramforever> why do you expect to be able to start doing SQL, file IO, etc. right now?
03:27:04 <gfixler> most languages = spending; haskell, agda, idris, coq = investing
03:27:15 <gfixler> spending leaves you half-fulfilled and poor
03:27:21 <hio> dramforever: because i expect to do real work with a language and if it cant read a file it can't do anything
03:27:26 <gfixler> investing leaves you bored for now, but powerful later
03:27:34 <tdammers> hio: haskell can read files just fine
03:27:43 <dramforever> hio: do you expect that before you learnt programming?
03:27:46 <gfixler> haskell reads files better than other languages I've used
03:27:54 <bennofs> perhaps there are patient new users that are only willing to invest time after they've at least seen (even if they do not understand it yet and can't apply it themselves) that the language can do real world things?
03:27:57 <gfixler> I've found it's file handling to be rather beautiful
03:28:02 <tdammers> hio: but it requires a tiny bit of learning effort before *you* can make it read files in a meaningful way
03:28:18 <srhb> I disagree with the "tiny" bit.
03:28:18 <ely-se> Haskell file reading API doesn't take an encoding
03:28:21 <srhb> It can be quite large.
03:28:21 <dramforever> hio: of course you don't, you haven't learnt the basics
03:28:24 <srhb> It was for me, at least.
03:28:24 <tdammers> hio: and it makes more sense to learn a few things first that aren't file reading before you proceed to learning I/O
03:28:29 <ely-se> but it *does* return String, not ByteString
03:28:32 <bernalex> hio: haskell is diametrically opposed to the C-like way of doing things. in haskell, safety and correctness is actually valued. this means you need to learn the rigurous ways of haskell before you start doing ugly unsafe and incorrect things like IO.
03:28:35 <srhb> I was particularly bad at abandoning my old ways, though.
03:28:40 <dramforever> the basics of haskell is very different
03:28:40 <ely-se> conclusion: it's bad
03:28:47 <tdammers> srhb: "tiny" compared to the total body of haskell knowledge that exists
03:28:50 <dramforever> so different that it's really re-learning programming
03:28:52 <srhb> Oh, yes, of course. :)
03:28:53 <srhb> Sorry.
03:28:56 <tdammers> :D
03:28:59 <dramforever> hio: ^
03:29:14 <dramforever> sigh that caret isn't going to do anything useful
03:29:24 <bennofs> tdammers: but that doesn't mean that a tutorial can't show that *it's possible*. Do you really think that there are no people that are patient only *after* they've seen that Haskell can do real world things? 
03:29:29 <srhb> It's pointing at how HAPPY Haskell programmers are!
03:29:30 <srhb> :-)
03:29:36 <frerich> dramforever: srhb should have anticipated it and extended it with some | characters.
03:29:46 <tdammers> also, once you're comfortable with Haskell's programming paradigm, the part that you need to master before doing I/O really isn't larger than what you need to know about imperative programming before you can write int main() { printf("Hello, world!\n"); return 0; }
03:29:51 <tzaeru> gfixler, the problem there, I think, is that majority of programmers are not really that interested in the language itself, or what it offers; they are interested in how they can quickly and effectively map problems for a computer to solve right here and now. that problem is not "how can I represent chains of functions while avoiding side-effects?", but "how do I get and show info about a furniture storage to the clients?" or "how do I implement fun ...
03:29:57 <tzaeru> ... physics for this tiny mobile car game?" or whatever.
03:30:01 <bernalex> people who program in java or c++ are in my experience not very concerned with doing the Right Thing, nor correctness in general. so they come to haskell & go "wow this is really cumbersome, why would anyone do it like this?" -- because they don't grok the fundamental mentality of haskell.
03:30:01 <ely-se> srhb: I'm a Haskell programmer and I'm not very happy.
03:30:11 <srhb> ely-se: Anecdotal evidence means little to me!
03:30:12 <tdammers> bennofs: agree; some more hints at Haskell's practical usefulness would certainly be in order
03:30:12 <srhb> :P
03:30:16 <gfixler> tzaeru: yep
03:30:26 <tzaeru> verement, that's a valid observation, I think.
03:30:30 <ely-se> srhb: now I'm even less happy :'(
03:30:36 <srhb> ely-se: *pat pat*
03:30:46 <tdammers> bernalex: in my experience, plenty of Java programmers *want* to do the right thing, but their current situation is limiting them
03:30:50 <tzaeru> errr, verement, sorry, mis-hilight :)
03:30:56 <tzaeru> bernalex*, that's a valid observation
03:30:58 <bennofs> tdammers: or what about, you know, just a code example that you can run right now where you can at least change the strings (like "Hello all" instead of "Hello world"), even if you don't understand the basics of the language yet?
03:30:59 <tdammers> bernalex: that's why things like Scala were invented
03:31:11 <tdammers> bennofs: sure, that'd work too
03:31:20 <ely-se> OMG SCALA
03:31:22 <bernalex> tdammers: my opinion is primarily concerned with newbie bachelor/master graduates.
03:31:27 <gfixler> I work with dozens of devs - none but me are interested in FP (I've asked too many times for them to join me)
03:31:32 <srhb> I'm sad no one thought it was a good idea to write some code example that actually has a subtle error that the type system catches. :(
03:31:33 <bernalex> tdammers: i.e. people new-ish to programming altogether.
03:31:44 <gfixler> I have a friend at another big company - he's managed to get 4 devs interested in following along with CIS-194
03:31:51 * dramforever feels ignored =(
03:31:51 <bennofs> tdammers: so maybe that would also fix hio's complaints? "I want to see that these things are possible!" (=> that haskell is not a toy)
03:31:53 <tdammers> bernalex: oh. I was assuming your average business programmer deep down in the trenches
03:31:55 <srhb> I think that would work as a great incentive for the right people and a great deterrent for people who are not yet ready for enlightenment.
03:31:57 <xeno> gfixler: a destiny shared by many
03:31:59 <gfixler> I'm in a few meetups - everyone has the same story: "I'm the only one at my company who cares about any of this stuff"
03:32:01 <tdammers> bennofs: yes, probably
03:32:02 <tzaeru> I still struggle in finding motivation to learn haskell properly. @,@ I kinda like learning about it, even that it is slow, but I also like getting stuff done right now. so I haven't gotten much time set to learning haskell thus far.
03:32:04 <black> Any one here Watch Mr.Robot
03:32:13 * dramforever still feels ignored
03:32:21 <tzaeru> dramforever, aww ;_;
03:32:22 <bennofs> dramforever: ?
03:32:23 <gfixler> this is just how we humans are - 1% or so of us cares deeply about our craft, the rest just want to get things done and go home
03:32:26 * pacak pokes dramforever
03:32:35 <bernalex> tdammers: I think hio is a newbie, so that was the "audience" I addressed. I agree with your view if we talk about the whole body of java programmers though.
03:32:44 <tdammers> bennofs: could even do it in a somewhat humoristic way, something like putting a Haskell program that greets people at the top of the landing page
03:32:49 <ely-se> srhb: I like how PostgreSQL package limits string concatenation of SQL queries.
03:32:53 <dramforever> hio: I think you expect to be able to do those because you know the basics of programming
03:33:03 <tdammers> bernalex: yeah. The Java worlds seems to be struggling.
03:33:03 <lf94> ...why is it so hard to find any documentation on getting software ready to be uploaded to hackage?
03:33:06 <srhb> ely-se: *nods*
03:33:10 <dramforever> is that correct?
03:33:15 <bennofs> gfixler: and 90% care more deeply about things giving at least give an indication of being useful :)
03:33:21 <lf94> I want to make a cabal package, where's some good documentation for this?
03:33:40 <bennofs> tdammers: sounds like a good idea. Embed the FP complete code runner there and it's awesome 
03:33:41 <gfixler> bennofs: yep - for me, I just need to hear a handful of people swooning about the amazingness of something, and I'm in :)
03:33:42 <hio> dramforever: yes, but to be honest when I started java I would have been amazed by reading a file in. I dont think the long and cumbersome java tutorials did me any good either
03:33:42 <tdammers> bennofs: I was also thinking of linking more prominently to real-world Haskell projects
03:33:46 <dcoutts> lf94: see the cabal website, has a link to a wiki page, and also to the cabal user guide
03:33:47 <bernalex> tdammers: the "java world" is a bit of a misnomer though, for the same reason that lead to our wee misunderstanding here. it's *huge*.
03:33:47 <mniip> lf94,  something about cabal sdist
03:33:51 <srhb> lf94: The GHC manual has a decent section on it.. Section 3 I think?
03:33:53 <tdammers> bernalex: sure.
03:33:54 <gfixler> bennofs: it helps tremendously if I view them as very smart
03:33:56 <tzaeru> gfixler, well, the "craft" part here is a bit problematic in programming. there's not only the *language* to worry about, but user experience, viability, agility, etc, to care about.
03:34:00 <bennofs> gfixler: :p
03:34:01 <ely-se> e.g. you can't do this: query_ conn ("select c from t where d = " ++ x)
03:34:05 <ely-se> the type system prevents you from doing that
03:34:12 <tzaeru> you can care a whole deal about your software without being, excuse the term, a total language geek ;)
03:34:21 <dramforever> hio: you don't know the basics of haskell
03:34:27 <gfixler> tzaeru: right, there are other motivations, many at odds with what we haskellers care about
03:34:28 <tdammers> ely-se: query_ conn ("select c from t where d = " ++ show x) -- oh boy
03:34:30 <mazur> lf94: i assume you've read https://wiki.haskell.org/How_to_write_a_Haskell_program
03:34:43 <dramforever> and much od your current programming knowledge doesn't translate to haskell
03:34:45 <dramforever> *of
03:34:45 <ely-se> tdammers: also won't work
03:34:50 <hio> dramforever: did a hello world once and looked at how do make my own types
03:35:04 <ely-se> Query has a FromString instance, so you can use OverloadedStrings, but ++ doesn't work on Query values
03:35:05 <tdammers> ely-se: why not?
03:35:08 <dramforever> hio: none of them quite is the same in haskell, right?
03:35:12 <tdammers> ah
03:35:14 <lf94> mazur of course! ;)
03:35:18 <tdammers> ely-se: query_ conn (fromString $ "select c from t where d = " ++ show x) -- oh boy
03:35:28 <tdammers> "problem solved"
03:35:30 <ely-se> tdammers: yes, but then it's at least explicit
03:35:34 <ely-se> you don't do that by accident
03:35:37 <tdammers> I know
03:35:43 <tdammers> tongue-in-cheek
03:35:46 <gfixler> main = readFile "foo.txt" >>= return . map toUpper >>= writeFile "bar.txt"
03:35:48 <hio> dramforever: well i walked away with the feeling that the type system is really powerful (or could be) but I dont see how I can write a "normal" program with it
03:35:51 <tdammers> this is the kind of stuff I love about Haskell
03:35:51 <gfixler> there, file handling
03:36:01 <ely-se> query conn "select c from t where d = $1" (show x)
03:36:04 <tzaeru> recently I've really liked programming in Rust. fast to learn for those with C background, but still different enough to be worth it, with its type system, explicit mutability, borrowing concepts, etc, which guarantee full type safety, memory safety and thread safety. I think it borrows a lot from haskell, too.
03:36:04 <dramforever> hio: THAT'S why you need to learn the basics
03:36:16 <gfixler> hio: the beautiful thing is that you can't write a normal program with it
03:36:17 <tzaeru> and I think it kinda helps in understanding some haskell concepts too, in a way
03:36:22 <tdammers> ely-se: shouldn't that rather be toSql or sth instead of show?
03:36:25 <gfixler> because "normal" in our world is crap :)
03:36:26 <dramforever> gfixler ++
03:36:30 <gfixler> Haskell keeps you from writing crap
03:36:31 <tzaeru> kind of intermediate way to map some problems into a more functional/compositional/strict system without a full leap to FP
03:36:38 <bennofs> hio: would putting a program that reads your name and says "Hello <name>" on the haskell.org front page (and making it editable like the fpcomplete example) improve your experience?
03:36:42 <dramforever> "normal" means programs you are used to, right?
03:36:49 <dramforever> hio: ^
03:36:56 <gfixler> "normal" is mutable, side-effecting, denotational semantics-free, muddy, OOP nonsense
03:37:13 <gfixler> so no, Haskell doesn't let us write normal, and that's why it's amazing
03:37:22 <hio> bennofs: yes I think so! what i also struggled with is making a reusable function.
03:37:30 <mazur> honestly the only complaint i have with haskell is the duplicate record field issue. hopefully that new pragma will be available soon :)
03:37:34 <tdammers> I like to think in terms of "what can the type system do for me" rather than "what does the type system prevent me from"
03:37:42 <tzaeru> gfixler, it's rather a mix tho when this is combined with somewhat unusual syntatical features and ending up looking completely different from the mainstream languages.
03:37:54 <bennofs> hio: well, after that example, you still have to read a tutorial since with Haskell, you really need some basic knowledge before you can write real programs :/
03:37:54 <tzaeru> gfixler, a lot of those things could still be achieved while having more resemblance to say, C, I think.
03:38:03 <srhb> mazur: Don't hold your breath, it requires a consensus on lens libraries, which is easy in practice and apparently super hard in theory :P
03:38:06 <liste> hio why wouldn't your function be reusable?
03:38:10 <gfixler> tzaeru: just start with "do" :)
03:38:27 <hio> bennofs: but a hello world IS a real program. And I mean that i need to know the syntax on how to make a function with arguments to write one
03:38:33 <bennofs> in fact, https://www.rust-lang.org/ does exactly what we just discussed
03:38:43 <gfixler> hio: arguments to hello world?
03:38:45 <tdammers> e.g., instead of saying, "the type system prevents me from interpolating strings into my HTML", I can say, "the type system can make the distinction between 'html source' and 'raw strings' explicit, and have the compiler detect any mistakes I make in this regard"
03:38:52 <gfixler> main = putStr "Hello, World!"
03:38:54 <tzaeru> gfixler, hmm ^^
03:38:57 <gfixler> that's a full, valid program
03:39:24 <gfixler> hio: that example was just to show you that Haskell needn't be bulky or crazy-looking
03:39:25 <hio> the essence is really this: instead of reading about how to make a type or a function with arguments, it would be good if i could just see one and then I can copy it and go from there
03:39:55 <bennofs> hio: problem is: that approach will often not lead to an understanding of haskell
03:39:56 <tdammers> hio: you can
03:40:10 <bennofs> hio: and you will get errors from the compiler that you cannot explain
03:40:15 <darenthis> I find I think of Haskell a little like SQL. I'm not specifying a sequence of instructions so much as describing an intent
03:40:25 <tzaeru> bennofs, yeah, and it works there, since Rust is designed to be familiar for C and C++ programmers
03:40:26 <tdammers> hio: but you'll bump into issues pretty soon, if only because the term "function" means something subtly different in a pure functional language
03:40:26 <bennofs> hio: and then ask in this channel and everybody will tell you: just learn the basics of haskell
03:40:28 <gfixler> hio: there's a new book out that's intended for new users: http://haskellbook.com/
03:40:30 <frerich> hio: I think there is an example of a function definition right at the top of https://www.haskell.org/ (the 'filterPrime' definition)
03:40:39 <frerich> hio: but that doesn't get you very far, I guess.
03:40:56 <gfixler> hio: that book was specifically written to address problems the community has had in teaching Haskell to newcomers
03:41:12 <merijn> hio: The problem is that Rust is still pretty similar to, e.g. C++, Haskell isn't similar to any language except the other functional ones, i.e. SML, Ocaml, Erlang (maybe), F#
03:41:19 <gfixler> hio: I have not read throug yet, so I can't comment on the validity of its claims, though
03:41:50 <darenthis> It's not just the type system, it's also referential transparency (aka variables are immutable) and laziness (declaring a variable to be the result of a costly function call doesn't incur the cost until/unless you need it)
03:42:04 <tdammers> what's worse, experimenting with example code under the assumption that Haskell's function is conceptually the same as C's function concept will be confusing
03:42:05 <gfixler> frerich: lots going on in that 'simple' function :)
03:42:15 <bennofs> hio: the problem is that because Haskell separates side-effect-free / side-effecting code, you'll easily run into weird errors if you write programs just as in imperative languages
03:42:16 <merijn> hio: For example, I can show you a function like https://gist.github.com/merijn/3f9ce423edadf1622823 but I'm not sure that's very helpful or intelligible...
03:42:30 <frerich> gfixler: I concur. :-]
03:42:43 <tzaeru> I keep having trouble reading that terse syntax @,@
03:42:52 <gfixler> frerich: lazy, infinite list generation, pattern-matching with cons on lists, consing of lists, list comprehension, /= (not the usual !=), etc
03:43:00 <tzaeru> despite "technically" knowing what the symbols ought to mean
03:43:08 <mazur> also, learn a lisp if you want to learn an archetypal FP language (i read through the emacs lisp manual when i was picking up emacs)
03:43:09 <hio> bennofs: an understanding can come later, first I want to extract value from trying out this new language. Look at php: you get a webpage and can put values into it. There is no understand yet. That comes later
03:43:10 <merijn> tzaeru: What? You mean mine? :)
03:43:19 <tzaeru> merijn, yea, though it's hardly from the tersest end
03:43:21 <gfixler> frerich: not to mention the thing newbs don't learn for awhile: no statements, all functions are single expressions
03:43:31 <bennofs> merijn: oh, explicit DL style :|
03:43:34 <tdammers> hio: the reason why people recommend shelving the IO part is because writing pure functions that consume and produce simple values (numbers, characters, lists) is easier than writing pure functions that deal with IO values, which is what you need to do in order to write programs with IO effects
03:43:41 <gfixler> frerich: and the fact that that isn't a function - no -> :)
03:43:48 <merijn> tzaeru: I think the problem with that example is that I'm assuming some familiarity with DList
03:43:50 <gfixler> primes is just a value (an infinite list of primes)
03:44:18 <merijn> tzaeru: As evidenced by bennofs' reaction ;) Once you know DList you spot this and go "oh, that's just a DList" and you don't need to parse the details as much
03:44:18 <frerich> gfixler: I agree with all of that (I wrote 'filterPrime' though).
03:44:25 <tzaeru> merijn, I think it's more about me being unused to so many single-letter variables and large amount of functionality within such a short space of characters.
03:44:49 <gfixler> frerich: ah, sneaky!
03:44:53 <merijn> tzaeru: Using some explicit DList library would probably make it easier to read, but I didn't wanna deal with imports, etc. to showcase this example when I wrote it :)
03:44:54 <hio> it's actually similar to learning a normal human language. It takes weeks building up a vocabular. Instead it would be much faster to 1. get the basic grammer explained to you. 2. learn to say "hello", "bye" "how much does this cost?" "thanks" and then get a real understanding later
03:45:18 <gfixler> hio: I think you'll find most of us in here agree that you need to work from specifics to general
03:45:39 <gfixler> we're pretty into hating on metaphors, too
03:45:45 <gfixler> for similar reasons
03:45:56 <tzaeru> gfixler, I think that in human learning, the split between "prefer to go from general to details" and "prefer to go from details to general" is roughly 50/50.
03:45:56 <hio> no, i think i convinced some people
03:46:19 <bennofs> hio: btw, are you familar with editors/the command line?
03:46:21 <gfixler> tzaeru: an interesting proposition - I'd like more data
03:46:25 <merijn> hio: There's two schools of thought on how to learn Haskell, but have their own pros and cons: There's the "directly wanna code "real" code" school of thought. Pro: Immediately get to writing real programs. Con: Lots of things will be confusing and frustratingly complex seeming because you lack understanding of the underlying ideas.
03:47:08 <tzaeru> I for one know that I'm really bad in learning details first, since my brain just fails to memorize and work on things that I can not set neatly into an established framework; when ever I learn new things, I start from "what can I use this for, and why would I?" instead of "how can this be used for things?"
03:47:15 <merijn> hio: Approach two: Start from the theory/fundamentals and work up from there. Pro: Better understanding leads to easier time grasping what's going on when moving to more complex code/libraries. Con: Inability to write "real" programs for a long time will be very frustrating
03:47:24 <tzaeru> gfixler, I guess statistical data would exist!
03:47:50 <tzaeru> though I don't know much about the psychological studies and I've no idea what the terms would be for this stuff even :/
03:47:50 <gfixler> tzaeru: statistical data on claims about programmers is always in short supply
03:47:52 <merijn> hio: Which approach suits you is something personal. I went the second way and it's the only way I know how to teach people, but there's people who've made the former work for them
03:48:04 <tzaeru> gfixler, oh, I wouldn't know for programmers!
03:48:18 <bennofs> hio: for the "no IDE" part, it would be really useful to know what OS you're on (Linux/Windows/Mac)
03:48:19 <merijn> tzaeru: btw, maybe this link helps explain what goes on in my earlier example: http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/
03:48:19 <tzaeru> but I do think that programmers today are a very general bunch.
03:48:38 <tzaeru> merijn, I'll save that and try to read it later with a bit of thought
03:48:41 <tzaeru> at work atm -.^
03:48:56 <bennofs> merijn: I wonder how far you could get by lying and saying that IO a marks the return value of the function :p
03:49:18 <sbrg> > 3 + 3
03:49:19 <lambdabot>  6
03:49:26 <bennofs> problem is of course if people don't work till the part where you explain pure functions 
03:49:52 <merijn> tzaeru: Sure :) I highly recommend it, because understanding DList is the starting point for codensity, which is a more general optimisation trick that can have excellent performance results :)
03:50:13 <bennofs> merijn: I always wonder, how can creating so many closures be efficient?
03:50:16 <bernalex> hio: actually, there is a *substantial* amount of teachers & researchers that would advocate *strongly* against learning a language like that (learning common phrases without understanding them). at least for adults. children learn very differently to adults.
03:50:29 <tzaeru> I think this is actually a nice thing about Rust, if you allow the comparison, that the docs and teaching of it starts by mapping straight away to *why* the language exists at all, on a very practical level. it doesn't talk about abstract concepts like purity or anything.
03:50:40 <tzaeru> it talks about that we want to do same shit as C++ but without constantly shooting ourselves in the foot :P
03:50:43 <merijn> bennofs: Did you read the link? It explains exactly how/what it optimises :)
03:50:43 <tzaeru> that's very understandable.
03:50:48 <tzaeru> even to the thick-headest programmers!
03:51:02 <merijn> tzaeru: Sure
03:51:04 <bennofs> merijn: I know how DList works, and that it reassociates. I just wonder how much the overhead of all the closures is
03:51:13 <merijn> bennofs: Allocation is *cheap*
03:51:13 <gfixler> I have a philosophy of teaching/learning that I call "One More Thing," that I don't think is followed enough, because it can be a bit tedious for teachers
03:51:29 <merijn> bennofs: The way GHC works allocation is basically "incrementing an int"
03:51:49 <tzaeru> then you see Haskell, which advertises as, "purely functional" and you go "wait, what's purely functional? what do I get from it?", so it's already not-so-practical, unless you're de-facto aware of the benefits of that sphere of programming.
03:52:04 <tzaeru> which isn't per-say to say that the advertisement was a bad one.
03:52:14 <tzaeru> I do believe it does exclude a group of people, though.
03:52:20 <bennofs> merijn: but if yoou have a DList, you basically have a very long chain of f1 . f2 . f3 . f4 . f5 .... Isn't calling all those functions (and (.)!) inefficient?
03:52:21 <merijn> tzaeru: I don't think Haskell will be "the next big thing", but I do believe that "the next big thing" will be A LOT more like haskell than current languages :)
03:52:34 <tzaeru> merijn, yeah, Rust too borrows from Haskell already ^^
03:52:42 <merijn> bennofs: calling functions is cheap too in Haskell :)
03:52:43 <gfixler> My "One More Thing" idea is basically teaching along a Levenshtein distance
03:52:52 <merijn> bennofs: A function call in haskell is basically a JMP instruction
03:53:00 <bernalex> tzaeru: so does python, scala, swift, and arguably any relevant language post 1990 or so.
03:53:01 <merijn> bennofs: Since there's no call stack to setup/maintain
03:53:05 <gfixler> i.e. what's the one, single, smallest thing I can change to take another step toward the goal?
03:53:13 <merijn> bernalex: I disagree
03:53:22 <merijn> bernalex: Well, Swift ok
03:53:32 <gfixler> that's how I learn best
03:53:36 <bernalex> merijn: python & scala are both directly influenced by haskell in some way.
03:53:38 <merijn> bernalex: But python and scala don't borrow from haskell in a meaningful way
03:53:43 <tzaeru> bernalex, I don't think they borrow directly from haskell.
03:53:49 <tzaeru> perhaps on some kinda principal level
03:53:53 <merijn> "copying list comprehensions" is hardly "similar to haskell"
03:54:00 <merijn> tzaeru: Python copied list comprehensions from haskell
03:54:06 <gfixler> bernalex: Odersky is on record saying that Scala is a gateway to haskell
03:54:09 <merijn> But that's pretty much where things end
03:54:17 <bernalex> merijn: I never said "similar to haskell", so that's OK.
03:54:21 <merijn> gfixler: Sure, because scala is way more complicated than haskell :)
03:54:41 <tzaeru> merijn, well, okay, that might be one, but it's indeed not a particularly meaningful thing
03:54:49 <gfixler> bernalex: https://twitter.com/tihomirb/status/577624701767319552
03:55:00 <bernalex> merijn: but they *did* borrow things. in python's case list comprehensions is one thing. whitespace syntax was also somewhat influenced by haskell (amongst others).
03:55:04 <merijn> gfixler: People learn Scala, become frustrated when they keep messing up. Look at haskell and suddenly all the functional stuff makes sense, except they stop shooting themselves in the foot so often :)
03:55:12 <gfixler> (that's Odersky at the podeum)
03:55:16 <bernalex> in python whitespace doesn't desugar though -- it's the one true syntax.
03:55:24 <gfixler> *podium
03:55:56 <Zyxoas> Yo, peeps. :-)
03:55:56 <gfixler> merijn: the biggest hurdle is the substrate - Scala rides on Java, which is "Everywhere™"
03:56:09 <dramforever> IIRC {;} is introduced partly because that enables code generation
03:56:10 <chattered> gfixler: Woah. Do you know what the talk was about?
03:56:20 <dramforever> e.g. Coq supports extraction to haskell
03:56:21 <gfixler> chattered: not specifically
03:56:30 <bernalex> gfixler: guido is on the record saying he doesn't understand function compositions. lol.
03:56:30 <gfixler> chattered: keynote, perhaps
03:56:39 <Zyxoas> I need some clarity: what is the point of the "other-extensions" field in cabal files? Do I need to even bother with it?
03:56:53 <gfixler> bernalex: yeah, Guido confuses me at times
03:56:54 <bernalex> Zyxoas: it's if you use lang extensions.
03:57:11 <dcoutts> Zyxoas: it declares the extensions that your package uses. They're sort-of like dependencies if you think about it.
03:57:23 <merijn> Zyxoas: Other-Extensions are ones that are not enabled globally but in use for SOME files
03:57:39 <Zyxoas> What's the point of it? Nothing breaks if I don't use that field...
03:58:02 <merijn> Zyxoas: Until I try to compile with UHC which doesn't support all GHC extensions and your package uses one it doesn't know...
03:58:04 <dcoutts> Zyxoas: current versions of cabal check that the compiler you're using supports those extensions, and the next version of the cabal tool can also take them into account in dependency planning
03:58:13 <Zyxoas> It seems to make no difference whether I use it or not,
03:58:25 <merijn> Zyxoas: Because they don't influence compilation
03:58:39 <Zyxoas> Ah, I see...
03:58:43 <merijn> Zyxoas: But they're documentation about "which extensions does a compiler need to succesfully compile"
03:58:51 <dcoutts> Zyxoas: it's good practice to declare them. It's not currently enforced that you do actually declare them, but one day it might be.
03:59:20 <merijn> I would personally not recommend using cabal to enable extensions (i.e. using that other field whose name I forgot)
03:59:31 <dcoutts> default-extensions
03:59:35 <gfixler> dcoutts: https://twitter.com/gfixler/status/602258414874468352
03:59:44 <merijn> Because I find it confusing to have to look into a cabal file to figure out that some source file is using extension X
04:00:08 <dcoutts> gfixler: heh
04:00:09 <Zyxoas> My build is failing on GHC 7.6 because of DeriveGeneric and DataKinds, but if I remove them from the cabal file but include them in the source code, my project build fine. merjin dcoutts
04:00:09 <gfixler> dcoutts: John's talk at LambdaConf, wherein he said there's no such thing as "Haskell" - the slide is tons of language extensions, which make up some huge number of possible Haskells in various permutations
04:01:15 <frerich> gfixler: The very next slide is this though: http://image.slidesharecdn.com/scaladayssf-150316213819-conversion-gate01/95/scala-days-san-francisco-4-638.jpg?cb=1427048581
04:01:21 <merijn> We don't have a "true" haskell implementation anyway :p
04:01:24 <merijn> Well, maybe UHC?
04:01:40 <gfixler> frerich: :)
04:03:29 <gfixler> I want to write a book of just the crap I didn't know while learning Haskell basics
04:03:36 <gfixler> there are so many things I learned months after I should have
04:03:58 <merijn> gfixler: You mean like the "Stuff I wish I knew while learning haskell" list and bitemyapp's book? :p
04:04:05 <gfixler> merijn: kind of
04:04:14 <gfixler> but really specific little things
04:04:23 <merijn> like?
04:04:39 <gfixler> like that the Fs and Ms in the types are the same functor or monad
04:04:57 <gfixler> I thought for months that monads could switch to other ones across bind
04:05:25 <gfixler> nothing ever explicitly mentioned that functions in Haskell are single expressions
04:05:28 <gfixler> and there are no statements
04:05:33 <gfixler> I just figured it out 'eventually'
04:06:06 <merijn> gfixler: Personally I like the explicit forall introducing type variables, because it makes it more obvious that type variables must be the same :)
04:06:06 <gfixler> and slowly realized that let and where were ways of squeezing more expressions into an expression
04:06:15 * frerich wonders how many people pointing to bitemyapp's book actually read it.
04:06:26 <gfixler> merijn: I'm still not fully down with forall - was just reading more about it last night
04:06:46 <merijn> I just bookmark logs whenever I give useful explanations...
04:06:47 <gfixler> merijn: slowly making my way through answers here:
04:06:47 <tdammers> merijn: my approach is kind of a hybrid - learn the theory until I reach 'critical mass', then pick a real-world project to tackle and keep learning the theory as needed
04:06:49 <gfixler> http://stackoverflow.com/questions/3071136/what-does-the-forall-keyword-in-haskell-ghc-do
04:06:55 <merijn> I explained forall like a week ago or so
04:07:03 <gfixler> tdammers: that's what I've switched to
04:07:07 <frerich> tdammers: same here
04:07:19 <gfixler> tdammers: prior to that, I just kept reading and rereading, hoping things would click
04:07:30 <merijn> Don't the logs have a search function?
04:07:38 <gfixler> merijn: ircbrowse.net does
04:07:40 <dramforever> ircbrowse has search
04:07:54 <merijn> Where?
04:07:59 <gfixler> http://ircbrowse.net/browse/haskell
04:08:04 <merijn> oh, found it
04:08:19 <tdammers> I've done that with every language so far, both programming and human
04:08:46 <tdammers> it took longer with Haskell, but I believe that's because there were so many new concepts and approaches to get used to
04:08:46 <gfixler> http://ircbrowse.net/browse/haskell?id=21196160&timestamp=1438958079#t1438958079
04:09:05 <gfixler> took/is still taking me way longer with Haskell
04:09:06 <merijn> gfixler: Right, start there :)
04:09:28 <gfixler> I need to get ircbrowse.net logs hooked up to Vim :)
04:09:39 <merijn> gfixler: There's a bit of a detour before it gets to my explanation there, but can't hurt
04:09:54 <gfixler> merijn: I grok the use of forall with where clauses
04:10:01 <gfixler> but only that
04:10:29 <Zyxoas> > 4*4
04:10:30 <lambdabot>  16
04:10:55 <gfixler> merijn: according to one answer on SO: "A complete explanation of the forall keyword requires math and can be understood only by someone who has studied the math. Even partial explanations are hard to understand without math."
04:11:11 <merijn> gfixler: pah, bogus
04:11:21 <gfixler> merijn: \o/ good to hear
04:12:06 <merijn> gfixler: Wait, this is a better start: http://ircbrowse.net/browse/haskell?id=21168810&timestamp=1438606396#t1438606396
04:13:05 <tdammers> gfixler: I stand corrected :D
04:15:52 <gfixler> merijn: \(T :: *) <- is that * the kind?
04:16:10 <merijn> gfixler: Yes
04:16:39 <merijn> gfixler: System F_ω (and GHC Core) support passing types as arguments to functions explicitly
04:16:51 <merijn> In fact, that's how they do polymorphism
04:17:36 <gfixler> merijn: I believe I recall SPJ showing this in his "Adventures with Types in Haskell" talk
04:17:54 <gfixler> passing around a record
04:18:08 <dramforever> merijn: oh and types are erased but dictionaries remain?
04:18:10 <dramforever> interesting
04:18:33 * hackagebot travis-meta-yaml 0.0.1.0 - .travis.yml preprocessor  https://hackage.haskell.org/package/travis-meta-yaml-0.0.1.0 (phadej)
04:19:45 <merijn> dramforever: Yes
04:19:51 <dramforever> great
04:20:03 <merijn> dramforever: (I think, I'm not an authorative source :p)
04:20:21 <merijn> gfixler: That's about the implementation of typeclasses, but this thing of explicit passing is similar, yes
04:21:42 <gfixler> I'll have to get to bed in a minute, but I realize I have an opportunity to ask a question here
04:22:03 <gfixler> what's the relation, if any, between Rank2Types and RankNTypes?
04:22:35 <gfixler> isn't Rank2Types part of RankNTypes? Why do we need to the former?
04:22:41 <liste> gfixler historical reasons
04:22:47 <merijn> liste: No, theoretical reasons
04:22:51 <chattered> I believe rank-2 supports type inference.
04:22:55 <merijn> chattered++
04:22:56 <chattered> (full)
04:23:39 <liste> what if I just use rank-2 types with RankNTypes ext, can type inference still fail?
04:23:58 <mniip> they are the same
04:24:01 <merijn> gfixler: Ok, so haskell has (implicit) forall on the left most part of a signature. Rank2 and RankN types allow forall's to occur in other locations. This means you can express more of the types that are possible in the underyling Core, however RankN types are not inferrable, which is why they require explicit annotation
04:24:07 <dramforever> IIRC ghc didn't implement Rank2 inference
04:24:24 <mniip> because rank 3 inference is undecidable in general
04:24:26 <merijn> gfixler: Here's an example of using RankN: https://gist.github.com/merijn/77e3fa9757658e59b01d
04:24:30 <merijn> dramforever: Correct
04:24:31 <liste> or is it just to make sure I won't use rank-n types where n>2
04:24:40 <dramforever> who needs rank 3 types..
04:24:59 <merijn> GHC does not infer Rank2, but it might in the future, so Rank2 types are a separate extension in case (in the future) Rank2 inference is added
04:25:34 <merijn> gfixler: So RankN is a superset of Rank2 types, but the former is not decidable (i.e. inferrable), but the second is (although GHC currently doesn't)
04:25:36 <gfixler> merijn: I had that open from your lesson that I'm reading through on ircbrowse :)
04:25:38 <bennofs> merijn: I thought Rank2 was deprecrated?
04:25:40 <chattered> The rank is specifically about how many times you go down the left of an arrow to put your forall. A forall on the right can always be brought to the top, and you can think of Hindley-Milner doing that for you everywhere.
04:25:43 <merijn> bennofs: No
04:25:54 <gfixler> merijn: okay, good to know - is inference intended to be added at some point?
04:25:56 <dramforever> IICRreturn sum + T[x].sum;return sum + T[x].sum;
04:26:03 <dramforever> ouch sorry
04:26:10 <dramforever> wrong window
04:26:19 <merijn> gfixler: Not unless some volunteer steps up. The inference is considerably harder than inferring "plain" haskell
04:26:25 <gfixler> merijn: okay
04:26:37 <dramforever> merijn: wait I don't think it's decidable
04:26:39 <merijn> gfixler: So it's a messy job that doesn't let you publish papers, so there isn't a lot of motivation to do it
04:26:47 <merijn> dramforever: What isn't?
04:27:04 <mniip> merijn, I heard that rank 2 inference is too complex to appear in a tiny and simple project like ghc
04:27:13 <dramforever> merijn: rank 2 inference
04:27:15 <dramforever> say we have foo f = (f "something", f (2 :: Int))
04:27:17 <merijn> dramforever: It is
04:27:20 <dramforever> what's the type of foo?
04:27:21 <merijn> dramforever: GHC just doesn't do it
04:27:35 <dramforever> merijn: infer the type of foo
04:27:35 <gfixler> mniip: ghc is tiny and simple?
04:28:05 <dramforever> did I do something bad?
04:28:06 <mniip> compared to rank 2 inference, yes
04:28:09 <merijn> dramforever: The literature says that there is an inference algorithm, but I don't know what it is :)
04:28:11 <mniip> that's what I heard
04:28:39 <dramforever> merijn: sigh...did I just ruin your view on rank2 types?
04:28:42 <gfixler> merijn: perhaps the margin was too small to contain it
04:28:42 <merijn> dramforever: https://dl.acm.org/citation.cfm?id=859873
04:28:42 <dramforever> sorry
04:29:13 <merijn> I don't think we'll ever actually have Rank2 inference in GHC. Too much work for too little pay-off
04:29:17 <bennofs> dramforever: it's foo :: (forall a. a -> x) -> (x,x) ?
04:29:19 <merijn> Writing down types isn't that cumbersome
04:29:24 <merijn> bennofs: Yes
04:29:40 <merijn> "forall x . (forall a . a -> x) -> (x, x)" if we want to be pedantic
04:29:59 <dramforever> bennofs: no, what about foo :: (forall a. Show a => a -> String) -> (String, String)?
04:30:13 <merijn> dramforever: That unifies with our type :)
04:30:27 <dramforever> but neither is more general IIUC
04:30:33 <bennofs> dramforever: ghc infers the most general signature
04:30:38 <merijn> dramforever: Sure it is
04:30:43 <dramforever> wait wait...
04:30:46 <dramforever> fail
04:30:52 <dramforever> sigh...sorry about that
04:30:55 <merijn> :)
04:31:00 <dramforever> thought I discovered something interesting
04:31:10 <mniip> there's a problem though
04:31:13 <gfixler> merijn: so in your NoRankN.hs, is the problem that the (a -> a) function might convert Int to Double, or vice versa?
04:31:16 <bennofs> merijn: hmm, no it's not. you can use foo' (with Show => constraint) in more cases than you can use foo
04:31:34 <merijn> gfixler: It might be applied to either Int or Double, but the caller doesn't know which
04:31:38 <bennofs> merijn: foo show is ill-typed, will foo' show works
04:31:43 <mniip> in covariant foralls you want to infer a join of multiple types
04:31:49 <bennofs> so arguably, foo' is more general
04:31:49 <merijn> gfixler: But without RankN the *caller* has to pick the type of 'a'
04:31:57 <dramforever> bennofs: oh yes!
04:31:59 <mniip> in contravatiant, you want to infer a meet
04:32:04 <merijn> gfixler: But whatever you pick might turn out to be wrong
04:32:09 <dramforever> bennofs: no!
04:32:12 <gfixler> merijn: whoa
04:32:16 <bennofs> dramforever, merijn: to find the most general type, you need to find all instances of a type
04:32:17 <dramforever> wtf...never mind
04:32:24 <dramforever> bennofs: not really
04:32:30 <dramforever> the general sig works
04:32:40 <mniip> and haskell typesystem doesn't always have minimal meets
04:32:41 <merijn> gfixler: The forall effectivelly says that the "callee" (i.e. the function being called) gets to pick the type 'a'
04:32:55 <bennofs> @let foo :: (forall a. a -> x) -> x; foo f = (f "hello", f 32)
04:32:56 <lambdabot>  .L.hs:146:9:
04:32:56 <lambdabot>      Couldn't match expected type ‘x’ with actual type ‘(x, x)’
04:32:56 <lambdabot>        ‘x’ is a rigid type variable bound by
04:33:00 <merijn> gfixler: Basically, "(a -> a)" says "I work for some, caller decided, type 'a'"
04:33:01 <bennofs> @let foo :: (forall a. a -> x) -> (x,x); foo f = (f "hello", f 32)
04:33:03 <lambdabot>  Defined.
04:33:06 <bennofs> > foo show
04:33:07 <lambdabot>      No instance for (Show a) arising from a use of ‘show’
04:33:07 <lambdabot>      Possible fix:
04:33:07 <lambdabot>        add (Show a) to the context of
04:33:08 <quicksilver> I think dramforever's Show type is not rank 2?
04:33:16 <bennofs> @let foo' :: (forall a. Show a => a -> x) -> (x,x); foo f = (f "hello", f 32)
04:33:17 <lambdabot>  .L.hs:144:1:
04:33:17 <lambdabot>      The type signature for ‘foo'’ lacks an accompanying binding
04:33:21 <bennofs> @let foo' :: (forall a. Show a => a -> x) -> (x,x); foo' f = (f "hello", f 32)
04:33:22 <lambdabot>  Defined.
04:33:25 <bennofs> > foo' show
04:33:26 <lambdabot>  ("\"hello\"","32")
04:33:29 <dramforever> wow
04:33:31 <bennofs> so which one is more general now?
04:33:33 <quicksilver> bennofs gave the correct rank 2 inference, and dramforever's example shows that rank-N inference isn't unique
04:33:36 <quicksilver> no?
04:33:39 <merijn> gfixler: Whereas "(forall a . a -> a)" says "I work for *all* possible types 'a'"
04:33:43 <dramforever> quicksilver: seems so
04:33:46 <merijn> gfixler: The forall has a very literal meaning :)
04:33:53 <mniip> guys
04:33:53 <bennofs> the only possible use of foo seems to be: 'foo id'
04:33:59 <dramforever> :t foo
04:34:00 <lambdabot> (forall a. a -> x) -> (x, x)
04:34:09 <dramforever> > foo (const 2) -- n
04:34:10 <lambdabot>  (2,2)
04:34:11 <dramforever> *no
04:34:15 <bennofs> oh, id + const
04:34:23 <merijn> id actually won't work
04:34:23 <gfixler> merijn: thanks, this gives me something to stew on
04:34:34 <dramforever> yes id doesn't work
04:34:34 <bennofs> > foo $ join (,) too
04:34:35 <lambdabot>      Not in scope: ‘too’
04:34:35 <lambdabot>      Perhaps you meant one of these:
04:34:35 <lambdabot>        ‘foo’ (line 148), ‘to’ (imported from Control.Lens)
04:34:37 <bennofs> > foo $ join (,) -- too
04:34:37 <gfixler> and now for bed - night all
04:34:38 <lambdabot>      Couldn't match type ‘x’ with ‘(a, a)’
04:34:38 <lambdabot>        because type variable ‘a’ would escape its scope
04:34:38 <lambdabot>      This (rigid, skolem) type variable is bound by
04:34:39 <dramforever> wait
04:34:42 <bennofs> ah no
04:34:51 <bennofs> even id doesn't work
04:35:05 <bennofs> so you cannot use the 'a' at all :)
04:35:07 <dramforever> @let foo2 :: (forall a. a -> a) -> (String,Int); foo2 f = (f "hello", f 32)
04:35:08 <lambdabot>  Defined.
04:35:11 <merijn> bennofs: Right
04:35:12 <dramforever> > foo2 id
04:35:14 <lambdabot>  ("hello",32)
04:35:16 <bennofs> which in retrospect, is obvious
04:35:25 <mniip> guys
04:35:30 <merijn> bennofs: Although Rank2 types like this make more sense if you have, for example a GADT with a phantom type :)
04:35:31 <dramforever> mniip: ?
04:35:33 <mniip> I just explained the problem above
04:35:42 <merijn> bennofs: "forall a . Foo a -> x" is more useful :)
04:36:01 <bennofs> merijn: yeah. was the type sig I gave the correct Rank2-inferred one?
04:36:10 <bennofs> merijn: so the correct one is not the most general one?
04:36:17 <bennofs> s/correct/inferred
04:36:23 <mniip> there is no most general one
04:36:35 <merijn> bennofs: It's correct, most general I dunno :p
04:36:44 <dramforever> hmm...covariant and contravariant forall
04:36:45 <merijn> This is near the limit of my knowledge :p
04:37:02 <dramforever> merijn: wait it can't be the most general
04:37:07 <bennofs> mniip: oh, overread, thanks (never heard of "needs" before :)
04:37:11 <dramforever> let foo2 :: (forall a. a -> a) -> (String,Int); foo2 f = (f "hello", f 32)
04:37:16 <dramforever> this works with id
04:37:38 <dramforever> that one has to return a tuple (x, x)
04:37:46 <dramforever> this can have two different types
04:38:52 <merijn> I don't know the formal definition of most general
04:39:02 <dramforever> me neither
04:39:07 <mniip> if you have 'if _ then x :: X else y :: Y', you want the resulting expression to have type Join X Y
04:40:02 <mniip> if you have '(f (x :: X), f (y :: Y))', you want f to have type 'Meet X Y -> ...'
04:40:19 <bennofs> not Join X Y ?
04:40:30 <mniip> haskell typesystem has minimal joins for any types
04:40:56 <mniip> in cases where they can't be joined, it's always a type error
04:41:11 <bennofs> ah
04:41:19 <mniip> not so good is the situation with minimal meets
04:41:42 <mniip> you'd need union types
04:41:56 <mniip> (not to be confused with sum types)
04:42:12 <bennofs> mniip: is there no Join Int String?
04:42:49 <mniip>  because its a type error
04:43:20 <bennofs> mniip: wouldn't (forall a. Show a => a) be a valid type?
04:43:57 <dramforever> bennofs: there aren't any inhabitants, though
04:44:08 <mniip> no
04:44:19 <bennofs> dramforever: oh, right. I wanted (exists a. Show a => a), but that's not Haskell ofc
04:44:24 <mniip> that type is an intersection
04:48:15 <mniip> hmm
04:48:27 <mniip> I always confuse intersections and unions
04:48:52 <bennofs> if _ then x :: X else y :: Y, don't you want an intersection here?
04:49:47 <mniip> no
04:50:14 <mniip> actually I'm not sure
04:50:23 <mniip> :)
04:51:54 <keko_> mniip: I'm a bit confused by this discussion, can you give an example of a Join instance?
04:52:12 <keko_> do you mean something like Monad m => Join (m ()) (IO ()) ?
04:52:56 <mniip> Join (forall a. X a) (forall f. f Y) = X Y
04:53:34 * hackagebot bitx-bitcoin 0.3.0.0 - A Haskell library for working with the BitX bitcoin exchange.  https://hackage.haskell.org/package/bitx-bitcoin-0.3.0.0 (tebello_thejane)
04:53:44 <mniip> more confusingly,
04:53:47 <dramforever> @let data Join a b where Join :: a -> Join a a
04:53:48 <lambdabot>  Defined.
04:54:08 <mniip> forall x y. Join (forall a. x a) (forall f. f y) = x y
04:54:13 <dramforever> no use
04:54:48 <mniip> @undefine
04:54:48 <lambdabot> Undefined.
04:55:13 <mniip> @let join :: a -> a -> a; join = undefined
04:55:14 <lambdabot>  Defined.
04:55:33 <mniip> :t join [] (return True)
04:55:34 <lambdabot>     Ambiguous occurrence ‘join’
04:55:34 <lambdabot>     It could refer to either ‘L.join’,
04:55:34 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:143:1
04:55:46 <mniip> ouch, but you get the idea
04:55:55 <mniip> :: [Bool]
04:58:48 <keko_> ah, I understood something slightly wrong at first
04:59:55 <keko_> I thought Join X Y was a typeclass meaning "X and Y can be joined" rather than a type function that actually tells you what you get when you join X and Y
05:00:04 <keko_> if that makes sense
05:01:06 <dramforever> @undefine
05:01:06 <lambdabot> Undefined.
05:01:16 <dramforever> @let type family Join a b
05:01:17 <lambdabot>  Defined.
05:01:23 <dramforever> @let type Join a a = a
05:01:24 <lambdabot>  .L.hs:144:1:
05:01:24 <lambdabot>      Multiple declarations of ‘Join’
05:01:24 <lambdabot>      Declared at: .L.hs:142:1
05:01:32 <dramforever> @let type instance Join a a = a
05:01:33 <lambdabot>  Defined.
05:01:48 <dramforever> :kind! Join (m ()) [a]
05:01:56 <dramforever> no such command...
05:02:00 <mniip> :k
05:02:13 <dramforever> :k! Join (m ()) [a]
05:02:28 <mniip> why !
05:02:54 <dramforever> expand type synonyms
05:03:12 <mniip> kind synonyms you mean?
05:04:06 <dramforever> forget about it
05:04:10 <dramforever> doesn't work...
05:08:39 <mniip> :t jn [] (return True)
05:08:40 <lambdabot> [Bool]
05:08:43 <mniip> :t jn
05:08:44 <lambdabot> r -> r -> r
05:08:48 <mniip> wat
05:08:58 <mniip> ghc outsmarted me
05:09:33 <mniip> [13:07] (mniip) @let class Join a b r | a b -> r where jn :: a -> b -> r
05:09:36 <mniip> [13:07] (mniip) @let instance (a ~ r, b ~ r) => Join a b r where jn = undefined
05:09:45 <dramforever> oh?
05:09:49 <dramforever> oh I know
05:10:36 <keko_> @let ourJoin :: a -> a -> a; ourJoin = undefined
05:10:37 <bennofs> mniip: oh wow
05:10:37 <lambdabot>  Defined.
05:10:46 <keko_> :t ourJoin [] (return True)
05:10:47 <lambdabot> [Bool]
05:11:05 <mniip> it probably detects that the class is closed under ambiguity restriction
05:11:29 <mniip> and since there is only one instance, it can inline the instance head into the signature
05:11:45 <mniip> and then it proceeds to inline ~ too
05:12:03 <mniip> er
05:12:18 <mniip> s/instance head/instance context/
05:17:35 <bennofs> mniip: I think it's the same as eliding (Show Int => ...) constraints when you write :t show :: Int -> String
05:18:23 <mniip> well that part is pretty simplistic
05:18:28 <mniip> the other one is not
05:34:13 <cow_2001> :t fix
05:34:14 <lambdabot> (a -> a) -> a
05:34:16 <cow_2001> :|
05:34:19 <cow_2001> idgi
05:35:36 <dramforever> :t \f -> let x = f x in x
05:35:37 <lambdabot> (r -> r) -> r
05:36:28 <cow_2001> wait, how did you get that x D:
05:36:51 <cow_2001> it looks recursive
05:37:09 <dramforever> google Y combinator
05:37:13 <aweinstock> it is (a recursive value)
05:37:34 <dramforever> :t fix (1:)
05:37:35 <lambdabot> Num a => [a]
05:37:35 <cow_2001> okay. no, not the VC thing
05:37:39 <geekosaur> it is. it's also lazy, so if f produces part of a result before evaluating its parameter, it can be usefil
05:37:44 <dramforever> > fix (1:)
05:37:46 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:38:01 <cow_2001> what is this magic :D
05:38:04 <aweinstock> there's a variant of the Y combinator that work with strict languages (explicitly using thunks to delay/force evaluation)
05:39:29 <dramforever> it's possible to write a Y in haskell combinator that doesn't use recursion, with some type-level magic
05:39:36 <dramforever> but it confuses the ghc compiler
05:40:01 <dramforever> ghc happily tries to inline it because it doesn't look recursive
05:41:34 <cow_2001> oooh
05:41:46 <aweinstock> (define (Y X1)
05:41:46 <aweinstock>       ((lambda (X2) (X1 (lambda (arg) ((X2 X2) arg))))
05:41:46 <aweinstock>        (lambda (X2) (X1 (lambda (arg) ((X2 X2) arg))))))
05:41:52 <cow_2001> so, huhm
05:42:02 <aweinstock> from step 5 on http://www.ece.uc.edu/~franco/C511/html/Scheme/ycomb.html with the variables renamed
05:42:12 <cow_2001> let me re-read the thing i'm trying to understand
05:42:23 <aweinstock> (not sure whether that's more or less enlightening)
05:43:11 <cow_2001> it all looks pretty much like greek to me
05:44:05 <cow_2001> i understand it is applying the function on the result of another application of that function applied on a result of application applied on a....
05:44:14 <cow_2001> f (f (f...
05:44:37 <aweinstock> > fix (const 5)
05:44:38 <lambdabot>  5
05:44:58 <cow_2001> :t const
05:44:59 <lambdabot> a -> b -> a
05:45:12 <cow_2001> it disregards b?
05:45:17 <aweinstock> tes
05:45:18 <aweinstock> yes
05:45:18 <geekosaur> cow_2001, behold the power of non-strict evaluation
05:45:25 <aweinstock> :t curry fst
05:45:26 <lambdabot> c -> b -> c
05:45:52 <quchen2> foo = fix $ \rec -> … rec …    ===   foo = … rec …   That's what fix does.
05:46:00 <quchen2> foo = fix $ \rec -> … rec …    ===   foo = … foo …   That's what fix does.
05:46:02 <quchen2> Fixed.
05:46:04 <quchen2> :-s
05:46:06 <cow_2001> O_o
05:46:31 <cow_2001> woah. curry fst is const D:
05:47:33 <cow_2001> quchen2: what happens in the '…'s?
05:47:46 <quchen2> Some arbitrary stuff.
05:47:54 <dramforever> cow_2001: they are repeated
05:48:28 <quchen2> fac n = fix $ \rec x -> if x <= 1 then 1 else x * rec (n-1)   ===   fac n = if n <= 1 then 1 else n * fac (n-1)
05:48:44 <quchen2> Note how the first definition uses a non-recursive lambda.
05:49:00 <quchen2> The "fix" then makes that first lambda parameter, "rec", refer to the entire lambda again.
05:49:10 <quchen2> That way it ties the knot to introduce recursion in a non-recursive lambda.
05:49:36 <aweinstock> > fix (\f x -> if x < 5 then x : f x else [])
05:49:38 <lambdabot>  <Integer -> [Integer]>
05:49:45 <quchen2> I wrote about this in much more detail and with examples here: https://github.com/quchen/articles/blob/master/fix.md
05:49:45 <aweinstock> > fix (\f x -> if x < 5 then x : f x else []) 0
05:49:47 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
05:50:01 <aweinstock> > fix (\f x -> if x < 5 then x : f (x+1) else []) 0
05:50:02 <lambdabot>  [0,1,2,3,4]
05:52:14 * cow_2001 ponders
05:52:21 <roundrobin1> what is the name of a type defined without a "= .. " ? E.g. `data Foo a` ?
05:52:34 <chattered> Uninhabited?
05:53:22 <srhb> roundrobin1: The only one of those that has a common name is probably data Void
05:53:34 <merijn> chattered: Not in haskell :)
05:53:40 <merijn> chattered: All types are inhabited in haskell
05:53:41 <quicksilver> empty
05:53:44 <quicksilver> is another word for them.
05:53:50 <merijn> But yeah, "void"/empty is the usual name
05:53:57 <roundrobin1> srhb quicksilver : thanks.
05:54:09 <Zoetrope> merijn: Just for my own learning, except for strict types?
05:54:14 <zennist> is there any other function of the type a -> a other than id
05:54:19 <quicksilver> I would still call them uninhabited. They are uninhabited in the logic which underlies haskell.
05:54:23 <wei2912> quchen2: thanks for that article!
05:54:23 <chattered> But if you use "empty" then you end up saying "non-empty", which makes non-emptiness sound like the negative property.
05:54:26 <dramforever> zennist: yes, undefined
05:54:31 <dramforever> or some infinite loop
05:54:32 <merijn> Zoetrope: There are no strictypes
05:54:37 <merijn> Zoetrope: Only strict constructors
05:54:42 <zennist> dramforever: well, I should say banning that :P
05:54:52 <dramforever> no then
05:55:12 <zennist> all right, looks like my knowledge hasn't gone too dusty
05:55:42 <Zoetrope> Oh right of course, interesting
05:56:21 <Zoetrope> That's actually a little bit scary
05:57:06 <merijn> Zoetrope: Why?
05:57:50 <merijn> zennist: It's perfectly defensible to pretend undefined doesn't exist! Fast and loose reasoning is morally correct! http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html
05:58:04 <Zoetrope> Bottom just reminds me of null somewhat
05:58:41 <quchen2> You can check for null.
05:58:43 <merijn> Zoetrope: It's a result of being Turing complete
05:58:45 <bennofs> Zoetrope: the difference is that bottom cannot be observed in the language itself
05:58:45 <quchen2> You cannot check for bottom.
05:58:51 <chattered> Zoetrope: null reminds me of undefined. But in languages with null, it's used as data.
05:59:01 <merijn> Zoetrope: undefined (or bottom) is equivalent to an infinite loop
05:59:14 <merijn> Zoetrope: As you may know, detecting infinite loops is impossible
05:59:38 <merijn> Zoetrope: The solution is to ditch Turing completeness and program in a total language (total -> all evaluations terminate)
06:00:04 <merijn> Agda and Coq are total and Idriss I believe has an optional totality checker 
06:00:20 <Zoetrope> Yeah I program in idris, it's making my haskell rusty
06:00:40 <merijn> Zoetrope: How's the library situation?
06:00:52 <merijn> Also, I wish Idris was lazy :(
06:01:03 <srhb> At least it has optional laziness.
06:01:10 <merijn> srhb: Not good enough
06:01:14 <srhb> No, I agree.
06:01:16 <quchen2> Just like Java has optional not-using-null.
06:01:19 <Zoetrope> Getting better I think, I'm working on something at the moment, who knows if I'll ever get it to release
06:01:22 <merijn> Actually, worse, that makes you feel it's useful while not being so
06:01:32 <srhb> merijn: OK, that I don't understand. Elaborate?
06:02:46 <merijn> srhb: The problem is that it's not possible to quickly "add" laziness. I mean, you can, but it doesn't do what you want
06:02:53 <merijn> whereas selectively adding strictness is easy
06:02:59 <srhb> merijn: Ah, okay.
06:03:02 <srhb> I was not aware of that.
06:03:13 <quchen2> Keep elaborating please.
06:03:26 <quchen2> I'm not sure why adding laziness is harder than adding strictness.
06:03:31 <srhb> Neither am I.
06:03:35 <aweinstock> why doesn't opt-in laziness help? (is it that the main benefit is modularity, which only helps when everything is modular?)
06:04:02 <aweinstock> network-effect, kind of?
06:04:03 <merijn> quchen2: Imagine something similar to "take 100 $ map f . map g . map h $ myHugeList"
06:04:21 <merijn> Where the maps are actually different functions with similar behaviour
06:04:47 <cow_2001> i'm reading this and it's defining an Arrow instance of (Behavior t) http://phaazon.blogspot.co.il/2015/03/getting-into-netwire.html
06:04:51 <merijn> Simply making the argument to "take 100" lazy is insufficient, because once you "unwrap" that level of laziness you still end up strictly traversing the hugeList 3 times
06:05:11 <cow_2001> arr f = fix $ \r -> Behavior $ \t a -> (f a, r)
06:05:17 <merijn> Whereas if everything is lazy, making the argument to "take 100" strict *will* force everything, like you wanted
06:05:27 <srhb> merijn: Oh, I actually thought that defining a lazy list structure would be sufficient
06:05:29 <phaazon> hi
06:05:30 <merijn> Laziness can *never* perform more work that strictness
06:05:30 <srhb> Hence the confusion I guess
06:05:43 <merijn> srhb: Then none of your strict list functions work...
06:05:46 <phaazon> cow_2001: getting your feet wet with netwire? :)
06:05:48 <srhb> Huh, really.
06:05:49 <aweinstock> merijn: by more than a constant factor?
06:05:53 <cow_2001> phaazon: yes!
06:05:57 <merijn> srhb: You get the lazy vs strict ByteString problem
06:06:00 <cow_2001> phaazon: thank you for the post!
06:06:01 <aweinstock> merijn: (or is it true without that caveat?)
06:06:02 <phaazon> hehe, good luck :)
06:06:05 <phaazon> you're welcome
06:06:06 <merijn> aweinstock: huh?
06:06:11 <merijn> aweinstock: It's true without caveat
06:06:24 <merijn> aweinstock: Lazy evaluation can never perform more work, worst case is equal work
06:06:41 <aweinstock> merijn: isn't there overhead in manipulating thunks?
06:06:42 <merijn> The problem with laziness is not computation, but memory allocated by thunks
06:07:00 <bennofs> IMO using the same data type for finite lists and streams is not a good idea.
06:07:40 <merijn> But excessive lazy thunk buildup happens rarely, and when it does it's usually in one single location. So it's easy enough to add a single strictness annotation *there*
06:07:43 <merijn> i.e. see foldl'
06:07:47 <aweinstock> I'm not sure I understand the distinction (why isn't allocating memory considered computation?)
06:08:21 <edk> it's a different thing in terms of complexity analysis
06:08:44 <merijn> The problem is that solving the problem caused by laziness is very simple to do in a local and restricted manner
06:08:45 <aweinstock> oh, I wasn't counting space usage, but the time/cycles it takes to deal with thunks
06:09:24 <merijn> Whereas solving a strictness issue requires invasively modifying every computation you depend on to be lazy
06:09:37 <edk> aweinstock, i think it'd be difficult to factor that in sensibly
06:09:53 <aweinstock> (I understand that lazyness is *asymptotically* at least as time-efficient as strictness, and am just wondering about the constant factors)
06:10:28 <merijn> aweinstock: There's a constant factor, sure.
06:10:32 <edk> well, the constant factors are implementation issues that it's difficult to prove minimal
06:11:30 <Zoetrope> I guess it's just have to have widespread laziness with totality at the moment, I think for now I prefer totality
06:11:31 <dramforever> also memory usage is a problem
06:11:31 <merijn> Anyway, my argument for defaulting to laziness is that it's easier to retroactively force things than to retroactively make them lazy. And forcing a lazy thing won't do more computation than if it was strict to begin with
06:11:36 <Zoetrope> *hard to have
06:11:44 <merijn> Zoetrope: huh?
06:11:52 <merijn> Zoetrope: totality is a property of type checking/language semantics
06:11:58 <dramforever> merijn: "forcing a lazy thing won't do more computation than if it was strict to begin with" false
06:12:10 <merijn> Zoetrope: It'd be trivial (theoretically, not practically) to make Idris lazy
06:12:23 <merijn> dramforever: Oh? How so?
06:12:36 <dramforever> merijn: did you know that extra strictness can cause code to become slower?
06:12:54 <merijn> dramforever: That's something different from what I said
06:13:07 <Zoetrope> Really? What about using infinite streams in the type level?
06:13:08 <dramforever> oh sure
06:13:26 <dramforever> merijn: the problem is forcing has to check if it's evaluated anyway
06:13:30 <merijn> dramforever: I said that if you need to force a computation (e.g. foldl) forcing it doesn't cost you anything extra compared to if your entire foldl input was strict anyway
06:13:44 <dramforever> I doubt if it's true
06:13:47 <merijn> dramforever: constant factor that disappears in asymptotics
06:13:55 <merijn> dramforever: We're talking asymptotically here
06:13:59 <krakrjak> dramforever: what's so hard to believe?
06:14:04 <dramforever> merijn: oh sure okay
06:14:19 <dramforever> sorry I didn't read the full discussion
06:14:31 <safinaskar> please, help me compile this code: http://paste.debian.net/290942/ . this is about monad transformers
06:14:33 <merijn> dramforever: Clearly for sufficiently small values it *might* be slower, but for values that small you don't really care about the cost
06:14:44 <safinaskar> i write somewhat my own Reader and State
06:14:44 <krakrjak> dramforever: lazy evaluation just puts of the cost of normalization until the data is required.  it's a tradeoff in time now vs time later.
06:14:51 <dramforever> yes
06:14:58 <merijn> And in lots of cases forcing the lazy thing is cheaper than, e.g. performing a triple strict map
06:16:14 <safinaskar> also, this code is my atempt to solve my old problem: how to program imperatively in haskell, how to have functions which can modify this-and-that variables. i dusscussed this with chpatrick and ski, ping
06:16:38 <safinaskar> the code is highly commented
06:17:09 <aweinstock> safinaskar: is the goal to understand how to implement monad transformers, or to solve something specific?
06:17:33 <safinaskar> aweinstock: solve some specific problem, i described it in the beginning
06:17:37 <bennofs> safinaskar: congrats, you've just discovered a problem with monad transformers! :=)
06:18:20 <dramforever> safinaskar: OverlappingInstances is almost never a good idea
06:18:26 <bennofs> safinaskar: you need to make a new instance for each concrete t, i.e. you need instance AR m => AR (ReaderT r m); instance AR n => AR (WriterT r m); ....
06:18:33 <dramforever> especially since those two instances are redundant
06:18:36 <dramforever> aren't they
06:18:43 <bennofs> dramforever: no, they're not redundant
06:18:52 <dramforever> oh lemme check
06:19:03 <aweinstock> safinaskar: is there a reason you're using "data" instead of "newtype"?
06:20:28 <dramforever> bennofs: I'm sure they are redundant
06:20:40 <latk> Does anyone know of an ubuntu vagrantfile using stack ?
06:21:05 <bennofs> dramforever: line 48 
06:21:06 <aweinstock> safinaskar: by "to solve something specific", I meant: is recommending the use of already-existing implementations of ReaderT/StateT bypassing your question, or a valid answer?
06:21:13 <bennofs> dramforever: + line 70 are overapping
06:21:19 <dramforever> yes
06:21:30 <dramforever> and the two instances are basically the same thing
06:21:46 <safinaskar> i added my examples how i want to use this code: http://paste.debian.net/290944/
06:21:50 <bennofs> dramforever: and not rendunant, because the one instance lifts while the other reads
06:21:59 <dramforever> oh wait
06:22:09 <dramforever> sorry I made a mistake
06:22:10 <krakrjak> safinaskar: I echo aweinstock here, AReaderT, BReaderT, and AStateT should be newtype wrappers and not data unless you have a good argument.
06:23:35 <safinaskar> also, please try to compile with newer ghc version
06:23:58 <krakrjak> is the instance in line 70 redundant?  the lift on line 48 should just do the right thing yeah?
06:26:08 <safinaskar> bennofs: "you need to make a new instance for each concrete t" - why? let's assume i did so. and let's assume i have 26 transformers (a, b, c, ..., of course, i will use template haskell). but then i will have to make 26 x 26 instances for every pair of instances. this is too bad
06:26:26 <bennofs> safinaskar: and exactly what mtl does :|
06:26:50 <bennofs> safinaskar: also, for some transformers, the combination does not pass the transformer's law
06:26:53 <safinaskar> aweinstock: "data" instead of "newtype" - no, i will switch
06:27:05 <bennofs> safinaskar: so some instances of the 26*26 matrix are missing
06:28:08 <bennofs> safinaskar: for example, there is no MonadWriter w m => MonadWriter w (ContT r m): http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Writer-Lazy.html
06:28:38 * hackagebot vcs-web-hook-parse 0.1.0.0 - Parse development platform web hook messages.  https://hackage.haskell.org/package/vcs-web-hook-parse-0.1.0.0 (akrasner)
06:29:34 <safinaskar> dramforever: "I'm sure they are redundant" - you mean AR (AStateT m) and AS (AStateT m), right? i need them. i need AS (AStateT m) because i want, for example, AStateT Identity to be AS. i need AR (AStateT m), because i need to prove that AStateT is AR and only after that i can prove that AStateT is AS (because class AS is defined as "(AR m) =>...")
06:29:46 <dramforever> no I made a mistake
06:29:48 <dramforever> sorry
06:30:21 <safinaskar> also, there is no instance AR Identity or AS Identity
06:31:47 <safinaskar> aweinstock: ReaderT is not ok for me.  because i need several distinct entities i want to modify. i need one ReaderT for every such entity. and i will generate one using template haskell
06:32:03 <aweinstock> safinaskar: http://lpaste.net/138418
06:33:36 <safinaskar> bennofs: yes, the compiler says that 48 + 70 = overlapping, but i don't see this overlapping
06:34:07 <safinaskar> overlapping will occur only if i make some strange monad, for example, AReaderT (AReaderT Identity), but i have no plans to create such monads
06:34:28 <zennist> actually, for a -> a, there can be many implementations other than id
06:34:37 <zennist> e.g. f a = head [a]
06:34:40 <bennofs> safinaskar: (t m) and (AStateT m) overlap, because t could be AStateT m
06:34:49 <bennofs> s/AStateT m/AStateT
06:34:59 <safinaskar> so, yes, AReaderT (AReaderT Identity) really brokes everything. but is this an error? i. e. is this possible to say to compiler: "i will not construct AReaderT (AReaderT Identity), please, accept my code"?
06:35:09 <aweinstock> zennist: that's another way of writing id
06:35:09 <niklasb> zennist: how is that not id?
06:36:19 <zennist> niklasb: mhh, does it have different behavior in terms of laziness?
06:36:21 <keko_> I suppose they mean it in the sense that 2 + 2 has answers other than 4, such as 1 + 3
06:36:24 <aweinstock> safinaskar: have you looked at this? http://lpaste.net/138418
06:36:40 <keko_> but the answers are all equal
06:36:42 <quchen2> \a -> head [a] is id.
06:36:44 <niklasb> zennist: even if it does, that wouldn't make it a different function
06:37:44 <aweinstock> keko_: https://ro-che.info/ccc/18.html
06:38:38 <safinaskar> krakrjak and others: instances in 48 and 70 are different things.   48 is for adding *any* monad tranformer to some monad, which is already AR.     for example, i have AReaderT Identity. i add to it any monad tranformer, for example, BReaderT or normal ReaderT or anything else. and resulting monad will be AR again.     70 instance says that AStateT is AR
06:38:39 <superduck> quack
06:40:00 <superduck> im trying to get my haskell program to run on android, i think the best way to do this is to compile to a c library and then import that into an android C or android java project and compile to an android installer with the android sdk. my question is how to wrap up my program to a c library, basically i want to compile to c source i think
06:40:15 <safinaskar> bennofs: "and exactly what mtl does" - what you mean? i don't see solution in mtl. i need one ReaderT for any my entity. and this ReaderT's should be distinguishable by names
06:40:35 <bennofs> safinaskar: I mean making x^2 instances for x transformers
06:40:38 <safinaskar> bennofs: "for some transformers, the combination does not pass the transformer's law" - what you mean?
06:41:01 <bennofs> safinaskar: ContT r (WriterT w) is not a valid MonadWriter, since it doesn't pass MonadWriter's laws
06:41:23 <safinaskar> bennofs: "so some instances of the 26*26 matrix are missing" - what you mean?
06:41:42 <bennofs> safinaskar: some instances are not implemented because they would break the laws of the classes
06:41:59 <safinaskar> bennofs: oops, i see that link, i understand
06:42:13 <superduck> does anyone know how to compile haskell to C?
06:42:26 <superduck> or more specifically, a C library...
06:42:53 <superduck> haskell to java would also work i think...
06:42:54 <krakrjak> safinaskar: ok, if 48 & 70 are not the same then you need a different way to differentiate them as the signature is the same...ish.
06:43:30 <Xe> superduck: https://github.com/Frege/frege
06:43:48 <jameseb> superduck: I think the FFI lets you export haskell functions so they can be referenced from C
06:43:52 <superduck> thanks Xe
06:43:53 <tdammers> superduck: https://wiki.haskell.org/FFI_Introduction this is the usual starting point
06:44:08 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-ghc.html#ffi-library
06:44:16 <aweinstock> superduck: http://stackoverflow.com/questions/5151858/running-a-haskell-program-on-the-android-os
06:44:24 <superduck> ahh FFI, i thought that might be the right thing, but thought maybe it was just for calling C libraries from haskell...
06:44:37 <tdammers> FFI can work both ways
06:44:38 <krakrjak> safinaskar: the 48 one is more general and the only contraints are that you have the type AR (MonadTrans Monad) and 70 has the constraint AR (AStatT m), which identifies AR (MonadTrans Monad).
06:44:57 <aweinstock> superduck: it's also possible to use the FFI to export C functions, but that's not the only thing that need to be dealt with to run on android
06:45:16 <superduck> aweinstock, you have done this?
06:46:07 <superduck> aweinstock, I think iv read all thats on stackexchange about this... there is one guy who has ported ghc to android, but i cant get it working...
06:46:09 <safinaskar> aweinstock: "http://lpaste.net/138418" - okey. now, please do the following: create function f which is allowed to read A and modify B, create function g which is allowed to modify both. and call f from g. your example doesn't allow this. but my code allows. see my latest link: http://paste.debian.net/290944/ near end
06:46:52 <superduck> im sure the easyest way to do it is to compile my haskell code to a C library and then import it. if it works ill link the solution on stackexchange
06:47:35 <safinaskar> bennofs: "(t m) and (AStateT m) overlap, because t could be AStateT" - yes. how to tell compiler: "trust me, i will not put AStateT to t"?
06:47:55 <krakrjak> safinaskar: In this case you can safely use OverlappingIstances in this case it would seem: https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/type-class-extensions.html#instance-overlap
06:48:15 <dramforever> safinaskar: that's exactly what the instance system doesn't want you to do =(
06:48:22 <keko_> superduck: this might help (haven't tried it myself) http://www.vex.net/~trebla/haskell/so.xhtml
06:48:23 <dramforever> there's no "trust me"
06:48:32 <dramforever> because anyone could add any instances
06:48:33 <superduck> Xe: frege is not suitable as a wish to use libraries written in haskell from hackage using cabal
06:48:39 * hackagebot travis-meta-yaml 0.0.1.1 - .travis.yml preprocessor  https://hackage.haskell.org/package/travis-meta-yaml-0.0.1.1 (phadej)
06:49:05 <superduck> keko_: thanks, that looks good
06:49:42 <safinaskar> "I mean making x^2 instances for x transformers" - well, i will try this as last measure. please, say me some other methods at first
06:51:30 <superduck> safinaskar you cant use => in your type signature to make t less general?
06:52:49 <safinaskar> superduck: i don't understand you
06:53:52 <geekosaur> superduck, context does not affect instance selection
06:54:15 <safinaskar> okey, i will use XOverlappingInstances, thanks everybody
06:55:06 <merijn> superduck: I have a minimal example for calling haskell from C, btw
06:55:27 <merijn> superduck: https://gist.github.com/merijn/4a0fee2b3a5ef3476aa4
06:56:06 <geekosaur> as for x^2 instances, I think that's the main argument against transformers and the reason people have been trying to work out e.g. extensible effects?
06:56:23 <geekosaur> (which as it turns out have their own issues)
06:58:23 <superduck> merijn: hi thinks thats amazing! i dont see a makefile for compiling the c source, is this handeled in the cabal file?
06:59:06 <superduck> also it looks like you have more than one project called foo....
07:00:08 <merijn> superduck: Cabal can handle (simple) C compilation, yes
07:00:17 <superduck> ok so the line mainis: main.c seems to indicate the library is built with cabal, so does that mean ghc can compile c source files?
07:00:29 <merijn> superduck: If you need something more complex you wanna setup a Setup.hs that hooks into autotools or whatever
07:00:41 <merijn> superduck: Cabal just calls your system C compiler
07:01:34 <kakashiAL> imperative programming uses statements that are executes step by step, thats the main difference between FP and classical programming, but if I program a function, I also use imperative programm
07:01:50 <kakashiAL> I mean I say what whould happen
07:01:59 <kakashiAL> "do this, then do that etc."
07:02:03 <tdammers> kakashiAL: not really, no
07:02:12 <tdammers> that's not what "function" is taken to mean in FP
07:02:31 <tdammers> a function is a mapping of one domain of values to another
07:02:36 <tdammers> like in math
07:03:00 <tdammers> e.g., `succ` is the "successor" function; it takes an enum-like value, and returns the next higher value in the enum
07:03:05 <tdammers> > succ 1
07:03:07 <lambdabot>  2
07:03:09 <tdammers> :t succ
07:03:10 <lambdabot> Enum a => a -> a
07:03:35 <tdammers> ^ this type signature expresses this exact sentiment: for any given enum value a, succ is the mapping of an a to another a
07:03:46 <kakashiAL> tdammers: myFunction n = if n >= 0 then "your number is positive" else "your number is nevative"    <---as you can see here I have 3 statements, 3 steps
07:03:48 <keko_> are "functional" and "imperative" really in the same class of things?
07:03:53 <tdammers> no
07:03:58 <keko_> I'd contrast "imperative" with "declarative" or something
07:04:15 <kakashiAL> tdammers: first do the checking, second do then or elese block
07:04:20 <dramforever> kakashiAL: those are not statements at all
07:04:33 <dramforever> but well, sure it's "steps"
07:04:48 <keko_> and "functional" with something like "structured"
07:04:50 <tdammers> what you have there is an expression that is composed of other expressions, and the order in which they need to be evaluated is determined by the way you compose them
07:05:01 <dramforever> kakashiAL: but there's a caveat: you cannot "chain" steps
07:05:12 <kakashiAL> dramforever: what do you mean by that?
07:05:13 <dramforever> at least not like imperative languages
07:05:18 <tdammers> but that order is implicit and follows from the way your expression is composed, not from the order in which you write things
07:05:36 <tdammers> > let a = 1 + undefined in if True then "hello" else show a
07:05:38 <lambdabot>  "hello"
07:05:42 <tdammers> > 1 + undefined
07:05:43 <lambdabot>  *Exception: Prelude.undefined
07:05:57 <tdammers> as you can see, the "1 + undefined" part isn't evaluated at all
07:05:58 <dramforever> kakashiAL: if n > 0 then print n; putStrLn "hi"
07:06:03 <dramforever> that doesn't make sense at all
07:06:43 <dramforever> kakashiAL: still there?
07:06:46 <kakashiAL> yes
07:06:53 <kakashiAL> why it makes no sense?
07:06:53 <tdammers> your function just maps all negative n to one value, and all non-negative ones to another
07:06:56 <frerich> tdammers: I think you're giving an argument in favour of non-strict evaluation there, not in favour of functional programming as opposed to imperative programming.
07:07:11 <tdammers> frerich: maybe so
07:07:11 <dramforever> kakashiAL: because a function is an expression
07:07:13 <frerich> tdammers: I think a good argument would involve something about the order of things not making a difference.
07:07:14 <kakashiAL> tdammers: so my function is not bijective, so what?:)
07:07:30 <tdammers> frerich: that was kind of what I was trying to demonstrate
07:07:33 <dramforever> kakashiAL: there's no "*do* this *do* that"
07:07:59 <kakashiAL> dramforever: thats the problem that I have, I see "do this, then do that..."
07:08:08 <dramforever> what did you do?
07:08:17 <tdammers> kakashiAL: yes, that's the imperative mindset limiting your thinking ;)
07:08:18 <dramforever> in the case of if n > 0 then "" else ""
07:08:32 <kakashiAL> dramforever: yes
07:08:35 <kakashiAL> first check
07:08:47 <kakashiAL> then take then or else block
07:08:57 <dramforever> "block" is wrong
07:09:04 <kakashiAL> dramforever: you know what I mean :)
07:09:05 <tdammers> "expression"
07:09:06 <dramforever> there can only be one expression
07:10:12 <kakashiAL> I know that a function in FP is more a input/output structure, like in math
07:10:24 <kakashiAL> but in my function definition, I say how to do it
07:10:44 <kakashiAL> like "do this" or "devide the inut by 2" or "add 42"
07:11:00 <frerich> kakashiAL: In functional programming (as is true for all forms of declarative programming, I believe) you concentrate on defining *what* should happen. There is no notion of time. Of course, there can be a 'data dependency such that some expressions need to be evaluated before others.
07:11:02 <tdammers> not really, no
07:11:15 <jameseb> kakashiAL: look at it this way, in the expression (a + b) * (b + c), do you really specify whether the a+b or the b+c should be evaluated first?
07:11:21 <frerich> kakashiAL: In imperative programming, you define * how* something is happening. A sequence of steps, tightly bound to the order of things
07:11:49 <dramforever> kakashiAL: there's no such thing as a *sequence* of statements
07:11:53 <tdammers> (a + b) is the same as ((+) a b), and it means "the + operator, applied to a and b"
07:11:54 <dramforever> just a tree of expressions
07:12:23 <kakashiAL> jameseb, frerich, dramforever lets concentrate in the "HOW" versus "WHAT" aspect
07:12:46 <kakashiAL> at the moment I cant imagine what is meant
07:12:50 <tdammers> kakashiAL: haskell goes through great lengths to abstract the "how" part away from the programmer
07:13:18 <merijn> dramforever: Graph of expressions, technically
07:13:24 <dramforever> oh sure
07:13:27 <tdammers> you say "I want the value of the function to be "foo" if the value of n is >= 0, else I want it to be "bar"
07:13:33 <dramforever> tree structured graph
07:13:50 <kakashiAL> I also think in how to translate my FP code in other languages like C++ or java
07:14:07 <frerich> kakashiAL: In functional programming, applying some function to all elements of a list has no notion of how this happens. It might even be that the function is applied to multiple elements in parallel. You merely say *what* is happening. In an imperative style, you would precisely define how the list is processed. From the front? From the back? All at once? Instead of saying what should happen, you would define how it should happen by gi
07:14:07 <frerich> ving a precise sequence of steps to implement the algorithm.
07:14:12 <kakashiAL> and there I have to tell my languages how to do it
07:15:01 <mniip> kakashiAL, so you're saying, you can't understand haskell because you try to translate it into C++?
07:15:03 <mniip> no wonder
07:15:12 <kakashiAL> frerich: take for example the reduce function
07:15:19 <kakashiAL> first: take an array
07:15:26 <tdammers> even translating haskell to JS is painful because there's so much abstraction going on
07:15:34 <kakashiAL> second: go to each element and add it
07:16:05 <kakashiAL> third: return the values (mostly automatikly)
07:16:11 <merijn> kakashiAL: You can't add to an element, since they're immutable, you have to allocate a new list with the results
07:16:18 <dramforever> kakashiAL: not really
07:16:38 <kakashiAL> sorry, I mean sum each value
07:16:41 <tdammers> kakashiAL: think of it in a different way. Given an accumulated value from a previous run, a combinator function, and an empty list, reduce is just returning the accumulator
07:17:16 <kakashiAL> tdammers: do you know the reduce function in javascript?
07:17:32 <tdammers> kakashiAL: yes, it's a very common primitive in FP
07:17:45 <mniip> in haskell it's called foldr
07:17:45 <tdammers> kakashiAL: but in Haskell, we define it recursively, using two cases
07:17:51 <aweinstock> safinaskar: I think I got it: http://lpaste.net/138420
07:17:55 <dramforever> @src foldr
07:17:55 <lambdabot> foldr f z []     = z
07:17:55 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:18:03 <dramforever> code speaks louder than prose
07:18:07 <dramforever> kakashiAL: ^
07:18:09 <tdammers> the first one, with the empty list, is the base case
07:18:15 <tdammers> and as usual, it's trivial
07:18:28 <kakashiAL> myArray.reduce(function(item){ return a+ item; });   <--I told HOW to do it
07:18:30 <tdammers> the second one is the recursive case, and that's where the real beef happens
07:18:37 <mniip> kakashiAL, no you didn
07:18:38 <mniip> 't
07:18:52 <kakashiAL> mniip: why?:(
07:18:57 <mniip> the implementation of Array.prototype.reduce defines "how" to do it
07:18:59 <geekosaur> telling how to do it would mean specifying manyally how to traverse the array
07:19:03 <tdammers> you didn't specify which implementation to use
07:19:03 <mniip> you're only saying "what" to do
07:19:09 <geekosaur> reduce is an FP thing added to JS because it's so useful
07:19:23 <dramforever> kakashiAL: what about this: even if the program SEEMS to be a sequence of statements, it's NOT RUN in the same way
07:19:23 <tdammers> also because JS is in part kind of a lisp
07:19:27 <geekosaur> so you have already been introduced to FP concepts
07:20:07 <kakashiAL> hmm...have to think about that
07:20:16 <dramforever> kakashiAL: in imperative we just step through the code, evaluating the expressions in the statements
07:20:27 <dramforever> in functional the who program IS an expression
07:20:32 <dramforever> just evaluate it
07:21:03 <mniip> as someone above already said
07:21:05 <tdammers> an interesting byproduct of this is that in most FP languages, all but a tiny handful of "control flow constructs" can be implemented as library functions
07:21:08 <tdammers> and they usually are
07:21:30 <mniip> haskell goes great lengths to let the programmer explain what, and not how, should happen
07:21:39 <tdammers> Haskell's if is a special syntax construct by historical accident, you could easily write it yourself
07:22:01 <frerich> tdammers: I think that (again) is a consequence of non-strict evaluation. There are non-strict imperative languages as well (e.g. Tcl) where common control-flow statements can be defined in the language, too.
07:22:19 <frerich> Like 'switch' or 'while'.
07:22:32 <tdammers> frerich: of course you need a minimum set for bootstrapping, but as long as you can get laziness from that set, you don't need more than that
07:22:38 <dramforever> IIUC just 4 building blocks make up the core of haskell: application, lambda, case and fix
07:22:41 <mniip> frerich, if I'm not mistaken, tcl is only non-strict thanks to messed up expansion rules
07:22:46 <safinaskar> hi all! i get my code to work! look: http://paste.debian.net/290979/ (that monad transformers)
07:22:53 <tdammers> frerich: lisps, for example, tend to derive their huge control flow libraries from just a few primitives
07:23:04 <captain_haddock_> where's the ghc api on hackage?
07:23:06 <safinaskar> geekosaur: as well as i know monad tranformers are more standard, so i picked them
07:23:14 <frerich> mniip: I'd very much disagree, but I'd rather not get into a Tcl discussion. :-)
07:23:48 <mniip> likewise, as I've never had a chance to write some tcl code, only looked at some manpages and noped the hell outta there
07:24:19 <geekosaur> captain_haddock_, it's not there, too difficult to separate it out just for haddocks
07:24:28 <frerich> mniip: I think it's actually a very interesting language in the sense that it's core and syntax is extremely minimalistic. I first thought it was terribly but I had to use it for some projects at work and by now got to appreciate a few things about it.
07:24:44 <frerich> mniip: I always liked it when you could define a lot of stuff in the language itself, i.e. little 'magic'.
07:25:29 <captain_haddock_> is there anywhere I can find reference or docs for it then? everything I came across with cursory googling has link-rotted
07:25:48 <mniip> [16:20:46] <captain_haddock_> where's the ghc api on hackage?
07:25:50 <mniip> the ghc-api package
07:26:08 <geekosaur> i didn't see it there...
07:26:39 <geekosaur> (sigh, yes local notwork, nice time to start dropping SYNs again...)
07:26:52 <mniip> hmm
07:26:58 <mniip> https://downloads.haskell.org/~ghc/7.8.4/docs/html/libraries/ghc-7.8.4/index.html
07:27:43 * geekosaur figured some path like that but browser window is stuck because local notwork :/
07:28:18 <mniip> nice pun
07:29:00 <captain_haddock_> huh
07:29:53 <captain_haddock_> search doesn't give the ghc package when you search for ghc or ghc-api
07:31:47 <bennofs> captain_haddock_: because ghc api is not on hackage
07:32:13 <superduck> merijn: sorry i was afk, so thats really cool, ghc can call gcc simply with a flag in the cabal file or automake tools from the setup.hs file. i think i will probably need to use my own compilation though as it is android and so calls the android compiler... would you know how to modify the cabal instalation or the setup.hs to work with this compiler? i think there would also have to be some fancy automatic generation of a blank 
07:32:55 <tdammers> superduck: you got cut off at "generation of a blank"
07:33:00 <superduck> continued, e.g. modification of this file to include the haskell main activity and execute it 
07:33:18 <superduck> blank android activity 
07:33:26 <merijn> superduck: You don't have to, if you change "Build-Type: Simple" to "Build-Type: Custom" you can implement you own Setup.hs that hooks into cabal
07:34:00 <merijn> superduck: That supports things like running installing hooks which, for example, run autotools/some other compiler for you
07:34:40 <superduck> thats great, ill look into implementing such a setup.hs and report back
07:34:52 <merijn> superduck: Trivial example: https://github.com/merijn/SNet2.0/blob/master/Setup.hs read the cabal user guide/docs for more details on what you can hook and when
07:35:04 <dramforever> :t Dict
07:35:05 <lambdabot> Not in scope: data constructor ‘Dict’
07:35:32 <valica92_> :t map
07:35:33 <lambdabot> (a -> b) -> [a] -> [b]
07:36:18 <superduck> any clues about import Distribution.Simple.Program
07:36:48 <superduck> :hackage Dict
07:38:06 <merijn> superduck: That's from the Cabal package, i.e. the library part of cabal
07:38:09 <superduck> i cant find this "Dict" anywhere
07:39:24 <mniip> Dict?
07:39:37 <superduck> [15:34] <dramforever> :t Dict
07:39:43 <mniip> Data.Constraint
07:39:51 <dramforever> @hackage constraints
07:39:51 <lambdabot> http://hackage.haskell.org/package/constraints
07:39:58 <superduck> i dont know what he is referencing
07:40:09 <zennist> when I say fib = 0 : 1 : zipWith (+) fib (tail fib)
07:40:11 <superduck> ok thanks
07:40:14 <zennist> what's the complexity  of the function?
07:40:35 <merijn> linear
07:40:41 <dramforever> zennist: you can expect it to be constant for each element
07:40:43 <zennist> it looks to me to be expensive
07:40:58 <valica92_> hi all. I am a beginner haskeller. I solved a problem in both java and haskell. My problem is that Java version runs instantly but haskell version takes like 5 minutes. I profiled but don't know what's so wrong with it. Code here: http://lpaste.net/138422 Prof report: http://lpaste.net/138425
07:41:04 <zennist> some explanation into why would be helpful
07:41:04 <merijn> zennist: Why?
07:41:11 <superduck> ooo
07:41:35 <zennist> I'm thinking about under the hood what the computer would really do when it takes say, the 5th element out of 'fib'
07:41:40 <dramforever> valica92_: first problem spotted: "pos `notElem` indices array" is very slow
07:41:47 <dramforever> it's linear time
07:41:52 <merijn> dramforever: Worse
07:41:59 <merijn> String everywhere is going to suck
07:42:02 <dramforever> oh quadradic
07:42:13 <bennofs> valica92_: can you run your program with +RTS -s and post output?
07:42:29 <merijn> valica92_: String is not a good datatype for performance. It's a linked list of characters. You should probably use Text instead
07:42:38 <zennist> it gets 0, 1 first, of course, and then the next element is obtained by adding 1 to 0, which is fine; now the next part is fuzzy to me - does it do 1+0 again or does it know the next element 1 and then just adds 1+1
07:42:41 <dramforever> :t bounds
07:42:42 <lambdabot> Ix i => Array i e -> (i, i)
07:43:01 <dramforever> valica92_: use this to get the bounds of the array, the compare the Pos with it
07:43:01 <mniip> :t inRange
07:43:03 <lambdabot> Ix a => (a, a) -> a -> Bool
07:43:06 <mniip> :t bounds
07:43:07 <lambdabot> Ix i => Array i e -> (i, i)
07:43:09 <dramforever> yes use that function
07:43:18 <dramforever> :t inRange . bounds
07:43:19 <lambdabot> Ix a => Array a e -> a -> Bool
07:43:24 <dramforever> bizarre...
07:43:31 <zennist> for the claim that this thing is linear; am I right in saying : all the identifier 'fib' in the function definition shares the same reference
07:43:37 <texvery> hi anyone knows if there's a way to convert computer code into math equations? so it looks cool and complex? 
07:43:37 <dramforever> valica92_: that should improve the speed by quite a bit
07:43:39 <texvery> : )
07:43:46 <merijn> zennist: Yes
07:43:53 <valica92_> ghc assignment.hs -prof -fprof-auto -rtsopts is my compiling. ./assignment +RTS -p running
07:43:57 <zennist> merijn: okay, then it is linear then
07:44:02 <merijn> zennist: 'fib' essentially functions as a pointer to a const value
07:44:07 <dramforever> valica92_: do you get my suggestion?
07:44:15 <dramforever> on line 32
07:44:18 <superduck> valica92_ iv never seen a prof report before but im guessing that "startsWord" is taking up most of your runtime. i guess its due to the costly flags, can you try changing the order of these flags to put the most computationally intensive ones at the bottom?
07:44:20 <mniip> zennist, every part of the fib list is only computed once
07:44:26 <bennofs> valica92_: what does ./assignment +RTS -sstderr output?
07:44:38 <mniip> so it takes O(N) to compute the N'th element
07:44:46 <mniip> (although it also takes O(N) time to index it)
07:44:48 <merijn> zennist: I recommend this as good basic intro to understanding the complexity/cost of lazy evaluation: https://hackhands.com/guide-lazy-evaluation-haskell/
07:44:58 <dramforever> mniip: or rather O(1) for each element, as you go through the list
07:45:07 <mniip> right
07:45:09 <zennist> merijn: is this true for everything in haskell? i.e. every resolved identifier shares the same pointer?
07:45:13 <dramforever> valica92_: sigh...
07:45:14 <superduck> texvery: you can include latex in lhs files and compile with lhs2tex. 
07:45:19 <merijn> zennist: Mostly
07:45:20 <mniip> zennist, "resolved identifier"
07:45:21 <dramforever> did you see my suggestion?
07:45:44 <merijn> zennist: GHCs optimiser may, sometimes, decide to duplicate an expressions if it thinks recomputing will be faster than sharing
07:45:46 <mniip> zennist, there's a simultaneously more general and less general statement that GHC obeys
07:46:00 <mniip> every closure is only computed once
07:46:04 <zennist> merijn: all right, like constants right?
07:46:24 <texvery> superduck, ok sounds cool. so latex is like a coding language of sorts, i mean you can transform haskell or other language code into latex? I'm kinda new on this.
07:46:25 <merijn> zennist: But in general, yes, multiple occurences of the same identifer are effectively pointers to the same value (meaning a complex expression is only evaluated once)
07:46:45 <mniip> when a new closure is made/a closure is reused is another questoin
07:47:03 <merijn> zennist: i.e. "let x = expensiveComputation in x + x" will only compute "expensiveComputation" once. But like I said, my earlier link has a good explanation of the details
07:47:16 <superduck> valica92_ you should definatly place   | pos `notElem` indices array = False as late as you can, it looks far too heavy to call eah itteration
07:47:18 <zennist> merijn: I think I heard about this before, it has a name for it..forgot about it - but can I also be assured that 'x+y' that appears in two places are actually computed once?
07:47:25 <dramforever> superduck: no
07:47:33 <dramforever> just use inBounds and bounds
07:47:40 <dramforever> that speeds it up a lot
07:47:51 <mniip> f x = g where g = expensiveComputation x
07:47:55 <bennofs> zennist: it's called common subexpression elimination, and no, Ghc does not do it in general
07:47:56 <merijn> zennist: No, that's called "Common Subexpression Elimination", GHC does it *occasionally*, but it's hard
07:47:59 <mniip> a new closure of g is made on every invocation of f
07:48:09 <mniip> f x = g x where g x = expensiveComputation x
07:48:16 <merijn> zennist: So the safest way to be sure is to explicitly give common expressions a name
07:48:20 <zennist> okay guess 'let' is still needed here
07:48:21 <mniip> a closure for g is reused across f invocations
07:48:30 <superduck> texvery: latex is how you can write pdf's with nice math symbols. its what all the math publications were done in pre maple. 
07:48:55 <mniip> superduck, are you trying to say something has changed since?
07:49:13 <superduck> lhs2tex will not interpret the code as math, but will allow you to annotate your source with latex style math and compile to pdf
07:49:14 <texvery> i see. it even has random number generators? :3
07:49:21 <texvery> ok
07:49:50 <superduck> mniip, im trying to say it was the industry leading standard for many years.
07:50:21 <dramforever> latex rocks
07:50:37 <superduck> actually its hellish!
07:50:43 * dramforever uses it for basically any document that needs more than just lots of text
07:50:51 <superduck> but the results are worth it
07:50:51 <dramforever> superduck: yes not easy to use
07:50:55 <dramforever> interface sucks
07:51:00 <merijn> dramforever: LaTeX sucks, just less than the alternatives :p
07:51:06 <dramforever> things behind it rocks
07:51:23 <safinaskar> aweinstock: "http://lpaste.net/138420" - thanks. but my code already works and i like it :)
07:51:42 <merijn> If I could go back in time, I'd go to Knuth and tell him "You realise that 40 years from now everyone will still be using this, right? You might wanna consider investing more time and processing into getting better errors..."
07:51:47 <superduck> anyone know of other nice ways to produce tex from source other than lhs2hs?
07:52:29 <superduck> merijn: lol, 40 years.... no wonder it feels so painful! 
07:52:40 <superduck> lhs2tex*
07:52:45 <tdammers> fwiw, latex predates the ubiquitousness of unicode by quite a bit
07:53:02 <tdammers> which probably excuses many of its design decisions
07:53:10 <superduck> argh
07:53:33 <superduck> so, lets redo it in haskell no?
07:53:35 <merijn> tdammers: Unicode is easy enough if you use Xe(La)TeX
07:53:40 <tdammers> merijn: true
07:53:56 <merijn> superduck: Pandoc?
07:54:01 <merijn> superduck: Written in haskell too!
07:54:24 <cow_2001> A multifunctor is fine too…
07:54:25 <tdammers> merijn: using latex for a data conversion job involving 100k documents using 30 different languages and 12 different scripts was still quite a challenge though
07:54:44 <superduck> like if tex is a complete language, cant we write it in haskell not c? or can we actually port the c source to haskell?
07:54:56 <merijn> superduck: Tex isn't written in C
07:54:58 <tdammers> it'd be a rewrite
07:55:05 <merijn> superduck: TeX is written in pascal, iirc
07:55:17 <tdammers> and it's possible, but the important question is, would it be worth it?
07:55:45 <geekosaur> and the build mechanism involves a hacked version of tangle that writes out ANSI C generated from the Pascal...
07:56:04 <superduck> it would be worth it if it created a better interface so this ancient tool could be properly maintained... 
07:56:35 <superduck> geekosaur, sounds hellish
07:56:51 <superduck> its making my hair fall out just hearing about it
07:56:55 <merijn> superduck: Feel free to do it :)
07:57:09 <merijn> superduck: Pandoc already shows you how to parse TeX, so :p
07:57:10 <superduck> brb rewriting latex lol
07:57:28 <merijn> fwiw, I think haskell would be well suited to a task like that
07:57:33 <superduck> merijn is it complete?
07:57:43 <merijn> I wouldn't wanna rewrite TeX in, like, python or C
07:57:57 <tdammers> ofc
07:58:05 <geekosaur> (see, TeX isn't even literally written in Pascal; it's written in a "literate Pascal" with documentation intermied, and there are programs "tangle" to extract the code and "weave" to extract the documentation. and a "ctangle" that generates aforementioned C
07:58:06 <superduck> haskell is perfect for sure. maybe we could get some funds...
07:58:07 <merijn> superduck: Well it doesn't *implement* TeX, it just parses it into a general document format for conversion to other formats
07:58:11 <tdammers> *if* one were to rewrite tex, then Haskell would be a great tool
07:59:01 <tdammers> but again, it'd be a rewrite, and the amount of work that has gone into the existing implementation is pretty damn huge
07:59:57 <merijn> XeTeX and ConTeXt are the closest to a TeX rewrite, I think
08:00:23 <demize> geekosaur: or web2c ;p
08:00:24 <merijn> XeTeX/XeLaTeX are straightforward identical to TeX in behaviour, ConTeXt I don't know much about
08:00:56 <geekosaur> yeh, it's been that long since I last poked at it
08:01:39 * geekosaur quite happy not to deal with building it any more :)
08:01:46 <demize> geekosaur: ah, ctangle is tangle for cweb
08:01:52 <demize> (Which is WEB for C)
08:02:14 <geekosaur> I recall it being used for the original source years ago. hopefully got cleaned up
08:02:18 <superduck> i dont see why you would *need* a "complete" rewrite of tex. you would just have to provide the useful functionality, and i guess it would have to be turing complete... 
08:02:35 <frerich> I think this isn't really #haskell material. :-]
08:02:41 <geekosaur> because people use all the functionality
08:03:00 <geekosaur> well, random macro packages that people expect to work do
08:03:07 <superduck> then it should be sufficiently documented for a rewrite
08:03:28 <superduck> frerich: it seems the correct crowd is here...
08:03:49 <geekosaur> also the documentation is pretty complete; the problem is that it'd be a lot of work and you'd have to guarantee 100% compatibility
08:04:49 <superduck> geekosaur, thats why i figured that parsing the source would be necessary...
08:06:08 <superduck> and if part of the compilation generates complete c code, this could be translated to haskell with c2hs...
08:06:30 <merijn> This would not make anything better >.>
08:06:36 <superduck> then a simple interface would be all the required writing...
08:06:52 <mniip> that solves 0 of the problems though
08:06:54 <mniip> you realize
08:07:21 <superduck> i feared as such, soory for noob
08:07:32 <superduck> ok im done!
08:08:33 <geekosaur> c2hs is not a translator, it is a binding generator
08:08:37 <superduck> maybe the next generation will have the necessary tools to make it facile... 
08:09:14 <superduck> we dont have a way of translating c?
08:09:18 <geekosaur> nope
08:09:42 <merijn> Well, we could, but I don't think many people want one :p
08:10:03 <geekosaur> and it wouldn't be very good
08:10:20 <geekosaur> I mean, it would work but the result wouldn't be maintainable much less idiomatic
08:10:24 <HijiriPhone> just solve strong AI and make it rewrite it into elegant haskell
08:11:01 <superduck> HijiriPhone, yeh, simple
08:11:04 <aweinstock> It'd be fairly straightforward (but quite a bit of effort) to write a C -> Haskell compiler that generated IO/Foreign.Marshal-ish code, right?
08:11:27 <aweinstock> and once that's done, you could incrementally refactor the output
08:11:31 <geekosaur> "SMOP"
08:11:35 <superduck> do we have ghc written in haskell?
08:11:39 <benzrf> aweinstock: are you 'awe in stock' or 'a wein stock'
08:11:40 <merijn> superduck: Yes
08:11:55 <aweinstock> benzrf: first initial, actual last name
08:12:08 <benzrf> ah
08:12:09 <merijn> superduck: The runtime has a large C component, but there's no real benefit to replacing that
08:12:24 <geekosaur> ghc was never written in C, the first version was in Lazy ML IIRC
08:12:25 <aweinstock> geekosaur: "small matter of programming"?
08:12:35 <merijn> geekosaur: Yeah
08:12:40 <geekosaur> usually "simple" instead of "small"
08:12:58 <aweinstock> hence the parenthetical "but quite a bit of effort"
08:13:28 <levi> aweinstock: Incrementally refactoring auto-generated code is, at best, a not-fun thing to do.
08:13:32 <superduck> the tool you describe is one of the most pressing tasks in the world
08:13:41 <merijn> levi: Understatement of the century :)
08:14:05 <merijn> superduck: Step one: learn to write compilers (go do that anyway, it's an important life skill!)
08:14:06 <aweinstock> (I'm not advocating rewriting TeX in Haskell, just saying the best way I can see how to do it while guarenteeing how to preserve compatibility)
08:14:13 <superduck> true dat
08:14:33 <obadz> In a type signature, "CanGetFrom tt ~ Yes" what do the ~ and the Yes mean?
08:14:52 <geekosaur> obadz, that is type equality
08:14:55 <merijn> obadz: ~ is unification, which you can read (roughly) as "equals"
08:15:07 <superduck> it looks like the real missing component in all this is a pretty sugary haskell minifier. 
08:15:10 <merijn> obadz: i.e. "CanGetFrom tt" is equal to "Yes"
08:15:31 <merijn> superduck: What do you mean by Haskell minifier?
08:15:32 <obadz> hmmm...
08:15:46 <obadz> merijn / geekosaur - CanGetFrom tt is a type right?
08:15:48 <bennofs> obadz: that specific code is HsQML notion for It's possible to retrieve a value of type tt from QML (i.e. there is a marshal instance for tt that supports this)
08:15:56 <merijn> obadz: Yes, and so is "Yes"
08:16:10 <bennofs> CanGetFrom (without tt) is a type family
08:16:20 <obadz> bennofs: isn't it a type class?
08:16:55 <bennofs> obadz: no. CanGetFrom is a type family which you can roughly think of as a function of types: given a type 'tt', it returns either 'Yes' or 'No' 
08:17:17 <geekosaur> type families are often defined in type classes (thus "associated type family"
08:17:24 <geekosaur> but they are not in and of themselves typeclasses
08:17:30 <obadz> ok, everything I feel I get a grip on Haskell, I realize how much I don't know or have never even heard about :)
08:17:47 <obadz> s/everything/everytime
08:17:51 <superduck> merijn: i think python has a minifier, thats where i got the termanology from, i guess what i mean is something that will rewrite haskell code in a minimal way...
08:17:53 <bennofs> obadz: to be fair, it took me a while to understand HsQML's interface :p
08:18:04 <merijn> superduck: But what's the point of that?
08:18:04 <geekosaur> obadz, it's growing faster than you are learning it, too :)
08:18:10 <obadz> bennofs: I'm watching the video by Robin Kay
08:18:21 <obadz> geekosaur: lol
08:18:32 <merijn> superduck: For python it makes sense, since you use the source as executable. But you compile haskell anyway...
08:18:35 <geekosaur> every time I turn around there's more type level hackery around
08:18:53 <ReinH> geekosaur: stop turning around then!
08:18:58 <geekosaur> worse, truly minified haskell wouldn't be comprehensible to most people
08:18:59 <obadz> Is HsQML the state of the art for building non-Web GUIs in Haskell?
08:19:16 <tdammers> merijn: "protecting your intellectual property" :C
08:19:51 <superduck> merijn: I understood that the main problem we face is that we must "rewrite" instead of simply translating... maybe actually the problem is not that we cant refacor haskell to pretty haskell, but that we cant translate c to any sort of haskell, but must simply bind to c libraries...
08:21:20 <geekosaur> we can translate C to Haskell, we just don't bother because the result would be horrid to work with
08:21:30 <bennofs> obadz: I think there are not many people building non-Web GUIs in Haskell, so there's hardly a state of the art? :p
08:21:34 <merijn> superduck: Translating C to haskell is easy, there's just almost no reason to do so
08:21:39 <geekosaur> and fixing the horrid would be the same as rewriting from scratch without the C
08:21:51 <superduck> geekosaur i thought that was kind of the point of haskell, to generate abstract syntax which captures the nature of things. anyway i would expect it could recognise common design patterns and refer them to standard libraries, e.g. it would be able to spot some class was equivalent to say functor, and simply import that library and generate the instance...
08:22:14 <levi> Heh.
08:22:40 <monochrom> did people want to translate C to Prolog, when Prolog was cool?
08:23:12 <merijn> monochrom: I know people translating IBM360 assembly to COBOL :)
08:23:22 <levi> Translating high-level C code to high-level Haskell code is probably not going to be a tractable problem. I don't think you're going to come across many Functor instances in C code.
08:23:41 <superduck> assembly to haskell would be good too
08:24:22 <merijn> Do you mean reverse engineering asm to haskell or simply compiling asm to haskell?
08:24:32 <merijn> The latter is pretty easy, the former...less so :p
08:25:01 <superduck> i suppose i should translate some c to haskell just to see how ugly it is, i think this is probably the reason i still entertain the idea while more experienced users shriek in fear
08:25:35 <superduck> i cant see the difference in those terms merinj
08:26:01 <levi> superduck: You might just start with writing a C compiler; see how much high-level understanding of the code intent you're able to derive while sticking to the C specification.
08:26:10 <superduck> [16:20] <geekosaur> we can translate C to Haskell, we just don't bother because the result would be horrid to work with
08:26:13 <superduck> which tool is used for this?
08:26:22 <geekosaur> do you want to generate comprehensible code, or just manipulate low level stuff that lets you get the same effect?
08:26:37 <geekosaur> sorry, I did not mean we can as in a tool exists, just that we know how to do it
08:26:39 <merijn> superduck: There is no tool yet, but writing such a tool wouldn't be very hard
08:27:01 <superduck> id love to translate incomprehensible auto generated haskell into intuition promoting pretty haskell 
08:27:07 <geekosaur> glwt
08:27:35 <levi> There are tools that exist for parsing C programs and tools for generating Haskell programs. All you need to supply is the code that figures out what the C code means and translates that meaning to a human-understandable Haskell program!
08:28:18 <superduck> levi: i guess that for simple c programs this would actually be really easy
08:28:48 <levi> superduck: I'm guessing you haven't read the C specification document?
08:29:23 <tdammers> superduck: how about you give it a go and see what happens
08:29:42 <superduck> because there is no point i me using incomplete tools that i have no ability to complete
08:29:43 <geekosaur> seriously, you are better off reading the C code and implementing equivalent Haskell
08:30:03 <geekosaur> because it's not a matter of incomplete tools (mostly they're incomplete in the AI-complete sense)
08:30:08 <tdammers> superduck: then stop guessing how easy or hard it'd be :D
08:30:11 <superduck> geekosaur, i know. this is the problem. there is a market for the solution i assure you
08:30:12 <mmachenry> I'm maintaining a big project. It has no warnings on. I turn on -Wall and I can a ton. I'd like to go file by file and just fix the warnings on a file I'm already editing and testing. Anyone know of a way to see these warnings on a per file basis rather than having to scroll back through a huge "cabal build" log?
08:30:27 <superduck> geekosaur, though i appriciate it may not be achievable 
08:30:57 <geekosaur> and translating generated Haskell to proper Haskell would be *harder* than translating C, because someone experienced in both C and Haskell can recognize high level patterns and translate them --- nobody would recognize those when autotranslated to uinidiomatic Haskell
08:31:31 <aweinstock> mmachenry: redirect the output to a file and use grep?
08:31:34 <tdammers> also, a "readability check" is really hard to do
08:31:35 <superduck> mmachenry, cant you just ghc --Wall the individual modules?
08:32:40 <mmachenry> superduck: I honestly didn't try that because this is cabal managed and thus I think would be missing dependencies but I will try.
08:33:02 <superduck> geekosaur, thanks for sharing your suspicions, im sure you can appreciate that as both an inexperienced haskell and c programmer i am unable to make these assertions myself. 
08:33:18 <afons> Hello, does anyone know what the command :cmd is used for?
08:33:36 <afons> I have just used it this way :cmd return ":!ls"
08:34:15 <superduck> mmachenry: ghc is pretty good at handling despondencies... the cabal build should have installed all the external libraries you use in a way that ghc can see them
08:34:21 <gregnwosu> anyone seen an ARM build of ghc 7.10?
08:34:27 <mmachenry> superduck: That does work for some. I think in general cabal exec ghc -Wall might fix sandbox issues
08:35:00 <superduck> afons: if you are trying to invoke command line actions consider System.Process
08:35:10 <geekosaur> understand that while I have not specifically translated C to Haskell (or Haskell to C), I have experience doing so with other languages in both directions, including some high level ones (e.g. Prolog)
08:35:41 <superduck> geekosaur: you da man, that is some heavy stuff 
08:35:46 <afons> superduck: I'm not "trying" anything, I am just wondering what the command is used for.
08:35:49 <superduck> i wish we had these tools
08:36:04 <superduck> afons: kk
08:37:08 <afons> so..
08:37:11 <afons> what is it used for?
08:37:20 <merijn> mmachenry: GHC_OPTIONS pragma!
08:37:32 <mmachenry> Oh ho! 
08:37:44 <mmachenry> Nice. Thanks merijn!
08:37:50 <merijn> {-# GHC_OPTIONS -Wall #-} if I recall syntax correctly
08:38:03 <aweinstock> afons: I think :cmd takes a definition of an IO action for defining commands in ghci
08:38:30 <aweinstock> https://downloads.haskell.org/~ghc/7.4.1/docs/html/users_guide/ghci-commands.html
08:38:42 <aweinstock> Executes expr as a computation of type IO String, and then executes the resulting string as a list of GHCi commands.
08:38:45 <bergmark> mmachenry: load everything into ghci with -Werror
08:40:34 <bergmark> mmachenry: i was in a similar position the other day (we have -Wall, but you don't see the warnings when building in parallell), stack helps a lot, do `stack build --ghc-options=-Werror` and then `stack ghci` any package with warnings
08:56:57 <tromp_> ddworken the gap should be a lot smaller on a cpu running 16 threads...
08:57:47 <nitrix> I find the recent proposals on the mailinglist very disturbing.
08:59:31 <nitrix> There are probably things that can be improved, but even I (disruptive as I am) would wait until I'm more acquinted with the language before questioning core features.
09:00:41 <bergmark> the ::= stuff? that's never going to happen :)
09:00:42 <SrP> saulzar: Hey I'm sorry :( I guess I fall asleep. 
09:02:33 <hodapp> how does one generalize something like... a1 -> Foo, a1 -> a2 -> Foo, a1 -> a2 -> a3 -> Foo...? Say, if I am trying to make something that applies to any chain of function that eventuall return Foo.
09:03:20 <Zekka> nitrix: Link?
09:03:29 <Zekka> (or subject line?)
09:04:13 <nitrix> Zekka: "an idea for modifying data/newtype syntax: use `::=` instead of `=`".
09:04:36 <hodapp> maybe this relates to some of the usage I see of (->) but have never really understood
09:04:36 <nitrix> Another one is the pattern guard inside of list comprehensions.
09:05:05 <exio4> hodapp: what do you want to do with the arguments? 
09:07:32 <hodapp> exio4: in this case, pass 'undefined' or 'error ...' to each of them; 'Foo' here is a more complex type and is almost always constructed in a manner that the part I need can leave all the arguments unevaluated.
09:08:25 <hodapp> I would look this question up but I have no idea how to phrase it more generally
09:08:39 <hodapp> "functions which return Foo eventually"?
09:08:44 * hackagebot http-client 0.4.19 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.19 (MichaelSnoyman)
09:08:46 * hackagebot http-conduit 2.1.8 - HTTP client package with conduit interface and HTTPS support.  https://hackage.haskell.org/package/http-conduit-2.1.8 (MichaelSnoyman)
09:08:55 <nitrix> hodapp: What you suggest can be done easily. Those are called polyvariadic functions.
09:09:09 <bennofs> hodapp: variadic function?
09:09:26 <nitrix> bennofs: polyvariadic
09:09:35 <bennofs> oh right.
09:09:47 <exio4> hm, a typeclass should be enough then, class FooC a where getFoo :: a -> Foo ; instance FooC b => FooC (a -> b) where getFoo f = getFoo (f undefined) ; instance FooC Foo where getFoo = id 
09:09:50 <hodapp> nitrix: well, I'm not really trying to *make* a polyvariadic function, but to write functionality that is defined over it
09:10:01 <exio4> something like this should work, I think
09:10:32 <hodapp> though I guess as a stopgap measure I could just do foo1 :: (a1 -> Foo) -> Foo, foo2 :: (a1 -> a2 -> Foo) -> Foo, etc.
09:10:39 <nitrix> Honestly, I'd advise agaisn't it. It makes it harder to reason about the code.
09:10:55 <hodapp> nitrix: Yes, I'd advise against me doing it too.
09:11:03 <nitrix> Even Prelude goes the explicit route: https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Enum.html#line-210
09:11:23 <exio4> this is about taking polyvaridic functions as arguments
09:11:50 <hodapp> https://github.com/GaloisInc/ivory/issues/54#issuecomment-129278014 is the particular issue, to put some specifics on it, and I'm trying to make a more general solution from what he suggests
09:13:11 <bernd> is it possible to do something like: "instance MyTypeClass a => Show a where show x = >use a method of MyTypeClass here<" ?
09:13:16 <hodapp> so, yes, it's not a great solution, but neither is making it easy to violate Ivory's type-safety in the generated code, and I'm trying to avoid having definitions floating around that have error/undefined in certain fields
09:13:16 <leshow> quick question i was hoping you guys could help with
09:13:28 <leshow> i have a list and a lists of lists
09:13:34 <leshow> a = [1,2,3,4,5]
09:13:40 <leshow> b = [ [1,2,3,4], [1,2,3,4], [1,2,3,4], [1,2,3,4], [1,2,3,4] ] 
09:13:53 <leshow> using just the list functions
09:13:54 <hodapp> which is why I'm trying to make a function that isolates those to a single point and immediately turns them to another form that doesn't have error/undefined
09:14:01 <leshow> how can i make it so i end up with something like
09:14:04 <subleq> bernd: i think so. did you try it?
09:14:27 <leshow> [ [1-2,2-1,3-1,4-1], [1-2,2-2,3-2,4-2], .. ]
09:14:30 <hodapp> exio4: I'll take a look at that
09:14:36 <leshow> using just map and or zip
09:14:52 <dmj`> leshow: homework?
09:14:56 <Zekka> leshow: What's the pattern that gets you that output?
09:15:16 <leshow> no im just mucking around with haskell
09:15:55 <hodapp> exio4: is there any particular term for that technique? that of making function types an instance of typeclasses in order to allow arbitrary chains of functions
09:16:03 <tromp_> :t zipWith
09:16:04 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
09:16:22 <bernd> :subleq yes I tried it. I get got an error that it's an illegal instance declaration. It says I need *distinct type variables*. I googled for things like superclass etc. but I only found topics were both Sub and Supclass are userdefined
09:16:34 <bernd> subleq: ^ xD
09:16:55 <leshow> i thought it would be like map (\x -> zipWith (-) a x) b
09:16:59 <subleq> bernd: I think that's unrelated to MyTypeClass
09:18:24 <aweinstock> :t zipWith (map . (-))
09:18:25 <lambdabot> Num b => [b] -> [[b]] -> [[b]]
09:18:30 <exio4> hodapp: I don't know if there is one, I just thought of this as a quick solution, most things that need to recurse based on the type can be done using either typeclasses (if the behavior can change heavily based on the type, and the datatype you work with isn't a GADT)
09:19:18 <hodapp> I don't *think* it's a GADT
09:19:42 <hodapp> 'Foo' is a big messy type, because for one thing it's modeling an entire C procedure type in Ivory
09:19:58 <leshow> i'm not too familiar with the dot notation
09:20:06 <exio4> hodapp: yeah, I am talking about the value you're pattern matching on, in this case, it is (->) :P 
09:20:09 <bernd> subleq: hm I also tried -XFlexibleInstances as suggested by the ghc, but still the same error
09:20:17 <aweinstock> leshow: (.) is function composition
09:20:23 <aweinstock> @src (.)
09:20:23 <lambdabot> (f . g) x = f (g x)
09:20:41 <aweinstock> :t map . (-)
09:20:42 <lambdabot> Num b => b -> [b] -> [b]
09:20:43 <hodapp> exio4: oh!
09:20:58 <aweinstock> > (map . (-)) 5 [1..10]
09:21:00 <lambdabot>  [4,3,2,1,0,-1,-2,-3,-4,-5]
09:21:26 <aweinstock> > map (\x -> (-) 5 x) [1..10]
09:21:27 <lambdabot>  [4,3,2,1,0,-1,-2,-3,-4,-5]
09:21:44 <leshow> makes more sense to me with the lambda notation
09:22:12 <arian0n> bit of a strange example
09:22:17 <subleq> bernd: http://stackoverflow.com/questions/3213490/how-do-i-write-if-typeclass-a-then-a-is-also-an-instance-of-b-by-this-definit
09:22:17 <arian0n> 3> map (5-) [1..10]
09:22:21 <arian0n> whoopsie
09:23:03 <aweinstock> arian0n: did you paste an ANSI color escape there?
09:23:37 <monochrom> lambdabot does not understand colours :)
09:23:54 <arian0n> i have a weechat thing for automagically adding colours because I use > for 3>quoting
09:24:13 <monochrom> haha
09:24:18 <subleq> bernd: I was thinking of a constraint like that in a class definition, not an instance
09:25:44 <arian0n> >map (10+) [10,9..1]
09:26:02 <exio4> > map (10+) [10,9..1] -- it needs the space
09:26:03 <arian0n> looks like it requires that leading space as well
09:26:07 <lambdabot>  [20,19,18,17,16,15,14,13,12,11]
09:26:52 <leshow> agh, i still don't get it
09:26:59 <leshow> i understand your second example
09:27:04 <leshow> but trying it in ghci
09:27:37 <bernd> bernd: thank you! I guess they changed the error message; I get a different error then the OP. I'll read through the answers now. which search term did you use? 
09:27:53 <leshow> zipWith (map (-) a) b
09:27:58 <leshow> ?
09:28:32 <arian0n> leshow, `map (f . g) your_list` effectively means `map (\x -> f (g x)) your_list`
09:30:01 <leshow> but im trying to subtract a number in a list from a number in a list of lists
09:31:17 <aweinstock> :t zipWith (\x ys -> map (\z -> z - x) ys)
09:31:18 <lambdabot> Num b => [b] -> [[b]] -> [[b]]
09:32:38 <aweinstock> > let {xs = [1..5]; ys = [[10,20..50], [100, 200.. 500]} in zipWith (\x ys -> map (\z -> z - x) ys) xs ys
09:32:39 <lambdabot>  <hint>:1:54: parse error on input ‘}’
09:32:47 <aweinstock> > let {xs = [1..5]; ys = [[10,20..50], [100, 200.. 500]]} in zipWith (\x ys -> map (\z -> z - x) ys) xs ys
09:32:48 <lambdabot>  [[9,19,29,39,49],[98,198,298,398,498]]
09:33:15 <aweinstock> > let {xs = [1..5]; ys = [[10,20..50], [100, 200.. 500]]} in zipWith (map . flip (-)) xs ys
09:33:16 <lambdabot>  [[9,19,29,39,49],[98,198,298,398,498]]
09:34:09 <aweinstock> leshow: does the expanded form there help?
09:35:12 <leshow> yeah a lot. i kept looking at zipWith func signature and wondering where the other arguments were
09:35:47 <aweinstock> that's currying/eta-expansion
09:36:02 <aweinstock> "\x -> f x" = "f"
09:37:05 <leshow> i had it backwards, look at this
09:37:54 <leshow> map (\x -> zipWith (\z y -> z - y) x xs) ys
09:39:55 <leshow> what about skipping the first element in each list in ys?
09:40:08 <leshow> like only doing the subtraction to the second element onwards
09:40:28 <leshow> is there a skip 1 or something
09:40:47 <arian0n> the tail function
09:41:04 <arian0n> > tail [1..5]
09:41:05 <lambdabot>  <no location info>: can't find file: L.hs
09:41:18 <arian0n> ;~;
09:41:29 <tromp_> > tail "tail"
09:41:30 <lambdabot>  "ail"
09:41:53 <tromp_> > tail "mass"
09:41:55 <lambdabot>  "ass"
09:42:18 <geekosaur> for more than one,
09:42:19 <leshow> thats why i mentioned skipping 2
09:42:30 <geekosaur> > drop 2 "mice"
09:42:32 <lambdabot>  "ce"
09:42:34 <leshow> plus doesnt tail turn the type into maybe
09:42:49 <tromp_> maybe not
09:42:50 <geekosaur> no, sadly
09:42:57 <MarcelineVQ> safetail would, is there a safetail?
09:42:58 <aweinstock> > let {skipMap f [] = []; skipMap f [x] = [x]; skipMap f (x:xs) = x: map f xs} in skipMap (+10) [1..5]
09:43:00 <lambdabot>  [1,12,13,14,15]
09:51:22 <geekosaur> > drop 1 ""
09:51:23 <lambdabot>  ""
09:51:30 <geekosaur> ^ "safetail"
09:52:20 <leshow> aweinstock: you've been great, thanks dude
09:52:21 <bernd> subleq: Thank you! I'll go with edwardk's answer and do it by hand, cause I don't have a lot of instances anyway. They also seemed to have changed the error message, I got a different one running the example in the SO post. And which search term did you use for google?
09:52:41 <leshow> i just picked up haskell a little while ago and it's very challenging for me
09:53:18 <leshow> did you find it difficult in the beginning as well or did you have a more natural inclination towards FP
09:53:31 <subleq> bernd: I tried it myself and got the "Constraint is no smaller than the instance head." error. I'd be super cautious about enabling those extensions
09:53:46 * hackagebot acme-grawlix 0.1.0.2 - More readable names for commonly used symbols  https://hackage.haskell.org/package/acme-grawlix-0.1.0.2 (kadoban)
09:58:08 <bernd> subleq: Hm strange that we get different errors. I run ghc 7.10.1.  Yep that's why I'll do it by hand without extensions. I find it quite interresting in his last sentence, edward states that the syntax for class and instance is often backwards.
09:58:22 <mmachenry> Why doesn't hlint like this code? http://lpaste.net/138433
10:03:33 <SlopeTeBT> www.cryptos-revolution.com OMG free Bitcoin and Money here!!!! www.cryptos-revolution.com
10:03:46 * hackagebot hierarchy 0.2.0 - Pipes-based library for predicated traversal of generated trees  https://hackage.haskell.org/package/hierarchy-0.2.0 (JohnWiegley)
10:04:33 --- mode: ChanServ set +o Mauke
10:04:33 --- mode: Mauke set +b *!*@81-64-178-252.rev.numericable.fr
10:05:44 <ackthet> lot of spammers recently :(
10:06:34 --- mode: Mauke set -o Mauke
10:08:57 <mmachenry> http://hackage.haskell.org/package/bitcoin-api OMG free Bitcoin library everybody!! 
10:09:05 <mmachenry> :)
10:10:03 <nschoe> Hi guys. I'm reading the stack readme (on the github repo); there's smth I don't get: it says "[it features] installing GHC automatically" (among other things). Does this mean you can/should have a specific GHC installation for each sandbox?
10:10:03 <aweinstock> what do the spammers gain from spamming? (I've seen religious-themed spammers a couple of times here)
10:10:50 <nschoe> And btw, how does stack, cabal and cabal sandboxes fit together? I'm sort of confused: should I stop using cabal and use stack instead? Or are the two complementary?
10:12:37 <mmachenry> aweinstock: Money
10:12:38 <kadoban> nschoe: You can stop using cabal and use stack instead. Stack internally uses the Cabal library, and understands/uses .cabal files.
10:13:04 <leshow> stack is much easier to use than sandboxes
10:13:11 <leshow> its like an npm for haskell
10:13:14 <kadoban> nschoe: I'm not really sure how to answer your first question. Some packages require different versions of GHC and etc. Stack can handle that for you.
10:13:19 <leshow> except it also includes the ghc version
10:14:04 <nschoe> kadoban, leshow okay but how does a typical workflow is with stack? I'm creating a brand new haskell package,. Usually I would 'cabal sandbox init' in it, fill my .cabal, then 'cabal install --only-d'. How do I do that with stack?
10:14:13 <nschoe> (Thanks for answering btw :-) )
10:14:33 --- mode: ChanServ set +o Mauke
10:14:34 --- mode: Mauke set -b *!*@81-64-178-252.rev.numericable.fr
10:14:43 <aweinstock> mmachenry: I still don't see any obvious way for them to profit (unless they're using browser exploits and selling botnets or something)
10:15:06 <mmachenry> It's advertising just like any other. 
10:15:29 <zomg> With irc it's pretty strange because most irc users are fairly technical and would realize it's spam
10:15:44 <kadoban> nschoe: 'stack new', change stuff, then when it's ready, 'stack build'
10:15:47 <zomg> so I fail to understand the point of it when they're clearly trying to trick people with it
10:16:31 <kadoban> zomg: It's near zero cost and they're hoping that at least some people will click on it, or otherwise be interested in it.
10:16:33 --- mode: Mauke set -o Mauke
10:16:45 <geekosaur> mmachenry, re your code, it looks to me like it thinks your definiton of toOObj is not there. indentation perhaps?
10:16:58 <zomg> kadoban: yeah that seems plausible
10:17:21 <geekosaur> and if ghc accepts it then you probably should file a bug against hlint
10:18:01 <geekosaur> or perhaps against haskell-src-exts since that is presumably what hlint is using to parse it
10:18:02 <nschoe> kadoban, okay. But then there is no concept of sandboxes anymore? How is dependency hell solved? What if I build two packages, they need different version of a library?
10:18:05 <kadoban> nschoe: 'stack new' is pretty … new and not terribly pretty yet in the released version. So another option would be to just set up the project as you already do with cabal, and then 'stack build'
10:18:47 * hackagebot hierarchy 0.2.1 - Pipes-based library for predicated traversal of generated trees  https://hackage.haskell.org/package/hierarchy-0.2.1 (JohnWiegley)
10:20:41 <kadoban> nschoe: stack handles sandboxes internally, and reuses already built stuff when possible. It mostly seems to work via stackage snapshots. A stack.yaml project file specifies what snapshot to build against.
10:21:16 <nschoe> kadoban, okay. Are executables still installed in ~/.cabal.bin?
10:21:16 <leshow> nschoe: just use stack init or stack new i think
10:21:28 <leshow> yeah stack new
10:21:48 <nschoe> leshow, okay. Will stack init or stack new guide me to the process of creating the .cabal file the same way 'cabal init' does?
10:21:51 <kadoban> nschoe: ~/.local/bin
10:22:02 <nschoe> kadoban, okay. Thx
10:22:21 <leshow>   new                      Create a brand new project
10:22:23 <leshow>   init                     Initialize a stack project based on one or more cabal
10:22:25 <leshow>                            packages
10:22:42 <Ankhers> nschoe: `stack new` creates a new .cabal file for you. So you just need to add/remove any stanzas you don't need.
10:22:54 <leshow> stack new makes a stack.yaml file
10:22:56 <nschoe> Ankhers, cool. Thanks.
10:23:56 <mmachenry> geekosaur: Maybe? ghc likes it, just not hlint. I'll check of odd whitespace
10:24:22 <geekosaur> ok, sounds like you have an h-s-e bug then
10:24:37 <nschoe> And when I run 'stack build' in my Haskell project folder (let's say I am building an executable), is the executable also installed into ~/.local/bin? Or is the folder somehow considered a sandbox?
10:25:08 <Ankhers> I think it bets put in the `.stack-work` folder in that directory.
10:25:16 <Ankhers> I don't know the exact location of it.
10:25:18 <leshow> it just builds
10:25:23 <nschoe> What I like with cabal sandboxes is that it's all contained. I can't screw my system, I can't mess packages versions. Worst case I jsut rm -rf the folder and it's all gone. Is smth like that garanteed with stack too?
10:25:27 <leshow> it's not going to add it to your path or anything
10:25:49 <leshow> stack is contained, like running npm for a javascript project and saving deps to package.json etc
10:25:57 <nschoe> leshow, okay so it builds the package in the folder?
10:26:05 <leshow> it's even better though because it has local versions of ghc
10:29:05 <Luke> is there any data type that represents a connection to be made including connect host and port and bind host and port?
10:30:08 <leshow> nschoe: the whole point of the tool is to be able to work on projects and build packages without interferring with the rest of your system. yes.
10:30:46 <nschoe> leshow, okay.
10:30:59 <nschoe> Thanks for your answers. I'll try it, see if I can manage to get smth working.
10:31:57 <shirt> why doesn't the index page in haddock also have the type signature of each function?
10:32:29 <leshow> it's pretty simple, 'stack new'
10:32:32 <leshow> and start working
10:32:41 <leshow> edit the .cabal and .yaml file as necessary
10:33:09 <nschoe> leshow, yes but I like (more like "need", really) to *understand* what I'm doing.
10:33:24 <nschoe> Is there a detailed page of hwo stack works? The options, etc?
10:33:32 <leshow> stack help
10:33:58 <leshow> https://github.com/commercialhaskell/stack
10:34:24 <nschoe> Yes I'm on this page. There is only little information. But that's a start :-)
10:34:32 <leshow> it's just a package manager lol
10:34:38 <leshow> i don't know hwat else you need to know
10:35:53 <kadoban> nschoe: It's pretty new, there's lots that still needs to be done of course, including better docs.
10:36:30 <Ankhers> nschoe: stack is very similar to cabal-install (the binary that is `cabal`). It just abstracts away sandboxes so you don't have to think about them.
10:36:37 <nschoe> kadoban, yes I understand perfectly. I was not critizing, only asking if I had missed some doc (not to ask too many questions here that could be answered in the doc/wiki page)
10:37:09 <nschoe> Ankhers, okay. Thanks for that.
10:37:24 <kadoban> nschoe: No no, you didn't do anything wrong, just meant it to confirm that you're not missing something, there really are deficiencies (and why)
10:37:45 <nschoe> okay :-)
10:38:06 <Ankhers> nschoe: Both stack and cabal-install depend on the same library for things (Cabal). stack was just made to be a little easier to use I believe.
10:38:31 <Ankhers> And to address things like cabal not knowing how to build multiple projects.
10:39:27 <nschoe> Ankhers, okay so basically it is a matter of creating a folder, running 'stack new' and 'stack build' in it?
10:39:48 <Ankhers> That will at least build an example application, yes.
10:40:31 <Ankhers> It will name the project something along the lines of `project-template`, so you will obviously want to change that at some point before the first release.
10:40:39 <nschoe> What I don't understand is how / where (in the filsesystem) stack abstracts the sandboxes? If I am working on an executable, I need to be sure that 'stakc build' won't erase smth / override lib version in my ~/.local
10:41:23 <kadoban> nschoe: It creates ~/.stack and puts a bunch of crap in there.
10:41:41 <Ankhers> The build command, I'm fairly certain, will actually put files in the .stack-work folder at the root of the project.
10:41:54 <kadoban> Right, also there.
10:42:06 <nschoe> kadoban, okay. I suppose ~/.stack is for internal stuff. We're not supposed to do anything with it, right?
10:42:23 <nschoe> Ankhers, okay. What if I am building a lib? Still goes into .stack-work?
10:42:33 <kadoban> nschoe: AFAIK, the only thing you're supposed to do is put a config file in there if you want, and otherwise leave it alone yeah.
10:42:55 <nschoe> okay. Cool
10:43:01 <Ankhers> nschoe: I'm fairly certain that `stack build` will always put it there. `stack install` may place it elsewhere.
10:43:07 <nschoe> The build just finished on my Arch. I'm going to test it now.
10:43:30 <nschoe> Ankhers, makes sense, 'install' is supposed to be "definitive" or "release-like".
10:43:42 <nschoe> What is the difference between the .cabal file and the .yaml file?
10:44:32 <Ankhers> the .cabal file explains the Haskell project. The .yaml file explains which project(s) to build, and any potential additional dependencies that you do not what to place in the .cabal file.
10:44:49 <Ankhers> Oh, and the version of lts-haskell that it should use.
10:45:04 <nschoe> okay
10:45:34 <Ankhers> An example of the extra dependencies would be something like `yesod-bin`. This is so you won't install it on a production system, but you still know you can use it on your development machine.
10:46:32 <SrP> What GHC version is recommended to use today?
10:46:43 <crino> hello
10:46:45 <johnw> 7.10.2
10:47:32 <nschoe> Okay
10:48:48 * hackagebot vector-instances 3.3.1 - Orphan Instances for 'Data.Vector'  https://hackage.haskell.org/package/vector-instances-3.3.1 (EdwardKmett)
10:48:50 * hackagebot travis-meta-yaml 0.1.0.0 - .travis.yml preprocessor  https://hackage.haskell.org/package/travis-meta-yaml-0.1.0.0 (phadej)
10:53:23 <SrP> Thanks johnw, all previous issues solved?
10:53:25 <nschoe> A stupid question: how do you do when a package is not present in the LTS? (In my case, ghc-mod). Should we fallback to hackage?
10:53:42 <SrP> (Last time I asked it was advised not to used 7.10.2, although I don't remember why.)
10:54:19 <johnw> SrP: oh really? the Haskell Platform is using 7.10.2
10:54:40 <exio4> it was probably when ghc 7.10 was still new 
10:58:38 <SrP> Yep some time already. Fair enough, thanks!
10:59:26 <geekosaur> 7.10.1 had linking bugs that could make things interesting; that was why the Platform waited for 7.10.2
10:59:33 <SrP> Since everything here is a little old I guess I'll dump it all and start again, is there any recommended way to build GHC?
10:59:47 <geekosaur> that said, when 7.10.1 had just come out a lot of stuff was not yuet ready for it
10:59:58 <SrP> On OSX, that is. Nix, homebrew, platform, compiling the source...?
11:00:00 <geekosaur> (AMP and BBP kinda broke things)
11:00:18 <dmj`> SrP: no 'x' ?
11:00:43 <SrP> Pardon?
11:01:06 <dmj`> Oh, just thought your nick was usually SrPx
11:01:19 <SrP> oh
11:01:27 <dmj`> :)
11:01:30 <SrPx> thanks dmj` 
11:01:35 <johnw> haha
11:01:42 <johnw> and my IRC client colors SrP and SrPx differently
11:01:46 <johnw> so now I recognize you!
11:01:53 <SrPx> Hi johnw :D
11:02:33 <Ankhers> SrP: I've been using GHC for OSX. https://ghcformacosx.github.io/
11:02:42 <Ankhers> SrPx: ^^
11:02:49 <SrPx> I have a new project in Haskell so I thought it was a good time to try the new versions
11:03:31 <SrPx> Ankhers: that sounds very cool, thanks!
11:03:58 <Ankhers> SrPx: It was recommended to me a while back and I have had no issues with it.
11:04:00 <SrPx> dmj`: (when you said "no X" I thought you was mocking me for OSX)
11:04:54 <dmj`> SrPx: lol, nah
11:05:40 <johnw> I actually stuck with 7.8.4 up until last week
11:05:49 <johnw> it feels like waiting for the next rev of Apple products sometimes
11:05:53 <dmj`> SrPx: Figured there could be two people SrP and SrPx, but that would seem unlikely
11:06:21 <SrPx> I'd not be happy with that 
11:09:25 <dmj`> rightfully so
11:09:38 <dmj`> ;)
11:13:49 * hackagebot cached-io 0.1.0.1 - A simple library to cache a single IO action with timeout  https://hackage.haskell.org/package/cached-io-0.1.0.1 (glasserc)
11:28:50 * hackagebot css-syntax 0.0.1 - This package implments a parser for the CSS syntax  https://hackage.haskell.org/package/css-syntax-0.0.1 (wereHamster)
11:30:08 <maki> hello
11:30:19 <maki> anybody got an advice for somebody who finished reading real world haskell?
11:31:07 <Yuu-chan> maki: bring Haskell to the _real_ world :)
11:31:33 <maki> umm i'll try xD
11:31:56 <dmj`> maki: maybe read parallel and concurrent programming in haskell next..
11:32:25 <maki> thank you
11:33:04 <Welkin> maki: did you go through the upenn course and nicta?
11:33:14 <Welkin> @where learnhaskell
11:33:15 <lambdabot> https://github.com/bitemyapp/learnhaskell
11:33:16 <maki> no, i haven't seen it
11:33:30 <Welkin> the cis194 assignments are pretty good (but sometimes poorly worded)
11:33:38 <Welkin> there is #haskell-beginners for help with the courses
11:33:44 <Yuu-chan> @where what i wish i know while learning haskell
11:33:44 <lambdabot> I know nothing about what.
11:34:26 <Yuu-chan> Well, that: http://dev.stephendiehl.com/hask/
11:34:42 <Welkin> yeah, I have that one bookmarked :)
11:34:57 <maki> i've seen this one. what i wish i knew when learning haskell, i've saved the site
11:36:02 <maki> when you say NICTA you mean National ICT Australia?
11:37:26 <maki> ohh, i've seen the upenn lectures, sorry
11:37:48 <Def1> are guards like if statments?
11:38:35 <ReinH> Def1: similar
11:38:37 <liste> Def1 kinda
11:38:51 <ReinH> They allow multiple clauses, so they are more similar to MultiwayIf.
11:39:06 <liste> and with them it's possible to fall back to next pattern
11:39:59 <Zemyla> Okay, I am having a big problem with my Unlambda interpreter.
11:40:18 <Zemyla> I typed it in to the ghci command line, and it worked fine.
11:40:32 <kadoban> maki: https://github.com/NICTA/course
11:40:56 <Zemyla> Them I typed the exact sa,e things into a file, compiled it, and ran it with the sa,e test program, and it's giving me "out of memory" errors.
11:40:58 <maki> I haven't seen this till now, thank you kadoban
11:41:28 <srhb> maki: I just want to +1 that suggestion. It will make you a lot more type savvy :)
11:41:59 <maki> shrb, you mean the NICTA course?
11:42:10 <srhb> maki: Yes :)
11:45:33 <benzrf> QUESTION: why is there no operator Functor f => f (a -> b) -> a -> f b
11:45:59 <Welkin> benzrf: hello Dwight Shrute
11:46:21 <benzrf> it's SCHRUTE
11:46:25 <benzrf> i dont even watch the office and i knew that
11:46:43 <Welkin> hahaha
11:47:31 <voidzero> haha Welkin so i'm not the only one who is reminded of the Office everytime someone starts with 'question' :)
11:48:22 <voidzero> i even have dwight and jim bobbleheads
11:48:30 <Yuu-chan> benzrf: what knowledge is required to answer this question?
11:49:24 <srhb> I guess because f <*> pure a is trivialish
11:49:27 <Cale> benzrf: (\f x -> fmap ($ x) f)
11:49:38 <srhb> Oops, accidentally applicatived it.
11:50:07 <Yuu-chan> @djinn Functor f => f (a -> b) -> a -> f b
11:50:07 <lambdabot> Error: Class not found: Functor
11:51:17 <Zemyla> :t flip (fmap . (&))
11:51:18 <lambdabot> Functor f => f (a -> b) -> a -> f b
11:51:19 <Welkin> :t extend
11:51:20 <lambdabot> Not in scope: ‘extend’
11:51:50 <Welkin> benzrf: in what situation would you want that function?
11:53:00 <Zemyla> :t fix . flip (fmap . (&))
11:53:01 <lambdabot> Functor f => f (f b -> b) -> f b
11:55:59 <hamsterdam> Hi, looking for help setting up https://github.com/eagletmt/ghcmod-vim
11:56:44 <hamsterdam> I have ghc-mod and vimproc installed but can't run any ghcmod-vim commands
11:56:51 <hamsterdam> Any ideas?
11:58:39 <Jello_Raptor> huh, I've got a multiparamtypeclass that needs "class Foo a a => Foo a b" to work, but GHC complains of cycles 
11:59:05 <Jello_Raptor> is there a workaround or good reason I shouldn't use the patter? 
11:59:07 <Jello_Raptor> pattern* 
11:59:19 <benzrf> i dont know my stuff good but fundeps may be in order
12:01:02 <Jello_Raptor> hmm, "class Foo a a => Foo a b | b -> a" still fails :/ :w
12:02:28 <benzrf> does b -> a, though?
12:02:33 <benzrf> wait hold on
12:02:38 <benzrf> what the heck
12:02:53 <benzrf> i thought you meant Foo a a => Foo a b as an /instance/
12:03:13 <benzrf> wh-why do you need that?
12:03:45 <Cale> Jello_Raptor: That makes little sense, what is this class?
12:03:51 * hackagebot css-syntax 0.0.2 - This package implments a parser for the CSS syntax  https://hackage.haskell.org/package/css-syntax-0.0.2 (wereHamster)
12:04:11 <Jello_Raptor> "class MeetSemiLattice b b => MeetSemiLattice a b | a -> b where" and yeah I mixed up instances and class. It's much more appropriate in the instance <_<
12:04:42 <Cale> It also doesn't make much sense as an instance, for a different reason (it's way too polymorphic)
12:04:42 <benzrf> :]
12:05:23 <johnw> and what if a ~ b
12:06:55 <Cale> Yeah, is there an instance MeetSemilattice Integer Integer? Well, this instance for MeetSemilattice a b matches that, so we'll commit to it. Now we just need to locate an instance MeetSemilattice Integer Integer to satisfy the constraint.
12:07:39 <Jello_Raptor> Cale: it can't detect when the instance itself is satisfying the requirements for the instance? 
12:08:22 <Cale> If you're going to require the two types to be the same, why have two type arguments?
12:09:01 <Cale> This instance is going to always match everything, so you won't be able to write any further instances of the class.
12:09:45 <Jello_Raptor> Cale: not always what I really want is to wrap semilattices with no top or bottom but with join and meet ops in a Maybe, so I can use Nothing as the top or bottom. http://lpaste.net/138438
12:09:52 * Jello_Raptor might just be going about it all wrong. 
12:10:24 <Jello_Raptor> while still having nice "join :: a -> a -> Maybe a" pop out. 
12:14:56 <Jello_Raptor> The other solution, with separate classes for semi-lattices with a 'meet' and those with both a 'meet' and 'bottom' led to me having multiple version of 'meet' that i really didnt' want. 
12:26:04 <hodapp> exio4: Your suggestion with typeclasses with instances of (a -> b) and (Foo c) is mostly working, but I'm running into some annoyances with ambiguous types; particularly, I have some function a -> b -> Foo Bar and even though that function has 'c' specified it can't be inferred
12:27:19 <hodapp> if I purposely mismatch the types, then compile fails because no instance is defined, so that's progress at least
12:33:23 <sctr> Hi. is ppa:hvr/ghc down for everyone or just? 
12:33:46 <dmj`> slackoverflow lol
12:34:06 <slackoverflow> dmj`: ?
12:34:06 <creichert> I've had issues since last night
12:34:17 * geekosaur wonders if it's in ec2
12:34:28 <haskellberry_pie> Anyone use Haskell on the reaspberry pi?
12:34:36 <sctr> sudo apt-get install -y cabal-install-1.20 ghc-7.8.4 produces unable to locate/find any package
12:34:38 <dmj`> slackoverflow: nice nick
12:34:41 <geekosaur> "We have just become aware of EC2 network connectivity issues in the US-EAST-1 region. The impact of this issue is loss of network connectivity to EC2 instances." <-- just reported elsewhere
12:34:51 <hvr> sctr: don't know... where does it show?
12:34:54 <creichert> yea, i think so (mine were issues with apt as well)
12:35:01 <slackoverflow> dmj`: thanks! :)
12:35:19 <haskellberry_pie> dmj`, i think mine is better :)
12:35:28 <sctr> hvr: ubuntu console
12:36:11 <dmj`> haskellberry_pie: yours is good too
12:37:35 <sctr> hvr: navigating to http://ppa.launchpad.net/hvr/ghc/ubuntu/dists/utopic/main/binary-i386/ ... seems that Package file has size 0 bytes 
12:38:02 <hodapp> haskellberry_pie: are you trying to use GHC on the Pi?
12:38:13 <lpaste_> Exio4 pasted “No title” at http://lpaste.net/138439
12:38:16 <hvr> sctr: well, 'utopic' is EOL'ed
12:38:20 <exio4> hodapp: if there's a phantom type that you need to match, I would use something like that 
12:38:34 <sctr> hvr: my debian-fu is a little bit rusty, so not sure if i'm checking right thing
12:38:46 <hvr> sctr: http://ppa.launchpad.net/hvr/ghc/ubuntu/dists/vivid/main/binary-amd64/
12:39:38 <hvr> sctr: I had to remove the Utopic debians after Utopic was EOL'ed as they wouldn't allow new uploads anyway
12:39:42 <hvr> and I needed the space
12:39:49 <hodapp> exio4: I parametrized the typeclass over two things instead of one, but I'm not sure if that counts
12:40:01 <hvr> s/debians/deb packages/
12:40:03 <hodapp> exio4: let me see if I can throw together a simpler example
12:40:29 <sctr> hvr: yup, not sure, however, what directory my distro checks for packages
12:40:30 <exio4> hodapp: it works, but if you don't want to kill type inference, you need functional dependencies
12:40:46 <haskellberry_pie> hodapp, i bought a RP2, i want to program it in haskell, is it possible
12:40:48 <haskellberry_pie> ?
12:41:09 <hodapp> haskellberry_pie: I'd recommend you just try it and see.
12:41:14 <hvr> sctr: what does 'lsb_release -d'  say?
12:41:17 <exio4> hodapp: (I think using functional dependencies is nice when there are multiple ways to infer the rest the parameters, in this case, I would use type families) 
12:41:50 <sctr> hvr: Ubuntu 14.10
12:42:00 <tdammers> haskellberry_pie: have you read this: https://wiki.haskell.org/Raspberry_Pi
12:42:03 <hodapp> haskellberry_pie: I don't know if GHCi is available yet on ARM, however
12:42:22 <hvr> sctr: sorry to tell you, but you;re using a Ubuntu version that is EOL'ed http://www.ubuntu.com/info/release-end-of-life
12:42:26 <sctr> hvr: utopic
12:42:38 <hvr> sctr: you should really upgrade
12:42:58 <sctr> hvr: ooops :) so now i've got bigger reinstall to do... <sigh>...
12:43:06 <sctr> hvr: thx
12:43:06 <hodapp> exio4: and I suppose I'm having a hard time with how that final return value can specify that type variable
12:43:40 <tdammers> sctr: what's the big deal, is ubuntu's dist-upgrade unreliable or sth?
12:44:41 <exio4> hodapp: you always need the first parameter, though 
12:46:00 <RageYL> hi 
12:46:57 <hodapp> exio4: what do you mean by first parameter?
12:47:23 <exio4> getFoo :: A -> B, B can be deduced per A 
12:47:39 <exio4> so, with fundepos, it'd be class Foo a b | b -> a where 
12:48:30 <hodapp> exio4: the problem is that here I can't put any constraints on 'A' or on any of the N arguments that function may have before producing B
12:48:33 <nschoe> Is anybody here using ghc-mod (more particularly ghc-modi)? I cloned the git repo, made it a sandbox, run cabal install. Now when I run "ghc-modi" from within the sandbox, it seems to work, but when I run it from another directory, I've got error regarding setup-config.
12:49:06 <nschoe> Can somebody shed light on that please? I tried to use ghc-mod with the Atom editor, but I had constant error. I think this is where it comes from.
12:49:10 <exio4> hodapp: I don't understand the problem 
12:49:32 <exio4> (also, I got the fundep wrong, it was a -> b)
12:50:29 <duckbob> suppose I had a lot of data someone had parsed (simple pretty print) from JSON, and I wished to parse it back into JSON, but wished to designate an abstract pretty print function, is there a good library that handles this kind of opperation?
12:50:47 <hodapp> exio4: I'm trying to handle a1 -> a2 ... -> Foo b where a1 etc. can be any type at all; I can't see any way that I can derive 'b' from anything else there
12:51:49 <exio4> hodapp: you don't derive b, you derive "Foo b" (you need to do this to make sure the base case makes sense) 
12:52:05 <hodapp> exio4: but from what can I derive 'Foo b'?
12:52:12 <obadz> What's is the type ((,) e)
12:52:19 <exio4> hodapp: the function?
12:52:24 <obadz> All tuples where first element is of type e ?
12:52:29 <exio4> (a1 -> a2 -> Foo x) -> Foo x 
12:52:38 <hodapp> exio4: ahh, okay, I see what you mean
12:52:52 <duckbob> is there a library which handles abstract representations such that JSON or CSV or other common formats can be read and shown in a customisable way?
12:53:53 * hackagebot casing 0.1.0.1 - Convert between various source code casing conventions  https://hackage.haskell.org/package/casing-0.1.0.1 (TobiasDammers)
12:53:54 <bitemyapp> duckbob: is that a confusing way of asking for a pretty printer?
12:53:59 <duckbob> e.g. if i wanted to create and read from colon seperated variable files obtained by swapping commas to colons in a csv file...
12:54:04 <duckbob> colum*
12:54:55 <duckbob> bitemyapp: its more than just a pretty printer, its a reader to a common datatype file format e.g. a datatype representing the contents of a CSV file which have been read in
12:55:56 <Phillemann> Hm, so the canonical way to include examples in your project is to add a separate directory, cabal file, LICENSE file etc.? I saw that in the lens package.
12:56:22 <duckbob> it would be one problem to pretty print JSON, but i want to use a JSON pretty printer to work on something which has already been pretty printed from JSON.
12:56:33 <obadz> I don't understand this: instance Monoid e => Applicative ((,) e) where pure x = (mempty, x) -- and -- (u, f) <*> (v, x) = (u `mappend` v, f x)
12:56:47 <shachaf> I understand it.
12:56:49 <athan> What's the complexity of Data.List.sort? O(n*log(n))?
12:56:50 <johnw> obadz: what part is confusing?
12:56:52 <obadz> What are the constraints on the type of f and x and what guarantees that f x is well defined?
12:57:16 <shachaf> obadz: Start by figuring out the types of pure and (<*>)
12:57:36 <obadz> ah
12:57:37 <obadz> yes
12:57:44 <obadz> hmmmmmm
12:57:46 <duckbob> i think i want to turn a pretty printer into a reader
12:58:02 <obadz> shachaf: Ok I guess that answers it
12:58:31 <duckbob> :t pure
12:58:32 <lambdabot> Applicative f => a -> f a
12:58:35 <duckbob> :t <*>
12:58:35 <obadz> and to my previous questions ((,) e) are tuples whose first element is of type e ? Couldn't we have written (e, e') ?
12:58:36 <lambdabot> parse error on input ‘<*>’
12:58:45 <obadz> :t (<*>)
12:58:45 <duckbob> :t (<*>)
12:58:46 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:58:46 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:59:02 <shachaf> You could have written (e, e') if you had e'
12:59:09 <shachaf> (,) a b means the same as (a,b)
12:59:21 <obadz> shachaf: what do you mean by "having" e' ?
12:59:27 <obadz> shachaf: can't it be a free type variable?
12:59:28 <duckbob> thats a function which takes a functor of a function from a to be, a functor of type a and returns a functor of type b
12:59:35 <shachaf> It's not a variable at all.
12:59:42 <shachaf> "e'" doesn't exist in "((,) e)"
13:00:15 <shachaf> This is a bit like saying: (+) 5 is a function. But why can't I write (5 + 3) instead?
13:00:29 <shachaf> You can, if you know the number 3. But if you don't, that doesn't help you much.
13:00:36 <obadz> I thought I was saying that (+ 5) is a function but why can't I write \ x -> 5 + x
13:00:41 <duckbob> you can if you have 3
13:00:47 <shachaf> You can write \x -> 5 + x
13:00:53 <obadz> but not (e, e') ?
13:01:02 <shachaf> You can write (e, e'), too.
13:01:07 <shachaf> You can't write \e' -> (e, e')
13:01:17 <SrPx> If I import Prelude qualified, can I make a synonym for classes such as "class Show = Prelude.Show" ?
13:01:28 <duckbob> because you dont have e?
13:01:39 <hodapp> exio4: I think I get it, but I am trying to figure out then how to write the instances
13:02:11 <obadz> shachaf: what confuses me is that in Applicative instances the variables of the "contained" variable is typically there
13:02:26 <obadz> shachaf: like instance Applicative [a] where ...
13:02:40 <shachaf> You are incorrect.
13:02:50 <duckbob> does anyone who knows anything about parsing JSON know a library i could use to read to JSON from pretty printed JSON?
13:02:53 <obadz> is it instance Applicative [] ?
13:02:59 <duckbob> by inverting the pretty printer...
13:03:02 <obadz> I guess I should look this up
13:03:09 <shachaf> Yes, you should look everything up.
13:03:41 <duckbob> its not instance of Applicative []
13:03:48 <duckbob> it needs the a
13:03:54 * hackagebot sneakyterm 0.1 - Tiny, declarative wrapper around ncurses  https://hackage.haskell.org/package/sneakyterm-0.1 (pimiddy)
13:04:10 <duckbob> otherwise it wouldnt know what kind of list you were making instances for
13:04:16 <obadz> duckbob: nope
13:04:21 <shachaf> You're both wrong.
13:04:24 <obadz> duckbob: not according to LYAH
13:04:38 <obadz> http://learnyouahaskell.com/functors-applicative-functors-and-monoids
13:04:41 <duckbob> darn
13:04:44 <shachaf> You can find out the truth by typing ":i Applicative" in ghci
13:05:19 <duckbob> not in scope data constructor...
13:05:29 <aupiff_> I'm reading about Pierce's law, and I'm confused both about how it implies law of excluded middle and how it is the type of continuation operators? Anybody care to explain or point me to a good resource?
13:05:43 <obadz> works for me
13:06:20 <kadoban> duckbob: If you're in 7.8, you probably need to import Control.Applicative, I believe. Or in ghci I guess that'd be :m + Control.Applicative
13:07:32 <aupiff_> the proof of ((P -> Q) -> P) -> P in propositional logic is simple, but I want some intuition about it's connection with continuation.
13:07:39 <duckbob> [21:01] <obadz> shachaf: what confuses me is that in Applicative instances the variables of the "contained" variable is typically there [21:02] <obadz> shachaf: like instance Applicative [a] where ...
13:08:00 <obadz> So instances of Applicative take * -> * so [] and not [a] and ((,) e) and not (e, e'). Mind blown again...
13:08:18 <shachaf> aupiff_: Well, think about how continuations behave.
13:08:25 <duckbob> ahh that makes sense
13:08:36 <duckbob> what are you applying?
13:08:42 <obadz> When will Haskell stop to blow my mind like my mind is worth nothing :-/
13:08:51 <duckbob> it needs to be provided something?
13:08:52 <shachaf> aupiff_: Imagine you had first-class continuations.
13:09:24 <shachaf> aupiff_: callCC (\k -> 5) = 5, right?
13:10:09 <aupiff_> shachaf: yep, makes sense
13:10:11 <shachaf> I.e. if you don't use the continuation at all, callCC (\_ -> x) = x
13:10:19 <duckbob> obadz it would not make sense to define it for a data constructor which took no arguments. if it were not a function it would not be composable? is this right!?
13:10:30 <shachaf> So callCC :: (something -> a) -> a
13:10:47 <shachaf> The other way you can use callCC is callCC (\k -> ...(k x)...)
13:10:49 <obadz> duckbob: I don't know my brain is shattered in pieces sticking to the wall...
13:11:06 <duckbob> haha
13:11:20 <duckbob> shachaf: is that right?^
13:11:21 <obadz> duckbob: but the key is here: class Functor f => Applicative (f :: * -> *) where
13:11:33 <obadz> duckbob: f is a * -> * HKT
13:11:47 <shachaf> I don't know.
13:11:47 <duckbob> HKT?
13:12:12 <shachaf> aupiff_: As soon as you use k x, the whole callCC expression returns x.
13:12:18 <obadz> actually forget the HKT part I think that's wrong
13:12:35 <obadz> duckbob: the kind of f is * -> *
13:12:40 <shachaf> aupiff_: So callCC (\k -> k 5 + 3) = 5. Have you seen that sort of thing before?
13:12:56 <hodapp> exio4: e.g. when I have the instance a -> b, neither 'a' nor 'b' is helping to derive 'Foo c'
13:13:09 <hodapp> thus coverage condition is not fulfilled
13:13:09 <obadz> duckbob: meaning f is a function from some type a to some type f a
13:13:30 <aupiff_> shachaf: not really, I've got to play with callCC a bit. is there a way to play with it in haskell? using cont monad?
13:13:30 <obadz> duckbob: [a] is a type, [] is a function from type a to type [a]
13:13:43 <obadz> duckbob: function in type space, not in value space
13:13:47 <shachaf> aupiff_: Not really.
13:13:53 <aupiff_> :(
13:13:56 <duckbob> shachaf, the mezmerising thing to obadz is that datatypes which instantiate Applicative must take an argument, im also learning about this and i understand that Applicative things must be composable, in the sense of (.) and so it makes sense that the datatypes must take at least one argument...
13:13:59 <shachaf> You could try Scheme or something.
13:14:20 <aupiff_> I'll write some scheme, yeah.
13:14:29 <shachaf> aupiff_: The thing is that there are two ways to "return" from the argument to callCC.
13:14:38 <chalkandpaste> Hi everyone. Sorry to interrupt. I'm looking for some help with cabal. I've noticed, when I compile libraries into .so files, the names get mangled (and also the names within the ELF get mangled) with some sort of hash. I link with some libraries and want to make builds more reproducible across machines, so this is a bit of a headache.
13:15:08 <shachaf> You can just return a value the normal -- callCC (\k -> x) -- or you can pass the value to the continuation -- callCC (\k -> ...(k x)...)
13:15:11 <benzrf> chalkandpaste: no need to apologize!
13:15:16 <chalkandpaste> Is there some way to disable this hash that's suffixed?
13:15:17 <benzrf> thats what the channel is for
13:15:30 <chalkandpaste> thanks @benzrf
13:15:32 <duckbob> :t <*>
13:15:33 <lambdabot> parse error on input ‘<*>’
13:15:36 <exio4> hodapp: A should determine B 
13:15:41 <duckbob> :t (<*>)
13:15:41 <shachaf> duckbob: Please use /msg lambdabot to experiment with lambdabot.
13:15:42 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
13:15:44 <benzrf> chalkandpaste: id answer your question but i have no idea :]
13:15:51 <duckbob> ok
13:15:57 <exio4> hodapp: do you have some example code, actually?
13:16:03 <simon> what emacs mode is the most popular for in-editor errors/warnings from ghc/hlint? I installed flymake-hlint.el, but now I found flymake-haskell-multi.el, and it even points towards using flycheck instead.
13:16:06 <shachaf> You've already asked for the type of that function four times, two of them without parentheses. :-)
13:16:12 <geekosaur> I don't think you can disable them, and if you could then things can explode rather badly
13:16:45 <geekosaur> I think the nix folks have been working on this but don't know if there;s a convenient place to see what's been going on
13:16:48 <shachaf> aupiff_: Anyway translating between callCC and LEM and DNE and so on is a fun exercise, but it's better to have a bit of intuition for callCC first, I think.
13:16:50 <aupiff_> shachaf: thanks, that helped. pulled up a page on Haskell CPS and found this familiar type: callCC :: ((a -> Cont r b) -> Cont r a) -> Cont r a
13:17:14 <hodapp> exio4: https://www.fpcomplete.com/user/hodapp/polyvariadic-stuff is what I'm looking at that's loosely derived from the full code
13:17:31 <chalkandpaste> geekosaur, thanks. How would it explode badly? I want to run a single service on a single instance, so conflicting versions shouldn't be an issue.
13:18:04 <duckbob> obadz: do you see how in the type of <*> the f has been *applied to* several arguments (namely (a->b),a,b)
13:18:23 <geekosaur> because ghc exports internals as part of the interface for inlining (and this is really needed to get any kind of semi-reasonable performance). and which internals can change, which means builds are not entirely reproducible anyway
13:18:33 <geekosaur> 7.0 has helped with this but I understand there are still issues
13:18:38 <geekosaur> er, 7.10
13:18:54 * hackagebot hierarchy 0.3.0 - Pipes-based library for predicated traversal of generated trees  https://hackage.haskell.org/package/hierarchy-0.3.0 (JohnWiegley)
13:19:04 <hodapp> exio4: it's a small modification on top of the code that is working without inference, so I'm having trouble figuring out what A and B are even supposed to refer to here
13:19:31 <obadz> duckbob: if is just the container
13:19:33 <obadz> duckbob: f
13:20:04 <geekosaur> the hash tracks what exactly is in the build, so same hash should mean a compatible build. the hash changing is exactly evidence that things are not yet quite right
13:20:18 <duckbob> but f must take one argument, it cant just be a datatype
13:20:37 <exio4> hodapp: that's why I prefer type families in those cases (like the code I pasted a bit ago)
13:20:38 <duckbob> (a datatype which takes no arguments*)
13:20:58 <exio4> http://lpaste.net/138439 
13:21:35 <obadz> duckbob: yes correct
13:22:06 <obadz> duckbob: that's what the * -> * in the definition enforces
13:22:28 <duckbob> is there a library for transforming between read and show instances?
13:22:54 <duckbob> obadz: thanks
13:22:56 <obadz> duckbob: meaning you write the printer and the parser comes out magically? :)
13:23:11 <chalkandpaste> geekosaur: I understand things could go badly if I'm not compiling everything at the the same time (which I am). I'm trying to link Rust against Haskell (which I've done successfully on many machines) but the only headache is the hashes
13:23:17 <duckbob> or i write both and can create similar ones
13:23:25 <hodapp> exio4: ahh, thanks, that makes more sense
13:24:06 <obadz> duckbob: what type do you have that's not some combination of records & ADTs and contain types that already implement read/show?
13:24:21 <hodapp> exio4: so in effect you've used type families there to carry the type through up to the instance that finally returns 'Foo w'?
13:24:34 <exio4> hodapp: indeed
13:24:38 <duckbob> i dont know of the things you speak, which is probably why im asking...
13:24:44 <hodapp> exio4: damn, now I still have to learn fundeps properly :P
13:25:09 <exio4> hodapp: I prefer fundeps for things that are bidirectional in some sense
13:25:25 <obadz> duckbob: is there a specific type you're looking to implement read/show for?
13:25:30 <hodapp> exio4: what do you mean bidirectional?
13:25:54 <mauris_> maaaybe you could make a FooShow typeclass and write an instance FooShow a => Show a that does whatever the instances have in common
13:27:20 <exio4> hodapp: when you have two parameters to the typeclass, and can derive one from the other
13:28:00 <hodapp> exio4: fundep says you *must* then derive one from the other, doesn't it?
13:28:54 <exio4> kinda, I don't know the right words
13:28:55 * hackagebot hierarchy 0.3.1 - Pipes-based library for predicated traversal of generated trees  https://hackage.haskell.org/package/hierarchy-0.3.1 (JohnWiegley)
13:28:57 * hackagebot pipes-files 0.1.0 - Fast traversal of directory trees using pipes  https://hackage.haskell.org/package/pipes-files-0.1.0 (JohnWiegley)
13:30:54 <hodapp> exio4: that seems to work in the "real"(tm) code, thanks
13:31:25 <hodapp> it looks like I had little need for a functional dependency when I didn't actually need to parametrize the typeclass over the return type
13:31:25 <mmachenry> Does anyone know the status of Hackage's password recovery system? A collaborator is having trouble with it. 
13:31:39 <geekosaur> try in #haskell-infrastructure
13:31:48 <kadoban> mmachenry: I used it last night and it worked.
13:32:26 <chalkandpaste> geekosaur: thanks, will do
13:33:56 <refefer> is there a better Data.Tree?  it's pretty limited
13:34:25 <johnw> better in what sense?
13:34:33 <johnw> I use the fgl when I want an actual graph to work with
13:34:49 <simon> I don't think it gets a better name than Data.Tree >:P
13:35:40 <mmachenry> kadoban: Huh, interesting. I wonder why it was broken for him. 
13:35:42 <johnw> also, you could use Control.Comonad.Free, where Cofree [] a ≅ Tree a.  That gives you a few more instances and utilities to work with.  It really depends on what you're intending to do.
13:35:51 <johnw> Control.Comonad.Cofree
13:35:51 <obadz> Isn't there an instance of Monoid a for Num a ?
13:36:09 <benzrf> cabal-install is running out of memory on me 512M vps
13:36:10 <benzrf> is this normal
13:36:11 <geekosaur> obadz, no. there are two newtypes providing such though
13:36:12 <johnw> obadz: no, because there wouldn't be a one-to-one selection
13:36:32 <obadz> johnw: what does that mean and why is it a problem?
13:36:34 <geekosaur> because both (0,+) and (1,*) are monoids
13:36:53 <geekosaur> so you have Sum and Product newtypes that have the Monoid instances
13:36:57 <obadz> well there's many cases where multiple instances of a typeclass are reasonable
13:37:07 <geekosaur> how do you pick one?
13:37:08 <obadz> we just pick one and have alternative newtypes no?
13:37:09 <simon> benzrf, same happened to me.
13:37:18 <simon> benzrf, I didn't resolve it.
13:37:20 <obadz> I see
13:37:38 * benzrf is mad
13:37:39 <geekosaur> there isn't really any gouns to say that (0,+) or (1,*) is "the" monoid
13:37:44 <geekosaur> *any grounds
13:37:49 <geekosaur> so they refused to pick one
13:37:50 <kadoban> benzrf: Depends what you're building, but sounds normal.
13:38:00 <benzrf> im not building anything
13:38:04 <benzrf> this is cabal update
13:38:05 <exio4> benzrf: I added swap until it stopped crashing
13:38:17 <benzrf> how i add swap
13:38:30 <kadoban> benzrf: Then I dunno, sounds unexpected maybe.
13:39:07 <obadz> geekosaur: ok thx
13:39:11 <geekosaur> I don't think they try to make it work in 512M... mostly because ghc won't link with that little
13:39:36 <benzrf> q_q
13:39:42 <benzrf> how do i get a haskell thing installed t h en
13:40:56 <saml> benzrf, linux?
13:41:02 <benzrf> ye
13:41:12 <benzrf> not much market for windows vps's is there
13:41:24 <saml> can't you compile things locally and upload to your server?
13:41:32 <benzrf> i guess
13:41:37 <benzrf> seems a little weird to do so
13:41:40 <benzrf> :\
13:41:45 <saml> if it's a web application, compiling on live server could be bad
13:43:24 <saml> what are good resources for math ph.d?
13:43:33 <Peaker> If instances were named at the type level, we could have type-indexed the instances we select, and then have both coherency and free instance selection.. Any reason this would not be a nice enhancement?
13:43:34 <exio4> benzrf: free -mt; dd if=/dev/zero of=swapfile bs=1M count=500 ; mkswap swapfile ; swapon swapfile ; free -mt 
13:43:35 <saml> to learn haskell for his field
13:44:07 <afons> What is a better way to do : foo ('b':'a':'r':s) = fuzz s 
13:44:16 <afons> I find this annoying when the pattern is very long
13:44:26 <saml> startsWith ?
13:44:30 <benzrf> o ye i think ive done that before exio4
13:44:37 <afons> samlk ?
13:44:41 <afons> saml ?
13:44:52 <afons> example
13:45:00 <saml> > isPrefixOf "bar" "barrrr"
13:45:02 <lambdabot>  True
13:45:06 <xplat> there's a prism too
13:45:07 <afons> but I need the rest
13:45:16 <afons> ..
13:45:22 <saml> oh i see :P
13:45:36 <xplat> > prefixed "bar" # "basol"
13:45:38 <lambdabot>  "barbasol"
13:45:43 <afons> ?
13:45:58 <Peaker> > "barzilay" ^? prefixed "bar"
13:45:59 <saml> > stripPrefix "bar" "barrrrr"
13:46:00 <lambdabot>  <no location info>: can't find file: L.hs
13:46:00 <lambdabot>  Just "zilay"
13:46:15 <saml> it'll be Nothing if not prefixed with bar
13:46:35 <xplat> > "bambi" ^? prefixed "bar"
13:46:36 <lambdabot>  Nothing
13:46:45 <saml> @hoogle prefixed
13:46:46 <lambdabot> No results found
13:47:00 <afons> where is ^? from ?
13:47:06 <saml> https://www.haskell.org/hoogle/?hoogle=%5E%3F
13:47:15 <xplat> lens (Control.Lens)
13:47:32 <afons> could not find module lens
13:47:42 <saml> i think it's 3rd party 
13:47:53 <xplat> if you'd rather spell it with letters you can say 'preview'
13:47:54 <saml> with a lot of dependencies
13:47:58 <Zemyla> Okay, I figured out what was wrong with my Unlambda interpreter.
13:48:00 <xplat> @hackage lens
13:48:00 <lambdabot> http://hackage.haskell.org/package/lens
13:48:18 <xplat> :t stripPrefix
13:48:19 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
13:48:39 <afons> where is stripprefix from
13:48:43 <xplat> base
13:49:05 <xplat> i think it's either prelude or Data.List
13:49:21 <afons> example ?
13:49:27 <afons> of working the way I described
13:49:56 <xplat> > stripPrefix "bar" "barbara"
13:49:57 <lambdabot>  Just "bara"
13:50:05 <afons> nice
13:50:06 <afons> thanks
13:50:16 <benzrf> bara ( ͡° ͜ʖ ͡°)
13:52:31 <saml> > let f x = case stripPrefox "bar" x of (Just a) -> a; Nothing -> "" in (f "barrrr", f "foooooo")
13:52:33 <lambdabot>      Not in scope: ‘stripPrefox’
13:52:33 <lambdabot>      Perhaps you meant ‘stripPrefix’ (imported from Data.List)
13:52:38 <saml> prefox
13:56:13 <xplat> > let f = foldMap id . stripPrefix in (f "barrrr", f "foooooo")
13:56:14 <lambdabot>      No instance for (Foldable ((->) [Char])) arising from a use of ‘f’
13:56:14 <lambdabot>      In the expression: f "barrrr"
13:56:14 <lambdabot>      In the expression: (f "barrrr", f "foooooo")
13:56:27 <obadz> Well reading the category theory definition of Monad, I see no ressemblance to the typeclass... Mind exploding again.
13:56:37 <xplat> > let f = foldMap id . stripPrefix "bar" in (f "barrrr", f "foooooo")
13:56:38 <lambdabot>  ("rrr","")
13:57:36 <xplat> obadz: Monad is usually defined with the type constructor (aka T), return (aka eta), and join (aka mu)
13:57:54 <obadz> xplat: how does join relate to bind ?
13:58:05 <xplat> @src join
13:58:05 <lambdabot> join x = x >>= id
13:58:24 <quchen> Monad is usually defined via >>= which is pointful Kleisli composition.
13:58:32 <arkeet> x >>= f = join (fmap f x)
13:58:52 <xplat> quchen: i meant Monad in category theory
13:59:25 <quchen> Oh, I just saw "Monad" capitalized, but it was at the beginning of a sentence.
13:59:37 <quchen> Apologies.
13:59:59 <obadz> arkeet / xplat - thx
14:00:25 <xplat> quchen: well, i don't always capitalize sentences, so the confusion was partly my fault
14:03:49 <obadz> you guys are very polite :)
14:12:27 <EvanR> i still havent tried to really study the category theory monad
14:12:46 <EvanR> monads are like a niche thing in haskell that often pisses me off
14:13:05 <Peaker> EvanR: why do they piss you off?
14:13:31 <EvanR> theyre not very composable, transformers suck
14:13:44 <Cale> I don't see why anyone would have an objection to the Monad typeclass getting used. There's obviously a fair amount we gain by recognising that certain libraries define monads
14:14:11 <Peaker> EvanR: I like transformers
14:14:12 <Cale> Monad transformers, sure, they kinda suck just because it's really easy to abuse them.
14:14:16 <Peaker> (most of the time)
14:14:20 <Cale> and a lot of people end up doing so
14:14:39 <Peaker> EvanR: it's not some artificial problem though, monadic composition is a "deep" issue
14:14:39 <Cale> They're not terrible, but I see more spurious applications of monad transformers than real ones.
14:15:04 <Cale> I don't understand why people are motivated to "compose" monads in the first place
14:15:21 <Peaker> Cale: to get features of multiple monads?
14:15:27 <EvanR> right, like "good OO design" is a "deep issue"
14:15:29 <koala_man> as opposed to what?
14:15:33 <Cale> Like, lists are a monad, parsers are a monad, why do you want lists of parsers to be a monad?
14:15:43 <Peaker> Cale: because I want a non-determinstic parser?
14:15:59 <EvanR> i dont want them to be a monad
14:15:59 <Peaker> (that's why I might want ParserT [], that is)
14:16:11 <EvanR> but i want to combine exceptions with some monad, maybe
14:16:33 <Cale> Peaker: Well, ParserT [] isn't lists of parsers.
14:16:39 <EvanR> the result doesnt have to be a monad
14:16:51 <Cale> Monad transformers aren't the same thing as composing monads.
14:16:52 <Peaker> Cale: well, it is a nice motivation to have a composition of monads :)
14:17:14 <Peaker> Cale: it's a workaround to lack of monad composition, though
14:17:16 <EvanR> or random number generator or other supply with some monad
14:17:42 <mniip> I wasn't a non-deteinistic stateful parser with an environment, an output stream,  and IO access, all that on top of continuations and with both descriptive and non-descriptive failures
14:17:45 <EvanR> or combine several different monads that use their own state 
14:17:55 <mniip> I want*
14:17:55 <dmj`> Cale: I'd like to know an example of the abuse of monad transformers
14:18:22 <Cale> dmj`: Pick a transformer from mtl/transformers which isn't ContT, and apply it to IO
14:18:25 <dmj`> Cale: is it more just that something can be just as easily expressed w/o a transformer
14:18:46 <EvanR> dmj`: or more easily
14:19:28 <dmj`> Cale: So ReaderT Config IO a, should just be Config -> IO a 
14:19:42 <Cale> dmj`: Usually I would agree with that, yes.
14:20:01 <mniip> putStrLn :: ReaderT IO String ()
14:20:22 <Cale> You pay heavily for ReaderT by forcing yourself to do lots of lifting, just to avoid passing around a parameter explicitly.
14:20:35 <Cale> and it's not like it makes the types any simpler, it clearly doesn't.
14:20:37 <Peaker> Cale: What about WriterT?
14:21:02 <Peaker> Cale: Threading around a parameter to *all* definitions is quite annoying, btw.  And the type *is* simple if it is just: foo :: MyMonad a
14:21:15 <EvanR> its usually not all definitions
14:21:38 <EvanR> just stuff that is configurable (with that particular config)
14:21:44 <hexagoxel> so what makes the ReaderT + IO combination special? the reasoning does not seem to mention IO.
14:21:48 <Cale> Yeah, it's usually not all definitions, and you usually end up writing liftIO many more times than you'd have written the parameter.
14:21:56 <Cale> At least in my experience.
14:22:04 <Peaker> Cale: I just have higher-level operations defined for MyMonad
14:22:12 <hodapp> This 'passing to all definitions' thing is why I want to learn to use the 'reflection' package that came from http://okmij.org/ftp/Haskell/tr-15-04.pdf 
14:22:14 <EvanR> for subconfigs, you wouldnt make a sub readerT for that sub config
14:22:14 <Peaker> Cale: Well, in my case it's not IO but ST s
14:22:21 <EvanR> but you could easily specialize the type
14:22:22 <Cale> hexagoxel: It's not entirely specific to IO, but IO has so many primitive operations that you need to liftIO
14:22:29 <EvanR> if it was just a parameter
14:22:31 <Peaker> hodapp: does the reflection package give you Reader.local though?
14:22:37 <hodapp> Peaker: I'm really not sure.
14:22:38 <Cale> and IO also has many higher order operations that the monad transformer interferes with
14:22:52 <hodapp> this just sounds like it's related to the "configurations problem" they mention
14:23:04 <Cale> Like, if you have a ReaderT, all of a sudden you have to jump through some hoops if you want to forkIO or use exceptions.
14:23:24 <Peaker> Cale: WriterT is super-annoying (and even error-prone) to thread around manually, btw
14:23:37 <EvanR> i like Writer
14:23:38 <Cale> Peaker: Well, in IO you have lots of options
14:23:42 <EvanR> i wish i could easily combine it with a monad
14:23:51 <Cale> Peaker: I tend to just pass around a function of type (a -> IO ())
14:23:57 * hackagebot EstProgress 0.3.0.0 - Methods for estimating the progress of functions  https://hackage.haskell.org/package/EstProgress-0.3.0.0 (JamesCandy)
14:23:59 <Peaker> Cale: what about listen/censor/etc?
14:24:00 <dmj`> Cale: so for StateT s IO b, just f :: s -> IO b, where f has a recursive loop passing the new state into itself on each iteration
14:24:21 <hodapp> hrpmh, I wonder why stack flips out when I change git branches and rebuilds everything
14:24:25 <EvanR> dmj`: thats even worse, use an IORef
14:24:26 <Cale> Peaker: Yeah, it depends on exactly what features of Writer you're using. I don't really use Writer all that much.
14:24:27 <Peaker> Cale: also, hackage has classes to handle the annoying contravariant-transformer issues (class for catching exceptions) as well as lifted-base for lifted IO operations, etc
14:24:32 <EvanR> dmj`: as many IORefs as you have state variables
14:24:48 <EvanR> instead of as many layers of StateT
14:25:32 <Cale> dmj`: You can explicitly pass parameters, you can use IORefs, you can also pass around functions/actions that internally read/write IORefs, but abstract the fact they're doing so.
14:25:37 <EvanR> Cale: what is the issue with transformers over IO and exceptions?
14:25:43 <Cale> EvanR: catch
14:25:45 <Cale> :t catch
14:25:46 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
14:25:55 <EvanR> oh dang
14:26:01 <Cale> You can't just easily liftIO that.
14:26:15 <Cale> There are convoluted solutions to managing that
14:26:27 <Cale> But I usually just prefer to avoid the transformer.
14:26:30 <Peaker> http://hackage.haskell.org/package/exceptions-0.3.1/docs/Control-Monad-Catch.html
14:26:39 <Cale> Unless the transformer is buying me something really valuable.
14:27:12 <Peaker> it's just closer to a nice DSL instead of nitty gritty threading around of stuffs
14:27:24 * shapr looks for rich transformers
14:27:44 <Cale> There are cases where you might say, "Oh, but I really want to be able to control which operations my computation has access to, and I don't want all of IO, so I want the mtl classes." -- but my counterpoint to that is that the mtl classes aren't very descriptive in general, and inventing your own classes (with an instance for IO) would usually be better.
14:27:50 <EvanR> i dont like imperative DSLs
14:28:12 <nitrix> Can someone explain to me what's happening here: http://ideone.com/XMi8mx ?
14:28:26 <dmj`> Cale: well then, when would you reach for transformers? I really like what monad-control, lifted-async afford me in web dev. Another issue is that a lot of haskell web frameworks force you into transformers
14:28:41 <EvanR> that sucks
14:28:50 <nitrix> Seems like a problem with kinds.
14:29:11 <shapr> Cale: do you avoid transformers with pipes?
14:29:24 <dmj`> except plain wai
14:29:26 <dmj`> type Application = Request -> (Response -> IO ResponseReceived) -> IO ResponseReceived
14:29:31 <Cale> shapr: Pipes is an example of a transformer which is really accomplishing something nontrivial
14:29:39 <Cale> So I'm okay with that.
14:30:19 <Cale> I'm just cautioning against jumping face-first into using ReaderT just to get a parameter to where you need it.
14:30:32 <Peaker> Cale: if I already have a newtype for my Monad everywhere
14:30:41 <Cale> Also, there are sensible places to use ReaderT
14:30:44 <Peaker> Cale: it's much easier/nicer to throw a ReaderT into it, than add a parameter to 30 locations
14:31:11 <EvanR> Peaker: a single custom monad with custom utility methods is better, and maybe its implemented with transformers, but i bet it would be easier without them
14:31:28 <Cale> and yeah, if you already have a nicely defined monad with a clear API, and you're putting ReaderT into its implementation in a way that your users don't have to care about, then fine
14:31:41 <Cale> That's what ReaderT is good for
14:31:51 <Peaker> EvanR: I usually implement my custom monad with transformers, and sometimes use a non-custom transformer (but only very locally)
14:32:08 * geekosaur didn't think `data` took non-* kinds...
14:32:13 <Peaker> EvanR: it's not easier to implement the monad manually -- I do it sometimes for performance reasons -- but it is ugly code duplication and it sucks
14:32:28 <geekosaur> if it can, probably need a kind signature
14:32:29 <EvanR> so is what you have to do to get 5 monad transformers together
14:33:07 <Peaker> geekosaur: data Fix f a = Fix (f (Fix f a)) ?
14:33:14 <dmj`> Cale: is it the internal 'complexity' or moreso performance considerations that bothers you
14:33:19 <Peaker> oops, forget the "a" :)
14:33:26 <geekosaur> hm
14:33:31 <dmj`> or both :)
14:33:51 <Cale> dmj`: It's just how the resulting code ends up looking and working. There are some performance considerations, but that's not what I really care about so much.
14:34:00 <Peaker> the fact that performance of transformers is worse than hard-coding the monad type and writing >>= manually means that GHC still has ways to go
14:34:10 <geekosaur> oh, wait
14:34:39 <geekosaur> partially applied type synonym. which in that situation actually should be fully applied, but I don't think ghc is smart enough to recognize it?
14:35:11 <Peaker> nitrix: a type synonym isn't a type-level function. You can't pass it not fully applied
14:35:21 <geekosaur> (that is, because Foo is fully applied Bar will be fully applied)
14:35:32 <rom1504> what's good for doing network in haskell ?
14:35:36 <geekosaur> (but ghc has only a few special cases to make that work, and otherwise just rejects them)
14:35:40 <Peaker> nitrix: I think there's an extension (LiberalTypeSynonyms or such?) that tries to allow it, but it ceases being a synonym and starts being more of a type-level function
14:35:46 <rom1504> is there something like js streams ?
14:36:20 <rom1504> (https://nodejs.org/api/stream.html)
14:37:08 <Peaker> geekosaur: it's not enough for it to be fully applied inside the data-type.. GHC needs to be able to type-check: Foo f1 a  vs.  Foo f2 a    f1=f2 is a non-trivial question when both can involve non-fully-applied synonyms, I think
14:37:36 <geekosaur> nitrix ^^
14:37:38 <dmj`> Cale: yea makes sense
14:38:08 <darenthis> rom1504: pipes seems nice: http://hackage.haskell.org/package/pipes-4.0.0/docs/Pipes-Tutorial.html
14:38:34 <afons> Why doesn't declaring multiple value constructors with the same name fail for different data types?
14:38:35 <afons> data Stuff = Joke deriving Show
14:38:36 <afons> data Man   = Joke deriving Show
14:38:45 <afons> sorry "Why does"
14:38:58 * hackagebot commutative 0.0.1 - Commutative binary operations.  https://hackage.haskell.org/package/commutative-0.0.1 (athanclark)
14:39:00 * hackagebot commutative 0.0.1.1 - Commutative binary operations.  https://hackage.haskell.org/package/commutative-0.0.1.1 (athanclark)
14:39:04 <geekosaur> because "Joke" is also the name of a function. what is the type of that function in your case?
14:39:16 <geekosaur> @src Maybe
14:39:16 <lambdabot> data Maybe a = Nothing | Just a
14:39:19 <geekosaur> :t Justr
14:39:20 <lambdabot>     Not in scope: data constructor ‘Justr’
14:39:20 <lambdabot>     Perhaps you meant ‘Just’ (imported from Data.Maybe)
14:39:20 <Cale> darenthis: pipes isn't specifically for networking on its own though.
14:39:21 <geekosaur> er
14:39:23 <geekosaur> :t Just
14:39:24 <lambdabot> a -> Maybe a
14:39:43 <quicksilver> afons: you can put them in different modules tho
14:39:43 <afons> geekosaur: that doesn't tell me anything. you could theorically distinguish both like Joke :: Stuff, Joke :: Man
14:39:48 <Cale> (it can be used to implement quite fancy networking libraries...)
14:40:11 <quicksilver> afons: just a design choice. Only one identifier in scope of a given name.
14:40:11 <Cale> I would usually shy away from introducing beginners to pipes/conduit
14:40:20 <geekosaur> "theoretically" yes. type directed name resolution has been discussed and discarded before; you lose a bunch of useful things in order to get it
14:40:39 <afons> quicksilver, that's really stupid, so you can have equal names for functions in instances of typeclasses, but not in value constructors?
14:40:43 <mizu_no_oto> What's the best library, at the moment, for writing a RESTful web service?
14:40:45 <quicksilver> afons: actually it's not stupid.
14:40:52 <geekosaur> https://wiki.haskell.org/TypeDirectedNameResolution
14:40:56 <afons> why is it not
14:41:02 <rom1504> darenthis: okay I'll look into that, thanks
14:41:03 <darenthis> Cale: true, it's more like clojures' core.async library
14:41:05 <Cale> One thing that I don't really understand is why the "Network" module is marked as deprecated, and people are supposed to be encouraged to use Network.Socket instead.
14:41:22 <geekosaur> because Network itself is deemed too simplistic
14:41:31 <quicksilver> afons: because unambiguous expressions are a nice property.
14:41:33 <dmj`> mizu_no_oto: I'd check out servant
14:41:34 <Cale> Network.Socket exposes all sorts of low level details which are often irrelevant
14:41:45 <quicksilver> you can disagree with that. You could prefer a different trade-off.
14:41:52 <quicksilver> but it isn't stupid.
14:41:57 <afons> quicksilver: that's not a valid argument, since there are multiple functions that are ambigous, read, readS
14:42:01 <quicksilver> it's just a choice that someone made.
14:42:13 <arkeet> read isn't ambiguous at all.
14:42:25 <afons> it's not because we add :: Stuff and it reads all good
14:42:27 <arkeet> it has this type: forall a. Read a => String -> a
14:42:27 <quicksilver> afons: there might be ambiguities in how they are type-checked in some circumstance but they are not ambiguous symbols.
14:42:30 <afons> why can't it be that way with value constructors?
14:42:32 <quicksilver> they are a single symbol.
14:42:43 <quicksilver> afons: it could be.
14:42:44 <afons> quicksilver: "there might", "some circumstance"
14:42:45 <quicksilver> it just isn't.
14:42:52 <afons> "it could"
14:42:59 <quicksilver> what you are suggesting is a possible way to design a language, afons.
14:43:02 <quicksilver> I'm not denying that.
14:43:08 <quicksilver> it just isn't the way this language was designed.
14:43:47 <afons> "possible"
14:44:01 <afons> I just want a logical reason
14:44:13 <afons> I don't think it's a matter of style preference
14:44:21 <quicksilver> I have given you the reason. The reason is that unambiguous terms is a desirable property.
14:44:21 <afons> there must be some deep meaning to this
14:44:32 <quicksilver> People like the idea that a single term refers unambiguously to a single thing.
14:44:43 <quicksilver> it doesn't have to be that way. But it is a property people chose to honour.
14:44:44 <Cale> afons: It's nice not to have to write type annotations everywhere.
14:44:52 <exio4> it makes things like type inference easier
14:44:54 <quicksilver> Other languages have chosen other approaches. Many things are possible.
14:45:09 <Cale> afons: If constructors have a well-specified type, it goes a long way toward helping type inference work.
14:45:09 <afons> Cale: repeated names would not be something you should do, it would rather be something it could support
14:45:56 <quicksilver> as geekosaur pasted the link it's something that has been seriously suggested for haskell and relatively recently.
14:46:03 <Cale> afons: You can define types in separate modules which define the same constructors, and disambiguate them using module qualification instead of types.
14:46:19 <Cale> I honestly kind of hate that as well :P
14:46:39 <Cale> I really like constructors to uniquely determine the type they're from, but it's a stylistic choice.
14:47:56 <Cale> The things which the language makes easy to do influences heavily the style of code written in it. If using the same constructor names at many types were allowed, people would do it. We'd probably even have to deal with some Henning Thielemann nonsense where someone names all his data constructors D.
14:48:58 * hackagebot varying 0.1.1.0 - Automaton based varying values, event streams and tweening.  https://hackage.haskell.org/package/varying-0.1.1.0 (SchellScivally)
14:49:00 * hackagebot diagrams-lib 1.3.0.3 - Embedded domain-specific language for declarative graphics  https://hackage.haskell.org/package/diagrams-lib-1.3.0.3 (BrentYorgey)
14:49:04 <quchen> It's great to import qualified, not so great if you don't have an IDE that desugars it.
14:49:37 <quchen> But then we're in "IDE provides a nice view or language is terribad" territory and that's copyrighted by Oracle.
14:54:53 <Peaker> quchen: better than that "oish my depth 8 transitive dependency broke because it imports Foreign and System.IO.Unsafe unqualified, and now 'unsafePerformIO' conflicts because it became a deprecation wrapper in one of them, and my package cannot build!
14:57:13 <obadz> quchen: which IDE desugars imports?
14:58:58 * hackagebot sets 0.0.1 - Various set designs in Haskell  https://hackage.haskell.org/package/sets-0.0.1 (athanclark)
15:09:37 <dzdcnfzd> Hey guys! I had a cool idea the other day, and now I'm trying to implement it. Basically, I want to make a DSL that will allow me to define basic SQL schemas without having to worry about many-to-one, one-to-many, and many-to-many stuff. I'm using the free monad and running into a bit of trouble. Here's my code, and errors: http://lpaste.net/138446
15:10:24 <dzdcnfzd> Basically, I want to encode into the DSL type that only one set of statements can follow a table declaration
15:11:04 <dzdcnfzd> But I don't understand how to get around this type thing. And I know that, fundamentally, the problem is I don't quite understand how I'm supposed to work with the Free monad in this instance, so that's where I'm asking for help
15:13:59 * hackagebot sets 0.0.1.1 - Various set implementations in Haskell  https://hackage.haskell.org/package/sets-0.0.1.1 (athanclark)
15:17:03 <johnw> dzdcnfzd: that shouldn't be "Declaration next", that's not what the type variable means there
15:17:38 <johnw> SQLDSLF will need to reference (DeclarationF next)
15:18:13 <johnw> or, SQLDSLF a next = DeclareTable String (Declaration a) next
15:18:18 <johnw> whichever has the meaning you intend
15:20:08 <dzdcnfzd> johnw: The intention is that, following a DeclareTable statement, you have to specify the name of a table and then make a full table declaration
15:20:26 <dzdcnfzd> and the full table declaration is given by the DeclarationF type
15:20:53 <johnw> ok, then the latter thing I mentioned, where 'a' is the result value from the declaration, or just use Declaration ()
15:20:57 <dzdcnfzd> The interpreter will deal with ensuring 
15:21:07 <dzdcnfzd> yeah! Check the code again and tell me if what I have makes sense
15:21:10 <johnw> but the free monad always results in a Pure value
15:21:14 <dzdcnfzd> (If you please :) )
15:21:20 <johnw> right
15:21:28 <johnw> now just on lines 64 and 65, rename 'next' to 'a'
15:21:39 <johnw> and add type signatures for all your functions
15:23:02 <dzdcnfzd> Okay. And it would probably make sense to redefine the type aliases for SQLDSL and Declaration to make it clear that next is ()
15:23:06 <dzdcnfzd> which I think it is?
15:23:15 <johnw> no, it's not
15:23:27 <johnw> the type variable in *that* case is whatever Pure is going to return
15:23:40 <johnw> it's not the recursor argument, which is implicitly passed to the first argument of Free
15:23:43 <dzdcnfzd> It isn't? But I have no statements to return, I thought
15:23:59 * hackagebot json-rpc 0.7.0.0 - Fully-featured JSON-RPC 2.0 library  https://hackage.haskell.org/package/json-rpc-0.7.0.0 (XenoGenesis)
15:24:06 <johnw> in general, users of your DSL need to be free to use "return x" for any x they choose
15:24:19 <johnw> even if you yourself always terminate with ()
15:24:44 <dzdcnfzd> I see. Is there any reason why I shouldn't disallow that sort of behavior?
15:24:51 <dzdcnfzd> Even if it doesn't make any sense?
15:24:58 <johnw> wait before disabling it
15:25:13 <johnw> it may make sense in ways you're not expecting
15:25:22 <dzdcnfzd> Okay
15:26:24 <dzdcnfzd> why rename "next" to "a"?
15:26:28 <dzdcnfzd> what does that do?
15:26:31 <dzdcnfzd> on 64
15:26:33 <johnw> because the meaning is different from 'next' up above
15:27:10 <dzdcnfzd> Can you explain what you mean, because I think this is one of my fundamental misunderstandings
15:27:26 <johnw> so, you have Free f a
15:27:30 <johnw> where f must be a functor
15:27:54 <johnw> the type agument to f is going to be 'next', while the type argument to 'Free f' is 'a'
15:28:06 <johnw> this way, you can go Free f a -> f a
15:28:23 <johnw> by performing the recursion in an evaluator, and replacing all the 'next' points with 'a'
15:28:28 <mniip> guys
15:28:37 <mniip> I just made a monad transformer transformer
15:28:47 <johnw> mniip: show the type!
15:28:54 <mniip> the kind?
15:29:01 <johnw> show me the transformer you made
15:29:10 <mniip> a useless transformer to be fair :)
15:29:12 <mniip> data MuT t a = MuT { runMuT :: t (MuT t) a }
15:29:53 <mniip> so far the only interesting structure I've found is MuT (ReaderT e)
15:30:12 <mniip> which is roughly isomorphic to e -> e -> e -> ...
15:31:18 <mniip> about an hour ago people were talking about transformer abuse, and useless side effect combinations
15:31:22 <johnw> Free ((->) e) a would be e -> e -> ... e -> a
15:31:28 <monochrom> dzdcnfzd: I wonder if this helps. "Free SQLDSLF a" means "(Free SQLDSLF) a" not "Free (SQLDSLF a)"
15:31:34 <mniip> so I thought, why not apply a sideeffect infinitely :)
15:32:07 <mniip> johnw, that's because Free is a sum type
15:32:13 <johnw> yeah, true
15:32:13 <mniip> it has a base for recursion
15:32:20 <dzdcnfzd> monochrom: yes!
15:32:23 <dzdcnfzd> beautiful!
15:32:29 <johnw> so, you're going to ReaderT e (ReaderT e (ReaderT e ...)) a
15:32:32 <johnw> going for*
15:32:42 <johnw> infinite recursion of the underlying monad
15:32:56 <mniip> yeah
15:33:23 <dzdcnfzd> monochrom: I just got that, thanks so much!
15:33:34 <dzdcnfzd> johnw: Thank you too so much! Gonna try to make this work...
15:33:56 <afons_> I am making a snake game, how do I detect input in haskell, say, for the upper arrow?
15:34:55 <mniip> johnw, looking at StateT
15:35:14 <johnw> monochrom: good catch
15:35:23 <mniip> s -> (s, s -> (s, s -> (s, ...)))
15:35:55 <mniip> hmm no
15:36:43 <monochrom> :)
15:37:23 <afons_> How do I listen for keys in haskell?
15:37:27 <afons_> To respond when they are pressed?
15:38:10 <dmj`> afons_: for a thread that listens on stdin, put a message on a chan to manipulate some shared state 
15:38:18 <mniip> s -> s -> s -> ... ((...(a, s), ... s), s)
15:38:23 <afons_> I am not that advanced
15:38:25 <subleq> afons_: http://book.realworldhaskell.org/read/io.html#io.buffering
15:38:27 <afons_> Oo
15:38:31 <dmj`> afons_: getChar
15:38:35 <dmj`> :t getChar
15:38:36 <lambdabot> IO Char
15:38:43 <mniip> johnw, my mind is melting down
15:38:46 <subleq> afons_: you can just use hGetChar on a handle without buffering
15:38:52 <afons_> getChar?
15:38:57 <afons_> that doesn't work for shift keys..
15:38:58 <afons_> arrows
15:40:11 <mniip> johnw, do you know of any monad transformer which is neither of the form 'm ...' nor 'a -> m ...'
15:40:14 <geekosaur> you're not going to get shift keys as such without using a GUI
15:40:20 <nullvoid8_> afons_: depending on what you're ultimatly making, maybe look into the GLFW-b package?
15:40:26 <subleq> afons_: it does work for arrows keys, terminals use escape sequences to encode them
15:40:38 <subleq> afons_: if you want more than that you're probably going to have to use something like curses
15:40:38 <geekosaur> as for arrows, in a terminal they will look something like <ESC> [ A
15:40:42 <afons_> I need to listen for keys such as shift keys, arrows keys in the terminal.
15:40:50 <johnw> mniip: ContT
15:40:52 <geekosaur> you can't get he shift key in a terminal
15:40:56 <mniip> ohh
15:40:57 <geekosaur> the terminal will not send it
15:41:08 <afons_> My game logic -> Print stuff -> wait for keys -> clear -> print stuff repeta
15:41:09 * mniip prepares for brain matter sublimation
15:41:11 <afons_> repeat*
15:44:44 <mniip> z = (a -> z) -> z
15:45:39 <nullvoid8_> mniip: wat
15:46:23 <nullvoid8_> (I was reading the context, but I can't grok this one at all)
15:46:43 <mniip> me neither actually
15:47:02 <mniip> (a -> (a -> (a -> ...) -> (a -> ...)) -> (a -> (a -> ...) -> (a -> ...)) -> ...) -> a -> (a -> ...) -> (a -> ...)) -> (a -> (a -> ...) -> (a -> ...)) -> ...
15:47:06 <mniip> if that makes more sense
15:47:30 <nullvoid8_> I think you can get rid of 99% of those brackets can't you?
15:47:48 <monochrom> are you trying to define "newtype Z a = Ztor ((a -> Z a) -> Z a)" ?
15:48:02 <grayen> How can I resolve the overlapping instances when using a type family? Here is an example of what I mean: http://pastebin.com/hZAVHJav
15:48:24 <nullvoid8_> monochrom: read back ~20 minutes
15:49:04 <mniip> basically a function
15:49:05 <mniip> that can take infinitely many copies of itself as an argument
15:49:23 <mniip> monochrom, no, I'm trying to figure out what the hell is a MuT ContT
15:49:35 <grayen> Is it even possible to resolve them in this case? It should be no more ambiguous then the call in main, since I am using a closed type family.
15:50:37 <mniip> monochrom, you gotta look at MuT
15:50:45 <mniip> it's pretty boring and interesting simultaneously
15:53:03 <exio4> where is it defined?
15:53:28 <afons_> Can I make comments inside the ghc file ?
15:53:34 <monochrom> mniip: may I replace "data" by "newtype"?
15:53:39 <mniip> exio4, a few lines above in the IRC
15:53:40 <afons_> Something like :set +m -- allows multiline
15:53:41 <mniip> monochrom, sure
15:53:51 <monochrom> newtype MuT t a = MuT { runMuT :: t (MuT t) a }
15:54:07 <mniip> non-sum non-product type, should be a newtype, yes
15:54:11 <geekosaur> afons_, ? -- starts a comment to end of line, {- ... -} is a comment that can span lines
15:54:23 <afons_> I mean inside the ghci file
15:54:27 <afons_> .ghci
15:54:49 <geekosaur> hm. ghci's kinda dumb :/
15:54:50 <afons_> Or does it work the same?
15:54:58 <afons_> is there a way
15:55:30 <geekosaur> :ste at least doesn't seem to support it
15:55:33 <geekosaur> er :set
15:55:37 <geekosaur> like i said, it's kinda dumb
15:56:14 <monochrom> @unmtl StateT Int IO a
15:56:14 <lambdabot> Int -> IO (a, Int)
15:56:35 <afons_> geekosaur, is there a way to make a :def such a way that it doesn't do anything?
15:57:08 <geekosaur> no idea, sorry
15:57:13 <geekosaur> I don't much mess with :def
15:57:20 <exio4> mniip: I fail to see how that is a monad transformer? 
15:57:24 <SrPx> Is there the opposite of Foldable class? I.e., a way to transform a list back to the original value? A parser, I guess.
15:57:30 <mniip> exio4, it's a monad transformer transformer
15:57:41 <afons_> I want to be able to use comments inside the ghci file
15:57:46 <exio4> ok then
15:57:50 <afons_> So I was wondering if there was a way to create a command that wouldn't output anything
15:57:54 <mniip> it finds the fixpoint of a transformer over the transformed monad
15:57:58 <afons_> Can anyone help me with this?
15:58:00 <afons_> please?
15:58:46 <mniip> is there a "nice" way to map 'data Kind = Star | Kind -> Kind' to a string?
15:59:00 <mniip> I mean naming convention wise
16:00:08 <mniip> I've seen some places go * = 0, *->* = 1, *->*->* = 2, however that tells nothing about (*->*)->* or the like
16:01:45 <exio4> mniip: define it as l(k -> k1) = 1 + l(k1) ; l (*) = 0 ?
16:01:58 <mniip> but that doesn't use k
16:02:22 <mniip> I need something that matches up with your definition, but that can handle actual trees fine
16:03:54 <monochrom> @unmtl ContT r (MuT (ContT r)) a
16:03:54 <lambdabot> (a -> (MuT (ContT r)) r) -> (MuT (ContT r)) r
16:04:06 <dzdcnfzd> Another thing I can't get through:
16:04:07 <dzdcnfzd> http://lpaste.net/138449
16:05:10 <monochrom> it is not exactly "Z = (a -> Z) -> Z". instead, it is "Y a = (a -> Y r) -> Y r"
16:07:10 <dzdcnfzd> I'm going to rework it to make the errors easier to follow, one sec
16:08:11 <dzdcnfzd> There, edited
16:11:01 <wagle> is there ghc (or haskell) for the ipad?  google isnt helpful
16:13:41 <dzdcnfzd> Gah! Silliness. This is what comes of staring at type declarations for too long! I was capitalizing functions I shouldn't have been
16:14:08 <cdsmith> Woohoo, I'm officially going to ICFP!
16:14:35 <wagle> gz!
16:14:44 <johnw> cdsmith: nice, maybe see you there
16:15:32 <cdsmith> Sadly, I am not able to stay for the Haskell Symposium, which looks more fun...
16:21:14 <tac-tics> If I want to nuke all the packages installed at user-level by cabal, what do I do?
16:21:41 <johnw> rm -fr ~/.ghc ~/.cabal/lib
16:23:53 <tac-tics> thanks
16:30:09 <SrPx> How do you define head in terms of foldr?
16:30:28 <hpc> > foldr const undefined [1..]
16:30:29 <lambdabot>  1
16:30:33 <SrPx> That is, intuitively it would be "head = foldr (\ head tail -> head) undefined", but...
16:30:35 <SrPx> ......
16:30:43 <hpc> lol
16:31:00 <hpc> > foldr (+) z [1..] :: Expr
16:31:01 <lambdabot>  1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + (11 + (12 + (13 + (14 + (1...
16:31:36 <hpc> SrPx: welcome to haskell, where if it typechecks it's probably right
16:32:04 <SrPx> No, that is the point, that isn't typechecking here. I'm probably doing something really stupid, brb
16:32:23 <hpc> monomorphism restriction?
16:38:11 <mniip> monochrom, so
16:38:12 <SrPx> Well I give up, this is what doesn't work: http://lpaste.net/138452 any idea?
16:40:28 <johnw> SrPx: your type synonym is wrong
16:40:34 <johnw> it only allows returning tails
16:40:46 <tommd> SrPx: It appears straight forward - am _I_ missing the complexity?  `h -> t -> t vs \h t -> h`
16:40:47 <mniip> (a -> (b -> (c -> (d -> ...) -> ...) -> (d -> ...) -> ...) -> (c -> (d -> ...) -> ...) -> (d -> ...) -> ...) -> (b -> (c -> (d -> ...) -> ...) -> (d -> ...) -> ...) -> (c -> (d -> ...) -> ...) -> (d -> ...) -> ...
16:41:19 <johnw> type List a = forall r. (a -> r -> r) -> r -> r
16:41:32 <johnw> now you can write List a -> a
16:43:04 <SrPx> Makes sense. Thank you!
16:43:32 <cow_2001> > fix ("a"++)
16:43:33 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
16:43:37 <cow_2001> > fix (++"a")
16:43:41 <lambdabot>  mueval-core: Time limit exceeded
16:43:47 <hpc> lemme get that for you
16:43:49 <hpc> > fix error
16:43:50 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
16:43:52 <hpc> oops
16:43:53 <cow_2001> O_O
16:43:56 <geekosaur> heh
16:44:01 <cow_2001> heh
16:44:33 <mniip> > fix exception
16:44:34 <lambdabot>      Ambiguous occurrence ‘exception’
16:44:35 <lambdabot>      It could refer to either ‘L.exception’, defined at L.hs:153:1
16:44:35 <lambdabot>                            or ‘Control.Exception.Lens.exception’,
16:44:39 <cow_2001> PLEASE ENJOY YOUR FUN FIX WITH #HASKELL
16:44:40 <mniip> screw you
16:44:45 <hpc> jokes aside, understanding that expression is a pretty good test of how well you know fix
16:45:07 <geekosaur> and perhaps how you understand haskell evaluation in general
16:45:10 <mniip> hpc, it's obvious
16:45:23 <cow_2001> nothing is obvious D:<
16:45:23 <hpc> it is, but so is fix
16:45:32 <hpc> "obvious" stuff can be the hardest shit to get in haskell
16:45:33 <monochrom> everything is obvious
16:45:44 <hpc> because it looks so weird that you never consider the easy explanations
16:45:46 <mniip> 'error x' evaluates x during error reporting
16:46:10 <pacak> fix has no real use, it's just there so you can type fix error in ghci and feel good about yourself
16:46:20 <johnw> fix does in fact have a real use
16:46:30 <hpc> fix lets you write recursive functions that have no name
16:46:34 <johnw> yep
16:46:36 <johnw> recursive lambdas
16:46:41 <cow_2001> i've seen it used in some Arrow instance definition
16:46:41 <hpc> let foo = (whatever with foo)
16:46:42 <johnw> fix $ \f x -> .... f x ...
16:46:44 <hpc> translates to
16:46:52 <hpc> fix $ \foo -> (whatever with foo)
16:47:05 <mniip> hpc, well technically
16:47:12 <mniip> letrec is not exactly a fix invocation
16:47:35 <hpc> save it for #ghc, nerd!
16:47:39 <geekosaur> cow_2001, do you understand why your two tests did what they did?
16:47:47 <hpc> ;)
16:47:51 <cow_2001> geekosaur: nope
16:48:01 <cow_2001> geekosaur: i'll look the fix definition, sec
16:48:08 <cow_2001> look at
16:48:10 <geekosaur> that may not help :)
16:48:15 <mniip> fix f = f (fix f)
16:48:25 <mniip> that's all you need to know
16:48:27 <geekosaur> > head (1 : undefined)
16:48:28 <lambdabot>  1
16:48:29 <cow_2001> nope, no clue
16:48:31 <hodapp> hpc: you're such a nerd you use Haskell >:O
16:48:38 <Fylwind> does anyone know when Cabal moved from storing packages in /lib/packagename-version to /lib/packagekey-version ?
16:48:39 <cow_2001> oooh, it's the ++ defintion
16:48:49 <monochrom> cow_2001: http://www.vex.net/~trebla/haskell/fix.xhtml
16:48:52 <mniip> hodapp, there is a nerdness hierarchy inside nerds too
16:48:54 <pacak> @src fix
16:48:54 <lambdabot> fix f = let x = f x in x
16:49:01 <hpc> (in a few years, you'll learn that it matters that the actual definition is fix f = let x = f x in x)
16:49:02 <cow_2001> (++) = ... uh...
16:49:03 * hackagebot hoopl 3.10.2.0 - A library to support dataflow analysis and optimization  https://hackage.haskell.org/package/hoopl-3.10.2.0 (NingWang)
16:49:09 <pacak> let is there to make it faster
16:49:12 <hodapp> mniip: that sounds like something a nerd would say!
16:49:16 <numberten> why is 'let a-b = 1' valid in ghci?
16:49:16 <mniip> hpc, I'll let GHC do the CSE
16:49:19 <hpc> pacak: not faster, it ties the knot
16:49:32 <geekosaur> numberten, it is defining a local version of (-)
16:49:42 <numberten> geekosaur: thanks
16:49:42 <monochrom> numberten: because it is valid to define binary operators in ghci
16:49:47 <numberten> makes sense
16:49:47 <cow_2001> (x:xs) ++ b = x : (xs ++ b)
16:49:54 <pacak> hpc: You can implement it as f (fix f), but with let there are more sharing
16:50:07 <geekosaur> cow_2001, the answer is in there if you think about it
16:50:10 <mniip> hmm
16:50:19 <mniip> yeah, evaluation semantics wise these are different
16:50:37 <cow_2001> so you unpack the left argument and leave the right one be
16:50:53 <hpc> pacak: indeed, which isn't necessarily faster, but totally changes memory characteristics
16:50:56 <hpc> (in ghc)
16:51:05 <monochrom> (and in hugs)
16:51:23 <pacak> hpc: Still waking up. Words are hard.
16:51:27 <hpc> until you go and ruin it by using the data in most ways you can use data
16:51:34 <hpc> for instance, (map id)
16:51:50 <mniip> one is a closure that passes itself as an argument, another is a closure that closes 'fix' obtaining a closure identical to itself, albeit still a new closure
16:51:52 <cow_2001> fix ("a"++) = fix \b -> ('a' : ([] ++ b))?
16:52:01 <monochrom> welll, to be fair, "map id" creates new data, not change existing data.
16:52:20 <hpc> monochrom: it's a use of the data ;)
16:52:49 <hpc> point is knots are invisible and vanish easily
16:52:58 <geekosaur> more specifically, it's producing a partial result which in non-strict evaluation can be returned to the caller before the recursive part is evaluated. so it produces ('a' : fix ("a" ++)). then the recursion produces another ('a' : fix ("a" ++)). etc.
16:53:30 <cow_2001> fix (++"b") = fix \(a:as) -> (a : (as ++ "b"))?
16:53:36 <geekosaur> which means you get an infinite stream of 'a':'a':... before it ever hits the part that would make it time out or crash
16:54:29 <geekosaur> with the second one, it can't produce a result until it evaluates fix (++ "b") which can't produce a result until it evaluates fix (++ "b") which ... the deadly recursion occurs before it can produce anything
16:54:30 <monochrom> https://ro-che.info/ccc/9
16:56:40 <cow_2001> okay, reading this YOU COULD HAVE INVENTED FIX page
17:00:03 <monochrom> cow_2001: did you know: we have re-allowed colour codes in this channel for a while. and so, you don't always have to use capital letters. you have more choices. for example: you could have invented fix
17:01:32 <hpc> amazing colors like 06green and 02orange
17:01:48 <hpc> monochrom: not sure what kind of color codes you're using
17:01:57 <monochrom> that one is italics
17:02:18 <hpc> weird, all i see is inverted ][ with plain text inside
17:02:35 <hpc> probably terminal stuff
17:02:46 <monochrom> probably fewer clients support italics
17:03:01 <monochrom> do you see underline?
17:03:12 <Lokathor> hexchat shows underline
17:03:31 <hpc> i see underline
17:03:38 <cow_2001> i don't know how to colour my stuff
17:03:44 <hpc> inverted text is what i see for bold
17:03:49 <cow_2001> let me google that for me
17:03:50 <hpc> holy crap, it works now
17:03:54 <hpc> hmm
17:04:27 <cow_2001> 1poop
17:04:27 <hpc> not sure if putty or irssi
17:04:30 <cow_2001> :D
17:05:46 <cow_2001> to boldlygo
17:05:48 <cow_2001> err
17:06:00 <monochrom> yes it's bold
17:06:11 <cow_2001> to boldly go where no bald had gone before
17:06:19 <hpc> to ly go where no man has 410 before
17:06:33 <cow_2001> ??
17:06:44 <hpc> (bold "ly", 410 gone)
17:07:13 <cow_2001> huh
17:07:31 <cow_2001> doomlord O_O
17:07:43 <Lokathor> so many split infinitives
17:07:52 <doomlord> what
17:07:54 <Lokathor> and at least i now know what an infinitive is, thanks esperanto!
17:08:01 <cow_2001> your nickname is very D&D
17:08:08 <Lokathor> me?
17:08:13 <hpc> Lokathor: only you can put the infinitives back together again
17:08:16 <cow_2001> doomlor's
17:08:19 <hpc> and form the infinitive gauntlet
17:08:32 <Lokathor> yeah i'm pretty sure that'll make for a pretty downer movie
17:08:44 <hpc> with it you would be more powerful that strunk and white combined!
17:08:52 <doomlord> its a very sad early 1980s comic book reference sorry
17:10:12 <hpc> so i had an adventure in win32
17:10:22 <hpc> it was very C-like and i think i will continue
17:10:36 <hpc> i accidentally captured the windows key though
17:11:06 <Lokathor> i tried to compile a cpp "hello world" OGL program one time
17:11:24 <Lokathor> but it required like 3 libraries and i couldn't figure out how to invoke visual studio or G++ properly, so i gave up
17:12:23 <hpc> i failed pretty hard at opengl before
17:12:40 <hpc> could probably do better now, but i know how bad the docs are for it and no thank you
17:12:57 <Lokathor> i've just grown too fat and lazy from cabal and maven
17:13:06 <Lokathor> if i don't have a build manager handling it all for me i fall over
17:13:07 <hpc> msdn is a lot like javadoc, very thoroughly automated and when people actually write anything themselves it's perfect
17:14:15 <hpc> the big benefit to win32 is that it comes with base
17:14:32 <hpc> so you don't have to do the 9-hour dance of desperation and sacrifice a goat to SDL
17:15:35 <Lokathor> sdl2 isn't so hard to setup once you get the hang of it
17:16:08 <hpc> yeah, i was all out of hangs the other day
17:16:27 <hpc> next time will probably be easier
17:16:53 <hpc> after how far windows has fallen in terms of UX, my next box will be linux
17:16:56 <Lokathor> i never actually did much in terms of the tutorial, but i wrote down pretty well how to get sdl2 installed on windows https://github.com/Lokathor/sdl2-tutorial
17:17:15 <hpc> (which is saying something, i have never gotten a GUI on linux to work to my satisfaction)
17:24:32 <duckbob> Hi guys, I was trying to work with Aeson to read nested Json data, but failed... heres the paste, can anyone have a look at this for me? http://lpaste.net/138457
17:25:04 <mniip> has anyone approached the lifted typeclass madness in the past?
17:25:28 <Lokathor> duckbob, do you mean that you have json data that contains more json inside of it?
17:25:51 <duckbob> Lokathor of the form {"a":1,"b":{"c":{"d":"hello","e",2}}}
17:26:19 <mniip> I mean like, Data.Functor.Classes but more general
17:26:19 <Lokathor> you don't need to make any special instance for that, if you want to convert it into a json Value
17:26:39 <Lokathor> (note the capital V, "Value" is a type they've got)
17:27:07 <duckbob> yes but they are hard to access, check out the paste, im sure im close...
17:27:18 <SrPx> Hey I thought `\ a -> f (g a)` could always be rewrote as `f . g`, but seems like that isn't the case here: http://lpaste.net/138458
17:27:34 <SrPx> rewritten
17:27:39 <mniip> I've seen edwardk generalize EqN/ShowN/... into a single LiftingN
17:27:39 <mniip> but still that only gives us linear kinds (*, *->*, *->*->*, ... *->...->*)
17:27:53 <mniip> I have some kind of solution in my mind but I can't figure it out
17:27:55 <duckbob> because its nested i dont know how to define the accessors as lower case set methods of my datatype...
17:28:19 <duckbob> also i need to make a datatype which represents data of this format which can be made instances of other classes
17:28:22 <geekosaur> SrPx, I think that's because the (.) version requires ImpredicativeTypes? which tends to not work anyway
17:28:23 <Lokathor> well, depending on what you need, you can use the lens library to adjust things once they're parsed
17:28:33 <Lokathor> i did this a few months ago https://github.com/Strifepad/StrifeServer/blob/master/src/Strife/Server.hs
17:28:39 <geekosaur> rank-N types are Difficult
17:28:55 <mniip> something like reusing 'Show' as the base case for the * kind, and defining another typeclass for the k->l kind
17:29:08 <mniip> which will be the induction step
17:29:25 <duckbob> Lokathor: Im not sure 
17:29:52 <Lokathor> duckbob, the lookup, eitherJsonFromText, and tryUpdate functions are what you might want to take a look at
17:29:58 <duckbob> yes you use AEP...
17:30:03 <Lokathor> all near the bottom of the page
17:30:12 <mniip> and something about passing constraints as arguments to constraints
17:30:32 <SrPx> geekosaur: wait isn't that really bad? I thought being able to rewrite equivalent expressions was regarded as the most sacred feature of haskell
17:30:50 <duckbob> Lokathor: just to clarify, my problem is that im trying to use this haskell built in data accessors beond what they are capable of and must use a lens?
17:31:05 <geekosaur> as long as you stick to actual Haskell, sure. rank-N types break that and a bunch of other things (like type inference)
17:31:26 <geekosaur> which is why they're an extension that is off by defaulr
17:31:29 <geekosaur> *default
17:31:51 <Lokathor> duckbob, the problem is nested data structures in haskell, which the lens library does a lot to make easier. there's some videos on it around the web, and you should really look into the lens library if you're doing anything with complex data structures in haskell
17:32:17 <duckbob> no worries, im using applicative already...
17:32:29 <geekosaur> (and is also why people have been banging their heads against ImpredicativeTypes for years, because if they could figure out how to make it work, well, you still wouldn't have type inference but at least that case would have some chance of working)
17:33:34 <SrPx> I see. That is really disappointing...
17:33:55 <duckbob> Lokathor: a really neat introduction to lenses for me would be if you showed me how to access this data type with a lens, i think it provides a pretty comprehensive way of parsing json... it could be super useful... 
17:34:05 * hackagebot base-orphans 0.4.3 - Backwards-compatible orphan instances for base  https://hackage.haskell.org/package/base-orphans-0.4.3 (ryanglscott)
17:35:08 <Lokathor> duckbob, well, the "lookup" function i have here accesses a location within a collection of nested json hashmaps, naming each key separated by a .
17:35:29 <duckbob> awesome
17:35:35 <Lokathor> it gets used on line 186, "failover (lookup (T.unpack path)) (\_ -> val) (Object (_object server)) :: Maybe Value"
17:36:34 <Lokathor> so it gets the path, such as "bob.height", goes to the bob value, goes to its height value, and then ignores the current value and sets a new value
17:37:05 <Lokathor> the whole thing gets repacked up by the failover function (which is part of the lens library) and then you have your new JSON value
17:38:56 <mazur> is there a function or module for the Linear package that calculates the rank of a 3x3 matrix?
17:39:42 <duckbob> what is the key function?
17:40:24 <Lokathor> duckbob, https://vimeo.com/56063074 is the video you might want where the lens creator goes over the whole thing (it is 2 hours though)
17:41:09 <duckbob> yeh, i watched that already
17:42:12 <duckbob> sometimes i find these things overwhelming. but i learn really fast by repetition. if i have a working example i can addapt it well, but i struggle to translate other peoples much less simple code...
17:42:32 <Lokathor> yeah, same
17:42:56 <Lokathor> i didn't even write "lookup" :P the lens guy did when i asked him how to look within nested hashmaps
17:43:24 <duckbob> haha, is that really how this is going! 
17:43:57 <Lokathor> I'm afraid i haven't actually programmed in haskell in several months, and that part of the program in longer still
17:44:03 <Lokathor> so i'm not sure i can be much more help
17:45:00 <duckbob> could you show me how to use it for my simple example in this paste? http://lpaste.net/138460
17:45:23 <Lokathor> sure
17:45:24 <Lokathor> 1 moment
17:46:27 <duckbob> Lokathor: thanks!
17:49:30 <benzrf> is there a way to get cabal-install to let me edit the source before it compiles it so that i can fix an erorr
17:49:32 <benzrf> :|
17:50:07 <Lokathor> you can use cabal to get the package source, modify that, and then run install after you change it?
17:50:22 <duckbob> benzrf yes, you can download the source, edit it and then run cabal configure, cabal build, cabal install
17:50:29 <benzrf> :I
17:50:34 <Lokathor> "cabal fetch" is what you probably want
17:50:37 <benzrf> ah, thanks!
17:50:40 <benzrf> was about to ask (:
17:51:03 <Lokathor> "cabal --help" explains more, you might want "cabal get", i'm not clear between the two
17:54:39 <SrPx> geekosaur: does this basically mean system-f isn't powerful enough to encode church lists? 
17:57:16 <lpaste_> Lokathor revised “lens json incomplete”: “duckbob I added some notes” at http://lpaste.net/138460
17:57:34 <duckbob> thanks!
17:57:47 <Lokathor> it gives back a Maybe Value
17:58:04 <Lokathor> Just if it found the location you specified, or Nothing if you ended up specifying a location it couldn't find
17:59:06 <duckbob> Lokathor: should the Objects contain Strings?
17:59:46 <Lokathor> an Object can contain any other data type, but the lookup path can only go "though" a sub-object, if that makes sense
17:59:54 <duckbob> lookup "b.c" == the entire Object {"d":"hello","e":2}
18:00:08 <duckbob> that object should contain a String?
18:00:29 <Lokathor> "b.c" could be a string, yes, but "b" must be an object
18:00:31 <duckbob> "{\"d\":\"hello\",\"e\":2}"
18:01:00 <Lokathor> oh, no, sorry, you should use it on a value that's been parsed using Aeson
18:01:03 <Lokathor> not on a string
18:01:07 <duckbob> lookup "b.c" == Object "{\"d\":\"hello\",\"e\":2}"
18:01:58 <duckbob> its ok i get it, so i could return that type and access it with the .:
18:02:09 <Lokathor> yes
18:02:25 <duckbob> no sorry, with the lens accessor function which i think is ^-
18:02:38 <dramforever> ^.
18:02:39 <Lokathor> i'd play around with it a lot in ghci, and you'll get used to it
18:03:09 <duckbob> i dont know what to do with a Value, i thought this was my original problem...
18:03:18 <benzrf> Lokathor: cabal-get doesnt exist:\
18:03:30 <Lokathor> no dash
18:03:32 <Lokathor> cabal get
18:03:34 <duckbob> cabal get ?
18:03:45 <duckbob> sorry.. slow
18:03:55 <benzrf> ye i know
18:03:57 <benzrf> meant that
18:04:01 <benzrf> aha, fetch then unpack
18:05:37 <duckbob> apparently lookup returns when passed a String, what you are calling an object, of type (Value -> f Value) -> Value -> f Value
18:05:48 <duckbob> Object*
18:06:43 <duckbob> but also lookup "a" == 1
18:06:47 <Lokathor> when i say Object
18:07:08 <Lokathor> i mean the Ason library Object constructor of the Value type
18:07:39 <Lokathor> https://hackage.haskell.org/package/aeson-0.9.0.1/docs/Data-Aeson.html#t:Object
18:09:14 <duckbob> > failover (lookup "a") (+1) "{\"a\":1,\"b\":{\"c\":{\"d\":\"hello\",\"e\":2}}"
18:09:15 <lambdabot>      Couldn't match type ‘Maybe Integer’ with ‘[Char] -> (Any, t)’
18:09:15 <lambdabot>      Expected type: Over (->) ((,) Any) [Char] t Integer Integer
18:09:15 <lambdabot>        Actual type: [(Any, Integer)] -> Maybe Integer
18:09:57 <Lokathor> you can't pass a string into that, it won't type check, you have to use a Value, which you get by parsing the string with the Aeson library
18:11:24 <duckbob> i would normally do that by creating an instance of FromJSON
18:11:29 <numberten> is there a way to make newtypes inherit typeclasses from the type they wrap?
18:11:37 <johnw> numberten: GeneralizedNewtypeDeriving
18:11:41 <numberten> thanks :)
18:11:50 <johnw> then name the type classes you want to inherit
18:11:55 <johnw> deriving (Foo, Bar, Baz, Etc)
18:12:00 <johnw> you can specify arguments too
18:12:04 <johnw> deriving (MonadReader r)
18:12:26 <johnw> it doesn't work for all type classes, and especially not if your type is recursive, but it can do a lot
18:12:42 <duckbob> the problem was expressing the datatype as it is heavily nested
18:13:22 <Lokathor> duckbob, https://github.com/Strifepad/StrifeServer/blob/master/src/Strife/Server.hs#L174 this is how you turn a Text into a Value
18:13:36 <Lokathor> you can modify that to turn a String to a Value, if you want
18:13:48 <duckbob> which function?
18:13:57 <Lokathor> line 174/ 175
18:14:09 <Lokathor> eitherJsonFromText
18:14:58 <duckbob> thanks
18:19:11 <ttt_fff> we need something like datomic, but for haskell; it's a fucking brilliant design idea ofr a datbase
18:24:52 <geekosaur> can we speak to family friendly language please, ttt_fff?
18:24:57 <geekosaur> stick to
18:25:22 <dramforever> maybe at least censor a bit
18:28:04 <duckbob> Lokathor: im still stuped as to where key is defined, i cant find it!
18:28:16 <Lokathor> key?
18:28:25 <Lokathor> oh, the key is just whatever string you pass to lookup
18:28:40 <Lokathor> i use the term key, it's like a dictionary key
18:29:00 <octopuscabbage> I'm reading through Chris Okasaki's "Purely Functional Data Structures" but I'm having trouble reading some of the intermediate and advanced sml code, does anyone have a quick tutorial on sml for haskell programmers?
18:29:06 <duckbob> its in your source code, i cant see where it is imported from...
18:29:56 <Lokathor> i suspect Control.Lens
18:30:07 <duckbob> nope
18:30:43 <duckbob> ill brute force it...
18:30:48 <duckbob> doh
18:32:49 <duckbob> it was in aeson-lens
18:34:19 <mniip> I made a thing!
18:34:27 <Lokathor> !?
18:34:33 * dramforever is interested
18:34:37 <dramforever> mniip: what is it?
18:34:38 <mniip> liftable typeclasses
18:34:51 <mniip> they're very close to generic
18:35:18 <mniip> and it only requires -XKitchenSink
18:35:19 <Lokathor> that sounds beyond me
18:35:36 <dramforever> that's an interesting extension
18:35:46 <lpaste_> mniip pasted “liftable typeclass” at http://lpaste.net/138463
18:36:29 <dramforever> that looks very general
18:36:38 <duckbob> cool beans
18:37:04 <mniip> if your thing has kind ((* -> *) -> * -> *) -> (* -> * -> *) -> * -> *
18:37:30 <Lokathor> that looks like an ascii creature with a bunch of noses and eyes
18:37:33 <mniip> you can define an instance Class3 (Class2 (Class1 Class0) Class0) (Class2 Class0 Class0) Class0
18:37:43 <duckbob> Lokathor: http://lpaste.net/138464 now i get an error cant match Maybe Value to Value
18:37:56 <mniip> and it will be classes all the way down
18:38:26 <exio4> mniip: how would that be used and what for?
18:38:34 <mniip> exio4, have you heard of Show1
18:38:45 <vik123> Hi all, does anyone know the syntax to put comments in a .ghci file?
18:38:54 <Lokathor> duckbob, well, yes, a Maybe Value and a Value aren't the same... how much haskell training do you have?
18:39:09 <duckbob> cheers...
18:39:21 * mniip .oO( all these extensions defeat the point of Show1 )
18:39:22 <duckbob> i know they are not the same type at least
18:39:48 <Lokathor> you'd have to use a case statement to unwrap the Maybe Value
18:39:50 <Lokathor> if you want the Value inside
18:39:53 <exio4> mniip: yes
18:40:01 <mniip> exio4, do you know what it's used for?
18:40:21 <exio4> mniip: no
18:40:35 <mniip> imagine data X f = X (f Int)
18:41:01 <mniip> so for example X [1, 2, 3] :: X [], and X (Just 3) :: X Maybe
18:41:15 <exio4> ah, right, instead of (Eq a, Eq (f a)) =>, you'd do (Eq1 f) => 
18:41:21 <mniip> yes
18:41:27 <exio4> which is haskell98 
18:41:28 <mniip> because Eq (f a) is not valid in 98
18:41:34 <exio4> (compared to (f a) which isn't)
18:42:13 <mniip> so yeah
18:42:31 <mniip> I generalized Eq1 to k -> *, where k is given as argument
18:42:48 <mniip> and Eq2 to k -> l -> * etc
18:43:20 <mniip> oh yeah
18:43:45 <mniip> there's one thing you can't do without Eq1, even in extensioned code
18:43:54 <duckbob> i used; let (Right y) = eitherJsonFromText x in  failover (lookup "a") (+1) y
18:44:15 <mniip> data D t m a = D (t m a)
18:44:15 <Lokathor> well, that should work out i guess
18:44:21 <duckbob> i dont
18:44:24 <mniip> hm
18:44:31 <mniip> data D t = D (t Maybe Int)
18:44:32 <exio4> mniip: what wouldn't be possible? 
18:44:39 <duckbob> it* does not
18:44:49 <Lokathor> it doesn't typecheck or it doesn't run?
18:44:55 <dramforever> just like Typeable1, isn't it
18:45:01 <Lokathor> getting json to parse properly is finnicky
18:45:14 <dramforever> can't work with something with kind (* -> *) -> *
18:45:19 <duckbob> typecheck
18:45:29 <Lokathor> well, use :t a lot in ghci
18:45:32 <Lokathor> see where you went wrong
18:45:39 <Lokathor> that's how i muddle through
18:46:10 <Lokathor> alas, i must go eat now
18:46:25 <mniip> @let data D t = D (t Maybe Int)
18:46:26 <lambdabot>  Defined.
18:46:31 <mniip> go define a show or eq for it
18:48:35 <mniip> hmm
18:48:45 <mniip> in fact my thingmabob is helpless there as well
18:48:56 <mniip> Constraint is no smaller than the instance head
18:50:43 <duckbob> instance Show (D t) where show (t (Just i)) = show t ++ show i; show (t (Nothing)) = show t
18:51:09 <mniip> duckbob, that's not how that works
18:51:20 <exio4> mniip: instance Show (t Maybe Int) => Show (D t) where show (D x) = show x ? 
18:51:28 <exio4> duckbob: that has no way to work 
18:51:36 <duckbob> instance Show (D t) where show (D t (Just i)) = show t ++ show i; show (D t Nothing) = show t
18:51:37 <mniip> exio4, unfortunately that pulls UndecidableInstances
18:51:39 <arkeet> did you mean data D t = D (t (Maybe Int))
18:51:50 <arkeet> or
18:51:54 <arkeet> data D t = D t (Maybe Int)
18:51:57 <mniip> arkeet, no, t ~ transofmer
18:52:02 <mniip> transformer
18:52:04 <arkeet> I'm confused.
18:52:15 <mniip> data D t = D (t Maybe Int)
18:52:21 <duckbob> instance Show (D t Int) where show (D t (Just i)) = show t ++ show i; show (D t Nothing) = show t
18:52:22 <exio4> mniip: well, considering that code already pulls out other extensions, and undecidableinstances is quite safe
18:52:29 <mniip> for example, D IdentityT
18:52:41 <mniip> exio4, undecidable instances? safe?
18:52:43 <duckbob> Maybe Int* sorry...
18:52:59 <exio4> mniip: you can't break type safety with it, can you? 
18:53:07 <duckbob> is that correct?
18:53:13 <mniip> you can hang the compiler
18:53:30 <exio4> which doesn't seem that bad
18:54:12 <exio4> mniip: considering you can get exponential time type inference
18:59:51 <EvanR> O(2^(-n))
18:59:55 <EvanR> aw yeah
19:00:31 <duckbob> can anyone tell me how to tweak this code to make it a working lens modification example for JSON data? http://lpaste.net/138464
19:00:34 <dramforever> :t let a x = (x, x); b = a.a; c = b.b in c
19:00:35 <lambdabot> t -> ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))
19:01:45 <edwardk> You want something that takes {"a":1,"b":{"c":{"d":"hello","e",2}}}  => "{\"a\":1,\"b\":{\"c\":{\"d\":\"hello\",\"e\",2.5}}" ?
19:02:01 <duckbob> yes
19:02:31 <duckbob> nonono, as a string on both sides of your =>
19:02:44 <edwardk> something like:      key "b".key "c".key "e"._Double +~ 0.5
19:02:54 <duckbob> well actually i guess it should stay as a Value...
19:03:06 <mniip> exio4, class E x
19:03:06 <mniip> instance (E (Maybe x)) => E x
19:03:32 <duckbob> yes!
19:03:37 <duckbob> thanks
19:03:57 <edwardk> to get the string you need _JSON at the front
19:04:09 <edwardk> _JSON.key "b".key "c".key "e"._Double +~ 0.5
19:04:51 <edwardk> alternately _JSON...key "e"._Double +~ 0.5  should also work
19:04:53 <duckbob> did you see the lookup' function? that already uses key, so do i need to change that?
19:05:49 <edwardk> what do you want to change it to?
19:06:08 <edwardk> _JSON.lookup' "b.c.e"._Double +~ 0.5
19:06:08 <duckbob> i dont know, do i need it?
19:06:22 <edwardk> lets you use the dotted notation directly without explicit keys
19:06:45 <duckbob> sweeet
19:06:54 <edwardk> a fun exercise would be to write a parser that too foo.bar.baz[10].quux   like notation and fixed it up, slightly more advanced than you lookup'
19:07:18 <edwardk> anyways that ... thing was originally constructor for hacking up JSON
19:07:23 <edwardk> er constructed
19:07:41 <duckbob> epic
19:07:48 * dramforever wonders if that foo.bar[10] thing is good
19:07:53 <duckbob> jems
19:07:59 <dramforever> it can't even get checked at compile time
19:08:23 <duckbob> dramforever, sure if we want nice representation for ktrees for example
19:08:25 <EvanR> json has only one type nothing you can do it wrong!
19:08:26 <dramforever> but who cares
19:08:30 <edwardk> dramforever: personally i wouldn't use it, but its a fairly standard way to talk about paths
19:08:36 <dramforever> =)
19:08:45 <dramforever> just like CSS selectors and XPath
19:09:49 <edwardk> yep
19:10:24 <duckbob> edwardk: now i just get hole error which iv never seen before... with _JSON.lookup' "b.c.e"._Double +~ 0.5
19:11:00 <dramforever> duckbob: what's the name of the hole?
19:11:06 <edwardk> _JSON is in lens-aeson, as is _Double
19:11:30 <edwardk> so typo somewhere?
19:12:26 <dramforever> or missing import maybe?
19:13:23 <duckbob> http://lpaste.net/138465
19:14:36 <Lokathor> edwardk, in addition to (...) you also were the one that constructed "lookup", if you recall x3
19:14:44 <edwardk> probably
19:15:08 <Lokathor> i asked one time and you threw it together in about 2 minutes. I was impressed
19:15:20 <duckbob> aha so i meet you edwardk
19:15:29 <edwardk> duckbob: why do you bother with the separate json parsing step?
19:15:40 <edwardk> you can use _JSON to consume Text directly
19:15:55 <duckbob> because i have no idea what im doing, im hacking up some of Lokathors code badly
19:16:18 <edwardk> go = x & _JSON.lookup' "b.c.e"._Double +~ 0.5
19:16:31 <Lokathor> my code kept a JSON Value in memory and used lookup to do updates. I'm not sure what duckbob is going for
19:16:31 <duckbob> woot!
19:16:55 <edwardk> sorry i don't have any more compression tricks to make that shorter other than things that drop the lookup'
19:17:27 <edwardk> go = x & _JSON...key "e"._Double +~ 0.5 does this particular case though
19:17:34 <duckbob> still gives me a hole
19:17:54 <edwardk> strange, try more spaces
19:17:59 <duckbob> on _Double
19:18:17 <edwardk> weirdness
19:19:27 <nitrix> Just making sure: * = Int,Float,...    * -> * = Maybe, [], IO    * -> * -> * = Either ?
19:19:55 <dramforever> nitrix: yes you are right
19:20:21 <nitrix> And all kinds are currently part of the BOX thing?
19:20:42 <dramforever> dunno
19:21:01 <nitrix> the BOX sort?
19:21:03 <EvanR> the sort of any kind of BOX
19:21:07 <EvanR> is BOX
19:21:17 <dramforever> that's useless
19:21:24 <duckbob> edwardk http://lpaste.net/138467
19:21:25 <EvanR> yep
19:21:44 <EvanR> nitrix: theres a :k command
19:21:49 <nitrix> Not that useless. I'm trying to trying `forall` fluently.
19:21:56 <nitrix> read*
19:22:15 <edwardk> duckbob: tell it    x :: T.Text
19:22:26 <edwardk> right now the OverloadedStrings don't know what instance to pick
19:22:31 <edwardk> that extension is godawful without types
19:23:16 <nitrix> EvanR: Does haskell have dependent types?
19:23:21 <EvanR> nope
19:23:46 <EvanR> you can duplicate a lot of machinery at the kind level though
19:24:01 <EvanR> datakinds, singleton types
19:24:14 <duckbob> there are so many errors, and changing this does not help
19:24:14 <nitrix> Ah :)
19:24:54 <edwardk> go2 = x & _Value..._Double +~ 0.5
19:24:59 <duckbob> i cant even begin to bugcheck this..
19:25:02 <edwardk> that version is the one that you can use with ... my bad before
19:25:06 <exio4> beware, quasi-dependent types in Haskell are verbose, annoying and extremely nasty to work with
19:25:15 <edwardk> _JSON can parse/unparse anything with FromJSON/ToJSON instances
19:25:21 <edwardk> while _Value yields only Values
19:25:41 <duckbob> with the dots!?
19:26:19 <edwardk> go2 = x & _Value...key"e"._Double +~ 0.5 -- will find the key 'e' anywhere in a document and change it
19:26:29 <edwardk> ... is a 'go fish' style operator
19:26:41 <duckbob> replacing _Value with _JSON
19:26:49 <edwardk> no, _Value is the one you want there
19:26:53 <duckbob> other way round...
19:26:56 <edwardk> _JSON is actually too powerful for it to infer
19:26:57 <edwardk> yeah
19:27:05 <nitrix> EvanR: Should I dare ask the difference between the unboxed # and * inhabited types?
19:27:12 <duckbob> still has holes
19:27:31 <EvanR> nitrix: some generics and dynamic stuff dont work with unboxed values
19:27:32 <nitrix> EvanR: inhabited kind, sorry
19:27:48 <EvanR> mainly read about unboxed to find out its limitations
19:27:48 <edwardk> nitrix: you know how folks say an Int in haskell is a promise to compute you an Int when asked? rather than an actual machine int? that is because it lives in *..   on the other hand, the actual machine Int, Int# lives in #
19:28:24 <duckbob> actually there is an error in this definition of lookup'
19:28:28 <edwardk> * values are boxed, they can be lazy, live on the heap, etc. # values are unlifted, they don't have an extra _|_ in them.
19:29:23 <edwardk> * is the nice lazy haskell universe you know, # is strict, types of kind * can have quantifiers involved, you can't quantify over anything in #
19:29:25 <nitrix> edwardk: So # are implementation specific and * are language specific?
19:29:49 <nitrix> Or am I extrapolating too much?
19:29:51 <edwardk> nitrix: the key distinction is that _|_ lives in *. while # values are strict
19:30:00 <edwardk> so if you want to boil it down to one thing, it is that thing
19:30:13 <nitrix> edwardk: _|_ being bottom?
19:30:16 <edwardk> yeah
19:30:59 <nitrix> Okay. I'm a long way from connecting the dots even though I feel like I understand this.
19:31:02 <nitrix> edwardk: I appreciate.
19:31:09 <edwardk> if i give you an Int#      you can know it is an honest to goodness machine integer. you can't do this in a top level definition, it has to always get shoved back into some kind of container to use it.
19:31:14 <EvanR> you cant write a polymorphic function over unboxed types
19:31:22 <duckbob> i have a function which wont work to parse something i dont know how it is constructed...
19:31:32 <dramforever> ghc primops cannot be partially applied
19:31:54 <dramforever> these all make # special
19:32:03 <dramforever> but that's it
19:32:28 <edwardk> things in # can have very different sizes. (# Int#, Double #)    is an unboxed tuple of a machine integer and a boxed double. it is like giving back a pair, except you don't have to worry about the pair itself being _|_. on the other hand, the downside is you can't abstract over (# , #)  or the choice of Int# in that type with a quantifier
19:32:47 <edwardk> the primops can't be partially applied, but you can write functions that take unboxed values that can be
19:32:53 <duckbob> can anyone see the error here? http://lpaste.net/138467
19:32:58 <edwardk> you can write foo :: Int# -> Double -- just like any other function
19:34:10 <cowboysauce> Is there a way to have a conduit that takes data from multiple sources without blocking any of them?
19:34:25 <nitrix> edwardk: So, from what I grasp, the core of the language is using *, but its foundation rely on a bit of magic (like any language), compiler/architechture primitives that are the # kind.
19:35:11 <edwardk> nitrix: the bulk of the code you write will be written with stuff in *. then ghc is super-fancy about figuring out how to unbox all this stuff behind your back when it is sufficiently strict.
19:35:32 <edwardk> it'll do 'worker-wrapper' transforms on the code and often be able to take monomorphic code down to code that actually works with those # values entirely
19:35:36 <edwardk> its kind of amazing
19:35:49 <nitrix> Sounds cool indeed.
19:35:53 <edwardk> when it fails, occasionally you may have to help it with writing code with things in # yourself for the tricky parts
19:35:55 <edwardk> e.g. https://github.com/ekmett/transients/blob/29ad98d8baa6d75575087dd6d4367bce38a12bc0/benchmarks/wordmap/Fingered.hs#L255
19:36:24 * dramforever was once amazed by how ghc could actually generate code like C compilers do
19:36:32 <dramforever> with little or no help
19:36:41 <edwardk> there i have 3 mutually recursive functions that all need to get optimized and that is just a step farther than i can get worker-wrapper from O2 to optimize, so i had to convert manually the critical bits of code
19:36:57 <edwardk> and only rely on it unboxing a handful of obvious bits that are left and within the capabilities of the compiler
19:37:06 <edwardk> i could have written much more straightforward code
19:37:13 <edwardk> but it would then have had to place more stuff on the heap
19:37:16 <nitrix> Holy.
19:37:23 <edwardk> and the point of this exercise was seeing how little i could do on the heap
19:37:39 <duckbob> @let lookup' = foldr (.) id . fmap (key . T.pack) . S.splitOn "."
19:37:40 <lambdabot>  .L.hs:156:32:
19:37:40 <lambdabot>      Not in scope: ‘key’
19:37:40 <lambdabot>      Perhaps you meant one of these:
19:38:09 <edwardk> nitrix: on the plus side it worked =)
19:38:36 <duckbob> edwardk, sorry lambdabot does not get it, but this has a type err,,r something about Maybe and key
19:39:53 <nitrix> edwardk: And just like that, you just confirmed it'll take me a good 3 years before I have enough knowledge to risk myself claiming doing better optimizations than the compiler.
19:40:11 <edwardk> duckbob: what version of the compiler are you using?
19:40:16 <nitrix> So much to learn.
19:40:33 <duckbob> 7.8.3
19:40:56 <edwardk> nitrix: fwiw- i pretty much listened to everything dons said about low level optimization with the same sense of wonder and abject dejection for a while ;)
19:41:11 <dramforever> except if you found a better algorithm
19:41:15 <edwardk> on the plus side the system is quite straightforward
19:41:39 <edwardk> dramforever: i mostly focus on high level optimizations, and then delegate to folks to figure out how to make the critical bits fast
19:41:54 <dramforever> yep that's what they should do
19:42:04 <edwardk> occasionally i have to dive deep on something like that once i realize i can't trick ghc into doing my work for me
19:42:14 <edwardk> and when i can't interest anyone else in the problem
19:42:19 <duckbob> is my definition of lookup' correct? where can i find its source normally?
19:42:22 <edwardk> or when it'd take too long to explain the issue
19:42:42 <edwardk> let lookup' = Prelude.foldr (.) id . fmap (key . T.pack) . S.splitOn "."    compiled for me
19:43:19 <edwardk> lookup' :: Applicative f =>  [Char]  -> (aeson-0.9.0.1:Data.Aeson.Types.Internal.Value -> f aeson-0.9.0.1:Data.Aeson.Types.Internal.Value) -> aeson-0.9.0.1:Data.Aeson.Types.Internal.Value -> f aeson-0.9.0.1:Data.Aeson.Types.Internal.Value  -- is what my ghci says when i type it in
19:43:54 <edwardk> which is lookup' :: String -> Traversal' Value Value -- just noisier
19:44:38 <duckbob> thanks! thats quite different from the type i had...
19:45:32 <edwardk> nitrix: http://jsbin.com/fehefekozo/1/edit?output <- is the result of the benchmarking that code for reference. FlatMap is the version of the code listed there.
19:45:37 --- mode: edwardk set -o edwardk
19:45:45 <edwardk> oops, someone just pointed out i was still opped
19:46:04 <EvanR> the power turban
19:46:56 <duckbob> edwardk: it still wants a maybe value...
19:46:56 <edwardk> basically all of this was an exercise in trying to build a faster IntMap
19:47:17 <edwardk> duckbob: nothing you mentioned there gives back a Maybe
19:47:38 <edwardk> :t Data.List.Split.splitOn
19:47:39 <lambdabot> Eq a => [a] -> [a] -> [[a]]
19:47:42 <edwardk> no maybes there
19:48:02 <edwardk> fmap (key . T.pack) -- that just packs each one of the substrings into a text field
19:48:12 <edwardk> now we have [Text]
19:48:17 <edwardk> er
19:48:19 <edwardk> rather
19:48:23 <edwardk> we would except for the key
19:48:42 <duckbob> yeh
19:48:52 <edwardk> so its now forall f. Functor f => [(Value -> f Value) -> Value -> f Value]
19:48:57 <duckbob> no functor instance either...
19:48:58 <edwardk> er Applicative f
19:49:07 <duckbob> ok its looking better!
19:49:46 <edwardk> then we take the list and flatten it down by noting that (Value -> f Value)      ->    (Value -> f Value)   is just a function    between values that look like (Value -> f Value)
19:50:08 <edwardk> so foldr id (.)    takes that and yields a single (Value -> f Value) -> Value -> f Value
19:50:31 <edwardk> nothing fancy, everything is portable, that is prelude's foldr and works across compilers for lists
19:50:46 <edwardk> so the only way you're getting a Maybe in here is if you have something weird in scope
19:50:53 <edwardk> can you lpaste the actual error you get?
19:51:40 <duckbob> can i pipe stdout or stderror to a file or something?
19:51:45 <edwardk> i have to give two talks on lenses, focusing much on the prism machinery over the next 3 weeks, so this is actually a subject near and dear to my heart =)
19:51:53 <edwardk> or just cut and paste from the terminal into lpaste
19:53:03 <duckbob> edwardk: and i will be presenting a talk on representations of polymers in functional programming for high performance computational chemistry, so it would be great to get this working! 
19:53:53 <duckbob> i would if i could copy from my terminal...
19:54:07 <dramforever> duckbob: what terminal are you using?
19:54:30 <duckbob> cant i just go go >>= catchError >>= writeFile "out.txt"
19:54:40 <duckbob> windows cmd
19:54:57 <dramforever> duckbob: click on cmd icon on the top left
19:55:11 <dramforever> there's submenu called edit or something
19:55:14 <edwardk> duckcmd: you can paste from a windows terminal its just a strange process
19:55:22 <dramforever> edwardk ++
19:55:29 <duckbob> no menues here...
19:55:34 <duckbob> windows 8
19:55:46 <dramforever> sigh...I don't know anything about windows 8
19:56:02 <edwardk> spinning up a windows 8 desktop, one sec.
19:56:11 <duckbob> C:\Windows\cmd.exe
19:56:36 <duckbob> C:\Windows\System32\cmd.exe
19:56:57 <edwardk> duckbob: right click on the little tiny icon for the window in the upper left hand corner
19:56:57 <duckbob> why are you starting windows 8!?
19:57:01 <geekosaur> I think if you at least have a service pack installed (or win8.1) then you can switch it to desktop mode and get the menu back
19:57:07 <duckbob> its not a problem with my compiler...
19:57:09 <edwardk> duckbob: to ensure i can still do it ;)
19:57:14 <duckbob> does the code i pasted work?
19:57:52 <edwardk> if you right click on that little icon you get a context menu, its not the usual way windows applications work, but cmd.exe is a console application and console applications have worked this way since 95 ;)
19:58:00 <dramforever> sigh...
19:58:36 <duckbob> http://lpaste.net/138470
19:58:39 <edwardk> (and i just confirmed it still works on 8.1)
19:59:18 <dramforever> duckbob: hey why do you have the [ ... ] around the traversal?
19:59:26 <dramforever> and obviously you didn't pass in the string
20:00:17 <leshow1> how would I turn a list of lists into a list of lists by column, for example
20:00:28 <edwardk> duckbob: you aren't crazy. something breaks between your code and Lokathor 's
20:00:29 <duckbob> thats the type edwardk gave me
20:00:37 <edwardk> i was giving you an intermediate step in the type
20:00:40 <dramforever> :t transpose
20:00:41 <lambdabot> [[a]] -> [[a]]
20:00:43 <edwardk> i was walking through what each step does
20:00:46 <leshow1> [[1,2,3,4],[1,2,3,4]] into [[1,1],[2,2],[3,3]..]
20:00:47 <dramforever> leshow1: ^
20:00:57 <dramforever> > transpose [[1,2,3,4],[1,2,3,4]]
20:00:57 <duckbob> thanks, sorry, this is killing me
20:00:59 <lambdabot>  [[1,1],[2,2],[3,3],[4,4]]
20:01:03 <Lokathor> i might import a thing that duckbob doesn't perhaps?
20:01:05 <edwardk> lookup' :: Applicative f => String -> (Value -> f Value) -> Value -> f Value
20:01:09 <edwardk> is the actual type
20:01:22 <edwardk> you were missing the String -> ... and had a funny list in place
20:01:28 <mniip> edwardk!
20:01:28 <edwardk> with that type it compiles
20:01:37 <edwardk> heya mniip 
20:01:51 <mniip> edwardk, have you see my monad transformer transformer? :p
20:01:57 <edwardk> mniip: ?
20:02:00 <leshow1> thanks
20:02:04 <dramforever> yw
20:02:05 <leshow1> i wonder if elm has somethign similar
20:02:10 <leshow1> i can't find a transpose in elm
20:02:44 <duckbob> whaaaat its still wanting a maybe V !?!?! am i importing key from the wrong place or something?
20:03:02 <mniip> edwardk, newtype MuT t a = MuT { runMuT :: t (MuT t a) a }
20:03:41 <dramforever> what does it do?
20:03:51 <mniip> hell if I know
20:03:55 <dramforever> lol
20:04:17 <edwardk> duckbob: you don't have a particularly large number of imports there
20:04:18 <mniip> I only know that it appears to generate fancy types in conjunction with ReaderT, StateT, and ContT
20:04:19 <betaceti> can anyone confirm i'm getting this right (LiquidHaskell): in both these cases the annotation `n :: Nat` needs to be wrapped in braces `{-@,@-}` for liquid to catch the error? i was hoping it would automatically infer without the braces: 1 http://pastebin.com/jYrtbwth 2 http://pastebin.com/Lxw6HjFs
20:04:22 <nitrix> edwardk: I have a quick question. How does Haskell ensures linearity and prevents duplication of unique types? I don't even know if those exists in the language, but when I think:  foo a b c = ...   clearly if a, b or c is reused twice in the function body and that happens to be a resource, then you get an invalidated resource.
20:04:31 <duckbob> could you paste your version?
20:04:40 <edwardk> nitrix: we don't have uniqueness or linear types in haskell
20:04:57 <nitrix> Is there a reason for that?
20:05:03 <exio4> mniip: t (MutT t a) a ? wasn't it newtype MutT t a = MuT (t (MuT t) a) ? 
20:05:06 <edwardk> yes, they kind of infect everything else in the typechecker
20:05:14 <mniip> er
20:05:15 <mniip> yes
20:05:16 <nitrix> I'm still fairly new to this.
20:05:21 <edwardk> a whole bunch of optimizations have to get complicated as well
20:05:35 <mniip> exio4, uh, that's the same thing
20:05:35 <edwardk> e.g. lifting a value out of a lambda now can change the uniqueness of the lambda
20:05:42 <nitrix> edwardk: Fair enough. I came to a similar conclusion when developing a toy language too.
20:05:48 <mniip> exio4, you don't need parentheses in record syntax
20:05:51 <duckbob> can someone compile this for me I think I have a broken GHC or something... http://lpaste.net/138470
20:06:00 <duckbob> i get a Matbe v0 error...
20:06:00 <edwardk> so you actually start to get fewer consistently legal optimizations once you enable uniqueness typing
20:06:04 <exio4> mniip: no, t (MuT t a) a vs t (MutT t) a 
20:06:11 <exio4> different kinds there
20:06:18 <mniip> ah yes
20:06:19 <mniip> that
20:06:21 <edwardk> @lpaste
20:06:21 <lambdabot> Haskell pastebin: http://lpaste.net/
20:06:31 <mniip> edwardk, newtype MuT t a = MuT { runMuT :: t (MuT t) a }
20:06:33 <lpaste_> edwardk pasted “works for me” at http://lpaste.net/138472
20:07:03 <edwardk> mniip: hrmm, so you feed it a monad transformer and you get what? is that a legal monad?
20:07:08 <duckbob> sorry not that one, this one; http://lpaste.net/138473
20:07:16 <edwardk> seems odd
20:07:22 <dramforever> @let newtype MuT t a = MuT { runMuT :: t (MuT t) a }
20:07:23 <lambdabot>  Defined.
20:07:39 <nitrix> edwardk: It it taken over by a different mechanism, or we just expect the users to use their common sense when doing IOs ?
20:07:52 <mniip> edwardk, it's a useless structure for half of transformers that use the passed monad in the top level
20:07:53 <edwardk> ... s -> s -> s -> s -> s -> ((((a, s), s), s)))) ..
20:08:00 <edwardk> mniip: yeah it generally doesn't work
20:08:07 <mniip> and slightly less useless for those that put it under a function arrow
20:08:13 <mniip> i.e all others
20:08:25 <duckbob> yeh those are identical pastes... i think my compiler is broken, god im so sorry i wasted a lot of time with that
20:08:31 <dramforever> ( ... ((a, w), w) ... )
20:08:31 <mniip> edwardk, but MuT ContT
20:08:39 <dramforever> duckbob: no they aren't identical
20:08:40 <edwardk> nitrix: well, there are a few saving graces we have available to us
20:08:50 <edwardk> you can reason about any _one_ linear resource by writing a monad.
20:08:53 <duckbob> still id like a second oppinion before i reinstall everything again...
20:08:55 <dramforever> duckbob: types are different
20:09:00 <edwardk> then you just give the linear operations on that resource as actions in the monad
20:09:05 <dramforever> duckbob: look at your types
20:09:09 <duckbob> nno this one http://lpaste.net/138473
20:09:12 <edwardk> this is great for singular resources and simple cases
20:09:36 <dramforever> duckbob: it doesn't work?
20:09:40 <nitrix> edwardk: I guess that's why I'm relating it directly with IO.
20:09:42 <dramforever> ok......
20:09:46 <duckbob> not for me no
20:09:50 <duckbob> i get a type error
20:10:02 <dramforever> maybe reinstall relevant packages
20:10:17 <edwardk> for larger cases you can actually embed a linear logic into haskell using various techniques, oleg has one, others exist http://www.ioc.ee/~tarmo/tsem11/jeltsch1602-slides.pdf etc.
20:10:19 <dramforever> like nuke ~/.ghc or whatever
20:10:43 <duckbob> Maybe v0 for Value in key
20:10:54 <edwardk> IO is done in a 'world-passing' style with a linear resource. IO a = State# RealWorld -> (# State# RealWorld, a #)
20:11:13 <nitrix> The # kind !
20:11:14 <edwardk> the combinators that manipulate IO make sure to linearly pass the State# RealWorld token through
20:11:20 <edwardk> that implicitly gives us sequencing
20:11:33 <duckbob> dramforever: did you compile it?
20:11:34 <edwardk> State# :: * -> #     RealWorld :: *
20:11:44 <nitrix> Fancy.
20:11:45 <dramforever> duckbob: no...but it doesn't seem wrong
20:11:51 <edwardk> ST s a = State# s -> (# State# s, a #) 
20:11:56 <dramforever> maybe because you are using a different version or something
20:12:01 <dramforever> forget about it I know nothing
20:12:03 <duckbob> well my colpiler says it is, can you check yours?
20:12:07 <edwardk> State# s   has '0 width' it takes 0 bytes to store
20:12:22 <edwardk> its just used to logically sequence stuff and keep the compiler from moving computations past it
20:12:23 <duckbob> just before i nuke mine...
20:12:42 <edwardk> the key here is IO and ST s 'manage a single linear resource'
20:12:46 <mniip> another thing to notice is that the return convention for (# State# s, a #) is the same as for just 'a'
20:12:47 <edwardk> which is this State# token
20:12:54 <mniip> which means it's not actually returned
20:12:57 <edwardk> so they can pull it off.
20:13:04 <nitrix> edwardk: The whole world, yeah.
20:13:08 <nitrix> Very interesting.
20:13:37 <edwardk> Chen and Hudak wrote a paper on the generalized form of this code transformation: http://haskell.cs.yale.edu/?post_type=publication&p=311
20:14:02 <edwardk> for more general scenarios where you want multiple linear/affine/whatever resource it isn't sufficient, but it goes remarkably far
20:14:18 <mniip> edwardk, by the way, I've been looking at typeclass lifting, and I suddenly remembered your Lifting class
20:14:32 <mniip> and I wonder, why do both of them work with "linear" kinds?
20:14:34 <dolio> It's how IO is done (in GHC), but it's not an adequate semantics, unless you're prepared to say the 'functions' have side effects.
20:14:46 <mniip> er, by both I mean your code and Data.Functor.CClasses
20:14:58 <edwardk> mniip: this monstrosity? https://github.com/ekmett/constraints/blob/master/src/Data/Constraint/Lifting.hs
20:15:02 <mniip> yes
20:15:43 <edwardk> class Lifting p f where lifting :: p a :- p (f a) -- what would you have it do instead?
20:16:24 <mniip> the transformers package defines Eq1 and Eq2, you define Lifting and Lifting2
20:16:43 <mniip> with linear kinds in mind, that is, *->*->...->*->*
20:16:48 <edwardk> nitrix: in theory you don't need to do 'world passing' to do IO, btw: http://comonad.com/reader/2011/free-monads-for-less-3/
20:16:50 <duckbob> a generalised Functor?
20:17:00 <mniip> what about other kind of kinds
20:17:57 <edwardk> mniip: nothing in the thing i just gave said the kind of p or f or a
20:18:37 <dramforever> duckbob: hi the code doesn't work for me too interestingly...
20:18:53 <duckbob> edwardk!
20:19:12 <edwardk> instance Lifting MonadPlus (ReaderT e) where lifting = Sub Dict  --     uses p :: (* -> *) -> Constraint     f :: ReaderT e :: (* -> *) -> * -> *   a :: (* -> *)
20:19:12 <dramforever> duckbob: however do check the type of k
20:19:16 <dramforever> *key
20:19:22 <dramforever> maybe it's changed
20:19:26 <edwardk> duckbob: juggling 3 conversations, lost the thread of yours
20:19:43 <dramforever> we need threaded chat like reddit...
20:19:54 <duckbob> my compiler is not broken, the type you gave is wrong... your other conversations are cool
20:19:55 <codehero> threaded irc
20:19:57 <edwardk> duckbob: lookup' :: Applicative f => String -> (Value -> f Value) -> Value -> f Value  -- once i changed your lookup' signature to that it compiled
20:20:05 <edwardk> note the String -> ... in it
20:20:08 <dramforever> lol it still doesn't
20:20:25 <mniip> edwardk, can you lift Eq to a (*->*)->* kind though?
20:20:38 <duckbob> i have that
20:20:46 <dramforever> here we have key :: (Functor f, ToJSON v, FromJSON v, Indexable ValueIx p) => T.Text -> p (Maybe v) (f (Maybe v)) -> Maybe Value -> f (Maybe Value)
20:20:46 <edwardk> mniip: no because its not really a lifting. it'd take Eq1 .. to Eq or whatever
20:20:50 <dramforever> edwardk: what about you
20:20:52 <edwardk> duckbob and what do you get?
20:20:55 <mniip> edwardk, exactly
20:20:55 <duckbob> it says key wants a maybe type
20:20:57 <dramforever> also happy juggling
20:21:14 <duckbob> Maybe Value
20:21:18 * dramforever is also in the JSON conversation, just in case you got confused
20:21:25 <edwardk> duckbob: key :: (Applicative f, AsValue t) => T.Text -> (Value -> f Value) -> t -> f t
20:21:29 <dramforever> lol
20:21:40 <edwardk> not a maybe anywhere in sight
20:21:48 <dramforever> now THAT'S the problem
20:21:50 <edwardk> duckbob: paste your current code
20:22:01 <dramforever> edwardk: same as yours
20:22:13 <duckbob> its the same as your last paste
20:22:22 <dramforever> I just reinstalled aeson-lens, and I have key  :: (Functor f, ToJSON v, FromJSON v, Indexable ValueIx p) => T.Text -> p (Maybe v) (f (Maybe v)) -> Maybe Value -> f (Maybe Value)
20:22:33 <edwardk> ok, then something's fucky. what version of lens-aeson do you have installed?
20:22:42 <dramforever> newest
20:22:44 <edwardk> and what version of lens?
20:22:52 <edwardk> _aeson-lens_?
20:22:56 <edwardk> aeson-lens is your problem
20:23:00 <edwardk> kill it with fire
20:23:00 <duckbob> same
20:23:04 <dramforever> lens 4.12.3
20:23:05 <edwardk> install lens-aeson
20:23:10 <edwardk> lens-aeson, not aeson-lens
20:23:14 <dramforever> oh
20:23:18 <dramforever> wow
20:23:18 <duckbob> ffs!!!
20:23:20 <edwardk> aeson-lens doesn't work
20:23:21 <dramforever> wtf
20:23:22 <saulzar> Hehe, I just ran into this too. 
20:23:31 <mniip> edwardk, so here's the problem, imagine data D f = D (f Int)
20:23:34 <dramforever> things happen
20:23:37 <edwardk> saulzar: i wrote and asked the author to deprecated the package, he never replied
20:23:40 <duckbob> i am die
20:23:50 <edwardk> it is actively harmful
20:23:54 * dramforever leaves lens stuff
20:24:01 <dramforever> for now
20:24:02 <duckbob> yeh its done
20:24:09 <mniip> edwardk, how would you implement an Eq/Ord/Read/Show instance for it?
20:24:12 * hackagebot breve 0.4.1.0 - a url shortener  https://hackage.haskell.org/package/breve-0.4.1.0 (rnhmjoj)
20:24:30 <dramforever> @let data D f = D (f Int)
20:24:31 <lambdabot>  .L.hs:159:1:
20:24:31 <lambdabot>      Multiple declarations of ‘D’
20:24:31 <lambdabot>      Declared at: .L.hs:155:1
20:24:34 <mniip> sure, you can use Eq1/Ord1/Read1/Show1, although you have to ensure that all respective-kinded datatypes have instances
20:24:35 <dramforever> @undefine
20:24:35 <lambdabot> Undefined.
20:24:40 <duckbob> can i get a high five and can we poste this somewhere!?
20:24:41 <edwardk> mniip: instance Eq1 f => Eq (D f)  -- or instance Lifting Eq f => Eq (D f)
20:24:41 <dramforever> @let data D f = D (f Int)
20:24:42 <lambdabot>  Defined.
20:24:51 <mniip> yeah, Eq1
20:25:06 <mniip> now imagine
20:25:11 <dramforever> @let instance Eq (f Int) => Eq D f where D a == D b = a == b
20:25:12 <lambdabot>  .L.hs:144:24:
20:25:12 <lambdabot>      ‘Eq’ is applied to too many type arguments
20:25:12 <lambdabot>      In the instance declaration for ‘Eq D f’
20:25:15 <dramforever> sigh...
20:25:20 <dramforever> forget about it
20:25:21 <mniip> data T t = T (t Maybe Int)
20:25:32 <edwardk> mniip: without kind equalities i can't do it in general
20:25:35 <dramforever> @let data T t = T (t Maybe Int)
20:25:37 <lambdabot>  Defined.
20:25:40 <edwardk> mniip: kind polymorphism only goes so far
20:25:47 <mniip> huh?
20:25:55 <mniip> you're saying this is impossible?
20:26:00 <dramforever> @let instance Eq (t Maybe Int) => Eq (T t) where T a == T b = a == b
20:26:01 <lambdabot>  Defined.
20:26:09 <edwardk> mniip: i'm saying that right now haskell has some limitations in this department, yes
20:26:13 <dramforever> mniip: looks...great
20:26:21 <saulzar> edwardk, Yeah.. quite problematic, I guess there must be someone who can 'veto' old packages though?
20:26:45 <edwardk> saulzar: i could apply with the hackage trustees to claim ownership of it
20:26:46 <mniip> dramforever, lambdabot probably has undecidables
20:26:52 <scshunt> just use idris
20:26:55 <edwardk> saulzar: i may do that, as it has caused enough pain
20:26:59 <mniip> which is what I'm trying to avoid here
20:27:11 <dramforever> mniip: yes
20:27:12 <mniip> edwardk, what are these limitations [caused by]?
20:27:15 * dramforever is just trying
20:27:44 <edwardk> mniip: we don't have kind classes. you can't talk about equalities between kinds if i and j are kinds you can't talk about the constraint i ~ j
20:27:55 <edwardk> this is enough that we can't give for instance a strongly typed TypeRep for Typeable
20:27:57 <edwardk> ideally we'd want
20:28:11 <edwardk> class Typeable a where typerep :: TypeRep a
20:28:12 <mniip> strongly typed?
20:28:43 <saulzar> edwardk, lens-aeson is great, though!
20:29:06 <edwardk> with things like data TypeRep :: k -> * where TypeAp :: TypeRep f -> TypeRep a -> TypeRep (f a); TypeInt :: TypeRep Int; ...
20:29:14 <edwardk> but that TypeAp is problematic
20:29:26 <edwardk> you can write it a fixed kind, but thats it
20:30:31 <dramforever> edwardk: I think you just carried mniip away from his/her interesting solution
20:30:38 <mniip> nah
20:30:39 <duckbob> edwardk: now  go = x & _Value . lookup' "b.c.e" ._Double +~ 0.5 does not change the value of b.c.e
20:30:55 <mniip> its interestingness is unimportant in context of this more generall issue
20:31:00 <dramforever> ok
20:31:13 <dramforever> forget about it
20:31:16 <dramforever> edwardk: ^
20:31:42 <mniip> edwardk, and what is getting in the way of simply promoting ~ to BOX -> BOX -> Constraint?
20:31:55 <edwardk> mniip: richard eisenberg finishing out his thesis
20:32:27 <edwardk> we need to have constraints that can live at the kind level all the way up, basically the type system gains a limited form of "* in *" which opens up some new paradoxes to consider
20:32:59 <edwardk> TypeAp :: forall x y. TypeRep (x -> y) f -> TypeRep x a -> TypeRep y a -- would seem to work at first to build such a beast, but what happens when you open that constructor?
20:33:02 <edwardk> er
20:33:38 <duckbob> edwardk: http://lpaste.net/138476
20:33:39 <edwardk> TypeAp :: forall (x :: BOX) (y :: BOX) (f :: x -> y) (a :: x). TypeRep (x -> y) f -> TypeRep x a -> TypeRep y (f a)
20:34:28 <mniip> it would have to make an x out of thin air
20:34:30 <edwardk> "{\"a\":1,\"b\":{\"c\":{\"d\":\"hello\",\"e\",2}}"  isn't legal json
20:34:49 <Kwhy> \nick 
20:35:21 <edwardk> "{\"a\":1,\"b\":{\"c\":{\"d\":\"hello\",\"e\":2}}}" -- on the other hand is
20:35:31 <duckbob> doh
20:35:33 <duckbob> thanks
20:36:06 <edwardk> mniip: well it'd have to have an (~) in scope on the kind level to talk about stuff involved there
20:36:11 <edwardk> so basically that path dead-ends
20:36:26 <edwardk> without (~) between kinds
20:36:45 <mniip> I don't see a need for infinite taxonomy when introducing kind-level ~
20:36:49 <dramforever> @let data TR (a :: k1) (b :: k2) where TypeAp :: forall (x :: BOX) (y :: BOX) (f :: x -> y) (a :: x). TypeRep (x -> y) f -> TypeRep x a -> TypeRep y (f a) -- let's try
20:36:50 <lambdabot>  .L.hs:150:9:
20:36:50 <lambdabot>      Kind variables also used as type variables: ‘x’, ‘y’
20:36:50 <lambdabot>      In the definition of data constructor ‘TypeAp’
20:36:50 <edwardk> which then opens more interesting questions, worthy of eisenberg going off and spending years figuring them out
20:37:01 <dramforever> oooh good
20:37:32 <dramforever> I know why...I seem to understand it
20:37:43 <mniip> me too
20:37:54 <mniip> even though it's 4 am
20:37:59 <duckbob> ok the working paste is here!! http://lpaste.net/138478
20:38:00 <edwardk> mniip: there are multiple versions of equality to consider. right now we get away with a very simple one.
20:38:11 <edwardk> this opens the door to things like needing John Major equality
20:38:23 <edwardk> or needing to accept "Axiom K" into our hearts
20:38:31 <edwardk> (which is equivalent)
20:38:40 <edwardk> this isn't a small step
20:38:42 <mniip> edwardk, if we go for the same equality constraint as the type one
20:39:00 <mniip> what problems do we meet
20:39:01 <edwardk> if we do pretty much anything with kinds that allows this process to keep going
20:39:03 <edwardk> which we need
20:39:21 <edwardk> Once you accept Axiom K you rule out things like HoTT
20:39:23 <duckbob> thanks for your help edwardk, id like to also congratulate you on your work. thanks
20:39:27 <mniip> also axiom K?
20:39:33 <mniip> a => b => a?
20:39:52 <edwardk> http://ncatlab.org/nlab/show/axiom+K
20:39:57 <edwardk> no
20:40:32 <mniip> aw
20:40:41 <mniip> that's slightly more complicated than I can understand
20:40:47 <edwardk> axiom k basically says that any two equalities are "propositionally equal"
20:40:57 <Jello_Raptor> quick question: In a monad transformer stack, which direction is canonically up? do IO and Identity do at the bottom of the stack or the top? 
20:40:59 <edwardk> basically it rules out equality having any interesting computational structure
20:41:35 <edwardk> mniip: the point isn't so much the particulars of this extension, so much as the fact that non-trivial issues start to crop up down this road
20:41:49 <edwardk> we may well just wind up accepting axiom k, but it is mutually incompatible with other foundations
20:42:03 <duckbob> edwardk: I think because the import is of Aeson.Lens, aeson-lens is the canonical package name, can you put a working version there too?
20:42:10 <mniip> maybe I'm thinking too practically, but isn't equality just an additional relation for unification and zonking?
20:42:24 <bnvuisdd> Is there a way to get a type from a value?
20:42:37 <edwardk> duckbob: lens-aeson is the name of the package i own. unless i petition the hackage trustees to let me take over aeson-lens i can't do anything with it
20:42:42 <bnvuisdd> typeof or something?
20:42:49 <edwardk> mniip: you're thinking too practically
20:42:56 <mniip> bnvuisdd, why do you want to do that
20:43:00 <duckbob> aha, sorry i presumed it was an earlier version of your own...
20:43:06 <bnvuisdd> mniip: looong story
20:43:11 <mniip> summarize
20:43:12 <edwardk> mniip: http://homotopytypetheory.org/book/ 
20:43:27 <duckbob> so what has mniip discovered?
20:43:30 <edwardk> the first 2 chapters of that book will explain the sort of things that get ruled out
20:43:32 <mniip> edwardk, I'd have to finish TaPL first :)
20:43:42 <edwardk> mniip: you don't need tapl for the first couple of chapters
20:43:57 <edwardk> in fact it might inform you as to why you should care more about some details about dependent types
20:44:08 <bnvuisdd> mniip: library that has a huge type composed recursively of other types, that must match the same structure but for values of corresponding types
20:44:09 <edwardk> and it gives another way to think about types entirely
20:44:30 <duckbob> it was this paste right? http://lpaste.net/138463
20:44:33 <Kwhy> \nick
20:44:42 <edwardk> bnvuisdd: we have a Typeable class which enables you to extract a representation of your type
20:44:50 <edwardk> without a Typeable constraint on 'a' you can't say anything about 'a'
20:44:58 <mniip> bnvuisdd, tell me more about those composed types
20:44:59 <edwardk> other than whatever instances you have on it
20:45:16 <bnvuisdd> edwardk: can I pass this extracted represenation to a type constructor?
20:45:38 <mniip> bnvuisdd, no, type representations are values
20:45:39 <edwardk> bnvuisdd: you can pass the extract representation toa type constructor, or even the Typeable instance (which is more useful)
20:45:41 <mniip> they live at runtime
20:45:50 <edwardk> er to a data constructor
20:45:53 <edwardk> sorry
20:45:55 <edwardk> misread you
20:45:58 <bnvuisdd> oh
20:46:03 <bnvuisdd> okay I need it at compile time
20:46:17 <mniip> that makes very little sense
20:46:26 <bnvuisdd> well
20:46:28 <edwardk> bnvuisdd: why don't you show folks what it is you are trying to do rather than describe precisely how you currently think you should accomplish it
20:46:33 <bnvuisdd> the library im talking about is servant
20:46:43 <bnvuisdd> edwardk: have you used servant?
20:46:53 <edwardk> bnvuisdd: i haven't, but others here i'm sure have, brb
20:47:04 <bnvuisdd> basically in this library the route is a type, and the handler is a value
20:47:11 <bnvuisdd> and they must match
20:47:16 <bnvuisdd> and you have to define them separatelly
20:47:29 <bnvuisdd> so im trying to write something to extract the type from the value
20:47:40 <bnvuisdd> automate the process a bit
20:47:45 <duckbob> edwardk: shouldnt I be importing Lens.Aeson, rather than Aeson.Lens?
20:48:20 <bnvuisdd> mniip: any ideas?
20:48:25 <mniip> bnvuisdd, I'm currently looking at servant haddocks, can you clarify on "the route is a type and the handler is a value" ?
20:48:52 <bnvuisdd> mniip: http://haskell-servant.github.io/tutorial/api-type.html
20:48:58 <bnvuisdd> look at UserAPI
20:49:12 <bnvuisdd> it is a type that represents the route
20:49:20 <bnvuisdd> route or routes
20:49:41 <bnvuisdd> the second example of UserAPI combines 2 routes
20:50:17 <bnvuisdd> and the handler is basically a value the matches this type and is defined elsewhere
20:50:45 <mniip> okay so a route is composed with the :> datum
20:51:00 <bnvuisdd> yes
20:51:21 <bnvuisdd> :> and <:> are type operators
20:51:41 <bnvuisdd> err :> and :<|>
20:51:56 <mniip> infix type constructors *
20:52:12 <bnvuisdd> ya
20:52:30 <mniip> okay and
20:53:17 <mniip> your problem is?
20:54:04 <bnvuisdd> mniip: here is an example of an application: https://github.com/haskell-servant/servant/blob/master/servant-examples/hackage/hackage.hs
20:54:13 <bnvuisdd> or.. 1 sec
20:54:50 <bnvuisdd> mniip: here is a better example: https://github.com/haskell-servant/servant/blob/master/servant-examples/auth-combinator/auth-combinator.hs
20:55:04 <bnvuisdd> at line 45 the routes type is composed
20:55:21 <mniip> okay
20:55:22 <bnvuisdd> at line 62 the handlers are composed
20:55:36 <bnvuisdd> these have to be composed in the correct order
20:55:48 <bnvuisdd> and they are defined separately from each other
20:55:59 <bnvuisdd> which makes it kind of awkward and annoying to use
20:56:55 * dramforever wonders if we could give each handler an individual type signature
20:57:13 <dramforever> oh that's not going to solve anything
20:57:28 <bnvuisdd> you can
20:57:42 <bnvuisdd> but it doesnt solve the issue because you still need to define the routes type again
20:58:13 <mniip> okay so
20:58:25 <bnvuisdd> as you can see on line 68 the api and server are linked 
20:58:27 <mniip> data a :<|> b = a :<|> b
20:58:29 <mniip> and?
20:58:40 <ttt_fff> http://bitcask.forge.ocamlcore.org/ <-- why does ocaml have a native bitcask impl but haskell deos not?
20:59:23 <bnvuisdd> mniip: so because of this linkage in the 'serve' function you need to have both a Proxy RouteType value and a Server RouteType value
20:59:32 <bnvuisdd> its kind of a duplication
20:59:59 <bnvuisdd> If I could extract RouteType from a value of type (Server RouteType) I could make it easier
21:01:27 <mniip> bnvuisdd, interesting
21:01:36 <mniip> I see what you mean
21:01:52 <bnvuisdd> :)
21:02:02 <mniip> I'm not sure what is the reason for that though
21:02:17 <saulzar> What's the simplest "extensible" system which will let me have an  HasA r ::  A -> r, and some way of tupling it up e.g.   HasA r => HasA (r, s) :: A -> (r, s)     <-- works for one side of the tuple, but it overlaps. I could use HList etc. I realize, but seems quite heavy weight.
21:03:16 <mniip> bnvuisdd, just declare a wrapper around 'serve' if you're that lazy
21:03:18 <bnvuisdd> mniip: one of the central points of this library seems to be that routes are defined on the type level
21:03:26 <mniip> I'm off I guess
21:03:36 <bnvuisdd> mniip: how?
21:03:43 <saulzar> Or more to the point, I don't know which one I should use in a library - because it seems like there's no de-facto choice for it
21:03:50 <bnvuisdd> mniip: you would still need to extract a type from a value somehow
21:04:03 <bnvuisdd> and there is still the issue of composing routes and handlers in the same order
21:05:31 <mniip> bnvuisdd, serve' :: HasServer layout => Server layout -> Application
21:05:58 <bnvuisdd> mniip: thats just a type signature, now lets see an implementation
21:06:41 <bnvuisdd> mniip: its not as easy as you might think
21:07:06 <mniip> serve' l = serve (mkProxy l) l where mkProxy :: Server a -> Proxy a
21:07:10 <mniip> mkProxy _ = Proxy
21:07:28 <mniip> or actually
21:07:37 <mniip> what am I thinking
21:07:43 <mniip> type inference to the rescue
21:07:48 <mniip> serve' l = serve Proxy l
21:08:17 <bnvuisdd> I'm pretty sure that won't work
21:08:40 <mniip> why not
21:08:54 <mniip> bnvuisdd, do you know what Proxy is
21:08:59 <bnvuisdd> yes
21:09:25 <mniip> then I don't see where you see a problem
21:09:41 <bnvuisdd> im pretty sure it will not be able to construct Proxy instancew
21:09:50 <mniip> Proxy instance?
21:09:53 <bnvuisdd> you need to specify a type, it wont infere it
21:10:03 <mniip> yes it will
21:10:19 <mniip> serve :: HasServer layout => Proxy layout -> Server layout -> Application
21:10:30 <mniip> you provide a 'Server layout'
21:10:44 <mniip> from which 'layout' will be inferred
21:10:55 <dmj`> I love all this servant talk
21:11:30 <mniip> dmj`, a person who doesn't know shit about servant is explaining to someone else with the same issue
21:12:05 <bnvuisdd> im going to try what you suggested 1 sec
21:13:35 <mniip> bnvuisdd, go figure out how type inference works, I'm off to bed
21:18:56 <lf94> HSpec looks like a really nice test suite.
21:19:07 <lf94> HUnit looks a lot more industrial though.
21:19:12 <lf94> Any preferences here?
21:19:14 * hackagebot yesod-bin 1.4.13.2 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.4.13.2 (MichaelSnoyman)
21:19:35 <Lokathor> i've had a tough time in the past getting cabal to interact with unit testing and quickcheck
21:19:49 <Lokathor> all the guides i read seemed to be very out of date a year ago when i tried
21:27:14 <bnvuisdd> mniip: fyi: http://lpaste.net/8391367181480230912
21:29:36 <bnvuisdd> and Proxy has to be of the type Proxy layout not Proxy Server layout
21:31:28 <c_wraith> bnvuisdd: then use a helper or RankNTypes
21:31:35 <c_wraith> err, ScopeTypeVariables, not RankNTypes
21:31:46 <c_wraith> *ScopedTypeVariables.  I'm not typing well today.
21:32:18 <c_wraith> :t Proxy
21:32:19 <lambdabot> forall (k :: BOX) (t :: k). Proxy t
21:32:22 <bnvuisdd> c_wraith: how?
21:33:15 <c_wraith> > let toProxy :: f x -> Proxy x ; toProxy _ = Proxy in toProxy [()]
21:33:17 <lambdabot>  Proxy
21:33:20 <c_wraith> heh.
21:33:22 <c_wraith> whoops
21:33:28 <c_wraith> :t let toProxy :: f x -> Proxy x ; toProxy _ = Proxy in toProxy [()]
21:33:29 <lambdabot> Proxy ()
21:33:41 <c_wraith> That's the helper function version
21:34:42 <dramforever> hello, I have a question
21:35:02 <dramforever> ouch sorry wrong channel
21:35:06 <dramforever> lol
21:36:05 <bnvuisdd> c_wraith: still getting the same error I posted above
21:37:22 <c_wraith> bnvuisdd: it'd be nice it you pasted it again anyway, just so I can see how you changed the code
21:38:53 <bnvuisdd> c_wraith: http://lpaste.net/8391367181480230912
21:40:56 <c_wraith> bnvuisdd: oh.  Heh.  What I pointed at was definitely a bug, but that's not the one the error message is reporting.
21:41:10 <c_wraith> bnvuisdd: the error message is saying that it has no way to determine what concrete type layout is
21:41:33 <c_wraith> bnvuisdd: and it needs a concrete type to pick the HasServer instance to use
21:41:53 <bnvuisdd> oh
21:42:18 <c_wraith> bnvuisdd: what's strange is that I would expect it to be able to infer the exact type from the type of server
21:42:42 <c_wraith> bnvuisdd: this is Servant code?
21:42:46 <bnvuisdd> c_wraith: yes
21:42:53 <c_wraith> Oh, heh, I just read the imports.  Could have done that sooner
21:43:23 <bnvuisdd> someone told me that servant has some sort of type level hackery which might make such a function impossible to write
21:44:16 <c_wraith> It might.  That error message is a bit odd.  I can't decode it without spending more time looking at the definitions of serve and ServerT.  And I need to be leaving now, so I can't look further.
21:44:30 <bnvuisdd> okay, I'm off too
21:46:25 <dramforever> interesting...
21:46:42 <dramforever> DeriveAnyClass seems to interfere with GeneralizedNewtypeDeriving
21:49:15 * hackagebot conduit-combinators 1.0.3 - Commonly used conduit functions, for both chunked and unchunked data  https://hackage.haskell.org/package/conduit-combinators-1.0.3 (MichaelSnoyman)
21:49:23 <lpaste_> dramforever pasted “funny error message” at http://lpaste.net/138484
21:51:22 <tjc> hey everyone, I'm trying to build HP but am getting stuck on "Preprocessing library hscolour" with an error about ghc not supporting single-file style package databases, can someone give me any pointers?
21:51:27 <dramforever> oooh this bug https://ghc.haskell.org/trac/ghc/ticket/10598
21:53:12 <pacak> tjc: Wrong version of cabal?
21:53:36 <pacak> tjc:  cabal-install
21:54:15 * hackagebot yesod-static 1.5.0.2 - Static file serving subsite for Yesod Web Framework.  https://hackage.haskell.org/package/yesod-static-1.5.0.2 (MichaelSnoyman)
21:55:34 <tjc> cabal is at 1.20 and I just did cabal install cabal-install but nothing changed
22:01:03 <dibblego> how might I get a list of all things exported by Prelude?
22:01:27 <dramforever> :browse Prelude
22:01:28 <solrize> :browse Prelude
22:01:29 <dramforever> in ghci
22:23:44 <dibblego> why can I import Prelude(foldMap) but not import Prelude(fold) ?
22:23:58 <dramforever> because there isn't such a function
22:24:01 <dramforever> :t fold
22:24:02 <lambdabot> (Foldable t, Monoid m) => t m -> m
22:24:07 <dramforever> sorry there is...
22:24:10 <dibblego> is too
22:24:20 <dibblego> foldMap id
22:24:21 <dramforever> then there isn't such a function in Prelude
22:24:46 <dibblego> right, why?
22:24:58 <dramforever> who knows
22:25:15 <shachaf> Because fold isn't in Prelude.
22:25:20 <dibblego> some methods of Foldable are exported, but not all
22:25:30 <dibblego> why is foldMap exported, but not fold?
22:26:33 <dibblego> https://i.imgur.com/yyfKc2E.png is there a specific reason why Foldable(foldMap) is exported but Foldable(fold) is not? 
22:27:29 <shachaf> fold is a pretty common name to take up?
22:27:50 <dramforever> because nobody uses fold?
22:28:04 <dibblego> shachaf: my guess too
22:28:09 <dibblego> however, foldr is also not exported
22:28:25 <shachaf> Not sure why foldMap is exported.
22:28:27 <dibblego> dramforever: do too
22:28:34 <dramforever> who knows
22:28:50 <dibblego> ok np cheers
22:30:22 <dibblego> actually, foldr is exported, foldr' is not
22:31:22 <shachaf> The idea with re-exporting things from Foldable/Traversable to Prelude was not to take up any more namespace.
22:31:33 <shachaf> Prelude already exported foldr, and didn't export foldr'; only the types changed.
22:32:41 <dibblego> yeah, got it
22:45:21 <eipi-1_> hi
22:46:04 <liste> hi
22:54:18 * hackagebot mongoDB 2.0.6 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  https://hackage.haskell.org/package/mongoDB-2.0.6 (VictorDenisov)
22:54:22 <johnw> I hope foldl' is added to the exports in some version
22:56:46 <shachaf> Prelude should be kept small.
22:57:04 <johnw> I'll trade foldl for foldl'
22:57:33 <dramforever> johnw ++
22:57:43 <dibblego> I got fed up with hiding all the unsafe functions
23:01:05 <dramforever> hmm...I'm doing some STM stuff
23:01:23 <dramforever> ended up using hungarian notations to separate the values and TVars
23:01:25 <johnw> retry
23:01:34 <dramforever> ?
23:01:37 <dramforever> oh
23:01:45 <dramforever> no I don't use retry explicitly
23:01:47 <johnw> if you're doing some STM stuff and failing... ;)
23:02:00 <johnw> ah, I use retry fairly often; it's pretty magical sometimes
23:02:01 <dramforever> but this hungarian notation is...weird
23:02:19 <dramforever> johnw: I don't need to, it's a rather simple application
23:02:22 <johnw> the true purpose of hungarian notation can be useful
23:02:31 <dramforever> yep
23:02:46 <dramforever> like I have vcinfo for client info
23:02:57 <dramforever> and I have cinfo <- readTVar vcinfo
23:03:02 <dramforever> to get it out from the TVar
23:03:20 <dramforever> I think lambdacase could have eliminated a few of those
23:03:24 <johnw> i often do the same
23:03:38 <dramforever> =)
23:03:47 <dramforever> yes this hungarian notation is good
23:03:53 <johnw> like mres <- x; case mres of Just res -> ...   just to avoid shadowing and having to invent new names that only live very briefly
23:04:11 <dramforever> it frees you from making up all kinds of names that all mean "client info"
23:04:16 <johnw> yeah
23:04:27 <johnw> and guides your reader that they are directly connected
23:04:32 <dramforever> yep
23:04:55 <dramforever> hey this is the Apps and Systems distinction, right?
23:05:01 <johnw> ?
23:05:14 <dramforever> https://en.wikipedia.org/wiki/Hungarian_notation
23:05:19 <dramforever> Systems vs. Apps Hungarian
23:05:25 <johnw> yes
23:05:38 <dramforever> however it's a bit systems
23:05:54 <dramforever> because of haskell's type system
23:06:34 <johnw> yeah, that's true, especially if you use newtypes
23:06:38 <dramforever> =)
23:07:43 <johnw> I once worked on a project where anything derived from Object, i.e., all non-fundamental values, were prefixed by o
23:09:01 <dramforever> javascript?
23:09:09 <johnw> Java
23:09:13 <dramforever> oh oh
23:09:18 * hackagebot pandoc-citeproc 0.7.3 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.7.3 (JohnMacFarlane)
23:09:55 <johnw> I like that types in Haskell make such notations irrelevant most of the time, but you do run into times where a value will have a "family" of directly related entities
23:10:56 <dramforever> actually there are lots of variable naming schemes much worse than systems hungarian
23:11:58 <johnw> used in Haskell code?
23:12:27 <dramforever> everywhere
23:12:44 <dramforever> forget about it it's useless to talk about them
23:12:58 <johnw> agreed
23:13:02 <johnw> back to STM
23:13:26 <dramforever> no more STM questions
23:14:03 <johnw> too bad, writing STM code can be very fun
23:14:13 <dramforever> yes it is
23:14:38 <dramforever> I like how the type system yells at me "this value is synchronized, you can't just read it that way"
23:16:12 <dramforever> but only someone who can read type errors can understand that, which rules out haskell newbies because they've never seen such a comprehensive error message
23:17:32 <dramforever> well who knows, forget about it
23:20:52 <ttt_fff> is there any kv store written in pure haskell ?
23:22:04 <johnw> ttt_fff: you may need to be more specific
23:22:16 <johnw> fsvo "kv store", Data.Map is an answer
23:22:25 <ttt_fff> disk backed kv store
23:22:36 <johnw> do you need every part of it to be in Haskell?
23:22:42 <dramforever> acid-state maybe?
23:22:49 <dramforever> I've never tried
23:22:53 <ttt_fff> I think if we lok at complexity of adatabases, highest form is SQL + ACID; middle is nosql; and simplest is just a dumbass kv sstore, like say, bitcask
23:22:55 <johnw> or a Data.Map backed by acid-state
23:22:57 <ttt_fff> but I can't find any written in haskell
23:23:18 <dramforever> johnw ++
23:23:26 <kadoban> ttt_fff: "complexity" in what sense exactly?
23:23:34 <ttt_fff> how ahrd to implement
23:23:47 <ttt_fff> johnw: hmm, I guess I should read the acid state code
23:24:35 <ttt_fff> acid state is like 3637 LOC
23:24:57 <dramforever> lemme see...
23:25:09 <ttt_fff> I'm not asking a question; I'm making a statement
23:25:09 <dramforever> what about a log-file based Data.Map?
23:25:11 <ttt_fff> using wc -l
23:25:24 <ttt_fff> is log-file a hackage packge?
23:25:29 <dramforever> no
23:25:35 <dramforever> I mean just log every operation
23:25:39 <ttt_fff> a kv store, like bitcask, is just logging + an in memory key -> loc mapping
23:25:40 <kadoban> What's the point of this exactly? Just something for you to learn with or whatever?
23:26:07 <ttt_fff> I want to implement datomic on top of it
23:27:03 <dramforever> maybejust write every operation to a log file, as well as having a Data.Map in memory
23:27:44 <dramforever> so say we did M operations, and there are at most N elements, when we load the log file we take O(M*log N) time
23:28:05 <dramforever> and we can periodically rewrite the log file so that M doesn't go very much larger than N
23:28:14 <dramforever> doesn't look too bad...
23:28:40 <dramforever> ttt_fff: no, use some already existing solution
23:29:06 <dramforever> he...llo?
23:29:52 <ttt_fff> fuck it
23:29:55 <ttt_fff> maybe i just impelment bitcask
23:30:00 <dramforever> sigh...
23:30:02 <ttt_fff> dramforever: sorry, did not see a question mark
23:30:08 <ttt_fff> dramforever: was not aware you were asking a question
23:30:16 <dramforever> no I'm not asking a question
23:30:22 * ttt_fff donates 10 ?'s to dramforever
23:30:31 * ttt_fff takes the ?'s back
23:30:48 <dramforever> I said "he...llo" because I thought my connection was lost
23:30:55 <dramforever> sorry
23:30:57 <ttt_fff> oh
23:31:16 <ttt_fff> you know, it's awkward enough when I'm walking on the street, someone on the other side waves and says hello
23:31:28 <ttt_fff> and I'm mentally trying to figure out "who the fuck is this person" while slowly guestering
23:31:32 <ttt_fff> only to realize they were talking to the person behind me
23:31:39 <ttt_fff> .... but I had never thought this would happen on IRC ...
23:31:40 <dramforever> but we are sitting in the same room
23:31:44 <ttt_fff> please consider using 'ping' :-)
23:31:49 <dramforever> oh
23:31:52 <pacak> Haskell?
23:31:57 <dramforever> how could I have forgotten about that
23:32:11 <dramforever> pacak: well it's related to a question related to haskell
23:32:26 <ttt_fff> do any of https://hackage.haskell.org/packages/#cat:Logging log to file ?
23:33:00 <dramforever> ttt_fff: so you made up your mind to implement a kv store?
23:33:16 <ttt_fff> I looked at the erlang bitcask code, it's only 4K LOC; and it's fucking brilliant
23:33:26 <ttt_fff> so yeah, I'm probably going ot rewrite it in haskell
23:33:32 <dramforever> good luck =P
23:33:39 <ttt_fff> minus the merging part, as it's not needed for datomic; since there's no 'erase'; there's only "add new facts"
23:34:05 <dramforever> what about "modify old facts"?
23:34:08 <dramforever> do you have them?
23:35:29 <ttt_fff> that's datomic's problem
23:35:32 <ttt_fff> datomic can run on riak
23:35:35 <dramforever> wow
23:35:46 <ttt_fff> datomic doens't 'update'; it just records new facts, and you make queries of the form (at time t) [query]
23:36:04 <dramforever> then looks like you don't even need to rewrite the log
23:36:07 <ttt_fff> http://blog.fogus.me/2012/03/05/datomic/
23:36:38 <ttt_fff> so there's no 'merging'; there's just (1) log to file, and (2) have a in memory "key => which file, which offset" apping, and (3) tools for rebuilding the "key => while file, which offset" map upon crash recovery
23:36:39 <dramforever> ttt_fff: so it's persistent?
23:36:40 <dramforever> wow
23:37:24 <ttt_fff> the only part I'm missing is: "what is haskell's semantics for it's IO when the prog crashes halfway through"
23:37:28 <dramforever> that doesn't look very hard, and seems surprisingly useful
23:37:58 <nshepperd> you record everything forever?
23:38:58 <ttt_fff> in datomic, yes; in bitcask, there's a 'merge/garbage collection' op which rewrites a new segment, and removes the old semgents
23:39:39 <dramforever> isn't that exactly what I was talking about earlier?
23:39:48 <dramforever> well, at least almost exactly
23:40:19 <ttt_fff> dramforever: yeah, bitcask is not as complicated as, say dynamo; it's a very simple + cool idea
23:40:34 <ttt_fff> so easy even people on irc can reinvent it :-)
23:41:07 <dramforever> =)
23:41:38 <dramforever> "people on irc" sounds a bit insulting
23:42:53 <ttt_fff> dramforever: I feel like someone neds to write a book titled "how to build shit with just a kv store", instead of telling everyone that they need SQL + transactions + a full fledge DB to do anything useful
23:43:11 <ttt_fff> user accounts? key = username, value = {first name, last name, password, email}
23:43:16 <dramforever> "transactions" you sure you don't need them?
23:43:36 <ttt_fff> i was thiking the other day; you know what's the most fucking distributed system ever?
23:43:37 <ttt_fff> email
23:43:41 <liste> "how to build _shit_ with just a kv store"
23:43:42 <ttt_fff> does email need distributed transactions?
23:43:43 <ttt_fff> no
23:44:02 <liste> ttt_fff that's because each email is atomic
23:44:14 <dramforever> wait lemme see
23:44:36 <ttt_fff> yet someone, using email people can solve coordaionat problems, lie "when should we get lunch for the 5 of us?"
23:44:45 <ttt_fff> and questions like "hmm, how can we split this project into 4 parts"
23:44:57 <ttt_fff> things that distributed db people will tell me can not be acheived
23:44:58 <liste> ttt_fff that's not the email doing all the heavy lifting, that's people
23:45:08 <dramforever> wait lemme see...
23:45:14 <kadoban> ttt_fff: … that's missing so many points that I can't imagine you're serious?
23:45:41 <ttt_fff> liste, kadoban: no no, i'm serious; I have this idea where there are these 'supervisor erlang threads', that basically help people coordinate stuff
23:45:42 <dramforever> "powerful full-fledged db" no we don't need that
23:45:51 <ttt_fff> instead of transactions that lock the entire db
23:45:56 <dramforever> "transactions" yes they are very important aren't they?
23:46:07 <dramforever> no I don't think transactions need to lock the entire db
23:46:14 <dramforever> I think STM-style is good enough
23:46:46 <dramforever> like okay so this transaction read keys a b c and wrote to x y z
23:46:52 <liste> ttt_fff what if two people want to get lunch at different times? they resolve the issue using their brains
23:46:56 <dramforever> oh f**k the value of a has changed
23:47:04 <dramforever> ...retry...
23:47:15 <dramforever> ttt_fff: much nicer than locks
23:48:18 <jhrcek> Hello. I have a question: how to declare class constraint in type signature? I'm using graphviz package and I want to generalize one type from "testGraph :: DotGraph String" to something like "testGraph :: PrintDotRepr gr => gr String". The problem is that PrintDotRepr has two type arguments and in my case the second argument is String (meaning node type of graph is String). 
23:48:31 <jhrcek> I'm getting type error:
23:48:32 <jhrcek>  Expecting one more argument to ‘PrintDotRepr gr’
23:48:32 <jhrcek>     Expected a constraint,
23:48:32 <jhrcek>       but ‘PrintDotRepr gr’ has kind ‘* -> Constraint’
23:48:32 <jhrcek>     In the type signature for ‘testGraph’:
23:48:32 <jhrcek>       testGraph :: PrintDotRepr gr => gr String
23:48:50 <jhrcek> Here's haddock for the type class in question : http://hackage.haskell.org/package/graphviz-2999.17.0.2/docs/Data-GraphViz-Types.html#t:PrintDotRepr
23:49:05 <dramforever> just use testGraph :: PrintDotRepr gr String => gr String
23:49:09 <dramforever> that should make sense
23:49:49 <ttt_fff> funName :: Constraint => type-sig
23:49:54 <dramforever> jhrcek: wait how come you haven't thought of that?
23:50:26 <jhrcek> dramforever: I tried this, but this gives another erro:r Non type-variable argument
23:50:27 <jhrcek>       in the constraint: PrintDotRepr gr String
23:50:33 <liste> ttt_fff I suppose those threads would make the system much more complex than just transactions or locks
23:50:39 <dramforever> yes FlexibleContexts
23:51:09 <ttt_fff> liste: I don't know if you have read the datomic white paper, but the idea is as follows: tehre's 3 parts, clients + transactor + storage
23:51:28 <ttt_fff> liste: tradiciontally, the storage has acid + transactions + ... ; but now, the stroage is just a dumb kv store
23:51:35 <ttt_fff> the clients can only read from the stroage, but not modify it
23:51:51 <dramforever> hmm wait that sounds plausible
23:51:59 <ttt_fff> if they need to update shit, they send stuff to the transactor, whose only job is to write to the storage; the transactor also serializes stuff, this sorta proviginx 'transactions'
23:52:23 <dramforever> ttt_fff: yes that is plausible
23:52:31 <liste> yeah, ma
23:52:34 <dramforever> ttt_fff: wait no
23:52:43 <liste> it makes sense, but it still is more than a KV store
23:52:44 <dramforever> what if we tried to put in two things
23:52:56 <dramforever> but just after the first is written, the server crashed
23:53:03 <dramforever> what do you do to recover it?
23:53:14 <dramforever> oh wait f**k, you can recover it
23:53:46 <dramforever> ttt_fff: wow that's impressive
23:54:07 <ttt_fff> on crash, all the 'dumbass storage' has to do is to read the logs, and recosntruct the "key => file/offset" table
23:54:16 <ttt_fff> dramforever: yeah, datomic + bitcask are fucking brilliant ideas
23:54:55 <dramforever> ttt_fff: that also sounds like a good idea for a medium-sized haskell project that anyone could do
23:55:00 <jhrcek> dramforever: Ahh, FlexibleContexts. thanks for kicking me in the right direction :)
23:55:01 <dramforever> for some value of "anyone"
23:55:10 <dramforever> jhrcek: but didn't ghc tell you that?
23:55:17 <ttt_fff> dramforever: are you good enough to do such a project?
23:55:24 <dramforever> dunno
23:55:28 <EvanR> datomic is horrible
23:55:54 <dramforever> but let me get this straight:
23:56:13 <dramforever> you need an insert-only kv store, right?
23:56:34 <ttt_fff> yeah, the entire history is stored
23:56:49 <ttt_fff> which it must be, because if you want to be able to query the history / prevous points in time, you have to store entire history
23:57:20 <jhrcek> dramforever: It did. I missed it in the many-page error :)
23:57:27 <dramforever> =)
23:58:39 <dramforever> so with Data.Map reconstructing the map from the log is linear time
23:58:48 <EvanR> datomic, despite the brochure, is slow, unwieldy, undocumented, unsupported, closed source, missing many features, inaccessible
23:58:49 <dramforever> inserting each element is logarithmic
23:58:52 <ttt_fff> it can be better, if you have check points
23:59:05 <dramforever> wait it can't be
23:59:06 <EvanR> and java/clojure only
23:59:20 * hackagebot conversion 1.1.1 - Universal converter between values of different types  https://hackage.haskell.org/package/conversion-1.1.1 (NikitaVolkov)
23:59:23 <dramforever> ttt_fff: you have linear amount of data to restore
23:59:24 <ttt_fff> EvanR: we're talkinb about how hard it would be to re-implement datomic in haskell,
23:59:27 <ttt_fff> using a bitcask like as a backend
23:59:45 <EvanR> ah
23:59:54 <ttt_fff> dramforever: if you just want the 'most up to date view', you can use check points; if you want to query the entire history, then yes, you need linear time to reconstruct that mapping
