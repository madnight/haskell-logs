00:45:54 * hackagebot HGamer3D 0.6.0 - Toolset for the Haskell Game Programmer  https://hackage.haskell.org/package/HGamer3D-0.6.0 (PeterAlthainz)
00:47:32 <Ongy> Hi I am currently working on a haskell package for linux netlink and ran into a problem: The sendmsg for netlink sometimes has an error ENOBUFS after I sent a few messages. It seems to fail deterministicly, but I only tested it by hand.
00:49:54 <Ongy> another thing I noticed is, that I cannot use any netlink related functions with ghci. If I try to send a message to netlink in ghci it fails with ENOBUFS. The same function works when I compile it with ghc and run the linked executable
00:50:18 <kaictl> So, I'm trying to get ghci to source ~/.ghci and .ghci in the directory that i'm starting ghci, but it's not being sourced for some reason.
00:58:18 <EvanR> question: if somebody were to refer to "Wadler's paper" which paper might that be?
00:58:39 <EvanR> like which one is most popular or influential enough to be referred to ambiguously like that
01:01:20 <ReinH> @google monads for functional programming wadler
01:01:22 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
01:01:22 <lambdabot> Title: Monads for functional programming
01:01:25 <ReinH> Possibly this one
01:36:05 <siwica> How do I get information on a particular type class using ghci?
01:37:18 <EvanR> :info Num
01:39:02 <ttt_fff> > runQ [| \x -> \x |]
01:39:04 <lambdabot>  <hint>:1:7: parse error on input ‘|’
01:39:13 <ttt_fff> lambdabot does not support TH ?
01:40:48 <siwica> EvanR: is there a way to omitt the information on the type class instances with :info?
01:42:09 <EvanR> what are you really trying to do
01:43:07 <siwica> EvanR: Just want to retreive the class definition
01:43:23 <siwica> don't care about the long list of instances
01:48:43 <EvanR> to get the code, then parse the source code isntead of ghci output
01:49:21 <EvanR> alternatively why do you want this class definition
01:53:27 <greves> seems like 95% of the work of haskell is making sure the types match
01:53:36 <greves> is that an accurate statement? haha
01:54:23 <srhb> greves: 95 is probably a bit high, but the general idea yeah.
01:56:35 <ttt_fff> alright, I'm about 30% done reading through the top 10 links on google about TH
01:58:48 <greves> how do you actually do development when stuff won't compile or load in ghci if it's wrong? like for me a lot of time in other languages would be in a repl changing code until it works
01:58:57 <greves> but in haskell i can't get into a repl because it won't compile
01:59:20 <srhb> greves: The nonworking code isn't really interesting to have loaded. You already know the error is there.
01:59:41 <srhb> greves: If you're working on transforming some A to B you can use undefined as a placeholder if you're not done with some part of it.
01:59:43 <jle`> greves: yeah, the time you would spend debugging running code in other languages is now time spent debugging code before it can compile
01:59:46 <bennofs> greves: comment out the non-working part / replace it with undefined :)
02:00:12 <jle`> only debugging at compile-time is a lot easier than debugging at run-time
02:00:43 <bennofs> greves: or if you have a recent enough GHC version, you can also used "type holes": if you write _foo at some point, GHC will tell you the type of the expression expected at that point
02:00:45 <jle`> compiler errors are the errors are errors you'd get if you ran the code anyway
02:01:25 <greves> ah that's a good trick bennofs, thanks
02:01:33 <srhb> You CAN defer type errors to runtime nowadays, but really you'll probably just be wasting time debugging a runtime of something the type system could have told you is wrong. :-)
02:02:05 <jle`> you can think of compiler errors as someone going, "yup, this is definitely going to be a bug...you missed this.  here's why it would be a bug, and here's how you can fix it."
02:02:17 <jle`> on one hand you miss the opportunity to run the program and spend hours hunting down the bug
02:02:20 <bennofs> greves: yeah, if you really want your dynamic type errors, you can use -fdefer-type-errors. But never use that for the final version of the program! :) (and don't be suprised if something breaks...)
02:02:23 <jle`> which may show up some times or not show up
02:02:39 <jle`> on the other hand, you get to fix the bug now and have it work :)
02:02:42 <EvanR> ReinH: thx
02:03:01 <greves> yeah i get the point of it, it's just hard / i'm not used to working this way
02:03:11 <srhb> greves: Sure! It takes a while :)
02:03:31 <greves> so like now i've got markdown from Text.Markdown, it returns type Html, which I need to be Text
02:03:45 <Myrl> What variable should I use if I want to bind a variable just so that I can insert it again? Say, `add1ToFst ((x,y):xs) = (x + 1, y):add1ToFst xs` in this example, y is such variable.
02:03:46 <greves> because putting in a type hole shows that spock is expecting Text here
02:04:04 <srhb> greves: That's a good approach.
02:04:12 <greves> but the solution for Html -> Text is not obvious
02:04:34 <srhb> greves: That's when you do a type search.
02:04:56 <srhb> greves: Hoogle may or may not have the relevant info, but if you had the libraries locally you'd probably find a Html -> Text function instantly.
02:05:10 <greves> how would i do tha?
02:05:13 <srhb> greves: http://hoogle.haskell.org/?hoogle=Html+-%3E+Text&scope=set%3Astackage
02:05:18 <greves> (use the libraries locally i mean?)
02:05:25 <srhb> I haven't actually bothered ever doing that, so I don't know.
02:05:34 <srhb> In this case, the online hoogle is enough to find solutions :)
02:06:57 <srhb> greves: Ie you need renderHtml from Blaze.
02:07:50 <srhb> Assuming that's Blazes Html type.
02:07:57 <greves> i think so
02:07:59 <srhb> Unfortunately it can't help us with overlapping names. :-)
02:08:53 <greves> yargh still not correct, since markdown expects Data.Text.Internal.Lazy.Text and i've only got Text
02:09:12 <srhb> There's an unfortunate name overlap between lazy and strict text, but you can convert between them.
02:09:17 <greves> this is what i meant by 95% of the time, although i suppose it gets easier as you go :P
02:09:47 <srhb> Yes, this little lazy/strict text problem is really annoying though. You get used to it, but it's an annoying design error
02:10:14 <Ongy> greves: I started to use haskell because of a lecture and it took me taking on haskell after around 5 months of "learn how to do this" to finally be able to use it in a real world example
02:10:44 <Ongy> but now I think it is way better to have so many compile time errors compared to run into them during execution
02:11:04 <srhb> greves: anyway, use toStrict from Data.Text.Lazy which has the unfortunate type Text -> Text
02:11:34 <srhb> Woops, other way around
02:12:20 <srhb> Actually, wait. You had Html and you wanted Text. And you used renderHtml, right? And you need a lazy text? That's what it already does, I think. Perhaps there's more than one version of that function.
02:12:49 <srhb> greves: Are you using Text.Blaze.Html.Renderer.Text?
02:13:09 <greves> i'm just trying to read in a markdown file and figure out what types it has to go through to work
02:13:29 <greves> so there's a bunch of different `readFile's to choose from (String, Text, Lazy.Text)
02:13:55 <srhb> greves: Right, but. You had foo :: Html. Then you wanted a lazy text. Then you used renderHtml from that module I just mentioned, right?
02:14:01 <srhb> That should give you a lazy Text.
02:14:09 <greves> and then each thing has to match up going through `markdown', `renderHtml', and spock's `html'
02:14:16 <srhb> Yes, of course. :)
02:14:38 <greves> i think i need a map or something :P
02:14:44 <srhb> Oh hang on. Did you annotate something as a strict Text?
02:15:14 <greves> i'm not sure what i did because i tried a bunch of things and every time the errors get worse haha
02:15:25 <srhb> Time to stop and be systematic about it then.
02:15:36 <greves> yeah
02:15:40 <srhb> I've asked you some relevant questions that should solve the problem entirely. :)
02:17:25 <srhb> OK, I think I got your original question backwards
02:17:32 <srhb> You have Text and you're going to Html, not the other way around.
02:17:42 <srhb> Sorry. :)
02:23:04 <srhb> greves: (ie. you are right about having to choose the right way to read it in, or converting the strict Text to lazy before using markdown.)
02:23:31 <lpaste_> greves pasted “reading markdown” at http://lpaste.net/139890
02:23:43 <greves> ok trying to be more systematic
02:23:56 <srhb> greves: Forget what I said about renderHtml. I got your question backwards. I thought you had Html and wanted Text, but you have Text and want Html
02:24:09 <srhb> Right?
02:24:30 <greves> i have (Lazy) Text and want (normal) Text, but it goes through Html because of the markdown function
02:24:42 <greves> see paste
02:24:48 <srhb> greves: anyway, mdFileContents has a lying type signature
02:25:04 <srhb> greves: Why did you comment out the right one?
02:25:25 <srhb> greves: You forgot IO :)
02:25:47 <greves> oh you're right, i should have written >>= or something somewhere, in my code it's inside of a do block
02:25:54 <greves> i was just trying to make a list here
02:25:56 <srhb> greves: Ah okay :)
02:27:01 <TomItsTime> ||||| >>>>> WHAT IS YOUR DOMAIN NAME WORTH? Vist >>> www.VALBOT.com <<< FREE DOMAIN VALUATION! or GOOGLE >>> VALBOT.com <<< |||||
02:27:26 <arkeet> @where ops
02:27:26 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
02:28:07 <srhb> greves: so ok, we can pretend to have the pure value.
02:28:33 <srhb> greves: But it makes it a little harder to find your error :-) Where's your current problem?
02:28:45 <TomItsTime> ||||| >>>>> WHAT IS YOUR DOMAIN NAME WORTH? Vist >>> www.VALBOT.com <<< FREE DOMAIN VALUATION! or GOOGLE >>> VALBOT.com <<< |||||
02:29:39 <greves> think i may have got it now
02:29:55 <greves> aha yes :D
02:30:06 <greves> so i had to do:
02:31:06 <greves> do Web.Spock.Safe.html $ Data.Text.Lazy.toStrict $ Text.Blaze.Html.Renderer.Text.renderHtml $ Text.Markdown.markdown Text.Markdown.def mdFileContents
02:31:09 <greves> ugggggly
02:32:07 <srhb> html . toStrict . renderHtml . markDown def $ mdfFileContents
02:36:05 * hackagebot fishfood 0.0.1.4 - Calculates file-size frequency-distribution.  https://hackage.haskell.org/package/fishfood-0.0.1.4 (AlistairWard)
02:37:45 <greves> srhb: in that last one, `markDown def' is a partial application and takes mdFileContents as an argument?
02:38:17 <srhb> greves: It is an entire application, but it would be wrong to say that IT takes mdFileContents as an argument.
02:38:23 <srhb> greves: The entire composition of functions does
02:38:43 <srhb> ie html . toStrict . renderHtml . markDown def is a function that takes the file contents
02:38:51 <greves> ok
02:39:10 <greves> yeah, that is clear i suppose
02:39:22 <srhb> But yes, markDown def is markDown partially applied
02:41:52 <greves> alright now i need to change the web server to read the markdown file when the page is loaded, instead of when the application is initialized
02:42:22 <EvanR> partially applied is a weird way to talk about curried functions ;)
02:45:39 <quazimodo> geekosaur: so it occurs to me that the majority of pubsubs shortcomings (that I can see) is in a module using the global pubsub registrar, rather than being given a registrar during runtime via some sort of dependency injection. If we do that, then it stops being global. Async messages are emitted, a switchboard catches them and remits or directly calls action on other components 
02:45:49 <quazimodo> geekosaur: does your brain see isseus with this?
02:46:26 <quazimodo> and modules outside the one mentioned aren't polluted by the screaming and shouting
03:02:29 <greves> srhb: http://lpaste.net/139891
03:03:14 <srhb> greves: Then move it to renderHomepage
03:03:19 <greves> what should i do on line 33/34? if i try doing the readFile there directly it doesn't work, expected type is `ActionT (WebStateM db ses state) Lazy.Text'
03:03:51 <srhb> greves: Do you know about monad transformers?
03:03:59 <greves> nope
03:05:20 <srhb> greves: You need to know about monad transformers. Essentially SpockAction is ActionT which is such a transformer, wherein you can use IO with liftIO
03:05:45 <sshine> how do I create a Gen String that produces a string of random length in some interval, e.g. 5-10?
03:05:45 <srhb> so your ... <- readFile becomes ... <- liftIO $ readFile
03:05:58 <srhb> greves: But you should read up on this separately to understand it. :)
03:08:09 <sshine> ah; sized $ \s -> do { i <- choose(0, n); xs <- f i; return xs }
03:09:41 <farnoy> HI, I've put a SCC around a `hWaitForInput hdl (-1)` and it shows 70% individual of the time when profiling. Is that a busy wait?
03:09:42 <greves> that does indeed work...
03:12:06 <srhb> greves: Monad transformers basically transform a stack of monads into one monad.
03:12:19 <Cale> uhhhh
03:12:26 <srhb> greves: Did I lie? :|
03:12:31 <Cale> Monad transformers transform one monad into another.
03:12:32 <srhb> Er
03:12:35 <srhb> Sorry.
03:12:42 <greves> no, it works
03:12:55 <greves> so in this case its transforming IO into SpockAction ?
03:13:33 <sshine> hi srhb :)
03:13:38 <srhb> liftIO transforms IO a into SpockAction .... a
03:13:40 <srhb> sshine: Hi!
03:13:45 <EvanR> need a lib called maple-syrup which makes a stack of monads palatable
03:14:12 <sshine> srhb, wanna be a TA? they just upped AP with another 22 students.
03:14:47 <srhb> sshine: Not sure I'm quite skilled enough in the other languages. Also I got kicked out of uni. :P
03:15:04 <srhb> I don't think they can accept non-students.
03:15:06 <sshine> srhb, at least you don't have the same time constraints then ;)
03:15:10 <srhb> That's true!
03:15:12 <sshine> srhb, I'm not a student either :)
03:15:19 <srhb> Oh.
03:15:30 <srhb> What are the other parts nowadays? Prolog and Erlang?
03:15:34 <sshine> srhb, actually, it's in my contract that I'm a student. I wrote and asked about it, and they explicitly ignored my question
03:15:41 <srhb> Typical :P
03:15:41 <Myrl> Anyone wanna see the most disappointing code you'll ever see in your whole life?
03:15:42 <sshine> srhb, yeah. but mostly Haskell.
03:15:47 <srhb> sshine: Hmm! I am tempted.
03:15:47 <Cale> greves: So yeah, IO is a monad, and ActionT is a monad transformer, so ActionT IO is a monad, and since ActionT is a monad transformer, you have lift :: m a -> ActionT m a
03:15:52 <Cale> greves: In general,
03:15:53 <Cale> :t lift
03:15:54 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
03:16:01 <greves> Myrl: how did you get a hold of my code??? :P
03:16:06 <Myrl> greves: lol
03:16:09 * hackagebot squeeze 1.0.4.6 - A file-packing application.  https://hackage.haskell.org/package/squeeze-1.0.4.6 (AlistairWard)
03:16:17 <Cale> greves: and more specifically,  lift :: IO a -> ActionT IO a
03:16:29 <Myrl> greves: I think I can make it worse than yours.
03:16:31 <Myrl> greves: `(x, y) = maybe undefined id $ findIndex (((==) `on` fst) (minHeap xs)) xs >>= \x -> return $ splitAt x xs`
03:16:33 <Cale> liftIO will do the same as lift in this case.
03:17:03 <Myrl> greves: Take note of how I used 'undefined' there.
03:17:24 <Cale> Myrl: maybe undefined id = fromJust
03:17:43 <Cale> (only fromJust is slightly better in terms of giving an error message when the pattern match fails
03:17:45 <Cale> )
03:17:47 <Myrl> Ah.
03:17:52 <Cale> Better yet would just be to pattern match
03:18:04 <Cale> Just (x, y) = findIndex (((==) `on` fst) (minHeap xs)) xs >>= \x -> return $ splitAt x xs
03:18:09 <Myrl> Cale: Nice catch, thanks.
03:18:41 <Cale> foo >>= \x -> return (f x) = fmap f foo
03:18:46 <Myrl> Looks better now.
03:18:47 <Myrl> flip splitAt xs  <$> findIndex (on (==) rootIndex' $ minHeap) xs
03:19:05 <Myrl> I think I can do better.
03:20:12 <Cale> Using findIndex together with splitAt seems redundant
03:20:19 <Cale> There's got to be something better than that :)
03:20:34 <Myrl> Cale: split isn't defined for lists though, right?
03:20:39 <Cale> hm?
03:20:48 <Cale> Probably you're looking for span/break
03:20:51 <Myrl> ah.
03:21:07 <EvanR> fromJust o_O
03:21:14 <EvanR> evil
03:21:42 <Myrl> EvanR: lol
03:21:57 <EvanR> fromIO :: IO a -> a
03:22:15 <Cale> > break even [1,3,4,5,7]
03:22:17 <lambdabot>  ([1,3],[4,5,7])
03:22:45 <EvanR> fromList :: [a] -> a
03:22:54 <Cale> :t head
03:22:55 <lambdabot> [a] -> a
03:23:05 <Cale> Not *that* evil, there are reasonable cases
03:23:06 <EvanR> the axis of evil
03:23:17 <Cale> > map head . group . sort $ "mississippi"
03:23:19 <lambdabot>  "imps"
03:23:51 <Cale> This usage of head will never fail, because group is guaranteed to produce nonempty lists as the elements of the list it produced.
03:23:52 <EvanR> its good for pithy one-liners
03:23:54 <Cale> produces*
03:24:14 <Cale> > (\xs -> zip xs (tail xs)) [1..10]
03:24:15 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10)]
03:24:25 <Cale> Similarly that usage of tail won't fail
03:24:30 <Cale> > (\xs -> zip xs (tail xs)) []
03:24:33 <lambdabot>  []
03:24:38 <EvanR> yes its reasonable like division, when you have proof the divisor isnt zero
03:24:44 <kalkin-_> hi
03:24:48 <EvanR> the proof is in the pudding, not the type system though
03:25:09 <kalkin-_> how can i remap ghci Page Up to complete from history incrementally like bash/zsh does?
03:25:46 <kalkin-_> i found out that i need to use haskeline and i know about the bind, but whats the ghci command for search incrementally?
03:25:56 <EvanR> relying on such proofs makes me feel like im writing in a dynamic language
03:27:15 <Cale> EvanR: use Agda :)
03:27:39 <Cale> Haskell allows general recursion too, which is scary
03:27:46 <Cale> Is it evil?
03:27:53 <EvanR> in two ways, functions and data types
03:28:49 <EvanR> Void = { _|_ } keeps me up at night
03:30:09 <scshunt> or Idris ;)
03:30:26 <scshunt> though idris is not truly sound
03:31:11 * hackagebot squeeze 1.0.4.7 - A file-packing application.  https://hackage.haskell.org/package/squeeze-1.0.4.7 (AlistairWard)
03:31:38 <EvanR> scshunt: which feature of idris are you refering to
03:31:51 <EvanR> it could be several ;)
03:32:08 <scshunt> EvanR: partial functions
03:32:24 <scshunt> unlike Agda, Idris doesn't require totality
03:32:33 <EvanR> its configurable
03:32:36 <scshunt> yeah
03:32:47 <scshunt> but it means that bottom does inhabit every time
03:32:48 <EvanR> but thats where it gets dicey i was wondering if you were talking about that ;)
03:32:48 <scshunt> *type
03:33:20 <EvanR> it doesnt support bottom as a language feature though, as in undefined
03:33:26 <EvanR> you cant explicitly cause a crash
03:33:37 <EvanR> which is actually annoying
03:35:12 <EvanR> even with total by default on, it currently has low level primitives like stringHead, and division which will crash in haskell, or in weird ways in the C runtime
03:35:33 <EvanR> also you can always use believe_me
03:35:49 <EvanR> which will hopefully segfault in C
03:36:21 <EvanR> but im not sure if it will (if used incorrectly)
03:40:25 <Myrl> Is ((++) . reverse) slower than (flip (foldl (flip (:))) ?
03:40:31 <sshine> haha
03:41:08 <Myrl> And which is more idiomatic?
03:42:06 <EvanR> combinations of the form f . g . h seem more idiomatic and easier to read and write to me
03:42:24 <Cale> Yeah, I'd much rather see  (++) . reverse
03:42:25 <EvanR> than f (g (h i))
03:42:44 <Cale> Or even (\xs ys -> reverse xs ++ ys)
03:43:03 <EvanR> yeah lambdas get overlooked a lot
04:04:42 <ij> Is there a stack data structure? (Though I know I can always hack one up from lists.)
04:05:28 <srhb> ij: Not in base afaik.
04:06:03 <ij> Some package then? Googling gave me that stack tool thing.
04:09:21 <ibid> aren't lists almost there already? what hacking is required?
04:10:15 <ij> I just wanted some different function names, I guess.
04:10:22 <EvanR> push = (:)
04:10:29 <EvanR> pop = id
04:11:17 <EvanR> pop_ = listToMaybe
04:11:17 * hackagebot sloane 4.0.2 - A command line interface to Sloane's OEIS.  https://hackage.haskell.org/package/sloane-4.0.2 (AndersClaesson)
04:11:21 <EvanR> :t listToMaybe
04:11:22 <lambdabot> [a] -> Maybe a
04:12:04 <pavonia> pop = tail, no?
04:12:16 <EvanR> if you want to forget whats on the top yeah
04:12:30 <EvanR> which seems like a special case
04:12:34 <pavonia> id doesn't change the list at all
04:12:38 <EvanR> indeed
04:12:47 <EvanR> it returns (top:tail)
04:13:35 <EvanR> tail is actually broken for stack, if you use it on the empty stack
04:13:51 <EvanR> id will let you choose what to do in either case
04:13:56 <pavonia> "drop 1" then
04:14:07 <EvanR> i tend to use the thing i pop
04:14:58 <EvanR> theres no a priori requirement that an operation on a data structure has to "do something" ;0
04:16:50 <EvanR> pop__ = drop 1
04:16:59 <pavonia> No, but I imagine the data structure more abstract, so you wouldn't be able to decompose it into head and tail
04:17:34 <EvanR> no real reason to make it more abstract, since its exactly isomorphic in every way
04:17:42 <ibid> tail is perfect for pop, i think. nonemptiness is a precondition
04:18:13 <EvanR> oh geez lets set up a inheritance hierarchy, pre and post condition contracts, and variance annotations ;)
04:18:32 <EvanR> also unit tests
04:19:38 <ibid> EvanR: there's no call to use foul language like inheritance hierarchy :)  (and also, there's nothing in design by contract that requires inheritance)
04:19:45 <EvanR> whats great about our standard data structures is that they are so dumb and basic, when you go into somebody elses code and they are using that ds, you dont need to convert because they made a "basically a list" list structure
04:20:35 <EvanR> this isnt even like "using an Int like a Nat", a stack is exactly a list
04:26:11 <Jinxit> how do I change a single element in Data.Vector? is // the best way?
04:26:18 * hackagebot libmpd 0.9.0.4 - An MPD client library.  https://hackage.haskell.org/package/libmpd-0.9.0.4 (JoachimFasting)
04:30:42 <EvanR> Jinxit: theres several functions there, like update_, they all are for particular purposes
04:30:55 <EvanR> update, update_, unsafeUpd, etc
04:32:11 <EvanR> "what does best mean"
04:36:06 <Jinxit> alright, thanks
04:41:20 * hackagebot moesocks 0.1.1.20 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.1.20 (JinjingWang)
04:49:43 <danilo2> Hello! :) I'm creating a graph processing algorithm. I want to be able to travel between nodes in small O(1) time, so I'm using MVector to store the nodes IDs (Ints). This solution performs really well but it forces me to use ST / IO monad in many, many places. When using pure Vectors the performance is much worse, because each update of Vector creates new one in memory even with highest optimisations. So is there any pure alternat
04:52:14 <bennofs> danilo2: perhaps there is a middle way? I've found that it often works well to work with pure vectors at a "high level" and then freeze / thaw just for the algorithms inner loops
04:52:45 <bennofs> danilo2: so each individual algorithm takes a pure vector, then thaws it, does its processing, and freezes it again
04:52:46 <cocreature> danilo2: IntMap give's you cheaper modifications at the cost of more expensive lookups
04:55:23 <danilo2> bennofs: Hmm, that could probably work, but I do not know exactly all the algorithms we would need to do there, so it could appear that we would need to rewrite everything to MVectors later. I understand that you are thinking about for example storing a list of updates and then make a bulk-update on the end of an algorithm part? Yeh, that would help with the performance much. Anyway would anybody be so nice and shortly explain to m
04:55:46 <danilo2> icily? When GHC sees that we do not need "old" vector values it could under the hood use the mutable one, couldn't it? 
04:56:21 <danilo2> cocreature: using MVectors both modifications and lookups are O(1) , much smaller than the one from IntMaps
04:57:22 <bennofs> danilo2: yes, there something like that in vector: http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector.html#v:modify
04:57:34 <bennofs> danilo2: it says: "The operation will be performed in place if it is safe to do so and will modify a copy of the vector otherwise"
04:57:43 <bennofs> not exactly sure what the conditions for that are though
04:58:12 <cocreature> danilo2: sure, but you said that you didn't want to use ST
04:58:47 <danilo2> cocreature: I would prefer to stay with pure code. I can use ST / IO - the most important factor to me is performance right now
05:00:01 <danilo2> bennofs: interesting, I'll look there right now.
05:00:30 <saulzar> I wonder how it knows "if it's safe to do"
05:04:34 <bennofs> danilo2: perhaps you can write your graph processing as   process1 . process2 . process3 . process...
05:05:00 <bennofs> danilo2: in that case, you can write processN using modify, {-# INLINE #-} it and stream fusion should fuse the intermediate pure vectors away
05:05:45 <bennofs> danilo2: because it can fuse modfiy x . modify y . modify z  to modify (x >>= y >>= z) I think
05:07:34 <danilo2> bennofs: ok, I'll try to do test it that way :) Thank you :)
05:11:34 <danilo2> bennofs: It seems it doesn't work like that, look here is a small benchmark:
05:11:36 <petsu> hello~~ i need a lil help
05:11:46 <petsu> how do i install base 4.6?
05:11:52 <petsu> i mean 4.7**
05:11:59 <danilo2> bennofs: http://lpaste.net/139894
05:13:02 <danilo2> bennofs: you should run it as: ./Main 4 10000 10000, the first number is the test case, the second and their number should be the same (sorry about that) and denote the number of modifications
05:13:28 <bennofs> danilo2: I'll look at it, thanks
05:13:43 <petsu> cabal: Could not resolve dependencies:
05:13:44 <petsu> rejecting: base-4.8.1.0, 
05:13:45 <danilo2> bennofs: thank you! :)
05:13:48 <petsu> etc +++=
05:14:39 <cocreature> petsu: base is tied to your ghc version, if you want/need a different base version you need a different ghc
05:14:50 <petsu> ahhh
05:16:01 <petsu> thanks!
05:16:18 <cocreature> np
05:29:12 <EvanR> i prefer pure code and highest performance too
05:29:29 <Gurkenglas> "seq v v" <- shouldn't this be completely equivalent to writing "v"?
05:29:33 <EvanR> screw tradeoffs
05:30:04 <EvanR> > head [1, seq undefined undefined]
05:30:05 <bennofs> Gurkenglas: yes
05:30:07 <lambdabot>  1
05:31:51 <EvanR> > case seq undefined undefined of {_ -> "shoes"}
05:31:54 <lambdabot>  "shoes"
05:33:39 <danilo2> Gurkenglas: `seq v v` should not evaluate v to WHNF? why should it be equivalent to just `v` ?
05:34:04 <EvanR> see my examples above, it didnt evaluate v
05:34:17 <EvanR> where v = undefined
05:34:45 <danilo2> i see it, but why >
05:34:47 <danilo2> ?
05:34:53 <EvanR> that triggers lambdabot
05:34:53 <Gurkenglas> Here's the specified behavior of seq: "seq _|_ x = _|_, otherwise seq _ x = x"
05:35:11 <lyxia> it evaluates v to WHNF when it evaluates v to WHNF... in short, it just evaluates v to WHNF
05:35:38 <EvanR> if or when it evaluates v to WHNF
05:35:42 <EvanR> it does nothing 
05:35:51 <EvanR> beyond what v would "do"
05:36:12 <bennofs> danilo2: hmm, 4 is fastest for me. it that expected?
05:36:47 <Gurkenglas> It basically says "evaluating seq's second argument to WHNF is not done until seq's first argument is in WHNF"
05:37:54 <EvanR> so seq x x should be able to be optimized away
05:38:18 <EvanR> unless x contains unsafePerformIO
05:38:30 <danilo2> bennofs: for me too. This is also interesting - why is it faster than 0
05:41:00 <danilo2> bennofs: Another interesting fact is that 2 is much faster than 0, although 2 is just AutoVector - a wrapper around MVector
05:41:46 <bennofs> danilo2: 2/0 are about the same speed for me
05:42:08 <bennofs> danilo2: +-100ms, which is noise I think
05:42:14 <saulzar> danilo2, Unrelated - but if you're just using Vector Int  (or other simple type supporting Unbox) it'll give you a big boost
05:43:36 <hexagoxel> how to map/fmap `a->b` over a mono-traversable.MinLen ?
05:44:12 <breadmonster> Hello.
05:44:52 <danilo2> bennofs: If you try with high number of operations like "1000000" then 0 is always about 0.18 s, while 2 was never bigger than 0.12 s 
05:45:32 <hexagoxel> > text "hi."
05:45:36 <lambdabot>  hi.
05:45:42 <danilo2> saulzar: I know, but there would not be ints. I'll make unboxed version of my structures later. these are just test cases
05:45:48 <saulzar> Is it that surprising that the bulk updates are fast? unsafeUpdate should be even better
05:46:04 <saulzar> danilo2, Alright, gotcha
05:48:38 <danilo2> saulzar: there are few surprising facts - the first one is that the bulk updates are faster than the mutable Vector ones, the second is that on my computer the 2 case runs faster than 0 case, while 2 is just 0 wrapped with some datatype and the third interesting question is what does exactly the http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector.html#v:modify function - how does it know if its safe or not safe to m
05:48:47 <hexagoxel> (ah, i just have to `fmap (fmap f)` )
05:48:51 <hexagoxel> pssh
05:53:58 <saulzar> danilo2, I think mapM is hurting you in case 0
05:54:44 <saulzar> danilo2,  Both of them - especially this one mapM (\i -> MV.unsafeWrite mv' i i) [0..j] 
05:55:12 <saulzar> danilo2, mapM_ should be a lot better, because it's not building up a list of [(), (), ... ]
05:55:57 <saulzar> danilo2, Instead of converting to a list and using foldl' it should be a lot quicker to just use Vector.foldl' as well
05:58:29 <danilo2> saulzar: ok, using MapM_ is a little better (again I don't see why GHC does not optimise it away, because it knows I don't need such output list). Mutable Vectors does not have fold'like functions
06:00:59 <saulzar> danilo2, I guess freeze it and use that. I haven't really used this stuff in a while, but usually if you can get away with using the bulk update functions instead of dipping into MVector (e.g. update, or backpermute) they're usually the way to go
06:02:01 <danilo2> saulzar, bennofs: thank you guys for all the discussion and help! :)
06:02:05 <chpatrick> does anyone know if there's an existing small package for using string literals efficiently? ie. just getting a Ptr to the UTF-8 string in memory
06:02:20 <saulzar> danilo2, Plain for loops using recursion usually work even better than mapM_ in such cases too
06:02:53 <breadmonster> If f and g are functors, is f (g a) also a functor?
06:03:09 <jeltsch> breadmonster: The composition of f and g is a functor.
06:03:26 <jeltsch> What you wrote is actually the application of this composition to a, but I know what you mean.
06:03:39 <breadmonster> jeltsch: Yeah well, how do I turn that into a typeclass instance?
06:03:49 <chpatrick> breadmonster: look at Data.Functor.Compose
06:03:53 <breadmonster> I can't figure out the Haskell syntax.
06:03:57 <breadmonster> chpatrick: Oh okay.
06:04:04 <chpatrick> you need to newtype it
06:04:11 <saulzar> danilo2, No prob :)
06:04:20 <chpatrick> it's also an applicative but not a monad oddly enough
06:04:33 <jeltsch> breadmonster: You could define a type alias, but you cannot make partially applied type aliases a class instance.
06:04:50 <breadmonster> Interesting.
06:05:00 <jeltsch> chpatrick: It’s not generally an Applicative. It is if both f and g are Applicatives.
06:05:26 <jeltsch> breadmonster: Yeah, functors compose, applicative functors compose, but monads don’t.
06:05:36 <chpatrick> jeltsch: that's what I meant since he was asking about composition of functors
06:05:55 <jeltsch> breadmonster: This is why we have monad transformers. If monads would compose, we would not need these transformers.
06:07:00 <breadmonster> jeltsch: Can you give me an example of a monad without a transformer?
06:09:20 <jeltsch> breadmonster: Let me think a bit about this.
06:09:28 * jeltsch thinks
06:10:24 <chpatrick> not sure what you mean by that breadmonster
06:11:08 <EvanR> IO
06:11:08 <breadmonster> chpatrick: if monad transformers arise solely because monads do not compose, there must be monads that do not have an equivalent transformer?
06:11:25 <jeltsch> EvanR: This is what I just thought. :-) 
06:11:25 <breadmonster> EvanR: Any others?
06:11:38 <breadmonster> IO is an answer to everything.
06:12:11 <EvanR> i dont even know why IO cant be a transformer, because its abstract? it has no run?
06:12:21 <peddie> breadmonster: ST
06:12:32 <chpatrick> could you make some weird IOT by representing it as StateT RealWorld?
06:12:32 <EvanR> beyond that, i dont even know what "can be a transformer" means precisely
06:12:40 <chpatrick> yeah it's kinda vague
06:12:50 <EvanR> IO isnt a StateT RealWorld
06:12:54 <breadmonster> peddie: ST has a transformer.
06:13:05 <peddie> breadmonster: where??
06:13:16 <breadmonster> peddie: https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0CB0QFjAAahUKEwjcr7SS8dDHAhWO1I4KHZBsAjk&url=https%3A%2F%2Fhackage.haskell.org%2Fpackage%2FSTMonadTrans%2Fdocs%2FControl-Monad-ST-Trans.html&ei=SAHjVdxrjqm7BJDZicgD&usg=AFQjCNHs4AxoSmPhNIHLd1AJrQRnNOAU0Q&sig2=TtdQ0kgpoF7VufdjNy6JYA
06:13:20 <chpatrick> EvanR: yeah it's a State RealWorld :D
06:13:26 <chpatrick> with some unboxed stuff
06:13:36 <EvanR> i seriously dont think that holds up
06:13:41 <EvanR> besides as a joke
06:13:50 <chpatrick> well let's think about it
06:13:58 <peddie> breadmonster: whoa, I had no idea
06:13:59 <chpatrick> what could you do if you put StateT RealWorld on top of something
06:14:05 <chpatrick> it would be MonadIO right?
06:14:06 <EvanR> how would you implement forkIO
06:14:10 <chpatrick> you could thread it through
06:14:30 <chpatrick> but it wouldn't have a very useful run... I think
06:14:33 <chpatrick> you could only turn it back into an IO
06:14:40 <chpatrick> so it wouldn't really add anything
06:15:04 <EvanR> for a faithful implementation of IO as pure code, youd have to have some kind of laws for IO to satisfy so you could check that its working
06:15:35 <chpatrick> I mean the whole "monads having a transformer" question is a bit vague
06:15:45 <chpatrick> some monad transformers have similar semantics to some monads
06:15:46 <EvanR> and time and concurrency are kind of oddballs as far as laws go
06:16:11 <EvanR> and sources of randomness
06:16:37 <jeltsch> IO is not State RealWorld. At best, it is State RealWorld*, where the * means that the world may be used at most once (Clean syntax).
06:16:55 <jeltsch> And this is the point why you cannot have an IOT.
06:17:04 <jeltsch> This would allow you to duplicate the world.
06:17:18 <chpatrick> well as far as implementation goes it's isomorphic isn't it?
06:17:23 <jeltsch> Take, for example, IOT [].
06:17:33 <EvanR> isomorphic to what
06:17:37 <chpatrick> State RealWorld
06:17:48 <jeltsch> chpatrick: The implementation of IO is a hack. It must be hidden from the user, because it is incorrect semantically.
06:17:49 <chpatrick> except it's magichashed
06:17:53 <EvanR> two things that arent IO can be said to be isomorphic
06:18:12 <jeltsch> chpatrick: No, the point is that the world should not be duplicated, but the internal representation allows exactly that.
06:18:17 <chpatrick> that's true
06:19:03 <jeltsch> So IOT [] a ≅ RealWorld -> [(a, RealWorld)]
06:19:30 <EvanR> even then, it seems like RealWorld in GHC is not what it advertises, its like a placeholder for some sequencing details
06:19:50 <EvanR> you cant explain concurrency with it
06:20:32 <jeltsch> If you would lift a pure list to IOT [], you would get an IOT that maps one world to a list that contains this world several times. If you then use (>>=) to append another IOT action, you would be able to go on in different ways from the same world. This would be wrong.
06:21:09 <jeltsch> In the Clean programming language, you can annotate the RealWorld type with a star, meaning that it is unique (values can be used at most once).
06:21:35 <jeltsch> Therefore, in Clean, they can really represent IO actions by a state monad, and this is actually what they really do.
06:21:41 <EvanR> even then, supplying the "same world" to an IO program shouldnt guarantee reproducibility
06:22:00 <jeltsch> They explicitely use types like World* -> (File*, World*)
06:22:05 <EvanR> you have to establish what the laws IO are supposed to follow
06:22:31 <EvanR> but good luck getting accurate laws
06:22:54 <EvanR> the real world might contain a person, and the person has free will, and he is tasked with giving the answer to an IO primitive
06:23:00 <EvanR> then what
06:23:48 <EvanR> more problematic, what if his answer depends on another IO action that is in concurrent progress
06:23:55 <EvanR> partially depends*
06:24:22 <EvanR> it seems simpler just to leave IO abstract
06:25:03 <EvanR> ideally, computations that arent so ridiculous as what i described shouldnt need to be in IO
06:25:14 <EvanR> but the type system only goes so far
07:21:44 * hackagebot mandrill 0.4.0.0 - Library for interfacing with the Mandrill JSON API  https://hackage.haskell.org/package/mandrill-0.4.0.0 (AlfredoDiNapoli)
07:27:39 <burp> % stack templates
07:27:45 <burp> Failed to download templates. The HTTP error was: TlsException (HandshakeFailed (Error_Protocol ("certificate has unknown CA",True,UnknownCa)))
07:27:47 <martinvlk> @pl (\w -> (w, capt w))
07:27:48 <lambdabot> ap (,) capt
07:27:56 <burp> anyone had this problem too?
07:31:02 <voidzero> maybe you can try `update-ca-certificates`
07:31:04 <voidzero> on the shell
07:31:07 <voidzero> burp^
07:32:13 <burp> voidzero: I'm on freebsd, and the x509-system package should also check /usr/local/share/certs/ where a file with root certificates (from mozilla) resides
07:32:47 <voidzero> ah.. yes indeed
07:33:03 <voidzero> it was a year or two since i last used freebsd
07:33:25 <voidzero> does update-ca-certificates exist?
07:33:31 <burp> no :)
07:33:38 <voidzero> how about c_rehash?
07:33:51 <burp> "Doing /usr/local/openssl/certs" :D
07:34:07 <voidzero> wonder if that fixes it
07:34:17 <voidzero> i remember from freebsd that the process was a bit more tedious
07:34:33 <burp> that's an empty directy though, maybe I should link /usr/local/share/certs to /usr/local/openssl/certs
07:34:48 <echo-area> How to see template haskell generated code with cabal?
07:35:03 <burp> voidzero: but thanks for the hint
07:35:05 <glguy_> envPathOverride = "SYSTEM_CERTIFICATE_PATH"
07:35:11 <voidzero> burp, c_rehash just creates hashes from the certificates
07:35:19 <glguy_> You can try seeing that envvar
07:35:29 <voidzero> .. that might work :)
07:35:46 <burp> glguy_: yay, thanks!
07:37:30 <voidzero> so i have a question about Applicative; what are *> and <* used for?
07:38:21 <glguy_> Same sort of use cases as (>>)
07:39:46 <voidzero> oh
07:39:54 <voidzero> yes, that makes sense
07:40:55 <burp> strange, in principle it should work, such a problem was reported and fixed in 2013 https://github.com/vincenthz/hs-certificate/commit/78efa46e29360553e353497982ab4e5167001c27
07:41:16 <echo-area> cabal configure --ghc-options=..., it is
07:42:04 <glguy_> Burp, your path wasn't "/usr/local/share/certs/" -- freebsd
07:42:17 <glguy_> I thought it mentioned openssl
07:42:36 <burp> glguy_: my certs are in /usr/local/share/certs, c_rehash reported openssl/certs, but it's empty
07:43:30 <burp> I put the certificates in /etc/ssl/certs now, it works with that
07:44:03 <glguy_> It only uses the first directory found
07:44:29 <Beardful> Is anyone else having trouble cabal'ing juicypixels-repa? It's hackage status says someone has successfully built it, but i can't. Can anyone tell me if im doing anything wrong? Log: http://sprunge.us/XZhP
07:44:34 <burp> "(getSystemPaths >>= findFirst)", eeks indeed
07:44:52 <burp> so I had /etc/ssl/certs/ too, but it was just empty
07:45:13 <burp> it should use the first non empty directory
07:45:53 <geekosaur> Beardful, ghc 7.10 by any chance?
07:46:10 <Beardful> geekosaur: Indeed
07:46:14 <geekosaur> ghc got stricter about FlexibleContexts
07:46:31 <geekosaur> (it used to quietly ignore it for inferred types, now it requires it)
07:47:27 <Beardful> geekosaur: Would a ghc downgrade suffice? If so, then which version am i looking for?
07:47:37 <glguy_> Juicypixel-repa has a base constraint that excludes GHC 7.10 on hackage
07:49:02 <geekosaur> so the quick fix is "cabal unpack juicypixels-repa", edit the cabal file to add "extensions: FlexibleContexts", and "cabal install" (without package name, in the directory with the cabal file)
07:49:33 <geekosaur> ...and hope it doesn;t have any other issues that 7.10 would affect, like a local Monad without an Applicative
07:50:16 <glguy_> Tommd would likely update it if you asked
07:56:16 <Beardful> geekosaur: Awesome, it worked like a charm, thanks.
08:01:51 <tommd> glguy_: What, huh?
08:02:51 <tommd> Ahh, jp-repa.  That is barely maintained as I prefer friday these days.  That's all an aside, I'll update.
08:04:40 <bergmark> I revised jp-repa, sorry for forgetting to notify you tommd http://hackage.haskell.org/package/JuicyPixels-repa-0.7/revisions/
08:05:40 <bergmark> as an aside FlexibleContexts is usually not needed (IME), usually adding a more concrete type signature is enough
08:20:34 <tommd> bergmark: Yes, I did just that
08:20:46 <tommd> bergmark: No worries about the revision, thanks for the notice.
08:21:47 * hackagebot JuicyPixels-repa 0.7.0.1 - Convenience functions to obtain array representations of images.  https://hackage.haskell.org/package/JuicyPixels-repa-0.7.0.1 (ThomasDuBuisson)
08:23:25 <tommd> Beardful: I fixed it, I think.  I don't like the signature of that function (histogram), it looks like I was being dumb.
08:23:33 <tommd> So be careful if you are using that.
08:44:57 <akegalj> i have defined:  safeHead [] = [] ; safeHead = tail    and ghc tells me they have different number of arguments ?
08:45:44 <glguy> One has 1 explicit argument and the other has 0
08:45:48 <glguy> they have to have the same
08:46:47 <akegalj> glguy: is it because on second definition it won't pattern match?
08:47:38 <glguy> No, because it's missing an explicit argument
08:47:43 <glguy> safeHead xs = tail xs
08:47:54 <akegalj> glguy: aha ok
08:49:54 <mazur> is the counit for the product/exponent just un-curry?
09:03:26 <Saizan> the counit is more like eval, uncurry/curry are the hom isomorphisms though
09:09:14 <mettekou> Anyone here who has any experience with x86 code generation from three address code in Haskell?
09:11:57 <mazur> Saizan: with eval : B^A x A -> B, what does it look like?
09:12:43 <mazur> is it the curry of that? B^A -> B^A ?
09:14:23 <setser> How can I rewrite this code without do-notation?
09:14:37 <setser> code:
09:14:49 <setser> main = do
09:14:55 <setser> a <- getLine
09:15:01 <setser> b <- getLine
09:15:02 <Saizan> mazur: the counit at A is supposed to be a morphism F (G A) -> A
09:15:23 <setser> putStrLn $ operate a b
09:15:29 <cocreature> setser: getLine >>= \a -> getLine >>= \b -> putStrLn $ operate a b
09:15:32 <Saizan> mazur: if F = (x A) and G = (^A) that's exactly eval
09:15:34 <MarcelineVQ> setser: you're lookign for >>=
09:15:50 <setser> No, i've forgot about lambdas
09:16:09 <setser> Thanks
09:16:12 <Saizan> mazur: i guess i should have said counit at B should be F (G B) -> B, to not confuse variables
09:16:16 <cocreature> yw
09:16:55 * hackagebot THEff 0.1.0.1 - TH implementation of effects.  https://hackage.haskell.org/package/THEff-0.1.0.1 (kolodeznydiver)
09:17:11 <mazur> hmm, thanks, still taking it in (just learned adjoints today)
09:19:03 <mazur> oh wait, so the counit there IS eval?
09:19:28 <Saizan> mazur: yah
09:19:58 <mazur> i guess the variable mislead me: epsilon for eval (when usually counit is eta)
09:20:13 <sleepomeno> how can i pass a flag to "stack install" as i could with "cabal install -fFLAG"?
09:21:51 <cocreature> do we have IORefs paired with unique integers in some package so that I can get an Ord instance for them?
09:22:07 <cocreature> I really don't want to loop through a list every time just to check if something is in a Set
09:22:33 <cocreature> ofc I could easily implement that myself, but I'd prefer not to if it already exists
09:23:16 <Cale> sleepomeno: https://github.com/commercialhaskell/stack/blob/master/GUIDE.md search for "Flags and GHC options"
09:23:22 <cocreature> mazur: I don't think I have ever seen eta being used for the counit. It is nearly always used for the unit
09:23:30 <cocreature> wikipedia agrees https://en.wikipedia.org/wiki/Adjoint_functors#Counit-unit_adjunction
09:23:31 <mazur> oh, nm afterall i had it backwards :)
09:23:53 <cocreature> I kinda hate those greek letters. I can never remember which one stands for what :)
09:24:33 <mazur> so the unit is what i was looking for is eta: B -> (B x A)^A i think
09:28:56 <cocreature> looks correct
09:30:16 <geekosaur> we really need to split the two meanings of Ord someday
09:30:35 <StoneToad> 2 meanings?
09:31:19 <geekosaur> it's used for two different things: mathematical total ordering, requiring that the type have a meaningful total order, which IORef (and some other things) do not
09:31:26 <cocreature> yeah
09:31:54 <geekosaur> and an "index total ordering" where all that matters is that something like Map can order them, but there's no conceptual meaning to the order of values of the type
09:32:37 <geekosaur> complex numbers are another example; there's no "proper" total ordering for e.g. (<) to work, but you can define a perfectly workable ordering for use in a Map
09:36:05 <StoneToad> ahh yes, I see waht you're saying
09:37:03 <akegalj> in xmonad documentation there are many definitions like   functionName :: !(...)  what this exclamation mark means?
09:37:10 <geekosaur> strict
09:37:16 <akegalj> thnx
09:37:53 <geekosaur> basically the compiler inserts a "seq" whenever something defines it, to ensure that it isn't _|_ (undefined / bottom)
09:38:50 <c_wraith> Err.  It shouldn't be in the type signature, though
09:39:48 <geekosaur> I think the actual reference is to the type of the "hook" functions in XConfig
09:40:25 <geekosaur> (fields with function values, e.g. XConfig { ... logHook :: !(X ()) ... } )
09:40:30 <c_wraith> ah, ok
09:40:51 <c_wraith> It seems a bit pointless to make function fields strict, tthough...
09:41:30 <ezrios> is there something like a monoid on Constraint kinds?
09:41:40 <geekosaur> I think that's just so it's caught before the window manager starts instead of the first time it lays out a workspace
09:42:12 <ezrios> I would like to write something like `Constraint -> Constraint -> Constraint` to glue together multiple constraints
09:42:38 <c_wraith> ezrios: does (,) work?
09:43:08 <ezrios> c_wraith: programming at the type level
09:43:23 <c_wraith> ezrios: yes.  (Foo a, Bar a)
09:44:18 <ezrios> c_wraith: what if I don't know that there's only two and instead have a list of them
09:44:55 <c_wraith> ezrios: then you'd need type families
09:45:14 <ezrios> c_wraith: can you elaborate a little? just dipping my toes into type level programming
09:45:42 <ezrios> http://stackoverflow.com/questions/28142914/managing-explosion-of-constraints-haskell ?
09:46:59 <c_wraith> That's the sort of thing I was thinking of, yeah
09:47:20 <ezrios> ok, thanks muchly
09:56:42 <catgocat> Guys I am a stuck at a NICTA course exercise
10:02:00 * hackagebot cassava 0.4.4.0 - A CSV parsing and encoding library  https://hackage.haskell.org/package/cassava-0.4.4.0 (JohanTibell)
10:12:00 * hackagebot ioref-stable 0.1.0.0 - iorefs with a unique stable index  https://hackage.haskell.org/package/ioref-stable-0.1.0.0 (cocreature)
10:28:45 <kuznero> Hi All!
10:28:59 <kuznero> Who knows why do I have problems runnin [stack test] with build dependency to quickcheck in test-suite?
10:38:30 <mpickering> kuznero: Maybe you can start by telling what the error is
10:42:02 * hackagebot universe-base 1.0.1 - A class for finite and recursively enumerable types and some helper functions for enumerating them  https://hackage.haskell.org/package/universe-base-1.0.1 (DanielWagner)
10:42:04 * hackagebot universe-instances-extended 1.0.0.1 - Universe instances for types from select extra packages  https://hackage.haskell.org/package/universe-instances-extended-1.0.0.1 (DanielWagner)
10:47:44 <lpaste_> kuznero pasted “No title” at http://lpaste.net/139900
10:47:58 <kuznero> mpickering: this one http://lpaste.net/139900
10:49:36 <eguneys> what is this `(. even)`
10:50:41 <MarcelineVQ> eguneys: hehe was that intentional?
10:50:41 <benzrf> "what is this even:
10:50:44 <benzrf> "
10:50:48 <glguy> :t (. even)
10:50:50 <lambdabot> Integral a => (Bool -> c) -> a -> c
10:50:51 <benzrf> eguneys: it's a composition section
10:51:11 <glguy> (. even) is \f -> f . even
10:53:09 <mpickering> kuznero: try QuickCheck
10:53:49 <kuznero> mpickering: that worked :) thanks a lot!
10:55:03 <eguneys> I dont understand the type how does it type work 
10:55:06 <eguneys> :t (. even)
10:55:07 <lambdabot> Integral a => (Bool -> c) -> a -> c
10:57:50 <EvanR> :t (.)
10:57:53 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:57:54 <EvanR> :t even
10:57:56 <lambdabot> Integral a => a -> Bool
10:58:18 <EvanR> do the maf
10:58:34 <jmcarthur> orphan rewrite rules are not any less likely to fire as long as the module is imported, right?
10:59:52 <jmcarthur> i'm using orphan rewrite rules as a way to prevent the rewrite rules from firing in the definitions of quickcheck properties (which i am annotating with NOINLINE to prevent the rules from firing at call sites even if they are imported there)
11:00:04 <jmcarthur> at least, i am hoping this is reasonable way to go
11:01:35 <jmcarthur> basically it's module A.NoRules with functions and not-inlinable quickcheck properties, and module A which reexports module A.NoRules and defines some rewrite rules
11:04:43 <ttt_fff> is there a good example of "how to reify case/pattern matching into a EDSL" using Template Haskell ?
11:18:12 <athan> wtf we can have comprehension / do-like syntax inside guards?
11:18:38 <athan> I'm guessing in the identity monad?
11:18:47 <mpickering> aka PatternGuards
11:19:02 <athan> lawd
11:19:06 <athan> thanks mpickering
11:19:43 <pyon> :k (forall a. Either a)
11:19:45 <lambdabot> * -> *
11:19:50 <pyon> How does that even make sense?
11:20:11 <EvanR> Either is  * -> * -> *
11:20:23 <EvanR> apply it to some type and you get * -> *
11:21:14 <pyon> EvanR: Yes, but, checking TaPL, `forall (a :: K). e` only makes sense when `a :: K ⊢ e :: ★`.
11:21:38 <EvanR> what is K in this context
11:21:46 <pyon> a's kind.
11:22:01 <EvanR> forall a . Either a, a is a type not a kind
11:22:13 <pyon> All types have a kind.
11:22:42 <EvanR> a is a *
11:22:53 <pyon> In this particular case, yes.
11:23:26 <pyon> My complaint is that (forall a. e) only makes sense when e has kind *, or so TaPL says.
11:24:04 <pyon> Note that `e` alone can make sense regardless of its kind.
11:24:15 <EvanR> that rule seems to be talking about specific language of types
11:24:43 <pyon> Ah, I thought Haskell was loosely based on System F-omega. That's why I consulted the definition of System F-omega.
11:24:48 <EvanR> and haskells type language is another specific language
11:25:25 <mpickering> pyon which page of tapl are you looking at 
11:25:36 <pyon> 450
11:25:43 <pyon> The rule K-ALL.
11:27:33 <athan> pyon: SystemFC_pro (with an arrow up) is based off SystemF-omega, I'm pretty sure
11:27:40 <athan> while SystemFC doesn't have kinds
11:28:20 <EvanR> pyon: so for Either a, you need rule K-APP
11:28:23 <fresheyeball_> hello out there, do anyone here know golang?
11:28:36 <monochrom> I don't
11:28:38 <EvanR> K-ALL doesnt apply because Either a isn't *
11:28:49 <pyon> ?
11:28:50 <fresheyeball_> I am wondering if its possible to write a function in go for foldr on a signal
11:28:59 <athan> fresheyeball_: o/
11:29:08 <pyon> The rule K-APP doesn't require a to have kind *. The rule K-APP would require `Either a` to have kind *.
11:29:11 <fresheyeball_> hey athan
11:29:21 <athan> I don't go :| sorry man
11:29:22 <pyon> Errr, K-ALL*
11:29:23 <EvanR> pyon: Either and Either a are both K1 -> K2 for some kind K1 and K2
11:29:30 <fresheyeball_> yeah me neither 
11:29:34 <fresheyeball_> its just an experiment 
11:30:04 <fresheyeball_> go pleople dont know folds though 
11:30:08 <EvanR> K-APP applies when your term has kind K1 -> K2
11:30:11 <fresheyeball_> it hard to ask them the question 
11:30:13 <EvanR> which is this case
11:30:23 <athan> fresheyeball_: You should be able to make it happen. Can you take in functions as arguments in the language?
11:30:33 <pyon> EvanR: But K-APP says nothing about `forall`.
11:30:35 <fresheyeball_> yes
11:30:36 <athan> like lodash's fold / reduce for javascript, you could go that route
11:30:38 <EvanR> K-ALL does not apply because it is NOT *
11:30:44 <fresheyeball_> but there is almost zero polymorphism 
11:30:54 <athan> :x
11:30:57 <pyon> K-APP can give me the kind of `Either a`, but *NOT* `forall a. Either a`.
11:31:10 <pyon> In fact, I don't think `forall a. Either a` even makes sense. :-|
11:32:11 <EvanR> youre right, it doesnt seem like you can form that in this language on 450
11:33:22 <pyon> I was a little baffled. `forall a. t` normally means «you give me a type `a`, I give you a value of type `t`». But a value of type `Either a` can't possibly exist, no matter what `a` is. :-|
11:33:24 <EvanR> well you can 
11:34:08 <EvanR> there are no values of type Either a, because * -> * doesnt have values anyway
11:34:16 <pyon> Yeah.
11:36:07 <pyon> Anyway, I'll assume that `:k (forall a. Either a)` is a syntactic quirk in GHCi, and it actually means «assume `a` stands for a type, then `:k (Either a)`».
11:36:51 <EvanR> but K-ALL still does not apply
11:37:19 <mpickering> I think the point is that K-APP then does apply
11:37:40 <EvanR> it doesnt apply to terms of kind * -> *
11:37:55 <pyon> K-APP itself works just fine with any kind, it seems to me.
11:37:58 <pyon> It's just K-ALL that's a problem.
11:38:09 <EvanR> what is T2 ?
11:38:31 <pyon> In this case, `T1 = Either` and `T2 = a`.
11:38:44 <EvanR> theres no T1 in the rule
11:38:58 <EvanR> and T2 = a is fine, since its *
11:39:08 <pyon> Oh, wait, I thought you were talking about K-APP.
11:39:17 <pyon> In K-ALL, T2 is the whole of `Either a`.
11:39:23 <EvanR> no its not
11:39:31 <EvanR> its not *
11:40:25 <pyon> Then K-ALL simply can't be made work for `forall a. Either a`.
11:40:36 <EvanR> no it cant
11:41:06 <pyon> And no other kinding rule even mentions `forall`, so `forall a. Either a` is simply not well-kinded.
11:41:23 <EvanR> i think forall a . Either a doesnt reduce to anything in isolation
11:41:32 <EvanR> it has a kind though
11:42:20 <pyon> How can it have a kind? The only rule that can possibly apply to something of the form `forall a. e` is K-ALL. And we couldn't make K-ALL work.
11:42:52 <EvanR> first of all, can we verify that you can even write forall a . Either a in the grammar provided
11:42:56 <Cale> You can only forall quantify type expressions of kind *
11:43:30 <glendc> Was starting the cis194 course and the "hanoi" exercice completely fucks my brain o.O 
11:43:30 <pyon> Exactly. But GHCi answers `:k (forall a. Either a)` with `* -> *`, rather than «kind error».
11:43:38 <pyon> Cale: ^
11:43:44 <Cale> pyon: Interesting
11:44:05 <EvanR> i guess its a bug after all
11:44:09 <MarcelineVQ> glendc: it's definetly a hard start, being tossed right into recursion, especially since the exercise isn't worded that great
11:44:42 <glendc> I do know recursion, I just can't wrap my head around it, as it becomes for example much more complicated from 4 disks on
11:44:44 <hpc> hanoi isn't trivial to understand either
11:45:29 <glendc> so perhaps I don't know recursion as well as I thought :|
11:45:37 <pyon> Can't you just perform induction on the number of disks to transfer?
11:45:45 <EvanR> pyon: can you explain how to construct forall a . Either a in F_omega
11:46:09 <glendc> in the homework he tries to give hints, via 3 lins of pseudo code, but that's like a huge simplification
11:46:48 <glendc> unless I'm making it more complex then it is
11:46:48 <wkmanire> glendc solving for 3 disks will just kind of emerge naturally.
11:46:51 <pyon> EvanR: Purely syntactically, it's possible. The left column in page 450 says so.
11:46:54 <EvanR> X = a, K = *, T = ...
11:46:54 <wkmanire> 3 towers
11:47:01 <wkmanire> Solving for 4 towers took me a while though
11:47:02 <EvanR> right
11:47:07 <pyon> EvanR: `Either a` is a type expression, and thus so is `forall a. Either a`.
11:47:16 <MarcelineVQ> I haven't done 4 peg yet
11:47:18 <pyon> It just... doesn't have a kind.
11:47:26 <EvanR> yeah, if T = T1 T2, and T2 = a, then what is T1 ?
11:47:44 <pyon> EvanR: In which rule?
11:47:50 <EvanR> universal type
11:48:07 <EvanR> using operator application
11:48:13 <wkmanire> glendc: Here's a hint: You can make multiple recursive calls in the same expression.
11:48:21 <EvanR> like what is the construction of Either
11:48:38 <pyon> EvanR: Well, System F-omega alone doesn't have Either, of course.
11:48:59 <pyon> Because it doesn't even have `data` declarations. :-p
11:49:24 <ttt_fff> with template ahskell, is it possible to get an entire file as a Expr ?
11:49:45 <EvanR> or any T with kind * => (* => *)
11:50:05 <hpc> glendc: solve this case:
11:50:24 <hpc> glendc: assume you already have an operator moveTower that can take a tower of arbitrary height and put it on one of the other two stacks
11:50:26 <pyon> EvanR: Those exist just fine.
11:50:28 <EvanR> "type abstraction" seems to be a no go 
11:50:45 <wkmanire> hpc: Hey, that's a nice way to think about it :)
11:50:50 <hpc> glendc: write a function that takes a tower of height+1 and moves it from one stack to another
11:50:58 <EvanR> meh
11:51:03 <MarcelineVQ> the best hint I can give for the hanoi problem, is to combine the algorithm he gives you into one line
11:51:20 <MarcelineVQ> Cause anything more is probably too much help, and anything less is just mystifying
11:52:03 <hpc> wkmanire: it's recursion
11:52:16 <hpc> assume small result, solve for larger
11:52:28 <wkmanire> hpc: I want a sandwich. 
11:52:31 <hpc> (or induction, rather)
11:53:02 <jmcarthur> hah, that's stupid. i tried hardcoding a lookup table as a big case expression, which maps from Word8 to something else, and ghc can't tell that the patterns are exhaustive
11:53:15 <jmcarthur> i guess nobody does this
11:53:42 <EvanR> pyon: heh, 451 has more
11:54:06 <MarcelineVQ> jmcarthur: if you're sure it's exhaustive, really really sure, you can have a catchall _ case at the end and that'll shut ghc up, but idk if that's a good idea
11:54:32 <jmcarthur> MarcelineVQ: i'm a little concerned that might make ghc not use a lookup table when i compiles? i could just check
11:54:38 <jmcarthur> *it compiles
11:54:50 <MarcelineVQ> I've not a clue about that
11:55:00 <jmcarthur> it probably does that implicitly anyway just because it thinks it needs it :(
11:55:02 <EvanR> pyon: see rule T-TABS
11:55:19 <pyon> EvanR: What about it?
11:55:21 <hpc> glendc: there's one more twist besides just that which you will have to deal with, but it's much more minor and easy to see once you're thinking in terms of base case and inductive case
11:55:24 <EvanR> hmm
11:55:49 <hpc> (and it's what makes hanoi such a great example of recursion in the first place)
11:55:53 <glendc> the thing that trips me over is that I have the feeling no one cares about the illegal rule of higher can't be on lowr
11:56:06 <pyon> EvanR: It doesn't mention forall.
11:56:09 <EvanR> well its two more rules that include forall
11:56:33 <pyon> T-TABS and T-TAPP.
11:56:52 <pyon> But they introduce any new kinding.
11:57:15 <DVE> sup
11:57:15 <MarcelineVQ> take your time with it glendc, this kind of problem comes up again a few times and getting it now will help a lot
11:57:41 <DVE> sup nigs
11:57:46 <glendc> I'll take my time :) Thx for the help though, I think I aleady got more help then I should get 
11:58:01 <DVE> this is a troll channel, right?
11:58:14 <glguy> Do you have a Haskell question?
11:58:27 <DVE> what the fucl is Haskell
11:58:29 --- mode: ChanServ set +o glguy
11:58:29 --- mode: glguy set +b *!*@gateway/web/freenode/ip.107.77.172.19
11:58:30 --- kick: DVE was kicked by glguy (DVE)
11:58:37 <jmcarthur> lame. the generated cmm is binary search :(
11:59:13 <MarcelineVQ> glendc: there's also #haskell-beginners channel which the course you're working on tends to come up quite a bit in, it's a pretty slow channel though so there's no reason not to ask those questions in here too
11:59:38 <shachaf> jmcarthur: I've run into that before (256 Word8 patterns not being exhaustive).
12:00:19 <jmcarthur> shachaf: did you ever manage to use a big case expression to make a lookup table this way? i can only get it to generate a binary tree like this
12:00:55 <jmcarthur> guess i'll resort to a vector or something
12:01:03 <shachaf> jmcarthur: I don't think so.
12:02:01 <EvanR> normally if its exhaustive it uses a lookup table?
12:02:47 <jmcarthur> i think it normally uses a lookup table if the patterns are "dense"
12:02:51 <jmcarthur> i don't know what dense means
12:02:59 <jmcarthur> it might only work for ADTs
12:03:30 --- mode: glguy set -o glguy
12:04:03 <Ralith> is ansi-wl-pprint current?
12:05:32 <ttt_fff> Is there a way to get all the *.hs files in my current cabal project as an EXPR ?
12:06:02 <ttt_fff> so it's sorta like Template haskell, but instead of just the strings inside of [| |], I'd like to run over my entire *.hs files
12:09:35 <p0a> Hello I am using Leksah and trying to follow the instructions at "3 Hello world example" in the manual http://leksah.org/leksah_manual.pdf
12:10:06 <p0a> After creating the module, the package and clicking save, I write main = putStrLn "Hello world" in the Main.hs file and for some reason ctr+alt+r does nothing
12:10:08 <shachaf> jmcarthur: To be fair to GHC, "Word8" isn't really a special integer type as a far as the compiler is concerned.
12:10:28 <shachaf> jmcarthur: It's just a Word# with a Num instance that treats it as a byte.
12:10:58 <shachaf> (But clearly this case should be handled somehow.)
12:12:12 * hackagebot streaming-bytestring 0.1.0.3 - effectful byte steams, or: lazy bytestring done right  https://hackage.haskell.org/package/streaming-bytestring-0.1.0.3 (MichaelThompson)
12:12:14 * hackagebot streaming 0.1.0.12 - A free monad transformer optimized for streaming applications.  https://hackage.haskell.org/package/streaming-0.1.0.12 (MichaelThompson)
12:12:28 <monochrom> http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#thinning
12:15:21 <jmcarthur> shachaf: fyi, the example at the bottom of this ticket attachment works (but requires making a huge ADT): https://ghc.haskell.org/trac/ghc/attachment/ticket/9159/ChunkBinSearchNotJumpTable.hs
12:15:45 <jmcarthur> i also need to see how tagToEnum# works
12:16:07 <jmcarthur> it's pretty awful in any case
12:16:27 <mniip> jmcarthur, it's a primitive
12:16:32 <shachaf> jmcarthur: Presumably this ADT is big enough in your case that the constructor won't fit in a pointer tag.
12:16:50 <ttt_fff> how do I get a ghc parse of all my *.hs files (taking into account flags in blah.cabal) asn a Expr ?
12:17:09 <shachaf> Still much better than binary search, of course.
12:17:35 <p0a> Anyone?
12:18:02 <jmcarthur> shachaf: the awful thing is that in my case the ADT would actually have to have the full 256 cases
12:18:14 <shachaf> Right.
12:18:37 <shachaf> I,I If GHC had unboxed sums, the ADT approach could work better in practice.
12:18:44 <jmcarthur> oh is that what tagToEnum# is for? pointer tags?
12:18:49 <jmcarthur> i don't see how that would work
12:19:30 <shachaf> I don't think so.
12:19:39 <shachaf> Though I wouldn't be surprised if it does generate a tagged pointer, I guess.
12:19:49 <p0a> Please help a newbie I'm just trying to get an environment ready to write some haskell l
12:19:53 <jmcarthur> bleh
12:19:58 <jmcarthur> i don't want a tagged pointer
12:20:56 <Saizan> p0a: there might not be many people that know leksah around
12:21:11 <glendc> from what branch of mathematics is induction?
12:21:21 <p0a> from none
12:21:30 <glendc> oh
12:21:59 <p0a> Saizan: I think the manual is written for an older version. That might make sense. I'll try to figure it out on my own
12:22:03 <Beardful> Is there a function like this - (IO a, b) -> IO (a,b)?
12:22:57 <lritter> glendc, https://en.wikipedia.org/wiki/Inductive_reasoning
12:22:58 <shachaf> jmcarthur: This binary search generates so much code. It's ridiculous.
12:23:08 <jmcarthur> i know! it's really dumb
12:23:16 <Saizan> glendc: it's pretty fundamental to any math you'd like to do, but mathematical logic is where induction is studied, among other stuff
12:24:09 <shachaf> What's the actual function you're writing?
12:24:09 <lritter> glendc, "Inductive reasoning is inherently uncertain" so it's clear why this is at most related to statistics
12:24:30 <lritter> and to quote my math teacher "statistic isn't really math" ;)
12:24:44 <monochrom> lritter, glendc: no, not from inductive reasoning. not from particularly any branch. a couple hundred years ago Peano formulated it. since then every branch uses it.
12:24:44 <Saizan> lritter: "induction" is an overloaded word
12:24:53 <lritter> "people who are bad at math tend to be pretty good at statistics and vice versa" he then added
12:25:03 <p0a> monochrom: nonsense
12:25:25 <lritter> deductive reasoning is the mathematical one
12:25:32 <Saizan> mathematical induction is actually deductive reasoning
12:25:40 <lritter> the article on inductive reasoning explains at length what the problem is
12:25:46 <xcv_> Beardful: yourFunc (ioa, b) = fmap (, b) ioa
12:25:50 <jmcarthur> shachaf: this particular one is a lookup table for converting from sRGB (using Word8) to a linear color space (for now using Doubles). i plan to write a lot more. i already have some using storable vectors, but you can only generate those dynamically, and i want to generate these LUTs statically if possible.
12:26:12 <jmcarthur> shachaf: i'm thinking i might go with using overloaded string literals to hardcode some bytestrings...
12:26:43 <Saizan> lritter: https://en.wikipedia.org/wiki/Mathematical_induction
12:27:55 <jmcarthur> i'm gonna see how bad the tagToEnum# version looks when compiled. if it's okay, maybe i can just use template haskell to hide this junk.
12:27:58 <lritter> Saizan, if this is what glendc actually meant then the answer to his question is "from the branch of proofs" ;)
12:28:34 <shachaf> jmcarthur: Just remember that \0 is UTF-8-encoded in compiled string literals.
12:28:52 <EvanR> statistics isnt math and induction isnt inductive
12:28:55 <EvanR> got it
12:28:56 <jmcarthur> yeah i would just generate it and use Show or something
12:28:59 <lritter> EvanR, :D
12:29:06 <glendc> I just wanted to make sure I understand the math, as I have a feeling that I'm missing some knowledge that is required for understanding hanoi and how to apply recursion to it
12:29:26 <p0a> EvanR: http://i.ytimg.com/vi/ohaLUlQhb2U/maxresdefault.jpg 
12:30:19 <p0a> glendc: To understand recursion try to think like this: "Assuming my function f solves the problem for up to n, how can I obtain solutions of n+1?"
12:30:22 <EvanR> a red herring may not be red or a herring
12:30:37 <p0a> :)
12:30:49 <monochrom> p0a: why did you say that my sentence was nonsense?
12:31:02 <glendc> what EvanR o.O
12:33:04 <p0a> monochrom: Because I strongly disliked the implication that Peano invented induction. To someone as clueless as glendc, your answer is highly misguiding. 
12:34:03 <glendc> I certainly feel very clueless, which is both great and frustrating.
12:35:25 <shachaf> jmcarthur: tagToEnum# isn't exactly optimal but I guess it does generate a table.
12:35:56 <glendc> https://www.khanacademy.org/math/precalculus/seq_induction/deductive-and-inductive-reasoning/v/deductive-reasoning-1 perhaps this will be a starting point
12:36:37 <MarcelineVQ> glendc: induction is in this case basically, what expression solves one disc move to one peg, what expression solves 2 moves, what solves 3, what's common bewteen them that can solve n steps.
12:36:52 <p0a> Actually reading math would be a starting point. Not much sense into reading about survival if you are not going to go out in the wilderness
12:37:08 <glendc> i also started relearning mathematics on my own
12:37:18 <p0a> Great, where do you study from?
12:37:25 <shachaf> jmcarthur: Of course, the way it does it is by indexing into a bunch of static ADT values, and then dereferencing one of those values to check the tag.
12:37:38 <glendc> I started with algebra, was going to move to calculas from there
12:37:49 <jmcarthur> shachaf: it does indeed... :\
12:37:53 <monochrom> I already chose the word "formulated" very carefully to minimize misguiding. at any rate, if I was highly misguiding, I don't know what "induction is inductive reasoning" is.
12:37:56 <p0a> whta have you done thusfar?
12:38:01 <MarcelineVQ> But I don't think induction research is neccesarily the best way to start here, the problem wants you to take the algorith it gives and rewrite it in haskell basically, try to read it all as one action
12:38:26 <shachaf> jmcarthur: You could also just write a Cmm primitive or something instead of a Haskell function.
12:39:02 <monochrom> but perhaps you like to pick on easy targets such as me.
12:39:18 <glendc> I also deal with the fact that English is only my third language, so I often end up learning a lot of new words while leearning these things
12:41:14 <srhb> glendc: Don't take the harsh words too hard. Most of us would never have said that. :)
12:41:26 <glendc> I haven't seen any harsh words :o
12:41:34 <glendc> I think your guys are really nice
12:41:34 <srhb> Oh, good!
12:41:35 <MarcelineVQ> me neither lol
12:41:44 <srhb> Perhaps I'm having language issues too :-)
12:41:46 <EvanR> FFFUUUUUUUUUU
12:41:47 <glendc> you guys* / or girls / or non-gnder peoplee
12:41:55 <srhb> glendc: Thanks ;)
12:42:24 <glendc> I just love programming, but I have to deal with massive fundamental issues all the time, which is why I'm re-learning a lot of basics in my free tim as well
12:42:31 * srhb nods
12:42:41 <greves> glendc yeah #haskell is pretty awesome
12:42:45 <greves> unlike #java =/
12:43:02 <EvanR> most language channels </bashing>
12:43:34 <glendc> well you all make this channel great I suppos
12:46:22 <glendc> are theree actually people here trying to make games with Haskell? As I was happy to learn that there is a company in London making a game in Haskll
12:46:35 <glendc> which made me wonder how much other companies are trying that
12:47:26 <glendc> it also made m wonder how well bindings to a library like C works, knowing that libraries like OpenGL are an entirely different kind of programming structure than Haskell programs are.
12:47:40 <glendc> a library like openGL (which is in C)***
12:48:03 <glendc> sorry my last sentence is slightly confusing
12:48:07 <jmcarthur> glendc: check out #haskell-game !
12:48:11 <glendc> oh ok :)
12:48:21 <sm_> glendc: not many companies or individuals, but a lot of folks are interested in it and experimenting with new libraries
12:48:29 <sm_> #haskell-game is active
12:49:28 <tromp_> :t fold
12:49:30 <lambdabot> (Foldable t, Monoid m) => t m -> m
12:50:27 <tromp_> :t foldr
12:50:29 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:50:37 <Gurkenglas> Will "map ($ f x) [g, h]" compute f x twice?
12:51:11 <Maxdamantus> Gurkenglas: no.
12:51:53 <Maxdamantus> it'll compute it 0 or 1 times.
13:00:35 <glendc> apperently you can keep it simple by saying that deductive reasoning is using facts to figure out a problem, while inductive reasoning is using patterns to determine solutions.
13:01:25 <srhb> glendc: Writing C bindings in Haskell is really easy.
13:02:01 <srhb> But of course you will have to take into consideration how the C code works. :)
13:02:09 <glendc> oh I didn't think writing the c bindings was hard on its own. I was more worried about the entirely different programming approach many of these libs are written in
13:02:46 <bz> how to define (>>>) in terms of first and arr?
13:03:50 <glguy> bz: You can't
13:04:11 <bz> glguy: then why is the minimal definition to fulfill class Arrow only require arr and first?
13:04:57 <bz> nvm
13:05:42 <Welkin> in pipes, `replicateM 10 await >>= mapM_ yield` on a stream with less than 10 elements will terminate the entire computation without ever yielding anything
13:05:45 <Welkin> correct?
13:06:08 <Welkin> that is what it seems to do
13:06:13 <Welkin> but that is not what I want it to do
13:06:26 <Welkin> I want to yield up to 10, let's say
13:06:29 <Welkin> er
13:06:31 <Welkin> await*
13:06:42 <glguy> Then maybe: replicateM_ 10 (await >>= yield)
13:06:44 <mauke> replicateM (await >>= yield)?
13:07:01 <Welkin> ah yes
13:07:02 <Welkin> very nice
13:07:20 <Welkin> sometimes it is simple :P
13:07:24 <Welkin> I just didn't see it
13:07:56 <monochrom> glendc: usually you write the bindings and call it the low level. then you write a layer that uses the low level in disciplined ways to provide a new API that fits Haskell better.
13:08:46 <glendc> monochrom: am I correct to assume that this is usually done within the same library? or is there no correct answer on that assumption?
13:09:58 <monochrom> sometimes in the same library. sometimes not. depends on authors.
13:10:14 <monochrom> also depends on economics.
13:10:45 <monochrom> you know, at the end, library provision is dominated by economics.
13:10:55 <glendc> really o.O
13:11:16 <monochrom> volunteer economics is pretty bizarre
13:12:48 <monochrom> actually, looks bizarre on the surface, but really conforming to the demand-price law once you know volunteers' real currency and hidden profit sources.
13:14:32 <monochrom> for example there are a couple of items on the most-wanted wish list for ghci, GHC's repl. for example "is there a command to display the docs of a library function?"
13:15:24 <monochrom> it is in such high demand and its cost looks so low, you may find it unbelievable that the volunteers still haven't done it. after 10 years.
13:15:53 <monochrom> the truth is that volunteers of GHC earn their profits in terms of "can publish an academic paper"
13:16:21 <monochrom> adding "display docs" to a repl doesn't earn you a paper. adding a new feature in the type system does.
13:16:26 <mauke> if you're good enough to hack on ghc, you probably don't need that feature anymore
13:17:31 <glguy> In the meantime there's a tool on hackage that provides that functionality and you can more or less add it to GHCi as a command via your .ghci
13:22:21 <cads1> im still pissed off at learning there's no ironhaskell for the clr
13:22:43 <cads1> dont some haskell honchos work at microsoft, wtf
13:23:50 <mauke> microsoft research*
13:24:29 <cads1> I /am/ happy to learn about the commercial haskell group and stackage 
13:26:34 <M-ou-se> State is defined as `type State s = StateT s Identity`, but wouldn't it be more useful if it was defined as `type State s = forall m. (Monad m) => StateT s m`? Now, you can't use a `State Foo Int` inside a `StateT Foo Maybe Int` without some weird tricks.
13:26:56 <M-ou-se> (i'm now using that definition of State, and all my code compiles fine)
13:28:29 <mauke> why not use (MonadState Foo m) => m Int?
13:29:06 <jmcarthur> well, beyond the obvious that MonadState is not in transformers
13:29:41 <geekosaur> State is basically of historical interest only, because it predates monad transformers
13:29:59 <mauke> oh, how did that happen
13:30:53 <geekosaur> transformers is just the mechanism. mtl is the actual implementations
13:34:38 <mpickering> also that definition will run into problems with impredicativity 
13:36:13 <geekosaur> (bit of history, you can implement monad transformers in two ways: via functional dependencies or via type families. so at one point we had monads-fd and monads-tf, and transformers which could work with either although a particular transformer had to be based on one or the other. fundeps won out for complex reasons, so mtl is effectively monads-fd + transformers)
13:37:02 <shachaf> Complex reasons?
13:37:25 <geekosaur> "type issues that are beyond my pay grade" :p
13:37:40 <M-ou-se> mpickering: can you explain?
13:38:57 <mpickering> You won't be able to write functions like foo :: State s -> State s
13:43:27 <M-ou-se> So this is the problem i have: I have several functions of type `StateT Foo Maybe a` that use the Maybe to report failure. i have some other functions that can never fail, so they have type `State Foo a`. but now it's quite annoying to use one of the never-failing functions inside a possibly-failing function.
13:44:23 <M-ou-se> using  `type State s = forall m. (Monad m) => StateT s m`  instead of the normal State seems to solve my issue. but there might be a better way..
13:46:11 <lpaste_> glguy pasted “Example of issue with the alternate state example” at http://lpaste.net/139905
13:47:46 <slack1256> M-ou-se seems what you want is mmorph
13:47:50 <slack1256> @where mmorph
13:47:50 <lambdabot> I know nothing about mmorph.
13:48:20 <slack1256> https://hackage.haskell.org/package/mmorph
13:49:03 <M-ou-se> oh, interesting
13:49:05 <slack1256> it will let you change the base Identity of State for the Maybe of your StateT Foo Maybe a. But you will write the first version only
13:49:15 <M-ou-se> `generalize :: Monad m => Identity a -> m a`
13:55:04 <Beardful> How do i make ghc search for my module whose filename is lowercase?
13:55:54 <monochrom> cannot. GHC insists on upper case filenames. (except for the file containing "main =")
13:57:00 <Beardful> monochrom: Ballocks, oh well.
13:58:14 <M-ou-se> is there some type class for all monads that can represent failure? (i guess that'd mean: All Monads that have a value v for which (v >>= _) == v) (So, Maybe, Either s, ... etc.)
13:59:11 <mniip> M-ou-se, Either doesn't have such a v
13:59:35 <tempname11> slack1256: are you suggesting to use 'hoist generalize' ?
13:59:47 <tempname11> what runtime cost does that have, I wonder?
13:59:59 <M-ou-se> mniip: Left  l >>= _ = Left l
14:00:15 <mniip> M-ou-se, and l is?
14:01:35 <M-ou-se> anything at all. i guess you're saying that it doesn't hold for `Either Foo` with just `data Foo`?
14:01:50 <mniip> Either Void
14:02:09 <M-ou-se> okay. then not Either s, but (SomeConstraint s) => Either s
14:02:21 <mniip> that's lame
14:12:26 <shersh> hello, everyone! Can anybody say if there `dropIf` function in haskell or how can I achieve it's behaviour without if-then-else and without pattern matching?
14:12:50 <Cale> shersh: What does it do?
14:12:55 <jmcarthur> can you explain what dropIf is supposed to do? what is its type, at least?
14:12:58 <Cale> shersh: Perhaps you want dropWhile?
14:13:41 <arw> or filter with the function argument negated?
14:14:03 <shersh> it drops first element of list if predicate is true or returns list without changes if predicate is false
14:14:27 <shersh> I want only first element drop, so `dropWhile` doesn't fit my needs :(
14:16:12 <tempname11> shersh: why don't you want pattern matching or conditionals?
14:16:20 <tulcod> shersh: something like this?  \list@(x:xs) -> if condition then list else xs
14:16:39 <tulcod> oops, sorry
14:16:49 <shersh> I need dropIf :: (a -> Bool) -> [a] -> [a]
14:17:17 <tulcod> shersh: well you'll need *some* pattern matching and if'ing. maybe it's hidden in the definition of something you're using, but in the end it's, mathematically speaking, necessarily an inductively defined function
14:17:28 * hackagebot Folly 0.1.4.1 - A first order logic library in Haskell  https://hackage.haskell.org/package/Folly-0.1.4.1 (dillonhuff)
14:18:02 <monochrom> shersh: "predicate is true" of which elements? the 2nd element? all odd-indexed elements?
14:18:03 <ReinH> dropIf p (x:xs) | p x = xs; | otherwise = x:xs
14:18:25 <ReinH> er, that ; is wrong but anyway it wouldn't be on one line
14:18:31 <p0a> Hello, assuming I have data Cons a = Cons a (Cons a), how can I create an object that refers to itself? i.e. parent x == x
14:18:38 <d-snp> do I get type families? a type class is a type set with varying implementations of functions for it, and a type family is a set of types with varying data fields?
14:18:57 <shersh> I just think than it would be more convinient to have such function in stdlib :) But maybe there is some analogue of it? I just don't want to create my own function for only one purpose
14:19:04 <glguy> p0a: let thing = Cons 10 thing in thing
14:19:07 <Jinxit> if I insert a trace into a function and call it twice with the same arguments, should it print the trace once or twice?
14:19:07 <monochrom> p0a: "x = Cons True x"
14:19:30 <p0a> Aha, thank you 
14:19:56 <p0a> couldn't be easier 
14:20:27 <monochrom> shersh: basically every week we see a request of "please add this function to the stdlib" but basically every request is supported by insufficient demand, basically one-person demand only.
14:21:01 <jmcarthur> monochrom: that's not true. you are only speaking of the ones that don't get added.
14:21:21 <jmcarthur> monochrom: many a function has been added to the stdlib by request (but by the request of many, not just of one)
14:21:24 <monochrom> they all lead me to conceive the idea of "Prelude.Twitter: contains every function writable in 140 bytes or less"
14:21:33 <MarcelineVQ> monochrom: hehe
14:21:56 <jmcarthur> i guess "basically" covers the others
14:22:09 <shersh> I don't want to demand and I realize that this function is not so popular. So maybe i can simulate it with other ones? I think about span, break and delete, but they just don't do this...
14:22:21 <monochrom> jmcarthur: please consider my blatantly weaselling use of "basically" multiple times!
14:22:29 * hackagebot Folly 0.1.4.2 - A first order logic library in Haskell  https://hackage.haskell.org/package/Folly-0.1.4.2 (dillonhuff)
14:23:28 <MarcelineVQ> shersh: Why does it need to be a library function you're using to do the task? someone already wrote something that'll do what you need: \list@(x:xs) -> if condition then list else xs
14:23:30 <tulcod> shersh: well surely you can find a combination of functions that does this. but it won't be faster or more clear
14:24:01 <tulcod> shersh: why do you not want to use simpler constructions?
14:24:06 <MarcelineVQ> If you want it to be prettier you can just write a prettier version
14:26:09 <shersh> I just want to write function in one line so it would be clear and concise. But maybe i just do the wrong thing. My task is to parse Int from String. But I want to parse Ints with one plus in the head. read :: String -> Int don't parse "+123" for example
14:26:28 <quchen> When I have "data List' rec a = Nil | Cons a (rec a)", I can create a full list by tying the knot with "List = Fix List'". This is the simple case where I factor out ordinary recursion from a single data type. What's the analogon for mutually recursive types? How would I do this for "data ListA a = NilA | ConsA a (ListB a); data ListB a = NilB | ConsB a (ListA a)"?
14:27:15 <jmcarthur> > stripPrefix "+" "+123"
14:27:16 <glguy> quchen: Fix (Compose Type1F Type2F)?
14:27:17 <lambdabot>  Just "123"
14:27:21 <monochrom> quchen, last time this was brought up, the conclusion was "too hard" because of lack of type-level tuple
14:27:39 <tulcod> shersh: what i suggested *is* clear and concise, isn't it?
14:28:04 <shersh> jmcarthur: thanks!
14:28:26 <jmcarthur> context always helps!
14:28:54 <slack1256> > read "-123" :: Int
14:28:56 <lambdabot>  -123
14:29:08 <shersh> tulcod: stripPrefix "+" "+123" is simpler and more concise than \list@(x:xs) -> if condition then list else xs
14:29:18 <jmcarthur> > read "+123" :: Int
14:29:20 <lambdabot>  *Exception: Prelude.read: no parse
14:29:20 <slack1256> it seems safe to always drop the + if you already have a number of the for (+Number)
14:29:24 <MarcelineVQ> shersh: That's because the 2nd one is general
14:29:32 <MarcelineVQ> Because the question was general :>
14:29:43 <jmcarthur> yeah, notably stripPrefix is not what you asked for
14:29:50 <MarcelineVQ> general/generic
14:29:51 <Jinxit> is there any way to verify that the result of a function is only calculated once? or is it always so?
14:30:04 <tulcod> shersh: if you first define if', then you could write what you want as:  dropIf p list = if' p list (tail list)
14:30:14 <monochrom> an answer that doesn't answer your question is always better
14:30:26 <tulcod> shersh: where if' is defined as: if' p x y = if p then x else y
14:30:33 <tulcod> shersh: (see also https://wiki.haskell.org/If-then-else about if')
14:30:49 <slack1256> Jinxit: You can make yourself sure if you bind the result of that function on a let/where pattern
14:31:15 <jmcarthur> slack1256: sort of sure. the inliner might still trick you.
14:31:33 <p0a> I'm trying to implement the union-find algorithm in haskell. I encounter a problem of efficiency: If I want to modify the root node, I essentially modify the whole tree, and therefore the operation is no longer O(1)
14:31:51 <p0a> Is there something more sophisticated for this type of problem in FP?
14:31:56 <monochrom> yes, union-find is fundamentally imperative (mutational)
14:31:57 <jmcarthur> p0a: union find is known to be super hard to do efficiently in purely functional style
14:31:58 <tulcod> shersh: but you don't need to write everything in haskell pointfree. it's not always better. https://wiki.haskell.org/Pointfree
14:32:04 <Jinxit> slack1256: I mean for calls from different parts of the code
14:32:16 <p0a> I just hit the hardest of walls in my first attempt at this huh
14:32:22 <jmcarthur> :)
14:32:30 * hackagebot Folly 0.1.4.3 - A first order logic library in Haskell  https://hackage.haskell.org/package/Folly-0.1.4.3 (dillonhuff)
14:32:41 <monochrom> there are a few union-find libraries on hackage. they do it in IO or ST.
14:32:44 <jmcarthur> p0a: you can always use ST or IO or something
14:33:37 <p0a> uhuh
14:34:16 <tulcod> p0a: i don't know union find, but maybe, by encoding your tree as some smart list, you can reuse the branches
14:34:17 <shersh> tulcod: I need to define if' function. I think than only hard or cumbersome things need to be define. Haskell has a huge number of blocks from which i can construct my own. But it is sometimes difficult to find the best and more suitable solution
14:34:24 <tulcod> p0a: might become O(1) without IO or ST
14:34:53 <guillaum2> Hi. Suppose I have a "data TypeA = TypeA Float" and "data TypeB = TypeB Float". How can I write a generic function which returns the Float contained inside ?. I thought about a typeclass and specific instance for each type, but can I specify only one generic implementation for both types instead of one implementation per type ?
14:34:59 <tulcod> shersh: would you be surprised if i said that you're overcomplicating things?
14:35:54 <jmcarthur> guillaum2: type classes allow you to have different implementations for each type
14:36:16 <guillaum2> jmcarthur: but the point is that I want the same implementation for both types
14:36:17 <slack1256> @type bool
14:36:20 <lambdabot> a -> a -> Bool -> a
14:36:23 <shersh> and stripPrefix still doesn't work. stripPrefix "+" "123" returns Nothing but I want "123" to be returned. I just need to parse int with one plus on the head. I don't think this problem should be difficult to solve
14:36:34 <tulcod> guillaum2: you might be looking for the deriving keyword
14:36:34 <slack1256> There is the if' function
14:36:49 <tulcod> slack1256: thanks, i thought i'd seen that once but couldn't find it
14:37:10 <slack1256> > bool (error "mama mia") (error "burn lambdabot burn!") False
14:37:13 <lambdabot>  *Exception: mama mia
14:37:15 <shersh> :t if'
14:37:15 <tulcod> shersh: dropIf p list = bool (tail list) list p
14:37:16 <lambdabot>     Not in scope: ‘if'’
14:37:16 <lambdabot>     Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
14:37:35 <jmcarthur> guillaum2: well, there is no way to pattern match where you're polymorphic in the constructor without having some specialized code somewhere
14:38:05 <lpaste_> glguy pasted “mutually recursive types for quicken” at http://lpaste.net/139911
14:38:10 <jmcarthur> guillaum2: in the future we will have type disambiguated record fields, which should solve this issue for your case
14:38:12 <slack1256> @let dropIf p list = bool (tail list) list (p $ head list)
14:38:13 <jmcarthur> guillaum2: but not yet
14:38:14 <lambdabot>  Defined.
14:38:21 <monochrom> glguy: it's quchen, not quicken :)
14:38:34 <slack1256> i like quicken, he is a cool guy
14:38:37 <rlewis> > dropWhile (=='+') "123"
14:38:38 <lambdabot>  "123"
14:38:48 <glguy> yeah, but my browser's autocorrect doesn't think "quchen" is a legitimate word :)
14:38:54 <tulcod> shersh: but really that code is not much more clear than the earlier lambda IMO
14:38:58 <glguy> quchen: that paste was for you
14:39:16 <lethjakman> so, you know when you only have to declare some of the class functions in order to have all of the methods?
14:39:19 <lethjakman> is there a name for that?
14:39:21 <monochrom> this is why I turn off every spellchecker on sight
14:39:21 <lyxia> guillaum2: Also in practice you don't run into situations where it can't be determined statically whether you are unwrapping a TypeA or TypeB...
14:39:22 <MarcelineVQ> shersh: stripPrefix "+" "+123" would give you 123 because it's stripping the + off, it's returning nothing because you gave it "123" which doesn't have a +
14:39:29 <lethjakman> so I know on hackage which ones I have to write myself
14:40:00 <shersh> dropWhile (== '+') "123" doesn't work either because it will parse "++123" either but this is what i don't want to appear
14:40:18 <tulcod> shersh: ??? we gave you an answer ???
14:40:21 <MarcelineVQ> I really don't know what you're after now lol
14:40:55 <shersh> what is the answer?
14:41:00 <tulcod> shersh: <slack1256> @let dropIf p list = bool (tail list) list (p $ head list)
14:41:28 <slack1256> > dropIf (== 'y) "ayyyyy lmao"
14:41:31 <lambdabot>      Syntax error on 'y
14:41:31 <lambdabot>      Perhaps you intended to use TemplateHaskell
14:41:31 <lambdabot>      In the Template Haskell quotation 'y
14:41:32 <tulcod> i really don't think it's better than some if-then-else stuff, but if this is what you want, this is it
14:41:35 <MarcelineVQ> If you have a +123 and you want it to become 123, anything proposed so far will work
14:41:57 <slack1256> > dropIf (== 'y') "ayyyyy lmao"
14:41:59 <lambdabot>  "yyyyy lmao"
14:42:07 <slack1256> > dropIf (/= 'y') "ayyyyy lmao"
14:42:10 <lambdabot>  "ayyyyy lmao"
14:42:11 <tulcod> shersh: and slack1256's solution means you are now depending on the additional bool-extras library. bit wasteful for just wanting to write code in a certain way
14:42:24 <slack1256> bool is in prelude
14:42:30 <shersh> :t bool
14:42:31 <lambdabot> a -> a -> Bool -> a
14:42:37 <tulcod> slack1256: uh?
14:42:48 <Clint> not in ghc 7.8 it's not
14:42:56 <quchen> monochrom, glguy: Thanks. Sorry I'm a bit busy because a friend was bitten by a dog just after I asked the question :-s
14:43:04 <shersh> not in my Prelude apparently...
14:43:06 <DrPavelheer> :t dropIf
14:43:07 <lambdabot> (r -> Bool) -> [r] -> [r]
14:43:09 <tulcod> Clint: nor in 7.10
14:43:12 <glguy> quchen: That happens
14:43:16 <slack1256> oh Data.Bool
14:43:41 <quchen> glguy: No, that does not happen. That never happens. I was so happily asking about Haskell and then this thing that never happens. It's like winning the lottery. It happens, but it really doesn't.
14:43:46 <quchen> Grrr.
14:43:49 <hvr> glguy: yeah... even knowing cat theory provides no protection against that
14:43:53 <slack1256> Mmm it is like dropIf can be implemented on Cont ...
14:44:13 <guillaum2> jmcarthur: ok, sadly. Thank you.
14:45:22 <tulcod> guillaum2: can't you solve this with a deriving(RealFloat) or something?
14:45:25 <slack1256> > dropIf (== 'S') "Spj's sandwichs"
14:45:28 <lambdabot>  "Spj's sandwichs"
14:45:34 <slack1256> > dropIf (/= 'S') "Spj's sandwichs"
14:45:37 <lambdabot>  "pj's sandwichs"
14:45:54 * slack1256 will show himself the way out
14:45:56 <MarcelineVQ> looks like you need to flip the bool in the definition
14:45:57 <monochrom> quchen: let's just say, "the impossible has happened!"
14:46:05 <quchen> monochrom: Panic was had
14:46:17 <slack1256> yeah, but I guess he got the gist
14:46:43 <monochrom> your friend is going to take a lot of painful syringe shots, if I understand correctly
14:46:50 <MarcelineVQ> the problem​ I have with it is that dropIf over a list, seems like it's more of a filter word than some head operation
14:47:04 <MarcelineVQ> just by wording, not action
14:47:05 <monochrom> or at least intimidating
14:47:09 <guillaum2> tulcod: actually my problem is more complex. I have ten data which all looks like "data T = T Float Float Float" with different T. I have something such as 10 function that I want to implement which are :: T -> T -> T and works exactly the same for all T
14:47:28 <guillaum2> tulcod: the naive solution is to duplicate all the work, but I don't like that.
14:47:33 <quchen> monochrom: This isn't the place for discussing dog bites, so I'll close with "it will be alright it's a friend's dog"
14:47:55 <tulcod> guillaum2: well tbh it also sounds like you're solving the wrong problem here, but i don't know what you're working on so i might very well be wrong :)
14:48:12 <tulcod> guillaum2: (like, type introspection is generally a bad sign, but you might have a valid use case :) )
14:48:44 <tulcod> guillaum2: and yeah, type classes could alleviate the pain here
14:48:55 <guillaum2> tulcod: my different T are different colorspace (RGB, HSL, HSV, XYZ, ...). I need to be able to do addition / substractions / scalar multiplications, ... between items inside those colorspace, but not between items of different colorspace
14:49:07 <arkeet> why do you have 10 different types with the same shape?
14:49:08 <shersh> well, thank you guys! I'll think about your solutions
14:49:13 <arkeet> why not make them newtypes of (Float,Float,Float) or something
14:49:22 <tulcod> guillaum2: definitely use type classes. addition might not work like you'd expect.
14:49:34 <arkeet> I dunno.
14:49:47 <tulcod> guillaum2: adding two RGB triples is something else than converting to HSV, adding the HSV values, and then converting back to RGB
14:50:05 <tulcod> guillaum2: so you're going to break some algebraic laws that one might expect here
14:50:21 <monochrom> yeah, RGB addition is very different from HSV addition. you really need to write custom code.
14:51:03 <quchen> glguy: So the "Fix (Annotated f)" way of builing a syntax tree isn't really a viable option then? I'm asking because I'm thinking of implementing quite a complex tree in Haskell, and there is no way I can do it in a single ADT.
14:51:19 <tulcod> guillaum2: what do you want e.g. addition to represent? like mixing of lights of various colors?
14:51:36 <tulcod> guillaum2: in that case, you'll find that adding two HSV's is actually very nontrivial
14:51:50 <tulcod> (easiest thing would just be to go via RGB)
14:52:24 <guillaum2> tulcod: actually, yes. Basically stuff are done in XYZ, but users also want the ability to add in other colorspace, because they want it...
14:52:31 * hackagebot HUnit-Plus 1.1.0 - A test framework building on HUnit.  https://hackage.haskell.org/package/HUnit-Plus-1.1.0 (emc2)
14:52:33 * hackagebot linearscan 0.10.0 - Linear scan register allocator, formally verified in Coq  https://hackage.haskell.org/package/linearscan-0.10.0 (JohnWiegley)
14:52:35 * hackagebot linearscan-hoopl 0.10.0 - Makes it easy to use the linearscan register allocator with Hoopl  https://hackage.haskell.org/package/linearscan-hoopl-0.10.0 (JohnWiegley)
14:52:37 * hackagebot Folly 0.1.4.4 - A first order logic library in Haskell  https://hackage.haskell.org/package/Folly-0.1.4.4 (dillonhuff)
14:52:38 <tulcod> guillaum2: yeah, so what does "add" mean here?
14:52:59 <guillaum2> (But I don't really want to discuss about how that's a good idea to add different colorspace, but more about how I can write this in haskell ;)
14:53:10 <guillaum2> tulcod: here add is addition per channel.
14:53:22 <tulcod> but why would you "add" different hues together?
14:53:30 <tulcod> physically, that doesn't make any sense
14:53:55 <tulcod> (except if you want to talk about photon energy)
14:54:14 <tulcod> (and even then it's not what you expect)
14:54:47 <tulcod> okay, i said what i needed to say, i should shut up
14:55:55 <guillaum2> tulcod: don't get me wrong, your point is appreciated and I think you are right ;) But for now I'm interested in the possibility to represent this concept in haskell, not on the corectness of the concept)
14:56:20 <gamegoblin> Wish IORef and STRef were both instances of some common interface. 
14:57:05 <kadoban> guillaum2: But without a concept of what it means … it's hard to know if you did it right or not.
14:57:29 <tulcod> guillaum2: also sounds like Typeable and Data.Data might be relevant here. but tbh i never used those so i might be wrong
14:57:40 <arkeet> gamegoblin: they internally are.
14:57:51 <gamegoblin> arkeet: I want it externally then ;)
14:57:54 <arkeet> :)
14:58:06 <guillaum2> kadoban: I'm not sure I agree with you on that ;)
14:58:18 <gamegoblin> arkeet: I want a generic newRef readRef etc so I can write code that uses IO in production and ST in tests.
14:58:22 <arkeet> here you go https://hackage.haskell.org/package/primitive-0.6/docs/Data-Primitive-MutVar.html
14:59:07 <monochrom> several libraries on hackage provide the common type class
14:59:09 <tulcod> guillaum2: if you want to be evil, you can just coerce all those data triples to a single one, do your thing, then coerce back
15:00:16 <guillaum2> tulcod: but I still need to be able to write a generic function which pattern match, such as: "addGeneric (T a b c) (T a' b' c') = T (a + a') (b + b') (c + c')"
15:00:58 <runeks> How do I properly read a large, binary file one well-defined data structure at a time? I'm using hGetContents from Data.ByteString.Lazy now, for each read, but only the first hGetContents decodes correctly into a data structure, the next always fails, so something is telling me this is the wrong approach.
15:01:19 <Rembane> runeks: Read a fixed number of bytes each time and parse them.
15:01:26 <glguy> runeks: You only get to call hGetContents on a Handle once
15:01:28 <monochrom> runeks: paste code on lpaste.net
15:01:38 <glguy> after that the Handle isn't yours any more
15:01:46 <runeks> Rembane: I wasn't able to find a function that reads a fixed number of bytes
15:02:03 <glguy> The fixed bytes reading function is "hGet"
15:02:16 <Rembane> runeks: Oh. Luckily glguy did. :)
15:02:18 <glguy> :t Data.ByteString.hGet
15:02:21 <lambdabot> GHC.IO.Handle.Types.Handle -> Int -> IO BSC.ByteString
15:02:39 <monochrom> you can also use "splitAt"
15:03:02 <runeks> Thank you all. I will try with that.
15:03:28 <Rembane> Good luck!
15:05:06 <tulcod> guillaum2: the SYB stuff (Data.Typeable and Data.Data) looks relevant - http://chrisdone.com/posts/data-typeable
15:07:13 <guillaum2> tulcod: thank you, I'll have a look.
15:07:33 * hackagebot Folly 0.1.4.6 - A first order logic library in Haskell  https://hackage.haskell.org/package/Folly-0.1.4.6 (dillonhuff)
15:08:40 <glguy> guillaum2: You can do it with GHC Generics. I'll paste an example in a moment
15:14:33 <lpaste_> glguy pasted “generic pairwise addition” at http://lpaste.net/139912
15:15:02 <guillaum2> glguy: thank you.
15:15:11 <ttt_fff> for TH, is it possible to (1) feed it the name of a module, and (2) have the TH code load up the entire module as an EXPR ?
15:15:22 <ttt_fff> so normally, for TH, it can only look at the expression passed to it.
15:15:37 <ttt_fff> However, I don't want to just pass it the stuff inside of [| ... |]. I want to feed it an entire module.
15:17:28 <guillaum2> glguy: ok, my brain just melt for today, it's paste midnight, but I'll read the documentation of ghc generic tomorrow, that's interesting. Thank you.
15:17:35 <glguy> guillaum2: I don't know if that's better than writing all 10 or whatever you needed manually, but that's how you can do it
15:18:21 <glguy> guillaum2: Each type will need one of these lines: instance PairwiseAdd T1 where (<+>) = genericPairwiseAdd
15:20:15 <ttt_fff> or .... use template haskell :-)
15:20:22 <glguy> guillaum2: Another nice thing is that those generic implementations don't have any runtime overhead
15:20:32 <glguy> The template haskell version would be much messier
15:22:18 <ttt_fff> is there a way, in TH, to read in an entire module as an EXPR? There is https://gist.github.com/Tener/4eae297562ae26781b01 for reading in a single file, but I wnat the file parsed, with the GHC extensiosn used in my blah.cabal file
15:22:36 * hackagebot opaleye-classy 0.3.1.1 - Opaleye wrapped up in classy MTL attire.  https://hackage.haskell.org/package/opaleye-classy-0.3.1.1 (BenKolera)
15:22:42 <ttt_fff> I basically want TH to read in the entireity of some module, then do some work on it, then output code
15:36:00 <ksaraswatIN> i am a newbie, can you tell me the purpose of haskell
15:36:30 <jmcarthur> ksaraswatIN: Haskell is a general purpose programming language.
15:36:40 <Welkin> 18:19 < ttt_fff> or .... use template haskell :-)
15:36:43 <Welkin> I am reminded of this: https://twitter.com/smdiehl/status/637735836654661632
15:36:51 <Welkin> also, ttt_fff, you are obsessed
15:37:28 <mpickering> ttt_fff have you heard of the LMS scala framework?
15:37:33 <montanonic> ksaraswatIN: a lot of people, myself included, find that Haskell code is easier to understand, because it allows for many high level abstractions. And because it makes it easy and smart to abstract code, you can also find patterns in things that you might not have been able to reason about in another language.
15:37:34 <mpickering> (lightweight modular staging)
15:37:39 <geekosaur> th has its place. less often than one might think from metaprogramming in other languages...
15:37:41 <ksaraswatIN> moving to haskell, where should i start 
15:37:53 <montanonic> ksaraswatIN: The Haskell Wikibook is good.
15:38:02 <mpickering> there's also meta ocaml which has some of these staging ideas
15:38:12 <ttt_fff> mpickering: never used scala
15:38:19 <ttt_fff> mpickering: tried to understand it, found it too confusing
15:38:31 <montanonic> ksaraswatIN: If you've never done functional programming before though, you might want to start with one of the intro books recommended on the Haskell website
15:38:45 <ksaraswatIN> sure will check that out
15:38:53 <Welkin> I find that other languages which try to mimic certain aspects of haskell have very ugly syntax
15:38:56 <mpickering> well my point is that it sounds like you want some kind of staged compilation
15:39:15 <mpickering> and as far as I know, nothing really like it exists yet in haskell 
15:39:21 <montanonic> ksaraswatIN: here's their list https://www.haskell.org/documentation
15:39:22 <ttt_fff> mpickering: yeah, I do, I basicallyw ant my code compiled twice, once as ghc, and once via TH with my haskell -> js compiler, so sorta like haste
15:39:32 <ttt_fff> https://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/src/Language.Haskell.TH.Syntax.html#reifyModule <-- so this here allows me to lookup ModuleInfo
15:39:38 <ttt_fff> unfortunately, ModuleInfo is just a list of [Module]
15:39:45 <ttt_fff> and each Module is just a ModuleName and  PKGName
15:40:07 <ttt_fff> so my question is, given a "Module", is there a way to get all the global defs in that module (data declarations, function declarations, class declarations, etc ...), all as Q Exps, ideally
15:40:14 <mpickering> so if you want to be the one to bring lms to haskell then I think it would be appreciated :)
15:40:36 <jmcarthur> i have my own TH question. i am defining a function roughly of type   (a -> b) -> Q Exp   and i want to constrain the resulting expression to have the same type as the input function, but i can't figure out how to do that. does somebody here know?
15:40:52 <montanonic> ksaraswatIN: and this might be the quickest way to get started with Haskell: https://www.fpcomplete.com/school/starting-with-haskell/introduction-to-haskell
15:41:07 <ttt_fff> mpickering: I haven't written a single hackage package, (2) and my greatest achievement of the past week is not getting kickbanned a 2nd time; I don't think I have the skills to bring multi-stage-compilatino to haskell :-)
15:41:09 <montanonic> ksaraswatIN: you don't need to install anything to write code on that website
15:41:27 <glguy> jmcarthur: There's typed template haskell
15:41:44 <montanonic> ksaraswatIN: feel free to browse other tutorial groups on FPComplete; hopefully you'll find something appropriate for your current comfort level
15:42:07 <ttt_fff> jmcarthur: err, so you want to write a macro mac, s.t. forall f :: a -> b, $(mac f) has type :: a -> b ?
15:42:22 <ksaraswatIN> montanonic : thanx !!!
15:42:34 <jmcarthur> glguy: it's not so much that i'm afraid of getting it wrong, but that i need to constrain the type of the generated expression to match that of the input function to assist with type class resolution.
15:42:55 <glguy> jmcarthur: I'm not worried about why you need typed template haskell, I'm just saying that it exists :)
15:43:02 <jmcarthur> ttt_fff: yes. i have in fact written it, but right now it requires a type annotation as the use site
15:43:23 <jmcarthur> glguy: i will have to look into it, but my understanding is that it's still experimental?
15:43:41 <jmcarthur> *at the use site
15:43:50 <ttt_fff> jmcarthur: yeah, I agree with glguy, a function in, functino out, sounds like the type of thing you can do with standard ahskell
15:43:58 <mpickering> jmcarthur: I think it's experimental in the sense that it hasn't been battle tested as people don't know about it
15:44:00 <jmcarthur> err
15:44:12 <jmcarthur> ttt_fff: i think you have misunderstood. i am actually using the function at compile time
15:44:12 <ttt_fff> TH, I think, is for weird things like "I want it to read this data type, and generate these functions" or "I want it ot read this data type, and generate more dat types"
15:44:14 <mpickering> I think it's supposed to work
15:44:36 <montanonic> ksaraswatIN: no problem! if you've never used a functional language before, be prepared to spend a while getting used to it, fair warning. But, everyone goes through that, so don't worry about it if you feel like you're not understanding it.
15:45:01 <ttt_fff> jmcarthur: you want a TH amcro mac, s.t. (1) for all f:: a-> b, f' = $(mac f) has type :: a -> b, (2) AND the value/code of f' depends on the behaviour of f ?
15:45:12 <jmcarthur> ttt_fff: correct
15:45:22 <jmcarthur> ttt_fff: again, i already have that. it's just the type constraint i'm stuck on
15:45:25 <ttt_fff> jmcarthur: what are you doing, summoning a 5 legged cow?
15:45:41 <jmcarthur> ttt_fff: i'm statically generating a lookup table
15:45:42 <ttt_fff> i'm really curious, how do you use this in practice, this sounds either genius or insane
15:45:50 <ksaraswatIN> montanonic : i am having a session on haskell, this week wanted to get a kickstarter first.
15:46:02 <jmcarthur> ttt_fff: and the type is not inferred correctly because it's a very low level lookup table using storable
15:46:10 <glguy> ttt_fff: I'm talking about Type Template Haskell which isn't normal Haskell
15:46:25 <lethjakman> so I'm trying to retrieve from a file and use the Data.Yaml file to decode some stuff. The file I'm using to decode though is giving me an error that it's a Maybe SesKeys instead of a IO SesKeys. can anyone tell me why it's expecting IO to be the return value?
15:46:34 <montanonic> ksaraswatIN: gotcha! well I hope you have fun and learn a lot! 
15:46:41 <mpickering> lethjakman: please paste your code
15:46:52 <ttt_fff> oh, okay, so you have something like "gen_at_compile_time_for_constant_runtime f ==> f'" then you do "fib ==> fib'", "square ==> square'", and during runtime, you can lookup, and it's fast (no computation involved)
15:46:56 <ttt_fff> and you want the f' to ahve the same type sig as f
15:47:01 <jmcarthur> correct
15:47:04 <glguy> jmcarthur: If you paste the current code I can play along at home
15:47:10 <ksaraswatIN> montanonic: hoping so !
15:47:21 <jmcarthur> glguy: good idea
15:47:28 <lethjakman> mpickering: whoops
15:47:30 <lethjakman> https://gist.github.com/lethjakman/e421abb5211a990e397c
15:47:33 <lethjakman> sorry I got distracted
15:47:57 <lethjakman> why can't you read my mind?! I thought haskell was the language of magicians!
15:48:09 <lethjakman> or...was that mathematicians...
15:48:13 <lethjakman> same difference
15:48:14 <mpickering> you'd be surprised how many people think that..
15:48:33 <geekosaur> type system magicians. if the mind were typesafe we wouldn't have depression etc.
15:49:01 <mpickering> anyway, your problem is the statements in this do block need to have the type IO _ 
15:49:03 <ttt_fff> this is not Coq though, so it could still infinite loop
15:49:06 <ttt_fff> as well as run out of space
15:49:14 <lethjakman> mpickering: what do you mean?
15:49:34 <mpickering> decode yamlConfig is of type Maybe SesKeys which is why you get the error
15:49:40 <jmcarthur> glguy, ttt_fff: comments on style and other concerns are also appreciated, because i have very little experience with TH: http://lpaste.net/139913
15:49:50 <lethjakman> mpickering: but I think that's w hat I want, no?
15:50:01 <jmcarthur> i also haven't really battle tested this lookup table implementation yet, so it might be bad too, but it's kind of a separate issue from my question
15:50:02 <ttt_fff> jmcarthur: will look at it, but only started with TH about 24 hours ago, so i'm a newb
15:50:40 <Rembane> I want to consume one character with Parsec, matching on any character, how do I do that?
15:50:49 <mpickering> lethjakman: What type do you expect `getsesAccessKey` to have?
15:50:59 <ttt_fff> jmcarthur: I have a dumb question; why can't you do this in normal haskell? i.e. build this table, deep seq it, and now, poof, you have a lookup table
15:51:02 <lethjakman> mpickering: sesKeys
15:51:12 <lethjakman> sorry I'm still getting used to haskeell
15:51:14 <lethjakman> haskell 
15:51:21 <mpickering> Rembane: Isn't there an anyChar parser?
15:51:27 <jmcarthur> ttt_fff: i can, but i'd rather just do it statically so there is a hard-coded pointer
15:51:58 <Rembane> mpickering: There is, I just missed it. Thank you!
15:52:03 <mpickering> ok! That is one type the function can't have. 
15:52:41 <lethjakman> mpickering: was that in reference to me?
15:52:42 <glguy> jmcarthur: I think that the tricky part will be getting stringPrimL into Typed TH...
15:52:48 <lethjakman> does it have to be Maybe SesKeys
15:52:53 <molnarjani> hello :)
15:52:57 <mpickering> because you are using readFile, the type of the whole do expression has to be "IO a" for some a
15:53:02 <jmcarthur> glguy: ah, that makes sense
15:53:06 <glguy> jmcarthur: Is there no syntax for that in Haskell?
15:53:14 <jmcarthur> glguy: there is in GHC haskell
15:53:19 <glguy> OK, what is it?
15:53:20 <jmcarthur> glguy: "string literal"#
15:53:32 <molnarjani> Im having trouble installing palf's sdl2 examples
15:53:34 <molnarjani> https://github.com/palf/haskellSDL2Examples
15:54:05 <molnarjani> it import Shared.Lifecycle ...etc bu apparently cabal has no idea what to do with them
15:54:35 <jmcarthur> glguy: the type of that literal is Addr#
15:54:37 <molnarjani> so i get an error like this: src/lesson01.hs:4:8:     Could not find module ‘Shared.Lifecycle’     Use -v to see a list of the files searched for.
15:54:46 <mpickering> lethjakman: Sorry I don't know how to explain this very well but I will try.  Are you comfortable with monads?
15:54:58 <lethjakman> mpickering: fairly. 
15:55:07 <mpickering> do you know how do notation desugars?
15:55:31 <mpickering> If we desugar your example here... 
15:55:43 <lethjakman> ...no
15:56:35 <mpickering> @undo do { ymlConfig <- readFile "myfile.yaml"; decode yamlConfig }
15:56:35 <lambdabot> readFile "myfile.yaml" >>= \ ymlConfig -> decode yamlConfig
15:57:15 <Welkin> molnarjani: it looks like the directory name needs to be capitalized
15:57:31 <montanonic> I have a question regarding Yesod and Stack: I'm wanting to use https://github.com/mpietrzak/yesod-purescript with a project, however, it does not exist on Stackage, only Hackage. I know the project uses several Hackage-based packages and interfaces them with Stack, but I don't know /where/ I should be looking within the Yesod project directory to add any links to Stack. Sorry, bit of a noob...
15:57:32 <montanonic> ...with Stack.
15:57:37 <mpickering> so that is the desugaring, the type of >>= is IO ByteString-> (ByteString -> IO b) -> IO b
15:58:08 <mpickering> and you can see that the type of decode yamlConfig doesn't match IO b
15:58:12 <lethjakman> mpickering: so you toss it into a lambda?
15:58:16 <mpickering> which is why there is a type error
15:58:22 <Welkin> molnarjani: I see it in "shared/lifecycle.hs", but I believe it is looking for "Shared/Lifecycle.hs"
15:58:40 * geekosaur guesses that was composed on windows or os x
15:58:48 <mpickering> do { a <- foo; b a } desugars into foo >>= \a -> b a
16:00:13 <lethjakman> mpickering: oh, so desugaring converts it from <- to >>= style?
16:00:19 <lethjakman> that helps
16:00:31 <mpickering> yes
16:00:44 <glguy> jmcarthur: yeah... I'm not sure how to get a programmatically generated string primitive literal into typed TH...
16:00:52 <lethjakman> but I don't get where the IO is supposed to come from?
16:01:01 <jmcarthur> bummer
16:01:02 <Welkin> molnarjani: you will probably be better off using lazyfoo's sdl2 tutorials (in c++) and using the raw SDL2 bindings directly, found on hackage
16:01:09 <Welkin> molnarjani: cabal install sdl2
16:01:11 <mpickering> well it happens that there is a function a -> IO a
16:01:21 <mpickering> which you can use
16:01:54 <Welkin> molnarjani: it looks like the person who wrote the repo you linked is using all kinds of his own custom functions wrapping the lower-level functions
16:02:04 <Welkin> molnarjani: so it will probably be a waste to try to decipher it
16:02:16 <mniip> guys
16:02:24 <mniip> I need feedback
16:02:39 <molnarjani> Welkin: thanks a lot, i managed to run it
16:03:02 <ttt_fff> argh
16:03:04 <mniip> on some haskelly mathy stuff
16:03:07 <ttt_fff> i want my entire module as an expr
16:03:10 <ttt_fff> to my template haskell function
16:03:13 <jmcarthur> anyway, i guess my actual question boils down to this mystery function:   foo :: a -> Q Type
16:03:19 <mniip> http://mniip.com/pages/ZAlgorithmOnConsCells
16:04:41 <molnarjani> Welkin: well i will take you advise on that couse i really have no idea what does things like this do:  applyToPointer operation pointer = liftM operation $ peek pointer :D
16:04:56 <molnarjani> your*
16:06:21 <Welkin> molnarjani: if you really want to understand, stick to the official SDL2 API and avoid "high-level" abstractions on top of it
16:06:44 <Welkin> it is a good way to learn the C Foreign Function Interface too :P
16:07:13 <Stratege> molnarjani liftM f x is just: x >>= return . f. So you are just applying operation to pointer, as it says.
16:08:27 <Stratege> (without actually mutating the pointer's content, but creating a new copy)
16:09:13 <molnarjani> Well was about to start lazyfoos sieries anyways, but i thought it would be nice to have some sort of running code ready if i need to take a quick peek :D
16:09:28 <ttt_fff> alright, I should stop spamming templat ehaskell here
16:09:30 <ttt_fff> is there a TH channel?
16:10:20 <jmcarthur> doubtful
16:10:56 <ttt_fff> well, there is my justificatino for spamming here then
16:11:12 <ttt_fff> either that or ghc as a library
16:11:35 <jmcarthur> i'm considering just renaming my function to unsafeMemo and calling it a day...
16:11:51 <Welkin> molnarjani: I have a simple example here (although it uses opengl for rendering) https://github.com/ericnething/gl-sdl2-basics
16:12:01 <ttt_fff> jmcarthur: this is sorta dumb, but why not pass it 3 args
16:12:02 <Welkin> molnarjani: also, you can join #haskell-game 
16:12:14 <ttt_fff> i.e. $(mymemoize f a b), where f :: a -> b
16:12:17 <jmcarthur> ttt_fff: it wouldn't be type safe anyway, so just as unsafe
16:12:36 <ttt_fff> jmcarthur: no no, it will be type safe, since mymemoize can now label its output as f' :: a -> b
16:12:51 <jmcarthur> it wouldn't be able to check that f has the claimed type though
16:13:21 <jmcarthur> it's no better than an explicit type annotation as the use site (which is what i'm doing already)
16:13:23 <ttt_fff> jmcarthur: if f did not have the correct type, it'd barf when constructing the table for f'
16:13:25 <jmcarthur> *as the use site
16:13:35 <jmcarthur> i don't see how it would barf then
16:13:48 <ttt_fff> hmm
16:13:53 <jmcarthur> at compile time it has some idea of what the type of f is and doesn't care about the other arguments
16:14:01 <ttt_fff> actually I'm goign to admit ignorance, and can't help unless you can present an f where this is typeunsafe
16:14:03 <ttt_fff> becuase it looks typesafe to me
16:14:07 <jmcarthur> and then the generated code can specify some other random type
16:15:56 <molnarjani> Welkin: well thanks a lot for all the help :) its good to see such a lovely community :)
16:15:57 <jmcarthur> ttt_fff: i will present my unit tests in their working form and then explain how to break them
16:16:12 <ttt_fff> jmcarthur: that'd be helpful
16:17:05 <jmcarthur> ttt_fff: see the annotation for the working unit tests: http://lpaste.net/139913
16:17:51 <jmcarthur> ttt_fff: to break type safety, change Double to Float on the definition of gMemo, and change the use of gMemo in the unit test to (realToFrac . gMemo)
16:18:29 <jmcarthur> ttt_fff: now i am memoizing a function of type Word16 -> Double by writing a bunch of doubles into an array, but i'm reading Floats out of it instead of Doubles
16:18:56 <Welkin> molnarjani: you are welcome. Now go build some games!
16:19:28 <Welkin> molnarjani: haskell is a great language for games :)
16:19:50 <jmcarthur> molnarjani: there's a #haskell-game channel!
16:20:12 <jmcarthur> molnarjani: also, here's some lazyfoo stuff https://github.com/haskell-game/sdl2/tree/new-api/examples/lazyfoo
16:20:47 <ttt_fff> jmcarthur: okay, I admit I was incorrect.
16:20:48 <Welkin> jmcarthur: pushing that new api I see
16:21:04 <jmcarthur> Welkin: well supposedly it's going to be on hackage soon
16:21:14 <Welkin> I heard it was today
16:21:21 <jmcarthur> i also heard that
16:21:25 <jmcarthur> we should poke ocharles__ 
16:21:27 <jmcarthur> poke!
16:24:33 <jmcarthur> maybe i can do some sort of coercion into typed TH to achieve what i want
16:27:42 <jmcarthur> :o
16:27:43 <jmcarthur> that was easy
16:27:47 <jmcarthur> \o/
16:28:43 <jmcarthur> ttt_fff, glguy: you will be interested to learn that all i did to solve this was wrap the result in TExp and change the type of memo to (Bounded a, Enum a, Storable b) => (a -> b) -> Q (TExp (a -> b))
16:29:03 <jmcarthur> so now a use site looks like $$(memo f), and it's type checked
16:29:16 <ttt_fff> why is it $$ instead of $ ?
16:29:25 <ttt_fff> so basically you spent twice as much $ and got want you wanted?
16:29:25 <jmcarthur> that's apparently just how typed template haskell works
16:29:36 <ttt_fff> oh, typed template haskell
16:29:39 <ttt_fff> i need to look that up
16:29:42 <jmcarthur> i cheated of course
16:29:58 <jmcarthur> i used untyped template haskell to generate typed template haskell
16:30:15 <glguy> Oh, neat trick
16:30:52 <mpickering> I think that is all it is though? Just a wrapper with a phantom parameter?
16:30:57 <jmcarthur> right
16:31:08 <jmcarthur> i think you aren't usually supposed to use it this way, is all
16:31:36 <jmcarthur> you're supposed to build them in a type safe way
16:36:13 <ttt_fff> ARGH
16:36:21 <ttt_fff> why does google tell me nothing useful about "template haskell entire module"
16:36:33 <ttt_fff> I want an entire module as Q [Exp]; yet; there appears no way to do this in Haskell
16:36:36 <mpickering> maybe you are the first person to try
16:36:55 <mpickering> you've asked this question three times in the last two hours!
16:37:00 <ttt_fff> no no, in haskell, things are named for the 2nd person to try after edwardk
16:37:48 <slack1256> try to answer what you want to know incorrectly
16:37:59 <slack1256> somebody will get pissed, yell and give you useful info :-)
16:38:04 <geekosaur> you can't get that, iirc; TH has no way to handle things like imports
16:38:37 <ttt_fff> scala is better than haskell, because in scala, it's possible to import an entire module, and do meta programming on that; whereas in TH, I am forced to do meta programming on the code inside of [| .... |]
16:38:48 <ttt_fff> so should I be looking at ghc as a library instead of TH then?
16:39:26 <jmcarthur> ttt_fff: well, if you could do this it certainly wouldn't have the type you just have
16:39:57 <jmcarthur> ttt_fff: maybe check the TH syntax, and if it doesn't even have a way to represent modules then you are just done
16:39:58 <ttt_fff> yeah, it't be Q [ (Exp or TypeDecl or .... )]
16:40:08 <ttt_fff> it has "Module" and "ModuleInfo"
16:40:12 <ttt_fff> the former is a wrapper of string
16:40:15 <ttt_fff> the latter is a [Module]
16:40:23 <jmcarthur> neither sound like what you want
16:43:24 <mpickering> what are you even trying to do exactly?
16:52:38 <montanonic> Can someone please help me with Stack? I'd like to be able to use https://github.com/wuzzeb/yesod-purescript, which is a Fork of the yesod-purescript package on Hackage, but updated to allow for the latest version of Purescript.
16:53:07 <montanonic> So my question is: How do I use Stack to build packages hosted from Github, but not on Hackage or Stackage?
16:53:13 <montanonic> Is this even possible? Thank you.
16:54:27 <mpickering> I think it is possible
16:54:37 <mpickering> https://github.com/alanz/HaRe/blob/wip/stack-travis.yaml
16:54:49 <mpickering> Maybe try based off this example?
16:55:15 <montanonic> Hmm, okay, I'll see if I can make it work. Thank you for the link!
17:32:47 * hackagebot cron 0.3.1 - Cron datatypes and Attoparsec parser  https://hackage.haskell.org/package/cron-0.3.1 (MichaelXavier)
17:47:49 * hackagebot lookup-tables 0.1.0.0 - Statically generate lookup tables using Template  Haskell.  https://hackage.haskell.org/package/lookup-tables-0.1.0.0 (JakeMcArthur)
17:48:00 <jmcarthur> shachaf: fyi: ultimately, i made that ^^
17:51:01 <MarcelineVQ> omy
17:52:30 <jmcarthur> incidentally, this is also the first time i have ever used accursedUnutterablePerformIO
17:52:42 <jmcarthur> everybody attack me at once
17:54:05 <MarcelineVQ> That sounds like a kind of cool arcane incantation, a dark ritual if you would.
17:54:13 <mniip> jmcarthur, your code is going to segfault
17:54:24 <jmcarthur> go on
17:54:28 <MarcelineVQ> from the outer ring such code sleeps and dreams the dream that is this mad universe
17:54:30 <mniip> I don't yet know how
17:54:39 <mniip> but eventually
17:54:45 <mniip> it just will
17:55:20 <jmcarthur> i don't think it is any more likely to segfaul because i used unsafeInlineIO than if i had use unsafePerformIO. it's just read-only stuff.
17:55:25 <jmcarthur> *segfault
17:56:01 <jmcarthur> it's reading a static piece of memory that the program never writes to, in fact.
17:56:13 <mniip> have you checked for polymorphism
17:56:49 <jmcarthur> the type has to be known at compile time for the TH to work. it generates a lookup table then.
18:06:17 <jmcarthur> bah, i don't have a public repo for it yet
18:06:20 <jmcarthur> i'll do it later
18:07:51 * hackagebot zalgo 0.1.0.3 - Z-algorithm implemented on haskell's built-in cons-cell-based lists.  https://hackage.haskell.org/package/zalgo-0.1.0.3 (mniip)
18:21:22 <slack1256> on haskell without retorting to FFI, how close can I get to the ram model in a setup?
18:22:14 <slack1256> i am guessing the ST type buys me references but no O(1) memory accesses that some algorithms presupone to get their asymtotics.
18:22:22 <slack1256> (purely theorical question though)
18:22:42 <jmcarthur> slack1256: ST gives you O(1) random access
18:22:53 * hackagebot quiver 0.0.0.12 - Quiver finite stream processing library  https://hackage.haskell.org/package/quiver-0.0.0.12 (patrykz)
18:22:57 <jmcarthur> slack1256: it's real mutation
18:26:17 <lethjakman> mpickering: sorry, I've been trying to figure a bit out on my own. but I can't seem to figure it out, what function will take Maybe a -> IO a ?
18:26:29 <lethjakman> it'd be a hoist right?
18:27:09 <slack1256> @hoogle Maybe a -> IO a
18:27:10 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
18:27:10 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
18:27:10 <lambdabot> Control.Exception evaluate :: a -> IO a
18:27:42 <pacak> unsafeCoerce!
18:27:48 <bergey> lethjakman: How do you expect that to behave when given a Nothing?
18:28:52 <lethjakman> huh, I tried fromJust and got another error previously
18:29:04 <lethjakman> bergey: return nothing?
18:29:13 <lethjakman> uhh, statement question. 
18:29:22 <lethjakman> I'm expecting it to return nothing but I'm not sure I'm correct.
18:29:22 <pacak> lethjakman: It would be IO (Maybe  a) then...
18:29:47 <slack1256> jmcarthur: I am new on the algorithmic side of CS. So does that mean that ST gives posibility of having the same asymtotics of the RAM machine? (albeit with a clunkier syntax)?
18:29:47 <pacak> unless by "nothing" you understand undefined or other bottoms.
18:30:24 <kadoban> lethjakman: I think you're not really understanding what IO is maybe?   IO a  is … something that when run could yield an 'a'.  Maybe a  is … you either have an 'a' or Nothing. So how would the IO a yield an 'a' when you don't give it one, when you have a Nohing instead?
18:31:00 <lethjakman> https://gist.github.com/lethjakman/6b425cc2999d07913459
18:31:19 <lethjakman> pacak: yeah I'd prefer to keep away from those, I mean Nothing. 
18:31:30 <lethjakman> kadoban: I think you're correct
18:32:08 <lethjakman> kadoban: so is my issue that it hasn't been run?
18:32:24 <lethjakman> I get Maybe, I thought IO was similar to it though. 
18:32:38 <kadoban> lethjakman: From what I understand, the type itself just doesn't make sense. If you're trying to do   Maybe a -> IO a, something is missing.
18:32:50 <pacak> lethjakman: put return before fromJust
18:33:03 <pacak> And it will throw an error if config fails to parse.
18:33:20 <c_wraith> I'm with kadoban.  That type really makes no sense.
18:33:35 <kadoban> 'fromJust' is pretty funky stuff, not really recommended.
18:33:48 <Cale> lethjakman: A value of type IO a is a description of something which could be done (possibly involving arbitrary I/O, and pretty much anything your computer is capable of) in order to produce a result of type a (supposing that it terminates normally)
18:33:51 <lethjakman> pacak: that kinda changes the compilation error?
18:34:09 <Cale> It's possible to write a function of type  Maybe a -> IO a  which throws an IO exception if the Maybe happened to be Nothing.
18:34:11 <mirpa> ($//) :: a -> (a -> [b]) -> [b] ; tail (a $\\ f) -- works fine but; (a $\\ (tail . f)) -- throws empty list exception, I don't understand why
18:34:20 <Cale> But perhaps that's not what you want.
18:34:21 <lethjakman> ok so maybe there's a better question I should be asking here...I have a yaml file that I need to parse into my type, is this the right way to do it?
18:34:22 <rlewis> lethjakman what behavior do you want if you have Nothing?
18:34:39 <lethjakman> rlewis: I'd like to log it
18:34:50 <Cale> So, er, what do you want to *do* with the result of parsing
18:34:52 <Cale> ?
18:35:04 <Cale> fromJust ymlConfig is not an IO action
18:35:09 <Cale> Did you want to print something?
18:35:16 <lethjakman> Cale: return a SesKeys that looks like this: SesKeys {accessKey :: String, secretKey :: String}
18:35:19 <Cale> Or... how should the program actually continue?
18:35:36 <pacak> > fromJust Nothing
18:35:38 <lambdabot>  *Exception: Maybe.fromJust: Nothing
18:35:45 <lethjakman> ew
18:35:45 <pacak> It kind of prints something...
18:35:49 <Cale> Okay, so maybe you wanted to apply the return function to fromJust ymlConfig ?
18:35:49 <Gurkenglas> https://hackage.haskell.org/package/safe-0.3.9/docs/Safe.html#v:fromJustNote is like fromJust, but the error message when it crashes your program is custom
18:35:51 <lethjakman> does that crash it?
18:36:41 <lethjakman> Gurkenglas: nice!
18:36:45 <Cale> If you wrote getsesAccessKey = do ymlConfig <- ...; return (fromJust ymlConfig)  then you're program is just going to die on a parse error
18:36:58 <pacak> There's safeFromJust in acme-safe, perhaps you want to use it instead...
18:37:10 <rlewis> lethjakman you want to log it, and then return what? some default value? do you want to throw an exception? quit the program?
18:37:15 <Cale> You could also just use case to pattern match and print a message or something when the parse fails.
18:37:25 <lethjakman> rlewis: logging and quitting would probably make sense in this case
18:37:30 <lethjakman> since I'm expecting that file to be present. 
18:37:45 <Cale> So something like:
18:37:50 <Cale> case ymlConfig of
18:37:54 <lethjakman> Cale: that returns a bytestring instaed
18:38:27 <Cale>   Nothing -> do putStrLn "Error parsing secrets.yaml"; exitWith (ExitFailure 1)
18:38:42 <Cale>   Just s -> return s
18:39:17 <orb_> maybe (putStrLn "Error parsing secrets.yaml" >> exitWith (ExitFailure 1)) return
18:39:37 <Cale> orb_: heh, you can do that if you want the code to be annoying to maintain
18:40:13 <lethjakman> so, this makes sense to me, but it doesn't seem to work: https://gist.github.com/lethjakman/9720a3f19aa3960b3e41
18:40:36 <lethjakman> the fromJust should unwrap the IO right? and then the return should wrap it in a maybe?
18:40:40 <lethjakman> but it returns a bytestring?
18:40:47 <lethjakman> gah, sorry I'm not trying to be difficult here. 
18:40:48 <rlewis> :t fromJust
18:40:50 <Cale> lethjakman: Is that the whole file?
18:40:50 <lambdabot> Maybe a -> a
18:41:04 <lethjakman> Cale: no, it's a big long yesod file, would you like more or all?
18:41:07 <Cale> lethjakman: all
18:41:09 <pacak> lethjakman: ymlConfig in  this version is a ByteString
18:41:13 <pacak> You need to parse t
18:41:14 <pacak> it
18:41:47 <Cale> lethjakman: In particular, I'd be quite interested if you gave an explicit type signature to getsesAccessKey
18:42:02 <orb_> Should probably be something like
18:42:07 <lethjakman> pacak: what do you mean parse it?
18:42:24 <orb_> :: IO (Either ErrorMessage WhateverTypeYouActuallyWant)
18:42:26 <Cale> Oh, right, readFile isn't going to produce Maybe anything
18:42:28 <lethjakman> Cale: just a moment. I need to pull some data out of here. it's an attempt for me to learn and it's being difficult. 
18:43:01 <Cale> You were applying decode before, it seems?
18:43:20 <Cale> Perhaps you wanted  return (fromJust (decode ymlConfig))
18:43:33 <rlewis> "Couldn't match expected type ‘Maybe b’ with actual type ‘ByteString’" means that fromJust expects "Maybe b" but you gave it a ByteString. types don't match
18:43:39 <Cale> (but really, it's much better to use case to pattern match on the result of decode, and do something sensible)
18:43:40 <orb_> readFile throws an error when it can't find / open the file, I assume.
18:43:45 <Cale> yes
18:44:18 <Cale> > fromJust Nothing
18:44:20 <lambdabot>  *Exception: Maybe.fromJust: Nothing
18:44:29 <orb_> fromJust: just say no.
18:44:31 <Cale> ^^ seeing that error message from a large program really really sucks
18:44:52 <Cale> Because you have to go through the whole program and look for occurrences of fromJust and figure out which one it came from
18:44:52 <orb_> fromMaybe "Sensible Error Message here"
18:44:56 <orb_> Is somewhat better.
18:45:13 <Cale> Well, just use case and print a proper message, and exit the program.
18:45:22 <orb_> Yes.
18:45:38 <Gurkenglas> Why doesn't GHC substitute all calls of fromJust with fromJustNote with source location information?
18:45:43 <orb_> As a rule of thumb: if there's a sensible thing to do with Nothing, do it.  If not, bubble it up.
18:45:50 <Cale> Gurkenglas: That's not referentially transparent
18:45:58 <orb_> And at the top level, print an error message, and exit.
18:46:10 <Cale> Gurkenglas: Well, to be fair, neither is do-notation
18:46:16 <orb_> (Either ErrorMessage Type) is better for that than (Maybe Type),
18:46:30 <orb_> it carries more information about what went wrong.
18:46:42 <lethjakman> Cale: https://gist.github.com/lethjakman/91626c700f6e28e0a6a8
18:46:49 <Cale> If you pattern match in do-notation for IO, you'll get a nice exception with the source location.
18:46:53 <Cale> That's sometimes handy
18:47:25 <orb_> Gurkenglas: good question.  I guess you are just not supposed to use fromJust.
18:47:28 <Cale> Oh, okay, it's a class method
18:47:38 <Cale> But yeah, we already pointed out the problem
18:47:43 <jle`> Gurkenglas: GHC can actually do that
18:47:51 <jle`> with an alternative implementation of fromJust
18:47:53 <Cale> lethjakman: Use something like
18:47:55 <jle`> it's just not merged into Prelude yet
18:47:57 <Pamelloes> Is there a good resource comparing various Haskell web servers?
18:47:59 <Cale> ymlConfig <- ...
18:48:00 <jle`> er, into base yet
18:48:09 <Cale> case decode ymlConfig of
18:48:43 <Cale>   Nothing -> do putStrLn "Error while parsing secrets.yaml"; exitWith (ExitFailure 1)
18:48:53 <Cale>   Just c -> return c
18:49:26 <jle`> Gurkenglas: https://hackage.haskell.org/package/located-base-0.1.0.0
18:49:59 <Gurkenglas> No source? :/
18:50:30 <Cale> Gurkenglas: seems to be there: https://hackage.haskell.org/package/located-base-0.1.0.0/src/
18:50:44 <Gurkenglas> Wait, just no docs. That source link down there shows sources.
18:51:14 <jle`> it uses a new feature of GHC that provides an implicit param for all function calls with call stack info
18:51:41 <jle`> really no reason why it sohuldn't be in base atm i think, it just hasn't been pulled in yet
18:51:48 <jle`> (the special variants of fromJust, I mean)
18:52:05 <Gurkenglas> That sounds like it costs performance, unlike having GHC substitute fromJustNote
18:52:06 <jle`> it even has a better `undefined`
18:52:15 <Cale> What happens if the extension is turned off?
18:52:52 <jle`> ah yeah i guess it would be annoying if Prelude wouldn't compile
18:53:01 <Cale> Oh, I guess you still have to explicitly import the Located versions of things
18:53:39 <Cale> The idea that there's a call stack is weird. What is that?
18:53:48 <jle`> i'm not sure if using the implicit param has performance penalty
18:53:53 <Cale> jle`: It does.
18:53:59 <jle`> aw, darn
18:54:40 <Cale> It means everything is implicitly a function of that thing, and presumably there's a bunch of code being inserted to manipulate the values being passed around.
18:54:54 <Cale> There is no call stack in GHC
18:55:00 <Cale> so whatever it's giving you is a lie
18:55:10 <Cale> I don't know how useful of a lie it is :)
18:55:17 <Cale> but possibly quite useful
18:55:20 <jle`> it's just a value called callStack
18:55:26 <jle`> so maybe it's not a call stack ^^
18:55:34 <Cale> Well, it has type CallStack
18:55:37 <Cale> whatever that is
18:56:29 <Cale> data CallStack = CallStack { getCallStack :: [(String, SrcLoc)] }
18:56:50 <Cale> I wonder what the code it inserts to maintain these lists looks like
18:57:21 <jle`> "CallStacks do not interact with the RTS and do not require compilation with -prof. On the other hand, as they are built up explicitly using implicit-parameters, they will generally not contain as much information as the simulated call-stacks maintained by the RTS."
18:57:47 <Cale> ugh, this stuff
18:59:06 <Cale> How many completely fake "stacks" do we need? :)
18:59:24 <jle`> i'm still not convinced that ImplicitParams is not the devil
18:59:43 <jle`> but the idea of having the compiler provide implicit params at runtime is an interesting application i didn't realize at first
18:59:56 <Cale> It pretty much is the devil, but LinearImplicitParams was worse.
19:00:31 <jle`> what were those?
19:01:01 <Cale> ImplicitParams is to Reader what LinearImplicitParams is to State
19:01:09 <jle`> heh
19:01:17 <EvanR> how about a call cyclic graph
19:01:19 <jle`> how did...that become a thing...
19:01:35 <EvanR> or non trivial call topology
19:02:01 <Cale> EvanR: I don't even know what a call stack means when we're evaluating everything outermost-first anyway.
19:02:03 <jle`> the use of ImplicitParams to simulate first-class typeclasses was interesting too but i think there were some issues that prevented it from being as flexible as actual GHC typeclass monsters
19:02:12 <Cale> EvanR: It doesn't make sense.
19:02:22 <neuroserpens> What's cooking?
19:02:26 <EvanR> ive never understood it
19:02:55 <Cale> I really wish we could just have these things report information about the *actual* stack, with nice prettyprinted case expressions that have bits elided or something.
19:02:58 <EvanR> jle`: or as inflexible, as in type-classes vs the world
19:03:45 <jle`> heh
19:04:25 <EvanR> more flexibility = more programmer brainshare allocated to code reasoning
19:05:05 <Cale> I wonder how hard it is to come up with a program which runs exponentially slower with these CallStack things turned on
19:05:14 <EvanR> "who, including myself, used the flexibility to do what when where"
19:05:18 <Cale> My initial guess would be "not hard at all"
19:05:31 <jle`> sounds like a nice lazy sunday kinda project
19:06:12 <jle`> and a blog post i would read :)
19:06:28 <Cale> But maybe the machinery to maintain them only gets inserted in places where it won't hurt performance much
19:06:45 <Cale> Like, only for function bindings or something
19:06:50 <Cale> (not for pattern bindings)
19:07:22 <Cale> But then that means that eta-reducing your program might result in stuff becoming invisible from the CallStacks
19:10:21 <Cale> The change that was made quite a while back to cost centre stacks (7.6?) was quite weird. It was supposed to make them "more like real call stacks" whatever the heck that means, but it made the .prof files for our game really difficult to use.
19:11:51 <Cale> Maybe it was 7.4.x based on the date of this prof file
19:12:08 <Cale> -rw-r--r-- 1 cale cale 40788019 Mar  7  2012 gameBenchmark.prof
19:12:19 <Cale> -rw-r--r-- 1 cale cale   147185 Oct 30  2011 gameBenchmark-prepatch.prof
19:14:22 <itsu> guys I'm having a lot of trouble understanding about how variadic functions work
19:14:33 <geekosaur> "painfully"
19:14:37 <itsu> http://pastebin.com/2DBpCXD1
19:14:40 <neuroserpens> > words "a b c d e"
19:14:43 <lambdabot>  ["a","b","c","d","e"]
19:15:01 <Cale> itsu: you might want to use lpaste.net
19:15:12 <itsu> alright will try that
19:15:21 <Cale> itsu: But yeah, it's just ordinary type classes.
19:15:36 <Cale> itsu: The type of the result of and' might be a function
19:15:51 <itsu> http://lpaste.net/139924
19:16:07 <Cale> yeah, that's better :)
19:16:48 <Cale> itsu: So,  and'' can have any type r which is an instance of the type class Valid
19:16:49 <itsu> I don't really get this part actually instance (Eq a, Valid r) => Valid (a -> r) where
19:16:49 <itsu>  
19:17:07 <itsu> (btw this sample doesnt compile)
19:17:30 <itsu> Cale: yeah, I think I got that
19:17:38 <geekosaur> an instance of Valid can be a function from some type a to an instance of Valid
19:17:51 <Cale> Probably it was meant to be  instance (Valid r) => Valid (Bool -> r)
19:18:18 <geekosaur> and yeh, that doesn't seem quite right, although it has the right idea
19:19:10 <itsu> Cale: but if you do that, how the compiler can make the difference wether to use the instance L4 and the instance of L7
19:19:27 <Cale> itsu: Based on the type of result which is demanded.
19:19:48 <EvanR> i appreciate this page https://wiki.haskell.org/Debugging
19:19:55 <Cale> itsu: Probably just applying "print" won't work, because you'll get an error about how the type is ambiguous
19:20:12 <EvanR> i would appreciate if it were more than a little wiki blurb, especially infinite loops
19:20:17 <geekosaur> because True is of type Bool; but in (True False) it is of type (Bool -> a) because it has a "parameter"
19:20:22 <Cale> itsu: However, if the result was specified to be Bool, then the instance selection would find a solution
19:20:56 <itsu> so print $ and'' True False :: Bool would help ?
19:21:59 <lpaste_> Cale annotated “No title” with “fixed” at http://lpaste.net/139924#a139925
19:22:11 <Cale> ^^ see there, I made some changes so it'll work
19:22:40 <Cale> itsu: You need more parens, but yeah
19:22:45 <itsu> alright I'll check that, thanks
19:23:01 <Cale> (the :: syntax scopes over the whole expression, including the other side of the $)
19:23:39 <itsu> I think I got it yeah
19:23:44 <Cale> itsu: This is usually not a very useful way to accomplish anything
19:24:14 <Cale> itsu: It's a cute trick, but I would be very hesitant to put it in real code.
19:24:48 <geekosaur> yes
19:24:57 <itsu> Cale: main = print (and'' True False :: Bool) How come the compiler cannot infer without the ":: Bool" at the end ?
19:24:58 <geekosaur> for one thing, you've stolen partial application
19:25:15 <Cale> itsu: Because  and'' True False :: Bool -> Bool  is also possible
19:25:24 <Cale> itsu: and  Bool -> Bool -> Bool
19:25:29 <Cale> and so on
19:26:18 <Cale> There's no way for it to know which of these infinitely many possibilities you want until you tell it the type of the result, from which it can infer which type  and''  must have in that expression, and then it can go look up which instance applies
19:26:21 <EvanR> instead of variadic function use a function that takes a list, a list of what? a list of things that have some common interface for the task at hand, and have different ctors for each different implementation of the thing
19:27:03 <EvanR> a typeclass can then be abused to make typing the ctor easier, by having it be implicit
19:27:06 <itsu> Cale: oh ok, I see
19:27:15 <monochrom> @quote monochrom river
19:27:15 <lambdabot> monochrom says: You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How
19:27:15 <lambdabot> many trips do you need? Solution: one trip, [show the_boolean, show the_character, show the_integer]
19:27:35 <itsu> EvanR: I cannot use a list in my case cause the elements are not of the same type
19:27:45 <EvanR> see above
19:27:54 <Cale> itsu: What are you going to do with the elements?
19:28:00 <EvanR> if you need them to all be stringable, send the strings instead
19:28:12 <EvanR> same applies to whatever you will do with them
19:28:40 <itsu> I'm basically trying to have a validation lib. So I have a 
19:28:43 <itsu> data Deal a =
19:28:43 <itsu>   Deal {
19:28:43 <itsu>     value :: a,
19:28:46 <itsu>     condition :: Condition a
19:28:50 <itsu>   }
19:29:06 <itsu> sorry I forgot:
19:29:08 <itsu> well here obviously they a
19:29:12 <itsu> type Condition a = a -> Bool
19:29:26 <itsu> so I have a list of Deal a
19:29:43 <EvanR> so taken literally the above advice is to apply the validation separately and youll have a list of bools
19:29:54 <EvanR> but a better pattern for this in haskell is to apply your validations in applicative style
19:29:58 <itsu> and I want a way to validate each of them without having to do something like validate deal1 $ validate deal2
19:30:03 <EvanR> instead of "list style"
19:30:46 <EvanR> theres really no better way, in fact using that style you will get more flexibility in choosing how to validate
19:31:03 <Cale> itsu: Okay, wait, do you ever do anything with a value of type  Deal a  which is not simply applying the condition to the value?
19:31:41 <itsu> right now no, but eventually I'll do something else probably
19:31:52 <Cale> itsu: If not, then why construct values of type Deal in the first place? Replace occurrences of the constructor  Deal  with the function  deal x f = f x
19:32:10 <Cale> and then instead of Deal a, you have Bool, and everything is the same type :)
19:32:33 <EvanR> and the if any are False you have a validation error but no context, which is where applicative comes in
19:32:35 <itsu> Cale: I don't think I'm following you
19:33:08 <Cale> itsu: Okay...
19:33:19 <onur_> Hello!
19:33:28 <itsu> Eventually I want to gather all value of all Deal that are invalid
19:33:29 <Cale> itsu: We can also keep our Deal type, but make it non-parametric
19:33:37 <Cale> itsu: and then what?
19:33:50 <Cale> Maybe these Deals need names?
19:34:00 <onur_> can i ask a really really noob question?
19:34:11 <Cale> onur_: Beginner questions are always welcome here :)
19:34:21 <arkeet> as long as it's related to haskell :-)
19:34:26 <Cale> yes, of course :)
19:34:33 <itsu> I can have many, many deals. Deal on a string, int, date,...
19:35:00 <itsu> So I'm not sure creating a type for each is going to be easy
19:35:06 <onur_> can i use openhardwaremonitorlib.dll in the haskell? 
19:35:09 <Cale> itsu: Yeah, I'm going to collect up the things which you do with these Deal values, and put *those* in a record instead, and remove the type argument :)
19:35:19 <onur_> is it possible or not 
19:35:51 <onur_> if okay for you i can link it here
19:36:09 <arkeet> onur_: if it has a C library you can probably make bindings for it
19:36:16 <Cale> onur_: Do you have a corresponding C library? You could write an FFI binding and link to it.
19:37:01 <Cale> It is possible to make calls to DLLs using the bindings to the Windows API, but I don't recall exactly what needs to be done, I'm not really a Windows user.
19:37:02 <itsu> Cale: you would have 2 data type then ? not sure I get you
19:37:07 <arkeet> google suggests it's a .net thing, though
19:37:08 <arkeet> written in C#
19:38:13 <arkeet> no idea what there is for haskell/.net interop
19:38:40 <Cale> itsu: I mean, you could have something like   data Deal = Deal { dealPassed :: Bool; dealName :: String; dealMessage :: String }, and then have a function like  mkDeal :: (Show a) => String -> a -> (a -> Bool) -> Deal
19:38:41 <arkeet> hm, there's something called hs-dotnet but it hasn't been updated since 2009
19:38:59 <onur_> I want to read CPU/GPU usage, temperature and other stats like that. 
19:39:18 <Cale> itsu: Note that those fields in Deal can themselves be functions if you need to do something more sophisticated
19:39:33 <onur_> I searched a bit and I think may be I can use the dll in haskell but I don't know really :(
19:39:52 <Cale> itsu: But the idea is that while building these things, you're going to compute all the things which you would have computed using your value of type Deal a, and put those in the structure instead.
19:40:00 <itsu> Cale: yeah, if I don't want to use the 'value' then your solution works. In my case I'd like to be able to use it afterward
19:40:05 <arkeet> onur_: if you can find a C library that does it then it should be doable.
19:40:12 <Cale> itsu: The problem is, how do you use it?
19:40:30 <Cale> itsu: If you have a value of an unknown type, there's really nothing you can do with it apart from passing it around
19:41:10 <onur_> arkeet: I'm searching for it now :) Thanks all, I'll be here more often! :)
19:41:17 <EvanR> the easiest way to use a list of hetero things is to figure out what the common interface is you want to use them for
19:41:24 <Cale> itsu: What things do the elements of your list need to have in common?
19:42:28 <itsu> Cale: good point yeah. I wanted to use it to fetch a related message error. so say the value is "James" i could print "James is valid" for example. But I guess I just need "value" to be a String then
19:42:46 <ttt_fff> :t (!)
19:42:48 <lambdabot> Ix i => Array i e -> i -> e
19:42:53 <Cale> itsu: Right, that's why I included a dealName field in my example :)
19:42:59 <ttt_fff> whyis this just arrah, and not array + map
19:43:11 <ttt_fff> i.e. ! also == Data.Map.lookup, via typeclass matic
19:43:13 <itsu> Cale: oh I see, sorry I didnt catch that
19:43:37 <Cale> itsu: and maybe you have some sort of additional message about why the thing succeeded or failed, and you might want that as a separate string, so that's what dealMessage was intended to be :)
19:44:06 <itsu> Cale: clever, I see
19:44:27 <itsu> Yeah, it helps a lot. Then I can manipulate a list instead
19:44:38 <itsu> Which is going to be way easier I guess
19:44:49 <itsu> a list of deals I mean
19:45:59 <shachaf> jmcarthur: OK, I suppose that's another solution.
19:47:10 <shachaf> jmcarthur: What do you do if you want some code, rather than a static value, for each byte?
19:49:42 <montanonic> Stack question: What is the difference between adding `import package_name` under the build-depends section in a project's .cabal file, versus doing `stack install package_name` within that project's directory?
19:50:20 <montanonic> actually
19:50:26 <montanonic> I'll just post that on StackOverflow
19:50:27 <LeftDissociative> Is anyone else having trouble emailing haskell-cafe? I got a mail bounce error.
19:53:02 * hackagebot moesocks 0.1.1.30 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.1.30 (JinjingWang)
20:01:18 <gamegoblin> Can anyone explain this error? Made a minimal test case I think http://lpaste.net/6648469345389248512
20:02:31 <arkeet> createRef has type a -> m (Ref m a), where the type variables are chosen by the caller.
20:02:33 <arkeet> yet you are applying it to ()
20:02:35 <cwraith> gamegoblin: well, you're saying that the caller can specify any type for a
20:02:41 <cwraith> gamegoblin: but then you insist that it's ()
20:02:48 <gamegoblin> cwraith: aaah gotcha
20:02:55 <gamegoblin> arkeet: thanks
20:03:27 <c_wraith> gamegoblin: you might want the function to have a rank-2 type
20:03:30 <Eduard_Munteanu> gamegoblin, you need the 'a' quantified inside the parens
20:03:43 <gamegoblin> c_wraith: what do you mean exactly?
20:03:52 <Eduard_Munteanu> Because the caller can then instantiate 'a' to ().
20:04:33 <Eduard_Munteanu> (forall a. a -> m (Ref m a)) -> m (m ())
20:04:38 <gamegoblin> c_wraith: what I want to say is "createRef should be a function that takes any type a, what I use it for internally is none of the persons business"
20:04:39 <c_wraith> gamegoblin: if you change the type to Monad m => (forall a. a -> m (Ref m a)) -> m (m ())
20:04:46 <gamegoblin> That sounds right, thanks
20:04:56 <gamegoblin> I want to be able to pass in "newIORef" for example
20:05:03 <c_wraith> gamegoblin: that requires an extension enabled.  Might as well go with RankNTypes
20:05:10 <gamegoblin> Cool, thanks
20:05:12 <neuroserpens> well wth why am i banned from haskell-beginners?
20:05:28 <neuroserpens> I don't even remember being there before
20:05:53 <shachaf> Not affiliated with this channel. Ask someone who runs it.
20:05:58 <Axman6> neuroserpens: is your nick registered?
20:06:04 <neuroserpens> Axman6: Yes.
20:06:08 <neuroserpens> shachaf: Haha.
20:06:09 <Axman6> odd
20:06:37 <shachaf> I'm serious. You can get a list of people to ask from ChanServ.
20:07:58 <Axman6> yeah, bitemyapp is the only op I think
20:08:04 * hackagebot moesocks 0.1.1.31 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.1.31 (JinjingWang)
20:08:28 <jle`> is there a package with singletons assocated with types of GHC's Nat kind?
20:10:08 <c_wraith> jle`: isn't that base?  GHC.TypeLits has singletons
20:12:19 <Eduard_Munteanu> I thought that was being deprecated.
20:12:37 <Eduard_Munteanu> @hackage singletons
20:12:37 <lambdabot> http://hackage.haskell.org/package/singletons
20:12:42 <c_wraith> eh, they're not explicitly the Sing type like there used to be
20:14:01 <Eduard_Munteanu> Ah.
20:16:13 <jle`> thank you all
20:16:32 <ttt_fff> you're welcome
20:19:00 <Welkin> how does `cabal run` work?
20:19:29 <ttt_fff> it reads your blah.cabal file
20:19:31 <ttt_fff> compiles the *.hs files
20:19:34 <ttt_fff> and runs the binary
20:19:38 <Welkin> it looks like it adds overhead compared to `cabal build main` followed by ./dist/build/main
20:20:01 <Welkin> memory usage goes up
20:20:03 <Welkin> as does time
20:23:26 <jle`> hm.  say `Vec n a` is a vec type where n is its length.  What's the best way I can have a function blah -> (exists n. Vec n a -> b) where the user can "know" what length vec they're supposed to provide?  the naive way would be just blah -> (exists n. Int, Vec n -> b), and the user can see the type expected at compile-time
20:23:32 <jle`> but i was wondering if there was a more type-safe way
20:23:38 <jle`> *type expected at runtime
20:24:01 <jle`> hm, i guess I could just do blah -> (exists n. Vec n (), Vec n a -> b)
20:24:21 <mniip> let's try this again
20:24:23 <jle`> which basically means "feed the function with some modification of the vector of ()'s i feed you, which is of the same length
20:24:35 <mniip> guys, I made a thing, anyone wanna read about it
20:25:15 <ttt_fff> why are orphan instances ba?
20:25:24 <ttt_fff> I use them all the time, yet the internets says Orphan Instances. BAD BAD BAD
20:27:56 <Hijiri> if you import two modules with two conflicting orphan instances it can break things
20:28:10 <Hijiri> also the behavior of things can change depending on which orphan you import
20:28:23 <Hijiri> if you're making orphan instances in something you're not exposing as a library, it probably doesn't matter much
20:28:41 <Hijiri> but if you are writing a library, you probably want to avoid them if you can
20:28:53 <Axman6> mniip: things are my favourite things!
20:29:52 <mniip> Axman6, things that happen or things that exist?
20:30:00 <Axman6> yes
20:30:11 <Axman6> precisely those things
20:30:31 <mniip> you'd be pretty happy because the thing I made is simultaneously both
20:30:40 <Axman6> yussss
20:30:59 <mniip> http://mniip.com/pages/ZAlgorithmOnConsCells
20:32:36 <Eduard_Munteanu> jle`, blah -> (exists n. Sing n -> Vec n a -> b) -> ... ?
20:34:35 <Axman6> mniip: I'll take a look shortly!
20:35:59 <Eduard_Munteanu> jle`, actually, you only need a SingI constraint, and you can get the singleton with sing
20:36:18 <Eduard_Munteanu> so   exists n. (SingI n) => Vec n a -> b
20:36:55 <Eduard_Munteanu> sing :: Sing n
20:37:44 <Eduard_Munteanu> That sounds like a maximum security type. :P
20:37:51 <jle`> how would someone use such a function?
20:38:05 * hackagebot streaming 0.1.0.13 - a free monad transformer optimized for streaming applications, with a simple prelude  https://hackage.haskell.org/package/streaming-0.1.0.13 (MichaelThompson)
20:38:17 <Eduard_Munteanu> jle`, pattern-match the singleton
20:38:20 <jle`> i'm not too familiar with the machinery of Proxy
20:38:33 <jle`> hm, but how is that different than just (Int, Vec n a -> b) ?
20:38:45 <jle`> *machinery of Data.SIngleton
20:39:30 <Eduard_Munteanu> jle`, the type system can see the length and 'n' are the same
20:40:15 <Eduard_Munteanu> jle`, how else do you enforce the Int to be equal to n
20:40:55 <jle`> ah
20:41:02 <jle`> so it's meant to be safety for the writer of the function
20:41:03 <jle`> not the suer
20:41:06 <jle`> *user
20:41:11 <jle`> i guess writers need love too
20:41:27 <jle`> (and i guess the user can more safely trust that the writer implemented it correctly)
20:43:07 * hackagebot streaming-bytestring 0.1.0.4 - effectful byte steams, or: lazy bytestring done right  https://hackage.haskell.org/package/streaming-bytestring-0.1.0.4 (MichaelThompson)
20:48:08 * hackagebot streaming 0.1.0.14 - a free monad transformer optimized for streaming applications  https://hackage.haskell.org/package/streaming-0.1.0.14 (MichaelThompson)
20:53:08 * hackagebot streaming 0.1.0.15 - a free monad transformer optimized for streaming applications  https://hackage.haskell.org/package/streaming-0.1.0.15 (MichaelThompson)
21:13:03 <gamegoblin> Oh man I just learned about LambdaCase, why did I not know about this sooner...
21:18:11 * hackagebot quiver-cell 1.0.0 - Quiver combinators for cellular data processing  https://hackage.haskell.org/package/quiver-cell-1.0.0 (patrykz)
21:21:40 <jmcarthur> shachaf: you mean like a closure? guess i'd have to defunctionalize it. in any case, all i really wanted this time was a simple lookup-table.
21:27:33 <Welkin> gamegoblin: I still don't see myself using it. May as well define a named (internal) function using let or where
21:28:01 <gamegoblin> Welkin: I’ve wanted it for use where I would otherwise use do-notation for so long
21:28:18 <gamegoblin> Welkin: do { x <- foo; case x of { … } }
21:28:23 <gamegoblin> can now be foo >>= \case
21:29:49 <Welkin> I see
21:37:44 <cads> hey guys, anyone know if there's a library to do generic 2 geometry packing (geometry nesting) in haskell?
21:38:25 <cads> I have done a preliminary few searches on hackage and found a library with some heuristics for packing circles of varying radii 
21:43:13 * hackagebot lookup-tables 0.1.1.0 - Statically generate lookup tables using Template  Haskell.  https://hackage.haskell.org/package/lookup-tables-0.1.1.0 (JakeMcArthur)
21:43:15 * hackagebot woot 0.0.0.0 - Real time group editor without operational transform.  https://hackage.haskell.org/package/woot-0.0.0.0 (tgolson)
21:58:14 * hackagebot language-lua2 0.1.0.0 - Lua parser and pretty printer  https://hackage.haskell.org/package/language-lua2-0.1.0.0 (mitchellwrosen)
21:58:19 <Welkin> jmcarthur: what is the use case for a static lookup table?
21:58:41 <Welkin> computations are often cheaper than storing a table
21:58:54 <Welkin> especially with SIMD
22:01:46 <pacak> Welkin: Functions can be expensive.
22:03:56 <Welkin> I am thinking of arithmetic/transcendental functions
22:19:30 <misha> Guys I am trying to install snappy bindings on windows and I am getting the following Error, anyone who is fammilar can you give me some pointers how to  get it to work on Windows?
22:19:37 <misha> * Missing C library: snappy
22:19:37 <misha> This problem can usually be solved by installing the system package that
22:19:37 <misha> provides this library (you may need the "-dev" version). If the library is
22:19:37 <misha> already installed but in a non-standard location then you can use the flags
22:19:37 <misha> --extra-include-dirs= and --extra-lib-dirs= to specify where it is.
22:19:37 <misha> cabal: Error: some packages failed to install:
22:19:37 <misha> snappy-0.2.0.2 failed during the configure step. The exception was:
22:19:38 <misha> ExitFailure 1
22:19:39 <misha> * Missing C library: snappy
22:19:39 <misha> This problem can usually be solved by installing the system package that
22:19:39 <misha> provides this library (you may need the "-dev" version). If the library is
22:22:40 <liste> misha have you installed the snappy library?
22:26:28 <pacak> liste: He left us...
22:31:34 <kristof> What's an example of parsing the bach grammar in Parsec?
22:33:00 <glguy> '
22:33:03 <kristof> I ask because I was trying to investigate context dependent grammars
22:33:10 <kristof> *sensitive
22:33:58 <kristof> And I was sort of wondering if you could do it with an Applicative, which you shouldn't be able to, but I can imagine a solution that in fact only uses liftA3 and some counting parsers.
22:36:08 <kristof> So for (a | b | c)*, where the number of as, bs, and cs is equal, I can imagine just parsing many of choice[aParser, bParser, cParser], where the parameterization of those parsers is Int (just counts it). Then the whole thing gives you back a triple (Int, Int, Int) and you just check if all three are eq.
22:37:41 <kristof> No, actually, that doesn't work. But it does work for a^n b^n c^n! I think that's what I was thinking of.
22:37:55 <Stratege_> kristof why shouldn't you be able to use applicative + arbitrary computations to be able to do context sensitive grammars?
22:38:24 <kristof> Stratege: I guess the arbitrary computations part is what makes that possible.
22:38:34 <Stratege> exactly ^^
22:38:56 <kristof> Well, I haven't taken so many shortcuts.
22:39:00 <ReinH> There's a somewhat well-known trick for that https://byorgey.wordpress.com/2012/01/05/parsing-context-sensitive-languages-with-applicative/
22:39:05 <glguy> kristof: if you want to parse (a^n b^n c^n) with parsec limited the the applicative instance you can
22:39:10 <glguy> because you can make an infinite parser
22:39:21 <ReinH> yep
22:39:50 <kristof> Well I don't mean something quite as abusive.
22:40:05 <ReinH> well, that's the trick
22:40:07 <glguy> p n = (a^n b^n c^n) <|> p (n+1) -- psuedocode
22:40:32 <ReinH> if it's less "abusive" it doesn't work
22:41:53 <kristof> Would a parser (count "a") :: Parser Int (assuming such a count function existed) be considered "arbitrary" computation?
22:41:57 <kristof> Stratege: ^
22:45:44 <Stratege> kristof I'm not really an expert on these things, just a comp sci student who's still learning about languages. I just wanted to point out that if you do things in Haskell you are dealing with a turing complete language so as long as you don't limit yourself to a subset that isn't turing complete you have turing completeness and therefor can "emulate" all the other languages on the chomsky scale as well. (I really hope I didn't get things wrong i
22:46:54 <shachaf> This isn't about what you can parse in Haskell, it's about the sort of parsers you can express with an API.
22:47:45 <shachaf> The point is that in Haskell the API is more flexible than it seems (and maybe more than it should be) because you can define an infinite value.
22:47:59 <Stratege> he originally mentioned getting a tripple of ints back and then checking equality on them, thus my comment.
22:48:00 <shachaf> Also, IRC messages have a length limit, and yours exceeded it.
22:48:17 <Stratege> oh, right. I tend to forget about that limit.
22:49:44 <kadoban> A decent client will handle it for you (by splitting the message)
22:50:00 <kristof> Yeah, what kind of client doesn't do that?
22:50:03 <kristof> ERC?
22:50:08 <ggVGc> irssi doesn't for me
22:50:13 <Stratege> trillian IRC plugin from like 8 years ago.
22:50:16 <ggVGc> some perl script probably exists to do it
22:50:44 <Stratege> By this point it's so entrenched for me with configs and settings that I just can't be arsed to change clients without something major breaking.
22:50:57 <kristof> Stratege: getting a triple of ints and folding it into equal or not is really just a function (Int,Int,Int) -> Bool that I can lift with an fmap into the parser functor
22:51:01 <kristof> so I still haven't cheated yet!
22:51:04 <kadoban> Something major like your messages being cut off …
22:53:18 * hackagebot nationstates 0.2.0.2 - NationStates API client  https://hackage.haskell.org/package/nationstates-0.2.0.2 (ChrisWong)
22:53:20 * hackagebot nationstates 0.3.0.0 - NationStates API client  https://hackage.haskell.org/package/nationstates-0.3.0.0 (ChrisWong)
23:07:19 <Meesha> Can anyone help me to resolve this error on windows? http://pastebin.com/5bV0G5HC
23:10:04 <liste> 05:22 < liste> misha have you installed the snappy library?
23:11:16 <MorpheusB> ggVGc: I have recently swapped from irssi to weechat - finding much better
23:11:26 <Meesha> liste, that the thing, i dont know how to do it on windows
23:11:42 <pacak> Meesha: Start by installing linux...
23:11:48 <Meesha> lol
23:11:57 <Meesha> ya, i know, cant do it at the moment
23:12:06 <Meesha> i wonder if it can easily be done in windows
23:13:37 <greves> i gave up on haskell in windows, i just use vagrant now
23:13:50 <glguy_> You'll have to ask the developers of the snappy library
23:17:10 <ramadoka> join #python
23:17:30 <EvanR> /join #python
23:17:32 <EvanR> oops
23:17:34 <ramadoka> sory, typo
23:19:06 <ggVGc> MorpheusB: why?
23:22:18 <MorpheusB> find it better, easier to understand windowing and swapping between buffers, written in c, many more scripts and plugins
23:22:25 <MorpheusB> in multiple languages
23:22:51 <MorpheusB> more like hexchat but with gui overhead
23:23:01 <MorpheusB> without gui overhead
23:23:17 <MorpheusB> bugger these dyslexic fingers
23:25:38 <etnobot> hey everyone not trolling, but did haskell not become very popular because it is hard to learn?
23:26:10 <etnobot> i really like functional programming but i find haskell kind of intimidating
23:26:35 <EvanR> i admit i was intrigued by the notion floating around outside haskell that "writing new monads from scratch is hard"
23:28:12 <MorpheusB> not hard to learn, just a completely different way of thinking about programs. As I never did calculus, found it helpful to study book on lambda calculus
23:28:16 <jle`> etnobot: i think it's not hard to learn, but just different
23:28:36 <jle`> so people who already know a language well and spent a lot of time on it have a hard time starting from scratch
23:28:40 <MorpheusB> thinking is the problem, fossilised brains like mine hard to retrain
23:28:42 <etnobot> how is haskell compared to erlang?
23:28:44 <jle`> there's also a lot of bad pedagogy too
23:28:53 <MorpheusB> Many unis teaching as first language
23:29:03 <jle`> and some people get a bad impression from misconceptions
23:29:13 <jle`> i think haskell is more general purpose than erlang, from what i hear
23:29:16 <jle`> i've never used erlang though
23:29:31 <shachaf> It seems to me that if you feel like saying "hey everyone not trolling" before asking your question, you might reconsider the question.
23:29:37 <MorpheusB> Programming in Haskell by Graham Hutton is good resource
23:31:33 <etnobot> also why are the error messages when i type something wrong in haskell so hard to understand
23:31:39 <etnobot> it's been around for quite a few years
23:32:09 <shachaf> The "not trolling" thing is becoming less and less convincing.
23:33:03 <jle`> admittedly it's something that's not ideal, but i think there's been some work on it recently too
23:33:45 <MorpheusB> that is why error messages to help you, not like c/c++ when you have to wait for runtime to find some errors
23:34:03 <etnobot> im not trying to start shit, i think functional programming is the future
23:34:04 <EvanR> c++ has plenty of error messages at compile time
23:36:13 <MorpheusB> it does but many missed compared with ghc
23:37:45 <etnobot> Are there any good talks for learning functional programming? I know stuff like map, filter, etc, and chaining functions together
23:37:57 <etnobot> and trying not to mutate stuff
23:38:13 <ramadoka> monad, watever it is.
23:38:18 <EvanR> learn by writing code, and reading code
23:38:33 <EvanR> pick a project and try to do it
23:38:58 <MorpheusB> have a look on /r/haskell many links to stuff on sidebar or main web site
23:39:21 <MorpheusB> also github has lots of resources listed if memory correct
23:40:07 <etnobot> neat thanks will do
23:40:23 <MorpheusB> Learn You A Haskell for Great Good is also available which worked well with Hutton's book, if you search will find pdf of them
23:43:28 <greves> etnobot let me know if you find something besides learn you a haskell and other commonly cited references :P
23:43:37 <greves> i find haskell really difficult
23:43:56 <etnobot> well currently im reading this http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf it uses haskell but im reading it to understand monads
23:44:30 <greves> cool thanks
23:44:32 <Meesha> as for hutton
23:44:37 <Meesha> one piece of advice
23:44:38 <EvanR> to understand monads you must first understand functors, and so you must first understand data types
23:44:44 <Meesha> first half of the book is fairly straightforward
23:44:49 <Meesha> the second half, is a bit tricky
23:44:55 <Meesha> i would go through the first half
23:45:05 <Meesha> and then try other tutorials and return to second part of hutton later
23:47:33 <liste> Meesha which C compiler are you using on Windows? I'm not sure how to install libraries, but you'll probably need to copy .dll/.lib/.so and .h files somewhere where the C compiler can find them
23:48:16 <liste> and GHC of course
23:54:30 <MorpheusB> https://www.haskell.org/platform/ - for haskell platform download
