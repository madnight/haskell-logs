00:00:02 <skore_de> I seem to, just not sure whether I understand it ;)
00:00:25 <asciiascetic> qracsp: maybe try the posts at fpcomplete
00:00:56 <asciiascetic> qracsp: https://www.fpcomplete.com/user/marcin/template-haskell-101
00:07:40 * hackagebot keera-hails-reactivevalues 0.1.0 - Haskell on Rails - Reactive Values  https://hackage.haskell.org/package/keera-hails-reactivevalues-0.1.0 (IvanPerez)
00:07:40 * hackagebot keera-hails-reactive-gtk 0.1 - Haskell on Gtk rails - Reactive Fields for Gtk widgets  https://hackage.haskell.org/package/keera-hails-reactive-gtk-0.1 (IvanPerez)
00:08:35 <qracsp> asciiascetic thanks
00:18:46 <eds> Code and error: http://lpaste.net/137809. I know I have not defined Rando (Expr (Bool : vs) Int)), but it is not a valid definition. I think I am doing something wrong while generating the tree.
00:18:57 <eds> Can anyone help.
00:22:40 <scshunt> eds: erm, that is the error
00:22:49 <scshunt> you can't apply rando to something which isn't an instance of Rando
00:22:55 <lf94> Hey, someone bored and want to port a Python script (7~ lines) to Haskell? I just want to see how elegant the end result would be, because it would probably take me like an hour to do it...
00:23:17 <lf94> https://gist.github.com/lf94/7274157b97eb60a2f817
00:23:19 <lf94> It's that
00:24:07 <eds> scshunt: yea I know. But the strongly typed GP should take care of it, according to the guy who helped me with that piece of code.
00:24:21 <eds> I mean strongly typed DSL*
00:24:43 <scshunt> eds: err, what?
00:24:55 <eds> That type of node should have never been generated.
00:28:43 <scshunt> eds: look at the type of O2 LEquals
00:28:54 <scshunt> it's Expr vs Int -> Expr vs Int -> Expr vs Bool
00:29:40 <scshunt> so the type of rando (d - 1) must unify with m (Exp cs Int)
00:30:09 <scshunt> but also, the function type is Expr (Bool ': vs) Bool
00:30:24 <scshunt> and rando (d - 1) is producing that
00:30:33 <scshunt> so it must unify with Expr (Bool ': vs) Bool
00:30:44 <scshunt> err
00:30:55 <scshunt> let me rephrase
00:31:10 <scshunt> the whole expression is producing an Expr vs Bool
00:31:13 <eds> scshunt: yea Lequals :: Op2 Int Bool, then look at op2's definition. op2 :: Op2 a b -> a -> a -> b. So for Lequals it will be Op2 Int Bool -> Int -> Int -> Bool.
00:31:17 <scshunt> but the individual randos are Expr vs Int
00:31:20 <scshunt> those are the same vs
00:31:36 <scshunt> moreover, the function type contrains vs ~ (Bool ': vs')
00:32:06 <scshunt> that's why you're getting that you must be using (rando (d - 1) :: m (Expr (Bool ': vs') Int))
00:32:20 <scshunt> or to put it another way
00:32:25 <scshunt> you said that type should never be generated
00:32:36 <scshunt> but it will be absolutely generated by LEquals
00:32:41 <eds> ahh I see.
00:32:56 <scshunt> if you actually want head vs ~ v at all times, why make it an option for it not to be equal?
00:33:10 <scshunt> just have it be Expr v vs, where vs is the tail of the list
00:34:53 <eds> scshunt: LEquals is defined Op2 Int Bool, and it is the Int parameter that generates the error here.
00:35:10 <eds> I did not understand the last part.
00:36:52 <scshunt> eds: so you currently have Expr vs v
00:36:57 <scshunt> but you're telling me that in all cases
00:37:08 <scshunt> you actually have an Expr (a ': vs) v
00:37:24 <scshunt> *Expr (a ': vs) a
00:37:30 <scshunt> why not simplify to just Expr a vs
00:38:15 <scshunt> it's sort of like how you can have data NonEmptyList a = {neHead :: a, neTail :: [a]}
00:40:12 <eds> scshunt: Yea, I have tried it. But that generated error when I try to produce Lists as nodes.
00:40:16 <eds> Wait let me upload that file.
00:40:19 <eds> and the error
00:42:03 <eds> scshunt: Here http://lpaste.net/137809
00:42:37 <rlewis> lf94 can you paste a list of files that python code generates, as well as their content?
00:42:55 <eds> The List does not know its type here.
00:43:29 <scshunt> eds: right
00:43:35 <scshunt> because you're trying to be more generic than you can be
00:43:40 <lf94> rlewis: it's a list of files from: 2015-04-19.txt to 2015-08-11.txt, in this format: 00:00:00, <daily average>
00:43:49 <scshunt> you don't have an instance of type forall a. Rando (Expr vs [a])
00:44:00 <scshunt> *for type
00:44:22 <lf94> rlewis: sorry, I meant that's the format inside the files.
00:44:47 <eds> scshunt: yeah. For now I just have an instance for Int and Bool values.
00:46:41 <scshunt> eds: the problem is that you have EL which can be validly made to be of type, say, (Expr vs [Maybe (IO Float)]) -> ExprW
00:46:45 <scshunt> is this really what you want?
00:47:34 <eds> No. So there is problem with my forall. I am not much acquainted with forall. Sorry about that.
00:47:36 * hackagebot strio 0.0.0.0 - Initial project template from stack  https://hackage.haskell.org/package/strio-0.0.0.0 (yulii)
00:51:38 <liste> interesting version number
00:53:13 <eds> scshunt: No. So there is problem with my forall. I am not much acquainted with forall. Sorry about that. So what can I do here?
00:55:11 <frerich>  lf94: What is the first element in the JSON output, seconds since 1970-1-1?
00:55:21 <frerich> lf94: I mean, the first element of each sublist.
00:55:28 <lf94> UNIX timestamp, yes :)
00:55:37 <lf94> The average is the last one.
00:55:43 <lf94> [7] = daily average
00:55:47 <lf94> [0] = timestamp
00:57:02 <rlewis> lf94, it has been a long time since I used python. if you ran that program today it would create just 2015-08-11.txt file, yes? with this content? 248\n236\n241...?
00:57:11 <adarqui> word, just installed 7.10.2 haskell platform on my mac
00:57:25 <lf94> rlewis, no it would create like...60 files
00:57:50 <lf94> rlewis, it gets the daily averages since a certain date until now.
00:57:59 <lf94> for every day, it creates a file and stores the daily average inside
00:58:02 <scshunt> eds: forall means exactly that. it can take any type
00:58:05 <rlewis> yes I see it now
00:58:23 <scshunt> the problem is you want to quantify over only Int and Bool here. You can't do this directly.
00:58:38 <scshunt> Probably the most direct solution is to create a typeclass, say Val, and make Int and Bool instances.
00:58:50 <scshunt> Then you can add a (Val a) constraint to the type
00:59:38 <scshunt> the downside is that the unifier would still fail for Rando
01:00:01 <scshunt> but you could move rando into that typeclass
01:00:11 <scshunt> or you could just make EL require a Rando instance
01:04:41 <joco> has anyone here experience with gtk-haskell bindings?
01:07:39 <karshan> can someone explain how the types of these 2 expressions make sense: http://lpaste.net/138668
01:08:07 <karshan> or is this a ghc bug/weird trickery
01:12:37 * hackagebot fay-jquery 0.6.1.0 - jQuery bindings for Fay.  https://hackage.haskell.org/package/fay-jquery-0.6.1.0 (AdamBergmark)
01:16:48 <karshan> nvm i'm stupid
01:17:37 * hackagebot ghc-exactprint 0.3.1.1 - ExactPrint for GHC  https://hackage.haskell.org/package/ghc-exactprint-0.3.1.1 (AlanZimmerman)
01:26:33 <nomeata> Is there a way to run "cabal run" from a different directory?
01:27:40 <ReinH> nomeata: what are you trying to do?
01:28:10 <nomeata> ReinH: Run an executable without installing it, but not from the project root
01:32:09 <lpaste_> predator117 pasted “bitcoin -- lf94” at http://lpaste.net/138671
01:32:26 <predator117> lf94: see above for a quick prototype
01:32:38 * hackagebot hOpenPGP 2.2.1 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.2.1 (ClintAdams)
01:32:50 <predator117> I didn't bother with writing files, output is just lines like '2015-08-13, 265.596930455263'
01:40:22 <rlewis> here's mine: http://lpaste.net/138674 
01:40:26 <rlewis> I did create files
01:42:45 <frerich> rlewis: It might be that you could simplify things even further using the 'wreq' package
01:43:09 <frerich> rlewis: It's my go-to stop for things like getting or posting JSON via HTTP.
01:43:33 <rlewis> quite possible. I haven't used it yet
01:45:48 <frerich> rlewis: If you have some suitable data type (say, 'Entry'), and the URL returns a list of such entries via JSON, getting the data via HTTP is as easy as 'asJSON =<< get "http://..." :: IO (Response [Entry])'
01:47:05 <frerich> rlewis: Hm, just tried it - but alas that gives an exception since the content type of the response is text/html
01:48:10 <merijn> I just saw someone say "cothunk" and now I'm thinking of values that magically turn into haskell programs that compute them :p
01:51:26 <rlewis> frerich in this case read parses a list of list of doubles just fine. but perhaps wreq also has a function that downloads a file and returns a String?
01:52:21 <merijn> rlewis: I'm going to guess that you almost certainly don't want this
01:52:31 <merijn> String is a terrible datatype for things like "downloaded files"
01:52:50 <rlewis> by file I meant a plain text file
01:52:51 <merijn> Note the String may consume as much as 24 bytes PER CHARACTER
01:52:58 <merijn> rlewis: You still don't want that
01:53:04 <merijn> rlewis: Use Text :)
01:53:45 <tdammers> "String" is a misnomer, in a way
01:54:06 <tdammers> IMO it represents a one-way traversal of a stream of characters more than an actual string
01:54:35 <rlewis> merijn, I know that. I was just translating a simple python script pasted above. and String works just fine
01:54:49 <merijn> tdammers: I'll take "tiny details I'd fix if I could go back in time before there was a lot of code" for $1000 ;)
01:55:01 <merijn> tdammers: Together with the horrible name of ByteString
01:55:12 <tdammers> sure
01:55:20 <tdammers> add "return" while we're at it
01:55:38 <merijn> tdammers: return was actually chosen on purpose >.>
01:55:47 <merijn> tdammers: Because you usually return at the end of a do-block
01:55:50 <merijn> But yeah...
01:56:01 <tdammers> still
01:56:17 <tdammers> trying to make do blocks look more imperative than they are was a wrong decision IMO
01:59:00 <merijn> Sure
01:59:51 <johnw> with 7.10, we can all just use pure
02:00:17 <merijn> I, for one, welcome our new Applicative overlords...
02:00:33 <merijn> Now, when is -XApplicativeDo coming here?
02:00:50 <johnw> good question
02:01:01 <rlewis> pure is shorter.. but not sure if the name is better
02:01:20 <johnw> it least it indicates that the only "content" in that action is the pure value being stated
02:01:36 <johnw> "return" just has no sensible meaning
02:04:57 <skore_de> A while ago, I commented on something on HN. It was on a video of a talk where somebody tried to do everything in some obscure language, including generating Javascript and pushing it to the browser. And my comment was -roughly- about being puzzled at why you would insist on doing that instead of just dealing with two different nodes. Now that I'm moving in an FP direction myself, I kept wondering what that language was, so I dug up 
02:06:39 <merijn> Ur/Web?
02:07:05 <merijn> The guy who wrote BazQuux (the RSS reader) used that and I know he posted on HN a few times about it
02:07:47 <merijn> It has a builtin DSL for SQL, HTML, JS (and I think CSS) so that sounds like what you mean?
02:08:12 <skore_de> This was about Jmacro, not sure whether that's directly related
02:08:18 <skore_de> https://wiki.haskell.org/Jmacro
02:08:20 <johnw> merijn: are you still in California?
02:08:34 <johnw> oh, sclv's library
02:09:01 <rlewis> lf94 not sure if you're still here.. I shaved a few more lines. http://lpaste.net/138678
02:09:36 <merijn> johnw: No, back in the Netherlands
02:10:43 <johnw> that's too bad
02:10:46 <johnw> I was just in SF this evening
02:11:52 <lf94> rlewis: still here :) nice job!
02:12:07 <lf94> I personally like yours more than predator117's
02:12:18 <rlewis> cheers :P
02:13:33 <antalsz> I just wrote some code which fails to link with “Undefined symbols for architecture x86_64:” for the symbols …ziDictionary_zdsfromList_closure and …ziDictionary_zdsfromList_closure (where “…” is the module name).  This seems to be referring to S.fromList, where S is Data.Set.  The code base is too big to be a MWE – any tips on cutting this down to debug it?
02:15:48 <lf94> yeah this is great
02:16:12 <lf94> I'm really happy that something like this is easily done in Haskell
02:16:32 <lf94> (Well, it took you awhile, but I don't know how well you know Haskell :)
02:16:45 <lf94> (or maybe you were busy doing something else)
02:17:43 <lf94> rlewis: How are you decoding the json?
02:17:58 <lf94> I see a "decode" here but nothing importing it AFAIK
02:17:59 <rlewis> I'd probably qualify as an advanced beginner
02:18:10 <rlewis> I just used read
02:18:19 <lf94> read decodes the json?
02:18:22 <Gurkenglas> rlewis, why not replace input with a two-element pattern match?
02:18:47 <rlewis> no, but in this case json's array syntax matches haskell's
02:19:00 <lf94> er...ok
02:19:03 <lf94> sounds magical to me
02:19:12 <rtb> how to use: newtype Pair a b = Pair (forall c. (a -> b -> c) -> c) from https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types (last section) ??
02:19:17 <rlewis> > read "[[1,2,3]]" :: [[Double]]
02:19:21 <lambdabot>  [[1.0,2.0,3.0]]
02:19:54 <lf94> rlewis, what happens when you have non-haskell compatible stuff ;)
02:20:05 <lf94> ok so I guess predator117's solution is a little more robust
02:20:10 <lf94> He does use Aeson
02:20:16 <rlewis> lf94, and because we passed the result to mapM_ createFile, and createFile accepts [Double], type inference did its thing and figured read has to attempt to parse the string to [[Double]]
02:20:21 <lf94> Eh either way they're both fairly short
02:20:40 <liste> > read "{\"not\": \"compatible\"}"
02:20:44 <lambdabot>  *Exception: Prelude.read: no parse
02:20:45 <rlewis> then you would use some json parsing library
02:20:46 <predator117> lf94: rlewis is much lighter regarding library usage
02:20:54 <rlewis> Gurkenglas yeah that would help
02:21:02 <lf94> predator117, yeah I see, but yours is definitely more correct I'd say
02:21:17 <predator117> mine is a little more robust due to aeson but uses unsafe operations like ^?!, if the format is not always valid you might want to change that as well
02:21:51 <lf94> This was just an exercise for seeing how concise a Python script could be in Haskell X)
02:22:07 <lf94> You both did good I'd say :)
02:24:11 <ttt_fff> this is sorated OT, but are al existing JS interpreters basically single threaded ?
02:24:12 <rlewis> thanks. I accept cheques.
02:26:33 <merijn> ttt_fff: Yes
02:26:48 <antalsz> Does anybody know what “$s” prepended to a name means in Core?
02:26:51 <squidp> can you create a GUI program in haskell?
02:26:52 <merijn> ttt_fff: All the ones I know, anyway, including Node
02:27:06 <merijn> antalsz: Sounds like a question that'll have better luck in #ghc
02:27:08 <ttt_fff> merijn: I was thiking only chrome/firefox, but it's a subset of the engines you mentioned
02:27:08 <maerwald> squidp: yes
02:27:11 <merijn> squidp: Sure
02:27:19 <antalsz> @merijn: Ah, should’ve thought of that – thanks!
02:27:19 <lambdabot> Unknown command, try @list
02:27:29 <squidp> how when haskell is purely functional?
02:27:30 <ttt_fff> squidp: I like the threepenny gui library
02:27:40 <maerwald> it's just not particularly fun, because there are not many proper GUI frameworks
02:27:54 <ttt_fff> threepenny-gui is nice
02:27:58 <maerwald> so you end up dealing with C binding most of the time
02:28:08 <ttt_fff> disclaimer: I do not own any stocks in threepenny-gui; nor have I shorted any of its competitors
02:28:10 <merijn> squidp: Why does that matter? We can do IO in haskell too. There's a perfectly well working FFI to C :)
02:28:33 <maerwald> bindings to C GUI frameworks are not fun
02:28:46 <merijn> maerwald: C GUI frameworks are not fun
02:29:02 <squidp> if we can do IO in haskell how can it be a purely functional language
02:29:04 <maerwald> they often rely on global variables for you to store states that you can access in random callback functions
02:29:08 <merijn> In better news, there's a vty-ui replacement that seems to address many of my vty-ui complaints :)
02:29:10 <skore_de> The only reason why I feel brave enough to go into Haskell is because I know I can do gui stuff in the browser and communicate through a webserver ;)
02:29:12 <tdammers> squidp: we cheat
02:29:17 <bernalex> we have declarative graphics for games, the web, and now finally curses as well.
02:29:23 <squidp> tdammers: o_O
02:29:30 <merijn> squidp: http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
02:29:34 <merijn> tdammers: No we don't
02:29:34 <tdammers> squidp: we don't actually do IO, we only declare things that represent IO operations
02:29:38 <maerwald> squidp: define "pure"
02:29:52 <tdammers> the process of producing these declarations is pure
02:29:56 <squidp> define define
02:29:58 <merijn> maerwald: "functions when given the same input always produce the same results with no side-effects"
02:30:08 <bernalex> gtk, qt, wx and so on is not nearly as nice. threepenny-gui is nice but needs you to run a local webserver for your program.
02:30:08 <merijn> maerwald: pure functions are pretty well-defined
02:30:24 <merijn> Well, maybe "no observable side-effects" if you want to be pedantic
02:30:27 <maerwald> merijn: I am aware that there are many different opinions on the definition
02:30:33 <maerwald> that's why I am asking
02:30:40 <ReinH> merijn: what is this vty-ui replacement?
02:30:41 <tdammers> executing the actions is impure, but we don't do that inside the language itself
02:30:44 <bernalex> ReinH: brick
02:30:46 <merijn> ReinH: brick
02:30:48 <ReinH> huh
02:30:53 <merijn> ReinH: vty-ui is deprecated and links to it
02:31:00 <merijn> ReinH: Was announced yesterday or so
02:31:07 <bernalex> ReinH: it was only recently announced on the haskell ml, and has been in the works for a long time.
02:31:33 <ReinH> great
02:31:44 <ReinH> I've never cared for vty-ui much
02:31:47 <bernalex> last I looked at it, it looked very very cool.
02:31:54 <merijn> maerwald: I don't think there's a lot of different opinions on what is a pure function. There's lots of arguments on what "referential transparency", etc. means
02:31:55 <tdammers> so when, for example, we say `putStrLn "Hello!"`, then we are using a pure function `putStrLn` and a pure string literal to create a pure expressing which, when evaluated, yields a pure value that represents an impure program that prints "Hello, world!"
02:32:05 <merijn> ReinH: He got rid of the stupid parametrization of Widget
02:32:12 <tdammers> except that I got the strings wrong
02:32:47 <squidp> didnt quite get this one: squidp: we don't actually do IO, we only declare things that represent IO operations
02:32:57 <merijn> ReinH: I liked vty-ui in the sense that it did what I wanted in a way that was sane (especially compared to ncurses), the API was just too imperative and needlessly verbose, imo. But the few small things I saw looked improved
02:32:59 <skore_de> re: threepenny-gui - I should have anticipated this, but OF COURSE there is already a solution available to the "kinda sorta want to do it this way, I think" idea I keep bouncing around in my head ;)
02:33:03 <merijn> squidp: Look at the link I told you earlier
02:33:07 <maerwald> merijn: see "What is a Purely Functional Language?" from Amr Sabry. That goes into way more detail, so I don't think it's that obvious.
02:33:09 <bernalex> tdammers: it would be a very interesting effect if "Hello!" was beta-reduced to "Hello, world!"
02:33:39 <merijn> maerwald: I'm not disagreeing that there's lots of arguments on what makes a language a "Purely Functional Language"
02:33:49 <tdammers> bernalex: import Prelude hiding (putStrLn); putStrLn = (++ "\n") -- there you go
02:33:55 <tdammers> :
02:33:59 <merijn> maerwald: I'm saying that "pure function" is pretty unambiguous, since I only know one possible definition
02:34:42 <lf94> quote from planet haskell, gave me a good chuckle:
02:34:44 <lf94> So, does functional programming stack up in the real world? In industry?
02:34:44 <lf94> Yes. Check my linkin profile. I have been programming, in industry, as long as you have been alive.
02:35:13 <pardonmemiss> Lol
02:35:14 <bernalex> maerwald: it goes into more detail, but it arrives at the same definition more or less.
02:35:24 <rtb> how to use: newtype Pair a b = Pair (forall c. (a -> b -> c) -> c) from https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types (last section) ??
02:35:30 <tdammers> sadly, I am now old enough for that to be true about myself
02:35:34 <maerwald> bernalex: and I was asking about squidps definition
02:35:43 <ironChicken> is it possible to have the GHC RTS is a shared library, and have GHC-compiled executables link to it dynamically?
02:35:47 <liste> rtb what do you want to use it for?
02:35:48 <merijn> ReinH: I like vty in that I can just give up on GUIs, write console interface and tell my friends to use "putty" to use my programs without worrying about portability, etc.
02:35:59 <merijn> ironChicken: Yes
02:36:01 <ReinH> heh
02:36:09 <tdammers> I have a colleague who was 3 years old when I made my first steps with MS-DOS batch scripts and Turbo Pascal
02:36:10 <merijn> ironChicken: Is there a reason you want to?
02:36:13 <ironChicken> merijn: is it also easy?
02:36:17 <mbrock> oh, wow, brick DOES look really cool. the time has come for declarative UI stuff! imperative widget creation and updating is so, so tedious, and declaring them as functions from state to description is just beautiful
02:36:24 <ironChicken> merijn: just out of interest, really
02:36:28 <squidp> maerwald: do you disagree that haskell is purely functional? i actually came here because there seems to be a disagrement whether it is.. wiki says it is, but that is not the best source
02:36:45 <merijn> ironChicken: Depends. If you think this stuff is easy to do in C, then it's not particularly harder. You need to do some digging to find the exact details, but it's not particularly hard
02:37:00 <bernalex> squidp: haskell is mainly purely functional but has escape hatches.
02:37:07 <merijn> ironChicken: If you're not familiar/comfortable with linking in C then it becomes harder
02:37:10 <squidp> disagrement among people who dabbled slighly in haskell at least
02:37:17 <Gurkenglas> rtb, you could give us the type signature of the function you need. For example, if you want to apply a function that takes two values to the two values contained in some Pair a b, you could say "(a -> b -> c) -> Pair a b -> c"
02:37:20 <liste> rtb e.g. first (Pair f) = (\x _ -> x)
02:37:22 <srhb> squidp: I'm guessing you're trying to bring out the "is IO pure" discussion?
02:37:36 <srhb> And not unsafePerformIO...
02:37:40 <liste> or snd (Pair f) = f (\_ x -> x)
02:37:41 <squidp> srhb: maybe?
02:37:46 <srhb> squidp: Heh. :-)
02:37:48 <liste> (the first one missed the f on rhs)
02:38:06 <squidp> I am not a haskell programmer
02:38:14 <merijn> ironChicken: Since GHC 7.8 it uses the system linker and dynamic linking for haskell has been possible for awhile longer, I think.
02:38:21 <Gurkenglas> liste, first traditionally maps a function across the first argument, retaining the second.
02:38:25 <srhb> squidp: I think that makes the distinction a little hard to discuss, unfortunately.
02:38:29 <liste> yeah, the naming was bad
02:38:31 <dramforever> squidp: we don't do error directly
02:38:33 <liste> fst is the correct name
02:38:42 <liste> or fst'
02:38:47 <dramforever> ouch screw it
02:38:55 <dramforever> squidp: we do IO in a different way
02:39:00 <merijn> ironChicken: By default GHC statically links all haskell objects, but you can turn the result into a dynamic library and you can (if you want) link the haskell objects dynamically too, but I don't see much value in it
02:39:09 <squidp> I see
02:39:12 <skore_de> squidp: Only getting into it myself, but: That's really the answer to your question - IO is not pure, so you cannot deal with it in a pure manner. Haskell accepts a few impurities in order to do IO
02:39:12 <dramforever> in other languages, we just interleave side effects with other stuff
02:39:21 <tdammers> squidp: I think a good first intuition for the IO type is that "IO a represents a program that produces a value of type a"
02:39:29 <srhb> skore_de: That is the disagreement where many (including me) will disagree with you.
02:39:36 <srhb> skore_de: ie. IO really is pure.
02:39:49 <merijn> ironChicken: In the end GHC just produces .a/.so (or I guess .dll on windows) objects that you can use the way you use any other library
02:39:50 <squidp> o_O
02:39:51 <dramforever> squidp: what about this: we only model IO in haskell
02:39:59 <tdammers> squidp: we can do all sorts of things with this program, because it is a first-class value; the only thing we cannot do, really, is run it, or modify it in place
02:40:17 <skore_de> srhb: I have a hunch that that is only true if you limit it to the point where it IS pure
02:40:20 <dramforever> the runtime system will evaluate the main expression, extracting an IO description
02:40:20 <maerwald> squidp: there is disagreement about whether IO is actually a pure thing and a lot of people dive into compiler details to figure that out. I just think in terms of "effects" and when I look at IO, it is part of the type, so an explicit effect, not a side effect
02:40:27 <dramforever> then it does the IO
02:40:28 <srhb> skore_de: Yes, ie. not unsafePerformIO
02:40:45 <ReinH> skore_de: evaluation is pure, execution is not. No one expects execution to be pure though.
02:40:47 <tdammers> squidp: if we want to run it, what we do is we declare a top-level variable called "main" in the module "Main", and then rely on the Haskell runtime to take that variable and run it as a program
02:41:13 <ironChicken> merijn: i was wondering if it would make my executables much smaller to remove the RTS
02:41:42 <tdammers> ironChicken: what's your use case for optimizing at this level?
02:41:51 <merijn> ironChicken: Perhaps, but then people still need to download the library anyway
02:41:52 <skore_de> ReinH: my next attempt then would be: Imperative languages are simply impure throughout whereas Haskell tries to pull as many impurities into a pure space as possible and cutting it off at a level where it starts to become useful
02:41:58 <ironChicken> tdammers: none. i'm just interested ;-)
02:42:04 <merijn> ironChicken: Given the side of hard disks these days my advice is "don't bother"
02:42:22 <merijn> I'm of the opinion that dynamic linking is a bad idea and you shouldn't do it
02:42:23 <tdammers> ironChicken: I guess the busybox approach would be a more fruitful one then
02:42:39 <tdammers> ironChicken: if saving disk space is worth it at all, that is
02:42:42 <merijn> Unless you want to *actually* dynamically like, like loading plugins on the fly
02:43:00 <ironChicken> tdammers: what's the busybox approach?
02:43:01 <skore_de> (but - I'm only weeks into learning FP and Haskell, so I am very probably completely off)
02:43:04 <merijn> s/like/link
02:43:10 <ReinH> merijn: well, you can't really avoid dynamic linking on linux though :/
02:43:19 <merijn> skore_de: That's a pretty fair assessment, imo
02:43:40 <dramforever> ironChicken: multiple programs smashed together
02:43:41 <ironChicken> ReinH: true. and i'd never really heard that it's especially bad
02:43:51 <merijn> skore_de: Most people who've been doing haskell for a while will say that Haskell is their favourite imperative language :)
02:43:59 <ironChicken> dramforever: ah yes, makes sense
02:44:01 <ReinH> you can certainly minimize it
02:44:03 <dramforever> merijn ++
02:44:10 <ttt_fff> ha, I think I just managed to crash ghci in a way where it told me to file a bug report
02:44:13 <skore_de> merijn: Hah! :D
02:44:26 <merijn> skore_de: Because programming in IO is essentially just writing imperative code (with the benefit of having a saner type system), whereas you can *stop* being imperative when convenient
02:44:34 <dramforever> ttt_fff: interesting, maybe see if it's really a bug
02:44:38 <dramforever> or something else
02:44:41 <srhb> I honestly think it's a bit strange that people get so hung up on the question (no offense.) It's clear that we can compose and work with IO actions AS pure values, and that's probably enough for anyone without going into ill-defined philosophical questions. :-)
02:44:46 <ttt_fff> dramforever: you mean do real work myself for the benefit of others?
02:44:48 <ReinH> merijn: I like programming imperatively in ST as well
02:44:49 <merijn> skore_de: Unlike other languages where you can never stop being imperative (well, you can make every const/constexpr in C++, but that's pretty annoying)
02:44:50 <srhb> But that's just, like, my opinion.
02:45:00 <dramforever> lemme see
02:45:15 <tdammers> the more I use Haskell, the more I think of it as not a programming language, but a DSL for building programming languages
02:45:18 <dramforever> in haskell no functions have side effects
02:45:26 <dramforever> they just have front and back effects
02:45:43 <ttt_fff> tdammers: a TYPESAFE way to build DSLs; lisp can build DSLs, but OMG lisp amcros sucked to debug
02:45:47 <ReinH> dramforever: top and bottom effects?
02:45:50 <ttt_fff> ghc errors are my favorite
02:45:51 <srhb> dramforever: "Now you have two problems..."
02:45:55 <merijn> skore_de: I know that I mostly write very imperative code in haskell (networking and concurrency, so like over 50% of my code ends up being IO anyway) and it's by far my favourite language for this type of imperative coding
02:46:00 <pyon> This isn't exactly a Haskell question, but it's the kind of question that someone in the Haskell intelligentsia should be able to answer (I hope!): http://stackoverflow.com/q/31977967/46571
02:46:01 <maerwald> ttt_fff: debugging haskell is not really nice either
02:46:02 <skore_de> merijn: very interesting! It sort of confirms my plan, though - I'm switching over from imperative programming and I can very clearly see how FP/Haskell will improve everything "on the server side", but for the client side, it's going to be html+javascript, for me. So I guess I'm kind of containing most of the imperative stuff there
02:46:10 <dramforever> srhb: don't worry it turns out to work pretty well
02:46:20 <ttt_fff> maerwald: oh, I have a really nice haskell system which outputs stack frames in svg
02:46:24 <srhb> skore_de: Haskell compiles to javascript... :-)_
02:46:25 <ttt_fff> maerwald: it makes debugging trivial
02:46:25 <merijn> skore_de: ghcjs let's you compile haskell to JS! Haskell on the client side too!
02:46:31 <tdammers> yeah, type safety is a much bigger deal to me than a functional programming style
02:46:36 <srhb> skore_de: And it's brilliant.
02:46:38 <dramforever> some people complain "haskell is impossible to debug, because the variables are immutable"
02:46:38 <skore_de> well, that's what I was linking to earlier :D
02:46:47 <ReinH> skore_de: you can use haskell on the clientside, or things like purescript
02:46:49 <skore_de> my bafflement at why somebody would do that... one and a half year ago ;)
02:46:51 <dramforever> I just want to say "wtf is that"
02:46:57 <ttt_fff> tdammers: type safety means I can use libraries I don't know, and if my code compiles, knows that i'm probably calling it correctly
02:47:07 <skore_de> I know far more javascript than haskell and it doesn't bother me as much to write it
02:47:08 <tdammers> ttt_fff: that's like the baseline, but yes
02:47:11 <mbrock> the relevant meaning of purity for me is that functions can be reasoned about as being mathematical functions, which indeed IO does not change. just like mathematical functions can operate on values that represent mayhem and nuclear destruction, Haskell functions can work with values representing HTTP sockets and file descriptors. the pure foundations of the
02:47:11 <mbrock> way it does so helps me write correct code
02:47:14 <merijn> dramforever: Well, haskell is tricky to debug. But it's also tricky to bug in the first place, so it's a net-win imo
02:47:18 <srhb> skore_de: ghcjs? OK. There are many solutions out there, and all other than ghcjs are imitations of Haskell, basically, while ghcjs provides you with actual Haskell in the browser. :)
02:47:22 <maerwald> ttt_fff: that's overly optimistic
02:47:23 <tdammers> ttt_fff: to me, it means that I can set myself up for success, in a way
02:47:23 <ReinH> dramforever: that's not why haskell is hard to debug
02:47:28 <squidp> what do you mean by type safety?
02:47:28 <srhb> skore_de: (ie. the ghc runtime embedded in the browser.)
02:47:32 <dramforever> exactly what I was talking about
02:47:45 <tdammers> Haskell is hard to debug? I beg to differ
02:47:47 <dramforever> I think haskell is hard to bug because you can easily write general functions
02:47:52 <dramforever> and parametricity help
02:47:54 <dramforever> *helps
02:48:01 <merijn> tdammers: Stepping through haskell is tricky and annoying
02:48:11 <tdammers> I think Haskell appears hard to debug because it prevents you from producing the kind of bug that is easy to debug
02:48:18 <maerwald> lol, no
02:48:18 <skore_de> srhb: I know it would take me longer to understand how to do javascript in haskell in javascript than just doing javascript right away ;) It's a shortcut for now and I'm very ready to eventually make the switch
02:48:19 <merijn> tdammers: I'd like a convenient way to step through parsec/attoparsec parsers
02:48:24 <tdammers> and step debugging is kind of shit anyway
02:48:33 <srhb> skore_de: OK, sure. Just pointing it out. :-)
02:48:44 <srhb> skore_de: Being able to share types across server/client is really handy.
02:48:45 <squidp> type safety = no segfaults?
02:48:57 <merijn> skore_de: There's JS FFI in ghcjs too, so you could always call functionality written in JS from your haskell core ;)
02:48:58 <pyon> squidp: What "type safety" means depends on the language.
02:49:04 <dramforever> lol segfaults
02:49:05 <merijn> pyon: No
02:49:07 <pyon> squidp: Different type systems aim to eliminate different kinds of errors.
02:49:12 <tdammers> merijn: I've found interactively evaluating subsets of a parser at least as good, once you know how to do it
02:49:15 <srhb> @quote srhb.segfault
02:49:15 <lambdabot> No quotes match. You untyped fool!
02:49:16 <srhb> aww
02:49:17 <merijn> pyon: type safety depends on an execution model
02:49:18 <srhb> :(
02:49:30 <pyon> merijn: Well, isn't the operational semantics a part of the language's definition?
02:49:33 <squidp> can you get a segfault in haskell?
02:49:34 <merijn> pyon: You can have multiple definitions of type safety for a given language
02:49:39 <pyon> merijn: Oh.
02:49:39 <dramforever> once I saw someone ask 'what's a "core dump?" why doesn't haskell have it?'
02:49:44 <merijn> pyon: Haskell doesn't have an operational semantics
02:49:44 <srhb> squidp: Sure, it's easy if you do FFI stuff especially. :-)
02:49:49 <srhb> squidp: Lots of fun.
02:49:57 <pyon> merijn: Ah, okay, point taken.
02:50:04 <dramforever> squidp: you can use unsafe functions
02:50:19 <merijn> pyon: Granted, it does have a denotational semantics and it's type safety is defined in relation to that
02:50:20 <tdammers> haskell can core dump just fine, it's just hard to drive it to that point
02:50:24 <maerwald> you can even have memory leaks in haskell and without FFI
02:50:31 <squidp> that is a shame
02:50:50 <hftf> @pl \e a b -> zipWith (f e) a b
02:50:50 <lambdabot> zipWith . f
02:50:53 <dramforever> squidp: but much less possible than languages like C
02:50:57 <tdammers> but then, in practice every language can coredump, unless the runtime is perfect
02:51:13 <merijn> pyon: In essence to have type safety you need to define 1) a type system and 2) a model and 3) a set of safety claims that the type system is supposed to enforce
02:52:02 <merijn> pyon: So a language + model is type safe for a given set of safety claims if you can prove in the model that those safety claims hold for any well-typed term
02:52:02 <frerich> merijn: Out of curiosity - what do you currently use for debugging parsec/attoparsec parsers right now?
02:52:03 <squidp> how about compared to languages like python, c#? i dont think you can cause segfaults in them (other than in an unsafe block in c#(
02:52:06 <dramforever> squidp: would you consider it a disadvantage?
02:52:15 <merijn> frerich: Whiskey
02:52:20 <skore_de> srhb & merijn: Actually, my hunch is that I appreciate the separation, tbh. I already liked adding to the workflow of doing everything server-side in an imperative language to /actually doing javascript proper/ - I learned tons through that. Now I want to see what having the contrast of client side javascript (or other clients, I will probably have PHP code consuming Haskell-written APIs) and serer-side Haskell has to offer in terms 
02:52:21 <dramforever> squidp: pretty sure you could get a segfault in python
02:52:28 <dramforever> just do a memory leak
02:52:30 <squidp> how?
02:52:57 <maerwald> you can definitely have segfaults and memory leaks in c#
02:52:59 <dramforever> ok if you don't allow that lemme see...python also has an FFI
02:53:04 <hftf> does anyone here use ramda js?
02:53:06 <merijn> pyon: Like, C is perfectly type safe. But the safety claims it makes for well-typed terms is so limited that that's pretty useless :)
02:53:08 <srhb> skore_de: Well, regardless of whether I think you will eventually want to switch, I'm sure it will be a fun and rewarding experience. :-)
02:53:17 <pyon> merijn: I'm not really used to thinking of programming languages without an execution model... We can have an axiomatic execution model, not defined by execution rules, but rather just by the type safety guarantees.
02:53:20 <dramforever> squidp: but would you consider it a disadvantage? I don't think so
02:53:26 <merijn> pyon: For example, any term containing undefined behaviour is allowed to do "anything" according to the safety claims :)
02:53:33 <dramforever> yes, FFI isn't very safe
02:53:41 <frerich> merijn: I guess that works. RWH suggested (and that's what I ever used since) liberal use of <?> but that worked so-so for me.
02:53:42 <hftf> I'm having trouble doing zipWith . f as R.compose( R.zipWith, f ) in ramda because I think R.compose discards all but one arg
02:53:45 <pyon> merijn: That's... utterly programmer-unfriendly.
02:53:52 <merijn> pyon: Oh, sure
02:53:52 <squidp> using up entire memory is not whAt i had in mind when I asked (will that even cause segfault, or some other error)
02:53:54 <frerich> merijn: Just wondering whether there's something friendlier these days.
02:54:09 <merijn> pyon: That's why "type safety" is not very useful without specifying precisely which safety claims you're talking about :)
02:54:17 <dramforever> squidp: ok then, we also have those escape hatches
02:54:18 <merijn> pyon: Harper has a good blogpost/comment on this
02:54:26 <pyon> merijn: Ah, will check.
02:54:29 <srhb> hftf: What is ramda?
02:54:34 <skore_de> srhb: Exactly - I'm very sure that I cannot lose in this equation. I don't know for sure whether Haskell will stick for me, but the learning experience has already been amazing. Worst case, I do end up with separated layers and some sweet Haskell codebase
02:54:40 <squidp> I meant data corruption, buffer overflows, dereferencing NULL, etc
02:54:50 <hftf> srhb: http://ramdajs.com/docs/
02:55:00 <merijn> pyon: http://www.pl-enthusiast.net/2014/08/05/type-safety/
02:55:04 <srhb> skore_de: Yeah. :)
02:55:08 <merijn> pyon: Especially the comments by Harper at the end
02:55:11 <squidp> I dont think you can do any of that in python
02:55:24 <srhb> hftf: Ah, so not Haskell. That explains the arguments.
02:55:27 <merijn> pyon: I forget whether the actual post was worth reading
02:55:31 <pyon> merijn: I really expect "type safety" to mean "abstractions are protected".
02:55:39 <skore_de> srhb: Although I think that the worst case is the most likely case at the moment, but that's simply due to the fact that I'm using it in a particular business niche
02:55:53 <hftf> right, theres no active ramda channel, i thought haskellers would have some tricks up their sleeves
02:56:14 <merijn> pyon: Yeah, people commonly use it informally as that. But it's important to realise the type safety is a technical term in type theory/PLT with a very rigid definition :)
02:56:14 <dramforever> "data corruption" I don't understand this, can you give an example?
02:56:20 <dramforever> squidp: ^
02:56:23 <srhb> skore_de: Well I don't know how far in you are, but I will say that most successful learning experiences in Haskell take a rather theoretical approach to start with (ie. don't start by hacking a web service together before learning the ropes with types.)
02:57:13 <dramforever> actually, there's a problem
02:57:14 <maerwald> dramforever: he probably means memory corruption?
02:57:20 <squidp> dramforever: writing to a pointer value that points somewhere it shouldnt, and with that silently corrupting other data. this is probably worse than a segfault
02:57:27 <srhb> hftf: "The rightmost function may have any arity; the remaining functions must be unary." <-- did you see this bit?
02:57:36 <hftf> I did and it seems like a bad design
02:57:40 <srhb> Agreed.
02:57:49 <hftf> In haskell everything is curried by default...
02:57:51 <dramforever> squidp: it's designed not to, but it's really the runtime system
02:57:53 <hftf> I think...
02:57:56 <srhb> hftf: Yes.
02:57:57 <dramforever> squidp: also another thing
02:58:00 <srhb> hftf: (Which is nice.)
02:58:19 <dramforever> those things aren't what we deal with often
02:58:29 <dramforever> instead, we write general code
02:58:33 <rtb> Gurkenglas, liste : foremost I'd like to contruct a Pair but understanding the nested functions in the constructor "Pair :: (forall c. (a -> b -> c) -> c) -> Pair a b" ist not easy
02:58:43 <dramforever> it's a double-win, because 1. it can be applied in more places
02:58:46 <squidp> but it is possible to write them? 
02:58:59 <Gurkenglas> rtb, so "a -> b -> Pair a b"?
02:59:06 <dramforever> by "them" you mean those pointer, array, etc. stuff?
02:59:08 <dramforever> yes then
02:59:23 <dramforever> 2. they are automatically less prone to bugs
02:59:35 <squidp> ?
02:59:40 <Gurkenglas> :t \a b -> Pair \f -> f a b
02:59:41 <lambdabot> parse error on input ‘\’
03:00:15 <squidp> I thought haskell is regarded as a super safe language?
03:00:21 <srhb> It is.
03:00:31 <dramforever> for some value of "super"
03:00:31 <maerwald> > [] !! 1
03:00:34 <lambdabot>  *Exception: Prelude.!!: index too large
03:00:35 <merijn> Compared to many popular languages it is
03:00:38 <maerwald> we are not dereferncing null here or anything
03:00:40 <merijn> But it's not perfectly safe
03:00:41 <dramforever> yep
03:00:42 <Gurkenglas> @let Pair a b = Pair {runPair :: forall c. (a -> b -> c) -> c}
03:00:43 <lambdabot>  Parse failed: NamedFieldPuns is not enabled
03:00:43 <skore_de> srhb: I have been planning a certain infrastructure for my business for about four years now and I'm just about getting done with boiling down the formal structure of it. I was looking for a way to implement it and arrived at the conclusion that I was looking for FP - and made a decision to go with Haskell. I'm going to learn the basics of it for another month or so while at the same time making the formal structure more concrete - I
03:00:48 <srhb> squidp: Being unable to call out to C functions would be a rather huge deficiency.
03:00:49 <squidp> dramforever: haha
03:00:50 <maerwald> it's an explicit case that throws an explicit exception
03:00:57 <srhb> squidp: But we have tools to do it in relatively safe manners.
03:00:59 <dramforever> squidp: wait you don't know haskell, right?
03:01:05 <squidp> no
03:01:17 <srhb> The ease of writing safe code is pretty important to the overall safety of a "language"
03:01:17 <dramforever> um...what other languages you know?
03:01:24 <dramforever> srhb ++
03:01:29 <rtb> Gurkenglas: thanks!
03:01:33 <pyon> merijn: I'm okay with defining type safety as being relative to a type system's claims. I'm much less okay with saying the execution model isn't a part of the language. We can have an abstract execution model, given just by the type safety guarantees, rather than execution rules. (In which case implementations are free to do as they wish, as long as the type safety theorem holds.)
03:01:34 <srhb> skore_de: Cool :-)
03:01:40 <squidp> C, C#, python, elisp
03:01:42 <fractalsea> I have a program that sends a data over a TCP socket, and receives the response. I have a script that runs this program multiple times in quick succession.  On my local (OSX) machine this works fine, but on my linux server, I randomly get the error `sendWakeup: invalid argument (Bad file descriptor)`. It doesn’t seem to have any effect, but I would like to get to the bottom of it. I believe it originates here: 
03:01:43 <fractalsea> https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Event.Control.html#sendWakeup. Has anyone seen this error before? Or have any ideas on why it is happening? Or tips on how to get to the bottom of it? Thanks
03:01:49 <squidp> dabbled in java
03:01:59 <squidp> and C++
03:02:01 <srhb> skore_de: Well, you seem to have one of the important things down; hanging out in #haskell ;)
03:02:13 <dramforever> squidp: ok do you know templates?
03:02:14 <srhb> skore_de: A lot of very nice and smart people in here.
03:02:17 <merijn> skore_de: The first steps of becoming a better programmer are realising that 1) you're not smart enough to keep everything in mind, 2) that most of this complexity comes from coupling and a large state space, thus you need tools with better abstraction AND reduce the statespace by reducing the amount of state transitions (i.e. mutations) and you quickly end up at haskell-like things :)
03:02:33 <skore_de> merijn: exactly!
03:02:33 <dramforever> squidp: oh forget about it, no use for those
03:02:55 <merijn> pyon: You may wanna look into denotational semantics instead of operational semantics for an alternate view (which I think is close to what you're suggesting)
03:03:10 <squidp> dramforever: I know how to use them the way they were originally intended.. template metaprogeamming hacks I dont know much
03:03:11 <Gurkenglas> rtb, http://lpaste.net/138688
03:03:27 <alpa-bet-gamma> merijn: Learning how to build large software systems in Haskell is what I wish to learn now.
03:03:37 <skore_de> I was trying and trying to come up with a clean system in my imperative language of choice... eventually I realized that I was actually looking for what FP calls 'pure' and that I really actually want to do FP :D
03:03:49 <alpa-bet-gamma> Which means I have to get my hands dirty fixing bugs in existing applications.
03:03:57 <hftf> meh i'll just go with pointful instead, even though it looks ugly
03:03:59 <dramforever> squidp: ok then, say we want a template<typename T> f (T x)
03:04:06 <alpa-bet-gamma> But since I am a little chatty now, I would still ask for suggestions. :-D
03:04:21 <dramforever> we want an ideal template here, which means you can't do anything that will look inside the x
03:04:28 <maerwald> alpa-bet-gamma: hack the diagrams libraries
03:04:39 <srhb> skore_de: Ssssoooon your corruption will be complete.
03:04:45 <dramforever> interestingly, there isn't much the function could do
03:05:02 <dramforever> because that "ideal" constraint
03:05:06 <dramforever> *because of
03:05:06 <squidp> dramforever: not following
03:05:15 <dramforever> forget about it then
03:05:20 <squidp> lol ok
03:06:04 <dramforever> ok then, say we want to write a function f which has type a -> a
03:06:20 <skore_de> srhb: yeah, way past the even horizon already ;)
03:06:26 <srhb> skore_de: :-)
03:06:30 <dramforever> in haskell that means the caller can pick the a
03:06:47 <hftf> anyone have experience contributing to pandoc? 
03:06:51 <dramforever> and f will take a value of type a and return another of type a
03:07:19 <squidp> yes
03:07:37 <dramforever> squidp: interestingly, without escape hatches, this function can't do very much
03:08:05 <axiomish> dreamforever: what do you mean by escape hatch?
03:08:16 <axiomish> *dramforever: 
03:08:36 <dramforever> there are a few functions that would allow you to side step the type system
03:08:53 <dramforever> and this system of parametricity
03:09:03 <dramforever> like unsafeCoerce, unsafePerformIO, seq, par
03:09:25 <axiomish> ahhh okay — sorry for jumping in
03:09:39 <dramforever> squidp: ok back to the function, it must be either 1. stuck in an infinite loop
03:10:03 <dramforever> 2. a function that returns it's passed in argument untouched
03:10:08 <squidp> I can think of infinite ways to write that function
03:10:12 <dramforever> squidp: yes
03:10:20 <dramforever> but only one is interesting
03:10:33 <dramforever> squidp: the rest are usually easily avoided
03:11:02 <dramforever> that's what we mean by "it's easier to write safe code in haskell"
03:11:15 <squidp> I dont see your point.. maybe because I dont know haskell, but you seem to keep assuming I do
03:11:18 <srhb> squidp: I think there are less ways than you think.
03:11:27 <srhb> fewer?
03:11:46 <dramforever> squidp: I just continued because you said "yes" after I said "and f will take a value of type a and return another of type a"
03:12:07 <dramforever> squidp: ok then tell me a few of those infinite ways
03:13:03 <squidp> return a + a. return a.foo() + a.foo()
03:13:22 <liste> squidp but you cant + or .foo()
03:13:30 <squidp> return a.foo().bar() + a.bar().foo()
03:13:38 <srhb> That would assume that (+) is supported and .foo() is supported.
03:13:43 <dramforever> those won't work
03:13:44 <srhb> a -> a makes no such promise
03:13:50 <srhb> In fact, it promises that you cannot do that.
03:13:52 <dramforever> because the caller gets to pick that a
03:13:54 <liste> because how can you know ANY value can be added or .foo()ed?
03:14:11 <squidp> I dont even know what a -> a is
03:14:23 <dramforever> I thought I told you
03:14:23 <srhb> Any type a, to any type a
03:14:27 <liste> the type a function that takes any value and returns a value of any type
03:14:30 <srhb> It could be String, Int, ... 
03:14:37 <axiomish> i'm not even sure what this function could really do with the value at this point, besides do nothing.
03:14:38 <liste> the same tye*
03:14:47 <srhb> axiomish: That's the point :)
03:14:47 <maerwald> axiomish: exactly that... nothing
03:14:48 <dramforever> I said "in haskell that means the caller can pick the a" "and f will take a value of type a and return another of type a"
03:14:50 <maerwald> :t id
03:14:51 <lambdabot> a -> a
03:14:53 <dramforever> then you said yes
03:15:15 <dramforever> squidp: ^ sorry for that confusion, though
03:15:32 <squidp> A function(A argument) ?
03:15:35 <srhb> Yes
03:15:44 <srhb> Takes a type a and returns a type a
03:15:53 <maerwald> squidp: with the constraint that you can't even do IO in that function
03:16:09 <srhb> You can do precious little since it must work for ANY type a
03:16:27 <frerich> squidp: It's important to note that in 'a -> a', the 'a's are not some specific type called 'a' but a type variable.
03:16:36 <hpc> there's also no "if A is this type then this, else that"
03:16:44 <hpc> like java's instanceof keyword
03:16:49 <frerich> squidp: Akin to e..g template parameters in C++ (or Java generics)
03:16:57 <dramforever> ONLY AKIN
03:16:58 <srhb> > let foo :: a -> a; foo x = x + x in foo -- this fails!
03:16:59 <lambdabot>      No instance for (Num a1) arising from a use of ‘+’
03:16:59 <lambdabot>      Possible fix:
03:16:59 <lambdabot>        add (Num a1) to the context of
03:17:15 <dramforever> squidp: because the compiler doesn't think this a is a number
03:17:30 <dramforever> "no instance for (Num a1)" means a1 is not an instance of sum
03:17:37 <dramforever> and a1 is just a renamed variable
03:17:41 <squidp> so this sounds more like C# generics than C++ templates
03:17:42 <Gurkenglas> *Num
03:17:46 <dramforever> squidp: exactly
03:17:46 <srhb> And there is very real and tangible safety in this.
03:17:52 <dramforever> but I don't know c# at all
03:18:04 <dramforever> I didn't even know C# had them
03:18:09 <dramforever> but I know java had them
03:18:48 <squidp> java picked them up from #
03:19:00 <squidp> c#
03:19:09 <dramforever> ok
03:19:28 <squidp> so, what is the only way you can write that function?
03:19:28 <dramforever> squidp: so I assume you understand it better now
03:19:33 <dramforever> f x = x
03:19:44 <ChristianS> squidp: java picked what from c#? generally i'd suppose that it likely was the other way around.
03:19:44 <dramforever> or some infinite loop
03:19:47 <dramforever> f x = f x
03:20:38 <maerwald> haskell -> f# -> c# -> java? ;)
03:20:41 <squidp> ChristianS: At the beginning yes. C# was basically a java rip off. but then they added a bunch of stuff that java didnt have
03:21:03 <squidp> f x = x  means return x?
03:21:53 <maerwald> > id "abc"
03:21:54 <dramforever> yep
03:21:55 <lambdabot>  "abc"
03:21:55 <silver> means more like function f evaluates to it's argument unchanged
03:21:56 <maerwald> > id 5
03:21:58 <lambdabot>  5
03:22:03 <axiomish> barely feasible research suggests java 2004 and c# 2006 but it really doesn't matter
03:22:04 <dramforever> silver: sure
03:23:21 <squidp> maerwald: squidp: with the constraint that you can't even do IO in that function
03:23:24 <squidp> why not?
03:23:38 <srhb> Because the type guarantees you cannot.
03:23:40 <maerwald> because then it would be something like: f :: a -> IO a
03:23:45 <maerwald> which is a different type
03:23:54 <srhb> > let foo :: a -> a; foo x = print x in foo -- this fails!
03:23:55 <lambdabot>      Couldn't match expected type ‘a1’ with actual type ‘IO ()’
03:23:56 <lambdabot>        ‘a1’ is a rigid type variable bound by
03:23:56 <lambdabot>             the type signature for foo :: a1 -> a1 at <interactive>:1:12
03:24:05 <srhb> a does not unify with IO ()
03:24:05 <tdammers> by declaring that type, you promise you won't be doing IO in that function
03:24:08 <srhb> (or IO anything)
03:24:10 <squidp> interesting
03:24:17 <dramforever> sure
03:24:18 <tdammers> and the compiler makes sure you keep your promise
03:24:40 <maerwald> silver: f only evaluates to its argument if you actually pass that argument :P
03:25:00 <silver> yeah
03:25:12 <srhb> squidp: For completeness, (I don't think anyone actually said this yet?) the only really obvious implementation of a function a -> a is id x = x
03:25:21 <srhb> squidp: Ie the function that takes an argument and returns it unaltered
03:25:50 <dramforever> srhb: I said this
03:25:52 <srhb> (Because without knowing the type, you cannot make any alterations! Adding requires Num, etc.)
03:25:55 <srhb> dramforever: Oh, sorry.
03:25:57 <dramforever> the other is f x = f x
03:25:58 * srhb is blind
03:26:07 <srhb> Sorry. :)
03:26:09 <dramforever> which is obviously wrong
03:26:15 <dramforever> srhb: don't worry
03:26:21 <dramforever> it's kinda "loud" here
03:26:30 <axiomish> so how are generics really used in haskell
03:26:38 <axiomish> if at all
03:26:39 <srhb> axiomish: Not often.
03:27:05 <tdammers> f x = undefined -- you don't want that either usually
03:27:13 <srhb> Mostly when you want to create instances programatically over some generic datatype.
03:27:22 <squidp> what would the definition look like if you wanted to print x?
03:27:29 <srhb> :t \x -> print x
03:27:30 <lambdabot> Show a => a -> IO ()
03:27:43 <dramforever> tdammers: technically that's an escape hatch into the exception mechanism
03:27:51 <srhb> squidp: It requires that a is a member of the Show typeclass (which knows how to make a string representation of the value)
03:27:54 <tdammers> dramforever: true
03:27:55 <dramforever> still escape hatch
03:28:15 <srhb> squidp: And passing in any value of a type that does NOT have a Show instance will be a compile time error.
03:28:18 <srhb> squidp: (safe!)
03:28:42 <dramforever> kinda like interfaces in java
03:31:15 <axiomish> how do protocols and typeclass's differ? They appear to be different but I'm not sure of how they would be used differently? (irrelevant to whether haskell supports protocols)
03:31:33 <squidp> we use -> when we do IO?
03:31:43 <srhb> squidp: -> is the function construction type operator
03:32:05 <srhb> squidp: a -> b -> c -- is a function that takes two arguments, one of type a and one of type b, and returns a type c value
03:32:20 <maerwald> right and please don't confuse him with currying now
03:32:33 <squidp> srhb: :t \x -> print x
03:32:38 <srhb> squidp: Oh and in the case of \x -> foo x -- it's just lambda (anonymous) syntax
03:32:50 <srhb> so it's an anonymous function that takes a variable named x
03:32:57 <srhb> squidp: I could have done foo x = print x
03:32:59 <squidp> oh okay
03:33:01 <srhb> To name it foo :)
03:33:13 <srhb> :t let foo x = print x in foo
03:33:14 <lambdabot> Show a => a -> IO ()
03:33:16 <srhb> Same thing.
03:33:32 <srhb> The let ... in ... syntax is just to make it an expression.
03:34:14 <liste> @let foo x = print x -- can be a definition too
03:34:15 <lambdabot>  Defined.
03:34:17 <liste> :t foo
03:34:18 <lambdabot> Show a => a -> IO ()
03:34:22 <srhb> Yes, but I don't think you can do
03:34:25 <srhb> :t foo x = print x
03:34:26 <lambdabot> parse error on input ‘=’
03:34:36 <hpc> :t let foo x = print x in foo
03:34:36 <srhb> Right. :)
03:34:37 <lambdabot> Show a => a -> IO ()
03:35:34 <rtb> Gurkenglas: updated the wiki with your lambda paste and ghci session, thx again
03:36:00 <Gurkenglas> ghci session? wut?
03:36:17 <squidp> that is a bit neat how you can restrict function to not so (any?) IO
03:36:23 <squidp> not do
03:36:28 <srhb> squidp: Yep.
03:36:32 <rtb> mine
03:36:37 <maerwald> squidp: well, it is actually the "default" to not have any IO
03:36:43 <rtb> to make things absolutely clear
03:36:50 <srhb> squidp: And it's not general for IO. It's the same restriction as with any other type mismatch.
03:36:57 <srhb> Er, it's not specific to*
03:37:17 <rtb> https://en.wikibooks.org/w/index.php?title=Haskell/Existentially_quantified_types&stable=0#Quantification_as_a_primitive
03:37:21 <maerwald> squidp: so it's not like you opt out, but rather opt in
03:37:33 <squidp> yeah I see
03:37:43 * hackagebot fswatcher 0.1.3 - Watch a file/directory and run a command when it's modified  https://hackage.haskell.org/package/fswatcher-0.1.3 (ErlendHamberg)
03:38:03 <srhb> squidp: And because of this, lambdabot can be safe and not fire missiles if I...
03:38:11 <srhb> > print "OK, maybe an IRC bot shouldn't do IO..."
03:38:12 <lambdabot>  <IO ()>
03:38:18 <hpc> :D
03:38:34 <hpc> what lambdabot does is calls show on what you give it
03:38:35 <hpc> :t show
03:38:36 <lambdabot> Show a => a -> String
03:39:02 <Gurkenglas> duhhhhhhhh so thats why IO is in there and I was looking for the package that defines the instance
03:39:05 <Hafydd> Why did we connect that missile silo to lambdabot's server, again?
03:39:06 <Gurkenglas> @instances Show
03:39:09 <lambdabot> (), (Data.Fixed.Fixed a), (Seq.Seq a), (Seq.ViewL a), (Seq.ViewR a), (Shrink2 a), (a -> b), (a, b), (a, b, c), All, AllocationLimitExceeded, Any, ArithException, Array a b, ArrayException, AssertionFailed, AsyncException, BlockedIndefinitelyOnMVar, BlockedIndefinitelyOnSTM, Bool, CReal, Char, Complex a, Const a b, Constr, ConstrRep, DataRep,
03:39:09 <lambdabot> DataType, Deadlock, DefName, Double, Down a, Dual a, Dynamic, Either a b, ErrorCall, Expr, First a, Fixity, Float, GeneralCategory, IO a, IOException, Identity a, Int, Int16, Int32, Int64, Int8, Integer, Interval a, Large a, Last a, Level i a, Magma i t b a, MaskingState, Maybe a, Natural, NestedAtomically, NoMethodError, NonEmptyList a, NonNegativ
03:39:09 <lambdabot> e a, NonTermination, NonZero a, OrderedList a, Ordering, PatternMatchFail, Positive a, Product a, Ratio a, RecConError, RecSelError, RecUpdError, Shrinking s a, Small a, Smart a, SomeAsyncException, SomeException, StdGen, Sum a, Sym a, Tree a, TyCon, TypeRep, Word, Word16, Word32, Word64, Word8, ZipList a, [a]
03:39:32 <hpc> NonTermination?
03:39:48 <Hafydd> NonTermination is an exception, presumably.
03:39:56 <liste> :t throw
03:39:57 <lambdabot> Exception e => e -> a
03:40:03 <hpc> > throw NonTermination
03:40:04 <lambdabot>  *Exception: <<loop>>
03:40:09 <hpc> aha!
03:40:23 <squidp> > f x = print x + y 
03:40:25 <lambdabot>  <hint>:1:5: parse error on input ‘=’
03:40:43 <liste> squidp use @let for top-level (global) definitions
03:41:01 <liste> or > let ... in ... for one-liner
03:41:04 <srhb> Hafydd: Re: why -- it's obviously important for pedagogical reasons
03:41:17 <srhb> If we didn't have a dangerous ICBM sitting on standby, it wouldn't be very impressive that we can avoid launching it.
03:41:22 <dramforever> squidp: also I want you to learn some proper haskell before trying
03:41:51 <dramforever> squidp: it's up to you, though
03:42:19 <squidp> I think I will. it looks interesting
03:42:25 <liste> haskell.org has a neat "try it"
03:42:31 <liste> for goofing around
03:42:33 <maerwald> @define poo x = print x + y
03:42:34 <lambdabot>  .L.hs:154:19:
03:42:34 <lambdabot>      Couldn't match expected type ‘IO ()’ with actual type ‘Expr’
03:42:34 <lambdabot>      In the second argument of ‘(+)’, namely ‘y’
03:42:40 <maerwald> there you go
03:42:52 <Hafydd> International Conference on Burrito Monads.
03:43:01 <srhb> Hafydd: :)
03:43:14 <maerwald> I prefer dürüm
03:43:22 <liste> so that's why people say ICBM missiles instead of ICBMs :D
03:43:33 <srhb> squidp: you can also privately chat with lambdabot. > expression and :t expression are the most useful features
03:43:48 <hpc> in pm i think you need to use @type though
03:43:52 <hpc> unless that was fixed
03:43:53 <srhb> hpc: Not anymore.
03:44:07 <srhb> Not for a year or so. :)
03:44:16 * hpc can never keep up
03:44:19 <srhb> It IS hard.
03:44:43 <dramforever> :t is more useful than >
03:44:44 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
03:44:48 <dramforever> wtf
03:44:51 <srhb> :P
03:47:44 * hackagebot yaml 0.8.13 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.13 (MichaelSnoyman)
03:48:24 <squidp> reading haskell.org. I like map and filter examples. similar to python but even shorter
03:48:35 <dramforever> =)
03:48:38 <srhb> squidp: Yes, Haskell syntax is very terse.
03:48:54 <dramforever> short like apl
03:49:04 <srhb> Infinitely more readable than APL :P
03:49:11 <dramforever> yes exactly
03:49:13 <hpc> obligatory mention of python's "maybe we get rid of filter and reduce in the next version" red scares
03:49:21 <dramforever> =)
03:49:42 <liste> "there should be only one right way to do it"
03:49:49 <rlewis> hpc and map and lambda
03:49:59 <liste> and I suppose list comps replace at least filter?
03:50:03 <hpc> i wouldn't say haskell is terse though
03:50:12 <liste> or genexps
03:50:14 <srhb> What I mean is there's very little fluff
03:50:23 <dramforever> srhb ++
03:50:24 <hpc> lol, was about to say "i would call it unfluffy"
03:50:33 <hpc> it was in my buffer
03:50:36 <srhb> :)
03:50:47 <srhb> In reality I'm just reading your buffer and pre-empting you to seem cool.
03:50:52 <srhb> Also you should change your password from hunter2.
03:50:59 <hpc> le gasp!
03:51:40 <hpc> mostly what i like about haskell is that after an initial learning curve most of the language looks like what it does
03:52:29 <hpc> (excepting things like the base library sort by augustss which is a tangled mess of perfect optimizations)
03:54:00 <tdammers> at least in Haskell you can *make* things look like what they do
03:55:33 <hpc> it's also to some extent very difficult to make things that behave weirdly
03:55:50 <frerich> hpc: Alas, that 'looks like what it does' thing stops once you look at libraries which set up some DSL so generic and vast that it runs out of descriptive names, and then you end up with lens. :-]
03:55:57 <hpc> it took me quite a bit of thinking to write acme-php
03:56:31 <tdammers> I like `instance Num String where...`
03:56:44 <tdammers> the pi one is also a gem
03:56:46 <squidp> how does map (+1) [1,2,3] work? in elisp there is a function named 1+
03:57:04 <tdammers> :t (+1)
03:57:05 <squidp> but this works with any function?
03:57:06 <lambdabot> Num a => a -> a
03:57:06 <srhb> squidp: It's called an operator section
03:57:23 <tdammers> :t (\x -> x + 1)
03:57:24 <lambdabot> Num a => a -> a
03:57:24 <dramforever> (+1) desugars to (\x -> x + 1), iirc
03:57:34 <tdammers> yes, it does
03:57:44 <srhb> squidp: By enclosing an infix function (which symbol names always are) in paranthesis with an argument to one side, you're providing that argument and returning a function that takes the _other_ one
03:58:00 <squidp> > map (10+) [1,2,3]
03:58:01 <lambdabot>  [11,12,13]
03:58:07 <srhb> ie. (/2) is divide by two, (2/) is divide two by
03:58:13 <dramforever> > map (10 -) [1,2,3] -- more obvious
03:58:14 <lambdabot>  [9,8,7]
03:58:17 <dramforever> > map (- 10) [1,2,3]
03:58:18 <lambdabot>      Could not deduce (Num a0)
03:58:18 <lambdabot>      from the context (Num a, Num (a -> b))
03:58:18 <lambdabot>        bound by the inferred type for ‘e_110123’:
03:58:22 <dramforever> ouch
03:58:33 <merijn> dramforever: Minus is always a bad example for this :p
03:58:36 <dramforever> that's a special case, (- 10) means that
03:58:37 <srhb> Yeah, negative literals kinda suck. :P
03:58:40 <dramforever> that number
03:58:40 <hpc> tdammers: you should look at the PRs i got too - https://github.com/headprogrammingczar/php-haskell-prelude/pull/1 - https://github.com/headprogrammingczar/php-haskell-prelude/issues/2
03:58:42 <liste> there's subtract and divide functions
03:58:45 <dramforever> yes negative literal
03:58:51 <liste> negate*
03:59:01 <srhb> :t minus 2
03:59:03 <lambdabot> Not in scope: ‘minus’
03:59:05 <srhb> Aw
03:59:06 <srhb> :t subtract 2
03:59:08 <lambdabot> Num a => a -> a
03:59:10 <srhb> Right.
03:59:40 <srhb> I have to run and celebrate Pride. Have fun learning :)
03:59:53 <liste> srhb have fun!
04:00:15 <tdammers> hpc: awesome
04:00:19 <liste> you can even leave both sides of the operator out!
04:00:21 <liste> :t (+)
04:00:23 <lambdabot> Num a => a -> a -> a
04:00:23 <tdammers> hpc: also, good to learn what "hpc" stands for
04:01:11 <merijn> tdammers: High performance computing? :p
04:01:27 <hpc> haskell program coverage?
04:01:51 <hpc> habanero potato crisps!
04:01:54 <liste> Highly Politically Correct
04:02:11 <q`> it must stand for hpc programs computers
04:02:17 <tdammers> highly paid consultants
04:02:31 <frerich> honored php comrade
04:02:42 <q`> haskell php C
04:02:50 <squidp> > filter (<17) map (2^) [0,1,2,3,4,5,6]
04:02:51 <Intolerable> q`: the holy trinity
04:02:51 <lambdabot>      Couldn't match expected type ‘(Integer -> Integer)
04:02:51 <lambdabot>                                    -> [Integer] -> t’
04:02:51 <lambdabot>                  with actual type ‘[Integer]’
04:03:09 <q`> squidp: you are not applying functions the right way
04:03:11 <liste> squidp you need parens or $'s
04:03:11 <Intolerable> > filter (<17) $ map (2^) [0,1,2,3,4,5,6]
04:03:13 <lambdabot>  [1,2,4,8,16]
04:03:23 <q`> > filter (< 17) (map (2^) [0,1,2,3,4,5,6])
04:03:24 <squidp> yeah I dont know what I am doing
04:03:25 <lambdabot>  [1,2,4,8,16]
04:03:27 <hpc> Intolerable: for a moment i thought "the holy trinity" was part of lambdabot's output
04:03:30 <q`> squidp: don't worry
04:03:33 <q`> hpc ++
04:03:40 <tdammers> > filter (<17) . map (2^) $ [0,1,2,3,4,5,6] -- would be more idiomatic
04:03:41 <lambdabot>  [1,2,4,8,16]
04:04:03 <q`> squidp: see, haskell is flexible and safe
04:04:14 <hpc> > filter (<17) . map (2^) $ [0 ..] -- even more idiomatic
04:04:18 <lambdabot>  mueval-core: Time limit exceeded
04:04:20 <hpc> oh whoops
04:04:24 <rlewis> haha
04:04:25 <liste> the other way
04:04:26 * hpc slinks away
04:04:30 <squidp> I like the syntax
04:04:31 <q`> > takeWhile (< 17) . map (2^) $ [0..]
04:04:33 <lambdabot>  [1,2,4,8,16]
04:04:38 <tdammers> tee hee
04:04:39 <q`> squidp: =)
04:04:47 <tdammers> there goes "safe"
04:04:53 <q`> ok
04:04:57 <q`> sigh
04:06:04 <rlewis> > map (2^) [0..]
04:06:05 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
04:06:48 <rlewis> ^ infinite list of power of twos
04:07:18 <Intolerable> > iterate (*2) 1
04:07:19 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
04:07:29 <q`> possibly faster
04:07:35 <q`> oh surely faster
04:07:40 <Intolerable> and golfier
04:07:51 <Intolerable> maybe
04:07:53 <q`> > iterate (`shiftL` 1) 1
04:07:54 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
04:07:58 <Intolerable> actually is it tho
04:08:01 <q`> maybe fastest
04:08:15 <pentfloret> Hey, I was profiling a program I did which received 10^5 lines of input, and each was a number. So, I had used read, and noticed that it was quite slow compared to a foldl alternative. Why is that so?
04:08:29 <Intolerable> read is really slow
04:08:31 <q`> read is slow
04:08:38 <q`> although I don't know why
04:08:52 <pentfloret> At least now I know it wasn't just me then :P
04:09:02 <Intolerable> are you just reading numbers?
04:09:06 <saep> Show and Read are useful for debugging and small things
04:09:06 <rlewis> read compared to your own int parser implemented with foldl?
04:09:23 <Intolerable> @hoogle readInt
04:09:23 <lambdabot> Numeric readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
04:09:24 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
04:09:24 <lambdabot> Data.ByteString.Lazy.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
04:09:35 <hpc> there's numeric parsers in the various *parsec packages, i believe
04:09:58 <pentfloret> Yes, just numbers. So, readInt is a faster alternative when it's just numbers?
04:10:15 <Intolerable> well i mean if its integers
04:10:27 <Intolerable> either use [atto]parsec or readInt
04:10:52 <Intolerable> String is slow, read is slow, neither are ideal if you need performance
04:10:56 <squidp> thanks everyone for explanations and examples! I need to run
04:11:04 <q`> =)
04:11:22 <pentfloret> I will give it a try then! :D 
04:11:47 <squidp> > map (+1) "axd"
04:11:48 <lambdabot>      No instance for (Num Char) arising from a use of ‘+’
04:11:48 <lambdabot>      In the first argument of ‘map’, namely ‘(+ 1)’
04:11:48 <lambdabot>      In the expression: map (+ 1) "axd"
04:12:03 <Intolerable> > map succ "axd"
04:12:05 <lambdabot>  "bye"
04:12:06 <squidp> ah I thought I had it :/
04:12:09 <Intolerable> :)
04:12:15 <squidp> thanks :)
04:12:31 <q`> > map ord "axd"
04:12:33 <lambdabot>  [97,120,100]
04:12:45 * hackagebot yesod-bin 1.4.13.3 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.4.13.3 (MichaelSnoyman)
04:12:47 * hackagebot yesod-core 1.4.13 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.13 (MichaelSnoyman)
04:12:49 <q`> oh that was a funny way to say goodbye =)
04:17:04 <rlewis> > map (+1) "axd"
04:17:06 <lambdabot>  "bye"
04:17:37 <q`> hey what did you do to lambdabot?
04:17:47 <rlewis> secret :P
04:17:57 <rlewis> > 'a' + 1
04:17:58 <Intolerable> instance Num Char?
04:17:58 <lambdabot>  'b'
04:18:02 <Gurkenglas> probably defined a num instance using lpaste
04:18:17 <Intolerable> > 'a' * 2
04:18:19 <lambdabot>  '\194'
04:18:27 <rlewis> > 'a' + 'b'
04:18:29 <lambdabot>  '\195'
04:18:47 <Intolerable> > 1 :: Char
04:18:48 <lambdabot>  '\SOH'
04:19:17 <Intolerable> > [0..100] :: String
04:19:18 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
04:20:17 <Gurkenglas> I wish there was [..] = [minbound..maxbound]
04:20:40 <rlewis> I did it inline
04:20:51 <rlewis> @let instance Num Char where; x + y = chr (ord x + ord y); x - y = chr (ord x - ord y); x * y = chr (ord x * ord y); abs = id; signum x = chr (signum (ord x)); fromInteger = chr . fromIntegral
04:20:51 <lambdabot>  .L.hs:150:10:
04:20:52 <lambdabot>      Duplicate instance declarations:
04:20:52 <lambdabot>        instance [safe] Num Char -- Defined at .L.hs:150:10
04:20:55 <hpc> > [..] -- i wonder how it fails to parse
04:20:57 <lambdabot>  <hint>:1:2: parse error on input ‘..’
04:21:02 <hpc> ah, boring
04:21:06 <hpc> Gurkenglas: it might be possible!
04:21:21 <q`> @undefine -- no you are not supposed to do that
04:21:21 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
04:21:28 <Dark_cloud_> it will be great if      anyone help can anyone tell me where do find programming problems to solve 
04:21:31 <q`> sigh...now the joke is on me
04:21:58 <Gurkenglas> Dark_cloud_, Project Euler, codewars, CodinGame
04:22:01 <lf94> Does anyone have a list of Haskell conventions that can be used to create any program?
04:22:07 <lf94> So like
04:22:39 <Gurkenglas> lf94, https://wiki.haskell.org/Programming_guidelines ?
04:22:40 <Dark_cloud_> much thanks Gurkenglas
04:22:45 <lf94> Instead of having to know a million concepts, we can tell people "you only need to learn this to create an haskell program"
04:22:57 <lf94> I'm having a hard time expressing what I mean
04:23:02 * lf94 click
04:23:03 <hpc> lf94: as in, a reduced set of haskell that's still turing-complete?
04:23:11 <lf94> hpc: Yeah :)
04:23:25 <lf94> Gurkenglas, nah not that
04:23:31 <q`> it's hard to do given how haskell is currently designed
04:23:48 <hpc> lf94: you get to that point pretty early in learning, but there's a variety of subsets that can do it
04:23:52 <lf94> Is there another pure functional language that does allow that?
04:24:01 <hpc> lf94: some more usable than others, none more usable than just learning the language
04:24:16 <hpc> lf94: so ultimately we don't really bother thinking about it
04:24:30 <lf94> hpc: Well yeah. It's more of a thing to encourage others to start using it.
04:24:47 <hpc> for the most part, if you don't understand something, don't use it
04:24:59 <hpc> and you can usually do fine
04:25:04 <lf94> But what if you think you absolutely need it?
04:25:08 <hpc> then learn it ;)
04:25:09 <lf94> I'm fine
04:25:22 <lf94> I know Haskell to a certain extent - I'm just saying if I want to teach someone else
04:25:28 <lf94> We could focus on a subset
04:26:00 <lf94> Like, recursion via pattern is one way to iterate through lists
04:26:05 <lf94> pattern matching*
04:26:10 <lf94> pattern matching actually covers a lot
04:26:34 <lf94> Using IO () monad could be difficult to teach
04:26:46 <hpc> IO isn't that hard
04:27:04 <lf94> No it isn't...but to someone who's completely new to Haskell...
04:27:17 <lf94> A lot of programmers are used to use IO elsewhere in their programs
04:27:30 <lf94> That's where the trouble comes in
04:27:49 <lf94> But Monad Transformers might give them more confusion
04:28:05 <lf94> (Personally I got Monad Transformers straight away)
04:28:13 <q`> oh?
04:28:18 <q`> hmm...
04:28:37 <lf94> To a new programmer I just think it's too much and I'd probably teach them "Monads as a design pattern"
04:28:41 <lf94> And then focus on the details later
04:28:48 <lf94> That monads actually offer bind and return
04:29:04 <lf94> So you can link statements together
04:29:08 <q`> design pattern is a bad thing because of the name
04:29:19 <q`> and some people who used the name
04:29:27 <lf94> What's your idea of a design pattern
04:29:30 <q`> so it kinda has a bad reputation
04:29:30 <lf94> What's wrong with it
04:29:41 <lf94> There are design, architectural, concurrent patterns
04:29:44 <q`> lf94: ever heard of the gang of four?
04:29:45 <lf94> a few more
04:29:45 <keko_> I could totally see being a Java coder at some company and sneakily telling everyone about the "Monad design pattern" :)
04:29:49 <lf94> q` yes lol
04:30:01 <lf94> hehe
04:30:03 <keko_> in a "you gotta speak their language" way
04:30:05 <lf94> Yeah I can imagine that too
04:30:07 <q`> that's the problem, these people's patterns caused problems
04:30:17 <lf94> keko_ it really helps to see it that way though!
04:30:40 <lf94> q` what do you mean...a pattern is a common solution to a problem
04:31:00 <q`> I mean, design patterns have a bad reputation somehow
04:31:08 <lf94> that's news to me
04:31:21 <q`> I don't know the details
04:31:52 <lf94> It took me awhile to really "get" Haskell because I was approaching it from the wrong angles
04:31:53 <cow_2001> Turtle is sweet.
04:31:57 <lf94> I really wish I took a course
04:31:57 <rlewis> you can get pretty far in using IO without knowing monads beyond the do syntax
04:32:14 <lf94> Anyways, after reading about category theory and how the concepts relate to haskell a lot of shit started making sense
04:32:23 <q`> lf94 ++
04:32:48 <lf94> The type system too is a burden at first
04:32:52 <lf94> There are just so many types
04:33:03 <lf94> "Do I use Int? Integer? Ratio? Rational? Decimal?"
04:33:04 <q`> that burden is worth it
04:33:15 <q`> lf94: use the numerical type classes
04:33:16 <lf94> Like I've been using Haskell on and off for a year
04:33:28 <lf94> and I'm only using it for toy programs now
04:33:34 <lf94> But at least I can write them in a reasonable time now
04:33:40 <lf94> Like, an hour
04:33:48 <hpc> fun fact: the burden of picking which type is appropriate still exists just as heavily in other languages
04:34:00 <hpc> but most options are hidden from you by the cloak of "not implemented in a module"
04:34:02 <lf94> q`: I know it's just an example :)
04:34:15 <lf94> hpc: ehhhh
04:34:29 <q`> yes but typeclasses are really nice
04:34:43 <q`> hpc: or duck typing
04:34:44 <hpc> a situation where Ratio would be appropriate in haskell, a similar type would be appropriate in any other language as well
04:34:50 <q`> whatever the type, I don't care
04:35:00 <q`> which creates problems
04:35:07 <lf94> Yeah you realize it's all great once you start to compare REAL programs you write in Haskell with the REAL programs you've written in other languages.
04:35:17 <lf94> I program I write in Haskell 95% of the time works first run.
04:35:45 <lf94> Python, C, or some other language I usually have to tinker a bit because I've forgotten something SO silly.
04:36:10 <lf94> Maybe it's the lack of discipline. I don't know.
04:36:19 <hpc> it's probably that
04:36:42 <hpc> haskell's general strictness (hehe) makes tiny errors become extremely visible
04:37:04 <hpc> eventually you get used to having it around and end up with a different type of lack of discipline
04:37:06 <lf94> Which is fantastic, because those are the errors that gets nearly anyone and everyone.
04:37:19 <tdammers> a language that requires discipline to get basic functionality right is stupid
04:37:35 <lf94> Like extremely discipline
04:37:36 <hpc> then you go back to a language like python and learn to do the disciplining in your own mind, which is when you start building lasting good habits as a programmer
04:37:42 <maerwald> I had more trouble with logical errors in haskell than in other languages when writing non-trivial algorithms, but less with memory or state.
04:38:10 <lf94> I have to deal with PHP, JavaScript, Python and C code regularly. There is not enough discipline to go around :(
04:38:13 <tdammers> fwiw, going to clojure from haskell is a frustrating experience
04:38:26 <q`> going back is no less so
04:38:44 <tdammers> at least Python and JS don't have a powerful metalanguage that you have to keep in check along with the already-abundant opportunities for foot-shooting
04:38:47 <q`> s/back/the other way/ -- generalize
04:39:04 <zomg> lf94: you'll spot many silly things if you run your dynamic lang stuff through a competent linter :) but obviously not as much as you'd get with ghc
04:39:22 <tdammers> idk, haskell just resonates very well with how I like to think
04:39:36 <lf94> zomg: I've begun doing that with JS...heh.
04:39:42 <skore_de> as still-mostly-a PHP dev, php-haskell-prelude makes me laugh and cry at the same time
04:40:03 <lf94> Lol what? PHP-Haskell prelude. What the heck is that?
04:40:12 <skore_de> https://github.com/headprogrammingczar/php-haskell-prelude
04:40:18 <Intolerable> @hackage acme-php
04:40:18 <lambdabot> http://hackage.haskell.org/package/acme-php
04:40:31 <lf94> This is satire
04:40:42 <lf94> Why is the README.md blank, where are the examples!
04:40:52 <Intolerable> https://hackage.haskell.org/package/acme-php-0.0.2/docs/src/Prelude-PHP.html
04:40:55 <skore_de> I know but, I mean... when you deal with it on a daily basis the stuff just fades to the background, but comparing it with directly with Haskell is a bag full of kicks to the nuts
04:41:34 <skore_de> deal with *PHP, I mean
04:41:45 <Intolerable> data Bool = TRUE | FALSE | FILE_NOT_FOUND is really the highlight
04:41:49 <skore_de> yeah :D
04:42:06 <skore_de> I'm usually doing a pretty good job not to get sucked into the "self loathing web developer" trope
04:42:10 <lamefun> Does PHP even have FILE_NOT_FOUND as bool?
04:42:13 <skore_de> but still, damn, seeing it spelled out like that...
04:42:21 <tdammers> lamefun: no
04:42:37 <zomg> iirc that bool thing is from The Daily WTF
04:42:38 <skore_de> but it DOES have tons of weird type conversions
04:42:40 <lf94> I still don't get this package it's just a bunch of standardish things crammed into 1 file
04:42:50 <tdammers> lf94: it's satire
04:42:56 <skore_de> (13:40:09) lf94: This is satire
04:42:58 <lf94> Yeah ok I asked that before lol
04:42:59 <skore_de> we've gone full circle :D
04:43:02 <lf94> B)
04:43:07 * lf94 slaps self with trout
04:43:11 <tdammers> lf94: it imitates a bunch of PHP-like broken functionality in Haskell
04:43:20 <tdammers> such as allowing addition of strings
04:43:56 <skore_de> 9 years of programming in PHP and I still cannot remember where needle and haystack are in some functions...
04:43:57 <lf94> Hahah, what WOULD this do?
04:43:58 <lf94> (+) x y = show (intval x + intval y)
04:43:58 <Maxdamantus> Num String
04:44:05 <lf94> x is [Char] right?
04:44:14 <lf94> intval on a [Char] what the flip would happen
04:44:55 <skore_de> https://wiki.theory.org/YourLanguageSucks#PHP_sucks_because
04:44:57 <lf94> skore_de, for me, it's the 4 different ways to split an array/string between PHP, C, Python, and JavaScript 
04:45:38 <skore_de> lf94 - again, happy tears of despair...
04:45:46 <lf94> I can't wait until everything is programmed with Haskell or a language that is strictly typed
04:45:52 <lf94> Just one language to rule them all
04:46:04 <lf94> We can sweep this crap under the rug
04:46:07 <skore_de> obligatory https://xkcd.com/927/
04:46:15 <lf94> heh
04:46:26 <tdammers> my hate for PHP is holistic
04:46:27 <skore_de> I'm just trying to switch to Haskell to maintain sanity, that's all
04:46:38 <lamefun> Is there a real PHP-like library in Haskell?
04:46:38 <liste> USDoD mandated that everything would be developed in Ada
04:46:42 <liste> at one point
04:46:46 <lf94> I seriously just want to focus on one language
04:46:59 <maerwald> skore_de: the problem is... if it's just you who switches. What about the rest of your working envrionment? ;)
04:47:07 <skore_de> I don't hate it and I think it's dangerous to fall into that trope, as mentioned above. But I'm... I guess I'm /over it/
04:47:09 <tdammers> lf94: one language for all sounds like a terrible terrible idea
04:47:25 <lf94> tdammers: that's what DSLs (written in Haskell!) are for...hehehe
04:47:34 <tdammers> lf94: not buying it
04:47:35 <skore_de> @maerwald well, that's the neat part - this is for my own business, while I still have a job on the side for PHP stuff
04:47:35 <lambdabot> Unknown command, try @list
04:47:47 <skore_de> woops ;)
04:47:59 <lf94> tdammers, for $99.99 monthly fee will you buy our Haskell Embedded Premium today?
04:48:09 <tdammers> lf94: sure, where do I sign up
04:48:11 <tdammers> :P
04:48:18 <Intolerable> its enterprise-ready
04:48:21 <Intolerable> ™
04:48:24 <skore_de> I had the plan to implement something "more clean" in PHP, kept searching and searching, ended up realizing I actually wanted to do FP
04:48:39 <lf94> Just sign your soul at the bo- just write your name here and here and we'll send it in the mail.
04:48:56 <skore_de> and that far beyond the casual hate that PHP gets, it really bites you in the "managing complexity over a long period of time" area
04:49:13 <lf94> Are there Haskell programs written in 1998 that run unmodified today
04:49:20 <lf94> I'd like to see that
04:49:27 <skore_de> and only after 9 years of doing it do I feel confident enough to just state that as a fact ;)
04:49:35 <tdammers> skore_de: yes, that's my holistic gripe pretty much exactly
04:49:42 <liste> what did Haskell look like in -98 :D
04:49:56 <lf94> yeah lets see some '98 haskell programs
04:50:01 <skore_de> tdammers - I will probably continue to do PHP on the side for a few years, heck, it's a great way to feed the family
04:50:09 <lf94> Yeah PHP pays well
04:50:10 <liste> I suppose you could dive into GHC's SCM
04:50:12 <q`> main = putStrLn "Hello World"
04:50:16 <tdammers> all the symptoms can be worked around, but no matter in which direction you go in order to manage the complexity, you always run into a situation where you can't go on for idiotic reasons
04:50:41 <skore_de> I spent 6 hours making asset management work at the PHP job the other day
04:50:44 <skore_de> 6 hours!
04:50:52 <q`> things haven't and have changed a lot since 1998
04:50:54 <tdammers> I wrote a parser-combinator in PHP, but pretty soon the recursion limit and the extremely costly function calls pretty much made that approach a no-go
04:51:11 <skore_de> just so that it would generate sane paths - and it still ended up as a hack solution that works in all cases because it behaves terribly in half of them
04:51:30 <skore_de> https://github.com/mathiasverraes/lambdalicious ;)
04:51:39 <tdammers> it's as if PHP actively tried to prevent people from doing things correctly
04:51:51 <skore_de> aye
04:51:56 <frerich> I always only used PHP for glue between JavaScript, HTML and some sort of backend (e.g. a page with sales statistics where PHP merely queries via SQL and then generates JavaScript tables consumed by the JS flot library). It actually worked well for that.
04:52:06 <Maxdamantus> Writing a parser combinator is also difficult in Go :(
04:52:20 <skore_de> frerich: it's actually pretty neat for that and as I said above - I will continue to use it for a while
04:52:27 <skore_de> at some point, you only use it for shovelling data around
04:52:28 <tdammers> Maxdamantus: Go feels like PHP redone with the knowledge gathered so far
04:52:29 <Gurkenglas> https://www.reddit.com/r/haskellquestions/comments/3gu8tt/writing_a_conjecture_generator/
04:52:32 <skore_de> and it's alright for that
04:52:33 <lf94> typescript/flowtype on node.js is starting to look good.
04:52:59 <lf94> At least there is strict typing there now
04:53:00 <tdammers> skore_de: many things are good enough for shoveling data around
04:53:06 <skore_de> for javascript, I STILL cannot decide between angular and react... but angular has earned some points moving to typescript, recently
04:53:08 <lf94> (well, stricter than nothing before hahaha)
04:53:32 <lf94> skore_de, I really love react.
04:53:42 <q`> Gurkenglas: weird but interesting thing =)
04:53:43 <lf94> But that's all I can really say because I haven't looked at Angular
04:53:43 <tdammers> for javascript, I'm torn between assembling a collection of libraries to make it manageable, clojurescript, one of the haskell-to-js compilers, and elm
04:53:47 <skore_de> tdammers: exactly, for that it hardly matters, but I have clients who are simply stuck on php, so I need some framework to make their websites viable nodes in the sort of infrastructure I have in mind ;)
04:54:01 <tdammers> "stuck on PHP" is a red flag
04:54:03 <q`> stuck on php
04:54:06 <tdammers> or can be
04:54:16 <skore_de> lf94 - definitely check out angular 2, where they've redone the whole thing, instead of earlier versions ;)
04:54:29 <q`> skore_de: they have old code and want you to support?
04:54:32 <skore_de> "stuck on PHP" - we're talking about "people who just run a small business on a website", not developers
04:54:33 <lf94> skore_de, I've heard people bitching about that version though!...lol
04:54:54 <lf94> skore_de, I'm in the same PHP bandwagon.
04:54:54 <q`> skore_de: oh small business...that makes some sense
04:54:59 <frerich> To be fair, I think this has been somewhat offtopic for a while now. Maybe move it to #haskell-blah
04:55:03 <skore_de> q` - yup, they have an old PHP CMS that runs a component I built
04:55:07 <skore_de> ecommerce stuff
04:55:11 <lf94> Guy made his site with a mix of PHP (he wasn't a programmer), and now I have to manage it
04:55:12 <Maxdamantus> Here's my Go parser combinator library, in case anyone's interested: https://gist.github.com/Maxdamantus/9184ff4b72017a8de0cc
04:55:15 <q`> ok now it's not too weird
04:55:25 <Maxdamantus> You have to use `interface {}` a lot.
04:55:27 <tdammers> more often than not, it means "we want to stay with this shitty shared hosting plan because spending $100/mo in programmer salaries to save $10/mo for hosting sounds like a great deal to us"
04:55:29 <skore_de> frerich: sorry, should I move this over to -blah?
04:55:37 <lf94> I slowly migrating it to a CMS (Kirby, it's great), but god there is so much interference with the rest of the components in the site.
04:55:49 <tdammers> skore_de: I think this has been #-blah territory for quite a while
04:55:58 <frerich> skore_de: I think that would be appropriate.
04:56:08 <catofhask> Hi what are consequences of using TMVar?
04:56:15 <skore_de> sorry, did not know about -blah before ;) moving there
04:56:25 <lf94> haskell-blah?
04:56:28 <tdammers> yes
04:56:41 <q`> catofhask: software transactional locks?
04:57:18 <q`> anyway I would expect it to be easy to implement given TVar's
04:57:19 <catofhask> I currently have an IO Channel, I want to replace it with TChan Queue, but I need Mvars to communicate between threads
04:57:48 <q`> why you need MVars to communicate?
04:58:07 <q`> can you, say, stick to stm?
04:58:30 <Intolerable> @hoogle TMVar
04:58:31 <lambdabot> Control.Concurrent.STM.TMVar module Control.Concurrent.STM.TMVar
04:58:31 <lambdabot> Control.Concurrent.STM.TMVar data TMVar a
04:58:31 <lambdabot> Control.Concurrent.MVar putMVar :: MVar a -> a -> IO ()
04:58:54 <catofhask> q`: So I have a database thread, and one app thread. App thread puts ooperation in channel with MVar to get notified whenever that op completes
04:59:06 <Intolerable> you can STM for that
04:59:09 <q`> sorry I gotta run
04:59:26 <Gurkenglas> Hmm. Maybe I could automate a ghci session, start with all names whose type signature has Bool at the end, apply each name that doesn't result in a type error, and repeat until only a Bool remains, at which point I evaluate it and print it if it True?
04:59:57 <Intolerable> catofhask: i've gotta go for a bit too
05:00:08 <catofhask> Intolerable: :) sure.
05:00:13 <Intolerable> if you're still having trouble when im back (30mins probably) i can give you a hand
05:00:35 <catofhask> yeah probably, I am bit in dilemma 
05:00:46 <Gurkenglas> What library allows me to interact with a ghci session?
05:02:02 <boj> do cloud haskell clients have to be written in haskell using Network.Transport.*? i tried the echoSever using telnet no no effect, however, a custom server/client in CH works fine
05:03:57 <frerich> Gurkenglas: Does it need to be a library? Automating a REPL session is something the standard 'expect' tool might be useful for.
05:07:15 <Dark_cloud_> .clear
05:08:02 <Gurkenglas> Huh, I don't need "interact with ghci", just "interface with another program's stdin and stdout". I'll try https://hackage.haskell.org/package/libexpect-0.3.0/docs/System-Expect-ExpectInterface.html , thanks
05:14:35 <anohigisavay> hi. is it possible to include a c source dir in cabal file?
05:14:49 <anohigisavay> there's only a c-sources option afaik
05:14:50 <lamefun> http://hackage.haskell.org/package/regex-tdfa-text - "This should be part of regex-tdfa package. But my patches are not accepted yet." - so regex-tdfa is stagnated?
05:15:33 <anohigisavay> and i have to list all c source files 
05:15:49 <lamefun> Are regexes unidiomatic / frowned upon in Haskell?
05:17:42 <peddie> lamefun: I think people tend to build full-blown parsers instead, 'cause parsec and co. are so pleasant to use
05:17:48 * hackagebot ListTree 0.2.2 - Trees and monadic trees expressed as monadic lists where the underlying monad is a list  https://hackage.haskell.org/package/ListTree-0.2.2 (YairChuchem)
05:18:43 <mbrock> there's also Roman's `regex-applicative` library that's kind of like a regular subset of parsec & co
05:19:17 <rlewis> personally I only use regex if I want to use user-provided regex strings
05:21:40 <mbrock> applicative regex examples: https://github.com/feuerbach/regex-applicative/wiki/Examples -- i think it's quite nice when you want to match some regular language and don't need the power of full parser combinators
05:24:25 <tdammers> another advantage of parser combinators like parsec is that they aren't restricted to String -> String
05:24:52 <tdammers> usually we want typed results, not list-of-strings or hashmap-of-names-to-strings
05:25:10 <tdammers> but regular expressions can't do anything else
05:28:46 <Fay> does Parsec use RE's?
05:30:51 <Intolerable> no
05:32:38 <Fay> oh okay :)
05:33:29 <Dark_cloud_> can some help me with linux command plz
05:34:58 <tdammers> Fay: parsec cannot possibly use regular expressions, because it is polymorphic in its token type
05:35:31 <tdammers> you can write parsec parsers that consume lists of rationals, if you want
05:36:37 <Fay> tdammers: oh cool. I havent read the parsec code yet 
05:36:45 <Fay> Dark_cloud_: what command
05:36:57 <tero> how can I get a from Ptr a?
05:37:06 <lamefun> in Parsec, can I use a parser, ignore the result and get the text instead?
05:37:54 <Intolerable> @hoogle match
05:37:55 <lambdabot> Language.Haskell.TH.Lib match :: PatQ -> BodyQ -> [DecQ] -> MatchQ
05:37:55 <lambdabot> Language.Haskell.TH match :: PatQ -> BodyQ -> [DecQ] -> MatchQ
05:37:55 <lambdabot> Data.Graph.Inductive.Graph match :: Graph gr => Node -> gr a b -> Decomp gr a b
05:37:59 <Intolerable> er
05:38:44 <quchen2> tero: peek :: Ptr a -> IO a
05:38:55 <lamefun> or simply get both the result and the text, eg. decon :: Stream s m t -> ParsecT s u m a -> ParsecT ([t], a)?
05:39:05 <Intolerable> parsec: no
05:39:10 <Intolerable> attoparsec yes
05:39:13 <Intolerable> (unfortunately)
05:39:32 <tero> quchen2: I was looking at Foreign.Ptr hackage page and there Storable a has function peek :: Ptr (Ptr a) -> IO (Ptr a)
05:39:40 <kqr> I'm using using Database.SQLite.Simple and I'd like to do something like    query db "select * where name like '%?%'" (Only "een")... how can I accomplish this? (when it tries to interpolate a string it wants to add quotes which behaves weirdly inside the string that's already there)
05:39:56 <Intolerable> tero: that's because it's specialized for the typeclass
05:40:03 <tero> Intolerable: ok
05:40:05 <Intolerable> and a Ptr is Storable
05:40:18 <Intolerable> the actual type of peek is Storable a => Ptr a -> IO a
05:40:19 <Intolerable> or something
05:40:28 <Intolerable> :t peek
05:40:29 <lambdabot> Not in scope: ‘peek’
05:40:47 <eikke> peek :: Storable a => Ptr a -> IO a
05:43:11 <tero> No instance for (Storable SDL.Surface) arising from a use of ‘peek’. eh but it's defined...
05:43:39 <Intolerable> catofhask: did you get your STM stuff working?
06:03:58 <kqr> never mind my sqlite question – internet suggests appending the %:s to the string being searched for. seems reasonable
06:10:21 <merijn> Fay: The parsec code is a little messy, tbh. It predates a lot of the ecosystem
06:10:48 <merijn> Fay: For example, Parsec predates the existence of Applicative and Alternative and thus has it's own versions of the operators from those
06:11:52 <Franciman> Hi all
06:11:56 <merijn> tdammers: You could use regular expressions despite a polymorphic token type, btw
06:12:15 <Franciman> Is there any new cool library for parsing out there?
06:12:17 <tdammers> merijn: I don't know of any regex impl that does that though
06:12:34 <merijn> Franciman: Depends on what you're looking for?
06:13:15 <Franciman> merijn, parser combinators
06:13:46 <phadej> tdammers: regex-applicative
06:14:07 <merijn> Franciman: Not really, Parsec if you want featureful/decent error reporting, attoparsec if you want fast, trifecta if you wanna spend hours trying to figure out from the docs how to use it ;)
06:14:08 <tdammers> phadej: hum, and outside of haskell?
06:14:18 <merijn> Franciman: Trifecta has pretty good error reporting, supposedly
06:14:22 <Franciman> ahah
06:14:48 <phadej> tdammers: outside haskell polymorphic types is quite rare :)
06:14:51 <tdammers> trifecta is from edwardk, which probably means it is perfect, but in a way that it takes us mere mortals years of diligent study to understand it
06:15:03 <tdammers> phadej: polymorphic functions aren't though
06:15:07 <Franciman> ahahahah
06:15:18 <Franciman> I'll give a look at them, thanks
06:15:37 <merijn> Franciman: FYI, attoparsec is essentially identical to Parsec in interface/use
06:15:57 <Fay> merijn: oh 
06:16:04 <merijn> Franciman: The Real World Haskell chapter on Parsec is a good intro
06:16:17 <merijn> Franciman: Most of the examples have bitrotted a little, but the high-level overview is still good
06:16:20 <tdammers> but be sure to read over the current documentation too
06:16:29 <Franciman> Yep, I've read it. I was already aware of Parsec, I was just looking for something different
06:16:30 <tdammers> so many useful combinators
06:16:40 <merijn> Fay: Although, to be fair, Applicative was, surprisingly, not invented until like 2004
06:16:49 <phadej> tdammers: yes, c++ had templates for quite long, but doesn't have adt:s. It's quite painful to do free encodings there
06:17:04 <Franciman> also, would you advice against using a lexer with parsec? Or don't you?
06:17:07 <aweinstock> is it possible to get the database of quotes that lambdabot uses for @quote?
06:17:09 <merijn> Franciman: attoparsec is basically the same, but with more primitives for efficient parsing of Text/ByteString for stuff like network protocols
06:17:26 <phadej> attoparsec is also backtracking, parsec isn't
06:17:37 <Fay> merijn: im not surprised by that, applicative seems like something that requires a strong ecosystem around it 
06:17:51 * hackagebot yesod-routes-flow 1.0.1 - Generate Flow routes for Yesod  https://hackage.haskell.org/package/yesod-routes-flow-1.0.1 (FelipeLessa)
06:17:55 <merijn> Franciman: Like "takeWhile :: (Word8 -> Bool) -> Parser ByteString" which efficiently blits a range of bytes into a new ByteString
06:18:08 <merijn> Fay: Not really, you don't really need anything except Functor?
06:18:10 <Franciman> oh cool
06:18:37 <Fay> merijn: oh wow.  sorry im new to haskell.  
06:18:55 <merijn> Franciman: Check out this: http://www.serpentine.com/blog/2010/03/03/whats-in-a-parser-attoparsec-rewired-2/
06:19:07 <merijn> Franciman: attoparsec vs hand-optimised HTTP parser :)
06:19:19 <Franciman> thanks again :P
06:19:33 <Franciman> but you said it had a bit poor error reporting?
06:20:12 <Franciman> btw, wow
06:20:15 <merijn> Franciman: Certainly poorer than attoparsec, yeah. But if you're using it for, for example parsing files/network protocols you might not care (as opposed to parsing programming languages)
06:20:22 <merijn> eh, poorer than parsec, I mean
06:20:36 <merijn> For network protocols you only really care about "yes it parses" or "no, it doesn't"
06:20:50 <merijn> Not so much about "the parse error is on line 5, column 10 in the word "let""
06:21:03 <Franciman> I'm using it for Programming Langs
06:21:30 <Franciman> btw impressive performances
06:21:43 <merijn> Franciman: Ok, than maybe try Parsec/Trifecta instead
06:21:55 <merijn> Franciman: For programming languages you don't care *that* much about parsing time anyway
06:22:04 <Franciman> I've given a little sneak peak at trifecta and: Aw my god, what's that :P
06:22:04 <tdammers> yeah, for source code, you want all the error reporting you can get
06:22:09 <Franciman> merijn, yep
06:22:32 <merijn> Franciman: GHC for example reparses files, someone wanted to optimise that. Until it was pointed out that parsing is like <0.5% of the time GHC takes to compile something :p
06:22:42 <Franciman> indeed
06:22:52 <Franciman> most of the time is spent on analysis and optimisation
06:22:56 <merijn> Franciman: Also check out parsers
06:22:59 <maerwald> could probably speed up GHC by 0.2% or so
06:23:06 <Franciman> what's parsers?
06:23:10 <merijn> Franciman: https://hackage.haskell.org/package/parsers
06:23:24 <merijn> Franciman: Typeclass for parsers than you can then use with either parsec, attoparsec or trifecta
06:23:33 <merijn> So you can write parser agnostic parsers
06:23:39 <Franciman> that's real cool, indeed
06:24:31 <Franciman> merijn, I was saying, do you think I should use a lexer?
06:25:03 <merijn> Franciman: Probably will make things more convenient. But if you start simple you can do without it in the beginning
06:25:18 <Franciman> what do you mean by start simple?
06:25:21 <Franciman> you mean easy grammar?
06:25:23 <merijn> Franciman: The advantage of a lexer is that you can skip skipping all the optional whitespace everywhere
06:25:27 <merijn> Franciman: Small grammar, yeah
06:25:28 <Franciman> yep
06:25:35 <Franciman> I'm intending to parse Rust
06:26:14 <merijn> Ok, probably go with lexer then
06:26:34 <codedmart> Anyone that can provide some help on this. http://lpaste.net/138505
06:26:37 <merijn> But you may wanna write a toy thing for a simpler language first to get some experience before moving into something complex like Rust
06:26:44 <haskell939> I am back with STM questions :)
06:26:47 <codedmart> Not sure if it is a CPP problem, but it compiles fine
06:26:55 <ironChicken> in HXT picklers, i'm trying to create an attribute from two literal strings, one for name and one for value. however, the type of xpAttr is String -> PU a -> PU a where first argument is name and second is value. but i can't work out how to use a [Char] as the value. i can't use xpText to create a PU a because its type is just PU a, i.e. it's not String -> PU a (which I don't understand).
06:27:03 <Franciman> that's true, actually
06:27:08 <codedmart> The doctest in the paste only fails with 7.8
06:27:16 <codedmart> But not 7.10
06:29:37 <ironChicken> oh hang on, typical, i think i've just found it: there's an xpTextAttr which is String -> PU String
06:59:28 <aweinstock> @src Data.Traversable.traverse
06:59:34 <lambdabot> Source not found. Are you on drugs?
06:59:55 <dramforever> that doesn't make sense
07:00:07 <dramforever> since it's a typeclasses function
07:00:12 <dramforever> *typeclass
07:00:17 <merijn> Also, @src isn't where you wanna look anyway
07:00:32 <Zyxoas> Hey, peeps.
07:00:56 <dramforever> oh sure you shouldn't even look at @src
07:01:04 <dramforever> it isn't useful at all
07:01:07 <dramforever> @src foldr
07:01:07 <lambdabot> foldr f z []     = z
07:01:07 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:01:09 <Zyxoas> What's the point of the cabal "tested-with" option? Do I need it in my package?
07:01:26 <merijn> Zyxoas: To indicate what you bothered to test? :p
07:02:03 <Zyxoas> What happens if I don't include it? merjin? I have tested with everything from GHC 7.6.* upwards...
07:02:48 <Zyxoas> What are the semantics of that field? What checks does cabal perform based on it?
07:03:36 <merijn> Zyxoas: Nothing
07:03:41 <merijn> Zyxoas: It's a field for users
07:03:59 <bergey`> It's for humans; I don't think Cabal does anything with it, except probably syntax check it.
07:04:24 <merijn> I think it's a free form field
07:04:36 <Zyxoas> Okay. ¯\_(ツ)_/¯ I'll include it for shits and giggles, then...
07:04:57 <int-e> poor lambdabot... fixing...
07:05:13 <Zyxoas> What is its syntax? Can I use ranges? The cabal docs sort of suck, I believe we are all aware?
07:05:14 <bergey`> merijn: it's part of the data structure in http://hackage.haskell.org/package/Cabal-1.22.4.0/docs/Distribution-PackageDescription.html so I assume it gets parsed.
07:05:36 <merijn> bergey`: Sure, but free form fields are just parsed as "string"
07:05:47 <bergey`> testedWith :: [(CompilerFlavor, VersionRange)]
07:06:30 <Zyxoas> VersionRange. Great, so that means I can use the "BuildDepends" syntax for the range.
07:06:50 <Zyxoas> Thanks, merjin & bergey`
07:15:29 <aweinstock> is traverse = mapM, but just with a weaker constraint (works on Applicative's instead of just Monad's)?
07:16:31 <merijn> aweinstock: Yes
07:16:32 <Intolerable> aweinstock: yes
07:16:38 <int-e> > fix (scanl (+) 1 . (0:))
07:16:39 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
07:16:47 <aweinstock> also, sequenceA = traverse id ?
07:17:17 <Intolerable> yes
07:17:34 <int-e> @botsnack
07:17:34 <lambdabot> :)
07:17:54 * hackagebot yesod-routes-flow 1.0.2 - Generate Flow routes for Yesod  https://hackage.haskell.org/package/yesod-routes-flow-1.0.2 (FelipeLessa)
07:17:57 <dramforever> @help botsnack
07:17:57 <lambdabot> botsnack. Feeds the bot a snack
07:18:02 <dramforever> @botsnack
07:18:02 <lambdabot> :)
07:18:10 <dramforever> I wonder if there's more than that...
07:19:02 <int-e> Well, it should work again.
07:19:17 <dramforever> oh?
07:19:27 <int-e> :t 123
07:19:29 <lambdabot> Num a => a
07:19:31 <dramforever> what did you just do to lambdabot?
07:19:42 <aweinstock> int-e: is there a way to get an offline copy of the database that lambdabot uses for @quote?
07:19:47 <int-e> I updated to ghc-7.10.2
07:19:47 <dramforever> or, what was the problem?
07:19:51 <dramforever> oh
07:19:59 <dramforever> good =)
07:21:03 <int-e> aweinstock: no official one right now... I guess I could put a snapshot somewhere
07:22:06 <aweinstock> int-e: I'd appreciate that
07:22:56 <dustieConcrete> about haggis, want to play with GUIs, programming noob and i don't want to develop procedural tendencies, can i get by with haggis?
07:24:06 <int-e> aweinstock: http://int-e.eu/tmp/lambdabot/quote
07:24:18 <merijn> dustieConcrete: Never heard about haggis, but in general GUI frameworks are a pain to work with
07:24:25 <int-e> (I probably won't delete it, but it'll become stale)
07:25:32 <aweinstock> int-e: thanks
07:25:48 <aweinstock> how does it become populated? is it manually added to?
07:25:57 <merijn> aweinstock: Yes
07:26:25 <dustieConcrete> merijn: thanks, it was developed in the 90's by SPJ and Sigbjorn Finne
07:31:34 <int-e> has anybody complained about the major version bump to vector in ghc-7.10.2?
07:34:12 <int-e> (I had some unexepected trouble with lambdabot because of that... but maybe that only happens with DYNAMIC_GHC_PROGRAMS enabled, because then dependencies are installed that would otherwise be hidden, and vector is one of those...)
07:39:19 <Gurkenglas> Does the inhabitant of Free f Void have a categorical dual?
07:45:11 <shachaf> You could say something like Free f Void = Mu f, Cofree f () = Nu f
07:48:02 <frerich> Thanks to the lambdabot quotes file, I found this little gem: http://hackage.haskell.org/package/lens-4.12.3/docs/src/Control-Lens-Lens.html#%25%25~ <-- a function in lens with 36 lines of documentation, and then the definition is just 'id'.
07:49:37 <aweinstock> (%%~) :: Optical p q f s t a b -> p a (f b) -> q s (f t)
07:50:18 <haskell939> Can I compose STM with other monads?
07:50:37 <Gurkenglas> Ah, right, of course.
07:50:45 <haskell939> Something like (Monad m) => m STM a
07:51:05 <Intolerable> transformers?
07:51:29 <Intolerable> you can, but STM has to be your base monad
07:52:58 <aweinstock> :k ExceptT STM a
07:52:59 <lambdabot>     Not in scope: type constructor or class ‘STM’
07:52:59 <lambdabot>     Perhaps you meant ‘ST’ (imported from Control.Monad.ST)
07:52:59 <lambdabot> Not in scope: type variable ‘a’
07:53:21 <Intolerable> :k ExceptT Control.Monad.STM.STM a
07:53:22 <lambdabot> Not in scope: type variable ‘a’
07:53:27 <Intolerable> :k ExceptT Control.Monad.STM.STM
07:53:29 <lambdabot>     Expecting one more argument to ‘GHC.Conc.Sync.STM’
07:53:29 <lambdabot>     The first argument of ‘ExceptT’ should have kind ‘*’,
07:53:29 <lambdabot>       but ‘GHC.Conc.Sync.STM’ has kind ‘* -> *’
07:53:42 <Intolerable> :k ExceptT () Control.Monad.STM.STM
07:53:43 <lambdabot> * -> *
07:54:57 <aweinstock> @quote Dijkstra immortality
07:54:57 <lambdabot> Dijkstra says: I mean, if 10 years from now, when you are doing something quick and dirty, you suddenly visualize that I am looking over your shoulders and say to yourself "Dijkstra would not have liked this", well, that would be enough immortality for me.
07:55:30 <haskell939> Intolerable: okay. also can we continue with the discusiion of using TVars instead of MVars to communicate between threads
07:55:31 <haskell939> ?
07:55:55 <Intolerable> yup
07:56:05 <Intolerable> do u mean MVar or TMVar
07:56:42 <haskell939> Intolerable: yeah
07:57:32 <haskell939> I will repeat: My situation is IO Chan is there which is used to send messages to other thread(DB thread)
07:57:50 <haskell939> I send an MVar as part of that request to get result back
07:58:20 <haskell939> now I want to replace IO Chan with TChan Wueue
07:58:37 <Intolerable> you should be able to just swap the Chan for a TQueue and the MVar for a TMVar then
07:58:47 <haskell939> I assume I need to give up on Mvars? not really sure about that!
07:59:21 <Intolerable> you can either keep using MVars (but it of course won't be transactional) or switch to TMVars, which will be transaction and essentially identical
07:59:27 <Intolerable> *transactional
07:59:53 <Intolerable> if you're sending something off to another thread and then waiting on a response, it'll have to be in two transactions anyway though
08:00:06 <Intolerable> (because otherwise the first transaction will never finish)
08:00:15 <haskell939> Okay...but I still want to understand what I am loosing with giving up MVars?
08:00:25 <Intolerable> if you switch them for TMVar?
08:00:26 <Intolerable> nothing
08:00:31 <haskell939> yeah
08:00:44 <Intolerable> if there's a lot of contention on them, they might be a little slower
08:01:04 <Intolerable> but if you're only gonna use each on a single time, they should be essentially identical
08:01:49 <haskell939> okay, why will I need two transactions? why first transaction will never complete?
08:02:07 <Intolerable> if you have one transaction
08:02:28 <Intolerable> one thread will send everything, then wait for the MVar to signal completion
08:03:00 <Intolerable> except because the transaction has not been completed, the other thread can't see the change yet
08:03:24 <Intolerable> whereas with multiple transactions
08:03:33 <Intolerable> it'll write to the queue, then commit
08:03:43 <Intolerable> then the other thread sees the commit, does its stuff
08:03:49 <Intolerable> then writes back to the MVar
08:03:55 <Intolerable> (commits it)
08:04:02 <Intolerable> and then the first thread can see the MVar has changed
08:04:26 <Intolerable> s/MVar/TMVar
08:04:46 <haskell939> yup, makes sense..
08:06:03 <Intolerable> you won't see many of the benefits of STM unless you need the transactional capabilities
08:06:19 <Intolerable> but it makes it very easy to get concurrency working *correctly*
08:06:50 <haskell939> Intolerable: exactly I need transactional capabilities
08:07:04 <haskell939> Because I need receiver to receive events in order
08:07:35 <Intolerable> do you have something you can put on lpaste that i can take a look at?
08:08:38 <haskell939> sure.
08:10:46 <haskell939> Intolerable: http://lpaste.net/6989495877609979904
08:11:01 <haskell939> I want eventAction to be in STM
08:11:27 <Intolerable> what's Op
08:11:29 <haskell939> because this should be consistent with something else!
08:11:44 <aweinstock> > floor (1.0/0.0)
08:11:46 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
08:11:48 <haskell939> I will put that too
08:13:05 <haskell939> edited
08:13:42 <haskell939> Intolerable: http://lpaste.net/6989495877609979904
08:14:02 <Intolerable> "This page is in [Danish]"
08:14:04 <Intolerable> errrrr
08:14:17 <haskell939> really? I see it in english :)
08:14:28 <Intolerable> chrome isn't convinced
08:14:58 <Gurkenglas> The recursion-schemes and free packages seem a little redundant, or am I missing something?
08:15:27 <haskell939> Intolerable: http://lpaste.net/6310414836048068608 can you read it at all?
08:15:38 <haskell939> I can create a private gist if you want
08:15:43 <Intolerable> yeah i can see it
08:16:39 <haskell939> Storage is basically a record that has reference to Chan
08:16:53 <haskell939> that is created by receiver thread only
08:17:56 * hackagebot human-readable-duration 0.1.0.0 - Provide duration helper  https://hackage.haskell.org/package/human-readable-duration-0.1.0.0 (yogsototh)
08:17:57 <Intolerable> http://lpaste.net/6989495877609979904
08:18:03 <Intolerable> two transactions
08:18:07 <Intolerable> one to put it into the queue
08:18:12 <Intolerable> and the other to wait until its done
08:18:57 <Intolerable> some of the functions might have the wrong names
08:19:15 <Intolerable> iirc TChan / TMChan / TQueue aren't entirely consistent
08:19:24 <haskell939> Intolerable: I need whole eventAction in STM or something like FileStore (STM a)
08:19:44 <Intolerable> you can't
08:19:56 <Intolerable> because if you need a response, you need to commit the transaction
08:20:02 <Intolerable> at which point you are no longer working in STM
08:20:07 <scshunt> 5/win 9
08:21:15 <haskell939> Intolerable: Ah
08:21:44 <haskell939> TQueue aren't entirely consistent? 
08:21:53 <Intolerable> the interface i mean
08:22:09 <lequtix> hi
08:22:32 <Intolerable> iirc something uses "writeX" and something uses "putX"
08:22:35 <Intolerable> hello
08:22:44 <Intolerable> i could be wrong w/ that tho
08:22:48 <Intolerable> they work fine though
08:23:53 <haskell939> okay, I really need to be consistent. because for atomicity I am using optimistic concurrency control.
08:24:09 <haskell939> sorry I mean for Idempotency!
08:24:31 <themachinist>  /part
08:25:03 <haskell939> If events gets reoredred between sender and receiver - my machinery will fail. 
08:27:15 <haskell939> Intolerable: Thanks for your help :). Really appreciated!
08:27:27 <Intolerable> np
08:32:57 * hackagebot reroute 0.3.1.0 - abstract implementation of typed and untyped web routing  https://hackage.haskell.org/package/reroute-0.3.1.0 (AlexanderThiemann)
08:33:27 <neurogeek> Hi! does anybody know if HLint supports things like checking import ordering (alphabetically) or should I write a custom script that do this? Thanks!
08:35:36 <obadz> Reminder: London Haskell meetup 6:30pm (in 2 hours) http://www.meetup.com/hoodlums/events/223759117/
08:48:36 <ironChicken> goodness, the HXT pickling API is so hard to understand
08:49:42 <ironChicken> i don't see why we can't have something like pickle :: a -> XmlTree
08:53:01 <dr_diagoras> evening, fellow haskellers. I have a question for you. Is it possible to somehow "hoist (Identity . runST)"? I have already learned about type inference problems with ST monad, but despite my best efforts can't make it work. is it posible at all or I'm chasing wrong target?
08:55:13 <aweinstock> dr_diagoras: what are you trying to do?
08:56:04 <dr_diagoras> I'm trying to run some MVector fiddling inside RWST for a short while
08:56:39 <aweinstock> could you do an lpaste of what you have so far?
08:57:11 <dr_diagoras> one moment
08:59:54 <dr_diagoras> aweinstock: http://lpaste.net/138717
09:00:32 <Zemyla> How does the simply typed lambda calculus work? I want to try implementing it in my program.
09:01:24 <subleq> Zemyla: that's a pretty big question. Have you read about it?
09:01:32 <dr_diagoras> hoist as in Control.Monad.Morph of course
09:01:54 <aweinstock> dr_diagoras: what's EventAction?
09:03:07 <dr_diagoras> some custom type of mine - no polymorphism or anything strange there
09:03:47 <Zemyla> subleq: Not really. But I want to use it with Unlambda, which only has function types and only has three primitives I would use it with.
09:04:06 <aweinstock> what are you planning to compute with MVectors?
09:05:06 <aweinstock> (and is Universe a variant of IO?)
09:05:17 <Zemyla> Would that make it simpler?
09:05:35 <dr_diagoras> well, there is some heavy number-crunching there, so I need stateful computations unfortunately - using pure data structures there would be awfully slow
09:06:33 <aweinstock> if it's just number-crunching (you don't need to interleave other UniverseActions in the middle), you can just use runST to get a pure result
09:07:39 <muake> IIRC unlambda is untyped, not simply-typed
09:08:11 <dr_diagoras> thought of it - unfortunately interleaved :-( unpacking and repacking this RWS around computational parts would look ugly as hell
09:08:18 <monochrom> MarvelUniverse is a variant of concurrent IO and branching STM :)
09:08:58 <dr_diagoras> monochrom: heh :-)
09:09:05 <aweinstock> Zemyla: Isn't simply typed lambda calculus "just" lambda calculus + some typing rules that ensure termination (and rule out things like the Y combinator)?
09:09:39 <scshunt> dr_diagoras: and lifting wouldn't work?
09:09:46 <aweinstock> dr_diagoras: where are the definitions of UniverseScheme/Universe?
09:09:50 <Zemyla> muake: Yes, but if a value in it can be simply typed, then it can be converted into a function without looping.
09:10:09 <Zemyla> Basically, I want to use it to optimize Unlambda.
09:10:55 <aweinstock> Zemyla: you're making an optimized Unlambda interpreter that JITs anything that simply-typed-lambda-calculus typechecks?
09:11:06 <dr_diagoras> scshunt: what do you mean? lifting is for things on top of monad stack and I need to embed ST _under_ my RWST
09:11:32 <scshunt> dr_diagoras: you would have RWST (ST a), no?
09:11:32 <Zemyla> aweinstock: Yeah, basically.
09:12:02 <dr_diagoras> aweinstock: in the same module. one moment, I'll add to paste
09:15:33 <dr_diagoras> aweinstock: http://lpaste.net/138717 - sort of like this, nothing too weird there
09:16:34 <dr_diagoras> scshunt: I have "RWST (ST a)" computation and need to make "RWS a" from it
09:17:12 <dr_diagoras> I mean "RWST (ST s) a" of course
09:17:25 <scshunt> well, RWST ST a
09:17:31 <scshunt> but yes, I understand what you mean
09:17:55 <aweinstock> dr_diagoras: replace (RWS UniverseScheme TL.Text Universe) with (RWST UniverseScheme TL.Text Universe ST), and use (lift $ {- modify ST things -} )
09:17:59 <scshunt> :t hoist runST
09:18:00 <lambdabot> Not in scope: ‘hoist’
09:20:21 <dr_diagoras> aweinstock: each (lift $ {- modify ST things -} ) can not pass MVectors to each other - it will be whole matrices copying on each lift
09:21:09 <dr_diagoras> this is already giving me headache :-(
09:21:47 <scshunt> dr_diagoras: yes they can; they're all inside the same ST monad
09:22:40 <codedmart> Can anyone tell me what is wrong with my OverlappingInstances? http://lpaste.net/138505 <- compiles but this doctest fails on 7.8. Not 7.10 though.
09:22:56 <scshunt> RWST ... (ST s a) is an RWS computation *inside* the ST monad
09:23:14 <aweinstock> dr_diagoras: yes, you can (vec <- lift $ MVector.new 42)
09:23:22 <scshunt> it's possible to write a function RWST ... (ST s a) -> RWS ... a
09:23:35 <scshunt> though because of the extra parameter to ST you might need to do it manually
09:23:36 <dr_diagoras> ah, stop-stop, I got what you mean
09:24:38 <scshunt> you can unwrap and then rewrap the RWS monad because it's entirely pure
09:26:28 <scshunt> :t transform
09:26:29 <lambdabot> Plated a => (a -> a) -> a -> a
09:26:32 <kyclark> Given a sorted list of integers, e.g., [2,4,5,7], how could I indicate the missing numbers starting from 1 and going to the last number? E.g., [False, True, False, True, True, False, True]?
09:26:32 <scshunt> not the right one
09:26:41 <dr_diagoras> yes, of course I can lift "ST s a" to "RWST ... (ST s) a". but problem is not here - somewhere I'll need to turn all this into pure RWS _without_ underlying ST - the main program stack is pure
09:26:44 <Zemyla> But yeah, any expression with just s, k, i, and ` (apply), if it can be simply typed, can be converted to an equivalent expanded function, yes?
09:27:27 <scshunt> dr_diagoras: you can do that
09:27:45 <scshunt> dr_diagoras: most of the combinators I've found do do that won't type check correctly because of the peculiar way that ST is typed
09:27:49 <scshunt> but you could do it manually
09:28:03 <scshunt> let me code something up
09:28:13 <kadoban> kyclark: Why not a list of the missing numbers, [1,3,6], or something? I'm not really sure what you're asking though.
09:28:29 <dr_diagoras> scshunt: that's the exact headache :-) I'm trying to manually typecheck for more then an hour already
09:28:46 <Zemyla> kyclark: missing = go 1 where go i [] = []; go i (j:l) = case compare i j of (... fill in the blanks ...)
09:28:48 <zipper> https://www.reddit.com/r/haskell/comments/3gv6eg/progress_with_waidevel/
09:29:00 <Zemyla> That should be enough for you to start.
09:29:01 <zipper> Progress with wai-devel
09:30:05 <dr_diagoras> "hoist idRunST" is fucking impossible to type as far as I see :-(
09:30:38 <geekosaur> language...
09:31:24 <Gurkenglas> "endsOnBool = zipWith (==) (reverse "Bool") . reverse" <- will this reverse "Bool" each time the function is called, or is that memoized?
09:31:43 <kyclark> Ultimately my problem set is a list of tuples [(2,3),(4,8),(5,1)] where I want to start at 1 and extract the tuple "snd" for every integer value "fst", so [(1,0), (2,3), (3,0), (4,8), (5,1)]
09:31:54 <dr_diagoras> geekosaur: sorry - some parts of haskell are infusing rage in me :-(
09:32:40 <kyclark> I'm stuck because it seems like a stateful thing -- I need to know what I saw before, right?  I've been banging my head on this.  I can do it easily in Perl with a "for" loop and a "last" variable.
09:33:00 * hackagebot hdevtools 0.1.2.0 - Persistent GHC powered background server for FAST haskell development tools  https://hackage.haskell.org/package/hdevtools-0.1.2.0 (SchellScivally)
09:33:14 <Intolerable> can you write it in a stateful way?
09:33:18 <Intolerable> in another language?
09:33:25 <Intolerable> i dont quite understand what you want
09:33:33 <Gurkenglas> kyclark, it seems pretty close to the last problem. Shall I write the foldr way?
09:34:09 <kyclark> I was playing with a fold last night, but a fold will collapse the list, right?  I need to expand it -- right?
09:34:25 <Intolerable> folds dont necessarily collapse the list
09:34:33 <Intolerable> you can collapse the list into another list
09:34:50 <Gurkenglas> :t foldr (:) []
09:34:51 <lambdabot> Foldable t => t a -> [a]
09:35:00 <codedmart> geekosaur or Intolerable could I bother you to glance at my problem, please? http://lpaste.net/138722#line27, doctest fails only on 7.8 but not 7.10 and I don't understand why.
09:35:06 <kyclark> Hmm, OK, that makes sense.
09:35:22 <Franciman> Hello, again
09:35:26 <nitrix> Can anyone help me with my broken parser?  -> http://lpaste.net/138721
09:35:30 <Intolerable> hello
09:35:35 <kyclark> Gurkenglas: I would appreciate a foldr example
09:37:51 <kadoban> nitrix: It sounds like your definition of line is wonky. Maybe define a line withoun the eol, and then use something like sepBy to require linebreaks in between? or whatever the real syntax is?
09:38:22 <nitrix> kadoban: The current definition has a newline at the end of each line though. I can provide a BNF?
09:38:40 <kadoban> nitrix: Then is your input just broken?
09:39:01 <nkaretnikov> is there an exception handling function with this type: m a -> (a -> m b) -> m b?  it should work like finally but allow me to kill the action when an exception is raised (hence the a argument)
09:39:45 <kadoban> nitrix: Sorry, I think I misread … let me look closer.
09:40:07 <nitrix> kadoban: Let me update it with BNF
09:41:00 <scshunt> dr_diagoras: hmm... I'm running into the same error
09:41:12 <scshunt> but at least it's distilled so someone smarter than me can explain the issue
09:41:43 <Gurkenglas> Hmm, I did end up needing a little state. Just one number. kyclark, http://lpaste.net/138725
09:42:12 <lpaste_> scshunt pasted “ST headaches” at http://lpaste.net/138726
09:42:21 <scshunt> dr_diagoras: ^
09:42:24 <dr_diagoras> scshunt: yup, haskell can make people feel dumb :-( I'm trying manually unpack and repack RWST now
09:42:30 <Gurkenglas> (chi because it's the characteristic function and my math class used Chi for that)
09:42:58 <kyclark> OK, I'm going to sit down with a cup of coffee and deconstruct this for myself.  Thanks!
09:43:00 * hackagebot liquidhaskell 0.5.0.1 - Liquid Types for Haskell  https://hackage.haskell.org/package/liquidhaskell-0.5.0.1 (EricSeidel)
09:43:06 <scshunt> dr_diagoras: that was my approach
09:43:07 <nitrix> kadoban: Updated, same url
09:43:10 <Intolerable> nkaretnikov: no, because if you're getting the a from the action, it necessarily must complete without exceptions
09:43:16 <geekosaur> codedmart, I have looked at that before and know no more about servant now than then to be able to help, sorry
09:43:30 <Intolerable> if it stops, there will be no returned "a"
09:43:50 <dr_diagoras> scshunt: exactly same stuff I have :-(
09:44:02 <glguy> nitrix: blockId <- many (noneOf "\n,")
09:44:14 <glguy> nitrix: your blockIds are eating the newlines
09:44:53 <kadoban> nitrix: I suspect that 'line' possibly doesn't mean what was intended?     line = entry <* char '\n'     or      line = do {e <- entry; char '\n'; return e} ?
09:45:11 <glguy> nitrix: also get rid of the "many"
09:45:13 <kadoban> Oh, yeah that's probably causing the actual problem
09:45:31 <scshunt> dr_diagoras: got it
09:45:34 <codedmart> geekosaur: I am more referring to the OverlappingIntances? But ok, thanks!
09:45:42 <lpaste_> scshunt revised “ST headaches”: “No title” at http://lpaste.net/138726
09:45:46 <scshunt> ^ that one works
09:46:23 <nkaretnikov> Intolerable: how does bracket work, then?
09:46:37 <dr_diagoras> scshunt: wow! one moment, trying to adapt
09:46:39 <codedmart> geekosaur: If I remove the Raw Enter instance that doc test passes so it seems that even though that doctest is not Raw it is still trying to use that instance or something.
09:46:53 <scshunt> dr_diagoras: the trick is the quantification in the type of the argument
09:46:59 <Intolerable> nkaretnikov: wait, which action are you expecting the exception in?
09:47:11 <codedmart> geekosaur: Didn't know if there was some magic I was missing related to overlapping instances is all I was hoping to get answered.
09:47:33 <nkaretnikov> Intolerable: i have only one; i'm thinking of using bracket action handler (return ())
09:47:40 <nkaretnikov> Intolerable: any problems with this?
09:47:41 <scshunt> You may need that same quantification in other places you need the type.
09:47:49 <scshunt> probably best to make a type alias
09:48:29 <dr_diagoras> hm... and I'm having the error still. pasting now
09:48:43 <nkaretnikov> Intolerable: like, bracket (forkIO $ ...) (killThread) (return ())
09:48:56 <nkaretnikov> hm
09:48:57 <nkaretnikov> wait
09:49:06 <Intolerable> that should be fine
09:49:08 <Intolerable> no?
09:49:16 <nkaretnikov> Intolerable: it doesn't make sense, i think.  the thread should be killed automatically, no?
09:49:17 <nkaretnikov> on exit
09:49:21 <dr_diagoras> scshunt: http://lpaste.net/138729
09:49:28 <Intolerable> is there any reason you can't use async?
09:49:32 <Intolerable> @hackage async
09:49:32 <lambdabot> http://hackage.haskell.org/package/async
09:49:37 <scshunt> dr_diagoras: you need to include the quantification of the type somewhere
09:49:40 <Intolerable> this is literally what it was designed for
09:49:45 <scshunt> see the forall t. in the type argument?
09:50:01 <scshunt> this is the trick used to make the ST monad work
09:50:07 <scshunt> and you need to thread that through wherever you use it
09:50:09 <nitrix> glguy: Wait, noneOf doesn't shortcircuit?
09:50:16 <scshunt> dr_diagoras: can you paste the whole thing?
09:50:27 <nitrix> glguy: many just keeps going and going until the end, aww crap.
09:50:27 <nkaretnikov> Intolerable: this is just for a test, not a missile launcher
09:50:38 <dr_diagoras> yes, I just copypasted your code into my module. very strange...
09:51:01 <Intolerable> are you trying to fork a thread and then kill it if another action fails?
09:51:12 <scshunt> dr_diagoras: did you enable RankNTypes
09:51:13 <scshunt> ?
09:51:21 <dr_diagoras> may be it's interference with some of weird GHC extensions I'm using... checking now
09:51:28 <nkaretnikov> Intolerable: i just realized that it may be a different process that i need to kill, so nevermind :)
09:51:41 <nkaretnikov> i'm pretty sure the thread one should die on its own
09:51:49 <scshunt> dr_diagoras: did you attempt to use the function?
09:51:54 <nkaretnikov> thanks for helping me debug though
09:51:59 <Intolerable> np
09:52:03 <Intolerable> hope you manage to sort it
09:52:22 <dr_diagoras> yes, I called it from other function to be sure
09:52:33 <geekosaur> codedmart, that is deifnitely not an issue of overlapping, since it's trying to match a ReaderT against an EitherT from the error message
09:52:46 <nitrix> glguy: But I thought, because `line` is defined as `endBy`, it'd already split on all the newlines and then just send substrings to `entry`.
09:52:46 <geekosaur> I might suggest that if you can't get help in here, try the haskell-cafe list and/or stack overflow
09:52:50 <nitrix> glguy: Is that wrong?
09:53:00 * hackagebot steeloverseer 1.1.0.5 - A file watcher.  https://hackage.haskell.org/package/steeloverseer-1.1.0.5 (SchellScivally)
09:53:04 <glguy> nitrix: Yes.
09:53:05 <codedmart> geekosaur: OK thanks very much!
09:53:27 <nitrix> glguy: I'm not sure I understand why though.
09:54:14 <nitrix> glguy: Because they aren't actual functions that takes inputs as argument? Merely an action that's the combination of many combinators and then this whole thing is applied in sequence to the input?
09:54:51 <glguy> endBy x y    will try to parse with x and if that works it will try to parse with y and then repeat
09:54:55 <dr_diagoras> scshunt: ok, I got it
09:55:10 <glguy> x has no idea what y will do
09:55:10 <dr_diagoras> it compiles in fresh module
09:55:34 <Zemyla> So is there a simple introduction to the simply typed lambda calculus?
09:55:44 <glguy> endBy p sep         07= many (07do{ x 07<- p; sep; return x })
09:55:58 <scshunt> dr_diagoras: ok, that's good :)
09:56:12 <dr_diagoras> something of FlexibleInstances, FlexibleContexts or UndecidableInstances are messing with typechecking process
09:56:37 <dr_diagoras> god, haskell is crazy sometimes
09:56:42 <Zemyla> glguy: endBy p sep = many (p <* sep)
09:57:02 <glguy> Zemyla: Yeah, they could have implemented it like that, too, but they didn't.
09:57:14 <nitrix> glguy: The documentation says "endBy p sep parses zero or more occurrences of p, separated and ended by sep.". If it did what you say, it'd parse a '\n' prior to elements, then inbetween every elemnts, then at the end.
09:57:22 <dr_diagoras> scshunt: thank you a lot!
09:57:45 <glguy> nitrix: You just misunderstood what I said, then.
09:57:57 <kadoban> nitrix: ? I think you're misreading him/it
09:57:57 <Gurkenglas> Oops, didn't letlpaste before posting my solution. kyclark the paste is updated to reflect some bugfixes (: changed to ++, updated type signature)
09:58:07 <ggole> Zemyla: Pierce has a nice page on his site iirc
09:58:21 <Zemyla> ggole: Link?
09:58:22 <nitrix> glguy: Oh wait my bad, I inverted the arguments in my head by mistake.
09:58:26 <scshunt> dr_diagoras: np
09:58:40 <nitrix> glguy: So it parsed x (the entry), if it succeeds, then it parses the separator.
09:59:03 <kyclark> Gukenglas: Thanks.  I just got my coffee and was ready to learn me some new stuff!
09:59:03 <nitrix> Okay that makes sense. Let me see if I can get the code to work now.
09:59:36 <ggole> Zemyla: ah, maybe not: the page I seem to be thinking of is part of SF
09:59:36 <glguy> Parsec is tricky, it makes you think that you get to structure the parser the way you think about things, but you still have to write your parser the way that Parsec parses
09:59:40 <kadoban> nitrix: Make sure you look at the definition of line above too. I think the type you're ending up with probably isn't what you want (it's wrapped in an extra [])
09:59:46 <ggole> (That is, http://www.cis.upenn.edu/~bcpierce/sf/current/Stlc.html )
09:59:50 <Gurkenglas> And kyclark, I think I already answered when you asked last week - http://lpaste.net/138011 for the "ultimate" question
09:59:52 <glguy> or at least that's how people tend to try to use it
10:00:18 <kyclark> Whoa!  I totally missed that, Gurkenglas!  I'm so sorry.
10:02:16 <nawal> Hi
10:02:23 <Intolerable> hello
10:02:24 <kyclark> Gurkenglas: I'm getting "Missing.hs:14:24: parse error on input ‘->’"
10:02:52 <nawal> I'm following up some definition of digitToInt, and ended up with ord in https://hackage.haskell.org/package/text-1.1.1.0/src/Data/Text/Internal/Unsafe/Char.hs
10:03:01 * hackagebot generic-accessors 0.4.1.1 - stringly-named getters for generic data  https://hackage.haskell.org/package/generic-accessors-0.4.1.1 (GregHorn)
10:03:14 <Gurkenglas> kyclark, weird. Try the other one first.
10:03:19 <Gurkenglas> > chi [2,4,7]
10:03:20 <lambdabot>  [False,True,False,True,False,False,True]
10:03:20 <nawal> What does this mean
10:03:21 <nawal> ord :: Char -> Int
10:03:21 <nawal> ord (C# c#) = I# (ord# c#)
10:03:21 <nawal> {-# INLINE ord #-}
10:03:25 <nawal> ?
10:03:44 <dr_diagoras> scshunt: you won't believe
10:03:54 <kyclark> Yeah, the "chi" works perfectly.  I figured I could expand on that idea.
10:04:05 <scshunt> dr_diagoras: ?
10:04:19 <dr_diagoras> this code is not working with {-# LANGUAGE GADTs #-}
10:04:29 <scshunt> dr_diagoras: O_o
10:04:30 <geekosaur> nawal: it's low level stuff. C# and I# are constructors for the low level representations of Char and Int; here, the trailing # basically means "unboxed machine representation"
10:04:33 <dr_diagoras> how the hell it is connected?!
10:04:37 <scshunt> dr_diagoras: can you put it in a different module and compile it there?
10:04:46 <geekosaur> language, please
10:04:47 <scshunt> and use it in one with GADTs
10:04:56 <scshunt> I have no idea why they wouldn't work together :/
10:05:24 <Gurkenglas> Oh, dangit. I put an -> instead of an =. The source location of the parse error should be shown. kyclark, lpaste updated
10:05:42 <dr_diagoras> geekosaur: sorry again :-(
10:05:43 <nawal> thanks geekosaur :-)
10:05:54 <dr_diagoras> scshunt: yup, did it and it works
10:06:05 <scshunt> dr_diagoras: YAY! :D
10:06:05 <nitrix> glguy: If I parse <- many digit, is it going to take all the digits until a non-digit arise?
10:06:16 <Gurkenglas> > fillup [(2,3),(4,8),(5,1)]
10:06:17 <lambdabot>  [(1,0),(2,3),(3,0),(4,8),(5,1)]
10:06:22 <geekosaur> don't know offhand about ord# especially since the unboxed forms should be the same representation...
10:06:27 <glguy> nitrix: yes
10:06:39 <kyclark> I'm getting "Fillup.hs:6:23: Illegal tuple section: use TupleSections"
10:06:48 <dr_diagoras> I don't know how many hours I could have spent - this is extremely weird conflict
10:06:49 <kyclark> Never seen that before.
10:06:55 <scshunt> dr_diagoras: yeah
10:07:16 <int-e> > (1,) 2
10:07:17 <lambdabot>  (1,2)
10:07:25 <Intolerable> kyclark: make sure you aren't accidentally doing (x,) or similar
10:07:30 <int-e> kyclark: that would be a tuple section
10:07:44 <int-e> > (1,,2) 3
10:07:45 <lambdabot>  (1,3,2)
10:08:32 <aweinstock> kyclark: put {-# LANGUAGE TupleSections #-} at the top of the file
10:08:59 <kyclark> aweinstock: That fixed it, thanks!
10:13:01 * hackagebot steeloverseer 1.1.0.6 - A file watcher.  https://hackage.haskell.org/package/steeloverseer-1.1.0.6 (SchellScivally)
10:14:16 <Welkin> oh, how about a probability package named "farseer"
10:14:31 * Clint squints.
10:15:46 <nitrix> glguy: is there a many1Till ?
10:16:10 <nitrix> manyTill but with 1 or more elements?
10:16:34 <Welkin> nitrix: parse one, then parse manyTill
10:17:12 <phadej> someTill p end = (:) <$> p <*> manyTill p end
10:17:46 <Welkin> I was just working with that last night :D
10:18:01 <phadej> yet, usually you want have your own function in place of (:), so you don't need to assume that list is non-empty
10:18:04 <int-e> :t ap (liftA2 (:)) manyTill
10:18:05 <lambdabot> Not in scope: ‘manyTill’
10:19:31 <int-e> oops, I didn't take the `end` into account
10:40:14 <nitrix> Last question, why does the type of my parser ends up being parseNodeBlock :: Block -> Either ParseError [[(String, [BlockId])]]
10:40:25 <nitrix> Why the [[ ]] and not simply [] ?
10:40:48 <kadoban> nitrix: You didn't read my messages, did you :-/
10:41:00 <nitrix> kadoban: Genuinely can't find it.
10:41:09 <nitrix> I know you said something about that :/
10:41:20 <kadoban> nitrix: I suspect that 'line' possibly doesn't mean what was intended?     line = entry <* char '\n'     or      line = do {e <- entry; char '\n'; return e} ?
10:41:57 <kadoban> I think that's the relevant one
10:42:42 <nitrix> kadoban: My block turned into  block = many1 line,   line = entry `sepEndBy1` (char '\n')
10:43:06 <nitrix> Oh crap
10:43:24 <kadoban> nitrix: Hmm, can I see the whole thing? But yeah I think that's the problem, many1 /and/ sepEndBy1, I think you mean … one of those and not the other.
10:43:41 <nitrix> Solved :D
10:43:46 <kadoban> :)
10:43:58 <nitrix> Now I love Parsec.
10:44:12 <kadoban> Lol. Yeah it's kinda funky sometimes, but I'm a big fan still.
10:45:47 <nitrix> 5 lines. The equivalent would be a linked list, 50 lines and bunch of pointer manipulation and awful string comparison that doesn't say much at first glance in C.
10:46:13 * nitrix takes a deep breath and contaplates his work of art.
10:48:03 * hackagebot steeloverseer 1.0.1.0 - A file watcher.  https://hackage.haskell.org/package/steeloverseer-1.0.1.0 (SchellScivally)
10:49:13 <Zemyla> Sit turns out what I'm looking for is Hindley-Milner type inference.
10:49:17 <Zemyla> *So it
10:53:03 * hackagebot steeloverseer 1.1.1.0 - A file watcher.  https://hackage.haskell.org/package/steeloverseer-1.1.1.0 (SchellScivally)
10:57:16 <dmj`> Is it still true that there's no way to access #define constants in C from haskell?
10:57:25 <dmj`> FFI addendum says, "In particular, there is no support for accessing pre-processor symbols from Haskell, which includes #defined constants"
10:58:03 * hackagebot exinst 0.1 - Derive instances for your existential types.  https://hackage.haskell.org/package/exinst-0.1 (RenzoCarbonara)
11:00:24 <glguy> dmj`: You use hsc2hs for stuff like that
11:01:04 <glguy> #include <stdio.h>              example = #{const FILENAME_MAX}
11:03:04 * hackagebot exinst-aeson 0.1 - Derive instances for the `aeson` library for your existential types.  https://hackage.haskell.org/package/exinst-aeson-0.1 (RenzoCarbonara)
11:03:06 * hackagebot exinst-bytes 0.1 - Derive instances for the `bytes` library for your existential types.  https://hackage.haskell.org/package/exinst-bytes-0.1 (RenzoCarbonara)
11:03:08 * hackagebot exinst-deepseq 0.1 - Derive instances for the `deepseq` library for your existential types.  https://hackage.haskell.org/package/exinst-deepseq-0.1 (RenzoCarbonara)
11:03:10 * hackagebot exinst-hashable 0.1 - Derive instances for the `hashable` library for your existential types.  https://hackage.haskell.org/package/exinst-hashable-0.1 (RenzoCarbonara)
11:05:24 <dmj`> glguy: ah cool, so the preprocessor will fetch it, I'll go read more :)
11:07:20 <geekosaur> the thing you were lookiung at applies only to foreign import
11:07:34 <Luke> bergmark: ping
11:07:58 <geekosaur> which used to go through a C compiler and thus could see preprocessor defined, but with direct to asm or direct to llvm there is no C compiler or preprocessor involved in foreign import any more
11:08:17 <geekosaur> *defines
11:09:36 <dmj`> geekosaur: I see
11:11:55 <Fay> geekosaur: there is no preprocessing for foreign code?
11:12:45 <geekosaur> ?
11:14:04 <geekosaur> Fay, this is specific to the "foreign import" declaration in Haskell
11:14:08 <Fay> geekosaur: perhaps im missing something how does foreign import work
11:14:27 <geekosaur> back when ghc compiled to C code, it was reasonable to imagine that anything available in the C compiler could be used in that declaration
11:14:49 <geekosaur> but with direct compilation to machine (or llvm) code, it refers only to linker symbols
11:15:04 <Fay> ahhhh okay that makes sense thankyou
11:16:08 <dmj`> Fay: seems like since there's no more C backend -fvia-C was removed, before there would have been access to the C preprocessor to get constants. With foreign import there is a calling convention 'ccall', but you need your own preprocessing tools to get access to #define macros now, which is probably a naive splice
11:35:19 <Fay> can ghc still compile to C
11:35:20 <Fay> ?
11:36:40 <comprehension> what causes Happy to throw a parse error? 
11:39:45 <dmj`> Fay: I don't think so
11:41:02 <dmj`> Fay: see the bottom section here: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/code-generators.html
11:43:33 <Fay> dmj`: okay so it actually looks like i can compile to C, however i need to compile GHC specifically to do that
11:45:43 <Luke> ocharles__: docs aren't generating here https://hackage.haskell.org/package/libsystemd-journal-1.3.3
11:45:45 <Fay> lol but why bother when ghc compiles strait to asm :)
11:47:08 <geekosaur> compile to C is how porting used to be done
11:47:18 <dolio> The only C output that GHC does these days is for porting GHC to platforms where it isn't already built.
11:47:25 <dolio> And it won't be as efficient.
11:47:29 <geekosaur> (these days we compile to llvm, capture the llvm bytecode before it is translated to native code, and translate it on the target)
11:48:41 <demize> geekosaur: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/code-generators.html seems to imply that it's not compiled to llvm by default.
11:49:00 <geekosaur> it's not default, correct
11:49:16 <geekosaur> unregisterised C for porting also was not default back when ghc compiled to C
11:49:31 <geekosaur> in both cases you use(d) special options to accomplish porting
11:49:55 <demize> Oh, I thought you meant the default codegen when you said these days.
11:50:22 <int-e> well, for porting
11:53:53 <frerich> > map (chr . fromIntegral) . unfoldr (\x -> guard (x > 0) >> return  (x `mod` 256, x `div` 256)) $ 152110696948989857750358645756541560135
11:53:54 <lambdabot>  "Get a calculator"
11:54:05 <frerich> (Courtesy of Cale)
11:56:55 <Cale> :)
11:57:09 <Welkin> LOL
11:57:16 <mmaruseacph2> 5/window 5
11:57:21 <Welkin> centrinia: what is the trigger for that response?
11:57:26 <Welkin> er
11:57:33 <Welkin> Cale: what is the trigger for that response?
11:57:46 <Welkin> tab completion...
11:57:49 <Cale> hm?
11:57:57 <centrinia> @slap Welkin 
11:57:57 * lambdabot locks up Welkin  in a Monad
11:58:02 <Cale> frerich posting my oneliner
11:58:15 <Welkin> @slap centrinia 
11:58:16 * lambdabot pokes centrinia  in the eye
11:58:21 <Welkin> where is the trout?
11:58:29 <centrinia> It is randomized.
11:58:32 <geekosaur> there isn't one; the long Integer is just the decimal version of the character values
11:58:33 <centrinia> It is in there somewhere.
11:59:21 <geekosaur> > showHex 152110696948989857750358645756541560135 ""
11:59:22 <lambdabot>  "726f74616c75636c6163206120746547"
11:59:42 <geekosaur> ...reversed
12:06:11 <rpfun> is there a way to express the idea in haskell "if I have typeclass A, then do x, otherwise do y"?
12:07:08 <phadej> rpfun: not really, it would require decidable type equality
12:08:19 <rpfun> phadej: does "not really" mean it can be hacked around? :)
12:08:21 <phadej> but you can do `class A' a where default xy :: A a => ...`
12:08:27 <shachaf> What is "decidable type equality"?
12:08:31 <phadej> rpfun: with some boilerplate.
12:08:35 <dmj`> rpfun: maybe a type function, using associated type synonyms
12:09:06 <phadej> rpfun, snachaf: look https://www.youtube.com/watch?v=AWeT_G04a0A
12:09:07 <frerich> The quotes file for lambdabot is truly a nasty time sink and amusing bedtime read, in equal parts.
12:09:58 <shachaf> phadej: Haskell isn't Idris, and its type level is much simpler. What is "decidable type equality" in this context?
12:10:13 <shachaf> I would say that there's a different reason that you can't do it (but you still can't do it).
12:12:09 <aweinstock> frerich: you're welcome :)
12:12:17 <Sindriava> Is there a way to make list comprehensions output multiple elements at once?
12:12:44 <Sindriava> e.g. something like [a, b, c | a <- …] 
12:13:18 <phadej> shachaf: that talk is applicable to haskell too. If we could do that "if type is a do x, otherwise y" we will ruin parametricity
12:13:22 <arkeet> no, but you can concat [[a,b,c] | ...]
12:13:40 <Sindriava> arkeet: That's what I'm doing, I was wondering if there was a sugar for it, thanks :)
12:13:49 <Sindriava> Also,
12:13:50 <phadej> e.g. write "id :: a -> a; id x = if (a ~ Int) then 42 else x"
12:13:56 * Sindriava frowns at contact
12:14:00 <Sindriava> wtf
12:14:05 <arkeet> btw, concat [f x | x <- a]  =  f =<< a
12:14:08 * Sindriava frowns at concat
12:14:41 <Sindriava> arkeet: that's more or less the definition of (>>=) for list monads, yes
12:14:47 <arkeet> yes
12:14:59 <shachaf> phadej: Type class constraints already ruin parametricity.
12:15:04 <centrinia> > [1..3] >>= (\x -> [x,x+10])
12:15:05 <lambdabot>  [1,11,2,12,3,13]
12:15:42 <arkeet> or if you liek:
12:15:46 <arkeet> do { a <- ...; [a,b,c] }
12:15:50 <arkeet> like*
12:15:53 <arkeet> instead of a list comprehension
12:16:17 <Cale> shachaf: In a more limited way though -- they're equivalent to additional function arguments, so you can account for them in a more uniform way.
12:16:28 <arkeet> (note the lack of return)
12:16:33 <phadej> rpfun: and you could write data type to close over instance, but then you'd need to be explicitly do so: `data EqOrOrd a where WithEq :: Eq a => a -> EqOrOrd a; WithOrd :: Ord a => a -> EqOrOrd a`
12:16:46 <phadej> shachaf: how it does, constraint is in the type, not invisible
12:16:51 <Sindriava> arkeet: Yeah, that's not really useful for what I'm doing, mconcat works well enough
12:18:21 <shachaf> Cale: I agree.
12:18:40 <phadej> shachaf: myfun :: Show a => a -> String, is the same as `myfun' :: (a -> String) -> a -> String`
12:18:45 <shachaf> I didn't say that you can do what rpfun was asking, just that "decidable type equality" isn't the reason as far as I can tell.
12:18:59 <Cale> ah, I missed the start of the conversation
12:19:01 <shachaf> phadej: It isn't really the same, though it's close.
12:19:18 <phadej> it is, only the amount of compiler doing work you differs
12:19:31 <phadej> *for you
12:19:44 <shachaf> Instances are globally unique for a particular type, for instance.
12:19:48 <aweinstock> it's also different because the actual Show uses difference lists internally (to handle lists of characters?)
12:19:54 <aweinstock> (or something like that)
12:19:57 <Cale> Yeah, what rpfun is asking for is a sign that one shouldn't be using type classes at all
12:20:22 <Cale> Just use an explicit function argument, and then you get to control what happens by hand.
12:21:19 <phadej> shachaf: true, `myfun` is even more restricted, when you think globally (that Show parameter is always the same).
12:22:33 <phadej> yet there is https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/other-type-extensions.html#implicit-parameters
12:22:36 <phadej> didn't tried yet
12:22:49 <shachaf> You keep talking about different things.
12:23:19 <phadej> but you cannot be sure that you don't go "type hasn't special ability", even if it has.
12:37:43 <prsteele> hello everyone. Question about QuickCheck... I seem to be getting a *lot* of zeros sometimes when I request a sequence of Doubles. This should never happen if we're actually flipping coins, so does anyone know if this is something QuickCheck does as an edge case?
12:40:25 <phadej> prsteele: can't try right now, but `sample` uses small generator sizes, so zero is highly likely to be there often
12:40:42 <phadej> prsteele: http://hackage.haskell.org/package/QuickCheck-2.8.1/docs/src/Test-QuickCheck-Gen.html#sample'
12:41:08 <prsteele> phadej: in my case I'm getting hundreds of zeros in a row. it actually might be infinite, since when I ask for a new sample when I get all zeros, my shell hung...
12:41:19 <prsteele> I'm starting to think its an issue with running tests in sequence
12:41:57 <phadej> prsteele: let's see
12:48:36 <phadej> prsteele: If I run `sample (arbitrary :: Gen Double)` I do get something random, not zeroes
12:48:46 <phadej> prsteele: are you sure you aren't genereting something else
12:49:17 <prsteele> ya, I'm pretty confident now I'm messing up something somewhere, now that I see how many I'm getting
12:50:35 <prsteele> the interesting thing is that I have a function, arbitraryFoo :: Gen [Double] which yields 'random' values when I call it with one proposition, but yields [0, 0, ...] when I call it with another proposition
12:51:33 <kazagistar> prsteele: I would guess it has to do with the QuickCheck size system
12:52:57 <kazagistar> prsteele: http://lpaste.net/138749
12:54:42 <prsteele> kazagistar: ya, if I throw a resize 10 in the problem goes away... any intuition on how I'm messing up the size to begin with, given that until now I never called resize?
12:56:39 <kazagistar> sample calls resize itself
12:57:00 <kazagistar> sample' g = generate (sequence [ resize n g | n <- [0,2..20] ])
12:57:20 <prsteele> hm. I'll look into it more, but for now "resize 10 (vector 123 :: Gen [Double])" does the trick
12:57:54 <prsteele> whereas just "vector 123 :: Gen [Double]" was yielding [0.0, ...]
12:59:17 <prsteele> thanks, everyone
12:59:32 <crobbins> is there an out-of-the-box way of decoding form-data from a bytestring?
13:04:10 <jeff_brown> Can I ask about FGL here? (I am new to IRC.)
13:04:21 <dmj`> crobbins: digestive functors
13:04:30 <dmj`> crobbins: maybe 'reform' too
13:05:06 <prsteele> jeff_brown: Maybe, what's FGL?
13:05:19 <jeff_brown> The functional graph library.
13:05:37 <jeff_brown> https://hackage.haskell.org/package/fgl
13:06:00 <prsteele> jeff_brown: then sure. In general just ask, don't ask to ask
13:06:15 <jeff_brown> How does gfold (graph fold) work?
13:07:32 <jeff_brown> I'm hoping it will let me do something like "find all the numbers in this node, and its children, and their children ... and add them all up."
13:08:02 <jeff_brown> It's in this part of the library: https://hackage.haskell.org/package/fgl-5.5.2.1/docs/Data-Graph-Inductive-Basic.html
13:09:38 <prsteele> jeff_brown: I think "Tree Operations" section might be more useful, at least for the example you gave 
13:10:11 <prsteele> jeff_brown: sum (postorder yourtree) ?
13:12:06 <jeff_brown> The Tree operations all expect to be handed a Tree. I will be operating on general graphs -- in fact, graphs with more than one kind of relationship. The gfold function takes an argument that lets you define the sense of direction -- for instance, "this node, and everything that uses it, and everything that uses those", where "uses" is a relationship.
13:12:08 <crobbins> dmj`, thanks, checking out digestive-functors, i just worry that it might be overkill
13:12:24 <Zepher> I realize this is probably a painfully rudimentary question for probably anyone in this chat, but why hypotenuser a b = [ (a,b,c) | a ==a , b == b, c == sqrt (a^2 + b^2)] does not work in Haskell? I realize there is a much simpler way to get Haskell to give me the hypotenuse in the form of a triple,  but I wanted to try it as a list comprehension. Can I not input values a b list that in a list comprehension form?
13:13:09 <Zepher> Can I not input values -a b- to a list comprehension form*?
13:13:12 <koala_man> Zepher: obviously something's weird with a == a
13:13:39 <Zepher> Do you mean the space?
13:13:44 <dmj`> crobbins: yea, it provides a lot of things ootb
13:13:47 <opqdonut> Zepher: for one you're not specifying where a, b and c come from
13:13:51 <geekosaur> that list comprehension looks wrong. for one, it doesn't seem to generate values, just test them
13:14:10 <geekosaur> and seems to not know the difference between the values it's testing
13:14:47 <opqdonut> > [ (a,b,c) | a <- [1..10], b <- [1..10], c <- [1..10], c == sqrt (a^2 + b^2) ]
13:14:49 <lambdabot>  [(3.0,4.0,5.0),(4.0,3.0,5.0),(6.0,8.0,10.0),(8.0,6.0,10.0)]
13:14:58 <opqdonut> Zepher: that's how you do it
13:15:11 <Zepher> Ah, that's how I had it before
13:15:19 <prsteele> > let hypo a b = head $ [(a, b, c) | c <- [1..], a * a + b * b = c * c] in hepo 3 4
13:15:27 <prsteele> > let hypo a b = head $ [(a, b, c) | c <- [1..], a * a + b * b = c * c] in hypo 3 4
13:15:46 <opqdonut> if you want a and b to be constant you can do what prsteele did
13:15:56 <Zepher> Can it be [1..]?
13:16:07 <prsteele> Zepher:  ya, but it might not terminate
13:16:21 <opqdonut> in the three-variable case it can't. b and c would be stuck at 1 for ever
13:16:25 <opqdonut> while a goes through 1..
13:16:45 <opqdonut> > [ (a,b,c) |  a <- [1..], b <- [1..], c <- [1..]]
13:16:46 <lambdabot>  [(1,1,1),(1,1,2),(1,1,3),(1,1,4),(1,1,5),(1,1,6),(1,1,7),(1,1,8),(1,1,9),(1,...
13:16:48 <opqdonut> like so
13:16:53 <Welkin> > [ (a,b,c) | a <- [1..10], b <- [1..10], c <- [1..10], c == sqrt (a^2 + b^2) ]
13:16:55 <lambdabot>  [(3.0,4.0,5.0),(4.0,3.0,5.0),(6.0,8.0,10.0),(8.0,6.0,10.0)]
13:17:05 <opqdonut> oh, sorry, _c_ will go through 1..
13:17:09 <Welkin> > [ (a,b,c) | a <- [1..10], b <- [a..10], c <- [1..10], c == sqrt (a^2 + b^2) ]
13:17:10 <lambdabot>  [(3.0,4.0,5.0),(6.0,8.0,10.0)]
13:17:15 <Zepher> Ah ok. But donut it seems like for your example if will give me a list of all those values
13:17:28 <Zepher> I can't input like for example 7 and 5
13:17:33 <Zepher> as values for a and b
13:17:44 <Zepher> and have it give me (a,b,c)
13:17:48 <webchat099_> test
13:18:10 <opqdonut> Zepher: if you want to do that, look at what prsteele said
13:18:31 <Zepher> What does the $ mean?
13:18:40 <opqdonut> oh that's just function application
13:18:52 <geekosaur> there it does nothing at all
13:18:59 <opqdonut> > let hypo a b = [(a, b, c) | c <- [1..], a * a + b * b = c * c] in hypo 3 4
13:19:03 <opqdonut> that's simpler
13:19:33 <opqdonut> you just get a list of 1 triple instead of the triple
13:19:41 <prsteele> Zepher: I wrote a $ because I hadn't thought through what I was going to write
13:19:57 <Zepher> I don't understand what in hypo 3 4 does
13:20:01 <Zepher> what does it do?
13:20:03 <opqdonut> also, a*a + b*b = c*c is a better test than c == sqrt (a^2 + b^2) because sqrt is a floating point operation and thus imprecise
13:20:04 <Welkin> opqdonut: lambdabot is not runing your expression
13:20:08 <Welkin> running*
13:20:09 <opqdonut> Welkin: I can see that
13:20:11 <johnw> it feels magical when I have a real reason to use recursive do
13:20:35 <mniip> > ""
13:20:37 <lambdabot>  ""
13:20:46 <opqdonut> Zepher: hypo 3 4 gives you all pairs (3,4,c) such that 3*3 + 4*4 = c*c
13:20:47 <prsteele> Zepher: let (some definitions) in (some statement). To make my example a 1-liner, I defined the function hypo in the (some definitinos) and then computed something in (some statement)
13:20:57 <Welkin> @let hypo a b = [(a, b, c) | c <- [1..], a * a + b * b = c * c]
13:20:57 <lambdabot>  Parse failed: Parse error: =
13:21:04 <Welkin> @let hypo a b = [(a, b, c) | c <- [1..], a * a + b * b == c * c]
13:21:05 <lambdabot>  Defined.
13:21:10 <Welkin> > hypo 3 4
13:21:14 <lambdabot>  mueval-core: Time limit exceeded
13:21:22 <broma0> what's the benefit of using mtl's classes over explicitly writing out the monads / transformer stacks for type signatures?
13:21:23 <prsteele> > head hypo 3 4
13:21:31 <prsteele> > head (hypo 3 4)
13:21:32 <lambdabot>  (3,4,5)
13:21:33 <prsteele> rather
13:21:39 <Zepher> oh I see
13:21:46 <geekosaur> hm, so we don't always get errors from the new lb?
13:21:51 <Zepher> you were inputting 3 and 4
13:21:57 <Welkin> geekosaur: it's a trap!
13:22:19 <Welkin> we have been infiltrated
13:22:22 <Zepher> I just got confused because it was all on the same line
13:22:34 <geekosaur> and hypo is going to time out if you request all values, since it doesn't know when to stop iterating [1..]
13:23:19 <mniip> > (syntax error
13:23:20 <lambdabot>  <hint>:1:14:
13:23:20 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
13:24:08 <mniip> > () ()
13:24:27 <mniip> type error then
13:24:58 <prsteele> > (1 :: Int) + (1.0 :: Double)
13:25:01 <geekosaur> int-e ^^
13:25:26 <geekosaur> @tell int-e lambdabot is not reporting type errors in @run / >
13:25:26 <lambdabot> Consider it noted.
13:26:31 <Zepher> Ok so I don't have to specify where what lists a or b belong to because I am inputting them, correct?
13:26:49 <Zepher> I just have to say where c is going to come from.
13:27:00 <Zepher> what lists*
13:27:07 <glguy> It might be nice if it only provided the error messages in /msg rather than to flood the channel when people make attempt after attempt to get something right
13:27:32 * geekosaur thinks it might rate-limit consecutive use by a single nick in channel
13:27:47 <mniip> > () ()
13:27:51 <mniip> nop
13:28:01 <geekosaur> and maybe a higher collective rate limit in a channel
13:28:18 <glguy> geekosaur: I tried ?run'ing something in /msg after you brought it up and didn't get a response
13:28:20 <mniip> > ()
13:28:22 <lambdabot>  ()
13:28:23 <mniip> > ()
13:28:25 <lambdabot>  ()
13:28:28 <mniip> > () ()
13:28:31 <mniip> nop
13:48:43 <Zepher> Anyway thanks guys.
13:48:51 <Zepher> How do I give brownie points?
13:49:05 <Welkin> Zepher: name++
13:49:19 <mniip> @karma+ Zepher 
13:49:20 <lambdabot> Zepher's karma raised to 1.
13:49:28 <arkeet> @karma name
13:49:28 <lambdabot> name has a karma of 2
13:49:31 <kadoban> Does #haskell have karma? Woh … how long has that been there
13:49:41 <arkeet> @karma C
13:49:41 <lambdabot> C has a karma of 2
13:50:07 <Welkin> @karma kadoban 
13:50:07 <lambdabot> kadoban has a karma of 5
13:50:13 <kadoban> O.o
13:50:19 <Zepher> opqdonut++
13:50:21 <Welkin> two of those are from earlier today in -blah
13:50:24 <mniip> @karma mniip
13:50:24 <lambdabot> You have a karma of 2
13:50:25 <glguy> kadoban: It's had it basically forever. It has also been reset in the past.
13:50:43 <kadoban> Welkin: Ohhh. I thought that was just an informal thing I guess. I didn't know the bot actually tracked it, heh.
13:50:43 <mniip> :\
13:50:59 <Welkin> @karma lambdabot 
13:51:00 <lambdabot> lambdabot has a karma of 29
13:51:02 <Zepher> @karma+ opqdonut
13:51:02 <lambdabot> opqdonut's karma raised to 4.
13:51:19 <Zepher> @karma+ Welkin
13:51:20 <lambdabot> Welkin's karma raised to 10.
13:51:38 <Welkin> Zepher: that raises the karma, exlude the + to view instead
13:51:59 <Zepher> @karma+ prsteele
13:51:59 <lambdabot> prsteele's karma raised to 1.
13:52:05 <Zepher> I know
13:52:10 <Zepher> You helped too
13:52:50 <Zepher> @karma+ geekosaur
13:52:51 <lambdabot> geekosaur's karma raised to 24.
13:53:48 <Zepher> Thanks guys.
13:53:51 <burp> @karma+ burp
13:53:51 <lambdabot> You can't change your own karma, silly.
13:54:07 <Zepher> @karma- lambdabot
13:54:07 <lambdabot> lambdabot's karma lowered to 28.
13:54:07 <Welkin> lol
13:54:10 <glguy> Zepher: It's not actually used for anything and it can be played with in /msg
13:54:11 <Zepher> hahahaha
13:54:29 <burp> @karma+ lambdabot
13:54:30 <lambdabot> lambdabot's karma raised to 29.
13:54:48 <Zepher> What doesn't do anything?
13:54:50 <Zepher> Karma?
13:57:24 <kyclark> Is there anything that would give me [[a,a]] -> [(a,a)], e,g, [[1,2],[3,4]] -> [(1,2),(3,4)]
13:57:37 <kyclark> A search on Hoogle for that sig gives nothing.
13:58:01 <arkeet> what do you do when the inner lists don't have length 2?
13:58:15 <centrinia> arkeet: n-tuples ;)
13:58:24 <arkeet> pls
13:58:25 <kyclark> Right, I can't answer that.  For now, I know they do, but it's the result of an IO so it could fail.
13:58:41 <arkeet> > (\[a,b] -> (a,b)) [1,2]
13:58:43 <lambdabot>  (1,2)
13:59:12 <arkeet> > map (\[a,b] -> (a,b)) [[1,2],[3,4],[5]]
13:59:12 <kyclark> Why couldn't I figure that out?  :-)
13:59:13 <lambdabot>  [(1,2),(3,4),*Exception: <interactive>:3:6-20: Non-exhaustive patterns in la...
13:59:27 <ttt_fff> tomjaguarpaw: can you enlighten a n00b on the difference between opaleye-postgresql vs opaleye-sqlite3? do they have the same features? or are there features lacking in one / the other
14:00:24 <mniip> map (liftA2 (,) head (head . tail))
14:00:35 <mniip> :t map (liftA2 (,) head (head . tail))
14:00:38 <lambdabot> [[a]] -> [(a, a)]
14:00:59 <arkeet> > map (\[a,b] -> (a,b)) [[1,2],[3,4,5]]
14:01:01 <lambdabot>  [(1,2),*Exception: <interactive>:3:6-20: Non-exhaustive patterns in lambda
14:01:04 <arkeet> > map (\(a:b:_) -> (a,b)) [[1,2],[3,4,5]]
14:01:05 <lambdabot>  [(1,2),(3,4)]
14:01:09 <arkeet> drops excess elements.
14:01:12 <arkeet> there is also
14:01:39 <arkeet> > [ (a,b) | [a,b] <- [[1,2],[3],[5,6]] ] -- just ignore lists of the wrong length
14:01:41 <lambdabot>  [(1,2),(5,6)]
14:02:14 <kyclark> I could try my hand at using Maybe
14:02:15 <kyclark> (\[a,b] -> (a,b))
14:02:25 <kyclark> sorry
14:02:26 <kyclark> split =  
14:02:27 <kyclark>   [a,b] -> Just (a,b)
14:02:28 <kyclark>   _     -> Nothing
14:02:32 <arkeet> sure
14:02:35 <int-e> mmm
14:03:12 * hackagebot target 0.2.0.0 - Generate test-suites from refinement types.  https://hackage.haskell.org/package/target-0.2.0.0 (EricSeidel)
14:13:39 <int-e> geekosaur: thanks, looks like another case of utf8 trouble, sigh...
14:14:01 <geekosaur> you and me both. just addressed one of those in #xmonad earlier today >.>
14:14:07 <int-e> > text "‘+’"
14:14:08 <lambdabot>  <hint>:1:8:
14:14:08 <lambdabot>      lexical error in string/character literal at character '\128'
14:18:13 <arkeet> > text "‘"
14:18:14 <lambdabot>  <hint>:1:8:
14:18:14 <lambdabot>      lexical error in string/character literal at character '\128'
14:18:16 <arkeet> :<
14:19:16 <arkeet> E2 80 98 in utf-8 yeah.
14:23:13 * hackagebot varying 0.1.1.2 - Automaton based varying values, event streams and tweening.  https://hackage.haskell.org/package/varying-0.1.1.2 (SchellScivally)
14:23:13 <zoto> !chk 111
14:35:44 <ttt_fff> at the cost of being kicked out for adultery:
14:35:52 <ttt_fff> what features of ahskell does frege lack?
14:36:20 <mniip> > () ()
14:36:32 <lambdabot>      Couldn't match expected type ‘() -> t’ with actual type ‘()’
14:36:39 <glguy> Let me google that for you: https://github.com/Frege/frege/wiki/Differences-between-Frege-and-Haskell
14:38:18 <Cale> I wonder why it would opt for a different comment syntax
14:38:30 <Cale> oh, no, that's just for docs
14:38:41 <int-e> > text "äöü"
14:38:50 <Cale> hm, probably should have just copied Haddock's convention there then
14:38:50 <lambdabot>  äöü
14:39:12 <mniip> > "ы"
14:39:20 <lambdabot>  "\1099"
14:39:23 <mniip> why so laggy
14:39:36 <int-e> it's still busy joining channels
14:39:41 <Cale> Maybe there was worry that you'd want different documentation text than Haddock documentation, which I suppose is fair.
14:39:49 <int-e> (and getting flooded with user lists)
14:40:01 <mniip> int-e, oh we talked about it, you can join multiple channels with one command
14:40:04 <ttt_fff> glguy: lol, was just reading that link after asking the question
14:40:21 <ttt_fff> glguy: have you tried frege yourself?
14:40:23 <mniip> and user lists can't take that long to parse
14:40:45 <int-e> Sorry, but I still don't care enough.
14:41:22 <mniip> :/
14:41:48 <int-e> > 1
14:41:55 <lambdabot>  1
14:42:25 <int-e> > 1
14:42:26 <lambdabot>  1
14:42:44 <Cale> It's probably not really worth optimising for something which is probably less than 0.01% of lambdabot's running time
14:43:04 <geekosaur> I did find that to be slow back when I ran one, but likewise didn't really care enough to try to debug
14:43:51 <Cale> But if you wanted to do it, I doubt a patch would be rejected :)
14:47:37 <int-e> Hmm, 0.1% may be more realistic (that's 5 minutes every 3-4 days...) but yeah.
14:48:06 <arkeet> lambdabot is restarted that frequently?
14:48:14 * geekosaur surprised by that, yeh
14:48:14 * hackagebot purescript 0.7.3.0 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.7.3.0 (PhilFreeman)
14:48:26 <int-e> most of the time it's freenode's fault
14:48:29 <arkeet> heh
14:48:43 <geekosaur> true, it never did recover well from being netsplit
14:51:24 <Peaker> GHC's RTS is using SIGVTALRM when my process is idle, wasting ~5% CPU constantly! :(
14:52:17 <int-e> Peaker: you can perhaps play with +RTS -C
14:52:36 <int-e> and -I as well
14:53:25 <Peaker> 50 context switches per second are enough to cost 5% CPU? or 3 major GC's per sec? wow
14:54:11 <gpyh> hi
14:54:37 <gpyh> I was wondering : do you have a solution when you want to define a N tuple when N is big?
14:54:42 <Peaker> +RTS -I0 -C1 <-- still 5% CPU
14:55:11 <HijiriPhone> gpyh: define a custom sum tyoe instead
14:55:14 <HijiriPhone> type
14:55:28 <int-e> Peaker: hmm, what kinbd of program is that?
14:55:40 <gpyh> actually, my question is wrong (because a tuple can hold different types): what is the best practice for fixed-length vectors
14:55:54 <Peaker> int-e: lamdu (IDE/gui)
14:56:09 <gpyh> My google skills gave me a quite thourough blog post that didn't help me much cause I'm too much of a rookie
14:57:11 <geekosaur> consider that GUI frameworks also like to have idle-time handlers
14:57:37 <HijiriPhone> vector package is often used for vectors
14:57:42 <Peaker> geekosaur: it's my own GUI framework :)
14:57:49 <Peaker> geekosaur: it's truly idle I'm pretty sure
14:58:04 <HijiriPhone> it has both vectors with and without type-safe indexing I think
14:58:11 <Peaker> (fixed a GLFW bug and disabled my config file sampling to make it truly idle)
15:00:26 <Peaker> even invoking: dist/build/lamdu/lamdu +RTS -I0 -C1   I see with strace that the RTS is spamming a huge amount of signals
15:00:36 <gpyh> HijiriPhone: thanks!
15:01:27 <geekosaur> odd... what ghc version?
15:01:27 <int-e> Peaker: oh -V should change the frequency of the VTALARM signals.
15:01:35 <geekosaur> wonder if there was a regression
15:02:09 <geekosaur> (7.2ish there was an RTS bug that was worked around with +RTS -V0 to disable the VTALRM stuff)
15:02:53 <Peaker> ah, yes, -V0 disables CPU use, but also makes threads not get any runtime, apparently
15:03:40 <geekosaur> now *that* sounds wrong
15:03:58 <Peaker> oh, maybe it's just super-slow because I compiled with profiling hoping it'd tell me what's wasting CPU time
15:04:04 <int-e> well, it does disable time based context switches
15:04:05 <Peaker> rebuilding without profiling (runs much faster)
15:04:46 <Peaker> I think the RTS ought to be "tickless" like the modern kernel.  wasting 5% at idle is terrible!
15:05:19 <Peaker> (or at least disable the signal if there are no threads to preempt)
15:05:42 <geekosaur> the master tick shouldn't have much to do if profiling isn't enabled
15:07:59 <Peaker> geekosaur: even when profiling disabled it wastes ~5% cpu
15:13:41 <koshmar> is there some analog of :clear for ghci?
15:14:09 <porges_> Ctrl-L
15:14:45 <porges_> as in Bash etc (it's a feature of the readline library)
15:15:01 <shapr> Has anyone come up with a list of compile-time and run-time GHC options for memory-constrained systems such as the Raspberry Pi 2?
15:15:34 <koshmar> great. thanks.
15:16:57 <mniip> I wonder if GC prediction is decidable in general
15:17:18 * geekosaur notes that ghci doesn't actually use readline, but a pure haskell clone of it ("thanks" os x and windows...)
15:18:12 <shachaf> I thought it was more along the lines of "thanks" GPL.
15:18:32 <glguy> thapl
15:18:46 <geekosaur> no, the problem was hard to get a usable readline lib on windows, and apple shipping a "readline" that isn't and breaks things if ghci build sees it
15:19:07 <geekosaur> especially the latter
15:20:46 <Sindriava> Is there a write-once variant of Reader?
15:20:56 <Sindriava> though I suppose I could use `local`
15:23:15 * hackagebot hdevtools 0.1.2.1 - Persistent GHC powered background server for FAST haskell development tools  https://hackage.haskell.org/package/hdevtools-0.1.2.1 (SchellScivally)
15:27:03 <Gurkenglas> @hoogle [a] -> (a, [a])
15:27:04 <lambdabot> Data.Text.Internal.Builder.RealFloat.Functions roundTo :: Int -> [Int] -> (Int, [Int])
15:27:04 <lambdabot> Data.Char readLitChar :: ReadS Char
15:27:04 <lambdabot> Language.Haskell.TH.Ppr split :: Type -> (Type, [Type])
15:27:13 <Gurkenglas> Where's the cons deconstructor?
15:28:08 <glguy> Data.List.uncons :: [a] -> Maybe (a, [a])
15:31:07 <mniip> Gurkenglas, the above function is not implementable in general
15:31:27 <mniip> (what would be the result if [] is the argument)
15:31:30 <Gurkenglas> head &&& tail
15:31:44 <arkeet> :(
15:32:09 <mniip> Gurkenglas, so, (bottom, bottom)
15:32:44 <Gurkenglas> When I ask for [a] -> a, you don't say "You can't implement that" :P
15:33:01 <mniip> "in general"
15:34:27 <arkeet> partial functions don't count.
15:34:41 <johnw> @djinn [a] -> a
15:34:41 <lambdabot> Error: Undefined type []
15:35:32 <johnw> it would have said, "no way"
15:36:11 <mniip> @djinn Maybe a -> a
15:36:11 <lambdabot> -- f cannot be realized.
15:36:13 <mniip> close enough
15:36:23 <Gurkenglas> Hah! Get djinn to work with recursive types and the same thing will happen as when chess computers disproved chess is a game of "creativity"
15:36:34 <johnw> huh?
15:37:00 <buff3r> hi, i'm trying to do a simple foldl to build up a data structure: data PersonEntry = PersonEntry Int64 Name Phone deriving (Show); for some params like let params = ["joe", "911"]
15:37:31 <johnw> foldl ($) PersonEntry ["joe", "911")
15:37:57 <johnw> it's not going to work unless all the arguments are of the same type, though
15:38:05 <buff3r> ah 
15:38:11 <mniip> johnw, it's not going to work ever
15:38:20 <johnw> mniip: hmm?
15:38:29 <Gurkenglas> :t foldl
15:38:30 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
15:38:35 <Gurkenglas> :t ($"joe")
15:38:36 <lambdabot> ([Char] -> b) -> b
15:38:41 <johnw> ah, right
15:38:47 <johnw> the type varies at each point
15:38:47 <mniip> :)
15:39:09 * johnw shouts "mniip" after the fashion of Kahn when Kirk has eluded him
15:39:40 <buff3r> hmm okay
15:40:04 <mniip> johnw, what o.o
15:40:17 * geekosaur wonders if Gurkenglas has met exferenceBot yet
15:40:33 <Gurkenglas> Oh, forgot about that one.
15:40:45 <mniip> whatsitdo
15:40:49 <buff3r> but i can do partial application.. let p = PersonEntry 1; let p' = p "joe"; let p'' = p' "911"
15:41:01 <johnw> buff3r: the types all differ
15:41:20 <Gurkenglas> I had some quick disillusionment about it, but I forgot why
15:41:37 <buff3r> well i should say the Name and Phone are both type alias to String, but perhaps they wouldn't be in a real life app
15:41:53 <johnw> I wonder if some HList magic could do this, but it certainly wouldn't be worth the effort
15:41:54 <mniip> buff3r, no
15:42:06 <Gurkenglas> buff3r, what stops you from applying all parameters at once?
15:42:14 <mniip> buff3r, String->PersonEntry and PersonEntry are different types
15:42:43 <buff3r> Gurkenglas: i guess i don't have a strong reason, maybe just laziness heh
15:43:01 <geekosaur> mniip, https://github.com/lspitzner/exference
15:43:56 <mniip> :exf (a -> a) -> a
15:45:19 <Gurkenglas> Ah yep I think that was it.
15:45:27 <buff3r> basically i'm doing a simple System.Environment.getArgs, so i have a list of parameters that would correspond to a program type.. is there a better way than: (PersonEntry 1) (params !! 0) (params !! 1) 
15:45:50 <buff3r> or maybe i should just pattern match early 
15:46:00 <exferenceBot> replying took too much time (60sec), aborting.
15:46:01 <buff3r> i'm trying to find a more idiomatic approach
15:46:17 <geekosaur> heh, didn't think it could infer fix
15:46:38 <geekosaur> or exfer, as the case may be >.>
15:47:38 <thepuma> hi guys, is there a way to short-circuit foldl?
15:47:49 <mniip> thepuma, foldr?
15:48:10 <johnw> @src foldl
15:48:10 <lambdabot> foldl f z []     = z
15:48:10 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:48:35 <thepuma> what's the best way to do it? I'm working with a list inside and I want to end up the computation when that list length doesn't grow too much (i.e. with a constant)
15:48:58 <johnw> use take before folding?
15:49:25 <thepuma> johnw something like take number $ foldl ..
15:49:28 <thepuma> ?
15:49:37 <johnw> > foldl' (+) 0 . take 1000 $ [1..]
15:49:39 <lambdabot>  500500
15:49:48 <johnw> it's OK if the list is <1000 elements
15:49:52 <johnw> take will then take whatever is there
15:49:57 <thepuma> mmm, I guess that not what i want
15:50:09 <johnw> can you try your question again then?
15:50:17 <thepuma> I'm growing the list inside the foldl
15:50:26 <johnw> use foldr
15:50:32 <johnw> never ever grow lists inside foldl
15:50:46 <johnw> if you use foldr, then it doesn't matter if your output is infinite
15:50:47 <thepuma> i'm using foldl'
15:50:55 <johnw> foldl' is not for (:)
15:51:11 <johnw> not unless you know exact why you'd do that, that is
15:51:34 <thepuma> ok, thanks, so using foldr I can just put the take inside the step function
15:51:42 <johnw> > take 10 $ foldr (:) [] [1..]
15:51:43 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
15:51:48 <johnw> let the user provide the take
15:51:55 <johnw> and leave the list infinite
15:52:19 <thepuma> johnw great ! :), thanks
15:52:24 <johnw> the beauty of Haskell's laziness is that we don't have to "fuse in" cutoffs like this
15:52:25 <arkeet> > foldl' (flip (:)) [] [1..10]
15:52:26 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
15:53:17 <JagaJaga> > take 20 $ foldl' (flip (:)) [] [1..]
15:53:22 <lambdabot>  mueval: ExitFailure 1
16:00:25 <arahael> So, I was looking, again, at the viability of using haskell as a cross platform language, and I'm not confident it makes sense when "cross platform" includes iOS and Android.  Can anyone challenge me on that, or suggest another language?
16:00:38 <arahael> I really don't want C++ to be the only realistically cross-platform language I can use.
16:01:26 <arahael> Or is haskell, _without_ template haskell, viable in this case?
16:01:52 <creichert> it will certainly take work, there are people that have done it
16:02:40 <mniip> I should write a haskell compiler
16:02:47 <arahael> creichert: I'm concerned about changing requirements, for instance, iOS dev now _requires_ 64-bit support - do we support 64-bit support on iOS?
16:03:04 <mniip> but, sometime later maybe
16:03:43 <creichert> arahael: i don't think so, but i'm getting my info from here:
16:03:49 <creichert> https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling/iOS
16:04:11 <creichert> it is a wishlist item but I admit i'm not 100% familiar with the ios cross compiling
16:04:34 <creichert> arahael: are you deploying mobile only? or mobile + desktop?
16:04:36 <arahael> creichert: Yeah, it doesn't fill me with confidence, though.  ghc is regarded as really dificult when it comes to cross compiling as well.
16:04:44 <arahael> creichert: I'm consiering deploying mobile + desktop.
16:05:01 <arahael> creichert: Thought experiment at this stage, mind you. ;)
16:05:02 <creichert> well that's not exactly trivial with the C++ i've worked with :)
16:05:06 <creichert> but certainly much more developed
16:05:28 <arahael> creichert: xcode for ios comes with a C++ compiler, so yeah, it's (relatively) trivial.
16:05:42 <arahael> creichert: And the NDK for android is also a C++ compiler.
16:05:51 <creichert> sure, but from one codebase?
16:05:57 <creichert> (I might misunderstand)
16:06:12 <arahael> creichert: I'm a competent developer.  Obviously some or all of the UI code will have to differ, though.
16:06:17 <creichert> most of the cross platform i've done with C++ was via Qt
16:06:45 <arahael> creichert: It's the "business logic" of the application I'm most concerned about.
16:06:49 <creichert> so i rephrase as it's hard to get the same ui code working well :) but i meant no offense
16:07:28 <arahael> creichert: Indeed, but this is a secondary concern. :)
16:08:15 <arahael> creichert: I suppose it might be clearer to suggest I'm looking for an ideal language to develop a cross platform _library_ in. ;)
16:08:54 <arahael> (And I do want that to be a functional language with fantastic type inferrence and strong typing)
16:09:34 <arahael> I'd probably pick purescript or something, actually, and just do it with javascript as the platform, except I need performance.
16:09:47 <creichert> one non-trivial project i know builds for android regularly is git-annex
16:11:03 <arahael> Wouldn't surprise me if that was ported as a classic linux application - git itself already works in android on the command line, and then they slapped a GUI on that.
16:11:18 <arahael> git is imlemented with a mixture of C and Perl, for the most part.
16:11:47 <buff3r> ididnt know git was running perl
16:11:47 <buff3r> cool
16:11:52 <creichert> https://github.com/neurocyte/ghc-android
16:12:30 <creichert> I'm just throwing some ideas out there, I feel like there would almost certainly be some limitations and some level of experimentation if you decided to try it out
16:13:48 <creichert> Somewhat recent discussion here too: 
16:16:05 <arahael> I think it's doable on android, for the most part, but again, no template-haskell, iirc.
16:16:18 <arahael> As for iOS, I notice this wishlist: ted/carc) has quit (Quit: QUIT)                                                                                                                                        │ adnap    
16:16:29 * arahael curses his cut&paste.
16:16:40 <arahael> ARM64 support (need support in LLVM, llvmCodeGen, Platform.hs, and calling conventions) 
16:16:49 <arahael> So no ARM64 for Haskell iOS.
16:17:03 <arahael> Isn't that a killer?
16:17:40 <creichert> I was trying to find some other resources because I thought that the ios support had improved recently. But it seems it would be
16:18:39 <arahael> creichert: Requirements to submit to the app store often includes things like: "Must be 64-bit, and compiled with iOS 8 SDK"
16:18:56 <creichert> ouch
16:19:40 <arahael> creichert: At least, I think it's now permitted to *talk* about such requirements(!)
16:20:17 <arahael> Btu anyway, so that's my concern.
16:20:44 <arahael> They also need to be fat binaries.
16:21:19 <arahael> swift looks like an option...  But it's not portable! (Doesn't do linux (yet), doesn't do android (yet?), doesn't likely do windows (ever?)
16:23:54 <kadoban> arahael: One way I thought of going is using sencha touch. That uses JS, but I thought maybe something with ghcjs? Not sure though, still kinda looking at it.
16:24:06 <arahael> kadoban: javascript on iOS is extremely slow.
16:24:11 <arahael> kadoban: No JIT, for instance.
16:24:22 <kadoban> arahael: I doubt it matters for most apps.
16:24:22 <arahael> kadoban: And you're not allowed to add one.
16:24:29 <arahael> kadoban: I'm actually thinking of games.
16:24:36 <kadoban> Yeah for games it wouldn't work.
16:24:54 <spicydonuts> I thought iOS 8/9 had JIT, not sure why though
16:24:55 <kadoban> I'd … never do a game anyway so it's more of an option for me. Just figuring out how to actually set it up nice is … difficult.
16:25:07 <erikd> anyone know if alex can lex Text input?
16:25:13 <arahael> kadoban: But you're right. For most apps it would be a viable solution, though I'd be tempted to consider purescript or seomthing else instead if I was depending on javascript.
16:25:25 <arahael> kadoban: That's another sigifnicant issue. :/
16:25:36 <kadoban> arahael: Well, my goal was to figure out how to do it via haskell with ghcjs.
16:26:04 <kadoban> arahael: No idea if that would even be practical though … just barely looking into it.
16:26:31 <arahael> kadoban: Ah, I played very briefly with that - did a helloworld on it a while ago. (last year?).  It was impressive, adn worked nicely.  produced a huge amount of JS code, though, but that can be managed for applications.  Not vialbe for websites, though, imho. (TOo much javascript)
16:27:15 <arahael> kadoban: I think ghcjs for platforms that have a good, fast js interpreter (such as v8 on x86), is a very viable and practical approach.  But phones and tablets are another beast, especially if they're ARM.
16:27:37 <arahael> kadoban: javascript on x86 is *stupid fast*.
16:28:43 <kadoban> arahael: Yeah speed is one of my concerns, but … my understanding would probably be that downloading it on mobile would probably take a while, but in terms of actual amount of code it's not much to just run. I'm currently kind of delaying hoping that ghcjs is supported better by stack before I play more with it, doing other small projects in the mean-time, heh.
16:28:53 <arahael> kadoban: So I might consider it even for games...   Except for iOS and to a slightly lesser degree, Android.
16:29:27 <arahael> kadoban: And since I articularly want to support iOS and Android, I'm having a very hard time justifying anything over C++. :(
16:29:34 <kadoban> I guess it depends just how bad JS is on android/ios, heh. If it feels laggy, that'd kinda suck. If it can feel okay for just normal GUI crap, that'd be fine for me.
16:29:47 <arahael> kadoban: Its' basically a regular, ordinary interpreter.
16:30:27 <arahael> kadoban: Whereas javascript on x86, depending on how it's written (eg, emscripten outputs asm.js), you can apparently achieve 2x the bare metal performance. It's that fast.
16:31:06 <mniip> arahael, did intel incorporate javascript optimizations into their cpus?
16:31:31 <kadoban> I think it's more that google and mozilla and friends have spent a ton of time optimizing the shit out of their engines.
16:31:34 <arahael> mniip: No, Google invested in a very good javascript compiler and JIT compiler.
16:31:45 <arahael> mniip: And likewise, Mozilla with their asm.js
16:32:08 <arahael> mniip: It's amazing what can be done with limitless money, in the case of google :)
16:32:57 <mniip> so basically
16:33:09 <arahael> mniip: So, do some reading about asm.js and javascript v8 (mozilla, and google, respectively)
16:33:21 <mniip> I know how those work
16:33:47 <mniip> they basically added assembly support to javascript by optimizing specific constructs to single instructions
16:34:00 <Peaker> is there a portable way to get the mtime?
16:34:09 <arahael> mniip: I think it's much more than that.
16:34:27 <Peaker> System.Directory gets the low-res modification time apparently?
16:34:47 <arahael> Peaker: low-res meaning 2 seconds? That _is_ the portable form.
16:35:06 <Peaker> oh, it does use hiRes when available
16:35:17 <FartsMcGee> [swift] ]OLI[ _6a68 __main__ _ashbreeze_ _di _flow_ _fritz_ _ikke_ _klm _sjs _slade_ `0660 aaron7 aaronm04 aarvar aatxe abbe abh abra0 abrar absence acfoltzer ackthet adarqui Adeon adimit Adios adlan adnap agjohnst_ agrif ahf ahihi ahungry aib aidanh akahn akuhlens AlainODea
16:35:17 <FartsMcGee> alang alanz albel727 alekst_ alem0lars alevy alexa_ alexlord aloiscochard alphonse23_ alpounet alynn amcoder amiller amiri_ amontez anachron anders0 anders^^_ anderson andjjj23 andreass_ Andrej_T andrewalker andrewsw andreypopp_ andyo Ankhers annulus anoe anohigisavay AntiSpamMeta Antoine59 apo_ arahael araujo arcanine arch__ arian0n arianvp
16:35:25 <geekosaur> right. 2s for non-NTFS Windows (or for FAT filesystem on any platform)
16:35:40 <ackthet> the fuck
16:35:40 <geekosaur> 1s for general POSIX compatibility
16:35:48 <ackthet> oh another spammer
16:35:54 <arahael> ackthet: Ignore it.
16:36:07 <geekosaur> freenode already klined it
16:36:10 <arahael> ackthet: We don't want to hear about people _talking_ about the spammers.
16:36:42 <ackthet> i was just wondering why i got pinged in here
16:38:23 <arahael> creichert: I'm increasonally of the opinion that whatever I use, should be compilable to C.
16:38:53 <arahael> creichert: But haskell doesn't really support it's unregistered transpilation support (compiling to C)
16:39:06 <arahael> And the other compilers that explicitly do, like YHC, seem dead.
16:39:09 <geekosaur> ghc doesn't. jhc compiles to ansi c
16:39:23 <arahael> *JHC
16:39:36 <arahael> Isnt it a dying project?
16:40:01 <geekosaur> some people apparently believe so. meacham hasn't had time for it of late but others have been working on it?
16:40:44 <arahael> AJHC is already dead.
16:42:03 <geekosaur> looks like uhc is still actively developed (repo on github) but your definition of dead would imply that anything that is not ghc is dead
16:42:14 <geekosaur> and maybe ghc is dead too because it doesn't use a C backend any more
16:42:17 <arahael> Actively maintained.
16:42:44 <arahael> And no, ghc is very much alive - just doesn't support the C backend.
16:43:02 <arahael> (And indeed, the C backend isn't even enabled by default as an option, anymore, iirc)
16:43:14 <kadoban> arahael: Do you actually need the C backend? Don't you more need cross-compilation?
16:43:35 <arahael> kadoban: Either way, yes.  But note that for iOS, I would need 64-bit support, _and_ to use a particular SDK.
16:43:55 <kadoban> Is 64-bit support a problem? (I have no idea)
16:44:12 <arahael> kadoban: It's required for acceptance into the app store, from what I can tell.
16:45:01 <kadoban> arahael: K, but is it … hard for GHC or something? I mean there's obviously 64-bit support on amd_64 or whatever we call x86 in the 64-bit world now.
16:45:41 <arahael> kadoban: 64-bit ARM support, with whatever funkiness iOS may or may not require.
16:45:56 <kadoban> Ya, GHC doesn't have that?
16:46:25 <arahael> kadoban: Apparently not.
16:46:31 <kadoban> Oh :-/
16:46:49 <Cale> Also, compiling via C with GHC didn't produce working C code. The assembly output from GCC had to be mangled in order to make the program work.
16:47:44 <Cale> (There was an Evil Mangler perl script which did tons of architecture-specific regex substitutions on the assembly)
16:48:12 <arahael> I'm hoping that ghcjs would eventually _finally_ allow a means of supporting template-haskell even when cross copmiling, but then, we'd still need a way to emit usable C or C++ code.
16:48:14 <kadoban> That sounds … fun.
16:48:39 <kadoban> Cale: I can't imagine why nobody wanted to keep supporting that XD
16:48:45 <arahael> I'm late for work. :(  Gotta cycle (though only 10 min...)
16:50:40 <Cale> kadoban: http://www.cs.virginia.edu/~wh5a/personal/House-0.8.92/ghc-6.8.2/driver/mangler/ghc-asm.lprl
16:51:45 <kadoban> Cale: Just that first bit of documentation … hurts.
16:52:09 <hpc> lprl? literate perl?
16:53:20 <Cale> hpc: yep
16:53:44 <hpc> oh god it is
16:54:45 <hpc> just realized that's the ghc mangler
16:55:29 <hpc> it does a lot of gross stuff with $_
16:59:26 <hackrilege> im considering representing my cyclic tree as a Map, but i fear that the traversal will be less fast. as my operation are over smmall local subtrees i require a fast nearest neighbour accessor, which i would like to know if it is faster with a Tree or a Map
17:04:54 <pacak> hackrilege: First make something that works. Then if it's not fast enough - start thinkging about optimizations.
17:06:14 <gpyh> is there an operator to do composition 'the other way'? I very much enjoy 'piping' because it makes something easier and I want to know if there is a canonical way to do it
17:06:30 <gpyh> s/something/coding
17:07:48 <pacak> :t (&)
17:07:50 <lambdabot> a -> (a -> b) -> b
17:07:54 <pacak> :t (.)
17:07:55 <lambdabot> (b -> c) -> (a -> b) -> a -> c
17:08:54 <arkeet> :t (>>>)
17:08:56 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
17:09:03 <Axman6> :t (|>)
17:09:04 <lambdabot> Snoc s s a a => s -> a -> s
17:09:08 <Axman6> hmm
17:09:18 <pacak> gpyh: But your code will be harder to read for others if you use something strange.
17:09:20 <arkeet> > (+10) >>> (*2) $ 1
17:09:22 <lambdabot>  22
17:09:59 <gpyh> 'piping' is rarely used in code?
17:10:10 <arkeet> most people just use .
17:10:21 <pacak> gpyh: Check the hackage.
17:10:26 <gpyh> (thanks for all the answers btw, sadly they're hardly googlable :p)
17:11:42 <buff3r> :t (>>>)
17:11:43 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
17:15:33 <mek42> Is haskell suited for generating graphs and testing them for isomorphism?
17:19:15 <comprehension> mek42: suitable?
17:19:44 <pacak> mek42: You can do that in haskell.
17:21:01 <mek42> thank you pacak .  I'm sure I have quite a bit of learning to do before I get there, but I have a project in mind that will need that.
17:22:02 <mek42> comprehension: Making sure I'll be able to try that in haskell eventually.
17:22:12 <pacak> mek42: Might take more learning than you expect :)
17:23:10 <mek42> pacak: How scared should I be, lol.
17:23:20 <pacak> :t confusing
17:23:21 <lambdabot> Applicative f => LensLike (Data.Functor.Kan.Rift.Rift (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
17:25:06 <mek42> Well, if I don't try to learn what I need to, I'll certainly never succeed at this project I have in mind.
17:25:47 <glguy> confusing (_2 07. _head) 07:: Traversal' (Int,String) Char
17:27:29 <mek42> Is there a beginner sub-irc for #haskell?
17:27:43 <shachaf> No.
17:27:54 <shachaf> #haskell is intended to be suitable for beginners.
17:28:09 <pacak> There is
17:29:00 <arkeet> there is also #haskell-beginners 
17:29:22 <shachaf> Despite the misleading name, that channel is unaffiliated with #haskell.
17:29:38 <shachaf> The existence of that channel doesn't mean that #haskell isn't intended to be beginner-friendly.
17:29:48 <arkeet> both channels are good
17:30:10 <arkeet> I believe the other channel was meant to accompany https://github.com/bitemyapp/learnhaskell
17:30:13 <arkeet> or something
17:30:29 <shachaf> Well, I don't recommend it.
17:31:16 <mek42> If I am interested in coding graph isomorphism in haskell eventually, is there some math I should be reading about also?
17:33:47 <srhb> shachaf: Are you not recommending it or are you recommending against it (and if so, why?)
17:33:52 <hackrilege> pacak: do you know which is faster at accessing neighbours, a Tree or a Map?
17:34:11 <KaneTW> a map is based on a tree in haskell
17:34:25 <dramforever> neighbours hmm...
17:34:32 <KaneTW> should be O log n
17:34:57 <dramforever> that sounds like a zipper
17:35:10 <kadoban> KaneTW: Well, there's more than one way to do it, though that's what Data.Map is.
17:35:14 <hackrilege> thats what i thought
17:35:19 <hackrilege> the zipper...
17:35:24 <pacak> hackrilege: I think Map. But again - first implement something that works.
17:35:33 <hackrilege> i dont see how Data.Map is a tree...
17:35:41 <dramforever> hackrilege: Why do you want to do that?
17:35:48 <KaneTW> kadoban: well, yeah, Data.Map
17:35:53 <kadoban> hackrilege: How it's implemented internally.
17:35:56 <dramforever> do you need to access other stuff quickly too?
17:35:56 <hackrilege> pacak: im just concerned by why you think i wouldnt have...
17:36:18 <hackrilege> other stuff?
17:36:33 <dramforever> like indexing quickly
17:37:01 <hackrilege> id like to be able to map over my structure, finding its nearest neighbours and then performing a calculation on the data stored in them.
17:37:19 <dramforever> its'?
17:37:37 <hackrilege> im not sure if reindexing is a priority.
17:37:37 <pacak> fgl?
17:38:05 <hackrilege> it = my data structure, be it Map or Tree or some other thing
17:38:30 <hackrilege> sorry, it would be the element
17:38:42 <dramforever> that's a bit weird...but sounds possible
17:39:21 <dramforever> there's a Data.Sequence that allows you to do persistently amortized O(1) cons/uncons and persistently amortized O(log N) indexing
17:39:32 <dramforever> maybe you can make a zipper with that
17:39:33 <hackrilege> so in a tree i would store a list of neighbours, which would be trees, i could easily access my neighbours. but in a map i store a list of indexes, the index retrieval would have to be blindingly fast to keep up with the tree no?
17:40:00 <dramforever> store a list of neighbours? do you mean siblings?
17:40:18 <shachaf> srhb: I was hoping to leave that ambiguous.
17:40:26 <srhb> shachaf: Sorry about that. :-)
17:40:46 <hackrilege> also with a tree i dont need indexing... or at least thats how it feels... like i say i get O(1) nearset neighbour access for free with a Tree...
17:41:08 <dramforever> hackrilege: IIUC two nodes are siblings if they share the same parent
17:41:13 <dramforever> is that what you want?
17:41:48 <asciiascetic> hackrilege: do you mean you're using a tree to store neighbor information about arbitrary graphs? E.g. if node 1 has neighbors 2,3,4 then (mymap ! 1) returns [2,3,4] ?
17:41:51 <mek42> dramforever: Maybe hackrilege means neighbors = {parent, children} (I hope I'm remembering set notation even close to correct)
17:42:00 <hackrilege> neighbour siblings, whatever, they are the list of Trees in data Tree a = Tree a [Tree] | End a 
17:42:21 <dramforever> tip: that End a isn't useful at all
17:42:54 <dramforever> you could easily do Tree blah []
17:42:54 <hackrilege> oh yeh can just have an empty list
17:42:57 <dramforever> =)
17:43:24 <dramforever> hackrilege: so what do you mean by neighbours again?
17:43:48 <hackrilege> ok so anyway, it seems to me that Map could not extract the list of Tree that is stored there as quickly as i could by getting it from a Tree
17:44:32 <Euryale> is there an idiomatic way to take all the elements less than a certain value from an infinite list of increasing value?
17:44:46 <arkeet> takeWhile (< x)
17:44:56 <Euryale> arkeet: thank you
17:44:58 <dramforever> hackrilege: now it seems that Data.Map isn't suitable at all
17:45:20 <arkeet> > takeWhile (< 1000) (iterate (*2) 1)
17:45:22 <lambdabot>  [1,2,4,8,16,32,64,128,256,512]
17:45:28 <hackrilege> suppose Tree Vec3, and that all cartesian nearest neighbours were stored as the subtrees at a node (data Tree a = Node a [Tree a])
17:46:26 <hackrilege> so I began investigating the lens library and eventually wound up at Map...
17:46:52 <mek42> arkeet: your takeWhile example also calculated 1024 and then stopped calculating?  Is this correct understanding of lazy?
17:47:06 <hackrilege> this was because my tree should be able to refer to itself, as it can contain closed loops, or "cycles"
17:47:07 <arkeet> more or less
17:47:52 <hackrilege> mek42: it kind of didnt "stop calculating" it was never asked to perform calculations after that point
17:48:08 <dramforever> hackrilege: now it seems that a Tree isn't even enough
17:48:08 <Cale> mek42: Even if the rest of the list were undefined, it would still work:
17:48:08 <hackrilege> not like it was looping and it hit a break
17:48:11 <dramforever> you need a graph
17:48:27 <hackrilege> dramforever.yes
17:48:41 <hackrilege> i need a graph! horay"
17:48:45 <Cale> > takeWhile (<20) (1 : 2 : 4 : 8 : 16 : 32 : undefined)
17:48:45 <dramforever> I like reasoning about lazy stuff using outmost reduction
17:48:46 <lambdabot>  [1,2,4,8,16]
17:49:22 <dramforever> but it's kinda boring...
17:49:55 <hackrilege> but anyway, my problem really is that i dont understand exacly about how slow this access is, like with an IntMap i need to find the index which is so costly... how is the graph solving that? and if it isnt then im stuck with a tree...
17:50:02 <hackrilege> so i thought I could make a zipper...
17:50:03 <mek42> ty - just making sure I'm thinking right with the simple example :)
17:50:17 <dramforever> hackrilege: with graph you can focus on a node
17:50:21 <dramforever> and go around
17:50:25 <dramforever> just like a zipper
17:51:04 <hackrilege> it stores pointers to neighbours like a tree? 
17:51:18 <dramforever> dunno
17:52:04 <hackrilege> argh
17:52:30 * dramforever doesn't know much about purely functional graph storing data structures
17:53:27 <hackrilege_> i was hoping actually that somehow a tree would be slower than a map
17:53:58 <hackrilege_> i guess i need someone who understands the implementation of Map quite well...
17:54:33 <hackrilege_> kadoban, you were saying that internally a Map is a Tree?
17:54:45 <mek42> shouldn't a list of pointers to neighbor nodes be part of a graph node?  I'd imagine something like: node_data, [*neighbor_nodes] (forgive my horrible syntax mixture)
17:54:55 <mniip> hackrilege_, a bit more than that
17:54:56 <mniip> but yes
17:54:57 <dramforever> "The implementation of 'Map' is based on /size balanced/ binary trees (or -- trees of /bounded balance/) as described by:"
17:55:07 <dramforever> "Stephen Adams, \"/Efficient sets: a balancing act/\", --     Journal of Functional Programming 3(4):553-562, October 1993, --     <http://www.swiss.ai.mit.edu/~adams/BB/>."
17:55:35 <dramforever> said thesource code of Data.Map.Base
17:55:38 <dramforever> *the source
17:55:40 <kadoban> hackrilege_: Yes. I don't know particularly what kind, but they're some kind of balanced BST
17:56:14 <dramforever> oh sorry there's another reference
17:56:22 <hackrilege_> hmm, so even though the syntax of map feels like it should be slower than a tree, it may be actually faster?
17:56:32 <dramforever> J. Nievergelt and E.M. Reingold "Binary search trees of bounded balance" SIAM journal of computing 2(1), March 1973.
17:56:41 <kadoban> hackrilege_: … the syntax feels like it should be slower? What does that mean?
17:56:49 <hackrilege_> i have those two papers referenced already!
17:56:55 <Cale> hackrilege_: Profile first, ask questions later.
17:57:01 <kadoban> hackrilege_: It's pretty fast for general use.
17:57:03 <dramforever> exactly =)
17:57:40 <dramforever> Cale: over-optimizing considered harmful =)
17:57:58 <hackrilege_> because when i look at the element of the map, if i have stored in it a list of my neighbours, then i will have to look each of them up by its flag, but this seems slower than just looking at the list of trees stored at each node of a tree... that just feels faster...
17:58:12 <dramforever> hey you guys
17:58:23 <dramforever> are you sure a Map could satisfy hackrilege_?
17:59:09 <kadoban> I'm sure he's caring if it will or not far too soon.
17:59:21 <hackrilege_> Cale: im not sure what you mean, but thanks
17:59:24 <maerwald> it's difficult to reason about performance in haskell. some things you may expect to be slow could be fast. I'd say it takes fiddling and experience, instead of just looking at O-notation
17:59:29 <kadoban> Try it, if it's too slow, profile it. If it's the problem, find a different data structure.
18:00:22 <hackrilege_> kadoban, im absolutely not, i must write up my rationality in full immediately upon making a decision, I have one task, to make fast code.
18:00:32 <Cale> hackrilege_: I mean, if you want to know what's faster, write the program and see.
18:00:55 <Cale> You can't really know for sure until you write the code.
18:01:01 <hackrilege_> no i need to understand why, as i can avoid that stage for countless alternatives with understanding
18:01:10 <dramforever> Cale ++
18:01:25 <maerwald> errr... as already said: it's difficult to reason about time and space performance in haskell
18:01:29 <maerwald> especially here
18:01:32 <Cale> It's not just in Haskell
18:01:35 <dramforever> I just rewrote a program to use tail recursion
18:01:39 <dramforever> now it's slower
18:01:44 <Cale> This would be just as true if you were trying to decide on a data structure to use in C.
18:01:45 <dramforever> so I know that well
18:01:48 <maerwald> Cale: not only, but especially
18:01:54 <dramforever> Cale ++
18:02:06 <mek42> hackrilege_: I'm reading to file stuff away for my own graph project - are you just asking about speed now or are you also trying to figure out what data structure will solve your problem of accessing all "neighbors" (which I take to mean as all adjacent nodes, or parent and children in a tree)?
18:02:09 <mniip> dramforever, that does nothing
18:02:12 <kadoban> hackrilege_: That's fairly hard to believe. Speed is /never/ the only consideration.
18:02:24 <maerwald> nah, there are differences to C, a lot when it comes to reasoning about performance
18:02:27 <kadoban> hackrilege_: Even if it is, just write something, see what's slow, speed that up.
18:02:28 <maerwald> even SPJ admitted that
18:02:33 <Cale> Unless you know what the program *is*, you can't possibly analyse which data structure is going to be better. You don't know what operations are performed and how often.
18:02:40 <dramforever> mniip ++
18:02:54 <mniip> dramforever, that too does nothing
18:03:00 <hackrilege_> Cale, i happen to know those things. 
18:03:02 <Cale> The best you can do is a rough guess.
18:03:12 <dramforever> mniip: so sad
18:03:17 <Cale> But once you have a rough guess like "Data.Map will probably be fairly decent"
18:03:25 <hackrilege_> im going round a graph performing a metric on subregions 
18:03:51 <Cale> it just comes down to running the program and seeing, or at least *writing* the program, before you can have a careful look at what operations are performed to figure out anything about how it'll perform
18:04:33 <hackrilege_> but i can compile it all in my mind, its small, so when you say i havnt written it, i would argue infact i have
18:04:53 <kadoban> hackrilege_: … is this a troll?
18:05:00 <maerwald> he can compile haskell in his head?
18:05:07 <asciiascetic> kadoban: I was thinking the same thing... 
18:05:21 <asciiascetic> for some time actually
18:05:23 <hackrilege_> i need to traverse elements for example, i need a fast way of doing so.
18:05:31 <dramforever> hackrilege_: not trust us you don't know for sure
18:05:50 <dramforever> *no, trust us
18:06:05 <asciiascetic> traversal, if you are visiting every element, will never be better than O(n), so.....
18:06:26 <dramforever> so now I think there's one last problem
18:06:46 <dramforever> how is hackrilege_ supposed to use that Data.Map
18:07:04 <maerwald> import it in his mind
18:07:05 <hackrilege_> hey look, sorry if that sounded stupid, but i hear "go away and write it" far too much, there is a reason im asking because infact writing alone would not solve my problem, i have a conceptual hole, i dont need to work further to identify it, my confusion is over the relative accessors, im just asking about that. 
18:07:07 <asciiascetic> what data structure is hackrilege_ trying to force into Data.Map?
18:07:32 <dramforever> tree zipper?
18:07:41 <dramforever> or rather a graph zipper
18:07:49 <dramforever> sorry, yes it's graph zipper
18:08:23 <hackrilege_> yeh its a graph zipper
18:08:32 <hackrilege_> if i understand zipper enough
18:09:00 <mek42> does zipper just mean at least one cyclic traversal through the structure?
18:09:44 <hackrilege_> ok not compile in my head, type check.
18:11:10 <maerwald> I'd just use GHC... it does both, type check and sompile.
18:11:46 <asciiascetic> hackrilege_: speaking of types, what does the type signature of your hypothetical function look like?
18:11:49 <hackrilege_> by the way the problem is chemical relaxation of a polymer network, the local environment of each molecule in the polymer chain will vary continuously and influence the force of this part of the chain on its neighbours  
18:12:32 <Cale> I've used Data.Map and Data.IntMap as a graph representation quite a few times with beyond-acceptable performance. I think it's definitely worth trying.
18:12:56 <Cale> It'll likely be the easiest representation to set up and operate on.
18:13:02 <mek42> lol, hackrilege_ I'm a chemist too, well, an industrial hygienist now, but trained as a PChemist and worked prior in analytical
18:13:35 <Cale> It's probably better to try other representations once you know more about how things are performing with Data.Map, and where the bottlenecks seem to be.
18:13:50 <hackrilege_> relax :: PolymerNetwork -> Timestep -> PolymerNetwork. a key portion of this is some zipper that examines the local environment of each element and accordingly updates its sate
18:14:42 <asciiascetic> hackrilege_: oh I see, so O(n log(n) m), where m is the number of neighbors, or something close to that?
18:15:10 <asciiascetic> hackrilege_: if I understand your problem even approximately, that is what Data.Map will give you
18:15:12 <maerwald> yep, Data.IntMap is pretty decent, used it too for some graph like thing, combined with regular lists
18:15:15 <Cale> If you have a graph with fixed structure whose labelling is changing a lot, then perhaps consider storing the adjacency structure of the graph in an Array of Sets, or even a 2D UArray of Bools.
18:15:43 <Cale> But if you're changing adjacencies ever, then Map is the first go-to representation, I'd say.
18:16:12 <hackrilege_> Cale: your direction is that which i would take were i not interested in communicating my understanding of the mechanisms most relevant to the performance i anticipate. but really this is a flame war now i feel so im going to go
18:16:38 <asciiascetic> really? I feel like we're getting somewhere now
18:16:48 <dramforever> we are finally getting somewhere
18:16:48 <hackrilege_> thanks for your input everybody, ill reprt back with benchmarks later
18:16:59 <dramforever> oh that's even more somewhere, great!
18:17:28 <hackrilege_> asciiascetic: yeh sorry, sometimes this place gets me frustrated 
18:17:45 <asciiascetic> hackrilege_: low bandwidth medium, hard to say everthing we mean.
18:18:01 <hackrilege_> i feel it
18:18:50 <hackrilege_> its not like i havnt spent 2 weeks learning lens just to get to the bottom of how this library works or anything
18:19:07 <mek42> hackrilege_: it is very important to make sure we are hearing what you mean, else folks will tell you to do something wrong and you'll be more frustrated - being able to communicate with people outside your domain is a skill that is in far too short supply
18:21:44 <hackrilege_> i think very often on this channel it is presumed that addressing some problem other than the one being asked is more relevant than the actual answer being sought.
18:22:15 <hackrilege_> ok over and out
18:22:51 <kadoban> Maybe you're just really bad at actually taking advice.
18:22:58 <asciiascetic> kadoban: hey!
18:23:07 <asciiascetic> we all get frustrated.
18:23:12 <asciiascetic> and defensive
18:23:43 <asciiascetic> but yeah, better communication is definitely key.
18:23:50 <dramforever> maybe hackrilege isn't good at explaining that polymer stuff to us
18:24:14 <lethjakman> so I have a stack project, how do I install Network.Mail.Mime?
18:24:17 <asciiascetic> dramforever: agreed. I still only have a vague notion of the question.
18:24:29 <lethjakman> I tried putting it in my extra-deps, but it just threw a faild po parse field
18:24:40 <mek42> I'll have the same communication problem later, but will stick around and be willing to take long time to acheive mutual basic understanding
18:26:00 <asciiascetic> mek42, I wonder how that could've gone better for hackrilege_? I do think that IRC is a "you get out what you put in" kind of place.
18:26:56 <mek42> I don't think that he really understands how differently chemists and mathemeticians/CSs think/speak from each other
18:27:06 <asciiascetic> I suspect you're right.
18:27:40 <mek42> and it is hard to communicate outside your domain - way too few folks have that skill
18:27:47 <asciiascetic> lethjakman: paste?
18:28:10 * geekosaur has actually been hovering on the edge of "are they trolling or do they just really want to do it the only way they know and must be told how to accomplish that instead of figuring out how Haskell-think works"
18:28:12 <sm> lethjakman: find which package that's in (eg at http://hoogle.haskell.org) and add *that* 
18:28:17 <mek42> does he come here often?
18:28:59 <asciiascetic> geekosaur: how do you emote?
18:29:11 <dramforever> geekosaur: I don't think hackrilege is trolling, though
18:29:18 <geekosaur> "poorly", beyond that don't ask...
18:29:18 <mek42> asciiascetic: /me
18:29:23 <dramforever> maybe
18:29:34 <asciiascetic> yuk yuk yuk
18:29:55 * geekosaur is sufficiently autistic that that's a much harder question than you'd think
18:30:00 <dramforever> =)
18:30:30 <geekosaur> no, trolling went through my mind with some of the earlier encounters though
18:31:55 <mek42> also, if he is a polymer guy, especially if a synthetic polymer guy, (as opposed to a computational guy looking at polymers) his math is proabably very poor relative to this channel - more from lack of formal training - even if he is a computational chemist, the math background is going to be much less than even a physicist experimentalist
18:31:57 <asciiascetic> its the feeling of sophisticated underspecification in hackrilige_'s questions that made me wonder, but I think mek42 is on the money.
18:32:36 <dramforever> mek42: I think he's pretty confident somehow
18:32:58 <mek42> confidence /= ability
18:33:10 <dramforever> somehow
18:33:28 <asciiascetic> dramforever: its hard not to be if you've got a few big projects under your belt, but none that were humblingly large. 
18:33:43 <dramforever> yep
18:34:02 <mek42> would it be at all helpful for me to try to explain his domain at this point?
18:34:06 <dramforever> perhaps he's got a really nice way to simulate polymer growth
18:34:07 <dramforever> who knows
18:34:29 <dramforever> I don't even know for sure what "polymer" is
18:34:35 <asciiascetic> mek42: sure, maybe paste it?
18:34:48 <asciiascetic> I'm curious anyway.
18:34:53 <dramforever> wait
18:35:02 <dramforever> maybe go to #haskell-blah?
18:35:16 <dramforever> <sarcasm>or #haskell-polymer</sarcasm>
18:35:30 <mek42> ok, blah it is
18:35:30 <geekosaur> "plastics" from a chemical standpoint. it's quite the discipline from that angle
18:37:26 <dramforever> wait I think I learnt about polymer a while ago
18:37:39 <dramforever> but just some really simple stuff
18:38:16 <geekosaur> probably belongs in -blah at this point...
18:38:30 <geekosaur> actually polymers are anything that can be linked together chemically. which includes rather more than just plastics; DNA and proteins are natural polymers
18:38:33 <dramforever> yes I'm already there
18:38:52 <geekosaur> hm, I saw a join and a leave, missed you rejoining
18:39:24 <hackrilege> yeh sorry about that
18:39:30 <dramforever> geekosaur: just accidentally closed the window, and I forgot to add -blah to my keep-joined list
18:44:19 <lethjakman-l> asciiascetic sm: https://gist.github.com/lethjakman/0d219730b216be223d8e
18:53:21 <porges_> hmm, is this a thing anywhere? https://gist.github.com/Porges/3397c4c8bd7c938d1a1d
18:57:45 <asciiascetic> lethjakman-l: I noticed that mime-mail is in lts-3.0, is there a reason you can't use lts-3.0?
18:58:11 <lethjakman-l> asciiascetic: lts?
18:58:20 <geekosaur> porges_, for at least that example it seems kinda pointless; laziness means that you can usually just stuff [show 1, show "2", show '3'] in the list
18:58:24 <lethjakman-l> also I added it to the cabal file and it's working
18:58:29 <lethjakman-l> however I'm not really sure what the difference is
18:58:31 <porges_> geekosaur, yes, dummy example
18:59:07 <geekosaur> lethjakman-l, lts as in stackage long-term-support branch
18:59:49 <Cale> In most cases you can avoid existentials altogether for the reason that you can do something analogous to what geekosaur did with show there, but yeah, that's kind of an interesting type.
18:59:52 <asciiascetic> lethjakman-l: its what you put in the resolver field in the stack.yaml
19:00:04 <hackrilege> @let strand n = Data.Graph.buildG (1,n) $ take (n-1) $ zip [1..] [2..]
19:00:06 <lambdabot>  Defined.
19:00:18 <hackrilege> > strand 3
19:00:19 <lambdabot>  array (1,3) [(1,[2]),(2,[3]),(3,[])]
19:00:50 <hackrilege> can anyone give me a zipper over this graph?
19:02:09 <asciiascetic> lethjakman-l: you might read https://github.com/commercialhaskell/stack/wiki/stack.yaml for clarity about what the stack.yaml file is for
19:04:20 <dramforever> hackrilege: https://hackage.haskell.org/package/fgl-5.5.2.1/docs/Data-Graph-Inductive-Graph.html#t:DynGraph
19:04:42 <dramforever> I found this interesting thing
19:04:43 <hackrilege> thanks!
19:04:55 <dramforever> and this fold https://hackage.haskell.org/package/fgl-5.5.2.1/docs/Data-Graph-Inductive-Graph.html#v:ufold
19:04:59 <dramforever> that could do what you want
19:05:07 <dramforever> although I'm not sure how to use them
19:06:43 <hackrilege> looks good. 
19:07:32 <dramforever> yep
19:07:33 <gpyh> hi again ; what would you advise me to do when confronted to a data structure in bijection with Z/nZ ? Is there a typeclass for that?
19:10:33 <asciiascetic> gpyh: you need to do ring arithmetic? 
19:11:54 <asciiascetic> gpyh: thinking about bijections alone isn't very helpful. Any collection with n elements would do. Do you mean your structure is isomorphic?
19:12:37 <dramforever> gpyh: can you give an example?
19:12:52 <dramforever> that seems to be something like Enum
19:12:59 <dramforever> and Bounded
19:14:03 <gpyh> I did a Enum+Bounded+Eq implementation of this
19:14:17 <gpyh> Basically I have a hexagonal board
19:14:27 <gpyh> each hexagon is a Tile
19:14:39 <gpyh> this tile is actually 6 triangles
19:14:49 <gpyh> one for each side of the hexagon
19:15:37 <gpyh> I have a data Direction = A | B | C | D | E | F deriving (Enum,Bounded,Eq)
19:15:51 <gpyh> I can rotate inside a Tile thanks to this
19:16:07 <gpyh> now let's say I want to move from a tile to another given a direction
19:16:19 <ReinH> gpyh: there's a package for grids that includes hexagonal ones
19:16:36 <ReinH> Also there's a Group typeclass
19:16:58 <ReinH> Being in bijectino with Z mod n isn't very interesting by itself
19:17:12 <gpyh> ReinH: I've seen the Grid package but it's not what I'm looking for ; however the Group thing might interest me
19:17:17 <asciiascetic> ReinH: hah. thats exactly what i said!
19:17:39 <gpyh> it's not in itself but it can save me a lot amount of work
19:17:55 <ReinH> Without any additional structure you're just saying "it has n elements"
19:17:57 <gpyh> if you map A to -2, C to 0, F to 3
19:17:59 <ReinH> how?
19:18:03 <gpyh> (I let you find the other)
19:18:08 <ReinH> Right, well, the that's additional structure I was referring to
19:18:12 <gpyh> you end up with Z/6Z
19:18:26 <ReinH> Well, you get that by virtue of having 6 elements
19:18:28 <ReinH> what else do you want?
19:18:34 <ReinH> do you want the group structure?
19:18:41 <ReinH> then you can use the group typeclass
19:20:05 <gpyh> (I just jumped into Haskell, I have a strong Math background but FP is a discovery, I need to wrap my head around a lot of concepts)
19:21:36 <mek42> are <- and `elem` equivalent?
19:21:48 <dramforever> no reason
19:21:55 <arkeet> mek42: no
19:21:59 <dramforever> they aren't even the same thing
19:22:06 <arkeet> <- is syntax, elem is a function
19:22:15 <dramforever> `elem` is a function that's been turned into an operator
19:22:35 <dramforever> mek42: wait so is there any context?
19:22:43 <dramforever> list comprehension?
19:22:45 <broma0> where does one draw the line between passing arguments and using a reader?
19:22:55 <arkeet> I assume list comprehension.
19:23:18 <mek42> arkeet yes, list comprehension - reading that section here: http://learnyouahaskell.com/starting-out
19:23:50 <mek42> specifically this line of code: removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
19:24:09 <arkeet> c <- st is the part that takes elements from the list st
19:24:18 <arkeet> `elem` is just an operator
19:24:22 <arkeet> that returns a Bool
19:24:38 <arkeet> for filtering out elements
19:25:33 <nitrix> Could be simplified as    removeNonUppercase = filter isUpper
19:25:39 <mek42> ok, I think I'm getting it now - I got confused because I didn't realize at first that was a function declaration
19:25:49 <dramforever> oh =)
19:26:03 <dramforever> welcome to the concise syntax of haskell
19:26:07 <nitrix> > filter isUpper "HeLLoWoRlD"
19:26:09 <lambdabot>  "HLLWRD"
19:26:37 <hackrilege> does anyone know any instances of Data.Graph.Inductive.Graph
19:26:38 <hackrilege> ?
19:26:43 <arkeet> mek42: yeah, there are a few kinds of clauses you can use on the right side of a list comprehension
19:26:46 <AshyIsMe> mek42: are you playing around in ghci while you read lyah?
19:27:15 <mek42> AshyIsMe: will soon, haskell just finished emerging for me
19:27:16 <arkeet> stuff like p <- l, where p is a pattern (including a variable), and l is a list
19:27:24 <arkeet> or you can put a boolean expression
19:27:44 <arkeet> or you can put "let" statements, but those are less common
19:28:06 <arkeet> p <- l selects elements from the list l.
19:28:26 * hackagebot base-orphans 0.4.4 - Backwards-compatible orphan instances for base  https://hackage.haskell.org/package/base-orphans-0.4.4 (ryanglscott)
19:28:33 <arkeet> boolean expressions remove elements when they result in False
19:28:54 <mek42> so p <- l means to use each element in list l as a value wherever p is called?  more or less?
19:29:01 <arkeet> something like that.
19:29:12 <nitrix> mek42: It gives an alias to each member of the list.
19:29:44 <arkeet> if you are following lyah I highly suggest playing around with things in ghci a lot.
19:29:48 <hackrilege> mek42, do you understand what is the | opperator inside the list comprehension?
19:29:59 <arkeet> hackrilege: that's not an operator.
19:30:07 <dramforever> arkeet ++
19:30:11 <mek42> I will, but I couldn't while haskell was still emerging :)
19:30:12 <hackrilege> oops
19:30:13 <nitrix> mek42: Your list comprehension could be built from two other lists, for example:  [(a,b) | a <- firstList, b <- secondList]
19:30:17 <arkeet> it's just syntax, like <-
19:30:23 <geekosaur> it can be read roughly as "where" or "such that"
19:30:30 <dramforever> syntax, syntax everywhere
19:30:40 <geekosaur> or in Python terms, "for"
19:30:46 <dramforever> actually I almost never use list comprehension
19:30:54 <arkeet> > [ a + b | a <- [1..5], b <- [10,20,30], even a ]
19:30:56 <lambdabot>  [12,22,32,14,24,34]
19:31:03 <hackrilege> arkeet, so is the <- in the list comprehension different from say in a do block?
19:31:11 <geekosaur> it's different but related
19:31:17 <dramforever> hackrilege: more or less
19:31:26 <mek42> the | means (sort of) fill with whatever meets the following criteria
19:31:37 <arkeet> hackrilege: when translating from list comprehensions to do notation, <- becomes <-
19:31:52 <hackrilege> also we find the | before an = in a function decleration, is it the same as in the list comprehension?
19:31:57 <Cale> If you're reading in English, you'd probably read the | as "such that"
19:32:14 <arkeet> hackrilege: but they have different contexts so I can't really say they're "the same"
19:32:18 <nitrix> hackrilege: List comprehensions are sugar on top of `do`, if I recall correctly.
19:32:18 <arkeet> same thing for guards
19:32:23 <geekosaur> in fact you can translate any list comprehension into a do expression, although the list comprehension translated directly will be simpler than the equivalent  monadic list operation
19:32:34 <Cale> e.g. [ a + b | a <- [1..5], b <- [10,20,30], even a ] might be read as "the list of a + b such that a comes from [1..5], b comes from [10,20,30], and a is even."
19:32:39 <geekosaur> nitrix, only if MonadComprehensions extension is enabled
19:33:33 <arkeet> if you've seen set builder notation from mathematics (e.g. { f(x) | x ∈ A, x < 10 } or something)
19:33:38 <hackrilege> hmm
19:33:40 <arkeet> then list comprehensions should be somewhat familiar
19:33:48 <arkeet> it's just <- instead of ∈
19:34:16 <hackrilege> i guess i should leanr how to write a haskell interpreter 
19:34:24 <mek42> i'm one course shy of a master in math - and I got the notation, just missed that they went from let / evaluate to a function definition
19:34:32 <rlewis> <- looks like ∈ if you squint a bit
19:34:33 <arkeet> ok.
19:34:39 <Axman6> hackrilege: that would be quite complex...
19:35:01 <geekosaur> learning graph reduction the hard way
19:35:13 <nitrix> [a for b in range(c) if d]      [a | b <- c, d]
19:35:15 <hackrilege> but its worth it for the women
19:35:37 <hackrilege> that was ironic...
19:35:51 <geekosaur> also dubious
19:36:14 <SrPx> Will "fmap (* 2) (fmap (* 3) int_map)" create intermediate structures? How can I can tell?
19:36:25 <mek42> hackrilege: are you a chemist or a CS?
19:36:32 <arkeet> SrPx: yes, but
19:36:38 <Axman6> SrPx: "maybe"
19:36:43 <dramforever> SrPx: maybe
19:36:48 <Axman6> there's lots of buts
19:36:49 <hackrilege> anyway that set builder notation is what haskell so appealing to the noob, its a shame the sugar is quickly lost 
19:36:50 <arkeet> well, maybe it gets optimized away.
19:36:58 <SrPx> Not Maybe, IntMap
19:37:02 <hackrilege> whats a CS?
19:37:05 <arkeet> but even if it doesn't, it's possible that the entire intermediate structure won't exist at once.
19:37:13 <mek42> computer science
19:37:22 <SrPx> arkeet: due to laziness ?
19:37:27 <nitrix> How can you be a computer science, lol.
19:37:33 <arkeet> SrPx: yeah
19:37:33 <dramforever> hackrilege: "sugar is quickly lost" huh?
19:37:35 <Axman6> I don't believe GHC actually implements a rule for fmap f . fmap g = fmap (f . g) because it's possible for people to write unlawful Functor isntances, and that transformation may break them
19:37:38 <arkeet> consider lists
19:37:38 <hackrilege> applied maths actually 
19:37:49 <SrPx> Axman6: aw :(
19:37:57 <arkeet> Axman6: not in general, but it might work for specific instances.
19:38:06 <dramforever> Axman6: I don't believe it's possible to write general rules like that
19:38:13 <dramforever> or am I wrong?
19:38:16 <hackrilege> dramforever no1 uses list comprehensions really...
19:38:28 <Cale> I use list comprehensions.
19:38:37 <Cale> There are a lot of places where they're pretty nice.
19:38:38 <hackrilege> great stuff!
19:38:40 <arkeet> no one uses list comprehensions, except the people who use list comprehensions.
19:38:44 <dramforever> yes
19:38:45 <rlewis> they are sometimes the cleanest way to express something
19:38:53 <nitrix> dramforever: As far as I know, no. You'd need a formal proof verification system for that, ala Adga or something.
19:39:05 <dramforever> nitrix: what?
19:39:05 <hackrilege> yeh, its great syntax, the more the merrier 
19:39:05 <Axman6> A&&!A
19:39:10 <dramforever> what happened
19:39:25 <Cale> One really cute degenerate case is where you want to optionally include elements in a list if some condition holds, you can write  [foo | cond1] ++ [bar | cond2]  etc.
19:39:27 <dramforever> nitrix: what are you referring to?
19:39:49 <dramforever> :t liftA2 (&&)
19:39:49 <Cale> Because the list [foo | cond1] is [foo] in the case that cond1 holds, and [] otherwise
19:39:50 <lambdabot> Applicative f => f Bool -> f Bool -> f Bool
19:40:03 <dramforever> oh wow
19:40:05 <nitrix> dramforever: Functor laws are just commonly agreed upon, they aren't enforced.
19:40:09 <dramforever> > [2 | False]
19:40:09 <rlewis> > [x | Just x <- [Nothing, Just 10, Just 20]]
19:40:11 <lambdabot>  []
19:40:11 <lambdabot>  [10,20]
19:40:14 <dramforever> nitrix: no I didn't mean that
19:40:35 <dramforever> I mean maybe the optimizer can't handle general rules like that
19:40:41 <dramforever> by general I mean with typeclasses
19:40:59 <rlewis> > [x^2 | Just x <- [Nothing, Just 10, Just 20]]
19:41:01 <lambdabot>  [100,400]
19:41:12 <nitrix> Oh, if you're talking about optimizations, then I've no clue where you were going with that.
19:41:19 <dramforever> me too
19:41:22 <dramforever> I don't know for sure
19:41:27 <Cale> Yeah, there's another really nice usage -- filtering the Justs out of a list like that
19:41:36 <arkeet> :t catMaybes
19:41:37 <lambdabot> [Maybe a] -> [a]
19:41:39 <Cale> Also, you can do things like:
19:41:49 <arkeet> > mapMaybe (^2) [Nothing, Just 10, Just 20]
19:41:49 <nitrix> rlewis: It does pattern matching too?
19:41:50 <lambdabot>      No instance for (Show b0)
19:41:50 <lambdabot>        arising from a use of ‘show_M849063953691558288217565’
19:41:50 <lambdabot>      The type variable ‘b0’ is ambiguous
19:41:52 <dramforever> :t maybeToList
19:41:53 <arkeet> oops.
19:41:54 <lambdabot> Maybe a -> [a]
19:41:58 <rlewis> it is more general than that though. pattern matching failure - ignore the element
19:41:58 <Cale> > [(x,y) | (x:xs) <- tails [1..10], y <- xs]
19:42:00 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,3),(2,4),(2,5),(2...
19:42:01 <nitrix> rlewis: That's genuinely cool.
19:42:11 <rlewis> nitrix yeah
19:42:14 <Cale> > [(x,y) | (x:xs) <- tails [1..3], y <- xs]
19:42:15 <lambdabot>  [(1,2),(1,3),(2,3)]
19:42:16 <arkeet> > mapMaybe (fmap (^2)) [Nothing, Just 10, Just 20]
19:42:17 <lambdabot>  [100,400]
19:42:21 <AaronFriel> Here's a fun puzzle:
19:42:39 <arkeet> Cale: nice.
19:42:39 <dramforever> > (\xs -> [a | Just a <- xs]) [Nothing, Just 2, Just 4, Nothing, Just 5]
19:42:41 <lambdabot>  [2,4,5]
19:42:42 <dramforever> nice
19:42:48 <AaronFriel> Find where in the GHC User Guide the specification for module exports is.
19:43:08 <arkeet> dramforever: I'd just use catMaybes there.
19:43:09 <Cale> AaronFriel: It's in the Haskell Report
19:43:13 <dramforever> arkeet: yes
19:43:25 <Cale> I wouldn't expect it to be in the GHC User's Guide
19:43:30 <AaronFriel> Cale: It really seems like the GHC user guide should include something like that, since it's pretty comprehensive on other "Basic things"
19:43:31 <Cale> Is it there somewhere?
19:43:44 <AaronFriel> I've never had to go to the Haskell Report to check something, fwiw
19:43:56 <Cale> The GHC User's Guide talks about the basics of extensions, but not the syntax of the language, generally.
19:44:09 <AaronFriel> It talks at length about compiling and using GHC to produce programs
19:44:16 <AaronFriel> It even says "Look here's a module, compile it with this"
19:44:24 <Cale> Like, you won't find an explanation of the syntax of function declarations in there.
19:44:27 <AaronFriel> Sure sure
19:44:36 <AaronFriel> But modules are covered in depth in the GHC user guide
19:44:50 <hackrilege> > concat $ map (\a->a:[a|a<3]) [1..6]
19:44:55 <lambdabot>  [1,1,2,2,3,4,5,6]
19:45:00 <AaronFriel> Except how to export things.
19:45:01 <Cale> Sure, it's just that GHC doesn't modify the syntax of module declarations at all from how it is in the Report.
19:45:18 <Cale> If it did, the User's Guide would probably have a section on how GHC did things differently
19:46:05 <nitrix> I have a very broad question; I'm sorry if I sound biased, but... while I encourage the GHC extensions because that's how we can improve the compiler and develop new idioms for the language, doesn't that sort of partition the language a lot? I'm not very keen of languages that can only be compiled by their reference compiler.
19:46:20 <arkeet> what is the reference compiler?
19:46:26 <nitrix> GHC I suppose?
19:46:26 <arkeet> ghc is the de facto standard haskell compiler.
19:46:44 <arkeet> other haskell compilers have specialized purposes
19:46:45 <mek42> how would I turn ordinal written numbers into integers?  I'm thinking (pseudocode) [ n | (n"rd",n"th",n"nd",n"st") ["21st","24th","82nd","101st","42nd","53rd"]] 
19:46:46 <hackrilege> AaronFriel: im sure i found it recently, but maybe it was in amongst some things for cabal
19:47:22 <mek42> ^missing a <- between ) and [
19:47:25 <Ralith> mek42: takeWhile isNumber?
19:47:28 <nitrix> arkeet: But why would someone use these extensions instead of a library?
19:47:29 <hackrilege> your pseudocode hurts
19:47:31 <AaronFriel> hackrilege: Yeah, I just wanted to see if I could selectively not export something from a type class, but exports don't have a 'hiding' option for the (..)
19:47:37 <Cale> > reads "42nd" :: [(Integer,String)]
19:47:39 <lambdabot>  [(42,"nd")]
19:47:45 <Ralith> or that
19:48:07 <nitrix> arkeet: I've done C for couple years and you basically want to avoid using implementation-specific features as much as possible.
19:48:18 <AaronFriel> > reads "42rd" :: [(Integer, String)]
19:48:19 <lambdabot>  [(42,"rd")]
19:48:20 <hackrilege> oh god how are you drawing out that tuple, on please use better pseudocode
19:48:22 <Cale> You may want to check that the taily bit is actually the right one
19:48:25 <AaronFriel> so maybe you should check it :P
19:48:26 <nitrix> So that's puzzling me. I see GHC extensions all over the place on hackage.
19:48:49 <nitrix> That breaks portability :(
19:48:50 <Cale> nitrix: Language extensions are part of the standard too.
19:48:57 <Cale> nitrix: At least since Haskell 2010
19:49:11 <Cale> nitrix: and several of them are described by the standard
19:49:11 <anohigisavay> i want to apply a function :: a -> IO Bool to a filter
19:49:14 <AaronFriel> nitrix: Many of the extensions are now part of the standard, but are considered extensions to allow support for Haskell 98, and intermediate stages between 98 and 2010
19:49:34 <AaronFriel> nitrix: And GHC itself is essentially an ongoing research project that happens to be used for serious work by some people
19:49:50 <AaronFriel> nitrix: So the extensions are ways of "trying out" new ideas within a robust compiler
19:49:52 <Cale> nitrix: It's nice for implementations to be able to say "I support X, Y, and Z language extensions" and for code to be clear about which extensions it makes use of as well
19:50:01 <hackrilege> AaronFriel: why are you doing this it dosent make sense... if you dont instantiate some method of the class the class wouldnt be instantiated! why would you want to hide the abstract methods of your class!?
19:50:05 <anohigisavay> say `any matcher myList` but matcher doesn't return Bool but IO Bool
19:50:17 <mek42> ok, let me wrestle with that read function, gave me an idea
19:50:27 <Cale> All the remotely popular implementations of Haskell apart from GHC also implement many of the extensions.
19:50:32 <nitrix> Yeah, but then it partition Haskell into those language supersets that can't really be called haskell anymore, no?
19:50:42 <Cale> nitrix: Nah, it's all Haskell.
19:51:10 <hackrilege> > 2**(read "2.123")
19:51:12 <lambdabot>  4.355988061344426
19:51:32 <nitrix> I don't know, I guess I'm just emptying my chest. It does scare me, but I'll try to ignore it for the moment.
19:51:40 <Cale> I mean, yeah, it does partition the language, but it helps make clear which implementations are going to be able to build any piece of code, and it makes it clear(er) to language implementors what needs to be done in order to get their implementation to build any given piece of code.
19:51:41 <ttt_fff> does hasound, haskore, or any haskell music synthesis libraries work on OSX ?
19:51:46 <AaronFriel> hackrilege: Yeah it didn't make sense but I thought I'd express frustration at not seeing module exports in the user guide.
19:52:00 <nitrix> As long as it doesn't end up like Python 3.
19:52:17 <AaronFriel> nitrix: Almost all extensions interoperate with others, and even when deprecated, they usually simply fall out of style
19:52:23 <geekosaur> that was what happened between 1.4 and 98 :)
19:52:32 <Cale> nitrix: Realistically, you'll probably only ever use GHC and/or GHCJS
19:52:36 <Cale> (at least for now)
19:52:38 <geekosaur> (which is gradually being undone)
19:52:42 <nitrix> There's a GHCJS ;o !
19:52:52 <AaronFriel> nitrix: A lot of thought is put into the extensions these days. You're much more likely to see breaking changes between versions because of base library changes than extensions.
19:53:11 <hackrilege> ttt_fff i played around with some sound stuff... not on OSX though
19:53:13 <Cale> The community is probably still a bit too small to really support a second language implementation effort as sophisticated as GHC.
19:53:13 <nitrix> AaronFriel: Cale: geekosaur: That's comforting.
19:53:30 <AaronFriel> nitrix: Speaking of, the major breaking change for most people between 7.8.x and 7.10.x was a base library change, not an extension.
19:53:44 <hackrilege> there was something about unix incompatibility with windows for me...
19:54:13 <AaronFriel> nitrix: And it was an easy fix, just a pain point for everyone upgrading packages.
19:54:23 <geekosaur> one issue you run into with windows is that most Haskell devs are on unixlikes, so windows is often not well supported
19:54:35 <echo-area> Oh, version numbers like 1.4 and 98, 2010 reminds me about Microsoft's version scheme
19:54:38 <geekosaur> with respect to OS X it's more that apple's ecosystem is weirdly antagonistic
19:54:43 <hackrilege> tell me about it!
19:55:04 <AaronFriel> geekosaur, hackrilege: I use a VM an X windows remoting to develop on "Windows"
19:55:11 <AaronFriel> and* X Windows remoting
19:55:24 <Cale> echo-area: SPJ even works at MS research :)
19:55:40 <AaronFriel> I get the benefit of being able to run Sublime on Linux, and use its nice plugins too.
19:55:48 <srobert> Question: Is leksah still in active development?
19:55:50 <hackrilege> i guess the root of the audio stuff is the binding to push information to the speaker or headphone out... would we need to use wxwindows for that?
19:55:53 <Cale> srobert: yes
19:55:53 <nitrix> Second question, I hear a lot about the sophistication of GHC. Just how sophisticated is it?
19:56:00 <AaronFriel> (Sublime on Windows works, but most Haskell and Rust plugins do not work well and were designed for Linux first.)
19:56:16 <srobert> Cale: Thanks. I'm building it on FreeBSD now. I should have asked sooner.
19:56:25 <pacak> Nobody uses windows those days.
19:56:44 <AaronFriel> nitrix: GHC is pretty sophisticated. It supports multiple backends (somewhat), multiple OSes, and so on and so forth. It can compile directly to assembly, or use LLVM for code generation.
19:56:49 <hackrilege> ill check sublime 
19:57:19 <hackrilege> no thats not audio
19:57:23 <hackrilege> oops
19:57:52 <mek42> > [ fst reads data | data <- ["21st","24th","82nd","101st","42nd","53rd"] ]
19:57:53 <AaronFriel> nitrix: I'm personally of the opinion that there's bloat - there's a lot of abstraction going on that could stand to have some postdoc come by and clean things up
19:57:53 <lambdabot>  <hint>:1:13: parse error on input ‘data’
19:58:04 <Cale> nitrix: I'm not sure how to answer that, but it's been under very active development for 16(?) years or so
19:58:07 <hackrilege> just rename that variable
19:58:09 <AaronFriel> nitrix: The stages of compilation for Haskell are very interesting
19:58:48 <mek42> > [ fst reads data :: (Integer,String) | data <- ["21st","24th","82nd","101st","42nd","53rd"] ]
19:58:49 <lambdabot>  <hint>:1:13: parse error on input ‘data’
19:59:01 <AaronFriel> nitrix: As far as being technically sophisticated, in terms of what it can do, there are a lot of programming languages now taking heed of Haskell and learning from its successes.
19:59:20 <hackrilege> does anyone know how to interface with hardware in haskell? e.g. to read data in from a microphone or usb port as a stream?
19:59:26 <AaronFriel> nitrix: And its type system lets you safely do things no other language can provide safely
19:59:34 <Welkin> hackrilege: FFI?
19:59:36 <AaronFriel> hackrilege: I'd imagine you'd use FFI
19:59:38 <dramforever> FFI
19:59:39 <hackrilege> lol
19:59:46 <dramforever> no I mean FFI
19:59:46 <AaronFriel> Welp all aboard the ffi train
19:59:47 <nitrix> AaronFriel: Agreed. If you avoid partial functions.
19:59:49 <hackrilege> oh what noooo
19:59:51 <geekosaur> http://hackage.haskell.org/package/usb
20:00:00 <AaronFriel> nitrix: Yes, but I'm talking about things like STM
20:00:12 <AaronFriel> nitrix: Software Transactional Memory - many programming languages have tried to implement it and failed
20:00:13 <nitrix> Oh yeah, that's apparently another big thing.
20:00:23 <nitrix> I haven't touched concurrency yet.
20:00:23 <hackrilege> thanks geekosuar!
20:00:26 <AaronFriel> nitrix: The fundamental problem is that they can't encapsulate effects strongly enough
20:00:40 <Welkin> hackrilege: https://hackage.haskell.org/packages/#cat:Hardware
20:00:52 <AaronFriel> nitrix: Concurrency is one place where Haskell shines
20:00:58 <mek42> > [ fst head reads data :: [(Integer,String)] | data <- ["21st","24th","82nd","101st","42nd","53rd"]]
20:01:00 <lambdabot>  <hint>:1:18: parse error on input ‘data’
20:01:09 <AaronFriel> nitrix: Another is, esp. if you're coming from the Java or C# world, often performance
20:01:21 <geekosaur> mek42, "data" is a keyword
20:01:37 <mek42> geekosaur: ah, ok
20:01:42 <AaronFriel> nitrix: Java is notoriously memory inefficient. It's not uncommon to hear about people running servers using the JVM with 48-192 GB of memory because of incredibly inefficient RAM usage
20:01:52 <AaronFriel> nitrix: (C# is almost always better thanks to value types)
20:02:07 <AaronFriel> nitrix: But it's pretty rare for me to write equivalent Haskell programs that use more than a few tens of MB of memory
20:02:07 <mek42> > [ fst head reads thingeemadoo :: [(Integer,String)] | thingeemadoo <- ["21st","24th","82nd","101st","42nd","53rd"]]
20:02:07 <hackrilege> if i need FFI for the speakers do i need it for the screen?
20:02:08 <geekosaur> actually it is possible that ghc might allow its use there; haskell-src-exts's parser is often not as flexible
20:02:08 <lambdabot>      Couldn't match expected type ‘(ReadS a1
20:02:08 <lambdabot>                                     -> [Char] -> [(Integer, String)],
20:02:08 <lambdabot>                                     b0)’
20:02:27 <geekosaur> hackrilege, depends on what you want to do with it
20:02:35 <Welkin> hackrilege: you can use something like SDL for that too
20:02:53 <mek42> > [ fst reads thingeemadoo :: [(Integer,String)] | thingeemadoo <- ["21st","24th","82nd","101st","42nd","53rd"]]
20:02:55 <lambdabot>      Couldn't match type ‘String -> [(a0, String)]’
20:02:55 <lambdabot>                     with ‘([Char] -> [(Integer, String)], b0)’
20:02:55 <lambdabot>      Expected type: ([Char] -> [(Integer, String)], b0)
20:03:05 <geekosaur> character output is fine. addressible character output (terminal style) requires ffi on windows (console control is done via a control interface), but not on unix (special escape sequences are used)
20:03:06 <hackrilege> > read "21st"
20:03:07 <lambdabot>  *Exception: Prelude.read: no parse
20:03:17 <geekosaur> graphics requires ffi or something that ultimately uses the ffi
20:03:17 <Cale> > [n | (n,s):_ <- map reads ["21st","24th","82nd","101st","42nd","53rd"]] :: [Integer]
20:03:19 <lambdabot>  [21,24,82,101,42,53]
20:03:34 <srobert> I'm waiting for someone to say thingeemadoo is a keyword.:-)
20:03:46 <hackrilege> lol
20:03:49 <mek42> srobert: lmao
20:04:32 <geekosaur> sound requires ffi, because setting sound parameters (bit rate, sample width, etc.) requires custom calls, not simply writing data to a file handle of some kind
20:05:38 <hackrilege> Welkin: hey, SDL looks great thanks
20:05:39 <Cale> Of course, most I/O stuff ultimately invokes FFI, because, well, just how much of an OS do you want GHC to put into your program's runtime system? :)
20:05:59 <AaronFriel> Cale: Some people would say the whole thing
20:06:09 <mek42> Cale: ty - though I haven't gotten to map yet - anyhow, I need to go to bed about an hour ago :)
20:06:19 <Cale> oh, in that case...
20:06:30 <hackrilege> geekosaur  could stream it out a network socket, i thought it would be trivial to put it out the speaker... 
20:07:13 <hackrilege> well really we should all run on a standard virtual machine which the compiler should be designed to target
20:07:17 <Cale> > [n | str <- ["21st","24th","82nd","101st","42nd","53rd"], (n,s) <- take 1 (reads str)] :: [Integer]
20:07:18 <geekosaur> it's not trivial, no. even very basic sound stuff requires what I cited. fancier sound systems (e.g. 5.1 or 7.1 audio systems, which you do find on high end hardware) require even more configuration
20:07:19 <lambdabot>  [21,24,82,101,42,53]
20:07:53 <Cale> (the take 1 is probably unnecessary, since reads rarely (never for Prelude instances?) produces more than one parse)
20:08:42 <Cale> hackrilege: Check out HaLVM :)
20:08:52 <geekosaur> for streaming you don't worry about that much, usually the first data packet specifies that information and it's up to the receiver to react to that by programming local sound hardware to match or putting up/downsampling filters in place, etc.
20:08:55 <Cale> https://github.com/galoisinc/halvm
20:09:51 <bitemyapp> @pl (traverse makeIoOnlyObj . traverse decodeFn =<<) . fetchFn
20:09:51 <lambdabot> (traverse makeIoOnlyObj . traverse decodeFn =<<) . fetchFn
20:09:56 <bitemyapp> dammit lambdabot
20:10:00 <bitemyapp> I wanted you to arrowize it or something
20:10:20 <geekosaur> sound stuff looks simple now with all the libraries and such that deal with things for you, but those libraries took some fiddling to get to work with all the oddball hardware out there
20:10:25 <Welkin> bitemyapp: what are those?
20:10:29 <Welkin> I have never seen those functions
20:10:51 <hackrilege> but its all so high latency. i just want to compile to a little cheap chip and not have to run a linux kernal and use a huge C library on it just to interface with the current from my guitar... before integrated circuits simple digital sound processing was faast!!
20:11:05 <geekosaur> (like, most things accept 44.1kHz audio. except the ones that want 48kHz or 96kHz and you have to upsample)
20:11:12 <Welkin> hackrilege: write an embedded program for a microcontroller
20:11:40 <bitemyapp> @pl \f g h -> (traverse f . traverse g =<<) . h
20:11:41 <lambdabot> (((.) . (=<<)) .) . (. traverse) . (.) . traverse
20:11:49 <bitemyapp> lmao, k
20:11:58 <Cale> hackrilege: Write a Haskell program which writes microcontroller assembly :)
20:12:04 <bitemyapp> @ty (((.) . (=<<)) .) . (. traverse) . (.) . traverse
20:12:05 <lambdabot> (Monad m, Applicative f, Traversable t, Traversable f) => (t b -> m b1) -> (a1 -> f b) -> (a -> m (t a1)) -> a -> m (f b1)
20:12:41 <geekosaur> you can still do stuff with hardware instead of with DSP. it just takes a soldering iron to adjust stuff instead of tweaking some constants :)
20:12:42 <bitemyapp> Welkin: they're free variables, don't sweat it homie.
20:13:00 <nkaretnikov> is there a way to generate 'foo <- f x y' with template haskell?
20:13:40 <srobert> Well, looks like I finally have leksah running. This whole cabal business is new to me. Very tedious.
20:14:44 <hackrilege> Welkin: yeh thats the idea. but i shouldnt need to buy a chip as there is one in my computer, the overhead is too much with an opperating system and ffi and all this. i could write a haskell program easily, why does fetching the data have to be so hard, something to do with dropping packets or other fear from internet protocall, its a distrorted analouge signal! i just care about latency, which even on production line chips is a
20:15:00 <hackrilege> Cale: that sounds more like it!
20:16:08 <Welkin> in what situation would you say to yourself "Template Haskell is just what I need for this!"
20:16:13 <geekosaur> nkaretnikov, isn;t that BindS?
20:16:14 <Welkin> because I have never encountered it
20:16:53 <nitrix> You know what would be great? A program that goes through every imports of your program, the libraries associated with them in your cabal, then checks all the functions used to try to find the minimal version possible of that library that would work with your program.
20:17:12 <geekosaur> there's some stuff in that direction on hackage, I think
20:17:20 <geekosaur> possibly not very complete yet
20:17:46 <nitrix> This way you could get a dependency of   library >= 1.0.0 (something very old) && <5.1.0 (tiny bit past current)
20:17:56 <nitrix> Auto detection :D
20:18:45 <dolio> How will it know that the things in 1.0.0 do the right thing?
20:18:54 <hackrilege> nitrix this sounds great.
20:19:05 <AaronFriel> nitrix: It also sounds very fragile
20:19:09 <nitrix> dolio: You could blacklist versions that are defective, I assume.
20:19:18 <AaronFriel> nitrix: We've had a lot of problems with tight bounds causing upgrade problems
20:19:33 <dolio> What if it's not defective, it just does something different than it currently does.
20:19:34 <hackrilege> i guess it compiles like that? i mean you dont carry round the huge library with the executable right?
20:19:42 <AaronFriel> nitrix: And as a result, Cabal and Stack now (both used to build Haskell programs) have overrides for the upper bounds
20:19:49 <geekosaur> weve also had problems where loose or nonexistent bounds cause upgrade problems
20:20:03 <geekosaur> and those tend to impact programs farther from the actual change
20:20:10 <nitrix> dolio: I don't know to be honest. I just had the idea, so it might need some thinkering.
20:20:23 <AaronFriel> geekosaur: I would say loose upper bounds have been less of a problem than strong upper bounds, based on experience. But this was from a couple years ago when people were putting very tight upper bounds on everything
20:20:45 <AaronFriel> geekosaur: I had to send many pull requests to packages on GitHub, and it wasn't uncommon to have to "git pull" packages I needed and recompile them with different bounds
20:21:06 <AaronFriel> geekosaur: For the end user, esp. an amateur at using Cabal, strong upper bounds were an awful experience
20:21:16 <geekosaur> the problem is that tight bounds mean lots of small breakages close to the source of the change, loose ones mean lots of huge breakages several dependents down the line
20:21:36 <AaronFriel> What would be REALLY great would be if Cabal could do dependency management based on the type signatures of functions you're actually using
20:21:54 <AaronFriel> Sort of like how Rust pins packages based on a cargo.lock file
20:21:59 <geekosaur> but everyone wants desperately to forget how changes in ByteString and Text at different times broke 75% of Hackage
20:22:05 <AaronFriel> I would like a cabal.lock file that records eery imported type signature
20:22:18 <AaronFriel> and if the type sigs are compatible, allow upgrades by default
20:22:29 <AaronFriel> *that* would be awesome
20:22:52 <AaronFriel> Then, if I depend on ".Internal.QuxBaz", I am invoking fragility on myself
20:23:04 <AaronFriel> and if I don't? easy peezy upgrades for most users
20:23:34 <nitrix> AaronFriel: Well, it's sort of what I'm suggesting, except yours is upgrade-wise, I was more considering picking the right version bounds. Both are prone to the same problem though; consider the behavior is wrong is changed but the type signature stayed the same :/ ?
20:24:09 <nitrix> and later changed*
20:25:14 <AaronFriel> nitrix: A legitimately awesome GHC extension + Cabal feature would be: allow you to import things based on their type sig (e.g: I want to import "null :: o -> Bool" from a module) to lock that signature down
20:25:27 <AaronFriel> nitrix: And automatic resolutions of upgrades
20:25:39 <AaronFriel> e.g.: Say my code depends on some peculiarity of the internals of Text
20:26:03 <nitrix> Sure. But what if the function behavior changes? Maybe doesn't even work properly, but the type is still fine.
20:26:08 <nitrix> e.g. a tree or whatever.
20:26:22 <AaronFriel> that's pretty rare, as the majority of libraries are not data structure libraries
20:26:38 <AaronFriel> and usually if a data structure library is changed, it's because there was a bug in say, merging two trees
20:26:40 <hackrilege> do we have a c compiler written in haskell?
20:26:47 <AaronFriel> yes
20:27:36 <AaronFriel> hackrilege: I jest, but I was going to say "It's called -fvia-c and piping into GCC"
20:28:14 <AaronFriel> hackrilege: An interesting project would be to write some Template Haskell that translated C into Haskell, then you would have a roundabout C compiler
20:28:28 <hackrilege> is gcc really so hard to emulate?
20:28:46 <mac10688> Anyone program haskell for windows applications? Is it buggy or anything?
20:28:58 <nitrix> hackrilege: If you include C++, almost impossible.
20:29:01 <hackrilege> id love to generate good haskell from c but its not there yet
20:29:20 <AaronFriel> nitrix: Well that's because writing a C++ compiler is impossible
20:29:23 <hackrilege> <mac10688> its fine
20:29:36 <hackrilege> lol almost impossible...
20:29:44 <AaronFriel> nitrix: I mean, if you find me a C++ compiler that meets C++11 and has no bugs...
20:29:44 <mac10688> <hackrilege> Thanks :)
20:29:51 <AaronFriel> Not that GHC is perfect
20:30:02 <nitrix> AaronFriel: My point precisely.
20:30:04 <anohigisavay> how can i write a monadic version of any?
20:30:15 <AaronFriel> use foldM_
20:30:18 <AaronFriel> err foldM
20:30:37 <AaronFriel> err... well that might not get you an early return
20:30:53 <AaronFriel> First question: Are you sure you want a monadic version of "any"?
20:31:00 <hackrilege> why is it so hard? its just a language, youd think it would be well defined...
20:31:33 <AaronFriel> e.g.: Do you want early return, or do you just want to run a list of monadic effects and check if any return true? 
20:31:49 <AaronFriel> hackrilege: "well defined", good joke
20:31:49 <anohigisavay> AaronFriel: i want early return
20:32:13 <anohigisavay> i want to check a filepath pattern against thousands of paths
20:32:28 <hackrilege> no but really what?
20:32:59 <anohigisavay> i read haskell's definition of any and was lost
20:33:10 <anohigisavay> any p = getAny #. foldMap (Any #. p)
20:33:13 <nitrix> hackrilege: The size of the standard library doesn't help. Microsoft has the resources to actually develop such compiler, and they are not even close, even after pouring so much time and money in it.
20:33:15 <hackrilege> there are too many subtle language extensions to even catalouge?
20:34:01 <AaronFriel> > :t let anyM ms = case ms of [] -> return False; (m:ms) -> do { result <- m; if result then return True else anyM ms }
20:34:03 <lambdabot>  <hint>:1:1: parse error on input ‘:’
20:34:03 <AaronFriel> oops
20:34:10 <AaronFriel> > :t \ms = case ms of [] -> return False; (m:ms) -> do { result <- m; if result then return True else anyM ms }
20:34:11 <lambdabot>  <hint>:1:1: parse error on input ‘:’
20:34:20 <AaronFriel> Dammit Lambdabot
20:34:21 <hackrilege> no i mean just to parse the source, all of the libraries are written in C no?
20:34:25 <nitrix> What's # again? Unboxed types?
20:34:29 <anohigisavay> xD
20:34:30 <AaronFriel> nitrix: Yes
20:34:36 <anohigisavay> AaronFriel: i think i understand what you mean
20:34:40 <Welkin> nitrix: and ghc type fuckery :D
20:34:41 <AaronFriel> anohigisavay: Yes, the function I pasted should do what you want
20:34:48 <Welkin> as was so elegantly described last night
20:34:53 <AaronFriel> Prelude> let anyM ms = case ms of [] -> return False; (m:ms) -> do { result <- m; if result then return True else anyM ms }
20:34:54 <AaronFriel> Prelude> :t anyM
20:34:54 <AaronFriel> anyM :: Monad m => [m Bool] -> m Bool
20:35:51 <anohigisavay> but i wonder how that ghc type fuckery can allow any Foldable types to early return?
20:36:25 <anohigisavay> any :: Foldable t => (a -> Bool) -> t a -> Bool
20:36:34 <Welkin> so, is # shorthand for the UNPACK pragma?
20:37:06 <Welkin> anohigisavay: using guards
20:37:10 <Welkin> er, guard
20:37:12 <hackrilege> :type fmap any
20:37:28 <hackrilege> :t fmap any
20:37:35 <lambdabot> (Functor f, Foldable t) => f (a -> Bool) -> f (t a -> Bool)
20:38:41 <hackrilege> > fmap any (return [True])
20:38:43 <lambdabot>      Couldn't match expected type ‘a -> Bool’ with actual type ‘[Bool]’
20:38:43 <lambdabot>      In the first argument of ‘return’, namely ‘[True]’
20:38:43 <lambdabot>      In the second argument of ‘fmap’, namely ‘(return [True])’
20:39:19 <anohigisavay> thank you guys :)
20:39:41 <hackrilege> sorry...
20:40:11 <hackrilege> i cant see why you wouldnt get an early return with that..
20:40:29 <hackrilege> but im usually wrong about stuff like that...
20:41:55 <anohigisavay> hackrilege:i eventually want an anyM with type :: (Monad m, Foldable t) => (a -> m Bool) -> t a -> Bool
20:42:44 <Welkin> anohigisavay: you could write one yourself
20:43:43 * hackagebot base-orphans 0.4.4 - Backwards-compatible orphan instances for base  https://hackage.haskell.org/package/base-orphans-0.4.4 (ryanglscott)
20:43:43 * hackagebot pkcs7 1.0.0.0 - PKCS #7 padding in Haskell  https://hackage.haskell.org/package/pkcs7-1.0.0.0 (kisom)
20:44:34 <hackrilege> your going to map the (a -> m Bool) over the t a to get a t m b. then you want to concat your t (sorry i know thats the wrong way of saying it) to get a m b?
20:44:58 <hackrilege> also yes i think you want type :: (Monad m, Foldable t) => (a -> m Bool) -> t a -> IO Bool
20:46:10 <hackrilege> anyway if it is foldable we have foldr
20:46:11 <hackrilege> :t foldr
20:46:13 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
20:46:27 <Welkin> why IO?
20:46:56 <hackrilege> sorry, anyM :: (Monad m, Foldable t) => (a -> m Bool) -> t a -> m Bool
20:47:04 <c_wraith> ok, that type signature looks way better.
20:47:11 <anohigisavay> yea right. 
20:48:19 <anohigisavay> [a] works for now. won't foldr sacrifice lazy evaluation
20:48:36 <c_wraith> :t foldMap
20:48:38 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
20:49:03 <c_wraith> Hmm.  I could swear there was an instance being added to Data.Monoid specifically for this sort of thing
20:49:15 <arkeet> for what thing
20:49:30 <hackrilege> :t foldMap any
20:49:32 <lambdabot>     Could not deduce (Monoid Bool) arising from a use of ‘foldMap’
20:49:32 <lambdabot>     from the context (Foldable t, Foldable t1)
20:49:32 <lambdabot>       bound by the inferred type of
20:49:36 <arkeet> :t any
20:49:37 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
20:49:47 <arkeet> :t foldrM
20:49:48 <lambdabot> (Monad m, Foldable t) => (a -> b -> m b) -> b -> t a -> m b
20:50:10 <c_wraith> Hmm.  There's Alt, but that's not actually the one I was looking for.
20:50:23 <arkeet> :t foldrM (fmap . (||)) (pure False)
20:50:25 <lambdabot>     Couldn't match type ‘Bool’ with ‘m Bool’
20:50:25 <lambdabot>     Expected type: Bool -> Bool -> m Bool
20:50:25 <lambdabot>       Actual type: Bool -> Bool -> Bool
20:50:28 <arkeet> oh.
20:50:44 <nshepperd> er, doesn't 'any' already shortcut?
20:50:48 <arkeet> it does.
20:51:41 <c_wraith> Oh, it's a live proposal.  Something like App or Ap, that lifts a monoid into an applicative
20:51:54 <c_wraith> It won't really be capable of short-circuiting, though.
20:52:12 <arkeet> meanwhile, foldrM doesn't shortcut.
20:52:21 <arkeet> er, can't make anything that shortcuts.
20:52:51 <c_wraith> No, shortcutting doesn't play especially well with >>= or <*>
20:53:14 <hackrilege> we want foldMapM i think....
20:53:59 <c_wraith> The problem is that <*> and >>= have rules that are incompatible with structural shortcutting.
20:54:25 <c_wraith> You need to build your own shortcutting that works in terms of those operators.
20:54:35 <c_wraith> And there's no good way to do it, in particular.
20:55:02 <arkeet> you can't implement a short circuiting anyM with foldrM or anything like it.
20:55:11 <c_wraith> yeah.
20:55:26 <arkeet> if you want anyM, look in the monad-loops package
20:56:03 <arkeet> actually it could probably be done with a regular (non-monadic) fold
20:56:18 <arkeet> by thinking of m Bool as a suitable monoid
20:56:28 <arkeet> :t foldr
20:56:29 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
20:56:35 <c_wraith> Only if you build shortcutting into your monoid
20:56:38 <nitrix> Sorry I got disconnected.
20:56:47 <arkeet> yes, that's the "suitable" part.
20:56:51 <arkeet> liftM2 (||) won't do it.
20:57:09 <nitrix> Isn't anyM :: (Monad m, Foldable t) => (a -> m Bool) -> t a -> Bool  breaking referential transparency or something?
20:57:16 <nitrix> In the case where m is IO ?
20:57:17 <anohigisavay> cool thank you guys
20:57:21 <c_wraith> arkeet: I'm pretty sure it would actually break the monoid laws
20:57:25 <hackrilege> anyM :: (Monad m, Foldable t) => (a -> m Bool) -> t a -> m Bool
20:57:27 <c_wraith> arkeet: you would lose associativity
20:57:33 <arkeet> :t \f -> foldr (\a b -> do { x <- a; if x then return True else b}) (return False)
20:57:34 <anohigisavay> i'll look into that package
20:57:35 <lambdabot> (Monad m, Foldable t) => r -> t (m Bool) -> m Bool
20:57:35 <nitrix> Yeah, you'd need -> m Bool
20:57:37 <arkeet> c_wraith: are you sure?
20:57:44 <arkeet> :t \f -> foldr (\a b -> do { x <- f a; if x then return True else b}) (return False)
20:57:46 <lambdabot> (Monad m, Foldable t) => (a -> m Bool) -> t a -> m Bool
20:57:49 <c_wraith> arkeet: associativity would control which effects run
20:57:57 <arkeet> no?
20:57:58 <c_wraith> potentially, anyway
20:58:08 <c_wraith> think in terms of foldMap, not foldr
20:58:28 <c_wraith> Where the implementation is free to reassociate however it likes
20:58:40 <c_wraith> Which is allowed by the monoid laws.
20:58:46 <arkeet> the monoid operation I'm thinking of is \a b -> do { x <- a; if x then return True else b}
20:58:57 <nshepperd> foldlM with EitherT possibly
20:58:57 <c_wraith> arkeet: yeah, that's not associative
20:59:01 <arkeet> why not?
21:02:18 <hackrilege> would head mapM not be lazy?
21:02:31 <arkeet> no.
21:02:41 <arkeet> it would run all actions in the list.
21:02:57 <hackrilege> damn
21:03:03 <c_wraith> Huh.  Ok, it is associative, though it's necessarily biased.  I suppose biased is necessary.
21:03:15 <hackrilege> can we use fix?
21:03:18 <c_wraith> Yeah, the bias is in fact what makes it associative.
21:03:29 <c_wraith> fix is a replacement for recursion.  You can always use it somehow.
21:03:36 <c_wraith> > fix (const True)
21:03:38 <lambdabot>  True
21:03:41 <c_wraith> look, I used fix!
21:04:01 <hackrilege> but would it break early like we want it too?
21:04:12 <c_wraith> It's a replacement for general recursion.
21:04:20 <c_wraith> It can do anything general recursion can do.
21:04:21 <hackrilege> so yes
21:04:21 <hackrilege> ok thanks
21:04:39 <hackrilege> i dont get why mapM isnt lazy...
21:05:16 <hackrilege> :t fix
21:05:17 <lambdabot> (a -> a) -> a
21:05:42 <lpaste_> arkeet pasted “orM is associative” at http://lpaste.net/138775
21:05:43 <arkeet> c_wraith: ^
21:05:49 <rom1504> :t mapM
21:05:50 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
21:06:16 <c_wraith> arkeet: yeah, I figured it out.  The bias forces it to be associative...  But might make it inefficient or even fail to terminate on some Foldables :)
21:06:17 <hackrilege> its good i think
21:06:17 <hackrilege> anyM :: (Monad m, Foldable t) => (a -> m Bool) -> t a -> m Bool
21:06:19 <arkeet> c_wraith: of course it's not commutative.
21:06:33 <arkeet> and yes it might be inefficient
21:06:40 <arkeet> but you can just use foldr
21:06:40 <arkeet> :-)
21:06:43 <c_wraith> arkeet: like, it's really good on [].  It's really bad on snoc-lists
21:06:56 <arkeet> foldr already associates to the right
21:07:07 <c_wraith> yeah, foldr is also really bad on a lot of Foldables
21:07:07 <hackrilege> so we just need to turn the t b into b, i thought to use head, but apparently this is not going to be lazy...
21:07:13 <c_wraith> that's why foldMap is the fundamental operation
21:07:42 <arkeet> no, it's only bad on things that are bad when reassociated to the right.
21:08:03 <c_wraith> I assure you, that's an infinite number of things. :)
21:08:06 <arkeet> of course foldMap is more fundamental.
21:08:24 <hackrilege> why not just traverse it?
21:08:33 <hackrilege> could break early then
21:08:45 <arkeet> that doesn't make sense.
21:09:03 <hackrilege> since we arnt really folding, just checking for one true return value
21:09:16 <arkeet> c_wraith: if f :: a -> [b], then I'm pretty sure foldMap f is in general much worse than foldr ((++) . f) []
21:10:50 <c_wraith> arkeet: I don't see why it would be.
21:10:55 <arkeet> consider snoc lists again.
21:11:05 <hackrilege> could we use (*>)?
21:11:10 <bz> is there a stack tutorial somewhere
21:11:12 <lyxia> hackrilege: What should this do: head <$> mapM (\x -> print x) [0 ..]
21:11:23 <c_wraith> arkeet: they're both terrible on snoc lists
21:11:32 <c_wraith> arkeet: foldr is O(n^2) on snoc lists
21:11:38 <arkeet> it is?
21:11:41 <lyxia> hackrilege: What's "lazy" for you in that context?
21:11:42 <hackrilege> :t <$>
21:11:43 <lambdabot> parse error on input ‘<$>’
21:11:46 <arkeet> I don't think it is.
21:11:57 <hackrilege> :t (<$>)
21:11:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:12:06 <arkeet> hackrilege: laziness isn't really the right term.
21:12:29 <arkeet> hackrilege: anyawy, if you only use Applicative stuff, it is impossible to decide what actions to run based on results of other actions.
21:12:38 <hackrilege> i get it
21:12:38 <hackrilege> thanks
21:12:41 <arkeet> in particular, it is impossible to do short circuiting.
21:12:53 <hackrilege> so why this whole discussion on getting an early return!?
21:13:09 <johnw> arkeet: that's not entirely, right is it?
21:13:17 <arkeet> johnw: why not?
21:13:38 * hackagebot pkcs7 1.0.0.1 - PKCS #7 padding in Haskell  https://hackage.haskell.org/package/pkcs7-1.0.0.1 (kisom)
21:13:40 <johnw> say f <$> a <*> b <*> c, where c is really expensive to compute; if b short-circuts (MaybeT), it's possible that c won't be executed
21:13:41 <hackrilege> lyxia: the lazy answer is ()
21:14:38 <arkeet> johnw: that's different from what I meant.
21:14:40 <anohigisavay> i don't actually know how the mutual definitions of traverse and sequenceA work. but just confirmed that head $ mapM (return . odd) [1..] never stops
21:15:08 <arkeet> johnw: it still "runs" the a, b, c MaybeT actions
21:15:25 <johnw> arkeet: I see
21:16:23 <hackrilege> anohigisavay: i think thats why they were using recursion. i never could tell if they found a short circuit or not though...
21:16:25 <arkeet> actually (>>=) is the very thing that describes deciding what actions to run based on results of other actions.
21:16:35 <lyxia> hackrilege: but that is an IO action which should print something, what, then would it print if it is to return ()
21:17:22 <arkeet> anohigisavay: I'm not sure what you think it's doing is what it's actually doing.
21:17:25 <hackrilege> it would print what it was supposed to, return (), head would be satisfied, and it would stop, if it were nice...
21:17:45 <arkeet> anohigisavay: the monad that's in play there is the list monad.
21:17:53 <nitrix> lyxia: The printing is a side-effect (hence IO). The value returned lazily is still ().
21:18:18 <nshepperd> actually, johnw is right
21:18:26 <arkeet> if you mapM an infinite list in the list monad, and all the lists are nonempty, it will never produce anything because it will never know there isn't an empty list somewhere deep
21:18:44 <nshepperd> if a,b,c are MaybeT m actions, c might not get executed
21:18:50 <arkeet> > head $ mapM (\x -> if x == 100 then [] else return (odd x)) [1..]
21:18:52 <lambdabot>  *Exception: Prelude.head: empty list
21:18:54 <nshepperd> in an applicative expression like that
21:19:14 <arkeet> well, depends on what you mean by execution.
21:19:25 <nshepperd> but the reason that makes sense is: instance (Functor m, Monad m) => Applicative (MaybeT m)
21:19:42 <arkeet> yeah.
21:19:58 <hackrilege> we will not call the (a -> m Bool) if we never reach it in a recursion. so it should be fine, why are the folds not behaving lazy?
21:20:02 <arkeet> sometimes I wish we had a version of MaybeT that only required Applicative.
21:20:12 <arkeet> but it would have different semantics.
21:20:35 <lyxia> nitrix: If one of the actions fails, the whole should fail without returning any result. That's what happens with Maybe: head <$> mapM (\x -> guard (x < 100000)) [0..].
21:20:41 <anohigisavay> arkeet: let mapM = fmap 
21:20:41 <bz> stack tutorial pls
21:20:46 <anohigisavay> then it early returns
21:20:47 <bz> recommendations, #haskell
21:20:52 <arkeet> anohigisavay: those have entirely different types.
21:21:06 <arkeet> and do entirely different things.
21:21:09 <hackrilege> #hashtag
21:21:14 <nkaretnikov> geekosaur: thanks, i'll take a look.  i wish it were documented :\
21:21:19 <anohigisavay> i think it's meant to evaluate everything
21:21:39 <arkeet> :t mapM
21:21:40 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
21:21:43 <arkeet> in your example, m is []
21:21:47 <arkeet> so it's (a -> [a]) -> [a] -> [[a]]
21:21:57 <arkeet> er
21:22:02 <johnw> bz: have none
21:22:05 <arkeet> (a -> [b]) -> [a] -> [[b]]
21:22:14 <anohigisavay> yea, but mapM is defined upon travere which also has a different type
21:22:27 <anohigisavay> *traverse
21:22:27 <arkeet> and it doesn't concatenate all the results of a -> [b]
21:22:35 <arkeet> it takes their product
21:22:48 <anohigisavay> oh, let me see
21:23:01 <hackrilege> the point of using map was because we were not folding.
21:23:13 <hackrilege> its any, not all
21:23:13 <arkeet> you will never be able to evaluate the product of infinitely many nonempty lists.
21:23:13 <anohigisavay> arkeet: yes you're right
21:23:18 <arkeet> becuase you can never know they're all nonempty.
21:23:24 <lpaste_> nshepperd pasted “anyM” at http://lpaste.net/138776
21:23:33 <anohigisavay> xD i was being stupid
21:23:45 <arkeet> ok, it is clear now I think. :)
21:23:45 <nshepperd> anyM using foldlM and EitherT ^^
21:24:13 <hackrilege> so whats the EitherT bit?
21:24:23 <nshepperd> well, sort of, I made it use Maybe b instead Bool, for extra usefulness
21:24:41 <arkeet> hackrilege: that's the part that lets you short circuit.
21:24:46 <arkeet> by using a different monad.
21:25:10 <hackrilege> uber cool
21:26:03 <hackrilege> maybe better without the Maybe Bool?
21:26:20 <arkeet> it's not a Bool.
21:26:50 <hackrilege> yeh its a maybe sorry, so thats like a bool but that can store another value, thats good i guess
21:27:57 <hackrilege> i kind of want a one liner
21:28:07 <arkeet> I did write one earlier.
21:28:11 <arkeet> using foldr
21:28:28 <hackrilege> it escapes using EitherT?
21:28:44 <hackrilege> i didnt think so...
21:28:47 <arkeet> :t foldr (\a b -> a >>= \x -> if x then return True else b) (return False)
21:28:48 <lambdabot> (Monad m, Foldable t) => t (m Bool) -> m Bool
21:28:51 <arkeet> oops.
21:28:57 <arkeet> :t \f -> foldr (\a b -> f a >>= \x -> if x then return True else b) (return False)
21:28:58 <lambdabot> (Monad m, Foldable t) => (a -> m Bool) -> t a -> m Bool
21:29:51 <hackrilege> i think a "lift" and a "runEitherT" are required..
21:30:01 <arkeet> ?????????
21:30:15 <hackrilege> nvm
21:31:14 <xpikab> Is there a monad type without the unit operation ?
21:31:26 <johnw> edwardk has an Apply class for that
21:31:28 <arkeet> there is a class called Bind somewhere.
21:31:32 <johnw> some papers call it a Premonoid
21:31:34 <johnw> oh, maybe Bind
21:31:39 <johnw> sorry, Premonad
21:31:42 <arkeet> Apply is the thing for (<*>)
21:31:54 <arkeet> same package, anyawy
21:32:04 <arkeet> https://hackage.haskell.org/package/semigroupoids-5.0.0.3/docs/Data-Functor-Bind.html
21:32:06 <hackrilege> premonoidal soup
21:51:53 <joshkirklin> anyone know of a library that can do diff based json encoding?
21:53:40 * hackagebot file-embed 0.0.9 - Use Template Haskell to embed file contents directly.  https://hackage.haskell.org/package/file-embed-0.0.9 (MichaelSnoyman)
21:53:42 * hackagebot ad 4.2.4 - Automatic Differentiation  https://hackage.haskell.org/package/ad-4.2.4 (EdwardKmett)
21:54:30 <kadoban> Anyone know a library or anything that has types/utils for handling physical addresses and/or phone numbers? Looking for stuff like maybe parsing, validating, enumerating parts … maybe stuff like country lists, that kind of thing.
22:02:27 <kadoban> joshkirklin: What is "diff based"?
22:03:40 * hackagebot moesocks 0.1.0.16 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.0.16 (JinjingWang)
22:04:42 <joshkirklin> kadoban, say I've already rendered a large json text, and I want to change just one small bit of that json. the library would provide me with some data type to describe that change, and apply that change to the rendered json in an efficient way, without having to rerender the entire thing.
22:05:15 <joshkirklin> I know such things are possible with eg html and virtual-dom
22:13:12 <saulzar> joshkirklin, But virtual dom is a bit different isn't it? You provide the whole html structure each time ..
22:15:57 <joshkirklin> is that right? I've never personally used it so I suppose I might have misunderstood what it's for.
22:16:05 <rpfun> is there a "lens" type for something that can never fail while getting but can fail while setting?
22:16:24 <johnw> rpfun: what would such a thing be like?
22:17:34 <saulzar> joshkirklin, Yeah - it's about making minimal changes to the dom
22:17:47 <rpfun> johnw: for example, i have some type "data A = { a1 :: Int, a2 :: Int }" and i want to have a lens that can only ever set a2 < a1 (this is contrived, but it's the same usecase as i have)
22:18:12 <johnw> ah, you want some kind of invariant preserved
22:18:48 <joshkirklin> saulzar, that makes sense, I remember now
22:19:05 <joshkirklin> still looking for the kind of solution I describe though (if such a thing exists)
22:19:37 <kadoban> joshkirklin: Not really sure what kind of rendering you're looking for. I don't know of any tool/library like that at all though, so I probably can't help regardless.
22:19:39 <saulzar> joshkirklin, What you describe would be quite useful though - I'm quite interested in diffing/patching for normal data structures too for use in FRP 
22:19:43 <johnw> rpfun: maybe a Prism could do that, but it would also have to return Maybe on getting as well
22:22:50 <rpfun> johnw: i don't see how a prism would work
22:24:43 <johnw> rpfun: for example, see http://hackage.haskell.org/package/lens-3.8.2/docs/Control-Lens-Prism.html
22:24:48 <johnw> the documentation and "nat" example
22:25:21 <johnw> although, in that case it's the setter that always succeeds
22:26:02 <rpfun> I don't think that's a trivial difference
22:30:58 <bz> chrissake
22:31:01 <bz> does anyone here use stack?
22:31:12 <kadoban> bz: yep
22:33:25 <AaronFriel> bz: yep
22:33:41 <bz> how
22:34:15 <bz> where the frick is the getting-started documentation? everything on the wiki and on google starts out with, "well stack was built to ________________"
22:35:29 <kadoban> bz: You don't need a ton more than what's under How to use in https://github.com/commercialhaskell/stack
22:37:57 <kadoban> bz: I'd just install it and try it and ask if you can't figure it out. It turned out to be quite a bit easier than I expected. And yes the docs are pretty sparse currently, it's new and changing fairly quickly.
22:42:05 <bz> "If everything is already configured" no, nothing is configured. i just want to start a init a new project. how do i stack init without it accessing the network? why does it insist on downloading some external package cache? how do i use it as a simple (offline) build tool? i don't want to depend on lts this or that
22:42:38 <johnw> why use it then?
22:42:47 <bz> because cabal is a huge pita
22:43:08 <bz> gotta redownload recompile reinstall on every new sandbox
22:47:34 <kadoban> bz: I doubt you can do it offline. Not sure why that'd be a requirement.
23:09:00 <SrPx> Sorry again, how do I refer to a type in a forall inside a instance? "instance forall a . Foo a where { foo x = bar :: a }" ... the ":: a" refers to the "a" on the forall.
23:09:38 <johnw> ScopedTypeVariables
23:14:13 <SrPx> ty
23:15:11 <SrPx> Is it impossible for GHC to suggest it when that is the cause of an error? I always forget the name of the extension
23:18:06 <ttt_fff> suppose I am parsing a white-space-important langauge (like python/haskell), is there something  better than parsec? (I heard about trifecta, but see now trifecta docs)
23:18:10 <hackrilege> how does this forall keyword  work?
23:19:26 <Zekka> ttt_fff: What would you expect it to provide? You can do indentation sensitivity OK with Parsec's extra state parameter
23:19:44 <ttt_fff> Zekka: I'm not sure, http://hackage.haskell.org/package/trifecta-0.46/docs/Text-Trifecta-Parser-Layout.html looks nice,
23:19:59 <ttt_fff> I tried doing indentation aware parsing once in parsec; was not nearly as easy as parsing sexps, I have to say
23:20:17 <Zekka> If trifeca does what you want, totally use it
23:20:32 <Zekka> trifecta*
23:20:36 <Zekka> I've never personally worked with it
23:20:43 <ttt_fff> is the author edwardk any good? :-)
23:21:05 <Zekka> ttt_fff: Sarcasm? He has a pretty good reputation, and he's worked on/written an extremely large number of libraries
23:21:15 <Zekka> You're probably already using a library he maintains
23:21:25 <ttt_fff> yes and yes, using lens
23:21:37 <hackrilege> just dont egg him on too much, it get too high level too fast! and away from your question...
23:22:14 <ttt_fff> haskell is so nice ot write
23:22:16 <ttt_fff> scheme is so nice to parse
23:23:05 <hackrilege> ttt_fff are you writing a haskell interpreter?
23:23:26 <ttt_fff> i'm writing a minimal typed purely functional language
23:23:36 <hackrilege> coool
23:23:46 <hackrilege> minimal typed?
23:25:12 <hackrilege> are you using lazy evaluation with thunks and such? i dont know how to produce bytecode really...
23:29:12 <hamsterdam> Hi, I have Syntastic with hdevtools installed in vim. Syntastic reports an error that it can't find a package, for example, Text.Regex.PCRE.  However, outside of vim, it compiles and runs fine. Can anyone give a newbie a tip?
23:32:55 <liste> hamsterdam try this http://lpaste.net/94999
23:33:19 <liste> if you're using cabal sandboxen
23:33:43 <hamsterdam> Thanks a bunch, but I'm just messing around globally
23:36:45 <liste> what does your g:hdevtools_options or g:syntastic_haskell_hdevtools_args look like?
23:37:41 <liste> and, what does hdevtools check say in the project folder?
23:37:41 <hamsterdam> haven't touched those
23:38:38 <liste> how did you install regex-pcre?
23:39:22 <hamsterdam> Could not find module `(module)'
23:39:23 <hamsterdam> Use -v to see a list of the files searched for.
23:39:39 <hamsterdam> cabal install regex-pcre
23:40:30 <liste> try checking if the search paths are correct with hdevtools check -v
23:40:42 <liste> what GHC version do you have?
23:42:53 <hamsterdam> ghc 7.10.2
23:43:10 <hamsterdam> -v apparently isn't an option
23:44:34 <liste> try -g -v
23:44:43 <liste> -g passes it to GHC
23:46:54 <hamsterdam> new to tmux as well, I think I might need to reload the session i'm in
23:48:51 <hamsterdam> outside the session, all good
23:48:55 <hamsterdam> argh
23:49:02 <hamsterdam> thanks for the help liste
23:51:14 <erikd> is there a way for an executable to detect if it has been compiled with --threaded?
23:52:58 <liste> yw (:
23:53:22 <erikd> :t rtsSupportsBoundThreads
23:53:23 <lambdabot> Not in scope: ‘rtsSupportsBoundThreads’
23:53:48 <erikd> :t Control.Concurrent.rtsSupportsBoundThreads
23:53:49 <lambdabot> Bool
