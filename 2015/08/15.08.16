00:00:13 <lf94> Yes
00:00:50 <solirc> lf94: https://github.com/hspec/hspec-example
00:00:53 <lf94> https://gist.github.com/0eaba7896e8b57bc4c04
00:01:02 <lf94> hspec is not the problem...it's cabal
00:01:20 <startling> lf94, I think you're not defining a Hangman library
00:01:23 <startling> only an executable
00:01:30 <lf94> Yes it's an executable
00:01:38 <lf94> Can you not test an executable?
00:01:38 <solirc> lf94: That was for your earlier question
00:01:40 <startling> lf94, OK. so, you can't depend on executables.
00:01:45 <lf94> Oh!
00:02:25 <startling> I *think* that's what's wrong.
00:02:55 <startling> I've used hs-source-directories as a hack to get around this in the past. you could also make it a library in cabal-terms even if it's not really a library.
00:03:32 <lf94> Yeah...
00:03:49 <lf94> I might separate the main :: IO () into its own file called Main.hs
00:03:55 <lf94> and keep the rest in Hangman.hs
00:03:59 <startling> that's an option, yeah.
00:08:01 <zipper> What's an include path in haskell
00:17:09 <athan> zipper: It's easy - replace the dots with slashes
00:17:18 <athan> Data.Foo.Bar becomes Data/Foo/Bar.hs
00:19:26 <arahael> I am trying to list all the advantages of using a Free Monad and interpreter pattern.
00:19:32 <arahael> Can someone help?
00:20:52 <startling> arahael, the biggest reason is that you can have transformers
00:21:29 <arahael> startling: Particularly if you can compose them, but what are the other reasons?
00:21:47 <startling> it's not really monadic, but one example is annotating your syntax tree with source positions
00:22:09 <arahael> startling: Someone using a different lnaguage might argue that transformers are 'merely' a workaround to not having side effects, and needing to do more.
00:22:22 <arahael> What do you mean? (w.r.t. that annotation)
00:23:24 <startling> arahael, I think using free monads for syntax trees is more an expression of how useful the type system is
00:23:36 <startling> not really a compelling reason to use Haskell on its own.
00:24:15 <arahael> startling: I see it as an elegant way of providing a DSL.
00:24:29 <chattered> startling: Could be "monadic." For a syntax tree, bind is substitution. So you can substitute in a tree and maintain the source position annotation.
00:24:40 <zipper> Is there an IRC channel for when one is feeling sad and depressed?
00:24:45 <startling> chattered, it could be monadic, but does that make sense?
00:25:10 <chattered> startling: Sure.
00:25:11 <arahael> startling: But you can do DSL's in other languages as well, and you can do nearly the same thing, however...  The "correct" way to do this in some circles (In OO circles, really), is to implement a class, and use inversion of dependency by passing in all of that class's dependnecies as constructor arguments.
00:25:36 <arahael> startling: I want to contrast it against how an OO designer would do it.
00:26:42 <arahael> One obviosu example of an advantage is the obvious threadsafety you have.
00:26:43 <startling> chattered, I'm not convinced. if I apply an arbitrary action to the leafs of my syntax tree, does it always make sense to preserve the source information? maybe it does, but I can see exceptions.
00:26:57 <srhb> zipper: A quick look shows that ##depression exists. You might give it a try.
00:27:51 <chattered> startling: Oh, I see. I think it works. I was trying exactly that the other day.
00:28:13 <startling> it works type-wise but I'm not sure it works semantically.
00:28:19 <arahael> zipper: I don't know if you're asking about depression, or commenting about what people are talking about, or making a joke.  But, on the off chance that you're actually feeling depressed, and you're in Australia, then I highly recommend BeyondBlue. They're pretty good to talk to.
00:28:39 <chattered> But I'm not sure about the pay-off. The main thing I want to do with a syntax tree is transform it with lots of pattern matching. But that seems really horrible with Free.
00:29:03 <zipper> arahael: No I'm not in Australia. Not joking.
00:29:09 <zipper> srhb: Thanks
00:30:03 <arahael> zipper: Well, good for making the step to ask. :)
00:31:50 <startling> zipper, happy to /msg for a bit if you want to talk and are comfortable with it.
00:33:03 <arahael> zipper: According to the stats in my country, somewhere between 1/5 and 1/10 have depression of some sort - but sadly, most people don't reach out to ask about it.  I suggest you take all the support you find. :)
00:35:23 <startling> chattered, I don't think it's that horrible
00:35:50 <arahael> So...  as for my question... What's the advantages?
00:36:25 <ttt_fff> what is the hardest part of writing something like GHC / Frege ? Is it the type checking algorithm?
00:36:37 <arahael> ttt_fff: That's possibly the easiest, I suspect.
00:36:43 <ttt_fff> I'm trying to figure out how much work it will take to port a Haskell-like to run on the BEAM virtual machine.
00:37:30 <arahael> ttt_fff: The erlang beam virtual machine?
00:37:38 <ttt_fff> arahael: yes
00:37:57 <ttt_fff> arahael: that would be the most amazing language
00:37:58 <chattered> startling: It's all the wrapping/unwrapping of Free that bugs me, especially if you are doing a nested pattern match. And then, if you've got another monad in there, you're pretty stuck.
00:38:18 <startling> chattered, yeah, you have to commit to using them monadically.
00:38:52 <arahael> chattered, startling: I have no idea what you're talking about.  Could you help me understand what it is, given that I did ask the initial question? :)
00:39:54 <arahael> ttt_fff: I haven't heard about GHC running on the BEAM, I think it would be difficult.  Why BEAM, though?
00:40:10 <chattered> arahael: Have you seen a simple data for, say, propositional logic before?
00:40:36 <chattered> Say, data Prop v = Var v | Prop v :&: Prop v | Not (Prop v) ?
00:41:14 <startling> arahael: one sec
00:41:17 <arahael> chattered: No I haven't, actually, though the wikipedia article reminds me of a basic class in logic I once had.
00:41:19 <chattered> If instead you do data P p = p :&: p | Not p, then you get something isomorphic to the original as the free monad of P.
00:43:06 <arahael> chattered: No, that's beyond me, right now.  I assume that :&: would be 'and', of some sort, but not sure how | works there, I'd have expected :|: but it must mean something else there.
00:43:27 <chattered> Oh, the pipe is just the usual Haskell sum type separator.
00:43:43 <arahael> Ah, so not 'or', but just a pipe.
00:44:17 <chattered> Yeah. Here, :&: is an infix data constructor, so has to start with a colon. I'd do or as :|:.
00:44:53 <arahael> 5zSo how does this relate to the free monad + interpreter issue?
00:45:14 <arahael> Beyond the fact that you're describing propositional logic.
00:47:28 <startling> have you seen Free?
00:47:44 <arahael> startling: Free is what I'm currently studying and learning.
00:47:51 <arahael> startling: Albiet in my own time.
00:48:15 <startling> cool, so if you have Free P, think about how that looks
00:48:19 <startling> and what the Monad instance does
00:48:41 <chattered> arahael: In this case, interpretation would be evaluation of the data-type.
00:48:59 <chattered> *of propositions
00:49:11 <arahael> startling: Yep, looks good and elegant, imho, though I haven't progressed to using iterM, though that's the obvious next-step for me (which would allow composability)
00:49:39 <startling> OK, so that's basically what chattered and I were talking about.
00:50:00 <arahael> startling: It strikes me that such would be difficult to implement with an OO design.
00:50:30 <startling> yeah. union types are pretty hard to represent nicely in general
00:50:46 <startling> in OO languages, I mean
00:51:15 <chattered> Normal approach is to have a class for the type, and subclasses for the variants.
00:51:42 <arahael> chattered: The example I'm writing up is the classic 'Draw a square' case.
00:51:55 <arahael> The free monad here just has four 'drawLine' instructions.
00:52:21 <startling> arahael, I'm not sure that's the best representation
00:52:24 <arahael> The normal OO case in this situation is to have a .render(DC) method, which renders to an (abstract) device context.
00:52:48 <startling> arahael, what's the difference between the four drawline instructions? different directions?
00:53:07 <arahael> startling: What would you suggest?  It seemed like the simplest to explain, but it strikes me that it's not doing a good job of being a _useful_ example.
00:53:14 <arahael> startling: Yes.
00:53:15 <startling> yeah, it's just [].
00:53:53 <startling> arahael, do you know basically what lambda calculus is? that might be a better example
00:53:54 <arahael> Infact, that's how I'm more-or-less demonstrating it.  Just as a list of instructions.  I wanted to build up from simple examples, and for a python dev, a list is easy to understand.
00:54:56 <arahael> startling: How would you use lambda calculus to explain to a _python_ or other typical developer what a free monad + interpreter pattern is?
00:55:08 <startling> arahael, it's a simple functional language
00:55:42 <startling> arahael, but I think maybe explaining free monads to python developers is going to be kind of tough
00:56:06 <arahael> startling: I'm simplifying to start with.
00:56:25 <arahael> Eg, rather than bother with do-notation, I just have a python example returning a _list_ of 'instructions'.
00:56:33 <arahael> lists, afterall, can be composed.
00:56:43 <arahael> Using +
00:57:05 <startling> arahael, is your actual goal to explain to a python developer what a free monad is?
00:57:10 <startling> or to get a better handle on it?
00:58:02 <arahael> startling: Frankly, the latter.
00:58:26 <arahael> startling: I seem to think I have a good handle of it now, but want to have an even better understanding of it, and to be able to *express* the damn thing.
00:59:00 <startling> So, the nice thing about Free is you get a monad instance ("for free") for every functor
00:59:33 <startling> It's mostly just a nice way to express a pattern that covers a range of monad instances.
00:59:43 <arahael> Yep.  And it dictates the shape of the resulting structure, which gives a very nice and constrained safe DSL.
01:00:10 <startling> maybe DSL is the wrong way to look at it.
01:00:19 <chattered> You can get a few other things for free as well, like a Traversable and a Foldable.
01:00:19 <arahael> Yeah?
01:00:41 <arahael> startling: I'm intruged, can you elaborate?
01:00:44 <startling> Well, writing a recursive type yourself gives you a Monad instance. That's sort of a dsl, isn't it?
01:00:57 <startling> If that's the case, what value does Free give you?
01:01:08 <arahael> startling: "do notation".
01:01:23 <startling> sure. You get do notation just by writing a Monad instance.
01:01:36 <startling> In my mind it's more about simplifying your datastructures so you can think about the parts that are actually application-specific.
01:01:45 <startling> Apart from the treeish part that all Frees have.
01:02:10 <arahael> startling: Somehow, that was what I was trying to get to.  The high level application-specific logic.
01:03:08 <arahael> Isn't that the same thing?
01:03:31 <startling> What do you mean?
01:03:46 <arahael> At that level, it's _still_ a DSL, isnt' it?
01:04:01 <arahael> An application-specific, domain specific language.
01:04:27 <startling> I don't think that's really what I mean.
01:04:49 <arahael> startling: We are like two alien races trying to communicate.
01:04:53 <startling> heh
01:05:03 <arahael> startling: I'm offering a cup of tea. You're offering hot brown water.
01:05:56 <arahael> startling: So, what do you really mean?
01:06:00 <startling> so, let me frame this another way. binary trees and quadtrees all have this common structure, right?
01:06:06 <arahael> Yes.
01:06:09 <startling> their monad instances are basically the same.
01:06:15 <arahael> Indeed.
01:06:17 <startling> so, you have data V2 a = V2 a a
01:06:27 <startling> you have data V4 a = V4 a a a a
01:06:36 <startling> with appropriate functor instances
01:06:54 <ecognium> hello everyone, I have a bit of a puzzling error: I have `import Data.HashMap.Strict as Imports          (fromListWith, toList,toAscList) ` when I compile I get `    Module ‘Data.HashMap.Strict’ does not export ‘toAscList’` and my .cabal has ` containers >= 0.5.6 && < 0.6 ` 
01:06:59 <chattered> ...(deriving Functor, Foldable, Traversable)!
01:07:10 <startling> arahael: so, Free encapsulates this common structure shared between the two.
01:08:08 <startling> i.e., you have Free V2 and Free V4.
01:08:40 <arahael> startling: Common in the sense that you can make a monad from a functor instance of V2 and likewise, a functor instance of V4?
01:09:02 <shachaf> ecognium: Data.HashMap isn't part of containers, and doesn't (and can't) export toAscList
01:09:11 <arahael> chattered: My free monad only derives Functor, incidentially)
01:09:17 <startling> arahael: yeah. you can write generic code for Free f with appropriate constraints on f.
01:09:22 <mazur> is there a function with a signature [(a -> b)] -> [a] -> [b] ?
01:09:24 <shachaf> arahael: Free f is a sort of tree with f-shaped branches
01:09:36 <chattered> @hoogle [(a -> b)] -> [a] -> [b]
01:09:36 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
01:09:36 <arahael> shachaf: That I can understand, yes.
01:09:36 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
01:09:36 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
01:09:41 <arahael> startling: Ok.
01:09:51 <arkeet> mazur: there are a couple, that do different things.
01:09:55 <shachaf> mazur: There are multiple such functions depending on the behavior you want.
01:09:56 <arkeet> what do you want it to do?
01:10:12 <mazur> i think <*> is what i want
01:10:18 <shachaf> arahael: OK, I should read more context before saying anything.
01:10:19 <ecognium> shachaf: I am so stupid. I wanted to do `Data.Map.Strict`. Thanks for making me look again. 
01:10:20 <mazur> just to apply a list of functions to a list of inputs
01:10:28 <arkeet> > [(+1),(+2)] <*> [10,20]
01:10:30 <lambdabot>  [11,21,12,22]
01:10:36 <arkeet> > zipWith ($) [(+1),(+2)] [10,20]
01:10:37 <lambdabot>  [11,22]
01:10:59 <startling> arahael, does that answer your question?
01:11:20 <arahael> startling: Not really, no.
01:12:35 <arahael> startling: I'm still left with the generic notion of a Free Monad, which I think I understand, yet you're saying that it's more than just being able to implement a DSL.
01:12:57 * shachaf looks for the original question.
01:13:15 <startling> arahael, I guess maybe I'm misunderstanding your use of "DSL".
01:13:27 <arahael> The _original_ question, is different, but still relevant: What's the advantgage of using the Free Monad + Interpreter pattern, as opposed to regular OO designs.
01:13:31 <startling> From where I'm sitting, it feels like less than being able to implement a DSL. :)
01:13:34 <arahael> What's _all_ the advantages, rather.
01:14:08 <arahael> startling: Other forms of DSL's are much more limited, imho. :) The Free Monad DSL is the most abstract and most safe DSL you can achieve, imho.
01:14:34 <shachaf> I don't know what regular OO designs are, but if they're more appropriate for something you should use them.
01:14:51 <shachaf> Free monads aren't the solution to all problems, or even most problems.
01:15:17 <startling> arahael, put another way: it sounds to me like you understand free monads.
01:15:48 <arahael> startling: I'm glad to hear that. :)  But I'm trying to _express_ the advantages, in english, in what might possibly become a blog post.
01:16:36 <startling> OK. I'm not sure there are that many advantages.
01:16:40 <arahael> shachaf: OO people regard OO designs as the most appropriate in all situations.
01:16:55 <bz> ls
01:17:05 <startling> One way it's helpful is that you can say "oh, X is obviously a Monad, since it's equivalent to Free F where F is a functor because ..."
01:17:23 <startling> and it gives you that mental shortcut for what a Monad instance means for your datatype.
01:17:30 <arahael> startling: One advantage, to me, is that it's abstract.  It's not tied to a particular implementation. And if you restrict yourself the particular DSL (which is the case in a Free Monad), then you're automatically threadsafe, side-effect free, and what else?
01:17:45 <startling> arahael, I don't think that has anything to do with Free.
01:18:02 <startling> Also, I can write free monads that aren't threadsafe.
01:18:08 <arahael> Oh?
01:18:44 <startling> Free IO, I guess.
01:18:47 <arahael> startling: I have a feeling thta my wife is about to ask me to cook dinner. Could you suggest a good website that explains at least one aspect of your thinking?
01:19:27 <startling> I guess it depends on what you mean by threadsafe.
01:19:28 <arahael> startling: Isn't IO already a monad?
01:19:35 <startling> Yes.
01:19:43 <arahael> So why Free it?
01:19:56 <startling> arahael, [] is already a monad, but Free [] is useful
01:20:07 <arahael> Ok, why is Free [] useful?
01:20:13 <startling> I don't think Free IO is useful. but I'm not sure what you mean by threadsafe.
01:20:30 <arahael> startling: The OO approach is not threadsafe, at all.
01:20:39 <arahael> I'm contrasting with OO approaaches.
01:20:42 <startling> arahael, so, I think you need to clarify what you mean.
01:20:57 <startling> constructing any kind of value is usually threadsafe in haskell, I guess.
01:21:01 <chattered> arahael: For a DSL-like interpreted language using free, I'd pick an example where some of the primitive "instructions" return a value. So if you're controlling a robot, you would have things like "senseData <- runSensor".
01:21:19 <arahael> startling: Indeed, because haskell allows you to tightly define any side effects.
01:21:21 <startling> even making IO actions is usually threadsafe.
01:21:44 <startling> arahael, so, why use Free at all if what you're interested in is threadsafety?
01:22:14 <arahael> chattered: Yes, that'd be a good idea, for my drawSquare, I should have something like 'getPreferredColour'.
01:22:50 <startling> arahael, I still don't get how Free comes into this.
01:23:03 <arahael> startling: I have to go now, please feel free to privmsg me.  As for 'if what you're interested in is threadsafety', I think you've misunderstood what I was asking for.
01:23:35 * hackagebot yi 0.12.1 - The Haskell-Scriptable Editor  https://hackage.haskell.org/package/yi-0.12.1 (DmitryIvanov)
01:23:48 <arahael> startling: I was asking for: "What are the advantages of... Free Monads + Interpreter...", and I gave a couple of example advantages, including threadsafety. I thought threadsafey was one advantage, but apparently it isn't.
01:25:12 <arahael> startling: After all, if you have a data structure.  You have a data structure. By that point, it's already threadsafe.
01:25:30 <startling> arahael, right. it seems what you're interested in is evaluation.
01:26:00 <arahael> startling: Not really. I'm interested in the application of the design.
01:26:04 <shachaf> I think most arguments you can make for some monad vs. a free monad can be made for some monoid vs. a free monoid.
01:26:09 <chattered> arahael: Thing is, how often do people define their own abstract syntax trees in Python and then write interpreters for them?
01:26:10 <startling> but you don't need to use Free, or even monad that looks sort of like Free, to evaluate something.
01:26:22 <shachaf> Why keep a list of values, rather than a value of type m for some specific monoid m?
01:27:00 <chattered> arahael: That sort of thing has always been the hallmark of ML and its descendents (including Haskell). Not so much Python, I think.
01:27:05 <arahael> chattered: rarely!
01:27:14 <arahael> chattered: Then again.  It happens quite often.
01:27:59 <arahael> chattered: But they don't think about it: They write classes, and allow metaclasses implement them.
01:29:04 <startling> I think maybe Free is a red herring.
01:29:06 <arahael> chattered: Ruby people profess to writing DSL's and the like, except that Ruby DSL's are imperative.
01:29:49 <arahael> startling: Perhaps it is, though I use Free because I want a monad that has no side effects, with the end result being all the business logic that then requires interpretation.
01:30:10 <arahael> startling: The obvious question is: Why not just do it all with "regular" IO monads?
01:30:29 <arahael> Instead of returning a data structure that explains how to draw a square, why not just draw a square? (Using SDL, perhaps)
01:30:36 <startling> arahael, well, lots of monads have no side effects, and you can interpret Free f x values in side-effecting ways.
01:31:38 <arahael> startling: But, the side effects are a property of the interpreter.
01:31:50 <jle`> i brushing rtooth hehe
01:31:53 <chattered> arahael: Maybe because you want to support multiple backends? Or you want to do some optimisations on the square drawing (think if you had a language that supported translations and you want to collapse translations) before you do the rendering.
01:31:56 <jle`> wrong window v.v
01:32:05 <startling> heh
01:32:18 <chattered> Or maybe you want to serialise the drawing instructions to disk and reload them later.
01:32:23 <startling> arahael, well, you can construct Free f x values in side-effecting ways too
01:32:58 <arahael> chattered: Yes, though there are common (and different) approaches in OO for that.  It's easy.
01:33:05 <arahael> startling: How!?
01:33:28 <startling> arahael, just have an IO (Free [] Int) or something.
01:34:01 <arahael> startling: I still don't understnad why you'd make a free monad out of a monad.
01:34:05 <arahael> It's _already_ a monad.
01:34:15 * ski . o O ( .. there are no side-effects in Haskell )
01:34:30 <ski> arahael : it makes a new monad
01:34:31 <startling> arahael, oh, I didn't explain that
01:34:42 <ski> `Free []' isn't isomorphic to `[]'
01:34:54 <startling> arahael, Free [] Int is a tree where each node is either an Int or a list of trees.
01:35:06 <chattered> arahael: What would be the easy way to do what I described in OO? (it's been too long for me!)
01:35:31 <startling> I think you'd just create an AST, and move that AST around.
01:35:32 <arahael> chattered: OO would define the neccessary API as an interface.
01:35:37 <jle`> arahael: Free Identity is definitely different than Identity :)
01:35:50 <arahael> chattered: And someone woudl implement a class that renders to, or uses, a concrete implemetnation of tha tinterface.
01:36:18 <arahael> Soryr, I must chat later.
01:36:23 <arahael> Gotta cook dinner now!
01:36:37 <startling> see ya.
01:37:26 <ski> arahael : there's this difference between a "deep embedding" representation and a "shallow embedding" representation
01:37:38 <ski> @wiki Embedded domain specific language
01:37:38 <lambdabot> http://www.haskell.org/haskellwiki/Embedded_domain_specific_language
01:37:55 <ski> arahael : see ^
01:39:40 <ski> arahael : for a shallow embedding, you think deeply about what your intended type *means*, and then you define your type in terms of that meaning (think "API"). for a parser (yielding a parse result of type `a'), this could be `String -> Maybe (a,String)', possibly (also returning unparsed remaining input, on success)
01:40:44 <ski> arahael : for a deep embedding, you encode your operations as data constructors, so your parser will then be some kind of tree (in the simplest case) that records how your particular parser was built
01:41:52 <ski> arahael : in this case, to actually use the parser, you need to *interpret* (iow pattern-match on, probably using recursion) the parser data structure, while consuming the input. so your "run" function (or functions/operations) is (are) nontrivial
01:42:29 <ski> arahael : while your (parser) producers are trivial (being data constructors)
01:42:35 <startling> ^ I think this is probably what you were asking about.
01:43:36 * hackagebot moesocks 0.1.0.18 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.0.18 (JinjingWang)
01:43:45 <ski> arahael : in the shallow embedding case, it's the other way around, the run function(s) (the parser consumers) is (are) trivial. just extracting the function (or one of the functions out of a record (think object) of functions (think methods)). while the producers are nontrivial
01:44:55 <ski> arahael : depending, it's also possible to have stages in between, with some producers being data constructors, and others being nontrivial (perhaps defined in terms of other producers. perhaps defined by *analyzing* the shape of argument parsers !)
01:46:11 <ski> arahael : the gain of using a deep embedding is that you can analyze (possibly deeply) the structure of your input data structures, when computing a new result one ..
01:46:50 <ski> arahael : .. and another gain is that you can have "nonstandard interpretations", perhaps adding it later, extracting some different kind of information that you didn't think of to begin with
01:47:20 <ski> arahael : with a shallow embedding, it's harder to add such extra interpretations/consumers late
01:47:39 <chattered> ski: Hence my example of saving instructions to disk, or doing optimisations before rendering.
01:48:05 <ski> arahael : however, if you think it's likely that you'll want to add more producers later, but not so likely to add more consumers, then a shallow embedding may a be better way to structure your code
01:48:36 * hackagebot shortcut-links 0.4.1.0 - Link shortcuts for use in text markup  https://hackage.haskell.org/package/shortcut-links-0.4.1.0 (Artyom)
01:48:55 <ski> arahael : now, `Free' can be seen as one way of getting a deep embedding (upto the functor being used)
01:49:59 <ski> chattered : yes. a similar example is analyzing source code to figure out cross-dependencies, instead of for execution or compilation
01:54:28 <arahael> ski: I've saved a screencopy of that, I'll have to read about it later, I never realsed that there was a difference between deep, and shallow, DSL's.
01:55:01 <arahael> ski: Though, except for my drawSquare example, I had assumed that real implemetnations of the interpreter would be non-trivial, for exactly the reason you explained.
01:55:19 <arahael> Anyway, will read and investigate later
01:56:41 <ski> arahael : anyway, the above is related to what is sometimes called the "FP vs. OO design structure" (though it's really variant/sum types vs. record types)
01:58:11 <arahael> ski: That particular "FP vs OO..." is exactly what I'm exploring.  Will definitely tak ea look at it, next chance I get.
01:58:13 <ski> (sometimes, stuffing a record full of functions is a very useful thing)
01:58:36 <ski> (vs. record/product types, i should say)
01:59:35 <ski> actual OO compicates the picture a bit by also having (implementation) inheritance (and also by usually being a PITA)
01:59:51 <arahael> ski: Can you please MSG me anything else you say, as I really am AFK now? :)
02:00:18 <chattered> arahael: But I'm enjoying ski's comments too!
02:00:18 <lf94> You can have an OO mindset in FP
02:00:20 <arahael> ski: Or wait until I get back to you (in a day, two, three, or four...)
02:03:45 <chattered> I find the nix language quite interesting here. It's pure functional and lazy, but feels quite OO. "self" is just a field which recursively references the defined record..
02:05:07 <lf94> Could someone explain data Thing = Thang { beep :: String, boop :: Int } ?
02:05:14 <lf94> What are beep and boop?
02:05:27 <arkeet> that is record syntax. beep and boop are field accessors
02:05:40 <lf94> How would you normally use beep and boop
02:05:49 <lf94> And when would you normally use record syntaxx
02:05:54 <lf94> What is wrong with pattern matching?
02:06:05 <startling> lf94, they're functions Thing -> String and Thing -> Int
02:06:08 <arkeet> pattern matching isn't a function.
02:06:16 <lf94> No obviously not
02:06:18 <dramforever> you could also use those records like this
02:06:20 <lf94> startling, Ah ok.
02:06:23 <arkeet> it's convenient when you want to define functions like that.
02:06:29 <lf94> startling, I can see how that can be useful.
02:06:32 <dramforever> f Thang{beep = s} = ... s ...
02:06:41 <dramforever> lf94: ^
02:06:55 <lf94> ...pattern matched record syntax?
02:06:56 <chattered> lf94: It gives you named fields, and there's some helpful sugar for changing just a few fields at a time.
02:07:01 <startling> lf94, yeah, it's not like you couldn't define them yourself with pattern matching
02:07:03 <dramforever> oh yes
02:07:06 <startling> lf94, just a syntactic nicety
02:07:11 <lf94> Gotchya
02:07:13 <dramforever> someOther {beep = "hello beep"}
02:07:28 <ttt_fff> chattered: yeah, it's cool enough that I want to learn it, weird enough I dont
02:07:29 <lf94> returns a new Thing?
02:07:49 <lf94> since you're "setting" beep
02:08:11 <dramforever> yes
02:08:24 <lf94> Alright. Thanks guys :)
02:08:37 * hackagebot trawl 0.1.0.0 - A tool for finding haddocks  https://hackage.haskell.org/package/trawl-0.1.0.0 (bmjames)
02:09:52 <ttt_fff> dramforever: why are you always online? what time zone are you in?
02:10:09 <dramforever> CST
02:10:23 <dramforever> oh sorry
02:10:24 <dramforever> no
02:10:34 <dramforever> I'm in Beijing
02:10:48 <dramforever> I thought CST was China Standard Time
02:11:46 <arahael> I thought china would have _several_ standard times.
02:12:04 <arahael> Heck, even Australia has several, and china is considerably larger.
02:12:04 <dramforever> maybe, I'm in Beijing time
02:12:13 <dramforever> arahael: yeah maybe
02:12:21 <dramforever> oh not maybe, surely
02:12:30 <dramforever> ttt_fff: where are you then?
02:12:48 <arahael> Interesting.
02:12:55 <chattered> arahael: I thought it just had the one, and that caused some havoc with people having to start work before way before sunrise. Maybe a myth.
02:13:06 <arahael> chattered: Wouldn't surprise me.
02:13:13 <arahael> china is weird.
02:13:23 * arahael is afk, again - this time eating, and startrekking.
02:13:23 <ttt_fff> i'm in the US, reading the reasoned schemer
02:13:25 <dramforever> no there are multiple
02:13:37 <dramforever> chattered: multiple, I made a weird mistake
02:13:38 <lf94> Yeah I'm currently in Australia, hence me being online for most of everyone's nights.
02:13:39 <dramforever> sorry
02:13:44 <arkeet> china has one timezone.
02:13:52 <ttt_fff> arahael: what type of food, how many calories, which episode, and in what resolution?
02:13:54 <int-e> https://en.wikipedia.org/wiki/Time_in_China
02:14:08 <ski> @time lambdabot
02:14:08 <lambdabot> I live on the internet, do you expect me to have a local time?
02:14:15 <ttt_fff> lf94: other time zone is good, you can avoid "if you swear you get banned" ops :-)
02:14:17 <int-e> adminstration gets a lot easier when you only have one time zone
02:14:28 <dramforever> The official national standard time is called Beijing Time (北京时间) domestically and China Standard Time (CST) internationally.
02:14:32 <dramforever> I was right =P
02:14:42 <dramforever> turns out
02:15:15 <ttt_fff> i guess taht's the advantage when you don't have a democracy
02:15:18 <ttt_fff> you can just impose standards
02:17:24 <pharaun> for better n' worse
02:18:19 <ttt_fff> china's not going to have the (1) let's send a rocket to space (2) what? those were in meters, not feet? oh
02:18:46 <pharaun> it will if it works with another country on space tech like the usa :p
02:18:47 <chattered> They're using F#?
02:18:51 <dramforever> actually I guess there are a few problems
02:19:01 <dramforever> wait let's move to #haskell-blah
02:27:24 <EvanR> pharaun: us space program gives chinese spaceprogram cold shoulder, national security at stake
02:27:33 <EvanR> they will steal our velcro technology
02:27:41 <EvanR> also #space
02:34:21 <zipper> How do I specify that I want to import a module from a specific package?
02:35:27 <startling> you can't.
02:35:29 <dramforever> you can
02:35:31 <startling> or rather you shouldn't.
02:35:35 <dramforever> sure
02:35:41 <zipper> I want to
02:35:50 <dramforever> zipper: wait what are you trying to do?
02:35:55 <dramforever> disambiguate?
02:36:05 <zipper> I want to import System.FilePath.Glob
02:36:16 <dramforever> so?
02:36:26 <zipper> This is exported by both the glob and filemanip packages
02:36:41 <dramforever> ok then that's what this is for
02:36:47 <dramforever> PackageImports
02:36:48 <arkeet> if you are working on a cabal project, it suffices to just depend on the package you want.
02:36:51 <dramforever> maybe PackageImport
02:36:55 <arkeet> (the other package will remain hidden, even if it's installed.)
02:36:55 <zipper> There is a way I just can't remember it
02:37:01 <zipper> Ler me look at package import
02:37:11 <arkeet> if you just need a reminder, a comment should suffice.
02:37:30 <arkeet> er
02:37:32 <zipper> arkeet: No, I am sure this is what I want. I am depending on both.
02:37:36 <arkeet> (I misunderstood.)
02:37:37 <arkeet> okay.
02:37:47 <arkeet> then PackageImports is the thing.
02:38:08 <MarcelineVQ> I'm confused, can't you just do a qualified import from the package you want something from?
02:38:11 <arkeet> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#idp23827600
02:38:21 <arkeet> MarcelineVQ: that requires this extension.
02:38:38 * hackagebot servant-server 0.4.4.1 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-server-0.4.4.1 (AlpMestanogullari)
02:39:04 <zipper> MarcelineVQ: How can I tell it which package I want to import System.FilePath.Glob?
02:39:24 <MarcelineVQ> arkeet's link seems to do that
02:40:05 <zipper> arkeet: Thanks
02:40:05 <MarcelineVQ> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/packages.html#package-thinning-and-renaming is related too
02:40:20 <arkeet> I was about to link that, yes.
02:40:46 <arkeet> the same syntax works in cabal's build-depends
02:41:30 <arkeet> but
02:41:41 <arkeet> this is new in cabal 1.20 and ghc 7.10, it seems.
02:41:55 <arkeet> so PackageImports is the more compatible method.
02:45:56 <nomeata> Hi. Under certain conditions, Cabal’s configure seems to consume huge amounts of ram, mostly in simplifyCondTree. Does that ring a bell with anyone?
02:53:38 * hackagebot harmony 0.1.0.0 - A web service specification compiler that generates implementation and tests.  https://hackage.haskell.org/package/harmony-0.1.0.0 (SantiMunin)
02:54:11 * EvanR clicks on harmony
02:57:15 <zipper> When I attempt to parse a cabal file with the following code. It prints out the cabal file and tells me it doesn't exist. What could be the issue? Here is the code and full error: https://gist.github.com/urbanslug/eceab9856baf1a22b792
02:59:57 <zipper> Could readFile be holding onto the file and making it impossible for other files to access it even after it's done?
03:05:03 <supki> zipper: readPackageDescription expects a filepath as the second argument
03:06:14 <zipper> supki: oi I see that now
03:15:24 <zipper> supki: Well that wasn't even the issue. The problem is that all my calls to get `allBuildInfo` are giving me an empty list despite these cabal files holding build info. https://gist.github.com/urbanslug/bab94b17f68c6ef31b59
03:32:24 <bennofs> zipper: have you solved the problem? the links are 404'ing on me
03:32:58 <bennofs> oh hmm, only the first one is broken it seems
03:34:27 <bennofs> zipper: perhaps the problem is that you haven't finalized your generic package description yet?
03:38:48 <bennofs> zipper: ah yes, since you haven't "configured" the package yet, the `packageDescription` is empty
03:39:05 <bennofs> zipper: packageDescription only holds generic information about the package which can be obtained without resolving flags etc
03:39:49 <bennofs> zipper: to get the real packageDescription (with all flags resolved), look at finalizePackageDescription in Distribution.PackageDescription.Configuration
03:50:58 <cow_2001> what's the bottle.py of haskell?
03:51:08 <cow_2001> this? http://snapframework.com/docs/tutorials/snaplets-tutorial
03:51:52 <dramforever> there are quite a few frameworks in haskell
03:52:08 <dramforever> afaik, snap, yesod are the larger ones
03:52:22 <dramforever> we also have scotty, which is much simpler
03:52:48 <cow_2001> i'm looking for the least hassle one for dead simple apps
03:52:49 <dramforever> servant is also great, but you might feel akward if you are not familiar with type level stuff
03:53:16 <erisco> Could not find moduke 'Music.Prelude'
03:53:18 <erisco> what did I do wrong
03:53:19 <dramforever> remember those are just afaik
03:53:53 <cow_2001> servant looks like what i'm looking for
03:54:11 <dramforever> cow_2001: servant can handle a lot of interesting stuff for you 
03:55:17 <cow_2001> now, how do i safely pass cli program arguments from user input?
03:55:39 <dramforever> safely hmm...
03:56:03 <dramforever> I heard that optparse-applicative is very good
03:57:22 <ChristianS> yeah, optparse-applicative is popular
03:57:30 <cow_2001> maybe i could just feed it through stdin
03:58:00 <cow_2001> i like Turtle
03:58:05 * arahael is back.
03:58:59 <MarcelineVQ> Are you trying to make a remote shell?
03:59:12 <dramforever> hmm...
03:59:37 <MarcelineVQ> Giving remote users access to a command line is usually kind of a big deal security-wise, even if the user is just you
04:00:01 <arahael> ski: If you're still around, what you were saying about deep adn shallow embedding makes sense.
04:00:09 <arahael> ski: But it seems to me thta the techniques are the same.
04:01:15 <arahael> ski: For instance, if the DSL representation embeds functions and the like, then interpreting it obviously becomes a bit more complex, but not much more (imho).
04:02:24 <arahael> ski: I think for a non-trivial cases, where you have a lot of meaning in the DSL, and where there may be multiple interpretations (for example, a solver), then it's neccessarily difficult to implement an interpreter for it.
04:03:18 <arahael> startling: I think ski was talking about wh...  Ah, he's gone.
04:04:25 <arahael> But yeah, I think ski was on the right track with what I was trying to aska bout.
04:07:45 <zipper> Is there a quick function to replace '.' with '/' in a string?
04:08:38 <zipper> Oh intersperse
04:09:21 <dramforever> your web app sounds ... weird
04:09:39 <chattered> zipper: map?
04:11:13 * ski stares at arahael
04:11:22 <dramforever> > map (\case '.' -> '/'; a -> a) "foo.bar.baz"
04:11:24 <lambdabot>  <hint>:1:6: parse error: naked lambda expression ''
04:11:35 <arahael> ski: Am I not making sense?
04:11:38 <dramforever> > map (\x -> case x of {'.' -> '/'; a -> a}) "foo.bar.baz"
04:11:39 <lambdabot>  "foo/bar/baz"
04:11:44 <dramforever> chattered ++
04:12:28 <ski> arahael : you are, basically. just wondering if you wanted to comment more
04:12:51 <ski> arahael : i'm not quite seeing what you mean by "But it seems to me thta the techniques are the same."
04:13:24 <arahael> ski: Well, it does seem that the techniques are the same.  You still need to define the types, which dictates the data structure.
04:13:33 <arahael> ski: And then you need to interpret it, which may or may not be easy.
04:14:08 <ski> > do x <- "foo.bar.baz"; [case x of '.' -> '/'; x -> x]
04:14:09 <lambdabot>  "foo/bar/baz"
04:14:28 <dramforever> isn't that just map?
04:14:37 <ski> it is
04:14:53 <arahael> ski: Yet most of the exaplmes I've seen only show simple, trivial ones. I was wondering if you could show (or suggest) some complicated examples that can only be (elegantly) done in this way?
04:15:00 <ski> > do x <- "foo.bar.baz"; case x of '.' -> "::"; x -> [x]
04:15:01 <lambdabot>  "foo::bar::baz"
04:15:28 <zipper> :t zipWith
04:15:29 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
04:18:27 <ski> arahael : a shallow parser could be `type Parser a = String -> Maybe (a,String)' (or probably using `newtype' to hide the implementation). a deep(er) one could be `data Parser a = Return a | Choice [Parser a] | Consume (Char -> Parser a)'
04:19:31 <ski> arahael : the shallow is typically using a function (or a record of functions). the deep one is typically using a data structure recording the use of the primitive operations (or some of them, at least)
04:19:48 <arahael> ski: I've only used the latter form.
04:20:22 <ski> the former is more akin to the OO approach
04:21:34 <yashinbasement> hey can any one explain this line to me apppend [] l2 = l2 
04:21:48 <yashinbasement> apppend(e:es) lst = e:apppend es lst
04:21:51 <arahael> ski: Yes, that analogy does make sense.  A "deep" DSL here is extremely complex in OO approaches, thanks for the insight.
04:21:57 <dramforever> yashinbasement: do you know what those : and [] mean?
04:22:03 <yashinbasement> the second line is not clear to me
04:22:20 <dramforever> oh?
04:22:27 <ski> compare with having an abstract base class (or an interface) `Parser<A>', with a virtual method consuming a string and (maybe) yielding an `A' and the remainder of the string, and then having concrete subclasses (or instances of the interface) for each basic parser combinator
04:22:27 <dramforever> which part do you find confusing?
04:22:56 <yashinbasement> rhs
04:23:02 <yashinbasement> right hand side
04:23:09 <ski> arahael : it is complex because OO languages typically doesn't support variant/sum types (aka algebraic data types, more or less) with pattern-matching
04:23:17 <dramforever> yep so I guess you are having a problem parsing that
04:23:34 <ski> arahael : you need both OOish record/product types, and variant/sum types
04:23:43 <danilo2> Hello guys! :) I've got a naming - related question to you :) How would you name operations of taking and releasing elements to a general Pool structure (this is not resource Pool - just any element pool, like name-pool or resource-pool)
04:23:44 <dramforever> function application binds stronger than any operator
04:24:00 <yashinbasement> no it works fine
04:24:20 <dramforever> then what's confusing you?
04:24:28 <yashinbasement> but I don't quite understand how it works , I mean what are the steps are happening
04:24:43 <yashinbasement> e:apppend ?
04:24:48 <yashinbasement> what is it
04:24:55 <dramforever> no that shows you are having problems parsing it
04:24:58 <dramforever> function application binds stronger than any operator
04:25:14 <dramforever> e:append es lst means e : (append es lst)
04:25:40 <ski> arahael : simulating variant types using record types usually requires arcane things like continuation-passing-style (see "Visitor pattern"), or horrible things like `.. instanceof ..' or something similar in spirit
04:25:58 <yashinbasement> is that a look
04:26:02 <yashinbasement> sorry loop
04:26:07 <dramforever> recursion
04:26:19 <yashinbasement> ahhh
04:26:19 <arahael> ski: instanceof is indeed horrible, I sometimes have to do that in python, but yeah.
04:26:19 <ski> arahael : well, or just including all the variant alternatives in a record, and using `null' for all but one of them .. which is its own punishment
04:26:22 <yashinbasement> yeah sorry
04:26:39 <yashinbasement> so I try to explain it correct me if I am wrong
04:26:45 <dramforever> ok
04:26:50 <arahael> ski: I often end up trying to make sure I've covered every possibility.
04:26:53 <dramforever> ski: or use unions and good luck
04:26:58 <dramforever> =P
04:28:02 <yashinbasement> ohh no that's what it is. so take the head and put the tail which is append es lst
04:28:04 <yashinbasement> hhhh
04:28:21 <ski> Tony Hoare / Historically Bad Ideas: "Null References: The Billion Dollar Mistake" <http://lambda-the-ultimate.org/node/3186>,<http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare>
04:28:42 * hackagebot hsexif 0.6.0.5 - EXIF handling library in pure Haskell  https://hackage.haskell.org/package/hsexif-0.6.0.5 (EmmanuelTouzery)
04:28:46 <yashinbasement> I mean tail:head(append es lst)
04:28:54 <arahael> ski: I've read that.  Just to be sure we're talking about the same thing, when you say "record", you're referring to a type of haskell record, used in an OO style?
04:28:55 <yashinbasement> sorry other way around
04:29:22 <yashinbasement> head:tail(append es lst)
04:29:36 <ski> arahael : the CPS encoding relies on `Either T U' being equivalent to `forall a. (T -> o) -> (U -> o) -> o', in terms of types
04:30:23 <ski> arahael : i'm referring to the general programming computing science idea of a record, however that may be spelled in any language that has them
04:30:28 <ski> (COBOL was the first)
04:30:31 <arahael> ski: I've yet to learn about forall, though I'm aware that there's several types of 'forall' in haskell.
04:30:43 <arahael> ski: Ah, like, like a struct.
04:30:49 <ski> yes, that's the same thing
04:31:42 <ski> (there's some related differences due to whether the language has first-class functions or not .. not having that makes it more painful to stuff functions into a record)
04:31:48 <joco42__>     Expected type: [Char]
04:31:48 <joco42__>                    -> bytestring-0.10.4.0:Data.ByteString.Lazy.Internal.ByteString
04:31:48 <joco42__>       Actual type: [Char] -> ByteString
04:31:52 <joco42__> sorry
04:31:59 <joco42__> I wanted to paste this online.
04:32:10 <joco42__> pressed the wrong button
04:32:15 <joco42__> in this irc client
04:32:17 <ski> @type either
04:32:18 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
04:32:43 <ski> could be thought of as effecting the translation to CPS (modulo argument ordering)
04:32:50 <arahael> ski: Yeah, that would be a syntax detail, at the conceptual level.  I am not completely sure about what you say about unions though.
04:33:11 <arahael> ski: Possibly because in Haskell, I just pattern-match most of the time, and in other languages, unions are really awful I avoid them.
04:34:20 <dramforever> sorry I just got disconnected a while ago
04:34:30 <joco42__> any ideas where this error is coming from ? I have been trying to figure out in lest 1 hour without luck... i am quite q newbee... 
04:34:32 <joco42__> http://snag.gy/xAieD.jpg
04:35:20 <dramforever> yashinbasement: hello are you still there?
04:35:27 <ski> arahael : `union's in C and C++ (and C# ?) aren't quite the same thing
04:35:30 <dramforever> I didn't quite get what you mean by head and tail there
04:35:53 <yashinbasement> I mean we repprsent a  list with head:tail right
04:36:12 <dramforever> ok
04:36:20 <yashinbasement> : explains thing the equation
04:36:29 <yashinbasement> in the eqauation
04:36:38 <arahael> ski: C++ doesn't really have union (It has them, but only barely - purely to maintain C compatibility, and badly, at that).  Don't think I've ever seen them in C#, though, but what are union sin haskell?
04:36:45 <yashinbasement> apppend(e:es) lst = e:apppend es lst
04:37:01 <dramforever> yashinbasement: yes you are right, just append the tail and the other list
04:37:02 <yashinbasement> so es and lst are arguments of the append function
04:37:07 <dramforever> yep
04:37:09 <yashinbasement> yep
04:37:16 <dramforever> so far so good
04:37:22 <ski> arahael : a value of a sum / variant / discriminated/disjoint union type itself knows which alternative it is. a value of a union type as in C doesn't, you have to know that separately (in any way you like)
04:38:43 * hackagebot regex-deriv 0.0.5 - Replaces/Enhances Text.Regex. Implementing regular expression matching using Brzozowski's Deriviatives  https://hackage.haskell.org/package/regex-deriv-0.0.5 (KennyLu)
04:39:24 <yashinbasement> hey what do you mean by function application binds stronger than any operator
04:39:44 <yashinbasement> :dramforever
04:39:47 <dramforever> e : a b means e : (a b)
04:39:54 <arahael> ski: Ah.  I end up doing that using templates, most of the time, as then you _do_ know which alternative it is, a bit like haskell pattern matching.
04:40:02 <dramforever> as well as e * a b means e * (a b), etc.
04:40:25 <dramforever> arahael: IIRC templates have less compile-time checks
04:40:43 <yashinbasement> thanks :dramforever
04:40:53 <dramforever> or rather, more checks are defered to where the template is actually used
04:40:57 <arahael> dramforever: C++ templates implement SFINAE, rather explicitly.
04:40:58 <dramforever> yashinbasement: you're welcome
04:41:09 <ski> arahael : a variant record type in Pascal/Ada might be thought of as something like `struct my_var_rec { foo_t *common; enum {simple,advanced,composite} tag; switch (tag) { case simple: int n; break; case advanced: int x,y; int *p; break; case composite: struct my_var_rec *children;} }'
04:41:36 <dramforever> =)
04:41:59 <arahael> ski: Ah, right.  Or a polymorphic type.
04:42:15 <ski> arahael : the `switch (tag) { case simple: int n; break; case advanced: int x,y; int *p; break; case composite: struct my_var_rec *children; }' part of this corresponds to a C union, except that we don't say which external (to the "union") value (here `tag') is used to determine which of the cases is the current one
04:43:26 <ski> arahael : with dependent types (as in Agda,Idris,Coq), one can express the above pattern exactly
04:43:31 <arahael> ski: In other words, you /have/ to match it, you can't just query it.
04:43:44 <arahael> ski: I very much like the idea of having to match all the cases.
04:43:45 <ski> arahael : yes, that would be the correct way to do it
04:45:24 <ski> (i would expect <https://en.wikipedia.org/wiki/ATS_%28programming_language%29> to use something like the above, e.g.)
04:47:25 <ski> arahael : there are different senses of the term "polymorphism" in programming (see "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>)
04:48:20 <arahael> ski: I've recently found out, when I trired to argue with someone at work that dynamic languages, by definition, have polymorphsm. He argued that they don't, because they're not statically typed.  Took me a while to come around to his point.
04:48:27 <ski> arahael : in Haskell, polymorphism, unqualified, means "parametric polymorphism", which is different from the kind of polymorphism related to subtyping (namely inclusion polymorphism) that is typical in OO
04:48:55 <arahael> ski: And in dynamic languages?
04:49:07 <arahael> ski: I was arguing that python had parametric polymorphism.
04:49:41 <ski> (however, generics (like templates in C++) are (more or less) parametric polymorphism .. (though usually we don't have the very useful "parametricity" property, that allows us more powerful forms of refactoring and reasoning. Haskell has parametricity))
04:50:14 <ttt_fff> #$%^ #$% #$%^#%^ #$% #$56 #%$^ debugging infinite loops in haskell iS #**#&$ #&*%*#($ #*%$($ #*($ because, my Logs are lazy ... so they don't get outputted until the computation completes, thus Ctrl-C-ing my app kills the computation and I get no logs. %&#($&$ infinite loops
04:50:34 <arahael> ski: I'm familiar with generics - both in the C# sense, and the C++ sense (and they're very different).  Did you intend to group them in the same way?
04:50:57 <ttt_fff> no
04:51:21 <ski> arahael : for a dynamically typed programming language, the type system is all in your head (in the best case). you may use parametric polymorphism, inclusion polumorphism, structural typing ("duck-typing"), &c. as you wish .. at least with enough discipline (using run-time contracts (especially if they assign blame properly in the higher-order case) can also be useful here)
04:52:03 <ski> arahael : i'm grouping them in the same general kind of thing, yes, having an operation take type parameters
04:52:32 <martinvlk> @pl (\x -> (maybeToList x ++))
04:52:32 <lambdabot> (++) . maybeToList
04:52:33 <arahael> ski: My head is becoming a poorer choice for a type system - programs are getting too complex.
04:52:40 <ski> (being able to do case analysis on the type parameter is one of the things that makes you lose parametricity)
04:52:48 <arahael> Oh?
04:53:01 <arahael> Isn't pattern matching a special case of case analysis?
04:53:24 <darenthis_> I have a question about resource cleanup. Is there a cleaner way to write this? http://lpaste.net/4827736518527287296
04:53:43 * hackagebot Hangman 0.1.0.0 - The classic game of Hangman.  https://hackage.haskell.org/package/Hangman-0.1.0.0 (lf94)
04:54:00 <ski> arahael : consider `mystery :: [a] -> (Bool,[a])'. by parametricity in Haskell, we know `mystery' can't inspect the elements of type `a' in the input list (since it has no way of knowing which type the caller will actually use for `a')
04:54:10 <Noinia> hmm, how do I wait for completion when streaming data into a sink using Conduit? I thought this should just work : http://lpaste.net/138952 but it seems that sometimes renameFile  is called before we have written all file data to it 
04:54:33 <Axman6> darenthis: that let binding does nothing different than writing the expression you're binding x to in the place you use x
04:54:37 <ski> arahael : therefore, the returned `Bool' can only depend on the length of the input list, and the output list must be some permutation of the input list, possibly with some elements dropped, and others repeated
04:54:46 <arahael> ski: Ah, yep.  You can in C++, though.  If you do it such that it doesn't compile, then the compiler tries the next pattern.
04:54:58 <Axman6> darenthis: I would look into using `bracket`:
04:55:01 <Axman6> :t bracket
04:55:03 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
04:55:13 <darenthis> Axman6: I have to force it before the connection is closed
04:55:23 <Axman6> that does no do that
04:56:02 <arahael> ski: Thanks for your discussion - it was extremely enlightening.
04:56:11 <arahael> ski: I must get to bed soon.
04:56:49 <ski> arahael : this can be very useful with higher-order code .. like `anotherMystery :: (a -> Bool) -> [a] -> [a]'. by looking at the type only, we can see that it can *only* inspect the elements of the input lists *via* the callback function that we give it. if we choose to not divulge some detail of the elements, then we know they call to `anotherMyster' can't depend on that detail (and so must work the same if we change that detail)
04:57:15 <ski> s/they call to/the call to/
04:58:02 <arahael> ski: Yep, that bit I understand.
04:58:27 <ski> arahael : imho, one of the points of having a statically checked type system (or even just explicitly stated formal rules) is to be able to offload cognitive mindspace for checking such boring things, so that we can focus more on the interesting (and harder) stuff
04:59:14 <arahael> ski: Definitely.  Tehre are so many times I wished that python let me do that.
04:59:19 <darenthis> Axman6: thanks. This does of course mean that the code is working, just not for the reasons I thought
04:59:28 <lpaste_> Axman6 annotated “Ugly amqp code” with “Ugly amqp code (annotation)” at http://lpaste.net/4827736518527287296#a138953
04:59:37 <arahael> ski: Unit tests only gets you so far, and they take ages.
04:59:41 <ski> arahael : re parametricity. this is a case of trading some expressive power for *reasoning* power. what good is a language that can do lots of things, if you can't reason (including refactor) effectively in it ?
04:59:50 <Axman6> darenthis: see the annotation above
05:00:08 <arahael> ski: Point.  Most people today, though, are happy they can organise code, and program imperatively.
05:00:19 <ski> arahael : both expressivity and "reasonability" of a language counts. raising one typically lowers the other. the trick is trying to find ways to not do that as much, or at all
05:00:55 <arahael> ski: I wish I was able to understand that line.  I'm still at the stage where I think, logically, that you should be able ot raise both.
05:00:58 <darenthis> Axman6: thanks, that's helpful
05:01:01 <ski> (and state side-effects is one of the common things that hinders "reasonability" as well)
05:01:04 <arahael> ski: Albiet at a cost of making for a more complex language.
05:01:13 * ski nods
05:01:53 <ski> (well .. side-effects in general. but state side-effects in particular, because of how pervasive they typically are)
05:02:16 <Gurkenglas> Why is that fmap in "sequence $ fmap (connectQueue chan) queueNames" not map? sequence takes a list, after all.
05:02:38 <ski> it just as well have been
05:02:52 <ski> (and it might be argued that it would be better as `map')
05:02:57 <ski> however ..
05:03:00 <arahael> ski: C++ is probably a great example here.  It's extremely expressive, and can be reasoned, though it has a _lot_ of rather severe warts.  Haskell has few warts (that I'm aware of), yet the language is complex enough (due to being able to leverage the type system), and syntatically seems simple.
05:03:05 <ski> @type sequence
05:03:07 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
05:03:35 <ski> Gurkenglas : with recent generalization ^, we really do need `fmap', if we want to retain the generality of that in the caller
05:03:35 <maerwald> I also usually just write fmap, because I don't want to think about "fmap or map now?"
05:04:24 <maerwald> "map" should just be removed, afais. I don't see what exactly the gain is, except having a more specialised type signature than fmap
05:04:49 <arahael> ski: G'night - and thanks. :)
05:04:50 <Gurkenglas> And then eventually rename fmap into map?
05:04:59 <maerwald> hmm, sounds interesting
05:05:03 <maerwald> but breaks too much legacy code
05:05:09 <ski> arahael : .. semi-recently, i've been pondering (understanding and) cleaning up and stealing "rvalue references" in C++ for an idea of mine related to modes in logic programming
05:05:45 <ski> Gurkenglas : maybe. originally, in Haskell 1.5 (?), we had `map :: Functor f => (a -> b) -> (f a -> f b)'
05:05:59 <ski> arahael : night
05:06:47 <Hafydd> Why ever did they change it to the more particular case?
05:07:06 <Axman6> it's easier for beginners to work with concrete types
05:09:39 <nomeata> Is there a way to make cabal build every module with a separate invocation of ghc (to save memory)
05:15:15 <magnap> Is it possible to make a library general over any 1 type? I am making a small library for playing board games (minimax), where currently `Boardgame g` is a typeclass, and instances must provide e.g. a function `score :: g -> Int`. I would like to have that function be `:: Ord s => g -> s`, but not force the instance to be polymorphic over all possible instances of `Ord`. In other words, is there a way to "
05:15:21 <magnap> pass" a type into a library?
05:16:18 <chattered> magnap: Could you use an associated type?
05:16:28 <chattered> Is the s determined by g?
05:16:38 <magnap> chattered: Ideally, yes
05:17:09 <magnap> Should I make an lpaste of my current code?
05:17:18 <Hafydd> magnap: the term "board game" sounds too specific if you're writing a min-max algorithm.
05:17:55 <magnap> Hafydd: I use it as a synonym for a vague concept I have of a perfect-information game with a finite number of players
05:18:15 <ski> magnap : you want a "module functor" (unrelated to `Functor' and CT functors), as in the module systems of the MLs
05:18:42 <Hafydd> PIGWAFNOP
05:18:43 <ski> an associated type could work
05:19:23 <magnap> ski, chattered: Type families is what I need to learn about to use associated types, right?
05:19:28 <dramforever> magnap: multi-param typeclasses?
05:19:33 <dramforever> that could also work
05:20:02 <chattered> magnap: Yeah. But if g determines your s, you probably don't need to worry about Ord.
05:20:37 <magnap> chattered: It's a neccesary constraint for the algorithm
05:20:42 <kronole> Will reading SICP as a beginner give me an edge over programmers who haven't read it?
05:21:04 <Axman6> knowledge is power
05:21:07 <Axman6> so, probably
05:21:12 <Hafydd> Most of them, probably.
05:21:56 <ggole> The question to ask is whether it will give you an edge over the you that didn't read it.
05:22:18 <magnap> Is there a way to do this without using extensions?
05:22:18 <chattered> magnap: Okay. But I think you would put the constraint outside the typeclass definition.
05:22:37 <Phillemann> Is there a point-free version of \x -> (f x,x)?
05:22:38 <ski> kronole : possibly
05:22:55 <dramforever> :t \x -> (f x, x)
05:22:56 <lambdabot> (Show t1, FromExpr t) => t1 -> (t, t1)
05:23:02 <dramforever> uh
05:23:08 <dramforever> @pl \x -> (f x, x)
05:23:08 <lambdabot> (,) =<< f
05:23:29 <dramforever> Phillemann: we have this one thing called pl
05:23:31 <ski> kronole : learning Haskell may also help
05:23:37 <Phillemann> dramforever: I didn't know
05:23:52 <dramforever> Phillemann: also you can pm lambdabot to play with it
05:23:54 <ski> kronole : CTM is also good book, about multiple paradigms
05:23:57 <ski> @where CTM
05:23:57 <lambdabot> "Concepts, Techniques, and Models of Computer Programming", by Peter Van Roy,Seif Haridi, at <http://www.info.ucl.ac.be/~pvr/book.html>
05:24:01 <Phillemann> dramforever: Grat, thanks
05:24:17 <ski> @help pointless
05:24:17 <lambdabot> pointless <expr>. Play with pointfree code.
05:24:37 <dramforever> @pf (,) =<< f
05:24:37 <lambdabot> Maybe you meant: pl bf
05:24:44 <dramforever> @unpl (,) =<< f
05:24:44 <lambdabot> (f >>= ((,)))
05:24:48 <dramforever> sigh
05:27:47 <magnap> So, a multi-parameter type class or a type family seems to be what I need. Is there a convention for choosing one over the other?
05:28:46 <Gurkenglas> @pl \x -> (f x, x) -- dramforever
05:28:46 <lambdabot> (,) =<< f
05:28:56 <dramforever> yep
05:30:56 <ski> magnap : MPTCs are more general. an MPTC with acyclical FDs can be expressed with ATs. the MPTC concept is simpler to grasp, imho, and FDs aren't that bad either
05:31:47 <magnap> ski: is AT short for algebraic type?
05:31:58 <hodapp> kronole: are you concerned about learning, or about beating other people?
05:32:19 <ski> magnap : with ATs, or TFs/DFs in general, you need to graph type expressions reducing based on the shape of arguments, and some rules for well-formedness
05:32:39 <ski> magnap : that's how i was using the initialism here, yes
05:33:26 <magnap> ski: I have trouble parsing your next-to-last sentence. Can you explain it differently?
05:34:02 <ski> er .. s/graph/grasp/
05:34:57 <magnap> ski: "type expressions reducing"?
05:35:09 <magnap> Sorry if I'm being dense, English is my second language
05:36:58 <kronole> hodapp: both
05:37:18 <kronole> mostly learning, though; i want to learn how to program with the best possible source -- which seems to be SICP
05:37:50 <Sindriava> hodapp + 1
05:38:10 <dramforever> kronole: I wonder if you could actually "beat" someone at programming
05:38:11 <ski> magnap : if you have `class Foo a where type Bar a' and `instance `Foo Int where type Bar Int = Bool', then `Bar Int' will reduce/simplify to `Bool', while `Bar Integer' may simplify to something unrelated (or not at all, if there's no instance)
05:38:21 <Sindriava> kronole: Little word of advice: Trying to get edge over other programmers doesn't get you and edge over other programmers
05:38:24 <chattered> ski: I think associated types placed nicer with the type inferencer, even when using functional dependencies. Did I misread that?
05:38:42 <Sindriava> This is why I've always hated programming / math competitions
05:39:00 <ski> chattered : i'm not sure how that stands, comparatively speaking
05:39:04 <dramforever> Sindriava ++
05:39:24 <chattered> ski: s/think/thought   s/played/placed
05:39:27 <magnap> ski: I see now. Thanks for being so patient. However, looking through the Haskell Wiki page on functional dependencies, it seems they are a bit too general for my case
05:39:30 <chattered> s/placed/played
05:39:31 <dramforever> actually if they were called "math problems solving competitions" it's much better
05:39:37 <ski> kronole : one of the important things is to remember to have fun
05:39:58 <magnap> Associated types seems to be more fitting for my particular use
05:40:16 <ski> magnap : it's probably just fine
05:40:24 <Sindriava> Look, one of the most important reasons that #haskell is a nicer place than most other programming IRC channels is that Haskell has closer to actual science than programming
05:40:46 <ski> @karma Sindriava
05:40:47 <lambdabot> Sindriava has a karma of 1
05:40:55 <ski> Sindriava ++
05:40:57 <ski> @karma Sindriava
05:40:57 <lambdabot> Sindriava has a karma of 1
05:41:05 <ski> dramforever ^
05:41:07 <Sindriava> Programming is young, and everyone with a hole in their ass has an opinion on what's best and 100 reasons why everyone else is a dumbo
05:41:13 <chattered> magnap: SICP gives a consistent story about programming in terms of "abstraction." I really like it. But you'll find haskellers like abstraction.
05:41:34 <dramforever> ski: no...it just means "agree"
05:42:12 <ski> ok. just pointing out that if you intended to raise the karma, you should do `@karma+ Sindriava' or `Sindriava++'
05:42:22 <chattered> Whoops.
05:42:26 <magnap> chattered: I think you might be confusing me with someone else. The person asking about SICP was kronole
05:42:33 <chattered> kronole: SICP gives a consistent story about programming in terms of "abstraction." I really like it. But you'll find haskellers like abstraction.
05:42:36 <Sindriava> Math is not. Math has systems in place. Math is much more objective. Granted, math went through this phase too (remember the time someone tried to make a law that Pi equals 3.2? Yah, that happened.)
05:42:47 <Sindriava> ski: Neat, I had no idea karma existed!
05:42:48 <chattered> magnap: Apologies!
05:42:51 <Sindriava> @karma+ ski
05:42:51 <lambdabot> ski's karma raised to 33.
05:42:53 <dramforever> ski++
05:42:58 <dramforever> hmm...
05:43:01 * ski thinks karma is mostly silly
05:43:01 <dramforever> @karma+ ski
05:43:01 <lambdabot> ski's karma raised to 35.
05:43:07 <dramforever> ski ++
05:43:19 <ski> @karma- ski
05:43:19 <lambdabot> You can't change your own karma, silly.
05:43:25 <ski> see !
05:43:27 <Sindriava> Where did 34 go? :D
05:44:07 <magnap> @karma ski
05:44:08 <lambdabot> ski has a karma of 36
05:44:09 <ski> Sindriava : see dramforever above
05:44:22 <dramforever> ski ++
05:44:25 <dramforever> @karma ski
05:44:25 <lambdabot> ski has a karma of 36
05:44:37 <dramforever> maybe we shouldn't play with this system like that
05:44:51 <Sindriava> kronole: Point being, you read something, you learn something, you rinse and repeat that until you can write something, then you write it, other's read it, decide whether it's sound, you move on with your life and read something else
05:45:40 <Sindriava> kronole: In time, someone will read your shit and it will inspire them to write their own shit. It's like Hakuna *Math*ata or whatever
05:46:31 * ski idly notes dons and Cale aren't in the top ten anymore ..
05:46:59 <Sindriava> lambdabot is neat, i should read up on what it can do
05:48:18 <Axman6> Sindriava: /msg lambdabot list
05:48:30 <Axman6> the /msg lambdabot help <foo>
05:48:46 <Sindriava> Oooh, neat-o!
05:48:47 <ski> @listmodules
05:48:47 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search seen slap source spell system tell ticker todo topic type undo unlambda unmtl version where
05:48:49 <ski> @help list
05:48:49 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
05:48:54 <Axman6> :(
05:48:58 <ski> use that ^ (privately)
05:49:46 <ski> (you need an intitial `@' (or `?' or something else i don't recall))
05:50:16 <Sindriava> @quote (.)
05:50:16 <lambdabot> scook0 says: real men don't need semantics, they pipe meaning directly into their compilers!
05:50:32 <hodapp> kronole: I really wouldn't waste time worrying about the "best possible" source, or pretending that one even exists.
05:50:42 <magnap> @quote lambdabot
05:50:42 <lambdabot> lambdabot says: Enough!
05:50:43 <Sindriava> @quote boob
05:50:44 <lambdabot> sixthgear says: sex pepsi coke sega nintendo girls sexy nudes pamela anderson WAVs MOVs weird al mtv boobs boob simpsons sex games doom doom ][
05:51:13 * Axman6 agrees with lambdabot, Enough!
05:51:13 <Sindriava> There's " (.) I am the boob operator! " somewhere in there :D
05:52:41 <hodapp> o_O
05:55:47 <kronole> How do people mod online video games, like GTA: Online and CoD? Does it involve programming or something?
05:56:59 <Axman6> depends what they're modding
05:57:25 <kronole> Like, mod menus and rank increases, for example
05:57:41 <kronole> Randomly blowing players up, like this guy is doing to me in GTA: Online as I type
05:57:45 <Axman6> it'll still depend on many things
05:57:58 <ralu> once it involved implmeneting new logic it usually involves programming
05:58:05 <Axman6> this probably isn't the best place to ask though
05:58:08 <pacak> kronole: Haskell?
05:58:49 <ralu> GtaOnline a -> GtaOnlineMod a
06:01:27 <maerwald> is there any good git library for haskell? the documentation of gitlib is either non-existent or old and broken
06:03:19 <pacak> ralu: There's not that much stuff you  can do using that type signature. Looks like a natural transformation.
06:03:54 <ralu> i igoured that out once writing this
06:11:48 <lpaste_> Magnap pasted “Boardgame solver” at http://lpaste.net/138958
06:14:13 <magnap> So, after having tried using both associated types and multi-parameter type classes, I have realized how little I understand either. Now I ask again: how can I have `Player` and `Score` be passed in by the module instancing `BoardGame`?
06:17:17 <dramforever> just create the instance as usual
06:17:48 <dramforever> wait doesn't this work now?
06:18:02 <dramforever> oh I understand
06:18:08 <Gurkenglas> You mean have each instance declare the type it uses in place of Player and Score?
06:18:12 <magnap> dramforever: No, right now Player and Score are predetermined
06:18:19 <magnap> Gurkenglas: Exactly!
06:18:24 <dramforever> magnap: associated types are part of the class
06:18:44 <dramforever> magnap: so to have each instance declare them just write it as part of the instance
06:18:48 <magnap> With the constraints of Ord Score and Eq Player
06:18:56 <kronole> What does 'dram' mean?
06:18:58 <dramforever> yes you can put that on the class
06:19:14 <magnap> dramforever: I can't see a way to do so while keeping Player :: *
06:19:15 <dramforever> kronole: intentional misspelling of dream
06:19:24 <dramforever> magnap: you can do this:
06:19:41 <dramforever> class Ord (Player a) => Game a where type Player = ...
06:19:49 <dramforever> or hmm something like that
06:20:16 <marchelzo> In a C library, there is a function like bind_event_handler(object, event_type, handler_callback, data) where data is a void * so that you can pass arbitrary mutable state to the handler. How can I go about exposing this cleanly in the Haskell bindings?
06:20:20 <Gurkenglas> magnap, "type family Player g :: * -> *" and "type instance Player (BoardGame) = MyPlayer" should allow you to do that
06:20:36 <dramforever> oh that
06:20:38 <Gurkenglas> (Nevermind those brackets)
06:20:57 <magnap> Gurkenglas: Can I make that associated?
06:21:31 <dramforever> magnap: put it inside the class
06:21:31 <Gurkenglas> Sorry, I don't know what you mean by associated. I just remembered that what you want has been done by the recursion-schemes package with Base.
06:21:35 <dramforever> or something
06:21:46 <Gurkenglas> Paste your code? I could annotate it with what I mean
06:21:51 <dramforever> @let class C a where type family X :: * -> *
06:21:51 <lambdabot>  Parse failed: Parse error: family
06:22:05 <dramforever> @let class C a where type X a :: *
06:22:07 <lambdabot>  Defined.
06:22:13 <dramforever> @undefine
06:22:13 <lambdabot> Undefined.
06:22:23 <dramforever> @let class C a where type X a :: *; func :: a -> X a
06:22:24 <lambdabot>  Defined.
06:22:25 <magnap> Gurkenglas: I pasted it earlier. http://lpaste.net/138958
06:22:51 <dramforever> @let instance C Int where type X Int = String; func = show
06:22:52 <lambdabot>  Defined.
06:22:54 <dramforever> > func 2
06:22:55 <lambdabot>      Couldn't match expected type ‘X a’ with actual type ‘X a0’
06:22:55 <lambdabot>      NB: ‘X’ is a type function, and may not be injective
06:22:55 <lambdabot>      The type variable ‘a0’ is ambiguous
06:22:56 <Sindriava> Can I compose typeclasses?
06:23:01 <dramforever> > func (2 :: Int)
06:23:02 <lambdabot>  "2"
06:23:23 <dramforever> magnap: do you get what I mean by these examples?
06:23:50 <dramforever> @let class (Monoid (Y a)) => C2 a where type X a :: *; func2 :: a -> Y a -- you could also do this
06:23:51 <lambdabot>  .L.hs:156:9:
06:23:51 <lambdabot>      Multiple declarations of ‘X’
06:23:51 <lambdabot>      Declared at: .L.hs:147:9
06:24:01 <dramforever> oh sorry, but you get what I mean
06:24:05 <Sindriava> @dice
06:24:05 <lambdabot> unexpected end of input: expecting number, "d" or "("
06:24:12 <Sindriava> @dice c20
06:24:12 <lambdabot> unexpected "c": expecting number, "d" or "("
06:24:13 <magnap> dramforever: I think I get it
06:24:14 <Sindriava> @dice d20
06:24:14 <lambdabot> Sindriava: 13
06:24:19 <Sindriava> neato
06:24:29 <dramforever> @dice 0
06:24:29 <lambdabot> unexpected end of input: expecting digit, operator or end of input: no rolls in expression
06:24:32 <dramforever> @dice d0
06:24:32 <lambdabot> unexpected end of input: expecting digit
06:24:45 <dramforever> I thought zero was a digit
06:24:49 <dramforever> @dice d077
06:24:49 <lambdabot> dramforever: 52
06:24:59 <lpaste_> Gurkenglas annotated “Boardgame solver” with “Boardgame solver (annotation)” at http://lpaste.net/138958#a138961
06:25:31 <Gurkenglas> *GeneralScore g in score's type signature, of course
06:26:53 <kronole> How is C not a functional language? Yes, I'm a noob, but it seems to me that everything in C works because of functions and such.
06:27:18 <magnap> Gurkenglas: Thanks a lot! That's very clear to me now
06:27:29 <magnap> @karma+ Gurkenglas
06:27:29 <lambdabot> Gurkenglas's karma raised to 3.
06:27:34 <magnap> @karma+ dramforever
06:27:35 <lambdabot> dramforever's karma raised to 6.
06:28:06 <dramforever> kronole: clearly you do not understand the meaning of "functional"
06:28:26 <marchelzo> Haskell is functional in the mathematical sense.
06:28:35 <dramforever> in functional programming languages programs are structured into functions that call other functions
06:28:59 <kronole> And I'm saying that's precisely what C looks like :)
06:29:27 <magnap> kronole: Functional implies referential transparency to some extent. As marchelzo said, we're talking mathematical functions here
06:29:43 <dramforever> kronole: no, functions just take values and return values
06:29:47 <ralu> in C functions are not all functions mathematical functions
06:29:50 <dramforever> no stuff like procedures or something
06:31:33 <magnap> kronolo: For example, it is guaranteed that a Haskell function of type Int -> Int can't read a file
06:31:56 <ralu> in C you program against Turing machine, where in Haskell you program against lambda calculus
06:33:04 <dramforever> kronole: what about this:
06:33:11 <dramforever> in haskell a program is an expression
06:33:26 <dramforever> whereas in C a program is a sequence of statements
06:33:34 <dramforever> with some control structures, of course
06:33:51 <u-ou> and there are no mutable variables (except when there are)
06:34:54 <magnap> u-ou: Shh, we don't talk about unsafe* ;-)
06:41:45 <kronole> What do you all think of Haskell's syntax? Just curious.
06:42:02 <hodapp> kronole: I find it generally easy to work in.
06:42:38 <magnap> kronole: I find it generally pleasant, especially the significance of whitespace and the easy partial application
06:42:38 <dramforever> hodapp ++
06:43:04 <dramforever> I find haskell's syntax cleaner
06:43:11 <dramforever> somehow
06:43:24 <hodapp> kronole: I find C-like syntax generally pleasant by way of familiarity but it is really not made for the semantics of a language like Haskell.
06:43:24 <dramforever> but I'm not exactly sure why...
06:43:48 * hackagebot c2hs 0.26.1 - C->Haskell FFI tool that gives some cross-language type safety  https://hackage.haskell.org/package/c2hs-0.26.1 (IanRoss)
06:44:12 <magnap> Is there any risk in using FlexibleContexts? I need it to ensure Ord (GeneralScore g)
06:45:05 <hodapp> kronole: Do you understand how a C function and a Haskell function (or really any pure function) differ?
06:45:21 <dramforever> C functions are really procedures
06:45:44 <kronole> hodapp: Not really; they seem the same to me, as a newbie
06:46:11 <dramforever> kronole: do you get that?
06:47:24 <ralu> kronole: are you familiar with OOP for example?
06:47:53 <dramforever> kronole: a haskell function takes a value, and returns a value
06:47:57 <dramforever> that's about it
06:48:05 <dramforever> *pretty much
06:48:51 <kronole> ralu: No, I've only really used C, Python and very, very, very basic Haskell
06:49:08 <ralu> ok
06:49:16 <reindeernix> what is it called when you have a function signature with two types that's not seperated by an arrow? I just don't understand what it's called nor what I should search for
06:49:29 <chattered> magnap: You flexible contexts all over Parsec to constrain the stream type. So I assume it can't be too bad.
06:49:36 <hodapp> reindeernix: do you have an example?
06:49:48 <zipper> Hey I want to parse a .hi file. Where do I start?
06:49:52 <reindeernix> hodapp, identifier :: Parser String
06:50:43 <magnap> chattered: Thanks, I'll go ahead with it then
06:50:49 <zipper> I'm trying the decode from Data.Binary but that doesn't seem to help.
06:50:50 <bennofs> zipper: ghc has a tool to show interface files, maybe you can find out how that works? (ghc --show-iface x.hi)
06:51:57 <nshepperd_> reindeernix: 'type constructor'
06:51:59 <hodapp> bennofs: interesting, that is new to me
06:52:38 <bennofs> hodapp: very useful if you're debugging ghc non-determinism bugs (ghc creates different interface files for identical source files) :)
06:52:42 <reindeernix> nshepperd_, didn't know you could use type constructors in signatures, thanks a lot
06:52:51 <geekosaur> zipper: I am under the impression that the best way to parse a .hi file is to make ghc-api do it for you
06:52:57 <hodapp> reindeernix: that is a pretty big thing to not know :P
06:53:06 <zipper> geekosaur: How do I do that?
06:53:07 <geekosaur> packages that parsed it themselves tended to be extremely fragile (early versions of "plugins", for example)
06:53:19 <zipper> I am reading the GHC docs https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/API
06:53:20 <geekosaur> so you might look at that package to see how it's done
06:53:21 <hodapp> reindeernix: type constructors just make types
06:53:24 <zipper> Nothing
06:53:52 <zipper> geekosaur: Which package?
06:53:58 <geekosaur> @hackage plugins
06:53:58 <lambdabot> http://hackage.haskell.org/package/plugins
06:54:06 <reindeernix> hodapp, it sure is a good thing to know ;)
06:55:30 <bennofs> zipper: https://downloads.haskell.org/~ghc/7.10.2/docs/html/libraries/ghc-7.10.2/BinIface.html looks good
06:55:31 <geekosaur> might need to pick a version from the middle of the list; early versions tried to parse .hi files themselves and had to be rewritten for every new ghc release, very recent versions likely just wrap the functionality added to ghc 7.x (I think 7.4)
06:55:50 <zipper> bennofs: Let me look at it
06:56:58 <nshepperd_> reindeernix: just to head off some possible confusion, type constructors are different to data constructors
06:58:18 <Sindriava> Hm… I still think that runReaderT and runStateT were misdesigned
06:58:27 <bennofs> Sindriava: why?
06:58:38 <Sindriava> :t runReaderT
06:58:39 <lambdabot> ReaderT r m a -> r -> m a
06:58:44 <Sindriava> :t flip runReaderT
06:58:45 <lambdabot> r -> ReaderT r m a -> m a
06:58:46 <dramforever> Sindriava: except that those are just record fields
06:58:47 <kronole> Why did Dijkstra think Haskell was the best first language?
06:58:54 <reindeernix> nshepperd_, I probably should read up more on type constructors then, I have only read about data constructors so far
06:58:59 <Sindriava> dramforever: What does that change?
06:59:19 <dramforever> Sindriava: I guess it's customary to have a runFoo function that simply unwraps the newtype wrapper
06:59:26 <dramforever> it's consistent
06:59:28 <Sindriava> dramforever: Hm… I guess
06:59:34 <Sindriava> but you can't compose them nicely
06:59:47 <bennofs> Sindriava: just use flip :)
06:59:49 <Sindriava> runReaderT (runStateT (stack) (state)) (reader)
06:59:53 <Sindriava> bennofs: That's what I'm doing
06:59:53 <dramforever> runReaderT (some long expression) reader
07:00:03 <Sindriava> bennofs: Doesn't make it a sane default
07:00:06 <dramforever> idea
07:00:13 <Sindriava> but unrwapping is a fair point
07:00:28 <bennofs> runReaderT :: ReaderT r m a -> (r -> m a)
07:00:29 <dramforever> (`runReaderT` foo) $ (`runStateT` bar) thatmonad
07:00:38 <dramforever> doesn't change much
07:00:44 <Sindriava> dramforever: flip is more readable IMOP
07:00:46 <Sindriava> *IMO
07:01:30 <Sindriava> but it *does* make sense that you'd expect runA some_a to return the insides of A
07:02:04 <dramforever> =)
07:02:25 <iambernie> kronole, he mentions several reasons here: http://www.cs.utexas.edu/users/EWD/OtherDocs/To%20the%20Budget%20Council%20concerning%20Haskell.pdf
07:02:50 <Sindriava> what I guess would be a compromise is current `runReaderT` being `unReaderT` and `runReaderT = flip unReaderT` ?
07:03:48 <nshepperd_> reindeernix: they serve similar purposes, just at the type level vs value level
07:03:48 * hackagebot amazonka-core 1.0.0 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.0.0 (BrendanHay)
07:05:02 <nshepperd_> reindeernix: Applying Just to the value 5 gives (Just 5), which is a value. While applying Maybe to the type Int gives (Maybe Int), which is a type
07:05:47 <reindeernix> nshepperd_, I remember seeing them multiple times but I didn't think much about them, but those are some confusing keywords at first
07:07:29 <nshepperd_> anyway keep reading I guess and it'll all become clear eventually
07:07:46 <reindeernix> will do
07:08:49 * hackagebot broker-haskell 0.1.0.0 - Haskell bindings to Broker, Bro's messaging library.  https://hackage.haskell.org/package/broker-haskell-0.1.0.0 (DavidBanas)
07:08:51 * hackagebot amazonka 1.0.0 - Comprehensive Amazon Web Services SDK  https://hackage.haskell.org/package/amazonka-1.0.0 (BrendanHay)
07:08:53 * hackagebot amazonka-config 1.0.0 - Amazon Config SDK.  https://hackage.haskell.org/package/amazonka-config-1.0.0 (BrendanHay)
07:08:55 * hackagebot amazonka-sns 1.0.0 - Amazon Simple Notification Service SDK.  https://hackage.haskell.org/package/amazonka-sns-1.0.0 (BrendanHay)
07:08:57 * hackagebot amazonka-sqs 1.0.0 - Amazon Simple Queue Service SDK.  https://hackage.haskell.org/package/amazonka-sqs-1.0.0 (BrendanHay)
07:11:32 <hodapp> Dijkstra had an opinion on Haskell besides "YOU'RE DOING IT WRONG"?
07:13:49 * hackagebot amazonka-glacier 1.0.0 - Amazon Glacier SDK.  https://hackage.haskell.org/package/amazonka-glacier-1.0.0 (BrendanHay)
07:13:51 * hackagebot tellbot 0.6 - IRC tellbot  https://hackage.haskell.org/package/tellbot-0.6 (DimitriSabadie)
07:13:53 * hackagebot amazonka-cloudhsm 1.0.0 - Amazon CloudHSM SDK.  https://hackage.haskell.org/package/amazonka-cloudhsm-1.0.0 (BrendanHay)
07:13:53 <bennofs> Sindriava: yeah, if you're redesigning mtl from scratch it would be an option, but now lots of code is already depending on current runReaderT signature
07:13:55 * hackagebot amazonka-datapipeline 1.0.0 - Amazon Data Pipeline SDK.  https://hackage.haskell.org/package/amazonka-datapipeline-1.0.0 (BrendanHay)
07:13:57 * hackagebot amazonka-iam 1.0.0 - Amazon Identity and Access Management SDK.  https://hackage.haskell.org/package/amazonka-iam-1.0.0 (BrendanHay)
07:14:47 <hodapp> what did Dijkstra mean by "operational reasoning" in that PDF?
07:14:59 <hodapp> is that as in 'operational semantics' vs. 'denotational semantics'?
07:16:43 <Sindriava> bennofs: Oh, no doubt!
07:17:08 <Sindriava> bennofs: It's not that much of a hassle, anyways :)
07:18:59 * hackagebot amazonka-route53-domains 1.0.0 - Amazon Route 53 Domains SDK.  https://hackage.haskell.org/package/amazonka-route53-domains-1.0.0 (BrendanHay)
07:19:01 * hackagebot amazonka-directconnect 1.0.0 - Amazon Direct Connect SDK.  https://hackage.haskell.org/package/amazonka-directconnect-1.0.0 (BrendanHay)
07:19:03 * hackagebot amazonka-devicefarm 1.0.0 - Amazon Device Farm SDK.  https://hackage.haskell.org/package/amazonka-devicefarm-1.0.0 (BrendanHay)
07:19:05 * hackagebot amazonka-cognito-sync 1.0.0 - Amazon Cognito Sync SDK.  https://hackage.haskell.org/package/amazonka-cognito-sync-1.0.0 (BrendanHay)
07:19:07 * hackagebot amazonka-elb 1.0.0 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elb-1.0.0 (BrendanHay)
07:21:32 <nawal> do people here use jhc? I'm trying to get it to compile the byte string library
07:21:37 <nawal> tmp/build/bytestring-0.9.2.0/Data/ByteString/Lazy.hs:535 - Error: parse error at "|"
07:24:09 * hackagebot amazonka-cloudformation 1.0.0 - Amazon CloudFormation SDK.  https://hackage.haskell.org/package/amazonka-cloudformation-1.0.0 (BrendanHay)
07:24:11 * hackagebot amazonka-sts 1.0.0 - Amazon Security Token Service SDK.  https://hackage.haskell.org/package/amazonka-sts-1.0.0 (BrendanHay)
07:24:13 * hackagebot tellbot 0.6.0.1 - IRC tellbot  https://hackage.haskell.org/package/tellbot-0.6.0.1 (DimitriSabadie)
07:24:15 * hackagebot amazonka-kinesis 1.0.0 - Amazon Kinesis SDK.  https://hackage.haskell.org/package/amazonka-kinesis-1.0.0 (BrendanHay)
07:24:17 * hackagebot amazonka-cloudsearch-domains 1.0.0 - Amazon CloudSearch Domain SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-domains-1.0.0 (BrendanHay)
07:29:19 * hackagebot amazonka-cloudwatch 1.0.0 - Amazon CloudWatch SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-1.0.0 (BrendanHay)
07:29:21 * hackagebot amazonka-cloudtrail 1.0.0 - Amazon CloudTrail SDK.  https://hackage.haskell.org/package/amazonka-cloudtrail-1.0.0 (BrendanHay)
07:29:23 * hackagebot amazonka-elasticache 1.0.0 - Amazon ElastiCache SDK.  https://hackage.haskell.org/package/amazonka-elasticache-1.0.0 (BrendanHay)
07:29:25 * hackagebot amazonka-importexport 1.0.0 - Amazon Import/Export SDK.  https://hackage.haskell.org/package/amazonka-importexport-1.0.0 (BrendanHay)
07:29:27 * hackagebot amazonka-s3 1.0.0 - Amazon Simple Storage Service SDK.  https://hackage.haskell.org/package/amazonka-s3-1.0.0 (BrendanHay)
07:34:29 * hackagebot amazonka-swf 1.0.0 - Amazon Simple Workflow Service SDK.  https://hackage.haskell.org/package/amazonka-swf-1.0.0 (BrendanHay)
07:34:31 * hackagebot amazonka-sdb 1.0.0 - Amazon SimpleDB SDK.  https://hackage.haskell.org/package/amazonka-sdb-1.0.0 (BrendanHay)
07:34:33 * hackagebot amazonka-codecommit 1.0.0 - Amazon CodeCommit SDK.  https://hackage.haskell.org/package/amazonka-codecommit-1.0.0 (BrendanHay)
07:34:35 * hackagebot amazonka-codedeploy 1.0.0 - Amazon CodeDeploy SDK.  https://hackage.haskell.org/package/amazonka-codedeploy-1.0.0 (BrendanHay)
07:34:38 * hackagebot amazonka-cloudfront 1.0.0 - Amazon CloudFront SDK.  https://hackage.haskell.org/package/amazonka-cloudfront-1.0.0 (BrendanHay)
07:37:06 <nawal> Why:     context reduction, no instance for: Jhc.Class.Ord.Eq (Jhc.ForeignPtr.ForeignPtr Jhc.Type.Word.Word8)
07:39:06 <geekosaur> nawal: not many jhc users here. as far as I know, there's only the mailing list
07:39:28 <nawal> okay thanks :-)
07:39:30 <dramforever> I wonder if ForeignPtrs are comparable
07:39:39 * hackagebot amazonka-efs 1.0.0 - Amazon Elastic File System SDK.  https://hackage.haskell.org/package/amazonka-efs-1.0.0 (BrendanHay)
07:39:41 * hackagebot amazonka-codepipeline 1.0.0 - Amazon CodePipeline SDK.  https://hackage.haskell.org/package/amazonka-codepipeline-1.0.0 (BrendanHay)
07:39:43 * hackagebot amazonka-elasticbeanstalk 1.0.0 - Amazon Elastic Beanstalk SDK.  https://hackage.haskell.org/package/amazonka-elasticbeanstalk-1.0.0 (BrendanHay)
07:39:45 * hackagebot amazonka-autoscaling 1.0.0 - Amazon Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-autoscaling-1.0.0 (BrendanHay)
07:39:46 <dramforever> it seems that a foreign ptr can contain a finalizer
07:39:47 * hackagebot amazonka-ses 1.0.0 - Amazon Simple Email Service SDK.  https://hackage.haskell.org/package/amazonka-ses-1.0.0 (BrendanHay)
07:39:56 <Rizy> hi i want to ask which is better for developing to android using haskell, ajhc or jni?
07:44:50 * hackagebot amazonka-support 1.0.0 - Amazon Support SDK.  https://hackage.haskell.org/package/amazonka-support-1.0.0 (BrendanHay)
07:44:52 * hackagebot amazonka-dynamodb-streams 1.0.0 - Amazon DynamoDB Streams SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-streams-1.0.0 (BrendanHay)
07:44:54 * hackagebot amazonka-redshift 1.0.0 - Amazon Redshift SDK.  https://hackage.haskell.org/package/amazonka-redshift-1.0.0 (BrendanHay)
07:44:56 * hackagebot amazonka-opsworks 1.0.0 - Amazon OpsWorks SDK.  https://hackage.haskell.org/package/amazonka-opsworks-1.0.0 (BrendanHay)
07:44:58 * hackagebot amazonka-emr 1.0.0 - Amazon Elastic MapReduce SDK.  https://hackage.haskell.org/package/amazonka-emr-1.0.0 (BrendanHay)
07:50:00 * hackagebot amazonka-cognito-identity 1.0.0 - Amazon Cognito Identity SDK.  https://hackage.haskell.org/package/amazonka-cognito-identity-1.0.0 (BrendanHay)
07:50:02 * hackagebot amazonka-ssm 1.0.0 - Amazon Simple Systems Management Service SDK.  https://hackage.haskell.org/package/amazonka-ssm-1.0.0 (BrendanHay)
07:50:04 * hackagebot amazonka-ml 1.0.0 - Amazon Machine Learning SDK.  https://hackage.haskell.org/package/amazonka-ml-1.0.0 (BrendanHay)
07:50:06 * hackagebot amazonka-workspaces 1.0.0 - Amazon WorkSpaces SDK.  https://hackage.haskell.org/package/amazonka-workspaces-1.0.0 (BrendanHay)
07:50:08 * hackagebot amazonka-dynamodb 1.0.0 - Amazon DynamoDB SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-1.0.0 (BrendanHay)
07:50:31 <mbrock> that's a lot of 1.0.0 releases of seemingly comprehensive AWS API clients... sweet!
07:50:56 <bren> hehe
07:50:58 * mbrock goes off to code hella cloud clusters
07:51:02 <bren> 53 in fact
07:51:12 <htebalaka> is there no way to promote a type with DataKinds so that it's Natural type (or some equivalent) gets promoted to GHC.TypeLits.Nat?
07:51:46 <hodapp> nawal: why JHC, out of curiosity?
07:55:10 * hackagebot amazonka-rds 1.0.0 - Amazon Relational Database Service SDK.  https://hackage.haskell.org/package/amazonka-rds-1.0.0 (BrendanHay)
07:55:12 * hackagebot amazonka-ds 1.0.0 - Amazon Directory Service SDK.  https://hackage.haskell.org/package/amazonka-ds-1.0.0 (BrendanHay)
07:55:14 * hackagebot amazonka-cloudwatch-logs 1.0.0 - Amazon CloudWatch Logs SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-logs-1.0.0 (BrendanHay)
07:55:16 * hackagebot amazonka-route53 1.0.0 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-1.0.0 (BrendanHay)
07:55:18 * hackagebot amazonka-cloudsearch 1.0.0 - Amazon CloudSearch SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-1.0.0 (BrendanHay)
07:59:16 <Sindriava> wow, hackagebot went bonkers
07:59:30 <Sindriava> Or, BrendanHey more likely
08:00:12 <jmcarthur> i'm surprised not to have heard much about vector since the version with bundles was released to hackage in july
08:00:20 * hackagebot amazonka-storagegateway 1.0.0 - Amazon Storage Gateway SDK.  https://hackage.haskell.org/package/amazonka-storagegateway-1.0.0 (BrendanHay)
08:00:22 * hackagebot amazonka-ec2 1.0.0 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-1.0.0 (BrendanHay)
08:00:24 * hackagebot amazonka-kms 1.0.0 - Amazon Key Management Service SDK.  https://hackage.haskell.org/package/amazonka-kms-1.0.0 (BrendanHay)
08:00:26 * hackagebot amazonka-elastictranscoder 1.0.0 - Amazon Elastic Transcoder SDK.  https://hackage.haskell.org/package/amazonka-elastictranscoder-1.0.0 (BrendanHay)
08:00:28 * hackagebot amazonka-lambda 1.0.0 - Amazon Lambda SDK.  https://hackage.haskell.org/package/amazonka-lambda-1.0.0 (BrendanHay)
08:00:44 <jmcarthur> what are these, automatically generated packages?
08:01:00 <bennofs> i hope they are automatically generated
08:01:33 <bren> Mostly .. :)
08:02:12 <jmcarthur> bren: you strategically joined the channel just before uploading these so you could watch the mayhem, didn't you? ;)
08:02:22 <fede08> Hi guys, I just wanted to do something like a counter in Haskell (for cutting a computation inside a foldl' ), what's the best way to do it? :P
08:02:23 <Sindriava> bren right now: http://i.imgur.com/0WH7DUv.gif
08:02:41 <Sindriava> fede08: Writer, maybe?
08:03:02 <bren> I usually idle here in the afternoon CEST. But yes, I do keep one eye here since most people complain about hackagebot at some point.
08:03:11 <jmcarthur> fede08: i would use a scan instead of a fold, compose it with take or takeWhile, and apply last to the result
08:04:10 <fede08> thanks ! :) I'll see what I can do with it
08:04:19 <jmcarthur> fede08: actually, i guess find or something could replace takeWhile composed with last
08:04:34 <jmcarthur> but anyway, that's the basic structure i would shoot for
08:04:49 <Sindriava> @define boob = (.)
08:04:51 <lambdabot>  Defined.
08:04:58 <jmcarthur> @undef
08:04:58 <lambdabot> Undefined.
08:05:00 <Sindriava> *giggle*
08:05:02 <jmcarthur> let's not do that
08:05:07 <Sindriava> Hey :(
08:05:30 * hackagebot amazonka-ecs 1.0.0 - Amazon EC2 Container Service SDK.  https://hackage.haskell.org/package/amazonka-ecs-1.0.0 (BrendanHay)
08:05:54 <fede08> basically, I'm applying a function inside the `step` function of foldl that grows a list (in a random way, it can blow the memory) so I have a max memory constant that should cut it
08:07:55 <jmcarthur> Sindriava: i know it's all in good fun and not intended to be harmful at all, but it's the sum of all the little things that can make a community seem toxic
08:09:12 <Sindriava> jmcarthur: Hey, I'm all about keeping the community nice (I love #haskell, I really do), but how is this toxic?
08:09:16 <Sindriava> Sorry, that sounded wrong
08:09:20 <Sindriava> It was a serious question
08:10:03 <Sindriava> What I meant was: "In what way is that toxic, so I can be aware of it in the future?"
08:16:23 <jmcarthur> Sindriava: My policy is to just avoid jokes about subgroups of people, because that tends to be divisive. In this case it's about women. To be clear, I think this particular joke is a very, very minor offense, albeit a common one.
08:16:43 <Sindriava> Argh
08:17:10 <jmcarthur> I don't even see it as though you did anything wrong.
08:17:31 <Sindriava> Ok, here's the deal. I have a very strong opinion on that and the whole topic makes me *really* angry, but I see what you're getting at
08:17:53 <Sindriava> I'll try to keep it down. Bottom line – it's a Haskell channel :)
08:18:20 <jmcarthur> I actually doubt that your opinions and mine are that far apart, but if we are to discuss it further we should do it elsewhere.
08:18:53 <Sindriava> Yeah, let's leave it at that, rather :)
08:19:03 <nkaretnikov> jmcarthur: glad you spoke up, thanks for that!
08:19:17 <Sindriava> @karma+ jmcarthur 
08:19:18 <lambdabot> jmcarthur's karma raised to 12.
08:19:40 <Sindriava> Anywoop, anyone care to take a look at my code? It's a mess and I'm hoping for some idioms to improve it
08:27:12 <broma0> Parsec is like cheating
08:27:57 <kadoban> Sindriava: People are unlikely to commit to helping before you post the code. Just lpaste it.
08:28:10 <Sindriava> kadoban: Fair enough, I'll link it
08:30:04 <Sindriava> Here: https://github.com/sindriava/glfw
08:30:28 <Sindriava> It's an OpenGL app, so there's a lot of messy code relating to that, I'd like to get it better under control
08:30:35 <Sindriava> (specially the state modifications)
08:45:51 <WeaponX> hi all, it's not clear to me how I can pattern-match on the UP,DOWN,LEFT,RIGHT arrow keys with getContents :: IO String?
08:49:24 <mbrock> Sindriava: the main loop has some repetitive stuff for modifying the camera state, I would at least try to factor out some functions there
08:50:08 <Sindriava> mbrock: Yeah, I've been playing with the idea of putting them in a list of [(Key, state -> state)] at lest
08:50:52 <Sindriava> then mapping ` \k a -> when (member k keys) $ modify a ` over it
08:51:08 <geekosaur> WeaponX, in a terminal they are escape sequences
08:52:53 <exio4> Sindriava: have you looked at lens? 
08:52:58 <geekosaur> '\27':'[':'A' :_ matches a string starting with up-arrow --- although it might be '\27':'O':'A':_ for some terminals. it's better to use a terminal handling package instead of doing it yourself
08:53:18 <geekosaur> @hackage ncurses
08:53:19 <lambdabot> http://hackage.haskell.org/package/ncurses
08:53:23 <geekosaur> @hackage brick
08:53:23 <lambdabot> http://hackage.haskell.org/package/brick
08:53:35 <Sindriava> exio4: Yeah, but I didn't want to use them, as to get the skeleton of the app right first
08:53:44 <WeaponX> geekosaur, thanks, I'll look into those
08:53:46 <Sindriava> exio4: But point taken, I'll read up on them
08:54:41 <Sindriava> WeaponX: Yeah, most of the time when you want to check for key arrows in the terminal, you *really* want to use ncurses or the like
08:54:56 <Sindriava> WeaponX: The glaring exception being already handled by readline
08:57:26 <mbrock> Sindriava: or perhaps even a Map Key (Endo State), so you can lookup all the keys and then mconcat with the Monoid instance for Maybe (Endo a) and modify the state with the resulting composition ;D
08:57:47 <Sindriava> Oooh, that sounds interesting
08:57:54 <Sindriava> What does Endo do?
08:58:13 <mbrock> it just means a function like a -> a
08:58:18 <Sindriava> Ah, I see
08:59:10 <mbrock> "endo" means "self-related" or something, so endomorphism is a function like that, and they're nice because you can compose them, so the monoid instance is basically mappend = (.)
08:59:13 <Sindriava> And Endo1 <> Endo2 is essentially like "foo1 . foo2"
08:59:19 <mbrock> yeah
08:59:29 <geekosaur> endo- inside, exo- outside
08:59:35 <Sindriava> neat! That sounds like a really good solution, thanks :)
08:59:35 <ReinH> geekosaur: o/
08:59:47 <mbrock> oh hah, good to know :)
09:03:01 <juanca_> Hi everyone, have you seen the change from various functions from EitherT to ExcepT in the errors package
09:03:20 <ReinH> juanca_: yep
09:03:34 <juanca_> i'm kind of newbie so i still don't understand how should i proceed to move som function using the previous to the new type signature
09:03:47 <ReinH> juanca_: Is it not a simple search/replace?
09:03:49 <Sindriava> juanca_: ExceptT seems to be the standard now
09:04:17 <ReinH> EitherT exists because ErrorT had a spurious constraint on its first type parameter.
09:04:27 <ReinH> ExceptT removed that constraint, so now EitherT is redundant
09:04:34 <Sindriava> ReinH: I think what juanca_ means it that some libs still use EitherT, while some use ExceptT, and wants to know how to connect them together?
09:04:47 <juanca_> Sindriava: indeed
09:05:43 <ReinH> Well, I guess that's going to be a pain.
09:05:49 <ReinH> :(
09:06:56 <Sindriava> Yah
09:07:27 <Sindriava> juanca_: Is there by chance an older version of the library using ExceptT, or a newer version of the one using EitherT?
09:07:47 <juanca_> The new verison uses ExceptT
09:07:52 <juanca_> *version
09:08:44 <Sindriava> juanca_: Yes. My question was if there's a way to alleviate the incompatibility by downgrading / upgrading the incompatible library?
09:09:48 <juanca_> the thing is that i was working on something that made heavy use of EitherT to catch exceptions and stuff, now i'm not sure how to properly use the ExceptT monad
09:09:59 <Sindriava> Ah, I see
09:10:05 <dope> I'm try to add the last to elements of a list together... Whats wrong with this: xs ++ (foldr (+) 0 (drop (length xs - 2) xs)) ?
09:10:12 <juanca_> and since many packages that now are using errors 2.0.0 i have broken stuff all over the place
09:10:16 <Sindriava> So you want to change *your* code from EitherT to ExceptT?
09:10:43 <Sindriava> That I can't help with, I'm afraid :( Maybe the Haskell wiki will have a guide on upgrading?
09:11:17 <kadoban> dope: (++) concatenates two lists.  foldr (+) 0 blah   doesn't seem like it's going to result in a list.
09:12:03 <dope> Oh ok thanks
09:12:43 <juanca_> Sindriava: i see, i was reading about ExceptT but still have some doubts. Thanks anyway and ReinH for some clarifications
09:12:44 <juanca_> :)
09:13:11 <Sindriava> No prob, the least I could do.
09:15:30 <dope> Do you always need to provide type signatures for functions?
09:16:00 <srhb> dope: Only if they cannot be inferred, though it's a good idea to have at least top level values annotated
09:16:37 <srhb> dope: It eases readability and makes errors better (because your functions don't suddenly change types to try and accomodate some error you made.)
09:17:15 <dope> Ok thanks, so it prevents any dynamic type changing stuff?
09:17:22 <geekosaur> it's not dynamic
09:17:55 <dope> Ah yes
09:18:16 <geekosaur> type inference happens at compile time. unfortunately, if the inferred type includes a typeclass, this tends to give the compiler a license to try to use strange type combinations if you made a mistake with types elsewhere
09:18:54 <geekosaur> and then you get an error in a third place when it finally realizes that it can't make things fit
09:19:52 <dope> Good to know, that'll help
09:23:57 * hackagebot nvim-hs 0.0.3 - Haskell plugin backend for neovim  https://hackage.haskell.org/package/nvim-hs-0.0.3 (saep)
09:39:49 <ReinH> dope: You often don't *need* to provide type signatures, but it's a good idea to provide them for top-level functions. It makes debugging type errors easier, and aids in type-driven design.
09:40:39 <hpc> the superior TDD ;)
09:52:45 <GLM> What is the best way to use something like foldr if you have a function of type a -> [b] -> a
09:55:29 <c_wraith> :t foldr
09:55:30 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
09:55:54 <c_wraith> flip your function
09:56:08 <ReinH> (assuming it's commutative)
09:56:24 <ReinH> or rather, that you don't really want foldl'
09:56:34 <c_wraith> Yeah, that function is absolutely not commutative.
09:56:43 <c_wraith> But there is a chance you really want foldl' instead
09:57:21 <c_wraith> A commutative function needs to unify with the type a -> a -> b
09:57:30 <c_wraith> If it doesn't, the arguments *can't* commute. :)
09:57:51 <statusfailed> I'm trying to follow this "developing Haskell with NixOS" workflow, but it says "base" is missing: http://wiki.ocharles.org.uk/Nix 
09:57:57 <statusfailed> anybody know why that would be?
09:58:43 <statusfailed> sorry, it says "base" is missing when I run the "nix-shell" command to do cabal configure
10:00:04 <bennofs> statusfailed: so you're on unstable nixpkgs/nixos channel?
10:00:31 <statusfailed> bennofs: yep!
10:00:32 <statusfailed> is that bad?
10:00:49 <bennofs> statusfailed: no, that's required :) 
10:00:59 <statusfailed> oh good heh
10:01:13 <GLM> Awesome. Thanks
10:02:25 <bennofs> statusfailed: can you paste the shell.nix file?
10:02:42 <statusfailed> bennofs: sure, lpaste OK?
10:02:46 <bennofs> ok
10:03:35 <lpaste_> statusfailed pasted “shell.nix” at http://lpaste.net/138967
10:03:39 <statusfailed> bennofs: done ^
10:05:03 <statusfailed> I autogenerated that file usinng the command from ocharles' wiki
10:05:27 <bennofs> statusfailed: do you have any overrides in your ~/.nixpkgs/config.nix?
10:05:43 <statusfailed> bennofs: yes!
10:05:50 <statusfailed> st.conf = builtins.readFile ./config.def.h;
10:06:00 <statusfailed> (this is for the st terminal, which I had to theme)
10:06:15 <bennofs> statusfailed: oh, if that's all, that shouldn't affect haskell :)
10:06:15 <statusfailed> but that's it.
10:06:22 <statusfailed> whew :-)
10:06:51 <bennofs> statusfailed: and you're calling nix-shell, without any arguments, right? Do you have a default.nix file in the directory?
10:07:04 <maerwald> shouldn't that go to a nix support channel?
10:07:10 <bennofs> yeah, we could switch to #nixos
10:07:24 <statusfailed> okie
10:16:50 <phaazon> hm
10:17:01 <phaazon> I’m designing an API, I’m not sure about errors handling
10:17:05 <phaazon> I have three choices
10:17:17 <phaazon> I can make all my functions return Either e a, for instance
10:17:29 <phaazon> I can make all my functions run in ExceptT e m a
10:17:46 <phaazon> I can make all my functions run in (MonadError e m) => m a
10:18:00 <phaazon> I like the third option
10:18:06 <phaazon> because it can be used to unify error handling later on
10:25:49 <bren> phaazon: you could also use a MonadThrow constraint, depending on how you plan on composing and/or offering up your API. Perhaps this is of interest: https://www.fpcomplete.com/user/commercial/content/exceptions-best-practices
10:28:58 <phaazon> bren: it’s not exceptions stuff, it’s error handling
10:29:01 <phaazon> exceptions ≠ errors
10:38:00 <GLM> How do I map over two lists at the same time that I need to pass into a function?
10:38:17 <scshunt> zipWith
10:44:23 <zipper> Heh is there really no package on hackage named ghc? Because that's the error cabal gives me.
10:44:39 <scshunt> there is not
10:44:39 <Cale> The ghc package comes with ghc
10:45:49 <viszu> @hoogle [a] -> [a]
10:45:50 <lambdabot> Prelude cycle :: [a] -> [a]
10:45:50 <lambdabot> Data.List cycle :: [a] -> [a]
10:45:50 <lambdabot> Prelude init :: [a] -> [a]
10:46:19 <viszu> > take 5 [1..]
10:46:20 <lambdabot>  [1,2,3,4,5]
10:48:23 <viszu> >  ((.)$(.)) (==) 1 (1+) 0
10:48:25 <lambdabot>  True
10:49:35 <c_wraith> the ghc compiler comes with the ghc package, and no other compiler is ghc, so it doesn't have the ghc innards the ghc package exposes.
10:49:46 <c_wraith> In other words, there's only downsides to putting it on hackage. :)
10:51:41 <zipper> Oh so that's why I keep getting this error: "Could not find module ‘BinIface’ It is a member of the hidden package ‘ghc-7.8.4’."
10:51:58 <zipper> Even after adding ghc to my depends in the cabal file.
10:52:09 <zipper> Then how can I use the darn package?
10:52:39 <zipper> This is crazy. What's the reason for this? Avoiding conflicting versions of the ghc package?
10:54:29 <c_wraith> It's impossible for any version of the ghc package to work properly with any other version of ghc, let alone a different compiler
10:54:32 <breadmonster> Hello.
10:54:51 <zipper> c_wraith: Even the ghc library?
10:55:02 <c_wraith> zipper: the ghc package *is* the ghc library
10:55:17 <monochrom> adding "ghc" to your depends suffices. (it works for many people.) so I conclude that your problem cause is elsewhere.
10:55:24 <c_wraith> zipper: what precisely is the problem, though.  the error message says you have it installed
10:55:29 <zipper> monochrom: Hopefully.
10:55:33 <breadmonster> c_wraith: So no ordinary Haskell 2010 implementation will compile GHC?
10:55:44 <scshunt> it can compile GHC
10:55:49 <c_wraith> breadmonster: the ghc package is exposing ghc's internals
10:55:59 <c_wraith> breadmonster: the library can't work without ghc's internals to expose.
10:56:24 <breadmonster> Ah, I thought it was a standalone version of ghc that it linked your program against.
10:56:44 <zipper> c_wraith: I don't even know. I just pasted the error. I'll investigate further.
10:57:18 <c_wraith> zipper: The error message you quoted says the package is installed.  So..  Are you trying to load code using it from ghci without using cabal repl, or something?
10:57:25 <breadmonster> c_wraith: like how some LISPs come with a RTS that includes the language.
10:57:36 <breadmonster> *includes an interpreter for the language.
10:59:04 <zipper> c_wraith: Using runhaskell
10:59:24 <c_wraith> zipper: you know that ignores .cabal files, right?  use cabal build and then run the resulting executable
10:59:27 <breadmonster> zipper: You mean runghc?
10:59:46 <zipper> breadmonster: I ran runhaskell.
10:59:49 <c_wraith> breadmonster: ghc installs scripts named each.  They're the same thing
11:00:07 <c_wraith> I think one's a symlink to the other usually
11:02:32 <monochrom> I hate "runhaskell". it's so unspecific.
11:02:56 <breadmonster> Has anyone seen bonus?
11:03:01 <monochrom> for all you know, hugs symlinks "runhaskell" to "runhugs", too.
11:03:04 <breadmonster> I wanted to thank him for LYAH.
11:03:06 <c_wraith> breadmonster: not in years
11:03:19 <breadmonster> c_wraith: Is he okay...?
11:04:22 <c_wraith> I think he just doesn't use IRC here.
11:05:22 <zipper> Something like cabal repl for stack?
11:05:36 <bitemyapp> zipper: stack ghci
11:08:22 <ansible1> I'm getting "fatal error: ffi.h: No such file or directory", and yet I have libffi installed.  
11:08:38 <ansible1> trying to compile persisent-sqlite on arm... 
11:08:56 <c_wraith> ansible1: debian-like system?
11:09:00 <ansible1> arch
11:09:06 <c_wraith> Hmm.  No idea then.
11:09:17 <ansible1> I've gotten it to compile in the past but now I don't remember what happened at this point
11:09:27 <c_wraith> debian-like system stuff .h files off into -dev packages for no reason.  But arch doesn't have that issue.
11:09:57 <ansible1> ah yes.  I'll if I can find the file, just to make sure
11:10:39 <johnw> maerwald: I'm willing to help remedy that situation, I just haven't had a pressing need to
11:10:44 <monochrom> I know the reason. but it's subjective.
11:10:52 <ansible1> hmm, file is on my system at least.
11:10:59 <c_wraith> ok, I know the reason, but I strongly disagree with it.
11:11:13 <monochrom> at any rate, it's yet better than Windows: off into MSDN
11:12:01 <c_wraith> ansible1: in that case, I can only conclude ghc isn't looking in the right place for some reason.  But I can't suggest possible reasons.
11:12:50 <ansible1> yeah, I don't know either.  could possibly be some confusion on my part trying to use this lib in my sandbox.  
11:12:55 <maerwald> johnw: what exactly do you mean
11:13:19 <ansible1> persistent-sqlite comes with its own C code, but you can change a flag so it uses the system sqlite lib
11:13:34 <zipper> hmmm stack doesn't seem to autodownload the packages under the test directory and only complains when one tries stack ghci. Weird.
11:14:00 <ansible1> I set the flag, but maybe still trying to compile the hackage version somehow...
11:15:28 <zipper> Anywho, Given https://downloads.haskell.org/~ghc/7.10.2/docs/html/libraries/ghc-7.10.2/BinIface.html#v:readBinIface which gives a value of type `ModIface` from a value of type `TcRnIf a b ModIface` ?
11:15:58 <zipper> I guess it's a monad transformers thing and I haven't read on those yet. I'm surprised I've gotten this far.
11:19:04 <ansible1> when you add-source to a sandbox, then install a lib, is there a way to know whether that lib is coming from the source you added, or from hackage?
11:21:00 <tempname11> zipper: I'm totally unfamiliar with that code, but I don't see any monad transformers there
11:21:25 <tempname11> what are you trying to accomplish?
11:21:58 <zipper> tempname11: Extract a value of type `ModIface` from `TcRnIf a b ModIface`
11:22:18 <zipper> pattern match?
11:24:21 <tempname11> zipper: TcRnif is defined as a type alias for IOEnv. I think you can extract the value you need using runIOEnv (inside IO)
11:25:17 <zipper> :t runIOEnv
11:25:18 <lambdabot> Not in scope: ‘runIOEnv’
11:25:34 <tempname11> I think it's some kind of an IO wrapper that captures an "enviroment", whatever that means in GHC
11:25:47 <tempname11> https://downloads.haskell.org/~ghc/7.10.2/docs/html/libraries/ghc-7.10.2/IOEnv.html#t:IOEnv
11:26:59 <tempname11> zipper: can you provide the context for your problem? because I'm totally guessing a.t.m
11:27:13 <tempname11> and I never ever read GHC's code :)
11:27:15 <zipper> tempname11: Okay should I paste the code?
11:27:19 <tempname11> sure
11:28:13 <zipper> tempname11: https://gist.github.com/urbanslug/e49899cadace3e6c7d7a
11:29:18 <zipper> the return on L22 is a mistake
11:32:28 <tempname11> zipper: well, it seems (and again, I'm totally in the dark about this stuff!) that runIOEnv would get you that value indeed. but you need to supply an "environment" to it
11:33:40 <zipper> tempname11: I'm in the dark too :)
11:43:13 <tempname11> zipper: I suggest you ask this in #ghc
11:43:30 <tempname11> oh, you just did
11:44:05 * hackagebot lens-tutorial 1.0.0 - Tutorial for the lens library  https://hackage.haskell.org/package/lens-tutorial-1.0.0 (GabrielGonzalez)
11:50:33 <ikane> Is there a channel specific to asking Cabal specific questions?
11:53:10 <Cale> ikane: Not as far as I know
11:53:34 <ikane> Cale: ok thanks, I've tried at #Cabal but they are pretty silent
11:55:49 <Cale> ikane: Did you have an actual question?
11:56:06 <Cale> ikane: This would be the channel to ask in.
11:57:23 <ikane> Cale: I'm trying to point GHC an install of LLVM I just built, but I'm unsure if I should be looking at my dot GHC file, or a cabal sandbox specific file
11:58:04 <ikane> the LLVM install is on my path but GHC keeps missing the llvm-opt
11:59:11 <Cale> ikane: Try  'which opt'
11:59:36 <ikane> Cale: right where I expect it to be
12:01:25 <Cale> Hmm, I dunno, it should just be looking in the PATH for opt and llc
12:02:30 <Atlantic778> Hi! I'm trying to learn haskell and get some experience in functional programming by solving problems on the code chef site.
12:02:56 <Cale> Atlantic778: Hello! Feel free to ask any questions you might have.
12:03:12 <ikane> Cale: yeah strange... I've only edited the path in my current shell session, I'll try putting it in the shell config file and exporting it.  Thanks for the help!
12:03:26 <Atlantic778> I'm stuck on the problem with a lot of IO processing. I have to read a lot of input lines, convert them to ints and check how many of them are congruent with some other number.
12:03:46 <Atlantic778> This is my solution: https://gist.github.com/anonymous/6eab16086864db0236e8
12:03:59 <Atlantic778> This is the text of the problem: https://www.codechef.com/problems/INTEST
12:04:22 <Cale> Atlantic778: Does that program not work?
12:04:52 <Atlantic778> Cale: yes, it is correct. It just doesn't meet performance requirements (it runs too long for large inputs).
12:05:14 <kadoban> Atlantic778: You're going to want to use Data.Text instead of String. String is pretty slow for massive amounts of input/output.
12:05:16 <tommd> Atlantic778: How is it being ran? Do you control that? Because many people either don't comile (use ghci) or don't optimizse (-O2)
12:05:37 <Atlantic778> tommd: I don't control that. I think it's compiled. 
12:05:51 <Cale> Atlantic778: I wouldn't worry about it.
12:06:01 <tommd> Atlantic778: OK.  The suggestion of Text is good.  Also, read is slow because it does some more parsing than you need.
12:06:07 <Atlantic778> tommd: by the way, I can choose in which language I will submit solution and I can see other accepted solutions but I don't understand them.
12:06:12 <kadoban> Atlantic778: Also, this is orthogonal to the speed thing, but you can consider using Data.Text.interact : http://haddock.stackage.org/lts-3.1/basic-prelude-0.5.0/BasicPrelude.html#v:interact
12:06:35 <Atlantic778> Ok, sooo... Data.Text and interact goes on my reading list.
12:07:12 <tommd> Atlantic778: See, for example, the top answer here (l that? Because many people either don't comile (use ghci) or don't optimizse (-O2) 
12:07:12 <tommd> +Ayey_ 
12:07:18 <tommd> Oops, sorry.
12:07:29 <Atlantic778> Thanks guys, this feels like really warm community. :)
12:07:39 <kadoban> Yeah, #haskell is badass ;)
12:08:18 <Cale> You could probably make that program faster using Text or something, but I'm not sure it's worth your time :)
12:08:56 <kadoban> Atlantic778: The idea of 'interact' is that you can just pretend the input is one big input Text, split it up with 'lines' and 'words', parse what you need to, etc. It's pretty neat.
12:09:54 <Cale> Also, there's no guarantee that they even have the text package installed.
12:10:13 <Atlantic778> Oh, and I have few more questions. I am used to thinking of boolean values as integers (false = 0, true != 0). My process function is basically just converting booleans to integers.
12:10:26 <Atlantic778> There has to be a better way of doing that.
12:10:36 <kadoban> It'd be pretty surprising if they didn't. Otherwise it's a bit questionable what they expect you to use … String doesn't tend to be anywhere near enough for those kinds of sites.
12:10:54 <tommd> Atlantic778: fromEnum
12:11:03 <luite> any haskellers from vancouver? :)
12:11:11 <tommd> > fromEnum (mod 5 3 == 0)
12:11:13 <lambdabot>  0
12:11:33 <tommd> luite: BC?
12:11:47 <tommd> luite: Are you looking for ICFP reasons?
12:12:20 <luite> i'll give you a free ghcjs intro course if you give me an apple power cord that fits the plugs here ;p (any apple user surely has a few spares, right? those power adapters don't last very long)
12:12:30 <kadoban> Atlantic778: You're converting them to 0 and 1 and then summing, instead you can just filter by your predicate and then take the length
12:12:48 <luite> tommd: no i just arrived there this morning, icfp in 2 weeks, but first some other stuffs, and the west coast trail next week
12:13:13 <luite> oh i also still need a tent, sleeping bag and cookware for that hike
12:13:38 <luite> free ghcjs course for supplying those too :)
12:14:39 <kadoban> Atlantic778: So change the name of process to something more appropriate, like 'divides' maybe? Then change it's type to :: Int -> Int -> Bool, and then you can do: print . length . filter (`divides` k) $ l    I probably screwed up the meaning and 'divides' doesn't actually make sense as a name, but whatever.
12:14:42 <tommd> luite I could provide a tent and sleeping bag here in Portland... and you could give a ghcjs tech talk at Galois.
12:18:21 <luite> hm that's 9 hours by greyhound, do they have wifi?
12:18:47 <tommd> Greyhound or Galois?
12:19:06 * hackagebot lzma 0.0.0.0 - LZMA/XZ compression and decompression  https://hackage.haskell.org/package/lzma-0.0.0.0 (HerbertValerioRiedel)
12:19:21 <luite> hehe, Greyhound, otherwise i wouldn't know what to do
12:20:03 <luite> tommd: but that might be fun for after ICFP, I have a few more weeks in this area
12:20:36 <tommd> luite feel free to set something up for after ICFP - or run into one of our many many folks who are attending.
12:21:07 <tommd> luite: lispy sets up the tech talks these days, but I'm betting anyone attending will be happy to help host.
12:21:36 <luite> what's the processing time for ESTA? i think mine is expired
12:22:07 <tommd> I haven't a clue.
12:24:30 <solrize> johnw?
12:24:52 <solrize> @seen johnw
12:24:52 <lambdabot> johnw is in ##categorytheory, #ledger, #ghc, #agda, #haskell-infrastructure, #haskell-lens and #haskell..
12:25:21 <solrize> @tell johnw please join emacsconf, we need help :)
12:25:21 <lambdabot> Consider it noted.
12:33:59 <int-e> (sorry, but @seen wasn't supposed to be enabled)
12:34:40 * mniip continues to bug int-e about multi-argument JOIN
12:40:19 <tommd> Has one regex came to rule them all at this point?
12:41:03 <tommd> Something that consumes Data.Text.Text?
12:41:20 <kadoban> tommd: Parsec? ;)
12:41:24 <scshunt> attoparsec?
12:41:56 <arkeet> those aren't regex
12:42:10 <arkeet> (but maybe what you want isn't really regex)
12:42:13 <tommd> I was going to saw, attoparsec grew since I looked!
12:42:17 <mniip> no one wants regex
12:42:20 <kadoban> But they're better for every case I've ever come across.
12:42:21 <tommd> arkeet: What I want is regex.
12:42:29 <mniip> tommd, no you don't
12:42:34 <tommd> mniip: Yes, I do.
12:42:42 <arkeet> this is going somewhere.
12:42:47 <tommd> Yep
12:42:52 <mniip> tommd, XY?
12:42:55 <arkeet> what do you want it for.
12:43:44 <tommd> arkeet: I want to add a /grep feature to glguy's irc-core.
12:44:05 <tommd> So regex is a somewhat universal language for what I believe the target audience t obe.
12:44:08 * hackagebot soxlib 0.0.2.1 - Write, read, convert audio signals using libsox  https://hackage.haskell.org/package/soxlib-0.0.2.1 (HenningThielemann)
12:47:13 <mniip> tommd, no!
12:47:25 <mniip> use hint to compile haskell expressions to parsec parsers
12:47:32 <arkeet> ??
12:47:41 <tommd> s/compile/interpret
12:47:43 <arkeet> his use case seems pretty reasonable to me.
12:47:45 <mniip> right
12:47:50 <arkeet> for regex
12:47:53 <mniip> arkeet, I was exaggerating, oka
12:47:53 <mniip> y
12:47:55 <arkeet> :-)
12:48:06 <tommd> mniip: I don't think hint is the right solution.  It would introduce more deps and greater breakage for a smaller target audience.
12:48:17 <tommd> Ahh
12:48:20 <arkeet> I would suggest something like regex-posix or so but.
12:48:28 <arkeet> it doesn't seem to be maintained?
12:48:42 <tommd> There are actually rather few regex packages for the Text type.  Just one that seems worthy so I guess that's what I'll use.
12:48:48 <geekosaur> does it need to change all the time?
12:49:06 <arkeet> or at least it hasn't had a release in 3 years
12:49:15 <arkeet> but maybe it still works.
12:49:29 <geekosaur> POSIX regex is relatively simple; if there are bugs, it's most likely either in the harness (separate package) or in the system's regex libs
12:49:51 <tommd> Or we could find the implementation of "A play on regular expressions".
12:49:56 <tommd> I'd be totally OK with that.
12:50:05 <geekosaur> also it's part of the Platform so you can assume it gets tested on every Platform release (like, er, a week or so ago)
12:50:45 <arkeet> I didn't know that.
12:52:04 <mniip> [21:45:58] <tommd> There are actually rather few regex packages for the Text type.  Just one that seems worthy so I guess that's what I'll use.
12:52:14 <mniip> just implement one using parsec on top of parsec
12:52:25 <tommd> More options, yes.
12:52:47 <tommd> OK, I'm out of coffee, which implies I should go home and hold a bike steady for a five year old. I'll finish this another time.
12:52:49 <tommd> Later.
12:52:57 <hodapp> o_O
12:53:03 <hodapp> I am really not sure how this implies that.
12:53:20 <arkeet> a long chain of implications.
13:11:58 <eikke> edwardk: I didn't think this through much yet, so might be totally off, but I was wondering: iany change it's possible to make a MonadThrow instance for ST?
13:16:06 <mniip> edwardk, so if I've derived the nature of lenses as 'Functor f => (a -> f b) -> s -> f t', where get uses f~Const a, and over uses f~Identity
13:16:17 <mniip> what's the next step to derive other strctures?
13:16:37 <mniip> (Prism, Traversal, Iso, Fold, ...)
13:28:23 <mpickering> what do you mean by derived?
13:34:31 <Fay> :t ~
13:34:32 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
13:34:41 <Fay> :t (~)
13:34:42 <lambdabot> parse error on input ‘)’
13:34:49 <Fay> whats ~
13:36:19 <pavonia> Type equality or what it is called
13:36:38 <Fay> oh ok
13:36:40 <Fay> thanks
13:36:41 <pavonia> :t undefined :: (a ~ Int => [a])
13:36:42 <lambdabot> [Int]
13:36:56 <Fay> ah 
13:37:45 <rpfun> is there a way to specify multiple extra-lib-dirs in a cabal.config file in a sandbox?
13:38:16 <rpfun> right now it works if i just put one directory, like "extra-lib-dirs: C:/asdf/fdsa", but I can't figure out the list syntax
13:40:08 <edwardk> eikke: i have no particular objection to such an instance
13:40:11 <mniip> :k (~)
13:40:12 <lambdabot> k -> k -> Constraint
13:40:15 <mniip> Fay, ^
13:42:46 <Fay> oh thanks
13:46:08 <Gurkenglas> What's the simplest type signature whose inhabitants require recursion to be implemented?
13:46:30 <Gurkenglas> *inhabited type signature :P
13:50:26 <t7> (a -> a) -> a ?
13:50:45 <t7> wait
13:51:26 <t7> :t fix
13:51:28 <lambdabot> (a -> a) -> a
13:51:31 <t7> yey
13:51:43 <t7> @djinn (a -> a) -> a
13:51:43 <lambdabot> -- f cannot be realized.
13:52:01 <t7> djinn cant into bottom?
13:54:23 <mniip> t7, bottom is an inconsistency in lambda calculus
13:54:57 <shachaf> forall a. a
13:55:03 <mniip> letting djinn do bottom would produce most boring implementations you'd ever see
13:55:12 <t7> :P
13:55:15 <kadoban> Haha, it'd be funny though.
13:55:35 <t7> constant time solving 
13:55:39 <mniip> for example, Maybe a -> (a -> Maybe b) -> Maybe b
13:55:42 <mniip> would infer 'undefined'
13:55:49 <arkeet> @djinn Maybe a -> (a -> Maybe b) -> Maybe b
13:55:49 <lambdabot> f a b =
13:55:49 <lambdabot>     case a of
13:55:49 <lambdabot>     Nothing -> Nothing
13:55:49 <lambdabot>     Just c -> b c
13:56:03 <t7> djinn cant into monads?
13:56:15 <arkeet> well djinn already knows how to find multiple solutions
13:56:25 <arkeet> so maybe it would just the least interesting ("undefined") solution last
13:56:50 <arkeet> there is already an uninteresting solution for that Maybe:
13:56:52 <arkeet> f a b = Nothing
13:57:00 <arkeet> @djinn Maybe a -> (a -> Maybe b) -> Maybe c
13:57:00 <lambdabot> f _ _ = Nothing
14:04:05 <rpfun> sorry to bump, does anyone have an example where multiple directories can be set to extra-lib-dirs in a cabal.config file? as I said, i have tried "extra-lib-dirs: C:/asdf/fdsa", which works, but none of "extra-lib-dirs: C:/asdf/fdsa, C:/asdf/fdsa1" or "extra-lib-dirs: C:/asdf/fdsa C:/asdf/fdsa1" work. quoting doesn't help either
14:05:01 <rpfun> i have even tried a project where i only need the first directory, so it compiles with "extra-lib-dirs: C:/asdf", but doesn't compile with "extra-lib-dirs: C:/asdf, C:/asdf2" even though it doesn't need asdf2 (and asdf2 ) exists
14:13:27 <gamegoblin> Is there a way I can provide a default implementation of a class function if the particular instance of the class is also an instance of another class?
14:14:24 <kadoban> gamegoblin: I don't see why not. Am I missing something?
14:14:38 <gamegoblin> e.g. I want to make an IsByteString sort of class, and if the type is an instance of Show, I can provide a default implementation in the form of "pack . show", otherwise the implementor will have to provide their own definition
14:15:41 <kadoban> Oh I see. Yeah I'm not sure about that. I mean you can provide an instance for every instance of Show, but that's less of a default and more of … the only one allowed unless you do something icky like OverlappingInstances or whatever it's called.
14:17:14 <kadoban> gamegoblin: So I suspect the answer is no, but I'm not the most knowledgeable person around so I may be wrong.
14:18:48 <eikke> gamegoblin: that'd make instances undecidable
14:18:53 <kadoban> gamegoblin: One thing you could do is if the instance function is myFunc, put a defaultMyFunc = pack . show    and tell people to use that if they want, but it wouldn't be automatic.
14:19:30 <eikke> gamegoblin: but if you really want to go that route, look for the DefaultSignatures language extension, that might help in hacking something up
14:22:00 <gamegoblin> kadoban: "can provide an instance for every instance of Show" how?
14:24:05 <kadoban> gamegoblin: instance (Show a) => MyClass a where    ?
14:24:49 <gamegoblin> kadoban: compiler says I’ll need UndecidableInstances for that… hmmm
14:24:56 <kadoban> gamegoblin: You … probably don't want to do that though IIUC.
14:24:56 <gamegoblin> I’ve heard bad things about that extension
14:27:27 <kadoban> I don't think you need at extension at all just for that syntax, though I may be wrong. But actually using it will be pretty hard without making it fail horribly and requiring goofy extensions (because just about everytihng is an instance of Show, so … there's going to be a lot of instance overlap unless you don't actually declare any instances, which would probably be useless)
14:28:11 <kadoban> s/need at/need an/
14:36:05 <obb> why does everyone write (x:xs)?
14:37:05 <kadoban> obb: In a pattern match, as opposed to just x:xs ?  That'll give you errors.
14:37:55 <obb> no i mean why they all name it x and xs
14:38:14 <mniip> an ecks prepended to multiple eckses
14:38:17 <kadoban> Just a convention.
14:38:22 <obb> where does this convention come from? :D
14:38:54 <kadoban> obb: What would you propose instead?
14:39:20 <exio4> it's a convention based on that highly polymorphic function can't get really informative names more than a few chars meaning nothing by themselves
14:39:28 <exio4> the s comes from some kind of plural
14:40:11 <obb> (first:rest) maybe
14:40:24 <obb> or (f:r) for brevety
14:40:29 <mniip> what if you have multiple lists
14:40:32 <kadoban> obb: Then what happens when you're breaking apart multiple lists?
14:40:49 <exio4> @src zipWith 
14:40:49 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:40:55 <obb> like how?
14:40:58 <kadoban> obb: It's better to be able to see that f and r are related.
14:41:02 <mniip> @src zip
14:41:02 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
14:41:02 <lambdabot> zip _      _      = []
14:41:11 <obb> f1 r1 :D
14:41:28 <mniip> that's equivalent to using letters
14:41:59 <kadoban> obb: That'd be an option, I guess. It doesn't seem any better though for sure, I suspect it's worse.
14:42:19 <exio4> it's not giving a lot of information either, the s-plural convention also expands to lists of lists
14:42:29 <obb> agreed
14:42:40 <exio4> (xs:xss)
14:42:57 <obb> ok so thats what the s means
14:44:35 <mniip> [23:35:29] <mniip> an ecks prepended to multiple eckses
14:45:10 <obb> oh sorry
14:48:27 <obb> http://weknowgifs.com/wp-content/uploads/2013/08/didnt-read-lol-gif-15.gif
14:54:53 <fr33domlover> How do I solve "depends on multiple versions of a package"? http://paste.rel4tion.org/46
14:55:06 <fr33domlover> is there a way to actually see what causes the conflict?
14:55:25 <fr33domlover> I do have some constraints I can relax, but I'm not sure which :P
14:55:30 <johnw> the outptu is telling you
14:56:22 <fr33domlover> johnw, but does "requires package-version" mean it strictly requires that version?
14:56:35 <fr33domlover> all my dependencies are only lower bounds
14:57:14 <johnw> some packages you're depending on have different lower bounds
14:57:31 <Gurkenglas> Can you name a term from an inhabited type that never terminates, such that no subterm of it never terminates?
14:57:46 <bennofs> fr33domlover: the problem is probably that you have already compiled versions of those packages, compiled against the respective version of the dep
14:57:58 <johnw> Gurkenglas: huh?
14:58:26 <bennofs> fr33domlover: so you already compiled HTTP against network-2.6.2.0 and tls against network-2.6.2.1
14:58:58 <fr33domlover> bennofs, that may explain why linking failed until I rebuilt tls and suddenly it succeeds now :P
14:59:27 <bennofs> Gurkenglas: let x = length [1..] in x ?
15:00:46 <Gurkenglas> Hmm. Right, thanks. I couldn't think of any that didn't include something like "fix id" there for some reason. "fix (:[])" would work too.
15:02:17 <Gurkenglas> Umm I mean fix (++[]) I guess...
15:02:58 <bennofs> Gurkenglas: for every computable rule for terminating terms that you can come up with, there will be some term that terminates and doesn't satisfy the rule [if i understand halting problem correctly]
15:03:44 <Gurkenglas> "has a subtype that never terminates" is not computable
15:04:51 <bennofs> ah
15:04:56 <bennofs> right
15:10:17 <spindas> I'm writing a fold over a structure that produces a HashSet (from unordered-containers) from elements in the structure. Which will perform better: creating singleton sets and union'ing them together as I go, or creating a big list and running fromList over it at the end?
15:10:55 <johnw> those might even be the same thing
15:10:59 <johnw> I'd check the source
15:13:26 <mniip> johnw,  some people in black suits came looking for you
15:13:33 <johnw> uh oh
15:18:08 <bamboo> what would be a idiomatic solution to parse a string like “[mscorlib]System.Math.Max” into a tuple (“mscorlib”, “System.Math”, “Max”)  ? I have something very ugly full of elemIndex, splitAt and drop…
15:19:45 <mniip> parsec?
15:20:27 <bamboo> mniip, I was considering it, at first it sounded a bit heavyweight but if it’s what haskellers would do
15:20:43 <ClaudiusMaximus> span or break would be a slight improvement
15:21:54 <ClaudiusMaximus> but still not a real parser (with its benefits like error handling)
15:22:56 <bamboo> yeah, makes sense
15:23:19 <bamboo> and what’s the deal with attoparsec  versus parsec?
15:24:32 <exio4> attoparsec is meant for speed and makes some tradeoffs, like worse error handling, and not being a monad transformers
15:25:04 <bennofs> bamboo: perhaps for something more lightweight, you could use regex-applicative?
15:25:07 <bennofs> @hackage regex-applicative
15:25:07 <lambdabot> http://hackage.haskell.org/package/regex-applicative
15:25:24 <ClaudiusMaximus> parsec-style parsers are more composable than ad-hoc list processing too, in my experience it's rare that you want to parse something simple in isolation, eventually you want to parse a whole config file or whatever
15:25:46 <bamboo> exio4, thanks
15:25:54 <exio4> (using attoparsec like you would use parsec won't lead to any speed improvement, tho)
15:25:54 <bamboo> bennofs, interesting
15:26:17 <exio4> ClaudiusMaximus: yeah, they're also easier to reuse and change 
15:27:02 <bamboo> ClaudiusMaximus, yes, I can see that I’ll need to parse a few more things in that string soon
15:27:19 <bamboo> ok, parsec it is, thanks everyone!
15:29:21 <bamboo> well, actually that regex-applicative package looks really nice :)
15:29:43 <mniip> bamboo,  sec
15:29:52 <Welkin> bamboo: so you are on of those people
15:30:00 <Welkin> "well actually..."
15:30:15 <bamboo> I couldn’t resist, I heard it today
15:30:35 <Welkin> there is a twitter account that collects all of the hacker news posts that begin with "well actually"
15:31:13 <lpaste_> mniip pasted “parse” at http://lpaste.net/138980
15:31:32 <mniip> add error handling to your taste
15:31:49 <asthasr> So I watched a video about avoiding monads in imperative languages, and instead using scoped continuations. The concept sounds interesting, but the talk itself was deeply unconvincing
15:32:15 <tommd> Convince yourself and produce a better talk?
15:32:22 <asthasr> i.e. making mistakes like thinking that an Error monad in an imperative language must necessarily lose stack information
15:32:40 <mniip> bamboo, ^
15:33:16 <asthasr> tommd: Well, that's where my next question is coming from. ;) Anyone know of a good paper or intro to scoped continuations?
15:36:20 <lamefun> uhm... why {-# MINIMAL #-} doesn't allow "default"?
15:36:35 <bamboo> mniip, very nice
15:36:57 <lamefun> to specify only the circular dependencies and have the rest inferred automatically
15:37:13 <webchat099> asthasr do yoy have the URL of that video?
15:37:38 <bamboo> it took me some time to understand the special casing of the last dot
15:37:55 <asthasr> webchat099: http://blog.paralleluniverse.co/2015/08/07/scoped-continuations/
15:38:03 <asthasr> That includes a video link and the related blog post
15:41:33 <gamegoblin> @pl \x -> (f x, ())
15:41:33 <lambdabot> flip (,) () . f
15:44:18 * hackagebot lzma-streams 0.1.0.0 - IO-Streams interface for lzma/xz compression  https://hackage.haskell.org/package/lzma-streams-0.1.0.0 (HerbertValerioRiedel)
15:46:15 <kadoban> I assume persistent is still a good solution for storing serializing stuff in a decent way, or is it outdated and I missed something?
15:48:35 <lamefun> What's the point of Description in Haddock module comment? It doesn't seem to show up anywhere.
15:49:27 <tommd> lamefun: It shows up at the top of the haddocks...
15:49:56 <d-snp> I just upgraded my haskell platform to 7.10.2, and now cabal won't find language-c-0.4.7, have I done something wrong?
15:50:05 <d-snp> I did cabal update, it complains when I run cabal configure
15:50:11 <Welkin> what?
15:50:13 <tommd> d-snp: You need to re-install packages after changing compiler.
15:50:19 <Welkin> there is no haskell platform for 7.10.2
15:50:20 <Welkin> is there?
15:50:32 <Welkin> oh wow
15:50:34 <Welkin> there is now
15:50:41 <Welkin> I don't use the platform any more
15:51:15 <d-snp> tommd: oh jeez I forgot about that, sorry I only do haskell like once a few months and I always forget stuff like that :P
15:51:17 <Welkin> the website has been changed too
15:51:30 <Welkin> d-snp: how do you only use haskell once every few months?
15:51:34 <Welkin> is it a ritual?
15:51:45 <lamefun> tommd, haddock doesn't parse the way I was writing them, that was my problem, how the descriptions do show up.
15:51:45 <d-snp> no, I have one project in haskell that I do in my spare time :P
15:51:51 <d-snp> amongst like 10 other projects :P
15:53:18 <lamefun> I was writing them like this: "-- | Name1 : Value1\n--   Name2 : Value2".
15:53:51 <d-snp> are the cabal maintainers stealing back from cargo? cargo is like the lovechild of cabal and bundler, taking much after cabal and it has some very nice improvements I think cabal could steal back
15:55:17 <bennofs> d-snp: hmm, I'm not familar with cargo, what improvements does it bring?
15:56:08 <d-snp> bennofs: well they put the bundler functionality right in there as a default behaviour instead of hiding it behind a 'sandbox' sub command
15:57:01 <d-snp> I have a feeling sandbox is more complex than it should be too, though I'm not enlightened on why sandbox is how it is
15:57:23 <d-snp> also the thing I just ran into, I ran cabal build, and it didn't automatically fetch and install dependencies
15:57:46 <d-snp> which is logical if you think about it if you think about cabal as a package manager for the whole system
15:58:21 <d-snp> but if you think about it as the build tool of your current project, which it is because it's in a sandbox, then it should just pull in deps without asking
15:59:07 <kadoban> Why does Database.Persist.TH say "Regular users do not need to use this module.", yet every persistent example I see uses it?
15:59:19 <d-snp> :P
15:59:42 <bennofs> d-snp: well, if you're working in a sandbox, just running `cabal install` will behave similar to `fetch deps + build` (it'll install into the sandbox too, but that shouldn't be a problem)
16:00:55 <kadoban> d-snp: sandboxes with cabal are indeed pretty complicated. There's newer/nicer tools like 'stack' you can use instead of using cabal. https://github.com/commercialhaskell/stack
16:01:35 <bennofs> d-snp: the complexity probably comes from the fact that there are multiple possible workflows. For example, one might want to share sandboxes between projects, or depend on other local projects which are built from source and should be rebuilt whenever their dependencies change. And yes, a more recent alternative which aims to be simple OOTB is stack
16:03:48 <d-snp> bennofs: cargo (and bundler), just have a .lock file that determines which exact versions of dependencies are used, and dependencies are installed in $HOME/.rust/packages/$PACKAGE_NAME-$EXACT_VERSION or something like that
16:03:54 <d-snp> maybe even a hash of the compiler flags appended
16:04:19 * hackagebot xmonad-wallpaper 0.0.1.0 - xmonad wallpaper extension  https://hackage.haskell.org/package/xmonad-wallpaper-0.0.1.0 (yeyan)
16:04:33 <d-snp> anyway the result is that your lock describes the packages uniquely, so the packages can just be in a global dir
16:04:54 <d-snp> and shared should two projects depend on the same project, without problems emerging
16:06:52 <d-snp> I'm looking into stack, maybe it's better, but it's more of a fork of the ecosystem right? I mean lots of people are just going to continue cabal, and cabal won't stop existing?
16:07:45 <ttt_fff> should "runtime" be named Runtime or RunTime ? should it be shortened as Rt or RT ?
16:08:19 <mpickering> yes d-snp 
16:08:21 <bennofs> d-snp: I think sombody is working to make cabal more "nix-like" (to allow multiple versions / same versions of the same package with possibly different versions of dependencies coexisting in a single "store" (like ~/.rust/packages)
16:09:38 <d-snp> why would someone use cabal if stack exists?
16:09:57 <bennofs> d-snp: does cargo allow installing two instances of the same version of a single library, but compiled against different versions of dependencies?
16:10:48 <d-snp> bennofs: lemme check :P
16:10:53 <kadoban> d-snp: cabal is pretty terrible at the moment. I have no idea if/when it'll improve, but … yeah stack is just better. If it helps, it uses the Cabal library internally, you still use .cabal files, etc. So it's pretty compatible.
16:11:42 <kadoban> d-snp: The only thing to keep in mind is, stack is pretty new. But I've been using it for a while now and so far it's great.
16:13:31 <d-snp> bennofs: I don't think build artefacts are in the global repo at all
16:14:33 <bennofs> d-snp: oh, then if I use foo in project A and B, I'll have to compile foo twice?
16:14:37 <d-snp> yes
16:14:58 <d-snp> actually the rust compiler is pretty slow compiled to Haskell, it hasn't even got incremental compilation yet
16:15:22 <ttt_fff> does the rust type system force Int -> Int functions to have no side effects?
16:15:36 <ttt_fff> d-snp: ^
16:15:46 <bennofs> ttt_fff: no
16:15:47 <d-snp> ttt_fff: no it doesn't
16:16:09 <bennofs> kadoban: does stack support packages not in stackage?
16:16:12 <d-snp> ttt_fff: but it does guarantee that any references it got to immutable data are not mutated
16:16:50 <bennofs> d-snp: well, except unsafe, right? [but there's unsafePerformIO in haskell too, so that probably doesn't count]
16:16:51 <ttt_fff> d-snp: hmm, so it allows IO, but not mutation, interesting
16:16:56 <d-snp> at least, not by pure (safe) rust
16:17:11 <d-snp> right :)
16:17:16 <exio4> it allows mutation locally
16:17:31 <ttt_fff> so Haskel;'s Int -> Int is like {you can compute an Int; you can't do anythign else); Rust's "Int -> Int" is like "you can't mutate stuff; but you can do whatever else // including send network packets" right?
16:18:00 <d-snp> yes
16:18:25 <ttt_fff> noted, thanks
16:19:11 <d-snp> it also has algebraic datatypes like in Haskell
16:19:11 <bamboo> mniip, http://lpaste.net/138982
16:19:14 <kadoban> bennofs: Yep. I haven't used it too much, but it's there.
16:19:40 <d-snp> and it uses them to implement Maybe, so it has no implicit null references
16:20:38 <d-snp> unfortunaly (I feel) it doesn't force exception handling, so it's just as bad as Haskell in that regard ;)
16:20:47 <ttt_fff> hmm, does Rust have type classes?
16:21:02 <ttt_fff> d-snp: haskell is execellent at error handling, I just had to roll my own
16:21:41 <d-snp> I think it does, though it's not as powerful as Haskell's
16:21:58 <d-snp> but I'm not a type wiz so I'm a bit fuzzy as to why not 
16:22:45 <d-snp> I've written about ~500 lines of Rust now, so I'm definitely a novice, still struggling with their borrow checker
16:22:56 <d-snp> getting code to compile is almost as hard as it is in Haskell :P
16:23:48 <d-snp> the immutability thing is pretty hard to get an intuition on, you feel like you're in a regular imperative language
16:24:00 <d-snp> but all sorts of things are not allowed that could cause invalid use of references
16:24:28 <d-snp> things like taking two elements from an array, that's actually easier in Haskell than it is in Rust
16:24:32 <d-snp> though they're working on that
16:25:49 <d-snp> you wouldn't expect to have difficulty with such a simple thing, since Rust looks so much like C, but it's actually much more like Haskell in that you sometimes have to transform your code to work around the restrictions
16:26:25 <d-snp> and Haskell has an advantage in that it's garbage collected and has referential transparency, so you can just grab copies/aliases of anything you need
16:26:26 <joshkirklin> For a program I'm writing want to provide a configuration file written in haskell in the style of xmonad, i.e. one that gets recompiled after restart if it has changed. Does anyone know where I should begin with such a thing? (save actually scouring the xmonad sources...)
16:26:48 <bennofs> joshkirklin: I think the dyre library implements that
16:26:51 <bennofs> @hackage dyre
16:26:51 <lambdabot> http://hackage.haskell.org/package/dyre
16:27:00 <joshkirklin> awesome, thanks, I'll check it out.
16:53:18 <Sindriava> 2AM reminder that #haskell is a nice place and I love you guys!
16:54:15 <kadoban> 2AM reminder that … you're across the world somewhere ;)
16:54:34 <Sindriava> Doesn't make it not 2AM :D
16:54:39 <Sindriava> It's always 2AM somewhere!
16:54:51 <Sindriava> #thingsalcoholicssay
16:56:52 <mniip> Sindriava, false
16:56:57 <mniip> timezones are integral
16:57:09 <mniip> it's 2AM only about 30-35 times a day
16:57:28 <Sindriava> 35 times a day? O.o
16:57:34 <pacak> Haskell?
16:57:35 <Sindriava> I'd assume it's at most 24?
16:57:45 <pacak> Sindriava: No, it's not.
16:57:49 <kadoban> Sindriava: Not all timezones are at whole number of hour offsets
16:57:58 <Sindriava> Oh yeah, derp
16:58:06 <Sindriava> Fair enough, let's carry on
16:58:16 <kadoban> I don't know how many aren't though, I think only a small number? Hard to say.
16:58:25 * mniip checks with newyears script
16:58:46 <mniip> > length [840, 825, 780, 720, 690, 660, 630, 600, 570, 540, 525, 480, 420, 390, 360, 345, 330, 300, 270, 240, 210, 180, 120, 60, 0, -60, -120, -180, -210, -240, -270, -300, -360, -420, -480, -540, -570, -600, -660, -720]
16:58:47 <lambdabot>  40
16:58:57 <mniip> 40 timezones are inhabited by people
16:59:04 <Gurkenglas> Did Applicative come after Parsec?
16:59:08 <pacak> mniip: Is it taking into account new north korean time zone?
16:59:12 <pacak> Gurkenglas: Yes.
16:59:21 <Gurkenglas> So that explains where some and many came from.
16:59:22 * hackagebot MFlow 0.4.5.10 - stateful, RESTful web framework  https://hackage.haskell.org/package/MFlow-0.4.5.10 (AlbertoCorona)
16:59:55 <mniip> pacak, did it exist on january 1st this year
17:00:18 <pacak> mniip: Can be 41 then.
17:00:35 <mniip> UTC+0830
17:00:42 <mniip> which is 270
17:00:45 <mniip> yes, it is in my list
17:28:12 <ttt_fff> wtf are attribute grammars? https://wiki.haskell.org/Attribute_grammar
17:28:36 <ttt_fff> I saw them in Beginning Haskell, but it (1) looks complicated, involving a prepreocessor, and (2) Im not sure what we gain from it
17:29:22 <johnw> https://wiki.haskell.org/The_Monad.Reader/Issue4/Why_Attribute_Grammars_Matter
17:33:05 <monochrom> indeed it does not gain much. therefore it is not often used.
17:33:29 <ttt_fff> I get this impression that with typeclasses , I can avoid attributes
17:39:35 <ski> @where UUAG
17:39:35 <lambdabot> http://www.cs.uu.nl/wiki/HUT/AttributeGrammarSystem
17:40:27 <johnw> monochrom: are these attribute grammars doing something similar to what beautiful folding achieves?
17:40:29 <ski> ttt_fff : it can be nice for tree processing, especially if you have multiple "conceptual" stages in a single traversal
17:40:54 <ski> `repMin' is a simple example
17:41:23 <ski> iirc there was some paper with a more advanced pretty-printing with layout negotiation example
17:42:19 <deepfire> is it possible to get similar functionality for promoted data types as is available for type-level naturals and symbols?
17:44:37 <deepfire> as in, how implementable is an equivalent to sameSymbol?
17:45:56 <deepfire> GHC.TypeLits.sameSymbol, to be precise
17:47:33 <mniip> deepfire, yes
17:47:43 <mniip> without much extensions even
17:48:15 <deepfire> mniip, where should I look at for inspiration?
17:48:21 <mniip> uhh
17:48:27 <mniip> I'm not actually sure
17:49:17 <deepfire> I've been looking at http://ponies.io/posts/2014-07-30-typelits.html for the type-level symbols case
17:49:39 <deepfire> it's got a pretty self-contained example at the end
17:54:20 <jura> Hello I have a question about whether a compile error I encountered is a compiler bug or something I am doing wrong.
17:54:32 <mniip> @where lpaste
17:54:32 <lambdabot> http://lpaste.net/
17:55:23 <jura> the error looks like this "dist/build/ray-tracer-worker/ray-tracer-worker-tmp/Main.o: In function `sh8b_info':
17:55:23 <jura> (.text+0xa05): undefined reference to `raytrzuDt7m371fTWGHWGravFAit1_Types_zdfBinaryColor_closure'
17:55:23 <jura> "
17:55:40 <jura> and there are about 50 of them
17:56:16 <jura> a link to the code may be found here: https://github.com/jrraymond/ray-tracer/tree/master
17:56:44 <jura> @mniip where you talking to me?
17:56:44 <lambdabot> Unknown command, try @list
17:56:46 <mniip> Types.$fBinaryColor
17:56:54 <mniip> interesting
17:57:05 <jura> I'm using ghc 7.10.1
17:58:12 <jura> I'm in the process of trying to reproduce from a completely fresh git clone by installing all the dependencies takes a while
17:58:45 <mniip> jura, paste a full list of errors to the provided link
18:00:40 <d-snp> heh, ghc now outputs warnings if it sees tab characters?
18:00:49 <mniip> yes
18:00:53 <d-snp> it complains for every single line :P
18:00:59 <geekosaur> yep
18:01:36 <jura> mniip http://lpaste.net/138988
18:03:07 <jura> mniip, interstingly enough, when I "cabal build --ghc-options="-fno-code"" I get the following message: Warning: the following files would be used as linker inputs, but linking is not being done: dist/build/RayTracer.dyn_o dist/build/HaObj.dyn_o
18:03:07 <jura> ghc: no input files
18:03:19 <jura> Also I was able to reproduce the error from a fresh git clone
18:04:03 <mniip> hmm, I don't think I can help here
18:04:46 <jura> should I file a bug or ask a question on stack overflow or on the haskell subreddit?
18:05:40 <d-snp> -fno-warn-tabs <-- jay :P
18:05:45 <d-snp> (tabs are superior!)
18:06:22 <Lokathor> spaces!
18:06:22 <kadoban> Tabs are kinda awful in general, especially in white-space sensitive languages.
18:06:23 <Lokathor> etc etc
18:06:47 <Lokathor> i use tabs in java, not in anything else though
18:09:04 <Cale> d-snp: Basically tabs are culturally taboo in Haskell, you should just tell your editor to replace them with spaces.
18:11:32 <mniip> kadoban, it's not tabs that are awful
18:11:39 <mniip> it's languages that are whitespace sensitive
18:11:44 <mniip> and code that is tabwidth sensitive
18:12:05 <d-snp> my haskell is just fine with tabs, never had a problem
18:12:13 <kadoban> mniip: Well, unless we're going to use a different language, isn't that the same thing in haskell?
18:12:17 <Lokathor> i thought haskell just read the whitespace sequence without regard to tabwidth?
18:12:30 <kadoban> I think it assume tabwidth of 8?
18:12:35 <kadoban> assumes*
18:12:52 <mniip> kadoban, I write my haskell without depending on tab width
18:13:38 <d-snp> a tab is just one indentation level, widths dont have anything to do with it
18:13:40 <kadoban> I do too … by not using tabs.
18:13:45 <d-snp> unless your parser is crappy
18:13:59 <d-snp> anyway, how do I get cabal to compile my stuff with -prof? it says: Warning: 'ghc-options: -prof' is not necessary and will lead to problems when
18:14:02 <d-snp> used on a library. Use the configure flag --enable-library-profiling and/or
18:14:05 <d-snp> --enable-executable-profiling.
18:14:10 <kadoban> d-snp: They do when whitespace is meaningful. Certain things need to line up, or be indented farther than other things.
18:14:15 <d-snp> and then a bunch of errors about unfound modules
18:14:21 <jura> is anyone familiar with how to build multiple executables and a library in cabal to prevent multiple compilation?
18:14:32 <asthasr> Is there a syntax for declaring an instance of a class using a class constraint? I.e. "instance Num a => Foo a where..."?
18:14:37 <jura> sort of like this stack overflow question: http://stackoverflow.com/questions/12305970/how-to-make-a-haskell-cabal-project-with-libraryexecutables-that-still-run-with
18:15:19 <mniip> asthasr, have you tried what you just wrote
18:15:28 <kadoban> asthasr: Looks like correct syntax to me
18:15:52 <slack1256> I think he meant writing a instance retroactively from a superclass
18:20:58 <kadoban> slack1256: I'm not sure what that means (unless you're describing what the syntax already does?)
18:44:18 <ttt_fff> to me, unification looks like a O(n log n) or O(n^2) time algorithm. Yet, wikipedia states unification can be done in linear time. What is the linear time algorithm?
18:44:28 * hackagebot sets 0.0.4.1 - Various set implementations in Haskell  https://hackage.haskell.org/package/sets-0.0.4.1 (athanclark)
18:49:10 <kadoban> ttt_fff: Look at the references it points to in that part, at least one of them is available in a pdf for free.
19:17:07 <sgronblo> what the hell does anaphoric mean?
19:17:54 <arahael> Same root as the 'ana-' in 'anabaptist', and same 'phoric' as in 'euphoric', perhaps?
19:19:29 * hackagebot hashabler 1.0 - Principled, cross-platform & extensible hashing of types, including an implementation of the FNV-1a and SipHash algorithms.  https://hackage.haskell.org/package/hashabler-1.0 (BrandonSimmons)
19:20:10 <johnw> sgronblo: in programming, anaphoric functions present you with the subject of the test
19:20:26 <johnw> aif :: Monad m => Maybe a -> (a -> m b) -> m b -> m b
19:25:03 <asthasr> mniip: I did try it.
19:25:27 <dramforever> oh you're here
19:25:47 <dramforever> asthasr: it's an undecidable instance, because if the compiler allowed that
19:26:00 <asthasr> I am now, took a walk around the neighborhood with my son
19:26:04 <dramforever> there's no reason it cannot allow instance Foo a => Num a
19:26:20 <dramforever> which causes a loop during instance resolution
19:26:21 <asthasr> hmm
19:26:26 <asthasr> so I have to use concrete types
19:26:36 <dramforever> furthermore, it overlaps with any other instance
19:26:38 <asthasr> like Foo Int, Foo Integer, Foo...
19:26:51 <dramforever> because the constraints are not considered when picking which instance to use
19:27:19 <dramforever> asthasr: a idiomatic way is to provide default functions
19:27:35 <dramforever> for example class Foo a where foo :: Integer -> a
19:27:49 <dramforever> {- outside -} fooDefault :: Num a => Integer -> a
19:28:12 <dramforever> *an idiomatic
19:30:50 <asthasr> dramforever: fair enough; how is fooDefault connected to the various Foo instances?
19:31:06 <dramforever> instance Foo Int where foo = fooDefault
19:31:10 <dramforever> instance Foo Integer where foo = fooDefault
19:31:11 <dramforever> etc.
19:33:11 <asthasr> fair enough
19:33:20 <asthasr> was wondering if there was some sort of template generation or something
19:33:39 <dramforever> hmm...template haskell?
19:33:49 <dramforever> it's not exactly easy to use
19:35:19 <asthasr> dramforever: Yeah, not intending to mess with it yet -- still learning some basic stuff -- but thought there might be something 'cute'
19:35:35 <dramforever> =)
19:35:50 <Zekka> asthasr: Can you do something like defining a function from any type in your typeclass to a single type that does implement Foo?
19:35:54 <dramforever> asthasr: you are very smart
19:35:56 <dramforever> good luck
19:36:16 <Zekka> Usually the idiomatic thing to do in cases like this is to try to use only one type (possibly one that's fairly polymorphic)
19:36:27 <dramforever> oh wow
19:36:47 <dramforever> yes you could also a newtype wrapper like Zekka said
19:36:47 <Zekka> Er, that does implement Num*
19:36:58 <Zekka> I wasn't thinking newtype wrapper although a newtype wrapper would probably work
19:37:04 <dramforever> oh not exactly like Zekka said
19:37:22 <dramforever> asthasr: alternative: newtype WrapNum a = WrapNum a
19:37:28 <asthasr> Zekka: Well, the thing I'm playing with is the surprisingly complex problem of questionnaires, which i have mentioned here before
19:37:32 <dramforever> instance Num a => Foo (WrapNum a) where ...
19:37:36 <dramforever> this fixes it
19:38:07 <asthasr> I was hoping to avoid some of the problems of the "polymorphism" necessary to have lists of different types of answers, etc. by using an existential type, Constrainable
19:38:48 <asthasr> then defining functions on the class to deal with different answer types... where things like (>) will return Left "Inappropriate constraint on this answer." when called on a string type, for example
19:38:54 <dramforever> asthasr: questionnaire?
19:39:22 <asthasr> dramforever: A set of questions, constrained in a few different ways
19:40:11 <dramforever> oh I found it in the logs
19:41:08 <dramforever> hmm
19:41:32 <dramforever> asthasr: oh so like later questions can depend on previous answers?
19:41:33 <asthasr> http://hastebin.com/siqeretoho.txt
19:41:36 <asthasr> yep
19:41:53 <asthasr> and, in fact, in my "ideal", there is no real concept of "later" versus "previous"
19:42:30 <dramforever> hmm...
19:42:35 <asthasr> the way I have been thinking about it is, it's almost like a tuple of state: (Settings, Questions, Answers). Questions can be constrained versus either of the other portions of the "State"
19:42:59 <asthasr> Arkeet made a really cool version: https://gist.github.com/arkeet/ee61240a866d72f6cf9d
19:43:07 <GLM> What is the best way to convert a String into a record type?
19:43:09 <asthasr> but after reading it I actually felt it was too imperative
19:43:09 <arkeet> I did?
19:43:12 <dramforever> Answer -> State -> State?
19:43:15 <arkeet> oh this thing
19:43:18 <asthasr> arkeet: You did! lol
19:43:48 <dramforever> actually this thing kinda looks like a comonad
19:43:54 <dramforever> rather, free comonad
19:43:57 <edwardk> ?
19:43:59 <asthasr> someone else said it was a free monad
19:44:06 <dramforever> comonad
19:44:06 <arkeet> it's a free monad
19:44:17 <asthasr> what is a comonad?
19:44:41 <arkeet> it's the thing you get when you take the definition of "monad" and flip all the arrows around.
19:44:52 <dramforever> data Questionnaire = Q Question (Answer -> Either FinalResponse Questionnaire)
19:44:53 <arkeet> it happens to be somewhat interesting.
19:44:58 <jmcarthur> s/all/most of/
19:45:00 <dramforever> asthasr: that type
19:45:58 <dramforever> isn't it a free comonad?
19:46:09 <jmcarthur> that doesn't look like a comonad to me. for one, it's not even a functor
19:46:17 <dramforever> hmm...
19:46:33 <dramforever> data Q a = Q a (Answer -> Either FinalResponse (Q a))
19:46:37 <dramforever> this, much better
19:46:56 <mac10688> it will be awesome when haskell will be able to compile down to web assembly. I'm assuming that will happen
19:47:02 <jmcarthur> yes, this looks more free comonad ish to me.
19:47:10 <dramforever> you can step through a questionnaire by providing an answer each time
19:47:16 <edwardk> jmcarthur: you flip all the arrows in category it is a monad over. but to do so you need to flip (>>=) so that it is a mapping from (a -> m b)   one arrow in the target category to (m a -> m b)
19:47:26 <dramforever> which is, afaik, exactly what a free comonad is doing
19:47:38 <dramforever> I think there's a thing called "moore machine" or something
19:47:45 <edwardk> dramforever: ok, terminology thing here, there is a cofree comonad, but no free comonad from a functor
19:47:49 <Axman6> mac10688: we already have GHCJS, which I believe uses fairly similar methods of telling the browser what types to use for things
19:47:51 <dramforever> oh
19:47:57 <dramforever> f***
19:47:57 <jmcarthur> edwardk: right. but i think when explaining this to somebody asking about it from a haskell standpoint, it's vague to just say you flip all the arrows around.
19:47:57 <edwardk> a moore machine happens to be a cofree comonad
19:48:06 <dramforever> yes I mean cofree comonad
19:48:07 <dramforever> sorry
19:48:08 <dramforever> sorry
19:48:14 <edwardk> data Cofree f a = a :< f (Cofree f a)
19:48:21 <edwardk> data Moore a b = Moore b (a -> Moore a b)
19:48:22 * dramforever says a lot of "sorry"s
19:48:30 <dramforever> ha!
19:48:43 <edwardk> can be seen as Cofree ((->) a) b
19:49:03 <dramforever> "the questionnaire comonad"
19:49:12 <edwardk> Moore is a profunctor, comonad, a bunch of things
19:49:28 <asthasr> you guys might think I'm crazy, but I actually created a mini-language capturing what I was thinking:
19:49:35 <asthasr> http://hastebin.com/quwihuhebi.txt
19:49:46 <jmcarthur> asthasr: creating languages is not at all crazy around these parts :)
19:50:01 <edwardk> its also much better encoded with data Moore a b where Moore :: (s -> b) -> (s -> a -> s) -> s -> Moore a b -- because otherwise fmaps are paid for by every step of the evaluator, not just the last one if you aren't constantly checking the 'b's you get out.
19:50:31 <dramforever> weird...hastebin.com isn't showing me anything beyond the little toolbar-ish stuff on the top right
19:50:37 <dramforever> edwardk: wow
19:50:51 <asthasr> dramforever: sometimes it is dumb
19:51:23 <asthasr> https://pastee.org/r4623
19:51:56 <dramforever> good
19:52:12 <mac10688> Axman6, ah. I may have made an assumption that the library would be more optimal if it compiles down to assembly. I guess I should try out ghcjs before making assumptions
19:52:33 <Axman6> mac10688: some of the commends on http://weblog.luite.com/wordpress/?p=14 might be of interest to you
19:53:08 <mac10688> thanks for the link. I'll give it a read
19:53:27 <dramforever> asthasr: this "constrained by" thing is rather weird...
19:53:38 <Axman6> IIRC, (and luite can correct me if I'm wrong), GHCJS does a pretty good job of compiling Haskell into a sort of virtual machine which sits at about the level of the STG - if you look at code compiled with GHCJS you'll see it starts by defining all the registers it uses in execution
19:53:55 <dramforever> asthasr: how do you decide when a question is unanswered?
19:54:05 <Axman6> I'm by no means an expert though, and luite will probably cringe at my explanation =)
19:54:36 <asthasr> dramforever: The way I am considering it, each question would have an identity, like :continent; once answered, that question's answer will go in the "answer state"
19:54:45 <dramforever> ok then
19:55:02 <asthasr> "constrained by answered :continent with :as" would be something like -- continent is present in the answer state, and its answer was :as
19:55:35 <dramforever> hmm...I think I get it now
19:55:39 <dramforever> doesn't look bad =)
19:55:51 <asthasr> I think it's relatively sane
19:55:57 <dramforever> yep
19:56:06 <asthasr> and I think that it can accomplish what I intend, which is a data-driven structure for dynamically presenting questions
19:56:16 <asthasr> and I am confident that I could write it in Python in about two hours
19:56:42 <asthasr> but, given that this is not something anyone is dying for at my workplace, so it's hobbyist stuff... I want to understand how to implement it best in Haskell ;)
19:56:59 <asthasr> perhaps then to make it available as open source, because it seems like something that people might like to use
19:57:01 <dramforever> suggestion: maybe move those constraints
19:57:05 <dramforever> so that it's like
19:57:18 <dramforever> question A, when answered X, show question B
19:57:28 <asthasr> but, see --
19:57:29 <dramforever> when answered Y, show question C
19:57:30 <asthasr> that's what I want to avoid
19:57:34 <dramforever> oh?
19:57:42 <asthasr> I want question A to declare its own constraints
19:58:02 <asthasr> the initial list of questions should consist of, like, [A, B, C...] -- you filter by the questions that have their constraints met
19:58:20 <asthasr> then present (head questions) to the user, or however your "display strategy" is implemented
19:58:43 <dramforever> I'm not sure what you want, but here's my idea
19:58:55 <dramforever> present a list of inital questions [A B C]
19:59:02 <dramforever> user answers A with X
19:59:18 <dramforever> then add questions D and E to the list
20:00:30 <asthasr> that feels like you're branching from A -> [D, E]
20:01:00 <dramforever> yes I am
20:02:25 <asthasr> in those cases, how do you do a multiple constraint? like, A, B, C answered a certain way lead to G -- answered another way, they lead to H -- and if a given setting is off, C is never asked, and both H and J are asked
20:02:55 <dramforever> hmm...that's more interesting
20:03:17 <dramforever> ok now I'm convinced that your system is better =)
20:03:44 <asthasr> dramforever: :P the problem being, how to encode that.
20:04:01 <asthasr> like I said, I think without types it would actually be quite easy. That... disappoints me.
20:04:47 <dramforever> without types?
20:05:16 <asthasr> i.e. in a dynamic language
20:05:25 <dramforever> what's the difference here?
20:06:00 <asthasr> because, in a dynamic language, I could simply have a map of settings, a map of answers, and my constraints would be duck typed against whatever happens to be in the two
20:06:22 <asthasr> loop until there are no more potential questions for me to ask
20:06:30 <dramforever> asthasr: can you just represent both together?
20:06:40 <ReinH> asthasr: sounds like a sum type?
20:06:45 <dramforever> I mean, a type with both settings and answers
20:07:43 <asthasr> dramforever: I could, but that seems unwise. Settings would be part of the public api and would simply be a map of string to boolean. Something like {"ask continent question" True "ask favorite color question" False}
20:08:02 <asthasr> whereas answers are a lot more complex, being validatable and coming in multiple types (boolean, integer, string, ...)
20:08:18 <dramforever> why not just have two separate types?
20:08:28 <asthasr> in what context?
20:08:58 <dramforever> I don't know, can't you just keep hold of the settings and the answers together?
20:09:04 <dramforever> so you can look up in either
20:10:54 <asthasr> I mean, I could
20:11:23 <asthasr> just get the Settings values and use them as the 'root' of the state
20:11:33 <dramforever> yep
20:11:40 <dramforever> that's it
20:12:06 <asthasr> fair enough -- doesn't capture how to comfortably implement a way to have heterogenous answers and complex constraints, though :(
20:12:24 <asthasr> although I suppose the existential type path I was on earlier would work, just with an unfortunate amount of boilerplate
20:14:43 <bob_twinkles> are the questionaires going to be defined only in haskell code?
20:15:35 <ttt_fff> kadoban++
20:15:43 <ttt_fff> (for the sugestion of the pdfs on wikipedia on linear time unification)
20:16:25 <asthasr> bob_twinkles: I was intending either haskell code or some kind of DSL
20:16:58 <bob_twinkles> well, those are almost the same =P
20:19:16 <asthasr> bob_twinkles: True.
20:24:49 <asthasr> Anyway, it is bedtime here, so if anyone has comments feel free to pm me :)
20:28:30 <arahael> ~'
20:28:33 <arahael> ~;~.
20:28:51 <arahael> Oops.
20:49:34 * hackagebot ghc-imported-from 0.2.0.7 - Find the Haddock documentation for a symbol.  https://hackage.haskell.org/package/ghc-imported-from-0.2.0.7 (CarloHamalainen)
20:49:48 <emanuelz> Does anyone know how to get GHC (7.10) or cabal to directly link a dynamic library against a framework on Mac OS X? For some reason, I've only been able to get it to work with executables.
21:19:36 * hackagebot streaming 0.1.0.4 - A free monad transformer optimized for streaming applications.  https://hackage.haskell.org/package/streaming-0.1.0.4 (MichaelThompson)
21:19:38 * hackagebot drifter 0.2 - Simple schema management for arbitrary databases.  https://hackage.haskell.org/package/drifter-0.2 (MichaelXavier)
21:20:15 <hackrilege> can anyone answer the lazy evaluation question in this paste? http://lpaste.net/138995
21:26:30 <ttt_fff> is there a wya, given two RWST monads, to keep the state moand state the same, but swap the reader monad value
21:26:45 <ttt_fff> i.e. RWST r0 w0 s a and RWST r1 w1 s a
21:30:26 <hackrilege> sorry there was an error in the paste
21:32:12 <saulzar> ttt_fff, There's magnify in lens
21:33:45 <hackrilege> foldr f v0 (CyclicTree v n  _) = f v $ foldr (foldr f v0) v0 n
21:44:40 <deepfire> how does one implement GHC.TypeLits.sameSymbol for promoted data types?
21:45:01 <deepfire> ..an equivalent of it, of course
21:49:38 * hackagebot streaming 0.1.0.5 - A free monad transformer optimized for streaming applications.  https://hackage.haskell.org/package/streaming-0.1.0.5 (MichaelThompson)
22:06:31 <ReinH> hackagebot: no, you can't rely on common subexpression elimination with ghc
22:06:39 <ReinH> er, hackrilege ^
22:07:50 <hackrilege> here is a new post, its a cleaned up version of the last one; http://lpaste.net/138996
22:08:09 <hackrilege> oh ReinH, do you know how i could direct it?
22:08:24 <hackrilege> or implement it...
22:08:30 <ReinH> You can't.
22:08:44 <ReinH> https://wiki.haskell.org/GHC:FAQ#Does_GHC_do_common_subexpression_elimination.3F
22:08:49 <hackrilege> it is not possible my structure?
22:09:05 <ReinH> I'm not sure if it's possible, I'm just talking about CSE.
22:09:32 <ReinH> it may be possible through some other means, although I can't think of one off hand
22:09:47 <hackrilege> if i call the same eveluation twice, CSE mkes quick reference to the first result right?
22:10:36 <hackrilege> and your telling me that this cannot resolve two processes running on the same data
22:10:39 <hackrilege> ?
22:20:33 <ReinH> I'm saying there is no CSE in Haskell
22:21:28 <startling> in GHC, I think
22:21:43 <ReinH> So there is no mechanism whereby the second list would not be evaluated again
22:21:56 <ReinH> startling: I believe it is unsafe with non-strict evaluation in general
22:22:12 <nshepperd_> there is not even a common subexpression in that code...
22:22:29 <ReinH> nshepperd_: Well, also that I suppose...
22:22:45 <startling> ReinH, what do you mean by unsafe?
22:22:48 <arkeet> a minor difficulty.
22:22:59 <ReinH> startling: As expained in the FAQ entry I linked
22:23:09 <ReinH> arkeet: we must not be distracted by such
22:23:12 <nshepperd_> the only way to do this would be to explicitly build a memoization table
22:23:48 <nshepperd_> with some way to distinguish CyclicTree items as "the same", like an integer id
22:24:26 <startling> OK, so it can create space leaks. makes sense.
22:25:47 <hackrilege> does this help? https://wiki.haskell.org/GCD_inlining_strictness_and_CSE
22:27:56 <hackrilege> the point of using a tree was to avoid indexing 
22:32:24 <hackrilege> i suppose i could do away with the second list and just have a CyclicTree also be just an accessor method taking a CyclicTree, but i imagine retrieval would be slow and thats not the idea...
22:32:37 <ReinH> hackrilege: what are you actually trying to do? This may be an XY problem.
22:33:23 <hackrilege> the best i can explain it is that paste
22:33:25 <nshepperd_> hackrilege: the only way to avoid reprocessing a node is to hold a table somewhere of the already-processed nodes, and index into it when you see a new node
22:34:14 <nshepperd_> hackrilege: this of course is not done by ghc, and in haskell would require adding to each node an ID of some kind so there we know where to find it in the table
22:35:39 <ReinH> or making the node hashable
22:38:03 <startling> can you hash cyclic graphs?
22:38:28 <startling> I mean, it seems like that would give you the same problem here.
22:38:33 <nshepperd_> I'm not sure hashing is possible in any sane way on a recursive datatype like this
22:39:03 <startling> I think it's probably possible actually. Maybe not useful.
22:40:00 <ggole> You can, even without checking for cycles: just stop after a given depth
22:40:05 <startling> yeah
22:40:17 <ggole> The hashes may collide more, but they will still be correct
22:41:36 <hackrilege> imagine i am a hydrocarbon, e.g. polymethylene, thats just a linked list of carbons, each also linked to a hydrogen. traversal is easy, i can just step to my neighbour, i can use the links to the hydrogens to access their information in my fold. so i want to have links i traverse along, and ones i dont for the map, but which i want to access to for the mapped function
22:42:20 <hackrilege> have*
22:43:44 <ggole> So you want some kind of identity for each node?
22:45:19 <nshepperd_> well, a hash with collisions is pretty useless actually since you still have to check for equality which is impossible
22:46:20 <startling> I think every useful hash function has collisions.
22:46:24 <ggole> That's a separate problem, surely
22:47:03 <ggole> Of course if you want equality you need some way of doing that (integer tags to represent node identity, or more advanced stuff like structured graphs)
22:47:04 <startling> hackrilege, the easy way is to give a unique id to every node. does that not work for you?
22:47:08 <ttt_fff> geekosaur: by the current standard, is 'wtf' considered a sear word?
22:47:44 <nshepperd_> ggole: yes, you need equality to build a memotable
22:48:57 <orb_> Equality would only give you linear time lookup.  You want at least Ord (or better hash-ability) from your elements.
22:49:15 <orb_> Equality is the bare minimum.
22:50:18 <ggole> Hmm. How would you define Ord for graphs?
22:50:29 <hackrilege> startling, no indexing allowed sorry. really
22:50:33 <nshepperd_> hackrilege: what you are describing is a sparse undirected graph, they are well studied and any book on algorithms will tell you the best representation to use is an adjacency list
22:51:52 <ggole> I suppose a lexicographic comparison where you stop if reaching part of the graph you have visited before would work
22:52:36 <hackrilege> nshepperd_ "best" is often for general application, for my application i must traverse using the laod balancing information present in the connectivity of the graph
22:53:28 <kadoban> hackrilege: Have you written up your actual problem statement somewhere?
22:54:23 <hackrilege> kadoban, i was just tryinng to go off this http://lpaste.net/138996
22:54:42 <hackrilege> i could make an example structure...
22:54:58 <hackrilege> but i think how i would be using it is clear
22:55:05 <nshepperd_> hackrilege: what you want is literally impossible without some form of 'indexing'. memoizing a function requires a memotable
22:55:31 <hackrilege> i understand that
22:55:52 <hackrilege> thanks, it answers the question
22:56:03 <kadoban> hackrilege: Isn't that your attempt to solve your problem, that's not working? I was asking about the original problem itself you're trying to solve.
22:56:42 <hackrilege> build efficient representation of sparse graph
22:57:04 <hackrilege> to be folded over, where local information is required by the fold
22:57:43 <kadoban> hackrilege: Anything more specific? That's pretty vague.
22:57:45 <hackrilege> where the pointers to these local information can be separated from the nodes to be traversed in a map
22:58:07 <hackrilege> thats really it, sorry
22:58:27 <hackrilege> an application example could be useful instead?
22:59:01 <kadoban> That kind of sounds like you already decided on some implementation or representation or something … not really what I'm asking about personally.
22:59:10 <hackrilege> propegate stress along dna
23:01:38 <hackrilege> measure elasticity of a nanotube, which is just the integration of a spring constant radial force between hexagons on a cylinder. 
23:02:07 <hackrilege> points in a hexagonal arrangement*
23:02:54 <hackrilege> we fold over the structure. there is a general sense of the best direction to go so as not to get confused by the heavily cyclic self connectivity
23:03:57 <hackrilege> we must examine elements surrounding this path 
23:04:01 <kadoban> Ah okay, so you have a graph with nodes and edges, and you're doing some kind of traversal over it figuring out forces between when stress is applied I guess?
23:04:35 <hackrilege> at each node we must examine the surrounding nodes to some depth in the style of a stencil for a convolution 
23:04:56 <hackrilege> kadoban; yes
23:05:01 <kadoban> Ah, interesting.
23:05:06 <hackrilege> in this example
23:05:16 <kadoban> How "deep" is the stencil?
23:05:21 <kadoban> Or does it vary?
23:05:30 <hackrilege> should vary
23:05:56 <hackrilege> im happy to index this as it is small
23:07:32 <hackrilege> using fmap f, f:: CyclicTree a -> CyclicTree (Map a) or some such
23:09:07 <hackrilege> and defining fold in terms of Map.fold
23:10:24 <kadoban> I'm … not really seeing what you're trying to do in the code there. Did you try just a basic adjacency list representation and your algorithm using that?
23:11:58 <hackrilege> yes but i didnt do the same example in this style yet, hang on ill dig it out
23:14:48 <hackrilege> http://lpaste.net/138863
23:16:36 <kadoban> Brb and then I'll take a peek. Did you run your algorithm on that though? How did it perform?
23:17:08 <hackrilege> i didnt do that yet, ill write it now
23:18:30 <nshepperd_> sigh
23:18:41 <nshepperd_> hackrilege: normal adjacency lists use arrays, not Data.Map
23:34:44 <hackrilege> data CyclicTree a = CyclicTree (Array (CyclicTree a)) (Array (CyclicTree a)) -- the first Array is the adjacent describing a hamiltonian cycle, the second is adjacents in a proximity sense for use in making a stencil for a subfold 
23:38:29 <hackrilege> this embodies the ability for cyclic regions of a datastructure to be traversed quickly in two different ways, the firstbeing hamiltonian is an efficient path for an fmap recursion, the other being of "all adjacents" (not just the ones in a hamiltonian cycle, stored in the first), which can be traversed in a custom fashion 
23:42:04 <hackrilege_> connection dropped
23:51:32 <hackrilege_> i think it is important to separate the traversal branches from the adjacency branches, into two arrays, so the nodes of the minimal spanning tree (a hamiltonian cycle), which are a subsection of the adjacent nodes, do not have to be extracted in constructing the traversal
