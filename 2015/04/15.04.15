00:10:12 * hackagebot bitcoin-tx 0.11.0 - Utility functions for manipulating bitcoin transactions  http://hackage.haskell.org/package/bitcoin-tx-0.11.0 (solatis)
00:10:12 * hackagebot glasso 0.1.0 - Graphical Lasso algorithm  http://hackage.haskell.org/package/glasso-0.1.0 (kaizhang)
00:20:48 <Gurkenglas> http://comonad.com/reader/ <- h [1,1..] = h [1] <> h [1,1..] means that h [1,1..] is a fixed point of (single 1 <>), but how do we know it is the least fix point?
00:21:45 <Gurkenglas> (...I should probably link to http://comonad.com/reader/2015/free-monoids-in-haskell/ the actual post so future log-readers know what I'm talking about.)
00:25:46 <sgronblo> Hey I was wondering. Is it possible at all in Haskell to define something like merge :: [A] -> [B] -> [A | B] ?
00:26:32 <mauke> [a] -> [b] -> [Either a b]
00:29:02 <sgronblo> yeah I guess thats kind of what i am thinking about
00:29:04 <arkeet> > (\x y -> map Left x ++ map Right y) [1,2,3] ['a','b']
00:29:06 <lambdabot>  [Left 1,Left 2,Left 3,Right 'a',Right 'b']
00:29:09 <arkeet> or something like that.
00:29:23 <arkeet> not going to guess what you want to do with it.
00:29:59 <arkeet> Gurkenglas: well,
00:30:17 <arkeet> there is a theoreM: least fixed point of f is the least upper bound of _|_, f _|_, f (f _|_), f (f (f _|_)), ...
00:32:07 <Gurkenglas> I understand that the least fixed point of (single 1 <>) is bottom, but not why h [1,1..] is the least fixed point of (single 1 <>).
00:32:16 <arkeet> ah.
00:33:23 <arkeet> well say.
00:34:55 <arkeet> hm
00:35:29 <mauke> I can't do it formally, but I can handwave it
00:36:56 <mauke> a strict function f is either const _|_ or it "inspects its argument", meaning that the top-level constructor of the result depends on the top-level constructor of the argument
00:37:18 <mauke> we even know the second case applies to (single 1 <>)
00:37:49 <arkeet> right, so (single 1 <>) _|_ = _|_
00:38:15 <mauke> the equation h [1,1..] = single 1 <> h [1,1..] has the general shape x = f x
00:38:20 <mauke> this is not haskell code
00:38:28 <arkeet> so (let f = (single 1 <>))
00:38:33 <arkeet> f _|_ = _|_, f (f _|_) = _|_, etc.
00:38:43 <arkeet> and what's the least upper bound of _|_, _|_, _|_ ... ?
00:39:03 <arkeet> oh wait that' snot what you were asking.
00:39:04 <mauke> we can substitute x on the right, giving x = f x = f (f x) = f (f (f x)) = ...
00:39:19 <Gurkenglas> Yes I don't know why that keeps being questioned :D
00:39:26 <arkeet> it's late.
00:39:54 <mauke> (if f is const _|_, we immediately get x = _|_, but that's the easy case that doesn't apply)
00:40:10 <arkeet> okay. let's do this different.
00:40:13 <arkeet> differently.
00:40:26 <arkeet> clealry h _|_ = _|_
00:40:29 <arkeet> right?
00:40:39 <Gurkenglas> Yes! How many more times must I accept that ._.
00:40:43 <mauke> arkeet: why?
00:40:49 <Gurkenglas> Oh wait
00:40:49 <arkeet> mauke: because h [] and h [x] differ.
00:40:55 <mauke> we know f's result depends on its argument, but we can always "extend" the argument further
00:40:59 <arkeet> ok listen.
00:41:06 <Gurkenglas> That wasn't the thing I already accepted, fails everywhere :D
00:41:08 <arkeet> now what is h (1 : _|_)
00:41:14 <arkeet> well, that is h [1] <> h _|_
00:41:38 <mauke> i.e. to know the value of x, we have to know f x, for which we have to know f (f x), for which we have to know f (f (f x)), ...
00:41:39 <arkeet> which is _|_, since we just said how (h [1] <>) = (single 1 <>) is strict.
00:41:42 <mauke> ad infinitum
00:41:44 <arkeet> and h _|_ = _|_
00:41:54 <Gurkenglas> (But yes, h ottom = bottom because h [] != h [x])
00:42:01 <arkeet> next, by similar reasoning, h (1 : 1 : _|_) = _|_
00:42:07 <arkeet> and so is h (1 : 1 : 1 : _|_) = _|_
00:42:17 <arkeet> good so far?
00:42:23 <Gurkenglas> Yes
00:42:35 <arkeet> now [1,1..] is the least fixed point of _|_, 1:_|_, 1:1:_|_, ...
00:42:44 <arkeet> and h is continuous, so it preserves least upper bounds.
00:42:49 <arkeet> i.e.
00:42:51 <Gurkenglas> You mean the lowest upper bound
00:42:56 <arkeet> yes sorry.
00:43:12 <arkeet> so h [1,1..] = least upper bound of h _|_, h (1:_|_), h (1:1:_|_), ...
00:43:19 <arkeet> which is _|_, since all the terms on the right are _|_
00:44:29 <arkeet> that's not the only way to see that h can't exist though.
00:44:41 <arkeet> consider that [1,1..] <> [1] = [1,1..] <> [2]
00:45:07 <arkeet> but h ([1,1..] <> [1]) has the form _ :> 1, and h ([1,1..] <> [2]) has the form _ :> 2.
00:45:09 <mauke> dammit, my approach is bogus
00:45:18 <Gurkenglas> I haven't heard of continuousness in this context, but I see how all the h (1:1...1:1:_|_) must be lower bounds for h [1,1..]
00:45:19 <arkeet> but h is a function and functions can't do that.
00:45:37 <arkeet> continuous in this case just means preserves least upper bounds.
00:45:56 <arkeet> and all functions you can define are continuous.
00:46:07 <Gurkenglas> Why have the term, then?
00:46:14 <arkeet> because there are functions you can't define.
00:46:44 <arkeet> like I can make a function of sets that says something like f _|_ = 1 and f 1 = 2
00:47:01 <Gurkenglas> Because there are countably many ()-lists and uncountably many ()-list-endofunctions
00:47:11 <Gurkenglas> right?
00:47:35 <arkeet> I'm not talking about cardinality.
00:47:49 <arkeet> there are continuous functions that aren't definable.
00:48:05 <arkeet> like take any non-computable total function from the naturals to itself.
00:48:13 <arkeet> (and extend it to domains by _|_ -> _|_)
00:49:22 <Gurkenglas> <arkeet> consider that [1,1..] <> [1] = [1,1..] <> [2] <- Yes I thought of that one too but hoped to understand his post ^^
00:49:45 <arkeet> right, well I gave an argument that h [1,1..] = _|_
00:50:28 <fumieval> why is Data.Coerce marked as unsafe?
00:51:49 <arkeet> I've wondered that too.
00:52:33 <arkeet> edwardk: do you know? :-)
00:53:11 <edwardk> because it can subvert the expectations of a module writer who wasn't aware of the need for role annotations
00:53:32 <Gurkenglas> What's the "less defined" symbol in IRC?
00:53:35 <arkeet> I guessed it was something along those lines.
00:54:10 <edwardk> i personally think it should be a sort of thing we hold out for a while then flip on once its more of the culture
00:54:10 <arkeet> Gurkenglas: I dunno, I guess you could write ⊑
00:54:33 <arkeet> edwardk: so you mean something along the lines of
00:54:52 <arkeet> if Data.Map didn't have a nominal role on the key parameter you could mess up its invariants. or something.
00:55:21 <edwardk> arkeet: yeah, and an author pre-role annotations who didn't export constructors and the like could be confident they plugged all the abstraction leaks
00:55:26 <Gurkenglas> (I see how for a function f implementable in haskell, x ⊑ y implies f x ⊑ f y, and so upper bounds are preserved, but why least upper bounds too?)
00:55:28 <edwardk> but now those expectations can be violated
00:55:36 <arkeet> right.
00:55:41 <fumieval> I see
00:55:47 <mjrosenb> does djinn know about Functors?
00:56:03 <edwardk> mjrosenb: djinn is remarkably bad with typeclasses.
00:56:13 <mjrosenb> blast
00:56:56 <mjrosenb> ok, I want fmap, but taking two arguments, e.g. expr :: (a->b->c) -> f a -> f b -> f c
00:57:05 <mjrosenb> err, Functor f => that
00:57:26 <EvanR> liftA2 ?
00:57:38 <arkeet> can't do that with Functor.
00:57:51 <arkeet> but I suppose one would want djinn to be able to tell you this.
00:58:21 <mjrosenb> do I need monad for that?
00:58:26 <arkeet> :t liftA2
00:58:27 <EvanR> :t liftA2
00:58:27 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
00:58:28 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
00:58:41 <mjrosenb> ok, that works. (probably)
00:58:55 <mjrosenb> how do I ask lambdabot what module something was defined in?
00:59:16 <mjrosenb> because it is super annoying never knowing what I need to import.
00:59:19 <arkeet> I dunno.
00:59:20 <arkeet> but you can use hoogle.
00:59:44 <mjrosenb> @hoogle liftA2
00:59:47 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
01:01:10 <mjrosenb> oh great, I actually need liftA4
01:01:15 <mjrosenb> and that isn't defined
01:01:18 <mjrosenb> :t liftA4
01:01:19 <lambdabot>     Not in scope: ‘liftA4’
01:01:19 <lambdabot>     Perhaps you meant one of these:
01:01:19 <lambdabot>       ‘liftA’ (imported from Control.Applicative),
01:01:32 <arkeet> @src liftA2
01:01:32 <lambdabot> liftA2 f a b = f <$> a <*> b
01:01:35 <arkeet> @src liftA3
01:01:35 <lambdabot> Source not found. My pet ferret can type better than you!
01:01:37 <arkeet> oh.
01:01:38 <arkeet> well, generalize.
01:01:45 <EvanR> i thought there was a liftA4
01:01:46 <arkeet> liftA4 f a b c d = f <$> a <*> b <*> c <*> d
01:01:50 <arkeet> nah it only goes to 3.
01:02:06 <arkeet> mjrosenb: maybe you can just use the <$> <*> stuff.
01:02:09 <jle`> yeah someone was going to write liftA4 but they got distracted
01:02:17 <jle`> and then maybe went to dinner and forgot about it
01:03:03 <jle`> they had one job, too.
01:03:14 <jle`> they should have gotten the person who they put in charge of writing `zipWithX` on that.
01:03:23 <jle`> that person was a trooper.
01:03:50 <gfixler> was that the same person that made the tuples?
01:03:58 <EvanR> i think there was a theoretical limit to 3 at the time
01:04:34 <gfixler> Scala functions are limited to 22 parameters
01:05:05 <jle`> with currying you can have unlimited :o
01:05:12 <jle`> thank you haskell curry.
01:05:15 <gfixler> mmm, unlimited curry
01:05:30 <EvanR> why is scala not curried >_< java?
01:05:51 <jle`> maybe, but it could also be a design choice.  most ocaml functions are traditionally written uncurried
01:06:00 <gfixler> it's explicitly curried
01:06:10 <EvanR> by taking a tuple?
01:06:19 <gfixler> by making helper functions
01:06:28 <gfixler> just like in Python
01:06:52 <EvanR> huh
01:07:08 <gfixler> in other words, not
01:10:08 <ChristianS> EvanR: this link says that scala supports currying: http://docs.scala-lang.org/tutorials/tour/currying.html (though apparently you have to use a special cumbersome syntax)
01:25:10 * hackagebot hLLVM 0.5.0.0 - A library for processing LLVM assembly codes  http://hackage.haskell.org/package/hLLVM-0.5.0.0 (NingWang)
01:35:10 * hackagebot interpolation 0.1 - piecewise linear and cubic Hermite interpolation  http://hackage.haskell.org/package/interpolation-0.1 (HenningThielemann)
01:45:11 * hackagebot hLLVM 0.5.0.1 - A library for analyzing and transforming LLVM (3.5) assembly codes  http://hackage.haskell.org/package/hLLVM-0.5.0.1 (NingWang)
01:49:43 <basiq> I'm getting unexpected NaN and Infinity results from (*)'ing Doubles
01:49:58 <basiq> Is it possible that I installed the wrong version of the Haskell Platform?
01:53:24 <Sizur> Hi all!
01:54:26 <Sizur> Is there an "anti-maybe" monad, where only the first success is propagated?
01:54:51 <jle`> basiq: can you reproduce in a minimal example?
01:54:59 <jle`> Sizur: it wouldn't really make sense to have it be a Monad, but you can use (<|>)
01:55:22 <echo-area> Is it common that given some type constrains and a function left hand side, one can define the function, but make sense of the definition later on?
01:55:30 <jle`> > Just 1 <|> Just 10 <|> Nothing
01:55:31 <lambdabot>  Just 1
01:55:33 <tdammers> Sizur: Alternative
01:55:55 <tdammers> :t (<|>)
01:55:56 <lambdabot> Alternative f => f a -> f a -> f a
01:55:56 <Sizur> hmm, i thought it's fitting the monad structure
01:56:34 <tdammers> almost, but not quite
01:56:49 <absence> is there a library function or monoid or something that returns "Just element" if all elements in a list/traversable are equal, and Nothing otherwise?
01:58:02 <absence> that should probably be foldable rather than traversable
01:58:52 <shachaf> i,i teaspoon . the
01:59:44 <jle`> Sizur: the problem is that once you get to a Nothing, everything has to stop.  so you can't do something like Nothing <|> Just 3 ==> Just 3
02:00:12 <jle`> you can't have a `Nothing >>= ...` that produces anything other than a Nothing
02:01:50 <Sizur> jle`: right, i need the opposite of that. and Alternative seems best suited, except i need a bind operation to evaluate functions, so maybe MonadPlus?
02:02:48 <Sizur> eh, brain's not working.  maybe need to go sleep
02:02:54 <jle`> luckily Maybe is both Alternative and a Monad.
02:03:37 <Sizur> so i need to pass the same arguments to a bunch of functions and get the first success
02:04:20 <Sizur> of course can be done without the higher abstractions, but would be neat if there is one.
02:04:57 <jle`> sounds like you can sequence and asum
02:05:09 <Sizur> asum?
02:05:15 <jle`> > asum . sequence [const Nothing, Just] $ 5
02:05:16 <lambdabot>      Not in scope: ‘asum’
02:05:16 <lambdabot>      Perhaps you meant one of these:
02:05:16 <lambdabot>        ‘F.asum’ (imported from Data.Foldable),
02:05:27 <basiq> jle`: http://lpaste.net/130749 not so minimal but I used my own hacky Data.Map functionality, because I thought Data.Map might be the problem
02:05:32 <jle`> asum [x,y,z] = x <|> y <|> z <|> empty
02:06:03 <mjrosenb> with Linear, and V2, is there a way to extract a single element from it?
02:06:21 <jle`> you can use view
02:06:22 <basiq> in calcUpdate if I multiply a result of findRanking, it goes NaN for a lot of values
02:06:46 <jle`> basiq: if you calculate some of these things by hand do you still get really large/big numbers?
02:07:26 <jle`> view _y (V2 1 2) ==> 2
02:07:36 <basiq> not that big
02:07:56 <basiq> nothing shocking, it does the same if I do ** 0.02
02:07:59 <basiq> or similar
02:08:01 <jle`> mjrosenb: you already have a lens dependency because linear requires lens, so you can use lens :)
02:08:16 <basiq> ie the values are pretty tiny
02:08:21 <jle`> hm
02:08:50 <basiq> where 1 calculation is made, the values are correct
02:09:18 <basiq> where 1 calculation is made, and where r1 is 0
02:09:41 <mjrosenb> ahh, I need a view in there
02:09:46 <mjrosenb> I found _x and _y
02:09:52 <mjrosenb> and did not understand them at all.
02:09:55 <basiq> I have no idea what could be going wrong
02:10:08 <jle`> mjrosenb: for these purposes you can just imagine they give you getters/setters
02:10:12 * hackagebot list-t 0.4.4 - ListT done right  http://hackage.haskell.org/package/list-t-0.4.4 (NikitaVolkov)
02:10:12 <jle`> or modifiers
02:10:34 <jle`> over (+3) _x (V2 1 2) ==> V2 4 2
02:10:37 <mjrosenb> jle`: wfm.  Is there something similar for P?
02:10:45 <mjrosenb> :t over
02:10:46 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
02:10:58 <mjrosenb> profunctor?
02:11:12 <jle`> you can think of _x and _y "encoding" getters and setters and modifiers, and over and view unlocking them for you to use it
02:11:26 <jle`> don't mind the type signature...it's a little...over-general
02:11:27 <jle`> heh
02:11:44 <jle`> over _x :: (a -> a) -> V2 a -> V2 a
02:12:03 <jle`> in this case the profunctor p is (->)
02:13:20 <jle`> set _x 10 (V2 1 2) ==> V2 10 2, etc.
02:14:03 <jle`> you really can write over and set yourself, if you wanted to
02:14:09 <jle`> without anything too fancy
02:14:18 <merijn> mjrosenb: My favourite explanation of profunctors is the following
02:14:54 <merijn> mjrosenb: A functor "f a" can be seen as a "producer" of a's and you can use "fmap :: (a -> b) -> f a -> f b" to turn a producer of a's into a producer of b's
02:14:58 <basiq> jle` the result is a nice mix of NaN, Infinity, -Infinity, and Doubles
02:15:31 <merijn> mjrosenb: Contravariant functor "f a" can be seen as a "consumer" of a's and you can use "contramap :: (b -> a) -> f a -> f b" to turn a consumer of a's into a consumer of b's
02:16:36 <mjrosenb> merijn: with you so far.
02:16:44 <merijn> mjrosenb: Then a profunctor "p a b" is a pipe with "lmap :: (b -> a) -> p a c -> p b c" that turns a pipe from a's to c's into a pipe of b's to c's
02:17:12 <merijn> mjrosenb: And "rmap :: (c -> d) -> p a c -> p a d" that turns a pipe from a's to c's into a pipe of a's to d's
02:17:18 <jle`> mjrosenb: _x acts like a "mapM" of sorts.  mapM Just [1,2,3] => Just [1,2,3].  _x Just (V2 1 2) => Just (V2 1 2).  _x is like a mapM/traverse, but it only "sees" the first element.  whereas if you mapM f [1,2,3], your f is applied to all 1, 2, and 3.  if you _x f, your f is only applied to the first element.
02:18:21 <jle`> you can think of `over` and `view` as passing in just the right `f` to work to do things like mapping functions and getting out values.
02:18:34 <jle`> or...you can just use over and view today and put off thinking about how they work til later, heh
02:20:18 <merijn> mjrosenb: To wrap back to the type of "over", since 'p a b' is a pipe/transformation from a's to b's and 's' is a type that has an 'a' somewhere in it and 't' is a type that has a 'b' somewhere in it
02:20:30 <merijn> So you're transforming the 'a' inside 's' into a 'b' inside 't'
02:20:57 <merijn> And the "Setting p s t a b" just determines which 'a' inside 's' and which 'b' inside 't'
02:24:51 <merijn> mjrosenb: Still following? :)
02:25:59 <basiq> any ideas on the NaN stuff?
02:26:03 <mjrosenb> more or less...
02:26:54 <merijn> mjrosenb: Actually, to make it even clearer we could specialise the profunctor to (->) (which is obviously a profunctor and fill in: "_1 :: Setting (->) (a, c) (b, c) a b"
02:28:07 <merijn> mjrosenb: Which then means that using "isDigit :: Char -> Bool" as the p a b gives us: "over :: Setting (->) (Char, x) (Bool, x) Char Bool -> (Char -> Bool) -> (Char, x) -> (Bool, x)"
02:29:33 <merijn> basiq: NaN usually means you have a division by zero somewhere
02:29:49 <merijn> Actually, wait, that would be infinity, I think
02:29:58 <merijn> > (1/0) :: Double
02:29:59 <lambdabot>  Infinity
02:30:03 <merijn> > (-1/0) :: Double
02:30:05 <lambdabot>  -Infinity
02:30:08 <merijn> > (0/0) :: Double
02:30:10 <lambdabot>  NaN
02:30:24 <merijn> basiq: Sounds like your symptoms :p
02:38:19 <exio4> it can be Infinity * 0, Infinity - Infinity, ...
02:50:00 <basiq> merijn
02:50:13 <basiq> NaN results from * in my case
02:50:14 * hackagebot getopt-generics 0.4 - Simple command line argument parsing  http://hackage.haskell.org/package/getopt-generics-0.4 (SoenkeHahn)
02:50:37 <merijn> > (1/0) * (1/0) :: Double
02:50:38 <lambdabot>  Infinity
02:50:44 <merijn> > (1/0) * (-1/0) :: Double
02:50:45 <lambdabot>  -Infinity
02:51:16 <exio4> > 0 * (1/0) 
02:51:17 <lambdabot>  NaN
02:51:21 <merijn> basiq: The only way to get NaN from * afaik is when one of the two is already NaN or maybe an overflow
02:51:26 <exio4> > (1/0) - (1/0)
02:51:28 <lambdabot>  NaN
02:51:42 <merijn> I guess multiplication of 0 and Infinity also works
02:51:45 <basiq> I don't do (/) anywhere afaik, see example: http://lpaste.net/130749
02:51:50 <merijn> Which would support the "overflow" theory
02:51:51 <basiq> hmmm
02:52:05 <merijn> Why Float and not Double?
02:52:18 <merijn> What happens if you switch to Double?
02:52:24 <basiq> originally it was Double
02:52:41 <basiq> same result
02:52:58 <merijn> > 0 ** 0.2
02:53:00 <lambdabot>  0.0
02:53:04 <merijn> > 0 ** 0.2 :: Double
02:53:05 <lambdabot>  0.0
02:53:21 <merijn> :t isNan
02:53:22 <lambdabot>     Not in scope: ‘isNan’
02:53:22 <lambdabot>     Perhaps you meant ‘isNaN’ (imported from Prelude)
02:53:25 <merijn> :t isNaN
02:53:26 <lambdabot> RealFloat a => a -> Bool
02:53:39 <merijn> basiq: Try and see in your parser whether any value returned is NaN?
02:54:27 <basiq> merijn, there isn't 
02:55:15 <basiq> -- > ranking . take 1 <$> db
02:55:26 <basiq> gives values 1000, Infinity
02:56:15 <basiq> -- > ranking . take 2 <$> db
02:56:20 <basiq> gives values 1000, NaN
02:57:13 <basiq> take 2 gives 2 different Games between the same teams in this case
02:58:04 <merijn> Ho
02:58:08 <merijn> hmm
02:58:32 <basiq> I can give someone the relevant modules if that helps
02:59:21 <merijn> I'm going for lunch now, but maybe someone else can have a look
02:59:21 <basiq> also fyi I tried initially to use Data.Map instead of the crappy Stat Double
02:59:27 <basiq> but same
02:59:55 <basiq> alright, enjoy your lunch
03:00:14 * hackagebot reasonable-lens 0.2.1.1 - Lens implementation. It is more small but adequately.  http://hackage.haskell.org/package/reasonable-lens-0.2.1.1 (outoftune)
03:03:13 <nshepperd_> basiq: maybe use Data.Trace and check things for NaN/infiniteness to find the first bad value
03:03:50 <nshepperd_> or even error, I guess
03:04:04 <nshepperd_> check foo bar = if isNaN bar || isInfinite bar then error (show foo) else bar
03:04:20 <nshepperd_> then sprinkle checks throughout the code :D
03:04:25 <basiq> hehe okay
03:04:34 <basiq> thanks for the tip =]
03:07:34 <nshepperd_> hey, maybe we should have a ThrowingFloat type or something, that throw an exception on non-real values
03:08:05 <basiq> that would be wonderful in this case ;p
03:19:14 <solatis> if I have the following instance declaration:
03:19:16 <solatis> instance FromJSON (RpcResult a) where
03:19:42 <solatis> how can I add (FromJSON a) to the instance declaration?
03:19:55 <solatis> as in, `a` should always have a FromJSON instance
03:20:14 <solatis> i tried doing that using instance FromJSON (RpcResult a) => (FromJSON a) where ..
03:20:37 <solatis> but that needs FlexibleInstances and FlexibleContexts and UndecidableContexts which all sounded way too much like I was doing it wrong
03:21:18 <jle`> do you mean instance FromJsSON a => FromJSON (RpcResult a) where ...?
03:21:36 <jle`> it works the same as for normal type signatures, the thing before the => is the constraints
03:21:53 <jle`> so that means FromJSON (RpcResult a), where a is constrained to be a FromJSON
03:22:21 <solatis> oh geez I got it mixed up
03:22:52 <solatis> what I had:
03:22:52 <solatis> instance FromJSON (RpcResult a) => FromJSON a where
03:23:00 <solatis> what I needed: 
03:23:00 <solatis> instance FromJSON a => FromJSON (RpcResult a) where
03:23:11 <jle`> yup
03:23:16 <solatis> that seems to do the trick
03:35:28 <mjrosenb> ... does SDL2 actually use CInt in some places, and Int32 in other places?
03:46:35 <Polarina> mjrosenb, in the new-api version? That's possible.
04:23:58 <jophish> Has anyone ever thought about how `a && b` is not always the same as `b && a`
04:24:10 <jophish> for example when a = False and b = undefined
04:24:37 <hpc> (&&) is one of those "pretend bottom doesn't exist" functions
04:24:53 <jophish> yeah, seems that way
04:25:05 <hpc> there's a lot of them
04:27:31 <pavonia> What other examples are there (besides (||))?
04:27:55 <hpc> pretty much anything that actually does something
04:28:08 <hpc> IO, stuff like blaze, parsec
04:29:29 <pavonia> Why IO?
04:29:59 <hpc> how often do you do readFile undefined?
04:30:39 <pavonia> Never, I guess
04:42:42 <jellie> Hey can anyone refer me to a place where I can read on "infixr" and "infixl" ?
04:42:59 <amaru> heyo: Does hlint work with type operators and typelits?
04:47:06 <amaru> I get a hlint parse error on something like (KnownNat m, KnownNat n) => ... (m * n) ..., which parses and compiles fine with ghc. 
04:53:29 <mniip> amaru, maybe hlint can't into TypeOperators?
04:57:22 <mpickering> amaru: The problem is that HLint relies on haskell-src-exts which doesn't parse type operators
04:57:25 <mpickering> or a bunch of other things
04:59:45 <amaru> ah. ok. 
05:00:12 <amaru> Is there some way to get around it?
05:01:03 <mpickering> no
05:01:39 <mpickering> unless you want to patch haskell-src-exts or rewrite HLint's backend to use the ghc parser 
05:04:05 <amaru> I see. Thanks for the quick reply! :)
05:04:50 <merijn> jellie: The haskell report, but there's not a lot to read
05:05:26 <merijn> jellie: the optional l/r ending specifies right vs left associativity and the number specifies the precedence (0 is lowest, 9 is highest, 10 is prefix function application and 11 is record syntax)
05:05:38 <merijn> jellie: There, now you know all about fixity :p
05:05:52 <jellie> merijn: I found what I needed from RWH however, I have a few things that are still unclear
05:06:00 <merijn> jellie: Such as?
05:06:14 <jellie> merijn: WHat happens when a infixl and infixr are used in the same expression?
05:06:32 <merijn> jellie: The compiler yells at you unless the precedence is different
05:06:57 <merijn> i.e. mixing infixl/infixr of different precedence is no issue, because precedence decides how it binds
05:07:00 <jellie> See this:
05:07:08 <merijn> Mixing l/r of the same precedence fails with an error
05:07:12 <jellie> > 8 * 8 ^ 2
05:07:13 <lambdabot>  512
05:07:29 <jellie> There. ^ is infixr and * is infixl
05:07:39 <merijn> jellie: The associativty isn't relevant here
05:07:47 <merijn> jellie: Because those have different precedences
05:08:02 <merijn> ^ has precedence 8 and thus binds tighter than + which has precedence 6
05:08:24 <merijn> jellie: Associativity is only necessary for deciding how to group operatos of the SAME precedence
05:08:48 <merijn> i.e. is "8 + 8 + 8" equal to "(8 + 8) + 8" or "8 + (8 + 8)"
05:09:05 <merijn> Operators of different precedences are grouped by precedence
05:09:18 <jellie> merijn: hmm do you know any two with the same precedence that we can play with. l and r ?
05:09:57 <jellie> merijn: It's these tiny details that have me confused.
05:10:17 <merijn> > let (&) = (*); infixr 6 & in 2 + 3 & 4
05:10:18 <lambdabot>      Precedence parsing error
05:10:19 <lambdabot>          cannot mix ‘+’ [infixl 6] and ‘&’ [infixr 6] in the same infix expre...
05:10:50 <merijn> Like I said, if they're the same precedence you can't mix and the compiler will yell at you
05:10:54 <merijn> > let (&) = (*); infixr 6 & in 2 + (3 & 4)
05:10:56 <lambdabot>  14
05:11:04 <merijn> > let (&) = (*); infixr 6 & in (2 + 3) & 4
05:11:06 <lambdabot>  20
05:11:11 <lush> yo
05:11:19 <lush> geekosaur: hi) ^^
05:12:56 <jellie> merijn: I see
05:13:02 <jellie> merijn: thankee
05:14:07 <freusque> Hello
05:14:24 <jellie> freusque: Hello
05:14:30 <freusque> I am trying to use the Foldl and  Conduits libraries together
05:14:46 <freusque> Conduits-Extra used to provide a converter
05:14:56 <freusque> but not any more in the latest versions
05:15:07 <freusque> Does anyone have an idea on the best apprroach?
05:15:14 <freusque> approach*
05:16:45 <freusque> this is motivated by the fact that I can't seem to get my Conduit.List.fold based  approach work
05:17:11 <freusque> I observe linearly increasing memory usage.
05:19:33 <freusque> code is there : http://pastebin.com/ZpTccpEG
05:19:56 <freusque> I'm trying to get a histogram from some huge flat file
05:20:17 <freusque> (not using mutable histogram because of my beginner level)
05:21:53 <freusque> here is cleaner code: http://pastebin.com/RpYreKHu
05:26:55 <guiraldelli> Hello everybody! I have a possibly stupid and newbie question but whathever. The point is: I have a data structure (a map, for instance) that is used for a series of (almost all) functions in my module. However, I think it is very ugly (unsophisticated) to pass this data structure as an argument for every function. In a OOP program, it would be a member of my class and "buenas", but in a immutable FP environment, it doesn't look like to be an option. 
05:26:56 <guiraldelli> Is there a better way of doing it?
05:28:17 <ion> guiraldelli: You could use http://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader.html
05:29:57 <guiraldelli> ion: I was afraid to get this answer since I have seen the Reader monad somewhere. Sorry for the silly question, but isn't it the same thing as passing the argument all the time?
05:30:28 <ion> It’s effectively the same but makes it implicit.
05:30:49 <bennofs> guiraldelli: do you have some functions right now that just take the datastructure so that they can pass it to other functions?
05:31:18 <bennofs> guiraldelli: using the Reader monad, those functions would become simple since the passing to the "sub" functions happens automatically
05:33:22 <AshyIsMe> ah sweet fpcomplete news
05:33:34 <AshyIsMe> those guys sound like a sweet company to work for
05:34:08 <guiraldelli> bennofs: I haven't understood clearly your question but I will try to answer you: I have a "generate", the unique exposed function of the module, that dynamically creates the map and pass it to almost every other function of the module.
05:35:17 <bennofs> guiraldelli: I meant, do all your functions actually need data from the map? Or are some of the functions just taking the map as an argument so that they can call other helper functions that operate on the map?
05:35:30 <guiraldelli> ion, bennofs: I will study better the Reader monad so I will see how it may improve my code.
05:37:57 <guiraldelli> bennofs: there are some functions (let's name then A) that receive the map as an argument because they use another function (which we may call B) that need its.
05:38:28 <bennofs> guiraldelli: yes, those functions will get simple with the reader monad since the reader monad will take care of passing the map to the B function
05:38:34 <bennofs> s/simple/simpler
05:39:18 <KaneTW> @unmtl ReaderT r Identity a
05:39:18 <lambdabot> r -> a
05:39:41 <guiraldelli> bennofs: Great! Thank you for your help! Now it is time to study the Control.Monad.Reader! :D
05:40:44 <guiraldelli> It is always a pleasure to post question here. Thank you all for your patience, didactic and wish to help! You are great! :)
05:41:15 <KaneTW> this channel is really an impressive anomaly
05:57:01 <lush> geekosaur: are you here?
06:00:22 * hackagebot STL 0.3.0.1 - STL 3D geometry format parsing and pretty-printing  http://hackage.haskell.org/package/STL-0.3.0.1 (bergey)
06:13:22 <__ryan> hi can i ask yesod here?
06:13:53 <KaneTW> yes, but #yesod will probably be more helpful
06:14:43 <__ryan> #yesod is not very active :)
06:18:38 <lush> may somebody check that piece of code? http://susepaste.org/63774441
06:19:05 <lush> I know that my "protocol" is pretty bad and unflexible, it's just for testing purposes
06:20:33 <lush> If I try to connect with my client the server says: "Chat.hs: <socket: 9>: hGetChar: end of file"
06:20:50 <lush> while the Client just stops executing without any messages
06:21:12 <lush> (forgot to add CMD, MSG to export in Protocol.hs)
06:25:23 * hackagebot jsonschema-gen 0.1.0.0 - JSON Schema generator from Algebraic data type  http://hackage.haskell.org/package/jsonschema-gen-0.1.0.0 (yuga)
06:26:37 <__ryan> hello what this means - Found hole _blah with type: Key News
06:26:55 <__ryan> the error occur here - updateWhere [NewsId ==. _blah]
06:28:28 <merijn> __ryan: It means that _blah is not in scope
06:29:04 <merijn> __ryan: Identifiers that start with _ AND that are not in scope are "typed holes" which results in GHC dumping out their type for you (so you can use it to easily figure out which type goes in a certain place)
06:29:44 <__ryan> merijn: so it says that i need a key of news right?
06:30:17 <__ryan> merijn: if i try this - updateWhere [NewsId ==. 1 ] - the error is - No instance for (Num (Key News)) arising from the literal 1 …
06:30:21 <lpaste> jerbome pasted “ReciprocalCycle” at http://lpaste.net/130753
06:30:41 <jerbome> hi folks, not sure it's the right channel to ask so let me know
06:30:44 <merijn> __ryan: "Key News" is not a Num instance, so you can't use '1' as a key
06:31:08 <__ryan> how do i do that?
06:31:11 <merijn> jerbome: Needs more guards and where clauses instead of if/then/else to be readable
06:31:14 <jerbome> I'm trying to do the euler problem 26, and I'm trying to implement the floyd algorithm of cycle detection in haskell
06:31:20 <merijn> __ryan: No clue, I don't know whichever library this is
06:33:38 <lpaste> jerbome revised “ReciprocalCycle”: “ReciprocalCycle” at http://lpaste.net/130753
06:34:08 <jerbome> so I(m trying to implement floyd algo (http://en.wikipedia.org/wiki/Cycle_detection) in haskell
06:34:35 <jerbome> but I think I got something wrong, my floyd function hangs for the list of decimal of 1/29 for example
06:36:27 <lpaste> jerbome revised “ReciprocalCycle”: “No title” at http://lpaste.net/130753
06:36:45 <jerbome> I'd appreciate any help on that matter
06:36:50 <smoores> why doesn't ['a'..'z'] :: (Char t, Enum t) => [t]  when [1..10] :: (Num t, Enum t) => [t]
06:36:54 <lpaste> merijn annotated “ReciprocalCycle” with “ReciprocalCycle (cleaned up)” at http://lpaste.net/130753#a130756
06:37:22 <merijn> smoores: Char is not a class, it's a concrete type
06:37:37 <merijn> smoores: And GHC already *knows* Char is an instance of Enum, so the constraint is redundant
06:38:35 <smoores> that makes sense, thanks
06:38:36 <merijn> jerbome: "flip decimal 1" <- this doesn't seem right?
06:39:01 <merijn> > 1 `divMod` 10
06:39:03 <lambdabot>  (0,1)
06:39:07 <jerbome> merijn, I think it's ok, it returns a list of the decimal of (1/n)
06:39:21 <merijn> jerbome: Eh, no
06:39:52 <merijn> or, hmm
06:40:07 <jerbome> tested my function against wolfram alpha, works pretty well
06:40:13 <merijn> > 1 `divMod` 5
06:40:15 <lambdabot>  (0,1)
06:40:34 <merijn> ah, now I see
06:41:09 <jerbome> my guess is that wikipedia got the puthon implementation of floyd wrong, but I'm usually wrong when I think wikipedia is wrong
06:41:17 <jerbome> s/puthon/python
06:41:30 <ski> @messages-loud
06:41:30 <lambdabot> athan said 23h 42s ago: Thank you :) You the maaaaaaaan!!!! (please emphasise the awesome)
06:41:46 <ski> mhm ..
06:41:58 <merijn> jerbome: I expect what you get wrong is the infiniteness of the list?
06:42:37 <merijn> jerbome: You're doing comparisons on the result of decimal, no?
06:42:50 <merijn> (tbh, I can't be arsed to figure out exactly what it's doing)
06:42:53 <jerbome> merijn, thats why it hangs on 29, but it does not explain why floyd (decimalN 1200 !!) is wrong1200 
06:46:04 <jerbome> merijn, the infiniteness of the list is only a side problem actually
06:47:06 <merijn> Anyway, I can't see anything obvious without trying to grok how the algorithm works
06:48:25 <jerbome> merijn, ok, thanks anyway, guess I'm gonna ask on #algorithms
06:52:24 <nyuszika7h> how do I get ctHour from  getClockTime >>= toCalendarTime  ?
07:00:26 <jerbome> oooh I think I got it
07:06:54 <Tiddles> Hello there! Would anyone be able to help me understand how to order a data type? I have a Point x1 y1 and Point x2 y2  and I would like to compare them and return based on the smaller first coordinate if they're not equal, and then the smaller second coordinate if they're not equal, and otherwise return the first if both are equal
07:10:01 <merijn> Tiddles: You mean "how do I make my Point type orderable for existing code like 'sort'?"
07:10:05 <zerokarmaleft> Tiddles: you should be able to simply derive an Ord instance
07:11:04 <Tiddles> I'm not necessarily sorting them, but wanting to determine which one should come first, applying an ordering
07:11:49 <Tiddles> so I could find the "minimum" point
07:12:04 <merijn> Tiddles: You will want to derive (or manually implement) the Eq and Ord typeclasses
07:12:53 <Tiddles> so data Point = Point Int Int deriving Ord, Eq would automatically give me what I want for free?
07:13:01 <merijn> Yes
07:13:07 <Tiddles> wow
07:13:22 <merijn> Tiddles: Well, I think you need to make it "deriving (Ord, Eq)", but yeah
07:13:23 <zerokarmaleft> try it and see :D
07:13:31 <merijn> (i.e. add parens)
07:13:41 <Tiddles> right
07:14:21 <Tiddles> Would that automatically extend to a third coordinate? x y z?
07:14:42 <Tiddles> I guess I could try :P
07:15:24 <merijn> Tiddles: Yes, but deriving always uses lexicographical order, so if you want a different comparison order you'd have to handwrite it
07:18:51 <Tiddles> okay great, that is fantastic
07:19:08 <Tiddles> thank you zerokarmaleft merijn
07:20:26 * hackagebot amazonka-workspaces 0.3.4 - Amazon WorkSpaces SDK.  http://hackage.haskell.org/package/amazonka-workspaces-0.3.4 (BrendanHay)
07:23:17 <ocramz> howdy haskells
07:35:27 * hackagebot wuss 1.0.0 - Secure WebSocket (WSS) clients  http://hackage.haskell.org/package/wuss-1.0.0 (fozworth)
07:55:33 <igniting> is there a method to generate permutations of a given size, similar to itertools.permutations in python?
07:56:54 <tromp> @hoogle permutations
07:56:57 <lambdabot> Data.List permutations :: [a] -> [[a]]
07:56:57 <lambdabot> package action-permutations
07:57:21 <tromp> > permutations [1..3]
07:57:22 <lambdabot>  [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
07:57:53 <igniting> @hoogle [a] -> Int -> [[a]]
07:57:53 <lambdabot> Prelude drop :: Int -> [a] -> [a]
07:57:53 <lambdabot> Data.List drop :: Int -> [a] -> [a]
07:57:53 <lambdabot> Prelude take :: Int -> [a] -> [a]
07:58:07 <tromp> you mean combinations?
07:58:24 <tromp> @hoogle combinations
07:58:25 <lambdabot> No results found
07:58:37 <ski> > replicateM 2 "abc"
07:58:38 <lambdabot>  ["aa","ab","ac","ba","bb","bc","ca","cb","cc"]
07:59:09 <tromp> do you want duplicates?
07:59:17 <igniting> no
07:59:31 <igniting> https://docs.python.org/2/library/itertools.html#itertools.permutations
08:02:45 <tromp> @let pick [] = []; pick (x:xs) = (x,xs) : map (second (x:)) (pick xs)
08:02:47 <lambdabot>  Defined.
08:03:08 <tromp> @let combinations n = evalStateT . replicateM  n . StateT $ pick
08:03:10 <lambdabot>  Defined.
08:03:30 <tromp> > combinations 2 "abcd"
08:03:32 <lambdabot>  ["ab","ac","ad","ba","bc","bd","ca","cb","cd","da","db","dc"]
08:08:11 <ski> > let n = 2; xs = "abcd" in [[x,y] | x:ys <- tails xs,y <- ys]  -- if case you don't want the same elements, but in another order
08:08:12 <lambdabot>  ["ab","ac","ad","bc","bd","cd"]
08:08:51 <ski> igniting : see ^ and what tromp said
08:09:07 <igniting> ski: P(4, 2) = 12
08:09:29 <igniting> I'm trying to understand what tromp did
08:09:31 * ski always mixes up what this sense of "permutations" means
08:09:43 <ski> > pick "abcd"
08:09:45 <lambdabot>  [('a',"bcd"),('b',"acd"),('c',"abd"),('d',"abc")]
08:10:11 <ski> `pick' "lifts out" one element of the list, and also gives you the rest of the list
08:10:27 <ski> it gives you a list of all possible ways of doing that
08:10:28 * hackagebot haxl 0.2.0.0 - A Haskell library for efficient, concurrent,  and concise data access.  http://hackage.haskell.org/package/haxl-0.2.0.0 (SimonMarlow)
08:11:33 <ski> tromp used the `StateT [a] []' monad, which is (remaining elements) list state over (list) nondeterminism (for multiple possible results)
08:11:36 <igniting> replicateM n [1..m] is O(m^n) ?
08:12:38 <ski> yes
08:13:12 <ski> (it gives a list of `m^n' elements)
08:19:23 <guiraldelli> Guys, one more question. I have a data type "data V = V String | E" in the module M1 and I want a data type "data K = V | X | Y" in the module M2. GHC is complaining that I have an ambiguous definition of V (M1 vs. M2). How could I create a data type K in the way I want?
08:20:23 <ski> guiraldelli : `V' in `data K = V | X | Y' is completely unrelated to the two `V's in `data V = V String | E' (and those two `V's are also different things)
08:21:16 <ski> guiraldelli : if you meant for the two data constructors `V' in your two data types to be distinct, then possibly you just want to import the two modules qualified ?
08:21:52 <guiraldelli> ski: I want the V (in module M2) to point to V (in module M1).
08:24:07 <geekosaur> guiraldelli, you seem to be making a common mistake
08:24:15 <geekosaur> your K should look like your V
08:24:41 <geekosaur> compare: data Maybe a = Nothing | Just a
08:25:16 <geekosaur> your data K is a simple enumeration type, not a thing that can contain a V-type or an X-type or a Y-type
08:25:48 <geekosaur> perhaps you want something more like: data K = KV V | KX X | KY Y
08:27:18 <guiraldelli> geeksosaur: Without knowing me you've gotten my frequent mistake: different between types and type constructor.
08:27:29 <ski> guiraldelli : data constructors are not types. `V' in `data K = V | X | Y' has nothing to do with `data V = V String | E'
08:27:31 <guiraldelli> s/different/difference/
08:27:57 <ski> (all type constructors are types. not all types are type constructors)
08:28:01 <geekosaur> confusion begtween type and data constructors seems to be a daily thing around here
08:28:46 <ski> this is one reason why i usually use the `data Foo = MkFoo ...' idiom, when i'm inventing some example, in here
08:29:14 <ski> (unless i can make up some more appropriate name for the data constructor, i.e.)
08:29:55 <guiraldelli> ski, geeksosaur: So let us see if I got it correct. I must create data constructors for my K and things are solved. Is it?
08:30:17 <geekosaur> they need distinct data constructors, yes
08:30:18 <ski> guiraldelli : i'm not sure what you're trying to do, so i can't tell
08:30:29 * hackagebot logic-classes 1.5.2 - Framework for propositional and first order logic, theorem proving  http://hackage.haskell.org/package/logic-classes-1.5.2 (DavidFox)
08:30:31 * hackagebot fast-tags 1.1.0 - Fast incremental vi and emacs tags.  http://hackage.haskell.org/package/fast-tags-1.1.0 (EvanLaforge)
08:30:32 <geekosaur> otherwise it can't tell if a random V is intended to be of type V or type K
08:31:09 <geekosaur> so a V stored in a K is marked with a distinct constructor (e.g. KV) and to mnake a value of type K containing some value v of type V you would say (KV v)
08:31:16 <ski> (you could use `M1.V' and `M2.V' to distinguish between the two data constructors)
08:32:32 <guiraldelli> Thank you, guys! Once again you've saved my project! :D
08:34:50 <ski> guiraldelli : whether to name then differently (like `KV' and maybe `VV') or to use module quanlification (`M1.V' and `M2.V') depends on taste, style, and the particular case ..
08:35:50 <guiraldelli> ski: I like your suggestion of KV.
08:36:43 <jellie> Hey isn't  the use of #if called conditional compilation? I can't find it under: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/index.html
08:36:46 <MichielDC> How good is Richard Bird's "Introduction to Functional Programming Using Haskell" for learning?
08:36:55 <jellie> I could've sworn it was here
08:40:29 * hackagebot mime 0.4.0.2 - Working with MIME types.  http://hackage.haskell.org/package/mime-0.4.0.2 (IavorDiatchki)
08:45:30 * hackagebot infernu 0.0.0.0 - Type inference and checker for JavaScript (experimental)  http://hackage.haskell.org/package/infernu-0.0.0.0 (NoamLewis)
08:46:10 <ggVGc> not really haskell-related, but I am making a functional superset of javascript and am trying to come up with a good operator/syntax for currying. Any suggestions?
08:49:49 <jellie> ggVGc: A syntax for currying? But doesn't currying just happen automatically when I don't give a function all it's arguments?
08:50:05 <ClaudiusMaximus> ggVGc: when i did something like that i just defined a curry function, and wrote my functions uncurried - but that wasn't a new language, just javascript - and i only did curry/curry3, didn't need any higher - if i did i'd see how variadic stuff might work...
08:53:53 <JordiGH> So...
08:53:58 <JordiGH> http://codepad.org/bioW2kLI
08:54:28 <JordiGH> This Reddit post seems to get the wrong distance, and takes 7 seconds instead of the 0.1s my C++ version seems to take: http://www.reddit.com/r/programming/comments/w4gs6/levenshtein_distance_in_haskell/c5a6jjz
08:54:49 <JordiGH> This really bugs me. An apparently expert Haskell programmer gets the wrong answer in a much longer time.
08:55:26 <JordiGH> Crap, I get the wrong answer.
08:56:59 <JordiGH> Anyway, still, the C++ version is way, way faster: http://codepad.org/sQTXhqC2
08:57:08 <JordiGH> 100 times faster than the expert Haskeller.
08:57:14 <JordiGH> Can you guys do better?
09:00:06 <ocramz> hi all, I have a question regarding c2hs marshalling of arguments, specifically a function within haskell-mpi: http://stackoverflow.com/questions/29654825/c2hs-in-and-out-marshalling
09:02:12 <ClaudiusMaximus> JordiGH: is std::string unicode code points or bytes?
09:02:37 <JordiGH> ClaudiusMaximus: Bytes, but it hardly matters here.
09:02:46 <JordiGH> This is all ASCII.
09:02:50 <bennofs> JordiGH: did you use the fast version from that thread?
09:03:09 <ClaudiusMaximus> JordiGH: try writing the haskell to use bytestring, otherwise it's not comparing like-with-like
09:03:17 <JordiGH> bennofs: I read further down, the fast version wasn't proclaimeed to be not that fast.
09:03:29 <bennofs> JordiGH: oh, sorry, it's about space
09:03:34 <c_wraith> That's a lot of negatives.  I'm confused.
09:03:36 <JordiGH> ClaudiusMaximus: Does it really matter if all the codepoints are ASCII.
09:03:44 <JordiGH> c_wraith: Wasn't proclaimed to be that fast.
09:03:52 <JordiGH> ClaudiusMaximus ?
09:03:54 <c_wraith> JordiGH: String is not ascii, so yes.  It matters.
09:04:28 <c_wraith> JordiGH: comparing a unicode-aware system with a unicode-oblivious system isn't an apples-to-apples comparison
09:04:34 <JordiGH> That's kind of ridiculous. You're paying a slowdown of 100x when you use non-bytestrings in Haskell? Surely the problem isn't there.
09:04:38 <ClaudiusMaximus> JordiGH: std::string is a flat array of bytes, String is a linked list of Unicode code points - if you want to compare the algorithm, better use the same data structure in both languages
09:04:48 <JordiGH> The algorithm is wrong, for one, using quadratic storage.
09:05:07 <JordiGH> But the proper linear algorithm seems to difficult for anybody to have bothered to write it down.
09:05:26 <elfeck> heyoh does someone know if I manually have to do escaping with Persistent? (e.g. SQL injection, XSS)?
09:05:28 <JordiGH> too difficult
09:06:08 <JordiGH> Okay, how about this: translate the fast C++ algorithm into Haskell. Surely this should be an easy task for a Haskeller?
09:06:12 <c_wraith> elfeck: what would Persistent have to do with XSS?
09:06:12 <JordiGH> http://codepad.org/sQTXhqC2
09:06:39 <JordiGH> I am most interested in seeing what you do with it. It's easier for me to learn when I already understand the algorithm to see how an experienced person does it.
09:06:39 <c_wraith> elfeck: and if it has SQL injection issues, that deserves a bug report.
09:06:52 <ClaudiusMaximus> JordiGH: http://hackage.haskell.org/package/edit-distance check that perhaps
09:07:06 <JordiGH> ClaudiusMaximus: Can you translate my precise algorithm?
09:07:11 <JordiGH> ClaudiusMaximus: It would be helpful for me.
09:07:15 <elfeck> my question is if I need to escape/sanatize stuff before storing or if Persistent does that job for me?
09:07:21 <ClaudiusMaximus> JordiGH: probably, but other things to do
09:07:27 <c_wraith> elfeck: my answer is that the question is bad.
09:07:49 <elfeck> wow I am sorry for asking a bad question ... can you maybe be a bit more constructive at least?
09:07:52 <c_wraith> elfeck: it is 100% wrong for Persistent to do anything other than give you back the same data you provided to it.
09:07:52 <ClaudiusMaximus> JordiGH: shouldn't be hard - use ST and transliterate memory access into reads and writes etc
09:08:06 <JordiGH> ClaudiusMaximus: I have no idea what you just said, so it is that hard.
09:08:08 <c_wraith> elfeck: Persistent should not *ever* do XSS escaping/sanitizing
09:08:26 <elfeck> well thanks for an answer. With that I can work
09:08:29 <c_wraith> elfeck: That job belongs to a presentation layer.
09:08:37 <elfeck> Dont assume everyone knows a lot of stuff
09:09:09 <ggVGc> jellie: yeah, if the language had curried functions by default, as haskell does. But this is just javscript with some additions, so I have to explicitly curry functions if I want to, and I'd like something nicer than just curry(f, arg1, arg2)
09:09:12 <c_wraith> elfeck: On the other hand, it should handle SQL escaping properly.  That *is* the job of a database store - storing exactly the data you give it and not becoming corrupted.
09:09:18 <ggVGc> ehh, sorry
09:09:22 <ggVGc> I mean curry(f)
09:09:27 <ggVGc> otherwise it's just partial application
09:09:42 <elfeck> okay
09:09:45 <c_wraith> elfeck: Are you coming from a PHP background?  That's the only language I know of that doesn't distinguish between those properly.
09:10:00 <c_wraith> (and that's been the source of a tremendous number of PHP security problems)
09:10:05 <elfeck> I am not working in webdev and am just fooling around
09:10:25 <hodapp> anyone proficient in Shake who has a suggestion on how I work with C source files stuck deep in some SDK's directory, short of somehow encoding the entire path into the object file's path?
09:10:53 <ClaudiusMaximus> JordiGH: ok, sorry - something like   a[i] = b[j] + c[k]  would become do{ bj <- readArray b j ; ck <- readArray c k ; let ai = bj + ck ; writeArray a i ai }
09:11:32 <elfeck> are there any packages for data-storage sanitizing?
09:11:36 <hodapp> as far as I can tell I must write things as how I produce a specific object file (as a rule)
09:11:40 <JordiGH> ClaudiusMaximus: I see!
09:11:53 <c_wraith> elfeck: any library that does data storage and doesn't sanitize for itself is buggy.
09:12:10 <elfeck> well I use Scotty + Persistent
09:12:30 <c_wraith> are you looking for presentation-layer sanitization?
09:13:08 <elfeck> yes I guess. As I said, I'm not too familiar with webdev. I want to store stuff with persisent that comes from userinput
09:13:40 <jellie> ggVGc: Actually carry(f) sounds great because it's self explanatory.
09:13:53 <elfeck> I mean I get a Data.Text, pack that into persistent and display it back as html on occasion
09:14:17 <c_wraith> elfeck: The general principle is store exactly the user input, and escape as necessary for how the data is being presented.
09:14:25 <elfeck> I see
09:14:47 <elfeck> So XSS prevention should then be in my Html-producing code?
09:15:13 <ggVGc> jellie: yeah, I might just go with that, but then I'd still want an operator or something for partial application, so as not to introduce too much noise when piping functions in sequence
09:15:16 <c_wraith> elfeck: correct
09:15:43 <elfeck> is there any utility for that already or do I need to write that myself? I'm using blaze-html atm.
09:16:20 <jellie> ggVGc: heh pick one of those lens operators. or something like (=~)
09:16:57 <c_wraith> elfeck: I think blaze-html can do it automatically.  let me double-check.
09:17:34 <ggVGc> jellie: hmm, maybe tilde is actually good. It doesn't collide with anything in javascript
09:17:37 <ggVGc> thanks
09:18:10 <ClaudiusMaximus> ggVGc: )( isn't that noisy
09:18:11 <c_wraith> elfeck: I suspect Text.Blaze.text does escaping for you, but I would want to double-check that.
09:18:31 <ggVGc> ClaudiusMaximus: yeah, but too confusing I reckon
09:18:33 <ClaudiusMaximus> ggVGc: curry(f)(a)(b) -> f(a,b)
09:18:45 <elfeck> alright, thanks a lot
09:18:47 <ggVGc> oh, that's what you meant
09:18:59 <jellie> ClaudiusMaximus: That's super confusing
09:19:14 <ggVGc> ClaudiusMaximus: yeah, I guess. I am trying to reduce the number of parens in this language though, and use operators and other syntax instead to make things clear
09:20:29 <ClaudiusMaximus> ggVGc: just wrap everything in parens - you write   curry f a b   it gets translated to   (curry)(f)(a)(b)  which evaluates to f(a,b)
09:21:22 <ggVGc> ClaudiusMaximus: well, it's a bit problematic to stay a javascript superset and also have whitespace function application. I was playing with various ideas for it, and decided it's not worth the effort and probably won't work out well
09:22:49 <ClaudiusMaximus> ggVGc: why?  does javascript use white space between identifier tokens in some way already?
09:22:53 <ggVGc> uhm.. what about f|a b c| -> partially applied f with a,b,c
09:23:58 <ggVGc> ClaudiusMaximus: I have chosed to use sweet.js macros to implement the language, because it already gives me all the javascript functionality, and lets me define very rich macros. But I don't think I can reliably implement whitespace function application with it, so I would need to chose another implementation strategy if I wanted that
09:24:03 <ClaudiusMaximus> well not really identifier tokens - i think i mean expressions
09:24:12 <ggVGc> ehh, chosen*
09:25:14 <ggVGc> but I think tilde works: f~a,b,c
09:25:25 <ggVGc> maybe it's not very clear..
09:25:27 <ggVGc> :(
09:25:49 <ggVGc> sorry, this is not at all haskell related. I will keep quiet about it now. Was just curious if anyone had ideas
09:25:52 <ggVGc> thanks
09:26:53 <c_wraith> elfeck: confirmed, Text.Blaze.text does escape for you.
09:27:15 <ggVGc> ClaudiusMaximus: also, from my experiments it's become clear to me that the more whitespace syntax I have, the more parens are needed when writing actual code, which is something I tried to avoid
09:28:06 <wakalabis> hey, guys
09:29:38 <wakalabis> I am trying to build glade. The build fails with compilation error: http://lpaste.net/130758 - It seems the code is calling a function (generageRegistrationInfo) from cabal library.
09:29:40 <elfeck> c_wraith: thank you a lot for your help
09:29:56 <c_wraith> elfeck: sorry for my tone initially.  I should have phrased that better.  Glad to have helped.
09:30:03 <wakalabis> The function call is missing 2 parameters according to the documentation.
09:30:13 <wakalabis> Has the interface to cabal library changed ?
09:30:23 <elfeck> no worries :)
09:31:16 <geekosaur> wakalabis, very likely yes. Is this with ghc 7.10.1? There is not yet a gtk2hs released that is compatible with it or its Cabal library, as I understand it
09:31:32 <wakalabis> geekosaur, I'm still at 7.8.4
09:31:40 <geekosaur> 7.10 was only just released and the ecosystem is still catching up. This is not Linux; the latest and greatest is not really something you should chase
09:32:13 <geekosaur> hm. may still have trouble with recent Cabal. what does `cabal --version` say?
09:32:15 <wakalabis> geekosaur, the weird thing is that I checked the package documenation. I checked every version that includes generateRegistrationInfo.
09:32:19 <hexagoxel> wakalabis: and you actually want glade, not gtk (i.e. you have noted the note in the package's description) ?
09:32:26 <wakalabis> Every one of them has the same signature
09:33:00 <wakalabis> hexagoxel, I have successfully isntalled gtk
09:33:05 <wakalabis> the problem is glade
09:33:25 <wakalabis> geekosaur, using version 1.22.2.0 of the Cabal librar
09:34:07 <geekosaur> mm. I have no idea
09:34:27 <wakalabis> see: Gtk2HsSetup: generateRegistrationInfo verbosity pkg lib lbi clbi inplace distPref
09:34:47 <wakalabis> but the signature is: generateRegistrationInfo :: Verbosity -> PackageDescription -> Library -> LocalBuildInfo -> ComponentLocalBuildInfo -> Bool -> Bool -> FilePath -> PackageDB -> IO InstalledPackageInfo
09:35:15 <wakalabis> it's missing 2 paramenters
09:35:35 <hexagoxel> wakalabis: and Graphics.UI.Gtk.Builder is not sufficient? i have used gtk, loading a glade-generated-window with the builder successfully in the past
09:36:21 <wakalabis> hexagoxel, I don't know :) I am trying to learn gtk. that's why I am trying to install glade
09:36:41 <wakalabis> I was followin Real World Haskell chapter 23.. I know it's very outdated though
09:36:49 <geekosaur> glade package is for glade2. glade3 uses what hexagonel said
09:36:59 <wakalabis> geekosaur, ooh
09:37:00 <geekosaur> glade2 is rather ancient at this point, in gnome terms
09:37:30 <wakalabis> geekosaur, you mean there is another library that uses glade3?
09:38:05 <geekosaur> it's in the gtk package
09:38:12 <geekosaur> not a separate package
09:38:19 <wakalabis> geekosaur, cool.. I'll try that
09:38:35 <wakalabis> I've installed gtk package with no problems at all
09:38:46 <geekosaur> this is some historicla stuff; glade originally didn't have any kind of runtime loading. for glade2, someone hacked up "libglade" that had shortcomings but was basically usable; that is what the gtk2hs glade package binds
09:39:01 <wakalabis> geekosaur, do you know of any example of loading a glade file?
09:39:10 <geekosaur> for glade3, proper runtime loading was added to gtk, fixing all the shortcomings of the libglade hack
09:39:31 <geekosaur> not off the top of my head, no
09:39:54 <geekosaur> note that most gtk / glade tutorials are fairly usable with gtk2hs
09:40:00 <wakalabis> what about gtk2hs ? is it outdated too?
09:40:14 <geekosaur> (or at least used to be, and the gtk2hs docs generally rely on it)
09:40:20 <hexagoxel> the gtk3 package contains at least one example regarding loading glade file, iirc
09:40:27 <mpickering> wakalabis: I have a branch of glade which builds with ghc-7.10, cabal 1.22 if that's what you need
09:40:30 <geekosaur> it's not up to date with ghc 7.10 although patches are pending. otherwise it's fairly up to date
09:40:42 <wakalabis> mpickering, cool! where can I get it?
09:40:51 <wakalabis> hexagoxel, thanks, I 'll check it out
09:40:52 <mpickering> github.com/mpickering/glade
09:41:09 <wakalabis> mpickering, thanks
09:41:18 <geekosaur> also I poked at Cabal and 1.18 is actually halfway, it has one fewer parameter to that function than 1.22's. I would infer that the glade package you were building expects Cabal 1.16 or earlier
09:41:44 <geekosaur> (that is, 1.18 still expects one more parameter than the lpaste-d code passes)
09:42:16 <wakalabis> man... this community rocks
09:42:23 <wakalabis> thanks guys
09:43:07 <geekosaur> unfortunately, those functions are intended to be internal, and that gtk2hs uses a custom Setup that needs to use them is somewhat unusual *and* guaranteed to have problems with different Cabal library versions
09:43:35 <wakalabis> geekosaur, so it's actually gtk2hs's fault?
09:43:56 <geekosaur> I suspect there's no good fix for it, though; gtk2hs is fairly complex and interdependent, largely because gtk is fairly complex and interdependent
09:44:18 <geekosaur> so it's in some sense gtk's fault for being a hairy complex beast that gtk2hs has to go through contortions to deal with
09:44:29 <wakalabis> geekosaur, I see
09:44:54 <mpickering> actually most of the gtk ecosystem got updated recently but glade got missed out for some reason
09:45:03 * geekosaur used to maintain gtk ports to various non-linux platforms and knows all to well what kind of hell gtk source builds and dependencies are :/
09:45:14 <mpickering> so my branch is just the changes that were made to the other packages 
09:46:28 <wakalabis> geekosaur, So I am talking to the right person!
09:47:22 <geekosaur> well, sort of. I gave up with gtk3/gnome3 because it's so outrageously linux-only that there was no longer any point
09:47:34 <geekosaur> (recent versions require systemd... good luck with that on OS X or Solaris)
09:47:56 <wakalabis> systemd is so controversial
09:48:51 * geekosaur likes it in theory but is uncomfortable with both the current implementation and how it's being forced onto production systems
09:49:35 <geekosaur> but it's more or less irrelevant to the question of non-Linux systems, where systemd is never going to work *or* be accepted; you deal with launchd (OS X) or SMF (Solaris), you don't get to replace it
09:49:56 <wakalabis> geekosaur, that's sad
09:50:22 <wakalabis> geekosaur, what is the best gui solution in your opinion?
09:50:39 <geekosaur> like, I just saw an RH ticket go by where RHEL7.2 is going to get a new incompatible version of systemd. so much for stable LTS releases
09:51:51 <geekosaur> that's almost more of a religious question than anything else. there are diehard gtk adherents and diehard Wx adherents and diehard Qt adherents, etc.
09:52:43 <wakalabis> geekosaur, in haskell at least, is there a stable, robust solution?
09:52:46 <geekosaur> if I had to write a GUI app right now I'd probably poke at the new fltk bindings... recognizing that they are *new* and may be unstable. but I don't do much production GUI work, so I can get away with that
09:53:21 <geekosaur> wx and gtk2hs are the generally used ones. each has its own pain points, though
09:53:52 <wakalabis> geekosaur, I was trying to make a redistributable version of a wx program
09:53:54 <geekosaur> wx because it's a binding to C++ libs, gtk2hs because it's a binding to the utter mess that is gtk >.>
09:54:12 <wakalabis> I could not make it work on an OS X machine without installing the whole haskell stack
09:54:17 <wakalabis> In the end I gave up
09:54:41 <bennofs> wakalabis: not sure if it's good, just noting that there is also hsqml
09:55:17 <wakalabis> I guess it would be easier to do the gui in C and use FFI to call haskell functions
09:57:15 <kuribas> fltk doesn't look native anywhere.
09:57:29 <kuribas> wakalabis: wxhaskell is usable.
09:57:54 <kuribas> wakalabis: In the worst case you have to implement functionality from wxwidgets into wxhaskell.
09:58:14 <wakalabis> kuribas, what do you mean?
09:58:55 <kuribas> wxhaskell has a lot of functionality, but it isn't exactly complete...
09:59:14 <wakalabis> kuribas, oh... I see
10:02:57 <ggVGc> why do I feel function composition goes the wrong way in haskell?
10:03:19 <fragamus> I use =<<
10:03:38 <EvanR> because you think f(x) is the wrong way ;)
10:03:49 <mpickering> because you're not reading (.) as "after" :P
10:03:50 <kuribas> ggVGc: because you've programmed in ruby, or C++?
10:03:52 <EvanR> obviously we should be using reverse polish notation 
10:04:00 <creichert> wakalabis: another option I like is HsQML. but it;s not pure Haskell which usually deters some :)
10:04:24 <fragamus> wtfihsqml
10:04:27 <ggVGc> mpickering: ah, that's actually a better trick. But I still feel like I need to read function composition backwards for it to parse well into my brain
10:04:28 <creichert> basically have to write the front-end in javascript (QML).
10:04:34 <creichert> Qt Quick binding
10:04:35 <geekosaur> people like to think left to right but math likes to go right to left for this kind of thing, there's been discussion of a flipped (.) (and iirc lens has one) but it keeps getting bikeshedded
10:04:47 <EvanR> ggVGc: (f . g) x = f (g x)
10:04:48 <wakalabis> f# has he pipeline operator |>
10:05:01 <wakalabis> g |> f instead of f . g
10:05:10 <ggVGc> wakalabis: yes, maybe that's why. I did F# and ocaml before haskell
10:05:40 <t7> both have weak type systems 
10:05:48 <ggVGc> EvanR: hm, yeah, that does make more sense
10:07:00 <EvanR> ggVGc: also you have to consider in what sense anything is right to left at all here. in f (g (h x)) the first thing to evaluate is f
10:07:24 <ggVGc> EvanR: yeah, your example made a lot more sense to me than how I thought about it before
10:07:26 <ggVGc> dunno why I didn't see that
10:07:28 <ggVGc> thanks
10:25:34 * hackagebot purescript 0.6.9.4 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.6.9.4 (PhilFreeman)
10:35:34 * hackagebot purescript 0.6.9.5 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.6.9.5 (PhilFreeman)
10:35:52 <zmbmartin> Does travis-ci work with 7.10 I tried - '7.10' and I get 'ghc_find: error, no such version 7.10'
10:36:06 <mpickering> zmbmartin: yes
10:36:20 <mpickering> Most people use hvr's template afaik
10:36:28 <kadoban> zmbmartin: 7.10.1 ?
10:36:32 <mpickering> https://github.com/hvr/multi-ghc-travis
10:37:28 <zmbmartin> kadoban: I will try that, it fell back to 7.4
10:38:05 <mjboa> i think right to left is easy if you think top down with respect to composition. Starting with the "inner" function is where the backwards parsing becomes a problem...
11:00:35 * hackagebot pandoc-crossref 0.1.0.0 - Pandoc filter for cross-references  http://hackage.haskell.org/package/pandoc-crossref-0.1.0.0 (lierdakil)
11:01:52 <SrPx> Can't I use minus sections? (- 3) hm
11:02:05 <geekosaur> no, conflict with unary -
11:02:05 <bennofs> SrPx: there is subtract though
11:02:16 <bennofs> > subtract 3 4
11:02:17 <geekosaur> one of the more annoying warts of haskell syntax
11:02:18 <lambdabot>  1
11:03:08 <int-e> > (-3+) 5
11:03:10 <lambdabot>  2
11:04:46 <SrPx> Ah, interesting. Also, `(subract n) . (+ n) == id`, `(* n) . (/ n) == id`, but `(logBase n) . (n ^) == id`, why is ^ flipped?
11:05:39 <monochrom> perhaps because logBase is flipped
11:06:25 <bennofs> SrPx: the inverse to (^ n) would be root n, no ? (don't know there is a generic root function in base)
11:06:42 <SrPx> monochrom: not true since (flip logBase n) . (^ n) != id
11:06:43 <hodapp> huh, Shake doesn't really make it clear to me whether its exception type is something I'm supposed to actually throw...
11:07:09 <SrPx> bennofs: I believe the inverse of exponential should be logarithm ... hm
11:07:16 <hodapp> or just... throw something and this is the exception type it'll wrap it in?
11:07:29 <monochrom> (flip logBase n) . (n ^) = id
11:07:41 <bennofs> :t logBase
11:07:42 <lambdabot> Floating a => a -> a -> a
11:07:54 <hodapp> ShakeException is both an instance of Exception, and has a SomeException contained therein
11:07:57 <bennofs> > logBase 64 2
11:07:59 <lambdabot>  0.16666666666666669
11:08:31 <SrPx> (flip logBase n) . (n ^) isn't id
11:11:09 <mniip> it is approximately id though
11:11:33 <SrPx> > (flip logBase 3) . (3 ^) $ 4
11:11:35 <lambdabot>  0.25
11:11:56 <SrPx> > (flip logBase 3) . (^ 3) $ 4
11:11:57 <lambdabot>  0.2641604167868594
11:12:01 <SrPx> > (logBase 3) . (^ 3) $ 4
11:12:02 <lambdabot>  3.785578521428744
11:12:04 <SrPx> > (flip logBase 3) . (3 ^) $ 4
11:12:05 <lambdabot>  0.25
11:12:10 <SrPx> woops, my bad -
11:12:17 <monochrom> I know how to fix it
11:12:20 <SrPx> > (logBase 3) . (3 ^) $ 4
11:12:22 <lambdabot>  4.0
11:12:27 <SrPx> That's the only way it works out, flipping ^
11:12:41 <monochrom> > recip . (flip logBase 3) . (^ 3) $ 4
11:12:43 <lambdabot>  3.785578521428744
11:12:54 <monochrom> oops. the wrong one
11:13:03 <SrPx> :t recip
11:13:04 <lambdabot> Fractional a => a -> a
11:13:10 * monochrom should have simply copied-pasted
11:14:45 <SrPx> I think I see what you are saying
11:15:03 <SrPx> > (^ 2) . (^ (1/2)) $ 7
11:15:05 <lambdabot>      Could not deduce (Integral b0) arising from a use of ‘^’
11:15:05 <lambdabot>      from the context (Num r)
11:15:05 <lambdabot>        bound by the inferred type of it :: Num r => r at Top level
11:15:11 <SrPx> ah cmon
11:15:26 <SrPx> > (** 2) . (** (1/2)) $ 7
11:15:27 <bennofs> :t (**)
11:15:28 <lambdabot> Floating a => a -> a -> a
11:15:28 <lambdabot>  7.000000000000001
11:15:33 <bennofs> close
11:15:36 <bennofs> :)
11:15:50 <SrPx> but that isn't kinda the way imo, log isn't on the equation
11:15:53 <NemesisD> cabal sandbox question. i'm attempting to install the deps of a project from a blank sandbox and for some reason the resolution fails, and indicates it is choosing "installed" versions of bytestring, unix, and process. Why? Why does it not install the latest versions into the sandbox.
11:16:15 <SrPx> brb
11:16:26 <geekosaur> NemesisD: do you have constraints in ~/.cabal/config?
11:17:02 * geekosaur typically puts "constraint: <foo> installed" in there for the global packages, but that disallows installing newer versions in a sandbox
11:17:06 <NemesisD> geekosaur: not that i can see, there's a commented out -- constraint: line
11:17:19 <geekosaur> it's safer for non-sandboxed stuff but blows up for sandboxed stuff, in other words
11:18:00 <geekosaur> it is also possible that, since those are all bootlibs (that is, they come with ghc), it's insisting on the compiler-matching versions
11:18:41 <jle`> yeah my cabal has never let me install newer versions of those packages that come with ghc
11:20:14 <jle`> for sanboxes
11:50:38 * hackagebot rethinkdb-model 0.1.0.1 - Useful tools for modeling data with rethinkdb  http://hackage.haskell.org/package/rethinkdb-model-0.1.0.1 (seanhess)
11:50:40 * hackagebot rethinkdb-model 0.1.0.2 - Useful tools for modeling data with rethinkdb  http://hackage.haskell.org/package/rethinkdb-model-0.1.0.2 (seanhess)
11:52:42 <frainfreeze> Hi, anyone wants to support table top game? https://www.kickstarter.com/projects/2084336794/awaken-1
11:58:49 <EvanR> ill come over and play it
11:59:15 <EvanR> i can donate 1 bag of cheetos
11:59:55 <hodapp> my Shake build finally built with no errors! \o/
12:02:29 <jle`> \o/
12:02:44 <frainfreeze> EvanR, we could code some haskell while playing ^^  
12:25:39 * hackagebot atomic-primops 0.8 - A safe approach to CAS and other atomic ops in Haskell.  http://hackage.haskell.org/package/atomic-primops-0.8 (BrandonSimmons)
13:00:46 * hodapp pokes jellie
13:01:31 <jellie> hodapp: Hey
13:01:38 <hodapp> jellie: yeah I really don't either
13:01:45 <hodapp> jellie: it's why they shout "KARTOFFEL" at me
13:02:39 <jellie> hodapp: You're not from there? Interesting. If you want to talk I'm in #haskell-blah
13:09:39 <marchelzo_> @pl \(a,b) (c,d) -> a == c
13:09:39 <lambdabot> (`ap` snd) . (. fst) . (const .) . (==) . fst
13:09:45 <marchelzo_> yuck
13:11:49 <enthropy> @type on (==) fst
13:11:50 <lambdabot> Eq a => (a, b) -> (a, b) -> Bool
13:13:19 <marchelzo_> @src on
13:13:19 <lambdabot> (*) `on` f = \x y -> f x * f y
13:13:43 <enthropy> it comes with ghc (import Data.Function)
13:14:07 <marchelzo_> I didn't know function arguments could be bound to infix operators
13:15:07 <marchelzo_> > let f (*) a b = a * b in f (+) 1 2
13:15:08 <lambdabot>  3
13:19:15 <mniip> [23:06:46] <lambdabot> (`ap` snd) . (. fst) . (const .) . (==) . fst
13:19:16 <mniip> the heck
13:19:43 <mniip> it didn't even suggest (. fst) . (==) . fst
13:20:34 <quchen> Has anyone here compiled stackage-view already? How long did the compilation roughly take?
13:30:42 * hackagebot webpage 0.0.3.1 - Organized and simple web page scaffold for blaze and lucid  http://hackage.haskell.org/package/webpage-0.0.3.1 (athanclark)
13:41:14 <athan> quchen: I'm getting some kind of cyclic dependency with fpview :S
13:41:34 <fuzzyhorns> on https://wiki.haskell.org/Algebraic_data_type it says "Algebraic Data Type is not to be confused with *Abstract* Data Type, which (ironically) is its opposite, in some sense."
13:41:51 <fuzzyhorns> i dont understand in what sense they are opposites?
13:42:09 <fuzzyhorns> (my understanding of abstract data type is it defines an interface, but hides an implementation)
13:42:32 <monochrom> an algebraic data type tells you its implementation
13:42:33 <athan> fuzzyhorns: Well, abstract types can be something like typeclasses
13:42:36 <quchen> fuzzyhorns: Algebraic data types define only the implementation. Less, even: only the shape of the data of an implementation.
13:42:52 <monochrom> "data Maybe a = Nothing | Just a" tells you to use Nothing and Just directly
13:43:00 <athan> or if your algebraic type was _really_ polymorphic, then you could see it like that
13:43:00 <ReinH> IO is an abstract datatype. Either is an algebraic datatype.
13:43:16 <fuzzyhorns> to me that is the interface of the data type, maybe i am using interface too loosely in my mind
13:43:31 <quchen> Oh, there's "abstract data type" in the Haskell context too, like ReinH said.
13:43:34 <athan> fuzzyhorns: Algebraic types _are_ the structure represented
13:43:49 <athan> the structure of it's data constructors
13:44:07 <athan> abstract types shouldn't be defined
13:44:07 <monochrom> "abstract" is relative, as is always
13:44:11 <fuzzyhorns> hmm, i guess i see them as a promise of the structure
13:44:14 <fuzzyhorns> not the structure itself
13:44:28 <fuzzyhorns> (in the sense that it is not an implementation, but a type)
13:44:29 <athan> you could see a kind signature as an abstract algebraic type :P
13:44:43 <fuzzyhorns> uh oh athan, gonna break my brain :c
13:44:45 <ReinH> In Haskell the question is basically "are its constructors exposed?"
13:44:49 <monochrom> but a data type without data constructors exported is certainly more abstract than a data type with data constructors exported
13:44:59 <athan> fuzzyhorns: The burn means it's working!
13:45:08 <fuzzyhorns> hahah x)
13:45:42 * hackagebot cube 0.2.0 - Cubic DSL for 3D printing  http://hackage.haskell.org/package/cube-0.2.0 (junjihashimoto)
13:45:50 <fuzzyhorns> also, a parameterized data type — what is it? :d
13:46:17 <monochrom> "data Maybe a = Nothing | Just a" is an example of parameterized
13:46:36 <fuzzyhorns> but isnt that also an algebraic data type because it has a sum type?
13:46:38 <fuzzyhorns> or is that a product type
13:46:43 <fuzzyhorns> (sorry i forget ;-;)
13:46:48 <monochrom> yes. must they be mutually exclusive?
13:46:57 <fuzzyhorns> no, but this https://wiki.haskell.org/Abstract_data_type
13:47:12 <fuzzyhorns> says parameterized types can be viewed as a kind of abstract type
13:47:16 <monochrom> some abstract types are parameterized, too. for example IO a.
13:47:24 <fuzzyhorns> which means to me that algebraic data types can be viewed as a kind of abstract type
13:47:49 <monochrom> Int is an abstract type. it is unparameterized.
13:48:14 <fuzzyhorns> but how is an algebraic data type the opposite of a parameterized abstract type?
13:48:43 <monochrom> do you mind deleting "parameterized" there?
13:49:16 <Bor0> fuzzyhorns, as you've been explained, the former "kind of" shows the implementation while the latter hides it. "kind of" is related to "in some sense" from the sentence that you linked
13:49:56 <monochrom> if someone asks me "how is black the opposite of white and creamy?", I'll certain request to delete "creamy" first.
13:50:45 <monochrom> I know how to explain that black is the opposite of white. I don't know what "opposite" means if you throw in "creamy", and only throw it in on one side
13:50:53 <fuzzyhorns> monochrom: i dont mind anything haha, just the wiki says a parameterized type is a kind of abstract type, but a parameterized type is an algebraic type, which is the opposite of abstract?
13:51:16 <monochrom> "is a kind of" is weaseling
13:51:25 <monochrom> in fact, I probably completely disagree
13:51:43 <fuzzyhorns> https://wiki.haskell.org/Abstract_data_type "parametrized types can be viewed as a kind of abstract type"
13:51:47 <monochrom> a parameterized type is not necessarily an algebraic type
13:51:49 <fuzzyhorns> is haskell wiki not a good source? :c
13:52:05 <fuzzyhorns> what's a parameterized type that isnt algebraic?
13:52:08 <monochrom> depends on who wrote it. don't you think?
13:52:12 <monochrom> IO a
13:52:29 <mniip> (->)
13:52:29 <monochrom> do you understand the whole idea of wiki?
13:52:32 <fuzzyhorns> monochrom: of course, but some communities are better than others, i tend to trust this channel as a source above the wiki for instance
13:52:40 <fuzzyhorns> monochrom: that seems like a bit of a mean thing to say
13:52:56 <fuzzyhorns> monochrom: is it intended to suggest i am too stupid to understand wikis yield to editing?
13:52:59 <fuzzyhorns> :c
13:53:03 <Bor0> I have to admit that I also tend to trust this channel :)
13:53:22 <fuzzyhorns> Bor0: :)
13:53:43 <fuzzyhorns> i would not be qualified to edit this wiki, anyhow, which is why i come to those i trust as more qualified :)
13:53:43 <monochrom> no, editing is not the key
13:54:09 <monochrom> vocal minority and over-enthusiasm are the key
13:54:28 <fuzzyhorns> hehe, this is always a critique of "what gets written down" or "what gets heard" dont you think?
13:54:40 <monochrom> note that vocal minority and over-enthusiasm do not imply competence
13:54:50 <fuzzyhorns> the motivation to document is not coincident with experience, sadly
13:54:56 <fuzzyhorns> is the way id put  it ;)
13:55:20 <fuzzyhorns> in any case monochrom, do you have a better source that sorts out these distinctions? id be happy to read something if you do
13:55:40 <monochrom> there is one more factor in the case of the Haskell wiki. the competent people are too polite to delete wrong information on the Haskell wiki
13:55:43 * hackagebot pandoc 1.13.2.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.13.2.1 (JohnMacFarlane)
13:56:10 <monochrom> (this factor does not exist on wikipedia. this is how wikipedia fares better.)
13:56:11 <Bor0> monochrom, but doesn't that make them impolite?
13:56:33 <fuzzyhorns> i think to delete incorrect stuff shows respect, actually
13:56:44 <fuzzyhorns> for the community of practice, and for the ability of colleagues to recognize mistakes
13:56:48 <fuzzyhorns> that is easily said though hehe
13:57:03 <monochrom> abstract types, algebraic types, and parameterized types are one-line definitions
13:57:54 <monochrom> "opposite" is a fairly subjective thing, but I can describe in what sense "opposite" applies to abstract types and algebraic types.
13:58:09 <fuzzyhorns> id be curious if you find it a useful opposition
13:58:13 <monochrom> having said that, it is not a useful thing to know
13:58:14 <fuzzyhorns> if not, i am not invested in it
13:58:51 <fuzzyhorns> it is unique to claim the use value of info, that one i hope you _will_ explain, as it is so tantalizing
13:58:58 <athan> Why doesn't -threaded & +RTS -N* give a speedup for Warp?
13:59:25 <monochrom> lastly, "X is kind of like Y" is true for all X and Y. proof: by bending the definition of "kind of like" for each case.
13:59:50 <fuzzyhorns> sounds like the wrong quantifier then monochrom ;)
14:00:01 <fuzzyhorns> i take your point though
14:00:26 <monochrom> it is not my wrong quantifier. it is other people's wrong quantifier.
14:00:43 * hackagebot stm-queue-extras 0.2.0.0.1 - Extra queue utilities for STM  http://hackage.haskell.org/package/stm-queue-extras-0.2.0.0.1 (JonSterling)
14:00:54 <monochrom> you look at 10 examples of "X is kind of like Y" and you see 15 different definitions of "kind of like", not one.
14:00:57 <fuzzyhorns> i didnt accuse you :d
14:01:39 <monochrom> that's right, even more definitions than examples. that is, one example may already use multiple definitions to weasel its way out
14:01:51 <fuzzyhorns> to me, i just try to think of the properties
14:01:58 <fuzzyhorns> and whether they are disjoint or not
14:02:18 <fuzzyhorns> but saying something has membership in a property set or not, people can make that anything
14:04:02 <ReinH> monochrom: So apfelmus wrote this on laziness recently https://hackhands.com/guide-lazy-evaluation-haskell/
14:04:34 <ReinH> Or, in fact, a few things on laziness.
14:05:43 * hackagebot unagi-chan 0.4.0.0 - Fast concurrent queues with a Chan-like API, and more  http://hackage.haskell.org/package/unagi-chan-0.4.0.0 (BrandonSimmons)
14:20:44 * hackagebot acme-everything 2015.4.15 - Everything.  http://hackage.haskell.org/package/acme-everything-2015.4.15 (quchen)
14:22:22 <hpc> quchen: i don't get it
14:22:44 <quchen> hpc: That wasn't supposed to happen.
14:22:57 <quchen> I released it instead of staging it. Ignore ;-(
14:23:14 <hpc> heh, makes sense
14:26:22 <monochrom> I wonder why Andrew Coppin is so nice as to name his libraries AC-* so we know what to avoid
14:26:50 <cachorro> Is there any shortcut on prelude for `foldr (.) id` ? I couldn't find anyting on hackage from the type
14:27:09 <hpc> (a -> a) is a monoid
14:27:31 <hpc> > mconcat [(+ 5), (* 2)] $ 5
14:27:32 <lambdabot>      No instance for (Show a0)
14:27:32 <lambdabot>        arising from a use of ‘show_M63496478820261509551157’
14:27:32 <lambdabot>      The type variable ‘a0’ is ambiguous
14:27:43 <Denommus> hi
14:27:44 <hpc> hmm
14:28:44 <barrucadu> > mconcat [(+ 5), (* 2)] $ (5::Int)
14:28:46 <lambdabot>      No instance for (Monoid Int) arising from a use of ‘mconcat’
14:28:46 <lambdabot>      In the expression: mconcat [(+ 5), (* 2)]
14:28:46 <lambdabot>      In the expression: mconcat [(+ 5), (* 2)] $ (5 :: Int)
14:28:58 <barrucadu> Aw
14:29:21 <Denommus> hpc: barrucadu: Int is not a monoid
14:29:48 <shachaf> hpc: You are thinking of Endo a
14:29:48 <hpc> it shouldn't need to be
14:29:52 <hpc> ah, right
14:29:58 <hpc> and that wouldn't be shorter than foldr
14:30:15 <hpc> which mconcat was i using then?
14:30:21 <Denommus> > mconcat [(++"a"), ('b':)] "bar"
14:30:22 <lambdabot>  "barabbar"
14:30:44 <Denommus> hpc: it needs to be
14:30:49 <hpc> oh, figures
14:30:56 <Denommus> :t mconcat [(+5), (*2)] 5
14:30:58 <lambdabot> (Num a, Monoid a) => a
14:31:07 <Denommus> hpc: see? "a" must be a Monoid
14:31:08 <hpc> Denommus: there's multiple instances
14:31:43 <hpc> the one i was thinking of is ENdo
14:39:12 <Denommus> hpc: but no Monoid Int instance
14:39:21 <Denommus> hpc: sorry, my connection is horrible today
14:41:21 <ReinH> hpc: Monoid b => Monoid (a -> b)
14:41:44 <hpc> ...
14:41:51 <hpc> i feel like i forgot to put a cover sheet on the TPS report
14:42:03 <monochrom> :)
14:42:08 <hpc> you see, it's just that there's no Monoid Int instance
14:42:14 <hpc> i'll get you another copy of the haddock
14:42:25 <ReinH> :t ("foo"++) <> (++"bar")
14:42:26 <lambdabot> [Char] -> [Char]
14:42:36 <ReinH> hpc: Yes, the error is telling you that as well.
14:43:49 <ReinH> > mconcat [(+5), (*2)] 5 :: Sum Int
14:43:50 <lambdabot>  Sum {getSum = 20}
14:44:32 <arkeet> > 5 :: Sum Int
14:44:33 <lambdabot>  Sum {getSum = 5}
14:47:11 <ReinH> > mconcat [(+5), (*2)] 5 :: Product Int
14:47:12 <lambdabot>  Product {getProduct = 100}
14:47:40 <ReinH> polymorphic number literals are fun
14:51:16 <KaneTW> ?pl a >>= (\x -> b x)
14:51:17 <lambdabot> b =<< a
14:52:02 <kadoban> I wonder why it changes >>= to =<<
15:02:03 <mauke> jellie: getArgs isn't supposed to ask for anything
15:02:19 <jellie> mauke: How is it going to get args?
15:02:30 <jellie> It's supposed to pause and wait for user input
15:02:35 <jellie> It isn't.
15:02:41 <newsham> getArgs gets the cmd line args you invoked the script with
15:02:41 <mauke> it's not supposed to do that
15:02:44 <mauke> user input is not args
15:02:46 <newsham> args !! 0   gets the fist one
15:02:51 <newsham> if you didnt give it any args, args !! 0 will error
15:03:06 <monochrom> command line arguments
15:03:08 <newsham> try rnning yoru script with more args
15:03:17 <bernalex> jellie: sounds like you mean getLine.
15:03:22 <jellie> Oh I see.
15:03:33 <newsham> > [] !! 0
15:03:34 <lambdabot>  *Exception: Prelude.!!: index too large
15:03:37 <jellie> bernalex: Yes I totally had it confused with getLine
15:03:45 <newsham> > ["this", "and", "that"] !! 0
15:03:45 <bernalex> newsham: don't recommend (!!). ever. use pattern matching.
15:03:46 <lambdabot>  "this"
15:03:48 * ReinH recommends not using !! for the result of getArgs or anything else.
15:03:53 <newsham> bernalex: i didnt.
15:04:08 <monochrom> bernalex: the !!0 comes from "write your scheme in 48 hours" literally
15:04:09 <bernalex> ReinH: hiya!
15:04:12 <ReinH> bernalex: hi
15:04:13 <newsham> its the scheme48 tutorial, not me
15:04:25 <jellie> Well since it's a wikibooks article I guess I can easily submit an edit
15:04:26 <ReinH> monochrom: "write yourself a scheme" isn't very good though
15:04:26 <bernalex> monochrom: someone should change that. I haven't gotten to it yet.
15:04:39 <ReinH> There are lots of things that need to change in that "book".
15:04:39 <jellie> ReinH: How are you doing?
15:04:43 <ReinH> jellie: good, you?
15:04:53 <monochrom> write yourself a scheme in 48 hours and use !!48 to get the final result
15:05:07 <mauke> off by one!
15:05:10 <mauke> it's !!47
15:05:13 <jellie> ReinH: LOL I just had an issue with getArgs I probably need to sleep
15:05:20 <ReinH> iterate writeYourself aScheme !! 48
15:05:26 <newsham> iterateM_ waitHour nothingYet !! 47
15:05:39 <newsham> w/o _
15:06:05 <jellie> Wait so if I pattern matched it like this:
15:06:17 <jellie> (args:_) <- getArgs
15:06:37 <monochrom> similar problem. what if it's [].
15:06:42 <jellie> If I gave it no args it would still hopelessly fail with an exception
15:06:46 <ReinH> args would be the first argument or you would get a runtime exception if there are no args
15:06:49 <mauke> but now it'll raise an IO exception
15:07:11 <ReinH> args <- getArgs; case args of ...
15:07:15 <lpaste> newsham pasted “args arguments” at http://lpaste.net/130771
15:07:30 <ReinH> or getArgs >>= \case if you're into LambdaCase (which I am).
15:07:36 <jellie> ReinH: Oh okay yeah that's obviously better.
15:08:13 <jellie> ReinH: Never heard of lambda case. Example?
15:08:14 <mauke> getArgs >>= \case [] -> hPutStr stderr "Naughty user! SPANK SPANK SPANK\n"; ...
15:08:41 <newsham> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions#lambdacase
15:08:41 <jellie> mauke: haha
15:09:00 <mauke> (error message deliberately awful; see TDWTF)
15:10:01 <arkeet> arg <- case args of [a] -> return a; _ -> exitFailre "gdfgdfgggfhh"
15:10:05 <arkeet> exitFailure.
15:10:18 <arkeet> I dunno.
15:10:26 <jellie> I usually do \x -> case x of ... and nobody has ever told me of lambda case before.
15:10:36 <jellie> Maybe I should get peers for peer review.
15:10:46 <arkeet> you have all of #haskell :-)
15:10:46 * hackagebot acme-everything 2015.4.15.1 - Everything.  http://hackage.haskell.org/package/acme-everything-2015.4.15.1 (quchen)
15:10:56 <mauke> peers for the peer review god
15:11:06 <jellie> arkeet: True
15:11:12 <lpaste> ReinH pasted “LambdaCase” at http://lpaste.net/130772
15:12:49 <newsham> unSingleton f g = \case [x] -> f x; xs -> g xs
15:12:53 <mauke> quchen: https://metacpan.org/pod/Acme%3A%3AEverything is slightly more convenient to install :-)
15:13:22 <quchen> mauke: Is that the same thing?
15:13:26 <newsham> getArgs >>= unSingleton run err
15:13:32 <mauke> quchen: not really
15:13:47 <mauke> but it has the same name
15:14:25 <quchen> mauke: I opened a ticket to reduce the explicit dependency footprint, since lots of these are covered as transitive dependencies.
15:14:38 <mauke> ah, smart
15:14:58 <quchen> I'll implement that later™ 
15:15:04 <Denommus> :i Sum
15:15:25 <mauke> Acme::Everything installs an AUTOLOAD handler that downloads and installs any missing modules on the fly
15:15:26 <quchen> Denommus: Lambdabot doesn't have :i
15:15:32 <arkeet> quchen: I'm a bit disappointed that it doesn't re-export all the moduels in the things it depends on.
15:15:37 <Denommus> quchen: ah
15:15:39 <arkeet> maybe that's a bug.
15:16:00 <quchen> arkeet: I suspect that wouldn't work because of name clashes
15:16:16 <quchen> e.g. mtl vs monads-tf or whatever it's called
15:16:23 <arkeet> make it work! :=)
15:16:30 <quchen> Denommus: :t is an alias for ?type, actually
15:16:38 <arkeet> why do people use the ? prefix
15:16:54 <quchen> Because @ is awkward to type on German keyboards
15:16:55 <dedgrant_> Hi all, thought experiment for me. This is the first time I've had to deal with projecting heterogeneous Maybe types to a (homogeneous) index of values in haskell, and I'm sure many have tackled this problem. Can anyone offer some experience/insight to reducing boilerplate here? Perhaps some natural forms of applicative style that at least reduce the boilerplate? http://pastebin.com/2VrCAEHM   Thanks.
15:16:58 <arkeet> ah
15:17:22 <quchen> And @ also means "at", while a question mark at the beginning means "probably not a proper sentence"
15:17:35 <quchen> (insert Spanish joke here)
15:17:42 <mauke> some people program with a german keyboard layout. those people are crazy.
15:18:09 <mauke> ({[]}\ are all impossibly awkward to type)
15:18:45 <ReinH> dedgrant_: What are you trying to do? It's hard to tell with meaningless names like Data, Ta, Tb, etc.
15:19:05 <arkeet> use isJust instead of (/= Nothing).
15:19:17 <arkeet> I dunno.
15:20:43 <augur> any good Haskell style guides out there?
15:20:57 <arkeet> @where style
15:20:57 <lambdabot> http://urchin.earth.li/~ian/style/haskell.html http://snapframework.com/docs/style-guide
15:21:03 <hpc> there's no single style
15:21:10 <quchen> augur: Look at hindent's README
15:21:20 <augur> k
15:21:22 <quchen> I think it links to a couple of styles, chrisdone style among them
15:21:27 <dedgrant_> ReinH: I am attempting to binary serialize (and later deserialize) a bitset indicating the data to follow. The bit offset identifies the type and availability of one piece of data to follow. 1 means the data at the bit offset will be written, 0 means it will not.
15:21:47 <quchen> augur: https://github.com/chrisdone/haskell-style-guide ← that one
15:21:51 <augur> additionally, any good references of ideal design considerations, etc.?
15:21:58 <ReinH> dedgrant_: I'd use a sum type.
15:22:15 <augur> like, "if you find yourself doing XYZ, you might want to do WQR instead"?
15:22:38 <arkeet> @where+ style http://urchin.earth.li/~ian/style/haskell.html http://snapframework.com/docs/style-guide https://github.com/chrisdone/haskell-style-guide
15:22:39 <lambdabot> Done.
15:22:43 <ReinH> augur: chrisdone also has a style guide. It is... opinionated... but I like it.
15:23:21 <augur> i too am opinionated :)
15:23:28 <ReinH> augur: indeed
15:23:39 <bernalex> just write code like I do. I tend to like code that looks like the way I write code.
15:24:03 <arkeet> :)
15:24:21 <bernalex> in general though, 2 spaces, tw=78 & some sort of vertical alignment of things is enough to make me semi-content.
15:25:07 * arkeet tends to use 4 spaces
15:25:21 <bernalex> arkeet: D:
15:25:23 <arkeet> D:
15:25:25 <quchen> ReinH: What's an unopinionated style guide? Isn't style about the opinion that it's a good style and it should be followed?
15:25:58 <ReinH> quchen: Fair point. I guess I'm trying to say that its opinions are somewhat non-standard based on what I've seen from other style guides.
15:26:20 <monochrom> an unopinionated style guide is a parameterized style guide
15:26:32 <quchen> ReinH: I really like the style though. I'm not sold on avoiding *all* ($), but I try to minimize its use.
15:26:37 <dedgrant_> ReinH: How so? The resulting value will be a product of heterogenous types and the binary format itself can not be changed.
15:26:43 <bernalex> ReinH: what are some unpopular points of it?
15:26:48 <ReinH> quchen: agreed
15:27:01 <koala_man> "1595-1605; obsolete: opinionate, to possess or form an opinion"
15:27:12 <arkeet> I find it really weird to see a comma as the first non-whitespace character in a line.
15:27:15 <quchen> ReinH: ($) for me is like a "big" parenthesis. Like in the end of "bracket foo bar baz $ \...", or liftIO, or atomically, …
15:27:20 <ReinH> dedgrant_: I don't see what the disjoint types are buying you that a sum type wouldn't
15:28:04 <ReinH> Except for difficulties that arise because lists of them are heterogeneous.
15:28:08 <dedgrant_> ReinH: They can all coexist. I may be misunderstanding something else about what you're saying..
15:28:29 <dedgrant_> ReinH: Rather, the values can all coexist simultaneously in the resulting value.
15:29:09 <ReinH> You have a heterogenous list. The easy thing to do is make it homogenous by wrapping the heterogenous types in a sum type.
15:29:21 <ReinH> *heterogeneous, *homogeneous
15:30:14 <ReinH> You have a small, fixed number of such types. It seems like an easy thing to do.
15:31:17 <quchen> Looks right to me as well.
15:32:06 <mgsloan> I feel like something like tibbe's style is used more frequently, but certainly a thing of personal taste: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md 
15:32:10 <quchen> If you're looking for heterogeneous lists, HList might be worth a look: http://hackage.haskell.org/package/HList-0.3.4.1/docs/Data-HList-HListPrelude.html
15:32:12 <dedgrant_> ReinH: Processing this.
15:32:27 <quchen> "Worth a look" mostly means seeing how complicated things get
15:34:50 <bernalex> arkeet: are you referring to the [lulz\n,lolz] style etc.?
15:35:26 <dedgrant_> ReinH: Do you mean think in terms of some [Value] where (data Value t = A Ta | B Tb | ...) instead?
15:36:01 <ReinH> dedgrant_: Probably, it's hard to know what's going on when dealing with something so abstracted from the underlying problem
15:36:41 <ReinH> Maybe this is really an XY problem.
15:37:24 <dedgrant_> ReinH: Yea I apologize for that (scrubbing private details) and thank you for the attempt.
15:38:02 <dedgrant_> ReinH: I'll explore the option.
15:50:03 <mjrosenb> if I have ApplicativeFunctor f => (\ a b c d -> foo) <$> a <*> b <*> c <*> d
15:50:21 <bernalex> mjrosenb: that's not really a question.
15:50:43 <bergmark> who said it was a question
15:50:56 <mjrosenb> *and* f is also a monad, then I should be able to transform this into do a' <- a; b' <- b; c' <- c; d' <- d; return foo
15:50:59 <mjrosenb> yes?
15:51:39 <mjrosenb> or at least something where the variables being bound are close to the values being bound to them.
15:51:40 <bergmark> mjrosenb: that seems to make sense to me at the time
15:52:06 <bernalex> mjrosenb: I concur with bergmark. there's also ApplicativeDo. or maybe that's not done yet.
15:52:17 <bergmark> it's in 7.10 iirc
15:52:22 <bernalex> orly?
15:52:34 * mjrosenb actually has like 8 things, and it is getting confusing, having the values separated from the variables by so much text
15:53:50 <bergmark> i'm not sure.... but i thought that was part of the motivation behind making applicative a superclass of monad
15:54:03 <bergmark> apart from it just making sense :P
15:54:14 <mpickering> There is an ApplicativeDo patch, D729
15:54:41 <bergmark> mpickering: what does D729 mean?
15:55:00 <bernalex> bergmark: phabricator differential
15:55:08 <mpickering> https://phabricator.haskell.org/D729
15:55:13 <bergmark> ah
15:55:47 <bergmark> Excuse meh
15:55:50 * hackagebot OpenSCAD 0.2.1.1 - ADT wrapper and renderer for OpenSCAD models.  http://hackage.haskell.org/package/OpenSCAD-0.2.1.1 (MikeMeyer)
15:58:55 <bstro9000> Haskell is cool.
15:59:08 <bernalex> so is liquid nitrogen.
15:59:48 <mjrosenb> not as cool as liquid helium
16:01:48 <ReinH> mjrosenb: f doesn't appear anywhere on the right hand side of the =>, which isn't a type level expression anyway, so I am... confused.
16:03:01 <bergmark> bstro9000: you know it!
16:06:31 <mjrosenb> ReinH: err, derp.
16:07:35 <mjrosenb> ReinH: yeah. I'm a bit tired, and I just forgot to annotate everything.  all of the variables ro the right of <$> should have type f X
16:07:43 <mjrosenb> where X is the name of the variable.
16:10:50 * hackagebot bower-json 0.4.0.0 - bower.json from Haskell  http://hackage.haskell.org/package/bower-json-0.4.0.0 (hdgarrood)
16:18:44 <mac10688> Anyone use sublimehaskell?
16:19:00 <KaneTW> what about it
16:19:57 <mac10688> Well I have it installed but it's telling me ghc-mod isn't found. I'm not blocked from compiling or testing my work. I just don't know how to fix it or if it's worth it. I tried looking up the answer but nothing made sense to me
16:20:56 <KaneTW> well, did you install ghc-mod and is it in your path?
16:24:08 <mac10688> No I hadn't truthfully. I didn't realize it was something to install. When you asked that I went to cabal and typed in cabal install ghc-mod. Just got a bunch of stuff missing. The ReadMe didn't mention anything about ghc-mod. I'll dig into. Thank you
16:43:39 <darkroom> if i wanted to parse 2 digits of hex from a string using attoparsec how would i do that?
16:43:51 <darkroom> because take 2 *> hexadecimal 
16:43:55 <darkroom> does the oppisite of what i want
16:47:40 <Hijiri> liftA2 (,) hexadecimal hexadecimal ?
16:48:03 <kadoban> Naw, hexidecimal consumes an entire number, of unspecified length.
16:48:27 <darkroom> kadoban: has it correct
16:48:31 <Hijiri> oh
16:48:42 <Hijiri> wouldn't you need a new parser for one digit
16:48:55 <Hijiri> or maybe there is something like that already
16:49:07 <darkroom> Hijiri: what do you mean
16:49:35 <kadoban> darkroom: You'll probably have to do 'blah <$> count 2 (satisfy isHexDigit)'   where blah converts the digits to actual hex
16:50:00 <darkroom> kadoban: i will test that 
16:50:37 <darkroom> kadoban: but then i have to write my own hex converter :/
16:50:56 <darkroom> kadoban: hexadecimal is a built in parser 
16:50:57 <kadoban> darkroom: There should be one around somewhere, I just didn't feel like looking it up.
16:51:24 <grpala> Numeric.readHex
16:51:27 <athan> fudge - I wish I could specialize the behaviour of a function based on the type it has :(
16:51:30 <kadoban> There's almost certainly a String -> Integral that can do hex, I don't recall what it's called and I'm lazy, and it's not my problem ;)
16:51:42 <athan> (or type of it's input)
16:52:04 <pavonia> > readHex "a0"
16:52:06 <lambdabot>  [(160,"")]
16:52:18 <darkroom> thanks guys
17:04:12 * hackagebot bower-json 0.4.0.0 - bower.json from Haskell  http://hackage.haskell.org/package/bower-json-0.4.0.0 (hdgarrood)
17:04:12 * hackagebot trace 0.2.0.0 - A monad transformer for tracing provenience of errors  http://hackage.haskell.org/package/trace-0.2.0.0 (JonSterling)
17:30:09 <Raiinb> so if you don't have constructors, what do you have
17:31:21 <ion> Void?
17:36:48 <Tiddles> lambdas
17:42:55 <yac> data Foo = Foo Int | Bar String
17:43:06 <yac> is this a product type or both sum type and product type?
17:44:02 <hpc> Int + String
17:44:35 <mgsloan> Haskell datatypes are always a sum of product types.  In this case, the product types have only one field, so they're a bit of a trivial product type
17:44:52 <yac> oh well, could be Foo Int String
17:45:18 <yac> but I was not clear on wheter those are either a sum type or a product type or they can be both
17:45:23 <monochrom> this is only a sum type
17:45:47 <mgsloan> Yeah, I suppose calling the constructors product types could be misleading, my bad!
17:45:50 <monochrom> another example contains both
17:46:00 <ion> data Foo = Foo A B | Bar C D is (A × B) + (C × D)
17:46:23 <monochrom> yes, like that. add more fields to get product types inside
17:46:52 <monochrom> although, I should not ignore the degenerate case. 1 field is a product type, too.
17:47:08 <ion> And 1 data constructor is a sum type, too. :-P
17:47:09 * mgsloan would argue that "data Foo = Foo Int | Bar String" is "(1 x Int) + (1 x String)"
17:47:16 <mgsloan> yeah
17:55:54 <athan> if I need a transformer function like this: `foo :: FooT m (BarT m a) -> BazT m (Foo (Bar a))`, where `runFooT :: FooT m a -> m (Foo a)` and `runBarT :: BarT m a -> m (Bar a)`, how can I run BarT in the same lifted monad `m`?
18:00:34 <athan> I can't really fmap a `lift` properly, can I?
18:04:52 <pavonia> athan: Do you have an unFoo?
18:05:50 <athan> pavonia: Well, it's a map, so it would still just return a functor of `a`'s
18:06:09 <athan> oh wait...
18:06:41 <athan> maybe FoldM, with a Foo map as an accumulator? So it's like `id`, but over a monad?
18:08:35 <pavonia> Not sure I understand correctly, to me it looks like just do { a <- runFooT ...; b <- runBarT (unFoo a); ...}
18:09:16 <athan> pavonia: Imagine `unFoo :: Foo a -> [a]` :\
18:10:19 <pavonia> Then some kind of monadic fold, I guess
18:11:34 <athan> so really, I'd want to `foldM (\b acc -> (flip insert acc) <$> runBarT b) mempty (runFooT ...)` or something :s
18:11:37 <athan> thanks pavonia
18:13:53 <pavonia> I don't feel I was much of help here, but you're welcome :)
18:16:07 <_ryan> hi how to check if a varaible is empty? this variable is a text type.
18:17:31 <peddie> :t Data.Text.null
18:17:32 <lambdabot> Data.Text.Internal.Text -> Bool
18:17:48 <peddie> _ryan: ^
18:19:09 <_ryan> peddie: can i do that in if else?
18:20:28 <peddie> _ryan: try it :)
18:20:53 <pavonia> Note that this doesn't mean your variable is empty but it holds a value that represents an empty text/string
18:21:11 <peddie> pavonia: what would an empty variable be?
18:21:24 <_ryan> > if Nothing then return "nothing" else "has data"
18:21:25 <lambdabot>      Couldn't match expected type ‘Bool’ with actual type ‘Maybe a0’
18:21:25 <lambdabot>      In the expression: Nothing
18:21:25 <lambdabot>      In the expression: if Nothing then return "nothing" else "has data"    C...
18:21:26 <pavonia> It doesn't exist in Haskel, AFAIK
18:21:40 <peddie> pavonia: OK, that's what I think as well
18:21:45 <Axman6> if needs a boolean value
18:21:50 <_ryan> > if Maybe Nothing then return "nothing" else "has data"
18:21:51 <lambdabot>      Not in scope: data constructor ‘Maybe’
18:21:52 <lambdabot>      Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
18:21:56 <Axman6> > if True then "Yes" else "No"
18:21:57 <lambdabot>  "Yes"
18:22:06 <Axman6> > ifnull "" then "Yes" else "No"
18:22:07 <lambdabot>  <hint>:1:11: parse error on input ‘then’
18:22:09 <Axman6> > if null "" then "Yes" else "No"
18:22:10 <lambdabot>  "Yes"
18:22:14 <benzrf> guys
18:22:30 <benzrf> if you show people how to do things correctly without helping them understand why they are wrong
18:22:34 <benzrf> where's the learning?
18:22:36 <_ryan> i forgot does Text type is also a list?
18:22:49 <Axman6> no
18:22:53 <Axman6> String is a list
18:23:09 <Axman6> Text is an opaque type
18:23:15 <_ryan> so i need to convert the text to string before i check it right?
18:23:27 <peddie> _ryan: the Data.Text module defines its own 'null' function that works on the Text type rather than lists like the "null" Axman6 showed
18:23:28 <Axman6> why?
18:25:19 <_ryan> >if null "this is string/text" then "yes" else "no"
18:25:27 <_ryan> > if null "this is string/text" then "yes" else "no"
18:25:28 <lambdabot>  "no"
18:26:32 <arkeet> :t pack
18:26:33 <lambdabot>     Not in scope: ‘pack’
18:26:33 <lambdabot>     Perhaps you meant one of these:
18:26:33 <lambdabot>       ‘BS.pack’ (imported from Data.ByteString),
18:26:37 <arkeet> :t T.pack
18:26:38 <lambdabot>     Not in scope: ‘T.pack’
18:26:38 <lambdabot>     Perhaps you meant one of these:
18:26:38 <lambdabot>       ‘L.pick’ (line 177), ‘BS.pack’ (imported from Data.ByteString)
18:26:44 <arkeet> no Data.Text hm.
18:26:48 <arkeet> @let import qualified Data.Text as T
18:26:49 <lambdabot>  .L.hs:113:1:
18:26:49 <lambdabot>      Data.Text: Can't be safely imported!
18:26:49 <lambdabot>      The package (text-1.2.0.4) the module resides in isn't trusted.
18:26:52 <peddie> arkeet, you have to say Data.Text.pack
18:26:53 <arkeet> lol
18:26:56 <peddie> :t Data.Text.pack
18:26:57 <_ryan> peddie- if i use the null function it will check if the string/text is empty right? if empty it will return false if not empty return true?
18:26:58 <lambdabot> String -> Data.Text.Internal.Text
18:27:01 <arkeet> heh.
18:27:11 <arkeet> _ryan: empty -> True
18:27:16 <peddie> _ryan: again, I suggest you try it AND read the documentation
18:27:20 <pacak> You can always use unsafeCorce....
18:27:20 <pacak> Prelude Unsafe.Coerce> if unsafeCoerce "A string" then "Not null" else "Null"
18:27:21 <pacak> "Not null"
18:27:21 <pacak> Prelude Unsafe.Coerce> if unsafeCoerce "" then "Not null" else "Null"
18:27:21 <pacak> "Null"
18:27:39 <arkeet> pacak: that's terrible.
18:27:41 <arkeet> :-)
18:27:53 <benzrf> o my god
18:28:02 <jmcarthur> please disregard
18:28:18 <benzrf> do ifs desugar to cass
18:28:18 <pacak> arkeet: That's universal and flexible!
18:28:21 <benzrf> *cases
18:28:33 <pacak> benzrf: yes
18:28:37 <peddie> _ryan: https://hackage.haskell.org/package/text-1.2.0.4/docs/Data-Text.html#v:null
18:28:41 <jmcarthur> benzrf: an if in haskell is a case in ghc core
18:29:36 <benzrf> yeah thats p much what i was askin
18:29:54 <peddie> > if Data.Text.null (Data.Text.pack "butts") then "it's null" else "there is some text"
18:29:56 <lambdabot>      Not in scope: ‘Data.Text.null’
18:29:56 <lambdabot>      Perhaps you meant ‘Data.List.null’ (imported from Data.List)Not in scope...
18:29:59 <peddie> aww
18:30:20 <peddie> she can type check them but not run them :/
18:32:44 <peddie> _ryan: if you're getting confused by 'Nothing' vs. 'False' and how 'if/then/else' works, maybe it's worth going through an introductory tutorial again :)
18:33:14 <_ryan> peddie i try it - and it works thank you :)
18:33:31 <peddie> _ryan: no problem, good luck
18:36:42 <P4Titan> Hello all, I am having some trouble here: I have a: type NGramTrie k = Data.Map.Map k (TrieNode k) and am tring to instance Show on it. TrieNode is a data which is deriving Show. I cannot seem to get the instance show on the NGramTrie working, haskell complains that it is an illegal instance creation.
18:37:28 <ion> You can't specify instances for type aliases.
18:38:17 <P4Titan> How should I make it show that printing NGramTrie is pretty, as it is quite hard to read with the way Data.Map.Map formats
18:39:01 <yac> why does this test fail? https://github.com/yaccz/yac-build-server/blob/drop-ybs-config/tests/unit/YacBuildServer/ServerSpec.hs
18:39:13 <ion> You can wrap it in a newtype and define an instance for that.
18:41:02 <pavonia> ion: Isn't that what TypeSynonymInstances is for?
18:41:15 <arkeet> you can't define different instances for type synonyms.
18:41:20 <arkeet> because they are the same type.
18:41:22 <yac> oh, it's probably the same as first hit on SO
18:41:57 <Moggle1> P4Titan: ion's solution works, but is there any reason you want a show instance in particular? you could just make your own prettyPrint function.
18:42:09 <geekosaur> TypeSynonymInstances is dangerous, specifically because a type alias is not a distinct type
18:42:10 <arkeet> P4Titan: I suggest writing a different function, instead of using Show.
18:42:54 <P4Titan> why is that?
18:43:26 <arkeet> the purpose of Show isn't really for pretty printing. generally its output should look something like a Haskell expression, that could be read back with Read.
18:43:37 <pavonia> arkeet: Say you have type Foo = Bar, does that mean you can't define a certain instance for both Foo and Bar even with TypeSynonymInstances enabled?
18:43:45 <arkeet> pavonia: Foo and Bar are the same type.
18:43:55 <arkeet> you can't have two different instances on the same type.
18:44:01 <arkeet> for the same class.
18:44:24 <arkeet> TypeSynonymInstances just expands type synonyms in instance declarations.
18:44:25 <pavonia> What does TypeSynonymInstances exactly do then?
18:44:44 <exio4> it's black magic 
18:44:45 <arkeet> if you write type Foo = Bar and use TypeSynonymInstances,
18:44:53 <arkeet> then instance C Foo is exactly the same as instance C Bar
18:45:07 <pavonia> Okay, that's what I meant
18:45:15 <geekosaur> it turns off the check for a type synonym; instance duplication will still be an error, it's on you to know what you are doing
18:45:24 <arkeet> in particular, you can't write instance C Bar somewhere, and instance C Foo somewhere else.
19:12:50 <KaneTW> huh
19:13:12 <KaneTW> @let s1 t@(a,_) = (a + 1, t)
19:13:15 <lambdabot>  Defined.
19:13:18 <KaneTW> @let s2 = s1.s1
19:13:20 <lambdabot>  Defined.
19:13:22 <KaneTW> :t s2
19:13:23 <lambdabot> Num t => (t, t1) -> (t, (t, (t, t1)))
19:13:26 <KaneTW> weirddd
19:13:29 <arkeet> :t s1
19:13:30 <lambdabot> Num t1 => (t1, t) -> (t1, (t1, t))
19:13:42 <KaneTW> :t s1.s1
19:13:43 <lambdabot> Num t1 => (t1, t) -> (t1, (t1, (t1, t)))
19:13:44 <KaneTW> :t s1.s1.s1
19:13:45 <lambdabot> Num t1 => (t1, t) -> (t1, (t1, (t1, (t1, t))))
19:13:48 <KaneTW> :t s1.s1.s1.s1
19:13:49 <lambdabot> Num t1 => (t1, t) -> (t1, (t1, (t1, (t1, (t1, t)))))
19:13:58 <arkeet> that is like duplicate for the (,) t comonad
19:14:13 <KaneTW> for some reason ghc 7.8.4 is giving me integer at the s2 step
19:14:23 <arkeet> monomorphism restriction
19:14:34 <KaneTW> thought so
19:15:00 <KaneTW> and yeah, makes sense that it doesn't work with let then
19:15:50 <KaneTW> oh ghci disables it
19:16:33 <arkeet> yeah I think they made that the default in 7.8
19:34:14 * hackagebot getopt-generics 0.4.1 - Simple command line argument parsing  http://hackage.haskell.org/package/getopt-generics-0.4.1 (SoenkeHahn)
19:59:16 <pacak> I'm trying to compile something using "cabal sandboxes - cabal build --ghc-option=-O0 TehProject", but it seems to be ignoring --ghc-option=-O0 part (as well as -j10) - no matter which values I try it always compiles with -O and -j12. Any suggestions?
20:00:17 <pacak> (I can override -j by passing option directly to cabal itself, but there's no way to override -O this way)
20:01:54 <arkeet> it's --ghc-options
20:04:09 <yac> Why do I need the two fmaps here https://github.com/yaccz/yac-build-server/blob/master/library/YacBuildServer/Jobs.hs#L114 ?
20:04:36 <arkeet> because you have two Functor layers.
20:04:37 <arkeet> :t fmap . fmap
20:04:39 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
20:04:49 <arkeet> also (<$>) a <$> b looks really odd.
20:05:02 <yac> yeah it does
20:05:06 <brrrrrrrrrian> hello
20:05:11 <arkeet> I'd rather (fmap . fmap) a b
20:05:38 <yac> but what is the second functor?
20:05:44 <pacak> arkeet: It's both --ghc-options and --ghc-option, I've tried both of them
20:05:50 <yac> I know I get Either from exe 
20:06:02 <brrrrrrrrrian> I'm having trouble walking an AST...  was wondering if someone could look at this quick example and provide some pointers: http://lpaste.net/130779
20:06:23 <arkeet> yac: I dunno. what's the type of (exe . cmd $ rJobDataSource j)?
20:06:55 <yac> oh
20:07:09 <brrrrrrrrrian> My loose understanding of Data.Traversable is that you can run a function and preserve the shape of the data... I think this is what I'm going for, but I don't see how to apply it to my example
20:07:15 <yac> RemoteJobRunner (Either TestResult CmdResult)
20:07:36 <arkeet> ok, so I guess RemoteJobRunner and Either TestResult are functors.
20:07:40 <pacak> brrrrrrrrrian: F-Algebras?
20:07:41 <arkeet> so you need two fmaps to get at the CmdResult
20:07:59 <yac> but RemoteJobRunner is also where it is executed
20:08:10 <enthropy> brrrrrrrrrian: Traversable would only apply if you had data Program stmt = Program [Decl stmt];
20:08:11 <yac> what I am getting is actually the Either
20:08:47 <brrrrrrrrrian> pacak: would that be the simplest way to do what I'm trying to do? I haven't learned about f-algebras
20:08:57 <brrrrrrrrrian> enthropy: oh
20:09:41 <enthropy> brrrrrrrrrian: you could start with mapStmt :: (Stmt -> Stmt) -> (Decl -> Decl)
20:09:42 <pacak> brrrrrrrrrian: Well, your code looks very similar to them. Also check about GATDs
20:09:43 <johnchen902> @pl (\x -> x `rem` 3 == 0)
20:09:44 <lambdabot> (0 ==) . (`rem` 3)
20:09:49 <yac> (<$>) /*no idea why*/ (const repo) <$> /*replace Right _ with repo*/ (exe .cmd $ rJobDataSource j) /* executed command cmd $ ...; returns an Either */
20:10:14 <yac> that's what I think it does
20:12:16 <enthropy> brrrrrrrrrian: but that's lots of work since you need one clause for every constructor in your data
20:13:24 <johnchen902> @pl (\x -> head . filter ((==0) . (`rem` x)). iterate ((+1).(*10)) $ 1)
20:13:24 <lambdabot> flip (head .) 1 . (. iterate ((1 +) . (10 *))) . filter . ((0 ==) .) . flip rem
20:13:51 <enthropy> you might add deriving (Data,Typeable), and then have  someFunction :: (Stmt -> Stmt) -> Program -> Program; somefunction f = everywhere (mkT f)
20:14:23 <enthropy> (which is using syb/Data.Generics which is one of a hundred libraries for generic programming)
20:16:07 <KaneTW> @pl \x y -> (<$>) x <$> y
20:16:07 <lambdabot> (<$>) . (<$>)
20:16:27 <brrrrrrrrrian> I'd love to implement something like Pandoc's walk, but I don't understand it.. http://hackage.haskell.org/package/pandoc-types-1.12.4.2/docs/src/Text-Pandoc-Walk.html
20:16:39 <arkeet> please write fmap instead of prefix (<$>)
20:16:44 <arkeet> seriously :(
20:16:51 <MP2E> haha
20:16:58 <MP2E> yeah it looks a bit odd here :v
20:17:06 <bitemyapp> arkeet: sometimes I write intentionally obtuse Haskell code just because I'm in a fey mood.
20:17:16 <arkeet> well that's fine if it's your intention
20:17:19 <bitemyapp> arkeet: at least it can be refactored ;)
20:17:28 <arkeet> but then I'd have to question your sanity
20:17:36 <Denommus> @pl \x y -> fmap x <$> y
20:17:36 <lambdabot> (<$>) . fmap
20:17:59 <arkeet> fmap x `fmap` y
20:18:19 <KaneTW> :t (<*>).(<*>)
20:18:20 <lambdabot> (a -> a1 -> b) -> ((a -> a1) -> a) -> (a -> a1) -> b
20:18:45 <arkeet> :t liftA2 . liftA2
20:18:46 <lambdabot> (Applicative f, Applicative f1) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
20:18:53 <KaneTW> @unpl (<*>).(<*>)
20:18:53 <lambdabot> (\ c -> (<*>) ((<*>) c))
20:18:57 <arkeet> :t (liftA2 . liftA2) id
20:18:58 <lambdabot> (Applicative f, Applicative f1) => f (f1 (b -> c)) -> f (f1 b) -> f (f1 c)
20:19:05 <bob_twinkles> how does GHC[i] decide between using a, a1, a2 etc.  versus a, b, c...?
20:19:11 <arkeet> arbitrarily.
20:19:28 <arkeet> usually if you see a, b, c it's because someone used those letters in some type annotation somewhere.
20:19:39 <arkeet> and it adds numbers when it has to make a new one.
20:19:46 <arkeet> :t \x -> x
20:19:47 <lambdabot> r -> r
20:20:27 <bob_twinkles> fair enough =P
20:20:43 <zilinc_> @bob_twinkles: I remember it's introduced in "Secrets of the Glasgow Haskell Compiler inliner" paper
20:20:43 <lambdabot> Unknown command, try @list
20:21:19 <bob_twinkles> hmm, sounds like an interesting read. thanks zilinc_ 
20:21:34 <zilinc_> @pl \(x,y,z) -> (x,y)
20:21:35 <lambdabot> (line 1, column 7):
20:21:35 <lambdabot> unexpected "z"
20:21:35 <lambdabot> ambiguous use of a non associative operator
20:21:47 <arkeet> lol what
20:21:52 <zilinc_> any knows how to solve this lambda bot problem?
20:21:55 <reduceleft> wow, could it be that the Haskell channel has more users than the C++ channel. Awesome.
20:22:09 <arkeet> @pl \(x,y) -> (x,y,y)
20:22:09 <lambdabot> uncurry (join . (,,))
20:22:14 <arkeet> @pl \(x,y,z) -> (x,y,z)
20:22:14 <lambdabot> (line 1, column 7):
20:22:15 <lambdabot> unexpected "z"
20:22:15 <lambdabot> ambiguous use of a non associative operator
20:22:16 <KaneTW> :t z
20:22:17 <lambdabot> Expr
20:22:23 <arkeet> I guess @pl doesn't know how to do tuples bigger than 2.
20:22:29 <zilinc_> it seems that lambda bot doesn't know the precedence of commas
20:22:56 <zilinc_> :t (x,t,z)
20:22:57 <lambdabot> (Expr, Expr, Expr)
20:23:14 <arkeet> it's just @pl
20:23:15 <KaneTW> @pl a -> (a,a,a)
20:23:16 <lambdabot> (line 1, column 5):
20:23:16 <lambdabot> unexpected '>'
20:23:16 <lambdabot> expecting operator
20:23:20 <KaneTW> oos
20:23:22 <KaneTW> oops
20:23:25 <KaneTW> @pl \a -> (a,a,a)
20:23:25 <lambdabot> join (join (,,))
20:23:40 <KaneTW> @pl \a b c -> (a,b,c)
20:23:40 <lambdabot> (,,)
20:23:47 <arkeet> please experiment in private message instead
20:23:58 <zilinc_> only in lambda..
20:24:16 * hackagebot extensible 0.3.4 - Extensible, efficient, lens-friendly data types  http://hackage.haskell.org/package/extensible-0.3.4 (FumiakiKinoshita)
20:24:23 <KaneTW> i guess it can't pattern match 3-tuples
20:24:53 <arkeet> right
20:25:16 <zilinc_> for some reason, tuples in haskell are not like, say ML tuples, which associate to the right
20:26:07 <AfC> It'd be nice if we could teach hackagebot not to publish an announcement until after the docs were compiled.
20:26:28 <arkeet> nested tuples are slower.
20:27:40 <zilinc_> arkeet: true, but they don't have a limit on max width
20:29:07 <enthropy> a 60-something tuple isn't big enough for everybody?
20:29:49 <KaneTW> data Pattern ... | PTuple Pattern Pattern
20:30:26 <arkeet> even 3-tuples are pretty rare in practice I think
20:49:39 <angerman> given a tuple (a,a) and a function a -> b, is there a function that would do (a -> b) -> (a,a) -> (b,b) ?
20:49:44 <angerman> Hoogle didn't help me much :(
20:50:47 <arkeet> not directly.
20:50:49 <glguy> over both 07:: (a 07-> b) 07-> (a,a) 07-> (b,b)
20:50:54 <arkeet> lens provides this ^
20:50:59 <jle`> in base you can do f *** f
20:51:04 <arkeet> oh yeah there is that.
20:51:14 <arkeet> from Control.Arrow
20:51:17 <jle`> > ((+2) *** (+2))  (5, 7)
20:51:19 <pavonia> :t join (***)
20:51:19 <lambdabot>  (7,9)
20:51:19 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
20:51:31 <angerman> ahh *** :)
20:52:02 <glguy> If you don't mind duplicating the function like that you can use Data.Bifunctor's bimap (it's in base)
20:52:06 <glguy> and avoid getting arrows on your code
20:52:14 <arkeet> :t join bimap
20:52:14 <lambdabot> Bifunctor p => (a -> b) -> p a a -> p b b
20:52:16 <jle`> specialized for (->), (***) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
20:52:51 <angerman> hm. 
20:53:15 <jle`> Arrow isn't really the best abstraction for this, but using *** in your code doesn't mean that your code has arrows
20:53:32 <jle`> you just use the specific instance :)
20:53:36 <glguy> Once you import the module you're part of the problem!
20:54:00 <pavonia> What's the problem with arrows?
20:54:00 <bob_twinkles> what's wrong with Arrow?
20:54:03 <glguy> If you were using a "Pair" type instead of (a,a) this operation would be fmap
20:54:30 <dfeuer> Arrow is not general enough, and maybe also a little too general.
20:54:35 <glguy> It's just a messy abstraction, generally close to what you want, but not what you want
20:54:39 <jle`> Arrow's problems aren't really too relevant here...it's just (***) and (&&&) might not be the best way to "generalize" mapping over tuples
20:54:43 <glguy> unless you're looting it for combinators on (->)
20:54:56 <arkeet> :t over each :: (a -> b) -> (a,a,a,a) -> (b,b,b,b)
20:54:57 <lambdabot> (a -> b) -> (a, a, a, a) -> (b, b, b, b)
20:56:18 <angerman> Ahh ok. so let's start from the beginning. Assume x :: Text, now I'm intending to split on a line that starts with "TRACE: [", so I was thinking about something along the lines of: mySplit l = unlines *** (break (isPrefixOf "TRACE: [") (lines l))
20:56:53 <jle`> arrow's intended purpose wasn't really meant to be used as tuple manipulation functions, really, but people abuse the (->) instance to do that.  so it's a little awkward, because if you want to do tuple maniupulation, iut's a weird way to generalize
20:57:07 <johnchen902> @pl (\x y -> zip y (map x y))
20:57:08 <lambdabot> ap zip . map
20:57:16 <geekosaur> prepend a newline and break "\nTRACE: ["?
20:58:07 <angerman> Hm... 
20:58:53 <jle`> johnchen902: you can always pm lambdabot, btw :)
20:58:59 <angerman> now I need a different break.
20:59:25 <arkeet> \x -> zip <*> map x
20:59:26 <johnchen902> @pm lambdabot @pl (\x y -> zip y (map x y))
20:59:26 <lambdabot> lambdabot @ pl (ap zip . map)
20:59:28 <angerman> ahh breakOn.
20:59:48 <geekosaur> /msg lambdabot ...
20:59:59 <angerman> Thanks geekosaur 
21:00:06 <geekosaur> or /query to (in most clients) open a new window/tab
21:19:52 <ttt_fff> is there a way to get "prolog as a haskell monad" ? 
21:20:10 <ttt_fff> I want to do prolog style (generate + test / relational programming), but I want do it in a typeful way in Haskell
21:20:17 <ttt_fff> I'm wondering if prolog's model can be captured as a ahskel monad
21:20:23 <ttt_fff> this would be so fucking cool
21:20:28 <ttt_fff> please say yes
21:21:26 <enthropy> @hackage logict
21:21:27 <lambdabot> http://hackage.haskell.org/package/logict
21:25:05 <slack1256> ttt_fff: https://hackage.haskell.org/packages/search?terms=prolog
21:25:14 <slack1256> Seems to be insterest
21:30:07 <ttt_fff> is there a logict tutotial?
21:30:17 <ttt_fff> or is all we have simply the whitepaper ?
21:32:41 <alonq> Recently tried Haskell and have a question. I'm trying out Data.Vector.Unboxed. Does the vector being unboxed imply that all the values are strict? None of them will be calculated lazily?
21:35:05 <alonq> For example, if I used Data.Vector.Unboxed.iternateN, does it imply that that all N values of the vector will be calculated strictly?
21:35:51 <heatsink> alonq: They are calculated strictly, but there are some loop fusion optimizations
21:36:09 <shachaf> That's easy enough to test yourself. :-)
21:36:17 <shachaf> But yes, you can expect that.
21:36:46 <heatsink> If one library call is passed as the input to another, and they both traverse the vector from beginning to end, the temporary vector won't be created
21:37:05 <heatsink> For example, sum $ map (2 *) $ iterate 100
21:37:17 <heatsink> will not create any vectors
21:37:53 <heatsink> on the other hand, let x = iterate 100 in sum x + sum (map (2 *) x) will create x
21:38:34 <heatsink> If you want to _explicitly_ not create intermediate vectors, use Data.Vector.Fusion.Stream
21:38:42 <shachaf> But that doesn't change strictness.
21:39:14 <alonq> So can I use the rule of thumb that if a data structured is unboxed, it is strict and if it is boxed, it is probably lazy?
21:39:41 <heatsink> yes
21:40:19 <heatsink> There is no way to represent thunks in unboxed form, so unboxed values have to be computed strictly
21:41:04 <heatsink> I'm not clear on how strictness interacts with operations that discard results
21:41:37 <alonq> That would explain why there is iterateN but no iterate in the Data.Vector.Unboxed module.
21:41:45 <alonq> Thanks.
21:42:16 <shachaf> I would assume that every vector is spine-strict, unboxed or not.
21:42:36 <shachaf> So you won't find iterate in Data.Vector either.
21:44:46 <arkeet> infinite vectors don't exist.
21:51:06 <heatsink> > let {f 1 = undefined; f x = x :: Int} in Data.Vector.Unboxed.last $ Data.Vector.Unboxed.map f $ Data.Vector.Unboxed.enumFromN 0 10
21:51:08 <lambdabot>  Not in scope: ‘Data.Vector.Unboxed.last’Not in scope: ‘Data.Vector.Unboxed.m...
21:51:52 <heatsink> If you create a vector containing [0, _|_, 2, 3], you can get the 3 without forcing evaluation of the _|_
21:52:53 <heatsink> And that behavior depends on whether optimizations are turned on
21:53:10 <heatsink> So optimizations do affect strictness in Data.Vector.Unboxed
21:59:20 * hackagebot Dist 0.1.0.0 - A Haskell library for probability distributions  http://hackage.haskell.org/package/Dist-0.1.0.0 (wyager)
22:04:21 * hackagebot getopt-generics 0.5 - Simple command line argument parsing  http://hackage.haskell.org/package/getopt-generics-0.5 (SoenkeHahn)
22:05:48 <timothyh> hmm. cabal unpack doesn't quite do what i want
22:05:59 <arkeet> what is it that you want?
22:06:15 <timothyh> i'm trying to use it in a makefile, so I wanna know in advance the path it'll unpack to
22:06:37 <timothyh> but say 'cabal unpack alex -d alex' will create alex/alex-3.1.4
22:07:38 <arkeet> are you able to specify the exact version of the package?
22:08:14 <timothyh> I guess I could use a specific version when i cabal fetch
22:08:42 <timothyh> would rather not though, since it's just happy and alex, both binaries.
22:09:55 <arkeet> maybe a makefile isn't quite the thing to use then.
22:10:10 <arkeet> or maybe you can have a small script that unpacks it and then moves it to a specified directory.
22:10:13 <arkeet> and use that in your makefile
22:10:24 <timothyh> this is for the halvm, and it's a monkey patch to postpone a full rewrite of the build system
22:10:25 <timothyh> lol
22:10:29 <arkeet> lol
22:10:49 <yac> I have roughly runMain = evalStateT serve mkYBServer where serve = evalState serveOne mkConnection ... now how do I get state from YBServer in Connection?
22:13:33 <yac> I suspect I need to lift get somehow
22:21:45 <Aearnus> Okay, I'm kind of stumped
22:21:58 <Aearnus> I'm trying to write a little program for this http://mathworld.wolfram.com/TuppersSelf-ReferentialFormula.html
22:23:04 <Aearnus> I can't figure out how to write the function itself. this is what I have so far http://lpaste.net/3664501745175756800
22:23:38 <Aearnus> But, I'm not sure what to do about the types of x and y. I need them to be unbounded as I have to deal with really huge numbers, but I need to be able to divide them also
22:23:46 <Aearnus> So I can't use Integer
22:24:05 <arkeet> Rational?
22:25:12 <Aearnus> Hmm, that seems to be exactly what I need
22:25:14 <Aearnus> Thanks!
22:28:00 <arkeet> although mod doesn't work on that (only Integral types)
22:28:32 <arkeet> but you can probably write your own mod for rationals using some RealFrac methods.
22:28:49 <Aearnus> Well, I'm running floor on it before I mod it every time, so that's probably not a problem
22:29:05 <arkeet> I mean the outermost mod.
22:29:39 <Aearnus> I see, hmm
22:29:41 <arkeet> also, (^) only works for nonnegative exponents
22:29:46 <arkeet> you should use (^^)
22:30:06 <arkeet> or just do 1/2 ^ some positive exponent.
22:30:44 <arkeet> :t (^)
22:30:45 <lambdabot> (Integral b, Num a) => a -> b -> a
22:30:45 <arkeet> :t (^^)
22:30:46 <lambdabot> (Fractional a, Integral b) => a -> b -> a
22:30:55 <arkeet> Fractional is needed for division.
22:31:59 <Aearnus> This is sure proving to be a bit trickier than I expected
22:32:30 * glguy extracts the raw expression: 1/2 < Floor[Mod[Floor[y/17] 2^(-17 Floor[x] - Mod[Floor[y], 17]), 2]]
22:33:36 <timothyh> for the eternal irc log record, I did not fix my unpack -d problem - I added cd alex* to my makefile. i am not proud
22:34:58 <arkeet> glguy: now write a mathematica implementation in haskell? 
22:35:41 <Aearnus> I mean, I could just launch R or something from the script and do the calculation there :P
22:36:12 <glguy> I found the raw expression useful to disambiguate the picture
22:39:18 <fresheyeball> hello out there
22:39:24 <fresheyeball> I have a real stupid problem
22:39:55 <fresheyeball> I'm using https://hackage.haskell.org/package/snaplet-postgresql-simple-0.1/docs/Snap-Snaplet-Auth-Backends-PostgresqlSimple.html
22:40:05 <fresheyeball> and trying to get it to connect to a postgresql db
22:40:19 <fresheyeball> and getting this error
22:40:21 <fresheyeball> libpq: failed (FATAL:  database "root" does not exist )
22:40:32 <fresheyeball> nothing I do seems to effect it
22:40:36 <fresheyeball> and I can't find it in the code
22:40:39 <fresheyeball> its a runtime error
22:41:18 <fresheyeball> any idea how I should approach this?
22:42:08 <slack1256> I don't know anything about databases (only a little of sqlite). But isn't usually the database a file that should exist previously to the operation of the program?
22:43:00 <fresheyeball> I have one
22:43:09 <fresheyeball> but no ability to know if it was picked up at runtime
22:44:06 <slack1256> eh, I guess you structured your program as the header of the link
22:44:28 <Aearnus> Oh, instead of using floor() and / I can just use an Integer and `div`
22:44:36 <arkeet> mhm
22:45:13 <arkeet> comparing 1/2 to the floor of a number seems odd to me.
22:45:19 <arkeet> why not just test whether the floor is positive.
22:45:25 <glguy> because the picture has to match
22:45:32 <arkeet> oh.
22:45:47 <arkeet> modify the picture to match your code, then.
22:46:00 <Aearnus> I just had that there because it's in the original formula, I can just do 0 == or whatever instead
22:47:19 <lpaste> glguy pasted “Tupper's” at http://lpaste.net/130780
22:47:21 <Aearnus> Oh, but then there's the problem of the negative exponent still
22:47:34 <arkeet> mhm
22:47:34 <glguy> Don't peek if you're doing it as an exercise :)
22:48:08 <arkeet> that's the longest line I've seen in a lpaste that I can remember.
22:50:23 <Aearnus> glguy: It's just for fun :)
22:50:34 <arkeet> exercises can be for fun :)
22:52:56 <glguy> Aearnus: Sure, I just meant if you were doing it for fun and didn't want to be poisoned
22:54:15 <Aearnus> So, in the outermost call to floor', what would the integer be converted to?
22:54:26 <glguy> floor' :: Rational -> Rational
22:54:52 <Aearnus> Then what's the point to calling fromInteger?
22:55:18 <glguy> floor 07:: (Integral b, RealFrac a) 07=> a 07-> b
22:55:33 <glguy> I'm using Integer as my Integral instance there
22:56:17 <Aearnus> Ohhh, I see
23:03:16 <Aearnus> Woohoo, it works; though the windows console isn't big enough to display the pictures haha
23:07:03 <halvorg> what's the library of choice to send http requests?
23:07:12 <halvorg> just a few simple posts.
23:07:12 <slack1256> HTTP ?
23:07:56 <arkeet> there's also http-conduit
23:09:04 <slack1256> HTTP is in the haskell-platform, you probably have it installed
23:09:40 <halvorg> Network.HTTP.simpleHttp looks good, thanks
23:10:22 <arkeet> http-conduit is fairly nice.
23:10:55 <slack1256> is there any web framework that uses pipes?
23:14:24 * hackagebot gimlh 0.1.3.0 - Haskell parser for GIML  http://hackage.haskell.org/package/gimlh-0.1.3.0 (gazay)
23:16:29 <athan> If you could make an operator that represented an empty RESTful path, what would it be?
23:16:53 <athan> I'm thinking something like `://` or `:/:` or something
23:18:06 <slack1256> mempty?
23:20:45 <athan> slack1256: That'd be a good idea, but I'd also like some syntactic appeal :\
23:22:03 <slack1256> athan: believe me, if you can reuse a common abstraction/names for something (specially monoids) you will win users more easily
23:22:51 <athan> slack1256: I plan on it, but I still want a symbol :(
23:22:56 <athan> maybe `=|`?
23:23:50 <athan> So the end syntax would look like `handle (=| := "foo" </> :~ parseBar </> := "baz")`
23:23:55 <slack1256> ¯\_(ツ)_/¯
23:24:09 <athan> poo. Thanks anyway :)
23:24:42 <mauke> that looks like a bunch of syntax errors
23:24:52 <slack1256> handle ( ¯\_(ツ)_/¯ := "foo" </> :~ parseBar </> := "baz")
23:24:56 <mauke> what is </> :~ supposed to be?
23:25:00 <slack1256> would be a-w-e-s-o-m-e
23:25:15 <yac> lifting feels named backwards. When I think about going inwards, I'm thinking "down". But when I think "lift", I think "up"
23:25:41 <mauke> it's modeled after UFOs
23:25:52 <mauke> imagine a tractor beam lifting a cow into a flying saucer
23:26:08 <yac> rekt
23:26:54 <athan> mauke: </> is cons for UrlChunks, and :~ says "this is a parser, not a literal" :)
23:27:06 <ElectricSolstice> what's a good way of learning haskell?
23:27:20 <yac> ElectricSolstice: like learning anything else. Just do it
23:27:29 <slack1256> ElectricSolstice: Practice, practice, practice. (and project euler)
23:27:36 <ElectricSolstice> Right now, I'm trying to make the hanoi puzzle thing for practice and not sure why one version of this function works over the other
23:28:06 <ElectricSolstice> first version, i'm using http://en.wikipedia.org/wiki/Special:Search?go=Go&search=x to match the first char of a stack
23:28:13 <ElectricSolstice> @_@ wth
23:28:13 <lambdabot>  wth
23:28:32 <yac> ElectricSolstice: I'm often writing SSCCE's just for the purpose of writing my own SSCCE when doing new stuff. like https://github.com/yaccz/code-samples-haskell-connection-counter
23:28:56 <mauke> athan: but you can't have two operators in a row. that's a syntax error
23:29:14 <ElectricSolstice> could someone explain the difference between these two? http://codepaste.net/y36up7
23:29:29 <ElectricSolstice> one, i'm trying to use pattern matching to get the first char of the first list
23:29:48 <mauke> [x] matches a list of exactly one element
23:29:48 <ElectricSolstice> second one, I use the head function to get it
23:29:56 <mauke> [x] is syntactic sugar for (x : [])
23:30:09 <mauke> [x,y,z] is syntactic sugar for (x : (y : (z : [])))
23:30:20 <ElectricSolstice> i see
23:30:25 <mauke> to match the first element, you need (x : _)
23:30:36 <mauke> @src head
23:30:36 <lambdabot> head (x:_) = x
23:30:36 <lambdabot> head []    = undefined
23:31:56 <ElectricSolstice> hmm, how would I pattern match it?
23:32:10 <ElectricSolstice> i put (x:_) inside the list
23:32:15 <ElectricSolstice> still nothing returned
23:35:21 <arkeet> well, you want the first element of the first element.
23:35:26 <arkeet> which would be more like ((x:_):_)
23:36:28 <ElectricSolstice> oh, that worked
23:37:01 <ElectricSolstice> how do you know when to use the parenthesis or the list?
23:38:31 <Axman6> ElectricSolstice: the list syntax is useful when you know you need to match a list with exactly n elements like: foo [a,b,c] = a + b * c; foo xs = 0
23:39:06 <ElectricSolstice> oh
23:39:08 <Axman6> the non-sugar syntax is best when you want to access the first n elements of a list: foo (a:b:c:xs) = a + b*c + foo xs
23:39:37 <Axman6> foo [a,b,c] only matches lists with three elements, but foo (a:b:c:xs) matches lists with at least three elements
23:39:39 <ElectricSolstice> so the list syntax is the sugar?
23:39:54 <Axman6> also, foo [a,b,c] is just sugar for foo (a:b:c:[])
23:39:58 <Axman6> yes
23:40:07 <ElectricSolstice> kk, thanks. Think I get now why the list didn't work.
