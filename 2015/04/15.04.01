00:08:59 * hackagebot dbus 0.10.10 - A client library for the D-Bus IPC system.  http://hackage.haskell.org/package/dbus-0.10.10 (JohnMillikin)
00:08:59 * hackagebot elevator 0.2.3 - Immediately lifts to a desired level  http://hackage.haskell.org/package/elevator-0.2.3 (FumiakiKinoshita)
00:10:37 <frerich> At first I thought the way regex-base works by being polymorphic in its return type is cool, but by now I think it was too much magic for its own good. :-/
00:12:16 <frerich> When doing 'This is T324545 or T5525 ok" =~ "T(\\d+)"', how could I get the matched (sub-)groups, i.e. so that I get ["324545", "5525"]? The only way I found was to do 'ap (!! 1) ("This is T324545 or T5525 ok" =~ "T(\\d+)" :: [[String]])' but that seems a little clumsy.
00:13:31 <arkeet> where is =~ from?
00:13:56 <arkeet> regex-posix?
00:14:32 <frerich> arkeet: I use regex-pcre
00:14:55 <arkeet> oh
00:14:57 <arkeet> close enough it seems
00:15:18 <arkeet> :t ap (!! 1)
00:15:20 <lambdabot> ([a -> b] -> a) -> [a -> b] -> b
00:15:32 <frerich> Err sorry, a 'm' got lost. I meant 'map (!! 1)'
00:15:40 <arkeet> oh that makes more sense.
00:16:25 <arkeet> I dunno, that seems reasonable. (except using (!!) is always a little scary0
00:16:26 <arkeet> )
00:16:43 <frerich> Right, it's the (!!) which made me feel uneasy :)
00:18:53 * hackagebot hspec-meta 2.1.5 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-2.1.5 (SimonHengel)
00:18:55 <arkeet> can't think of a better way heh
00:19:04 <arkeet> other than using some safe indexing function
00:19:20 <arkeet> although you know from the form of the regex that it'll always work...
00:19:38 <arkeet> I think...
00:23:11 <Cale> I believe there are instances of RegexContext that let you get the matches as an array instead of a list
00:26:29 <arkeet> Cale: yes, but array indexing isn't any safer.
00:26:44 <Cale> It's cheap to test that the bounds are what you expect them to be
00:26:51 <arkeet> sure.
00:27:06 <arkeet> but these are lists of length 2.
00:27:10 <Cale> [x | a <- "this is T324545 or T5525 ok" =~ "T([0-9]+)" :: [MatchText String], bounds a == (0,1), (x,_) <- [a ! 1]]
00:27:16 <Cale> Still pretty ugly
00:27:35 <Cale> I guess if you're going to to that, might as well just use the list
00:28:22 <arkeet> [x | [_,x] <- "..." =~ "T([0-9]+)" :: [[String]]]
00:28:25 <arkeet> I dunno.
00:28:42 <Cale> right, something like that
00:28:50 <arkeet> frerich: ^
00:28:54 * hackagebot forecast-io 0.1.0.0 - A Haskell library for working with forecast.io data.  http://hackage.haskell.org/package/forecast-io-0.1.0.0 (stormont)
00:28:59 <L8D> hehehe
00:29:11 <Cale> Or even [x | [_,x] <- "this is T324545 or T5525 ok" =~ "T([0-9]+)"] :: [String]
00:29:15 <arkeet> yeah.
00:29:44 <arkeet> or [x :: String | x <- ...]. (does that require ScopedTypeVariables?)
00:29:50 <Cale> nope
00:30:00 <arkeet> oh, sure it won't.l
00:30:10 <Cale> No type variables to scope :)
00:30:24 <arkeet> I was thinking [x | x :: String <- ...]
00:30:26 <arkeet> that would need it.
00:30:29 <frerich> Thansk for your ideas, guys :-)
00:30:32 <frerich> Thanks, too.
00:31:49 <jle`> pattern matching on [_,x] is even more partial than `drop 1 . head`
00:31:52 <jle`> er, `head . drop 1`
00:32:38 <jle`> concatMap (listToMaybe . drop 1) will only give you inner lists longer than 1
00:32:47 <jle`> er, mapMaybes
00:32:49 <arkeet> head . drop 1 seems unsafe.
00:33:00 <jle`> head . drop 1 is even "more safe" than [_,x]
00:33:10 <arkeet> uh.
00:33:20 <arkeet> > [x | [_,x] <- ["a","bc","def"]]
00:33:22 <lambdabot>  "c"
00:33:23 <jle`> > mapMaybe (listToMaybe . drop 1) [[1,2,3],[],[1,2],[1],[1,2,3]]
00:33:23 <arkeet> looks safe to me.
00:33:24 <lambdabot>  [2,2,2]
00:33:29 <glguy> They're all "safe" but partial
00:33:33 <jle`> oh, forgot it was a list comprehension v.v
00:33:37 <arkeet> yeah.
00:33:51 <jle`> cute :)
00:33:55 <arkeet> > [x | (_:x:_) <- ["a","bc","def"]]
00:33:56 <lambdabot>  "ce"
00:34:05 <frerich> More often than I'd like to admit, the 'fail' behaviour in list comprehensions is actually quite convenient.
00:34:27 <jle`> why "more often"? it's awesome :)
00:34:33 <arkeet> > ([5 | True], [6 | False])
00:34:34 <jle`> embrace it
00:34:34 <lambdabot>  ([5],[])
00:35:04 <frerich> jle`: I mean, in general 'fail' doesn't actually do anything useful (or rather, useful to me) *except* in that case.
00:35:22 <jle`> so what are the cases when the fail behavior in list comprehensions is not what you'd like?
00:35:39 <frerich> jle`: I meant the 'fail' behaviour for other monads
00:35:44 <jle`> ah okay
00:36:00 <jle`> had trouble parsing the original sentence, sorry :)
00:36:19 <frerich> I guess I was being a little on the ambiguous side, ahem.
00:38:48 <joliny> hello! I input :t (1,3) int ghci
00:38:55 <arkeet> :t (1,3)
00:38:56 <lambdabot> (Num t, Num t1) => (t, t1)
00:39:49 <joliny> Prelude> :t (1,2)
00:39:50 <joliny> (1,2) :: (Num t1, Num t) => (t, t1)
00:39:57 <arkeet> indeed.
00:40:01 <joliny> why is not (t1,t)
00:40:12 <arkeet> why is it not (w,banana)
00:40:25 <arkeet> it makes up arbitrary new variable names.
00:40:32 <shachaf> joliny: The order of the constraints is irrelevant.
00:40:36 <arkeet> that too.
00:40:42 <shachaf> (Num t, Num t1) is the same as (Num t1, Num t)
00:40:54 <shachaf> (But (t, t1) isn't the same as (t1, t).)
00:41:03 <shachaf> (Though in this case they're just arbitrary names so it doesn't matter.)
00:41:24 <joliny> thanks
00:43:54 * hackagebot wai-middleware-consul 0.1.0.2 - Wai Middleware for Consul  http://hackage.haskell.org/package/wai-middleware-consul-0.1.0.2 (dysinger)
00:43:56 * hackagebot crackNum 1.0 - Crack various integer/floating-point data formats  http://hackage.haskell.org/package/crackNum-1.0 (LeventErkok)
01:03:52 <frerich> Does anybody know a way to contact Ertugrul Soeylemez ('mmfreak' on IRC)? The email address he used on haskell-* lists and for his packages on Hackage (es@ertes.de) bounces.
01:04:59 <frerich> Aha - a Twitter account. Now I only need to figure out how to message people on Twitter...
01:08:17 <f-a> is there a commonly used Either like sum-type, just with 3 constructors?
01:09:14 <capisce> f-a: Either (Either a b) c ?
01:10:01 <capisce> or Either a (Either b c)
01:10:04 <shachaf> No.
01:10:05 <f-a> well, I was expecting something like data Three a b c = A a | B b | C c
01:10:09 <f-a> but that would do
01:15:42 <hvr> is there a shortcut/combinator for '(Left <$> parser1) <|> (Right <$> parser2))' ?
01:18:22 <shachaf> I'm sure I've seen it.
01:18:26 <shachaf> At least I've written it.
01:18:51 <hvr> I would have expected that one to exist in parsec or in base somewhere
01:18:53 <shachaf> attoparsec calls it eitherP
01:19:02 <hvr> ah... that's where I saw it
01:20:55 <shachaf> It's useful in all sorts of situations, though.
01:23:42 <f-a> a bit messy but yeah, it was one of those moment (Parsec)
01:28:43 <m0rphism> Hey guys, I'm having problems with the OpenGL bindings: everything segfaults, even minimalistic programs only calling GLFW.init or GLUT.createWindow
01:28:50 <m0rphism> Any idea how I could perform diagnosis?
01:29:12 <m0rphism> I'm using NixOS 64bit with proprietary ati drivers, btw
01:56:22 <quchen2> Hmm, Lambdabot is broken :-(
01:56:23 <quchen2> :t 1
01:56:23 <lambdabot> ghc: unrecognised flags: -XEmptyCase
01:56:23 <lambdabot> Usage: For basic information, try the `--help' option.
02:06:11 <joliny> initials :: String -> String -> String  
02:06:11 <joliny> initials firstname lastname = [f] ++ ". " ++ [l] ++ "."  
02:06:12 <joliny>     where (f:_) = firstname  
02:06:12 <joliny>           (l:_) = lastname  
02:06:40 <joliny> why use（f:_） = firstname
02:06:53 <joliny> but not is [f:_] = firstname
02:07:04 <mauke> because that means something completely different?
02:08:06 <joliny> firstname is a list , (f:_) looks like a tuple
02:08:49 <ibid> but isn't
02:09:34 <mauke> no, it doesn't
02:09:47 <mauke> and those parens are redundant
02:09:51 <zipper> :t (/)
02:09:51 <lambdabot> ghc: unrecognised flags: -XEmptyCase
02:09:51 <lambdabot> Usage: For basic information, try the `--help' option.
02:09:58 <mauke> f:_ = firstname
02:10:01 <zipper> What's or>
02:10:02 <mauke> l:_ = lastname
02:10:03 <zipper> *?
02:10:10 <zipper> :t (or)
02:10:10 <lambdabot> ghc: unrecognised flags: -XEmptyCase
02:10:10 <lambdabot> Usage: For basic information, try the `--help' option.
02:10:42 <shachaf> int-e: ☝
02:10:50 <mauke> int-e: are you running lambdabot? because @type is broken
02:11:02 <mauke> zipper: ||
02:11:41 <joliny> ...sorry! my english is not good
02:12:33 <shachaf> λ> typeRep (Proxy :: Proxy A) == typeRep (Proxy :: Proxy B) -- True
02:12:37 <joliny> in erlang , tuple match use (),list match use []
02:12:41 <shachaf> λ> typeRep (Proxy :: Proxy (Proxy A)) == typeRep (Proxy :: Proxy (Proxy B)) -- False
02:12:46 <int-e> huh.
02:13:06 <shachaf> Oh, int-e is here.
02:13:25 <mauke> joliny: haskell uses ( ) for precedence
02:13:31 <mauke> > 2
02:13:33 <lambdabot>  2
02:13:36 <mauke> > (((2)))
02:13:37 <lambdabot>  2
02:13:37 <zipper> mauke: Thankee ^_^
02:13:41 <mauke> same thing, no tuples
02:14:26 <joliny> thank you ,i see.
02:15:17 <mauke> [x,y,z] is syntactic sugar for (x : (y : (z : [])))
02:15:40 <mauke> [x] is syntactic sugar for x : []
02:15:54 <mauke> [f:_] is syntactic sugar for (f : _) : []
02:21:38 <int-e> :t 1
02:21:44 <lambdabot> Num a => a
02:27:12 <int-e> Okay, somehow lambdabot's screen session died and the (as yet untested) cron job that is supposed to restart it doesn't set up the environment variables correctly.
02:33:52 <SwashBuckla> what is going on in this compiler error? http://lpaste.net/5049044015647817728
02:34:03 <SwashBuckla> (here is JoinList.hs http://lpaste.net/5684241383481671680)
02:35:53 <merijn> SwashBuckla: Hard to say without knowing the type of 'size' on line 25
02:36:30 <SwashBuckla> merijn: https://github.com/spanners/cis194/blob/master/Course/answers/07-folds-monoids/Sized.hs
02:36:36 <SwashBuckla> apologies for not including tha
02:37:30 <merijn> SwashBuckla: Try annotating 'm' with a type signature
02:38:20 <merijn> SwashBuckla: Oh, I already see exactly what's happening
02:38:28 <merijn> SwashBuckla: Basically, you have a case of:
02:38:41 <merijn> > show . read $ 5
02:38:43 <lambdabot>      No instance for (Num String) arising from the literal ‘5’
02:38:43 <lambdabot>      In the second argument of ‘($)’, namely ‘5’
02:38:43 <lambdabot>      In the expression: show . read $ 5
02:38:51 <merijn> :t show . read
02:38:52 <lambdabot> String -> String
02:39:09 <SwashBuckla> > show . read $ 5 :: String
02:39:10 <lambdabot>      No instance for (Num String) arising from the literal ‘5’
02:39:10 <lambdabot>      In the second argument of ‘($)’, namely ‘5’
02:39:10 <lambdabot>      In the expression: show . read $ 5 ∷ String
02:39:13 <SwashBuckla> oh dorp
02:39:20 <merijn> SwashBuckla: Arbitrary is polymorphic and so is size, so it's unable to infer which instances you want
02:39:55 <merijn> I suspect that "fmap (size :: MyType -> Size) arbitrary" will make it work
02:44:24 <ij> I know I can't test Control.Concurrent.Chan channels for emptyness, but there be a function that tries to read from a channel and gives up after n miliseconds? 
02:44:46 <ij> I feel like such a function wouldn't need to test for emptiness.
02:46:47 <merijn> ij: You probably want either 1) async's race or 2) STM
02:46:59 <merijn> ij: Incidentally, STM has channels you CAN test for emptiness
02:47:48 <SwashBuckla> merijn: I can't seem to figure out what MyType can be
02:47:56 <ij> Oh, race looks nice, thanks.
02:48:52 <SwashBuckla> merijn: in Sized.hs I don't appear to have anything with type signature <MyType> -> Sized
02:49:09 <merijn> SwashBuckla: Well, what's the type of arbitrary in "fmap size arbitrary"?
02:49:12 <SwashBuckla> <MyType> -> Size
02:49:20 <SwashBuckla> the type there is Int
02:49:25 <SwashBuckla> for arbitrary
02:49:31 <merijn> SwashBuckla: Right, GHC is telling you it can't know that
02:49:48 <merijn> SwashBuckla: Also, that's not true
02:49:52 <merijn> Because you are using fmap
02:49:56 <merijn> And you can't fmap Int
02:50:12 <SwashBuckla> you asked what the type of arbitrary was
02:50:22 <SwashBuckla> I want to generate some random int
02:50:30 <merijn> SwashBuckla: Yes, but the type you give isn't possible given the code you wrote
02:50:35 <SwashBuckla> hmm
02:50:48 <Pantsu> SwashBuckla: there are libraries for that
02:50:52 <merijn> In your code it has "arbitrary :: (Functor f, Arbitrary (f a)) => f a"
02:51:02 <merijn> Eh, that's wrong
02:51:08 <merijn> In your code it has "arbitrary :: (Functor f, Arbitrary (f a), Sized a) => f a"
02:51:34 <merijn> Because you are doing "fmap :: Functor f => (a -> b) -> f a -> f b" and "size :: Sized a => a -> Size"
02:51:54 <merijn> Therefore "fmap size :: (Functor f, Sized a) => f a -> f Size"
02:52:18 <SwashBuckla> hmmso I need a Sized thing
02:52:26 <merijn> So it's trying to find some "(Functor f, Arbitrary (f a), Sized a)" and it says multiple are possible, so it can't figure out which to pick
02:52:42 <SwashBuckla> ok
02:52:51 <merijn> Don't you just want "size (arbitrary :: Int)"?
02:53:01 <merijn> To generate a random Size?
02:53:54 <SwashBuckla> (arbitrary :: Gen Int) would do it
02:54:02 * hackagebot distributed-process-p2p 0.1.3.2 - Peer-to-peer node discovery for Cloud Haskell  http://hackage.haskell.org/package/distributed-process-p2p-0.1.3.2 (AlexanderBondarenko)
02:54:21 <SwashBuckla> but I still get a 'Could not deduce (Sized Int) arising from a use of `size'
02:54:35 <SwashBuckla> so it needs some way of fixing the type of size
02:55:00 <merijn> SwashBuckla: No, that's saying Int is not an instance of Sized
02:55:14 <merijn> So you can apply "size" to Int at all
02:55:24 <SwashBuckla> can't*
02:55:28 <SwashBuckla> mm
02:55:33 <merijn> Eh, yeah, can't
02:55:38 <merijn> Typing is hard
02:55:43 <SwashBuckla> haha
02:55:45 <SwashBuckla> in more than one way
02:56:37 <merijn> SwashBuckla: The golden rule for these type of issues: Always add more type annotations to narrow down exactly where the compiler and you disagree on the types of things
02:56:38 <Haskellfant> I am working with a C library that is based on callbacks. Now I need to maintain some state that needs to be read and modified in the callbacks. My current approach is to just pass a TVar containing the state into each callback and synchronize my state using that. Are there any better solutions to maintain a state in this case? State monad doesn't seem to do the trick if my functions only get called from C
02:57:06 <merijn> Haskellfant: TVar/MVar/IORef are the usual ways
02:57:15 <merijn> Haskellfant: State doesn't work for callbacks from C, no
02:58:29 <Haskellfant> merijn: okay, I'll go with that then. I was hoping to avoid it as it feels a bit dirty :)
03:03:53 <jellie> :info liftIO
03:06:14 <jellie> How can I check which module a function is in using lambdabot?
03:06:37 <shachaf> You can use @index for a few functions, but in general you can't.
03:06:59 <jellie> shachaf: Well hoogle isn't helping much either.
03:07:01 <shachaf> Also @hoogle, I guess.
03:07:06 <jellie> shachaf: Which module has liftIO?
03:07:14 <jellie> @hoogle liftIO
03:07:15 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
03:07:15 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
03:07:15 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
03:07:24 <shachaf> Looks like it works fine.
03:13:43 <haskell380> \msg lambdabot
03:13:58 <haskell380> \msg lambdabot @pl id
03:14:31 <TheFallingCat> Hello?
03:15:38 <mars__> Hello
03:17:30 <TheFallingCat> -p
03:19:03 * hackagebot Win32-security 0.1 - Haskell bindings to a security-related functions of the Windows API  http://hackage.haskell.org/package/Win32-security-0.1 (anton_dessiatov)
03:23:49 <TheFallingCat> Hello?
03:24:13 <Yaniel> hello
03:30:38 <TheFallingCat> helo
03:30:45 <Haskellfant> can I make a Proxy implicit somehow? I end up having to change every single function call because I added a Proxy argument to make ghc happy
03:31:18 <shachaf> No.
03:31:35 <Haskellfant> hm k
03:33:11 <bartavelle> is there a mechanical way to convert lambda calculus to SKI combinators ?
03:33:17 <shachaf> Yes.
03:33:21 <bartavelle> cool ;)
03:33:21 <shachaf> It's listed on the Wikipedia page.
03:33:24 <bartavelle> rah
03:34:23 <Pantsu> Haskellfant: you can use a transparent proxy on the os side of things
03:34:48 <Pantsu> oh nm wrong proxy
03:34:53 <Haskellfant> Pantsu: I don't think we are talking about the same kind of proxy. I'm talking about the one from Data.Proxy :)
03:34:57 <bartavelle> shachaf, I suppose I am too dense to find it in http://en.wikipedia.org/wiki/SKI_combinator_calculus  :/
03:35:39 <shachaf> Looks like it's in https://en.wikipedia.org/wiki/Combinatory_logic
03:35:50 <bartavelle> thanks !
03:40:25 <bartavelle> alternate question, I saw a typed lambda calculus implementation, but I don't really know how to extend it with "forall."
03:41:19 <merijn> bartavelle: You should probably grab TaPL if that's where your interest lie :)
03:41:20 <sinelaw> bartavelle, you mean to add rank-n polymorphism?
03:41:27 <sinelaw> bartavelle, or just plain rank-1
03:41:41 <sinelaw> bartavelle, and yes, TaPL is a good reference (and quite readable)
03:41:51 <bartavelle> sinelaw: I don't know what the difference is :) I need church encoded as foldr lists
03:41:57 <bartavelle> I'll check what TaPL is
03:42:01 <sinelaw> @where TAPL
03:42:01 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
03:42:05 <sinelaw> bartavelle, ^^
03:42:15 <bartavelle> thanks merijn and sinelaw 
03:42:46 <merijn> bartavelle: It presents simply typed lambda calculus, then extends it with polymorphism, mutation, subtyping and a bunch of other stuff and shows how to do type inference and checking for all of those
03:43:00 <bartavelle> ah awesome !
03:43:11 <merijn> bartavelle: It includes implementations of all the discussed checkers/inferers too (in ocaml, but basic ocaml, so if you know basic haskell it should be trivial to read)
03:43:37 <sinelaw> bartavelle, plus, there's a haskell port of all the code in that book: https://code.google.com/p/tapl-haskell/
03:44:27 <bartavelle> oh it's not a 12$ book
03:44:28 <sinelaw> and this https://github.com/zeckalpha/TaPL and a few others i seems
03:44:35 <sinelaw> *it
03:45:37 <bartavelle> I'll just add it to my wishlist for now, and postpone my project a bit, thanks for the great pointer
03:54:02 <jellie> :t IO a -> [a]
03:54:03 <lambdabot> parse error on input ‘->’
03:54:13 <jellie> @hoogle IO a -> [a]
03:54:15 <lambdabot> Foreign.Marshal unsafeLocalState :: IO a -> a
03:54:15 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
03:54:15 <lambdabot> Foreign unsafePerformIO :: IO a -> a
03:55:15 <merijn> jellie: That function doesn't exist and doesn't make sense
03:55:24 <merijn> jellie: You probably want "IO a -> IO [a]"
03:55:56 <ski> bartavelle : you could also try "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)>, if you're looking for info on types for polymorphism
03:55:59 <jellie> merijn: but then how will I get the [a] from IO?
03:56:05 <ski> jellie : what do you want to do ?
03:56:13 <bartavelle> ski: thanks
03:56:57 <jellie> I want to use UTCTime from getCurrentTime in such a way that I concatenate it to a list
03:57:02 <jellie> ski: merijn ^
03:57:41 <nh2> hey, https://wiki.haskell.org/Short_cut_fusion says "E.g. computing sum [1..n] does not require an explicit list structure, and the expression is actually translated into a simple loop". Has anybody ever tried that?
03:57:45 <jellie> liftIO can't give me IO UTCTime -> [UTCTime] because I can't write a MonadIO instance for list.
03:57:52 <nomeata> Hi. Is there a cpp-free way of importing foldr with its old, monomorphic type?
03:58:22 <nh2> because for me, sum [1..n] pretty sure takes damn forever
03:58:28 <ski> @type Data.Time.Clock.getCurrentTime
03:58:29 <lambdabot> IO time-1.5.0.1:Data.Time.Clock.UTC.UTCTime
03:58:48 <jellie> ski: let me paste the code
03:59:00 <ski> @hoogle getCurrentTime
03:59:00 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
03:59:00 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
03:59:48 <ski> jellie : concatenate to a list, how ? just add it to a pre-existing list ?
04:01:10 <jellie> ski: https://gist.github.com/urbanslug/09072afe720d03788ee5 Line 21 and 36
04:01:57 <jellie> though they wont compile they sort of show what I want to do. I see that unsafePerfromIO might do the trick but I'm not sure
04:04:24 <jellie> merijn: I kinda see the function doesn't make sense. but how on earth can I escape the IO monad?
04:05:06 <ski> jellie : you don't "escape the IO monad"
04:05:10 * jellie is trapped in IO.
04:05:29 <jellie> ski: Have you seen what I'm trying to do?
04:06:09 <jellie> It's like I'm trying to safely get a string out of an IO String
04:06:32 <jellie> Which I see is impossible because there can be no safe way to do it
04:06:54 <ski> `liftA2 diffUTCTime getCurrentTime $ return last' can be simplified to `fmap (\currentTime -> diffUTCTime currentTime last) getCurrentTime'
04:11:27 <ski> jellie : `nick' in line `31' is a `Char' ?
04:11:27 <merijn> jellie: That's because you CAN'T get a String out of an IO String
04:11:40 <merijn> jellie: However, you CAN put other functions INTO IO
04:11:44 <ski> @quote /bin/ls
04:11:44 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
04:11:48 <jellie> ski: It is
04:12:10 <merijn> jellie: Most likely candidates are: "fmap :: (a -> b) -> IO a -> IO b" and "(>>=) :: IO a -> (a -> IO b) -> IO b"
04:13:46 <ggVGc> Finally got what I wanted to write working. Would appreciate if someone wants to point out obvious stupid things I've doing so I can learn better, https://gist.github.com/4b8d3c834b4ddf25a26e
04:13:51 <sinelaw> ski, you're here! are you aware of work done on parametric polymorphism with type guards? e.g. case x is String of True -> /* here x is a string */; False -> /* Here it is anything but a string (or just anything) */
04:14:13 <sinelaw> ski, I have a vague understanding of GADTs and it seems related, but GADTS aren't inferred
04:14:19 <sinelaw> (they are declared)
04:14:34 <ski> (i'm here ?)
04:14:53 <sinelaw> I was assuming you might know
04:14:57 <jellie> How can I get the difference in time in haskell? uuuiiiiiiiiiiiiiiii
04:14:58 <sinelaw> and you weren't here before
04:15:07 <merijn> ggVGc: Add more local definitions to make lines shorter
04:15:21 <ski> jellie : i'm still trying to figure out what you want to do
04:15:26 <jellie> I've updated the gist https://gist.github.com/urbanslug/09072afe720d03788ee5
04:15:32 <merijn> ggVGc: i.e. line 28 is excessively long and hard to read
04:15:46 <sinelaw> jellie, look at the time package: https://hackage.haskell.org/package/time-1.5.0.1/docs/Data-Time-Clock.html
04:15:51 <ggVGc> merijn: yeah, I know that. You mean using "where x = ..."
04:16:03 <ggVGc> ?
04:16:05 <merijn> ggVGc: Yeah
04:16:17 <jellie> ski: You see in line 20? I'm trying to write a bot that shows the last seen.
04:16:24 <merijn> ggVGc: Also "concat $ map ..." is just concatMap ;)
04:16:34 <jellie> sinelaw: So I'm trying to get the difference between current time and the last seen time
04:16:43 <ggVGc> ah, thanks
04:16:57 <ggVGc> merijn: yeah, I figure there's a lot of shorthands that I don't know about yet
04:17:01 <jellie> ski: So I'm trying to get the difference between current time and the last seen time
04:17:04 <jellie> sinelaw: Sorry
04:17:04 <ski> sinelaw : hm .. i think what you're asking for has often been called "typecase" .. however, i'm opposed to it :)
04:17:46 <sinelaw> jellie, see the 'diffUTCTime' function on that page
04:17:59 <ski> jellie : anyway, i'm all but certain that you *don't* want to use `unsafePerformIO' here
04:18:14 <sinelaw> ski, funny, 'typecase' is the name I invented in my AST, I guess I wasn't off.
04:18:21 <sinelaw> ski, why are you opposed?
04:18:24 <merijn> ggVGc: If you use lpaste.net it will run HLint on your code and give many suggestions
04:18:34 <merijn> sinelaw: typecass breaks parametricity
04:18:40 <merijn> sinelaw: And thus equational reasoning
04:18:41 <jellie> sinelaw: yeah but that wont solve my problem because current time is still in IO https://gist.github.com/urbanslug/09072afe720d03788ee5
04:18:43 <ggVGc> ah, thanks
04:18:44 <ggVGc> will do that
04:18:52 <sinelaw> jellie, so get it out of the IO
04:18:53 <ski> (generally speaking, you should only use it when you know that the I/O-action will *behave* as `return x' (for some value `x'), iow *not* have *any* visible I/O-effects)
04:18:59 <jellie> sinelaw: How?
04:19:15 <merijn> sinelaw: Wrong suggestion
04:19:17 <sinelaw> myTime <- theIOAction; let diff = diffUTCTime myTime oldTime
04:19:20 <merijn> sinelaw: There is not getting it out
04:19:25 <ski> sinelaw : "typecase" makes it possible to distinguish between isomorphic types
04:19:33 <jellie> ski: It doesn't have side effects. It just should get time.
04:19:37 <ocramz> hi all, anybody has some experience with c2hs for FFI bindings?
04:19:39 <ski> (at least as it is usually formulated)
04:19:42 <ggVGc> merijn: even better, will download hlint so I can get the linting in vim with syntastic
04:19:43 <merijn> jellie: Getting the time IS a sideeffect
04:19:48 <sinelaw> jellie, getting time is an io action
04:19:48 <ski> jellie : getting the current time is a side-effect
04:20:00 <sinelaw> merijn, fair enough
04:20:01 <jellie> merijn: but getting time will hardly ever fail
04:20:08 <ski> doesn't matter
04:20:13 <merijn> jellie: It won't fail, but it will always be a different time
04:20:18 <ski> getting time twice will usually yield different results
04:20:19 <sinelaw> jellie, it's not about failing: the result depends on when you do it
04:20:22 <Axman6> it's certainly not pure, it takes no inputs yet returns different outputs each time you call it
04:20:33 <merijn> jellie: Something is only pure if the results are the same, regardless of WHEN and how many times the compiler runs it
04:20:49 <merijn> Getting the time is neither of those things
04:20:54 <sinelaw> merijn, ski ok I'm aware of it breaking parametericity - but my language allows mutation so there is none to begin with
04:21:00 <sinelaw> mutation a la ML
04:21:06 <merijn> sinelaw: You can have mutation + parametricity
04:21:11 <jellie> What can I do?
04:21:44 <merijn> jellie: About 10 or so minutes back I said you probably either: "fmap :: (a -> b) -> (IO a -> IO b)" or "(>>=) :: IO a -> (a -> IO b) -> IO b"
04:21:52 <notdan> myTime <- theIOAction; let diff = diffUTCTime myTime oldTime
04:22:05 <ski> jellie : if you use `unsafePerformIO' with `getCurrentTime' twice (or more times), then the compiler is allowed to optimize this into only getting the time once, and then reusing the previous result (because by using `unsafePerformIO' you're promising to the compiler that the I/O-action has no observable effects, will always give the same result (given the same inputs, but in this case there's no arguments))
04:22:12 <sinelaw> merijn, hm
04:22:16 <jellie> notdan: hmm that might work
04:22:37 <notdan> Does
04:22:43 <notdan> jellie: does the code you posted not work?
04:22:46 <merijn> sinelaw: With typecase you lose the ability to say that, for example, "id :: a -> a" will not increment Int's by 1
04:22:47 <jellie> ski: WOW I would never have guessed that
04:22:48 <notdan> https://gist.github.com/urbanslug/09072afe720d03788ee5 ?
04:22:50 <sinelaw> merijn, doesn't the fact the functions like 'id' could be doing side effects behind th scene break it?
04:22:58 <jellie> notdan: No
04:23:06 <merijn> sinelaw: It breaks purity, sure, but not parametricity :)
04:23:15 <jellie> notdan: but I think I know how to make it work now
04:23:21 <merijn> sinelaw: Parametricity states that the behaviour of polymorphic functions can't depend on their type
04:23:29 <sinelaw> merijn, oh ok
04:23:31 <sinelaw> merijn, then it does.
04:23:34 <notdan> jellie: add `return' to `diffUTCTime'
04:23:49 <merijn> sinelaw: And even with mutation there's not a lot that id can do (well, it could do a bunch of side effects which would ALSO break parametricity)
04:24:14 <merijn> sinelaw: But the main objection is the fact that something like "id :: a -> a" now can return potentially ANY value it wants
04:24:36 <merijn> Whereas without typecase it may have ANY side-effect it wants, but you can still reason about the return value
04:24:47 <sinelaw> merijn, thanks for clarifying
04:24:57 <sinelaw> nevertheless, I think I need it.
04:25:05 <sinelaw> It's a common idiom in the target language
04:25:09 <sinelaw> unfortunately.
04:25:18 <merijn> sinelaw: Then may god have mercy on your soul ;)
04:25:43 <sinelaw> alternatively if I could supply an equally "powerful" way to do what they want..
04:25:51 <sinelaw> type classes could work
04:26:09 <jellie> notdan: What do you mean exatcly? How will that help?
04:26:38 <merijn> sinelaw: Typeable? :p
04:26:56 <sinelaw> merijn, doesn't Typeable break parametericity too?
04:27:05 <ski> sinelaw : no
04:27:10 <merijn> Well, no, because it's visible in the type signature
04:27:24 <sinelaw> ok, so it's explicitly breaking it
04:27:25 <ski> just like `Num' and `Eq' doesn't break parametricity
04:27:30 <merijn> "id :: Typeable a => a -> a" is very different from "id :: a -> a"
04:27:36 <merijn> sinelaw: Right
04:27:54 <merijn> One you see Typeable you explicitly know "all bets are off"
04:27:58 <ski> it's explicitly exempt from it, because of the class constraint
04:28:23 <ski> sinelaw : how about something GADT-like ?
04:28:47 <sinelaw> ski, that's where my question started: but GADTs are declared, not inferred
04:28:58 <sinelaw> i.e. they are nominal
04:29:53 <jellie> ski: Okay uh how come line 14 gives me an error in https://gist.github.com/urbanslug/09072afe720d03788ee5 It seems I can't write: do now <- getCurrentTime
04:30:20 <ski> jellie : the compiler is allowed to optimize `diffUTCTime (unsafePerformIO getCurrentTime) (unsafePerformIO getCurrentTime)' or `let currentTimeA = unsafePerformIO getCurrentTime; currentTimeB = unsafePerformIO getCurrentTime in diffUTCTime currentTimeA currentTimeB' into `let currentTime = unsafePerformIO getCurrentTime in diffUTCTime currentTime currentTime'
04:30:52 <jellie> ski: I'm not using unsafePerformIO
04:31:16 <Axman6> but it's important to understand why things that mayt not appear to be 'side effects' actually are
04:31:33 <ski> jellie : just as it is allowed to optimize `(a * (c ^ 2)) - (b * (c ^ 2))' into `let c2 = c ^ 2 in (a * c2) - (b * c2)'
04:31:53 <jellie> ski: I'm not sure you got my question
04:32:04 <ski> sinelaw : i'm not quite sure what you mean by "declared"/"nominal" here
04:32:27 <jellie> I'm trying to do `now <- getCurrentTime` in a do block and getting a parse error
04:32:30 <jellie> ski: ^
04:32:50 <Axman6> is it an IO do block?
04:32:54 <merijn> jellie: That's not a do block
04:32:56 <ski> no, it isn't
04:32:58 <merijn> jellie: That's arrow notation
04:33:07 <sinelaw> ski, I mean that you need to declare the GADT
04:33:15 <sinelaw> ski, and use the type constructor
04:33:19 <sinelaw> (by name)
04:33:25 <ski> jellie : you need to lift your `IO UTCTime' into that `Auto' arrow
04:33:37 <merijn> And I don't remember enough arrow notation to use IO inside them
04:33:45 <sinelaw> ski, whereas with typecases you don't need to declare anything beforehand - everything is inferred
04:34:49 <ocramz> pointers make me cry
04:39:07 * hackagebot list-fusion-probe 0.1.0.3 - testing list fusion for success  http://hackage.haskell.org/package/list-fusion-probe-0.1.0.3 (JoachimBreitner)
04:39:21 <ski> sinelaw : let's consider `data Expr :: * -> * where Lit :: a -> Expr a; App :: Expr (b -> a) -> (Expr b -> Expr a); Abs :: (b -> Expr c) -> Expr (b -> c)' aka `data Expr a = Lit a | forall b. App (Expr (b -> a)) (Expr b) | forall b c. a ~ (b -> c) => Abs (b -> Expr c)'
04:39:48 <sinelaw> ok
04:39:56 <ski> sinelaw : we could represent this as something like `newtype Expr a = MkExpr (Either3 a (exists b. (Expr (b -> a),Expr b)) (exists b c. a ~ (b -> c) *> (b -> Expr c)))' (if this example wasn't recursive, we could use `type' instead of `newtype') -- perhaps you can use something like this (or use an explicit GADT `Equal' instead of `~')
04:41:06 <ski> jellie : which package is `Control.Auto' from ?
04:42:20 <jellie> ski: Dude it's so scary I want to cry. I can't figure out how to do that lifting over the arrow thing you talked about even though I see that it's the answer. The proc won't let me wrap it in a do notation
04:43:02 <jellie> ski: It's by jle` a package called auto https://github.com/mstksg/auto
04:43:16 <Denommus> hi
04:43:22 <jellie> I don't really want to cry but I am frustrated.
04:44:25 <ski> jellie : how is `RoomBot' defined ?
04:44:47 <ski>   type RoomBot m = Auto m ??? ???
04:45:14 <jellie> give me a sec
04:46:14 <jellie> ski: L 36 https://gist.github.com/urbanslug/cad5d9f3b03f886ccb6d
04:46:20 <ski>   Control.Auto.Effects.arrM :: (a -> m b) -> Auto m a b  -- i think this is relevant to what you want to do atm
04:46:22 <jellie> ski: You might want to look at https://github.com/mstksg/auto/blob/master/tutorial/tutorial.md
04:46:35 <hodapp> It's okay to cry in #haskell.
04:46:43 <hodapp> we'd offer you tissues if we knew where you were.
04:46:43 <ocramz> C FFI/c2hs question: I have to wrap some C functions that can operate on either references or copies of the same type; e.g. ... TypeA m, n; ..., funct1(m , &n ); 
04:47:11 <jellie> hodapp: Is it now? It's hard to ship anything let alone tissues to Kenya.
04:47:35 <ocramz> nullary types are not supposed to be dereferenced; what Haskell type should I set for TypeA ?
04:47:54 <hodapp> jellie: It's fine to cry. When I say 'offer you tissues', I don't mean for *free*...
04:48:05 <hodapp> it's a little scummy, but #haskell has to make money somehow.
04:48:10 <ski>   Control.Auto.Effects.effect :: m b -> Auto m a b  -- or this is probably even better
04:48:29 <jellie> ski: Where/how are you finding these?
04:48:31 <merijn> ocramz: C doesn't have references, just pointers and values
04:48:41 <jellie> hodapp: LOL I'll be more open about crying now.
04:48:46 <ski> jellie : <https://hackage.haskell.org/package/auto>, the `Control.Auto.Effects' part
04:48:47 <fr33domlover> Hello. Is there a reason DarcsDen has its own SSH server? Git does it by having a git shell and a git system user, so other things can work on SSH. Does having a specialized SSH server not prevent other things from working over SSH? (like shell access or having git and darcs at the same time)
04:49:01 <ocramz> merijn: that I know, I'm concerned about the Haskell side
04:49:08 <sinelaw> ski, the point were making is that you can get GADT-like stuff without declaring a GADT?
04:49:13 <sinelaw> *was?
04:49:14 <merijn> ocramz: Which part of the haskell side, exactly?
04:49:36 <ski> sinelaw : yes, by using existentials, and `~'/`Equal'
04:49:51 <hodapp> ski: have a link on this?
04:49:54 <hodapp> might be relevant to me
04:49:56 <sinelaw> ski, ok, cool - but you still need to declare the data type
04:49:56 <merijn> ocramz: Oh, I think I missed the second bit
04:50:00 <ski> sinelaw : or some other construct which incorporates enough of the power of those
04:50:04 <merijn> ocramz: There's a Ptr type in the FFI
04:50:11 <ski> sinelaw : "but you still need to declare the data type" -- i don't see why
04:50:29 <sinelaw> ski, newtype Expr a = MkExpr (Either......
04:50:54 <merijn> ocramz: You can just do "data TypeA" <- empty definition, assuming you don't need it Haskell side and use "Ptr TypeA" as haskell type
04:50:58 <jellie> ski: Honestly, I'm afraid of  touching stuff that is outside of the proc but I will try.
04:51:04 <ski> sinelaw : as i said, that was only because the example was recursive (and i couldn't recall any sensible-sounding non-recursive example at the time. perhaps you have one in mind ?)
04:51:40 <sinelaw> ski, my actual use case is javascript - it's a common idiom to accept multiple possible types 
04:51:56 <ski> jellie : anyway, `now <- effect (liftIO getCurrentTime) -< ()' might work (you need `MonadIO m', not just `Monad m', for this)
04:51:57 <merijn> ocramz: Or I'm not understanding what your actual question is :)
04:52:37 <sinelaw> ski, come to think of it, maybe all the relevant JS use cases can be handled otherwise
04:53:00 <ocramz> merijn: thank you, let me retry: I have some C functions with either pointers or copies to the same struct type as arguments
04:53:24 <ski> ocramz : ooc, what are "nullary types" ?
04:53:38 <ocramz> type TypeA = ()
04:53:47 <ocramz> or data TypeA as you wrote
04:53:48 <ski> oh, the unit type
04:54:14 <merijn> ocramz: Right, and the problem is?
04:54:24 <sinelaw> ski, i'll look for an interesting use case
04:54:26 <ski> (ocramz : but `TypeA m, n;' looks like C. what is the C type `TypeA' ?)
04:54:29 <jellie> ski: PM
04:54:51 <sinelaw> dispatching on the type of deserialized unknown data may be one
04:55:32 <ski> sinelaw : are you compiling to ECMAScript ? interfacing to it ?
04:55:44 <sinelaw> ski, type checking it!
04:57:08 <ocramz> merijn: so if the C signature is let's say IntType func1(TypeA ,*TypeA), the corresponding Hs sig will be func1 :: TypeA -> Ptr TypeA -> IO IntType   ?
04:57:33 <ski> sinelaw : type checking existing code ?
04:57:49 <sinelaw> ski, that's yet to be seen; for now, no.
04:58:06 <merijn> ocramz: Yeah
04:58:07 <sinelaw> but I want to allow as many as the common idioms as I can (safely)
04:58:40 <ski> sinelaw : so you want to check/infer on code without any explicit type annotations ?
04:58:42 <ocramz> merijn: thanks, I know this is not particularly interesting; I always had an irrational fear of pointers
04:58:53 <merijn> ocramz: Also, I recommend reading Chapter 8 from the Haskell Report (the FFI chapter) it contains many details on marshalling, etc.
04:58:58 <ski> jellie : did the `effect' suggestion work at all ?
04:59:04 <sinelaw> ski, right
04:59:23 <sinelaw> ski, https://github.com/sinelaw/infernu/blob/master/docs/type-system.md
04:59:26 <merijn> ocramz: i.e., how compilers marshall between haskell values and C values, etc.
04:59:35 <jellie> ski: Yes but the issue is with the MonadIO instance.
05:00:07 <jellie> ski: I had tried writing an instance of MonadIO for list  earlier when I was trying to get IO a to [a] but failed.
05:00:40 <ocramz> merijn: so far I've read RWH, the Wikibook, a bunch of Hs wiki pages (ranging from "choppy" to unreadable), and the c2hs reference
05:00:41 <ski> you can't write any sensible `MonadIO []' instance
05:00:58 <ocramz> but still quite confused
05:01:21 <ski> jellie : why is `MonadIO' an issue ?
05:01:26 <jellie> ski: hmmm I'd tried getCurrentTime >>= \x -> [x]
05:02:10 <ski> jellie : which of the "run" operations in <https://hackage.haskell.org/package/auto-0.2.0.6/docs/Control-Auto-Run.html> are you using ?
05:02:32 <ski> maybe you meant `getCurrentTime >>= \x -> return [x]' ?
05:02:33 <merijn> ocramz: So did I, turns out that the Report is pretty in-depth, yet readable
05:03:08 <ski> (which is the same as `do x <- getCurrentTime; return [x]', which is the same as `(: []) <$> getCurrentTime')
05:03:17 <merijn> ocramz: If your decently famliar/comfortable with C and C linking it's all actually pretty obvious. But a lot of blogposts are written by people with a...far from decent grasp of linking, etc.
05:03:20 <jellie> ski: i have so much to say...
05:03:23 <jellie> ski: No I didn't want to add return because it would just have it in IO.
05:03:53 <jellie> ski: I'm using runOnChanM
05:04:00 <ski> well, `getCurrentTime >>= \x -> [x]', as it stands, is nonsense. lists doesn't include any descriptions of I/O-actions
05:04:14 <ocramz> merijn: thank you; does the FFI addendum help as well?
05:04:17 <merijn> ocramz: The report describes the exact marshalling rules, all the compiler does is generate machine code with the relevant C calling convention on your machine + marshalling as described in the FFI chapter and that's it
05:04:30 <jellie> ski: Then I'll add a type constrain that m be an instance of MonadIO in type ChatBot.
05:04:40 <merijn> ocramz: The FFI addendum is from the Haskell 98 report, in Haskell 2010 it's been integrated into the report as chapter 8
05:04:57 <ocramz> awesome :) thank you so much
05:05:03 <merijn> So, basically, they're the same thing, but the one in Haskell2010 report is newer
05:05:12 <merijn> I doubt anything changed, though
05:05:23 <jellie> ski: hmmm I see that it's nonsense but I couldn't find a better way to get a out of IO a
05:05:49 <jellie> I mean seenBot
05:05:50 <ski> jellie : hm, that accepts (and also yields back) an  Auto'  .. which can't do I/O
05:06:03 <ocramz> the whole 2010 report is 300 or so pages; would make for a nice bedside reading 
05:06:11 <ski> ("that" being `runOnChanM')
05:06:49 <ski> jellie : there is no "get a out of IO", there is only "get the results of everything else inside `IO'"
05:06:53 <merijn> ocramz: It's (together with the Scheme RSR6 spec) one of the most readable language specs written
05:07:20 <jellie> ski: I couldn't find a way to get all the results from running the IO
05:07:39 <ski> jellie : anyway, i'd like to see the code where you're using `runOnChanM'
05:08:43 <makalu> is there a standard approach for implementing an interpreter of a dynamically typed language in Haskell? I mean how to represent values (lets say int and float) and how to write a cast function. I have used existentials + GADT before so I could pattern match and get the correct type.
05:09:45 <Cale> makalu: Define a data type which represents the type of values in your language, probably by cases.
05:10:36 * ski . o O ( "-- Almost always a bad idea in every conceivable situation.  Why is it even here?  I'm sorry." )
05:10:56 <Cale> heh
05:11:07 <jellie> ski: Okay quick question since I forget too often. I forgot the syntax for seenBot :: Monad m, MonadIO m => RoomBot m . The comma is causing an error. Here is the code for it: https://github.com/urbanslug/nairobi-bot/blob/master/src/Main.hs
05:11:45 <Cale> jellie: (Monad m, MonadIO m) => RoomBot m
05:11:45 <ski> jellie : `(Monad m,MonadIO m) => RoomBot m'
05:11:53 <merijn> That's redundant
05:11:58 <merijn> MonadIO has Monad as superclass
05:12:00 <ski> but, what merijn said
05:12:11 <ski> so just `MonadIO m => RoomBot m'
05:12:29 <makalu> Cale: ok "data Type = Int | Float". But how do I write a cast? "cast :: a -> Type -> ??"
05:12:32 <jellie> I thought it was redundant but I wasn't sure and I wasn't ready to take chances
05:12:44 <jellie> After all the name Monad is in MonadIO
05:13:35 <Cale> Well, you can be forgiven, given that Functor wasn't a superclass of Monad up until, well, any day now.
05:13:51 <quchen2> Cale: Last Friday?
05:13:53 <merijn> Cale: 7.10 is out already!
05:13:59 <ocramz> sweet
05:14:03 <jellie> but it's not in the repos yet
05:14:13 <Cale> Ah, I didn't know :)
05:14:15 <merijn> Which means that I should now tell everyone to start using -fdefer-typed-holes
05:14:24 <jellie> Cale: hahaha you mean Applicative. Functor was always a superclass of Monad
05:14:31 <merijn> jellie: No, it wasn't
05:14:33 <Cale> jellie: no
05:14:52 <Cale> I meant what I said :D
05:14:59 <jellie> I could've sworn I read something of the sort in learn you a haskell
05:15:27 <ski> merijn : why do you have `a' there ? why not something like `cast :: Value -> Type -> Value' ?
05:15:29 <jellie> Plus I use fmap on Monads and have never had to make them an instance of functor so I assumed
05:15:30 <ski> er
05:15:32 <ski> makalu ^
05:15:34 <merijn> jellie: Conceptually every monad is a functor, but practically not every Monad was a Functor
05:16:00 <merijn> jellie: i.e. there was a difference between the mathematical concept and the corresponding Haskell typeclass
05:16:12 <Cale> But you could always consider it a bug if someone neglected to provide a Functor instance.
05:16:28 <Cale> So usually there would be one, it just wasn't formally required.
05:16:36 <jellie> Cale: You wrote the typeclassopedia, right?
05:16:36 <quchen2> Such as 100 instances in GHC itself ;-(
05:16:42 <Cale> no
05:16:57 <jellie> Cale: but I saw your nick in the list of contributors
05:17:22 <Cale> Brent Yorgey wrote it
05:17:36 <ski> jellie : oh, you're using `void' there ..
05:17:37 <Cale> If I contributed, I have no idea what :)
05:17:52 <makalu> what I used before was essentially this. "data TypeRep a = IntRep :: TypeRep Int | FloatRep :: TypeRep Float" and "data Value = forall a. Value (TypeRep a) a". Then I can have "cast :: Value -> TypeRep a -> Value" where I pattern match "case (Value IntRep val, FloatRep) -> -- convert val to float"
05:18:06 <Cale> Well, I guess I was around at the time that Brent was learning Haskell :)
05:18:15 <jellie> ski: Quite honest most of that code is copied from a tutorial and I'm trying to play around with it to understand it.
05:18:16 * ski really thinks `void' should not be in `Control.Monad' (at least not under that name) .. *grmbl*
05:18:27 <Cale> It's very generous of him to attribute me
05:18:44 <jellie> ski: You see I hadn't even seen `void` before this. I don't even know what it does yet.
05:18:54 <Cale> void is silly
05:19:00 <Cale> It shouldn't even be a thing.
05:19:08 <jellie> Cale: What is it?
05:19:12 <Cale> :t void
05:19:13 <lambdabot> Functor f => f a -> f ()
05:19:14 <jellie> It sounds like Nothing
05:19:25 <ion> void x = () <$ x
05:19:28 <Cale> void = fmap (const ())
05:19:31 <jellie> It's like print for functor?
05:19:34 <jellie> :t print
05:19:34 <Cale> no
05:19:34 <lambdabot> Show a => a -> IO ()
05:19:46 <jellie> Okay LOL I see that
05:19:56 <ski> it replaces every "element"/"result" of the "collection"/"computation" with `()'
05:20:14 <quchen2> void used to not introduce a "Functor m, Monad m" constraint, hence it had to have monadic type when functor was logically enough
05:20:26 <ski> however, with the name `void', imnsho, it should only be present in the FFI modules (if at all)
05:20:41 <quchen2> It was moved to Data.Functor with more general type and a reexport from Control.Monad somewhere around 7.6
05:20:43 <Cale> It only really exists to sidestep a warning which is turned on by -Wall that warns you when you fail to bind the result of a computation in a do-block which has type other than ()
05:21:03 <Cale> -Wall turns on all kinds of questionable warning messages
05:21:13 <jellie> Cale: I see. 
05:21:13 <Cale> and then people write awkward code to avoid them
05:21:20 <jellie> So let's say I have...
05:21:23 <ski> if in `Control.Monad', `Control.Applicative' or `Data.Functor', it should get another name (possibly `ignore', since that's what the corresponding thing in SML and O'Caml is nameD)
05:21:37 <Cale> For example...
05:21:39 <Cale> :t forkIO
05:21:40 <lambdabot> Not in scope: ‘forkIO’
05:21:45 <Cale> :t Control.Concurrent.forkIO
05:21:46 <lambdabot> IO () -> IO GHC.Conc.Sync.ThreadId
05:22:03 <quchen2> Cale: Unused variables are pretty similar to forgetting to use monadic values I think, so the warning makes sense
05:22:20 <Cale> If you use that, and have -Wall turned on, and fail to capture the ThreadId, you'll get a warning
05:22:58 <jellie> e.g in `stuff :: m a` I can write it as `void stuff :: m a` and get no warnings as if I had writteb `_ <- stuff :: m a`
05:22:59 <ion> I don’t really mind having to make “i want to ignore this result” explicit.
05:23:06 <Cale> Even though you might not need the ThreadId for anything -- you either have to write something like _ <- forkIO $ ...  or else  void . forkIO $ ...
05:23:08 <jellie> Cale: what I said in the e.g
05:23:19 <Cale> jellie: yeah
05:24:03 <Cale> Personally, I think that's a bit silly, because the point of (>>) (which is what the do-syntax desugars to in the case where you don't bind a variable) is to ignore the result of the first computation.
05:24:14 <ski> jellie : anyway, you have `runOnChanM id (processOutput server) inputChan chatbot :: IO (Auto IO InMessage OutMessages)'. that `Auto IO InMessage OutMessages' amounts roughly (according to docs) to `InMessage -> IO OutMessages'. if you use `void' here, you'll ignore this function, and thus the I/O-effects that it returns will never be performed/executed
05:24:21 <ski> jellie : .. probably not what you want
05:24:43 <Cale> I mean, I guess it's okay as an optional warning, but as something which you leave on all the time, it's sort of obnoxious.
05:24:48 <supki> Cale: it also exists to satisfy all sorts of annoying functions that take  m ()  as input
05:25:01 <Cale> Oh yeah, that too.
05:25:05 <supki> void (forkIO (void ...))
05:25:05 <jellie> ski: hmmm I sort of get what you're saying. 
05:25:22 <Cale> We have parametric polymorphism and people don't learn to use it correctly.
05:25:32 <jellie> ski: I thought they'd have to get executed but just in the order that the compiler choses because of laziness.
05:25:58 * ski . o O ( "-- natural transformation from the underling 'Monad' of the 'Auto' to 'IO'" )
05:26:01 <Cale> The right way to indicate that you're not going to use part of your argument is to be polymorphic in it.
05:26:15 <Cale> Not to specify that you want ()
05:26:15 * ski too wants monad underlings
05:26:42 <seanhess> I'd like to crawl a webpage recursively, and get all links and link text without revisiting pages. Which package would you recommend using? 
05:27:15 <Cale> supki: and yeah, forkIO again has that problem! :)
05:27:32 <Cale> It should be  forkIO :: IO a -> IO ThreadId
05:27:32 <jellie> Do I need to know category theory to know what you guys are talking about?
05:27:37 <Cale> jellie: no
05:27:39 <ion> seanhess: I notice http://hackage.haskell.org/package/scalpel which looks nice.
05:27:54 <ski> jellie : hmm
05:28:16 <Cale> Oh, ski used the term "natural transformation", which is from category theory, I guess
05:28:36 <ski> Cale : the source used it
05:28:41 <ski> jellie : actually, now that i'm looking at the source, i think i get a better idea what the operation is for :/
05:29:10 * hackagebot alfred 0.4 - utility library for Alfred version 2  http://hackage.haskell.org/package/alfred-0.4 (PatrickBahr)
05:29:11 <Cale> jellie: As far as Haskell is concerned, when F and G are functors, then a natural transformation from F to G is just a polymorphic function F a -> G a
05:29:27 <seanhess> ion: I've been playing with Scalpel, it is nice. I'm not sure how to the recursive crawling part
05:29:56 <seanhess> ion: would you use forkIO to do that concurrently? How would you store which web pages you've already visited?
05:30:45 <ski> jellie : i see `processOutput' always yields `True' (in case it exits normally) .. so the execution of `runOnChanM' will never terminate (normally)
05:31:01 <jellie> ski: Yes
05:31:16 <jellie> ski: It's this never ending loop that's listening in for events
05:32:13 <ski> jellie : the `Auto IO InMessage OutMessages' (supposedly) yielded by `runOnChanM' here would be the final state of the automaton, after having accepted all the messages on the channel (when to stop determined by `processOutput', in this case never)
05:32:22 <jellie> ski: but according to your description of void. I don't see how void stops it from never ending.
05:32:34 <ski> jellie : so i suppose it doesn't matter if you ignore this (non-existing) final result
05:32:49 <ski> "I don't see how void stops it from never ending." -- it wouldn't
05:32:53 <jellie> ski: because it doesn't exist
05:32:54 <ion> seanhess: Keep a list of pages to be visited. Keep taking pages to scrape and insert new pages. Or use a Seq if you want to scrape from the front and append to the end. Keep a Set of visited pages and refrain from adding them. 
05:33:15 <ski> it would just discard the final result (if any) (replacing it with `()', as required by `forkIO')
05:34:11 <ski> (anyway, i'd probably use `fmap (const ())' here instead of `void' ..)
05:36:05 <indiagreen> is there any place where versions of GHC supported by Travis CI are listed? I want to know when they have 7.10 so that I can enable it, but I've no idea how to check apart from actually attempting a build
05:36:06 <seanhess> ion: do I share that list / seq between threads? With an MVar? (Sorry for the beginner questions, I haven't done this in haskell before)
05:38:03 <quchen2> indiagreen: There's a custom repo around (maintained by hvr I think) that lets you use most GHC versions with Travis
05:38:31 <quchen2> https://github.com/hvr/multi-ghc-travis
05:40:17 <ski> jellie : i see you have `MonadIO' on `chatBot'. did you add it to `seenBot' (and `repBot') as well ?
05:41:06 <indiagreen> quchen2: yep, know about it, but it basically just downloads and reinstalls GHC before every build and I feel bad doing this to their server
05:41:22 <jellie> ski: I have added it to seenBot
05:41:53 <jellie> ski: Why do you say that I have MonadIO on ChatBot?
05:41:58 <jellie> I have no such thing.
05:43:41 <jellie> The default results in time difference are far from flattering. :( The time difference is in seconds
05:43:46 <ski> jellie : line `77' at <https://github.com/urbanslug/nairobi-bot/blob/master/src/Main.hs> has `chatBot :: MonadIO m => ChatBot m'
05:44:02 <jellie> Though I see that it's common sense to give time difference in seconds
05:44:03 <ski> (`chatBot', not `ChatBot')
05:45:00 <ski> jellie : .. i suppose, depending on what `repBot' is supposed to do, you might not need `MonadIO' for it
05:45:20 <jellie> ski: Ah some of that coped code that I really don't get. I still don't quite undertstand the composition of RoomBots to ChatBots.
05:45:34 <jellie> or the composition of Auto s in short
05:45:45 <jellie> ski: I don't
05:46:00 <ski> by "composition" do you mean the `mconcat' there of `repBot' and `seenBot' ?
05:46:12 <seanhess> ion: or this is a good use case for channels right? https://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Concurrent-Chan.html
05:46:20 <seanhess> ion: thanks for your help btw
05:47:18 <jellie> ski: yeah to make one chatbot
05:48:10 <jellie> ion: You're always so charged
05:48:52 <arkeet> ha ha
05:49:07 <arkeet> :)
05:49:17 <ion> seanhess: Yeah, a Chan/TChan/TQueue could be useful.
05:49:39 <ion> jellie: Want an electron? I have an extra one.
05:50:07 <ski> jellie : for "composing" (`mconcat :: Monoid a => [a] -> a') on `Auto', i looked up the `Monoid' instance for it in <https://hackage.haskell.org/package/auto-0.2.0.6/docs/Control-Auto-Core.html> (search for "ignoring")
05:52:39 <ski> jellie : so, in your `chatBot' case, it'll pass each `InMessage' to both `repBot' and `seenBot' (while serializing internal state changes to file, and passing through `perRoom', which i haven't checked yet), and then combine the two resulting `OutMessages's (which contains `M.Map Channel [Message]'s .. presumably `mappend'/`(<>)' will here concatenate the `[Message]' for corresponding channels ?)
05:59:12 * hackagebot uhc-util 0.1.5.2 - UHC utilities  http://hackage.haskell.org/package/uhc-util-0.1.5.2 (AtzeDijkstra)
05:59:14 * hackagebot equivalence 0.2.6 - Maintaining an equivalence relation implemented as union-find using STT.  http://hackage.haskell.org/package/equivalence-0.2.6 (PatrickBahr)
06:00:18 <ski> jellie : hm, i was checking whether you could derive `Monoid' on `OutMessages' -- however, the `Monoid' instance on `Map' doesn't combine values, it just keeps the first one, so you can't do that
06:00:58 <benma> hey everyone. this article by chris done talks about using RankNTypes to limit the scope of the connection var, similar to ST: http://chrisdone.com/posts/rankntypes
06:01:31 <benma> can't you solve the same problem by just putting a reader/state monad in the middle, from which the query function can get the connection?
06:01:34 <ski> jellie> :t fromBlips
06:02:03 <jellie> ski: You understand what I'm working on a lot better than I am
06:08:04 <ski> jellie : any reply to my last question ?
06:09:26 <jellie> ski: Which question :(
06:09:53 <jellie> ion: lol no I like to be positive.
06:13:36 <ski> jellie : sorry, by my "<ski> jellie> :t fromBlips", i meant "what is the type of `fromBlips' ?"
06:15:04 <jellie> ski: fromBlips :: a -> Auto m (Blip a) a
06:15:27 <jellie> ski: LOL you asked me as if I were lambdabot
06:18:24 <tinchos> help purple
06:18:34 <jellie> tinchos: what?
06:18:55 <tinchos> jellie: sorry!! different window :P
06:20:30 <merijn> benma: The trick being used there is not "getting the connection in"
06:20:44 <merijn> benma: The RankNTypes trick statically guarantees you can't LEAK a connection
06:21:04 <benma> merijn: yes, but you can also do that by not exposing the connection variable at all
06:21:18 <merijn> benma: For example, suppose I just use Reader/State, how do I prevent someone from storing the connection into an IORef and accessing it later
06:21:27 <benma> ie instead of `query conn "querystring"` you would have `query "querystring`, and the latter gets the connection from the reader monad
06:21:48 <benma> merijn: if you use reader/state, you don't expose the functions that let you get to the connection
06:22:11 <merijn> benma: Then you can't use Reader/State, because those by definition let you access it :)
06:22:49 <merijn> benma: Although I agree that I'm not sure this is the best example of this trick
06:22:49 <benma> in the same module yes, but not the clients of the DB library
06:23:16 <benma> the clients only have the query (and say, liftIO) functions in the monad
06:23:27 <benma> and no direct access to the state monad
06:23:34 <merijn> benma: I think ST itself is a far better example of this trick
06:23:48 <benma> yes, ST is pretty great
06:24:31 <benma> so when I write a DB library, i am not worried about myself up withConnection and leaking of the variable, because this function is not even called
06:24:33 <benma> inside that module
06:24:54 <benma> but i want to prevent the clients of the libraries to be able to leak it
06:25:08 <benma> and that i can do with a reader monad, without exposing functions to access it
06:25:09 <benma> right?
06:25:15 <benma> merijn ^
06:26:15 <merijn> If you wrap it with a newtype and don't make a MonadReader instance, then yes
06:27:43 <ph88> hey guys, does someone know what is going wrong here?   http://pastebin.com/v12CUUPy
06:27:47 <benma> merijn: yes, that is what i meant
06:27:53 <benma> thx
06:28:06 <merijn> ph88: use -v3 to get verbose errors
06:28:25 <benma> merijn: would you happen to know of some type trickery to prevent `withConnection` to be called inside a `withConnection`? i.e. no nested withConnection calls
06:28:45 <benma> merijn: in my usecase, it is not withConnection, but runTransaction (db transaction)
06:30:49 <benma> merijn: but nothing stops the user from doing this: `withConnection $ do { liftIO (withConnection ...) }
06:30:49 <benma> merijn: resp. `withTransaction $ do { liftIO (withTransaction ...) }
06:30:49 <merijn> benma: Not of the top of my head
06:30:49 <benma> ok, thanks
06:30:49 <ph88> merijn: http://pastebin.com/Kj4YvF0G
06:30:49 <merijn> Well, not providing a MonadIO instance, would work :p
06:31:59 <benma> merijn: of course ;) but i do need that
06:32:45 <ph88> i think it's using the wrong mingw
06:33:14 <bergmark> benma: have an opaque type and a monadio instance inside
06:34:07 <benma> bergmark: what is an opaque type?
06:34:15 * hackagebot equivalence 0.3 - Maintaining an equivalence relation implemented as union-find using STT.  http://hackage.haskell.org/package/equivalence-0.3 (PatrickBahr)
06:37:43 <bergmark> benma: you don't expose the constructor/deconstructor directly
06:37:45 <ski> jellie : ok
06:37:55 <merijn> ph88: I have no experience with coding on windows, sorry
06:38:06 <ski> (jellie : well, really more like an interactor like GHCi or Hugs ..)
06:38:34 <benma> bergmark: yes, I don't. don't see how that helps in preventing nested calls to an exposed monadic  function
06:38:42 <benma> bergmark: can you elaborate?
06:38:50 <jellie> ski: The bot? or the way it auto works?
06:40:10 <exio4> I would have an internal liftIO' used within the module as needed, but not exported, you'd also just export the functions that take those actions as invariants or similar
06:40:43 <exio4> that seems to be the easier way, as the MonadIO instance "leaks" 
06:41:41 <benma> exio4: hmm but i actually need the liftIO. the library clients should be able to do IO stuff
06:41:59 <benma> all IO except `runTransaction` :P
06:43:15 <benma> i guess there is no way to have both
06:43:40 <benma> there is no way to wrap the IO monad and instead of "whitelisting" functions, "blacklist" them, right?
06:44:33 <ski> jellie : in GHCi, `Prelude> :t not' will result in `not :: Bool -> Bool'
06:45:12 <jellie> ski: Oh haha
06:45:26 <jellie> Gotta go.
06:47:20 <ph88> what can i do about these errors? http://pastebin.com/5PWuwZYN
06:48:21 <arkeet> ph88: looks like your Cabal package is broken.
06:48:32 <ph88> i just installed haskell platform fresh
06:48:40 <ph88> what can i do about this ?
06:49:00 <arkeet> it suggests running 'ghc-pkg check'.
06:49:02 <arkeet> have you tried that?
06:49:14 <arkeet> is this the first thing you ran after installing the platform?
06:50:02 <ph88> first thing i ran was cabal update
06:50:07 <arkeet> okay, sure.
06:50:08 <ph88> > ghc-pkg check is on line 21
06:50:10 <lambdabot>  Not in scope: ‘ghc’Not in scope: ‘pkg’Not in scope: ‘check’    Not in scope:...
06:50:11 <lambdabot>      Perhaps you meant one of these:
06:50:11 <lambdabot>        ‘id’ (imported from Data.Function),
06:50:17 <zalami> lucky 7 = "LUCKY NUMBER SEVEN!"  
06:50:18 <zalami> lucky x = "Sorry, you're out of luck, pal!" 
06:50:18 <zalami> How is that not redefining lucy?
06:50:19 <zalami> lucky
06:50:30 <ph88> ....
06:50:48 <arkeet> zalami: those are multiple cases for a single function defintion.
06:50:51 <ph88> zalami: it's not redefining, it's extending
06:51:13 <mniip> what would be the best structure for a set of strings
06:51:18 <ph88> zalami: maybe redefining in the way that it takes the first case and now the new definition is the old definition + the extra case
06:51:26 <arkeet> mniip: what do you want to do with the strings?
06:51:29 <mniip> it needs to be constructed once, and then checked for membership a lot of times
06:51:45 <zalami> ph88: I dont follow, why not just make an if inside the function?
06:52:28 <mniip> zalami, you can of course do that too
06:52:33 <ph88> zalami: because haskell/ghc will put the "if" for you in the assembler code that it produces. But in the code you write they replace if's with "pattern matching" ... this is just how the language is
06:52:35 <mniip> there is more than one way to do  it
06:53:23 <arkeet> zalami: it's equivalent to something like
06:53:32 <arkeet> lucky a = case a of { 7 -> "..."; x -> "..." }
06:53:47 <zalami> I'm brand new to haskell, Im sure it shows
06:54:14 <zalami> ph88: so I get the lucky 7 part, but what does the lucky x do?
06:54:23 <ph88> zalami: x takes anything
06:54:37 <arkeet> that's the branch it takes for any x that wasn't already matched previously (so, anything other than 7)
06:54:44 <zalami> ohh
06:54:45 <zalami> ok
06:54:46 <zalami> thanks
06:54:49 <ph88> zalami: x here is just a letter you use to do something with the argument that you receive... you can also put something else than x
06:55:19 <ph88> zalami: i think instead of x you can also put a word there
06:55:20 <arkeet> cases are checked in order from top to bottom.
06:55:23 <arkeet> it takes the first one that matches.
06:55:40 <zalami> got it
06:55:56 <zalami> now say I wanted to just define the function normally, would I do that before or after pattern matching?
06:56:06 <arkeet> what do you mean by normally?
06:56:28 <ph88> zalami: after ... using x would be your "generic case" all the specific cases come before
06:56:34 <ij> merijn, Sounds unlikely, but still could it be that if I "race readChan threadDelay" then readChan pops something off the channel, but threadDelay manages to race first before readChan's returned?
06:57:02 <zalami> ph88: ok, thanks
06:57:02 <Cale> zalami: If you don't like the use of the n-pattern, one option would be to use a guard
06:57:12 <Cale> lucky x | x == 7 = ...
06:57:20 <Cale>         | otherwise = ...
06:57:36 <Cale> Another option would be to use an if-then-else expression
06:57:44 <Cale> lucky x = if x == 7 then ... else ...
06:57:45 <zalami> Thats what I was thinking
06:58:14 <Cale> Also, case expressions will let you use all the same pattern matching and guards and stuff :)
06:58:19 <merijn> ij: Hard to say
06:58:32 <merijn> ij: That would involve checking all of the code
06:58:39 <merijn> ij: If you worry about that, use TChan
06:58:39 <Cale> So you could write  lucky x = case x of { 7 -> ... ; _ -> ... }
06:59:05 <ij> merijn, Ok, thanks.
06:59:20 <ph88> Cale: do you know what i can do about this?  http://pastebin.com/5PWuwZYN
06:59:23 <arkeet> zalami: case is really the fundamental pattern matching construct in haskell.
06:59:36 <zalami> is this case?
06:59:42 <arkeet> like
06:59:45 <arkeet> case ... of {...}
07:00:14 <arkeet> basically any other sort of matching (multiple branches of a function definition, if/then/else, etc.) can be translated to use case.
07:00:30 <arkeet> if b then x else y  -->  case b of { True -> x; False -> y }
07:00:59 <Cale> ph88: I'm not a Windows user, but that looks as if a bunch of the files related to your user-installed Cabal library package somehow got deleted
07:01:02 <zalami> got it
07:02:01 <Cale> ph88: One option might be just to  cabal install Cabal-1.22.2.0  and then fix up all the dependencies, if any... I'm not sure if there are any common libraries which depend on Cabal.
07:02:30 <Cale> You might need a --reinstall flag
07:04:17 * hackagebot aivika 4.0.1 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-4.0.1 (DavidSorokin)
07:04:19 * hackagebot stackage-curator 0.7.0.4 - Tools for curating Stackage bundles  http://hackage.haskell.org/package/stackage-curator-0.7.0.4 (MichaelSnoyman)
07:18:45 <ph88> reinstalling haskell platform for the 3rd time seems to do the trick
07:18:48 * ph88 crosses fingers
07:22:05 <ph88> just installed cabal-install and still it says there is a newer version available ... what's going on?   http://pastebin.com/AcGtQWk4
07:22:29 <clrnd> you probably don't have it in your path before the old one ph88
07:22:35 <merijn> ph88: It installs the new version into your user directory which is probably not on your path
07:27:22 <geekosaur> or it is on $PATH and before the old one, but shell is caching the old one; hash -r
07:27:52 <ph88> USER: C:\Users\ph88\AppData\Roaming\cabal\bin    SYS: C:\Program Files\Haskell\bin;C:\Program Files\Haskell Platform\2014.2.0.0\lib\extralibs\bin;C:\Program Files\Haskell Platform\2014.2.0.0\bin;C:\Program Files\Haskell Platform\2014.2.0.0\mingw\bin
07:28:09 <ph88> USER takes precendes over SYS  ... first path that matches gets precendence
07:28:15 <merijn> geekosaur: It's windows, hash -r won't work
07:30:08 <ph88> you guys are right ... but for some reason it's prefering the SYS dirs over the USER dirs ... i don't understand why
07:31:14 <ph88> http://pastebin.com/i2fTHUwc
07:32:30 <ph88> mighty strange ... i think i will just move the user path to the system path and be done with it ^^
07:33:41 <ph88> is there something like virtualenv (python) for cabal which i should use ?
07:34:19 * hackagebot netrc 0.1.0.0 - Parser for .netrc files  http://hackage.haskell.org/package/netrc-0.1.0.0 (HerbertValerioRiedel)
07:35:01 <kaiyin> haskell is a mathy language, but what's keeping it from competing with languages like R?
07:36:11 <barrucadu> I wouldn't say Haskell is a mathy language. It has concepts from maths, but it wasn't really built from the ground-up to excell at doing maths in - like R was for statistical processing
07:36:17 <ph88> kaiyin: what do you mean something is keeping it from competing ?
07:36:21 <barrucadu> *excel
07:36:39 <Gurkenglas> Idea. A website allows you to type in a type signature. It shows you a list of implementations (initially empty) and a Request button. Another page of the website shows you a list of requested type signatures and allows you to submit implementations which are then added to the type signature's lists. Those lists are grouped by satisfied QuickCheck laws. Thoughts?
07:37:27 <ph88> Gurkenglas: doesn't hoogle provide something like this ?
07:37:39 <Gurkenglas> (Possibly add voting etc.)
07:37:48 <Gurkenglas> What does hoogle search?
07:38:09 <ph88> maybe it can search type signatures too
07:39:09 <ph88> is this highly recommended?   https://www.haskell.org/cabal/users-guide/installing-packages.html#developing-with-sandboxes
07:39:20 <Gurkenglas> I often find myself writing code that I feel is general enough that other people have already written it. The coding should stop as soon as you find a type signature and the QuickCheck laws that point to an implementation that has already been done. Hoogle doesn't allow this, my idea would.
07:39:40 <clrnd> ph88, cabal sandbox
07:39:42 <ph88> sounds nice :)
07:39:52 <ph88> clrnd: yes exactly cabal sandbox !
07:39:53 <clrnd> ph88, oh, yes, I use it all the time
07:40:00 <ph88> oki :)
07:40:15 <clrnd> ph88, the other option is halcyon, which builds on top of sandboxes to avoid re-installing pckgs for each sandbox
07:40:16 <Gurkenglas> (I mean, what sourcecodes does hoogle search?)
07:40:23 <clrnd> but disk is cheap :P
07:40:28 <ph88> :)
07:55:01 <Lis> how do i assign a return value of a function to a variable?
07:56:45 <Cale> Lis: let?
07:56:54 <Cale> Lis: or where?
07:57:15 <ph88> Lis: are you new ?
07:57:19 <Cale> Lis: Of course, it's not really assignment
07:57:21 <Lis> Cale, in the main function, i want to execute some function in a given order and assign their return values to variables
07:57:51 <Cale> Lis: These are genuinely functions and not IO actions?
07:58:04 <Lis> they return [String]
07:58:26 <Cale> okay, then you can use   let strings = foo x y z
07:58:34 <Cale> as one of the lines in your do-block
07:58:47 <Lis> where can i read something about io actions?
07:59:20 <Cale> Note that this doesn't cause the function to be evaluated -- only evaluating strings will cause foo to be evaluated.
07:59:21 * hackagebot hourglass 0.2.9 - simple performant time related library  http://hackage.haskell.org/package/hourglass-0.2.9 (VincentHanquez)
07:59:35 <Cale> It just defines strings to be the result of applying foo to those arguments
07:59:46 <ski> (note that `main' is not a function (since it doesn't take an argument). it is an I/O-action)
08:00:09 <Cale> I have a very quick intro here: https://wiki.haskell.org/Introduction_to_IO
08:00:20 <Cale> There are more in-depth presentations in most Haskell tutorials
08:02:27 <Lis> ty
08:10:50 <karun012> Hey All. We just released a stable version of Arion - https://github.com/karun012/arion. This is to help make red-green-refactor go faster. Do let us know if like it and need any new features. Thanks
08:34:10 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org | Learn, Teach, or Get Out of the Way!'
08:34:10 --- topic: set by shapr!~shapr@84.200.228.78 on [Tue Mar 17 12:32:20 2015]
08:39:22 <ph88> saml: ssd ?
08:40:42 <hiptobecubic> saml, you need to define "efficient" as well
08:40:57 <saml> is ssd random access?
08:41:12 <ph88> it can handle random access better than hard drive
08:41:24 <saml> i want 2TB RAM  but persists 
08:41:35 <ph88> it's expensive
08:41:44 <saml> want it to be $100 USD
08:41:55 <ph88> then you are out of luck
08:42:06 <Welkin> RAM that persists?
08:42:12 <Welkin> RAM is by definition volatile...
08:42:21 <saml> i just want ideas. so i can start kickstarter and get rich. i don't necessarily need to ship the final product
08:42:27 <ph88> Welkin: no no
08:42:45 <saml> i want RAD  Random Access Disk
08:42:50 <merijn> Welkin: Why is it volatile by definition?
08:42:55 <merijn> saml: That's called an SSD
08:43:00 <saml> I guess filesystems are optimized for serial seeking disk
08:43:16 <saml> so even if there's RAD, filesystem performance won't be that great
08:43:18 <ski> (.. on Amiga, you could have a `RAD:' device)
08:43:55 <Welkin> it only retains memory as long as it has a power source
08:44:14 <ion> SYS:C/ghci
08:44:25 * hackagebot network-bitcoin 1.7.2 - An interface to bitcoind.  http://hackage.haskell.org/package/network-bitcoin-1.7.2 (ClarkGaebel)
08:44:26 * ski grins
08:44:32 <merijn> Welkin: You mean all current implementations of RAM are volatile
08:44:39 <Welkin> there is this, however: https://en.wikipedia.org/wiki/NvSRAM
08:44:50 <merijn> Welkin: What's stopping us from inventing non-volatile RAM implementation?
08:44:52 <hiptobecubic> saml, for $100 you aren't going to get anything worth talking about
08:44:59 <Welkin> merijn: it already exists
08:45:02 <hiptobecubic> for more than that you can get NVME or something 
08:45:06 <hiptobecubic> which is very fast
08:45:44 <ph88> http://www.pcworld.com/article/2084240/new-types-of-ram-could-revolutionize-your-pc.html
08:47:16 <hiptobecubic>  ”A lot of people, in order to recover from system crashes and problems, will restart their computers. Well, it’s usually something bugged up in the memory, so if my memory stays even when I turn it off, then I have to find new ways of doing that,” said Coughlin. As a result, computer makers might be forced to make more reliable systems, he said. 
08:47:29 <hiptobecubic> Hahahahaha  hooboy... 
08:47:41 * ion makes an effort to watch https://youtu.be/OZWYohmLKuU despite the sound quality
08:48:31 <ph88> my ex-gf was a dependent type
08:54:25 * hackagebot swearjure 1.0.0 - Clojure without alphanumerics.  http://hackage.haskell.org/package/swearjure-1.0.0 (hyPiRion)
08:55:36 <joe9> Just want to check if there might be library function to do this: [(a,t1),(a,t2),(a,t3),(a,t4),(b,u1),(b,u2)] ==> [(a,[t1,t2,t3,t4]),(b,[u1,u2])]
08:56:04 <merijn> There was a one line I came up with, but I forgot
08:56:25 <ph88> looks like a group by :P
08:56:41 <joe9> ph88: thanks, that is a good idea.
08:56:43 <merijn> It's group + strength
08:56:56 <merijn> But I don't think strength is in base anywhere
08:57:42 <joe9> found this: http://stackoverflow.com/questions/12398458/how-to-group-similar-items-in-a-list-using-haskell
08:57:46 <ski> @type uncurry (fmap . (,))
08:57:47 <ph88> https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-List.html#v:groupBy
08:57:47 <lambdabot> Functor f => (a1, f a) -> f (a1, a)
08:58:17 <merijn> :t fmap . (,) . group
08:58:18 <lambdabot> (Eq a1, Functor f) => [a1] -> f a -> f ([[a1]], a)
08:58:21 <ph88> very nice joe9 
08:58:24 <merijn> :t fmap . (,) . groupBy fst -- I guess
08:58:25 <lambdabot>     Occurs check: cannot construct the infinite type:
08:58:25 <lambdabot>       a1 ~ (a1 -> Bool, b0)
08:58:25 <lambdabot>     Expected type: a1 -> a1 -> Bool
08:58:37 <merijn> hmmm
08:58:46 <merijn> :t fmap . (,) . groupBy (comparing fst)
08:58:48 <lambdabot>     Couldn't match type ‘Ordering’ with ‘Bool’
08:58:48 <lambdabot>     Expected type: (a1, b) -> (a1, b) -> Bool
08:58:48 <lambdabot>       Actual type: (a1, b) -> (a1, b) -> Ordering
09:17:23 <Lis> if i define a function and write foo :: String -> [String] i tell haskell, that the function takes a String as argument and returns a list of Strings?
09:18:07 <sellers> yes
09:18:17 <eli-se> I heard Haskell deprecated purity. Is that true?
09:18:19 <Redz> Lis: yup. 
09:18:41 <Redz> lol
09:19:05 <nitrix> Hey guys, I'll need help figuring out a package on Hackage.
09:19:09 <nitrix> https://hackage.haskell.org/package/sdl2
09:19:24 <Redz> oh that package ...
09:19:26 <nitrix> When it says "source repository", this is actually the source used by that package or reported?
09:19:45 <c_wraith> nitrix: it's what the package metadata claims its source is
09:19:54 <nitrix> c_wraith: But it might not be?
09:20:04 <c_wraith> a package could lie, I guess
09:20:26 <geekosaur> usually it is, but nothing stops a package maintainer from switching repos after a release
09:20:45 <Redz> or writing a git command instead of the http link. 
09:20:55 <geekosaur> (consider upcoming shutdowns of code,google.com, gitorious.org, and likely code.haskell.org)
09:21:11 <nitrix> Because when I install sdl2 with cabal, it gives me the Graphics.UI.SDL.* functions, it works fine. But I go to the github project, into src/SDL, the code there is completely different, there are functions like defaultWindow that I cannot find at all, no matter what I import.
09:21:34 <Lis> how can i see what type a function returns? if I write parseCsv :: String -> [String] \r\n parseCsv string = do return (splitOn "&" string)  i get: Couldn't match type `[Char]' with `Char'
09:21:44 <nitrix> So I'm really confused as wth this haskell-game is related with sdl2.
09:21:49 <c_wraith> nitrix: you know Polarina maintains that package, right?  You can ask questions about it in here..
09:22:07 <nitrix> c_wraith: I currently am asking a question about it in here.
09:22:23 <c_wraith> nitrix: I mean it's helpful to direct questions to Polarina specifically. :)
09:22:40 <ski> Lis : probably you should remove `do return' (and the then redundant brackets)
09:23:02 <nitrix> Polarina: ping.
09:23:03 <Redz> nitrix: function can be hidden
09:23:28 <nitrix> Redz: I'll be a bit more explicit, here's an example (literally): https://github.com/haskell-game/sdl2/blob/new-api/examples/lazyfoo/Lesson01.hs
09:23:44 <nitrix> Redz: So I assume I could just do the same with my code, but cabal doesn't know about a module SDL.
09:24:01 <nitrix> I do see a module named SDL in src/SDL of that repository though. So, then, what's on hackage?
09:24:05 <Lis> ski, uh. return is special to do right?
09:24:14 * geekosaur notes that the sdl2 he sees on hackage has two repos listed, one explicitly the version on hackage and the other HEAD
09:24:19 <geekosaur> Lis: no
09:24:41 <Lis> i can use a return without do, ok. didn't understand it
09:24:47 <nitrix> geekosaur: Bingo!
09:24:58 <nitrix> geekosaur: I was looking at the branch new-api on Github.
09:25:05 <nitrix> Interesting.
09:25:14 <nitrix> Does cabal let you pick the source?
09:25:24 <ski> Lis : `return' is just another function
09:25:33 <geekosaur> no; if you want to play with the new one then you'll have to get it from github
09:25:45 <nitrix> ok.
09:25:59 <geekosaur> just be warned that things like that may be unreleased for a reason (incomplete, buggy, ...)
09:26:17 <geekosaur> :t return
09:26:18 <lambdabot> Monad m => a -> m a
09:26:51 <geekosaur> > return 5 :: [Int]
09:26:52 <lambdabot>  [5]
09:27:08 <Lis> ahhhhhh
09:27:11 <Lis> ok thank you :D
09:27:17 <geekosaur> > return 5 :: Maybe Int
09:27:19 <lambdabot>  Just 5
09:27:57 <Lis> :t what whas i was looking for also. is it possible to print a functions implementation too, interactivly?
09:27:58 <lambdabot> parse error on input ‘,’
09:29:28 <geekosaur> sort of; there's a database (@src) but it's incomplete and culled from things like the Haskell 98 Report's Prelude (and therefore may not match ghc's current implementation)
09:29:40 <geekosaur> @src Maybe return
09:29:40 <lambdabot> return = Just
09:30:11 <geekosaur> (since `return` is one of the methods of the Monad typeclass, you need to specify which Monad instance)
09:31:07 <Lis> hm, ok this is what i found. https://www.haskell.org/haddock/#Documentation not interactively but online
09:31:20 <Lis> you can click on the source link
09:32:53 <Polarina> nitrix, pong.
09:33:54 <Polarina> nitrix, the HEAD is a development version of sdl2, quite different from the one currently on hackage.
09:34:10 <geekosaur> yes, although that can have other problems (the doc builders tend to be Linux, for example, so won't show when an implementation is different for Windows vs. Linux unless it's cpp-ed in a single source)
09:34:28 * hackagebot bytestring-progress 1.0.4 - A library for tracking the consumption of a lazy ByteString  http://hackage.haskell.org/package/bytestring-progress-1.0.4 (AdamWick)
09:34:44 <nitrix> Polarina: Yeah, we sort of figured it out. So I'd have to manually download the new-api version?
09:35:00 <Redz> its funny, that they made a usage example that isn't working for the hackage version.
09:35:23 <sellers> So I'm using vim with the taglist plugin.  When I code in other languages, I get a nice set of tags automatically generated.  It seems to be totally haskell unaware.  Any suggestions on fixing it? (#vim is up next, but I was already here)
09:35:24 <Polarina> nitrix, if you'd like to use the new-api version, then yes.
09:35:35 <Ryanar> what is hackage?
09:35:44 <Polarina> nitrix, it's not finished though and you'll probably find some missing functionality.
09:36:00 <geekosaur> Ryanar: http://hackage.haskell.org
09:36:10 <nitrix> Polarina: I really do not need much, I can help with the remaining parts as I go, I think.
09:36:12 <geekosaur> it's the master haskell / cabal package repository
09:36:20 <Polarina> nitrix, wonderful. :)
09:36:22 <Ryanar> ahhh ok. cool
09:36:28 <nitrix> Polarina: As long as it's mostly usuable for keyboard/mouse and drawing 2d tiles...
09:36:55 <Polarina> nitrix, The SDL.Raw module is identical to what is currently on hackage, so the incompleteness shouldn't be a showstopper.
09:37:01 <nitrix> Polarina: Not an expert of cabal here though, is there a way to have this in my cabal file?
09:37:34 <nitrix> An external dependency that isn't on hackage but github?
09:37:36 <Polarina> nitrix, clone the repository, then you should be able to simply execute `cabal install`.
09:37:49 <nitrix> That's manual -.-
09:37:50 <c_wraith> Polarina: by the way, what does the hackage branch use pkg-config for?  (Currently prevents building on windows)
09:37:56 <Polarina> nitrix, just state sdl2==2.0.0 in the cabal file.
09:38:11 <sellers> re the taglist plugin/ haskell thing... my google-fu is weak, I think I found my answer
09:38:13 <Polarina> c_wraith, it uses it for finding the include files and the proper linker flags.
09:38:35 <geekosaur> nitrix, it's not released yet, you can't get it from hackage / via cabal install
09:39:21 <c_wraith> Polarina: ah.  So not *that* bad to do manually on a specific install. I wonder how much work it would be to add flags to allow specifying those manually.
09:39:28 * hackagebot stackage-curator 0.7.0.5 - Tools for curating Stackage bundles  http://hackage.haskell.org/package/stackage-curator-0.7.0.5 (MichaelSnoyman)
09:40:08 <Polarina> c_wraith, pkg-config allows you to specify/override the include directory and linker flags if you prefer.
09:40:20 <c_wraith> Polarina: only if it exists - which it doesn't on windows.
09:40:37 <c_wraith> Polarina: ie, I'm told that pkg-config can't be found, and it stops running at that point.
09:41:20 <Polarina> c_wraith, I just install the GTK+ runtime myself, which comes with pkg-config and other tools.
09:41:32 <c_wraith> Oh.  I guess I could install that whole bundle.
09:46:51 <pietervdvn> Hi all! Can someone recommend a XMPP library?
09:47:59 <Clint> pietervdvn: well, i use network-protocol-xmpp
09:48:37 <pietervdvn> Is it reliable and easy to use?
09:49:26 <Clint> i guess?
09:49:38 <pietervdvn> ok, thanks a lot
09:49:50 <nisstyre> http://www.reddit.com/r/haskell/comments/312nu8/proposal_improving_layout/
09:49:55 <nisstyre> some good ideas here
09:51:16 <johnw> heh
09:51:22 <johnw> the thriving APL community
09:56:36 <jellie> What's the best way to convert seconds into: x days: y hours: z minutes : w seconds?
09:59:28 <ion> jellie: quotRem
09:59:29 * hackagebot stackage-curator 0.7.1 - Tools for curating Stackage bundles  http://hackage.haskell.org/package/stackage-curator-0.7.1 (MichaelSnoyman)
09:59:31 * hackagebot blaze-json 0.1.0 - tiny library for encoding json  http://hackage.haskell.org/package/blaze-json-0.1.0 (HirotomoMoriwaki)
09:59:40 <jellie> ion: What?
09:59:47 <jellie> :t quotRem
09:59:48 <lambdabot> Integral a => a -> a -> (a, a)
09:59:50 <ion> > 123 `quotRem` 60
09:59:51 <lambdabot>  (2,3)
10:03:45 <haskell_newbie> test
10:03:52 <indiagreen> hi, haskell_newbie 
10:03:54 <haskell_newbie> ist this working 
10:04:01 <haskell_newbie> AHHHH great !!!
10:04:13 <haskell_newbie> real people here?
10:04:42 <haskell_newbie> so you all are experienced haskell users right?
10:05:01 <geekosaur> it's a mixture
10:05:07 * awesomehaircut is as experience as a potato
10:05:23 <sellers> haskell_newbie: Nope, green as grass
10:05:29 <haskell_newbie> i have a question, is anybody using this language "professionel" .. in the job?
10:05:34 <awesomehaircut> Does anyone use geany to write haskell programs?
10:05:54 <indiagreen> haskell_newbie: some people do
10:05:54 <Redz> awesomehaircut: me
10:05:58 <indiagreen> me, too
10:06:06 <indiagreen> wait, no
10:06:09 <indiagreen> wrong question
10:06:12 <indiagreen> sorry
10:06:20 <haskell_newbie> great!!! is haskell REALLY usefull in any kind of problem???? 
10:06:36 <Redz> i mean i use geany. ;)
10:06:37 <Myrl> Hi guys.
10:06:43 <Myrl> Is there a way to make this shorter?
10:06:44 <Myrl> (\x y -> compare (length x)(length y))
10:06:55 <haskell_newbie> i HAVE to learn it now, but i dont see any use for this language...
10:07:04 <Redz> haskell_newbie: its useful in all kinds of problems.
10:07:08 <indiagreen> Myrl: there's “comparing”
10:07:10 <indiagreen> :t comparing
10:07:11 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
10:07:20 <indiagreen> so, your thing is “comparing length”
10:07:20 <Redz> haskell_newbie: how did you use other languages? 
10:07:24 <awesomehaircut> redz: cooool I wanted to ask how to change the comment command to not have a #
10:07:28 <Welkin> haskell_newbie: are computers useful?
10:07:35 <haskell_newbie> :-)
10:08:06 <Redz> awesomehaircut: uh, i never fixed that. 
10:08:13 <hiptobecubic> Welkin, a net loss or productivity I'd say.
10:08:14 <Myrl> indiagreen: I see.
10:08:16 <platz> haskell_newbie: Since you never know how what you learn now will impact what you do in the future, only learning for the sake of making doesn't work for everyone.
10:08:18 <hiptobecubic> of*
10:08:33 <haskell_newbie> ok, maybe i come back in some days... i just started learing... and wanted to check out if there is really anybody using his lnguage... obv there are! you guys do.......
10:08:40 <Myrl> "sortBy (comparing length)" That sounds so English.
10:08:44 <Myrl> Thanks indiagreen.
10:09:02 <awesomehaircut> Redz: I'm getting help at #geany
10:09:11 <haskell_newbie> ok, bye
10:09:24 <hiptobecubic> ahhhh geany. Those were the days
10:09:30 * hackagebot cabal-debian 4.24.9 - Create a Debianization for a Cabal package  http://hackage.haskell.org/package/cabal-debian-4.24.9 (DavidFox)
10:09:32 * hackagebot aeson-schema 0.3.0.1 - Haskell JSON schema validator and parser generator  http://hackage.haskell.org/package/aeson-schema-0.3.0.1 (TimBaumann)
10:10:11 <ski> Myrl : you can also do stuff like `sortBy (comparing length <> compare)' to primarily sort by length, secondarily (amongst words with the same length) using the default ordering (lexicographic ordering for lists, here strings)
10:10:48 <Myrl> ski: I see.
10:11:51 <ski> Myrl : see Cale's <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx> for some info on how that works
10:12:32 <awesomehaircut> what do you use hiptobecubic
10:13:43 <hiptobecubic> awesomehaircut, I used geany for about a year until I switched to vim (in ~2008)
10:14:08 <Myrl> ski: Thanks.
10:14:30 * hackagebot charset 0.3.7.1 - Fast unicode character sets based on complemented PATRICIA tries  http://hackage.haskell.org/package/charset-0.3.7.1 (EdwardKmett)
10:14:32 * hackagebot blaze-builder-enumerator 0.2.1.0 - Enumeratees for the incremental conversion of builders to  bytestrings.  http://hackage.haskell.org/package/blaze-builder-enumerator-0.2.1.0 (MichaelSnoyman)
10:14:37 <hiptobecubic> I liked geany though. As far as light IDEditors go I thought it was good
10:14:42 <awesomehaircut> I wish I could use Vim for more than five minutes without getting frustrayed hitting the keyboard and colorful stuff hapening
10:14:58 <hiptobecubic> awesomehaircut, yes the learning curve is *a little* steep
10:15:19 <hiptobecubic> now I start hitting the keyboard when I have to use something else
10:15:38 <Welkin> awesomehaircut: I had the same difficulty with emacs and I hated it
10:15:51 <Welkin> after spending two days playing with emacs and customizing it, I never looked back
10:15:58 <Welkin> it is incredibly easy to use now
10:16:03 <awesomehaircut> i tried using emacs, cause when i hit the keyboard nothig too weird happen
10:16:09 <hiptobecubic> That's how it usually goes, yeah
10:16:45 <oakwhiz> is there a way to round up or round down in Haskell? e.g. Double -> Int
10:17:01 <Welkin> > round 1.6
10:17:03 <lambdabot>  2
10:17:06 <ski> @type ceiling :: Double -> Int
10:17:07 <lambdabot> Double -> Int
10:17:08 <Welkin> > floor 1.6
10:17:10 <lambdabot>  1
10:17:18 <ski> @type floor :: Float -> Integer
10:17:19 <lambdabot> Float -> Integer
10:17:26 <ski> @type round
10:17:27 <lambdabot> (Integral b, RealFrac a) => a -> b
10:17:51 <Welkin> `round` always rounds up I believe
10:17:53 <Welkin> > round 1.2
10:17:55 <lambdabot>  1
10:17:57 <Welkin> oh
10:18:03 <Welkin> > round (-1.2)
10:18:05 <lambdabot>  -1
10:18:05 <awesomehaircut> i've been learning haskell for about two weeks and i still feel weird how clean things are haha
10:18:06 <arkeet> round roundes to nearest, with .5 going to even
10:18:10 <arkeet> > map round [0.5, 1.5]
10:18:11 <lambdabot>  [0,2]
10:18:12 <Welkin> that was the difference
10:18:18 <arkeet> rounds*
10:18:24 <oakwhiz> Weird that floor is Float -> Integer but ceiling is Double -> Integer
10:18:28 <oakwhiz> well
10:18:28 <ski> `ceiling' rounds to the next greatest integer (well, the same integer, if the input already is one)
10:18:31 <arkeet> they can both be both.
10:18:32 <hiptobecubic> oakwhiz, it's not. that's just lambdabot
10:18:35 <oakwhiz> oh
10:18:36 <arkeet> :t floor
10:18:37 <lambdabot> (Integral b, RealFrac a) => a -> b
10:18:37 <ski> @type ceiling :: Float -> Integer
10:18:38 <lambdabot> Float -> Integer
10:18:48 <arkeet> Float and Double are both RealFrac instances
10:18:52 <Myrl> ski: Does <> exist in Hugs?
10:19:01 <oakwhiz> Well thanks everybody
10:19:04 <ski> Myrl : `mappend' is another name for it
10:19:08 <oakwhiz> I need more caffeine
10:19:17 <Myrl> ski: Ah. I see.
10:19:19 <hiptobecubic> oakwhiz, or less
10:19:23 <ski> Myrl : perhaps try importing `Data.Monoid'
10:20:02 <ski> > sortBy (comparing length `mappend` compare) (words "The quick brown fox jumps over the lazy dog")
10:20:03 <lambdabot>  ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
10:20:09 <Myrl> ski: I have, but it only loaded mappend, not <>
10:20:28 <arkeet> people still use hugs?
10:20:28 <ski> Myrl : so try using `mappend' as in the example above
10:20:38 <Myrl> ski: Mhm. Thanks, by the way.
10:20:41 <Welkin> > round (-1.5)
10:20:42 <lambdabot>  -2
10:20:43 <Welkin> > round 1.5
10:20:44 <lambdabot>  2
10:20:47 <ski> (the name `(<>)' was introduced later than `mappend')
10:21:10 <ski> arkeet : possibly some universities still use it for some courses ?
10:21:33 <arkeet> it's been unmaintained now for what, 12 years?
10:21:36 <ski> (iirc, it's also a bit more portable)
10:21:41 * ski can't recall
10:21:43 <arkeet> 9
10:22:08 <ski> (yea, was just about to say that istr a release in 2006)
10:23:06 <geekosaur> I also recall that, and that it was just minor compile fixes
10:23:12 <geekosaur> (no new functionality)
10:28:31 <jellie> Hey what does NominalDiffTime mean? http://hackage.haskell.org/package/time-1.5.0.1/docs/Data-Time-Clock.html#t:NominalDiffTime
10:28:46 <jellie> I thought it meant time difference in seconds but it doesn't
10:29:16 <geekosaur> "It has a precision of 10^-12 s"
10:29:24 <geekosaur> quioted from that very page
10:29:31 * hackagebot xml-picklers 0.3.6 - XML picklers based on xml-types, ported from hexpat-pickle  http://hackage.haskell.org/package/xml-picklers-0.3.6 (PhilippBalzarek)
10:29:51 <geekosaur> and from the source link to the right: newtype NominalDiffTime = MkNominalDiffTime Pico
10:29:57 <jellie> geekosaur: So it is time difference in seconds?
10:30:02 <geekosaur> ...
10:30:16 <geekosaur> what does "10^-12 s" mean to you?
10:30:20 <Welkin> oh boy
10:30:27 <jellie> geekosaur: Because when I run it a few seconds apart it gives me time differences that are way less than a second
10:30:32 <geekosaur> yes, sorry, I'm a bit grumpy
10:30:38 <geekosaur> "picoseconds"
10:30:42 <jellie> It means it can get up to 10^-12 of a second
10:30:55 <geekosaur> how are you delaying a few seconds?
10:30:55 <jellie> but that's not what it seems to be doing in my case
10:31:20 <geekosaur> (if you are using threadDelay then beware of the gotcha on that --- read its docs carefully)
10:31:39 <jellie> No I'm doing it physically. Let me demonstrate.
10:32:03 <jellie> >let x = getCurrentTime
10:32:08 <geekosaur> @paste
10:32:09 <lambdabot> Haskell pastebin: http://lpaste.net/
10:32:23 <geekosaur> you are doing this in ghci?
10:32:41 <jellie> geekosaur: No but I think it can be done in ghci too
10:32:43 <jellie> >let y = getCurrentTime
10:32:53 <roboguy_> jellie: shouldn't you do x <- getCurrentTime?
10:32:58 <geekosaur> also, that does not do what you think
10:33:13 <jellie> then liftA2 diffUTCTime y x
10:33:21 <geekosaur> `let x = getCurrentTime` gives you an alias to getCurrentTime
10:33:30 <roboguy_> jellie: that will probably run both at basically the same exact time
10:33:32 <geekosaur> not the time at the point where you do the let
10:33:45 <geekosaur> right, so that's showing you how long liftA2 tajes
10:33:47 <geekosaur> *takes
10:33:57 <geekosaur> use <- for both
10:34:14 <roboguy_> yeah, that's the same as liftA2 diffUTCTime getCurrentTime getCurrentTime
10:34:23 <jellie> roboguy_: I can do: `x <- getCurrentTime` in ghci?
10:34:27 <roboguy_> yeah
10:34:28 <geekosaur> yep
10:34:45 <jellie> lets see but I still don't think it will work
10:34:50 <roboguy_> ghci is sorta like being in a do block
10:35:02 <jellie> x <- getCurrentTime
10:35:04 <jellie> >x <- getCurrentTime
10:35:08 <jellie> >y <- getCurrentTime
10:35:16 <jellie> :t x
10:35:17 <lambdabot> Expr
10:35:22 <jellie> Ah
10:35:24 <clrnd> jellie, lambdabot won't do IO
10:35:25 <roboguy_> jellie: you need a space after > to use lambdabot
10:35:32 <roboguy_> also yeah, lambdabot doesn't run IO
10:35:36 <jellie> Anyway you get my point
10:36:09 <geekosaur> no, I don't, because it works here
10:36:18 <geekosaur> if you use <-, note that you no longer need liftA2
10:36:35 <roboguy_> it seems to work okay for me too. The let version and the <- version do two very different things, so I'm getting different results as I'd expect
10:36:36 <geekosaur> Prelude Data.Time.Clock Control.Applicative> diffUTCTime y x
10:36:36 <geekosaur> 11.043148s
10:38:43 <geekosaur> also note that lambdabot doesn't remember bindings across invocations unless you use @let (and don't do that, in general)
10:39:29 <jellie> geekosaur: See line 25? https://gist.github.com/urbanslug/54bebc3027c9369b4fd6#file-nyan-hs-L25
10:40:04 <Luke> Data.IntMap.Strict says this: "Be aware that the Functor, Traversable and Data instances are the same as for the Data.IntMap.Lazy module, so if they are used on strict maps, the resulting maps will be lazy." -- What exactly does that mean in practice?
10:40:10 <jellie> geekosaur: Could you please join #zippy for a better demo of that code at work?
10:40:40 <jellie> geekosaur: It's a bot that should work when @seen is called but it's giving something way less than seconds
10:41:49 <geekosaur> as far as I can see, that is comparing now to the time at which the @seen was received, which should be quite short
10:42:13 <hsk4> What do you guys think about http://elixir-lang.org
10:42:19 <hsk4> just heard of it this week
10:42:25 <jellie> geekosaur: Really?
10:42:28 <jellie> hmmm
10:42:52 <geekosaur> it looks like the same code is trying to track people and respond to @seen at the same time. those are logically separate
10:43:01 <geekosaur> but appear to be conflated here
10:43:27 <jellie> geekosaur: Well yes the code isn't okay yet.
10:43:43 <jellie> I thought t is time it's pulling from the map
10:44:13 <geekosaur> it is. but it's *building* the map before querying it
10:44:32 * hackagebot comptrans 0.1.0.5 - Automatically converting ASTs into compositional data types  http://hackage.haskell.org/package/comptrans-0.1.0.5 (JamesKoppel)
10:44:36 <geekosaur> because you are doing the tracking and the responding in the same invocation
10:45:00 <hiptobecubic> hsk4, what I don't see on the page is a reason to use it over erlang
10:45:32 <geekosaur> so it is tracking only the thing that caused it to be invoked, and the last-seen for that is obviously going to be pretty short
10:46:15 <hsk4> hiptobecubic: yeah
10:46:23 <ski> hsk4 : i've mostly heard negative remarks about it, from one of the contributers to OTP
10:46:27 <jellie> geekosaur: I guess it makes sense because one shouldn't pull a last seen of themselves which is what I'm doing
10:46:40 <geekosaur> right
10:47:12 <ski> (one complaint, iirc, being that it makes mutable variables too easy to use)
10:47:14 <clrnd> huh, sdl2 seems to require sdl 2.0.3 and ubntu has 2.0.2, c'mon please ...
10:47:14 <geekosaur> your @seen bot needs two entrypoints. one triggers on any channel message and updates seen for the sending nick, and does not report. the other responds to @seen and reports from the saved map
10:47:45 <hiptobecubic> "Note a dot (.) between the variable and parenthesis is required to invoke an anonymous function."
10:48:03 <ski> (also, iirc, if you only bind a variable in some (but not all) of the branches of a `case'/&c., then if one of the other branches are taken, you'll get some default value like `nil')
10:48:54 <ski> (in Erlang, you have to bind it in all branches for it to be in scope after the `case')
10:49:03 <jellie> :t mod
10:49:04 <lambdabot> Integral a => a -> a -> a
10:49:43 <jellie> @hoogle (Num a, Integral b) :: a -> b
10:49:45 <lambdabot> Parse error:
10:49:45 <lambdabot>   (Num a, Integral b) :: a -> b
10:49:45 <lambdabot>                         ^
10:50:04 <roboguy_> :t floor
10:50:05 <lambdabot> (Integral b, RealFrac a) => a -> b
10:50:31 <ski> @hoogle (Num a,Integral b) => a -> b
10:50:31 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
10:50:31 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
10:50:31 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
10:52:16 <jellie> LOL if I keep messing up like this I should just kill myself and save my family the shame
10:52:30 <jellie> round sounds great
10:53:01 <roboguy_> > round 2.5
10:53:02 <lambdabot>  2
10:53:05 <roboguy_> > round 2.6
10:53:06 <lambdabot>  3
10:53:18 <jellie> roboguy_: I thought 2.5 should be 6
10:53:23 <roboguy_> me too
10:53:23 <ski> > round 3.5
10:53:24 <lambdabot>  4
10:53:49 <geekosaur> you may be trying to figure out too many new things at once. I never thought an IRC bot was a good first Haksell project
10:53:53 <roboguy_> might be some floating point weirdness
10:54:07 <ski> it's called Banker's rounding. see <https://en.wikipedia.org/wiki/Banker's_rounding#Round_half_to_even>
10:54:19 <hiptobecubic> make somtehing stateless for your first project if you cna
10:54:33 <roboguy_> ahh
10:54:33 * hackagebot snap-core 0.9.7.0 - Snap: A Haskell Web Framework (core interfaces and types)  http://hackage.haskell.org/package/snap-core-0.9.7.0 (GregoryCollins)
10:55:10 <geekosaur> (yeahyeah, I started with a window manager. But, I already knew X11 window management before I wrote a line of code...)
10:55:15 <ski> (apparently also known as unbiased rounding,convergent rounding,statistician's rounding,Dutch rounding,Gaussian rounding,odd-even rounding,broken rounding)
10:56:19 <Welkin> a widow manager!
10:56:42 <hsk4> Is Erlang more popular for web apps?
10:56:45 <sivteck> s/widow/window
10:56:56 <Welkin> no sivteck, I meant widow
10:56:57 <hsk4> (as opposed to Snap/Happstack/Yesod with Haskell)
10:57:03 <sivteck> oh ;p
10:57:09 <Welkin> hsk4: no
10:57:46 <Welkin> web apps in haskell are a joy to build
10:59:01 <hsk4> Welkin: you use snap?
10:59:28 <Welkin> hsk4: I use yesod
10:59:33 * hackagebot snap-server 0.9.5.0 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.9.5.0 (GregoryCollins)
11:00:13 <hsk4> Welkin: ok. yesod is more like rails and snap is more of a sinatra ain't they?
11:00:20 <hsk4> snap more minimalistic
11:00:56 <Welkin> scotty is like sinatra
11:01:05 <Welkin> I don't know about snap
11:02:37 <Lis> how do i define a function with no argument ? foo :: ?? -> b
11:02:38 <Lis> ?
11:02:49 <Welkin> well
11:02:52 <roboguy_> Lis: it isn't a function if it doesn't have an argument
11:02:57 <Welkin> if it doesn't have any parameters, it is a value
11:02:59 <roboguy_> it's just a non-function value
11:02:59 <Lis> indeed thats true
11:03:00 <Welkin> not a function
11:03:07 <Welkin> so, :: a
11:03:28 <Welkin> five :: Int
11:03:29 <Welkin> five = 5
11:03:33 <hsk4> Welkin: thanks
11:05:45 <Ryanar> hey guys, when people join IRC chats you see ~johndoe@12341234abc.john.doe.net, would it be a useful feature to build an IRC bot that sits in a channel and records where users are logging in from and aggregates the data to allow other people who use *john.doe.net to connect?
11:06:12 <Ryanar> relevance: I wanted to do it as a project to continue learning haskell
11:06:40 <Ryanar> but if this kind of thing is already trivial to do then I wouldn't be doing anything useful
11:07:09 <Luke> hey guys. just posted a haskell question on SO: http://stackoverflow.com/questions/29397711/how-can-data-intmap-strict-be-made-accidentally-lazy-in-practice
11:07:36 <Luke> looking for help in refining the question or even better, an answer =)
11:07:47 <roboguy_> Ryanar: I'm not sure I understand. Wouldn't they be able to connect anyway or would it be a private channel?
11:07:55 <koala_man> Ryanar: I'd have used grep on the channel log
11:08:59 <Ryanar> roboguy_, I dont have lot of experience with irc, but how would they be able to easily connect? Unless I am looking at the log when john.doe.net user logs in I don't know that they are in the channel
11:09:33 <roboguy_> Ryanar: wait, what do you mean by connect?
11:09:37 <Welkin> the protocol specifies a command to list the users in the channel
11:09:40 <Welkin> read the IRC spec
11:10:38 <geekosaur> Luke: afaik the difference between strict and lazy maps is strictness annotations in the actual functions, so if you use the lazy version then it doesn't force the value before adding it to the map
11:10:39 <indiagreen> Luke: the IntMap type exported by the Strict module is the same as the type exported by the Lazy module. The Strict module just exports functions that are strict instead of lazy
11:10:51 <indiagreen> if you want to use lazy map, you can use fmap
11:10:52 <Ryanar> roboguy_, could either a) inform you of the user names of the people, b) send out private messages to inform the people of others in the same area/location c) invite them to join a channel and host it
11:11:05 <indiagreen> if you want to use strict fmap, you should use “map” from the Strict module
11:11:15 <Luke> I guess the real question is what's the right way to keep the map strict?
11:11:35 <indiagreen> import the Strict module and don't use generic functions (such as fmap and friends)
11:11:39 <geekosaur> only use the functions from .Strict
11:12:06 <Luke> so basically don't use traversals?
11:12:45 <arkeet> you are free to use traverseWithKey from .Strict
11:12:56 <Luke> arkeet: no that's what the docs say doesn't work
11:13:04 <Luke> it's the same function as the lazy version
11:13:11 <arkeet> oh ah.
11:13:15 <arkeet> well that's silly.
11:13:19 <Luke> I think I need to use foldr and foldl with key instead of traverse
11:13:24 <Ryanar> Welkin, you can list users but can you filter the list based on what network they are coming from?
11:13:51 <nitrix> I hate april fools.
11:13:51 <Welkin> once you get the user list, you can do anything you want with it
11:13:54 <nitrix> https://www.youtube.com/watch?v=qi34UHp8jsU
11:13:58 <nitrix> Some clever guy at work did that.
11:14:07 <nitrix> Took me almost 2 hours until I figured it out :(
11:14:36 <Welkin> nitrix: so you crossed your legs and danced about for 2 hours?
11:15:13 <clrnd> I just had to clone-to-modify-upper-bounds a project, I can see what the argument is all about
11:15:27 <nitrix> More like circling around the office hoping "he"'d be done soon.
11:15:34 <nitrix> >_>
11:15:39 <Welkin> a better april fools prank would be to hand out pink slips and tell employees "you're fired"
11:15:51 <JordiGH> Goddammit I hate YouTube autoplay.
11:16:00 <Welkin> JordiGH: I have it turned off
11:16:03 <JordiGH> nitrix: I had to watch two seconds of sportsball.
11:16:12 <JordiGH> Welkin: I have cookies turned off, so I guess it comes back.
11:19:02 <lseppala> Are the separate parts of an applicative automatically processed in parallel given the threaded runtime? I've taken this for granted, but I really don't know
11:19:32 <jle`> just joined, but... lseppala , it depends on the instance
11:19:45 <jle`> (i might have missed some context)
11:20:20 <c_wraith> lseppala: In general, they're never processed in parallel unless you've put effort into making that happen.
11:20:22 <lseppala> jle`: Ah, of course.
11:20:47 <jle`> you should probably assume they are not, because there are far fewer ones that don't than do in the wild
11:20:57 <jle`> when in doubt, just look at the instance definition
11:21:08 <lseppala> Hmm. Are there any common ones that are? IO, perhaps?
11:21:11 <jle`> remember, <*> and pure are just "normal functions" you can define
11:21:18 <Lis> http://www.mathematek.de/paste:haskell_read_list how to solve this error?
11:21:21 <jle`> IO is not;
11:21:31 <jle`> instance Applicative IO where pure = return; (<*>) = ap
11:21:34 <jle`> @src ap
11:21:35 <lambdabot> ap = liftM2 id
11:21:45 <jle`> ap uses sequential sequencing
11:21:48 <c_wraith> lseppala: the only one I can think of offhand is the one for facebook's query language.  Haxl?
11:22:21 <lseppala> yeah, I guess that would make sense
11:23:05 <clrnd> I did a ConcurrenT once that ran <*> in parallel
11:23:07 <roboguy_> Lis: did you try IO String?
11:23:41 <Lis> hm but i want to return a [[String]] of the parsed csv
11:23:46 <jle`> also some instances might behave worse when run in parallel.  consider Maybe's Applicative instance...if the initial on evaluates to Nothing, then we can skip evaluating the second one altogether
11:23:56 <jle`> s/worse/less efficient
11:24:01 <roboguy_> Lis: or IO (Either ParseError [[String]])
11:24:35 <jle`> and i think State is impossible to evaluate in parallel because the second one's result depends on the final state of the first one
11:24:52 <jle`> (for the Applicative instance at least)
11:25:28 <roboguy_> jle`: you might be able to terminate the evaluation of the other side if the first one evaluates to Nothing
11:25:41 <roboguy_> I think that's how unamb works
11:25:51 <roboguy_> (well, sorta)
11:26:46 <lseppala> Right, that'd make sense. We're using applicative builds up a value by sending out web requests for each of its parts. So, the applicative instance for EitherT a IO b. I naively thought, 'oh, this is mostly safe to parallel, surely it does'. But short-circuiting for the Left/Error case would be tricky
11:26:47 <jle`> hm. yeah, that might make the two have the same performance disregarding overhead from parallelism
11:26:47 <Lis> roboguy_, same error with IO (Either ParseError [[String]])
11:27:01 <roboguy_> Lis: what is the type of parseCSV?
11:27:26 <Lis> parseCSV :: String -> Either ParseError [[String]]
11:27:31 <roboguy_> you need a return call around the parseCSV call
11:27:48 <roboguy_> :t return
11:27:49 <lambdabot> Monad m => a -> m a
11:27:52 <roboguy_> in this case, m = IO
11:28:03 <jle`> btw if you want to do a bunch of "Either"'s in parallel, where none of the actions depend ont he results of the other (ie, sequence, liftA2, etc.), you might benefit from that Validation Either Applicative instance
11:28:17 <jle`> 'parallel' in a data dependency sense
11:29:09 <Lis> ty again
11:31:35 <Lis> and how to define a function without return type ?
11:32:02 <Lis> hm guess ()?
11:32:11 <ski> the return values of a function always have some type
11:32:13 <roboguy_> Lis: functions always have return types. What are you doing?
11:32:26 <ski> `()' can be used as an "uninteresting type", yes
11:32:35 <ski> (as in "uninteresting result", e.g.)
11:33:18 <roboguy_> but you almost never want that as a return type
11:33:19 <Lis> roboguy trying to write a csv parser. which i currently use to save programm configurations
11:33:34 <roboguy_> Lis: I mean, specifically what are you doing where you want a function without a return type?
11:33:55 <lseppala> Lis: if you're saving to the disk, sounds like it'll be IO ()
11:34:06 <Lis> saving the modified configurations back to the file roboguy_ 
11:34:24 <Lis> aha
11:34:42 <Lis> ty :D
11:39:36 * hackagebot srcloc 0.5.0.1 - Data types for managing source code locations.  http://hackage.haskell.org/package/srcloc-0.5.0.1 (GeoffreyMainland)
11:41:53 <Lis> hm two hours i continue with haskell then back to the boredom of php
11:42:30 <koala_man> if PHP is merely boring you're doing a good job at it
11:42:57 <tdammers> koala_man: not really, no
11:43:13 <tdammers> if it's boring, it means you're putting up with stupid repetitive work
11:43:27 <tdammers> developer time is too expensive to spend on repetitive work
11:43:52 <tdammers> but then, developer time is also too expensive to spend on PHP code
11:44:08 <tdammers> also, #-blah material
11:44:36 * hackagebot lhs2tex 1.19 - Preprocessor for typesetting Haskell sources with LaTeX  http://hackage.haskell.org/package/lhs2tex-1.19 (AndresLoeh)
11:44:51 <koala_man> I had a summer job with PHP once. it was the first time I was responsible for the loss of thousands of dollars, after PHP silently ignored a database error in favor of showing my form
11:45:27 <sinelaw> koala_man, ruby style
11:45:42 <sinelaw> "Our goal is a type system that is predictable enough to be used by ordinary programmers; and simple enough to be implemented without heroic efforts" 
11:46:12 <hiptobecubic> Why do they care if it's simple enough to be implemented without heroic efforts?
11:46:14 <tdammers> that's still better than the millions of production sites that use PDO, contain insufficiently tested database access code, and are misconfigured to dump all uncaught exceptions and errors into the HTTP response
11:46:57 <tdammers> also, "predictable" is not the only thing you need for a type system to be usable by average joe programmer
11:47:08 <tdammers> otherwise, Haskell would be more successful
11:47:53 <sinelaw> hiptobecubic, because they (SPJ included) had to implement it in GHC
11:48:12 <sinelaw> this is from a paper about type inference for GADTs
11:49:20 <Lis> i choose haskell over ruby
11:49:41 <aommm> Hi! I have a question regarding parsing with HXT. It is based on Arrows, and all arrows I use implement the ArrowXml class (http://hackage.haskell.org/package/hxt-9.3.1.15/docs/Text-XML-HXT-Arrow-XmlArrow.html). I wonder if there is a way to guard against selector arrows failing?  In the link it says that "selector arrows will fail, when applied to wrong input". From what I have seen, when this happens the whole computation just stops w
11:50:09 <Lis> while looking for a new language to do my web work with. haskell has a much clearer source structure if you get used to the -> :: and () $ etc. stuff
11:50:33 <Lis> also you can tweak the source much mor easy. granted if you write a function in haskell it's reusable
11:50:33 <sinelaw> Lis, cool, that is just the tip of a very, very large iceberg
11:50:50 <tdammers> ruby has weird symbols too
11:50:59 <sinelaw> and they are dynamically resolved
11:51:03 <tdammers> at least you can define your own weird symbols in Haskell
11:52:23 * ski notes that aommm's message was cut off at ".. From what I have seen, when this happens the whole computation just stops w"
11:52:31 <tdammers> > let a ^:^ b = "OMG " ++ a ++ ", I *love* " ++ b ++ "!" in "honey" ^:^ "lasagna"
11:52:33 <lambdabot>  "OMG honey, I *love* lasagna!"
11:52:54 <roboguy_> aommm: I suspect "fail" means arrowZero, but I don't have any experience with that
11:53:17 <aommm> the whole computation just stops, w...hich is unfortunate. :)
11:53:47 <roboguy_> aommm: hmm, how about using ArrowPlus?
11:54:05 <aommm> yes, I also think that it results in arrowZero (or none, as I know it)
11:54:13 <roboguy_> it shouldn't...
11:54:37 <roboguy_> ArrowPlus is a monoid with arrowZero as its identity so arrowZero <+> x = x = x <+> arrowZero
11:54:58 <Vhictour> Please I need someone who can tell me or teach me Haskell or c++, I'm new to this.
11:55:23 <Lis> aommm, what you mean by it stops? it's possible you dont traverse your xml tree properbly. like difference of multi and childs ? whats the line for your element selection?
11:55:43 <Lis> only multi >>> ... continues if elements are found
11:55:51 <mmachenry> Vhictour: You're unlikely to get a tutor here but there are many great books and webpages on Haskell.
11:55:54 <mmachenry> @where lyah
11:55:54 <lambdabot> http://www.learnyouahaskell.com/
11:55:58 <mmachenry> Try that.
11:56:10 <roboguy_> Vhictour: people definitely answer questions here though
11:56:55 <Vhictour> mmachenry: I know... But I can't understand them
11:57:11 <Lis> Vhictour, first before learning a language you should know what you use it for
11:57:14 <lpaste> clrnd pasted “cairo 0.12” at http://lpaste.net/129986
11:57:24 <clrnd> I just can't  install cairo 0.12
11:57:34 <mmachenry> Vhictour: What don't you understand?
11:57:35 <roboguy_> Vhictour: well, if you have any questions you should feel free to ask. There's usually at least one person here who'll help
11:57:46 <Vhictour> Lis: I need to learn c++
11:58:05 <sellers> Vhictour: then why come to #haskell?
11:58:06 <mmachenry> Vhictour: This is not the right place for that. 
11:58:31 <geekosaur> that looks like it should depend on a particular Cabal library version range, but doesn't
11:58:41 <Vhictour> mmachenry: why all those signs like /****************/
11:59:03 <aommm> I am not sure what I mean by "it stops". :) it doesn't seem to continue in the sequencing, E.g. a >>> b >>> c, if b fails then c is never run. Although, now that I think about it, I am not sure what I think ought to happen in this scenario
11:59:05 <roboguy_> Vhictour: this channel is for Haskell stuff and there is another channel for C++ stuff. (Also, that line you gave is just a comment. It doesn't do anything)
11:59:13 <clrnd> geekosaur, it does seem like that, there is a #if CABAL_CHECK_VERSION(1,22,0) near the eror
11:59:15 <sinelaw> Vhictour, try ##c++
11:59:32 <Lis> aommm, look above. use multi read the hxt doc
11:59:51 <aommm> yes, will do!
11:59:54 <geekosaur> in any case that's cabal version skew, I don't know cabal internals well enough to help
12:00:06 <clrnd> me neither
12:00:13 <aommm> thanks for the quick answers
12:00:28 <clrnd> I could --ghc-options=-DVAR but I don't know the VAR I;m supposed to set
12:00:34 * geekosaur hoping one of the experts will notice, rather than ping someone who certainly knows but is busy
12:00:39 <roboguy_> aommm: yeah, b needs the output from a
12:00:45 <Vhictour> roboguy_: I know but.. How many ** and why // works for only some
12:01:02 <geekosaur> Vhictour, this is not the right channrl
12:01:05 <geekosaur> *channel
12:01:14 <geekosaur> ask C/C++ questions in ##c or ##c++
12:01:16 <roboguy_> Vhictour: These questions are more appropriate for ##C++ or #C++-general
12:01:18 <geekosaur> not here
12:01:20 --- mode: ChanServ set +o geekosaur
12:01:28 <Lis> https://wiki.haskell.org/HXT : A variant of
12:01:28 <Lis> deep
12:01:28 <Lis> , called
12:01:28 <Lis> multi
12:01:28 <Lis> , performs a complete search, where the tree traversal does not stop when a node is found. 
12:01:33 <Lis> wtf
12:02:43 <Vhictour> Who know how to hack WiFi networks WPA with windows?
12:03:28 <tdammers> Vhictour: why are you asking this on a channel dedicated to the Haskell programming language?
12:03:43 --- mode: ChanServ set +o monochrom
12:03:47 <geekosaur> Vhictour, final warning. use an appropriate channel
12:04:02 <Vhictour> tdammers: nothing more?
12:04:15 <geekosaur> (there is no appropriate channel on freenode for that last question)
12:04:23 <Vhictour> geekosaur: okay okay!!
12:04:26 <geekosaur> chanels exist for a reason
12:04:42 <Desu> Vhictour: http://www.somethingawful.com/hosted/jeffk/
12:04:46 <Desu> Vhictour: he is a pro hacker
12:04:57 <geekosaur> #haskell is fairly busy, offtopic causes problems, we have several offtopic channels plus freenode has lots of topic-focused channels
12:06:09 <Vhictour> Desu: thanks
12:06:34 <Hijiri>   /disconnect
12:07:36 --- mode: geekosaur set -o geekosaur
12:07:49 <zomg> Desu: lol, been a while since I saw that
12:07:56 <aommm> I don't think multi is what I want. I know that it is at this level of the tree, if any
12:08:35 <aommm> ifIsNone a b c
12:08:57 <aommm> is what I am asking for. I think
12:09:03 <roboguy_> aommm: what would that do?
12:09:19 <aommm> so, a way to supply a default value whenever "none", or arrowZero, is encountered
12:09:27 <aommm> that would be b
12:09:37 * hackagebot fixedwidth-hs 0.1.0.0 - Quick parsing of fixed-width data formats.  http://hackage.haskell.org/package/fixedwidth-hs-0.1.0.0 (MichaelOChurch)
12:09:41 <aommm> so that it will continue in the chain of arrows, with that value
12:09:52 <roboguy_> aommm: wouldn't that be (a <+> b) >>> c?
12:10:55 <roboguy_> well, maybe not exactly
12:12:09 <roboguy_> aommm: maybe something from ArrowIf?
12:12:40 <Vhictour> Okay.. Can Haskell be used in programming worms?
12:13:16 <platz> i'm suprised the Groom package isn't more popular; does everyone just use pretty/pretty-show or not bother?
12:13:45 <aommm> Will look into it. "The empty list as result represents False, none empty lists True.".
12:13:59 <platz> writing custom pretty instances seems tedious for lots of data just to get something to print hierarchically
12:15:34 <EvanR> platz: maybe people avoid nested data
12:15:56 <EvanR> for other reasons, and so dont bother with pretty printing heterotyped trees
12:17:30 <platz> I could appreciate that.
12:18:16 <platz> seems like some things are hierarchical in the problem domain though. for example, usb devices, properties, and attributes
12:18:58 <sellers> Newbie working through Hutton's writeup on monads: http://www.cs.nott.ac.uk/~gmh/monads  I'm confused about the exercise at the very bottom, making a monad instance out of data Expr a = Var a | Val Int | Add (Expr a) (Expr a).  I can't seem to come up with a >>= for Val n that satisfies to monad laws.  My code snippet, which includes the full problem: http://sprunge.us/BgSX
12:19:21 <sellers> I know this looks like homework, but I'm not in school I promise :P Just learning haskell on my own
12:20:52 <roboguy_> sellers: I believe there are two possible type checking definitions (excluding some 'fixed' ones) for that, and you have one there
12:21:25 <monochrom> Val x >>= _ = Val x
12:22:02 <conal> sellers: the wrong Val >>= case doesn't type-check either.
12:22:11 <sellers> monochrom: That would typecheck and follow the monad laws, but is that really what it's looking for?  Why would you just throw f away?
12:22:13 <sellers> conal: oops
12:22:19 <monochrom> here is why. with "data Maybe a = Nothing | Just a", you write "Nothing >>= _ = Nothing". this is analogous.
12:22:53 <monochrom> i.e., imagine one day you have "data Funny a = NothingButInt Int | Just a".
12:23:13 <conal> sellers: and there's nothing you can do with f in that case (since there's no 'a' value in scope).
12:23:20 <Welkin> monochrom is wearing a monocle today
12:23:35 <roboguy_> sellers: have you tried implementing Functor for the type?
12:23:48 <monochrom> here is another perspective. "data Either t a = Left t | Right a", you write "Left t >>= _ = Left t".
12:24:10 <conal> roboguy_: good idea. simpler and illuminating.
12:24:23 <sellers> roboguy_: no, I haven't
12:24:24 <conal> "If you can't solve a problem, then there's an easier problem you can solve: find it." - George Polya
12:24:36 <roboguy_> sellers: I would try that
12:24:38 * hackagebot exception-transformers 0.4 - Type classes and monads for unchecked extensible exceptions.  http://hackage.haskell.org/package/exception-transformers-0.4 (GeoffreyMainland)
12:25:01 <conal> sellers: that Polya advice is very useful for puzzles like this one.
12:25:37 <sellers> conal: monochrom: I understand how that works for Either and Maybe, but that seems like it would break evaluating expressions... maybe I don't understand what Val is intended to do
12:25:42 <sellers> conal: indeed
12:25:58 <sellers> roboguy_: alright, thanks for the hint
12:28:16 <monochrom> I don't think >>= stands for "evaluating expressions", whatever that means, to begin with
12:28:55 <Gurkenglas> @ping
12:28:55 <lambdabot> pong
12:29:21 <monochrom> instead, it stands for "substitution". expr>>=f means perform a substitution in expr. which substiution? as induced by f.
12:29:29 <Gurkenglas> 16 seconds?
12:29:59 <aommm> to answer my own question re HXT: one can use ArrowIf as suggested, and simply do "ifA a b c"
12:30:09 <monochrom> therefore, Val 5 remains Val 5 after substiution, so you need not care about f.
12:30:26 <aommm> then c will run if a is nothing
12:30:33 <monochrom> it's the variables in Var that needs real substitution work
12:30:39 <aommm> it's really cool. Haskell reminds me of JavaScript.
12:31:02 <monochrom> Gurkenglas: this is the meaning of "YMMV"
12:32:58 <breadmonster> Has anyone read To Mock a Mockingbird?
12:34:04 <Gurkenglas> Which is why that was a question mark. What do your timestamps say between our pingpong delay?
12:34:15 <EvanR> aommm: in what way?
12:34:25 <Gurkenglas> @where+ counter 0
12:34:25 <lambdabot> It is stored.
12:34:39 <Gurkenglas> @where+ increment_function (+1)
12:34:39 <lambdabot> Done.
12:34:51 <monochrom> what are you doing?!
12:34:59 <Gurkenglas> @where+ increment @@ @run flip const (@show (@where+ counter (@run (@where increment_function) $ (@where counter)))) (@where counter)
12:35:00 <lambdabot> Done.
12:35:10 <EvanR> hes hacking into the mainframe
12:35:13 <Gurkenglas> @@ @@ @url increment
12:35:15 <lambdabot>  1
12:35:18 <Gurkenglas> @@ @@ @url increment
12:35:21 <lambdabot>  2
12:35:23 <ski> @remember Polya "If you can't solve a problem, then there's an easier problem you can solve: find it." -- George Polya
12:35:23 <lambdabot> It is forever etched in my memory.
12:35:24 <Gurkenglas> Nice.
12:36:56 <yuung> are "Maybe" types used often?
12:37:01 <hiptobecubic> yes
12:37:05 <Gurkenglas> yes
12:37:19 <yuung> it's such a completely new thing to me it's hard to understand that its use cases i think
12:37:22 <bjorkintosh> Maybe.
12:37:38 <yuung> bjorkintosh, ......okay that was good
12:37:46 <aommm> you can check if a value "exists" in some sense by simply giving it to an if clause, which does the necessary type coercion. Values are considered to be truthy/falsy
12:37:48 <bjorkintosh> :D
12:37:50 <EvanR> yuung: any place you thought you would want to use nil in dynamic languages
12:37:56 <aommm> I was being kind of ironic though but I don't think it showed
12:37:59 <EvanR> you might want Maybe
12:38:01 <yuung> EvanR i see
12:38:34 <Welkin> like the awkward optionals in swift
12:38:35 <EvanR> aommm: yes that doesnt sound like haskell
12:38:35 <m4ple> hello everyone. I am trying to download a zip from the internet and process its contents. Unfortunately it seems like that openURIWithOpts returns a strict ByteString, while the zip processing lib expects a lazy ByteString. In my infinite haskell noobness, I got stuck. Code: http://pastebin.com/3EeijVtF
12:38:44 <Welkin> they are so clumsy...
12:38:58 <hiptobecubic> @hoogle fromStrict
12:38:59 <tdammers> m4ple: Data.ByteString.Lazy.fromStrict
12:39:00 <lambdabot> Data.ByteString.Lazy fromStrict :: ByteString -> ByteString
12:39:00 <lambdabot> Data.ByteString.Lazy.Char8 fromStrict :: ByteString -> ByteString
12:39:00 <lambdabot> Data.Text.Lazy fromStrict :: Text -> Text
12:39:20 <m4ple> tdammers: well that was easy
12:39:22 <m4ple> thansk!
12:39:23 <roboguy_> yuung: if something might fail, that might be a good case to use Maybe
12:39:35 <yuung> experienced haskellers: how long did it take you to get the hang of haskell, assuming an OO/imperative background?
12:39:38 <hiptobecubic> roboguy_, yuung or "Either" if you might care why it failed
12:39:43 <hiptobecubic> And I find that usually I do
12:40:05 <bjorkintosh> yuung, what's the hurry? don't forget to have fun. 
12:40:08 <Welkin> yuung: a few months, but most of the value came from building a real application (in yesod)
12:40:09 <bjorkintosh> sit, back, and research.
12:40:13 <yuung> hiptobecubic, i'll have to wait til i'm farther in the book to see about this new Either keyword
12:40:15 <Gurkenglas> So. What features is lambdabot missing? We might be able to add them now x)
12:40:27 <yuung> bjorkintosh, that's the pace i'm going for - just curious about other peoples' experience
12:40:31 <clrnd> yuung, a year :P
12:40:33 <EvanR> Either is not a keyword
12:40:37 <EvanR> @src Either
12:40:37 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:40:38 <yuung> err, type
12:40:45 <roboguy_> yuung: it's not a keyword, it's a type in the standard library. Haskell has few keywords, most things are defined as code
12:40:52 <EvanR> data Either a b = Left a | Right b
12:40:55 <roboguy_> instead of as keywords
12:41:11 <Gurkenglas> (I thought Either was a type constructor constructor.)
12:41:12 <yuung> roboguy_ i see
12:41:20 <EvanR> Gurkenglas: uhg no
12:41:28 <EvanR> about the terminology
12:41:42 <roboguy_> Gurkenglas: haha there was a long discussion about this last night. In my opinion, that should be considered a type
12:42:07 <roboguy_> I haven't seen a case where disallowing it to be a type helps with something
12:42:15 <Gurkenglas> It is something that has a kind.
12:42:25 <EvanR> you can make anything a type with sufficient type theory
12:42:49 <athan> @learn yuung :)
12:42:49 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
12:44:05 <EvanR> Either has a kind, so its obviously a type since types are the things that have kinds. in haskell
12:44:27 <Welkin> where are the sorts!?
12:44:39 <EvanR> -XDataKinds
12:44:51 <hiptobecubic> who named this crap
12:45:15 <Welkin> depraved mathematicians
12:45:35 <Welkin> also, see Particle Physics for extra naming fun
12:46:09 <sellers> Welkin: oh, you mean super-dark-naming?
12:46:47 <Gurkenglas> Now I only need to figure out how to make lambdabot strip the "" off a string, then I can take over the world!
12:47:04 <EvanR> use id
12:47:10 <Gurkenglas> @id "asd"
12:47:10 <lambdabot>  "asd"
12:47:13 <Gurkenglas> nope
12:47:18 <EvanR> all "" have been removed
12:47:49 <Gurkenglas> @id ""asd""
12:47:50 <lambdabot>  ""asd""
12:47:52 <hexagoxel> > text "asd"
12:47:53 <lambdabot>  asd
12:48:16 <Gurkenglas> @karma+ hexagoxel
12:48:16 <lambdabot> hexagoxel's karma raised to 3.
12:49:11 <cfoch> Hello
12:49:14 <Gurkenglas> Of course, Strings show adds \"s. Should have thought of that
12:52:20 <Welkin> @karma c++
12:52:20 <lambdabot> c++ has a karma of -7
12:52:23 <Welkin> haha
12:52:27 <clrnd> lol
12:52:28 <Welkin> @karma c--
12:52:28 <lambdabot> c-- has a karma of 1
12:52:36 <clrnd> @karma
12:52:36 <lambdabot> You have a karma of 0
12:53:06 <clrnd> very, very nice
12:54:49 <sellers> monochrom: roboguy_: conal: Alright, I think I get it.  Since the Val Int constructor isn't parametric/polymorphic (maybe the wrong term..), the only possible way to implement >>= and fmap for that constructor is the totally trivial case, right?  like fmap _ (Val n) = Val n, and (Val n) >>= _ = Val n
12:55:17 <monochrom> yes
12:55:19 <sellers> monochrom: roboguy_: conal: thanks for the patience and the hints
12:55:19 <conal> sellers: you got it.
12:55:23 <conal> :)
12:55:26 <monochrom> it's really similar to Maybe and Either
12:55:43 <conal> especially Either
12:56:26 <sellers> yeah
12:56:44 <sellers> *cough* Either a
12:56:52 <sellers> :-)
12:57:13 <hunteriam> What would be a good way to learn formal category theory and type theory etc. and eventually dependent type theory
12:57:19 <conal> and note that Maybe b =~ Either () b
12:57:21 <hunteriam> I already write Haskell but I want to be better
12:57:23 <conal> (isomorphic)
12:58:00 <Welkin> hunteriam: well, category theory won't help you a whole lot with writing haskell
12:58:28 <Welkin> but a good place to start is LAwvere's Introduction to Categories
12:58:36 <hunteriam> Why wouldn't it help me?
12:58:57 <hunteriam> I want to know what people are talking about when they talk about certain categories in Haskell and cool things you can do
12:58:59 <Welkin> http://www.amazon.com/Conceptual-Mathematics-First-Introduction-Categories/dp/052171916X/ref=sr_1_1?ie=UTF8&qid=1427918228&sr=8-1&keywords=lawvere+categories
12:59:12 <folsen> hunteriam: hacking on GHC/Cabal will probably be the quickest path to getting really good at Haskell, if you want sort of the theory behind haskell and related languages etc i'd try to look up textbooks on those topics
12:59:39 <folsen> and read lots of papers, like the list of papers from the latest ICFP
12:59:39 * hackagebot paypal-adaptive-hoops 0.10.0.1 - Client for a limited part of PayPal's Adaptive Payments API  http://hackage.haskell.org/package/paypal-adaptive-hoops-0.10.0.1 (fanjam)
12:59:41 * hackagebot exception-transformers 0.4.0.1 - Type classes and monads for unchecked extensible exceptions.  http://hackage.haskell.org/package/exception-transformers-0.4.0.1 (GeoffreyMainland)
12:59:43 * hackagebot exception-mtl 0.4 - Exception monad transformer instances for mtl classes.  http://hackage.haskell.org/package/exception-mtl-0.4 (GeoffreyMainland)
12:59:44 <hunteriam> Is there a textbook that people recommend - how can I hack on ghc and cabal without already being good at Haskell?
12:59:45 * hackagebot exception-monads-tf 0.4 - Exception monad transformer instances for monads-tf classes.  http://hackage.haskell.org/package/exception-monads-tf-0.4 (GeoffreyMainland)
13:00:02 <hunteriam> Folsen I can't really understand the papers, that's the problem
13:00:59 <Welkin> hunteriam: the book I just linked (on amazon) is written for high school students
13:01:11 <Welkin> it was actually used in a high school class on category theory
13:01:30 <Welkin> I have the book and it is very good (although I haven't read too much of it yet)
13:01:31 <Welkin> it is often recommended here
13:01:33 <levi> In the terminology of the Haskell Report, a kind applies to a term in a 'type expression', which is the language describing types. But when they talk about the semantics of the type system, the term 'type' is used to describe an attribute of program value expressions. In this sense, type constructors are distinct from types, as type constructors are an artifact of the type language rather than the value
13:01:34 <levi> language. So the meaning of the word 'type' is overloaded a bit even in the Report, and if you want to be precise you need to make clear what context you're using it in.
13:01:34 <nsxt> given a type data Fruit = Fruit { name :: String, color :: String } and a list, say, ["Lemon", "Yellow"], is there a way to convert the list into a Fruit?
13:01:36 <conal> hunteriam: i recommend starting with Brent Yorgey's Typeclassopedia
13:01:37 <folsen> hmm.. right.. well there's a ton of resources, for category theory i'd recommend starting to read this http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/ to see if you're interested in it, then branch out into more traditional textbooks
13:01:52 <folsen> hunteriam: ^
13:02:17 <Welkin> the Typeclassopedia is also invaluable
13:02:21 <conal> hunteriam: grokking the main type classes and how to use them will be a great start.
13:02:25 <Welkin> much more useful than any formal theory, actually
13:03:25 <hunteriam> I should finish reading the typeclassopedia
13:03:30 <defanor> is there anything like Haskeline's getInputChar, but non-blocking? or something to check if input is available. i want to user input by character, but only if it's available
13:03:34 <hunteriam> I understand the bare essentials of it
13:03:36 <folsen> hunteriam: for getting to grips with GHC you have https://ghc.haskell.org/trac/ghc/wiki/Newcomers and for getting a good broad understanding of Haskell (certainly enough to hack on GHC) there's http://dev.stephendiehl.com/hask/
13:03:39 <hunteriam> And I think I understand arrow
13:03:42 <defanor> read user input*
13:03:56 <monochrom> there is isEOF
13:04:08 <conal> hunteriam: also, bird's and hutton's books, emphasizing equational reasoning. you might also like my type class morphisms paper.
13:04:27 <Welkin> nsxt: yes, just pattern match on the first two elements of the list and construct the new data, then recurse until the list is empty
13:04:36 <defanor> monochrom: thanks, but i don't think it's what i need. EOF happens only once, in the end, right?
13:04:50 <monochrom> actually, maybe hReady is better
13:05:01 <defanor> monochrom: will check now, thanks
13:05:14 <conal> hunteriam: ... which is about using simple denotations and homomorphisms to design functional libraries with provably (or constructively) correct implementations.
13:05:17 <monochrom> go through System.IO doc. you will need to eventually.
13:05:35 <indiagreen> does lambdabot answer messages from itself?
13:06:00 <indiagreen> I'm really tempted to check with a quine I just wrote
13:06:06 <nsxt> Welkin: yeah, with my example, it's trivial... but let's say you have a line of text separated by a delimiter, and you have 20+ fields which are then split into a list. there's no easier way to construct the new data?
13:06:07 <JordiGH> Your radical ideas of forkbombing the IRC bot have already ocurred to others.
13:06:08 <geekosaur> it's not supposed to, no. that's one reason that outptu tends to be prefixed with a space, and LB ignores stuff starting with a space
13:06:49 <indiagreen> JordiGH: yep, which is why I asked instead of actually doing it
13:08:06 <nsxt> Welkin: i guess what i'm asking is... let's say I have a list corresponding to the order of the fields, and then a list containing the data. how can i combine those two to get the new data type?
13:08:39 <Welkin> nsxt: can you show an example?
13:08:44 <nsxt> Welkin: so something like [color, name, season] and ["yellow", "lemon", "spring"]
13:08:45 <Welkin> @lpaste
13:08:45 <lambdabot> Haskell pastebin: http://lpaste.net/
13:09:00 <Welkin> oh, so the fields are not known until runtime?
13:09:33 <quchen> edwardk: -fwarn-unused-single-letter-name?
13:09:36 <Welkin> where is this data coming from?
13:09:56 <nsxt> Welkin: imagine it's a csv file
13:10:26 <Welkin> nsxt: you can build your native haskell data as you parse the input
13:11:09 <nsxt> Welkin: sorry, i'm a noob... can you help me understand that a little better?
13:11:24 <Welkin> can you type up an example on lpaste?
13:11:26 <Welkin> @lpaste
13:11:27 <lambdabot> Haskell pastebin: http://lpaste.net/
13:11:30 <nsxt> Welkin: yes, sorry
13:11:39 <Welkin> including the data declaration and an example of the function
13:14:40 * hackagebot lens 4.7.0.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.7.0.1 (EdwardKmett)
13:15:19 <linman32> how does one pattern match a rational? ex: case expr1 of (1%4) -> expr2
13:15:36 <quchen> You can't, (%) is a function
13:15:38 <linman32> that statement has a parse error
13:15:48 <quchen> (%.) is the constructor, but it's not exported.
13:16:03 <quchen> You'll have to do something like (n,d) = (numerator x, denominator x).
13:16:59 <nsxt> Welkin: http://lpaste.net/7487913638171246592
13:17:08 <linman32> quchen: thanks
13:17:57 --- mode: monochrom set -o monochrom
13:19:40 * hackagebot linklater 3.1.0.0 - The fast and fun way to write Slack.com bots  http://hackage.haskell.org/package/linklater-3.1.0.0 (hao)
13:27:10 <Welkin> nsxt: http://lpaste.net/7487913638171246592
13:27:17 <Welkin> take a look and tell me what you thinkl
13:27:46 <Welkin> for parsing, it is easiest to use parsec
13:28:07 <Welkin> but your example is simple enough to do without it, as a learning exercise at least
13:28:46 <ski> hunteriam : for type theory, perhaps you could try "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)> to start with
13:29:41 * hackagebot bytestring-progress 1.0.5 - A library for tracking the consumption of a lazy ByteString  http://hackage.haskell.org/package/bytestring-progress-1.0.5 (AdamWick)
13:29:46 <nsxt> Welkin: thanks, so i guess the best approach is to just pattern match, then
13:30:30 <Gurkenglas> Didn't even test this one in a query:
13:30:32 <nsxt> Welkin: i was just wondering if perhaps there were an alternative (without using Parsec)
13:30:41 <Gurkenglas> NO
13:30:46 <Welkin> if you don't use parsec, you will have to pattern match
13:30:59 <Gurkenglas> Ychat deleted my clipboard again :(
13:31:09 <Welkin> you need to know the number of elements in the list, otherwise you don't get a complete piece of data
13:31:18 <Gurkenglas> The one time I didnt send my command to lambdabot before trying it here ._.
13:35:32 <jle`> it's always the one time
13:37:44 <lpaste> randir pasted “Parse error ” at http://lpaste.net/3897397459197886464
13:38:07 <randir> Can someone check out this code? I'm getting a parse error.
13:40:59 <randir> Any ideas?
13:42:44 <hexagoxel> randir: include the error?
13:43:10 <randir> parse error (possibly incorrect indentation or mismatched brackets)
13:43:19 <randir> at the line starting with "then"
13:43:36 <Gurkenglas> Okay, wrote it up again (and corrected a mistake meanwhile):
13:43:37 <quchen> Are there tabs in your code?
13:43:40 <Gurkenglas> @where+ highlightWith @@ @run text $ const (namebuffer ++ ", " ++ resultbuffer) @show @let resultbuffer = @show @@ @run text $ (\(namepart1 : (namepart2 : cmd)) -> [chr 64] ++ "run const (" ++ unwords cmd ++ ") (" ++ [chr 64] ++ "let namebuffer = \"" ++ namepart1 ++ namerpart2 ++ "\")") $ words @show
13:43:40 <lambdabot> It is stored.
13:44:28 <Gurkenglas> @@ @@ @url highlightWith Gurken glas @run 2+2
13:44:33 <lambdabot>  Not in scope: ‘namebuffer’
13:44:47 <Gurkenglas> Hmm.
13:46:27 <Gurkenglas> @where+ highlightWith @@ @run text $ const ((@where namebuffer) ++ ", " ++ (@where resultbuffer)) @show @where+ resultbuffer @show @@ @run text $ (\(namepart1 : (namepart2 : cmd)) -> [chr 64] ++ "run const (" ++ unwords cmd ++ ") (" ++ [chr 64] ++ "where+ namebuffer \"" ++ namepart1 ++ namerpart2 ++ "\")") $ words @show
13:46:27 <lambdabot> Good to know.
13:46:31 <Gurkenglas> @@ @@ @url highlightWith Gurken glas @run 2+2
13:46:35 <lambdabot>  <hint>:1:48: parse error on input ‘++’
13:47:11 <shachaf> Probably better to experiment with lambdabot in /msg until you make it work.
13:47:52 <Gurkenglas> 'kay.
13:48:28 <monochrom> Gurkenglas, I am not thrilled with polluting the @where database just for personal enjoyment like this
13:48:29 <hexagoxel> Gurkenglas: there is a brainfuck interpreter in lambdabot, if you want unreadable code
13:48:49 <monochrom> lambdabot is not your personal backyard and toy
13:49:12 <Gurkenglas> Do you mean disc space or the possibility of someone trying to use that name?
13:49:32 <monochrom> that is beside the point.
13:50:16 <Gurkenglas> I don't understand. Why not play with lambdabot?
13:50:40 <monochrom> but I see now you are one of those selfish people who think in the mode of "if no one else uses this resource then it is up to me to exploit it maximally"
13:50:47 <Gurkenglas> Me deriving personal enjoyment doesn't stop other people from getting theirs
13:51:00 <hexagoxel> is there no unboxed on GADTs?
13:51:38 <Gurkenglas> Also I was pretty transparently trying to implement something that would afterward be of (minimal) use to all
13:52:07 <quchen> Can we keep this a non-issue and stay civil? :-|
13:52:16 <roboguy_> indiagreen: that's an interesting question
13:52:23 <roboguy_> oh, oops scrolled up
13:52:38 <Gurkenglas> Right, #haskell-blah for further discussion on that
13:52:41 <augur_> i blogged a post http://languagengine.co/blog/extensible-serialization/
13:58:34 <roboguy_> hexagoxel: I don't think you can store unboxed things in containers
13:59:30 <arkeet> hexagoxel: you mean the {-# UNBOX #-} stuff?
13:59:36 <hexagoxel> arkeet: yes
13:59:42 * hackagebot vector-space-points 0.2.1.1 - A type for points, as distinct from vectors.  http://hackage.haskell.org/package/vector-space-points-0.2.1.1 (bergey)
13:59:57 <hexagoxel> arkeet: wait.. UNPACK
14:00:00 <arkeet> er, UNPACK
14:00:05 <hexagoxel> :)
14:00:49 <arkeet> you can write stuff like I :: {-# UNPACK #-} !Int -> T
14:00:50 <arkeet> or whatever
14:03:51 <arkeet> hexagoxel: ^
14:03:59 <hexagoxel> i get "Ignoring unusable UNPACK pragma on the first argument of ‘:+:’"
14:04:14 <arkeet> code?
14:04:42 <hexagoxel> roboguy_: what exactly does "container" mean?
14:04:42 * hackagebot aeson-schema 0.3.0.2 - Haskell JSON schema validator and parser generator  http://hackage.haskell.org/package/aeson-schema-0.3.0.2 (TimBaumann)
14:06:04 <arkeet> hexagoxel: what code causes that?
14:06:34 <roboguy_> hexagoxel: if you try to put an unboxed type into something like Just, it won't work. I don't think you can set the kind to # for something like that
14:06:49 <roboguy_> put an unboxed value, I mean
14:07:07 <hexagoxel> arkeet: https://gist.github.com/lspitzner/552e87dea74482aad05d
14:07:35 <roboguy_> hexagoxel: I don't think you can UNPACK a type variable
14:07:36 <hexagoxel> it probably makes no sense to put unpack there (even the strictness is probably a bad idea)
14:07:39 <arkeet> ^
14:08:04 <hexagoxel> ah, ok
14:08:08 <arkeet> or anything polymorphic really.
14:08:12 <hexagoxel> roboguy_, arkeet: thanks
14:08:49 <hexagoxel> (hmm, now that i think of it that is obvious. the warning could still mention it :D)
14:09:42 * hackagebot mongoDB 2.0.4 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  http://hackage.haskell.org/package/mongoDB-2.0.4 (GregWeber)
14:10:18 <arkeet> ghc doc says "Any single-constructor data is eligible for unpacking".
14:10:39 <arkeet> with, I guess, the implication that nothing else is.
14:11:15 <platz> I thought UNPACK was automatically applied by ghc now when it can
14:11:30 <arkeet> no, you still need -funbox-strict-fields for that.
14:12:05 <arkeet> unpacking everything isn't necessarily better, because you might have to box something up again.
14:12:46 <arkeet> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/pragmas.html#unpack-pragma
14:13:25 <JordiGH> What's in the fun box?
14:13:34 <arkeet> :)
14:14:23 <arkeet> (if that's an honest question, the answer is that it should really be read -f"unbox-strict-fields")
14:14:43 * hackagebot rethinkdb-client-driver 0.0.16 - Client driver for RethinkDB  http://hackage.haskell.org/package/rethinkdb-client-driver-0.0.16 (wereHamster)
14:16:02 <platz> yeah http://www.reddit.com/r/haskell/comments/29onpf/why_does_ghc_always_box_polymorphic_fields_in/
14:16:06 <JordiGH> No, I just wanted a funbox.
14:17:14 <platz> https://downloads.haskell.org/~ghc/7.8.1-rc2/docs/html/users_guide/release-7-8-1.html "By default, GHC will now unbox all "small" strict fields in a data type"
14:17:39 <platz> so the fields have to be strict first
14:17:48 <platz> then it might auto unpack it?
14:18:12 <arkeet> I guess so.
14:18:29 <cschneid> why's it called `nub` to uniq a list?
14:18:54 <arkeet> according to Data.List docs: "The name nub means `essence'."
14:19:40 <JordiGH>  3. The heart of a matter; the crux or central point of a discussion, argument, etc.
14:20:00 <JordiGH> 1974   Times 22 Oct. 14/6   The nub of the judges' difficulty lay in..the claim..that the judge had no authority in law to give a direction binding on the press.
14:20:48 <cschneid> uhh huh. 
14:21:01 <cschneid> just showed some haskell code to a coworker. He was like: "what the hell is nub"
14:21:03 <cschneid> :)
14:21:10 <JordiGH> Yeah, I wonder why they didn't go with "unique" or "uniq" if it was too long.
14:21:35 <cschneid> no biggie - but distracting while I was trying to evangelize quickcheck
14:21:40 * geekosaur didn't think num was that archaic...
14:21:46 <geekosaur> er, nub'
14:21:50 <geekosaur> siiigh
14:21:54 * geekosaur cannot type today
14:22:00 <JordiGH> geekosaur: The OED's last citation is from 1999, certainly not archaic.
14:22:24 <schell> geekosaur: what’s the history on ‘nub’? i had also not heard the name used until haskell (or couldn’t remember)
14:22:25 <JordiGH> Although the reason why it means the "essence" is archaic: it's the innermost wrapping of a chryssalid in its cocoon.
14:22:44 <JordiGH> It's kind of analogous to "kernel".
14:22:50 <JordiGH> As in, "there's a kernel of truth in that argument".
14:22:59 <JordiGH> Or a kernel of corn.
14:24:02 <geekosaur> "the nub of the matter" feels somewhat British to me but not particularly rare/obscure
14:24:08 <JordiGH> It's more commonly spelled "knub" when referring to cocoons.
14:24:23 <schell> interesting
14:24:28 <schell> that’s cool
14:24:54 <JordiGH> Well, GHC *is* from Glasgow.
14:28:41 <ion> knub feel
14:30:14 <ReinH> Science.
14:31:22 <monochrom> ?
14:32:08 <JordiGH> So how come you never hear much from other Haskell compilers besides ghc?
14:32:34 <hpc> ghc gets an order of magnitude more development
14:32:54 <hpc> other compilers pop up in discussion when they get a unique feature
14:33:00 <JordiGH> It almost seems like it's the reference implementation, doesn't it? Whatever ghc does is what "standard" Haskell is.
14:33:02 <mmachenry1> JordiGH: It's also nice to have one standard environment for all developers and Haskell users to agree on.
14:33:22 <JordiGH> mmachenry1: Ein Reich, Ein Volk, Ein GHC!
14:33:54 <hpc> JordiGH: ghc adheres to the standard pretty closely
14:34:08 <hexagoxel> and a million extensions
14:34:10 <JordiGH> Doesn't GHC influence the standard very heavily?
14:34:25 <mmachenry> JordiGH: It has become a defacto standard with its language extensions.
14:34:27 <hpc> not that heavily
14:34:31 <quchen> GHC certainly isn't the reference implementation, but it's the biggest implementation. A reference implementation would adhere to the rules, but GHC deviates from them and experiments on a regular basis. It's safe to call it the de facto standard compiler if you want to emphasize its specialness.
14:34:33 <hpc> implementations in general influence standards
14:34:47 <monochrom> other compilers such as jhc and ajhc are 1-person or 2-person projects. they are updated less frequently so their news is announced infrequently
14:34:50 <mmachenry> JordiGH: But many of those extensions stand a good chance of becoming part of the next Haskell definition. 
14:35:03 <hpc> developments in ghc do eventually become good enough to become standard
14:35:15 <hpc> but they start as extensions, and the system for those is also standard
14:35:36 <monochrom> tautologically you're just looking at a networking effect
14:35:39 <geekosaur> less often than you think. haskell2010 uhas only a small handful of changes over haskell98, and there's been no later standard
14:35:43 <vandenoever> what's the runner up haskell env?
14:35:52 <JordiGH> Is there an audio interview of the ghc devs somewhere? I'd love to hear their Scottish accent.
14:36:01 <quchen> ?quote elliott conservative
14:36:01 <lambdabot> elliott says: An interesting exercise is to try and imagine a language revision more conservative than H2010.
14:36:13 <hpc> haha
14:36:17 <vandenoever> JordiGH: and how they pronounce nub
14:36:20 <hpc> h2010 was pretty hyped too
14:36:23 <JordiGH> vandenoever: Sure. :-)
14:36:23 <monochrom> simply find a video lecture of Simon Peyton Jones. any one will do.
14:36:31 <quchen> JordiGH: Hearing SPJ talk will probably disappoint you then
14:36:40 <JordiGH> quchen: Isn't he Scottish?
14:36:43 <monochrom> oh, it will? darn
14:36:57 <JordiGH> No, he sounds English. :-(
14:37:03 <quchen> JordiGH: He's the most British person I can think of.
14:37:04 <ion> I hope you like yellow Comic Sans on blue background.
14:37:04 <monochrom> I guess simply find a Sean Connery movie, then
14:37:09 <hpc> JordiGH: it's the bowtie
14:37:23 <JordiGH> quchen: Are we saying that Scottish people aren't British? Dem's fighting words.
14:37:35 <hpc> it's like a stetson in the US
14:37:38 <hpc> wear it, instantly brit
14:37:39 <JordiGH> monochrom: Sean Connery has a Sean Connery accent.
14:37:45 <monochrom> :)
14:37:47 <ion> Hi JordiGH, btw. I recognize your nick from some channel. Possibly MOOC-related.
14:38:07 <JordiGH> ion: I knew an ion-flux once. Is that you?
14:38:15 <ion> nope
14:38:20 <JordiGH> I think I already asked you that.
14:39:23 <ReinH> He has a very particular Oxfordian accent.
14:39:26 <JordiGH> ion: Maybe #ml-class.
14:40:03 <ion> That must be it.
14:40:14 <ReinH> Specifically the one caricatured by Monty Python in https://www.youtube.com/watch?v=2K8_jgiNqUc
14:40:19 <ReinH> And it's awesome.
14:41:29 <roboguy_> ReinH: he always reminded me a bit of Michael Palin and I never knew why. Maybe that's why
14:41:48 <ReinH> I particularly enjoyed our discussion about threading on the Haskell Cast.
14:42:01 <vandenoever> monoids remind me of countercurrent exchange
14:42:10 <ReinH> .oO How can I get him to say "threading" again?
14:43:23 <roboguy_> vandenoever: how so?
14:43:59 <vandenoever> functions stacking one way, payload stacking the other
14:45:08 <roboguy_> functions stack one way and the payload stacks the other?
14:47:08 <cfoch> Hi, folks.  could somebody give me a hand
14:47:24 <cfoch> I am trying to install SourceGraph... and many errors
14:47:25 <cfoch> http://fpaste.org/206200/79247081/
14:48:42 <roboguy_> cfoch: do you have the C library 'z' installed?
14:49:06 <Enigmagic> cfoch: setup-Simple-Cabal-1.18.1.3-x86_64-linux-ghc-7.8.3: The program ar is required but it could not be found.
14:49:10 <Enigmagic> lots of those
14:49:11 <quchen> cfoch: "setup-Simple-Cabal-1.18.1.3-x86_64-linux-ghc-7.8.3: The program ar is required but it could not be found."
14:49:15 <Enigmagic> yep
14:49:33 <geekosaur> you are missing a number of OS prereqiosites: the ar program and the zlib devel libraries
14:49:42 <monochrom> it is really strange if ar is not found
14:50:32 <geekosaur> what kind of system is this? (distro/version)
14:50:49 <cfoch> NixOS
14:50:50 <roboguy_> vandenoever: that sounds like maybe a specific monoid, but I'm not sure which
14:51:18 <cfoch> 14.12
14:51:23 <cfoch> geekosaur
14:51:48 <vandenoever> roboguy_: maybe it does, i'm reading RWH
14:52:24 <roboguy_> a monoid is just a binary operation * that has a neutral element and obeys the law (a * b) * c = a * (b * c)
14:53:41 <geekosaur> cfoch, so it sounds like this is expected. (e.g. ar not being installed by default)
14:54:44 * hackagebot fixedwidth-hs 0.2.0.0 - Quick parsing of fixed-width data formats.  http://hackage.haskell.org/package/fixedwidth-hs-0.2.0.0 (MichaelOChurch)
14:55:06 <geekosaur> see https://nixos.org/wiki/Haskell#Using_cabal_in_the_direct_installation_scenario re ar. don't know how you install zlib on nixos
14:56:46 <roboguy_> cfoch: I sounds like this is relevant to the zlib issue http://comments.gmane.org/gmane.linux.distributions.nixos/12372
14:59:26 * geekosaur has to admit that nix/nixos is starting to sound rather annoying
15:00:29 <JordiGH> Because it's compiling even more than Gentoo?
15:01:04 <geekosaur> the stuff about what's in scope etc. (see last question on above gmane page)
15:03:36 <roboguy_> I wonder what it would be like if it worked the other way around (everything is in scope to start with, like most systems, but you can hide things)
15:09:45 * hackagebot hs-inspector 0.2.0.0 -   http://hackage.haskell.org/package/hs-inspector-0.2.0.0 (flbulgarelli)
15:09:47 * hackagebot blaze-json 0.2.0 - tiny library for encoding json  http://hackage.haskell.org/package/blaze-json-0.2.0 (HirotomoMoriwaki)
15:14:45 * hackagebot fixedwidth-hs 0.2.0.1 - Quick parsing of fixed-width data formats.  http://hackage.haskell.org/package/fixedwidth-hs-0.2.0.1 (MichaelOChurch)
15:30:14 <cfoch> roboguy_: thanks
15:30:17 <cfoch> I could install it
15:30:44 <monochrom> interesting. when ghc 7.10 builds a library, the filenames now come with bitcoin addresses?! XD
15:31:09 <monochrom> for example I just saw libHSCabal-1.22.2.0-HWT8QvVfJLn2ubvobpycJY.a on the internet
15:33:32 <roboguy_> monochrom: I think they used to use hex numbers. Maybe they switched to base64?
15:34:21 <monochrom> they didn't write ABI hashes in filenames, only in package.conf files
15:34:46 * hackagebot flow 1.0.0 - Functions and operators for more understandable Haskell  http://hackage.haskell.org/package/flow-1.0.0 (fozworth)
15:50:48 <hunt> is functor a superclass of applicative?
15:51:02 <hunt> or a superclass of monad?
15:51:26 <Guest28698> if no, why not?
15:51:39 <roboguy_> Guest28698: Functor is a superclass of Applicative and Applicative is a superclass of Monad
15:51:48 <Guest28698> ok cool
15:51:49 <roboguy_> (as of GHC 7.10 the last part is true)
15:52:17 <Guest28698> i read something where people were excited about functor being a direct superclass of monad, would that have been preferable to applicative?
15:52:34 <roboguy_> Guest28698: there was an April Fool's joke on reddit about that
15:52:39 <Guest28698> yea
15:52:39 <roboguy_> it wasn't serious
15:52:43 <Guest28698> the reactions though
15:52:50 <Guest28698> people seemed genuinely excited
15:53:20 <roboguy_> probably because Applicative actually was recently made a superclass of Monad
15:53:34 <roboguy_> to answer the question, no it would not be preferable
15:54:21 <GoGoGarrett> I'm having issues with : http://www.yesodweb.com/page/quickstart these instructions. I keep getting yesod command not found
15:54:57 <jellie> roboguy_: What? I thought Functor was also made a superclass of Monad.
15:55:00 <jellie> Seriously
15:55:27 <ski> jellie : Guest28698 said "direct superclass"
15:55:34 <roboguy_> jellie: it is indirectly a superclass of Monad because it is a superclass of Applicative
15:55:41 <roboguy_> but not directly
15:55:42 <ski> "direct superclass" isn't transitive. "superclass" is
15:56:01 <dawik> strawberries, refigerated or not?
15:56:09 <Yaniel> yes
15:56:19 <ski> (you could also say that `Functor' is a mediate superclass of `Monad')
16:00:07 <jellie> wow I didn't expect wreq to install so many things along with it.
16:05:09 <Luke> what's the benefit of vector vs. array in ST?
16:05:16 <Luke> just a better interface?
16:06:02 <bazqux> Is there a nice function in the standard library for truncating strings?
16:06:35 <osa1__> bazqux: text has strip
16:06:43 <osa1__> oh you said stdlib
16:06:45 <geekosaur> depends on what you mean by truncate
16:06:52 <geekosaur> > take 3 "foobar"
16:06:54 <lambdabot>  "foo"
16:07:31 <bazqux> geekosaur: Yes that's exactly what I need! I think I'm too tired. I forgot that strings are just lists.
16:07:46 <bazqux> Thanks guys. Sorry for being stupid.
16:08:05 <s00pcan> bazqux: is it a cultivated stupid?  I can respect that
16:10:01 <jellie> :t Network.Wreq.get 
16:10:02 <lambdabot> Not in scope: ‘Network.Wreq.get’
16:18:33 <Aruro> i just checked, hoogle takes 1 GB space on my disk. Is it ok? :)
16:18:58 <tnks> cd
16:19:04 <tnks> (sorry)
16:19:24 <athan> Is there a good QuickCheck tutorial, for writing Arbitrary instances for complicated types?
16:19:41 <Aruro> cabal 1.8 gb
16:19:49 <Aruro> i did not even installed anything complicated yet :D
16:21:28 <Lis> Aruro, you should clean temporary compilation files.
16:21:33 <jellie> I'm having a small issue with get from Data.Wreq. As far as I can tell, it's not working as shown in the example. http://lpaste.net/4322370879565594624
16:21:37 <Aruro> how do i do that?
16:21:51 <mpickering> athan: Search for jasper's tutorial about it
16:22:02 <athan> Thanks! :)
16:22:14 <Lis> Aruro, https://wiki.haskell.org/Cabal-Install cabal clean
16:22:19 <mpickering> http://jaspervdj.be/posts/2015-03-13-practical-testing-in-haskell.html
16:22:34 <Aruro> Lis, ty!
16:23:26 <athan> mpickering: Just got it haha
16:23:46 <athan> I've seen people make applicative-style instances, but I'm wondering how you'd do that with a sum type
16:23:54 <Aruro> hm looks i have to do it by hand for every package?
16:24:07 <Aruro> cabal clean asks for package name
16:24:13 <bazqux> s00pcan: I'm not sure. I think I'm just sleepy. I've been writing haskell all day. :-)
16:24:48 * hackagebot autonix-deps-kf5 0.2.0.1 - Generate dependencies for KDE 5 Nix expressions  http://hackage.haskell.org/package/autonix-deps-kf5-0.2.0.1 (ThomasTuegel)
16:27:54 <Aruro> it does not look like its files after compilation
16:28:02 <Aruro> looks like hoogle database takes 1 gb
16:29:29 <Lis> bazqux, i don't sleep much today. like i got about 4 to 5 hours sleep today
16:30:35 <Lis> depends how you feel with it. i usually stop if I get slow and trap myselfe making mistakes. usually it's better to rest, becouse your much quicker then
16:32:29 <jellie> Having an issue with Network.Wreq.get not working. The error is here: http://lpaste.net/4322370879565594624
16:33:12 <jellie> Aruro: You downloaded it all? How will you keep it updated?
16:34:49 <Aruro> i did not download anything more than needed
16:34:53 <Aruro> just followed instruction
16:34:59 <Aruro> hoogle update or something
16:35:01 <mpickering> jellie: Do you not mean W.get?
16:35:11 <Aruro> i did not know it will blow up up to 1 gig :D
16:35:27 <jellie> mpickering: Yeah but I wanted to ask in a way that makes sense in the channel.
16:35:50 <mpickering> well it doesn't make sense if you edit the paste ha
16:35:55 <Aruro> 1 gb of raw text its a lof of read
16:36:31 <jellie> mpickering: What? Well I'm having an issue with W.get but nobody in the channel knows what `W` is.
16:36:44 <mpickering> well they do if you've imported it on the line above
16:37:06 <mpickering> what does ":t W.get" give you?
16:37:33 <jellie> Response ByteString
16:38:03 <jellie> mpickering: It makes no sense because that code is copied straight from the example.
16:38:27 <mpickering> is this a clean ghci session?
16:39:48 <jellie> mpickering: Cabal repl
16:41:44 <mpickering> jellie:  and what about :info W.get
16:41:46 <zipper> mpickering: I don't know what happened there. DId you say something?
16:42:32 <zipper> mpickering: W.get :: String -> IO (W.Response ByteString) defined in ‘Network.Wreq’
16:42:40 <zipper> mpickering: http://www.serpentine.com/wreq/#whirlwind-tour
16:43:09 <zipper> It's the exact same thing in hackage and the tutorial.
16:43:11 <geekosaur> so, for what it's worth, the lpaste shows Data.Wreq but I am finding Network.Wreq
16:43:53 <zipper> geekosaur: I wrote the parts above the error by hand
16:44:15 <mpickering> so what are you actually typing?
16:44:21 <mpickering> can you paste that?
16:44:22 <s00pcan> mpickering: ashjkdlfkajhs
16:44:24 <s00pcan> I typed that
16:44:36 <zipper> mpickering: This http://www.serpentine.com/wreq/#whirlwind-tour
16:44:54 <zipper> I copied and pasted into the repl
16:44:58 <zipper> It's not a typo
16:45:20 <mpickering> what happens if you use ghci rather than via cabal repl?
16:45:37 <lpaste> newsham pasted “complicated type class question” at http://lpaste.net/129990
16:45:49 <newsham> can anyone help with my complicated type class question?
16:46:27 <zipper> mpickering: I can't because wreq is installed in a sandbox. Do you really think the problem is with the repl?
16:46:35 <mpickering> newsham: No, you can't do that
16:46:41 <mpickering> zipper: No, but I'm out of ideas
16:46:48 <mpickering> you can do.. cabal exec ghci 
16:46:55 <mpickering> which will load ghci with your sandbox env
16:47:10 <mpickering> without loading your project as well
16:48:02 <newsham> so i'm stuck writing a 'lstget = lift get' and having to manually differentiate between which fields are lifted? :(
16:48:42 <zipper> mpickering: No kidding. It worked when I used `cabal exec ghci`
16:48:47 <zipper> Why on earth?
16:49:24 <mpickering> newsham: Are there other things which have StSerialize instances?
16:49:46 <shachaf> newsham: The trouble is that you might manually define instance StSerialize r Foo and someone else might define instance Serialize Foo
16:49:46 <newsham> there will be eventually.
16:50:07 <shachaf> Then it isn't clear which instance to use.
16:50:15 <mpickering> zipper: Something in your project is clashing, looking a newshams paste, it's probably from the Serialize class
16:51:36 <zipper> mpickering: It seems to be from there because the errors have a lot to do with each other
16:52:04 <zipper> That's too weird
16:52:10 <zipper> Anyway thanks
16:52:55 <newsham> shachaf:  oh well.
16:54:18 <shachaf> newsham: The usual approach is to define an instance manually for each Foo. There are some tricks to make it more convenient to define them, but you still need to enumerate the types manually somehow.
16:57:36 <newsham> there's no way to automate the generation of "instance StSerialize Foo where stGet = lift get" without TH?
16:59:22 <shachaf> You can make it more compact with DefaultSignatures.
16:59:28 <newsham> mkStSerialize :: Serialize a => StSerialize a ; mkStSerialize Foo :)
16:59:42 <newsham> shachaf: can you give an example?
17:00:23 <shachaf> Something like class StSerialize r a where { stGet :: StGet r a; default stGet :: Serialize a => StGet r a; stGet = lift get }
17:00:34 <cfoch> Sorry... I forget it. When I have a sandbox in a folder and I have a subfolder, should I do: 'cabal sandbox init --sandbox=./.cabal-sandbox'?
17:00:36 <shachaf> Then you can just type "instance StSerialize Foo".
17:00:46 <shachaf> At least I think that's how it works. I haven't really used this extension.
17:00:59 <newsham> hrmm.. that would be fine with me..  wasnt aware of that "default" thing.
17:01:15 <shachaf> I think there's a plan in the next version of GHC to make that work with "deriving" somehow.
17:01:30 <shachaf> Actually that's probably not too relevant to your case.
17:04:52 <newsham> ok, this works well.. the only downside is that I have to pin down what the state type is when i instantiate the instance.
17:05:05 <newsham> instead of having it forall that state type.
17:05:10 <newsham> but in my situation that shouldnt be a problem.
17:05:11 <newsham> thank you
17:05:49 <newsham> I just tested it out and it compiles fine.
17:06:52 <geekosaur> sorry, in [libdefaults]
17:07:02 <geekosaur> oops, I keep ending up oin the wrong channel...
17:24:50 <gfixler> is there a way with System.IO to skip the pause when hitting escape in the terminal?
17:25:07 <gfixler> i.e. when I c <- getChar
17:25:24 <gfixler> I tried a do with an hFlush stdin, but it didn't make any sense or work
17:26:04 <EvanR> pause?
17:26:05 <geekosaur> um? that sounds like you are using haskeline (i.e. are running in ghci); try a compiled program and don't forget to switch to and from raw mode on unixlikes
17:27:18 <gfixler> haskeline?
17:27:23 <gfixler> yes, I'm in ghci
17:29:06 <EvanR> on osx hitting escape after execution getChar immediately responds
17:31:12 <gfixler> EvanR: not an option
17:31:29 <gfixler> Linux for Life
17:31:58 <EvanR> this is just information you can use to determine the issue
17:32:00 <gfixler> I was wondering, as you can set a timer thing in Vim to make escapes fast
17:32:10 <nwf> I have a silly question for the channel.  I understand, I think, why natural transformations correspond exactly to polymorphic functions (\forall a . F a -> G a) when F and G are functors, not just type constructors.  Is there any analogue for when F and/or G are just type constructors and *not* functors (of either variance)?
17:32:12 <EvanR> oh vim?
17:32:14 <gfixler> EvanR: yeah, it's definitely terminal based
17:32:26 <shachaf> nwf: Someone was just talking about that the other day.
17:32:30 <EvanR> theres no delay in the terminal, its vim
17:32:30 <gfixler> e.g. I can hit Esc, then j to simulate Alt+j
17:32:42 <gfixler> that pause is waiting for me to complete an old-timey escape code
17:32:48 <gfixler> it's a 1-second pause
17:32:49 <shachaf> nwf: arkeet, I think. Maybe edwardk or xplat or other people.
17:32:58 <nwf> I am not all that surprised. =P
17:33:00 <arkeet> I was talking about lenses the other day.
17:33:01 <shachaf> I'd like a good answer to that question.
17:33:09 <shachaf> arkeet: The other other day.
17:33:29 <arkeet> whatever it is, it probably induces a natural transformation between coyonedas.
17:33:44 <arkeet> or yonedas. I dunno.
17:34:14 <nwf> Hm.  If it involves Yoneda anything, it's going to be left as "I don't know how..." in the thing I'm writing right now.
17:34:29 <arkeet> I'm just thinking out loud.
17:34:48 <bgamari> Anyone seen benmachine recently?
17:35:38 * ski . o O ( ⌜∀ α β. (α → β) → (F α → G β)⌝ )
17:36:33 <arkeet> yes.
17:37:13 * ski . o O ( ⌜∀ α. F α → Yoneda G α⌝ )
17:37:33 * ski . o O ( ⌜∀ β. CoYoneda F β → G β⌝ )
17:51:35 <homovitruvius> any workaround for cabal haddock --executables? I get "cabal: internal error when calculating transitive package dependencies.
17:51:35 <homovitruvius> Debug info: []"
17:55:36 <gfixler> there isn't a way to do this, is there? update f g r = r { g = g $ f r }
17:55:49 <gfixler> it's that g = that's the sticking point
17:56:09 <gfixler> I have to define this for each field, or use lenses, right?
18:01:44 <geekosaur> right
18:01:50 <gfixler> thanks
18:05:23 <ski> nwf : given two categories ⌜C⌝,⌜D⌝, two functors ⌜F,G : C → D⌝, and a natural transformation ⌜η : F → G⌝ between them, we can, for any object ⌜α⌝ in ⌜C⌝, get a morphism ⌜η_α : F α → G α⌝. also, for any two objects ⌜α⌝,⌜β⌝ in ⌜C⌝, and a morphism ⌜f : α → β⌝ between them, we can get a commuting square :
18:05:35 <ski>                f
18:05:41 <ski>             α  →    β
18:05:43 <ski>  
18:05:51 <ski>               F f
18:06:02 <ski>     F     F α  →  F β
18:06:11 <ski>   η ↓  η_α ↓   ↘   ↓ η_β
18:06:20 <ski>     G     G α  →  G β
18:06:27 <ski>               G f
18:06:49 <ski>   nwf : here the two ways to get from the top left corner to the bottom right corner of the square, by composing two edges of it, must be equal. we could name this equal diagonal morphism ⌜η_f : F α → G β⌝
18:07:11 <ski> nwf : if ⌜F⌝ (or ⌜G⌝) isn't known to be a functor, then we can't form the top (or bottom) edge of this square, and so we can't even state that the two ways ought to be equal
18:07:23 <shachaf> ski++ # defining natural transformation components on arrows
18:07:52 <ski> nwf : it might make sense to take the construction of the diagonal (⌜f ↦ η_f⌝) (satisfying which laws ?) as a primitive for a "natural transformation" (⌜η⌝) between two type constructions, from ⌜C⌝ to ⌜D⌝, which aren't known to be functors
18:07:58 <shachaf> I find it very difficult to read diagrams in IRC, though, especially with people joining in the middle. Might be better to use hpaste or something.
18:09:46 <ski> nwf : the three types (all equivalent) i was pondering above express this diagonal construction
18:09:58 <nwf> ski: I don't mean to be obtuse, but haven't you just reposed the question I asked?
18:11:26 <nwf> The "satisfying which laws?" is, I think, "what does it mean to be parametrically polymorphic when F and/or G are not functors"?
18:11:36 <nwf> (It's entirely possible I'm missing something.)
18:11:39 <ski> nwf : for all but the last of what i said, you're correct
18:12:20 <nwf> Could you slow down the new part, again?
18:13:06 <ski> * ski . o O ( ⌜∀ α β. (α → β) → (F α → G β)⌝ )
18:14:36 <ski> that is an attempt of explaining what a "natural transformation" from ⌜F⌝ to ⌜G⌝ might mean, when not both of those are known to be functors
18:15:27 <arkeet> why must it be covariant like that?
18:15:30 <ski> it's interesting to note that it is equivalent to both ⌜∀ α. F α → Yoneda G α⌝ and ⌜∀ β. CoYoneda F β → G β⌝
18:16:00 <ski> arkeet : no good reason, except that we're usually talking about covariant functors by default
18:16:32 <arkeet> what's a natural transformation from (-> r) to (-> s)?
18:16:58 <arkeet> I would hope it looks like (b -> a) -> (a -> r) -> (b -> s)
18:16:59 <arkeet> or something.
18:17:22 <ski> (and so there would probably be other variants (how many ?) for when we don't start from the case where both ⌜F⌝ and ⌜G⌝ are covariant (as opposed to contravariant) functors)
18:17:43 <arkeet> maybe we can solve this with profunctors.
18:17:53 <nwf> arkeet: AFAIUI the natural transformation diagram is basically unaltered when talking about contravariant functors, because everything's universally quantified at the same time.
18:20:24 <nwf> Hm.  If we run with ⌜∀ α β. (α → β) → (F α → G β)⌝ being the appropriate analog of nat. trans., then the traditional pun that parametric functions "are" natural transformations needs some updating; in addition to the type application, they'll be supplying id at the right type.
18:22:05 <ski> (i'm not sure how the above idea would integrate with (e.g. relational) parametricity)
18:22:17 <arkeet> ski: I assume you've seen the arrow definition of a natural transformation.
18:22:37 <shachaf> arkeet: Is that the one ski gave above?
18:22:46 <arkeet> something like that.
18:22:56 <arkeet> the thing that maps arrows a -> b to arrows F a -> G b
18:23:13 <ski> "arrow" as in the type class `Arrow' ?
18:23:21 <arkeet> as in morphisms in a category
18:23:31 <arkeet> I'm talking about natural transformations in general.
18:23:42 <shachaf> 18:05 <ski>   nwf : here the two ways to get from the top left corner to the bottom right corner of the square, by composing two edges of it, must be equal. we could name this equal diagonal morphism ⌜η_f : F α → G β⌝
18:24:19 <arkeet> yeah so it's the one ski gave above.
18:24:24 <shachaf> I guess this is defining it in terms of the usual components, rather than its own thing with its own law.
18:25:10 <arkeet> so what I mean is, I guess,
18:25:35 <arkeet> a natural transformation between two functors F, G : C -> D
18:26:03 <arkeet> is something that assigns, for each f: a -> b in C, some \eta_f: F a -> G b in D
18:26:19 <arkeet> such that G g . \eta_f = \eta_g . F f.
18:26:26 <arkeet> for any composable f and g in C.
18:26:48 <shachaf> So the "diagonal square" commutes.
18:26:56 <arkeet> I guess.
18:28:18 <arkeet> you get the traditional components of a natural transformation by \eta_c = \eta_{id_c} for objects c in C.
18:28:44 <shachaf> I guess it's "commutative parallelogam" might be more descriptive. :-)
18:28:49 <arkeet> sure. :)
18:28:55 <ski> (yes)
18:29:26 <joliny> I find zipWith funciton is defined like this.
18:29:28 <joliny> zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
18:29:28 <arkeet> well, you can draw two adjacent commutative squares.
18:29:33 <arkeet> and the diagonals in those squares.
18:29:39 * ski nods
18:29:55 <joliny> but zipWith function 's params is two list
18:30:12 <ski> joliny : .. and a function
18:30:12 <joliny> why is not zipWith :: (a -> [b] -> [c]) -> [a] -> [b] -> [c]
18:30:41 <ski>   zipWith f as bs = ..f..as..bs..
18:30:59 <ski> you know `zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]', and therefore you also know
18:31:05 <ski>   f :: a -> b -> c
18:31:09 <ski>   as :: [a]
18:31:14 <ski>   bs :: [b]
18:31:23 <ski>   ..f..as..bs.. :: [c]
18:31:44 <arkeet> joliny: zipWith takes a function and two lists.
18:31:47 <ski> (the last is what the *expected* type of the body is. if the actual type is something different, then you get a type error)
18:31:54 <arkeet> the function takes an element from two lists, and returns an element of the result list.
18:32:14 <arkeet> er, an element from each of the two lists.
18:32:40 <arkeet> elements of something of [a] have type a, elements of something of tyep [b] have type b, etc.
18:33:40 <joliny> er,I kown. (a->b->c) b,c is a function's paramters
18:33:51 <arkeet> ?
18:34:02 <joliny> [a]->[b] is zipWith 's parameters
18:34:49 <roboguy_> that's not how that gets grouped
18:35:07 <joliny> thanks to arkeet and ski
18:35:33 <arkeet> I'm confused.
18:36:26 <SolWolf> hey
18:36:43 <joliny>  `zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]`
18:36:53 <SolWolf> nice
18:37:19 <joliny> zipWith user one function and two list for it's parameters. and (a->b->c) is the function's define
18:37:50 <joliny> (a -> b -> c) -> [a] -> [b]->[c] is zipWith function's define
18:38:14 <arkeet> that is the type of zipWith.
18:38:37 <joliny> yes.
18:47:36 <Javran> what's the reason that every other member in Data.Tuple gets exported in Prelude, but not "swap" ?
18:47:58 <shachaf> The Prelude is defined independently of Data.Tuple.
18:48:16 <shachaf> Someone wanted swap, so they added it to Data.Tuple. No problem. But adding it to the Prelude is a different matter.
18:48:30 <johnw> in fact, that's been asked for
18:49:56 * hackagebot HsOpenSSL-x509-system 0.1.0.2 - Use the system's native CA certificate store with HsOpenSSL  http://hackage.haskell.org/package/HsOpenSSL-x509-system-0.1.0.2 (MariosTitas)
18:54:57 * hackagebot irc-core 1.0 - An IRC client library and text client  http://hackage.haskell.org/package/irc-core-1.0 (EricMertens)
19:09:42 <Javran> ah, I see. then has "swap" been proposed to be exported from Prelude?
19:10:13 <shachaf> Maybe.
19:10:23 <shachaf> It doesn't sound like a great idea because lots of people define that name themselves.
19:12:17 <arkeet> I don't think swap gets used that often.
19:13:11 <arkeet> I'd guess more often than curry, though.
19:13:40 <Javran> well, I guess even defining one involves fewer keystroke than import Data.Tuple
19:14:58 * hackagebot Redmine 0.0.6 - Library to access Redmine's REST services  http://hackage.haskell.org/package/Redmine-0.0.6 (cstpierre)
19:19:58 * hackagebot feature-flags 0.1.0.1 - A simple library for dynamically enabling and disabling functionality.  http://hackage.haskell.org/package/feature-flags-0.1.0.1 (IanDuncan)
19:34:59 * hackagebot webcrank-wai 0.1 - Build a WAI Application from Webcrank Resources  http://hackage.haskell.org/package/webcrank-wai-0.1 (purefn)
19:45:08 <gfixler> It works. I just needed UnicodeSyntax: http://lpaste.net/2856430135496671232
19:46:57 <shachaf> int-e: Would it be reasonable to turn off UnicodeSyntax for @run for consistency?
19:47:05 <shachaf> I guess it doesn't show up much and doesn't interfere that much.
19:58:44 <zbrown> Is it possible to download the entirety of a hackage repository, say the LTS stack one
19:58:47 <zbrown> stackage* one?
19:59:01 <zbrown> (and local host it, ideally config'ing cabal to hit that one)
19:59:23 <Clint> you mean like a mirror
19:59:43 <zbrown> Clint: yes
20:00:06 <zbrown> Clint: Ideally, flags I could pass to cabal to do so. 
20:01:26 <zbrown> Clint: I've got a network of machines which don't have external internet access for reasons I won't get into. I do however want to download the stackage repo and mirror it.
20:04:19 <geekosaur> there are some packages on hackage for automating mirroring of hackage repos, iirc
20:04:28 <johnw> zbrown: fpcomplete just released one
20:05:39 <zbrown> johnw: awesome, thank you
20:05:43 <zbrown> geekosaur: also you, thanks
20:06:38 <Ryanar> is there a function built into prelude that matches the first element of a list and then I can drop it from that list
20:07:04 <Ryanar> I am trying to go through a list and find an element and then move it to the front, so find 3 in [1,2,3] and make it [3,1,2]
20:13:03 <Sizur> anybody know of any papers how to implement a finite domain contraint solvers?
20:29:10 <jle`> Ryanar: i don't think so. it seems a little specialized :)
20:42:31 <RustyShackleford> I'm using HSpec
20:42:52 <RustyShackleford> just wondering, can I have multiple tests inside one "it" function?
20:43:04 <johnw> sure
20:43:24 <johnw> tests are anything that might throw an exception if it's wrong
20:43:33 <RustyShackleford> well i tested the same constraint twice
20:43:37 <RustyShackleford> and it shows only one failure
20:44:04 <johnw> ah, that's different questions
20:44:13 <johnw> you can HAVE multiple tests in one "if"
20:44:20 <johnw> you can't get _reporting_ from multiple failures in one "if"
20:44:27 <johnw> the first failure is the end of that set of tests
20:44:34 <johnw> s/if/it
20:44:37 <RustyShackleford> oh i see
20:44:50 <RustyShackleford> i suppose that might be okay
20:46:03 <wakalabis> Hey, guys.
20:46:18 <wakalabis> Has anyone tried LLVM Haskell tutorial?
20:47:02 <wakalabis> I cant make calls to external functions work.
20:47:21 <wakalabis> I get this message: ¨LLVM ERROR: Program used external function 'putchard' which could not be resolved!¨
20:47:30 <wakalabis> Has anyone come accross the same error?
20:48:43 <tzar> http://ipaste.org/kak
20:49:07 <tzar> can anyone help regarding different ways to load this program in Winghci
20:53:30 <peddie> wakalabis: yes, I think you have to remove the call to 'runPassManager'
20:53:39 <peddie> not sure why that happens
20:54:40 <wakalabis> peddie, thanks, Ill try it
20:55:03 * hackagebot crackNum 1.1 - Crack various integer, floating-point data formats  http://hackage.haskell.org/package/crackNum-1.1 (LeventErkok)
20:55:07 <peddie> wakalabis: please let me know whether that works; if it's a different thing it might still provide a clue about what causes it
20:55:43 <wakalabis> peddie, It was actually already commented here
20:56:45 <wakalabis> If I remember correctly, if it is *not* commented I can t call sin() and cosin() functions as described in the tutorial
20:56:48 <peddie> wakalabis: are you correctly linking with an external library?
20:56:55 <RustyShackleford> i've noticed that a few guides mention that repeated use of ++ is slow
20:57:02 <RustyShackleford> for string concatenation, that is
20:57:17 <RustyShackleford> what is the alternative then?
20:57:23 <Clint> not using String
20:57:29 <wakalabis> peddie, I don t know. I am just using the Makefile in the project I pulled from github
20:57:39 <shachaf> Using (++) right-associatively.
20:57:40 <peddie> wakalabis: I see, not sure then
20:57:52 <RustyShackleford> Clint: I don't follow. Do we have like a StringBuilder sorta object we can use?
20:57:57 <shachaf> ((a ++ b) ++ c) is a problem; (a ++ (b ++ c)) is fine.
20:58:09 <shachaf> Well, as fine as you can hope for with a linked list of characters.
20:58:15 <wakalabis> peddie, did you follow this tutorial too?
20:58:23 <wakalabis> peddie, I am on Mint Linux, by the way
20:58:40 <peddie> wakalabis: a while back, but I started having linkage problems (on debian) when I got some newer llvm-general versions
20:59:03 <wakalabis> everything else works though
20:59:21 <wakalabis> I´ll try it later on OS X 
20:59:33 <Clint> RustyShackleford: i was suggesting using a different type, such as Text or ByteString
20:59:33 <peddie> wakalabis: I guess I would look at the Makefiles and see whether you think the 'putchard' that's defined (or that you define?) in C should be available to the program you're running
20:59:58 <peddie> i.e. does whatever object (.o/.a/.so) contains putchard get linked into your haskell program?
21:00:07 <Clint> RustyShackleford: shachaf is being more helpful
21:00:08 <RustyShackleford> anyway unless I'm doing this a whole bunch of times it shouldn't matter, right?
21:00:15 <wakalabis> peddie, it´s funny how I can call sin() and cosin() 
21:00:31 <wakalabis> peddie, I don´t even know where they are defined
21:00:34 <peddie> wakalabis: that makes it seem like a linkage problem, because the C libm is linked automatically
21:00:51 <peddie> wakalabis: they're in libm (when building C code, you must pass '-lm' to link to that library)
21:00:56 <wakalabis> what´s this libm ?
21:01:03 <RustyShackleford> C math library
21:01:11 <peddie> wakalabis: well, sin() and cos(); I dunno about 'cosin()' . . . 
21:01:22 <wakalabis> oh.. of course
21:01:40 <wakalabis> peddie, that´s correct
21:03:19 <peddie> wakalabis: I suspect it's something the Makefile isn't doing that you have to do yourself
21:03:37 <peddie> wakalabis: what chapter are you trying to 'make'?
21:03:42 <wakalabis> peddie, I guess so. I have never called anything from C before
21:03:50 <wakalabis> peddie, Chapter 4
21:04:43 <wakalabis> $(CC) -fPIC -shared src/chapter4/cbits.c -o src/chapter4/cbits.so
21:04:51 <peddie> hmm, it looks like the Makefile for that tutorial is doing the right thing . . . not sure where to point you but at the github issues page for that tutorial
21:04:51 <wakalabis> ghc $(OPTS) src/chapter4/cbits.so --make src/chapter4/*.hs -o chapter4
21:04:53 <peddie> yeah
21:05:24 <Ryanar> if I have a function that returns a list and I want to wrap it into a list how do I do that? would this work? [foo [1,2,3,4] [4,5,6,7]]
21:05:34 <Ryanar> foo :: [a] -> [a] -> [a]
21:05:37 <shachaf> Why don't you tell us?
21:06:12 <jle`> Ryanar: do you have a haskell compiler installed? like ghc, maybe?
21:06:16 <Ryanar> yes
21:06:18 <Ryanar> I tried it
21:06:22 <Ryanar> but its not working
21:06:23 <jle`> if you have ghc installed, you can use `ghci` to test
21:06:35 <Rotaerk> if you have a function that returns a list, let's say foo
21:06:39 <Rotaerk> you wrap it into a list with [foo]
21:06:50 <Rotaerk> seems simple enough :P
21:07:08 <Ryanar> yeah I can't get it to work in ghci
21:07:24 <jle`> what does "not work" mean?
21:07:27 <Ryanar> so I was wondering if I was misplacing the parenthesis
21:07:41 <jle`> is foo in scope?
21:07:53 <jle`> if you have an error, can you post it?
21:07:57 <Ryanar> sure
21:08:12 <Ryanar> what is the easiest way to post errors? a screencap? a gist?
21:08:16 <jle`> it's much easier than us guessing things one at a time with no idea what the error is :)
21:08:18 <jle`> @where lpaste
21:08:18 <lambdabot> http://lpaste.net/
21:08:24 <Ryanar> ok
21:08:31 <Ryanar> is there a way to pipe error output of ghci?
21:09:43 <Ryanar> actually I just got it working, it is [foo arg1 arg2] ++ [[a]]
21:10:25 <jle`> congrats :)
21:10:29 <benzrf> night
21:10:43 <Ryanar> jle`, but for future reference, how would I capture the output from a ghci error?
21:10:45 <jle`> btw [x] ++ ys is the same as x : ys
21:10:53 <jle`> i'm not sure, i just copy and paste normally
21:11:12 <jle`> if you can get the error in a haskell source file you can pipe out the result of ghc
21:11:46 <Ryanar> I just need to figure out how to copy and paste in git bash then
21:11:55 <Ryanar> or pipe the error
21:12:21 <RustyShackleford> so I have a rather complicated data type I'm trying to test with HSpec
21:12:23 <RustyShackleford> http://lpaste.net/129999
21:12:23 <jle`> can you highlight?
21:12:53 <RustyShackleford> so i'll need a few test fixtures. where do I put them?
21:13:00 <jle`> ctrl+insert is the copy-highlighted-thing-to-clipboard for most terminal emulators 
21:14:03 <Javran> or just highlight the message and mid click on places you want to paste
21:15:05 * hackagebot mighttpd2 3.2.6 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.2.6 (KazuYamamoto)
21:17:18 <Javran> is there a ghc option for dry-running compilation?
21:18:42 <zilinc_> Javran: what's for?
21:20:04 <Javran> zilinc_: I meant I just want to see if it compiles, but care nothing about the resulting files
21:20:39 <verement> how would I indicate a GHC version dependency in my .cabal file, if I know that my code provokes bugs in prior versions of the RTS?
21:21:01 <Javran> like a quick and dirty "let (Right _) = parse p foo bar" for testing parsers
21:21:49 * ski . o O ( `let Right _ = parse p foo bar' )
21:22:15 <ski> > let Right _ = Left () in ()
21:22:16 <lambdabot>  ()
21:22:28 <Javran> what
21:22:38 <Javran> oh right, fail ...
21:22:58 <zilinc_> Javran: maybe -fno-code?
21:24:22 <mniip> > let !(Right _) = Left () in ()
21:24:23 <lambdabot>  *Exception: <interactive>:3:5-24: Non-exhaustive patterns in pattern binding
21:24:40 <mniip> but still iff the () is demanded
21:25:01 <ski> (naturally)
21:25:02 <Javran> zilinc_: yeah, that's exactly what I want, thanks
21:25:34 <ski> > case Left () of Right () -> ()
21:25:36 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
21:25:54 <ski> > let check (Right ()) = () in check (Left ())
21:25:55 <lambdabot>  *Exception: <interactive>:3:5-25: Non-exhaustive patterns in function check
21:26:42 <ski> `let'-bindings are performed non-strictly (unless you use `!', like mniip showed)
21:27:49 <Javran> ah right, then it isn't fail's fault
21:28:24 <ski> > let Right x = Left () in ()
21:28:26 <lambdabot>  ()
21:28:27 <ski> > let Right x = Left () in x
21:28:28 <lambdabot>  *Exception: <interactive>:3:5-21: Irrefutable pattern failed for pattern Rig...
21:28:44 <Javran> just wanted to give an example to say I want to run it and don't care about the result
21:28:55 <ski> when `x' is forced, the pattern which bound `x' is actually matched with the corresponding value
21:29:00 <Javran> void should be sufficient though
21:29:43 <Javran> @src void
21:29:43 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
21:30:07 <Javran> > void (Just undefined)
21:30:08 <lambdabot>  Just ()
21:30:35 <Javran> oh right
21:30:37 * ski thinks the name `void', with this implementation, should only by used in conjunction with FFI
21:31:39 <Javran> sometimes I use "void $" to get rid of some "_ <- foo" stuff
21:31:54 * ski would call that `ignore', in a Haskell context
21:32:07 <Javran> especially the last line in a do block
21:32:08 <johnw> in Lisp that's ignore
21:32:14 <ski> (the corresponding thing in SML and O'Caml is called `ignore')
21:32:32 <ski> johnw : CL ? ELisp ?
21:32:38 <johnw> elisp
21:32:48 <ski> ok, ty
21:34:28 <ski> (the name `void' here is really not Haskell terminology (the closest Haskell thing is `()', the "unit" type&value). it is C, and so belongs with the FFI)
21:37:03 <RustyShackleford> you can hide functions inside your module. But if you do that, how do you test them?
21:37:18 <johnw> put them in a module called ...Internal
21:37:32 <johnw> then re-export the few that should be from a public facing module
21:37:42 <johnw> that way, your tests can import the Internal module directly (i.e., not the library)
21:38:10 <RustyShackleford> maybe I'll just continue exporting them all
21:38:24 <RustyShackleford> and trust that the user (me) won't call certain ones
21:38:49 <RustyShackleford> i have quite a few helper functions
21:48:51 <Ryanar> if I have a pattern match of x:y:zs, could I call a function foo as foo (y:zs) to leave off x?
21:50:17 <arkeet> yes.
21:50:25 <arkeet> because the types work.
21:50:54 <arkeet> if you match x:y:zs, you know x :: a, y :: a, z :: [a] for some a.
21:50:58 <L8D> is there a way to design a language like Haskell but somehow now use capital letters at all?
21:50:59 <arkeet> er, zs :: [a]
21:51:02 <arkeet> so y:zs makes sense.
21:51:42 <arkeet> L8D: you mean to not have a different syntactic category for constructors and variables?
21:51:56 <L8D> basically
21:52:37 <arkeet> you could try.
21:52:44 <glguy> L8D: Agda has Haskell-like syntax and doesn't use capitalization for namespacing
21:53:05 <Cubesoup> also mixfix operator syntax
21:53:09 <Cubesoup> which is very sexy
21:53:27 <glguy> Special editor support for context sensitive syntax highlighting becomes extremely important to be able to tell what's going on
21:53:37 <glguy> and also just knowing all the operators by heart and their fixities
21:54:00 <L8D> glguy: constructors/pattern matches are based on scope?
21:54:15 <L8D> does that also mean you can have prolog-style matches?
21:54:54 <glguy> No, it's not related to that
21:58:06 <hunteriam> whats keeping us from removing map and renaming fmap as map
21:58:12 <hunteriam> nd including it in base
21:58:18 <hunteriam> or head 
21:58:22 <hunteriam> or watever
21:58:39 <L8D> hunteriam: it would cause a lot of existing code to break
21:58:46 <hunteriam> examples?
21:58:54 <L8D> hunteriam: and it's worse for beginners
21:59:07 <L8D> hunteriam: type ambiguity problems
21:59:10 <hunteriam> shouldnt we focus on making the best language we can?
21:59:14 <hunteriam> not the easiest?
21:59:19 <L8D> hunteriam: that's what Idris is doing
21:59:24 <hunteriam> ah
21:59:26 <L8D> which already does that
21:59:37 <hunteriam> too bad i dont understand dependant types very well
21:59:38 <bananagram> being easy to learn is part of being a good language
22:00:00 <L8D> hunteriam: dependent types don't prevent you from using Idris
22:00:19 <L8D> hunteriam: also, most of the problems in Haskell are from Haskell being as old as it is
22:00:33 <hunteriam> are there many unsolvable remaining problems?]
22:00:39 <hunteriam> what problems are you talking about?
22:00:57 <L8D> hunteriam: for example, AMP and FTP proposals
22:00:59 <hunteriam> bananagram: i dont think fmap -> map would make it harder or worse
22:01:02 <sellers> newtype Writer w a = Writer { runWriter :: (a, w) }  : why the heck is this runWriter :: (a, w) instead of runWriter (w, a)?  That's just confusing :<
22:01:05 <L8D> hunteriam: fmap not being map
22:01:18 <L8D> hunteriam: not putting Applicative in Prelude
22:01:20 <L8D> hunteriam: String
22:01:27 <L8D> hunteriam: IO typing
22:01:32 <hunteriam> i wish we could just break haskell and fix it all
22:01:37 <hunteriam> cause its not hard to fix
22:01:38 <L8D> hunteriam: clunky GADTs
22:01:45 <hunteriam> theyre clunky?
22:01:52 <L8D> well they can't do everything
22:01:53 <hunteriam> how does idris do GADTs?
22:01:56 <arkeet> what's wrong with IO
22:01:59 <L8D> GADTs are built-in
22:02:05 <arkeet> or GADTs
22:02:10 <L8D> arkeet: effects is a better term for that
22:02:22 <L8D> arkeet: i.e. Haskell doesn't have effects
22:02:33 <L8D> or any way to reason about IO code other than wrapping IO in a newtype
22:02:50 <L8D> :s/reason about/well type/
22:03:09 <hunteriam> could you give an example of how it could be better
22:03:22 <hunteriam> also i dont understand whats wrong with GADTs being built in
22:03:37 <L8D> hunteriam: GADT are built-in to Idris
22:03:39 <L8D> is what I meant
22:03:50 <hunteriam> theyre not built into haskell?
22:04:02 <L8D> hunteriam: they weren't for quite a while
22:04:08 <hunteriam> oh
22:04:13 <L8D> hunteriam: now they are, but you still need a few language pragmas for them to work properly
22:04:14 <hunteriam> how did we use to do it?
22:04:29 <hunteriam> like which ones L8D ? ive never used pragmas really
22:04:35 <L8D> hunteriam: we just didn't use GADTs, or used really crazy Rank2 systems
22:06:16 <hunteriam> i wish haskell would stop caring about being easy to learn
22:06:24 <hunteriam> i feel like fmap -> map wouldnt make it harder
22:06:30 <hunteriam> you can use map without fully understanding it
22:07:09 <sellers> hunteriam: The error messages from the more general fmap are much harder to understand for a beginner
22:07:20 <sellers> "what's a functor?" vs "oh i just screwed up my types with map"
22:07:33 <L8D> hunteriam: you need the GADTs pragma, and usually others like EmptyDataDecls and/or DataKinds
22:07:39 <hunteriam> so the real thing were wiating for is better error messages?
22:07:40 <sellers> i don't know if that's a "good enough" argument to keep fmap and map separate, but it's something
22:08:09 <hunteriam> L8D: wait the default data constructor arent GADTs?
22:08:18 <L8D> hunteriam: no
22:08:33 <L8D> hunteriam: they define ADTs
22:08:34 <hunteriam> ...why not?
22:08:48 <L8D> hunteriam: because they're not in the Haskell report or something
22:08:57 <L8D> you need language pragmas for just about everything
22:11:08 <L8D> Bang patterns, derivable generic, pattern symbols, multi-parameter type classes, overloaded strings, rank n types, scoped type variables
22:11:24 <rola> i thought it was because "Type inference in the absence of any programmer supplied type annotations is undecidable", and the langauge designers value the current automaticity of inference 
22:12:24 <L8D> rola: you could make that argument, but it's not a very pragmatic one
22:13:50 <L8D> I'm thinking of designing a logic programming language with dependent types where types are just predicates
22:14:19 <hunteriam> what would it mean if types were predicates
22:14:35 <L8D> in logic programming, you use predicates instead of functions
22:14:39 <RustyShackleford> what the heck? "cabal: ghc: failed to create OS thread: Cannot allocate memory"
22:14:49 <L8D> with functions, you go from input to output
22:14:54 <RustyShackleford> i suppose I could try restarted. It worked just fine a minute ago
22:14:56 <L8D> with predicates, you go from input to true/false
22:15:18 <L8D> RustyShackleford: it probably ran out of memory in it's heap or something
22:15:45 <RustyShackleford> the machine is basically idle
22:16:30 <RustyShackleford> no, nevermind. I'm reading the graph incorrectly
22:16:45 <RustyShackleford> yes, memory is full. and I'm an idiot haha
22:17:31 <L8D> hunteriam: so defining a type is the same as defining a function, and I can use any existing predicates for functions
22:18:07 <hunteriam> L8D: how are types equivalent to inpt -> bool
22:18:36 <hunteriam> although that sounds potentially way more powerful than functions
22:18:44 <hunteriam> or potentially less
22:19:17 <Hijiri> maybe you restrict the type with predicates?
22:20:38 <Hijiri> like you can do with typeclass hackery
22:21:18 <Hijiri> class Succ a b | a -> b where {}
22:21:49 <hunteriam> how is that restricted as in -> bool?
22:22:14 <Hijiri> well types couldn't be predicates
22:22:29 <Hijiri> well
22:22:31 <Hijiri> maybe
22:22:37 <Hijiri> the predicate of "you are this type:
22:22:51 <Hijiri> you are that type if you fit that predicate
22:23:00 <L8D> yes
22:23:03 <Hijiri> which is something different from what I was thinking about
22:23:27 <L8D> int(X) :- X rem 1 is 0.
22:23:41 <L8D> int(X) :- even(X).
22:24:09 <L8D> nat(zero).
22:24:18 <L8D> nat(succ(N)) := nat(N).
22:24:30 <L8D> ^ something like that
22:24:55 <hunteriam> := is a type predicate?
22:25:07 <hunteriam> how does the compiler check that?
22:25:09 * hackagebot auto 0.3.0.0 - Denotative, locally stateful programming DSL & platform  http://hackage.haskell.org/package/auto-0.3.0.0 (jle)
22:25:16 <Hijiri> I thought it was typoed :-
22:25:49 <L8D> ^
22:25:53 <L8D> oops
22:25:59 <hunteriam> sorry, what is :-?
22:26:06 <Hijiri> It's implication
22:26:09 <L8D> hunteriam: it means "such that"
22:26:12 <Hijiri> the thing on the left is true if the things on the right are true
22:26:19 <L8D> or "if"
22:26:26 <hunteriam> ah
22:26:48 <hunteriam> how would you define even
22:26:56 <hunteriam> or rem
22:27:16 <Hijiri> even(zero). even(succ(succ(N))) :- even(N)
22:27:19 <L8D> rem is just a restricted version of modulo
22:27:24 <Hijiri> but I don't know how type checking would work
22:27:37 <L8D> Hijiri: dependent types
22:27:58 <L8D> you can only use predicates as types if the compiler can prove they will never fail
22:28:06 <L8D> for example:
22:28:07 <Hijiri> but how do you check it
22:28:15 <Hijiri> would this be like liquid types
22:28:32 <Hijiri> I'm wondering how you would incorporate the types into using the logic language
22:28:50 <L8D> append(X, Y, R) :- list(X, A), list(Y, A), list(R, A).
22:28:59 <L8D> hm....
22:29:12 <L8D> how about := is for type declaration
22:29:24 <L8D> append(X, Y, R) := list(X, A), list(Y, A), list(R, A).
22:29:36 <Cale> What are we discussing? Dependently typed logic programming languages?
22:29:41 <L8D> append(Xs, [], Xs).
22:30:03 <L8D> whoops
22:30:23 <L8D> append([X|Xs], Ys, [X|Rs]) :- append(Xs, Ys, Rs).
22:30:29 <L8D> append([], Ys, Ys).
22:30:32 <L8D> Cale: yes
22:30:44 <L8D> I'm designing one
22:31:48 <L8D> it should probably be: list(A, X), list(A, Y), list(A, R).
22:32:21 <hunteriam> L8D: but how does that change the underlying data
22:32:33 <hunteriam> hunteriam: it just proves appending is possible,right?
22:32:37 <hunteriam> it doesnt actually append
22:32:43 <L8D> hunteriam: it does
22:33:12 <L8D> say you want to write append_123
22:33:30 <L8D> append_123(Xs, Rs) :- append(Xs, [1, 2, 3], Rs).
22:33:45 <L8D> you could define list as:
22:34:16 <L8D> list(A, [X|Xs]) :- A(X), list(A, Xs).
22:34:19 <L8D> or
22:34:24 <hunteriam> so a list is going to be a bunch of nested appends?
22:34:32 <L8D> list(A, cons(X, Xs)) :- A(X), list(A, Xs).
22:34:36 <L8D> list(_, nil).
22:34:58 <L8D> hunteriam: that's how they work in Haskell
22:35:06 <L8D> data List a = Cons a (List a) | Nil
22:35:57 <hunteriam> is it possible to do IO in this language?
22:36:12 <L8D> Yeah
22:36:36 <L8D> main(IO1, IO3) :- getLine(Input, IO1, IO2),
22:36:47 <L8D> append("Hello ", Input, Line),
22:36:56 <L8D> putStrLn(Line, IO2, IO3).
22:37:21 <L8D> DCG's are prolog's equivalent to a do-block
22:37:24 <L8D> where I can write:
22:37:48 <L8D> main --> getLine(Input), putStrLn(Line), { append("Hello ", Input, Line) }.
22:37:50 <sellers> I'm asking this out of curiosity, not trying to be derogatory -- what's the point?
22:38:00 <L8D> sellers: of this language?
22:38:10 <sellers> L8D: yes
22:38:16 <hunteriam> well its got dependant types i think
22:38:30 <hunteriam> and types and functions are really closely related
22:38:44 <L8D> sellers: the nearly perfect language?
22:38:59 <L8D> hunteriam: but they're not functions, they're predicates
22:39:20 <L8D> sellers: logic programming, static typing, intuitive dependent types
22:39:25 <sellers> L8D: clearly I'm missing something
22:39:40 <L8D> vect(zero, A, []).
22:39:46 <sellers> L8D: but don't let me get in the way of your conversation :)
22:39:54 <L8D> vect(succ(N), A, [X|Xs]) :- vect(N, A, Xs).
22:40:02 <L8D> sellers: feel free to ask questions
22:40:24 <hunteriam> now how do you specify that A is a type
22:40:31 <hunteriam> or could A be any predicate
22:40:33 <L8D> oops
22:40:40 <L8D> vect(succ(N), A, [X|Xs]) :- A(X), vect(N, A, Xs).
22:40:56 <L8D> A is a predicate
22:41:05 <L8D> and the value X has to follow A
22:41:23 <L8D> in this case, I'm using A as a type
22:41:29 <L8D> like a type variable in Haskell
22:41:38 <L8D> except it's just a variable, and it's just a predicate
22:41:52 <CapitalSigma> hello
22:42:01 <L8D> though there is one thing I have no idea how I could implement
22:42:07 <L8D> which is type classes
22:42:21 <CapitalSigma> what's the "right way" to do a key-value structure in haskell? something like a hashmap
22:42:38 <L8D> CapitalSigma: Map
22:42:48 <L8D> :t Map
22:42:49 <lambdabot>     Not in scope: data constructor ‘Map’
22:42:49 <lambdabot>     Perhaps you meant one of these:
22:42:49 <lambdabot>       variable ‘map’ (imported from Data.List),
22:42:53 <L8D> -.-
22:42:55 <L8D> :i Map
22:43:00 <L8D> CapitalSigma: look at Data.Ma
22:43:06 <L8D> Data.Map*
22:43:36 <hunteriam> couldnt you just have predicate classes, basically the same as typeclasses
22:43:41 <CapitalSigma> L8D: i'm not seeing that in the prelude, is it a package? i'm looking for something in the standard library
22:43:47 <dmj`> Data.Map is slow
22:43:52 <L8D> CapitalSigma: It's in the standard library
22:43:56 <L8D> dmj`: it's still usable
22:43:59 <hunteriam> and say that for a predicae in the calss the predicate x has to be true
22:44:12 <L8D> dmj`: and way faster than a python dict or a ruby hash
22:44:18 <L8D> and in most cases, a JavaScript object
22:44:19 <hunteriam> maybe you can partially specify the predicate
22:44:35 <Jeanne-Kamikaze> dem javascript objects
22:44:36 <L8D> functor(F) :- ...
22:44:39 <dmj`> L8D: a lot of python functions are just ffi calls to C
22:44:42 <CapitalSigma> L8D: where's the right way to look at the standard libary? (sorry, new to haskell)
22:44:54 <CapitalSigma> i've been looking at base on hackage
22:45:03 <Jeanne-Kamikaze> hoogle
22:45:06 <L8D> dmj`: it's still slow because they aren't sorted and the keys can be of any type
22:45:26 <L8D> CapitalSigma: you need to do: import Data.Map
22:45:35 <L8D> CapitalSigma: or better yet: import qualified Data.Map as M
22:45:44 <L8D> then use M.Map and M.insert and so on
22:45:57 <dmj`> L8D: Data.HashMap from unordered-containers would be a better choice
22:46:03 <heatsink> CapitalSigma: You can look at containers on hackage.  The documentation for the standard library is also installed locally if you install the Haskell Platform.
22:46:05 <L8D> dmj`: touche
22:46:15 <heatsink> CapitalSigma: "containers" is the package name
22:46:24 <hunteriam> hmm actually
22:46:28 <L8D> CapitalSigma: http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Map.html
22:46:31 <L8D> http://hackage.haskell.org/package/unordered-containers-0.2.5.1/docs/Data-HashMap-Lazy.html
22:46:34 <hunteriam> L8D: how do you do any transformation across types
22:46:38 <dmj`> IntMaps are fast
22:46:42 <hunteriam> L8D: i was trying to write fmap and couldnt
22:46:50 <L8D> hunteriam: yeah that's my problem
22:46:56 <L8D> how and where do I define fmap
22:47:11 <L8D> I'd need to think about it
22:47:14 <hunteriam> L8D: well could you even do map?
22:48:05 <L8D> map(P, [X|Xs], [R, Rs]) :- P(X, R), map(P, Xs, Rs).
22:48:10 <L8D> map(P, [], []).
22:48:42 <dmj`> hunteriam: fmap is defined for you in Data.Map
22:48:49 <hunteriam> dmj`: not in haskell
22:48:53 <dmj`> a Map is an instance of Functor
22:48:53 <CapitalSigma> Jeanne-Kamikaze: i'm a little bit confused by hoogle because it seems to index more than just the standard library
22:49:04 <hunteriam> were talking about a language L8D is thinking about writing
22:49:09 <dmj`> oh
22:49:12 <dmj`> myb
22:49:42 <hunteriam> L8D: so P is a predicate that takes two arguments? or P(X), P(R)
22:49:44 <CapitalSigma> in SML, i can look at all of the modules in the basis in a very nice way
22:50:17 <hunteriam> L8D: is X the input type and R the output?
22:50:18 <heatsink> CapitalSigma: On OS X, the standard library documentation gets installed in /Library/Haskell/doc/ghc-doc/index.html
22:50:29 <L8D> map(P, Xs, Rs) := pred(P, X, R), list(X, Xs), list(R, Rs), length(Xs, L), length(Rs, L).
22:50:42 <hunteriam> L8D: also why are you taking in a second list [R, Rs]
22:50:45 <heatsink> CapitalSigma: On Linux I think it's in /usr/share/ghc/doc/ or something like that
22:50:53 <CapitalSigma> i'm less clear with haskell when the documentation is taking about something in the basis and when it's talking about something else
22:50:56 <L8D> hunteriam: that's the resulting value
22:51:02 <L8D> hunteriam: the resulting list
22:51:08 <CapitalSigma> thanks, i'm on linux
22:51:32 <hunteriam> L8D: shouldnt you really just be providing a predicate that goes to the new output type R? what kind of input would you give for [R, Rs]?
22:51:48 <L8D> hunteriam: there is no "output type"
22:52:00 <L8D> hunteriam: predicates just return true or false
22:52:17 <L8D> map is a predicate, append is a predicate
22:52:25 <L8D> length is a predicate
22:52:35 <hunteriam> L8D: could you give an example of what you might provide for R, Rs as an argument?
22:53:03 <L8D> map(plus(1), [1, 2, 3], Xs).
22:53:16 <L8D> then Xs is now bound to [2, 3, 4]
22:53:29 <L8D> or really
22:53:47 <L8D> Xs is now bound by list(int, Xs)
22:53:57 <L8D> and Xs is the set {[2, 3, 4]}
22:54:02 <hunteriam> pred(P, X, R) is equivalent to pred(P), pred(X), pred(R), right?
22:54:08 <heatsink> CapitalSigma: With GHC, there is an index of all installed libraries (standard and otherwise).  You can list the installed libraries with `ghc-pkg list`
22:54:23 <L8D> since [2, 3, 4] is the only value that satisfies Xs in map(plus(1), [1, 2, 3], Xs).
22:54:32 <L8D> hunteriam: nope
22:54:43 <heatsink> CapitalSigma: As far as the index and library documentation are concerned, there's no difference between standard libraries and other libraries.
22:55:02 <CapitalSigma> heatsink: i'm taking a student learning haskell so i'd like to restrict my attention to only what's in the standard library
22:55:04 <L8D> pred(P, X, R) is equivalent to: P(A, B) := X(A), R(B).
22:55:21 <L8D> pred(P, X, R) is like p :: x -> r
22:55:24 <heatsink> Ok
22:55:25 <CapitalSigma> the distinction is clear in all of the other languages i'm familiar with so hoogle is a little overwhelming
22:56:22 <L8D> hunteriam: there should probably be some syntactic sugar for pred
22:56:36 <L8D> since you need to use pred on many arities
22:56:38 <heatsink> CapitalSigma: I would base it off of what's in the Haskell platform
22:56:55 <hunteriam> L8D: and you also have to curry pred for longer length predicates, right?
22:57:06 <hunteriam> or uh, recursively apply it
22:57:19 <L8D> hunteriam: yeah
22:57:27 <L8D> for p :: x -> r -> a -> b
22:57:41 <hunteriam> so how would you define plus?
22:57:58 <L8D> it would have to be: pred(P, X, P1), pred(P1, R, P2), pred(P2, A, B).
22:58:08 <L8D> plus(zero, X, X).
22:58:36 <L8D> plus(succ(N), X, succ(Y)) :- plus(N, X, Y).
22:59:27 <L8D> I could make:
23:00:05 <L8D> map(P(X, R), Xs, Rs) := list(X, Xs), list(R, Rs), length(Xs, L), length(Rs, L).
23:00:23 <L8D> using that inline syntax for typing predicates
23:00:35 <L8D> since otherwise it'd be invalid syntax
23:01:06 <hunteriam> that would be called differently than your first map, right?
23:01:19 <L8D> hunteriam: no it's just a different syntax for annoting the type of P
23:01:38 <hunteriam> oh ok its sugar for pred?
23:01:40 <L8D> instead of pred(P, X, R) I would match on P(X, R)
23:01:47 <L8D> yeah it's sugar for pred
23:02:09 <L8D> I still don't know how I'm going to add typeclasses though
23:02:20 <L8D> ooo
23:02:26 <hunteriam> L8D: i think you forgot to recall map on Xs and Rs
23:02:26 <heatsink> CapitalSigma: The Haskell Platform libraries are listed here, you'll probably be looking at base and containers the most: https://www.haskell.org/platform/changelog.html
23:03:02 <L8D> hunteriam: that was just the type signature
23:03:10 <hunteriam> oh.
23:03:15 <hunteriam> L8D: whats the body, then?
23:03:24 <L8D> hunteriam: the same as it was before
23:03:39 <L8D> I was just showing how the sugar would work
23:03:42 <hunteriam> oh ok
23:03:44 <hunteriam> cool
23:03:47 <hunteriam> i finally understand i think
23:05:04 <hunteriam> so Functor(P) ~~ fmap (P, A, B) := P(A), P(B)
23:05:08 <hunteriam> maybe?
23:06:25 <hunteriam> and youd have to make lists type dependant on its length i think
23:06:40 <L8D> hunteriam: no, fmap(P(A, B), Fa, Fb) := F(A, Fa), F(B, Fb).
23:07:00 <L8D> well in prolog [|] is just an atom
23:07:22 <L8D> '[|]'(X, Xs) is the same as [X|Xs]
23:07:29 <L8D> '[]' is the same as []
23:07:45 <L8D> oh you mean dependent on it's length
23:08:02 <L8D> that's why I have the length(Xs, L), length(Rs, L) at the end of the type signature
23:08:09 <hunteriam> I dont understand why thats right and mine is wrong
23:08:10 <L8D> which say that Rs and Xs must have the same length
23:08:23 <hunteriam> L8D: yea but you cant add that to the generic fmap type signature
23:08:25 <oakwhiz> :t sequence ((take 5 . repeat) [floor, ceiling])
23:08:26 <lambdabot> (Integral b, RealFrac a) => [[a -> b]]
23:09:05 <L8D> hunteriam: true, but you can't do that in Idris either
23:09:28 <hunteriam> L8D: thats why i was saying the functor instance of list would have to be for lengthed lists
23:09:37 <L8D> in which case, it would just mean only lists of equal lengths will satisfy the predicate
23:09:43 <hunteriam> so in my type P would be list(number)
23:09:52 <L8D> hunteriam: the length(Xs, L), ... part is only optional
23:10:02 <L8D> without it, it should still work
23:10:33 <L8D> if P is the predicate, the function that maps from A to B
23:10:44 <L8D> it would have type P(A, B)
23:10:53 <L8D> err... you would call it that way
23:11:06 <L8D> it would be typed as: pred(P, A, B)
23:11:12 <oakwhiz> @hoogle [[a -> b]] -> [a] -> [[b]]
23:11:12 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
23:11:13 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
23:11:13 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
23:11:48 <L8D> or foo(P(A, B)) := ...
23:12:20 <shachaf> This seems to not be Haskell and also to be taking over the channel.
23:12:26 <L8D> sorry
23:12:50 <lpaste> ryanar pasted “not understanding error with solveTriangular” at http://lpaste.net/6577705803522768896
23:13:07 <Ryanar> hey guys, not understanding why I am getting this error in my solveTriangular function
23:13:22 <Ryanar> oh wow
23:13:42 <Ryanar> oh wait, yeah no I don't get it
23:14:16 <L8D> Ryanar: look at the type of solveLine
23:14:28 <L8D> then look at the first case of solveTriangular
23:14:55 <L8D> then look at the second case of solveTriangular
23:14:59 <Ryanar> solveLine returns a single value
23:15:08 <L8D> Ryanar: solveLine has type [a] -> [a] -> a
23:15:08 <Ryanar> solveTriangular returns a list of values
23:15:12 * hackagebot expiring-cache-map 0.0.5.4 - General purpose simple caching.  http://hackage.haskell.org/package/expiring-cache-map-0.0.5.4 (elblake)
23:15:28 <Ryanar> oh, hahahaha
23:15:30 <Ryanar> wow
23:15:33 <hunteriam> L8D: Functor(F, X) :- fmap(F, P, X, A); fmap(F, P, X, A) -: F(X), F(A), P(X,A)
23:15:43 <hunteriam> i know thats not right, bu t i feel close
23:16:22 <shachaf> I recommend finding another channel for this.
23:19:43 <netroby> Why you learn Haskell
23:24:12 <Cale> netroby: who?
23:24:55 <netroby> You guys  who already learned haskell 
23:26:02 <pacak> netroby: It's a nice language
23:26:36 <quchen2> It's the only language I know that is interesting, fun, and practical.
23:26:47 <pacak> netroby: Which makes it difficult to shoot yourself in a foot unless you know what a monad is.
23:26:58 <Cale> Originally, I guess it was because it had a lot of cool features that the other programming languages I knew didn't already have. I got pointed at Haskell when I mentioned to a friend of a friend that I was interested in algebraic approaches to music theory, and he pointed me to Paul Hudak's Haskore.
23:27:14 <johnw> pacak: what have monads got to do with that?
23:28:03 <pacak> johnw: You need to do IO since pulling the trigger got some side effects.
23:28:20 <Cale> pacak: IO is not "monads", it's just something which happens to be an example of one.
23:28:46 <Cale> You don't need to know about monads in general just to use IO.
23:29:01 <Cale> (Though it might help a bit)
23:37:38 <caconym> netroby: tried it on a whim, stuck with it because IMO it's the best-designed language I've ever used and offers such a rich set of general tools for building software
23:40:26 <netroby> F# seems another well design functional programming. how do you feeling it?
23:41:34 <caconym> caconym: I don't know it, but I've heard good things and that it shares many features with Haskell
23:41:46 <caconym> netroby: oops that's a message for you, not myself
23:42:50 <oakwhiz> @pl \fl a -> map (\x -> zipWith id x a) fl
23:42:50 <lambdabot> flip (map . flip (zipWith id))
23:43:04 <Rotaerk> I prefer haskell to F#
23:43:14 <caconym> netroby: although personally, I am more inclined to be into Haskell because it is strictly functional
23:43:16 <Rotaerk> I'd only use F# as a compromise to get .NET, if I wanted that
23:43:58 <joliny> erlang && haskell is enought
23:44:08 <joliny> erlang && haskell is enough
23:47:02 <CindyLinz> netroby: I learned Haskell, because I wondered how a language without mutable variables or loops can work.... XD
23:47:25 <oakwhiz> > flip (map . flip (zipWith id)) (sequence ((take 5 . repeat) [floor, ceiling])) [1.2, 1.3, 1.4, 1.5, 1.6]
23:47:26 <lambdabot>  [[1,1,1,1,1],[1,1,1,1,2],[1,1,1,2,1],[1,1,1,2,2],[1,1,2,1,1],[1,1,2,1,2],[1,...
23:47:29 <jokester> I am learning it mostly as a quiz
23:47:46 <caconym> netroby: to elaborate, F# (IIRC) is "multi-paradigm", which implies that it is not strictly a functional language; I tend to think that multi-paradigm languages aren't a positive force for good design
23:48:29 <oakwhiz> yay it works
23:49:24 <oakwhiz> trying to get a list of coordinates of the integer corners of a 5-dimensional grid cell that an arbitrary point is inside.
23:50:21 <quchen2> It's completely unreadable.
23:55:04 <ph88> hi zalami 
