00:03:50 <dmj`> Why would running four parsers in parallel on a Text perform worse than the synchronous version?
00:04:02 <dmj`> like waaay worse
00:04:19 <dmj`> 600 picoseconds vs. 82 nanoseconds
00:04:33 <dmj`> what black magic is this
00:07:38 <pingu> dmj`: you need enough parallelism to overcome any constants.
00:08:16 * hackagebot pred-trie 0.0.10 - Predicative tries  http://hackage.haskell.org/package/pred-trie-0.0.10 (athanclark)
00:08:16 * hackagebot tasty 0.10.1.1 - Modern and extensible testing framework  http://hackage.haskell.org/package/tasty-0.10.1.1 (RomanCheplyaka)
00:08:21 <pingu> I don't know your specifics, but there's generally not much point to parallelising something that is already so fast.
00:09:38 <dmj`> pingu: good point, the constants are very small, only a few hundred characters
00:09:46 <dmj`> 136 times slower 
00:10:15 <dmj`> pingu: let me try increasing the sample size
00:14:07 <dmj`> pingu: it's still embarrasingly slower. This time ms vs ps
00:16:10 <stoopkid> haskell is killing me
00:16:27 <Xe> stoopkid: how?
00:16:30 <Xe> it's a pure language
00:16:35 <Xe> pure things can't be evil
00:17:24 <Adeon> purely evil
00:17:58 <stoopkid> Xe, i don't understand even the most basic things
00:18:11 <stoopkid> Xe, and everything is centered around data types
00:18:24 <stoopkid> except i understand none of the data types outside the primitives like Bool, Int, etc
00:18:51 <kadoban> stoopkid: What are you using to learn haskell?
00:18:59 <stoopkid> kadoban, the internet
00:19:11 <stoopkid> kadoban, any and every possible resource
00:19:22 <kadoban> stoopkid: Sounds awful. Use https://github.com/bitemyapp/learnhaskell
00:28:22 <pingu> dmj`: Have you read imbalance influenced by
00:28:29 <pingu> derp
00:28:36 <pingu> let's try pasting agian
00:28:43 <pingu> http://community.haskell.org/~simonmar/par-tutorial.pdf
00:28:56 <stoopkid> why does IO have to be so difficult
00:29:16 <stoopkid> it's like... the basic unit of operation in imperative programming
00:29:20 <stoopkid> in haskell its like
00:29:21 <stoopkid> ??
00:30:21 <kadoban> stoopkid: Haskell isn't an imperative language. And it's generally not that hard, IMO. Most imperative code in haskell looks a decent amount like imperative code in other languages. Is there a specific thing you can't figure out?
00:31:08 <stoopkid> kadoban, data types involved with packages for web & networking
00:31:15 <MP2E> stoopkid: it's really not so bad, don't worry about the specifics just yet, but you can use do blocks to sequence IO things. It happens to do other things with other datatypes, but that won't be important until you've read through a fair bit of a tutorial on Haskell
00:31:42 <kadoban> stoopkid: Don't do web and networking stuff when you don't know haskell yet.
00:32:24 <kadoban> stoopkid: Start with cis194, linked from the above URL, that'll give you some code under your belt and a better understanding of some haskell types.
00:32:25 <stoopkid> kadoban, that's what i mean about how IO is so difficult in haskell
00:33:09 <stoopkid> kadoban, i've gone through almost all of cis194 i still feel pretty shaky about it
00:33:22 <stoopkid> idk
00:33:26 <stoopkid> i was expecting something to click
00:33:31 <stoopkid> but that never happened
00:34:04 <stoopkid> if anything i just have more questions than when i started
00:34:19 <stoopkid> and the answer is always "don't worry about the details"
00:34:26 <stoopkid> even though i cant make my code compile
00:35:11 <simpson> I understand your pain. I was a novice for a long time.
00:35:12 <MP2E> Ah, didn't know you had already gone through most of cis194
00:35:17 <kadoban> stoopkid: "almost all". cis194 itself is kind of a minimum baseline, you need to do it all and do it thoroughly. If you're not clear on parts, ask, or experiment.
00:35:32 <MP2E> we can definitely get into more gory details, not sure which part specifically is confusing you though. Or which parts.
00:43:12 * hackagebot th-instance-reification 0.1.4 - Fixed versions of instances reification functions  http://hackage.haskell.org/package/th-instance-reification-0.1.4 (NikitaVolkov)
00:50:21 <felipedvorak> I know this channel is probably biased towards this question, which in itself is a poor question, but nonetheless a useful one now. Out of the functional programming languages, which would be the equivalent to what JavaScript is today in Web Development. Which means big, not that mature or well accepted, but definitely seen as the future and where the money is/will be?
00:50:32 <ollef> @tell napping I don't know, but I'll look into it. it looks like the worst-case performance is the same though.
00:50:32 <lambdabot> Consider it noted.
00:52:19 <kadoban> felipedvorak: JS is a functional language … so I would guess JS would be the equivalent of JS :)
00:52:28 <latk> I've been playing around with opaleye, and have run into a problem. When using tuples, as in the tutorial, to generate insert sql, all is fine. When I try and use a record however, it doesn't work. For example: http://lpaste.net/131401. Any ideas how I can fix this ?
00:54:55 <dmj`> felipedvorak: In the words of Tony Hoare, "Haskell is doomed to succeed"
00:55:26 <MP2E> Yep, it's mature, it's big, it's not well accepted yet but the momentum is increasing :)
00:57:04 <felipedvorak> dmj`: For years I've been planning on learning Haskell, but mostly out of curiosity. But really, nowadays I can't (at least yet) give myself the pleasure to learn something that would not impact me financialy at least in a short to medium term..
00:57:23 <felipedvorak> So I just thought that maybe I could get best of both worlds somewhere...
00:57:56 <latk> Many people have found that learning haskell makes them more structured when programming in other languages. Maybe that could be some justification ?
00:58:20 <felipedvorak> latk: Sure
01:00:06 <felipedvorak> I confess I did a poor searchjob before coming here and ask questions, but is there a haskell presence in the web development field somewhere?
01:00:15 <dmj`> felipedvorak: Haskell benefits me financially, no it's not like javascript where your mom can learn it in a week and lie to some recruiter to get a job. Anything good will take time to learn, it's worth it though, if not for the intellectual stimulation alone, but also financially, since at the end of the day it's still programming, and programming isn't going away anytime soon.
01:00:25 <latk> felipedvorak: You mean a company? Or webframeworks ?
01:00:29 <dmj`> felipedvorak: haskell is big in web dev
01:00:42 <latk> felipedvorak: Either way, yes :)
01:00:45 <u-ou> I just hope success doesn't ruin it :/
01:02:02 <dmj`> u-ou: I don't think it can, it weeds out all the rails-like people who want to "write code" w/o knowing what you're writing. It keeps you a computer scientist, not a configurator. IMO.
01:03:21 <latk> dmj`: I'm not sure that is necessarily true. I'm definitely not a computer scientist, but have come to prefer haskell over other languages.
01:03:40 <LordBrain> this might be bad netiquette, but i just walked in, and i'm curious what does that dmj` "weeds out all the rails-like people" ?
01:03:54 <latk> dmj`: Though I'm not hopefully not just a configurator..
01:04:04 <felipedvorak> latk: interesting... can you point me to a good page or a nice framework?
01:04:21 <dmj`> felipedvorak: http://snapframework.com
01:04:31 <felipedvorak> dmj`: thanks
01:04:48 <latk> felipedvorak: https://hackage.haskell.org/package/Spock, http://www.yesodweb.com/
01:05:34 <latk> felipedvorak: https://www.silk.co/home for example is written in haskell.
01:05:46 <latk> (I think I'm right in saying their server stuff is haskell, at least)
01:06:18 <latk> felipedvorak: http://engineering.silk.co/post/31920990633/why-we-use-haskell
01:06:23 <dmj`> LordBrain: what do you think it means?
01:07:33 <felipedvorak> latk: thanks!
01:35:30 <solatis> hello, I'm struggling a bit with Aeson, Lenses and using my own custom type
01:35:30 <solatis> http://lpaste.net/131429
01:35:30 <solatis> I have my own custom type HS.HexString which has FromJSON and ToJSON, which seems to be working fine
01:35:30 <solatis> however, I'm now trying to extract it out of a nested JSON Object using aeson-lens
01:35:30 <solatis> and it is telling me my destination type must be an instance of Monoid, presumably because Lens uses Monoid's mempty when a key cannot be found. Is this correct?
01:35:38 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org | Learn, Teach, or Get Out of the Way!'
01:35:38 --- topic: set by shapr!~shapr@84.200.228.78 on [Tue Mar 17 12:32:20 2015]
01:35:38 --- names: list (clog thkoch Swizec jontmorehouse Fusebox learns mauke eriksensei ywata fujimura bennofs adam_hardkey_shi aranemnon albel727 Jackneill qubitnerd cleamoon__ vlkm ndrei gienah LordBrain permagreen nshepperd_ nrolland edon amiri doomlord Itkovian ThatOtherPerson_ adek zso tibbe Xilov apolune felipedvorak boxfire pt1 xenog favetelinguis infinity0 Xnuk Vq Fubar^ chaosmasttter Kamas incredible _flow_ Lutin` fsvehla funfunctor Zanzare joneshf-laptop pacon Iskarlar)
01:35:38 --- names: list (Shagane Hijiri laar goldfire1 solatis hackagebot alevy raichoo mrb_bk plutoniix sebastard dgonyeo rbocquet dsantiago cmsmcq rj-code Reiser cstrahan mpereira mankyKitty eniirane Laney namuromus jnoah beauby anachron_ greymalkin hpd exio4 Draconx joehh1 drdo blue_feint cursork brezel Edoxile bsmt tarcwynne BrianHV thomas tessier mietek fr33domlover vikraman mno2 barrucadu jxm_ ]OLI[ ironChicken Elsi samnmax sevcsik dpwright niklasb xplat cryon bergmark pantsman-)
01:35:38 --- names: list (zrl alekst_ eivuokko_ lifenoodles_ Adeon thorkilnaur_ sokoll- jml AlainODea pm51 c9sould__ hguux____ az uwap_ jlamothe_ malllle sys9mm_ korpse_ vlatkoB_ luite__ apaku_ jrslepak_ ahihi2 NeatBasisW mgsloan_ Tehnix_ tlevine_ Guest6839 khisanth_ ibid__ sellout- jtobin_ deavidsedice mniip_ staffehn_ samertm hator1 lsep1 tismith_ scott lfairy vikram_ sclv seabre fro_ozen MrWoohoo dot_asp bb010g mrkishi bcavalier coeus andreypopp otherchas_ kerrick saolsen lacrosse__)
01:35:38 --- names: list (kalz chriswk zpconn__________ akahn dlackty___ joedevivo moy CARAM__ shennyg Tritlo fuziontech rslima bgyss nmashton jroesch avdi Qfwfq n1ftyn8 zph comma8 dh gbiv tomboy65 Dartanjan saep spion AntiSpamMeta ElderFain owa ezrios DANtheBEASTman friden __main__ crlane fnordbert psy__ drmegahertz trevorriles sorind poikon heyj diginet_ Natch Geekingfrog panda_man xandaros1 taruti electrogeek liff Profpats1 EvanR_ lispy_ pi8030 michaelpj_ mirsal rom1504_ _ether__)
01:35:38 --- names: list (platz_ jlewis_ jmcarthur_ krgn_ Keel abh yarou wrengr_a1ay sleepynate taksuyu kess_ hongminhee_ sgronblo_ kjnilsson rray Maxdaman1us RevJohnnyHealey kaol_ pleiosau1 Guest84284 Kneiva_ tzaeru_ PinealGl1ndOptic JamesJRH_ SoupE guampa shiona_ nyuszika7h_ vodkaInf1rno puzza007 biscarch doppioslash arnihermann Guest60091 A205B064 ronh_z jimstutt rikkie_ rivarun obcode_ Revenrof filius jumblerg yfeldblum nour revath rnons tv armyriad hiratara arbelos)
01:35:38 --- names: list (jmcarthur_mobile CMCDragonkai SamB_laptop free_beard pavonia fling rwiggins sakirious bshelden sunwukong` emanuelz dibblego Guest72815 forgottenone overlord7 thunderrd aborgna mhd Tril rprije fredp2 eazar001 fumieval negatratoron path[l] tgeeky Longlius gfixler naevathecat indiagreen tinyblak eisbehr jungnam Rotaerk darkf PyroPeter mecalopolis chrisdotcode darkbolt renzhi zaquest jessicah doctorinserenity MultiPurposeHat lspitzner hexagoxel exferenceBot cdk)
01:35:38 --- names: list (ArneB ellinokon theorb ksf Zekka pacak tvh Ralith Guest15869 kcj falafel mrd_ ScRaMbLe jonesinator erkin predator117 cyborg-one ryantrinkle sprang saulzar Stratege_ aarvar eevar rkazak_ Plastefuchs kfish amatsu Moggle vmeson dgorbik_ Nils fengshaun gusto martintrojer srid solarus pixelfog seedy meteo_ Paradisee Beetny centrinia _ixti_ proq byorgey ivan\ johtso_ gabriel_laddel stoopkid _ashbreeze_ Flonk ElectricSolstice latk skeet70 tnks whaletechno boot13 dxtr)
01:35:38 --- names: list (kadoban jmct oscar_toro gws MoALTz ValicekB schell desophos benwf sogaan ev` imPure renekooi xxpor StoneCypher noam mceier mada Gurkenglas Noldorin vin-ivar petermw xahry MP2E qiv clarktic MarkusBarthlen djellemah Quashie_ gnoel kosorith Wamanuz ollef augur isocliff otulp whiteline sw1nn Schrostfutz Frank89RM jaseemabid_ bjz bitonic theDon ktosiek tremon hamishmack sergey__ EvanR- ssn__ hebz0rl_ m0rphism Plasmastar larsen__ Francisco solrize erikd gsnewmark)
01:35:38 --- names: list (ecraven teclo- mimi_vx milieu f|`-`|f thetallguy BMeph otto_s_ sharvils rejuvyesh Betal drbean blicero tsou C4Cypher kidnapped_robot lnr mephx LnL tranma Excureo tejing wayne loz-- xant0me lurker6 Dykam kjanosz- fikusz aaronlevin srhb enthropy Svedrin martingale yrdz ryanakca Polarina Nimatek chishiki DrPete dolio Sonderblade akurilin pyon Or1 sh1ken zerokarmaleft rejerson69 nuser joris974 enolan Giggaflop abrar schoppenhauer bgamari bgamari_ Dodek julmac)
01:35:38 --- names: list (Soft- dcoutts mgomezch rola simonnn manfoo7 luzie dav ttuegel phaazon nuttycom besenwesen nak hive-mind paf31_away `szx vili Freundlich Guest70634 xificurC_ ido jacksoow siddhanathan Juka dixie_ zhulikas Pamelloes maurer Xack apollo1993 prophile Internet13 Elision verement Nadrieril CosmicRay tsani whitesn supki sagittarian dgvncsz0f lieven przembot djanatyn dockdock ljhms kvieta ortmage lambdabot klarrt jtanguy tg Voldenet cyphase zimbatm mitchty m1dnight_)
01:35:38 --- names: list (conehead pyloid ipuustin paperManu pikhq jle` Orwell84 ikke Vorpal huonw umbriel Talryn dino- unsymbol niko cschneid Bigcheese nemesit|znc marienz DrAwesomeClaws grohne nwf Draggor hattusili_III idempotent tswett therealklanni shouya demolithion catsup bracket ousado byaruhaf ernst dabradley lolmac juri_ acmiyaguchi Cale perrier simpson mrknife alanz BeardedCoder SaidinWoT steell noteventime keix MMuse_______ jonrh alphonse23_ phuu nbouscal kirjs_______)
01:35:38 --- names: list (mindos_cloud____ trig-ger Sorella neektza stasku dstockwell bonobo_ Oxyd octalsrc Kruppe mountaingoat Darkflux totte tongcx ixian andrewsw sinopeus ij folsen aloiscochard condy tridactyla wizonesolutions k-u bsummer4 caasihuang QuestofIranon josephle miklcct pyrtsa emma zilinc glguy jbalint fyolnish theanalyst somenick canta u-ou killerpty shlevy Eagle_Erwin td123 duairc kaictl u_ atn34 levi majorsei1an hvr untwisted Ezku xpika brixen lvh bitemyapp znutar)
01:35:38 --- names: list (dreixel heath jcp imalsogreg bjobjo esssing colah tinchos chris2 bananagram kolmodin rossberg mach spacebug shapr chpatrick tusj saurik duoi brackets frawgie mrsolow hooptw noddy oconnore pharaun Gothmog_ ZsoL myst|work janne sea-gull tristero sudog XMunkki SparkySparkyBoom FreeFull earthy agumonkey eddsteel da-x _rgn Phillemann statusbot ski RGamma noctux zorzar s00pcan fall` zeiris aaronweiss74 rdema etabot Jellydog nkpart cloudhead_ Liskni_si AWhetter alynn)
01:35:38 --- names: list (lenstr jaspervdj ParahSailin wagle OutlawStar Tristan-Speccy drewdavis spwhitt meteo buoto seagreen fryguybob phaskell Floyd_ petercommand anders^^ dlundy arw kqr dewdrop Taneb gds jameseb wedens dario` greeny kaw_ lamilami suls eyck unknownloner rul R0b0t1 johnw adzuci_ netj_ haroldwu robotbrain_ Sigyn bdamos David ctag cdidd hrnz mrowe_away elementalest Eliel inr ubuntor kalloc newsham zxq9 Boney Tesseraction grol lassulus kav spaceships ephemeron Vbitz)
01:35:38 --- names: list (avocado SHODAN flux flx aidecoe JZTech101 yusukesuzuki butyoudonot pii4 qr42 robbert ajp andjjj23 dropdrive kloplop321 cosban shwouchk sku1d masse MitchW blenny hemite Twey Bane^ kmicu thomie irclogger_com poucet lykkin jokester chirpsalot ephess karshan jaffachief benonsoftware gniourf gratimax iElectric cic eyenx_ lpsmith benzrf dmilith ThePhoeron TallerGhostWalt d3lxa mak` sdx23 ayertienna cjh` itsmonkt1stic jarvi_ nik_89 keaml_ klugez runde robogoat duga3)
01:35:38 --- names: list (lytchi yorick TRManderson mokus_ mgaare_ Zemyla ziman zyoung_ sivoais pygospa Tene saiam_ hiredman aaronm04 burp M-ou-se mitu yac SuperTux88 Cerise stvc maw Eiam harski Xe coyotebush Preyer ByronJohnson lahwran horlicks_ Athas ChristianS monochrom sunnymilk devi magicman hodapp kini sebleblanc hpc sabalaba cYmen mt mikedanese acharm AncientPC ninzine tomprince wtw shachaf DenSchub Guest85510 jakutis Eldrad lemmih pingu sephiap yrashk ggherdov ehamberg cojy_)
01:35:38 --- names: list (Raynos lohkey bkolera andrew__n ocharles_ jfokkan bcarrell Erstarrung bjornars1 xxx zxtx tomphreek Rembane Rastus_Vernon tazjin S11001001 twopoint718 dan64 atomi Ke Starfire _klm jabbslad_ RasmusWL gridaphobe RayNbow`TU valdyn Paks Chobbes mjo martinbmadsen asjo eL_Bart0 bbee ilmig rudi_s mpw lattenwald fugyk bijumon SwashBuckla brennie nisstyre joeyh mlen plhk cods mmaruseacph2 tdammers Dtgr mrd tuv pharpend|away Belgarion0 ninegrid iulian zbrown mads- ft)
01:35:38 --- names: list (spindas Jaak bvad zq eamelink tjbp cpa_ paz__ heaumer PHO dawik deni mortberg gargawel rabisg kloeri relrod froztbyte lf94 stomp koomi igniting ad ndeine pdxleif swen rieper nitrix padre_angolano natte eyem_ KitC BlakeRain foolie tomjaguarpaw sternenseemann pranz rseymour vladan Factionwars theorbtwo kakos fionnan cjay aristid thoradam jstolarek int-e ion dowski_ machineslearn thoughtpolice knyppeldynan aleator_2 aleator_1 marens TDJACR GGMethos zomg)
01:35:38 --- names: list (hanDerPeder sohum LordDeath BillyIII bydo SegFaultAX LeaChim Sornaensis obiwahn gseitz kipras monty avn oberstein Spockz dp_wiz lokydor fergusnoble peddie dkua Jonno_FTW petantik jkarni jix Heero JonasH__ NemesisD emmanueloga idnar shelling__ julienXX Xorlev DigitalKiwi jophish Fuuzetsu mpickering sajith dmwit notdan aleator davl slasktask rs0 kgadek wto helgar fredsir senseibaka dpn` oherrala mami kosmikus mjrosenb statusfailed kazawore_ dabukalam zeroskil1or)
01:35:38 --- names: list (seanparsons hellschreiber integral Walther zymurgy kwantam felixsch Ornedan pfoetchen killtheliterate alem0lars lachenmayer myme jlouis ahf isomorphismes arkeet carter scopedTV otterdam `0660 jlyndon jrp6 ThreeOfEight fmapE kshannon schlumpi adamse Hafydd tekacs alang Razz biio Boreeas zebr tych0 osfameron howard s_e kragniz tero- aupo arch_ edran_ @ChanServ Atlanis Deewiant Ulrar cross ClaudiusMaximus mp callumacrae ReinH banjiewen Heffalump u_quark1 ckw)
01:35:38 --- names: list (Watcher7_ albertid raek Th0mas orzo Guest37394 majoh mikeplus64 xaimus f_x_ Mandus KaneTW WSergio Chousuke opqdonut elgot heikkih IbnFirnas Uritomi2 bartavelle [swift] ChongLi Intensity asm89 qz monsieurp mendez_ anastas xnyhps GaveUp cynick naudiz pmade joehillen joshc Jello_Raptor FireFly joeytwiddle gdsx angryzor brolin_empey annulus tomaw posco tromp xian cYmen_ numberten mattp|spurs dicioccio sbauer322 CindyLinz thebnq cscorley stbuehler sunnavy gtklocker)
01:35:38 --- names: list (yeltzooo9 fractalcat adlan shmookey1 Ptival hsyl20 liste AshyIsMe nikola gmcintire kennyp yukonjack phadej sujeet apo gbarboza davean betawaffle Clint edwtjo bcoppens niluje ggreg jayne jludwig Nanar amontez sagelywizard d-snp geal DanZimm noplamodo mechairo` dredozubov eagleflo rtl_ metaf5 seliopou Klumben edk Jaxan Nickeeh freusque serutsubi zenzike kvalle spdionis dilinger bolmar cowtown alpounet Baughn arianvp aseidl absence comboy Forkk sweenzor)
01:35:38 --- names: list (carter_cloud zero7 incomprehensibly milli acfoltzer neptunepink wolf_mozart cjwelborn Cr8 Hugglesworth wjm mikeizbicki agrif geekosaur Guest60360 Enigmagic tomku meretrix waxjar wenzowski si14 gnusosa mikel blast_hardcheese bigs darkowlzz|afk jackhill sdressel zalami ryantm iross karls frontendloader Paprikachu Sqt tumdedum fall_ poga devJunk mathu jacksnipe RustyShackleford Guest48087 tolt jcurbo bafbomb_ davesilva lyddonb sm jokra Guest90609 IanKelling)
01:35:38 --- names: list (defanor eikke jvd nathanic psacrifice Blkt cin codehero raid brisbin ircbrowse nrw lpaste DanToml dqd Brando753 japesinator timothyh HylianSavior _1126 RageD uber bernalex usr StoneToad brent80_plow gmaslov Axman6 bind yminsky jzl nakal abbe mudphone haasn konne_ lambdahands mbrcknl edwardk andreass_ hyPiRion zso__ SLi flori_ lfp__ Ferdirand Saizan hegge Haskellfant drone- skarn_ dustinm- nesqi PotatoGim zyla Ring0` bob_twinkles _ikke_ fold turinturambar _di)
01:35:38 --- names: list (suvash_away ricardo82 ruukasu anoe enojelly adnap Cathy agam malglim lyxia c-rog mero Flaeme TheMoonMaster MK_FG thomassgn Igloo e4x averell pederindi solirc pieter_ etrepum bdha simon___ Fuco irishsultan JPohlman1 DustyDingo WarzoneCommand dschoepe gpampara Ankhers enomies bennyklo1z optocoupler astocko ackthet stass pii glowcoil cmn kriwil srcerer Yawgmoth bennyklotz Adios_ jlind capisce ggVGc certainty amiller Pucilowski_ sLite_ Desoxy_ McManiaC quaestor)
01:35:38 --- names: list (Fylwind inuoppai dju kevin1024 linduxed Korri LQYMGT liyang voidzero ErichKeane efm tromp_ Nik05 frogpunc sbrg Tiktalik Philonous dxld nmontecc)
01:35:55 <bergmark> solatis: sounds reasonable
01:40:01 <solatis> so apparently I need to either use Maybe and handle the error "later", or use Monoid and provide the error-handling primitives there ?
01:40:01 <solatis> am I interpreting this correctly?
01:40:01 <bennofs> solatis: yes
01:40:01 <solatis> ok awesome
01:40:01 <solatis> then I solved my own question
01:40:01 <statusfailed> Dumb question: how do I divide quantities of type "Data.Fixed"? (for purposes of this question assume "Fixed Centi")
01:40:36 <pavonia> statusfailed: (/)?
01:41:50 <statusfailed> pavonia: Ah I think I'm missing a "HasResolution" instance somehow
01:41:50 <statusfailed> > 1.0 :: Fixed Centi
01:41:51 <lambdabot>      Ambiguous occurrence ‘Fixed’
01:41:51 <lambdabot>      It could refer to either ‘Data.Fixed.Fixed’,
01:41:51 <lambdabot>                               imported from ‘Data.Fixed’ at L.hs:83:1-17
01:41:57 <bennofs> @more
01:42:05 <statusfailed> > 1.0 :: Data.Fixed.Fixed Centi
01:42:07 <lambdabot>      No instance for (HasResolution (Data.Fixed.Fixed E2))
01:42:07 <lambdabot>        arising from the literal ‘1.0’
01:42:07 <lambdabot>      In the expression: 1.0 :: Data.Fixed.Fixed Centi
01:42:18 <statusfailed> oh wait
01:42:23 <statusfailed> > 100 :: Data.Fixed.Fixed Centi
01:42:23 <pavonia> Err, why  Fixed Centi and not just Centi?
01:42:24 <lambdabot>      No instance for (HasResolution (Data.Fixed.Fixed E2))
01:42:24 <lambdabot>        arising from the literal ‘100’
01:42:24 <lambdabot>      In the expression: 100 :: Data.Fixed.Fixed Centi
01:42:32 <statusfailed> pavonia: because I'm an idiot
01:42:43 <bennofs> > 1 / 2 :: Centi
01:42:44 <lambdabot>  0.50
01:42:45 <statusfailed> thanks :-)
01:43:13 * hackagebot libconfig 0.2.0.0 - Haskell bindings to libconfig  http://hackage.haskell.org/package/libconfig-0.2.0.0 (peddie)
01:43:35 <statusfailed> relatedly, how does haskell read literals of fractional numbers?
01:43:43 <statusfailed> turns them into a Rational somehow?
01:44:14 <arkeet> :t 1.2345
01:44:15 <lambdabot> Fractional a => a
01:44:31 <arkeet> it turns this into something like fromRational (12345 % 10000), I beileve.
01:44:58 <statusfailed> OK, that makes sense
01:45:03 <statusfailed> thanks :-)
01:45:14 <arkeet> what does the Report say
01:45:52 <arkeet> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-240003.2
01:46:18 <statusfailed> seems to say the same thing
01:46:22 <arkeet> mhm
01:46:34 <arkeet> it's not so explicit about the numerator and denominator
01:46:37 <statusfailed> bennofs, pavonia: thanks again btw!
01:46:50 <pavonia> No problem
01:46:58 <statusfailed> arkeet: yeah, I think it's implied in ", a floating literal stands for
01:46:59 <statusfailed> an application of fromRational to a value of type Rational (that is, Ratio Integer)."
01:48:49 <latk> I've been playing around with opaleye, and have run into a problem. When using tuples, as in the tutorial, to generate insert sql, all is fine. When I try and use a record type however, it doesn't work. For example: http://lpaste.net/131401. Any ideas how I can fix this ?
01:49:26 <latk> I get some error " No instance for (Data.String.IsString (Column PGText))". This doesn't happen if my record type uses only Ints.
01:51:04 <mauke> latk: what's the actual error message?
01:51:32 <latk> mauke: http://lpaste.net/131430
01:53:50 <latk> It seems strange, because it all works if I remove the "name" field of the record.
01:55:15 <mauke> not strange to me
01:55:21 <mauke> Column a has a Num instance
01:55:22 <latk> Hm actually now that I look again, the tutorial only uses Ints. So I must have to convert it some how.
01:55:34 <latk> if it is a PGText
01:56:33 <latk> Yep and there is a function pgStrictText that does exactly that. doh.
01:57:24 <mauke> the tutorial doesn't use Ints
01:57:50 <latk> Ah, it uses floats.
01:57:58 <latk> and ints
01:58:03 <latk> https://github.com/tomjaguarpaw/haskell-opaleye/blob/master/Doc/Tutorial/TutorialManipulation.lhs
01:59:24 <mauke> where?
02:00:19 <k0ral> how would you pretty print multiple aligned columns with wl-pprint ? "column1 <+> align column2" doesn't align the heads of the columns, it starts column2 from the last row of column1...
02:00:45 <mauke> as far as I can see, it uses Column PGInt4 and Column PGFloat8, not Int or Double
02:02:30 <latk> mauke: I'm talking about the haskell types.
02:02:40 <mauke> so am I
02:03:33 <mauke> are you aware that numeric literals are overloaded?
02:03:38 <mauke> i.e. 2 is not an Int
02:03:42 <latk> mauke: Huh actually you are right.
02:04:02 <latk> I assumed there was some kind of automatic conversion to the pgtypes
02:04:09 <mauke> :t 2
02:04:10 <lambdabot> Num a => a
02:04:14 <latk> everything makes more sense now
02:04:19 <mauke> yay
02:08:14 * hackagebot FontyFruity 0.5.1 - A true type file format loader  http://hackage.haskell.org/package/FontyFruity-0.5.1 (VincentBerthoux)
02:13:14 * hackagebot JuicyPixels 3.2.4 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.2.4 (VincentBerthoux)
02:13:48 <jle`> have you ever made an abstraciton/interface in a way that you can't tell if it's extremely smart or extremely awful?
02:18:14 * hackagebot FontyFruity 0.5.1.1 - A true type file format loader  http://hackage.haskell.org/package/FontyFruity-0.5.1.1 (VincentBerthoux)
02:20:06 <ppfs> Hi
02:21:20 <ppfs> The pastepipe script doesn't allow to upload a private snippet, so I changed it to do so http://lpaste.net/38936481288421376 . Is there a better way to do it?
02:21:43 <ppfs> Now it works, but the code doesn't really look good
02:23:03 <jle`> ppfs: anything in particular you don't like? :)
02:23:34 <jle`> on 116 you can use patternmatching, let (ppx,ppy) = mkPrivatePair ...
02:23:48 <jle`> in .. ppx ++ ":" ++ ppy
02:24:17 <jle`> i would probably just put it in a where declaration because you know it before you have to do any IO
02:24:35 <ppfs> jle`: Let me try that
02:25:10 <jle`> you can use guards in mkPrivatePair, line 95
02:25:37 <jle`> mkPrivatePair conf | private conf = ("private","Private")   ... ; ... | otherwise = ...
02:25:56 <jle`> honestly though there isn't anything that really stands out as ugly or bad :)
02:26:47 <jle`> line 118: return . fromJust . paruseUI $ uri conf  ... we tend to not like to use multiple $'s
02:26:56 <jle`> also fromJust is a little scary
02:27:16 <ppfs> jle`: I just added the private option, the rest is not from me
02:27:36 <jle`> you can use a case statement if you want to do something to handle the Nothing case, or you can use forM if you wanted to ignore the Nothing case
02:27:48 <jle`> oh nvm it's a return, you can't use forM
02:28:12 <jle`> what private option do you mean?
02:28:14 * hackagebot svg-tree 0.3 - SVG file loader and serializer  http://hackage.haskell.org/package/svg-tree-0.3 (VincentBerthoux)
02:29:21 <ppfs> jle`: pastepipe doesn't allow to post a snippet as private
02:29:45 <ppfs> jle`: I wanted to be able to do that, so I just added the corresponding option
02:29:45 <jle`> oh. what are you asking then?
02:30:12 <jle`> what lines?
02:30:26 <ppfs> jle`: Well, you pretty much answered
02:30:40 <jle`> mk :)
02:32:11 <paolino> is it right that viewpatterns bring some case expressions at pattern matching level ?
02:33:12 <mauke> er, what?
02:34:37 <ppfs> jle`: Do you think I could send try to give them this version http://lpaste.net/7818085701408260096 (added the pattern match + the where (how to indent that ?)) ?
02:34:56 <ppfs> jle`: And thank you for the help
02:36:02 <ppfs> s/send//
02:36:23 <ysr> I am trying to understand how "foldr1 (const id)" evaluates to last element of a list
02:36:59 <mauke> @unpl const id
02:37:00 <lambdabot> (\ _ b -> b)
02:37:30 <ysr> :t const
02:37:31 <lambdabot> a -> b -> a
02:37:34 <mauke> > foldr1 f [a, b, c, d]
02:37:36 <lambdabot>  f a (f b (f c d))
02:37:45 <ysr> :t id
02:37:46 <mauke> our f always returns its second argument
02:37:46 <lambdabot> a -> a
02:38:14 * hackagebot rasterific-svg 0.2 - SVG renderer based on Rasterific.  http://hackage.haskell.org/package/rasterific-svg-0.2 (VincentBerthoux)
02:38:27 <ysr> what does id function do in this case?
02:39:12 <mauke> const id x y  =  (\a _ -> a) id x y  =  (\_ -> id) x y  =  id y  =  (\a -> a) y  =  y
02:39:48 <paolino> mauke, I make up an example
02:40:05 <jle`> i would indent the do block 4 spaces, indent the "where" two spaces, and indent the (pp1...) four spaces
02:40:11 <jle`> i just sort of stick with what i know :3
02:42:55 <ysr> mauke, ohh, const id is like reversed cons
02:42:59 <ysr> *const*
02:43:05 <mauke> right
02:43:10 <mauke> const id == flip const
02:43:19 <ppfs> jle`: Perfect, thank you!
02:45:07 <jle`> np!
02:53:15 * hackagebot asciidiagram 1.1 - Pretty rendering of Ascii diagram into svg or png.  http://hackage.haskell.org/package/asciidiagram-1.1 (VincentBerthoux)
02:53:22 <ysr> When a write a function composition, will it get reduced to single function in compilation time, or will it be evaluated at run time?
02:55:10 <haasn> ysr: That's a difficult question to answer, partly because it's not very well-defined
02:55:50 <haasn> GHC will inline many things, such as the definition of (.), when it can. So it *can* optimize them as if they were part of the same function body. But that's also not always true
02:56:06 <haasn> And it also depends on what kind of optimizations you're looking for (rules?)
02:58:10 <ysr> for example, if I define flippedconst = const id , will it get turned to flippedconst = (\y -> \x -> x) in compile time or will compiler call const function with first argument of id function in runtime
02:58:57 <haasn> I think the more important question is: What difference would it make?
02:59:51 <ysr> run-time performance I guess
03:00:26 <haasn> If you're ever worried about a function like that slowing your code down, you can benchmark both versions to find out
03:02:14 <haasn> (but to be less pedantic: GHC inlines small function bodies where it can. You can also check -ddump-simpl in order to see one GHC intermediate form that happens after some number of optimizations)
03:02:25 <haasn> (You should also probably enable optimizations if you're worried about run-time performance)
03:02:53 <nurupo> how can i convert [[Char]] to Vector Vector Char easily?
03:03:39 <ysr> sure, I was just wondering. For example, let x be a very complicated but a pure function. if program main is main = putStr $ x 5, compiler could just calculate x 5 and doesnt even need to include the function in final executable
03:04:08 <haasn> ysr: There's no way the compiler can do that for sufficiently complicated ‘x’
03:04:11 <haasn> (halting problem)
03:04:11 <tempname11_> nurupo: fromList . map fromList ?
03:04:28 <haasn> ysr: so you have to draw the line somewhere. I'm not sure where GHC draws the line
03:05:02 <paolino> mauke, https://gist.github.com/paolino/827d3e14a11fb20671d6
03:05:12 <nurupo> tempname11_: aha! that's easier than i expected, thanks :)
03:05:21 <tempname11_> Also you might want to use ByteString instead of Vector Char
03:05:49 <jle`> or Text :)
03:06:42 <haasn> ysr: https://www.reddit.com/r/haskell/comments/1kpu1h/can_haskell_programs_be_compiled_such_that_the/ this may be relevant
03:06:50 <mauke> paolino: why does 7 become 4?
03:07:31 <paolino> because, I documented it wrong
03:09:45 <paolino> btw, I don't know if I got the point, I took it from the real code, hoping it explains the view pattern advantage
03:12:45 <McManiaC> is there a way to safely "lift" a "String -> String" function to "Text -> Text" ?
03:12:53 <McManiaC> or should i just use Text.unpack/pack
03:13:30 <paolino> without the viewpatterns I couldn't match the Just and I would have to put the second match inside the first match with a case, is it right ?
03:17:18 <nurupo> also, any way to split a Sting into a list of N strings K characters each without writing a separate function for that? was thinking about using `iterate`, but it doesn't seem to do what i need
03:17:49 <jle`> nurupo: this is the commonly requested "chunksOf" function
03:18:15 <paolino> Data.List.Split
03:19:55 <nurupo> oh, splitEvery K !! N
03:20:29 <paolino> good exercise too implement it
03:20:51 <paolino> :t unfoldr
03:20:53 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
03:22:10 <nurupo> that's what i started doing, with splitAt and a counter variable
03:22:12 <jle`> i might be missing something very obvious but is there any reason why MVar/Chan aren't Functors
03:23:10 <paolino> because operations are inside IO
03:24:16 <tempname11_> jle`: how would you writeChan to an fmapped Chan?
03:24:22 <ysr> How does (+) . const 1 work? (+) takes 2 arguments bust const 1 returns 1 argument
03:24:28 <jle`> oh it's the putting. i see. thanks :)
03:24:37 <jle`> ysr: everything takes one argument in haskell :)
03:24:50 <jle`> if it helps, expand out the definitions
03:24:54 <jle`> @src (.)
03:24:54 <lambdabot> (f . g) x = f (g x)
03:25:03 <paolino> :t (+) . const 1
03:25:05 <lambdabot> Num a => b -> a -> a
03:25:10 <jle`> ((+) . const 1) x = ....?
03:25:14 <solatis> to elaborate, everything in haskell takes one argument, and returns a function that takes one more argument
03:25:28 <jle`> (not everything returns a function :) )
03:25:33 <solatis> ok, true
03:25:45 <jle`> from (f . g) x, we say that f is (+) and g is const 1
03:26:03 <jle`> so that's \x -> (+) (const 1 x)
03:26:34 <jle`> which is \x -> (+) 1
03:26:45 <jle`> which is const ((+) 1)
03:29:04 <ysr> ok, so it is just, \x -> \y -> x + 1
03:29:56 <paolino> the ignored arg is the first
03:30:48 <paolino> :t add
03:30:50 <lambdabot>     Not in scope: ‘add’
03:30:50 <lambdabot>     Perhaps you meant one of these:
03:30:50 <lambdabot>       ‘and’ (imported from Data.List), ‘odd’ (imported from Prelude)
03:31:19 <paolino> :t (-)
03:31:21 <lambdabot> Num a => a -> a -> a
03:31:49 <paolino> negatively biased language
03:32:43 <ysr> (+) = \x -> \y -> x + y ; const = \x -> \y -> x ; const 1 = \y -> 1 ; (+) . (const 1) = \x -> \y -> 1 + y
03:32:55 <ysr> ohh, I guess I am getting it now :)
03:34:09 <nurupo> is there a random access data structure, similar to Data.Vector, in Haskell?
03:34:57 <paolino> access is reading ?
03:35:04 <nurupo> yes
03:35:13 <paolino> Data.Array
03:35:34 <jle`> why not Data.Vector?
03:35:55 <EvanR_> not everything takes one argument
03:36:03 <EvanR_> just functions
03:36:13 <paolino> well if similar is not equal
03:36:32 <EvanR_> nurupo: there is Data.Vector
03:37:05 <nurupo> standard packages only
03:37:32 <ibid__> asked for something similar to Data.Vector, answered Data.Vector. how strange.
03:37:48 <Rembane> That is very similar.
03:37:51 <nurupo> heh
03:38:14 <EvanR_> as similar as possible
03:38:16 <paolino> the "in haskell" was misleading
03:39:16 <haasn> clearly “in Haskell” here means “part of the Haskell specification” = “standard packages only” :p
03:39:29 <paolino> point free
03:42:50 <paolino> :t foldr
03:42:51 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
03:45:11 <paolino> :t foldMap
03:45:13 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
03:52:49 <Myrl-chan> Hi guys, is it preferable to use a sandbox when using cabal?
03:53:09 <Myrl-chan> (and why)
03:55:07 <Rembane> Myrl-chan: I prefer it, because no matter what I do I wont mess upp my globally installed packages.
03:55:59 <Myrl-chan> Rembane: Globally installed packages?
03:56:13 <Myrl-chan> In what sense, other cabal install or your package manager's packages?
03:57:17 <bergmark> Myrl-chan: i use sandboxes for everything
03:57:55 <bergmark> Myrl-chan: having global or user level packages will lead to conflicts sooner or later
03:58:03 <Myrl-chan> bergmark: I see.
03:58:27 <bergmark> e.g. i have a separate sandbox for each executable i install, and add each one to my PATH
03:58:27 <Rembane> Myrl-chan: Both. I have for instance Pandoc installed, and I never remember if I install it through cabal or pacman. :)
03:58:47 <Myrl-chan> Rembane: Hahahaha.
03:59:24 <Rembane> Myrl-chan: And regardless of which method I install it with, I don't want it to break when I do hacking on other stuff. :)
03:59:32 <Myrl-chan> Also, how do sandboxes work? Do they only work for your current directory or something?
03:59:53 <bergmark> Myrl-chan: that's the default behavior, but you can use them from other places as well if you pass flags to cabal
04:00:07 <Myrl-chan> I see.
04:00:40 <bergmark> i have a wrapper script that uses one sandbox per git branch and puts them in ~/.sandboxes/path-to-project/branch
04:02:26 <ysr> I wrote myLength = foldr ((+) . (const 1)) 0 in python http://lpaste.net/131432
04:04:54 <k0ral> using xml-conduit, is there a way to parse tags without enforcing any order between them ?
04:05:12 <Myrl-chan> ysr: Hahaha, implementing parts of a language in another language is always fun.
04:06:17 <Myrl-chan> ysr: I'm doing the same thing in Lua. I plan on including type safety.
04:09:15 <lorefyr> hi everyone
04:09:22 <bergmark> .o/
04:10:06 <paolino> :t fst . last . zip [0..]
04:10:07 <lambdabot> (Enum c, Num c) => [b] -> c
04:14:58 <frerich> ysr: You could translate it even more literally by exploiting that (to a large degree) 'f = \x -> x' is equivalent to 'f = lambda x: x' in Python.
04:15:29 <frerich> ysr: E.g. you can define 'compose = lambda f: lambda g: lambda x: f(g(x))' or 'const = lambda x: lambda _: x'
04:16:02 <frerich> ysr: This is also closer to Haskell since Python has no lambda functions but only lambda expressions (just like Haskell, which has only expressions)
04:19:19 <brbblnch> Is it possible to implement operator precedence without any other mean than simply defining the operators ?
04:20:15 <paolino> there is infixl and infixr keywords
04:21:05 <paolino> statements
04:22:26 <brbblnch> paolino: Oh, yeah, thanks!
04:26:04 <Anon25502> Hi everyone, got a quick question on creating a list of fibonacci numbers.
04:26:23 <Rembane> Anon25502: Shoot!
04:26:38 <paolino> Poor Fibonacci
04:27:02 <Rembane> paolino: He's already dead, can't get much worse.
04:27:16 <Anon25502> I wrote this little snippet http://lpaste.net/5409666014034001920
04:27:28 <paolino> we don't know
04:27:39 <Anon25502> I assumed that because of laziness, it would work, however, the programm will not finish
04:27:52 <Anon25502> If I do give an upper border, it does
04:29:27 <paolino> the program is fibList ?
04:29:40 <Anon25502> Yes
04:30:09 <Anon25502> I thought I could basically create an infinite list of fibonacci numbers to use in fibListUpTo
04:31:12 <paolino> [1..] is infinite
04:32:43 <paolino> so fibList is infinite
04:32:54 <paolino> and fibListUpTo
04:32:58 <nshepperd_> fibListUpTo n will never reach the list terminator because it doesn't "know" that there aren't numbers later in fibList < n
04:33:24 <paolino> x < n is a filter
04:33:49 <Anon25502> Oh ok
04:34:01 <Anon25502> so filters in general won't work on infinite lists?
04:34:01 <paolino> > take 100 [1..]
04:34:03 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
04:34:03 <nshepperd_> fibListUpTo 6 = [1, 2, 3, 5, ⊥]
04:34:25 <nshepperd_> er, fibListUpTo 6 = 1:2:3:5:⊥ rather
04:34:58 <statusfailed> Is there a nice way to parse JSON data with aeson where numbers have been encoded as strings? e.g.: {"nums": ["1", "2"]} ?
04:35:04 <nshepperd_> Anon25502: filters "work" but they won't give you a finite result
04:35:14 <paolino> Anon25502, filters work, but they don't make them finite
04:35:22 <paolino> ops
04:35:26 <nshepperd_> heh
04:36:01 <Anon25502> Ok that explains it, thank you very much
04:37:44 <Anon25502> Is there a way to make fibListUpTo return a finite list in this scenario?
04:37:53 <paolino> use take
04:38:17 <paolino> :t take
04:38:18 <lambdabot> Int -> [a] -> [a]
04:38:21 <ClaudiusMaximus> :t takeWhile
04:38:23 <lambdabot> (a -> Bool) -> [a] -> [a]
04:38:40 <ysr> this is "myLength = foldr ((+) . const 1) 0" in Python using lambdas http://lpaste.net/131433
04:38:53 <k0ral> let me ask a more generic question: how would you use Parsec to parse multiple elements (of distinct type) in any order ?
04:39:07 <Anon25502> Alright, thank you.
04:39:10 <brbblnch> /quit/quit
04:39:11 <nshepperd_> Anon25502: yes, you want a takeWhile
04:44:20 <paolino> k0ral, how you store a list of different types ?
04:44:37 <paolino> (values)
04:46:51 <ClaudiusMaximus> i guess with a sum type wrapper - perhaps something like  p = many $ choice [ Left <$> try l, Right <$> r ]
04:50:08 <ronh_z> > filter even [0..]
04:50:09 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
04:53:15 <k0ral> paolino: as an ADT
04:57:23 <k0ral> paolino: I think this is impossible, the way Parsec works is inherently sequential, and I can't see a simple way to encode "parse this and that, in whichever order"
04:57:41 <paolino> So, it's ClaudiusMaximus answer
04:58:05 <paolino> where Left and Right are your sum type constructors
04:58:31 <safinaskar> parsec question. is "try" neccessary in this code? http://paste.debian.net/168791/
04:58:39 <k0ral> ClaudiusMaximus: that doesn't scale well with the number of distinct types
04:58:50 <safinaskar> i want to parse expressions "a + b" and "a"
04:59:03 <k0ral> also, you want each element to appear exactly once
05:01:08 <nshepperd_> k0ral: I imagine it's something like "do x1 <- parse any of the things; x2 <- parse any except x1; ... ; xn <- parse final thing ; wrangle x1..xn into a structure"
05:01:32 <k0ral> nshepperd_: that's the idea, but it's very tedious to actually write it
05:01:43 <k0ral> and that's what I think Parsec isn't the right tool for this
05:01:48 <k0ral> s/what/why
05:03:32 <k0ral> the question is: is there a way to design a monad such that behavior is encoded by "do x1 <- parseType1; x2 <- parseType2; ...; xn <- parseTypeN; wrangle x1..xn into a structure" ?
05:03:57 <k0ral> and the monad would automatically do the tedious work
05:04:52 <k0ral> x1 >>= x2 = "parse x1 or x2; then, if x1 was found, parse x2, else if x2 was found, parse x1; otherwise, fail"
05:05:11 <nshepperd_> half the difficulty is that your items have different types
05:05:52 <nshepperd_> you could instead make the subparser return a function that puts the item into the right spot in the ADT
05:06:35 <qegrhet> hey
05:06:49 <nshepperd_> ie. data Foo = { x :: Bar, y :: Baz }, instead of returning x' :: Bar directly, return (\foo -> foo {x = x'}) :: Foo -> Foo
05:06:55 <paolino> a lens
05:07:37 <nshepperd_> or even Endo of that
05:09:53 <safinaskar> parsec question. is "try" neccessary in this code? http://paste.debian.net/168791/
05:09:54 <nshepperd_> then you can feasibly write 'parseInAnyOrder :: [Parser a] -> Parser [a]' and 'do setters <- parseInAnyOrder [x1..xn]; appEndo (fold setters) Foo{}'
05:10:05 <safinaskar> please, answer, i see you know parsec here :)
05:10:47 <nshepperd_> also ops, quetzakubica1 is flapping?
05:11:13 <paolino> :t flapping
05:11:14 <lambdabot>     Not in scope: ‘flapping’
05:11:14 <lambdabot>     Perhaps you meant one of these:
05:11:14 <lambdabot>       ‘lmapping’ (imported from Control.Lens),
05:12:24 <nshepperd_> safinaskar: 'try' is necessary exactly when you need more than one token of lookahead
05:14:36 <nshepperd_> safinaskar: since both sides here start with iIdentifier, it looks like yes -- you won't know whether you're in the left or right branch until you've parsed an entire identifier and then the presence or absence of the '+'
05:18:47 <haasn> ‘try’ is never strictly necessary
05:18:52 <haasn> But it's often the most elegant solution
05:19:20 <k0ral> nshepperd_: thank you for the analysis with the Endo, that's interesting, I'll look into that
05:20:25 <nshepperd_> right, you could of course rewrite the expression into an iIdentifier followed by an optional '+ iIdentifier'
05:21:07 <latk> What do people tend to use for logging? Looks like there are a few options.
05:22:27 <latk> I would be looking to do the logging from inside a conduit, if that makes a difference.
05:22:51 <safinaskar> parsec docs here https://web.archive.org/web/20140529211116/http://legacy.cs.uu.nl/daan/download/parsec/parsec.html says: "Since adding the try combinator in the right places, using notFollowedBy and checking for reserved words is quite subtle, the ParsecToken module implements all of this complexity for you". so i don't need "try" because i use "Token", right?
05:27:03 <nshepperd_> i don't know
05:28:06 <nshepperd_> I would think that (iIdentifier >> iReservedOp "+") is still two steps of lookahead
05:29:39 <nshepperd_> i mean (iIdentifier >> foo) <|> iIdentifier should take two steps of lookahead unless there's some magic I don't know about
05:30:27 <safinaskar> nshepperd_: you mean ">>="?
05:31:16 <nshepperd_> >>= in general, sure, but here you're just sequencing
05:31:41 <nshepperd_> Parsec.Token seems to just take care of properly parsing identifiers and reserved words themselves
05:32:38 <nshepperd_> anyway, instead of trusting me, you could test it
05:33:41 <safinaskar> nshepperd_: ok, thanks
05:48:22 * hackagebot breve 0.2.0.0 - a url shortener  http://hackage.haskell.org/package/breve-0.2.0.0 (rnhmjoj)
05:52:52 <P4Titan> Hello all, I have a data type where one of the types is Parser (String -> Toke), I want to do deriving Show, but it does not know how to display it. Is there a way to create an instance only for that and use the default Show for the others?
05:54:13 <nshepperd_> instance Show (Parser a) where show _ = "(..)"?
05:54:50 <P4Titan> But my code is data Expr = Parser (String -> Token) | Add Expr Expr ..., 
05:54:52 <nshepperd_> strictly speaking this is abuse of Show
05:55:06 <nshepperd_> oh, right
05:55:08 <P4Titan> Will that still work
05:55:29 <nshepperd_> Parser is the constructor, not a type?
05:55:35 <P4Titan> Yes
05:55:57 <nshepperd_> then you need a similar show instance for functions
05:56:28 <nshepperd_> , or you could just write the Show instance for Expr manually
05:56:30 <P4Titan> When I do Show (String -> Token), it complains about an illegal instance declaration
05:57:37 <nshepperd_> yes, 'Show (String -> Token)' needs FlexibleInstances
05:59:17 <P4Titan> What does that mean
06:01:56 <srhb> P4Titan: That a language extension is required in order ofr that to be legal. {-# LANGUAGE FlexibleInstances #-} at the top of your file will enable it
06:08:36 <haskell857> anyone knows where i can find a simple sudoku with user input written in haskell? 
06:16:01 <quchen> ?google sudoku solver haskell
06:16:02 <lambdabot> https://wiki.haskell.org/Sudoku
06:16:49 <haskell857> quchenbut i´m searching for an interactive game, not a solver
06:19:20 <haskell857> how can I get the user input and use this as a parameter for another function?
06:25:48 <ysr> I remember a saying like "monads are monoids in the category of endofunctors" does anyone remember the context?
06:26:07 <ysr> and, is endofunctors a thing in haskell?
06:26:41 <barrucadu> All Haskell Functors are endofunctors, in the category of Haskell types and functions
06:27:22 <barrucadu> And this is the context: http://james-iry.blogspot.co.uk/2009/05/brief-incomplete-and-mostly-wrong.html
06:48:23 * hackagebot PastePipe 1.8 - CLI for pasting to lpaste.net  http://hackage.haskell.org/package/PastePipe-1.8 (MateuszKowalczyk)
06:48:51 <Fuuzetsu> Uploading dist/PastePipe-1.8.tar.gz...
06:48:51 <Fuuzetsu> Error: dist/PastePipe-1.8.tar.gz: 503 backend read error
06:48:56 <Fuuzetsu> I wonder if that's OK…
06:54:15 <arbelos> I am trying to use Text.Regex. But in a wrong way it seems :/ 
06:54:20 <arbelos> subRegex (mkRegex "hello[\\d]") "hello5" "what"
06:54:57 <Aruro> is it possible to use two cabal sandboxes at the same time? like lets say having installed attoparsec in one and diagrams in another?
06:57:52 <estsauver> So, it seems a little painful to add custom class attributes for example to forms in yesod. Am I missing an easier way?
06:57:57 <estsauver> It seems like this is the easiest way: http://stackoverflow.com/questions/21147570/yesod-custom-divs-and-forms
07:03:01 <byorgey> Aruro: sure, in theory you can pass two --package-db flags to GHC or something like that
07:03:40 <byorgey> I can't actually tell you specific details but I think it should be possible
07:11:09 <arbelos> I guess I'll just write subRegex (mkRegex "hello[0123456789]") "hello5" "what" instead
07:11:25 <Aruro> byorgey: ty
07:11:31 <Aruro> i will try to do that
07:12:12 <Aruro> actually when ghc compiles lest say two packages does it do it in parallel? on different cores?
07:13:23 * hackagebot shake 0.15.1 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.15.1 (NeilMitchell)
07:13:25 <bergmark> Aruro: cabal can do that if the packages don't depend on each other
07:13:45 <bergmark> controlled by --jobs
07:21:45 <carter_cloud> bergmark: where's the code for the build matrix tooling btw?
07:22:45 <bergmark> carter_cloud: https://github.com/hvr/hackage-matrix-builder
07:22:56 <Aruro> bergmark: ty for the help will try t
07:22:57 <Aruro> it
07:23:04 <Godsgift> hello
07:23:16 <bergmark> .o/
07:24:38 <Godsgift> Im a noob to irc any help/suggestions wud be appreciated. Thanks
07:24:57 <arbelos> o/ \o  <-- is that how it works :)
07:25:08 <arbelos> i saw that over at #rest
07:25:20 <MagneticDuck> does anybody have any idea what kind of things I should install to get the "haskell platform" on nix?
07:25:48 <bennofs> MagneticDuck: HP is currently not packaged in Nix afaik
07:26:07 <MagneticDuck> hum.
07:26:34 <MagneticDuck> I guess it doesn't really matter much
07:26:58 <MagneticDuck> since I have to parameretize is in whatever nix build expressions I'm using
07:27:24 <MagneticDuck> parametrize*
07:27:31 <MagneticDuck> parameterize*
07:29:21 <ggVGc> is haskell or ocaml better suited for DSLs that break quite far from the original grammar?
07:30:38 <carter> ggVGc: depends
07:30:44 <hodapp> ggVGc: do you have any examples of such DSLs?
07:33:38 <ggVGc> hodapp, carter>: My goal is to ptototype a language for music composition, where the syntax will be ascii versions of music notation, but the means of composing different musical parts will be normal functional programming(hence I want to base it on haskell or ocaml)
07:33:54 <ggVGc> the syntax for defining musical constructs will be completely custom though
07:34:07 <hodapp> ggVGc: I'm not sure if anything you just said constitutes 'quite far from the original grammar'.
07:34:37 <carter> ggVGc: have you looked at the >=5 different music composition libs in haskell yet?
07:35:43 <ggVGc> carter: yes, and they don't seem at all to be what I am looking for. i.e I would have things like, let melody = ..1..34..5.6.**.xx.*..1.4
07:36:17 <ggVGc> carter: I only looked at hascore and something else though. Which are the others? Do you have a list maybe?
07:36:41 <carter> @google haskell music composition
07:36:43 <lambdabot> http://haskell.cs.yale.edu/?post_type=publication&p=1305
07:36:43 <lambdabot> Title: Grammar-Based Automated Music Composition in Haskell | The Yale Haskell Group
07:37:01 <carter> https://hackage.haskell.org/packages/search?terms=music
07:37:16 <ackthet> is there anything that *isn't* in a haskell library
07:37:24 <carter> probably
07:37:26 <carter> somewhere
07:38:17 <ackthet> one day... i'll find it
07:38:21 <carter> http://opam.ocaml.org/packages/ i dont see any on coaml
07:38:25 <carter> opam
07:38:52 <carter> ggVGc: so it sounds like you're doing a deep embedding
07:39:02 <carter> where you have a custom parser / user syntax
07:39:12 <carter> so its really about what makes the engineering easiest for you
07:39:17 <carter> and how complex that might get to be over time
07:39:36 <statusfailed> Why does cabal complain "cabal: unrecognized 'install' option `--ignore-sandbox'" ? I'm on version 1.22, does that flag exist still?
07:39:52 <carter> statusfailed: what does cabal help install say
07:40:13 <ysr> how can I convert sqrt x to Int?
07:40:39 <carter> floor or ceil
07:40:44 <carter> or round
07:40:49 <statusfailed> carter: nothing in there about that flag, but I did "cabal install cabal", and it hasn't helped
07:41:14 <carter> statusfailed: what about cabal help configure
07:41:22 <carter> statusfailed: you could just mv the sandbox
07:42:09 <statusfailed> carter: I just installed from a different place in the end, but still confused why that flag's missing
07:42:17 <statusfailed> wait; do I want "cabal-install" instead of "cabal" maybe?
07:42:21 <carter> yes
07:42:25 <carter> cabal-install === app
07:42:30 <carter> cabal pkg == lib
07:43:07 <ggVGc> carter: yeah.. basically I want to define "music functions" that have completely custom syntax, and then compose those functions using normal language features.
07:43:08 <ysr> hmm, I cant user sqrt with Ints :/
07:43:16 <carter> ysr: :)
07:43:19 <carter> ysr: 
07:43:25 <carter> @google integer sqrt hackers delight
07:43:27 <lambdabot> http://www.hackersdelight.org/hdcodetxt/isqrt.c.txt
07:43:30 <carter> ysr: bam
07:43:48 <ggVGc> so, how would I do this in haskell? I know ocaml has camlp4/5. What would be the implementation path if I went with haskell?
07:44:29 <carter> ggVGc: 1) dont do surface syntax till you like what the internals can do
07:44:34 <ysr> carter I don't understand :)
07:44:43 <carter> ysr: that code is for integer square root
07:44:50 <carter> easy to translate to haskell
07:45:16 <ysr> you are saying I cant do this by using standard functions?
07:45:32 <carter> i'm saying theres ways
07:45:41 <carter> using either a) quasiquoters or b) parsing 
07:45:46 <haskell857> whats wrong if i get the message Could not find module ‘System.Console.ANSI’?
07:45:46 <hodapp> ggVGc: I'm still not sure why this admits of 'completely custom syntax'.
07:45:56 <carter> oh
07:46:01 <carter> ysr: ohh
07:46:04 <carter> hrmm
07:46:20 <carter> :t (fromIntegral :: Integer -> Double) 
07:46:21 <lambdabot> Integer -> Double
07:46:29 <carter> ysr: you could abuse that :)
07:46:36 <carter> if you want something simple
07:46:43 <bennofs> anyone know why weak pointers behave stragely in GHCi?
07:46:50 <carter> bennofs: share your code
07:46:54 <exio4> @type truncate  . sqrt . fromIntegral
07:46:56 <lambdabot> (Integral c, Integral a) => a -> c
07:47:09 <carter> bennofs: welll... variables stay in scope in ghci :)
07:47:39 <ggVGc> hodapp: well, my syntax might become something like this, https://gist.github.com/676101b92e4032c39745
07:48:06 <ysr> "takeWhile (<= floor sqrt fromIntegral x)" still doesnt work, x is an Int
07:48:11 <ysr> any help?
07:48:24 <lpaste> bennofs pasted “Weak pointer weirdness” at http://lpaste.net/131445
07:48:35 <ggVGc> carter: yeah, absolutely. My first prototype will just be a library for the underlying concepts
07:48:45 <bennofs> carter: see paste. works when compiled, fails with runhaskell / GHCi :main or main
07:49:34 <ysr> what is the simplest way to test if an Int is smaller than square root of another int in haskell
07:49:54 <carter> ysr: compare  the bit shiftness 
07:49:59 <carter> at least for positive ints
07:50:18 <carter> errr
07:50:20 <carter> ysr: ohhhh
07:50:22 <carter> ohhh
07:50:25 <hodapp> ggVGc: get the functionality written, and then worry about syntax.
07:50:34 <carter> ysr: do you want exact or "nearly so"
07:50:52 <mauke> ysr: x*x < y
07:51:03 <bennofs> carter: ah, it's different with -O0 too (there the finalization only happens after last performGC)
07:51:14 <ysr> mauke, I am so stupid :D
07:51:46 <mauke> are you computing primes?
07:51:56 <carter> i was gonna suggest clz# :: Word# -> Word# in ghc-prim
07:52:13 <ggVGc> hodapp: of course. I was just curious if haskell or ocaml lends itself better to this kind of DSL which is basically a chunk of syntax which is completely separate from the host language. I.e say if I wanted to implement a block of python code within haskell/ocaml. Which would bea easier
07:52:24 <carter> ggVGc: ghc has quasiquoters
07:52:27 <carter> which you can do
07:52:29 <carter> for arb syntax
07:52:37 <carter> but you lose things like type errors and stuff :)
07:52:59 <ggVGc> carter: yeah, that is a shame. I was thinking about that. But I don't think type errors will be an issue for this actually.
07:53:01 <bennofs> carter: or leadingZeros from bits-extras :) (clz# was only added in recent GHC, wasn't it?)
07:53:35 <statusfailed> carter: whoops, it was cabal/cabal-install - thanks :)
07:54:43 <ysr> I am computing primes but I am stuck here http://lpaste.net/131446
07:55:38 <haskell857> can anybody tell me whats wrong if i get the message Could not find module ‘System.Console.ANSI’?
07:56:02 <carter> statusfailed: yeah, the naming is annoying
07:56:12 <carter> and theres plans to fix it at some point ... i think
07:57:48 <bennofs> carter: oh, the reason seems to be that a non-optimized version of monadic bind never makes bound values go out of scope. so non-optimized do x <- a; ... will always have x in scope in ..., so x will never be GCed
07:57:48 <ysr> can someone help me out: http://lpaste.net/131446
08:03:18 <lyxia> ysr: (<= truncate (sqrt $ fromIntegral x))
08:18:53 <ggVGc> so, I don't completely feel laziness by default is a good part of haskell, and that maybe explicit laziness would actually be more useful. Does anyone else agree with tjis?
08:33:11 <dfeuer> Cale, so a Maybe-algebra can always be specified by a type and the arguments to `maybe`?
08:37:49 <carter_cloud> ggVGc: depends.  Also there's some work that should land in 7.12 that will allow you to have strict modules with explicit laziness. Hehe
08:38:43 <iron_houzi> Is work being done on handling what people call "cabal-hell"? Does anybody know the current status on this endavour?
08:39:04 <jml> in Emacs, how can I jump to the definition of a Haskell term?
08:39:29 <c_wraith> iron_houzi: it's about 90% solved by cabal sandboxes.
08:39:35 <c_wraith> iron_houzi: err, I meant 80% there
08:40:11 <c_wraith> iron_houzi: 10% needs to be "stop rebuilding everything all the time", and then the remaining 10% is all sorts of QoL stuff.
08:40:19 <iron_houzi> c_wraith: OK, is this a recent change? I remember trying to install and use mutliple pieces of haskell using cabal sandboxes and having problems with dependency collisions.
08:41:05 <c_wraith> iron_houzi: no recent change.  "cabal hell" isn't responsible for "the packages I want to use don't work together"
08:41:07 <iron_houzi> .. it was only pandoc and hackage .. and this was a year ago
08:41:42 <jonh> is there a suggested way to copy a sandbox? or is just copying the directory the way to do it
08:42:00 <iron_houzi> c_wraith: OK. Do you think I was experiencing this problem due to my own ignorance, not using sandboxes correctly?
08:42:10 <catern> dear #haskell, if I wanted to ask a programming-language-theory question, would this be a good channel to ask it in? would there be a better channel?
08:42:37 <lolisa> I think this is a good place.
08:42:46 <c_wraith> iron_houzi: most likely the problem was due to *either* having installed the haskell platform, which breaks quite a lot, or running a version of GHC newer than things were last tested on.
08:42:58 <lolisa> Another good place may be Coq or Hott, there aint a PLT channel AFAIK
08:43:36 <iron_houzi> c_wraith: Ah, OK. I do believe I installed the haskell platform in order to get cabal. Is this not the optimal way to get cabal sandboxes working?
08:43:46 <c_wraith> iron_houzi: unfortunately, the haskell platform installs a bunch of things globally, and globally installed packages are always favored in installs, even when not favoring them would make things work.
08:43:58 <iron_houzi> c_wraith: That makes a lot of sense
08:44:12 <catern> am I right in thinking that memory addresses are ideally alpha-equivalent? if I am right, is there a relationship between that fact and the problems with pointer aliasing, and/or things like the ownership rules in Rust?
08:44:44 <iron_houzi> c_wraith: Do you have any recommendation for how to get cabal sandboxes working without haskell platform?
08:45:11 <c_wraith> iron_houzi: if you're on windows, use minghc these days.  If you're not on windows, just use a binary GHC build for your platform and grab a cabal binary directly.
08:45:13 <hexagoxel> iron_houzi: at the moment -even though ghc-7.10 is released- the safest bet is to use ghc-7.8.4 to install the usual tooling
08:45:21 <iron_houzi> I'm on Arch Linux
08:45:33 <hexagoxel> so you have ghc-7.10 :D
08:45:39 <c_wraith> oh, that's true.  Stick with ghc 7.8.4 for now, for installing stuff. :)
08:46:07 <jonh> being new to haskelll myself, i also suggest hanging back a bit on release ver :)
08:46:24 <c_wraith> iron_houzi: and you can get the cabal binary from https://www.haskell.org/cabal/download.html
08:46:48 <iron_houzi> I have 7.10. Probably from a dependency for the pandoc package. Why should I use 7.8.4 instead?
08:47:12 <c_wraith> 7.10 is very new, and changed a number of things.  Lots of packages haven't updated to work with it yet.
08:48:05 <iron_houzi> I see. Thanks for the help
08:49:53 <KoF_> Any chance anyone is around that is good at finding infinite loops in Haskell? x.x;
08:50:10 <dfeuer> KoF_, it depends.....
08:50:22 <hexagoxel> Debug.Trace.trace is good at finding loops
08:50:25 <c_wraith> KoF_: usually, they're the result of a typo - having something accidentally depend on itself
08:50:50 <dfeuer> @paste
08:50:50 <lambdabot> Haskell pastebin: http://lpaste.net/
08:51:07 <dfeuer> That's one place you can put code you want us to look at.
08:51:38 <c_wraith> KoF_: of course, many other things can be the cause.  If you're an absolute beginner, it's common to see something like fac n = fac n-1 and not realize that's an infinite loop, for example.
08:52:50 <dfeuer> c_wraith, how good are Agda's and Coq's error messages for code that can loop forever?
08:53:24 <c_wraith> dfeuer: haven't actually used them.  All I know is that they report things they can't prove will terminate.
08:53:45 <c_wraith> dfeuer: I know nothing about the form of those reports
08:53:52 <dfeuer> *nod*
08:54:17 <dfeuer> Idris's are not usually useful.
08:54:20 <KoF_> I've been using Haskell for a few years. From what I can tell, the places where it's apparently looping are all places where I've got a really basic recursion that slowly decreases and has a base case.
08:54:27 <dfeuer> But Idris is new.
08:54:55 <dfeuer> KoF_, sometimes, you can rewrite something with combinators to avoid having to do recursion by hand.
08:54:57 <c_wraith> KoF_: is the code small enough to lpaste to us?
08:54:59 <dfeuer> Sometimes, you cannot.
08:55:53 <KoF_> http://lpaste.net/131448
08:56:52 <KoF_> I left out the other cases in evalRule. I've been playing with sticking errors in a bunch of places to figure out where it's actually going, which has been meeting with mixed success.
08:56:52 <dfeuer> KoF_, what are you calling to get it to loop?
08:57:12 <KoF_> The evalRule is where the loop is starting.
08:57:33 <ollef> line 8 looks suspicious
08:57:41 <dfeuer> KoF_, trace is much more commonly used for that.
08:57:51 <dfeuer> Debug.Trace
08:58:10 <KoF_> That's useful - wasn't familiar with that.
08:58:22 <ollef> should probably be (exprs2, univ) = newRulesForUniv cs u
08:58:51 <dfeuer> Ahhhh.... Yes, ollef is right. That is very fishy looking.
08:59:11 <KoF_> Oh, shit, you're right.
08:59:31 * dfeuer kicks Idris for error messages like "idris: Scope error in B !!V 0!!" followed by dumping me to a shell.
08:59:35 <ollef> sometimes you wish there was a non-recursive let :)
09:00:08 <dfeuer> ollef, you could probably make one in Template Haskell, but I've never used that.
09:00:27 <ollef> KoF_: btw, -Wall would have caught that (since u is unused)
09:00:45 <ollef> dfeuer: probably!
09:02:36 <KoF_> Mm, will keep that in mind.
09:03:17 <ysr> if something is Num, is it also a Ord?
09:03:53 <geekosaur> no
09:04:01 <geekosaur> because Complex is Num
09:04:06 <geekosaur> but not Ord
09:04:55 <plvpb> Hi, whats the proper way to 'load' a source file in ghci from a cabal project?
09:05:13 <plvpb> if I just do 'load Main' it complains about dependencies which are installed in the sandbox
09:05:19 <geekosaur> cabal repl
09:05:23 <geekosaur> instead of ghci
09:05:27 <plvpb> ahh ok
09:05:46 <plvpb> another question: is there any good way to debug parsec parsers?
09:05:51 <ysr> how does my primes list look: http://lpaste.net/131449
09:05:54 <c_wraith> sometimes that doesn't work, though...  It loads *all* modules in your package.
09:06:02 <c_wraith> If some of them have compile errors, it doesn't work right.
09:06:09 <c_wraith> In those cases, cabal exec ghci works
09:06:22 <plvpb> ah ok c_wraith 
09:06:55 <plvpb> When I use Debug.Trace (trace) inside my parsec parsers it will only print that 'trace' one time 
09:06:56 <KoF_> Do you know when Haskell decides that something loops infinitely?
09:07:31 <plvpb> Is there a way to step through the parsec parsing process?
09:08:01 <jmcarthur_> with ghc, if i use the NOINLINE unsafePerformIO trick to make a polymorphic global ref, it's going to make one global ref per type used, right? it still won't make more than one? surely it can't guarantee that... for example, what if i use it with several existential types? some of them could actually be the same type, but it would have no way of knowing
09:08:23 <sm> plvpb: https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Utils/Debug.hs#L55 is a more useful trace for parsec
09:08:34 <c_wraith> jmcarthur_: no, it uses the same global ref.  That's what unsafePerformIO + mutable top-level polymorphic refs = unsafeCoerce
09:08:35 <jmcarthur_> i guess each existential type is a whole new type always
09:08:46 <jmcarthur_> oh bah idiot
09:08:48 <c_wraith> err, that's *why*..
09:09:00 <jmcarthur_> not sure what i was thinking there
09:09:22 <jmcarthur_> oh, if there was a *type class* involved, it would make a new ref per type used
09:09:33 <jmcarthur_> but then existentials would be more constrained
09:09:54 <c_wraith> That..  might end up depending on the optimizations used.
09:10:22 <jmcarthur_> i don't know how it could work otherwise
09:11:32 <jmcarthur_> do you have any optimizations in mind that would violate it?
09:12:16 <jmcarthur_> i guess it depends on how the type class is involved. perhaps it supplies the initial value of the ref
09:16:00 <SrPx> Hello, is there any *detailed* explanation of how lazy evaluation takes place? Preferably in Haskell terms and not hieroglyphs (for example, a function "reduce" which lazily evaluates "data Term = Lam Term | Var Int | App Term Term"). :)
09:16:18 <c_wraith> SrPx: have you read ezyang's blog?
09:16:52 <SrPx> No, thanks! :)
09:17:11 <c_wraith> He wrote a long series about GHC internals with lazy evaluation
09:17:46 <c_wraith> SrPx: http://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html is also good
09:18:07 <SrPx> Wait, is this a single person? He certainly posts a lot. I'll look for that series, thank you!! 
09:18:30 <c_wraith> SrPx: ezyang is not only a single person, he's often here.  (though apparently not right now)
09:18:41 <jmcarthur_> SrPx: it's easy to summarize, but there is a lot of variety in the details. in a nutshell, you just store the expression you want to evaluate lazily in an IORef (Either Value Term), and when you need to observe its result you either extract the Value, if it's there, or evaluate the stored Term, store the resulting Value in its place, and return the Value
09:19:23 <plvpb> sm thanks, it looks like an extra argument is needed to printf at line 63? 
09:19:58 <plvpb> sm: when I try to use this function I get an error "printf: argument list ended prematurely"
09:20:16 <sm_> it takes two arguments
09:20:36 <SrPx> But how is "you need to observe its result" defined? Say, evaluating (λ f . f (f (f x))) (λ . f (f (f x))) ...
09:20:51 <SrPx> λ f x . *
09:21:08 <jmcarthur_> SrPx: if you try to write the evaluator, you will just find that you have no choice as to when you really need the result
09:21:33 <plvpb> oh yes, sorry sm_ I made I typo copying the function, it works great :D thanks
09:22:01 <jmcarthur_> SrPx: it depends on what your Value form actually is, what kinds of expressions you are putting in thunks, etc.
09:22:02 <sm_> plvpb: sorry, one argument. np
09:23:02 <sm> example usage: https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Read/JournalReader.hs
09:31:07 <slomo> why is there no newBroadcastChan like there is a newBroadCastTChan? i assume the same problem applies with normal Chan too?
09:31:53 <edwardk> jmcarthur_: if there is a typeclass involved make sure it is a single dictionary with no superclass constraints on it
09:32:42 <athan> n-ary stuff is difficult :(
09:32:58 <jmcarthur_> edwardk: hmm... because it would be some sort of function instead otherwise?
09:33:26 <edwardk> yeah then its a function of the dictionaries it gets fed, and you'll 'recreate the dictionary' over and over
09:33:44 <edwardk> if the dictionary is holding such an ioref of its own it'll be making a new one each time you make the dictionary
09:33:47 <orion> Hi. Is there any practical difference between writing: fromJust $ decode $ x    and: (fromJust . decode) x ? Is one "better" than the other?
09:33:55 <jmcarthur_> i'm going to just find a way not to do this. it's pretty fragile sounding
09:33:57 <MuffettMan> Is there any way to pattern match more than one at a time? Sorry, don't know the terminology, basically something like this : data Color = Red | Blue |Green; someFunction (Red | Blue) = ...; so that I don't have to write the same code for the Red and Blue case?
09:34:38 <MuffettMan> Related question: What would you call each of the colors in that code? I know color is a typeclass, what would you call Blue?
09:34:48 <edwardk> orion: no real difference. one reason to prefer the $ version is that it typechecks in a few more situations involving rank-n types. the (.) version makes it easier to see where you can eliminate arguments though
09:35:00 <jmcarthur_> MuffettMan: Color is an algebraic data type, not a type class
09:35:13 <jmcarthur_> MuffettMan: and Red and Blue are constructors
09:35:21 <jmcarthur_> err... and Green
09:35:48 <edwardk> orion: a $ b $ c $ d $ e = a . b . c . d $ e, though, so you can eliminate all but the right most $ if you like (but this has annoying fixities involved so if a,b,c or d have operators involved, it probably won't work)
09:35:58 <jmcarthur_> MuffettMan: your first question is looking for "or patterns" which we unfortunately don't have in haskell
09:36:06 <MuffettMan> jmcarthur_: Oh okay, thank you, what's an example of a typeclass then?
09:36:20 <sveit> what is the idiomatic way to process a sequence, but with access to previous parts? A specific, simplified example would be a list of tuples, where I would like to select the element in the tuple whose position corresponds to the smallest element in the tuple n-elements back. For example, for n=1, [(1,2),(3,4),(6,5),(7,8)] -> [3,6,8]?
09:36:21 <jmcarthur_> MuffettMan: Num is an example of a common type class
09:36:25 <orion> edwardk: I see. Thanks!
09:36:28 <edwardk> once it is in the latter form its really easy to see that you could eta reduce e if it was the last arg to the function
09:36:31 <sveit> I guess I could do it with a fold, but is there a "better" way?
09:36:38 <jmcarthur_> MuffettMan: class Num a where (+) :: a -> a -> a; ...
09:37:21 <MuffettMan> jmcarthur_: Ah okay, thank you! What would be the best way to get around the lack of an 'or pattern'? Guards?
09:39:09 <jmcarthur_> MuffettMan: you could factor out the right hand side into a separate definition, or if you will be doing this a lot with the same subsets of constructors you could write a separate function to convert your input into something having fewer constructors.
09:40:40 <MuffettMan> Okay, the first option I understand, what do you mean by the second option? Write a function that takes a Color and returns what?
09:41:17 <MagneticDuck> what should I use in ghci to "decompose" a type definition?
09:41:19 <edwardk> MuffettMan: you can write a function like redOrBlue x = x == Red || x == Blue and use a view pattern:    foo (redOrBlue -> True) = ... do something here using that fact. oryou can move the test in foo c | c == Red || c == Blue = ...
09:41:49 <MagneticDuck> type Thing = Int -> String -> Bool
09:41:55 <MagneticDuck> >:decomposetype Thing
09:41:59 <MagneticDuck>   Int -> String -> Bool
09:42:08 <geekosaur> :info ?
09:42:09 <ysr> How does my prime factorization look? http://codereview.stackexchange.com/q/87954/13063
09:42:28 <MagneticDuck> geekosaur: that works thanks
09:42:41 <MuffettMan> edwardk: : That sounds like a good option, that requires the view pattern language extension, correct?
09:42:55 <edwardk> MuffettMan: the former does, yes.
09:43:07 <MagneticDuck> ysr: well my prime factorization algorithm is the fastest in the world -- nobody read the part of the documentation that says it "only works for primes" though
09:44:06 <orion> Does Haskell evaluate guards in order from top to bottom?
09:44:23 <MagneticDuck> orion: yes
09:44:25 <MuffettMan> Thanks for the help, jmcarthur_ and edwardk!
09:44:30 <orion> MagneticDuck: First one wins?
09:44:39 <orion> (The rest are unevaluated?)
09:45:12 <dshad> I've tried install libraries with profiling support but on compilation of tf-random-0.5 complain about lack of System.Random
09:45:17 <dshad> what should I do?
09:47:01 <MagneticDuck> orion: I believe that's how it's done
09:48:42 <sveit> sorry to bump, but i was wondering what is the idiomatic way to process a sequence, but with access to previous parts? A specific, simplified example would be a list of tuples, where I would like to select the element in the tuple whose position corresponds to the smallest element in the tuple n-elements back. For example, for n=1, [(1,2),(3,4),(6,5),(7,8)] -> [3,6,8]?
09:49:21 <sveit> where i just drop the first n elements since there is no "previous" elements to compare to
09:50:40 <arbelos> What regex library is best if I need to work with Data.Text and do pretty trivial search/replace operations?
09:51:16 <jmcarthur_> sveit: i'm trying really hard to understand the question...
09:51:31 <frerich> sveit: A common way to process lists while taking previous elements into account is to use zipWith, but I'm not yet sure whether that's applicable in your case since I have trouble understanding why you'd expect [3,6,8] in that sample.
09:51:36 <arbelos> s/is best/do you recommend perhaps
09:52:16 <jmcarthur_> sveit: just with my vague understanding of your question, i'm tempted to say it's going to involve inits or tails in some way
09:53:29 <sveit> thanks, i will explain! suppose i give you a sequence of pairs of numbers. then i tell you, give me the element of the pair whose position in the pair (0 or 1) corresponds to the position of the smallest element in the previous pair. so my example [(1,2),(3,4),(6,5),(7,8)] -> [3,6,8] works because i must drop (1,2) since there is no "previous" pair, then to choose one of (3,4), i look at the previous one and see (1,2), so 1 is the
09:53:29 <sveit> smaller number, and has position 0, so I choose 3
09:53:52 <sveit> then i look at (6,5), see (3,4) as the previous one, and choose 6 since the smaller (3) has position 0.
09:54:07 <jmcarthur_> ah!
09:54:10 <frerich> Ah
09:54:10 <sveit> but for (7,8), i look at the previous, see (6,5), so 5 is smaller in position 1
09:54:11 <brbblnch> Given a commutative ring having exactly n zero divisors, show that its size is at most (n+1)². 
09:54:18 <jmcarthur_> yeah, something with zipWith like frerich will probably be the way
09:54:27 <jmcarthur_> sveit: here's a starter:
09:54:29 <brbblnch> (oops sorry, wrong chan)
09:54:45 <sveit> but is zipwith efficient in general? what if my structure isn't lazy?
09:54:51 <jmcarthur_> > zip (drop 1 [(1,2),(3,4),(6,5),(7,8)]) [(1,2),(3,4),(6,5),(7,8)]
09:54:52 <lambdabot>  [((3,4),(1,2)),((6,5),(3,4)),((7,8),(6,5))]
09:55:28 <sveit> basically, i'd like to do it in one pass over my data. i know this may be too stringent on haskell, but I'd like a generally efficient solution :)
09:55:39 <jmcarthur_> sveit: if you have something sequence-like, you could always lazily convert it to a lazy, use zipWith on that, then convert back to your original sequence type.
09:55:47 <jmcarthur_> * to a lazy list
09:55:50 <arbelos> brbblnch, out of curiosity; what is the "right" channel for that question? 
09:56:05 <brbblnch> arbelos: ##math!
09:56:10 <arbelos> ah. thx
09:56:17 <arbelos> obviously :)
09:56:38 <brbblnch> arbelos: really cool chan, if you ask enough, they will have to help you eventually
09:56:57 <jmcarthur_> sveit: it's going to be two passes, but if done lazily then under the hood it will basically just be a little extra state as you do something that looks a bit more like just one pass
09:57:17 <arbelos> brbblnch, i'll try next time I get stuck with abstract algebra or cat theory
09:57:36 <sveit> jmcarthur_: can you explain in a bit more detail?
09:57:37 <jmcarthur_> sveit: if you just want two cursors into your original sequence, you could convert it to a lazy list twice, once for each input to zipWith, instead of reusing the same lazy list
09:58:11 <jmcarthur_> sveit: (though you are at the mercy of ghc not to apply common subexpression elimination, which would reintroduce the sharing you would be trying to eliminate)
09:59:42 <sveit> jmcarthur_: thanks! could you explain a bit more about the "something that looks a bit more like just one pass"? and the details of how i could try to prevent ghc introducing sharinig?
09:59:48 <jmcarthur_> sveit: zipWith produces a new list lazily. for each node in the new list, it will visit one node in each input list. it will do this one node at a time in lockstep. if both are actually the same list, that might look like two passes over the list. it kind of is. however, it's not like you traverse the whole list once and then repeat the traversal. you do both traversals at once.
10:00:17 <frerich> sveit: I think something like http://lpaste.net/131451 might be what you want.
10:01:27 <sveit> frerich: it is, thank you! i was just wondering if there was some assurance this strategy was efficient "in general" for, for example, strict datastructures.
10:06:08 <McManiaC> i moved my application to another machine and now it segfaults everytime i shut it down via ^C, any idea why?
10:06:14 <McManiaC> or how i could find out why
10:06:32 <McManiaC> (moved the source code, compiled with ghc 7.8.3 on the new machine)
10:09:21 <monochrom> does it segfault on the old machine?
10:13:06 <McManiaC> monochrom: no
10:13:26 --- mode: ChanServ set +o glguy
10:13:33 <monochrom> is it also GHC 7.8.3 on the old machine?
10:13:38 --- mode: glguy set +b quetzakubica1!*@*$##fix_your_connection
10:13:53 <McManiaC> i think its 7.8.2
10:14:08 <McManiaC> otherwise same OS etc
10:14:39 <akyte> Is there a better library for C parsing than language-c?
10:14:49 <schoppenhauer1> is it possible to tell haskell to garbage-collect more aggressively?
10:15:08 <bennofs> If I have 'data Foo = Foo { readFoo :: IO Int }' vs 'data Bar = Bar { barRef :: IORef Int }', how much memory will Foo take compared to Bar?
10:15:12 <akyte> schoppenhauer1: Set a smaller nursery? 
10:15:15 <bennofs> schoppenhauer1: System.Mem.performGC
10:15:26 <schoppenhauer1> akyte: nursery?
10:15:31 <akyte> bennofs: That's very unsafeperformIO of you
10:15:36 <bennofs> schoppenhauer1: that allows you to manually trigger a GC. 
10:15:41 <bennofs> akyte: it lives in the IO monad
10:16:17 <akyte> It lives in the IO monad, but I think that abusing the IO monad to control internal runtime state is like hiding IO outside of the IO monad.
10:16:18 --- mode: glguy set -o glguy
10:16:39 <akyte> schoppenhauer1: So all memory is allocated into a nursery
10:16:45 <akyte> And that's collected a lot
10:16:46 <McManiaC> akyte: it's fine if he reads foo in IO
10:17:07 <schoppenhauer1> akyte: I just read https://wiki.haskell.org/GHC/Memory_Management, how can I set this nursery?
10:17:08 <bennofs> akyte: oh, were you refering to my Foo/Bar example or to performGC?
10:17:19 <McManiaC> it could just be something like "Foo { readFoo = readIORef myref }"
10:17:21 <akyte> And when objects survive that collection, they're moved to another part of the heap
10:17:34 <akyte> bennofs: performGC
10:18:05 <akyte> schoppenhauer1: I think the parameters are tunable somewhere?
10:18:06 <bennofs> schoppenhauer1: compile with -rtsopts, then run your program with ./foo +RTS --help and it'll give you a list of flags that can be used to tune the RTS behavior
10:18:17 <akyte> bennofs has it
10:18:29 * hackagebot OpenSCAD 0.3.0.0 - ADT wrapper and renderer for OpenSCAD models.  http://hackage.haskell.org/package/OpenSCAD-0.3.0.0 (MikeMeyer)
10:18:31 * hackagebot OpenSCAD 0.3.0.1 - ADT wrapper and renderer for OpenSCAD models.  http://hackage.haskell.org/package/OpenSCAD-0.3.0.1 (MikeMeyer)
10:18:59 <monochrom> bennofs: if I interpret your question literally, they take the same amount of memory: 1 pointer. if I interpret it morally, it compares apples with oranges, yet I know how to make them use the same amount of memory. do you want literally or morally?
10:19:47 <bennofs> monochrom: no, I don't want literally. Assume that Foo and Bar both live on the heap and are not eliminated through inlining
10:20:00 <monochrom> I am not talking about inlining
10:20:35 <monochrom> I already put them (and everything) on the heap.
10:21:23 <bennofs> monochrom: oh. So then let's compare foo x = do ref <- newIORef x; return $ Foo (readIORef x)   and bar x = do ref <- newIORef x; return $ Bar x. How much memory will the result returned by a call to 'foo 0'/'bar 0' take?
10:21:59 <bennofs> Is that question more acurately specified? Maybe I should say: how much memory will foo/bar allocate?
10:22:04 <schoppenhauer1> thx
10:23:56 <monochrom> foo 0 uses more memory on account that it firstly uses as much memory as bar 0 for the IORef and then adds its own "readIORef"
10:29:19 <bennofs> monochrom: according to criterion, they both seem to allocate the same amount of memory
10:30:39 <nolrai66> Well to use bar, you have to call readIORef, and maybe the foo thunk it self is getting optimized away into just a call to readIORef?
10:31:03 <monochrom> you mean one test case uses the same amount of memory. do you know a proof that this test case generalizes to all cases?
10:31:11 <bennofs> I used 'bench "Test2" $ whnfIO $ Test2 <$> newIORef 0' and 'bench "Test1" $ whnfIO $ (Test1 . readIORef <$> newIORef 0)'
10:34:08 <ysr> Can I get a set union of two list using base functions. I need to drop common elements of two lists
10:34:55 <monochrom> set union does not drop common elements. rather, it includes both common elements and uncommon elements.
10:35:08 <monochrom> but look for "union" in Data.List
10:36:01 <Xnuk> Can I turn off ssl verification in Network.TLS?
10:36:20 <Xnuk> when I connect to the server
10:36:41 <glguy> Xnuk: Yes, I can send an example in a moment
10:37:25 <glguy> https://github.com/glguy/irc-core/blob/master/driver/Connection.hs#L88
10:37:32 <nolrai66> ysr: also I think 'delete' does what you want.
10:37:38 <nolrai66> (IIRC)
10:38:13 <Xnuk> glguy: thank you very much!
10:40:06 <gremble> Is there any sort of trick to get the whitespace right? I am currently using vim as an editor working through examples I keep getting parsing errors that I fix by fiddling with the whitespace
10:40:57 <nolrai66> Is vim replacing tabs?
10:40:58 <ion> gremble: :set et sw=2 sts=2, :%retab to get rid of tabs
10:41:35 <lpaste> ysr pasted “Euler 1” at http://lpaste.net/131453
10:41:47 <ysr> does it look correct?
10:42:26 <gremble> Thanks ion
11:02:06 <AndroUser> Hi, Peeps.
11:02:19 <bergmark> .o/
11:04:17 <AndroUser> So, I'm having an interesting issue using Haskell-Vim-Now on GHC 7.10.1. This is not specific to Haskell-Vim-Now, though.
11:05:27 <ysr> I have a [(Int, Int, Int)] How do I sort it according to 3rd element
11:05:50 <hpc> :t sortBy
11:05:52 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
11:05:52 <AndroUser> The issue is that, when I load up some Haskell source in Vim, I get an error message at the bottom saying "Can't parse: /blah/blah/ghc-7.10.1/platformconstants".
11:05:59 <hpc> :t comparing
11:06:00 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
11:06:18 <AndroUser> A Google search suggests that this error message is generated in GHC itself. :-/
11:06:42 <hpc> ysr: sortBy (comparing somethingYouWriteThatGetsTheThirdTupleElement)
11:07:30 <SwashBuc1la> is there an open souce Haskell project that needs contributors/help? I am a beginner, so would ideally like some mentoring
11:08:10 <Clint> SwashBuckla: anything i've uploaded to hackage
11:09:04 <SwashBuckla> example?
11:09:13 <SwashBuckla> (I am not sure how you search by author)
11:09:18 <Clint> SwashBuckla: http://hackage.haskell.org/user/ClintAdams
11:10:59 <ysr> hpc, thanks
11:11:18 <ysr> another question, how can I sort in reverse order
11:11:31 <ysr> do I need to reverse . sort or is there something else for it
11:11:37 <Jeanne-Kamikaze> sortBy ?
11:11:46 <ZyXoas> It makes no sense that GHC can't parse it's own platformconstants. This is a clean GHC and I have zero global packages besides those needed by GHC (I didn't use Haskell platform).
11:11:56 <Jeanne-Kamikaze> :t sortBy
11:11:57 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
11:11:59 <hpc> ysr: reverse the comparison
11:17:14 <ZyXoas> So.... No? :-(
11:18:38 <kadoban> ZyXoas: At a guess, it's probably something else screwing up because GHC 7.10.1 is super new and not much supports it yet.
11:20:07 <kadoban> ZyXoas: I'd probably stick with 7.8.4 for a while personally, but … if not, I dunno. Install and configure the parts of vim-haskell-now one by one until you figure out what's causing that maybe? Also, if this is in a cabal project, maybe make sure everything old is cleaned out, 'cabal clean' or whatevs.
11:21:20 <lpaste> nichtdiebohne pasted “Fibonacci nw” at http://lpaste.net/131454
11:22:09 <nichtdiebohne> this doesn't work, beginner problem i guess
11:22:33 <ZyXoas> kadoban: Thanks. I'm not experienced with Vim, though. Vim verbose mode doesn't show anything obviously bad...
11:23:01 <kadoban> nichtdiebohne: "doesn't work" is pretty useless as a problem description. That second "where" looks weird though. Remove the "where" from that line, and line up the y with the x from the previous line.
11:24:19 <ZyXoas> Yeah. I'm thinking that downgrading might be a good idea. I'm trying to write a small library and I don't have the energy to try and learn Emacs just now.
11:24:35 <SwashBuckla> Clint: I like the look of MusicBrainz
11:24:37 <kadoban> ZyXoas: If you can figure out how to remove/add bundles in vundle, that's probably enough, and it's not very hard at all. You could just remove one by one until it goes away, then try the other direction. If you don't want to mess with it … 7.8.4 is your friend. I would assume it's known to work there (or maybe it's just totally broken, I don't know that setup well)
11:24:54 <nichtdiebohne> thx
11:24:59 <Clint> SwashBuckla: cool, are you a musicbrainz user?
11:25:19 <SwashBuckla> yes
11:25:27 <SwashBuckla> I tag my music with it
11:25:33 <SwashBuckla> parsing with applicative functors is quite tidy in Haskell and the MusicBrainz code shows it
11:25:59 <lpaste> ysr pasted “euler 4” at http://lpaste.net/131455
11:26:15 <ysr> can http://lpaste.net/131455 be improved
11:26:20 <SwashBuckla> I've not done any networking with Haskell though, so this should provide some learning material
11:26:28 <Clint> SwashBuckla: great, let me know if you have any questions
11:26:37 <ZyXoas> kadoban: Haskell-Vim-Now works well. I screwed up by installing some stuff in the global space and ghc-mod broke, and I thought that upgrading GHC might help. But now that I know how to install a clean GHC, I think I will go back to an earlier GHC and start again. :-)
11:27:53 <kadoban> ZyXoas: Only thing to keep in mind, since that seems to use ghc-mod, is don't use cabal newer than ~1.18.x with GHC 7.8.4 (it'll break ghc-mod if you do)
11:28:16 <kadoban> ZyXoas: Assuming you're installing manually. If not … hopefully whatever you're installing is set up sanely enough to work.
11:28:29 * hackagebot hsini 0.4.0 - Package for user configuration files (INI)  http://hackage.haskell.org/package/hsini-0.4.0 (MagnusTherning)
11:29:09 <ZyXoas> kadoban: yes. I will not upgrade to Cabal 1.22. It's bizarre that the newer Cabal breaks everything even though it installs just fine.
11:29:48 <SwashBuckla> Clint: I like that you restrict your imports to only the things you're using from a library (e.g. import Data.Conduit (Consumer, ($=), ($$))) -- is there something in your IDE which does that for you?
11:30:41 <carter_cloud> 1.22 works great. The problem is ghc mod :)
11:30:58 <kadoban> ZyXoas: It's something about newer cabal changing some format that ghc-mod parses, and the problem can be fixed in newer GHC versions, but it was too annoying to backport or something.
11:31:05 <mauris_> ysr: you could maybe edit the comment so that it has any relation to the code at all?
11:31:15 * mauris_ is very confused.
11:31:20 <kadoban> Yeah, it's only a ghc-mod problem. How it works is pretty fragile I think.
11:31:28 <mauris_> is that just the previous problem?
11:31:42 <Clint> SwashBuckla: no, i do that by hand
11:32:34 <ZyXoas> kadoban: Thanks a lot, Bud. :-) I'll go back to 7.8.4.
11:33:25 <ysr> mauris_ yes, I copied wrong comment from my file :)
11:33:43 <ysr> I have a file that includes all my euler problems with definitions
11:35:04 <mauris_> ysr: anyway, i suppose you could filter first and then just call "maximum" on the resulting list
11:35:18 <lpaste> ysr revised “euler 4”: “No title” at http://lpaste.net/131455
11:35:39 <ysr> I fixed the comment
11:36:31 <untseac> hey
11:36:37 <mauris_> ysr:  result4 = maximum [a * b | a <- [999,998..100], b <- [999,998..a], isPalindrome (a * b)]
11:37:28 <untseac> How do I run one of the sdl2 examples? I want to learn some graphical stuff
11:38:27 <mauris_> that's just what i'd write. it is a tiny bit faster, i think, because finding the maximum (O(n)) should be faster than sorting (O(n log n))
11:38:29 * hackagebot hsini 0.4.1 - Package for user configuration files (INI)  http://hackage.haskell.org/package/hsini-0.4.1 (MagnusTherning)
11:39:23 <untseac> Perhaps I should learn cabal to run the examples?
11:40:04 <untseac> oh I figured it out nvm
14:56:13 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org | Learn, Teach, or Get Out of the Way!'
14:56:13 --- topic: set by shapr!~shapr@84.200.228.78 on [Tue Mar 17 12:32:20 2015]
14:56:13 --- names: list (clog akyte kunalb_ aleator_ sabauman1 rgrinberg SrPx mmachenry Korri pieter_ aleator stef204 MuffinMan` flux austeritysucks yfeldblum doomlord DerisiveLogic randir overlord7 dav malkomalko DrPete_ bherzog erkin tripped wakalabis ansible1 sagittarian knyppeldynan mgsloan danza dedgrant Hijiri desophos j201 L8D gsingh93 pantsman- trnh_ ElectricSolstice ph88 SCHAAP137 pata tss1 dmj` saml_ osa1 darkbolt tommd Welkin raichoo aphorisme gcj frodwith sinelaw)
14:56:13 --- names: list (jonmorehouse mada adam_hardkey_shi dfeuer cbaatz ellipsis_ Aruro Fran__ dan_f CADD Goplat mac10688 ElMoloko ziocroc jfischoff ropav_ vishnix thetomster not_on_fp theorbtwo johtso_ AleXoundOS bshelden tsou jml mkster_ MP2E MuffettMan spopejoy tempname11_ alexclark frerich naudiz arbelos chadkennedy marienz devi tjbp mortberg mniip thunderrd banister amatsu pavonia iElectric BlueRavenGT Mon_Ouie fuzzyhorns skeet70 niklasl2 plutoniix pushpull bb010g d_k untseac)
14:56:13 --- names: list (Betal _sjs theKillingJoke C4Cypher godel KitC_ watabou deni_ Igloo_ aristid_ schell jergason ecthiender cognominal zcd rgr chrisdotcode hiptobecubic paperziggurat Longlius mauris_ triliyn kadoban gabriel_laddel MultiPurposeHat nuttycom mrkishi Jesin edon Lokathor sprang Jeanne-Kamikaze x91 inuoppai mrd_ biscarch zegeri incomprehensibly doppioslash vikram_ chriswk sweenzor nrw phuu bgyss ikke Guest62611 srid Flaeme etrepum neektza arnihermann joedevivo)
14:56:13 --- names: list (cjwelborn darkowlzz|afk seagreen duoi n1ftyn8 Klumben Cr8 konne_ kjnilsson vikraman Frank89RM_ cyphase gnoel drewdavis ScRaMbLe chpatrick agrif lambdahands grol Forkk mudphone mitchty pacak lpaste meretrix killerpty jmct tranma Guest34160 glguy hiratara mikel ackthet kess_ HylianSavior aseidl QoI ortmage zilinc rossberg atn34 neptunepink ephemeron solrize nakal Bigcheese kolmodin coyotebush jzl waxjar huonw wjm Tiktalik Enigmagic pikhq mikeizbic ryanakca pii)
14:56:13 --- names: list (Hugglesworth acfoltzer ciwolsey martintrojer schlicht arjanb emanuelz kav ixti permagreen psy_ xxpor metaf5 nshepperd_ dustinm naevathecat stomp int-e greenbagels dawik_ iulian_ tomku|two atomi_ StoneToad FreeFull rabisg David BlakeRai1 shachaf igniting tomjagua1paw ad_ SwashBuckla klugez_ otulp jstolare1 orion JagaJaga Draggor renzhi tomprince ndeine- FMcC_ hator2 pm52 whaletechno bananagram niko ssedov enthropy doctorinserenity visi0n qiv PHO_ natte levi)
14:56:13 --- names: list (rofer djanatyn joneshf-laptop tinyblak Vbitz cschneid Plastefuchs Cathy seliopou Juka tusj dreixel_ Jellydog renekooi wolf_mozart oconnore dixie_ mitochon arw Xe JamesJRH skarn tinchos Guest26031 gratimax_ Saizan _ashbreeze_ etabot gnusosa_ AntiSpamMeta sleepynate Guest3255 davesilva_ ernst Excureo Fylwind DANtheBE- eyenx iron_houzi eamelink gmaslov vladan foolie cmn_ pranz jxm_ niklasb schoppenhauer1 flori froztbyte nathanic R0b0t1 rseymour nuser cjay)
14:56:13 --- names: list (boris`` saiam kloeri sternenseemann freusque padre_angolano lf94_ pdxleif lyxia MoALTz_ k00mi Faction swen conrad__ fionnan_ spwhitt_ kakos_ td123_ MitchW_ relrod robotbrain Pucilowski lattenwa1 fugyk absence_ jcurbo Ezku_ sabalaba_ lurker6_ _zxq9_ cpa theorb_ sLite gargawel_ stvc_ mephx_ taksuyu Phillema1n Saidin rieper_ paz bennyklo2z sm eyem kstuart_ mrowez michaelpj wagle_ heaumer_ M-ou-se wayne jutaro sdx32 optocoup1er d-q-d adzuci Gurkenglas_ rkazak)
14:56:13 --- names: list (dgorbik ksf concacid1 davidstone zymurgy plvpb EvanR- Artpicre zariuq trism oneeman boathouse2112 ndrei diginet travgmon lexir learns gsnewmark jinblack Kron hjulle redShadow edwinvdg_ mmh Wizek phaskell lspitzner hexagoxel echo-area marcus-aurelius dgpratt jxv indiagreen_ MrFlibble thetallguy Zeitgeist_ lambdabot jomg s4msung bennofs rufs Orwell84 kjanosz zalami_ agjacome ps-auxw gusto c_wraith aborgna hc fikusz u_ adimit thevishy foreignFunction rikkie_)
14:56:13 --- names: list (m1dnight_ saep RegEchse nominolo infinity0 rejerson69_ shintah fling rasen__ bjz quchen duncank zhulikas EnergyCoffee Slay gienah sdothum thorkilnaur_ Willis Nik05 falafel nurupo predator117 slomo t7 Azel LordDeath asQuirreL quyse whiteline tomh- ulfdoz SoupEvil troydm mauke albel727 amiri ThatOtherPerson_ zso Xilov boxfire Xnuk Vq Fubar^ Kamas _flow_ Lutin` Zanzare Shagane goldfire1 hackagebot alevy mrb_bk sebastard dgonyeo rbocquet dsantiago cmsmcq rj-code)
14:56:13 --- names: list (Reiser cstrahan mpereira mankyKitty eniirane Laney namuromus jnoah beauby anachron_ greymalkin hpd exio4 Draconx joehh1 drdo cursork brezel Edoxile bsmt tarcwynne BrianHV thomas tessier mietek fr33domlover mno2 barrucadu ]OLI[ ironChicken Elsi samnmax sevcsik dpwright xplat cryon bergmark zrl alekst_ eivuokko_ lifenoodles_ Adeon sokoll- AlainODea c9sould__ hguux____ az uwap jlamothe malllle sys9mm_ korpse_ luite__ apaku_ jrslepak ahihi2 NeatBasisW Tehnix_)
14:56:13 --- names: list (tlevine khisanth_ ibid sellout- jtobin_ deavidsedice staffehn_ samertm lsep1 tismith_ scott sclv seabre MrWoohoo bcavalier coeus andreypopp otherchas_ saolsen lacrosse__ kalz zpconn__________ akahn dlackty___ moy CARAM__ shennyg Tritlo fuziontech rslima nmashton jroesch avdi Qfwfq zph comma8 dh gbiv tomboy65 Dartanjan spion ElderFain owa ezrios friden __main__ crlane fnordbert drmegahertz sorind poikon heyj Natch Geekingfrog panda_man xandaros Profpatsch)
14:56:13 --- names: list (lispy_ pi8030 mirsal rom1504 _ether__ platz_ jlewis_ jmcarthur_ krgn_ Keel abh yarou wrengr_a1ay hongminhee_ sgronblo_ rray Maxdamantus RevJohnnyHealey kaol_ pleiosau1 Guest84284 Kneiva_ tzaeru PinealGl1ndOptic shiona_ guampa nyuszika7h vodkaInf1rno puzza007 Guest60091 rivarun obcode_ Revenrof taruti electrogeek liff nour tv armyriad CMCDragonkai SamB_laptop free_beard sakirious sunwukong` dibblego eazar001 negatratoron path[l] tgeeky eisbehr Rotaerk)
14:56:13 --- names: list (PyroPeter mecalopolis zaquest jessicah exferenceBot Zekka Ralith jonesinator cyborg-one ryantrinkle Stratege_ eevar Moggle Nils fengshaun solarus pixelfog seedy meteo_ proq byorgey ivan\ latk tnks boot13 oscar_toro gws ValicekB benwf sogaan StoneCypher noam mceier Noldorin vin-ivar xahry clarktic djellemah kosorith Wamanuz ollef isocliff sw1nn Schrostfutz jaseemabid_ bitonic theDon ktosiek tremon hamishmack sergey__ ssn__ hebz0rl_ m0rphism Plasmastar larsen__)
14:56:13 --- names: list (erikd ecraven teclo- mimi_vx milieu f|`-`|f BMeph otto_s_ sharvils drbean blicero kidnapped_robot lnr LnL tejing loz-- Dykam aaronlevin srhb Svedrin martingale yrdz Polarina Nimatek chishiki dolio Sonderblade akurilin faser-pyon-del Or1 sh1ken zerokarmaleft joris974 enolan Giggaflop abrar bgamari bgamari_ Dodek julmac Soft- dcoutts mgomezch rola simonnn manfoo7 luzie ttuegel phaazon besenwesen nak hive-mind paf31_away `szx Freundlich xificurC_ ido jacksoow)
14:56:13 --- names: list (siddhanathan Pamelloes maurer CaveJohnson apollo1993 prophile Internet13 Elision verement Nadrieril CosmicRay tsani whitesn supki dgvncsz0f lieven przembot dockdock ljhms kvieta klarrt jtanguy tg Voldenet zimbatm conehead pyloid ipuustin paperManu jle` Vorpal umbriel Talryn dino- unsymbol nemesit|znc DrAwesomeClaws grohne nwf hattusili_III idempotent tswett therealklanni shouya demolithion catsup bracket ousado byaruhaf dabradley lolmac juri_ acmiyaguchi Cale)
14:56:13 --- names: list (perrier simpson mrknife alanz BeardedCoder steell noteventime keix MMuse_______ jonrh alphonse23_ nbouscal kirjs_______ mindos_cloud____ trig-ger Sorella stasku dstockwell bonobo_ Oxyd octalsrc Kruppe mountaingoat Darkflux totte tongcx ixian andrewsw sinopeus ij folsen aloiscochard condy tridactyla wizonesolutions k-u bsummer4 caasihuang josephle miklcct pyrtsa emma jbalint fyolnish theanalyst somenick canta shlevy Eagle_Erwin duairc kaictl hvr untwisted)
14:56:13 --- names: list (xpika brixen lvh bitemyapp znutar heath jcp imalsogreg bjobjo esssing colah chris2 mach spacebug shapr saurik brackets frawgie mrsolow hooptw noddy pharaun Gothmog_ ZsoL myst|work janne sea-gull tristero sudog XMunkki SparkySparkyBoom earthy agumonkey eddsteel da-x _rgn statusbot ski RGamma noctux zorzar s00pcan fall` zeiris aaronweiss74 rdema nkpart cloudhead_ Liskni_si AWhetter alynn lenstr jaspervdj ParahSailin OutlawStar Tristan-Speccy meteo buoto)
14:56:13 --- names: list (fryguybob Floyd_ petercommand anders^^ dlundy kqr dewdrop Taneb gds jameseb wedens dario` greeny kaw_ lamilami suls eyck unknownloner rul johnw netj_ haroldwu Sigyn bdamos ctag cdidd hrnz elementalest Eliel inr ubuntor kalloc Boney Tesseraction lassulus spaceships avocado SHODAN flx aidecoe JZTech101 yusukesuzuki butyoudonot pii4 qr42 robbert ajp andjjj23 dropdrive kloplop321 cosban shwouchk sku1d masse blenny hemite Twey Bane^ kmicu thomie irclogger_com)
14:56:14 --- names: list (poucet lykkin jokester chirpsalot ephess karshan jaffachief benonsoftware gniourf cic lpsmith benzrf dmilith ThePhoeron TallerGhostWalt d3lxa mak` ayertienna cjh` itsmonkt1stic jarvi_ nik_89 keaml_ runde robogoat duga3 lytchi yorick TRManderson mokus_ mgaare_ Zemyla ziman zyoung_ sivoais pygospa Tene hiredman aaronm04 burp mitu yac SuperTux88 Cerise maw Eiam harski Preyer ByronJohnson lahwran horlicks_ Athas ChristianS monochrom sunnymilk magicman hodapp kini)
14:56:14 --- names: list (sebleblanc hpc nmontecc dxld Philonous sbrg frogpunc tromp_ efm ErichKeane voidzero liyang LQYMGT linduxed kevin1024 dju McManiaC Desoxy_ amiller certainty ggVGc capisce jlind Adios_ bennyklotz Yawgmoth srcerer kriwil glowcoil astocko enomies Ankhers gpampara dschoepe WarzoneCommand DustyDingo JPohlman1 irishsultan Fuco simon___ bdha solirc pederindi averell e4x thomassgn MK_FG TheMoonMaster mero c-rog malglim agam adnap enojelly anoe ruukasu ricardo82)
14:56:14 --- names: list (suvash_away _di turinturambar fold _ikke_ bob_twinkles Ring0` zyla PotatoGim nesqi drone| Haskellfant hegge Ferdirand lfp__ SLi zso__ hyPiRion andreass_ edwardk mbrcknl haasn abbe yminsky bind Axman6 brent80_plow usr bernalex uber RageD _1126 timothyh japesinator Brando753 DanToml ircbrowse brisbin raid codehero cin Blkt psacrifice jvd eikke defanor IanKelling Guest90609 jokra lyddonb bafbomb_ tolt Guest48087 RustyShackleford jacksnipe mathu devJunk poga)
14:56:14 --- names: list (fall_ tumdedum Sqt Paprikachu frontendloader karls iross ryantm sdressel jackhill bigs blast_hardcheese si14 wenzowski geekosaur milli zero7 carter_cloud comboy arianvp Baughn alpounet cowtown bolmar dilinger spdionis kvalle zenzike serutsubi Nickeeh Jaxan edk posco rtl_ eagleflo dredozubov mechairo` noplamodo DanZimm geal d-snp sagelywizard amontez Nanar jludwig jayne ggreg niluje bcoppens edwtjo Clint betawaffle davean gbarboza apo sujeet phadej yukonjack)
14:56:14 --- names: list (kennyp gmcintire nikola AshyIsMe liste hsyl20 Ptival shmookey1 adlan fractalcat yeltzooo9 gtklocker sunnavy stbuehler cscorley thebnq CindyLinz sbauer322 dicioccio mattp|spurs numberten cYmen_ xian tromp tomaw annulus brolin_empey angryzor gdsx joeytwiddle FireFly Jello_Raptor joshc joehillen pmade cynick GaveUp xnyhps anastas mendez_ monsieurp qz asm89 Intensity ChongLi [swift] bartavelle Uritomi2 IbnFirnas heikkih elgot opqdonut Chousuke WSergio KaneTW)
14:56:14 --- names: list (Mandus f_x_ xaimus mikeplus64 majoh Guest37394 orzo Th0mas raek albertid Watcher7_ ckw u_quark1 Heffalump banjiewen ReinH callumacrae mp ClaudiusMaximus cross cYmen mt mikedanese acharm AncientPC ninzine wtw DenSchub Guest85510 jakutis Eldrad lemmih pingu sephiap yrashk ggherdov ehamberg cojy_ Raynos lohkey bkolera andrew__n ocharles_ jfokkan bcarrell Erstarrung bjornars1 xxx zxtx tomphreek Rembane Rastus_Vernon tazjin S11001001 twopoint718 dan64 Ke Starfire)
14:56:14 --- names: list (_klm jabbslad_ RasmusWL gridaphobe RayNbow`TU valdyn Paks Chobbes mjo martinbmadsen asjo eL_Bart0 bbee ilmig rudi_s mpw bijumon brennie nisstyre joeyh mlen plhk cods mmaruseacph2 tdammers Dtgr mrd tuv pharpend Belgarion0 ninegrid zbrown mads- ft spindas Jaak bvad zq ion dowski_ machineslearn thoughtpolice aleator_1 marens TDJACR GGMethos zomg hanDerPeder sohum BillyIII bydo SegFaultAX LeaChim Sornaensis obiwahn gseitz kipras monty avn oberstein Spockz dp_wiz)
14:56:14 --- names: list (lokydor fergusnoble peddie dkua Jonno_FTW petantik jkarni jix Heero JonasH__ NemesisD emmanueloga idnar shelling__ julienXX Xorlev DigitalKiwi jophish Fuuzetsu mpickering sajith dmwit notdan davl slasktask rs0 kgadek wto helgar fredsir senseibaka dpn` oherrala mami kosmikus mjrosenb statusfailed kazawore_ dabukalam zeroskil1or seanparsons hellschreiber integral Walther kwantam felixsch Ornedan pfoetchen killtheliterate alem0lars lachenmayer myme jlouis ahf)
14:56:14 --- names: list (isomorphismes arkeet carter scopedTV otterdam `0660 jlyndon jrp6 ThreeOfEight fmapE kshannon schlumpi adamse Hafydd tekacs alang Razz biio Boreeas zebr tych0 osfameron howard s_e kragniz tero- aupo arch_ edran_ @ChanServ Atlanis Deewiant Ulrar)
14:57:02 <bergmark> latk: e.g. we write a query as `Query (To Column User)', and an optional insert as `To Maybe User`, a left join gives you a `To Column (To Nullable User)`
14:57:25 <latk> bergmark: Are there any examples of this online? 
14:57:52 <bergmark> latk: our library is here https://github.com/silkapp/silk-opaleye/blob/master/example/Example.hs
14:58:57 <bergmark> not sure if it's easier to start learning using that though...
14:59:28 <bergmark> might be helpful to -ddump-splices on that file to see what it generates
14:59:30 <latk> bergmark: Almost certainly not, given how little I know of template haskell :p
14:59:41 <latk> I'll have a look later, however
15:00:36 <ion> wakalabis: Aligned: https://gist.github.com/ion1/0672eea6e88188682106
15:00:49 <bergmark> we also don't use any of the PG* types from opaleye
15:01:15 <wakalabis> io: thanks !! i was copying and pasting the code you wrote to vim, so that I could indent it!
15:01:19 <latk> bergmark: Oh? How come / 
15:03:00 <bergmark> latk: mostly for type safe joins, if you have two tables with id :: PGInt you might join them by accident
15:03:25 <latk> bergmark: Oh. I thought I saw something about wrapping stuff up in newtypes ?
15:03:40 <bergmark> latk: instead we have `id :: IdA` and `id :: IdB`
15:05:05 <bergmark> latk: there are several ways to do this... we thought it made most sense to assume that different haskell types should not be the same in opaleye either
15:05:38 <wakalabis> ion !! I got it :) thanks
15:05:53 <latk> bergmark: Fair enough. Hopefully in a few more hours of looking at this I'll see why you made this decision.
15:06:28 <ion> wakalabis: np
15:06:38 <wakalabis> partition even [0..10]; foldr (select even) ([], []) [0..10]; (select even) 0 (foldr (select even) ([], []) [1..10])
15:07:37 <wakalabis> In order to pattern match on (select even) 0 (foldr (select even) ([], []) [1..10]), we would have to fully evaluate foldr (select even) ([], []) [1..10]
15:08:04 <ion> Not fully per se, just up to the spine of the tuple. But that is enough to evaluate the spines all the way to the end.
15:08:55 <wakalabis> ion: without the tilde, wouldnt we have to fully evaluate it?
15:09:41 <ion> (Well, it will also evaluate the elements of the input list because of the “p x” condition. But that’s another matter.)
15:11:01 <wakalabis> yeah... that makes sense
15:12:06 <ion> > let f (a,b) = error "did not evaluate the parameter" in f (error "evaluated the tuple constructor")
15:12:08 <lambdabot>  *Exception: evaluated the tuple constructor
15:12:42 <ion> > let f (a,b) = error "did not evaluate the tuple members" in f (error "evaluated member a", error "evaluated member b")
15:12:43 <lambdabot>  *Exception: did not evaluate the tuple members
15:13:51 <ion> > let f ~(a,b) = error "did not evaluate the parameter" in f (error "evaluated the tuple constructor")
15:13:52 <lambdabot>  *Exception: did not evaluate the parameter
15:15:39 <wakalabis> ion: cool :D
15:39:09 <dmwit> Probably better to make the case you expect to hit not use an exception, to avoid the possibility of getting confused by imprecise exceptions.
15:39:50 <dmwit> > let f ~(a,b) = "you can be really sure we did not evaluate the parameter" in f (error "evaluated the tuple constructor")
15:39:51 <lambdabot>  "you can be really sure we did not evaluate the parameter"
15:43:48 <nurupo> for some reason I get "parse error (possibly incorrect indentation or mismatched brackets)" when trying to have a function in "where" clause that uses "|" conditions
15:44:03 <dmwit> ?paste your code
15:44:03 <lambdabot> Haskell pastebin: http://lpaste.net/
15:47:20 <lpaste> nurupo pasted “No title” at http://lpaste.net/131471
15:47:47 <dmwit> The pipe should be indented more than the g.
15:48:25 * hackagebot DAV 1.0.5 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-1.0.5 (ClintAdams)
15:48:39 <nurupo> aha!
15:48:42 <nurupo> worked
15:48:52 * nurupo blames Kate
15:54:13 <Pamelloes> How does FFI work for languages other than c?
15:54:26 <dmwit> via C
15:54:39 <Pamelloes> ok
15:54:43 <Pamelloes> What about Objectice C?
15:55:06 <dmwit> Same answer, as far as I know.
15:55:07 <Welkin> the FFI is in C
15:55:23 <Welkin> pretty much every language has a bridge to C
15:55:34 <Welkin> some are even implemented in C, like python and ruby
15:56:09 <Pamelloes> In my case I'm using a library "language-c-inline" that lets you embed c and objective c code via template haskell that is automatically extracted.
15:56:49 <Pamelloes> Right now I'm just trying to figure out how to link everything, so I think my issue is that I just don't understand the library correctly :/
16:04:28 <pavonia> Is there a way to check if a certain character is in the current code page and can be printed via putStr?
16:05:36 <pavonia> I guess I could catch the exception and check if has "invalid argument" in its message but maybe there's a better way
16:06:36 <pavonia> Ideally, I'd like to replace all non-printable characters in a string to printable ones
16:07:00 <jle`> you can check if a Char is printable with `isPrint`, if that helps
16:07:18 <dmwit> encodeable :: Encoding enc => enc -> Char -> Bool, in package encoding
16:09:40 <pavonia> dmwit: How do I get the current encoding?
16:11:07 <dmwit> ah, well
16:11:11 <dmwit> That's trickier. =P
16:11:21 <dmwit> getSystemEncoding :: IO DynEncoding
16:11:50 <dmwit> ...sort of
16:12:50 <dmwit> Reasons for saying "sort of": 1. only supported on Linux 2. not handle-specific
16:14:23 <dmwit> There's also get{Locale,FileSystem,Foreign}Encoding from base-GHC.IO.Encoding.
16:15:23 <lpaste> randir pasted “Imperative pseudocode ” at http://lpaste.net/131472
16:15:52 <randir> Can you guys help me implement this functionally? I want to make it very clean and efficient.
16:16:05 <frerich> Is putStrLn already encoding aware to some degree? After all, it receives a list of Unicode codepoints. At some point somebody will have to decide how to serialize that into octets.
16:16:15 <randir> I'm thinking using a foldr would be the best way? Or is there a cleaner way?
16:16:23 <dmwit> randir: I'm sure there are alpha-beta implementations on Hackage already, if you want to look at how others would do it.
16:17:07 <randir> Well even outside of the specific implementation, I'm curious how I would implement this sort of psuedocode functionally in a clean manner. 
16:17:50 <dmwit> What does the combination of "outside of the specific implementation" and "this sort of pseudocode" mean?
16:18:03 <dmwit> frerich: It is, yes.
16:18:42 <dmwit> frerich: And pavonia is dealing with that, it sounds like: not all Char's are encodeable in all encodings, at which point putStrLn and friends will throw an exception.
16:18:59 <randir> I mean I'm not just looking to implement alphabeta, I'm also just curious how I would implement pseudocode of a breaking for loop that iteratively updates a value. 
16:19:11 <dmwit> frerich: Try putStrLn "\1000" in LANG=C ghci to see the exception for yourself. =)
16:19:13 <randir> The example alpha-beta search I found approaches it rather differently
16:20:08 <dmwit> randir: Perhaps a combination of takeWhile and scanl max
16:20:10 <dmwit> :t scanl max
16:20:11 <lambdabot> Ord b => b -> [b] -> [b]
16:20:45 <dmwit> :t Data.Monoid.Inf.negInfty
16:20:46 <lambdabot> Not in scope: ‘Data.Monoid.Inf.negInfty’
16:20:48 <dmwit> too bad
16:21:18 <frerich> dmwit: It actually doesn't raise an exception here but prints some sort of '8' :-)
16:21:29 <frerich> \10000 is a pen, heh.
16:21:52 <dmwit> frerich: Err, really? Even with LANG=C? What version of ghc?
16:21:59 <dmwit> Are you in the stone ages...? =P
16:22:09 <pavonia> Bah, my GHC is way too old :(
16:22:33 <frerich> dmwit: http://lpaste.net/131473 is what I get.
16:22:41 <rwiggins> dmwit: it prints a Ϩ for me (if that symbol appears for you). GHC version 7.10.1.
16:22:52 <dmwit> Strange.
16:22:53 <teurastaja> i dont understand the difference between MonadPlus and Monoid
16:23:14 <dmwit> That's what I get with a utf-8 language.
16:23:25 <dmwit> teurastaja: different kinds
16:23:27 <teurastaja> seems to me like MonadPlus is useless with Monoid
16:23:32 <teurastaja> what is a kind?
16:23:53 <dmwit> teurastaja: Monoid instances are types. MonadPlus instances are type functions.
16:23:53 <teurastaja> the haskell wikibook says that but never mentionned it before
16:24:22 <dmwit> teurastaja: Kinds are the types of types. So, we have a base kind * which classifies the inhabitable types.
16:24:25 <fr33domlover> Hello, is there a better way to share type definitions than this? http://pamrel.lu/5573f/
16:24:26 <dmwit> Like Int, Bool, Maybe (), and so on.
16:24:50 <dmwit> Then for every kind k1 and k2, there is a kind k1 -> k2 which is the kind of a type which takes a k1 as an argument and produces a k2.
16:24:54 <dmwit> For example, Maybe :: * -> *
16:25:08 <dmwit> says that if you have a type (like Int), you can apply Maybe to it to get another type (like Maybe Int).
16:25:35 <dmwit> teurastaja: Instances of Monoid are boring old types, things of kind *.
16:25:48 <dmwit> teurastaja: But instances of MonadPlus are things of kind * -> * which are monoids *for every argument*.
16:26:20 <pavonia> fr33domlover: Not really. "data Element = Resource Resource | Value String String" would be another option
16:26:21 <dmwit> teurastaja: So, in a hypothetical extended Haskell, one might write "MonadPlus m => ..." to mean the same thing as "(forall a. Monoid m a) => ...".
16:26:38 <dmwit> "(forall a. Monoid (m a)) => ...", I mean.
16:26:39 <teurastaja> what is forall?
16:26:45 <dmwit> The usual mathematical forall.
16:26:56 <teurastaja> like a functor?
16:27:00 <dmwit> "This thing is a monoid no matter which type you provide as an argument."
16:27:08 <dmwit> There's not really a way to say that in existing Haskell.
16:27:39 <fr33domlover> pavonia, thanks :-)
16:27:45 <teurastaja> how do you use that forall notation? what does "." stand for?
16:28:10 <teurastaja> like forall a in ...?
16:28:13 <dmwit> fr33domlover: You can do a bit better by providing a type argument.
16:28:34 <dmwit> fr33domlover: e.g. data Foo a = Uid String | Generator | Value a a
16:28:46 <dmwit> fr33domlover: type Resource = Foo Void; type Element = Foo String
16:29:00 <dmwit> teurastaja: I invented that notation. It's not real. Don't get too hung up on it.
16:29:17 <teurastaja> you invented forall??
16:29:21 <dmwit> teurastaja: The "." is just a separator between the name we're binding and the property that holds for all values of that name.
16:29:30 <dmwit> teurastaja: No, I invented the *notation*! =D
16:29:44 <dmwit> The idea is of course centuries old.
16:30:05 <teurastaja> you mean you ported the mathematical forall to haskell?
16:30:24 <dmwit> um. sure
16:30:44 <dmwit> That sounds like it gives me a bit too much credit. No implementation would accept the thing I wrote above.
16:30:47 <teurastaja> how old are you? just wondering at what age one becomes a genius
16:31:14 <dmwit> I expect that I'm just doing a bad job of explaining things, actually.
16:31:46 <dmwit> Okay, let's try again from the top.
16:32:15 <dmwit> The difference between Monoid and MonadPlus. You are right that they are very similar.
16:32:30 <teurastaja> no youre not. category theory just happens to be too circular. i havent seen "inhabited types" and "types of types" and kinds and things like that
16:32:33 <dmwit> If you have a MonadPlus instance m, and a type a, you definitely have a monoid m a.
16:33:12 <dmwit> Specifically, the inhabitants of (m a) is the set, mzero is the unit element, and mplus is the binary operation.
16:33:21 <teurastaja> so MonadPlus is a subclass of Monoid?
16:33:26 * hackagebot Chart 1.4 - A library for generating 2D Charts and Plots  http://hackage.haskell.org/package/Chart-1.4 (TimDocker)
16:33:27 <fr33domlover> dmwit, thanks. I never saw Void before
16:33:28 * hackagebot Chart-cairo 1.4 - Cairo backend for Charts.  http://hackage.haskell.org/package/Chart-cairo-1.4 (TimDocker)
16:33:30 * hackagebot Chart-gtk 1.4 - Utility functions for using the chart library with GTK  http://hackage.haskell.org/package/Chart-gtk-1.4 (TimDocker)
16:33:32 * hackagebot Chart-diagrams 1.4 - Diagrams backend for Charts.  http://hackage.haskell.org/package/Chart-diagrams-1.4 (TimDocker)
16:33:56 <dmwit> But the magical thing is that this works no matter which type you pick for the argument; m Bool is a monoid, m () is a monoid, m (StateT Int (Either Void Bool)) is a monoid...
16:34:18 <dmwit> "subclass" has a specific technical meaning in Haskell.
16:34:22 <jle`> MonadPlus gives you a monoid, but that's different than saying it's a Monoid (the haskell typeclass)
16:34:27 <dmwit> And MonadPlus is not a subclass of Monoid in that technical sense.
16:34:44 <dmwit> MonadPlus is a subclass of Monad.
16:35:00 <teurastaja> a subset then?
16:35:19 <mauris_> [] is the MonadPlus and [a] is the Monoid
16:35:30 <jle`> MonadPlus gives you a monoid with mzero and mplus
16:35:37 <jle`> Monoid gives you a monoid with mempty and mappend
16:35:40 <dmwit> teurastaja: Well, they are completely disjoint classes. Nothing can be both a MonadPlus and a Monoid.
16:35:51 <teurastaja> ok
16:35:54 <jle`> both typeclasses give you monoids
16:35:57 <teurastaja> weird
16:36:05 <dmwit> teurastaja: Because MonadPlus instances have to be able to take a type argument, and Monoids must already be types without any further arguments.
16:36:09 <jle`> look at the type signature of mappend
16:36:12 <jle`> :t mappend
16:36:13 <lambdabot> Monoid a => a -> a -> a
16:36:25 <jle`> can you put `Maybe` there? ...no, it makes no sense
16:36:35 <jle`> Maybe -> Maybe -> Maybe doesn't make sense as a type
16:37:16 <dmwit> fr33domlover: If you decide to go that route, you might want to consider making Value a strict constructor.
16:37:21 <teurastaja> so Monoid cant implement transformers but MonadPlus can?
16:37:30 <dmwit> fr33domlover: So that somebody couldn't accidentally make a Value undefined undefined.
16:37:36 <rwiggins> :t mplus
16:37:37 <lambdabot> MonadPlus m => m a -> m a -> m a
16:37:47 <dmwit> teurastaja: I'm not sure I understand the question yet. Can you elaborate?
16:38:03 <dmwit> fr33domlover: data Element a = ... | Value !a !a
16:38:25 <fr33domlover> dmwit, thanks. I think I'll take the simpler option of Resource Resource (also I haven't read about ! and strictness yet so I prefer not to use it for now)
16:38:26 <teurastaja> so Monoid cant share the properties of 2 monads but MonadPlus can?
16:38:28 <jle`> a monoid is anything that has a "combining" function and an identity.  the Monoid typeclass ofers that with mappend and mempty.  the MonadPlus typeclass offers that with mplus and mzero.  so they're not superclases or subclasses of eachother
16:38:49 <jle`> they are just two different ways of defining monoids
16:38:59 <mauris_> hmm
16:39:02 <mauris_> @src mfilter
16:39:02 <lambdabot> Source not found.
16:39:42 <mauris_> oh, found it. that is a cool little function i didn't know about
16:40:28 <dmwit> teurastaja: Well, there can certainly be a Monoid instance which has a monad transformer in it. Same for MonadPlus. I don't know if there are any standard ones.
16:40:58 <teurastaja> hmm... then i still dont understand the difference
16:41:10 <fr33domlover> teurastaja, a metaphore, hopefully I'm not wrong: the parametric type "Bird a" can be a MonadPlus. Each instantiation, e.g. "Bird Pigeon", can be a Monoid
16:41:30 <dmwit> Some slight imprecision: Bird can be a MonadPlus.
16:41:36 <dmwit> Bird Pigeon can be a Monoid.
16:42:31 <dmwit> teurastaja: Let's talk a bit more about kinds.
16:42:37 <dmwit> teurastaja: I think that background will help.
16:42:37 <mauris_> are there intresting MonadPlus instances beyond [] and Maybe?
16:42:51 <teurastaja> yes very much
16:43:12 <dmwit> So * is the most basic kind.
16:43:23 <teurastaja> i dont even know what parametric polymorphism is, i just know one type of polymorphism
16:43:28 <fr33domlover> teurastaja, the haskell wikibook talks about MonadPlus and Monoid, take a look there
16:43:35 <dmwit> It's the kind we're all pretty familiar with, because the types we annotate things with in Haskell are all of kind *.
16:43:36 <teurastaja> i have
16:43:44 <teurastaja> thatsd why im here
16:44:19 <dmwit> Some examples of types of kind * are `Int`, `Bool`, `Int -> Bool`, `[Either Int Bool] -> Graph Nodes Edges`, etc.
16:44:21 <teurastaja> that MonadPlus page on wikibooks is using unforeseen concepts to explain it
16:44:28 <dmwit> Are you on board with this so far?
16:44:57 <dmwit> On the other hand, you wouldn't write `foo :: Either` in a Haskell file. Why is that?
16:45:14 <teurastaja> because you need Either a?
16:45:26 <dmwit> Yeah, `Either` is a bit... unfinished, right?
16:45:31 <teurastaja> yes
16:45:34 <dmwit> It actually takes two more types before it "makes sense" as a type.
16:45:56 <dmwit> We say `Either :: * -> * -> *` to make this claim more compact and precise.
16:45:57 <teurastaja> oh true so Either a b
16:46:20 <dmwit> There's a hidden kind-checker inside GHC that makes sure you apply `Either` to two base types before you use it.
16:46:37 <dmwit> e.g. you wouldn't write `Either Maybe Bool`, again because the `Maybe` part is "unfinished".
16:46:41 <dmwit> It has the wrong kind.
16:46:46 <fr33domlover> teurastaja, another intuition (dmwit, sorry for interrupting): MonadPlus lets you combine actions with different types (e.g. different bird types into a Nest) while a Monoin works on a single type (e.g. combine just Pigeons)
16:46:55 <dmwit> `Either` expects a type of kind * as its first argument, but `Maybe` has kind `* -> *`.
16:46:56 <fr33domlover> again I hope this is correct :P
16:47:29 <teurastaja> so MonadPlus is polymorphic and Monoid is not?
16:47:31 <dmwit> Depending on what you mean by "combine actions with different types", it may be right.
16:47:34 <jle`> mauris_: i use the MonadPlus instance of StateT s [] in a recent blog post to great effect :)
16:47:53 <dmwit> teurastaja: Sort of, yes!
16:48:11 <jle`> people also sort of like to pretend IO is a MonadPlus
16:48:45 <teurastaja> "pretend"?
16:48:59 <jle`> i think it's safe to say it's at least an Alternative
16:49:00 <dmwit> teurastaja: Another fun kinding judgement is `(->) :: * -> * -> *`. It looks a bit funny, because it's using two different meanings for `->` in one statement: on the left of the `::`, `->` is the thing we use to construct function types, whereas on the right `->` is the thing we use to construct function kinds.
16:49:04 <mauris_> huh. ``IO a'' isn't always a Monoid though is it
16:49:26 <dmwit> mauris_: The MonadPlus instance throws exceptions and acts as the first action which doesn't do that.
16:49:33 <jle`> no...MonadPlus m doesn't usually have anything to do with a corresponding Monoid (m a)
16:49:35 <dmwit> mauris_: Though I think it's probably not quite law-abiding.
16:50:13 <mauris_> dmwit: and mzero just throws?
16:50:17 <dmwit> mauris_: correct
16:50:23 <dmwit> ?src IO MonadPlus
16:50:23 <lambdabot> Source not found. Do you think like you type?
16:50:25 <dmwit> ah well
16:50:33 <teurastaja> :t mplus
16:50:34 <lambdabot> MonadPlus m => m a -> m a -> m a
16:50:38 <jle`> mauris_: the MonadPlus instance for Maybe has nothing to do with the Monoid instance for Maybe a, so you should in general assume they don't have anything to do with eachother
16:50:42 <teurastaja> :t mappend
16:50:43 <lambdabot> Monoid a => a -> a -> a
16:51:02 <Myrl-chan> bye
16:51:08 <dmwit> teurastaja: There you can see a kinding distinction: MonadPlus instances have kind `* -> *`, while Monoid instances have kind `*`.
16:51:44 <teurastaja> still dont understand kinds sorry :(
16:51:54 <dmwit> teurastaja: Can you tell me where you first got lost?
16:52:16 <rwiggins> :k Maybe
16:52:17 <lambdabot> * -> *
16:52:20 <rwiggins> :k Int
16:52:21 <lambdabot> *
16:52:28 <rwiggins> :k Either
16:52:29 <lambdabot> * -> * -> *
16:52:40 <teurastaja> * is the base "kind"...? and what is * -> *
16:52:47 <mvc`> any recommendations of libraries for numeric integration of a dataset?
16:52:49 <dmwit> Yes, * is the base kind.
16:53:00 <teurastaja> what is a base kind?
16:53:03 <peddie> mvc`: hmatrix-gsl?
16:53:04 <dmwit> `* -> *` is the kind of type-level terms that, when applied to a type, produce a type.
16:53:38 <dmwit> "What is a base kind?" isn't such a great question, unfortunately. But the related question, "What does * mean?" is pretty okay. Is it alright with you if I answer that one instead?
16:53:47 <peddie> mvc`: https://hackage.haskell.org/package/hmatrix-gsl-0.16.0.3/docs/Numeric-GSL-Integration.html 
16:53:47 <dmwit> I'm happy to answer the first one, but i don't think it will be helpful.
16:53:59 <teurastaja> yes
16:54:09 <dmwit> `*` is the kind of types that are inhabited by values.
16:54:12 <mvc`> peddie: I'll check it out
16:54:40 <peddie> mvc`: oh of a dataset, that may actually not help too much
16:54:43 <dmwit> So, e.g., True is a term. It has type Bool. Since Bool is a type with values, it has kind *.
16:55:02 <dmwit> (This is a good first approximation of what `*` means.)
16:55:09 <mvc`> peddie: yeah, all the libraries I've found assume its a function I know
16:55:17 <mvc`> peddie: I suppose I could interpolate
16:55:53 <teurastaja> like saying "types are isomorphic to functions"?
16:55:58 <dmwit> The actual definition of `*` involves a complete kind system -- which is like a type system, but instead of connecting terms and types, it connects types and kinds.
16:56:08 <dmwit> Who says types are isomorphic to functions?
16:56:13 <dmwit> That doesn't sound right to me.
16:56:15 <teurastaja> are you using value as a synonym of term?
16:56:24 <peddie> mvc`: I guess if you have a bunch of points, you may also know how to interpolate (is it a smooth function?  zero-order holds in between?)
16:56:24 <dmwit> Sorry, yes, I meant term. Apologies.
16:56:54 <mauris_> are term and value different things?
16:56:55 <mvc`> peddie: yeah, its the rate of change of a hysteresis loop
16:57:09 <dmwit> Yes, values are terms which cannot take a reduction step.
16:57:19 <teurastaja> sorry perhaps i misunderstood the curry-howard isomorphism and just make a confusing/wrong reference to it
16:57:22 <dmwit> ...and are not merely "stuck", but are actually done computing.
16:57:23 <peddie> mvc`: it looks like hmatrix-gsl doesn't expose GSL's spline interpolation routines
16:58:23 <mauris_> are there types that have terms, but no values?
16:58:30 <dmwit> Yes.
16:58:33 <hiptobecubic> Arghhhhhhh! 
16:58:34 <dmwit> data Void -- here is an example
16:58:36 <mauris_> well, i guess `undefined` in Void?
16:58:42 <dmwit> exactly =)
16:59:06 <dmwit> The question of whether a type has a value is a very interesting one, and solving it is the purview of the field of proof search.
16:59:45 <mvc`> peddie: hmm, ok. I'm gonna look around for interpolation libraries
16:59:57 <mauris_> dmwit: i've seen the term "inhabited" thrown around. is that what it formally means?
17:00:08 <dmwit> yep
17:00:12 <teurastaja> mauris_: good question
17:00:27 <mauris_> neat
17:01:37 <teurastaja> this is probably not related, but can you describe the unit type?
17:01:43 <teurastaja> ()
17:01:54 <teurastaja> is it just an empty tuple?
17:02:06 <dmwit> It might help to talk about the isomorphic type
17:02:07 <voidzero> it's a distinct type
17:02:10 <dmwit> data UnitType = UnitValue
17:02:12 <teurastaja> or is it "() a"
17:02:21 <Cale> teurastaja: It's an empty tuple
17:02:48 <Cale> teurastaja: There's only one defined value of type (), which is punnily also called ()
17:02:51 <dmwit> Empty tuple is not a bad way to think of it. It is not `() a`.
17:03:03 <Cale> teurastaja: But like any type, there is also an undefined value of type ()
17:03:10 <voidzero> i've seen people argue in here about that quite often Cale :)
17:03:23 <Cale> voidzero: about what?
17:03:27 <mauris_> () :: () is pretty confusing
17:03:36 <voidzero> if () can be called an empty tuple
17:03:40 <Cale> ah
17:03:46 <mauris_> i recently found out ML calls the type "unit" or something?
17:03:50 <ion> () ;: (() :: *)
17:03:53 <teurastaja> an endofunctor?
17:03:58 <dmwit> It can be called an empty tuple. Proof: I have done so.
17:04:00 <Cale> Yeah, it's also called Unit or 1
17:04:09 <Cale> In various other languages and settings
17:04:13 <voidzero> mauris_, yeah, unit
17:04:24 <voidzero> "unit is a type and it has one value: ()"
17:05:10 <teurastaja> so unit is a neverending term with each subsequent evaluation pointing to itself?
17:05:16 <Cale> teurastaja: no
17:05:23 <mauris_> > ()
17:05:25 <lambdabot>  ()
17:05:31 <dmwit> This is why I like data UnitType = UnitValue.
17:05:33 <mauris_> > undefined :: ()
17:05:34 <lambdabot>  *Exception: Prelude.undefined
17:05:42 <Cale> teurastaja: I believe you're just confused by the fact that terms and types live in completely separate namespaces in Haskell
17:05:46 <dmwit> UnitValue :: UnitType
17:06:01 <Cale> teurastaja: So you can have a value which is named the same thing as a type, and they're two separate things.
17:06:09 <teurastaja> actually i think im confused about haskell
17:06:18 <mauris_> (Cale: i think this was a very confusing time to bring up undefined to teurastaja)
17:06:26 <Cale> mauris_: possibly!
17:07:22 <voidzero> just keep in mind that the stuff left of the equal sign refers to types, and the right side refers to values.
17:07:26 <teurastaja> ok so () is a function from the type () to value ()?
17:07:27 <voidzero> type = value
17:07:37 <Cale> teurastaja: Nope.
17:07:55 <ion> teurastaja: Consider dmwit’s equivalent example of data UnitType = UnitValue.
17:07:56 <Cale> The value () is simply a value (a constructor) of the type ()
17:08:02 <mauris_> teurastaja: Int is a type. its values are: 0, 1, -1, 2, -2...
17:08:09 <mauris_> teurastaja: () is a type. its values are: ()
17:08:14 <Cale> teurastaja: So there are two separate things both called () here
17:08:53 <Cale> The value () and the type (). You can never get them confused in Haskell because you're never allowed to write a value where a type is supposed to go and vice versa.
17:08:54 <voidzero> a function is something that takes a value of a certain type, and transforms it to a value of a certain type.
17:08:57 <voidzero> in/out.
17:09:13 <voidzero> you already know this. But it's really that simple.
17:09:35 <teurastaja> also, im confused about equality vs equivalence in haskell and life in general
17:09:43 <voidzero> so, my advice - focus on "what data do I have" and "to what do i want to transform it"
17:09:52 <Cale> teurastaja: So, the things on the left of the :: live in a completely separate world from the things on the right of the :: in Haskell.
17:09:53 <ion> Also, a function always has the type A -> B for some A and B.
17:10:00 <voidzero> teurastaja, in life, no two things are equal, but that's off topic for this channel. :P
17:10:58 <dmwit> teurastaja: That's okay. I've been studying equality and equivalence for years and it still confuses me. There's lots of different flavors of each.
17:10:59 <voidzero> no things are equal, unless everything is equal, in which case there are no things anyway. Or something. It's late over hither.
17:11:15 <teurastaja> ive seen a haskell proof of equivalence in the wikibook but there seems to be no proof of equality anywhere
17:11:26 <dmwit> teurastaja: But if you have some context you want to talk about, we can pick a particular equality and a particular equivalence that make sense for that context and talk more about them.
17:12:02 <mauris_> an equality/equivalence thing i am still philophically very confused by:
17:12:20 <mauris_> are square : Z -> Z and square : Z -> Z+   equal? equivalent?!
17:12:20 <teurastaja> does equality even exist??
17:12:23 <Cale> teurastaja: Equality is always just a certain sort of equivalence which is intended to be finer than any other kind of equivalence we want to discuss.
17:12:45 <Cale> teurastaja: Equality exists only as much as anything in mathematics exists.
17:13:06 <dmwit> "finer" means "fewer things are equivalent"
17:13:19 <mauris_> if you take a function to be "a set of tuples", does the notion of "codomain" even really exist? i guess not?
17:13:24 <teurastaja> so mathematics dont exist because equality cant be proven?
17:13:59 <Cale> Which is to say, there's no empirical content to mathematics whatsoever, to say that equality exists in this context is not to make a prediction about what will be observed in some circumstance. It's making a statement about a formal game whose rules we've made up (or are in the process of describing).
17:14:07 <voidzero> i don't know if this discussion has a mathematical context that's unfamiliar to me; i'm a philosopher. Philosophically I'd just talk about similarities.
17:14:35 <nshepperd_> mauris_: bah, that's why you take a function to be (tuples, domain, codomain)
17:15:08 <nshepperd_> or (tuples, codomain) I guess if you're lazy
17:15:23 <mauris_> ah, do people do that?
17:15:45 <Cale> teurastaja: When we do mathematics, we make up the rules that we then follow, and if we care to describe what the rules regarding equality are, then we can discuss it. There's really not just one sort of equality, but most formalisms for mathematics will have some sort of concept for which the symbol and name are appropriate.
17:15:49 <dmwit> mauris_: Yes, people do that.
17:16:22 <dmwit> mauris_: From wikipedia: "A binary relation R is usually defined as an ordered triple (X, Y, G) where X and Y are arbitrary sets and G is a subset of the Cartesian product X x Y."
17:16:28 <voidzero> just pondering.. perhaps equality implies absence of state..?
17:16:34 <teurastaja> im talking about pointer equality
17:16:36 <dmwit> ...and functions are relations with certain properties. So.
17:16:49 <Cale> teurastaja: Ah, nobody here was even considering pointer equality.
17:17:03 <Cale> teurastaja: Pointer equality in GHC Haskell is pretty much useless.
17:17:09 <mauris_> dmwit: aha! jeez, all the schools i've been in that taught me about functions cut serious corners. that makes a lot more sense.
17:17:19 <dmwit> voidzero: How to do equality in a stateful (or even IO-ful!) world is a very interesting research question.
17:17:31 <Cale> teurastaja: The garbage collector is free to move things around at any time, to the extent that you can do a pointer equality with a value and itself and have it fail.
17:17:55 <dmwit> ...but we have StableName's.
17:18:01 <Cale> (because the thing got moved by garbage collection)
17:18:03 <nshepperd_> Cale: there's no way to to an "atomic" test in between gc runs?
17:18:10 <mauris_> ("a relation is a subset of X x Y" etc.)
17:18:24 <Cale> dmwit already mentioned the right thing to use
17:18:26 <voidzero> dmwit, sounds like you can't avoid to talk about it in a temporal context
17:18:30 <dmwit> nshepperd_: I'm not sure. But if you use a stable name, the name doesn't change after a GC.
17:18:55 <voidzero> then again.. state probably already implies that
17:19:15 <teurastaja> i have a pretty disturbing question... am I myself? or am I just the same as my own value, if "own" can be used here
17:19:57 <dmwit> Perhaps that question would be better discussed on another channel.
17:20:00 <mauris_> i think it says something about haskell that you can walk in here with a question about MonadPlus and end up at "am I myself?"
17:20:07 <Cale> teurastaja: You're not a-priori something which is mathematically defined, so you have to say what you mean by that first.
17:20:15 <mauris_> and it's a good thing! i like it :>
17:20:29 <voidzero> heh. Yes, I'm with dmwit - although you make it hard to resist
17:20:44 <voidzero> hard to resist going into it i mean.
17:20:51 <Cale> teurastaja: and once you formalise what "you" are in some kind of system (perhaps some kind of mathematical physical theory), then the question can be stated in a way which has a definite answer.
17:21:50 <Cale> teurastaja: In any case, usually reflexivity is an essential property of equality which we don't want to give up on. So usually there is a logical rule of some sort which grants us that x = x, regardless of what x is.
17:21:50 <mauris_> i guess mathematically, though, "equality" is usually reflexive? (or are there some cool weird cases where it isn't?)
17:22:00 <voidzero> i'll just leave it at this - all of us have our own truths; all truths are volatile; and none of them are equal unless they all are.
17:22:07 <fr33domlover> I just found ##philosophy, by the way
17:22:46 <RyanGlScott> I have a generics-related problem. I want to create a generic default signature for a typeclass of kind (* -> * -> *) -> Constraint.
17:22:55 <RyanGlScott> Is this possible using Generic and/or Generic1?
17:22:59 <mauris_> wow, a philosophy channel on freenode sounds like just about the last place i want to ever find myself in
17:23:05 <teurastaja> sorry if i derive into chaos from Monoids and MonadPlus. haskell is just so insightful and plain philosophers know nothing about such questions. Leibniz was a mathematician after all....
17:23:16 <Xe> mauris_: it's #Haskell, it happens
17:23:21 <voidzero> mauris_, heh I know how to top it: #politics.
17:23:36 <mauris_> voidzero: oh goddd
17:24:00 <voidzero> ha ha my thoughts exactly :P gnite you lot. Pleasure as always :-)
17:25:06 <nshepperd_> RyanGlScott: create a default :: (Generic (p a b)) => ...?
17:25:12 <Hafydd> gnite, ignite, lignite, gelignite
17:26:12 <RyanGlScott> nshepperd_: That would prevent you from being able to walk over the a and b terms though, right?
17:26:20 <Pamelloes> How does memory management work via ffi? If I create an object in ffi code, who is responsible to release it and where?
17:26:32 <Cale> mauris_: Yeah, calling something "equality" and/or using the "=" sign for it when it is not reflexive will tend to get you weird looks and/or complaints about your shitty notation.
17:26:43 <RyanGlScott> nshepperd_: e.g., something like Rec1 for Generic1: http://hackage.haskell.org/package/base-4.8.0.0/docs/GHC-Generics.html#t:Rec1
17:27:07 <Cale> mauris_: I guess in the real world we have IEEE floating point :D
17:27:17 <Cale> > (0/0) == (0/0)
17:27:18 <lambdabot>  False
17:27:24 <RyanGlScott> nshepperd_: Er, Par1, I mean.
17:27:42 <enthropy> Pamelloes: somebody has to call free (possibly done by a finalizer for a ForeignPtr)
17:28:01 <teurastaja> Cale: isnt that because 0/0 can take many values at once?
17:28:06 <enthropy> by somebody I mean you do somehow
17:28:23 <arkeet> it's because 0/0 is NaN, and NaN /= NaN according to IEEE754
17:30:30 <nshepperd_> RyanGlScott: i'm not sure :S maybe we need Generic2?
17:31:02 <RyanGlScott> nshepperd_: Yeah, that's what I was wondering. There isn't a Generic2, unfortunately, so I was wondering if any had managed to hack around it before.
17:31:02 <teurastaja> my math teacher said division by zero can take many different values. of course division by zero triggers automatic exceptions but perhaps the meaning is deeper
17:31:32 <ryantrinkle> is there a "standard" dependently typed version of Traversable?
17:31:46 <arkeet> teurastaja: division by zero in mathematics is not defined.
17:31:54 <ryantrinkle> (or, Functor, for that matter)
17:31:59 <arkeet> division of IEEE754 floating point numbers by zero is very well defined.
17:32:06 <arkeet> (as some infinity or NaN)
17:32:10 <arkeet> > 1/0
17:32:12 <lambdabot>  Infinity
17:32:13 <arkeet> > 0/0
17:32:14 <lambdabot>  NaN
17:32:24 <dmwit> ryantrinkle: I'm not sure what that means. But there's mono-traversable, which goes the other direction.
17:32:48 <teurastaja> perhaps infinity is what he meant, perhaps not...
17:32:59 <dmwit> ryantrinkle: I think the answer to your question is "no".
17:33:06 <dmwit> Or perhaps "not in Haskell". =P
17:33:07 <ryantrinkle> dmwit: i'm looking for something with this function: fmap :: (forall a. f a -> g a) -> x f -> x g
17:33:16 <ryantrinkle> where x is the "container" type
17:33:45 <dmwit> Okay. That's dependently typed?
17:33:59 <ryantrinkle> dmwit: perhaps that's not the right word for me to use
17:34:18 <ryantrinkle> it would be useful with things such as Data.Dependent.Map, though
17:34:20 <dmwit> hoist :: Monad m => (forall a. m a -> n a) -> t m b -> t n b
17:34:25 <dmwit> http://hackage.haskell.org/package/mmorph-1.0.4/docs/Control-Monad-Morph.html
17:34:35 <dmwit> Not *quite* the same as what you wrote.
17:34:48 <ryantrinkle> interesting
17:36:00 <dmwit> Uh, there's probably also an MFunctor t constraint there.
17:39:00 <RyanGlScott> Is there a type-level equivalent to undefined?
17:39:09 <RyanGlScott> Something like Undefined :: k?
17:39:19 <dmwit> There is, unfortunately.
17:39:23 <RyanGlScott> ooh
17:39:43 <dmwit> :k Any
17:39:44 <lambdabot> *
17:39:51 <dmwit> This is a lie. Any :: k
17:40:05 <RyanGlScott> Is that from GHC.Exts?
17:40:13 * enthropy thought there were some changes to Any with 7.10
17:40:15 <dmwit> It might be in there. It is definitely in GHC.Prim.
17:40:34 <growthskull> helo
17:40:52 <enthropy> RyanGlScott: you can do stuff like  f `asTypeOf` (undefined :: a -> x a)
17:40:56 <growthskull> i am here to talk about game development
17:41:28 <enthropy> which constrains the type of f a bit... which might be what you're actually looking for?
17:41:37 <RyanGlScott> I think I might (emphasis on might) have a need to use Any in something useful, so this is good to know.
17:42:17 <growthskull> do you know rogue like game ?
17:42:56 <growthskull> please respond before my team kills hya
17:43:06 <arkeet> remind me why Any exists
17:43:45 <RyanGlScott> Here's one useful thing I might be able to do with Any:
17:44:02 <RyanGlScott> I'm trying to use reifyInstances from Template Haskell to figure out if something is an instance of a typeclass.
17:44:03 <peddie> mvc`: is this for production?  I am partway through a patch to add GSL's interpolation interface to hmatrix-gsl, but it might not end up in the main package too soon . . . you could get it from github if it works though
17:44:28 <RyanGlScott> Unfortunately, reifyInstances wants all types to be fully applied, so it's hard to check things like Maybe or Either.
17:44:40 <growthskull> you are fucking like robots
17:44:48 <dmwit> ?where ops
17:44:48 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
17:44:59 --- mode: ChanServ set +o geekosaur
17:45:01 <RyanGlScott> However, I can use Maybe Any or Either Any Any to make it fully applied without worrying about the kinds of the type parameters.
17:45:04 --- mode: geekosaur set +b *!*@gateway/web/freenode/ip.87.89.74.248
17:45:04 --- kick: growthskull was kicked by geekosaur (growthskull)
17:45:14 <RyanGlScott> > $(reifyInstances ''Show [AppT (ConT ''[]) (ConT ''Any)] >>= stringE . show)
17:45:15 <lambdabot>  <hint>:1:1:
17:45:15 <lambdabot>      parse error on input ‘$’
17:45:15 <lambdabot>      Perhaps you intended to use TemplateHaskell
17:45:26 <enthropy> > const () id -- what's the type of id here arkeet ?
17:45:28 <lambdabot>  ()
17:45:29 --- mode: geekosaur set -o geekosaur
17:45:47 <RyanGlScott> Oops. Well, if I knew how to lambdabot, I could demonstrate.
17:46:04 <dolio> arkeet: Which Any?
17:46:08 <arkeet> Any :: k
17:46:10 * enthropy thinks that's an example where ghc picks id :: Any -> Any
17:46:32 <enthropy> which rarely shows up in error messages
17:47:07 <dolio> Yeah, if there's a type variable that becomes ambiguous, but there's no class constraint to use for defaulting, GHC picks Any.
17:47:40 <arkeet> I see
17:47:45 <mvc`> peddie: no, its for a physics lab. So I don't need it to be in main package. 
17:47:58 <mvc`> peddie: please let me know how it goes :D
17:49:12 <dolio> It's hard to find examples where you'd be able to tell outside of GHCi, though.
17:49:32 <arkeet> well, how do we know it picks Any?
17:50:00 <dolio> It's not hard to find examples in GHCi. :)
17:50:16 <arkeet> show me one
17:50:58 <RyanGlScott> Could you implement something equivalent to Any with type families?
17:51:03 <dolio> Do: let foo :: IO a ; foo = return undefined
17:51:03 <RyanGlScott> e.g., type family Undefined :: k?
17:51:16 <dolio> Then do 'x <- foo'. Then do ':t x'.
17:51:25 <arkeet> hmm.
17:51:37 <arkeet> why does it not give me forall a. a?
17:52:44 <enthropy> lambdas/do notation patterns are not generalized/polymorphic
17:53:08 <dolio> forall a. a is not always a type, depending on your extensions.
17:53:39 <dolio> It'd also be an impredicative instantiation of the variable a.
17:53:47 <dolio> And it would only work for kind *.
17:54:37 <arkeet> so it's because it's foo :: forall a. IO a, not IO (forall a. a).
17:54:49 <arkeet> so it has to pick a specific type for a before executing it orsomething?
17:55:31 <Guest87153> that conversation about Any is interesting, do you know a web page where i can read more about that?
17:55:53 <enthropy> Guest87153: the ghc source has "stories"
17:55:54 <ReinH> arkeet: doesn't IO (forall a. a) only "contain" bottom?
17:56:23 <arkeet> ReinH: I'm told I can't write IO (forall a. a) without ImpredicativeTypes.
17:56:23 <ion> Exactly what does ghci print for :t x from above? Any? I'm in bed and I'm afraid my phone doesn't have ghci.
17:56:41 <arkeet> x :: GHC.Prim.Any
17:56:47 <ion> Thanks
17:58:31 <enthropy> Guest87153: I mean long comments like https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcEvidence.hs#L853
17:58:47 * nurupo wonders why most tetorials use main with `do` instead of main with `interact`
17:58:50 <nurupo> *tutorials
17:59:17 <dolio> arkeet: Yes.
17:59:47 <enthropy> somewhere under typecheck/ there's an explanation of Any (but I don't think anything is missing from the explanations here)
17:59:58 <dolio> arkeet: It's important, because you need 'newIORef undefined' to pick a particular type for the variable.
18:00:15 <nshepperd_> nurupo: well, lazy IO is evil and monsterous
18:00:40 <nshepperd_> (and hard for beginners to understand, I assume)
18:01:20 <ion> Also, interact only lets you do a small subset of what arbitrary IO provides.
18:02:10 <RyanGlScott> entropy: Speaking of GHC comment stories, do you know if there's somewhere in the code that explains this behavior?
18:02:37 <RyanGlScott> entropy: If you make a function like f :: (Show (Fixed a)) => Fixed a -> String; f = show
18:02:55 <RyanGlScott> entropy: And then typecheck it, it will have reduced to f :: HasResolution a => Fixed a -> String
18:03:26 <RyanGlScott> Is there an algorithm that GHC uses to reduce the constraint to HasResolution a?
18:03:49 <dolio> It's the algorithm for checking with type classes.
18:04:05 <dolio> There's an instance HasResolution a => Show (Fixed a)
18:04:11 <dolio> So the latter discharges into the former.
18:04:19 <ion> GHC doesn't use algorithms, it uses magic.
18:04:35 <RyanGlScott> Sure, I know where it comes from, but I'm having a hard time replicating this "magic" (as ion put it) in, say, Template Haskell.
18:05:06 <RyanGlScott> I'm wondering if it's simple enough where I could reimplement a small subset of the typechecker in TH.
18:05:16 <dolio> Well, I'm not particularly surprised that it's not exposed to template Haskell.
18:05:38 <dolio> It's simple, but you need a lot of information that you probably don't have available.
18:05:50 <dolio> You need to know all the classes and instances and their relationships.
18:05:58 <RyanGlScott> Well, reifyInstances gives you whether a type is an instance of a typeclass (as well as its instance context)
18:06:23 <RyanGlScott> (Which I why I asked about Any earlier, because actually using reifyInstances turns out to be a bit of a PITA)
18:06:54 <enthropy> RyanGlScott: just call runghc from TH :p
18:07:19 <dolio> Type class handling is actually not well exposed in other parts of GHC, either.
18:07:30 <dolio> Like, now they're first class when you have the Constraint kind enabled.
18:07:57 <dolio> But the resolution check doesn't fire unless the constraint is on the left of an =>
18:08:41 <dolio> So if you have Foo :: Constraint -> *, Foo (C1 a, C2 b) is not the same as Foo (C2 b, C1 a), and Foo (Eq a, Ord a) is not the same as Foo (Ord a). and so on.
18:08:49 <dolio> At least, last I checked.
18:09:45 <RyanGlScott> Well, I do appear to have all the type instance information available from TH, I just need to figure out how to reason about it somehow.
18:10:05 <RyanGlScott> For example, turn (Show Either [a] b) into (Show a, Show b)
18:10:17 <RyanGlScott> But mechanically
18:11:02 <enthropy> if you're just generating code, you can write   f :: Show (Either [a] b) =>  Either [a] b -> String; f = show
18:11:10 <enthropy> but I guess that's not your problem
18:11:35 <RyanGlScott> One way it would be problematic is that (Show (Either [a] b)) requires -XFlexibleContexts, which is kind of annoying.
18:11:53 <arkeet> that's a pretty benign extension.
18:12:02 <arkeet> a lot of code requires that anyway.
18:12:30 <RyanGlScott> True, but most people wouldn't expect a function that just shows a value to require FlexibleContexts (moreover, it shouldn't).
18:12:47 <dolio> RyanGlScott: There are two cases to consider. If you have 'class C a => D a', then you can reduce (C a, D a) to (D a). And you need to follow along such chains recursively. And if you have 'instance Cxt => C (F a b ...)' then you can reduce 'C (F A B ...)' to 'Cxt[a := A, b := B, ...]'.
18:13:20 <dolio> And you have to do the closure of those two operations.
18:13:25 <RyanGlScott> dolio: Where do equality constraints fit into this?
18:13:37 <dolio> Well, for that you have to read more papers.
18:14:22 <RyanGlScott> e.g., if you have (a ~ b) => Show (WTF a b), and data WTFPair a b = (WTF a b) (WTF a b), how would you reduce Show (WTFPair a b)?
18:14:24 <dolio> Also for all of GHC's other tweaks, there are more things to consider.
18:14:28 <RyanGlScott> Things get bananas.
18:15:19 <dolio> For instance, GHC allows non-linear variable use in instance heads.
18:15:24 <dolio> So you have to consider that.
18:15:25 <RyanGlScott> Oh dear.
18:15:48 <RyanGlScott> (And I thought replicating "deriving Show" in TH would be simple...)
18:15:50 <enthropy> Show (WTFPair a b) would be (a ~ b), no?
18:16:10 <enthropy> and there's OverlappingInstances too
18:16:52 <peddie> mvc`: happily, gsl provides a function for numerical integration of interpolated datasets :)
18:16:53 <dolio> Yeah, I don't know if you can even know about overlapping instances in TH.
18:16:59 <RyanGlScott> Oh, that's a good point. I'm not sure how TH's reifyInstances handles that at the moment. Let me check...
18:18:31 * hackagebot poly-arity 0.0.3 - Tools for working with functions of undetermined arity  http://hackage.haskell.org/package/poly-arity-0.0.3 (athanclark)
18:19:40 <enthropy> athan: there's a bit of arity stuff in HList-0.3
18:19:59 <athan> enthropy: I saw some really cool stuff with folds
18:20:02 <dolio> RyanGlScott: If you just want to produce equality constraints that come from an instance context, that's one of the operations I mentioned. But I'm sure they affect the algorithm subsequently.
18:20:02 <athan> in HList I mean
18:20:37 <athan> enthropy: I'm just trying to get some abstract concepts attempted, not sure if this lib will be even useful or not :\
18:22:50 <enthropy> I mean 0.4 coming out some times soon (TM)
18:22:55 <miscyb> does anyone know how i can make a route lead to a static file with yesod?
18:23:55 <miscyb> like if i wanted to make a getHomeR that just went to a static html or css file or something
18:25:26 <johnw> miscyb: there's a way to do static routes that's pretty easy, I just forget how
18:25:29 <johnw> but it's there :)
18:25:32 <mvc`> peddie: woot
18:25:48 <peddie> mvc`: should have a patch for you in an hour or so :)
18:26:09 <miscyb> johnw: i figured there was. I can reference static files, but I just don't quite know how to serve them
18:26:36 <johnw> I think you do it at the WAI level
18:26:50 <athan> miscyb: Look at the wai-static-middleware package, that should give you some kind of static deployment as a middleware
18:30:17 <athan> enthropy: Do you know when it's going to be published? :o
18:32:02 <enthropy> hopefully soon. I think I have worked around https://ghc.haskell.org/trac/ghc/ticket/10009 for the most part
18:42:04 <carter> enthropy: btw, the trustees were looing at the build matrix
18:42:15 <carter> https://github.com/haskell-infra/hackage-trustees/issues/30
18:42:17 <enthropy> looking?
18:42:47 <enthropy> next one is good for 7.6 thru 7.10
18:43:01 <carter> you shoud reply :) 
18:43:02 <hiptobecubic> quickcheck can generate values that depend on other values right?
18:43:03 <carter> yay
18:43:19 <carter> hiptobecubic: by the power of monads yet
18:43:23 <hiptobecubic> for example, I need to generate test input that is a list and a valid index into the list
18:43:32 * hackagebot pred-trie 0.0.10.1 - Predicative tries  http://hackage.haskell.org/package/pred-trie-0.0.10.1 (athanclark)
18:43:36 <hiptobecubic> so a number between 0 and length list
18:43:37 <carter> hiptobecubic: monads :)
18:43:41 <carter> :t (>>=)
18:43:42 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:44:03 <carter> hiptobecubic: so you could generate a list, then compute the length
18:48:32 * hackagebot pred-trie 0.0.10.2 - Predicative tries  http://hackage.haskell.org/package/pred-trie-0.0.10.2 (athanclark)
18:50:12 <hiptobecubic> carter, ....... yes
18:50:17 <carter> :)
18:50:51 <carter> hiptobecubic: my main project at work is basically a really really really fancy use case of random value generation monads
18:56:04 <hiptobecubic> So I have to say, throwing around `arbitrary` and letting the type checker sort it out is pretty excellent
18:56:29 <carter> yeah
18:56:34 <carter> in my case i cant quite do that
18:56:46 <carter> because i've got all sorts fo funky distributions and user configureation things
18:56:55 <carter> plus "fancy" conditional probabilities
18:57:40 <hiptobecubic> Sure, it only takes you so far
18:57:43 <hiptobecubic> but it takes you quite far
18:57:48 <carter> true
18:58:26 <carter> in some sense, i guess the work project i have is a bunch of fancy monoids for stats ingestion, and then a sort of quickcheck for generating test data
18:58:50 <hiptobecubic> carter, have a blog?
18:58:52 <carter> the majority of my income over the past year or two seems to be from industrial monoid code
18:59:04 <carter> hiptobecubic: i've not posted to the blog in a year or so
18:59:10 <carter> i do have a moderately active irc channel i run :)
18:59:18 <heatsink> stats ingestion?
18:59:33 <carter> heatsink: yeah
18:59:39 <carter> ingest a data set
18:59:42 <carter> gimme the stats
19:01:11 <carter> #numerical-haskell is that channle
19:01:14 <carter> i should get to blogging
19:01:17 <heatsink> carter: Is it to examine the properties of an unknown function by feeding random data into it?
19:01:26 <hiptobecubic> So if i've defined a `Gen ([a], Int)` to generate test args for my function, how do i get quickcheck to use it instead of deriving a default implementation?
19:01:35 <carter> heatsink: newtype
19:01:39 <carter> hiptobecubic: newtype
19:01:44 <hiptobecubic> ah of course
19:01:45 <carter> or write the gen code explicitly
19:01:46 <carter> and use it
19:02:21 <hiptobecubic> Well i've written a value of type (Q.Gen ([Int], Int))
19:02:32 <hiptobecubic> is that "writing the gen code explicitly" ?
19:02:39 <carter> hiptobecubic: then  x<- fooTupleGen
19:04:51 <carter> heatsink: pm'd yah :)
19:05:12 <nurupo> any way to make `cycle` less cpu hungry?
19:05:27 <carter> nurupo: dont use it :)
19:05:34 <carter> or write lazier code
19:05:41 <carter> mostly your code is too strict
19:06:49 <nurupo> wanted to have binary being printed in terminal, did `cycle "10110100"` in ghci, but soon my cpu fan turned on and the pc tower got ready to launch in space
19:07:55 <nurupo> carter: right, too eager for me, need to me more lazy :)
19:07:55 <johnw> nurupo: why else did you do, since that function alone will not use much CPU at all
19:08:05 <carter> nurupo: try adding a take 1000 infront
19:08:06 <johnw> s/why/what
19:08:43 <nurupo> carter: but i don't want it to end
19:09:07 <nurupo> i guess i will just use bash printf/echo and sleep
19:09:33 <carter> nurupo: you could use a monadic loop :)
19:10:40 <carter> let foo = do  mapM  (putStr . show) (take 1000 $ cycle "101010") ; foo
19:10:43 <carter> then call foo
19:14:20 <dmwit> replicateM 1000 (putStr "101010") -- ?
19:14:37 <carter> or that
19:15:32 <dmwit> But really, I would expect that "printing 10 as fast as I can" would turn on your CPU pretty hard.
19:15:37 <dmwit> No matter how you do it.
19:15:53 <MuffettMan> I'm going through the typeclassopedia, and came across this sentence :
19:15:55 <MuffettMan> the list functor represents a context of nondeterministic choice; that is, a list can be thought of as representing a single value which is nondeterministically chosen from among several possibilities (the elements of the list).
19:16:13 <dmwit> The real question is not "will it pin a CPU", but "how many bytes will it output per CPU cycle"?
19:16:16 <MuffettMan> Can someone explain why that's a useful way to think about lists?
19:17:03 <dmwit> Define "useful".
19:17:06 <heatsink> It's one use case for lists, MuffetMan
19:17:33 <heatsink> When you want to write code that generates all the possible inputs and then tries them all, such as exhaustive search
19:17:50 <heatsink> list functions are a convenient way to do that
19:18:08 <MuffettMan> I guess useful may have been a poor choice of word, just wondering why the authors felt it was important enough to mention, and why you would ever think of lists in that way
19:18:33 * hackagebot names-th 0.1.0.1 - Manipulate name strings for TH  http://hackage.haskell.org/package/names-th-0.1.0.1 (KeiHibino)
19:18:39 <meretrix> I have a function "foreign export ccall foo :: IO CString" that I want to return a value in C to a "const char*", but I get the error "invalid conversion from ‘HsPtr {aka void*}’ to ‘const char*’"... any idea what's wrong?
19:18:43 <dmwit> You would think of it in that way when you want to do depth-first search.
19:22:37 <peddie> mvc`: you can get an 'hmatrix-gsl' with the interpolation interface, including integration, at https://github.com/peddie/hmatrix -- I put in a pull request to the main project as well, so if it's not urgent, you could wait
19:26:39 <mvc`> peddie: ok. I just changed to the new haskell-ng system in nixos, so I gotta figure out how this all fits in
19:29:16 <peddie> mvc`: no idea about that, sorry -- good luck :)  I tested all the examples I put in the documentation, but don't hesitate to let me know if you get it working and something is amiss!
19:36:09 <Pamelloes> why is "newtype MyType = MyType (ForeignPtr MyType)" a vaild statement while "type MyType = ForeignPty MyType" isn't?
19:36:51 <dramforever> Pamelloes: the second is a infinite type
19:37:10 <Pamelloes> dramforever: I can see that, but why isn't the first?
19:37:28 <dramforever> Pamelloes: there's a level of wrapping
19:37:44 <MuffettMan> I'm trying to implement my own version of Either for practice, I got it, but after messing around with it I realized I don't really understand it too well, in this code, the first implementation works but the second doesn't : http://lpaste.net/131480. The only difference is the order of 'a' and 'b' in the constructors, why does that matter?
19:38:03 <dramforever> Pamelloes: like...
19:38:14 <dramforever> how about data [a] = [] | a : [a]
19:38:34 * hackagebot base-orphans 0.2.0 - Backwards-compatible orphan instances for base  http://hackage.haskell.org/package/base-orphans-0.2.0 (ryanglscott)
19:39:21 <dramforever> MuffettMan: note which value you are expected to map
19:39:48 <dramforever> hint: it's the has the same "type name" in both cases
19:40:59 <Pamelloes> dramforever: hm, so it's because "type" resolves compile time you get an infinite type, whereas in "newtype", the type doesn't become infinite until you try and fully realize it. But since Haskell is lazy, it can still be usable since the type never needs to be fully realized.
19:41:23 <dramforever> yes, IMHO
19:41:48 <dramforever> actually in runtime it's really a value with an infinite type, but there isn't a type so it hardly matters
19:42:09 <Pamelloes> True
19:42:11 <dramforever> wait wait
19:42:20 <dramforever> nothing about "lazy" here
19:43:35 <dramforever> how about this: newtype T = C {unT :: F T}
19:43:45 <dramforever> C :: F T -> T, unT :: T -> F T
19:43:57 <dramforever> there isn't anything infinite in the types
19:44:16 <MuffettMan> dramforever: I'm trying to think about that, but I have one more question, why is it only instance Functor (Either a), why not instance Functor (Either a b), similarly, why do I only have to do instance Functor Maybe, instead of instance functor (Maybe a)?
19:44:58 <enthropy> :k Either a b
19:44:59 <lambdabot> Not in scope: type variable ‘a’
19:44:59 <lambdabot> Not in scope: type variable ‘b’
19:45:03 <enthropy> :k Either () ()
19:45:04 <lambdabot> *
19:45:06 <enthropy> :k Either ()
19:45:07 <lambdabot> * -> *
19:45:11 <dramforever> yep kind stuff
19:45:13 <dramforever> :k Functo
19:45:14 <lambdabot>     Not in scope: type constructor or class ‘Functo’
19:45:14 <lambdabot>     Perhaps you meant ‘Functor’ (imported from Control.Monad.Writer)
19:45:14 <Pamelloes> dramforever: Well, in the FPtr case it is actually infinite ;) But you're right, my comment about laziness was referring to a type like "data List' a = List' a (List' a)" not the type cycle.
19:45:15 <dramforever> :k Functor
19:45:16 <lambdabot> (* -> *) -> Constraint
19:46:03 <dramforever> Pamelloes: yes I think that's correct. anyone more experienced should add to this
19:46:09 <MuffettMan> Ah okay, so when you only give Either one argument it turns it into a function from * -> *? is * the same thing as a wildcard like a?
19:46:10 <Pamelloes> mhm
19:46:17 <dramforever> :k Functor (Either ())
19:46:18 <lambdabot> Constraint
19:46:23 <dramforever> MuffettMan: not really
19:46:41 <dramforever> "full" types have kind *
19:46:44 <tejing> is there a library I can use to find the null space of a matrix of Rationals? hmatrix works great if I'm content with doubles, but it would be nice to solve my problem exactly
19:46:51 <dramforever> so Either Either Either doesn't make sense
19:47:12 <ronh> MuffettMan not a function.. a type of * -> * kind has to accept one type to form a "complete" type (which has a kind of *)
19:47:56 <joneshf-laptop> okay, this seems too good to be true, so what are the drawbacks? http://okmij.org/ftp/Haskell/typecast.html#deepest-functor
19:48:18 <MuffettMan> Ah, I got confused with kinds and types, so to make the kind complete it has to take both types? And when only one type is given, the constraint for functor is satisfied?
19:48:34 * hackagebot hspec-core 2.1.6 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-core-2.1.6 (SimonHengel)
19:48:36 * hackagebot hspec-discover 2.1.6 - Automatically discover and run Hspec tests  http://hackage.haskell.org/package/hspec-discover-2.1.6 (SimonHengel)
19:48:38 * hackagebot hspec 2.1.6 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-2.1.6 (SimonHengel)
19:48:59 <joneshf-laptop> i know it uses overlapping instances, but I'm not sure if it's an issue in this case
19:49:17 <dramforever> joneshf-laptop: I guess it's generally bad
19:49:28 <dramforever> it's hard to control
19:49:53 <dramforever> like in F (G a), you don't know if a is a functor application
19:50:33 <joneshf-laptop> dramforever, i don't follow, what do you mean by "a is a functor application?"
19:50:44 <dramforever> MuffettMan: only when one type is applied to Either, the result can be applied to Functor
19:51:05 <dramforever> joneshf-laptop: like F (G (H Int)) is different from F (G Int)
19:51:13 <dramforever> (where F G H are functors)
19:51:31 <dramforever> I guess that's why it's undecidable/overlapping
19:52:10 <joneshf-laptop> dramforever, ah, I see. So you're saying it's hard to force the `f_map` to apply to `H Int` vs `Int`?
19:52:34 <dramforever> yes, it's hard to decide which one to match
19:52:39 <dramforever> so hard it gets undecidable
19:52:57 <joneshf-laptop> gotcha
19:53:49 <joneshf-laptop> I assumed one would only want this kind of thing when they had a monomorphic function to `f_map` over.
19:54:03 <joneshf-laptop> s/over/with/ ?
19:54:04 <dramforever> how about this: for example, once I wrote this:
19:54:34 <dramforever> class LiftIO a b where io :: a -> b
19:54:36 <joneshf-laptop> or, monomorphic enough to decide when to stop `f_map`ping
19:54:48 <mishac> Hi Guys,
19:54:57 <dramforever> instance MonadIO m => LiftIO (IO a) (m a) where io = liftIO
19:55:01 <mishac> does anyone have a guide on how to install ghc 7.10.1 on ubuntu?
19:55:19 <dramforever> instance LiftIO a b => liftIO (x -> a) (x -> b) where io = {- insert something here -}
19:55:47 <dramforever> so that I could write (io putStrLn "blah") or (io hPutStr stderr "Error")
19:55:55 <dramforever> but it isn't really idiomatic
19:56:23 <arkeet> mishac: https://launchpad.net/~hvr/+archive/ubuntu/ghc
19:56:43 <joneshf-laptop> dramforever, heh, i've been messing around with similar stuff tonight :)
19:57:01 <enthropy> joneshf-laptop: TypeCast is (~) -- so probably you don't need overlapping instances
19:57:18 <MuffettMan> dramforever: Thank you, one last question for now, why is it that the order of the constructors matters? What's the difference between Either a b = Left a | Right b, and Either a b = Left b | Right a? From my understanding, it's pretty much saying Either is an ADT that has two constructors, which can take different types, one constructor is Left that takes type a, and one is Right that takes type b. So
19:57:24 <MuffettMan>  when you switch a and b, I don't see how it changes anything since they are wildcards that mean 'any type'
19:57:43 <dramforever> No
19:57:47 <joneshf-laptop> enthropy, the first one still overlaps though
19:57:59 <dramforever> are f a b = a - b and f a b = b - a the same?
19:58:09 <joneshf-laptop> enthropy, instance IsCollection (m a)       (m ())
19:58:57 <MuffettMan> No they're not
19:59:30 <dramforever> when you fmap, you are supposed to map the second argument to Either, right
19:59:37 <dramforever> do you get it?
19:59:41 <dramforever> d/right/
19:59:46 <ronh> the order of constructors doesn't matter, the order of types does. You can't partially apply Either's second type to get * -> * kind.. you have to go in order
20:00:03 <dramforever> you should map b, not a in Either a b
20:00:12 <enthropy> joneshf-laptop: oh true
20:03:10 <joneshf-laptop> wait what?
20:03:43 <joneshf-laptop> how do the two definitions differ?
20:04:16 <MuffettMan> When you say map the second argument to Either, do you mean what (+2) is in this case : fmap (MyRight 5) (+2)? Or do you mean Either's second argument, b?
20:04:22 <joneshf-laptop> or do you all mean syntactically they're different?
20:04:31 <joneshf-laptop> because semantically they're the same right?
20:04:32 <MuffettMan> Sorry it's taking a while for me to grasp this
20:05:06 <dramforever> MuffettMan: b
20:08:26 <MuffettMan> Okay, so I'm used to thinking of mapping a function, not a type, b is a type right? You're saying that b gets mapped to (Either a)? 
20:09:10 <dramforever> hmm....sorry if I messed that up
20:09:26 <dramforever> fmap :: (a -> b) -> Either x a -> Either x b
20:09:41 <dramforever> understand?
20:11:21 <dramforever> @ping MuffetMan
20:11:21 <lambdabot> pong
20:11:41 <dramforever> lol
20:17:02 <MuffettMan> Hey sorry I got disconnected, college wi-fi sucks. I'm beginning to understand it a bit better, I'm gonna play around with it a bit more. Thanks so much for all the help
20:29:14 <HaskellStudent81> I'm working out of Discrete Math Using a Computer, and I'm not sure how to do this exercise:
20:29:16 <HaskellStudent81> Write (!!) , a function that takes a natural number n and a list and selects the n th element of the list. List elements are indexed from 0, not 1, and since the type of the incoming number does not prevent it from being out of range, the result should be a Maybe type. For example,
20:29:43 <HaskellStudent81> [1,2,3]!!0 ==> Just 1 [1,2,3]!!2 ==> Just 3 [1,2,3]!!5 ==> Nothing
20:30:05 <HaskellStudent81> I want to make an iterator variable to count the elements, but you can't do that in Haskell
20:30:13 <HaskellStudent81> so I'm not sure what I should do?
20:30:28 <simpson> HaskellStudent81: Analyze n by cases.
20:30:48 <HaskellStudent81> what does that mean?
20:31:11 <simpson> Well, you've written stuff that recurses on lists already, right?
20:31:19 <HaskellStudent81> right
20:31:25 <HaskellStudent81> a little
20:31:48 <nurupo> HaskellStudent81: make a function with integer argument, then make it call itself increating the integer
20:31:49 <simpson> Okay. Think about the case where n is 0.
20:32:01 <nurupo> here is your iterator variable
20:32:43 <HaskellStudent81> nurupo thats what I want to do but I thought you couldnt do that
20:33:01 <HaskellStudent81> OH
20:33:03 <nurupo> *increasing
20:33:08 <nurupo> i.e. incrementing
20:33:38 <HaskellStudent81> I was thinking like resetting the variable n = n + 1, but I can just say n + 1 on each recursion, without ever changing n
20:34:17 <nurupo> well, you can't modify variables in Haskell
20:34:18 <simpson> Right. You can't do that.
20:34:24 <nurupo> there is no assignment operator
20:34:34 <HaskellStudent81> right nurupo that was my question
20:34:43 <HaskellStudent81> I think I get it now
20:35:20 <HaskellStudent81> is there a way to ignore the server messages, like users quitting etc?
20:35:21 <nurupo> f xx == <stop condition>) then foo else f (x+1)
20:35:52 <nurupo> f x
20:35:53 <nurupo>    | x = <stop condition> = foo
20:35:53 <nurupo>    | otherwise = f (x+1)
20:35:58 <nurupo> that's what i meant :)
20:36:14 <nurupo> and it should be "x =="
20:39:12 <rwiggins> HaskellStudent81: if you're talking about irc, some irc clients (like weechat) have options to filter out join/part messages, etc... 
21:10:33 <HaskellStudent81> Still having trouble, any help? Details in the paste http://lpaste.net/131485
21:11:25 <ronh> iterator will stay 0.. forever
21:11:30 <simpson> HaskellStudent81: Consider: getEle (x:_) 0 = ...
21:11:37 <mvc`> peddie: I was able to build it, but got "spline_eval_integ: input domain error"
21:11:39 <ronh> and that shouldn't compile
21:11:40 <geekosaur> (1) you're using ghci syntax in ghc
21:12:08 <geekosaur> (2) you should not asusme you can have a handy "variable" somewhere out of scope, because Haskell doesn't have variables in that sense
21:12:39 <geekosaur> (out of scope of getEle and/or helpers that is)
21:13:16 <geekosaur> think about it a bit, you should realize that you don't actually need a separate iterator
21:13:37 * hackagebot handa-gdata 0.7.0.3 - Library and command-line utility for accessing Google services and APIs.  http://hackage.haskell.org/package/handa-gdata-0.7.0.3 (RyanNewton)
21:15:39 <Pamelloes> What does "Ix{Int}.index: Index (2) out of range ((0,0))" mean?
21:16:08 <Pamelloes> Obviously some array is being accessed at an invalid index, but is there more information in there beyond that?
21:16:26 <geekosaur> you declared an array with bounds (0,0)
21:17:04 <Pamelloes> So like []?
21:17:28 <geekosaur> it has 1 element
21:17:38 <geekosaur> min array index = 0, max array index = 0
21:18:07 <Pamelloes> hm?
21:18:23 <geekosaur> the max element index is the size - 1
21:18:35 <geekosaur> as a 10-element list has indexes 0 .. 9
21:18:42 <geekosaur> same with arrays
21:19:33 <Pamelloes> What would the bounds of an empty array be?
21:19:46 <Pamelloes> (0,-1)? That doesn't make much sense.
21:21:21 <simpson> HaskellStudent81: Okay. So, the syntax that I was trying to hint at is for defining getEle using a pattern match.
21:21:30 <edwardk> you have to make the array, you put the bounds in then
21:21:36 <edwardk> you want a range which has no inhabitants
21:21:50 <edwardk> (0,-1)   (123,-12931293), etc.
21:21:51 <edwardk> all work
21:21:54 <simpson> (x:_) matches a constructor of [a], and 0 matches a constructor of Int.
21:22:25 <geekosaur> actually I don;t think they do, they just want to understand: What does "Ix{Int}.index: Index (2) out of range ((0,0))" mean?
21:22:36 <edwardk> is there an Ix instance for ()?
21:22:37 * Maxdamantus blames the Romans.
21:22:42 <edwardk> > range ((),())
21:22:44 <lambdabot>  [()]
21:22:47 <edwardk> yep
21:22:52 <geekosaur> and the answer to that is that some array has minbound 0, maxbound 0, and something attempted to do something with index 2
21:22:54 <edwardk> guess you can't make an empty array with an () index.
21:23:36 <Pamelloes> Yep... So is there any way to find out which array this is?
21:24:07 <edwardk> Pamelloes: by careful reasoning about the code involved =)
21:24:51 <Pamelloes> That's unfortunate. Is there any way to look at the post-transformed template haskell code?
21:31:44 <simpson> HaskellStudent81: Bingo! You got it.
21:34:18 <mvc`> peddie: also, if I enter a non-monotonically increasing series it crashes
21:34:28 <mvc`> peddie: (although it's understandable why it wouldn't work)
21:36:12 <mvc`> peddie: that said, looks like it works :D
21:37:16 <geekosaur> Pamelloes, one of the  -d options, I think -ddump-splices
21:37:52 <Pamelloes> That's what google said as well ;) Still playing around with cabal's verbosity settings to get it to show up, though.
21:41:01 <deezn> Hi Guys.. can someone clarify what is happening here: 1/2 down the page of http://learnyouahaskell.com/making-our-own-types-and-typeclasses#algebraic-data-types
21:41:07 <Pamelloes> Oh god. It's way worse than I thought D:
21:41:15 <deezn> here: type LockerMap = Map.Map Int (LockerState, Code)
21:43:43 <kadoban> deezn: What specifically about it?
21:44:11 <geekosaur> not sure what the question is
21:44:19 <deezn> I don’t understand: what is going on in: Map.Map Int (LockerState, Code) 
21:44:34 <deezn> What is the Map.Map bit?
21:44:42 <geekosaur> it's a Data.Map whose key is an Int and whose associated value is a tuple (LockerState, Code)
21:45:13 <deezn> Ok so the Map.Map is its type?
21:45:23 <geekosaur> import qualified Data.Map as Map   <-- this is relevant
21:45:25 <rwiggins> note that in the beginning of the code, he imports Data.Map as Map, so Map.Map is actually the Map type from Data.Map. 
21:45:52 <deezn> Yeah I saw that. But in the combination of everything was not clear to me. 
21:45:57 <geekosaur> it's a type Map qualified by the module name Map, which the import line defines as an alias for the module Data.Map
21:46:29 <deezn> Why does it need to be Map.Map and not just Map?
21:46:51 <rwiggins> deezn: are you familiar(ish) with Python?
21:47:19 <deezn> hmm only used it a little.. but feel free to have a shot.
21:47:43 <geekosaur> deezn: because "import qualified"
21:47:59 <rwiggins> ah, well, the import statement there is analogous to python's "import blah as b" or whatever. 
21:48:00 <geekosaur> and that's done because many of the names defined in it collide with functions on lists from ther Prelude
21:48:35 <geekosaur> note that an alternative import convention, not udsed by LYAH, is: import qualified Data,Map as Map; import Data.Map (Map)
21:48:41 <geekosaur> which indeed lets you call the type just Map
21:49:14 <geekosaur> but avoids the collision with the list functions because you must still say e.g. Map.lookup to get the one on Map instead of the one on lists
21:49:45 <geekosaur> (that's actually a bad example because Prelude doesn't export lookup; more relevant if you do the traditonal unqualified import of Data.List)
21:51:23 <deezn> “it's a Data.Map whose key is an Int and whose associated value is a tuple (LockerState, Code)” — >So the purpose of this to to basical specifically define the types so that it is no longer parameterised..? 
21:51:35 <geekosaur> it's a shorthand
21:52:02 <geekosaur> you can use the type LockerMap in places where you otherwise would have to write out Map.Map Int (LockerState, Code)
21:52:39 <deezn> ok.. 
21:52:55 <geekosaur> lockerLookup :: Int -> LockerMap -> Either String Code
21:53:13 <geekosaur> would have to be written: lockerLookup :: Int -> Map.Map Int (LockerState, Code) -> Either String Code
21:53:21 <geekosaur> which gets annoying if you have to use that type a lot
21:54:54 <deezn> ok..
21:57:38 <kadoban> So this is kind of a dumb question, but … for programming competition websites, they all only seem to accept a single source file. Is there any tool or technique to translate a normal haskell file (with imports of other modules I've written), to a single source file with all the crap it needs? I hate having to copy-paste all this crap around and try to remember what's what.
21:58:01 <Welkin> kadoban: fuck those websites
21:58:09 <Welkin> don't waste your time
21:58:21 <Ralith> ^
21:58:21 <kadoban> Basically I guess I want it to act like a crappy CPP include, except ideally leave out unused stuff.
21:58:26 <kadoban> Welkin: Eh, they're kinda fun though.
21:59:02 <rwiggins> kadoban: for those sites, you just sort of have to write everything in one file.
21:59:13 <deezn> Thanks for the clarification.. 
21:59:36 <rwiggins> I doubt there is a tool that does what you're looking for... it doesn't sound like something most people ever want to do.
22:00:46 <kadoban> Yeah, I guess. I wonder if it'd be possible to write using some kind of GHC API or whatever. I know ghc-mod can tell what imports are unused, and can tell what definitions aren't used … hmm.
22:07:11 <enthropy> kadoban: http://www.umiacs.umd.edu/~hal/HAllInOne/index.html
22:08:47 <kadoban> enthropy: Holy crap, that sounds perfect. Thanks!
22:09:17 <enthropy> there are lots of limitations on that page
22:09:51 <kadoban> Yeah, none of them that I see actually affect me though I don't think
22:10:51 <hiptobecubic> kadoban, oh :) It's you.
22:11:14 <kadoban> hiptobecubic: Haha, hiya :) Any luck on that problem, if you happened to work on it more
22:11:46 <hiptobecubic> kadoban, no. timout on the same cases as before. Although I haven't gone whole hog and written everything in ST. I was hoping not to have to
22:12:19 <kadoban> Hmm
22:12:28 <hiptobecubic> http://lpaste.net/131487
22:13:06 <hiptobecubic> ignore the silly double call to `go` in quickMedian' for now. The real problem is partitioning, which is 98% of the time
22:24:51 <lpaste> nurupo pasted “How to rotate a 2d matrix by 135 degrees?” at http://lpaste.net/131488
22:28:56 <Pamelloes> Yay seg faults.
22:44:02 <nurupo> given number 3, how can i get [(1, 1), (1, 2), (2, 1), (3, 1), (2, 2), (1, 3), (3, 2), (2, 3), (3, 3)] in any order?
22:44:43 <nurupo> looks like `permutations [1..n]` with n=3 doesn't do what i want
22:46:20 <nurupo> [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]
22:46:20 <kadoban> > let l = [1..3] in (,) <$> l <*> l
22:46:21 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
22:46:25 <nurupo> that makes more sense
22:46:34 <nurupo> hm
22:46:35 <hiptobecubic> crazy old list monad
22:46:59 <nurupo> now to figure out what it's doing, heh
22:47:01 <hiptobecubic> or applicative in this case I guess
22:47:34 <hiptobecubic> nurupo, it's easier to think about as a monad i think. and write it out in do notation
22:47:41 <kadoban> Hehe, yeah. nurupo: in words, it's the cartesian product of the list with itself I think?
22:47:51 <hiptobecubic> do a <- l; b <- l; return (a, b)
22:48:27 <hiptobecubic> "Take an element from l and call it 'a', take one and call it 'b', then return the pair"
22:48:37 <hiptobecubic> and it does this for all possible a and b
22:48:46 <nurupo> <interactive>:1101:23: Not in scope: `<$>' <interactive>:1101:29: Not in scope: `<*>'
22:48:55 <hiptobecubic> nurupo, import Control.Applicative
22:48:56 <kadoban> nurupo: Control.Applicative
22:49:43 <kadoban> nurupo: You also need tuple sections for (,), or just use  \a b -> (a, b)   instead there
22:51:38 <ronh> > join (liftA2 (,)) [1,2,3]
22:51:39 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
22:51:59 <lpaste> nurupo revised “How to rotate a 2d matrix by 135 degrees?”: “No title” at http://lpaste.net/131488
22:52:10 <nurupo> that's what i'm using it for ^
22:52:51 <nurupo> figured indices in the rotated matrix add up to the same number in rows
22:53:13 <kadoban> Heh, that's a cute usage of join.
22:53:14 <Hijiri> you don't need tuple sections for (,)
22:53:24 <kadoban> Oh, don't you?
22:53:35 <Hijiri> you only need it when using like (a ,) or (, b)
22:53:40 <ronh> or (,,) ?
22:53:46 <kadoban> Oic. I always get that confused
22:53:51 <Hijiri> I don't think you need it for (,,) either, not sure
22:53:52 <nurupo> so going to filter that for sum = 2, 3, 4, 5 and 6 to get indices of elements i need for each column
22:58:45 <nurupo> > nub $ map (\(a, b) -> a + b) $ let l = [1..3] in (,) <$> l <*> l
22:58:46 <lambdabot>  [2,3,4,5,6]
23:00:16 <hiptobecubic> nub sucks
23:00:47 <kadoban> nurupo: There's gotta be a faster way to do that. Are you just getting all of the possible sums of the two? That seems pretty easy, it's just 2 .. n*2 isn't it?
23:01:23 <hiptobecubic> kadoban is much more helpful than I am :)
23:01:36 <kadoban> Haha
23:02:15 * hiptobecubic throws a tomato at nub
23:06:30 <nurupo> just realized `let l = [1..3] in (,) <$> l <*> l` won't work for me
23:07:03 <nurupo> it's more like i have [1..n] [1..m] and i want to pair them up, when `let l = [1..3] in (,) <$> l <*> l` pairs [1..n] [1..n]
23:08:17 <ronh> pair them up how?
23:08:20 <nurupo> i.e. [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3), (4, 1), (4, 2), (4, 3)] for [1..4] x [1..3]
23:08:43 <kadoban> nurupo:  … so do that. (,) <$> [1..n] <*> [1..m] , but then again your subsequent question leads me to believe that's not actually what you want anyway?
23:08:50 <tejing> nurupo: (,) <$> [1..n] <*> [1..m]
23:09:11 <nurupo> kadoban: which question is that?
23:09:17 <ronh> or: liftA2 (,) [1..n] [1..m]
23:09:24 <kadoban> nurupo: The nub thing
23:09:53 <nurupo> oh, yes, those are not sums of 2
23:10:06 <nurupo> you assumed that i needed sums of two incorrectly
23:10:23 <kadoban> Sums of two?
23:10:48 <nurupo> ><kadoban> nurupo: There's gotta be a faster way to do that. Are you just getting all of the possible sums of the two?
23:11:15 <kadoban> nurupo: Sums of /the two/, not sums of two.
23:15:38 <ronh> > splitOn "|" "a|bb|ccc|d"
23:15:40 <lambdabot>  ["a","bb","ccc","d"]
23:16:02 <ronh> wasn't there a Prelude or Data.List equivalent?
23:38:43 * hackagebot hsini 0.4.2 - Package for user configuration files (INI)  http://hackage.haskell.org/package/hsini-0.4.2 (MagnusTherning)
