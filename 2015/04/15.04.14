00:02:26 <mjrosenb> gah
00:02:31 * mjrosenb is so confused
00:02:46 <mjrosenb> I can run cabal build from ~/projects/pqueue
00:03:02 <mjrosenb> but it fails when I try to install from ~/projects/reactive-banana-sdl2
00:04:56 <arkeet> mjrosenb: oh are you saying pqueue fails to compile?
00:05:18 <arkeet> hpd: have a look at the Numeric module
00:05:29 <arkeet> :t showFFloat
00:05:29 <lambdabot> RealFloat a => Maybe Int -> a -> ShowS
00:05:30 <mjrosenb> arkeet: yes.
00:05:32 <mjrosenb> GAH.
00:05:40 <arkeet> gah.
00:06:08 <arkeet> mjrosenb: not terribly surprising I guess, it hasn't been updated since 2012.
00:06:22 * hackagebot dataflow 0.5.4.0 - Generate Graphviz documents from a Haskell representation.  http://hackage.haskell.org/package/dataflow-0.5.4.0 (owickstrom)
00:06:36 <mjrosenb> gah.
00:07:00 <mjrosenb> now the error message is pointing to a line that contains -----------------------------------------------------------------------------
00:07:04 <arkeet> haha
00:08:05 <hpd> arkeet: I already wrote, that showFFloat does not what I want
00:08:19 <arkeet> oh sorry I misread.
00:09:52 <arkeet> perhaps you could just drop trailing zeros? :p
00:11:35 <arkeet> or write your own using floatToDigits
00:11:59 <arkeet> :(
00:16:22 * mjrosenb wonders if this will allow emacs' haskell integration to function now
00:16:32 * mjrosenb has never actually written a .cabal file before
00:19:24 <mjrosenb> it looks like haskell assumes that all unused type variables in a type definition have kind '*'
00:19:25 <srhb> mjrosenb: Who has! cabal init all the way.
00:19:38 <mjrosenb> srhb: let me clarify
00:19:54 <mjrosenb> srhb: I have never worked on a project that has a .cabal file.
00:20:04 <srhb> mjrosenb: Sorry, it was a poor joke. :)
00:20:06 * mjrosenb does not want this behavior from type
00:36:23 * hackagebot wl-pprint 1.2 - The Wadler/Leijen Pretty Printer  http://hackage.haskell.org/package/wl-pprint-1.2 (NoamLewis)
00:38:40 <dmj_> Monad control lets me control the monads
00:38:58 <dmj_> To control a monad is a noble task
00:39:31 <tripped> and a noble spirit embiggens the smallest man
01:00:06 <jle`> mjrosenb: you can explicitly give a kind signature, i guess :)
01:00:19 <jle`> or maybe you can use polykinds
01:00:26 <jle`> i wonder if polykinds does what you want
01:00:43 <jle`> oh
01:00:45 <jle`> it does :O
01:00:54 <jle`> :set -XPolyKinds
01:00:57 <jle`> data Foo a b = Foo b
01:01:00 <jle`> :k Foo
01:01:02 <lambdabot> Not in scope: type constructor or class ‘Foo’
01:01:05 <jle`> Foo :: k -> * -> *
01:16:25 <Xnuk> :t xor
01:16:26 <lambdabot> Bits a => a -> a -> a
01:26:05 <Phillemann> Is there a preferred library for dates, times and durations in hackage? For time stamps, I'm currently using clock, but it doesn't seem to have a nice duration type.
01:26:24 * hackagebot bitcoin-script 0.10.0 - Compilation, manipulation and decompilation of Bitcoin scripts  http://hackage.haskell.org/package/bitcoin-script-0.10.0 (solatis)
01:28:38 <solatis> Phillemann, Haskell Platform ships with the `time` package, in case that matters anything to you
01:29:10 <jle`> i think it might also be included with ghc too
01:29:26 <solatis> yeah i also got that impression
01:29:31 <solatis> https://www.haskell.org/platform/doc/2014.2.0.0/ghc/libraries/time-1.4.2/Data-Time.html
01:29:36 <solatis> note the /ghc/ path
01:29:40 <Phillemann> Oh
01:30:29 <Phillemann> Indeed, I'm already using time. :D There seems to be some overlap in function names and types, so hoogle directed me to the clock package.
01:33:31 <_ryan> hi can anyone guide me about the case?
01:37:52 <solatis> _ryan, what do you mean ?
01:37:54 <frerich> _ryan: Do you mean 'case' as in 'case expression' or is 'the case' a reference to something you wrote earlier and I missed it? :-)
01:38:43 <mauke> or is it about case significance in haskell?
01:39:50 <frerich> Or maybe a typo and you meant to talk about some race in a concurrent program?
01:40:04 <srhb> Or a new type of container!
01:40:11 <_ryan> oh ok i change my mind - another question - http://lpaste.net/130685
01:40:36 <_ryan> but also it include the  case statement.
01:40:49 <mauke> that's a case expression
01:41:25 <_ryan> *expression
01:41:40 <mauke> what's newsMetaTitle and what does it mean to be "null"?
01:41:44 <srhb> _ryan: let nmt = newsMetaTitle n in if null nmt then newsTitle n else nmt
01:42:04 <srhb> Or something to that extent.
01:42:42 <srhb> Or you could use guards.
01:43:04 <hexagoxel> mjrosenb: btw i have recently tried contacting the pqueue maintainer; got no reply yet (i fixed the problems locally as well for now)
01:43:48 <_ryan> srhb: how do i do that?
01:44:03 <srhb> _ryan: Use guards? Look it up in whatever reference book you're using for learning Haskell. :)
01:44:36 <_ryan> so instead of case i will use guard, is that right?
01:44:43 <srhb> No, you will be combining the two.
01:44:53 <srhb> The guards get rid of the if-then-else
01:46:44 <hexagoxel> mjrosenb: when you make a local copy, i recommend bumping the version in some way and depending exactly on that version. reduces the risk of cabal accidentally installing the hackage version for some reason.
01:46:59 <_ryan> so in just (Entity _ n) ->  -- guard code?
01:47:19 <Raydiation> lets say i want to concat a string x times depending on a number, whats the best way to do that?
01:47:35 <_ryan> srhb: so in just (Entity _ n) ->  -- guard code?
01:48:05 <frerich> Raydiation: You could use 'replicate' to replicate a string x times and then 'concat' it.
01:48:08 <srhb> _ryan: Yes. What book are you using for the basic (non-Yesod specific) Haskell things? I may be able to point you to the relevant chapter.
01:48:11 <frerich> > concat . replicate 3 $ "ohmygod"
01:48:13 <lambdabot>  "ohmygodohmygodohmygod"
01:48:20 <Raydiation> ty
01:48:23 <_ryan> learn you a haskell
01:48:39 <_ryan> srhb: http://learnyouahaskell.com/syntax-in-functions#guards-guards
01:48:45 <srhb> Yeah, that.
01:51:39 <srhb> _ryan: So combining them looks like case foo of bar | condition1 -> ...; condition2 -> ...;
01:56:32 * hackagebot amazonka 0.3.4 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.3.4 (BrendanHay)
01:56:34 * hackagebot amazonka-core 0.3.4 - Core functionality and data types for Amazonka libraries.  http://hackage.haskell.org/package/amazonka-core-0.3.4 (BrendanHay)
01:56:36 * hackagebot amazonka-config 0.3.4 - Amazon Config SDK.  http://hackage.haskell.org/package/amazonka-config-0.3.4 (BrendanHay)
02:00:22 <_ryan> srhb: hi i follow you suggestion - it gives me an error of - parse error (possibly incorrect indentation or mismatched brackets)
02:01:46 * hackagebot amazonka-sns 0.3.4 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.3.4 (BrendanHay)
02:01:48 * hackagebot amazonka-sqs 0.3.4 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.3.4 (BrendanHay)
02:01:50 * hackagebot amazonka-glacier 0.3.4 - Amazon Glacier SDK.  http://hackage.haskell.org/package/amazonka-glacier-0.3.4 (BrendanHay)
02:01:52 * hackagebot amazonka-cloudhsm 0.3.4 - Amazon CloudHSM SDK.  http://hackage.haskell.org/package/amazonka-cloudhsm-0.3.4 (BrendanHay)
02:01:54 * hackagebot amazonka-iam 0.3.4 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.3.4 (BrendanHay)
02:03:52 <srhb> _ryan: Not enough information.
02:05:30 <_ryan> srhb: i update the paste - http://lpaste.net/130685
02:05:59 <srhb> _ryan: You should still use the case expression to deal with the Nothing and Just cases separately
02:06:30 <srhb> Then use guards in the Just n case to figure out whether newsMetaTitle n is null or not
02:06:56 * hackagebot amazonka-route53-domains 0.3.4 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.3.4 (BrendanHay)
02:06:58 * hackagebot amazonka-directconnect 0.3.4 - Amazon Direct Connect SDK.  http://hackage.haskell.org/package/amazonka-directconnect-0.3.4 (BrendanHay)
02:07:00 * hackagebot amazonka-elb 0.3.4 - Amazon Elastic Load Balancing SDK.  http://hackage.haskell.org/package/amazonka-elb-0.3.4 (BrendanHay)
02:07:02 * hackagebot amazonka-cloudformation 0.3.4 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.3.4 (BrendanHay)
02:07:04 * hackagebot amazonka-sts 0.3.4 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.3.4 (BrendanHay)
02:09:31 <_ryan> srhb: so the i will put the guard on my Just case?\
02:09:40 <srhb> _ryan: Yes
02:12:05 <_ryan> srhb: Just (Entity _ n) -> ???
02:12:06 * hackagebot amazonka-cloudtrail 0.3.4 - Amazon CloudTrail SDK.  http://hackage.haskell.org/package/amazonka-cloudtrail-0.3.4 (BrendanHay)
02:12:08 * hackagebot amazonka-elasticache 0.3.4 - Amazon ElastiCache SDK.  http://hackage.haskell.org/package/amazonka-elasticache-0.3.4 (BrendanHay)
02:12:10 * hackagebot amazonka-importexport 0.3.4 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.3.4 (BrendanHay)
02:12:12 * hackagebot amazonka-s3 0.3.4 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.3.4 (BrendanHay)
02:12:14 * hackagebot amazonka-swf 0.3.4 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.3.4 (BrendanHay)
02:12:48 <bergmark> mjrosenb: if a package fails to compile and the maintainer is unreachable please open an issue on https://github.com/haskell-infra/hackage-trustees/issues
02:12:54 <srhb> _ryan: Just (Entity _ n) | null (newsMetaTitle n) -> ...; otherwise -> ...
02:15:56 <srhb> I wonder how crazy it would be to have Hackage buildbot all the things.... :-)
02:16:09 <srhb> (Pretty crazy)
02:17:01 <aleator> I just got a desire to use Either String () as a return type of input validator. Does this make sense?
02:17:16 * hackagebot amazonka-sdb 0.3.4 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.3.4 (BrendanHay)
02:17:18 * hackagebot amazonka-autoscaling 0.3.4 - Amazon Auto Scaling SDK.  http://hackage.haskell.org/package/amazonka-autoscaling-0.3.4 (BrendanHay)
02:17:20 * hackagebot amazonka-codedeploy 0.3.4 - Amazon CodeDeploy SDK.  http://hackage.haskell.org/package/amazonka-codedeploy-0.3.4 (BrendanHay)
02:17:22 * hackagebot amazonka-cloudfront 0.3.4 - Amazon CloudFront SDK.  http://hackage.haskell.org/package/amazonka-cloudfront-0.3.4 (BrendanHay)
02:17:24 * hackagebot amazonka-cloudsearch-domains 0.3.4 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.3.4 (BrendanHay)
02:17:43 <jle`> aleator: why not Maybe String ?
02:17:51 <frerich> aleator: I think it's not bad. You could also consider 'Maybe String', but that seems a bit odd because 'Nothing' would denote success.
02:18:13 <aleator> jle`: What frerich just said.
02:18:26 <jle`> you can use Nothing to denote no errors
02:18:28 <jle`> :3
02:18:36 <frerich> :-)
02:18:47 <aleator> Other option would be to do Unvalidated a -> Either String (Validated a)
02:18:48 <jle`> although none of the instances on Maybe really work well for this
02:18:53 <srhb> data Success = Success
02:19:07 <jle`> that too
02:19:11 <jle`> fight boolean blindness
02:19:27 <aleator> Thanks
02:19:45 <srhb> That's obviously the female version of succ
02:19:47 <srhb> Succ*
02:19:56 <frerich> Ouch...
02:20:19 <srhb> Yes. I've been doing this all day. My jokes aren't becoming better.
02:20:29 * srhb gets coffee ._.
02:22:26 * hackagebot amazonka-elasticbeanstalk 0.3.4 - Amazon Elastic Beanstalk SDK.  http://hackage.haskell.org/package/amazonka-elasticbeanstalk-0.3.4 (BrendanHay)
02:22:28 * hackagebot amazonka-datapipeline 0.3.4 - Amazon Data Pipeline SDK.  http://hackage.haskell.org/package/amazonka-datapipeline-0.3.4 (BrendanHay)
02:22:30 * hackagebot amazonka-support 0.3.4 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.3.4 (BrendanHay)
02:22:32 * hackagebot amazonka-redshift 0.3.4 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.3.4 (BrendanHay)
02:22:34 * hackagebot amazonka-opsworks 0.3.4 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.3.4 (BrendanHay)
02:23:03 <frerich> Would the real BrendanHay please stand up.
02:23:46 <kqr> I think they did
02:25:09 <_ryan> srhb: another erro occured - parse error on input =
02:25:55 <srhb> _ryan: i still can't magically see your code. :)
02:27:29 <_ryan> srhb my newsMetaTitle has a Maybe in Model... - here is the error Couldn't match expected type [a0] with actual type ‘Maybe Text’
02:27:36 * hackagebot amazonka-emr 0.3.4 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.3.4 (BrendanHay)
02:27:38 * hackagebot amazonka-cognito-identity 0.3.4 - Amazon Cognito Identity SDK.  http://hackage.haskell.org/package/amazonka-cognito-identity-0.3.4 (BrendanHay)
02:27:40 * hackagebot amazonka-ssm 0.3.4 - Amazon Simple Systems Management Service SDK.  http://hackage.haskell.org/package/amazonka-ssm-0.3.4 (BrendanHay)
02:27:42 * hackagebot amazonka-ml 0.3.4 - Amazon Machine Learning SDK.  http://hackage.haskell.org/package/amazonka-ml-0.3.4 (BrendanHay)
02:27:44 * hackagebot amazonka-dynamodb 0.3.4 - Amazon DynamoDB SDK.  http://hackage.haskell.org/package/amazonka-dynamodb-0.3.4 (BrendanHay)
02:28:37 <srhb> _ryan: Oh, you said you wanted to check if it's null.
02:28:40 <_ryan> srhb: the error occurse in this section "| null (newsMetaTitle n) "
02:28:43 <srhb> _ryan: null is [] in Haskell lingo
02:29:13 <_ryan> Maybe is null right? or wrong
02:29:20 <_ryan> now i'm wrong
02:29:22 <mauke> null is a function
02:29:23 <mauke> :t null
02:29:24 <lambdabot> Foldable t => t a -> Bool
02:29:25 <srhb> if the type of newsMetaTitle n is Maybe Text, you can just use case again to deal with either the Nothing or Just something
02:29:28 <srhb> > null []
02:29:29 <lambdabot>  True
02:29:30 <mauke> oh, hey
02:29:30 <srhb> > null [1,2,3]
02:29:32 <lambdabot>  False
02:29:34 <mauke> > null Nothing
02:29:36 <lambdabot>  True
02:29:38 <mauke> dohoho
02:29:39 <srhb> Heh
02:29:42 <jle`> haha
02:29:50 <srhb> That's unfair, these changes are so new!
02:30:15 <jle`> [] is nil; null is a way to test if something is nil.
02:30:35 <srhb> jle` But I can also say that 2 is even
02:30:41 <jle`> > (null [], null [1,2,3])
02:30:41 <mauke> "is nil" is fairly meaningless
02:30:42 <lambdabot>  (True,False)
02:31:01 <jle`> fsvo is :o
02:31:07 <srhb> :P
02:31:13 <jle`> a value that imbues exactly the meaning i intend >_>
02:31:15 <mauke> what's "nil"?
02:31:47 <jle`> the english pronunciation of one of the constructors of [a]
02:31:54 <_ryan> how do i check i the newsMetaTitle is empty..
02:32:09 <srhb> _ryan: newsMetaTitle is a record accessor, a function
02:32:19 <_ryan> a record
02:32:27 <srhb> _ryan: newsMetaTitle n might be Nothing, if I understood your previous message correctly.
02:32:41 <srhb> _ryan: And in that case, you can check it with yet another case of
02:32:46 * hackagebot amazonka-rds 0.3.4 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.3.4 (BrendanHay)
02:32:48 * hackagebot amazonka-ses 0.3.4 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.3.4 (BrendanHay)
02:32:50 * hackagebot amazonka-cloudwatch-logs 0.3.4 - Amazon CloudWatch Logs SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-logs-0.3.4 (BrendanHay)
02:32:52 * hackagebot amazonka-route53 0.3.4 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.3.4 (BrendanHay)
02:32:54 * hackagebot amazonka-cloudsearch 0.3.4 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.3.4 (BrendanHay)
02:32:56 <mauke> newsMetaTitle n :: Maybe Text, apparently
02:33:04 <jle`> BrendanHay is my hero
02:33:22 <srhb> Why is the same version getting uploaded multiple times? >>
02:33:37 <jle`> tjey
02:33:42 <jle`> *they're all different packages
02:33:45 <mauke> are we looking for a Text or a Maybe Text?
02:34:14 <mauke> the former can be done with fromMaybe
02:34:27 <mauke> the latter with maybe, but it feels weird
02:35:10 <srhb> Oh, I'm blind.
02:36:24 <srhb> I think _ryan wants maybe.
02:36:31 <srhb> But I'm not sure if HOFs will go over well yet.
02:37:56 * hackagebot amazonka-storagegateway 0.3.4 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.3.4 (BrendanHay)
02:37:59 * hackagebot amazonka-ec2 0.3.4 - Amazon Elastic Compute Cloud SDK.  http://hackage.haskell.org/package/amazonka-ec2-0.3.4 (BrendanHay)
02:38:00 * hackagebot amazonka-kms 0.3.4 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.3.4 (BrendanHay)
02:38:03 * hackagebot amazonka-elastictranscoder 0.3.4 - Amazon Elastic Transcoder SDK.  http://hackage.haskell.org/package/amazonka-elastictranscoder-0.3.4 (BrendanHay)
02:38:04 * hackagebot amazonka-lambda 0.3.4 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.3.4 (BrendanHay)
02:39:02 <mauke> HasselHOFs
02:39:31 <tdammers> Haskellhoff?
02:40:02 <sgronblo> ReiserFS vs HasselhofFS
02:40:37 <_ryan> srhb: the just needs one parameter right? so if in the first Just case i created i case for - case (newsMetaTitle n) of Nothing -> newsTitle n Just ? -> ?
02:41:32 <_ryan> srhb: the just needs one parameter right? so if in the first Just case, the second case may be look like this? case (newsMetaTitle n) of Nothing -> newsTitle n Just ? -> ?
02:41:35 <srhb> Yes, that's right
02:42:36 <spaceloop> does [1,1 ..] denote bottom?
02:43:01 <_ryan> srhb: yes i want maybe sorry for misundertunding..
02:43:06 * hackagebot amazonka-ecs 0.3.4 - Amazon EC2 Container Service SDK.  http://hackage.haskell.org/package/amazonka-ecs-0.3.4 (BrendanHay)
02:43:09 * hackagebot bitcoin-tx 0.10.0 - Utility functions for manipulating bitcoin transactions  http://hackage.haskell.org/package/bitcoin-tx-0.10.0 (solatis)
02:43:35 <mauke> > [1, 1 ..]
02:43:36 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
02:43:55 <mauke> > scanl (+) 0 [1, 1 ..]
02:43:57 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
02:44:01 <mauke> > take 5 $ scanl (+) 0 [1, 1 ..]
02:44:02 <lambdabot>  [0,1,2,3,4]
02:44:46 <merijn> spaceloop: No, because it terminates as long as you don't inspect the entire list
02:44:57 <spaceloop> ok, then what would be the least fixed point of the function (1:) ?
02:46:16 <spaceloop> I would guess bottom
02:46:40 <shachaf> ((1:) bottom) isn't bottom, so it isn't a fixed point at all.
02:46:42 <merijn> I'm never quite sure what the least fixed point is
02:46:44 <spaceloop> right
02:46:53 <spaceloop> ok I just figured that out too, thanks
02:47:45 <shachaf> The least fixed point is the fixed point that is least defined.
02:49:28 <shachaf> Conveniently, "let x = f x in x" is the least fixed point of f, in Haskell.
02:50:25 <mauke> merijn: do you know what fixed points are?
02:51:23 <Ferdirand> is the least fixed point guaranteed to be unique and why ? (sorry for newbishness)
02:51:46 <Ferdirand> is it correct that from two equivalently-defined fixed points you can derive a third that is less defined than the two ?
02:56:11 <mauke> I can't think of a counterexample
02:56:35 <mauke> a proof probably involves induction on the structure of haskell code
02:57:34 <merijn> mauke: yeah, but the formal definition sunk deep into my memory somewhere, so when it comes least vs most fixed point I lose track which is what
02:57:44 <shachaf> There are two questions, whether it's guaranteed to exist and whether it's guaranteed to be unique.
02:58:26 <frerich> merijn: 'most fixed point'? I think 'least fixed point' is in the sense of 'smallest fixed point', at least that's how I remember it - so you could have a function which has zero or one 'largest fixed point', I think.
02:58:32 <mauke> well, a fixed point is simply a value x such that f x = x
02:58:57 <shachaf> People talk about fixed points of both types and values.
02:58:58 <mauke> if there are several such values, we take the one that is "least defined"
02:59:17 <shachaf> "greatest fixed point" usually only comes up when talking about types, of these contexts.
02:59:47 <mauke> consider id. every value is a fixed point of id. but _|_ is the least defined of those
03:00:20 <mauke> in general, a function that inspects its argument will have _|_ as a fixed point
03:00:47 <spaceloop> (that fully evaluates its argument)
03:00:54 <mauke> no, only the top
03:01:03 <mauke> WHNF, I think it's called
03:01:09 <spaceloop> ah, ok I see
03:01:14 <frerich> mauke: Hm, that part confuses me, I would have thought that 'id has no least fixed point but I think that's because 'least defined' confuses me. I always read that as 'less defined', i.e. 'partly undefined' or so.
03:01:37 <mauke> frerich: why does that confuse you? :-)
03:01:42 <shachaf> undefined isn't just partly undefined, it's completely undefined
03:01:46 <mauke> _|_ is least defined because it's completely undefined
03:02:11 <frerich> mauke: Are there other 'least defined fixed points' in Haskell programs?
03:02:23 <mauke> depends on the function
03:02:28 <shachaf> As mentioned earlier, _|_ isn't a fixed point of (1:) at all.
03:02:35 <spaceloop> for (1:), [1,1 ..] is a least defined fixpoint
03:02:36 <mauke> e.g. consider const5 = \_ -> 5
03:02:57 <mauke> this function doesn't have _|_ as a fixed point because const5 _|_ = 5
03:03:05 <frerich> mauke: The least defined fix points would '5' then, I see.
03:03:07 <mauke> the only fixed point is 5
03:03:08 <shachaf> [1,1 ..] is a complicated Haskell program that does different things depending on the type.
03:03:37 <shachaf> Just listen to mauke.
03:03:45 <mauke> '\_ -> undefined' is a bit funny
03:03:59 <mauke> it doesn't inspect its argument, but its least fixed point is still _|_
03:04:01 <kuribas> I have troubles installing tasty: http://lpaste.net/130687
03:04:12 <mauke> (it's also strict)
03:04:13 <spaceloop> scachaf, could you elaborate? do you mean the overloaded number literals or something else?
03:04:27 <frerich> mauke: When you say 'inspect its argument', you mean that the argument is used somewhere in the definition, as in 'f x = x'?
03:04:45 <merijn> frerich: that still doesn't inspect it's arguments
03:04:49 <Ferdirand> okay so what about (\x -> [x])
03:04:52 <frerich> mauke: Or is that 'inspect' as in 'pattern matches'?
03:04:53 <shachaf> merijn: It doesn't?
03:04:56 <mauke> frerich: not just used but (the outermost layer of) the result depends on it
03:05:03 <merijn> frerich: "map f (x:xs) = .." inspects the second
03:05:26 <mauke> in f x = x, the result depends directly on the argument, which I count as "inspect"
03:05:33 <shachaf> "inspect its argument" is really an operational thing which is so close to a denotational thing (strictness) that it can be a bit confusing.
03:06:12 <kuribas> How can something be 'least defined'?  Shouldn't it be defined or not?
03:06:17 <mauke> ah!
03:06:31 <mauke> consider foo x = [x !! 0, x !! 0]
03:06:32 <frerich> kuribas: Try reading the IRC backlog of the last 8 minutes :-)
03:06:47 <mauke> what are the fixed points of this function?
03:06:53 <merijn> shachaf: To me inspects == force to WHNF or further
03:07:02 <shachaf> merijn: And why doesn't id inspect its argument?
03:07:23 <merijn> shachaf: id doesn't force it's argument to WHNF, does it?
03:07:46 <shachaf> What does it do with its argument?
03:07:54 <mauke> _|_ is not a fixed point because foo always returns [..., ...]
03:08:17 <mauke> ['x', 'x'] is a fixed point
03:08:26 <frerich> mauke: foo [[0],[0]] ?
03:08:31 <mauke> [_|_, _|_] is also a fixed point
03:08:46 <R0b0t1> kuribas: definedness is defined to be an ordering
03:08:56 <merijn> shachaf: Return it for further evaluation, at which point it may or may not be inspect by whatever uses the result of id
03:08:59 <mauke> of all the values that match [x, x], [_|_, _|_] is least defined
03:09:15 <shachaf> merijn: OK, can you name a function that does force its argument?
03:09:43 <mauke> (inb4 seq x x is a no-op)
03:09:55 <merijn> shachaf: Anything with a pattern match on said argument?
03:10:19 <frerich> mauke: Hm and that's because '(!! 0) undefined' is, uh, - undefined?
03:10:21 <shachaf> So "foo [] = []; foo (x:xs) = x:xs" forces its argument, but "foo x = x" doesn't?
03:10:29 <frerich> mauke: I.e. that's why it's a fixed point in the first place?
03:10:38 <mauke> frerich: right. _|_ is a fixed point of (!! 0)
03:10:57 <shachaf> mauke: That's an odd statement.
03:11:04 <shachaf> Is _|_ :: [a] the same value as _|_ :: a?
03:11:22 <mauke> oh, right. I misspoke
03:11:28 <merijn> shachaf: I would say so, but I might be thinking to operationally :)
03:11:39 <shachaf> merijn: They seem to me to be the same function.
03:12:56 <spaceloop> I think only fixpoints of functions :: a -> a for some a make sense
03:13:12 <shachaf> merijn: Whether or not "id x" inspects "x", in order to inspect "id x", you have to inspect "x".
03:13:34 <mauke> spaceloop: you're right
03:13:42 <shachaf> merijn: And given "foo (x:xs) = ...; foo [] = ...", in order to inspect "foo y", you have to inspect "y".
03:14:10 <aleator> Where does cabal store the package.conf file on linux?
03:14:29 <aleator> .ghc?
03:14:46 <shachaf> I think ghc-pkg list will tell you where GHC looks.
03:14:48 <mauke> isn't package.conf a ghc thing?
03:14:53 <merijn> shachaf: Yeah, I guess my definition of strictness needs some work :)
03:14:59 <mauke> I mean I've got one in /usr/lib/ghc-7.10.1/package.conf.d
03:15:04 <merijn> cabal doesn't store any package registration at all
03:15:10 <merijn> Cabal queries GHC for registered packages
03:15:26 <shachaf> merijn: Strictness is slightly different from what we're talking about.
03:15:34 <mauke> merijn: I can tell you that 'const undefined' is officially strict
03:15:45 * dramforever is using drambot to notify himself for irc messages
03:15:49 <shachaf> Only because of the thing mauke said.
03:16:20 <dramforever> it saves time, because otherwise I end up staring at IRC and see nothing
03:16:31 <mauke> dramforever: what do you mean?
03:16:31 <kuribas> mauke: Which one is less defined, Left _|_ or Right _|_?
03:16:41 <mauke> kuribas: neither
03:16:57 <dramforever> mauke: whenever a message is seen, ring the terminal bell
03:17:00 <kuribas> mauke: they are equally defined?
03:17:00 * hackagebot snmp 0.1.0.3 - API for write snmp client.  http://hackage.haskell.org/package/snmp-0.1.0.3 (chemist)
03:17:03 <mauke> kuribas: yes
03:17:12 <kuribas> mauke: so you count the number of bottoms?
03:17:16 <mauke> dramforever: why does that require a bot?
03:17:29 <mauke> kuribas: no, their distance from the root
03:17:43 <kuribas> ah...
03:18:04 <dramforever> mauke: because I use ERC and my emacs is not good enough to make it beep on message
03:18:14 <dramforever> *emacs skill
03:18:15 <mauke> _|_ : _|_ is less defined than _|_ : (_|_ : _|_), for example
03:19:04 <dramforever> okay...forget about it
03:19:47 <dramforever> mauke: 1 : _|_ is neither more nor less defined than _|_ : [], right?
03:20:26 <merijn> dramforever: Right, afaik
03:20:29 <mauke> I think so, yes
03:20:35 <dramforever> ouch I'm so stupid
03:20:47 <kuribas> dramforever: http://www.emacswiki.org/emacs/ErcSound
03:20:58 <dramforever> how could I forget about PING/PONG
03:21:04 <dramforever> kuribas: good I'll check it out
03:22:22 <mauke> wait, it does a regex search?
03:22:28 <mauke> haha, what the heck
03:22:36 <kqr> why does attoparsec support incremental input if it's going to store the entire input in memory anyway?
03:23:03 <mauke> (re-search-forward (regexp-quote (erc-current-nick)) nil t)  ¯\(°_o)/¯
03:24:06 <shachaf> I guess that when people talk about types, "least fixed point" is a bit misleading anyway.
03:24:07 <merijn> kqr: It doesn't store the entire input in memory...
03:24:18 <merijn> kqr: Unless that's required by your parser
03:24:32 <shachaf> "initial fixed point" would be more accurate.
03:24:45 <kqr> merijn, am I misunderstanding this:
03:24:46 <kqr> merijn, Note: incremental input does not imply that attoparsec will release portions of its internal state for garbage collection as it proceeds. Its internal representation is equivalent to a single Text: if you feed incremental input to an a parser, it will require memory proportional to the amount of input you supply. (This is necessary to support arbitrary backtracking.)
03:24:49 <kqr> merijn, ?
03:25:46 <srhb> kqr: Internal representation can be a window onto your source, if your parser allows it
03:26:02 <merijn> kqr: Basically, that's saying that using incremental input will not incrementally free memory that your non-incremental parser wouldn't free
03:26:36 <kqr> hm. not sure I follow. is attoparsec able to determine that there is no reason to backtrack, and then releases those resources it would otherwise keep
03:26:38 <kqr> ?
03:26:40 <merijn> kqr: Basically, if your top level parser starts with a bunch of alternatives, it can never collect anything until you complete
03:26:50 <kqr> sure
03:27:11 <kqr> but it will throw away data once there are no more alternatives for it?
03:27:19 <merijn> kqr: AFAIK
03:27:23 <dramforever> merijn: okay, I just patched my previous bot so that it beeps.
03:27:25 <kqr> sounds reasonable
03:27:40 <merijn> kqr: But you should benchmark and let me know for sure ;)
03:27:46 <kqr> heh
03:27:48 <merijn> Should be pretty easy to test, I think?
03:28:11 <kqr> possibly... if you are good at that kind of stuff :(
03:28:35 <merijn> Just create one parser with a top level branch and one without, feed random data, profile their memory consumption
03:28:47 <kqr> ah
03:28:49 <kqr> that should be easy
03:28:55 <merijn> The branching one would expect linear growth, the 2nd one constant-ish memory?
03:29:12 <merijn> (if you do "many myTest")
03:29:22 <merijn> Hmm, actually
03:29:38 <merijn> "many myTest" would commit after every myTest and potentially still collect...
03:30:15 <merijn> I guess it'd be sufficient to use only a branching myTest, run "many myTest" and check whether it has either linear or constant memory depending on how much you feed it
03:30:29 <merijn> Can even use something like "yes" to generate input for a parser that simple :p
03:32:29 <exfalso> hi, is there a way to cabal install dependencies as static libs instead of dynamic ones?
03:32:58 <nshepperd_> hmm, I thought attoparsec had try, but 'This combinator is provided for compatibility with Parsec. attoparsec parsers always backtrack on failure.'
03:33:21 <Gurkenglas> One only compares terms for definedness that aren't 'provably different', right? i.e. 1 vs 2
03:33:35 <nshepperd_> so yeah, I assume that means it keeps all input after the first branch
03:34:03 <exfalso> nshepperd_: attoparsec does "infinite" lookahead
03:34:19 <exfalso> you can fail your branch at any point 
03:34:32 <exfalso> and it will backtrack
03:35:17 <brbblnch> Hi
03:35:58 <brbblnch> Are proof assistants restricted to doing proofs in intuistionnistic logic?
03:36:14 <exfalso> brbblnch: no
03:36:24 <exfalso> brbblnch: well, depends on the proof assistant
03:36:57 <exfalso> brbblnch: if it's based on calculus of constructions like coq or agda then the type theory itself is intuitionistic
03:37:10 <exfalso> brbblnch: but you can model any logic in them
03:37:37 <brbblnch> exfalso: You can do a proof using the excluded middle in them?
03:37:55 <exfalso> brbblnch: well you can assume EM
03:38:35 <exfalso> for example you can do your proof in the double negation monad which is equivalent to assuming EM
03:38:38 <brbblnch> exfalso: I had the idea that excluded middle is non-constructive, thus can't be used in "program-as-proof"
03:39:17 <brbblnch> exfalso: So, for instance, it is possible that the proof of the four color theorem uses excluded middle somewhere?
03:39:28 <dramforever> brbblnch: the interesting thing is that even if you don't have LEM many, if not most theorems are provable
03:39:28 <exfalso> it is non-constructive, but you can still create proofs that assume that it's inhabited
03:40:32 <exfalso> the meaning changes a little: LEM is a universal statement about all types, whereas if you assume it your proof will assume that for the specific type you want to reason about it holds
03:40:37 <brbblnch> exfalso: Does that mean that I can create the proof, but not get a useful program out ouf it?
03:40:51 <exfalso> brbblnch: exactly
03:41:04 <exfalso> brbblnch: unless you can inhabit it for your specific type
03:41:27 <dramforever> that...reminds me of Typeable of GHC 7.10
03:41:35 <exfalso> brbblnch: but if you inhabit it it will probably become a pretty meaningless statement
03:42:27 <brbblnch> exfalso: Inhabit it for my specific type = "Have a proof that LEM holds for this particular formula" ?
03:42:50 <dramforever> IMHO LEM isn't very useful
03:42:58 <brbblnch> dramforever: That means that intuitionistic logic is powerful enough for a lot of stuff?
03:42:59 <exfalso> brbblnch: yes
03:43:16 <brbblnch> exfalso: Thanks
03:43:17 <exfalso> brbblnch: most probably you can do your proof without LEM
03:43:23 <dramforever> brbblnch: yes. do you know Coq
03:43:38 <dramforever> ?
03:43:44 <brbblnch> I know the idea
03:43:54 <brbblnch> well, I've heard of it
03:44:05 <dramforever> IIRC Coq is based on sort-of intuitionistic logic
03:44:22 <brbblnch> it's Martin-Löf, right?
03:44:34 <exfalso> its a much improved version of martin lof
03:45:07 <exfalso> its core is based on the calculus of constructions
03:45:32 <brbblnch> exfalso: Martin-Löf is not powerful enough for Coq?
03:46:06 <dramforever> exfalso: calculus of *inductive* constructions?
03:46:23 <dramforever> Theorem LEM : forall P : Prop, ((P -> False) -> False) -> P.
03:46:27 <brbblnch> There are too many variants and logics
03:46:32 <kuribas> I am stuck in cabal-hell again: http://lpaste.net/130687
03:46:33 <exfalso> no, id doesnt have inductive datatypes
03:46:45 <exfalso> dramforever: yes
03:46:55 <srhb> kuribas: What does --force-reinstalls give?
03:46:57 <dramforever> for this theorem, tauto fails, so that it's not a tautology in Coq
03:47:05 <exfalso> dont use force-reinstalls lol
03:47:15 <srhb> exfalso: Why not?
03:47:26 <dramforever> "dangerous"
03:47:33 <exfalso> srhb: because it *will* break your packages
03:47:40 <chpatrick> tbh it's never happened to me
03:47:44 <srhb> Nor to me..
03:47:46 <chpatrick> despite all the warnings
03:47:52 <exfalso> do ghc-pkg check
03:47:53 <xelxebar> beginner here: looking at families of functions like liftM, liftM2, etc. is there really no idiomatic way to provide a variadic function in Haskell? intuitively, considering that Hask is closed, I would expect this to be possible.
03:48:05 <exfalso> it will list your broken packages
03:48:10 <chpatrick> it's complaining about some haddocks
03:48:11 <exfalso> ghc-pkg unregister them
03:48:13 <chpatrick> that's it
03:48:18 <dramforever> xelxebar: how about applicative stuff?
03:48:21 <jle`> xelxebar: (<*>) and pure
03:48:24 <kuribas> xelxebar: printf is variadic.
03:48:28 <exfalso> and reinstall
03:48:30 <srhb> exfalso: If that other one gets broken, I just --force-reinstall that, and live on happily ever after. :)
03:48:30 <dramforever> have you heard of applicatives?
03:48:42 <jle`> liftA2 f x y = f <$> x <*> y, liftA3 f x y z = f <$> x <*> y <*> z, etc.
03:48:54 <jle`> or maybe this is not what you mean by variadic functions
03:49:01 <exfalso> srhb: yeah you can do that as well, but taht solution is not scalable and results in non-reproducible setups
03:49:03 <chpatrick> xelxebar: yeah look at printf
03:49:04 <dramforever> srhb: if anything will be broken, I rm -rf ~/.ghc and retry
03:49:18 <exfalso> the best solution is to use cabal sandboxes
03:49:26 <dramforever> yeah +1 for that
03:49:29 <srhb> exfalso: I don't want to build every package for every sandbox.
03:49:43 <kuribas> me neither
03:49:47 <exfalso> srhb: there are tools to handle that
03:49:47 <dolio> printf is not code that should be emulated.
03:49:48 <chpatrick> xelxebar: you can make a function that returns a variadictype where a variadictype is either a result or a function of a parameter to another variadictype
03:49:55 <srhb> exfalso: Surely. --force-reinstalls works fine for me :)
03:49:55 <chpatrick> it's just a typeclass
03:50:25 <jle`> xelxebar: consider what you actually want to do and why it is meaningful or useful :)  in specific cases
03:50:34 <jle`> printf is definitely not "idiomatic".
03:50:49 <srhb> exfalso: Also I only have haddock errors, despite doing exactly --force-reinstalls often.
03:50:50 <exfalso> well, you have been warned;)
03:50:57 <srhb> exfalso: I'm guessing it's more rare than you think.
03:50:59 <dramforever> aww this scared me:
03:51:05 <dramforever> :t liftM3 . liftM3
03:51:06 <lambdabot> (Monad m, Monad m1) => (a1 -> a2 -> a3 -> r) -> m (m1 a1) -> m (m1 a2) -> m (m1 a3) -> m (m1 r)
03:51:15 <xelxebar> dramforever, jle`, chpatrick: thanks. I'll take a look at printf.
03:51:31 <jle`> dramforever: do you understand (fmap . fmap) ?
03:51:32 <exfalso> no, its not rare, when it warns you that packages will break they *will* break. You probably went and force-reinstalled those packages as well
03:51:54 <srhb> exfalso: Right, so there's no problem.
03:52:10 <srhb> Living with cabal is a hack.
03:52:22 <xelxebar> chpatrick: well, I guess I'm just asking why do we have the liftM family of functions instead of one polyvariadic liftM?
03:52:27 <exfalso> it doesn't have to be...
03:52:48 <jle`> fmap :: (a -> b) -> (t a -> t b)      -- everything is in a t
03:53:05 <exfalso> xelxebar: because you cannot write that function
03:53:16 <jle`> (fmap . fmap) :: (a -> b) -> (s (t a) -> s (t b))     -- everything is lifted "two layers"
03:53:20 <dramforever> jle`: it's okay, I understand it
03:53:42 <mauke> the other day I used liftA2 . liftA2
03:53:44 <jle`> liftA2 :: (a -> b -> c) -> (t a -> t b -> t c)    -- everything in a t.
03:53:57 <jle`> liftA2 . liftA2 :: (a -> b -> c) -> (s (t a) -> s (t b) -> s (t c))
03:54:10 <dramforever> just amazed by the fact that whoa virtually any two functions will compose
03:54:31 <chpatrick> xelxebar: it's difficult to write it because if you wrote a typeclass that recursed on functions to produce their lifted versions then the base case of (a -> (b -> c)) is "c"
03:54:35 <jle`> yeah it's pretty cray
03:54:41 <mauke> xelxebar: that would be really annoying to use, especially considering ((->) e) is an instance of Monad
03:54:42 <jle`> :t zipWith . zipWith
03:54:43 <lambdabot> (a -> b -> c) -> [[a]] -> [[b]] -> [[c]]
03:54:44 <chpatrick> and if you write a typeclass instance for "c" then it overlaps everything
03:54:52 <jle`> :t liftA2 . zipWith . liftA2
03:54:53 <lambdabot> (Applicative f, Applicative f1) => (a -> b -> c) -> f [f1 a] -> f [f1 b] -> f [f1 c]
03:54:56 <exfalso> exactly what chpatrick says
03:55:13 <exfalso> it all breaks down because of polymorphism
03:55:34 <exfalso> you cannot write an instance for the "result type of a function"
03:55:39 <mauke> it all returns to nothing, it just keeps tumbling down, tumbling down, tumbling down ...
03:55:39 <dramforever> jle`: similar: you can do "fmap fmap fmap fmap....", it's at lease equally amazing
03:56:00 <exfalso> dramforever: look into Control.Lens you'll love it hehe
03:56:06 <chpatrick> would haskell break if it checked instance contexts before the instance body?
03:56:08 <dramforever> yeah
03:56:14 <chpatrick> meaning if you said
03:56:25 <jle`> :t traverse . traverse
03:56:26 <lambdabot> (Applicative f, Traversable t, Traversable t1) => (a -> f b) -> t (t1 a) -> f (t (t1 b))
03:56:28 <chpatrick> FunResult a ~ a => LiftM a
03:56:29 <dramforever> to me in haskell (.) is at lease as important as lambda
03:56:37 <chpatrick> wouldn't match unless the closed type family matches a
03:56:53 <kuribas> srhb: --force-installs worked for now :)
03:57:01 <exfalso> chpatrick: i think instance resolution would break and it will become undecidable by default
03:57:06 <srhb> kuribas: Score one for lousy hacks. :-)
03:57:17 <kuribas> srhb: yeah:)
03:57:18 <exfalso> ...
03:57:25 <srhb> exfalso: I'm teasing. Sorry :P
03:57:32 <exfalso> i know:)
03:57:43 <dramforever> :t fmap . map . traverse . liftM2 . zipWith . (.)
03:57:44 <lambdabot> (Monad m, Functor f, Traversable t) => (b1 -> c) -> f [t (m [b -> b1])] -> f [m [b] -> t (m [c])]
03:57:50 <dramforever> That's as much as I can think of
03:57:53 <dramforever> and it still works
03:58:12 <jle`> well...that it works isn't too interesting.  that it provides something meaningful is probably the more interesting thing :)
03:58:13 <dramforever> although map and (.) are probably redundant
03:58:30 <dramforever> jle`: welcome to lens lol
03:58:41 <jle`> (fmap . fmap) is meaningful because it is fmap over "two layers".  liftA2 . liftA2 is liftA2 over "two layers".  (traverse . traverse) is traverse over "two layers"
04:00:08 <xelxebar> chpatrick, dramforever: thanks. I'll have to think about this some
04:00:32 <dramforever> xelxebar: you're welcome
04:12:02 * hackagebot rainbox 0.12.0.0 - Two-dimensional box pretty printing, with colors  http://hackage.haskell.org/package/rainbox-0.12.0.0 (OmariNorman)
04:32:02 * hackagebot pipes-cliff 0.10.0.2 - Streaming to and from subprocesses using Pipes  http://hackage.haskell.org/package/pipes-cliff-0.10.0.2 (OmariNorman)
04:39:18 <MichielDC> Got some question on record syntax. I got this: data a <~> b =  Iso { to :: a -> b , from :: b -> a }. Can someone explain the things between { } (It's on isomorphism)
04:40:24 <MichielDC> Does it mean that for any types a and b, I need to provide to and from functions?
04:40:31 <chpatrick> so it's basically the same as having a type Iso (a ->b) (b -> a)
04:40:59 <chpatrick> except you get a function to :: (a <~>b) -> (a -> b)
04:41:13 <chpatrick> and from :: (a <~>b) -> b -> a
04:41:23 <chpatrick> which just take the type and return that field for you
04:41:42 <chpatrick> you can also use them to update like this: myIso { to = myTo, from = myFrom }
04:41:49 <chpatrick> and pattern match like this:
04:42:03 <chpatrick> case myIso of
04:42:03 <chpatrick>   Iso { from = f, to = to } -> ....
04:42:09 <kqr> MichielDC, http://lpaste.net/8271226097123721216
04:42:18 <chpatrick> and if you turn on NamedFieldPuns you can just write Iso { from, to } :)
04:42:22 <kqr> MichielDC, is a half-true way to view it
04:43:05 <kqr> MichielDC, so yes, you need to supply one (a -> b) function and one (b -> a) function to create an instance of a<~>b
04:43:12 <kqr> MichielDC, that's the two arguments the Iso constructor needs
04:43:27 <MichielDC> Thanks! It was just the record syntax that I was struggling with, haven't used it much myself
04:59:24 <Noel97> #haskell-blah
05:05:49 <dot_asp> http://lpaste.net/130691 hello. Can I get a hint on how to solve exercise 4? 
05:07:10 <dot_asp> How do I get a from EitherLeft a t ? 
05:07:21 <dot_asp> *EitherLeft t a
05:08:16 <KaneTW> you don't
05:08:36 <Ivanchuk> h
05:08:39 <Ivanchuk> hi haskellers
05:08:44 <KaneTW> you can only reason about one side of the either with that type
05:08:50 <KaneTW> apply furry to that
05:08:56 <frerich> dot_asp: I'd imagine you would do it much like you would do for the 'Maybe' instance of Fluffy.
05:09:52 <frerich> dot_asp: I.e. you could pattern-match on the possible values of 'a' in 'EitherLeft a'.
05:10:00 <int-e> Cute, I wonder if that's a precursor to a WarmAndFuzzy typeclass...
05:10:40 <frerich> int-e: I suspect that WarmAndFuzzy might have a 'cuddle :: f (a -> b) -> f a -> f b' function.
05:11:33 <frerich> (and 'snuggle :: a -> f a')
05:12:17 <int-e> frerich: it should have a  hug :: f (f a) -> f a
05:12:22 <grohne> is there a way to log from a haskell application in a way that does not make performance suck when logging is disabled?
05:13:32 <dot_asp> Alright thanks.
05:13:59 <frerich> grohne: A very basic approach might be to pass a 'String -> IO ()' function around which your code uses to log things. In 'main', you potentially set that to a 'nullLogger = const (return ())'
05:14:07 <Ivanchuk> I'm struggling at functor instantiations and category concepts...
05:14:12 <liyang> (Cross-posting from #ghc) Has anyone noticed ridiculous slowdowns with ghc 7.8.3 and Linux 3.17.1? It doesn't happen with 3.14.1… (and I haven't tested anything else yet—nor feel inclined to—unless no one else can replicate the issue.)
05:15:56 <Ivanchuk> Whenever we declare a data type of kind * -> *, is it a sort of a "half" functor ?
05:17:06 <grohne> frerich: hmm. currently I am doing "when (msgPrio >= minPrio) ..." and that (and >>=) uses 20% of the runtime according to a profile run with -auto-all
05:17:15 <mniip> Ivanchuk, not all * -> * types can be functors
05:17:28 <grohne> frerich: well, with minPrio coming from a ReaderT
05:17:35 <grohne> err StateT to be honest
05:19:24 <Ivanchuk> thanks mniip
05:19:25 <mniip> Ivanchuk, 'f' can only be a functor if in 'f a', all occurencies of 'a' and 'f a' occur to the right of (->)
05:19:41 <mniip> there might be some more restrictions I can't recall right now
05:20:03 <Ivanchuk> ok
05:20:06 <frerich> grohne: Yeah, the idea is to not do that 'when' at every place where a message is logged but rather as part of the logging function, such that when a 'null' function is passed you don't even perform that check.
05:20:13 <frerich> grohne: It should evaluate to just 'return ()'.
05:20:47 <Ivanchuk> I asked that because in cat says that a functor is map between objects and "arrows"
05:21:14 <Ivanchuk> but when instantiating a functor typeclass, I looks to me that I only define a map between "arrows"
05:21:15 <mniip> in haskell, a functor is a map between a and 'f a'
05:21:27 <mniip> with a function that lets you turn the 'a -> b' arrow into an 'f a -> f b' one
05:21:46 <grohne> frerich: currently the application appears to be able to change the level at runtime, not sure whether it really needs to be able to do that
05:22:03 <mniip> Ivanchuk, data constructors serve as the mapping between the objects
05:22:12 <merijn> Ivanchuk: I can give you a simple example of a type with kind * -> * which can't be a Functor :)
05:22:17 <frerich> grohne: Then your logging function could be part of the State you already have, I guess?
05:22:27 <Ivanchuk> great, that's the answer I was looking for !
05:22:32 <merijn> Ivanchuk: "data Foo a = Foo (a -> Int)" <- try and implement Functor for this :)
05:22:40 <mniip> also applicative functors do have a 'pure'
05:23:02 <grohne> frerich: good idea!
05:23:06 <mniip> protip for merijn's question: you can't
05:23:29 <merijn> mniip: I already gave that answer, it's still good practice to try and see where you get stuck :)
05:23:45 <mniip> well
05:24:02 <mniip> you could say 'fmap f = Foo $ const 0'
05:24:07 <mniip> but then there are functor laws
05:24:31 <mniip> oops that needs more const
05:27:26 <Ivanchuk> mniip, I thought type constructors (|) (->) or (space) by space I mean product type, serve as object mapping ?
05:29:05 <mniip> yeah that
05:29:23 <mniip> hmm
05:29:45 <mniip> 'f' serves as the object mapping
05:30:00 <mniip> turning 'a' into 'f a'
05:30:20 <Ivanchuk> then a represent all object being haskell data types ?
05:30:43 <mniip> a is any specific haskell type (object in the Hask category)
05:34:05 <Ivanchuk> got it, thanks
06:02:02 <bernalex> byorgey: ping?
06:02:05 * hackagebot sfmt 0.1.1 - SIMD-oriented Fast Mersenne Twister(SFMT) binding.  http://hackage.haskell.org/package/sfmt-0.1.1 (HirotomoMoriwaki)
06:02:21 <troydm> what's the best direct way to output Int16 to stdout 
06:02:24 <troydm> directly
06:02:28 <bernalex> meh. not haskell related. guess I''ll pm. :)
06:02:41 <tdammers> troydm: conceptually impossible
06:02:42 <troydm> not as text but as two characters 
06:02:56 <tdammers> stdout is a stream of unicode characters or a stream of bytes, depending on the platform
06:03:14 <tdammers> there is no unambiguous way to output 16-bit integers on that
06:03:23 <troydm> tdammers: Int16 is two bytes
06:04:06 <chpatrick> hPutBuilder (int16BE yourInt)?
06:04:07 <troydm> tdammers: how do I output it as two bytes?
06:04:10 <chpatrick> with Data.ByteString.Builder
06:04:29 <troydm> ahh ic thx chpatrick 
06:04:35 <chpatrick> or int16LE if you want little endian
06:05:03 <tdammers> exactly - you need to serialize
06:05:17 <troydm> let's say I have a function that for a given time outputs Int16
06:06:06 <troydm> can I build lazy output stream of Int16 for that funtion given time going from 0 to infinity
06:06:49 * frerich wades through a Java project, sees a type 'AbstractReusableInformationControlCreator' and wishes for a job which involves Haskell. 8-[
06:07:16 <chpatrick> FactoryProviderStrategyHelper
06:07:22 <Axman6> but that name is so long, it MUST be clear and descriptive!
06:07:44 <tdammers> AbstractBaseClassThatYouNeedToInheritFromThisMeansYouCannotInstantiateItDirectlyHonestlyISwearIHaveTriedItDoesntWork
06:08:02 <tdammers> also, -blah?
06:08:17 <chpatrick> http://docs.spring.io/spring-framework/docs/2.5.x/api/org/springframework/aop/framework/AbstractSingletonProxyFactoryBean.html
06:12:06 * hackagebot helium 1.8.1 - The Helium Compiler.  http://hackage.haskell.org/package/helium-1.8.1 (JurriaanHage)
06:12:36 <Lis> hello everyone. what could cause that the output of putStrLn is not shown? i get the output of Debug.Trace.trace
06:13:02 <chpatrick> Lis: how are you using it?
06:13:40 <Lis> foo = do; putStrLn "bar"; Debug.Trace.trace "Bla" (baz)
06:13:48 <Lis> bla is shown but bar not
06:14:35 <srhb> Lis: What is the type of foo?
06:14:54 <Lis> writeStats :: [String] -> [String] -> IO ()
06:15:13 <srhb> Uh...
06:15:47 <srhb> Lis: More code, please, something is wrong.
06:16:00 <srhb> Lis: lpaste.net
06:17:11 <srhb> With that type I can't see how the trace can possibly be evaluated without baz and putStrLn...
06:22:07 * hackagebot blunt 1.0.1 - Convert between pointfree and pointful expressions.  http://hackage.haskell.org/package/blunt-1.0.1 (fozworth)
06:28:22 <Lis> i found the error
06:28:30 <Lis> recompiling my haskell broke some things
06:29:20 <Lis> ah no, it didnt
06:29:31 <Lis> just got some linker errors with runhaskell
06:30:59 <dot_Laptop> Hello. After trudging compiler error logs and looking up prelude definition for Either, I came up with this http://lpaste.net/130692  . Is this the correct solution?
06:32:07 * hackagebot dataflow 0.6.0.0 - Generate Graphviz documents from a Haskell representation.  http://hackage.haskell.org/package/dataflow-0.6.0.0 (owickstrom)
06:35:41 <miheerdew> Hello, I would like to learn haskell by working on some projects. Do you have some suggestions?
06:38:51 <tdammers> miheerdew: what kind of projects have you done before?
06:39:48 <miheerdew> tdammers: I haven't done any real world coding in haskell. I have some experience with python.
06:41:35 <miheerdew> tdammers: it would be best to find something that I find intersting. Did I answer you correctly?
06:42:48 <miheerdew> Yes, so basically I am trying to dive into programming with haskell
06:42:52 <tdammers> right
06:43:24 <yac> can you give some pointers on what I'm doing here? https://github.com/yaccz/yac-build-server/commit/4d272490ed24fcd23a4412def522662a461bf9c1 I tried to turn the main and mainWithConf into "monadic" ybsRun but I feel like I only made it worse
06:45:44 <tdammers> miheerdew: how about you check out some of the introductory resources and take it from there?
06:45:46 <tdammers> @where lyah
06:45:46 <lambdabot> http://www.learnyouahaskell.com/
06:45:49 <tdammers> @where rwh
06:45:49 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
06:46:14 <tdammers> these are the ones I'd recommend
06:46:21 <geekosaur> @where learnhaskell
06:46:21 <lambdabot> https://github.com/bitemyapp/learnhaskell
06:46:28 <tdammers> oh yeah, that too
06:46:32 <geekosaur> ^ list of more up to date learning resources
06:46:49 <miheerdew> tdammers: I have tried learning from places. Know what is a monad. But could never get started writing real programs
06:47:25 <miheerdew> tdammers: I would like to read the more advance concepts only when I start using them
06:51:38 <frerich> miheerdew: One thing you could do is - given that you have some Python experience - to write some programs which you already did in Python in Haskell. That gets you a 'goal' and you can also compare your solutions.
06:51:51 <frerich> miheerdew: In general, it's good to have some itch to scratch. :-)
06:54:16 <miheerdew> frerich: Thanks, thats a nice idea :)
06:54:40 <kqr> miheerdew, only you know best what kinds of programs you want to write
06:55:52 <kqr> miheerdew, I would like something that extracts the individual photosite values from a nikon NEF raw file if you want to write me a program :>
06:58:27 <miheerdew> kqr: I didn't understand much of what you said. But yes starting out on a new projects seems to require knowledge of which libraries to use, and the abstractions that they use.
06:58:54 <miheerdew> kqr: And I have a project that I want to work on ;)
06:58:57 <kqr> ah good
06:59:01 <kqr> then what's stopping you?
06:59:46 <miheerdew> It has lots of components, for instance a gui and database. 
07:00:12 <miheerdew> I don't know which libraries i should use
07:00:20 <kqr> oh yeah
07:00:25 <miheerdew> Also what abstraction i will need
07:00:26 <kqr> you should probably start with a smaller project
07:00:32 <kqr> if you've never written a haskell program before
07:01:02 <kqr> pretend like you're just learning programming for the first time
07:01:16 <kqr> easy to want to do something really complicated that's way beyond your knowledge
07:02:08 * hackagebot blunt 1.0.2 - Convert between pointfree and pointful expressions.  http://hackage.haskell.org/package/blunt-1.0.2 (fozworth)
07:02:09 <miheerdew> hmm. I can write hello world programs and maybe solve those on project euler. But that won't help me get started with real world
07:02:54 <miheerdew> programming
07:03:32 <frerich> miheerdew: You could implement a web crawler which fets HTML pages, extracts links and then goes to visit the links (unless the links point to a different host). Based on that, you could generate sitemaps or search for broken links. You'll get in touch with all kinds of common Haskell libraries.
07:03:44 <frerich> miheerdew: Lateron, you can also parallelize it, visiting many pages concurrently.
07:04:00 <Lis> miheerdew, you learn it by doing bigger projects
07:04:10 <exio4> miheerdew: how many languages do you already know? 
07:04:18 <arbelos> Also, you mentioned that you have an idea for a program. Break this into smaller modules and start perhaps with only the database interaction. Try to make things modular so that each component can be reused in other programs, and works on it own in a generic way. That is how I would start
07:04:27 <kqr> exio4, isn't that kind of irrelevant, since haskell is likely different from all of them
07:04:29 <miheerdew> exio4: Python
07:04:47 <Lis> frerich, how much have you already finished with that projects? could you send me some code?
07:05:16 <exio4> kqr: I was asking, mostly because if he had learnt 'lots' of  similar languages, he may think picking up haskell would have been relatively similar
07:05:28 <exio4> miheerdew: oh, ok
07:05:31 <kqr> exio4, ah, sure
07:05:59 <bennofs> Some experience with programming probably still helps even if the language is quite different
07:06:05 <frerich> Lis: I stopped at some point because I got bored, but the code is on https://github.com/frerich/lambdacrawler -- IIRC it already concurrently fetched web pages, dealt with redirects and eventually printed a list of links it found.
07:06:52 <exio4> bennofs: it does help, and it also hurts a little bit, "I picked up a language on a week! this is taking too long!"
07:07:02 <miheerdew> frerich: Yes, that is good too.
07:07:39 <miheerdew> arbelos: Yes I can start with that.
07:08:02 <arbelos> Just an idea ;)
07:08:32 <arbelos> for GUI programming, working with some existing toolkit is unavoidable. So that is going to glue together most of the other parts of your program in the end
07:09:08 <troydm> what's the easiest way to get an infinite numbers list in Haskell starting with 1?
07:09:11 <arbelos> At that stage, you'll probably want to make sure most of the underlying functionality is already in place
07:09:17 <troydm> is there a builtin function?
07:09:18 <miheerdew> arbelos: I kind of hate the gluing part in python too.
07:09:19 <frerich> troydm: [1..]
07:09:33 <kqr> troydm, repeat 1
07:09:34 <arbelos> miheerdew, oh, why is that?
07:09:37 <troydm> frerich: ahh yeah thx, dumb me dumb me :)
07:09:48 <kqr> troydm, depends on what the list is supposed to look like
07:09:59 <troydm> kqr: [1,2,3,4.....
07:10:02 <miheerdew> arbelos: Too many things to do. 
07:10:10 <kqr> troydm, ah then you want [1..] as frerich suggested
07:10:31 <miheerdew> arbelos: Just for some simple functionality
07:10:37 <kqr> troydm, you can also do "enumFrom 1" if you want it to be a function
07:10:49 <troydm> kqr: ic, thx
07:11:11 <xelxebar> :t fmap . fmap . fmap
07:11:12 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
07:11:50 <miheerdew> Do people use FRP more in haskell
07:12:16 <kqr> more than what?
07:12:41 <miheerdew> compared to wxhaskell for instance
07:12:42 <arbelos> there is definitely a lot of interest in FRP.. A lot of people are interested, how many that are using it I don't know
07:13:16 <miheerdew> I wanted to know a clean GUI framework
07:13:35 <kqr> from what I have been able to tell, the GUI story in haskell is sad
07:13:46 <kqr> the best we have are somewhat thin wrappers around other libraries
07:14:04 <kqr> and browser-based stuff which isn't the same thing
07:14:29 <bennofs> hsqml is quite ok IMO
07:14:45 <arbelos> Leksah is the only major GUI application written in Haskell I can think of
07:14:49 <bennofs> if you can live with Qt and QML
07:15:05 <miheerdew> bennofs: Yes, will check that. Is the separation good 
07:15:21 <kqr> haven't looked at hsqml, but I don't mind Qt
07:15:37 <miheerdew> bennofs: I meant of the gui programming and the haskell part
07:15:52 <exio4> I wouldn't really look at GUIs for now
07:15:57 <bennofs> kqr, miheerdew: it's based on QML, which means that you expose data to QML and the GUI is written in QML
07:16:17 <bennofs> QML is a little bit like json to describe user interfaces
07:16:28 <xelxebar> :t (***)
07:16:29 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
07:16:38 <bennofs> With the QtQuick.Controls module, there are also native desktop widgets provided
07:17:54 <arbelos> exio4, pessimistic outlook for GUI programming in Haskell? :(
07:18:45 <exio4> arbelos: pretty much, I (sadly) haven't looked at hsqml, but GUIs are one of the boring parts anyway :p
07:19:05 <miheerdew> exio4: I agree with you on that :P
07:19:35 <Moggle1> arbelos, my experiences with GUI programming in haskell have been universally awful
07:19:52 <tdammers> GUIs are boring
07:19:53 <miheerdew> There should be a nice separtion of concerns as in HTML. Maybe hsqml might provide it
07:19:58 <Moggle1> if you ever find a nice library to do it that doesn't use a browser, let me know
07:20:02 <tdammers> solving the GUI problem is interesting though
07:20:39 <arbelos> Moggle1, I know what you mean. GUIs should be declarative, which is why FRP is making sense also
07:21:42 <Lis> frerich, awesome thank you
07:22:23 <arbelos> or perhaps even functional reactive DESIGN, more
07:22:39 <tdammers> fwiw, HTML doesn't have "nice" separation of concerns
07:22:50 <tdammers> it tries hard, but people abuse it too much
07:23:24 <arbelos> no HTML doesn't solve any problems in the GUI area
07:23:27 * davidfetter not about to blame HTML until he understands it better
07:23:57 <bergmark> mostly css that's terrible :-)
07:24:16 <davidfetter> Moggle1, what's your take on reflex?
07:26:16 <tdammers> IMO the problem with HTML is that it wants to be a document language, but people use it for user interfaces instead
07:26:50 <tdammers> if you use it to implement a cross-linked decentralized encyclopedia, then it works nicely
07:27:03 <merijn> kqr: To be fair, the story of GUIs in all languages is pretty terrible, atm
07:27:44 <merijn> Haskell just has the general terribleness PLUS the pain of FFI impedance mismatch
07:28:10 <miheerdew> tdammers: I don't know much. But I think there should be a separate declarative language for guis. And gluing should be simple
07:28:14 <kqr> merijn, I agree
07:29:01 <merijn> I've done some thinking in an FRP GUI framework, but I ran into a reactive-banana bug and haven't revisited it since, since I don't have enough hours in the day >.>
07:30:01 <kqr> we should have a library that makes more hours in the day
07:30:04 <kqr> I need that too
07:30:10 <tdammers> miheerdew: agree. unfortunately, no satisfactory solution exists
07:30:13 <arbelos> things have not exactly improved since GUIs decided to move into the browser either
07:30:26 <kqr> actually Elm isn't bad
07:30:34 <tdammers> arbelos: some things have improved, others are now worse
07:30:35 <kqr> it's just a shame it's not haskell and native instead of in the browser
07:31:10 <jellie> @info bindPOrt
07:31:11 <lambdabot> bindPOrt
07:31:15 <jellie> @info bindPort
07:31:15 <lambdabot> bindPort
07:31:20 <merijn> kqr: So start developing an Elm-like library for haskell that's native?
07:31:24 <merijn> jellie: There is no @info
07:31:25 <arbelos> tdammers, it feels like UI toolkits like Qt and GTK+ had finally reached a point, after 30 years or something, where desktop application design was fairly straightforward
07:31:27 <rabisg> I'm trying to understand what is the policy for exporting constructors? I understand the module would like to abstract away the internals but sometimes it might be necessary, isn't it? For instance while declaring instances
07:31:50 <jellie> merijn: :( I would've sworn.
07:31:57 <jellie> @hoogle bindPort
07:31:57 <arbelos> tdammers, in an OOP context at least
07:31:59 <lambdabot> No results found
07:32:21 <merijn> rabisg: It depends on whether constructors let you violate the invariants for the type
07:32:24 <tdammers> arbelos: the cost is pretty dire though, if you consider what it takes to build a real-world application on either
07:32:30 <kqr> merijn, possibly... I'm not qualified to say. I also don't know whether or not we have something close to that already
07:32:34 <merijn> rabisg: For example, exposing constructors for Set would let people violate the ordering
07:32:44 <tdammers> compared to just typing some HTML and CSS and JS and serving it
07:32:49 <frerich> rabisg: It depends, constructors let you pattern-match values but they might also permit to create bogus values (i.e. violating invariants)
07:33:13 <kqr> merijn, elm has also made some tradeoffs Haskell didn't to get good behaviour, and I don't know if we can get that in haskell short of "implement an elm compiler that compiles down to native code"
07:33:25 <rabisg> merijn: agreed but doesn't it make sense to export the constructor in lets say A.B.Internal module?
07:33:53 <merijn> rabisg: Maybe, maybe not?
07:34:13 <arbelos> tdammers, but with modern JS frameworks, we are almost back to the same point
07:34:14 <merijn> kqr: You can get quite far just using TH :)
07:34:19 <kqr> tdammers, i'm not sure I agree. depends on what kind of application you're trying to make
07:34:38 <rabisg> for example Im trying to use Data.Trie which defines an instance of Binary but not for Serialize. I want to use the latter but now I cant
07:34:38 <arbelos> tdammers, now you need to be a JavaScript "engineer" :)
07:34:46 <kqr> tdammers, at least when I'm forced to make web apps, it never turns out as simple as "just typing out some HTML, CSS and JS"
07:35:01 <kqr> tdammers, with browsers, weird css behaviour and all that
07:35:02 <arbelos> no that is my experience too
07:35:24 <rabisg> merijn: frerich in such a case shouldn't Data.Trie.Internal export the constructors?
07:35:30 <tdammers> my unpopular opinion is that almost all JS frameworks are for idiots who are so deeply in love with baroque ornaments that they conveniently forgot to learn some actual programming
07:35:55 <merijn> rabisg: Maybe, FYI, there's not much reason to use cereal over binary
07:36:01 <arbelos> baroque ornaments?
07:36:07 <athan> Hi everyone, is there something like a "predicative" lookup table? Does this exist? :S
07:36:10 <kqr> merijn, good point. I'm not sure whether it's a good or bad thing I tend to forget TH is an option...
07:36:22 <merijn> rabisg: The main reason for cereal was the ability to use strict incremental parsing, but binary can now do that too
07:36:24 <tdammers> arbelos: couldn't think of a better opposite of "minimalism"
07:36:39 <merijn> rabisg: iirc there were vague plans to merge the remains of cereal into binary
07:36:40 <arbelos> ok. hehe
07:36:41 <kqr> athan, what does predicative mean in this case?
07:37:10 * hackagebot grid 7.8.0 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.8.0 (AmyDeBuitleir)
07:37:12 * hackagebot midi 0.2.1.5 - Handling of MIDI messages and files  http://hackage.haskell.org/package/midi-0.2.1.5 (HenningThielemann)
07:37:17 <rabisg> merijn: I wanted to use ByteString instead of LazyByteString. In any case I have written instances of Serialize all over. Either I add both dependencies or remove cereal completely
07:37:32 <kqr> tdammers, is that similar to how haskell is just a bunch of baroque ornaments for people who conveniently forgot to learn some real C programming? ;)
07:37:37 <athan> kqr: Well, take this for example - a normal lookup table would just be a rose tree of (t, Maybe x), where t is a node label and Maybe x is the contents
07:37:41 <rabisg> merijn: so I was wondering what do people do in such cases
07:37:43 <tdammers> kqr: not at all
07:37:49 <athan> kqr: Now, normal lookups are just literal with this
07:37:54 <merijn> rabisg: There's a toStrict in bytestring which I've been informed is faster than building a strict bytestring directly
07:38:19 <rabisg> merijn: oh didnt know that. will look into it
07:38:21 <athan> kqr: But, if you mess with it a bit, and instead of forcing literal lookups with `t`, you have a function `forall r. (t -> Maybe r)`
07:38:31 <athan> kqr: This makes the "predicate", so to speak
07:38:38 <Eduard_Munteanu> Why do Debian Haskell packages depend on exact builds of other Haskell packages?
07:38:42 <merijn> rabisg: Data.ByteString.Lazy has toStrict/fromStrict
07:38:57 <athan> Then, the result of the parse (or what have you) is _applied_ to the result of the lookup, but that's an aside
07:39:03 <Eduard_Munteanu> Like, really now, do I have to rebuild everything to replace a package?
07:39:16 <rabisg> merijn: hmm but didnt know it was faster than building it directly
07:39:32 <kqr> athan, I haven't heard of that before...sorry
07:40:00 <merijn> rabisg: I didn't bother to benchmark that claim, it also depends on how big your bytestrings are
07:40:00 <athan> kqr: Then there's hope that I might become blasphamously famous for it! :D
07:40:26 <kqr> athan, possibly! or you'll be remembered as the one that listened to some silly guys advice on irc and reinvented the wheel only to find out later ;)
07:41:01 * athan gets a wrench
07:41:20 <kqr> rabisg, forcing strictness as late as possible sometimes helps with performance because you know more about the final result
07:41:44 <kqr> (heh. "forcing strictness as late as possible" sounds like a very roundabout way of saying "using laziness")
07:42:24 <rabisg> merijn: kqr thanks. I will revaluate my use case 
07:42:25 <kqr> rabisg, I imagine it might be similar to how the recommendation in Python is to use iterators/generators for all the intermediary code, and then force it to a list only as the last step
07:43:39 <merijn> kqr: Well using a strict builder might be faster than using lazy and converting to strict
07:43:55 <kqr> depends on what you are building and how, no?
07:43:56 <merijn> But then the question is whether the difference is significant enough to matter
07:44:01 <merijn> rabisg: btw
07:44:12 <rabisg> following
07:44:14 <merijn> rabisg: You said you have hand-written Serialize instances?
07:44:26 <merijn> Are you trying to conform to some existing format?
07:44:58 <rabisg> merijn: I mean I can write it easily since I already have the binary instance. isn't it?
07:45:29 <rabisg> same format as Binary instance would be fine
07:45:29 <merijn> rabisg: No, my question is: Are your serialise instances meant to produce binary output matching some existing format/spec?
07:46:18 <rabisg> merijn: not necessarily. I mean I dont have any restrictions on the format as such
07:46:25 <merijn> ok, then carry on
07:46:33 <kqr> merijn, what were you gonna say otherwise?
07:46:40 <rabisg> merijn: ^same question
07:47:03 <merijn> I just wanted to warn you that Serialize/Binary can (and do!) insert some library specific headers/chunks into the output
07:47:21 <merijn> If you want to match an existing spec use Get a/Put directly instead of relying on the classes
07:47:38 <merijn> I found this out after 4 hours of frustrated debugging of my zmtp parser :p
07:47:51 <kqr> oh
07:47:53 <kqr> good to know
07:48:02 <Noell96> #haskell-blah is dead and im bored!
07:48:07 <rabisg> merijn: thanks. I'll keep that in mind
07:48:13 <kqr> Noell96, answer stuff on stackoverflow
07:48:33 <joobus> Noell96: do actual work??? nah, nevermind.
07:48:34 <Noell96> im not that desperate yet
07:48:41 <Noell96> and i hate writing!!
07:48:44 <Noell96> :(
07:49:02 <arcaedox> Has anybody been able to build GLFW-b on windows 8 ?
07:50:02 <Eduard_Munteanu> Can someone remind me why Haskell libs depend on exact builds of other Haskell libs?
07:51:00 <bergmark> Eduard_Munteanu: usually they have version ranges of their dependencies, not just one specific
07:51:12 <Eduard_Munteanu> bergmark, I mean once compiled
07:51:42 <Eduard_Munteanu> <command line>: cannot satisfy conduit-1.1.6-d422ad1b0f15749ef6ade095c21dcc4b is unusable due to missing or recursive dependencies: lifted-base-0.2.0.3-635db11b8313e1acaa5140f2757e862e resourcet-1.1.2.3-300a5f454b32622dd26f5e38817d3f89-package conduit: 
07:52:22 <igniting> Data.ByteString.hPut does not give any error if the file corresponding to the handle is deleted?
07:52:23 <Eduard_Munteanu> Which happened after updating lifted-base.
07:53:06 <igniting> I tried in GHCi and hPut completed happily :/
07:53:06 <geekosaur> igniting, on unix the file still "exists" in kernel memory
07:53:16 <geekosaur> until all references go away
07:53:32 <igniting> oh, rm does not check for open handles?
07:53:33 <rabisg> Eduard_Munteanu: dont all packages (all languages) work like that? Once compiled, how can you be sure that it will work with any other version of the lib?
07:53:40 <geekosaur> on windows it does
07:53:43 <geekosaur> on unix it does not
07:53:45 <tdammers> it's called "unlink" for a reason
07:53:46 <merijn> Eduard_Munteanu: Cross-module/package inlining
07:53:56 <Eduard_Munteanu> rabisg, because ABI compatibility?
07:54:22 <geekosaur> that's even an idiom of sorts: for a secure temporary file, create-and-open O_RDWR and immediately unlink, then use the handle that is the only reference to the now anonymous file
07:54:32 <geekosaur> write, seek to beginning, read
07:54:47 <Eduard_Munteanu> Hm.
07:54:58 <merijn> Eduard_Munteanu: To get better performance GHC can dump whole functions into it's interface files and inline the cross module/package boundaries, which is what makes stuff like ByteString/Text/Pipes so fast
07:55:00 <int-e> Eduard_Munteanu: The ABI may change: Even though exported functions themselves are the same, a package can expose an unfolding that refers to auxilliary functions whose name and implementation can change based on the mood of the compiler.
07:55:09 <tdammers> geekosaur: aren't there even syscalls to not link the file at all in the first place, just create an open inode and a handle to it?
07:55:22 <merijn> Eduard_Munteanu: The downside is that your external interface becomes dependend on the exact version of your dependencies
07:55:25 <geekosaur> tdammers, not standard
07:55:26 <Eduard_Munteanu> merijn, so if I replace one package, do I have to replace all of the packages that depend on it recursively? :/
07:55:40 <merijn> Eduard_Munteanu: Yes, currently
07:55:43 <tdammers> geekosaur: of course not... the good stuff never is...
07:55:45 <Eduard_Munteanu> Awful. :(
07:56:10 <merijn> Eduard_Munteanu: GHC supports multiple parallel installs of the same package+version combo now, but the cabal-install UI isn't implemented/invented yet
07:56:20 <geekosaur> afs servers used to include a kernel module to provide iopen() like that. it does have some security implications since it's less trackable
07:56:41 <geekosaur> (and if you can open an existing inbode that way, you can bypass filesystem-based security)
07:56:45 <merijn> Eduard_Munteanu: So you could have the same package build with different dependencies, cabal is moving to a more Nix-like approach which should improve this
07:56:54 <geekosaur> *inode
07:57:00 <Eduard_Munteanu> I see.
07:57:06 <geekosaur> I should say path-based security
07:57:11 * hackagebot som 8.0.1 - Self-Organising Maps.  http://hackage.haskell.org/package/som-8.0.1 (AmyDeBuitleir)
07:57:11 <Eduard_Munteanu> Not sure if distro package managers can handle it.
07:57:19 <igniting> geekosaur: I would like the file not to be deleted if there are open handles, is there some way?
07:57:27 <Eduard_Munteanu> Perhaps I should build this program manually and link it statically.
07:57:34 <geekosaur> igniting, nope
07:58:03 <geekosaur> not without kernel hacking
07:58:17 <igniting> so I would have to do some gc on my own, assuming all the handles are opened by my program
07:58:41 <bennofs> Eduard_Munteanu: it's even worse than that. Prior to GHC 7.10, it could even fail if you rebuild the same package with exact the same source code and in the same environment
07:58:53 <merijn> igniting: You would like the file to not be deleted if it's open? Is your program the only one deleting the file?
07:59:06 <igniting> merijn: yes
07:59:21 <merijn> igniting: i.e. are you trying to make your program play nice with itself and not caring about something like "user ran 'rm' on my file"?
07:59:26 <bennofs> Eduard_Munteanu: Since some randomly generated variable names and similar stuff changed from run to run in the .hi files :/
07:59:53 <igniting> merijn: for now, yes
08:00:03 <Eduard_Munteanu> Yikes.
08:00:05 <merijn> igniting: Posix has the flock() interface (pretty sure there's posix haskell bindings for that) which lets you get a "voluntary lock" on a file
08:00:31 <merijn> igniting: That lock doesn't actually stop you from deleting the file, but you could do something like "if locked, don't delete, else, delete"
08:00:41 <merijn> So if it's only your program that would work
08:01:04 <merijn> On windows you can't delete open files anyway
08:03:31 <frerich> merijn: You can delete open files on WIndows; whether or not it works depends on the flags used when opening the file.
08:04:00 <merijn> ah
08:04:17 <merijn> So all the application developers are just asses for blocking my files indefinitely :p
08:04:29 <igniting> merijn: what happens if the process which had lock crashes?
08:04:35 <frerich> merijn: Most popular example is deleting the executable of a program currently running, which fails because Windows opened the executable (or DLLs) with a 'Don't elete this please' flag.
08:04:36 <tdammers> igniting: then you have to reboot
08:04:44 <bergmark> I can never delete folders because of Thumbs.db
08:05:41 <igniting> tdammers: that's why I was advised against using locks I guess. I was looking for a workaround.
08:06:04 <merijn> igniting: You can have a signal handler release the lock on crashes, but that still leaves you screwed if you get SIGKILLed
08:07:00 <frerich> Wow, flock() locks are not released by the OS? That's quite harsh.
08:07:06 <merijn> So, it seems that linux actually releases the lock
08:07:11 * hackagebot grid 7.8.1 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.8.1 (AmyDeBuitleir)
08:07:14 <merijn> It's just not guaranteed by posix
08:07:16 <frerich> On Windows, 'FileLock()' handles are reclaimed by the OS (as part of closing all the handles).
08:07:54 <frerich> Err, LockFile().
08:08:44 <xelxebar> anyone here read the Journal of Functional Programming?
08:09:54 <geekosaur> afaik posix doesn't guarantee it because some posix emulations don't support it, but all unixlikes (and certainly all those supported by ghc) will clean locks up on exit
08:10:17 <igniting> I'm writing a package for reading and writing large binary values, in which I'm trying to handle these cases.
08:11:37 <onTrain> I have a function defined using some parameters loaded from a file (using file-embed template haskell). I want to use the ad library on this function but I can't figure out how to make a read instance for the numeric types loaded from the file. Any advice on how to approach this?
08:12:45 <merijn> xelxebar: I think a lot of people have read stuff from there, yes
08:13:20 <merijn> onTrain: You should probably just use a parser instead of a Read instance
08:13:45 <yac> \x -> liftIO (atomically $ newTVar x) >>= putState
08:13:55 <yac> how can this be rewritten without the lambda?
08:14:14 <yac> I tried putState =<< liftIO . atomically . newTVar
08:14:25 <yac> but that doesn't type check
08:15:37 <Ferdirand> (putState =<<) . liftIO . ...
08:16:13 <onTrain> merijn: Does Parsec easily support "vague" numeric parsers? Attoparsec seems to require me to parse a Double which puts me in the same place
08:16:25 <yac> oh, thanks Ferdirand 
08:17:53 <merijn> onTrain: There's several parsec/attoparsec wrappers for more complex numbers
08:19:37 <mjrosenb> can I run ghci, asking it to load everything in a .cabal file in pwd?
08:19:41 <onTrain> merijn: excellent.
08:19:42 <merijn> Hell, it shouldn't be very hard to write your own
08:20:09 <merijn> onTrain: https://hackage.haskell.org/package/parsec-numbers-0.0.1/docs/Text-ParserCombinators-Parsec-Number.html for example?
08:20:20 <xelxebar> merijn: if you're aware, is the journal accessible to someone more familiar with CT formalisms?
08:20:20 <merijn> eh
08:20:34 <merijn> That's ridiculously old, click to a newer version of that package :p
08:21:13 <merijn> Actually, the entire thing is old, but you could copy the code since it's BSD
08:21:42 <merijn> xelxebar: IJFP isn't VERY theory focussed
08:21:57 <onTrain> merijn: the type sig for floating2 there looks like what I want. Thank you
08:22:09 <merijn> xelxebar: So I would expect to see some CT mentioned, but mostly in passing and not in-depth
08:22:31 <merijn> onTrain: Like I said, the dependencies are stupid old, but porting it to whatever version of attoparsec/parsec you're using is probably simple
08:23:19 <merijn> oh, it's not actually that bad, just confusingly linked/named
08:26:19 <xelxebar> merijn: okay. thanks. I'm sort of looking for a place that would bridge the math formalisms and the Haskell implementations. For example, discussing what an Applicative functor is, generalizing to n-cats, etc.
08:26:39 <ij> Does Pred in "type Pred a = a -> Bool" have a functor instance?
08:27:39 <fread2281> is there a typeclass for pure + mappend (like a set) somewhere?
08:28:07 <fread2281> or not pure, but some insert
08:28:13 <merijn> xelxebar: I'm not really sure what the place to go is for that, you could try asking on haskell-cafe mailing list for suggestions?
08:29:20 <ij> Nevermind — no, it's not.
08:29:51 <xelxebar> merijn: thanks. that's a good suggestion
08:30:56 <JagaJaga> Is there a library with a function to check if `programName` exists in $PATH?
08:32:12 * hackagebot creatur 5.9.3 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.9.3 (AmyDeBuitleir)
08:34:15 <yac> where should I get fst3 from? 
08:35:07 <merijn> ij: It has a Contravariant instance, though! :)
08:35:23 <yac> looks like MissingH or extra
08:35:42 <frerich> yac: If it's only for that single function, I'd define "fst3 (a,_,_) = a" myself.
08:35:47 <ij> merijn, I'm fpcomplete exactly about that.
08:36:03 <Cale> yac: I'd just write a lambda
08:36:40 <Cale> yac: (\(x,_,_) -> x) is pretty short and clear
08:38:00 <ronh> if someone uses cabal sandbox I am wondering how do you handle huge libraries that take ages to compile? do you recompile them for each sandbox? do you share sandbox with those libraries in all the projects?  someting else?
08:39:25 <merijn> ronh: I mostly install into the user database unless it fails and only then use a sandbox
08:39:59 <ronh> user database = global cabal install?
08:40:26 <lpaste> slack1256 pasted “Simple TypeFamilies” at http://lpaste.net/130699
08:40:46 <slack1256> any idea why doesn't type checks?
08:42:30 <dolio> slack1256: Because b is ambiguous?
08:43:19 <eze> > 1+2
08:43:21 <lambdabot>  3
08:43:35 <eze> > :t 1
08:43:36 <lambdabot>  <hint>:1:1: parse error on input ‘:’
08:43:49 <eze> :t 1
08:43:51 <lambdabot> Num a => a
08:43:54 <quchen> slack1256: b can be anything, as long as Fun b = Bool. You provided one mapping from Char to Bool, but GHC cannot know that there aren't any others.
08:44:30 <quchen> slack1256: The problem is that type families aren't injective, so even though the compiler sees "Fun a = Fun Char", that does not imply "a = Char".
08:44:54 <Cale> Then again, the implementation doesn't need to know which type b is.
08:45:06 <Cale> (in this case)
08:45:13 <slack1256> I would argue that it isn't neccesary
08:45:19 <dolio> It probably doesn't realize that.
08:45:26 <slack1256> oh
08:46:30 <Cale> Because there's no explicit type application, even if you get it to accept this definition, you wouldn't be able to apply it
08:46:36 <dolio> I don't understand the algorithm well enough to tell you exactly why it doesn't like this example, but it seems like the kind of thing it doesn't like.
08:47:17 <Cale> Because even applying isUpp to some Bool value, it still needs to apply the (invisible at source level) type lambda to some 'b'
08:47:18 * hackagebot hoogle-index 0.4.2 - Easily generate Hoogle indices for installed packages  http://hackage.haskell.org/package/hoogle-index-0.4.2 (BenGamari)
08:47:23 <Cale> and it can't guess one
08:48:05 <Cale> and there's no syntax available to tell it you, for instance, want b = Char
08:48:38 <Cale> isUpp :: (Fun b ~ Bool) => b -> Fun b -> Bool
08:48:38 <Cale> isUpp _ = id
08:48:42 <Cale> that would work though
08:48:48 <Cale> Or even...
08:48:52 <slack1256> right!
08:48:55 <slack1256> you are right
08:49:02 <slack1256> if it were to accept it
08:49:07 <quchen> Proxy b should suffice
08:49:08 <Cale> isUpp :: (Fun b ~ Bool) => p b -> Fun b -> Bool
08:49:09 <Cale> isUpp _ = id
08:49:24 <Cale> (with which you can use Proxy to fill the argument)
08:49:27 <slack1256> isUpp True would force the compiler to know that Bool ~ Fun Char
08:49:37 <slack1256> which goes on the other direction of the type instance
08:50:12 <slack1256> as it isn't injective, it can't assure that there is ONE instance that results in Bool
08:50:42 <dolio> It seems like it could do simplification of the type to get Bool -> Bool, which doesn't involve b at all, but it probably doesn't do that until after checking types, if at all.
08:52:07 <dolio> It probably also doesn't have the right passes to turn Fun b into Bool and then realize it can forget about (Fun b ~ b
08:52:14 <Cale> In fact, it does the opposite in a sense
08:52:14 <dolio> Er, Fun b ~ Bool.
08:52:18 * hackagebot creatur 5.9.4 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.9.4 (AmyDeBuitleir)
08:52:30 <Cale> It preserves the type equality constraints, turning them into explicit coercion parameters
08:53:04 <Cale> You'll see these things at the level of Core still :)
08:54:13 <dolio> Sometimes it gets rid of equality constraints. As it should.
08:54:26 <dolio> @let wat :: (b ~ Bool) => b -> b ; wat x = x
08:54:27 <lambdabot>  Defined.
08:54:29 <dolio> :t wat
08:54:30 <lambdabot> Bool -> Bool
08:54:39 <dolio> I just don't think it knows enough to get rid of this one.
08:59:04 <xelxebar> is there a way to enforce natural numbers in the types?
08:59:23 <xelxebar> I'd rather avoid doing Maybe Integer with error checking
08:59:39 <chpatrick> in what context?
09:00:18 <chpatrick> you could make a newtype with a smart constructor, probably exists somewhere already
09:00:26 <chpatrick> newtype Natural = Natural Integer
09:00:32 <chpatrick> mkNatural :: Integer -> Maybe Natural
09:00:34 <ion> http://hackage.haskell.org/package/base-4.8.0.0/docs/Numeric-Natural.html
09:01:03 <ion> Alas, it doesn’t use the type system to prevent things like 1 - 2.
09:01:04 <quchen> ♥
09:01:48 <chpatrick> nice
09:02:09 <quchen> Interesting that it's not just a newtype around Integer.
09:02:17 <xelxebar> chpatrick: yeah, I was worried about the exact case that ion mentioned
09:02:34 <koral> Hi, I'm considering forking the network-uri package to include backward-incompatible changes (like turning Strings into Texts), as suggested by the maintainer; do you have any suggestions on the name of such fork ?
09:02:38 <chpatrick> you could use type level nats
09:02:39 <xelxebar> ion: thanks for the reference to Numeric!
09:02:42 <quchen> xelxebar: There's unsafety in constructing these values, yes, but if your function expects a Natural it'll always be nonnegative.
09:02:46 <chpatrick> but that's more trouble than its worth
09:02:54 <chpatrick> imho
09:03:48 <quchen> ion: Any idea why this isn't in GHC's changelog?
09:04:09 <quchen> 4.8 from GHC 7.8?
09:04:11 <ion> I don’t know, but it’s in base’s changelog.
09:04:13 <ion> 7.10.1
09:04:14 <jellie> What do such lines in haskell code mean: `#if MIN_VERSION_http_client(0,4,7)`
09:04:50 <geekosaur> jkellie: https://www.haskell.org/cabal/users-guide/developing-packages.html#conditional-compilation
09:04:51 <xelxebar> chpatrick: Peano nats or something? that seems like it could slow down ghc quite a bit if you're not careful
09:04:58 <geekosaur> er jellie
09:05:01 <ion> jellie: Cabal can create macros like that when building a package. It is true if the installed version of http-client is ≥ 0.4.7.
09:05:03 <chpatrick> xelxebar: https://hackage.haskell.org/package/base-4.8.0.0/docs/GHC-TypeLits.html
09:05:28 <chpatrick> but in my experience all this quasi-dependent typing stuff in haskell wastes more of your time than it saves in catching bugs
09:05:48 <merijn> chpatrick: But you get to brag about it!
09:06:02 <jellie> ion: So that is generated and not code that was written? I'm talking about such: https://github.com/yesodweb/yesod/blob/master/yesod-bin/Devel.hs#L146
09:06:07 <chpatrick> you get into the secret nerd club
09:06:11 <jellie> geekosaur: Yes?
09:06:26 <ion> jellie: No, the macro MIN_VERSION_http_client was generated, the code you linked is written to use that macro.
09:06:38 <exio4> chpatrick: it is fun though
09:06:41 <merijn> chpatrick: Like the fact that my (still in-progress after two years) zmq library statically guarantees it never takes the wrong authentication code path!
09:06:43 <chpatrick> true
09:06:45 <geekosaur> [14 16:01] <geekosaur> jellie: https://www.haskell.org/cabal/users-guide/developing-packages.html#conditional-compilation
09:06:45 <xelxebar> chpatrick: interesting. thanks for the link
09:06:55 <ion> merijn: cool
09:06:56 <quchen> merijn:  You also get to understand these kinds of things better, and if enough people do decisions on making it standard, ditching it, or putting it into limbo can be made.
09:07:13 <jellie> ion: What I liked was line 72 of that file.
09:07:59 <jellie> ion: So I write a .hs file then I assume template haskell adds some code to that file during compilation?
09:08:12 <ion> jellie: That is implemented using CPP, not TemplateHaskell.
09:08:12 <jellie> geekosaur: Thanks
09:08:36 <merijn> ion: I'm moving a lot of that checking into using singletons so now I have to refactor everything again xD
09:08:46 <merijn> Hopefully one of these days I'll finish writing tests and publish it :p
09:08:49 <ion> merijn: hehe
09:09:04 <jellie> ion: So a simple explanation would be that at compile time my source file will by edited by the CPP compiler?
09:09:06 <ion> merijn: Did you use hand-written singletons before?
09:09:14 <jellie> geekosaur: Reading now
09:10:15 <geekosaur> CPP is a preprocessor. cabal, as documented in that link, can define cpp macros that let you do things conditionally depending on the version of a dependency
09:10:17 <ion> jellie: At compile time there will be an automatically built header with macro definitions that your code can take advantage of using the CPP (C-style preprocessor) extension.
09:10:25 <merijn> ion: Basically
09:10:41 <merijn> ion: And explicitly passed values
09:11:01 <merijn> ion: I'm trying to replace all of that by reflecting values from types via singletons to avoid the ability to make mistakes
09:11:14 <ion> ok
09:11:28 <merijn> ion: But it results in...rather big type signatures :p
09:11:34 <jellie> geekosaur: ion So the source file didn't have code added to it by the preprocessor or anything?
09:11:41 <geekosaur> nope
09:11:43 <merijn> And I need to add SingI constraints in lots of places
09:12:05 <geekosaur> you write your source code with annotations like that when you need to do something differently based on what version of http-client is installed
09:12:44 <hexagoxel> mjrosenb: `cabal repl` might not load _everything_, but maybe sufficient?
09:12:48 <geekosaur> and cabal will generate the macros like MIN_VERSION_http_client() based on what is installed on the system you code is being built on
09:13:34 <jellie> geekosaur: I should probably find out what macros are.
09:14:15 <geekosaur> read that link, it tells you what's going on and gives you some terms to look up
09:15:18 <geekosaur> or look at the docs for cpphs, which is used when the C preprocessor on the system is unavailable or not usable (clang's is not very compatible with Haskell code, for example, which is relevant on freebsd and os x)
09:15:51 <geekosaur> (and some of us think using the C preprocessor on Haskell code is asking for trouble anyway...)
09:16:04 <cfoch> could we say a that a type B is a "subclass" of class A, if B declares an instance of A? Can we make this analogy?
09:16:05 <geekosaur> (which is what cpphs is about)
09:16:39 <ion> cfoch: I don’t think so.
09:16:56 <geekosaur> only in a highly misleading sense
09:17:13 <ion> Applicative is a subclass of Functor, Maybe is an instance and not a subclass of Functor.
09:17:32 <merijn> Quick question: If my tests (ab)use internal modules how can I accomplish that?
09:17:45 <cfoch> ion: why?
09:17:53 <merijn> i.e. I have a library and my tests require access to an internal module
09:18:05 <cfoch> Int is a subclass or an instance of Num ?
09:18:22 <ion> class Functor f; class Functor f => Applicative f; instance Functor Maybe
09:18:23 <geekosaur> instance
09:18:39 <merijn> cfoch: Instance, it's not a typeclass
09:19:06 <bennofs> merijn: expose internal modules too? or add the library source directory to hs-source-dirs for the tests too, but that will compile the library twice (one for the lib, another time the used modules for the tests)
09:19:12 <cfoch> so, all these elements here are instances of the bold ones? http://upload.wikimedia.org/wikipedia/commons/thumb/6/69/Classes.svg/480px-Classes.svg.png
09:19:14 <ion> instance Num Int  -- Int is an instance of Num
09:19:21 <ion> class Num a => Fractional a  -- Fractional is a subclass of Num
09:19:38 <merijn> bennofs: Ok, so that works fine? (aside from double compilation)
09:20:06 <mjrosenb> hexagoxel: yeah, it is.  thanks.
09:20:12 <bennofs> merijn: you might need to have to duplicate the dependencies of the library :/
09:20:19 <ion> cfoch: Bold text is a class, non-bold text is a type that is instance of said class, an arrow corresponds to a subclass relationship.
09:21:59 <ion> That diagram needs an update. Num no longer requires Eq and Show; Monad requires Applicative which requires Functor.
09:22:32 <merijn> bennofs: :\
09:22:43 <merijn> Anyway, I'll tackle this problem later
09:22:54 <merijn> Time for relaxing
09:25:22 <athan> Is there a better way to `($ r) <$> foo`?
09:25:55 <merijn> eh <*> ?
09:26:02 <merijn> oh wait
09:26:08 <merijn> "foo <*> pure r", I guess
09:26:24 <Cale> That's one of the Applicative laws
09:27:19 * hackagebot tagchup 0.4.0.4 - alternative package for processing of tag soups  http://hackage.haskell.org/package/tagchup-0.4.0.4 (HenningThielemann)
09:28:27 <hodapp> hm, is (maybe [] (\_ -> foo)) equivalent to some other simpler function?
09:28:59 <hodapp> perhaps my case is just weird
09:29:42 <jellie> ion: In a case which one uses comditional compilation and uses the #if ... #endif shouldn't the dependency have been specified in the cabal file instead? For example https://github.com/yesodweb/yesod/blob/master/yesod-bin/Devel.hs#L72
09:29:50 <jellie> ion: It's the same file.
09:30:08 <hodapp> but I'm in the situation of building up a list from various things, including several different Maybe values which should not contribute anything to the list if Nothing, and contribute [foo] otherwise (contents inside the Just are irrelevant)
09:30:58 <jellie> hodapp: I don't know what you're talking about but lately I've been throwing comprehensions at everything.
09:31:14 <hodapp> jellie: it is possible this is good advice.
09:31:32 <geekosaur> jellie, the #if is for the case where you can use multiple versions of a dependency but need different code for some of those versions, *and* when constraining the dependency so you only need to use the same code means forcing people to install different versions of ghc 
09:31:46 <monochrom> there is a maybeToList. combine it with map (const foo)
09:32:19 <lush> hi everyone
09:32:20 * hackagebot data-accessor-template 0.2.1.12 - Utilities for accessing and manipulating fields of records  http://hackage.haskell.org/package/data-accessor-template-0.2.1.12 (HenningThielemann)
09:32:35 <kuribas> hodapp: mapMaybe (const "foo")?
09:32:47 <geekosaur> for example, it's generally a PITA to get a newer version of ghc on Debian, and getting pretty much any external dependency (that is, some library you FFI to) on Windows is painful
09:33:21 <jellie> geekosaur: Okay uh...
09:34:01 <jellie> geekosaur: As far as I can see in that L72 one is forced to use >= http-0.4.7
09:34:06 <geekosaur> so you allow multiple versions of a dependency but need different code to deal with older versions of that dependency, so you use the #if in your code
09:34:12 <hodapp> kuribas: doesn't typecheck, first arg is a -> Maybe b
09:34:19 <hodapp> though I guess that's easily fixed
09:34:31 <jellie> geekosaur: It's not allowing for other versions.
09:34:36 <ClaudiusMaximus> > let j = Just{}; n = Nothing in [ c | (Just{}, c) <- [j,n,j,n,n,j] `zip` "hodapp" ]
09:34:36 <Faucelme> hodapp: \foo m -> maybeToList m *> foo
09:34:37 <lambdabot>  "hdp"
09:34:47 <jellie> geekosaur: L72 has no else
09:34:57 <kuribas> :t mapMaybe (fmap (const "foo"))
09:34:58 <lambdabot> [Maybe b] -> [[Char]]
09:35:24 <geekosaur> jellie, did you look for similar conditionals elsewhere?
09:35:24 <ion> athan: foo $> r
09:35:35 <merijn> jellie: It doesn't need an else, because the import wasn't needed for older versions
09:35:38 <ClaudiusMaximus> (though that does assume all the maybes have the same type)
09:35:40 <ion> athan: Sorry, that’s not it.
09:35:41 <Faucelme> (*>) . maybeToList
09:35:48 <geekosaur> I see it saying import that only if the min version is met, then code elsewhere in the same file does different things based on whether it is available or n ot
09:35:48 <merijn> jellie: https://github.com/yesodweb/yesod/blob/master/yesod-bin/Devel.hs#L146-L150
09:35:49 <athan> ion: Yeah I didn't think so :\
09:35:56 <athan> Thanks merijn anyway!
09:36:06 <merijn> jellie: The code there changes depending on version, so the import is needed for the alternative version
09:37:03 <ion> athan: lens has (??)
09:37:27 <athan> thanks ion :)
09:37:35 <jellie> geekosaur: merijn: hmmm I see. I was looking at that line in isolation.
09:37:40 <athan> also, that's crazy o_o how does it work?
09:37:40 <mjrosenb> in Reactive.Banana, is it possible to turn a [Moment t ()] into a Moment t ()?
09:37:56 <merijn> mjrosenb: Isn't Moment t a monad?
09:38:17 <athan> that's friggin sweet!
09:38:30 <ion> jellie: Conditional compilation lets you support a wider range of versions for the dependency.
09:38:44 <merijn> mjrosenb: Right, it's a monad, so just sequence_?
09:38:53 <geekosaur> jellie: given that an import generally has no effect on anything by itself, I would expect to go looking for other appearances of the conditional
09:39:17 <mjrosenb> oh, if it is a monad, I can just use mapM, rather than map
09:39:18 <mjrosenb> err
09:39:21 <mjrosenb> mapM_
09:39:22 <geekosaur> (the exception is when something moves, as with Applicative being partly in the Prelude in ghc 7.10)
09:39:22 <mjrosenb> no
09:39:28 <mjrosenb> those types don't work.
09:39:32 <geekosaur> (or when network-uri was split from network)
09:39:47 <merijn> mjrosenb: Why not?
09:39:53 <merijn> :t sequence
09:39:54 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
09:39:56 <merijn> errr
09:39:59 <merijn> :t sequence_
09:40:00 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
09:40:05 <jellie> geekosaur: ion What is that #if... #endif called? Is it what is called an if-def?
09:40:28 <geekosaur> #ifdef is a separate kind of conditional, testing whether some macro is defined
09:40:32 <merijn> jellie: No, that's just an if/else ifdef are named for, well, being written "#ifdef"
09:40:33 <geekosaur> #if is the more general one
09:40:40 <geekosaur> it's a CPP conditional
09:40:54 <mjrosenb> merijn: nope, I was wrong.  I can totally use mapM_.
09:41:38 <jellie> and do various #if #end from a single file end up making one header file or do all the #if ... #end from a project get bundled into one header file?
09:42:11 <jellie> geekosaur: Being that #if is more general you are saying that it's more powerful, right?
09:42:21 <merijn> jellie: There are no header files in haskell
09:42:46 <merijn> jellie: CPP just takes a file and adds/removes contents depending on the CPP macros used
09:43:20 <hodapp> kuribas: yeah, variation of this seems to work
09:43:34 <hodapp> also turns out I do need the contents of Just, sometimes
09:43:45 <jellie> merijn: and #if... #end is an example of a CPP macro and so it #ifdef?
09:44:09 <mjrosenb> with RankNTypes, is it possible to write a function that transforms a heterogenous list of showable values to a string?
09:44:27 <ion> athan: How does (??) work? Exactly how you defined it in your original question.
09:45:17 <chpatrick> mjrosenb: depends on how you define your heterogenous list
09:45:25 <chpatrick> but in general yes
09:45:48 <mjrosenb> that is good to hear.
09:45:53 <athan> :x
09:45:58 <mjrosenb> what would its signature be?
09:46:12 <chpatrick> what does your list look like?
09:46:29 <mjrosenb> shower :: [forall s. Show s => s] -> String
09:46:40 <chpatrick> that's impredicative
09:46:54 <chpatrick> the thing is though
09:47:11 <chpatrick> if you have a type forall s. Show s => s, all you can do is turn it into a string anyway
09:47:15 <chpatrick> so why not just have a list of strings
09:47:15 <ion> That list is equivalent to [String]
09:47:27 <mjrosenb> sadly, Ideally, it would be something like [2, "foo"], which doesn't actually typecheck.
09:48:03 <mjrosenb> the class isn't Show, it is Widget, and I'm attempting to be able to handle a list of heterogenous Widgets.
09:48:16 <monochrom> forall? exists?
09:48:20 <mjrosenb> while leaving it extensible to anyone else who wants to implement the Widget class
09:48:33 <chpatrick> sounds like https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
09:48:40 <monochrom> you may like:
09:48:45 <monochrom> @quote monochrom river
09:48:45 <lambdabot> monochrom says: You are to send a boolean, a character, and an integer across the river. The list for transporting across the river can hold 3 items, in fact any number of items you like, but they must all be of the same type. On the bright side, after crossing the river, the boolean, the character, and the integer need only be put on show. How
09:48:45 <lambdabot> many trips do you need? Solution: one trip, [show the_boolean, show the_character, show the_integer]
09:52:11 <mjrosenb> monochrom: yeah, however, the typeclass that I'm using has multiple "extract a value of uniform type from this value" functions, so I can't just run one function on all of them.
09:52:17 <mjrosenb> chpatrick: I shall read that on the train.
09:52:34 <cfoch> ion: is there something here that is not a data type¡
09:52:37 <cfoch> ?
09:52:37 <cfoch> http://upload.wikimedia.org/wikipedia/commons/thumb/6/69/Classes.svg/480px-Classes.svg.png
09:52:50 <cfoch> *a type?
09:52:57 <cfoch> for example, is there a data type?
09:53:23 <cfoch> or newtype
09:54:23 <monochrom> mjrosenb: then look for existential types
09:54:58 <ion> cfoch: The instances of Functor, Monad and MonadPlus are type constructors (of kind * -> *), not types of kind *.
09:54:59 <monochrom> it may be ironic that the article you're postponing is the very article that will tell you right now, even though it advises against doing it
09:55:35 <Cale> cfoch: I don't understand that question
09:56:44 <cfoch> Cale: if all those non-bold words represent a type only? or there are data types and newtypes there? 
09:57:11 <Cale> The things defined by data and newtype declarations are types.
09:58:04 <Cale> There are in fact, apart from the classes, only things listed there which were declared using data or newtype.
09:58:21 <Cale> Type synonyms declared with the type keyword are not allowed to be instances of classes.
09:59:10 <jellie> What does it mean when one pattern matches with an underscore at the beginning of a pattern? e.g `lockFile _opts =  "yesod-devel/devel-terminate"`
09:59:28 <Cale> (with extensions, GHC will try to unfold the type synonyms in instance heads, but you can't declare separate instances for a synonym than were defined on the base type)
09:59:52 <Cale> jellie: That's just a convention for "I'm not going to use this"
10:00:04 <jellie> Oh I see
10:00:20 <jellie> Cale: Thank you
10:00:28 <dolio> It's still a named parameter, though. It doesn't work like _.
10:00:33 <Cale> jellie: GHC won't warn about unused parameters which start with an underscore, if you have that warning turned on.
10:01:50 <Cale> cfoch: Does that make sense?
10:02:28 <Cale> cfoch: Some people have suggested that the use of the keyword 'type' was confusing, and something like 'alias' should have been used instead.
10:03:06 <jellie> Cale: I see :)
10:03:10 <jellie> Don't be afraid to sound stupid is my motto.
10:04:19 <monochrom> I don't have that motto, but I do it anyway
10:04:35 <jellie> monochrom: LOL
10:04:52 <Cale> cfoch: because of the three {data, newtype, type}, it's the only one which doesn't actually define a new type -- it just defines an alias which effectively macro-expands to an existing type.
10:05:06 <monochrom> when there is a question or an assertion, I sometimes choose a word used and ask "what does it mean?"
10:05:21 <monochrom> and it always turns out that I hit the gist.
10:06:26 <jellie> monochrom: Do you know about the CPP haskell extension?
10:06:45 <monochrom> I haven't used it
10:06:46 <jellie> monochrom: Can #if ... #else #endif be considered macros?
10:06:57 <jellie> are they macros?
10:07:14 <monochrom> no. even C doesn't consider them macros. C considers them conditional compilation
10:07:30 <jellie> monochrom: What about #ifdef?
10:07:39 <monochrom> still a conditional
10:07:46 <mauke> "preprocessor directive"
10:08:13 <jellie> monochrom: I don't want to look read on C++ macros such as #define because they'll just confuse me in regards to haskell, no?
10:08:25 <monochrom> "#define HAHA 10000", that makes HAHA a macro. however, "#define" is still not a macro. "HAHA" is.
10:08:26 <jellie> monochrom: So where in haskell do we have macros?
10:08:49 <monochrom> CPP does not mean C++
10:09:03 <monochrom> CPP means C pre processor
10:09:09 <geekosaur> jellie, in Haskell we don't. there are Template Haskell splices which serve a similar purpose
10:09:10 <jellie> monochrom: Shock on me.
10:09:30 <cfoch> Cale: if data, newtype and type are more like an 'alias', which would be more like a type? (
10:09:41 <geekosaur> well, it;'s been used for both although the trend is for the C++ one to be called CXX instead
10:10:09 <jellie> monochrom: So the C pre processor adds or removes lines of code during compilation.
10:10:13 <geekosaur> cfoch, you seem horribly confused
10:10:14 <Cale> cfoch: No, only 'type' defines aliases
10:10:17 <jellie> monochrom: I believe I got it.
10:10:20 <jellie> geekosaur: Thanks
10:10:20 <geekosaur> `type` (the keyword) defines aliases
10:10:23 <Cale> cfoch: 'data' and 'newtype' define new types
10:10:25 <cfoch> ah ok
10:10:25 <jellie> monochrom: Thanks
10:11:13 <mauke> technically the C preprocessor is C's tokenizer (and does some transformations with its token stream)
10:11:23 <jellie> geekosaur: Do we use #ifdef in haskell? Do you have any example code?
10:11:48 <jellie> mauke: tokenizer?
10:11:58 <geekosaur> jellie, as I commented earlier, I try to avoid using it
10:12:08 <mauke> jellie: also known as "lexer"
10:12:18 <Cale> cfoch: For example, if I write  type Label = String  this defines Label to be the same type as String. The type system will not distinguish between those two things. If I declare something to be a Label, I can use it anywhere that a String is required and vice-versa.
10:12:35 <jellie> mauke: Thanks for giving me the name preprocessor directive now I know what to call #if s and #ifdef s.
10:12:44 <onTrain> merijn: had a bit of a battle with the morphism restriction, but this is working excellently. Thank you
10:12:55 <jellie> mauke: I've heard the word lexer thrown about but I don't know about it.
10:13:41 <Cale> cfoch: Whereas if I write  newtype Label = L String  this defines Label to be a completely distinct type from String, along with a data constructor L :: String -> Label  for making Label values (and explicit pattern matching to get Strings back out again)
10:14:00 <Cale> cfoch: If I use a Label where a String is required, or vice-versa, the type system will complain
10:15:56 <Cale> The situation with  data Label = L String  is similar, only with some subtle semantic differences with respect to pattern matching allow for the newtype to impose no additional runtime cost, while the L constructors defined by data would physically take up memory at runtime. (data declarations are also much more general than newtypes, because they may have multiple constructors and each constructor may have multiple fi
10:15:56 <Cale> elds)
10:24:48 <cfoch> Cale: thanks, I understand now
10:26:19 <Javran> I have a hpc question here: is it possible to specify where should .tix files be generated?
10:29:25 <NemesisD> is it possible to add a typeclass constraint to a type family's associated type?
10:30:00 <NemesisD> i.e. class (SomeClass (Associated a)) => Foo a where type Associated a :: *
10:30:10 <Gal3rielol> I have a question about concurrency in Haskell, is MVar the most fundamental way of building concurrency programs?
10:30:15 <dolio> NemesisD: I believe so.
10:30:30 <mauke> Gal3rielol: no, and what do you mean by "fundamental"?
10:30:49 <edwardk> @remember glguy I heard id was unsafeCoerce with a restrictive type
10:30:49 <lambdabot> Nice!
10:31:02 <geekosaur> heh
10:31:14 <Gal3rielol> like a spin lock in a imperative language?
10:31:31 <mauke> I've never used a spin lock but it sounds bad
10:31:34 <Gal3rielol> you can build other locks on spin lock.
10:31:47 <mauke> locks are also often bad
10:32:01 <Gal3rielol> what's the other options of concurrency programming in Haskell?
10:32:03 <Gal3rielol> STM?
10:32:07 <mauke> yeah
10:32:43 <Gal3rielol> I am wondering the performance of STM, is there any benchmark of STM in Haskell?
10:34:44 <ReinH> Gal3rielol: It's probably fast enough.
10:34:50 <lush> Is there a way to use a System.IO.Handle in sth. similar to Data.Map? I'm currently trying to write a simple chat server that handles users with a certain nick name and just supports broadcasting a message to all connected users (atm). I tried to use a Data.Map Handle User (where type User = String) to manage all the connected users.. how'd you do that instead?
10:35:11 <mcfound> what is a usable haskell ide?
10:36:02 <Gal3rielol> I will recommend emacs as a haskell ide
10:36:03 <lush> mcfound: maybe try http://leksah.org/ or https://atom.io/
10:36:16 <lush> mcfound: although you need to add some extensions to atom
10:36:39 <chpatrick> lush: if you're sending to all users why do you need a map?
10:37:01 <MichielDC> emacs with Haskell-mode or ghcmod?
10:37:13 <chpatrick> I can't really think of a situation where I would have a handle before I would know who I'm sending something to
10:37:17 <igniting> mcfound: with vim you can use haskell-vim-now
10:38:21 <Gal3rielol> see this https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md
10:39:11 <davidfetter> anybody using yi?
10:39:31 <lush> chpatrick: If I'd use Data.Map User Handle and I want to change a nick I currently only had a handle that relates to the user to change, but not it's current nickname... so I thought I'd try to switch User -> Value and Handle -> Key
10:39:45 <lush> Is there a simple way to achieve renaming with Data.Map User Handle?
10:39:59 <Gal3rielol> I feel like Yi is still immature.
10:40:25 <lush> it's probably a design mistake, that was just my first attempt and I tried to extend the tcp server from: http://www.catonmat.net/blog/simple-haskell-tcp-server/
10:41:13 <geekosaur> had you considered assigning each user a unique ID of some kind and then using that with a map id->user, id->handle, etc.?
10:42:03 <geekosaur> or even store them in the same Map (Map UserID UserData with data UserData = UserData {nick :: String, conn :: Handle, ... }
10:42:22 <lush> geekosaur: no, but that may be a much better and more flexible approach
10:42:24 <lush> ty)
10:43:07 <MichielDC> haskell-mode or ghcmod for emacs?
10:43:21 <geekosaur> perhaps a reverse map from nick to UserID which fo coruse would need to be changed when they change nicks, but as the nick is how most chat protocols present them to you (you can't make it use your UserID) you'd need that map regardless
10:43:52 <NemesisD> are type synonym instances safe? does it force there to be 1 unique instance when all type synonyms are resolved?
10:43:54 <Gal3rielol> you can install both, they serve different purposes
10:44:11 <arkeet> NemesisD: it is safe
10:44:22 <arkeet> it just expans the type synonym inside instance declarations
10:44:29 <arkeet> expands.
10:44:56 <NemesisD> arkeet: thanks!
10:47:19 <fryguybob> Gal3rielol: There are some STM benchmarks but the performance is highly dependent on how it is used.  Haskell's STM is very nice for getting correct, concurrency.
10:47:23 * hackagebot xmobar 0.23.1 - A Minimalistic Text Based Status Bar  http://hackage.haskell.org/package/xmobar-0.23.1 (JoseAntonioOrtegaRuiz)
10:49:43 <lush> geekosaur: ty, I'll try :)
10:50:01 <fizbin> Is there a standardly defined function that means the same as (>>=) but is all letters so that you use it as a prefix?
10:50:19 <mauke> how about (>>=)?
10:50:36 <Gal3rielol> fryguybob thx!
10:50:38 <fizbin> I've seen people call (>>=) "bind", but that doesn't seem to be used as a definition.
10:50:47 <arkeet> why not (>>=)?
10:50:50 <fizbin> Oh, right. I suppose I could do that.
10:51:02 <fizbin> And actually, what I want is (=<<) anyway.
10:51:48 <fizbin> (background: I just found out that I don't want "fmap" here, because the function I thought returned "a" returns "Maybe a")
10:58:29 <hiptobecubic> If i have a list [2, 3, 4] and i want to produce a list like [[1, 3, 4], [0, 3, 4], [2, 1, 4], [2, 0, 4], [2, 3, 1], [2, 3, 0]], how does this fit into the list monad? Or does it
10:59:38 <mpickering> where is that 0 and 1 coming from?
10:59:59 <hiptobecubic> so given theList, i want to replace each element it with each output of (f e theList)
11:00:30 <zipper> mpickering: Waddup kitty cat.
11:00:44 <jellie> Sometimes I greet people in weird ways.
11:00:49 <hiptobecubic> mpickering, problem specific in this case, but nothing special about it. Assuming i have a function that produces candidate elements (in this example always [0, 1]) but sometimes maybe [] or [0] or who knows
11:02:19 <hiptobecubic> jellie, you forgot the comma.
11:02:24 * hackagebot hs-inspector 0.4.0.0 - Haskell source code analyzer  http://hackage.haskell.org/package/hs-inspector-0.4.0.0 (flbulgarelli)
11:03:32 <jellie> hiptobecubic: Really? Where should I have put a comma in that statement?
11:03:58 <hiptobecubic> "kitty cat" refers to mpickering there, no?
11:20:59 <Javran> why ghc has to be compiled twice. namely what's the difference between ghc-stage1 and ghc-stage2?
11:21:24 <monochrom> I forgot. but stage 2 is where ghci is built
11:21:27 <hiptobecubic> is stage 2 compiled using stage 1?
11:21:32 <monochrom> yes
11:21:34 <Javran> yes
11:21:39 <hiptobecubic> That would explain it then :)
11:21:52 <jarvi_> You probably can't compile all of the world with a stage1 compiler.
11:22:15 <hiptobecubic> stage 1 can only be compiled using features/optimizations that were available in the compiler used to build stage 1
11:22:15 <Javran> actually you need to have a ghc binary to bootstrap
11:22:31 <hiptobecubic> stage 2 can use things you just compiled into stage 1
11:22:53 <Javran> I feel compiling stage2 is faster somehow
11:23:52 <monochrom> there is some disk caching effect by the time you build stage 2
11:25:02 <Javran> oh I haven't taken hardware effects into account
11:27:25 * hackagebot xmonad-extras 0.12.1 - Third party extensions for xmonad with wacky dependencies  http://hackage.haskell.org/package/xmonad-extras-0.12.1 (AdamVogt)
11:29:13 <statusfailed> Can I use a sandbox for building a cabal package?
11:29:38 <statusfailed> what I mean is: what's the workflow for saying "build the package in the current directory, and use the sandbox to do it"
11:30:06 <merijn> statusfailed: "cabal sandbox init && cabal install blah" ?
11:30:37 <geekosaur> leave off the 'blah' in this case
11:31:33 <statusfailed> oh neat, i think that works
11:31:57 <statusfailed> except for one minor detail... I need a package that's not yet on hackage. Is that cabal sandbox add-source ?
11:32:04 <ProofTechnique> Yup
11:32:07 <statusfailed> awsum
11:32:10 <statusfailed> thanks everyone!
11:38:06 <merijn> geekosaur: No, that's only if you're inside a cabal package directory
11:38:27 <geekosaur> "build the package in the current directory"
11:38:46 <merijn> I interpreted that as "the package asked for" in "the current directory"
11:46:45 <lush> How can I map an IO Function over a Map that contains a handle as value?
11:47:04 <bennofs> lush: do you need the keys too, or just the values?
11:48:46 <ReinH> lush: what are the types you're working with?
11:49:16 <lush> bennofs: atm not essentially, the function should just be mapped over every value
11:49:44 <bennofs> lush: then you can use traverse :: (a -> IO b) -> Map k a -> Map k b from Data.Traversable
11:49:52 <lush> ReinH: data User = User { nick :: String, conn :: Handle };  type UserID = Int;  type Users = Map.Map UserID User
11:50:06 <bennofs> > traverse print $ M.fromList [(1,2), (2,4)]
11:50:07 <lambdabot>  <IO (Map Integer ())>
11:50:18 <bennofs> :t traverse print $ M.fromList [(1,2), (2,4)]
11:50:20 <lambdabot> (Num k, Ord k) => IO (M.Map k ())
11:50:34 <lush> ty I'll check that out
11:50:46 <xelxebar> I can't figure out how to do this right. I've got some functions defined in a Main module and want to define main such that calling the exe with args just calls a function. E.g. ./myExe f 1 2 3 should display the result of calling f 1 2 3.
11:51:56 <xelxebar> would the magic word be Applicative here?
11:52:15 <JagaJaga> Is there a way to show type of a function during runtime?
11:52:27 * hackagebot bower-json 0.1.0.0 - bower.json from Haskell  http://hackage.haskell.org/package/bower-json-0.1.0.0 (hdgarrood)
11:53:07 <bennofs> JagaJaga: you can do it if you type has a Typeable instance
11:53:07 <enthropy> > typeOf (undefined :: Int -> Char -> Double)
11:53:09 <lambdabot>  Int -> Char -> Double
11:53:22 <bennofs> > show (typeOf (undefined :: IO ()))
11:53:24 <lambdabot>  "IO ()"
11:53:46 <Javran> should be derived automatically in ghc 7.10
11:54:44 <JagaJaga> bennofs: thank you, my nix friend :)
11:55:21 <JagaJaga> Javran: thank you, but I do still use 7.8 :(
11:55:28 <ion> xelxebar: You could create a map like Map.fromList [("f", f), ("g", g)], find the function corresponding to the first argument and apply it to the following three arguments. Or you could use something like https://github.com/pcapriotti/optparse-applicative#commands
11:56:06 <enthropy> xelxebar: you could define myExe to do something like ghc -e ':load MyMain' -e "f $1 $2 ..."
11:56:48 <Javran> JagaJaga: then just do "deriving (Typeable)", won't get into much trouble :)
11:56:51 <browndawg> 5788164
11:57:02 <JagaJaga> Javran: yup :)
11:58:50 <ion> > typeOf (undefined :: Proxy 42)
11:58:51 <lambdabot>  Proxy Nat 42
12:01:05 <xelxebar> ion: I'm confusing myself on the part about "applying it to the folling arguments". As long as we can read the arguments to the proper types, how do we go about calling the function with the "rest of the args list"?
12:01:17 <xelxebar> enthropy: that's an evil hack. hehe.
12:02:10 <Javran> > typeOf (Proxy :: Proxy Sym)
12:02:11 <lambdabot>  Proxy (* -> *) Sym
12:03:00 <xelxebar> ion: I sort of want to turn [String] into t1 -> t2 -> ...
12:04:09 <Javran> > typeOf (undefined :: forall a . a -> a)
12:04:11 <lambdabot>      No instance for (Typeable a0) arising from a use of ‘typeOf’
12:04:11 <lambdabot>      In the expression: typeOf (undefined :: forall a. a -> a)
12:04:34 <Javran> > typeOf (id :: () -> ())
12:04:35 <lambdabot>  () -> ()
12:04:36 <ion> > case map readMaybe ["1","2","3"] :: [Maybe Integer] of [Just a, Just b, Just c] -> sum [a,b,c]
12:04:38 <lambdabot>  Not in scope: ‘readMaybe’
12:05:07 <xelxebar> ion: yeah, I just figured out that I'm being thickheaded. this is a map
12:05:18 <xelxebar> map? I mean fold
12:07:41 <enthropy> map won't work if the elements are different types
12:09:16 <shachaf> ]]: This is not a good place for that.
12:09:16 * EvanR invents stabbing through the internet
12:09:34 <]]> shachaf: sorry was playing a game with a friend in another channel
12:13:58 <dfeuer> Remind me: for quicksort/quickselect, how do you deal with the possibility that all the values are the same?
12:17:16 <xelxebar> ion: not sure why I thought it was a fold for a second.
12:19:17 <xelxebar> basically I'd like a way of supplying [1,2,3] to (\x y z -> x + y * z)
12:19:39 <SrPx> Hello, what is the state of art implementation of priority queues? I don't mean an actual library but the best technique around
12:19:44 <xelxebar> my functions are actually more complicated, but I think this is a relevant simplification
12:20:42 <mauke> > (\f [x,y,z] -> f x y z) (\x y z -> x + y * z) [1,2,3]
12:20:43 <lambdabot>  7
12:21:03 <lyxia> dfeuer: Is it ever a problem?
12:22:24 <dfeuer> lyxia, well, I think I need to take it into account to avoid infinite loops, don't I?
12:22:27 <Javran> out of curious I guess the point-free version this won't be readable
12:22:27 <EvanR> if they are all the same, then you cant do anything wrong!
12:22:33 <EvanR> except infinite loop
12:22:35 <Javran> @pl (\f [x,y,z] -> f x y z)
12:22:35 <lambdabot> (line 1, column 5):
12:22:35 <lambdabot> unexpected "["
12:22:35 <lambdabot> expecting operator, pattern or "->"
12:22:38 <trolling> SrPx: heaps
12:22:56 <dfeuer> EvanR, I would prefer to avoid infinite loops :-P
12:23:01 <Javran> @pl (\f (x:y:z:[]) -> f x y z)
12:23:01 <lambdabot> (line 1, column 12):
12:23:01 <lambdabot> unexpected "["
12:23:01 <lambdabot> expecting "()", natural, identifier, "_" or "("
12:23:13 <Javran> @pl (\f (x:y:z:_) -> f x y z)
12:23:14 <lambdabot> (`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . (((.) . (const .)) .)) .)
12:23:21 <Javran> here we go
12:23:25 * trolling vomits
12:23:30 <dfeuer> I suppose one option is to use a three-way split, but that seems a bit ugly, and requires a custom partitioning function.
12:23:31 <lyxia> dfeuer: If at every step you make sure to not include the pivot in the recursive calls it won't loop infinitely.
12:24:36 <dfeuer> lyxia, I think I want to make this a stable sort, which I think precludes that approach.
12:25:24 <enthropy> dfeuer: maybe you should have a check for "already sorted"?
12:25:45 <dfeuer> enthropy, I think the 3-way partition is going to be better than *that*.
12:27:22 <Forgetaboutit> Is there something I need to do to make GHCi print my `trace' calls?
12:28:18 <Javran> Forgetaboutit: I don't think so
12:28:19 <mauke> no
12:28:22 <dfeuer> Forgetaboutit, you're calling trace in your module? GHCi *should* just do it.
12:28:35 <hexagoxel> evaluate the expression containing the trace
12:28:58 <Forgetaboutit> I'm calling trace in a huge `let - in', maybe that's the issue
12:28:58 <dfeuer> Ah yes, there is that.
12:29:09 <dfeuer> You need to make sure that expression is actually forced.
12:29:12 <Javran> but if you are using something like Control.Monad.State, you can switch to the strict version or otherwise the output would be a little confusing
12:29:22 <mauke> i.e. you need to make sure trace is actually called :-)
12:29:33 <Forgetaboutit> I see :)
12:29:44 <Forgetaboutit> can I force it using `seq' or so?
12:29:50 <dfeuer> Maybe.
12:29:56 <dfeuer> It depends what you're actually doing.
12:30:13 <dfeuer> If you put it on lpaste, we might have a better chance of guessing.
12:30:38 <Forgetaboutit> I'm not sure you want to see the mess that is manually converted Java code in Haskell :D
12:30:51 <dfeuer> Well ....
12:31:00 <bitemyapp> dfeuer: in case I forgot to say so, bravo on making a total <*> for Sequence btw.
12:31:11 <dfeuer> Thanks, bitemyapp!
12:31:27 <bitemyapp> you said it was a bit faster than the previous version as well right?
12:31:28 <monochrom> this is strange. I am not sure what your goal is. is your goal to make sure some trace messages happen? is your goal to use trace to learn what won't happen? they are incompatible goals. pick one.
12:31:48 <bitemyapp> dfeuer: does error ever prevent GHC optimizations that might be pertinent or was it a side effect of the changed design?
12:31:49 <Forgetaboutit> monochrom: I want to trace the intermediate results
12:32:28 <monochrom> ok, evaluate the final answer you want, then you will also see the intermediate results reported.
12:32:46 <Forgetaboutit> http://lpaste.net/1235533551277965312
12:32:48 <Gurkenglas> Forgetaboutit, you could try putting traces on the encapsulating expressions, to see at which point some expression is not forced
12:32:51 <dfeuer> bitemyapp, I'm not quite sure. There are also, I think, some things that get manipulated less.
12:32:52 <Forgetaboutit> Please don't judge me
12:32:54 <monochrom> if the final answer is reported but not some intermediate result, then you *learn* that the intermediate was never used
12:33:16 <dfeuer> bitemyapp, the performance change from that commit was pretty small.
12:33:23 <Gurkenglas> "_ = trace" <- yea no that's not gonna be forced
12:33:42 <Forgetaboutit> Gurkenglas: which is why I was asking about how to force it
12:34:01 <Forgetaboutit> I heard about `seq'/`deepseq', but I don't know my way around that well
12:34:44 <monochrom> ok, so your goal is to ensure that some trace messages are printed, even it they are attached to a subexpression not needed.
12:34:48 <Gurkenglas> Or am I wrong? Does "_ = (...)" ever do anything? Because if yes, I might be wrong, and if no, it's surprising that that syntactic suger is even in there...
12:35:10 <bitemyapp> dfeuer: that's what I thought I remembered. Makes sense, thanks.
12:35:22 <Forgetaboutit> monochrom: That's correct
12:35:23 <EvanR> Gurkenglas: the compiler might even omit the definite entirely
12:35:27 <EvanR> definition
12:35:58 <EvanR> assuming thats in a let
12:36:02 <EvanR> or where
12:36:24 <Gurkenglas> It's a line in a do block
12:36:36 <EvanR> thats not valid in a do block
12:36:43 <EvanR> youd need a let
12:36:52 <Gurkenglas> wait it isn't im stupid, it's a let <.<
12:38:03 <hexagoxel> Forgetaboutit: there is `traceShowId`. you could write `(alphabet'', seps'') = traceShowId $ ....`
12:38:36 <hexagoxel> Forgetaboutit: no promise that this will already be sufficient, but better than the traces that get not forced in any way :)
12:38:59 <Forgetaboutit> hexagoxel: Awesome, that looks better :)
12:39:17 <Gurkenglas> Would x = trace (show x) (...) work?
12:43:51 <lush> http://susepaste.org/61705590 is this supposed to work as a really simple client that justs receives messages from a handle and sends messages to it?
12:45:06 <geekosaur> I see you using hGetContents, so no
12:45:40 <lush> geekosaur: what should I use instead?
12:46:32 <geekosaur> hGetContents should work exactly once, "half-closing" the handle and giving you a "magic" IO String that will be populated on demand from the original handle. You can't do anything else with the handle afyter using hGetContents on it
12:46:43 <geekosaur> probably hGetLine
12:47:01 <lush> aaah damn forgot about that x.X
12:47:31 <geekosaur> hm, als you are using hPutStr, but you turn on LineBuffering; perhaps you wanted hPutStrLn?>
12:52:10 <lush> geekosaur: still doesn't work... http://susepaste.org/67271921   http://susepaste.org/63870970
12:52:25 <lush> geekosaur: I was too haskell-inactive the last few months I guess ^^
12:57:30 <geekosaur> if you're expecting that first part to work with anything but NoBuffering on both sides (and can't use hGetLine to receive it, because it's not a full line), it won't
12:58:33 <lush> geekosaur: what can I use instead of hGetLine?
12:58:40 <geekosaur> meanwhile someone seems to have replaced my wnetwork with an ancient dialup, taking forever for anything to load :(
12:58:42 <lush> and aren't both sides NoBuffering now?
12:58:51 <lush> xD
13:00:48 <geekosaur> I may be confused at this point. what's on the other side of (that is, connecting to) the socket?
13:02:10 <lush> Chat.hs is a simple server that lets connect clients to chat, and SimpleChat is supposed to connect to that server? (Or better: to the port that Chat.hs listens on)
13:02:13 <lush> Or what do you mean?
13:02:15 <monochrom> someone replaced your internet connection with NoBuffering
13:02:42 <lush> *SimpleClient
13:02:43 <hodapp> does anyone know of something that is like takeDirectory, but also gives me the part that takeDirectory left behind?
13:02:48 <geekosaur> oh, apparentluy I managed to load the one paste twice instead of both pastes, sorry
13:02:59 <lush> haha geekosaur that's a nice one :)
13:03:06 <hodapp> I have splitFilename, but that doesn't really help with directories
13:03:19 <hodapp> and I'd like to avoid manually popping path separators off the end of a directory
13:03:55 <monochrom> I don't know what takeDirectory does to begin with
13:03:59 <dfeuer> bitemyapp, here's a question to think about: is it possible to augment finger trees with forcing schedules to make their amortized bounds into worst-case bounds?
13:04:27 <hodapp> > takeDirectory "foo/bar/baz"
13:04:28 <lambdabot>  Not in scope: ‘takeDirectory’
13:04:30 <geekosaur> in any case, since the first part wants to work without using a full line, I think either you make it take a full line or you use hGetChar and recognize the end of the prompt somehow
13:04:58 <geekosaur> this is why most things use some kind of protocol, so they can reliably recognize end-of-packet (in this case, that they should display the "what nick?" prompt)
13:05:12 <hodapp> > System.FilePath.Posix.takeDirectory "foo/bar/baz"
13:05:13 <lambdabot>      Not in scope: ‘System.FilePath.Posix.takeDirectory’
13:05:38 <bitemyapp> dfeuer: if your forcing emulated a default strict language, it would seem so, but why would you want to?
13:05:46 <bitemyapp> just because?
13:05:48 <geekosaur> you might, if only that first prompt needs to be a partial line, send it over the socket with the newline (hPutLine) and have the client recognize that for the first line only, don't output the newline
13:06:03 <geekosaur> otherwise, consider using a chat protocol instead of trying to handle it "raw"
13:07:53 <dfeuer> bitemyapp, you can't maintain good bounds if you just emulate a strict language. You'd need to be careful to force things at just the right time. Why you'd want to in some cases: I think you could get better locality in some situations.
13:09:03 <dfeuer> For example, if you perform a bunch of conses in a row, you actually get a chain of thunks built up on the second level of the tree.
13:09:39 <lush> geekosaur: what's the problem with outputting that first prompt? The client should only give it to stdout?
13:09:59 <geekosaur> the problem is you hGetLine it but it doesn't end with a newline
13:09:59 <dfeuer> So then if you do some unsnocs, kaboom.
13:10:02 <geekosaur> so it's not a line
13:10:23 <geekosaur> and if you end it with a newline, then you need to either handle it specially or expect that it will be displayed on a line by itself
13:10:53 * dfeuer wonders if Chain of Thunks would be a good name for a band.
13:11:13 <geekosaur> if you planb to do any other prompting later, you will have the same general issue only worse (this being the first thing output, you can easily special case it): how to deal with something that needs special handling of some kind
13:12:01 <geekosaur> likewise, if you plan to output status changes, you have no good way to make them distinct such that a client could choose not to display them (consider, for example, hiding jpoins/parts in IRC)
13:13:03 <geekosaur> this is why most chat protocols use actual protocols and not just raw streams that act like a telnet connection (and even telnet has a protocol, it's just handled via special escape sequences)
13:13:11 <dfeuer> Bleh. This strict state thing ain't givin' me enough love. I'm going to need to steal some laziness.
13:13:12 <lush> geekosaur: mhm I tried to avoid a real protocol as it should be a really simple chat service as a first attempt.. although considering a protocol could ease it, so I'll consider that.
13:13:38 <geekosaur> you specifically want some way to recognize that you have reached the end of the prompt packet
13:14:04 <geekosaur> since it's not actually a packet protocol (TCP is a stream protocol), you can't see that
13:14:09 <dfeuer> lush, the people who design protocols sometimes get some parts right!
13:14:31 <geekosaur> so you have to either recognize the end of the prompt, or time out (and hope there are no networtk glitches)
13:14:41 <geekosaur> or implement your own packetizing protocol of some kind
13:15:03 <lush> dfeuer: That project is just for learning purposes, I know that protocols are very useful
13:15:07 * dfeuer guesses, with little justification, that IRC is probably not terribly hard to implement the basics of.
13:15:53 <dfeuer> lush, what I mean is that the people who designed such standard protocols thought through a lot of these issues that you are grappling with, and you can avoid that effort by using theirs.
13:16:00 <geekosaur> the absolute basics are fairly easy. not many servers work well with an absolutely basic client these days, though
13:16:24 <dfeuer> geekosaur, sure, but lush could implement an absolute basic server to go with it :-)
13:16:26 <lush> geekosaur: about that hGetLine <-> newline thing: so using hPutStrLn to give the server the nickname to use should work (just as a workaround for testing purposes)
13:16:32 <geekosaur> bots have to respond to a bunch of informational packets...
13:17:00 <lush> dfeuer: I also could try it myself and see what difficulties appear and then get a better understanding of why protocols are so useful :P :)(
13:17:12 <geekosaur> you need hPutStrLn on line 13 of the client and on line 32 of the server
13:17:19 <dfeuer> lush, it all depends on what you want to learn today :-P
13:17:36 <dfeuer> That is definitely a valid approach as well.
13:18:23 * dfeuer generally prefers to learn as little as possible at one time.
13:18:33 <dfeuer> So as not to get overwhelmed.
13:18:40 <geekosaur> you may also see some correct for what you have written, but possibly surprising behavior
13:19:00 <lush> dfeuer: not today, got to go to school tomorrow relatively early :)
13:19:05 <lush> but I'll try it anyways :P
13:19:44 <dfeuer> Of course, it's also possible that the approach you come up with will be better than what anyone has done before, but that's a relatively uncommon occurrence.
13:20:12 <dfeuer> Especially in this realm, which is so boringly mature.
13:21:11 <lush> dfeuer: I don't want to revolutionize IRC communication, I just want to get a better understanding of networking and in this case I may want to use a protocol to understand what benefits it brings :P
13:21:33 <dfeuer> Have fun!
13:21:58 <lush> ty ))
13:22:12 <lush> geekosaur: mhm still seems not working at all ^^
13:22:50 <lush> geekosaur: If I connect about 10times I'll get at least that "Enter nickname" at my client (then he finishes executing without asking me anything...) 
13:23:02 <lush> but I guess that's nothing to fix today :)
13:23:14 <lush> Ty for your help geekosaur and dfeuer, cya :)
13:24:43 <geekosaur> lush: you use putLine to output, there is no newline on the string returned by hGetLine, it's sitting in the buffer
13:25:08 <geekosaur> because stdout in the client is LineBuffering
13:26:28 <lush> geekosaur: mhm I'll continue tomorrow sry ^^
13:26:32 <lush> Ty anyways :)
13:26:35 <lush> bb
13:27:31 <faux___> python has the convenient r"" notation for regexes. does haskell have a parallel?
13:27:49 <geekosaur> no
13:28:00 <faux___> alright thanks
13:28:20 <geekosaur> regexes are not looked on kindly by the haskell community, else someone would have come up with e.g. a quasiquoter for them
13:28:51 <Clint> to do what exactly
13:29:07 <tdammers> more like, haskell has better stuff on offer for almost all tasks
13:29:33 <tdammers> regular expressions solve a subset of the problems we can solve with full-blown parser libraries, and that subset is limited and somewhat ill-defined
13:29:42 <meoblast001> raichoo: :o i didn't know you idle here too. hi
13:30:07 <raichoo> meoblast001: sure I do, why would I not? :D Do we know each other?
13:30:43 <meoblast001> not really. i saw a presentation from you once. also i stalk you on twitter
13:30:51 <benzrf> tdammers: regexes are convenient syntax though =)
13:30:54 <meoblast001> your city also doesn't exist
13:30:57 <benzrf> they are nicely concise
13:31:13 <raichoo> meoblast001: Ah ok, nice to meet you :)
13:31:32 <meoblast001> nice to meet you too :3
13:31:33 <quchen> They are short, I don't think they're concise.
13:32:28 <tdammers> I like to think of them as "convenient" because I have spent so much time learning them...
13:32:34 <tdammers> .oO( something about sunk cost )
13:35:16 <enthropy> @hackage regex-applicative
13:35:16 <lambdabot> http://hackage.haskell.org/package/regex-applicative
13:36:49 <osa1> having a "equality modulo alpha-renaming" function for haskell-src-exts syntax would be great, does anyone know if we have a package that provides this?
13:37:31 * hackagebot bower-json 0.2.0.0 - bower.json from Haskell  http://hackage.haskell.org/package/bower-json-0.2.0.0 (hdgarrood)
13:40:25 <jlamothe> Z
13:40:53 <absence> this is odd. when i import bimap from Control.Lens, my program runs faster than when i import it from Data.Bifunctor, but lens just re-exports the bifunctor one
13:40:57 <absence> why would that happen?
13:41:56 <aruro> folks, is there any studies to implement functions domains of validity in haskell ? For example head :: [a]-> a domain of validity would be - not [].
13:42:07 <shachaf> lens is just that optimized.
13:42:07 <moghedrin> Welkin: That.Talon password AUTHCHANGE johnny
13:42:56 <dfeuer> absence, I wonder if some rewrite rules are coming along for the ride.
13:43:04 <shachaf> If you're sure it's faster, I would look at the Core and see what's different.
13:44:06 * geekosaur was just looking around for rewrite rules but has no idea where this stuff is in there...
13:44:07 <moghedrin> Whoops.
13:44:26 * moghedrin was leaning on his keyboard, apparently
13:44:56 <HeladoDeBrownie> aruro, what do you mean by "implement" here?
13:45:40 <aruro> i mean that i would like it to specify it in the functions type declaration field
13:45:51 <aruro> to spare me from handwork on thecking parameters ranges
13:46:15 <aruro> type declaration+ domain declaration
13:46:30 <aruro> so head will not have famous problem because domain is not []
13:46:34 <HeladoDeBrownie> aruro, i think that's generally not feasible without dependent types; however, head could easily be rewritten to have type [a] -> Maybe a to avoid that.
13:46:46 <aruro> indeed
13:46:55 <chpatrick> aruro: what about a function that returns something with an unpredictable domain?
13:46:59 <aruro> but for example often we want Int to be just positive
13:47:07 <absence> shachaf: as sure as i can be, it always runs in about 160 s with lens and 190 s with bifunctor
13:47:08 <chpatrick> sorry not domain, range I guess
13:47:20 <absence> shachaf: i'll check out the core some day when i'm feeling more awake
13:47:22 <chpatrick> like something that might return an empty list depending on some IO
13:47:31 * hackagebot passwords 0.1.0.6 - Password generation/validation library  http://hackage.haskell.org/package/passwords-0.1.0.6 (mkulkin)
13:47:46 <aruro> i think it will look nicer than infunction hidden checks on parameters ranges
13:48:04 <aruro> plus i see from start that some function rejects certain domains-ranges
13:48:14 <chpatrick> there are nicer ways to do it though
13:48:19 <aruro> which ones?
13:48:19 <chpatrick> I mean the main culprit is list right?
13:48:24 <arkeet> aruro: have a read about liquid types
13:48:30 <aruro> not just list
13:48:40 <aruro> Integer has lots of problematics in this direction
13:48:45 <arkeet> and liquid haskell
13:48:49 <aruro> any number type
13:48:50 <pavonia> aruro: You could also invent new type reflecting the actual domain, like head :: NonEmptyList a -> a
13:48:54 <aruro> arkeet, they do that?
13:48:55 <chpatrick> I think liquid haskell is the way to go too
13:48:59 <chpatrick> https://hackage.haskell.org/package/semigroups-0.8.3/docs/Data-List-NonEmpty.html
13:49:04 <chpatrick> that's what I was going to say
13:49:10 <shachaf> absence: You can paste the program if it's small enough.
13:49:19 <arkeet> chpatrick: NonEmpty kind of sucks.
13:49:28 <chpatrick> so does annotating everything with its domain though
13:49:32 <arkeet> e.g. its Foldable instance is really slow.
13:49:43 <aruro> so you say liquid haskell takes problem of domains seriously and allows some real abstractions?
13:49:52 <quchen> arkeet: How so?
13:50:11 <aruro> nonemptylist is not different than infunction checks
13:50:23 <aruro> though maybe more readable for third party
13:50:28 <EvanR> what is a real abstraction
13:50:28 <chpatrick> not with NonEmpty
13:50:34 <chpatrick> it's impossible to have an empty list
13:50:39 <HeladoDeBrownie>  NonEmpty is a type not even containing the problematic case
13:50:41 <aruro> real means good
13:50:43 <aruro> :)
13:50:56 <quchen> arkeet: The Foldable instance looks pretty normal to me
13:51:04 <chpatrick> arkeet: I don't see it either
13:51:23 <aruro> arkeet, ty for the links
13:51:27 <EvanR> domains might be or might not be more natural than arbitrary properties
13:51:40 <arkeet> sorry.
13:51:41 <EvanR> both seem hard to prove things about
13:51:43 <arkeet> the Foldable1 instance.
13:52:12 <quchen> I don't see a Foldable1 instance (it's commented out)
13:52:32 <quchen> https://hackage.haskell.org/package/semigroups-0.8.3/docs/src/Data-List-NonEmpty.html#line-179
13:52:36 <shachaf> It's in https://hackage.haskell.org/package/semigroupoids-4.3/docs/src/Data-Semigroup-Foldable.html
13:52:39 <arkeet> the commentedd out thing is the instance, it's just defined in ^
13:52:46 <aruro> i think now i read something about parameter ranges in haskell before
13:52:47 <EvanR> smart constructors might be easier
13:52:51 <aruro> so problem does not seem new
13:53:02 <shachaf> Anyway the issue with NonEmpty is efficiency.
13:53:17 <EvanR> domain or range? ;)
13:53:23 <aruro> :)
13:53:23 <chpatrick> arkeet: I still don't see what's wrong with it
13:53:48 <aruro> mmm, domain ? :) what is difference btw?
13:53:50 <Forgetaboutit> EvanR: For clarifiation: By smart constructor you mean like `a -> b -> ... -> Maybe SomeNewtype', right?
13:54:08 <Forgetaboutit> *clarification
13:54:16 <quchen> arkeet: Alright, the instance is there. Why is it inefficient?
13:54:38 <arkeet> chpatrick: at each step (in the nonempty tail case), it deconstructs the tail list, and puts it in a NonEmpty.
13:54:40 <EvanR> Forgetaboutit: yeah at some point you have a runtime check, and this only seems stupid if theres no way it could be Nothing, in which case you might be able to use dependent types
13:54:48 <arkeet> so it has to allocate a new NonEmpty each time.l
13:54:59 <shachaf> The issue is that e.g. "tail" for NonEmpty needs to allocate.
13:55:06 <dfeuer> Wow. It passed the type checker. I wonder if it's right.
13:55:24 <chpatrick> oh yeah
13:55:27 <chpatrick> that's weird
13:55:27 <arkeet> aruro: http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/about/
13:55:42 <EvanR> a non empty list can also be a regular list with a proof that its not empty
13:55:43 <chpatrick> why doesn't it just foldMap1 the list when it's not empty?
13:55:48 <chpatrick> oh because there's no instanec
13:55:56 <arkeet> [] isn't Foldable1
13:56:05 <quchen> Oh, I looked at the wrong instance. The Foldable1 NonEmpty looks strange indeed.
13:56:05 <chpatrick> could just make a non-total helper function
13:56:31 <chpatrick> as in, regular foldr1
13:56:32 <chpatrick> right?
13:56:39 <arkeet> perhaps
13:57:35 <chpatrick> so yeah, why doesn't he just list foldr1 the list when it's not empty?
13:58:10 <chpatrick> it's ekmett so I assume there's a good reason
13:59:16 <aruro> arkeet, ty, liquid types explore exaclty what we talked about
13:59:56 <aruro> in the first page of their paper they argue they want to check types for values being in certain range
14:00:07 <athan> aruro: Decidable, commutative boolean proofs of "refinement"? :D
14:00:12 <aruro> to ensure silly things like division by 0 etc.
14:00:33 <aruro> ensure absence :)
14:00:41 <EvanR> non empty and non zero are common things that you can ensure with dependent types
14:00:46 <athan> aruro: I'm about to get knee-deep in it
14:00:53 <aruro> athan, really? :)
14:00:59 <aruro> i would be glad to talk about it :)
14:01:00 <athan> aruro: Yep :)
14:01:04 <aruro> i need some time to research it
14:01:06 <aruro> :)
14:01:07 <EvanR> whats an example where you want a more complex numeric range
14:01:08 <athan> Not yet not yet! Give me a week :P
14:01:16 <aruro> :D
14:01:19 <aruro> you got it! :)
14:01:58 <aruro> EvanR, almost anything mathematical
14:02:21 <EvanR> eh...
14:02:30 <aruro> also most list operations
14:02:43 <aruro> like drop (-1)
14:02:45 <EvanR> practically speaking, im actually curious when you want what numeric ranges
14:02:58 <EvanR> aruro: well a length indexed list type is a dependent type
14:04:06 <athan> EvanR: It's not just numerical stuff, anything with equality / ord can be constraint (pretty sure)
14:04:13 <athan> Eq / Ord instances, I mean
14:04:20 <athan> as _booleans_, not heyting stuff
14:04:23 <EvanR> but for what purpose
14:04:40 <athan> EvanR: Type safety on-the-cheap :)
14:04:49 <EvanR> nevermind
14:04:56 <athan> for libs I'm pretty sure they would also need to be infected with the liquid :\
14:05:38 <aruro> EvanR, dependent types are going certainly in the similar direction
14:05:44 <aruro> im not sure what is better :)
14:06:05 <EvanR> its easy to sweep what you would use dependent types to ensure, i.e. "anything"
14:06:27 <aruro> but haskell does not have dependet types does it?
14:06:34 <aruro> nt*
14:06:39 <athan> Well, with dependent types you run into the definitional-recursion problem pretty quickly
14:06:39 <EvanR> no but it has DT-ish things
14:06:49 <EvanR> the what?
14:06:50 <aruro> like ?
14:06:52 <athan> ie `x + 0 == x` vs `0 + x == x`
14:06:54 <HeladoDeBrownie> aruro, for a haskell-like language with dt, try idris
14:07:04 <athan> With liquid types, it ain't don't matter ya digs?
14:07:14 <aruro> HeladoDeBrownie: ty
14:07:32 * hackagebot persistent-refs 0.4 - Haskell references backed by an IntMap for persistence and reversibility.  http://hackage.haskell.org/package/persistent-refs-0.4 (AdamFoltzer)
14:07:38 <athan> aruro: Also very performant, I've heard!
14:07:59 <EvanR> performant :\
14:08:16 <athan> EvanR: (cough static type erasure cough)
14:08:55 <EvanR> i was just thinking about type erasure and how somehow this equates to "performant"
14:09:16 <athan> EvanR: mi... minimal la.. lambdas? :(
14:09:19 <athan> you got me
14:09:47 <EvanR> which seems like a non sequitur but i never understand unreasonable jargon
14:10:46 <aruro> ty guys, i go think on my stuff :D
14:15:55 <dfeuer> So what do refinement types get you that dependent types don't, and vicec versa?
14:16:49 <Eiam> Some enlightenment on what the partial applications of this functor definition would look like on the RHS (line 4, https://gist.github.com/anonymous/1e5e07ccb5d8c928b064 ) 
14:17:02 <merijn> dfeuer: I think you can build anything that refinement types can inside dependent types
14:17:23 <dfeuer> I believe edwardk uses the NonEmpty def he does to get good conversions to/from lists. You can also do a good job using GADT-based size-indexed lists and unsafeCoerce,
14:17:29 <dfeuer> but that doesn't work in GHCi for some reason.
14:17:42 <arkeet> :t fmap -- Eiam 
14:17:42 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:17:49 <dfeuer> And I guess that's a little different.
14:17:51 <merijn> Eiam: As an exercise can you rewrite the type of fmap with 'f' replaced by your Functor type?
14:17:53 <arkeet> now (alpha-rename and) put f = Two a
14:18:04 <merijn> ^^^ what arkeet said
14:18:07 <arkeet> fmap :: (b -> c) -> Two a b -> Two a c
14:18:15 <dfeuer> Er ... but you can use a GADT to determine nonemptiness, without size indexing,
14:18:27 <dfeuer> and use unsafeCoerce. But that coercion doesn'nt work in GHCi.
14:18:29 <dfeuer> Dunno why.
14:18:45 <dfeuer> merijn, thanks.
14:18:56 <HeladoDeBrownie> Eiam, to clarify, they're telling what the type should be, not what goes on the right side of that equation
14:19:10 <dfeuer> merijn, do you know why unsafeCoerce acts funny in GHCi, by any chance?
14:19:12 <arkeet> right. but writing down the type should help you figure out what to put there.
14:19:16 <merijn> Which should become self-evident after staring at the type :)
14:19:16 <Eiam> HeladoDeBrownie: oh, I'm well aware they are not telling me the rhs =)
14:19:16 <HeladoDeBrownie> Eiam, although the type is important to know
14:19:33 <HeladoDeBrownie> Eiam, what have you tried? what do you think it ought to be?
14:19:35 <merijn> HeladoDeBrownie: We're trying to be all educational and shit by avoiding complete spoilers :p
14:19:45 <HeladoDeBrownie> merijn, i understand, so am i
14:20:10 <Eiam> oh, a friend pointed me at the problem and he was stuck too, so I figured I'd just try and get the answer
14:20:12 <Eiam> but no, arkeet stalks
14:20:22 <ElderFain> stalker.
14:20:38 <arkeet> (´・ω・｀)
14:22:24 <ElderFain> HeladoDeBrownie: devolved into literally trying random things to see what compiles. =) 
14:22:33 * hackagebot tinytemplate 0.1.0.0 - A tiny text templating library  http://hackage.haskell.org/package/tinytemplate-0.1.0.0 (PhilFreeman)
14:23:04 <Eiam> arkeet: = (Dos a (f x)) }
14:23:42 <arkeet> Eiam: does it compile? :)
14:24:07 <dfeuer> Has Google been really screwy today, or is it just me?
14:24:56 <xelxebar> :t (take 5) . zip
14:24:57 <lambdabot>     Couldn't match type ‘[b0] -> [(a1, b0)]’ with ‘[a]’
14:24:57 <lambdabot>     Expected type: [a1] -> [a]
14:24:57 <lambdabot>       Actual type: [a1] -> [b0] -> [(a1, b0)]
14:24:59 <HeladoDeBrownie> ElderFain, are you the other person mentioned?
14:25:12 <ElderFain> mm hmm
14:25:23 <HeladoDeBrownie> well there's your problem, you've got to be guided by the types :)
14:25:39 <HeladoDeBrownie> do you know what the type of Dos is? (hint: it's a function)
14:25:44 <ElderFain> you say that like it means something 
14:25:52 <ElderFain> if it meant something to me, It would have given me the answer already ;)
14:25:53 <HeladoDeBrownie> you look at the types and see what unifies
14:26:15 <HeladoDeBrownie> fmap :: (a -> b) -> Two c a -> Two c b
14:26:27 <HeladoDeBrownie> you start off with values of type a -> b and Two c a, and need one of type Two cb
14:26:29 <HeladoDeBrownie> Two c b*
14:26:47 <dfeuer> Is there a way to hook MonadRandom up to tf-random stuff?
14:27:01 <dfeuer> Actually, that's the wrong question, isn't it?
14:27:04 <dfeuer> Hmmm.
14:27:29 <HeladoDeBrownie> and as it happens you have one way to turn Two c a into values of type c and a, which looks promising
14:28:21 <infandum> I need help with memory usage. Say I have a giant file, 400 gigabytes for instance. Each line is a string of arbitrary length. I need to get the number of each type of character at each position. Therefore, I need to get a Map of: Map Position (Map Char Size), where Position is an Int and Size is an Int. The naive method is: http://pastebin.com/C4fLCnNh, however this takes up a ton of memory for some reason,
14:28:23 <infandum> so I'm assuming it's not as lazy as I thought. How can I do this in a memory efficient manner? It seems to read in the entire file before outputting anything even though it "theoretically" can by counting each type as it goes per position as it streams in the file.
14:28:54 <Hijiri> where are you getting the statistic "a ton of memory"?
14:29:45 <Hijiri> also, what is a position in this context
14:29:48 <Hijiri> column?
14:30:09 <arkeet> infandum: does it help if you use a Data.Map.Strict?
14:30:28 <xelxebar> :t ((.).(.)) (take 5) zip
14:30:29 <lambdabot> [a] -> [b] -> [(a, b)]
14:31:00 <xelxebar> I have no idea why I tried that but it works...
14:31:29 <arkeet> :t (take 5 .) . zip
14:31:30 <lambdabot> [a] -> [b] -> [(a, b)]
14:31:45 <arkeet> :t (fmap.fmap) (take 5) zip
14:31:45 <lambdabot> [a] -> [b] -> [(a, b)]
14:32:18 <infandum> arkeet: I'll try it out
14:32:50 <xelxebar> arkeet: well, (.) *is* fmap under the hom functor
14:32:55 <arkeet> sure.
14:33:02 <luzie> :t (fmap `fmap` fmap) (take 5) zip
14:33:03 <lambdabot> [a] -> [b] -> [(a, b)]
14:33:07 <xelxebar> that first one you give is way more readable
14:33:21 <arkeet> the fmap.fmap one is conceptually nicer imo
14:33:24 <infandum> arkeet: it...does? Why would it!? Doesn't strictness put more IN memory!?
14:33:24 <arkeet> either works.
14:33:43 <arkeet> infandum: lazy map will just build up thunks for the values.
14:34:13 <arkeet> it won't actually evaluate any sums when you combine maps together.
14:34:16 <infandum> arkeet: But I never got any stack size overflows...
14:34:22 <arkeet> no, it builds them up in the heap.
14:35:31 <Hijiri> stack overflows usually happen when you try to actually look at the very thunked value
14:36:17 <arkeet> if it's some deeply nested expression yes.
14:36:41 <arkeet> yours probably didn't overflow because each value in the map wasn't big enough to blow up the stack.
14:37:01 <infandum> Even if it's 1 thunk per value it would have such a large footprint?
14:37:02 <arkeet> see what happens if you have a line with 1000000 of the same character.
14:37:23 <arkeet> 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1 takes up much more mempry than 15.
14:37:35 <infandum> I see...
14:38:14 <RyanGlScott> Is there a reason that mconcat didn't have its type signature generalized to (Foldable t, Monoid a) => t a -> a as a part of the FTP?
14:38:36 <EvanR> mconcat is part of the Monoid class
14:38:43 <ion> That would have broken more existing code.
14:38:49 <arkeet> because that would break anyone who wrote a definition for it.
14:38:49 <infandum> Unfortunately that didn't solve all of my memory issues but it certaintly helped!
14:38:52 <arkeet> in their Monoid instance.
14:38:52 <infandum> Thank you!
14:39:12 <infandum> Wow! From max 12% memory down to max 4%!
14:39:14 <EvanR> you can do the equivalent of that mconcat by doing foldMap
14:39:20 <arkeet> or just fold
14:39:21 <arkeet> :t fold
14:39:22 <lambdabot> (Foldable t, Monoid m) => t m -> m
14:39:24 <EvanR> fold
14:44:56 <xpilot> hello; type families question here
14:45:22 <xpilot> is there some way of using @ patterns in type families?
14:45:48 <monochrom> that is a strange question. wrong level, wrong impedence, etc.
14:46:37 <monochrom> in each instance implementation, you are of course free to use any construct you normally use for normal functions, including pattern matching and guards and lambdas and whatnot
14:47:09 * enthropy thinks the idea is something like how to avoid writing T X Y Z twice in:  type instance TF (T X Y Z) = T2 (T X Y Z)
14:47:38 <monochrom> there is no shorthand for that.
14:49:00 <xpilot> monochrom: thanks, that answers my question
14:54:02 <rasen_> Hey, guys! Can someone run this? BL.putStrLn $ encode $ (decode $ BL.pack "[\"привет\"]" :: Maybe Value)
14:54:46 <rasen_> The problem is, I don't get back ["привет"] but ["?@825B"]
14:55:10 <mniip> where BL is?
14:55:19 <rasen_> Data.ByteString.Lazy.Char8
14:55:30 <ReinH> rasen_: Char8 doesn't handle multi-byte characters
14:55:44 <ReinH> So you shouldn't be using that module.
14:55:53 <monochrom> which decode is decode?
14:55:54 <koala_man> can't you pack them as utf-8? 
14:56:27 <monochrom> also, BL.pack "[\"привет\"]"  is documented to do funny things. it truncates.
14:57:06 <rasen_> oh.. I should pack it as Word8 then?
14:57:10 <jedai42> rasen_: to handle text, you shouldn't be using ByteString... you should be using Text
14:57:27 <monochrom> let me tell you, step by step, what really really happens.
14:57:29 <rasen_> sorry... decode is from Data.Aeson
14:57:53 <rasen_> It accepts only ByteString
14:58:03 <monochrom> allow me to simply use "привет", ok?
14:58:08 <rasen_> yep
14:58:57 <monochrom> firstly, "привет" is ['\1087', '\1088', '\1080', '\1074', '\1077', '\1090']
14:59:31 <monochrom> when you give that to Char8's pack, the first thing it does is truncate each item. truncate means bitwise-and with 0xff
14:59:52 <arkeet> which gives you [0x87, 0x88, 0x80, 0x74, 0x77, 0x90]
14:59:53 <monochrom> this is because Char8 assumes iso-8859-1.
15:00:08 <rasen_> I see
15:00:08 <monochrom> it goes downhill from that point. I think you see the idea.
15:01:04 <arkeet> so if you want to stick some unicode text into a bytestring, you need a proper unicode encoding, such as utf-8
15:02:18 <arkeet> for example, the utf8-string package provides functions such as fromString :: String -> ByteString
15:02:25 <monochrom> you should, simply, BL.putStrLn (encode (the thing))
15:02:43 <monochrom> for a suitable version of encode
15:03:44 <EvanR> also Data.Text.Encoding
15:04:04 <arkeet> there is that, but that deals with Text instead of String.
15:04:14 <arkeet> (maybe you do want to use Text.)
15:04:30 <jedai42> EvanR: Yes, that would be my suggestion (eventually with overload string literals if that is often used)
15:04:46 <rasen_> Ok... I got my ["привет"] back from aeson
15:05:28 <arkeet> yeah, aeson's encode will take a String directly.
15:07:02 <rasen_> However, the real problem was the following: I get the response from server in ByteString (utf8) then I decode json with aeson, and get corrupted encoding on output. I would be really happy if aeson took Text as input, but it doesn't.
15:07:38 * hackagebot tinytemplate 0.1.1.0 - A tiny text templating library  http://hackage.haskell.org/package/tinytemplate-0.1.1.0 (PhilFreeman)
15:07:38 <EvanR> why do you have text though?
15:07:43 <EvanR> you said it was ByteString
15:08:17 <arkeet> hm, does aeson only work with utf-8 encoded documents?
15:08:34 <rasen_> server response is ByteString, but some fields in my data are Text
15:09:01 <EvanR> interpret them as bytestrings instead?
15:09:29 <rasen_> there is no instance FromJSON ByteString
15:09:42 <EvanR> you have json inside json then?
15:09:51 <rasen_> no
15:09:58 <rasen_> I can show you the code
15:10:32 <rasen_> https://github.com/rasendubi/hsreadability/blob/master/src/Network/Readability/Parser.hs
15:16:36 <travis1376> Hi, I'm trying to learn Haskell and I have a question about types and a function definition from the text Programming in Haskell.
15:16:59 <arkeet> ask away :)
15:17:20 <travis1376> I've pasted the relevant snippet here: http://lpaste.net/130710
15:17:39 * hackagebot bower-json 0.3.0.0 - bower.json from Haskell  http://hackage.haskell.org/package/bower-json-0.3.0.0 (hdgarrood)
15:17:59 <mjrosenb> I'm trying to use a ghci session from within emacs
15:18:00 <KaneTW> what's your question
15:18:02 <travis1376> I don't understand the definition, it appears to accept one integer as an argument in the type statement, but accepts two integers in the definition?
15:18:28 <KaneTW> what's Int -> Int
15:18:40 <mjrosenb> It is asking me "Start a new project named "reactive-banana-sdl2"".  What is it attempting to do?
15:18:57 <mjrosenb> there is already a reactive-banana-sdl2.cabal in the directory
15:19:02 <mjrosenb> or at least a parent of pwd.
15:19:12 <travis1376> I'm trying to show the portion of the text I'm quoting, the proper name is 'maps to'
15:19:35 <KaneTW> ok. Int maps to Int. what type of value maps an Int to an Int?
15:19:36 <HeladoDeBrownie> travis1376, you can imagine  add' x y = x + y means add' = \x -> \y -> x + y
15:20:23 <HeladoDeBrownie> (those are subtlely different in haskell but it might help demonstrate what the definition means)
15:20:41 <travis1376> Sorry, I'm not following your notation
15:21:01 <mjrosenb> travis1376: that isn't notation so much as valid haskell.
15:21:04 <HeladoDeBrownie> travis1376, \x -> whatever is a function accepting a parameter named x and resulting in whatever
15:21:26 <KaneTW> travis1376: well let's try it this way
15:21:38 <KaneTW> what's the difference between a value of type Int -> Int and Int -> Char
15:21:43 <HeladoDeBrownie> travis1376, in haskell every function accepts *exactly* one parameter, is the gist of it; but the result of a function can be a function
15:21:45 <mjrosenb> HeladoDeBrownie: how are those different? do they handle bottom differently?
15:22:02 <HeladoDeBrownie> mjrosenb, monomorphism restriction
15:22:08 <mjrosenb> HeladoDeBrownie: gah.
15:22:40 <mjrosenb> at least it isn't as bad as it is in SML.
15:22:47 <HeladoDeBrownie> but that gets sidestepped since there's a type signature (and it's monomorphic)
15:23:33 <mjrosenb> oh, I wonder if emacs is not running cabal repl to get its inferior ghci process.
15:23:41 <travis1376> What is the argument passed to add' then?  Is it only passed x?
15:24:06 <HeladoDeBrownie> travis1376, that's one way to look at it, yeah; and then y would be the parameter of the function that add' outputs
15:25:39 <mjrosenb> does anyone know how to force emacs to use cabal repl rather than ghci?
15:25:44 <HeladoDeBrownie> you will often hear people talk about functions of multiple parameters in haskell; but they really just mean functions that are like this, where they result in functions that accept the additional arguments
15:25:45 <mjrosenb> or how to tell which it is using?
15:26:05 <KaneTW> http://stackoverflow.com/questions/25580561/how-can-i-use-cabal-repl-instead-of-ghci-in-ghc-mod
15:26:22 <HeladoDeBrownie> travis1376, does this make sense?
15:26:31 <travis1376> not yet
15:26:48 <HeladoDeBrownie> ask about what's unclear
15:26:51 <travis1376> what is the difference between an argument and a parameter then?
15:27:08 <HeladoDeBrownie> ah, well people mix them up all the time in casual speech
15:27:26 <HeladoDeBrownie> but i use parameter to mean the variable bound by the lambda and argument to mean the thing passed to the function
15:27:38 <rasen_> Thank you guys! I just rerun my request and got proper encoding back. Seems that I was getting it wrong while extracting/printing
15:27:55 <KaneTW> foo :: Int -> Int  \ foo n = add n 1
15:28:08 <KaneTW> here n is the parameter to foo and n and 1 are arguments to add
15:28:29 <HeladoDeBrownie> KaneTW, what's the \ there supposed to be?
15:28:47 <HeladoDeBrownie> a semicolon?
15:28:57 <KaneTW> newline
15:29:08 <HeladoDeBrownie> just write a semicolon since \ means something else already
15:29:14 <HeladoDeBrownie> foo :: Int -> Int ; foo n = add n 1
15:29:17 <KaneTW> ah
15:29:19 <travis1376> the foo example makes sense since 1 is in the function definition
15:29:20 <KaneTW> wasn't sure one worked
15:29:32 <travis1376> but my example doesn't, since y is a variable... I think
15:29:32 <arkeet> semicolon is valid syntax for that too.
15:29:59 <HeladoDeBrownie> travis1376, y is a variable, yeah. it is also a parameter. parameters are variables.
15:30:05 <HeladoDeBrownie> (variables are not all parameters.)
15:30:11 <KaneTW> i use them so rarely that i always forget when they're valid syntax
15:30:42 <mjrosenb> KaneTW: ahh, a bit more verbose than necessary, but that did actually have relevant info!
15:32:05 <travis1376> Do the type statements like add' :: int (int -> int) leave out all parameters and include only arguments?
15:32:33 <HeladoDeBrownie> travis1376, i'm not sure that question is well formed or whether you're asking what you mean to
15:33:06 <HeladoDeBrownie> travis1376, i don't think you need to be too concerned about the distinction between parameters and arguments, judging from your initial question
15:33:41 <HeladoDeBrownie> travis1376, by the way, int, with a lowercase i, indicates a type variable, not the specific type Int, which has a capital I.
15:34:19 <fragamus> i was recently reading about cabal headaches somewhere regarding dependencies with dependencies
15:34:22 <KaneTW> travis1376: i think you're missing some vital piece of background
15:34:36 <fragamus> does anyone have the basic notion of what that was about5
15:35:21 <mjrosenb> fragamus: diamond dependencies?
15:35:38 <monochrom> this requires someone to know what that "somewhere" means.
15:35:49 <monochrom> but I guess people love to guess.
15:35:59 <kadoban> travis1376: What resource(s) are you using to learn haskell, by the way? https://github.com/bitemyapp/learnhaskell has good advice
15:36:44 <travis1376> I'm currently working through Programming in Haskell:  http://www.cs.nott.ac.uk/~gmh/book.html
15:37:17 <HeladoDeBrownie> hmm, i'm not familiar with that book but it makes me nervous that it introduces "classes" before "defining functions"
15:38:06 <benzrf> whats the diff between divmod and quotrem again
15:38:17 <benzrf> er or rather between div and quot and mod and rem
15:38:20 <fragamus> diamond dependencies yeah what is that
15:38:23 <monochrom> they do different things to negative numbers. I forgot the detail
15:38:24 <HeladoDeBrownie> although looking at it it seems like it's probably fine
15:38:51 <fragamus> mjrosenb: diamond dependencies yeah what is that
15:39:09 <mjrosenb> > ((-3) `divmod` 5, (-3) `quotrem` 5)
15:39:11 <lambdabot>      Not in scope: ‘divmod’
15:39:11 <lambdabot>      Perhaps you meant one of these:
15:39:11 <lambdabot>        ‘divMod’ (imported from Prelude),
15:39:21 <mjrosenb> > ((-3) `divMod` 5, (-3) `quotRem` 5)
15:39:21 <monochrom> yeah, it shows some simple function definitions after types before classes
15:39:22 <lambdabot>  ((-1,2),(0,-3))
15:39:24 <HeladoDeBrownie> travis1376, what chapter are you on?
15:39:36 <jedai42> benzrf: divmod is the "correct" mathy way to have euclidean division
15:39:45 <travis1376> I'm in chapter 3, section 6, the first example
15:39:56 <monochrom> quotRem is usually faster :)
15:40:15 <mjrosenb> fragamus: that is if Bar depends on Foo, and Baz also depends on Foo, and you depend of both Bar and Baz
15:40:18 <mjrosenb> which isn't a problem
15:40:28 <jedai> benzrf: but quotRem is usually faster (implemented in the cpu directly) and do the same for positive inputs so...
15:40:34 <monochrom> but don't forget to try negative divisors, too
15:40:35 <mjrosenb> unless Bar depends on Foo-1.0, and Baz depends on Foo-0.1
15:40:38 <benzrf> howdothey differ for neg
15:40:43 <HeladoDeBrownie> travis1376, ah, it looks like the slide more or less says what we were saying. if something is confusing you about that feel free to ask about what is confusing you
15:41:06 <jedai> benzrf: Well -7 = -3 * 3 + 2 right
15:41:20 <benzrf> uuh
15:41:25 <benzrf> no?
15:41:28 <jedai> benzrf: that's the proper euclidean division anthat's what divMod qiges you
15:41:31 <benzrf> er wait yes
15:41:38 <benzrf> oh i missed your demo
15:41:40 <benzrf> derp
15:41:59 <jedai> but -7 = -3 * 2 - 1 too, and that's what quotRem gives you
15:42:28 <mjrosenb> IIRC, they only differ when the divisor and dividend have different signs?
15:42:28 <travis1376> The type statement appears to indicate that add' operates on one Int, but the definition of appears to state that add' operates on two Ints
15:42:33 <jedai> > (divMod (-7) (-3), quotRem (-7) (-3) )
15:42:34 <lambdabot>  ((2,-1),(2,-1))
15:42:44 <jedai> ....
15:42:57 <jedai> > (divMod (-7) 3, quotRem (-7) 3 )
15:42:58 <benzrf> > -10 `mod` 3
15:42:58 <lambdabot>  ((-3,2),(-2,-1))
15:42:59 <monochrom> try pos dividend, neg divisor
15:43:00 <lambdabot>  -1
15:43:02 <HeladoDeBrownie> travis1376, the way the definition is written employs a bit of shorthand for something commonly done, namely defining curried functions
15:43:05 <benzrf> > -10 `rem` 3
15:43:07 <lambdabot>  -1
15:43:10 <benzrf> ?
15:43:51 <mjrosenb> benzrf: is that getting parsed correctly?
15:44:07 <zaquest> @pl \x -> x - 2
15:44:07 <lambdabot> subtract 2
15:44:09 <HeladoDeBrownie> travis1376, the definition "add' x y = x + y" just means the following: add' is a function accepting an argument, which we will call x, and returning a function accepting an argument, which we will call y, and returning x + y.
15:44:30 <jedai> benzrf: Welp... it usually don't matter much, but the point is with a positive divisor, rem will sometimes gives you a negative remainder whereas mod will always gives you a positive remainder
15:44:38 <benzrf> huh
15:44:39 <mjrosenb> oh, wait. the infix should force it to be parsed correctly?
15:44:42 <fragamus> mjrosenb: why is that problematic in cabal
15:44:49 <HeladoDeBrownie> travis1376, you may notice that the x from the outer function is available to the inner one, which is fine because of haskell's scoping rules
15:44:50 <travis1376> wouldn't the function have to accept both x and y in order to do that?
15:45:33 <kadoban> travis1376: It does.
15:45:38 <HeladoDeBrownie> travis1376, basically, x is available *everywhere* in the entire body of the outermost function
15:46:05 <HeladoDeBrownie> you could even have written it like this and it'd still work the same: add' x = \y -> x + y
15:46:07 <travis1376> I understand x's scope and availability, it is y that is proving difficult
15:46:23 <HeladoDeBrownie> travis1376, what about y?
15:46:57 <jedai> benzrf: so basically, neither divMod nor quotRem guarantee a proper euclidean division but divMod does a bit more often (it only mess up for negative divisors...)
15:47:11 <travis1376> In the type statement add' operates on Int, not (Int, Int).  So where does y come from, and how does add' 'know about y' if it only operates on a single Int
15:47:31 <kuribas> travis1376: in haskell (add' 1 2) is the same as ((add' 1) 2)
15:48:14 <mjrosenb> gah.  why are sandboxes so annoying to use.
15:48:14 <HeladoDeBrownie> travis1376, in the definition add' x = \y -> x + y, add' has type Int -> (Int -> Int), x has type Int, and \y -> x + y has type Int -> Int. does that help?
15:48:16 <kuribas> travis1376: (add' 1) is a function which adds 1 to another number.
15:49:16 <monochrom> add' has type Int->(Int->Int). therefore, "add' 1" has type (Int->Int). therefore, "(add' 1) 2" is still legit, and the 2 is your y
15:49:51 <Javran> :t [undefined :: a -> a -> a, undefined :: b -> (b -> b)]
15:49:52 <lambdabot> [a -> a -> a]
15:49:56 <monochrom> you are right to observe that there is no (Int,Int) involved anywhere.
15:50:01 <travis1376> I'm thinking about it Heraldo and kuribas
15:50:14 <mjrosenb> travis1376: for the most part, haskell is referentially transparent, which means you can replace a variable with its value, and not change anything.  This means that if you have (add = \x -> \y -> x+y), then add 1, you can replace 'x' with '1', and have an equivalent expresion, so add 1 = \y -> 1+y
15:50:20 <HeladoDeBrownie> nobody's ever called me Heraldo before XD
15:50:48 <travis1376> Sorry, HeladoDeBronie, I meant no offence
15:50:52 <travis1376> lol
15:50:58 <monochrom> I think he likes it
15:50:58 <HeladoDeBrownie> that's worse -_-
15:50:59 <travis1376> HeraldoDeBrownie
15:51:12 <travis1376> I can't type
15:51:39 <mjrosenb> travis1376: most clients support tab completion, so you can type in hel<TAB>, and it gives you HeladoDeBrownie 
15:52:16 <travis1376> HeladoDeBrownie:
15:52:20 <HeladoDeBrownie> there you go
15:52:22 <monochrom> the only limitation is that I can't type "ref<tab> tra<tab>" to obtain "referentially transparent" or something
15:52:28 <travis1376> mjrosenb: thank you
15:52:32 <HeladoDeBrownie> monochrom, with the right client you can
15:52:45 <mjrosenb> monochrom: in erc, that will more or less work.
15:52:53 * mjrosenb wonders if the correct way to do this is to just include my test code in my .cabal file?
15:53:01 <Javran> not if something called referentially or transparent enter the room :)
15:53:17 <kuribas> monochrom: M-S-/ in emacs :)
15:53:19 <mjrosenb> since I can't seem to get runghc to include both things in the sanbox, and the libraries that I'm working on?
15:53:21 <HeladoDeBrownie> we should just have people around with all sorts of useful nicks
15:54:01 <HeladoDeBrownie> ski has a useful nick sometimes
15:54:10 <monochrom> some mad scientist once postulated to have a lot of bots join this channel, under the names "catamorphism", "adjunction", "applicative", etc
15:54:13 <HeladoDeBrownie> regrettably, it's very easy to type without tab
15:55:50 <monochrom> I see what you're doing
15:55:59 <Reflexivity> I guess I have more uses in coq 
15:56:00 <Reflexivity> lol
15:56:26 <monochrom> both partial orders and equivalence relations have Ref<tab>
16:09:13 <mjrosenb> does putStrLn automatically flush stdout?
16:10:38 <dpwright> mjrosenb: Check out https://hackage.haskell.org/package/base-4.8.0.0/docs/System-IO.html#v:BufferMode
16:11:22 <dpwright> when set to LineBuffering, yes.
16:12:24 <dpwright> the default for stdout, at least in the environments I've tried it in, has been BlockBuffering
16:13:12 <mjrosenb> dpwright: it doesn't say what the default is :-/
16:13:43 <dpwright> "The default buffering mode when a handle is opened is implementation-dependent and may depend on the file system object which is attached to that handle. For most implementations, physical files will normally be block-buffered and terminals will normally be line-buffered."
16:14:31 <dpwright> if flushing automatically on newlines is the behaviour you need, just enable LineBuffering at the start of your app and have done with it
16:15:01 <dpwright> hSetBuffering stdout LineBuffering
16:17:41 * hackagebot cipher-aes128 0.7 - AES and common modes using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.7 (ThomasDuBuisson)
16:18:55 <faux___> i have multiple types that should all implement a function 'f'. what are the pros/cons to implementing a type class 'F a' with 'f :: a -> String' and making all of these types an instance of 'F', vs. creating a 'data Type' that includes all my types and a function 'f :: Type -> String'? thanks
16:19:24 <HeladoDeBrownie> faux___, is there a "privileged" implementation for each, or can there be several?
16:19:42 <faux___> HeladoDeBrownie: what do you mean by privileged? i am new to haskell, but not to programming
16:19:59 <HeladoDeBrownie> faux___, are you only ever going to want to have one such function per type?
16:20:06 <faux___> HeladoDeBrownie: yes
16:22:20 <HeladoDeBrownie> well, roughly, one advantage is the compiler can compute which instance to use automatically, and one disadvantage is that instances are not as easy to compose or otherwise use first-class as data types
16:22:32 <HeladoDeBrownie> it sounds like the latter won't be as much a problem here
16:22:52 <HeladoDeBrownie> so just from what i've heard i don't think there'd be much problem making it a typeclass
16:23:52 <faux___> HeladoDeBrownie: as a haskell novice, the biggest disadvantage i see to a typeclass is verbosity
16:24:17 <HeladoDeBrownie> in what way? there definitely is a tradeoff there but i'm wondering what in particular you mean
16:24:53 <faux___> HeladoDeBrownie: having to write 'data Type1 = Type1 ... instance Type Type1 where f (Type1 ...) = ...'
16:25:25 <faux___> vs. 'Type = Type1 | ... f (Type1 ...) = ...'
16:25:36 <HeladoDeBrownie> ah, i definitely misunderstood what you were saying
16:26:32 <HeladoDeBrownie> well those two things are going to have quite different purposes; the major difference is in the former example, Type represents an open universe of types whereas in the latter it's closed
16:26:47 <HeladoDeBrownie> in other words, the first lets you add more later or from outside, the latter does not
16:27:04 <faux___> HeladoDeBrownie: that's very good. i wasn't thinking about that
16:27:20 <faux___> HeladoDeBrownie: i will need to extend from outside
16:27:30 <faux___> HeladoDeBrownie: you just answered my question, thank you!
16:27:55 <HeladoDeBrownie> no problem
16:30:16 <ronh> HeladoDeBrownie what subtle difference is there between "add' x y = x + y" and "add' = \x -> \y -> x + y"?
16:31:04 <HeladoDeBrownie> ronh, i answered earlier; it involves the monomorphism restriction. there is no difference if you explicitly write its type though.
16:31:11 <Hijiri> faux___: If you think of it in terms of the expression problem, ADTs let you add new operations easily, but typeclasses let you add more members easily
16:31:16 <arkeet> they also can inline differently.
16:31:48 <faux___> Hijiri: that's very good, thank you
16:32:24 <faux___> Hijiri: in my case i have only one function but a variable amount of members. so it's an easy decision with your advice
16:33:43 <travis1376> HeladoDeBrownie: Do you know where I can find an explanation of currying in a mathematical sense, rather than as applied to Haskell?
16:34:18 <HeladoDeBrownie> travis1376, study the untyped lambda calculus; haskell can be seen in many ways as a heavily sugared, typed, lambda calculus
16:34:44 <HeladoDeBrownie> travis1376, this won't lead you to an "explanation of currying" per se but it behaves like haskell does
16:35:01 <rye_yawn_> I'm new to haskell, and I'm wondering if we're allowed to ask questions here?
16:35:13 <geekosaur> sure
16:35:16 <josephle> ask away
16:35:19 <HeladoDeBrownie> travis1376, this might  help https://en.wikipedia.org/wiki/Lambda_calculus
16:35:20 <rye_yawn_> Sweet :-)
16:35:50 <rye_yawn_> I'm working on some project euler problems and one is to sum the fibonacci sequence below 4000000
16:36:03 <rye_yawn_> I wrote a function which generates fibonacci numbers
16:36:09 <faux___> travis1376: +1 on lambda calculus. it might seem uselessly abstract but it'll teach you haskell like nothing else
16:36:10 <rye_yawn_> but my sum for some reason doesn't work
16:36:18 <rye_yawn_> and I think it is because the predicate has a problem
16:37:12 <travis1376> I'm beginning to think something is amiss with my 'BS in mathematics'
16:37:23 <rye_yawn_> fibonaccisum = sum [fibonacci y | y <- [1..], fibonacci y < 4000000]
16:38:11 <josephle> travis1376, any experience in category theory?
16:38:41 <hpc> rye_yawn_: you'll be recomputing the beginning of the fibonacci sequence many times
16:38:51 <kadoban> rye_yawn_: Why not make a list of all of the fibonacci numbers in order, and takeWhile (<4000000), and then sum that?
16:38:51 <travis1376> none, abstract algebra, set theory, analysis,... no category theory
16:39:10 <rye_yawn_> I haven't used takeWhile yet
16:39:12 <rye_yawn_> I'll look into that
16:39:15 <hpc> :t takeWhile
16:39:16 <lambdabot> (a -> Bool) -> [a] -> [a]
16:39:23 <rye_yawn_> why does it recompute the beginning of the fibonacci numbers many times?
16:39:23 <hpc> rye_yawn_: to elaborate, you'd make an infinite list of fibs
16:39:39 <kadoban> rye_yawn_: That doesn't appear that it can work. It doesn't know when it can stop. Haskell can't know that fibonacci is strictly increasing, so it'll keep trying higher and higher y, forever.
16:39:49 <hpc> rye_yawn_: it's never being reused
16:39:54 <rye_yawn_> OH
16:39:55 <Javran> rye_yawn_: does "fibonacci 34" take a long time to run?
16:40:18 <hpc> so (fibonacci 100) takes some long computation time
16:40:23 <hpc> and then you throw out all that work
16:40:28 <rye_yawn_> hmmm
16:40:34 <hpc> and (fibonacci 101) has to recompute all of that again
16:40:42 <travis1376> HeladoDeBrownie: Thank you, http://en.wikipedia.org/wiki/Lambda_calculus is made of awesome
16:40:53 <rye_yawn_> I guess I thought that fibonacci y < 4000000 means it'd produce a list until you got to a number less than 4000000
16:41:06 <rye_yawn_> so for instance
16:41:07 <kadoban> Well, it depends how he implemented 'fibonacci'. It might not be quite as bad as it seems, but it probably is.
16:41:14 <rye_yawn_> :-)
16:41:17 <kadoban> Hehe
16:41:32 <rye_yawn_> functional programming is new to me
16:41:36 <rye_yawn_> so for instance 
16:41:39 <arkeet> it'll take all the elements of the list less than 4000000.
16:41:46 <arkeet> but who knows if there is one far down the list that's smaller
16:41:49 <hpc> kadoban: at the very least, it'd take a phenomenal amount of memory
16:41:52 <Javran> the math formula translation of fibonacci doesn't work well in haskell, in terms of time.
16:42:02 <hpc> while a list streaming approach is constant in memory as well
16:42:04 <rye_yawn_> because it doesn't remember the rest of the list?
16:42:09 <rye_yawn_> so it has to constantly recheck it?
16:42:12 <hpc> rye_yawn_: yes
16:42:18 <Javran> yeah, you'd want to do some sharing
16:42:19 <hpc> except it's not a list
16:42:32 <rye_yawn_> so when I hit 2 for y
16:42:37 <hpc> rye_yawn_: it's similar to using (!!) for indexing, if you've been explained why that's slow
16:42:45 <arkeet> haskell does not automatically memoize results of functions.
16:42:53 <arkeet> this is a textbook example for memoization :p
16:42:54 <rye_yawn_> the predicate has to check if fibonacci 1 and fibonacci 2?
16:43:16 <Javran> @let fib x | x <= 1 = x | otherwise = ((+) `on` fib) (x-1) (x-2)
16:43:19 <lambdabot>  Defined.
16:43:22 <Javran> > fib 30
16:43:22 <kadoban> hpc: Well, not really. There's not very many fibonacci numbers below 4000000. Remember it's exponential
16:43:26 <lambdabot>  mueval-core: Time limit exceeded
16:43:39 <arkeet> > fib 15
16:43:40 <lambdabot>  610
16:43:47 <arkeet> > fib 20
16:43:48 <lambdabot>  6765
16:43:50 <arkeet> > fib 25
16:43:52 <lambdabot>  75025
16:43:53 <arkeet> > fib 30
16:43:57 <lambdabot>  mueval-core: Time limit exceeded
16:44:09 <rye_yawn_> got it
16:44:13 <rye_yawn_> thanks everyone :-)
16:44:19 <hpc> kadoban: close enough
16:44:25 <arkeet> computing fib 25 has to perform 75025 additions.
16:44:35 <arkeet> well, 75024
16:44:42 <arkeet> well I dunno.
16:44:43 <arkeet> it's a lot.
16:44:51 <kadoban> hpc: Not sure I get what you mean by "close enough"
16:45:35 <arkeet> > [x | x <- [1..]; x < 10]
16:45:37 <bernalex> @let fibernalex 0 = (1, 1); fibernalex 1 = (1, 2); fibernalex n | even n    = (a*a + b*b, c*c - a*a) | otherwise = (c*c - a*a, b*b + c*c) where (a,b) = fib2 (n `div` 2 - 1); c = a + b
16:45:37 <lambdabot>  <hint>:1:16: parse error on input ‘;’
16:45:39 <lambdabot>  .L.hs:154:18: Not in scope: ‘fib2’
16:45:42 <bernalex> aw
16:45:44 <arkeet> > [x | x <- [1..], x < 10]
16:45:51 <lambdabot>  mueval-core: Time limit exceeded
16:45:55 <arkeet> (if you did this in ghci you'd see: [1,2,3,4,5,6,7,8,9,
16:45:58 <arkeet> and it would never stop)
16:46:00 <hpc> kadoban: there's still a lot of them
16:46:06 <rye_yawn_> interesting!
16:46:09 <Javran> @let fibs = 0:1:zipWith (+) fibs (tail fibs)
16:46:10 <lambdabot>  Defined.
16:46:12 <bernalex> @let fibernalex 0 = (1, 1); fibernalex 1 = (1, 2); fibernalex n | even n    = (a*a + b*b, c*c - a*a) | otherwise = (c*c - a*a, b*b + c*c) where ((a,b), c) = fibernalex ((n `div` 2 - 1), a + b)
16:46:13 <lambdabot>  .L.hs:153:15:
16:46:13 <lambdabot>      Occurs check: cannot construct the infinite type: t ~ (t, t)
16:46:13 <lambdabot>      Relevant bindings include
16:46:13 <kadoban> hpc: There's … 34
16:46:14 <hpc> might as well optimize further
16:46:22 <hpc> eh
16:46:23 <bernalex> interesting.
16:46:24 <Javran> > take 30 fibs
16:46:26 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
16:46:27 <hpc> that's basically a billion
16:46:33 <kadoban> Haha
16:46:40 <arkeet> you can compute the n'th fib with O(log n) additions.
16:47:05 <Javran> textbook example for lazy stream :)
16:47:44 <bernalex> I wrote a very efficient generalised (includes negative numbers) fib once
16:48:23 <bernalex> http://lpaste.net/4710034138076282880 like this
16:48:37 <arkeet> messy.
16:49:13 <bernalex> sure. it's somewhat non-trivial.
16:49:48 <bernalex> rather efficient AFAIR though. and works for negative numbers.
16:50:04 <arkeet> now write one that uses the fact that (^) already does exponentiation by squaring.
16:50:07 <FireFly> arkeet: there's a closed-form expression for it, no?
16:50:26 <arkeet> FireFly: yes but
16:50:35 <bernalex> arkeet: no thanks. I don't like premature optimisation. if I did I'd use c instead of haskell.
16:50:48 <arkeet> what's premature optimization about that?
16:50:53 <arkeet> FireFly: how would you use that?
16:50:56 <bernalex> arkeet: I don't need a faster fib.
16:51:02 <arkeet> not faster.
16:51:04 <arkeet> just cleaner.
16:51:04 <Javran> or you can translate the until loop approach
16:51:04 <arkeet> :-)
16:51:30 <Javran> @let fib2 m n 0 = m; fib2 m n c = fib2 n (m+n) (pred c)
16:51:32 <lambdabot>  Defined.
16:51:40 <Javran> > map fib2 [1..10]
16:51:41 <lambdabot>  Not in scope: ‘fib2’
16:51:44 <arkeet> that's linear time.
16:51:53 <arkeet> > map fib2 [1..10]
16:51:54 <lambdabot>  Not in scope: ‘fib2’
16:52:00 <Javran> weird
16:52:08 <arkeet> try defining it again.
16:52:17 <Javran> @let fib2 m n 0 = m; fib2 m n c = fib2 n (m+n) (pred c)
16:52:18 <lambdabot>  Defined.
16:52:28 <Javran> > map fib2 [1..10]
16:52:30 <lambdabot>  [<Integer -> Integer -> Integer>,<Integer -> Integer -> Integer>,<Integer ->...
16:52:39 <Javran> oh right
16:52:52 <Javran> > map (fib2 1 1) [1..10]
16:52:55 <lambdabot>  [1,2,3,5,8,13,21,34,55,89]
16:53:18 <Javran> so this one don't require streams
16:54:55 <lpaste> arkeet pasted “fib using (^)” at http://lpaste.net/130719
16:54:57 <arkeet> ^
16:55:16 <arkeet> :t fib
16:55:17 <lambdabot>     Not in scope: ‘fib’
16:55:18 <lambdabot>     Perhaps you meant one of these:
16:55:18 <lambdabot>       ‘fib2’ (line 149), ‘fix’ (imported from Data.Function)
16:55:21 <arkeet> @letlpaste 130719
16:55:23 <lambdabot>  Defined.
16:55:27 <arkeet> :t fib
16:55:28 <lambdabot> (Integral i, Num a) => i -> a
16:55:31 <arkeet> > map fib [0..20]
16:55:33 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
16:55:41 <arkeet> > fib 1000 :: Integer
16:55:42 <lambdabot>  4346655768693745643568852767504062580256466051737178040248172908953655541794...
16:56:34 <kadoban> arkeet: Heh, that's cute.
16:56:34 <Javran> @src (^)
16:56:34 <lambdabot> x ^ 0            =  1
16:56:34 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
16:56:34 <lambdabot>   where f _ 0 y = y
16:56:34 <lambdabot>         f x n y = g x n
16:56:34 <lambdabot>           where g x n | even n    = g (x*x) (n `quot` 2)
16:56:36 <lambdabot>                       | otherwise = f x (n-1) (x*y)
16:56:38 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
16:56:40 <arkeet> the idea is that F a b represents the number a + b*(1+sqrt 5)/2
16:57:47 <Javran> I see, ^ is doing fast exponentiation
17:02:52 <JagaJaga> (lens question) What's a right operator like (^..) for State Monad?
17:03:06 <JagaJaga> ^. = use, but what about ^..?
17:03:52 <mpickering> JagaJaga: This might be helpful - https://github.com/ekmett/lens/wiki/Operators
17:05:10 <JagaJaga> mpickering: the cell I need is empty :(
17:07:43 * hackagebot hsx2hs 0.13.3.2 - HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.  http://hackage.haskell.org/package/hsx2hs-0.13.3.2 (DavidFox)
17:07:59 <HeladoDeBrownie> JagaJaga, then using gets may be the way to go
17:08:07 <dfeuer> Well.... I got this sorting algorithm working. The only problem is that it's currently slow as molasses. Some of the inefficiencies are very obvious. How to fix them is somewhat less so.
17:08:20 * dfeuer seriously hates nested types.
17:08:56 <JagaJaga> hellschreiber: "gets"?..
17:09:34 <HeladoDeBrownie> @type gets
17:09:36 <lambdabot> MonadState s m => (s -> a) -> m a
17:09:50 <HeladoDeBrownie> gets (^.. _)
17:10:14 <JagaJaga> HeladoDeBrownie: oh! Nice. Thank you
17:15:45 <arkeet> haha I got addition wrong on my F thing but it still somehow worked for fib.
17:15:54 <arkeet> I had F a b + F c d = F (a+b) (c+d).
17:23:23 <rockfruit> join
17:28:22 <edwardk> or reference: you can use gets (toListOf l) as well 
17:31:41 <discus> in a program that doesnt do any heavy string parsing should I use String for convenience or Text?
17:33:24 <monochrom> if a few strings, String; if a lot, Text.
17:33:34 <monochrom> this is because merely memory usage can already kill you
17:33:36 <JagaJaga> What's the right way to do such thing: (using pseudocode) for (i = 0; i < list.length; i++) { result <- f list[i]; if result == ok then do next iteration else break and return result. If there are no elements return ok}. data Result = Ok | Fail
17:34:47 <monochrom> a String of length n takes at least n*8 bytes. if 64-bit, n*16 bytes
17:35:23 <arkeet> JagaJaga: if you use Either, with Left as failure, then that's basically mapM_
17:35:37 <arkeet> or Maybe with Nothing for failure.
17:35:52 <Javran> does it include Cons overhead?
17:36:46 <discus> monochrom: what about an irc client?
17:36:47 <tonyday567> JagaJaga: this helped me understand breaks http://www.haskellforall.com/2012/07/breaking-from-loop.html
17:36:49 <Javran> Strings are just singly linked list of Chars
17:36:54 <JagaJaga> arkeet: oh! I can just create a monad instance for my datatype
17:36:54 <discus> String or Text
17:37:06 <monochrom> a Text of length n takes 2*n to 4*n bytes usually. maybe more if you use the really newfangled characters but rare
17:37:08 <JagaJaga> tonyday567: thx, gonna read
17:37:59 <monochrom> Javran: my n*8 and n*16 are just the Cons cell itself. I am not even counting the characters themselves
17:38:24 <Javran> monochrom: O_O wow that's a lot already
17:38:47 <monochrom> the characters are difficult to count, since GHC-generated code likes to keep a bunch of shared flyweights for them.
17:39:09 <arkeet> I think (repeat 'x') :: String takes up fairly little space.
17:39:12 <arkeet> :-)
17:39:31 <Javran> @src repeat
17:39:31 <lambdabot> repeat x = xs where xs = x : xs
17:39:51 <Javran> yeah, that's sharing
17:40:21 <JagaJaga> arkeet: oh, I forgot, my function have type `a -> IO MyResultType`
17:40:29 <monochrom> "aaaaaaaaa" is usually n*16 bytes of cons cells and one single 'a' shared n times
17:40:34 <JagaJaga> arkeet: mapM is not a way, is it?
17:40:40 <arkeet> JagaJaga: okay, so you can use mapM on EitherT or something.
17:41:00 <monochrom> actually should be n*24.
17:41:01 <arkeet> IO (Either e a) = EitherT e IO a
17:41:02 <JagaJaga> arkeet: oh, nice, ok.
17:41:22 <arkeet> (from the either package)
17:41:43 <monochrom> each cons cell is: 8 bytes for tag and header, 8 bytes for pointer to data, 8 bytes for pointer to next
17:42:21 <monochrom> in general, "data X = Ctor A B C" is 8 bytes for tag, 8 bytes for pointer to A, 8 bytes for pointer to B, 8 bytes for pointer to C.
17:43:16 <monochrom> while you may be disgusted that the tag takes a whole word itself, there is much benefit in keeping alignment
17:44:12 <monochrom> and also something about "the tag is a pointer to a piece of code" so it has to be a full address
17:44:16 <Javran> that's its internal representation in STG machine?
17:44:41 <monochrom> I don't know STG. this is GHC-generated code by the time you see x86-64 asm
17:44:53 <Javran> I see
17:45:02 <monochrom> STG is likely more abstract and non-committal than that
17:45:09 <monochrom> STG is written on paper.
17:45:35 <shachaf> STG is the name of an abstract machine and also of an intermediate language used by GHC.
17:45:47 <Javran> I don't get the "Tagless" part, since we does have tags on things ..?
17:46:13 <shachaf> And you do get the "spineless" part?
17:46:22 <shachaf> At any rate, those aren't the tags "tagless" refers to.
17:46:31 <Javran> neither
17:46:44 <Javran> so yeah I didn't know much about it
17:46:46 <monochrom> I don't know STG, and probably that's my blessing.
17:47:59 <monochrom> but I know the bottomline. if you desire to treat thunks and WHNFs uniformly, then you are forced to: a thunk is a record, the first field is pointer to a piece of code; a WHNF is a record, the first field is a pointer to a piece of code again
17:49:07 <Javran> I thought there're 3 kinds of things, all sharing the same structure
17:49:36 <monochrom> I take liberty to call the latter pointer to code "tag".
17:49:53 <monochrom> one has to be pretty pedantic to say that it is not a "tag"
17:51:05 <monochrom> this is because that pointer points to the piece of code that reminds you "you are looking at the data constructor Ctor". therefore it is logically equivalent to a tag.
17:52:04 <monochrom> everything I said does not contradict "there are more than 2 cases"
17:52:27 <lpaste> arkeet revised “fib using (^)”: “No title” at http://lpaste.net/130719
17:52:40 <monochrom> I have listed 2 cases. this is consistent with every statement of the form "there are n cases" where n>=2.
17:52:44 <arkeet> oop, didn't mean to advertise that.
17:52:49 <arkeet> oh well, negative arguments supported now.
17:52:50 <Javran> right, there has to be something that plays the role of tags
17:53:47 * Javran wants to scan over that STG paper
17:54:51 <arkeet> > map fib [-10..10]
17:54:53 <lambdabot>  [-55,34,-21,13,-8,5,-3,2,-1,1,0,1,1,2,3,5,8,13,21,34,55]
17:56:19 * arkeet now ponders whether all the units in Z[phi] have the form +/- phi^n
18:04:27 <Ryanar> > max [1,2..10]
18:04:29 <lambdabot>  <[Integer] -> [Integer]>
18:04:42 <Ryanar> > max 1 2
18:04:43 <lambdabot>  2
18:05:02 <Ryanar> > map max [1,2..10]
18:05:03 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>,<Integer -> ...
18:05:07 <Ryanar> ack
18:05:18 <arkeet> seems like the answer is yes.
18:05:24 <dfeuer> map max!
18:05:39 <arkeet> Ryanar: what do you want?
18:05:56 <Ryanar> find the max of a list
18:06:07 <arkeet> sounds like a fold.
18:06:14 <arkeet> well, there's a Prelude function that does it directly.
18:07:07 <tromp> :t maximum
18:07:08 <lambdabot> (Ord a, Foldable t) => t a -> a
18:07:12 <Ryanar> ah
18:07:20 <Ryanar> > maximum [1,2..10]
18:07:21 <arkeet> I wonder why it's defined using foldl1 instead of foldl1'
18:07:21 <lambdabot>  10
18:07:28 <tromp> > maximum [Nothing, Just 42, Just 5]
18:07:30 <lambdabot>  Just 42
18:07:32 <Ryanar> cool
18:07:48 <Ryanar> > minimum [1,2..10]
18:07:49 <lambdabot>  1
18:08:04 <tromp> > minimum [Nothing, Just 42, Just 5, Just -89]
18:08:05 <lambdabot>      Couldn't match expected type ‘Maybe a’
18:08:05 <lambdabot>                  with actual type ‘a0 -> Maybe a0’
18:08:05 <lambdabot>      Probable cause: ‘Just’ is applied to too few arguments
18:08:12 <tromp> > minimum [Nothing, Just 42, Just 5, Just (-89)]
18:08:12 <bananagram> > map max [1,2..10] <*> [3,8]
18:08:13 <arkeet> that's parsed as Just - 89
18:08:14 <lambdabot>  <no location info>: can't find file: L.hs
18:08:14 <lambdabot>  Nothing
18:08:15 <arkeet> yeah.
18:08:26 <tonyday567> :t foldr max (-1/0)
18:08:26 <lambdabot> (Fractional b, Ord b, Foldable t) => t b -> b
18:08:33 <arkeet> > map max [1,2..10] <*> [3,8]
18:08:34 <lambdabot>  [3,8,3,8,3,8,4,8,5,8,6,8,7,8,8,8,9,9,10,10]
18:08:47 <arkeet> :t liftA2 max
18:08:48 <lambdabot> (Ord c, Applicative f) => f c -> f c -> f c
18:09:02 <arkeet> > liftA2 max [1..4] [1..4]
18:09:03 <lambdabot>  [1,2,3,4,2,2,3,4,3,3,3,4,4,4,4,4]
18:11:46 <Ryanar> ok so question for you guys
18:13:24 <Ryanar> meh easier to paste one second
18:14:16 <lpaste> ryanar pasted “how can I store the values read from IO” at http://lpaste.net/4111190318328578048
18:15:45 <pacak> Ryanar: Extra parameter and recursion
18:16:13 <Ryanar> ok let me play with that idea
18:17:36 <KaneTW> state monad
18:17:46 <KaneTW> which is pretty much the same
18:17:58 <HeladoDeBrownie> State just helps make the "extra parameter and recursion" idea implicit, but is functionally the same
18:18:30 <pacak> MVar/IORef - you are in IO
18:18:42 <KaneTW> @unmtl StateT s IO a
18:18:42 <lambdabot> s -> IO (a, s)
18:18:54 <HeladoDeBrownie> i tend to think pure state is better unless you need cross-thread state
18:19:03 <HeladoDeBrownie> or otherwise transactional, etc.
18:19:11 <faux___> i've created a new ADT 'data Alignments = Alignments [String]'. I'm using an ADT because Alignments needs to be an instance of a typeclass. I'd like to use `length` on Alignments. How can i define a `length` function for this ADT? I think that defining a length function for it would overwrite the existing length function. thanks
18:19:44 <pacak> faux___: You can use newtype. You can't override length.
18:20:01 <HeladoDeBrownie> faux___, you can name the function length but you'll need to use the module name or whatever to disambiguate it, or else use only one length function or the other
18:20:16 <faux___> pacak: alright, that means it can't be an ADT?
18:20:19 <HeladoDeBrownie> it can be
18:20:28 <KaneTW> you could use a generic length implementation
18:20:29 <HeladoDeBrownie> you just can't use the same Prelude.length on it
18:20:52 <KaneTW> @unmtl StateT s (StateT s IO a) a
18:20:52 <lambdabot> s -> (StateT s IO a) (a, s)
18:21:16 <HeladoDeBrownie> if you wrote type Alignments = [String] then you could, because then they'd be exactly the same as far as the type system cares
18:21:42 <faux___> HeladoDeBrownie: and then i can do 'instance MyClass Alignments where ...'?
18:21:51 <HeladoDeBrownie> not as such
18:22:24 <pacak> You kind of can. It's just not a very good idea to do it this way.
18:22:36 <zugz> is there a neat way to express the list version of zip? i.e. to zip a finite list of streams into a stream of finite lists?
18:23:02 <KaneTW> :t length
18:23:03 <lambdabot> Foldable t => t a -> Int
18:23:09 <KaneTW> well you could implement foldable
18:23:34 <faux___> KaneTW: you mean 'instance Foldable Alignments where ...'?
18:23:46 <pacak> faux___: Which ghc are you using?
18:24:17 <KaneTW> something like that, but you'd need to work around the * -> * kind somehow
18:24:32 <faux___> pacak: i'm using cabal, is there a way for cabal to reveal its ghc version?
18:24:37 <pacak> ghc --version
18:24:56 <faux___> 7.8.3
18:25:08 <zugz> ah nevermind, Data.List.transpose is what I wanted
18:25:22 <pacak> No instance Foldable then.
18:25:38 <faux___> i'm guessing this is the same ghc that cabal is using
18:26:11 <faux___> sounds like i need to define a new function `numAlignments`
18:31:44 <KaneTW> @hoogle a -> b
18:31:46 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
18:31:46 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
18:31:46 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
18:34:46 <dfeuer> Pointless challenge:  flip flip [] . (foldr .) . (.) . flip . flip (ap . liftM2 (.) bool (flip (:)))
18:37:02 <pacak> dfeuer: http://glennstovall.com/images/no.jpeg 
18:38:17 <jmcarthur> @unpl flip flip [] . (foldr .) . (.) . flip . flip (ap . liftM2 (.) bool (flip (:)))
18:38:17 <lambdabot> (\ ad f -> foldr (\ j m -> (((\ r b -> return (\ x -> r ((\ z aa -> (:) aa z) b x)) b) (bool m) m) >>= \ as -> ad >>= \ ar -> return (as ar)) (f j)) [])
18:38:22 <KaneTW> whoa what
18:38:23 <jmcarthur> impressive
18:38:29 <dfeuer> pacak, it's just   \f g -> filter f . map g   but taken apart.
18:38:36 <Javran> :t bool
18:38:37 <lambdabot> a -> a -> Bool -> a
18:38:52 <Javran> if' with argument rearranged?
18:38:56 <dfeuer> unpl doesn't help because it doesn't know what monad instance it is.
18:39:10 <KaneTW> :t flip flip [] . (foldr .) . (.) . flip . flip (ap . liftM2 (.) bool (flip (:)))
18:39:10 <dfeuer> Javran, yeah; if' is an @pl special; bool is in Data.Bool.
18:39:11 <lambdabot> Foldable t => (b -> Bool) -> (a -> b) -> t a -> [b]
18:39:17 <jmcarthur> yeah shame that
18:39:20 <Javran> I see
18:39:51 <jmcarthur> so judging from the type if looks like a map-filter-tolist thing?
18:39:56 <jmcarthur> (it
18:40:18 <dfeuer> jmcarthur, I hadn't even thought about it working on general Foldables.
18:40:22 <Javran> I guess bool is arranged in this way to make it look like church encoding
18:40:40 <jmcarthur> :t \p f xs -> filter p . map f . toList xs
18:40:41 <lambdabot>     Couldn't match expected type ‘a -> [a2]’
18:40:41 <lambdabot>                 with actual type ‘[Item l]’
18:40:41 <lambdabot>     Relevant bindings include
18:40:46 <_ryan> hi what does this error means? - Couldn't match type Maybe with ‘HandlerT App IO’
18:40:46 <jmcarthur> :t \p f xs -> filter p . map f . F.toList xs
18:40:47 <lambdabot>     Couldn't match expected type ‘a -> [a2]’ with actual type ‘[a3]’
18:40:47 <lambdabot>     Relevant bindings include
18:40:47 <lambdabot>       xs :: t a3 (bound at <interactive>:1:7)
18:40:50 <dfeuer> Javran, my understanding is that bool is the usual form of an eliminator, whereas foldr has its arguments backwards for that.
18:41:08 <jmcarthur> i won't try here more than twice
18:41:16 <KaneTW> _ryan: your types don't match
18:41:24 <jmcarthur> oh i see what i did
18:41:40 <Javran> > bool 1 2 True
18:41:41 <lambdabot>  2
18:41:43 <jmcarthur> :t \p f -> filter p . map f . F.toList
18:41:44 <lambdabot> Foldable t => (a -> Bool) -> (a1 -> a) -> t a1 -> [a]
18:41:51 <KaneTW> :t bool
18:41:52 <lambdabot> a -> a -> Bool -> a
18:41:59 <KaneTW> > bool 1 2 False
18:42:00 <lambdabot>  1
18:42:19 <KaneTW> :t ap
18:42:20 <_ryan> kaneTW: this error occur in my code - filename <- do; case file of ; Nothing -> Nothing
18:42:20 <lambdabot> Monad m => m (a -> b) -> m a -> m b
18:42:43 <KaneTW> _ryan: that tells me nothing without context
18:43:12 <_ryan> KaneTW - what context?
18:45:07 <_ryan> kaneTW: here is the code, http://lpaste.net/130727
18:46:23 <kadoban> _ryan: Is line 3 supposed to be so indented? That doesn't appear to make sense
18:46:24 <jmcarthur> dfeuer: flip (fmap.fmap) ((. toList) . map) . filter
18:46:41 <kadoban> _ryan: What Monad is this?
18:47:13 <dfeuer> jmcarthur, that's not nearly as mysterious.
18:47:37 <_ryan> kadoban: i update the code sorry.. its just the part of the code in my handler
18:47:59 <jmcarthur> dfeuer: i figured that point was either for us to figure out what yours does or reexpress it a little more nicely (in this case still in a point free style)
18:48:10 <jmcarthur> *the
18:48:35 <dfeuer> jmcarthur, what I was actually trying to do was figure out whether there was any way to do it point free without using flip.
18:48:39 <Gal3rielol> How to build a lock with MVar?
18:48:41 <dfeuer> I think the answer is probably no.
18:48:43 <jmcarthur> there's always the unnecessary fmap conversion
18:48:44 <jmcarthur> fmap (flip (fmap.fmap) (fmap (flip fmap toList) map)) filter
18:48:50 <_ryan> kadoban: i include also the error message
18:48:51 <jmcarthur> ah
18:49:01 <Gal3rielol> like the post http://neilmitchell.blogspot.ca/2012/06/flavours-of-mvar_04.html, but i don't quite understand the first example/
18:49:45 <dfeuer> jmcarthur, I imagine the fmap.fmap could also be written (.).(.) in this case?
18:50:33 <kadoban> _ryan: Sorry, I'm … not really sure what any of that stuff is still :-/  It seems that "Nothing" doesn't match at all the type of "writeToServer file" though, maybe that's it?
18:52:22 <jmcarthur> dfeuer: fmap ((. fmap (. toList) map) . fmap) filter
18:52:41 <dfeuer> jmcarthur, nice!
18:52:46 <dfeuer> jmcarthur++
18:52:49 <_ryan> kadoban: do you have any suggestion - i just want to check if the "file <- runInputPost $ iopt fileField "news_snopshot" is empty do return Nothing if is not empty writeToServer file
18:52:50 <jmcarthur> :D
18:52:57 <dfeuer> :t fmap ((. fmap (. toList) map) . fmap) filter
18:52:58 <lambdabot> IsList l => (b -> Bool) -> (Item l -> b) -> l -> [b]
18:53:16 <jmcarthur> :t fmap ((. fmap (. F.toList) map) . fmap) filter
18:53:17 <lambdabot> Foldable t => (b -> Bool) -> (a -> b) -> t a -> [b]
18:53:25 <dfeuer> Actually, I don't need that either... so it should be ....
18:53:41 <dfeuer> :t fmap ((. map) . fmap) filter
18:53:42 <lambdabot> (b -> Bool) -> (a -> b) -> [a] -> [b]
18:53:47 <dfeuer> um no.
18:54:05 <jmcarthur> i'm out! have fun
18:54:09 <dfeuer> OK!
18:54:17 <kadoban> _ryan: My suggestion would be to check the type of 'writeToServer file' and make your other case branch match that?   You can replace the Nothing line with:  Nothing -> _blah   on newer GHC and it'll tell you what type _blah is supposed to be, in the error message.
18:56:25 <_ryan> kadoban: it gives me this - Found hole _blah with type: HandlerT App IO FilePath
19:00:12 <kadoban> _ryan: Then that's the type you need. I don't know what HandlerT is, so I'm unsure what to tell you of how to fix that.
19:01:50 <_ryan> kadoban: thank you - another question can i ask about the runinputpost of yesod?
19:02:50 <kadoban> _ryan: You can ask, but I've never used yesod, so someone else will probably have to answer :)
19:03:17 <_ryan> kadoban: thank you for you'r help :)
19:03:38 <kadoban> 'welcome
19:08:30 <ffwacom> YOU MENA HASKELL???
19:09:59 <KaneTW> what was that?
19:10:59 <echo-area> Is it a custom to simplify type specs?  For example, in CallCC the type variable `m` stands for `ContT r m'` but the former is used instead of the latter
19:11:39 <KaneTW> is there a ghci or lambdabot command to list all typeclasses of a type
19:11:54 <KaneTW> or rather
19:12:02 <echo-area> KaneTW: Probably :info?
19:12:03 <HeladoDeBrownie> echo-area, can you illustrate what you're talking about?
19:12:31 <KaneTW> echo-area: right
19:13:51 <echo-area> HeladoDeBrownie: Take StateT's instance of liftCallCC for example.  It is declared as `CallCC m (a,s) (b,s) -> CallCC (StateT s m) a b`, but here `m` is in fact a type of `ContT r m'`.
19:14:59 <echo-area> I mean, rather than writing `CallCC (ContT r m) (a,s) (b,s) -> CallCC (StateT s (ContT r m)) a b`, a simplified version is written
19:15:03 <echo-area> Is it a custom?
19:15:19 <HeladoDeBrownie> echo-area, that doesn't sound right
19:15:30 <echo-area> Why?
19:15:41 <HeladoDeBrownie> why do you say that m is ContT r m'?
19:16:10 <echo-area> Otherwise liftCallCC cannot be applied
19:16:51 <HeladoDeBrownie> i think the CallCC type itself wraps up the "contness" you're thinking of. have you seen how it's defined?
19:17:17 <echo-area> Yes
19:18:52 <echo-area> It uses callCC in its definition, so m here has to be `ContT r m'`, right?
19:19:12 <HeladoDeBrownie> no. callCC is the name of its parameter.
19:19:15 <dfeuer> :t callCC
19:19:16 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
19:19:35 <HeladoDeBrownie> if the ContT callCC was in scope, that one is shadowed by the parameter; it isn't used.
19:19:56 * dfeuer never feels like he understands what's going on with these mtl things. transformers is so much simpler.
19:20:22 <HeladoDeBrownie> so yeah, it might be a little bit confusing but there is no ContT employed here whatsoever.
19:21:44 <echo-area> Hmm, I think ContT derives from the parameter, I must be missing something, let me check
19:22:01 <HeladoDeBrownie> you're not missing anything, you're just assuming callCC is defined outside the function; it isn't.
19:22:11 <HeladoDeBrownie> look at the parameter list; it's right there.
19:22:13 <echo-area> I don't assume that
19:22:29 <echo-area> I am well aware of the parameter
19:22:35 <HeladoDeBrownie> callCC :: CallCC m (a,s) (b,s)
19:22:50 <HeladoDeBrownie> (where m, a, b, and s are bound by the type of the function)
19:23:03 <HeladoDeBrownie> so you can choose any m you like
19:23:46 <_ryan> can anyone help me what does this error means? - Non-exhaustive patterns in case
19:24:14 <HeladoDeBrownie> _ryan, there is at least one input that is not covered by your case expression and will result in bottom.
19:25:08 <_ryan> the Just case?
19:25:19 <HeladoDeBrownie> _ryan, i don't know; i'd have to see the case expression.
19:25:29 <_ryan> i will paste it..
19:26:25 <_ryan> HeladoDeBrownie: here it is http://lpaste.net/130730
19:26:57 <arkeet> aughhh
19:27:02 <arkeet> why is Fractional a superclass of RealFrac
19:27:05 <HeladoDeBrownie> _ryan, i don't know the type of result, nor how it's defined, so i can't say.
19:27:40 <arkeet> it makes perfect sense to take the floor of stuff like
19:27:48 <arkeet> numbers of the form a + b*phi, where a and b are integers.
19:28:09 <arkeet> (also I don't know why Real is a superclass either.)
19:30:50 <_ryan> HeladoDeBrownie: what do you want see :-)
19:31:12 <HeladoDeBrownie> _ryan, knowing the type of runFormPost would probably suffice
19:31:43 <HeladoDeBrownie> _ryan, better yet, just tell me what package it's from
19:33:23 <echo-area> HeladoDeBrownie: I think you mean some other function can be defined within the type of CallCC and used in the place of callCC, and in that case m is not Cont r m', am I right?
19:33:49 <HeladoDeBrownie> echo-area, not at all. callCC is literally defined by whatever argument is passed to liftCallCC.
19:34:38 <_ryan> HeladoDeBrownie: i solve it.. thank you for the input i just need to add another case which is the "FormFailure _" thank you :)
19:34:57 <echo-area> Is there an example where the first argument passed is not callCC?
19:36:01 <HeladoDeBrownie> echo-area, i don't quite how this function is supposed to be used, but, for a silly example, const (return 'a') is a valid input.
19:37:05 <HeladoDeBrownie> +know
19:37:59 <echo-area> HeladoDeBrownie: Thanks, let me try it for a while
19:58:43 <_ryan> can anynone help me :-) i want create a function that accepts parameter but don't have any return value is it possible?
19:59:21 <dfeuer> _ryan, a function that doesn't have a return value never returns.
19:59:36 <dfeuer> But you can have a function with a boring return value
19:59:43 <HeladoDeBrownie> also, every function *must* have a return value, even if it's bottom
19:59:46 <dfeuer> The canonical boring return value is ().
20:00:06 <HeladoDeBrownie> so it would be best if you explained why you wanted something with no return value
20:00:59 <dfeuer> HeladoDeBrownie, that is a matter of language. A function of type  A->b, where b is not free in A, or a function of type  A -> Void, can reasonably be said not to have a return value.
20:01:05 <dfeuer> I think.
20:01:13 <HeladoDeBrownie> dfeuer, "even if it's bottom"
20:01:22 <Cale> "return value" is sort of funny language here
20:01:23 <dfeuer> Hrmmm....
20:01:26 <dfeuer> Yes.
20:01:45 <_ryan> i want to create a function to run some DB query only i have a case(the problem i ask before, now it's solve).
20:02:08 <_ryan> in every i will call the function and pass some parameters on it..
20:02:11 <geekosaur> so assuming some database monad DB, you probably want it to produce DB ()
20:02:20 <geekosaur> just as putStrLn produces IO ()
20:02:21 <HeladoDeBrownie> _ryan, that sounds suspiciously like an IO action, or a function outputting one. you can use IO () for "IO action with no useful result"
20:02:47 <dfeuer> Or you can use IO Void for "IO action that runs forever".
20:02:56 <Cale> Or just IO a
20:02:59 <dfeuer> Yes.
20:03:06 <_ryan> thank you :-) i will do this.. be back if i encounter some problem again.. thank you very much :-)
20:03:34 <dfeuer> Cale, the obvious advantage of IO a is that you don't need the Void.
20:03:36 <geekosaur> it has to produce *something*, else you have no way to thread it with other actions and make sure it happens in its correct order. the monad operation (>>) will ignore the useless () while maintaining the ordering of operations
20:03:51 <dfeuer> But the disadvantage is that you are then allowed to use it in contexts where you obviously shouldn't.
20:04:06 <HeladoDeBrownie> dfeuer, you get Void -> a for free anyway
20:04:58 <dfeuer> HeladoDeBrownie, what I mean is that it's likely better for   sinkhole >>= print   to give a type error than to happily run sinkhole forever and ignore the print.
20:05:55 <dfeuer> If sinkhole::Void, you get a type error, which I think is probably preferable.
20:05:56 <HeladoDeBrownie> dfeuer, i think with that example you'd get an error in either case. a is ambiguous, or no instance for Show Void.
20:05:58 <dfeuer> er.
20:06:04 <dfeuer> sinkhole::IO Void
20:06:28 <dfeuer> HeladoDeBrownie, okay, so that's a bad example, maybe, for trivial reasons. I think you can see my actual point.
20:06:39 <HeladoDeBrownie> dfeuer, i can't, can you give a better example?
20:06:43 <dfeuer> Sure.
20:06:48 <dfeuer> sinkhole >>= putStrLn
20:07:17 <dfeuer> It doesn't really make sense to do that, but if sinkhole::IO a, then that's allowed.
20:07:24 <HeladoDeBrownie> i see.
20:12:51 * hackagebot test-sandbox-hunit 0.1.1 - HUnit convenience functions for use with test-sandbox  http://hackage.haskell.org/package/test-sandbox-hunit-0.1.1 (junjihashimoto)
20:17:15 <Pamelloes> Is there a way to make a do statement where the first statement is based off of latter ones? For instance do { z <- x + y; x <- ...; y <- .....; return z }
20:17:50 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#recursive-do-notation ?
20:19:41 <_ryan> HeladoDeBrownie: is this correct? dbQuery :: Text title -> Text url -> Text snaphsot -> Text content -> Text metaTitle -> Text metaDescription -> Bool isSticky -> Int postion  -> Handler ()
20:20:27 <HeladoDeBrownie> _ryan, i don't know in what context you're asking, but i would say likely not. what is your intent?
20:21:34 <_ryan> HeladoDeBrownie: here is the code - http://lpaste.net/130732
20:21:54 <HeladoDeBrownie> _ryan, where did you get the idea to write that like that?
20:23:22 <Pamelloes> geekosaur: I'm trying to use do { rec {}} but I'm getting "parse error in pattern: rec possibly caused by a missing do" Does that mean my indentation is off since I have "do" at the end of the previous line?
20:24:50 <dfeuer> Is there anything between the arrays in primitive and full-on vectors? Specifically, I want vectors with *sizes*, but without the extra space required for *slices*.
20:24:52 <_ryan> HeladoDeBrownie: sorry i was confuse - i change it - dbQuery :: Text -> Text -> Text -> Text -> Text -> Text -> Bool -> Int  -> Handler ()
20:25:13 <HeladoDeBrownie> _ryan, that looks better. i still don't know in what context you're wondering whether it's correct though
20:25:31 <HeladoDeBrownie> _ryan, in short, what do you mean by "correct"?
20:25:38 <dfeuer> Er .. wait ... I just remembered why I rejected arrays of any kind for this application :-[
20:25:49 <dfeuer> But 
20:25:59 <dfeuer> that may have been a mistake......
20:26:11 <_ryan> HeladoDeBrownie: if my function was correct based on you given input before :-)
20:26:21 <geekosaur> Pamelloes, sorry, I don't know. I know RecursiveDo extension exists but haven't had a need for it muyself (and therfore haven't tried to figure out syntax details)
20:26:38 <Pamelloes> Alright, I'll see if I can get it to work
20:26:48 <HeladoDeBrownie> _ryan, i don't know anything about this library you're using, so i couldn't say
20:26:49 <geekosaur> if uyou can't get answers here, try in #ghc where you might find an implementor
20:27:40 <_ryan> HeladoDeBrownie: you said this before - " that sounds suspiciously like an IO action, or a function outputting one. you can use IO () for "IO action with no useful result" "
20:27:54 <HeladoDeBrownie> _ryan, as far as that suggestion goes, it looks fine
20:28:23 <_ryan> HeladoDeBrownie: thank you any suggesstion :-) to get it better?
20:29:25 <HeladoDeBrownie> _ryan, in this respect it's fine as it is, but you can also delete the "return ()" line and pass the whole do expression to Control.Functor.void, for the same result. void $ do …
20:29:33 <HeladoDeBrownie> Data.Functor.void *
20:29:49 <Ryanar> hey guys, question about whether this is considered fine or good form for Haskell coding:
20:30:03 <dfeuer> Or you can use   () <$ do ...
20:30:18 <Ryanar> f name date year = f' name date year
20:30:21 <dfeuer> <$ is sort of a more general version of void.
20:30:24 <Ryanar> f' n d y = ...
20:30:38 <dfeuer> Ryanar, nope.
20:30:44 <dfeuer> Just do  f = f'
20:30:50 <dfeuer> Or don't bother....
20:30:58 <Ryanar> dfeuer, ah ok
20:30:59 <Ryanar> well
20:31:03 <Ryanar> does that work if
20:31:09 <Ryanar> f' takes an extra parameter that doesnt exist in f
20:31:14 <dfeuer> Depends.
20:31:20 <Ryanar> like f name date year = f' name date year []
20:31:30 <dfeuer> Ah, that's another story.
20:31:53 <dfeuer> Ryanar, I would say if you *can* give an argument a meaningful name, then you probably *should*.
20:32:11 <Ryanar> but moreso what I was going after was, if when you pattern match in your helper function, is it ok to abbreviate since the names are clearly defined above
20:32:17 <Ryanar> so f' n d y [] = ...
20:32:24 <dfeuer> You'll often see situations where you can't really, without making the function look less general than it really is, in which case a meaningless name might be acceptable.
20:32:44 <_ryan> HeladoDeBrownie: it give me an error - The last statement in a 'do' block must be an expression
20:32:47 <dfeuer> :t Lens
20:32:48 <lambdabot> Lens s t a b -> ReifiedLens s t a b
20:32:54 <dfeuer> Buh.
20:32:57 <dfeuer> :i Lens
20:33:12 <HeladoDeBrownie> _ryan, you don't use newsId, you might as well not bind it
20:33:58 <slack1256> @info Lens
20:33:59 <lambdabot> Lens
20:34:01 <_ryan> thank you it works :)
20:34:08 <dfeuer> type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t      is what I was after, where none of the variables are meaningful.
20:34:13 <_ryan> HeladoDeBrownie: thank you it works :)
20:34:25 <Ryanar> was the 'stab' an unintended side effect?
20:34:25 <dfeuer> None of the names, that is, because there's no particular meaning behind any of them,
20:34:41 <Ryanar> oh
20:34:49 <dfeuer> Ryanar, I don't know. That is what some people feel like doing when they see that definition, however.
20:35:03 <Ryanar> gotcha
20:35:15 <Ryanar> thanks
20:35:43 <dfeuer> And yet, it's turned out to be the basic concept behind a whole programming paradigm.
20:38:39 <slack1256> Is there any program that included a haskell repl (possibly hugs) as an scripting language? In the vein of autocad and Lisp
20:39:35 <HeladoDeBrownie> slack1256, runhaskell can be used to run haskell as scripts
20:39:44 <HeladoDeBrownie> this comes with ghc among other things
20:39:57 <HeladoDeBrownie> #!/path/to/runhaskell
20:40:19 <HeladoDeBrownie> as far as repl goes, ghci
20:40:52 <slack1256> yes, but I was thinking of earlier attempts to include a haskell repl as underlying glue
20:41:02 <HeladoDeBrownie> "underlying glue"?
20:41:13 <slack1256> you know, as autocad.
20:41:20 <_ryan> another question :-) - is ther a function of haskell to get the first 20 char of a string?
20:41:21 <HeladoDeBrownie> oh, embedded.
20:41:33 <slack1256> yep
20:41:44 <HeladoDeBrownie> that's a good question. i don't personally know of any haskell embeddings.
20:41:59 <benzrf> _ryan: strings are just lists of chars
20:42:12 <benzrf> _ryan: you want a function that gets the first 20 elements of any list
20:42:14 <slack1256> _ryan: String are just list of Char. Can you get the first 20 elements of a list?
20:42:45 <Jeanne-Kamikaze> is there an x64 version of cabal-install for windows? I got the latest ghc+mingw for windows x64, and then cabal-install comes with its own mingw but that's 32 bit and I fear adding both in the path is going to cause issues
20:45:12 <_ryan> slack1256: is it possible?
20:45:57 <_ryan> benzrf: yes i want a function that gets the first 20 element from the list
20:46:06 <slack1256> @type take
20:46:07 <lambdabot> Int -> [a] -> [a]
20:46:12 <slack1256> _ryan: Play
20:46:21 <slack1256> > 2 + 2
20:46:22 <lambdabot>  4
20:51:01 <_ryan> 4
20:51:40 <slack1256> _ryan: On this channel if you put "> haskell-expression" it will evaluate it as in ghci
20:52:21 <_ryan> sorry first time :-)
20:52:36 <slack1256> _ryan: Don't worry
20:52:48 <_ryan> > "hellow" 20
20:52:49 <lambdabot>      Couldn't match expected type ‘Integer -> t’
20:52:49 <lambdabot>                  with actual type ‘[Char]’
20:52:49 <lambdabot>      The function ‘"hellow"’ is applied to one argument,
20:52:53 <_ryan> > "hellow" 2
20:52:55 <lambdabot>      Couldn't match expected type ‘Integer -> t’
20:52:55 <lambdabot>                  with actual type ‘[Char]’
20:52:55 <lambdabot>      The function ‘"hellow"’ is applied to one argument,
20:53:21 <slack1256> use the take function
20:53:28 <slack1256> @type take
20:53:29 <lambdabot> Int -> [a] -> [a]
20:53:38 <_ryan> > take "hellow" 2
20:53:39 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘[Char]’
20:53:39 <lambdabot>      In the first argument of ‘take’, namely ‘"hellow"’
20:53:39 <lambdabot>      In the expression: take "hellow" 2
20:53:46 <_ryan> > take 2 "hellow"
20:53:47 <lambdabot>  "he"
20:53:53 <_ryan> got it :-)
20:54:13 <slack1256> if you read the type signature, it tells you the order and roughly what it does
20:55:12 <HeladoDeBrownie> lists especially are one of those types where the type signature doesn't tell you so much. this one could just as easily be satisfied by "replicate each element in the original list n times"
20:55:40 <HeladoDeBrownie> although (a -> b) -> [a] -> [b] is "obvious"
20:55:52 <HeladoDeBrownie> (there's still more than one way to fulfill it though)
20:59:35 <dfeuer> Haaaaa!
20:59:37 <dfeuer> Silly me!
21:00:43 <dfeuer> I was trying to compare the performance of my new, not-yet-optimized, stable sequence sorting algorithm to the current one. I accidentally used something that's pretty close to the best-case-scenario for the current algo.
21:01:55 <infandum> I have a program which uses a library I wrote which uses parsec. 50% of the memory is allocated to the eoe function:
21:02:20 <infandum> eoe :: Parsec String u ()
21:02:21 <dfeuer> Endomorphisms on Eurocentrism?
21:02:34 <infandum> eoe = do; lookAhead (void $ char '>') <|> eof
21:02:38 <slack1256> infandum: use lpaste.net if your are gonna paste code
21:02:41 <infandum> is that crazy pig?
21:02:43 <infandum> big?
21:02:46 <dfeuer> What does do;  mean?
21:03:01 <slack1256> end of line basically
21:03:31 <dfeuer> > do; print 3
21:03:33 <lambdabot>  <IO ()>
21:03:41 <dfeuer> I'm surprised that's even legal.
21:03:58 <infandum> I don't use ;, I'm just doing it here to save space
21:04:15 <dfeuer> infandum, you don't need the do either.
21:04:16 <slack1256> is used on older haskell too. I recall there was somebody on the comitte that didn't like white space identing that much and used them
21:04:20 <infandum> yeah, just return
21:04:23 <infandum> but still
21:04:28 <dfeuer> No return either.
21:04:53 <dfeuer> Just   eoe = lookAhead (void $ char '>') <|> eof
21:04:58 <geekosaur> you are not uaing do notation at all, so you can leave it off entirely
21:04:59 <infandum> alright...
21:05:02 <dfeuer> And I don't think that should take much space....
21:05:10 <dfeuer> But I'm no parsing expert.
21:05:34 <infandum> Well I have x <- manyTill anyChar eoe
21:05:38 <slack1256> infandum: yes maybe it used 50% of memory, but how much memory was the maximum allocated?
21:06:01 <geekosaur> @undo  do; lookAhead (void $ char '>') <|> eof
21:06:01 <lambdabot> lookAhead (void $ char '>') <|> eof
21:06:03 <infandum> the total allocation?
21:06:06 <dfeuer> infandum, things like manyTill are much more likely to be interesting in this regard.
21:06:19 <infandum> 50,177,718,392 bytes
21:06:20 <dfeuer> Depending on context. But I'm not a parsing expert.
21:06:22 <slack1256> yep, it's on the output of the profiling
21:06:59 <dfeuer> Still, that's weird.
21:07:10 <dfeuer> infandum, are you using optimization?
21:07:18 <infandum> yes
21:07:21 <infandum> -O2
21:07:25 <dfeuer> If so, you can't really trust what the profiler says :-/
21:07:41 <slack1256> I though you can't even profile with optimization on
21:07:47 <slack1256> *thought
21:07:58 <dfeuer> Whereas if you turn off optimization, the profiler will give you honest results that don't reflect reality.
21:08:07 <dfeuer> It's a bit of a problem.
21:08:19 <infandum> oh
21:08:19 <slack1256> you can think of it as a lower bound
21:08:21 <infandum> ok
21:08:28 <solatis> reminds me of debugging race conditions using valgrind
21:08:33 <dfeuer> But if you turn off optimization, you *might* find the profiler's output more useful.
21:08:46 <solatis> which has a completely different thread scheduling mechanism than the kernel
21:09:05 <infandum> Running it without optimization
21:09:16 <infandum> It's part of a much larger program
21:09:24 <infandum> but that's where the profiling says 50% is hapenning
21:09:37 <infandum> and there's only one eoe
21:09:42 <dfeuer> Yeah ..... but with optimization .... I've seen the profiler say some really weird things.
21:09:43 <infandum> called from one spot
21:10:10 <infandum> Nope, even without optimization
21:10:13 <dfeuer> How big is this thing you're parsing?
21:10:13 <infandum> eoe takes up 50%
21:10:16 <infandum> alloc
21:10:16 <dfeuer> o.O
21:10:20 <infandum> uh
21:10:23 <infandum> 300 MB
21:10:26 <infandum> about
21:10:28 <infandum> wait
21:10:30 <infandum> no
21:10:38 <dfeuer> Yeah, sounds like you might need to ask someone who knows something about parsing.
21:10:46 <dfeuer> Email haskell-cafe?
21:10:48 <infandum> 12M
21:10:56 <infandum>  I made it smaller
21:10:58 <infandum> for testing
21:11:42 <infandum> 30000 lines of text
21:12:54 <dfeuer> infandum, can you lpaste the rest of the parsing code?
21:13:20 <dfeuer> I'm wondering if maybe it's running eoe a *lot* more times than it should.
21:13:54 <dfeuer> Like if you're accidentally running into some major backtracking.
21:14:35 <slack_> also the profiling output would be nice!
21:15:04 <dfeuer> Yes, the profiler will tell you, among other things, how many times that function runs.
21:15:28 <dfeuer> If it's running billions of times, you know that's why it's taking a lot of time and space.
21:15:52 <slack_> Well this looks like it's running once for each line
21:16:10 <slack_> 12 MB of text can't have billions of line (I hope)
21:16:47 <dfeuer> slack_, my #1 suspect is some unexpected backtracking making it read lots of the file many many times.
21:16:59 <slack_> yep!ç
21:17:04 <slack_> wait
21:17:10 <infandum> wait how do I find the number of times run
21:17:23 <dfeuer> infandum, it'll be called something like "entries" in the profiling report.
21:17:37 <infandum> uh
21:17:38 <dfeuer> Or maybe "entered" or something.
21:17:39 <infandum> 0 entries
21:17:41 <slack1256> but you should paste it on lpaste too
21:17:52 <slack1256> I mean the whole profiling output
21:19:20 * dfeuer sees that with more interesting test data, his sorting function is only twice as slow as the current one, and for certain uses, actually faster. This makes it worth the time to try to optimize it!
21:21:37 <infandum> here is the relevant part
21:21:40 <infandum> http://lpaste.net/3151737720104026112
21:23:05 <Axman6> looks like you're working on shootout code?
21:23:21 <dfeuer> infandum, what does "try" do? That looks dangerous. 
21:23:55 <dfeuer> Also, it seems a bit strange to have a filter like that in Parsec code. Is there a way you can use Parsec stuff instead?
21:24:09 <infandum> I'm pretty beginner at parsec
21:24:18 <slack1256> IIRC let you backtrack when a parser fails
21:24:31 <slack1256> *lets
21:24:45 <dfeuer> Also also, your variable names are as bad as mine.
21:25:05 <infandum> haha thanks
21:25:05 <dfeuer> Yeah, anything with backtracking can be a big problem. Is there a way to avoid that?
21:25:08 <Axman6> they seem fine to me
21:25:16 <slack1256> yeah no me too
21:25:24 <infandum> I mean it should just parse a fasta file
21:25:32 <infandum> so it needs a header and a sequence
21:25:35 <Axman6> fseq -> faste sequence, makes perfect sense in context
21:25:40 <Axman6> fasta*
21:25:54 <infandum> >header\nsequence>header\nsequence
21:25:56 <infandum> etc
21:26:16 <dfeuer> OK.....
21:26:19 <infandum> but there are other file types
21:26:28 <mjrosenb> whoops, I just made a program segfault.
21:26:34 <slack1256> dfeuer: backtracking isn't bad :-)
21:26:47 <dfeuer> slack1256, it's only bad when it happens.
21:26:47 <infandum> with >>bigheader\nbigsequence>header\nseq>head\nseq etc, so I needed to differentiate
21:26:54 <infandum> so I can use this
21:27:00 <dfeuer> So I don't know if it's actually bad here.
21:27:02 <infandum> it works, but the memory footprint is high apparently
21:27:14 <slack1256> how are you reading the 12MB file on the program?
21:27:19 <infandum> getContents
21:27:22 <infandum> uh
21:27:26 <dfeuer> I'm speculating, because, as I said, I am not a parsing expert at all.
21:27:48 <slack1256> because that could explain why eoe is the one being told that allocates
21:27:50 <infandum> yeah
21:27:54 * hackagebot bitcoin-script 0.11.0 - Compilation, manipulation and decompilation of Bitcoin scripts  http://hackage.haskell.org/package/bitcoin-script-0.11.0 (solatis)
21:27:57 <dfeuer> Reading a 12MB file with getContents should not billions and billions of bytes of allocation explain, does it?
21:28:07 <infandum> well
21:28:12 <infandum> this is the parsing part
21:28:19 <infandum> there are other parts of the program
21:28:21 <slack1256> well I though each Char was infact a Word32 IRCC
21:28:27 <infandum> but it goes directly from getContents to the parser
21:28:32 <infandum> and the 50% is in the parser
21:28:34 <infandum> so...
21:28:46 <dfeuer> slack1256, it is, yes, but that's not *that* bad.
21:28:48 <slack1256> yeah, but lazy IO make everything entangled
21:29:02 <slack1256> as in, not telling you where the real action happens
21:29:24 <infandum> that's the profiling's job, right?
21:29:57 <infandum> I always stink at memory usage with haskell
21:29:59 <infandum> it's a curse I have
21:30:10 <MP2E> dunno if profiling would help with lazy IO
21:30:18 <MP2E> but it does help when finding space leaks/performance issues
21:30:51 <infandum> I mean, it goes from a 12MB file to use over 4 gigs, so yeah I think it's an issue haha
21:31:03 <dfeuer> Anyone happen to have some vague guesses about where cutoffs should be for quicksort/quickselect? Below what threshold  size should I switch to some other algo (insertion sort?); when should I go from a single random element pivot to median of three?
21:32:02 <slack1256> dfeuer: https://en.wikipedia.org/wiki/Sorting_algorithm
21:32:18 <slack1256> Although the constants are implementation dependent
21:33:50 <slack1256> infandum: In the profiling, did you tell me the _Total_ allocation or the _maximum_ allocation
21:34:00 <infandum> the total
21:34:12 <slack1256> I want the maximum pls
21:34:16 <infandum> there is no maximum
21:34:34 <slack1256> can you paste on lpaste.net the whole profile?
21:34:44 <mjrosenb> is it possible to use a valueB in an expression of type IO ()?
21:35:07 <mjrosenb> valueB :: Behavior t a -> Moment t a
21:37:09 <infandum> http://lpaste.net/1258686787962798080
21:37:17 <infandum> It includes the other program
21:37:26 <infandum> but as you can see eoe is 50% alloc
21:37:54 * hackagebot json-rpc 0.2.1.4 - Fully-featured JSON-RPC 2.0 library  http://hackage.haskell.org/package/json-rpc-0.2.1.4 (XenoGenesis)
21:37:56 * hackagebot json-rpc 0.2.1.5 - Fully-featured JSON-RPC 2.0 library  http://hackage.haskell.org/package/json-rpc-0.2.1.5 (XenoGenesis)
21:39:43 <slack1256> What options are you using? Are you using the -s option?
21:39:52 <infandum> no
21:39:59 <slack1256> as in: ./test +RTS -s 
21:40:04 <infandum> oh
21:40:06 <infandum> no
21:40:08 <infandum> -p
21:40:13 <slack1256> also that
21:40:51 <infandum> ill try -s
21:40:57 <slack1256> yeah
21:41:02 <dfeuer> infandum, I'm not understanding how the heck eoe can be using 50% allocation when it's allegedly never entered.
21:41:11 <infandum> believe me
21:41:15 <infandum> im just as confused as you
21:41:18 <slack1256> dfeuer: it can be 50% of 1MB
21:41:43 <dfeuer> slack1256, but we ain't talkin' 'bout no 1MB.
21:41:46 <infandum> should I not ever use -p?
21:41:52 <slack1256> use it
21:41:52 <infandum> ah
21:42:08 <infandum> uh
21:42:11 <slack1256> dfeuer: we don't know, we only use have the _total_ allocation rate
21:42:26 <slack1256> even xmonad uses 2 GB total allocation rate
21:42:39 <slack1256> and it runs under 1MB on my machine
21:42:55 * hackagebot bitcoin-tx 0.11.0 - Utility functions for manipulating bitcoin transactions  http://hackage.haskell.org/package/bitcoin-tx-0.11.0 (solatis)
21:43:14 <dfeuer> slack1256, I do not understand how something can show 0 entries and yet show allocation.
21:43:22 <dfeuer> But that might be my own failure.
21:43:42 <dfeuer> I understand the difference between allocation and residency.
21:45:19 <infandum> at the top is -s stuff
21:45:20 <infandum> http://lpaste.net/1258686787962798080
21:45:52 <dfeuer> Youch.
21:45:56 <infandum> yeah
21:45:58 <infandum> exactly
21:46:03 <slack1256> Mmm it's still bad, (man I had hopes) :-(
21:46:07 <infandum> and this is only 30000 lines
21:46:16 <infandum> with small stuff it works great
21:46:22 <infandum> with 500MB files, not so much
21:46:44 <dfeuer> infandum, this is with -O0, right?
21:47:02 <infandum> no optimization at all
21:47:06 <infandum> WAIT
21:47:11 <dfeuer> And you used -fforce-recomp?
21:47:17 <infandum> no
21:47:19 <dfeuer> Or killed your .o?
21:47:23 <dfeuer> Oh, so ...
21:47:24 <dfeuer> ha.
21:47:26 <dfeuer> DO THAT.
21:47:27 <infandum> uh
21:47:29 <infandum> hold on
21:47:31 <slack1256> well he didn't change a thing
21:47:58 <dfeuer> Or use touch to update the timestamp on the .hs, for thatmatter, which is what I tend to do.
21:48:51 <hemite_> if objects in haskell are immutable how does Data.HashTable work?
21:48:55 * dfeuer doesn't know if that will actually get things anywhere, but thinks he'd have thought about it sooner if he weren't sleepy and also distracted by a movie and sorting implementation.
21:49:27 <Hijiri> hemite_: It's a tree
21:49:43 <slack1256> hashtables are an abstract data type
21:49:50 <slack1256> the implementation can be a tree for all we know
21:50:00 <hemite_> Hijiri, does that mean its not o(1) lookup and insert?
21:50:11 <Hijiri> I interpreted hemite_ as asking about the implementation
21:50:15 <dfeuer> Hijiri, that's wrong.
21:50:20 <Hijiri> oh
21:50:28 <dfeuer> Hijiri, you're thinking of HashMap.
21:50:36 <dfeuer> hemite_, Haskell *does* offer mutation.
21:50:42 <dfeuer> It just has to be confined to IO or ST.
21:50:54 <Hijiri> right, I was thinking of the wrong thing
21:50:59 <dfeuer> The hashtables package lets you make hash tables confined to either.
21:51:31 <hemite_> I see
21:51:44 <dfeuer> hemite_, have you ever played with ST?
21:51:46 <slack1256> Mmm the hashtables implements them on the ST monads, indeed
21:52:15 <infandum> slack1256 dfeuer: Even with -O0 for everything and -fforce-recomp it's the same
21:52:26 <hemite_> dfeuer, I'm not that far yet. But this is my second attempt at haskell
21:52:41 <hemite_> last attempt was 3 years ago, and I am getting further, which is encouraging 
21:53:14 <hemite_> I'm trying to find the Data.HashTable implementation, for reference 
21:53:14 <slack1256> hemite_: Alternatively, you can use Data.Map which works mostly equally without all the hashing
21:53:19 <dfeuer> hemite_, I would recommend waiting with all that stuff for a bit. It's not that it's super-hard or anything, but you're probably better off getting a hang of more functional-style stuff before digging into that weird stuff.
21:53:47 <dfeuer> hemite_, click on one of the hashtable modules, like https://hackage.haskell.org/package/hashtables-1.2.0.2/docs/Data-HashTable-ST-Basic.html and click on the "source" link at the top.
21:53:55 <hemite_> dfeuer, I feel relatively OK with all the functional stuff. I did learn ocaml along the way =)
21:54:09 <dfeuer> *nod*
21:54:10 <hemite_> slack1256, But then I wouldn't have o(1) insert/lookup 
21:54:59 <dfeuer> slack1256, Data.Map is kind of slow. Data.IntMap and Data.HashMap are much more practical.
21:55:19 <MP2E> Hmm
21:55:26 <slack1256> no it's not
21:55:27 <MP2E> guess I should migrate a program that uses Data.Map to HashMap then :)
21:55:30 <dfeuer> But if a hash table is what ye wants, that's what ye can use.
21:55:41 <slack1256> also, constants!
21:55:47 <dfeuer> MP2E, depends on what your keys are, and probably operations to some extent.
21:55:55 <dfeuer> But consider it.
21:56:00 <slack1256> There is a reason why not every structure on Containers isn't a patricia tree
21:56:17 <dfeuer> slack1256, parse error. Please try again.
21:57:17 <dfeuer> There's also a library of generic tries that should be quite good for some uses.
21:57:28 <dfeuer> ER ... many uses, I mean.
21:58:32 <infandum> Is my problem related to this? http://stackoverflow.com/questions/23706611/out-of-memory-using-attoparsec
21:58:41 <infandum> Is it because I'm nesting a manyTill in a many?
21:59:32 <slack1256> try to change it
21:59:50 <infandum> that's not trivial haha
21:59:57 <infandum> ill try some other day, I'm pretty tired
22:01:06 <slack1256> send a mail to haskell-cafe 
22:02:14 <infandum> I could just not use parsec...
22:02:16 <infandum> :D
22:03:00 <infandum> but then i'd go back to the normal parser I wrote which isn't very sophisticated
22:04:24 <dfeuer> regex-applicative is rather nice, and gives stringent time bounds. But it only works for regular languages and has a somewhat limited API.
22:05:58 <infandum> alright, well thanks for your help!
22:06:15 <infandum> im going to bed
22:14:12 <jascase901> Im writing a text based rpg as an exercise. I started out using records as the data structure for Stats and skills. But I am having trouble accessing indivdual skills. I was thinking about storing them as a hashmap instead. Is this less idiomatic though.
22:16:37 <kadoban> jascase901: What do you mean you were having trouble accessing them?
22:16:41 <jle`> jascase901: are you using record syntax?
22:18:20 <mjrosenb> gah, I can't seem to find a nice way to use Reactive.Banana to do two things.
22:19:19 <HeladoDeBrownie> jascase901, less idiomatic and probably inappropriate for what you're after. maps allow values to be absent altogether, which it sounds like you don't want.
22:19:58 <jascase901> jle`, kadoban I tried using the record syntax but it seems awkard. I want my function to take the name of a skill as an argument and be able to apply operations on that skill
22:21:05 <jle`> jascase901: why can't your function take an accessing function instead?
22:21:26 <HeladoDeBrownie> sounds halfway to lens
22:21:52 <jle`> you have a free accessing function with record syntax
22:22:05 <jle`> modifying functions are a bit more awkward
22:23:04 <jascase901> jle`, Ill try that. 
22:23:19 <jascase901> I didn't think of having it take a function as an argument
22:23:43 <dfeuer> I just had an idea, and I can't tell yet if it's brilliant or idiotic.
22:24:41 <jle`> jascase901: alternatively, you can have a data type that encodes what field you want to talk about
22:24:56 <jle`> data MyType = Field1 | Field2 | Field3 | Field4
22:25:02 <dfeuer> I think there's a good chance it won't work at all.... hmmmmmmmm.
22:25:06 <jle`> and then branch on that
22:25:19 <jle`> the benefit of this over a hashtable approach is that the compiler can ensure completeness
22:25:48 <dfeuer> But then ......... it might.
22:26:01 <jle`> also if you always notice that you do the same thing with certain labels you can also refactor for more general patterns
22:28:36 <dfeuer> jle`, what are the chances I can make Data.Sequence.partition really efficient? There's weirdness if the left/right side has to start climbing the right/left side.....
22:28:47 <dfeuer> That might be trouble.
22:30:43 <jle`> haven't worked enough with finger trees to be able to say conclusively
22:30:56 <dfeuer> Hmmmm.
22:32:21 <jascase901> jle`, the data type was kinda what I trying to do when I realized records were awkward.  http://pastie.org/10093193. But im not sure about how to  associate the skills with each character. 
22:34:24 <jascase901> I was thinking about a list of skillRanks because haskell loves lists. But that also seemed awkward because I don't want duplicate skills 
22:34:39 <HeladoDeBrownie> jascase901, Skill -> SkillLevel
22:34:48 <HeladoDeBrownie> functions are just total maps (approximately)
22:35:49 <jascase901> HeladoDeBrownie, would that be a record?
22:36:02 <HeladoDeBrownie> it'd be *in* a record, probably
22:36:23 <HeladoDeBrownie> i'm saying that each character can have associated with it a function mapping Skills onto how skilled that character is with that skill
22:36:59 <HeladoDeBrownie> though you could also have each skill as a separate field
22:37:59 * hackagebot glasso 0.1.0 - Graphical Lasso algorithm  http://hackage.haskell.org/package/glasso-0.1.0 (kaizhang)
22:38:16 <solatis> hmz, i'm in doubt about library design
22:38:59 <jle`> we've all been there :)
22:39:09 <solatis> i'm developing a library that needs some kind of context (which is, in this case, among others, a pool of Http connections and some configuration data)
22:39:20 <solatis> i'm thinking to use a callback for that
22:39:37 <solatis> so you have MyLib.withSession "config" "foo" (\session -> do ...)
22:39:56 <solatis> primarily because i see that pattern quite a lot
22:40:25 <solatis> but it could also be solved with a monadic approach
22:40:48 <solatis> but i feel that is just adding complexity and not really required here
22:41:48 <jle`> withSession is a nice basic approach that can be used as a primitive to build up more complex things/use cases easily
22:41:54 <jle`> i think that's why it's a common pattern
22:41:56 <HeladoDeBrownie> solatis, whenever you have continuation passing style like that it usually can be inverted somehow
22:42:08 <HeladoDeBrownie> and inverting is desireable because cps isn't that easy to compose
22:42:34 <HeladoDeBrownie> solatis, why not have a Session object that gets passed where it's needed?
22:42:48 <solatis> yes I was thinking about that, but I have resources i need to clean up
22:43:10 <solatis> with a callback, combined with bracket, that is quite easy
22:43:20 <jle`> i think the most common is to have a session object with an opener, and a closer.  and then offer an abstraction with the continuation form
22:43:39 <jle`> so the user can manually open and close if they want, or use your withSession if they wanted you to handle it for them
22:43:56 <solatis> right, so decouple the opening and closing of the session, and provie a "glue" withSession function that combines both
22:44:05 <solatis> sound fine by me
22:45:07 <solatis> what would the abstraction in the continuation form look like? is that a fancy way of describing a callback?
22:45:44 <solatis> so i can do withSession "user" "pass" (makeFoo . makeBar) ?
22:45:56 <jle`> yeah, by that, i meant your withsession thing
22:46:05 <solatis> right, gotcha
22:46:34 <jle`> i feel like if i give any real reasons i would only be trying to justify it afterwards...i've just seen this style used everywhere.
22:47:05 <jle`> but it *is* nice because you can use it to make your "monadic context" form, for example...or stream using pipes, or conduits
22:47:15 <solatis> yeah, that's why my first intuition was "do it like this, my library will be easier to understand"
22:47:28 <jle`> it's a nice primitive construct that your user can easily make work with pipes/conduits/etc.
22:47:35 <solatis> yes, got it
22:47:36 <jle`> becuase libraries like that were designed with interfaces like this in mind
22:47:48 <solatis> hmhm
22:48:01 <solatis> so there's a reason this is the status quo
22:48:03 <jle`> some libraries do offer the monadic context form as teh default way...but those tend to be like...huge things.
22:48:30 <solatis> http://hackage.haskell.org/package/zeromq4-haskell offers both
22:48:33 <jle`> like entire frameworks
22:48:46 <jle`> ah
22:49:11 <solatis> i think once you have the CPS-style, writing a monadic interface is easy
22:49:15 <jle`> i would bet that the session token version is used to implement the monadic one :)
22:49:20 <jle`> yeah, it's straightforward
22:49:29 <solatis> yeah exactly
22:49:30 <jle`> just a Reader with a restricted runReader
22:49:38 <jle`> *ReaderT
22:51:17 <solatis> http://hackage.haskell.org/package/zeromq4-haskell-0.6.3/docs/src/System-ZMQ4-Monadic.html#runZMQ
22:51:28 <solatis> (runReaderT (_unzmq z))
22:51:28 <solatis> :)
22:51:37 <jle`> :)
22:51:55 <_ryan> hi everyone can i ask something about yesod - does yesod has a put method?
22:52:06 <_ryan> hi everyone can i ask something about yesod - does yesod has a put method in a route?
22:52:29 <solatis> _ryan, let me look
22:52:33 <Axman6> @google Yesod put request
22:52:34 <lambdabot> http://www.yesodweb.com/book/restful-content
22:52:34 <lambdabot> Title: RESTful Content :: Yesod Web Framework Book- Version 1.4
22:52:41 <Axman6> (yes)
22:53:28 <solatis> _ryan, yes it does
22:53:33 <solatis> http://www.yesodweb.com/book/routing-and-handlers
22:54:10 <_ryan> thank you :-)
23:02:07 <pacak> I've noticed that memory usage never goes down when you compile sizeable project using ghc --make. It's the first time I've seen memory usage displayed as 0.01t in top...
23:05:33 <AshyIsMe> so installing haskell on ubuntu, what's the current best practise?
23:05:40 <AshyIsMe> apt-get apparently only has 7.6.3 still
23:06:59 <kadoban> AshyIsMe: I do this: https://gist.github.com/ion1/2815423   7.8.4 or 7.10.1, whichever you prefer.
23:07:04 <jle`> usually just installing the binary itself is preferred
23:07:08 <jle`> but there's also an ubuntu apk
23:07:14 <jle`> ppk
23:09:30 <kadoban> AshyIsMe: There's also the advice from the top of https://github.com/bitemyapp/learnhaskell if you prefer.
23:11:27 <AshyIsMe> ah cool that looks a bit nicer actually
