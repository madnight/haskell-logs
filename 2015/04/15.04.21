00:06:39 <Axman6> Is there a nice library which lifts a lot of the IO actions in Prelude into MonadIO?
00:08:05 * hackagebot notmuch-haskell 1.0.0.3 - Binding for notmuch MUA library  http://hackage.haskell.org/package/notmuch-haskell-1.0.0.3 (BartonMassey)
00:08:05 * hackagebot hexstring 0.11.1 - Fast and safe representation of a hex string  http://hackage.haskell.org/package/hexstring-0.11.1 (solatis)
00:10:19 <arkeet> Axman6: classy-prelude has a lot of that stuff.
00:10:59 <Axman6> hmm
00:11:04 <arkeet> but it also has a lot of other stuff.
00:11:10 <Axman6> I think a lot of what I need is actually a proper logging library
00:11:16 <arkeet> heh
00:11:30 <Axman6> too many putStrLn's
00:11:34 <arkeet> :)
00:11:43 <Axman6> (which made sense when originally written, but not any more)
00:11:48 <arkeet> https://hackage.haskell.org/packages/search?terms=logger
00:11:51 <arkeet> lots of stuff there
00:13:06 <Axman6> yeah I've looked at a lot of and haven't been happy with much
00:17:10 <Mirc-user> FH9 FREE HACKED PC GAMES http://tinyurl.com/l7ycbh9
00:26:39 <MagBo> I'll ask here as well — how do users of ghc-mod make maximum use of both ghc-mod and haskell-ng package infrastructure in nix package manager? You just expose cabal binary to ghc-mod user-wide?
00:29:06 --- mode: ChanServ set +o glguy
00:29:06 --- mode: glguy set +b *!*@2.237.171.7
00:29:06 --- kick: Mirc-user was kicked by glguy (spam is offtopic)
00:33:16 <quxbam> i'm beginning to learn arrows which are fine for expressing computations which could be run in parallel.  But how do i actually let something be calculated in parallel? For example:  ((*2) &&& (*3)) 4
00:34:51 --- mode: glguy set -o glguy
00:36:43 <quxbam> anybody?
00:36:59 <haasn> quxbam: For starters, you could equip your Arrow with special implementations of (&&&) and (***) that use `par` to run both sides simultaneously
00:37:14 <haasn> Perhaps
00:37:19 <kadoban> quxbam: I'm not sure that's actually a common use for Arrows. If it is, I have no idea how, and it … doesn't immediately sound like a good idea. Restricting parallelism to only 2 possible threads sounds dubiously useful. http://chimera.labs.oreilly.com/books/1230000000929/index.html is a good book about doing parallel and concurrent programs.
00:37:21 <haasn> I'm not sure how useful that would be, or if it's even legal
00:38:03 <haasn> kadoban: I think the benefit would be using arrow-do notation in order to express parallel computations
00:38:12 <shachaf> i,i use reflection to configure your Arrow instance's parallelism at runtime
00:38:25 <haasn> That's the thing I would be most fascinated by
00:39:02 <quxbam> i've read that book
00:39:12 <quxbam> i'm thinking the same as haasn
00:39:13 <haasn> kadoban: That said, it doesn't have to be limited to 2. You can repeatedly apply (&&&) or (***) to arbitrarily nested tuples in order to get any number of parallel threads. And for many applications, even 4 computations in parallel would be the most parallelism you can get out of a typical CPU either way
00:39:26 <quxbam> and when you compose arrows, you've got a lot more than 2 threads
00:39:38 <haasn> quxbam: I think composing arrows would be inherently sequential, actually
00:39:44 <haasn> The parallelism would come from (***) and (&&&)
00:40:01 <haasn> so if you have (f *** g) . (h *** j) you can compute (f . h) and (g . j) in parallel
00:40:03 <kadoban> Even if it worked, wouldnt the degree to which you compute in a parallel fashion be deeply and annoyingly embedded in the logic of the algorithm itself?
00:40:06 <haasn> but each of those operations is “sequential”
00:40:12 <jle`> Arrows doesn't work with this
00:40:14 <jle`> because of arr
00:40:41 <quxbam> kadoban: that's allways the case
00:40:51 <haasn> quxbam: I think you should give it a try
00:41:33 <jle`> i've made some attempts on using &&& and *** to give implicit parallelism and for the most parts it's worked actually.  you just have to be really disciplied because there's nothing about arrow laws that will stop you from screwing things up
00:41:41 <quxbam> and will it work as well with the proc notation? It dosen't desugare to (***) etc. Would i have to rebind first?
00:41:42 <jle`> and if you screw things up it's pretty hard to enforce in types
00:41:54 <jle`> no, it won't work wiht proc notation because proc notation doens't use *** and &&&
00:41:57 <jle`> it uses arr swap and arr first
00:41:58 <haasn> newtype ParA a b = ParA (a -> b);  arr = ParA; but have f *** g = ParA $ \(x,y) -> let (x',y') = (f x, f y) in x' `par` y' `par` (x', y')
00:42:13 <haasn> jle`: ah, okay
00:42:21 <haasn> jle`: That seems like the biggest reason for why this won't work
00:42:35 <quxbam> but i could rebind arr first, or?
00:42:47 <jle`> sorry, i meant `first
00:42:50 <jle`> arr swap is the real killer here
00:42:54 <haasn> jle`: so to fix that underlying problem would amount to making the do arrow desugaring insert more `par` ?
00:43:00 <haasn> Or maybe just inserting the `par` in your code yourself
00:43:04 <haasn> Which doesn't gain you anything
00:43:19 <jle`> what you might write as (f *** g) becomes rewriten as arr swap . first g . arr swap . first f
00:43:25 <haasn> I thought the desugaring for this used (***) and (&&&)
00:43:52 <jle`> i documented my failed attempt at making this nice last year v.v
00:43:53 <jle`> http://blog.jle.im/entry/a-dead-end-arrowized-dataflow-parallelism-interface-attempt
00:43:54 <haasn> But yeah, you're right that there would be zero guarantees about this sort of arrow *actually* calculating anything in paralle. Then again, I think the same is true for `par`
00:44:17 <haasn> Since there's no way to decide inside Haskell whether or not something was computed in parallel or not
00:44:23 <haasn> (without using IO)
00:44:39 <haasn> There are no guarantees that `par` can, or has to make
00:45:15 <haasn> Then again, you also can't decide between () and _|_ inside Haskell either
00:45:28 <haasn> Well, you can semi-decide I guess. You can confirm that something is not _|_, but you can't confirm that something is _|_
00:45:35 <jle`> you can do reflection to refactor your proc blocs to be parallel, maybe, but i think arrow gives you enough tools to ruin any sort of reconfiguration scheme
00:45:42 <haasn> That's a useful distinction from the parallelism thing
00:45:52 <haasn> Because for parallel computations, you can't prove nor disprove that they were run in parallel
00:45:56 <haasn> nor can you prove nor disprove that they were not
00:47:39 <quxbam> you're blogpost is quite good
00:48:18 <jle`> ty :) looking at it now it's actaully unfortunately verbose for the short point it was trying to make.  i think that's a problem of mine ...
00:50:12 <quxbam> i think that is good for someone who tries to learn and understand
00:50:22 <quxbam> short is good as a memo
00:56:20 <quxbam> perhaps we could file a feature-request
00:56:36 <quxbam> parallelism with arrows looks very promising
00:59:25 <CapitalSigma> stupid question: how can i avoid writing the lambda in "x >>= \y -> f g (h y)"? i would have thought "x >>= f g $ h" but that has the wrong type
01:00:10 <timothyh> @pl \x -> return x
01:00:10 <lambdabot> return
01:00:33 <timothyh> @pl \y -> f g (h y)
01:00:33 <lambdabot> f g . h
01:00:40 <frerich> CapitalSigma: You want '.' instead of '$'
01:01:40 <CapitalSigma> frerich: thanks
01:33:18 * hackagebot json-stream 0.3.0.0 - Incremental applicative JSON parser  http://hackage.haskell.org/package/json-stream-0.3.0.0 (ondrap)
01:34:15 <lpaste> yasar11732 pasted “L system equations” at http://lpaste.net/131114
01:34:46 <yasar11732> I created myself a haskell exercise but It doesn't compile : http://lpaste.net/131114
01:35:04 <yasar11732> it says parse error in pattern getrule
01:41:37 <kqr> yasar11732, it reads line 27 as "getRule ch (rulekey, rulevalue) : rest"
01:41:42 <kqr> yasar11732, do you see the problem with that/
01:43:30 <yasar11732> I was trying to pattern match on list of tuples
01:43:35 <yasar11732> doesn't it work like that?
01:43:54 <kqr> yasar11732, that pattern matches on four arguments
01:44:09 <kqr> yasar11732, arg1 is ch, arg2 is (rulekey, rulevalue), arg3 is :, arg4 is rest
01:44:27 <kqr> yasar11732, you need parentheses to tell haskell that the last three things should be treated as a single argument
01:44:35 <yasar11732> ohh
01:44:36 <yasar11732> ok
01:53:19 * hackagebot json-stream 0.3.0.1 - Incremental applicative JSON parser  http://hackage.haskell.org/package/json-stream-0.3.0.1 (ondrap)
01:57:26 <amaru> Hi! Why are the type level functions + * ^ on type literals defined as type families and not data families? Am i correct in thinking that if they were data families, there could be an instance like (KnownNat a, KnownNat b) => KnowNat (a+b)?
01:58:52 <tulcod> amaru: not sure what data families have to do with anything here...
01:59:28 <yasar11732> Ok, this works: http://lpaste.net/131116 Does it look like a normal?
01:59:45 <yasar11732> * like a normal haskell program *
02:00:09 <Profpatsch> Does anyone know how I can get the day-part of a DiffTime?
02:00:25 <Profpatsch> I mean the seconds from midnight.
02:00:45 <tulcod> yasar11732: yeah it's alright
02:01:26 <Profpatsch> I find it fascinating, that only UTCTime has a function for that.
02:01:44 <Profpatsch> Or am I missing something obvious Class-related?
02:02:49 <Profpatsch> Or can I cast a DiffTime to UTCTime and then use utcDayTime?
02:03:20 * hackagebot ClustalParser 1.0.3 - Libary for parsing Clustal tools output  http://hackage.haskell.org/package/ClustalParser-1.0.3 (FlorianEggenhofer)
02:03:44 <Hijiri> does it make sense for a delta like DiffTime to have a day part
02:05:44 <tulcod> Profpatsch: a UTCTime is an absolute point in time. this year, this date, this hour, this minute, this second.... DiffTime is a difference between two points in time, and it doesn't /quite/ make sense to say that there is a certain of number of days in between
02:06:03 <Profpatsch> tulcod: So I probably use the wrong type.
02:06:08 <tulcod> Profpatsch: for example, what's the difference between December 31 23:59 and January 1 00:01 next year?
02:06:12 <jle`> yasar11732: it's good :) you can always also use `concatMap (\ch -> getRule ch rules) axiom` too if you fancied
02:06:21 <tulcod> is there a day in between? well surely, because the date changed. but it's only 2 minutes later.
02:06:57 <Profpatsch> tulcod: I get two values from Network.Pcap, time from epoch in seconds and a value for microseconds.
02:07:12 <ibid> tulcod: isn't it fairly common to define day in datetime difference as 24 hours?
02:07:32 <ibid> (though, of course, in some other contexts it would be calendar days.  yes, i see.)
02:07:37 <tulcod> ibid: it's not so simple. some days are not 24 hours long
02:08:38 <Profpatsch> tulcod: So I should probably add those up to a double, cast to POSIXTime and then to UTCTime.
02:08:49 <Profpatsch> Then I can get the time of day.
02:08:56 <tulcod> Profpatsch: i don't know what you want to do 
02:09:12 <tulcod> but time&date is much more complicated than you'd expect
02:09:15 <tulcod> so be careful
02:09:31 <tulcod> for example, what are you going to do around DST?
02:09:33 <Profpatsch> tulcod: I’ve got this: https://hackage.haskell.org/package/pcap-0.4.5.2/docs/Network-Pcap.html#t:PktHdr
02:09:38 <xelxebar_> geekosaur, srhb: I seems like the script is working now: http://ix.io/i1O/haskell. I hacked together a C version and realized that the write buffer wasn't getting flushed until several iterations of cat had already run.
02:10:14 <Profpatsch> tulcod: And another value from inside the Network Packet, given as 8 bytes with the semantics HHMMSSuu.
02:10:27 <Profpatsch> And I need to compare both.
02:10:40 <lpaste> yasar11732 pasted “concatmap” at http://lpaste.net/131118
02:10:47 <tulcod> then you better make sure you understand the details of the semantics
02:10:48 <xelxebar_> geekosaur, srhb: thanks for your help. if you notice me doing anything Bad(TM), please let me know. still a noob here
02:11:04 <tulcod> Profpatsch: e.g. what happens around leap seconds?
02:11:16 <yasar11732> jle`: like this: http://lpaste.net/131118 ?
02:11:40 <Profpatsch> tulcod: Since it’s only the part from midnight I’m fairly sure it’s given as UTC seconds from midnight.
02:12:22 <amaru> tulcod: As it stands now, + is  defined as type family m + n :: Nat. Which means that (m + n) can't have any instance declarations. It's just some type. 
02:12:57 <tulcod> amaru: you can only add numbers of equal type, is that what you're trying to say?
02:13:10 <jle`> yasar11732: yeah, either works... like concatMap (flip getRule rules) axiom, too.  but the list comprehension version is just fine too :)
02:13:20 * hackagebot clock 0.4.5.0 - High-resolution clock functions: monotonic, realtime, cputime.  http://hackage.haskell.org/package/clock-0.4.5.0 (CetinSert)
02:13:21 <jle`> it's just doing the mapping and teh concatting in one step
02:13:24 <jle`> instead of in two steps
02:14:04 <jle`> actually...you can do both list a list comp too.  [ r | ch <- axiom, r <- getRule ch rules ].  but i think concatMap is a little clearer
02:14:05 <amaru> tulcod: it gets kinda annoying, as you have to add loads of contexts to your constraint: e.g. (KnownNat a, KnownNat a*b, KnownNat (1+a*b), KnownNat (a+2)) => ...
02:14:33 <amaru> where, you'd think KnownNat a, KnownNat b would've sufficed. 
02:14:42 <tulcod> amaru: i don't know what KnownNat is
02:14:59 <tulcod> ah nvm
02:15:53 <amaru> tulcod: ah, ok :) It's a typeclass for type level naturals https://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-TypeLits.html
02:16:42 <tulcod> amaru: sorry yes, i don't know anything about this class. sorry for wasting your time :)
02:17:32 <amaru> tulcod: hehe, no problem :)
02:23:22 <TimTravel> I just upgraded Haskell on my arch linux install and one of my packages doesn't build anymore. I get the following error message: http://lpaste.net/131120
02:23:32 <TimTravel> I think I have the wrong version of a few things in my dependencies but I don't know what's wrong. Did Int64 used to be compatible with Int at some point and then stop?
02:24:43 <kqr> TimTravel, no, they are different types and not compatible unless one is explicitly converted to the other
02:25:28 <TimTravel> That's what I thought. Hmm.
02:26:14 <Profpatsch> TimTravel: They probably changed from Int to GHC.Int64 in the library API.
02:26:51 <Profpatsch> But that looks to me like either you are using internals or they made a mistake.
02:27:08 <kqr> TimTravel, it appears as though System.Clock changed to Int64
02:27:46 <kqr> TimTravel, in version 4.2
02:27:59 <Profpatsch> Int can be 32bit on some systems, right?
02:28:20 <kqr> TimTravel, so freeze the clock package at <0.4.2 and you should be fine
02:28:27 <Profpatsch> Then that would make sense to get the wanted precision.
02:28:46 <Profpatsch> kqr: He could update the code. :)
02:28:58 <kqr> Profpatsch, that sounds way too reasonable
02:29:14 <Profpatsch> ikr
02:30:05 <kqr> oh
02:30:18 <kqr> newest version of http-client has removed the code that doesn't work with newest system.lcock
02:30:20 <kqr> clock*
02:30:23 <kqr> but for other reasons, apparently
02:30:32 <kqr> so just upgrading to the newest http-client would solve the problem too
02:31:26 <lpaste> Geraldus pasted “Yesod Core internal server errors” at http://lpaste.net/131121
02:31:42 <Geraldus> Hi folks! I'm facing strange issue with Yesod. My project could be successfully built, and I'm able to run devel server. However, when I hit any app route from browser I see «Internal server error», yesod devel reports me, that this errors comes from yesod-core itself: http://lpaste.net/131121. 
02:32:16 <yasar11732> let say I have a string like "X adfcs", how can I get ('X', "adcfs"). We can assume string starts with a single chracter followed by a space 
02:32:47 <Geraldus> I tended to manually debug my app step by step, but REPL does not want to help me: first I'm adding Home handler (interpreting it): `:add *Handler.Home`
02:33:21 * hackagebot dimensional 0.13.0.2 - Statically checked physical dimensions.  http://hackage.haskell.org/package/dimensional-0.13.0.2 (BjornBuckwalter)
02:33:33 <Geraldus> But when I try to set break point after that `:break Handler.Home 53` REPL says: module 'Handler.Home' is not interpreted; try ':add *Handler.Home' first
02:34:28 <Geraldus> am I missing something?
02:35:40 <halvorg> anyone used smtp-mail? it hangs indefinitely on a sendEmailWithLogin call.
02:36:10 <Geraldus> halvorg: I use network-mail-mime
02:36:26 <halvorg> ill try that, thanks
02:37:02 <Geraldus> halvorg: sorry, correct package name is `mime-mail`
02:38:21 * hackagebot dimensional-tf 0.3.0.2 - Statically checked physical dimensions, implemented  using type families.  http://hackage.haskell.org/package/dimensional-tf-0.3.0.2 (BjornBuckwalter)
02:39:59 <halvorg> Geraldus: hm, how do I add login/password? sendmailCustom with some extra parameters?
02:40:48 <Profpatsch> yasar11732: Take a look at span https://hackage.haskell.org/package/base-4.8.0.0/docs/Prelude.html#v:span
02:41:14 <Profpatsch> span (== ' ') s
02:41:16 <Geraldus> halvorg: oh, excuse me, it turns I answered too early. Let me ask now: what do you want to do? I use mime-mail to send emails from my VPS server to clients
02:41:36 <halvorg> I want to send an email using SMTP
02:42:13 <halvorg> (to a mailgun server, which sends it onwards)
02:44:01 <Geraldus> halvorg: mime-mail allow you to send emails from your host using sendmail program, you can specify `From` header to set sender email address
02:44:25 <Geraldus> So, I turns that mime-mail will not help you
02:44:59 <halvorg> Okay, thanks for your time anyways : )
02:45:21 <TimTravel> Profpatsch, kqr: upgrading http-client worked perfectly. I messaged the developer. Thank you very much!
02:45:42 <Profpatsch> TimTravel: Cool.
02:46:30 <Profpatsch> yasar11732: You probably want to split at any word boundary, so probably the function “words” is what you want.
02:49:00 <lpaste> yasar11732 pasted “No title” at http://lpaste.net/131122
02:49:32 <yasar11732> I did this, but I guess it is kind of ugly: http://lpaste.net/131122
02:49:50 <yasar11732> I was trying to read a L-System from a file
02:50:37 <Profpatsch> yasar11732: Ah, you mean exactly the second character must be a space.
02:51:00 <Profpatsch> In that case you should probably use a parser.
02:51:45 <Profpatsch> yasar11732: You should never throw errors, since it makes your functions partial.
02:51:53 <Profpatsch> aka your program can crash.
02:52:55 <yasar11732> I couldnt figure out what to do, so I just crashed :D
02:53:28 <yasar11732> should I return a Maybe String instead?
02:54:08 <yasar11732> I mean Maybe (Char, String)
02:54:54 <Profpatsch> yasar11732: Yes, or Either ErrorMsg (Char, String)
02:57:55 <Profpatsch> yasar11732: Then after mapping you have a list of [Left …, Right …, Left, Left, …]
02:59:19 <Profpatsch> So you can choose what to do. If you just need the good values you can use “rights”, if you want to crash anyway you can e.g. accumulate the errors and crash with all of them.
03:00:04 <yasar11732> Ok, so far I did this: http://lpaste.net/131123
03:00:23 <lf94> Are there system calls available in Haskell?
03:00:34 <lf94> Such as fork(), pipe(), etc
03:01:09 <yasar11732> Now I am trying to figure out what should readLSystem return, should it return "IO Maybe LSystem" ?
03:01:40 <Profpatsch> yasar11732: Yes, that looks quite elegant.
03:02:04 <Profpatsch> yasar11732: Depends on where in your program you want to handle errors.
03:02:12 <kqr> lf94, yes and no
03:02:18 <lf94> I'm particularly interested in freopen
03:02:48 <lf94> kqr: please explain? :)
03:03:01 <yasar11732> I actually want to skip bad input lines, but if there are no lines or file doesnt exist I want to return Nothing
03:03:07 <lf94> kqr: I'd like to create some utilities that utilize those
03:03:15 <yasar11732> can I do that?
03:03:20 <kqr> lf94, there are several layers to the answer, and the question is probably broader than you think
03:03:20 <Profpatsch> yasar11732: Of course.
03:03:37 <kqr> lf94, in the absolute worst case, haskell can call C code, so you could write C functions that use them and call them from haskell
03:04:13 <kqr> lf94, haskell does have easy-to-use high-level functions for forking off a separate thread, and piping output from one process to another
03:04:16 <Profpatsch> yasar11732: It seems to be a normal use case, since there is a listToMaybe function https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Maybe.html#v:listToMaybe
03:04:27 <kqr> lf94, as for freopen, I don't know enough about what you use it for to understand the problem
03:04:41 <yasar11732> For example, let "ax:rules = lines contents" would crash if file didnt exist right?
03:05:16 <Profpatsch> yasar11732: listToMaybe . catMaybes $ map splitRule rules
03:06:23 <Profpatsch> yasar11732: first maps to a [Maybe Rule], then throws out all Nothings, then check whether the list is emtyp.
03:06:27 <Profpatsch> *empty
03:06:35 <kqr> Profpatsch, asum = listToMaybe . catMaybes
03:07:08 <Profpatsch> Apparently, There Is An Instance For That™
03:08:15 <Profpatsch> kqr: Data.Foldable is still uncharted territory for me. ;)
03:08:26 <m4ple> hello everyone. I'm having some issues with Aeson (still). I'm trying to parse a field that might be either a single string, or an array of strings. Here is the code I'm using: a little help, please? http://lpaste.net/131125
03:08:57 <Profpatsch> It’s quite a step from using plain functions to using the power of typeclasses & their instances.
03:10:06 <m4ple> I should add that decoding to a simple AuthorInfo works, although of course it's only half of the problem as I want AuthorInfo to be a field in a larger structure
03:12:50 <Profpatsch> kqr: So Maybe is short-circuiting to Nothing in Monads and discarding Nothings in Foldables?
03:12:54 <Profpatsch> instance Foldable Maybe where
03:12:56 <Profpatsch>     foldr _ z Nothing = z
03:13:19 <kqr> Profpatsch, I think it's more natural to think of asum in terms of Alternative
03:13:27 <kqr> Profpatsch, Nothing <|> Nothing = Nothing
03:13:36 <kqr> Profpatsch, Just 42 <|> Nothing = Just 42
03:13:44 <kqr> Profpatsch, Nothing <|> Just 42 = Just 42
03:13:56 <kqr> Profpatsch, Just 42 <|> Just 57 = Just 42
03:14:06 <kqr> Profpatsch, and asum is just running through the list and applying <|> between each element
03:15:45 <yasar11732> Profpatsch listToMaybe only returns the first element from the list
03:15:46 <Profpatsch> kqr: But wouldn’t that discard everything but the first Just?
03:16:03 <kqr> Profpatsch, yes
03:16:04 <Profpatsch> Ah, okay. I see.
03:16:07 <kqr> Profpatsch, like listToMaybe
03:16:22 <Profpatsch> yasar11732: Then it’s mapMaybe of course.
03:16:22 <kqr> Profpatsch, in the case of your code
03:18:23 * hackagebot halma 0.2.0.0 - Library implementing Halma rules  http://hackage.haskell.org/package/halma-0.2.0.0 (TimBaumann)
03:19:09 <lf94> What does -- do in Haskell?
03:19:20 <selveskii> comments
03:19:59 <Profpatsch> yasar11732: Sorry, I’m still wrong.
03:20:21 <kaidelong> (caveat; -- can be part of an operator like -->)
03:21:18 <yasar11732> So far, I did this: http://lpaste.net/131128
03:21:28 <selveskii> I am building Haskell Platform 2015 by myself. I now face a problem of documentation index. The master index file includes links to, instead of some absolute paths to specific modules, a relative HTML file like “Control-Monad.html”. What should I do to resolve this?
03:22:01 <selveskii> On HP 2014, it is something like "/Library/Haskell/xxxx/base/xxxx/Control-Monad.html"
03:22:50 <Profpatsch> yasar11732: mapMaybe = catMaybes . map
03:23:24 <yasar11732> ohh
03:23:28 <yasar11732> that is better
03:23:58 <Profpatsch> I’d advise changing Rules to Rule = (Char, String)
03:24:43 <Profpatsch> Normally putting those in singular form gives better reusability.
03:26:44 <yasar11732> ok, so far it works. Now I want to return Nothing from readLSystem if file doesnt exist
03:27:04 <yasar11732> how do I check it though?
03:27:20 <Profpatsch> yasar11732: there is “null”, which checks for empty list.
03:27:42 <kqr> yasar11732, why isn't it good enough to return the empty list?
03:27:54 <Profpatsch> But yeah, that.
03:29:15 <kqr> yasar11732, or ah you want to differentiate between "file doesn't exist" (Nothing) and "no valid lines in file" (Just [])?
03:29:16 <kqr> that is reasonable
03:29:26 <kqr> though it should probably have a data type by then
03:33:23 * hackagebot hlint 1.9.20 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9.20 (NeilMitchell)
03:38:02 <seanparsons> Has an empty record update become invalid since 7.6.X? I'm thinking of something like defaultMyRecord{}.
03:38:55 <shachaf> I don't think it's ever been valid.
03:46:45 <lf94> What does @ do in Haskell
03:47:14 <seanparsons> shachaf: Odd, I'm sure I've built something that has code using that and it hasn't complained, but rolling back another project to 7.6.3 and it fails just like 7.8.4.
03:47:27 <capisce> lf94: alias?
03:47:45 <seanparsons> Helpfully it's generated code, so this is going to be all kinds of fun.
03:47:55 <capisce> lf94: https://www.haskell.org/tutorial/patterns.html
03:48:01 <shachaf> Maybe you're thinking of matching: f Foo{} = ...
03:48:12 <dredozubov> if94: alias@of_this in pattern matching expressions
03:48:14 <capisce> lf94: it's called "as-pattern"
03:51:52 <hvr> there's probably a joke in there about ass-patterns
03:52:55 <hvr> or about "lazy ass patterns"?
03:54:20 <Flonk> Imagine if Haskell had a PHP-style @ operator. It would turn `Right x` into `Left undefined` and let the whole program go haywire without you noticing because you never get any error messages. In the end you see '1' in your terminal and wonder what went wrong.
03:56:58 <dredozubov> hvr: can i OH you on twitter? :)
03:57:54 <hvr> dredozubov: sure...
03:58:25 * hvr as a twitter-non-user had to lookup what OH even means...
03:58:43 <dredozubov> hvr: i googled it a week ago and now i'm infected
03:58:44 <dredozubov> :((
03:58:45 <capisce> overhear?
03:58:51 <osfameron> as a twitter-user, I'd have to look it up too...
03:58:58 <capisce> can I eavesdrop on your conversations on Twitter?
03:59:24 <hvr> seems it's an old term... it's already mentioned in 2008: http://www.brentozar.com/archive/2008/08/twitter-101/
03:59:25 <capisce> ah, quote
03:59:27 <keko-2> overhead?
03:59:27 <dredozubov> i honestly thought i was slow when i had to look it up
03:59:39 <osfameron> ok, overheard... but how's that used as a verb?
03:59:42 <dredozubov> capisce: quote something overheard
03:59:56 <capisce> usually people don't ask to post OH quotes :)
04:00:04 <capisce> though they're typically from real life, not from IRC
04:00:21 <dredozubov> capisce: i was asked once, so maybe it's etiquette, dunno
04:00:30 <dredozubov> i want to be a cool kid
04:01:05 * hvr imagines asking a total stranger whether I may "OH" something 
04:01:15 <hvr> IRL, obviously
04:01:42 <hvr> I don't think that would go well :)
04:01:57 <dredozubov> hvr: i shrug when i hear something like LOL in real-life
04:08:22 <kqr> dredozubov, i'm guessing you shiver, and not shrug
04:08:44 <dredozubov> maybe, but i'm definitely feeling funny
04:10:27 <yasar11732> what should I import for `catch` error handler?
04:11:03 <yasar11732> hoggle says it is prelude but ghci says not in scope `catch`
04:12:38 <lpaste> yasar11732 pasted “No title” at http://lpaste.net/131130
04:12:56 <yasar11732> that is my code
04:13:02 <dredozubov> yasar11732: Control.Exception
04:13:47 <kqr> is there any tutorial for exceptions in haskell? back when I last used them, people said "no just don't use them they're a nuisance" but now people seem to recommend to use them?
04:14:20 <dredozubov> yasar11732: IO Either Maybe LSystem doesn't seem well-typed to me :)
04:14:41 <yasar11732> ohh, I forgot to remove either :)
04:14:49 <dredozubov> and \_ -> return Nothing is const Nothing
04:16:41 <kqr> dredozubov, no its not
04:16:52 <kqr> dredozubov, const (return Nothing) if anything
04:17:38 <dredozubov> yeah, sorry
04:17:43 <dredozubov> missed the return
04:17:54 <lpaste> yasar11732 pasted “No title” at http://lpaste.net/131131
04:18:17 <yasar11732> what am I doing wrong in above code?
04:18:25 * hackagebot snap-blaze 0.2.1.3 - blaze-html integration for Snap  http://hackage.haskell.org/package/snap-blaze-0.2.1.3 (JasperVanDerJeugt)
04:18:31 <kqr> yasar11732, readFile returns IO String
04:18:43 <kqr> yasar11732, but return Nothing returns IO (Maybe String)
04:20:21 <yasar11732> I want whole function to return IO Nothing :: IO (Maybe LSystem) if an exception occured
04:20:33 <yasar11732> how can I do that?
04:21:41 <pavonia> "return Nothing"
04:22:04 <bergmark> @type return Nothing
04:22:06 <lambdabot> Monad m => m (Maybe a)
04:22:36 <kqr> yasar11732, wrap the whole function in `catch`
04:23:59 <lpaste> yasar11732 pasted “No title” at http://lpaste.net/131132
04:24:09 <yasar11732> something like that?
04:24:27 <kqr> yasar11732, like that, but with the open paren before "do"
04:25:51 <kqr> yasar11732, you could also do this: http://lpaste.net/2401068816487415808
04:28:01 <m4ple> Hey guys, I need a little help with aeson. I'm trying to parse an object with multiple constructors for a field: a little help, please? http://lpaste.net/131125
04:32:14 <bazqux> Does anyone know which is more popular? Yesod or Snap?
04:32:20 <pavonia> m4ple: Don't you want a string/array rather than an object?
04:32:37 <kqr> bazqux, https://hackage.haskell.org/packages/top
04:32:57 <m4ple> pavonia: I guess so, but I'm not sure how to write the FromJSON instance properly
04:34:30 <bazqux> kqr: Thanks. Going by that it is yesod.
04:36:40 <pavonia> m4ple: Shot in the dark: http://lpaste.net/131133
04:37:15 <Adeon> the problem is that in the JSON, you have "author": "something",  that "something" is a string but withObject expects an obejct
04:37:19 <Adeon> object*
04:37:31 <Adeon> so in the FromJSON instance, expect a string or an array instead
04:37:34 <Adeon> you can also use pattern mathinc
04:37:40 <Adeon> parseJSON (String str) = ...
04:37:45 <Adeon> parseJSON (Array arr) = ...
04:37:53 <Adeon> parseJSON _ = empty or error or something
04:39:08 <bazqux> I'm thinking of building a website that is just static html but with dynamic content grabbed by javascript. Would it be crazy to mix hakyll and yesod for that? i.e. Hakyll to generate the static content and Yesod to serve the dynamic content (JSON presumably). Maybe there would even be some way to produce the required javascript by compiling haskell into js.
04:40:28 <kqr> bazqux, if you're going to write a REST API it might make more sense to use a library dedicated for that
04:40:42 <kqr> rather than a full-blown web framework with templating and everything
04:40:44 <m4ple> pavonia: for some reason I can't get your solution to compile... :/
04:40:57 <m4ple> (still trying to understand why, it's surely an indentation problem)
04:41:19 <pavonia> Yeah, at least the last line ist wrong
04:43:27 * hackagebot agentx 0.1.0.3 - AgentX protocol for write SNMP subagents  http://hackage.haskell.org/package/agentx-0.1.0.3 (chemist)
04:43:54 <bazqux> kqr: Okay, thanks for the pointer.
04:58:52 <m4ple> ok I'm making some progress using Adeon's approach. I'm having difficulties pattern-matching inside Array though
04:59:19 <Adeon> the way it works that parseJSON is called with whatever JSON aeson is seeing
04:59:39 <Adeon> you then try to make sense of the data in the implementation of parseJSON and return the haskell value you are trying to parse
05:00:01 <Adeon> or if it doesn't make sense (wrong type, missing fields or something else), you fail with empty, mzero or fail or some other mechanism
05:00:42 <m4ple> Adeon: I got this far http://lpaste.net/5055311287760715776
05:00:57 <m4ple> now I just need to pattern match inside Array to get the list of strings...
05:02:40 <Adeon> yeah that's almost there
05:02:48 <Adeon> the ar in Array ar is a vector from Data.Vector
05:03:36 <m4ple> Adeon: ok, this helps a lot :) I'll look up how to get the list from there
05:03:59 <Adeon> the aeson package may also give you some convenience functions but I'm not sure
05:09:12 <mniip> hmm, I haven't tried the most straighforward thing yet
05:09:31 <ij> Is Either the generic sum type?
05:10:17 <mniip> is there a way to turn k->l->Constraint into k->l (obviously only possible if it's a fundep'd typeclass)
05:10:27 <mniip> ij, yes
05:10:38 <Profpatsch> yasar11732: Try using an editor with support for hslint.
05:10:44 <mniip> and (,) is the generic product
05:11:11 <Profpatsch> It is an incredible feeling seeing type problems right after you type something.
05:11:30 <ij> Never thought of phrasing it like that.
05:11:36 <ij> Thanks.
05:11:48 <Profpatsch> Or, first syntax errors, then type errors, then improvement suggestions.
05:12:01 <duga3> hi, what am I doing wrongly with creating haskell library http://pastebin.com/6m3C9SsN
05:12:06 <mniip> syntax errors as you type? sounds extreme
05:12:11 <duga3> i cannot use it as "plain" c library
05:12:11 <mniip> so does improvement suggestions
05:12:42 <duga3> when throw away extra-libraries it compiles itself, but has haskell libs dependencies (what I don't want)
05:12:53 <m4ple> Adeon: success! (almost). http://lpaste.net/359236532130807808
05:13:02 <duga3> and when I try to attach haskell rts library it fails to locate rts library
05:13:09 <m4ple> this gives me the result as a Vector Value, but that's good enough for the moment
05:13:26 <duga3> 71 line, library  extra-libraries:     libHSrts-ghc7.8.4
05:14:16 <Adeon> something like Many <$> traverse parseJSON ar might work
05:14:41 <Adeon> then you can have Vector Text in AuthorInfo
05:16:29 <sopvop> There used to be ghc builds for centos (older libgmp). But not 7.10.1 :(
05:16:48 <Adeon> if Applicative and Alternative and traversing is not familiar to you then this is an excellent place to gain intuition how it works
05:16:53 <Adeon> Applicative shines in this sort of parsing
05:17:18 <mniip> > traverse (:"_") ["derp"]
05:17:19 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘[Char]’
05:17:19 <lambdabot>      In the expression: "derp"
05:17:19 <lambdabot>      In the second argument of ‘traverse’, namely ‘["derp"]’
05:17:22 <mniip> er
05:17:36 <mniip> > traverse (:"_") "derp"
05:17:37 <lambdabot>  ["derp","der_","de_p","de__","d_rp","d_r_","d__p","d___","_erp","_er_","_e_p...
05:17:38 <m4ple> lol
05:18:01 <m4ple> thanks for the big help, Adeon. traverse will have to wait though, I'm at work and my boss is starting to notice
05:18:16 <srhb> That you're at work? Heaven forbid. :-)
05:18:25 <m4ple> thanks everyone, see you soon. o/
05:21:18 <kqr> mniip, what the... how does that work?
05:26:20 <bennofs> kqr: it works like sequence $ fmap (:"_") "derp", so like sequence ["d_", "e_", "r_", "p_"]
05:26:58 <bennofs> kqr: which works like: do d <- "d_"; e <- "e_"; r <- "r_"; p <- "p_"; return [d,e,r,p]
05:27:37 <mniip> which works like "d_" >>= \d -> "e_" >>= \e -> "r_" >>= \r -> "p_" >>= \p -> return [d,e,r,p]
05:28:33 <kqr> aaah. that's clever
05:28:36 <kqr> thanks
05:28:46 <kqr> not at all what I was expecting either
05:28:50 <kqr> but makes sense
05:33:12 <ij> It's amazing.
05:48:29 * hackagebot ghc-typelits-natnormalise 0.1.2 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  http://hackage.haskell.org/package/ghc-typelits-natnormalise-0.1.2 (ChristiaanBaaij)
05:53:29 * hackagebot clash-ghc 0.5.2 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.5.2 (ChristiaanBaaij)
05:56:12 <lpaste> yasar11732 pasted “No title” at http://lpaste.net/131134
05:56:32 <yasar11732> what am I doing wrong now?
05:58:16 <bartavelle> yasar11732, didn't get your previous messages, but what is the error ?
05:58:30 * hackagebot th-lift-instances 0.1.5 - Lift instances for template-haskell for common data types.  http://hackage.haskell.org/package/th-lift-instances-0.1.5 (BennoFuenfstueck)
05:59:54 <lpaste> yasar11732 pasted “No title” at http://lpaste.net/131135
06:00:14 <yasar11732> bartavelle, see last paste. it contains full code with error message
06:01:06 <bartavelle> ok
06:01:39 <bennofs> yasar11732: what kind of exception do you want to catch there? probably IOExceptions?
06:01:40 <bartavelle> so look at the type of try: https://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Exception.html#g:7
06:02:12 <bartavelle> you don't care about the type of exceptions you want to handle, but the compiler has to know, so that it can use the right "plumbing"
06:02:22 <yasar11732> bennofs, yes I want to catch exceptions like file doesnt exist or cant read it etc.
06:03:03 <bartavelle> so you might specifically annotate the "try" line with something like ":: IO (Either IOException String)
06:05:02 <yasar11732> bartavelle, thanks it works now ;)
06:05:45 <bartavelle> no problem
06:07:23 <yasar11732> Ok, I have a new question now, (ax:rules) = lines str throws exception if the file is empty
06:07:28 <yasar11732> how can I catch that too?
06:07:51 <bennofs> yasar11732: just do a pattern match on lines str (using case) to handle the [] case
06:08:11 <bartavelle> yasar11732, what bennofs said, you can do it in your "case" statement, you don't need an extra one
06:08:29 <bartavelle> Right [] -> return Nothing; Right str -> ...
06:09:50 <yasar11732> ohh, nice :)
06:10:51 <yasar11732> Can you divide a line of code into multiple lines in haskell?
06:12:23 <yasar11732> I have "lSystemIterate n axiom rules = lSystemIterate (n-1) (concatMap (\ch -> getRule ch rules) axiom) rules" which is too long for a line
06:12:42 <chpatrick> sure you can, you just need to stay at at least the same indent level
06:13:15 <c_wraith> Well, you often need to increase the indentation level
06:13:26 <frerich> yasar11732: You could also shorten the line without sacrifying readability too much by removing 'rules' from either side.
06:13:28 <c_wraith> But it depends on context whether you need to increase or not
06:14:02 <spdionis> hello
06:14:09 <chpatrick> I really dislike how you need to indent past the parameters in a let statement in a do block
06:14:24 <spdionis> can some one give me a pointer about what the "<$>" and  "<*>" syntax is about in this file? https://github.com/norm2782/NanoProlog/blob/master/src/Language/Prolog/NanoProlog/Parser.hs
06:14:35 <chpatrick> spdionis: it's Applicative
06:15:07 <c_wraith> chpatrick: you need to do that to indicate you don't mean an additional binding in the same let.
06:15:20 <c_wraith> chpatrick: you know that you can have multiple bindings in a let statement in a do block, right?
06:15:32 <chpatrick> spdionis: simply put it's a way to apply a pure function to parameters that are in some context
06:15:44 <chpatrick> c_wraith: of course
06:15:56 <chpatrick> but I still find it ugly
06:16:14 <benma> spdionis: a <$> b <*> c is like return a `ap` b `ap` c
06:16:26 <benma> spdionis: if you are familiar with Control.Monad
06:16:32 <spdionis> i am not
06:16:43 <spdionis> what function is `ap`?
06:17:06 <chpatrick> spdionis: so it's bracketed like this (a <$> b) <*> c
06:17:24 <benma> spdionis: return a `ap` b `ab` c is like liftM2 a b c, if you know liftM
06:17:40 <benma> or liftA2 a b c, from Applictive
06:17:42 <chpatrick> a <$> b applies a to b in some context, then <*> applies the result to c in some context
06:18:26 <chpatrick> so for example (++) <$> getLine <*> getLine applies ++ to two IO Strings and gives you an IO String
06:18:31 <benma> spdionis: https://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Base.html#liftA2
06:18:51 <benma> "fmap f a <*> b" is "f <$> a <*> b"
06:21:09 <spdionis> thank you for the pointers, i don't understand it completely yet but now i have some starting points
06:22:38 <benma> spdionis: if you don't have the time to look in detail: you can just drop the <$> and <*> and look at it like normal constructur/function applicatoin
06:22:48 <benma> spdionis: but with some underlying context, like a parser state
06:23:37 <benma> spdionis: i.e. ParsedValue <$> aNumber <*> aString would return a ParsedValue Int String, if aNumber/aString are functions to parse numbers and strings
06:26:46 <hjulle> Is there a neat way to provide Show and Read instances at the same time, so you don't have to duplicate the code?
06:27:41 <selveskii> hjulle: you may check projects like invertible-syntax
06:29:17 <hjulle> Yeah, that sounds like exactly what I want
06:30:19 <Ryanar> > Just (+3) *> Just 9
06:30:21 <lambdabot>  Just 9
06:30:30 <frerich> hjulle: I guess a poor mans solution might be to implement 'read' in terms of 'show.
06:30:40 <Ryanar> > (+3) <$> Just 9
06:30:41 <lambdabot>  Just 12
06:30:43 <spdionis> chpatrick: but why do that and not simply getLine ++ getLine?
06:31:01 <chpatrick> spdionis: because you can't append IO Strings
06:31:19 <chpatrick> remember an IO String is more like a plan or a recipe for how to produce a string, not a string itself
06:31:50 <chpatrick> however, you can plan to append :)
06:32:07 <chpatrick> which is what (++) <$> getLine <*> getLine means
06:32:11 <hjulle> frerich, How would you do that?
06:32:16 <chpatrick> :t (++) <$> getLine
06:32:17 <lambdabot> IO ([Char] -> [Char])
06:32:25 <chpatrick> :t (++) <$> getLine <*> getLine 
06:32:26 <lambdabot> IO [Char]
06:32:41 <chpatrick> so the first thing builds a plan for a function that's still expecting the second string
06:32:47 <selveskii> hjulle: However, I never read through that paper so...Besides, you may also be interested in Boomerang, a package which helps to generate URL and parse URL at the same time (type-safe routing). Unfortunately, I couldn't find any papers/design docs for this package.
06:32:50 <chpatrick> and then <*> supplies it the second string
06:32:56 <frerich> hjulle: If the given type is enumerable, you could map 'show' on all the values and then look for the string which you're trying to read.
06:33:05 <spdionis> chpatrick: now it's clearer
06:34:34 <hjulle> frerich, That does not apply in my case, so I guess I'll have to look at the other solutions.
06:37:52 <tero-> what is causing "setup-Simple-Cabal-1.22.3.0-x86_64-linux-ghc-7.8.3: : does not exist" after creating package registration file: /tmp/....?
06:43:06 <lpaste> yasar11732 pasted “No title” at http://lpaste.net/131137
06:43:52 <tero-> the file seems to be present at ~/.cabal/setup-exe-cache 
06:44:17 <yasar11732> I used iterateMaybe and iterateIOMaybe functions to apply lSystemIterate to IO (Maybe LSystem) in http://lpaste.net/131137
06:44:21 <yasar11732> does it look ok?
06:47:22 <geekosaur> tero-: that error message indicates that it's trying to open the empty string as a file
06:48:05 <tero-> geekosaur: ah, maybe there's something in the .cabal file, then
06:48:32 * hackagebot stackage-update 0.1.0.3 - Update your package index incrementally (requires git)  http://hackage.haskell.org/package/stackage-update-0.1.0.3 (MichaelSnoyman)
06:57:57 <Ryanar> > numberParser = read <$> (many $ oneOf "012345")
06:57:58 <lambdabot>  <hint>:1:14: parse error on input ‘=’
06:59:04 <petercommand> Ryanar: you should try "> let numberParser = ... in ..."
07:03:20 <lpaste> yasar11732 pasted “No title” at http://lpaste.net/131138
07:03:41 <yasar11732> I am getting not in scope data constructor IO
07:03:56 <yasar11732> where do I import IO data constructor from?
07:04:11 <c_wraith> yasar11732: in about 99.99999% of correct code, you don't
07:04:41 <c_wraith> yasar11732: you use operations like >>= to combine IO actions together.
07:04:51 <kqr> yasar11732, there is no way to "extract" a value from its IO type
07:05:06 <kqr> yasar11732, you can only combine IO actions together with do notation or the >>= operator
07:06:09 <yasar11732> so, I cant have this type of function? "iterateIOMaybe :: Int -> IO (Maybe LSystem) -> Maybe String"
07:06:16 <kqr> nope
07:06:17 <exio4> yasar11732: you can't escape IO
07:06:26 <kqr> you can have Int -> IO (Maybe LSystem) -> IO (Maybe String)
07:06:26 <c_wraith> yasar11732: well, you can, but it can't depend on its second argument
07:06:54 <tero-> geekosaur: yep. something in build-depends field. now it works
07:06:56 <kqr> well, yes, what c_wraith says. you can get that type if you don't use the second argument
07:07:22 <yasar11732> What is the point of second argument if I don't use it :)
07:07:28 <dst1> Anyone using Test-Suite type detailed-0.9?? Most of the projects I have seen continue using deprecated exitcode-stdio-1.0...
07:08:06 <whiteline> i use exitcode
07:08:33 * hackagebot cabal-debian 4.27.1 - Create a Debianization for a Cabal package  http://hackage.haskell.org/package/cabal-debian-4.27.1 (DavidFox)
07:08:48 <whiteline> i heard detailed was "badly supported" and that i should use exitcode anyway even if it's legacy
07:09:22 <whiteline> exitcode and hsunit seems to cover my needs in any case
07:10:26 <dst1> thats the point, It looks weird that most of the projects are using what it should be deprecated..
07:15:12 <merijn> detailed isn't quite finished, afaik
07:15:21 <merijn> It needs some more polish and has for quite a while now
07:15:29 <selveskii> yasar11732: You can hoogle the type signature "IO a -> a" and find some "backdoor". But most time you should just separate your IO codes from pure ones.
07:15:34 <merijn> Also, where did it say that exitcode-stdio-1.0 is deprecated?
07:16:11 <merijn> selveskii, yasar11732: It's not a matter of "should", any function with that signature is basically guaranteed to create weird bugs you won't be able to debug
07:16:18 <merijn> @quote not.a.bug
07:16:19 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
07:17:33 <Giggaflop> New to haskell, looking a the tutorial on the front page. Are haskell tuples the equivalent of python's lists?
07:17:39 <Giggaflop> looking at*
07:18:41 <kqr> Giggaflop, no
07:18:56 <kqr> Giggaflop, but they are similar
07:19:02 <kqr> Giggaflop, are you curious about some particular property?
07:19:03 <merijn> Giggaflop: No, python lists are mutable
07:19:09 <Giggaflop> ah
07:19:13 <Giggaflop> fair enough
07:19:13 <merijn> Giggaflop: Also, of unknown/variable size
07:19:24 <merijn> Haskell tuples are more like python tuples
07:19:28 <merijn> Except with types
07:20:02 <kqr> and not iterable
07:20:08 <Giggaflop> no?
07:20:11 <kqr> and not really anything like python tuples :)
07:20:14 <Giggaflop> al
07:20:18 <Giggaflop> lol*
07:20:22 <merijn> kqr: Python tuples are immutable
07:20:24 <kqr> Giggaflop, tuples aren't really considered a "sequence" in haskell
07:20:26 <merijn> So there's that
07:20:41 <kqr> Giggaflop, haskell tuples are more like "here are a few different values and we need to treat them as a single value"
07:20:58 <Giggaflop> that's how a lot of python people treat them
07:20:59 <kqr> Giggaflop, with emphasis on "few". if you need more than 4–5 elements in a tuple you might be doing something wrong
07:21:29 <Giggaflop> then how do you store lists of non integer/string objects?
07:21:39 <kqr> normal lists can store any object
07:21:51 <Giggaflop> that's not what the tutorial said?
07:21:51 <kqr> (including tuples or other lists)
07:22:04 <kqr> hm it might be wrong, or you misunderstood something
07:22:07 <Giggaflop> "You can only have a list of numbers or a list of characters"
07:22:09 <exio4> they all have to be of the same type, though
07:22:13 <kqr> ah yeah what exio4 says
07:22:15 <Giggaflop> missed a bit
07:22:17 <Giggaflop> "You can only have a list of numbers or a list of characters, whereas in a tuple you can throw anything in!"
07:22:24 <kqr> if one element is a number, then all elements have to be numbers
07:22:25 <exio4> > [1,2,3,4] 
07:22:27 <lambdabot>  [1,2,3,4]
07:22:27 <Giggaflop> ah
07:22:29 <kqr> if one element is a string, then all elements have to be strings
07:22:31 <kqr> and so on
07:22:35 <exio4> > [True,False]
07:22:35 <Giggaflop> i took it to literally
07:22:36 <lambdabot>  [True,False]
07:22:38 <Giggaflop> too*
07:22:47 <exio4> > [True,'a']
07:22:48 <lambdabot>      Couldn't match expected type ‘Bool’ with actual type ‘Char’
07:22:48 <lambdabot>      In the expression: 'a'
07:22:48 <lambdabot>      In the expression: [True, 'a']
07:23:00 <kqr> nah it's badly worded
07:23:29 <Giggaflop> you'll have to functionally create a new website and throw out the old one ;)
07:23:55 <kqr> Giggaflop, fun fact: that's exactly how version control works, so yes, that's what they'd do :)
07:23:56 <Giggaflop> (bad attempt at a joke)
07:24:21 <Giggaflop> kqr: git doesn't operate like that...does it?
07:24:25 <kqr> yes it does
07:24:28 <Giggaflop> i thought it diff'd
07:24:33 <kqr> common misconception
07:24:42 <kqr> a git commit is a complete snapshot of the entire repository
07:25:24 <Giggaflop> then why doesn't it bloat out of control?
07:25:30 <Athas> What do I do when `haskell-process-load-or-reload` in the fancy new haskell-mode seemingly does not do anything?
07:25:37 <Athas> It worked at first, but then it stopped.
07:25:46 <Athas> The REPL also refuses to accept input.
07:26:19 <kqr> Giggaflop, it does, but it has a couple of tricks up its sleeve to make it not too bad. if a file isn't changed, it reuses the content from the previous commit. and when you have a big enough number of commits, it runs a compression algorithm over them which makes browsing old history slower but saves space
07:26:38 <Giggaflop> hmmm
07:26:45 <OutlawStar> question, I have to modules with name Network.Http.Client, "http-commmon" and "http-streams". How would I hide "http-common" when compiling? PackageImports ext doesn't seem to do it
07:26:49 <Giggaflop> i guess that's to protect against bit rot?
07:26:59 <indiagreen> Athas: perhaps restart the process: M-x haskell-process-restart
07:27:18 <c_wraith> OutlawStar: the easiest approach is to compile with cabal, and only list one in your builds-depends section
07:27:33 <Athas> indiagreen: yes, but that takes a long time.  It seems that `haskell-process-clear` also cleans it up.
07:28:35 <OutlawStar> c_wraith: thx, seems that gives me different output than the build process in vim, any idea on how to fix that?
07:28:42 <kqr> Giggaflop, nah, it's just one way of doing it. it has some benefits and some drawbacks, like the other ways. one benefit is that when you switch branches it can re-create the working directory really quickly since it just pulls binary data out of its database, instead of having to re-create each file by applying successive patches
07:28:54 <Athas> Seems like the space key runs some magic that causes the breakage.
07:29:21 <Giggaflop> yeah, I guess
07:29:33 <Giggaflop> I probably would have a snapshotting feature going the other way
07:29:44 <Giggaflop> or maybe something like rdiff-backup
07:30:01 <kqr> Giggaflop, if you're interested in diff-based version control systems, darcs is probably the premier one (and it just happens to be written in haskell too)
07:30:02 <Giggaflop> where it makes a reverse diff from what you have to what you had
07:30:50 <Giggaflop> kqr thanks, looking at now
07:33:45 <kqr> Giggaflop, (for the record, immutable values in functional languages like haskell are usually based on "persistent data structures", which means they are diff-based under the hood too)
07:34:17 <kqr> Giggaflop, (which is why you can get decent performance with immutable values. having to copy everything every time you change something would be expensive)
07:34:45 <Giggaflop> kqr, Copy on write i guess?
07:35:07 <Giggaflop> same as *
07:35:13 <kqr> Giggaflop, mainly "copy only the parts that changed"
07:35:20 <Giggaflop> ok
07:35:20 <fizbin> Ugh. Stupid problem that should be easy, and that I'd solve without thinking in non-haskell. I hate these.
07:35:32 <kqr> Giggaflop, if you switch out the first element of a list, the rest of the list is shared between both versions of the list
07:35:41 <Giggaflop> that makes sense
07:36:04 <Giggaflop> kqr: does that mean you can go back to the previous version :O
07:36:04 <frawgie> ls
07:36:09 <frawgie> >_<
07:36:12 <Giggaflop> he
07:36:19 <Giggaflop> i do that all the time
07:37:01 <kqr> Giggaflop, in a sense? I mean, if you keep a reference to the old version then yes
07:37:10 <kqr> Giggaflop, if you don't have a reference to the old version then it will be garbage collected
07:37:25 <Giggaflop> i guess it'd collapse it after the last reference goes away
07:39:59 <kqr> not sure what you mean by that, Giggaflop 
07:43:35 * hackagebot som 8.0.2 - Self-Organising Maps.  http://hackage.haskell.org/package/som-8.0.2 (AmyDeBuitleir)
07:45:48 <Giggaflop> kqr: it'd collapse the diff'd datastructure once the references to the old data went away
07:45:55 <Giggaflop> some sort of reference counting
07:47:31 <c_wraith> Giggaflop: it doesn't actually keep diffs, per se.  It just shares as much of the structure as possible between the different versions.
07:47:54 <Giggaflop> so pointers
07:47:57 <c_wraith> yep
07:48:00 <Giggaflop> ok
07:48:42 <Kind> hey guys, how to i compile some simple code in sandbox directory?
07:48:45 <Kind> do*
07:49:09 <Kind> seems a bit overkill to do a package for that
07:50:09 <c_wraith> you could try cabal exec ghc
07:50:14 <dmj`> ^
07:50:49 <dmj`> or cabal exec (zsh/bash), then ghc Main.hs -o main
07:51:13 <Kind> ty
07:52:38 <Luke> I'm trying to learn more about ST data structures. It seems that Vector gives a way to preserve the state between runST calls with freeze and thaw - do any other data structures allow for this?
07:52:58 <Luke> hashtable doesn't seem to have an equivalent
07:54:40 <Kind> hm
07:55:06 <Kind> it does not seem to work, ghc keeps complaning about everything
07:55:14 <Kind> after i run cabal exec bash
07:55:24 <Kind> i get just new line :)
07:56:04 <kqr> Kind, I have a special little sandbox I use to just try quick things out
07:56:20 <Kind> yes, so how do you compile?
07:56:27 <kqr> cabal build
07:56:39 <Kind> but that requires pakaging
07:56:46 <kqr> yes that's what I said
07:56:48 <Kind> i just want simple file to compile
07:56:49 <dmj`> Kind: after you run cabal exec bash, what does ghc-pkg list tell you
07:56:59 <kqr> Kind, I have one package which I use to compile simple files
07:57:14 <dmj`> Kind: it should say your package repo is that of the sandbox
07:57:33 <c_wraith> Luke: it requires having different types for mutable and immutable versions.  hashtable doesn't consider it worth providing an immutable table for the cases it was built for.
07:57:48 <Kind> dmj`: hm everything seems alright
07:57:58 <Luke> c_wraith: are there others that do?
07:57:59 <Luke> c_wraith: datastrucutres that is
07:57:59 <Kind> it does show me new packages i installed in sandbox
07:58:17 <Kind> so must be something in my code, i will check it
07:58:25 <lpaste> ryanar pasted “how do I do an instance of Show Unit?” at http://lpaste.net/579831395392684032
07:58:35 * hackagebot IOSpec 0.2.6 - A pure specification of the IO monad.  http://hackage.haskell.org/package/IOSpec-0.2.6 (WouterSwierstra)
07:58:37 * hackagebot IOSpec 0.3 - A pure specification of the IO monad.  http://hackage.haskell.org/package/IOSpec-0.3 (WouterSwierstra)
07:59:12 <c_wraith> Luke: not that I'm aware of.  mutable hash tables are very much second-class citizens in Haskell, as mutable data structures have a lot of annoying properties.
07:59:26 <Luke> c_wraith: yeah understood
07:59:48 <Luke> c_wraith: just trying to wrap my head around all of the options out there
08:01:20 <Kind> dmj`: ok, ty , it worked
08:01:25 <dmj`> Kind: sweet
08:01:41 <hjulle> > last . takeWhile (<5) $ [1,3,5,2,4] -- Is there a name for this function? And can you write the monadic version (:: Monad m => (a -> Bool) -> m a -> m a) of it in an easy way (without explicit recursion)?
08:01:42 <lambdabot>  3
08:02:13 <hjulle> :t \p -> last . takeWhile p
08:02:14 <lambdabot> (c -> Bool) -> [c] -> c
08:03:01 <dmj`> > last $ do x <- [1,3,5,2,4]; guard (<5) x; return x
08:03:03 <lambdabot>      Couldn't match type ‘()’ with ‘[a0]’
08:03:03 <lambdabot>      Expected type: a -> [a0]
08:03:03 <lambdabot>        Actual type: a -> ()
08:03:42 <dmj`> > last $ do x <- [1,3,5,2,4]; guard (x<5); return x
08:03:43 <lambdabot>  4
08:04:12 <mniip> dmj`, guard is filter, not takeWhile
08:04:26 <chpatrick> https://hackage.haskell.org/package/monad-loops-0.3.0.2/docs/Control-Monad-Loops.html#v:iterateWhile
08:04:38 <fragamus> infix constructors are permitted in data declarations, and are distinguished from infix operators (for pattern-matching purposes) by the fact that they must begin with a :
08:04:47 <fragamus> whats that all about
08:05:00 <mniip> fragamus, about infix constructors, duh
08:05:02 <fragamus> i am asking where is that used 
08:05:10 <geekosaur> it's a generalization of (:)
08:05:18 <chpatrick> fragamus: Complex for example
08:05:23 <mniip> you could say 'data [a] = [] | a:[a]
08:05:24 <dmj`> mniip: doesn't look like filter
08:05:25 <mniip> '
08:05:55 <mniip> fragamus, : here is a constructor
08:06:13 <bennofs> Is there a type like the following: there is one function thunk :: IO a -> Thunk a to construct a new value of the type. Access to the value of the type is only possible within the IO monad, but multiple accesses will be cached (eval :: Thunk a -> IO a). So let t = thunk (putStrLn "Example" >> return 3) in liftA2 (+) (eval t) (eval t) will only print "Example" once
08:06:28 <fragamus> it seems to say that you can make other infix constructors like, say, :+
08:06:41 <mniip> fragamus, yes, you can
08:06:49 <mniip> that's what Data.Complex uses
08:06:50 <bennofs> I can implement this myself, and it doesn't seem to break referential transparency or anything since to access the value you need to be in the IO monad
08:06:57 <chpatrick> bennofs: ioref? :)
08:06:58 <geekosaur> @src Complex
08:06:59 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
08:07:01 <bennofs> But is it defined in an library already?
08:07:09 <fragamus> ah
08:07:14 <bennofs> chpatrick: newIORef :: a -> IO (IORef a), not :: a -> IORef a
08:07:26 <mniip> > do x <- [1,2,3,4,5,6]; guard $ even x; return x -- dmj`
08:07:27 <lambdabot>  [2,4,6]
08:07:38 <bennofs> chpatrick: i'd like the construction to happen in pure code
08:07:56 <chpatrick> that seems a bit weird
08:08:04 <chpatrick> construction outside IO, access only in IO
08:08:08 <bennofs> yes
08:08:09 <chpatrick> usually it's the other way
08:08:15 <mniip> seems rather sane
08:08:50 <fragamus> @src Complex
08:08:51 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
08:08:59 <fragamus> what are those bangs
08:09:07 <chpatrick> I mean if anything it makes sense to read it in pure, no?
08:09:15 <chpatrick> since you'd always get an equal value back
08:09:16 <bennofs> chpatrick: no, since thunk :: IO a -> Thunk a
08:09:18 <chpatrick> just ached
08:09:31 <chpatrick> oh I see
08:09:36 <chpatrick> so it would produce the value with an IO action
08:09:40 <bennofs> yes
08:09:48 <chpatrick> yeah I've written one of those too
08:09:52 <mniip> bennofs, construction cannot be pure, because referential transparency
08:09:53 <chpatrick> don't know if there's a popular one
08:10:10 <lpaste> bennofs pasted “Thunk / Cache” at http://lpaste.net/131141
08:10:26 <bennofs> see the paste for an implementation
08:10:33 <hjulle> chpatrick, That function is almost right, but I want the last one before failing, not the first one that is failing.
08:10:39 <chpatrick> bennofs: can't you just store an mvar + the action?
08:10:43 <mniip> bennofs, see (thunk getLine, thunk getLine) versus join (,) (thunk getLine)
08:10:47 <bennofs> mniip: no, since all access to the type is in IO, referential transparency is not broken
08:11:10 <bennofs> mniip: oh hmm, yes, you're right
08:12:19 <chpatrick> bennofs: I think I would just have data Thunk a = Thunk { produce :: IO a, thunkVal :: MVar a } and thunk :: IO a -> IO (Thunk a)
08:12:27 <chpatrick> is it a big problem that it'd be created in IO?
08:12:31 <bennofs> mniip: I'm intending this to be used where the IO action is idempotent, so executing it twice will not change the behavior of the program (except performance)
08:12:40 <mniip> unsafePerformIO
08:12:42 <mniip> realWorld#
08:12:42 <bennofs> chpatrick: yes, it is
08:12:59 <mniip> pick your poison
08:13:00 <chpatrick> how come though, if you have access to IO for reading it?
08:13:33 <chpatrick> it just doesn't seem like an unsafePerformIO use case to me
08:13:43 <Ryanar> is there some way to take any enumeration of data like data Things = Shoe | Cat | Dog and give the lower case string of that enum?
08:14:12 <dmj`> mniip: oh, I guess it is filter
08:14:19 <chpatrick> Ryanar: map toLower . show?
08:14:34 <Ryanar> that looks good!
08:15:09 <bennofs> chpatrick: consider an implementation of a event network. You have events that can depend on each other (for example, map a function over the value of another event or merge the values of multiple events). There are also roots that depend on no other events. Now, in each "frame", a subset of the roots will be firing. The value of all dependent events will now have to be computed. I'd like to avoid computing
08:15:11 <bennofs> an event more than one time.
08:15:43 <bennofs> chpatrick: so the events need some kind of a "cache" so if they are depended on by more than one other event, they "remember" their current value
08:16:30 <bennofs> chpatrick: actually, I'm not using Thunk for this cache, but only for creating the cache. So I have something like data Event a = Event (Thunk (Cache a))
08:17:15 <bennofs> chpatrick: now I don't want to force all functions that build such an event network into the IO monad, since that for example would disallow me to implement Functor for events and would become akward to use
08:18:25 <mjrosenb> in Reactive.Banana, why would the callback to trigger an event not return until some other event happens (e.g. I move the mouse)
08:18:33 <mniip> bennofs, how about an implicit state like in ST
08:18:52 <bennofs> mniip: but note that the "impurity" can only be observed in IO. So it's on the same as for example Weak references
08:19:10 <mniip> your pure code can create values of the type, but can't do anything with them because of forall's
08:19:32 <bennofs> mniip: ST wouldn't work because i still need to force all my construction of the event network into a monad (so no Functor and "events" cannot just be treated like values)
08:19:41 <mniip> hmm actually that makes little sense
08:19:59 <chpatrick> bennofs: could you defer the caching to something like
08:20:02 <chpatrick> @hackage stable-memo
08:20:03 <lambdabot> http://hackage.haskell.org/package/stable-memo
08:20:09 <lpaste> yasar11732 pasted “L system program” at http://lpaste.net/131143
08:20:21 <yasar11732> my first program is finished!
08:20:41 <yasar11732> every comment is appreciated
08:21:12 <mniip> what's it do
08:21:26 <yasar11732> ohh, I should have added comments :)
08:21:41 <mniip> it's not immediately obvious
08:22:08 <chpatrick> l systems :)
08:22:19 <bennofs> mjrosenb: do you have a small code example demonstrating your problem? I'm not sure what you mean by "callback to trigger an event"? Do you mean when calling the "Handler" passed to you in an AddHandler?
08:22:28 <mjrosenb> bennofs: yes.
08:22:49 * mjrosenb sees if he can get this pared down a whole lot
08:22:54 <yasar11732> It takes a number of iterations and a filename describing an L system (http://en.wikipedia.org/wiki/L-system#Examples_of_L-systems) and grows the system by that number
08:23:37 * hackagebot agentx 0.1.0.4 - AgentX protocol for write SNMP subagents  http://hackage.haskell.org/package/agentx-0.1.0.4 (chemist)
08:25:10 <lpaste> yasar11732 pasted “example usage” at http://lpaste.net/131144
08:25:24 <yasar11732> mniip, you can see above paste
08:26:05 <mjrosenb> bennofs: basically, what I tried to do was put all rendering code into an event that gets called right after SDL.renderPresent gets called, but the "Handler" seems to block until I move the mouse.
08:26:38 <yasar11732> in l system you take an initial string and a list of transformation rules and keep applying rules in each iteration
08:38:44 <yasar11732> I made a codereview question about it: http://codereview.stackexchange.com/questions/87567/l-system-equations
08:43:41 <brbblnch> Hi
08:45:27 <dmj`> brbblnch: Hi
08:46:38 <brbblnch> So the type for $\not A$ in System F is $\forall \alpha . A -> \alpha$. The type for $A -> \bot$ is $A -> \forall \alpha . \alpha$. Shouldn't those two actually be the same?
08:48:38 * hackagebot breve 0.1.1.0 - a url shortener  http://hackage.haskell.org/package/breve-0.1.1.0 (rnhmjoj)
08:50:15 <mjrosenb> bennofs: https://gist.github.com/a05a1a8f76d3707a5b86 -- much shorter than my current codebase, still a tad bit long.
08:50:53 <mjrosenb> bennofs: it doesn't start refreshing the screen until you move the mouse
08:51:14 * mjrosenb has similar code, but with a click handler installed as well
08:51:41 <mjrosenb> and the screen only updates when you move the mouse, not on every "vsync", like I want.
08:53:22 <arbelos> Functions like filter and partition maintain the order of elements, because it follows from how they are implemented (stability). But is it fair to assume that this always holds? If some critical code is relying on the fact that the sorted order of some list is preserved by a filter operation, for instance. 
08:54:23 <mniip> arbelos, filter preserves order in accordance with report
08:54:32 <arbelos> mniip.. oh?
08:54:39 <arbelos> what report
08:55:05 <arbelos> the language report?
08:55:31 <bennofs> mjrosenb: so "callback" from redner loop is printed, but "Done" only after you move the mouse?
08:55:35 <mniip> and partition pretends to be implemented via filter
08:56:07 <arbelos> Good news then, but why doesn't the documentation mention this i wonder?
08:56:40 <mjrosenb> bennofs: yes.
08:57:05 <mniip> hmm
08:57:49 <mniip> https://www.haskell.org/onlinereport/standard-prelude.html#sect8.2
08:57:53 <mniip> er
08:57:59 <mniip> https://www.haskell.org/onlinereport/standard-prelude.html#sect8.1
08:58:11 <Ryanar> if I have a function where I want to pass in some predefined list in my program how can I do that?
08:58:14 <mniip> the default implementation suggests this kind of behavior
08:58:37 <mjrosenb> Ryanar: f [1,5,4,19] ?
08:58:51 <Ryanar> what if its defined as
08:58:57 <Ryanar> someStrings :: [String]
08:59:06 <Ryanar> someStrings = ["str1","str2"..]
08:59:07 <arbelos> mniip. I guess to be paranoid, I could include my own implementation and add this requirement explicitly.. 
08:59:22 <mjrosenb> Ryanar: sure.
08:59:34 <Ryanar> the problem is I want to parse through that string with pattern matching
08:59:37 <Ryanar> and I am not sure how to do that
08:59:55 <Ryanar> like f (x:xs) where (x:xs) is being pattern matched against someStrings
09:00:05 <mjrosenb> arbelos: or you could just sort it every time you need it to be sorted, sorting a sorted list should be linear.
09:00:10 <Ryanar> I can have a wrapper function call it I guess
09:00:18 <Ryanar> ill do that
09:00:29 <mniip> Ryanar, have you heard about case-of?
09:00:49 <Ryanar> I have seen it used, and I don't really like the syntax it is always confusing to me
09:01:15 <mniip> it's barely different from, say, binding syntax
09:01:29 <mniip> or let syntax, or monadic bind syntax
09:02:58 <bennofs> mjrosenb: does SDL.renderDrawRect return?
09:06:26 <bennofs> mjrosenb: when you call cb, you will call the event network, so any registered reactimate handlers will be called. Only when all reactimate handlers have returned, then cb will return
09:08:01 <sagittarian|2> i'm kind of new to haskell and i have a question
09:08:23 <geekosaur> so, ask it?
09:08:39 <bananagram> is there any regex library besides regex-compat-tdfa that provides a replacement function?
09:08:58 <meoblast001> i don't even know if this makes sense but i'll ask... is there something that does something along the lines of Monad m, Monad n => m n a -> n m a?
09:09:13 <sagittarian|2> i'm reading all kinds of random things about haskell, and there seems to be this common reference to a guy named oleg who can do amazing incredible programming feats
09:09:17 <sagittarian|2> who is oleg?
09:09:28 <meoblast001> mostly because i have something giving me a Maybe (IO a) and i really need an IO (Maybe a)
09:10:02 <geekosaur> sagittarian|2, Oleg Kiselyov, http://okmij.org/ftp/
09:10:13 <geekosaur> meoblast001, it can
09:10:22 <mjrosenb> bennofs: I put a print statement, and a flush after SDL.renderDrawRect, and they only get printed after the mouse moves
09:10:38 <yasar11732> is there a function like takeWhile but also returns the rest of the list?
09:10:40 <mjrosenb> also, it doesn't seem to *start* entering the render loop until the mouse moves.
09:10:46 <sagittarian|2> geekosaur: thanks
09:10:50 <meoblast001> geekosaur: oh?
09:10:54 <geekosaur> meoblast001, it can't be done in the general case
09:11:07 <meoblast001> oh, but for IO and Maybe?
09:12:03 <meoblast001> ooh.. sequenceA seems to do it
09:12:09 <meoblast001> because Maybe is Traversable
09:12:18 <meoblast001> or even just sequence
09:13:28 <bennofs> mjrosenb: so a print statement before renderDrawRect in line 102 is executed, but a print statement after is only executed after the mouse moves?
09:14:54 <b34gl3> hello all, i have been given a homework problem, (which the function is incomplete) i have to print out a string which when typed is output diagonally, with each character on a new line: (here is the incomplete solution to complete to aid help better understand): http://pastebin.com/fesAVN5w
09:15:19 <eacameron> What's the diff between ErrorT in mtl and EitherT in errors package?
09:15:22 <sagittarian|2> yasar11732: it's almost like partition, but not quite
09:15:30 <b34gl3> hope someone can help? :O haskell is very hard to understand (never got good understanding :( )
09:15:50 <bennofs> eacameron: EitherT e does not require e to be an instance of an Error typeclass
09:16:12 <eacameron> bennofs: Is that truly all?
09:16:30 <eacameron> bennofs: i.e. is that the only salient difference?
09:16:52 <bennofs> eacameron: note that errors 2.0 will use ExceptT which was recently introduced in transformers and is like errors' eitherT
09:16:58 <xenog> b34gl3: You can use putStrLn instead of putStr >> putChar
09:17:16 <sagittarian|2> is it considered bad form to use Either for something where Left x doesn't indicate an error?
09:17:20 <bennofs> eacameron: I think it is. The Error class is quite annoying since it requires the ability to construct an error message from any string, which is often not possible
09:17:31 <eacameron> bennofs: So does that largely deprecate the use of EitherT then (i.e. use ExceptT instead)?
09:17:32 <mjrosenb> bennofs: no, a print statement right before renderDrawRect also only gets called when the mouse moves.
09:17:37 <b34gl3> xenog, i am unable to change the way it has been laid out ... unfortunately :( it has to follow that method
09:18:42 <b34gl3> xenog: or possibly i can define this way with my 'diag' function ? 
09:19:18 <geekosaur> sagittarian|2, no. in fact the other discussion going on (ErrorT vs EitherT) is kinda related; we are trying to push the stuff that assumes Left is an error to its own structure that assumes one side is an error, whereas Either should be agnostic
09:20:13 <xenog> b34gl3: If you must use printList, and printList takes a list of strings, you must transform your String in diag to a list of String where each letter of String goes to one element of the String list that printList will get, with increasing whitespace to the left as you add each character.
09:21:27 <supki> yasar11732: span
09:21:43 <sagittarian|2> so does it make sense to create another monad instance for either but use Left where canonically Right is used and vice versa
09:21:46 <Ryanar> is there a "trim" method that removes leading or trailing whitespace in a string?
09:21:58 <Ryanar> I can implement my own easily but I didn't know if it already exists
09:22:18 <c_wraith> :t dropWhile
09:22:19 <lambdabot> (a -> Bool) -> [a] -> [a]
09:22:21 <c_wraith> :t dropWhileR
09:22:22 <lambdabot>     Not in scope: ‘dropWhileR’
09:22:22 <lambdabot>     Perhaps you meant one of these:
09:22:22 <lambdabot>       ‘Seq.dropWhileR’ (imported from Data.Sequence),
09:22:39 <xenog> b34gl3: You could do a fold or a recursive function. Maybe if you are not too experienced a recursive function will be easier to do. Your recursive function will probably benefit from having an accumulator argument that counts how many times the function called itself, since that will allow you to choose the right amount of whitespace per character.
09:22:43 <c_wraith> Shoot, that isn't in Data.List at the moment?
09:23:03 <Ryanar> :t takeWhile
09:23:04 <lambdabot> (a -> Bool) -> [a] -> [a]
09:23:46 <Ryanar> > dropWhile (x == ' ') "  1234"
09:23:47 <sagittarian|2> yasar11732: span in the function you're looking for
09:23:47 <lambdabot>      Couldn't match expected type ‘Char -> Bool’ with actual type ‘Bool’
09:23:48 <lambdabot>      In the first argument of ‘dropWhile’, namely ‘(x == ' ')’
09:23:48 <lambdabot>      In the expression: dropWhile (x == ' ') "  1234"    Couldn't match expec...
09:23:48 <geekosaur> sagittarian|2, no unless you swap the type variables. (type can be "partially applied" like functions can, and things like Functor and Monad can only use the last type variable (so Either a b must have Functor (Either a), Applicative (Either a), Monad (Either a)) 
09:23:52 <xenog> b34gl3: Look at repeat too, to do “take n (repeat ' ')”, so that you can generate the list of whitespace that you need.
09:24:15 <Ryanar> > dropWhile ' ' "  1234"
09:24:17 <geekosaur> although arguably we should probably have some kind of Dual-ish wrapper to swap the type variables, type level flip not being a thing
09:24:17 <lambdabot>      Couldn't match expected type ‘Char -> Bool’ with actual type ‘Char’
09:24:17 <lambdabot>      In the first argument of ‘dropWhile’, namely ‘' '’
09:24:17 <lambdabot>      In the expression: dropWhile ' ' "  1234"
09:24:25 <bennofs> mjrosenb: is the SDL package used their available somewhere, so I can run the code?
09:24:27 <sagittarian|2> > dropWhile (== ' ') "   123"
09:24:28 <lambdabot>  "123"
09:24:33 <Ryanar> ah
09:24:35 <mrkkrp> Ryanar: if you want to do for String, it won't be efficient. There is however efficient function strip for Data.Text.
09:24:40 <bennofs> s/their/there
09:24:41 <xenog> > take 5 (repeat ' ')
09:24:42 <lambdabot>  "     "
09:24:57 <xenog> > take 8 (repeat 'a')
09:24:58 <lambdabot>  "aaaaaaaa"
09:25:12 <Ryanar> :t strip
09:25:13 <lambdabot> Not in scope: ‘strip’
09:25:14 <b34gl3> xenog: hmm ok, what is take ? a function 
09:25:22 <Ryanar> mrkkrp, ok I will look into it
09:25:30 <sagittarian|2> :t Data.Text.strip
09:25:31 <lambdabot> Data.Text.Internal.Text -> Data.Text.Internal.Text
09:25:32 <mjrosenb> bennofs: yeah, it is https://github.com/haskell-game/sdl2
09:25:55 <mjrosenb> bennofs: I forked it, and pushed a couple of changes, but nothing that should affect this.
09:26:01 <sagittarian|2> b34gl3: everything is a function, nothing that is not a function exists
09:26:26 <xenog> b34gl3: Think of Haskell as a generic toolkit. take is a function that receives a number and a list, and returns a number of elements from that list, starting from the head.
09:26:58 <lpaste> mrkkrp pasted “HXT element editing” at http://lpaste.net/131148
09:27:12 <mrkkrp> I have my own question too :) Here is a little piece of code that I'm playing with. Could you please take a look at this paste and answer two questions (included in the paste).
09:27:20 <xenog> Since a String is a list of Char ([Char]), then you can do things like what follows…
09:27:31 <xenog> > take 6 "hello world"
09:27:33 <lambdabot>  "hello "
09:28:33 <b34gl3> ok sure i get that, takes the first 6 char's
09:28:39 * hackagebot grid 7.8.2 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.8.2 (AmyDeBuitleir)
09:28:41 <b34gl3> (or atleast outputs them)
09:29:16 <beruuwong> Hi guys, I'm a simple question to ask : http://lpaste.net/131149
09:29:16 <beruuwong> *I've
09:29:24 <sagittarian|2> > (reverse . dropWhile (== ' ') . reverse . dropWhile (== ' ')) "    abc123 efgh     "
09:29:25 <lambdabot>  "abc123 efgh"
09:30:14 <sagittarian|2> > join (.) (reverse . dropWhile (== ' ')) "    abc 123          "
09:30:16 <lambdabot>  "abc 123"
09:30:28 <b34gl3> xeong: lamdabot : so then how does the implementation of newline come in? would it be like take 1 putNewline ?
09:30:35 <moghedrin> --
09:30:35 <moghedrin> --
09:30:41 <slack1256> beruuwong: the whole list
09:30:43 <mrkkrp> beruuwong: `xs' refers to the whole list
09:31:09 <beruuwong> mrkkrp : thank you!
09:31:43 <haskell985> hello friends!
09:31:54 <slack1256> hi
09:33:11 <mrkkrp> No HXT hackers here who know how to append "!" to selected elements?
09:33:40 * hackagebot aeson-better-errors 0.5.0.0 - Better error messages when decoding JSON values.  http://hackage.haskell.org/package/aeson-better-errors-0.5.0.0 (hdgarrood)
09:33:42 * hackagebot bower-json 0.7.0.0 - Read bower.json from Haskell  http://hackage.haskell.org/package/bower-json-0.7.0.0 (hdgarrood)
09:38:38 <orion> What is an example of a package with excellent unit testing?
09:40:26 <dmj`> orion: stripe-haskell is pretty good :) 
09:41:06 <dmj`> @hackage stripe-haskell
09:41:06 <lambdabot> http://hackage.haskell.org/package/stripe-haskell
09:41:22 <orion> Thank you.
09:42:16 <Zemyla> Is there a way to check whether one constraint entails another? Like, whether c m implies MonadPlus m?
09:42:32 <Zemyla> Using ConstraintKinds.
09:42:54 <shachaf> You can check in ghci, if that's what you mean.
09:43:24 <Ryanar> if I have a string "1e-2" how would I go about converting that to a number? so I can do something like
09:43:28 <Ryanar> > 3 * 1e-2
09:43:30 <lambdabot>  3.0e-2
09:43:45 <brbblnch> Are questions concerning system F and co more welcome in this channel or in ##math ?
09:44:06 <shachaf> Defining a new instance generally shouldn't change the behavior of existing working programs, so checking it inside your program would be a problem.
09:44:07 <sagittarian|2> Ryanar: 1e-2 is a number
09:44:10 <sagittarian|2> or at least a Num
09:44:11 <shachaf> brbblnch: They're fine here.
09:44:22 <Ryanar> > 3 * "1e-2"
09:44:24 <lambdabot>      No instance for (Num [Char]) arising from a use of ‘*’
09:44:24 <lambdabot>      In the expression: 3 * "1e-2"
09:44:40 <brbblnch> shachaf: Nice, I'm never quite sure where to ask
09:44:44 <Ryanar> "1e-2" -> 1e-2 is what I am trying to accomplish
09:44:45 <mrkkrp> Ryanar: read "1e-2" :: Double
09:44:49 <Ryanar> ah I forgot about read
09:44:51 <Ryanar> thanks!
09:44:51 <sagittarian|2> > 3 * (read "1e-2" :: Float)
09:44:52 <xenog> > read "1e2" :: Double
09:44:53 <lambdabot>  3.0e-2
09:44:53 <lambdabot>  100.0
09:45:24 <Zemyla> shachaf: No, I want to check in an instance section.
09:45:43 <phaazon> aw
09:45:49 <xenog> > 3.0 * read "1e2"
09:45:50 <phaazon> I just installed GHC 7.10
09:45:52 <lambdabot>  300.0
09:45:56 <brbblnch> So: Is the following proof of $\bot => A correct ?: $\lambda x^{\bot}. {x}U$ where ${}$ represent the type application. 
09:46:00 <phaazon> importing Control.Applicative is now redundant :3
09:46:12 <phaazon> though, Semigroup is not in base
09:46:15 <phaazon> which is a pity :(
09:46:22 <Zemyla> Like, if I have newtype M c a = M (forall m. (Monad m, c m) => m () -> m a)
09:46:44 <orion> dmj`: https://travis-ci.org/dmjio/stripe fail
09:48:15 <Zemyla> And I want to see if I can write instance ??? => MonadPlus (M c) where...
09:48:36 <phaazon> let see something…
09:48:46 <phaazon> AAAAAAAW
09:48:47 <phaazon> class Applicative m => Monad (m :: * -> *) where
09:49:44 <dmj`> orion: so, sometimes the tests run too fast and Stripe rate limits them :)
09:50:10 <dmj`> orion: esp. when you use hspec's parallel function
09:51:42 <dmj`> orion: if we go back to synchronous tests, no problem. I recommend downloading it yourself and running it locally
09:52:53 <earl> If I'm hitting a Zlib "Codec.Compression.Zlib: premature end of compressed stream" problem on mac, is there a good way of addressing this?
09:53:06 <dmj`> earl: with cabal?
09:53:34 <earl> Yes, with cabal, following the Yesod getting started instructions. 
09:53:40 * hackagebot som 8.0.3 - Self-Organising Maps.  http://hackage.haskell.org/package/som-8.0.3 (AmyDeBuitleir)
09:53:46 <yasar11732> My SO question about parsing chemical formulas in Haskell http://stackoverflow.com/q/29778508/886669
09:53:47 <earl> http://lpaste.net/131151
09:56:43 <Hijiri> yasar11732: for parsing, I would recommend a parser combinator library like parsec or attoparsec
09:57:16 <Hijiri> it is much nicer than writing parsers by hand
09:57:39 <Hijiri> well it's still being written by your hands, but more high level
09:58:19 <Hijiri> you can write your own small parser library too, I think that's a common exercise
09:59:31 <earl> dmj' I'm getting quite a bit of advice from 2010, but none of it seems to work.
09:59:41 <orion> dmj`: Why do you use hspec over, say, QuickCheck?
10:00:22 <dmj`> orion: QuickCheck is more for pure code, I'd use it to test encoding/decoding json. Ensure that the isomorphism holds
10:00:45 <orion> I see.
10:00:47 <yasar11732> Hijiri: I am very very new to Haskel writing a parser library is something I cant even imagine how to do :)
10:01:06 <dmj`> orion: My code is more a lot of integration tests against stripe's dev api
10:01:12 <dmj`> which mimics prod
10:01:15 <orion> Right, not pure.
10:01:38 <Luke> how do I get an Int from a DiffTime in `time` package?
10:01:41 <Hijiri> yasar11732: I probably wouldn't be able to either, unless I had already known about them
10:01:49 <Luke> there's a toInteger but I want an Int
10:02:55 <Hijiri> a parser is basically something that may or may not give you something from a String
10:03:09 <Hijiri> so its type would be String -> Maybe a
10:03:09 <orion> dmj`: Do you do hlint testing?
10:03:38 <glguy> truncate 07:: DiffTime 07-> Int
10:04:24 <Hijiri> so you could write type Parser a = String -> Maybe a, as a synonym
10:04:38 <dmj`> orion: There's no warnings when compiled with -Wall
10:05:03 <Hijiri> For the most basic parser you can have    satisfy :: (Char -> Bool) -> Parser a
10:05:27 <Hijiri> wait no
10:05:31 <Hijiri> Parser Char
10:05:49 <Hijiri> It takes a predicate, and returns a parser
10:05:59 <Hijiri> and I got my earlier explanation wrong too
10:06:16 <Hijiri> a parser is like String -> Maybe (a, String), because you have the unconsumed part of the String
10:06:39 <Hijiri> there must be an article somewhere that does a better job than me
10:06:41 <glguy> Luke: truncate was for you
10:08:13 <Luke> glguy: thanks
10:11:31 <bennofs> mjrosenb: compiling with -threaded seems to fix the issue
10:14:52 <bennofs> mjrosenb: probably it's waitEvent that blocks if you don't compile with -threaded
10:16:56 <orion> dmj`: hmm
10:17:25 <orion> I noticed that you have some modules exposed and some modules listed as "other-modules". Does that hinder your ability to unit test those non-exposed modules?
10:17:56 <orion> Web.Stripe.Client.Internal for example
10:18:14 <lpaste> mrkkrp revised “HXT element editing”: “No title” at http://lpaste.net/131148
10:19:39 <mrkkrp> Second attempt... could someone help me process simple XML file with HXT?
10:20:40 <rom1504> maybe
10:20:58 <aidecoe> is there a data structure which has O(1) for insert and lookup?
10:21:20 <rom1504> hash tables
10:21:21 <aidecoe> in HashMap doc it is written: "Many operations have a average-case complexity of O(log n)"
10:21:27 <bennofs> aidecoe: hashtables have that (nearly)
10:21:39 <aidecoe> i would expect theta(1)
10:21:56 <bennofs> aidecoe: but they need mutability, so you need either ST or IO to use hashtables
10:22:00 <bennofs> @hackage hashtables
10:22:00 <lambdabot> http://hackage.haskell.org/package/hashtables
10:22:07 <aidecoe> ST?
10:22:20 <aidecoe> State?
10:22:26 <Hijiri> State Threads
10:22:45 <Hijiri> an abstraction for operations that do destructive updates
10:22:45 <bennofs> ST allows to define a pure function using mutable variables as long as your result is pure
10:22:49 <aidecoe> haven't heard of that yet
10:23:08 <merijn> rom1504: hash tables never of O(n)
10:23:17 <merijn> rom1504: Eh, O(1)
10:23:34 <bennofs> aidecoe: like : runST $ var <- newSTRef 0; ... do somthing with var (like IORef) ...; readSTRef var
10:23:38 <aidecoe> not O(1), but theta(1)
10:23:43 <merijn> They're O(k) (where k is the complexity of the hashing function) with a usual worst case of O(n) if everything hashes to the same bucket
10:24:12 <merijn> aidecoe: No, because bucket collisions are usually resolved using a linked list, resulting in a worst case way different from theta(1)
10:24:14 <Hijiri> aidecoe: theta(1) would imply O(1)
10:24:36 <bennofs> aidecoe: there is also unordered-containers, which are not O(1) but O(log n) with a large base iirc
10:24:47 <bennofs> @hackage unordered-containers
10:24:47 <lambdabot> http://hackage.haskell.org/package/unordered-containers
10:25:06 <aidecoe> ah, theta is o() and O()
10:25:16 <Hijiri> theta is Omega and O
10:25:24 <aidecoe> so i meant amortized cost or something like that
10:25:26 <aidecoe> (-:
10:25:34 <Hijiri> o is O but not Theta
10:26:04 <aidecoe> dammit, i need to refresh that once again
10:26:13 <merijn> aidecoe: Still wrong for amortised
10:26:19 <aidecoe> :-(
10:26:57 <levi> While the complexity bounds of an algorithm are absolutely good to know, they're often misleading as a performance metric in everyday programs.
10:26:58 <aidecoe> merijn: you can have tree instead of linked-list
10:27:38 <aidecoe> levi: unless you're solving task in some online judge system (-:
10:27:45 <merijn> aidecoe: Still not amortised O(1) :)
10:28:15 <aidecoe> merijn: „amortized analysis examines how an algorithm will perform in practice or on average”
10:28:31 <levi> Amortization isn't average case analysis, either.
10:29:16 <levi> Average case does an average over the input domain, while amortization takes into account the proportion of cheap vs. expensive operations over time.
10:29:38 <merijn> Right
10:29:56 <merijn> But a hash map with a low number of buckets will still have a terrible complexity, even amortised
10:30:17 <levi> E.g. Quicksort is n^2 worst-case, but n log n average case.
10:33:42 * hackagebot creatur 5.9.5 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.9.5 (AmyDeBuitleir)
10:33:44 * hackagebot json-stream 0.3.0.2 - Incremental applicative JSON parser  http://hackage.haskell.org/package/json-stream-0.3.0.2 (ondrap)
10:34:03 <levi> When people call hash tables O(1), they're assuming some implementation details like auto-resizing + amortization in the analysis or maybe assuming a good hash function and bucket count for the data set.
10:35:37 <nshepperd_> complexity bounds seem to work surprisingly well for estimating feasibility in google code jam
10:35:49 <nshepperd_> but... perhaps the challenges are designed that way
10:36:49 <levi> I would suspect that they're designed to reward knowledge of CS and Math.
10:38:02 <nshepperd_> typically, if there are 1000 numbers, something O(n^2 log n) will generally work but O(n^3) will not
10:38:16 <nshepperd_> though I wouldn't have thought the constant factors to be that predictable
10:42:33 <levi> This is a pretty neat illustration of how you can sometimes get good results from basic data structures and nice algorithmic design: http://www.cs.nott.ac.uk/~gmh/sudoku.lhs
10:42:41 <mmaruseacph2> I think Dijkstra said that's better to use 2000n^3 + O(n^2) rather than O(n^3)
10:47:25 <lilred> I have a question I don't know how to approach - is every endofunctor on Set monotonic? Does that question even make sense?
10:48:11 <shachaf> "functor" is a sort of generalization of "monotonic function".
10:49:21 <beruuwong> Hi, I've another question : http://lpaste.net/131156            Note : The ?? is just something I use to express my confusion
10:52:50 <sagittarian> which is easier in haskell, writing a full-featured parser for arbitrary english phrases/sentences, or getting the current unix time?
10:53:11 <c_wraith> the latter takes one import and one line
10:53:30 <c_wraith> The former requires a copy of CGEL and hundreds of thousands of lines to capture the grammar it specifies
10:53:54 <sagittarian> c_wraith: which import am I missing?
10:54:08 <arkeet> I don't think anyone really knows how to do the former in any programming language.
10:54:24 <sagittarian> it's not in Data.Time as far as I can see, did I miss it there?
10:54:31 <c_wraith> sagittarian: https://hackage.haskell.org/package/time-1.5.0.1/docs/Data-Time-Clock-POSIX.html
10:54:32 <arkeet> https://hackage.haskell.org/package/time-1.5.0.1/docs/Data-Time-Clock-POSIX.html
10:54:41 <sagittarian> oh I have to install stuff
10:54:53 <arkeet> no, it's in the same package.
10:55:49 <sagittarian> I was looking at Data.Time.Clock, all I see is getCurrentTime, which maybe works, but I can't actually do anything with it because I'm missing constructors that are mentioned in the documentation
10:56:18 <c_wraith> sagittarian: you don't need the constructors, by the way.  It has a Num instance
10:56:33 <slack1256> lambdabot doesn't build in my machine
10:56:42 <slack1256> Can I invite him somehow to a channel?
10:56:44 <sagittarian> uh, I get ghc griping about not having a show instance
10:57:03 <slack1256> I need to show a friend some ghci interactive session on irc
10:57:05 <cschneid> slack1256: private message him
10:57:23 <arkeet> lambdabot isn't ghci.
10:57:24 <cschneid> oh, showing a friend. :)
10:57:28 <slack1256> yes
10:57:45 <arkeet> consider ssh + screen/tmux
10:58:03 <slack1256> too complicated
10:58:13 <rwiggins> Is there a "sequence" for a tuple (m a, m a)? If I'm not mistaken, "sequence [m a, m a]" does what I want, but I only have two elements specifically.
10:58:24 <S11001001> beruuwong: replace x on the LHS of the = on line 3 with x@(a Cars pattern) to destructure it into variables you can use in your ?? definition
10:58:39 <arkeet> :t both id
10:58:40 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable r) => r (f b) (f b) -> f (r b b)
10:58:48 <arkeet> rwiggins: ^ from lens
10:58:55 <arkeet> otherwise you'll just have to write it yourself
10:59:11 <arkeet> actually...
10:59:13 <bennofs> :t bitraverse id
10:59:14 <lambdabot>     Not in scope: ‘bitraverse’
10:59:14 <lambdabot>     Perhaps you meant one of these:
10:59:14 <lambdabot>       ‘itraverse’ (imported from Control.Lens),
10:59:22 <bennofs> @hoogle bitraverse
10:59:22 <Cale> :t uncurry (liftM2 (,))
10:59:23 <lambdabot> Monad m => (m a, m b) -> m (a, b)
10:59:24 <lambdabot> No results found
10:59:24 <lpaste> sagittarian pasted “What is this "time" whereof you speak?” at http://lpaste.net/131157
10:59:25 <arkeet> yeah
10:59:28 <arkeet> that thing
10:59:33 <S11001001> I assume in Data.Bitraversable
10:59:41 <beruuwong> S11001001 : Hi, what do you mean a Car's pattern in x@(a Car's pattern)?
10:59:42 <arkeet> @let import Data.Bitraversable
10:59:44 <lambdabot>  Defined.
10:59:46 <arkeet> :t bisequenceA
10:59:47 <lambdabot> (Applicative f, Bitraversable t) => t (f a) (f b) -> f (t a b)
10:59:49 <S11001001> but both id is nicer, and composes if you have to go deeper
10:59:52 <Cale> Using lens just for that is ridiculous overkill imo
11:00:00 <Cale> Just use liftM2
11:00:01 <arkeet> heh
11:00:07 <S11001001> Cale: we can assume that lens is already in use ;)
11:00:15 <rwiggins> Thanks, guys. I'm still trying to get the hang of all this. :)
11:00:30 <arkeet> :t bisequence
11:00:31 <lambdabot> (Monad m, Bitraversable t) => t (m a) (m b) -> m (t a b)
11:00:43 <barrucadu> jmct: Taneb: Slight emergency situation regarding York Haskell next week, check your emails.
11:00:49 <Cale> Yeah, also, given the question it can be assumed that rwiggins is *probably* somewhat of a beginner, which makes the lens answer even more inappropriate :)
11:01:04 <c_wraith> sagittarian: it looks kind of like you have two different versions of time installed.  That would be kinda bad.
11:01:04 <arkeet> I didn't want to assume.
11:01:36 <Cale> But yeah, for just about any higher order function you can imagine, there's probably something in lens which specialises to it :P
11:01:44 <yasar11732> Hijiri: I was away for a while, thanks for the explanations
11:02:15 <sagittarian> c_wraith: where would these things be installed? ~/.ghc?
11:02:46 <c_wraith> sagittarian: I'm pretty sure time comes with ghc, so no.  use ghc-pkg list
11:03:39 <sagittarian> okay, i have time and old-time, are those conflicting?
11:03:55 <c_wraith> no, that's normal for a certain range of GHC distributions
11:03:59 <Cale> @let swing f c a = f ($ a) c
11:04:01 <lambdabot>  Defined.
11:04:02 <brbblnch> Cale!
11:04:05 <Cale> :t swing map
11:04:06 <lambdabot> [a -> b] -> a -> [b]
11:04:08 <JoshieAS> Is there a good Haskell library for displaying command line reports?
11:04:09 <arkeet> :t swing
11:04:09 <Cale> :t swing foldr
11:04:10 <lambdabot> (((a -> b) -> b) -> t1 -> t) -> t1 -> a -> t
11:04:10 <lambdabot> Foldable t => b -> a -> t (a -> b -> b) -> b
11:04:12 <mjrosenb> bennofs: interesting.  I'll have to add that to my compile flags.
11:04:22 <Cale> :t swing zipWith
11:04:22 <aawe> Anyone here using haskell/ghc from the arch package repos? It's at 7.10, wondering if I should just install it and xmonad or if I should play around with some sandbox solution
11:04:23 <lambdabot> [a -> b -> c] -> a -> [b] -> [c]
11:04:31 <Cale> :t swing partition
11:04:32 <lambdabot> [a -> Bool] -> a -> ([a -> Bool], [a -> Bool])
11:04:39 <Cale> :t swing find
11:04:40 <lambdabot> Foldable t => t (a -> Bool) -> a -> Maybe (a -> Bool)
11:04:56 <Cale> :t swing any
11:04:56 <aawe> if I make a cabal sandbox later, will it be affected by system packages apart from mtl?
11:04:57 <lambdabot> Foldable t => t (a -> Bool) -> a -> Bool
11:05:03 <arkeet> :t swing traverse
11:05:04 <lambdabot> (Applicative f, Traversable t) => t (a -> f b) -> a -> f (t b)
11:05:20 <S11001001> beruuwong: you know how you can pattern match on a Car to get at its bits
11:05:25 <S11001001> beruuwong: like you do in force
11:05:46 <sagittarian> what's the difference between ghc-pkg and cabal?
11:05:59 <sagittarian> can i remove something using ghc-pkg in case that's causing the problem?
11:06:25 <sagittarian> and how would i have gotten more than one version of time installed?  I accidentally installed something globally that depended on it so it brought along its own version?
11:06:29 <beruuwong> S11001001 : do I have to do it in the form of x@(m (x1,y1) (vx, vy)) or can I do this : x@(m a b)?
11:06:33 <sagittarian> I don't remember doing that, but I could be wrong
11:07:47 <S11001001> beruuwong: whichever you like
11:08:05 <S11001001> beruuwong: it would probably be best to add enough boilerplate so we can see a self-contained sample
11:08:11 <sm> https://www.fpcomplete.com/user/simonmichael/how-to-cabal-install is old but may help orient you
11:08:37 <S11001001> beruuwong: definition of Car, force, etc.  Doesn't have to be real, just has to compile, and be syntactically similar enough to what you have
11:08:43 <JoshieAS> is there a Haskell library for displaying command line reports or tables?
11:08:52 <brbblnch> Cale: Would you mind explaining me some things about types in System F?
11:10:37 <Cale> brbblnch: Ask away
11:10:37 <levi> What about types in system F?
11:11:11 <sm> (sagittarian ^^)
11:11:23 <brbblnch> \math Ok, the simplest first: The type for \bot is defined as \Lambda \alpha. \alpha
11:12:22 <Cale> brbblnch: okay, though you can't write bottom in plain System F.
11:12:26 <orion> What's the practical difference between: Thing <$> x <*> y -- and: Thing x y?
11:12:26 <mjrosenb> bennofs: strange, I just added -threaded into ghc-opts, and now I'm getting lots of spew on the command line
11:12:27 <td123> is there any way to check which build-depends in a cabal file are unused in an executable or library?
11:12:53 <sm> td123: remove them and rebuild.. :|
11:12:57 <bennofs> mjrosenb: well, your renderLoop is a loop without delay ...
11:12:59 <beruuwong> S11001001 : Thanks for the help. Would this be correct? http://lpaste.net/131159
11:12:59 <sagittarian> sm: thanks but I finally figure out that importing Data.Time.Clock.POSIX got me my beloved unix time
11:13:00 <mjrosenb> but the sdl window never seems to actually paint
11:13:13 <brbblnch> Cale: Well, Girard defines it?
11:13:14 <supki> td123: there's packunused
11:13:17 <Cale> orion: The first thing produces an action which will execute x and y and apply Thing to the results of those actions in order to obtain its result
11:13:19 <bennofs> nshepperd_: yi
11:13:20 <supki> @hackage packunused
11:13:21 <lambdabot> http://hackage.haskell.org/package/packunused
11:13:25 <bennofs> mjrosenb: your example works for me
11:13:45 <Cale> orion: i.e. Thing <$> x <*> y = do { u <- x; v <- y; return (Thing u v) } whenever you're dealing with a monad.
11:14:17 <Cale> brbblnch: Does the variant of System F being used have a fixpoint combinator thrown in as a primitive?
11:14:29 <brbblnch> Cale: Not that I know of
11:14:34 <sm> td123: or reload in ghci, quicker - but remember to also test any cabal flags and executable/test sections
11:15:19 <Cale> brbblnch: Okay, how do you do it then? The usual System F is strongly normalising, which means you can't write nonterminating programs in it.
11:15:20 <brbblnch> Cale: See paultaylor.eu/stable/prot.pdf
11:15:53 <mjrosenb> bennofs: weird.  Maybe I changed something.
11:15:57 <brbblnch> \math Cale: Well, he says \forall \alpha. \alpha is the type, and it shouldn't contain any element
11:16:01 <S11001001> beruuwong: yeah.  You aren't using (x1,y1) so might as well replace with _.  Same with m, and a@ can just be removed.  Otherwise cool
11:16:17 <mjrosenb> bennofs: presumably, you built whatever HEAD was on sdl2?
11:16:19 <levi> brbblnch: Where in particular in the book are you finding this?
11:16:24 <bennofs> mjrosenb: yes
11:16:25 <S11001001> beruuwong: warnings help here :)
11:16:32 <bennofs> mjrosenb: (new-api branch)
11:16:33 * mjrosenb wonders if that being out of date is affecting things for me
11:16:43 <beruuwong> S11001001 : What warnings?
11:16:46 <brbblnch> levi: In the chapter on System F (page 85 in my edition)
11:16:58 <Cale> brbblnch: Right.
11:17:06 <Cale> brbblnch: In that case, sure
11:17:28 <S11001001> beruuwong: add ghc-options: -Wall to your library/executable block in yourproject.cabal, or {-# OPTIONS_GHC -Wall #-} to the top of the haskell file
11:18:11 <beruuwong> S11001001 : Thanks for the tip! I appreciate your help very much :)
11:18:20 <brbblnch> Cale: So, i'm not sure what the defined ϵ does. I guess it gives you a proof of any formula out of the proof of false, right ?
11:18:44 * hackagebot cndict 0.5.3 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.5.3 (DavidHimmelstrup)
11:19:03 <sagittarian> if I install time in a cabal sandbox and then run ghci within that sandbox, is that bad?
11:19:10 <Cale> ε_U t = t U
11:19:18 <Cale> Here t : Pi X. X
11:19:28 <Cale> and U is some type
11:19:50 <Cale> So ε_U t : U
11:20:04 <Cale> and yeah, it's like ex falso
11:20:09 <sm> sagittarian: no
11:20:20 <sagittarian> so how do I get it to work?
11:20:27 <sm> cabal exec ghci
11:20:30 <brbblnch> But why is it called the empty type, Λ α. α is of this type, no?
11:20:42 <sagittarian> do I need to install the Prelude into the sandbox too?
11:20:43 <slack1256> sigittarion: on the sandbox `cabal repl`
11:20:50 <Cale> no
11:21:49 <Cale> Λα. α is a syntax error, you're using a type where a term was expected
11:22:04 <monochrom> "time" already comes with ghc. you should not need to install "time"
11:22:28 <sm> oops, s/cabal exec ghci/cabal sandbox exec ghci/. Or what slack1256 said if you're in a cabal project
11:22:32 <monochrom> if you still do it, you will get two versions, and there will be potential conflicts.
11:22:35 <sagittarian> so wtf?  I created a brand new sandbox, installed only time into it, ran ghci, import Data.Time.Clock tried to look at getCurrentTime, and ghc still complains that it doesn't have a Show instance for UTCTime
11:23:01 <aidecoe> what to do if I get "Ambiguous module name" from ghc?
11:23:03 <monochrom> the Show instance is in another module
11:23:04 <sagittarian> or does UTCTime really not have a Show instance and I have to muck around with formatting strings?
11:23:04 <brbblnch> Cale: so the term t to which you apply \epsilon doesn't actually exist ?
11:23:12 <sagittarian> monochrom: which module?
11:23:21 <monochrom> it is easiest to just import Data.Time
11:23:24 <aidecoe> i want to import Data.HashSet but it's present in: hashmap-1.3.0.1 and unordered-containers-0.2.5.1
11:23:37 <aidecoe> i cannot pass anything to ghci, because it's online judge
11:23:42 <Cale> brbblnch: It may exist locally. There should be no way to get a term of that type from an empty context.
11:23:44 <sagittarian> Data.Time.Format, thanks for the tip monochrom
11:23:53 <Cale> brbblnch: But if you bind some variables, you can get one.
11:24:00 <brbblnch> Cale: ok. 
11:24:09 <sagittarian> that's perverse though, is it really helpful that Data.Time.Clock doesn't import Data.Time.Format?
11:24:23 <Cale> brbblnch: Just like there ought not to be a proof of False in terms of logic
11:24:24 <monochrom> I don't know. submit a pull request.
11:25:19 <Cale> brbblnch: But you might assume some contradictory things and end up proving False
11:26:07 <sm> sagittarian: if you want everything with fewer imports, can't you just import Data.Time as monochrom suggested ?
11:27:08 <sagittarian> sm, oh I missed the idea of importing Data.Time, thanks
11:27:10 <brbblnch> Next question: I don't get how to get a term of type ¬ A . It should have the form Λα.λx^A->[something of type α]
11:27:15 <sagittarian> > let not True = True in not True
11:27:17 <lambdabot>  True
11:27:24 <monochrom> aidecoe: there is an extension PackageImports for this. read the GHC user's guide, section title "Package-qualified imports"
11:27:41 <sm> sagittarian: that may not include *everything*, but try
11:27:54 <aidecoe> monochrom: thanks
11:28:25 <orion> Cale: The effect though is the same for both, correct?
11:28:44 * hackagebot cndict 0.5.4 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.5.4 (DavidHimmelstrup)
11:28:49 <Cale> orion: Usually only one of the two will typecheck, unless Thing is rather polymorphic
11:28:58 <brbblnch> Cale: I guess you could put {t}α (where {} denote type application) in the []. That would quite correspond to the idea that ¬ A = A -> ⊥ …
11:29:02 <Cale> orion: and even if both typecheck, they are very different
11:29:23 <Cale> orion: Consider for instance  (,) getLine getLine   vs.  (,) <$> getLine <*> getLine
11:29:42 <lpaste> yasar11732 pasted “No title” at http://lpaste.net/131161
11:29:51 <Cale> orion: The first of these is a pair of IO actions, each of which is the action for getting a line of text from the user.
11:30:16 <Cale> orion: The second is a single IO action which when executed will get two lines of text from the user, and result in a pair of strings
11:30:25 <Cale> (the two strings which were typed)
11:30:36 <yasar11732> I was trying to build a parser like Hijiri described, but I am stuck here: http://lpaste.net/131161
11:30:44 <mmachenry> When I use "cabal exec" to run a command, I can get libraries from my sandbox imported, but I can't get libraries I wrote in my src directory to import. What do I do to have ghc find them?
11:30:51 <orion> Cale: I see.
11:30:52 <aidecoe> monochrom: "Package-qualified imports are not enabled; use PackageImports"
11:31:18 <monochrom> {-# LANGUAGE PackageImports #-}
11:31:19 <aidecoe> monochrom: can i somehow enable it with some instruction within .hs file?
11:31:24 <aidecoe> thanks (-:
11:32:04 <Cale> orion: If you have the first of these, you can turn it into the second, but if you're given the second, there's no way to turn it back into the first.
11:32:25 <orion> Interesting.
11:32:57 * mjrosenb has a directory with a sandbox in it.  I want to build the package, and install it into my user-local stuff. Can I do this?
11:33:07 <Cale> orion: If you're given a pair of IO actions (x,y) and have to produce an IO action, you might choose to discard one or both of x or y and never execute it.
11:33:10 <sagittarian> does haskell have anything like lisp or python docstrings, or are you just supposed to figure everything out from the type signature?
11:33:41 <Cale> orion: But if you're given an IO action that results in a pair, if you want either part of the pair, you have to execute the entire action.
11:33:41 <monochrom> there is no docstring. but there is haddock.
11:34:37 <Cale> brbblnch: Sorry, where would you put {t}α?
11:34:38 <monochrom> the difference is that haddock docs are read in a web browser, not in the repl.
11:34:39 <mmachenry> sagittarian: We use — | for comments.
11:34:48 <Cale> mmachenry: --
11:35:01 <monochrom> I think ------ | works
11:35:01 <mmachenry> Cale I can't type that in my client. I tried twice. :)
11:35:03 <yasar11732> can anyone help me you here? http://lpaste.net/131161 I am trying to create a simple parser
11:35:12 <Cale> (your IRC client mangled that into an em-dash or something)
11:35:21 <mmachenry> Cale I know
11:35:41 <Cale> yeah, definitely an em-dash :)
11:35:58 <mmachenry> Cale, yes definitely. We're on the same page.
11:36:13 <monochrom> I have a cunning plan!
11:36:19 <brbblnch> Cale: Like that Λα.λx^A->{t}α
11:36:39 <sagittarian> nothing inline, within ghci?  I have to open a web page or something to get the documentation?
11:36:51 <monochrom> we should propose for the next Haskell report to allow – and — for comments, too
11:36:54 <Cale> brbblnch: System F doesn't let you write a type there.
11:37:12 <monochrom> yes sagittarian
11:37:27 <Cale> brbblnch: er, also you mean Λα.λx^α.{t}α right?
11:37:54 <brbblnch> Cale: yeah, ups
11:38:02 <brbblnch> cale: But it still doesn't work?
11:38:04 <Cale> But the thing which is in a body of a λ or a Λ is never a type
11:38:10 <Cale> Only terms are allowed there
11:38:17 <monochrom> but look at the bright side! lisp and python repls don't have hyperlinks
11:38:54 <monochrom> and are so terminal-console-mode you can't "open link in new tab" either
11:38:55 <Cale> monochrom: what about ― ?
11:39:32 <sagittarian> monochrom: i've never seen hyperlinks in ghci, what am i missing?
11:39:33 <monochrom> I forgot that one. I support it too
11:39:51 <Cale> ー
11:39:55 <sagittarian> i'm anxious that i wasted my youth now, ignorant of the hyperlinks in ghci
11:40:03 <monochrom> I mean with haddock you view doc in web browser and it has hyperlinks
11:40:08 <sagittarian> ah
11:40:23 <monochrom> with lisp and python you view in repl and do not enjoy hyperlink
11:40:46 <sagittarian> okay, but doc.python.org has hyperlinks, so i'm not sure ghc is going to win this one
11:41:01 <monochrom> no, I was stating a "silver lining" thing
11:41:20 <monochrom> tons of people what haddock stuff to show up in ghci too.
11:41:24 <monochrom> s/what/want/
11:41:31 <sagittarian> oh, okay, thanks for the help :-)
11:41:37 <monochrom> but so far the real bounty is $0 so no one is going to do it
11:42:04 <Cale> brbblnch: This is at least part of what sets System F apart from dependently typed languages
11:42:19 <monochrom> economics explains a lot of lack of things
11:42:52 <brbblnch> Cale: Could you point me to what in the definition in Proofs and Types, says so ?
11:43:15 <Cale> brbblnch: Look on page 81
11:43:32 <brbblnch> Cale: Also, does there exist a term for ¬ A then ?
11:44:19 <Cale> You could define ¬ A as A -> Emp
11:44:43 <Cale> which if we unfold it a little, would be  A -> (ΠX. X)
11:45:17 <Cale> That's a type, not a term, just to be clear
11:45:31 <brbblnch> Cale: But that's not the type that is given (and follow up question, are those two types equivalent)
11:45:32 <sm> sagittarian: :t, :i, and :bro help a little. Also you can set up an alias to run hoogle, etc.
11:45:56 <Cale> uhhhhhh
11:46:09 <Cale> brbblnch: Which ¬ are you looking at?
11:46:10 <brbblnch> Cale: Sorry, I'm confused!
11:46:34 <Cale> brbblnch: There's a completely unrelated function on booleans
11:46:44 <Cale> brbblnch: Is that what you're after?
11:47:15 <brbblnch> Cale: In another source, he defines ¬ A as ∀ α . A → α
11:47:39 <Cale> oh, he moved the Π outward, that's fair
11:47:45 <monochrom> this is why I say, "if there are 10 authors, there will be 12 different definitions"
11:47:48 <brbblnch> lol
11:48:10 <brbblnch> Cale: Yeah, they look similar, but then…
11:48:43 <Cale> Let's try to construct an isomorphism.
11:48:45 * hackagebot sendgrid-haskell 1.0 - Sengrid API  http://hackage.haskell.org/package/sendgrid-haskell-1.0 (owainlewis)
11:49:57 <ezyang_> What's your preferred way of finding name conflicts when you're picking a name for something 
11:50:20 <Cale> i.e. let's define a function f: ΠA. (A -> ΠX. X) -> (ΠX. A -> X), and its inverse g: ΠA. (ΠX. A -> X) -> (A -> ΠX. X)
11:50:41 <monochrom> yasar11732: to write "\n -> if n==0 then 0 else 1 + «recurse here, call self with (n-1)»", there are two ways
11:51:17 <monochrom> first way: let {f n = if n==0 then 0 else 1 + f (n-1)} in f
11:51:42 <monochrom> second way: fix (\f n -> if n==0 then 0 else 1 + f (n-1)).  fix is in Data.Function
11:52:21 <bennofs> ezyang: hayoo
11:52:22 <Cale> f = ΛA. λr^(A -> ΠX. X). ΛX. λa^A. r a X
11:52:33 <ezyang> how can I make it tell me only types 
11:52:43 <ezyang> ! apparently 
11:53:42 <Cale> g = ΛA. λr^(ΠX. A -> X). λa^A. ΛX. r X a
11:55:16 <Cale> brbblnch: Does that make sense to you? It remains to check that f and g are actually inverses, but so long as they typecheck, we see that there is at least always an implication in either direction between ΠX. A -> X and A -> ΠX. X
11:55:42 <Cale> brbblnch: essentially all we're doing is interchanging the order of the arguments, but one of them is a type argument
11:55:45 <brbblnch> Cale: f is given a type A , a proof r of one form, you create a proof in the other form, right ?
11:55:55 <Cale> yeah
11:56:14 <brbblnch> Cale: Intuitively, choosing \alpha before looks harder, because there could be clashes with A, no ?
11:56:37 <Ryanar> Is there a built-in way to make haskell evaluate a number fully of this form
11:56:43 <Ryanar> > 3 * 1e-3
11:56:45 <lambdabot>  3.0e-3
11:56:54 <Ryanar> I want it to instead ouput 0.003
11:56:58 <Cale> Implicit in all of this has been the fact that X can't depend on A in any way
11:57:28 <brbblnch> Cale: ok, then
11:57:43 <Cale> > showFFloat (Just 3) (3e-3) ""
11:57:44 <lambdabot>  "0.003"
11:58:03 <monochrom> Ryanar: that's output formatting, not evaluation. use either stuff from Numeric or stuff from Text.Printf to control output formatting.
11:58:05 <brbblnch> Cale: But anyway, it's not possible to provide a term of type ¬ A ?
11:58:09 <Cale> brbblnch: er, sorry, no, the other way around
11:58:14 <Cale> A can't depend on X, sorry
11:58:21 <Cale> X *can* depend on A
11:58:22 <Ryanar> ok
11:58:44 <Cale> brbblnch: A is not in scope, so this isn't a complete type
11:58:45 <monochrom> 3.0e-3 and 0.003 display exactly the same bit pattern underneath
11:58:55 <Cale> brbblnch: For some choices of A, there will be a term of that type.
11:59:48 <brbblnch> Cale: Do you have an example?
11:59:52 <Cale> brbblnch: For example, we can get a term of type ¬ (¬ Bool)
11:59:58 <brbblnch> hehe
12:00:26 <Cale> Which definition of ¬ do you prefer?
12:00:45 <monochrom> ¬Emp has a term too, no?
12:00:48 <Cale> yes
12:01:00 <brbblnch> A → ⊥
12:02:20 <brbblnch> monochrom: λx^⊥.x^⊥ ?
12:02:27 <Cale> correct
12:02:44 <brbblnch> like a pro
12:03:17 <sagittarian> would I be ostracized by the haskell community if I decided to use snake case instead of camel case for all my haskell code?
12:03:52 <monochrom> what is snake case? I am happy to rid of camel case
12:03:58 <sinelaw> why does Identity have fmap = coerce? why not: fmap f (Identity x) = Identity (f x) ?
12:04:03 <Cale> sagittarian: If there were two libraries which were entirely equivalent apart from one of them using underscores in its names, I would choose the one which didn't.
12:04:15 <sagittarian> snake_case, camelCase
12:04:47 <monochrom> have you also considered oleg case? it means oleg'case
12:04:58 <brbblnch> Cale, in the other definition, it's Λα.λx^⊥.{x^⊥}α ?
12:05:03 <sagittarian> is that legal in haskell?
12:05:04 <Cale> Sometimes I'll even use variable patterns in place of wildcard patterns just because I dislike the underscore character typographically.
12:05:04 <sinelaw> monochrom, `
12:05:17 <sagittarian> which non-alphanumerics are legal as non-operator identifiers anyway?
12:05:20 <monochrom> yes, because ' can be in identifiers after the first letter
12:05:28 <sagittarian> okay
12:05:47 <monochrom> people usually use it for s', s'', s''' etc. but nothing stops you from s'''t
12:05:59 <Cale> brbblnch: You put a type where a term was intended again
12:06:00 <sagittarian> I wish I could use ? and ! in identifies (like in ruby (and lisp)), but at least the strong typing solves some of the need for that
12:06:15 <Cale> errr
12:06:16 <sagittarian> english doesn't have a good single word for "is it true"
12:06:25 <sinelaw> source for fmap = coerce: https://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-Functor-Identity.html#Identity
12:06:27 <Cale> Wait
12:06:31 <brbblnch> Cale: Clearly I don't really get that yet. Do you mean the \alpha ?
12:06:37 <bernalex> sagittarian: -p
12:06:56 <tromp> > 0 < 1 > False
12:06:57 <lambdabot>      Precedence parsing error
12:06:58 <lambdabot>          cannot mix ‘<’ [infix 4] and ‘>’ [infix 4] in the same infix expression
12:07:01 <orion> Is it possible to expose modules located in an executable?
12:07:11 <Cale> brbblnch: Well, I honestly don't understand what it is that you meant by the body of that lambda
12:07:20 <Cale> brbblnch: So you might be fine, it's just weird :P
12:07:27 <monochrom> no, "expose modules" makes sense for library only
12:07:34 <Cale> brbblnch: If you define all the syntax differently :P
12:07:44 <brbblnch> Cale: I mean type application
12:07:44 <Cale> brbblnch: Try using the book's syntax
12:08:18 <brbblnch> Cale: Actually, I'm using «The Blind Spot»s syntax, afaik
12:08:48 <Cale> It's okay for type application to be rendered identically to ordinary application, because the type variables will be bound by type lambdas Λ so you'll know which ones they are.
12:09:31 <brbblnch> Cale: yeah, ok. Then α.λx^⊥.(x^⊥)α, is valid or not ?
12:09:51 <Cale> What type is that supposed to have?
12:10:21 <Cale> Also, there's a superscript on the x which isn't in a binder...
12:10:29 <brbblnch> ⊥ -> ⊥
12:10:43 <Cale> Nope, can't be that type
12:11:05 <Cale> Any term which starts out with a Λ must have a type which is formed using Π
12:11:11 <brbblnch> Cale, no : ∀ α.⊥->⊥
12:11:56 <Cale> Do you mean Πα.Emp -> α?
12:12:08 <brbblnch> Cale: … yeah, sorry
12:12:10 <Cale> In that case, I think you're right
12:12:26 <Cale> You've effectively written ε
12:12:43 <brbblnch> \math Cale, I wanted to prove \neg \bot in both variants of negation
12:13:01 <Cale> I would have written Λα. λx^⊥. x α
12:13:25 <brbblnch> Cale: Isn't it the same ?
12:13:40 <Cale> yeah, it's just usually you don't superscript *everything* with its type
12:13:50 <Cale> Just the variables in binders
12:13:58 <Cale> But I guess you could
12:14:09 <brbblnch> Yeah, but I finally worked out how to write math symbols, so I enjoy the possibility
12:15:13 <brbblnch> Cale: Last question if I may, do you have an intuitive explanation of the definition of  ∃ in term of ∀ ?
12:16:13 <levi> The notation is a bit confusing (to me, anyway), as you have some symbols that stand for some arbitrary terms/types, and others that stand for specific bound or free (term/type) variables.
12:16:47 <lpaste> yasar11732 pasted “parser monad” at http://lpaste.net/131163
12:17:00 <yasar11732> does that look like a correct monad?
12:17:18 <yasar11732> I don't really know what I did there :)
12:17:43 <yasar11732> ignore first 3 lines, those shouldnt be there
12:17:57 <brbblnch> levi: You mean my notation, or the one for \exists ?
12:18:52 <levi> The existential-to-universal quantification transformation is Skolemization, isn't it?
12:19:08 <monochrom> yasar11732: you should get a type-error for "Just (f a, cs')".
12:19:43 <yasar11732> monochrom: i didn't even try to compile that, I am still trying to figure out how to do it
12:20:06 <levi> brbblnch: I mean Girard's notation from the book.
12:20:20 <monochrom> if you don't want a spoiler, pay more attention to the type of f.
12:20:42 <monochrom> if you want a spoiler, I can give you a spoiler
12:20:47 <levi> brbblnch: http://en.wikipedia.org/wiki/Skolem_normal_form
12:21:44 <yasar11732> monochrom: f :: (String -> Maybe (a, String)) -> Parser (String -> Maybe (a, String))
12:21:48 <yasar11732> am I correct so far?
12:21:58 <Cale> ... not sure which of my messages made it through
12:22:05 <Cale> What was the last thing I said?
12:22:21 <monochrom> no, f :: a -> Parser b
12:22:22 <levi> Cale: 'Just the variables in binders' 'But I guess you could'
12:22:37 <sbidin> With haddock, how do I write "Type's", where "Type" is a link to the Type documentation? Doing "'Type''s" doesn't work. (Sans all the quotation marks.)
12:22:57 <sbidin> (Sans the *double* quotation marks.)
12:23:05 <Cale> <Cale> brbblnch: So, the book does this, it says if V is a type, and X is a type variable (which may occur free in V), then ΣX.V = ΠY.(ΠX.(V -> Y)) -> Y
12:23:08 <Cale> <Cale> So, this says there exists a type X for which V holds if for any type Y, if (it's the case that for all types X, we have V -> Y), then we have Y.
12:23:11 <Cale> <Cale> This might be clearer if we wrote V(X) instead of V
12:23:22 <yasar11732> monochrom: I am so confused, is a and b are both functions?
12:23:25 <EvanR-> trying to build git-annex on a somewhat old installation of ghc and the unix package seems to be barfing on link: http://lpaste.net/131164
12:23:34 <monochrom> no, a and b are type variables
12:23:47 * hackagebot airship 0.1.0.0 - A Webmachine-inspired HTTP library  http://hackage.haskell.org/package/airship-0.1.0.0 (patrick_thomson)
12:23:57 <Cale> The intuition is that we could just apply our proof that ΠX.(V -> Y) to the actual X for which V(X) holds, and then to the proof of V(X), obtaining a proof of Y.
12:24:02 <yasar11732> I mean b should be a function because "newtype Parser a = Parser (String -> Maybe (a, String))"
12:24:17 <yasar11732> argument of a Parser is a function
12:24:23 <sbidin> I figured it out: use back-quotes instead. So: "`Type`'s".
12:24:25 <monochrom> that is wrong reasoning
12:24:44 <yasar11732> Like I said, I don't know what I am doing :D
12:24:45 <Cale> brbblnch: still here?
12:24:51 <brbblnch> Cale: Yeah
12:24:59 <Cale> brbblnch: Does that help any?
12:25:12 <geekosaur> EvanR-, you have two different installations of the unix package, and they're conflicting with each other
12:25:15 <brbblnch> Cale: Not yet, let me read it!
12:25:17 <monochrom> you probably need to learn types solidly before you can do this one
12:25:42 <geekosaur> same version but one is in /usr/local/lib and the other's in your local packages
12:25:58 <EvanR-> ok
12:26:23 <yasar11732> monochrom, so Parser is a type, which takes one type parameter and return a function wrapped in a new type
12:26:28 <yasar11732> am I right so far?
12:26:28 <geekosaur> suggest you ghc-pkg unregister the one registered under ~/.ghc and then rebuild anything that is marked as broken by ghc-pkg
12:26:44 <geekosaur> and make sure they don't suck the local one back in somehow
12:26:52 <monochrom> when I learned this parser monad thing, I didn't know what I was doing either. but I got all the types right.
12:27:03 <geekosaur> (same version so they shouldn't, but then how did you get a local package in the first place?)
12:27:14 <monochrom> no, that sounds like a flawed description.
12:27:21 <Cale> brbblnch: You should also be looking at section 11.3.5 of the book here of course
12:27:24 <EvanR-> geekosaur: im not seeing the local version anywhere...
12:28:06 <EvanR-> ghc-pkg list shows only one
12:28:07 <geekosaur> /home/evan/.cabal/lib/i386-linux-ghc-7.8.3/unix-2.7.1.0/libHSunix-2.7.1.0.a(ghcrts.o)
12:28:15 <Cale> brbblnch: So here he defines a notation for elements of type ΣX.V which ought to be familiar if you've ever used a dependently typed language.
12:28:24 <monochrom> in fact, my kind of "I didn't know what I was doing" was that I was able to write a type-correct expression and I didn't know what its behaviour was.
12:28:28 <EvanR-> ok so the ghc version doesnt show up
12:28:44 <geekosaur> ~/.ghc has the package registration information; ~/.cabal is where cabal puts the actual package installation, then adds a package record under ~/.ghc poionting to it
12:29:36 <EvanR-> it says unregistering it would break some packages which i cant unregister because "permission denied" which i take to mean they are part of system ghc
12:29:41 <yasar11732> monochrom: Parser is another type for (String -> Maybe (a, String)) so far so good?
12:29:53 <monochrom> no
12:30:05 <EvanR-> do i have to just reinstall ghc
12:30:10 <yasar11732> I thought that is what newtype did
12:30:21 <brbblnch> Cale: haven't done that
12:30:38 <geekosaur> EvanR-, I don;t think so. maybe just move ~/.ghc out of the way and then reinstall anything you had in there
12:30:50 <geekosaur> ghc-pkg list --user
12:30:52 <geekosaur> first
12:31:14 <EvanR-> theres a lot of red 
12:31:21 <EvanR-> and no unix
12:32:04 <geekosaur> so already unregistered and already quite broken. just remove it, I think
12:32:10 <geekosaur> and reinstall anything you need afterward
12:32:14 <EvanR-> removing .ghc
12:32:37 <yasar11732> monochrom: this says newtype is used to wrap existing types into new types: http://learnyouahaskell.com/functors-applicative-functors-and-monoids#the-newtype-keyword
12:32:59 <monochrom> I can agree with "wrap"
12:33:34 <EvanR-> rebuilding everything (again)
12:34:13 <EvanR-> geekosaur: if this works, its going solidify trashing and rebuilding as the goto solution for haskell ;)
12:34:25 <geekosaur> this is why people use sandboxes :)
12:34:49 <EvanR-> yeah, so with a sandbox you have to sit through this rebuild world for each new project?
12:34:51 <monochrom> --user is just a bigger sandbox
12:34:54 <geekosaur> much safer than ending up with snarled tangles in the user cache
12:34:57 <geekosaur> yes
12:35:03 <geekosaur> s/user cache/user packages/
12:35:12 <brbblnch> Cale: Still don't get it! I'll have to think about it some more, and look the skolemization that levi pointed
12:35:45 <yasar11732> monochrom, so a Parser monad is a type that wraps (String -> Maybe (a, String)) ?
12:35:46 <geekosaur> and it's not that hard to precreate a sandbox, although you do need to edit some paths and recache it
12:36:03 <monochrom> I wouldn't say that.
12:36:23 <monochrom> it is "Parser a", not "Parser", that wraps "String -> Maybe (a, String)"
12:36:26 <EvanR-> geekosaur: sounds like a thing that would be nice to make a feature
12:36:32 <EvanR-> rather than a hack
12:36:37 <monochrom> but then, "Parser a" is not a monad. "Parser" is.
12:36:38 <geekosaur> but enough things need their own specific versions of varuious packages that you often end up reinstalling stuff anyway
12:36:45 <geekosaur> it's been discussed
12:36:58 <EvanR-> ;_;
12:37:05 <monochrom> it is no use trying to merge the two sentences.
12:38:11 <yasar11732> So, how would you describe Parser monad?
12:38:34 <geekosaur> (also been mostly discarded because the inevitable "just docker it!" responbse...)
12:38:40 <monochrom> there is nothing to describe, other than writing out the instance code
12:38:49 * EvanR- checks what the docker craze is about
12:39:24 <levi> The Parser monad lets you compose parsers nicely.
12:39:26 <brbblnch> Oh I think I'm slowly getting it
12:39:37 <monochrom> people describe too much (in fact philosophize too much) when they are learning programming.
12:40:04 <monochrom> but then when they become professional programmers, they describe (document) too little.
12:40:11 <brbblnch> Cale, levi: Thanks for the help!
12:40:25 <geekosaur> docker's kinda sandboxing via ephemeral virtual machines
12:40:31 <monochrom> this must be some kind of Dunning-Kruger effect
12:41:08 <EvanR-> monochrom: fairy tales we tell ourselves to sleep well at night
12:41:23 <EvanR-> "a X is a Y"
12:41:23 <monochrom> no, maybe it is a selection bias thing
12:42:05 <EvanR-> where Y is meaningless
12:42:12 <monochrom> people who philosophize too much when learning  programming may be entirely disjoint from people who will be professional programmers
12:43:25 <monochrom> is "Dunning-Kruger effect" meaningless?
12:43:47 <monsieurp> what is actually a professional programmer?
12:43:48 * hackagebot nf 1.0.0.0 - NF data type to statically enforce normal form  http://hackage.haskell.org/package/nf-1.0.0.0 (EdwardYang)
12:43:52 <EvanR-> i wasnt referring specifically to your sentence, but more specifically ot "a Parser monad is a _"
12:44:02 <monsieurp> it's a vague term
12:44:16 <monochrom> I see
12:44:38 <EvanR-> monsieurp: well if you watch professional sports youll learn that professional means specifically that youre getting paid and thats it
12:44:56 <monsieurp> I've ran into people who've been working for over a decade and still don't master the concepts of object oriented programming
12:45:08 <monochrom> OOP is hard to master.
12:45:12 <EvanR-> thats probably more of an issue with OOP
12:45:17 <monochrom> come join FP, it's easier to master
12:45:24 <monsieurp> monochrom: ahahah
12:45:41 <monsieurp> OOP is hard to master... if you don't learn it properly
12:46:05 <EvanR-> OOP isnt even a specific thing
12:46:06 <Rembane> I think you can generalize that to almost everything.
12:46:06 <monochrom> http://www.slideshare.net/ScottWlaschin/fp-patterns-buildstufflt  especially slide 13
12:46:13 <monsieurp> you know, like taking a good book about OOP, sitting down and putting that useful information into your head
12:46:19 <monsieurp> it's really hard for some folks to do that
12:46:57 <monsieurp> Rembane: definitely
12:47:01 <monsieurp> Rembane: it speaks volume though
12:47:11 <EvanR-> oop should be a niche thing
12:47:18 <EvanR-> people act like its a core foundation
12:47:28 <monsieurp> I've taken OOP as an example
12:47:35 <monsieurp> cause it was the first that sprung to mind
12:48:01 <EvanR-> i think people will "master" functional concepts faster, for some version of master
12:48:09 <EvanR-> its just simpler
12:48:41 <exio4> I haven't seen someone come up with a new paradigm "COP", conditional-oriented-programming  
12:48:57 <Rembane> monsieurp: It does indeed.
12:48:58 <exio4> why do we have object oriented programming?
12:49:20 <monochrom> exio4: I have come close: http://www.vex.net/~trebla/humour/book_for_sale.html
12:49:29 <EvanR-> fairy tales promoted to money-making
12:49:36 <EvanR-> rather than engineering 
12:49:42 <monsieurp> ok let's pick another example cause I read tons of code where I always find this mistake, times and times again
12:49:50 <monochrom> behold my "while-loop technology"
12:49:54 <monsieurp> string interpolation in [insert your favourite language here]
12:50:07 <monsieurp> the difference between '' and "" 
12:50:10 <EvanR-> i.e. not haskell
12:50:58 <EvanR-> seems hard to screw that up since a basic test will show its wrong
12:51:23 <exio4> monochrom: damn! I thought I had the best idea ever!
12:51:32 <monochrom> :)
12:52:02 <EvanR-> conditional oriented, isnt that flow charts?
12:52:20 <igniting> > let a = 1 - 1
12:52:21 <lambdabot>  <no location info>: not an expression: ‘let a = 1 - 1’
12:52:30 <EvanR-> > let a = 1 - 1 in a
12:52:31 <lambdabot>  0
12:52:34 <monochrom> Floyd proved flow-charts correct before I was born
12:52:43 <igniting> > :t a
12:52:44 <lambdabot>  <hint>:1:1: parse error on input ‘:’
12:52:58 <monochrom> Hoare turned that into text-mode Hoare triples around the time I was born
12:53:00 <EvanR-> :t let a = 1 - 1 in a
12:53:01 <lambdabot> Num a => a
12:53:36 <igniting> EvanR- thanks! Is there an instance Num a => Show a?
12:53:38 <frerich> EvanR-: I think if programming is your profession, i.e. you're a professiona, you're not only getting paid for it - it means that you have to balance technical decisions with all kinds of non-technical decisions. You're compromising all the time (as opposed to an amateur who can allow himself the luxury of always striving for the technically best solution).
12:53:57 <monochrom> of course, I didn't know that when I was born. I knew that long after I had chosen to go into formal methods, not before.
12:53:58 <igniting> If not, how ghci is able to print a?
12:54:05 <EvanR-> frerich: yeah thats an interesting version of professional, that you "know what youre doing"
12:54:08 <monsieurp> frerich: so all open source developers are amateurs?
12:54:16 <monsieurp> :\
12:54:33 <levi> Ynot has Hoare Types, which bring the power of separation logic to the language's type system.
12:54:37 <c_wraith> igniting: ghci defaults things with a Num constraint to Integer for printing them.  It's part of the extended defaulting rules which ghci enables by default
12:54:54 <EvanR-> frerich: the second part of your version sort of subsumes the money factor
12:55:00 <frerich> monsieurp: According to EvanR-'s definition, I guess so (he's who said that 'being a professional' means that you're getting paid for it).
12:55:51 <EvanR-> frerich: well i said thats what you might learn by watching pro sports, because they certainly dont always know what theyre doing or act nice or whatever people imply by professional sometimes
12:56:02 <monsieurp> frerich: well, I don't really like the term amateur, it sounds like the person you're refering to is also unskilled and incompetent 
12:56:43 <monsieurp> frerich: but hey, to each his own
12:57:41 <levi> "being professional" arose from contexts where there tended to be measures of competence and codes of conduct in place such that one would lose their employment if they were below par.
12:58:22 <EvanR-> which could be a separate thing from "a professional"
12:58:36 <EvanR-> jargon collision
12:59:02 <monochrom> I must be a world-renouned literature author.
12:59:10 <monsieurp> levi: which is not the case anymore (wrt "one would lose their employment if they were below par")
12:59:25 <monochrom> people will still be analysing my writings 20 years after I die.
12:59:52 <EvanR-> you spell it renouned?
13:00:12 <monochrom> I am not sure I spelt it right
13:00:12 <levi> monsieurp: There are still professions where being incompetent or misbehaving will cost you your job.
13:00:22 <EvanR-> still learning british ;)
13:00:23 <Rembane> But not as a working programmer?
13:00:45 <monsieurp> levi: plenty of workplaces out there where one only need connections and a good network to keep one's job
13:01:01 <monsieurp> levi: I've witnessed it
13:01:21 <levi> But I think the usage of 'profession' vs. 'trade' is not as common as it used to be.
13:01:25 <sbidin> I'm writing a binding, and have found myself wanting a global mutable variable. I need it to keep track of a pointer that the C library doesn't expose. So I'm about to do the unsafePerformIO newIORef hack. Is there a better way?
13:01:32 <sbidin> The safe-globals library seems outdated.
13:01:33 <monsieurp> "connections" is the new "competence"
13:01:36 <monsieurp> ;)
13:01:42 <monsieurp> the new 2.0 skill
13:01:45 <EvanR-> levi: professional association vs trade association ...
13:02:09 <EvanR-> still dont get that
13:02:41 <monsieurp> levi: you see.. why do you think business schools exist? seriously
13:02:50 <EvanR-> sbidin: eh, maybe you shouldnt use a global mutable variable
13:03:00 <EvanR-> pass the mutable variable as an argument to the bindings
13:03:50 * hackagebot pred-trie 0.0.6 - Predicative tries  http://hackage.haskell.org/package/pred-trie-0.0.6 (athanclark)
13:04:11 <sbidin> EvanR-: Not sure that applies here. Here's the exact use case: I give the C lib a pointer. It then hides that pointer from me. The next time I give it the pointer, it will overwrite the last one I gave it.
13:04:16 <sbidin> I need to free that last one.
13:04:17 <EvanR-> sbidin: for usability, you could have the client code run in a monad that has this variable in its context
13:04:31 <EvanR-> sbidin: oh, then you can use finalizeres
13:04:37 <EvanR-> foreign pointers
13:04:52 <sbidin> Haskell will know when the C library overwrites the pointer?
13:04:53 <EvanR-> or maybe you dont need to do any of that
13:05:11 <EvanR-> you said it gets overwritten when you use a particular method
13:05:15 <sbidin> Yes.
13:05:19 <EvanR-> so yeah you know
13:05:37 <sbidin> I still need to remember the pointer I gave it.
13:05:42 <sbidin> And the API is all in IO.
13:05:55 <sbidin> With the end user not having any idea about the pointers.
13:06:13 <EvanR-> do you really need to malloc something?
13:06:51 <levi> monsieurp: You seem to be implying that the power of connections vs. competence is a *new* thing. It's always been that way. I'm just speaking to the etymology of a word, not to how "the world works".
13:06:51 <sbidin> Sadly, I think so. The pointer I'm passing in is a FunPtr, to register a callback.
13:07:10 <EvanR-> by itself that doesnt require any mallocing
13:07:30 <sbidin> I still need to free it, no?
13:07:38 <sbidin> Because otherwise it leaks memory.
13:07:40 <EvanR-> free what?
13:07:44 <sbidin> The FunPtr.
13:08:11 <sbidin> See freeHaskellFunPtr: http://hackage.haskell.org/package/base-4.8.0.0/docs/Foreign-Ptr.html
13:08:38 <EvanR-> yeah
13:08:54 <EvanR-> you can free that as soon as C remembers it
13:09:01 <monochrom> oh, it's renowned, not renouned
13:09:26 <sbidin> EvanR-: Damn, really? I had no idea. That's solved, then. :D
13:09:28 <EvanR-> i would have guessed reknowned
13:09:58 <monochrom> I am a world-renowned wrong spelling creator
13:10:42 <EvanR-> sbidin: hold on, maybe that isn't right.
13:11:31 <sbidin> EvanR-: In any case, I'll try it out and see what happens.
13:19:13 <i_rony> heya! guys, is there any example of lambdabot plugin in the wild wich one is triggered by some schedule, instead of channel message/event?
13:22:56 <i_rony> or some kind of loop inside of moduleInit is the only way?
13:22:57 <yasar11732> Hmm, how come I can foldr to construct a tree from a list, but not foldl?
13:23:27 <glguy> Because you're still learning about foldl?
13:24:02 <c_wraith> If the list was infinite foldr might work in more cases than foldl, too - depending on how you build the tree
13:25:00 <yasar11732> if I try foldl on it "Tree a = EmptyTree | Node a (Tree a) (Tree a)" it says it cannot construct the infinite type
13:25:13 <yasar11732> should I include the whole code and error message?
13:25:14 <c_wraith> You probably have the arguments backwards
13:25:23 <c_wraith> :t foldr
13:25:24 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
13:25:26 <c_wraith> :t foldl
13:25:27 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
13:25:41 <c_wraith> note that the functions passed to them take their args in different orders
13:26:06 <c_wraith> You can only use a function interchangeably with them if it's associative with type a -> a -> a
13:27:08 <lpaste> yasar11732 pasted “No title” at http://lpaste.net/131167
13:28:34 <i_rony> or maybe there is existing plugins with some kind of IPC i can reuse?
13:30:58 <verement> yasar11732: try foldl (flip appendTree) EmptyTree ...
13:31:04 <quchen> haasn: Evil sections. :-|
13:33:04 <HairyDude> Are there any examples available of embedding Haskell in an expression quasiquoter?
13:38:21 <EvanR-> ggVGc: im going through all my shit to dump into git-annex and i found some music you wrote a million years ago
13:41:48 <sbidin> EvanR-: Yeah, definitely can't free it immediately. It's the same memory, from both the Haskell and C side.
13:42:33 <sbidin> EvanR-: So far I have a small memory leak, which isn't a big deal. But if I want to fix it, currently I think a global variable is the only way out, short of changing the entire API.
13:43:28 <sbidin> EvanR-: The C lib is to blame for not exposing the pointer I guess.
13:44:51 <EvanR-> sbidin: well like i said, you can keep whatever context you need in a monad that the client code runs in
13:45:30 <EvanR-> youd use an imperative style interface to "register callback"
13:45:58 <EvanR-> if you dont expose re-registering callbacks, well then you dont need to save the pointer
13:46:14 <EvanR-> otherwise you do
13:46:44 <phaazon> my god
13:46:48 <phaazon> ghc compiles so quickly
13:47:09 <arbelos> Has anyone used Data.IxSet? I am wondering how I can select a subset with an index NOT equal to a given key.
13:48:07 <EvanR-> isnt that one of the selectors
13:48:43 <arbelos> there is only getEQ
13:48:56 <arbelos> I could write getOrd2 True False True
13:49:01 <arbelos> but getOrd2 is hidden
13:49:30 <EvanR-> i guess you have to use getLT union with getGT
13:49:48 <simpson> Has anybody worked with bound? I'm trying to repeatedly perform abstractions over a single scope and not having a good time of it.
13:50:18 <EvanR-> but getNEQ would make more sense
13:50:26 <EvanR-> file a complaint
13:50:29 <arbelos> yes, and in this case I can't use a union
13:50:40 <EvanR-> no but you can implement getNEQ
13:50:42 <arbelos> since I am looking up an index from a set
13:51:05 <arbelos> yes.. perhaps a pull request is in order here
13:51:10 <EvanR-> i didnt know you could get the index out
13:52:15 <arbelos> what I mean is that in my type I have something like   data Stuff = Stuff { range :: [Int] }
13:52:41 <arbelos> I want to be able to select Stuff where a given Int appears in the range
13:52:48 <arbelos> which works fine
13:53:07 <EvanR-> so you have a custom index
13:53:32 <ggVGc> EvanR-: hahaha, which song? Probably psychotic rest?
13:53:44 <EvanR-> thats one of them
13:53:45 <simpson> Actually, I can refine my complaint. I want to abstract and instantiate single names at a time. I'm working with an expression language that has a sense of mutable bindings and so I need to apply names one-at-a-time.
13:54:04 <ggVGc> EvanR-: funky?
13:54:09 <ggVGc> (song name=
13:54:10 <ggVGc> )
13:54:13 <EvanR-> yeah
13:54:16 <ggVGc> hah
13:55:10 <akurilin3> question: I have a lib and an exec in a .cabal file. If I apply -O2 to the exec when building it, will the same flag be applied to the library?
13:55:10 <bitemyapp> carter_cloud: compilation question if you've a minute.
13:55:28 <ggVGc> EvanR-: I recorded this a few years ago, if you're interested(not electronic, and I rap in it), https://soundcloud.com/inferred/skappa
13:56:51 <meoblast001> if i declare a type and a function (say func) in some module and then in that same module make that type an instance of a typeclass and use func in a definition for the typeclass, could i get an out of scope error?
13:57:35 <ggVGc> EvanR-: makes me feel a bit honoured my musical crap has been allowed to consume bits on your drive for all this time
13:57:42 <ggVGc> even if it was just out of negligence
13:58:05 <EvanR-> and now its going into git annex
13:58:16 <ggVGc> haha
13:58:35 <ggVGc> I've never used git annext
13:58:48 <EvanR-> i just started using it
13:58:50 <ggVGc> maybe I should
13:59:02 <meoblast001> oh.. it seems func needs to be defined before i make the type an instance of the typeclass
13:59:39 <akurilin3> bitemyapp: I checked persistent as an example, those guys don't bother settings optimizations there
13:59:42 <ion> The ordering in the file doesn’t matter (modulo TH splice weirdness).
13:59:46 <akurilin3> so I'd guess they are decided by the executable
14:00:02 <c_wraith> meoblast001: except in some weird cases involving template haskell, order of declarations shouldn't matter
14:00:03 <ion> ggVGc: nice
14:00:18 <meoblast001> c_wraith: i'm using template haskell and it seems to matter here
14:00:18 <c_wraith> meoblast001: though having circular references between modules is *very* awkward in GHC
14:00:33 <meoblast001> i don't think this thing involves usage of template haskell though...
14:00:39 <meoblast001> i'm only using template haskell for lenses
14:00:41 <c_wraith> meoblast001: ok, then yes.  Order does matter when using template haskell, but that detail is really important.
14:00:58 <meoblast001> c_wraith: does order matter for everything when template haskell is enabled?
14:01:05 <meoblast001> or only for things affected by template haskell?
14:01:14 <c_wraith> meoblast001: I've never figured out the rules for that detail.
14:01:21 <meoblast001> hmm, okay
14:01:26 <bitemyapp> akurilin3: well, they're usually just building it for tests so that makes sense.
14:01:28 <meoblast001> i'll just fix it when GHC bitches
14:09:21 <ggVGc> ion: thanks :)
14:09:37 <Ryanar> Hey guys, what would be an approach to see if a part of a string matches a list of strings
14:10:17 <tlwr> I just spent 15 minutes hunting down a specific XF86 Keybinding for XMonad, is it worth me contacting the maintainer to get them to add it?
14:10:38 <frerich> Ryanar: partOfStr `elem` ["this", "that", "foo", "bar"]
14:11:03 <Ryanar> partOfStr being a part of the string that I choose?
14:11:32 <frerich> Ryanar: partOfStr being the part of the string.
14:11:44 <sagittarian> you mean any part of a sting or a specific part of the string?
14:12:06 <Ryanar> well I can get away with just take 3 string and matching that against the list of strings
14:12:33 <Ryanar> so I can probably just use the `elem`
14:18:13 <HairyDude> Are there any examples available of embedding Haskell in an expression quasiquoter?
14:22:12 <mpickering> HairyDude: you mean something like quote/antiquote? 
14:23:47 <HairyDude> mpickering: in the same way in TH you can do [| $(haskell code goes here) |]
14:24:39 <HairyDude> mpickering: where "haskell code goes here" has type ExpQ or whatever
14:25:40 <frerich> HairyDude: A very simple example is https://github.com/frerich/smartconstructor which is a Haskell package featuring a TH function you invoke like 'makeSmartCtor defaultOptions ''Positive [|(> 0)|]' and that last bit is a function which is spliced into the code.
14:26:38 <HairyDude> frerich: I'm talking about embedding Haskell inside my own quasiquoter.
14:27:59 <HairyDude> frerich: so [myqq|some custom syntax $(here's some haskell) |]
14:28:53 <HairyDude> just recalled that Shakespeare does it, I could go dig around in that
14:29:23 * hackagebot hsc3 0.15.1 - Haskell SuperCollider  http://hackage.haskell.org/package/hsc3-0.15.1 (RohanDrape)
14:34:59 <meoblast001> so... >>= :: m a -> (a -> m a) -> m a
14:35:08 <meoblast001> is there something like m n a -> (a -> m n a) -> m n a
14:35:14 <meoblast001> basically binding two monads at once
14:35:36 <meoblast001> something that i could do in do-notation too
14:37:45 <monochrom> iff "m n" is a Monad instance
14:38:12 <meoblast001> oh.. i guess i could join?
14:38:22 <monochrom> no, I am not talking about that
14:38:54 <monochrom> I am talking about for example m = StateT Int, n = IO, so m n = (StateT Int) IO.
14:38:57 <tulcod> meoblast001: what you're looking for is monad transformers
14:39:28 <teurastaja> im having trouble understanding the state monad i guess because i dont understand how to build quad-linked circular lists, with what functions and how they work
14:39:31 <monochrom> therefore, (>>=) :: StateT Int IO a -> (a -> StateT Int IO b) -> StateT Int IO b fits your requirement where m = StateT Int, n = IO
14:39:49 <meoblast001> tulcod: join wouldn't work in this instance?
14:40:37 <tulcod> meoblast001: just lookup monad transformers.
14:40:53 <meoblast001> okay
14:41:12 <Ryanar> what is the best way to figure out if a string exists in another string ex: "shoe" in the string "a boy and his shoes was a great grand tale!" -> True
14:41:45 <Hijiri> isInfixOf ?
14:41:46 <quchen> > "shoe" `isInfixOf` "a boy and his shoes was a great grand tale!"
14:41:48 <lambdabot>  True
14:41:58 <Ryanar> beautiful
14:42:28 <quchen> That's one way to do it, but probably not the best if your text is longer.
14:42:35 <monochrom> it is not the fastest. (it has the commonly known inefficiency cured by the Knuth-Morris-Pratt algorithm)
14:42:40 <quchen> Data.Text also has `isInfixOf`, which might be more suitable.
14:42:45 <Ryanar> text is pretty short
14:42:59 <teurastaja> can i build doubly-linked circular list structures with Data.STRef?
14:43:19 <teurastaja> or is it better with another monad?
14:43:21 <monochrom> if short, then it's more convenient to just use what's already available :)
14:43:38 <monochrom> yes, you can use STRef for that
14:43:47 <teurastaja> how does it work?
14:44:10 <teurastaja> i dont understand how they use it in the examples i watched
14:44:58 <monochrom> https://wiki.haskell.org/MonadFix has an example using IORef. just change to STRef (or not)
14:45:33 <athan> HList v0.3.4.1 seems broken :\
14:46:02 <teurastaja> can IORef build doubly-linked circular list structures?
14:46:16 <teurastaja> why would i use one over the other?
14:46:48 <arkeet> ST can be used in pure (non-IO) code
14:46:48 <athan> broken on 7.10*
14:46:57 <arkeet> :t runST
14:46:58 <lambdabot> (forall s. ST s a) -> a
14:47:05 <monochrom> IO can be used in effectful (IO) code
14:47:08 <arkeet> (there is no runIO)
14:47:40 <arkeet> (there's a ST transformer too, so you can get the best/worst of both worlds)
14:47:45 <monochrom> (there is no "I want want to print" when not in IO)
14:48:28 <monochrom> every advantage is a disadvantage
14:49:59 <teurastaja> i heard about an algorithm X implementation in haskell that uses trees instead of mutable references through dancing links because apparently you get free node recovery with tree structures
14:50:19 <teurastaja> the codes link is broken so cant see it
14:50:31 <teurastaja> how would that work?
14:50:33 <SrPx> > :t ap
14:50:34 <lambdabot>  <hint>:1:1: parse error on input ‘:’
14:50:56 <monochrom> what is dancing link?
14:51:14 <teurastaja> knuths solution to the exact cover problem
14:52:07 <teurastaja> exactCover -> AlgorithmX -> DancingLinks
14:52:50 <teurastaja> my notation is probably wrong
14:53:34 <teurastaja> but i wanted to emphasize the fact that each is a subset of the other
14:56:36 <teurastaja> its too long for you to read about it and answer me today. all you need to know is i want to make node fields point at each other
14:58:00 <c_wraith> also, exact cover's main use seems to be solving sudoku. :)
14:58:23 <teurastaja> yes its the intent, although there are many other uses
14:58:54 <c_wraith> That was mostly a joke about throwing super-high-power algorithms at relatively trivial uses of it. :)
14:59:14 <monochrom> sudoku is not relatively trivial
14:59:33 <monochrom> if sudoku were relatively trivial, then CNF satisfiability would be, too
15:00:00 <c_wraith> Well, I meant in that the problem size is fixed and relatively small
15:00:15 <teurastaja> i already wrote my program in scheme but since r7rs is just out and implementations cant seem to agree with each other, i may port it to haskell if i understand how to do the same in haskell
15:01:07 <teurastaja> so... how would i set a data field to point to itself? example please
15:01:36 <c_wraith> teurastaja: if you want an alternate haskell sudoku algorithm for comparison, check out chapter 19 of http://www.amazon.com/Pearls-Functional-Algorithm-Design-Richard/dp/0521513383
15:01:53 <c_wraith> teurastaja: it's not going to be *as* fast, but it's actually pretty fast, and quite a bit simpler
15:02:55 <teurastaja> i already wrote the program. all i need to do is port it in a purely functional world
15:03:11 <teurastaja> im not seeking other algorithms
15:03:47 <teurastaja> between trees, STRefs and zippers, which would be best here?
15:04:07 <monochrom> I guess this is why people joke about programmers with "if a programmer designs a toaster, it will have a plugin framework and can send email"
15:04:24 * hackagebot hails 0.11.2.1 - Multi-app web platform framework  http://hackage.haskell.org/package/hails-0.11.2.1 (DeianStefan)
15:05:47 <teurastaja> so... which should i learn about first to implement dancing links in haskell? zippers, trees or STRefs?
15:07:22 <teurastaja> id like to peek at this code but cant: https://wiki.haskell.org/Sudoku#Only_guessing_without_dancing_links
15:07:51 <teurastaja> both links are dead
15:24:25 * hackagebot octohat 0.1.4 - A tested, minimal wrapper around GitHub's API.  http://hackage.haskell.org/package/octohat-0.1.4 (stackbuilders)
15:29:25 * hackagebot ssh 0.3.0.1 - A pure-Haskell SSH server library.  http://hackage.haskell.org/package/ssh-0.3.0.1 (GaneshSittampalam)
16:05:13 <Cale> Apparently my ISP saw fit to give me a birthday Internet, TV and phone outage.
16:06:09 <arkeet> ~rogers~
16:06:24 <Cale> rogers indeed
16:07:13 <Cale> It's convenient to have the Internet go down only to find out you can't even call to complain :D
16:11:10 <Hijiri> What is the usual way to store "application data"-type files?
16:11:34 <hpc> what kind of data?
16:12:12 <Hijiri> it's a chatbot for some chat thing, but it's a library that you pass pluginey things to them
16:12:39 <Hijiri> I want to give each of them a place to store data
16:13:19 <Hijiri> not really pluginey
16:13:26 <geekosaur> https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code
16:13:27 <Hijiri> you can't plug them in, you have to compile it together
16:13:46 <Hijiri> thanks
16:14:08 <Hijiri> can a data-files entry be a directory?
16:19:32 <hexagoxel> Hijiri: i think not (yet), see https://github.com/haskell/cabal/pull/2522
16:19:58 <Hijiri> ok
16:20:52 <ronh> how to split list into parts of 2
16:21:28 <pavonia> :t chunksOf
16:21:29 <ronh> [1,2,3,4] -> [[1,2],[3,4]]
16:21:29 <lambdabot> Int -> [e] -> [[e]]
16:21:44 <arkeet> what about [1,2,3,4,5,6]
16:21:47 <arkeet> what about [1,2,3]
16:21:56 <arkeet> what do you mean exactly?
16:22:13 <ronh> > chunksOf 2 [1..4]
16:22:15 <lambdabot>  [[1,2],[3,4]]
16:22:17 <ronh> > chunksOf 2 [1..5]
16:22:18 <lambdabot>  [[1,2],[3,4],[5]]
16:23:00 <ronh> I think it does what I want. why would [1,2,3,4,5,6] be special though?
16:23:14 <arkeet> it was unclear what you wanted.
16:23:21 <arkeet> did you want to break it up into pieces of length 2?
16:23:24 <arkeet> did you want to divide it into 2 lists?
16:23:36 <ronh> ah.. into pieces of length 2
16:23:44 <arkeet> okay. then chunksOf is the thing
16:23:45 <eacameron> I've seen examples where packages using Stackage LTS, etc. don't do much to explicitly name versions in the cabal file. Is there some way to force a particular stackage version in the cabal file?
16:25:00 <dcoutts> eacameron: the .cabal file is designed to leave the versions somewhat flexible, for the person building. But as the person building you can certainly pin down versions, e.g. in a local cabal.config file.
16:25:22 <dcoutts> e.g. that's what cabal freeze does
16:25:53 <dcoutts> and that cabal.config file can be checked in to source control and shared with other people hacking on the thing
16:26:46 <eacameron> dcoutts: Here's what is messing with me: https://github.com/fpco/stackage-cli/blob/master/stackage-cli.cabal#L35 (no cabal.config) checked in
16:26:55 <eacameron> ** (no cabal.config checked in)
16:27:12 <dcoutts> eacameron: that package is assuming a particular build environment
16:27:38 <eacameron> dcoutts: ah, so not an exemplar
16:29:02 <dcoutts> eacameron: that approach is ok if you're always using the same environment
16:29:48 <eacameron> dcoutts: I have a hard time seeing how stackage-cli will always be built in the same environment if it's available on hackage
16:29:57 <dcoutts> me too
16:33:07 <eacameron> dcoutts: ok so I'm not going crazy
16:33:25 <eacameron> dcoutts: being a noob means I don't know when to follow and when not too
16:34:36 <dcoutts> eacameron: my recommendation is to think about other people's environments when writing the .cabal file, and you own choices when you make your sandbox or local cabal.config file
16:35:15 <dcoutts> so in principle you want to allow other people to be able to use your package in as wide a range of versions as practically possible, while making sure it still works
16:35:26 <dcoutts> though that's easier said than done
16:36:49 <eacameron> dcoutts: that makes sense; will do
16:36:56 <eacameron> thanks, btw
16:46:04 <SrPx> "class Functor f => Additive f where" doesn't that mean any Functor is also an Additive? If so, why `data Box a = Box a deriving Functor; ... Box 1 ^+^ Box 2` won't work?
16:46:26 <Hijiri> it just means all Additives have to be Functor
16:46:35 <Hijiri> instance Functor f => Additive f would mean what you said
16:46:38 <monochrom> "=>" does not mean "implies"
16:46:49 <SrPx> Ahhh. Okay, my bad.
16:47:02 <Welkin> it is the lambda arrow in js6...
16:47:35 <Welkin> they tried to copy haskell, but tried to make it look like they weren't
16:49:05 <SrPx> So, is there any typeclass that implements a generic "zipWith", the same way Functor implements a generic "map"?
16:49:33 <homovitruvius> >
16:49:40 <SrPx> If I'm not mistaken, Foldable would be enough, right.
16:49:59 <monochrom> no, Functor and lambda are enough
16:50:12 <monochrom> no, nevermind
16:50:15 <solirc> orion: Regarding what you and dmj' where discussing earlier, Hspec allows you to use QuickCheck, SmallCheck and HUnit in the same test suite
16:51:06 <solirc> orion: stripe doesn't seem to use automatic test discovery, which is one of Hspec's distinguishing features
16:51:57 <solirc> orion: you may want to look at https://github.com/hspec/hspec-example for an example of how to set things up
16:55:08 <solirc> orion: QuickChek is an awesome library, but it is most commonly used in combination with some other testing library (e.g. Hspec, HTF, tasty, test-framework)
17:03:53 <teurastaja> what is _|_ ?
17:04:11 <teurastaja> :t _|_
17:04:12 <lambdabot> parse error on input ‘|’
17:05:01 <Cale> teurastaja: _|_ is the mathematical value assigned to all expressions whose evaluation doesn't terminate normally
17:05:13 <Axman6> called 'bottom'
17:05:38 <teurastaja> how do you use it?
17:05:43 <Cale> The name 'bottom' comes from the fact that each type is partially ordered by definedness in a particular way
17:06:14 <Cale> There's an implementation of bottom called undefined, but anything which loops forever would also be considered bottom
17:06:33 <acowley> I thought it was a Midsummer Night's Dream reference
17:06:34 <Axman6> you don't, it's a symbol that represents things like undefined and fix id (things which don't return). it's not actually a haskell opetator or anything
17:06:41 <Cale> > undefined -- this loops forever, but a bit more quickly ;)
17:06:43 <lambdabot>  *Exception: Prelude.undefined
17:07:00 <Axman6> ⊥ <- how it's usually written
17:07:02 <Cale> > let x = x + 1 in x
17:07:06 <lambdabot>  mueval-core: Time limit exceeded
17:07:12 <Cale> ^^ the value of that expression is also _|_
17:08:06 <teurastaja> hmm...
17:08:55 <Axman6> https://wiki.haskell.org/Bottom
17:08:56 <Cale> The definedness ordering I'm talking about is defined a bit differently on each type, but generally the intuition is that x <= y whenever one could replace occurrences of _|_ in x with some values of appropriate types in order to obtain y.
17:09:11 <Cale> So, for instance, we could consider [Bool]
17:09:38 <Cale> We have _|_ at the bottom of the ordering, and then immediately above it, there are [] and _|_ : _|_
17:09:57 <Cale> nothing else lies above [], as it's totally defined
17:10:26 <Cale> immediately above _|_ : _|_, there's True : _|_, False : _|_ as well as _|_ : [] and _|_ : (_|_ : _|_)
17:11:16 <teurastaja> : as in cons?
17:11:20 <Cale> yes
17:11:40 <Cale> > head (1 : undefined)
17:11:42 <lambdabot>  1
17:12:12 <Cale> It's in order to be able to deal with expressions like this one that we need some formal representation for nontermination.
17:12:29 <teurastaja> :t undefined
17:12:30 <lambdabot> t
17:12:41 <teurastaja> ?
17:12:46 <Cale> undefined has any type at all
17:12:57 <Cale> > undefined :: Integer
17:12:59 <lambdabot>  *Exception: Prelude.undefined
17:13:02 <Cale> > undefined :: String
17:13:04 <lambdabot>  "*Exception: Prelude.undefined
17:13:55 <Cale> ^^ notice the quote which managed to be printed before 'show' actually pattern matched the String and caused the exception.
17:14:30 * hackagebot karver 0.1.2 - A simple template engine, inspired by jinja2  http://hackage.haskell.org/package/karver-0.1.2 (JeremyHull)
17:14:40 <Cale> This means that _|_ is not a fixed point of the show function on String
17:14:46 <Cale> > fix show
17:14:48 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
17:15:08 <Cale> so the least-defined fixed point is actually a bit fancier :)
17:15:31 <Cale> Whenever f _|_ = _|_, we'll have fix f = _|_
17:15:37 <semigroup> Hi, I'm trying to do some UDP stuff using a Handle (instead of a Socket). When I call hFlush on the handle, I get "*** Exception: <socket: 18>: hFlush: invalid argument (Destination address required)". How do I go about setting the handle up in such a way that it has a destination address?
17:15:40 <teurastaja> > fix read
17:15:44 <lambdabot>  mueval-core: Time limit exceeded
17:16:01 <Cale> But when f _|_ is not _|_, fix f will be some more-defined value (possibly still not fully defined, but often so)
17:16:13 <Cale> 1 : undefined  is not the same list as  undefined
17:16:16 <Cale> because:
17:16:19 <Cale> > head undefined
17:16:20 <lambdabot>  *Exception: Prelude.undefined
17:16:25 <Cale> > head (1 : undefined)
17:16:26 <lambdabot>  1
17:16:50 <Cale> So the least defined fixed point of the function (1 :) is not _|_
17:16:55 <Cale> > fix (1 :)
17:16:57 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:17:03 <Cale> Rather, it's an infinite list of 1's
17:18:24 <Cale> semigroup: hmm, how are you creating the Handle? Did the connection get closed or something?
17:19:19 <Cale> I haven't done all that much direct network programming in quite some time, but from the little I did, I don't recall seeing that error.
17:20:10 <semigroup> Cale: I actually just figured it out– I forget to call 'connect' on the socket with the destination address.
17:20:28 <Cale> ah, okay
17:20:39 <Cale> yeah, if it's disconnected, then that would make sense
17:20:41 <teclo-> Hi I'm doing aptitude install haskell-platform and I get: Need to get 110 MB of archives. After unpacking 567 MB will be used.
17:20:52 <teclo-> sorry but, 567 MB for an interpeter/compiler ?!
17:21:03 <Cale> teclo-: and a bunch of libraries
17:21:05 <semigroup> I'm used to using higher-level abstractions for networking, generally speaking. Not super familiar with low-level udp stuff
17:21:28 <Cale> teclo-: But yeah, GHC has a lot of stuff in it.
17:21:52 <teclo-> Cale: ah, ok
17:22:31 <Cale> teclo-: Look at it this way, it's about the same as a single episode of a TV show :P
17:23:31 <Cale> teclo-: I suspect that a lot of the size comes from the amount of static linking that's going on, but I've never really looked into it.
17:24:48 <teclo-> ah;..
17:25:27 <teurastaja> > fix ($ fix)
17:25:29 <lambdabot>      Occurs check: cannot construct the infinite type:
17:25:29 <lambdabot>        b ~ ((a -> a) -> a) -> b
17:25:29 <lambdabot>      Expected type: (((a -> a) -> a) -> b) -> ((a -> a) -> a) -> b
17:25:53 <teurastaja> > fix ($)
17:25:54 <lambdabot>      No instance for (Typeable a0)
17:25:54 <lambdabot>        arising from a use of ‘show_M37799004849609293946580’
17:25:55 <lambdabot>      In the expression:
17:26:00 <Cale> :t fix
17:26:01 <lambdabot> (a -> a) -> a
17:26:10 <Cale> > fix id
17:26:13 <lambdabot>  mueval-core: Time limit exceeded
17:26:42 <Cale> Kind of weird that it gave an error for fix ($)
17:26:45 <teurastaja> what happens if you use fix with continuations?
17:26:51 <Cale> :t ($)
17:26:52 <lambdabot> (a -> b) -> a -> b
17:26:57 <Cale> oh, I know why
17:27:06 <Cale> It's because the Show instance wants a Typeable instance
17:27:28 <teurastaja> lol
17:27:50 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
17:27:51 <lambdabot>  3628800
17:28:57 <Cale> It's possible to express pretty much all recursive things via fix (there are some issues with polymorphic recursion though)
17:29:54 <teurastaja> what trickery could be done with continuations and fix?
17:30:11 <monochrom> I usually ignore polymorphic recursion (since I keep forgetting it)
17:30:43 <monochrom> however, mutual recursion is still within the reach of fix.
17:30:52 <Cale> teurastaja: Well, you can use it along with callCC in order to get the current continuation.
17:31:50 <Cale> :t callCC (\c -> return (fix c))
17:31:51 <lambdabot> MonadCont m => m (m b)
17:32:03 <monochrom> my http://www.vex.net/~trebla/haskell/cont-monad.xhtml has an example
17:33:30 <Cale> That's basically a way to get a first class label of sorts.  do label <- callCC (\c -> return (fix c)); liftIO (putStrLn "Hello!"); label
17:33:41 <Cale> will be an infinite loop that prints Hello! forever
17:35:35 <Cale> (`runContT` return) $ do label <- callCC (\c -> return (fix c)); liftIO (putStrLn "Hello!"); label -- you can try it like this
17:35:45 <Cale> after importing Control.Monad.Cont
17:36:41 <Cale> @let getCC = callCC (return . fix)
17:36:43 <lambdabot>  Defined.
17:36:55 <arkeet> :t getCC
17:36:56 <lambdabot> MonadCont m => m (m b)
17:37:05 <Cale> You can also define a variant which lets you pass a value back in time
17:37:37 <Cale> @let getCC' x0 = callCC (\c -> let f x = c (x, f) in return (x0, f))
17:37:39 <lambdabot>  Defined.
17:37:42 <teurastaja> ok havent studied continuations as monads yet i come from scheme
17:38:02 <arkeet> :t getCC'
17:38:03 <lambdabot> MonadCont m => t -> m (t, t -> m b)
17:39:04 <Cale> This one I could probably demo without needing some kind of state or IO
17:39:10 <Cale> let's see...
17:40:40 <Cale> > (`runCont` id) $ do ((n,xs), label) <- getCC' (0,[]); if n < 10 then label (n+1, n:xs) else return (n,xs)
17:40:42 <lambdabot>  (10,[9,8,7,6,5,4,3,2,1,0])
17:41:51 <Cale> So, here, (n,xs) is initially (0,[]), and if n < 10, we jump back to the label, only with an incremented n, and with n consed to the beginning of xs
17:42:42 <Cale> So Cont and fix basically gives you goto with state :P
17:42:52 <Cale> Only, no forward jumping
17:43:48 <teurastaja> ok i think i need some sleep im beginning to see chinese characters. thanks for the explanations. wait, you mean no escape continuations?
17:44:25 <Cale> Oh, you can escape, I just mean you can't get hold of a continuation you've yet to see like this.
17:44:26 <monochrom> I know Chinese. perhaps it is why I understand Cont. :)
17:45:38 <Cale> callCC gives you escaping, but you have to use it explicitly, and so you can't get hold of some continuation far in the future, like labels and goto let you do.
17:46:21 <teurastaja> Cale: do you mean assembly beats all languages?
17:46:25 <Cale> (unless you've explicitly wrapped everything intervening into a block)
17:46:33 <Cale> heh
17:46:50 <Cale> If the competition is to be as potentially confusing as possible, yeah, probably.
17:47:21 <teurastaja> lol
17:48:07 <teurastaja> no i mean for its jumps and labels
17:49:26 <teurastaja> can you have that in haskell?
17:49:45 <Cale> Well, not as straightforwardly.
17:50:07 <Cale> You can set up any kind of control flow scheme you like if you're willing to take enough trouble.
17:50:18 <hpc> the better question is why you would want to
17:50:38 <Cale> It's hard to do it *in this way*, as a monad
17:50:41 <hpc> there's not much you gain, for the cost of reasoning about your code
17:51:06 <Cale> Probably impossible... however...
17:51:13 <Cale> Wait a minute...
17:51:25 <Cale> Let me try using MonadFix with getCC
17:51:26 <arkeet> recursive do
17:51:27 <arkeet> yeah
17:51:29 <Cale> yeah
17:51:39 <arkeet> oh dear
17:52:33 <teurastaja> do you have a call-with-current-continuation that allows non-local exits?
17:53:14 <Cale> No instance for (Control.Monad.Fix.MonadFix (ContT () m0)) -- hmmm
17:54:14 <teurastaja> because i think it can be implemented as such
17:54:35 <Cale> teurastaja: What do you mean by that? You can execute any ContT action of the appropriate type inside a callCC
17:54:47 <arkeet> yeah, no MonadFix for ContT :-(
17:54:59 <Cale> arkeet: :(
17:55:10 <arkeet> or Cont
17:55:28 <Cale> Maybe there is a way to implement MonadFix for ContT, but whoever wrote the library was just like "okay, fuck this" :D
17:55:55 <Cale> Let's see if djinn can do it...
17:55:59 <Cale> :t mfix
17:56:00 <lambdabot> MonadFix m => (a -> m a) -> m a
17:56:14 <arkeet> @djinn (a -> (a -> r) -> r) -> (a -> r) -> r
17:56:14 <lambdabot> -- f cannot be realized.
17:56:25 <arkeet> uh
17:56:25 <Cale> oh, right, djinn is bad at recursion
17:56:28 <arkeet> yeah 
17:56:46 <arkeet> even so.
17:56:54 <arkeet> I don't think you can write that.
17:57:01 <arkeet> in a nontrivial way.
17:57:18 <Cale> yeah, there's no way
17:57:30 <Cale> hmm
17:57:59 <Cale> I wonder if a fancier Cont monad could do it
17:59:03 <simpson> Yeah, it looks like you'd need to pluck an `a` out of thin air.
17:59:35 <arkeet> @djinn (a -> (a -> a) -> a) -> (a -> a) -> a
17:59:35 <lambdabot> -- f cannot be realized.
17:59:46 <Cale> I bet edwardk knows :D
18:00:06 <arkeet> still doesn't look possible.
18:00:07 <monochrom> I heard that it can't be done
18:01:19 <Cale> monochrom: A monad supporting MonadFix and some sort of callCC at the same time?
18:01:46 <teurastaja> i dont know what MonadFix is
18:01:51 <arkeet> :t mfix
18:01:52 <lambdabot> MonadFix m => (a -> m a) -> m a
18:01:54 <arkeet> that is MonadFix
18:01:59 <teurastaja> but i know call/cc
18:01:59 <monochrom> no, more specifically "no MonadFix for Cont"
18:02:29 <Cale> yeah, the impossibility of that is quite plausible, given the types
18:04:51 <teurastaja> what do you mean by MonadFix with call/cc?
18:05:46 <Cale> teurastaja: Well, MonadFix lets you refer to the results of computations in a monad which haven't happened yet
18:06:25 <teurastaja> so MonadFix is a continuation reification?
18:06:30 <Cale> e.g. we could do forward jumps after all
18:07:12 <Cale> because we could write something like  do rec { label; liftIO (putStrLn "this won't happen"); label <- getCC }; return ()
18:07:51 <Cale> Actually, I have no idea if that would actually work as advertised, but it'd be worth trying :D
18:08:25 <Cale> However, there's no instance of MonadFix for ContT, and it's apparently impossible to write one, so you'd need some other implementation of a continuation monad to make things like that possible.
18:08:51 <jdreaver> Does anyone have any resources for financial time series modeling in Haskell? I am using Python right now (because pandas is awesome and fast), but I would love to use Haskell for this project.
18:10:55 <Cale> jdreaver: I'm fairly certain that companies exist who are doing just that sort of thing in Haskell, but I don't know what if anything of their implementations of it are available.
18:11:34 <jdreaver> I figured :/ I tried contacting FPComplete to see if they had any open-sourced components of their trading platform, but they didn't respond.
18:11:52 <teurastaja> well if you just used \ continuation -> ($) continuation?
18:11:54 <jdreaver> I guess the financial guys consider their Haskell code as an edge, and want to keep it secret.
18:15:11 <Cale> jdreaver: Perhaps there's a specific mathematical thing you need?
18:15:56 <Cale> jdreaver: There's a fairly decent amount of stuff on Hackage that I expect could be useful for that kind of domain
18:17:14 <Cale> http://hackage.haskell.org/package/statistics is a pretty high quality package for instance
18:17:42 <jdreaver> I just wanted to see examples of how people sttructure time series data while still being efficient. I was thinking of storing each series as two vectors, where one holds the times and the other holds the values. Then, I would create functions to operate on those vectors (combine with interpolation, index by time range, etc). I just didn't want to reinvent the wheel too much if a financial time series package already existed.
18:18:01 <enthropy> that one is missing even ARIMA
18:18:38 <jdreaver> I also am not an expert Haskeller, so I didn't want my homegrown solution to be too slow either, especially since I am spoiled with the high quality Python libs like numpy and pandas
18:18:48 <jdreaver> That statistics lib looks useful, thanks Cale!
18:19:15 <Cale> Yeah, it's not like R or anything, but what it does, it does reasonably well :)
18:25:15 <jdreaver> I love Haskell, but it is hard to decide to use it over Python in my work because I do so much numerical computing and GUI programming. I guess if I contribute to some libraries to advance Haskell in those areas then I will end up learning a lot of Haskell along the way, which is nice :)
18:26:32 <AshyIsMe> wxhaskell is pretty nice for some basic stuff
18:26:48 <AshyIsMe> ive been messing around with wxhaskell and diagrams recently
18:26:56 <AshyIsMe> https://github.com/AshyIsMe/diagramming
18:28:37 <AshyIsMe> fun doesnt make it battle tested though...
18:29:14 <jdreaver> Neat! I've been messing with hsqml since I have Qt experience. It is a really cool library, and the maintainer is great.
18:33:25 <hodapp> hsqml? that... is too many similar-looking letters.
18:33:30 <AshyIsMe> nice, i havent done much with qt so just went with wxhaskell for simplicity's sake
18:34:37 <AshyIsMe> it shall from here on out be pronounced "husqmal" haha
18:34:38 <jdreaver> Haha. hodapp, "hs" stands for Haskell, and QML is a language built on top of the Qt framework for declaratively building UIs.
18:47:54 <hodapp> It looks like someone threw SQL, HTML, SGML, and Haskell into a blender.
18:49:44 <kadoban> I looked into QML very briefly. I think I stopped when I realized that all of the examples I saw … didn't look at all like GUIs I expected. There didn't seem to be any of the usual OS-looking-widgets used at all.
18:49:56 <kadoban> I'm not sure if that's actually correct or if I just gave up too quickly, heh.
18:50:11 <hodapp> kadoban: QML was made originally for mobile.
18:51:22 <kadoban> hodapp: Right … but I don't generally care about mobile, at least while doing haskell. So it doesn't seem to look right at all :-/
18:51:54 <kadoban> (Don't get me wrong, I'd love to do mobile stuff with haskell, but since that doesn't really work out as far as I know …)
18:52:10 <hodapp> kadoban: well, all I mean is that that's *why* it looks that way, most likely.
18:52:15 <kadoban> Right
18:53:42 <kadoban> But then again I haven't really found a better way to do a GUI in haskell either, maybe I should look into that again sometime …
19:13:22 <carter> bitemyapp: what was the compilation question?
19:14:35 * hackagebot matrices 0.4.0 - native matrix based on vector  http://hackage.haskell.org/package/matrices-0.4.0 (kaizhang)
19:15:59 <fuzzyhorns> for development, should i be sandboxing ghcmod, hdevtools, hlint, etc?
19:16:03 <fuzzyhorns> i work in vim
19:16:20 <chug> if i use nix pm ,i can have primitive-0.5 and primitive-0.6 both?
19:16:48 <fuzzyhorns> because i am finding (i have them installed globally) that some projects seem to want to force reinstall in a sandbox local to that project
19:17:49 <Ryanar> when you are defining types and data in a haskell file, what should be the ordering?
19:18:10 <Ryanar> should you put the types at the top followed by the data definitions?
19:18:20 <Ryanar> especially if the data definitions use the type defs?
19:21:43 <pavonia> From the compiler's perspective the order doesn't matter
19:23:21 <Ryanar> well right, I am going for human readability
19:25:56 <pavonia> When you write bigger modules, you usually arrange types and functions by topics in the file, so you get both interspersed
19:26:19 <pavonia> or sections or what they are called in haddock
19:26:20 <Ryanar> ah I see
19:26:50 <Ryanar> yeah I haven't learned about how to use haddock, but I am copying the commenting format that established haddock projects use in the hopes that I will have done it right
19:35:22 <SrPx> Linear's "Additive" class has a generic implementation. Yet, "data Foo = Foo a deriving Generic; main = print $ Foo 1 ^+^ Foo 2" doesn't work (No instance for (Additive Foo)). Why?
19:36:42 <BMeph> SrPx: Um, 'cause you didn't have a "deriving Additive" statement there?
19:37:17 <SrPx> BMeph: if I add "Additive" to the deriving list, it will say "‘Additive’ is not a derivable class"...
19:39:14 <nshepperd> you need DeriveAnyClass for that
19:39:33 <nshepperd> or if the generic implementation is the default, just write 'instance Additive Foo'
19:43:53 <monochrom> w00t new Cartesian Closed Comic https://ro-che.info/ccc/26
19:44:31 <SrPx> Now I have this: http://lpaste.net/131190
19:45:05 <SrPx> There is a pragma, #ifdef USE_GHC_GENERICS on the fine https://hackage.haskell.org/package/linear-1.18.0.1/docs/src/Linear-Vector.html#E
19:45:09 <SrPx> Maybe this is related?
19:46:33 <Welkin> monochrom: is that guy with the beard and mustache supposed to be edwardk ?
19:46:47 <monochrom> I don't know
19:52:08 <Tortis> I have a list comprehension that that generates pairs with type :: (String, IO [String]), but I would like it to generate (String, [String]). Any tips on how I can do this?
19:52:26 <Hijiri> Tortis: what does the comprehension look like?
19:52:32 <Tortis> The list comprehension looks like this : [ (id, f id) | id <- ids]
19:52:39 <Hijiri> what is f
19:52:43 <Hijiri> and ids
19:52:47 <Tortis> f has type :: String -> IO String
19:52:51 <Tortis> all strings
19:53:01 <Tortis> ids is [String]
19:53:06 <Hijiri> well that's a problem, because you can't go from IO [String] to [String]
19:53:15 <Hijiri> But you could get IO (String, [String])
19:53:22 <Tortis> that's what I would like
19:54:01 <Tortis> Is it someting with fmap?
19:54:02 <Hijiri> fixify (strings, iostrings) = fmap ((,) strings) iostrings would work
19:54:04 <Hijiri> yeah
19:54:13 <Hijiri> actually I haven't tested that
19:54:14 <conehead> :t sequence
19:54:15 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
19:54:29 <conehead> :t sequence :: (String, IO [String]) -> IO (String, [String])
19:54:30 <lambdabot> (String, IO [String]) -> IO (String, [String])
19:54:41 <Hijiri> oh yeah, you would need to sequence after doing things
19:54:50 <Hijiri> oh
19:54:55 <Hijiri> you could sequence twice
19:55:11 <Tortis> Sequence twice?
19:55:11 <Hijiri> ignore my answer, conehead's is nicer
19:55:19 <Tortis> oh I see
19:55:20 <michaelt> SrPx: it looks like you need to write an Applicative instance and that you need to define zero after 'instance Additive Foo'
19:55:35 <Hijiri> you could use mapM with sequence
19:55:42 <Hijiri> instead of sequence twice
19:56:07 <Hijiri> :t mapM sequence
19:56:08 <lambdabot> (Monad m, Traversable t, Traversable t1) => t (t1 (m a)) -> m (t (t1 a))
19:56:43 <Hijiri> :t mapM sequence :: [(String, IO [String])] -> IO [(String, [String])]
19:56:44 <lambdabot> [(String, IO [String])] -> IO [(String, [String])]
19:57:36 <Ryanar> could anyone give me some direction on doing some error checking in a program, I am looking to do something along the lines of
19:57:47 <Ryanar> f :: a -> Either a SomeError
19:58:31 <Ryanar> to do that do I need to define a StateT Monad?
19:58:35 <Hijiri> :t Left
19:58:36 <lambdabot> a -> Either a b
19:59:06 <Hijiri> the convention, though, is that errors go with Lefts
19:59:10 <michaelt> SrPx: like so http://lpaste.net/4447667792988078080
19:59:26 <Ryanar> ok so given that it will be different functions.. like f :: String -> Either SomeError (String, String) 
19:59:26 <kadoban> Ryanar: The Left part is usually the error side. Right is the "not error" side.
19:59:31 <Ryanar> sorry yeah
19:59:48 <Ryanar> so I just need to say Left
19:59:51 <Ryanar> and right
19:59:55 <Ryanar> for my returns
20:00:20 <Hijiri> yeah
20:00:21 <kadoban> Yep. There's some nice ways to do that idiomatically, but yeah it comes down to that.
20:00:58 <Eldrad> edwardk: You did wait for the tests to pass before accepting my pull request? :P
20:01:14 <edwardk> Eldrad: nope =P
20:01:40 * edwardk is a trusting sort
20:02:06 <SrPx> michaelt: interesting, thank you!
20:02:06 <kadoban> Ryanar: (Just to be clear, the "nice ways" I mean are using the Monad, Functor, Applicative, etc. instances for 'Either e')
20:02:07 <Eldrad> k! :D They did pass locally!
20:02:08 <edwardk> i figured i'd get it merged in now to signal a clear intention to accept it, then deal with fallout later
20:02:15 <SrPx>  Is there any way to derive that Applicative instance automatically?
20:02:53 <Ryanar> kadoban, alright, I am going to try and build up to that, but for now I will probably just use the quick and dirty way
20:03:14 <arkeet> SrPx: there isn't, but there should be.
20:03:16 <kadoban> Ryanar: Yeah, a good idea in general.
20:03:29 <SrPx> arkeet: uhm?
20:03:37 <arkeet> there isn't.
20:03:43 <Ryanar> especially because I -just- learned Monads and am still super unclear about them :P
20:03:45 <SrPx> there should be?
20:04:11 <arkeet> as in someone should make it derivable.
20:04:43 <SrPx> has nobody bothered yet?
20:04:48 <arkeet> no.
20:05:46 <Hijiri> would DeriveApplicative give a zippy sort of instance?
20:05:48 <Eldrad> edwardk: I'm probably going to make a RealFrac instance for Log a tomorrow. And maybe a RealFloat. Also am I crazy for wanted a version which supports negative numbers?
20:05:51 <arkeet> yeah, that's what I have in mind.
20:06:11 <Eldrad> *wanting
20:06:27 <arkeet> if you have something that's just a composite of applicatives applied to the type parameter, or a product of such things
20:06:28 <edwardk> Eldrad: instances are welcome =)
20:06:40 <arkeet> there's only one obvious way to define an Applicative instance.
20:07:00 <edwardk> some of the corner cases were deliberate, because i wanted graceful underflow for a particular application in the code this was ripped from, but its not worth chasing after that usecase too much
20:07:14 <edwardk> (it was used in "approximate" originally)
20:08:08 <edwardk> since we knew all the quantities were between 0 and 1 that were being combined the underflow behavior going gracefully to negInf was key to avoiding some checks, but meh
20:08:40 <edwardk> not using approximate any more though, and i never ran into any of the corner cases i was working around anywyas
20:08:57 <SrPx> Is this helpful somehow? https://hackage.haskell.org/package/emgm-0.4/docs/Generics-EMGM-Functions-ZipWith.html
20:08:59 <Eldrad> Right makes sense. I'm using it for testing Approximates. I'm not hugely attached to those corrections... but just caused me to scratch my head when I saw them.
20:10:15 <SrPx> Also the default applicative instance for lists seems to be different from what we would expect
20:10:24 <edwardk> Eldrad: you now have commit access to log-domain, so if you see something else go nuts
20:10:38 <edwardk> SrPx: does the only thing it can that is compatible with the Monad.
20:10:47 <edwardk> SrPx: if you were looking for ZipList it also exists
20:11:09 <edwardk> > liftA2 (,) [1,2] [3,4]
20:11:09 <Eldrad> edwardk: okay
20:11:11 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
20:11:24 <michaelt> arkeet: isn't there a Monad instance for Foo, and thus a different Applicative? http://lpaste.net/282586531426729984
20:11:25 <edwardk> ^- computes the cartesian product
20:11:30 <lpaste> ryanar pasted “Using the Maybe Monad” at http://lpaste.net/6271900339591446528
20:11:38 <edwardk> > liftA2 (,) (ZipList [1,2]) (ZipList [3,4])
20:11:39 <lambdabot>  ZipList {getZipList = [(1,3),(2,4)]}
20:11:43 <edwardk> ^- zips
20:12:00 <Ryanar> alright so I am trying to understand the process for using the Maybe Monad
20:12:18 <arkeet> michaelt: it's the same applicative.
20:12:59 <arkeet> michaelt: expand out the definition of 'ap' for your Monad instance and you will see it's the same.
20:12:59 <edwardk> Eldrad: i've been meaning to add some good computations for things like logGamma in there as well
20:13:02 <michaelt> I was wondering...
20:13:16 <michaelt> arkeet: yeah I'm trying it, just a sec
20:13:20 <edwardk> Eldrad: or as it is known in the Log world, 'gamma' =)
20:16:02 <kadoban> Ryanar: Sounds like a good thing to understand. Going okay so far? If it's confusing, the Functor and Applicative instances for Maybe might be a good way to ramp up.
20:16:23 <Ryanar> I mostly think I am struggling to see how to add strings with Just
20:16:44 <Ryanar> for numbers it would be Just (+3) <*> Just 4 with Control.Applicative imported
20:17:09 <Ryanar> or I could try fmap (+3) Just 4
20:17:28 <kadoban> Sounds right so far
20:17:30 <michaelt> arkeet: Right; my suspicion was coming from ZipList/List, but this is more remote than it seems from Foo x y z
20:17:45 <Ryanar> but how would I do it with strings
20:18:02 <kadoban> Ryanar: Same thing(s) except use (++) ?
20:18:11 <kadoban> :t (++)
20:18:12 <lambdabot> [a] -> [a] -> [a]
20:18:20 <LordBrain> > Just (++"World") <*> Just "Hello "
20:18:21 <lambdabot>  Just "Hello World"
20:18:26 <Ryanar> ohh
20:18:30 <Ryanar> I tried using ++
20:18:33 <Ryanar> but in the wrong place
20:18:34 <Ryanar> hah
20:18:35 <byorgey> > Just (++) <*> Just "Hello " <*> Just "world"
20:18:36 <lambdabot>  Just "Hello world"
20:18:56 <Ryanar> > fmap (++"newstring") (Just "current")
20:18:56 <byorgey> > (++) <$> Just "Hello " <*> Just "world"
20:18:57 <lambdabot>  <no location info>: can't find file: L.hs
20:18:58 <lambdabot>  Just "currentnewstring"
20:19:02 <Ryanar> ah darn
20:19:17 <byorgey> Ryanar: yours worked
20:19:22 <Ryanar> oh
20:19:26 <Ryanar> > fmap (++"newstring") (Just "current")
20:19:27 <lambdabot>  Just "currentnewstring"
20:19:30 <Ryanar> Ohhh
20:19:31 <Ryanar> cool
20:19:38 * hackagebot persistent-vector 0.1.0.3 - A persistent sequence based on array mapped tries  http://hackage.haskell.org/package/persistent-vector-0.1.0.3 (TristanRavitch)
20:19:40 <byorgey> not sure what happened with mine.
20:19:49 <Ryanar> would it be better to use fmap or import Control.Applicative?
20:19:49 <byorgey> > (++) <$> Just "Hello " <*> Just "world"  -- try again
20:19:50 <lambdabot>  Just "Hello world"
20:20:33 <byorgey> Ryanar: if all you're doing is applying a function under a Just, fmap should suffice
20:20:45 <LordBrain> my eyes are not seeing what you did different the second time there
20:20:47 <Ryanar> Ok, cool
20:20:58 <Ryanar> I think it might have been two commands input at the same time?
20:21:03 <kadoban> LordBrain: Nothing, lambdabot just has random failures with that odd message sometimes.
20:21:04 <byorgey> LordBrain: you have good eyes.
20:21:16 <Ryanar> Hahaha
20:21:27 <LordBrain> oh, that's embarrassing, someone should fix lambdabot
20:21:35 <Ryanar> :uptime
20:21:37 <LordBrain> not me tho :)
20:21:47 <byorgey> LordBrain: see, this is exactly the problem =)
20:21:54 <Ryanar> ~uptime
20:22:01 <byorgey> @uptime
20:22:02 <lambdabot> uptime: 6d 3h 15m 31s, longest uptime: 1m 10d 23h 44m 29s
20:22:04 <kadoban> I think lambdabot got big enough that nobody is quite sure where that error comes from anymore, or why. At least last time I looked at the issue in the tracker, that seemed to be the consensus XD
20:22:33 <Ryanar> I don't like how month and minute share the same abbreviation
20:22:35 <Ryanar> for the time format
20:22:54 <Ryanar> 1mo 10d 23h 44m 29s would be better clarity for me, but who knows im a noob
20:23:07 <kadoban> Seems like a good idea.
20:23:26 <Ryanar> haha pull request to lambdabot inc.
20:24:10 <_10edoneerf_> michaelt: is it ok to use this instead? `instance Applicative f => Additive f where zero = pure 0`
20:24:36 <LordBrain> just capitalize the month one, i say
20:24:53 <LordBrain> hmmm what's unix's date command do
20:25:33 <LordBrain> no %M is month, and %m is minute, so its the reverse of what i said
20:25:41 <LordBrain> er i mean %M is minute
20:25:45 <LordBrain> sorry
20:25:48 <LordBrain> man date
20:26:16 <LordBrain> I guess we should go for consistency
20:26:33 <Ryanar> timeDiffPretty :: TimeDiff -> String
20:26:33 <Ryanar> timeDiffPretty td = concat . intersperse " " $ filter (not . null)
20:26:34 <Ryanar>     [ prettyP ye "y"
20:26:34 <Ryanar>     , prettyP mo "m"
20:26:34 <Ryanar>     , prettyP da "d"
20:26:34 <Ryanar>     , prettyP ho "h"
20:26:36 <Ryanar>     , prettyP mi "m"
20:26:40 <Ryanar>     , prettyP se "s"
20:26:42 <Ryanar>     ]
20:26:44 <Ryanar>   where
20:26:46 <Ryanar>     prettyP 0 _ = []
20:26:48 <Ryanar>     prettyP i s = show i ++ s
20:26:50 <Ryanar>     
20:26:52 <Ryanar>     (ye, mo, da, ho, mi, se, _) = toOldTimeDiff td
20:26:54 <Ryanar> there is the code that determines it
20:27:16 <kadoban> Ryanar: Next time … http://lpaste.net/
20:27:30 <michaelt> _10edoneerf_: oh, you mean, maybe Additive could have default like that? Oh wait it sort of does...
20:27:46 <Ryanar> yeah.. that looked a lot smaller on github, my apologies
20:28:03 <vVilD> hi all
20:28:06 <Ryanar> I do wonder though, for relatively small pastes what is the downside to doing it in the channel?
20:28:07 <_10edoneerf_> michaelt: it does?
20:28:17 <vVilD> pls help me 
20:28:33 <michaelt> _10edoneerf_:   default zero :: (GAdditive (Rep1 f), Generic1 f, Num a) => f a  ;  zero = to1 gzero  
20:28:37 <barrucadu> vVilD: Ask your question
20:29:18 <kadoban> Ryanar: For me, mostly it looks like crap, especially if other people talk in between. Imagine 2 (or more conversations) going on at once, and 2 or more people pasting code at once. Not only pretty spammy, also completely incomprehensible.
20:29:18 <_10edoneerf_> michaelt: but it doesn't work removing the zero implementation
20:29:25 <vVilD> barrucadu:  I was threatened to flood you can help ?
20:29:50 <michaelt> _10edoneerf_: it's a little complicated, http://hackage.haskell.org/package/linear-1.18.0.1/docs/src/Linear-Vector.html#Additive  Right, its starting to make sense to me, maybe we need instance GAdditive?
20:29:57 <barrucadu> Threatened to flood?
20:30:15 <barrucadu> If you need to paste something of more than a couple of lines into irc, use lpaste: http://lpaste.net/
20:30:36 <_10edoneerf_> why I feel like edward is watching us eating popcorns
20:31:04 <kadoban> (Plus, paste sites can have nice additional features, like ability to edit as the conversation advances, syntax highlighting, annotations, etc.)
20:31:29 <Ryanar> kadoban, ah I understand, maybe its my irc client but the format comes out pretty nice and clean. However I can definitely see two pastes getting interleaved and behind a spammy mess, regardless I wasn't trying to argue my case I just was curious, thanks
20:31:37 <vVilD> barrucadu: I used to flood risk 
20:31:43 <michaelt> _10edoneerf_: oh this seems to work, data Foo a = Foo a a a deriving (Show, Functor, Generic, Generic1)
20:31:48 <LordBrain> is there a room for haskell programming on android and such?
20:31:56 <LordBrain> chatroom i mean on freenode
20:32:01 <michaelt> _10edoneerf_: I'm trying to figure out how ... It's clearly all there.
20:33:38 <_10edoneerf_> michaelt: cool! It works without Generic too
20:33:41 <tejing> is there a standard function equivalent to (guard . not) ?
20:33:49 <_10edoneerf_> I wonder what Generic1 does
20:33:56 <kadoban> LordBrain: I don't know that it's a very popular subject. Last time I looked it was pretty much "don't, it's annoying and lame"
20:34:10 <kadoban> There was a toy way to do it, or two, but nothing actually usable, IMO.
20:34:36 <michaelt> _10edoneerf_: Ok, the default implementation of zero needs a Generic1 instance, so we have to ask for that to be derived. All the GAdditive stuff makes better sense now, it's relating the generic representation of the type with what's needed for a default implementation.
20:34:56 <LordBrain> kadoban, well, yeah, but it never gets better without energy and focus on it
20:36:22 <dfeuer> LordBrain, I would think GHCJS and Haste would probably be useful. But there's other stuff too, around.
20:36:22 <kadoban> LordBrain: Well, that's true, but … it would be a huge, ongoing, effort and I don't know that anybody is /that/ motivated.
20:39:39 * hackagebot persistent-vector 0.1.1 - A persistent sequence based on array mapped tries  http://hackage.haskell.org/package/persistent-vector-0.1.1 (TristanRavitch)
20:39:49 <semigroup> I'm having a hard time getting this signature right: DogStatsSettings -> ((forall v. ToStatsD v => v -> IO ()) -> IO a) -> IO a
20:40:17 <semigroup> When I try to use the v -> IO () callback for various v's, it tries to constrain it to the first sort of v
20:42:02 <semigroup> How do I get it to be polymorphic for various uses of v: such that (\f -> f foo >> f bar) works where foo and bar are different types?
20:42:12 <michaelt> SrPx: as _10edoneerf_ is pointing out, you just need the Applicative instance if you 'derive Generic1' for Foo
20:44:41 <michaelt> _10edoneerf_: I see, we want Generic1 Foo, not Generic a => Generic (Foo a) .  
20:47:02 <_10edoneerf_> michaelt: oh I'm SrPx I'm just in a different screen lol
20:47:57 <michaelt> _10edoneerf_:hah, okay; tell yourself about your discovery ...
20:48:20 <_10edoneerf_> hah ok
20:59:39 * hackagebot mockery 0.0.0 - Support functions for automated testing  http://hackage.haskell.org/package/mockery-0.0.0 (SimonHengel)
21:24:40 * hackagebot monad-skeleton 0.1.1 - An undead monad  http://hackage.haskell.org/package/monad-skeleton-0.1.1 (FumiakiKinoshita)
21:27:09 <Axman6> Anyone know why the TH created logFoo functions from monad-logger don't accept ToLogStr a => a values insted of Text? makes things far less convenient than they should be
21:44:38 <Ryanar> how can I lift the Just monad to get the underlying value?
21:44:56 <dmj`> :t fromJust
21:44:57 <Ryanar> return Just "hello" -> "hello"
21:44:57 <lambdabot> Maybe a -> a
21:45:01 <Ryanar> cool
21:45:04 <Ryanar> thanks
21:45:08 <dmj`> that's very unsafe though
21:45:08 <johnw> Ryanar: you don't want to use that function
21:45:12 <Ryanar> hah
21:45:18 <Ryanar> oh boy
21:45:19 <johnw> you should pattern match on your value of type Maybe whatever
21:45:30 <johnw> or use the "maybe" function
21:45:32 <dmj`> :t fromMaybe
21:45:33 <lambdabot> a -> Maybe a -> a
21:45:42 <johnw> yes, or that
21:46:04 <dmj`> fromJust is an evil partial function
21:46:09 <bitemyappPrime> > fromJust Nothing
21:46:11 <lambdabot>  *Exception: Maybe.fromJust: Nothing
21:46:12 <Ryanar> haha
21:46:16 <bitemyappPrime> this is why we don't use fromJust.
21:46:30 <bitemyappPrime> it's senseless because it's not even something that merits or needs an exception.
21:46:40 <dmj`> looks similar to unsafePerformIO
21:46:41 <dmj`> :t unsafePerformIO
21:46:42 <lambdabot> Not in scope: ‘unsafePerformIO’
21:46:50 <bitemyappPrime> it's not really comparable
21:46:52 <dmj`> IO a -> a
21:47:01 <dmj`> the types are similar
21:47:07 <Ryanar> where is fromMaybe?
21:47:08 <bitemyappPrime> IO isn't a sum type, you don't use unsafePerformIO for the same things as that.
21:47:12 <Ryanar> er what package is it in
21:47:13 <dmj`> Data.Maybe
21:47:14 <Ryanar> ok
21:47:15 <dmj`> base
21:47:27 <dmj`> bitemyappPrime: the types look similar
21:48:11 <dmj`> @src fromJust
21:48:11 <lambdabot> fromJust Nothing  = undefined
21:48:11 <lambdabot> fromJust (Just x) = x
21:48:26 <bitemyappPrime> they look similar, but neither yield a valid copure implementation.
21:48:34 <Ryanar> @src fromMaybe
21:48:34 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
21:48:39 <bitemyappPrime> so any attempt to generalize from these two concrete instances isn't meaningful.
21:50:38 <dmj`> if you do something like, if (isJust x) then let y = fromJust x in print x else return () it's safe, but ugly
21:51:07 <dmj`> forM_ from Data.Foldable is nice for working with Maybe types 
21:51:37 <Cale> I think fromJust has its use cases. They are all cases where you know for certain that an operation will succeed because of the manner in which you've used it.
21:52:00 <johnw> it being mentioned here is not a good use case :)
21:52:02 <Cale> If you're using isJust and fromJust together, then that's when you're doing something poorly
21:52:20 <bitemyappPrime> most programmers aren't Cale though
21:52:29 <bitemyappPrime> so the decision tree begins with, "Am I Cale?"
21:52:33 <Cale> The good uses of isJust are the ones where you don't care about what the x is in Just x
21:52:56 <Cale> (and so wouldn't use fromJust)
21:53:14 <Cale> Similarly, the good uses of fromJust are the ones where you wouldn't need isJust to be able to tell that you had Just x
21:53:18 <bitemyappPrime> I've had to do cleanup duty on Haskell projects littered with partials, it's terrible. I ended up having to grep for everything that had a Maybe or Either and check that it wasn't getting partial'd out because they didn't understand join.
21:53:21 <bernalex> Cale: using them together looks quite bad, yes, heh. but using one of them is usually to me a sign of "someone (like a library) finds this datatype more useful wrapped in Maybe, but I don't really care right now".
21:53:52 <Cale> Sometimes you just don't care, yeah
21:54:04 <bitemyappPrime> IME, when somebody uses fromJust because it's because they have an (a -> Maybe b) and a (b -> Maybe c) and don't know how to squish  Maybe (Maybe c)
21:54:15 <bitemyappPrime> or compose them.
21:54:24 <bernalex> bitemyappPrime: I have not seen that. do you work with newbies or more intermediate/advanced hackers?
21:54:41 <bernalex> I'm asking since you are a teacher and so on, so you have a different perspective on things than me
21:55:01 <bernalex> in my company's production code, I have not seen what you are suggesting at least.
21:55:01 <bitemyappPrime> bernalex: it was a student I hadn't had a chance to attend to properly.
21:55:06 <bitemyappPrime> bernalex: well, more than one.
21:55:12 <bitemyappPrime> I've seen this pattern recur several times.
21:55:25 <bitemyappPrime> so I get a little prickly when people direct new people to partial functions.
21:55:27 <bernalex> bitemyappPrime: right. that makes sense. I think for us more intermediate users, what Cale & I are describing is the more common case though.
21:55:36 <bernalex> I agree that for newbies we should say "always pattern match".
21:55:41 <bitemyappPrime> bernalex: right, which is why the decision tree begins with, "Am I Cale?"
21:55:47 <bitemyappPrime> but you have to appreciate that if they have to ask, they shouldn't use it.
21:55:52 <Cale> There's a whole space of script-like programs where the whole program is short and if you screw up with fromJust, you'll know immediately which one it was, and why (and you might not even have to change the program to fix whatever the problem is)
21:56:19 <Cale> So those are all "I really don't care about the robustness of my program" cases
21:56:31 <bernalex> Cale: yeah <500 SLOC one-file haskell programs are dead simple to troubleshoot anyway.
21:57:08 <bitemyappPrime> the problem isn't a script, it's developing the habit and avoiding forcing a thunk that needs forced (learning how to manage Maybe/Either/etc. values properly)
21:57:25 <Cale> But then there are cases where, for instance, you're certain that you've populated a Map-like structure with every possible key
21:57:26 <mniip> bernalex, hahahaha
21:57:27 <lpaste> ryanar pasted “Trying to implement Either and Maybe error checking” at http://lpaste.net/3480128364050644992
21:57:29 <mniip> you're funny
21:57:34 <bernalex> mniip: ?
21:57:35 <LordBrain> hmm
21:57:39 <Ryanar> So I tried to make a simplified example
21:57:47 <Cale> and so you know for certain that the lookup will succeed
21:57:48 <Ryanar> I am doing something horribly wrong it seems
21:58:11 <mniip> even 10-line programs can be hard to comprehend and debug
21:58:36 <Welkin> bernalex is the css expert
21:58:42 <Cale> mniip: Can be, but there are a lot of 500 line programs which aren't that terrible to fix problems in.
21:59:02 <mniip> true
21:59:27 <Ryanar> mostly I am wondering if my implementation for the parsePrefix Either is correct
21:59:30 <Welkin> what if it is a 500-line template haskell program?
21:59:39 <Cale> There are lots of 500 line programs which are full of very dense and effective code.
21:59:57 <bernalex> bitemyappPrime: I like to err on the side of caution and go for the verbose thing. even in production code that will only ever be appreciated by intermediate/advanced hackers. simply because actively developed software are organisms that constantly evolve, so there's a good chance someone wants to expand the code in the future, at which point they'd need to explicitly pattern match anyway.
22:00:09 <bernalex> Welkin: that is true. edwardk has endorsed me in CSS.
22:00:26 <glguy> Ryanar: You forgot the first argument to fromMaybe
22:00:40 <bitemyappPrime> bernalex: ditto.
22:00:40 <Cale> (on the other hand)
22:00:53 <bitemyappPrime> bernalex: are you really an expert on CSS?
22:00:53 <Ryanar> glguy hah, alright
22:01:07 <Welkin> does anyone here seriously call themself a "hacker"?
22:01:09 <Cale> Ryanar: When in doubt about this sort of thing, just use case.
22:01:12 <bernalex> bitemyappPrime: not even remotely. but people keep endorsing me in it on linkedin.
22:01:20 <bernalex> Welkin: I do. my official job title is "hacker wizard".
22:01:29 <bitemyappPrime> Welkin: well, I've no academic background so it seems like the only self-aggrandizing title I can adopt.
22:01:30 <Ryanar> I honeslty don't understand the case syntax :P
22:01:30 <LordBrain> lol
22:01:33 <bitemyappPrime> Welkin: I am open to alternatives.
22:01:34 <dmj`> LinkedIn.com, where people you don't know endorse you for things you can't do
22:01:36 <Cale> Ryanar: It's almost never *wrong* to use a case expression. It'll often be more verbose than you might like.
22:01:46 <Cale> Ryanar: But it's usually dead simple to get right.
22:01:48 <Welkin> rockstar ninja 10x hacker wizard with your hat and robe
22:01:52 <bernalex> Welkin: I use hacker in the MIT sense.
22:01:57 <Cale> vs. using a bunch of fancy combinators
22:01:57 <bitemyappPrime> Ryanar: case EXPR of PossibleResultOfEXPR -> ...; SomeOtherPossibleResult -> ...
22:02:08 <xelxebar_> In general does a smaller binary get produced when explicitly importing functions with import Foo (bar) as opposed to just importing Foo? I'm guessing that ghc doesn't go around slicing up library binaries like that but I know nothing.
22:02:12 <Ryanar> yeah that seems pretty mysterious to me
22:02:17 <mniip> Ryanar, why
22:02:22 <Ryanar> -> is only ever used in type signatures
22:02:27 <Ryanar> now its being used in a function
22:02:27 <mniip> it's not any more mysterious than function arguments
22:02:38 <Welkin> bitemyappPrime: software developer?
22:02:43 <bernalex> Welkin: when I talk to muggles who I would expect not to grok what hacking is about, I say that I am a "computer science researcher".
22:02:47 <bitemyappPrime> DEVELOPERS DEVELOPERS DEVELOPERS?
22:02:50 <bernalex> Welkin: because I do work in research.
22:02:54 <mniip> Ryanar, ah? \x -> x
22:02:56 <Cale> Often when returning to code that I wrote in the past, if I was too clever with my uses of functions like 'maybe', the first thing I have to do is turn them back into case expressions for a bit, and then think about whether I really want to fold things back up into a compact expression.
22:02:58 <mniip> eh?*
22:03:06 <Ryanar> ok good point there mniip 
22:03:10 <johnw> bernalex: what kind of research?
22:03:17 <bitemyappPrime> johnw: researchy research.
22:03:22 <bitemyappPrime> johnw: it's all very hush-hush you see.
22:03:34 <mniip> Cale, often when returning to code that I wrote in the past, I can't read it
22:03:36 <dmj`> CSS research
22:03:38 <bernalex> Welkin: "software engineer" and similar titles leave a bad taste in my mouth. it seems, at least here, to be reserved for people who work with programming 9-5 because it pays well, and aren't drawn to it in the same way as hackers are.
22:03:52 <Cale> mniip: Well, yeah. That's sort of my point there :)
22:04:22 <bernalex> johnw: different sorts. might be working on a programming language soon. that would be cool. :) right now we're working on the best way to chronologise events, preserving accuarcy & understanding chronology context etc.
22:04:50 <johnw> bernalex: events coming from multiple sources with possibly unsync'd time?
22:05:09 <_10edoneerf_> Why is Data.List.Split .... made for lists? :( So many useful functions I'd like to use with Vector. Does anyone know an alternative?
22:05:31 <Welkin> _10edoneerf_: yes, use Sequence
22:05:40 <Welkin> or just use a list
22:06:10 <bitemyappPrime> _10edoneerf_: yeah if you're doing "splitty" things Sequence is probably better than Vector (I could eat my words here with a benchmark)
22:06:23 <mniip> variable size vectors sounds like you're using vectors wrong
22:06:27 <Welkin> since vectors are arrays, you have to create a new one every time you make a change
22:06:50 <Cale> Uh, Sequence isn't too likely to help in practical terms though -- it has fast splitting technically, but there's not a lot of fancy operations for actually splitting Seq values.
22:07:02 <Cale> (i.e. ones that are already written)
22:07:11 <bernalex> johnw: that's not the problem. the problem is twofold. 1. precision: the big bang on planck time scale, the history of the universe in milliards of years, your mother's birthday. all in the same timeline. visulalisation is also a problem with this. 2. context. how do we know what the user is likely to want to see? with e.g. World War II, it will not only begin & end at different times depending on which
22:07:13 <bernalex> country you live in, but you are also likely to be interested in different aspects of it. or, let's say Jesus -- a Muslim or a Christian would expect to see different things. so our research is on how to store this, how to serve it to a frontend (with prediction of what they want & what they will want next, when they zoom in/out, etc), & a little bit on how to visualise it as a timeline.
22:07:41 <johnw> bernalex: interesting stuff
22:08:16 <bernalex> johnw: right now we're just working on how to serve stuff effectively. we have a timeline of all of wikipedia (the articles with time information). so that's >10 million events on a timeline. that's a >2G JSON file lol.
22:08:42 <bernalex> but now I need to go to meet a friend. :)
22:08:58 <mniip> >country-dependent content
22:09:04 * mniip disapproves ಠ_ಠ
22:09:47 <Cale> One thing which could be done is work out exactly which operations are needed on a type in order to be able to efficiently support the general 'split' function there.
22:09:50 <bernalex> mniip: it is really interesting, actually. imagine you could have a look at newsclippings or whatever from Germany & then from the UK & then from the US, in WWII. and then make them overlap & compare them. :)
22:09:55 <Cale> and define a type class for that
22:10:02 <bernalex> but now I'm really going. bye!
22:10:18 <Cale> _10edoneerf_: I think that would be worth doing if you're motivated :)
22:11:10 <_10edoneerf_> I'm not :( 
22:11:14 <Cale> _10edoneerf_: Because once you can support that, all the other functions that Data.List.Split defines are practically free. So you could generalise the whole library pretty quickly.
22:11:49 <_10edoneerf_> I just wanted to use it, but I think it would be a great addition
22:12:12 <bitemyappPrime> Cale: the product type split uses to describe splits is pretty serious
22:12:28 <Cale> yeah
22:12:33 <bitemyappPrime> http://hackage.haskell.org/package/split-0.2.2/docs/Data-List-Split-Internals.html#t:Splitter
22:12:37 <bitemyappPrime> for any curious
22:12:58 <bitemyappPrime> maybe Sequence would be more advantageous for joining rather than splitting.
22:13:08 <bitemyappPrime> I wonder what the ideal datatype for splitting would look like?
22:13:36 <Cale> Well, Data.Sequence gives you log time splitting (log of minimum distance to either end)
22:13:50 <bitemyappPrime> seems good.
22:14:01 <Cale> The constant factors are kind of heavy
22:14:25 <_10edoneerf_> bernalex: that sounds very cool btw
22:15:03 <Cale> But the more important thing is that lots of sequence types would benefit from having Data.List.Split :)
22:15:17 <Cale> It *should* be possible to use this with Vector
22:15:22 <akurilin3> GHC question: is anybody aware of 7.8.x bugs that might have caused the RTS to generate wayyy too many threads with the -N option?
22:15:30 <Cale> It's just not, because it's hard to generalise over all possible sequence types.
22:15:32 <akurilin3> I can't find anything by googling
22:15:50 <Cale> Also, Text and ByteString
22:16:02 <Cale> But those don't have type parameters
22:16:19 <Cale> So the types of the operations end up looking a bit different usually -- type families are in order probably.
22:16:50 <Cale> akurilin3: hmm, too many OS threads?
22:17:05 <Cale> akurilin3: I mean, you can't really mean too many Haskell threads...
22:17:13 <Cale> I've never seen that myself
22:18:08 <dmj`> akurilin3: do you have example code? What do you see happening?
22:19:43 <bitemyappPrime> dmj`: https://groups.google.com/forum/#!topic/yesodweb/LU1r1ygMuOY
22:19:58 <bitemyappPrime> akurilin3: best to just link the thread immed. since it has a lot of context.
22:26:30 <dmj`> akurilin3: did specifying an explicit value w/ -N help?
22:27:37 <dmj`> akurilin3: how many cores did that machine have? Looks like 32
22:28:47 <dmj`> akurilin3: I like Greg+Felippe's suggestions, keep removing web handlers to isolate it
22:30:30 <bitemyappPrime> akurilin3: I'm not really satisfied with limiting the number of cores as a final answer, myself. I'd go with what dmj` suggests and bisect the handlers.
22:30:36 <bitemyappPrime> akurilin3: IMHO
22:34:00 <dmj`> akurilin3: My only suggestion is look at your code, see if in your handlers you have a lot of calls to forkIO that are long running. The rts will evaluate thread stacks round robin based on the number of cores available (if you using -N). Are you calling mapConcurrently over a list of arbitrary length that doesn't terminate quickly? (Like issues many http requests that are timing out / db calls that put strain on the conn. pool). As
22:34:01 <dmj`> bitemyappPrime hard coding -Nx seems like a band aid.
22:34:19 <dmj`> said*
22:35:36 <bitemyappPrime> I don't think akurilin3 has anything like that, I would guess it's a library.
22:35:41 <bitemyappPrime> but I could be wrong.
22:38:01 <beruuwong> If I write a function with 'where a=...,' is 'a' only local to that function or can I use it in another function too?
22:39:08 <bitemyappPrime> beruuwong: it's only local to that function. Only way for it to escape is for it to get returned by that enclosing function
22:39:10 <glguy> It's local to the declaration associated with the "where" assuming your talking about a where attached to a declaration
22:39:10 <dmj`> beruuwong: if that other function is defined the where clause, but not in another top-level function
22:39:18 <dmj`> in the*
22:59:16 <beruuwong> Hi, I've a question : http://lpaste.net/131210
23:00:20 <kadoban> beruuwong: Where do you want the Float to come from? How much do you want to move each Car ?
23:01:03 <mniip> beruuwong, you apply moveCar to t, and get a function of type Car -> Car
23:01:07 <mniip> then you pass that to map
23:02:14 <beruuwong> Hi, I think I figured it out. I can store 'f = moveCar t' and then pass it to 'map f ptl'
23:02:50 <mniip> beruuwong, no need for intermediate variables
23:02:56 <mniip> map (moveCar t) ptl
23:03:13 <beruuwong> oh, thanks. That's much more convenient
23:09:45 * hackagebot wai-extra 3.0.7.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.7.1 (MichaelSnoyman)
23:22:07 <beruuwong> Hi, I've another question : http://lpaste.net/131212
23:23:24 <jle`> beruuwong: you're missing the case where your list is one item long
23:23:24 <kadoban> beruuwong: That's because you don't have a pattern that matches a list of length 1. You only handle [] and ones with two or more items.
23:23:27 <mniip> beruuwong, you have patterns for [] and (x:y:z)
23:23:32 <mniip> but not for [x]
23:24:05 <kadoban> beruuwong: By the way, it's not an error, just a warning. But it's still something to worry about.
23:24:27 <beruuwong> Oh okay. Thanks, I'll try and fix it up
23:56:13 <HEGX64> :t map.map
23:56:14 <lambdabot> (a -> b) -> [[a]] -> [[b]]
23:56:21 <HEGX64> :t map.map.map
23:56:22 <lambdabot> (a -> b) -> [[[a]]] -> [[[b]]]
