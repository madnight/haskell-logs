00:00:08 <shachaf> What is it?
00:00:57 <dolio> And function spaces being continuous, it is wrong to think of them as automatically being 'bigger' than their related spaces.
00:01:25 <shachaf> Do you know which post?
00:03:27 <dolio> http://math.andrej.com/2009/10/12/constructive-gem-double-exponentials/
00:08:43 <dolio> Anyhow, you can think about writing programs, too. (f : (Nat -> Bool) -> Bool) is limited in the ways it can inspect its argument to produce a result. It can only probe up to a point, and it will agree on all functions that agree up to that point.
00:09:06 * hackagebot ide-backend-common 0.9.1 - Shared library used be ide-backend and ide-backend-server  http://hackage.haskell.org/package/ide-backend-common-0.9.1 (MichaelSnoyman)
00:09:06 * hackagebot repa 3.4.0.1 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-3.4.0.1 (BenLippmeier)
00:09:08 <dolio> Or, agree on all functions that agree on the particular points that it tests.
00:09:45 <dolio> And it only gets to test on finitely many points.
00:09:50 <arkeet> yes, now I'm reminded of this stuff I guess.
00:11:08 <dolio> So functionals like that are forced to unify functions that a normal set theoretic intuition would say are distinct.
00:11:53 <dolio> I think there's some paper that shows that the fixed point itself turns out to be the natural numbers, but I don't know if I'd ever be able to find it.
00:12:09 <dolio> It's easier to work backwards from knowing that ((Nat -> Bool) -> Bool) ~= Nat.
00:12:58 <shachaf> Just knowing that they're isomorphic doesn't tell you that that works as good definition of Nat, though.
00:13:15 <dolio> Well, I'm sure it's not a good definition.
00:13:34 <shachaf> I mean as a definition at all.
00:15:27 <dolio> If you're in a system that allows positive types, and you know that that isomorphism on the naturals holds (if it does in that same system), then I think it's not so hard to show that the positive type definition would also be isomorphic to the naturals.
00:17:08 <dolio> One direction of the isomorphism on Nat is what you need to eliminate the positive type into Nat.
00:17:32 <dolio> The other direction probably lets you build the positive type.
00:19:58 <arkeet> this vaguely reminds of the duality between compact and discrete abelian topological groups.
00:21:17 <arkeet> (the Pontryagin dual of an abelian topological group G is the group of homomorphisms from G to the circle group R/Z. any locally compact group is self-dual, and compact groups are dual to discrete groups.)
00:25:51 <arkeet> but (a -> Bool) -> Bool is rather different from a if a is finite.
00:26:40 <dolio> Yeah, for finite cases, the functional is bigger in some clear ways.
00:29:13 <dolio> One interesting (I think) thing to wonder is whether things actually get 'bigger' in set theory.
00:29:33 <arkeet> you'd have to start by thinking about what 'bigger' means, I guess.
00:29:50 <dolio> Since the Loewenheim-Skolem says that set theory has countable models.
00:30:09 <arkeet> I forget much of what I learned about logic.
00:30:30 <dolio> But, those models will let you prove internally that PN is 'bigger' than N, in the sense that there's no surjection.
00:30:40 <arkeet> sure.
00:31:06 <dolio> Of course, you can prove that PPN ~= N is false internally, I imagine.
00:31:31 <dolio> So it's not really the same situation.
00:31:55 <dolio> It's more of an internal vs. external thing.
00:31:57 <arkeet> I don't like talking about surjections.
00:32:13 <arkeet> there is never an injection Px -> x.
00:32:19 <arkeet> but there is always one x -> Px
00:32:30 <dolio> Than an internal thing where two steps of 'getting bigger' gets you back to the same thing.
00:33:04 <arkeet> so if one had an injection P(Px) -> x, you could compose that with Px -> P(Px).
00:33:54 <arkeet> you'd have to weaken the "there is an injection x -> Px" thing.
00:34:02 * hackagebot pinboard 0.6.4 - Access to the Pinboard API  http://hackage.haskell.org/package/pinboard-0.6.4 (jonschoning)
00:34:50 <arkeet> I think.
00:35:14 <arkeet> well, I dunno.
00:35:19 <arkeet> there ought to be one.
00:35:42 <dolio> Injection from Nat -> (Nat -> Bool) might exist.
00:35:46 <arkeet> of course.
00:36:00 <dolio> But maybe not (Nat -> Bool) -> ((Nat -> Bool) -> Bool). Presumably not.
00:36:16 <dolio> Oh, right.
00:36:27 <arkeet> the obvious one needs to test equality
00:36:50 <dolio> Because of the whole, "you can't probe them sufficiently," thing.
00:38:13 <arkeet> thinking of Nat -> Bool as a topological space for a moment.
00:38:13 <dolio> Yeah. Presumably deciding equality violates the topology.
00:38:17 <arkeet> the equality function on that isn't continuous.
00:38:20 <dolio> Whatever the topology is.
00:38:32 <arkeet> (it's semicontinuous though.()
00:38:49 <arkeet> (which I suppose to us means that if two things are different, you can tell in finite time.)
00:40:57 <dolio> Yeah. Same reason we don't have Eq for arbitrary functions.
00:41:19 <arkeet> and, well
00:41:45 <arkeet> I guess since we know (Nat -> Bool) -> Bool is countable
00:41:48 <arkeet> there can't be any continuous injections.
00:46:25 <arkeet> there's also the thing that the natural map Nat -> (Nat -> Bool) -> Bool isn't surjective.
00:47:19 <dolio> Yeah.
00:51:16 <arkeet> well
00:58:53 <augur> question for anyone familiar with existentials: is it possible to match on a value of an existentially closed type, and thereby force the type?
00:59:08 <augur> in haskell, specifically, not in general
00:59:40 <arkeet> what do you mean?
00:59:43 <arkeet> (the answer is probably no.)
01:00:21 <augur> ill assume the answer is no, then
01:04:03 * hackagebot filediff 0.1.0.1 - Diffing and patching module  http://hackage.haskell.org/package/filediff-0.1.0.1 (bgwines)
01:14:04 * hackagebot repa-algorithms 3.4.0.1 - Algorithms using the Repa array library.  http://hackage.haskell.org/package/repa-algorithms-3.4.0.1 (BenLippmeier)
01:14:06 * hackagebot process-streaming 0.7.1.0 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.7.1.0 (DanielDiazCarrete)
01:14:08 * hackagebot repa-io 3.4.0.1 - Read and write Repa arrays in various formats.  http://hackage.haskell.org/package/repa-io-3.4.0.1 (BenLippmeier)
01:14:10 * hackagebot repa-examples 3.4.0.1 - Examples using the Repa array library.  http://hackage.haskell.org/package/repa-examples-3.4.0.1 (BenLippmeier)
01:19:04 * hackagebot json-autotype 0.3 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.3 (MichalGajda)
01:45:34 <Axman6> @where ops
01:45:34 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
01:45:45 --- mode: ChanServ set +o shachaf
01:46:12 --- mode: shachaf set +b-o stuntaneo!*@*$##fixyourconnection shachaf
01:46:20 <shachaf> Oops.
01:46:32 --- mode: ChanServ set +o shachaf
01:46:49 --- mode: shachaf set -b+b stuntaneo!*@*$##fixyourconnection stuntaneous!*@*$##fixyourconnection
01:47:03 <Axman6> thanks shachaf 
01:48:11 <Ke> wow, I didn't know you can do comments in bans
01:49:14 --- mode: shachaf set -o shachaf
01:49:17 <shachaf> It's a redirect.
02:04:04 <jellie> How can I pass the Content-Type I want in Network.Wreq? In this case I want to recieve xml.
02:08:56 <pavonia> jellie: Use a request with options and add a header to it
02:11:05 <paweln> does sort [minBound .. maxBound] == [minBound .. maxBound] ?
02:19:14 <jle`> paweln: I'd expect it to for most meaningful instances, but there's nothing in the laws that for Ord, Enum, and Bounded that requires it in general
02:20:06 <jle`> if succ x > x, then I think so
02:23:41 <mikeplus64> is there a way to "or" (as in <|>) prisms from lens? ie a simpler do x <- preview (foo.bar); y <- preview(foo.baz); return (x <|> y)
02:24:08 * hackagebot edit-distance-vector 1.0 - Calculate edit distances and edit scripts between vectors.  http://hackage.haskell.org/package/edit-distance-vector-1.0 (ThomasSutton)
02:25:16 <jellie> pavonia: I'm trying to let me show you what it is I'm trying. I'm probably failing in something small.
02:26:59 <jellie> pavonia: http://lpaste.net/5348804862865833984
02:30:08 <jellie> pavonia: Gotta go :(
02:34:08 * hackagebot hothasktags 0.3.3 - Generates ctags for Haskell, incorporating import lists and qualified imports  http://hackage.haskell.org/package/hothasktags-0.3.3 (LukePalmer)
02:34:10 * hackagebot data-partition 0.3.0.0 - A pure disjoint set (union find) data structure  http://hackage.haskell.org/package/data-partition-0.3.0.0 (LukePalmer)
02:35:47 <comodo_dragon> what is haskeLL ?
02:38:59 <pavonia> A functional programming language
02:51:22 <comodo_dragon> is haskell a troLL ?
02:53:53 <UnrealQuester> why would you think that?
02:59:10 * hackagebot rest-gen 0.17.0.3 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.17.0.3 (AdamBergmark)
03:24:11 * hackagebot json-schema 0.7.3.3 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.7.3.3 (AdamBergmark)
03:24:13 * hackagebot aeson-diff 0.1.1.1 - Extract and apply patches to JSON documents.  http://hackage.haskell.org/package/aeson-diff-0.1.1.1 (ThomasSutton)
03:37:38 <Forgetaboutit> I have an issue with nested monads where I need to access the outer context from the inner.  I found two really ugly solutions so far, but I wonder if there is a better one.  Code: http://lpaste.net/130081
03:38:54 <Cale> Forgetaboutit: Well, you might be looking for ReaderT instead of Reader, but better yet, I think is just to write functions taking Config as an argument.
03:39:25 <Peaker> Forgetaboutit: "nested monads" do not compose, that's why monad transformers need to exist
03:39:36 <Peaker> monad transformers let you compose monads ("nest" them) when applicable
03:40:07 <Cale> Well, more precisely, the monad transformers themselves compose
03:40:16 <Cale> The resulting monads still don't.
03:40:41 <Forgetaboutit> Cale: I'm using `Reader' in `routeHandlerA' on purpose since I don't know yet if I need the config later and where
03:41:31 <Cale> Forgetaboutit: Using Reader or ReaderT is not syntactically lighter than adding an extra parameter to your function.
03:41:38 <Cale> at least, most of the time
03:41:44 <Forgetaboutit> I see
03:41:57 <Forgetaboutit> So what's the point of ReaderT then?
03:42:21 <Cale> The best uses of monad transformers tend to obscure the fact that a monad transformer is in use.
03:42:37 <Cale> You want the clients of your library not to have to do any manual lifting
03:42:50 <Cale> which if you leave the monad transformer exposed, they will be allowed to do
03:43:31 <Forgetaboutit> so would I basically newtype the transformer-stack?
03:43:42 <Cale> So for the most part, ReaderT is sometimes part of a construction of a particular monad that you're wrapping up in a newtype (whose data constructor isn't exposed), and then all the lifting gets confined to that one module
03:43:56 <Cale> yes
03:44:18 <Forgetaboutit> hm
03:44:25 <Forgetaboutit> so maybe that's what I should do
03:44:44 <Cale> Whether or not it's worthwhile to do that basically comes down to how much up-front effort you're willing to put in, and how well-defined a language of operations you have.
03:45:03 <Cale> I find ReaderT on its own is almost never worth it.
03:45:28 <Cale> You can't write enough meaningful operations to make the abstraction worth its weight with just ReaderT.
03:45:59 <Forgetaboutit> I'm currently building a small web app using Scotty and Hasql, so there's some more stuff I need
03:46:24 <Cale> Like, is there any reason you can't just have  setupRoutes :: Config -> ScottyM () ?
03:46:55 <Forgetaboutit> I thought about that before
03:47:31 <Forgetaboutit> But then I'd have to partially apply config to all the routes
03:48:11 <Cale> Anything you could accomplish with ReaderT e m a, you can accomplish with e -> m a
03:48:44 <Cale> The only difference is having to explicitly lift all the m actions vs. having to explicitly pass a parameter around
03:49:01 <Forgetaboutit> yeah right
03:49:03 <Cale> I usually find the latter to be less troublesome
03:49:12 * hackagebot json-autotype 0.4 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.4 (MichalGajda)
03:49:15 <Cale> But of course it depends
03:49:31 <jle`> for me, the main thing is the static guarantee that all functions will be called with the *same* `e`.
03:49:45 <jle`> you can do explicit parameter passing...and sometimes it's even cleaner with explicit parameter passing
03:49:49 <jle`> but you don't have that guarantee anymore
03:49:57 <Forgetaboutit> jle': when using reader?
03:49:59 <jle`> some function might change the `e` along the way before passing it down
03:50:00 <Cale> You don't have that guarantee with ReaderT though
03:50:06 <Cale> :t local
03:50:07 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
03:50:56 <jle`> maybe you can say it restricts it to certain constructs ;)
03:51:01 <Cale> Actually, I think the best applications of ReaderT are usually the ones where you use local a whole lot
03:51:05 <tsahyt> Is there a way to get hlint working with source files containing unicode characters like alpha, beta, etc?
03:51:11 <jle`> or maybe it's just that you can convey what you mean in the type
03:51:18 <Cale> (e.g. things like keeping track of an interpreter's context)
03:51:34 <jle`> having ReaderT conveys "all things under the same context" in the type
03:51:48 <Cale> tsahyt: Uh, we'd have to know what's wrong with it.
03:52:06 <jle`> hm. it might also be the case that we use ReaderT for very different things
03:52:11 <Forgetaboutit> jle`: I agree
03:52:38 <jle`> still I almost always use `ReaderT e m` only in places where something is "expecting" a `Monad`
03:52:46 <tsahyt> Cale: I'll cook up an example. I haven't tried it in a few months and have just given up on using unicode but I'd really like to use proper names for some variables.
03:53:04 <jle`> so that it can take advantage of the (>>=) defined on ReaderT, which is different than just using (e -> m a)
03:53:14 <jle`> in real life that is
03:53:17 <hexagoxel> Forgetaboutit: would mapReaderT be able to improve the particular example?
03:53:42 <Forgetaboutit> hexagoxel: I'm not familiar with this function
03:53:52 <hexagoxel> :t mapReaderT
03:53:53 <lambdabot> (m a -> n b) -> ReaderT r m a -> ReaderT r n b
03:54:19 <hexagoxel> :t mapReader
03:54:20 <lambdabot> (a -> b) -> Reader r a -> Reader r b
03:54:47 <simg> hi, could anyone tell me how with digestive-functors I can use a :: Form Text v a    subform as a field on a  :: Form Html v a parent form ?
03:55:29 <tsahyt> Okay apparently it works for greek characters, but here's something: http://lpaste.net/1023647322619248640 Hlint reports a Parse Error on the subscript 1
03:56:03 <Forgetaboutit> hexagoxel: I'm not sure that would help.  However, I'm not an expert in Haskell (yet :))
03:56:25 <hexagoxel> (i don't mean to invalidate the rest of the discussion; choosing a different general design may be the better solution)
03:56:30 <tsahyt> The exact error message is "test.hs:4:6: Warning: Parse error: Illegal character ''\8321''"
03:57:36 <Forgetaboutit> hexagoxel: I'm open for suggestions :).  I'd appreciate any help
03:58:00 <Forgetaboutit> pointers, not a finished design of course
04:02:53 <hexagoxel> Forgetaboutit: http://lpaste.net/493626230621339648
04:04:12 <hexagoxel> i think that should type-check. (also, the original post got spammed? that is sad ):
04:06:10 <tsahyt> :t maybe
04:06:11 <lambdabot> b -> (a -> b) -> Maybe a -> b
04:06:18 <Forgetaboutit> hexagoxel: It doesn't typecheck, unfortunately
04:08:09 <Forgetaboutit> hexagoxel: now it does
04:09:16 <Forgetaboutit> that's definitely less ugly
04:15:42 <Cale> tsahyt: Okay, I found the problem
04:16:04 <Cale> http://hackage.haskell.org/package/haskell-src-exts-1.16.0.1/docs/src/Language-Haskell-Exts-InternalLexer.html#isIdent
04:16:30 <Cale> isAlpha '₁' and isDigit '₁' are both False, but isAlphaNum '₁' would be True
04:22:06 <mauke> @check \c -> (isAlpha c || isDigit c) == isAlphaNum c
04:22:08 <lambdabot>  *** Failed! Falsifiable (after 88 tests):
04:22:08 <lambdabot>  '\188'
04:22:59 <benzrf> rip
04:23:24 <benzrf> > text "\188"
04:23:26 <lambdabot>  ¼
04:24:10 <mauke> isDigit is ascii only
04:24:37 <mauke> @check \c -> (isAlpha c || isNumber c) == isAlphaNum c
04:24:38 <lambdabot>  +++ OK, passed 100 tests.
04:27:22 <tsahyt> Okay at least now I know why it fails. Thanks! Is this worth writing a bug report for?
04:31:47 <sammecs> No, as isDigit is useful for parsing, I think.
04:32:07 <f-a> say I have parsed a json file with aeson, and you are not 100% sure what's on it, how do you guys 'navigate' it? I see there is a handy 'value' type, but little convencience functions
04:37:39 <dicioccio> what do you mean f-a ?
04:38:12 <dicioccio> what I typically do is project JSON objects to whatever is my business domain objects
04:39:17 <f-a> dicioccio: I just downloaded a sample datset in json. I know there is a statistical data I need in there, but not sure "where". I would like to navigate the raw json
04:39:37 <f-a> much like hxt
04:40:28 <f-a> because I don't still know what's the connection from the json to my type
04:41:06 <WarzoneCommand> question: I'm trying to upload a new version of my package to hackage, but I'm getting a 'Unknown extensions: PatternSynonyms' error. Anyone know how to fix that? 
04:41:36 <WarzoneCommand> (i.e.  PatternSynonyms is in the list of default-extensions) 
04:41:53 <WarzoneCommand> (locally cabal build, builds just fine) 
04:42:20 <dicioccio> f-a: I'm not sure I follow you but what you want is the "parser part" not the "fromJson part"
04:43:34 <dicioccio> you'll find them in Data.Aeson.Parser
04:44:12 <f-a> thanks, I'll look into that dicioccio 
04:44:57 <dicioccio> you'll need to use attoparsec's "parse" function
04:45:09 <tdammers> f-a: you'll want to work with the Value type. There's a section called "working with raw JSON objects" in the Aeson docs.
04:46:40 <tdammers> f-a: Value itself is a trivial instance of ToJSON and FromJSON, so instead of parsing into something well-typed, you can just parse into Value and then take it from there
04:47:27 <tdammers> (or you can just use the json or json' function for parsing)
04:49:08 <f-a> tdammers: thanks. You mean the "working with the AST" section, right? http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson.html
04:50:36 <tdammers> ah, yes
04:51:00 <f-a> thanks
04:51:50 <tdammers> p
05:04:16 * hackagebot haroonga 0.1.7.1 - Low level bindings for Groonga.  http://hackage.haskell.org/package/haroonga-0.1.7.1 (cosmo0920)
05:04:55 <ph88> what's \ on line 12? http://lpaste.net/7088950479618572288
05:05:18 <quchen> A lambda.
05:05:45 <quchen> > map (\x -> (x,x)) [1,2,3]
05:05:47 <lambdabot>  [(1,1),(2,2),(3,3)]
05:05:52 <ph88> i'm used to lamda being of form   (\x -> x + 1)    what's going on here with only sincel \   ?
05:06:00 <ph88> single
05:06:09 <quchen> > map (\(x,y) -> (y, x)) [(1,2), (11, 22)]
05:06:10 <lambdabot>  [(2,1),(22,11)]
05:06:46 <quchen> The \x part in your paste is \(name, salary :: Int)
05:06:48 <srhb> ph88: The space is optional :)
05:06:56 <ph88> oh ok
05:08:02 <quchen> The space is optional unless your pattern starts with ! or ~.
05:08:19 <quchen> (Which is rare.
05:08:31 <ph88> instead of a fixed column size in csv how can i make the code like "for reach column ... interprent as float"
05:09:02 <ph88> i have 64 columns at the moment
05:09:12 <srhb> > (\ ~x -> x+2) 2
05:09:14 <lambdabot>  4
05:09:15 <srhb> ?
05:09:25 <srhb> Ooh, you meant \~ is a syntax error
05:13:10 <quchen> Right.
05:13:15 <quchen> And \! as wel
05:13:16 <quchen> l
05:22:43 <marcin__> Hi! I would like to write a function composed of many IO operations. When any of them fail, I would like to revert all of the operations that had been done and report some error (obviously, I assume that each operation knows how to be reverted). What is the most elegant way of doing that ?
05:23:40 <Clint> i think someone wrote a transformer for that
05:26:00 <marcin__> Clint, Where should I look for a details of those transformers ?
05:26:33 <Clint> hackage, i guess
05:27:07 <mauke> :t foldr (\(d, r) z -> d >> (z `onException` r)) (return ())
05:27:08 <lambdabot> Foldable t => t (IO a, IO b) -> IO ()
05:27:58 <mauke> :t foldr (\(d, r) z -> d >>= \x -> z x `onException` r) return
05:27:59 <lambdabot>     Couldn't match expected type ‘a -> IO b’ with actual type ‘IO b’
05:27:59 <lambdabot>     Relevant bindings include
05:27:59 <lambdabot>       x :: a (bound at <interactive>:1:28)
05:28:08 <mauke> true
05:28:50 <mauke> :t foldr (\(d, r) z -> \y -> d y >>= \x -> z x `onException` r) return
05:28:51 <lambdabot> Foldable t => t (b -> IO b, IO b1) -> b -> IO b
05:29:07 <marcin__> @Clint Yes, it's clear, but I found it hard to find anything.
05:29:07 <lambdabot> No module "Yes, it's clear, but I found it hard to find anything." loaded
05:29:17 * hackagebot QuickCheck 2.8.1 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.8.1 (NickSmallbone)
05:29:29 <marcin__> Clint, Yes, it's clear, but I found it hard to find anything.
05:30:04 <Clint> yup
05:32:45 <lpaste> ane pasted “blah” at http://lpaste.net/130087
05:33:10 <ane> is there any way to not use the do notation there? using applicatives or something
05:34:44 <mauke> you can use >>=, but that's it
05:35:39 <hexagoxel> @@ @pl @undo do str <- c_calc_dm c_input c_country (fromIntegral speed) c_directory; peekCString str
05:35:39 <lambdabot>  peekCString =<< c_calc_dm c_input c_country (fromIntegral speed) c_directory
05:37:27 <ane> huh, neat
06:02:57 <ph88> hi guys   how can i put this decode (line 10) http://lpaste.net/7088950479618572288  with something like this    decode NoHeader "John,27\r\nJane,28\r\n" :: Either String (Vector (Vector ByteString))
06:05:43 <sammecs> ph88: What do you mean?
06:07:07 <ph88> sammecs: combine line 10 with the :: thing
06:08:32 <mauke> like that
06:10:10 <int-e> :t 1 ∷ Num a ⇒ a
06:10:16 <lambdabot> Num a => a
06:10:24 <ph88> Could not find module `Data.Csv'  why am i getting this ?
06:10:40 <jhance> ph88: Because there is no module Data.Csv in your package dependencies
06:10:55 <ph88> why not? i did    cabal install cassava    was installed fine
06:11:00 <ph88> also i used    cabal sandbox init
06:11:03 <ph88> BEFORE install
06:12:28 <quchen> Sounds like you have it installed in your sandbox, but your program's .cabal does not list it as one of its dependencies.
06:12:55 <ph88> i don't have a program .cabal ... only this file: cabal.sandbox.config
06:13:34 <ph88> also it installed in    C:\Users\ph88\AppData\Roaming\cabal\packages\hackage.haskell.org    ... eh doesn't look like a sandbox !
06:14:20 * hackagebot gio 0.13.1.0 - Binding to the GIO.  http://hackage.haskell.org/package/gio-0.13.1.0 (HamishMackenzie)
06:14:22 * hackagebot gtk3 0.13.6 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk3-0.13.6 (HamishMackenzie)
06:15:12 <mpickering> What happened to the Data.HashTable module in base?
06:15:23 <mpickering> can i get it from a package still?
06:15:38 <ph88> is my sandbox broken ?
06:16:11 <sammecs> @hoogle HashTable
06:16:12 <lambdabot> Data.HashTable module Data.HashTable
06:16:12 <lambdabot> Data.HashTable data HashTable key val
06:16:12 <lambdabot> package hashtables
06:16:33 <quchen> ph88: How are you compiling your program?
06:16:35 <hexagoxel> ph88: what command leads to the "module not found"-error?
06:17:01 <quchen> mpickering: If you need a hash container, have a look at unordered-containers
06:17:17 <ph88> quchen: runhaskell
06:17:27 <phaazon> hey
06:17:30 <ph88> hexagoxel:  import Data.Csv
06:17:34 <quchen> runhaskell doesn't know about sandboxes.
06:17:37 <mpickering> I'm trying to compile some old code which uses Data.HashTable
06:17:37 <phaazon> I’d like to import a pattern synonym from SDL2
06:17:44 <phaazon> I can’t find a way to do that…
06:17:56 <ph88> quchen: is that normal that the packages are not installed in the same directory when using a sandbox ?
06:18:02 <phaazon> I thought it was something like import Stuff ( pattern A )
06:18:06 <phaazon> but it’s actually not
06:18:22 <hexagoxel> ph88: use `cabal exec -- runhaskell`
06:18:24 <quchen> Try `cabal exec runhaskell`, which will make runhaskell sandbox-aware iirc.
06:18:51 <ph88> hexagoxel: fixed, thanks
06:18:57 <ph88> quchen: thanks too
06:19:21 * hackagebot gtk 0.13.6 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.13.6 (HamishMackenzie)
06:19:41 <phaazon> oh I guess I need the PatternSynonyms extension dammit
06:20:11 <phaazon> yeah it was that, nevermind then
06:23:13 <ph88> how can i pick a column, lets say column number 50 instead of 2 columns and name them?  http://lpaste.net/4605653118384865280
06:24:10 <ph88> i think i need to refer to a particular index of the vector
06:24:21 * hackagebot pango 0.13.1.0 - Binding to the Pango text rendering engine.  http://hackage.haskell.org/package/pango-0.13.1.0 (HamishMackenzie)
06:29:44 <ph88> here is my attempt:  http://lpaste.net/4076286703956918272
06:38:46 <mniip> ph88, V.!
06:38:48 <mniip> not (V.!)
06:39:07 <srhb> ph88: You're applying 1 to (V.!) as well. Not intentional I'm guessing.
06:39:15 <sammecs> Or (V.!) blah 1
06:39:35 <mniip> > 1 GHC.Num.+ 2
06:39:36 <lambdabot>  Not in scope: âGHC.Num.+â
06:39:43 <mniip> oh?
06:40:19 <geekosaur> > 1 Prelude.+ 2
06:40:20 <lambdabot>  3
06:40:34 <mniip> yeah well that works
06:40:35 <sammecs> (+) 1 2
06:43:32 <int-e> lambdabot: oh, did I mess up that unicode thing again?
06:44:37 <Cale> int-e: What is going on there? Wrong locale?
06:45:14 <int-e> Cale: A discrepancy between behavior on the console and in IRC, essentially.
06:46:00 <int-e> I had reverted a patch, but in today's update that revert was lost.
06:47:01 <int-e> > ihopethisdoesn'texist
06:47:06 <lambdabot>  Not in scope: ‘ihopethisdoesn'texist’
06:47:40 <Phillemann> http-conduit seems to handle the HTTP client stuff. Is there a library dual to it for server stuff?
06:52:49 <Cale> Phillemann: wai?
06:52:54 <Cale> Phillemann: or scotty?
06:53:21 <Cale> Or one of the big web application frameworks Snap, Happstack and Yesod
06:54:42 <Phillemann> Neither wai nor scotty expose a conduit based interface. Which is ok, I'm just asking if there is anything available.
06:55:00 <Cale> hmm
06:55:19 <Phillemann> I just saw "runTCPServer" which gives you, for each connecting client, two conduits for the input and the output which you can then use.
06:55:22 <Cale> Maybe this is what you're looking for? http://hackage.haskell.org/package/wai-conduit
06:55:43 <Cale> It looks pretty minimal though
06:55:59 <Phillemann> Ah yes, that's a start :)
06:56:57 <quchen> int-e: Is there a way to give Lambdabot a function of unsafePerformIO's type? Like unsafePerformIO = error "..." :: IO a -> a?
06:57:08 <quchen> Would be useful for :t sometimes
06:57:27 <ph88> why is the expected type int ? what to do about it?? http://lpaste.net/2101201514210000896
06:57:33 <int-e> there is @let, but I don't see the general utility.
06:58:28 <int-e> ph88: is the argument order of V.! really that way?
06:58:59 <ph88> https://hackage.haskell.org/package/vector-0.9.1/docs/Data-Vector.html#g:20
06:59:14 <haskell762> Hi, I'm trying to use "sortBy ( compare `on ` length ) xs" from the book "learn you haskell" but where is    `on` ??
06:59:18 <quchen> int-e: Well, it's a standard function we sometimes talk about here
06:59:22 <ph88> sorry its this one https://hackage.haskell.org/package/vector-0.9.1/docs/Data-Vector.html#g:4
06:59:28 <ph88> (!) :: Vector a -> Int -> a
06:59:38 <ph88> but i use ! not (!)
06:59:43 <quchen> unsafeCoerce as well
06:59:52 <int-e> ph88: the vector still comes first.
06:59:58 <ph88> oh ok
06:59:59 <jkarni> haskell762: it's from Data.Function
07:00:15 <jkarni> haskell762: import Data.Function (on) should do it
07:00:20 <int-e> quchen: a ! b  is the same as  (!) a b
07:00:27 <haskell762> thx
07:00:39 <quchen> int-e: Did you mean ph88?
07:00:41 <int-e> ph88: err. that was for you.
07:00:44 <jkarni> :i on
07:00:50 <ph88> oh boy oh boy this program runs :d
07:00:54 <quchen> Lambdabot has no :i
07:01:04 <int-e> quchen: I should know better than try and talk to two people at once.
07:01:05 <jkarni> hmm
07:01:08 <jkarni> @src on
07:01:09 <lambdabot> (*) `on` f = \x y -> f x * f y
07:01:50 <ph88> so i have a csv with 91 columns at the moment. each column is a series ... would it be better to reread the file for each serie or put it in memory ?
07:01:51 <jkarni> wow, pattern matching on operators - I had never though of doing that!
07:02:01 <ph88> 30000 rows
07:02:29 <quchen> (*) is an ordinary name in Haskell.
07:02:46 <quchen> It's as much of a pattern match as "x" is.
07:03:14 <quchen> > let (*) = "hello" in (*) ++ "world"
07:03:16 <lambdabot>  "helloworld"
07:04:42 <jkarni> yeah, I get that, I just wouldn't have though of pattern matching with (<operator>) to avoid having to use backticks
07:08:00 <ph88> can somebody recommend me a FFT library for haskell ? there are so many ... and i'm new to this stuff    i saw this page but it doesn't really help in the decision, also performance is not that important  http://en.pk.paraiso-lang.org/Hackage/what-is-the-fastest-dft-in-haskell/main
07:10:31 <ph88> maybe just this one ? https://hackage.haskell.org/package/fft
07:12:04 <Lis> hello everyone. http://www.mathematek.de/paste:haskell_map_list i get this error for calling a function. can someone point out my error, thank you
07:14:23 * hackagebot classy-prelude 0.11.1 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.11.1 (MichaelSnoyman)
07:14:25 * hackagebot classy-prelude-yesod 0.11.1 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.11.1 (MichaelSnoyman)
07:14:27 * hackagebot classy-prelude-conduit 0.11.1 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.11.1 (MichaelSnoyman)
07:17:00 <ph88> hey how can i make this work on windows?  E:\dev\fuzzy>cabal install fft Resolving dependencies... Notice: installing into a sandbox located at E:\dev\fuzzy\.cabal-sandbox Downloading ix-shapable-0.1.0... Downloading storable-complex-0.2.2... Configuring storable-complex-0.2.2... Configuring ix-shapable-0.1.0... Building ix-shapable-0.1.0... Building storable-complex-0.2.2... Installed storable-complex-0.2.2 Installed ix-shapable-0.1
07:17:10 <ph88> eh sorry http://pastebin.com/FYtqrtwn
07:19:23 * hackagebot blunt 0.0.16 - Point-free Haskell as a service.  http://hackage.haskell.org/package/blunt-0.0.16 (fozworth)
07:21:37 <lpaste> light pasted “speed” at http://lpaste.net/130092
07:23:37 <tdammers> regarding this issue: https://github.com/snoyberg/file-embed/issues/12
07:24:08 <tdammers> I'm wondering whether there is an efficient way of injecting raw byte data into a bytestring with TH prior to version 2.8
07:25:17 <tdammers> I'm currently pondering a route that involves C and the FFI
07:25:46 <tdammers> read the bytestring, wrap it in some C code, dump that in a temporary .c file, link it into the binary and pull it in with FFI
07:28:13 <absence> did some floating point stuff change in ghc 7.10? i have some image processing code, and after recompiling, some of the pixels output differ by 1 or so compared to output from the 7.8 compiled code
07:34:24 * hackagebot haroonga-httpd 0.1.1.0 - Yet another Groonga http server.  http://hackage.haskell.org/package/haroonga-httpd-0.1.1.0 (cosmo0920)
07:34:57 <tdammers> hmm... wonder what would happen if I define a C function in a header and {-# INCLUDE #-} that
07:36:52 <tdammers> wait no, that can't work
07:39:32 <AshyIsMe> argh, diagrams-cairo is bloody impossible to get working on osx
07:42:00 <ggVGc> AshyIsMe: maybe one day you'll have a real OS below you
07:42:00 <tdammers> hmm, I can't drive FFI includes from within TH, can I?
07:42:05 <ggVGc> until then I'll just wait
07:44:25 * hackagebot generic-aeson 0.2.0.4 - Derivation of Aeson instances using GHC generics.  http://hackage.haskell.org/package/generic-aeson-0.2.0.4 (AdamBergmark)
07:44:32 <byorgey> AshyIsMe: yes, it can be quite difficult
07:44:43 <byorgey> AshyIsMe: can I ask why you want diagrams-cairo in particular?
07:44:55 <byorgey> maybe there is another backend that will work for you
07:45:18 <AshyIsMe> i want to render to a bitmap so i can draw that on to a wxHaskell panel
07:46:31 <AshyIsMe> ggVGc: maybe one day...
07:47:35 <ph88> anyone know what to do about this?   setup-Simple-Cabal-1.22.2.0-x86_64-windows-ghc-7.8.3.exe: The pkg-config package 'fftw3f' version >=3.3 && <4 is required but it could not be found.
07:49:29 <byorgey> AshyIsMe: try the diagrams-rasterific backend
07:49:49 <byorgey> that is pure Haskell, no C libraries required, and can generate a bunch of different raster formats
07:50:07 <byorgey> you can use it to generate a bitmap in memory too, without writing it to disk
07:50:20 <AshyIsMe> ah perfect, thanks
07:50:43 <byorgey> AshyIsMe: ask in #diagrams if you need help getting it set up or figuring out how to use it to do what you want
07:51:58 <AshyIsMe> byorgey: cheers
07:54:12 <Lis> hello everyone. http://www.mathematek.de/paste:haskell_map_list can anyone help me with that?
07:55:50 <byorgey> Lis: since  runParser :: [String] -> IO [String],  then   map runParser :: [[String]] -> [IO [String]]
07:56:06 <Lis> ok, thank you
07:56:09 <byorgey> Lis: you probably want mapM instead of map
07:56:23 <byorgey> @type mapM
07:56:24 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
07:57:08 <byorgey> in this case t = [], a = b = [String], m = IO  hence   mapM runParser :: [[String]] -> IO [[String]]
07:59:26 * hackagebot total-maps 1.0.0.0 - Dense and sparse total maps.  http://hackage.haskell.org/package/total-maps-1.0.0.0 (pawel834)
08:06:05 <Lis> where does cabal store the compiled libraries?
08:07:44 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml
08:11:46 <Lis> hm when trying to install ghc 7.10.1 i get this: http://www.mathematek.de/paste:haskell_install_maybet
08:14:00 <int-e> Lis: the second error looks like a fallout of the Applicative-Monad-Proposal; Applicative is now a superclass of Monad, which is expected to break code.
08:14:19 <int-e> apparently MaybeT is one of the packages broken by this.
08:14:27 * hackagebot pcf 0.1.0.0 - A one file compiler for PCF  http://hackage.haskell.org/package/pcf-0.1.0.0 (jozefg)
08:14:33 <monochrom> perhaps 7.10.1 is too new for your purpose
08:15:36 <monochrom> it has been decided that ghc shall move faster than most programmers need because haskell platform already exists for that
08:16:06 <Lis> int-e, ah, so there was a change made to haskell, which was not applied to maybet yet?
08:16:10 <Lis> am i getting this right?
08:16:23 <int-e> Yeah, ghc-7.10.1 can still be considered bleeding edge at this time.
08:17:13 <Lis> ok thank you, good thing i didnt delete the old 7.8.4 :D
08:17:50 <int-e> Lis: more or less. (ghc is, technically, just an implementation of Haskell, and it's now incompatible with Haskell2010, the latest official specification of Haskell.)
08:18:28 <int-e> (Or did I miss a Haskell2014? Hmm.)
08:18:49 <monochrom> there has not been a Haskell 2014
08:19:27 * hackagebot csound-expression-dynamic 0.1.2 - dynamic core for csound-expression library  http://hackage.haskell.org/package/csound-expression-dynamic-0.1.2 (AntonKholomiov)
08:19:29 * hackagebot csound-expression-typed 0.0.7.1 - typed core for the library csound-expression  http://hackage.haskell.org/package/csound-expression-typed-0.0.7.1 (AntonKholomiov)
08:19:31 * hackagebot csound-expression 4.4.1 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-4.4.1 (AntonKholomiov)
08:21:29 <caribou_lands> Hi I have a question about installing the fft library with cabal on mac osx. I get the error 'Failed to install carray-0.1.5.2'. Has anyone got any idea how I might fix this
08:23:10 <dgpratt> does lambdabot have lint functionality?
08:23:19 <monochrom> no
08:23:42 <dgpratt> ok, thanks
08:23:52 <monochrom> that gives me an idea
08:25:18 <monochrom> next April 1st, lpaste's hlint should look at your do-block "do { x<-m; y<-f x; return (g x y) }" and say "why not m >>= \x -> f x >>= \y -> return (g x y)"
08:25:43 <Lis> hm still, where does cabal store it's installed package list. i only found AppData\Roaming\cabal
08:26:12 <Lis> i am on msys2. so where are the linux locations of cabal?
08:26:19 <monochrom> cabal doesn't store that list. ghc does. look for AppData\Roaming\ghc
08:26:36 <Lis> ah thank you
08:30:13 <kstuart> Lis: ghc-pkg list should also give you package locations
08:31:32 <Lis> deleting ghc perfectly solved my problem
08:31:45 <Lis> i need to backup that folder too, next time.
08:32:02 <tromp> why is it that my browser shows one prog.hs url, but wants me to download another prog2.hs url?
08:33:15 <tromp> e.g. http://www.nayuki.io/res/fast-fibonacci-algorithms/fastfibonacci.hs shows as text, while http://tromp.github.io/go/SimpleGo.hswants to download 
08:33:33 <tromp> last one is http://tromp.github.io/go/SimpleGo.hs
08:34:21 <monochrom> the web server tells your web browser the MIME type of each file, and your browser obeys (why shouldn't it)
08:35:09 <monochrom> the web server can say "text/plain" or "text/hs" or even "img/jpeg"
08:36:04 <tromp> how can i make my webserver (well, github's) declare my haskell file as text/plain ?
08:36:18 <monochrom> probably can't
08:36:29 <tromp> i was afraid you were gonna say that:(
08:36:29 <geekosaur> yeh, the download one possibly sends application/octet-stream as the mime type, or there are content dispositions that indicate download vs. other options
08:36:59 <arw> usually the webserver has a magic table of file ending to mime-type associations
08:37:10 <geekosaur> and github will do as it will, if you grab a file by name it expects download, it uses a viewer page for source
08:37:12 <monochrom> github intends you to either "git clone" or download the *.zip file anyway
08:37:15 <ggVGc> magic tables are the best
08:37:17 <tromp> ok, plan B: how can i make firefox show particular mime types as plain text?
08:37:50 <arw> in the preferences, there is an 'applications' tab 
08:37:52 <tromp> preferences/Applications doesn't allow me to add content types
08:38:15 <tromp> and there are no entries for programming lang source
08:39:28 * hackagebot cabal-bounds 0.9.3 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.9.3 (DanielTrstenjak)
08:39:43 <monochrom> oops, it's text/x-haskell
08:40:10 <tromp> how can you tell?
08:40:25 <monochrom> I asked an expert
08:40:41 <tromp> firefox should be able to tell me the content type of a url...
08:41:21 <monochrom> sometimes I write an HTTP request by hand and read the raw HTTP response myself
08:41:32 <arw> somewhere in the web developer tools you can look at response headers
08:41:42 <tromp> maybe wget can tell me...
08:41:47 <monochrom> on the bright side, I cannot do ssh traffic by hand. yet.
08:43:20 <tromp> wget shows Content-Type: application/octet-stream
08:43:23 <monochrom> that does give me an idea. if I want to do https by hand, I can let stunnel do the translation for me so I just have to do http by hand
08:44:15 <geekosaur> and then you get the fun where it serves different headers based on the user agent header in the http/1.1 request
08:44:24 <monochrom> :)
08:44:26 <tromp> lynx also shows application/octet-stream
08:44:35 <WarzoneCommand> Can someone tell me why I get a ''Unknown extensions: PatternSynonyms'' error when uploading my package to hackage? compiling locally with cabal works fine 
08:44:48 <tromp> with options download or cancel (no view:()
08:45:15 <monochrom> every web server can do a different thing
08:45:37 <geekosaur> application/octet-stream is assumed by browsers to be binary data
08:46:14 <monochrom> also, it's image/jpeg rather than img/jpeg
08:47:14 <monochrom> let me give you a delayed April 1st joke of a whole bunch of *.hs filenames (on the surface) such that each has a different MIME type and none contains Haskell code
08:49:20 <mauke> I have a solution for text/x-haskell and content-disposition, but I can do nothing about application/octet-stream
08:49:25 <tromp> maybe i shld rename my SimpleGo.hs to SimpleGo.hs.txt to give it a sensible content type
08:49:41 <monochrom> no, you should stop using github :)
08:49:46 <mauke> workaround: view-source:http://tromp.github.io/go/SimpleGo.hs
08:49:53 <tromp> i'm too invested in github :(
08:50:24 <monochrom> well, I use github too, but I don't worry about that issue. not a normal use-case anyway
08:51:15 <tromp> thx, mauke, that works
08:51:47 <hexagoxel> WarzoneCommand: might be hackage issue. does `cabal check` report no problems? you might want to ask in #hackage
08:51:56 <tromp> but i prefer other ppl clicking on my link to just see the source
08:52:15 <WarzoneCommand> cabal check says 'no errors or warnings found'
08:52:21 <WarzoneCommand> ok 
08:54:23 <Aruro> @src map
08:54:23 <lambdabot> map _ []     = []
08:54:23 <lambdabot> map f (x:xs) = f x : map f xs
08:55:25 <tromp> ok; http://tromp.github.io/go/SimpleGo.hs.txt works, even if ugly
08:57:14 <mniip> is there a library with classical ciphers anywhere
08:57:43 <mniip> I mean stuff like rotation, monoalphabetic substitution, vigenere, caesar, playfair, foursquare
08:57:46 <tromp> github seems pretty braindead for determining content type purely by filename extension, and declaring unknown ones as octet-stream
08:58:20 <tromp> running "file go/SimpleGo.hs" shows it to be ASCII text
08:59:56 <Aruro> @src fmap
08:59:57 <lambdabot> Source not found. Are you on drugs?
09:00:14 <Aruro> @src foldr
09:00:15 <lambdabot> foldr f z []     = z
09:00:15 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:00:36 <eacameron> how does acid state clean up after itself? I've never used it, but I'm curious how it "garbage collects" unreachable, old state
09:01:10 <funke> ! 7**5
09:01:41 <mniip> it's > also consider PMing lambdabot instead
09:02:18 <Clint> or running lambdabot locally
09:03:38 <funke> > 7**5
09:03:39 <lambdabot>  16807.0
09:04:26 <mniip> Clint, or ghci for that matter
09:04:28 <funke> > [7**5, 5**7]
09:04:29 <lambdabot>  [16807.0,78125.0]
09:04:32 <monochrom> simply run your own ghci
09:04:47 <funke> > [7**5, 5**7, exp (1+:1)]
09:04:48 <lambdabot>      Not in scope: ‘+:’
09:04:48 <lambdabot>      Perhaps you meant one of these:
09:04:48 <lambdabot>        data constructor ‘:+’ (imported from Data.Complex),
09:04:55 <monochrom> are you done yet?
09:04:55 <funke> > [7**5, 5**7, exp (1:+1)]
09:04:56 <lambdabot>  [16806.99999999998 :+ 0.0,78125.0 :+ 0.0,1.4686939399158851 :+ 2.28735528717...
09:05:03 <mauke> funke: stop. hammer time.
09:05:17 <quchen> funke: You can also message lambdabot in private (/msg lambdabot) when you just want to try things out (as opposed to demonstrating code to others). 
09:05:18 <mauke> or is that "collaborate and listen"?
09:05:36 <funke> ok
09:06:08 <Clint> mniip: well, in this case, sure
09:09:30 * hackagebot second-transfer 0.1.0.0 - Second Transfer HTTP/2 web server  http://hackage.haskell.org/package/second-transfer-0.1.0.0 (dsign)
09:09:32 * hackagebot pcf 0.1.0.1 - A one file compiler for PCF  http://hackage.haskell.org/package/pcf-0.1.0.1 (jozefg)
09:11:49 <absence> how can i write a Data.Vector.Storable to disk?
09:12:39 <andbroby> is emacs' haskell-mode turning >>= into >≥ for anyone else? seems like http://git.io/veq22 would be the culprit but since github doesnt let you search for symbols like >= i don't know if there's something in place to prevent it from activating on >>= somewhere else. my emacs version is 24.4 and haskell-mode is the newest one from melpa, so that shouldnt be an issue. :|
09:13:40 <quchen> andbroby: clone and grep the source? I'm not using Emacs, but when Github won't let you search something that's a good start.
09:14:36 <andbroby> yeah, i'm going to do that, just wanted to see if someone else was having the same issue.
09:16:25 <quchen> It sounds like an unrelated error though, I cannot imagine Emacs' Haskell mode messing with >>=
09:16:45 <quchen> It's as if your C IDE changed ; handling
09:18:55 <andbroby> should have specified; it's when using haskell-font-lock-symbols which makes it display things like forall as ∀, \ as λ etc. it's awesome, but having it display >>= wrong is kind of annoying. the actual string in the file is unchanged though, it's just for display.
09:19:39 <quchen> andbroby: In that case it might just be an issue with your font
09:20:08 <quchen> I could imagine the ≥ symbol is rendered as a squashed >= in some fonts
09:20:17 <quchen> So a neat >>= is composed of > and >=
09:20:33 <quchen> I don't think there's a >>= in Unicode, I searched that myself recently
09:20:46 <quchen> All there is is >>-
09:21:35 <geekosaur> shouldn't it be something like a fat double arrowhead anyway?
09:22:04 <quchen> >>= should be rendered as ">>=" if you ask me.
09:22:11 <quchen> So much for "should" ;-)
09:22:45 <quchen> Although I'm quite happy the initial devs chose the bitwise right-shift assign operator for bind, because it's a common operator in other languages, so other keyboard layouts often support it well. :-)
09:24:31 * hackagebot network-bitcoin 1.8.0 - An interface to bitcoind.  http://hackage.haskell.org/package/network-bitcoin-1.8.0 (ClarkGaebel)
09:24:56 <geekosaur> right, I had understood >>= to be an ASCII approiximation of U+27BE
09:25:18 <GnuYawk> true
09:25:29 <geekosaur> or maybe that with the head on the other side but pointing the same direction...
09:25:44 <JordiGH> In a deriving clause, you can only use Read, Show, Eq, Ord, Bounded and Enum, right? Nothing else?
09:26:00 <quchen> You mean ➾?
09:26:07 <JordiGH> I meant the deriving keyword.
09:26:20 <geekosaur> JordiGH, in standard Haskell
09:26:22 <JordiGH> data Foo = ... deriving (omg, lol, wtf)
09:26:24 <monochrom> if you turn on extensions, there are a couple more, e.g. DeriveFunctor (sp?) gives you "deriving Functor"
09:26:28 <quchen> JordiGH: In Haskell your choices are limited. GHC has some extensions to that though.
09:27:10 <geekosaur> also there's an extension to derive existing things "through" a newtype
09:30:15 <S11001001> JordiGH: might as well derive Data, Generic, Typeable if possible; Functor, Foldable, Traversable if you have a tparam and it's amenable; every Monad* class from mtl if you implement if it's a newtype and monad, which is all of them if you produce a transformer
09:30:18 <S11001001> :)
09:30:46 <JordiGH> S11001001: I know I can derive more things. I just want to know which ones I can fit in a deriving clause.
09:31:16 <S11001001> JordiGH: all of them
09:31:46 <JordiGH> S11001001: Huh? This contradicts my understanding. I can automatically derive, say, Foldable?
09:32:21 <glguy> GHC has extensions: DeriveDataTypeable, DeriveFoldable, DeriveFunctor, DeriveGeneric, DeriveTraversable
09:32:47 <quchen> glguy: Do you know how safe these extensions are? Are there way to construct bad instances?
09:33:06 <glguy> No, those instances actually write the code
09:33:29 <quchen> glguy: Sure, but the code might still be wrong, e.g. violate the Functor laws.
09:33:53 <glguy> It'd be tough to generically derive a functor instance that did that
09:34:04 <glguy> this one is safe, though. 
09:34:32 * hackagebot Win32-dhcp-server 0.3 - Win32 DHCP Server Management API  http://hackage.haskell.org/package/Win32-dhcp-server-0.3 (MichaelSteele)
09:34:34 * hackagebot cabal-cargs 0.7.7 - A command line program for extracting compiler arguments from a cabal file.  http://hackage.haskell.org/package/cabal-cargs-0.7.7 (DanielTrstenjak)
09:35:14 <glguy> There's also the new DeriveAnyClass extension which creates empty instance declarations for the other classes it doesn't know about
09:35:25 <glguy> This can be useful when you have a class with a default implementation that uses Generics
09:36:24 <quchen> What's an empty instance declaration? You mean something like "instance MonadPlus m where"?
09:36:29 <S11001001> JordiGH: yes
09:36:51 <glguy> quchen: Yeah, (and also the 'where' isn't necessary)
09:36:58 <quchen> glguy: I guess what I'm concerned about is getting incorrect yet typechecking programs.
09:37:05 <glguy> quchen: ok
09:37:07 <quchen> glguy: Thanks, I can never remember the syntax :-)
09:37:09 <tromp> i sent a request to github to improve their content-type determination. let's see how well their customer service is...
09:38:07 <monochrom> try "newtype Eat a = Ctor (a -> Eat a) deriving Functor" and see what happens
09:38:30 <quchen> tromp: They sure took (take?) their time fixing the incorrect parser behaviour when "'" is involved with promoted types
09:39:10 <glguy> "customer" server? Are you paying them?
09:39:31 <tromp> yes, i have a paid account so i can have private repositories
09:39:40 <quchen> Booya.
09:40:01 <glguy> Neat, maybe you can buy us better Haskell support :)
09:40:51 <quchen> glguy: That would be the equivalent of someone believing to have a right to a parking space in front of the town hall because he's a taxpayer ;-)
09:41:05 <glguy> I pay that police officers salary
09:41:12 <JordiGH>     Can't make a derived instance of `Foldable Lol':
09:41:12 <JordiGH>       You need -XDeriveFoldable to derive an instance for this class
09:41:12 <JordiGH>     In the data type declaration for `Lol'
09:41:41 <glguy> JordiGH: You need -XDeriveFoldable to derive an instance for this class
09:41:52 <JordiGH> glguy: Your C&P is amazing.
09:41:58 <JordiGH> So, do I need one of these -XDeriveFoo clauses each time I want to automatically derive one of those?
09:42:48 <glguy> Just once at the top of the file
09:42:49 <monochrom> -X or {-# LANGUAGE
09:43:13 <monochrom> preferrably {-# LANGUAGE
09:43:38 <monochrom> unless you plan to write a huge Makefile that calls ghc
09:44:51 <JordiGH> But for each thing I want to automatically derive, there's an -XDeriveBlah thing?
09:45:08 <JordiGH> Can I make up my own typeclass and allow automatic derivation of it?
09:46:04 <glguy> There are 3 kinds of things that you can put in the deriving clause, the normal ones like Eq,Ord,Show,Read, the 6 I mentioned that have special extensions above
09:46:23 <glguy> and then new is this DeriveAnyClass extension that allows you to use the default implementation via the deriving clause
09:46:40 <JordiGH> Okay.
09:46:53 <JordiGH> And all of this is new and scary or already wildly used and understood?
09:47:02 <JordiGH> Will people squint at my code if I do this?
09:47:24 <JordiGH> I write code mostly for others, only partially for myself.
09:47:25 <coltfred> I was reading the haskell documentation and stumbled across `data StdGen`. I can't seem to locate the source for this file, but I find it confusing to have a data type with no constructors. Is this useful because you can use newtypes around it or am I missing something? https://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:StdGen
09:48:08 <JordiGH> Hahaha, someone just teased me with this: http://narf-archive.com/pix/49518cf17ceab781214c47faeea9b8584675e830.jpg
09:48:09 <glguy> DeriveAnyClass is new to 7.10.1, but shouldn't be particular controversial. The 6 explicit extension ones aren't surprising
09:48:25 <coltfred> Oh, I found the source.
09:48:34 <coltfred> I see now that there is a constructor.
09:48:45 <glguy> coltfred: You can have an "abstract" data type by only exporting the type and not its data constructors
09:49:00 <coltfred> glguy: Oh, that's the deal... 
09:49:07 <coltfred> It's there, just not exported.
09:50:16 <AX3L> I'm just beginning haskell and I have a question. Why does the compiler interpret "foo.bar x" as "foo.(bar x)" instead of "(foo.bar) x"?
09:50:46 <JordiGH> AX3L: That's just the way it is, function application has highest precedence.
09:50:56 <glguy> function application has the highest precedence, the whitespace doesn't influence that
09:50:59 <JordiGH> AX3L: I think it's weird that sin.cos 2 doesn't parse, but I've gotten used to it.
09:51:33 <JordiGH> AX3L: It's like mathematics. You never really understand anything, you just get used to it.
09:51:34 <glguy> It allows you to write f x + g y, for example
09:51:48 <JordiGH> glguy: I think . should have higher precedence, but meh.
09:54:10 <AX3L> Okay Thanks! If that's just they way it is I'll get used to it.
09:54:32 * hackagebot hsimport 0.6.5 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.6.5 (DanielTrstenjak)
10:09:33 * hackagebot total-maps 1.0.0.1 - Dense and sparse total maps.  http://hackage.haskell.org/package/total-maps-1.0.0.1 (pawel834)
10:09:53 <ReinH> AX3L: It's better to be able to say map f . filter p and (foo . bar) x than (map f) . (filter p) and foo . bar x. If function application had low precedence, using juxtaposition to represent it would be a strange choice.
10:10:11 <ReinH> Since you'd end up having to use parens everywhere anyway
10:32:06 <PrakashTheGreat> hello
10:32:09 <PrakashTheGreat> can u see me
10:32:24 <koala_man> PrakashTheGreat: yes
10:32:31 <PrakashTheGreat> awesome
10:38:45 <Redz> hello, is there an argument why putting a non-type-variable argument in a MonadReader constraint is a bad idea? for example: 
10:38:45 <Redz> class MonadReader World m => Interact m where ...
10:38:45 <Redz> without flexible contexts, this isn't working. 
10:45:27 <enthropy> Redz: I don't think you're restricting the number of haskell implementations your code can run on by turning on -XFlexibleInstances
10:46:30 <NemesisD> is there a way in STM to deliberately rollback a transaction but return a value you obtained
10:46:52 <NemesisD> something like x <- takeSomeValue; abort; return x
10:48:06 <ReinH> FlexibleInstances and FlexibleContexts are pretty reasonable extensions.
10:49:31 <enthropy> anybody know of a https://github.com/luqui/parsec-layout/blob/master/Text/Parsec/Layout.hs for uu-parsinglib?
10:51:04 <Cale> NemesisD: You could throw an exception containing the value.
10:51:55 <Redz> thanks you, I hope it doesn't break something.
10:52:09 <ReinH> o_O
10:52:56 <NemesisD> Cale: yikes. well i guess its worth a shot
10:53:20 <enthropy> writing an IORef with unsafeIOToSTM probably seems better
10:53:43 <Cale> Well, throwing an exception from inside an STM action will cause it to roll back correctly
10:54:02 <glguy> enthropy: I don't know if a library exists or not, but this is how I was doing layout in parsec. You might just copy the 4 definitions: https://github.com/glguy/config-value/blob/503f6f34b8ebeeec14f21b320290ec97634fdd28/src/Parser.hs
10:54:56 <glguy> enthropy: based on http://dev.stephendiehl.com/fun/008_extended_parser.html
10:55:08 <Cale> Note also that it's easy to make a new exception type especially for doing this.
10:58:46 <guest87654567> I have no programming experience and I am looking for introductory material to start learning Haskell
10:59:01 <athan> Is there a way to put a maximum bound for QuickCheck Arbitrary instances? I see `listOf1` gives a minimum, but how would I say something like "no more than 20"?
10:59:20 <athan> @learn guest87654567 :)
10:59:20 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
10:59:36 * hackagebot list-tries 0.6.1 - Tries and Patricia tries: finite sets and maps for list keys  http://hackage.haskell.org/package/list-tries-0.6.1 (MattiNiemenmaa)
10:59:40 <NemesisD> Cale: by god it works!
11:00:24 <enthropy> athan: do n <- choose(0,20); replicateM n arbitrary
11:00:36 <athan> enthropy: Thank you!!
11:01:56 <Cale> guest87654567: You might try http://www.seas.upenn.edu/~cis194/spring13/lectures.html though I'm pretty sure it's not quite aimed at people with no programming experience, it's overall quite good, and you can always ask for help with things here
11:02:39 <Cale> guest87654567: There's also the book here, http://learnyouahaskell.com/chapters which you might like
11:03:00 <guest87654567> Thanks!
11:05:57 <enthropy> glguy: thanks those are a bit simpler than luqui's example
11:20:03 <nmontecc> question for emacs people: how do I disable the wavy lines that mark the indent locations? e.g. these: http://snag.gy/Dy354.jpg -- they started appearing in the past week or so and I haven't been able to figure out how to get rid of them
11:24:39 <nmontecc> nevermind found it - set hi2-show-indentations variable to nil
11:28:38 <ReinH> Cale: Maybe someone should write a Haskell text in the style of Conceptual Mathematics
11:29:37 * hackagebot total-maps 1.0.0.2 - Dense and sparse total maps.  http://hackage.haskell.org/package/total-maps-1.0.0.2 (pawel834)
11:29:39 <Cale> ReinH: I'm not entirely sure what that would mean :)
11:31:39 <ReinH> Cale: Similarly few prerequisites, similar style.
11:31:51 <ReinH> Similarly good exercises.
11:51:14 <Assassins> .Dr.even
11:51:48 <Assassins> :)
11:54:38 * hackagebot http-client-streams 0.3.1.0 - http-client for io-streams supporting openssl  http://hackage.haskell.org/package/http-client-streams-0.3.1.0 (DavidJohnson)
11:57:57 <Rainb> is there a #functional channel out there
11:58:24 <Rainb> for non-haskell functional discussion
12:10:38 <PrakashTheGreat> anyone know of a good irc client
12:10:43 <PrakashTheGreat> this shit hurts me eyes
12:11:22 <narendraj9> PrakashTheGreat: I use weechat. I am happy with it. 
12:11:33 <rpaehlig_> Hi! I'm looking for a way to validate XML documents against XML Schemas (.xsd files). This article suggests HXT is capable of this: https://www.fpcomplete.com/school/advanced-haskell/xml-parsing-with-validation. But looking at the documentation (http://hackage.haskell.org/package/hxt/docs/Text-XML-HXT-Arrow-ReadDocument.html) reveals that only DTD and RelaxNG validation is implemented. Am I missing something?
12:11:33 <mniip> heh, qwebirc iws barely an irc client
12:11:54 <PrakashTheGreat> @scottj
12:11:55 <lambdabot> Unknown command, try @list
12:12:04 <PrakashTheGreat> this is painful
12:12:05 <PrakashTheGreat> im out
12:14:19 <monochrom> rpaehlig_: I think I have only seen hxt doing dtd and relaxng, too
12:16:48 <rpaehlig_> monochrom: are you aware of other packages which allow validation against .xsd?
12:17:03 <monochrom> indeed, the article shows relaxng only. as for xsd, the key phrase to look for is "we won't use it"
12:18:13 <rpaehlig_> You are right. I just interpreted this as "We won't use it in our examples".
12:19:47 <monochrom> I don't know other packages
12:21:26 <rpaehlig_> Too bad. Haskell seemed to be a good fit for the job. But schema validation is non-negotiable. Thank you anyway!
12:21:48 <johnw> rpaehlig_: why not convert to RelaxNG?
12:21:54 <johnw> I did that for the XSD we use at work
12:22:24 <monochrom> was it manual conversion? was it grunt work?
12:22:40 <johnw> it was automated, just running two commands
12:22:52 <johnw> one to convert XSD -> RelaxNG, another to go from RelaxNG to Compressed RelaxNG
12:23:07 <rpaehlig_> can every .xsd expressed in .rng without loss of information?
12:23:11 <johnw> no, not every
12:23:51 <johnw> also, there is http://hackage.haskell.org/package/HaXml-1.25.3/docs/Text-XML-HaXml-Schema-Schema.html
12:23:58 <johnw> "A SchemaType promises to interconvert between a generic XML content tree and a Haskell value, according to the rules of XSD."
12:24:40 <rpaehlig_> johnw: Now that sounds interesting. I'll check. Thanks!
12:24:48 <johnw> which seems like it requires you writing your own instances to do verification of custom types
12:26:09 <johnw> Also, if you're an Emacs user, doing the conversion to relaxNG will give you verification in nxml-mode
12:26:22 <johnw>  which is why I did it
12:35:06 <rpaehlig_> I have to deal with many schemas, 200+ at the moment. They change over time and new ones are introduced as well. Anything that involves manual work won't do. But I will look into automatic .xsd->.rng conversion. I have to find the cases which cannot be expressed in RelaxNG.
12:38:59 <johnw> I have about 40, and I think it had issues in only two places that were trivial manual fixes
12:44:39 <johnw> rpaehlig_: you'll need this info: http://stackoverflow.com/questions/122089/xsd-to-rnc-or-rng-conversion-unix-command-line
12:45:10 <johnw> I used rngconv for XSD->RNG, and trang for RNG->RNC (which you may not need)
12:45:53 <johnw> the best way to find out whether the conversion really works for you is to build some kind of testing that does a round-trip followed by a comparison
12:46:21 <rpaehlig_> johnw: thank you! and rngconv failed on only two of your fourty instances, right?
12:46:26 <johnw> it didn't fail
12:46:33 <johnw> just the regexp it produced wasn't valid
12:46:48 <johnw> (in the rnc file)
12:47:00 <johnw> it got the escaping of a special character wrong
12:47:45 <rpaehlig_> that doesn't sound too bad. I'll give it a shot.
12:49:41 * hackagebot quenya-verb 0.0.1 - Quenya verb conjugator  http://hackage.haskell.org/package/quenya-verb-0.0.1 (kaashif)
12:50:23 <Luke> what's a .o_p file?
12:52:13 <neuroserpens> Can anyone give me an example of how to use =<<
12:52:14 <neuroserpens> ?
12:52:49 <Clint> neuroserpens: print =<< myThingy
12:52:52 <rpaehlig_> Luke: An object file w/ profiling information
12:53:01 <mauke> putStrLn =<< getLine
12:53:18 <Luke> rpaehlig_: looks like my compile is running twice once with profiling objects and once without
12:53:26 <johnw> Luke: yep
12:53:31 <johnw> Luke: that's as it should be
12:53:35 <Luke> why's that?
12:53:46 <johnw> probably because you're using TH in some way
12:54:00 <Luke> I use lens makeLens stuff
12:54:02 <Luke> is that enough?
12:54:11 <neuroserpens> thankss Clint and mauke
12:55:57 <neuroserpens> Another question... I'm trying to map read words getLine on user input but everything I write yield a crazy error I can't understand
12:56:07 <neuroserpens> yields*
12:56:16 <johnw> indeed
12:56:19 <mauke> start with 'line <- getLine'
12:56:36 <mauke> then you can run map read (words line)
12:56:52 <neuroserpens> mauke: I can't do that in one line then?
12:57:12 <muyfine> having trouble figuring out how to use aeson with "named" dictionaries
12:57:24 <muyfine> have data that looks like: http://lpaste.net/130102
12:57:34 <mauke> sure you can: do line <- getLine; print (map read (words line))
12:57:38 <muyfine> my code right now looks like: http://lpaste.net/130100
12:57:49 <EvanR> neuroserpens: you can
12:57:50 <muyfine> which works for data that looks like: http://lpaste.net/130101
12:58:02 <mauke> print . map read . words =<< getLine
12:58:18 <Luke> "hpc: can not find text_IINWRW1LxFGIctooOLjJAI/Data.Text.Unsafe" why would this be?
12:58:25 <muyfine> but having trouble figuring out how to parse the names out when they're the name of the dictionary
12:58:38 <neuroserpens> thanks mauke 
12:58:59 <EvanR> neuroserpens: you can apply a function to the results of doing a IO action by using fmap
12:59:09 <mauke> :t getLine >>= words >>> map read >>> print
12:59:10 <lambdabot>     Precedence parsing error
12:59:10 <lambdabot>         cannot mix ‘>>=’ [infixl 1] and ‘>>>’ [infixr 1] in the same infix expression
12:59:15 <mauke> :t getLine >>= (words >>> map read >>> print)
12:59:16 <lambdabot> IO ()
12:59:28 <neuroserpens> triple ">"?
12:59:32 <neuroserpens> I have never even seen that
12:59:42 <arkeet> >>> is flipped <<<
12:59:44 <arkeet> <<< is .
12:59:47 <neuroserpens> wow
12:59:55 <arkeet> from Control.Category
13:00:23 <EvanR> if you want print, thats another issue, but map, read and words are all pure functions which you can compose of apply to IO a with fmap
13:00:35 <EvanR> and apply*
13:00:53 <arkeet> I think the two-line version is nice and clear.
13:00:57 <mauke> :t getLine >>= (words <&> map read <&> print)
13:00:58 <lambdabot> IO ()
13:01:14 <EvanR> uhg
13:02:02 <monochrom> I have a radical idea. I propose to rename Control.Category to Math.Category
13:02:27 <mauke> Theory.Category
13:02:32 <EvanR> Math.Monoid, Math.Functor
13:02:44 <EvanR> im on board with this
13:02:47 <mauke> our functors are too endo
13:03:38 <neuroserpens> :t getLine >>= print . map read . words
13:03:40 <lambdabot> IO ()
13:03:45 <EvanR> Control doesnt seem to make sense for really anything
13:04:01 <neuroserpens> If I try that and type 1 2 3 4 I get a prelude.readd no parse exception
13:04:27 <arkeet> you need to specify the type of the thing to read to.
13:04:35 <arkeet> try annotating it like
13:04:39 <arkeet> (read :: String -> Int)
13:04:43 <neuroserpens> hm
13:04:47 <arkeet> else I think it defaults to ()
13:04:51 <mauke> (read :: ReadS Int)
13:04:53 <EvanR> which you probably only need to do on ghci
13:04:59 <neuroserpens> oh
13:05:05 <neuroserpens> Is it because I'm in ghci then
13:05:22 <EvanR> because in source code you probably have a top level type annotations
13:05:32 <neuroserpens> hm
13:05:45 <arkeet> EvanR: no top level type annotations will help with getLine >>= print . map read . words
13:06:19 <athan_> Hey guys, I think my quickcheck tests are combinatorically exploding. Does anyone know of a good rememdy for this?
13:06:21 <arkeet> yeah, I guess normal ghc won't even compile it
13:06:24 <arkeet> because ambiguous tpye
13:06:43 <monochrom> when ghci differs from ghc, just remember: ghci is wrong
13:07:13 <monochrom> that is right, even when ghci doesn't give you an error message and ghc does.
13:07:14 <arkeet> monochrom: except about the monomorphism restriction
13:07:20 <arkeet> :>
13:08:43 <Desu> specially when ghci doesn't give you an error message but ghc does
13:08:51 <monochrom> athan_: theorem proving is a way to use a small amount of time and space to cover an exponentially huge set of test cases.
13:09:36 <athan_> monochrom: Are there ways to prove theorems for haskell code? Besides Coq extraction?
13:09:59 <EvanR> pencil and paper
13:10:07 <monochrom> for example, for boolean variables, a simple proof of "a and b and c and d and e = e and b and c and a and d, by associativity and commutativity" saves you 2^5 tests.
13:11:32 <EvanR> on the other hand automatic checking of 2^5 tests would be pretty nice
13:12:04 <EvanR> automatic checking of automatically written tests
13:17:02 <athan_> monochrom: Thank you
13:17:18 <athan_> I remember chrisdone working on some kind of template haskell prover or something
13:19:09 <athan_> maybe hermit?
13:19:58 <dolio> I think liquid haskell would be the most recommendable.
13:20:28 <johnw> liquid haskell++
13:21:27 * athan_ turns baseball cap backwards
13:21:36 <athan_> It's like a switch, man
13:23:55 <c_wraith> I need to get into liquid haskell.
13:24:30 <c_wraith> I like that it's just additional annotations in comments. It means that no extra tools are needed to compile it, just check it.
13:25:09 <c_wraith> So it's extra safety while writing code that's fully compatible with all other haskell.
13:32:40 <tromp> i just got a response to my github content-type determination request, thanking me for the suggestion and primising to "pass it along to the team", but no promise if/when it will be implemented
13:34:42 * hackagebot dual-tree 0.2.0.6 - Rose trees with cached and accumulating monoidal annotations  http://hackage.haskell.org/package/dual-tree-0.2.0.6 (BrentYorgey)
13:45:07 <johnw> c_wraith: it's super-easy to get started with these days, now that you can write measures as ordinary Haskell functions
13:45:20 <johnw> (which is only about a month old)
13:45:45 <johnw> and gridaphobe is quite open to bug reports and feature requsets
13:47:22 <monochrom> I should learn more about liquidhaskell, too
13:47:43 <johnw> there's a very nice PDF tutorial now
13:49:04 <johnw> https://github.com/ucsd-progsys/liquidhaskell-tutorial/blob/master/pdf/programming-with-refinement-types.pdf
13:49:10 <johnw> with over 75 exercises
13:53:44 <c_wraith> johnw: well, I was going to go through the html version of that.
13:53:47 <c_wraith> (hate pdfs)
13:54:04 <johnw> I live for pdfs
13:59:30 <Luke__> "hpc: can not find text_IINWRW1LxFGIctooOLjJAI/Data.Text.Unsafe" -- anyone know why I would get that? On my test-suite directive in cabal i have -fhpc
13:59:38 <Luke__> this used to work before I updated to 7.10. I reinstalled everything in 7.10
13:59:44 * hackagebot edit-distance-vector 1.0.0.1 - Calculate edit distances and edit scripts between vectors.  http://hackage.haskell.org/package/edit-distance-vector-1.0.0.1 (ThomasSutton)
14:02:09 <hpc> hey, i never said that
14:02:15 <hpc> :P
14:06:24 <Luke> hpc: haha
14:13:32 <wgosling> weird/dump question: Sometimes when I have a type error, the complier says "NB: 'Foo' is defined in 'Foo'". What does the NB stand for? The only thing I can think of is "New Brunswick" but that is probably not it...
14:14:27 <bscarlet> http://en.wikipedia.org/wiki/Nota_bene
14:14:27 <verement> "Nota Bene
14:14:55 <wgosling> Thanks.
14:15:13 <bscarlet> NP
14:15:41 <Rotaerk> is the doctor in here/
14:15:46 <Luke> anyone got any hpc love for me here?
14:15:50 <Luke> "hpc: can not find text_IINWRW1LxFGIctooOLjJAI/Data.Text.Unsafe" -- anyone know why I would get that? On my test-suite directive in cabal i have -fhpc
14:16:12 <ion> Sometimes the IRC says “NP”. What does the NP stand for? The only thing I can think of is “North Pole” but that is probably not it…
14:16:21 <ion> J/K.
14:16:25 <kaidelong> no problem
14:16:33 <wgosling> ion: lol
14:16:40 <hexagoxel> "nota problem"
14:16:43 <yuung> let's say i define a data type with a ctor that takes an integer.  after i construct the data type, i can't change its integer value, right?
14:16:46 <wgosling> I did say it was going to be a dumb question!
14:16:54 <yuung> and this is what people mean when they say haskell is stateless?
14:17:47 <Rotaerk> yuung, they're called value constructors because they construct values
14:17:53 <Rotaerk> not objects or variables
14:18:23 <yuung> Rotaerk ah, okay
14:18:34 <absence> how are readFile and writeFile in Data.ByteString.Lazy supposed to be used? by in the naive way, they seem to gobble more and more memory for each use, so i wonder if there's a problem related to lazy IO and files not being closed or something
14:18:36 <yuung> so haskell doesn't have "objects" in the traditional sense
14:19:04 <ion> Haskell has values in the even more traditional sense. :-P
14:19:20 <monochrom> NP stands for the Latin phrase Non Problemo
14:19:24 <Luke> johnw: you around?
14:20:18 <Rotaerk> yuung, mutability, in the sense of value-holders that can have their values changed, can be done in haskell, but it's not a language feature so much as a library
14:20:24 <johnw> Luke: I'm here
14:20:34 <yuung> Rotaerk, i see
14:20:45 <Luke> johnw: i need some help w/ hpc issue i'm having
14:20:59 <Luke> johnw: "hpc: can not find text_IINWRW1LxFGIctooOLjJAI/Data.Text.Unsafe" -- On my test-suite directive in cabal i have -fhpc
14:21:12 <Rotaerk> yuung, and objects aren't really simple, and most OOP programmers don't really understand what they are at a fundamental level
14:21:30 <yuung> Rotaerk what would you have them defined as?
14:21:32 <Luke> johnw: does that mean I didn't compile Data.Text with profiling or does that mean something else?
14:21:54 <johnw> Luke: that doesn't sound right
14:21:55 <Rotaerk> yuung, an interface is essentially a record type where all the members are functions.  an object is essentially an instance of that record type
14:22:04 <johnw> I'm not familiar with these text_* symbols
14:22:07 <Rotaerk> and a constructor, in the OOP sense, is a function that produces such an instance
14:22:39 <Luke> johnw: all my libraries were compiled in a sandbox but the -fhpc flag is only on the test-suite directive not the library directive
14:22:51 <EvanR> Rotaerk: the members might be functions
14:23:17 <Rotaerk> EvanR, as in they might *not* be?
14:23:25 <monochrom> at first sight, an object looks simply like a record of variables and procedures. (even then, it is already way more sophisticated than, say, a mathematical function which is what Haskell code usually does)
14:23:40 <johnw> Luke: I don't have any ideas, sorry
14:23:41 <Rotaerk> EvanR, in a C# interface, all the members are generally functions, I think
14:23:51 <Rotaerk> they can also be properties, but those are just syntax-sugared methods
14:23:58 <Luke> johnw: ok thanks
14:24:28 <Rotaerk> haskell is of course more flexible, so to limit a record type to the capabilities of a C# interface is ... unnecessarily restrictive
14:24:45 <EvanR> oh i didnt know we were talking about c#
14:24:58 <caconym> here is an article that is related to this topic: https://www.fpcomplete.com/user/meiersi/the-service-pattern
14:25:09 <platz> traditional objects tend to have references to self from inside too
14:25:10 <monochrom> the real trouble begins when you have inheritance and virtual methods (dynamic dispatch). teachers usually gross over how advanced this really is, just handwaving it with "it's obvious, you know what I mean"
14:25:11 <Rotaerk> EvanR, we were talking about OOP; C# is a good language to represent the mainstream conception of OOP
14:25:25 <Rotaerk> platz, that's just a closure really.
14:25:26 <EvanR> is it :S
14:25:42 <monochrom> no, it is not obvious, and I don't know what you mean. but once you write it down very carefully and rigorously (no handwaving allowed), ...
14:25:50 <fluvian> how can I efficiently perform bitwise operations on bytestrings? e.g. XOR two long bytestrings
14:26:21 <monochrom> an object that involves virtual methods is the fixed point of a function from objects to objects.
14:26:38 <fluvian> using Data.Bits operates on individual Word8s
14:26:53 <fluvian> if efficiency is important should I use FFI?
14:27:10 <monochrom> this is because virtual methods involve self-references. every self-reference is a recursion (fixed point)
14:27:11 <EvanR> fluvian: theres zipWith in the ByteString package
14:27:35 <Rotaerk> monochrom, you don't need self reference
14:27:47 <Rotaerk> the only reason self reference is needed is to allow you to access the other members of it
14:27:49 <EvanR> you sometimes do
14:27:52 <fluvian> EvanR: zipWith is close to what I need but it produces list output which must then be reconstructed to ByteString
14:27:57 <monochrom> no teacher wants to talk about this, since they want to preserve the pretense that OOP is not academic.
14:28:04 <EvanR> Rotaerk: or to return a modified version of yourself
14:28:09 <monochrom> but OOP came from academia. no more no less.
14:28:15 <Rotaerk> EvanR, yea, but again, that's doable just with closures
14:28:27 <EvanR> fluvian: well, if you dont do it, an implementation that returns a new bytestring would have to do it
14:28:45 <Rotaerk> and virtual methods and inheritance aren't anything special; they're still merely records of functions
14:28:45 <EvanR> fluvian: so using zipWith then pack should work
14:28:59 <EvanR> Rotaerk: well yeah, but the closure is the self reference
14:29:06 <Rotaerk> sure
14:29:18 <monochrom> there were many PhD theses and academic papers on OOP and what happens once you write it down carefully. look for Luca Cardelli
14:30:05 <monochrom> it turns out that, when you write down both OOP and Haskell carefully, Haskell is simpler and gets just as much work done.
14:30:46 <EvanR> well cardelli is one alternate reality of oop
14:31:48 <josephle> monochrom: OOP is complex. I wrote a paper on first-class classes with static types, and I ended up having to pull in dependent types to get soundness :(
14:31:58 <fluvian> EvanR: that's probably efficient enough for my purposes. I was hoping to avoid the overhead of making a list but I guess it's asymptotically equivalent anyway
14:32:12 <Rotaerk> if you have a constructor:  createFoo :: ... -> Foo;  you can "inherit" Bar from Foo just by putting a Foo inside the Bar record, and creating a createBar :: ... -> Bar which internally constructs Foo with createFoo
14:32:21 <EvanR> fluvian: its easy to jump to conclusions about what you think ghc is going to do with your code
14:32:32 <monochrom> yes, type systems for OOP are really hard to get right, even really hard to invent to begin with
14:32:40 <Rotaerk> similar to how the ctor of a derived class in C# calls the ctor of the base class
14:32:42 <EvanR> but it probably doesnt construct an entire list, at least not all at once
14:33:35 <monochrom> but do not rejoice if you set out to ignore types. even the operational semantics is non-trivial
14:33:53 <EvanR> fluvian: for example, the pack operation, which is strict for strict bytestrings, will consume a whole list of Word8, but that list may be producing lazily
14:33:53 <fluvian> interesting. doesn't ByteString.pack have to pull elements from the front of the list?
14:34:16 <josephle> monochrom: heck, *with* types the operational semantics is bad enough
14:35:17 <EvanR> fluvian: yeah so when you pack you will force whatever is producing that list to produce, and if the producer is lazy, you might avoid a memory issue
14:35:44 <yuung> i have a function that takes two arguments, and i'd like to use map with it.  should i just use map fn lst secondArg?
14:35:47 <EvanR> and the gc will soon collect to temporary list nodes
14:35:54 <EvanR> the
14:36:18 <dibblego> yukko: all haskell functions take one argument, always.
14:36:28 <EvanR> fluvian: also a lot of stuff in ByteString is subject to fusion, im not sure about zipWith though
14:36:38 <monochrom> most OOP programmers get by by two mental tricks: 1. denial; 2. using only an easy subset
14:36:39 <EvanR> yuung: zipWith ?
14:36:42 <fluvian> yeah I saw some references to fusion in the docs but I have no idea what is meant?
14:37:05 <Rotaerk> yuung, you can express "a function with two arguments" in multiple ways in haskell, so be more specific
14:37:15 <EvanR> fluvian: it completely avoids lists sometimes, so what i described wouldnt even happen. but for zipWith it might
14:37:29 <glguy> yuung: map (\x -> func x scndArg) xs
14:38:14 <glguy> or for the other way around: map (fun firstArg) xs
14:38:16 <yuung> Rotaerk, EvanR, i have a Widget ADT that has a price. i'd like to write a function that applies a percentage discount to each widget, so the mapping function would take in a widget and the percentage to mark it down by.  the percentage would be the same for each widget in the list
14:38:38 <akurilin> Hey guys: any esqueleto maintainers / contributors here?
14:38:39 <yuung> glguy, i'll try that right now, ty
14:38:40 <monochrom> map gcd [1, 2, 3] = [gcd 1, gcd 2, gcd 3]  is an example of using map on a 2-ary function (gcd here)
14:38:48 <akurilin> I'm trying to make a small change, could use some advice
14:38:53 <EvanR> yuung: if your function takes the percent first, then partially apply it like map (f .50) xs
14:38:59 <EvanR> er, 0.50
14:39:10 <fluvian> EvanR: it's not listed in the docs as one of the fusing functions, but I suppose that doesn't mean it isn't 
14:39:11 <Forgetaboutit> josephle: First-class classes sounds interesting. Could you elaborate what that means?
14:39:12 <yuung> EvanR ah okay, i knew it couldn't be too difficult
14:40:33 <EvanR> fluvian: id guess it isnt. but you shouldnt really worry about the performance of consuming a lazy list until it matters
14:42:11 <fluvian> EvanR: fair enough. I was mostly just curious if there was some package to do this stuff
14:42:13 <EvanR> fluvian: one way to squeeze performance for vector xor is make a special datatype with fixed length of word8s
14:42:25 <EvanR> then use vector operations
14:42:45 <fluvian> EvanR: I'll look into that. Thanks
14:42:53 <EvanR> like Word160 in the digest modules
14:43:10 <josephle> Forgetaboutit, in smalltalk you could use classes as a value that can be modified
14:43:21 <josephle> of course, that was because classes were objects in smalltalk
14:43:49 <Forgetaboutit> josephle: Ah, like in Ruby or JavaScript?  I don't know any Smalltalk unfortunately
14:44:15 <josephle> like Ruby, which is somewhat based on Smalltalk
14:45:08 <josephle> so the key idea is that maybe we could have a statically typed OOP language that placed classes at the same syntactic level as objects
14:45:09 <Maxdamantus> Maybe that's why it has insane syntax.
14:45:27 <Maxdamantus> (trying to mix Smalltalk with non-Smalltalk)
14:45:33 <Forgetaboutit> I see.  That must be hard to properly type ...
14:46:02 <EvanR> josephle: for the purposes of dynamically generating interfaces? or theorem proving with oop decorations?
14:46:16 <josephle> EvanR: dynamically generating interfaces
14:46:27 <EvanR> my favorite
14:46:35 <ggVGc> EvanR !!!!!!!
14:46:39 <ggVGc> long time
14:46:43 <josephle> you can also use scoping to prevent interfaces from leaking out to peole who shouldn't see them
14:46:48 <EvanR> oh shit its Walt
14:46:57 <walt> yep
14:47:10 <walt> EvanR: damn, I was thinking about where might be last year
14:47:22 <walt> where you might be*
14:47:30 <EvanR> according to irc stats, completely missing
14:47:42 <josephle> Forgetaboutit: it turns out it isn't *that* hard to type
14:47:53 <EvanR> theres #haskell-game where people use SDL a lot
14:48:15 <walt> EvanR: I wrote my first haskell program the other day. The preprocessor for this, https://github.com/ggVGc/TerseJS
14:48:16 <josephle> but it's very tricky to translate this "source" language into a lambda calculus (+ dependent types -_-)
14:48:18 <walt> its quite shitty
14:49:13 <walt> EvanR: so you still use SDL eh?
14:49:31 <EvanR> not really, mainly glfw
14:49:36 <walt> yep, same
14:49:56 <walt> glfw is pretty great. It's what we needed for a long time
14:50:00 <EvanR> tersejs, kind of like coffee script
14:50:29 <walt> EvanR: yeah, except a core thing is to keep the output very close to the input, and have it look as if manually written
14:50:59 <walt> also, being based on sweet.js macros, it's much easier to extend
14:51:11 <walt> I only worked on it for two days though, so it's not much yet
14:51:16 <walt> but works surprisingly well
14:53:47 <boxmein> I'm having trouble thinking in haskell
14:54:05 <boxmein> as an exercise I implemented a tape machine in haskell, but am having a hard time making it iterate
14:54:08 <walt> same
14:54:14 <newsham> anyone know of a haskell lib that can read RSA certs and keys from openssl-generated files?
14:54:25 <walt> boxmein: you should probably stop thinking in terms of iteration
14:54:30 <newsham> it seems the reader in Network.TLS.Extras doesnt like openssl's PEM files
14:54:37 <Cale> Well, iteration is just a particular kind of recursion
14:54:58 <boxmein> let me dump some code
14:55:08 <monochrom> I am writing a tutorial on recursion
14:55:23 <lpaste> boxmein pasted “here's a tape machine yo” at http://lpaste.net/6017485525156364288
14:55:24 <Cale> But you can also often use operations on lists to represent iteration nicely
14:55:28 <ion> monochrom’s tutorial on recursion: 1. see monochrom’s tutorial on recursion
14:55:35 <monochrom> haha
14:55:38 <newsham> ion: unfounded.
14:55:58 <boxmein> so basically, as you can see in main, I can't really tell what to do to make the tape machine run more than one iteration
14:56:32 <boxmein> I'm having trouble thinking of recursive code to do what I want lol
14:56:41 <newsham> monochrome's well founded tutorial on recursion: if you're on chapter zero, you're done. otherwise see the previous chapter of monochrome's well founded tutorial on recursion.
14:57:09 <boxmein> I first need to react on the Direction returned by tapeMachine to act on the Tape and move it, then create another tuple of State and Pivot to pass to tape machine again
14:57:53 <newsham> boxmein: does this make sense to you?   {x=1; loop: do stuff; goto loop with x=x+1 } ?
14:57:53 <boxmein> if y'all'd punch me with some ideas that would be great
14:58:05 <boxmein> newsham: sure
14:58:07 <Cale> boxmein: So, perhaps write a function move :: (State, Pivot, Direction) -> (State, Pivot)
14:58:09 <newsham> recursion at the end of a function is just like a "goto" that can also set values.
14:58:27 <boxmein> newsham: I totally grok recursion...not in this case however
14:58:30 <Cale> and then you'll have  move . tapeMachine :: (State, Pivot) -> (State, Pivot)
14:58:35 <newsham> boxmein: so...   foo' x = doo stuff; foo' (x+1);    foo 0. 
14:58:38 <newsham> is just like that
14:58:44 <newsham> ahh
14:58:51 <boxmein> Cale: I see :o 
14:58:53 <Cale> and then  iterate (move . tapeMachine) :: (State, Pivot) -> [(State, Pivot)]
14:59:07 <newsham> anyone know of good PEM/x509 parsers for hask?
14:59:07 <Cale> and it'll give you an infinite list of the future states of the machine
14:59:08 <boxmein> Cale: however, the Tape is not passed along with that tuple so move needs an extra argument
14:59:24 <Cale> boxmein: Well, make it part of the state
14:59:24 <boxmein> Cale: also, is iterate a function
14:59:25 <monochrom> I agree with Cale's scheme.
14:59:28 <monochrom> yes
14:59:33 <monochrom> @type iterate
14:59:34 <lambdabot> (a -> a) -> a -> [a]
14:59:42 <boxmein> this is so great
15:00:05 <monochrom> for example, iterate f 0 = [0, f 0, f(f 0), f(f(f 0)), etc]
15:00:22 <haasn> > iterate f 0
15:00:24 <lambdabot>      No instance for (Show a0)
15:00:24 <lambdabot>        arising from a use of ‘show_M26769756436718466994351’
15:00:24 <lambdabot>      The type variable ‘a0’ is ambiguous
15:00:31 <arkeet> > iterate f 0 :: [Expr]
15:00:32 <lambdabot>  [0,f 0,f (f 0),f (f (f 0)),f (f (f (f 0))),f (f (f (f (f 0)))),f (f (f (f (f...
15:00:58 <haasn> (wow, monochrom was telling the truth!)
15:01:12 <monochrom> I always tell the truth
15:01:15 <monochrom> (famous last words)
15:01:31 <ion> Good, no paradox in that sentence.
15:01:37 <haasn> famous last words of the guardian to the heaven shortly before it got stabbed?
15:01:44 <ion> (as opposed to “I always tell a lie”)
15:02:08 <monochrom> sometimes I tell a dilemma, but it's still honest
15:02:21 <shachaf> <monochrom> always trust monochrom after you have asked him to double-check and he has confirmed
15:02:22 <s00pcan> this is the only channel with any traffic for me … lol where is everyone?
15:02:42 <ion> here
15:03:00 <monochrom> for example, in a group meeting in which some people introduce themselves, I introduce the people who don't, and add "I introduce exactly those who don't introduce themselves"
15:03:06 <acowley> I'm having trouble understanding a cabal-install message
15:03:09 <acowley> rejecting: transformers-0.3.0.0/installed-645... (conflict:
15:03:09 <acowley> transformers-compat-0.4.0.4:three => transformers>=0.4.1 && <0.5)
15:03:24 <acowley> To me, that reads like it's using the "three" flag for transformers-compat
15:03:36 <acowley> But, if so, then those are the wrong bounds on transformers
15:03:45 <Cale> boxmein: Overall, you want some type A such that a value of type A tells you everything about the current state of the machine and its memory, and then you construct a function of type A -> A expressing how the system changes on one time step, and some initial value of type A, and you hand those to iterate and you get a list of A's
15:03:50 <s00pcan> so last night I figured out the point of ballpoint pens
15:03:51 <haasn> good thing monochrom doesn't need an introduction
15:03:57 <monochrom> in fact, I did that when Tony Hoare visited us (formal methods group at U of Toronto)
15:04:18 <s00pcan> they require extra pressure to write, which I initially thought as a hinderance, but it allows for sketching, like with a pencil
15:04:35 <s00pcan> also no drying time because no water
15:04:43 --- mode: ChanServ set +o monochrom
15:04:47 --- mode: monochrom set +b *!*@108-208-65-111.lightspeed.livnmi.sbcglobal.net
15:04:47 --- kick: s00pcan was kicked by monochrom (s00pcan)
15:05:01 <boxmein> I have arrived at a curry-powered enlightenment
15:05:11 <acowley> Does anyone know how to properly read that error message?
15:05:36 --- mode: monochrom set +b-b $a:s00pcan *!*@108-208-65-111.lightspeed.livnmi.sbcglobal.net
15:05:43 --- mode: monochrom set -o monochrom
15:05:56 <Cale> boxmein: It may also be helpful to look at how iterate is implemented:
15:06:01 <Cale> @src iterate
15:06:01 <lambdabot> iterate f x = x : iterate f (f x)
15:06:46 <Cale> > iterate (*2) 1
15:06:48 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
15:07:10 <boxmein> that looks deceivingly simple
15:07:32 <LambdaDusk> my brain won't work... I have a vector of an W by H image, and I need to convert it into 8x8 squares... the vector stores 1D, row after row, but I can access it with (x,y)... but I just can't think of the right map/generator lines to get it done... maybe someone here has an idea?
15:07:34 <Cale> It's about as simple as it looks, when you get right down to it :)
15:09:13 <Cale> The clever bit is how it interacts with lazy evaluation -- the x will be evaluated at most once, even though it occurs in two places on the right hand side, and the result of the evaluation will be shared between those occurrences.
15:11:13 <oneeman> This channel is the most fun of the 10 programming language channels I'm on :-)
15:11:54 <Cale> It can be important that you look at the elements of the resulting list in order, because this allows the expressions to be simple by the time you reach them. If you pick out the millionth element of the list, the resulting not-yet-evaluated expression will look like f (f (f ... (f x) ...))
15:12:16 <Cale> and if f pattern matches its argument, a bunch of pattern matches will build up on the stack, leading to a stack overflow
15:13:58 <Cale> You can avoid that in various ways, like applying a function such as  strictList [] = []; strictList (x:xs) = x : (x `seq` strictList xs)  to make sure that the elements get evaluated when anything tries to walk down the list.
15:15:30 <boxmein> hmmm
15:15:47 <boxmein> that has interesting properties nevertheless, like the ability to jump back and forth quite literally in time
15:16:15 <boxmein> I'll right now skip considering the pattern matches, however, since this is a simple thing with a simple purpose
15:16:19 <LambdaDusk> > map (\(w,h) -> [(x+w,y+h) | x <- [0..7], y <- [0..7]]) [(w,h) | w <- map (8*) [0..3], h <- map (8*) [0..3]]
15:16:20 <lambdabot>  [[(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(1,0),(1,1),(1,2),(1,3),(1...
15:16:26 <Cale> yeah, don't worry about that, it's mostly a performance thing
15:17:12 <Cale> I'm just warning about it in case you eventually do try to grab the millionth element of the resulting list without looking at the others first, and wonder why it dies. :)
15:18:30 <boxmein> for the topic being, how will building up all elements of the turing-machine state list help mitigate the stack overflow? 
15:18:40 <arkeet> :t \f -> iterate (f $!)
15:18:41 <lambdabot> (a -> a) -> a -> [a]
15:23:36 <Moggle> hey there, i'm trying to get mueval installed and working but at this point it's complaining "mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMsg = \"Top level:\\n    Module `Control.Monad.Error' is deprecated:\\n      Use Control.Monad.Except instead\"}]"
15:23:36 <Moggle> "
15:23:52 <Moggle> does anyone have any easy suggestions? the internet has not been very helpful
15:25:41 <arkeet> where is Control.Monad.Error coming from?
15:26:42 <Luke__> what are the tradeoffs between Cereal and Attoparsec for producing and consuming a binary protocol?
15:26:51 <Luke__> it looks like they can both do it
15:27:05 <int-e> mueval has a list of modules that it imports by default, see Mueval/Context.hs
15:27:33 <Moggle> int-e: so if I fix that on my end and recompile, you'd guess that would fix it?
15:27:40 <int-e> and the hint library helpfully turns warnings into errors in src/Hint/Base.hs
15:27:44 <EvanR> Luke__: they are for different things, Cereal (really Binary) is for producing readable binary, and attoparsec is for parsing 
15:27:44 <arkeet> Luke__: cereal is meant for serialization, not more general parsing.
15:28:02 <Luke__> gotcha - thanks guys
15:28:18 <arkeet> (and I guess binary is preferred over cereal anyways?)
15:28:25 <EvanR> i think so
15:28:45 <arkeet> any particular reason? I thought the main difference was just lazy vs strict bytestrings
15:28:49 <int-e> Moggle: yes that should do the trick. It should also be possible to use  mueval -n  and then add imports for the modules you need.
15:29:06 <Moggle> the -n flag overrides the basic imports?
15:29:08 <Moggle> sweet.
15:30:14 <Luke__> arkeet: but cereal doesn't allow you to lay out a protocol to a spec right?
15:30:19 <EvanR> they both do lazy, which is trivially convertable to strict
15:30:44 <c_wraith> whoops.  LiquidHaskell doesn't build against whatever version of Cabal comes with GHC 7.10
15:30:49 <Luke__> it looks like cereal is for saying out binary data according to some cereal spec whereas attoparsec allows you to parse a specific spec?
15:31:38 <c_wraith> Luke__: yes, cereal/binary are about efficient serialization to a format whose details aren't important.  something like attoparsec is for parsing a format where the details are important
15:31:48 <Luke__> gotcha - thanks c_wraith 
15:32:00 <Luke__> so cereal is like python's pickle
15:32:17 <c_wraith> yeah, though binary is the preferred package these days, from what I've seen
15:32:36 <EvanR> binary is haskells python pickle
15:32:46 <Luke__> yeah
15:32:52 <Luke__> what about cereal though?
15:32:57 <Luke__> same idea right?
15:32:59 <c_wraith> yes
15:33:02 <EvanR> its for the same thing
15:33:16 <Luke__> oh i see what you guys are saying: stop using cereal in favor of binary package again
15:33:19 <Luke__> sorry I missed that before
15:33:22 <Luke__> why is that?
15:33:23 <c_wraith> I think cereal had some new ideas about 5 years ago, then binary folded them in and sort of absorbed cereal's use cases
15:33:30 <Luke__> cool thanks
15:33:33 <Luke__> i didn't realize that
15:33:40 <Luke__> i've been using cereal all over basically since 3 years ago
15:34:00 <c_wraith> Nothing wrong with that, per se.  It does work, after all. :)
15:34:13 <ion> I hadn’t realized binary supports graceful failure these days.
15:34:28 <Luke__> yeah I just want to stay up to date
15:36:50 <boxmein> Cale: also, iterate did manage to fix everything. thanks for your assistance :D 
15:39:01 <Moggle> int-e: thanks again for your help, it is all working
15:39:22 <walt> boxmein: funny how the function solving your iteration problems was 'iterate'
15:39:53 <boxmein> walt: most of the time I come looking for help, prelude seems to have exactly the function needed
15:39:55 <boxmein> it's creepy, even
15:40:08 <EvanR> in which case hoogle might have helped
15:40:14 <boxmein> I suppose
15:40:29 <boxmein> however, my question was more on the thinky side, which hoogle doesn't solve lol
15:40:40 <EvanR> yet
15:40:55 <boxmein> I guess
15:41:44 <walt> wolfram alpha: "How do I search hoogle for help on iteration in haskell for my tape machine"
15:42:27 <EvanR> "I'm sorry I can't let you do that"
15:42:33 <boxmein> walt: I bet typing that into askjeeves would help
15:42:45 <boxmein> when we're already doing multiple search engines lol
15:45:53 <dorefoo> hi
15:46:14 <dorefoo> this is not strictly related to haskell, but probably close enough to the day joy of some of you
15:46:31 <dorefoo> I'm currently working on a paper where I'd like to put some fancy unicode in latex
15:46:44 <dorefoo> like a nice arrow instead of '->'
15:46:53 <oneeman> lol, day joy... if only!
15:47:01 <dorefoo> but when I compile the latex file, I end up staring at a blank space
15:47:03 <dorefoo> how does this work?
15:47:22 <dorefoo> I looked up using \usepackage{listingsutf8}
15:47:35 <dorefoo> but that didn't lead to the desired output either
15:48:48 <bananagram> does regex-tdfa have support for replacing matches with text, like the second argument in s/x/y/?
15:51:03 <monochrom> dorefoo: there needs some \usepackage[utf8]{inputenc} or some such. without it, latex simply doesn't honour utf8
15:51:21 <dorefoo> monochrom: I'm using that one already
15:51:24 <dorefoo> it still doesn't work
15:51:24 <monochrom> and I am sure I have used a wrong spelling
15:51:32 <dorefoo> (in code listings, that is)
15:51:35 <monochrom> alright, then I don't know more
15:51:52 --- mode: ChanServ set +o monochrom
15:52:10 --- mode: monochrom set -b $a:s00pcan
15:52:11 <Njanta> please http://yhqz.oblogs.ru/180245460/2566850/ <3
15:52:21 --- mode: monochrom set -o monochrom
15:52:27 <oneeman> dorefoo: if all you want is a nice arrow, you can check out the math libraries, like amstex or whatever it's called
15:52:42 <dorefoo> oneeman: that isn't rendered in code listings
15:52:46 <monochrom> you can fall back to $\rightarrow$ :)
15:53:08 <monochrom> ok, if $\rightarrow$ is unsuitable, then I still don't know
15:53:08 <dorefoo> yes, that is exatly what is printed -- instead of an actual nice arrow
15:53:26 <monochrom> I don't understand latex
15:53:49 <slack1256> \mapsto ? 
15:53:50 <dorefoo> I'd need Latex to convert that command to an arrow, but math mode can't be used in a code listing, it seems
15:53:57 <monochrom> on the top 10 list of things that everyone uses but no one understands, latex is just second to c++
15:54:07 <oneeman> dorefoo: you want a unicode arrow in a code listing? 
15:54:16 <dorefoo> any kind of arrow will do
15:54:29 <dorefoo> just not "->"
15:54:55 <walt> monochrom: true words. MY whole CV and most things I wrote for uni were latex, and I still barely get it
15:55:14 <walt> I also generate my invoices with latex, and again, don't really understand how it works
15:55:18 <Saizan> dorefoo: is this haskell code? if so try lhs2tex
15:55:22 <walt> but I managed to make it do what I want anyway
15:56:53 <oneeman> dorefoo: have you seen http://tex.stackexchange.com/questions/24528/having-problems-with-listings-and-utf-8-can-it-be-fixed ?
16:02:13 <monochrom> oohhh, so listingsutf8 only goes up to U+00FF
16:08:48 <pavonia> Amusingly, almost the same question has just been discussed in #latex :)
16:10:22 <absence> why would a function run twice as fast by moving it from the top level to a where clause?
16:12:34 <pavonia> Something related to defaulting/the monomorphism restriction, I guess
16:13:12 <absence> pavonia: would it be possible to make it run as fast at top level?
16:13:35 <pavonia> I don't know, sorry
16:14:01 <shachaf> I expect that it's neither defaulting nor the MR.
16:14:12 <shachaf> It could be inlining or something else. Not a lot of information to go on.
16:14:27 <slack1256> Also, how did you measure it? criterion?
16:15:23 <absence> slack1256: just +RTS -s. the program takes 8 vs 16 seconds to run, so it's good enough :)
16:15:54 <absence> shachaf: i added {-# INLINE funcname #-} and now it's fast :O
16:16:00 <slack1256> yeah, is good enough.
16:16:26 <absence> i had no idea that was necessary inside the same module
16:16:57 <shachaf> The GHC inliner has many secrets.
16:17:29 <absence> apparently. and it has to be INLINE, INLINABLE doesn't do the trick
16:18:13 <pavonia> Are local definitions automatically inlined?
16:18:53 <absence> it seems so from this particular experience
16:19:50 * hackagebot yaml-light-lens 0.3.1.8 - Lens interface to yaml-light.  http://hackage.haskell.org/package/yaml-light-lens-0.3.1.8 (AnthonyCowley)
16:19:57 <shachaf> Definitions that aren't exported and are only used once are generally inlined.
16:20:03 <shachaf> (And aren't recursive and so on.)
16:22:41 <absence> shachaf: ah, so if my toplevel function was only used once, it might have been inlined?
16:26:15 <boxmein> oh, Cale if you're interested this is the end result: https://gist.github.com/boxmein/ad786f2b044ad9d4468d
16:37:26 <Husel> Hey, I'm new to Haskell, just wondering if I could get a little help with this function? http://lpaste.net/130104 I'm not sure what syntax I should be using for these if statements.
16:39:04 <hpc> you need else before each subsequent if
16:39:16 <hpc> however, i expect you really want guards
16:39:28 <boxmein> Husel: remember that if-then-else is an expression, it's expected that it ends up as a value
16:39:29 <Husel> I want it possible for all of them to run if necessary
16:39:33 <hpc> oh wait, no you don't
16:39:35 <hpc> you want when
16:39:37 <hpc> :t when
16:39:38 <lambdabot> Applicative f => Bool -> f () -> f ()
16:39:46 <hpc> when (isJust $ north room) $ do
16:39:48 <hpc>   whatever
16:39:54 <hpc> when (isJust $ north room) $ do
16:40:01 <hpc> er, east
16:40:07 <hpc> @src when
16:40:07 <lambdabot> when p s = if p then s else return ()
16:40:51 <hpc> yeah, if-then-else is a value, and works for things that don't have "do nothing"-y values
16:40:56 <hpc> (such as return ())
16:40:59 <Husel> I'll give it a go, thanks :)
16:40:59 <lpaste> MP2E revised “Show exits”: “Show exits: guard edition” at http://lpaste.net/130104
16:41:25 <MP2E> could probably be improved further, also I didn't check if it compiles :p
16:47:16 <Husel> MP2E: Thanks, but this only prints 1 of them, even if the room has exits both north and south for example.
16:47:36 <Husel> hpc: I'm getting an error that "when" is not in scope
16:47:58 <hpc> @hoogle when
16:47:59 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
16:48:00 <lambdabot> Test.QuickCheck.Property whenFail :: Testable prop => IO () -> prop -> Property
16:48:00 <lambdabot> Test.QuickCheck whenFail :: Testable prop => IO () -> prop -> Property
16:48:04 <hpc> import Control.Monad
16:48:05 <jmcarthur> Husel: when lives in Control.Monad. i never remember what's in Prelude...
16:48:12 <hpc> or Control.Applicative now, maybe?
16:48:36 <MP2E> Husel: ah, didn't consider multiple exits
16:48:45 <MP2E> when is better suited then, yeah
16:49:13 <Husel> hpc, jmcarthur: It works great now
16:49:16 <Husel> Thanks everyone :)
16:49:17 <jmcarthur> Husel: here is a not-so-beginner-friendly version more reflective of what i might do in this situation, more FYI than an actual suggestion since i think you shouldn't just jump into point free style like this: http://lpaste.net/130104
16:50:35 <Husel> jmcarthur: I was reading a bit about point free style in the Yet Another Haskell Tutorial wikibook a little earlier, so I'll take a look, but I probably won't be writing such cool haskell for some time :P
16:50:52 <jmcarthur> Husel: and that's fine! :)
16:51:18 <jmcarthur> Husel: haskell should be about being easy to reason about first and foremost, not about looking cool
16:51:34 <arkeet> when (isJust x) a = mapM_ (const a) x
16:51:36 <neitsab> hi everybody, just a quick question from an end user of a few Haskell programs (gitit, pandoc): is it normal that my Haskell setup takes so much disk space?
16:52:15 <mpickering> neitsab: pandoc is on the larger side
16:52:19 <mpickering> how much are you talking?
16:52:31 <neitsab> The /usr/lib/ghc (7.8.4) directory is currently 1.2 GB and tops by far all other dirs on my system
16:52:48 <pavonia> :t \x a -> mapM_ (const a) x
16:52:49 <lambdabot> (Monad m, Foldable t) => t b1 -> m b -> m ()
16:53:24 <neitsab> The /site-local subdir is 609 MiB and /ghc-7.8.4 is 286
16:53:26 <jmcarthur> neitsab: ghc does a lot of cross module inlining, so stores a surprising amount of information that many compilers wouldn't.
16:53:48 <jmcarthur> neitsab: if you only need the binaries in the end you could always remove the compiler and libraries afterward
16:54:38 <neitsab> mpickering jmcarthur thanks for the info, I just wanted to confirm this wasn't unexpected
16:55:11 <jmcarthur> neitsab: i do think there could be a lot saved if somebody spent the effort tweaking ghc, but yes, for now ghc does tend to take a lot of space
16:55:24 <jmcarthur> neitsab: and i think it gets even worse with 7.10.1 :(
16:56:50 <platz> so by default syslibs will be dynamic, with -dynamic hs deps are dynamic, and with -static there are no (hs or sys) libs dynamic?
16:58:05 <neitsab> jmcarthur: all right now I'm warned :) Checking the disk usage space on my server I was surprised seeing those figures, but as Haskell was a kind of difficult platform to get running on my system (Arch) I thought it could be the result of y wrong doing
16:59:52 * hackagebot DocTest 0.2.0.1 - Test interactive Haskell examples  http://hackage.haskell.org/package/DocTest-0.2.0.1 (SimonHengel)
17:01:07 <jle`> sequence_ (a <$ x)
17:01:22 <jle`> maybe not
17:02:45 <Zemyla> Hmm, would the RWS monad be faster if it were put into CPS form?
17:04:52 * hackagebot errorcall-eq-instance 0.2.0.1 - An orphan Eq instance for ErrorCall  http://hackage.haskell.org/package/errorcall-eq-instance-0.2.0.1 (SimonHengel)
17:09:52 * hackagebot test-shouldbe 0.2.1.1 - Catchy combinators for HUnit  http://hackage.haskell.org/package/test-shouldbe-0.2.1.1 (SimonHengel)
17:16:34 <Zemyla> Like, forall k. (a -> w -> s -> k) -> r -> s -> k.
17:17:01 <shachaf> A monad doesn't have a speed.
17:17:18 <Zemyla> I mean would it generally give better performance.
17:17:18 <shachaf> Are lists faster if they're put into CPS form?
17:17:45 <Zemyla> A few sources I've seen show they are.
17:18:16 <Zemyla> For instance, Oleg's LogicT vs regular lists.
17:19:01 <shachaf> The answer is that lists don't have a speed either.
17:19:13 <shachaf> Some operations are faster and some operations are slower.
17:19:52 <Zemyla> Well, the main operations we're worried about are return and >>=, yes?
17:19:53 * hackagebot hspec-shouldbe 0.0.1 - Convenience wrapper and utilities for hspec  http://hackage.haskell.org/package/hspec-shouldbe-0.0.1 (SimonHengel)
17:20:18 <alynn> depends on the application
17:20:32 <shachaf> In the case of lists, what are the main operations you're worried about?
17:20:34 <alynn> for lists, ++ is often quite important too
17:20:43 <Zemyla> I mean for a state or RWS monad.
17:20:53 <shachaf> If your monad has no operations but return and (>>=), it's pretty useless.
17:21:10 <Zemyla> (Also, ++ is O(1) for lists in CPS form.)
17:21:46 <shachaf> Yes. So if all you do with your lists is (++) them, CPS lists are great.
17:22:40 <Zemyla> If List a = List (forall r. (a -> r -> r) -> r -> r), then (List a) ++ (List b) = List $ \c n -> a c (b c n).
17:23:09 <shachaf> Yes.
17:23:45 <Zemyla> But yeah, I guess it's something I'd have to benchmark.
17:24:08 <shachaf> Benchmarking is good.
17:24:09 <shachaf> Thinking about what you're doing with your type is also good.
17:24:23 <shachaf> What is usually not useful is saying "type A is faster than type B".
17:24:37 <shachaf> Is IntSet faster than Set Int? (No.)
17:25:04 <arkeet> didn't someone do a benchmark like that?
17:25:19 <shachaf> Like what?
17:25:25 <arkeet> comparing various versions of RWST.
17:25:29 <arkeet> or maybe it was some other monad
17:27:36 <alynn> I recall some heavy strict vs non-strict vs church encoded vs "emulated-via-State" for Writer
17:27:41 <alynn> in a blog somewhere
17:28:03 <arkeet> yeah something like that
17:30:24 <arkeet> I think this is what it was. http://fumieval.hatenablog.com/entry/2013/03/09/180504
17:32:04 <arkeet> I guess this is not the same thing you were thinking of.
17:33:29 <Zemyla> Well, I can think of one reason not to do CPS-style encoding on the State monad.
17:33:50 <Zemyla> It'd violate the separation of Church and State.
17:34:12 <arkeet> that is the pun I have heard in a while.
17:34:16 <arkeet> the worst pun*
17:34:34 <josephle> I wonder who coined it first
17:35:19 <josephle> it's certainly not a new pun concerning functional programs :)
17:35:27 <arkeet> it's new to me!
17:35:36 <shachaf> i,i the worst pun i've heard since the last time i heard that pun
17:35:38 <Zemyla> But yeah, it feels like CPS for the State and Writer monads would make them faster, because you aren't continually constructing and deconstructing pairs.
17:36:13 <arkeet> even cps'd reader looks faster, although only barely
17:36:29 <Zemyla> I mean, with Writer, you'd have the cost of adjoining the functions, but for State you already have to do that.
17:38:38 <arkeet> wonder why mtl-c isn't on hackage.
17:38:47 <arkeet> https://github.com/fumieval/mtl-c
17:39:43 <arkeet> well, at least we have http://hackage.haskell.org/package/contstuff
17:39:54 <arkeet> but it's old
17:40:57 <arkeet> the types are a bit different though.
17:42:34 <Zemyla> Also, is the CPSed State monad strict or lazy in its semantics, or is it completely different?
17:43:40 <arkeet> I see uses of seq in mtl-c
17:43:42 <arkeet> so I assume strict
17:43:46 <arkeet> in the state
17:44:54 * hackagebot yaml-light-lens 0.3.1.9 - Lens interface to yaml-light.  http://hackage.haskell.org/package/yaml-light-lens-0.3.1.9 (AnthonyCowley)
17:46:56 <Luke> what's the favorite command line arg parser these days?
17:47:49 <fryguybob> Luke: I use optparse-applicative
17:47:59 <Luke> that's the top one that came up on google search too
17:48:08 <Luke> there's just so many!
17:56:33 <Zemyla> Hmm. If regular monads could be sped up this way, could the ST and IO monads similarly be sped up?
17:57:03 <hpc> no
17:57:17 <hpc> or at least, probably not
17:57:47 <Zemyla> Well, all the primops are designed around it being pairs.
17:59:06 <arkeet> ST and IO don't really pass around a real state anyway.
17:59:25 <Zemyla> No, but if even Reader is sped up...
18:00:08 <arkeet> I dunno.
18:00:16 <arkeet> I don't think there'd be much to do, because ST/IO don't really have any operations.
18:00:28 <hpc> see if Identity is sped up
18:01:07 <Zemyla> Also, interesting thought, this means that ST and IO could potentially be monad transformers more easily.
18:01:53 <hpc> IO can never be a transformer, runIOT can't be written
18:02:19 <hpc> it'd involve unsafePerformIO
18:02:23 <hpc> which obeys no laws
18:02:25 <Zemyla> It can in CPS land.
18:04:59 <Zemyla> If IO a is IO (forall r. (a -> State# RealWorld -> m r) -> State# RealWorld -> m r, then runIOT would basically just be io (const . return) realWorld#.
18:05:12 <Zemyla> :t runIO
18:05:12 <lambdabot> Not in scope: ‘runIO’
18:05:59 <alynn> don't take IO's implementation in GHC too seriously
18:06:18 <alynn> the abstraction doesn't withstand StateT RealWorld shenanigans
18:07:31 <Zemyla> Why not? The state never even touches the transformed mobad.
18:08:46 <arkeet> well, what would IOT even be?
18:08:50 <arkeet> like
18:08:56 <arkeet> what's the type of runIOT or whatever?
18:09:27 <Zemyla> Well, what is the state of runIO?
18:10:17 <Zemyla> *type
18:12:55 <Zemyla> Wait, it would have to somehow convert a value of type IOT a to IO a.
18:13:44 <jmcarthur> runio would be a great name for a haskell compiler
18:14:11 <jmcarthur> or i guess a haskell interpreter
18:14:21 <Zemyla> I suppose it would work possibly for an ST transformer.
18:14:49 <jmcarthur> Zemyla: how does  STT [] a  behave?
18:14:58 <jle`> IOT m a would presumably be equivalent to IO (m a), so runIOT :: IO (m a) -> m (IO a)
18:15:22 <jle`> wait did i do that backwards
18:16:09 <jle`> yeah i got that backwards
18:18:25 <Zemyla> jmcarthur: Probably like multiple threads with shared memory, something like.
18:18:58 <jmcarthur> Zemyla: so it would be nondeterministic?
18:19:06 <nshepperd> Zemyla: 'io (const . return) realWorld#' is just a different unsafePerformIO
18:19:16 <Zemyla> Hm.
18:21:15 <bobsdad> I have a very newbie question to ask.
18:21:38 <bobsdad> I'm trying to make a function that returns True if it's a leap year, and false if not.
18:21:44 <bobsdad> Here's what I Have:
18:21:46 <bobsdad> http://pastebin.com/giyc2y2x
18:21:59 <bobsdad> isLeapYear :: Int -> Bool
18:21:59 <bobsdad> isLeapYear year
18:21:59 <bobsdad>         | divisbleBy 400                         = True
18:22:01 <bobsdad>         | divisbleBy 4 && (not $ divisbleBy 100) = True
18:22:03 <bobsdad>         | otherwise                              = False
18:22:05 <bobsdad>         where divisbleBy x = year `rem` x == 0
18:22:16 <bobsdad> The question asks that:
18:22:22 <bobsdad> on every year that is evenly divisible by 4
18:22:22 <bobsdad>   except every year that is evenly divisible by 100
18:22:22 <bobsdad>     unless the year is also evenly divisible by 400
18:22:46 <bobsdad> And I know I've achieved this, but is there anything in Haskell (like maybe an unless or except function) that will allow me to be more semantic?
18:22:54 <shachaf> bobsdad: Please don't paste more than a couple of lines into IRC.
18:23:00 <bobsdad> Because as it stands, my solution isn't really close to the way the question is phrased.
18:23:02 <bobsdad> Oh I'm sorry
18:23:46 <shachaf> I don't think the answer to your question is too Haskell-related.
18:24:06 <shachaf> I mean that you're not missing any language features here.
18:24:27 <nshepperd> apparently the FreeT type exists, so you could define a 'type IOT m a = FreeT FFI m a'. no idea what that would actually do though
18:24:38 <jxv> bobsdad, you need need to use guard syntax
18:24:42 <jxv> don't need to use*
18:24:56 * hackagebot al 0.1.2 - OpenAL 1.1 raw API.  http://hackage.haskell.org/package/al-0.1.2 (DimitriSabadie)
18:24:57 <jxv> it can be a oneliner
18:25:15 <bobsdad> @jxv, can you explain further?
18:25:15 <lambdabot> Unknown command, try @list
18:25:20 <bobsdad> jxv, can you explain further?
18:26:27 <nshepperd> hmm, oh, maybe you'd need a special interpreter for each base 'm'. 'unsafePerformIOMaybe :: IOT Maybe a -> Maybe a' etc etc
18:27:07 <shachaf> divisibleBy 4 && (not (divisibleBy 100) || divisibleBy 400) -- for instance
18:27:39 <jxv> ^
18:28:42 <johnw> nshepperd: FreeT FFI m a would mean: While building up an FFI tree, you can interleave effects in 'm', like using State to refer to past decisions, etc.
18:28:42 <arkeet> shachaf: are those missing arguments, or are you using some generalized && and ||
18:28:51 <shachaf> arkeet: I'm following the paste above.
18:29:00 <arkeet> oh there's the argument.
18:29:05 <arkeet> I should read.
18:29:07 <bobsdad> shachaf: oh brilliant, thanks!
18:29:36 <arkeet> curiously you could drop the outermost parenthese and it would still work.
18:30:12 <shachaf> Yes.
18:30:48 <Zemyla> Hmm. I think I'll try writing this STT and see how it performs with lists.
18:31:13 * arkeet would be more curious about how it works at all
19:08:07 <int-e> Why is Data.Coerce (which provides safe coercions) marked unsafe?
19:10:17 <int-e> Is it just a matter of time, until libraries have the required type role annotations?
19:12:23 <arkeet> int-e: like what is suggested in https://ghc.haskell.org/trac/ghc/wiki/Roles#Changingdefaultroletonominal ?
19:13:44 <awesomehaircut> hi there
19:14:17 <awesomehaircut> For any one that has read "Learn you a haskell good" what would you recommend as a next step?
19:14:25 <arkeet> @where learnhaskell
19:14:25 <lambdabot> https://github.com/bitemyapp/learnhaskell
19:14:30 <arkeet> have a look here :)
19:14:42 <ackthet> awesomehaircut: the upenn class on here is good
19:14:49 <ackthet> its referenced in that url above
19:14:58 * hackagebot cuda 0.6.6.1 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.6.6.1 (TrevorMcDonell)
19:15:34 <awesomehaircut> cool :D I'm still half way through the book but i'm honestly in love withhaskell
19:15:51 <arkeet> the upenn class there actually has exercises :)
19:16:10 <awesomehaircut> I've been using the little i know to do the euler problems ^ ^
19:16:33 <arkeet> cis194
19:20:15 <echo-area> Why is >>= for `(->) r` defined as `f >>= k = \ r -> k (f r) r` instead of `f >>= k = k . f`?
19:20:50 <arkeet> because that woudl have the wrong type.
19:21:01 <shachaf> And the wrong value.
19:21:24 <arkeet> k . f = \r -> k (f r)
19:21:36 <arkeet> see there's an extra r in the definition of >>=
19:21:49 <echo-area> Is its type `(a -> b) -> (b -> a -> c) -> a -> c`?
19:22:14 <arkeet> for (->) a, sure.
19:22:43 <arkeet> that looks pretty different from (.)
19:23:12 <shachaf> arkeet: Not in Kleisli (->).
19:23:17 <shachaf> Er
19:23:25 <shachaf> That made no sense, never mind.
19:23:53 <shachaf> Too many types.
19:24:00 <arkeet> too many ->s
19:26:09 <ReinH> johnw: ping
19:26:34 <johnw> pong
20:13:12 <echo-area> arkeet: Thanks.  I thought the arg can be omitted, but it can't, so that's the only possible definition
20:13:45 <echo-area> (I tried k $ f r but realized that r needed to be provided)
20:24:07 <tommd> newsham: Ping
20:30:40 <Luke> http://hackage.haskell.org/package/cryptohash-0.11.6/docs/Crypto-Hash.html with a (Digest a) and no data constructor, how can I make a function that maps a number to each Digest a type?
20:31:44 <shachaf> I can't parse that.
20:33:22 <Luke> shachaf: you want me to explain it differently?
20:34:10 <shachaf> I don't understand "how can I make a function that maps a number to each Digest a type".
20:34:40 <Luke> you understand a function that maps a type to a number right?
20:34:49 <nshepperd> each 'Digest a' type
20:34:57 <Luke> nshepperd: right
20:34:59 <shachaf> nshepperd: Oh, I see.
20:35:23 <shachaf> Now I can parse it but I don't understand it. Do you have an example?
20:36:06 <Luke> i want to make a function "code :: (HashAlgorithm a) => Digest a -> Int"
20:36:15 <Luke> but a is a phantom type
20:36:45 <Luke> I'm just not sure how to assign a number to each HashAlgorithm
20:37:07 <shachaf> What does this function do?
20:37:25 <Luke> it assigns a number to each HashAlgorithm
20:37:39 <Luke> SHA1 -> 1
20:37:42 <nshepperd> why would you want to do that
20:37:42 <Luke> for example
20:37:45 <shachaf> Maybe your example is that code :: Digest MD5 -> Int; code _ = 1, and code :: Digest SHA1 -> Int; code _ = 2
20:38:03 <shachaf> That's an example of an example.
20:38:23 <Luke> yeah that's it
20:38:30 <glguy> Of a hash hash
20:38:51 <Luke> shachaf: thanks
20:38:55 <shachaf> OK. I think nshepperd's question was good.
20:39:12 <shachaf> But you can implement this with class DigestNumber a where code :: digest a -> Int
20:41:03 <arkeet> too bad those types aren't Typeable.
20:41:20 <shachaf> Everything is Typeable.
20:41:24 <arkeet> not yet.
20:41:39 <arkeet> I don't think that made it into 7.10?
20:41:44 <shachaf> It made it into 7.10.
20:41:49 <arkeet> ah.
20:42:04 <Luke> arkeet: how would I use that?
20:42:27 <arkeet> I don't see it in the release notes though.
20:42:35 <johnw> it was mentioned by austin in his e-mail
20:42:37 <shachaf> typeRep :: Digest MD5 -> TypeRep gives you one TypeRep, typeRep :: Digest SHA1 -> TypeRep gives you another TypeRep
20:42:41 <johnw> I was rather excited about that
20:43:12 <shachaf> Of course, the new Typeable is still unsafe.
20:43:17 <shachaf> They really hurried this out.
20:43:25 <johnw> that's what .1 is for
20:43:28 <johnw> it's the new beta
20:43:51 <arkeet> this bug? https://ghc.haskell.org/trac/ghc/ticket/9858
20:44:31 <shachaf> Yes.
20:44:49 <Luke> seems cryptohash would have been simpler just to use a sum type for the algos
20:44:54 <shachaf> I wish all this discussion was taking place in bug 10000.
20:44:55 <arkeet> why?
20:45:03 <arkeet> Luke: why?
20:45:19 <Luke> less abstract
20:45:24 <Luke> less ad hoc classes
20:45:24 <arkeet> less type safe
20:45:40 <carter> shachaf: i thought it was fixed asdie from the possible hash collsion
20:45:43 <Luke> questionable
20:45:58 <arkeet> why would you want a SHA1 digest and a MD5 digest to have the same type?
20:46:00 <carter> ohhh
20:46:18 <Luke> arkeet: because they are the same type: bytestring
20:46:26 <arkeet> that's not an answer
20:46:43 <arkeet> everything is a bytestring
20:47:27 <shachaf> Is BOX a ByteString?
20:47:35 <arkeet> I said lowercase bytestring.
20:47:57 <shachaf> That's true.
20:48:37 <Luke> arkeet: with your argument we should have each number be it's own type. One. Two...
20:48:42 <arkeet> that's not true.
20:48:47 <Luke> in this case we are using the wrong language =)
20:49:09 <arkeet> you can't meaningfully compare a MD5 with SHA1 in the way you can compare 1 and 2.
20:49:40 <Luke> true
20:50:03 * hackagebot cuda 0.6.6.2 - FFI binding to the CUDA interface for programming NVIDIA GPUs  http://hackage.haskell.org/package/cuda-0.6.6.2 (TrevorMcDonell)
20:50:49 <Luke> well you sort of can: ByteString comparison =)
20:51:15 <Luke> they were generated with different algorithms but they are still both values
20:51:30 <arkeet> okay, let's all just use PHP then.
20:51:38 <kadoban> Luke: Sure, but extending that logic to every type would completely defeat the entire purpose of a type system.
20:54:11 <Luke> my point is it may have been better to have a type "data Digest = Digest ByteString Algo" where algo is a sum type
20:54:29 <Luke> you still retain type safety and not can compare the algo it was generated with
20:55:03 * hackagebot taffybar 0.4.5 - A desktop bar similar to xmobar, but with more GUI  http://hackage.haskell.org/package/taffybar-0.4.5 (TristanRavitch)
20:56:08 <dolio> You don't retain type safety, though. At least not the same type safety.
20:56:30 <Luke> why not?
20:56:40 <Luke> well yes that's true. it's different
20:56:47 <Luke> but now we can express more things more easily
20:56:54 <dolio> Because now you cannot specify in the types that you only accept SHA digests and so on.
20:56:59 <shachaf> But are they things that we want to express?
20:57:42 <Luke> shachaf: serializing digests along with their hash algo for example
20:57:45 <Luke> may be useful
20:57:54 <arkeet> you can do that.
20:57:57 <arkeet> make your own sum type.
20:58:54 <Luke> that's a lot of boilerplate
20:59:53 <Luke> this in fact was my original point "Luke:	seems cryptohash would have been simpler just to use a sum type for the algos"
21:00:11 <shachaf> Serializing digests is not a typical use case.
21:00:19 <Luke> that's probably true
21:00:23 <Luke> its just an example
21:00:35 <shachaf> If you want to give up type safety to allow for this feature, that's fine and probably reasonable.
21:02:07 <Luke> i think actually its very common to serialize hashes. usually they're persisted and compared later.
21:02:19 <Luke> this is what Shake does for example 
21:06:27 <Luke> arkeet: what do you use cryptohash for?
21:06:31 <arkeet> I don't.
21:06:56 <Luke> what use case do you have in mind then?
21:07:33 <arkeet> any case where one would not want to misinterpret a hash produced by one algorithm as one produced by a different one.
21:08:27 <Luke> but really you're saying this way of representing the types is better than a product type with a sum type of algos?
21:09:04 <arkeet> with a sum type, you don't know the digest algo at the type level.
21:09:30 <Luke> arkeet: polio's point then
21:09:32 <arkeet> generally you want to make the type system work for you as much as possible.
21:09:37 <Luke> dolio*
21:10:27 <dolio> If Haskell had sigma types none of this would be an issue.
21:11:08 <Luke> shachaf: anyway thanks for your help. i know what I need to do
21:11:15 <Luke> its a pain ;-)
21:11:23 <dolio> You'd have Digest : Algo -> * and Σ Algo Digest is easy to serialize.
21:11:56 <Luke> dolio: right I can imagine cases where this would be easier
21:12:12 <dolio> Check back in a few years. :)
21:12:12 <Luke> the type system could be working for me ;-P
21:12:26 <arkeet> check now in a dependently typed language.
21:12:54 <dolio> You'd have to find one that you actually want to use for real things.
21:13:08 <dolio> And has all the relevant libraries you want to use written.
21:13:14 <carter> dolio: dont  gadts make it easy to write basic sigmas?
21:13:14 <arkeet> yes, that is a slight issue.
21:13:29 <Luke> arkeet: that's a major issue
21:13:34 <Luke> ;-P
21:13:50 <Luke> if i'm to take you as literally as you take me
21:13:55 <dolio> Depends on what you think is "easy".
21:14:37 <Luke> no dependently typed language is where I need it wrt libraries etc at the very least unfortunately
21:14:54 <dolio> Presumably the library doesn't have the right stuff defined, so it'd be just as much user-boilerplate as defining your own sum type.
21:15:05 <Luke> right =D
21:15:25 <Luke> the type safety vs. utility tradeoff arises again
21:15:39 <glguy> (some of this is probably covered above, I haven't read everything) Digest isn't a sum type because the set of digests is not closed
21:15:50 <dolio> And it's probably not defined because all the duplication required between terms and types is annoying.
21:15:59 <glguy> As far as serializing you'd need to pick a set of digests that you support serializing and select an encoding
21:16:11 <Luke> glguy: yeah that was covered
21:16:21 <glguy> OK, back to programming :)
21:16:24 <Luke> haha
21:19:30 <carter> dolio: how would the gadt verison of of that sigma digest thing fall short?
21:20:17 <dolio> Non-existence.
21:27:10 <carter> oh
21:27:20 <carter> the sigma would allow an open universe?
21:27:33 <dolio> No.
21:27:37 <carter> whereas i'd have to just choose a fixed universe in gadt land?
21:27:52 <carter> "Digest : Algo -> * and Σ Algo Digest "
21:27:57 <carter> that specifically
21:28:08 <dolio> With dependent types, Σ of course exists.
21:28:15 <dolio> And Algo probably exists.
21:28:30 <dolio> Although not with an open universe.
21:28:52 <dolio> Anyhow, since those things exist, you can use them without defining anything yourself.
21:29:06 <dolio> The GADTs are not defined, you have to make them yourself.
21:29:15 <dolio> And you also have to define a one-off sigma type, probably.
21:29:33 <carter> ahh
21:30:46 <carter> i'll need some help understanding that more hwne i've caught up on sleep
21:30:47 <carter> ngiht
21:39:24 <Javran> nubBy (\x y -> x `mod` y == 0) [2..]
21:39:29 <Javran> > nubBy (\x y -> x `mod` y == 0) [2..]
21:39:30 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
21:39:52 <Javran> strange, my ghci doesn't agree with this result
21:40:05 * hackagebot gtksourceview3 0.13.1.3 - Binding to the GtkSourceView library.  http://hackage.haskell.org/package/gtksourceview3-0.13.1.3 (HamishMackenzie)
21:40:07 * hackagebot auto 0.4.0.0 - Denotative, locally stateful programming DSL & platform  http://hackage.haskell.org/package/auto-0.4.0.0 (jle)
21:40:09 * hackagebot gtksourceview2 0.13.1.3 - Binding to the GtkSourceView library.  http://hackage.haskell.org/package/gtksourceview2-0.13.1.3 (HamishMackenzie)
21:40:11 <c_wraith> nubBy's implementation changed in GHC 7.10
21:40:55 <c_wraith> It still works the same with equivalence relations
21:41:03 <c_wraith> Which is all it was ever documented to work correctly with
21:41:14 <c_wraith> but x `mod` y == 0 is not an equivalence relation
21:41:27 <Javran> hmm, I see
21:42:01 <jle`> so...hopefully nobody was relying on undefined behavior :)
21:42:22 <jle`> if so then i guess their code will break silently in 7.10
21:43:42 <c_wraith> I prefer the new implementation-specific behavior!
21:44:39 <c_wraith> But I think depending on it is just as wrong as depending on the previous behavior
21:50:05 * hackagebot webkitgtk3 0.13.1.2 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkitgtk3-0.13.1.2 (HamishMackenzie)
21:54:35 <ttt_fff> are there haskel bindings for surface pro 3 anywhere? I want to build a app for drawing stuff with the surface pro 3 pen; one option was ghcjs  html5+ canvas ... but all canvas demos I tried had this extra "lag" when processing pointer events (very noticabvle compared to one note) -=- querstion: dis there some haskell package that binds directly to surface pro 3's pen?
21:55:06 * hackagebot webkit 0.13.1.2 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkit-0.13.1.2 (HamishMackenzie)
21:55:19 <Zemyla> jmcarthur: I found out how STT s [] behaves!
21:55:40 <Zemyla> It runs each branch completely and returns it before going on to the next.
21:57:14 <dfeuer> Is reverse a traversal?
21:57:44 <Zemyla> runSTT $ do { r <- newSTRef 0; s <- mplus (return 1) (return 2); modifySTRef r (+s); readSTRef r } returns [1, 3].
22:00:33 <jle`> nice :)
22:01:24 <dfeuer> jle`, do you know if reverse can be written for general Traversables? It seems ... not too unlikely?
22:02:24 <glguy> over (partsOf traverse) reverse 07:: Traversable t 07=> t b 07-> t b
22:02:32 <glguy> depending on what you're doing
22:02:43 <jle`> i'm not totally sure what reverse would look like for some traversables
22:02:48 <dfeuer> glguy, that looks like a bunch of lens stuff.
22:03:17 <glguy> ok
22:03:28 <dfeuer> glguy, by which I mean I don't understand it.
22:03:48 <dfeuer> jle`, it would make the same structure with the elements traversed the other way?
22:04:04 <glguy> yup
22:04:25 <dfeuer> glguy, yeah, but what's that over (partsOf traverse) reverse  stuff mean?
22:04:27 <jle`> the only lens thing there is partsOf...the rest of it can be straightforwardly implemented with normal haskell stuff so it might give a template of what you could do
22:04:55 <glguy> > over (partsOf traverse) reverse (Node 1 [Node 2 [], Node 3 []])
22:04:57 <lambdabot>  Node {rootLabel = 3, subForest = [Node {rootLabel = 2, subForest = []},Node ...
22:05:02 <dfeuer> jle`, I have the vague feeling maybe the StateR type used to implement mapAccumR will do something.
22:05:04 <dfeuer> :t over
22:05:06 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
22:05:09 <dfeuer> o.O
22:05:17 <jle`> over is generalized fmap
22:05:34 <nshepperd> you can traverse it once with a State operation that pushes its argument onto a stack, then traverse it again with a State operation that pops the top item off the stack
22:06:10 <nshepperd> maybe you can use some crazy Reverse State trickery to do it in one pass
22:09:22 <johnw> Tardis!
22:09:59 <dfeuer> Crayze.
22:10:16 <dfeuer> nshepperd, that's a very good explanation.
22:12:12 <dfeuer> nshepperd, I guess the first one is just a fold....
22:12:28 <jle`> > over (partsOf traverse) reverse $ M.fromList [('k', 10),('r',4),('s',9),('a',1000)]
22:12:30 <lambdabot>  fromList [('a',9),('k',4),('r',10),('s',1000)]
22:12:51 <jle`> oh that's neat
22:13:04 <nshepperd> hum.. reverse xs = evalState (traverse_ push xs >> traverse (const pop) xs) []
22:13:10 <nshepperd> for instance
22:13:40 * dfeuer was actually trying to work it out himself :-/
22:13:45 <dfeuer> :t push
22:13:46 <lambdabot> Not in scope: ‘push’
22:13:48 <jle`> that's neat too
22:13:57 <jle`> push = modify . (:)
22:14:00 <dfeuer> Yeah.
22:14:05 <dfeuer> I got the drift.
22:15:29 <zerkms> guys, is there an idiomatic way to transform `[Maybe a]` into `Just [a]` if all maybe's are `Just`s or to `Nothing` otherwise?
22:15:37 <jle`> sequence
22:15:44 <glguy> > sequence [Just 1, Just 2]
22:15:45 <sellers> :t sequence
22:15:46 <lambdabot>  Just [1,2]
22:15:46 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
22:15:57 <zerkms> just checked it and couldn't realize if it fits
22:16:08 <jle`> [Maybe a] -> Maybe [a]
22:16:12 <jle`> sequence lets you "flip the order"
22:16:18 <zerkms> sequence [Just 1, Nothing]
22:16:23 <neuroserpens> shutdown -P now
22:16:37 <neuroserpens> wtf...
22:16:43 <jle`> shutdown command issued. system will shut down in 10 seconds
22:16:45 <neuroserpens> wrong term... god i need sleep
22:16:55 <neuroserpens> sorry
22:17:03 <sellers> how dare you, scoundrel
22:17:55 * jle` is looking at the implementation of partsOf in lens to see if it'll give a nice plain-haskell solution
22:18:12 <scott> what module is lambdabot's sequence from?
22:18:36 <arkeet> Data.Traversable
22:18:47 <jle`> Data.Traversable pre-7.10, and Prelude 7.10+
22:18:55 <scott> 7.10 is exciting :)
22:18:55 <arkeet> was sequence in prelude before?
22:18:58 <jle`> well i guess it's also in Data.Traversable 7.10+, but it's also in Prelude
22:19:03 <scott> yes, with t = []
22:19:08 <jle`> sequence was in prelude, but the [m a] -> m [a] version
22:20:04 <arkeet> yeah, I couldn't remember if it had to be imported from Control.Monad or so
22:20:21 <jle`> yeah that was always weird
22:20:37 <jle`> forM/forM_, when/when_, etc. were imported i think. could never really remember
22:21:00 <jle`> always just waited for the compiler to tell me heh.
22:21:15 <godel> I'm having a problem with type classes, here is a minimal example: http://lpaste.net/130111
22:21:20 <arkeet> when_ doesn't exist.
22:21:26 <godel> neither of those versions of the function compiles
22:21:35 <jle`> oops :P
22:21:37 <godel> I don't know what to do
22:21:46 <arkeet> maybe you could start by showing us the error?
22:22:17 <godel> ok let me paste it there
22:23:31 <scott> godel: you would have to pick some concrete type with a My instance, otherwise GHC has no idea what (f inhabitant) should do
22:23:59 <godel> scott: but f is defined for all instances
22:24:20 <jle`> the result of applying `null` to `f inhabitant` might be different for different instances
22:24:38 <scott> ^ that's the point. some instances might return an empty list, while others may not
22:24:56 <jle`> instance My Bool where inhabitant = True; f x = []; instance My Int where inhabitant = 10; f x = [x]
22:24:57 <scott> so it matters which one you pick here
22:24:59 <godel> but that's the joke
22:25:00 <jle`> so what would `isGood` return?
22:25:16 <godel> jle`: it depends on the type, that's the thing
22:25:22 <scott> GHC rejects your joke a type error :P
22:25:26 <jle`> but how would it know which type to pick?
22:25:35 <godel> but
22:25:38 <jle`> isGood' is a nicer attempt, but by default, type variables aren't scoped
22:25:39 <godel> it is not a type error
22:25:44 <godel> the expresion does have a type
22:25:54 <arkeet> (and it's impossible to specify which type to use when calling isGood')
22:26:01 <jle`> so the `a` on like 8 isn't the same as thee `a` on line 8
22:26:08 <godel> inhabitant :: a      f inhabitant :: [a]      null (f inhabitant) :: Bool
22:26:51 <arkeet> okay.
22:26:56 <godel> i don't see why this isn't a haskell limitation
22:26:58 <arkeet> what should the value of isGood be?
22:27:00 <jle`> but it's not implementable
22:27:08 <scott> inhabitant :: My a => a   f :: My a => a -> [a]   f inhabitant :: My a => [a]    null (f inhabitant) -- ambiguous without specifying which `a`
22:27:09 <jle`> it isn't a haskell limitation, it's a human being limitation too
22:27:27 <narendraj9> godel: That's not how you do ad-hoc polymorphism, aka overloading. The thing that you say about doing something with every type should be done with parametric polymorphism though I don't get what you are trying to do.
22:27:28 <jle`> there isn't any meaningful way to implement it even with a supernaturally inelligent compiler
22:28:01 <jle`> isGood is a Bool...it's evaluated once, and that's what it is, forever
22:28:09 <godel> ah
22:28:11 <godel> jle`: 
22:28:21 <godel> >isGood is a Bool...it's evaluated once, and that's what it is, forever
22:28:28 <godel> that I understand
22:28:36 <godel> mh
22:28:41 <jle`> it has to be either True or False forever...it's an immutable value
22:28:43 <jle`> :)
22:28:46 <godel> yep
22:28:48 <godel> nice
22:28:50 <godel> thanks
22:29:03 <godel> no, i don't mean nice :P, bit I got it
22:29:07 <scott> you could do: isGood :: My a => a -> Bool; isGood x = null (f (inhabitant `asTypeOf` x)) -- or something like this
22:29:12 <scott> not that it makes a tonne of sense
22:29:21 <arkeet> you could do
22:29:23 <arkeet> class My a where
22:29:30 <arkeet>  inhabitant :: Proxy a -> a
22:29:30 <jle`> GHC uses that trick for Typeable
22:29:47 <arkeet> (Proxy is () with a phantom type variable, so you can specify which type you want it instantiated at)
22:29:48 <godel> what trick?
22:29:51 <arkeet> (from Data.Proxy)
22:29:59 <jle`> scott's trick
22:30:04 <jle`> it uses a parameter that it ignores
22:30:11 <jle`> just so the compiler can figure out what type you want
22:30:17 <arkeet> yeah, same idea.
22:30:24 <arkeet> except you can enforce it to be ignored by using a proxy.
22:30:41 <zerkms> checking the `traverse` implementation
22:30:53 <zerkms> err: `sequence`
22:31:01 <godel> nice
22:31:13 <zerkms> and what confuses me is how `sequenceA` and `traverse` mutually refer to each other
22:31:14 <zerkms> http://pastebin.com/RVSY10VH
22:31:20 <jle`> still, there is probably a better way to do whatever it is you are trying to do at the high level :)
22:31:25 <jle`> zerkms: it's the same as for Eq
22:31:30 <zerkms> hm
22:31:33 <zerkms> but how does it work?
22:31:41 <arkeet> isGood :: My a => p a -> Bool; isGood p = null (f (inhabitant `asProxyTypeOf` p))
22:31:42 <jle`> class Eq a where x == y = not (x /= y); x /= y = not (x == y)
22:31:50 <zerkms> I see
22:31:51 <scott> zerkms: the idea is you only have to define one of them and only the other one gets the default implementation you see there
22:31:54 <arkeet> where asProxyTypeOf :: a -> p a -> a
22:31:54 <arkeet> is const
22:31:57 <jle`> you have to provide at least one as a default
22:31:58 <zerkms> the specifications override one
22:32:01 <jle`> yeah
22:32:02 <zerkms> yep, got it
22:32:06 <zerkms> thanks
22:32:18 <arkeet> if you instead had a -> Bool, there would be no guarantee to the caller that the function wouldn't try to use the value.
22:32:26 <godel> great
22:32:31 <godel> thanks guys
22:32:49 <godel> it works
22:32:52 <zerkms> so if I'm looking for `sequence` for `Maybe` I need to go to `Maybe` module implementation? 
22:32:54 <jle`> these days we have compiler warnings if you don't provide the absolute minimum.  back in the old days you can do something like instance Eq Foo;, which would compile and hang forever whenever using (==) on Foo
22:33:04 <jle`> zerkms: it depends on where it's defined...you can check in ghci
22:33:08 <godel> haha
22:33:17 <zerkms> How would I do that in ghci?
22:33:21 <jle`> :i Maybe
22:33:36 <jle`> instance Traversable Maybe -- Defined in 'Data.Traversable'
22:33:46 <arkeet> you look at the implementation of the Traversable instance for Maybe
22:33:47 <zerkms> you guessed that?
22:33:50 <arkeet> since sequence is a method of Traversable
22:33:51 <zerkms> because it's not in Maybe
22:33:53 <jle`> no i just entered it :)
22:34:04 <scott> godel: here's a curious situation similar to yours in a way, except GHC accepts it due to some defaulting:
22:34:05 <arkeet> so you have to find the instance, not the definition of Maybe.
22:34:06 <jle`> you enter `:i Maybe` in ghci, and it shows you where all the instances (in scope) are defined
22:34:07 <scott> :t show . read
22:34:08 <lambdabot> String -> String
22:34:21 <arkeet> scott: ghci accepts it
22:34:21 <scott> the trivia question is what string will that not crash on :p
22:34:24 <arkeet> ghc does not, by default
22:34:27 <scott> ah, right
22:34:31 <zerkms> jle` I did and there is no " instance Traversable Maybe -- Defined in 'Data.Traversable'" line for me, hmm
22:34:35 <scott> > show . read $ ""
22:34:35 <arkeet> because of extended default rules in ghci
22:34:36 <lambdabot>  "*Exception: Prelude.read: no parse
22:34:41 <jle`> zerkms: you have to import Data.Traversable then
22:34:44 <scott> > show . read $ "()"
22:34:44 <jle`> it must not be in scope
22:34:45 <lambdabot>  "()"
22:34:46 <jle`> :'(
22:34:55 <zerkms> yep, thanks
22:34:57 <godel> great
22:34:59 <jle`> pre-7.10 blues
22:35:06 <godel> hey guys
22:35:21 <arkeet> hi
22:35:22 <jle`> :i Traversable will also tell you where all instances of Traversable in scope are defined, too
22:35:25 <godel> what do you think about prelude not being backwards compatible?
22:35:31 <godel> Am i strarting a war?
22:35:32 <arkeet> good in the long run.
22:35:55 <arkeet> there has been a lot of discussion about it
22:36:02 <scott> it's a long run / short run tradeoff for sure
22:36:04 <arkeet> it seemed like most people were in support of the change.
22:36:05 <jle`> i think we've all decided that it's best to all be on board at this point.  we've moved together as a community.
22:36:14 <godel> I use arch as os, so I have had a few problems lastly when distributing code to friends :P
22:36:37 <godel> that do not update as regularly as I do
22:36:51 <arkeet> it's going to make it a bit annoying to write code with ghc 7.10 that you want to work with 7.8
22:37:10 <jle`> yeah my main problems are going to be with the libraries i maintain. oh well
22:37:17 <arkeet> that's what travis-ci is for :-)
22:37:32 <jle`> :-)
22:37:58 <jle`> for now i'll just use 7.10 stuff for my applications and old-Prelude stuff for my libraries...despite the possible performance advantages, i guess
22:38:15 <jle`> the only other way I see being able to take advantage of 7.10 things is with lots of CPP
22:38:37 <jle`> but who knows, maybe liftM isn't much less performant than fmap for most instances.  i haven't benchmarked :)
22:38:59 <Zemyla> Why is Foldable f not a subclass of Functor f? Every Foldable by necessity is a functor.
22:39:07 <arkeet> Zemyla: why is it necessary?
22:39:26 <arkeet> consider Set
22:39:32 <scott> how do you implement fmap using Foldable methods?
22:39:40 <Zemyla> ...sigh.
22:40:09 <Zemyla> Frigging Set.
22:40:32 <EvanR> i thought Foldable did have a Functor prereq
22:40:35 <nshepperd> don't forget bytestrings, unboxed vectors, etc etc
22:40:42 <glguy> Set's just an example. The fact that you can't define the methods of one in terms of the other is the issue
22:40:45 <nshepperd> Traversables are functors
22:40:50 <glguy> ByteStrings aren't foldable, at least
22:41:00 <jle`> is bytestring the right kind...?
22:41:02 <scott> nshepperd: bytestrings can't be Foldable, can they? wrong kind
22:41:15 <EvanR> wrong kind
22:41:35 <jle`> the essense of Foldable is `toList`...so nothing about `toList` really says anything about being fmappable
22:41:36 <nshepperd> well no, not as they're currently implemented. but you can make them foldable by adding a type parameter
22:41:38 <arkeet> it's ok, lens saves the day.
22:41:50 <arkeet> jle`: I would argue that the essence is foldMap.
22:41:51 <Zemyla> You can make kind of a wrapped Foldable that is also a Functor, though.
22:41:52 <jle`> in fact all of Foldable's methods have you "leave" the Foldable
22:42:03 <jle`> none of Foldable's methods can return the foldable back
22:42:08 <arkeet> Zemyla: you can make anything a Functor.
22:42:11 <arkeet> with Coyoneda.
22:42:21 <jle`> but for fmap you need to return the type bacck
22:42:23 <arkeet> that doesn't mean it's the right thing to do all the time
22:42:33 <Zemyla> Yeah, it would basically be a Coyoneda.
22:42:34 <jle`> Foldable's are one-way deconstructors :)
22:42:39 <nshepperd> data ByteStringF a where B :: ByteString -> ByteStringF Word8
22:42:52 <arkeet> yeah that could work.
22:43:00 <arkeet> but why not just
22:43:02 <arkeet> uh
22:43:07 <arkeet> :t pack
22:43:08 <lambdabot>     Not in scope: ‘pack’
22:43:08 <lambdabot>     Perhaps you meant one of these:
22:43:08 <lambdabot>       ‘BS.pack’ (imported from Data.ByteString),
22:43:22 <arkeet> :t each :: Traversal' BS.ByteString Word8
22:43:23 <lambdabot> Applicative f => (Word8 -> f Word8) -> BSC.ByteString -> f BSC.ByteString
22:43:25 <jle`> fmap doesn't really fit into Foldable's MO
22:43:54 <nshepperd> arkeet: clearly it's more fun to be able to use foldMap
22:44:08 <arkeet> nshepperd: what is that in response to?
22:44:37 <EvanR> it doesnt make sense to use foldMap on a bytestring
22:44:47 <nshepperd> "why not just use each"
22:44:58 <Zemyla> :t each
22:44:59 <lambdabot> (Applicative f, Each s t a b) => (a -> f b) -> s -> f t
22:45:19 <nshepperd> oh, you're talking about traversals
22:45:48 <nshepperd> EvanR: sure it does? it's just a container of Word8s
22:45:58 * dfeuer is sleepy.
22:46:08 <EvanR> nshepperd: yes, but its just fold . map
22:46:09 <Zemyla> So the free monoid is also the free Foldable, it looks like.
22:46:21 <EvanR> nshepperd: not Foldable
22:46:22 <Zemyla> Is there a free Traversable?
22:46:41 <shachaf> What is a free Foldable?
22:46:51 <arkeet> what is a free Functor?
22:47:15 <EvanR> or mconcat . map
22:47:29 <arkeet> whatever a free Foldable is, it's a kind error to say that it's the free monoid.
22:47:31 <nshepperd> EvanR: all that means is that you can't write foldMap = fold . map as a law
22:48:08 <nshepperd> (because bytestrings don't have map)
22:48:13 <EvanR> nshepperd: practically, i see no point to make foldMap (the typeclass method) be somehow implemented so that its mconcat . map
22:48:15 <shachaf> arkeet: You're very kind.
22:48:18 <EvanR> toList
22:48:24 <EvanR> unpack
22:48:50 <EvanR> like why is it a typeclass method at that point
22:49:11 <nshepperd> huh?
22:49:39 <EvanR> if you just want the function to be called foldMap, you can just have one that has nothing to do with Foldable
22:50:05 <EvanR> but you gain nothing by it being literally associated with Foldable, because you cant use it polymorphically
22:50:08 * hackagebot bytestring-builder 0.10.6.0.0 - The new bytestring builder, packaged outside of GHC  http://hackage.haskell.org/package/bytestring-builder-0.10.6.0.0 (LeonSmith)
22:50:24 <nshepperd> sure you do, it means you don't have to import stuff qualified
22:50:39 <nshepperd> and you can use all the other Foldable methods as well
22:50:41 <EvanR> is that really the only point?
22:50:54 <Zemyla> :t fmap fmap fmap -- the fuck?
22:50:55 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
22:51:14 <nshepperd> EvanR: it also means you can pass to functions that expect a Foldable
22:51:15 <jle`> Zemyla: do you understand (fmap . fmap) ?
22:51:17 <EvanR> qualified imports is another issue and should have other solutions
22:51:23 <jle`> "fmap over two layers"?
22:51:32 <EvanR> nshepperd: no you cant >_>
22:51:34 <jle`> > (fmap . fmap) (+3) [Just 3, Nothing, Just 10]
22:51:36 <Zemyla> :t fmap . fmap
22:51:36 <lambdabot>  [Just 6,Nothing,Just 13]
22:51:37 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
22:51:50 <EvanR> because the type would have the wrong kind
22:51:50 <nshepperd> EvanR: ???
22:51:53 <jle`> it's like fmap (fmap (+3)) [Just 3, Nothing, Just 10]
22:51:59 <Zemyla> Oh, and fmap over functions is basically composition.
22:52:15 <nshepperd> type ByteString = ByteStringF Word8
22:52:24 <jle`> yeah
22:52:37 <jle`> > fmap (fmap (+3)) [Just 3, Nothing, Just 10]
22:52:38 <lambdabot>  [Just 6,Nothing,Just 13]
22:52:45 <jle`> > (fmap . fmap) (+3) [Just 3, Nothing, Just 10]
22:52:46 <lambdabot>  [Just 6,Nothing,Just 13]
22:52:47 <EvanR> nshepperd: what is the type of a function that you would pass that to
22:53:07 <jle`> > (fmap `fmap` fmap) (+3) [Just 3, Nothing, Just 10]
22:53:09 <lambdabot>  [Just 6,Nothing,Just 13]
22:53:12 <jle`> then expand the infix to postfix, ta da
22:53:15 <EvanR> thats polymorphic in Foldable
22:53:16 <jle`> *prefix
22:53:46 <nshepperd> EvanR: 'fold :: Foldable f => Fold a b -> f a -> b' from the foldl package, for instance
22:54:30 * EvanR goes to look all that up
22:55:21 <EvanR> this seems like the same issue as making your Monoid a Monad (with a dummy type parameter) so you can use do notation to execute mappends
22:55:22 <nshepperd> anyway, I'll concede that it makes a bit more sense to do this sort of thing with unboxed vectors / arrays / whatever, since it doesn't require you to add or remove type parameters
22:56:27 <arkeet> ByteString is baiscally a Vector of Word8s, anyway.
22:57:07 <arkeet> unfortunately, Storable.Vector isn't Foldable for a slightly different reason.
22:57:23 <EvanR> orphaned instances?
22:57:25 <Zemyla> :t fmap fmap fmap fmap fmap fmap fmap fmap
22:57:26 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
22:57:33 <arkeet> EvanR: no, because of the Storable constraint.
22:57:36 <EvanR> oh
22:57:41 <nshepperd> nah, the reason is essentially the same
22:57:46 <arkeet> I said slightly.
22:57:57 <shachaf> fmap^6 = fmap^10
22:57:59 <arkeet> Zemyla: figure this one out
22:58:00 <Zemyla> And there is apparently no number of fmaps that fmaps over four functora.
22:58:00 <arkeet> yeah that
22:58:04 <arkeet> :t fmap fmap fmap fmap fmap fmap 
22:58:05 <lambdabot> (Functor f, Functor f1) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
22:58:05 <arkeet> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap 
22:58:06 <EvanR> at least Vectors have the right kind, they have a parameter that actually matters, unlike ByteString
22:58:06 <lambdabot> (Functor f, Functor f1) => (a1 -> a -> b) -> f a1 -> f (f1 a -> f1 b)
22:58:18 <arkeet> however, fmap^5 /= fmap^9
22:58:19 <arkeet> puzzling.
22:58:29 <EvanR> adding useless parameters for syntax tricks seems wrong
22:59:22 <EvanR> ByteString is implemented as word8 vectors, but thats got nothing to do with its type
22:59:39 <scott> arkeet: that reminds me of the proof that a 7-tuple of a certain tree type is isomorphic to just one of that tree
22:59:46 <Zemyla> The Foldable Bytestring type is ByteString' a = ByteString (Word8 -> a) ByteString 
23:00:27 <EvanR> by the same reasoning, Integer should be foldable
23:00:46 <arkeet> heh.
23:01:06 <EvanR> by folding bits, or digits
23:01:16 <nshepperd> well, the whole reason I brought this up is because there's no need to Functorize things with a coyoneda trick just to make them Foldable
23:01:22 <arkeet> EvanR: or bytes.
23:01:29 <EvanR> >_<
23:02:04 <nshepperd> things that obviously aren't functors like storable vectors can still have useful folds
23:02:04 <Zemyla> Actually, I figured out what fmap fmap fmap is.
23:02:19 <sellers> meta comment: I learn more from googling things to try to follow discussions in this channel than any other Haskell source, I swear
23:02:30 <Zemyla> It's the sound a Haskell programmer makes when he masturbates.
23:02:30 <EvanR> they can but Foldable seems like the wrong thing, however Foldable has no laws so whatever
23:02:48 <AshyIsMe> Zemyla: haha
23:03:48 <Rotaerk> that's awful
23:03:49 <Rotaerk> lol
23:04:44 <arkeet> EvanR: sure it does.
23:05:04 <arkeet> if g is a monoid homomorphism, then foldMap (g . f) = g . foldMap f
23:05:31 <EvanR> is that even true for current Foldables?
23:06:01 <jle`> oh there are FOldable laws now in base 4.8
23:06:09 <jle`> neat
23:06:41 <EvanR> alternatively does that disallow foldMap _ _ = mempty
23:07:02 <jle`> previously there were no laws.  i am not certain that arkeet's law would have been enforced pre-4.8
23:07:47 <arkeet> I don't think this law can be enforced.
23:07:51 <shachaf> arkeet: Can you write me a Foldable instance that doesn't obey the laws?
23:07:52 <arkeet> much like the monad laws can't be enforced.
23:08:00 <arkeet> shachaf: I can't remember if this is free or not.
23:08:01 <jle`> i mean, enforced by the laws
23:08:01 <shachaf> Zemyla: Not appropriate for this channel.
23:08:30 <jle`> the foldMap (g . f) = g . foldMap f cannot be said to hold for all law-abiding Foldable instances pre-4.8
23:08:35 <jle`> mostly because there are no laws pre-4.8
23:08:55 <EvanR> theres gotta be a better way to say that
23:09:00 <jle`> (for monoid homomorphism g)
23:09:13 <shachaf> Why can it not be said?
23:09:28 <jle`> because there were no laws...implementations are only bound by parametricity
23:09:30 <arkeet> EvanR: why would it disallow foldMap _ _ = mempty?
23:09:33 <Zemyla> Sorry.
23:09:37 <arkeet> you can always pretend your Foldable doesn't have anything in it.
23:09:53 <jle`> *meaningful statements that can be made about implemenations can only come from parametricity
23:10:00 <EvanR> arkeet: it wouldnt, but sometimes it comes up that there should be laws that make that impossible, like Functor
23:10:10 <arkeet> I don't think it should be impossible.
23:10:14 <shachaf> What is parametricity for a non-Functor?
23:10:26 <arkeet> but probably if your thing is a Functor then it should interact with Functor appropriately.
23:10:40 <arkeet> such as foldMap (f . g) = foldMap f . fmap g
23:10:45 <shachaf> Isn't that free?
23:11:22 <jle`> parametricity would be something like saying foldMap :: Monoid m => (a -> m) -> t a -> m can not interact directly with `a` and `m` as concrete types
23:11:30 <arkeet> so e.g. you cannot have a Foldable instance for [] that obeys the fmap law as well as having foldMap _ _ = mempty
23:11:39 <arkeet> wait sure you can.
23:11:40 <arkeet> never mind.
23:11:48 <jle`> in the implementation of foldMap
23:11:51 <arkeet> okay
23:11:59 <arkeet> I don't see any reason to disallow foldMap _ _ = mempty.
23:12:05 <EvanR> ok 
23:12:14 <arkeet> pretty sure you can't have that for a nontrivial Traversable though.
23:12:18 <shachaf> If you want to disallow that, use Traversable.
23:12:30 <jle`> Traversable laws are pretty solid and say a lot
23:13:08 <shachaf> Traversable instances aren't unique like Functor instances.
23:13:21 <arkeet> sure.
23:13:24 <arkeet> you can always traverse something backwards.
23:13:33 <arkeet> for example.
23:13:56 <shachaf> You can even decide how to traverse something based on the parts you don't traverse.
23:14:16 <nshepperd> hmmm, you could invent laws relating Foldable to Applicative/Alternative that would disallow 'foldMap _ _ = mempty', but they would probably have poor consequences
23:14:47 <jle`> i think disallowing foldMap _ _ = mempty is a road that closes off a lot of useful foldable instances
23:15:02 <EvanR> what
23:15:11 <sellers> jle`: like what?
23:15:25 <EvanR> exactly that instance
23:15:26 <nshepperd> eg. 'foldMap f (pure x) = f x' works but rules out ziplists and other things
23:15:40 <nshepperd> "works"
23:16:00 <EvanR> is that a law or an instance
23:16:05 <EvanR> ok law
23:16:28 <arkeet> I don't think Foldable and Applicative shold be related.
23:16:42 <shachaf> Do you want to rule this one out? data Repeated a = Repeated Int a; foldMap f (Repeated n x) = foldMap f (replicate n x)
23:17:05 <arkeet> Functor/Applicative kind of lives in a different world from Functor/Foldable/Traversable, I think.
23:17:14 <jle`> i feel like any meaningful and non-ad-hoc law you can make to try to disallow foldMap _ _ = mempty is going to disallow something like `data Two a = One a | Two a`, foldMap f (One x) = f x; foldMap f (Two x) = f x
23:17:16 <arkeet> and Applicative is dual to Traversable in some vague sense.
23:17:23 <arkeet> (via traverse)
23:17:33 <johnw> arkeet: how is it dual?
23:17:38 <arkeet> :t traverse
23:17:39 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
23:17:40 <arkeet> in a vague sense.
23:17:42 <arkeet> related to traverse.
23:18:29 <EvanR> shachaf: looks good to me, is there something wrong with it
23:18:38 <arkeet> maybe not dual.
23:18:55 <jle`> the "this feels wrong" intuition that is triggered when you see foldMap _ _ = mempty is probably the idea that you're losing information...but foldable instances should be allowed to lose and throw away information. for reasons like the data type shown above
23:19:20 <arkeet> jle`: I don't see how the Foldable instance for Two throws away information.
23:19:27 <jle`> it throws away what the constructor was
23:19:35 <jle`> it's really a tuple (Bool, a)
23:19:39 <jle`> and you're throwing away the Bool
23:19:42 <arkeet> whatever Two a you give me, foldMap looks at all thea 's in it.
23:19:44 <arkeet> well yes.
23:19:44 <EvanR> throwing away the constructors seems to be the point of Foldable
23:20:02 <johnw> isn't that what folding pretty much is about?
23:21:22 <jle`> maybe replace "throwing away" with "not using as much information as possible"
23:21:41 <shachaf> No one objected to the fact that you don't get the Bool.
23:22:01 <nshepperd> anyway, I think jle` is right, it can make sense to only look at a subset of the contents in a fold
23:22:02 <EvanR> i objected to the scenario where you dont get anything
23:22:27 <nshepperd> eg. 'foldMap _ (Repeated 0 _) = mempty', in shachaf's example
23:22:34 <EvanR> or a One a | Two a where you do use the value in One but mempty on Two
23:22:49 <arkeet> let's think about what sort of abstract thing a Foldable should be.
23:23:21 <arkeet> I guess it's like
23:23:31 <arkeet> uh
23:23:53 <shachaf> data Iterated a = Iterated (a -> a) a; foldMap f (Iterated g x) = foldMap f (iterate g x)
23:24:32 <shachaf> That one isn't a Functor, so who can say what "a"s it truly contains?
23:24:33 <arkeet> another thing.
23:24:43 <arkeet> there's no reason to restrict Foldable to only look at an element once.
23:24:56 <arkeet> data One a = One a; instance Foldable One where foldMap f (One x) = f x <> f x
23:25:08 <Hijiri> what's wrong with only taking One values
23:25:09 <shachaf> Yes, that's Repeated above.
23:25:10 <nshepperd> EvanR: but if you rename those constructors to 'data Two a = Good a | Bad a' it might make sense to ignore the Bad value
23:25:13 <arkeet> oh.
23:25:14 <Hijiri> wouldn't Either a a basically do that
23:25:15 <arkeet> I missed it.
23:25:20 <arkeet> Hijiri: nope.
23:25:32 <shachaf> Foldable is scow.
23:25:35 <EvanR> nshepperd: for Foldable only ? thats more like a Filterable
23:25:36 <shachaf> Just use Traversable.
23:25:39 <EvanR> its own can of worms
23:25:40 <arkeet> it's like
23:25:44 <arkeet> some natural transformation
23:26:00 <johnw> maybe one thing people are saying here is that a Foldable instance should all for all possible folds, rather than ruling out some of those possibilities by its implementation
23:26:05 <johnw> s/all/allow
23:26:20 <arkeet> I disagree.
23:26:23 <arkeet> that it should.
23:26:55 <johnw> it's like the difference between foldr, and another version of foldr that doesn't visit every member of the list, right?
23:27:11 <EvanR> based on an arbitrary pattern?
23:27:12 <nshepperd> it should do whatever is most useful in practice for the data type in question, which is generally domain-specific 
23:27:17 <jle`> if that's the case, then the Two instance I described earlier would not work, because it's possible to encode the Bool into foldMap/toList...and that opens up a possible fold that would be lost if the Bool wasn't encoded.
23:27:36 <johnw> nshepperd: I meant, if we were thinking of laws for Foldable; if it has no law, then fine, implementor's choice
23:27:45 <shachaf> sigh
23:28:16 <jle`> i think Foldable is just a catch-all by-instance ad-hoc thing
23:28:31 <jle`> if Foldable is also a Traversable, then that's where things become interesting
23:28:32 <johnw> shachaf: was that a meaningful sigh?
23:28:38 <Hijiri> is it possible to have two possible Foldable instances, where neither can be implemented in terms of the other?
23:28:41 <johnw> did he leave?
23:28:42 <jle`> shachaf left
23:28:52 <Hijiri> and now least common multiple
23:28:56 <arkeet> whatever it is
23:28:57 <Hijiri> s/now/no
23:29:02 <Hijiri> that can implement those two instances
23:29:07 <jle`> Hijiri: least common multiple is not always the best instance
23:29:10 <arkeet> a Foldable gives you
23:29:21 <arkeet> a natural transformation from some endofunctor on the category of monoids
23:29:24 <arkeet> to the identity functor
23:29:34 <arkeet> :t fold
23:29:35 <lambdabot> (Foldable t, Monoid m) => t m -> m
23:29:35 <Hijiri> I'm just wondering if it's possible that two possible instances can have no LCM
23:30:04 <nshepperd> johnw: I think it can have a few sensible laws and still have wiggle room to decide 'what' to fold
23:30:16 <arkeet> in other words it makes every monoid naturally a F-algebra.
23:30:20 <arkeet> t-algebra.
23:31:07 <EvanR> is the monoid homomorphism law automatically satisfied?
23:31:17 <arkeet> I think so.
23:31:36 <arkeet> via the fact that an implementation can't "know" what monoid it's getting.
23:31:45 <arkeet> (so I mean it's a free theorem.)
23:32:35 <EvanR> so Foldable is left with no real guidance on what an implementation is supposed to do, i guess "no laws" might be technically wrong
23:33:07 <arkeet> probably the interaction with fmap is also a free theorem.
23:33:27 <arkeet> @free (a -> m) -> t a -> m
23:33:27 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
23:33:33 <arkeet> @free foldMap :: (a -> m) -> T a -> m
23:33:33 <lambdabot> g . h = k . f => g . foldMap h = foldMap k . $map_T f
23:33:38 <arkeet> yep.
23:33:57 <c_wraith> There are a couple candidate laws for what Foldable should do.  They all seem awfully weak, but that's because parametricity covers most of the obvious stuff
23:34:26 <arkeet> I think there shouldn't be any additional laws.
23:35:04 <c_wraith> Fortunately, this isn't a MonadPlus situation.
23:35:05 * zerkms just used `>>=` for the first time
23:35:13 <jle`> congrats zerkms :)
23:35:18 <zerkms> this world will never be the same
23:35:27 <arkeet> I think a consequence of these (free) laws is that
23:35:30 <c_wraith> People aren't going to agree to laws for Foldable unless they actually seem right.  (unlike MonadPlus)
23:35:31 <jle`> i actually don't use (>>=) that often...most of the time i use (=<<) in situations where I'd otherwise use (>>=)
23:35:33 <nshepperd> oh, the laws in base-4.8 don't actually restrict foldMap at all
23:35:39 <arkeet> a Foldable is uniquely determined by a map
23:35:47 <EvanR> zerkms: achievement unlocked
23:35:48 <arkeet> t a -> FM a
23:35:51 <arkeet> where FM is the free monoid.
23:35:55 <arkeet> (which isn't quite the same as [])
23:36:04 <c_wraith> Isn't that what foldMap is?
23:36:24 <arkeet> it's foldMap on the canonical map a -> FM a
23:36:49 <arkeet> if we stick to finite stuff so FM *is* []
23:36:58 <arkeet> then I'm basically saying Foldable is completely determined by toList
23:37:06 <arkeet> and uniquely
23:37:11 <arkeet> er
23:37:20 <arkeet> there's a 1-1 correspondence.
23:37:28 <arkeet> between maps t a -> FM a and Foldable instances on t.
23:37:33 <EvanR> makes sense
23:37:39 <arkeet> natural maps I guess.
23:38:48 <EvanR> the repeated example above means theres unlikely to be a law that can tell us how toList is supposed to work
23:39:20 <arkeet> toList (Repeated n x) = replicate n x
23:39:50 <EvanR> yeah it uses the extra info n in a certain way, but it could have been inconsequential and toList (Repeated n x) = [x]
23:39:57 <arkeet> yeah.
23:40:00 <EvanR> in a different example
23:40:10 <arkeet> :t toList
23:40:11 <lambdabot> IsList l => l -> [Item l]
23:40:13 <arkeet> agh
23:40:14 <arkeet> :t F.toList
23:40:15 <lambdabot> Foldable t => t a -> [a]
23:40:34 <arkeet> :t \f z -> foldr f z . F.toList
23:40:35 <lambdabot> Foldable t => (a -> c -> c) -> c -> t a -> c
23:40:57 <arkeet> :t \f -> foldMap f . F.toList
23:40:58 <lambdabot> (Foldable t, Monoid c) => (a -> c) -> t a -> c
23:41:23 <arkeet> this *almost* is the same as foldMap.
23:41:33 <arkeet> (except [] is only almost the free monoid.)
23:41:48 <EvanR> when is it not
23:41:59 <arkeet> when e.g. your structure can be left-infinite
23:42:00 <c_wraith> When it's infinite and you want to reassociate
23:42:25 <EvanR> head explode
23:42:28 <arkeet> [a] doesn't have any elements z such that x <> z = z for all z.
23:42:41 <arkeet> but left-infinite lists do.
23:43:01 <EvanR> it doesnt?
23:43:07 <arkeet> sorry.
23:43:09 <arkeet> x <> z = z for all x
23:43:28 <arkeet> (just pick x to be something that starts with something different from z)
23:43:33 <c_wraith> Hmm.  Your Repeated type can't be a Traversable consistently with that Foldable instance.
23:43:40 <arkeet> that's right.
23:43:50 <EvanR> c_wraith: which instance
23:44:01 <arkeet> the one that uses replicate 
23:44:02 <EvanR> arkeet: [a] is finite lists?
23:44:07 <arkeet> EvanR: no, Haskell lists.
23:44:24 <arkeet> if we were in a finite world then [a] would be the free monoid on a.
23:44:38 <arkeet> as in a world with just data (no codata)
23:44:55 <EvanR> is x <> z = z for all z required by free monoidism?
23:45:11 * hackagebot webkitgtk3-javascriptcore 0.13.0.4 - JavaScriptCore FFI from webkitgtk  http://hackage.haskell.org/package/webkitgtk3-javascriptcore-0.13.0.4 (HamishMackenzie)
23:45:14 <arkeet> for all x.
23:45:26 <arkeet> pick an arbitrary element a.
23:45:29 <EvanR> for all x there exists a z such that
23:45:38 <arkeet> consider (((... <> a) <> a) <> a) <> a
23:45:38 <EvanR> or
23:45:45 <EvanR> right
23:45:46 <arkeet> no, there exists z such that for all x
23:45:57 <arkeet> hmm.
23:46:00 <arkeet> I think I got that wrong.
23:46:02 <EvanR> im trying to get the whole law
23:46:06 <arkeet> associate the other way.
23:46:23 <arkeet> uh.
23:46:38 <arkeet> maybe I should think *before* typing.
23:46:58 <arkeet> anyway, there is a type of left-infinite lists.
23:47:02 <arkeet> and it's a perfectly fine Foldable.
23:47:06 <arkeet> (in Haskell again.)
23:47:10 <arkeet> but toList doesn't work on it.
23:47:20 <arkeet> because there is no first element.
23:47:44 <EvanR> ... then how is it a fine Foldable and ... whats the left infinite list type?
23:47:47 <arkeet> ok
23:47:58 <arkeet> data L a = Snoc (L a) a
23:48:01 <Gurkenglas_> Is there a web frontend to lambdabot?
23:48:05 <c_wraith> It's a perfectly fine foldable because FoldMap can work fine with monoids like Last
23:48:09 <arkeet> yeah.
23:48:12 <EvanR> oh Stream a
23:48:15 <arkeet> not quite.
23:48:15 <johnw> Gurkenglas: that would actually be pretty cool
23:48:17 <arkeet> Stream is right-infinite.
23:48:21 <mauke> Maerts a
23:48:24 <arkeet> :)
23:48:44 <EvanR> huh
23:48:56 <arkeet> foldMap f (Snoc as a) = foldMap f as <> a
23:49:15 <arkeet> er, ... <> f a
23:49:28 <EvanR> ok Foldable can make sense if toList doesnt because free monoid isnt list, ok.
23:49:37 <arkeet> my point exactly.
23:49:38 <EvanR> but how is L a = Snoc (L a) a not Stream 
23:49:56 <mauke> it gives you last elements, not first
23:50:11 * hackagebot webkit-javascriptcore 0.13.0.4 - JavaScriptCore FFI from webkitgtk  http://hackage.haskell.org/package/webkit-javascriptcore-0.13.0.4 (HamishMackenzie)
23:50:30 <EvanR> is there an actual difference and im misreading it, and mis alpha-renaming it
23:50:39 <arkeet> Stream a = Cons a (Stream a)
23:50:57 <EvanR> R a = Cons a (R a)
23:51:01 <arkeet> yeah.
23:51:03 <EvanR> L a = Snoc (L a) a
23:51:12 <arkeet> obviously they're isomorphic
23:51:19 <arkeet> but the point is that the Foldable instances aren't.
23:51:25 <EvanR> nothing is obvious at 2AM
23:51:33 <EvanR> ok i see
23:51:39 <arkeet> reverse (Cons a as) = Snoc (reverse as) a
23:51:42 <arkeet> is your isomorphism
23:52:19 <arkeet> anyway, we *can* express the free monoid in haskell.
23:52:26 <arkeet> FM a = forall m. (a -> m) -> m
23:52:30 <arkeet> er
23:52:32 <arkeet> yeah.
23:52:36 <arkeet> except as a newtype.
23:52:42 <Gurkenglas> :k Flip
23:52:43 <lambdabot> Not in scope: type constructor or class ‘Flip’
23:52:45 <mauke> positive_integers = go 1 where go n = Cons n (go (n + 1))
23:52:46 <arkeet> let' fix it.
23:52:56 <arkeet> newtype FM a = FM (forall m. Monoid m => (a -> m) -> m)
23:52:58 <arkeet> better.
23:53:01 <mauke> negative_integers = go (-1) where go n = Snoc (go (n - 1)) n
23:53:12 <mauke> both in ascending order
23:53:15 <Gurkenglas> Why's there no Flip ::: (* -> * -> *) -> (* -> * -> *)?
23:53:17 <arkeet> then foldMap f (FM c) = c f
23:53:33 <Gurkenglas> (::: is for kinds right?)
23:53:36 <mauke> no, ::
23:53:40 <arkeet> Gurkenglas: there is no reason one cannot write newtype Flip f x y = Flip (f y x)
23:53:43 <EvanR> how many more things can we get away with by just saying its different trust me ;)
23:53:48 <arkeet> Gurkenglas: however, you can't make Flip . Flip = id
23:54:10 <mauke> type Flip f x y = f y x  -- but that's useless
23:54:15 <arkeet> yeah you can do that.
23:54:21 <arkeet> but it's useless because you can't partially apply type synonyms.
23:54:27 <EvanR> [1..] is all positive integers in descending order as a left infinite list ;)
23:54:47 <mauke> but by convention [] has "first" elements
23:54:57 <EvanR> haha
23:54:57 <arkeet> [..1]
23:54:58 <arkeet> :)
23:55:10 <arkeet> oh wait I misread.
23:55:20 <EvanR> what happens when you append a left infinite list to a right infinite list
23:55:23 <Gurkenglas> There should be [..] :: Enum a => [a]
23:55:27 <arkeet> then you get a both-infinite list. :)
23:55:28 <EvanR> well, prepend
23:55:41 <mauke> Gurkenglas: needs Bounded
23:55:49 <mauke> EvanR: type error?
23:55:55 <EvanR> type error
23:56:10 <arkeet> EvanR: if you append
23:56:11 <EvanR> or a zipper
23:56:13 <mauke> :t [minBound .. maxBound]
23:56:14 <arkeet> you get a middle-infinite list :-)
23:56:14 <lambdabot> (Bounded t, Enum t) => [t]
23:56:23 <EvanR> depending on your mood that day
23:56:36 <arkeet> a more concrete implemntation of the free monoid is
23:56:45 <arkeet> data FM a = Mempty | Mappend (FM a) (FM a)
23:56:53 <arkeet> but that's just a binary tree.
23:57:12 <EvanR> so the free monoid is a binary tree
23:57:14 <arkeet> but you're supposed to promise to not distinguish between Mappend (Mappend a b) c) and Mappend a (Mappend b c))
23:57:28 <arkeet> or a and Mappend Mempty a
23:57:29 <mauke> it's an AST of mappends, basically
23:57:30 <arkeet> because monoid laws.
23:57:54 <arkeet> unbalanced parens.
23:58:08 <EvanR> that makes so much more sense to me than what i thought i knew before, which was that it was a list
23:58:16 <arkeet> nice.
23:58:52 <EvanR> why did i think that? or why would that even be a mistake someone could make ?
23:59:09 <mauke> it is a list with potentially infinite embedded sections
23:59:38 <arkeet> EvanR: because what you thought *is* true in a strict language.
23:59:39 <arkeet> or in mathematics.
23:59:46 <EvanR> what
23:59:50 <arkeet> that list = free monoid
23:59:59 <mauke> if you ignore infinite sections or only have one on the right, it's a straight list
