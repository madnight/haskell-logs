00:33:35 <meesha> Hi guys, i am sorry for bothering but is there anyone active now who understands monads in depth?
00:33:46 <johnw> what is the question?
00:34:40 <meesha> THank you John.
00:34:44 <meesha> Here is a question
00:35:00 <meesha> there a book by Graham Hutton where he discusses parsers
00:35:05 <meesha> and there is an example
00:35:08 <meesha> at one point
00:35:39 <meesha> http://pastebin.com/RQ6uAtX4
00:35:41 <meesha> here is a link
00:35:42 <meesha> to the code
00:35:48 <meesha> it is desugared notation
00:36:05 * hackagebot yarr 1.4.0.0 - Yet another array library  http://hackage.haskell.org/package/yarr-1.4.0.0 (DominicSteinitz)
00:36:07 <meesha> can you follow it?
00:36:07 <johnw> ok
00:36:09 <johnw> sure
00:36:18 <meesha> ok
00:36:21 <meesha> so
00:36:43 <meesha> what it does it is a function that takes an string as input and returns a value of type parser
00:37:00 <meesha> so far so good
00:37:01 <meesha> right
00:37:02 <johnw> where do you see it taking a string as input?
00:37:06 <meesha> well
00:37:15 <meesha> sorry
00:37:17 <meesha> i should have
00:37:17 <johnw> it's just a value of type Parser (Char, Char)
00:37:23 <meesha> added code for item
00:37:25 <meesha> apologies
00:37:38 <johnw> even then, it wouldn't change the meaning of 'p'
00:38:29 <meesha> in the book
00:39:24 <meesha> Parser of type a or Parser a is defined as type Parser a :: String -> [(a,String)]
00:39:38 <johnw> ok
00:39:48 <meesha> so it takes string as input by default
00:39:53 <meesha> err implicitly
00:40:02 <johnw> what's the monad part of the question?
00:40:12 <meesha> so you have
00:40:21 <meesha> item `bind` everything else
00:40:23 <meesha> in the code
00:40:25 <meesha> do you see it
00:40:28 <johnw> i do
00:40:52 <meesha> it executes parser item
00:40:57 <meesha> and then passes something to
00:41:00 <meesha> variable a
00:41:13 <meesha> what was really bugging me
00:41:16 <meesha> for several weeks
00:41:21 <meesha> what exactly is passed to variable a
00:41:40 <meesha> is it monadic valye [(a,String)]
00:42:00 <meesha> or is it modified string
00:42:05 <meesha> or is it value a
00:42:21 <johnw> have you looked at the implemented of bind for Parser a?
00:42:26 <johnw> implementation*
00:42:27 <meesha> yes
00:42:31 <meesha> it is here
00:43:01 <meesha> http://pastebin.com/z0qRs9aY
00:43:16 <meesha> sorry for incomplete code
00:43:43 <johnw> so, the 'a' in first paste
00:43:51 <johnw> is what is passed to the 'f' in the second paste
00:44:23 <johnw> it looks like this code is using list to mean what Maybe is for
00:44:30 * Digit is loving this find: http://www.haskellforall.com/2015/01/use-haskell-for-shell-scripting.html
00:45:16 <meesha> I see
00:45:20 <meesha> so you are saying that
00:45:31 <meesha> what is passed is to the other function
00:45:36 <meesha> after item is executed is
00:45:44 <johnw> yes, if (item) results in [], the bound function is not called
00:46:01 <meesha> part a from the monadic value [(a,String)]
00:46:01 <johnw> if (item) results in some [(x, _)], the bound function is called with 'x'
00:46:05 * hackagebot yarr 1.4.0.1 - Yet another array library  http://hackage.haskell.org/package/yarr-1.4.0.1 (DominicSteinitz)
00:46:17 <meesha> so x is passed
00:46:17 <meesha> ok
00:46:18 <meesha> thank you
00:46:21 <meesha> second question
00:46:25 <meesha> how does is know
00:46:32 <meesha> to pass string
00:46:39 <meesha> because item modifies input string
00:46:51 <meesha> which then modified string is passed to the the rest of the functions
00:47:00 <johnw> you mean, how does the whole change "start'?
00:47:03 <johnw> chain*
00:47:28 <sellers> Digit: that looks like a good read, thanks for linking.  I'd disagree about lightweight syntax, but maybe once I'm more experienced..
00:47:34 <meesha> I think it starts by applying function item to the input string which produces monadic value [(a,modified string)]
00:47:49 <meesha> what happens then
00:48:02 <meesha> the other expression is anonymous function
00:48:04 <meesha> right?
00:48:06 <johnw> [(a, modified string)] is not a "monadic value"
00:48:10 <johnw> it's just a value, like any other
00:48:18 <meesha> well, i mean a value and the context
00:48:27 <johnw> in fact, none of this is really about monads at all, so maybe it will be simpler if we step back
00:48:38 <johnw> what we're really asking about is how bind does what it does
00:48:50 <meesha> in a sense yes
00:48:55 <meesha> it calls item
00:49:04 <meesha> then it calls other function's
00:49:13 <meesha> but it has to pass modified string to it
00:49:28 <meesha> in order for other functions to be executed
00:50:03 <johnw> it takes an input, applies the first parser to it -- (item) in your case --, then takes the result of that parse plus any leftover input, applies 'f' to that result, and then, because the result of 'f' is another parser, applies that parsing to the leftover input from the first parse
00:50:25 <meesha> ok
00:50:26 <meesha> yes
00:50:28 <meesha> so
00:50:30 <meesha> first step
00:50:33 <meesha> is the function
00:50:41 <meesha> String -> [(a,modified String)]
00:50:42 <meesha> right
00:50:46 <johnw> no modification is happening anywhere
00:50:51 <meesha> it does
00:50:55 <meesha> it consumes string
00:50:56 <johnw> String -> [(a, some other String)]
00:51:01 <meesha> yes
00:51:03 <johnw> technically, it doesn't have to
00:51:05 <meesha> original string is consumed
00:51:15 <meesha> after item
00:51:29 <meesha> thats how parser works
00:51:35 <johnw> there is a relationship between the input and output strings, yes
00:51:40 <johnw> but it's not a relationship of modification
00:51:52 <johnw> you could say the output string is based on information from the input string
00:51:52 <meesha> string is consumed
00:51:55 <meesha> thats what i am saying
00:52:02 <meesha> first character of the stting is consumed
00:52:08 <johnw> consumed meaning...?
00:52:14 <meesha> so the string is not the same
00:52:27 <johnw> I think I agree with you, but I'm not sure
00:52:34 <johnw> the original string is untouched in Haskell
00:52:35 <meesha> look at item
00:52:36 <meesha> (x:xs) -> [(x, xs)]
00:52:40 <johnw> right
00:52:44 <meesha> so string is modified
00:52:46 <meesha> so what you are getting is
00:52:48 <johnw> no, it is not modified
00:52:51 <sellers> johnw: meesha I think you two would agree if meesha said *potentially* consumed part of the string
00:52:57 <meesha> ys
00:52:59 <meesha> yes
00:53:02 <johnw> xs is simply a pointer to the "tail" of the original string
00:53:02 <meesha> original string is abc
00:53:08 <meesha> modified string is "bc"
00:53:19 <johnw> modified is a bad choice of word here, in a Haskell context
00:53:25 <meesha> well
00:53:29 <johnw> result string is "bc"
00:53:31 <meesha> yes
00:53:34 <meesha> sorry
00:53:42 <meesha> i should have used term
00:53:45 <meesha> output string
00:53:49 <johnw> ok, I'm with you
00:53:53 <meesha> so now
00:53:59 <meesha> after we apply parser item to the string
00:54:32 <meesha> for example: parse item "abc" we get [('a', "bc")]
00:54:33 <meesha> right
00:54:55 <johnw> exactly, yes
00:55:01 <meesha> now
00:55:06 <meesha> first part is clear
00:55:16 <meesha> we apply parser item to a string and we get this valye
00:55:19 <meesha> now the question is
00:55:25 <meesha> there other function left
00:55:26 <meesha> which is
00:55:43 <meesha> (\a ->  -- applies function item to a string and binds the result to value a
00:55:43 <meesha>   (item) `bind`(\b -> -- the big question is how is the
00:55:43 <meesha>    (item) `bind` (\c -> (return1 (a,c)))))
00:55:48 <johnw> right
00:55:50 <johnw> let's call that "f"
00:55:54 <meesha> yep
00:55:57 <johnw> parse (f 'a') "bc"
00:55:59 <meesha> what is passed to \a?
00:56:02 <johnw> will be the next "step" in the parse
00:56:27 <meesha> because if I look at it
00:56:27 <johnw> 'a' is passed to \a, in this example
00:56:32 <meesha> the other function f has to consume string
00:56:38 <meesha> i mean it has to have string as input
00:56:47 <meesha> otherwise it won't execute
00:56:59 <meesha> am I right
00:57:11 <johnw> f is of type: a -> Parser b
00:57:17 <johnw> and a ~ Char in this example
00:57:31 <meesha> so
00:57:32 <johnw> now, the parser returned by "f a", that wants a string
00:57:41 <johnw> return by "f 'a'", I mean
00:57:41 <meesha> yes
00:57:44 <meesha> it wants a string
00:57:47 <meesha> but how does it know
00:57:50 <meesha> that it has to consume
00:58:01 <meesha> string from parser item and not original string
00:58:13 <meesha> this is what has been driving me crazy
00:58:15 <johnw> because f returns a parser, a function basically
00:58:20 <johnw> and that function gets passed the leftover
00:58:21 <meesha> yes
00:58:23 <meesha> f is parser
00:58:23 <johnw> your "bc" in this example
00:58:28 <johnw> f is not a parser
00:58:34 <johnw> f is a function that, given a Char, returns a Parser
00:58:39 <meesha> ohh yes
00:58:41 <meesha> yes yes yes
00:59:36 <meesha> so f is a function that takes a Char and returns a Parser of Type b
00:59:59 <johnw> yes!
01:00:02 <meesha> and this function f has to have String as input
01:00:05 <johnw> and b happens to be of type (Char, Char) in this example
01:00:18 <johnw> the function f has a Char as input
01:00:26 <johnw> the Parser it returns happens to be a function that takes a string as ainput
01:00:27 <meesha> it is getting clearer
01:00:45 <johnw> part of what makes this examlpe difficult is that Parser is also a function in disguise
01:00:52 <meesha> yep
01:00:55 <meesha> Parser is
01:00:57 <johnw> so 'f' is a function returning a function
01:01:10 <meesha> which than takes an input
01:01:14 <meesha> string
01:01:17 <johnw> higher-order coding was always very difficult for me in the beginning
01:01:44 <meesha> it is a bit hard
01:01:55 <meesha> i have been trying to make sense of the example for past few month
01:02:06 <johnw> this is a tricky example
01:02:10 <meesha> however, lets get back
01:02:13 <meesha> to the function f
01:02:21 <meesha> it takes an input 'Char"
01:02:25 <meesha> and returns a parser
01:02:34 <meesha> but it also has to consume a string
01:02:50 <johnw> it is given the leftover from the last parse
01:02:50 <meesha> in order to produce parser (Char,CHar)
01:02:55 <meesha> yes
01:02:58 <meesha> whic his "bc"
01:03:01 <johnw> right
01:03:07 <meesha> so in the type definition
01:03:22 <meesha> we have ma -> (a -> m b) -> m b
01:03:50 <meesha> m a is Parser a
01:03:54 <meesha> which is Item
01:04:23 <meesha> (a -> m b) is this nested other thing
01:04:54 <meesha> and m b is [(Char,Char), String)]
01:05:07 <johnw> right
01:05:28 <johnw> [(a, String)] -> (a -> [(b, String)]) -> [(b, String)]
01:05:32 <meesha> so obviusly String' is passed to function f after item is executed with input String
01:05:46 <johnw> it's not passed to f
01:05:52 <johnw> it's passed to the function returned by f
01:06:32 <johnw> parse (f v) out
01:06:40 <johnw> not: parse (f v out)
01:06:51 <johnw> well, scratch that
01:06:54 <johnw> ignore what I just said entirely
01:07:07 <johnw> becasue you are using type synonyms and that would actually almost work
01:07:22 <johnw> and I don't want to go down that road
01:07:39 <meesha> I see, so String passing is implictly defined in the bind
01:07:47 <johnw> yes!
01:07:55 <johnw> the whole job of bind here is to do the house-keeping for you
01:08:03 <johnw> of managing the input and passing along of leftovers
01:08:16 <meesha> this is just so hard to wrap my head around
01:08:18 <meesha> than kyou
01:08:21 <johnw> your 'f' gets to focus only on the value just parsed
01:08:22 <meesha> i think i have some moments of clarity
01:08:42 <srhb> :)
01:08:48 <meesha> yess
01:08:55 <meesha> so parse (f v) is just
01:09:24 <meesha> applying the output string  to the function (f v)
01:09:32 <meesha> I see it
01:09:33 <johnw> yes!  parse (f v) out is "continuing the parse"
01:09:46 <johnw> until you encounter a parse that returns [], and then things stop
01:09:49 <meesha> I think i can sleep now
01:09:55 <meesha> yep
01:09:57 <meesha> that makes sense
01:10:24 <johnw> what is "monadic" about this is how bind lets you chain together a series of function that only care about WHAT was parsed, not HOW it was parsed
01:10:24 <meesha> so the expression (\a -> stuff inside) is just a function
01:10:32 <meesha> that takes character and returns a parser
01:10:38 <johnw> exactly
01:10:48 <meesha> ohh
01:10:54 <meesha> my infinite thanks
01:11:03 <meesha> this makes sense
01:11:31 <meesha> so than in this cain of functions
01:11:34 <meesha> the string is consumed
01:11:53 <meesha> so does it mean that the context is string?
01:11:55 <johnw> the parser returned by each function sees the remainder of input up to that point
01:11:59 <johnw> yes, the context is a string
01:12:11 <meesha> so does it mean that for all monads
01:12:23 <meesha> you consume context and return some value from the context and new context
01:12:31 <johnw> only monads that act like functions
01:12:37 <johnw> or I should say
01:12:38 <meesha> does not apply for IO
01:12:44 <johnw> only function types that present a Monad interface
01:12:55 <johnw> well, IO has other quirks
01:13:02 <johnw> but the Maybe monad certainly does not fall into your description
01:13:18 <meesha> so maybe has two values
01:13:22 <meesha> Nothing and Just a
01:13:28 <johnw> yes
01:13:43 <meesha> then the function that would work for maybe monad
01:13:48 <meesha> would take a maybe value
01:14:01 <meesha> say Maybe 2
01:14:15 <johnw> I would suggest sleeping on what you learned about your 'bind' at this point
01:14:20 <meesha> ok
01:14:21 <meesha> yep
01:14:24 <meesha> thank you again
01:14:24 <johnw> let's talk about Maybe after your dream state has sunk it in
01:14:29 <meesha> yes
01:14:30 <meesha> good idea
01:14:38 <meesha> thanks Johnw!!!!
01:14:45 <meesha> gtg
01:14:48 <meesha> cheers
01:14:53 <johnw> night!
01:14:57 * gfixler applauds
01:15:17 <gfixler> I'm having trouble with this: do { a <- sequence foo; print $ take 10 a }
01:15:29 <johnw> what trouble?
01:15:46 <gfixler> one sec, checking something...
01:16:08 <gfixler> foo :: [IO a]
01:16:46 <nshepperd> gfixler: if you're expecting it to execute only the first 10 actions, lazily, it won't do that
01:16:56 <gfixler> nshepperd: that was my question - am I hitting laziness?
01:17:00 <gfixler> because nothing prints out
01:17:18 <johnw> no, you shouldn't be hitting laziness
01:17:30 <johnw> is foo empty?
01:17:39 <gfixler> foo is an infinite list of random IO values
01:17:43 <nshepperd> gfixler: is foo an infinite list? then 'sequence foo' will run forever
01:17:44 <johnw> ah
01:17:45 <gfixler> random between two options
01:17:48 <johnw> sequence will never complete
01:17:52 <gfixler> ah ha
01:17:55 <nshepperd> yeah
01:17:57 <gfixler> that's what I was wondering
01:18:00 <gfixler> so now what do?
01:18:08 <gfixler> sequence!?
01:18:11 <nshepperd> sequence (take 10 foo)
01:18:16 <johnw> yep
01:18:48 <gfixler> hehe, that printed out [
01:18:51 <gfixler> and hung
01:19:19 <gfixler> do { a <- sequence (take 10 foo); print a }
01:19:22 <johnw> is foo defined by some kind of recursion?
01:19:22 <gfixler> for that
01:19:27 <gfixler> yes
01:19:30 <johnw> can I see?
01:19:46 <gfixler> it's a call to choose, which takes a list and gives you back !! (random of length)
01:20:08 <gfixler> and foo is just choose [0,1] : choose
01:20:19 <gfixler> sorry, choose [0,1] : foo
01:20:22 <johnw> it feels like something is self-referential here in a way that cannot produce values lazily
01:20:32 <gfixler> yeah, but I'm too newb to find it
01:20:36 <johnw> show me foo and choose?
01:20:47 <arkeet> you can sort of make it work, using unsafeInterleaveIO
01:20:52 <gfixler> foo is from the internet
01:20:55 <gfixler> choose :: [a] -> IO a
01:20:58 <gfixler> choose xs = do
01:20:58 <johnw> arkeet: I actually typed that, and deleted it :)
01:21:00 <gfixler>     i <- getStdRandom (randomR (0, length xs - 1))
01:21:01 <arkeet> heh
01:21:02 <gfixler>     return $ xs !! i
01:21:04 <gfixler> sorry, choose is
01:21:13 <gfixler> arkeet: I'd like to avoid unsafe, if possible
01:21:18 <johnw> gfixler: if xs is infinite, length will never end
01:21:23 <arkeet> heh
01:21:32 <gfixler> johnw: I don't think it is
01:21:37 <gfixler> foo = choose [0,1] : choose
01:21:42 <johnw> ahh
01:21:42 <gfixler> crap, sorry again
01:21:44 <gfixler> foo = choose [0,1] : foo
01:21:52 <johnw> ok
01:21:53 <gfixler> choose isn't infinite, but foo is
01:22:08 <gfixler> by the way, just so I'm not XY Probleming myself here
01:22:28 <johnw> that all looks fine to me
01:22:30 <gfixler> I'm trying to generate an infinite list of values I can choose from, because I've been having problems mixing getting random values and building lists
01:22:39 <gfixler> I probably need to learn about monad transformers/stacks
01:22:39 <johnw> can you try with sequence (take 1 foo)?
01:22:55 <gfixler> johnw: hangs
01:23:19 <johnw> now replace that with: choose [0,1]
01:23:21 <Zemyla> You know, there's a way to choose a random value from a list while only traversing the list once.
01:23:54 <gfixler> Zemyla: that's a Z problem - I gotta figure out this XY problem first :)
01:23:56 <arkeet> Zemyla: I had an interview question like that.
01:24:14 <gfixler> johnw: what am I replacing?
01:24:21 <johnw> sequence (take 1 foo)
01:24:25 <johnw> boil it down to what it's doing
01:24:32 <johnw> and keep boiling until you find where the hang occurs
01:24:37 <johnw> add "print" statements to debug at this point
01:24:43 <johnw> (in choose)
01:24:49 <arkeet> or trace calls
01:24:53 <johnw> or trace calls
01:25:00 <gfixler> ah
01:25:09 <gfixler> I forget I can drop in prints
01:25:11 <gfixler> it's so pythony
01:25:36 <nshepperd> gfixler: if you really need an infinite list of random values, the best way to do that is combining 'split' and 'randomRs' from System.Random
01:26:12 <gfixler> nshepperd: I toyed with the idea of making a type and instancing Random for it
01:26:22 <gfixler> felt a bit above me atm, though
01:26:44 <nshepperd> getStdRandom (\g -> let (s, g') = split g in (randoms s, g'))
01:26:47 <gfixler> I'd actually much prefer to just be able to call random on my type
01:27:01 <gfixler> though I'm not sure that fixes this sequence problem
01:27:35 <bennofs> gfixler: I think the idea is that you split your RNG, so you get one RNG you use for the rest of the program and one RNG that you can use for the list. This way, you don't need to finish evaluating the whole list to know the "seed" of the RNG for the rest of the program
01:28:01 <gfixler> bennofs: right, that part makes sense to me (and is cool)
01:28:23 <gfixler> nshepperd: what does that line do?
01:28:58 <gfixler> nshepperd: and should that last g' be a g?
01:29:07 <nshepperd> bennofs pretty well described what that line does
01:29:12 <gfixler> no, I guess it should be g'
01:29:57 <gfixler> :t randoms
01:29:58 <lambdabot> (RandomGen g, Random a) => g -> [a]
01:30:02 <gfixler> that's the bit I'm missing
01:30:25 <gfixler> well, one of them
01:30:44 <bennofs> :t getStdRandom
01:30:45 <lambdabot> (StdGen -> (a, StdGen)) -> IO a
01:30:51 <nshepperd> we split the RNG into s and g', use s to generate the list, and return g' to the global RNG store
01:31:19 <gfixler> nshepperd: does it generate an infinite list?
01:31:23 <nshepperd> yeah
01:31:25 <gfixler> oh
01:31:28 <gfixler> that's cool
01:31:38 <nshepperd> 'randoms' generates an infinite list of pseudorandom numbers *purely*
01:31:41 <gfixler> is it calling random over and over on its own?
01:31:43 <gfixler> ah
01:31:46 <gfixler> nice
01:32:44 <gfixler> "that is so purely pseudorandom" -future kid slang
01:32:47 <arkeet> > evalState (sequence . repeat . state $ \s -> (s,s+1)) 0
01:32:49 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
01:33:03 <nshepperd> yeah, something like randoms g = let (a, g') = random g in a : randoms g'
01:33:12 <gfixler> however
01:33:18 <gfixler> I need to define randomness for my type
01:33:20 <gfixler> no?
01:33:25 <gfixler> Random a
01:33:40 <arkeet> > evalState (sequence . repeat . state $ \g -> randomR (0,9) g) (mkStdGen 0)
01:33:42 <lambdabot>  [3,3,3,8,0,7,1,1,1,6,3,0,2,0,4,5,0,1,5,2,2,6,0,5,6,9,0,9,1,0,7,2,3,4,0,0,0,8...
01:34:02 <gfixler> that was my assumption, and it felt like another potential rabbit hole
01:34:41 <nshepperd> well, conceivably you could just write that yourself. myRandoms = let (a, g') = _choose g in a : randoms g'
01:35:02 <nshepperd> you just need something to go in the _choose spot
01:35:04 <gfixler> :t _choose
01:35:05 <lambdabot>     Found hole ‘_choose’ with type: t
01:35:05 <lambdabot>     Where: ‘t’ is a rigid type variable bound by
01:35:05 <lambdabot>                the inferred type of it :: t at Top level
01:35:29 <gfixler> nshepperd: right - I know I have to write my own random for my own type
01:35:42 <gfixler> I just felt like it would be a bit of a journey
01:35:48 <gfixler> I'm already on like 5 journeys
01:35:59 <gfixler> I don't even remember what the first one was about
01:36:02 <Zemyla> What type is it that you have to write Random for?
01:36:40 <gfixler> Zemyla: many different ones - I've needed this for a lot of ideas for many months now
01:36:53 <gfixler> sometimes existing types, often times things I make up as needed
01:37:28 <gfixler> although probably most fall into the a | b | c | d category
01:38:04 <gfixler> i.e. simple sum types
01:38:31 <gfixler> I was hoping I could just deriving (Enum, Ord) and get random for free, or similar
01:38:58 <gfixler> that doesn't seem like a crazy wish
01:39:11 <gfixler> deriving (Rand)
01:40:14 <gfixler> where I'd presume Rand derivability on all members and whatever sub-members in product types are called
01:40:22 <gfixler> sub-inhabitants?
01:40:52 <johnw> you mean the type indices?
01:41:05 <gfixler> data Foo = Bar a | Baz Int
01:41:08 <gfixler> the a and the Int
01:41:09 <johnw> (a, b) is a family of types indexed by a and b
01:41:36 <johnw> data Foo a = Bar a | Baz Int
01:41:40 <gfixler> if I'm going to randomly choose a Foo, I need to pick Bar or Baz, and then a random a or Int
01:41:47 <johnw> I'd just say the type of the constructor's argument
01:41:50 <gfixler> johnw: sorry, yes
01:41:55 <gfixler> ok
01:42:06 <johnw> gfixler: what you're describing sounds like what Arbitrary does
01:42:07 <gfixler> does it even make sense that these could be derived?
01:42:15 <gfixler> johnw: ah ha
01:42:25 <gfixler> deriving (Arbitrary)
01:42:28 <gfixler> :)
01:43:02 <gfixler> whoa http://hackage.haskell.org/package/derive-0.1.1/docs/Data-Derive-Arbitrary.html
01:43:06 <johnw> import Data.DeriveTH
01:43:07 <johnw> derive makeArbitrary ''Foo
01:43:23 <gfixler> aw, template haskell?
01:43:33 <johnw> how else did you want compile-time generation of instances?
01:43:42 <gfixler> how does deriving work?
01:43:49 <gfixler> magics?
01:43:51 <fizruk> hello everyone! does anyone know of an open source (game) project using netwire 5?
01:43:54 <johnw> magic in GHC
01:43:56 <gfixler> ah
01:43:57 <nshepperd> GHC.Generics
01:44:16 <johnw> well, the Generics route would require that Arbitrary offered Generics-based defaults
01:44:29 <nshepperd> I'm surprised there isn't a default definition for Random in terms of Generics
01:44:30 <johnw> and then it would work
01:44:36 <nshepperd> a bit
01:44:57 <fizruk> one of the problems I have is that I can't figure out how to use Events, it seems there is no way to destruct/fold Event: https://hackage.haskell.org/package/netwire-5.0.1/docs/Control-Wire-Event.html
01:45:06 <gfixler> would what you're both talking about in theory work on types defined with data?
01:45:25 <johnw> gfixler: oh, hey: http://hackage.haskell.org/package/regular-0.3.4
01:45:34 <johnw> "This package provides generic functionality for regular datatypes."
01:45:48 <fizruk> so from my point of view that renders Event quite useless. but perhaps I'm missing something
01:46:16 <gfixler> johnw: interesting
01:46:28 <johnw> in regular-extrtas
01:46:37 <johnw> you'll find a way of generating Arbitrary instances using regular
01:47:02 <johnw> so that looks like what you want, without template haskell
01:47:17 <gfixler> johnw: or I could just learn how to define random for types
01:47:21 <gfixler> if it's not all that hard
01:47:29 <johnw> by way of another construction (Reguglar) giving you defaults based on GHC.Generics, with an explicit tie in to Arbitrary
01:47:46 <srhb> fizruk: What about the accums?
01:47:51 <johnw> gfixler: or that
01:48:01 <johnw> gfixler: it's going to be very boilerplatey
01:48:10 <gfixler> johnw: ew
01:48:39 <gfixler> I'd love to work mostly on pure things, but almost everything I want to do is game-like, IO-heavy monstrosities
01:48:40 <gfixler> so torn
01:48:49 <johnw> boilerplate is really only truly bad if the types aren't strong enough to make boredom-induced slip-ups into errors
01:49:07 <johnw> make the game logic pure
01:49:12 <johnw> i doubt a game needs much real IO
01:49:17 <fizruk> srhb: they can take me from Event a to Event b, but I want to get behaviour (e.g. Wire s e m a b) out of an event (e.g. Wire s e m a (Event b))
01:49:32 <gfixler> johnw: that's a burning question in my brain
01:49:52 <johnw> but don't ask me, I'm not a games designer
01:49:54 <johnw> ask stepcut
01:49:59 <johnw> or Cale
01:50:02 <johnw> they've been doing that for years
01:50:05 <fizruk> srhb: perhaps it's not meant to be used that way. but then I don't understand what Events are used for.
01:50:11 <gfixler> isn't #haskell-games a thing?
01:50:20 <johnw> sure sounds like it should be
01:50:58 <fizruk> gfixler: it's #haskell-game
01:51:03 <gfixler> whoops
01:51:13 <gfixler> yeah, #haskell-games didn't exist, and I logged out by accident
01:51:29 <johnw> playing the Haskell game: rearrange type variables until the errors go away
01:51:47 <gfixler> oy, tell me about it
01:51:54 <gfixler> this random thing has been fighting with me for 3 days
01:52:00 <gfixler> I can't seem to get around it
01:52:06 <gfixler> IO infects everything it touches
01:52:09 <johnw> yeah, that's Haskell for you
01:52:25 <johnw> but there's light beyond this
01:52:28 <gfixler> IO is like Tiberium
01:52:36 <johnw> I remember the "hours long type errors, IO everywhere" days
01:52:44 <gfixler> ooh, that sounds hopeful
01:52:53 <johnw> gfixler: I'm using a language now that has no IO, period
01:52:56 <johnw> it changes your thinking
01:53:03 <elith_> which language?
01:53:06 <johnw> Coq
01:53:07 <gfixler> yeah, which?
01:53:09 <gfixler> hmmm
01:53:12 <gfixler> hardcore
01:53:20 <johnw> I'm writing code for a compiler, but I get no IO
01:53:28 <johnw> turns out, I don't need any either
01:53:45 <gfixler> does this mean you need to encode all values into the program?
01:54:06 <johnw> i take a data structure as input, and I yield a set of structures as output
01:54:15 <johnw> my caller has to do the IO to generate the data, and then to write it out after
01:54:38 <johnw> but I must say, it changed my approach to Haskell
01:54:44 <gfixler> +5 to ambiguity
01:55:01 <johnw> I used to write code that was 95-99% monad-transformers-over-IO
01:55:23 <gfixler> the caller sounds like main
01:55:23 <johnw> but it turns out that was my pre-Haskell bias affecting my thinking
01:55:49 <gfixler> I haven't even gotten to transformers yet :(
01:56:04 <gfixler> I'm still using monad gobots
01:57:03 <nocturne777> could anyone tell me how I can evauluate if a function is strict or not?
01:57:28 <Zemyla> Also, why do you need a custom Random if you need to select a random value from a list?
01:57:34 <nocturne777> there's the seq function and undefined 
01:57:45 <gfixler> Zemyla: I don't need to do that - that's my current workaround
01:57:59 <alpounet> nocturne777: maybe this may help? http://alpmestan.com/posts/2013-10-02-oh-my-laziness.html
01:58:08 <mniip> semantics-wise, is 'f ~(Just x) = ...' the same as 'f z = let x = case z of { Just x -> x; _ -> undefined } in ...'
01:58:14 <gfixler> Zemyla: if I have data Foo = Bar | Baz, I'd rather random Foo than choose [Bar,Baz]
01:58:22 <johnw> gfixler: with your random thing, instead of worrying about generating random data, just take as input a function Monad m => (Int,Int) -> m Int, and don't think about the IO involved.  All you need is a number sequence, assume for your sake that 'm' is just Identity for all you know
01:58:34 <johnw> and then, try to constrain where you actually need 'm' to the least surface possible
01:58:56 <Zemyla> You can make a choose function that doesn't require IO.
01:59:15 <Zemyla> It does require a random generator passed into it, but it doesn't require IO or any other monad.
01:59:20 <gfixler> johnw: whoa, this is intriguing
02:00:28 <nocturne777> alpounet: tnx for the link
02:01:03 <johnw> defer effects to your caller, and minimize their use, and you'll find that you naturally tend to build pure cores that are orchestrated from an overseer function that is often just "main"
02:01:38 <solatis> what benefit does making your module Trustworthy add? as far as i understand, it is a totally subjective thing that is not enforced by the compiler in any way, right?
02:01:46 <johnw> Coq forced me into that model, but it works nicely in Haskell as it turns out; just requires a bit of extra abstraction in a few places
02:01:54 <solatis> can other people make Safe modules that use Trustworthy modules?
02:02:01 <srhb> nocturne777: I think it makes more sense to talk about strictness in the sense of arguments. So a function f  is strict in its first argument if f x evaluates x. (Someone may correct me here)
02:02:20 <johnw> f is strict in its first argument if f ⊥ = ⊥
02:02:24 <gfixler> johnw: exciting - I've been preaching higher order functions, and deferring effects to callers, but haven't really made the leap to deferring effects to callers via higher order functions
02:02:34 <johnw> gfixler: nice! :)
02:02:58 <johnw> functions-as-values is an incredibly rich field that still has many gems to offer
02:03:08 <gfixler> and it fits my favorite style of learning, which I've nicknamed "One More Thing"
02:03:38 <gfixler> the standard style in the wild I call "One Thing, Two Thing, Every Thing"
02:03:49 <gfixler> where slides 1-3 are nice, baby steps, and slide 4 is the haskell report
02:04:02 <nshepperd> huh, Data.RVar doesn't have any 'randoms' function built in
02:04:30 <nshepperd> but, randoms r g = evalState (sequence $ repeat $ runRVar r StdRandom) g
02:04:48 <srhb> gfixler: That's cute. :-)
02:04:51 <johnw> gfixler: good night, and good luck :)
02:04:52 <nshepperd> works for any RVar
02:04:56 <gfixler> johnw: thanks so much!
02:05:15 <gfixler> srhb: and everywhere - I'm constantly saying "Well, 10 minutes in and this tech talk is done for me."
02:05:24 <srhb> Hehe
02:05:46 <gfixler> srhb: I have a theory that people carefully create 3 slides, then forget until the last minute about their presentations
02:05:53 <gfixler> and jam everything into the next 5 slides
02:06:01 <srhb> That's how I work at least. :-)
02:06:18 <gfixler> srhb: alternate theory: 3 slides is a lot of work, and they realize it's going to be 400 slides at this rate
02:06:42 <gfixler> (my git talk was 360 slides!)
02:06:48 <srhb> In my case, the first three slides are usually where I still think it's fun really crafting slides well.
02:06:58 <gfixler> srhb: :)
02:09:31 <gfixler> srhb: I have such fun ideas for easing slide/presentation creation, but I need to learn more Haskell first
02:09:50 <srhb> gfixler: Sounds great!
02:09:52 <gfixler> srhb: and possibly forget, and just spend the rest of my life learning more Haskell
02:10:07 <srhb> Everyone will be understanding if that happens. :-)
02:10:17 <srhb> Well, not _everyone_, but hEveryone
02:10:31 <gfixler> srhb: I might just learn Coq so I can prove that I could have created a great slide creation tool
02:10:39 <gfixler> that might be enough
02:11:00 <srhb> ... "but the margin is too narrow to contain it@
02:11:04 <merijn> gfixler: pandoc can generate slides and hacking pandoc doesn't require too advanced haskell skillz
02:11:48 <gfixler> merijn: I'll have to look into it, but this would be a live orchestration, not a processor you feed thing into
02:16:00 <lpaste> Zemyla pasted “Random choice for gfixier” at http://lpaste.net/130577
02:16:40 <gfixler> whoa, presents
02:26:09 * hackagebot streaming-commons 0.1.11 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.11 (MichaelSnoyman)
02:26:11 * hackagebot conduit-extra 1.1.7.2 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.7.2 (MichaelSnoyman)
02:31:09 * hackagebot orgmode-parse 0.1.0.1 - A collection of Attoparsec combinators for parsing org-mode  flavored documents.  http://hackage.haskell.org/package/orgmode-parse-0.1.0.1 (ParnellSpringmeyer)
02:33:02 <Zemyla> gfixler: I have randomR and random defaults for Bounded Enum instances, too.
02:34:06 <gfixler> Zemyla: oh?
02:34:28 <lpaste> Zemyla pasted “Random Enum for gfixier” at http://lpaste.net/130578
02:35:19 <Zemyla> And then it's basically instance Random Foo where { randomR = randomREnum; random = randomEnum }
02:35:31 <Gurkenglas> @hoogle Int -> Lens' [a] a
02:35:34 <lambdabot> Warning: Unknown type Lens'
02:35:34 <lambdabot> No results found
02:35:59 <gfixler> Zemyla: thanks - I'll have to chew on these tomorrow - it's almost bedtime tonight
02:36:05 <Zemyla> Okay, then.
02:36:09 <Zemyla> Godspeed.
02:36:09 * hackagebot orgmode-parse 0.1.0.2 - A collection of Attoparsec combinators for parsing org-mode  flavored documents.  http://hackage.haskell.org/package/orgmode-parse-0.1.0.2 (ParnellSpringmeyer)
02:36:11 * hackagebot ekg-core 0.1.0.4 - Tracking of system metrics  http://hackage.haskell.org/package/ekg-core-0.1.0.4 (JohanTibell)
02:36:12 <gfixler> much appreciated!
02:49:46 <mniip> hold on, if MaybeT is m (Maybe a)
02:49:52 <mniip> wouldn't ReaderT be m (r -> a)
02:50:26 <bennofs> mniip: yes, but it turns out that it is easy to convert from m (r -> a) to r -> m a
02:50:34 <bennofs> mniip: but not the other way around
02:50:52 <bennofs> mniip: so having r -> m a is strictly more useful, since you can use it for more values
02:50:54 <mniip> yeah the first one is ap
02:51:10 * hackagebot orgmode-parse 0.1.0.3 - A collection of Attoparsec combinators for parsing org-mode  flavored documents.  http://hackage.haskell.org/package/orgmode-parse-0.1.0.3 (ParnellSpringmeyer)
02:51:15 <bennofs> mniip: it would be fmap ap . pure
02:51:20 <bennofs> :t fmap ap . pure
02:51:21 <lambdabot> (Monad m, Applicative f) => m (a -> b) -> f (m a -> m b)
02:51:25 <bennofs> or not
02:51:31 <shachaf> bennofs: Isn't that backwards?
02:51:42 <bennofs> :t \f x -> ap f (pure x)
02:51:43 <lambdabot> Monad m => m (a -> b) -> a -> m b
02:51:54 <mniip> :t liftM . flip id
02:51:55 <lambdabot> Monad m => b -> m (b -> r) -> m r
02:51:58 <shachaf> Oh, I guess it depends on how you meant what you said.
02:51:59 <mniip> ugh
02:52:05 <shachaf> Anyway, the answer to the "if-then" question is no.
02:52:06 <mniip> flip that
02:52:17 <mniip> so yeah
02:52:31 <mniip> some transformers add onto the inside, and some add onto the outside?
02:52:37 <shachaf> Monad transformers don't work that way.
02:52:52 <shachaf> They can be whatever you want. They aren't just defined by composition.
02:53:07 <ddellacosta_> just found this in functional programming pearls:  filter p . map f = map f . filter (p . f)  ...anyone know where I can find a proof/discussion/etc. of this, or just more about this kind of higher-level function composition in general?
02:53:33 <ddellacosta_> (er, "pearls of functional algorithm design" rather)
02:54:30 <mniip> ddellacosta_, do you need a strict proof, or
02:55:04 <ddellacosta_> mniip: not really, although would be interesting in seeing one.  I'm just more looking to build more intuition about how composition works with higher-level functions.
02:55:15 <hjulle> ddellacosta_, I believe It's pretty easy to prove it yourself using the definitions.
02:55:27 <mniip> neither of those compositions are high-level
02:55:45 <ddellacosta_> mniip: filter and map are both higher-level functions, no?
02:55:56 <ddellacosta_> hjulle: you are assuming a lot about my knowledge and abilities I suspect. :-)
02:55:58 <hjulle> *higher order
02:55:58 <mniip> yeah but 'map f' and 'filter p' aren't
02:56:12 <ddellacosta_> hjulle: oh thanks, higher-order I mean
02:56:29 <mniip> @pointful filter p . map f
02:56:29 <lambdabot> (\ c -> filter p (map f c))
02:56:42 <mniip> @pointful map f . filter (p . f)
02:56:42 <lambdabot> (\ c -> map f (filter (\ g -> p (f g)) c))
02:57:23 <ddellacosta_> mniip: hmm, I see what you're saying, but the relationship between the right and left sides implies to me (and this is what I want to know if I'm wrong or right on) that there is something important going on there in terms of how filter and map interact with each other
02:57:31 <hjulle> ddellacosta_, Do you understand on an intuative level why it should be true?
02:57:59 <ddellacosta_> hjulle: I understand in the sense that I've run it in ghci a few times with different examples and see that it does work consistently
02:58:07 <mniip> ddellacosta_, the first applies f to every element in the list, and then filters the results using p
02:58:31 <mniip> the second filters the list by applying f and then checking with p; and then applies f to the remainders
02:59:34 <ddellacosta_> mniip: I understand literally how they work; what I'm looking for is more something that is describing a mathematical relationship between map and filter, or higher-order functions with the same relationship in terms of each of their type signatures
02:59:56 <mniip> well
03:00:10 <hjulle> :t \p f -> (filter p,map f, filter p.map f, map f . filter (p . f))
03:00:11 <lambdabot> (b -> Bool) -> (a -> b) -> ([b] -> [b], [a] -> [b], [a] -> [b], [a] -> [b])
03:00:47 <mniip> forall foo :: forall a b. [a] -> [b] 
03:00:50 <mniip> er
03:00:58 <mniip> I should have used a text editor instead
03:01:34 <kadoban> I wonder if it would be illustrative to look at the definitions of each, in terms of foldr?
03:01:48 <mniip> yeah, can't go so much foralld
03:02:11 <ddellacosta_> kadoban: yeah, that sounds promising...
03:02:29 <mniip> ddellacosta_, try joining the definitions of 'filter p' and 'map f'
03:03:29 <kadoban> map f = foldr (\x y -> f x : y) []         filter p = foldr (\x y -> if p x then x : y else y) []       I would assume that has quite a bit to do with the ability to muck about with them, but … too late in the night for me to figure out beyond that.
03:03:48 <dshad> kadoban: in monad.reader 6 described how to implement fixed point combinator with only foldr and repeat
03:03:57 <mniip> foo [] = []; foo (x:xs) = let r = f x in if p r then r:foo xs else foo xs
03:04:04 <dshad> so you can implement foldr and repeat any recursive function
03:04:14 <mniip> if we implement the RHS,
03:04:50 <mniip> foo [] = []; foo (x:xs) = if (p . f) x then f x:foo xs else foo xs
03:04:56 <mniip> now do you see why are they equal?
03:06:11 * hackagebot http-client 0.4.11.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.11.1 (MichaelSnoyman)
03:06:13 <hjulle> So the predicate p :: b -> Bool and f :: a -> b. If you got a list of type [a], you need to convert the elements to type b if you want to filter them with p. Thus the two ways to get a function [a] -> [b] which filters with p is: map f . filter (p . f) or filter p . map f. The next question to think of is if they are equal.
03:06:26 <haskeller5> I am trying to get rid of parens in this definition: let sequenceA = foldr (liftA2 (:)) (pure []). I thought let sequenceA = foldr $ liftA2 (:) $ pure [] should work but it doesn't. What am I missing?
03:06:57 <shachaf> haskeller5: $ is right-associative
03:07:59 <dshad> can somebody explain why my program with existential quantification doesn't compile http://lpaste.net/130580
03:09:54 <haskeller5> shachaf: Right, forgot about that. So how would I do this then?
03:10:09 <shachaf> The way you wrote it is fine.
03:10:19 <shachaf> I mean, with the parentheses.
03:11:17 <jle`> you can take off one with foldr (liftA2 (:)) $ pure [], but...that's probably a lot less readable than the original version
03:11:31 <jle`> parentheses are your friends
03:11:33 <jle`> :)
03:12:08 <haskeller5> All right, thanks! Do you happen to know of any resources where one can exercise the dot, dollar and parentheses in haskell?
03:12:27 <jle`> alternatively you can pull them out into a separate let/where binding, let la2c = liftA2 (:); pnil = pure [] in foldr la2c pnil
03:12:59 <jle`> i think it might be a little too small of a subject for exercises.  when reasoning with them just use manual evaluation
03:13:03 <jle`> @src ($)
03:13:03 <lambdabot> f $ x = f x
03:13:05 <jle`> @src (.)
03:13:06 <lambdabot> (f . g) x = f (g x)
03:13:10 <jle`> following those will never fail you
03:13:33 <jle`> you really shouldn't sacrifice readability for less parentheses, either
03:13:41 <shachaf> My main tip for ($) is to use it less.
03:13:45 <jle`> if the immediately obvious version has parentheses, then that's better
03:13:51 <haskeller5> Right, I just want to train my intuition but I guess I'll just have to do it by reading and writing more code. :)
03:13:53 <shachaf> People use it too much, especially when they first learn about it.
03:14:15 <haskeller5> Interesting, thanks for the hint!
03:15:54 <hjulle> @src map
03:15:54 <lambdabot> map _ []     = []
03:15:54 <lambdabot> map f (x:xs) = f x : map f xs
03:16:02 <hjulle> @src filter
03:16:03 <lambdabot> filter _ []     = []
03:16:03 <lambdabot> filter p (x:xs)
03:16:03 <lambdabot>     | p x       = x : filter p xs
03:16:03 <lambdabot>     | otherwise = filter p xs
03:19:20 <hjulle> Which is preferable of "f . g . h $ x" or "f $ g $ h $ x"?
03:19:34 <mauke> the former
03:19:48 <hjulle> Or perhaps "f (g (h x))"?
03:19:55 <mniip> I always use the latter
03:20:10 <mniip> especially if f, g, and h are longer than one letter
03:20:36 <hjulle> Yay! Strong opinions, no concensus.
03:20:52 <shachaf> You should go with whatever mauke says.
03:21:15 <mauke> I often use f (g (h x)) but I'm allergic to ))))))))
03:21:20 <hjulle> shachaf, Is that a general rule? ;)
03:21:27 <mniip> well, when working with forall'd types, . might cease to work
03:21:30 <mauke> hjulle: I follow it all the time
03:21:43 <mniip> whilst $ continues to work as it has a special typechecking rule
03:21:44 <hjulle> :D
03:21:56 <mauke> f . g . h $ x is preferable because it has more extractable subexpressions
03:22:23 <mniip> "extractable subexpressions"?
03:22:32 <mauke> i.e. I could take f . g, g . h, or f . g . h and give them their own name
03:22:45 <mniip> hm
03:22:55 <mauke> let gh = g . h in f . gh $ x
03:22:57 <hjulle> I forgot about the fourth alternative: "f . g $ h x"?
03:23:02 <mauke> for example because I need gh elsewhere
03:23:14 <bennofs> mauke: depends on whether your prefer to extract from the end or from the beginning
03:23:26 <mniip> well, 'g . h' isn't a particularly useful value to let-bind
03:23:37 <bennofs> mauke: from f $ g $ h x, you can also extract h x or g $ h x
03:23:43 <shachaf> bennofs: You can still "extract" "g . h $ x"
03:23:57 <bennofs> hmm, right
03:24:08 <mauke> :t \rule xs -> do let { ys = map rule xs }; guard (any isJust ys); return (zipWith fromMaybe xs ys)
03:24:09 <lambdabot> (Monad m, Alternative m) => (c -> Maybe c) -> [c] -> m [c]
03:24:31 <mauke> :t \rule xs -> do let { ys = map rule xs }; guard (any isJust ys); Just (zipWith fromMaybe xs ys)
03:24:32 <lambdabot> (c -> Maybe c) -> [c] -> Maybe [c]
03:24:40 <mauke> is there a better way to write that?
03:24:54 <hjulle> It's easier to eta reduce on the form f . g . h $ x.
03:25:56 <mniip> mauke, if you're referring to the 'let ys', it's very much different than 'let gh =  g . h'
03:26:17 <mauke> huh?
03:26:37 <mniip> was that a counterargument attempt or a real question?
03:26:55 <mauke> a real question
03:27:02 <mauke> the code doesn't even contain . or $
03:27:04 <mniip> okee then
03:28:19 <mniip> mauke, would mapMaybe help?
03:28:44 <mniip> or am I misinterpretting the function
03:28:59 <shachaf> The question is pretty clearly specified. You have a full implementation.
03:29:12 <shachaf> I wonder what the function is for, though.
03:29:13 <mniip> I see
03:29:17 <jle`> ot
03:29:50 <mauke> shachaf: I'm transforming a tree with a list of rules
03:29:51 <jle`> it's nice when (f . g) is something meaningful, for example.  and it's associative too, so you can do some nice things with that.
03:30:19 <jle`> also things like fmap f . fmap g $ x turning into fmap (f . g) x is clearer with the (.)-way
03:30:35 <hjulle> If any of the rules match, return Just the transformed list, with defaults from xs, otherwise return Nothing, is my interpretation of the source.
03:30:37 <mauke> shachaf: a rule can match (and return Just result) or fail (and return Nothing)
03:30:49 <mniip> hjulle, yeah, mine too, now
03:31:00 <jle`> it's nicer to recognize meaingful units of (.)'s and things, like the fmap f . fmap g case.   but yeah, with forall'd types things will stop working
03:31:27 <mniip> jle`, I, for one, have to issues with substituting $ with . in my head
03:31:31 <mauke> shachaf: this code is part of the definition of recursive rule application. if any of the children were transformed, we succeed overall. if none of the children were transformed, we fail
03:31:43 <mniip> to see things like 'fmap f $ fmap g $ x' => 'fmap (f . g) x'
03:31:43 <jle`> what do you mean by substituting $ with . ?
03:32:02 <jle`> i think fmap f . fmap g $ x => fmap (f . g) x is pretty clear
03:32:08 <mccn> what's wrong with my fib? ghci hangs when I use it. http://pastebin.com/Z8cs3KbQ
03:32:12 <jle`> because the former is just (fmap f . fmap g) x, which is fmap (f . g) x
03:32:16 <mniip> yeah but for me, with $ it's not any less clearer
03:32:25 <shachaf> mauke: Maybe something like "\rule xs -> let { ys = map rule xs } in [zipWith fromMaybe xs ys | any isJust ys]" (with MonadComprehensions) is clearer.
03:32:40 <shachaf> Maybe not, it's just rephrasing it.
03:32:52 <mauke> mccn: parens where they're redundant and no parens where they're needed
03:33:11 <mniip> mccn, function application binds tighter than -
03:33:19 <hjulle> mccn, (fib n - 2) is interpreted as ((fib n) - 2)
03:33:58 <hjulle> You want: fib (n - 2) + fib (n - 1)
03:33:59 <mauke> shachaf: isJust bothers me
03:34:08 <mccn> thanks guys, that was it
03:34:22 <shachaf> mauke: Yep.
03:34:37 <shachaf> So does any, to some degree. :-)
03:35:09 <hjulle> mccn, You should note that this implementation is extremely slow and recalculates the same number many times though.
03:35:29 <mniip> mauke, guard (null $ catMaybes ys)
03:35:46 <mniip> or would that be, not . null
03:36:03 <mauke> that's any isJust, only obfuscated
03:36:07 <mniip> yes
03:37:03 <mccn> you're right hjulle, but I'm a beginner importing some exercise definitions to ghci. I'll try to optimize it once I learn a bit more
03:37:13 <mauke> :t isJust . find isJust
03:37:14 <lambdabot> Foldable t => t (Maybe a) -> Bool
03:37:18 <Gurkenglas> :t nim -- You can now play NIM against lambdabot! Until someone does @undefine. The list represents piles of straw; players alternatingly take any positive integer of straws from one pile. You choose starting pile sizes, he goes first. Or you pretend to have gone first. http://lpaste.net/130587 is the source, code comments and suggestions welcome.
03:37:19 <lambdabot> [Int] -> Doc
03:37:19 <mauke> if we're being silly
03:37:34 <Gurkenglas> Oh right, the last player to take a straw wins.
03:37:59 <hjulle> mccn, That example is an excilent one for that. :)
03:38:44 <mauke> hah. how evil would it be to make my functions take Maybe Foo though they're always applied to Just x?
03:39:12 <mniip> mauke, Just evil
03:39:15 <shachaf> Moderately evil.
03:39:23 <mauke> currently they all start with \e -> do Pattern x <- return e; ...
03:40:08 <hjulle> mniip, XD
03:41:56 <hjulle> > nim [1..7]
03:41:57 <lambdabot>  I concede.
03:41:59 <shachaf> mauke: I've had similar problems before (to the any isJust thing), and I don't know what the best way to do it is.
03:42:30 <shachaf> It's the sort of behavior you might want a monad for that would have the opposite behavior of Maybe, but that doesn't really make sense.
03:42:44 <shachaf> Maybe passing success and failure continuations in some way can express it.
03:43:19 <hjulle> MonadPlus?
03:44:36 <Gurkenglas> Was that the first one you tried?
03:44:42 <whitesn> would someone give me simple example to use do clause in haskell?
03:44:46 <hjulle> shachaf, The MonadPlus instance of Maybe is what I think of when I hear anti-Maybe.
03:45:02 <mauke> > do "hi"
03:45:04 <lambdabot>  "hi"
03:45:43 <hjulle> > do "hi"; "there"
03:45:45 <lambdabot>  "therethere"
03:46:33 <Gurkenglas> *hjulle
03:46:52 <hjulle> ?
03:47:01 <whitesn> > do x <- length
03:47:02 <lambdabot>      The last statement in a 'do' block must be an expression
03:47:02 <lambdabot>        x <- length
03:47:08 <whitesn> > do x <- length [1,2,3]
03:47:09 <lambdabot>      The last statement in a 'do' block must be an expression
03:47:09 <lambdabot>        x <- length [1, 2, 3]
03:47:11 <whitesn> > do x <- length [1,2,3]; x
03:47:13 <lambdabot>      Couldn't match expected type ‘m (m b)’ with actual type ‘Int’
03:47:13 <lambdabot>      In a stmt of a 'do' block: x <- length [1, 2, 3]
03:47:13 <lambdabot>      In the expression:
03:47:23 <hjulle> > do x <- length [1,2,3]; return x
03:47:24 <lambdabot>      Couldn't match expected type ‘m b’ with actual type ‘Int’
03:47:25 <lambdabot>      In a stmt of a 'do' block: x <- length [1, 2, 3]
03:47:25 <lambdabot>      In the expression:
03:47:25 <Gurkenglas> hjulle, was [1..7] the first one you tried?
03:47:43 <shachaf> Please experiment with lambdabot in /msg.
03:47:52 <whitesn> oh sorry
03:47:55 <mniip> > do x <- "hello"; ['<', x, '>']
03:47:56 <lambdabot>  "<h><e><l><l><o>"
03:48:32 <Gurkenglas> Moderately spamming lambdabot in this channel is moderately fine as long as you don't do any mistakes.
03:48:59 <mniip> whitesn, how good are you at monads
03:49:25 <hjulle> > "hello" >>= (\x -> ['<', x, '>']) -- equivalent to mniip's code.
03:49:26 <lambdabot>  "<h><e><l><l><o>"
03:49:47 <mauke> > concatMap (\x -> ['<', x, '>']) "hello"
03:49:48 <mniip> Gurkenglas, to some moderate extent
03:49:48 <lambdabot>  "<h><e><l><l><o>"
03:49:57 <mauke> > concat (map (\x -> ['<', x, '>']) "hello")
03:49:58 <lambdabot>  "<h><e><l><l><o>"
03:50:33 <mniip> > concatMap (('<':) . (:">")) "hello"
03:50:34 <lambdabot>  "<h><e><l><l><o>"
03:50:35 <mauke> > join (liftM (\x -> ['<', x, '>']) "hello")
03:50:36 <lambdabot>  "<h><e><l><l><o>"
03:50:45 <whitesn> mniip: only ever heard it, not sure what is it
03:50:45 <shachaf> Gurkenglas: The things you've been doing with lambdabot are probably going too far.
03:51:12 <mniip> whitesn, then go figure out monads first, 'do' is all about monads
03:51:13 <Gurkenglas> Who is harmed?
03:51:44 <hjulle> Gurkenglas, Yes, how so?
03:51:58 <mniip> (except for when no semicolons, newlines or <- are involved, in which case do is rather useless)
03:52:00 <mauke> you can figure out 'do' without monads
03:52:18 <mauke> it's syntactic sugar for calls to >>= and >>
03:52:38 <mniip> yeah but >>= and >> make little sense to someone who doesn't know monads
03:52:54 <mauke> even then, you can't just "learn monads" in order to understand >>=
03:53:10 <mauke> you have to start with a particular type's >>=
03:53:11 <mniip> hence "figure out"
03:53:28 <mauke> then another >>=, then a third >>=, and then you might see a pattern
03:55:12 <mauke> @hoogle (a -> Maybe b) -> [a] -> Maybe ([a], b, [a])
03:55:14 <lambdabot> No results found
03:58:32 <shachaf> mauke: Did you see byorgey and dpiponi's paper about making types that match regular expressions?
03:59:36 <mauke> no
03:59:46 <shachaf> https://github.com/byorgey/type-matrices
03:59:55 <shachaf> I don't think a PDF is available yet, though.
04:00:05 <dshad> is there somebody who understands Typeable and ExistentialQuantification?
04:00:25 <shachaf> There exists a person of that type.
04:01:57 <dshad> I had got compilation error when I tried to use them http://lpaste.net/130580
04:02:32 * mauke sighs
04:02:35 <dshad> can somebody who understands explain what's wrong with my program
04:02:55 <shachaf> Apparently what's wrong is that it doesn't compile.
04:03:21 <adamse> dshad: please include whatever error message you get
04:03:21 <Gurkenglas> @letlpaste 130580
04:03:22 <lambdabot>  .L.hs:176:9:
04:03:22 <lambdabot>      No instance for (Typeable b0) arising from a use of ‘strange’
04:03:22 <lambdabot>      In the expression: strange myId
04:05:13 <dshad> adamse: included error message in file on hpaste
04:06:08 <mauke> it doesn't know which instance of Typeable to use
04:09:26 <mauke> even ignoring dictionaries, the crucial point is line 15
04:09:36 <mauke> it has to know which branch to take, line 16 or line 17
04:10:16 <mauke> this depends on whether the existential type hidden in old is the same as the 'a' that f takes
04:10:16 <dshad> mauke: oh, I see
04:10:23 <dshad> thx
04:11:18 <mauke> our f is myId :: (Typeable a) => a -> a, which leaves 'a' open
04:14:40 <jedai> Anyone here installed GLUT recently ? I'm getting a bit tired of "Missing C library : glut32" after having tried glut2.7 and freeglut in every combination I could imagine, placing the .dll on the path and the lib and include in path I gave with --extra-*-dirs...
04:16:05 <shwouchk> I keep seeing '$' in a book I'm reading, and I didn't find where the notation was defined. Anyone care to explain?
04:16:14 <mauke> @src ($)
04:16:14 <lambdabot> f $ x = f x
04:16:38 <mauke> or are you reading a Perl book?
04:16:48 <mauke> or economics
04:16:59 <jedai> installed GLUT on Windows with minghc
04:17:50 <shwouchk> mauke: :) 
04:17:51 <Gurkenglas> The operator also separates its sides very strongly, to help reduce the number of brackets, for example "f $ g x" vs "f (g x)"
04:18:32 <shwouchk> Gurkenglas: ah! very good, thanks
04:18:37 <shwouchk> mauke: thanks
04:20:13 <shwouchk> Gurkenglas: 'very strongly' is a technical term? :) So is *everything, always* that comes to the right of it equivalent to being in parens?
04:20:31 <srhb> shwouchk: Usually we would say it has very low precedence
04:20:57 <shwouchk> srhb: not very high?
04:21:01 <bennofs> What do you think of instance NFData a => NFData (IORef a) where rnf ref = rnf (unsafePerformIO $ readIORef ref)? Is the unsafePerformIO here safe?
04:21:14 <bennofs> (This is useful for criterion for example)
04:21:27 <hjulle> :i $
04:21:30 <srhb> shwouchk: No, very low indeed. :)
04:21:38 <hjulle> infixr 0 $
04:21:58 <shwouchk> srhb: ah, I guess precedence is counted low-> high rather than the other way?
04:22:20 <srhb> shwouchk: (binds strongly == high precedence. Separates strongly == low precedence, in the parlance Gurkenglas used)
04:22:28 <Gurkenglas> The highest precedence is resolved first - for example, function application has very high precedence, so the f $ g x has the right part collapsed first
04:23:16 <Peaker> bennofs: it makes it possible to be affected by an IORef in pure code, that would otherwise be impossible.. writeIORef fooRef (error "Nobody should ever see this) ; return $ pureCode fooRef  <-- pureCode should be able only to use the Eq instance of the IORef
04:23:19 <Peaker> but now it can read the IORef and see the error :(
04:23:50 <bennofs> Peaker: so would you think instance NFData (IORef a) where rnf a = seq a () is more useful?
04:23:51 <Peaker> jedai: Why use GLUT and not GLFW-b?
04:25:07 <jedai> Peaker: because I always did that (on the other hand GLFW-b install failed with "unknown symbol `strdup'" so...
04:25:11 <shachaf> bennofs: I that in do { let { !x = foo ref }; writeIORef ref ...; let { !y = foo ref }; ... }, x and y certainly shouldn't be different.
04:25:27 <Peaker> bennofs: Yeah
04:25:29 <Peaker> bennofs: I think the thing the IORef refers to is not a pure part of the IORef. rnf would also become IO order-dependent, which would suck
04:25:52 <Gurkenglas> (I'm of course just speaking of my own experience and the mnemonics I'm using.)
04:26:53 <jedai> Peaker: Of course in the past I used the Haskell Platform so Glut wasn't a problem... I'm trying to do it with MinGHC, I expected it to be quite straightforward : download a binary of freeglut for Mingw, copy the .a and .dll in the right places and there it goes but I don't seem to be able to make it see the library, nevermind compiling...
04:28:31 <hjulle> shwouchk,  "infixr 0 $" (which is the answer if you type ":i $" in GHCi) means that $ associates to the right and has precedence 0, which is the lowest possible. "Associates to the right" means that  f $ g $ h x == f $ (g $ h x) == f (g (h x)).
04:29:32 <Peaker> jedai: GLUT sucks :(  GLFW-b is better.  strdup missing sounds like libc isn't linked against properly?
04:30:28 <jedai> Peaker: Apparently it's bindings-GLFW which has a problem (ghc can't load it when it has to compile GLFW-b
04:31:16 <Peaker> jedai: strdup is a libc symbol though, maybe MinGHC strips down some of libc?
04:31:46 <jedai> strdup is quite indispensable though... that would seem a bad idea
04:32:47 <jedai> Peaker: How would I check that ?
04:34:23 <Peaker> jedai: Try nm -D on the libc file (however that is packaged?) Try building a small C program using strdup?
04:38:50 <bennofs> Is there a good library for macro-benchmarking in haskell? criterion seems to be focused on benchmarking small functions
04:40:53 <jedai> Peaker: Ok, after compiling a small program strdup seems ok...
04:41:15 * hackagebot linear-opengl 0.2.0.8 - Isomorphisms between linear and OpenGL types  http://hackage.haskell.org/package/linear-opengl-0.2.0.8 (BenGamari)
04:41:17 * hackagebot HueAPI 0.2.4 - API for controlling Philips Hue lights  http://hackage.haskell.org/package/HueAPI-0.2.4 (SjoerdVisscher)
04:41:19 * hackagebot standalone-haddock 1.1.4.4 - Generate standalone haddock documentation for a set of packages  http://hackage.haskell.org/package/standalone-haddock-1.1.4.4 (KarlVoelker)
04:41:21 * hackagebot wkt 0.2.5 - Parsec parsers and types for geographic data in well-known text (WKT) format.  http://hackage.haskell.org/package/wkt-0.2.5 (BenGamari)
04:41:39 <jedai> ghc.exe: D:\DevTools\Scripts\Haskell\GlossSandbox\.cabal-sandbox\x86_64-windows-ghc-7.10.1\bindings-GLFW-3.1.1.2\HSbindings-GLFW-3.1.1.2-F0TYvfItplwGfQojnd7MTc.o: unknown symbol `strdup'
04:42:09 <jedai> Peaker: That's the exact error I get after it tells me it can't load bindings-GLFW
04:42:38 <hjulle> bennofs, How about the built in profiling support in ghci?
04:42:49 <hjulle> *ghc
04:43:00 <Peaker> jedai: Can't spend much time helping ATM, sorry :(
04:43:23 <mauke>  Not y <- [x, Not x]  -- ¯\(°_o)/¯
04:43:29 <jedai> Peaker: Right.. :( Well this is annoying but not vital
04:43:46 <bennofs> hjulle: profiling can slow things down quite a lot. also, I'd like something where I can define multiple scenarios and get timings automatically
04:45:15 <hjulle> bennofs, What is the problem with criterion? My guess is that it would work fine for macro benchmarking if you tweak a few parameters.
04:46:06 <bennofs> hjulle: hmm, I wonder if I should benchmark "create 100000 events" or "create 1 event" with criterion ...
04:51:47 <zq> is there multicase syntax in ghc or not
04:52:01 <zq> as usual the wiki page is abjectly unhelpful
04:52:01 <hjulle> Why is there no official syntax for the laws associated with typeclasses? If there was, you could have used an automated theorem solver to prove them for your instance, or at least QuickCheck.
04:52:26 <jedai> Peaker: Well managed to install a version of GLFW but I can't get gloss to forgo GLUT even by telling it -f="GLFW -GLUT", does it still need Glut anyway or should I try to remove those dependancies ?
04:54:33 <pavonia> zq: What is multicase syntax?
04:54:43 <hjulle> https://wiki.haskell.org/MultiCase
04:55:28 <hjulle> zq,  "It is proposed that... " This means there is no such syntax yet.
04:57:05 <zq> hjulle: " This page was last modified on 30 September 2011, at 04:20." suggests that something would have changed
04:57:33 <hjulle> zq, There is also no official proposition about such an extension AFIK.
04:57:38 <zq> ah yes the old 4-year standing ghc proposal
04:58:19 <hjulle> The date suggests that nothing has happened, rather than the opposite.
05:01:55 <mccn> hjulle, doesn't my inefficient fib evaluate each number just once because the lazy evaluation uses local definitions?
05:03:14 <srhb> hjulle: I would say this is the proposed extension, but since the page doesn't load, I can't be sure :P https://ghc.haskell.org/trac/ghc/ticket/3919
05:04:04 <srhb> For now, http://hackage.haskell.org/package/OrPatterns
05:05:10 <hjulle> mccn, No, each call to fib n will run the whole function again. See also: https://wiki.haskell.org/Memoization
05:06:22 <mccn> thanks, I'll keep trying
05:08:05 <hjulle> let x = f y in (x,x) -- will only evaluate f once, let x = f in (f x, f x) -- will evaluate f twice
05:08:36 <hjulle>  let y = f in (y x, y x)
05:09:07 <hjulle> My second example was incorrect.
05:10:26 <hjulle> mccn, You can use the module Debug.Trace to see what is evaluated and what is not. But note that using it may change the behaviour of the program if you are not careful.
05:11:15 <excelsio1a> When Currying, do you get partial evaluation if possible?
05:11:16 * hackagebot hspec-contrib 0.2.1 - Contributed functionality for Hspec  http://hackage.haskell.org/package/hspec-contrib-0.2.1 (SimonHengel)
05:14:21 <byorgey> excelsio1a: I am not quite sure what you are asking, but the answer is probably yes.
05:14:36 <byorgey> excelsio1a: can you give a more specific example of what you are wondering about?
05:19:04 <mccn> wow memoization is awesome, thanks hjulle. I was trying to make a different more efficient recursive function, I don't know if that was possible without learning some new concept
05:20:50 <hjulle> mccn, Yes, that is really important in these kinds of cases, when the same function is called repeatedly with the same arguments. There is also several modules for memoization, so you don't have to write the memoization code yourself.
05:21:20 <jedai> Peaker: Ok, I found the problem (it was stupid... as usual)
05:21:21 <hjulle> But of course, it's good to do it yourself in the beginning as an exercise.
05:21:29 <mauke> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
05:21:31 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
05:21:33 <hjulle> :)
05:22:53 <mccn> by the way, what do the !! in "memoized_fib = (map fib [0 ..] !!)" mean?
05:23:12 <mauke> @src (!!)
05:23:12 <lambdabot> xs     !! n | n < 0 = undefined
05:23:12 <lambdabot> []     !! _         = undefined
05:23:12 <lambdabot> (x:_)  !! 0         = x
05:23:12 <lambdabot> (_:xs) !! n         = xs !! (n-1)
05:23:46 <dot_Laptop_> how does the fibs with zipWith work? Is there a visualization explanation of fibs in the internet?
05:23:51 <hjulle> mccn, It is also possible to make an efficient version without using memoization. Think of how you would write it in an imperative language.
05:24:51 <mauke> dot_Laptop: do you know how zipWith works?
05:25:20 <dot_Laptop> yes.
05:25:52 <dot_Laptop> I've looked into its definition and tried using it on simple iilst of integers
05:26:02 <dot_Laptop> *list
05:26:02 <hjulle> I know a good visual representation of the fibs with zipWith would look, but I do not know how to create it.
05:26:15 <mauke> ok, so zipWith (+) (x : xs) (y : ys) = (x + y) : ...
05:26:38 <mauke> that is, zipWith starts by emitting the sum of the first elements of the argument lists
05:27:18 <mauke> the first argument is fibs. the first element of that is 0 (because fibs = 0 : ...)
05:27:49 <mauke> the second argument list is tail fibs. the first element of that is 1 (because tail fibs = tail (0 : 1 : ...) = 1 : ...)
05:28:22 <mauke> so the first element returned by zipWith is 0 + 1, which is 1
05:29:07 <mauke> at this point fibs = 0 : 1 : 1 : <thunk>
05:29:42 <mauke> <thunk> represents the unevaluated expression for the recursive call to zipWith
05:30:43 <dot_Laptop> which is zipWith (+) xs ys ?
05:30:53 <mauke> yes
05:31:02 <dot_Laptop> oh thanks!
05:31:23 <mauke> at that point, xs = 1 : 1 : <thunk> and ys = 1 : <thunk>
05:31:45 <mauke> again, the first elements are already computed, which is enough to provide another result element
05:34:30 <mauke> visual representation: https://www.youtube.com/watch?v=t8T8bStabq0&t=1m37s
05:36:00 <dot_Laptop> haha
05:39:36 <dramforever> hmm...people discussing about looking into partially-evaluated values
05:51:18 * hackagebot pdfinfo 1.5.3 - Wrapper around the pdfinfo command.  http://hackage.haskell.org/package/pdfinfo-1.5.3 (ChrisDone)
05:55:25 <dramforever> Q: anyone installed cairo/glib recently?
05:55:46 <dramforever> because it's failing here
05:55:58 <dramforever> log coming...
05:57:03 <lpaste> dramforever pasted “cairo/glib” at http://lpaste.net/8134109631271141376
05:57:18 <lpaste> dramforever pasted “cairo/glib” at http://lpaste.net/130591
05:57:40 <dramforever> oh same post
05:57:53 * dramforever thought "private" won't appear here
05:59:14 <mauke> dramforever: what locale are you using?
05:59:36 <mauke> also, how good is your chinese?
06:00:14 <mauke> (private pastes don't appear in this list: http://lpaste.net/browse )
06:00:49 <dramforever> ok
06:01:33 <dramforever> mauke: I'm Chinese
06:01:34 <dramforever> oh locale!
06:01:34 <dramforever> why might/does that matter?
06:01:47 <mauke> http://a.haskellcn.org/topic/4f97afb0edefd68d3700193e - I found this on google
06:01:57 <mauke> it says "locale" and I can't read the rest
06:02:34 <dramforever> mauke: good I'll try
06:02:38 <mauke> but it suggests switching to en_US.UTF-8 as a workaround
06:03:36 <dramforever> the post makes sense to me
06:03:48 <dramforever> great it worked
06:03:54 <mauke> for the record/log: gtk2hsC2hs: Error in C header file. >>> Lexical error! The character '#' does not fit here.
06:04:39 <kuribas> Why do haskell programmers dislike "let"?
06:04:56 <dramforever> you know, google ,duckduckgo, startpage, etc are all blocked
06:05:45 <mauke> relevant bug: https://github.com/haskell/c2hs/issues/7
06:06:04 <dramforever> kuribas: Can you elaborate?
06:06:05 <dramforever> okay
06:06:57 <kuribas> dramforever: It seems haskell programmers prefer a "where" clause over a "let" clause, but maybe my perception is wrong?
06:07:48 <mauke> 'let' requires more thinking about formatting
06:08:22 <dramforever> okay I'm back
06:08:57 <kuribas> mauke: how do you mean?  emacs does the formatting for me...
06:09:11 <mauke> I don't use emacs
06:09:24 <mauke> also, how can this possibly work?
06:09:35 <dramforever> kuribas: indent determines structure, and structure doesn't determine indent
06:09:39 <mauke> in haskell, formatting determines the structure of the code
06:09:46 <dramforever> yeah exactly
06:10:48 <dramforever> kuribas: to me the difference is x = A where B means that A is the big picture of x and B is the detail
06:10:50 <kuribas> mauke: emacs determines where the logical stops are, you choose the stops with tab.
06:12:02 <mauke> kuribas: what do you mean by "stops"?
06:12:19 <kuribas> mauke: valid indentation points
06:12:25 <dramforever> kuribas: press tab over and over again, you get the current line moved back and forth
06:12:31 <mauke> that doesn't help me with lines
06:12:54 <mauke> formatting is not just indentation but also whether/where to start a new line
06:13:03 <Cale> I don't dislike let
06:13:06 <dramforever> it doesn't help much, but seems okay
06:13:24 <Cale> let is good when you want to put the declarations you're about to use up-front
06:13:29 <dramforever> Cale: +1, in fact I like let very much
06:13:37 <Cale> Often if you're thinking in a top-down sort of way though, you'll prefer where
06:13:40 <kuribas> mauke: if you want a new line, you press enter?
06:13:41 <dramforever> the haskell way: important things first
06:13:58 <kuribas> dramforever: of course it is up to debate what is important :)
06:14:04 <Cale> It depends on what you consider to be more important, right.
06:14:08 <dramforever> yeah
06:14:24 <Cale> let is also something that I tend to use more if I'm trying to think operationally
06:14:44 <Cale> Because it corresponds nicely (for the most part) with manipulations of the heap.
06:14:49 <kuribas> I seem to find let easier to write, since I can code constructively.
06:15:44 <dramforever> kuribas: it's just a matter of order
06:16:04 <dramforever> with let you work bottom up
06:16:10 <dramforever> with where, top down
06:16:12 <kuribas> dramforever: true
06:16:46 <dramforever> when running haskell order is rather moot, which gives you the freedom
06:17:05 <dramforever> I guess that's the good thing about lazy evaluation?
06:18:09 <mauke> Cale: http://blogs.perl.org/users/mauke/2015/04/functional-fun-with-logical-expressions.html :-)
06:18:53 <mauke> also I've discovered I love LambdaCase
06:19:31 <Cale> heh, nice :)
06:19:40 <bennofs> In criterion, if I do --regress allocated:iters, what does 'y' mean in the output?
06:19:59 <mauke> I suspect parts of this are horribly clumsy or inefficient
06:20:43 <quchen> mauke: Hooray for LambdaCase! Next stop, MultiWayIf
06:21:25 <kuribas> mauke: I couldn't work without autoindentation...
06:22:10 <mauke> vim's autoindent (together with ^D/^T) is enough to be practical
06:22:23 <mauke> fancier things are welcome, of course
06:22:52 <kuribas> I cannot comment on that, I never used vim for coding.
06:23:27 <arcaedox> Hi there , does anybody do FRP here ?
06:23:30 <Cale> I'm happy as long as my editor will start a new line indented as deeply as the previous.
06:23:38 <Cale> arcaedox: Quite a few
06:23:41 <mauke> that's exactly what autoindent does
06:23:52 <arcaedox> great , elerea ?
06:23:53 <mauke> when you start a new line, it preserves the indentation of the previous line
06:24:25 <mauke> (I like it so much, I've turned it on globally, not just in haskell mode)
06:25:18 <kuribas> mauke: the indentation mode parses the expression before the cursor, and finds all the possible tab, taking care of the layout rule, parens, etc...
06:25:21 <mauke> ^T and ^D are increase/decrease indentation of current line, respectively
06:25:36 <Cale> arcaedox: In general on IRC it's better just to ask a question and see if someone is around who can answer.
06:25:53 <Cale> arcaedox: I don't know Elerea very well, but depending on what you ask, I might be able to help.
06:26:36 <arcaedox> ok , Im trying to convert a tutorial from reactive banana to elerea
06:26:41 <mauke> kuribas: I wonder how that is implemented
06:26:50 <mauke> and how hard I can break it
06:27:19 <arcaedox> and here is my code , (a little novice though lol) http://pastebin.com/SpnGDVx0
06:27:29 <kuribas> mauke: it has a ad-hoc parser.  It will choke on syntax extensions that aren't implemented though.
06:28:01 <mauke> kuribas: does it always reparse from the beginning of the file?
06:28:16 <kuribas> mauke: please break it, and file issues at https://github.com/haskell/haskell-mode
06:28:33 <kuribas> mauke: no, from the first zero indentation line before point.
06:28:47 <mauke> ok, that's already broken
06:29:15 <kuribas> mauke: It works fine for me, as long as you don't have a 1000line function or so.
06:30:03 <kuribas> Or if you are programming on a i386 from 1990.
06:30:52 <bennofs> kuribas: what indentation mode are you talking about? hi2?
06:31:11 <mauke> what's the difference between haskell-indent.el and haskell-indentation.el?
06:31:13 <bennofs> or indent-mode or indentation-mode?
06:31:59 <kuribas> bennofs: indentation-mode
06:32:38 <kuribas> mauke: haskell-indentation will find the correct indentation stops, at least it should.
06:33:29 <mauke>   (setq max-lisp-eval-depth (max max-lisp-eval-depth 600))  <- wtf am I reading .jpg
06:34:02 <phaazon> is there a proposal somewhere to make fmap being map?
06:34:09 <phaazon> (the typeclass’ method name)
06:34:23 <lynnard> Is there a nice operation for doing (||) on Maybe values similar to Bool? i.e. Nothing || v@(Maybe _) = v | v@(Maybe _) || _ = v | _ || _ = Nothing
06:34:24 <Cale> arcaedox: Did you have a question? One thing you might do is make use of 'when'
06:34:28 <Cale> :t when
06:34:29 <lambdabot> Applicative f => Bool -> f () -> f ()
06:34:46 <Cale> when (x > 0) (bShout x)
06:34:52 <arcaedox> oh right , where can I read the docs for that ?
06:34:57 <phaazon> lynnard: the Monoid interface?
06:35:03 <mauke> lynnard: mplus
06:35:07 <arcaedox> That looks good 
06:35:28 <mauke> phaazon: the monoid instance is lifted IIRC
06:35:28 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/Control-Monad.html#v:when
06:35:39 <phaazon> > Nothing <> Just "lol"
06:35:41 <lambdabot>  Just "lol"
06:35:44 <phaazon> oh, right
06:35:49 <phaazon> then, All
06:35:58 <phaazon> > All Nothing <> All (Just "lol")
06:35:59 <lambdabot>      Couldn't match expected type ‘Bool’ with actual type ‘Maybe a0’
06:35:59 <lambdabot>      In the first argument of ‘All’, namely ‘Nothing’
06:35:59 <lambdabot>      In the first argument of ‘(<>)’, namely ‘All Nothing’    Couldn't match ...
06:36:03 <phaazon> that’s not all…
06:36:06 <phaazon> :D
06:36:08 <phaazon> And, maybe
06:36:12 <phaazon> I don’t remember
06:36:23 <mauke> > Just "a" <> Just "b"
06:36:24 <lambdabot>  Just "ab"
06:36:27 <mauke> > Just "a" `mplus` Just "b"
06:36:28 <lambdabot>  Just "a"
06:36:52 <lynnard> mauke: unfortunately that's not what I want
06:37:00 <phaazon> > getFirst $ First Nothing <> First (Just "lol")
06:37:01 <lambdabot>  Just "lol"
06:37:11 <lynnard> mauke: I thought about it as well, but basically I want to discard the second value if the first when is (Just _)
06:37:12 <kuribas> mauke: elisp doesn't have tail-call optimization.
06:37:24 <mauke> "You can remove all indentation from a region by giving a large negative ARG." ಠ_ಠ
06:37:46 <mauke> lynnard: that is exactly what I gave you
06:37:56 <mauke> lynnard: how is that not what you want?
06:38:39 <lynnard> <> for Maybe a demands that a is an instance of Monoid and when two (Just _) values are <> together you get Just (the result of the <> for the inner values)
06:38:53 <pyrtsa> lynnard: `mplus`
06:39:04 <mauke> lynnard: phaazon was the one who suggested Monoid, not me
06:39:26 <lynnard> ok cool sorry
06:39:48 <phaazon> yeah, the Monad interface is the correct one
06:39:57 <phaazon> > do { Nothing; Just 3 }
06:39:59 <lambdabot>  Nothing
06:40:13 <mauke> > do { Just 3; Nothing }
06:40:15 <lambdabot>  Nothing
06:40:21 <grpala> phaazon: the classy prelude
06:40:32 <phaazon> grpala: what do you mean classy prelude?
06:40:37 <ggVGc> wish I'd spent my first programming years understanding haskell rather than learning broken C++ only to years later abandon it after understanding what I'd done to my brain
06:40:55 <phaazon> ggVGc: don’t say that
06:41:00 <grpala> ?fmap
06:41:01 <lambdabot> Maybe you meant: slap faq
06:41:02 <grpala> err
06:41:03 <phaazon> C++ and C were important
06:41:08 <ggVGc> yeah I guess
06:41:10 <phaazon> without them, we wouldn’t have Haskell
06:41:18 <phaazon> the ystill are
06:41:21 <phaazon> they still*
06:41:26 <grpala> phaazon: map being fmap
06:41:32 <phaazon> grpala: oh, nice
06:41:39 <ggVGc> phaazon: well, but starting programming in something like haskell ismore beneficial for becoming a good programmer I reckon
06:41:43 <phaazon> I really like the idea of map being Functor’s method
06:41:48 <pyrtsa> I'm pretty happy I got to first try the hard things in C++ that turned out to be simple almost everyday stuff in Haskell. :)
06:41:53 <phaazon> ggVGc: I don’t think so
06:42:00 <ggVGc> just because C++ has been important as a historical block, doesn't mean that I benefit from starting in it
06:42:04 <phaazon> Haskell is, to me, the best programming language
06:42:12 <phaazon> but it’s also very controversial
06:42:26 <kuribas> mauke: If you want something less ad-hoc, you could look at structured-haskell-mode from Chris Done
06:42:34 <phaazon> if you haven’t done memory allocation by hand or assembly
06:42:42 <phaazon> I’m pretty sure you’ll make a bad use of Haskell
06:42:48 <ggVGc> true
06:42:51 <phaazon> because, it’s very easy to stack thunks 
06:43:20 <ggVGc> phaazon: I just wonder if it wouldn't be better to first learn logical building and modelling well, and then learn how machines work
06:43:32 <phaazon> on the other hand, getting your feet wet with Haskell after years of imperative languages like C or C++ makes you discover “magic” every day :)
06:43:45 <phaazon> ggVGc: maybe, maybe
06:43:46 <kuribas> ggVGc: C is good as portable assembly.
06:43:53 <phaazon> though, you can still produce very good designed code in C++
06:44:06 <ggVGc> I don't have much problems with C, and I still use it often, but C++ was not a good investment of my time
06:44:22 <kuribas> ggVGc: The problem with C++ is that it wants to be high-level language and low-level, but it is neither.
06:44:28 <phaazon> ggVGc: in general, I think that OO is not a good investment
06:44:31 <Cale> It's possible to understand Haskell's memory usage fairly well without actually thinking in terms of how GHC implements it at a low level.
06:44:48 <kuribas> ggVGc: On the other hand, C++ may help you more to find a job.
06:44:48 <phaazon> Cale: meh
06:45:03 <Xe> C++ is great if you like making code that takes forever to compile, is hard to understand and can introduce bizarre behavior via operator overloading without typechecking
06:45:19 <phaazon> Xe: you forget one very important point
06:45:20 <Cale> In fact, most of the time I just picture things in terms of graph reduction, where the space usage of a program is proportional to how much space it will take to draw your graph on a page :D
06:45:28 <phaazon> C++ is way much simpler than Haskell to learn for common people
06:45:37 <phaazon> mastering Haskell is _HARD_
06:45:55 <Xe> phaazon: no thing worth doing is trivial
06:45:57 <Cale> mastering C++ is so hard that nobody has ever done it
06:46:07 <phaazon> Cale: sure
06:46:11 <ggVGc> I am just annoyed that durint the 2 years I learnt C++ and used it heavily, I wasn't experienced enough to understand why what I was learning was just not a very good way of modelling problems at all, so I feel a bit fooled and wish I'd been given Ocaml or haskell instead
06:46:13 <phaazon> but you can learn C++ faster
06:46:22 <phaazon> getting your mind wrapped around Haskell is hard
06:46:28 <phaazon> as a begginer would say
06:46:30 <phaazon> beginner*
06:46:36 <tzaeru> I'm quite glad I learned C++ amongst the first languages I ever looked into as a wee litl' kid. it was a practical choice that carried well pretty far.
06:46:38 <kuribas> Cale: yeah.  Writing correct programs in C++ is much harden than in haskell.
06:46:47 <phaazon> ggVGc: sure
06:46:53 <phaazon> that’s the common feeling of us here
06:47:02 <phaazon> after learning Haskell, you look backwards and… “AHAH”
06:47:28 <ggVGc> phaazon: what I'm getting at is that Haskell and other FP languages are about problem solving and logical design(which is the core of good programming), while C and C++ etc. are about how our machines work currently. I feel like I and most of the world started in the wrong end
06:47:38 <phaazon> and as a guy already mentionned above, C++ is – with C and Java – the way to make money.
06:47:45 <exio4> phaazon: Haskell is pretty much dead easy to "understand", remember, after all, the language itself is kinda simple
06:47:55 <phaazon> ggVGc: I agree
06:48:03 <Cale> If all the written references for what C++ consists of and all the compilers were to mysteriously vanish overnight, there is nobody in existence who could actually remember all the details, and probably even collectively, we wouldn't be able to get back to exactly what we had before.
06:48:09 <phaazon> exio4: the language, at itself
06:48:12 <phaazon> is maybe simpler than C
06:48:13 <ggVGc> exio4: yep, it just feels hard because we're conditioned to think about how curent CPU's work rather than how programs flow
06:48:16 <mauke> phaazon: I completely disagree with "C++ is way much simpler than Haskell to learn for common people"
06:48:18 <Xe> phaazon: My job is actually encouraging me to learn haskell, we're replacing PHP with it
06:48:26 <phaazon> but the “practical Haskell” is not
06:48:29 <exio4> ggVGc: yes, pretty much that's what I am thinking
06:48:35 <ggVGc> C++ is far from simple
06:48:37 <phaazon> Xe: that’s awesome!
06:48:40 <phaazon> I envy you :)
06:48:48 <ggVGc> and the moment I realised how not simple it is, is about the same time I stopped using it for anything
06:48:50 <mauke> this is independent of whether Haskell is easy to learn or not. it's just that C++ is impossibly complex
06:48:51 <exio4> phaazon: practical C++ is easier..? 
06:49:06 <phaazon> exio4: practical C++ is dirty
06:49:11 <pyrtsa> I think Haskell is simpler to learn for people that haven't learned to write procedural or OOP code already.
06:49:13 <phaazon> people don’t have to worry about abstractions
06:49:18 <phaazon> and “learing”
06:49:19 <Xe> mauke: there's a reason why we also use Go for internal tools :D
06:49:22 <phaazon> a lot of people out there are lazy
06:49:24 <ggVGc> mauke: to me the rules of C++ are practicaly summed up as "Yeah, whatever!"
06:49:25 <Xe> it has a lot of well defined rules
06:49:26 <phaazon> they don’t want to “learn”
06:49:28 <phaazon> they want to make
06:49:37 <mauke> ggVGc: I wish :-(
06:49:39 <phaazon> “learning”*, sorry for the typo
06:49:42 <exio4> phaazon: you actually need to learn lots of things + exceptions 
06:49:48 <tzaeru> that's me, by the by. I've still wanted to learn a bit of Haskell, but it's way too much work really.
06:49:52 <tzaeru> especially when I can get nothing useful done with it anyway
06:49:53 <phaazon> exio4: not that much
06:50:01 <Xe> exio4: not to mention that exceptions stop all other threads at the same time
06:50:15 <phaazon> I’ve been doing C++ for almost 10 years since I’m young
06:50:16 <maw> easy /= simple
06:50:26 <phaazon> expression templates and all that stuff is not mandatory for a daily job
06:50:39 <exio4> I didn't mean those exceptions, just that you need to learn X and then another hundred of places where X is different
06:50:45 <tzaeru> and "lazy" is really the wrong word for people who feel that the trade-off of time to learn and getting actual stuff done, is not-so-good.
06:51:00 <mauke> ok, can we go back to me ranting about emacs/lisp?
06:51:17 <quchen> I hate Emacs because watching chrisdone's videos make me jealous
06:51:17 <exio4> emacs-lisp is dirty
06:51:18 <ggVGc> tzaeru: this is what I'm getting at. If you'd initially been intriduced to FP and Haskell(for example), it would probably have felt super natural. Because FP is more about how problems are solved and how data flows, rather than "what should I name this piece of memory and where should I put it so that this other piece of memory can talk to it"
06:51:22 <exio4> let's switch to Scheme
06:51:27 <nszceta> haskell-emacs
06:51:33 <mauke> consider the following:  (looking-at "\"\\([^\\\"]\\|\\\\.\\)*\"")
06:51:38 <phaazon> exio4: what I mean is that in the current times, people have imperative ways to see code
06:51:39 <mauke> just ... why
06:51:41 <phaazon> because of schools
06:51:53 <phaazon> and all the materials they used to learn how to write code lines
06:52:00 <ggVGc> yep
06:52:03 <ggVGc> that that's why I feel fooled
06:52:05 <ggVGc> dam nyiu world
06:52:07 <nszceta> what is more relaxing to code in, haskell or another language?
06:52:09 <ggVGc> damn you*
06:52:17 <Cale> Haskell is my favourite imperative programming language
06:52:20 <nszceta> what is the most relaxing language to code in
06:52:26 <phaazon> in my schools
06:52:33 <tzaeru> ggVGc, well, I feel that it's terribly wrong to think that experienced people actually think of problems on the level of memory management or scopes when they work on imperative/OO languages.
06:52:34 <phaazon> I **never** heard of FP
06:52:35 <phaazon> never.
06:52:39 <phaazon> always Java
06:52:41 <phaazon> J2EE
06:52:43 <Cale> ggVGc: I understand the feeling :)
06:52:44 <maw> mauke: let's see what happens now that regex is part of C++. Give it ten years
06:52:46 <exio4> phaazon: I won't deny that, we're learning how to implement data structures in an enviroment with manual memory management, which is a bit far from FP
06:52:47 <phaazon> and all thug shit
06:53:07 <phaazon> exio4: :)
06:53:09 <nszceta> my buddy talks about using XML to generate Java objects at work. Wtf is going on? Anybody know this?
06:53:20 <phaazon> nszceta: run.
06:53:22 <phaazon> run away.
06:53:24 <tzaeru> ggVGc, and I don't know what'd really happened if I was originally introduced to Haskell or other functional programming languages.. I don't really program because of how cool programming itself is, but because of what I actually can do with it.
06:53:25 <mauke> I'll rewrite this in perl just to make it easier to understand
06:53:29 <ggVGc> nszceta: sounds pretty common in the corporate programming world
06:53:33 <nszceta> wtF?
06:53:45 <quchen> Sounds like enterprise, i.e. broken.
06:53:46 <nszceta> can you please explain though. I have never heard of this sort of insanity anywhere else
06:53:46 <ggVGc> nszceta: generating code from markup?
06:53:48 <ggVGc> happens all the time
06:53:51 <tzaeru> not many FP languages would have been terribly useful in graphics or game industry in the past and hardly now either.
06:54:11 <mauke> qr{ " ( [^\\"] | \\ . )* " }x
06:54:15 <phaazon> exio4: I think the “problem” – if it’s really an actual problem – is that people have prejugés about Haskell
06:54:19 <phaazon> and FPL
06:54:20 <ggVGc> nszceta: one example is generating bindings from SQL schemas I'd say
06:54:26 <nszceta> why is it a common practice to generate objects from XML ?
06:54:32 <nszceta> aha
06:54:36 <exio4> Cale: I agree, writing imperative code is extremely nice in Haskell :D 
06:54:40 <ggVGc> people generate code form metadata all the time
06:54:42 <phaazon> nszceta: because of android, I’d say
06:54:48 <phaazon> it’s very common to do that
06:54:48 <tzaeru> overall I actually think that the repulsion towards low level topics like manual memory management is very uncalled for when discussing the benefits of FP..
06:54:51 <phaazon> they put constants in XML…
06:55:04 <nszceta> my buddy works for a financial company that is heavily invested in Java
06:55:09 <tzaeru> "not being low-level" is not a benefit. it just is. a thing.
06:55:10 <nszceta> so its not android...
06:55:31 <phaazon> I don’t know, I tend to hate those kind of people
06:55:35 <exio4> phaazon: I think it's a bit because it is a "language with types!, functional!" which is a bit far from what most people like nowdays, which is a unityped imperative programming language
06:55:55 <phaazon> freshly graduated, and they think they know the world better than you because “they use apache and do some business”
06:55:56 <exio4> and when they saw a language with static types, it was Java or C++
06:55:58 <phaazon> damn them.
06:56:02 <ggVGc> phaazon: haskell's largest problem currently is the huge system dependency and setup to get started, which in turn makes it almost impossible for people to distribute software written in haskell to non-haskell-users, and also that the ecosystem as a developer is not very mature
06:56:04 <kuribas> tzaeru: There's nothing wrong with low level programming when necessary, but FP isn't really suited for it.
06:56:28 <exio4> ggVGc: ? distribute software written in Haskell to non-haskell-users? what's hard about it?
06:56:37 <tzaeru> kuribas, yeah, that's one way to put what I was going for, really.
06:56:45 <phaazon> what’s about the ecosystem?
06:56:54 <phaazon> I find it way cooler than, e.g., in C++
06:57:00 <tzaeru> when I see people bash other languages/paradigms to support their own, I just get the impression that their choice can't stand on its own.
06:57:01 <phaazon> where you’re left alone in the jungle
06:57:03 <mauke> kuribas: I've found a few potential problems glancing at the elisp code
06:57:03 <nszceta> wtf are you talking about ggVGc ... ghc --make A.hs --> A.exe
06:57:07 <phaazon> and grab libs everywhere from the net
06:57:10 <arw> ggVGc: its about as hard as c++- or java-software imho. 
06:57:12 <kuribas> mauke: fire up
06:57:18 <ggVGc> exio4: the fact that with software written in C you can just ask people to run make and it's all good, but with haskell it'll tell them "hey you need a few hundred mb of GHC"
06:57:31 <kuribas> tzaeru: I think rust is supposed to change that.
06:57:32 <mauke> kuribas: https://github.com/haskell/haskell-mode/blob/master/haskell-indentation.el#L1172
06:57:32 <nszceta> as if GCC is lightweight
06:57:36 <Cale> ggVGc: How big is GCC?
06:57:37 <nszceta> who are we kidding here?
06:57:46 <nszceta> GCC is just as big as GHC
06:57:54 <nszceta> why do you need to distribute a compiler to your end-users?
06:57:55 <nszceta> you don't
06:57:58 <ggVGc> Cale: smaller I reckon, but not the point. The point is that everyone has gcc or a C compiler, and most don't have haskell deps
06:58:04 <nszceta> wtf?
06:58:05 <exio4> for windows, after you got the dependencies compiled (which is a pain in the ass in anything not-Microsoft-sponsored under windows), fire up a NSIS script, and you have a standalone installer and whatnot
06:58:05 <phaazon> nszceta: you actually need
06:58:11 <mauke> kuribas: oh, sorry, that line is actually ok. I was confused by the line noise
06:58:22 <phaazon> on linux you have gcc installed automatically in 99% of the cases
06:58:29 <nszceta> I am certain you can make a self-contained statically linked executable from a haskell source file
06:58:29 <tzaeru> on windows I didn't manage to run most more complicated haskell programs and examples with external dependencies..
06:58:32 <tzaeru> since dependency hell
06:58:32 <nszceta> prove me wrong
06:58:46 <Cale> ggVGc: You could also just give them a binary
06:58:48 <exio4> nszceta: it's static linked by default 
06:58:50 <nszceta> statically link all the things
06:58:51 <kuribas> mauke: elisp ain't beautiful :)
06:58:52 <phaazon> nszceta: sure, that’s not the debate
06:58:54 <tzaeru> and a lot of snippets were using library versions that I couldn't find at all.
06:58:58 <arw> phaazon: yes, but on linux you have a package manager that just installs ghc for you if necessary
06:58:59 <nszceta> ok whats the big deal
06:59:15 <phaazon> nszceta: if you need to compile a Haskell source
06:59:32 <phaazon> you’ll need several things that don’t go “by default” with the distribution
06:59:34 <exio4> gcc isn't installed by default in most distros
06:59:39 <mauke> kuribas: this isn't "not beautiful", this is deliberately obfuscated
06:59:40 <exio4> it's just that you install it somewhat early 
06:59:41 <ggVGc> Cale: yeah, but I'm talking about random OSS-projects people make and want to share on github etc. and with most things people can just pull it down and try it out, while with haskell all of a sudden you have to install a whole new compiler system and deps which will be a few hundred mb
06:59:46 <mauke> kuribas: anyway, https://github.com/haskell/haskell-mode/blob/master/haskell-indentation.el#L1186
06:59:47 <phaazon> exio4: it’s likewise then
06:59:56 <Cale> ggVGc: If they want to make changes, sure.
07:00:04 <ggVGc> no
07:00:10 <mauke> kuribas: this tries to parse a string literal, but it doesn't handle gaps, so I suspect it'll get confused by "\ \"
07:00:13 <ggVGc> Cale: most things I check out and try on github are just sourcees
07:00:22 <exio4> ggVGc: installing GHC is a single-time task, too
07:00:34 <ggVGc> yes, but it's a time consuming large single-step task
07:00:36 <phaazon> I’m pretty happy with the “haskell ecosystem”, I find it mature enough for my needs, along with github / darcs.net / whatever, it’s flexible enough to me
07:00:36 <tulcod> ggVGc: different language, different infrastructure, it's that simple
07:00:50 <Cale> ggVGc: You shouldn't have to compile something yourself if all you want to do is use it, unless it's an incomplete project or something and you want a development version.
07:01:19 <ibid> ggVGc: you do need to install gcc too the first time you want to source-install a C project
07:01:21 * hackagebot repa-devil 0.3.2.3 - Support for image reading and writing of Repa arrays using in-place FFI calls  http://hackage.haskell.org/package/repa-devil-0.3.2.3 (RaphaelJavaux)
07:01:22 <Cale> ggVGc: Maybe people are bad at remembering to make binaries available or something :)
07:01:23 * hackagebot nero-warp 0.3 - Run Nero server applications with Warp  http://hackage.haskell.org/package/nero-warp-0.3 (jdnavarro)
07:01:25 * hackagebot nero-wai 0.3 - WAI adapter for Nero server applications  http://hackage.haskell.org/package/nero-wai-0.3 (jdnavarro)
07:01:26 <mauke> kuribas: https://github.com/haskell/haskell-mode/blob/master/haskell-indentation.el#L1193
07:01:27 <ibid> ggVGc: or mono for C#
07:01:27 * hackagebot nero 0.3 - Lens-based HTTP toolkit  http://hackage.haskell.org/package/nero-0.3 (jdnavarro)
07:01:29 * hackagebot hsass 0.1.0 - Integrating Sass into Haskell applications.  http://hackage.haskell.org/package/hsass-0.1.0 (jakubfijalkowski)
07:01:47 <mauke> kuribas: this line tries to parse `infixOperatorSyntax`
07:02:15 <exio4> there were some new parser combinators library that IIRC was designed for having better error messages and what not, does anyone remember its name?  
07:02:24 <mauke> kuribas: it has several problems
07:02:29 <ggVGc> Cale: well, I am just saying this is a reason for slower adoption of haskell. People want to write stuff for fun and share it, without having a whole build scheme with binary distributions. and for things written in C, javascript with node, python, ruby etc. this is much easier because most people just have it
07:02:34 <mauke> kuribas: 1) it doesn't handle _ in operator names. `foo_bar` fails
07:02:44 <mauke> kuribas: 2) it doesn't handle qualified names. `Foo.bar` fails
07:02:53 <mauke> kuribas: 3) it doesn't handle whitespace. ` foo ` fails
07:02:57 <ibid> ggVGc: that is a problem for any non-mainstream language
07:02:59 <phaazon> exio4: parsec messages are pretty cool
07:03:03 <mauke> kuribas: 4) it doesn't handle comments. ` foo {- bar -}` fails
07:03:33 <ggVGc> ibid: yes, but then comes the second issue of cabal not being great and managing haskell dependencies often turns out being a pain, and then you lost your potential intersted people
07:03:37 <tzaeru> ggVGc, that's a very accurate description
07:03:38 <kuribas> mauke: thank for pointing that out...
07:03:56 <Cale> ggVGc: I guess. If you don't care much about actually writing Haskell, it's usually not so hard to install your distribution's GHC.
07:04:18 <tulcod> ggVGc: i'm not sure what your point is. did you bring this up because you think haskell can only become popular if ghc is rewritten into tinyghc or something? and you think this irc chat will contribute to that effort?
07:04:22 <Cale> ggVGc: No guarantees that it'll compile all the latest stuff
07:04:41 <ggVGc> I guess what I am saying is that usually languages are spread by someone seeing something cool someone else made in it. But with haskell this is hard, because most people don't get the chance to try the cool stuff other people make
07:04:57 <mauke> why are so many parsers so easy to break
07:05:12 <ggVGc> tulcod: uhm, I answered someone else's statement
07:05:12 <exio4> phaazon: trifecta is the one I meant! 
07:05:19 <ggVGc> I can stop talking about it if it's bothering you
07:05:27 <tzaeru> tulcod, having a reliable ecosystem with which you actually can painlessly run more complex code with external dependencies and not have to fully understand what's going on and constantly fix problems, would be a pretty damn great a boon.
07:05:27 <phaazon> exio4: how does it perform compared to parsec?
07:05:30 <tulcod> ggVGc: ah okay, sorry, i joined late. no, it's okay :)
07:05:38 <kuribas> mauke: I'll need to clean that up.  Btw that's not the parser, that's just the tokenizer.
07:05:40 <tulcod> was just wondering where this discussion was headed
07:05:51 <tzaeru> any newbie with nodejs can get stuff to run and switch between library versions and install full-blown huge projects to play around with
07:06:04 <ggVGc> personally, I enjoy writing haskell, but I feel I can't share my stuff with others without making binaries for each platform my friends might have, which is a bit of an overhead
07:06:09 <phaazon> ahah
07:06:15 <phaazon> it’s maintained by kmett!
07:06:15 <exio4> phaazon: I don't really know and I don't really care, this won't be more than a small interpreter 
07:06:21 <phaazon> I’ll have a talk with him then :)
07:06:21 <ggVGc> I can't just put stuff on github and tell people "check this out"
07:06:24 <Cale> ggVGc: One thing that I suppose can help with that is using nix to distribute an appropriate compiler along with all the dependencies.
07:06:36 <exio4> phaazon: unless it needs more than 1 second to parse 500 lines, I won't mind it!
07:06:54 <Cale> Like what ryantrinkle did with https://github.com/ryantrinkle/try-reflex
07:07:07 <phaazon> exio4: :)
07:07:15 <tulcod> tzaeru: a specific example here being... cabal hell?
07:07:19 <phaazon> parsec is already very elegant and fast
07:07:32 <tzaeru> tulcod, yup ^^
07:07:36 <phaazon> I wonder how trifecta performs and what the interface looks like
07:07:37 <tulcod> any others?
07:07:39 <exio4> phaazon: if I was looking for speed, I am pretty sure I would go with attoparsec
07:07:51 <tzaeru> it's a very meaningful example.
07:07:57 <tulcod> well sure, but are there any others?
07:08:14 <ggVGc> I feel currently haskell is usually being shared with other people already using haskell, and not so much with "outside" people
07:08:17 <ggVGc> which is a shame
07:08:20 <tulcod> because the issue of cabal hell is generally accepted as being on the todo list in the community, i think
07:08:25 <ggVGc> but yeah, it's the case with any non-mainstream language
07:08:27 <tzaeru> I don't know. I haven't dabbled much with haskell really. but I've had my share of hours of frustration in trying to track down right libraries and get things installed right and so to try projects and snippets :x
07:08:39 <ggVGc> but I feel haskell is large and mature enough to be able to begin being widely adopted
07:08:57 <tulcod> ggVGc: well... opinions are divided about this
07:09:10 <tzaeru> I need to try to figure out something practical to do with Haskell in my current projects..
07:09:18 <Cale> ggVGc: I expect the biggest problem is not that installing GHC is really hard (though installing GHC, Haddock, and cabal-install properly is harder than I'd like it to be)
07:09:21 <tzaeru> would be a good motivation to learn.
07:09:30 <srhb> ggVGc: Why not ggcG?
07:09:41 <ggVGc> srhb: http://tinyurl.com/NickAnswer
07:09:50 <Cale> ggVGc: The trouble is really that if you want to understand Haskell code, well, the language is not just a reskinning of a language that you probably already know.
07:09:53 <srhb> ggVGc: Damn, I walted right into that...
07:09:56 <jdnavarro> if hackage fails to build when a package is first published, does it try to rebuild later? or how do I make rebuild again?
07:09:59 <srhb> walked*
07:10:17 <ggVGc> srhb: funny because my other nick is Walt
07:10:26 <Clint> apt install ghc ghc-haddock cabal-install is pretty easy
07:10:30 <srhb> I'm accidentally psychic, I just never know.
07:10:31 <kuribas> mauke: BTW, it handles those pretty fine.  You just glanced at the code and made unfounded assumptions from it.
07:10:34 <jdnavarro> I uploaded some packages in the wrong order...
07:10:39 <phaazon> exio4: or happy / alex, even though they’re not parser combinators :)
07:11:10 <exio4> phaazon: I would with lbnf-meta if it was that way
07:11:16 <Cale> ggVGc: Haskell is so far displaced from most "mainstream" languages that it makes them all appear nearly identical to one another. :)
07:11:39 <Cale> ggVGc: People get used to being able to pick up a new language in a week, because it's essentially the same thing as 8 other languages they know.
07:11:48 <tulcod> Cale: while i absolutely agree with this, we all know that that has a reason. why can't we exploit this reason more often and more powerfully?
07:12:12 <Cale> tulcod: hm?
07:12:21 <tulcod> or to put it less subtly, why isn't it more clear to potential future haskell developers that haskell is superior?
07:12:45 <ggVGc> tulcod: I think simply because they aren't seeing/trying enough cool stuff written in it
07:12:50 <Cale> tulcod: Well, because in order to evaluate whether Haskell is superior for any particular task, you have to know it already.
07:12:51 <ggVGc> it's all opaque
07:13:12 <tulcod> Cale: but if it's truly better in some sense, then we should be able to show this by just writing cool shit, right?
07:13:16 <Cale> This isn't something special to Haskell, it's true of any programming language.
07:13:16 <tzaeru> professional programmers tend to pick new languages because either a) they have to because a project they get assigned to is using it or b) they feel that the time spent in learning that new language *and* solving the problem at hand, is less than the time to solve the problem with a language they already know
07:13:37 <Cale> tulcod: Well, sure. Maybe it's a bit sad that the largest things going on in Haskell are private developments.
07:13:41 <tzaeru> from my perspective at least, getting the motivation to learn haskell properly is much restricted by the fact that there's not much I actually can do with it.
07:13:46 <Xe> I pick new languages for personal projects because fuck it yolo
07:13:48 <ggVGc> tzaeru: 3/ because their favourite new cool thing was writtn in it
07:13:59 <tzaeru> I mostly do game dev/graphics dev. what do I do with haskell? not really much beyond academic curiousity, which for me, is a poor driver.
07:14:12 <tulcod> Cale: should i be thinking of the finance guys who keep spamming job ads?
07:14:18 <ggVGc> RevJohnnyHealey: ypu make it multiplayer and write your server in it
07:14:18 <Cale> tulcod: Also, only so much gets done because of the size of the community
07:14:19 <mauke> kuribas: I'm not convinced
07:14:24 <tzaeru> ggVGc, well yea, but I think the hype train is overestimated. a vocal minority jumps to any new cool full web server stack, but majority of professional, daily programmers don't.
07:14:33 <Cale> tulcod: Perhaps -- which spam?
07:14:39 <nshepperd> ggVGc: how much do cabal sandboxes help your 'publishing random things on github' problem?
07:14:40 <kuribas> mauke: if you like to make more comments, please do in #haskell-emacs
07:14:48 <tzaeru> ggVGc, meant that to me?
07:15:17 <Cale> tulcod: Did you see Ryan Trinkle's Reflex presentation?
07:15:19 <tzaeru> err, meaning your latter comment ^^
07:15:26 <ggVGc> tzaeru: yes
07:15:53 <tulcod> Cale: nope
07:16:05 <tzaeru> ggVGc, well, is there an industry-grade networking library available? what if I want to share large parts of server and client code?
07:16:07 <bennofs> tulcod: i can recommend it. 
07:16:18 <tulcod> this one? https://www.youtube.com/watch?v=BveDrw9CwEg
07:16:25 <tzaeru> I could write bindings to RakNet or something.
07:16:26 <tulcod> "CUFP 2013: Ryan Trinkle: Enterprise Appointment Scheduling with Haskell"
07:16:30 <ggVGc> nshepperd: not really much becuase people who might want to try something still need to get all of ghc and libraries etc. which mihgt be too big of an investment for many. BUt yeah, that's not really a "problem" that can be solved. It's just unfortunate currently
07:16:36 <tzaeru> but the total time used would be more than just jumping to use Unity would be..
07:16:37 <bennofs> tulcod: no, the reflex one
07:16:54 <kuribas> tzaeru: For game programming, I would favor an eager language, due to more predictable memory usage.
07:16:55 <tulcod> ah yes :)
07:17:00 <bennofs> tulcod: https://www.youtube.com/watch?v=mYvkcskJbc4
07:17:05 <tulcod> yep got it
07:17:07 <tzaeru> kuribas, yes. :P which I do favor.
07:17:24 <ggVGc> tzaeru: depending in your platforms you should be able to write the shared stuff in haskell, and combine it with C/C++/whatever for the game binary
07:17:26 <Cale> tulcod: Pt1: https://www.youtube.com/watch?v=mYvkcskJbc4  Pt2: https://www.youtube.com/watch?v=3qfc9XFVo2c  Interactive slides: https://obsidian.systems/reflex-nyhug/
07:17:53 <nshepperd> most linux distros seem to have ghc in repositories, so that shouldn't be too difficult
07:18:17 <nshepperd> although it seems have having ancient versions of ghc is a problem
07:18:33 <tzaeru> ggVGc, to me that just sounds a little painful.. like I'd.. write an entity system in haskell, then RakNet bindings to do the server, then I'd be doing all the physics engine and rendering engine wrapping in C++..
07:18:35 <tulcod> those slides ::OOO
07:18:40 <tulcod> that stuff is slick
07:19:14 <tzaeru> it's difficult to see why just doing it in Unity wasn't much faster and more reliable.
07:19:20 <tzaeru> like, a lot.
07:19:51 <nshepperd> my ubuntu 14.04 aws microserver has ghc 7.6 which is probably already useless for things I want to compile right now
07:19:56 <ggVGc> well, you said you wanted to use haskell
07:20:13 <nszceta> nshepperd does an RVM equivalent exist for Haskell
07:20:26 <nszceta> this would solve all of the old version problems
07:20:27 <tzaeru> ggVGc, main goal is to get things done, secondary goal is to learn something fun
07:20:34 <nszceta> www.rvm.io
07:20:35 <tzaeru> if the secondary goal doesn't hinder the main goal too much, then it's pushable.
07:20:36 <nszceta> check it out
07:20:39 <Cale> I think that eventually systems like reflex will win for game development, but there's still quite a lot work beating a path through that jungle.
07:21:17 <ggVGc> tzaeru: my day job has been game development and related for the past 7 years, and yes I agree haskell is not the best fit. But it's more fun and mentally developing. for things like parsing and processing data flows the situation is a lot different though
07:21:45 <ggVGc> tzaeru: I would never use haskell currently for a commercial game project obviously. But I might use it in the asset pipeline for the project
07:21:47 <nszceta> do you make money by making games in haskell
07:21:48 <nszceta> ok
07:21:59 <Cale> Most of the difficult bugs in game development come about from improperly updating one piece of state in reaction to a change in another.
07:22:02 <notdan> tulcod: I do need more RAM to view those slides I guess
07:22:13 <notdan> tulcod: hi, btw :)
07:22:16 <tulcod> sup
07:22:16 <ggVGc> Cale: s/game/software
07:22:23 <tulcod> notdan: you read the papers yet? :P
07:22:57 <ggVGc> nshepperd: also, if the game had a chat server, I'd use haskell for that. Or if it had a validator of transactions in the game
07:23:04 <Cale> ggVGc: Yeah, but *especially* for games, which tend to have many many "local" pieces of state that interact with each other over time.
07:23:06 <ggVGc> for thins like that, haskell or another FP language is great
07:23:23 <tzaeru> Cale, dunno. somehow, at least from my perspective, imperative (and, to degree, OOP) fits games very well, since games are basically a bunch of data with associated ways of modifying it. it makes very much sense to think of a game character as a bunch of collected data like position, velocity and health. how does FP fit into that?
07:23:42 <ggVGc> why do you have to make games that way though?
07:23:47 <ggVGc> just because we learnt it that way
07:23:57 <ggVGc> why is the world procedural and not functional?
07:24:00 <Cale> tzaeru: It's not like FP means you stop organising data into sensible collections :)
07:24:20 <Welkin> why is it not valid to have all the data in one place instead of encapsulated all over the place?
07:24:30 <Welkin> I think the FP approach is much easier to work with
07:24:32 <nshepperd> O_O my debian server has ghc 6.12
07:24:36 <ggVGc> I think FRP sounds like a greaet fit for game development, but I don't know it well enough to use t yet
07:24:42 <notdan> tulcod: nope. I got a bit stuck working through Pitts' paper. I will read more Hofmann
07:24:44 <ggVGc> nshepperd: see, good times
07:24:46 <bennofs> tzaeru: maybe you should also watch the reflex presentation by ryan :)
07:25:05 <Cale> tzaeru: FRP is about expressing how things vary over time in a somewhat more declarative way though. There are two main concepts which most FRP libraries try to reflect somehow
07:25:08 <tzaeru> I don't really understand it nor buy into it.
07:25:22 <nshepperd> oh... debian squeeze is the obsolete version. I should probably upgrade that....
07:25:24 <tzaeru> of course, I can be proved wrong tho ^,^
07:25:31 <Cale> tzaeru: You have behaviours, which are values that vary over time, and any time you look at them, they have a value
07:25:53 <tzaeru> game state is a thing that is generally strongly driven through input, though.
07:25:57 <bennofs> the reflex presentation shows a simple twitter client being built using FRP
07:26:02 <Cale> tzaeru: Things like, the current location of the mouse, the current HP of a monster, what needs to be drawn on the screen right now, ...
07:26:21 <tzaeru> it can stay static for hours, and then suddenly every connected player needs to become aware of an input that caused a bunch of things change in that state.
07:26:57 <Cale> tzaeru: and then you have events, which are things which occur at particular points in time, and have values at those times, like the sequence of keystrokes entered by the user, the sequence of attacks made by an AI, the sequence of sound assets to be played
07:27:06 <tulcod> quickly though, is reflex the Next Big Thing in FRP, and can we ditch reactive bananas?
07:27:27 <Cale> tzaeru: FRP is about defining libraries which implement those two concepts, and provide lots of ways to construct new behaviours and events from others.
07:27:43 <tzaeru> well, I guess it'll be seen how much interest it picks
07:28:16 <Cale> tzaeru: And right, absolutely, you want propagation of state to be efficient, and you want things which are static not to be recomputed every frame
07:28:23 <Cale> and that's what FRP is kind of all about
07:28:44 <Cale> Putting the logic for how to do that efficiently into a library, so you can get it right once and reuse it.
07:29:39 <ggVGc> yep
07:29:45 <Cale> It's sort of like what people do with game engines, only slightly more abstract, and really applies to many other kinds of software
07:29:47 <ggVGc> I think FRP is very suitable for game development
07:29:57 <ggVGc> I don't think we've developed it far enough yet though
07:30:28 <Cale> Yeah, it's still in its infancy, we know there's something there, but we're not 100% sure what it is and how to do it extremely well yet.
07:30:47 <Cale> But have a look at Ryan's demo for some nice examples in a completely different space (web applications)
07:30:48 <Welkin> it takes at least 20 years before a new technology is widely adopted
07:30:49 <tzaeru> mmh. well, maybe I've learned myself some FP properly by then.
07:30:53 <tzaeru> I suppose there's plenty of time >:D
07:31:00 <ggVGc> Cale: btw, I thin your short description was very good, from what I know of FRP. It sounds like how I largely understand it also
07:31:22 * hackagebot data-clist 0.0.7.4 - Simple functional ring type.  http://hackage.haskell.org/package/data-clist-0.0.7.4 (jeremyjh)
07:31:30 <tulcod> Welkin: i would be surprised if FRP has not beer around for 20 years yet. also, haskell itself if 25 years old.
07:31:37 <ggVGc> tzaeru: you can start by using FP in watever language you prefer. Things like lodash/underscor in javascript are functional libraries for use in imperative languages
07:31:44 <ggVGc> and C# has a lot of FP in it now
07:32:24 <tulcod> hm, wikipedia says "FRP has taken many forms since its introduction in 1997." so that gives you 2 more years, Welkin 
07:32:25 <tzaeru> I usually try to avoid the functional programming packages in languages like Python. they just never really work that well without needing a whole ton of extra code to be written around them.
07:32:34 <tzaeru> and don't really answer any problems I have better than what writing a short loop would
07:32:55 <ggVGc> sounds like you are thinking about it wrong
07:33:00 <Welkin> tulcod: http://conal.net/papers/frp.html
07:33:32 <Welkin> those are some of the originating papers
07:34:08 <arbelos> Do JS frameworks like Angular incorporate ideas from FRP? 
07:34:15 <Welkin> tzaeru: that is because python is not a functional language
07:34:20 <ggVGc> tzaeru: at the simplest level, [1,2,3,4] |> mulBy 2, reads a lot better than the equivalent imperative function call I reckon
07:34:21 <tzaeru> Welkin, oh! really?!
07:34:23 <Welkin> arbelos: yes, to some degree
07:34:25 <tzaeru> :O <--- mind, blown
07:34:42 <arbelos> It certainly feels like. But maybe there is a more general "overlap".
07:34:56 <bennofs> FRP takes JS frameworks call "data binding" a step further
07:35:31 <arbelos> yes, they don't really model values as time-varying in that sense
07:35:49 <arbelos> more that values update based on some response
07:35:55 <arbelos> which is different, i guess
07:36:13 <Welkin> React is the trend-setter in JS these days
07:36:28 <arbelos> is it "reactive"?
07:36:29 <Welkin> everyone realized that two-way data-binding is a terrible idea
07:36:38 <Welkin> arbelos: yes, it is based on FRP principles
07:36:49 <Welkin> and mutable data
07:36:58 <Welkin> er
07:37:01 <Welkin> immutable data
07:37:26 <tzaeru> those JS stacks change more often than I buy new cloth articles..
07:37:29 <arbelos> explicit state makes things more complicated, i would think
07:37:34 <capisce> well, it's more based on functional programming principles than FRP principles I'd say
07:37:48 <Welkin> well, facebook is leading the charge for making JS into a purely functional, staticaly typed language
07:38:16 <arbelos> sounds like a challenge
07:38:24 <tulcod> let me just cross-spam here: Are you an Xmonad developer (ish), and do you have some time this summer? Then I'd love to discuss with you the possibility for you to mentor me in a google summer of code effort to make Xmonad work on wayland. privmsg welcome. wayland experience not required.
07:38:36 <bennofs> Qt/QML also has properties which can be bound (you can even bind them to whole JS expressions and the update whenever one of the JS expression's dependent variable changes! really cool)
07:38:52 <arbelos> yes QML is pretty cool
07:39:12 <arbelos> Qt were pioneers with the whole signals/slots-paradigm
07:39:30 <bennofs> In fact, hsqml why I looked into FRP
07:39:57 <capisce> Elm on the other hand is FRP
07:40:09 <capisce> and yeah, QML in some ways
07:40:54 <arbelos> the "Observer pattern" is the OOP term i believe
07:40:59 <mauke> byorgey: are you there? I have a question about semirings / your paper
07:41:09 <tulcod> tzaeru: mere mortals have been using and still use jquery
07:41:17 <tzaeru> tulcod, which is kind of unfortunate..
07:41:23 * hackagebot process-streaming 0.7.2.0 - Streaming interface to system processes.  http://hackage.haskell.org/package/process-streaming-0.7.2.0 (DanielDiazCarrete)
07:41:59 <arbelos> DOM manipulation without jQuery is quite painful
07:42:18 <mauke> byorgey: specifically, https://github.com/byorgey/type-matrices/blob/master/type-matrices.lhs#L678 says 0 is an annihilator for ·
07:42:22 <Welkin> arbelos: you don't want to manipulate the dom
07:42:28 <Welkin> you want to redraw it
07:42:33 <tzaeru> yes, well, a lot of painful things have less painful solutions to them, but that doesn't make the thing non-painful.
07:42:54 <arbelos> Welkin, but in plain JS?
07:42:59 <bennofs> Welkin: or at least "pretend" to redraw it :)
07:43:06 <Welkin> no, using React
07:43:20 <Welkin> it diffs the changes to a virtual DOM
07:43:31 <tulcod> i once made this terribly complicated bookkeeping website that stored its data in the dom. every feature request by the client doubled the code size. he had a lot of feature requests, a new one every few weeks.
07:43:34 <arbelos> to be honest, in JS i have no idea what to do since there is a new framework every week
07:43:38 <tzaeru> I like how 10 years old laptops struggle in loading a simple modern website with all the angular and jquery libraries and multimedia content rolling in. it's sad.
07:43:43 <mauke> byorgey: but then an example is given of (ℝ⁺, max, 0, +, 0), so addition plays the role of ·. but 0 is not an annihilator for addition. is this a bug?
07:43:46 <Welkin> arbelos: React is the best bet
07:43:53 <tulcod> but it worked great, and i think it is still being used
07:43:58 <Welkin> it is built/used by facebook and has been around for a while now
07:44:04 <arbelos> Welkin, I'll have a look at it.
07:44:09 <tzaeru> like your page can have just a small graph for 10 data points and some simple server-communication with an interactive login-page and that HP laptop is going to go "oh my god I don't wanna do this :("
07:44:29 <capisce> Welkin: React is still manipulating the DOM
07:44:41 <capisce> it's not replacing the entire DOM each time, only the parts that need changing
07:45:32 <capisce> you can have Virtual DOM with ELM too: http://elm-lang.org/blog/Blazing-Fast-Html.elm
07:47:37 <Cale> mauke: I think it was perhaps intended to be this? http://en.wikipedia.org/wiki/Max-plus_algebra
07:49:09 <Cale> Also known as the tropical semiring
07:49:28 <mauke> ok, that makes more sense than non-negative reals
07:51:23 * hackagebot json-schema 0.7.3.4 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.7.3.4 (AdamBergmark)
07:56:03 <mauke> "Tropical surfaces are exactly the non-Archimedean amoebas over an algebraically closed non-archimedean field K."
07:56:22 <mauke> why are we letting mathematicians use words
07:56:44 <tulcod> because they are too stubborn to use proof assistants
07:57:16 <mauke> but then we get gibberish like "tropical surfaces are non-archimedean amoebas"
07:58:07 <Yaniel> still better than some commit messages I've seen
07:58:14 <tulcod> somewhat in their defense, the physicists have particles with weird names
07:59:51 <bennofs> Does anyone have an idea what could cause this criterion output? http://bennofs.github.io/reflex.html
08:00:05 <bennofs> (the few outliners in head/merge100)
08:03:06 <Cale> mauke: I don't see what the problem is :)
08:03:21 <Cale> http://en.wikipedia.org/wiki/Amoeba_(mathematics)
08:03:43 <Cale> They really do look like amoebas!
08:06:22 <mauke> "A two-dimensional amoeba has a number of "tentacles" which are infinitely long and exponentially narrow towards infinity."  just like real amoebas!
08:06:40 <Cale> exactly!
08:08:11 <nszceta> I am now using Ractive
08:08:33 <nszceta> After permanently abandoning Angular
08:08:38 <nszceta> http://www.ractivejs.org/
08:09:20 <nszceta> the JS software environment is highly annoying to work with due to the insane pace of innovation
08:10:13 <Cale> nszceta: Not Reflex? :D
08:10:39 <nszceta> reflex has fewer contributors and supporters
08:10:42 <Cale> nszceta: Did you see that demo earlier? :)
08:10:54 <nszceta> negative
08:10:58 <quchen> nszceta: http://static1.squarespace.com/static/518f5d62e4b075248d6a3f90/t/54687528e4b0768e168b3c76/1416131884224/?format=1000w ;-)
08:10:59 <bennofs> Cale: i also first read Reactive instead of Ractive and was about to say that Reactive is not actively developed afaik :)
08:11:26 <nszceta> Oh god
08:11:43 <nszceta> Take that Java culture away, PLEASE
08:11:44 <Cale> nszceta: Pt1: https://www.youtube.com/watch?v=mYvkcskJbc4  Pt2: https://www.youtube.com/watch?v=3qfc9XFVo2c  Interactive slides: https://obsidian.systems/reflex-nyhug/
08:12:03 <bennofs> So just pass Nothing for the Maybe PanelContentProviderInitializerFactoryBuilder :)
08:12:18 <nszceta> I am sure reflex is sweet but its not mature enough for me to consider
08:12:21 <nszceta> if its around another year i'll take a look
08:12:35 <nszceta> those slides are slick
08:12:45 <mr-_> nszceta: how much is that in Javascirpt-years?
08:12:48 <nszceta> 40
08:12:51 <Cale> The slides are written in reflex :)
08:12:52 <bennofs> whatever you do with reflex, do not look at the spider implementation :p (weak pointers everywhere! :/)
08:12:59 <nszceta> probably the biggest improvement in javascript ever made was typescript
08:13:02 <bennofs> Cale: well, and impressjs
08:13:04 <nszceta> which is what my company uses in production
08:13:18 <nszceta> typescript brings some serious order to the chaos
08:13:46 <nszceta> https://eng.asana.com/2014/11/asana-switching-typescript/
08:14:46 <mauke> the slides are ugly
08:15:08 <nszceta> lmao
08:15:17 <mauke> the text scrolls into view, then the font resets slightly
08:15:21 <nszceta> http://www.openbsd.org/papers/
08:15:23 <nszceta> click through these links
08:15:28 <sammecs> Hi, when does GHC link a package / create a executable?
08:15:29 <nszceta> http://www.openbsd.org/papers/hackfest2014-arc4random/index.html
08:15:37 <nszceta> http://www.openbsd.org/papers/hackfest2014-arc4random/mgp00002.html
08:15:40 <nszceta> tell me this is better
08:15:47 <sammecs> So when I compile my file, GHC doesn't create a executable...
08:16:41 <quchen> sammecs: Going all the way to an executable is GHC's default behaviour.
08:16:55 <mauke> sammecs: is your file a program?
08:17:05 <bennofs> sammecs: did you put anything else than module Main at the top of your file?
08:17:32 <sammecs> bennofs: My file is not called "Main", but it contains a method main
08:17:59 <mauke> "method"
08:18:03 <mauke> java programmer?
08:18:20 <sammecs> mauke: Yes, but changed to haskell ;)
08:18:36 <mauke> sammecs: 1) are you trying to create an executable?  2) what's in your file?  3) how are you invoking ghc?
08:19:43 <sammecs> mauke: 1) Well, I thought that's what GHC does... I invoke "ghc foo.hs". 2) "methods" and a module declaration and a main function.
08:19:54 <mauke> wow, those slides ... it looks like the code samples are bold while scrolling, then reset to normal after stopping
08:20:01 <mauke> sammecs: 1) is that a yes or no?
08:20:14 <mauke> sammecs: 2) I was asking for the exact content, not a paraphrase
08:20:25 <sammecs> mauke: I want to create an executable, if that's what you're asking for...
08:20:29 <mauke> ok, good
08:20:38 <mauke> that leaves 2) and 3)
08:21:04 <sammecs> mauke: So... should I paste the contents here (pastebin)?
08:21:25 * hackagebot fltkhs 0.1.0.2 - FLTK bindings  http://hackage.haskell.org/package/fltkhs-0.1.0.2 (deech)
08:21:31 <mauke> @where lpaste
08:21:31 <lambdabot> http://lpaste.net/
08:21:38 <mauke> there :-)
08:21:48 <mauke> "Sorry, this slide uses WebComponents, which your browser does not seem to support! Please try it in Chrome or take a look at http://caniuse.com/#feat=shadowdom for more information" <- what the heck
08:22:36 <mauke> yay, let's use chrome-only features in our slides
08:22:36 <nshepperd> sammecs: if your module starts with 'module Foo where' and Foo is not Main, then ghc will not create an executable by default
08:22:50 <sammecs> mauke: Speaking of a "Main"-module... I just renamed the file and the module declaration *in* the file and it worked.
08:23:16 <Gurkenglas> What should I call a ([a] -> a -> Either a [a])? archiveOrReturn sounds stupid.
08:23:17 <bennofs> sammecs: yes. you may not name your module different from Main if you wish to create an executable. The file name does not matter though afaik
08:23:19 <nshepperd> sammecs: in fact, the entry point for a haskell program is Main.main
08:23:35 <bennofs> Gurkenglas: what does that do?
08:23:41 <sammecs> oh, ok. I will remember that
08:24:00 <mauke> sammecs: the name of the file doesn't matter
08:24:58 <Gurkenglas> bennofs, given xs and x it returns either Left x or Right (x:xs), depending on xs and x.
08:24:59 <sammecs> mauke: Yes, still following the "the file has to be named after the module its containing"-philosophy...
08:25:25 <aruro> is it possible to create new types on runtime? or collection of types restricted to the source one?
08:25:26 <bennofs> Gurkenglas: so, like checkNonempty?
08:25:31 <mauke> sammecs: that's only required for loadable modules, not programs
08:25:47 <bennofs> aruro: I think there may be infinitely many types
08:25:47 <tulcod> Gurkenglas: depending on what?
08:26:01 <mauke> sammecs: programs are all in module Main (because the entry point is Main.main), so that could get unwieldy for simple stuff
08:26:54 <tulcod> Gurkenglas: is this the full type signature, or does `a` have a more specific type?
08:26:57 <Gurkenglas> It occurs to me that evil, evil Eq instance reimplementation allows me to say that it checks whether xs already contains x
08:27:02 <mauke> aruro: using polymorphic recursion you can instantiate type schemas at runtime
08:27:43 <Gurkenglas> (Is it an Eq law that x == y => f x == f y?)
08:27:45 <tulcod> Gurkenglas: and if x is already in xs, why would you want to return `Left x`? you already know the value of x - you just supplied it! why not return Nothing?
08:28:18 <tulcod> Gurkenglas: if that would not be the case, that would be extremely confusing and non-mathematical
08:28:24 <tulcod> (re: x ==y )
08:28:44 <nshepperd> I don't think so
08:28:56 <nshepperd> I think Eq is allowed to represent equivalence classes
08:28:59 <mauke> > let foo :: (Show a) -> Int -> a -> String; foo 0 x = show x; foo n x = foo (n - 1) (x, ()) in foo 0 ()
08:29:00 <lambdabot>      Expected a type, but ‘Show a’ has kind ‘Constraint’
08:29:00 <lambdabot>      In the type signature for ‘foo’:
08:29:00 <lambdabot>        foo :: (Show a) -> Int -> a -> String
08:29:19 <mauke> > let foo :: (Show a) => Int -> a -> String; foo 0 x = show x; foo n x = foo (n - 1) (x, ()) in foo 0 ()
08:29:21 <lambdabot>  "()"
08:29:23 <mauke> > let foo :: (Show a) => Int -> a -> String; foo 0 x = show x; foo n x = foo (n - 1) (x, ()) in foo 5 ()
08:29:24 <lambdabot>  "((((((),()),()),()),()),())"
08:29:27 <mauke> there we go
08:29:52 <Gurkenglas> tulcod, I'm not returning Nothing because I'm using the special properties of the Either a monad.
08:30:31 <aruro> by type shemas you mean types which structure is more or less known to program?
08:30:38 <tulcod> Gurkenglas: addIfNotInsideEither ?
08:30:55 <Gurkenglas> ...sure, whatever :D
08:30:57 <dot_Laptop> foo
08:31:21 <dot_Laptop> How do I use lambdabot/its manual?
08:31:22 <mauke> aruro: yes. in the example above, it is nested tuples
08:31:24 <deech> Hi all, I'm trying to PUT a documentation tar.gz directly into Hackage and I'm getting the error: "There is an error in the gzip encoding of the uploaded data". Running `file` on it tells me that it is indeed a gzip file. What am I doing wrong?
08:31:53 <dot_Laptop> > foo
08:31:54 <lambdabot>      Not in scope: ‘foo’
08:31:55 <lambdabot>      Perhaps you meant ‘T.for’ (imported from Data.Traversable)
08:32:13 <mauke> deech: 'file' doesn't mean much. it just guesses
08:32:33 <aruro> :t ()
08:32:33 <deech> mauke: I tried gunzipping that file and it worked too ...
08:32:34 <lambdabot> ()
08:33:07 <hpc> file is pretty trustworthy for formats that have magic bytes
08:33:27 <aruro> :t (1,())
08:33:28 <lambdabot> Num t => (t, ())
08:33:33 <tulcod> deech: tried this? http://neilmitchell.blogspot.nl/2014/10/fixing-haddock-docs-on-hackage.html
08:33:43 <aruro> :t (1,(2,()))
08:33:44 <lambdabot> (Num t, Num t1) => (t, (t1, ()))
08:33:47 <mauke> hpc: not if you have a valid header with damaged contents
08:34:05 <mauke> deech: then I don't know
08:34:19 <aruro> :t foo
08:34:21 <lambdabot>     Not in scope: ‘foo’
08:34:21 <lambdabot>     Perhaps you meant ‘T.for’ (imported from Data.Traversable)
08:34:35 <aruro> > let foo :: (Show a) => Int -> a -> String; foo 0 x = show x;  |               foo n x = foo (n - 1) (x, ()) in foo 5 ()
08:34:36 <lambdabot>  <hint>:1:63: parse error on input ‘|’
08:35:01 <aruro> forgot to add @let
08:36:25 * hackagebot wai-extra 3.0.7 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.7 (MichaelSnoyman)
08:38:45 <aruro> @let polyfoo :: (Show a) => Int -> a -> String ; polyfoo 0 x = show x; polyfoo n x = polyfoo (n-1) (x, ())
08:38:46 <lambdabot>  Defined.
08:38:52 <aruro> :t polyfoo
08:38:53 <lambdabot> Show a => Int -> a -> String
08:39:14 <aruro> polyfoo 5 'a'
08:39:17 <aruro> > polyfoo 5 'a'
08:39:20 <lambdabot>  "((((('a',()),()),()),()),())"
08:39:30 <aruro> :t it
08:39:32 <lambdabot>     Not in scope: ‘it’
08:39:32 <lambdabot>     Perhaps you meant one of these:
08:39:32 <lambdabot>       ‘id’ (imported from Data.Function),
08:39:40 <aruro> >:t polyfoo 5 'a'
08:39:43 <deech> :new
08:39:46 <deech> oops
08:39:52 <aruro> :t polyfoo 5 'a'
08:39:53 <lambdabot> String
08:40:20 <aruro> hm
08:40:28 <aruro> tricky, because of show
08:41:03 <aruro> so the idea is that last type has to be fixed?
08:41:31 <mauke> @let polybar :: (Show a) => Int -> a -> String ; polybar 0 x = show x; polybar n x = polybar (n-1) [x,x]
08:41:33 <lambdabot>  Defined.
08:41:37 <mauke> > polybar 5 'a'
08:41:38 <lambdabot>  "[[[[\"aa\",\"aa\"],[\"aa\",\"aa\"]],[[\"aa\",\"aa\"],[\"aa\",\"aa\"]]],[[[\...
08:41:53 <aruro> yes
08:42:01 <aruro> very nice :) can we get rid from show?
08:42:57 <bennofs> aruro: no, since you need a typeclass to observe types at runtime
08:43:10 <Gurkenglas> Should I rather apply foldr (:) [] or foldr (:) undefined to a right-infinite Foldable?
08:43:41 <aruro> so if i understand correctly function can be of the form  a -> b -> c -> FIXED type
08:43:44 <aruro> ?
08:43:48 <hpc> use []
08:43:58 <hpc> it's more clear that what you're doing is some sort of id
08:45:21 <aruro> wait a minute, this function does not generate new types :)
08:45:28 <aruro> there is no way get them out from it
08:45:36 <mauke> > let foo :: (Show a) => Int -> a -> (forall b. Show b => b -> c) -> c; foo 0 x k = k x; foo n x = foo (n - 1) (x, ()) k in foo 5 () show
08:45:36 <aruro> they are always reduced to String
08:45:37 <lambdabot>      Equations for ‘foo’ have different numbers of arguments
08:45:37 <lambdabot>        <interactive>:1:71-85
08:45:37 <lambdabot>        <interactive>:1:88-118
08:45:39 <hpc> you do what you need within the function
08:45:55 <mauke> > let foo :: (Show a) => Int -> a -> (forall b. Show b => b -> c) -> c; foo 0 x k = k x; foo n x k = foo (n - 1) (x, ()) k in foo 5 () show
08:45:56 <lambdabot>  "((((((),()),()),()),()),())"
08:45:58 <bennofs> aruro: what should be the return type of a function which has a type that you generate at runtime?
08:46:13 <mauke> there, now the function type has no fixed elements (apart from Int)
08:46:22 <funfunctor> @hoogle [Word8] -> Word16
08:46:24 <lambdabot> Data.List genericLength :: Num i => [b] -> i
08:46:25 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
08:46:25 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
08:46:44 <aruro> mauke, ty
08:46:47 <hpc> similarly to IO, you don't "get the type out", you decide what you want to do and apply it inside
08:47:21 <aruro> so my question is basically about the fact the program does not seem to be able to generate new types on the fly
08:47:23 <mauke> > let foo :: (Show a) => Int -> a -> (forall b. Show b => b -> c) -> c; foo 0 x k = k x; foo n x k = foo (n - 1) (x, ()) k in foo 5 () (length . show)
08:47:24 <lambdabot>  27
08:47:28 <aruro> accoding to some algorythm
08:47:33 <funfunctor> with attoparsec what is the best way to parse out a Word16?
08:47:41 <mauke> funfunctor: depends on the syntax
08:48:06 <funfunctor> mauke: its a serialized binary stream
08:48:13 <mauke> funfunctor: depends on the syntax
08:48:40 <funfunctor> how do you mean, its just bytes after bytes being packed into a gadt
08:48:50 <funfunctor> record, whatever
08:48:54 <Gurkenglas> Should I use the find from Foldable rather than the one from List even when working with lists?
08:49:08 <mauke> funfunctor: which bytes packed how?
08:49:10 <funfunctor> so data Foo = Foo { a :: !Word16, b :: !Word8 }
08:49:18 <mauke> i.e. what is the syntax of your "binary stream"?
08:49:35 <funfunctor> what do you mean "syntax" its a pure binary stream
08:49:40 <nshepperd> umm, if it's just word8s isn't that just "read two word8s, do some bit shifting"
08:49:47 <monochrom> funfunctor: let's say "format"
08:49:52 <gregnwosu> i have been reading about free monads, but also faglebras and catamorphisms and the two seem very similar
08:49:53 <mauke> funfunctor: that's like saying "what do you mean syntax, it's pure text"
08:50:09 <capisce> what's a faglebra?
08:50:25 <gregnwosu> so much so that im a little confused as to the advantages of each compared to each other
08:50:39 <gregnwosu> capisce f-algebra
08:50:51 <capisce> oh
08:50:52 <monochrom> although it's uncommon to say "syntax of binary data" among the circle of people who use binary data, it makes sense and it is what they call "format of binary data"
08:51:00 <funfunctor> Sorry I dont understand what your asking me, are you asking me the endianness?
08:51:18 <Clint> that would be one important factor
08:51:19 <mauke> funfunctor: ... do you not how how serialization works?
08:51:26 * hackagebot orgmode-parse 0.1.0.4 - A collection of Attoparsec combinators for parsing org-mode  flavored documents.  http://hackage.haskell.org/package/orgmode-parse-0.1.0.4 (ParnellSpringmeyer)
08:51:29 <monochrom> i.e., once you understand that there is no fundamental difference between "stream of bits" and "stream of chars"
08:51:59 <funfunctor> mauke: that depends on what your serialising but after yes, you have byte and then another byte and then another..
08:52:05 <arcaedox> Hi guys cleaned up my code a little and it works just like the tutorial one , however I feel I have been a bit hacky in the use of transfer...? http://pastebin.com/SpnGDVx0
08:52:26 <monochrom> mauke, I think it's a good time to give up or start charging money
08:52:31 <mauke> funfunctor: what do those bytes mean/represent?
08:53:21 <funfunctor> mauke: they are just bytes, don't worry about the high level interpretation , see above (01:46:30 AM) funfunctor: so data Foo = Foo { a :: !Word16, b :: !Word8 }
08:53:26 <funfunctor> that will do as a example
08:53:42 <gregnwosu> arcedox are you looking for style pointers?
08:53:58 <nshepperd> funfunctor: I believe that what mauke is getting at is whether the Word16 has tags attached or what
08:54:01 <funfunctor> if I want to fetch the first Word16, I could do count 2 anyWord8 but then I end up with [Word8]
08:54:08 <mauke> nshepperd: ... no?
08:54:20 <funfunctor> nshepperd: "tags" ?
08:54:36 <mauke> funfunctor: dude, you just told me not to worry about the high level interpretation. what do you need a parser for then?
08:54:45 <mauke> funfunctor: you already have a list of "just bytes"
08:55:08 <monochrom> why is it not 1 anyWord16?
08:55:41 <mauke> why is it not LBC8.pack (show n)
08:55:47 <funfunctor> My question is very very simple, I want to fetch 2 bytes out of a stream using attoparsec, anyWord8 gives me 1 byte, count 2 anyWord8 gives me [Word8] but I want a anyWord16
08:55:52 <funfunctor> I didn't see it in the api
08:56:32 <monochrom> ok, you can multiply one word8 by 256 and add the other word8. you know that?
08:56:35 <nshepperd> funfunctor: never mind. what's wrong with anyWord16BE = do { a <- anyWord8; b <- anyWord8; return (fromIntegral a `shiftl` 8 + fromIntegral b) }
08:57:37 <funfunctor> nshepperd: so thats what I did but I was looking for something neater
08:57:39 <monochrom> must you use attoparsec? why is it not binary?
08:58:07 <funfunctor> monochrom: I wanted a little more control than the Get monad
08:58:15 <funfunctor> for later down the track
08:58:30 <mauke> XY detector overload
08:58:50 <nshepperd> funfunctor: if anyWord16BE was defined in the api, it would probably be written like that
08:58:56 <hpc> mauke: real programmers use Z
08:59:15 <monochrom> mauke: have you heard of XYX problems? :)
08:59:22 <funfunctor> nshepperd: yea but is it in the API somewhere
08:59:25 <funfunctor> I didn't see it
08:59:32 <funfunctor> @hoogle anyWord16
08:59:34 <lambdabot> No results found
08:59:48 <funfunctor> @hoogle anyWord16BE
08:59:49 <lambdabot> No results found
08:59:51 <Clint> @hoogle getWord16
08:59:52 <lambdabot> No results found
08:59:53 <mauke> monochrom: no
09:00:29 <mauke> http://hackage.haskell.org/package/binary-0.7.4.0/docs/Data-Binary-Get.html#v:getWord16be
09:02:01 <monochrom> "I want to solve X. I can transform it to Y and translate Y's solution back into X's solution." then, while solving Y...
09:02:13 <Gurkenglas> http://lpaste.net/130595 -- A little proud and a little ashamed of this one. Suggestions on style and patterns and the like, please?
09:02:36 <monochrom> "I want to solve Y. I can transform it to X and translate X's solution back into Y's solution". then, a bit later, X is solved, but...
09:02:57 <monochrom> "so now I translate X's solution back into Y's solution, and then translate that back into X's solution"
09:03:50 <monochrom> there is an example in the CIS194 course, the credit card question. either the question itself is an XYX problem, or most students do it an XYX way. I forgot. but here it goes...
09:05:32 <monochrom> an Integer is given. (it is intended to be a credit card number.) convert it into its list of digits, then apply a checksum algorithm to the list. the checksum algorithm is leaned towards the least significant side, i.e., it talks about "sum up every other digit, starting from the least significant digit", something like that
09:06:52 <monochrom> because both converting to list of digits and the checksum algorithm lean towards the least significant digit, a sane person will use this convention: in the list, the earlier items are the less significant digits.
09:07:50 <mauke> that depends on how you do the conversion
09:08:00 <mauke> map digitToInt . show
09:08:07 <monochrom> but insane people insist on the following: in the list, the earlier items are the more significant digits. therefore, during conversion from Integer to list of digits, they have to do one reverse at the end. then, during the checksum algorithm, they have to do one reverse at the beginning.
09:08:48 <monochrom> I'm pretty sure show for Integer does least significant digits first, and then reverse at the end
09:09:10 <mauke> yeah, but that's not apparent from just looking at 'show'
09:10:01 <monochrom> well, if the exercise encouraged you to use show, I would not be saying all this. the exercise encourages you to write your own converter.
09:10:03 <Gurkenglas> They are probably thinking that they are sacrificing insignificant performance for what they see as sanity
09:10:25 <monochrom> I am not talking about performance. I am talking about the XYX problem.
09:10:43 <monochrom> "I want to reverse so that I have to reverse again later"
09:11:15 <mauke> you know what? that sounds bit like 2 loops
09:12:46 <funfunctor> So I know how to use the Get monad for binary parsing out Word16 but that does not help me with attoparsec
09:13:01 <frerich> monochrom: Are you talking about http://www.seas.upenn.edu/~cis194/hw/01-intro.pdf ? It seems that the final function 'luhn' which tells whether some Integerr is a valid credit card number is specifically meant to be implemented in terms of the smaller functions developed in earlier exercises. Maybe 'Y' in 'XYX' is defined vy the homework.
09:13:05 <nshepperd> if the intermediate format is more familiar and therefore easier to think about, that does not seem necessarily insane
09:13:32 <monochrom> frerich: yes.
09:14:02 <nshepperd> funfunctor: there's nothing wrong with just defining your own anyWord16**
09:14:06 <monochrom> I am happy to agree that the question itself requires you to do an XYX problem
09:17:20 <monochrom> nshepperd: a system in which each small part is intuitive in isolation, but the whole makes you go "why do you even do that?", is the very definition of bureaucracy
09:20:42 <orbifx> Hello
09:20:57 <orbifx> Has anyone one used libssh for Haskell?
09:21:56 <orbifx> My question is more regarding Haskell in general rather then libssh specific
09:21:59 <srhb> orbifx: If you pose your question, people may be able to help you regardless.
09:22:18 <orbifx> One of the main functions of executing a remote command with libssh
09:22:35 <frerich> Gurkenglas: I think loopSize is quite hard to read.
09:23:43 <nshepperd> monochrom: But I understand perfectly why one would do that. It's so that the individual parts can be understood intuitively. (And, perhaps, reused for other purposes.)
09:23:48 <srhb> orbifx: Yes?
09:23:59 <orbifx> Expects actions as a list. I want to a embed libssh in hsqml. I want to instantiate the ssh connection using libssh, but without having the actions in advance, passing them in as the execution goes along. At this point I have to reconnect every time I want to execute a command. Any ideas?
09:24:45 <srhb> orbifx: Is it the libssh2 bindings?
09:24:53 <orbifx> Yes
09:24:57 <tew88> Hoping someone can help resolve my Cabal/Stackage issue.  I've done a fresh install of GHC and cabal-install with Homebrew.  I've followed the instructions on Stackage to get up and running with that, however, I seem to be hitting "Cabal Hell" on what I think must be a clean system when attempting to install happy and alex.  Error: http://paste.ee/r/Vyvmf -- any suggestions?
09:24:59 <monochrom> nshepperd: probably because you haven't seen a better way that does the best of both worlds. here is how to have the best of both worlds:
09:25:05 <orbifx> Example code here: https://github.com/portnov/libssh2-hs/blob/master/libssh2/ssh-client.hs
09:25:34 <arcaedox> Thanks a lot guys till the next !
09:25:44 <arcaedox> bye..
09:25:55 <monochrom> in a previous question, ask the student to do both: convert to list of digits, most-significant first; convert to list of digits, least-significant first.
09:26:36 <srhb> orbifx: Can't you just open a Session and use it later with withChannel?
09:27:10 <orbifx> srhb: how to extract the session?
09:27:11 <monochrom> remark two points: 1. one of them may simply call the other and then reverse, you figure out which one is easier for you; 2. both conventions have their use cases, this is why this exercise makes you provide both
09:27:21 <srhb> orbifx: sessionInit?
09:28:05 <orbifx> srhb: sessionInit seemed internal to me, was it that simple?
09:28:06 <monochrom> this has many benefits. in addition to promoting reuse, it furthermore promotes deeper thinking of design, the design space, tradeoffs, how to use a data structure to really fit a task
09:28:44 <srhb> orbifx: It's in the main Network.SSH.Client.LibSSH2 module, so i would certainly assume so.
09:28:47 <orbifx> so call sessionInit and pass the session as a paramete to the callback function I have in hsqml?
09:28:55 <srhb> orbifx: Something like that.
09:29:02 <orbifx> ok
09:29:15 <Gurkenglas> frerich, better? http://lpaste.net/130596
09:29:19 <srhb> orbifx: I've never used it, but judging by the types that seems completely reasonable.
09:29:24 <nshepperd> monochrom: that seems very sensible
09:29:41 <nshepperd> it just strikes me as melodramatic to call doing things the easy way 'insane'
09:29:47 <orbifx> Out of "academic" curiosity, is there another way, of partially applying ssh, and binding the actions parameter to one that is later provided?
09:29:57 <orbifx> srhb: I will try out that just now and see how it works.
09:30:09 <orbifx> (using sessionInit I mean)
09:30:46 <Gurkenglas> Whoops, missed a line. http://lpaste.net/130597
09:31:16 <joneshf-laptop> dibblego, does `coordinate` support distances?
09:31:28 <srhb> orbifx: You can always (\session -> ssh session myActions)
09:31:39 <joneshf-laptop> dibblego, I'm not sure the terminology, either flat point to point, or spherical distances?
09:31:59 <srhb> orbifx: Or was it the other way around you wanted.
09:32:00 <absence> what's that famous library for profiling called? google is being very unhelpful
09:32:02 <joneshf-laptop> dibblego, or is there perhaps a package built upon it tht does?
09:32:06 <orbifx> srhb: that is pressuming I had a session, so the other way around
09:32:14 <srhb> orbifx: Either way, parameter order is irrelevant, you can always fill in in the order you prefer
09:32:33 <srhb> absence: Criterion?
09:32:34 <joneshf-laptop> absence, criterion?
09:32:40 <joneshf-laptop> srhb, jinx
09:32:43 <srhb> :O
09:32:54 <absence> srhb, joneshf-laptop: correct, thanks
09:33:42 <joneshf-laptop> wasn't there a reverse dependency thing for hackage?
09:33:48 <srhb> Yes.
09:34:10 <srhb> Or well, it's on a mirror.
09:34:10 <joneshf-laptop> am i shit at finding it then? :)
09:34:19 <srhb> http://packdeps.haskellers.com/reverse
09:34:28 <orbifx> srhb: so how would I bind in a "do" section the last parameter of the withSSH2 
09:34:31 <orbifx> ?
09:34:37 <joneshf-laptop> srhb, thanks
09:35:47 <srhb> orbifx: Given f x y z = ... you can always do (\z y x -> f x y z) or whatever order you prefer
09:36:32 <absence> hm, criterion doesn't measure memory usage, does it?
09:37:46 <frerich> Gurkenglas: Not sure I get it now - but the idea is to look for the first time some element is repeated and then consider that a loop? I guess it's a difficult problem, think e.g. [1,2,3,4,2,3,4,2,3,4,5,6,7]. You probably make some assupmtions about the list?
09:38:55 <orbifx> srhb: sure, but my question is about the notiation of binding a parameter of a function to a result of something that comes later.
09:39:28 <orbifx> srhb: do; actions <- withSSH _ _ _ _ parameter_to_bind
09:39:42 <Gurkenglas> I failed to paste the instructions into the latest pastes. The Nodes form a graph, and equality on nodes implies that they point to the same location in the graph, so the first reoccurence of an element indeed points out an eternal cycle.
09:40:05 <orbifx> srhb: This might be stupid and unecessary in Haskell, I am learning it at this stage.
09:40:07 <srhb> orbifx: I'm not sure I follow. let withSSH' a b c d = withSSH a b c d yourParam
09:40:19 <Gurkenglas> *frerich
09:40:25 <srhb> orbifx: Given that yourParam is already defined
09:40:46 <srhb> orbifx: I may be misunderstanding you completely.
09:41:13 <orbifx> srhb: the parameter is a list of actions, which are not available yet.
09:41:28 <srhb> orbifx: but then there's no problem
09:41:34 <srhb> orbifx: withSSH is already in the order you want
09:41:39 <orbifx> srhb: So i want to call my function, get it started and going, but feed in more elements in that list.
09:41:44 <srhb> orbifx: applying it to a b c d yields a function that takes the action list
09:41:53 <srhb> Oooooh
09:42:00 <orbifx> srhb: :D
09:42:02 <Gurkenglas> I now notice that since only Eq, not Ord, is given, hashmappy or treey data structures would not accelerate the algorithm, so the fact that my solution still times out the codewars.com checker implies I introduced an inefficiency somewhere. Can someone point it out, or explain how to profile code?
09:42:12 <orbifx> srhb: Sorry I am learning even the lingo now :P
09:42:42 <srhb> orbifx: OK, depending on how withSSH works it might be sufficient to feed it a lazy list 
09:43:14 <orbifx> srhb: Lazy list, that is what I want :D how would that be written?
09:43:53 <Gurkenglas> Oh right, that last one is general enough to be googleable, I'll do that.
09:43:58 <orbifx> srhb: my first reaction to this problem was to solve it using a lazy list, which I bind to something and give it to my callback method.
09:44:37 <orbifx> srhb: than I can call withSSH2, bind its action list to my lazy list and proceed to doing my GUI stuff
09:44:44 <srhb> orbifx: Not sure about callbacks and such. Basically the call to withSSH should feed it the final parameter which is all the actions, even if they are not all there "yet"
09:45:19 <orbifx> srhb: yeah, how is that achieved in a _do_ segment?
09:45:54 <srhb> orbifx: actions <- actionMakingFunction; withSSH a b c d actions
09:46:06 <srhb> Assuming actionMakingFunction is IO [action]
09:47:18 <srhb> orbifx: This is assyming that withSSH doesn't deepseq the list first or something. Refer to its implementation to see if it handles lazy lists well. :0
09:47:20 <srhb> :) *
09:48:15 <srhb> Otherwise nothing will be done until the list is terminated.
09:48:25 <orbifx> srhb: ok. I'll have a look. I am really new to this, so the lack of experience makes it daunting, but that is how to learn.
09:49:10 <orbifx> srhb: For now I am going to use the session as a parameter, but I will then look into that approach too, cause I wouldnt have to be passing "session" around
09:49:42 <srhb> orbifx: Sure. Perhaps it would be simpler to try something like do { ls <- replicateM 10 getLine; mapM_ (putStrLn . (++" -- this is a line!)) ls } -- and understand how that works
09:50:16 <orbifx> srhb: from what I have learned so far, once I have bound actions <- function, I can only "read" actions right? Can't have something else feeding to it?
09:51:33 <srhb> orbifx: I don't feel comfortable answering that in the general. Suppose your action was the creation of a queue, and some other thread was feeding that queue..
09:53:28 <orbifx> srhb: ok that is outwith my domain just now :P
09:53:38 <HeladoDeBrownie> orbifx, once you have something bound as a variable, that variable's value never changes. however, the action that bound it can give a different result later.
09:53:41 <orbifx> srhb: let me try the session and the binding methods and get back to you.
09:53:45 <srhb> orbifx: Suffice to say there are plenty of structures that can be read and written to.
09:59:34 <orbifx> srhb: thanks for all the help. Hopefully I'll remember to come back and say how things went, although I have to go now.
10:00:08 <srhb> good luck
10:00:19 <srhb> orbifx: Oh and contrast previous example with   replicateM_ 10 (getLine >>= putStrLn . (++" -- this is a line!"))
10:00:22 <srhb> If you get the chance
10:01:07 <haskell052> Hi, I have problems constructing Writer monad. I want to do 'Writer "" 3', I have imported Control.Monad.Writer (Writer) and Control.Monad.Writer.Lazy. but it still cannot see the constructor Writer. It suggests using WriterT, but I am not yet familiar with transformations.
10:01:53 <haskell052> looking at hackage it should be there (in my scope).
10:01:55 <geekosaur> haskell052, Writer hasn't been a standalone monad for some years.
10:02:30 <geekosaur> Writer is a type synonym, yoiu cannot use it as a data constructor. however there is `writer` (lowercase) which should serve the same purpose as the original `Writer` data constructor
10:02:30 <haskell052> so I should learn to use Mona Transformation?
10:02:49 <geekosaur> in short: change `Writer` to `writer`
10:03:04 <haskell052> ok
10:03:47 <haskell052> what am I doing wrong here. I mean what should I use instead of 'writer'
10:03:48 <monochrom> you probably mixed up type names with value names
10:04:18 <haskell052> I read the book learnyouhaskell and Writer is used there
10:04:20 <geekosaur> I could repeat myself but I suppose it won't make any more sense this time
10:04:21 <monochrom> there is a type called Writer. this does not imply that there is a value called Writer. and indeed there is no such value.
10:04:34 <monochrom> ok, but learnyouhaskell is outdated on this
10:04:40 <geekosaur> LYAH is based on an *outdated version of the monad transformer library*
10:04:46 <geekosaur> in that version, Writer was its own thing
10:04:49 <geekosaur> as I already saud
10:04:58 <haskell052> what else should I read?
10:05:37 <haskell052> any suggestions ?
10:06:08 <geekosaur> @where learnhaskell
10:06:08 <lambdabot> https://github.com/bitemyapp/learnhaskell
10:06:16 <geekosaur> ^ list of modern haskell learning resources
10:06:50 <orbifx> HeladoDeBrownie: yeah, I know, don't know how to explain that you can affect the "flow" not the value of the bind.
10:07:09 <orbifx> gotta run, bbs
10:07:15 <haskell052> thx
10:08:23 <dot_Laptop> Hello. In this code http://lpaste.net/130598 , is ((->) t) a kind of function ? 
10:10:28 <funfunctor> what does *** Exception: Network.Socket.recvFrom: end of file (end of file) mean?
10:10:38 <geekosaur> it's sort of writing part of a function type in prefix form (that is, `(->) t x` would be the same as `t -> x`, in the same way that `(+) a b` is the same as `a + b`). in this case the x is not specified, just as in exercise 2 where the type is `Maybe a` but the instance is on `Maybe` without the `a`
10:10:39 <funfunctor> how can i be EOF on a socket?
10:11:08 <geekosaur> funfunctor, for a socket that means the other end of the stream was closed
10:11:35 <kuribas> @pl \x if x == 2 then Just 4 else Nothing
10:11:35 <lambdabot> (line 1, column 6):
10:11:35 <lambdabot> unexpected reserved word "if"
10:11:35 <lambdabot> expecting pattern
10:11:40 <dot_Laptop> thanks geekosaur
10:11:42 <kuribas> @pl \x -> if x == 2 then Just 4 else Nothing
10:11:42 <lambdabot> flip (flip if' (Just 4) . (2 ==)) Nothing
10:11:52 <kuribas> :t if'
10:11:53 <lambdabot>     Not in scope: ‘if'’
10:11:53 <lambdabot>     Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
10:11:58 <tulcod> dot_Laptop: https://wiki.haskell.org/Kind
10:12:14 <funfunctor> geekosaur: ah ok, thx!
10:12:24 <funfunctor> yea makes sense also :p
10:12:31 <arkeet> @pl \b t f -> if b then t else f
10:12:31 <lambdabot> if'
10:12:42 <geekosaur> it's common to call that "EOF" even though it's not a file. likewise with pipes and other things that are not strictly "files"
10:14:30 <funfunctor> geekosaur: yep I know, i'm just switching been Haskell, C legacy code, C vendor code and my own code.. mind exploding :p
10:15:00 <geekosaur> that conflation's even more common in C docs...
10:16:29 <mauke> because it's built into the low-level functions
10:16:39 <monochrom> indeed, I know about socket's EOF from unix and C stuff
10:16:49 <monochrom> long before I heard of Haskell
10:17:01 <kuribas> @hoogle a -> b -> a -> Maybe a
10:17:03 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYearValid :: Bool -> Int -> Int -> Maybe Int
10:17:03 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
10:17:03 <lambdabot> Data.IntMap.Strict findWithDefault :: a -> Key -> IntMap a -> a
10:17:06 <monochrom> then when I met Haskell, I was happy to see that these things are preserved
10:17:23 <monochrom> along with line buffering when stdin and stdout are ttys
10:18:07 <monochrom> the only thing that confuses me: that other people are confused about line buffering
10:18:39 <monochrom> (did they not have precious previous experience with C, python, java, which did the same thing?)
10:19:47 <mauke> haskell is weird in that it implicitly messes with terminal settings
10:21:30 * hackagebot tasty-silver 3.1.4 - Golden tests support for tasty. Fork of tasty-golden.  http://hackage.haskell.org/package/tasty-silver-3.1.4 (PhilippHausmann)
10:22:22 <mauke> IIRC setting stdin to unbuffered switches the terminal (if any) to noncanonical mode
10:24:36 <Raydiation> hi, is there something like mocks and unit tests in haskell?
10:25:03 <Raydiation> as in youve got a function that saves something to the disk
10:25:14 <heatsink> There HUnit for unit testing.  It's based on JUnit.
10:25:17 <Raydiation> you dont want to write to the disk but test if the correct stuff would be written
10:25:31 <c_wraith> Raydiation: free monads can often be used to emulate mocking - but it mocks operations, not objects.
10:26:04 <Raydiation> when looking at dependency injection in OOP, partial function application seems awefully similar
10:26:30 <Raydiation> s/awefully/very
10:26:38 <acowley> Do we have kind synonyms in GHC yet?
10:26:42 <mauke> Raydiation: that's easier done by separating the parts that generate content and the parts that write to disk
10:26:46 <c_wraith> partial application is pretty much exactly dependency injection
10:27:10 <Raydiation> yep, ive kinda came to the conclusion that this is the way to go in OOP
10:28:03 <mauke> and if you have pure "generate content" functions, you can easily test them and even use something like quickcheck to automatically generate inputs for you
10:28:46 <dysinger> Q: anyone have experience poking at hackage’s server api? http://hackage.haskell.org/api#list I tried list packages via json. works great. then I tried listing revisions for a package. nope `curl -H "Accept: application/json" http://hackage.haskell.org/package/ghc-mod/revisions/` brings back [{"time":"Wed Dec 31 22:35:59 UTC 2014","user":"DanielG","number”:0}]
10:29:01 <Raydiation> maybe test the pure functions like unit tests and use integration tests for impure functions?
10:29:14 <Raydiation> that way you wouldnt really need mocks
10:30:29 <Raydiation> is layered architecture used in FP?
10:31:53 <Raydiation> how do you structure web applications for instance?
10:32:05 <Raydiation> i suppose the controller is just a callback function
10:32:31 <roboguy_> dot_Laptop: It is the function type (->) partially applied to one type argument
10:34:17 <monochrom> c_wraith: it turns out that "mocking an object" is implemented by mocking operations. this is a rich source of XYX problems
10:34:44 <c_wraith> monochrom: heh.  XYX is one I haven't seen before.  :)
10:35:27 <monochrom> it means: "I am required to solve X. I think I can transform it to Y". an hour later, "I think I can solve Y by transforming it to X"
10:35:47 <monochrom> that is not the best part.
10:36:13 <monochrom> the best part is, after solving X, "now I just need to translation X solution to Y solution, then translate Y solution to X solution"
10:37:14 <monochrom> an example for this thread is: I am to test by mocking operations. I think I can do that by mocking an object.
10:37:16 <Raydiation> the thing is im atm trying rust and keeping state around like youd do with dependency injection containers just is very hard to do. maybe its the wrong way
10:37:31 <monochrom> and then: to mock an object, I will mock its operations...
10:37:41 <Raydiation> so maybe programming rust in a more functional way is the way to go
10:37:53 <Raydiation> then again i dont know anything about how to actually structure a fp well
10:38:00 <Raydiation> patterns, architecture etc
10:40:26 <monochrom> Raydiation, you should simply read http://www.slideshare.net/ScottWlaschin/fp-patterns-buildstufflt , then start working
10:41:08 <monochrom> slide 13 is the climax. or anti-climax
10:41:45 <glguy> I'm interested in learning more about the "Oh my, functions again!" pattern
10:41:53 <monochrom> :)
10:42:23 <c_wraith> slide 13 was fantastic
10:42:33 <glguy> Also, I'm interested in freeing those slides from slideshare
10:43:52 * glguy finds the powerpoint file...
10:50:09 <Raydiation> monochrom: ty
10:50:49 <glguy> This is the link to the video that you eventually get to if you follow the link on that page: https://vimeo.com/113588389
10:56:40 <linman32> is there a class for converting "type a" to "type b", and vice versa?
10:57:05 <monochrom> not in the common libraries
10:58:00 <linman32> monochrom: ok thnx. i'll probably make own
10:59:37 <monochrom> I believe that you will find this class and many instances to be a bliss to write. but then at the use sites, things become so clumsy you will find it not worthwhile.
11:01:54 <monochrom> actually, sometimes not clumsy. it may be worthwhile.
11:02:01 <linman32>  what do you mean at the "use sites"
11:02:14 <monochrom> it is a worthwhile exercise in multi-param type classes
11:02:30 <piotrm1> Hello, I'm looking for help resolving a parsing issue I cannot figure out. Specifically, "reads" fails to read an integer if there is a period followed by a number after said integer, like so:
11:02:34 <monochrom> it means when you call the method (as opposed to when you implement the method)
11:02:40 <piotrm1> Prelude Data.Int> (reads "1000.a") :: [(Integer, String)] [(1000,".a")] Prelude Data.Int> (reads "1000.0") :: [(Integer, String)] []
11:03:24 <linman32> ok understand
11:03:54 <monochrom> perhaps don't use reads
11:04:01 <mauke> ah, that's because Read is stupid and can't decide what it's trying to be
11:04:06 <linman32> prob give it a shot anyway and learn something from it
11:04:24 <piotrm1> what is the preferred replacement for reads/readsPrec ?
11:04:30 <mauke> in this instance it parses "1000.0" and says "hey, that's a floating point literal! I better fail"
11:05:46 <monochrom> Text.ParserCombinators.ReadP is nice and convertible back to the ReadS scheme of things
11:06:01 <monochrom> it already comes with GHC
11:08:03 <monochrom> read `fmap` munch1 isDigit  will do wonder, especially since you are controlling what read sees
11:08:22 <monochrom> (isDigit is from Data.Char)
11:09:40 <piotrm1> thanks, reading about this now
11:12:03 <arkeet> I didn't even know that existed.
11:16:32 * hackagebot hplayground 0.1.3.1 - monadic, reactive Formlets running in the Web browser  http://hackage.haskell.org/package/hplayground-0.1.3.1 (AlbertoCorona)
11:26:48 <Raydiation> monochrom: ty, that talk actually helps a lot
11:28:00 <byorgey> mauke: oh, thanks, that is a bug.
11:30:04 <byorgey> mauke: I guess the example I gave is not a valid example, one can instead use (ℝ ∪ {-∞}, max, -∞, +, 0)
11:31:31 <byorgey> or even (ℝ⁺ ∪ {-∞}, max, -∞, +, 0) if you only want positive real numbers
11:32:13 <mauke> while you're at it, https://github.com/byorgey/type-matrices/blob/master/type-matrices.lhs#L699 =~ s/form/forms/
11:34:39 <byorgey> mauke: thanks, fixed now
11:37:21 <roboguy_> @tell edwardk hask doesn't build quite right on GHC 7.8.4. I get "Conflicting family instance declarations" in src/Hask/Tensor/Compose.hs for Dom and Cod
11:37:21 <lambdabot> Consider it noted.
11:41:34 * hackagebot warp 3.0.12 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.12 (MichaelSnoyman)
11:42:52 <joneshf-laptop> dibblego, fwiw, I see `geodetic` now. Thanks for both of these packages!
11:51:34 * hackagebot repa-devil 0.3.2.4 - Support for image reading and writing of Repa arrays using in-place FFI calls  http://hackage.haskell.org/package/repa-devil-0.3.2.4 (RaphaelJavaux)
12:07:28 <Raydiation> monochrom: btw, that talk was the first talk where i managed to get monoids and monads
12:07:39 <monochrom> good
12:07:51 <Raydiation> full of awesomeness :)
12:19:38 <platz_> Is "IO (Either AppErr a)" as 'bad' as "EitherT AppErr IO a"?  I see lots of apis on hackage with the former
12:20:08 <platz_> i've heard we need to use MonadThrow instead of the latter, but the former too?
12:21:13 <maurer> platz_: those do different things, and which you want depends on wha tyou're doing
12:21:56 <platz_> hrmm, i think I need to read the typeclassopedia again
12:21:56 <maurer> platz_: IO (Either AppErr a) means "do this IO action, then if you want the returned value, you need to check the error code to get it
12:22:28 <maurer> platz_: EitherT AppErr IO a instead means "do this possibly erroring IO action, and if it fails, cancel the rest of the computation and return the failure"
12:22:35 <quchen> platz_: The two types are the same in the sense that you can convert back and forth without losing information, but their Monad instances are different.
12:22:36 <maurer> (or you can explicitly handle it)
12:23:05 <maurer> Yeah, what quchen said, I was basically explaining the difference in how bind would work on them
12:24:59 <platz_> ah, i see, thanks
12:27:16 <platz_> I'm still figuring out how writing libraries, transformer stacks, and exceptions are all supposed to work together from an author's point of view
12:27:24 <platz_> it seems there are several choices in this space
12:28:09 <platz_> and there (may?) be a best practice, but there are certainly some competing forms that are more or less complex than others
12:28:44 <platz_> i'm not sure many languages do well with this, for that matter
12:31:17 <funfunctor> Suppose I have data Foo = Foo { a :: !Word16, b :: !Word8 } deriving (Show) and I wish to pretty print it but convert all record members values to hex, what is a nice way to go about this?
12:32:13 <heatsink> :t showHex
12:32:14 <lambdabot> (Integral a, Show a) => a -> ShowS
12:32:29 <monochrom> showHex is in Numeric
12:32:30 <funfunctor> I have toHex v = showIntAtBase 16 intToDigit v and I am currently using import qualified Text.Show.Pretty as Pr to pretty print like so putStrLn $ Pr.ppShow $ frames
12:33:07 <funfunctor> ah ok, well that was not the hard part but thanks heatsink
12:33:32 <funfunctor> the issue is how to map it over the structure Foo ?
12:34:21 <monochrom> presumably you know how to extract the two fields? then simply use showHex on one field, and showHex on the other field?
12:35:06 <funfunctor> monochrom: well there is a lot more than two fields in the real structure
12:35:25 <funfunctor> So I would prefer a way to map over it
12:35:41 <funfunctor> fmap comes to mind but I am not sure how
12:35:44 <funfunctor> :t fmap
12:35:45 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:38:12 <fizruk> funfunctor: well, if you move Word16 and Word8 to type parameters, you can use bimap from Data.Bifunctor... not sure that's what you want though
12:38:52 <fizruk> :t bimap
12:38:53 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
12:39:06 <monochrom> but it sounds like there are 13 such fields so it will have to be a DeccaTrioFunctor or something
12:39:22 <funfunctor> fizruk: well no, I mean.. notice the ! syntax.. The structure is in fact a representation of a binary stream parsed and packed into it
12:39:49 <funfunctor> basically I want to pretty print it but with its values in hex
12:40:24 <fizruk> funfunctor: afaik strict fields (the ! syntax) have nothing to do with parametricity, but I may be wrong
12:40:44 <lpaste> funfunctor pasted “No title” at http://lpaste.net/130608
12:40:52 <quchen> When I attach an action to a value using `addFinalizer` from System.Mem.Weak, i.e. run an IO action when the value is GC'd, am I guaranteed the finalizer is run at some point after that GC? Is there anything that can get in the way, like exceptions?
12:40:55 <funfunctor> ^ does that make sense
12:41:29 <quchen> Or in short, am I guaranteed the finalizer of Weak pointers are always run?
12:41:39 <fizruk> funfunctor: perhaps you can just wrap Word16/Word8 in a newtype with hex Show?
12:41:42 <monochrom> quchen: GC may be skipped when the program terminates (even normally). finalizers may be skipped, therefore.
12:41:47 <Cale> class Triskaidekafunctor f where thirteenMap :: (a1 -> b1) -> (a2 -> b2) -> (a3 -> b3) -> (a4 -> b4) -> (a5 -> b5) -> (a6 -> b6) -> (a7 -> b7) -> (a8 -> b8) -> (a9 -> b9) -> (a10 -> b10) -> (a11 -> b11) -> (a12 -> b12) -> (a13 -> b13) -> f a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 -> f b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 b13
12:42:00 <funfunctor> instead of things like version = 16777473 I want it to show version = 0x1000101
12:42:16 <Cale> This class is bad luck
12:42:16 <monochrom> however, that is the only scenerio I know that skips GC and/or finalizers
12:42:19 <fizruk> funfunctor: newtype Hex a = Hex a
12:42:37 <monochrom> Cale: behold my intelligent choice of the random number 13! :)
12:42:56 <quchen> monochrom: Very useful, thanks. I guess I could force a GC at program exit if I *really* wanted to run the finalizers that were set implicitly.
12:43:00 <funfunctor> fizruk: wait how is that going to work?
12:43:07 <fizruk> funfunctor: instance (Integral a, Show a) => Show (Hex a) where shows = showHex
12:43:18 <fizruk> I did not check that
12:44:11 <fizruk> then you can have your data structure: data Foo = Foo { a :: !(Hex Word16), b :: !(Hex Word8) }
12:44:59 <fizruk> so when you show foo, you get Words displayed in hex
12:46:59 <funfunctor> fizruk: then I get issues like     Expected type: Get (Hex Word16)  Actual type: Get Word16
12:47:15 <fizruk> sure
12:47:32 <roboguy_> you can also make a nice Num instance for it to make it easy to work with
12:48:48 <roboguy_> funfunctor: where would you get that error?
12:48:57 <fizruk> :t word16
12:48:59 <lambdabot>     Not in scope: ‘word16’
12:48:59 <lambdabot>     Perhaps you meant one of these:
12:48:59 <lambdabot>       ‘words’ (imported from Data.List),
12:49:06 <funfunctor> roboguy_: In my Get monad parser
12:49:14 <roboguy_> funfunctor: Get is a type though, not a type class
12:49:29 <funfunctor> I know
12:49:37 <roboguy_> and you can write a quick getHexWord16be = Hex . getWord16be, etc
12:49:48 <roboguy_> I think that would avoid all those issues
12:49:56 <funfunctor> ah oh
12:50:22 <roboguy_> oh, it might be fmap not (.), but the same idea
12:50:27 <fizruk> <$> rather than (.)
12:50:41 <roboguy_> ha, yep
12:52:39 <orbifx> srhb: Hey, it works with session as parameter
12:52:43 <orbifx> it is clearly faster too
12:52:49 <srhb> orbifx: :)
12:52:54 <orbifx> because of not having to reconnect
12:53:06 <orbifx> I am tempted to try out binding a lazy list too :P
12:53:23 <srhb> orbifx: Evenrually you will probably have to consider some kind of session management though. I assume the session can time out, and I don't think the library is equipped to handle that automatically.
12:54:14 <orbifx> I see
12:54:46 <orbifx> srhb: _style_ wise.. is it better to go with lazy lists or session as a parameter do you think?
12:54:53 <funfunctor>     Expected type: Hex a -> String  Actual type: Hex a -> ShowS In an equation for `show': show = showHex
12:54:57 <funfunctor> what is a ShowS?
12:55:02 <funfunctor> > :k ShowS
12:55:02 <srhb> orbifx: I don't think they are orthogonal.
12:55:03 <lambdabot>  <hint>:1:1: parse error on input ‘:’
12:55:10 <funfunctor> > :t ShowS
12:55:11 <lambdabot>  <hint>:1:1: parse error on input ‘:’
12:55:20 <srhb> :t ShowS
12:55:21 <lambdabot> Not in scope: data constructor ‘ShowS’
12:55:26 <srhb> Ah, that's the data type
12:55:39 <orbifx> srhb: explain please
12:55:39 <EvanR> type ShowS = String -> String
12:55:41 <funfunctor> I think it probably has kind *
12:55:46 <funfunctor> oh ok
12:56:01 <funfunctor> :t id
12:56:02 <lambdabot> a -> a
12:56:19 <funfunctor> :t id . showHex
12:56:20 <lambdabot> (Integral a, Show a) => a -> ShowS
12:56:33 <funfunctor> umm
12:56:34 <EvanR> ("concat "++) . ("this "++) . ("stuff "++) $ ""
12:56:38 <EvanR> > ("concat "++) . ("this "++) . ("stuff "++) $ ""
12:56:40 <lambdabot>  "concat this stuff "
12:57:02 <fizruk> @src Show
12:57:02 <lambdabot> class  Show a  where
12:57:02 <lambdabot>     showsPrec :: Int -> a -> ShowS
12:57:02 <lambdabot>     show      :: a   -> String
12:57:02 <lambdabot>     showList  :: [a] -> ShowS
12:57:26 <srhb> orbifx: I think for what you are doing, having session be separate and reusable makes complete sense for allowing multiple actions over one connection. The manner in which the actions are actually carried out need not have anything to do with this. It's true that a lazy list approach could mean that you avoid passing the session around, but they can also be combined, if that's nicer. Though I think what you
12:57:28 <srhb> have now is conceptually very simple.
12:57:39 <EvanR> funfunctor: by composing ShowS you can build a string piece by piece more efficiently than continuouslly ++ing the entire thing
12:57:47 <EvanR> continually
12:58:13 <funfunctor> EvanR: right because you eval it at the end or something?
12:58:39 <nocturne777> is my understanding on this correct? "foldr (\x acc -> acc || odd x) False [2,4,9, 2, 4, undefined]" produces exception here because foldr recurses all the until exhausts the list and the first time "x" it evaluates is undefined. However,  "foldr (\x acc -> odd x || acc) False [2,4,9, 2, 4, undefined]" does not produce an exception because "odd" forces x to be evaluated and thus can cause an early termination
12:58:51 <funfunctor> > "0x" ++ showHex 13
12:58:53 <lambdabot>      Couldn't match type ‘String -> String’ with ‘[Char]’
12:58:53 <lambdabot>      Expected type: [Char]
12:58:53 <lambdabot>        Actual type: ShowS
12:59:08 <EvanR> funfunctor: because with the naive way you probably ended up with something that was left associative
12:59:11 <aawe> > "0x" ++ (showHex 13)
12:59:12 <lambdabot>      Couldn't match type ‘String -> String’ with ‘[Char]’
12:59:12 <lambdabot>      Expected type: [Char]
12:59:12 <lambdabot>        Actual type: ShowS
12:59:16 <nocturne777> it evaluates "x"*
12:59:32 <aawe> :t showHex
12:59:33 <lambdabot> (Integral a, Show a) => a -> ShowS
12:59:35 <EvanR> ("concat " ++ "this ") ++ "stuff"
12:59:47 <EvanR> funfunctor: that would end up reallocating the whole string once
12:59:52 <funfunctor> :t (++)
12:59:54 <lambdabot> [a] -> [a] -> [a]
13:00:10 <aawe> what's ShowS?
13:00:17 <EvanR> type ShowS = String -> String
13:00:24 <funfunctor> EvanR: right, but I am not connecting the dots.. how can I get a string out of showHex ?
13:00:34 <EvanR> funfunctor: apply the ShowS to ""
13:00:35 <aawe> > showHex 13 "what"
13:00:37 <lambdabot>  "dwhat"
13:00:43 <funfunctor> oh
13:00:47 <funfunctor> derr
13:02:21 <funfunctor> what does this mean?     Could not deduce (Integral (Hex a)) arising from a use of `showHex' from the context (Integral a, Show a) bound by the instance declaration at Server.hs:88:10-45 Possible fix: add an instance declaration for (Integral (Hex a))
13:03:01 <funfunctor> while trying newtype Hex a = Hex a
13:03:01 <funfunctor> instance (Integral a, Show a) => Show (Hex a) where show v = showHex v ""
13:03:19 <EvanR> newtyping doesnt auto carry over the instances
13:03:38 <Jeanne-Kamikaze> isn't there an extension for that ?
13:03:50 <fizruk> funfunctor: show (Hex v) = showHex v ""
13:04:03 <funfunctor> god dam 6am.. I just wanted to pretty print in hex :'(
13:04:13 <EvanR> Show is not for pretty printing
13:04:13 <orbifx> srhb: hmm, yeah a combination would have benefits from both approaches. I can have some session passing high up, but use lazy lists further in. Yeah?
13:04:35 <srhb> orbifx: You can, but I'm not sure what benefits you would reap.
13:04:37 <EvanR> funfunctor: just make a different function that prints your type in hex
13:04:41 <funfunctor> fizruk: thx !
13:04:47 <fizruk> funfunctor: you can still go and showHex each field
13:04:51 <srhb> orbifx: Perhaps that's just because I think your current solution sounds just fine to me. And perhaps I'm lazy. :-)
13:05:11 <EvanR> or use a pretty print package
13:06:05 <funfunctor> I wish showHex was String -> a and not a -> String so you could write stuff like showHex "0x" 13
13:06:14 <funfunctor> instead of showHex 13 "h"
13:06:20 <EvanR> make a function that does that
13:06:23 <EvanR> its literally one line of code
13:06:42 <funfunctor> I know, I did.. "0x" ++ showHex v ""
13:07:23 <EvanR> you should wish for the more general function to not exist
13:07:26 <EvanR> shouldNT
13:07:31 <nocturne777> ?
13:07:45 <EvanR> because then you cant make specific derived functions
13:08:06 <EvanR> 0x isnt a universal notation for hex numbers
13:08:21 <EvanR> or bytes
13:08:24 <orbifx> srhb: mostly educational.. first serious project, so far been ready books and trying oneliners from time to time.
13:08:56 <srhb> orbifx: Well, that's a good reason :-)
13:12:56 <Luke> does any haskell shell library support starting a process, confirming it's started, then backgrounding it?
13:13:33 <EvanR> confirming its started?
13:14:20 <Luke> yeah like confirming it was backgrounded
13:14:47 <Luke> but allowing me to keep a handle to the process
13:15:21 <Luke> i explained poorly. I will confirm with the handle that the process is still running after backgrounding
13:15:36 <EvanR> background wont kill a process
13:15:48 <Luke> i know
13:15:59 <EvanR> and if some async effect kills it, seems like a race
13:16:06 <Luke> it is a race
13:16:13 <EvanR> so whats the point of confirming
13:16:45 <Luke> what's the point of confirming your process didn't die?
13:17:07 <EvanR> right because right after the confirmation it could die
13:17:28 <Luke> because in the real world, if there's a command line arg error or something, it will die right away
13:17:47 <EvanR> or it gets confirmed before it dies "right away"
13:17:47 <Luke> i'm not trying to catch random async shutdowns i'm trying to catch the case when it died right away
13:18:04 <Luke> yeah you can simply wait a bit then check
13:18:05 <EvanR> it seems ill concieved
13:18:26 <EvanR> maybe you want to spawn the process and get a signal when the process terminates
13:18:36 <Luke> EvanR: sure
13:18:53 <Luke> the point is having a handle to look at after the process is started
13:19:08 <EvanR> wait, to wait on
13:19:19 <EvanR> s/wait,/well,/
13:19:25 <Luke> yeah totally
13:19:30 <Luke> similar to the async library
13:19:35 <Luke> but for processes
13:19:49 <EvanR> what shell library are you talking about
13:19:56 <Luke> any that exists
13:20:03 <Luke> shelly, turtle, etc etc
13:20:06 <EvanR> System.Process does all this but isnt a shell library
13:20:23 <Luke> the process package?
13:20:33 <EvanR> i think its built in?
13:20:35 <EvanR> base
13:20:51 <EvanR> youre right, process
13:21:12 <Luke> yeah I didn't know the process package existed. that looks like what i'm looking for
13:22:19 <Luke> EvanR: shelly and turtle's process runners don't have handles
13:22:27 <Luke> *don't have wait handles
13:22:41 <EvanR> they return immediately?
13:22:45 <EvanR> thats weird
13:22:52 <Luke> no they block
13:22:59 <EvanR> ah well there you go
13:23:20 <Luke> EvanR: you're thinking just wrap in async?
13:23:36 <EvanR> what are you actually trying to do
13:23:48 <EvanR> fork?
13:23:49 <Luke> to wait on the process so I know when it dies
13:23:54 <Luke> with async?
13:24:05 <EvanR> thats what blocking does ;_;
13:24:31 <Luke> yeah i have multiple processes I want to start and wait on. was that not obvious with my questions?
13:24:36 <EvanR> no
13:24:38 <Luke> sorry
13:24:50 <Luke> so yeah wait on multiple processes.
13:25:21 <EvanR> to wait on multiple processes you need to spawn all of them in threads, have each thread wait, and then the parent thread needs to wait for all the MVars to be written
13:25:35 <EvanR> each thread writes to an mvar when done
13:25:50 <Luke> EvanR: that's what the async library abstracts away
13:25:56 <EvanR> then use that
13:26:09 <srid> has anyone completed the Expr exercise 6 in http://www.seas.upenn.edu/~cis194/spring13/hw/05-type-classes.pdf ?
13:26:17 <mauke> async handles all the edge cases, which is nice
13:26:38 * hackagebot repa-devil 0.3.2.5 - Support for image reading and writing of Repa arrays using in-place FFI calls  http://hackage.haskell.org/package/repa-devil-0.3.2.5 (RaphaelJavaux)
13:26:41 <Luke> mauke: yeah I'm a fan of async
13:27:46 <mauke> "The UI department has internalized the focus group data and is ready to synergize with you." <- CAN'T DO EXERCISES; CRINGING TOO HARD
13:28:07 <capisce> maybe they want to pick your brain
13:28:25 <Luke> EvanR: thanks for pointing me to process. I forgot that existed
13:28:35 <capisce> or grok you
13:28:35 <mauke> "Leverage the assets of the UI team to implement the value-added function"
13:28:39 * mauke face melts
13:28:56 * capisce groks mauke
13:29:10 <EvanR> hey keep your hands to yourself
13:29:45 <mauke> nah, grok is tech jargon
13:29:53 <EvanR> i know
13:30:01 <mauke> not you
13:30:37 <quchen> Is there a difference between using ForeignPtr to ensure GC of C heap variables, and Ptr + adding a `free` finalizer?
13:31:17 <EvanR> those exercise background infos are eerily realistic
13:31:39 * hackagebot twentefp-graphs 0.1.0.4 - Lab Assignments Environment at Univeriteit Twente  http://hackage.haskell.org/package/twentefp-graphs-0.1.0.4 (sebaslafleur)
13:32:34 <mauke> quchen: how do you add a finalizer to a Ptr?
13:33:19 <lynnard> I can write ((,) a) for tuple of partially applied first field, how can I do the same for the second field?
13:33:28 <quchen> lynnard: -XTupleSections
13:33:30 <lynnard> tried (`,` a) not working
13:33:46 <EvanR> (,x)
13:33:47 <mauke> `` is for turning words into infix operators. , is not a word
13:34:04 <EvanR> > (,'a') 0
13:34:05 <lambdabot>  (0,'a')
13:34:31 <quchen> mauke: I have lots of C structures that contain allocated stuff. I'd like to deallocate the contained data when the parent struct is GC'd. `addFinalizer parent (free child)` seems to let me do something like that.
13:34:33 <lynnard> cool thanks
13:36:02 <quchen> mauke: The main problem I'm having is that I have to allocate data at some point, but I cannot be sure when the deallocation happens (which depends on external circumstances), so `bracket` and friends are out. I'd like to ensure the data is deallocated at *some* point though, and finalizers or touchForeignPtr and so on seem to be a way to do this sort of thing.
13:36:10 <mauke> oh, weak pointers
13:36:57 <mauke> I would have used the normal ForeignPtr finalizers
13:40:32 <quchen> It's not always a ForeignPtr that should trigger the deallocation though. Sometimes, Haskell doesn't need the pointers anymore, so it is free to GC them. But there are still other structures that depend on external C functions to be runnable, and I'd like those structures to trigger the GC.
13:41:04 <mauke> srid: ok, I've read the pdf. do you have a specific question?
13:41:08 <quchen> Building safe wrappers around C libraries is fun (in the Dwarf Fortress sense)
13:43:21 <mauke> ah, screw it
13:43:23 * mauke installs ghc
13:46:24 <monochrom> wait, you hadn't installed ghc previously, mauke? :)
13:46:30 <mauke> no
13:47:06 <mauke> (one of the reasons I find "I'm getting an error" with no details so annoying)
13:48:59 <monochrom> hehe
13:49:06 <Rotaerk> I'm getting an error; it says things aren't working
13:50:41 <monochrom> when, one day, we write a biography of mauke, we will write: "mauke amazingly answered tons of #haskell questions without any haskell compiler or interpreter. only by the 2nd quarter of 2014 did he finally install ghc."
13:51:01 <monochrom> err, s/2014/2015/
13:51:22 <mauke> I used to have ghc :-)
13:51:29 <monochrom> sorry I was worrying about filing tax stuff and so my clock rewinded by one year!
13:51:42 <kuribas> Which datastructure has constant append and constant indexing?  (or log n)
13:51:45 <mauke> not sure which version; 7.4?
13:51:54 <ElderFain> monochrom: one year ago today, you still had tax problems to worry about ;)
13:52:06 <monochrom> truth
13:52:12 <kuribas> Should I use an intset?
13:52:21 <mauke> monochrom: I do have a haskell interpreter (/query lambdabot) and compiler (fpcomplete)
13:52:28 <monochrom> kuribas: you may like Data.Sequence
13:52:47 <monochrom> ah, fpcomplete does wonder, too
13:53:10 <srid> mauke: been discussing this in #haskell-beginners now. still as confused as before
13:53:25 <unscriptable> does anybody have a code example using web-routes with query parameters?
13:53:33 <srid> mauke: if you join, i can copy paste the history
13:53:51 <asthasr> I am trying to represent a "question tree" -- where you can define questions that are presented to the user with a set of options, etc.; however, I'm having trouble with types, because I am a newb.
13:53:58 <asthasr> http://hastebin.com/dogetilacu.hs <-- this is my code
13:54:16 <kuribas> monochrom: that's it, thanks!
13:54:17 <asthasr> unanswered is incomplete because I realized my type problem when I started to work on it
13:54:43 <asthasr> a list of answers should not be homogenously typed... a question might return an integer, another might return a string, another might return a boolean
13:55:13 <asthasr> is there a way to express "I don't care about what type this is," or am I taking a fundamentally wrong approach?
13:57:28 <srhb> asthasr: You probably want to try wrapping out the possible Answer types with Answer Int | Answer String | Answer ... -- before going the heterogenous route.
13:58:08 <asthasr> ah, so that would basically eliminate the type parameters
13:58:08 <Cale> asthasr: Why do you want to stick those things in a list together, if you don't care about the type of their results? Why do they have a result type?
13:58:22 <Cale> asthasr: What are you going to do with them when you take them out of the list again?
13:59:04 <asthasr> Cale: Because the idea that I had was starting with a list of constraints and an empty list of answers. Recursively, filter the list of constraints to pull out available questions, and ask the first one, then put the answer into the list of answers... repeat until the available questions are [].
13:59:08 <Cale> asthasr: If you're going to use them to ask the user a question and then do something with the response (which is presumably a value of the appropriate type), then the code absolutely needs to know that it's the correct type, right?
14:00:05 <asthasr> Yes, but you can constrain a question of type "Int" against a question of type "Bool"... and if you're asking a list of questions, you can ask all your questions before you take any action dictated by the types of the responses
14:00:21 <asthasr> i.e. in this case, my use case is "here is a question tree. ask all of those questions. then, do things based on the set of responses."
14:01:39 <Cale> asthasr: If you have some value x of some type which you don't know what it is, there are almost no operations you can legally apply to x. You have no right to inspect a value of arbitrary type.
14:02:09 <Cale> You can only pass it around to things which are capable of accepting a value of an arbitrary type (and they can't look at it either)
14:02:31 <asthasr> The only thing it needs to do is Eq.
14:02:51 <Cale> asthasr: Okay, so how does it use Eq?
14:03:21 <asthasr> It seems to me that if two disparate (but Eq'able) types are compared, it should simply return false
14:03:30 <arkeet> you can't compare them though. that's a type error.
14:03:31 <Cale> no
14:03:37 <Cale> right
14:03:42 <arkeet> you can only apply == to values of the same type.
14:03:44 <Cale> You can't compare things of different types
14:03:46 <Cale> :t (==)
14:03:47 <lambdabot> Eq a => a -> a -> Bool
14:03:59 <asthasr> fair enough
14:04:01 <arkeet> so if you have a value whose type you know nothing about except that it's an instance of Eq
14:04:06 <arkeet> the only thing you can equate it with is itself.
14:04:13 <Cale> asthasr: Also, types do not exist at runtime
14:04:43 <Cale> asthasr: Compilation destroys all the types, at runtime, it's all pointers to code and tables.
14:04:52 <asthasr> ugh. I've been hoping to use types to help my program design, and then I try to do a haskell prototype of something and end up running into this first thing
14:05:21 <Cale> Well, you're definitely going to learn something here :)
14:05:35 <Cale> I have no doubt there's an appropriate type for what it is that you really want
14:05:54 <Cale> If you *really really* want to stick things of different types in a list, we can invent an existential wrapper
14:06:03 <Cale> However, I don't think that's likely to be the best route
14:06:24 <arkeet> if you know all the different types you want to use, you can stick them in a sum type.
14:06:35 <Cale> yeah, that's possible as well
14:06:40 * hackagebot tasty-silver 3.1.5 - Golden tests support for tasty. Fork of tasty-golden.  http://hackage.haskell.org/package/tasty-silver-3.1.5 (PhilippHausmann)
14:07:26 <asthasr> the problem with a sum type, as I understand it, is that it will be next to impossible to get a well-typed thing out of it
14:07:32 <Cale> If you think about what you'll do with the elements once you get them out of the list, you can always stick records of *that* into the list.
14:07:41 <Cale> hm?
14:07:54 <Cale> Well, a sum type would at least let you inspect which type of thing you had
14:08:03 <Cale> by pattern matching on the constructors
14:08:59 <Cale> However, that might be quite obnoxious if you have a lot of different types of questions.
14:09:20 <monochrom> sum types used incorrectly will lead to impossible to get well-typed things out of it, yes.
14:09:51 <asthasr> so let's approach this differently
14:10:17 <asthasr> if you guys were designing a tree, which would basically be a directed graph where the connections are constraints that can reference higher portions of the graph
14:10:23 <monochrom> suppose I am to model a tree of questions and follow-up questions, i.e., a node has a question and possibly child nodes
14:10:24 <asthasr> what would be the toolbox you would reach for in haskell?
14:10:47 <EvanR> (a cyclic graph, too)
14:10:52 <EvanR> ... acyclic
14:10:57 <asthasr> it's probable that my approach is shaped by my dynamically typed background, where answers would just be a 'thing' and i could do whatever I like to them
14:11:01 <asthasr> yes, acyclic
14:11:11 <EvanR> so theres several Tree types common in haskell
14:11:27 <Cale> asthasr: The idea being that we decide which questions to ask based on the responses to previous ones?
14:11:34 <asthasr> yes, callumacrae
14:11:35 <asthasr> er
14:11:37 <asthasr> Cale
14:11:44 <gfixler> what does one do with this? https://github.com/byorgey/type-matrices
14:12:14 <gfixler> I tried a ghc --make, which created a make, but then ./make couldn't find Diagrams.Prelude, even though I've installed diagrams
14:12:30 <asthasr> Maybe: "Do you own a car?" -> boolean -> If no, "What mode of public transportation do you use?" -> [bus, train, etc.] -> if yes, "What brand of car do you own?" -> [...]
14:12:37 <monochrom> suppose, furthermore, each question is one of two kinds:  A. the answer is true/false, in which case there must be two follow-up questions, one for true one for false;  B. the answer is an Integer, in which case for each Integer value there is a follow-up question.
14:12:38 <callumacrae> I'm famous \o/
14:12:52 <michaelt_> gfixler: this is a latex repository no?
14:13:03 <asthasr> callumacrae: sorry :S
14:13:06 <arkeet> michaelt_: it comes with a make.hs
14:13:07 <gfixler> michaelt_: I don't know - that's probably my main problem
14:13:07 <byorgey> gfixler: that depends on the (unreleased) diagrams-1.3 anyway
14:13:14 <michaelt_> gfixler: yes, i see it's shake
14:13:16 <callumacrae> no worries! you reminded me that I'm supposed to be learning haskell
14:13:24 <Cale> asthasr: So, one thing you can do is something like this:   data Q a = Done a | Ask (Question a) (Maybe a -> Q a)
14:13:24 <arkeet> well there's your answer.
14:13:26 <gfixler> ah, shake
14:13:30 <byorgey> gfixler: I will put out a PDF very soon, once I have finished incorporating feedback from the reviewers
14:13:31 <michaelt_> gfixler: I think you have your answer now ...
14:13:38 <gfixler> michaelt_: I do
14:13:42 <gfixler> byorgey: thanks - I'm interested!
14:14:27 <Cale> er, actually, let me fix that :)
14:14:30 <monochrom> an incorrect model is "data Tree = Node The_Question Which_Kind [Tree] | Leaf", which clearly loses the information "if it's kind A, there are two questions; if it's kind B, for each number there is one question"
14:15:21 <asthasr> monochrom: Also, note that this is slightly different from my goal, which is where a question does not necessarily have a follow up question and, theoretically, multiple questions could fulfill the conditions for another question to be asked
14:15:36 <monochrom> a correct model is "data Correct = BooleanQ The_Question Correct Correct | IntegerQ The_Question (Integer -> Correct) | Leaf"
14:17:59 <Cale> So, the problem with the type I just suggested is that it constrains all the questions to having the same type again. So, perhaps this sort of an existential wouldn't be bad:  data Q a = Done a | forall b. Ask (Question b) (Maybe b -> Q a)
14:18:46 <nkar`> is there a good introduction to parMap?
14:18:50 <Cale> If you want a better name than Q, perhaps Questionnaire
14:19:12 <nkar`> I've never used strategies before, and the par example from RWH doesn't help me much
14:19:29 <Cale> So this says that a questionnaire whose result has type a is either Done x, where x has type a, which is a boring questionnaire that asks no questions
14:19:32 <srhb> nkar`: Isn't Marlows book open? Not sure.
14:19:46 <nkar`> srhb: yeah, I'm checking it out at this moment
14:19:53 <nkar`> besides it, I mean
14:20:05 <asthasr> monochrom, Cale :  http://hastebin.com/orifojeker.txt
14:20:25 <Cale> Or, it consists of a question whose result is a value of some arbitrary type b (I noticed that you have Maybe b as a result, perhaps the users are allowed to skip questions) 
14:21:21 <Cale> and in addition to the question, it has a function from the type of possible responses to further questionnaires
14:21:58 <Cale> So, basically, the questionnaire itself is allowed to compute the rest of the questionnaire from the responses to initial questions.
14:22:04 <Cale> That's one approach anyway :)
14:22:06 * arkeet smells a monad
14:22:20 <Cale> Yeah, the monad instance here is pretty easy
14:22:48 * arkeet mumbles something about continuations
14:22:50 <monochrom> yes arkeet, this is clearly a free monad that stands for interactive operations
14:23:06 <monochrom> in fact, free-game is a good fit for it
14:23:15 <arkeet> I never actually looked at free-game.
14:23:36 <arkeet> I imagined that was made for video games though.
14:23:56 <mauke> byorgey: http://www.seas.upenn.edu/~cis194/spring13/hw/05-type-classes.pdf is this yours? because exercise 5 clashes with exercise 1
14:24:01 <monochrom> yes, but there is an isomorphism between questionaires and video games
14:24:15 <arkeet> yes, I noticed that too.
14:24:20 <Cale> asthasr: Of course, perhaps you want to restrict things more than that. Depending on your overall goals, it might be inconvenient not to be able to inspect the overall questionnaire because it's built out of functions
14:24:23 <arkeet> I ended up importing StackVM qualified.
14:24:47 <arkeet> monochrom: well... ok :)
14:24:54 <asthasr> well, ultimately this will be part of a web app; so I will need to be able to deconstruct it into a data structure and then do some fanciness with js on the browser
14:24:58 <mauke> you're supposed to submit a single file (Calc.hs). ex 1 asks you to import ExprT, which defines Add/Mul. ex 5 asks you to import StackVM, which also defines Add/Mul. result: name clashes in your homework
14:25:32 <arkeet> yeah
14:28:19 <byorgey> mauke: indeed. As I recall I had to tell them to import StackVM qualified, since I didn't catch that until after I published the assignment
14:28:28 <asthasr> originally, I was thinking of modeling this in Clojure, but thought I should put my money where my mind is and try to use types as a tool to make the design clean... but of course it seems I have stumbled into a monad
14:28:39 <mauke> byorgey: TypeSynonymInstances isn't enough either. ghc wants FlexibleInstances
14:29:04 <byorgey> that probably depends on what version of GHC you are using
14:29:20 <Cale> asthasr: Well, it's not hard to find monads when you're working with trees, and it's also not hard to find them when you're working with computations of a specified sort, and here we have both :)
14:29:22 <mauke> 7.10.1, it seems
14:29:36 <monochrom> I would recomment s/but/I am please to announce that/
14:29:38 <byorgey> yes, I think 7.10 got stricter about some things
14:29:46 <monochrom> and s/please/pleased/
14:30:18 <arkeet> nah, I got that too with 7.8
14:31:16 <Cale> Note that we can be ignorant of the fact that anything happens to be a monad and still the type itself can be useful. Pointing out that something is a monad just saves you from having to write a bunch of common definitions.
14:33:06 <Cale> In this case, since you likely have to convert everything into JSON or something regardless, fixing some small set of types for the responses to questions, and using something more tree-like is probably not a terrible plan.
14:33:34 <Cale> (i.e. use types which don't have type parameters that you could fill in with any type whatsoever)
14:34:47 <merijn> byorgey: Yes, it got stricter, or rather, it's no longer faultily allowing somethings
14:35:15 <merijn> byorgey: i.e. it no longer allows inferred types that would require you to enable an extension when writing the type.
14:35:27 <Cale> (unless your Haskell code can run in the browser because you're using GHCJS anyway :)
14:35:36 <asthasr> Cale: ha! well
14:35:38 <asthasr> for context
14:35:45 <ProofTechnique> merijn: Can you give an example? That sounds like an interesting case.
14:35:48 <byorgey> merijn: ah, right
14:35:52 <asthasr> I am doing this as a proof of concept for doing things in a non-braindead way
14:36:00 <asthasr> at present, this same thing is modeled using javascript... stored in a db.
14:36:02 <asthasr> :|
14:36:45 <asthasr> like -- if ($("#whatever-question").value() == "something") { $(this).show() }
14:36:58 <Cale> heh
14:37:02 <asthasr> this is... god awful
14:37:05 <asthasr> and bad
14:37:09 <asthasr> and also terrible
14:37:43 <merijn> ProofTechnique: Requiring RankNTypes, or any other extension
14:37:52 <ProofTechnique> Ah, okay.
14:38:01 <Cale> Okay, so one important thing to think about, because of this constraint, is the JSON format for your questionnaires, because there are a lot of Haskell-definable types that don't squish down into JSON so easily.
14:38:06 <merijn> ProofTechnique: Basically, it would silently infer the type with all extensions enabled and work, even if those extensions were off
14:38:21 <ProofTechnique> Hmm. That does sound a bit icky
14:38:37 <arkeet> sounds scary. I wouldn't want it to silently enable ImpredicativeTypes for me.
14:38:51 <arkeet> oh wait I misread.
14:38:56 <mauke> byorgey: "... it should be the case that   stackVM exp == Right [IVal exp]"  <- this is bogus
14:39:12 <Cale> arkeet: Especially as ImpredicativeTypes doesn't actually work.
14:39:17 <arkeet> well sure.
14:39:23 <arkeet> but I thought it meant to infer which extensions would be necessary.
14:39:30 <arkeet> for the types you wrote.
14:39:36 <mauke> byorgey: stackVM returns Either String StackVal, not a list of StackVals, so it should be Right (IVal exp)
14:39:53 <mauke> byorgey: second, StackVal doesn't have an Eq instance, so this doesn't compile
14:41:18 <Cale> asthasr: But if you can work out what you want the JSON to look like, it's pretty easy to come up with some corresponding Haskell types.
14:41:27 <asthasr> hmm, fair enough.
14:41:31 <byorgey> mauke: sounds right
14:41:51 <EvanR> a tree-like haskell type can be json pretty easily
14:42:00 <byorgey> mauke: FYI, although I appreciate bug reports in general, you should consider those files "unmaintained", in that I don't have the time or interest to go back and fix them now
14:42:31 <mauke> oh well. maybe google will index these channel logs at least
14:43:20 <byorgey> true
14:43:44 <asthasr> Cale: baby just awoke; could we continue this by email when I get a chance?
14:44:12 <asthasr> if so, I will work up some json and send you for your thoughts :)
14:44:17 <monochrom> data Q a = Done a | forall b. (Finite b, ToJSON b) => Ask String (b -> Q a).  the type class Finite lets you enumerate all finitely many values of type b.
14:44:29 <Cale> asthasr: You could try to email me, but IRC is honestly a much more reliable way to get in touch with me.
14:44:33 * asthasr nods.
14:44:55 <asthasr> monochrom: I don't understand that type signature. Will hopefully come back and try to comprehend it later. Must go be dad.
14:47:25 <merijn> arkeet: The enabling it is what GHC *used* to do, GHC 7.10 instead complains if the extensions are off
14:48:00 <arkeet> merijn: no, 7.10 complains if you try to use some imported type that needed the extensions.
14:48:15 <arkeet> nothing is changed about needing to specify extensions when you write such types yourself.
14:48:20 <arkeet> afaik.
14:48:32 <merijn> arkeet: Yes
14:48:49 <merijn> arkeet: Where did I say that anything changed with regards to types you write?
14:48:57 <_ryan> hi does anyone know how to create a custom RawSQL in yesod? thank you
14:48:57 <arkeet> I don't know.
14:49:10 <arkeet> I thought we were talking about byorgey's exercises needing FlexibleInstances.
14:49:41 <aspidites> is there a haskell webdev channel, or is everything pretty centralized?
14:49:52 <aspidites> i know of the beginner and game dev channels, but nothing otherwise
14:50:05 <aspidites> wait...redesigned haskell homepage -- community tab
14:50:09 <aspidites> forgot all about taht
14:50:10 <aspidites> that*
14:50:45 <srhb> aspidites: There are channels for each of the major frameworks, but that's about it afaik
14:50:55 <aspidites> thanks srhb 
14:51:17 <aspidites> i had a more general question, which I suppose I could ask here: are there any trends for single page apps in haskell yet? (frameworks, that is)
14:51:33 <aspidites> i think i've seen haskell-react, and something more recently using ghc and frp, but that's about all
14:51:48 <aspidites> oh. maybe i can head to he ghcjs room
14:51:49 <srhb> aspidites: Everyone is up in arms over Reflex.dom :)
14:52:01 <aspidites> srhb: that's the one i was trying to remember 
14:52:05 <aspidites> srhb: have you played with it yet?
14:52:29 <aspidites> i like the idea of react-haskell because it at least reuses libraries im already familiar (more or less) with, such as lucid
14:52:41 <srhb> aspidites: I have it installed, but have not had the time to play with it yet. Been mucking about with various frameworks and backend stuff :)
14:52:58 <srhb> aspidites: There's #reflex-frp if you're interested.
14:53:15 <aspidites> that was fast. i'll head over there and poke around. thanks
14:53:20 <srhb> Sure thing.
14:53:44 <ryantrinkle> aspidites: there's also #haskell-web
14:53:56 <aspidites> speak of the devil :P
14:54:04 <ryantrinkle> haha
14:54:23 <ryantrinkle> i know what you mean about lucid
14:54:50 <ryantrinkle> i haven't had a chance to dig into lucid and understand what reflex-lucid would look like, but i would love to get something like that going
14:54:53 <aspidites> ryantrinkle: I think you mentioned it during the talk, but why wasn't something like lucid or blaze leveraged for Reflex?
14:55:06 <aspidites> ah. already a thought ahead of me, lol
14:55:29 <ryantrinkle> aspidites: well, the design goals are very different when you're producing dynamic rather than static DOM
14:56:13 <ryantrinkle> i'm not sure reflex-blaze is even possible to write, because blaze is so built around this "monoid masquerading as monad" thing
14:56:17 <ryantrinkle> where everything return ()
14:56:26 <aspidites> ryantrinkle: react-haskell doesn't seem to be producing static dom. Though, I'll admit, I haven't gotten far enough with it (documentation) to say whether that's the case, or the examples aren't the type of dynamic dom manipulations you're really talking about
14:56:39 <ryantrinkle> ah, but react is based on very different principles
14:56:45 <ryantrinkle> it produces static dom each frame, and then diffs and applies it
14:57:04 <ryantrinkle> with reflex, there's no need to diff - the FRP system already understands what things have changed and what things have not
14:57:12 <aspidites> ah
14:57:31 <ryantrinkle> also, in reflex, it's all based around return values - an element *returns* its onclick Event
14:57:39 <aspidites> sounds a bit like the argument hplayground's creator was making -- think there's an article explaining why somethign like react isn't needed in haskell
14:57:47 * aspidites goes to dig up article
14:57:53 <ryantrinkle> yeah
14:57:58 <ryantrinkle> to me, react logically has two parts
14:58:04 <ryantrinkle> an engine for diffing virtual dom
14:58:10 <ryantrinkle> and an engine for efficiently applying those diffs to the real dom
14:58:18 <ryantrinkle> FRP makes the first part irrelevant
14:58:25 <ryantrinkle> but the second part is still quite relevant
14:59:11 <ryantrinkle> (and i would very much welcome input from anyone who has a good understanding of the details of DOM performance)
15:01:16 <aspidites> definitely not me. Been doing desktop development mostly until this last year
15:01:26 <aspidites> and of course, none of that (except for static pages) in haskell
15:01:36 * arkeet is coding up asthasr's questionnaire thing
15:01:38 <ryantrinkle> well, one thing i should point out: reflex-dom builds native apps, too ;)
15:01:54 <ryantrinkle> only on linux right now, but should be possible on other platforms with a little work
15:01:54 <aspidites> ryantrinkle: what does that mean?
15:02:09 <aspidites> native in what sense, in other words
15:02:16 <ryantrinkle> aspidites: it uses webkitgtk
15:02:24 <aspidites> aah
15:02:26 <ryantrinkle> and then your haskell code manipulates the DOM through that
15:02:31 <aspidites> spoiler: i'm a qt guy :P
15:02:38 <aspidites> still neat though
15:02:43 <ryantrinkle> it's 5-10x faster, and you can call out to C
15:02:55 <ryantrinkle> also, you can debug your programs using ghci :D
15:03:17 <aspidites> ah, is that using ghcjs's webkitgtk bindings? (remember something like that in passing)
15:03:21 <ryantrinkle> yep
15:03:28 <EvanR> i havent seen any performance issues with regenerating and replacing a large section of the page from scratch 
15:03:42 <EvanR> without caring about diffs
15:04:00 <EvanR> its 60fps but 
15:04:23 <aspidites> hmm..can't find the exact article, but there's this -> https://www.airpair.com/haskell/posts/haskell-tutorial-introduction-to-web-apps
15:04:57 <aspidites> reactive interfaces using haste and haskell. not quite the same ball park, but something might be relevant
15:04:59 <ryantrinkle> EvanR: interesting; what about focus issues and things like that?
15:05:27 <EvanR> in a textbox?
15:05:41 <ryantrinkle> EvanR: yeah
15:05:48 <ryantrinkle> and generally losing the internal state of native controls
15:06:19 <EvanR> like what
15:06:47 <M-ou-se> if i have a State Foo Bar, how do I use that in a StateT Foo Maybe Bar? at first i figured 'lift' would do this, but lift (in this context) is to be used on Maybe Bar, not on State Foo Bar.
15:07:13 <EvanR> i meant to say NOT 60fps but (why would you need this)
15:07:25 <ryantrinkle> ah, that makes sense
15:07:56 <M-ou-se> mapStateT (\(Identity x) -> Just x) would do the trick, but isn't there a generic function for this kind of 'lifting' (or however this should be called)?
15:08:00 <ryantrinkle> i haven't tried it, but i imagine you wouldn't want to lose the internal state of an HTML5 video element, for example
15:08:22 <EvanR> right, so i wouldnt replace that part
15:08:34 <EvanR> just talking about forms
15:09:08 <EvanR> (unless the state of a video element was the actual view of the thing and resetting its state is the point)
15:09:35 <lpaste> nocturne777 pasted “ Occurs check: cannot construct the infinite type:” at http://lpaste.net/130611
15:09:56 <ryantrinkle> EvanR: yeah, that makes sense
15:10:02 <ryantrinkle> EvanR: how do you deal with it with textboxes, though?
15:10:08 <ryantrinkle> focus and selection state, for example
15:10:12 <nocturne777> I tried to use ($!), but it it did not help
15:10:30 <nocturne777> it will fold if I use foldr, tho
15:10:36 <EvanR> ryantrinkle: if you were regenerating a text box due to some model being updated, it may not make sense for selection to persist
15:10:48 <nocturne777> I want to use foldl' as I am going to fold the entire thing anyhow
15:10:59 <EvanR> and selection of normal text also gets messed up by changing the text
15:11:10 <ryantrinkle> true, but what about a case where, say, the textbox's css classes need to change
15:11:19 <ryantrinkle> e.g. if its current value is invalid
15:11:23 <kuribas> nocturne777: indentation looks wrong...
15:12:10 <nocturne777> kuribas: In the copy-paste I messed up the indentation
15:12:19 <nocturne777> in my source code the indentation is correct
15:12:27 <lpaste> nocturne777 revised “ Occurs check: cannot construct the infinite type:”: “corrected indentation” at http://lpaste.net/130611
15:12:27 <mauke> nocturne777: wrong argument order
15:12:50 <mauke> it's foldl (\z x -> ), not foldl (\x z -> )
15:12:51 <nocturne777> mauke: damn!
15:12:58 <EvanR> ryantrinkle: on key up?
15:13:01 <nocturne777> I can't believe I made that mistake
15:13:04 <EvanR> do not like
15:13:07 <nocturne777> mauke: tnx for pointing it out
15:13:52 <ryantrinkle> EvanR: just something, e.g., to shade the box red; nothing obtrusive
15:14:15 <EvanR> well youre treating it as a model update
15:14:24 <EvanR> so its something happening on key up
15:14:27 <EvanR> rather than change
15:15:08 <ryantrinkle> well, i'm not really speaking with respect to MVC or any particular model like that
15:15:23 <ryantrinkle> i'm just curious if there's a good way to replace text boxes without making the user lose their place
15:15:32 <ryantrinkle> it's something that i've been curious about for a while
15:15:39 <kuribas> nocturne777: couldn't you do just rowNums = [0..min 20 (width-1)]?
15:15:53 <EvanR> ryantrinkle: well ive avoided it by only doing anything on change
15:16:03 <ryantrinkle> in reflex-dom, we're just careful never to replace anything unless the programmer specifically asks us to
15:16:03 <EvanR> or blur
15:16:09 <ryantrinkle> ah yeah, that makes sense
15:16:16 <ryantrinkle> it's more of a hypothetical situation :)
15:16:24 <arkeet> okay
15:16:37 <kuribas> nocturne777: and rowNums = width?
15:16:40 <arkeet> asthasr|afk: https://gist.github.com/arkeet/ee61240a866d72f6cf9d
15:16:44 <arkeet> oh afk
15:17:06 <arkeet> well cale can look at this then.
15:17:12 <kuribas> nocturne777: sorry, numOfCols = width?
15:18:09 <EvanR> ryantrinkle: i thnk were just now getting to the point where its practical to get by reasonably without dealing with horrible web crap, but its very easy still to say "hey make my selection region cause scrolling marques react to a midi file" 
15:18:30 <EvanR> because its technically possible, and then people suffer the maintenance consequences
15:18:48 <ryantrinkle> EvanR: haha, good point
15:19:16 <kuribas> nocturne777: maybe use Data.Map.fromList
15:21:25 <EvanR> ryantrinkle: i think even desktop stuff can learn alot from the "lazy" way to do web GUIs. i.e. avoid fancy crap
15:28:59 <hask> hey does anyone have experience downloading gtk2hs for windows 8
15:29:16 <hask> er installing
15:30:59 <ryantrinkle> hask: i haven't tried it, but if you do get it to work, i'd love to hear about it
15:33:48 <hask> or wxHaskell
15:45:02 <logarythm> what is a haskell?
15:47:49 <davidfetter> it's a language based on functionals, which are a gorgeous mathematical construct with many nicely exploitable properties
15:48:04 <arkeet> Haskell is a standardized, general-purpose purely functional programming language, with non-strict semantics and strong static typing. It is named after logician Haskell Curry.
15:48:44 <logarythm> is it a new language? never heard of it before
15:48:56 <arkeet> it's been around since around 1990
15:49:19 <abrar> but unlike a lot of languages, it's getting better with age
15:50:03 <logarythm> is it a scripting language like perl?
15:50:12 <arkeet> https://en.wikipedia.org/wiki/Haskell_%28programming_language%29
15:50:20 <arkeet> it is generally compiled.
15:50:21 <mniip> more like a mix of C and python
15:50:47 <arkeet> but ghc (the most popular haskell compiler) comes with an interactive environment.
15:51:16 <logarythm> nice thanks
15:51:28 <arkeet> "scripting language" isn't a very meaningful term, I think.
15:51:46 <davidfetter> you have to be pretty hipster to use anyting but ghc, especially when you're starting out
15:51:55 <aspidites> i don't know that 'mix of C and python" is very descriptive either
15:52:46 <gfixler> I feel like a big part of my Python -> Haskell transition has been learning about 'wholemeal' programming
15:53:49 * davidfetter suspects he'll really dive into haskell as part of making immutable infrastructure
15:54:41 <rvxi> .join #numerical-haskell
15:54:46 <rvxi> whoops
15:55:36 <rvxi> i'm looking to do sampling from probability distributions
15:55:39 <ryantrinkle> davidfetter: that sounds fun :) have you looked into nix, too?
15:55:53 <rvxi> does anyone have any recommended packages? there are a ton to choose from it seems
15:56:27 <davidfetter> ryantrinkle, briefly. i suspect it won't work super well with the architecture we're planning out. it's literally, "build the image" "deploy the image" "destroy the image"
15:57:37 <ryantrinkle> davidfetter: that may be; but, check out https://nixos.org/wiki/NixOS_on_Amazon_EC2
15:57:45 <ryantrinkle> there's a section "Creating a NixOS AMI"
15:58:03 <ryantrinkle> there's basically a script that'll turn your system config into a prebuilt AMI
15:58:27 <athan> Is there an n-ary (.)?
15:58:42 <athan> (not sure if I have this right in my head)
15:58:47 <mniip> define n-ary
15:58:53 <davidfetter> ryantrinkle, thanks, bookmarking...
15:59:00 <ryantrinkle> no problem :)
15:59:27 <ski> @type foldr (.) id
15:59:28 <lambdabot> Foldable t => t (b -> b) -> b -> b
15:59:38 <athan> mniip: (.n) :: (b -> c) -> (... -> b) -> ... -> c?
15:59:57 <ski> > foldr (.) id [sin,cos,tan] x
15:59:58 <lambdabot>  sin (cos (sin x / cos x))
16:00:01 <mniip> you can use a fold like ski demonstrated
16:00:15 <ski> athan : no
16:00:16 <athan> ski: Oh wow!
16:00:55 <athan> ski: I imagined so :\ what about (.2) :: (b -> c) -> (a1 -> a2 -> b) -> a1 -> a2 -> c?
16:01:04 <mniip> ah
16:01:08 <mniip> that's (.).(.)
16:01:17 <athan> :o!
16:01:23 * ski calls that `(.:)'
16:01:27 <athan> :t (.)(.)(.)
16:01:28 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
16:01:33 <athan> gorgeous
16:01:46 <ski> @let infixr 9 .:; (.:) = (.) . (.)
16:01:47 <lambdabot>  Defined.
16:01:52 <ski> @let infixr 9 .::; (.::) = (.) . (.) . (.)
16:01:53 <lambdabot>  Defined.
16:01:54 <ski> &c.
16:02:17 <ski> @type (.:)
16:02:18 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
16:02:19 <ski> @type (.::)
16:02:20 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
16:02:34 <mniip> ski, I prefer 'liftA fmap liftM'
16:02:39 * athan has edk's lens talk come to mind
16:02:51 <athan> thanks ski :)
16:02:57 <ski> mniip : `liftA' didn't exist when i invented this
16:03:59 <ski> the number of dots in `.:',`.::',&c. is the same as the number of dots in the definition (this suggests the naming)
16:04:23 * gfixler actually noticed that
16:04:28 <ski> the number of characters (the `:'s, and additionally the `.') is the number of arguments that are "passed along" to the right hand function
16:05:02 <ski> so, `(f .: g) x y z' is equal to `f (g x y) z'
16:05:04 * mniip still prefers lifts
16:05:11 <athan> oh that's awesome!!
16:05:20 <ski> depending, SEC may be more appropriate
16:05:23 <athan> mniip: Can you demonstrate the equivalent?
16:05:24 <ski> @where SEC
16:05:24 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
16:05:30 <mniip> liftA (f . liftA g . h) . j
16:05:51 <athan> o_O
16:07:41 * mniip tries to come up with a visualisation
16:08:12 * mniip gives up
16:08:20 <ski> @type liftA `asTypeIn` \liftA -> liftA ?f ?g
16:08:21 <lambdabot> (Applicative f, ?f::a -> b, ?g::f a) => (a -> b) -> f a -> f b
16:08:26 <ski> @type liftA `asTypeIn` \liftA -> liftA fmap liftM
16:08:27 <lambdabot> (Monad m, Functor f) => ((m a1 -> m r) -> f (m a1) -> f (m r)) -> ((a1 -> r) -> m a1 -> m r) -> (a1 -> r) -> f (m a1) -> f (m r)
16:08:43 <ski> so `liftA' here is just an abstract way of saying `(.)'
16:08:45 <roboguy_> I would personally just use fmaps for all of those
16:08:52 <ski> (which is one reason i don't really like it)
16:08:53 <mniip> ski, each of the three is (.)
16:09:02 <mniip> literally
16:09:03 <arkeet> :t on
16:09:04 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
16:09:23 <ski> mniip : all the more reason to avoid it :)
16:10:19 <ski> @type liftA (?f . liftA ?g . ?h) . ?j
16:10:20 <lambdabot> (Applicative f, Applicative f1, ?f::f1 b1 -> b, ?g::a2 -> b1, ?h::a1 -> f1 a2, ?j::a -> f a1) => a -> f b
16:11:20 <ski> if `f' here is abstract, then this would be fine to me. if `f' is actually `(r ->)', then i wouldn't think it was a good way to write it
16:11:47 <mniip> yep
16:11:49 <edk> athan, this isn't the edk you're thinking of
16:11:57 <athan> :x
16:12:24 <mniip> ski, if only there was a typeclass-less prefix .
16:12:44 <edk> sorry. it confuses quite a lot of people in here. i think it's a little too late to change nicks sadly
16:14:05 <ski> @let result :: (b0 -> b1) -> ((a -> b0) -> (a -> b1)); result = (.)
16:14:07 <lambdabot>  Defined.
16:14:30 <ski> @let argument :: (a1 -> a0) -> ((a0 -> b) -> (a1 -> b)); argument = flip (.)
16:14:31 <lambdabot>  Defined.
16:14:52 <fread> has anyone used threepenny-gui
16:15:11 <ski> @let infixr 9 ~>; (~>) :: (a1 -> a0) -> (b0 -> b1) -> ((a0 -> b0) -> (a1 -> b1)); (f ~> h) g = h . g . f
16:15:12 <lambdabot>  Defined.
16:15:29 <ski> (also `result f = id ~> f; argument f = f ~> id')
16:16:22 * mniip awaits patiently
16:16:44 <enojelly> Hi guys! I'm reading the Observational Equality, Now! paper and I've got a question:
16:17:02 <enojelly> if T/X.S then T else T
16:17:02 <enojelly> and
16:17:02 <ski> @type result (result (L.argument ?f))
16:17:03 <lambdabot> (?f::a2 -> a0) => (a -> a1 -> a0 -> b) -> a -> a1 -> a2 -> b
16:17:11 <enojelly> if tt/x.P then t else f 􏰂 t
16:17:11 <enojelly> if ff/x.P then t else f 􏰂 f
16:17:21 <enojelly> I don't quite grasp the meaning of the / here.
16:17:29 <ski> @type result (result (L.argument (map ?f)))
16:17:30 <lambdabot> (?f::a2 -> b1) => (a -> a1 -> [b1] -> b) -> a -> a1 -> [a2] -> b
16:17:42 <ski> you could also say
16:17:53 <ski> @type (result . result . L.argument . map) ?f
16:17:54 <lambdabot> (?f::a2 -> b1) => (a -> a1 -> [b1] -> b) -> a -> a1 -> [a2] -> b
16:18:09 <fread> has anyone used threepenny gui before?
16:18:09 <mniip> ಠ_ಠ are you a wizard
16:18:18 <ski> the `result . result . L.argument . map' acts as a "path" in the type, descibing which part we should focus on
16:18:30 <ski> `result' means "move once to the right of a `->'"
16:18:35 <enojelly> "This system is just a fragment of many standard-issue type theories"
16:18:36 <NateUni> Guys if I have some lambda function.. what is the deal with having a \\ after it?
16:18:38 <ski> `argument' means "move once to the left of a `->'"
16:18:47 <ski> map' means "move once inside a `[...]'"
16:18:47 <enojelly> guess I don't know too much about standard-issue type theories, then 8)
16:18:49 <NateUni> \a -> something \\
16:18:55 <arkeet> NateUni: \\ is just an operator.
16:18:56 <arkeet> :t (\\)
16:18:57 <lambdabot> Eq a => [a] -> [a] -> [a]
16:19:02 <mniip> ski, I had a similar idea
16:19:11 <NateUni> hmm  ok.
16:19:12 <ski> see SEC for more info on this idea
16:19:14 <arkeet> it deletes elements from a list.
16:19:38 <enojelly> NateUni, so you should read it as \a -> (something \\ whatsafterit) instead.
16:19:51 <NateUni> Iok thnaks
16:19:56 <roboguy_> arkeet: I think this is a different /
16:19:59 <enojelly> unless the lambda binds stronger?
16:20:08 <fread> :t ==
16:20:09 <lambdabot> Eq a => a -> a -> Bool
16:20:19 <fread> :t liftM2
16:20:20 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:20:26 <arkeet> lambdas extend as far to the right as syntactically possible.
16:20:33 <athan> Is bifunctor's `first` & `second` supposed to collide with Control.Arrow's?
16:20:35 <arkeet> so, weaker than everything else.
16:20:36 <NateUni> How do I use it?
16:20:43 <mniip> ski, I even came up with liftS f = flip . flip f . flip
16:20:51 <arkeet> > [1,2,3,4,5,6] \\ [2,4]
16:20:52 <lambdabot>  [1,3,5,6]
16:20:53 <enojelly> arkeet, thanks, I wasn't sure if you couldn't override that with a lower precedence
16:21:21 <arkeet> athan: yes. 
16:21:30 <arkeet> athan: note that both versions of first specialize to (a -> b) -> (a,c) -> (b,c)
16:21:41 <athan> Thanks arkeet :)
16:21:46 <arkeet> (they generalize this in different ways.)
16:22:05 <arkeet> (so does first' from profunctors)
16:22:16 <enojelly> recs▹f/w.P withp􏰂psf(λt.recft/w.P withp)
16:22:19 <NateUni> why doesnt that work? [1,2,3,4] \\ [1,2,3,4,5]
16:22:21 <enojelly> again the /
16:22:21 <athan> Is it common to want to break up a functor into a bifunctor, for specialized behavior in different data constructors?
16:22:27 <arkeet> NateUni: what doesn't work about it?
16:22:28 <aruro> guys, Data.List uses merge sort for sort function, on wikipedia they claim von Neumann suggested merge sort, anyone have seen original article??
16:22:38 <NateUni> it gives []
16:22:47 <roboguy_> I'm pretty sure the Arrow class methods can be rebuilt using nothing but stuff from Profunctor and Category
16:22:49 <NateUni> and [1,2,3,4,5] \\ [1,2,3,4] gives [5]
16:22:50 <arkeet> yes, it deletes all the elements in the second list from the first list.
16:22:53 <arkeet> it's not symmetric.
16:22:56 <NateUni> oh ok
16:23:03 <NateUni> thanks for clearing that up
16:23:15 <athan> roboguy_: That's friggin awesome
16:23:42 <roboguy_> athan: here's something I wrote up a while back. I haven't proven it's the same, but it was something I was thinking about: http://lpaste.net/100875
16:23:55 <arkeet> roboguy_: yup.
16:24:18 <roboguy_> arkeet: the only one I remember not being sure of was ArrowLoop
16:24:20 <arkeet> rather, a strong profunctor.
16:24:27 <arkeet> + category
16:24:41 <arkeet> well, ArrowLoop is some weird thing.
16:24:41 <athan> roboguy_: This is incredible!! Thank you!
16:24:55 <roboguy_> athan: np!
16:26:06 <enojelly> Hmm. I think the / just incarnates the dependent type, if that makes sense (I'm weak on terminology, there)
16:26:36 <roboguy_> arkeet: I think you also need Functor to define arr
16:27:04 <arkeet> no, arr f = rmap f id
16:27:48 <ski> @type mapM
16:27:49 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
16:27:50 <arkeet> (or lmap f id, whichever you like)
16:27:52 <ski> @type (state .) . ((swap .) .) . flip . mapAccumL . flip . ((swap .) .) . (runState .)    :: Traversable t => (a -> State s b) -> (t a -> State s (t b))
16:27:53 <lambdabot> Traversable t => (a -> State s b) -> t a -> State s (t b)
16:27:56 <ski> @type ((flip . result (result swap) . result runState) ~> (result state . result (result swap) . flip)) mapAccumL    :: Traversable t => (a -> State s b) -> (t a -> State s (t b))
16:27:57 <lambdabot> Traversable t => (a -> State s b) -> t a -> State s (t b)
16:28:00 <ski> mniip ^
16:28:11 <ski> @type mapAccumL
16:28:12 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
16:28:14 <arkeet> :t \f -> fmap f . sequenceA
16:28:15 <lambdabot> (Applicative f, Traversable t) => (t a -> b) -> t (f a) -> f b
16:28:22 <arkeet> oh never mind.
16:28:29 <arkeet> :t traverse
16:28:30 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
16:28:40 <roboguy_> arkeet: oh right. You could do it with fmap as well
16:28:49 <ski> (iow : `mapAccumL' is basically the same as the `State' instance of `mapM')
16:29:11 <arkeet> :t mapAccumL
16:29:13 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
16:32:05 <sofianito> Hi there
16:32:17 <mccn> hello
16:32:23 <sofianito> I'm having trouble to install ghc-mod
16:32:46 <mccn> in what OS?
16:33:00 <sofianito> Mac OS X 10.9.5
16:33:03 <arkeet> what is the trouble?
16:33:24 <sofianito> cabal: Error: some packages failed to install:
16:33:24 <sofianito> ghc-mod-5.2.1.2 depends on haskell-src-exts-1.16.0.1 which failed to install.
16:33:24 <sofianito> haskell-src-exts-1.16.0.1 failed during the configure step. The exception was:
16:33:26 <sofianito> ExitFailure 1
16:33:28 <sofianito> hlint-1.9.19 depends on haskell-src-exts-1.16.0.1 which failed to install.
16:33:31 <sofianito> cabal fails
16:33:57 <siwica> As I am fairly new to haskell I am looking for an elegant way
16:33:57 <siwica>       to count the occurences of numbers in a list of intergers. E.g. both
16:33:57 <siwica>       [2,2,3,5,5,5] and [5,5,3,2,2,5] should become [2,1,3]
16:34:41 <arkeet> sort, group, and then look at lengths of groups?
16:34:51 <gfixler> map length . group . sort
16:34:51 <mccn> have you tried to install  haskell-src-exts-1.16.0.1 separately, sofi?
16:34:56 <siwica> ok, I didn't know about group
16:35:02 <arkeet> group is nice.
16:35:10 <sofianito> I'' try it right now
16:35:22 <michaelt_> siwica: but you do need to sort first if you go that way
16:35:27 <arkeet> post the build log of the package that fails.
16:35:33 <michaelt_> > group "hhhihhh"
16:35:34 <lambdabot>  ["hhh","i","hhh"]
16:35:48 <michaelt_> > group $ sort "hhhihhh"
16:35:49 <sofianito> Didn't work
16:35:49 <lambdabot>  ["hhhhhh","i"]
16:35:51 <sofianito> cabal install haskell-src-exts-1.16.0.1                                                                                                          ⏎
16:35:51 <sofianito> Resolving dependencies...
16:35:51 <sofianito> Configuring haskell-src-exts-1.16.0.1...
16:35:53 <sofianito> Failed to install haskell-src-exts-1.16.0.1
16:35:54 <siwica> michaelt_: yes, that's clear
16:35:55 <sofianito> Build log ( /Users/sofianec/.cabal/logs/haskell-src-exts-1.16.0.1.log ):
16:35:57 <sofianito> Configuring haskell-src-exts-1.16.0.1...
16:35:59 <sofianito> setup-Simple-Cabal-1.22.2.0-x86_64-osx-ghc-7.10.1: The program 'happy' version
16:36:00 <arkeet> stop
16:36:01 <sofianito> >=1.17 is required but it could not be found.
16:36:03 <sofianito> cabal: Error: some packages failed to install:
16:36:05 <sofianito> haskell-src-exts-1.16.0.1 failed during the configure step. The exception was:
16:36:07 <sofianito> ExitFailure 1
16:36:19 <arkeet> please don't paste many lines in irc like that.
16:36:20 <michaelt_> sofianito: cabal install happy
16:36:27 <sofianito> I got a hint from the log
16:36:28 <arkeet> but anyway, as the error indicates, the program 'happy' is missing.
16:36:31 <sofianito> yep thanks:
16:36:33 <sofianito> less  /Users/sofianec/.cabal/logs/haskell-src-exts-1.16.0.1.log                                                                                  ⏎
16:36:33 <sofianito> Configuring haskell-src-exts-1.16.0.1...
16:36:33 <sofianito> setup-Simple-Cabal-1.22.2.0-x86_64-osx-ghc-7.10.1: The program 'happy' version
16:36:35 <sofianito> >=1.17 is required but it could not be found.
16:36:40 <sofianito> Thanks 
16:37:39 <michaelt_> sofianito: you might do cabal install alex too, and maybe a couple other standard haskell build helpers. 
16:37:56 <arkeet> yes, you probably also need alex.
16:37:57 <roboguy_> @paste
16:37:57 <lambdabot> Haskell pastebin: http://lpaste.net/
16:38:02 <arkeet> and please use this in the future ^
16:38:05 <roboguy_> ^ sofianito when you have that many lines, you should use that
16:38:06 <siwica> This is probably a dumb question, but how do I make the functions of a specific module available in ghci?
16:38:15 <arkeet> siwica: import the module.
16:38:18 <arkeet> e.g. import Data.List
16:38:28 <arkeet> (or you can fiddle with the :m command)
16:38:43 <sofianito> ok thanks for the tips
16:38:59 <nkar`> parallelism question: do <- res1 $ par action1; res2 $ par action2; return $ (res1, res2).  does the second 'par' require ghc to use the second core, or is it only used if the first one is overloaded?
16:39:02 <arkeet> siwica: when you do this, by default it'll show the list of all modules that are imported in your prompt, which is kind of annoying.
16:39:12 <arkeet> siwica: so I like to do something like  :set prompt ">>> "
16:39:18 <arkeet> (you can put that in ghci.conf too)
16:39:28 <siwica> arkeet: ok, cool! Thank you.
16:43:26 <heatsink> nkar`: Available work is run on idle threads.  Deciding which core will run a computation depends on both GHC's scheduler and the OS's scheduler.
16:44:34 <heatsink> nkar`: They both try to schedule in a way that keeps all the cores busy
16:46:47 <michaelt_> nkar`: where is this `par` from? It isn't the usual one, no?
16:47:10 <arkeet> I think nkar` got some <- and $ mixed up.
16:49:30 <sofianito> Now I got another while installing ghc-mod: http://lpaste.net/130616
16:49:37 <sofianito> error *
16:50:53 <sofianito> any hint please?
16:50:53 <Cale> nkar`: par only adds expressions to a queue which the scheduler will pull from and create spark threads when there are capabilities that have no runnable threads. Depending on how things go, the expressions may already be evaluated by the time a spark gets evaluated, in which case, no harm is done apart from the scheduling effort (it'll appear as a constructor, and evaluate to itself immediately)
16:51:32 <bananagram> I can't compile OpenGLRaw under GHC 7.10.1; it uses too much memory on my 4GB system
16:51:36 <bananagram> bug?
16:52:01 <aruro> hm Von Neumann did not invent merge sort :D
16:52:17 <aruro> some guy at IBM did
16:53:18 <arkeet> I invented merge sort.
16:53:39 <arkeet> but wikipedia says it was von Neumann.
16:53:40 <aruro> god bless you erroneous wikipedia :)
16:53:46 <aruro> it is wrong
16:53:53 <aruro> if you go to knuth book
16:53:57 <Cale> sofianito: hmm, that looks like perhaps a different version of the ghc API is in use from what ghc-mod expects.
16:54:06 <aruro> he tells there was IMB card sorting automat before computers :)
16:54:08 <davidfetter> aruro, fix it :)
16:54:15 <aruro> nah
16:54:36 <aruro> dont have account
16:54:40 <arkeet> don't need one
16:54:47 <davidfetter> i don't think you need one
16:54:53 <sofianito> @Cale: Shall I reinstall cabal-install and ghc?
16:54:53 <lambdabot> Unknown command, try @list
16:55:03 <Cale> sofianito: The ghc-mod package doesn't put any version constraints on the ghc package, which seems a little bit sketchy. It probably ought to.
16:55:25 <Cale> sofianito: I'm guessing that it just doesn't build with whatever version of ghc it is that you have.
16:55:35 <davidfetter> dependency is tough. let's go shopping!
16:55:41 <davidfetter> </barbie>
16:55:46 <enojelly> dependent types also.
16:55:55 <Cale> (or at least, whichever version of ghc-mod you're trying to build doesn't go with whatever version of ghc you're using)
16:56:34 <Cale> It is well known that dependent types are Simply Easy :) http://strictlypositive.org/Easy.pdf
16:56:35 <enojelly> So what's the application of a dependent type called, actually?
16:56:42 <sofianito> my ghc version is: 7.10.1
16:56:45 <michaelt_> bananagram: it seems to have 520 modules 
16:56:48 <arkeet> aruro: well, if your Knuth source is TAoCP, wikipedia cites that for the von neumann reference. maybe IBM's thing doesn't strictly satisfy what wikipedia considers to be a merge sort algorithm. anyway this is getting offtopic heh.
16:57:08 <Cale> sofianito: It's possible that ghc-mod hasn't been updated yet. 7.10.1 only just came out.
16:57:10 <enojelly> Cale, hah, great, thanks
16:57:15 <aruro> :) von Neumann seems to just be first to write actual program
16:57:20 <siwica> what is the best way to map length+1 instead of length to a list?
16:57:21 <roboguy_> enojelly: you mean like applying a pi type? I think just application
16:57:23 <aruro> he knew algorithm from mechanics
16:57:26 <enojelly> I had great fun *using* them in agda
16:57:38 <aruro> hence he did not invent algorithm
16:57:42 <enojelly> roboguy_, just application? It feels like there should be a word for it, but maybe there isn't
16:57:43 <arkeet> might be a good opportunity to add a "history" section then!
16:57:59 <bananagram> michaelt_: it doesn't use much memory until it reaches Graphics.Rendering.OpenGL.Raw.Functions
16:58:11 <roboguy_> enojelly: well, it's ultimately just a function at the type level so I would expect it is called application
16:58:20 <Cale> enojelly: A fibre?
16:58:26 <sofianito> @Cale: It makes sense then. I guess I have to downgrade my ghc install
16:58:26 <lambdabot> Unknown command, try @list
16:58:42 <aruro> arkeet, maybe some other day :)
16:58:46 <heatsink> Cale: Was that paper formerly titled LambdaPi?
16:58:53 <Cale> sofianito: You might want to look and see if there's a github package or something
16:59:03 <enojelly> roboguy_, yeah, but there are a lot of other words for specific things. Kind, sort...
16:59:10 <enojelly> roboguy_, in dependent types, all of those are just "types" as well
16:59:18 <sofianito> @Cale: I'll check it out. Thanks
16:59:19 <lambdabot> Unknown command, try @list
16:59:27 <Cale> sofianito: https://github.com/kazu-yamamoto/ghc-mod/issues/437
16:59:27 <enojelly> roboguy_, so are, basically, values, no?
16:59:52 <enojelly> Cale, is fibre actually used, or is that a proposal? 8)
17:00:03 <roboguy_> fibre might be accurate. That's near the part of HoTT I didn't understand
17:00:10 <Cale> sofianito: So, https://github.com/DanielG/ghc-mod is supposed to actually work with 7.10.1
17:00:12 <enojelly> ah
17:00:41 <Cale> enojelly: Yeah, that name comes from the homotopy theory point of view
17:00:57 <enojelly> roboguy_, and an "application" is a bit too generic of a term to use when talking about dependent types, I think
17:01:00 <roboguy_> unfortunately, I don't really know anything about homotopy so that didn't help me too much at the time haha
17:01:02 <enojelly> Cale, great, thanks
17:01:21 <sofianito> @Cale: Many thanks!
17:01:21 <lambdabot> Unknown command, try @list
17:01:46 <michaelt_> bananagram: yeah I was trying it and was about to say, its getting stuck at [199 of 520] which is Graphics.Rendering.OpenGL.Raw.Functions
17:02:00 <roboguy_> sofianito: you should probably avoid starting a message to a specific person with @ since it confuses lambdabot
17:02:32 <enojelly> (also it's not really done in IRC. It's just a convention, and you're free to ignore it, but in this channel there's actually a good reason not to do it 8) )
17:02:41 <sofianito> roboguy_: Thanks for the tip
17:03:36 <michaelt_> bananagram: oh, I see it is the profiling compilation it is getting stuck on, maybe one could turn that off ?
17:03:44 <Cale> enojelly: Specifically, you picture Sigma (x:A), P x as being a big space (the "total space of the fibration") with the type A (the "base space") sitting in its "shadow", and for each x in A, the type P x is called the "fibre lying over x", you sort of picture it as being part of the total space.
17:04:05 <Cale> Oh, "shadow" there wasn't intended as technical
17:04:13 <Cale> The other quoted terms are technical terms :)
17:04:13 <roboguy_> Cale: what would be a good place to start learning about the parts of homotopy theory you need to understand HoTT?
17:04:41 <enojelly> Cale, oh, I think I get it
17:04:42 <bananagram> michaelt_: do you know how to do that?
17:04:44 <Cale> roboguy_: Did you try reading the HoTT book starting from Chapter 1? It sort of tries to teach enough homotopy theory on its own.
17:04:55 <Cale> (the intro is hard to follow though)
17:04:55 <bananagram> I wouldn't
17:05:21 <roboguy_> Cale: I did a while back, but I remember them assuming you know terms like "fibration" and "homotopy lifting property"
17:05:35 <roboguy_> maybe I gave up too easily
17:05:45 <Cale> Well... they define those terms, but yeah.
17:06:08 <enojelly> Cale, heh, I did that. More or less skipped the intro, and then read as far as I could just for the dependent types, not actually having reached any "homotopy" stuff yet 8)
17:06:17 <Cale> roboguy_: HoTT is to classical homotopy theory what Euclidean geometry is to geometry in the style of Descartes
17:06:46 <Cale> So, it's sort of defining things as primitive notions which would usually be built up out of lots of sets
17:06:51 <enojelly> I knew dependent types from Agda, going so far as implementing veeery simple type systems in it, but I think HoTT does a great job of explaining them in theoretical terms
17:07:08 <Cale> If you want a book on classical homotopy theory, I can recommend Brown's Topology and Groupoids
17:07:17 <roboguy_> Cale: maybe I'm misremembering, but I thought they defined it in terms of other homotopy terms
17:07:24 <michaelt_> bananagram: in your ~/.cabal/config do you have library-profiling: True uncommented? You could use the flag  --disable-library-profiling I guess.  None of this is going to be ideal..
17:07:24 <Cale> hmm
17:08:46 <Cale> roboguy_: It seems as if the term "homotopy lifting property" doesn't actually occur. They use the term "path lifting" at one point.
17:09:07 <roboguy_> Cale: ahh, that's probably what I was thinking of
17:09:19 <Cale> and they talk about lifting equivalences
17:09:24 <bananagram> michaelt_: I think I'll do it, then if it works I'll submit a bug report
17:09:48 <michaelt_> bananagram: hm, it does still take forever to do [199 of 520] with profiling disable, im waiting on it.
17:09:58 <slack1256> Are module systems compatible with nix-style packages?
17:10:06 <bananagram> yeah, it failed
17:11:00 <enojelly> Cale, soooo... is the number of fibers in a dependent type basically P^A?
17:11:17 <roboguy_> Cale: that's the part about lifting equivalence from types to a type family applied to those types, isn't it?
17:12:17 <fread> has anyone used threepenny gui?
17:12:20 <Cale> roboguy_: yeah
17:12:26 <Cale> enojelly: I'm not sure what that means
17:12:47 <Cale> enojelly: There is one fibre for each of the elements of A.
17:12:57 <roboguy_> Cale: that part made sense to me intuitively, I think it was just that the new terms they introduced intimidated me a bit. I should probably give it another go
17:13:01 <Cale> enojelly: Where P: A -> Type
17:13:09 <fread> :t where
17:13:10 <lambdabot> parse error on input ‘where’
17:13:23 <Cale> fread: where is a keyword
17:13:23 <roboguy_> fread: I haven't, but what problem are you having?
17:13:33 <enojelly> What does the "-oid" suffix mean, by the way? I read about groupoids, setoids... I think I've recently learned that setoids are sets with a defined equality?
17:13:53 <ReinH> enojelly: I don't think it has a consistent meaning
17:13:58 <fread> just on how to use the threepenny after cabal install
17:14:00 <Cale> enojelly: "Generalisation of"
17:14:01 <michaelt_> bananagram: I see, this module exports 3000 functions ...
17:14:15 <ReinH> Cale: Monoid is a generalization of... mons?
17:14:25 <Cale> heh
17:14:37 <Cale> Well, it includes a generalisation of one :)
17:14:41 <slack1256> fread: https://ocharles.org.uk/blog/posts/2013-12-07-24-days-of-hackage-threepenny-gui.html
17:14:47 <enojelly> Cale, okay yeah that makes more sense (one fibre for each element), thanks
17:14:47 <slack1256> maybe haven't used it
17:15:22 <bananagram> michaelt_: of course it worked in GHC 7.8
17:15:24 <michaelt_> bananagram: hm, and the module itself is 60000 lines long. 
17:15:38 <ryantrinkle> fread: if you're looking to write web GUIs in haskell, you might want to check out reflex (my library)
17:15:39 <enojelly> This was interesting: http://gelisam.blogspot.com/2010/10/equality-is-useless-transmutation.html
17:15:49 <Cale> regarding -oid, OED says: Forming adjectives with the sense ‘having the form or nature of, resembling, allied to’, and nouns with the sense ‘something having the form or appearance of, something related or allied in structure, but not identical’
17:15:49 <ryantrinkle> the talk is here https://www.youtube.com/watch?v=mYvkcskJbc4
17:15:54 <bananagram> michaelt_: I compiled it successfully on netbook
17:16:09 <ryantrinkle> fread: if it looks interesting to you, i'll be happy to answer any of your questions :)
17:16:12 <enojelly> dependent types get me confused sometimes because my mind wanders between orders %)
17:16:55 <Cale> So, monoid comes from the prefix mono- meaning "one", and that, referring to the idea that monoids have a unit element.
17:17:26 <Cale> There's also a lot of geometric uses
17:17:31 <Cale> Like ellipsoid
17:17:39 <enojelly> matroid
17:17:39 <Cale> hyperboloid
17:17:54 <fread> so ive been just trying to have some haskell GUI library to work for windows 8 since wxHaskell and gtk2hs was taking too long
17:18:08 <Cale> Yeah, matroid works too -- especially as the original examples were encoded by matrices
17:18:10 <fread> to work with*
17:18:25 <slack1256> metroid ;_;
17:18:36 <ryantrinkle> fread: ah, i wish i could help you there
17:18:38 <enojelly> Anyway, gotta make Risottoid now. Let's see how it turns out. C'ya.
17:19:05 <ryantrinkle> fread: reflex-dom builds stuff for in-browser or linux; i don't have support for native apps yet
17:19:08 <michaelt_> fread: there was just blather about http://www.reddit.com/r/haskell/comments/32c9tq/announcement_fltkhs_bindings_to_the_fltk_gui/ 
17:19:10 <ryantrinkle> er, native apps on windows
17:19:11 <Cale> slack1256: D e e R F o r C e
17:19:21 <michaelt_> fread: which advertises itself as windows-also
17:21:18 <arkeet> ooh, I might check that out.
17:21:19 <arkeet> fltk
17:22:05 <arkeet> I dunno.
17:22:47 <michaelt_> It's a little rustic it seems, this fltk
17:23:11 <bananagram> michaelt_: with -O0, it does compile
17:23:22 <michaelt_> ah 
17:26:02 <michaelt_> bananagram: I cant remember, the default cabal uses is -O1, and -O0 is sort of what ghci uses? 
17:26:08 <bananagram> haddock, calm down
17:26:12 <bananagram> 2GB is too much
17:26:17 <hodapp> o_O
17:26:36 <bananagram> michaelt_: yes, 1 by default
17:27:14 <michaelt_> yeah, carefully labelling 3000 functions is not something haddock is generally doing ...
17:28:06 <michaelt_> bananagram: maybe you don't lose much with -O0 if it's just a matter of getting a bunch of foreign things in place. 
17:28:25 <michaelt_> or maybe the opposite is true..
17:28:37 <bananagram> yeah
17:29:06 <bananagram> I'll just downgrade to 7.8.4 for now
17:29:36 <siwica> Could you help me with finding the error in this statement?
17:29:40 <siwica> foldr (*) 1  map (\ x -> length x + 1) . group . sort $ [2,3,2,2,5,5]
17:30:20 <bananagram> try inserting a $ after foldr (*) 1 
17:30:38 <bananagram> or putting everything after that in parens
17:30:43 <siwica> ah, perfect ;)
17:31:15 <siwica> bananagram: thank you!
17:31:23 <bananagram> np
17:32:56 <siwica> is there some simpler function than foldr (*) 1 for multiplication where I could ommit the initial value 1?
17:34:28 <Pamelloes> What are the various options for building a GUI using Haskell?
17:35:49 <roboguy_> siwica: foldr1, but you have to know that the list has at least one element
17:35:58 <bananagram> > foldr1 (*) [3,4,6]
17:36:00 <lambdabot>  72
17:36:13 <bananagram> > foldr1 (*) []
17:36:14 <lambdabot>  *Exception: Prelude.foldr1: empty list
17:36:18 <bananagram> hm
17:39:54 <siwica> ok, forgot about foldr1
17:40:11 <siwica> thanks, I am quite new to haskell 
17:40:47 <siwica> Is there some convention on whether to use sneak_case or CamelCase for function names in haskell?
17:41:23 <roboguy_> siwica: I very rarely see people use something other than camelCase
17:41:59 <siwica> ok, thank you!
17:42:30 <bananagram> weechat 0.3.2? geez
17:42:44 <roboguy_> siwica: once in a while I'll see snake_case and on very, very rare occasions I'll see them use this'kind'of'convention. But yeah, mostly camelCase
17:42:45 <siwica> Is there some Haskell "style guide" document" that is widely accepted?
17:43:03 <srhb> roboguy_: Obviously that's dromedaryCase
17:43:14 <siwica> haha
17:43:15 <srhb> roboguy_: CamelCase is reserved for type and value constructors. :-)
17:43:41 <roboguy_> srhb: ha. yeah, that's why I said camelCase
17:43:52 <timothyh> i'm curious if there's an authoritative Haskell style guide that puts everything together in one place
17:44:05 <siwica> I got it right away, but I like dromedaryCase
17:44:08 <roboguy_> I'm trying to remember where I saw domedary'case haha. It was something relatively big I think
17:44:11 <srhb> timothyh: Not really. As long as you don't use tabs you won't get flayed.
17:44:23 <roboguy_> oh I see
17:44:26 <srhb> roboguy_: I mean, dromedaryCase because... One hump
17:44:27 <srhb> :P
17:44:30 <roboguy_> right, haha
17:44:35 <srhb> Sorry, it's a terrible joke.
17:44:43 <timothyh> ithink th emost common thing I see is 2 spaces, utrecht style for multiline lists / records / imports, and 80 chars
17:44:45 <timothyh> nothing too fancy
17:44:50 <roboguy_> I wonder if there's a name for the single quote thing
17:45:11 <srhb> timothyh: There's whatever stylish-haskell does...
17:45:23 <timothyh> stylish haskell only really touches the import list
17:45:31 <srhb> timothyh: But really I love the flexibility and I don't mind reading slightly differently styled Haskell as long as dromedaryCase, CamelCase, no tabs....
17:45:43 <siwica> timothyh: ok, it seems that's kindof what emacs haskell-mode is doing, so I guess I'll be fine when it come sto indenting
17:45:45 <timothyh> mm. i  quite like it when people align their <- and such
17:45:49 <srhb> True!
17:46:05 <srhb> Unless you have a <- ..; b <- ..; veryLongName <- ...
17:46:05 <timothyh> and their = in let bindings
17:46:15 <srhb> I might break them up into groups then
17:46:17 <timothyh> and :: and -> in type signatures etc
17:46:22 <michaelt_> does haskell mode do things like aligning <- ?
17:46:28 <timothyh> not afaik
17:46:29 <srhb> michaelt_: I don't think so.
17:46:51 <michaelt_> I like it too, but feel like a moron doing it by hand ...
17:47:00 <srhb> M-x align-regex
17:47:16 <timothyh> i much prefer reading code styled that way
17:47:18 <srhb> But yes, it should be automated
17:47:45 <timothyh> i'm not sure you'd want it automated, since dogmatically following it could cause problems. like if you have a single very long name and the rest are single characters
17:48:00 <srhb> Yes, indeed.
17:48:13 <timothyh> although I guess you could have a max align length or something
17:48:14 <srhb> Well, then align-regex does what is needed.
17:48:41 <sofianito> How can I install ghc 7.8.4 with mac os x homebrew?
17:48:48 <siwica> Just define a macro an map it to a key I guess
17:49:13 <timothyh> thanks for align-regexp, I didn't know of it
17:49:20 <srhb> timothyh: It's great. :)
17:50:10 <timothyh> excellent
17:50:55 <pharpend> Hey, I'm trying to build my program statically linked, to make it easier to distribute
17:51:30 <pharpend> If I turn on static linking in cabal, i get this long string of errors: http://ix.io/hQo
17:51:50 <pharpend> I've tried googling it, but all of the solutions involve the libraries in queston not existing
17:52:18 <pharpend> But they do exist. For instance, libgmp: http://ix.io/hQp
17:55:58 <bananagram> I get those errors too trying to compile programs statically linked
17:57:27 <pharpend> Here's what happens when I turn the linker to verbose mode: http://ix.io/hQq
17:59:40 <roboguy_> sofianito: I think the recommended way is from the GHC binaries off the website. Also, 7.8.3 isn't the latest
17:59:46 <roboguy_> or, 7.8.4
18:00:04 <pharpend> roboguy_: I have 7.10
18:02:03 <sofianito> pharpend: Did you install it with homebrew?
18:02:11 <pharpend> sofianito: no
18:02:31 <sofianito> haskell platform?
18:02:36 <pharpend> sofianito: pacman
18:03:05 <pharpend> sofianito: https://wiki.archlinux.org/index.php/Pacman
18:03:38 <sofianito> pharpend: I see. I'm on Mac 10.9.5
18:04:22 <pharpend> roboguy_: oops I thought you were talking to me =P
18:04:46 <pharpend> sofianito: alright
18:05:24 <sofianito> roboguy_: Where should I get the right cabal binaries that work with ghc 7.8.4?
18:05:45 <roboguy_> sofianito: if you just want 7.8.4, I would use the Haskell Platform
18:05:59 <roboguy_> oh, I guess they have 7.8.3
18:06:10 <pharpend> sofianito: I don't know much about OS X, but bitemyapp is trustworthy: https://github.com/bitemyapp/learnhaskell#mac-os-x
18:06:37 <sofianito> I just want ghc and cabal with homebrew :/
18:06:49 <roboguy_> why does it need to be homebrew?
18:06:52 <pharpend> sofianito: Is that some weird attempt at an OS X package manager?
18:06:59 <roboguy_> you can get a newer version without it...
18:07:02 <funfunctor> Does anyone happen to know a algorithm that auto balances weight scales?
18:07:10 <roboguy_> and I hear people sometimes have issues installing ghc with homebrew
18:07:13 <pharpend> I vaguely remember MacPorts
18:07:25 <roboguy_> pharpend: it's the current popular one
18:07:35 * pharpend swims in the nostalgia
18:07:39 <pharpend> I remember BSD ports
18:07:42 <roboguy_> I remember my Fink days...
18:07:58 <michaelt_> pharpend: homebrew is what we dim bulbs use.
18:08:03 <pharpend> Heh
18:08:09 <sofianito> pharpend: They upgraded ghc homebrew formuale to 7.10, but ghc-mod is broken with that version
18:08:23 <pharpend> I wasn't aware that anyone actually used ghc-mod
18:08:27 <michaelt_> sofianito: do you already have a ghc and cabal executable?
18:08:35 <pharpend> sofianito: 7.10 is definitely worth the switch
18:08:36 <sofianito> yes
18:08:55 <pharpend> I was disappointed that they moved Control.Applicative to Prelude, but not Data.
18:08:57 <pharpend> Monoid
18:08:59 <roboguy_> pharpend: your experience has been good so far? I've been trying to decide when to upgrade
18:09:07 <pharpend> roboguy_: what OS are you on?
18:09:12 <roboguy_> OS X
18:09:19 <roboguy_> 10.10.2
18:09:20 <sofianito> michaelt_: I have installed them with brew
18:09:22 <michaelt_> sofianito: you can probably keep cabal. you can just install ghc locally in ~/ghc/bin or whatever , putting it in $path or using a symlink. 
18:09:33 <pharpend> roboguy_: ah. Arch Linux sort of forced me to upgrade
18:10:11 <michaelt_> sofianito: it takes about thirty seconds to install ghc from https://www.haskell.org/ghc/download_ghc_7_8_4#macosx_x86_64
18:10:11 <pharpend> roboguy_: really, the big advantage is that you don't have to import control.applicative any more
18:10:20 <roboguy_> pharpend: that's very nice. I always wanted that
18:10:24 <pharpend> michaelt_: that's the old version of GHC
18:10:34 <sofianito> michaelt_: I'll give it a try
18:10:36 <roboguy_> pharpend: (it'll help my code golf too!)
18:10:55 <michaelt_> sofianito: you just unpack it, enter the directory, type "./configure --prefix=/Users/sofianito/ghc" or whatever, then make 
18:11:11 <michaelt_> pharpend: oh, I thought sofianito wanted the slightly old one
18:11:24 <pharpend> Oh i see.
18:12:05 <pharpend> sofianito: it's sad that non-*nix users never got "./configure && make && sudo make install" in their muscle memory
18:12:07 <michaelt_> sofianito: the cabal executable should still be functional but you might use it to install the more appropriate one for your ghc ; it might not matter, not sure. 
18:15:29 <sofianito> I'll install 7.10 and wait until they fix ghc-mod.
18:16:15 <roboguy_> speaking of installing GHC in order to upgrade, can I just install the new version? Or is there something special I should do? I was never clear on that
18:20:53 <siwica> is there some canonical way on how to name helper functions?
18:23:36 <srhb> siwica: You will see 'go' littered all over the sources of base
18:23:52 <srhb> siwica: In my opinion it depends on the helper function.
18:24:34 <benzrf> hmmmm
18:24:46 <benzrf>    Kind * cannot be applied
18:24:48 <benzrf>    In the kind ‘* *’
18:24:56 <benzrf> but no sorts?
18:25:00 <benzrf> er, only 1 
18:25:18 <srhb> GHC has sorts?!
18:26:48 <exio4> benzrf: that's why that new "dependent typed type system" would be cool
18:39:55 <ttt_fff> so this is sorta a vim/haskell/postgresql question. I have written this wiki system in postgresql + haskell. Now, I'd like an VIM interface to my note taking system. The note taking system is RESTFUL (GET/POST/PUT) ... I need some way (writing this code in Haskell) to let me use VIM as the editor, but somehow make these GET/POST/PUT requests
18:40:45 <lpaste> Simon pasted “Project Euler - Problem 12” at http://lpaste.net/130621
18:41:17 <siwica> I just wrote my almost first haskell programm doing a 'Project Euler' problem. Could you just quickly check the program for some things one should avoid?
18:41:42 <siwica> The problem was https://projecteuler.net/problem=12
18:42:05 <Clint> siwica: did you take note of the hlint warnings at the bottom?
18:42:42 <siwica> I didn't get to see it before it was posted here. It worked with ghci and the output was correct
18:43:14 <siwica> ok, the hlint warnings make sense 
18:44:34 <siwica> any other "mistakes" such es formatting errors or so?
18:44:58 <siwica> just want to be sure I am not developing bad  habits
18:46:14 <pacak> siwica: 4 spaces offsets are customary in haskell in most libraries. With 2 it looks like Ruby.
18:47:08 <siwica> pacak: I was doing Ruby before but emacs haskell-mode is to blame for this ;)
18:47:16 <siwica> good to know though!
18:50:48 <lpaste> Simon revised “Project Euler - Problem 12”: “No title” at http://lpaste.net/130621
18:59:35 <fread> anyone have experience with threepenny gui?
18:59:53 <fread> im trying to change the text within a button after clicking it while keeping it on the same location
19:57:10 <rvxi> hello
20:00:11 <XorSwap> > [0..]
20:00:12 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
20:00:18 <XorSwap> huh
20:01:31 <michaelt_> > [1, 0..]
20:01:32 <lambdabot>  [1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,...
20:02:02 <michaelt_> hello rvxi 
20:02:26 <XorSwap> > map fst $ filter snd $ zip [2..] $ fix (((True :) .) . ap (zipWith (&&) . cycle . (++ [False]) . flip replicate True) . (. (1 +))) 1
20:02:27 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
20:03:03 <XorSwap> > map fst $ filter snd $ zip [2..] $ fix (((True :) .) . ap (zipWith (&&) . cycle . (++ [False]) . flip replicate True) . (. (1 +))) 2
20:03:05 <lambdabot>  [2,3,4,6,10,12,16,18,22,28,30,36,40,42,46,52,58,60,66,70,72,78,82,88,96,100,...
20:03:31 <XorSwap> > map
20:03:33 <lambdabot>      No instance for (Typeable a0)
20:03:33 <lambdabot>        arising from a use of ‘show_M14474712229414536719546’
20:03:33 <lambdabot>      In the expression:
20:03:45 <HeladoDeBrownie> pacak, i've seen (and use) two-space indents solely for the 'where' keyword that begins a clause (and similar-looking things)
20:03:49 <XorSwap> > (\f -> f f) (\f -> f f)
20:03:51 <lambdabot>      Occurs check: cannot construct the infinite type: r0 ~ r0 -> t
20:03:51 <lambdabot>      Expected type: r0 -> t
20:03:51 <lambdabot>        Actual type: (r0 -> t) -> t
20:04:06 <NateUni> Guys I how do I check that two ints belong to a list (with ordering unimportant)?
20:04:12 <XorSwap> > f x = x
20:04:14 <lambdabot>  <hint>:1:5: parse error on input ‘=’
20:04:14 <HeladoDeBrownie> @type elem
20:04:15 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
20:04:25 <HeladoDeBrownie> @type Prelude.elem
20:04:26 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
20:04:29 <HeladoDeBrownie> what
20:04:41 <roboguy_> XorSwap: That formulation of the fixed point combinator doesn't work in Haskell. There's another one that does though
20:04:43 <michaelt_> ghc-7.10
20:05:09 <roboguy_> HeladoDeBrownie: FTP
20:05:14 <michaelt_> > elem 2 [2]
20:05:16 <lambdabot>  True
20:05:20 <HeladoDeBrownie> @type \a b xs -> a `elem` xs && b `elem` xs
20:05:21 <lambdabot> (Eq a, Foldable t) => a -> a -> t a -> Bool
20:05:23 <michaelt_> > elem 2 (Just 2)
20:05:24 <HeladoDeBrownie> roboguy_, what?
20:05:25 <lambdabot>  True
20:05:38 <XorSwap> robo, my experiance with functional programming so far has been mostly lambda calc, so I'm not used to types
20:05:41 <roboguy_> HeladoDeBrownie: in GHC 7.10, they replaced a lot of Prelude functions with their general version
20:05:48 <michaelt_> > elem 2 (Right 2)
20:05:49 <lambdabot>  True
20:05:50 <HeladoDeBrownie> roboguy_, neat. what does ftp stand for here?
20:05:59 <XorSwap> ftp
20:06:08 <NateUni> yeah just I want to check both at once.. 
20:06:10 <roboguy_> HeladoDeBrownie: Foldable, Traversable in Prelude
20:06:14 <HeladoDeBrownie> ah
20:06:21 <NateUni> like 1&&2 `elem` [1,2]
20:06:22 <HeladoDeBrownie> NateUni, what do you think of the function i mentioned above?
20:06:38 <XorSwap> > fix fix
20:06:39 <NateUni> oh,… ok
20:06:39 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ a -> a
20:06:40 <lambdabot>      Expected type: a -> a
20:06:40 <lambdabot>        Actual type: (a -> a) -> a
20:06:40 <roboguy_> XorSwap: that would work in untyped lambda calculus, but we have System-Fw typed lambda calculus
20:06:44 <NateUni> missed that thanks
20:06:55 <michaelt_> > elem 3 ("Hello", 3)
20:06:56 <lambdabot>  True
20:07:16 <XorSwap> best I can figure, lambda calc has type F = F -> F
20:07:39 <roboguy_> XorSwap: that is simply typed lambda calculus
20:07:44 <roboguy_> well
20:08:07 <roboguy_> I think it's actually untyped lambda calculus viewed as having a single type. Any time you have an untyped system, you can view it as having a single type
20:08:26 <XorSwap> ok
20:09:00 <roboguy_> the simplest infinite loop here would be
20:09:06 <roboguy_> > let x = x in x
20:09:10 <lambdabot>  mueval-core: Time limit exceeded
20:09:19 <XorSwap> lol
20:12:11 <michaelt_> > Map.fromList ("two", 2)
20:12:12 <lambdabot>      Not in scope: ‘Map.fromList’
20:12:13 <lambdabot>      Perhaps you meant one of these:
20:12:13 <lambdabot>        ‘M.fromList’ (imported from Data.Map),
20:12:22 <michaelt_> ah
20:12:35 <michaelt_> > let ok = elem 2 in [ok (Just 2), ok (Right 2), ok [2], ok ("Hi",2), ok (S.fromList [2]), ok (M.fromList [("two",2)])]
20:12:37 <lambdabot>  [True,True,True,True,True,True]
20:13:15 <michaelt_> I'm sure I'll get used to this ...
20:13:53 <aaronm04> what does it mean to have Type<space>Type in a type definition? For example, a function with type X -> A B
20:14:15 <HeladoDeBrownie> aaronm04, the application of a type-level function to some type
20:14:16 <roboguy_> aaronm04: the type constructor A is applied to the type B to get a type
20:14:22 <mauke> parameterized types
20:14:33 <roboguy_> :t Just 'a'
20:14:34 <lambdabot> Maybe Char
20:14:38 <HeladoDeBrownie> Maybe is a type-level function accepting a concrete type and resulting in a concrete type.
20:14:41 <aaronm04> ah got it, thanks
20:14:50 <michaelt_> aaronm04: Maybe is a typical constructor like that
20:15:22 <aaronm04> so this is also true of a function that does IO? Like someFunction :: Double -> IO ()
20:15:42 <HeladoDeBrownie> aaronm04, yep, and strictly speaking that function doesn't "do" i/o, it only produces an IO procedure
20:15:42 <michaelt_> right
20:15:49 <michaelt_> @type print
20:15:50 <lambdabot> Show a => a -> IO ()
20:15:51 <aaronm04> ah ok
20:17:20 <mauke> :t getChar
20:17:21 <lambdabot> IO Char
20:17:27 <mauke> not a function
20:20:47 <XorSwap> @fp f x y z = x z y
20:20:47 <lambdabot> Maybe you meant: wn v rc pl id faq do bf @ ? .
20:20:53 <rvxi> hey guys
20:20:57 <rvxi> dumb question about evaluation
20:21:05 <ProofTechnique> @pl f x y z = x z y
20:21:05 <lambdabot> f = flip
20:21:15 <rvxi> getNumber mu sd = do   foo <- sample $ rvar  $ Normal (mu :: Double) (sd :: Double)   return foo  getNumber2 mu sd = do   return sample $ rvar  $ Normal (mu :: Double) (sd :: Double)
20:21:18 <rvxi> oops
20:21:23 <rvxi> getNumber mu sd = do
20:21:26 <rvxi>   foo <- sample $ rvar  $ Normal (mu :: Double) (sd :: Double)
20:21:32 <rvxi>   return foo
20:21:38 <rvxi> getNumber2 mu sd = do
20:21:42 <rvxi>   return sample $ rvar  $ Normal (mu :: Double) (sd :: Double)
20:22:21 <rvxi> getNumber 3 2
20:22:23 <rvxi> returns a number
20:22:45 <rvxi> getNumber2 3 2
20:22:47 <rvxi> returns
20:22:53 <rvxi> getNumber2 3 2 :: (Distribution d t, MonadRandom m) => d t -> m t
20:23:10 <rvxi> obviously i'm missing something basic about lazy evaluation 
20:23:27 <rvxi> can someone explain why the sxecond case doesn't return a number? (and how to fix it without the temporary variable?)
20:24:19 <HeladoDeBrownie> rvxi, return is not special syntax like in other languages, it's a function and thus obeys function application precedence rules
20:24:28 <ProofTechnique> :t return
20:24:29 <lambdabot> Monad m => a -> m a
20:24:36 <HeladoDeBrownie> also, i'm not quite sure that expression has the type you want anyway
20:25:20 <HeladoDeBrownie> ah i see, you're using the function Monad instance by accident
20:25:31 <HeladoDeBrownie> or, never mind
20:25:35 <rvxi> I don't understand monads yet
20:25:37 <HeladoDeBrownie> i misread
20:25:48 <rvxi> i think the expression type is right (Double)
20:25:54 <HeladoDeBrownie> well, "understanding monads" is a bit of a chimera anyway
20:26:17 <HeladoDeBrownie> do you understand the basics of typeclasses?
20:26:58 <rvxi> still learning. i've gone through some examples but I'm sure there's things I don't fully get yet
20:27:26 <HeladoDeBrownie> well, return will have a different implementation depending on what type gets filled in for m, basically
20:27:37 <HeladoDeBrownie> but other than that it's just like the other functions you're used to
20:27:43 <roboguy_> rvxi: essentially, in your second example you shouldn't have return
20:27:48 <XorSwap> > let x = x x in x
20:27:50 <lambdabot>      Occurs check: cannot construct the infinite type: t3 ~ t2 -> t3
20:27:50 <lambdabot>      Relevant bindings include
20:27:50 <lambdabot>        x :: t2 -> t3 (bound at <interactive>:1:5)
20:28:21 <XorSwap> > let x = x in x
20:28:25 <lambdabot>  mueval-core: Time limit exceeded
20:28:51 <XorSwap> @pl f x = x x
20:28:51 <lambdabot> f = join id
20:29:11 <XorSwap> @pl f x = x $ f x
20:29:11 <lambdabot> f = fix (ap id)
20:29:15 <roboguy_> I don't think you'll be able to convince the type checker to let you apply something to itself
20:29:31 <roboguy_> directly, anyway
20:29:32 <XorSwap> so it would seem
20:29:34 <rvxi> roboguy - that fixes it. what does it mean that return is a function and what is the second version doing exactly when it doesn't evaluate the argument for return
20:29:36 <rvxi> ?
20:30:19 <roboguy_> rvxi: return is an unfortunately named function that is part of the Monad type class. It puts a value into a "monadic context". Basically, in the second example, your value is already in a monadic context
20:30:33 <ProofTechnique> rvxi: When you use the <- notation, you're sort of pulling the value out of it's Monadic context, while return puts it back in.
20:30:47 <HeladoDeBrownie> you're  not pulling it out, you're just giving it a name
20:30:52 <ProofTechnique> Right
20:31:18 <HeladoDeBrownie> there is no way to "get a value out" of any general monad because not all of them even have a way to get values out
20:31:38 <rvxi> what does it mean to pull something out or put it back in a monadic context? is pulling out like an evaluation?
20:32:01 <ProofTechnique> I said sort of specifically to avoid that idea, but I also shouldn't be trusted
20:32:16 <rvxi> something like being in or out of a closure?
20:33:49 <nelk> @type join id
20:33:50 <lambdabot>     Occurs check: cannot construct the infinite type: a1 ~ a1 -> a
20:33:50 <lambdabot>     Expected type: a1 -> a1 -> a
20:33:50 <lambdabot>       Actual type: a1 -> a1
20:33:59 <XorSwap> @type fix
20:34:00 <lambdabot> (a -> a) -> a
20:34:14 <XorSwap> > fix
20:34:16 <lambdabot>      No instance for (Typeable a0)
20:34:16 <lambdabot>        arising from a use of ‘show_M323749749369369454320434’
20:34:16 <lambdabot>      In the expression:
20:34:33 <XorSwap> fix const
20:34:37 <XorSwap> oops
20:34:45 <XorSwap> > fix const
20:34:47 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ b -> a
20:34:47 <lambdabot>      Expected type: (b -> a) -> b -> a
20:34:47 <lambdabot>        Actual type: a -> b -> a
20:34:48 <roboguy_> rvxi: it's more like naming something in the context, like HeladoDeBrownie said. And how it works depends on which particular Monad you're talking about
20:35:03 <XorSwap> > fix const 3
20:35:05 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ Integer -> a
20:35:05 <lambdabot>      Expected type: (Integer -> a) -> Integer -> a
20:35:05 <lambdabot>        Actual type: a -> Integer -> a
20:35:19 <HeladoDeBrownie> here's an example. using the Maybe Monad instance, "x <- foo" means to give the name x to the value that foo contains in a Just, if it contains one. if it's a Nothing, instead the whole computation short circuits and outputs Nothing.
20:35:20 <rvxi> still have a lot to learn before i can even understand these explanations =P
20:35:30 <XorSwap> @pl f x = f
20:35:31 <lambdabot> f = fix const
20:35:37 <roboguy_> > > fix id
20:35:38 <roboguy_> > fix id
20:35:39 <lambdabot>  <hint>:1:1: parse error on input ‘>’
20:35:39 <lambdabot>  <no location info>: can't find file: L.hs
20:35:42 <roboguy_> aw
20:35:43 <XorSwap> > fix const
20:35:45 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ b -> a
20:35:45 <lambdabot>      Expected type: (b -> a) -> b -> a
20:35:45 <lambdabot>        Actual type: a -> b -> a
20:35:47 <roboguy_> > fix id
20:35:50 <lambdabot>  mueval-core: Time limit exceeded
20:36:23 <ProofTechnique> HeladoDeBrownie: Yeah, that's what I was trying to express by "pulling a value out of a Monadic context", but it is (probably inexcusably) imprecise
20:36:26 <XorSwap> pl gives an expression that doesnt work?
20:36:50 <roboguy_> XorSwap: I don't think pl does any type checking
20:36:53 <ProofTechnique> XorSwap: @pl is a mechanical process more than anything. It doesn't really do any type checking
20:36:58 <XorSwap> oh
20:37:13 <roboguy_> > let y f = f (y f) in y id
20:37:17 <lambdabot>  mueval-core: Time limit exceeded
20:37:27 <HeladoDeBrownie> yeah, i just want to make it clear though that it's not as simple as "pulls the value out". there might be no values. there might be several. there might be a value only at time of interpretation. etc.
20:37:39 <ProofTechnique> Yeah, that's much more precise.
20:37:40 <HeladoDeBrownie> (see: Maybe, [], and IO)
20:38:16 <XorSwap> > let y f = f (y f) in y
20:38:17 <lambdabot>      No instance for (Typeable t0)
20:38:17 <lambdabot>        arising from a use of ‘show_M707121426107672286220569’
20:38:17 <lambdabot>      In the expression:
20:38:25 <XorSwap> > let y f = f (y f) in y y
20:38:26 <lambdabot>      Occurs check: cannot construct the infinite type: t ~ t -> t
20:38:26 <lambdabot>      Expected type: t -> t
20:38:26 <lambdabot>        Actual type: (t -> t) -> t
20:38:39 <XorSwap> > print 3
20:38:40 <lambdabot>  <IO ()>
20:39:10 <rvxi> heladodebrownie ok so that sounds like an eval but allowing for Nothing as a possible assignment
20:39:25 <rvxi> heladodebrownie what does it mean to put something back into a monadic context?
20:39:51 <roboguy_> rvxi: what is eval?
20:39:55 <ProofTechnique> rvxi: How it works is dependent on how bind is implemented for a particular Monad instance.
20:39:58 <HeladoDeBrownie> rvxi, i'm not sure what you mean about eval. "put in a monadic context" is a kind of imprecise intuition for what return and some other things do.
20:40:07 <XorSwap> @pl s x y z = x z $ y z
20:40:07 <lambdabot> s = ap
20:40:16 <XorSwap> woah
20:40:39 <roboguy_> XorSwap: yep, the (->) r Applicative instance has the S combinator as <*>
20:40:41 <ProofTechnique> rvxi: Putting it back in a Monadic context, very imprecisely, means (for instance) turning 4 into Just 4
20:40:43 <roboguy_> (which is the same as ap)
20:40:43 <ProofTechnique> :t return
20:40:45 <lambdabot> Monad m => a -> m a
20:40:54 <ProofTechnique> :t return 4 :: Maybe Int
20:40:55 <lambdabot> Maybe Int
20:40:55 <HeladoDeBrownie> rvxi, another intuition you can use for return is it produces the "trivial" monadic value, one that always just produces the thing you gave it. return :: Char -> IO Char produces an IO action that always does nothing and results in the Char you gave it.
20:41:01 <ProofTechnique> > return 4 :: Maybe Int
20:41:01 <XorSwap> ap id id $ ap id id
20:41:02 <lambdabot>  Just 4
20:41:12 <XorSwap> oh
20:41:29 <XorSwap> > ap id id $ ap id id
20:41:31 <lambdabot>      Occurs check: cannot construct the infinite type: a0 ~ a0 -> b
20:41:31 <lambdabot>      Expected type: ((a0 -> b) -> b) -> a0 -> b
20:41:31 <lambdabot>        Actual type: (a0 -> b) -> a0 -> b
20:41:42 <HeladoDeBrownie> rvxi, do you want to try going more precise?
20:41:54 <ProofTechnique> HeladoDeBrownie: I like that intuition better.
20:41:57 <rvxi> thinking about this
20:42:11 * HeladoDeBrownie gets ready to break out kleisli arrows if requested :)
20:42:17 <XorSwap> > reverse [0..]
20:42:22 <lambdabot>  mueval: ExitFailure 1
20:42:28 <rvxi> at this point i'm grasping at things that are definitely wrong in hopes of understanding how they're wrong ...
20:42:35 <roboguy_> XorSwap: the only way something like that would type check is if it ignores its argument, which wouldn't lead to an infinite loop
20:42:56 <roboguy_> > let f _ = () in f f
20:42:57 <LQYMGT> > sum [1..10000000000000000]
20:42:58 <lambdabot>  ()
20:42:59 <lambdabot>  <no location info>: can't find file: L.hs
20:43:19 <rvxi> what i mean by eval in pseudocode ...
20:43:27 <rvxi> say i have a function f
20:43:27 <XorSwap> reverse $ reverse [0..]
20:43:29 <LQYMGT> > sum [1..100]
20:43:30 <lambdabot>  5050
20:43:34 <rvxi> f() would be evaluating f
20:43:43 <rvxi> i guess my intuition is along the lines of 
20:43:47 <rvxi> bertosz milewski
20:43:47 <roboguy_> rvxi: that is very different
20:43:53 <rvxi> when he says "lift"ing 
20:43:58 <XorSwap> > reverse $ reverse [0..]
20:44:02 <roboguy_> lifting usually has more to do with Functor
20:44:03 <lambdabot>  mueval: ExitFailure 1
20:44:26 <rvxi> or alternatively in maxima there's the symbol 'x
20:44:40 <rvxi> and i can evaluate it to get the value contained in x
20:44:51 <XorSwap> @type ap
20:44:52 <lambdabot> Monad m => m (a -> b) -> m a -> m b
20:44:58 <rvxi> which i guess would be analogous to deferencing a pointer
20:44:59 <roboguy_> rvxi: it's pretty different. The monadic bind operation is just a normal function. It happens to have different definitions depending on what type you use it on, but all the definitions are normal functions
20:45:08 <ProofTechnique> :t (>>=)
20:45:09 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:45:21 <HeladoDeBrownie> rvxi, it's not quite like that. here is a quote that may help illustrate.
20:45:28 <HeladoDeBrownie> @where /bin/ls
20:45:28 <lambdabot> I know nothing about /bin/ls.
20:45:30 <HeladoDeBrownie> erm
20:45:33 <HeladoDeBrownie> @quote /bin/ls
20:45:33 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
20:45:57 <roboguy_> That's a good quote
20:46:04 <HeladoDeBrownie> rvxi, the idea is it could also not actually *contain* a thing, but represent a way to *get* a thing (or various other possibilities)
20:47:30 <rvxi> how is getting a thing different than something analogous to a pointer deference? i'm sorry i know my intuition is way off still.
20:47:33 <roboguy_> Ultimately, monads get more mystique than they should, at least for the perspective of someone starting out. They consist of a couple regular functions
20:47:56 <HeladoDeBrownie> rvxi, because you may need to do a complex computation to attain the value, as opposed to looking it up somewhere, for example.
20:48:01 <ProofTechnique> rvxi: It might be helpful to look at some simple Monad instances.
20:48:13 <NateUni> I have a BST with ints as values. I am deleting two values and I want to make sure that other then these that the tree stays the same. I have a function that just builds a list of all ints in the tree… so I want to compare the before and after. I was thinking about beforeTree \\ afterTree == [int1, int2] but it factors in order which I don’t want. Any ideas? 
20:48:18 <ProofTechnique> Maybe is pretty grokkable: http://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Base.html#line-642
20:48:59 <rvxi> heladebrownie - so isn't bertosz's lifting analogy usable? he puts both a pointer deference and a function call in the same category of 'extraction'
20:49:29 <HeladoDeBrownie> rvxi, i'm not really sure i get the analogy you're using. for all i know it's an intuition that may serve you.
20:49:37 <rvxi> so if it's a calculation it would be analogous to making a function call to unlift
20:49:50 <rvxi> although in some case it may be a piece of data
20:49:52 <HeladoDeBrownie> but it's probably dangerous to try to assume all Monad instances are like that.
20:49:56 <rvxi> like a pointer dereference
20:50:11 <XorSwap> @type Maybe
20:50:12 <lambdabot>     Not in scope: data constructor ‘Maybe’
20:50:12 <lambdabot>     Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
20:50:20 <HeladoDeBrownie> i can even think of a Monad instance where the "thing" you give a name to never exists at all. instance Monad Proxy
20:50:22 <XorSwap> @type maybe
20:50:23 <lambdabot> b -> (a -> b) -> Maybe a -> b
20:50:39 <HeladoDeBrownie> Proxy is defined just like this: data Proxy a
20:51:00 <XorSwap> @type Just 3
20:51:01 <lambdabot> Num a => Maybe a
20:51:01 <HeladoDeBrownie> the methods like so: return _ = Proxy ; _ >>= _ = Proxy
20:51:03 <roboguy_> HeladoDeBrownie: that doesn't have a Monad instance
20:51:12 <HeladoDeBrownie> roboguy_, are you sure?
20:51:12 <roboguy_> a law abiding one
20:51:14 <ProofTechnique> servant uses Proxy really interestingly, and it feels like magic
20:51:30 <HeladoDeBrownie> roboguy_, what law does it violate?
20:51:47 <HeladoDeBrownie> oh woops
20:51:48 <roboguy_> return a >>= f = f a
20:51:49 <HeladoDeBrownie> i miswrote it
20:51:54 <HeladoDeBrownie> data Proxy a = Proxy
20:51:55 <HeladoDeBrownie> sorry
20:52:09 <roboguy_> That too
20:52:22 <HeladoDeBrownie> it doesn't violate that law you said
20:52:30 <HeladoDeBrownie> f will always return Proxy
20:52:43 <roboguy_> oh, maybe I'm wrong
20:52:46 <Hijiri> could return bottom
20:52:53 <roboguy_> I'm probably thinking of that other thing
20:52:54 <XorSwap> so what does => mean?
20:52:56 <HeladoDeBrownie> Hijiri, i think we usually ignore that when proving the laws
20:52:59 <roboguy_> Void1 maybe
20:53:02 <HeladoDeBrownie> XorSwap, the left side is a constraint
20:53:04 <ProofTechnique> XorSwap: That's a type class constraint
20:53:07 <Hijiri> sometimes it's important
20:53:13 <Hijiri> like coercing functors that contain things
20:53:23 <HeladoDeBrownie> XorSwap, e.g., (Integral a) => a means "any type, as long as it has an Integral instance"
20:53:31 <ProofTechnique> :t (+)
20:53:32 <lambdabot> Num a => a -> a -> a
20:53:44 <XorSwap> ok
20:53:52 <hiptobecubic> `foldr1 (++)` should be linear in the number of elements in the result right?
20:53:54 <HeladoDeBrownie> roboguy_, yeah, you're right, the original thing i wrote clearly has no instance. my mistake, typo
20:54:29 <rvxi> another dumb question - when do i need function declarations?
20:54:42 <NateUni> How could I do something like: [1,2,3,4,5,6] \\ [1,2,5,6] == [3,4] || [4,3] in haskell?
20:54:46 <roboguy_> HeladoDeBrownie: to be fair, I was thinking the real Proxy didn't have one too. But, I was thinking about another type
20:54:46 <rvxi> ghc at least seems to do fine without explicit declarations..
20:54:46 <HeladoDeBrownie> rvxi, when you want to give names to functions? i'm not sure i understand your question
20:55:13 <Hijiri> rvxi: type annotations?
20:55:36 <rvxi> hijiri: yes i guess they look like function declarations in C++ ... maybe they aren't
20:55:42 <rvxi> like i can get away with having just
20:55:42 <Hijiri> you should have type annotations on all top-level definitions for the sake of readability, even if ghc can infer them
20:56:07 <rvxi> defining my function without an explicit
20:56:07 <rvxi> getNumber :: MonadRandom m => Double -> Double -> m Double
20:56:11 <crodjer> Is it possible to have a custom haskell base installed in a cabal sandbox?
20:56:18 <HeladoDeBrownie> NateUni, this can be expressed succinctly using a list comprehension. \xs ys -> [x | x <- xs, not (x `elem` ys)]
20:56:31 <NateUni> ok thanks.. 
20:56:40 <Hijiri> rvxi: You don't need them to compile (in many cases), but you want to have them on top-level definitions, so it's easier to tell what they do
20:56:43 <HeladoDeBrownie> NateUni, should i explain what i did there?
20:56:47 <NateUni> please
20:56:55 <Hijiri> Things in where clauses, let expressions, it depends
20:56:57 <ProofTechnique> > [1,2,3,4,5,6] `intersect` [1,2,3,4,5,6]
20:56:58 <lambdabot>  [1,2,3,4,5,6]
20:56:59 <rvxi> what's a top-level definition?
20:57:07 <rvxi> as opposed to functions in functions?
20:57:08 <ProofTechnique> > [1,2,3,4,5,6] `intersect` [1,2,5,6]
20:57:09 <lambdabot>  [1,2,5,6]
20:57:13 <HeladoDeBrownie> NateUni, are you familiar with the set builder notation often used in math?
20:57:17 <XorSwap> > let x = 1:0:x in x
20:57:19 <lambdabot>  [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0...
20:57:21 <Hijiri> rvxi: Anything defined one level down from the module declaration
20:57:21 <ProofTechnique> Oh, duh, I'm thinking of difference
20:57:28 <ProofTechnique> > [1,2,3,4,5,6] \\ [1,2,5,6]
20:57:29 <lambdabot>  [3,4]
20:57:30 <NateUni> Yes,.. and in haskell I have looked at it as well. 
20:57:40 <Hijiri> rvxi: So things that are not indented, in most people's styles
20:57:42 <XorSwap> > let x = 1:0:x:x in x
20:57:44 <lambdabot>      Occurs check: cannot construct the infinite type: a1 ~ [a1]
20:57:44 <lambdabot>      Relevant bindings include x :: [a1] (bound at <interactive>:1:5)
20:57:44 <lambdabot>      In the first argument of ‘(:)’, namely ‘x’
20:58:05 <NateUni> I get it now.. 
20:58:08 <HeladoDeBrownie> NateUni, well it's basically like that; "x <- xs" can be read as "x are drawn from the list xs", and "not (x `elem` ys)" imposes a condition that must be true of any given x for it to be in the final list
20:58:56 <rvxi> hijiri: ok
20:59:23 <HeladoDeBrownie> NateUni, and i just wrote it as a lambda but you could easily write it in a definition like this: xs \\ ys -> [x | x <- xs, not (x `elem` ys)]
20:59:29 <XorSwap> > cycle
20:59:30 <lambdabot>      No instance for (Typeable a0)
20:59:30 <lambdabot>        arising from a use of ‘show_M301551028876737295821057’
20:59:30 <lambdabot>      In the expression:
20:59:36 <HeladoDeBrownie> `elem` is infix application, it's the same here as elem x ys
20:59:43 <XorSwap> @type cycle
20:59:44 <lambdabot> [a] -> [a]
20:59:53 <HeladoDeBrownie> NateUni, gah, sorry
20:59:57 <XorSwap> > cycle 0
20:59:59 <lambdabot>      No instance for (Show a0)
20:59:59 <lambdabot>        arising from a use of ‘show_M404240348128534036921072’
20:59:59 <lambdabot>      The type variable ‘a0’ is ambiguous
21:00:01 <HeladoDeBrownie> NateUni, xs \\ ys = [x | x <- xs, not (x `elem` ys)]
21:00:04 <XorSwap> > cycle [0]
21:00:06 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
21:00:46 <XorSwap> > cycle & cycle [0]
21:00:48 <lambdabot>      Couldn't match expected type ‘([a0] -> [a0]) -> b’
21:00:48 <lambdabot>                  with actual type ‘[Integer]’
21:00:48 <lambdabot>      Possible cause: ‘cycle’ is applied to too many arguments
21:00:49 <NateUni> Thanks Brownie Icecream.. :)
21:01:01 <HeladoDeBrownie> no problem :)
21:01:06 <XorSwap> > cycle $ cycle [0]
21:01:08 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
21:01:13 <XorSwap> > cycle $ cycle [0,1]
21:01:15 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
21:01:28 <HeladoDeBrownie> XorSwap, do you mind playing with that in a private message instead?
21:01:30 <XorSwap> > cycle [0..]
21:01:32 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
21:01:46 <XorSwap> oh, sorry
21:01:51 <arkeet> cycle of an infinite list is the same list.
21:01:52 <HeladoDeBrownie> it's okay if you want to show someone something in channel, but excessive use is best in pm
21:01:57 * hackagebot texmath 0.8.1 - Conversion between formats used to represent mathematics.  http://hackage.haskell.org/package/texmath-0.8.1 (JohnMacFarlane)
21:02:06 <roboguy_> XorSwap: one thing that's kinda cool that you don't (I think) get with lambdabot is that sometimes GHC can detect an infinite loop and terminate
21:02:10 <XorSwap> ah, ok
21:02:10 <roboguy_> (not every time, of course)
21:02:21 <roboguy_> when that happens, it says <<loop>>
21:03:40 <roboguy_> yeah, GHC detects the infinite loop in "let x = x in x", so lambdabot probably doesn't do it
21:03:54 <arkeet> ghci doesn't do it either, afaik
21:04:25 <roboguy_> arkeet: 7.8.4 GHCi does it
21:04:47 <arkeet> 7.8.3 on windows here, doesn't work
21:05:09 <ProofTechnique> mueval is a rather more strict about things, too.
21:05:38 <enojelly> In some cases non-termination is pretty trivial.
21:05:39 <roboguy_> arkeet: huh, maybe they added it in 7.8.4. I'm on OS X and it did it
21:05:40 <XorSwap> I'm starting to wish that some other programming channels had a lambdabot
21:05:46 <enojelly> fac
21:05:51 <roboguy_> XorSwap: most of the other Haskell ones do!
21:07:16 <roboguy_> I think I ran into lambdabot in a non-Haskell connected channel once, but I don't remember which
21:07:54 <Hijiri> it's in ##categorytheory apparently
21:08:07 <ProofTechnique> And the esolang channel
21:08:27 <HeladoDeBrownie> haskell is my favorite esolang
21:08:52 <ProofTechnique> I just wish #haskell had fungot
21:10:38 <roboguy_> ProofTechnique: what's that?
21:10:48 <ProofTechnique> https://github.com/fis/fungot/blob/master/fungot.b98
21:10:55 <ProofTechnique> IRC bot in Befunge
21:10:56 <NateUni> HeladoDeBrownie.. any idea why this wont compile? http://lpaste.net/130626
21:11:27 <roboguy_> ProofTechnique: haha, what does that do? My Befunge is a bit... rusty
21:11:54 <HeladoDeBrownie> NateUni, (xs ys) is incorrect
21:12:05 <HeladoDeBrownie> NateUni, you probably want not to have parens there at all
21:12:07 <ProofTechnique> NateUni: And (\\) is in Data.List, so you'll need to import that
21:12:13 <NateUni> oh ok.. 
21:12:20 <XorSwap> proof, that must have been an absolute nightmare to make
21:12:25 <NateUni> I tried without () but then go an error abotu the //
21:12:28 <ProofTechnique> roboguy_: It does a ton of things, but mostly it spouts gibberish
21:12:29 <NateUni> makes sense now. 
21:12:54 <ProofTechnique> XorSwap: I can only imagine.
21:13:22 <ProofTechnique> roboguy_: It has a bunch of builtin interpreters for esolangs, too
21:13:52 <roboguy_> ProofTechnique: nice
21:13:55 <HeladoDeBrownie> NateUni, by the way, there also exists notElem now that i recall. might save a tiny bit of space
21:14:51 <arkeet> > [1,1,1] \\ [1]
21:14:53 <lambdabot>  [1,1]
21:15:18 <arkeet> NateUni: xs \\ ys only removes the first occurrence of each element of ys in xs
21:15:23 <arkeet> > [1,1,1] \\ [1,1]
21:15:24 <lambdabot>  [1]
21:15:34 <NateUni> hmm.. 
21:16:03 <NateUni> ok give me a sec to go look at my code
21:16:04 <ProofTechnique> NateUni: What do you mean for checkIntersection to do?
21:16:12 <arkeet> just a FYI.
21:16:14 <pacak> Data.Set, yay. \\ is not exactly efficient.
21:16:38 <ProofTechnique> I mean, I know what it says it should do, I just don't know what list difference brings to it
21:17:00 <NateUni> I have a BST with ints as values. I am deleting two values and I want to make sure that other then these that the tree stays the same. I have a function that just builds a list of all ints in the tree… so I want to compare the before and after. I was thinking about beforeTree \\ afterTree == [int1, int2] but it factors in order which I don’t want.
21:17:27 <arkeet> beforetree \\ [int1,int2] == aftertree?
21:17:29 <HeladoDeBrownie> sounds like you do want a Set rather than a list
21:17:34 <arkeet> also yes, set is good.
21:17:39 <HeladoDeBrownie> Data.Set is in the containers package
21:17:57 <arkeet> treating lists as sets is bad.
21:18:12 <NateUni> I was looking at that. Should I just convert both lists to a set and then get the intersection?
21:18:16 <HeladoDeBrownie> yeah
21:18:27 <NateUni> ok.. off to go look more at Hoogle.. 
21:18:51 <pacak> Maybe you want to keep stuff in sets all the time?
21:19:22 <enojelly> Cale, you're not Andres, are you?
21:19:34 <enojelly> just asking because of the paper you linked
21:19:36 <Gurkenglas> http://lpaste.net/130628 <- Should I "fold" the stream into an infinite list to allow zips as I am doing now, or transform the decoration as state onto the Either Int monad, or implement zipping on Cofree f a? General suggestions also welcome.
21:20:00 <NateUni> Problem is that I need to keep the majority of the code the same.. and just add methods that do predicate type checks for Quickcheck.. 
21:20:18 <NateUni> otherwise the auto marker can’t do it magic
21:20:25 <NateUni> *its
21:21:04 <ProofTechnique> fromList and toList may be your friends
21:22:01 <NateUni> Issue.. with sets though is that my tree has >= for the right branchs.. 
21:22:03 <Gurkenglas> Foldable has toList? But how does it handle left-infinite structures?
21:22:22 <NateUni> the set would cause equal elements to be discarded.. 
21:22:31 <NateUni> (well duplicate elements)
21:22:42 <ProofTechnique> Gurkenglas: Sorry, I was talking to NateUni 
21:22:52 <Gurkenglas> Oh, heh.
21:22:59 <arkeet> there's probably some handy multiset package somewhere.
21:23:11 <arkeet> otherwise you can make a simple multiset wrapper around Data.Map
21:23:22 <HeladoDeBrownie> @hackage multiset
21:23:23 <lambdabot> http://hackage.haskell.org/package/multiset
21:23:31 <ProofTechnique> :t zipWith
21:23:33 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
21:23:46 <ProofTechnique> Aww, I was hoping zip got generalized in FTP. Oh, well :D
21:23:54 <arkeet> what to?
21:23:59 <Gurkenglas> (Although I guess I should use toList instead of F.foldr (:) []...)
21:24:01 <HeladoDeBrownie> it would still result in a list
21:24:26 <arkeet> not sure how one would generalize it.
21:24:39 <ProofTechnique> Nor i. Just a thought I had.
21:24:42 <ProofTechnique> *I
21:24:53 <arkeet> at least while staying in base.
21:25:02 <arkeet> ProofTechnique: you might be interested in the 'these' package
21:25:03 <NateUni> Is teh multiset part of Haskell or a third part library?
21:25:05 <Gurkenglas> Sounds like Foldable shouldn't be enough, but Traversable should be, if I got that right
21:25:11 <ProofTechnique> @hackage these
21:25:11 <lambdabot> http://hackage.haskell.org/package/these
21:25:13 <HeladoDeBrownie> NateUni, it's not part of base. it's a separate package.
21:25:20 <arkeet> but neither is Data.Set
21:25:21 <ProofTechnique> arkeet: I've actually looked at it before, come to think of it.
21:25:24 <NateUni> ohok .. 
21:25:27 <NateUni> thanks.
21:25:40 <ProofTechnique> I do like it quite a bit, though :D
21:26:34 <NateUni> Wait.. BST order is important! So mutiset wont do either. 
21:26:47 <NateUni> Hmm ok need to go think about this a bit more obviousy. 
21:26:56 <arkeet> well maybe you need to think a bit more on what exactly you want.
21:26:57 <arkeet> yeah
21:27:09 <Gurkenglas> Maybe it's just a Map to unsigned Int?
21:27:21 <arkeet> that's a multiset.
21:27:36 <Gurkenglas> Yes, I was guessing at its implementation ^^
21:27:49 <NateUni> I thought multiset allows for duplicated but with order NOT being important.. ?
21:27:55 <Gurkenglas> I thought that's what Nate was wondering about.
21:27:57 <arkeet> Gurkenglas: you'd be right.
21:28:05 <arkeet> NateUni: if order is important
21:28:06 <arkeet> then you have a list.
21:28:33 <NateUni> yeah hence back to where I started. 
21:28:38 <NateUni> ok off to ponder.
21:30:06 <ProofTechnique> :t _This here
21:30:07 <lambdabot> Not in scope: ‘here’
21:32:07 <ProofTechnique> I love that mapThis = over here
21:34:30 <roboguy_> I have to write a continuation passing interpreter for class and I'm *really* tempted to ask my professor if I can do it in Haskell instead of Racket
21:35:46 <c_wraith> continuation passing is kind of easier when you can write down types and have the compiler check them.  There is typed racket!
21:35:59 <roboguy_> exactly. Oh man, I totally forgot about typed racket!
21:36:15 <roboguy_> that might help, thanks!
21:37:51 <roboguy_> I wonder if that interacts okay with the parsing library
21:51:52 <Zemyla> gfixler: You use the stuff I gave you?
21:55:47 <diggle> Should I install haskell platform or ghc? i'm just getting started.
21:57:35 <XorSwap> ghc has worked well for me
21:58:22 <echo-area> diggle: I see at many places haskell platform is recommended, but I installed GHC on Gentoo
21:58:54 <echo-area> diggle: I think it depends on if it is easy to install GHC
21:58:57 <diggle> hm, if I need the most latest version of ghc I have to install it myself, but if I can just use ghc 7.8.3 the platform would be better.
21:59:14 <diggle> hm, i'm on windows, so it's easy for me.
21:59:28 <MP2E> I recommend latest GHC via https://github.com/fpco/minghc
21:59:38 <MP2E> if there are any platform libraries you are missing, you can just install them with cabal
22:02:08 <diggle> Are there any problems with the 64-bit installer? I mean is there anything with haskell that makes the compiled code with 64 bit not run on 32 bit?
22:02:34 <MP2E> Yeah, any 64-bit compiled code isn't going to run on 32-bit platforms, that's not a haskell specific thing
22:03:09 <diggle> yeah, i'll just get the 32 bit installer.
22:03:14 <MP2E> to be fair though, x64 has been around since what.. 2004-05 now? I think it's safe to assume most PCs are x64 capable
22:03:22 <MP2E> I don't really think twice about it, anyway
22:03:45 <diggle> yeah, but I can run 32 bit code on both, so.
22:27:01 * hackagebot sbv 4.4 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-4.4 (LeventErkok)
22:31:23 <siwica> How can I restrict a function to only take ranges of Int as parameter?
22:32:08 <siwica> e.g. [1..100] and [1,2,3] are permitted, [1,3,4] is notdan 
22:32:14 <siwica> *not
22:33:09 <sgronblo> you could probably make some data type that describes the range
22:34:00 <kadoban> siwica: Take just the start and end instead, optionally wrapped up as a type Range or something.
22:34:31 <sgronblo> and then at run time convert your [1..100] to the Range or whatever type
22:36:13 <siwica> ok, but there is no standard type?
22:36:53 <kadoban> Well, there's kind of Enum I guess, which is basically what you're using when you do 1..100
22:37:33 <ReinH> siwica: you can't capture requirements like these about values in Haskell's type system
22:37:40 <ReinH> You would need dependent types for that
22:37:41 <tar_> If I have an "IO (Maybe a)" and an "a -> IO (Maybe (a, a))" can I connect them succinctly?
22:37:56 <ReinH> tar_: use MaybeT?
22:38:15 <tar_> ReinH: Thanks, I will look
22:39:06 <siwica> ok, thank you!
22:39:26 <kadoban> Could just do some construction with fmap, >>= and join I guess if not? Shouldn't be too complicated, but probably not exactly pretty.
22:41:34 <tar_> kadoban: I think so, but I haven't been able to get the types to line up yet
22:42:01 <kadoban> Let me see if I can manage it, for practice if nothing else
22:44:40 <ReinH> I mean, this is exactly what MaybeT is for, but why not
22:44:54 <kadoban> Yeah, that's probably a better idea I'd think, heh.
22:46:38 <kadoban> Hmm, yeah my original idea doesn't seem like it'll even work, hmm.
22:51:36 <tar_> Should I be able to easily use IO (Maybe a) functions from MaybeT IO a, or would you usually convert everything to MaybeT IO a?
22:51:50 <jle`> tar_: if you decide to do MaybeT, then you can do `MaybeT . f =<< MaybeT x` to get your MaybeT IO (a, a), which you can runMaybeT it out into an IO (Maybe (a, a))
22:51:58 <jle`> tar_: MaybeT :: IO (Maybe a) -> MaybeT IO a
22:52:08 <jle`> you can think of MaybeT as just a newtype wrapper, like Sum or Any
22:52:59 <jle`> in your do block you can `do x <- MaybeT thefirstthing; foo <- MaybeT (f x)`
22:53:58 <jle`> and at the end you'd 'unwrap the newtype wrapper' with runMaybeT
22:54:47 <jle`> this pays off if you do a few or several of these chaninings on IO (Maybe a)'s
22:55:02 <jle`> if you're only doing one though, i feel like the return is a bit not worth the extra investment
22:57:00 <tar_> jle`: I have 3-4 functions like this, and I think it's cleaning up nicely. Thanks for the pointers.
22:57:26 <jle`> np :) 3-4 functions is definitely at the range where this becomes super useful.
23:02:46 <siwica> what is a good way to calculate the exact integer value of 2^1000 in haskell?
23:03:52 <Rotaerk> siwica, 2 ^ 1000 ?
23:04:16 <MP2E> > (2^1000 :: Integer)
23:04:18 <lambdabot>  1071508607186267320948425049060001810561404811705533607443750388370351051124...
23:04:23 <siwica> ah, I only knew of 2**1000
23:04:55 <siwica> This seems to be for Floating Integers?
23:05:13 <nshepperd> :t (^)
23:05:14 <lambdabot> (Integral b, Num a) => a -> b -> a
23:05:14 <Ralith> :t (^)
23:05:15 <lambdabot> (Integral b, Num a) => a -> b -> a
23:05:22 <nshepperd> hah
23:05:32 <siwica> :t (**)
23:05:33 <lambdabot> Floating a => a -> a -> a
23:05:48 <siwica> ok...
23:06:34 <f|`-`|f> > 32**2.45789478
23:06:36 <lambdabot>  5006.108693245721
23:06:44 <f|`-`|f> > 32^2
23:06:46 <lambdabot>  1024
23:10:29 <tar_> Thanks, MaybeT is just what I wanted.
23:25:12 <jle`> siwica: (^) is basically actually iterated multiplication.  haskell multiplies the thing over and oever again 1000 times.  (**) is for Floating's, and is actually an inherent function that the type provides
23:25:20 <jle`> siwica: for Floats and Doubles, for example, it uses machine exponentiation.
23:25:50 <jle`> > x^4
23:25:51 <lambdabot>  x * x * (x * x)
23:26:25 <jle`> with (**) the type itself gets to decide how it wants to handle exponentiation.  with (^), haskell just multiplies the thing over and over again.
23:28:22 <jle`> oh yea and it also only works on Floating's.
23:31:35 <NateUni> Guys.. Can someone help me with this: data Particle = Particle Mass Position Velocity 
23:32:07 <NateUni> I dont understand what there is also Particle on the RHS of the =
23:32:15 <jle`> NateUni: it's the type constructor
23:32:24 <jle`> oh, the RHS
23:32:28 <jle`> it's your data constructor/value constructor
23:32:59 <jle`> it's a little confusing because you gave the type and the data constructor the same name; it could have been data Particle = P Mass Position Velocity
23:33:01 <NateUni> ?
23:33:16 <jle`> then to use it in a function, you could do foo (P m p x) = ....
23:33:34 <NateUni> oh ok.. 
23:33:37 <jle`> or you can use it to "consruct" a Particle; P :: Mass -> Position -> Velocity -> Particle
23:33:39 <NateUni> makes sense now.. 
23:33:46 <jle`> " give me a mass, a pos, and a vel, and i'll give you a particle
23:33:53 <jle`> P 1 2 3 :: Particle
23:34:01 <NateUni> ok thanks jle`
23:34:06 <jle`> np!
23:34:13 <NateUni> :)
23:37:05 * hackagebot bitcoin-script 0.9.0 - Compilation, manipulation and decompilation of Bitcoin scripts  http://hackage.haskell.org/package/bitcoin-script-0.9.0 (solatis)
23:44:15 <nshepperd> huh, cool, (^) using successive squaring
23:44:20 <nshepperd> uses
23:45:05 <fragamus> how can i see the source for (^)
23:45:15 <kadoban> Hah yeah I was wondering if it did, seemed weird it'd just do plain iterated multiplication.
23:45:26 <nshepperd> hackage: http://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Real.html#^
23:46:08 <nshepperd> so 32^1000 actually does something like 10 multiplications
23:47:05 * hackagebot bitcoin-script 0.9.1 - Compilation, manipulation and decompilation of Bitcoin scripts  http://hackage.haskell.org/package/bitcoin-script-0.9.1 (solatis)
23:47:21 <NateUni> This is messy.. I know there is a way to make this tider in haskell I this with “as” can I ask someoen about it? moveParticle t (Particle m Point(a b) Point(x y))
23:48:31 <NateUni> where a Particle = Particle mass position velocity. And position and velocity are just points..  
23:49:20 <frerich_> NateUni: 'as' is useful if you want to reuse values which you just deconstructed while pattern matching. Can you post some actual code?
23:50:14 <NateUni> ok.. 
23:50:14 <NateUni> http://lpaste.net/6673635259583561728
23:51:26 <NateUni> So the idea is to get time and a particle.. and then see how much time has lapsed and then use this with the velocity to then return the new particle in the new position
23:51:43 <frerich> NateUni: The only place where 'as' would help is the '(Point x y)' part. you could use 'p@(Point x y)' on the left side of the '=' and then use that on the right side (instead of 'Point x y').
23:51:56 <__ryan> how to i include the id in my rawSQL and turn it to json? - here is my question in stackoverflow http://stackoverflow.com/questions/29552552/return-json-based-on-persistent-query-from-yesod-handler
23:52:04 <NateUni> what about using wherE?
23:52:31 <NateUni> ahh thats right.. i forgot about the old @
23:54:03 <frerich> NateUni: The transformation applied to each of the coordinates could be factored out to something like 'f p q = p + (1/t) * q' such that you could use 'Point (f a x) (f b y)'
23:54:15 <frerich> NateUni: Except that 'f' is a pretty lame name for it. :-)
