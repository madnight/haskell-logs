00:21:52 <kaidelong> I don't have access to John Mybill's paper, but would the correct embedding of double negation elimination in Haskell be something in the form of (((t -> Void) -> Void) -> Void,(t -> Void)) -> Void) -> Void)) -> Void?
00:22:50 <kaidelong> writing it out like that is too hard, umm
00:23:16 <kaidelong> ~(~~~t,~t)
00:23:20 <kaidelong> is the basic idea
00:24:16 <kaidelong> I've been trying to prove classical logic statements with haskell using the embedding but I haven't quite figured double negation elimination out
00:33:11 <kaidelong> oh never mind
00:33:14 <kaidelong> it was actually really simple
00:33:30 <kaidelong> the proof of classical double negation is just f (x,y) = x y
00:33:54 <kaidelong> don't know why this stumped me
00:34:19 <kaidelong> double negation elimination*
00:35:25 <kaidelong> f :: Not (Not t) ~-> t ; type t ~-> u = Not (t, Not u)
01:17:11 <randir> is there any speed boost in hardcoding in the literal 0.125 as opposed to (1/8)?
01:17:27 <randir> Or would the compiler do that before runtime anyhow?
01:23:37 <jle`> randir: i know one way to find out :)
01:23:47 * hackagebot rtlsdr 0.1.0.4 - Bindings to librtlsdr  http://hackage.haskell.org/package/rtlsdr-0.1.0.4 (adamwalker)
01:25:09 <randir> I'll run a speed test, although I'm also interested in the theory behind it, with what GHC does. It seems like it *should* resolve it as a constant during compilation.
01:26:11 <jle`> i wonder if checking the core would yield any insight
01:26:34 <jle`> 0.125 and 1/8 are both run through `fromRational` anyway
01:26:40 <jle`> no matter which form you use
01:26:58 <randir> during runtime, I'm taking?
01:27:46 <jle`> hm.  sematantically.  i haven't looked too deeply into it, but even during runtime it'll only have to be done once
01:27:57 <jle`> if you keep your value monomorphic
01:30:03 <ZyXoas> Yo.
01:33:03 <ZyXoas> I need to do some JSON magic, Reading data from a Web application which returns timestamps in posix epoch format.
01:33:16 <ZyXoas> Dealing with time doesn't seem straightforward in Haskell.
01:33:55 <randir> I did a test with "putStrLn $ sum $ take 500000000 $ repeat 0.125"
01:34:02 <randir> and another one with (1/16)
01:34:29 <randir> ah, 1/8*
01:34:47 <jle`> hi ZyXoas :)
01:35:18 <ZyXoas> jle` hello.
01:35:47 <randir> there didn't seem to be any determinable efficiency difference, but I think haskell is actually intelligently getting the sum without going through the whole list
01:36:06 <randir> turning it into a question of multiplication
01:36:23 <jle`> hm. even if so, the conversion is only done once
01:36:26 <randir> because it's doing it in about 0.6 seconds each time
01:36:36 <jle`> the conversion from the literal to the float/whatever type you are using
01:36:37 <randir> ah, of course
01:36:51 <randir> regardless, ghc is pretty impressive
01:37:20 <jle`> it is :)
01:37:30 <jle`> i'm trying to think of cases where parsing numerical literals would be a bottleneck
01:37:33 <randir> Do you think it's factoring out the sum into multiplication? 
01:38:15 <randir> I feel as if going through a 500mil element list should take more than .6 seconds.. but I mean, clock cycles now *are* pretty damn impressive
01:38:29 <jle`> i wouldn't expect it too :) but ther emight be some fusion going on
01:38:35 <bennofs> randir: no, it's no doing the factoring it into a sum I think
01:38:36 <randir> well, I'm doing an evaluation function for a chess engine, and want it to be efficent. I don't think it's a bottleneck, either way.
01:39:15 <randir> This is one of the larger haskell programs I've written, the chess engine and gui is working pretty well now!
01:39:22 <bennofs> randir: it's probably compiling it into a loop with no allocation though (keeping the current sum in a register)
01:39:36 <bennofs> the list is fully eliminated i'd guess
01:39:38 <randir> ah, that makes sense
01:40:35 <randir> Later on one the engine is more fully developed I'll post it on github to see if you guys have any performance tips
01:43:09 <jle`> sure :) sorry i couldn't answer the actual question directly.  it's something that i have thought aobut in the past.  but i can't imagine any situation where it would be a bottleneck, so i guess that might count for something in terms of how much it'll matter
01:43:11 <bracket_> i am by far the worst haskell programmer that has ever lived. goodnight!
01:43:44 <Rotaerk> can't be worse than my mom
01:44:42 <jle`> bracket_: i think you give yourself too much credit in how bad you are
01:47:00 <jle`> only one person can be the worst
01:47:10 <jle`> i highly doubt it's you :)
01:50:52 <bennofs> Is there a difference between x <- evaluate y and !x <- evaluate y
01:50:54 <bennofs> ?
01:51:06 <bennofs> Because I'm seeing a difference in weak pointer behavior with GHC 
01:53:48 <Myrl-chan> Guys, I want to benchmark something, how do I force evaluate a list?
01:55:19 <arkeet> Myrl-chan: deepseq will force the entire contents of the list.
01:55:32 <arkeet> but if you want to benchmark something, use criterion.
01:55:32 <jle`> i think you can do it by hand with foldr and seq, or you can use deepseq where someone wrote it for you already
01:55:46 <arkeet> yeah you could also go through and seq everything in the list.
01:55:50 <Myrl-chan> arkeet: I guess I'll do criterion.
01:56:02 <Myrl-chan> I don't even think I can benchmark this properly.
01:56:20 <Myrl-chan> I'll just tell the details.
01:56:33 <Myrl-chan> So, I made a skew binary list.
01:56:54 <Myrl-chan> And I made it so that a skew binary list converts from a list.
01:57:13 <Myrl-chan> Basically, `sfromlist :: [a] -> SList a`
01:59:38 <nshepperd> and you want to benchmark the conversion?
02:08:49 * hackagebot vcswrapper 0.1.2 - Wrapper for source code management systems  http://hackage.haskell.org/package/vcswrapper-0.1.2 (HamishMackenzie)
02:10:12 <Myrl-chan> ...lol
02:10:17 <Myrl-chan> I crashed my computer, twice.
02:10:41 <Myrl-chan> My skew binary list doesn't play well with infinite lists.
02:18:49 * hackagebot vcsgui 0.1.2.0 - GUI library for source code management systems  http://hackage.haskell.org/package/vcsgui-0.1.2.0 (HamishMackenzie)
02:33:50 * hackagebot dynamic-graph 0.1.0.7 - Draw and update graphs in real time with OpenGL  http://hackage.haskell.org/package/dynamic-graph-0.1.0.7 (adamwalker)
02:44:32 <dmj`> Does hspec have a way to generate html reports?
02:53:51 * hackagebot json-stream 0.3.0.4 - Incremental applicative JSON parser  http://hackage.haskell.org/package/json-stream-0.3.0.4 (ondrap)
02:58:04 <nshepperd> Myrl-chan: heh, did you run out of memory? if you're on linux, have a dreambubble: https://github.com/rfjakob/earlyoom
02:58:51 * hackagebot ltk 0.15.0.0 - Leksah tool kit  http://hackage.haskell.org/package/ltk-0.15.0.0 (HamishMackenzie)
03:04:52 <Myrl-chan> nshepperd: Ah, cool.
03:11:11 <nshepperd> much nicer to see my ill-considered folds exit with 'Killed.' than to trundle on for ten minutes before exiting with 'Killed.' :>
03:12:43 <mauke> couldn't this be solved with ulimit?
03:13:51 * hackagebot ApproxFun-hs 0.1.0.0 - Function approximation  http://hackage.haskell.org/package/ApproxFun-hs-0.1.0.0 (DominicSteinitz)
03:13:53 * hackagebot cudd 0.1.0.2 - Bindings to the CUDD binary decision diagrams library  http://hackage.haskell.org/package/cudd-0.1.0.2 (adamwalker)
03:17:04 <randir> What's an elegant way to randomly choose an object from a list?
03:17:08 <randir> using System.Random
03:17:33 <randir> I mean, I obviously could get a value bounded by the length of the list, and access it with !!
03:17:59 <randir> but is there a preexisting lib. function for chooseRandomlyFrom xs
03:18:04 <randir> >
03:18:05 <randir> ?* 
03:18:06 <lambdabot> Maybe you meant: v @ ? .
03:19:26 <randir> well, no matter, easy enough to write a function to do that, was just curious
03:33:52 * hackagebot base58string 0.9.0 - Fast and safe representation of a Base-58 string  http://hackage.haskell.org/package/base58string-0.9.0 (solatis)
03:34:07 <Myrl-chan> weeeeelp
03:34:49 <elfeck> can someone help me with this? http://lpaste.net/131497
03:36:54 <Gurkenglas> randir, assuming you want to repeatedly draw remaining elements from the list, I find excessive use of (!!) a code smell and in your situation would have the idea of first producing a random permutation of the list, then just taking heads.
03:41:10 <lyxia> elfeck: What are you trying to do?
03:42:35 <randir> Gurkenglas: For what I'm doing, I'm actually not wanting to draw remaining elements, but each time drawing from the pool of possible options 
03:42:47 <lyxia> elfeck: Perhaps you are looking for mapM
03:42:48 <randir> so if I was doing it for something that needed to be performant, I'd use arrays
03:43:16 <randir> but as it is, I think it works well enough, just doing it for an easter egg in a program. Thanks for responding though!
03:43:20 <Gurkenglas> Nevermind then.
03:44:17 <elfeck> lyxia I want to have the Monad-Actions in a list an then have them as in a sequential "do" notation
03:47:58 <Gurkenglas> Oh, there's one. randir, https://hackage.haskell.org/package/random-extras-0.17/docs/Data-Random-Extras.html
03:48:39 <lyxia> elfeck: Look for sequence and mapM in Control.Monad.
03:49:45 <Gurkenglas> (Which, by the way, also just uses (!!) with a random number and length :P)
03:51:35 <Gurkenglas> ((in the case of a single element at least))
04:16:16 <lpaste> bennofs pasted “Finalizer runs too early?” at http://lpaste.net/131498
04:16:32 <elfeck> can someone explain this: data Path as :: [*] -> *
04:16:39 <bennofs> Can somebody explain the output of that paste?
04:17:00 <bennofs> I do not understand why the finalizer runs before the Touch
04:18:02 <bennofs> (only happens in GHCi)
04:18:05 <opqdonut> elfeck: I haven't seen that before, looks like a combination of explicit kinds and DataKinds
04:19:41 <opqdonut> elfeck: anyway [*] is the kind of a type-level list
04:19:49 <Black0range> Hey guys are there any way to easily determine the size in bytes of a Text string ?
04:19:50 <opqdonut> elfeck: where is this from?
04:20:00 <elfeck> http://hackage.haskell.org/package/Spock-0.7.9.0/docs/Web-Spock-Safe.html#t:Path
04:20:02 <opqdonut> Black0range: it depends on the encoding, of course
04:20:57 <Black0range> of course. But i mean just the byte size, for when you want to send and receive the data over a network 
04:21:27 <Myrl-chan> Black0range: "Byte size" makes me hungry.
04:21:47 <Black0range> hah
04:21:50 <opqdonut> Black0range: convert to bytestring, get length of bytestring?
04:23:55 * hackagebot tellbot 0.5.1.2 - IRC tellbot  http://hackage.haskell.org/package/tellbot-0.5.1.2 (DimitriSabadie)
04:25:05 <Black0range> hmm yeah that must be the best alternative :/
04:25:33 <opqdonut> don't worry, fusion makes it surprisingly efficient
04:25:45 <opqdonut> c.f. the fusion example on http://hackage.haskell.org/package/text-0.11.2.0/docs/Data-Text.html
04:26:18 <opqdonut> and utf8 is so complex that it's hard to count the byte length without effectively encoding
04:38:55 * hackagebot list-t-libcurl 0.2.0.2 - A "libcurl"-based streaming HTTP client  http://hackage.haskell.org/package/list-t-libcurl-0.2.0.2 (NikitaVolkov)
05:06:06 <brbblnch> Hi
05:06:07 <kaidelong> I am right in that compiling haskell for profiling can cause functions to get worse asymptotic bounds, right?
05:07:22 <brbblnch> Is it wrong saying that in system F, the type ∀α.α , i.e. false, ⊥ is empty (not inhabited) ?
05:08:07 <kaidelong> looks right to me
05:12:12 <MagneticDuck> .. are there seriously no functions for 'if' in the base haskell libraries?
05:12:19 <MagneticDuck> it seems like that could often be pretty useful
05:12:37 <ion> @type bool
05:12:38 <lambdabot> a -> a -> Bool -> a
05:12:46 <MagneticDuck> ah cool
05:12:57 <MagneticDuck> my use case needs Bool -> a -> a -> a
05:13:12 <MagneticDuck> is that not also a think?
05:13:16 <ion> @type (bool, maybe, either)
05:13:17 <lambdabot> (a -> a -> Bool -> a, b -> (a1 -> b) -> Maybe a1 -> b, (a2 -> c) -> (b1 -> c) -> Either a2 b1 -> c)
05:13:43 <ion> You can just define your own.
05:13:46 <MagneticDuck> well yeah
05:15:10 <MagneticDuck> ion: where is that function from?
05:15:12 <MagneticDuck> can't find it on hackage >_>
05:15:16 <MagneticDuck> hoogle*
05:15:33 <opqdonut> @info bool
05:15:33 <lambdabot> bool
05:15:36 <opqdonut> oh.
05:15:47 <ion> https://www.fpcomplete.com/hoogle?q=bool&env=ghc-7.8-stable-14.09
05:18:12 <brbblnch> What's the diff between bool and if…then…else ? 
05:18:24 <srhb> brbblnch: if then else is syntax
05:18:50 <srhb> brbblnch: So you can't, say, partially apply it, which you can by making it a function.
05:19:15 <brbblnch> srhb: oh, yeah. 
05:20:01 <srhb> I find the existence of if-then-else to be the weirder thing, really. :PO
05:20:40 <brbblnch> srhb: But you can easily get a corresponding if function, right?
05:20:58 <srhb> brbblnch: Sure. if' True a _ = a; if' False _ b = b
05:20:58 <brbblnch> Is 'bool' the same as the 'if'' given here https://wiki.haskell.org/If-then-else ?
05:21:14 <srhb> Basically, but with arguments switched around
05:21:25 <brbblnch> ok
05:21:27 <brbblnch> thanks
05:23:57 * hackagebot hsbencher 1.20.0.5 - Launch and gather data from Haskell and non-Haskell benchmarks.  http://hackage.haskell.org/package/hsbencher-1.20.0.5 (RyanNewton)
05:23:59 * hackagebot hsbencher-fusion 0.3.15.1 - Backend for uploading benchmark data to Google Fusion Tables.  http://hackage.haskell.org/package/hsbencher-fusion-0.3.15.1 (RyanNewton)
05:24:01 * hackagebot hsbencher-codespeed 0.1.0.1 - Backend for uploading benchmark data to CodeSpeed  http://hackage.haskell.org/package/hsbencher-codespeed-0.1.0.1 (RyanNewton)
05:24:25 <slomo> is there a "standard" package that people use for vectors/arrays that have their size in the type?
05:25:43 <srhb> slomo: I'm not sure, but I think a candidate will arise when the type Nat constraint solver is builtin. :)
05:26:00 <brbblnch> About proving that ⊥ is empty, how do you do it?
05:26:40 <pavonia> Empty in what way?
05:27:31 <dmj`> what is the best way to use Hspec as a monad transformer?
05:27:57 <brbblnch> pavonia: It shouldn't have a proof, right?
05:28:36 <slomo> srhb: possible, but that's all not even needed in my case probably... i just want to be sure that two vectors passed to one of my functions have the same size :)
05:28:57 * hackagebot hsbencher-fusion 0.3.15.2 - Backend for uploading benchmark data to Google Fusion Tables.  http://hackage.haskell.org/package/hsbencher-fusion-0.3.15.2 (RyanNewton)
05:29:10 <pavonia> brbblnch: Not sure, do values or types have a proof?
05:29:31 <srhb> slomo: The implementation is like 4 lines, so I think people tend to just include it for now.
05:29:47 <pavonia> IIRC, every type can have a proof in form of a value
05:30:00 <brbblnch> pavonia: Well, through Curry-Howard, they should. No?
05:30:22 <pavonia> Yes. But then bottom isn#t a type
05:31:01 <brbblnch> pavonia: afaik, it is in System F. Defined as ∀α.α
05:31:17 <slomo> srhb: yeah, that was the other option :) just seems boring to have more or less the same code in lots of different projects
05:31:50 <srhb> slomo: Definitely. As said, i think a canonical library will emergy when the solver is better. :)
05:32:02 <jophish> @seen ndmitchell
05:32:02 <lambdabot> ndmitCH3LL
05:32:12 <jophish> :/
05:32:16 <pavonia> brbblnch: I don't know System F, sorry
05:32:52 <brbblnch> pavonia: thanks anyway
05:35:36 <ion> Re: bool, maybe, either etc, GHC could theoretically generate such functions automatically based on data type definitions.
05:37:38 <pavonia> Is there a name for these kind of functions?
05:38:16 <srhb> choice combinators?
05:38:19 <srhb> Or something like that
05:38:28 <bergmark> i think i've heard them called "deconstructors"
05:42:35 <hotcore> Noob here. How can I search ** in Hoogle?
05:43:26 <srhb> hotcore: What is **?
05:44:16 <hotcore> srhb: an operator; also * gioves an error in Hoogle
05:44:17 <pavonia> hotcore: Use Hayoo instead, I think it gives better results for function names
05:44:21 <raek> hotcore: try adding parentheses: https://www.haskell.org/hoogle/?hoogle=%28**%29
05:45:06 <brbblnch> pavonia: I thought that was a joke
05:45:08 <hotcore> raek: indeed that works but is not so obvious ;-)
05:45:27 <byorgey> hotcore: (**) is exponentiation where the power can be any floating-point type
05:45:39 <byorgey> > pi ** pi
05:45:40 <raek> no, it is not.
05:45:40 <lambdabot>  36.4621596072079
05:46:31 <hotcore> pavonia: and Hayoo works right away (but does show parenthesis in search result)
05:47:05 <pavonia> I guess that's because ** isn't a function, but (**) is
05:47:10 <pavonia> :t **
05:47:11 <lambdabot> Floating a => a -> a -> a
05:47:16 <pavonia> :/
05:47:41 <ion> :t ** 1
05:47:42 <lambdabot> Floating a => a -> a
05:47:44 <ion> huh
05:47:45 <hotcore> byorgey: knew that, but tried to search different things and stumbled on error message
05:48:02 <byorgey> fair enough
05:48:43 <byorgey> haha, what, I didn't know :t did that
05:48:47 <ion> :t ** 1 2
05:48:48 <lambdabot> (Floating a, Num a1, Num (a1 -> a)) => a -> a
05:48:54 <ion> uh
05:49:27 <byorgey> heh
05:49:33 <pavonia> Is that the extension for postfix operators?
05:50:08 <byorgey> it's like it's parsing as (**) (1 2)
05:50:27 <byorgey> which would yield that type
05:50:28 <ion> It probably just shoves parens around it and looks at (** 1 2)
05:50:47 <byorgey> ah, right, which is an operator section (** (1 2))
05:53:23 <bennofs> Is there a way to prevent an expression from being floated out in GHC?
05:58:44 <exio4> is there any "tip" that you could link for a small haskell talk? (I won't have more than 20~25 minutes)
05:58:59 <exio4> basically, how to show purity and lazyness and other concepts in a simple manner and without saying too much :P
05:59:15 <learns> haskell is so hard :( what easy projects are there for haskell?
06:00:06 <kaidelong> hunt the wumpus is a fun one
06:00:19 <learns> wat
06:00:20 <izgzhen> Hi! I am reading HaLVM's code, and find such a sentence: `outBuffer p = (#ptr struct xencons_interface, out) p`, I can't find information about the hash sign before `ptr`, as well as why `p` has a `(X, Y)` tuple before it. thx!
06:00:26 <KaneTW> learns: you could find some assignments for haskell courses and do them
06:00:45 <learns> KaneTW: I bet it's all maths..
06:00:52 <kaidelong> learns: http://en.wikipedia.org/wiki/Hunt_the_Wumpus
06:00:58 <hotcore> learns: read "Real World Haskell"; it is free on the web as HTML or PDF
06:01:13 <oherrala> learns: I have been doing http://www.codewars.com/ katas
06:01:42 <KaneTW> learns: not the one's i've seen, but math is extremely useful for haskell
06:02:26 <learns> thanks everyone! I think I'll try to love math
06:02:51 <kaidelong> math is no more useful for Haskell than it is for any other programming language really but that still means its quite useful
06:09:47 <KaneTW> i actually think it's more useful for haskell and functional languages in general
06:12:15 <izgzhen> Oh, as a reference for the last problem I asked, you may want to see this: https://github.com/GaloisInc/HaLVM/blob/master/src/HALVMCore/Hypervisor/Console.hsc#L183
06:18:18 <ywata> list
06:19:20 <KaneTW> tree
06:23:30 <nschoe> Hey guys, I'm trying to install ghc-mod, but I got this error: http://lpaste.net/131501
06:23:50 <nschoe> It just fails with ExitFailure 1 so I don't really konw what the problem is... any help?
06:26:41 <dmj`> nschoe: maybe try cabal update first, Not in scope: data constructor ‘ExposePackageId’ is the problem
06:27:04 <ywata> :q
06:27:33 <dmj`> nschoe: it seems like someone already beat you to stackoverflow
06:27:36 <dmj`> nschoe: http://stackoverflow.com/questions/29540829/how-do-you-set-up-haskell-ghc-mod-on-os-x
06:27:42 <nschoe> dmj`, tried update, did not work
06:27:46 <nschoe> Ah? Okay let me take a loook
06:27:50 <nschoe> look*
06:27:51 <dmj`> it's the same issue
06:28:29 <dmj`> nschoe: is this for haskell-mode w/ emacs by any chance?
06:28:38 <nschoe> dmj`, absolutely :-)
06:29:28 <nschoe> dmj`, but I'm not on MacOS
06:29:35 <nschoe> I'm under Arch.
06:29:57 <dmj`> nschoe: that's ok, pretty sure you don't need to use ghc-mod anymore to get the same experience w/ haskell-mode
06:30:48 <nschoe> dmj`, well, according to https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md , ghc-mod seems handy because you don't need to start an interactive session for it to report errors
06:32:50 <dmj`> nschoe: I think someone added something where the ghc-api is used, something lighter weight, but same effect
06:33:00 <dmj`> nschoe: sorry to be so vague :)
06:33:14 <dmj`> nschoe: I use haskell-mode for emacs, but I don't use ghc-mod
06:33:17 <nschoe> dmj`, okay, np. So are you saying that ghc-mod is somehow deprecated?
06:33:46 <dmj`> nschoe: I think deprecated is too strong a word, I think there are better alternatives though
06:33:58 <nschoe> hum ok...
06:34:48 <nschoe> dmj`, then, how do you get build-on-save feature in emacs?
06:35:10 <nschoe> From what I see, with haskell-mode, you have to explicitly call it (after loading an interactive session)
06:36:08 <dmj`> nschoe: you mean C-c C-l ? Sending to repl explicitly
06:36:34 <dmj`> nschoe: you just want to C-x s
06:36:36 <nschoe> dmj`, yes, if I understand correctly, C-c c-l is the same as calling 'cabal repl' in my sandbox, right?
06:37:16 <dmj`> nschoe: You can configure it to use cabal repl, but I think cabal repl is a lot slower. Let me check what I use
06:37:28 <nschoe> dmj`, I did configure it to use cabal repl.
06:38:08 <nschoe> dmj`, actually, haskell-mode seems pretty nice, but I think I'll find it a pain to always have a interpreter session opened, taking up space in Emacs :/
06:38:36 <dmj`> nschoe: I use cabal repl, it used to be slow in older versions of cabal
06:38:52 <dmj`> nschoe: I use the interpreter all the time
06:39:10 <nschoe> dmj`, ok. So it is always opened & visible in an Emacs buffer, right?
06:41:15 <dmj`> nschoe: yea, you don't like that? I inspect the types as I go sometimes, I C-c C-l a lot
06:41:55 <nschoe> dmj`, okay. Well I don't know if I like that or not. I'm used to dev in Haskell with Sublime Text. But I have always prefered Emacs for everything else, so I'd like to switch to Emacs entirely.
06:42:10 <nschoe> I guess I'll try to adapt mysel always keeping an interpreteur opened
06:42:43 <nschoe> dmj`, (C-c C-l sort of "refresh" the file, by (re)sending it to the interpreteur, right ?)
06:43:54 <nschoe> (By the way, how do you properly sto pthe interpreteur? When I quit emacs, it tells me there are processes still running)
06:44:46 <dmj`> nschoe: yea, I use sublime too for large refactorings, but emacs is more integrated with haskell dev IMO. To stop the interpreter I just kill the buffer, it prompts me to kill the session and all associated buffers
06:45:10 <nschoe> dmj`, okay. Will try that.
06:45:59 <nschoe> dmj`, sorry to ask so many questions, but, how do you get completion with haskell-mode? In the tutoril I found it adivses to make use of company-ghc, but since I can't install ghc-mod...
06:52:09 <dmj`> nschoe: I don't use completion, I think I use tags (M-/), but they aren't intelligent (but it's faster than a drop down gui). I have a lot of snippets for commonly used things. Completion kind of slowed me down, if I don't know what I want before I type it, then I probably shouldn't be typing.
06:52:35 <dmj`> if I really can't remember the function I'll use the haddocks, which you can browse from emacs
06:52:45 <dmj`> I think you can pull hackage docs too
06:52:45 <nschoe> dmj`, Ah ah, that is one way to put it, yes
06:52:52 <nschoe> dmj`, okay.
06:52:59 <nschoe> dmj`, more importantly, how do you query hoogle from emacs?
06:53:15 <dmj`> nschoe: M-x hoogle always worked for me
06:53:35 <ggVGc> so, these two lines are equivalent in haskell right? Could I write it in some way to not use parentheses around (bobo 'hi')? https://gist.github.com/48628d78d146edcb9f35
06:53:43 <dmj`> nschoe: you can even shell out to bash in ghci, :! echo "yo", so you can just call hoogle from there if it's in your path
06:54:45 <nschoe> dmj`, ah, okay. So yo ucall hoogle from repl/ghci. Nice.
06:54:50 <nschoe> I'll try to adapt to this workflow ^^
06:54:52 <dmj`> nschoe: yea, just put your cursor over the function / data type in question, then M-x hoogle >> enter
06:55:10 <dmj`> nschoe: hoogle should be available via M-x 
06:55:37 <dmj`> nschoe: if it doesn't work you might not have it installed
07:04:02 * hackagebot getopt-generics 0.6.3 - Simple command line argument parsing  http://hackage.haskell.org/package/getopt-generics-0.6.3 (SoenkeHahn)
07:19:03 * hackagebot yesod-transloadit 0.1.0.0 - Transloadit support for Yesod  http://hackage.haskell.org/package/yesod-transloadit-0.1.0.0 (boblong)
07:24:03 * hackagebot enummapset 0.5.2.1 - IntMap and IntSet with Enum keys/elements.  http://hackage.haskell.org/package/enummapset-0.5.2.1 (MichalTerepeta)
07:26:41 <joehh1> \quit
07:34:03 * hackagebot vado 0.0.4 - Runs commands on remote machines using ssh  http://hackage.haskell.org/package/vado-0.0.4 (HamishMackenzie)
07:47:14 <SrPx> Is it possible to implement "zip" with "foldr" efficiently? 
07:48:34 <opqdonut> no, not really
07:48:52 <SrPx> Wow. Really? Why?
07:49:14 <opqdonut> I don't see a way to iterate the second list
07:49:17 <opqdonut> scanl might be doable
07:51:14 <opqdonut> think of it this way, foldr f a (x:y:z:[]) ==> f x (f y (f z a))
07:51:15 <SrPx> Interesting ... but then saying "you can implement any list function with foldr without recursion" doesn't mean that you can do so efficiently, right?
07:51:26 <SrPx> opqdonut: yes
07:51:34 <opqdonut> f has to do the "same thing" at each index in the list
07:51:48 <opqdonut> so it's hard to get the i'th element from the second list
07:52:34 <SrPx> yep that's what I was thinking. But I just thought some clever use of continuation passing could solve it
07:52:49 <opqdonut> I'd reformulate this statement as "you can replace a recursive destructuring of a list xs with a foldr over xs"
07:53:06 <opqdonut> or something like that, doesn't really apply two multiple-list cases
07:53:13 <SrPx> makes sense.
07:54:05 * hackagebot jsaddle 0.2.0.4 - High level interface for webkit-javascriptcore  http://hackage.haskell.org/package/jsaddle-0.2.0.4 (HamishMackenzie)
07:55:09 <opqdonut> we can do something like this though:
07:55:25 <opqdonut> > let zip' xs ys = foldr (\x (built,(y:ys)) -> ((x,y):built,ys)) ([],ys) xs in zip' [1,2,3] [4,5,6]
07:55:28 <lambdabot>  ([(1,6),(2,5),(3,4)],[])
07:55:52 <nshepperd> continuations!
07:56:30 <nshepperd> zip = foldr (\a k bs -> case bs of {(b:s) -> (a, b) : k s; [] -> []}) (const [])
07:57:13 * nshepperd had to think real hard :>
07:57:23 <nshepperd> oh, you already suggested continuation passing
07:57:24 <opqdonut> wow
07:57:40 <SrPx> came up with that definition 
07:57:55 <SrPx> A little worse, though
07:58:00 <SrPx> zip' = foldr cons nil where cons h t (y:ys) = (h,y) : (t ys); cons h t [] = []; nil = cons []
07:58:07 <SrPx> now I wonder if we can eliminate the second matching
07:58:23 <SrPx> nil = const*
08:00:45 <nshepperd> the [] match? I think you need that so you know to stop at the end of the second list
08:01:21 <SrPx> your "case bs of {...}"
08:01:34 <SrPx> by a second foldr, somehow
08:01:37 <SrPx> dunno
08:01:39 <nshepperd> oh, hah
08:02:27 <SrPx> of course you can't do it inside (\a k bs → ...) so, hmm... dunno
08:04:07 <SrPx> maybe in place of nil and then you keep joining elements from both ends... [1,2,3,4] [40,30,20,10] → [(4,40)] & [1,2,3] [30,20,10] → [(3,30),(4,40)] & [1,2] [20,10] → ... 
08:04:12 * SrPx shrugs
08:04:50 <SrPx> nah that is nonsense. hmm there should be a way
08:21:08 <nshepperd> SrPx: behold, the list eliminator, written as a foldr
08:21:10 <nshepperd> > let list = (\f z as -> foldr (\a k qs -> f a as) (const z) as []) in list (\a as -> a) 7 [2]
08:21:11 <lambdabot>  2
08:23:22 <SrPx> (what)
08:23:31 <SrPx> that's head...?
08:24:21 <nshepperd> > let list = (\f z as -> foldr (\a k qs -> f a as) (const z) as []) in list (\a as -> a) 7 []
08:24:23 <lambdabot>  7
08:24:37 <nshepperd> er, I think it's not quite right though
08:25:47 <SrPx> lol interesting
08:26:18 <nshepperd> but I think a monstrosity like that is what you'd need to write to replace the case match with a foldr
08:27:47 <SrPx> just implementing the matching with foldr would not be good, though, that will be inefficient 
08:28:14 <SrPx> I was thinking in some sorcery to somehow fuse both foldrs. don't know, passing the continuation from one to another...? hm
08:36:29 <marcus-aurelius> Hi everybody! I want to enhance a simple command line tool with logging capability. The first try was just to use ordinary  IO operations. Unfortunatley that doesn't work in realtime when I want to pipe the output into a file ('>') while reading it ('tail -f').
08:36:29 <marcus-aurelius> I now saw that in the haskell-plattform Control.Monad.Logger is included and wonder how to use it. I haven't found any tutorials for this by searches. Can someone help out?
08:39:07 * hackagebot yesod-auth 1.4.5 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.4.5 (MichaelSnoyman)
08:46:38 <SrPx> nshepperd: hey!!! I got it!
08:46:50 <SrPx> nshepperd: but it is not typable on Haskell :(
08:46:54 <SrPx> I think.
08:48:16 <SrPx> zip a b = ((foldr cons nil a) (foldr cons nil b)) where { nil cont = []; cons x xs cont = x : cont xs }
08:48:25 <SrPx> it works on my lambda calculator, but not on Haskell :(
08:50:22 <nshepperd> haha wow
08:51:36 <SrPx> any idea why?
08:52:40 <nshepperd> where's the tuple constructor?
08:56:43 <joneshf-laptop> is there an agreed upon NEL?
08:57:50 <kuribas> SrPx: nil is a function?  Then xs is also a function?
08:57:53 <SrPx> nshepperd: it returns a flat list actually
08:58:16 <SrPx> yep, nil and xs are functions that receive the continuator and decides what to do
08:58:50 <SrPx> I create 2 continuators (foldr cons nil a) and (foldr cons nil b), then I send one to another in alternance, while extracting the heads as it goes
08:59:07 * hackagebot BufferedSocket 0.1.0.0 - A socker wrapper that makes the IO of sockets much cleaner  http://hackage.haskell.org/package/BufferedSocket-0.1.0.0 (tmore)
08:59:30 <SrPx> I have to finish a work now,, I'll leave a question on SO in case anyone is interested in taking this
09:01:50 <kuribas> :t let zip a b = ((foldr cons nil a) (foldr cons nil b)) where { nil cont = []; cons x xs cont = x : cont xs } in zip;
09:01:51 <lambdabot> parse error on input ‘;’
09:02:20 <kuribas> :t let {zip a b = ((foldr cons nil a) (foldr cons nil b)) where { nil cont = []; cons x xs cont = x : cont xs }} in zip;
09:02:21 <lambdabot> parse error on input ‘;’
09:15:04 <marcus-aurelius> Is someone here who already worked with Control.Monad.Logger? :-)
09:25:44 <faux___> i'd like to use a tool that autoformats my code. i have encountered hindent, stylish-haskell, and haskell-formatter. any recommendations? thanks
09:26:06 <prophile> the amazon mechanical turk
09:26:32 <f-a> hello. I am a Debian user and I need to submit a bug on a haskell program (hbro) segfaulting. Even if I invoke it with -v there is no additional info being displayed. Is there a way to squeeze out something more which could be useful to the maintainer?
09:28:12 <nolrai66> Would RTS flags help in that case?
09:30:47 <bergmark> f-a: http://hackage.haskell.org/package/hbro
09:31:42 <f-a> bergmark: what to do with this?
09:31:46 <faux___> prophile: i don't have money, i can't use mechanical turk
09:31:56 <bergmark> f-a: there you have the source repo and the maintainer's e-mail address
09:33:01 <f-a> bergmark: I use the debian package, I meant the debian package mainteiner
09:34:37 <nshepperd> f-a: if it's really segfaulting you could run it under gdb, and get a core dump, I suppose
09:34:43 <f-a> and nolrai66 , unfortunately +RTS is not enabled
09:34:48 <eitan_chatav> hi, how do I generate a random value according to a nonuniform probability distribution, in particular the laplace distribution, in Haskell?
09:34:55 <f-a> I will try this now nshepperd 
09:35:01 <nshepperd> not sure usefulness, whether we've got debugging symbols yet?
09:35:45 <nshepperd> but a core dump or stack trace may well help find the problem any way
09:37:19 <ReinH> eitan_chatav: use the gsl? https://hackage.haskell.org/package/hmatrix-gsl-stats-0.2.1/docs/Numeric-GSL-Distribution-Continuous.html
09:37:35 <eitan_chatav> hi ReinH! Happy birthday!!!
09:37:47 <ReinH> eitan_chatav: hi! aww thanks!
09:37:56 <ysr> I am trying to follow real world haskell online version, but I spend more time reading the comments than reading the book
09:39:09 * hackagebot cipher-aes128 0.7.0.1 - AES and common modes using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.7.0.1 (ThomasDuBuisson)
09:39:35 <eitan_chatav> ReinH: have you used that library before? is there a particular function that will generate a random value (in a MonadRandom, say) according to a distribution?
09:41:00 <ReinH> eitan_chatav: I haven't, but random_1p with a random seed would seem to do what you want
09:41:37 <eitan_chatav> ReinH: awesome, looks good, thanks!
09:41:48 <ReinH> eitan_chatav: yw
09:42:57 <ysr^AFK> I am awat
09:42:57 <srhb> ysr: Have you considered a different book, perhaps some of the resources from https://github.com/bitemyapp/learnhaskell ?
09:43:55 <ysr> srhb I started with learnyouahaskell
09:44:09 * hackagebot eventloop 0.2.1.1 - A different take on an IO system. Based on Amanda's IO loop, this eventloop takes a function that maps input events to output events. It can easily be extended by modules that represent IO devices or join multiple modules together.  http://hackage.haskell.org/package/eventloop-0.2.1.1 (sebaslafleur)
09:44:11 * hackagebot twentefp-eventloop-trees 0.0.0.1 - Tree type and show functions for lab assignment of University of Twente. Contains RoseTree and ParseTree  http://hackage.haskell.org/package/twentefp-eventloop-trees-0.0.0.1 (sebaslafleur)
09:44:17 <ysr> finished it but didn't go really deep
09:44:27 <srhb> ysr: I think RWH is too messy and dated to be a great learning tool compared to the other resources you can find on that page.
09:45:04 <ysr> srhb Yeah, I think it is messy too
09:45:10 <ysr> I will check the link you gave
09:46:17 <nolrai66> Man I feel so old now.
09:46:52 <nolrai66> RWH and "for the great good" didn't exist when I learned.
09:47:18 <nolrai66> I just used blog posts and ghc documentation.
09:47:44 <nolrai66> (Actually I still think just reading ghc documentation is a good way to learn the extensions.)
09:48:39 <nolrai66> Though so is just choosing something hard, and then popping in here when ever you get stuck.
09:50:10 <ysr^AFK> I am awat
09:54:10 * hackagebot fit 0.5.1 - FIT file decoder  http://hackage.haskell.org/package/fit-0.5.1 (mgiles)
09:56:49 <kuribas> ghc documentation is surprisingly good.
10:05:41 <rvxi> hi
10:08:35 <rvxi> running into some cabal issues all of a sudden (already using a sandbox)
10:09:08 <rvxi> getting errors like .cabal-sandbox/logs/random-1.1.log: does not exist
10:09:31 <rvxi> anyone ever run into this?
10:10:19 <srhb> rvxi: Could happen if a download / unpack failed I suppose?
10:10:50 <srhb> rvxi: https://github.com/haskell/cabal/issues/1914
10:10:50 <rvxi> srhb - it's now happening for every package i try to install
10:11:01 <rvxi> also when i make a clean sandbox and try there
10:11:04 <srhb> rvxi: try with -v3 and paste the output
10:13:30 <rvxi> with -v3 http://pastebin.com/raw.php?i=PYhVbDNn
10:24:30 <McManiaC> is there a "Either" for 3 arguments?
10:24:31 <McManiaC> :D
10:25:01 <ysr^AFK> You can always create it yourself :)
10:26:31 <Pamelloes> Is there a convention for how to implement inheritance in ffi bindings for an oop library?
10:27:34 <Black0range> Hey just noticed that for example [5..0] evaluates to []? why?
10:27:57 <bennofs> Black0range: because it assumes the forward direction
10:28:02 <fryguybob> > [5,4..0]
10:28:02 <bennofs> > [5..0]
10:28:03 <lambdabot>  mueval-core: L.hs: removeLink: does not exist (No such file or directory)
10:28:04 <lambdabot>  []
10:28:10 <bennofs> > [5,4..0]
10:28:11 <lambdabot>  [5,4,3,2,1,0]
10:28:22 <Black0range> oh
10:29:11 * hackagebot rainbow 0.26.0.0 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.26.0.0 (OmariNorman)
10:29:22 <Pamelloes> McManiaC: You can always do Either a (Either b c)
10:31:38 <monochrom> [5..0] = [] because it allows me to define this recursion without an explicit base case: f n = 1 + sum [f i | i <- [0 .. n-1]]
10:33:05 <Black0range> hmm what would be the most efficient way to make a descending list? 
10:33:37 <monochrom> use the [5 , 4 .. 0] example given 5 minutes ago
10:34:12 * hackagebot prednote 0.36.0.0 - Evaluate and display trees of predicates  http://hackage.haskell.org/package/prednote-0.36.0.0 (OmariNorman)
10:34:23 <Black0range> oh i forgot to add that the max value is a variable
10:34:43 <Black0range> [x..0] if x = 1 then there would be a problem :)
10:35:02 <eitan_chatav> Trying to use `hmatrix-gsl-stats` which depends on the c library `gsl` which i installed with brew on my mac. but it doesn't seem to be working. is there a trick to getting C libs to work?
10:35:22 <monochrom> [x..0] is not a generalization of the example [5, 4 .. 0]
10:35:32 <Black0range> sorry i mean [x, x - 1 ..]
10:35:32 <eitan_chatav> ld: warning: directory not found for option '-L/opt/local/lib/' Undefined symbols for architecture x86_64:
10:35:44 <eitan_chatav> Anyone know what to do in this case?
10:35:49 <monochrom> [x, x-1 .. 0]
10:35:49 <Black0range> and of course i forgot the zero...
10:36:11 <monochrom> > (\x -> [x, x-1 .. 0]) 1
10:36:12 <lambdabot>  [1,0]
10:36:16 <monochrom> what problem?
10:36:32 <monochrom> worksforme willnotfix
10:37:21 <Black0range> hah good attitude! I assumed that would be give me something weird
10:37:54 <monochrom> assume nothing. assume absolutely nothing.
10:38:11 <Black0range> word
10:38:14 <monochrom> the disease of most programmers is that they assume too much and test too little
10:38:26 <joneshf-laptop> i'm having a brain fart, isn't there a nice way to write this: `\(p, f) (q, x) -> (p * q, f x)`?
10:38:50 <marchelzo_> @pl \(p, f) (q, x) -> (p * q, f x)
10:38:50 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .) . (*))
10:38:59 <marchelzo_> well if there is, that's not it!
10:39:04 <monochrom> @type (***)
10:39:05 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
10:39:09 <bennofs> joneshf-laptop: if p and q were Product, then it would just be (<*>) :)
10:39:10 <monochrom> @type (&&&)
10:39:11 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
10:39:12 * hackagebot rainbox 0.16.0.0 - Two-dimensional box pretty printing, with colors  http://hackage.haskell.org/package/rainbox-0.16.0.0 (OmariNorman)
10:39:13 <bennofs> :t Product
10:39:14 <lambdabot> a -> Product a
10:39:21 <bennofs> > Product 3 <> Product 4
10:39:22 <lambdabot>  Product {getProduct = 12}
10:40:04 <prophile> joneshf-laptop: there may be Writer or arrow options, but is that form you have it in really so bad?
10:40:06 <joneshf-laptop> bennofs, oh?
10:40:16 <monochrom> @type \op1 op2 (p,f) (q,x) -> (op1 p q, op2 f x)
10:40:17 <lambdabot> (t -> t2 -> t4) -> (t1 -> t3 -> t5) -> (t, t1) -> (t2, t3) -> (t4, t5)
10:40:30 <joneshf-laptop> prophile, no, it's not bad, I just thought there was something in `Arrow` tha already did that
10:40:44 <monochrom> I don't know of a better way
10:40:45 <prophile> ah
10:40:48 <prophile> alas, looks unlikely
10:40:58 <bennofs> > (Product x, f) <*> (Product y, a) :: (Product Expr, Expr)
10:40:59 <lambdabot>  (Product {getProduct = x * y},f a)
10:41:03 <bennofs> joneshf-laptop: ^^^^
10:41:33 <joneshf-laptop> bennofs, nice, but how?
10:41:36 <joneshf-laptop> oh!
10:41:36 <joneshf-laptop> right
10:44:56 <kqr> if I have a couple of prisms and I want to use them with alongside, how would I go about that? (I accept both (Maybe a, Maybe b) and Maybe (a, b) as a result)
10:45:17 <bennofs> :t alongside
10:45:18 <lambdabot> LensLike (Control.Lens.Internal.Getter.AlongsideLeft f b') s t a b -> LensLike (Control.Lens.Internal.Getter.AlongsideRight f t) s' t' a' b' -> LensLike f (s, s') (t, t') (a, a') (b, b')
10:48:12 <kqr> hm maybe something like below helps
10:48:56 <bennofs> > (1, Just "lens") ^? aside _Just
10:48:57 <lambdabot>  Just (1,"lens")
10:51:57 <bennofs> > (1, Just "lens") ^? beside id _Just
10:51:58 <lambdabot>      No instance for (Num [Char]) arising from the literal ‘1’
10:51:58 <lambdabot>      In the expression: 1
10:51:58 <lambdabot>      In the first argument of ‘(^?)’, namely ‘(1, Just "lens")’
10:51:59 <kqr> > [Just "lens", Nothing, Just "okay"] ^.. aside _Just
10:52:00 <lambdabot>      Couldn't match type ‘(e, Maybe a)’ with ‘[Maybe [Char]]’
10:52:01 <lambdabot>      Expected type: Getting (Endo [(e, a)]) [Maybe [Char]] (e, a)
10:52:01 <lambdabot>        Actual type: ((e, a) -> Const (Endo [(e, a)]) (e, a))
10:54:36 <ysr^AFK^AFK> what does this file do? https://github.com/NICTA/course/blob/master/src/Course.hshttps://github.com/NICTA/course/blob/master/src/Course.hs
10:54:41 <bennofs> > (Just "lens", Just True) ^? runFold ((,) <$> Fold (_1._Just) <*> Fold (_2._Just))
10:54:43 <lambdabot>  Just ("lens",True)
10:57:21 <Denommus> Hi
10:58:51 <Lokathor> hello
10:58:52 <bennofs> kqr: might also ask in #haskell-lens. 
10:59:19 <kqr> ah. I solved it more primitively now, but I'll keep that in mind for the next time :)
11:04:52 <ysr> Do you guys know how should I follow this course: https://github.com/NICTA/course
11:07:29 <nomeata> Hi. Does someone have a nice solution to make Cabal include the output of "git describe --tags" in Paths, or something equivalent, with a fallback to the version in .cabal if this is not run in a git repo?
11:13:32 <nomeata> I’m leaning between a Cabal Setup preBuild hook akin to http://www.hyperedsoftware.com/blog/entries/build-info-gen.html or a Template Haskell solution like https://hackage.haskell.org/package/git-embed-0.1.0
11:15:29 <joneshf-laptop> ysr, yeah it's a bit confusing what you're supposed to do, does this help: https://github.com/NICTA/course#getting-started ?
11:16:44 <ysr> joneshf-laptop so, I am supposed to open the files in Course folder, and fill out missing stuff so that code compiles?
11:18:18 <joneshf-laptop> ysr, yeah
11:18:38 <joneshf-laptop> ysr, the order is given here: https://github.com/NICTA/course#progression
11:19:08 <McManiaC> can somebody explain to me (like i'm 5) what Control.Exception.mask is good for?
11:21:27 <rezwu> Is haskell worth investing my time to learn if I’m still beginner at programming? I know javascript basics, made hello world level android app, and worked on .NET project previously. 
11:21:58 <doomlord> some claim it will be easier
11:22:12 <doomlord> if its your first language
11:22:53 <Denommus> rezwu: it is challenging, but worth the effort 
11:23:27 <rezwu> doomlord: How much is the knowledge worth commercially, given that I have limited time. Sadly
11:23:52 <doomlord> rezwu i think it's fair to say, "it'll make you a better programmer"
11:23:56 <rezwu> I would love to learn it but there are other things to be done too
11:24:10 <doomlord>  ideas pioneered in haskell are appearing in other languages
11:24:13 * hackagebot crypto-classical 0.1.0 - An educational tool for studying classical cryptography schemes.  http://hackage.haskell.org/package/crypto-classical-0.1.0 (fosskers)
11:24:23 <Denommus> rezwu: if you want a job and nothing else, Haskell is not for you 
11:24:29 <rezwu> doomlord: I understand but is it significantly better than becoming a better programmer with other languages?
11:24:34 <rezwu> Denommus: I see
11:24:38 <doomlord> take my opinions with a pinch of salt, i've never mastered haskell myself. but I'd been getting into Rust, and it definitely takes some ideas
11:24:39 <shachaf> You're free to learn or not learn Haskell as you wish.
11:25:09 <rezwu> shachaf: yes. I was just wondering because haskell has been the buzz word recently
11:25:10 <frerich> ion: srhb: bergmark: re bool/maybe/either: these functions are 'catamorphisms' and GHC could indeed generate them automatically. There is a package at http://hackage.haskell.org/package/catamorphism which generates them automatically for custom types.
11:25:18 <johnw> also, there may be more to life than acquiring knowledge which is commercially viable
11:25:21 <verement> Haskell challenges you to think about programming in ways you won't find in other languages
11:25:22 <srhb> frerich: Thanks
11:25:31 <Denommus> rezwu: despite that, there aren't that many Haskell jobs 
11:25:31 <rezwu> johnw: I definitely agree
11:26:05 <Denommus> Maybe learn Scala, I don't know 
11:26:43 <rezwu> thanks for sharing your opinion
11:27:02 <doomlord> Thats a fair suggestion... I for one do personally much prefer multiparadigm languages and was able to get much further with them
11:29:54 <monochrom> a beginner in programming is a person that gets the biggest bang out of the buck learning haskell
11:30:23 <ion> frerich: -- Defines 'maybe :: b -> (Maybe a -> b) -> Maybe a -> b'
11:30:27 <ion> I suppose that’s a typo?
11:31:10 <monochrom> i.e., you have 50 years ahead of you. Haskell is here to stay. you will eventually have to know it for better or worse.
11:31:41 <doomlord> i think seeing similar ideas in a more familiar syntax went better for me
11:31:54 <doomlord> bits of haskell made more sense *after* i'd used rust
11:31:56 <monochrom> since you are sure you will have to know it, learning when young is better than learning when not young
11:32:07 <Denommus> doomlord: I personally dislike Scala, but it probably has a bigger market share 
11:32:41 <frerich> ion: Not sure I see the typo.
11:33:06 <ion> frerich: I would have expected b -> (a -> b) -> Maybe a -> b
11:33:14 <doomlord> Denommus what do you make of clojure
11:33:34 <doomlord> (if i remember you're a lisp fan?)
11:34:19 <Denommus> doomlord: I don't understand why some syntax constructs use arrays and others use lists, but besides that it's a usable Lisp 
11:34:57 <Denommus> doomlord: yeah, I'm a Lisp fan, but I have been doing mostly Haskell and OCaml for some time (besides QML and C++, of course) 
11:35:09 <frerich> ion: Oh, duh, yeah - of course. That also what's defined.
11:35:09 <doomlord> Denommus i tried common-lisp and clojure round about the same time, coming to them as a non-lisper.. i actually rather liked clojure. But ultimately i'm not a fan of the JVM generally :)
11:35:32 <doomlord> i liked the fact it had 'funcallable objects' etc.
11:35:51 <doomlord> threading macro etc
11:37:43 <Denommus> doomlord: yeah, funcallable objects is a Lisp-1 thing 
11:40:59 <Denommus> doomlord: but I prefer Haskell's composition operator and OCaml's piping operator over Clojure's threading macro 
11:41:24 <doomlord> fair enough
11:42:04 <SrPx> nshepperd: btw in case you are interested this is the definition that works with the tuple constructor http://lpaste.net/131519
11:43:02 <SrPx> I find it very elegant, sad fact it won't pass through the typesystem :(
11:53:02 <a2> monochrom: ive been telling people that as well!
11:54:08 <a2> monochrom: haskell is among the best currently when it comes to parallelism and concurrency. if you are going to be programming in our masivelly multicore future, its going to be in something functional.
11:54:57 <simpson> Unless something better comes along.
11:55:31 <a2> monochrom: basically i say that you would be better off learning today at a lesurely pace, than hurrying having to learn with a work deadline looming
11:55:36 <a2> simpson: sure
11:55:56 <a2> simpson: agreed. id be interested if you know of something better!
11:56:03 <apollo1993> monochrom: define young :)
11:56:56 <a2> apollo1993: im pretty young. only 22
11:57:02 <simpson> a2: I have several candidates under development. However, my point was more that we have no guarantees that tomorrow we will not discover some new, alien, massively better model of computation.
11:57:23 <zomg> simpson: psst.. it's javascript
11:57:33 <a2> simpson: yes! im very into that. i think that J lang is pretty close to that
11:57:46 <a2> simpson: http://jsoftware.com/
11:59:17 <a2> simpson: mind sharing what you are working on, im always interested in new ideas
12:00:12 <simpson> a2: Well, two example environments are Erlang, and also Chuck Moore's green arrays, which are hundreds (!!) of cores which automatically (!!!) distribute a flavor of colorForth between them.
12:00:39 <simpson> Additionally, I'm personally working in reviving the E language, via a newer language called Monte. Read up on E to learn more.
12:01:24 <a2> simpson: yes! im a big fan of green arrays. although ive heard there are some problems, such as the IO not having enough throughput to saturate the entire array
12:01:49 <a2> although im sure that will be fixed in further editions
12:03:36 <a2> simpson: i think that J is a good candidate too. since it has a lot of mechanical sympathy in terms of cache data locality, and since its mostly functional, distributing computations with its is just as easy as opening a few sockets
12:04:11 <simpson> a2: Ah. Well, that's actually a fundamental premise of languages like Erlang and E, that "opening a few sockets" is a very unfriendly and tricky thing to do correctly.
12:04:15 * hackagebot BufferedSocket 0.1.1.0 - A socker wrapper that makes the IO of sockets much cleaner  http://hackage.haskell.org/package/BufferedSocket-0.1.1.0 (tmore)
12:05:26 <a2> simpson: sure, but implementing mailboxes and actors is not too difficult on top of that. if it hasnt been done already
12:05:28 <joneshf-laptop> a2, well anything that gets us away from von Neumann is a step in the rigth direction, no?
12:05:33 <a2> simpson: ill need to take a look at e though
12:05:42 <a2> joneshf-laptop: yes! indeed
12:06:34 <a2> simpson: but the biggest win for J is the language itself, since it doesnt have a focus on distributed computing
12:08:01 <a2> simpson: ive been tossing around the idea of a J/Agda hybrid. although one of the virtues of J is that fact that it has a limited set of types, its dynamism comes from its polymorphism over the dimension of the array, and the efficiency comes from the limited set of types 
12:08:38 <a2> so adding mechanisms for new adding new types would clash with the years of optimization efforts put into J
12:08:51 <a2> alas, there is no free lunch
12:11:31 <Hijiri> a2: there is cloud haskell
12:12:07 <a2> although i do see much to be gained with a TH macro that expands a subset of J into either accelerate or repa code
12:12:14 <a2> Hijiri: yes, its great
12:14:15 * hackagebot hspec-snap 0.3.2.6 - A library for testing with Hspec and the Snap Web Framework  http://hackage.haskell.org/package/hspec-snap-0.3.2.6 (DanielPatterson)
12:19:15 * hackagebot bindings-fluidsynth 0.1.1 - Haskell FFI bindings for fluidsynth software synthesizer  http://hackage.haskell.org/package/bindings-fluidsynth-0.1.1 (BenGamari)
12:23:14 <osa1> I need some HUnit test wrappers for allocating some resources before tests and releasing them even when tests fail, do we have a package for this?
12:24:02 <ysr> So, I know the criteria to tell if something is a monad, and I can work with list and IO monads. Does it mean that I know monads?
12:27:07 <osa1> ysr: no, but that probably means you're ready to write some haskell :) get familiar with some other widely used monads like Either, Maybe, Reader, Writer, State and their transformer versions and you're good to go...
12:27:32 <ysr> transformer versions?
12:28:14 <osa1> ysr: not sure if this is best intro but see https://wiki.haskell.org/Typeclassopedia#Monad_transformers
12:31:23 <dmj`> to transform a monad is a noble task
12:31:31 <ggVGc> has anyone here done anything music-related with haskell?
12:31:52 <mniip> ggVGc, putStrLn "\a"
12:32:15 <dmj`> ggVGc: https://vimeo.com/96744621
12:32:56 <dimsuz> hello! having an array of nested type values aka [Token (Identifier "id1"), Token (Identifier "id2")] what would be the best course of action to map these to ["id1","id2",...]?
12:34:48 <dimsuz> I've read a bit on lenses (never used them though) and this task looks somewhat similar to getting deep into records, but for type constructors...
12:34:53 <dmj`> map (\(Token (Identifier x)) -> x) [Token (Identifier "id1"), Token (Identifier "id2")] 
12:35:37 <dmj`> > map fromJust [Just "id1", Just "id2"] 
12:35:39 <lambdabot>  ["id1","id2"]
12:35:43 <ggVGc> dmj`: yeah, I've been watching that. Just curious to speak with someone who has some handson experience withit
12:36:05 <dimsuz> dmj`: oh, thank you. I had something like this in mind, only w/o immediate pattern matching but suddenly I thought I might miss even something more obvious
12:36:30 <dimsuz> maybe some nice abstraction :)
12:36:41 <neuroserpens> Can anyone explain to me what these O, O2, and O3 compiler flags are?
12:38:13 <dmj`> dimsuz: you can make it more palatable if you abstract the mapping function out into a where
12:38:50 <aochagavia> hello! Is there a special channel to talk about ghc development or is this one ok?
12:39:00 <dmj`> aochagavia: #ghc
12:39:07 <aochagavia> ;) thanks!
12:39:17 * hackagebot catamorphism 0.4.0.1 - A package exposing a helper function for generating catamorphisms.  http://hackage.haskell.org/package/catamorphism-0.4.0.1 (frerich)
12:40:09 <dmj`> neuroserpens: when you specify the "O" it corresponds to Core transformations, the more transformations the more efficient your code can become, but the longer it will take to compile, so maybe make a flag "dev" "prod" etc. in your cabal file for those ghc-options
12:40:40 <frerich> ion: I hope you didn't mind me mentioning you as the reporter of the documentation issue: https://github.com/frerich/catamorphism/commit/2720cea457ff70caf72a7486db0eb07009c136fb
12:40:47 <neuroserpens> dmj`: I see. Thanks a lot.
12:40:59 <ion> frerich: I don’t mind. :-)
12:41:14 <neuroserpens> dmj`: Me and a friend wrote the same code for a problem in codechef but his spent no memory while mine spent 6 mb and i was like wtf
12:41:15 <tommd> How frequently does travis-ci cabal-update?
12:41:33 <frerich> ion: Just don't be surprised if you see groups of teenage girls throwing their bras onto your balcony now. You're famous now.
12:42:03 <dmj`> neuroserpens: ha cool :) it pays to understand compilation, but ghc's compilation pipeline is anything but trivial 
12:42:40 <dmj`> tommd: it should cabal update on every pull req. that's what circle ci does at least
12:42:46 <dmj`> er, every commit
12:43:27 <ion> frerich: They’ll have to go to the queue, teenage girls have really loved my quadratic irrational math library.
12:44:13 <neuroserpens> dmj`: I see. Your explanation was very clear. Thanks again.
12:45:30 * frerich throws a couple of pink stuffed animals in ion's direction
12:49:59 <dmj`> neuroserpens: if you're into ghc, this is good things: http://takenobu-hs.github.io/downloads/haskell_ghc_illustrated.pdf
12:52:44 <neuroserpens> dmj`: wow nice
12:53:25 <faux___> i can do 'import Data.GraphViz (LNodeCluster)' without error. but then data constructor 'LNodeCluster' is not in scope. what does this mean? thanks.
12:55:40 <mauke> you only imported the type name, leaving it abstract
12:55:52 <mauke> import Data.GraphViz (LNodeCluster(..))
12:56:25 <dmj`> mauke++
12:56:56 <johnw> what should default-language be set to for projects using 7.10.1?
12:57:19 <johnw> if I don't include it, GHC and cabal are happy, but cabal upload fails; if I do include it, GHC won't build saying: Setup: The package github-0.13.2 requires the following languages which are not supported by ghc-7.10.1: haskell2010
12:57:56 <SrPx> Anyone else find it weird that `length (scanl f g list) == length list + 1` ? o.o
12:58:04 * hexagoxel expected something along the lines of "but happy is sad"
12:58:09 <johnw> scanl includes []
12:58:15 <SrPx> for some stupid reason I assumed it was equal but ofc it is not. but that is weird
12:58:25 <dmj`> johnw: 7.10.1 doesn't support Haskell2010?
12:58:34 <johnw> that's what I'm being told
12:59:01 <johnw> oh, maybe I really need to capitalize
12:59:04 <ronh> trying to use HTUnit with cabal for the first time.. if I add tests in src/test directory (which seems to be a common thing to do), I can't import the files from src/.. how does one handle that?
12:59:11 <johnw> yeah, that was it, thanks
12:59:18 * hackagebot eventloop 0.2.1.2 - A different take on an IO system. Based on Amanda's IO loop, this eventloop takes a function that maps input events to output events. It can easily be extended by modules that represent IO devices or join multiple modules together.  http://hackage.haskell.org/package/eventloop-0.2.1.2 (sebaslafleur)
12:59:20 * hackagebot github 0.13.2 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.13.2 (JohnWiegley)
12:59:25 <ronh> HUnit*
13:00:12 <dmj`> ronh: in your library do you specify hs-source-dirs: src, tests?
13:00:34 <dmj`> ronh: maybe post your cabal file
13:01:17 <faux___> mauke: thanks
13:02:26 <ronh> dmj` I have not actually tried to run tests through cabal yet.. I'm loading the file to ghci and trying to call main.. but the code won't compile unless there's a special way to import files.
13:02:58 <ronh> with this approach you can't load main and run it directly in ghci?
13:03:34 <dmj`> ronh: It won't compile? Or ghci can't find your code?
13:04:14 <dmj`> ronh: If you're using a sanbox ghci might be ignorant of your dependencies, you must cabal `cabal exec ghci`
13:04:24 <dmj`> ronh: yea, that should fix it 
13:04:42 <johnw> haha: Deprecated: "If you think you know what you are doing, use 'unsafePerformIO'. If you are sure you know what you are doing, use 'unsafeDupablePerformIO'. If you enjoy sharing an address space with a malevolent agent of chaos, try 'accursedUnutterablePerformIO'."
13:04:47 <johnw> message from GHC 7.10
13:05:08 <dmj`> johnw: lolol
13:05:13 <ion> :-D
13:05:45 <jle`> I just use unsafeCoerce, is that ok too
13:06:05 <ronh> dmj` the issue is that "import Foo" won't work in /src/test/main.hs when foo's path is /src/foo.hs
13:06:42 <ion> johnw: Which function has that warning?
13:06:54 <johnw> oh, I don't know, it was just in my build log
13:07:13 <ronh> I am not using sandbox ghci, and don't even know what that is. just plain ghci
13:08:49 <dolio> Plain ghci doesn't know about source directories and all that from cabal.
13:08:53 <dmj`> ronh: in ghci do, ":set -isrc" and ":set -itests"
13:09:17 <dmj`> ronh: you need to give ghci a hint where to look, by default it isn't going to know where to find that module
13:09:34 <dmj`> ronh: you should always use sandboxes 
13:09:37 <dolio> All this will probably be easier if you use 'cabal repl'.
13:09:46 <dolio> Instead of ghci.
13:09:53 <dolio> Although I'm not sure if it does tests.
13:10:41 <soud> Hi, I'm trying to install streams for building geordi, but I'm getting an error: https://bpaste.net/show/64632f70b39b . The error really doesn't say much to me.
13:11:46 <dmj`> soud: are you using base 4.9? 
13:12:22 <soud> dmj`: 4.8.0.0
13:12:53 <ion> https://github.com/haskell/bytestring/blob/master/Data/ByteString/Internal.hs#L627
13:12:57 <dmj`> soud: well the error is that there are two functions imported with the same name.
13:13:08 <dmj`> from different modules
13:16:06 <soud> dmj`: I see, is there anything I can do about this? Isn't this the package's fault?
13:20:15 <dmj`> soud: yea, make an issue on github
13:20:36 <dmj`> soud: let me try to install first
13:20:44 <soud> dmj`: great, thanks
13:21:08 <dmj`> soud: sometimes the monads get out of control and things happen
13:23:08 <neuroserpens> So... I want to map read . words on a line from input and turn that list into a tuple to pass it to another function
13:23:13 <neuroserpens> I'm a bit lost
13:23:46 <aaronm04> Hi all, what is your favorite Vim plugin that does haskell indentation (and preferrably, completion)?
13:27:52 <hiptobecubic> aaronm04, necoghc for completion
13:32:28 <latk> are there any packages people would recommend to use for logging ? 
13:32:41 <johnw> if your needs are simple, then 'logging'
13:32:44 <johnw> @hackage logging
13:32:44 <lambdabot> http://hackage.haskell.org/package/logging
13:32:59 <johnw> I'm working on the next version of this package, which simplifies it even further
13:33:48 <tertl3-laptop> how ironic
13:36:27 <aaronm04> hiptobecubic: thanks! no idea about indentation, though?
13:36:32 <aaronm04> or does necoghc do that?
13:36:44 <aaronm04> I should probably just see myself... :)
13:36:53 <hiptobecubic> aaronm04, there are a few haskell syntax files floating around, but vim already does haskell formatting i think?
13:38:16 <latk> johnw: I would think pretty simple. Got some long running scraping tasks, would like to have some logfiles to keep track of what is going on. Will look at logging, thanks.
13:47:54 <dmj`> soud: ping
13:48:09 <dmj`> soud: sorry my battery died, streams installed fine for me
13:48:29 <soud> dmj`: wb!
13:48:32 <soud> dmj`: hmm weird
13:48:40 <dmj`> soud: what is wb?
13:48:47 <soud> dmj`: welcome back
13:52:40 <aaronweiss74> aaronm04: I use ghcmod-vim and vim2hs.
13:56:10 <aaronm04> hiptobecubic: it does Haskell syntax hilighting out of the box, but not indentation or completion
13:56:32 <aaronm04> well, it's hard to say about completion... there are so many Vim features it could be one of them
13:56:41 <aaronm04> aaronweiss74: thanks!
13:58:34 <EvanR> ctrl N
13:58:50 <EvanR> ctags
14:00:06 <Pamelloes> Is there a way of transferring a value via FFI, instead of a pointer?
14:01:01 <EvanR> Binary
14:01:08 <EvanR> if its haskell to haskell
14:01:27 <EvanR> or you can use a non-pointer FFI type like CInt
14:02:22 <Pamelloes> I'm trying to marshall (Word,Word) to struct Range { uint loc; uint len; }
14:02:32 <EvanR> then you need Storable
14:02:41 <Pamelloes> Ok
14:03:07 <EvanR> make a Storable instance for a data type Range Word Word
14:05:39 <Taslem> Is there a way that I can ask GHC to tell me where I've used a particular instance for a typeclass?
14:06:05 <neuroserpens> ok I'm kind of ashamed to ask this because I'm still beginning but what's wrong with this? withdraw $ map read . words =<< getLine
14:06:07 <neuroserpens> please bear with me
14:06:35 <EvanR> map read words probably isnt a function so using it with . doesnt make sense
14:06:44 <indiagreen> “map read . words” is a pure function, and you don't need =<< to apply it to the read line
14:06:50 <EvanR> uhg i misread that because its on the edge of the screen
14:06:52 <indiagreen> you need <$> (fmap)
14:07:12 <noreason> i guess this is main channel
14:07:20 <EvanR> main screen turn on
14:07:40 <monochrom> noreason, if you continue your provocative tactic here, I will simply ban you.
14:07:56 <neuroserpens> indiagreen: I have no idea what <$> is
14:07:59 <noreason> go ahead monochrom 
14:08:05 <indiagreen> :t (<$>)
14:08:06 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:08:13 <caconym> anyone have any experience using travis-ci or similar with haskell projects? i'm worried that GHC's memory usage is going to give me grief
14:08:16 <indiagreen> :t (<$> getLine)
14:08:17 <lambdabot> (String -> b) -> IO b
14:08:19 <neuroserpens> lol still no idea what that is
14:08:21 <caconym> i have not yet tried to set anything up
14:08:33 <noreason> if you cant answer that what you can do monochrom 
14:08:35 <indiagreen> :t map read . words <$> getLine
14:08:36 <lambdabot> Read b => IO [b]
14:08:36 <EvanR> neuroserpens: check out fmap, it is awesome
14:08:43 <EvanR> :t fmap
14:08:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:08:59 <neuroserpens> fmap and <$> are the same thing?
14:09:03 <EvanR> yes
14:09:17 <neuroserpens> why two different names?
14:09:19 <neuroserpens> o.0
14:09:22 <EvanR> ones an operator
14:09:23 <Taslem> although <$> isn't in Prelude
14:09:38 <pavonia> I think it is now
14:09:39 <EvanR> use fmap in places you would use map
14:09:40 <geekosaur> fmap is the historical name. <$> was added with Control.Applicative
14:09:42 <danilo2> Hello! :) I'm trying to build GHC cross-compiler (Linux -> ARM). I've found a lot of documents on the web, but they are a little bit old. Could anybody recommend me any source / hints regarding ARM backend support by modern GHC distributions?
14:09:46 <Taslem> Hm, not in my version
14:10:13 <geekosaur> and the concept of applicative functors
14:10:17 <indiagreen> caconym: Travis CI works alright with Haskell
14:10:41 <indiagreen> I think GHC itself is being built on Travis
14:10:52 <indiagreen> (and they had some problems because of time limit)
14:11:28 <caconym> indiagreen: ok, that's good to know; presumably my project will not take as long as GHC to build :)
14:11:37 <indiagreen> you can use their GHCs, or you can use hvr's repositories
14:11:50 <caconym> indiagreen: though it does take a few minutes even on my fast laptop with 16G of memory
14:12:17 <caconym> indiagreen: any idea if GHC 7.10 will be a currently be a dealbreaker getting anything to work?
14:12:37 <indiagreen> GHC 7.10 isn't supported on Travis yet (unless you use hvr's repositories, right)
14:12:43 <bennofs> caconym: hvr's repo has GHC 7.10 and any other version of ghc
14:13:08 <bennofs> caconym: see https://github.com/hvr/multi-ghc-travis
14:13:12 <caconym> indiagreen bennofs thanks very much! I will look into hvr
14:14:38 <bitemyapp> michaelchurch: where's the o?
14:15:09 <chpatrick1> is there an alternative way of making an Ap (Coyoneda f)?
14:15:18 <chpatrick1> as in, some isomorphic ekmett-type
14:24:20 <noreason> bitemyapp go stick with your channel
14:24:21 * hackagebot pred-trie 0.0.11 - Predicative tries  http://hackage.haskell.org/package/pred-trie-0.0.11 (athanclark)
14:25:32 --- mode: ChanServ set +o monochrom
14:25:38 --- mode: monochrom set +b *!*@83.143.240.6
14:25:38 --- kick: noreason was kicked by monochrom (noreason)
14:25:45 --- mode: monochrom set -o monochrom
14:25:54 <neuroserpens> rofl
14:34:22 * hackagebot gitlib-libgit2 3.1.0.4 - Libgit2 backend for gitlib  http://hackage.haskell.org/package/gitlib-libgit2-3.1.0.4 (JohnWiegley)
14:34:24 * hackagebot git-monitor 3.1.1.4 - Passively snapshots working tree changes efficiently.  http://hackage.haskell.org/package/git-monitor-3.1.1.4 (JohnWiegley)
15:02:27 <meretrix> So I've been using ghci to control my haskell process -- just load its libraries in ghci, and then send data back and forth using Binary and IPC.  But as I move my application to its own production environment, I no longer want a whole ghc install on the server.  Any suggestions for a simple alternative type-safe RPC setup?
15:04:07 <balor> I'm trying to get a Maybe String from an IO (Maybe [String]) -- code here http://lpaste.net/131527 -- Which doesn't typecheck.  What am I doing wrong>
15:04:23 * hackagebot pred-trie 0.0.12 - Predicative tries  http://hackage.haskell.org/package/pred-trie-0.0.12 (athanclark)
15:05:46 <mauris_> balor: that's impossible
15:06:14 <mauris_> you probably want "Maybe [String] -> Maybe String"
15:06:15 <meretrix> balor: IO is on the wrong side
15:06:23 <c_wraith> balor: the trick with IO is that >>= lets you use an IO foo as if it was a foo
15:06:36 <mauris_> and then just `fmap` that over your IO action, probably?
15:06:48 <balor> thanks all, I get it now
15:06:55 <mauris_> (i don't know what you want to do with the value though)
15:10:16 <monochrom> mauris_: see my http://www.vex.net/~trebla/haskell/IO.xhtml
15:10:22 <neuroserpens> Please... What's wrong with map read $ words line? being that line is a string of course
15:10:49 <neuroserpens> I'm getting a no parse
15:10:52 <monochrom> > map read $ words "123 456"
15:10:53 <lambdabot>  [*Exception: Prelude.read: no parse
15:11:02 <monochrom> oh I see, typing
15:11:12 <monochrom> > (map read $ words "123 456") :: [Int]
15:11:13 <lambdabot>  [123,456]
15:11:36 <monochrom> if the type becomes [()] for whatever reason, then...
15:11:36 <neuroserpens> ... crap fakk god@#$%@%#%$@#$%
15:11:40 <neuroserpens> thanks.................
15:11:50 <monochrom> > map read $ words "() ()"
15:11:52 <lambdabot>  [(),()]
15:13:04 <monochrom> () is the best type since Void :)
15:13:07 <mauris_> monochrom: i'm more confused about what balor was trying to do than about IO, i guess!
15:13:13 <neuroserpens> I am getting the impression that ghci is retarded
15:13:15 <mauris_> but this looks like a neat IO tutorial
15:13:35 <monochrom> oh! I should tell balor instead
15:13:43 <monochrom> balor: see my http://www.vex.net/~trebla/haskell/IO.xhtml
15:14:00 <balor> mauris_, I'm trying to create an instance of FromReqURI that gets data from a database
15:14:58 <mauris_> the data being a Maybe [String]?
15:15:33 <balor> mauris_, the data is an IO (Maybe [String]) as the db lookup is an IO action
15:16:05 <mauris_> i see
15:16:25 <mauris_> but: what's an example Maybe [String] value yielded by that IO action, and what do you want to turn it into?
15:18:32 <joneshf-laptop> is there some slick way to have this: reverse . sortBy (compare `on` foo) ?
15:18:57 <joneshf-laptop> > sortBy (compare `on` fst) [(1, 2), (5, 6), (3, 4)]
15:18:57 <arkeet> sortBy (flip compare `on` foo)
15:18:58 <lambdabot>  [(1,2),(3,4),(5,6)]
15:19:15 <joneshf-laptop> > sortBy (flip compare `on` fst) [(1, 2), (5, 6), (3, 4)]
15:19:16 <lambdabot>  [(5,6),(3,4),(1,2)]
15:19:23 <joneshf-laptop> arkeet, cool thanks
15:19:29 <arkeet> sortBy (flip (comparing foo))
15:19:32 <balor> mauris_, I'm trying to turn it into a Maybe String i.e. filter the rows that come back from the DB
15:20:22 <joneshf-laptop> arkeet, lens?
15:20:28 <arkeet> no, comparing is standard
15:20:39 <mauris_> balor: right; i assume you want to turn a Nothing into a Nothing. what do you want to do with Just []? and with Just ["a", "b"]?
15:20:42 <joneshf-laptop> :t comparing
15:20:43 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
15:20:48 <joneshf-laptop> :browse comparing
15:20:53 <arkeet> @hoogle comparing
15:20:54 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
15:20:54 <joneshf-laptop> @info comparing
15:20:54 <lambdabot> comparing
15:20:58 <joneshf-laptop> k
15:21:18 <arkeet> :t Dual
15:21:19 <lambdabot> a -> Dual a
15:21:34 <arkeet> > sortBy (comparing Dual) [2,3,1]
15:21:35 <lambdabot>  [1,2,3]
15:21:37 <arkeet> oh.
15:21:42 <arkeet> nm Dual isn't the thing.
15:21:54 <arkeet> > sortBy (comparing Down) [2,3,1]
15:21:55 <lambdabot>  [3,2,1]
15:22:04 <quchen> Dual is the flipped monoid I think.
15:22:08 <mauris_> you're thinking of Down
15:22:09 <arkeet> yes.
15:22:13 <mauris_> whoops. yeah
15:22:14 <joneshf-laptop> @browse Data.Ord
15:22:14 <lambdabot> Unknown command, try @list
15:22:14 <arkeet> so yeah, sortBy (comparing (Down . foo)) is an alternative.
15:22:31 <joneshf-laptop>  /MSG lambdabot @list Data.Ord
15:22:35 <joneshf-laptop> em...
15:22:46 <arkeet> just look it up on the web
15:23:00 * joneshf-laptop is lazy :)
15:23:07 * joneshf-laptop grumbles
15:23:14 <arkeet> > sortBy (comparing (Down . fst)) [(1, 2), (5, 6), (3, 4)]
15:23:15 <lambdabot>  [(5,6),(3,4),(1,2)]
15:23:45 <mauris_> let ascending = comparing; descending = comparing . Down
15:23:48 <mauris_> ^ this would be cool
15:23:54 <arkeet> heh
15:24:07 <mauris_> you could "sortBy (ascending length)" and stuff!
15:24:22 <joneshf-laptop> mauris_, quite!
15:24:29 <arkeet> cute
15:24:58 <OutlawStar> so I'm having trouble pattern matching in ghci, this [let (InvalidUrlException e a) = parseUrl "bob"] causes an error (which I can give if needed). Can someone tell me if I am doing something stupidly wrong there?
15:25:15 <arkeet> is [ ] part of the code?
15:25:22 <OutlawStar> no
15:25:43 <arkeet> yes, it would help if you posted the error along with some context for that code
15:26:09 <OutlawStar> interactive>:16:33:
15:26:09 <OutlawStar>     Couldn't match expected type ‘HttpException’
15:26:10 <OutlawStar>                 with actual type ‘m0 Request’
15:26:10 <OutlawStar>     In the expression: parseUrl "bob"
15:26:10 <OutlawStar>     In a pattern binding: (InvalidUrlException e a) = parseUrl "bob"
15:26:10 <OutlawStar> Prelude Network.HTTP.Client> let (InvalidUrlException e Request) = parseUrl "bob"
15:26:16 <arkeet> uh
15:26:21 <arkeet> @paste -- use this next time
15:26:21 <lambdabot> Haskell pastebin: http://lpaste.net/
15:26:29 <OutlawStar> :) sry
15:26:46 <arkeet> parseUrl is from http-conduit or something?
15:27:09 <OutlawStar> its from http-client
15:27:18 <geekosaur> you can't pattern match exceptions
15:27:26 <OutlawStar> oh?
15:27:26 <geekosaur> they're exceptions, not data
15:27:28 <joneshf-laptop> mauris_, you sould pr that
15:27:34 <OutlawStar> https://hackage.haskell.org/package/http-client-0.2.1.1/docs/Network-HTTP-Client.html#t:Request
15:27:37 <geekosaur> you must use catch or handle
15:27:46 <mauris_> pr?
15:27:47 <joneshf-laptop> or whatever the way to do that is for base
15:28:01 <joneshf-laptop> raise an issue?
15:28:12 <joneshf-laptop> i dunno for the workflow is for base
15:28:26 <haasn> mauris_: I don't think that combinator is worth the name
15:28:29 <joneshf-laptop> s/for/what/
15:28:36 <haasn> s/combinator/function/
15:28:45 <balor> I used unsafePerformIO and now feel dirty
15:28:53 <mauris_> yeah, it seems a bit silly to actually implement after "combining" already exists
15:28:57 <mauris_> uhh, comparing
15:28:59 <haasn> mauris_: “ascending” gains you nothing over “comparing”, and “descending = comparing . Down” gains you little over “comparing . Down”
15:29:20 <haasn> sortBy (comparing length) makes more sense to me than sortBy (ascending length), also
15:29:40 <arkeet> sortOn :: Ord b => (a -> b) -> [a] -> [a] would be nice.
15:29:59 <mauris_> to me the ascending/descending ones are way more "obvious", i guess in a spreadsheet kind of way
15:30:15 <OutlawStar> hmm so when i see this signature "parseUrl :: Failure HttpException m => String -> m Request". It means i need to catch exception, but to get the value I just pattern matching on ie IO Request?
15:30:24 <mauris_> but it doesn't seem to be in the haskell spirit to just add a bunch of synonyms for functions to base, so it'd be weird
15:30:27 <mauris_> (if this were ruby...)
15:30:27 <haasn> I just mean that “sort by comparing length” reads like an english sentence, but “sort by ascending length” does not
15:30:38 <arkeet> :t \f -> map snd . sortBy (comparing fst) . map (f &&& id)
15:30:39 <lambdabot> Ord a => (a1 -> a) -> [a1] -> [a1]
15:30:49 <arkeet> :t \f -> sortBy (comparing f)
15:30:51 <lambdabot> Ord a => (b -> a) -> [b] -> [b]
15:30:57 <haasn> (unless you interpret ‘ascending’ in the sense of ‘to rise’ :p)
15:31:10 <haasn> or rather: to climb p
15:31:13 <shirt> what is currently considered the best library for parsing/managing command line arguments?
15:31:27 <arkeet> shirt: optparse-applicative is popular
15:31:28 <haasn> shirt: there are many alternatives. I think optparse-applicative is popular?
15:31:38 <arkeet> heh
15:31:47 <haasn> I also remember liking https://hackage.haskell.org/package/options
15:31:50 <joneshf-laptop> haasn, I assumed it would be interpreted in the context of `Ord a` or `Ordering`
15:31:57 <mauris_> haasn: hm, how *would* you say that in english, though, now i'm thinking
15:31:59 <dmj`> shirt: optparse-applicative?  ?
15:32:25 <mauris_> like, "sort by length in ascending order"? also sounds a bit off to me. i guess it is the "by" that does that
15:32:28 <shirt> arkeet, haasn, dmj`: thanks! looks like there is a consensus :)
15:32:32 <arkeet> heh
15:32:45 <haasn> mauris_: “sort (descending) by comparing lengths” sounds like what I would actually write
15:33:52 <mauris_> wow, sql does ORDER BY xxx DESC; elegant as always
15:34:25 <prophile> isn't there an SQLesque language extension for list comprehensions
15:34:32 <prophile> presumably it handles sorting by key
15:35:06 <haasn> mauris_: sortBy (flip compare `on` length)
15:39:06 <dmj`> haasn: so the flip makes it asc or desc?
15:39:51 <dmj`> > sortBy (flip compare `on` length) [[1,1],[1,1,1],[1]]
15:39:52 <lambdabot>  [[1,1,1],[1,1],[1]]
15:40:00 <dmj`> > sortBy (compare `on` length) [[1,1],[1,1,1],[1]]
15:40:02 <lambdabot>  [[1],[1,1],[1,1,1]]
15:40:10 <dmj`> such clever
15:40:31 <joneshf-laptop> yeah, I never know which way it's going to sort it
15:41:37 <joneshf-laptop> i'd rather naively believe that `ascending` will sort it in ascending order, and `descending` will sort it in descending order
15:42:40 <joneshf-laptop> in fact, might as well make that a thing on hackage
15:43:36 <dmj`> joneshf-laptop: it seems the default is ASC
15:43:52 <dmj`> joneshf-laptop: default meaning no flip
15:50:45 <dmj`> I have a question
15:51:31 <dmj`> Since cabal files only let you specify one library, Is it best practive to put all your test, benchmark, and application code in the same library, for a reasonably sized project
15:51:36 <dmj`> practice*
15:57:28 <dmj`> does anyone know what I'm talking about
16:01:04 <neuroserpens> Can anyone give me an example of how I can read a line that contains two values from stdin and read it as a tuple?
16:01:09 <d-snp> dmj`: http://hackage.haskell.org/package/hashable-1.1.2.2/hashable.cabal
16:01:32 <vasanth> hi i work in finance some of my friend (starl) said haskell is good in finance so want to know it my english is bad , my college uses erlang as my college circuilam 
16:01:34 <d-snp> neuroserpens: you'd need to parse it
16:01:44 <indiagreen> neuroserpens: if the line is in “(x, y)” format, then you can just use readLn
16:03:10 <neuroserpens> indiagreen: d-snp: "80.40 120.99" to (80.40, 120.99) as doubles for example 
16:03:51 <indiagreen> then I would've either used “[x, y] <- map read . words <$> getLine” if I need values themselves, or wrote “readTuple = do s <- words <$> getLine; case s of [x, y] -> (read x, read y); _ -> error "wrong number of values"”
16:04:02 <indiagreen> (replace “;” by newlines)
16:04:30 <neuroserpens> holy crap... I think I can use a list
16:06:44 <d-snp> neuroserpens:"words s" returns a list
16:09:25 * hackagebot gtk3-mac-integration 0.3.0.3 - Bindings for the Gtk/OS X integration library.  http://hackage.haskell.org/package/gtk3-mac-integration-0.3.0.3 (HamishMackenzie)
16:13:02 <exio4> > (\x -> case (Traversable.traverse readMaybe . words) x of Just [a,b] -> Just (a::Int,b) ; _ -> Nothing) "123 456"
16:13:03 <lambdabot>  Not in scope: ‘Traversable.traverse’
16:13:07 <exio4> > (\x -> case (traverse readMaybe . words) x of Just [a,b] -> Just (a::Int,b) ; _ -> Nothing) "123 456"
16:13:09 <lambdabot>  Just (123,456)
16:19:25 * hackagebot sorting 1.0.0 - Utils for sorting.  http://hackage.haskell.org/package/sorting-1.0.0 (joneshf)
16:19:27 * hackagebot sorting 1.0.0.1 - Utils for sorting.  http://hackage.haskell.org/package/sorting-1.0.0.1 (joneshf)
16:20:31 <dmj`> d-snp: what is this
16:29:31 <mgsloan> edwardk / carter: Y'all around?
16:29:51 <carter> kinda busy
16:30:08 <carter> mgsloan: i think we agreed that the goals were valid,
16:30:11 <mgsloan> alright, no worries! (I want to discuss the exception stuff, but it can wait)
16:30:36 <carter> but that the design proposed raises some smell alarms in the course of servicing those goals
16:30:41 <mgsloan> Yup!  It seems like there's no set of tradeoffs which are palatable to everyone
16:30:45 <carter> well
16:30:54 <mgsloan> Agreed, I wasn't 100% happy with it myself
16:31:14 <carter> the biggest issue is its one of those areas of base where anything less than a validating patch actually is underspecified
16:31:25 <mgsloan> To me, it's worth it since *most* of the time things would just work out
16:31:31 <carter> ...
16:31:36 <carter> thats not a good enough bar for base
16:32:25 <carter> mgsloan: fyi... you CAN write a custom exceptions abstraction in userland
16:32:35 <carter> and test it out there
16:32:56 <mgsloan> True.  So the alternatives I see are: 1) a layer atop Control.Exception, which would opt in to providing / receiving stack traces 2) Breaking backwards compatibility 3) Doing something clever and hacky that's not yet figured out
16:34:09 <carter> as much as i like cool new things
16:34:12 <mgsloan> So I will probably try out writing such a layer, and also try out the patch to base
16:34:17 <carter> yes
16:35:29 <carter> mgsloan: also try to patch error to attched the profiling way stack trace
16:35:38 <carter> its actually kinda confusing navigating that cycle
16:36:53 <carter> mgsloan: also, once you've mocked out a working representative patch
16:37:11 <carter> it'll be easy to fork the patch candidate to layout alternative designs
16:37:18 <mgsloan> One hacky solution I've considered is using stable ptrs to exceptions, so they can't be moved.  Then, we can associate info with them in a global map where the key is the pointer.  There's a crucial issue with this, though, which is that 'fromException' isn't guaranteed to merely be a cast.  So, usages of fromException would need to write down the pointer for the result value... Yuck!
16:37:26 <carter> no
16:37:29 <carter> no stable pointers
16:37:32 <mgsloan> :)
16:37:45 <carter> why woudl stable pointers help with anything
16:37:50 <carter> what problem would that solve
16:38:23 <mgsloan> It solves the rethrow problem, where we want to rethrow the exception without losing info
16:38:53 <carter> mgsloan: the fleshed out version of the api davean very loosely proposed would also allow that
16:39:00 <jmcarthur_> mgsloan: you don't need stable pointers for that. you can just use stable names
16:39:13 <carter> mgsloan: also
16:39:31 <carter> why can't you just have this "embeding" supported in the application / library layer?
16:39:45 <mgsloan> How does davean's api allow for that?  It only allows that if you catch the exception within a "WithStack" wrapper, right?
16:39:52 <jmcarthur_> despite my contribution to the idea, i don't care for it either. it's not very functional (not that exceptions are my favorite thing in the world anyway)
16:40:09 <carter> mgsloan: you have a throwWithAdditionalInfo
16:42:03 <mgsloan> Yeah, the issue is I want to transparently update all users of throw to include callstacks
16:42:48 <carter> mgsloan: ohh
16:42:53 <bros> I currently have a slightly sizable web app written in Node.js. I'm interested in functional programming, so I've been reading about Haskell. The app's main purpose is to move data around from APIs, into databases, then to a client. I don't see where functional programming would benefit me at all here.
16:43:05 <carter> you missed the part where he was saying the internal value is no longer SomeException
16:43:12 <bros> If anything, I feel it'd get in my way and slow me done due to its cumbersome syntax, coupled with its "math first" stigma
16:43:20 <carter> but rather (ExtraStuff,CallStack,SomeException)
16:43:23 <bros> I'd love to be proven wrong/lead in the right direction/taught though.
16:43:36 <mgsloan> carter: Right, which is pretty much the same as my proposal
16:43:45 <mgsloan> So, there is no material difference between them
16:43:54 <carter> code is for humans
16:43:56 <carter> not for machiens
16:44:11 <johnw> bros: your database, data, and client, all participate in a common "model"
16:44:21 <johnw> Haskell's types will help verify that all parties adhere to the same model
16:44:26 * hackagebot scalpel 0.2.0 - A high level web scraping library for Haskell.  http://hackage.haskell.org/package/scalpel-0.2.0 (fimad)
16:44:45 <carter> mgsloan: i'm still trying to understand when you wanna do the catch + rethrow + embed the info case
16:45:07 <carter> where you cant amend the the specific userland exception to contain it
16:45:49 <carter> mgsloan: i guess my point, and to a less extent eds, was that while theres 2-3 new call stack notions in flight to be merged into ghc, its a bit premmeture to redesign the exception data type
16:45:53 <jmcarthur_> bros: this sounds like a pretty typical application to me, and typical applications are basically the bread and butter of functional programming. i know it's not helpful for me to just say these things without presenting evidence, but functional programming would allow me to write the thing faster, be more confident that it will work, and know i will be able to maintain or change it without the kind of fear
16:45:55 <jmcarthur_> i would have in an imperative language.
16:46:24 <carter> hehe, the best code is the code that works even after you've forgotten how you wrote it
16:46:33 <bros> jmcarthur_, I totally see how a strong emphasis on types could lead to that, which is why I am interested in the language.
16:46:36 <jgcoded> anybody here solved the mars lander 1 problem on codingame? I'm thinking about solving it using monads as a state machine and such. What did you use to solve it?
16:46:41 <mgsloan> carter: Hmm, I pretty much always want to have the original callstack of the exception.  The rethrown callstacks are handy too, and should be there, but the original callstack is usually the interesting one.
16:46:41 <jmcarthur_> bros: and yeah, i claim that functional programming is better suited for quick iteration, not less
16:46:47 <jmcarthur_> *not worse
16:46:54 <bros> Would it be OK if I wrote a small node.js function and got explained how it would break down into Haskell?
16:47:26 <mgsloan> carter: Yeah, I can understand being tentative due to such things being unresolved.  This is why I want a rather open mechanism, so that such details don't need to be resolved before allowing exceptions to have more info
16:47:32 <jmcarthur_> bros: it would be okay, but be warned that such exercises are often super misleading. perhaps that function would not exist in a haskell implementation of the full application anyway.
16:47:51 <jmcarthur_> bros: entire applications are much better examples for comparison
16:47:58 <jmcarthur_> bros: but of course they are much more work to demonstrate...
16:48:10 <carter> mgsloan: the difference with the style davean suggested is that we dont have to change ANY current ocd
16:48:19 <carter> so any changes exposed that way could be marked unstable
16:48:38 <bros> jmcarthur_, I see. I'll broaden the scope of my question then. 
16:48:44 <mgsloan> Well, we don't have to change any current code, but we also do have to change library code whenever we want callstacks from that library
16:49:16 <mgsloan> I want to rely on being able to get callstacks, at least of some variety, when compiled with (-prof or -g)
16:50:29 <jmcarthur_> brb
16:50:52 <srhb> bros: One other misconception that you might have based on what you wrote is about syntax. Haskell has one of the ligtest syntax burdens of any language I know. :)
16:51:36 <bros> srhb, I just don't see how that is true compared to say... JavaScript or C. I feel stupid for thinking the syntax of C was all I'd need to know as a programmer. It's... too simple compared to all of these flying arrows and colons.
16:51:50 <johnw> Haskell has far less syntax than C
16:52:05 <johnw> most of what looks like syntax in Haskell is really just operator functions defined in some libraries
16:52:32 <johnw> or maybe, the amount of syntax is on par with C; but not more
16:52:34 <srhb> We like short names for things we use often. >>= and <$> for example..
16:53:49 <bros>   return $ decodeEither $ responseBody res What does the dollar sign mean here?
16:53:51 <bros> both times?
16:53:59 <srhb> Function application
16:54:06 <johnw> it's low-precedence function application
16:54:08 <jmcarthur_> bros: even if i had to write nothing but imperative style code for the rest of my life, i'd prefer to do it with haskell syntax instead of javascript or c
16:54:22 <srhb> bros It's equivalent to return (decodeEither (responseBody res))
16:54:40 <jmcarthur_> bros: the dollar sign is not necessary to the code, is what's important. the author just wanted to use it
16:55:15 <srhb> @src ($)
16:55:15 <lambdabot> f $ x = f x
16:55:21 <srhb> No magic :-)
16:55:25 <bros> https://gist.github.com/brandonros/ba9a37842313c75c2cbc What kind of mess would this become in Haskell?
16:55:28 <jmcarthur_> my preference would be to write something like   pure . decodeEither . responseBody   and not mention res at all
16:55:56 <jmcarthur_> bros: well, first of all, in haskell we wouldn't need anything like deferred at all
16:56:10 <bros> This excites me.
16:56:18 <jmcarthur_> bros: haskell threads are super lightweight, so you can just spawn them all over the place
16:56:31 <jmcarthur_> bros: or use higher level libraries for concurrency if you wish, but they are all thread backed
16:57:14 <bros> You see how 85% of the code is simply variables, simple logic, small network requests, minor data manipulation, and error handlong, yes?
16:57:16 <jmcarthur_> bros: another observation: good haskell style is to use the right data structure for the job. you'd use typed records instead of dictionaries, etc.
16:57:48 <jmcarthur_> bros: if anything this code further validates to me that haskell would work well
16:58:21 <jmcarthur_> bros: it looks pretty verbose to me, lots of boilerplatey for loops and junk
16:59:06 <bros> It's 445 lines of code. In haskell, it would probably be around what? (Bad metric, I know. just curious)
17:00:28 <srhb> You could translate it directly to "imperative Haskell" if you're feeling very bad.
17:00:34 <srhb> And you'd get around the same number of lines.
17:00:46 <jmcarthur_> bros: well, this particular code sample i think *especially* favors haskell... as in more than average... i also haven't exactly studied the code, but i estimate in the most handwavy stupid fashion that it could be done in <150 lines of haskell, plus about 15 lines of module imports.
17:01:06 <bros> I was thinking about the same number as well. Hmm...
17:01:21 <srhb> But yeah, what jmcarthur_said. It'b be less in proper Haskell.
17:02:17 <srhb> bros: http://snapframework.com/docs/tutorials/snap-api -- this is a small hello world in the Snap Framework. It should be fairly legible.
17:02:52 <bros> srhb, what is <|> ?
17:03:17 <srhb> bros: Consider it a form of "or" for now
17:03:21 <jmcarthur_> bros: it's an operloaded operator that usually means some sort of choice or concatenation
17:03:36 <jmcarthur_> *overloaded
17:04:09 <jgcoded> this video shows an example that uses it
17:04:10 <jgcoded> https://www.youtube.com/watch?v=r_Enynu_TV0
17:04:33 <bros> srhb, jmcarthur_ this is a bit offtopic but it will point me further down what to do with Haskell. Would you guys ever choose a WebSocket based API/backend over an HTTP/RESTful/AJAX one?
17:04:46 <srhb> bros: Probably.
17:04:55 <srhb> But yes, I don't see the relevance. :)
17:05:27 <bros> It's that all Haskell web frameworks seem to be geared towards traditional HTTP routing
17:05:40 <jmcarthur_> bros: i can't say i never would, but i really like plain ol' HTTP/REST
17:05:59 <jmcarthur_> bros: honestly, my preference is to not care about the backend
17:06:12 <jmcarthur_> bros: but if i'm going to have to care, it's going to be whatever is easiest for me :)
17:06:13 <srhb> bros: It's because everything is so pluggable. Every framework could easily be equipped with websockets
17:06:37 <srhb> bros: Framework often means a lot less in Haskell because everything can be mixed and matched more easily.
17:06:46 <bros> jmcarthur_, don't care about it in the sense that you wouldn't be writing the code to handle connections/messages?
17:07:02 <jmcarthur_> bros: what i mean is i'd rather the interface i'm presented with just let me write my business logic and not worry about such low level details
17:07:08 <jmcarthur_> yeah, that's what i mean
17:07:37 <jmcarthur_> bros: with nice little escape hatches here and there for those rare moments when i do care, of course
17:07:47 <bros> escape hatches?
17:08:55 <jmcarthur_> bros: i'm just pointing out the unremarkable fact that no matter how awesome a high level interface is, you will eventually find something you want to do that just needs to peel back some layers of abstraction.
17:09:08 <jmcarthur_> bros: a lot of haskell libraries do this pretty elegantly
17:09:20 <jmcarthur_> bros: even the standard libraries allow you to get pretty low level, if you want
17:10:14 <jmcarthur_> bros: e.g. Ints are boxed. but i can work with unboxed ints as well, with reasonable restrictions. i can even work with C pointers and raw memory buffers
17:10:19 <HaskellStudent81> why doesn't this work? I get "parse error on input `where'" http://lpaste.net/131530
17:10:56 <bros> I want to get a minimal WebSocket server up and running in Haskell so I can see what it would be like responding to requests. What library would I use for this?
17:11:18 <c_wraith> HaskellStudent81: the where needs to be indented so that it's clearly a continuation of the previous line
17:11:20 <jmcarthur_> hmm... i've never worked with websockets
17:11:25 <bros> https://hackage.haskell.org/package/websockets ?
17:11:41 <bros> jmcarthur_, there must be a reason a professional like you hasn't work with websockets... It makes me nervous that I wrote my entire app to use them. :/
17:11:54 <jmcarthur_> bros: mainly because i'm not really a web dev
17:12:01 <bros> How else do you do sub-20ms messages, instant push notifications, etc.?
17:12:01 <ansible1> HaskellStudent81: because indention...
17:12:03 <bros> Ah, that might be what it is.
17:12:05 <jmcarthur_> bros: i'm a systemsy guy
17:12:10 <jmcarthur_> profesionally, at least
17:12:13 <bros> jmcarthur_, what kind of stuff are you more familiar with?
17:12:57 <HaskellStudent81> c_wraith: does it need to be part of the previous line? I thought where had a scope over the whole function, why does it need to be part of the previous line?
17:12:59 <jmcarthur_> bros: at work i use ocaml to write large global distributed systems with high reliability and low latency. i'd rather use haskell, but i can't complain about ocaml :)
17:13:23 <bros> jmcarthur_, what do those systems do?
17:13:31 <jmcarthur_> bros: these are mostly "backend" systems. the only UI i'm really responsible for are command line interfaces and some curses stuff
17:13:39 <Rotaerk> ocaml where art thou
17:13:50 <jmcarthur_> bros: i work for a proprietary trading company
17:13:55 <c_wraith> HaskellStudent81: where clauses are part of a binding - top-level, in a let expression, or in a case expression.
17:15:29 <HaskellStudent81> c_wraith: if I indent the where I get "not in scope: a"
17:16:07 <c_wraith> HaskellStudent81: that's because it's not in scope, because it's a typo.  There are other typos, too.
17:16:20 <HaskellStudent81> c_wraith: I think I can do this without a actually, but I'm trying to understand why what I tried to do doesnt work
17:16:46 <c_wraith> HaskellStudent81: oh, I see what you're trying to do
17:17:24 <c_wraith> HaskellStudent81: I have no idea why it says 'a' isn't in scope.  update the paste with your new code
17:17:31 <travgmon> can someone help me understand why I am getting a parse error on input c? http://lpaste.net/1474521045049278464
17:17:53 <bros> jmcarthur_, https://raw.githubusercontent.com/jaspervdj/websockets/master/example/server.lhs versus https://gist.github.com/brandonros/9da88eaf89050da16c53
17:18:13 <johnw> travgmon: you are missing "then" and "else" in the right places
17:18:15 <c_wraith> travgmon: because it's not aligned properly.  It needs to be aligned with the first non-whitespace token after the do, not with the do itself
17:19:18 <travgmon> Ah I see, thanks!
17:19:21 <HaskellStudent81> c_wraith: http://lpaste.net/131531  when I indent I think the where becomes part of the scope of the if, but if I don't I get error on input where
17:21:04 <c_wraith> HaskellStudent81: I'd indent more like http://lpaste.net/131532 ...  It still has some errors, but a should be in scope
17:21:19 <c_wraith> HaskellStudent81: *oh*.  the problem is line 3
17:21:21 <jmcarthur_> bros: i know nothing about the library, but jaspervdj writes pretty quality stuff as i understand it
17:21:41 <c_wraith> HaskellStudent81: where clauses only attach to a *single* binding.  The function is multiple bindings
17:22:03 <jmcarthur_> bros: jaspervdj is also in here, as are many authors of good libraries :)
17:22:17 <c_wraith> HaskellStudent81: a where clause can attach to multiple guards, but not multiple bindings
17:22:32 <bros> I understand pretty much everything except for the main case. the _, |, ', \, $, ->, T, and ` are all totally unknown to me.
17:23:26 <jmcarthur_> bros: | \ -> and ` are syntax. _ ' $ T are valid parts of identifiers, so it depends on the library.
17:23:51 <saulzar> bros, I've started using that library for a small game.. seems to work well so far, though I'm not dealing with a million clients or anything like that
17:23:53 <jmcarthur_> bros: technically all the symbols in the first groups are also valid parts of identifiers, but i'm guessing they are appearing on their own
17:24:08 <jmcarthur_> bros: well, ` isn't a valid part of an identifier, i guess
17:24:44 <bros> What does mappend do?
17:24:48 <Rotaerk> huh.  \ looks like a yen symbol to me
17:24:54 <Rotaerk> recently changed my IRC font...
17:24:59 <chpatrick1> is there any sense in a category where the objects are natural transformations?
17:25:05 <chpatrick1> total CT noob here btw
17:25:18 <jmcarthur_> bros: think of mappend as being like <|> with a slightly different kind of type...
17:25:30 <jmcarthur_> bros: it's also overloaded
17:25:33 <bros> lol, come on, how can you say this compares to C? :/
17:25:34 <saulzar> > mappend [1,2,3] [4, 5, 6]
17:25:35 <lambdabot>  [1,2,3,4,5,6]
17:25:41 <chpatrick1> just thinking about how Control.Applicative.Free.runAp is a "natural transformation transformation"
17:25:49 <jmcarthur_> bros: basically, mappend should always be an associative binary operation with some associated identity
17:25:50 <chpatrick1> and you could compose them
17:25:58 <arkeet> mappend for Text just concatenates text.
17:26:14 <HaskellStudent81> c_wraith: is there a way to make it work with the variable a, or is this an incorrect use of a local variable? I understand I could do without it, and that would be better, but I'm curious if it's possible to do it with the variable a
17:26:31 <arkeet> \ is lambda
17:26:45 <arkeet> -> has a few different meanings (function type arrow, part of lambda syntax, part of case syntax)
17:26:48 <jmcarthur_> bros: well if you want more precise answers you will need to just learn some of the language first. it seems that you lack the vocabulary for me to give great answers to these questions
17:26:57 <c_wraith> HaskellStudent81: I think you're trying to use it as an accumulator? That doesn't work. Bindings aren't mutable.
17:27:07 <jmcarthur_> bros: also the real meaning of mappend is context dependent, so i just can't answer it for you
17:27:30 <c_wraith> HaskellStudent81: If you want to write the function to use an accumulator, you need to pass it along as another argument to the function.
17:27:30 <arkeet> _ is a wildcard pattern, ' is just a letter, $ is function application (with a low precedence, it could just use parentheses instead)
17:27:42 <bros> jmcarthur_, what should I read to learn the language?
17:27:47 <arkeet> @where learnhaskell
17:27:47 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:27:50 <bros> Learn You A Haskell is shite, in my opinion
17:28:00 <jmcarthur_> i'm not a huge fan of learn you a haskell either
17:28:13 <arkeet> have a look at this thing
17:28:39 <c_wraith> HaskellStudent81: and of course, in haskell, just using a parameter as an accumulator typically performs really badly due to lazines...
17:29:19 <jmcarthur_> i learned largely from http://ais.informatik.uni-freiburg.de/teaching/ws06/info1/material/haskell-tutorial.pdf in my early days, but it's been so long that i can't promise it's the best out there
17:29:47 <arkeet> oh this thing
17:29:49 <jmcarthur_> it's written straightforwardly, unlike LYAH, but it's kind of dense relatively. it's also really old now
17:29:50 <arkeet> it's ancient lol
17:30:00 <jmcarthur_> arkeet: doesn't mean it's bad!
17:30:08 <arkeet> well no
17:30:25 <jmcarthur_> it's only a year younger than haskell 98
17:30:33 <HaskellStudent81> c_wraith: ok, thank you
17:31:17 <arkeet> bros: anyway, the learnhaskell thing lists a bunch of material
17:31:28 <arkeet> and the recommended starting point is this https://www.seas.upenn.edu/~cis194/spring13/lectures.html
17:31:32 <arkeet> it has exercises!
17:36:10 <slack1256> Uh, I need to do some hydraulic simulations. Any package that would help me?
17:37:32 <saml_> how can I get [1,3,5,...]   given [1,2,3,4,5,...]  filter only odd indexed elements
17:37:42 <bros> jmcarthur_, if you had to estimate, how long would you say it would take a beginner to be able to grasp these concepts? 
17:38:04 <mniip> saml_, filter odd
17:38:16 <saml_> > filter odd "abc"
17:38:17 <lambdabot>      No instance for (Integral Char) arising from a use of ‘odd’
17:38:17 <lambdabot>      In the first argument of ‘filter’, namely ‘odd’
17:38:17 <lambdabot>      In the expression: filter odd "abc"
17:38:17 <chpatrick1> mniip: odd indices
17:38:19 <mniip> hold on, odd-indexed or odd elements?
17:38:26 <aphorisme> I'm searching for a somewhat "forgetful functor"  @forget :: (p1 c a) -> (p2 c)@ is there a typeclass for such a thing? And: is it possible to have typeclasses for pairs of types?
17:38:30 <mniip> your example is a poor one then
17:38:41 <saml_> you rich
17:39:05 <slack1256> saml_: filter (\(i,_) -> i `mod` 3 || i == 1) zip [1..] [9..]
17:39:33 <saml_> that's pythonic
17:39:51 <slack1256> > filter (\(i,_) -> i `mod` 3 || i == 1) $ zip [1..] ['a'..]
17:39:52 <lambdabot>      No instance for (Integral Bool) arising from a use of ‘mod’
17:39:53 <lambdabot>      In the first argument of ‘(||)’, namely ‘i `mod` 3’
17:39:53 <lambdabot>      In the expression: i `mod` 3 || i == 1
17:40:13 <slack1256> > filter (\(i,_) -> i `mod` 3 == 0 || i == 1) $ zip [1..] ['a'..]
17:40:14 <lambdabot>  [(1,'a'),(3,'c'),(6,'f'),(9,'i'),(12,'l'),(15,'o'),(18,'r'),(21,'u'),(24,'x'...
17:40:19 <pavonia> > map snd . filter (odd . fst) . zip [1..] $ "abcdef"
17:40:20 <lambdabot>  "ace"
17:40:38 <slack1256> that is better
17:40:59 <slack1256> The idea is to make the indexes explicit on the list (because list don't really have indexes)
17:41:27 <jmcarthur_> bros: it certainly took me longer than most languages i'd learned up to then. it also depends on what definition of "grasp" you mean. haskell has a much, much higher skill ceiling than most languages, in the sense that no matter how much you have discovered, there's always more.
17:42:16 <jmcarthur_> bros: to be able to write a simple web server with database integration, etc., i'd say i could have done something not great within the first month
17:42:36 <h-core> so i'm trying to implement filter for the Data.CaseInsensitive CI data type and I'm not sure why I can't do it: http://lpaste.net/131533
17:43:04 <jmcarthur_> bros: i don't know if it's any different with the current landscape though. there are more web frameworks and such now than then
17:43:21 <bros> jmcarthur_, I don't like frameworks because instead of learning the language, I feel you learn the framework instead.
17:43:29 <bros> I'd rather have skills that can translate into different environments.
17:43:30 <jmcarthur_> bros: i agree!
17:43:37 <bros> I really appreciate all of your help.
17:43:49 <bros> I'll set a date on my calendar for May 26th to see if I could do what you described.
17:43:52 <jmcarthur_> bros: the haskell web "frameworks" are mostly collections of interchangeable modules at least
17:43:56 <h-core> im just not sure in this case why i'm expecting type a instead of CI a
17:44:00 <bros> Quick question. I don't think these tutorials are of any use.
17:44:04 <h-core> is it because f a
17:44:12 <bros> They're all "factorial, Fibonacci, recursion"
17:44:14 <jmcarthur_> bros: that's not a question ;)
17:44:21 <h-core> omg it is
17:44:33 <jmcarthur_> h-core: i'm talking to bros, sorry
17:44:41 <saml_> > let f (a:b:c:d) = a:c:f d; f (a:b:[]) = [a,b]; f a = a in f "abcdefghi"  -- i did it this way
17:44:42 <lambdabot>  "acdfgi"
17:44:43 <h-core> it's cool
17:44:53 <bros> jmcarthur_, I was curious if you felt similarly
17:45:03 <jmcarthur_> h-core: ah, i misunderstood what you said, in fact. disregard me
17:45:24 <h-core> lol i was going to say it's well within everyone's right to ignore any question they want :)
17:45:43 <jmcarthur_> bros: i do think it's unfortunate that there aren't so many real world examples in haskell tutorials. you can always look at Real World Haskell, though as with anything real-world, it's showing its age
17:45:57 <jmcarthur_> @where rwh
17:45:57 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
17:46:16 <bros> I should write my experiences as a beginner/intermediate C/node.js developer migrating to Haskell.
17:46:24 <bros> Give people the resources I can't find myself. :P
17:46:26 <jmcarthur_> bros: i think that's why i tend to recommend less real-world material... it just doesn't get outdated so quickly
17:46:27 <pavonia> h-core: f is supposed to work on values of type "a", i.e. any type, but "CI a" is more specific than that
17:46:52 <h-core> jmcarthur_, if you want a "real world" example of haskell look at anyone using Excel, that's an incredibly limited subset of functional programming that has tons of real world application
17:47:10 <jmcarthur_> h-core: eh... but it's so... un-haskell-like :)
17:47:26 <h-core> so the idea that an actual functional programming language with far more to it isn't usable in the real world is silly
17:47:34 <h-core> jmcarthur_, ohh i know :)
17:48:01 <slack1256> Excel is more about declarative programming than functional
17:48:18 <jmcarthur_> h-core: also, i don't think the goal here is to show that it's real-world applicable, but to find actual tutorials that are directly applicable to the real world in ways that fib and prime functions are just... not
17:48:19 <slack1256> but the two term and mangled together on the real world anyways
17:48:20 <h-core> slack1256, how so?
17:48:31 <h-core> jmcarthur_, this is true
17:49:03 <h-core> pavonia, yeah i noticed that finally lol, i needed (CI a -> Bool)
17:49:43 <slack1256> On excel you don't really use functions/composition as much as expressing interdependencies between cells/columns.
17:50:14 <jmcarthur_> for some reason it took me several tries over years to understand the mnemonic for the (~>) operator: http://matt.immute.net/content/pointless-fun
17:50:21 <jmcarthur_> now i don't know how i missed it
17:50:39 <jmcarthur_> i think the ($.) operator used in the article made it look more confusing to me
17:52:37 <h-core> jmcarthur_, heh i still have trouble with the (.) operator and often use it when i mean to use $
17:52:46 <jmcarthur_> @let f ~> g = (. f) . (g .)
17:52:47 <lambdabot>  Defined.
17:53:02 <slack1256> @type f
17:53:03 <lambdabot> FromExpr a => a
17:53:16 <slack1256> @type (~>)
17:53:17 <lambdabot> (a -> b) -> (b1 -> c) -> (b -> b1) -> a -> c
17:53:26 <slack1256> so, bifunctor?
17:53:32 <jmcarthur_> > sortBy ((length ~> length ~> id) compare) ["foo", "bar", "wibble", "blah"]
17:53:34 <lambdabot>      Couldn't match type ‘t0 a0’ with ‘Int’
17:53:34 <lambdabot>      Expected type: (t0 a0 -> Int) -> (Int -> t a) -> Ordering
17:53:34 <lambdabot>        Actual type: (Int -> t a) -> (Int -> t a) -> Ordering
17:53:36 <jmcarthur_> i stink
17:53:44 <jmcarthur_> will play in ghci first
17:53:55 <h-core> slack1256, that's true but I can compose functions with the results of other functions, of course i still don't understand compose even though i should because i know it's the result of one function feeding into another that accepts that result as its input
17:54:04 <h-core> err i mean in Excel i can
17:54:29 * hackagebot find-conduit 0.4.3 - A file-finding conduit that allows user control over traversals.  http://hackage.haskell.org/package/find-conduit-0.4.3 (JohnWiegley)
17:55:19 <jmcarthur_> oh, it's just that i didn't (can't) set the precedence for the operator in lambdabot
17:55:29 <jmcarthur_> @let infixr 2 ~>
17:55:30 <lambdabot>  Defined.
17:55:32 <jmcarthur_> aha!
17:55:36 <jmcarthur_> > sortBy ((length ~> length ~> id) compare) ["foo", "bar", "wibble", "blah"]
17:55:37 <lambdabot>  ["foo","bar","blah","wibble"]
17:56:38 <shachaf> Seems like (~>) should be dimap?
17:56:41 <jmcarthur_> slack1256: the idea is that each of those functions is applied to the corresponding position in the type of compare, in that example
17:57:13 <shachaf> Seems like a funny use of it.
17:57:20 <jmcarthur_> foo ~> bar ~> id    works on things with types of the form   A -> B -> C  where foo :: A -> _, bar :: B -> _, and id :: C -> _
17:58:16 <jmcarthur_> well, id :: C -> C, of course
17:58:37 <shachaf> p A (p B C) for any profunctor p. But dimap f id = lmap f
17:58:39 <jmcarthur_> my explanation is a failure
17:58:50 <shachaf> Maybe it's not a useful generalization.
18:00:38 <pavonia> :t length ~> length ~> id
18:00:39 <lambdabot> (Foldable t, Foldable t1) => (Int -> Int -> c) -> t a -> t1 a1 -> c
18:02:33 <jmcarthur_> :t \f -> f ~> id
18:02:34 <lambdabot> (a -> b) -> (b -> c) -> a -> c
18:02:36 <jmcarthur_> :t \f -> id ~> f
18:02:37 <lambdabot> (b1 -> c) -> (b -> b1) -> b -> c
18:03:52 <jgcoded> :t a ~> b
18:03:53 <lambdabot>     Couldn't match expected type ‘a -> b’ with actual type ‘Expr’
18:03:53 <lambdabot>     In the first argument of ‘(~>)’, namely ‘a’
18:03:53 <lambdabot>     In the expression: (a ~> b)
18:04:19 <jgcoded> :t Expr
18:04:21 <lambdabot>     Not in scope: data constructor ‘Expr’
18:04:21 <lambdabot>     Perhaps you meant variable ‘expr’ (imported from Debug.SimpleReflect)
18:04:28 <jgcoded> :t expr
18:04:29 <lambdabot> Expr -> Expr
18:04:51 <jgcoded> :t (expr -> expr) ~> (expr -> expr)
18:04:52 <lambdabot>     Pattern syntax in expression context: expr -> expr
18:04:53 <lambdabot>     Pattern syntax in expression context: expr -> expr
18:05:25 <jmcarthur_> jgcoded: maybe a private session with lambdabot until you get it worked out?
18:05:33 <exio4> (~>) looks really cool :P
18:05:42 <jgcoded> what is ~> called?
18:05:49 <slack1256> @type dimap
18:05:50 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
18:06:17 <jmcarthur_> (~>) is just some unnamed operator which happened to be the same as dimap
18:06:22 <jmcarthur_> :)
18:06:40 <exio4> being able to generalize it to any category also looks really cool
18:06:48 <jmcarthur_> yup!
18:08:07 <shachaf> Generalize it to any category?
18:08:24 <jmcarthur_> shachaf: if you use (Category..)
18:08:37 <shachaf> You mean by composing arrows from that category on both sides?
18:08:41 <jmcarthur_> yes
18:08:50 <shachaf> I guess that's another generalization.
18:10:04 <lpaste> chpatrick pasted “Category of natural transformations” at http://lpaste.net/131536
18:14:55 <jmcarthur_> chpatrick1: http://lpaste.net/131536  i annotated it with a version not requiring unsafeCoerce (though i stripped out stuff using libraries i didn't feel like looking up the docs on)
18:15:16 <jmcarthur_> chpatrick1: perhaps your representation was chosen for the parts i stripped out though
18:16:26 <chpatrick1> jmcarthur: isn't that the category of functors?
18:17:42 <chpatrick1> this is one level up
18:18:09 <shachaf> unsafeCoerce Refl?
18:18:10 <shachaf> good value
18:18:57 <bros> jmcarthur_, do you prefer NoSQL or SQL databases?
18:19:09 <shachaf> I must have missed some context on why that's necessary.
18:19:30 <chpatrick1> shachaf: I'm trying to pattern match on a type-level tuple
18:19:54 <chpatrick1> but I'm guessing haskell doesn't know that anything of kind ( k, k ) is equal to some ( t1, t2 )
18:19:58 <chpatrick1> so I need to unsafecoerce it
18:20:12 <shachaf> chpatrick1: That's because it's not true. :-(
18:21:00 <chpatrick1> shachaf: not for any t1, t2 but for some, surely?
18:21:28 <shachaf> Any :: (k, k)
18:22:04 <chpatrick1> sorry?
18:22:34 <chpatrick1> my problem is that haskell says I want NatM a a
18:22:45 <chpatrick1> and I say I can do NatM '( f, g ) '( f, g )
18:22:47 <shachaf> The type Any has kind (k,k)
18:23:00 <chpatrick1> and haskell says but I don't know a is '( f, g )
18:23:06 <chpatrick1> even thought it is
18:25:15 <shachaf> It isn't necessarily.
18:25:49 <chpatrick1> hmm, I see
18:26:09 <chpatrick1> that's annoying
18:26:17 <shachaf> Yep.
18:26:27 <shachaf> It really restricts the sorts of things you can do with Category, for instance.
18:27:49 <chpatrick1> even if there wasn't Any, Haskell still couldn't deconstruct ( k, k ) for you
18:27:55 <chpatrick1> just because it has one constructor
18:28:24 <chpatrick1> and I think in this case it's safe since the only way you could make a NatM Any or something would be with unsafeCoerce somewhere else
18:28:30 <chpatrick1> in which case you're asking for it :)
18:29:29 <jmcarthur_> chpatrick1: how about this?  http://lpaste.net/131536
18:30:47 <jmcarthur_> i haven't tried anything with it. there may be something wrong
18:32:01 <jmcarthur_> lol this is totally different
18:32:40 <chpatrick1> I thought partially applying type families was not kosher
18:34:12 <shirt> I need to make a value of type  (Conduit ByteString IO (Flush Builder))  What I want to do is find the first occurrence of the string "foo" and replace it with the string "foobar". Any pointers would be appreciated
18:34:16 <jmcarthur_> chpatrick1: i don't actually know what i was trying to do there. i don't even know how it compiles now
18:34:40 <chpatrick1> good night guys
18:40:39 <RyanGlScott> I have a generics-related question.
18:41:02 <RyanGlScott> When you derive a Generic instance for, say, data ADT = ADT Int a (ADT a), each field is represented by a K1 term.
18:41:19 <RyanGlScott> How can you distinguish each field?
18:42:23 <RyanGlScott> I want to do one action for occurrences of the type parameter, another instance for other types, and another action for recursive occurrences of the data type.
18:43:05 <jmcarthur_> bros: ah sorry i missed your question. though it's off topic, i'd say i would choose a SQL database over some NoSQL thing, but mainly because i trust postgresql a lot more than "random database whose core philosphy seems to be to make ORMs easier"
18:44:09 <jmcarthur_> bros: but the decision would really just have to depend on the application
18:52:41 <lpaste> chpatrick revised “Category of natural transformations”: “No title” at http://lpaste.net/131536
19:12:18 <nocturne777> I've been studying the "Cont" and it does not seem awfully useful to me
19:12:39 <fragamus> it sure iweird
19:12:48 <fragamus> *is*
19:13:33 <jmcarthur_> nocturne777: here's one way to use it: http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
19:13:35 <nocturne777> it just makes the code appear kind of imperative.  and callCC can act like a go-to statement
19:13:53 <jmcarthur_> nocturne777: in the linked article, callCC isn't even used!
19:13:59 <simpson> ContT IO still blows my mind. It's so clever.
19:14:07 <simpson> Definitely read that blog post.
19:14:43 <nocturne777> I also came across this: http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
19:14:52 <nocturne777> besides the one on wikibook
19:14:57 <geekosaur> that last is disputed btw
19:15:11 <geekosaur> but yes, it's kinda hard to show real use cases for Cont / ContT
19:15:52 <geekosaur> because the cases where it comes in useful all tend to be large and complex, and if you simplify them down enough to make good examples you usually end up removing the need for Cont
19:16:32 <nocturne777> geekosaur: I was going to say that pretty much anything can be achieved without the use of Cont
19:16:59 <saulzar> Usually for things like co-routines etc. though libraries like Pipes are probably more convenient in most ways
19:16:59 <nocturne777> and the code would still look clean I think
19:17:52 <nocturne777> I think CPS is more relevant in languages where evaluation is strict by default
19:18:38 <jmcarthur_> Cont is a fine way to remove some deep indentation, at worst
19:18:59 <jmcarthur_> and a way to get some crazy control operations at best
19:59:34 * hackagebot test-sandbox 0.1.4 - Sandbox for system tests  http://hackage.haskell.org/package/test-sandbox-0.1.4 (junjihashimoto)
20:05:50 <travgmon> using connectTo from Network it shows it returns an IO handle, is there a way to test against it?
20:06:36 <geekosaur> it throws an exception if it fails
20:08:07 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/base-4.6.0.1/Control-Exception.html 
20:09:06 <travgmon> thanks geekosaur
20:27:24 <jle`> ContT IO is really the only useful Cont i've used in the real world
20:27:42 <jle`> i can't imagine Cont or ContT m for any other monad being too useful
20:27:48 <jle`> but admittedly my imagination isn't the best
20:36:21 <mniip> jle`, IO is the only thing you can use in RealWorld
20:38:02 <Hafydd> Heh.
20:38:07 <verement> I've used ContT to good effect with STM
20:38:31 <jle`> oh i guess that makes sense too
20:38:41 <jle`> i can see that
20:41:17 <subleq> I'm looking at the use of modifyMVar here: http://jaspervdj.be/websockets/example.html. The docs for modifyMVar says "This function is only atomic if there are no other producers for this MVar.". Isn't each thread in that example a producer for the MVar and therefore it's unsafe?
20:42:43 <subleq> Oh, I think I understand. Multiple threads can atomically use modifyMVar as long as none of them does a putMVar without a takeMVar first?
20:48:15 <subleq> I've never seen it this quiet in here
20:49:13 <biglambda> Haskell is over I think.
20:49:30 <biglambda> People just suddenly decided to all learn go.
20:49:37 * hackagebot memcache-haskell 0.0.10.1 - Memcache procotol library  http://hackage.haskell.org/package/memcache-haskell-0.0.10.1 (junjihashimoto)
20:49:39 * hackagebot memcache-conduit 0.0.3 - Conduit library for memcache procotol  http://hackage.haskell.org/package/memcache-conduit-0.0.3 (junjihashimoto)
20:49:41 <biglambda> It's sad really.
20:49:45 <subleq> Oh, that makes sense. I hear scala is where it's at
20:49:49 <Hafydd> Ah, yes, I'm sure Go is a suitable replacement for Haskell.
20:49:51 <biglambda> Yeah
20:49:53 <subleq> And Go, good point
20:50:02 <biglambda> It just makes sense
20:50:11 <biglambda> I'm changing my username to biggo
20:50:52 <biglambda> Trying to install ghc-7.10 on an ubuntu machine tonight
20:50:57 <subleq> biggoroutine
20:50:57 <biglambda> kind of painful
20:51:16 <subleq> bigchannel
20:51:40 <nocturne777> go is not a good language
20:51:42 <biglambda> Does building and installing ghc create a new cabal database?
20:51:59 <nocturne777> it's a throwback to ancient times
20:52:06 <Zemyla> Why is there no default Monad instance for (,) w?
20:52:47 <rwiggins> Game of Thrones is on the loose! There's no time for IRC.
20:52:58 <subleq> I see :(
20:53:04 <subleq> Game of Thrones over MVars
20:54:04 <biglambda> I keep getting this error ghc: ghc no longer supports single-file style package databases 
20:54:28 <biglambda> When I try to install something using cabal
20:54:36 <biglambda> any package really
20:54:37 * hackagebot conversion-text 1.0.0.2 - "Conversion" instances for the "text" library  http://hackage.haskell.org/package/conversion-text-1.0.0.2 (NikitaVolkov)
20:54:41 <saulzar> I got that error when I was trying to install ghcjs
20:55:05 <saulzar> Before I updated cabal, unsure why but it disappeared
20:55:19 <saulzar> (with 7.10)
20:55:26 <biglambda> how did you update cabal exactly
20:56:05 <joneshf-laptop> Zemyla, how would you implement `return`?
20:56:27 <saulzar> cabal install cabal-install
20:56:29 <Zemyla> return a = (mempty, a)
20:57:02 <joneshf-laptop> Zemyla, yeah, you need a `Monoid` constraint
20:57:14 <Zemyla> Yes, but why is it not defined in the Prelude?
20:57:56 <biglambda> saulzar: Yes I even get the error when I do that :)
20:58:08 <saulzar> I guess that could be problematic :)
20:58:41 <saulzar> I had a working ghc-7.8.4 which I was using to build it
20:59:03 <Zemyla> instance (Monoid w) => Monad ((,) w) where { return a = (mempty, a); (w, a) >>= f = case f a of (w', b) -> (mappend w w', b); (w, _) >> (w', a) = (mappend w w', a) }
20:59:13 <Zemyla> That should be defined either in Prelude or Data.Monoid.
20:59:19 <joneshf-laptop> Zemyla, oh, it breaks laws
20:59:45 <Zemyla> No it doesn't. It's one of the most basic law-abiding monads ever.
20:59:52 <biglambda> saulzar: Yes I made the mistake of installing 7.6.3 first
21:00:07 <biglambda> Now I'm paying the price
21:00:12 <joneshf-laptop> Zemyla, it doesn't?
21:00:31 <Zemyla> Nope.
21:00:51 <arkeet> joneshf-laptop: it's the standard Writer monad
21:01:04 <arkeet> and I dunno why that instance isn't in the prelude either
21:01:15 <Andromeda_> Hi all, just going through LYAH and am currently doing the section on functors and applicative functors, I can't seem to find a name for the operators <$> and <*> - can anyone tell me what to call them when I'm reading the code in my head?
21:02:31 <Andromeda__> hmm, I seem to have been disconnected
21:03:42 <saulzar> <*> = ap
21:04:09 <arkeet> at best the thing I say in my head on those is "uhh"
21:04:17 <byorgey> Andromeda__: <$> = fmap
21:04:59 <saulzar> I just think function application when I see  f <$> arg1 <*> arg2 <*> arg3
21:10:06 <nurupo> is there a short way to sort [(Integer, Integer, Integer, Integer)] by 1st, then 2nd, then 3rd and then 4th quadruple's elements?
21:10:54 <kadoban> nurupo: Isn't that the default thing sort does?
21:11:04 <nurupo> is it?
21:11:11 <kadoban> I think so.
21:11:48 <opqdonut> > sort [(1,2,3),(2,1,3),(2,0,4),(3,0,0)]
21:11:49 <lambdabot>  [(1,2,3),(2,0,4),(2,1,3),(3,0,0)]
21:11:50 <nurupo> > sort $ [(4, 3, 2, 1), (1, 2, 3, 4), (2, 3, 4, 1), (2, 3, 1, 4)]
21:11:52 <lambdabot>  [(1,2,3,4),(2,3,1,4),(2,3,4,1),(4,3,2,1)]
21:12:11 <nurupo> looks like it
21:12:43 <nurupo> didn't work in your case though
21:12:50 <nurupo> oh, nevermind
21:15:59 <subleq> Nobody knows about my question about modifyMVar atomicity?
21:21:01 <mniip> subleq, modifyMVar is takeMVar then putMVar
21:21:06 <mniip> it can't really be unatomic
21:22:45 <saulzar> subleq, Yeah I think that's right
21:24:07 <saulzar> subleq, https://groups.google.com/forum/#!topic/haskell-cafe/3Zq3CyZhQbo
21:24:49 <saulzar> So they're just using takeMVar, putMVar  ... which is fine as long all accesses uses the same pattern
21:25:08 <saulzar> But if some thread calls putMVar in the middle it's going to bugger everything up
21:25:08 <jle`> this is in 2010 though.  i feel like i might ahve heard about some more recent developments?
21:27:04 <subleq> "These only have atomicity guarantees if all other threads perform a 'takeMVar' before a 'putMVar' as well;  otherwise, they may block."
21:27:07 <subleq> got it
21:27:19 <saulzar> Yeah..
21:34:50 <shirt> how do i block a thread forever?
21:37:00 <igniting> shirt: you do a takeMVar on an empty MVar. If that MVar remains empty forever, then the thread would be blocked forever
21:38:08 <subleq> shirt: newEmptyMVar >>= takeMVar (please don't listen to me, I don't know what I'm doing, I was only thinking about MVars)
21:38:22 <mniip> subleq, that throws an exception
21:38:34 <mniip> you need the MVar shared with some other thread
21:38:53 <subleq> mniip: see, the runtime can tell it will never not be empty?
21:38:58 <subleq> s/see/I see/
21:39:01 <mechanical-eleph> so, random question: I was just reading up on typeclasses and found the Alternative instance for list, which sets <|> = (++)      …annnd that doesn’t make any sense to me.  Can anyone explain?  I mean I know what it does, but I’d expect [1,2,3] <|> [4,5,6] to be [1,2,3], not [1,2,3,4,5,6]
21:39:03 <igniting> yes, in this case compiler is able to figure out
21:39:17 <mniip> subleq, it can see no threads have a reference to it
21:39:28 <igniting> oops, the runtime
21:39:38 * hackagebot hpack 0.1.0 - An alternative format for Haskell packages  http://hackage.haskell.org/package/hpack-0.1.0 (SimonHengel)
21:47:53 <mauke> :t forever (threadDelay maxBound)
21:47:54 <lambdabot> Not in scope: ‘threadDelay’
21:56:21 <solrize> bleh i'm trying to cabal install something, it downloads a pile of packages and compiles files one by one slowly, til it hits a missing dependency and stops. i find the missing thing and install it, then run cabal again, and it starts compiling again from the beginning.  is there a way to get it to save .o's between runs?
22:01:40 <joneshf-laptop> does anyone else find lhs a pain in the ass?
22:02:47 <gfixler> lhs?
22:07:27 <friden> left-hand-side?
22:07:35 <enthropy> literate haskell probably
22:08:04 * enthropy doesn't use it, it doesn't play nicely with adjusting indentation with the >
22:09:49 <joneshf-laptop> yeah literate haskell
22:10:04 <joneshf-laptop> did one module in bird style
22:10:08 <joneshf-laptop> and anoher with latex
22:10:14 <joneshf-laptop> pain for either
22:11:08 <peddie> joneshf-laptop: I always found it pretty nice in latex mode, but that was with a lot of help from emacs
22:14:40 * hackagebot hpack 0.1.1 - An alternative format for Haskell packages  http://hackage.haskell.org/package/hpack-0.1.1 (SimonHengel)
22:14:51 <johnw> sm_: hpack looks pretty nice
22:19:29 <arkeet> cool
22:19:44 <arkeet> might give hpack a try for my next thing maybe
22:53:00 <yan4138> ?
22:54:06 <saulzar> Good question
23:02:03 <farrioth> Hi. I don't know much about Haskell yet, but I have a question about typechecking and typecasting. It's slightly long (114 words) so I've pastebinned it here: http://jandal.sdf.org/b/13538
23:03:24 <Bynbo7> "probably" is my answer as far as I understand the qyestion
23:04:04 <shachaf> farrioth: That's just a syntactic thing about Python.
23:04:09 <Axman6> s/y/u
23:04:35 <shachaf> I don't think it's directly comparable.
23:04:41 <farrioth> Axman6: Okay. Are there parts of the question I should clarify?
23:04:54 <shachaf> I can imagine translations of that into Haskell that would and wouldn't be type errors, but the translation is up to you.
23:06:31 <farrioth> shachaf: So `operand operator operand operator operand' isn't valid in Haskell where both operators are infix comparison operators?
23:06:48 <shachaf> It's not in the Python sense.
23:06:56 <shachaf> But this is really a very Python-specific thing.
23:08:59 <farrioth> shachaf: I understand that it's not a shorthand for foo C1 bar && bar C2 baz or so, but presumably such an expression with multiple comparison operators in syntactically valid?
23:10:01 <shachaf> "a OP1 b OP2 c" is either "(a OP1 b) OP2 c" or "a OP1 (b OP2 c)" or an error, depending on how the fixity of the operators was declared.
23:10:23 <igniting> > True > True > True
23:10:25 <lambdabot>      Precedence parsing error
23:10:25 <lambdabot>          cannot mix ‘>’ [infix 4] and ‘>’ [infix 4] in the same infix expression
23:10:45 <igniting> > True > (True > True)
23:10:46 <lambdabot>  True
23:11:13 <ollef> however
23:11:17 <ollef> > 1 > (2 > 3)
23:11:18 <lambdabot>      No instance for (Num Bool) arising from the literal ‘1’
23:11:18 <lambdabot>      In the first argument of ‘(>)’, namely ‘1’
23:11:18 <lambdabot>      In the expression: 1 > (2 > 3)
23:12:56 <farrioth> shachaf: Mmm, that's what I would expect. And presumably I'm not allowed to either test for string inclusion in a boolean or inequality of a boolean and an integer?
23:13:49 <igniting> farrioth: You can define your own functions to do that with proper types.
23:14:08 <igniting> :t (==)
23:14:09 <lambdabot> Eq a => a -> a -> Bool
23:14:30 <igniting> the default equality operator can only compare values of same types
23:15:16 <farrioth> igniting: My point is that I want to not be allowed to do that because the said expression I wrote in Python was an error but the Python interpreter happily accepted it.
23:15:48 <farrioth> igniting: Hence why I turn to Haskell as a language which I understand hase stricter typing.
23:16:09 <arkeet> :t let eq a b = cast a == Just b in eq
23:16:10 <lambdabot> (Eq b, Typeable a, Typeable b) => a -> b -> Bool
23:16:20 <nshepperd> I thought 'foo < bar < baz' *was* desugared to 'foo < bar && bar < baz' in python
23:16:34 <farrioth> igniting: But I think your comment about the default equality operator has answered my question.
23:16:52 <farrioth> nshepperd: Yes, it is.
23:21:03 <Cale> farrioth: Yeah, usually comparison operators in Haskell are defined such that their arguments must be the same type.
23:21:06 <Cale> :t (<)
23:21:07 <lambdabot> Ord a => a -> a -> Bool
23:21:55 <nurupo> > cycle "cycle"
23:21:57 <lambdabot>  "cyclecyclecyclecyclecyclecyclecyclecyclecyclecyclecyclecyclecyclecyclecycle...
23:22:12 <farrioth> Cale: Okay, great.
23:22:42 <Cale> farrioth: Here, the type variable 'a' must be an instance of the Ord type class, and whichever type it stands for must be consistently chosen for both arguments.
23:22:45 <farrioth> Thanks everyone.
23:22:48 <nshepperd> > ((True < True) < True, True < (True < True))
23:22:49 <lambdabot>  (True,False)
23:24:09 <farrioth> I think the discussion of Python's sugar in my question may have been confusing.
23:24:42 * hackagebot step-function 0.1.0.0 - Step functions, staircase functions or piecewise constant functions  http://hackage.haskell.org/package/step-function-0.1.0.0 (petterb)
23:31:22 <farrioth> Well, a test tells me that Haskell would pick up the error :)
23:39:43 * hackagebot cabal-src 0.2.5.1 - Alternative install procedure to avoid the diamond dependency issue.  http://hackage.haskell.org/package/cabal-src-0.2.5.1 (MichaelSnoyman)
23:49:32 <jle`> welp finally installing 7.10
23:53:21 <verement> jle`: I've been enjoying your blog. Thanks for writing in depth in such clear language.
23:55:23 <jle`> verement: thanks :) it's my pleasure!
23:55:32 <jle`> glad you have been able to gain something from it
23:58:08 * echo-area searches
