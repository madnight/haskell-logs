00:02:32 <ane> what broke it?
00:03:04 <d3dave> its incompatible with Cabal > 1.18
00:03:24 <ane> oh yes, that's right, but i just downgraded cabal
00:03:35 <d3dave> yea, same
00:04:12 <ane> actually it's incompatible with cabal(-install) 1.20.0.6
00:04:22 <ane> above that, i mean
00:04:36 <ane> i'm not familiar with what 1.22 has 1.20 doesn't have
00:40:24 * hackagebot dynamic-graph 0.1.0.6 - Draw and update graphs in real time with OpenGL  http://hackage.haskell.org/package/dynamic-graph-0.1.0.6 (adamwalker)
01:25:28 * hackagebot base-compat 0.7.0 - A compatibility layer for base  http://hackage.haskell.org/package/base-compat-0.7.0 (SimonHengel)
01:35:28 * hackagebot hPushover 0.2 - Pushover.net API functions  http://hackage.haskell.org/package/hPushover-0.2 (WJWH)
01:36:59 <maple> I'm sorry to keep bothering the channel, but I'm still struggling with installing haskell on this machine. I hope you don't mind if I link the issue I opened on github: https://github.com/haskell/cabal/issues/2526
01:37:19 <marchdown> Are there any projects that could use more contributors? Alternatively, is anybody willing to walk me through contributing to an oss project?
01:39:06 <predator117> maple: cabal configure does not work because you need `Cabal` as a dependency, you can install all dependencies with `cabal install --dependencies-only`
01:39:29 <maple> predator117: thanks, trying in a sec
01:58:51 <maple> predator117: ok sorry, I'm back. So i tried going slow and manually. This is a clean install of the 32 bit platform on win8.1. I ran cabal fetch cabal-install
01:59:09 <maple> then I unpacked Cabal and I'm running cabal configure on Cabal
01:59:18 <maple> and it hangs already
02:01:43 <maple> it got stuck at .\dist\setup\setup.exe configure --verbose=3 (plus a ton of other options)
02:01:51 <maple> (mainly constraints)
02:02:47 <lpaste> d3dave pasted “shift list” at http://lpaste.net/130239
02:02:56 <d3dave> which version is better?
02:03:38 <maple> d3dave: clearly the first, as it's less clear :)
02:05:30 * hackagebot auto 0.4.1.0 - Denotative, locally stateful programming DSL & platform  http://hackage.haskell.org/package/auto-0.4.1.0 (jle)
02:07:09 <maple> screw this, I'm going back to python I guess
02:08:22 <d3dave> maple: >screw this, I'm going back to js
02:53:55 <indiagreen> marchdown: the Hackage server is both important and lacking active developers at the same time, you could choose it if it's in your area of interest
03:08:32 <rabisg> indiagreen: this one right? https://github.com/haskell/hackage-server 
03:09:56 <indiagreen> yes
03:20:03 <merijn> See also #hackage
03:20:39 <merijn> Both cabal and hackage are mostly maintained by a handful of people, all of whom have fulltime jobs, so help is always welcome and if you ask they've got plenty of pointers on where you could start
03:26:57 <nshepperd> oh sweet, ghc 7.10 is in archlinux repos already
03:27:17 <nshepperd> I guess I should brace for breakage
03:28:21 <merijn> You mean, the ritual cleansing of infidel packages that don't appreciate the latest and greatest? ;)
03:29:28 <nshepperd> hehe
03:29:59 <nshepperd> just so
03:31:27 <rabisg> merijn: I will check #hackage. Thanks for the pointer
03:32:23 <merijn> rabisg: It might take a while (read: hours/potentially a day) before you get a respone
03:33:15 <rabisg> hmm. np
03:39:38 <jellie> I have this small xml document that I'm trying to parse with the xml package. http://ix.io/hkN
03:40:24 <jellie> Now how can I isolate the info under `<pod title="Result" .../>`
03:41:17 <jellie> I want to get <plaintext>...</plaintext> under  <pod title="Result" .../>
03:48:25 <phaul> hi, I'm having trouble defining a class where a method has a type constraint (here IsString) but otherwise free type variable. For example is it possible to do sg like this: class Show a where show :: (IsString b) => s -> b? 
03:49:05 <phaul> After the definition I can't define instances for it.. As it cannot deduce the concrete type from IsString
03:49:05 <merijn> phaul: Sure
03:49:18 <pavonia> phaul: show has to mention 'a' in the type
03:49:24 <merijn> oh
03:49:41 <merijn> Yeah, you probably want "show :: IsString b => a -> b"
03:49:47 <merijn> (or "class Show s")
03:51:46 <phaul> hm. I write up a snipet on lpaste, that demonstrates what I'm trying... 1 sec..
03:53:34 <benneh> quick style question: which is preferable, "h =<< fmap (g . f) a" or "h . g . f =<< a"?
03:54:24 <pavonia> :t (=<<)
03:54:25 <lambdabot> Monad m => (a -> m b) -> m a -> m b
03:54:30 <alynn> I would say the latter
03:54:30 <bergmark> benneh: =<< fmap is a code smell to me
03:55:21 <jle`> i do the latter all the time
03:55:26 <nshepperd> hmm. it would be cool to have some sort of buildbot that would build things against various versions of other packages, and thereby bump the dependencies automatically
03:55:30 <narendraj9> How can I prove that pure (flip ($)) <*> x <*> pure f is the same as pure ($) <*> pure f <*> x using the Applicative laws? I understand why it should be so.
03:55:56 <bergmark> nshepperd: hvr has been working on some stuff for that https://ghc.haskell.org/~hvr/buildreports/0INDEX.html
03:56:01 <nshepperd> 'compiles with no type errors' is not as strong as 'is compatible' but maybe it would be saner than blanket --allow-newer
03:56:12 <merijn> bergmark: The latter
03:56:21 <merijn> s/bergmark/benneh
03:57:25 <merijn> narendraj9: Equational reasoning, i.e. by expanding out the implementation of flip and using the fact that pure has no effects
03:57:43 <narendraj9> @src flip
03:57:44 <lambdabot> flip f x y = f y x
03:58:10 <merijn> narendraj9: I'm guessing this is more of a "how do I prove these sorts of things" question then you wondering about this specific example?
03:58:10 <nshepperd> bergmark: oh neat
03:58:41 <narendraj9> merijn: pure (\x y -> $ y x) <*> x <*> pure f
03:58:44 <nshepperd> bergmark: i see, this is compatibility vs ghc
03:58:54 <narendraj9> merijn: Yes, I haven't proved these sort of things.
03:59:11 <narendraj9> merijn: What now?
03:59:20 <benneh> alright, that was simple enough; thanks for the help folks
03:59:25 <merijn> narendraj9: Right, then I know the (free!) book for you :)
03:59:27 <phaul> merijn: ok, this is weird :) Now my example typechecks. nm
03:59:28 <merijn> @where sf
03:59:28 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
03:59:28 <lambdabot> assistant."
03:59:59 <bergmark> nshepperd: right, but a lot of other dependency problems also pop up because of it :-)
04:00:22 <narendraj9> merijn: Okay. Thanks for the book. But help me go through this specific problem please.
04:00:24 <merijn> narendraj9: That book is an intro to Coq and theorem proving that starts with proving properties of simple pure functions (i.e. "reverse (reverse xs) == xs") and gradually becomes more complex and looking at imperative programs
04:00:42 <bergmark> nshepperd: it also ensures that a simple "cabal install foo" works, which is the most important thing
04:00:47 <narendraj9> merijn: Okay. I am downloading the book now.
04:00:52 <merijn> narendraj9: I'd have to grab the remaining Applicative laws to see how to proceed
04:01:57 <merijn> narendraj9: If we assume the Applicative instance is lawful we have the following laws: 1) Identity "pure id <*> v = v"
04:02:13 <narendraj9> merijn: Yes. 
04:02:29 <narendraj9> merijn: And pure f <*> pure x = pure (f x)
04:02:33 <merijn> 2) homomorphism "pure f <*> pure x = pure (f x)" 3) interchange "u <*> pure y = pure ($ y) <*> u" 4) composition "u <*> (v <*> w) = pure (.) <*> u <*> v <*> w"
04:02:56 <narendraj9> merijn: Yes.
04:02:58 <merijn> narendraj9: So it looks like the question your asking is actually a prerequisite of Applicative
04:03:17 <merijn> narendraj9: Which means that you have to prove for a specific instance that it holds
04:03:28 <narendraj9> merijn: No, it is not. It's a question from typeclassopedia.
04:03:54 <narendraj9> merijn: Assuming that the applicative laws hold, we have to prove this. It's a different formulation of the interchange law.
04:04:11 <shachaf> It's slightly tricky but I think it's a good exercise to figure out for yourself. :-)
04:04:22 <merijn> narendraj9: Right, but my point is you can't prove that in general using only the properties of Applicative
04:04:23 <narendraj9> As we have an effectful function rather than the object.
04:04:28 <shachaf> Sure you can.
04:04:38 <merijn> narendraj9: To prove interchange we need to pick a specific implementation of <*> and pure
04:04:42 <narendraj9> shachaf: Okay. Am I on the right track?
04:04:50 <shachaf> I don't know. Which track are you on?
04:05:03 <merijn> shachaf: Proving interchange using the Applicative laws would be a tautology
04:05:16 <shachaf> OK, but this isn't any of the usual laws.
04:05:18 <merijn> As it's a prerequisite of being an applicative
04:05:29 <shachaf> All of maths is a tautology.
04:05:30 <merijn> shachaf: These are the laws from typeclassopedia
04:05:50 <shachaf> I don't know what problem you're talking about at this point.
04:05:57 <narendraj9> SCHAAP137: I need to prove that pure (flip ($)) <*> x <*> pure f is equal to pure ($) <*> pure f <*> x. Then after that it's all easy.
04:06:04 <narendraj9> shachaf: ^^^
04:06:12 <narendraj9> Sorry SCHAAP137.
04:06:27 <shachaf> Yes.
04:06:40 <narendraj9> shachaf: So, what I don't understand is how I would prove this. How I do make the things exchange their positions.
04:06:41 <shachaf> That's not any of the Applicative laws, so I don't see the objection. It's a reasonable exercise.
04:07:04 <narendraj9> shachaf: I am not saying that the exercise is not reasonable.
04:07:09 <shachaf> merijn is.
04:07:31 <elvinz> Hi, I am very new to Haskell... I try to do basic IO, this is my Main.hs file: http://pastebin.com/A1k4mz0Q . The output to the screen works, but the output to the file (commented main) leaves an empty file output.txt on my disk, why ?
04:07:39 <shachaf> Anyway, you'd start with one of the two things, and you'd use the Applicative laws that you know about to manipulate it.
04:08:13 <narendraj9> shachaf: Okay. Will give it another try. :)
04:08:35 <narendraj9> shachaf: It seems to me that I am good at proving things. 
04:08:49 <narendraj9> shachaf: *not good :-D
04:08:53 <merijn> elvinz: Printing does output something sensible?
04:09:02 <elvinz> yes
04:09:03 <shachaf> Then you'd better practice!
04:09:13 <merijn> narendraj9: Better than being too good at proving things and being able to prove false things ;)
04:09:21 <elvinz> merijn, I create a matrix object that I can see on the screen
04:09:35 <merijn> elvinz: Which OS? (Specifically: Is this windows?)
04:09:51 <elvinz> merijn, yes, Windows indeed
04:09:51 <narendraj9> merijn: Yeah. :-D
04:10:04 <shachaf> narendraj9: I don't know that what you said is the easiest way to go about it.
04:10:07 <narendraj9> shachaf: Any books that you would suggest? Apart from sf?
04:10:11 <shachaf> Best to start with the original exercise.
04:10:31 <merijn> elvinz: My (completely unfounded!) gut says: Maybe some confusion due to text output to binary file or something along those lines
04:10:32 <shachaf> I haven't read SF so I can't recommend it. I don't know. Any mathematics book?
04:10:44 <narendraj9> shachaf: Okay. You mean I should start over again? 
04:10:59 <shachaf> What you're trying to prove is "pure f <*> x = pure (flip ($)) <*> x <*> pure f"
04:11:01 <narendraj9> shachaf: The flip removal isn't a good idea?
04:11:09 <merijn> ah, no, openFile is text already
04:11:16 <narendraj9> shachaf: yes.
04:11:19 <elvinz> merijn, ok I will look after then
04:11:31 <shachaf> It might be a good idea, I don't know. Does it help you? If it helps you it's a good idea.
04:11:37 <phaul> I think I still managed to reproduce the problem I'm facing : http://lpaste.net/130240
04:11:38 <narendraj9> shachaf: Sure. Any mathematics book would also be fine.
04:12:14 <shachaf> Looking at the two sides of that equation, the right side is much more complicated, so it might be easier to start with the right side and show that it's equal to the left side.
04:12:38 <phaul> Can someone point out what wrong with that paste? (Thanks in advance)
04:13:44 <merijn> phaul: Your class claims the function can return ANY enum, but your implementation ALWAYS returns (), which is not right at all
04:14:10 <narendraj9> shachaf: Yes, I started wit the right side of the equation. It is easy to see why this should be so, becuase x is the only thing with effects. But eventually I have to use some law to make x and (pure f) exchange their positions. I am stuck there.
04:14:20 <narendraj9> shachaf: Will start afresh. Thanks.
04:14:42 <merijn> phaul: Because that's basically "f :: Blah a => a -> ()", which is not the same as "f :: (Blah a, Enum b) => a -> b" (convert any Blah instance into any Enum instance)
04:15:04 <shachaf> Let me see.
04:15:15 <shachaf> narendraj9: I think the laws really guide you in this case.
04:15:55 <phaul> ok I expected this to be the other way around. I thought I can return any concrete type as long as its Enum
04:16:27 <elvinz> merijn, apparently my file is still opened in ghc after execution of main. Should I add something in my code to close it ? Maybe the file content is in a buffer, explaining why there is no content on disk ?
04:16:44 <arkeet> phaul: the caller gets to choose the type.
04:16:50 <arkeet> the implementation must work with any possible type.
04:16:53 <shachaf> Oops, they left.
04:16:59 <phaul> makes sense now
04:17:02 <phaul> thanks
04:18:23 <cYmen> Hi
04:18:57 <merijn> elvinz: Oh, this is in ghci?
04:19:08 <cYmen> I have a CookiesText which is a tuple of Data.Text.Internal.Text from which I would like to parse a list of ints. Is there a "read" alike for Text?
04:19:21 <shachaf> narendraj9: I went through the proof and it looks like if you start from the right side, there's really only one law you can plausibly use at any point.
04:19:23 <merijn> elvinz: Try calling "hFlush" (or whatever it's name was on the Handle
04:19:29 <elvinz> merijn, well I just tried by compiling it with ghc, but the problem remain
04:20:07 <narendraj9> shachaf: Okay. And I think that's the interchange law. :-D
04:20:15 <merijn> elvinz: When compiling and running the result buffers should be flushed when the program exits, so hFlush shouldn't help in that case....
04:20:21 <shachaf> E.g. start with "pure (flip ($)) <*> x <*> pure f". The only obvious thing to do is to use the interchange law to turn it into "pure ($ f) <*> (pure (flip ($)) <*> x)"
04:20:26 <merijn> cYmen: Parsec/attoparsec have parsers for Text
04:20:36 <shachaf> And so on.
04:21:04 <merijn> cYmen: Also, you can convert Text to String, depending on what you're doing. Attoparsec/parsec directly on text is probably faster than String, but if you're doing a one-off thing you might not care
04:21:37 <cYmen> Poke
04:22:24 <Clint> there's also Data.Text.Read
04:22:30 <Clint> or something like that
04:22:48 <narendraj9> shachaf: Okay. I must treat f as data. Okay. I see. Thanks.
04:24:52 <cYmen> IRC?
04:25:49 <cYmen_> hm...other irc client is bitchy :/
04:26:01 <Clint> @hoogle decimal
04:26:03 <lambdabot> Text.Parsec.Token decimal :: GenTokenParser s u m -> ParsecT s u m Integer
04:26:03 <lambdabot> Text.ParserCombinators.Parsec.Token decimal :: GenTokenParser s u m -> ParsecT s u m Integer
04:26:03 <lambdabot> Data.Text.Lazy.Read decimal :: Integral a => Reader a
04:27:31 <Athas> Which is the best Haskell indentation mode for Emacs?
04:28:16 <Taneb> haskell-indentation-mode
04:29:10 <Athas> It does not seem to be able to handle simple cases like a 'data' definition where the first constructor is on a separate line.
04:29:21 <Athas> It wants me to indent like this:
04:29:22 <Athas> data Foo =
04:29:22 <Athas>   Bar
04:29:24 <Athas>   | Baz
04:29:38 <merijn> Athas: I've started indenting like this
04:29:41 <narendraj9> shachaf: Okay. I have to apply the law twice it seems. Okay. Thanks. I must do this myself now.
04:29:41 <merijn> data Foo
04:29:45 <merijn>     = Bar
04:29:48 <merijn>     | Baz
04:29:54 <Athas> Yes, but that doesn't read as well to me.
04:29:56 <Taneb> Athas, I do this:
04:29:58 <Taneb> data Foo =
04:30:00 <Taneb>   Bar |
04:30:01 <Taneb>   Baz
04:30:18 <merijn> Athas: Clearly there's only one solution: GADT syntax everywhere ;)
04:30:30 <Athas> This is working around something I'm very surprised doesn't work.
04:32:03 <Taneb> Athas, how would you want it?
04:35:14 <Athas> Taneb:
04:35:14 <Athas> data Foo =
04:35:15 <Athas>     Bar
04:35:17 <Athas>   | Baz
04:44:54 <ane> Athas: try hi2
04:46:58 <Profpatsch> Okay, one thing I can’t get in my head is: When would I want to use Data.Semigroup.Min?
04:47:26 <Profpatsch> Instead of a simple min from Ord?
04:48:16 <Profpatsch> What is the use case other than “Min is a semigroup”? :)
04:51:44 <pacak> Profpatsch: It allows you to do typelevel stuff without having to choose specific function as an argument
04:53:16 <Profpatsch> Hm.
04:53:17 <Cale> Profpatsch: Maybe you have an algorithm which is designed to work using an arbitrary semigroup
04:54:17 <pacak> Something like "foldMap pure"
04:54:45 <Profpatsch> Ah!
04:54:51 <pacak> It can be more complicated. And having that you can later specify which exact monoid or semigroup you want to use
04:54:57 <Profpatsch> I can see a use case for that, yes.
04:55:12 <pacak> So you will be changing that pure without having to pass it
04:55:36 <Profpatsch> foldMap is over monoidal functors, right?
04:55:47 <pacak> :t foldMap
04:55:48 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
04:56:14 <pacak> Amd there's this instance: (Ord a, Bounded a) => Monoid (Min a)
04:56:43 <tsahyt> Is there any way I can use a wildcard in pattern matching a constructor? For instance I have this piece of code: http://lpaste.net/261289867370037248 and I'd rather just write something like intersect r (_ x) = intersect r x.
04:56:57 <merijn> tsahyt: No
04:57:12 <tsahyt> So is this the idiomatic way to do this?
04:57:34 <merijn> You could generate it via TH, but that might be more hassle than it's worth
04:57:42 <pacak> unsafeCoerce all the things!
04:57:48 <tsahyt> *shudders*
04:58:10 <merijn> tsahyt: Well, usually you would try avoid constructing OO-like hierarchies
05:00:14 <tsahyt> I'm not quite sure if this is even doable here. I'm literally dealing with objects. I've got several kinds of geometric objects that I want to render, i.e. use in ray tracing. They of course all have different properties but they all can be intersected by a ray and have surface normals. I'm not quite sure how else I'd model this.
05:01:26 <merijn> tsahyt: It's hard to give an example based on this tiny sample, but a similar "inheritance" scenario I've encountered where you have multiple Sockets exposing the same operation I implemented like "data Socket = Socket { readSocket :: IO ByteString; writeSocket :: ByteString -> IO () }" and then I would have "socketType1 :: IO Socket" and capture whatever internal state the socket has in closures
05:01:44 <pacak> tsahyt: toIntersectable :: Intersectabve a => Object -> a
05:04:02 <tsahyt> merijn: So I would carry what "kind" of object it is from a data type to a particular constructor? In your example you'd have for instance tcpSocket :: Port -> Socket or something like this to build a new value of type Socket?
05:04:03 <merijn> tsahyt: There's a lot of example haskell raytracers you could have a look at too
05:06:11 <merijn> tsahyt: I would have like "readTCP :: IORef TCPState -> Size -> IO ByteString" or whatever and then "tcpSocket = do { ref <- newIORef newTCPState; return (Socket { read = readTCP ref 1024, write = ... }) }"
05:06:56 <merijn> tsahyt: Which means all the state is captured by partially applying a specific "readTCP" function and the Socket object then only exposes the "common" type shared by all different types of sockets
05:07:46 <merijn> tsahyt: One benefit of this is that it becomes very easy for others to implement "custom" Sockets, that work with all existing code, since they don't have to integrate into some complex hierarchy, they just need to construct a few functions with the right type signature
05:08:17 <merijn> Wanna implement websockets? As long as you can produce "ByteString -> IO ()" and "IO ByteString", no problem!
05:08:36 <tsahyt> I see. It might be worth a try. I'm thinking that since intersecting and calculating normals is all that I want to do for now, I'd end up with something like data Surface = { intersect :: Ray -> [Float], normal :: Point -> V3 Float }.
05:08:50 <merijn> tsahyt: Right
05:09:14 <tsahyt> After more than a year of writing Haskell code I still don't know anything about how to *design* in a functional style.
05:09:26 <merijn> tsahyt: Have you read any Functional Pearls?
05:10:01 <merijn> Also, Bird's "Pearls of Functional Algorithm Design"
05:10:01 <tsahyt> A few. I didn't have time to really work into any though.
05:10:25 <tsahyt> I have Bird's book lying around and plan to read it during my summer vacation.
05:10:57 <merijn> I think just seeing a lot of examples of things you never would've thought of yourself it the only real way to improve and see "oh, that's how I can tackle things"
05:11:06 <merijn> Of course Okasaki is pretty neat too
05:12:02 <tsahyt> The thing is that I've implemented light falloff functions in almost the same way that you suggested for surfaces, but in this particular case it didn't occur to me. Might be that I'm still too used to OOP and that I'm too quick to introduce a type class.
05:12:55 <tsahyt> In particular my first thoughts are always about what data I have to encapsulate before I think about what properties a type should have.
05:14:34 <merijn> tsahyt: What data to encapsulate is still important, you just tend to encapsulate differently (i.e. closures over "inheritance")
05:19:03 <c_wraith> I think less about encapsulation and more about modeling.
05:19:32 <c_wraith> What data is necessary to make my application work?  How do I represent it so that I can efficiently perform the necessary operations on it?
05:20:25 <c_wraith> Classes almost never are part of the answer to those questions
05:20:58 <pacak> https://www.youtube.com/watch?v=hIZxTQP1ifo
05:21:02 <tsahyt> But I lose the ability to look into the defining data when I'm debugging, don't I? For instance, I had data Triangle = Triangle VF3 VF3 VF3, now I have triangle :: VF3 -> VF3 -> VF3 -> Surface. Before I was able to derive a Show instance. Now the data is hidden in the closure.
05:21:45 <pacak> Classes are cool.
05:22:16 <tsahyt> It seems that every time I get to implement one, it was the wrong choice.
05:30:43 * hackagebot wl-pprint-text 1.1.0.4 - A Wadler/Leijen Pretty Printer for Text values  http://hackage.haskell.org/package/wl-pprint-text-1.1.0.4 (IvanMiljenovic)
05:34:01 <lachenmayer> Hi, I'm using the Data.FileStore module to interact with a git repo - I'm trying to `retrieve`, update and then `save` a file (inside a single do block). When I do that, I get a "resource busy (file is locked)" error.
05:34:48 <lachenmayer> I've gathered that this has to do with lazy IO, ie. the file not being closed before saving. The FileStore API does not give me a handle to close the file though, is there any way to force this?
05:35:02 <lachenmayer> Or is there another solution altogether?
05:43:19 <nshepperd> lachenmayer: if it's to do with lazy IO, then fully evaluating the retrieved contents before updating it should make it work
05:43:48 <lachenmayer> I've been adding bangs left right and center, no dice so far :)
05:44:43 <nshepperd> eg. do { a <- retrieve ; deepseq a (return ()) ; save (modified a) }
05:44:56 <lachenmayer> Trying {-# LANGUAGE BangPatterns #-} right now, let's see if that helps
05:45:14 <lachenmayer> ah, I'll try that!
05:45:19 <Profpatsch> So I’ve got a binary format that has a field of size 5 bytes.
05:45:36 <Profpatsch> I wonder what would be a good type to represent that with.
05:45:55 <srhb> Profpatsch: Depends on what they mean, imo.
05:46:04 <Profpatsch> word32 is not enough, should I simply put it into a word64?
05:46:14 <Profpatsch> Or just parse it into an Int?
05:46:26 <nshepperd> lachenmayer: bang patterns only reduce the value to whnf, which doesn't necessarily fully evaluate eg. the whole string
05:47:13 <srhb> Profpatsch: Without further information, I'd just ByteString it.
05:47:28 <Profpatsch> srhb: It represents a price.
05:47:35 <CMCDragonkai> [Roger Qiu] is there a bang pattern analogue to deepSeq?
05:47:39 <nshepperd> however, it looks like the git store works by running git commands, rather than direct access
05:47:39 <Profpatsch> So kind of an Int.
05:47:42 <srhb> Profpatsch: So an always positive integer? Then I'd use an Integer type.
05:48:19 <nshepperd> so i'd be surprised if it's at all related to laziness
05:48:26 <Profpatsch> srhb: I guess. The Binary module just uses Words in the datatype, strict at that.
05:48:38 <srhb> Profpatsch: Word is an integer type, too. Use that. :)
05:48:48 <Profpatsch> Ah. :)
05:48:59 <Profpatsch> But there’s only Word64
05:49:06 <srhb> Which is fine.
05:49:23 <srhb> I mean, you have 40 bits.
05:49:34 <Profpatsch> Okay; the compiler aligns it anyway, right?
05:49:45 <srhb> Heck if I know.
05:50:03 <asthasr> Hi guys. I'm doing a "lunch and learn" for my workplace trying to justify/explain the use of monads (specifically, Maybe and Either). We work primarily in Java and Ruby, but you guys are the best people I know to ask this. I have thought of a "five cent definition" of monad and would like your opinion:
05:50:04 <Profpatsch> I’d think so, normally processors are faster with aligned data.
05:50:17 <Profpatsch> srhb: Another thing would be: Should I make the fields strict?
05:50:30 <asthasr> "A monadic type is a data type which encapsulates different behavior for different subsets of the type."
05:50:44 * hackagebot Win32-security 0.1.1 - Haskell bindings to a security-related functions of the Windows API  http://hackage.haskell.org/package/Win32-security-0.1.1 (anton_dessiatov)
05:51:18 <asthasr> this seems to encompass the behavior of Maybe and Either pretty well, but it doesn't capture IO and State (as I understand them), so it's incomplete.. but you'd never use IO and State in Java/Ruby anyway.
05:51:35 <nshepperd> Profpatsch: you could define your own Word40 type that uses Word64 for backing storage
05:52:03 <Profpatsch> nshepperd: Haha, nah, I think that’s overkill.
05:52:28 <Profpatsch> asthasr: I like to think of monads as magic boxes. :P
05:52:49 <Profpatsch> You chain stuff and they Do What You Want™
05:52:54 <nshepperd> or even a proper fixed point arithmetic type, assuming fixed point is indeed what you are doing here
05:53:00 <lachenmayer> asthasr: "Monads are a way of specifying side effects - where the side effect of "Maybe" is that a value might not exist, of "Either" that a value could have two distinct types, and of "List" that there could be multiple values., "IO" that it performs some IO actions, etc etc..."
05:53:18 <merijn> Monads are a way of specifying EFFECTS
05:53:23 <merijn> not SIDE-effects
05:53:49 <asthasr> that's what I was going for with the phrase "different behavior for different subsets"
05:53:52 <merijn> side-effects are things that happen implicitly/invisibly, the whole point is to make them explicit so you can reason about them
05:54:26 <lachenmayer> yes! minus side then :)
05:54:44 <asthasr> seems that "subsets" might be the wrong term
05:55:06 <CMCDragonkai> [Roger Qiu] monads are a general pattern for composing/chaining computations that are a bit more complicated than just function composition
05:55:11 <Profpatsch> merijn: In other languages the stuff that monads do is very explicit most of the time. Since you simply have to write it yourself.
05:55:13 * nshepperd https://xkcd.com/895/
05:55:17 <Profpatsch> Think parsec.
05:55:33 <asthasr> my motivation here really is to get people to use Maybe and Optional
05:55:48 <asthasr> I don't really care that much about State/IO, that's a broken pile of misery in Ruby/Java anyway
05:55:53 <Profpatsch> CMCDragonkai: Try to first teach Java/Ruby guys about function composition …
05:56:04 <asthasr> but I am tired of debugging NPEs
05:56:10 <Profpatsch> There are no first class functions anyway afaik
05:56:18 <CMCDragonkai> [Roger Qiu] well you should start with teaching composition first then!
05:56:19 <asthasr> Ruby has first class functions
05:56:28 <Profpatsch> asthasr: Ah, okay.
05:56:33 <nshepperd> the monadic interface to Maybe can just be considered a convenient way of composing partial functions
05:56:42 <lachenmayer> nshepperd: deepseq didn't work... I've also tried printing out the file contents before saving, that doesn't work either. There must be something else going on here...
05:56:54 <asthasr> The *syntax* for first class functions is painful, but it exists
05:57:05 <asthasr> doubler = ->(x) { x * 2 }
05:57:12 <asthasr> doubler.call(2)
05:57:12 <Profpatsch> I think for lots of programmers out there (.) is a deeply magical thing.
05:57:14 <asthasr> => 4
05:57:16 <Profpatsch> Thank Java for that.
05:57:38 <CMCDragonkai> [Roger Qiu] well you can just explain using pipes
05:58:05 <Profpatsch> asthasr: Yeah, but can you use them as args?
05:58:15 <asthasr> Sure. Ruby actually has special syntax for that, block notation
05:58:22 <asthasr> [1, 2, 3, 4, 5].map { |x| x * 2}
05:58:31 <asthasr> => [2, 4, 6, 8, 10]
06:00:44 * hackagebot tasty-silver 3.1.2 - Golden tests support for tasty. Fork of tasty-golden.  http://hackage.haskell.org/package/tasty-silver-3.1.2 (PhilippHausmann)
06:00:46 * hackagebot Rasterific 0.5.2 - A pure haskell drawing engine.  http://hackage.haskell.org/package/Rasterific-0.5.2 (VincentBerthoux)
06:01:24 <asthasr> You can also pass explicit "Proc objects" (i.e. functions) to another function or method, because they are just values, and of course Ruby is dynamically typed so you can pass them *anywhere!* Your program will probably fail, but you can do it.
06:02:46 <asthasr> Actually, for work, I wrote a validation framework that is essentially a way of specifying rules... the type would be something like Validator A = [(A -> Bool)] -> A -> Bool
06:05:57 * hackagebot svg-tree 0.1.1 - SVG file loader and serializer  http://hackage.haskell.org/package/svg-tree-0.1.1 (VincentBerthoux)
06:09:17 <asthasr> Oh, here's a question regarding that validator framework and haskell
06:09:53 <asthasr> I used that to sift members of a collection into "Very Bad (i.e. exceptional errors)", "No Good (i.e. normal, expected reasons for exclusions)", and "Good" records
06:10:11 <nkar`> andbroby: regarding the font: have you tried this one: https://github.com/i-tu/Hasklig?
06:10:35 <nkar`> andbroby: I haven't used it myself, but it does what you want, iiuc
06:10:39 <asthasr> how would that be modeled in haskell? what would be the best way to go about it?
06:23:49 <blackdog> hey all. i wrote something up about a problem i hit today, and a possible solution - would appreciate feedback http://www.shimweasel.com/2015/04/06/paranoid-testing-in-haskell/
06:28:17 <pacak> blackdog: We have a faily large codebase depending on a bunch of packages. Packages are allowed to come from either of two places - local ghc installation - ghc + base + a bunch of packages that we are going to use (this usually changes when we switch between ghc releases and it's cloned between dev/prod machines) and extsrc folder in the project itself - those packages are installed into a local sandbox. This helps to ensure reproduceable builds.
06:29:48 <blackdog> pacak: i can see how that would solve some problems :)
06:30:15 <blackdog> it would be nice to have a solutions for the general case, though
06:30:18 <blackdog> *solution
06:31:18 <blackdog> i suppose one incremental improvement could be to only run tests for libs that have changed
06:31:32 <blackdog> but you'd have to do that too - you're just doing it manually rather than relying on cabal freeze etc
06:32:14 <pacak> For the general case this solution should be centralized so running all the possible combinations of libraries happens only in one copy, not on all machines
06:33:22 <asthasr> A dumb question, maybe... but is there a more succinct way to map across a list [M a] than (for example) "map (\x -> x >>= return . (f x)) xs"
06:33:29 <asthasr> the nested bind seems... unfortunate
06:33:40 <Clint> asthasr: are you familiar with mapM
06:33:44 <blackdog> pacak: you would only be running the set of all tests before deploy on one machine anyway
06:33:46 <arkeet> :t map (\x -> x >>= return . (?f x)) ?xs
06:33:47 <lambdabot> (Monad m, ?f::m a -> a -> b, ?xs::[m a]) => [m b]
06:33:50 <srhb> Remind me, where does one canonically grab liftIO from?
06:33:59 <srhb> Control.Monad.IO.Class?
06:34:13 <arkeet> asthasr: what exactly do you want?
06:34:23 <asthasr> Clint: No, I haven't used it.
06:34:26 <arkeet> given a [m a], what is the type of the thing you want out of it?
06:34:35 <geekosaur> Control.Monad.Trans
06:34:40 <blackdog> pacak: not suggesting devs should be running it as a matter of course - you'd probably slot it into a CI workflow
06:34:42 <asthasr> another [m a]. "f" in the above would be a function (a -> a)
06:34:47 <pacak> blackdog: I mean globally across all hackage users - I'm testing just one combination of packages
06:34:48 <srhb> geekosaur: Thanks.
06:34:51 <arkeet> ok
06:34:56 <arkeet> :t map . fmap
06:34:57 <lambdabot> Functor f => (a -> b) -> [f a] -> [f b]
06:35:03 <arkeet> :t map (fmap ?f)
06:35:04 <lambdabot> (Functor f, ?f::a -> b) => [f a] -> [f b]
06:35:15 <blackdog> pacak: that only works for apps, though. they might be using a different combination of libraries to you.
06:35:25 <blackdog> i think it's optimising for the wrong thing too
06:35:58 <asthasr> ahh, thanks arkeet. I always forget fmap... joys of being a newbie.
06:36:21 <arkeet> np :)
06:36:59 <asthasr> and I'm only trying to justify maybe/either... trying to keep the haskell to a minimum (in terms of complex-looking things) to illustrate the behavior of the monadic types
06:40:39 <d34df00d> Hi!
06:41:00 <benma> hello!
06:41:20 <d34df00d> I'm trying to write a function like this (actually, just adapting http://stackoverflow.com/questions/5268156/how-do-you-do-an-in-place-quicksort-in-haskell to types other than plain Int lists):
06:41:23 <d34df00d> https://bpaste.net/show/07fee1d72d03
06:41:34 <d34df00d> But it doesn't typecheck:
06:41:37 <d34df00d> https://bpaste.net/show/15827931d13d
06:41:44 <d34df00d> How can this be solved?
06:43:34 <srhb> d34df00d: Are you using ScopedTypeVariables?
06:43:46 <d34df00d> srhb: nope, should I?
06:44:01 <srhb> If your a inside the body means to refer to the a in the function signature, yes.
06:44:06 <srhb> Otherwise a new a is allocated
06:44:14 <srhb> (Not sure that's the error, but that's certainly one thing.)
06:44:30 <d34df00d> Yes, that's exactly what I meant the inner "a" to refer.
06:44:55 <srhb> Right. And then you will need to use forall a. ... in the function signature to bring it into scope in the body
06:45:33 <d34df00d> srhb: awesome, it worked, thanks!
06:45:40 <srhb> Skimming for the win. You're welcome. :)
06:51:00 * hackagebot http-client 0.4.10 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.10 (MichaelSnoyman)
06:56:00 * hackagebot RefSerialize 0.3.1.4 - Write to and read from ByteStrings maintaining internal memory references  http://hackage.haskell.org/package/RefSerialize-0.3.1.4 (AlbertoCorona)
06:57:36 <LAC1213> I started a symbolic algebra project in haskell and I wonder if somebody is interested in this topic and would like to join me on a small and fun project
07:29:04 <ahg> I am attempting to install ghc 7.10 and cabal 1.22 on a debian machine that has never seen haskell before. ghc installed fine, but cabal is failing with missing dependencies (initially old-locale, then System.Locale). I've been manually adding packages according to the instructions at https://wiki.haskell.org/Cabal/How_to_install_a_Cabal_package, but even though "ghc-pkg list" shows current-locale, and in ghci I can import System.Locale, cabal's bootstr
07:29:04 <ahg> ap.sh is failing, saying "could not find module: System.Locale"
07:30:00 <ahg> Am I going about this wrong?
07:30:30 <ahg> Is there a guide I could be following to install 7.10 from scratch?
07:32:15 <dhrosa> ahg: are you using the debian repositories or just cabal?
07:33:26 <ahg> dhrosa: neither. I am avoiding the debian repos because they're on ghc 7.4, and I have been unable to install any version of cabal-install
07:34:26 <hjulle> Is there an easy way to unzip a ZipList?
07:34:30 <ahg> dhrosa: ghc-pkg list shows that Cabal-1.22.2.0 is available on my system, and I have used it to install several packages
07:34:40 <Lokathor> ahg, my advice would be to get either the unstable or experimental version of ghc and cabal-install
07:34:57 <Lokathor> and use those to compile the very latest versions from there
07:35:03 <Myrl> Good evening guys. I'm planning to use Haskell in GCJ. However, I'm bad in I/O and strings in general.
07:35:11 <sm> Lokathor: that seems bad advice
07:36:09 <Myrl> So, for each test case, I plan to make a list of lines, and for each problem, I plan to make a list of test cases.
07:36:23 <Lokathor> sm, possibly
07:36:45 <Myrl> So, the first thing I'll do is to use 'interact' and 'lines' together to create a list of lines. However, I don't even know something as simple as separating those lines by 5 elements.
07:37:17 <Myrl> TL;DR. How to separate a list of x into a list of list of x, by a constant?
07:37:34 <Myrl> Or more like restructure.
07:37:38 <sm> not I-will-take-over-the-world-bad, but surely suboptimal since we just had a stable release which must be installable
07:37:53 <geekosaur> http://lambda.haskell.org/platform/doc/current/packages/split-0.2.2/doc/html/Data-List-Split.html
07:37:56 <Myrl> I plan on doing recursion, and to work with take.
07:38:22 <Lokathor> sm, i'm assuming that if they could just unpack a .tgz file it wouldn't have come up
07:39:00 * sm wonders if the ubuntu PPA at http://www.stackage.org/install is usable on debian
07:40:00 <Myrl> geekosaur: Ah, chunksOf seems to be what I need. Thanks!
07:40:58 <geekosaur> ...what is this, since stacking is making a play to become the platform now *it* has to be the most evil thing since ever?
07:40:59 <ahg> lokathor: The problem is that I am missing dependencies necessary to build cabal. I have downloaded the .tar but cannot compile it
07:41:19 <ahg> lokathor: and without cabal-install, I am having difficulty installing those dependencies
07:41:42 <sm> ahg: yes, hvr's PPA is useful for Debian too: https://github.com/bitemyapp/learnhaskell/blob/master/README.md. So that's an option
07:42:14 <nshepperd> Myrl: last year I typically did thing like 'testCases $ lines $ getContents where testCases [] = []; testCases (n:rest) = doSomething (take n rest) : testCases (drop n rest)'
07:42:57 <nshepperd> Myrl: for those problems with variable number of lines per test case
07:42:58 <Myrl> nshepperd: That seems sane too.
07:43:09 <sm> separately, if you can't successfully "cabal install cabal-install" there is probably a problem with your setup, and you may want to pastebin the errors and seek advice
07:44:23 <sm> uh, s/"cabal install cabal-install"/install cabal-install/
07:44:38 <nshepperd> er, take (read n) rest
07:44:51 <nshepperd> gotta read that number from a String into an Int
07:46:07 <Myrl> Ah.
07:46:14 <Myrl> I think I understand chop now.
07:46:37 <Myrl> nshepperd: I think chop also works for variable number of lines.
07:47:39 <ddellacosta> Data.List.tails is linear, right?
07:47:46 <nshepperd> hmm, I hadn't tried the split package
07:47:47 <ahg> sm: thanks for the link. Reading...
07:48:01 <nshepperd> Myrl: yeah, looks like chop basically abstracts this pattern out
07:49:06 <Myrl> nshepperd: Yeah. I think chop works by making a list out of the fst of the returned tuples, and then passes snd back to the function.
07:49:27 <nshepperd> chop (\(nr:rest) -> let n = read nr in (doSomething (take n rest), drop n rest))
07:49:43 <Myrl> Oh yeah, I forgot lambdabot has @src.
07:50:10 <Myrl> Nop.
07:50:32 <Myrl> Oh okay, there's a "Source" button at the rightmost side. I'm blind.
07:50:35 <nshepperd> the @src database is pretty limited
07:51:34 <Myrl> chop f as = b : chop f as'
07:51:34 <Myrl>   where (b, as') = f as
07:51:42 <Myrl> I guess I'm right.
07:51:55 <Myrl> I'ma use this too. I guess. Thanks geekosaur.
07:56:04 * hackagebot llvm-ffi 3.0.0 - FFI bindings to the LLVM compiler toolkit.  http://hackage.haskell.org/package/llvm-ffi-3.0.0 (HenningThielemann)
07:56:34 <quazimodo> hey all
07:57:01 <quazimodo> I'm looking for a coding walkthrough, much like the programming walkthroughs in gigamonkeys, for haskell 
07:57:22 <athan> quazimodo: hello!
07:57:22 <quazimodo> i haven't found anything notable to help me learn, do these exist?
07:57:29 <athan> quazimodo: I'm not very familiar with that. Something like a tutorial?
07:57:37 <athan> @learn quazimodo
07:57:37 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
07:57:44 <quazimodo> http://www.gigamonkeys.com/book/practical-a-spam-filter.html
07:57:54 <athan> quazimodo: There is a lot of information, but a learning curve
07:57:56 <quazimodo> athan: i'm going through learn you a haskell, it's awesome
07:58:09 <quazimodo> and i've listened to several lectures
07:58:09 <Lokathor> it's... alright
07:58:25 <athan> quazimodo: That book might introduce you to concepts, but I really suggest you check out bitemyapp's Learning Haskell resource
07:58:31 <quazimodo> i'm getting the drift, I like it. What helped me learn LISP was gigamonkeys' guided practicals
07:58:36 <athan> Also, there's #haskell-beginners :)
07:58:42 <c_wraith> quazimodo: There's https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours for a project-based approach
07:58:45 <quazimodo> didn't know aboutit
07:58:49 <Lokathor> after trying the cis194 class and doing the homeworks, i've learned quite a bit more than LYAH teaches
07:59:16 <Lokathor> http://www.seas.upenn.edu/~cis194/spring13/lectures.html
07:59:55 <quazimodo> that's essentially what I need, homework
07:59:59 <Lokathor> though cis194 does have you read LYAH for each section. i guess my point is that actually writing down code matters more than reading the whole book at once
08:00:02 <Lokathor> yeah yeah
08:00:15 <quazimodo> took me a long time to understand the purpose of monads
08:00:25 <quazimodo> no one explains what the hell they are for lol
08:00:42 <quazimodo> just some confusing abstract notion of what they are/arent
08:00:46 <geekosaur> https://wiki.haskell.org/Xmonad/Config_archive/John_Goerzen%27s_Configuration :)
08:00:55 <quazimodo> xmonad lol
08:01:01 <ddellacosta> quazimodo: I haven't done all the exercises, but what I did I enjoyed: https://github.com/opqdonut/haskell-exercises
08:01:25 <quazimodo> i use i3, geekosaur, someone tried to get me to use xmonad years ago
08:01:25 <ddellacosta> quazimodo: as far as monads, I wouldn't rush it
08:01:28 <quazimodo> i panicked :P
08:01:32 <Lokathor> quazimodo, you can't be told what a monad is, you have to see it for yourself *puts on 90's cyberpunk sunglasses*
08:01:38 <quazimodo> lol
08:01:44 <quazimodo> i understand it now
08:01:47 <quazimodo> it's a great idea
08:01:48 <geekosaur> nobody says what they're for because that's the wrong question. monads are a pattern that has been found to be useful, rather than a concept developed to fill a need
08:02:42 <quazimodo> geekosaur: well, i don't know about that. What I do know is that the moment I understood their utility in composition, I suddenly started to understand them
08:02:51 <quazimodo> some times the why bleeds into the how, for me at least
08:03:19 <quazimodo> guys thank you all, i have some resources to read now, very awesome
08:03:44 <quazimodo> need to get ontop of basic haskell this month, we want to trial some systems built in haskell at work soon
08:04:11 <geekosaur> that can happen afterward, sure, but it means that there is no nice global "here's what it does" because "what it does" is essentially be a pattern. the pattern existed before the applications.
08:04:39 <quazimodo> geekosaur: right, yes that makes sense to me
08:04:49 <quazimodo> the pattern is pretty brilliant though
08:04:52 <ddellacosta> Has anyone gone through Pearls of Functional Algorithm Design who would care to explain something to me?  I'm on #2, and feeling confused about what Bird means by the "divide and conquer property of tails." 
08:05:38 <narendraj9> join #tmux
08:05:39 <athan> c_wraith: liquid haskell is the future I think
08:06:04 <c_wraith> athan: I like it, but I've run into bugs in the tutorial and some other early-phase stumbling blocks. :)
08:06:04 <athan> oh shoot he's not online
08:06:08 <athan> er wait
08:06:14 <c_wraith> You're really bad at this. :)
08:06:15 <athan> damn
08:06:20 <athan> :v
08:06:31 <c_wraith> Or I'm very stealthy online. One of the two!
08:06:52 <athan> c_wraith: I really want to see how this subtyping / refinement system has more freedom than dependent types
08:06:57 <quazimodo> i  wish I'd had this write yourself a scheme in 48 horus
08:07:00 <athan> ._.
08:07:00 <johnw> c_wraith: to be fair, he didn't say liquid haskell was the present
08:07:07 <quazimodo> I'd have spent the eastre long weekend and done it by now
08:07:22 <johnw> athan: the freedom comes by way of a loss of freedom, btw
08:07:41 <johnw> any time you constrain the expressivity of a system, you give freedom to its implementation
08:07:43 <quazimodo> johnw: that's why greco roman wrestling is more artistic than freestyle btw
08:08:06 <athan> johnw: Ahh okay, I think I see
08:08:06 <quazimodo> imho anyway
08:08:30 <johnw> dependent types can express propositions about undecidable, uncomputable things
08:09:14 <johnw> on the other hand, for typical engineer problems, I think liquid haskell's domain of interest is the more readily applicable
08:10:21 <athan> johnw: For haskell anyway, I think LQ haskell might be a good initiative
08:10:37 <athan> coq extraction isn't the best, I've heard :\
08:11:11 <athan> c_wraith: Did you run into a -Werror failure while compiling? There's no log info :(
08:11:25 <nshepperd> I think liquid haskell was a subset of dependent types
08:12:00 <johnw> liquid haskell is the subset of decidable, computable propositions
08:12:24 <athan> boolean ones too, correct?
08:12:36 <athan> er - the propositions are boolean
08:12:38 <johnw> that are pretty much the essence of what it is to be decidable :)
08:12:59 <johnw> bools, ints, finite lists, etc.
08:12:59 <athan> :o!
08:13:05 <ahg> In case anyone is curious about my cabal-install install difficulties: I 'ghc-pkg unregister'ed the libraries that I had manually installed, then re-ran bootstrap.sh to prove to myself that I was back where I started, and the build succeeded.
08:13:06 <nshepperd> as in, you can implement it straightforwardly with dependent types, with the product of a value and a proof about the value
08:13:13 <ahg> *shrug*
08:13:16 <nshepperd> "straightforwardly", anyway
08:14:20 <lpaste> athan pasted “liquid haskell bummer :(” at http://lpaste.net/130245
08:14:39 <athan> Can anyone point where I should look next?
08:14:45 <nshepperd> anyway, it makes sense. I suppose inference in liquid haskell is 'easier' than dependent types?
08:14:58 <geekosaur> I thought -Werror wasn't supposed to be allowed in releases
08:15:29 <athan> uh oh
08:15:39 <geekosaur> liquid haskell supports a specific subset of dependent types for which inference is possible, as I understand it
08:15:44 <johnw> nshepperd: LH, by confining itself to a computable sub-domain, can compute the solvability of expressed propositions without requiring any proof construction
08:15:50 <geekosaur> athan, if it's not a release then I'd just remove -Werror fromt he cabal file
08:15:59 <jellie> I'm using the xml package and I'm having trouble understanding the type called QName.
08:16:02 <jellie> What does it mean?
08:16:04 <jellie> http://hackage.haskell.org/package/xml-1.3.14/docs/Text-XML-Light-Types.html#t:QName
08:16:07 <jellie> or work
08:16:07 <johnw> athan: are you trying to build with 7.10?
08:16:16 <athan> johnw: Yes!
08:16:26 <athan> geekosaur: Alright, I'll give it a shot, thank you
08:16:29 <johnw> yeah, i don't think liquidhaskell has even been tested with 7.10 yet
08:16:35 <athan> shoot
08:17:16 <geekosaur> (in essence, -Werror is a lovely way to prevent cross-version portability. it's desirable for development but risky for release...
08:17:37 <jellie> What is an xml qualified name?
08:17:43 <johnw> the main LH feature I'm looking forward to is better support for type classes, so that I can use it to prove that a Monad instance fulfills the monad laws
08:18:04 <johnw> jellie: <ns:Foo>...</ns:Foo>?
08:18:06 <geekosaur> jellie: a name with a namespace qualifier
08:18:23 <geekosaur> http://www.w3schools.com/xml/xml_namespaces.asp
08:18:27 <johnw> where earlier there was: <... xml:ns="URL">
08:19:00 <geekosaur> so it gives a name, the namespace prefix, and the URL providing the authority / definition for the prefix
08:20:28 <athan> thanks guys :)
08:21:17 <geekosaur> s/for the prefix/for the namespace/
08:23:16 <haskell638> hey guys quick Q
08:24:24 <jellie> brb
08:25:31 <haskell638> http://lpaste.net/130246
08:25:46 <haskell638> can I pattern match on the db to see if its a connection or a sql error?
08:28:08 <erkin> On emacs, I'm suddenly getting a cryptic error of "You tried to do an indentation command, but an indentation mode has not been enabled yet."
08:28:15 <erkin> Any ideas why this happens?
08:28:57 <erkin> I'm pretty sure I have (haskell-mode-hook (quote (turn-on-haskell-indent))) in my (custom-set-variables) in init.el
08:29:35 <erkin> What's more, it worked perfectly well until fifteen minutes ago.
08:30:44 <geekosaur> haskell638, no, it's an exception. you can use COntrol.Exception.catch or you can use something other than handleSQLError (which just changes the SQL exception to an IO exception per http://hackage.haskell.org/package/HDBC-2.4.0.1/docs/Database-HDBC.html#v:handleSqlError)
08:31:01 <geekosaur> look around the other functions at that URL to see other ways to deal with SQL errors
08:31:16 <geekosaur> in particular handleSQL / catchSQL
08:31:49 <geekosaur> (if you're not using HDBC then I suggest checking the documentation for the database driver you are using)
08:32:01 <Springwight> I want to determine the structure of a possible finger tree that holds N elements. Does anyone have any idea how to do that? Things like its height, the number of elements in its digit, and so forth.
08:32:49 <haskell638> @geekosaur: does connectSqlite3 throw a sqlError? I look at the docs, and it says it returns an IO Connection
08:32:49 <lambdabot> Unknown command, try @list
08:33:05 <geekosaur> [06 15:29] <geekosaur> (if you're not using HDBC then I suggest checking the documentation for the database driver you are using)
08:34:33 <geekosaur> do I need to go research hdbc for you?
08:34:53 <erkin> Fixed it.
08:35:11 <geekosaur> I assume that since it is part of hdbc (it is, right? you neglected to mention what you are using) it does what hdbc does, i.e. throw SQLErrors on failure
08:35:45 <erkin> For the future record: I replaced (haskell-mode-hook (quote (turn-on-haskell-indent))) in (custom-set-variables) with (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
08:36:01 <erkin> Except this one's outside (custom-set-variables)
08:47:59 <haskell638> @geekasaur, can I do this? http://lpaste.net/130247
08:47:59 <lambdabot> Unknown command, try @list
08:48:48 <haskell638> @list
08:48:48 <lambdabot> What module?  Try @listmodules for some ideas.
08:49:09 <haskell638> <haskell638>
08:56:06 <mustafa_> Hey guys! I'm trying to understand Gabriel's free monad tutorial and having a bit of trouble. When he uses the declaration:
08:56:17 <mustafa_> data Free f r = Free (f (Free f r)) | Pure r
08:56:21 <mustafa_> what is the type of f?
08:56:25 <mustafa_> is it * -> *
08:56:31 <mustafa_> or is it like [Int]
08:56:35 <mustafa_> (for instance
08:56:36 <mustafa_> )
08:59:19 <cYmen_> Alright, back to those strings. What is the easiest or quickest way to get a list of Ints out of a cookie. I can't find any functions to convert Data.Text.Internal.Text back to string. Any hints?
09:00:42 <josephle> mustafa_, it seems like f has kind * -> *
09:03:11 <mustafa_> Do you think so? I'm very confused then
09:03:50 <srhb> mustafa_: Well it must, since it is applied to (Free f r)
09:04:16 <srhb> mustafa_: A type of kind * cannot be applied
09:04:28 <srhb> mustafa_: (How do you apply [Int] to, say Int?)
09:04:50 <mustafa_> Okay. I mean, that was my thought. But then I dno't get how you "store" values inside the datatype
09:05:16 <mustafa_> How he uses it in his tutorial (http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html)
09:06:14 <mustafa_> data Toy b next =     Output b next   | Bell next   | Done
09:06:19 <S11001001> mustafa_: a type argument, like a normal argument, is an invitation to substitute in various values.
09:06:29 <mustafa_> Fix (Bell (Fix (Output 'A' (Fix Done)))) :: Fix (Toy Char)
09:06:54 <S11001001> mustafa_: For example, what happens when you set f = Maybe, perform this substitution on the RHS of the data declaration, and eliminate the type parameter f?
09:07:00 <srhb> mustafa_: Is it the recursion that's bothering you?
09:07:27 <S11001001> mustafa_: alternatively, what happens when you set f = []?  What about f = (->) Int?
09:07:31 <mustafa_> What's bothering me is I don't see how you can get anything other than an endlessly descending series of functor declarations
09:07:38 <srhb> Ah
09:07:50 <mustafa_> f (f (f (f (f (f ...))))))
09:08:08 <srhb> mustafa_: I think you're confusing Free with Free, perhaps
09:08:13 <srhb> (Arguably understandable :-))
09:08:21 <mustafa_> explain!!
09:08:31 <srhb> Well, one is a type constructor and the other is a data constructor
09:08:39 <srhb> Pure r :: Free f r
09:09:08 <srhb> Free (f (Pure r) :: Free f r
09:09:15 <S11001001> mustafa_: is this better? data Free f r = Roll (f (Free f r)) | Pure r
09:09:31 <srhb> I can terminate at any point using Pure r
09:10:04 <srhb> It really is no different than data List a = Nil | Cons a (List a)
09:10:04 <mustafa_> why don't we use [] for f?
09:10:07 <mustafa_> just for now
09:10:10 <srhb> OK
09:10:32 <mustafa_> Okay! But in the list example you have Cons a (List a)
09:10:37 <mustafa_> not just Cons (List a)
09:11:03 <mustafa_> So let's say we have f :: [] and r :: Int
09:11:30 <S11001001> mustafa_: sure
09:11:49 <srhb> Free [Pure Int]
09:11:51 <srhb> There, done!
09:11:56 <nshepperd> 'Free [] a' is actually a rose tree
09:11:58 <mustafa_> Roll [Pure 5, Pure 6, Roll [Pure 3], Roll [Roll 7]]
09:12:03 <mustafa_> is that right!?
09:12:16 <S11001001> mustafa_: you can't Roll 7, but otherwise sure
09:12:19 <mustafa_> Oh my god I might have just understood this
09:12:26 <srhb> Hooray!
09:12:28 <mustafa_> **Pure
09:12:53 <mustafa_> Thanks guys! I think the Roll thing helped me, as well as using the concrete list example
09:13:15 <srhb> Yeah getting data and type constructors mixed up is quite easy.
09:13:37 <mustafa_> I guess I hadn't thought about how a functor often implies a container for multiple values, so I didn't see the point of recursion
09:14:21 <nshepperd> i like the explanation: 'Free f a' for a Functor f is a tree, where each leaf node has one 'a' and each node has a 'functorful' of children
09:14:26 <mustafa_> I was talking with a friend about this, and I came up with the following intuition: Just as the list captures the "Shape" of monoidic composition, the free monad captures the "shape" of monadic composition
09:14:31 <mustafa_> Is that accurate?
09:14:38 <mustafa_> Or does it make any sense to you?
09:14:46 <nshepperd> if you use the functor 'f a = (a, a)' you get an ordinary binary tree
09:15:14 <nshepperd> er, each *inner* node has a functorful of children
09:15:17 <mustafa_> Oh my god that's so cool I never thought about that
09:15:49 <mustafa_> a binary tree with only leaves, right?
09:16:10 <mustafa_> or, to be more precise, the only values are at the leaves
09:17:31 <S11001001> mustafa_: yep
09:18:05 <srhb> Such magic. Much Free.
09:19:30 <hjulle> What is the best data structure if I want to store many copies of it with just a few elements changed in each? I know the exact range of the keys. It's for storing state in a list monad-based backtracking algorithm.
09:20:15 <hjulle> More specifically, the set of all nodes visited so far.
09:20:23 <mustafa_> S11001001: Thanks so much!
09:20:30 <johnw> mustafa_: a list captures all quotiented expressions of the monoid algebra; the free monad captures all quotiented expressions of any f-algebra
09:20:50 <Springwight> hjulle, is it sequential? a set? a map? how do you want to use it
09:21:02 <mustafa_> johnw: I don't know what that means. I've never read anything about f-algebras
09:21:08 * hackagebot turtle 1.1.0 - Shell programming, Haskell-style  http://hackage.haskell.org/package/turtle-1.1.0 (GabrielGonzalez)
09:21:15 <mustafa_> any suggestions?
09:21:16 <johnw> an f-algebra codifies an algebra as a functor
09:21:21 <hjulle> Random access. I think a set would be bad because of all the rebalancing?
09:21:28 <johnw> data Monoid a = MEmpty | MAppend a (Monoid a)
09:21:31 <johnw> should look familiar :)
09:21:38 <Springwight> I don't know. Whatever you choose, it's going to be a tree of some sort anyway.
09:21:48 <mustafa_> Yes
09:22:08 <johnw> the "quotienting" means that expressions equivalent by way of a law (like a++(b++c) = (a++b)++c) have been collapsed down to a single value
09:22:12 <mustafa_> (I"m a theoretical math student who doesn't know what an algebra is)
09:22:26 <mustafa_> (Blame the institution that gave me my degree)
09:22:37 <mustafa_> That I understand
09:22:52 <johnw> an algebra is a carrier set, a group of operations over that set, and the laws governing those operations
09:23:04 <mustafa_> I don't know what it means to "capture" quotiented expressions
09:23:10 <mustafa_> do you just mean encodes the equivalence
09:23:13 <johnw> yes
09:23:16 <hjulle> Springwight,  I think using "Set key Bool" and setting all values to False before using might work.
09:23:24 <johnw> capture means it encodes the syntax tree
09:23:45 <johnw> i.e., it could print the same expressions back to you, modulo equivalence
09:24:09 <johnw> this is the essence of what being "free" means here
09:24:10 <mustafa_> So basically it just has to collapse identities
09:24:13 <mustafa_> okay
09:24:31 <johnw> right, you lose distinction between equivalent forms of expression
09:24:38 <mustafa_> When I studied free monoids it was in the context of having prime elements
09:25:21 <johnw> so, now imagine you have a functor that represents the abstract form of some "expression node"
09:25:31 <mustafa_> and I think I understand the equivalency of these two formulations
09:25:32 <johnw> the free monad over that functor, plus its laws, becomes your grammer
09:25:34 <johnw> grammar*
09:25:51 <mustafa_> "its laws"
09:26:01 <johnw> like, commtativity, associativity, etc.
09:26:06 <mustafa_> ambiguous object pronoun
09:26:12 <johnw> its = the functor
09:26:14 <mustafa_> the functor's laws?
09:26:20 <mustafa_> kk
09:26:24 <johnw> the functor + its laws becomes the seed of your "language"
09:26:35 <johnw> where every legal sentence of that language is parsed into a syntax tree
09:26:43 <johnw> the structure of that "tree" is the free monad over that functor
09:26:49 <mustafa_> I'm still trying to understand how this is monadic, though I think I'll be able to reread the definitions now and get it better
09:27:06 <johnw> it's monadic because it's sufficiently rich to express join and return
09:27:12 <johnw> even if the functor can't
09:27:20 <mustafa_> Oh
09:27:22 <mustafa_> before that
09:27:41 <mustafa_> can I ask what it means to encode the equivalence
09:27:45 <mustafa_> like, concretely
09:27:49 <johnw> you can't encode it
09:27:50 <mustafa_> not in a mathematical sense
09:27:51 <johnw> you lose that information
09:28:05 <mustafa_> I mean, to collapse equivalence
09:28:14 <johnw> this could encode it: data Monoid a = MEmpty | MSingleton a | MAppend (Monoid a) (Monoid a)
09:28:15 <mustafa_> what does that mean literally when I'm using the free monad
09:28:21 <mustafa_> say Free [] Int
09:28:52 <johnw> that's a rose-tree of integers
09:29:13 <mustafa_> Yeah, so what does it mean to encode equivalence?
09:29:23 <mustafa_> sorry
09:29:28 <mustafa_> I keep saying that
09:29:30 <johnw> so, in that case there are no equivalences
09:29:34 <mustafa_> how do we equate equivalent statements
09:29:41 <johnw> ok
09:29:48 <johnw> take that Monoid a I just give you, the one with MSingleton
09:29:56 <mustafa_> Yes
09:30:13 <johnw> as a magma, it is *not* equivalent to Monoid a = MEmpty | MAppend a (Monoid a)
09:30:28 <johnw> because Monoid a with MSingleton can encode trees, whereas Monoid a without MSingleton cannot encode trees
09:30:36 <johnw> yet, as a monoid, they are equivalent
09:30:50 <johnw> because of the application of the associativity law
09:31:09 * hackagebot snap 0.14.0.2 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.14.0.2 (DougBeardsley)
09:31:24 <johnw> i.e., take the associativity law, apply it over any value of Monoid-with-MSingleton, and there will be a value of Monoid-without-MSingleton that it is equivalent to
09:31:52 <mustafa_> Is this a transformation that we have to program?
09:32:02 <johnw> well, you *could* do that, if you wanted to
09:32:03 <mustafa_> or is it something that haskell takes care of for us
09:32:06 <johnw> but usually we encode the law into the type
09:32:15 <johnw> so that you lose the information right up front, when you parse the expression
09:32:22 <mustafa_> How does the Fix example do that?
09:32:57 <johnw> I'm not sure I see the laws applicable to Fix that would do this
09:33:03 <johnw> so maybe this point should be deferred until later
09:33:26 <mustafa_> Okay
09:33:49 <johnw> (to your Fix example, I meant)
09:34:12 <johnw> but does that make it clear how the free monad builds tree structures out of functors?
09:34:13 <mustafa_> Yeah, I understand. I'm really happy because I think I'll be able to read through this stuff now and get it
09:34:16 <mustafa_> yeah
09:34:24 <johnw> one last intuition for you
09:34:29 <johnw> if the free monoid goes from a to [a]
09:34:36 <mustafa_> I'd been under the impression that infinitely nested []s were impossibles
09:34:38 <mustafa_> *impossible
09:34:40 <johnw> you can almost think of the free monad as going from f a to [f] a :)
09:34:47 <mustafa_> so this is cool
09:34:48 <mustafa_> yes
09:34:49 <mustafa_> ?
09:34:55 <johnw> (as long as you keep in mind that [f] is a tree, not a list)
09:35:17 <mustafa_> when f is [] right?
09:35:23 <johnw> no, this isn't legal syntxa
09:35:25 <mustafa_> yeah!
09:35:27 <johnw> just an intuition
09:35:38 <johnw> free gives you unmolested structure
09:35:39 <mustafa_> Yeah, thanks! This is great!
09:36:09 <mustafa_> thanks a lot, man, I appreciate it. Okay, going to run to work.
09:36:13 <mustafa_> peace!
09:36:15 <johnw> enjoy
09:36:20 <mustafa_> You too
09:40:13 <johnw> hjulle: Data.Map?
09:41:16 <hjulle> johnw, Wouldn't the constant rebalancing prevent it from reusing anyting in the other copies?
09:41:41 <johnw> I think it would only fail to reuse the balanced sub-tree
09:41:48 <hjulle> johnw, Oh, I misread yoe
09:41:50 <hjulle> *you
09:42:16 <johnw> but it's better than a list, where the subtree's size is always n-i
09:43:16 <hjulle> Yes, I've decided that Data.Map is the best. Probably much better than Data.Set, since I know the size on beforehand, but I'll have to test it.
09:44:14 <hjulle> A list is really good with respect to reuse in my case, but the lookup times are horrible.
09:45:03 <Javran> hmm, I find those days whenever I look at this channel, there are something about functors :)
09:46:10 * hackagebot fixed-vector 0.8.0.0 - Generic vectors with statically known size.  http://hackage.haskell.org/package/fixed-vector-0.8.0.0 (AlexeyKhudyakov)
09:46:33 <johnw> hjulle: the number of keys, is it known statically, or just at runtime?
09:47:09 <hjulle> The set of keys is known statically.
09:47:18 <johnw> so, there's something you could do then :)
09:47:28 <Javran> I'm trying to make sense of "data Fix f = Fix (f (Fix f))" .. any straightforward intuition about this?
09:47:34 <johnw> make a lambda that closes over a set of lists, that branches on its key argument to each sublist 
09:47:54 <johnw> Javran: so, let's think of it in a simpler way
09:47:59 <mauke> Javran: it's like fix, only at the type level
09:48:06 <johnw> yeah, or do that :)
09:48:27 <johnw> fix f = f (fix f).  s/fix f/x/g and you get x = f x.  symmetry and you get f x = x.
09:49:41 <Javran> but for "fix" to work we need laziness
09:50:02 <Javran> not sure about Fix -- it's at the type level
09:50:04 <hjulle> johnw, "a lambda that closes over..."? What does closes mean in this context? 
09:50:24 <johnw> hjulle: \idx -> case idx of 0 -> []; 1 -> []; 2 -> []
09:50:34 <johnw> then, whenever a list at an index is updated, just make a new lambda
09:50:59 <johnw> this gives you pretty insanely fast lookup times, and should give you pretty good sharing
09:51:24 <johnw> "closes over" means that lambda is kind of storing those list values inside it
09:51:37 <Javran> ah wait, I think I get it..
09:52:39 <hjulle> johnw,  I'm not going to write a case clause with 1364 cases. :P
09:52:54 <Javran> type unification should result in the most general type, if that's something like laziness -- do I get it right?
09:52:59 <johnw> hjulle: well, you could use TH to generate it :)
09:53:06 <johnw> just saying, if efficiency is your main concern
09:54:24 <johnw> Javran: you can construct a type of infinite depth resulting from Fix f a by tying the knot
09:54:55 <johnw> I don't think the type unifier ever tries to "expand out" the infinite type
09:55:16 <johnw> let me try
09:55:31 <Forgetaboutit> Is there a simple way in to update the `i'-th element in a list?
09:55:44 <Forgetaboutit> s/in/in Haskell/
09:55:45 <srhb> Forgetaboutit: recursively, counting down.
09:56:03 <srhb> Or with take and drop.
09:56:43 <hjulle> But I think you have misunderstood my question. What I want is a data structure for a subset of the known set of keys. This could be solved with either Data.Set Key, Data.Map Key Bool, Data.Array Key Bool or [Key]. Does your suggestion solve that as well?
09:56:47 <johnw> Javran: https://gist.github.com/a5ce34f2370d5b2e3341
09:56:52 <Forgetaboutit> srhb: you mean, like `take i list ++ newI : drop (i + 1) list'?
09:57:15 <johnw> Javran: you could never deepseq 'x', but you can construct it, and case match it to any finite depth you desire
09:57:18 <srhb> Forgetaboutit: I think it should be take (n-1) xs ++ [x] ++ drop n xs
09:57:36 <Forgetaboutit> srhb: oh sure
09:57:36 <srhb> Or something like that.
09:57:39 <Javran> johnw: I see
09:57:47 <Forgetaboutit> srhb: Thanks!
09:57:57 <srhb> Forgetaboutit: (Lists are not the greatest structure for doing this thing, but I guess you can tell :-))
09:58:27 <Javran> so you can't deepseq because there's always a type level argument that we don't know its NFData instance?
09:58:41 <Forgetaboutit> srhb: Indeed.  I should probably using Arrays instead
09:58:47 <johnw> Javran: no, because the value at runtime (when type has been erased) is an infinite loop
09:58:49 <srhb> Forgetaboutit: It really depends.
09:58:54 <hjulle> Forgetaboutit, list & ix n .~ x -- In Control.Lens
09:59:02 <srhb> Forgetaboutit: Sequence might be sufficient.
09:59:16 <johnw> when I said can't, I meant it would result in ⊥
09:59:52 <srhb> Forgetaboutit: For a Sequence it would be update i x
10:00:00 <Forgetaboutit> hjulle: I want to avoid any dependencies, I already assumed lens has a combinator for that :)
10:00:03 <srhb> Uh, update i x xs
10:00:10 <levi> Javran: Stuff like 'Fix' makes more sense when thinking denotationally rather than operationally, I think.
10:01:22 <Javran> levi: yeah, I was trying to figure out what exactly happens
10:02:08 <Forgetaboutit> srhb: Never used Sequence before.  Looks like an interesting data structure
10:02:26 <levi> A fixed point of a function 'f' is exactly a value x such that f(f(x)) == f(x); i.e. multiple applications don't change the value anymore.  The point of a function 'fix f' is to give you the fixed point.
10:02:53 <johnw> levi: and in the case of Haskell's fix, the least defined fixpoint
10:03:05 <levi> Right.
10:03:15 <Forgetaboutit> I'm mostly coming from an imperative OOP background, unfortunately.  I assume there is no equivalent of this in more mainstreamy languages, right?
10:03:44 <levi> But to get into what that means, you have to get into a the concept of partial orders and particularly the partial order of 'definedness'.
10:04:09 <Javran> oh right, newtype deconstructors are identities -- if type info gets erased..
10:04:48 <Javran> so "let x = Fix (Identity x)" is just "let x = x" ?
10:06:10 <hjulle> Forgetaboutit, my intuition is that Sequence is a hybrid of a biqueue and a binary tree.
10:06:45 <levi> Javran: The point of having something like Fix was originally that if you add it to a language that doesn't allow recursive types (i.e. a simply-typed lambda calculus), it lets you *build* recursive types. In Haskell, where we already had recursive types, it's an alternate way to build them.
10:07:21 <Forgetaboutit> hjulle: biqueue == double-ended queue?
10:07:37 <Javran> I guess it's just like you can use fix to write recursive functions
10:07:43 <levi> I.e., Fix doesn't have to be a primitive in Haskell because its primitive type expressions already allow that sort of recursive construction.
10:07:49 <levi> Javran: Exactly.
10:08:24 <Javran> and recursion seems to be a builtin feature of let-expressions
10:08:34 <levi> Of Haskell let expressions, anyway.
10:09:10 <levi> In ML-style or Scheme-style languages, you have to use an explicitly recursive variant of let to get the recursive behavior.
10:09:45 <Javran> oh, like ocaml letrec
10:11:22 <levi> Forgetaboutit: Mainstream languages that want a persistent data structure will sometimes implement something like Sequence, but when you're not forced by the language runtime to be purely functional they're typically not the optimal choice if you don't need persistence.
10:12:26 <Forgetaboutit> levi: I see, thanks!
10:12:34 <levi> Purely functional data structures are actually a lot *nicer* and simpler than the earlier imperative attempts at getting persistent data structures.
10:14:05 <Forgetaboutit> What's the difference between imperative and purely functional persistent data structures?
10:14:30 <EvanR> pointer wrangling is error prone and confusing
10:15:15 <levi> I don't know as much about imperative persistent data structures, but they tended to try to explicitly store history along with mutating updates to the primary structure, IIRC.
10:16:09 <EvanR> with a gc you can avoid all that, but its still a non trivial task
10:16:15 <Forgetaboutit> That's interesting.  I've never heard of that before (which is a good thing, I suppose)
10:16:29 <levi> The ones I saw tended to come from algorithms to do computational geometry stuff, so they'd explicitly store the history they needed for their algorithms in the data structure.
10:17:47 <Forgetaboutit> Do persistent data structures exhibit structural sharing like in Clojure?
10:18:07 <EvanR> thats what persistent is supposed to mean when people saying
10:18:08 <EvanR> say it
10:18:09 <levi> Purely functional ones do.
10:18:11 <Forgetaboutit> (regarding their implementation in Haskell, that it)
10:18:35 <EvanR> in haskell you just say that you get sharing
10:19:07 <Forgetaboutit> Ah ok.  I still get confused by the terminology, I guess
10:19:12 <EvanR> since everything is immutable persistence or sharing is an implementation detail 
10:19:30 <EvanR> you cant really observe it when writing your code
10:19:46 <johnw> persistence = doesn't change behind your back, the value "persists".  Immutability makes this a no-brainer
10:21:12 <levi> EvanR: What I'm trying to say is that the concept of persistent data structures predates a lot of the work on functional data structures, and so earlier techniques for persistence are not at all the same as functional data structures.
10:22:16 * EvanR complains a little about terminology functional data structure
10:22:48 <johnw> impurely functional, persistent, mutable data structures
10:22:59 <levi> Wasn't our last discussion about some terminology you had issues with?
10:23:24 <EvanR> probably but im not interested in saying anything else about this
10:23:42 <utdemir> Hey. Assume that there is a web api which provides a method a -> b. So, if I have [a], I can just mapM and get [b]. But this makes N network requests. But this api provides a method that, if you put [a] in your requests it can provide [b]. How can I model my request so that I can combine two requests to one request. That looks like applicative to me, but I'm not sure how I'd implement ap?
10:24:18 <levi> Anyway, this paper compares/contrasts methods of making some data structures persistent: http://www.cs.cmu.edu/~sleator/papers/another-persistence.pdf
10:25:38 <EvanR> yeah, persistence is almost a non-concept in haskell. its really an idea to be applied in a context where the default is something like javascript object where everyone sees all mutations
10:26:25 <EvanR> and that would cause trouble
10:26:39 <levi> The 'fat node' method described there is a mutable in-place update way to add persistence to a data structure.
10:28:11 <bennofs> utdemir: can you also do requests of different types in one request?
10:28:57 <utdemir> bennofs: There is just one request, which you provide a string and it returns an integer
10:29:12 <EvanR> in the first version of my midi sequencer in c++ i added persistence to the sequence structure in order to deal with concurrency and undoing. it was awful. in the haskell rewrite its indeed a "no brainer"
10:29:49 <utdemir> bennofs: *which I plan to use. Actually there is more methods, but you can't combine different types of requests to one.
10:30:48 <bennofs> utdemir: ok. so you could make a data NetM a = NetM { requests :: [(String, Int)], result :: [(String, Int)] -> a }
10:31:29 <bennofs> utdemir: this data type contains a list of requests needed to compute the result, and a function to compute the result given the responses values of those requests
10:32:16 <bennofs> (I think there is a way to encode this more nicely which I can't think of right now, but this will work to explain the concept)
10:34:06 <utdemir> bennofs: But I think I can't enforce that the request and response should have a same number of elements on type level. I was thinking something like making `sumAnswers <$> question "1" <*> question "2"` work with just one request.
10:35:40 <bennofs> utdemir: yes, but if you don't expose the NetM constructor, you just have to make sure that the primitive operations on NetM retain the invariant that the number of elements in requests is the same as the number of elements in this list expected by the result function. 
10:36:11 <bennofs> utdemir: as long as those operations preserve this invariant, other code can just rely on them and be safe
10:36:15 * hackagebot exp-pairs 0.1.2.0 - Linear programming over exponent pairs  http://hackage.haskell.org/package/exp-pairs-0.1.2.0 (Bodigrim)
10:36:39 <utdemir> bennofs: Thanks, I'm going with that way. Have a nice day :)
10:36:47 <bennofs> utdemir: oh, I just remembered how a nicer solution for this can work
10:36:53 <hjulle> Forgetaboutit, Yes. It is a double-ended queue. That is difficult to implement an effective persistant/immutable version of.
10:37:22 <bennofs> utdemir: See http://twanvl.nl/blog/haskell/non-regular1
10:37:48 <bennofs> utdemir: I love that data type. data FunList a b = Done b | More a (FunList a (a -> b))
10:38:51 <bennofs> utdemir: in your case, you would need data NetM a = Pure a | Request String (NetM (Int -> a))
10:39:17 <bennofs> utdemir: this data type represents a function of n Int arguments together with a list of n Strings
10:39:28 <bennofs> utdemir: (returning a value of type a)
10:41:25 <utdemir> bennofs: It looks useful! Now I'm trying to understand it :) 
10:41:29 <bennofs> utdemir: this data type 
10:42:55 <bennofs> utdemir: well, the idea is that with each application of the Request constructor, the type 'a' is prefixed with one more Int -> ... . So if you apply Request n-times, the a type at the end when you reach Pure will be a function of n Ints
10:43:32 <bennofs> @let data NetM a = Done a | Request String (NetM (Int -> a))
10:43:34 <lambdabot>  Defined.
10:44:33 <bennofs> @let instance Show (NetM a) where show (Done x) = "done"; show (Request r next) = r ++ " -> " ++ show next
10:44:34 <lambdabot>  Defined.
10:44:45 <srhb> Has anyone been having issues (and, preferably, solved them) with haskell-process after upgrading to GHC 7.10? It complains that it cannot even find $ and class IO, return and others.
10:45:06 <bennofs> > Request "1" (Request "2" $ Done $ \a b -> a + b)
10:45:08 <lambdabot>  1 -> 2 -> done
10:49:22 <utdemir> bennofs: Interesting. But it looks like it's mostly useful for me when crafting a request. Still the answer is kind of untypedç
10:51:44 <bennofs> utdemir: this data type will guarrante that the number of requests needed and the number of responses expected is the same. Of course you will still have to convert this into a list of requests and apply it to a list of responses at some time, since that is the only API you are provided. However, with this data type, this should be a really small part of the program / library.
10:56:52 <arbelos> benchmarking reveals some veeeery interesting results
10:57:50 <d34df00d> Hi!
10:58:53 <d34df00d> I'm trying to make all rotations of a string (10^4 chars in my case) and sort them and then take the last symbols of the sorted strings list (yes, that's Burrows-Wheeler transform).
10:59:22 <d34df00d> This takes around 5 GiB of memory, though. I've noticed that this variant eats 5 GiB as well (without sorting): `map last . (\x -> x `deepseq` x) . rotations`
10:59:42 <d34df00d> If I remove the deepseq step, all's fine, but seems like sort (in place of deepseq) also evaluates all the strings in the list.
11:00:17 <d34df00d> I use `rotations xs = take (length xs) $ iterate shift xs` where `shift (x:xs) = xs ++ [x]`, but I also tried a few other variants for rotations.
11:00:20 <d34df00d> How can this be solved?
11:05:42 <johnw> d34df00d: I don't have the time to help, but that's really not enough information for anyone to go on.  We haven't been working on your problem, so we don't already know what your code examples mean
11:06:13 <d34df00d> I'm eager to provide more relevant code, but I don't know what's needed exactly :)
11:06:34 <johnw> using a paste with all of what you've done, and pointing out the section with the problem
11:06:48 <d34df00d> The problem basically is that the following code eats 5 GiB of memory when fed with a string of 10 kilocharacters:
11:06:57 <d34df00d> https://bpaste.net/show/f240b79b0a1c
11:09:59 <S11001001> d34df00d: how about defining data Rotated a = Rotated Int [a] with a custom Ord instance?
11:10:37 <d34df00d> S11001001: I'm not sure I can derive the full solution from it :) How can it help?
11:11:42 <S11001001> d34df00d: you do two things with your lists: compare them (while sorting), and take the last thing.
11:12:00 <S11001001> d34df00d: whereas your shift requires tons of allocation,
11:12:18 <S11001001> d34df00d: your two operations don't *really* require all that work
11:12:37 <S11001001> d34df00d: if shift just increments that Int (representing the # of rotate operations to apply),
11:12:42 <d34df00d> S11001001: but won't all that work be hidden inside the Ord instance instead?
11:12:53 <d34df00d> I'll still need to construct the rotated strings in it I guess.
11:13:00 <S11001001> d34df00d: no
11:13:45 <S11001001> d34df00d: drop is free, and you can compare element by element, then go back to the beginning if the Int is positive
11:14:18 <S11001001> d34df00d: similarly, taking the last is free, you just have to reinterpret what "last" means
11:14:37 <d34df00d> Yeah, it's the Int -1 `mod` length.
11:14:45 <d34df00d> S11001001: cool, thanks for the idea!
11:21:18 * hackagebot acme-lolcat 0.1.1 - LOLSPEAK translator  http://hackage.haskell.org/package/acme-lolcat-0.1.1 (AntonNikishaev)
11:24:33 <marchelzo_> @pl id *** read
11:24:33 <lambdabot> id *** read
11:24:45 <levi> Heh, good to know acme-lolcat is being actively maintained.
11:25:26 <marchelzo_> I barely know what Arrow is, so forgive me if this doesn't even make sense, but is there a more concise way of writing "break isSpace >>> id *** read"?
11:25:49 <johnw> break isSpace >>> second read
11:26:40 <marchelzo_> Thanks. That's exactly what I was looking for. I though the 'id' was sort of noisy.
11:27:52 <nitrix> :t (***)
11:27:53 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
11:28:11 <nitrix> Interesting.
11:28:32 <marchelzo_> s/though/thought
11:28:45 <johnw> I both read and speak typo
11:34:13 <srhb> Is it possible to make cabal spit out and and all rejections because of version constraints rather than dying on the first one? Tidying up old packages is cumbersome.
11:37:55 <raek> does anyone recommend any library for reentrant parsing?
11:40:29 <johnw> i'm pretty sure parsec and attoparsec can do that
11:40:46 <johnw> or do you mean, parsing with continuations or something?
11:42:10 <SrPx> > sequence [[1,10],[2,20],[3,30]]
11:42:13 <lambdabot>  [[1,2,3],[1,2,30],[1,20,3],[1,20,30],[10,2,3],[10,2,30],[10,20,3],[10,20,30]]
11:43:13 <raek> johnw: I mean in the way attoparsec can do it. I'm struggling with writing a C parser. I need to preprocess the lines and then feed them to a parser.
11:43:34 <raek> it would be nice if attoparsec accepted any kind of stream (like parsec does)
11:44:39 <raek> but is it possible to feed parsec with incomplete streams and be notified when it needs more input?
11:45:58 <johnw> I'm not sure, but maybe edwardk's parsers library has that capabilitiy
11:46:05 <johnw> he has some pretty fancy support for data sourcing in there
11:46:17 <edwardk> whats up?
11:46:52 <edwardk> raek: you can build a parsec parser that consumes incrementally
11:46:55 <raek> I'm browsing for parser libraries... :-)
11:47:29 <mauke> preprocessing should give you a list of tokens
11:47:36 <edwardk> parsec uses uncons :: Steam s m t => s -> m (Maybe (t, s))  -- as its main workhorse to get content
11:47:44 <raek> okay
11:47:59 <edwardk> so define your own Stream instance and state 's', which can take input through whatever means you want in a monad m
11:48:02 <edwardk> and you can parse
11:48:04 <edwardk> now
11:48:06 <mauke> what are you using the incomplete stream for?
11:48:10 <edwardk> you then run into a problem
11:48:30 <edwardk> the problem is that all the combinators for Language/Token parsing in parsec are gimped and only work with the stock instance
11:48:39 <edwardk> not for any stream that produces chars as tokens!
11:48:45 <raek> mauke: I am experimenting with using conduit in order to keep as little data as possible in memory
11:48:53 <mauke> ah
11:49:01 <edwardk> to work around that you can use my parsers library which exposes a version of the language/token machinery that isn't restricted
11:49:08 <edwardk> and which works with parsec
11:49:28 <raek> edwardk: neat! what's your library called?
11:49:40 <edwardk> attoparsec is also very much made for parsing streaming data.
11:49:45 <edwardk> 'parsers'
11:49:47 <sw17ch> http://hackage.haskell.org/package/parsers
11:50:03 <raek> edwardk: what does a Nothing from uncons mean? end of stream, or end of input?
11:50:13 <edwardk> parsers acts as a sort of general purpose glue between parsec-like parsing combinator libraries and makes it possible to lift parser combinators over monad transformers, etc.
11:50:18 <raek> or is the "real" end of the stream indicated in some other way?
11:50:28 <edwardk> raek: "real end of stream"
11:50:47 <raek> end of the current bytestring chunk vs end of the file
11:50:52 <edwardk> raek: you can have m capture the current continuation and work prompt-response style in m with runParsecT
11:50:57 <edwardk> end of file
11:51:15 <edwardk> the stream machinery in parsec is quite flexible
11:51:19 * hackagebot git-annex 5.20150406 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20150406 (JoeyHess)
11:51:24 <edwardk> you can do a lot of things it was never intended for with it
11:51:28 <raek> ok, so I need to add ContT to the mix?
11:51:57 <edwardk> well, you'd need something like an iteratee.
11:52:10 <raek> or maybe I could just use ConduitM and make my Stream instance await more data...
11:52:14 <edwardk> yeah
11:52:18 <sw17ch> Anyone here used Cabal to create a Setup script that’s able to install the different bits and pieces into a place that’s more like a system installation rather than a ghc/cabal installation?
11:52:26 <edwardk> ContuitM or Pipe or an Iteratee or whatever
11:52:28 <sw17ch> at least when it comes to binaries and associated files
11:52:39 <edwardk> one of those as long as its monadic and can feed input incrementally
11:52:52 <edwardk> then you can run ParsecT on top of that with your custom Stream instance
11:53:01 <edwardk> that'd be how you'd use parsec out of the box
11:53:29 <raek> yeah, I didn't realize that the little "m" in Stream gave me all this power... :-)
11:53:31 <johnw> Conduipatee
11:54:16 <edwardk> i confess, i've kind of moved on from parsec, but i've used it for some fun tricks before: e.g. you can abuse Stream to implement packrat parsing: http://comonad.com/reader/2011/a-parsec-full-of-rats/ http://comonad.com/reader/2011/a-parsec-full-of-rats-part-2/
11:54:59 <raek> I've been using attoparsec so far, but I couldn't figure out if there is any way to separate tokenization from parsing with it
11:55:56 <raek> as far as I can tell, parsec only works on ByteString or Text streams
11:56:00 <raek> *attoparsec
11:56:59 <raek> I need to tokenize, the perform macro expansion on the tokens and then parse an AST out from the tokens
11:58:14 <raek> a parsec Stream instance that uses conduit sounds like a good idea. I think I'll look at that first.
11:58:19 <raek> thanks edwardk!
11:59:07 <edwardk> attoparsec is limited to the character case, as is, sadly, my parsers library.
11:59:27 <edwardk> i tend to do tokenization in my parsing combinators themselves rather than in a separate traditional lexer.
11:59:49 <edwardk> then if the tokenization is expensive, i can hide that behind packrat-style tricks
12:00:34 <johnw> summoning edwardk is like launching a stinger missile at an incoming question
12:00:44 <edwardk> separate tokenization is (for the most part) an artifact of LALR style parsing which really needed that to increase the effective reach of the (1) in LR(1) to something useful
12:01:32 <raek> if I weren't parsing C, I wouldn't bother separating lexing and parsing... :-)
12:01:36 <edwardk> johnw: you'd probably do better with a Patriot or something that is explicitly anti-missile ;)
12:02:09 <edwardk> you can still fuse the C-lexer into the parser, replete with the lexer hack
12:02:48 <edwardk> you already have to hack up the grammar to get it into LL form anyways
12:02:59 <raek> but what about macro expansion and token concatenation (##)?
12:03:25 <raek> and the fact that whitespace is not allowed in certain places in the syntax?
12:03:39 <levi> So you're doing CPP + C in the same parser?
12:03:40 <edwardk> that is a bit trickier. i wound up dealing with that with a 'parser transformer' but i never managed to get around to releasing that code for trifecta. =(
12:03:53 <raek> eg. #define MAX<here>(x, y) (...)
12:04:16 <raek> levi: yes, to get correct source locations
12:04:41 <edwardk> the whitespace control is more about keeping track if you have preceding whitespace before parsing the (
12:04:42 <johnw> raek: you may want to create a parsing conduit that handles the CPP part, and then fuse that with a parsing conduit for the C part
12:05:00 <johnw> err, not fuse, just $=
12:05:17 <johnw> i.e., avoid conflating the two parsers
12:05:25 <edwardk> my best version of the location information was to track the include stack and current macro expansions in the location data type.
12:05:32 <raek> johnw: yes, I'm writing the "parser" as multiple steps
12:05:34 <levi> johnw: I was thinking that, but you'd have to transform your text type to an annotated text type, and that could run into the same issues as using a separate lexer.
12:05:44 <johnw> yeah, true
12:05:54 <johnw> also, you'd want an expansion "stack", for multiple locations
12:06:27 <raek> (file -> lines -> include handling) -> lines -> tokens -> macro expansion -> parsing
12:06:30 <raek> something like that
12:06:42 <raek> where the part in parentheses can invoke itself recusively
12:06:50 <njksdnf> is there a function like (.) that can combine functions that take different numbers of arguments?
12:07:07 <johnw> njksdnf: there are a whole bunch of such operators
12:07:07 <edwardk> i used to be kinda crazy and maintained that 'delta' as a monoid, so that i could actually do monoidal C preprocessing, basically scanning for #'d lines, setting up that skeleton with the uninterpreted text for the range in between, parsing and handling defines to figure out what includes to run, then lazily deferring the evaluation of the macros in the text
12:07:07 <edwardk> between #'s
12:07:15 <johnw> nearly none of them are worth the trouble of memorizing them
12:07:18 <edwardk> turns out that is quite hard
12:07:19 <edwardk> =)
12:07:25 <edwardk> but lets me steal a bit of parallelism
12:07:39 <njksdnf> johnw: basically I want to evaluate functions in order
12:08:04 <johnw> njksdnf: I'm not sure I follow then
12:08:17 <njksdnf> :t ((.) (:))
12:08:18 <lambdabot> (a -> a1) -> a -> [a1] -> [a1]
12:08:47 <edwardk> raek: anyways you can get 90% of what you'd want in a two phase manner, parse CPP, leaving line directives, then write a normal parser and just leave in the handler for line directives in the whitespace parser, which just changes the current location to match
12:09:03 <edwardk> this doesn't get you 'what macros are being expanded and their source location and arguments'
12:09:15 <edwardk> but it gets you everything else and is suitable for 90% of the usecases folks have
12:09:30 <raek> edwardk: I see. but I
12:09:32 <njksdnf> has anyone used the 'indentation' package?
12:09:33 <edwardk> to show active macros and arguments to get full clang-style diagnostics is harder
12:09:37 <johnw> the EDG parser tracks this using "annotations"
12:09:51 <johnw> so the output is a text stream, but there is this set of structure that apply an annotation to ranges within that stream
12:09:52 <raek> 'm writing this for myself and I'm one of the 10%... :-)
12:09:59 <edwardk> raek: fair enough
12:10:07 <johnw> so you can ask "what all was involved in this text HERE"
12:10:24 <raek> edwardk: but separating CPP from C is probably the most sane approach in general, yes
12:10:26 <edwardk> i can see if i can resurrect the CPP transformer code that i had for trifecta, but have rather limited free time at the moment and its against quite an old version of trifecta
12:10:40 <njksdnf> :t concat
12:10:41 <lambdabot> Foldable t => t [a] -> [a]
12:11:11 <raek> edwardk: don't worry about it. I need to explore this problem space a bit further anyway
12:11:36 <edwardk> you could in theory do the same thing as the #line directive residues for the macro expansions, leave an out of band signal for what macros were expanded where, what the original source location was for the macro, and what arguments were fed to it and stash that, then when you encounter an error in the expanded region you can tag it with the original
12:11:36 <edwardk> location as well and the arguments
12:11:39 <raek> this just one of my hobby projects after all
12:11:59 <mauke> "(file -> lines -> include handling) -> lines -> tokens -> macro expansion -> parsing" <- if this is supposed to be strictly sequential, it can't work
12:12:02 <raek> yeah. the #line directive is even in the standard, right?
12:12:02 <edwardk> one of the designs i experimented with used an interval tree to track such regions in the resulting source file
12:12:06 <edwardk> yes
12:12:08 <njksdnf> :t (((,) ()) (.) (:))
12:12:09 <lambdabot>     Couldn't match expected type ‘(a1 -> [a1] -> [a1]) -> t’
12:12:09 <lambdabot>                 with actual type ‘((), (b0 -> c0) -> (a0 -> b0) -> a0 -> c0)’
12:12:09 <lambdabot>     The function ‘(,)’ is applied to three arguments,
12:12:17 <edwardk> but there isn't such a corresponding standard for macro expansions
12:12:37 <njksdnf> ^ is there a way to combine functions without 'changing' the domain of the first function?
12:12:45 <edwardk> you can of course use the #pragma space to shove whatever made up stuff you want in though
12:13:03 <njksdnf> because . curries the functions and make a domain constraint on the first argument
12:13:13 <mauke> njksdnf: huh?
12:13:14 <levi> Although the general theory of parsing is pretty well-explored, the nitty-gritty details of parsing in real-world compilers that attempt to have helpful error messages and such are rarely served by general-purpose compiler machinery. :(
12:13:44 <raek> mauke: I'm thinking about keeping current source location and macro environment in StateT, but to be honest I haven't thought all this through
12:13:44 <njksdnf> mauke: '(((,) ()) . (:))'
12:13:55 <mauke> njksdnf: what
12:13:59 <edwardk> the nice thing about just writing a parser that happens to recognize #line pragmas in the whitespace parser is that you can test with an off the shelf cpp without getting that part of your code right day 1 ;)
12:14:14 <njksdnf> mauke: how do i make something like that work?
12:14:25 <mauke> njksdnf: I have no idea what you're trying to do
12:14:43 <levi> Why would you want something like that to work?
12:14:45 <njksdnf> im trying to use (.) to combine functions that take different numbers of arguments
12:14:47 <enthropy> :t ((,) ()) . (:)
12:14:48 <lambdabot> a -> ((), [a] -> [a])
12:14:51 <enthropy> it does "work"
12:14:56 <mauke> njksdnf: have you tried using a lambda?
12:14:57 <johnw> @pl \x ys -> ((), x:ys)
12:14:58 <lambdabot> ((,) () .) . (:)
12:15:06 <KorriX> Hello! How to make some optional field in attoparsec?
12:15:11 <johnw> i think he wants ((,) ()) .: (:)
12:15:18 <johnw> from one of the packages that supplies (.:)
12:15:23 <raek> edwardk: I could still make such a test by only using the first half of the conduit pipeline though
12:15:39 <raek> with a special sink that emits #line lines
12:15:44 <enthropy> http://code.haskell.org/HList/Data/HList/HCurry.hs maybe this?
12:15:45 <johnw> KorriX: just try to parse it, and do something if it fails
12:15:54 <johnw> i.e., myParser <|> pure someDefault
12:15:55 <njksdnf> :t (((,) ()) . (:))
12:15:57 <lambdabot> a -> ((), [a] -> [a])
12:16:00 <njksdnf> huh
12:16:10 <KorriX> johnw: Thanks
12:16:22 <njksdnf> :t (.:)
12:16:23 <lambdabot>     Not in scope: ‘.:’
12:16:23 <lambdabot>     Perhaps you meant one of these:
12:16:23 <lambdabot>       ‘.’ (imported from Data.Function),
12:17:07 <johnw> njksdnf: it's from Hackage, not in base
12:17:09 <raek> johnw: is that equivalent to "option someDefault myParser"?
12:17:20 <njksdnf> what package johnw ?
12:17:22 <johnw> raek: oh, probably
12:17:33 <johnw> pointless-fun, I think
12:18:36 <KorriX> johnw: but how to define function Parser a -> Parser (Maybe a)
12:19:04 <ion> foo p = (Just <$> p) <|> pure Nothing or something like that
12:19:07 <johnw> Just <$> myParser <|> pure Nothing
12:19:11 <johnw> uh, yeah
12:19:53 <KorriX> johnw: thx
12:20:01 <Mattyjesq> can anyone help me get all the webpages inside a folder at pamperedchef.com/pws/ ... I tried dirbuster but couldn't get it
12:20:24 <em> Is the idea of a monad in any way related to Leibniz concept of monads?
12:20:55 <mauke> Mattyjesq: does that have anything to do with haskell?
12:21:00 <mauke> em: no
12:21:02 <johnw> em: not at all
12:21:19 <cfoch> haskell.gsoc
12:21:20 <johnw> Leibniz's monads are from 1714, as a concept in his philosophy
12:21:27 <cfoch> (sorry)
12:21:27 <Mattyjesq> um srry wrong chat
12:22:15 <ski> em : only very indirectly. i think Category Theory got the word "monad" from Leibniz (but the concept is different). then Moggi started using monads in semantics of programming, and Wadler started using them in programming
12:22:19 <johnw> em: http://english.stackexchange.com/questions/30654/where-does-the-term-monad-come-from
12:22:33 <raek> the Partially Examined Life podcast has an interesting episode on Monadology
12:22:47 <ski> (CT probably also chose the word "monad", since it sounds a bit like "monoid", which is related to the CT concept)
12:23:15 <johnw> yeah, that webpage suggests it might be a contraction of "monoidal triad"
12:23:19 <johnw> but who really knows
12:24:11 <levi> I tracked down a bit of the history of the usage of the word 'functor' in a few contexts. It means quite a lot of different things these days.
12:24:32 <ski> (the word "monad" is also used in some esoteric writings. i assume they got the term from Leibniz)
12:25:04 <ski> @where on-functors
12:25:04 <lambdabot> "On Functors" (in C++,Standard ML,Haskell,Prolog) by Peteris Krumins in 2010-05-17 at <http://www.catonmat.net/blog/on-functors/>
12:25:11 <ski> (has four meanings)
12:25:28 <levi> Four meanings *in programming*; there are lots of uses outside of programming.
12:25:31 <johnw> it adds fun to your ctors, clearly
12:26:04 <ski> levi : the Prolog one comes from predicate logic, iirc
12:26:18 <levi> For what it's worth, here's my writeup of what I found: http://pinealservo.com/posts/2014-10-22-ManyFunctionsOfFunctor.html
12:26:21 <ski> ty
12:26:29 <levi> It's got lots of references at the end.
12:27:23 <levi> Hmm, no, in this form they're all embedded as links.
12:28:06 <levi> But anyway, I tried to follow things back to original sources as much as possible without a real library handy.
12:30:25 <raek> levi: cool!
12:31:22 * hackagebot stm-conduit 2.6.0 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-2.6.0 (ClarkGaebel)
12:31:45 <levi> As an aside, my research also uncovered the origin of the term 'Polish Notation'. :)
12:33:22 <ski> levi : elaborate ? :)
12:34:31 <levi> Some Polish logicians came up with a notation in which they placed their functors before their arguments, thereby allowing expressions to be unambigious without parentheses.
12:35:23 <raek> "Łukasiewicz [woo-kah-SHEV-ich] Notation" too difficult to pronounce?
12:35:49 <mauke> are you sure about the "sh"?
12:36:48 <kadoban> That's what wikipedia says at least
12:37:49 <raek> mauke: well, English does not differentiate Polish "ś" (written as "si" before a vowel") and "sz"...
12:38:54 <raek> it's not pronounced as an "s"
12:39:25 <mauke> https://www.youtube.com/watch?v=4XfEtymyXJ0&t=88s
12:39:27 <mauke> I see
12:41:39 <levi> I think the real story is that logicians, mathematicians, and pretty much any other branch of theoretician is always looking for obscure but memorable words to use for the concepts they come up with. Words like 'Functor' and 'Monad' just sound too meaningful (yet without any real meaning in the common lexicon) to avoid regularly re-purposing them in various contexts.
12:46:19 <Zemyla> Hmm, is the CPSed state monad more like the strict state monad or the lazy state monad in its semantics?
12:49:01 <athan> If you wanted to handle uploaded content, what would `z` be if the handler needed a signature of `ByteString -> z`?
12:49:06 <athan> ideally, for your own personal use?
12:49:51 <athan> I was thinking just `IO ()`, for people that want to push the uploaded content to storage, but I just don't know
12:50:41 <njksdnf> Don't use impure types if you don't have too
12:50:52 <njksdnf> user can always lift to IO
12:51:10 <athan> njksdnf: I'm not sure sure :\
12:53:56 <athan> One major issue I'm running into is this:
12:54:23 <athan> currently, I've got some complicated monad writers keeping everything together - you can imagine them to be writing to Maps or something
12:54:32 <athan> now, what I'm working on is a router for Wai
12:54:43 <athan> this means that the Map is holding on to Wai's Response data type
12:54:51 <athan> here's the stick in the spoke
12:55:20 <athan> I would like to turn it into a Map of pairs (ByteString -> m z, Response), where `m` unifies with the rest of my transformer stack
12:55:33 <athan> but, this completely screws up my standalone derivability
12:55:43 <athan> I'm just not sure how to gear this
12:56:17 <athan> that's why I kept it as `ByteString -> z`, but this also means that per-request, all I'm doing is running the function on the data and throwing it away
12:56:27 <sinelaw> arg.  lifting the eitherT func into a monad transformer stack... 
12:56:28 <athan> it's no good :\
12:56:38 <sinelaw> trial & error
12:56:42 <athan> :S
13:01:23 * hackagebot ide-backend 0.9.0.7 - An IDE backend library  http://hackage.haskell.org/package/ide-backend-0.9.0.7 (MichaelSnoyman)
13:04:05 <Zemyla> I'm sad because I just realized that Set can't be a law-abiding Functor, and now I'm wondering if it's worth the effort to try and make a Functor instance for it that tries to tell Ord values from non-Ord values.
13:04:42 <athan> Zemyla: ):
13:04:57 <Taneb> Zemyla, enough people have tried that I think the answer must be "no"
13:05:17 <Zemyla> I just want it to work with the syntactic sugar of Haskell.
13:05:20 <athan> Map can't be applicative/monad, it's wrecking me
13:05:53 <athan> Can `Foo z m a = Foo {unFoo :: z -> m a}` be a monad?
13:06:07 <athan> er can (Foo z m) be a monad?
13:06:14 <Hijiri> isn't that ReaderT?
13:06:20 <Zemyla> Yes, it is.
13:06:22 <athan> Hijiri: ><
13:06:28 <athan> wrecked
13:06:30 <athan> thanks :)
13:07:38 <EvanR> too much syntax sugar will rot your brain!
13:07:54 <shachaf> You can make a Coyoneda version of Set which is a functor, but it isn't that great.
13:08:27 <Kaligule> Hi
13:08:30 <Kaligule> I am having touble with installing music pitch: github.com/music-suite/music-pitch with cabal install I get an cabal Error with "ExitFailure 1"
13:08:32 <EvanR> you can make a similar-looking to <$> operator that does Set map, with the correct type
13:08:40 <Kaligule> What am I dupposed to do about that?
13:08:51 <roboguy_> Kaligule: that could be pretty much any error. We'll need more info
13:08:52 <EvanR> with correct implications
13:09:26 <KrzyStar> Whazza
13:09:35 <KrzyStar> How do you disable chatting mode in lambdabot? :v
13:10:02 <Kaligule> roboguy_: I did "cabal update" and wrote "cabal install music-pitch" Then this error message came up
13:10:10 <roboguy_> Kaligule: you can paste the error here: http://lpaste.net/new/haskell
13:10:17 <roboguy_> Kaligule: I think all cabal errors end with "ExitFailure 1"
13:10:26 <EvanR> Zemyla: perhaps Bag instead
13:10:38 <kadoban> Darn, the stackage lts targetting ghc 7.10 won't be until like august? Was hoping it'd be sooner.
13:12:09 <Kaligule> roboguy_: http://lpaste.net/130263
13:12:23 <bergmark> kadoban: still lots of packages that don't support 7.10...
13:12:43 <mauke> the actual error message: ghc: unrecognised flags: -fno-warn-typed-holes
13:13:10 <kadoban> bergmark: Yeah, I figured. I really had no idea at all how long those would take to fix. I'm sure my expectations were ridiculously optimistic.
13:14:12 <Kaligule> mauke: Always when I think I get the real information out of that ghc it fools me again.
13:14:36 <bergmark> and there are also a lot more packages in stackage now compared to when 7.8 came out
13:15:00 <Kaligule> mauke: I suppose my ghc version is too old, then. Thanks.
13:15:09 <mauke> yeah, or too new
13:15:20 <mauke> anyway the package is not compatible with it :-(
13:15:26 <bergmark> Kaligule: you need ghc >= 7.8
13:19:11 <lincoln99672> how do I tell cabal where to search for .so files?  http://pastebin.com/tWFcjY5D
13:19:58 <lincoln99672> cabal claims it can't fine libzmq.so.4 but I specified /usr/local/lib on command line, where this file can be found
13:22:19 <mauke> I don't think that error comes from cabal, and my first guess would be that your zeromq4-haskell install is broken
13:26:29 * hackagebot tasty-silver 3.1.3 - Golden tests support for tasty. Fork of tasty-golden.  http://hackage.haskell.org/package/tasty-silver-3.1.3 (PhilippHausmann)
13:26:40 <lincoln99672>  cabal install zeromq4-haskell    succeeds with no errors, instlaling 0.6.3 as expected
13:27:04 <lincoln99672> mauke: is it possible it is broken although install reports no error?
13:27:24 <mauke> I don't know
13:37:04 <Lokathor> so does haskell get buffer overflow problems?
13:37:10 <Lokathor> (when using FFI)
13:37:12 <Lokathor> er
13:37:13 <Lokathor> not
13:37:15 <Lokathor> when not using FFI
13:37:35 <EvanR> no since you dont usually have any buffers
13:37:52 <EvanR> ByteStrings are immutable
13:38:09 <Lokathor> fancy
13:38:58 <EvanR> but theres plenty of ways to screw up and introduce security problems
13:39:16 <EvanR> buffer overflow is just one really obvious and stupid one you can easily avoid
13:39:26 <mauke> non-C languages generally don't suffer from buffer overflows
13:39:31 <Lokathor> i would assume there's always at least one more way to screw up
13:39:50 <mauke> you still get to have fun with race conditions, sql/html injections, etc
13:40:42 <Lokathor> yeah in the current version of a project, "chat" gets sent from one person to the other, but then the rendering interprets tags
13:40:49 <Lokathor> so you can run scripts on their machine >_>
13:44:57 <rnhmjoj> How can I interpret a ByteString as say a list of Int?
13:45:40 <ReinH> rnhmjoj: depends on how the list of Int is encoded in the ByteString
13:45:42 <rnhmjoj> In python I would do something like: struct.unpack('hhl', b'\x00\x01\x00\x02\x00\x00\x00\x03') == (1, 2, 3)
13:45:47 <raek> with parsec, is it possible to get the unconsumed part of the stream back after parsing?
13:45:59 <ReinH> @hoogle binary -- rnhmjoj
13:46:00 <lambdabot> Parse error:
13:46:01 <roboguy_> @hackage binary
13:46:01 <lambdabot>   binary -- rnhmjoj
13:46:01 <lambdabot>            ^
13:46:01 <lambdabot> http://hackage.haskell.org/package/binary
13:46:13 <ReinH> Woah, that's spamier than I remember :(
13:46:26 <raek> or should I design my Stream in such a way that it stores the remainder of the input in the monad state?
13:46:36 <roboguy_> ReinH: well, the last line was me probably
13:46:55 <ReinH> roboguy_: Oh. I hoogled instead of hackaged. Woops.
13:48:53 <rnhmjoj> decode from Data.Binary seems what I need. Thank you.
13:58:22 <drewbert> How does ghc-mod report errors so much faster than ghc?
13:59:21 <raek> found an answer to my question: Text.Parsec.Prim.getInput
14:05:42 <dmj`> what fixity number is ($)?
14:06:07 <johnw> dmj`: you mean, what :i ($) tells you in ghci?
14:06:22 <dmj`> johnw: oh :)
14:06:25 <dmj`> johnw: tanks
14:07:09 <arkeet> > (0$0$)
14:07:10 <lambdabot>      The operator ‘$’ [infixr 0] of a section
14:07:10 <lambdabot>          must have lower precedence than that of the operand,
14:07:10 <lambdabot>            namely ‘$’ [infixr 0]
14:07:37 <arkeet> > (0$0:)
14:07:39 <lambdabot>      The operator ‘:’ [infixr 5] of a section
14:07:39 <lambdabot>          must have lower precedence than that of the operand,
14:07:39 <lambdabot>            namely ‘$’ [infixr 0]
14:08:54 <roboguy_> Is there a reason that lambdabot doesn't do :i or :kind!, or is it just that no one has gotten around to it?
14:09:18 <dmj`> :k Maybe
14:09:19 <lambdabot> * -> *
14:09:25 <dmj`> @info Maybe
14:09:25 <lambdabot> Maybe
14:10:09 <roboguy_> dmj`: oh, cool. Thanks. Does it do ":kind!"?
14:11:02 <dmj`> @kind Maybe
14:11:03 <lambdabot> * -> *
14:11:30 <dmj`> doesn't look like it
14:11:34 <arkeet> what is ":kind!"?
14:11:41 <dmj`> λ: :kind! Maybe
14:11:42 <dmj`> Maybe :: * -> *
14:11:42 <dmj`> = Maybe
14:11:53 <roboguy_> arkeet: it typically applies type functions and shows the result of that application
14:12:03 <athan> arkeet: Sometimes it forces type exectuion of type families
14:12:05 <johnw> > (0.0.(
14:12:07 <lambdabot>  <hint>:1:7:
14:12:07 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
14:12:07 <johnw> > (0.0.)
14:12:09 <lambdabot>      No instance for (Typeable b0)
14:12:09 <lambdabot>        arising from a use of ‘show_M34987033027804841325986’
14:12:09 <lambdabot>      In the expression:
14:12:09 <arkeet> ah
14:12:18 <arkeet> > (.0.0)
14:12:20 <lambdabot>      No instance for (Typeable b0)
14:12:21 <lambdabot>        arising from a use of ‘show_M21476046635958609086003’
14:12:21 <lambdabot>      In the expression:
14:12:29 <dmj`> :kind Maybe Int
14:12:30 <arkeet> interesting
14:12:37 <dmj`> @kind Maybe Int
14:12:38 <lambdabot> *
14:13:36 <roboguy_> arkeet: I used it an a stackoverflow answer one time: http://stackoverflow.com/questions/25329263/can-you-do-pattern-matching-on-the-type-level-in-haskell/25329298#25329298
14:16:45 <roboguy_> a smaller example would be something like: :kind! Int == Char         Int == Char :: Bool       = 'False
14:17:44 <Lokathor> i had a problem with my Java the other day
14:17:50 <_ryan> hi everyone is it possible yo hash and input? e.g password?
14:17:55 <Lokathor> (one among many, har har and such)
14:18:42 <_ryan> s/yo/to
14:18:51 <Lokathor> I had a static method that just needed a way to get a random double, and i wanted to accept a thing based on an interface for that, and then say that java.util.Random was an instance of that interface
14:18:57 <Lokathor> but i could not do this :/
14:19:28 <roboguy_> _ryan: yeah. Anything's possible (as long as it is computable)
14:19:29 <Lokathor> _ryan, i assume that you can hash an input somehow. What is the goal of hashing it?
14:19:54 <_ryan> for login purpose and registring
14:19:55 <arw> _ryan: for passwords, there is https://hackage.haskell.org/package/Unixutils-1.48.1/docs/System-Unix-Crypt.html for example
14:20:23 <_ryan> arw: does it allow also to devrypt?
14:20:35 <_ryan> arw: i mean decrypt?
14:20:54 <arw> _ryan: no, of course not, its a hash. the name is just very misleading
14:21:12 <Lokathor> the doc formatting is also messed up
14:21:26 <dmj`> _ryan: I'd check out scrypt
14:21:32 <Lokathor> haddock read "/etc/shadow" and converted it to "<i>etc</i>shadow"
14:21:49 <_ryan> arw: ah sorry i didn't read first the docs. :-) thank you.
14:21:59 <dmj`> _ryan: @package scrypt
14:22:01 <dmj`> @package scrypt
14:22:01 <lambdabot> http://hackage.haskell.org/package/scrypt
14:22:28 <arw> _ryan: depending on what exactly the passwords should be used for, other packages might be preferable.
14:22:43 <_ryan> arw: thank you
14:23:19 <arkeet> from a security standpoint, you shouldn't encrypt passwords (implying reversible), or simply hash them.
14:23:41 <arkeet> well what do you know, hackage has a pbkdf2 package.
14:23:46 <arkeet> https://hackage.haskell.org/package/PBKDF2
14:23:48 <arw> _ryan: System.Unix.Crypt gives you hashes that are compatible with unix login password hashes. but the usage is not as simple as one might wish.
14:23:51 <arkeet> ph it's deprecated.
14:24:01 <arkeet> ok, use one of its replacements.
14:24:51 <dmj`> use scrypt
14:25:09 <arkeet> yeah scrypt looks good.
14:25:36 <arkeet> bcrypt also looks fine
14:25:57 <ion> http://www.unlimitednovelty.com/2012/03/dont-use-bcrypt.html
14:26:08 <dmj`> ^
14:26:10 <arkeet> ic
14:26:39 * hackagebot git-annex 5.20150406.1 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20150406.1 (JoeyHess)
14:26:42 <levi> Crypto: You're Doing It Wrong
14:28:22 <levi> Not to belittle the efforts of people trying to get it right; it's just one of those hard things that nearly everyone gets wrong, sometimes in ways that don't become apparent until years after the fact.
14:28:33 <arkeet> sure.
14:29:03 <arkeet> if you need it you should probably research it more than I have.
14:29:09 <_ryan> arw: what do you mean by - "usage is not as simple as one might wish?"
14:29:51 <arw> _ryan: you have to read the manpage of your systems crypt() libc function, which this module wraps
14:30:24 <_ryan> arw: got it thank you...
14:30:27 <arw> _ryan: and for generating a new hash from a password, you have to supply the random salt yourself in the right format
14:30:52 <_ryan> got it..
14:31:39 * hackagebot Rasterific 0.5.2.1 - A pure haskell drawing engine.  http://hackage.haskell.org/package/Rasterific-0.5.2.1 (VincentBerthoux)
14:31:41 * hackagebot stack-prism 0.1.3 - Stack prisms  http://hackage.haskell.org/package/stack-prism-0.1.3 (MartijnVanSteenbergen)
14:32:22 <arw> _ryan: oh, and use the more secure hash formats, $6$ is 100 rounds of sha-512, the rest is weaker (though with the exception of DES not totally useless)
14:32:56 <johnw> do more rounds help sha-512?
14:33:35 <arw> johnw: yes.
14:33:42 <kadoban> johnw: It's a hardening thing, it makes it take more time to brute-force, since there's no (known) shortcut to doing N rounds of a secure hash.
14:34:06 <johnw> ah, ok
14:34:20 <arw> johnw: a single round of sha-* is quite simple to crack in hardware and even software.
14:34:23 * johnw makes a note not to announce his shortcut
14:34:48 <ReinH> johnw: not significantly
14:35:34 <arw> ReinH: how do you mean?
14:36:00 <ReinH> The SHA family of functions are far too fast
14:36:35 <arw> ReinH: thats why you do multiple iterations.
14:36:40 * hackagebot svg-tree 0.2 - SVG file loader and serializer  http://hackage.haskell.org/package/svg-tree-0.2 (VincentBerthoux)
14:36:45 <ReinH> arw: Still too fast
14:36:50 <ReinH> by a few orders of magnitude
14:37:21 <ReinH> You want to use bcrypt, scrypt, PBKDF2, etc
14:41:01 <johnw> "I'll have 5 orders of magnitude, please".
14:41:33 <__ryan> arw: can you give me a snippet for that? if it is ok?
14:41:36 <arw> ReinH: that strongly depends on the tuning parameters of those packages.
14:41:42 * hackagebot rasterific-svg 0.1.1 - SVG renderer based on Rasterific.  http://hackage.haskell.org/package/rasterific-svg-0.1.1 (VincentBerthoux)
14:41:44 * hackagebot tfp 1.0 - Type-level integers, booleans, lists using type families  http://hackage.haskell.org/package/tfp-1.0 (HenningThielemann)
14:41:46 <ReinH> The main reason to recommend bcrypt or scrypt is simply that it's much harder to use them incorrectly, since they are designed to be slow rather than to be fast.
14:41:46 * hackagebot llvm-tf 3.0.3.1 - Bindings to the LLVM compiler toolkit using type families.  http://hackage.haskell.org/package/llvm-tf-3.0.3.1 (HenningThielemann)
14:42:30 <__ryan> arw: also i try to use the package that you gave to me it says that the module is not found.
14:43:07 <arw> __ryan: problem is, it won't work on non-linux.
14:43:31 <arw> __ryan: or rather, non-unix, but i don't know about macOS
14:43:50 <__ryan> arw: do you have some other options?
14:45:08 <arw> __ryan: pbkdf2 should be fine, but i'm not sure which package you would want to use
14:46:05 <__ryan> arw: how about this http://haddocks.fpcomplete.com/fp/7.8/20140916-162/pureMD5/Data-Digest-Pure-MD5.html#v:md5
14:46:39 <arw> __ryan: scrypt and bcrypt might be fine, but i'm not sure how many of the right people have looked at it
14:46:42 * hackagebot llvm-extra 0.6 - Utility functions for the llvm interface  http://hackage.haskell.org/package/llvm-extra-0.6 (HenningThielemann)
14:46:50 <arw> __ryan: nope.
14:47:16 <arw> __ryan: definitely not for passwords, under no circumstances whatsoever
14:48:06 <__ryan> arw: thanks - so what about the pbkdf2?
14:48:21 <__ryan> arw: thanks - what does pbkdf2 mean?
14:48:49 <arw> http://en.wikipedia.org/wiki/PBKDF2
14:50:28 <bergmark> PBKDF2 is deprecated
14:51:17 <johnw> bergmark: in favor of what?
14:51:26 <bergmark> says on hackage! http://hackage.haskell.org/package/PBKDF2
14:51:42 * hackagebot synthesizer-llvm 0.7 - Efficient signal processing using runtime compilation  http://hackage.haskell.org/package/synthesizer-llvm-0.7 (HenningThielemann)
14:52:09 <kadoban> johnw: Probably stuff like scrypt
14:52:16 <arw> the package is deprecated in favour of stuff like 'pbkdf'...
14:52:23 <arw> which I hope isn't pbkdf1...
14:52:50 <__ryan> arw: http://haddocks.fpcomplete.com/fp/7.8/20140916-162/pwstore-fast/Crypto-PasswordStore.html
14:52:52 <arw> the algorithm itself should be quite fine for a while
14:53:51 <arw> __ryan: looks good
14:54:08 <brauz> hello, I want to combine two datas into one data and use the combined datatype as a type for a function, the following doesnt work http://lpaste.net/2857335819545346048 how can I fix this? (Expr has to be either IExpr or BExpr) I get errors like this: Couldn't match expected type ‘Expr’ with actual type ‘IExpr’
14:54:36 <__ryan> arw: so what do you suggest? pbkdf2 is good?
14:55:52 <johnw> http://www.happybearsoftware.com/you-are-dangerously-bad-at-cryptography.html
14:56:03 <arw> __ryan: yes, use pbkdf2, strength factor 14, then you should be fine
14:56:43 * hackagebot synthesizer-llvm 0.7.0.1 - Efficient signal processing using runtime compilation  http://hackage.haskell.org/package/synthesizer-llvm-0.7.0.1 (HenningThielemann)
14:56:50 <kadoban> Well, pbkdf2 type things have a definite weakness, in that it's possible to make an ASIC, or other special-purpose unit, for them that is orders of magnitude faster than the usual client would be. But it's not that bad.
14:56:57 <earthy> pbkdf2 is better than many other things, bcrypt is better than pbkdf2.
14:57:01 <glguy> brauz: zetom :: Either IExpr BExpr -> [VStackExpr]
14:57:20 <__ryan> arw: it requires a salt? how do i that?
14:57:27 <earthy> (bcrypt by default encodes the strength in the generated hash, for example)
14:57:29 <glguy> brauz: When you wrote "data Expr = BExpr | IExpr" You created new data constructors "BExpr" and "IExpr"
14:57:43 <glguy> which aren't related to the type constructors defined above them in any way
14:58:29 <arw> __ryan: you need a secure random number generator to create it
14:58:38 <glguy> brauz: If you want you can write:
14:58:39 <glguy> 03data Expr 07= BExpr BExpr 07| IExpr IExpr
14:58:49 <glguy> Or you could be more explicit and write:
14:58:57 <glguy> 03data Expr 07= MkBExpr BExpr 07| MkIExpr IExpr
14:59:23 <jellie> How can I access the info under <plaintext> which is under the pod with title of "Result" using the XML package?
14:59:30 <__ryan> arw: http://haddocks.fpcomplete.com/fp/7.8/20140916-162/pwstore-fast/Crypto-PasswordStore.html#t:Salt
14:59:34 <roboguy_> drewbert: ghc-mod probably just type checks and doesn't try to build an executable
14:59:35 <arw> __ryan: but you should use 'makePasswordWith pbkdf2', that handles the salt stuff for you
15:00:06 <drewbert> roboguy_: That's what I assumed, but I was wondering if anybody knew for sure.
15:01:09 <__ryan> arw: if i use this makePasswordWith pbkdf1 "password" 14 - where is the salt part?
15:03:36 <brauz> glguy: I got it, thank you!
15:03:45 <arw> __ryan: its randomly generated for you. "Generates a salt using high-quality randomness"
15:07:06 <__ryan> arw: got it - if it generates a random salt - how would i verify it from the input of the user and once the use login
15:08:19 <roboguy_> I like that the wikipedia page on cryptographic salts has both a "Benefits" and an "Additional benefits" section
15:10:28 <monochrom> add a "bonus benefits" section
15:10:38 <johnw> "But wait, there's more!"
15:11:17 <__ryan> arw: maybe i'm the one who will do that.. thank you :)
15:11:32 <monochrom> then "redeem these coupons for more benefits" and "customers who have used cryptographic salts also like"
15:11:44 * hackagebot reactive-banana 0.8.1.0 - Library for functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.8.1.0 (HeinrichApfelmus)
15:14:16 <arw> __ryan: the salt is included in the output of makePasswordWith
15:14:32 <__ryan> arw: thank you
15:15:13 <roboguy_> __ryan: I think you hash it with the same salt when you want to check if the password is correct
15:15:48 <__ryan> roboguy: same idea thanks :)
15:16:05 <RyanGlScott> Is AutoDeriveTypeable enabled by default in GHC 7.10.1?
15:16:09 <arw> yes, but the check-function does all that for you
15:20:04 <RyanGlScott> I ask since all data types defined in GHCi now seem to have Typeable instances, even if they're not explicitly derived.
15:21:41 <monochrom> yes
15:23:35 <RyanGlScott> monochrom: Is this documented somewhere? The 7.10.1 release notes ( https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/release-7-10-1.html ) don't say anything about this.
15:23:41 <doweaver> Say I have a custom data structure Foo, with fields Name :: string and Amount :: int. I want to make a function that combines two Foos, but only if they have the same name. I'm curious how you guys would implement that. I could, for example, just have the combining function throw an error if the arguments passed to it have different names... but I'm new to Haskell, and wondering if there's a different
15:23:43 <doweaver> approach that's more "Haskellian"
15:24:03 <monochrom> I don't know
15:24:31 <RyanGlScott> Huh. Even stranger, running :set in GHCi only shows the NoDatatypeContexts and NondecreasingIndentation extensions being on.
15:24:44 <monochrom> don't forget :seti
15:24:53 <EvanR> doweaver: if the best known way to enforce that with types is too much of a pain in the ass, then yeah throw an error. then later prove in your head why that error will never happen
15:25:49 <johnw> doweaver: the question is whether you want it to be an error to do so, or for the combination to be inexpressible in code
15:25:58 <RyanGlScott> monochrom: Even with :seti, it doesn't show up. Besides the ones I mentioned earlier, only ExtendedDefaultRules and NoMonomorphismRestriction are reported.
15:26:09 <johnw> for the latter to be checked at compile-time, you'd have to be dealing in constant strings
15:26:36 <arkeet> strings known at compile time, anyway.
15:26:45 <johnw> yeah, those
15:26:53 <doweaver> EvanR: What exactly do you mean by "enforcing that with types"?
15:27:00 <johnw> Foo "Some name"
15:27:03 <doweaver> EvanR: Not having the Name be a string, but its own type?
15:27:05 <arkeet> making it a type error to combine two Foos with different names.
15:27:11 <arkeet> (by encoding the name in the type.)
15:27:14 <doweaver> Gotcha
15:27:18 <EvanR> thats one way, but they are talking about using strings at the type level
15:27:44 <RyanGlScott> I'm half-convinced this is a bug, but maybe there's a logical reason for not reporting it.
15:27:57 <arkeet> wild guess that that's not something you'd actually want to do.
15:28:09 <johnw> I wonder why it's so rare for people to be 3/4 convinced
15:28:11 <EvanR> its also possible that whatever youre trying to do has a better solution
15:28:16 <RyanGlScott> Running :i Typeable also doesn't report any instances (although I can see why this is the case if all data types are instances)
15:28:23 <arkeet> what EvanR said I guess.
15:28:34 <__ryan> hi once againg. i want to convert the string to bytestring. how do i do that. i use a pack function for Data.ByteString.Char8 but it gives me an error of Couldn't match expected type [t0] with actual type ByteString
15:28:50 <johnw> avoid Char8
15:28:51 <ion> ryan: In what encoding?
15:28:53 <arkeet> no idea what you're using Foo for, but maybe you're interested in some map from names to amounts?
15:28:57 <EvanR> you need to use an encoding, like utf8
15:29:03 <arkeet> (so something like a Map String Int)
15:29:26 <arkeet> and you can combine two Maps, merging key-value pairs if they have keys in common.
15:29:32 <__ryan> ion: don't get it what do you mean?
15:29:42 <arkeet> (say, adding the amounts when they do.)
15:29:45 <ion> ryan: String represents a collection of Unicode codepoints, ByteString represents a collection of bytes. There are multiple mappings between them known as encodings. You’ll need to pick one, such as UTF-8.
15:29:57 <doweaver> arkeet: Hmm. Yeah, I see what you're saying
15:30:01 <EvanR> __ryan: look at Data.Text.Encoding
15:30:07 * monochrom recommends UTF-16384
15:30:48 <doweaver> arkeet: To give a little more context, I'm looking at ingredients in a recipe, and then combining ingredients from a bunch of recipes into a shopping list
15:30:49 <EvanR> UTF-69
15:30:58 <arkeet> mhm.
15:31:19 <arkeet> sounds like each recipe can give you a map from ingredients to amounts, then.
15:32:06 <doweaver> arkeet: Yup... that sounds like a reasonable approach. Thank you!
15:32:19 <__ryan> EvanR: encodeUtf8 :: Text -> ByteString
15:32:32 <monochrom> Data.Map.Strict's unionWith (+) will do the addition for you nicely
15:32:39 <EvanR> you can go back and forth between Text and String using pack and unpack
15:32:53 <monochrom> in fact, unionsWith (+) if you have more than two recipes
15:33:13 <arkeet> or if you want n copies of the same recipe, you can just fmap (*n)
15:33:36 <__ryan> got it thank you
15:34:32 * arkeet wonders how useful it would be if one made Map into a profunctor by Coyonedaing the first argument.
15:35:22 <monochrom> it may be not very useful
15:35:27 <arkeet> probably not. :)
15:35:41 <johnw> in what way do you want to make use of its profunctoriality?
15:35:44 <monochrom> but I only know coyoneda, I don't know profunctor yet, I think
15:35:48 <arkeet> johnw: I don't know!
15:35:52 <arkeet> that's the question.
15:36:09 <johnw> well, it would let you transform the set of keys until you actually made a query
15:36:09 <monochrom> there is one thing coyoneda forbids you from doing, and one thing it does wrong
15:36:20 <johnw> monochrom: hmm?
15:36:35 <monochrom> suppose you have a Set Int and you convert it to coyoneda
15:36:39 <johnw> but to do that, you'd probably need a Monoid constraint on the values
15:36:51 <monochrom> after converting, you cannot insert or delete an element
15:37:15 <arkeet> I think you can, but what you get might not be what you expect.
15:37:46 <arkeet> insert x (Coyoneda f s) = Coyoneda f (insert (f x) s)
15:38:11 <arkeet> but that would end up inserting all the preimages of f x
15:38:36 <Javran> I want to know something about coyoneda/yoneda stuff, but gets a little confused, as we have Control.{Functor,Contravariant}.{Coyoneda,Yoneda} :(
15:38:47 <johnw> would there be two flavors: Coyoneda (a -> b) (Set b) and Coyoneda (a -> b) (Set a)?
15:39:05 <arkeet> johnw: talking about the former, in this case.
15:39:08 <johnw> ok
15:39:08 <arkeet> the contravaraint one.
15:39:22 <johnw> or rather, Coyenada on Hask^op
15:40:20 <monochrom> arkeet, Coyoneda is an existential type. the computer forgets that s has type Set Int. it only knows s :: Set t "for some t"
15:40:35 <monochrom> oh nevermind, you are doing a different thing
15:41:20 <monochrom> well, it also forgets that t is an instance of Ord. you can't insert.
15:41:29 <arkeet> it does?
15:42:00 <monochrom> data Coyoneda f a = forall t. Coyoneda ... (f t)  where is the Ord?
15:42:33 <arkeet> ah yeah it doesn't typecheck.
15:42:58 <arkeet> needs some restricted Coyoneda with some constraint on the existential
15:43:04 <monochrom> ok, that covers what coyoneda forbids. now, what it does wrong:
15:43:26 <johnw> feels a monochrom blog post in the works....
15:44:08 <monochrom> suppose you have this set "fromList [1,2,3]". after converting to coyoneda, you can apply "fmap (const ())" sure. but after that, when you convert it to a list, it is [(), (), ()], not [()].
15:44:54 <monochrom> it loses the Set semantics
15:45:41 <arkeet> er, I don't think you can fmap a contravariant Coyoneda.
15:49:02 <monochrom> if you define and use an Ord-ized coyoneda: "data Coyoneda f a = forall t. Ord t => Coyoneda ... (f t)"
15:49:18 <monochrom> then you lose Functor
15:49:33 <arkeet> that's ok, Set wasn't a Functor to begin with.
15:49:57 <johnw> for Profunctor, he just needs to contramap on the function
15:49:58 <arkeet> but you're right, we can't map anymore.
15:50:09 <arkeet> but that's ok.
15:50:26 <arkeet> I don't care about covariantly mapping keys in a Map.
15:50:31 <arkeet> (thinking of Set a as Map a ())
15:51:46 * hackagebot cgi 3001.2.2.2 - A library for writing CGI programs  http://hackage.haskell.org/package/cgi-3001.2.2.2 (cheecheeo)
15:51:51 <monochrom> there was a silverlining when I learned this stuff.
15:51:59 <arkeet> anyway, it seems not very useful.
15:53:22 <monochrom> I never learned Yoneda. I only learned Co Yoneda from a 6-minute video on Loop School. (because I read HWN.) I saw "data CY f a = forall t. CY (t -> a) (f t)", i.e., "exists t. (t -> a, f t)"
15:53:37 <monochrom> so I tried to guess, what would Yoneda look like?
15:54:05 <shachaf> I learned both of them from IRC.
15:54:07 <arkeet> right, that's the covariant Coyoneda.
15:54:17 <monochrom> I guessed "forall r. (a -> r) -> f r" based on experience on dualizing things, and the goal that it still has to be isomorphic to f a.
15:54:38 <monochrom> (and I guess a bit of experience with CPS, too)
15:55:00 <monochrom> then I checked wikipedia and saw that I guessed right
15:56:24 <arkeet> in another direction though, Map can be a Category.
15:56:42 <arkeet> :t \m m' -> M.mapMaybe (`M.lookup` m) m'
15:56:43 <lambdabot> Ord a => M.Map a b -> M.Map k a -> M.Map k b
15:57:00 <arkeet> except without id.
15:57:26 <arkeet> so a semigroupoid.
15:57:33 <arkeet> which means semigroupoids ought to provide an instance for Map.
15:57:47 <arkeet> (it already depends on containers.)
15:58:00 <arkeet> except it can't. because of that damn Ord constraint.
15:58:29 <arkeet> :(
16:03:57 <xpilot> hello
16:04:08 <moghedrin> xpilot: o/
16:04:20 <xpilot> is there a way to see what ghc generates from a deriving declaration?
16:04:33 <arkeet> --ddump-deriv?
16:04:38 <arkeet> -ddump-deriv
16:05:27 <arbelos> WAT! When did the redesign happen on haskell.org?
16:06:34 <koala_man> whoa
16:06:45 <xpilot> ew, lots of cases and lambdas
16:07:08 <xpilot> I assume deriving produces well-optimized code?
16:07:21 <johnw> xpilot: that has not always been a safe assumption
16:11:34 <arkeet> xpilot: if it produces something slower than the obvious hand-written one, I'd say it's a bug.
16:11:37 <arkeet> e.g. https://ghc.haskell.org/trac/ghc/ticket/7436
16:25:08 <caconym> gloss is really cool
16:25:25 <caconym> i feel like there is huge education potential with haskell + gloss
16:31:20 <EvanR> what does haskell school of expression use
16:32:47 <caconym> i'm not sure
16:32:59 <caconym> but i *am* sure that people out there are already using gloss to teach
16:41:49 * hackagebot hbro 1.3.0.0 - Minimal extensible web-browser  http://hackage.haskell.org/package/hbro-1.3.0.0 (koral)
16:43:47 <newsham> http://thenewsh.blogspot.com/2015/04/why-i-love-haskell-example.html
16:46:49 * hackagebot hbro-contrib 1.3.0.0 - Third-party extensions to hbro.  http://hackage.haskell.org/package/hbro-contrib-1.3.0.0 (koral)
16:51:49 * hackagebot pseudo-trie 0.0.4.1 - A tagged rose-tree with short circuited unique leaves  http://hackage.haskell.org/package/pseudo-trie-0.0.4.1 (athanclark)
17:00:31 <Gurkenglas> Why doesn't https://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Functor.html have "Applicative a => Functor a" on its instance list?
17:00:58 <benzrf> Gurkenglas: why would it
17:01:12 <enthropy> because it's class Functor a => Applicative a, not the other way around
17:01:19 <Gurkenglas> Isn't any Applicative a functor?
17:01:23 <benzrf> Gurkenglas: yes
17:01:34 <Gurkenglas> So... why isn't that on the list?
17:01:35 <benzrf> Gurkenglas: but not because of an instance
17:01:44 <benzrf> Gurkenglas: because anything that is an applicative is already on the lits
17:01:47 <benzrf> *list
17:02:00 <benzrf> Gurkenglas: the whole point is that anything thats an applicative is also a functor/... as in, it has a functor instance
17:02:05 <benzrf> Gurkenglas: so it'll already be on the list since it has an instance
17:02:30 <monochrom> "Applicative a => Functor a" is the wrong direction. do not read "=>" as "logically implies". far from it
17:02:51 <benzrf> Gurkenglas: if you had a list of all of the citizens of the united states, you wouldnt expect to see "also all of the members of the government"
17:02:57 <benzrf> Gurkenglas: they're a subset, so they're already listed
17:03:14 <benzrf> Gurkenglas: it's not that being in the govt /causes/ you to be a citizen, it's that the latter is a prerequiste
17:03:22 <benzrf> inb4 noncitizens can be in the government its just an example
17:03:34 <Gurkenglas> Wasn't gonna say that :P
17:03:42 <benzrf> i dont even know if its true
17:03:53 <Gurkenglas> The implementation of the functor instance can be derived from the implementation of the applicative instance, right?
17:05:35 <benzrf> Gurkenglas: strictly, yes
17:05:43 <benzrf> Gurkenglas: but imo that's a shitty mistake
17:05:46 <Gurkenglas> So adding instance Applicative a => Functor a where fmap = liftA would allow people to use applicative without writing down the functor instance
17:06:01 <benzrf> Gurkenglas: but then it becomes circular
17:06:21 <benzrf> you cant be an appl instance w/o being a functor instance
17:06:24 <c_wraith> Gurkenglas: also, that instance overlaps everything
17:06:30 <c_wraith> Gurkenglas: and overlapping is kind of bad
17:06:50 <benzrf> classes are bad sry2say
17:06:51 <Gurkenglas> benzrf, if you can supply an applicative instance implementation then you know you are a functor, so there's no problem there
17:07:07 <benzrf> not what i mean
17:07:22 <benzrf> Gurkenglas: no i understand what you mean but its not really a huge concern
17:07:33 <benzrf> little of value would be gained
17:07:54 <benzrf> AWW YEAH
17:07:57 <benzrf> GHC 7.10
17:08:00 <benzrf> FTP !!!!
17:08:01 <enthropy> that instance/feature would have avoided AMP breakage
17:08:16 <benzrf> woot
17:08:56 <alynn> a little behind the times?
17:09:09 <Gurkenglas> (But, if it wouldn't break all code and took no effort, would something be lost by replacing class Functor a => Applicative a with class Applicative a (...) instance Applicative a => Functor a?)
17:09:37 <c_wraith> Gurkenglas: well, like I said, that instance overlaps *everything*
17:09:42 <c_wraith> Gurkenglas: which breaks all kinds of stuff
17:10:47 <Gurkenglas> Like, if the instance graph thus becomes a DAG we have a problem?
17:10:48 <enthropy> Gurkenglas: even with that instance, ghc doesn't accept   fmap_ :: Applicative f => (a -> b) -> f a -> f b; fmap_ = liftA
17:11:46 <enthropy> err, make the rhs there fmap
17:12:05 <enthropy> and this is in the world where we have class Applicative a
17:12:21 <Gurkenglas> Shouldn't overlapping instances have the same definitions if nobody made a mistake?
17:12:27 <Gurkenglas> (in the sense of function equality
17:12:28 <Gurkenglas> *)
17:12:49 <alynn> only for Functor
17:13:00 <alynn> and special casing for that in the compiler seems like a bad idea
17:14:06 <Gurkenglas> Not just there, everwhere you get a diamond graph of instances
17:15:32 <Gurkenglas> Like, the applicative instance can also be derived from the monad instance, and if we had another thing from which the applicative instance can be derived, and then yet another thing from which both the other thing and the monad instance can be derived, then we have two instances from the yet another thing to applicative and it shouldn't matter which way one goes
17:17:01 <Gurkenglas> So overlapping instances resulting from replacing the prerequisites in the class declaration with instances shouldn't change anything as long as the compiler assumes all instance implementations do the same thing
17:18:03 <enthropy> probably it would be more useful if Applicative ZipList was the instance for []
17:18:10 <Gurkenglas> (All this thinking, of course, results from reading https://ghc.haskell.org/trac/ghc/wiki/Migration/7.10 and the boilerplate code suggested after "then the easiest way to fix this error is by defining an Applicative (and possibly a Functor) instance:")
17:18:56 <monochrom> Gurkenglas, you should formally propose to the haskell committee to allow overlapping instance.
17:18:57 <Gurkenglas> That sounds like a hack. What happens when we find a data structure with three useful instances?
17:19:39 <caconym> Data.Trifunctor
17:20:57 <Gurkenglas> int-e, would you tweak the lambdabot configs to have it trust Control.Comonad?
17:21:17 <enthropy> that argument would be better if you had a data with 3 instances to choose from
17:22:56 <Gurkenglas> You mean you want an example? I don't think we should fortify language features that inconvenience data structures we haven't thought of yet. (Yes I realize that's far-fetched.)
17:24:26 <newsham> hi dysinger
17:28:02 <Newb> Hey all I am trying to create a data type uniqueList that only adds an element if it is not already in the list, can anyone point me in the right direction for this?
17:28:02 <Gurkenglas> Why isn't toList an alternative for a minimal complete definition for https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Foldable.html ?
17:28:43 <pacak> Newb: Data.Set ?
17:28:51 <caconym> Newb: Data.Set is similar to what you describe, although it's not strictly a list
17:28:54 <Gurkenglas> Does the order matter?
17:29:17 <pacak> :t nub
17:29:18 <lambdabot> Eq a => [a] -> [a]
17:29:39 <Newb> Trying to create one from scratch, the order doesn't matter but I assume it probably will make it easier to keep the elements unique
17:29:56 <Zemyla> Yeah, just use Data.Set.
17:29:57 <eacameron1> is there a version of hoogle hosted somewhere that searches *all* packages?
17:30:06 <pacak> Newb: Ord constraint will help to make it less expensive.
17:30:24 <pacak> eacameron1: It's called hayoo
17:30:40 <pacak> eacameron1:  hayoo.fh-wedel.de
17:31:00 <pacak> eacameron1: You  can explain hoogle to each all packages as well
17:31:01 <Newb> Hm alright
17:31:17 <eacameron1> pacak how?
17:31:26 <Gurkenglas> Is he wrong to try to implement it himself as a challenge?
17:31:48 <caconym> on the contrary, it's probably a good exercise
17:31:50 <pacak> eacameron: By manually specifying all the packages :)
17:31:57 <jle`> Newb: you could create a newtype wrapper over a list, and create an API that enforces this invariant
17:32:08 <eacameron> pacak: ha!
17:32:13 <jle`> newtype Nubbed a = N [a]
17:32:19 <pacak> jle` It would be inefficient.
17:32:40 <jle`> the other answer would be to create a binary search three, or a hash map?
17:32:48 <jle`> it seems like this is a learning experiment in any case
17:33:04 <jle`> if performance matters you can restrict it to comparable items and use a binary search tree, or restrict it to hashable items and use a hash map
17:33:16 <jle`> but if it's for learning, you can just do the newtype and have O(n) additions
17:33:41 <jle`> consNubbed :: a -> Nubbed a -> Nubbed a
17:33:50 <jle`> so the result will not add it if the a already exists in the list
17:34:01 <Newb> Yeah I am doing it to try new challenges which is why I dont wanna use data.set,  performance doesn't really matter.
17:34:09 <jle`> and in the end, only export the smart constructor `consNubbed`
17:34:09 <Newb> How does that stop it from adding it if it already exists
17:34:16 <jle`> you have to write the function yuorself :)
17:34:24 <pacak> :t elem
17:34:25 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
17:34:25 <jle`> consNubbed x (N xs) = ...?
17:34:40 <jle`> probably check if x is in xs, then cons it if it is.  otherwise, don't.
17:34:47 <jle`> using a guard, maybe
17:35:05 <jle`> be sure to add a nilNubbed :: Nubbed a, which returns an empty list nubbed
17:35:09 <ReinH> jle`: or cons without checking and nub after
17:35:18 <jle`> that too :)
17:35:53 <jle`> hm you might actaully be able to use nubOrd to have a consNubbedOrd :: Ord a => a -> Nubbed a -> Nubbed a, which might be cheaper...
17:36:31 <jle`> and then the final thing you need for a complete list interface is uncons :: Nubbed a -> Maybe (a, Nubbed a), which is Nothing when the list is empty and Just (x, xs) when not, with the head and the tail
17:36:42 <kcccccc> Which approach is more recommended when different components of a web application need to communicate with each other? A communication through a mediating publish/ subscribe system, over which the messages are distributed, or through method calls from one component to the other?
17:36:49 <Gurkenglas> Wouldn't doing nub on every add waste lots of time because nub doesn't know the list was nubbed before?
17:36:59 <kcccccc> (I'm writing here, because I would like to know a functional approach to this)
17:37:09 <Newb> Hm youve given me a lot to go over and analyze, takes me a while to make sense of it all since I am not used to haskell's syntax, I will look over all this and come back if I have any questions. Thanks so much
17:37:12 <jle`> efficiency is not a high priority, but this might be a good start before really considering what happens and thinking about optimizations
17:37:20 <pacak> > (\x xs -> (if elem x xs then flip const else (:)) x xs) 1 [1,2,3]
17:37:21 <lambdabot>  [1,2,3]
17:37:28 <pacak> > (\x xs -> (if elem x xs then flip const else (:)) x xs) 100500 [1,2,3]
17:37:29 <lambdabot>  [100500,1,2,3]
17:38:12 <jle`> np Newb !  having a cons, a nil, and an uncons is all you need to implement any list algorithm/function, i think...so users of your Nubbed type can do what they want, albeit inefficiently.  but of course you can always implement "faster" variations too of common list functions.
17:39:27 <jle`> like you can write map :: (a -> b) -> Nubbed a -> Nubbed b using only cons, nil, and uncons.  but it'd be much much slower than just directly mapping the underlying list :)
17:39:46 <jle`> (and then nubbing at the end)
17:40:15 <Newb> :) thanks
17:40:28 <KaneTW> :t flip const
17:40:29 <lambdabot> b -> c -> c
17:40:40 <jle`> map f xs = case uncons xs of Nothing -> nil; Just (y, ys) -> cons (f y) (map f ys)
17:40:54 <pacak> :t flip flip flip
17:40:55 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
17:41:52 * hackagebot haskell-src-meta 0.6.0.9 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.6.0.9 (BenMillwood)
17:42:29 <jle`> (that'sthe "slow" way using only your special exported api functions)
17:45:04 <Newb> Can I do something like Data Nubbed = { list :: [a] }
17:45:31 <byorgey> Newb: yes, but you need a data constructor
17:45:43 <byorgey> also you need to make 'a' a parameter to Nubbed
17:45:56 <byorgey> data Nubbed a = Nub { list :: [a] }
17:46:05 <Newb> Gotchya
17:46:18 <johnw> byorgey: hi!
17:46:20 <byorgey> also, if it's just wrapping a single thing then it's better to make it a newtype rather than data
17:46:24 <byorgey> newtype Nubbed a = ...
17:46:29 <byorgey> hi johnw!
17:46:37 <Newb> Whats the difference between newtype and data?
17:46:39 <neuroserpens> Nubbed... LOL!
17:46:49 <monochrom> you can use jle`'s code, <jle`> newtype Nubbed a = N [a]
17:47:08 <byorgey> Newb: newtypes have no extra runtime overhead
17:47:13 <byorgey> unlike data
17:47:31 <shachaf> That depends on what you mean by runtime overhead. :-)
17:47:34 <neuroserpens> Hahahahahaha nubbed nub hahahahhahaha oh my god hahahahalmao
17:47:48 <Newb> Does it still make the datatype distinct from a list?
17:47:53 <byorgey> yes.
17:48:07 <Newb> I can still make it instances of things and such
17:48:18 <byorgey> right, exactly
17:48:52 <Newb> Okay thanks so much again byorgey and jle!
17:51:32 <slack1256> wow, ghc 7.10.1 in archlinux
17:55:55 <jokester> failed to build ghc 7.10 with homebrew
17:56:01 * jokester sobs
17:56:20 <ackthet> i've become less and less impressed with homebrew
18:00:04 <pharaun> i do the bare min with homebrew then run
18:00:20 <Newb> Is there an easy way to copy errors/output from gchi that I don't know about ? I can't seem to copy I always manually type out or screenshot
18:00:35 <Newb> ghci*
18:01:29 <Hijiri> depending on your terminal emulator, highlighting it might put it in your primary buffer
18:01:47 <Hijiri> on my computer I can pull from the buffer using shift + insert or middle mouse click
18:02:00 <Newb> I can't even highlight :*
18:02:02 <Newb> :(
18:02:33 <Hijiri> maybe your terminal emulator has some other kind of marking functionality
18:08:17 <lpaste> Newb pasted “Set help” at http://lpaste.net/3402231362541846528
18:09:04 <slack1256> Newb: `ghci | tee output` works!
18:09:09 <Newb> Can anyone gander and tell me where I am being an idiot
18:09:32 <Newb> Thanks slack1256  I will look at that
18:10:03 <enthropy> Newb: instance Show [a] => Show (Set a) where <what you have>
18:10:58 <newsham> "Set" is a whole family of types.  (Set a) (for a specific a) is a type.
18:11:09 <newsham> and you wanted to say that for all the a's, (Set a) is an instance of show
18:11:26 <newsham> but you can only do that if the a it contains is also an instance of Show
18:12:08 <newsham> (because you want to call "show" on the elements)
18:12:16 <Newb> Ah makes sense
18:12:30 <pharpend> Is there a way to have Cabal install man pages for my package?
18:13:06 <Newb> so newsham you back enthropy's fix?
18:13:30 * enthropy backs newsham's explanation
18:13:59 <Newb> lol
18:14:22 <lpaste> Newb revised “Set help”: “No title” at http://lpaste.net/3402231362541846528
18:14:40 <newsham> i'm newsham and I endorse this message
18:15:13 <newsham> "Show a => Show (Set a)"  should do the trick for you
18:15:19 <newsham> it can infer "Show [a]" from "Show a"
18:15:41 <Newb> Ahh!!! Thanks!
18:36:10 <quazimodo> hay hay
18:36:26 <pacak> Looks like cabal package can depend on itself: http://hackage.haskell.org/package/freetype2 
18:37:16 <glguy> The executable depends on the library
18:37:38 <pharaun> i do that all the time, have a lib + several executables + test that depends on the lib
18:38:37 <pacak> I know, but it looks a bit strange how hackage shows that.
18:39:50 <caconym> best practices question: if you only need a tiny corner of a sprawling library with many dependencies (eg lens), is it considered acceptable to implement that tiny corner yourself in your own program?
18:40:25 <caconym> i haven't run into this issue in quite the same way in any other language... in haskell, complex and powerful ideas can be expressed so compactly
18:40:28 <edwardk> you hereby have my blessing to copy and paste whatever code you want to from me, at the risk of course, of losing any improvements that get posted downstream along the way
18:41:20 <pacak> caconym: Exactly which corner do you want to get from lens?
18:42:13 <caconym> edwardk: thanks :)
18:43:06 <caconym> pacak: in this case, only the Lens' type and an implementation that lenses list elements by index
18:44:05 <caconym> pacak: but i am more wondering in a general sense; this has come up before for me
18:44:54 <fuzzyhorns> http://cs.stackexchange.com/questions/37157/binary-search-trees-node-trees-vs-leaf-trees?newreg=d69d648da76844e2ab9c75649bbc314c has anyone ever seen the data structures mentioned here?
18:45:03 <fuzzyhorns> i feel like i saw an example of model 1 in haskell once
18:45:03 <pacak> caconym: Lens' is a simple type alias, you might as well use this signature type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t 
18:45:06 <fuzzyhorns> but failing at google
18:45:38 <caconym> pacak: that's exactly what i've done
18:46:56 * hackagebot pinboard 0.6.5 - Access to the Pinboard API  http://hackage.haskell.org/package/pinboard-0.6.5 (jonschoning)
18:47:05 <caconym> pacak: i am just curious whether a more experienced haskeller might scoff at code that 'reimplements the wheel' rather than just pulling in the appropriate library
18:47:29 <edwardk> fuzzyhorns: model 1 comes up in the paper on finger-trees quite a bit
18:47:30 <pacak> As for reimplementing existing code... I did it once.  I have a commit that replaced one sass file (5 lines) with one css file (8 lines) and removed about "200 different modern web development technologies javascript libraries" from the project.
18:47:32 <edwardk> at least the general idea
18:48:49 <fuzzyhorns> edwardk: i dont think the poster of that comp sci post is right though, i thought the point of model 1 being better was it involved fewer comparisons
18:48:53 <fuzzyhorns> perhaps I misunderstood though
18:48:59 <caconym> pacak: thanks for the anecdote, that's exactly the sort of thing i'm thinking of
18:48:59 <edwardk> fuzzyhorns: there you pick a monoid to accumulate up the tree and picking the maximum or minimum value for instance in a binary search tree leads to model 1 style trees.
18:49:24 <pacak> caconym: You have my blessing to do so :)
18:50:04 <edwardk> model 1 vs. model 2 for binary trees doesn't matter so much, for b-trees you can see a win for moving the data down to the leaves because you can afford a wider fan-out in the space allotted to a cache-line
18:50:25 <caconym> pacak: :)
18:51:43 <fuzzyhorns> hmm, i dont know what you mean about a cache line
18:53:16 <fuzzyhorns> also edwardk do you agree with what the book says on model 1 v 2? "In model 1, the underlying tree is a binary tree, whereas in model 2, each tree node is really a ternary node with a special middle neighbor."
18:54:14 <platz> fuzzyhorns: http://www.pantherproducts.co.uk/index.php?pageid=cpucache
18:54:50 <fuzzyhorns> thanks platz
18:55:04 <fuzzyhorns> i havent done much systems programming so i dont know enough about that
18:55:17 <__ryan> arw: hi - i use this code makePasswordSalt "password" (makeSalt "72cd18b5ebfe6e96") 14 and return me this sha256|14|NzJjZDE4YjVlYmZlNmU5Ng==|rqC1cZcg8tvPHwEV81UNP8Upx/EJ2BMV8L4WGKwwzDQ= i'd like to ask if this will be the data to be save in the db? for password
18:55:24 <fuzzyhorns> oh i know what a line cache is
18:55:31 <edwardk> fuzzyhorns: meh, both of them are decorated trees
18:55:35 <__ryan> hi everyone - i use this code makePasswordSalt "password" (makeSalt "72cd18b5ebfe6e96") 14 and return me this sha256|14|NzJjZDE4YjVlYmZlNmU5Ng==|rqC1cZcg8tvPHwEV81UNP8Upx/EJ2BMV8L4WGKwwzDQ= i'd like to ask if this will be the data to be save in the db? for password
18:55:48 <fuzzyhorns> edwardk: why do you think this author is pursuing the difference then?
18:55:59 <edwardk> i think the author is being needlessly pedantic
18:56:23 <fuzzyhorns> i guess i am easily impressed haha, i thought it was compelling that one needed half as many comparisons in one model vs the other
18:56:55 <edwardk> fuzzyhorns: in http://comonad.com/reader/wp-content/uploads/2010/04/Finger-Trees.pdf i talk a bit about leafy and 'traditional' trees as a warmup for finger-trees
18:57:06 <edwardk> the slides are mostly correct except for a couple of ! annotations
18:57:52 <edwardk> fuzzyhorns: the reduction in worst case comparisons comes at a cost of course of having to walk all the way to the bottom of the tree
18:58:02 <edwardk> this means you guarantee more cache misses
18:58:20 <edwardk> and nobody cares about a 1-cycle compare usually compared to a cache miss
18:58:40 <edwardk> i'd say in the 80s the optimization mentioned there mattered
18:58:52 <fuzzyhorns> the book also says "A tree of height h and model 1 contains at most 2h objects. A tree of height h and model 2 contains at most 2h+1 − 1 objects."
18:58:53 <edwardk> but now for the most part doing a ternary compare is a win
18:59:12 <fuzzyhorns> so i would think model 1 would still be better, given it would mean a shorter tree height?
18:59:46 <arkeet> model 1 forces you to go all the way to the bottom of the tree every time.
19:00:57 <fuzzyhorns> arkeet: yeah, i see that
19:01:35 <edwardk> model 1 requires more nodes, so a deeper tree. in exchange for a deeper (by 1 level) tree you get the ability to do a half-price comparison at each node
19:01:50 <edwardk> but its half-price after you load the cache-line, and the cache-line is the expensive part
19:02:24 <edwardk> unless you have a particularly weird key a three-way comparison and a two-way comparison are going to be very cost competitive
19:04:03 <fuzzyhorns> edwardk: is deeper different than height?
19:04:07 <edwardk> so you trade accessing (h+1) lines guaranteed and having a cheaper operation at each vs. accessing the number of cache lines you actually need to get to the value, but having a more slightly expensive comparison.
19:04:15 <arkeet> same thing.
19:04:37 <fuzzyhorns> and thank you for humoring my questions, at work i dont get to discuss stuff like this
19:04:53 <edwardk> deeper = height here
19:05:13 <edwardk> your statement about the heights between model 1 and model 2 seem inverted
19:05:42 <fuzzyhorns> edwardk: direct quote from the book: "A tree of height h and model 1 contains at most 2h objects. A tree of height h and model 2 contains at most 2h+1 − 1 objects."
19:05:50 <fuzzyhorns> and that's 2^h
19:05:55 <fuzzyhorns> (sorry if unclear)
19:06:13 <arkeet> right. so you need a greater height for model 1 to hold the same number of objects.
19:06:13 <fuzzyhorns> he justifies it by: "This is easily seen because the tree of height h has as left and right subtrees a tree of height at most h − 1 each, and in model 2 one additional object between them."
19:06:39 <arkeet> 2^(h+1) - 1 = 2^0 + 2^1 + ... + 2^h
19:07:06 <edwardk> except for the fact that in model 2 your 'leaves' are just null pointers. no data.
19:07:55 <fuzzyhorns> arkeet: and so?
19:08:18 <fuzzyhorns> they are the same?
19:08:43 <arkeet> I'm just saying that's the number of nodes.
19:08:55 <edwardk> model 1: data Map k v = Empty | Tree (Tree k v); data Tree k v = Bin (Tree k v) k (Tree k v) | Tip v      -- vs. model 2: data Map k v = Bin (Tree k v) k v (Tree k v) | Tip
19:09:23 <fuzzyhorns> arkeet: sorry I dont follow :c
19:09:28 <edwardk> an empty Tip has 'no node' in model 2, its just a null pointer. in model 1 it has to pay for storing the data somewhere.
19:09:42 <edwardk> so basically i'd say the author is using shitty accounting to grind an axe
19:09:47 <fuzzyhorns> hahaha
19:09:55 <edwardk> to mix a metaphor
19:10:08 <fuzzyhorns> can you recommend a different advanced data structures book? :d
19:10:14 <edwardk> what book?
19:10:31 <fuzzyhorns> http://www.amazon.com/dp/0521880378/?tag=stackoverfl08-20
19:10:41 <edwardk> hrmm
19:10:47 <edwardk> have you read okasaki?
19:11:00 <fuzzyhorns> i am reading him now too, yes
19:11:05 <edwardk> different emphasis, but a very very good book to read, especially if you care about functional programming
19:11:14 <fuzzyhorns> i wanted to read something "typical" or not functional specific
19:11:29 <hiptobecubic> fuzzyhorns, have you read THE intro to datastructures book?
19:11:46 <lpaste> Newb pasted “Set help” at http://lpaste.net/3837074102359687168
19:12:08 <edwardk> and have you read "Introduction to Algorithms" by cormen, leiserson, rivest, and stein?
19:12:16 <edwardk> it has a rather imperative take but it covers a lot of ground
19:12:18 <Newb> Can anyone tell me why my code hangs when I try to check the equality of two sets?
19:12:33 <fuzzyhorns> hiptobecubic: that one is different from the cormen one ed is mentioning yes?
19:12:37 <fuzzyhorns> the answer is no to hiptobecubic
19:12:50 <fuzzyhorns> and partially to introduction to algorithms, back when i took a mooc :/
19:12:50 <hiptobecubic> fuzzyhorns, no the cormen book is what i'm referring to
19:12:56 <arkeet> Newb: the default definition of (/=) uses (==)
19:13:00 <hiptobecubic> http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844/ref=pd_sim_b_2?ie=UTF8&refRID=0N19C9Q71GBC8F77D0E7
19:13:10 <arkeet> so x == y is not (x /= y), which is not (not (x == y)), etc
19:13:41 <arkeet> I'm guessing you want to compare the underlying lists.
19:13:45 <Newb> exactly
19:13:59 <Newb> Good guess
19:14:44 <edwardk> fuzzyhorns: what particular data structures are you interested in? i can point more to papers than books =)
19:15:15 <fuzzyhorns> well, i had a general sort of question about them i didnt know precisely how to pursue, which is perhaps a bit silly
19:15:36 <fuzzyhorns> but i was thinking about how hypermedia is intended to be messages of application state and controls
19:15:50 <fuzzyhorns> and i wondered to myself, what kinds of data structures were already used that way or to what ends
19:15:50 <edwardk> bookwise there is also the class "art of computer programming" if you can get past the affectation of supplying assembly for all the algorithms in a made up assembly language
19:16:02 <edwardk> er the classic
19:17:03 <fuzzyhorns> edwardk: part of what i found compelling about the model 1 vs 2 thing was that if every comparison is an operation over the network, it seems better to avoid them
19:17:07 <edwardk> my first algorithms textbook was the old sedgewick "algorithms" (back when it was printed in pascal, the later editions get too bogged down in C++ nonsense and the insights seem to be lost)
19:17:10 <Newb> akeet, how can I do that rather then end up in an infinite loop? :(
19:17:16 <Newb> arkeet*
19:17:37 <fuzzyhorns> edwardk: hehe i was just reading someone complaining about pascal vs c++ x)
19:17:39 <edwardk> if i'm sending you the key i damn well better ask you to tell me the 3 way decision than the 2-way decision ;)
19:18:08 <benzrf> cabal install hdevtools sez:
19:18:09 <benzrf> Language/Haskell/GhcMod/Gap.hs:256:18:
19:18:10 <hiptobecubic> fuzzyhorns, might I also recommend MIT open courseware, which has several good courses on this with notes and sometimes even transcripts of the videos
19:18:11 <benzrf>    Not in scope: data constructor ‘ExposePackageId’
19:18:12 <fuzzyhorns> edwardk: why?
19:18:27 <arkeet> Newb: pattern match on Set to get at the list, as you did in your Show instance.
19:18:30 <edwardk> and your case actually argues the other way. i'd prefer not to have the network latency of asking you 6 2-way questions all the time, than escaping early when the 3rd question yielded the answer.
19:18:33 <fuzzyhorns> hiptobecubic: yeah that is how i read part of that algorithms book, it was part of the MIT algorithms class
19:18:41 <arkeet> (or use the "list" accessor)
19:18:55 <platz> cannot not mention https://www.coursera.org/course/algo and https://www.coursera.org/course/algo2
19:19:15 <sydneyhacker> Newb
19:19:34 <fuzzyhorns> nice
19:19:40 <Newb> sydneyhacker
19:19:41 <platz> although i admit the instructors style covers a bit more theory than you'd expect
19:19:53 <platz> mathematical proofs and such
19:19:54 <fuzzyhorns> edwardk: well, in my case i am thinking of links
19:19:56 <edwardk> the model 2 tree can stop asking when it finds the key. the model 1 tree has to walk all the way down to the end no matter what.
19:20:05 <platz> truly makes the head hurt.  
19:20:09 <platz> but in a good way
19:20:13 <fuzzyhorns> edwardk: i want the user to traverse as few links as i can, but i guess it is better to bottom out sooner
19:20:42 <benzrf> pls help
19:20:47 <benzrf> tia
19:20:57 <sydneyhacker> Sorry Newb that was an accident I was trying to search on your name. I did :m Data.Set. Then fromList [1,2,3] == fromList [1,2,3] in GHCi and it worked OK.
19:21:11 <arkeet> fwiw
19:21:30 <arkeet> the average height of a node in a complete binary tree of height n is about n-1
19:22:11 <fuzzyhorns> arkeet: so if i am worried about the average case, do i want model 1?
19:22:27 <fuzzyhorns> given its height will be lesser
19:22:29 <arkeet> I don't know how you conclude that.
19:22:34 <arkeet> model 1 will have a greater height.
19:22:40 <Newb> Thats okay sydneyhacker, I am not using Data.Set unfortunately I am using my own (poor) implementation
19:22:40 <arkeet> you need 1 more level to store the same number of nodes.
19:22:49 <fuzzyhorns> arkeet: again, he says model 1 has fewer
19:22:54 <Newb> arkeet I thought I was doing that :(
19:22:56 <arkeet> no.
19:23:01 <arkeet> he says model 1 can hold fewer nodes given the same height.
19:23:11 <arkeet> which means given the same number of nodes, the height will be greater.
19:23:37 <edwardk> model 1 requires you to walk 1 extra level guaranteed to get a slightly cheaper compare per node. the only way model 1 counts as 'cheaper' is if you count a cost for storing a 'node' for the empty leaves.
19:23:45 <sydneyhacker> Newb, I am a 'newb' too. I imagine the problem then is implementing the instance of Eq? Because in one of the online books I read, it says /= is defined in terms of == and vice versa. So you need to specify one of them.
19:23:45 <arkeet> in model 2, not only is the maximum height lesser by 1, the *average* height is lesser by 2.
19:24:01 <tnks> I'm giving a short presentation about type classes. . . but it occurred to me I don't really have a good succinct definition yet.
19:24:06 <tnks> any tips?
19:24:21 <arkeet> so it's clearly a big win if traversing down the tree is more expensive than doing a comparison at a node.
19:25:04 <Javran> typeclasses are like java interfaces
19:25:21 <Newb> Yeah sydneyhacker, definitely the problem, blah. Wish I was a haskell guru lol. back to google
19:25:42 <fuzzyhorns> i guess i just trust books too much
19:25:45 <tnks> Javran: I plan on getting to the comparisons too; what I want is an accurate definition to avoid confusion.
19:25:53 <slack1256> tnks: The operations that a type admitted ought to appear on the type signature, thus type classes where born 
19:26:00 <arkeet> (the average height is actually something like (n-1) + (n+1)/(2^(n+1)-1), if I did my math right.)
19:26:04 <Javran> you implement type instances and it goes into a dictionary-like stuff
19:26:14 <arkeet> (for a complete tree of height n)
19:26:49 <slack1256> IRC the original description of type classes was different and somebody misunderstood what he meant and implemented them as we know it today
19:26:58 <slack1256> I have to find that cite somewhere though
19:27:33 <Javran> tnks: I think the difference are .. Haskell type classes dispatches on types while java objects carry their own methods.
19:27:54 <Javran> might not be that accurate, I haven't written in Java for a while
19:28:32 <fuzzyhorns> edwardk: i have an unrelated question to the one before, which is, what is the difference between types and classes?
19:28:50 <fuzzyhorns> my thought was just that classes have the property of inheritance and so can be partially ordered
19:29:24 <tnks> yeah, I've thought of some of this, but it seems to skate past some kind of essense.
19:29:32 <tnks> just curious if someone had thought more about it.
19:30:13 <tnks> the "ad hoc" paper has the sequent calculus and a lot of discussion -- but I'm missing a concise definition.
19:32:33 <__ryan> hi everyone what does this error means? - Couldn't match type ByteString with Text
19:32:34 <__ryan> Expected type: Handler Text
19:32:34 <__ryan>   Actual type: HandlerT App IO ByteString 
19:32:41 <Javran> I guess "ad hoc" polymorphism doesn't rely on inheritance in an OOP sense.
19:33:14 <pacak> __ryan: Wrong type. You are doing ByteString IO and trying to process it with Text functions.
19:33:33 <__ryan> pacak: what will i do?
19:33:37 <Javran> it's more like a logic system at type level, e.g. if you can give me evidence of Eq a, it might be possible to make an instance of Ord a
19:34:08 <slack1256> type system are logic systems
19:34:43 <Javran> yeah
19:34:56 <pacak> __ryan: Check if you are actually want to use Text or ByteString. Add some transcoding, not sure how it's usually done in Yesod
19:35:21 <slack1256> tnks: Read the paper `haskell: being lazy with class'
19:35:39 <__ryan> pacak: i want my function to return a Text cause i will save to the db here is the code http://lpaste.net/130281
19:35:43 <slack1256> it will clarify the story and make the succint explanation get to you
19:36:55 <pacak> __ryan: encodeUtf8, you probably want decodeUtf8 nearby, not sure
19:37:05 <tnks> slack1256: k, thanks.
19:37:39 <edwardk> slack1256: the bit in there about how wadler invented them via misunderstanding made it into my talk on typeclasses
19:39:30 <__ryan> pacak: thank you it works.. :-)
19:41:26 <slack1256> edwardk: Maybe I got it from that talk
19:41:52 <platz> I wonder what the original ask was, if perhaps we'd have subtyping instead
19:42:01 <tnks> edwardk: what was Wadler's misunderstanding?
19:42:04 <Newb> an someone help me I am still stuck and ten minutes of googling has been fruitless, my code gets stuck in an infinite loop http://lpaste.net/3837074102359687168
19:43:24 <platz> or maybe we'd have the vtable attached to data record
19:44:02 <pacak> Newb: x and y are sets
19:44:20 <pacak> You are trying to use /= from Set which is defined in terms of ==
19:44:46 <sydneyhacker> Newb. Try this for your last line: 	Set x == Set y	= x == y
19:47:01 <Javran> Newb: the problem is you are defining (==) in terms of (/=), but you didn't overwrite the default definition, which is defined in terms of (==) 
19:47:26 <pharpend> Is there a library to use a pager (like 'less')
19:47:49 <Javran> the minimal definition you need to give for Eq is either (==) or (/=), try not to implement it in terms of each other.
19:48:05 <fuzzyhorns> i feel duped by that book, i def think im gonna just stick to the verified classics now :/
19:48:07 <lpaste> Martin revised “Set help”: “Soln” at http://lpaste.net/3837074102359687168
19:50:59 <Newb> Ahh thanks Sydneyhacker! and javran and pacak
19:51:05 <Newb> Got it working
19:51:11 <Newb> Yall are the best
19:51:20 <sydneyhacker> Newb does it make sense why it works?
19:52:00 * hackagebot esqueleto 2.1.2.3 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.1.2.3 (FelipeLessa)
19:52:14 <mrmyers> sydneyhacker: Calling someone 'newb' isn't very civil.
19:52:26 <Newb> Yes because you are comparing the two sets first but you are really comparing the lists underneath... I think?
19:52:59 <Newb> and lol @ mrmyers
19:53:27 <arkeet> you are defining how to comapre two sets.
19:53:46 <arkeet> so you better not try to compare the two sets you are trying to define how to compare.
19:53:59 <sydneyhacker> Newb, yes and it is pattern matching, so x is bound to the innards. A most beautiful feature of Haskell imo.
19:55:01 <tnks> k, found Wadler's misconception.
19:56:16 <Javran> Newb: what you did is just like "instance Eq a where; a == a = not (a /= a); a /= a = not (a == a)" .. it doesn't make any progress, the definition should at least somehow examine its value and takes some action accordingly
19:57:46 <Newb> Sometimes I like to imagine my code does what I want it to do rather than what i program it to do, thanks for all the clarifications
20:02:00 * hackagebot ottparse-pretty 0.1.2.5 - Pretty-printer for Ott parse trees  http://hackage.haskell.org/package/ottparse-pretty-0.1.2.5 (BrentYorgey)
20:10:21 <fuzzyhorns> edwardk: also do you endorse this explanation of finger trees? http://scienceblogs.com/goodmath/2010/04/26/finger-trees-done-right-i-hope/
20:11:08 <edwardk> fuzzyhorns: you can see comments from me on the post =)
20:11:16 <fuzzyhorns> hahah! nice
20:11:21 <edwardk> fuzzyhorns: the previous version mark posted before that was actually very wrong
20:11:30 <edwardk> this version at least doesn't lie
20:12:47 <arkeet> I think the finger trees paper is good reading.
20:13:17 <arkeet> this page even has pictures. http://staff.city.ac.uk/~ross/papers/FingerTree.html
20:14:07 <edwardk> the original finger tree paper is pretty darn good
20:14:07 <fuzzyhorns> yeah i was looking at that one, too :)
20:14:32 <fuzzyhorns> im afraid im still at the shallow end
20:14:52 <edwardk> it also nicely fundamentally uses laziness
20:15:20 <arkeet> I should make some time to actually read okasaki's book.
20:15:29 <edwardk> fuzzyhorns: you might also enjoy https://yow.eventer.com/yow-2014-1222/functionally-oblivious-and-succinct-by-edward-kmett-1701
20:16:02 <fuzzyhorns> edwardk: thanks :) i wish i could work professionally in a functional language but havent had the chance yet
20:16:06 <edwardk> that uses okasaki style techniques to build a b-tree analogue
20:16:19 <fuzzyhorns> oh neat!
20:16:30 <edwardk> (it also builds a data structure you can easily re-implement in c/c++/c#/java whatever)
20:16:56 <fuzzyhorns> sadly the language i am most fluent in is Ruby :/
20:19:00 <edwardk> ruby might work, haven't tried it there. do so, benchmark it and tell me ;)
20:19:17 <fuzzyhorns> hehe i will, it'll prob be a bit painful though
20:19:19 <edwardk> might be hard to get things unboxed enough to win though
20:20:02 <fuzzyhorns> i once wrote a radix sort in ruby for fun and its performance was terrible of course
20:25:05 <__ryan>  hi everyone - i want to create a dynamic meta data instead of static metadata - does anyone should now how to do it in yesod thank you in advance
20:44:05 <fresheyeball_> any Snap users out there?
20:44:15 <dmj`> yea
20:44:27 <fresheyeball_> any idea how to reverse proxy?
20:44:32 <dmj`> yes
20:44:35 <fresheyeball_> I'd like to take a request
20:44:39 <bitemyapp> dmj`: hey
20:44:40 <fresheyeball_> decorate the headers
20:44:45 <fresheyeball_> then send it along
20:45:02 <dmj`> _ <- try $ httpServe conf (behindProxy X_Forwarded_For site) :: IO (Either SomeException ())
20:45:02 <bitemyapp> dmj`: you pinged me the other day. What's up?
20:45:36 <fresheyeball_> I don't understand how that would work
20:45:45 <fresheyeball_> how to I specify the uri to forward to?
20:45:56 <fresheyeball_> I saw Snap.Util.Proxy
20:46:02 <fresheyeball_> but it looks like its not a reverse proxy
20:46:17 <dmj`> bitemyapp: yea I was going to use elasticsearch, but then we switched to cloudsearch, was wondering why conduit was a dep. in bloodhound
20:46:22 <em> Leibniz was a very intelligent guy so its hard to just write off his thoughts as nonsense. I was reading the monadology and its kind of hard to grok.
20:46:33 <dmj`> fresheyeball_: oh, you want to know how to setup nginx? That's not a snap thing
20:46:59 <fresheyeball_> well not nginx
20:47:00 <em> I do have a feeling that Leibniz had in mind something like computer science concepts tho.
20:47:06 <fresheyeball_> I know how to setup nginx as a reverse proxy
20:47:17 <fresheyeball_> but I need to change the headers along the way
20:47:19 <dmj`> bloodhound: I removed the conduit dep and it built in the cabal file and it built fine
20:47:24 <dmj`> derp :/
20:47:26 <fresheyeball_> with a value from memory in snap
20:47:35 <dmj`> wow what did I just say
20:47:47 <dmj`> bitemyapp: I removed the conduit dep and bloodhound still built
20:47:58 <em> mauke, johnw , ski do you know about Leibniz Monadology?
20:49:31 <dmj`> fresheyeball_: the code you see above sets the request url properly on incoming requests that are reversed proxied to your web server
20:50:18 <dmj`> fresheyeball_: just run your reverse proxy (nginx / haproxy) and have it point to your running web server process
20:50:35 <fresheyeball_> I want to proxy a request coming into my webserver to someone else's server
20:51:07 <fresheyeball_> perhaps I am misusing the term 'reverse proxy'
20:51:11 <bitemyapp> dmj`: probably because I had http-conduit instead of http-client before.
20:51:27 <bitemyapp> dmj`: but it's possible it'll go back to being http-conduit again, depending on how some updates go.
20:51:38 <dmj`> fresheyeball_: that's a redirect
20:51:40 <bitemyapp> dmj`: there's another company using it and I'm waiting for them to finalize a PR.
20:51:57 <fresheyeball_> requests are reaching my webserver just fine
20:52:04 <dmj`> bitemyapp: ah cool
20:52:05 <fresheyeball_> ok ok
20:52:11 <fresheyeball_> redirect
20:52:16 <heatsink> em, Leibniz's monads are not related to monads in algebra or Haskell
20:53:12 <dmj`> fresheyeball_: can you explain your use case in a little more detail?
20:54:11 <dmj`> either way, `redirect :: MonadSnap m => ByteString -> m a`
20:54:24 <fresheyeball_> I have a user with a multi-part file upload
20:54:33 <fresheyeball_> and want to pass through to google storage
20:55:37 <bitemyapp> dmj`: we'll see. I'm not sure they know what all they want to change yet, lol.
20:56:36 <em> heatsink: yeah i figured. Do you know about Leibniz Monads?
20:56:37 <dmj`> fresheyeball_: why go through the web server? Why not place a signed url on an html element and have them upload directly
20:56:49 <dmj`> fresheyeball_: or via ajax
20:57:11 <fresheyeball_> I don't want to pass the accesstoken to the client 
20:57:12 <em> heatsink: even though Im pretty sure you are right, I do think that Leibniz philosophy could make a lot more sense if you interpret it with a computer science model.
20:57:37 <fresheyeball_> or require users to link their google accounts
20:58:00 <lmin> em: http://plato.stanford.edu/entries/leibniz/#MetLeiIde
20:58:11 <dmj`> fresheyeball_: you cryptographically sign it and embed an expiry as well, so even if they share it, the rights are only upload (not read), and only valid for <10 seconds
20:58:21 <heatsink> em: No.  Also, I'm rather skeptical of philosophers' approach to ontology in general
20:58:28 <lmin> There's lots right with Leibniz's metaphysics; monads aren't one of those things.
20:58:29 <fresheyeball_> ok, now that I did not know
20:58:29 <dmj`> fresheyeball_: can you use s3?
20:58:32 <fresheyeball_> please tell me more
20:58:47 <heatsink> em: "God must exist, because otherwise he would not be the greatest good" and lots of people believed that was a sound argument
20:58:51 <fresheyeball_> s3 is amazon?
20:59:05 <dmj`> fresheyeball_: yes
20:59:38 <fresheyeball_> google nearline is a requirement from the customer
20:59:43 <fresheyeball_> so I have to use google nearline
21:00:30 <dmj`> fresheyeball_: how hard of a requirement is it 
21:01:31 <dmj`> fresheyeball_: I have something that signs urls a direct uploads them to s3 via ajax 
21:01:34 <fresheyeball_> its a hard requirement 
21:01:37 <dmj`> s/a/and
21:01:58 <fresheyeball_> dmj`: that would be cool
21:02:26 <dmj`> fresheyeball_: I'm unfamiliar with nearline, but it might allow you to do something similar
21:02:42 <fresheyeball_> what do I google for
21:02:48 <fresheyeball_> this is an alien concept for me
21:03:20 <fresheyeball_> ?
21:04:25 <dmj`> fresheyeball_: this is what it looks like for s3, not sure where to begin for nearline. https://aws.amazon.com/articles/1434
21:07:10 <heatsink> em: My "No" was in response to "Do you know about Leibniz monads", not the other thing you said.
21:09:34 <lmin> re: formalizing Leibniz' metaphysics, you /are/ aware of Kripke's work, right (and Lewis etc.)?
21:12:05 * hackagebot HaskellNet 0.4.3 - Client support for POP3, SMTP, and IMAP  http://hackage.haskell.org/package/HaskellNet-0.4.3 (lemol)
21:13:09 <OutlawStar> question: If i have a data type that is "Ctor ByteString ByteString ByteString ByteString" is there a clever way to create that from strings with out calling "pack" for each individual string?
21:14:58 <mrmyers> heatsink: To be fair, that was Anselm's argument. Leibniz' argument was certainly an improvement on that: "God, /if it is possible for him to exist/, must neccesarily exist, because ..."
21:17:06 * hackagebot cube 0.1.0 - Cubic DSL for 3D printing  http://hackage.haskell.org/package/cube-0.1.0 (junjihashimoto)
21:17:15 <fresheyeball_> dmj`: https://cloud.google.com/storage/docs/access-control#Signed-URLs
21:17:22 <permagreen> Gotta, I'm not complaining at all, but this is not the conversation I expected to see going on in the channel at all
21:17:23 <fresheyeball_> does that look like it?
21:28:08 <Newb> Hi guys, reall newbie question here, Is there supposed to be anything meaninful that comes after the where in section 1.2 https://wiki.haskell.org/Smart_constructors
21:29:32 <ion> No, the point is just to refrain from exporting the data constructors.
21:30:38 <Cale> Newb: the remainder of the module
21:30:40 <lmin> Newb: It's part of the syntax of module declarations. Look at Section 9.5 here: <https://www.haskell.org/onlinereport/syntax-iso.html>
21:31:09 <Cale> Newb: Effectively, the entire module along with all its declarations are part of the where clause of that module declaration.
21:31:15 <lmin> Whether anything meaningful comes after it is really up to you, I guess!
21:31:50 <Cale> Of course, at the very least, definitions of Resistor and metalResistor need to be provided
21:32:14 <Cale> (that code was written already above)
21:32:16 <Newb> Do those definitions come specifically after the where or can they exist elsewhere in the code
21:32:36 <Newb> right yeah that was my question, I wasnt sure if that code above had to go where the ... was or if I could place it elsewhere
21:32:54 <Cale> The module declaration must be before anything else in the module
21:33:18 <Cale> and while the standard allows for files with multiple modules in them, in practice, the implementations require one module per file
21:34:09 <Cale> (this is so that it's easy to locate and build the code for a module that's imported)
21:34:49 <Newb> I currrently have something like data Set a = Set {list :: [a]} and am trying to create a smart constructor so that I can run nub on the list provided, so do I turn Set into a module?
21:35:30 <Cale> Right, you probably want to put that Set datatype in its own module along with the smart constructor and other operations on it.
21:35:30 <lmin> Yes, since you only want to expose functions that conform to the axioms for sets
21:37:34 <Cale> Modules are the primary means of abstraction in Haskell. Haskell's module system is really simple compared to the module systems in SML or OCaml, but it's pretty nicely positioned when considering the implementation cost.
21:37:48 <Cale> I mean, data abstraction rather.
21:37:56 <Cale> There are obviously lots of other abstraction mechanisms
21:38:56 <lpaste> Newb pasted “Set help” at http://lpaste.net/6612930440930000896
21:39:16 <Newb> This could be atrocious and no where close, but am I on the right path with that ^?
21:39:17 <Cale> Okay, first thing, configure your text editor to replace tabs with spaces automatically
21:39:49 <Cale> If you're using vim, you'll want to do something like adding  set expandtab  to your .vimrc
21:41:18 <Cale> Next, you don't *have* to indent all the lines in your module. While it's common to indent the contents of most where clauses in the language, we typically don't do it for the overall module.
21:41:48 <Cale> and I suppose the last thing is just that you haven't actually defined the Set datatype there, and you're not using its constructor
21:42:06 <Newb> replace tab with 4 spaces?
21:42:18 <Cale> yeah, or any number of spaces you like, really
21:42:27 <Newb> Ok cool I set that up
21:42:38 <kadoban> Seems like 2 or 4 are the popular options
21:43:17 <Cale> The important thing is that tab characters do not occur in source files, because they're treated differently by different people's editors, but the compiler will treat them as aligning to the next multiple of 8 spaces
21:43:34 <kadoban> And 8 is … pretty extreme, haha.
21:44:39 <Newb> I thought doing the whole module thing was defining the datatype/ constructor (I know I am probably uber noob status right now, still trying to wrap my head around haskell)
21:44:49 <Cale> Nope, the module is a separate thing
21:45:01 <Cale> You still need to define the datatype and such
21:45:39 <Cale> It's just what allows you to not export the data constructor, so that the users of your module can't make a Set out of just any list.
21:45:54 <Cale> (and so you can enforce the invariant you wanted)
21:47:15 * hackagebot yesod-mangopay 1.11 - Yesod library for MangoPay API access  http://hackage.haskell.org/package/yesod-mangopay-1.11 (FelipeLessa)
21:47:17 * hackagebot mangopay 1.11 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.11 (FelipeLessa)
21:47:19 <Newb> So when defining the datatype would I use nubSet or back to Set a = Set {list :: [a]}
21:48:21 <Cale> you'd just define it as usual
21:48:55 <Cale> but you might additionally define a function like  fromList :: (Eq a) => [a] -> Set a; fromList xs = Set (nub xs)
21:49:21 <Cale> and then the idea is that you don't give the users of your module access to the Set data constructor, you only give them things like fromList
21:49:44 <Cale> So they can only make Sets whose lists of elements have already been nubbed
21:51:23 <Gurkenglas> (Maybe even provide unsafePerformNubbed :: [a] -> Nubbed a when the user is really sure the list is already nubbed? x))
21:51:28 <Newb> Ok Ill give that a try and come back, thanks for the help
21:52:16 * hackagebot base-compat 0.7.1 - A compatibility layer for base  http://hackage.haskell.org/package/base-compat-0.7.1 (SimonHengel)
21:54:41 <lpaste> Newb revised “Set help”: “No title” at http://lpaste.net/6612930440930000896
21:54:52 <Newb> What part of what you said am I missing here
21:55:10 <Gurkenglas> Your curly brackets aren't balanced
21:55:17 <Gurkenglas> wait they are what
21:55:28 <Gurkenglas> Sorry I'm gonna shut up for the next 10 minutes.
21:56:06 <Cale> there's a few things wrong... one is that there's an extra comma after nubSet in the export list, another is that there are still lots of tab characters and things are indented erratically
21:56:19 <Cale> But that isn't the error I'd expect to get there
21:56:30 <Cale> So, what exactly are you doing to load this code?
21:56:44 <Cale> Here, let me just fix it for you, first of all :)
21:57:56 <lpaste> Cale revised “Set help”: “No title” at http://lpaste.net/6612930440930000896
21:58:52 <Cale> oh, one more edit required
21:59:09 <lpaste> Cale revised “Set help”: “No title” at http://lpaste.net/6612930440930000896
21:59:39 <Cale> (We need to know that the type 'a' supports equality testing for nub to work)
22:00:47 <newsham> wouldnt "listToSet" be a good name there?
22:01:16 <Cale> newsham: Sure, that would be fine as well.
22:01:32 <Newb> Hm that code does look much better then mine but I am still getting the same error
22:01:55 <newsham> i wrote a haskell-advocacy post today.  would love any feedback -- http://thenewsh.blogspot.com/2015/04/why-i-love-haskell-example.html
22:02:06 <LQYMGT> Sorry to break in, but I just wonder whether Real World Haskell is outdate now ?
22:02:11 <Cale> Okay, then the problem is now what you're doing to invoke this code. Put this source code in Set.hs and then try to load it by running  ghci Set.hs  on the commandline.
22:02:30 <Cale> LQYMGT: Perhaps slightly.
22:02:35 <newsham> LQYMGT: haskell is a moving target, but RWH shouldnt be that dated
22:02:40 <Cale> LQYMGT: It's not wildly out of date
22:02:59 <caconym> LQYMGT: it helped me learn a bunch of haskell as recently as last year
22:03:14 <Cale> But there are almost certainly some small differences in some of the libraries, and if you have the latest GHC, there have been a bunch of changes to the Prelude library.
22:03:36 <Cale> (i.e. the GHC which came out just a handful of days ago)
22:03:53 <newsham> when's the next haskell-platform due out?
22:04:10 <Newb> You right cale, I put it in a seperate file and it loaded fine
22:04:18 <LQYMGT> So it is still suitable... Thanks :)
22:05:26 <caconym> newsham: I must admit that I opened your post and was too lazy to grok the function definition at the top so i didn't keep reading
22:06:04 <caconym> newsham: it might have grabbed my attention more if you went straight into what attributes of the problem were fun/nice to solve using haskell, or something
22:06:13 <Newb> newsham I got to the problem paragraph and got lost in all the acronyms, but that might make more ense to someone more haskell/comp sci savy
22:06:30 <caconym> newsham: but also i am a lazy reader with a short attention span, so don't use me as any more than a data point
22:06:44 <caconym> newsham: also i don't need to be convinced that haskell is great :)
22:07:30 <Gurkenglas> I suspect the problem was in the "93:1" part - did you not put the pasted section at the beginning of your file?
22:08:13 <Newb> I did not, do modules need to go in the beggining? I ended up taking out the beginning of the file and putting it there and it worked
22:09:13 <Cale> Newb: Yeah, the module declaration needs to go at the beginning of the file, and there can be at most one
22:10:06 <Cale> Newb: It's basically saying something about all the code which is in this particular file -- which things from this file are to be made available to programs which import this module.
22:11:22 <Newb> Gotchya Cale , Thanks for all the help
22:12:19 <Newb> One last (hopefully) question. Given the code you provided, nubSet now provides the functionality I want whereas Set just still contains the unnubbed list
22:13:46 <Newb> So err, how do I change that
22:14:02 <Cale> Newb: Yeah, which is why you only export the Set *type* and not the Set *data constructor* from the module. It's a little unclear because they're called the same thing here, but if you wanted to export the Set data constructor, you'd have to put something like Set(Set) or as a shorthand, Set(..) in the export list.
22:14:38 <newsham> if "nubSet" is the only way outsiders can create a Set, then they will never create un-nubbed sets 
22:14:44 <Cale> Newb: The point being that other things which import this module are not allowed to use the Set data constructor (which is unsafe), they're only given access to the things you exported, like nubSet
22:17:33 <ion> edwardk: I hadn’t seen https://yow.eventer.com/yow-2014-1222/functionally-oblivious-and-succinct-by-edward-kmett-1701, thanks for the link.
22:18:10 <Gurkenglas> Try to seperate links and additional characters.
22:19:03 <Newb> Cale so the export list is the stuff I list in the Module definintion.
22:20:06 <Newb> Can you just clarify which is the type and which is the data constructor
22:20:11 <Newb> Sorry for being such a noob
22:21:39 <newsham> ion: ty, too. :)
22:21:55 <heatsink> Newb: In a data declaration, the type constructor is defined on the left side of the = and the data constructors are defined on the right side
22:22:14 <heatsink> Newb: Your type constructor is named "Set" and your data constructor is also named "Set"
22:22:48 <Cale> Newb: So, if it had been defined as  data Set a = MkSet { list :: [a] }  instead, then MkSet would be the data constructor, and Set would be the type constructor
22:23:05 <Cale> Data constructors appear in expressions and patterns, and they effectively construct values
22:23:38 <Cale> Type constructors appear in types (i.e. on the right hand side of the :: )
22:26:59 <tr9yy> is there any way to call all outstanding finalizers on ForeignPtrs other than calling performGC a few times?
22:27:38 <tr9yy> I run with +RTS -N -RTS and calling performGC a single time won't call all finalizers sometimes
22:28:11 <heatsink> Why do you want to call finalizers?  They're not designed to be called at a reliable time.
22:28:30 <tr9yy> It's for a test to see if they are all cleaned up
22:29:10 <Newb> Thanks Cale and heatsink
22:29:13 <heatsink> As I recall, when the GC detects that an object is ready to finalize, it schedules it to be finalized at the next GC
22:29:54 <tr9yy> It does that when I call performGC without the rts -N option
22:30:16 <tr9yy> but with -N I have to call performGC multiple times
22:32:02 <jellie> How can I access the info under <plaintext> which is under the <pod title="Result".../> using the XML package?
22:32:04 <jellie> Here is the small xml file http://ix.io/hkN
22:32:13 <heatsink> I don't know of another way to run finalizers
22:32:19 <Newb> One more time just to make sure, it is possible for me to somehow give Set the functionality of nubSet?
22:32:40 <lpaste> Newb revised “Set help”: “Set help” at http://lpaste.net/6612930440930000896
22:33:27 <tr9yy> thanks heatsink, I've been looking for one a bit and just wanted to see if there's something obvious
22:35:25 <heatsink> np, tr9yy
22:35:35 <heatsink> What do you mean, Newb?
22:35:47 <Cale> Newb: not Set itself
22:35:49 <Newb> I don't even know anymore heatsink, I have just confused myself
22:36:05 <jellie> Newb: hahaha your nick.
22:36:17 <caconym_> Newb: I think the answer is no, at least with things as they are now
22:36:19 <Newb> Am I not supposed to even be constructing Sets anymore? only nubSets?
22:36:43 <caconym_> Newb: Data constructors can't "modify" the parameters they're given in that way
22:37:08 <Cale> Newb: The point is that the Set data constructor here becomes your internal, unsafe way to construct Set values, while nubSet is the "public" way to construct them.
22:38:47 <Cale> Newb: You could call it something like 'set' if you wanted, but it's not a data constructor, and you won't be able to match on it. There's a very new language extension called PatternSynonyms which could be used to allow pattern matches, but I don't know whether you want those details right now :)
22:39:08 <caconym_> Cale: huh, TIL :)
22:39:27 <Newb> Gonna go with that then Cale, Think that sounds over my head haha. Thanks again for all your help, you guys rock.
22:39:41 <Cale> Newb: Yeah, no problem :)
22:44:18 <srid> I'm pretty satisfied with cis194 so far. This should be the introductory haskell 'book' for existing (imperative or functional) programmers 
22:58:38 <bramgg> Can I create a data type that only allows a certain list of strings without any extensions?
22:59:03 <solatis> what do you mean with "a certain list of strings" ? you mean with specific values ?
22:59:10 <bramgg> yes
22:59:25 <bramgg> in this specific case I have a model in mind that would only ever be one of two strings
22:59:58 <solatis> let me think
23:00:11 <solatis> this requires compile time evaluation of the contents of the list
23:00:15 <solatis> is that even possible ?
23:00:16 <jle`> data Foo = S1 | S2 | S3 | S4
23:00:19 <jle`> etc.
23:00:35 <jle`> encoded S1 = "the first of the list of strings"
23:00:41 <jle`> encoded S2 = "the second", etc.
23:00:41 <bramgg> solatis: err, the list was in my mind. Sorry for not being clear about that.
23:00:57 <bramgg> like data OneOfTwo = "foo" | "bar"
23:01:05 <solatis> ah right
23:01:26 <bramgg> jle`: "encoded"?
23:01:27 <arkeet> data OneOfTwo = Foo | Bar; enc :: OneOfTwo -> String; enc Foo = "foo"; enc Bar = "bar"
23:01:29 <jle`> yeah, you can do something like data OneOfTwo = Foo | Bar; stringFromOneofTwo Foo = "foo"; stringFromOneOfTwo Bar = "bar"
23:01:36 <jle`> bramgg: it's a function
23:01:39 <jle`> you're defining
23:01:43 <arkeet> and you can write dec :: String -> Maybe OneOfTwo
23:01:58 <jle`> encoded :: Foo -> String, stringFromOneOfTwo :: OneOfTwo -> String, etc.
23:02:03 <jle`> whatever you want to call i
23:02:04 <jle`> t
23:02:10 <jle`> using pattern matching
23:02:12 <em> so what is a monad in haskell? is haskel the only language with a monad?
23:02:22 <solatis> em, no, not at all
23:02:25 <pacak> em: You can monad in any language
23:02:38 <solatis> monad is just a difficult name for a simple principle
23:02:42 <pacak> The same as you can Fortran in any language.
23:02:51 <em> I guess I had the impression that a monad was a very esoteric and difficult thing to understand.
23:02:54 <bramgg> ah, so basically I would add the restrictions in the functions, not the actual data type declaration
23:02:56 <solatis> no, hold on
23:03:10 <solatis> em, for me i found a javascript implementation of a monad that made it "click" with me
23:03:15 <pacak> em: Not really. Monads are nice, warm and fuzzy things, similar to burritos.
23:03:17 <jle`> bramgg: your data declaration is a sum type with only three options
23:03:20 <bramgg> solatis: can you link that?
23:03:26 <solatis> uno momento
23:03:32 <solatis> https://curiosity-driven.org/monads-in-javascript
23:03:33 <jle`> bramgg: three constructors
23:03:39 <bramgg> solatis: ty
23:03:43 <caconym_> monads are like tacos
23:03:44 <bramgg> will read later
23:03:45 <jle`> bramgg: and to "get the string", you'd write a function, getTheString :: OneOfTwo -> String
23:03:45 <johnw> em: I doubt you will find a satisfying answer to your query tonight, I'd suggest reading more and coming back to the question in a while
23:03:56 <solatis> caconym_, if you eat too much of them your brain farts?
23:04:15 <em> ok
23:04:31 <jle`> they aren't esoteric and difficult things to understand...but they're not very useful or meaningful things to understand on their own without application or context or practical usage
23:04:41 <solatis> em, javascript is especially useful since it can return functions, and bind that function to a specific context
23:04:41 <caconym_> solatis: a brain fart is like a best case scenario after eating too many monads :)
23:04:44 <solatis> that context is the monad
23:05:17 <MP2E> learning about monads is like learning what a musical instrument is, it helps you identify a pattern but it doesn't help you actually play any of those instruments
23:05:19 <jle`> many problem domains common across many languages can apply monads to be useful...but it's better to actually understand how to use specific applications than trying to understand monads as a whole (which is not very helpful or meaningful)
23:05:33 <jle`> but the actual concrete usages are very simple and straightforwrd to understand
23:05:45 <jle`> and definitely non-esoteric...happening every day in most programming languages, even
23:06:04 <bramgg> jle`: re-read your replies, makes sense, ty
23:07:03 <jle`> np!
23:07:11 <Maxdamantus> better at first to understand specific examples, that is.
23:07:24 <Maxdamantus> once you understand that you can probably identify the common pattern and say whether or not something else is a monad.
23:07:32 <Maxdamantus> or whether a monad would be useful.
23:08:20 <Maxdamantus> even though it has a fairly strict meaning, it's difficult to intuitivise on its own.
23:12:52 <caconym_> i think my favorite bite-size description of monads is still "programmable semicolons"
23:13:53 <mniip> burritos I'm telling you
23:14:57 <lpaste> bramgg pasted “<opinion>which is better?</opinion>” at http://lpaste.net/130286
23:15:09 <johnw> I have to say, likening them to burritos may be amusing to those who understand monads and who know the "in joke", but it can be both confusing and frustrating to newcomers who are asking a sincere question
23:15:37 <johnw> I target this at no one, since I've engaged in that humor myself on numerous occasions
23:15:46 <johnw> but after em's question, it struck me this way tonight
23:15:49 <caconym_> monad transformer stack: https://vimeo.com/90127834
23:16:13 <bramgg> ^ lpaste 
23:16:21 <mniip> bramgg, first, but without x
23:16:28 <mniip> use the _ thing
23:16:39 <bramgg> mniip: cheers
23:17:13 <lpaste> mauke annotated “<opinion>which is better?</opinion>” with “<opinion>which is better?</opinion> (annotation)” at http://lpaste.net/130286#a130287
23:17:54 <bramgg> mauke: is that really what you'd go with?
23:17:55 <lpaste> mauke revised “<opinion>which is better?</opinion> (annotation)”: “No title” at http://lpaste.net/130287
23:18:16 <bramgg> fancy.jpg
23:18:26 <mauke> bramgg: I don't like having to repeat stringToSplit or x three times
23:25:29 <EvanR> programmable semicolons wouldnt make sense in the context of most haskell code or any language that doesnt use semicolons
23:26:00 <EvanR> which is where a lot of new haskellers are coming from
23:26:23 * Maxdamantus wishes Haskell required semicolons.
23:26:31 <EvanR> gross
23:27:03 <randir> how do I import only a single operator from a module, and have the rest be imported qualified?
23:27:08 <randir> import qualified Data.Map (!) as M didn't work
23:27:14 <randir> nor import qualified Data.Map as M (!)
23:27:15 <Maxdamantus> > let { a = 4; b = 5 } in a + b
23:27:16 <lambdabot>  9
23:27:21 * hackagebot clash-prelude-quickcheck 0.1.1.0 - QuickCheck instances for various types in the CaSH Prelude  http://hackage.haskell.org/package/clash-prelude-quickcheck-0.1.1.0 (JohnEricson)
23:27:59 <Maxdamantus> the structure of `let` seems fairly non-obvious without them.
23:28:09 <EvanR> if you put it all on one line
23:28:32 <Maxdamantus> if you put it on multiple lines you're not sure what whitespace is meaningful.
23:28:44 <EvanR> yes you are
23:28:50 * Maxdamantus isn't.
23:29:07 <EvanR> the layout rules are
23:29:37 <EvanR> ... a + b where
23:29:39 <EvanR>   a = 4
23:29:41 <EvanR>   b = 5
23:29:57 <Maxdamantus> `where` is quite different to `let`
23:30:06 <mauke> randir: import qualified DAta.Map as M; import Data.Map ((!))
23:30:15 <EvanR> where is syntax sugar for let
23:30:51 <mauke> DECL where BLOCK, let BLOCK in EXPR
23:31:00 <mauke> BLOCK is the same
23:31:01 <Maxdamantus> you wouldn't want to define that sugar with the whitespace layout stuff.
23:31:11 <Maxdamantus> you'd want to use curly brackets and semicolons.
23:31:21 <EvanR> personally id rather use layout
23:31:44 <randir> mauke: Okay, thank you.
23:31:57 <Maxdamantus> mauke: does that explain how far the `in` has to be indented?
23:32:07 <mauke> Maxdamantus: sure
23:32:14 <mauke> it can be indented however you want
23:32:23 <Maxdamantus> I don't think that's true.
23:32:26 <mauke> modulo messing up outer blocks
23:32:43 <Maxdamantus> even taking that into account.
23:32:48 <mauke> there are only three possible cases
23:32:58 <mauke> indented more, indented equal, or indented less
23:33:27 <mauke> indented less works because it explicitly closes the block
23:33:30 <EvanR> i avoid this a lot (when not using where) by doing
23:33:35 <EvanR> let a = 4 in
23:33:37 <mauke> indented more works because we use it all the time
23:33:37 <EvanR> let b = 5 in
23:33:40 <EvanR> a + b
23:33:42 <mauke> ^ like that
23:33:53 <mauke> that's using layout with 'in' indented less than its block
23:34:19 <mauke> I can't imagine 'in' being in the same column as its preceding block making any difference
23:38:33 <Maxdamantus> let b = 4
23:38:35 <Maxdamantus>   in 5
23:38:55 <Maxdamantus> how does `let BLOCK in EXPR` explain that adding an extra space or two to the second line makes that valid?
23:39:14 <mauke> I don't understand the question
23:39:32 <mauke> this de-layouts to "let {b = 4 }in 5"
23:39:44 <mauke> what extra spaces where?
23:43:22 * Maxdamantus is trying to reproduce it.
23:43:40 <Maxdamantus> I'm pretty sure it depends somehow on indenting something further than some token.
23:43:44 <Maxdamantus> sometimes.
23:43:55 <EvanR> theres the do version of let
23:44:10 <Maxdamantus> (than the end of some token)
23:56:02 <caconym_> is there a style guide for haskell that has gained general acceptance as "the" style guide?
23:57:45 <ohxvoa> hi. i'm starting haskell. should i begin with 7.6 or 7.8?
23:58:35 <ohxvoa> and, is it a good language to script to manage your system instead of shell script?
23:58:47 <frerich> caconym_: There's no such thing AFAIK but my impression is that https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md is commonly considered to be reasonably sane.
23:58:54 <ohxvoa> i'm searching for a only-one language to use all-around daily
