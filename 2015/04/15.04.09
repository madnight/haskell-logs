00:09:40 * hackagebot extensible 0.3.3 - Extensible, efficient, lens-friendly data types  http://hackage.haskell.org/package/extensible-0.3.3 (FumiakiKinoshita)
00:09:40 * hackagebot dataflow 0.3.2.0 - Generate Graphviz documents from a Haskell representation.  http://hackage.haskell.org/package/dataflow-0.3.2.0 (owickstrom)
00:14:35 * hackagebot cufft 0.1.2.1 - Haskell bindings for the CUFFT library  http://hackage.haskell.org/package/cufft-0.1.2.1 (RobEverest)
00:14:37 * hackagebot applicative-parsec 0.1.0.0 - An applicative parser combinator library  http://hackage.haskell.org/package/applicative-parsec-0.1.0.0 (KarlVoelker)
00:22:47 <mikeplus64> hm, are there any postgres libraries that nested arrays of rows (or tuples or whatever pg calls them)? ie stuff produced by 'select bar.id, array_agg(foo.*) from ...'
00:24:45 <mikeplus64> assuming foo has fields with different types
00:27:07 <mikeplus64> or composite types at all for that matter
00:28:17 <bartavelle> I think I have a GHC 7.10 problem
00:28:30 <bartavelle> in https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html#g:1 there are two conflicting instances (I think)
00:28:36 <bartavelle> MonadError e (Either e)
00:28:47 <bartavelle> (Monad m, Error e) => MonadError e (ErrorT e m)
00:28:57 <bartavelle> > Left (4 :: Int) <|> Right (12 :: Int)
00:28:58 <lambdabot>      No instance for (Control.Monad.Trans.Error.Error Int)
00:28:59 <lambdabot>        arising from a use of ‘<|>’
00:28:59 <lambdabot>      In the expression: Left (4 :: Int) <|> Right (12 :: Int)
00:29:05 <bartavelle> oh it's not 7.10 :)
00:29:31 <bartavelle> isn't that supposed to work ? Or am I not reading this properly ?
00:34:35 <ocramz`> morning haskells
00:35:03 <ocramz`> I have a FFI/c2hs question, minimal (non)working example here : http://stackoverflow.com/questions/29526738/linker-error-in-c2hs-generated-c-binding
00:36:03 <bartavelle> the monad instance is actually right, it's the alternative instance that isn't defined in Control.Monad.Except
00:39:36 * hackagebot calculator 0.3.1.0 - A calculator repl, with variables, functions & Mathematica like dynamic plots.  http://hackage.haskell.org/package/calculator-0.3.1.0 (sumitsahrawat)
00:42:06 <Geraldus> Greeting everybody!
00:42:59 <Geraldus> How can make per—project HLint configuration? I need to enable TH support (hlint is used by flycheck in my Emacs) and disable some warnings.
00:49:00 <gfixler> is there a more efficient way to do (nub . sort . permutations)?
00:49:51 <mauke> > permutations "abcd"
00:49:52 <lambdabot>  ["abcd","bacd","cbad","bcad","cabd","acbd","dcba","cdba","cbda","dbca","bdca...
00:49:59 <mauke> I see
00:50:30 <gfixler> with "aaaabbbb" you get 40k+ perms; nubbed it's only 70
00:50:47 <kadoban> gfixler: If nothing else, wouldn't    sort . permunations . nub be better?
00:51:17 <gfixler> I want all the items
00:51:35 <gfixler> "abababab", "abbabaab", etc
00:51:50 <kadoban> Oh, right.
00:51:50 <mauke> @check \xs -> (sort . permutations . nub) xs == (nub . sort . permutations) (xs :: String)
00:51:54 <lambdabot>  (0 tests) (1 test) (2 tests) (3 tests) (4 tests) (5 tests) (6 tests) (7 test...
00:52:06 <mauke> ?
00:52:09 <jle`> heh
00:52:14 <kadoban> Err, what is that output, hah. Is @check broken?
00:52:21 <mauke> @check (==)
00:52:22 <lambdabot>  +++ OK, passed 100 tests.
00:52:27 <mauke> @check (/=)
00:52:29 <lambdabot>  *** Failed! Falsifiable (after 1 test):
00:52:29 <lambdabot>  () ()
00:52:34 <jle`> @check \x y -> x + y == y + x
00:52:36 <lambdabot>  +++ OK, passed 100 tests.
00:52:41 <jle`> how weird
00:53:37 <jle`> anyways i can provide a counter example, "aaa", where nubbing first gets you ["a"] but nubbing after gets you ["aaa"]
00:54:03 <jle`> i am a real life quick check
00:54:06 <tdammers> > nub "aabbaacc"
00:54:08 <lambdabot>  "abc"
00:54:11 <tdammers> hmm
00:54:29 <jle`> any reason why i would get a "blocked indefinitely on MVar" when i do'nt use any mvars?
00:54:41 <kadoban> gfixler: Seems like at least you could do a lot better if you do a version of permunations that knows about equal elements. I'm not vastly sure how to do that though immediately …
00:54:41 <mauke> jle`: what do you use?
00:54:44 <tdammers> jle`: maybe something else does, behind your back?
00:54:47 <jle`> i use tchan's
00:54:51 <jle`> *chans
00:54:53 <jle`> does that matter?
00:55:00 <gfixler> kadoban: it feels like it could be a hard problem
00:55:03 <mauke> chans use mvars internally
00:55:19 <jle`> i see
00:55:42 <jle`> i guess i just need to launch a dummy thread that writes to it after forever
00:56:02 <mauke> http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Control-Concurrent-Chan.html#Chan
00:56:43 <gfixler> kadoban: I think what I really want is binary digits
00:56:45 <mauke> a chan is a pair of Stream a = MVar (a, Stream a)
00:59:10 <jle`> thanks :)
01:00:06 <kadoban> gfixler: It doesn't seem too hard to me, but I didn't actually implement it. I think the starting point is … group . sort  the input. Then, say you have two a's and two b's. You want to have free range to place a's, but they must be placed … in the same order each time, you allow a1 a2, but not a2 a1
01:02:16 <kadoban> That probably made no sense. Let me see if I can implement it.
01:03:01 <gfixler> kadoban: something like a stable sort?
01:03:21 <gfixler> my current need is for every ordering of 2 things in a list of length n
01:03:33 <kadoban> Not really I don't think.
01:03:38 <gfixler> and I realized that's basically just all n-length binary numbers
01:03:52 <gfixler> hmmm, wait, no it isn't
01:03:59 <gfixler> back to the drawing board
01:09:05 <kadoban> gfixler: Yeah, I'm not really awake enough to do this, sorry.
01:09:13 <gfixler> kadoban: no worries; me either
01:25:55 <jle`> for some reason network-simple stopped working on my machine in the past half year or so since i last compiled a program with it
01:26:12 <jle`> hm
01:27:50 <jle`> oh it started working again how odd.
01:27:52 <jle`> don't mind me
01:30:31 <mjboa> quit
01:46:43 <Gurkenglas> If compatibility wasn't a problem, for what reason shouldn't "class Functor f => Applicative f (...)" and the like be replaced with "class Applicative f (...) instance Applicative f => Functor f (...)" and the like?
01:47:39 <KaneTW> applicative doesn't really make sense without functor imo
01:47:56 <Gurkenglas> Yes, the instance part would make sure of that
01:48:05 <KaneTW> applicative is an applicative functor, kinda has to be a functor to be that
01:49:06 <KaneTW> well it'd give an automatic implementation for functor but you could have applicative functors that aren't Functors 
01:49:41 * hackagebot knots 0.1.0.1 - Khovanov homology computations  http://hackage.haskell.org/package/knots-0.1.0.1 (maltem)
01:50:12 <Gurkenglas> How? Putting "instance Applicative f => Functor f where fmap = liftA" next to the Applicative declaration would avert that
01:50:30 <dramforever> Gurkenglas: I guess that's not allowed by default
01:50:45 <Gurkenglas> Who is this default?
01:51:02 <dramforever> you need some...you know...BlahBlahInstances extension(s)
01:51:40 <dramforever> You know, FlexibleInstances, OverlappingInstances, UndecidableInstances, etc.
01:51:59 <dramforever> let me see...
01:52:04 <KaneTW> Gurkenglas: right, yeah
01:52:23 <KaneTW> i haven't woken up yet i guess
01:52:46 <dramforever> ha!
01:52:54 <dramforever> wait I'll make a post
01:52:57 <dramforever> to lpaste
01:53:43 <Gurkenglas> If this produces overlapping instances, then since the monad laws imply liftM = fmap (right?), the overlap would only be between equal implementations
01:54:26 <Gurkenglas> Umm I started out with Applicative didn't I, the same goes here of course.
01:54:42 <lpaste> dramforever pasted “You...need these, and ” at http://lpaste.net/130406
01:54:50 <dramforever> great, so far all three are mentioned
01:55:05 <dramforever> lol it's highlighted
01:56:05 <KaneTW> Gurkenglas: ghc is telling me to enable flexibleinstances, and then undecideableinstances if i try to do instance applicative f = functor f
01:56:16 <KaneTW> =>*
01:56:18 <dramforever> keep going
01:56:33 <dramforever> I guess UndecidableInstances is not very good...
01:59:52 <dramforever> Hmm...By adding UndecidableInstances we effectively have a prolog in the type checker
02:00:27 <arkeet> maybe it should be called something more positive.
02:00:32 <arkeet> like TuringCompleteInstances
02:00:40 <dramforever> arkeet: Don't worry
02:00:56 <dramforever> most (okay, many) things are undecidable
02:00:59 <arkeet> someone should write a turing machine simulator in typeclasses.
02:01:11 <dramforever> arkeet: I think there's already one
02:01:11 <KaneTW> ackermann function in types
02:01:17 <merijn> UndecidableInstances isn't that bad, but would probably require FunDeps
02:01:24 <dramforever> SK combinatory calculus
02:01:34 <merijn> By not bad I mean "it won't cause code to do bad things at runtime"
02:01:45 <dramforever> merijn: oh sure. but prolog doesn't have fundeps
02:01:47 <merijn> It could, potentially lead to the compiler infinite looping while compiling :)
02:02:16 * dramforever has never used prolog, actualy
02:04:39 <Gurkenglas> KaneTW, your lpaste doesn't remove the "Functor f =>" out of the "class Functor f => Applicative f"
02:05:01 <KaneTW> not my lpaste, it's dramforever's
02:05:09 <Gurkenglas> ...right
02:05:09 * dramforever is here
02:05:17 <dramforever> oh!
02:05:23 <dramforever> Ha!
02:05:38 <dramforever> don't worry...It's not going to work anyway...(IMHO)
02:06:06 <Gurkenglas> OverlappingInstances would still have to be enabled, but as I said above those shouldn't be a problem, right?
02:06:40 <dramforever> wait...it's an orphan instance! (is it?)
02:06:50 <merijn> OverlappingInstances is far worse than UndecidableInstances
02:07:08 <merijn> And almost always a code smell
02:07:11 <dramforever> neither f nor Functor is defined in Control.Applicative
02:07:19 <lpaste> KaneTW pasted “undecidable” at http://lpaste.net/8794129479124385792
02:07:42 <arkeet> overlapping instances can lead to unpredictable behaviour
02:07:47 <Gurkenglas> merijn, OverlappingInstances makes the compiler assume that it doesn't matter which applying instance implementation to use because they're all equationally equal, right?
02:07:50 <arkeet> undecidable instances just means instance resolution may or may not terminate.
02:08:14 <lpaste> KaneTW pasted “undecidable (now without typos)” at http://lpaste.net/130408
02:08:16 <merijn> Gurkenglas: No, Overlapping lets you define multiple instances that potentially overlap
02:08:36 <merijn> Gurkenglas: When resolving an instance for an overlapping case you don't really have a good way to control which is selected
02:09:00 <arkeet> well, it will pick more specific instances over general ones.
02:09:01 <Gurkenglas> Yes, that means that you are supposed to make sure that overlapping instance implementations are equationally equal on their overlap
02:09:09 <merijn> Gurkenglas: Now, you could rely on the GHC implementation behaviour, but that is not guaranteed and adding more instances can break things accidentally
02:09:13 <Gurkenglas> Just like you are supposed to make sure that your monad instances satisfy the monad laws
02:09:42 * hackagebot conduit-combinators 0.3.1 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.3.1 (MichaelSnoyman)
02:09:47 <dramforever> hey, idea: I remembered a challenge: (any PL) define g such that g()()()...("al") outputs "gooo...al" and the number of "o"s is equal to the number of ()'s 
02:10:02 <dramforever> e.g. g()()()()("al") outputs gooooal
02:10:06 <lpaste> KaneTW pasted “After enabling UndecidableInstances” at http://lpaste.net/8842669404207448064
02:10:09 <dramforever> (Can't find it...)
02:10:42 <dramforever> KaneTW: should be (<$>) . pure
02:10:46 <dramforever> :t (<$>) . pure
02:10:47 <lambdabot> Functor f => b -> f a -> f b
02:10:51 <KaneTW> right
02:10:54 <dramforever> :t (<$>) pure
02:10:54 <lambdabot> (Functor f, Applicative f1) => f a -> f (f1 a)
02:10:55 <tdammers> dramforever: easy in a dynamic PL with varargs
02:10:55 <arkeet> :t (<$)
02:10:56 <lambdabot> Functor f => a -> f b -> f a
02:11:05 <dramforever> tdammers: has...kell?
02:11:19 <dramforever> typeclasses? I failed, though
02:11:19 <merijn> tdammers: Easy with typeclass recursion too :p
02:11:28 <tdammers> dramforever: I assumed "any PL" to mean "doesn't have to be Haskell"
02:11:35 <dramforever> tdammers: of course
02:11:47 <arkeet> in (<$>) . pure, pure is const.
02:12:15 <Gurkenglas> dramforever, you mean a function with a variable number of variables, or a string of the form 'g'("()")*"(\"al\")"?
02:12:15 <dramforever> KaneTW: oh right
02:12:21 <dramforever> still wrong
02:12:25 <dramforever> Gurkenglas: function
02:12:28 <KaneTW> <$> is in functor though
02:12:34 <dramforever> g()()()("al") is code
02:12:37 <tdammers> so that would have to be a polymorphic function
02:12:40 <arkeet> :t (<*>) . pure
02:12:41 <lambdabot> Applicative f => (a -> b) -> f a -> f b
02:12:42 <KaneTW> and i need to define an instance of functor so it'd be circular
02:12:43 <dramforever> exactly
02:12:56 <KaneTW> :t (<*>) pure
02:12:57 <lambdabot> (b -> a) -> b -> b
02:12:57 <dramforever> KaneTW: ^ by arkeet
02:13:02 <KaneTW> yeah
02:13:05 <tdammers> g()()()("al") is equivalent to g () () () "al"
02:13:07 <arkeet> now the trouble is that
02:13:18 <arkeet> instance App f => Functor f
02:13:22 <arkeet> will overlap with *every* other Functor instance
02:13:25 <dramforever> tdammers: yeah, that's actually very lucky
02:13:31 <KaneTW> yeah
02:13:38 <tdammers> so if the argument to g is (), you have to return a function that takes a () or a String
02:13:45 <dramforever> the author apparently assumes that fun(arg) is application
02:14:00 <dramforever> tdammers: yes
02:14:02 <Gurkenglas> arkeet, but by the applicative laws liftA=fmap (right?), so each and every one of those instance overlaps would satisfy equational equality
02:14:26 <dramforever> tdammers: warning (might apply): it's not as easy as it seems
02:14:37 <mauke> ok, I can make g () () "al" == "al"
02:14:52 <tdammers> dramforever: oh, I'm not suggesting that it's easy
02:14:55 <arkeet> the goooooal thing could be done with some typeclass hackery.
02:15:00 <arkeet> similar to printf
02:15:01 <dramforever> ok
02:15:38 <Gurkenglas> tdammers, what type would g have? It would have to contain (), and "al". Neither () nor String nor Either () String do that.
02:15:42 <tdammers> if you can get to g' () () "al" == "ooal", it should  be near-trivial
02:15:45 <Gurkenglas> *its argument type
02:15:59 <tdammers> g would have to be polymorphic
02:16:13 <tdammers> g :: GoalArgs a b => a -> b
02:16:21 <tdammers> with MultiParamTypeClasses
02:17:35 <tdammers> or maybe more like g' :: GoalArgs a b => String -> a -> b
02:18:43 <tdammers> and then you'd have instance GoalArgs String String where g' = (++)
02:18:47 <tdammers> that one is easy
02:18:59 <tdammers> the other instance is where hair catches fire
02:19:09 <dramforever> yeah
02:19:10 <Gurkenglas> http://lpaste.net/130409
02:19:21 <mauke> got it
02:20:05 <mauke> dramforever: https://www.fpcomplete.com/project/105467/e2iBNE4yYL
02:20:12 <tdammers> still easier than doing it in scheme... or clojure...
02:20:12 <dramforever> Gurkenglas: type error
02:20:39 <dramforever> mauke: ha!
02:20:40 <dramforever> thanks
02:20:48 <dramforever> slow here...
02:20:53 <dramforever> gotta wait for a while
02:21:55 <merijn> Dammit
02:22:01 <merijn> mauke: Beat me to it :\
02:22:24 <merijn> Like, literally the exact same implementation too >.<
02:22:41 <mauke> rekt
02:22:52 <merijn> That's what I get for trying to check my code in ghci
02:23:04 <tdammers> easier than I thought
02:23:06 <tdammers> as usual
02:23:37 <dramforever> anyone help lpaste it for me? too slow here that it timed out
02:23:39 <dramforever> thanks
02:24:04 <lpaste> mauke pasted “g()al” at http://lpaste.net/130410
02:24:19 <dramforever> mauke: thanks, great
02:24:40 <dramforever> woo that's great
02:30:29 <mauke> perl solution: http://fpaste.scsys.co.uk/471435
02:30:36 <mauke> should be easy to adapt to scheme or whatever
02:31:02 <RaceCondition> the wiki seems broken; for example https://www.haskell.org/haskellwiki/Hoogle redirs to https://wiki.haskell.org//Hoogle which yields a 404
02:33:53 <dramforever> fun fact: () in ruby is the same as nil
02:34:27 <dramforever> after I found out this I can't agree more with "ruby is lisp with lots of syntactic sugar"
02:34:41 <dramforever> and "modern" stuff
02:35:25 <mauke> perl is lisp plus syntax minus macros plus stuff
02:36:11 <tdammers> a *lot* of stuff
02:36:23 <tdammers> also, "everything is a lisp if you squint enough"
02:37:07 <arkeet> ok I didn't peek at anyone's solution.
02:37:10 <arkeet> here's mine https://gist.github.com/arkeet/895a55eea05eae796cdc
02:37:31 <arkeet> (it's the first thing that worked and I'm tired)
02:38:20 <tdammers> most of the stuff that is currently touted as "modern" is really a renaissance of pre-OOP concepts
02:38:29 <dramforever> tdammers: 
02:38:38 <mauke> arkeet: that looks wrong
02:38:44 <dramforever> ouch
02:38:45 <arkeet> well I ran it and it works
02:39:05 <mauke> how can g "al" :: String be "g"?
02:39:06 <arkeet> oops too many os
02:39:26 <arkeet> bad copy paste.
02:39:29 <mauke> it should at least contain "al"
02:39:44 * hackagebot product-profunctors 0.6.1 - product-profunctors  http://hackage.haskell.org/package/product-profunctors-0.6.1 (tomjaguarpaw)
02:40:10 <arkeet> fixed haha.
02:40:13 <arkeet> see I'm tired.
02:40:50 <crvs> well, that seems contrived...
02:40:56 <arkeet> of course it is.
02:41:20 <crvs> hooray for obscurity!
02:41:38 <arkeet> I like mauke's better.
02:41:45 <mauke> http://fpaste.scsys.co.uk/471436 perl solution that uses mutability
02:43:17 <arkeet> a more realistic application of such typeclass hackery is https://hackage.haskell.org/package/base-4.8.0.0/docs/Text-Printf.html
02:43:26 <merijn> crvs: Contrived is a summary of 80% of the code mauke pastes here ;)
02:44:03 <mauke> guess who's written his own printf
02:44:12 <arkeet> is it safe?
02:44:28 <mauke> the TH version should be
02:44:34 <arkeet> well yes I hope a TH version would be.
02:44:36 <merijn> crvs: Wanna see truly contrived? https://github.com/mauke/poly.poly/blob/master/poly.poly
02:44:44 * hackagebot syntactic 2.1 - Generic representation and manipulation of abstract syntax  http://hackage.haskell.org/package/syntactic-2.1 (EmilAxelsson)
02:44:58 <arkeet> how many languages is this.
02:45:00 <merijn> mauke: That file works wonders to scare 1st year students, btw :p
02:45:55 <merijn> arkeet: According to the tests 26, if you count different dialects of the same language
02:46:11 <mauke> about a dozen
02:46:25 <crvs> merijn: ouch... that's just painful
02:46:26 <arkeet> oh there's chk.t
02:46:27 <arkeet> lol
02:46:30 <mauke> the tests aren't exhaustive
02:46:39 <mauke> e.g. it doesn't test all combinations of LANGUAGE flags
02:47:07 <Cale> Can you make the testing script a polyglot too?
02:48:24 <mauke> what for? :-)
02:48:29 <NateUni> Hi guys.. I want to ask a question about using (x:xs) to split lists. if I can.. 
02:48:47 <pingu> NateUni: It is quite possible.
02:48:56 <mauke> x : xs doesn't split lists, it just extracts the first element
02:49:00 <mauke> merijn: why would you show that to first year students? :-)
02:49:22 <NateUni> ok.. thanks.. pingu: What is going on here -> 
02:49:26 <NateUni> split :: Ord a => [a] -> ([a],[a])
02:49:27 <NateUni> split [] = ([], [])
02:49:28 <NateUni> split (x:[]) = ([x], [])
02:49:30 <NateUni> split (x1 : x2 : xs)  = (x1:xs1, x2:xs2)
02:49:31 <NateUni>   where
02:49:31 <NateUni>     (xs1, xs2) = split xs
02:49:32 <pingu> mauke: which is "splitting" the product type.
02:49:40 <merijn> mauke: To terrify them :p
02:49:44 * hackagebot open-typerep 0.3.1 - Open type representations and dynamic types  http://hackage.haskell.org/package/open-typerep-0.3.1 (EmilAxelsson)
02:49:49 <NateUni> I mean with the: (x1 : x2 : xs)
02:49:50 <arkeet> please don't paste multiple lines in irc like that in the future.
02:49:57 <pingu> NateUni: it's pattern matching twice
02:49:59 <NateUni> sorry.. 
02:50:07 <Cale> NateUni: each of the patterns is tried in turn, and the first pattern to successfully match is taken.
02:50:09 <arkeet> it's the same as (x1 : (x2 : xs))
02:50:15 <mauke> : is right associative, so ... ^
02:50:15 <pingu> NateUni: you can see it more clearly if you bracket it like that ^^
02:50:28 <Cale> NateUni: (x1 : x2 : xs) matches any list with at least two elements
02:50:39 <Cale> (x : []) matches only lists with exactly one element
02:50:43 <pingu> NateUni: (and hence it will fail on any list shorter than two elements.
02:50:47 <Cale> and [] of course matches only the empty list
02:50:56 <mauke> merijn: do you work at a university?
02:51:30 <merijn> mauke: Yeah, have to teach as part of my phd :)
02:51:37 <NateUni> ok.. so why a list with two elements.. isnt that 3? (x1 : (x2 : xs))
02:51:43 <arkeet> xs is a list.
02:51:44 <arkeet> it migth be empty.
02:51:54 <dramforever> @src []
02:51:54 <lambdabot> data [] a = [] | a : [a]
02:52:02 <Cale> NateUni: It's like saying "If the list has at least 2 elements, and those first two elements are x1 and x2, and the rest of the list beyond that point is xs, then the result should be ...
02:52:12 <NateUni> also arkeet: what do you want me to do if I have mutiple lines like that next time?
02:52:21 <dramforever> NateUni: see topic
02:52:21 <arkeet> @where lpaste -- use a pastebin such as this
02:52:22 <lambdabot> http://lpaste.net/
02:52:22 <dramforever> lpaste
02:52:25 <mauke> merijn: and you choose to teach them fear? :-)
02:52:31 <NateUni> and xs could be []?
02:52:34 <arkeet> yes.
02:52:37 <arkeet> it could be any list.
02:52:59 <arkeet> matching (x1 : x2 : xs) against [1,2] would put 1 in x1, 2 in x2, and [] in xs
02:53:02 <merijn> mauke: Functional languages and compilers, fear...what's the difference? ;)
02:53:02 <NateUni> hmm ok.. great. As usual you guys are a great help.
02:53:03 <arkeet> because [1,2] = 1 : 2 : []
02:53:06 <Cale> > let (x1 : x2 : xs) = [1,2] in (x1, x2, xs)
02:53:08 <lambdabot>  (1,2,[])
02:53:11 <arkeet> yeah.
02:53:12 <Cale> > let (x1 : x2 : xs) = [1,2,3,4,5] in (x1, x2, xs)
02:53:13 <lambdabot>  (1,2,[3,4,5])
02:53:48 <merijn> > let (x1 : x2 : xs) = (1:(2:[])) in (x1, x2, xs)
02:53:50 <lambdabot>  (1,2,[])
02:54:31 <NateUni> ok two or more elements.. is there a limit on how many times you can match like this.. 
02:54:33 <NateUni> ??
02:54:43 <Cale> Not really
02:54:55 <Cale> You can arbitrarily nest patterns however you like
02:55:02 <arkeet> > let (a:b:c:d:e:f:g:h:r) = [1..20] in (a,b,c,d,e,f,g,h,r)
02:55:03 <lambdabot>  (1,2,3,4,5,6,7,8,[9,10,11,12,13,14,15,16,17,18,19,20])
02:55:29 <mattby> >let a =  [1..20] in (a,b,c,d,e,f,g,h,r)
02:55:30 <arkeet> your pattern structure can get as deep as yo ulike.
02:55:33 <mattby> > let a =  [1..20] in (a,b,c,d,e,f,g,h,r)
02:55:34 <lambdabot>      No instance for (Show t0)
02:55:35 <lambdabot>        arising from a use of ‘show_M572101467385235245031121’
02:55:35 <lambdabot>      The type variable ‘t0’ is ambiguous
02:55:42 <arkeet> mattby: you didn't bind b or c or ...
02:55:46 <Cale> > let f ((x,y):(z,w):xs) = (z,x):(w,y):xs in f [(1,2),(3,4),(5,6)]
02:55:47 <lambdabot>  [(3,1),(4,2),(5,6)]
02:55:55 <pingu> NateUni: It's arbitrary because you're just pattern matching over and over.
02:55:58 <pingu> But one at a time.
02:56:10 <pingu> and : is just an infix data constructor
02:56:35 <pingu> with a certain fixity and such
02:56:43 <arkeet> > (0$0:)
02:56:44 <lambdabot>      The operator ‘:’ [infixr 5] of a section
02:56:44 <lambdabot>          must have lower precedence than that of the operand,
02:56:44 <lambdabot>            namely ‘$’ [infixr 0]
02:56:52 <bennofs> Is reactive-banana really FRP? Since it doesn't provide real "time-varying" behaviors ... the only way to create a Behavior is through Stepper, so you could also represent it as data Behavior = Behavior a (Event a) and would not loose anything, would you?
02:56:59 <Cale> NateUni: Anywhere that you could use a variable in a pattern, you could use any other pattern there instead.
02:57:38 <Cale> (at least, so long as that pattern doesn't use variables which are already taken)
02:58:05 <jle`> bennofs: is that really how it's set up?
02:58:29 <jle`> hmh
02:58:33 <pingu> Cale: well you couldn't use *any* other pattern, surely only where the the type is variable also.
02:58:33 <bennofs> jle`: well, there are only two functions to create behaviors: pure :: a -> Behavior t a and stepper :: a -> Event t a -> Behavior t a
02:58:41 <jle`> interesting
02:58:57 <shachaf> Cale: Not v@p :-(
02:58:59 <jle`> so the only primitive behaviors are "constant functions"...and steps between them
02:59:03 <bennofs> jle`: (and (<*>) :: Behavior t (a -> b) -> Behavior t a -> Behavior t b)
02:59:05 <mauke> pingu: syntactically you can
02:59:24 <pingu> mauke: sure, but I sure *hope* you can't type it
02:59:34 <arkeet> bennofs: what other sort of behaviors do you want?
02:59:45 <jle`> it's still FRP because it abstracts over discrete time...and it still uses continuous time semantics by allowing you to "interleave" event streams
02:59:50 <jle`> interleave steps appropriately
03:00:04 <Cale> shachaf: Oh, that's a good point, the variable v in a pattern of the form v@p isn't allowed to be another pattern
03:00:15 <jle`> the continuous time abstraciton is probably used to define a meaningful liftA2/ap on steppers
03:00:20 <bennofs> arkeet: well, to be continously, you need at least time :: Behavior t Double or smth
03:00:41 <jle`> yeah, you can't represent arbitrary `Time -> a`s with this set-up
03:00:51 <jle`> but you can still represent a subset and be useful i guess
03:00:55 <bennofs> jle`: yeah, the problem probably arises when you try to get the "changes slightly after the event occurred"
03:00:57 <arkeet> well its notion of time is discrete.
03:01:04 <jle`> it can't
03:01:06 <jle`> if it's FRP
03:01:06 <arkeet> natural number time.
03:01:38 <bennofs> jle`: you cannot do this with my definition of Behavior (with reactive-banana, stepper a ev <@ ev returns the value of the stepper "slightly" before ev occurred)
03:01:45 <jle`> the Applicative instance for stepper uses continuous time semantics to work...so that's correct in FRP
03:02:01 <jle`> that's probably where the FRP "comes in"
03:02:20 <jle`> is there any clock behavior, maybe?
03:02:34 <jle`> whose output is the time elapsed?
03:02:36 <bennofs> jle`: no. reactive-banana doesn't provide any built-in time
03:03:32 <bennofs> jle`: you can create a counter yourself by creating a timer event, but the combinators only talk about time abstractly
03:03:43 <jle`> so...i would say...still uses FRP semantics to be able to do its job and give denotational semantics to its things.  but it only gives you access to a restricted subset of behaviors.
03:03:53 <jle`> my analogy would be a vector art software that only gave you lines
03:03:55 <jle`> and no curves
03:04:13 <bennofs> that sounds correct
03:04:14 <jle`> it's still vector art, and can store things in infinite resolution.  but it only lets you draw a finite subset of shapes
03:04:55 <arkeet> time to sleep.
03:04:58 <jle`> i wonder if this is a limitation of its push-y implementation
03:05:10 <jle`> night arkeet 
03:05:47 <bennofs> it just occurred to me that even with that restriction, you cannot write changes :: Behavior t a -> Event t a such that the event fires when the behavior changes. You could, however, have triggered :: Behavior t a -> Event t a that fires "slightly" before the behavior changes
03:06:28 <jle`> so, stepper is non-invertible
03:07:01 <bennofs> jle`: in current reactive banana, yes. I'd like if reactive banana provided a way to get the two arguments to stepper through :|
03:07:12 <jle`> ...do you mean that you cannot write this using the internal representation of Behavior?  or you can't write it within the offered combinators?
03:07:32 <bennofs> the combinators don't provide it
03:07:41 <NateUni> Sorry guys.. gf came home.. 
03:08:18 <bennofs> it seems that using data Stepper t a = Stepper (Behavior t a) (Event t a), I can get it through (even preserving the property that the event fires slightly before the behavior changes in the Applicative instance)
03:08:34 <NateUni> Cale: “ NateUni: Anywhere that you could use a variable in a pattern, you could use any other pattern there instead.” For example?
03:09:33 <bennofs> jle`: changes would be impossible, since "slightly before/after" in reactive banana means infinitely close to the real event. 
03:09:34 <Cale> NateUni: For example, if I were matching a list of pairs, instead of matching against x : xs, I might prefer to match on (x,y):xs
03:10:21 <jle`> well, i guess for the use case of event-driven GUI's, the current representations seem to be sufficient
03:10:22 <NateUni> so the first pair in the list?
03:10:41 <Cale> NateUni: yeah
03:10:59 <Cale> NateUni: that would actually deconstruct the pair into parts while we were at it
03:11:51 <jle`> i know some have advocated for a mix-and-match approach to working with FRP...rx-banana/sodium for event-driven pushy guis, and pull/afrp for things where you work with continuous Time -> Double's
03:12:04 <jle`> but that always felt a little weird to me
03:12:12 <NateUni> what would you do if you wanted the whole pair and not the parts.. ? Just (x:xs) where  x would be the (x,y)?
03:12:22 <Cale> yeah
03:12:24 <jle`> imagine programming a game when every time you opened a menu, your logic switched to a completley new framework
03:12:47 <NateUni> ok great.. and one last thing can you explain what you did here: let (x1 : x2 : xs) = [1,2,3,4,5] in (x1, x2, xs)
03:12:51 <Cale> Of course "Just (x:xs)" is also a pattern, but I know what you mean ;)
03:13:10 <jle`> i think that new FRP library Reflex has some practical solutions to this maybe.  i still need to watch the talk, but from what i've heard it is an exciting new development.
03:13:18 <bennofs> jle`: hmm. I'd like a framework that can do both
03:13:44 <Cale> NateUni: That was just a way to match the pattern (x1 : x2 : xs) against the list [1,2,3,4,5], and see which parts matched
03:13:45 <jle`> yeah.  switching between two frameworks with completely different vocabulary/api is probably not the most ideal workflow
03:14:01 <jle`> but at least the semantics are the same ^^
03:14:17 <Cale> NateUni: So the first part of the resulting tuple is x1, the second part is x2 and the third part is xs
03:14:25 <Cale> > let (x1 : x2 : xs) = [1,2,3,4,5] in (x1, x2, xs)
03:14:27 <lambdabot>  (1,2,[3,4,5])
03:14:35 <jle`> i think reflex incorporates both arbitrary behaviors and pushy events.
03:14:38 <bennofs> jle`: reflex is quite similar to reactive-banana from what I understand. It also has this notion that behavior change slightly after the corresponding events triggered (it has "Frames", where first all events are propagated and then the values of behaviors are recomputed, as far as I understand)
03:14:47 <Cale> See, so x1 is the first element of the list, x2 is the second, and xs is the remainder [3,4,5]
03:14:47 <jle`> hm, maybe i am speaking from ignorance then
03:15:04 <bennofs> jle`: but it could be that it has a time behavior
03:15:06 <bennofs> let me see
03:15:09 <NateUni> what is the “in” ?
03:15:12 <Cale> Behaviours in reflex are pull, and Events are push
03:15:23 <NateUni> Iam just trying to see what happens and in what order. 
03:15:29 <jle`> beautiful :)
03:15:36 <jle`> > let x = 5 in x + 2
03:15:37 <lambdabot>  7
03:15:46 <jle`> ^ do you understand that, NateUni ?
03:15:57 <Cale> NateUni: let <decls> in <expr> is an expression form, which makes the declarations in <decls> available in the context of the expression <expr>
03:16:07 <bennofs> Cale: hmm, but it only recomputes behavior when any of it's "inputs" / "dependencies" changes, right?
03:16:32 <bennofs> or are all behaviors always recomputed?
03:16:36 <NateUni> is that a lambda expression? 
03:16:43 <Cale> bennofs: A behaviour caches its results, yes
03:17:06 <Cale> But it only ever computes them when demanded, not just every time that the inputs change.
03:17:10 <jle`> if we are talking about arbitrary behaviors, then in general behaviors are always changing
03:17:26 <bennofs> jle`: yes, but you can optimize the special case :)
03:17:35 <jle`> unless you have a reified representation
03:17:41 <jle`> yeah :)
03:18:06 <Cale> bennofs: Reflex also has a monad PullM which you can use to avoid caching.
03:18:19 <Cale> The only difference between PullM and Behaviour is the caching
03:18:27 <bennofs> Cale: can you create a behavior from f :: Time -> a in reflex?
03:18:50 <Cale> bennofs: Well, you need to get the Time from somewhere
03:19:02 <bennofs> Cale: and that is, from a timer event?
03:19:23 <NateUni> I  am still not up to speed on this idea that a function takes one parameter.. (I think that is what I mean) eg the a-> a -> a
03:19:51 <jle`> NateUni: let x = 5 in x + 2 means "wherever you see x in 'x + 2', put a 5 there instead"
03:19:55 <Cale> bennofs: Reflex doesn't have a built in notion of "the current time" in any concrete sort of data representation.
03:20:16 <dramforever> NateUni: -> is right associative
03:20:17 <bennofs> Cale: ah, then it is similar to reactive-banana in this regard
03:20:19 <jle`> is the current time accessible...?
03:20:24 <bennofs> jle`: no
03:20:38 <jle`> is there a behavior `time :: Behavior Double`
03:20:44 <jle`> might not be concrete...but it's there
03:20:45 <Cale> bennofs: But supposing that the current time is in scope, then you could write a PullM which applies the function given, and turn it into a Behavior by applying pull
03:20:56 <Cale> pull :: PullM t a -> Behavior t a
03:21:01 <bennofs> Cale: ah, can PullM do IO?
03:21:03 <Cale> no
03:21:39 <bennofs> Cale: hmm, but PullM is provided by the concrete implementation of the reflex spec, so I guess you could write an implementation that allows access to the "real" time 
03:21:46 <Cale> Well, okay
03:21:50 <bennofs> Cale: and only caches behaviors that do not access the current time
03:21:59 <jle`> hmmmm
03:22:03 <Cale> Some concrete instance of the Reflex type class might define PullM in a way which allows IO
03:22:15 <bennofs> reflex looks really nice so far 
03:22:16 <Cale> But by default, and I think in the given implementation of that class, it can't.
03:22:17 <jle`> or if not arbitrary IO, at least access to the time
03:22:56 <Cale> In my experience, even though the current time is conceptually a behaviour, actually making it into one tends to be not such a great idea.
03:23:11 <jle`> it depends on the application, i think
03:23:16 <Cale> The problem is that it's a behaviour which is *always* invalid.
03:23:28 <Cale> and all of whose dependents are then always invalid
03:23:34 <jle`> invalid?
03:23:39 <Cale> In the sense of caching
03:23:51 <bennofs> Yes, but for example for games, it makes sense
03:23:56 <Cale> So, you end up being forced to recompute everything
03:24:04 <jle`> which is....back to pull frp :)
03:24:09 <Cale> My experience is directly from implementing a game :)
03:24:14 <jle`> well, in practice, even in games, you don't use Time
03:24:20 <Cale> You want the frame timer to be an event there.
03:24:24 <jle`> you abstract away change in time
03:24:33 <jle`> which is the route of netwire etc.
03:25:06 <bennofs> Cale: hmm? but couldn't having a time behavior make your network independent of the actual "time resolution" you run it at?
03:25:10 <jle`> provide a behavior that is *semantically* a `Time -> a`, but with efficient implementation that only relies on the time step
03:25:25 <Cale> bennofs: It can, yes.
03:25:29 <jle`> where the entire api abstracts over the timestep
03:26:02 <jle`> the idea of driving things with clock events sounds like one of the problems that FRP was trying to solve in the first place, though
03:26:21 <jle`> abstracting over clock events was one of the reasons FRP exists as an abstraction to be able to ignore it
03:26:28 <NateUni> can someone explain this:  -> is right associative
03:26:29 <Cale> Well, yeah, it really depends on usage.
03:26:41 <jle`> so you're going to be building an abstraction over your clock events to abstract over it and reason about continuous time...
03:26:47 <jle`> but that's building an FRP framework on top of your FRP framework
03:26:51 <Cale> You can have a currentTime behaviour and just be principled about how you use it and everything is fine
03:27:09 <Cale> It's just building complicated behaviours in terms of currentTime might result in terrible performance issues
03:27:11 <jle`> "just be principled" is like saying you can do OOP in Assembly :p
03:27:20 <Cale> This is something that we came to realise when working on our game
03:27:26 <bennofs> NateUni: it means that a -> a -> a "associates to the right", which means that you begin placing parentheses from the right going outward, so a -> a -> a -> a = a -> a -> (a -> a) = a -> (a -> (a -> a)) 
03:28:14 <jle`> if there was an API that could abstract over clock events and give you semenatic Time -> a's with efficient representation and cacheing...that would be nice
03:28:19 <Cale> NateUni: When you write A -> B -> C -> D, it really means A -> (B -> (C -> D)), and correspondingly, function application associates to the left, so that when you write f x y z, it really means ((f x) y) z
03:28:49 <NateUni> I get the bracket parts but I think of functions as passing something into something forward. As right association is kinda backwards.. 
03:29:15 <Cale> NateUni: If we have f :: A -> (B -> (C -> D)) and x :: A and y :: B and z :: C, then f x :: B -> (C -> D), and then (f x) y :: C -> D, and finally ((f x) y) z :: D
03:29:56 <jle`> how about you drive things by clock events...but then create your behaviors using something like netwire
03:29:56 <stoopkid> NateUni, think of right association as being forward by grouping everything "in front" of where you are together 
03:30:00 <Cale> NateUni: Whenever functions in Haskell appear to have multiple arguments, they really just have one, and produce another function.
03:30:20 <NateUni> Yeah this is what I was asking about before: “NateUni: Whenever functions in Haskell appear to have multiple arguments, they really just have one, and produce another function.”
03:30:35 <NateUni> I still cant get my head fully around this.. 
03:30:38 <jle`> with netwire you can reason about continuous time and abstract away discrete time...build semantic Time -> a's.  and then drive it all on top of your clock events on your pushy frp framework
03:31:28 <jle`> (my idea is intentionally absurd :) )
03:31:52 <Cale> jle`: You can also get reasonable performance just by defining a currentTime behaviour which is obtained by doing a hold on a limited (but arbitrary) resolution timer event.
03:32:07 <stoopkid> NateUni, consider f x y = x + y. if you put in one of the arguments, say x = a, then you get another function f y = a + y
03:32:16 <stoopkid> NateUni, so you can do this with all your arguments
03:32:18 <jle`> NateUni: if you wrote something like plus x y = x + y, then `plus 1 2` gives you 3.  but `plus 1` gives you a function that adds 1 to any number.
03:32:30 <jle`> @let plus x y = x + y
03:32:32 <lambdabot>  Defined.
03:32:39 <jle`> > let plus1 = plus 1 in plus1 10
03:32:41 <lambdabot>  11
03:32:51 <Cale> jle`: But yeah, Reflex's notion of time isn't discrete or continuous really. It's just totally ordered.
03:33:05 <jle`> Cale: you can do that...but then you lose the ability to reason with ideas in continuous time semantics
03:33:20 <jle`> to reason about and make meaningful statements about continuous time behaviors
03:33:32 <Cale> jle`: there's also many different sorts of "continuous time"
03:33:48 <Cale> Like, do you have a measure on the continuous times? Can you express the idea of "1 second from now"?
03:33:51 <jle`> so i was saying...do that reasoning in netwire, and "export it" to this clocky driver
03:34:22 <stoopkid> NateUni, consider that even if your function is implicitly multiple arguments, the computer is still going over things one at a time, these conventions are just making that a little bit more explicit
03:34:23 <Cale> Or "half as much time as what passed between the last two occurrences of this Event"?
03:34:27 <jle`> canonically i am using the definition from the seminal paper :)
03:34:46 * hackagebot lexer-applicative 1.1 - Simple lexer based on applicative regular expressions  http://hackage.haskell.org/package/lexer-applicative-1.1 (RomanCheplyaka)
03:34:49 <jle`> a `Behavior a` is something semantically equivalent to a `Real -> a`
03:35:16 <jle`> anything you can express with a behavior should be expressible as a meaningful `Real -> a`, and vice versa
03:35:25 <sgronblo> Is there an ordered set for haskell?
03:35:33 <Cale> Yeah, the tricky thing about that in high performance settings is that actually making use of it results in kind of shitty caching behaviour.
03:35:56 <sgronblo> as in you can get the values out in insetion order
03:36:11 <jle`> yeah, but the dream is being able to reason about things in a language that only exposes and manipulates Real -> a's
03:36:21 <jle`> even though it's not represented by it internally
03:36:22 <NateUni> I kind of get it.. I read about it in a HAskell book.. and tried it with (< 10) for example. But I am still digesting it.. 
03:36:22 <bennofs> Cale: but assuming you have an animated elements, whose position changes every frame, how can you cache this?
03:36:30 <Cale> sgronblo: Like a list with at most one of any given element?
03:36:31 <NateUni> But thanks again for all your help.. 
03:36:45 <jle`> NateUni: np :) it just takes some getting used to
03:36:50 <jle`> play around with it on ghci :D
03:37:01 <sgronblo> Cale: That's another way to describe a set yeah :)
03:37:40 <solatis> hmmm, is it possible to tell cabal to always import a certain module (similar like implicit Prelude import) ? or is that a thing that's deliberately not supported due to risks of naming conflicts ?
03:37:59 <jle`> there are domains like sound synthesis...where you have Time -> Double, the amplitude of a sample at a given time
03:38:07 <jle`> for most things, it doens't really make sense to cache
03:38:08 <Cale> sgronblo: What happens to the ordering when you insert an element that's already in the ordered set?
03:38:15 <bennofs> The problem is that you have to be careful to not depend on the time too much. Just doing animateIfTrue <$> toggleBehavior <*> time can be bad
03:38:21 <sgronblo> Cale: That shouldn't happen
03:38:40 <Cale> sgronblo: In that case, just use a list.
03:38:57 <jle`> i guess any implementation/representation that tries to be smart about cacheing can be destroyed if you tried
03:38:57 <sgronblo> Cale: but then membership is O(n)?
03:39:01 <jle`> or unintentionally
03:39:16 <bennofs> jle`: that example didn't look to me like I tried very hard :)
03:39:19 <Cale> sgronblo: Okay, I guess there's some advantage to making it a synchronised list and Set.
03:39:26 <jle`> heh.
03:39:44 <Cale> sgronblo: But deletion will be costly, because you'll need to traverse the list.
03:40:03 <bennofs> If only we could figure out a way to make const c <$> time a behavior that does not depend on the time
03:40:25 <jle`> if only we had reified functions in haskell
03:40:36 <Cale> sgronblo: I suppose if you wanted to fix *that* you could use (Seq a, Map a Int)
03:40:41 <bennofs> Perhaps you could do it with observable sharing
03:40:59 <bennofs> or, just pass "undefined" as time once, and look if it blows up?
03:41:03 <jle`> lol
03:41:24 <jle`> i laugh only because i've done things like that before
03:41:29 <bennofs> jle`: don't laugh, lens has a module that uses this trick to create lenses from any record getter!
03:41:33 <Cale> bennofs: Right, that's exactly the trouble. When things *aren't* moving, you don't want to be recomputing their positions every frame
03:41:36 <jle`> :p
03:41:41 <bennofs> > (1,2) & upon fst .~ 3
03:41:43 <lambdabot>  (3,2)
03:41:46 <bennofs> magic!
03:42:17 <bennofs> (through quite fragile I guess ...)
03:42:22 <NateUni> Thanks as well Cale..!
03:42:31 <jle`> for a library i suppose that's perfectly reasonable if you can justify it
03:42:42 <jle`> and i can't say i've never done it v.v
03:42:42 <Cale> NateUni: perhaps this example will help...
03:42:54 <Cale> We can define a function add x y = x + y
03:42:58 <Cale> @let add x y = x + y
03:43:00 <lambdabot>  Defined.
03:43:03 <Cale> > add 3 6
03:43:05 <lambdabot>  9
03:43:23 <Cale> add 1 is then a function which adds 1 to its argument
03:43:28 <Cale> @let addOne = add 1
03:43:29 <lambdabot>  Defined.
03:43:37 <Cale> > addOne 5
03:43:39 <lambdabot>  6
03:44:03 <Cale> In terms of the types, we might have  add :: Integer -> Integer -> Integer
03:44:07 <jle`> hm. i guess all i really am thinking about is a library to be able to have efficient pushy things when it needs it, and also be able to reason about and manipulate/make statements about arbitrary Time -> a's in an efficient way when possible.
03:44:08 <bennofs> Maybe we could have data Timed a = Timed a that says "this value depends on the time" and then have time :: Timed Time
03:44:11 <Cale> that is,  add :: Integer -> (Integer -> Integer)
03:44:22 <Cale> So, add 1 :: Integer -> Integer
03:44:33 <Cale> and addOne has the same type, being equal to add 1
03:44:43 <bennofs> that would it make even more explicit and would at least prevent my example
03:44:58 <Cale> NateUni: This sort of thing is very handy in conjunction with higher order functions such as map
03:45:12 <jle`> maybe have behaviors defined as regions
03:45:14 <bennofs> ah, I think you need data Timed a = Timed a | Pure a
03:45:17 <Cale> NateUni: map is a function which takes a function and a list, and applies the given function to all the elements of the list
03:45:28 <Cale> > map (add 1) [10,20,30,40]
03:45:30 <lambdabot>  [11,21,31,41]
03:45:46 <Cale> > map (map (add 1)) [[10,20],[30,40]]
03:45:48 <lambdabot>  [[11,21],[31,41]]
03:46:04 <NateUni> yeah I get that it saves you time by making generic functions like map
03:46:27 <Cale> So, we don't have to use a lambda here
03:46:38 <Cale> You might otherwise have to write:
03:46:45 <Cale> > map (\x -> add 1 x) [10,20,30,40]
03:46:47 <lambdabot>  [11,21,31,41]
03:46:49 <Cale> or
03:47:01 <jle`> anyways, i probably have to head to bed
03:47:05 <bennofs> gn
03:47:12 <jle`> ty and thanks for the discussion.
03:47:15 <jle`> lmk if you find anything out further
03:47:18 <Cale> > map (\xs -> map (\x -> add 1 x) xs) [[10,20],[30,40]]
03:47:21 <lambdabot>  [[11,21],[31,41]]
03:47:28 <bennofs> has been really interesting, thanks
03:47:29 <Cale> and the notation starts to get a bit hard to follow
03:48:50 <Cale> Because everything is already "curried", it becomes trivial to specialise functions on their first argument.
03:48:52 <NateUni> Wait.. still confused.. split (x1 : x2 : xs)  = (x1:xs1, x2:xs2) where (xs1, xs2) = split xs 
03:49:01 <Cale> so...
03:49:06 <NateUni> I dont get what is happening here:  (x1:xs1, x2:xs2) where (xs1, xs2) = split xs
03:49:39 <NateUni> I get the matching: split (x1 : x2 : xs)  
03:49:46 <Cale> split (1:2:3:4:[]) = (1:xs1, 2:xs2) where (xs1, xs2) = split (3:4:[])
03:50:15 * bennofs has a dirty idea: time :: Behavior Time; time = Behavior $ \timeUsedRef -> ....; return (unsafePerformIO $ writeIORef timeUsed timeUsedRef >> return ...)
03:50:29 <Cale> split (3:4:[]) = (3:xs1, 4:xs2) where (xs1, xs2) = split []
03:50:47 <Cale> and then split [] = ([], [])
03:50:55 <Cale> So we can see that:
03:51:02 <Cale> split (3:4:[]) = (3:xs1, 4:xs2) where (xs1, xs2) = ([], [])
03:51:09 <Cale> and so we have:
03:51:13 <NateUni> ok that makes more sense..  I will jsut look over it again.. 
03:51:16 <Cale> split (3:4:[]) = (3:[], 4:[])
03:51:23 <Cale> and finally,
03:51:32 <Cale> split (1:2:3:4:[]) = (1:xs1, 2:xs2) where (xs1, xs2) = (3:[], 4:[])
03:51:38 <Cale> so that,
03:51:48 <Cale> split (1:2:3:4:[]) = (1:3:[], 2:4:[])
03:52:18 <Cale> I'm just doing the sort of highschool algebra thing of replacing equals with equals
03:53:07 <Cale> It's actually a very powerful technique for understanding the behaviour of Haskell programs :)
03:53:16 <NateUni>  I am going to go read more about the “where”
03:53:20 <NateUni> brb
03:54:21 <Cale> (I implicitly used the fact that if (x,y) = (z,w) then x = z, and y = w)
03:55:54 <NateUni> ok got it.. 
03:56:45 <lpaste> tdammers pasted “goooooooooal” at http://lpaste.net/130412
03:57:03 <tdammers> took me a while, but I got the MultiParamTypeclass approach working
03:57:05 <tdammers> also, ugh
03:57:19 <Cale> lol
03:58:22 <NateUni> Thanks guys!!
04:14:48 * hackagebot ideas 1.3 - Feedback services for intelligent tutoring systems  http://hackage.haskell.org/package/ideas-1.3 (BastiaanHeeren)
04:14:50 * hackagebot ideas-math 1.2 - Interactive domain reasoner for logic and mathematics  http://hackage.haskell.org/package/ideas-math-1.2 (BastiaanHeeren)
05:00:36 <Armel`> Hi!  What would be the best way to transform a 8 Char long list "aabbccdd" into this: "aa bb cc dd"?
05:00:58 <hellertime> is it possible to raise a signal from a handler setup with installHandler? 
05:01:28 <mniip> Armel`, concat . intersperse " " . group
05:03:41 <Armel`> mniip: My bad, in facts 'as' ("aa"), 'bs', 'cs' and, 'ds' could be any Char.
05:03:56 <KaneTW> what?
05:04:33 <Armel`> mniip: (I made them 'a', 'b', 'c' and 'd' for easier reading purpose.)
05:04:37 <KaneTW> >concat . intersperse " " $ group "aaaabcccddeeffghhhhhd"
05:04:41 <KaneTW> > concat . intersperse " " $ group "aaaabcccddeeffghhhhhd"
05:04:43 <lambdabot>  "aaaa b ccc dd ee ff g hhhhh d"
05:06:40 <pacak> > unfoldr (\x -> case x of { [] -> Nothing ; x -> Just (splitAt 2 x)} )  "AABBCCDDEE"
05:06:41 <lambdabot>  ["AA","BB","CC","DD","EE"]
05:07:00 <Armel`> Ok, I'll explain it better: I've a list of 8 Char (any char) and I want a list of this 8 Char with a withe space beetwin any 2 Char. Like "e65vaje4" gives "e6 5v aj e4".
05:07:02 <pacak> >  concat . intersperse " " . unfoldr (\x -> case x of { [] -> Nothing ; x -> Just (splitAt 2 x)} ) $  "AABBCCDDEE"
05:07:03 <lambdabot>  "AA BB CC DD EE"
05:07:27 <KaneTW> what pacak wrote then
05:07:31 <Armel`> Ok
05:07:43 <tsahyt> Is there a preferred syntax to state laws for some type or class in haddock (comments)?
05:11:57 <merijn> tsahyt: Not really
05:12:05 <merijn> tsahyt: Whatever is most human readable :p
05:15:42 <Armel`> I didn't knew about 'unfoldr'. So thank you pacak, thanks all. Bye.
05:16:49 <nuser> Old bookmarks to Haskell website aren't forwarded correctly. "https://www.haskell.org/haskellwiki/Fold" now "https://wiki.haskell.org//Fold" 
05:16:58 <nuser> to whom it may concern.
05:26:13 <mniip> hmm, the new instance source links in haddock look weird
05:26:18 <mniip> css-wise
05:32:19 <frerich> Armel`: The Data.List.Split function has a 'chunksOf' function (and instead of (concat . intersperse " ") you can use 'unwords'). So you could go for 'unwords . chunksOf 2'
05:32:27 <frerich> Oh, too late.
05:34:37 <merijn> @remember JohnCarmack If I had to write software that my life depended on, I would seriously consider using Haskell.
05:34:37 <lambdabot> Good to know.
05:43:35 <jacquerie> Hey everyone. Do you know any resources about competing in programming competitions using Haskell?
05:44:34 <jacquerie> Specifically, how to solve the mismatch between the imperative algorithms these competitions require and Haskell's way of doing things.
05:47:48 <kja> In my experience, few of the major competitions allow for much beyond C++/Java
05:48:57 <tzaeru> there are quite few occasional competitions that only really require you to supply a working executable.
05:49:01 <tzaeru> + the code, which can be anything
05:50:43 <jacquerie> I'm thinking of Google Code Jam, which requires the output + a copy of the source code (for anti-cheating purposes, I think)
05:52:52 <merijn> jacquerie: I don't know anything about competitions exactly, I do know a good reference on functional algorithm vs imperative mismatch
05:53:19 <merijn> jacquerie: The best material would be Okasaki, Bird's Pearls of Functional Algorithms and the Functional Pearl papers
05:56:12 <jacquerie> merijn, awesome. thanks!
05:58:15 <merijn> Okasaki (at least his thesis, which covers most of the same as the book based on it) should be available as a PDF in plenty of places
06:13:28 <Guest35441> I get a "Ressource busy error" when trying to open a file. Is there a way to check, whether a file is ready to be opened and get a Boolean? FilePath -> Bool ?
06:14:13 <c_wraith> Guest35441: well, it'd need to have a signature like FilePath -> IO Bool
06:14:34 <Guest35441> your right! is there something like that?
06:14:36 <c_wraith> Guest35441: But even then, it wouldn't be too useful.  The file could always become busy between when it runs and you open it
06:14:47 <Guest35441> mhm
06:14:49 <Guest35441> right
06:15:08 <c_wraith> Guest35441: the only reliable way to do that is to try to open the file and handle failure
06:22:22 <Franciman> Hello, I'm having problems installing annotated-wl-pprint-0.5.3
06:22:26 <Franciman> I have the latest GHC
06:22:41 <Franciman> and cabal 1.22.2.0
06:22:51 <Franciman> it gives a problem with ambiguous <$>
06:23:11 <KaneTW> please provide the complete error message in a pastebin (see topic)
06:23:29 <Franciman> ok
06:24:05 <crvs>  is there a way to directly read from a command into bytstring without using something like > readProcess (...) >>= return . pack ?
06:24:35 <crvs> I was searching through the bytestring libraries yesterday and for the life of me, I couldn't find it...
06:25:10 <Franciman> KaneTW, http://pastebin.com/d0Y1BDfA
06:26:01 <Gurkenglas> crvs, what's wrong with that line you gave?
06:28:04 <ph88> hey guys how do i tell cabal to look into a directory for some depedencies?  http://pastebin.com/KC1xNQFp
06:28:05 <crvs> just that readProcess reads the output into a string then I still have to pack it into a bytestring, and so I was wondering if there is a readProcess-like function in the bytstring library that interprets directly as a bytestring
06:29:08 <jacquerie> merijn, I'm lucky: my library has access to the Safari Online version of that book. Thanks again!
06:29:55 * hackagebot chalmers-lava2000 1.5 - Hardware description EDSL  http://hackage.haskell.org/package/chalmers-lava2000-1.5 (EmilAxelsson)
06:30:08 <Gurkenglas> crvs, so I went to the Data.ByteString page and Ctrl-F'd for "-> IO ByteString" and found "readFile :: FilePath -> IO ByteString" "Read an entire file strictly into a ByteString. This is far more efficient than reading the characters into a String and then using pack. It also may be more efficient than opening the file and reading it using hGet. Files are read using 'binary mode' on Windows, for 'text mode' use th
06:30:09 <Gurkenglas> e Char8 version of this function."
06:30:15 <crvs> like ByteStrig.Char8.hGetContents
06:30:34 <merijn> Char8 is bad and you should feel bad
06:31:10 <Gurkenglas> https://www.haskell.org/hoogle/?hoogle=FilePath+-%3E+IO+ByteString and here's some alternatives from different modules
06:31:19 <merijn> https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
06:31:25 <crvs> merijn: why?
06:31:27 <crvs> oh
06:32:29 <crvs> I'll read up on that
06:33:03 <meretrix> I want to serialize a list of a ~100 million ADTs sorted by a timestamp and then be able quickly lookup a few elements within a time range.
06:33:09 <meretrix> Any suggestions on how to do that?
06:33:12 <crvs> there's too many things to be aware of in the Haskell world
06:34:18 <ph88> how can i let cabal know about c libraries that need to be used?  i put in my cabal.config     install-dirs   Includes: $prefix\fftw-3.3.4-dll64\fftw3.h   extra-libraries: $prefix\fftw-3.3.4-dll64\libfftw3-3     but i get warning:   Unrecognized field extra-libraries
06:38:22 <KaneTW> Franciman: bug with that package, needs to import prelude hiding at least (<$>)
06:38:33 <KaneTW> or ideally rename it's operators
06:39:08 <c_wraith> ph88: extra-libraries is the correct field, but it needs to be inside a Library or Binary section
06:39:20 <Franciman> thanks KaneTW 
06:44:30 <meretrix> Looks like http://hackage.haskell.org/package/b-tree should work well for fast serialized lookups.
06:44:32 <idnar> is there an order-preserving Map somewhere?
06:44:39 <idnar> insertion order, that is
06:46:00 <ph88> c_wraith: how do i know if its better to put it in a Library or Binary section ?
06:47:13 <geekosaur> it's actually executable, not binary. if you don't know which one you need, you have bigger problems
06:47:23 <Gurkenglas> idnar, you mean M.Map (a, Int) b instead of M.Map a b?
06:47:57 <ph88> c_wraith: with Library i get:   Unrecognized stanza on line 1
06:48:47 <idnar> Gurkenglas: not quite, but yes
06:48:47 <merijn> idnar: Isn't that just a List of tuples? or a Map + list?
06:49:01 <merijn> :t lookup
06:49:02 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
06:49:17 <Gurkenglas> Wait. the int is obviously paired with the b. <.<
06:49:31 <idnar> Gurkenglas: ah, gotcha
06:50:11 <idnar> the problem with a list of tuples is that it doesn't preserve uniqueness of keys
06:50:30 <merijn> That can be easily solved with insertion sort
06:50:38 <idnar> it's also not convenient for modifications
06:51:02 <merijn> idnar: Preserving order of insertion for a Map isn't going to be convenient anyway
06:52:00 <KaneTW> Franciman: downgrading to a ghc that uses base-4.7.0.0 would be a temporary workaround
06:52:09 <KaneTW> if you can't fix the package
06:52:20 <Franciman> KaneTW, I've fixed downloading git version
06:52:35 <Gurkenglas> Well one can deal with the O(n) stuff at least. http://stackoverflow.com/questions/25336297/set-like-data-structure-that-maintains-insertion-order seems related.
06:52:51 <KaneTW> cool
06:53:00 <Franciman> thanks for you help
06:59:02 <geekosaur> ph88: randomply putting a library stanza before everything else in the cabal file won't work, which is what that sounds like. as I have no idea what you are doing, I have no suggestions except that you explain what you are trying to do
06:59:30 <geekosaur> and probably pastebin the cabal file
07:14:58 <merijn> argh
07:15:21 <merijn> GHC keeps warning me about unticked promoted constructors even when I use -fno-warn-unticked-promoted-constructors
07:18:43 <merijn> Hmm, actually it's just syntastic >.<
07:20:47 <HugoDaniel> has anyone used haskell on a raspberry pi ? how does it perform ?
07:20:58 <frerich> merijn: I guess you don't use hdevtools anymore, but in case you do: you can use something like 'let g:syntastic_haskell_hdevtools_args = '-g-Wall'' to pass specific flags.
07:21:14 <ph88> geekosaur: i'm trying to use fftw in my haskell program  http://pastebin.com/s3a3swyr
07:21:35 <ph88> HugoDaniel: if you have a script i can test it this evening =)
07:22:10 <geekosaur> that doesn't go in cabal.config
07:22:26 <ph88> geekosaur: what can i do to make it work ?
07:22:30 <geekosaur> it goes in a cabal package description for your project, foo.cabal for a package named foo
07:23:46 <merijn> frerich: I do use hdevtools and I added "-fno-warn-unticked-promoted-constructors" there, because that's where I have all flags, but syntastic is STILL reporting it
07:23:50 <merijn> Even after disabling it
07:23:52 <ph88> geekosaur: i renemed cabal.config to fuz.cabal  but ghc can still not find the fftw library
07:24:24 <frerich> merijn: You mean '-g-fno-warn-unticked-promoted-constructors', right?
07:25:40 <geekosaur> ph88, if you did not have a cabal config, how were you using ghc?
07:25:57 <geekosaur> if you just run it directly then it won't pay any attention to the sandbox at all.
07:26:05 <geekosaur> if you are using cabal exec then you have only limited functionality
07:26:15 <geekosaur> the expectation is that you are using cabal, not ghc directly
07:26:28 <merijn> frerich: Yes
07:26:44 <geekosaur> and this (external libraries and other dependencies) is exactly where truying to use ghc directly will cause problems
07:27:01 <ph88> geekosaur: cabal exec runhaskell fuz.hs
07:28:10 <ph88> geekosaur: is that limited functionality of cabal a problem for getting fftw to work ?
07:28:18 <geekosaur> ...
07:28:26 <geekosaur> you are not *using* cabal, is the problem
07:28:47 <geekosaur> cabal exec can set ghc package paths nbut not pass on random libraries
07:28:55 <geekosaur> because it does not know what you are running
07:29:03 <geekosaur> and therefore cannot know how to pass things on
07:29:19 <geekosaur> if you were using cabal instead of trying to do things directly, then cabal could work for you
07:29:31 <ph88> how do i use cabal instead ?
07:29:36 <geekosaur> (however I'm not sure how you runhaskell in a cabal sandbox)
07:30:26 <merijn> "cabal run runhaskell" :p
07:30:35 <ph88> ok
07:30:42 <merijn> That's just a guess, btw
07:30:48 <ph88> but actually i'm not running yet
07:30:50 <geekosaur> that'd be the cabal exec runhaskell
07:30:53 <ph88> i'm trying to install a new package
07:30:59 <ph88> i issue the command: cabal install fft
07:31:03 <geekosaur> but I am pretty sure it can't pass on the C library stuff to a random cabal exec
07:31:44 <geekosaur> because it would need to build a command line incljuding link information for the library, which means cabal exec has to know all about the commands you are running, which... no
07:31:52 <ph88> sorry for the confusion but you were talking about "run it directly" ... but i'm not at that stage yet ... first i would like to install the fft (fftw) package, and i try: cabal install fft
07:32:04 <geekosaur> and?
07:32:14 <ph88> and it can not find the package
07:32:16 <kuribas> Does there exist a comparison function for lists where you give the elementwise comparison function?
07:32:17 <geekosaur> it should not need to be told about C libraries
07:32:23 <kuribas> Like [a] -> [a] -> (a -> a -> Bool) -> Bool
07:32:40 <ph88> geekosaur: http://pastebin.com/0tHeLKzi
07:32:47 <ocramz`> kuribas: zipWith?
07:32:57 <geekosaur> pkg-config package
07:33:13 <kuribas> > all $ zipWith (==) [1, 2] [1, 2, 3]
07:33:15 <lambdabot>      Couldn't match expected type ‘a -> Bool’ with actual type ‘[Bool]’
07:33:15 <lambdabot>      Possible cause: ‘zipWith’ is applied to too many arguments
07:33:15 <lambdabot>      In the second argument of ‘($)’, namely
07:33:17 <geekosaur> you are missing the developer package for fftw on your platform
07:33:21 <geekosaur> native package manager
07:33:21 <ph88> geekosaur: that command doesnt return anything
07:33:33 <kuribas> > all id $ zipWith (==) [1, 2] [1, 2, 3]
07:33:33 <geekosaur> ok, let me say that more fully
07:33:34 <lambdabot>  True
07:33:45 <kuribas> ocramz`: doesn't work...
07:33:53 <ph88> geekosaur: windows does not have a package manager ... but i installed pkg-config anyway ... but this package is not available i think
07:33:59 <geekosaur> oh
07:34:00 <geekosaur> good luck
07:34:19 <geekosaur> I have no idea how you work with random libraries on window
07:34:20 <geekosaur> s
07:34:24 <ph88> but i have the header files and library files ...
07:34:41 <ph88> in GCC you can just use include dir and lib dir and it works
07:34:47 <geekosaur> pkg-config was supposed to solve these problems but nobody on windows uses it so it doesn't end up helping at all on the one platform where it's most needed
07:35:14 <ph88> pkg-config is just a helper to setting stuff like this ... i would like to set it manually
07:35:34 <geekosaur> you will probably need to "cabal get fft" and edit its cabal file to change the pkg-config reference to instead reference the paths directly
07:35:43 <ocramz`> kuribas: keep trying
07:35:49 <geekosaur> no you cannot do it in your sandbox because the fft package will still be looking to pkg-config instead
07:36:17 <geekosaur> cabal get fft; cabal sandbox add-source fft
07:36:19 <kuribas> ocramz`: of course I can _write_ such a function ...
07:36:38 <geekosaur> well, whatever directory "cabal get fft" leaves you with, which will probably have a version number
07:36:49 <ph88> Unpacking to fft-0.1.8\
07:37:15 <geekosaur> then edit the fft.cabal file in that directory to remove the pkg-config stuff and add the includes and extra-libraries stuff to its library section
07:38:47 <merijn> frerich: Actually...it seems to be ignoring ALL my configured warnings :\
07:39:28 <merijn> frerich: I'm guessing this new release of hdevtools is ignoring all my vim configured warning flags and ONLY using those in my cabal file, which is REALLY stupid
07:39:46 <niklasb> hey guys, we're seeing performance problems in our STM-based application. Transactions seem to be tried without any other transaction committing in the mean time, is there any situations in which this could happen?
07:39:52 <merijn> Actually, no, because it's ignoring some in my cabal file too
07:39:53 <niklasb> *be retried
07:40:01 <ph88> geekosaur: i edited the cabal file and issued the command   cabal sandbox add-source fft-0.1.8    is there any follow up step to this or can i just start using the library now?
07:40:54 <geekosaur> I think add-source should cause cabal exec to build that library automatically now
07:41:01 <frerich> merijn: I cannot imagine that. It would be Syntastic ignoring the warnings, I think. Does running hdevtools on the commandline work better (i.e. if you use '-g -fblahblahlblah')?
07:41:39 <merijn> frerich: No clue, I never ran hdevtools on the commandline
07:41:54 <merijn> And I dunno how to query which commandline args it gets
07:42:59 <chpatrick> @unmtl RWST c m s (Cont r)
07:42:59 <lambdabot> Plugin `unmtl' failed with: `RWST c m s (Cont r)' is not applied to enough arguments, giving `/\A. c -> s -> (Cont r) (A, s, m)'
07:43:10 <frerich> merijn: Running hdevtools is imply a matter of e.g. 'hdevtools check -g -isrc -g -Wall -g -hide-package -g transformers Foo.hs' (which invokes GHC with '-isrc -Wall -hide-package transformers')
07:43:21 <chpatrick> @unmtl RWST c m s (Cont r) a
07:43:21 <lambdabot> c -> s -> (Cont r) (a, s, m)
07:43:31 <fryguybob> niklasb: How are you coming to this conclusion?
07:43:56 <frerich> merijn: I.e. you could try something like 'hdevtools check -g -fno-warn-unticked-promoted-constructors InfamousDutchmen.hs' and see what happens.
07:44:01 <merijn> frerich: hmm, it doesn't seem to be getting any arguments when it gets run
07:44:13 <chpatrick> @unmtl ContT r (RWS c m s) a
07:44:13 <lambdabot> (a -> (RWS c m s) r) -> (RWS c m s) r
07:44:16 <merijn> frerich: When I specify arguments it works right, but syntastic runs it without arguments
07:44:29 <fryguybob> niklasb: And what do you mean by "retried".  Do you mean a blocked transaction (one that executed 'retry' successfully) attempts to run again before any other transaction has committed?
07:45:06 <frerich> merijn: Sounds like it. When you do ':SyntasticInfo' it does show that you're using the hdevtools checker though, right?
07:45:25 <merijn> yeah
07:45:41 <frerich> Hmmm.
07:46:27 <niklasb> fryguybob: we are using a wrapper around atomically that logs when a transaction is initiated and when it commits, as well as when it is restarted (using unsafeIOToSTM)
07:47:42 <fryguybob> niklasb: Ah, well, I think I would have to see those details to know what is going on.
07:48:39 <KorriX> I have problem with parsing multiple lines using attoparsec. many (lineParser <* word8 _lf) allways returns empty list
07:48:54 <niklasb> fryguybob: do you have any suggestions on how to debug these kinds of situations? we are already using a mechanism to trace tvar reads and writes, but we're seeing aborts of a transaction even without any other transaction having comitted since its start
07:49:05 <merijn> frerich: ugh, looks like syntastic isn't reading the option variable it used to
07:49:20 <niklasb> STM tracing isn't really useful to us unfortunately, since we can't associate tvar addresses to the haskell equivalents
07:49:28 <merijn> frerich: It's just "g:syntastic_haskell_hdevtools_args" no?
07:49:44 <frerich> merijn: That's what https://github.com/scrooloose/syntastic/blob/master/syntax_checkers/haskell/hdevtools.vim uses AFAICS.
07:50:02 <fryguybob> niklasb: It is posible for two committing transactions to abort eachother, but the window for that is pretty narrow.
07:50:14 <KorriX> What can cause such a behavior?
07:50:38 <frerich> merijn: ...and I have exactly 'let g:syntastic_haskell_hdevtools_args = '-g-Wall'' in my own .vimrc
07:50:59 * frerich squints to see whether you have a typo there.... nope. :-)
07:51:18 <merijn> frerich: It's worked for like a year, so unlikely >.>
07:51:30 <Yuu-chan> KorriX: if it can't parse a single line, the result will be empty
07:51:42 <niklasb> fryguybob: can using unsafeIOToSTM interfer with the STM subsystem if you i.e. use atomicModifyIORef inside transactions? And also, can evaluating Haskell values inside transaction lead to conflicts?
07:51:45 <fryguybob> niklasb: Is there any use of  orElse  or  retry?
07:52:11 <merijn> frerich: If I remove that line I get a "hdevtools_options is deprecated for g:syntastic_haskell_hdevtools_args" warning, but THEN it works
07:52:41 <fryguybob> niklasb: Evaluating Haskell values is not a problem unless there is unsafePerformIO $ atomically hiddent behind it (that is something that will never work)
07:53:22 <fryguybob> niklasb: Using unsafeIOToSTM can lead to deadlocks if you are using information from that in a choice to retry.
07:53:29 <KorriX> Yuu-chan: But i tested my lineParser on single lines (map PARSE $ B.split _lf imput) and it works for every line
07:53:45 <niklasb> fryguybob: ok that's obvious, we don't do that.
07:53:46 <Cale> niklasb: I would do everything I possibly could to avoid using unsafeIOToSTM
07:53:56 <niklasb> Cale: it's a big program, we use that e.g. for logging
07:54:06 <niklasb> kinda hard to avoid
07:54:13 <merijn> frerich: Oh well, at least it works now :)
07:54:21 <Yuu-chan> KorriX: by the way, use sepBy
07:54:36 <fryguybob> niklasb: It isn't clear that logging implemented with unsafeIOToSTM will be reliable
07:54:38 <KorriX> Yuu-chan: Same result. Empty list
07:54:49 <niklasb> can you guys shed some light on when a transaction gets retried at all? can it happen when two transactions read the same var or only if one of them is writng it?
07:54:51 <frerich> merijn: Still a bit fishy...
07:54:54 <merijn> frerich: And with 7.10 I can finally silence typed holes warnings :D
07:54:55 <Cale> You must be aware that the actions you perform in unsafeIOToSTM may happen repeatedly as transactions get aborted, and their effects obviously can't be rolled back.
07:54:56 <ph88> geekosaur: maybe it did build ... but no messages show up in the console
07:55:25 <KorriX> Yuu-chan: What is funny when I'm using sepBy in other place and other separator it is giving nonempty lists
07:55:26 <merijn> niklasb: If any of the TVars have changed since the start of a transaction, it aborts
07:55:27 <fryguybob> niklasb: Haskell's STM is lazy (in the STM sense) and doesn't check if there is something wrong until commit time genrally.  But it will also check that in some cases at GC
07:55:47 <niklasb> fryguybob: that's interesting, because we're definitely seeing aborts in the middle of a transaction
07:56:03 <merijn> niklasb: Isn't that just useage of orElse?
07:56:05 <Yuu-chan> KorriX: hmm. Could you paste a compilable code snippet into ideone or something?
07:56:06 <Cale> niklasb: If, when a transaction finishes, it ended up having read from some TVar whose value is now different, it retries.
07:56:10 <fryguybob> niklasb: This lazyness makes things unreasonable in the presense of side effects.
07:56:11 <geekosaur> ph788: it should have shown. I am beyond my depth, sorry
07:56:12 <niklasb> merijn: no
07:56:22 <geekosaur> ph88: it should have shown. I am beyond my depth, sorry
07:56:30 <KorriX> Yuu-chan: I'll try
07:56:38 <ph88> geekosaur: i think it didn't work because i put in my code:    import Math.FFT      and i get: Could not find module `Math.FFT'
07:56:41 <niklasb> any special cases for long-running transactions?
07:56:46 <ph88> geekosaur: ok thank you very much for trying to help !
07:57:04 <fryguybob> niklasb: If you do read inconsitent data and act on it leading to unsafeIOToSTM you can see strange output.
07:57:07 <Cale> niklasb: Also, it may explicitly execute the retry action in order to wait for more suitable conditions, after having tested some condition on the values of TVars it read.
07:57:27 <niklasb> ok but then it will not retry unless some other transaction commits correct?
07:57:47 <Cale> niklasb: Not necessarily. It might do something which retries explicitly.
07:58:06 <fryguybob> *sigh* retry is too overloaded a word
07:58:15 <niklasb> I agree
07:58:27 <Cale> Is it?
07:58:37 <Cale> It means something very specific in this context.
07:58:37 <fryguybob> Executing  retry  means blocking the transaction.
07:58:41 <niklasb> Cale: we're not using conditional retries in the transaction in question
07:58:47 <fryguybob> retrying can me aborting durring commit.
07:58:52 <niklasb> like, explicitly using the `retry' function
07:58:54 <fryguybob> At least that is the way the word is used.
07:59:03 <Cale> fryguybob: Those two things have the same effect.
07:59:08 <fryguybob> No
07:59:12 <Cale> hm?
07:59:27 <niklasb> in the `retry' function case, something needs to change before you will schedule the transaction again
07:59:31 <niklasb> I think
07:59:31 <fryguybob> At one semantic level, yes
07:59:40 <fryguybob> But as to what you can see with unsafeIOToSTM, no
07:59:46 <Cale> Oh, yeah, okay.
07:59:52 <mokasin> hi. i'm battleing with cabalt, trying to install "yi" in a sandbox. i copyied the stackage config into the dir. a cabal install --only-dependencies leads to: trying: transformers-compat-0.4.0.3 (dependency of exceptions-0.8.0.2)  Dependency tree exhaustively searched.
08:00:02 <fryguybob> niklasb: Correct.
08:00:04 <mokasin> running out of ideas. somebody a hint?
08:00:35 <fryguybob> niklasb: But that thing that changed could change back before it actually runs.
08:01:16 <merijn> ugh
08:01:34 <merijn> There's no way to hide a constraint within a type alias, is there?
08:01:46 <niklasb> so our transaction has the form  a >> unsafeIOToSTM a' >> b >> unsafeIOToSTM b' >> c. The effects of a' are visible, those of b' are not. b is only reading vars, not writing them
08:02:09 <niklasb> no retry or orElse involved
08:02:38 <niklasb> do you think alwaysSucceeds will help debug us what the conflicting vars or transactions are?
08:02:59 <fryguybob> niklasb: Well there is the possible issue that there isn't enough synchronization in a' and b' know the ordering.
08:03:25 <fryguybob> niklasb: alwaysSucceeds unfortunately fairly drastically changes the performance of STM.
08:03:25 <niklasb> fryguybob: it's atomicModifyIORef on a list of log messages
08:03:32 <fryguybob> niklasb: Ok
08:03:51 <fryguybob> niklasb: And has bugs in the face of  orElse
08:03:56 <niklasb> fryguybob: that's not much of a problem, our priority is finguring out the problem in our code so we can fix it
08:04:10 <niklasb> like where we have contention
08:04:15 <niklasb> or long/short transactions fighting
08:04:57 <fryguybob> niklasb: So in your case while running b you could GC and abort due to a conflict seen in a
08:04:57 <niklasb> we know the long-running transaction that doesn't finish, but we don't know what is causing the aborts
08:05:03 <gwm_> http://lpaste.net/130430 - Can anyone tell me why when I input 'election ballots' it outputs " instead of "Green"
08:05:14 <niklasb> fryguybob: ok so GC validates the transactions?
08:05:40 <fryguybob> niklasb: Yes, it has to catch transactions in an infinite loop due to inconsistent reads.
08:06:06 <niklasb> it doesn't seem like a regular occurence, almost no time passes between a' and the log message that informs us of the fact that the transaction restarts
08:07:25 <fryguybob> niklasb: How is that log message triggered?
08:07:39 <niklasb> by adding to the list in the ioref
08:08:00 <indiagreen> gwm_: can you also paste the definition of “results”?
08:08:20 <fryguybob> niklasb: I mean where is that called to be added.
08:08:25 <gwm_> @indiagreen yes sorry - http://lpaste.net/130431
08:08:25 <lambdabot> Unknown command, try @list
08:08:31 <niklasb> fryguybob: after the atomcially
08:09:26 <gwm_> it keeps calling the election function over and over it should stop at the last colour
08:09:38 <gwm_> i think it's going through every character not every word
08:10:43 <fryguybob> niklasb: So  unsafeIOToSTM (log "starting") >> a ...
08:11:04 <fryguybob> niklasb: And you see "starting", a', "starting"
08:11:24 <niklasb> fryguybob: well it's more like (log "starting") >> atomically (a >> unsafeIOToSTM (log "a") >> b >> unsafeIOToSTM ("log b")) >> (log "ending")
08:11:33 <indiagreen> gwm_: your mistake is in “remove”
08:11:52 <niklasb> and we see "starting", "a", "starting", "a", ...
08:11:54 <fryguybob> niklasb: When a transaction aborts and starts again, it doesn't start outside the atomically
08:12:01 <niklasb> sry
08:12:02 <indiagreen> gwm_: it doesn't remove the party you give, but removes all other parties
08:12:25 <niklasb> there's also a "retrying" message at the beginning of the transaction, using unsafeIOToSTM
08:12:38 <niklasb> and we see "retrying", "a", "retrying", ...
08:12:47 <niklasb> without any "ending" in between
08:12:56 <niklasb> and almost no time between "a" and "retrying"
08:13:19 <niklasb> b ist an expensive computation
08:13:33 <gwm_> indiagreen: oh...how comes when I type in ghci 'remove "Red" ballots' it does what I thought?
08:14:08 <indiagreen> ouch
08:14:16 <indiagreen> no, wait, remove is correct
08:14:48 <KorriX> Yuu-chan: I found bug. Is caused by using Control.Applicative.optional
08:15:01 * hackagebot annotated-wl-pprint 0.6.0 - The Wadler/Leijen Pretty Printer, with annotation support  http://hackage.haskell.org/package/annotated-wl-pprint-0.6.0 (dchristiansen)
08:15:12 <KorriX> Yuu-chan: Last column of my data is optional
08:15:47 <fryguybob> niklasb: I'm poking around in the source to see if there isn't anything that I haven't thought of.
08:16:53 <bitonic> is there a way to disable GC using some RTS options?
08:17:26 <fryguybob> bitonic: And just crash when you need a GC?
08:17:30 <gwm_> indiagreen: could it have something to do with it never reaching the [p] -> p part in election function
08:17:56 <bitonic> fryguybob: well... when do you *need* a GC?  I'd want the program to just run out of memory
08:17:59 <indiagreen> gwm_: second guess: did you mean “xs” instead of “ballots” in rank?
08:18:17 <fryguybob> bitonic: Run out of memory and ... crash?
08:18:25 <bitonic> fryguybob: yeah
08:18:30 <bitonic> if the OOM killer gets it
08:18:34 <gwm_> indiagreen: ahhh that's it
08:18:37 <gwm_> indiagreen: thanks :)
08:18:42 <bitonic> maybe something else will crash
08:18:43 <bitonic> who knows
08:20:02 * hackagebot breve 0.0.2.0 - a url shortener  http://hackage.haskell.org/package/breve-0.0.2.0 (rnhmjoj)
08:20:36 <fryguybob> niklasb: An asynchronous exception might cause a validation.
08:21:04 <niklasb> fryguybob: any async exception, or only one in that thread?
08:21:17 <niklasb> I don't think we would miss an exception tbh
08:21:17 <fryguybob> niklasb: One thrown to that thread
08:21:42 <niklasb> ok well thanks a lot for your time fryguybob, I guess we're missing something important
08:22:54 <geekosaur> ph88: I think the secret sauce is: cabal install --only-dependencies
08:23:04 <fryguybob> niklasb: If you are open to hacking GHC a bit you can add some logging that you could be confident about and have access to better information about what is going on in the transaction.
08:23:16 * geekosaur is experimenting, as he's realized this is related to a little problem of his own which probably qualifies as cabal abuse
08:23:37 <fryguybob> niklasb: But short of that, I'm not sure of a good way to get a better handle on what is going on.
08:24:49 <niklasb> fryguybob: it's kind of hard to represent the haskell semantics (i.e. logic transactions in our code) to the GHC level though
08:25:05 <fryguybob> niklasb: Also note that there is no guarentee about future semantics of unsafeSTMToIO.  For instance, I have a branch of GHC that will exhibit the behavior you are seeing due to just memory operations not going your way.
08:26:14 <niklasb> interesting fryguybob, that makes sense
08:26:15 <phaazon> hey
08:26:22 <phaazon> is there a way to pattern match on a specific record field?
08:26:23 <niklasb> does this have to do with hardware acceleration?
08:26:24 <phaazon> like hm
08:26:34 <phaazon> data Foo = Foo { foo :: Int, bar :: String }
08:26:50 <phaazon> stuff foo{ bar -> [] } = "empty string"
08:27:01 <geekosaur> mumble Foo { bar = bar } = ...
08:27:11 <fryguybob> niklasb: I understand.  I was only able to track down what transaction was doing something in my code by finding the the TVar was pointing to something of a type (by looking at the info table in the binary) that was different from the ones in my application
08:27:16 <phaazon> geekosaur: thanks
08:27:18 <fryguybob> niklasb: It was an internal RTS use of STM.
08:27:44 <geekosaur> and bar is bound within (the second occurrence is the local name, so mumble Foo {bar = x} = ... locally binds the bar field to x
08:28:04 <phaazon> ok
08:28:04 <phaazon> thanks
08:28:11 <geekosaur> if you also want the whole record, use an as-pattern: mumble foo@(Foo {bar = x}) = ...
08:28:29 <niklasb> fryguybob: again, thanks a ton for your valuable information :)
08:28:29 <phaazon> right
08:28:32 <phaazon> thank you very much
08:29:51 <fryguybob> niklasb: Anytime!
08:35:02 * hackagebot breve 0.0.2.1 - a url shortener  http://hackage.haskell.org/package/breve-0.0.2.1 (rnhmjoj)
08:45:03 * hackagebot diversity 0.4.0.2 - Return the diversity at each position for all sequences in a fasta file  http://hackage.haskell.org/package/diversity-0.4.0.2 (GregorySchwartz)
08:48:18 <Franciman> Hey can you explain me, why this is an error?
08:48:19 <Franciman> http://pastebin.com/DWNdG6ta
08:48:33 <Franciman> I've read on ghc's page that if I have two instances with one more specific, they can overlap
08:50:08 <KaneTW> Franciman: you have a general polymorphic instance and a monomorphic instance
08:50:16 <KaneTW> ghc can't decide which of these to take by default
08:50:24 <Franciman> how can I fix that?
08:50:34 <Cale> Franciman: Don't use type classes.
08:50:42 <Franciman> uhm?
08:50:55 <Franciman> (sorry I don't know much about haskell, I just need to fix it to make idris work)
08:51:02 <Franciman> Cale, why shouldn't i?
08:51:20 <KaneTW> you already have a generic show implementation
08:51:22 <Cale> Type classes are inappropriate for any case that you'd want more than one instance at any given type
08:51:31 <KaneTW> ^
08:51:47 <Franciman> oh ok
08:51:50 <Cale> You should just explicitly pass (records of) function implementations if that's the sort of situation you're in
08:52:06 <Cale> Or, there are usually many other options.
08:52:07 <S11001001> Franciman: where is the code you are compiling coming from?
08:52:16 <Franciman> idris' git repo
08:52:24 <Cale> If you're just trying to build Idris, I don't know why you'd be running into that problem.
08:52:31 <Franciman> me too
08:52:47 <S11001001> Franciman: can you check out the latest tag and try to build that?
08:52:57 <Franciman> S11001001, how to do that?
08:56:40 <s3vv4> hi, anybody have experience getting pandoc to run on arch linux?
08:58:43 <narendraj9> s3vv4: What is the issue? I think installing/using pandoc should not be any different on any distro that has cabal-install.
08:59:35 <s3vv4> narendraj9: I get a lot of errors when trying to install it
08:59:43 <s3vv4> even over cabal-install
08:59:59 <s3vv4> it can't resolve the dpendencies
09:00:05 <geekosaur> pandoc wants stackage these days
09:00:54 <indiagreen> hm, interesting, it had no troubles resolving dependencies for me in a fresh sandbox
09:01:11 <geekosaur> I think you create a sandbox, drop http://www.stackage.org/lts/cabal.config into it, and then you should be able to install pandoc in the sandbox
09:01:43 <s3vv4> geekosaur: will try
09:01:46 <s3vv4> thanks
09:03:06 <arboris> has anyone else here experienced problems with loading symbols for haskell-mode in emacs
09:03:35 <arboris> currently it reproducibly hangs when trying to load the symbols of Graphics.GL
09:03:41 <sternenseemann> s3vv4: if you want to do a lot of hecking around, you could install the nix package manager
09:03:57 <sternenseemann> s3vv4: it works fine along with pacman and stays in you $HOME
09:04:11 <sternenseemann> s3vv4: it has entire hackage packaged I think
09:04:20 <arboris> i guess there are a lot of them, but 
09:04:29 <sternenseemann> s3vv4: and I had no problems installing anything yet
09:04:35 <sternenseemann> even ghcjs is no problem :D
09:04:41 <arboris> i feel like it shouldn't take that long and freeze up the editor
09:05:00 <s3vv4> sternenseemann: I'll see what works, thanks for the suggestion!
09:05:15 <hexagoxel> can anyone confirm if pandoc works with ghc-7.10?
09:05:37 <sternenseemann> s3vv4: the easiest solution ist to use ArchHaskell https://wiki.archlinux.org/index.php/ArchHaskell
09:05:47 <sternenseemann> s3vv4: it's an additional repo for pacman
09:06:08 <Cale> arboris: http://hackage.haskell.org/package/gl-0.7.4/docs/doc-index-G.html -- this page takes Chrome a good few seconds to load as well :)
09:06:18 <sternenseemann> s3vv4: but watch out, it was down for some time recently and I had lots of package managing trouble
09:06:32 <sternenseemann> (it's not an official repo)
09:06:36 <s3vv4> sternenseemann: I tried that already tbh
09:06:45 <arboris> Cale: Chrome loads that near instant for me, I have a fairly fast machine
09:06:58 <sternenseemann> s3vv4: really? back then installing pandoc worked fine
09:07:04 <arboris> Cale: emacs sits at 100% for several minutes now
09:07:14 <s3vv4> sternenseemann: it doesn't contain any pandoc package
09:07:35 <sternenseemann> s3vv4: it's haskell-pandoc there…
09:08:21 <s3vv4> sternenseemann: haskell-core has no such package
09:08:39 <sternenseemann> s3vv4: ah, I see, I don't know why it has gone
09:09:02 <sternenseemann> s3vv4: then try the cabal sandbox thingy, or if you plan installing more haskell packages or using nix-shell
09:09:04 <sternenseemann> nix
09:09:28 <sternenseemann> https://ocharles.org.uk/blog/posts/2014-02-04-how-i-develop-with-nixos.html
09:09:34 <sternenseemann> s3vv4: like this ^
09:10:04 * hackagebot yesod-angular-ui 0.1.0.0 - Angular Helpers  http://hackage.haskell.org/package/yesod-angular-ui-0.1.0.0 (tolysz)
09:10:22 <Cale> arboris: Oh, several *minutes*, then I have no idea what it's doing :P
09:15:04 * hackagebot yet-another-logger 0.2 - Yet Another Logger  http://hackage.haskell.org/package/yet-another-logger-0.2 (larsk)
09:20:18 <ane> would parsing IRC logs be considerably faster with attoparsec instead of regular expressions?
09:20:56 <johnw> ane: regular expressions are in a way another way of encoding what attoparsec does, so your question is at two different levels
09:21:11 <johnw> attoparsec could be used as an implementation of regular expressions, for example
09:22:55 <johnw> arboris: I've found symbol loading to be incredibly slow
09:23:40 <johnw> arboris: are you using ghc-mod?
09:24:27 <ane> johnw: huh.. uh.. ok
09:26:13 <johnw> ane: for example, foo*bar? is: string "foo" *> many anyChar *> string "ba" *> optional (char 'r')
09:26:26 <ane> ah, right, so implementing regexps using attoparsec
09:26:50 <johnw> and conversely, the attoparsec "interface" could be used to build regexps, which is what regexp-applicative does
09:27:29 <johnw> but although every regexp could be written as an attoparsec parser, not every attoparsec parser could be rendered as a regular expression
09:34:38 <ane> regexp-applicative looks like a good option
09:50:06 * hackagebot socket-io 1.3.1 -   http://hackage.haskell.org/package/socket-io-1.3.1 (OliverCharles)
09:50:08 * hackagebot engine-io-yesod 1.0.2 -   http://hackage.haskell.org/package/engine-io-yesod-1.0.2 (OliverCharles)
09:50:10 * hackagebot engine-io-snap 1.0.3 -   http://hackage.haskell.org/package/engine-io-snap-1.0.3 (OliverCharles)
09:55:06 * hackagebot engine-io 1.2.5 - A Haskell implementation of Engine.IO  http://hackage.haskell.org/package/engine-io-1.2.5 (OliverCharles)
10:05:06 * hackagebot exhaustive 1.1.1 - Compile time checks that a computation considers producing data through all possible constructors  http://hackage.haskell.org/package/exhaustive-1.1.1 (OliverCharles)
10:12:55 <rohan_> Hi.  I just tried to do the exercise of proving the equivalence of Peirce's law and the law of the excluded middle in Haskell.  I am getting an error that I do not understand:
10:13:03 <rohan_> http://lpaste.net/2982157550671101952
10:13:41 <johnw> what is the error?
10:14:02 <sellers> Any suggestions for vim packages for haskell syntax highlighting?  I just want something simple, and all the packages I'm finding have other things bundled in I don't want
10:14:32 <rohan_> johnw: peirce_eq_lem does not typecheck, the exact error is a bit too long to paste in IRC.
10:15:25 <kadoban> sellers: Doesn't it come with syntax highlighting, you just have to make sure syntax On and filetype On or whatever is in you config or something? I don't think I ever installed anything specifically for syntax highlighting.
10:15:41 <mauke> rohan_: how about using a paste site?
10:15:46 <mauke> such as lpaste!
10:16:07 <rohan_> But GHC basically seems to remove the universal quantification from LEM and Peirce at the end of the arrows.
10:16:10 <rohan_> mauke: I did.
10:16:19 <mauke> are you being a dick on purpose?
10:16:22 <rohan_> Maybe my post got lost? Here it is again: http://lpaste.net/2982157550671101952
10:16:26 <rohan_> Huh?
10:16:37 <glguy> sellers: You can rip out the highlighter I use in my IRC client, it's pretty isolated with minimal deps: https://github.com/glguy/irc-core/blob/master/driver/HaskellHighlighter.hs
10:16:38 <johnw> rohan_: without teh error, I cannot help
10:16:45 <mauke> "I'm getting an error: <link to stuff that is not an error"
10:16:51 <sellers> kadoban: it does, but I find it underwhelming
10:16:51 <glguy> sellers: Just change the definition of the colors to whatever it is you're doing
10:16:51 <johnw> annotate your lpaste with the error
10:16:58 <mauke> what is the error? "well, it's too long to paste"
10:17:07 <kadoban> sellers: Oh okay. That's possible, it's not that impressive.
10:17:40 <rohan_> done
10:17:51 <sellers> glguy: looks interesting, I'll check it out thanks!
10:18:32 <rohan_> mauke: no need to be so aggressive.  I did not think it would be such a hassle for people interested in the question to compile the example themselves.
10:19:10 <mauke> that would require me to download your code
10:19:15 <mauke> and then download and install ghc
10:19:15 <johnw> mauke: calling some by a derogatory term is not acceptable
10:19:19 <johnw> someone*
10:22:17 <mauke> rohan_: that limits the set of people you might get answers from
10:22:59 <rohan_> mauke: I already annotated the post following the earlier and civilised suggestion of johnw.
10:23:10 <johnw> rohan_: sorry, I don't know the answer offhand
10:23:54 <mauke> rohan_: ok, my bad then
10:24:07 <mauke> I reopened the link but didn't see your annotation. browser caching issue?
10:24:21 <johnw> yeah, could be
10:24:25 <rohan_> mauke: not sure. When I click my original link I see the annotation.
10:24:34 <mauke> I do now after reloading
10:25:07 * hackagebot exact-pi 0.1.0.0 - Exact rational multiples of pi (and integer powers of pi)  http://hackage.haskell.org/package/exact-pi-0.1.0.0 (dmcclean)
10:28:29 <benzrf> hey
10:28:39 <johnw> hey back
10:29:06 <johnw> benzrf: remember that FreeT version of pipes I showed you?
10:29:22 <benzrf> is there a haskell library for algebraic manipulation of expression trees, preferably allowing universally quantified equalities
10:29:25 <benzrf> johnw: yeah
10:29:43 <johnw> http://hackage.haskell.org/package/pipes-2.4.0/docs/Control-Proxy-Core.html :)
10:29:55 <johnw> those who do not know history are doomed to repeat it
10:33:58 <s3vv4> sternenseemann: in the end I built haskell from source and then cabal had no issues installing pandoc, seemed easier than nixos, atleast for my limited use
10:34:37 <sternenseemann> s3vv4: okay, then everything is fine I guess? :)
10:36:13 <ion> Law of Excluded Middle in Cont https://gist.github.com/ion1/9803dbd77cf88147bde7
10:37:19 <EntropicMind> Greetings, all.
10:38:39 <rom1504> mauke: I can see errors on the bottom of http://lpaste.net/2982157550671101952
10:39:13 <johnw> ion: that shouldn't be Either' (f a) (Not f a) a ?
10:39:34 <benzrf> johnw: bwahaha
10:39:34 <Lezkus> Hi everyone
10:39:41 <benzrf> johnw: niiiiiiiiiiiiiiiiice
10:39:54 <Lezkus> I'm new to haskell and I'm having some trouble getting haskell to run in arch
10:40:01 <benzrf> Lezkus: how are you installing
10:40:30 <ion> johnw: The caller is free to dictate the “r”.
10:40:41 <Lezkus> benzrf: I did sudo pacman -S ghc cabal-install happy alex haddock, as stated on the arch wiki
10:41:00 <benzrf> Lezkus: and what problems are you experiencing?
10:41:20 <johnw> ion: just makes it harder to see that you're expressing a ∨ ¬ a
10:41:20 <Lezkus> benzrf: Here is the thread I opened explaining everything: https://bbs.archlinux.org/viewtopic.php?pid=1518017#p1518017
10:41:35 <ion> lezkus: This may or may not be helpful, but i always install them in my home directory as follows: https://gist.github.com/ion1/2815423
10:42:27 <mauke> Lezkus: why do you have files in /usr/local?
10:42:38 <Lezkus> mauke: I have no idea
10:44:55 <barrucadu> Lezkus: Did you do `sudo cabal install ...` at all?
10:45:04 <hexagoxel> Lezkus: ghc-7.8.3? that looks suspicious; official arch repo is at ghc-7.10.1. when did you last `pacman -Syu` ?
10:45:52 <Lezkus> hexagoxel: I did it like... 2 days before installing haskell... but that's true...
10:46:15 <ion> johnw: That’s encoded as the “a” and the “b” parameters, the Church-style Either can return anything your case functions choose to return.
10:46:28 <hexagoxel> but that is the wrong question probably; it would not put in /usr/local anyway
10:46:31 <Lezkus> hexagoxel: uhmmm shoudl I just remove all the haskell packages with pacman, and then remove that file
10:46:42 <Lezkus> ohhhhh
10:47:20 <Lezkus> now that you said so, I also tried installing it following this tutorial: http://yannesposito.com/Scratch/en/blog/Safer-Haskell-Install/
10:47:37 <Lezkus> i.e. executing this script: https://raw.githubusercontent.com/yogsototh/install-haskell/master/install-haskell.sh
10:48:00 <Lezkus> but then  realized that that script didn't apply to arch... 
10:48:45 <hexagoxel> Lezkus: what is the output of `/usr/bin/ghc --version`
10:49:13 <Lezkus> hexagoxel: The Glorious Glasgow Haskell Compilation System, version 7.10.1
10:50:09 * hackagebot haste-perch 0.1.0.9 - Create, navigate and modify the DOM tree with composable syntax, with the haste compiler  http://hackage.haskell.org/package/haste-perch-0.1.0.9 (AlbertoCorona)
10:51:46 <hexagoxel> Lezkus: so remove the /usr/local stuff and update (clean up) your PATH
10:52:21 <Lezkus> ok
10:52:53 <Lezkus> I'm going to uninstall first ghc, cabal, etc via pacman so I don't touch anything I'm not supposed to 
10:55:09 * hackagebot hplayground 0.1.3 - monadic, reactive Formlets running in the Web browser  http://hackage.haskell.org/package/hplayground-0.1.3 (AlbertoCorona)
10:56:24 <murz> What's the best way to install an old version of the Haskell Platform on mac? I'm following a haskell web development tutorial that's from 2014, and I'm unable to run the examples I think because my version of Haskell is too new: "rejecting: todo-0.0.1 (conflict: ansi-terminal => base==4.7.0.1/installed-df2..., todo => base==4.6.*)"
10:56:47 <murz> My current version was just installedb y downloading the "Haskell Platform 2014" osx installer from https://www.haskell.org/platform/mac.html
10:58:00 <ryantrinkle> bennofs: thanks for the PR :) looking over it now
10:58:27 <kadoban> murz: I'd just try to minorly modify the thing you're trying to run, instead of trying to install an ancient version of haskell. If it can't be done, then maybe it's time to find a different tutorial :-/
10:58:34 <rohan_> ion: have you seen my problem? http://lpaste.net/2982157550671101952 ;  I encountered it while trying to solve the exercise that I think you gave.
10:59:02 <murz> kadoban: I came here with the various dependency problems I was having yesterday trying to do just that -- and was given the exact opposite recommendation: to just use an older version of the platform
10:59:35 <Lezkus> hexagoxel: after removing all those files and installing a fresh ghc, I still got this message /usr/local/bin/ghc: line 9: /usr/local/lib/ghc-7.8.3/bin/ghc: No such file or directory
10:59:50 <kadoban> Haha. Well, maybe whoever recommended that was smarter than I am. I'm not sure. It's not what I'd do though, I'd hate trying to install old haskell just for that.
10:59:51 <Lezkus> hexagoxel: it still refers to the older version 
11:00:11 <hexagoxel> Lezkus: hash -r
11:00:48 <mauke> rm /usr/local/bin/ghc
11:01:49 <hexagoxel> hmm i thought Lezkus had already done that. does the error suggestion otherwise?
11:01:55 <hexagoxel> *suggest
11:02:15 <Lezkus> no, no, no, I forgot to remove those files
11:02:37 <Lezkus> thanks for pointing that out
11:03:04 <murz> I'm trying to follow this tutorial: http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html   But when I run cabal install with the provided cabal file I get hit with this error: http://lpaste.net/130391  ... so I tried just bumping base==4.6.* to base==4.7.* which seems to help but then I get hit with: http://lpaste.net/130392 and I'm at a bit of a loss
11:03:21 <ion> rohan: I’d need to study it to potentially see what’s going on. I’m not feeling too great at the moment, perhaps someone in the reddit thread can figure it out.
11:03:28 <murz> If anyone has any more up to date tutorial recommendations that'd be awesome. or any tips for how to get that one building
11:04:46 <suppi> murz, are you building with cabal sandboxes?
11:04:57 <murz> yes. I did as the tutorial recommended
11:04:59 <murz> cabal sandbox init
11:05:24 <rohan_> ion: alright.  The problem must lie somewhere in the definition of ⨿, ×, `and`, and peirce_eq_lem though, so there should not be anything tricky about it.
11:05:28 <kadoban> murz: What if you just remove all of the dependency constraints? Probably won't work, but maybe worth a shot
11:05:30 <Lezkus> at last!!
11:05:51 <Lezkus> thank you so much hexagoxel, mauke and all of you that helped me!!
11:05:55 <rohan_> ion: I just thought that since you did not use an equivalence type when posing the question you might know what goes wrong.
11:06:11 <kadoban> murz: Like, just change base==blahblah,  to base,    (no idea if this is good advice, it may magically work though)
11:07:08 <suppi> murz, when I started working with scotty I used this guide loosely also, you can probably remove most of the dependencies until you encounter them
11:07:20 <suppi> and remove the restrictions as kadoban suggested
11:07:49 <ion> rohan: I solved it in the style of https://gist.github.com/cdsmith/9af82fde6549b69537ec (but he commented and structured it much nicer than me)
11:07:50 <Lezkus> hexagoxel: just one more quick question; do I actually need happy and alex if I don't intend to write a compiler in haskell?
11:08:38 <kadoban> Lezkus: Some stuff uses it as dependencies, like I think pandoc maybe uses happy, and pandoc is cool as hell.
11:08:44 <suppi> murz, the cabal file for the project I did looks like this: https://github.com/soupi/hablog/blob/master/hablog.cabal , but I didn't use db and such
11:08:50 <rohan_> ion: my problem is not in solving the exercise as given; if I remove the equivalence line it all checks out.
11:09:05 <murz> I took out the constraints and shaved off a bunch of the dependencies: http://lpaste.net/538769467933458432  now the error looks much different: http://lpaste.net/130440
11:09:07 <hexagoxel> Lezkus: many haskell executables (and development tools like pointfree, hoogle, ..) depend on one or the other)
11:09:45 <mniip> guys I came up with the ultimate monad transformer
11:09:48 <rohan_> ion: the error seems like a bug to me, but I do not feel confident in calling it that, so I am asking here. :)
11:09:53 <murz> Thanks suppi I'll use that as a reference
11:09:53 <lpaste> mniip pasted “The ultimate monad transformer” at http://lpaste.net/130441
11:09:54 <ion> mniip: ContT?
11:10:15 <ion> rohan: Ok
11:10:21 <suppi> murz, did you delete the sandbox first?
11:10:28 <Lezkus> thank you again kadoban and hexagoxel!
11:12:16 <suppi> murz, also I don't know much about it, but i heard stackage is a good thing to use which tries to avoid dependency breakage: http://www.stackage.org/
11:12:37 <mniip> ion, this thing combines MaybeT, ListT, EitherT, and others
11:12:39 <suppi> does anyone has some experience with stackage?
11:14:45 <murz> suppi: Oops, no. I just tried deleting the ".cabal-sandbox" ran cabal sandbox init and cabal install again but I get the same error with all of the "ExitFailure 1"s
11:15:13 <mniip> doesn't seem to include ReaderT though...
11:15:38 <murz> I'll try stackage
11:16:01 <suppi> murz, i think that's what i also do, try deleting cabal.sandbox.config also maybe?
11:16:26 <kadoban> You can just 'cabal sandbox delete' instead of deleting stuff manually.
11:16:52 <kadoban> murz: Also, make sure you don't have conflicting stuff already installed globally, that will probably wreck some otherwise working attempts.
11:16:58 <suppi> kadoban, thanks
11:17:11 <suppi> didn't know that :)
11:17:17 <kadoban> :)
11:17:28 <suppi> also, what is your ghc and cabal versions?
11:18:06 <murz> cabal-install version 1.18.0.5 using version 1.18.1.4 of the Cabal library
11:18:16 <murz> The Glorious Glasgow Haskell Compilation System, version 7.8.3
11:19:20 <murz> Where do global packages get installed? I don't see anything in ~/.cabal/ other than configs and a where-is-my-stuff.txt
11:19:40 <suppi> i guess that where-is-my-stuff.txt will tell you :)
11:19:49 <monochrom> murz: see my http://www.vex.net/~trebla/haskell/sicp.xhtml
11:19:51 <murz> I thought so too but it doesn't
11:20:01 <kadoban> ~/.ghc and ~/.cabal/ maybe. Haha yeah that text file sounds suspiciously topical.
11:20:19 <suppi> ~/Library/Haskell maybe
11:21:00 <murz> ah, looks like there are packages in ~/Library/Haskell/repo-cache/hackage.haskell.org/
11:22:58 <hexagoxel> i normally think "global" refers to system-global, i.e. /usr/lib/ghc-.../..
11:23:09 <monochrom> I agree
11:23:56 <hexagoxel> murz: and in general, `ghc-pkg list` (or `cabal sandbox hc-pkg list` for sandboxes) will tell you installation locations
11:26:03 <murz> hexagoxel: thanks
11:33:59 <oconnore> Hi, I'm getting an error "Couldn't match type Text with text-1.1.0.0:Data.Text.Internal.Text" since 'Text' is from text-1.2.0.4
11:34:03 <oconnore> how do I resolve this?
11:48:15 <mniip> so, is my ultimate monad transformer of any use :o
11:48:32 <mjrosenb> how do sandboxes work? will I always get a sandbox if it is in one of my parent directories?
11:49:23 <kadoban> mjrosenb: IIUC, yes
11:53:22 <osa1> any hermit devs/users here? any ideas how do I use it in a sandbox?
11:53:52 <Cale> mniip: I don't think that'll be an honest monad transformer for most instances of Traversable
11:54:01 <mniip> yes it is
11:54:14 <Cale> Have you proved that it satisfies the associativity law?
11:54:44 <Cale> I don't think it'll be associative
11:54:50 <mniip> m >>= (\x -> f x >>= g) -- this one?
11:54:55 <Cale> yes
11:55:00 <mniip> er
11:55:07 <Cale> QuickCheck it for lists of integers
11:55:08 <mniip> (m >>= f) >>= g ≡ m >>= (\x -> f x >>= g)
11:55:14 <Cale> yeah, that
11:55:32 <mjrosenb> ccoool.
11:55:34 <Cale> The ListT in mtl is *not* a proper monad transformer
11:55:35 * mniip has never worked with quickcheck
11:55:42 <mniip> oh? it is not?
11:55:45 <Cale> Good excuse to learn it!
11:55:47 <mjrosenb> ok, now, I guess I'm just flailing with the emacs integratoin.
11:56:00 <mniip> well then T [] probably isn't a proper transformer either
11:56:55 <Cale> mniip: yeah, ListT m will only be a monad if m satisfies the property that  do u <- x; v <- y; return (u,v) is equal to do v <- y; u <- x; return (u,v)
11:57:04 <Cale> which very few monads really satisfy
11:57:14 <Cale> ("commutative monads")
11:57:32 <Cale> mniip: There's a ListT which is part of pipes which is actually a monad transformer though
11:58:16 <mauke> is Maybe commutative?
11:58:42 <mniip> yeah except for bottoms I think
11:59:06 <mjrosenb> so, what is emacs doing when it asks to make a new cabal project?
11:59:07 <johnw> "except for bottoms" seems to be a universally applicable condition
12:00:22 <frerich> johnw: Universally applicable, except for bottoms, I guess.
12:00:36 <mjrosenb> johnw: I like big bottoms and I can not lie
12:01:09 <mauke> what's a commutative monad that is not Maybe or Reader?
12:01:45 <Cale> mauke: Identity :)
12:01:56 <kadoban> Hah
12:01:59 <Cale> mauke: Writer with a commutative monoid
12:07:07 <murz> Finally got my scotty project to compile.. thanks for all the help. I ran "cabal sandbox hc-pkg list" on one of the dependencies that were failing which said "WARNING: cache is out of date: /Library/Frameworks/GHC.framework/Versions/... Use 'ghc-pkg recache' to fix" so I used ghc-pkg recache and tried cabal install again and it worked!
12:08:32 <bracket> hey, anyone can clue me in real quick why hackage packages often use '4 numbers' for versioning; ie, 0.1.1.5? i don't see it explained why on the hackage versioning doc.
12:10:10 <ReinH> bracket: It's a "patch" number and doesn't have a defined semantics i PVP as far as I know
12:10:14 <ReinH> *in
12:10:34 <bracket> gotcha, cool thanks.
12:11:04 <mniip> Cale, how does one define arbitrary instances
12:12:55 <Cale> mniip: lots of good examples here: http://hackage.haskell.org/package/QuickCheck-2.8.1/docs/src/Test-QuickCheck-Arbitrary.html
12:13:07 <Cale> mniip: and you can skip defining shrink if you want
12:14:00 <Cale> mniip: Gen is a monad, and you can use the instances of arbitrary for other types
12:18:22 <mniip> Cale, ok so I tried with 'T Maybe [] Int'
12:18:24 <mniip> and it passed
12:18:52 <mniip> oh right, that's MaybeT
12:19:18 <mniip> T [] Maybe Int, still passes
12:21:07 <hodapp> runTest :: Int -> IO Test -> IO (Name, Bool, Int, [Name], [Name])
12:21:10 * hodapp twitches
12:23:38 <mniip> Cale, does that mean I made a breakthrough in monadic transformers :3
12:24:12 <Cale> mniip: Well, it means it might be worth trying to prove it :)
12:24:28 <mniip> ah
12:24:28 <mniip> nope
12:24:34 <mniip> T [] [] Int fails
12:25:28 <hodapp> it boggles my mind why they're using a 5-tuple here. They already have a record that, as far as I can see, contains most of the same information.
12:27:55 <athan_> Are Cabal / cabal-install mutually exclusive from using a particular version of GHC? For instance, if I compile cabal install on 7.8, can I use that executable with 7.10?
12:35:14 * hackagebot hspec-snap 0.3.2.4 - A library for testing with Hspec and the Snap Web Framework  http://hackage.haskell.org/package/hspec-snap-0.3.2.4 (DanielPatterson)
12:36:50 <hexagoxel> athan_: it should be completely irrelevant what compiler you used to retrieve a cabal-install executable. the thing that _can_ matter is what Cabal version is used (but that is not strictly connected to ghc version either; even though Cabal is a boot-lib, you can use a different one when compiling cabal-install)
12:37:28 <athan_> hexagoxel: Awesome, thank you
12:38:52 <hexagoxel> athan_: but that should be the case in general; a program compiled with ghc-7.4.2 should behave the same as the same source compiled with ghc-7.10.1 (apart from performance)
12:40:19 <athan_> hexagoxel: Is there a mainstream routine for updating critical libraries to 7.10 / base >= 4.8?
12:40:33 <athan_> s/updating/the updating of
12:41:40 <Philonous> Is there a way to turn -fwarn-incomplete-patterns into an error (and only that one?) 
12:46:17 <hexagoxel> athan_: not that i know of (also, i am not sure if you mean a the social or a the technical level)
12:46:38 <hexagoxel> (i.e. means to organize 7.10-compatability for as much of hackage as possible vs updating a single broken package)
12:46:39 <athan_> hexagoxel: More of a social level, it would be nice to have some kind of goal-oriented collaboration system, though
12:46:48 <athan_> (instead of project oriented, like git / trac)
12:48:53 <hexagoxel> athan_: maybe https://mail.haskell.org/pipermail/haskell-cafe/2015-March/118877.html
12:48:53 <hexagoxel> the nixos guys at least have some automated testing set up, they might know more
12:49:10 <athan_> Right on :)
12:54:15 <hexagoxel> (and gals..)
12:57:03 <infandum> I want to make a computation in parallel across a list. The function, f, is a huge giant pure function with all these complexities, and it's mapped over a list [start,(start + interval)..(end - 1)] ++ [end]. So I want parMap rseq f $ [start, etc., right?
12:57:24 <infandum> Compiled with -threaded and +RTS -N makes it the same speed, sometimes slower
12:57:31 <infandum> even -N2 or -N3
12:57:41 <seanhess> using parsec, how do you ignore large portions of a string? Like parsing all the numbers out of a large string and nothing else?
12:57:52 <seanhess> I'm using attoparsec for now if that makes a difference
12:58:56 <kadoban> seanhess: Use sepBy with something that consumes everything you don't care about I guess?
12:59:05 <hexagoxel> infandum: do you have -rtsopts compile flag as well?
12:59:53 <infandum> hexagoxel: I tried with it on and off and it was slower either way
13:00:15 <infandum> hexagoxel: I had -sstderr and it reported 0 sparks
13:00:22 <infandum> hexagoxel: which seems wrong
13:02:03 * hexagoxel forwards this back to the general public
13:03:14 <infandum> hexagonal: Could it have something to do with it being a lazy list?
13:10:16 * hackagebot ttrie 0.1.1 - Contention-free STM hash map  http://hackage.haskell.org/package/ttrie-0.1.1 (MichaelSchroeder)
13:10:44 <infandum> Woah, does hackagebot automatically report uploaded packages?
13:11:17 <benzrf> yee!
13:11:48 <infandum> ahaha well THAT explains why so many people downloaded my little package
13:13:21 <infandum> either that or bots
13:13:27 <lelf> what's the sane way to write (forever $ do { x <- await; when (bad x) $ lift $ EitherT.left "oops"; yield x })?
13:14:42 <syndarion> Hi, i'm learning Haskell through LYAH and an online UPenn course, and the latter has an assignment where you need write a function `allColors` to find all length n combinations of 6 colors. I thought this was the way to go: take n=1 as base, and for n>1 combine allColors (n-1) with allColors 1. The assignments gives `concatMap` as a hint, but I don't have a clue on how to do it. Any advice? :)
13:15:14 <syndarion> Btw, I've found a different way, using list comprehension, but I'd really like to find it using `concatMap`.
13:16:24 <mauke> what's your solution using list comprehensions?
13:16:59 <syndarion> mauke: `allCodes n = [ x ++ y | x <- allCodes (n-1), y <- allCodes 1 ]`
13:17:36 <mauke> @undo allCodes n = [ x ++ y | x <- allCodes (n-1), y <- allCodes 1 ]
13:17:36 <lambdabot> allCodes n = concatMap (\ x -> concatMap (\ y -> [x ++ y]) (allCodes 1)) (allCodes (n - 1));
13:18:05 <syndarion> Wow, hard to read :P
13:18:13 <mauke> it can be simplified a bit
13:18:32 <syndarion> Do you think there's a difference in performance between the two?
13:18:49 <mauke> no
13:19:04 <mauke> that's how list comprehensions are implemented
13:19:21 <syndarion> Then i'll stick with the list comprehension actually :)
13:19:59 <mniip> what was the tex symbol for :: again
13:21:07 <quchen> \paamayimNekudotayim
13:21:15 <mniip> close but no
13:21:37 <hexagoxel> dblcolon?
13:21:43 <srhb> squaredots? Or are they too spaced?
13:21:49 <quchen> :\!:
13:22:02 <mauke> unicode name: PROPORTION
13:22:10 <quchen> Detexify isn't helping so I'm guessing ;-)
13:22:30 <mniip> hmm, mathb.in seems to understand neither :/
13:22:40 <mniip> I'll stick with plain :: I guess then
13:23:14 <srhb> \coloncolon :3
13:23:16 <quchen> The colonequals package has \coloncolon.
13:25:41 <hexagoxel> bind must be \ggeq :D
13:25:57 <quchen> \kleisliFish
13:26:07 <quchen> \lensRat
13:26:09 <quchen> \robotMonkey
13:26:39 <lelf> \squaredots
13:26:46 <mauke> \squaredots (MnSymbol)
13:28:53 <jhance> blah, looks like my VM doesn't have enough memory to compile haskell-src-exts
13:28:55 <mauke> \dblcolon (mathtools)
13:29:36 <mgsloan> jhance: It's because of all the deriving clauses in the syntax datatypes
13:29:40 <mauke> \coloncolon (colonequals)
13:30:17 * hackagebot breve 0.0.2.2 - a url shortener  http://hackage.haskell.org/package/breve-0.0.2.2 (rnhmjoj)
13:30:28 <mgsloan> (or at least, that's why haskell-src-exts takes 40 seconds to compile instead of 5)
13:30:32 <mauke> ok, I think that's all of them
13:30:58 <cfoch> Yo!
13:31:02 <cfoch> o/
13:31:48 <jhance> Hopefully temporarily giving it 4 GB lets me compile it
13:32:01 <cfoch> Does someone has experience with GHC API ? I have this code which prints what modules does a 'data type' belongs to. 
13:32:02 <cfoch> http://dpaste.com/2078VBY
13:32:59 <cfoch> But it only works if I do " guessTarget "test.hs" Nothing" (line 17). Is there a way to avoid putting that?
13:35:17 * hackagebot cblrepo 0.15.1 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.15.1 (MagnusTherning)
13:36:35 <oconnore> What file does ghc need to reference a cabal sandbox? I'm getting: ghc: can't find a package database at .cabal-sandbox/x86_64-linux-ghc-7.8.4-packages.conf.d
13:39:59 <hexagoxel> oconnore: where is the sandbox? how did you call ghc?
13:42:04 <jhance> anyone able to build concrete-typerep on 7.10?
13:43:56 <oconnore> hexagoxel: ah, that was right, I just forgot to add '..' because I am compiling from a sub directory. I wasn't sure if the '*packages.conf.d' directory was the right thing.
13:44:01 <oconnore> hexagoxel: thanks
13:44:29 <hexagoxel> oconnore: also, you know of `cabal exec`, right?
13:45:30 <hexagoxel> (if you `cabal exec -- sh -c "echo \$GHC_PACKAGE_PATH"`, you see what cabal would forward to ghc)
13:46:17 <oconnore> hexagoxel: ah, that might be easier
13:46:23 <oconnore> thanks
13:46:41 <athan> hexagoxel: That's awesome!!
13:46:56 <athan> I knew about cabal exec, but I thought it was just for an executable in the install path
13:48:54 <hexagoxel> athan: there is the `cabal exec bash` trick as well, which gives you a sandbox-aware shell (by the virtue of GHC_PACKAGE_PATH defined appropriately in the env) :)
13:49:15 <hexagoxel> only caveat is that you should not `cabal exec` again inside that environment, afaik
13:49:27 <meoblast001> hi
13:49:52 <hexagoxel> (i don't use that trick; there may be other problems)
13:50:18 * hackagebot git-annex 5.20150409 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20150409 (JoeyHess)
13:50:20 * hackagebot simtreelo 0.1.0.3 - Loader for data organized in a tree  http://hackage.haskell.org/package/simtreelo-0.1.0.3 (mgmillani)
13:53:14 <meoblast001> hi. i'm having a bit of a problem with the binary package... i'm trying to read copies of the same data at different locations in a file... after i seek to new locations in the file, the data at that location is the same (in the lazy byte string).. but when i read it with the binary package, it's not right
13:53:19 <meoblast001> here's the code: https://gist.github.com/meoblast001/5ecb8ae7850d12c5df29
13:53:28 <meoblast001> the most important functions are fetchBackupSuperblocks and getSuperblock
13:53:38 <meoblast001> at the bottom in the comment is the output of the program
13:55:18 * hackagebot descrilo 0.1.0.3 - Loads a list of items with fields  http://hackage.haskell.org/package/descrilo-0.1.0.3 (mgmillani)
13:55:42 <meoblast001> i'm tempted to believe the prints of the byte string contents all consecutively implies maybe it's executing things in the wrong order
13:55:52 <meoblast001> and calling all of the hSeek's before it runs the binary monad
13:55:59 <meoblast001> which would explain why the second run is wrong
13:56:15 <meoblast001> but i don't know how to change that
14:00:56 <geekosaur> meoblast001, you can't mix hGetCOntents with anything else. if anything, the bug there is that either hGetContents is not marking the handle closed, or hSeek is ignoring that and then undoing it
14:01:21 <geekosaur> hGetContents takes control of the Handle and hands it to something resembling a background thread
14:01:21 <meoblast001> marking the handle closed?
14:01:32 <meoblast001> oooh :X
14:01:35 <geekosaur> if you manipulate the handle afterward, things break in weird ways
14:01:44 <meoblast001> that explains a lot
14:01:50 <geekosaur> so it marks it "half-closed" and other operations should fail on it
14:01:52 <meoblast001> are there ways i could... do sort of what i'm doing without that?
14:02:27 <meoblast001> i basically need chunks of the file as byte strings but then need to be able to jump to other parts of the file (using something like hSeek) based on things i read from that bytestring
14:02:50 <geekosaur> I'm not sure.. I got lost last time I tried to figure out how to avoid lazy I/O without switching to conduit or pipes
14:02:55 <geekosaur> possib ly you should just do that
14:03:18 <meoblast001> isn't pipes supposed to be extremely complicated?
14:03:31 <geekosaur> because while lazy I./O is covenient, it is neither reliable (no way to get errors) nor capable of the htings you are trying to dos
14:04:39 <geekosaur> hm. hGet can do chunked reads (think the read syscall)
14:05:13 <geekosaur> pipes is different. the internals are pretty complicated, but for most things you shouldn't need to care
14:05:43 <meoblast001> so pipes would be simpler than conduit for this?
14:06:21 <geekosaur> it's supposed to be, as I understand it
14:06:49 <meoblast001> geekosaur: hGet shouldn't do what hGetContents does?
14:07:07 <meoblast001> i could survive with hGet if it won't destroy the handle
14:07:17 <geekosaur> hGet doesn't do lazy I/O
14:07:23 <meoblast001> yay
14:07:30 <meoblast001> everything i'm working with has fixed sizes.. iirc
14:07:40 <meoblast001> thanks, geekosaur :)
14:07:55 <geekosaur> it will block if not enough data is available; see hGetNonBlocking or hGetSome to deal with that
14:08:15 <meoblast001> okay. blocking is okay in my scenario. but that's good to know :)
14:08:22 <meoblast001> this may fix more than one problem hahaha
14:08:44 <meoblast001> i was getting a lot of similar issues to this. and i kept reading the file format spec and thinking "wtf?! this is exactly how i'm reading it"
14:08:48 <meoblast001> this explains a lot
14:08:51 <geekosaur> yep
14:08:59 <geekosaur> lazy I/O is ... annoying
14:09:17 <geekosaur> but it's really convenient for many common things
14:09:43 <geekosaur> (as long as you're fine with the kind of laziness you see in so many C programs which just silently ignore I/O errors...)
14:09:46 <meoblast001> yeah. it's nice to have sometimes
14:09:59 <meoblast001> like one library i'm working on.. it has no business existing in I/O, but it reads different types of files
14:10:34 <meoblast001> geekosaur: i actually got into a conversation about this the other day with someone in this channel (hi relrod). does haskell have a way to handle errors in lazy I/O?
14:10:43 <meoblast001> or does the program just bomb out if i disconnect a harddrive while reading a file off of it
14:10:50 <stephenmac7> Is there any way to get active patterns in haskell?
14:10:57 <geekosaur> lazy I/O will just return EOF at that point
14:11:04 <meoblast001> hm. interesting
14:11:06 <geekosaur> no exception, no failure
14:11:36 <meoblast001> it'd be cool if there were some kind of type representing a lazy list of (Either IOError a)
14:11:41 <geekosaur> the unsafeInterleaveIO-d thing has no ability to throw any ind of exception or error indication; all it can do is stiop producing data, which is the same as it does for EOF
14:12:11 <geekosaur> if you want any kind of handling, you either implement in terms of lower level stuff like hGetBuf (hGet is just a ByteString wrapper for that) or switch to pipes/conduit
14:12:22 <geekosaur> and at this point I think pipes has eclipsed conduit
14:13:32 <meoblast001> hmmm. thanks :)
14:13:37 <meoblast001> that's interesting to know
14:13:42 <meoblast001> and quite frankly, very useful to know
14:16:07 <meoblast001> \o/ now i get consistent numbers
14:16:09 * meoblast001 hugs geekosaur 
14:24:14 <lpaste> edwardk pasted “fast fibonacci transform a la linear” at http://lpaste.net/130447
14:26:26 <l8star_> hi @all
14:34:44 <relrod> edwardk: huh, that looks neat
14:47:31 <benzrf> hmmmm
14:47:40 <benzrf> my local generated haddocks dont seem to have source links
14:47:42 <benzrf> what the heck
14:47:47 <benzrf> do i need to flip a switch
14:50:21 * hackagebot repl-toolkit 0.4.0.0 - Toolkit for quickly whipping up config files and command-line interfaces.  http://hackage.haskell.org/package/repl-toolkit-0.4.0.0 (jtapolczai)
14:52:27 <geekosaur> is hscolour installed?
14:52:51 <geekosaur> otherwise I'd guess the --hyperlink-source option is relevant
14:54:18 <benzrf> it's in
14:54:30 <benzrf> god dammit
14:54:32 <benzrf> it was off ;-;
14:55:48 <nrw> i have a fairly high level question. #haskell seemed like a place that would be full of people with answers about functional programming. :)
14:56:11 <nrw> is there a common pattern for how you represent playing audio in an immutable data structure? i'm used to dealing with data that changes on a schedule i set. playing audio is changing constantly.
14:56:53 <KaneTW> :t forever
14:56:54 <lambdabot> Monad m => m a -> m b
14:57:04 <nrw> a good example of what i'm trying to do is building the interface of a music player with play, pause, and "seek to point in song"
15:00:17 <nrw> KaneTW: ah. that's a really efficient answer. :)
15:00:19 <nrw> thanks.
15:02:46 <KaneTW> haha that was unintenional
15:02:48 <KaneTW> +t
15:02:53 <KaneTW> was just looking up a time
15:02:55 <KaneTW> type*
15:03:16 <nrw> KaneTW: i thought that might be the case, but i think that solves my problem.
15:03:24 <nrw> KaneTW: do you have another suggestion?
15:03:26 <nrw> :D
15:03:45 <srhb> nrw: Not sure I understand the question. You want to represent the "played" audio in a pure fashion?
15:04:00 <srhb> So it would simply be the bitstream thrown at /dev/audio or whatever?
15:04:30 <srhb> If so, any container that deals well with binary would do, I imagine.
15:05:51 <nrw> srhb: if i have a song playing, and i want to keep the interface updated with the correct number of milliseconds of the song that have been played, i need to represent "ms_elapsed" as data and update it.
15:05:56 <srhb> Aaah
15:06:25 <nrw> srhb: i have thought of "loop checking how much has been played" :P
15:06:30 <srhb> No specific idea about that, but it sounds vaguely FRP'y
15:06:35 <KaneTW> frp yeah
15:06:43 <srhb> The whole events (seconds elapsed) -> gui update 
15:07:06 <benzrf> aaargh
15:07:22 <benzrf> how do i get a Q Type from a Name like ”Int
15:07:22 <nrw> is looping and checking how much has played a good solution, then?
15:07:28 <benzrf> ugh, \'\'Int
15:07:32 <benzrf> ...you get the idea
15:07:34 <srhb> nrw: I would really suggest looking into FRP, if you have the time. :)
15:07:52 <srhb> Your solution sounds very callbacky, you could probably get rid of that.
15:08:00 <srhb> If you really want to be functional about it :)
15:09:12 <nrw> srhb: i have some experience with frp. i'm building the ui with an frp (javascript) tool https://github.com/Raynos/mercury
15:09:19 <srhb> Ah. :)
15:09:23 <nrw> srhb: i don't know why i feel like dealing with playing audio is such a change.
15:09:55 <nrw> srhb: i guess and audio stream is just a data stream that gets piped to the speakers. ;P
15:09:57 <srhb> Then you probably know more than I do. I would imagine the FRPy solution would be to "simply" (whatever that entails) have an event fire whenever a second is elapsed on the song, and that would trigger the UI update
15:10:17 <nrw> srhb: ok. you have been very helpful. :)
15:10:19 <nrw> thanks!
15:10:31 <srhb> Not really, but I hope you find a nice solution (and bring it back) :-)
15:13:05 <Cale> nrw: The time at which you started playing the audio changes less often at least.
15:14:25 <Cale> nrw: I don't know if that helps any. Probably there ought to be a way to query whatever code is actually playing the audio stream for its status.
15:15:06 <bennofs> ryantrinkle: what is the reason fmap for Dynamic in reflex cannot be implemented as fmap f (Dynamic b e) = Dynamic (fmap f b) (fmap f e) ?
15:19:21 <ryantrinkle> bennofs: that would result in double-evaluating f for a single update
15:19:42 <chpatrick1> is there a nice way to do the equivalent Maybe mappend with a given function instead of a semigroup instance?
15:19:49 <chpatrick1> *equivalent of a
15:20:15 <chpatrick1> so if both maybes are Just, combine them with f, otherwise whichever one is Just
15:20:36 <bennofs> ryantrinkle: ah ok, didn't think of that as a big problem. thanks
15:20:54 <ryantrinkle> bennofs: for expensive 'f', it's pretty bad; for trivially cheap f, it's probably fine
15:21:35 <enthropy> > mappend (Just 1) (Just 2)
15:21:36 <lambdabot>      No instance for (Show a0)
15:21:37 <lambdabot>        arising from a use of ‘show_M861538774292722784810833’
15:21:37 <lambdabot>      The type variable ‘a0’ is ambiguous
15:22:05 <quchen> enthropy: Num a => a (which is 1's type) isn't a Monoid.
15:22:07 <ryantrinkle> bennofs: one of my top priorities is supporting Functor (Dynamic t); hopefully that can be done in the next release
15:22:24 <bennofs> ryantrinkle: btw, push (liftM Just . f) $ updated b should be equal to fmap f $ updated b, no ?
15:22:25 <srhb> > Just 1 <> Just 2 :: Maybe (Sum Int)
15:22:27 <lambdabot>  Just (Sum {getSum = 3})
15:22:35 <enthropy> > mplus (Just 1) (Just 2) -- I guess what I was thinking of
15:22:37 <lambdabot>  Just 1
15:22:53 <srhb> enthropy: Not sure what you want :)
15:22:54 <quchen> enthropy: The First newtype around Maybe has that behaviour.
15:22:58 <ryantrinkle> bennofs: yes, that's right
15:23:23 <ryantrinkle> er, i think there may be an extra `return` or something that ought to be in there
15:23:25 <enthropy> @type \f x y -> msum [ liftM2 f x y, x, y ]
15:23:26 <lambdabot> MonadPlus m => (a -> a -> a) -> m a -> m a -> m a
15:23:26 <bennofs> ryantrinkle: seems that Dynamic can also be made Applicative and Monad then (assuming the laws work out), which could eliminate combineDyn and joinDyn
15:23:32 <enthropy> chpatrick1: ^^
15:23:35 <ryantrinkle> push (liftM Just . return . f)
15:23:55 <bennofs> ryantrinkle: ah, that's why it didn't use fmap there. f is indeed of type a -> PushM b
15:24:12 <ryantrinkle> bennofs: yes, that's correct; however, without fusion laws, Applicative-style usage will be slow
15:24:34 <ryantrinkle> i have an ugly-but-fast TH-based way of combining lots of dynamics together
15:24:41 <ryantrinkle> Reflex.Dynamic.TH
15:24:44 <chpatrick1> neat
15:25:28 <bennofs> ryantrinkle: I guess this is the same reason why merge is more performant than just using align?
15:25:35 <ryantrinkle> bennofs: correct
15:25:46 <ryantrinkle> there's bookkeeping associated with each merge or pull
15:25:59 <ryantrinkle> there's very little overhead associated with fanning in lots of stuff together
15:26:31 <ryantrinkle> but making it have a binary tree structure means you've got the full overhead at each node
15:28:43 <bennofs> ryantrinkle: the comment next to merge says you want to generalize merge so it does not depend on DMap. Do you already know how to do this?
15:30:04 <ryantrinkle> roughly
15:30:23 <ryantrinkle> i need a dependently-typed indexed traversable functor class
15:30:49 <bennofs> oh :| I thought maybe it would become easier
15:31:09 <ryantrinkle> it also need a dependently-typed 'Align' function
15:31:28 <ryantrinkle> bennofs: well, perhaps some renaming is in order
15:31:34 <rockfruit> this is the most transcendental channel on freenode.  the infinite type?  I had presumed upon nature.
15:31:47 <ryantrinkle> the maximally-general version doesn't necessarily need to be the one with the shortest name :P
15:39:49 <bennofs> ryantrinkle: so the overhead from align comes from the fact that you have to build lots of intermediate events, instead of just one event for a "set" of input events? So there could be a way that some kind of fusion makes align as efficient as merge?
15:40:04 <ryantrinkle> bennofs: precisely
15:40:23 * hackagebot yesod-angular-ui 0.1.0.1 - Angular Helpers  http://hackage.haskell.org/package/yesod-angular-ui-0.1.0.1 (tolysz)
15:40:31 <ryantrinkle> bennofs: what we want to do is fuse all the merges (and the pulls, which merge behaviors) into a single one when we statically know the structure
15:41:22 <ryantrinkle> i haven't looked into what it would take to get reliable fusion for this stuff, but if we could, then it would allow much more use of idiomatic haskell
15:41:58 <ryantrinkle> plus, it would probably speed up even the current existing code
15:43:17 <bennofs> I see, thank you very much for explaining this. I agree that having such fusion would make things a lot nicer, and it would also probably make the API easier to understand (through there may be problems with predicting when fusion happens ... as always with optimizations that are implicit)
15:43:50 <ryantrinkle> my pleasure :)
15:44:01 <ryantrinkle> the predictability of the fusion is definitely key
15:44:17 <ryantrinkle> one of my goals with reflex is to make it perform well *by default*
15:44:32 <ryantrinkle> users shouldn't need to understand anything about the implementation in order to get good performance
15:48:37 <bennofs> wow, the last argument of ReaderT has role nominal since the base monad could require it's argument to be nominal. this looks really limiting
15:49:45 <ryantrinkle> ah
15:49:48 <ryantrinkle> that's interesting
15:49:57 <ryantrinkle> i wasn't able to get any nice coercions working
15:50:18 <ryantrinkle> i don't really understand all the type roles stuff yet
15:53:06 <bennofs> ryantrinkle: well, the reason that ReaderT r m a has a at role nominal is that m could apply some type family to a, so that it would contain a different type depending on whether a is an Int or a newtype of an Int for example. So coercing ReaderT r m a to ReaderT r m (newtype of a) in general is not safe for all m
15:53:19 <nrw> Cale: right now, i'm going with time_started_playing - time_now. we had the same idea there. :)
15:54:23 <mjrosenb> In Reactive.Banana, newAddHandler returns two values, one seems to be the trigger that generates events.  The other looks kind of like reactimate.  Is this the case?
15:56:07 <bennofs> mjrosenb: yes. the snd is the trigger, the first one is an AddHandler, which is a function that can be used to register new "event" handlers, just like reactimate (using register :: AddHandler a -> (a -> IO ()) -> IO (IO ())). Unlike reactimate, it also allows you to unregister the handler again by executing the returned "unregister" action
15:56:50 <bennofs> mjrosenb: you can also get an Event using fromAddHandler :: AddHandler a -> Moment t (Event t a)
15:57:22 <fragamus> i wish i knew about "what i wish i knew when learning haskell" when learning haskell
15:58:10 <Rotaerk> how meta
15:59:13 <mjrosenb> bennofs: but... AddHandler can also be used to translate some IO into an event, right?
15:59:24 * mjrosenb is like 10% sure he has done this in the past.
16:00:02 <bennofs> mjrosenb: yes, since you can get an Event from an AddHandler, you can use it to get an Event that can be triggered via a trigger function from IO
16:09:16 <fragamus> does anyone use leksah
16:14:17 <hunteriam> whats the best way given strings a and b to select the string with the longer length?
16:15:16 <srhb> hunteriam: selectLonger x y = if length x >= length y then x else y ?
16:15:30 <hunteriam> i feel like there must be a better way than bigS a b | length a > length b = a | otherwise = b
16:15:39 <srhb> Hmm.
16:15:49 <hunteriam> something using existing prelude functions maybe?
16:16:08 <srhb> maxBy, is that a thing?
16:16:12 <hunteriam> cause we have max which is what i want but it uses lexicographic order
16:16:30 <hunteriam> :info max
16:16:35 <srhb> No, that's not what I want, indeed.
16:17:03 <hunteriam> i just wanted to see what module max was in to look for maxBy
16:17:28 <srhb> Data.Ord
16:17:31 <EvanR> :t maximumBy
16:17:32 <lambdabot> Foldable t => (a -> a -> Ordering) -> t a -> a
16:18:14 <EvanR> best could mean highest performance, least time to research, etc ;)
16:20:01 <srhb> So build something with comparing, I guess
16:20:03 <srhb> :t comparing
16:20:04 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
16:20:27 <pacak> > > fst . maximumBy (compare `on` snd) . map (id &&& length) $ ["foo", "fooooo"]
16:20:29 <lambdabot>  <hint>:1:1: parse error on input ‘>’
16:20:30 <EvanR> or just use the if based version above
16:20:31 <pacak> > fst . maximumBy (compare `on` snd) . map (id &&& length) $ ["foo", "fooooo"]
16:20:33 <lambdabot>  "fooooo"
16:20:49 <srhb> Yow.. :P
16:26:36 <srhb> > maximumBy (comparing length) ["abc", "abcd"] -- is probably the nicest with standard functions
16:26:37 <lambdabot>  "abcd"
16:26:43 <srhb> Very readable at least.
16:27:50 <EvanR> maximumBy is not on Foldable, need to restructure how to explain stuff to noobs ;)
16:27:53 <EvanR> is now*
16:28:06 <srhb> Aha
16:28:35 <EvanR> rewrite the type with specialization for list, like the way monad stuff is explained a lot of the time
16:28:38 <EvanR> by picking a monad
16:29:22 <srhb> Not sure that was a problem for hunteriam :)
16:29:28 <lynnard> what's the most elegant way to get the sum of a list of Maybe values
16:29:58 <arkeet> :t sum . catMaybes
16:29:58 <EvanR> sum . catMaybes ?
16:29:58 <ryantrinkle> lynnard: i would probably use (sum . catMaybes)
16:29:59 <lambdabot> Num c => [Maybe c] -> c
16:30:12 <EvanR> assuming Nothing counts as zero
16:30:22 <lynnard> I'm more thinking in the way of Applicative
16:30:31 <lynnard> like (+) <$> a <*> b
16:30:38 <lynnard> which handles failure nicely
16:30:47 <EvanR> a b isnt a list
16:30:54 <EvanR> or even compatible
16:30:56 <arkeet> do you want to fail if the list has a single Nothing in it?
16:31:01 <lynnard> arkeet: yes
16:31:06 <lynnard> a b are Maybe values
16:31:23 <ryantrinkle> :t fmap sum . sequence
16:31:24 <lambdabot> (Monad f, Num b, Traversable t) => t (f b) -> f b
16:31:26 <lynnard> I'm just giving an example which I'd like to generalize for list
16:31:47 <arkeet> :t fmap sum . sequenceA
16:31:48 <lambdabot> (Num b, Applicative f, Traversable t) => t (f b) -> f b
16:32:04 <arkeet> @let untraverse f = fmap f . sequenceA
16:32:05 <arkeet> :t untraverse
16:32:05 <lambdabot>  Defined.
16:32:06 <lambdabot>     Not in scope: ‘untraverse’
16:32:06 <lambdabot>     Perhaps you meant one of these:
16:32:06 <lambdabot>       ‘traverse’ (imported from Control.Lens),
16:32:12 <arkeet> :t untraverse
16:32:13 <lambdabot> (Applicative f, Traversable t) => (t a -> b) -> t (f a) -> f b
16:32:31 <EvanR> the known untraverse
16:32:32 <arkeet> > untraverse sum [Just 1, Just 2]
16:32:34 <lambdabot>  Just 3
16:32:35 <arkeet> > untraverse sum [Just 1, Just 2, Nothing]
16:32:36 <lambdabot>  Nothing
16:32:57 <arkeet> couldn't think of a better name at the time.
16:33:31 <srhb> I like it :P
16:33:38 <arkeet> > (untraverse.untraverse) sum [[Just 1, Just 2],[Just 3]]
16:33:40 <lambdabot>  [Just 4,Just 5]
16:34:31 <arkeet> oh right yeah.
16:34:50 <arkeet> that composes Applicatives.
16:34:50 <bennofs> ryantrinkle: btw, do you have benchmarks / tests for reflex?
16:35:14 <ryantrinkle> bennofs: i have tests, but they're in a weird state right now; i'll publish them when i get a chance
16:35:21 <ryantrinkle> benchmarks, not really
16:35:26 <arkeet> > (untraverse.untraverse) sum [Just (Just 1), Just (Just 2)]
16:35:28 <lambdabot>  Just (Just 3)
16:35:32 <arkeet> > (untraverse.untraverse) sum [Just (Just 1), Just Nothing]
16:35:33 <lambdabot>  Just Nothing
16:35:35 <arkeet> > (untraverse.untraverse) sum [Just (Just 1), Nothing]
16:35:37 <lambdabot>  Nothing
16:35:39 <bennofs> :t untraverse
16:35:40 <lambdabot> (Applicative f, Traversable t) => (t a -> b) -> t (f a) -> f b
16:35:41 <ryantrinkle> it would be great to have some benchmarks, especially for regression testing
16:36:07 <lynnard> so this requires Traversable
16:36:15 <arkeet> list is a Traversable
16:36:37 <lynnard> yes I see
16:37:03 <lynnard> okay thanks
16:37:04 <arkeet> > untraverse sum [(+1),(*2)] 10
16:37:05 <lambdabot>  31
16:37:32 <lynnard> btw, untraverse is a weird name to me :P 
16:37:36 <arkeet> it is to me too.
16:37:48 <arkeet> but I never thought of a better one.
16:37:50 <bennofs> arkeet: untraverse f = fmap f . sequenceA ?
16:37:52 <arkeet> yes
16:37:57 <arkeet> I defined it above.
16:38:10 <bennofs> oh, I just saw that. scrolled off already :)
16:38:13 <l8star_> > utraverse 2 + 2
16:38:14 <lambdabot>      Not in scope: ‘utraverse’
16:38:14 <lambdabot>      Perhaps you meant one of these:
16:38:14 <lambdabot>        ‘traverse’ (imported from Control.Lens), ‘untraverse’ (line 153),
16:38:30 <l8star_> >  2 + 2
16:38:31 <lambdabot>  4
16:41:29 <mjrosenb> > maximumBy (compare `on` length) ["foo", "fooooo"]
16:41:30 <lambdabot>  "fooooo"
16:41:50 <mjrosenb> oh, good.
16:41:57 <mjrosenb> @hoogle on
16:41:58 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
16:41:58 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
16:41:58 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
16:42:05 <arkeet> (compare `on`) = comparing
16:42:28 <arkeet> I wouldn't miss comparing if it was gone though, since we can just use compare `on`
16:42:46 <arkeet> I find it a bit odd that we have a name for (compare `on`) but not ((==) `on`)
16:43:04 <mjrosenb> arkeet: how about ==ing?
16:43:29 <arkeet> I'd suggest equating, but I'd rather have neither than both.
16:43:59 <arkeet> I'd rather build it up out of simpler things. like (==) and on.
16:44:44 * mjrosenb is kind of amused about the simultaneous prefixing of ==, and infixing of on, in one expression.
16:44:49 <mjrosenb> with nothing else in there.
16:45:45 <arkeet> well,  on (==) length  doesn't quite sound the same.
16:46:00 <srhb> mjrosenb: And a section on top of that. Perverse.
16:46:11 <arkeet> haha
16:51:44 <arkeet> @let zippy = getZipList . traverse ZipList
16:51:46 <lambdabot>  Defined.
16:52:00 <arkeet> > zippy [[1,2,3],[4,5,6]]
16:52:01 <lambdabot>  [[1,4],[2,5],[3,6]]
16:52:23 <arkeet> oops.
16:52:25 <arkeet> crap.
16:52:30 <arkeet> @undefine
16:52:30 <lambdabot> Undefined.
16:52:34 <mjrosenb> now all we need is an infix constructor, or a tuple section, and we can start charging for it!
16:52:37 <arkeet> @let zippy f = fmap f . getZipList . traverse ZipList
16:52:38 <lambdabot>  Defined.
16:52:44 <arkeet> @let untraverse f = fmap f . sequenceA
16:52:45 <lambdabot>  Defined.
16:53:31 <arkeet> never mind it
16:53:33 <arkeet> 's all wrong.
16:53:53 * mjrosenb stares at AddHandler a bit more.
16:54:13 <arkeet> > zippy sum [[1,2,3],[10,20,30]]
16:54:14 <lambdabot>  [11,22,33]
16:54:21 <arkeet> > untraverse sum [[1,2,3],[10,20,30]]
16:54:22 <lambdabot>  [11,21,31,12,22,32,13,23,33]
16:54:23 <mjrosenb> I guess the register function gets called once per instance of fromAddHandler?
16:54:59 <arkeet> maybe I should start a blog where I can put silly things like this.
16:56:25 <mjrosenb> arkeet: you already have one!
16:56:31 <arkeet> where?
16:56:40 <mjrosenb> arkeet: http://tunes.org/~nef/logs/haskell/?C=M;O=D ... the signal to noise ratio is kind of low though.
16:57:10 <arkeet> heh
16:59:11 <shachaf> <arkeet> I support the idea of shachaf having a blog.
16:59:16 <shachaf> arkeet: it's mutual hth
16:59:50 <osa1> is MultiWayIf enabled by default in GHC 7.10 ?
17:00:20 <XorSwap> > [1..10]
17:00:22 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
17:00:30 <XorSwap> sweet :)
17:00:33 <mjrosenb> MultiWayIf?  sounds interesting.
17:06:07 <XorSwap> > zip
17:06:08 <lambdabot>      No instance for (Typeable a0)
17:06:09 <lambdabot>        arising from a use of ‘show_M623814326776801512712666’
17:06:09 <lambdabot>      In the expression:
17:08:06 <NateUni> can someone help me understand what is going on with this function?
17:08:10 <NateUni> (please)
17:08:49 <Tene> NateUni: Which function?
17:09:00 <NateUni> one sec just enlarging this font.. 
17:09:08 <Tene> o_O
17:09:21 <Xe> o/ Tene 
17:09:23 <EvanR> equipping glasses
17:09:25 <mjrosenb> ok... this feels strange.
17:09:50 * mjrosenb has callback :: () -> IO ()
17:10:09 <mjrosenb> and an underlying function that reasonably takes an IO ()
17:10:10 <EvanR> that might be necessary to satisfy some polymorphic type
17:10:31 <mjrosenb> so, I have doRepeatedly (callback ())
17:10:31 <EvanR> requiring a -> IO b
17:11:40 <mjrosenb> while I'm used to laziness, it still looks strange, like callback is only going to be evaluated once, when doRepeatedly first looks at its argument.
17:12:24 <hpc> evaluation and execution are different
17:13:10 <mjrosenb> hpc: yes. I know.
17:14:56 <NateUni> ok thats better
17:15:43 <NateUni> mergeSort xs  | (length xs <= 1) = xs  | otherwise = merge (mergeSort xs1) (mergeSort xs2) where (xs1, xs2) = split xs
17:16:00 <NateUni> Thats the function I want to ask about.. 
17:16:41 <mjrosenb> that is not my favorite implementation of mergesort in a functional language :-/
17:16:54 <NateUni> It is a learning task.. 
17:17:14 <NateUni> And has been modded to make it more readable for newbies like myself. 
17:17:49 <NateUni> I just dont get what is happeneing precedence wise with all the recursion
17:18:24 <kadoban> NateUni: precedence wise? Not sure what you mean.
17:18:54 <NateUni> ok sorry if I am not communicating well.. let me try and explain. 
17:19:08 <mjrosenb> NateUni: if you want to think of it as being eagerly evaluated, then first split gets called, then the two inner mergeSorts get called, finally, the outer merge gets called.
17:19:28 <NateUni> ok that what I am enquiring about.. 
17:19:40 <NateUni> let me ponder that for a minute by looking at the code.
17:19:40 <mjrosenb> hrmm
17:19:45 <mjrosenb> > f 5
17:19:47 <lambdabot>      No instance for (Show a0)
17:19:47 <lambdabot>        arising from a use of ‘show_M522174606402427698112871’
17:19:47 <lambdabot>      The type variable ‘a0’ is ambiguous
17:20:01 <mjrosenb> what is the magic type to make that show up nicely?
17:20:25 <NateUni> me?
17:20:36 <shachaf> > f 5 :: Expr
17:20:36 <mjrosenb> NateUni: no.
17:20:37 <lambdabot>  f 5
17:20:39 <EvanR> :t f
17:20:40 <lambdabot> FromExpr a => a
17:20:42 <NateUni> ops ok.
17:20:44 <mjrosenb> shachaf: danke
17:21:39 <NateUni> ok so here is what is confusing me.. with this: “first split gets called, then the two inner mergeSorts get called, finally, the outer merge gets called.”
17:23:04 <NateUni> Split recursively goes and partitions a list so it is more or less even and returns as a tuple which is comprrised of two lists… but if MergeSort gets called on those lists.. then wont it just call split again..?
17:23:19 <mjrosenb> NateUni: yup.
17:23:27 <jhance> NateUni: Yea, recursion.
17:23:32 <mjrosenb> NateUni: but it'll call it on a list that is half as large.
17:23:51 <mjrosenb> NateUni: part of the version of mergesort that I like doesn't involve calling split
17:23:54 <mjrosenb> ever.
17:24:10 <NateUni> Thats what I am having trouble with is what the list would look like each step of the function call… 
17:24:25 <srhb> NateUni: Half, half of half, half of half of half...
17:24:26 <NateUni> what is your version?
17:24:53 <jhance> As long as the approximation of the median is somewhat sane (I believe dividing the list into groups of 5) then the factor from split is actually not large enough to impact the overall running complexity as per masters theorem
17:25:01 <NateUni> ok.. yeah that makes more sense.. 
17:25:20 <srhb> NateUni: Try hand running it for a short list :)
17:25:47 <NateUni> I havent dealt with a lot of recursion in a while.. so my brain is getting battered in haskell as it is alllllllll recursion.. !
17:25:51 <jhance> Usually what medians do is they divide the list into 5 parts, call mergesort on those 5 parts, and then take the center of that, and its guaranteed to be a "good approximation" of the median
17:25:55 <mjrosenb> > let split (x:y:t) = let (l,r) = split t in (x:l, y:r); split x = (x,[]); mergeSort xs | (length xs <= 1) = xs | otherwise = f (mergeSort xs1)( mergeSort xs2) where (xs1, xs2) = split xs in mergeSort [1..10] :: Expr
17:25:56 <lambdabot>      Couldn't match expected type ‘Expr’ with actual type ‘[a0]’
17:25:57 <lambdabot>      In the expression: mergeSort [1 .. 10] :: Expr
17:25:57 <lambdabot>      In the expression:
17:25:57 <srhb> NateUni: It really helps if you try to just run it :)
17:25:59 <kadoban> jhance: Actually as long as it's (at least) any constant factor split, like 1/1000 would work even, it's still the same asymptotic complexity, but the constants get /much/ worse.
17:26:00 <emma> Do any of you watch Better Call Saul?
17:26:02 <srhb> I mean, on paper.
17:26:19 <jhance> kadoban: I thought there was a limit, like you can't do 2 or 3, but after around 5 its god
17:26:21 <jhance> good*
17:26:50 <kadoban> jhance: You might be thinking of introselect kind of thing, median of medians. There's a constant of 5 you have to use or the math doesn't come out right.
17:26:52 <NateUni> srhb: :p did that smarty pants
17:26:58 <kadoban> But that's kinda unrelated to this.
17:26:58 <srhb> NateUni: Okay. Sorry. :P
17:27:08 <jhance> kadoban: Thats what I'm thinking of, i thought that was what he was doing with splitting the list into "two good parts"
17:27:21 <NateUni> But I should be able to break it down in my head and know what is going on.. which is why I fronted up here
17:27:32 <srhb> Alright. I can't. :P
17:27:37 <srhb> I need to do at least a few steps.
17:27:41 <kadoban> With mergesort, you don't have to pick a pivot for partitioning or anything, you can just arbitrarily split the list into 2 parts.
17:28:02 <jhance> kadoban: Oops I don't even know what I was thinking nevermind, I guess too late for me...
17:28:16 <kadoban> No worries, it's easy to get confused between all of them, heh.
17:28:18 <jhance> <realizes he was reading quicksort this whole time>
17:28:18 <NateUni> yeah that what I thought.. isnt that quick sort.. the pivot?
17:28:31 <kadoban> Yeah, quicksort and related.
17:28:32 <NateUni> oh ok.. yep..
17:28:43 <jhance> I was thinking you were doing a variation on quicksort with better worst-case
17:28:49 <jhance> which you are obviously not
17:29:21 <NateUni> ok brb.. going to play with some code..!
17:32:17 <mjrosenb> gah, this code is not even close to as pretty as I remember it being.
17:36:41 <arkeet> :t partitionEithers . zipWith id (cycle [Left,Right])
17:36:41 <lambdabot> [b] -> ([b], [b])
17:36:49 <arkeet> > partitionEithers . zipWith id (cycle [Left,Right]) $ [1..20]
17:36:50 <lambdabot>  ([1,3,5,7,9,11,13,15,17,19],[2,4,6,8,10,12,14,16,18,20])
17:41:11 <indiagreen> > transpose . chunk 2 $ [1..20]  -- the disadvantage is that it requires the split library
17:41:12 <lambdabot>  [[1,3,5,7,9,11,13,15,17,19],[2,4,6,8,10,12,14,16,18,20]]
17:41:28 <mjrosenb> mergeSort l = mergeSort' (map (:[]) l, []) where mergeSort' ([], [l]) = l; mergeSort' (h1:h2:t, l) = mergeSort' (t, merge h1 h2 : l);  mergeSort' (x, l) = mergeSort' (x++l, []) 
17:41:31 <mjrosenb> gah.
17:41:42 <mjrosenb> there is no way that is the thing I wrote in college.
17:44:52 <mjrosenb> mergeSort [l] = l; mergeSort x = mergeSort (mergeSort' x) where mergeSort' (h1:h2:t) = merge h1 h2 : mergeSort' t; mergeSort' x = x
17:45:08 <mjrosenb> ok, that is a bit better, but it still requires an external map (:[])
17:45:44 <mjrosenb> > [1,2.3] :: Expr
17:45:46 <lambdabot>      Couldn't match expected type ‘Expr’ with actual type ‘[Double]’
17:45:46 <lambdabot>      In the expression: [1, 2.3] :: Expr
17:45:54 <mjrosenb> > [1,2,3] :: Expr
17:45:55 <lambdabot>      Couldn't match expected type ‘Expr’ with actual type ‘[Integer]’
17:45:55 <lambdabot>      In the expression: [1, 2, 3] :: Expr
17:46:04 <mjrosenb> > [a,b,c] :: Expr
17:46:05 <lambdabot>      Couldn't match expected type ‘Expr’ with actual type ‘[Expr]’
17:46:05 <lambdabot>      In the expression: [a, b, c] :: Expr
17:46:12 <shachaf> mjrosenb: Please experiment with lambdabot in /msg. :-)
17:46:22 <mjrosenb> shachaf: yeah, that was the last one.
17:46:33 <shachaf> If you have a question you should ask. The answer is that you want [Expr], not Expr.
17:46:55 <mjrosenb> shachaf: so, [Expr] is not an instance of Expr?
17:47:24 <ClaudiusMaximus> Expr is a type, not a class
17:47:27 <shachaf> Instance? Expr isn't a class.
17:47:32 <mjrosenb> oh.
17:47:40 <mjrosenb> well, that makes a bit more sense then.
17:47:59 <shachaf> 1 happens to be overloaded so that 1 :: Expr is a value.
17:48:36 <shachaf> List syntax isn't overloaded (except with a GHC extension), so if you write [a,b,c], it must have some type that unifies with [t]
17:51:04 <ClaudiusMaximus> i played with stepeval.cgi, and got a mergeSort example working - but i had to replace guards and tuple pattern bindings with if or case of
17:54:51 <mjrosenb> shachaf: right, which is where my assumption that Expr was a typeclass came into play.
17:59:14 <Gurkenglas> You can also experiment with lambdabot in #lambdabot , for the people that want to listen!
18:16:19 <mjrosenb> Is the source for Expr available?
18:17:15 <hpc> it is, i forget what package it's from
18:17:43 <shachaf> https://hackage.haskell.org/package/simple-reflect
18:19:30 <arkeet> it would be nice if it simplified arithmetic expressions.
18:19:40 <arkeet> optionally.
18:25:16 <__ryan> hi everyone how do i return a json object on my persistent query?
18:26:47 <srhb> __ryan: iirc you have a datatype that corresponds to whatever is in the database. If that is not a JSON object, you'll need to use tojson or something similar, with a matching instance.
18:28:00 <__ryan> srhb: i'm yesod framework..
18:29:14 <__ryan> srhd: what iirc means?
18:29:26 <srhb> __ryan: "If I recall correctly"
18:29:38 <srhb> __ryan: What's the type of your query result?
18:30:05 <__ryan> srhb: i'm just using the persistent query "selectList"
18:30:34 <__ryan> srhb: w/c will return an array as far as i know.
18:34:46 <mjrosenb> ok, another Reactive.Banana question: reactimate's argument is Event t (IO ()).  It would seem to be that if I want some action to depend on a behavior, then I need to convert this behavior into an event
18:34:48 <srhb> __ryan: Look at aeson, write a ToJSON instance for the return type of selectList, the run that on the result
18:34:56 <mjrosenb> which feels less than ideal.
18:39:53 <_ryan> srhb: just like this? instance ToJSON Person where
18:39:53 <_ryan>     toJSON Person {..} = object
18:39:53 <_ryan>         [ "name" .= name
18:39:53 <_ryan>         , "age"  .= age
18:39:53 <_ryan>         ]
18:40:16 <srhb> _ryan: If your result type looks like that, yes.
18:41:24 <_ryan> srhb: what if i want it dynamic.. that code maybe static right? what if i want to add another field but i don't want to touch the instance?
18:42:38 <srhb> _ryan: Perhaps have a look at Data.Aeson.TH then
18:42:56 <NateUni> Can I ask about maybe?
18:43:06 <srhb> NateUni: You can ask about anything related to Haskell :-)
18:43:16 <NateUni> Can someone give me the low down on MAybe?
18:43:22 <srhb> @src Maybe
18:43:22 <lambdabot> data Maybe a = Nothing | Just a
18:43:24 <srhb> There!
18:43:34 <NateUni> is it just like a optional in swift?
18:43:36 <srhb> Yep
18:43:53 <NateUni> How do we unrap them?
18:43:56 <srhb> Or well, it's like Optional in a lot of languages, probably Swift as well (which I know nothing about)
18:44:02 <srhb> NateUni: unwrap Justs?
18:44:08 <NateUni> Yes.
18:44:20 <srhb> unMaybe (Just x) = x; unMaybe Nothing = crashAndBurn
18:44:35 <srhb> (Obviously, don't do that)
18:44:39 <NateUni> lol.
18:44:58 <srhb> It depends on the use case. You often need to make a decision on what to do if you encounter Nothing
18:45:02 <NateUni> Where can I look at some example code on maybe.. 
18:45:09 <srhb> Sometimes, if you have a list of [Maybe a] you just want to get rid of the Nothings
18:45:16 <NateUni> yes,,,
18:45:29 <NateUni> how to test?
18:45:39 <NateUni> for the Justs?
18:45:55 <srhb> @src catMaybes
18:45:55 <lambdabot> catMaybes ls = [x | Just x <- ls]
18:46:01 <georgeleege> #haskell-in-depth
18:46:10 <srhb> > catMaybes [Just 1, Nothing, Just 4]
18:46:11 <lambdabot>  [1,4]
18:46:48 <srhb> NateUni: You can consider that a fold over the list which simply discards all the Nothings and unwraps the Justs
18:50:01 <NateUni> ok
18:55:30 <NateUni> Thanks guys
18:57:51 <bucketh3ad> I have a stupid beginner question. I have a list of values. How can I map print over the list?
18:59:02 <srhb> mapM_ print xs
18:59:09 <srhb> bucketh3ad: And it's not a stupid question :)
18:59:16 <bucketh3ad> Thanks! :)
19:00:02 <arkeet> :t mapM_
19:00:03 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
19:00:18 <arkeet> mapM_ :: (a -> IO b) -> [a] -> IO ()
19:01:41 <pharpend> I'm surprised, the new GHC is notably faster
19:02:22 <kadoban> Is it? That's cool.
19:05:10 <glguy> My experience is that 7.10.1 takes about 1.5x the time to do stuff as 7.8.4 did (which was only a little slower than 7.6.3, which was 1.5x what things were in 7.4.2)
19:11:38 <NateUni> Hi at 4:50.. on this video on Haskell: https://www.youtube.com/watch?v=qiYVyAmPoUg what does he do with the @? I dont get it?
19:12:41 <newsham> I want to use "runhaskell" to run some test programs, one of them uses an import that is ambiguous.  is there an easy way to hide the package causing ambiguity?
19:12:54 <Clint> newsham: -hide-package
19:13:21 <newsham> ty
19:14:39 <bob_twinkles> NateUni: @ lets you bind a name for the whole pattern, so if you had something like foo :: [a] -> a, you could do foo xs@(y:ys) = ... to have access to the full list and the head/tail of the list
19:15:31 <NateUni> Nope.. still confused.. sorry :(
19:15:43 <NateUni> oh wait.. 
19:15:47 <ClaudiusMaximus> > let f xs@(x:ys@(y:zs)) = (xs, x, ys, y, zs) in f "NateUni"
19:15:48 <lambdabot>  ("NateUni",'N',"ateUni",'a',"teUni")
19:15:50 <arkeet> it's just foo (y:ys) = ...
19:15:55 <arkeet> except also letting xs = y:ys
19:16:16 <teurastaja> how could i create a doubly-linked circular list?
19:16:18 <pharpend> glguy: I may be talking about cabal. (I gathered this from cabal installing some stuff)
19:16:32 <pharpend> glguy: I assumed it was ghc that was faster, but maybe cabal got better
19:16:38 <arkeet> teurastaja: how would you create a doubly linked list?
19:16:49 <NateUni> Nice ClaudiusMaximus.. thanks
19:17:12 <arkeet> non-circular
19:17:16 <teurastaja> in fact, quad-linked circular matrix of lists
19:17:53 <carter> teurastaja: use IO/STRefs
19:19:15 <NateUni> Thanks.. 
19:20:55 <teurastaja> how do i do that?
19:21:01 <carter> same way you do in C
19:21:11 <carter> or SML
19:21:13 <carter> or Java
19:21:16 <carter> or Python
19:21:19 <arkeet> should be able to do it without ST too.
19:21:26 <teurastaja> how?
19:21:30 <carter> arkeet: yeah, but then you're basically doing an explicit heap model
19:21:37 <teurastaja> with records?
19:21:39 <carter> teurastaja: how do you do it in C or jva?
19:21:47 <teurastaja> pointers
19:21:57 <teurastaja> structs
19:21:59 <carter> IORefs are mutable boxes/references
19:22:16 <carter> same as pointers for the purposes of this discussion
19:22:17 <_ryan> srhb: thank you i will check this out.. another question how to if else in haskell?
19:22:34 <carter> > if 1 > 2 then "it works" else "it doesnt"
19:22:36 <lambdabot>  "it doesnt"
19:22:42 <carter> o/ srhb 
19:23:13 <srhb> o/
19:23:35 <carter> srhb: youve done a lot of helping folks over the past few months, many thanks!
19:23:39 <kadoban> _ryan: The only thing that's really different about if/else in haskell as elsewhere is that it's an expression, not a statement. If that didn't make sense maybe ignore it though.
19:23:55 <teurastaja> where do i find documentation for that? im still learning monads but i think i could handle it
19:23:59 <srhb> carter: Oh, not that much. But thank you. :)
19:24:07 <carter> ever bit counts!
19:24:41 <ClaudiusMaximus> any way to insert MARK into .hp logs?  or merge eventlog with .hp?  there's support for eventlog in Debug.Trace, and the source comments hint at future support for other profiling methods, but i'm impatient..
19:25:12 <ClaudiusMaximus> http://hackage.haskell.org/package/base-4.8.0.0/docs/Debug-Trace.html#v:traceMarkerIO is the relevant thing, view source for more documentation
19:26:03 <_ryan> kadoban: then i want to use the if/else for checking - if my data is null else do something - how do i do that in code?
19:26:33 <arkeet> _ryan: if null x then ... else ...
19:27:08 <arkeet> (but consider pattern matching instead)
19:27:08 <kadoban> _ryan: What do you mean by null exactly?
19:28:02 <ClaudiusMaximus> @src unless
19:28:03 <lambdabot> unless p s = if p then return () else s
19:28:32 <_ryan> kadoban: this is the code - but gives me an error - images <- runDB $ selectList [ImagesFilename !=. ""] [Desc ImagesDate]
19:28:32 <_ryan>     if null images then
19:28:32 <_ryan>         return $ object []
19:28:32 <_ryan>     else
19:28:33 <_ryan>         -- do something
19:29:04 <arkeet> _ryan: you have to indent the else further
19:29:11 <HeladoDeBrownie> you actually don't
19:29:16 <arkeet> er
19:29:18 <HeladoDeBrownie> it'd be helpful to see the actual error message
19:29:41 <HeladoDeBrownie> use lpaste rather than pasting everything in the channel
19:29:44 <HeladoDeBrownie> (see the topic)
19:29:53 <arkeet> and also paste the error message together with it.
19:30:28 <HeladoDeBrownie> however if you literally have a comment after the else then that's not gonna work, you need some expression there
19:30:28 <cfoch> hi. Is there a function something like [[...], [...], [...]] in which I can apply a operator (<operator>) giving as result  [...] <operator> [...] <operator> [...]
19:30:30 <cfoch> ?
19:30:34 <_ryan> arkeet: here is the code for easy debugging -http://lpaste.net/130458
19:30:38 <HeladoDeBrownie> it could even be undefined temporarily
19:30:42 <arkeet> cfoch: that's a fold.
19:30:45 <_ryan> kadoban: heres is the code - http://lpaste.net/130458
19:31:05 <arkeet> cfoch: depending on how you want the operator to associate, use foldl' or foldr
19:31:07 <HeladoDeBrownie> _ryan, if that's literally your code then you have a syntax error; for now, put undefined after the else
19:31:19 <HeladoDeBrownie> _ryan, that's what we often do when we want to say "i'll implement this part later"
19:31:29 <HeladoDeBrownie> note that if it actually gets evaluated it will crash the program
19:31:30 <teurastaja> > ((id id) . (id id))
19:31:31 <lambdabot>      No instance for (Typeable c0)
19:31:31 <lambdabot>        arising from a use of ‘show_M823192890193311227915019’
19:31:31 <lambdabot>      In the expression:
19:31:50 <arkeet> > foldr (+) 0 [a,b,c]
19:31:51 <lambdabot>  a + (b + (c + 0))
19:31:55 <arkeet> > foldl' (+) 0 [a,b,c]
19:31:56 <lambdabot>  0 + a + b + c
19:32:24 <kadoban> _ryan: And the error message?
19:32:26 <pavonia> > foldl (+) 0 [a,b,c]
19:32:26 <ClaudiusMaximus> > foldr1 (+) [a,b,c] -- cfoch, though it will crash for empty lists, so if your operator has an identity then use what arkeet suggested
19:32:27 <lambdabot>  <no location info>: can't find file: L.hs
19:32:28 <lambdabot>  0 + a + b + c
19:32:30 <pacak> > foldl1' (+) [a,b,c]
19:32:32 <lambdabot>  a + b + c
19:32:35 <teurastaja> > id id
19:32:36 <lambdabot>      No instance for (Typeable a0)
19:32:36 <lambdabot>        arising from a use of ‘show_M904655712765399387415099’
19:32:36 <lambdabot>      In the expression:
19:32:44 <HeladoDeBrownie> teurastaja, it doesn't know how to print a function
19:32:46 <arkeet> (watch out, foldl1 and foldr1 will crash your program on an empty list.)
19:32:48 <ClaudiusMaximus> > foldr1 (+) [a,b,c]
19:32:49 <lambdabot>  a + (b + c)
19:32:57 <_ryan> i update my code everyone :-)
19:33:06 <arkeet> ok, where's the error message?
19:33:18 <cfoch> thanks.. actually I want to apply this operator to a list of this type " [GhcMonad [Name]]"
19:33:28 <teurastaja> > ((\x -> x) (\x -> x))
19:33:30 <lambdabot>      No instance for (Typeable t0)
19:33:30 <lambdabot>        arising from a use of ‘show_M370526850122742000515134’
19:33:30 <lambdabot>      In the expression:
19:33:37 <HeladoDeBrownie> teurastaja, please take it to private message
19:33:39 <arkeet> teurastaja: please experiment in private message
19:33:54 <teurastaja> why doesnt it work?
19:34:00 <pacak> teurastaja: What output you expect to get?
19:34:04 <HeladoDeBrownie> teurastaja, see my previous message
19:34:07 <arkeet> < HeladoDeBrownie> teurastaja, it doesn't know how to print a function
19:34:14 <pacak> :t id id
19:34:15 <lambdabot> a -> a
19:34:18 <teurastaja> something like **infinite recursion**
19:34:32 <arkeet> that is not the Y combinator.
19:34:35 <HeladoDeBrownie> it's not infinite recursion, it's a perfectly well formed value, but it's a function
19:34:37 <pacak> > "**infinite recursion**"
19:34:38 <lambdabot>  "**infinite recursion**"
19:34:43 <pacak> teurastaja: Here you go
19:35:13 <teurastaja> ok how do you define it in haskell?
19:35:27 <HeladoDeBrownie> teurastaja, you don't
19:35:33 <HeladoDeBrownie> it's ill-typed afair
19:35:39 <glguy> You use a newtype
19:35:45 <arkeet> if you try the one from untyped lambda calculus (\x -> x x) (\x -> x x)
19:35:45 <dfeuer> Hello, persons.
19:35:47 <arkeet> it won't typecheck
19:35:52 <arkeet> but you can work around it with a newtype
19:35:56 <cfoch> Hello, persona
19:36:02 <solatis> this might sound like a very stupid question, but what exactly is Data.Fixed ? what is an appropriate use case to use it ?
19:36:14 <_ryan> kadoban: here is the error - Ambiguous occurrence null
19:36:17 <teurastaja> arkeet: thats what i was trying to do
19:36:19 <solatis> a library i'm using (network-bitcoin) uses Data.Fixed to represent BTC
19:36:26 <arkeet> solatis: fixed point arithmetic
19:36:48 <HeladoDeBrownie> teurastaja, by the way, are you aware of this?
19:36:50 <HeladoDeBrownie> @type fix
19:36:51 <lambdabot> (a -> a) -> a
19:36:54 <HeladoDeBrownie> @src fix
19:36:54 <lambdabot> fix f = let x = f x in x
19:37:05 <glguy> solarus: You use fixed point arithmetic so that you don't get any unexpected rounding when dealing with currency
19:37:20 <solatis> glguy, i understand
19:37:28 <pacak> > fix (+1) 1
19:37:31 <lambdabot>      Could not deduce (Num a0)
19:37:31 <lambdabot>      from the context (Num a, Num (a -> t))
19:37:31 <lambdabot>        bound by the inferred type for ‘e_111’: (Num a, Num (a -> t)) => t
19:37:37 <pacak> > fix (+1) (1 :: Int)
19:37:37 <solatis> is fix related to Data.Fix ?
19:37:39 <lambdabot>      No instance for (Show a0)
19:37:39 <lambdabot>        arising from a use of ‘show_M103993436648669217215226’
19:37:39 <lambdabot>      The type variable ‘a0’ is ambiguous
19:37:41 <arkeet> solatis: no
19:37:46 <kadoban> _ryan: There's probably more to the error. But I think that means that something you're importing exports a 'null', which is different from the Prelude one.
19:37:51 <solatis> i figured that
19:37:53 <dfeuer> Oh, different sense of fixed point.
19:37:54 <arkeet> err
19:37:55 <dfeuer> Hah.
19:37:56 <arkeet> :t fix
19:37:57 <lambdabot> (a -> a) -> a
19:37:58 <arkeet> this one sort of is.
19:38:05 <glguy> solarus: fixed vs floating
19:38:07 <dfeuer> Fixed precision, more like.
19:38:10 <kadoban> _ryan: It should tell you which one and such.
19:38:13 <dfeuer> Or whatever.
19:38:15 <glguy> http://en.wikipedia.org/wiki/Fixed-point_arithmetic
19:38:16 <solatis> right
19:38:58 <arkeet> with floating point arithmetic you can have annoying things like a + b == a + c even when b /= c.
19:39:08 <teurastaja> im confused
19:39:24 <arkeet> fixed point arithmetic doesn't have that problem
19:39:29 <HeladoDeBrownie> teurastaja, ask about what's confusing you
19:39:44 <teurastaja> whats fix?
19:39:55 <HeladoDeBrownie> teurastaja, it's a fixpoint combinator
19:40:09 <teurastaja> and they were talking about...?
19:40:11 <arkeet> so compared to floating point, fixed point gets you consistent precision across the entire range
19:40:16 <arkeet> but you lose some range
19:40:21 <HeladoDeBrownie> teurastaja, something unrelated, fixed-point arithmetic.
19:40:21 <solatis> arkeet, i understand, so currency is one area where you definitely want to have fixed point
19:40:27 <arkeet> mhm\
19:40:42 <teurastaja> ah... makes sense now
19:40:47 <_ryan> kadoban: i remove the text in th [] and it works but how should i put it back without an error. i will update the code
19:41:04 <solatis> i'm used to representing currency as an Integer and using the smallest unit of payment possible, but i guess this is a bit nicer
19:41:21 <teurastaja> so how does fix not fail??
19:41:26 <teurastaja> *?
19:41:28 <HeladoDeBrownie> teurastaja, lazy evaluation! :)
19:41:31 <HeladoDeBrownie> non-strict*
19:41:38 <teurastaja> oh
19:41:42 <HeladoDeBrownie> > fix (1 :)
19:41:43 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:41:44 <arkeet> fix f = f (fix f)
19:42:09 <HeladoDeBrownie> generally you use data constructors to make fix productive, and that way you can get infinite data structures out of it
19:42:11 <pacak> turtles all the way down!
19:42:11 <arkeet> fix can be used to implement arbitrary recursion.
19:42:11 <teurastaja> why is the output in a list?
19:42:12 <HeladoDeBrownie> or even finite ones
19:42:19 <kadoban> _ryan: Maybe post the entire error, because I don't know what any of that is and don't really feel like looking it all up.
19:42:24 <HeladoDeBrownie> teurastaja, because (:) is a list constructor
19:42:26 <arkeet> > fix (\f n -> if n == 0 then 1 else f (n-1)) 5
19:42:30 <lambdabot>  1
19:42:39 <arkeet> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 5
19:42:40 <lambdabot>  120
19:42:43 <arkeet> note that the argument to fix is a non-recursive function.
19:43:18 <arkeet> _ryan: please include any error message with your paste
19:43:22 <arkeet> below the code, say
19:43:24 <arkeet> it really helps
19:43:48 <_ryan> kadoban: i pasted the whole code - http://lpaste.net/130458
19:44:10 <arkeet> no one's asking for more code.
19:44:31 <cfoch> is there something like foldl but without the third parameter?
19:44:31 <_ryan> arkeet: kadoban ask it.. :-)
19:44:38 <HeladoDeBrownie> _ryan, you said there was an error message, right? include it with the code so we know what you're seeing
19:44:40 <kadoban> _ryan: I really didn't.
19:44:53 <teurastaja> @src fix
19:44:53 <lambdabot> fix f = let x = f x in x
19:45:08 <teurastaja> interesting
19:45:17 <_ryan> kadoban: sorry i thought the code  sorry :-) pasting error..
19:45:23 <kadoban> No worries
19:46:45 <johnw> cfoch: what do you mean?  without the list you're folding over?
19:46:49 <_ryan> kadoban: i pasted the error - http://lpaste.net/130458
19:47:02 <pharpend> I'm getting the weirdest error in ghci: http://lpaste.net/130467
19:47:19 <cfoch> johnw: sorry, without the second parameter
19:47:27 <kadoban> _ryan: Just FYI … that doesn't say anything about null being ambiguous :-/
19:47:32 <johnw> ah I think you're probably referring to foldl1
19:47:33 <Gurkenglas> :t foldl1 --cfoch
19:47:34 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
19:48:11 <cfoch> thanks
19:48:14 <pharpend> Here's the file containing mkProject http://lpaste.net/130469
19:48:29 <cfoch> foldl1 was what I was looking for
19:48:39 <pharpend> and prettyEncode: http://lpaste.net/130470
19:49:01 <kadoban> _ryan: Okay so the first one. You have to specify the type of … the  "data" .= "value"  part I believe. It doesn't know what that's supposed to be, it gives you some possible things, and doesn't know which one to choose.
19:49:22 <teurastaja> > fix fix
19:49:23 <_ryan> kadoban: the error talk about something in this code ["data" .= "value"]  - the null error is resolve. 
19:49:24 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ a -> a
19:49:24 <lambdabot>      Expected type: a -> a
19:49:24 <lambdabot>        Actual type: (a -> a) -> a
19:49:35 <teurastaja> aha!
19:50:09 <kadoban> _ryan: Err, I don't understand the second error exactly, it may be fixed when you fix the first.
19:51:54 <_ryan> kadoban: thank you i will try to figure it out. :-)
19:52:19 <kadoban> _ryan: Try fixing the first thing and see. If you give a type annotation to the thing I mentioned, that should help.
19:55:27 <teurastaja> what is the longest and most cryptic error message you have seen in ghc?
19:55:51 <kadoban> GHC error messages are all pretty long, but they don't tend to be all that cryptic.
19:56:15 <HeladoDeBrownie> "cryptic" is relative
19:56:22 <teurastaja> i mean for non geeks :P
19:56:57 <HeladoDeBrownie> probably the most cryptic i've seen has been because i would've had to chase several type synonyms to understand the error
19:57:01 <HeladoDeBrownie> (this was in lens)
19:57:08 <kadoban> Well, anything is going to be cryptic if you don't understand the language.
19:57:16 <teurastaja> can you replicate it?
19:57:21 <HeladoDeBrownie> (i do not admit to be proficient at lens)
19:57:45 <HeladoDeBrownie> not off the top of my head
19:58:28 <teurastaja> anything else i could reproduce then?
19:58:29 <HeladoDeBrownie> one i do remember from recently was when i wrote Lens' instead of Traversal' and it complained that it couldn't infer Applicative
19:58:44 <kadoban> teurastaja: What's the goal exactly?
19:59:24 <teurastaja> probably putting that message on my screensaver of something lol
19:59:25 <Gurkenglas> https://hackage.haskell.org/package/void-0.6/docs/src/Data-Void.html#Void <- "instance Eq Void where;  _ == _ = True" <- Shouldn't this be "instance Eq Void where;  (==) = absurd"?
19:59:45 <HeladoDeBrownie> Gurkenglas, that doesn't type does it?
20:00:08 <Gurkenglas> Why wouldn't it? (Void -> a) matches (Void -> (Void -> Bool)).
20:00:11 <HeladoDeBrownie> Gurkenglas, oh, i suppose it does.
20:00:41 <kadoban> teurastaja: Haha. I'll let you know if I run accross one that's good. Only thing that comes to mind is monomorphism restriction, everyone likes* that one.
20:00:43 <HeladoDeBrownie> Gurkenglas, either way, i don't think it's violating any laws the way it is; i think we tend to ignore bottom, and there is nothing *but* bottom
20:01:13 <NateUni> Hi guys why do I need the Ord => a on the MergeSort and split? On this: http://tinypic.com/r/e6f2nk/8
20:01:13 <HeladoDeBrownie> Gurkenglas, if you get to the point of evaluating (==) applied to Void, there is clearly something else going on that's not quite right :P
20:01:27 <NateUni> As the only comparission is happening in merge.. !?
20:01:45 <HeladoDeBrownie> NateUni, can you use lpaste or something else? that doesn't seem to show (for me at least)
20:02:00 <NateUni> THey said dont past mutiple lines
20:02:05 <teurastaja> kadoban: how do you trigger it?
20:02:10 <HeladoDeBrownie> NateUni, in the channel. that's what lpaste is for
20:02:11 <NateUni> it is about 3 functions.. 
20:02:16 <NateUni> ops ok.. 
20:02:17 <glguy> NateUni: You can paste to http://lpaste.net/new/haskell
20:02:44 <NateUni> it says it is down
20:02:51 <NateUni> Sorry,, 
20:03:06 <HeladoDeBrownie> it's up for me
20:03:06 <NateUni> ok back now
20:03:23 <kadoban> teurastaja: I'm not really sure, heh. I don't run into it much, I remember it from when I was pretty new though.
20:03:54 <NateUni> http://lpaste.net/130473
20:03:58 <NateUni> There we go.. 
20:04:08 <HeladoDeBrownie> NateUni: (<=)
20:04:25 <NateUni> ops..
20:04:26 <HeladoDeBrownie> @type (<=)
20:04:27 <lambdabot> Ord a => a -> a -> Bool
20:05:01 <NateUni> on split I dont need it write.. 
20:05:03 <NateUni> *right
20:05:14 <HeladoDeBrownie> not on split, right
20:05:26 <NateUni> Ok just wondering why it was there…. Thanks. 
20:06:08 <Gurkenglas> @letlpaste 130474
20:06:10 <lambdabot>  Defined.
20:06:18 <NateUni> I will take my laptop to my lecture next time.. you guys sure come in handy, with confusing stuff
20:06:30 <Gurkenglas> Oh, I thought it wouldn't work, but this instantiation of lambdabot allows it. soz.
20:16:07 <ClaudiusMaximus> teurastaja: simple monomorphism restriction error is triggered by a top level "eq = (==)" or similar (note: no type signature), ghc-7.6 tells you "probable cause, monomorphism restriction" but this helpfulness seems to have been removed in 7.8
20:24:25 <faux___> i'm trying to debug a haskell program using ghci. i have set a breakpoint and am trying to use :print on bindings. However, :print always returns 'binding = (_t#::Type)', where # is some number and Type is some type. Is there a way I can get more information from GHCi?
20:26:26 <geekosaur> that is something that is unevaluated as yet. if you want to force evaluation, use :force instead
20:27:14 <faux___> geekosaur: thank yo
20:27:16 <faux___> you*
20:32:25 <NateUni> Property.. guys whats the deal?
20:32:44 <NateUni> I am looking at an example with a ==> and the return type is property.. 
20:32:57 <HeladoDeBrownie> NateUni, those sound like they're from some library. more details?
20:33:06 <HeladoDeBrownie> i'm guessing quickcheck, though i've never used it
20:33:10 <NateUni> yes
20:33:20 <NateUni> it tried :l Property
20:33:23 <NateUni> *i
20:33:34 <HeladoDeBrownie> @hackage quickcheck
20:33:35 <lambdabot> http://hackage.haskell.org/package/quickcheck
20:33:40 <HeladoDeBrownie> woops
20:33:49 <NateUni> ok.. brb
20:33:51 <HeladoDeBrownie> @hackage QuickCheck
20:33:51 <lambdabot> http://hackage.haskell.org/package/QuickCheck
20:34:19 <HeladoDeBrownie> usually a good idea to have docs on hand. if you have a specific question some in here might be able to help you too
20:34:20 <OutlawStar> can anyone point me toward a codebase with a good monad example?
20:34:40 <HeladoDeBrownie> OutlawStar, your question leaves me unclear what you want an example of exactly
20:34:49 <OutlawStar> a state monad 
20:34:52 <OutlawStar> implementation
20:35:11 <OutlawStar> I just having trouble understanding how they full work
20:35:13 <HeladoDeBrownie> i would have said mtl but that does something slightly more complex than just that
20:35:24 <HeladoDeBrownie> but, so, you want to understand the Monad instance for State?
20:35:31 <OutlawStar> yes
20:35:38 <HeladoDeBrownie> okay well, do you know how State is implemented?
20:36:07 <OutlawStar> i'm reading about in the "real world haskell" book. Thats about as far as my knowledge goes
20:36:10 <HeladoDeBrownie> newtype State s a = State { runState :: s -> (a, s) } -- here's one way
20:36:12 <OutlawStar> what would you recommend?
20:36:29 <HeladoDeBrownie> i can step you through it if you want. if you wanna do that let's go to #haskell-overflow
20:36:47 <OutlawStar> ok thx
20:38:18 <fumieval> hxt is such chaotic...
20:40:48 <randir> How can I search for a function or string within a hackage package?
20:40:57 <randir> For example, I want to find "spawnEvent" in https://hackage.haskell.org/package/uni-htk
20:41:00 <HeladoDeBrownie> randir, check the index
20:41:31 <geekosaur> @where hayoo
20:41:32 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
20:41:33 <randir> The index seems to give module level, not function level, documentation?
20:43:28 <randir> geekosaur: hayoo looks nice!
20:43:29 <randir> thanks
20:50:33 <R0b0t1> Is looking at the source of Hugs still relevant?
20:56:15 <markmc_att> irc://irc.freenode.com/#scons
20:56:59 <slack1256> R0b0t1: I would say so. porting interpreters is much more easy than porting compilers
21:00:23 <R0b0t1> slack1256: hmm, guess that is true
21:00:49 <R0b0t1> I started looking at it because the only material I could find talking about making an interpreter/compiler for haskell assumed you started in haskell
21:00:52 * R0b0t1 shrugs
21:02:46 <slack1256> I don't understand the last part of what you said "assumed you started in haskell" as in making an interpreter/compiler for other language that isn't haskell?
21:15:29 <R0b0t1> slack1256, sorry, I meant making a inter/compiler for haskell in a language besides haskell
21:15:48 <R0b0t1> the opposite of self-hosting
21:17:45 <kadoban> I would imagine that most people deep enough into haskell to write a compiler for it aren't going to want to do it in another language, heh.
21:22:31 <homovitruvius> if possible in a sentence, what can fixplate do that uniplate/biplate cannot?
21:24:01 <emma> Do any of you watch Better Call Saul?
21:24:16 <kadoban> Ya
21:25:38 <R0b0t1> kadoban: true, but the language is pretty different from the machine it is running on
21:25:46 <R0b0t1> what I'm interested in would have had to have happened somewhere
21:28:47 <ClaudiusMaximus> how do you install old ghc versions? seems ghc-7.2.2 won't compile with ghc-7.4.2
21:30:10 <erikd> ClaudiusMaximus: that's true for any ghc N and M where N < M. later ghc does not compiler earlier.
21:31:46 <pharpend> Is anyone else getting errors like these: http://ix.io/hMC ?
21:32:39 <johnw> homovitruvius: uniplate for fixed-point types
21:32:49 <pharpend> It happens basically whenever I run mkProject
21:33:05 <erikd> pharpend: do you have libncurses installed?
21:33:08 <arkeet> pharpend: sounds like you need to install ncurses
21:33:43 <pharpend> core/ncurses 5.9-7 [installed]
21:33:45 <pharpend>     System V Release 4.0 curses emulation library
21:33:55 <arkeet> what distro?
21:34:23 <erikd> pharpend: ncursesw (the wide char version)
21:34:37 <pharpend> arkeet: arch linux
21:35:20 <pharpend> erikd: that appears to only be for Ruby
21:35:37 <arkeet> pharpend: so, does that file exist?
21:35:41 <arkeet> /usr/lib/libncurses.so
21:35:52 <erikd> on debian there are separate libncurses5 and libncursesw5
21:35:57 <arkeet> because it should, according to https://www.archlinux.org/packages/core/x86_64/ncurses/files/
21:36:07 <pharpend> arkeet: /usr/lib/libncurses.so: ASCII text
21:36:13 <erikd> arkeet: there's a w on the end of the name
21:36:35 <arkeet> erikd: but it's looking for libncurses.so
21:36:36 <pharpend> arkeet: I have libncursesw
21:36:39 <erikd> can't load .so/.DLL for: /usr/lib/gcc/x86_64-unknown-linux-gnu/4.9.2/../../../../lib/libncurses.so (-lncursesw: cannot open shared object file: No such file or directory)
21:36:48 <pharpend> erikd: http://ix.io/hME
21:36:52 <arkeet> but either way pharpend should have both
21:37:13 <arkeet> hum
21:37:13 <pharpend> arkeet: that's the output of ls /usr/lib/libncurses*
21:37:52 <arkeet> I'm out of ideas
21:38:07 <pharpend> I asked in #archlinux, but it inevitably devolved into a discussion about anal sex
21:38:55 * pharpend should probably switch back to debian one of these days
21:39:07 <erikd> pharpend: sounds like a plan to me :-)
21:39:43 <erikd> i've never seen what you describe on #archlinux on any of the debian channels
21:40:07 <pharpend> I have a debian virtual machine, starting it up
21:44:07 <Gurkenglas> Is it inefficient to apply a long series of small changes to a large data structure?
21:44:21 <arkeet> depends on the data structure.
21:44:52 <arkeet> do you have something specific in mind?
21:45:01 <Gurkenglas> not quite
21:45:05 <Gurkenglas> Let's say a record with n entries, and each series changes a different entry
21:45:16 <Gurkenglas> ("attributes"?)
21:45:27 <arkeet> fields?
21:45:27 <Gurkenglas> -series+change
21:45:52 <Gurkenglas> Yes, fields.
21:46:31 <arkeet> probably fine.
21:46:34 <arkeet> (benchmark it!)
21:48:01 <pharpend> erikd: well my debian vm is terribly broken, so I'll have to go to VM
21:48:07 <pharpend> erikd: ack, go to FreeBSD.
21:48:17 <pharpend> I forgot I broke my Debian vm
21:56:44 <Gurkenglas> I have the feeling laziness is going to hide all the inefficiencies from my attempts to benchmark until I try to code a big project
21:59:12 <jle`> Gurkenglas: you can try simulating the sort of things you would meaningingly want to do with your data structure.
21:59:20 <jle`> (remember to use strict fields if it's just a fancy tuple)
21:59:26 <jle`> also, it might not even be a bottleneck
21:59:31 <jle`> so it might not even be worth worrying about
22:00:00 <jle`> it might cost you a millisecond of runtime every few hours for example
22:08:52 <mniip> is there any place I could quickly check the monad laws for the return-join definition
22:15:43 <jle`> those laws are actually the ones that are on wikipedia
22:16:09 <jle`> of the several possible statements, it has precisely those :)
22:45:43 * hackagebot sbv 4.3 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-4.3 (LeventErkok)
22:59:02 <ChaseC_> Anyone here use the sdl2 package?
23:02:27 <pavonia> Anyone probably does
23:02:47 <ClaudiusMaximus> erikd: thanks for info - seems ghc-6.4.3 bindist is installable on debian wheezy amd64 with a libgmp package from squeeze, but wheezy perl is too new (removed $* for regex matching control), currently compiling perl-5.8 in the hope that i can get it to work...
23:03:22 <erikd> ClaudiusMaximus: why do you need 7.2? my oldest ghc is 7.4.2.
23:03:41 <ChaseC_> Well it hasn't been working correctly for me since the 7.10 update.
23:03:49 <ClaudiusMaximus> erikd: just doing some research (out of curiosity)
23:04:03 <ChaseC_> I was wondering if other people were having problems, too
23:04:04 <erikd> fair enough
23:04:12 <erikd> ClaudiusMaximus: fair enough
23:05:34 <pavonia> ChaseC_: What's the issue exactly?
23:07:11 <ChaseC_> Nothing renders at all - even in the simplest examples
23:07:33 <ChaseC_> But the delay function still works properly
23:07:52 <ChaseC_> I'll post an imgur link to what it looks like
23:08:16 <arkeet> maybe post your code too
23:08:32 <pacak> ChaseC_: Did you tried switching it off and then back on again?
23:09:00 <ChaseC_> Yeah, I reinstalled all the packages
23:09:22 <arkeet> changing ghc versions shouldn't affect it.
23:09:28 <erikd> thats the moral equivalent of turning off and on again
23:10:06 <ChaseC_> http://i.imgur.com/powrCnz.jpg
23:10:13 <ChaseC_> That includes the code as well
23:10:23 <ChaseC_> You can ignore the OpenGL stuff, it isn't being used
23:10:43 <pacak> ChaseC_: Any sdl non-haskell examples? Just to make sure sdl works fine on your machine?
23:11:34 <ChaseC_> I'll download an example and get back to you in a minute
23:13:48 <arkeet> don't you need to call SDL_UpdateWindowSurface
23:14:23 <arkeet> ChaseC_: 
23:15:55 <ChaseC_> Well, adding the updateWindowSurface fixed it
23:15:59 <ChaseC_> Thanks
23:16:13 <arkeet> else it'll just draw stuff to the back buffer and never show it on screen.
23:16:54 <ChaseC_> Now I need to figure out why the OpenGL surface was having the same problem.
23:17:00 <ChaseC_> I'll ask if I have any problems with that
23:17:11 <arkeet> not showing on screne?
23:17:17 <arkeet> screen.
23:17:46 <ChaseC_> Yeah, I started with using OpenGL. It's the commented out stuff in the code I posted
23:17:55 <ChaseC_> It was having the exact same issue
23:18:04 <arkeet> try something simple like clearing to some non-black colour
23:18:30 <arkeet> and don't forget to glSwapWindow
23:23:37 <ChaseC_> Yeah, I don't know what's going on with the OpenGL version
23:23:45 <ChaseC_> Here's the code if you want to check it out
23:23:45 <ChaseC_> http://pastebin.com/YcNX1CCw
23:24:31 <ChaseC_> Before the ghc update though, I had a much more complex scene being rendered just fine
23:27:07 <ChaseC_> arkeet:
23:27:41 <arkeet> ChaseC_: well, you commented out all the drawing code.
23:28:00 <arkeet> do you see a white screen?
23:28:32 <ChaseC_> Nope, it's transparent
23:28:44 <arkeet> shouldn't glFlush come before swapwindow?
23:28:48 <ChaseC_> Or at least it displays whatever was begin it at first
23:29:03 <ChaseC_> behind
23:29:15 <arkeet> hm
23:29:20 <ChaseC_> Same problem
23:29:31 <ChaseC_> I'm pretty sure the glFlush is unnecessary anyway
23:30:03 <arkeet> no idea then
23:30:23 <ChaseC_> Well, thanks for the help
23:33:27 <idnar> @hoogle (a -> Bool) -> a -> Maybe a
23:33:29 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
23:33:29 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
23:33:29 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
23:34:22 <idnar> hrm, wait
23:34:46 <idnar> I actually want Bool -> a -> Maybe a which is a bit of a weird type
23:36:16 <idnar> hah, but it exists, http://hackage.haskell.org/package/utility-ht-0.0.10/docs/Data-Maybe-HT.html
23:36:48 <idnar> or http://hackage.haskell.org/package/data-easy-0.5/docs/Data-Easy.html#v:ifToMaybe
23:45:45 * hackagebot filediff 0.1.0.5 - Diffing and patching module  http://hackage.haskell.org/package/filediff-0.1.0.5 (bgwines)
23:55:46 * hackagebot equivalence 0.3.1 - Maintaining an equivalence relation implemented as union-find using STT.  http://hackage.haskell.org/package/equivalence-0.3.1 (PatrickBahr)
23:57:25 <srid> i was asking this earlier, but any clues as to this GHC error? https://gist.github.com/srid/9830609acba3dd752b71
23:57:38 <srid>  Couldn't match type ‘a’ with ‘[a]’ … ‘a’ is a rigid type variable bound by
