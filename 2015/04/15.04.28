00:00:31 <jle`> newtype MultiSet a = MS (Map a Int)
00:00:35 <jle`> cute :)
00:01:27 <Cale> A little silly that it would use Int rather than Integer
00:01:48 <Cale> But otherwise, the library looks good
00:02:07 <jle`> are you one of those people who prefers length :: [a] -> Integer ?
00:02:12 <Cale> yes
00:02:13 <jle`> ;0
00:02:16 <jle`> ;)
00:02:25 <Cale> But in this case, there's even more reason for that
00:03:17 <jle`> yeah, i do agree
00:03:23 <Cale> Like, there's an argument if you forget that lists can be lazily constructed that you don't have to worry about overflow because there can't possibly be more elements than there are addresses (expecting Int size to match pointer size)
00:04:54 <Cale> But here we're just operating on counts abstractly, so there's not even that argument for it.
00:05:46 <arkeet> > maxBound :: Int
00:05:48 <lambdabot>  9223372036854775807
00:06:10 <Cale> Yeah, on a 64 bit machine, maxBound is also reasonably large and hard to count to.
00:06:27 <kadoban> arkeet: Int is 32 bit sometimes, which is … not hard at all to count to.
00:06:28 <Cale> (on a 32 bit machine, you can definitely count to it)
00:06:35 <arkeet> yeah
00:06:55 <nak> > maxBound
00:06:57 <lambdabot>  ()
00:06:58 <Cale> and I think the Report even allows Int to be as small as 30 bits.
00:07:17 <nak> arkeet interesting... i'm still learning this ":: Foo" thing you're doing
00:07:19 <arkeet> something like it must contain [-2^29 .. 2^29-1]
00:07:27 <nak> that seems to tell haskell to return a specific type of value
00:07:33 <jle`> nak: maxBound is polymorphic, it infers the type you are talking about using type inference.  but when you use it alone, Haskell assumes it's of type ()
00:07:35 <arkeet> nak: maxBound is polymorphic, so I'm specifying the type.
00:07:37 <arkeet> :t maxBound
00:07:38 <lambdabot> Bounded a => a
00:07:38 <Cale> nak: Yeah, it's a type annotation
00:07:39 <jle`> yeah, it's called a type signature :)
00:07:42 <jle`> er, type annotation
00:07:55 <arkeet> Int and () (and many other things) are Bounded.
00:08:05 <arkeet> lambdabot (and ghci) will by default pick ()
00:08:07 <jle`> > [True, maxBound]
00:08:08 <lambdabot>  [True,True]
00:08:11 <kadoban> () is /very/ bounded XD
00:08:15 <nak> so maxBound has multiple ... "definitinos" ?
00:08:17 <jle`> > [1 :: Int, maxBound]
00:08:18 <lambdabot>  [1,9223372036854775807]
00:08:19 <arkeet> yes
00:08:25 <arkeet> one for each instance of the Bounded class
00:08:27 <kadoban> nak: instances, yeah
00:08:30 <nak> how would you call that? i'm sure i'm using the wrong words
00:08:33 <jle`> you'll learn about typeclasses eventually :)
00:08:36 <nak> ok so maxBound has more than one "instance"
00:08:49 <Cale> Whenever you have an expression, you can insist that it has a particular type. The Haskell compiler will check that the expression you wrote can actually have that type, and if it had a more polymorphic type, then its type will be restricted. This is important in cases where the type is ambiguous.
00:08:54 <nak> and by calling `maxBound :: Int` we help it know which one to call
00:09:00 <arkeet> > maxBound :: Integer
00:09:01 <lambdabot>      No instance for (Bounded Integer) arising from a use of ‘maxBound’
00:09:02 <lambdabot>      In the expression: maxBound :: Integer
00:09:04 <Cale> nak: maxBound is a method of the Bounded type class
00:09:07 <kadoban> nak: More Bounded has more than one instance.
00:09:19 <Cale> class Bounded a where
00:09:23 <kadoban> nak: And you're … not really calling it, you're evaluating it.
00:09:24 <Cale>   maxBound, minBound :: a
00:09:26 <nak> ok i gotta learn type classes
00:09:41 <nak> because these are like *zoom*, right over my head
00:09:44 <nak> i've never worked in a typed lang
00:09:50 <nak> so i suppose that is part of the problem i'm having too
00:09:57 <arkeet> never written C++ or java or anything?
00:10:04 <nak> like 15 years ago
00:10:05 <nak> in highschool
00:10:09 <Cale> nak: Okay, so a good motivating example for type classes is the function to sort a list.
00:10:29 <Cale> nak: We'd like to be able to write a sorting algorithm once, and use it on many different types of list
00:10:41 <Cale> nak: But  sort :: [a] -> [a]  doesn't quite work
00:10:45 <nak> you mean on a list of chars, a list of ints, a list of ... etc, right 
00:10:48 <arkeet> yep
00:10:49 <Cale> yeah
00:11:23 <Cale> If you don't know anything at all about the type of elements of the list, you have no idea if it's something which can be compared with inequality tests like (<) that the sorting algorithm needs.
00:12:00 <Cale> So, Haskell has a way of restricting the types that type variables range over
00:12:02 <Cale> :t sort
00:12:03 <lambdabot> Ord a => [a] -> [a]
00:12:31 <Cale> Here, the class constraint "Ord a" says that whichever type a is, it must be a type for which there is an instance of the type class Ord
00:13:03 <Cale> Ord is a class which defines the operations like (<), (>=), some other comparisons, and it's a subclass of Eq which defines the equality tests (==) and (/=)
00:13:05 <nak> I assume we can define what Ord is
00:13:10 <Cale> yeah
00:13:40 <nak> using the word "class" here, we're not talking at all about a "class" like in OOP, right ?
00:13:46 <arkeet> indeed
00:13:47 <Cale> Right, we're not
00:13:48 <nak> i assume completely different concept
00:13:48 <nak> ok
00:14:06 <nak> ok Cale, I follow you so far
00:14:07 <arkeet> (the closest thing in OOP is probably an interface)
00:14:20 <Cale> Similar terminology simply because we're talking about collections of things supporting certain operations, and so similar words apply
00:14:20 <kadoban> Yeah, they're a decent amount like interfaces in some languages
00:14:47 <lpaste> Cale pasted “definition of Eq and Ord” at http://lpaste.net/131613
00:14:58 <Cale> ^^ there's the definition of the Eq and Ord classes from the Prelude
00:15:23 <arkeet> min and max are class methods now? 
00:15:40 <Cale> That's actually from the Haskell 98 report.
00:15:52 <arkeet> oh it's not new
00:16:10 <arkeet> for some reason I thought they were separate.
00:16:34 <nak> ok so this paste is not from ghci or something. this is a snippet from the 98 report?
00:16:51 <Cale> yeah, this code is in the Prelude (maybe slightly modified, I don't recall)
00:17:13 <nak> ok
00:17:14 <Cale> If you want, I can get you the real code, hang on :)
00:17:20 <nak> "in the Prelude" means ?
00:17:29 <sveit> in some of my recent code, I have found it extremely useful to have a typeclass "Subset a b" that provides functions a -> b and b -> Maybe a . Looking online this seems like something similar to what people call "Iso" or "Isomorphism", but i don't see much written about it and it doesn't seem to be widely used. Is there some corner case or flaw I am overlooking in using a typeclass like this? does something already exist that makes this
00:17:29 <sveit> obselete? also, why do some people define the type "Iso a b" that contains the functions as opposed to using the typeclass? is there some advantage? sorry for the wall of text.
00:17:32 <arkeet> Prelude is the module that's always imported by default.
00:17:32 <Cale> Prelude is the module which is always loaded by default
00:17:36 <nak> so far my brain associates "Prelude" == GHCi
00:17:44 <nak> oh
00:17:49 <nak> haha very different things
00:18:03 <arkeet> so anything you can use without importing anything explicitly is in the Prelude.
00:18:19 <nak> got it 
00:18:26 <Cale> https://downloads.haskell.org/~ghc/7.8.4/docs/html/libraries/ghc-prim-0.3.1.0/src/GHC-Classes.html#Eq
00:18:32 <nak> so I can think of Prelude as "Core" functionality
00:18:40 <Cale> That's from 7.8.4 since the 7.10.1 source links are broken :P
00:18:41 <arkeet> you could
00:18:48 <arkeet> although it's not really essential
00:19:16 <arkeet> a lot of stuff in it can be implemented from scratch, and there are some alternative preludes floating arround
00:19:21 <arkeet> around
00:19:44 <nak> interesting
00:19:46 <iaoel> sveit: That's more like a prism https://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html
00:19:46 <iaoel> * than `f :: Set b -> [a] -> b`? i.e. one that suggest that `f` be defined fo
00:19:56 <nak> what's with all the derived instances of Eq
00:20:02 <nak> Eq a .. Eq o, etc
00:20:17 <Cale> nak: You're probably looking at the instances for tuples
00:20:19 <xelxebar> are those the dictionary orders on tuples?
00:20:21 <arkeet> well, someone had to write an instance for equality of 15-tuples.
00:20:29 <nak> lol
00:20:34 <Cale> For Eq and Ord and a handful of other classes GHC knows how to write some instances automatically.
00:20:35 <arkeet> actually they're derived
00:20:46 <Cale> xelxebar: yes
00:20:48 <nak> ok so you can only test equality of a tuple <= 15 elements?
00:20:53 <Cale> yeah
00:20:56 <arkeet> yeah heh
00:21:02 <Cale> In fact, that's kind of overkill
00:21:05 <nak> weird, but i suppose that's fine
00:21:06 <iaoel> sveit: (ignore that second line)
00:21:06 <arkeet> but such large tuples are very rarely used
00:21:07 <xelxebar> *only*
00:21:12 <Cale> You never use tuples with more than about 3 elements anyway
00:21:13 <nak> i know a tuple that long would be kind of obscene
00:21:17 <nak> yeah
00:21:22 <nak> time to refactor
00:21:23 <nak> lol
00:21:30 <arkeet> I see 3-tuples sometimes, but anything bigger is extremely rare
00:21:35 * nak nods
00:21:42 <nak> ok
00:22:01 <pacak> arkeet: Mwahahahahaha
00:22:04 <Cale> But an interesting instance there is the one for lists
00:22:04 <arkeet> (if you want to throw a bunch of things together in a big structure, usually you define your own data type for that)
00:22:19 <Cale> instance (Eq a) => Eq [a] where
00:22:20 <Cale>     []     == []     = True
00:22:20 <Cale>     (x:xs) == (y:ys) = x == y && xs == ys
00:22:20 <Cale>     _xs    == _ys    = False
00:22:32 <Cale> This says that if a is an instance of Eq, then so is [a]
00:22:35 <arkeet> (that one could also be derived though)
00:22:39 <Cale> yeah
00:22:55 <sveit> iaoel: so prisms are a good way to encapsulate something like (for example) the relationship between tuples of two elements and two-element lists?
00:23:08 <xelxebar> don't want to derail the pedagogy at the moment, but I'd really like to know how 'deriving' works once there's a lull
00:23:10 <Cale> That's actually what the derived instance would be anyway
00:23:12 <sveit> i.e. that we can always go tuple -> list but not the other way?
00:23:29 <arkeet> sveit: yep you can do that.
00:23:50 <arkeet> :t prism' (\(x,y) -> [x,y]) (\l -> case l of [x,y] -> Just (x,y); _ -> Nothing)
00:23:50 <lambdabot> (Applicative f, Choice p) => p (t, t) (f (t, t)) -> p [t] (f [t])
00:23:53 <nak> Cale let me step through that one with ou
00:23:56 <nak> [] == [] = True
00:24:04 <nak> this is saying Empty list compared to Empty list is True
00:24:07 <sveit> arkeet, iaoel: is it considered the "best" or "standard" way to do this? (reading the documentation now)
00:24:09 <Cale> yep
00:24:16 <arkeet> sveit: well, it's the lens way to do it :-)
00:24:18 <Cale> i.e. that the empty list is equal to itself
00:24:28 <nak> (x:xs) == (y:ys) = x == y && xs == ys
00:24:32 <arkeet> a Prism is more or less a pair of (a -> s) and (s -> Maybe a)
00:24:45 <sveit> i guess the reason i wanted a typeclass is that i can require an instance in a type signature, this doesn't seem to provide a mechanism for this...
00:24:56 <nak> this compares the head of each list, and tail of each lists
00:24:59 <sveit> replace first "this" with "prism"
00:25:06 <Cale> yep
00:25:18 <arkeet> a typecalss makes sense if you only have one sensible implementation per type.
00:25:20 <Cale> Two nonempty lists are equal if they have equal heads and equal tails
00:25:38 <nak> Cale this is necessary because  (head []) freaks out
00:25:39 <Cale> and note that x == y uses the fact that there's an instance of Eq for a
00:26:01 <Cale> Well, we're not actually using the head function, but yes.
00:26:01 <nak> rather, the [] == [] is necessary because we can't use (x:xs) == (y:ys) on empty lists
00:26:18 <Cale> right, the pattern (x:xs) never matches an empty list
00:26:22 <nak> gotcha
00:26:31 <nak> ah right, this is "pattern matching" in this context
00:26:34 <arkeet> yup
00:26:51 <nak> so only ONE line of this will get evaluated
00:26:57 <Cale> and then it says any two other lists are not equal (i.e. if one was empty and the other was not)
00:26:58 <nak> because only ONE line will match the pattern 
00:26:59 <arkeet> all evaluation of stuff in haskell boils down to pattern matching, more or less
00:27:04 <Cale> right
00:27:08 <arkeet> aside from primops I guess
00:27:09 <xelxebar> speaking of tuple overkill: https://downloads.haskell.org/~ghc/7.8.4/docs/html/libraries/ghc-prim-0.3.1.0/src/GHC-Tuple.html#()
00:27:25 <arkeet> does ghc still only let us use up to 63-tuples or whatever
00:27:43 <iaoel> sveit: Maybe I'm not understanding but why can't you just shift `Subset a b
00:27:43 <iaoel> * => foo` to `Prism' a b -> foo`?
00:27:59 <Cale> The last pattern would match in any case, but the patterns are matched in order, that is, the earlier pattern matches have priority over the later ones.
00:28:06 <sveit> it is very convenient to write functions that take some specialized sequence-like data structure "a" and be able to immediately write a function requiring "Subset a [Int]" (note in this case requiring foldable doesn't work since "a" might only hold unboxed values)
00:28:08 <nak> Cale how come _xs == _ys = False ?
00:28:26 <arkeet> nak: the first case tells how to compare two empty lists.
00:28:29 <arkeet> the second tells how to compare two nonempty lists.
00:28:30 <Cale> Because if the lists are neither both empty, nor both nonempty, then that means one is empty and the other is not.
00:28:36 <Cale> In which case, they can't be equal.
00:28:39 <arkeet> the last one catches the case where you have one empty and one nonempty list.
00:28:42 <arkeet> yeah
00:28:44 <nak> oh!
00:28:48 <nak> it's not saying they're ===
00:28:51 <nak> == *
00:29:12 <Cale> Remember, we're defining the function == here :)
00:29:15 <arkeet> it's defining equality of two such things to be false.
00:29:15 <nak> it's saying if you call list1 == list2, and neither of the previous pattern matched expressions are true, then the result is False
00:29:18 <sveit> iaoel: i guess i could, it just seems like /slightly/ more typing for me :)
00:29:18 <nak> yeah
00:29:20 <nak> gotcha
00:29:29 <Cale> right
00:29:33 <nak> very cool
00:29:41 <nak> very concise
00:29:52 <nak> i was kind of wondering when i'd see nasty logic blocks in haskell
00:29:59 <sveit> iaoel: but probably necessary, since you're right that there may be several possible prisms. do you know if this method incurs significant performance overhead?
00:30:04 <nak> but this kind of thing helps avoid a lot of if/else bs
00:30:05 <iaoel> sveit: Depending on your use case, Reader could help with that
00:30:18 <Cale> nak: Yeah, there are also guards which can help
00:30:49 <iaoel> sveit: My understanding is that Lens has very good performance. Inlines
00:30:49 <iaoel> * pragmas everywhere
00:31:39 <arkeet> yeah, code written with lens typically inlines away completely.
00:31:44 <Cale> nak: So, while this instance doesn't appear to explicitly implement the not-equal-to test (/=), there's a default implementation in the definition of the Eq class which gets used.
00:32:31 <Cale> nak: Which is why the definitions in the class declaration for Eq are circular, it's so you can define either one of (==) or (/=), whichever is easier for your data type, and the other will be defined for you.
00:33:56 <sveit> iaoel: can you say how reader could help?
00:34:07 <sveit> keep the prism in the state?
00:34:32 <iaoel> Yeah
00:35:24 <Cale> nak: So, one thing which is really cool that type classes let you do is to have operations which are polymorphic just in the type of the result
00:35:30 <Cale> nak: We can have things like:
00:35:31 <Cale> :t read
00:35:33 <lambdabot> Read a => String -> a
00:36:02 <arkeet> > read "123" :: Int
00:36:03 <lambdabot>  123
00:36:03 <Cale> Which implementation of the function (i.e. which parser) to use is determined by which type of thing is required.
00:36:04 <arkeet> > read "123" :: Double
00:36:05 <lambdabot>  123.0
00:36:07 <arkeet> > read "123" :: String
00:36:09 <lambdabot>  "*Exception: Prelude.read: no parse
00:36:20 <Cale> > read "\"123\"" :: String
00:36:21 <lambdabot>  "123"
00:36:30 <Cale> > read "[1,2,3]" :: [Integer]
00:36:31 <lambdabot>  [1,2,3]
00:36:47 <arkeet> ^ this recursively uses the Read instance for Integer to parse the elements.
00:36:58 <Cale> > read "[(1,2),(2,3),(3,4)]" :: [(Integer,Double)]
00:36:59 <lambdabot>  [(1,2.0),(2,3.0),(3,4.0)]
00:37:14 <nak> hmm
00:37:24 <arkeet> (although to support this the Read class needs something a bit more powerful than just read)
00:37:33 <nak> that's really fricken cool
00:37:54 <arkeet> > read "fromList [(1,2),(2,3)]" :: M.Map Int Double
00:37:56 <lambdabot>  fromList [(1,2.0),(2,3.0)]
00:38:32 <Cale> This kind of thing is one reason that types become more than just being about making sure that code doesn't misbehave. Which type you use can change what the program is.
00:39:30 <nak> so this tho
00:39:31 <nak> Read a => String -> a
00:39:49 <nak> read takes a string and returns a 'Read'
00:39:56 <nak> Read is the type constraint here, right ?
00:40:23 <nak> i'm assuming that Double, Integer, String, etc are all parts of the Read type?
00:40:29 <nak> my verbiage probably sucks there
00:40:38 <nak> how would you phrase that using proper terms ?
00:40:55 <arkeet> Double, etc. are all instances of Read
00:40:58 <Cale> Double, Integer, and String are all instances of the Read type class
00:41:19 <arkeet> `read` is a method of the Read class
00:41:35 <Cale> Read itself isn't a type, but a class, which constrains the types over which type variables range to just those which implement its methods
00:41:35 <arkeet> each of those types has an implementation of that method, I guess. (as part of the instance definition)
00:41:54 <arkeet> words.
00:42:22 <nak> coming from langs that do OOP, it's a bit of a brainf***
00:42:37 <Cale> yeah, here the operations don't travel with the data like in OOP
00:42:46 <nak> like, my brain says "How can Integer be an instance of many different type classes"
00:42:49 <Cale> They travel separately, and come together when the operations get used.
00:42:52 <nak> yeah
00:42:58 <nak> this is *way* better
00:43:03 <nak> Honestly, i hate OOP
00:43:06 <arkeet> it's because anyone can define an instance of any type for any class.
00:43:07 <R0b0t1> structured programming -> OOP -> haskell
00:43:20 <arkeet> although in practice it's a bad idea to do this in some place other than the type or class's definition
00:43:22 <R0b0t1> circle of programming paradigms
00:43:38 <arkeet> er, in the same module that defines the type or class
00:43:42 <iaoel> Hm. Is there a better way to encode `f : Set b -> Set a x ... x Set a -> b`* than `f :: Set b -> [a] -> b`?
00:43:42 <iaoel>  
00:43:49 <Cale> There are some use cases for OOP, and you can actually do it really well in Haskell, but usually it doesn't involve type classes, just record data types whose fields are typically functions or IO actions or something.
00:44:03 <echo-area> If a type variable is not provided an argument, does this mean that it is of kind *?
00:44:09 <arkeet> speaking of OOP I should play around with the objective library at some point.
00:44:56 <echo-area> This is from the Haskell spec: data App f a = A (f a)
00:45:20 <Cale> echo-area: In Haskell 98, yeah.
00:45:37 <arkeet> yeah, so in there, f :: * -> * and a :: *
00:45:50 <arkeet> and App :: (* -> *) -> * -> *
00:45:57 <Cale> echo-area: The kind inference in Haskell 98 is very simplistic -- anything whose kind is not otherwise constrained within the module in which it's declared just gets kind *
00:46:16 <arkeet> in GHC with polykinds it gets generalized to App :: (k -> *) -> k -> *
00:46:35 <echo-area> (* -> *) -> * -> * assumes (App f a) is of kind * and (f a) is of kind *
00:46:48 <arkeet> yes, that always holds.
00:47:06 <arkeet> (because App is a function, and functions map between types of kind *)
00:47:12 <arkeet> (er, because A is a function)
00:47:32 <xelxebar> nak: there's a wealth of Haskell learning resources, so much so that I kind of find it overwhelming. Here's a resource that gives a learning path that seems pedagogically sound: https://github.com/bitemyapp/learnhaskell
00:48:03 <Cale> xelxebar: Oh, and you wanted to know more about the derived instances
00:48:08 <echo-area> Cale, arkeet: Thanks
00:48:22 <nak> arkeet, Cale, xelxebar do you think i should skip over LYAH ?
00:48:26 <Cale> xelxebar: https://www.haskell.org/onlinereport/derived.html has a specification for them
00:48:48 <Cale> nak: A lot of people seem to be recommending Brent Yorgey's course over LYAH now
00:48:56 <xelxebar> nak: scroll down to the "Primary Courses" section. Everything above it is good for getting yourself set up with a haskell environment which you seem to already have.
00:48:57 <Cale> http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
00:49:31 <Cale> I actually learned Haskell a long time before either of these things existed, and I haven't really read them in all that much detail
00:50:03 <Cale> But I'd trust Brent to teach people well :)
00:50:22 <Cale> His libraries are all quite beautifully designed.
00:50:37 <arkeet> I...don't remember how I learned haskell, heh
00:50:49 <nak> hmm ok
00:50:50 <arkeet> I suspect I just read a variety of things and pieced together information from them.
00:50:51 <nak> i will start there then
00:51:07 <arkeet> I skimmed through the cis194 lectures and it seemed pretty reasonable to me though
00:51:19 <xelxebar> Cale: thanks for the derived link
00:52:16 <xelxebar> nak, Cale: that github link references the Yorgey's course as the place to start as well as recommending where to go from there
00:52:29 <Cale> Yeah
00:52:40 <nak> ok awesome
00:52:45 <NicX> Hspec users: How do you assert that 'take 5 []' should return []? I tried 'take 5 [] `shouldBe` []' but ghc complains about ambiguous types. I can grudgingly sympathize with ghc here, but I don't know how to fix my test. http://pastebin.com/YAYKTAJt
00:52:52 <nak> hey, so i originally setup my haskell sometime ago through homebrew
00:52:58 <nak> and i get some funky errors when i install packages
00:52:59 <xelxebar> there was a nice blog reviewing most of the learning materials and explaining why Yorgey's course was pedagogically the most sound at the moment
00:53:13 <nak> how can i delete everything and start over from the ghcforosx
00:53:19 <Cale> NicX: Try making one of the empty lists be ([] :: [Integer])
00:53:49 <nak> i know i can `brew uninstall ghc` but where do haskell packages get installed ?
00:54:20 <arkeet> nak: for stuff installed with cabal, package metadata is stored in .ghc, and the meat is in .cabal
00:54:37 <arkeet> in the home directory
00:54:50 <nak> alright that's not so bad
00:55:18 <arkeet> xelxebar: yeah, and it was also rather critical of LYAH
00:55:25 <nak> any other OSX users here ?
00:56:01 <arkeet> xelxebar: this post http://bitemyapp.com/posts/2014-12-31-functional-education.html
00:56:13 <arkeet> nak ^
00:56:48 * nak reads
00:56:48 <NicX> Cale: thanks! I fought with that for hours yesterday
00:56:51 <arkeet> nak: there's a fair number of OSX haskellers (I'm not one of them though)
00:57:03 <Cale> nak: I used GHC on OSX for a while, but it was back in 2004 or so...
00:57:44 <nak> Cale you've been using haskell for >10 years?
00:57:55 <nak> ._.
00:57:56 <nak> i'm so behind
00:57:56 <Cale> Yeah, since 2001-2002
00:58:25 <arkeet> haskell has been around since 1990
00:58:39 <arkeet> (although it's evolved a fair bit since then)
00:58:43 <Cale> When I first joined this channel it had less than 100 users
00:58:46 <nak> yeah but like, i'm just an imperative noob compared to u guys
00:59:00 <arkeet> everyone was a noob once :)
00:59:03 <xelxebar> nak: here's where the author of that github repo explains why he recommends said courses http://bitemyapp.com/posts/2014-12-31-functional-education.html
00:59:42 <m_ryan> hi is there a way to convert a key on html? e.g Entiy id val - in hamlet <label> #{id} </label>
01:00:12 <nak> xelxebar thanks, reading it now
01:02:43 <xelxebar> nak: no problem!
01:03:19 <Cale> m_ryan: I don't know Hamlet very well, but I'm having trouble making sense of your question. I believe you can put pretty much arbitrary Haskell code inside the curly braces
01:03:52 <arkeet> m_ryan: you might also try asking in #yesod (hamlet is a yesod thing right?)
01:04:02 <m_ryan> Cale: yes it can but the id gives me a little bit of pain. 
01:04:22 <m_ryan> arkeet: i post also the same question waiting for a response.
01:04:26 <Cale> arkeet: Mainly, yeah. You can mix and match with the web frameworks pretty well though.
01:04:44 <Cale> m_ryan: Do you get some kind of error message?
01:04:53 <arkeet> I guess I don't really understand the question anyway
01:04:57 <xelxebar> Cale: okay, so it's pretty much the obvious implementation that a compiler would be able to do. Answers my question whether you can derive instances of custom typeclasses.
01:04:59 <echo-area> What is Constraint in (Num :: * -> Constraint)?  Is it GHC a specialized kind?
01:05:03 <Cale> m_ryan: Oh, I know what your issue might be
01:05:12 <Cale> m_ryan: There is a Haskell function called id in the Prelude
01:05:30 <Cale> m_ryan: It's the identity function  id x = x
01:05:37 <arkeet> echo-area: yeah, it's a GHC thing (ConstraintKinds)
01:06:18 <echo-area> arkeet: If expressed without using GHC, it should be * -> *, right?
01:06:24 <arkeet> no, it shouldn't.
01:06:33 <arkeet> "Num Int" isn't a typ.
01:06:34 <arkeet> e
01:06:43 <Cale> xelxebar: There are ways using GHC extensions to get very close to user-defined deriving mechanisms. You can derive Generic, and then have the class declaration provide a default implementation with restricted type when there's an instance of Generic available.
01:06:52 <m_ryan> Cale: i will check it thnks
01:07:05 <arkeet> echo-area: without ConstraintKinds there isn't really a way to express what sort of thing Num Int is.
01:07:34 <echo-area> arkeet: Okay, let me see.  Thanks
01:07:38 <arkeet> and you just treat it as part of class/constraint syntax
01:07:40 <arkeet> I guess
01:08:55 <nak> is it generally advisable for me to install documentation with cabal packages?
01:09:18 <arkeet> it's optional, but I like having a local copy of all the documentation so I do that.
01:09:23 <nak> i only have a 128 GB hdd on this laptop, if they don't take a lot of space i guess i don't mind
01:09:32 <arkeet> yeah don't worry about it if you're short on space
01:09:41 <arkeet> well
01:09:45 <Cale> It's just a bunch of HTML though, shouldn't be very large
01:09:46 <m_ryan> Cale: it gives me this error No instance for (ToMarkup (Yesod.Key Countries))
01:09:49 <arkeet> actually I never really looked at how big it is, and yeah
01:09:51 <arkeet> it's just text
01:10:10 <nak> ok :)
01:10:29 <Cale> nak: Also, if you ever plan on profiling anything, turn on the option to build profiling versions of packages as soon as possible
01:10:56 <Cale> Because you'll need to reinstall everything at that point and it's annoying :P
01:11:08 <arkeet> that'll take up more space than documentation though :p
01:11:11 <Cale> yeah
01:11:41 * arkeet the recent trend for laptops to have non-upgradable storage is unfortunate :(
01:11:42 <echo-area> Cale: Oh my, I didn't do that
01:11:50 <nak> arkeet i think you were here when i pasted that console output of `cabal install -j hakyll`
01:11:51 <arkeet> internal storage
01:11:58 <nak> i reinstalled using ghc for osx and it's MUCH cleaner now
01:12:03 <arkeet> I may have been, but I've certainly forgotten
01:12:04 <nak> there must've been something b0rked with my install
01:12:13 <xelxebar> Cale: is this what you're talking about: http://hackage.haskell.org/package/generic-deriving ?
01:12:25 <arkeet> there's a 'derive' package
01:12:33 <nak> Cale i probably won't get into profiling any time soon
01:12:45 <arkeet> which is closer to ghc's derived instances I guess
01:12:51 <nak> Cale i'm too noob for that right now :)
01:12:59 <nak> gotta learn my combinators first !
01:13:00 <arkeet> like I think the deriving for Functor/Foldable/Traversable got into ghc via derive
01:13:21 <Cale> xelxebar: Yeah, that's a package of useful things for doing that.
01:13:25 <arkeet> (now someone just needs to write some deriving mechanism for Applicative)
01:13:28 <Cale> xelxebar: see also http://hackage.haskell.org/package/base-4.8.0.0/docs/GHC-Generics.html
01:13:56 <arkeet> (maybe I should do that)
01:14:18 <arkeet> shouldn't be terribly hard.
01:15:22 <xelxebar> Cale: excellent. thank you
01:15:33 <xelxebar> arkeet: I support your initiative!
01:15:42 <arkeet> well, I'd have to figure out how derive works, first.
01:16:06 <arkeet> but I have an idea of exactly what sort of types we should be able to derive it for.
01:16:09 <arkeet> and how the instances should look.
01:16:15 <arkeet> so.
01:16:55 <arkeet> it would still be somewhat limited though.
01:22:09 <nak> ffs pandoc is huge lol
01:23:16 <nak> arkeet Cale xelxebar thanks (again) for your help tonight
01:23:27 <nak> i'm gonna catch some zs
01:23:45 <Cale> nak: Cheers!
01:24:18 <nak> ^.^ bye bye
01:24:56 <xelxebar> nak: night!
01:27:55 <merijn> It's "Question about Awodey"-time again: So it says here that C-> has two functors mapping it to C, dom and cod, but I don't understand exactly what they're mapping?
01:30:00 <SwashBuckla> should @cis194 link to the spring13 version?
01:30:04 <SwashBuckla> @cis194
01:30:04 <lambdabot> Unknown command, try @list
01:30:11 <SwashBuckla> @list cis194
01:30:11 <lambdabot> No module "cis194" loaded
01:30:33 <SwashBuckla> @where cis194
01:30:33 <lambdabot> http://www.seas.upenn.edu/~cis194/fall14/spring13/index.html
01:31:18 <SwashBuckla> oh, it does :D
01:31:30 <lieven> merijn: on what page?
01:32:27 <srhb> echo-area: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/constraint-kind.html
01:32:42 <srhb> Woops, scrolled up by accident
01:33:05 <merijn> lieven: Eh, hold on lemme check
01:33:29 <merijn> lieven: Page 14
01:33:56 <merijn> It just mentions: "Observe that there are two functors: C <-dom- C-> -cod-> C"
01:34:20 <echo-area> srhb: Thank you :)
01:34:41 <merijn> lieven: Oh, wait, I think I get it
01:34:57 <lieven> merijn: it's just arrows and decomposing in domain and codomain
01:35:24 <merijn> lieven: Since the objects in C-> are the arrows in C and functors map objects to objects it's mapping the C arrows to their domain and codomain objects respectively!
01:35:49 <lieven> indeed
01:36:21 <merijn> And then since the arrows are just pairs of arrows in C that create a square it maps the fst/snd arrow respectively
01:36:24 <merijn> \o/
01:55:26 <srhb> Anyone using cabal2nix? I'm trying to figure out how to make my XMonad config build in a clean manner, and it relies on a number of external bits and bobs (X11 xkb libs, a personal hsc package with bindings to that, etc)
01:55:53 <srhb> An well, uh, I don't even know what to do with the nix expression that cabal2nix /home/me/myxmonadcabalized spits out :-)
02:21:01 <aleator_> Anyone know what criteria cabal uses to determine whether to rebuild a file? I'd really would like to get rid of useless rebuilds..
02:21:17 <dcoutts> aleator_: for .hs files?
02:21:23 <dcoutts> ghc --make decides
02:22:51 <aleator_> dcoutts: Yeah. Or more precisely it decides to rebuild add-sourced packages on every build.
02:23:04 <dcoutts> ah, that's different
02:23:41 <dcoutts> that's the cabal sandbox code
02:23:42 <aleator_> My build system forces a git update on the dependencies, which, I think, touches the files.
02:23:54 <dcoutts> right, it's looking at timestamps
02:23:57 <dcoutts> like make does
02:23:58 <fumbles> Has anyone had any success installing and running xmonad on osx yosemite? Got it to build but xmonad-contrib fails everytime to build 
02:24:31 <srhb> fumbles: I don't have OS X now, but how does it fail?
02:26:49 <fumbles> I'm rerunning it to see the errors
02:27:44 <aleator_> dcoutts: Yup.. Then I either need to find out how to reset file timestamps or hack a digest mode into cabal-sandbox...
02:28:03 <dcoutts> aleator_: right
02:28:07 <lpaste> fumbles pasted “Xmonad-contrib build attempt” at http://lpaste.net/131621
02:28:32 <srhb> fumbles: Which ghc version?
02:28:43 <merijn> fumbles: Looks like building a post-AMP package using a GHC before 7.10
02:28:48 <fumbles> 7.8.3
02:29:13 <fumbles> What's the most current version?
02:29:16 <merijn> fumbles: File a bug-report, that version relies on the AMP changes which are only in 7.10
02:29:24 <merijn> A bit sloppy...
02:29:44 <fumbles> Ah. ok. Thanks
02:29:49 <merijn> fumbles: Basically, in 7.10 we (finally!) moved Applicative into Prelude and made it a Monad superclass
02:30:07 <srhb> fumbles: 7.10.1 is latest
02:30:09 <merijn> fumbles: So you no longer need to import it, but of course if you're using an older GHC it flips out and can't find stuff
02:30:25 <aleator_> dcoutts: otoh, how contained is the client.sandbox.timestamp? Is anything else likely to use the fact that AddSourceTimestamp is a tuple with time?
02:30:43 <fumbles> Ah that makes sense for those errors than
02:30:50 <merijn> fumbles: Should be easy to fix locally, just "cabal get xmond-contrib" and add "import Control.Applicative" to the relevant files
02:31:05 <aleator_> dcoutts: Adding digesting there would probably be  a not so good idea though.
02:31:10 <dcoutts> aleator_: I'm not totally sure of the mechanism
02:31:14 <merijn> fumbles: Yeah, the authors should've added CPP ifdef's to check for this, imo
02:32:46 <merijn> fumbles: If you're motivated, add the CPP yourself and do a pull request/mail the maintainer a patch ;)
02:34:10 <fumbles> I'll probably be motivated after I take a nap lol. It's 4 CST. But If it's just adding an import statement I don't think much motivation will be needed heh
02:34:12 <aleator_> dcoutts: Thanks. I probably won't have energy for it, but would digest based tracking option be useful to add to cabal-install?
02:34:27 <aleator_> In case I can't get sleep..
03:22:43 * hackagebot html-entities 1.0.1.0 - A codec library for HTML-escaped text and HTML-entities  http://hackage.haskell.org/package/html-entities-1.0.1.0 (NikitaVolkov)
03:29:05 <aruro> what is most easy and lightweight command line parsing library?
03:29:22 <kqr> aruro, what does command line parsing mean?
03:29:39 <kqr> aruro, are you asking for optparse-applicative?
03:29:39 <aruro> https://wiki.haskell.org/Command_line_option_parsers
03:32:25 <aruro> would like to know what is the best one to use :)
03:34:00 <kqr> optparse-applicative!
03:35:12 <aruro> ok,ty
03:39:08 <srhb> Has anyone experienced the lens-4.9.1 build getting stuck at Test suite doctests: RUNNING forever?
03:43:28 <arkeet> srhb: literally forever, or just a really long time?
03:43:31 <arkeet> there are a lot of doctests
03:43:43 <srhb> arkeet: I'll wait some more. 30 minutes so far :)
03:43:55 <arkeet> not sure exactly how long it takes though
03:44:00 * srhb nods
03:44:29 <arkeet> 632 according to #haskell-lens topic
03:45:03 <passingBy> Greetings. 
03:46:50 <srhb> arkeet: 632 what_ minutes_
03:46:54 <srhb> :P
03:47:12 <arkeet> 632 doctests.
03:47:15 <srhb> Ah
03:51:37 <srhb> arkeet: Apparently I'm just impatient. Passed. :)
03:51:43 <arkeet> cool
03:54:20 <dcoutts> aleator_: yes it would be useful
03:56:52 <sopvop> hm, with GHC.TypeLits can I somehow get symbolVal (string) from SomeSymbol?
03:57:45 * hackagebot vimus 0.2.1 - An MPD client with vim-like key bindings  http://hackage.haskell.org/package/vimus-0.2.1 (JoachimFasting)
03:57:50 <sopvop> ah, sure I can
04:00:00 <merijn> arkeet: Late to the party, but I second optparse-applicative as least magic/most flexible I've used :)
04:05:40 <MagneticDuck> any elerea users here?
04:07:45 * hackagebot test-framework-golden 1.1.3.2 - Golden tests support for test-framework  http://hackage.haskell.org/package/test-framework-golden-1.1.3.2 (RomanCheplyaka)
04:07:47 * hackagebot test-framework-golden 1.1.3.3 - Golden tests support for test-framework  http://hackage.haskell.org/package/test-framework-golden-1.1.3.3 (RomanCheplyaka)
04:17:46 * hackagebot one-time-password 1.0.0.0 - HMAC-Based and Time-Based One-Time Passwords  http://hackage.haskell.org/package/one-time-password-1.0.0.0 (AlekseyUymanov)
04:22:46 * hackagebot stackage-upload 0.1.0.3 - A more secure version of cabal upload which uses HTTPS  http://hackage.haskell.org/package/stackage-upload-0.1.0.3 (MichaelSnoyman)
04:32:47 * hackagebot cookie 0.4.1.5 - HTTP cookie parsing and rendering  http://hackage.haskell.org/package/cookie-0.4.1.5 (MichaelSnoyman)
04:33:54 <absence> http://lpaste.net/131547 <- is this the prefered way to refactor such a problem, or are there some clever alternatives?
04:35:33 <srhb> So, now I have cabal2nix . > mypackage.nix -- how do I install it?
04:38:14 <bennofs> srhb: 'nix-env --install -E "{..}: (import <nixpkgs> {}).haskellngPackages.callPackage ./mypackage.nix {}' should work
04:38:17 <latk> I'm in the process of setting up a new computer - what is the best way of installing stuff on osx these days ?
04:38:24 <bennofs> srhb: see also #nixos
04:38:47 <latk> (obviously I mean cabal/ghc/happy/alex/egc)
04:38:49 <srhb> bennofs: Thanks!
04:38:50 <latk> etc*
04:39:23 <srhb> bennofs: I'm also in #nixos, but I'm not sure whether Haskell related nix questions fit better there or here.
04:39:36 <bennofs> srhb: I'd say better there
04:39:40 <srhb> Got it :)
04:39:49 <exio4> is there any way to see which cabal packages were installed manually (and not as dependencies)?
04:41:19 <merijn> exio4: No
04:41:56 <merijn> latk: I used ghcformacosx to install GHC + cabal and installed happy/alex manually
04:41:59 <bennofs> exio4: not sure, but I believe ~/.cabal/world is something close to this?
04:42:26 <latk> merijn: Cheers, will have a look at ghcformacosx
04:42:52 <merijn> latk: https://ghcformacosx.github.io/
04:43:09 <latk> Is it worth using 7.10, or are many packages incompatible ?
04:43:22 <merijn> latk: Differs per person, I think
04:43:49 <merijn> If you work on stuff with a huge dependency footprint (like yesod, or something) you might run into breakage, otherwise maybe not?
04:44:04 <merijn> latk: It's pretty easy to have multiple GHC versions installed, though
04:44:33 <merijn> latk: GHC has a per-version package database and cabal just uses whichever GHC is first on your path so all you have to do to switch GHC versions is change which one comes first on your path
04:45:33 <exio4> bennofs: maybe, I want to reinstall most packages, but I actually wanted to see a clean-list of things I installed, that way I could only install the ones I actually need now :p 
04:47:44 <latk> merijn: Currently I don't work on any huge projects at the mo, so I'll give 7.10 a spin.
04:48:41 <merijn> latk: Worst case scenario, you install both and have to recompile some stuff using 7.8 when you switch if you hit breakage
04:48:52 <latk> merijn: True :)
04:52:47 * hackagebot postgresql-query 1.1.1 - Sql interpolating quasiquote plus some kind of primitive ORM  using it  http://hackage.haskell.org/package/postgresql-query-1.1.1 (AlekseyUymanov)
05:02:48 * hackagebot shuffle 0.1.3.2 - Shuffle tool for UHC  http://hackage.haskell.org/package/shuffle-0.1.3.2 (AtzeDijkstra)
05:13:27 <randu> Does anyone has links to course-webpage of some university that taught Real World Haskell?
05:13:41 <gcganley> is there a hackage which i can use to download internet files (im downloading jquery). I know about the download package but it doesnt work becuase of some unsafePerformIO stuff
05:15:05 <eatman> Hi there.
05:15:16 <eatman> I'm following the steps on this page: https://wiki.haskell.org/Xmonad/Config_archive/John_Goerzen%27s_Configuration#Configuring_xmonad_to_use_xmobar
05:15:26 <tdammers> gcganley: you mean, you want something like libcurl?
05:15:33 <eatman> But I can't see any xmobar.
05:15:39 <eatman> Is it the normal behavior?
05:16:23 <tdammers> gcganley: http://hackage.haskell.org/packages/search?terms=curl <- anything useful here?
05:16:37 <aleator_> What black magic must I do to get cabal-install from github to compile in a sandbox?
05:16:56 <tdammers> gcganley: or alternatively, something like this: http://hackage.haskell.org/package/http-client
05:17:22 <tdammers> eatman: do you have xmobar installed?
05:20:18 <eatman> tdammers: yes
05:20:53 <tdammers> eatman: then I don't know :x
05:21:07 <eatman> Arf...
05:21:53 <eatman> Anyone else for a xmobar issue?
05:23:26 <kqr> eatman, do you get any error messages?
05:24:01 <geekosaur> (1) make sure manageDocks is enabled (2) make sure xmobar is in $PATH --- note that when using a GUI login manager, none of your shell-specified directories will be in $PATH anywhere but terminal windows
05:25:22 <eatman> I'll give you my config files to be sure.
05:27:15 <eatman> My xmonad.hs http://sprunge.us/FWAJ
05:27:29 <eatman> My xmobarrc http://sprunge.us/chLb
05:27:41 <eatman>  xmobar
05:27:42 <eatman> Fields missing from config defaulted: additionalFonts,border,borderColor,textOffset,iconOffset,allDesktops,overrideRedirect,pickBroadest,hideOnStart,lowerOnStart,persistent,iconRoot,alpha
05:28:05 <eatman> kqr: I think defaulted values are ok.
05:28:18 <eatman> and my xmonad config seems ok a well.
05:31:40 <gcganley> hey sorry my internet dropped did anyone repond to my question about the networking library that wasnt 'download'
05:31:48 <gcganley> becuase that library doesnt build for me
05:32:06 * aleator_ wonders why persistent depends on blaze-html..
05:32:14 <tdammers> gcganley: try searching hackage for "curl" or "http"
05:32:24 <tdammers> there are a few packages that look like they'd do what you want
05:32:48 <bennofs> @hackage wreq -- can also be used
05:32:48 <lambdabot> http://hackage.haskell.org/package/wreq -- can also be used
05:33:02 <bennofs> for doing networking
05:33:56 <gcganley> im literally doing this so i dont have to keep jquery on my disk until i start my server
05:34:40 <tdammers> what?
05:34:46 <tdammers> I mean, you're using haskell
05:35:04 <tdammers> your web app's main binary is going to be a hundred times the size of jquery
05:35:45 <gcganley> tdammers: my website right now is part of my subnetting calc @ github.com/gcganley/subnet
05:36:28 <jaseemabid> gcganley: Isn't is much easier to ship jQuery along with your app?
05:36:31 <tdammers> yeah, but still - I'd even go so far as to embed jquery in the binary itself
05:36:35 <gcganley> but if you load Web.Subnet package then when you try and run main w/o jquery.js in the working directory than it breaks
05:37:09 <tdammers> the same happens when there's a network problem, a DNS problem, or the configured URL is no longer valid, or a million other things
05:37:18 <bennofs> just use TH (TemplateHaskell) to embed the file if you want that.
05:37:21 <tdammers> anyway, you could use file-embed
05:37:36 <merijn> That or do it the ghetto linking way :p
05:37:49 * merijn has embedded text files into C binaries in the past
05:37:57 <tdammers> merijn: I started writing a little helper for that a while ago
05:38:09 <tdammers> merijn: turns out, just upgrading the ghc on my build server was easier :D
05:38:16 <tdammers> it did work though
05:38:18 <merijn> tdammers: What's that helper do? It's almost trivial to do it in C
05:38:19 <tdammers> fun project
05:38:24 <gcganley> i always try to avoid TH because it erks me
05:38:27 <tdammers> well, I did the helper in Haskell
05:38:44 <merijn> gcganley: If it irks you more than linker hackery, I can show you what I did :p
05:39:08 <tdammers> it'd load a bunch of files and generate some C code that contains the file contents and some metainformation
05:39:25 <tdammers> the source files are huge, but there is little overhead in the compiled output
05:39:37 <merijn> tdammers: Oh, but you can do it directly without that
05:39:51 <tdammers> well, I wanted to mimic what file-embed's embedDir does
05:40:17 <gcganley> im cool with linker hacking, that doesnt bother me as much as TH, which is prbebly the better solution but fuck it
05:40:31 <tdammers> so I'd generate functions for listing the embedded files and for getting an individual one, and then FFI them into the Haskell layer
05:40:44 <tdammers> anyway
05:40:58 <tdammers> on 7.8 and up, file-embed works flawlessly, and you don't need to do the TH yourself
05:41:10 <tdammers> you just do something like:
05:41:34 <tdammers> jquery = embedFile "jquery.js" -- and that's it, jquery is now a ByteString containing whatever was in that file at compile time
05:41:44 <merijn> http://lpaste.net/131623
05:42:15 <merijn> You can basically ask 'ld' to turn arbitrary binary data into a linkable file exporting symbols to access the data and it's size
05:42:37 <Malenko> hey
05:42:41 <Malenko> anyone there/
05:42:45 <Malenko> ?
05:42:47 <merijn> So I just used that to turn my text file into a binary blob that I can then index directly using pointers in my code
05:42:47 <kqr> only 1600 people
05:42:56 <Malenko> i need  someone to help me hack
05:43:00 <Malenko> will pay in btw
05:43:11 <Malenko> btc
05:43:16 <tdammers> Malenko: this is not the right place
05:43:30 <Malenko> what channel do i goto for that?
05:43:33 <Malenko> any ideas?
05:43:37 <kqr> careers.stackoverflow.com
05:43:45 <merijn> gcganley: Of course instead of using the C code I mentioned just do the same in Haskell via the FFI and the linker will point you at the right binary location in your binary
05:43:58 <jaseemabid> Malenko: hasjob.co
05:44:00 <kqr> create a job posting there
05:44:11 <Malenko> any irc channels for it?
05:44:58 <kqr> no
05:45:04 <kqr> job searching on irc is not very efficient
05:45:07 <Malenko> ok thanks
05:45:13 <Malenko> peace y
05:45:13 <JordiGH> Why do people say that List as a monad is about nondeterminism? I don't see anything random about it at all.
05:45:14 <gcganley> i might go with the TH actually its more concise and im only running on x86_64 linux so i should be fine support wise
05:45:15 <kqr> people go to job searching sites
05:45:25 <kqr> JordiGH, there are two kinds of non-determinism
05:45:41 <kqr> JordiGH, either you choose a value at random at every point in the evaluation when you have multiple alternatives
05:45:47 <kqr> JordiGH, or you compute a result for *all* of them
05:45:51 <kqr> JordiGH, the list monad does the latter
05:46:09 <gcganley> i always thought of the list monad as multiple alternitives
05:46:11 <JordiGH> Okay, weird word choice, I guess. Wouldn't be the first time that Haskell has its own idiosyncratic vocabulary.
05:46:20 <tdammers> think of it as "here, I can't decide on any of the values you gave me, I'll just give you the results for all of them so you can pick"
05:46:36 <kqr> JordiGH, so instead of giving different results every time you run it, it gives you all the possible results and then you can choose from them at random if you want to
05:46:58 <JordiGH> Pretty weird to say "all values" is "nondeterministic", but whatevs.
05:47:20 <JordiGH> I *can* rely on the order of the values returned being the same, right? It doesn't depend on Haskell implementation or something like that?
05:47:28 <kqr> not at all
05:47:39 <JordiGH> Which statement are you negating?
05:47:39 <kqr> the list monad is well defined
05:47:43 <kqr> haha the last one
05:48:06 <bernalex> JordiGH: it's just two different usages of the word nondeterminism. both are old and well-known.
05:48:19 <JordiGH> bernalex: I don't see the other meaning here: https://en.wikipedia.org/wiki/Deterministic_algorithm
05:48:49 <bernalex> JordiGH: I didn't check the article, but based on the word "algorithm", that is probably the "other" meaning.
05:49:01 <JordiGH> I don't quite see it here either: https://en.wikipedia.org/wiki/Nondeterministic_programming
05:49:18 <JordiGH> There's no "choice" involved in just doing a [a | a <- whatever]
05:49:30 <kqr> yes
05:49:36 <kqr> there's a choice of as many a as there are in whatever
05:49:43 <kqr> a is chosen from whatever
05:49:45 <JordiGH> Okay, I guess I'll just get used to your language.
05:49:50 <bernalex> JordiGH: this is called "nondeterministic calculation" or "computation".
05:49:53 <eatman> Still can't see the xmobar.
05:49:56 <eatman> Any clue?
05:49:57 <barrucadu> JordiGH: When talking about automata, nondeterminism refers to taking all possible paths
05:50:00 <JordiGH> I don't like it, but it's hardly the only part of the arbitrary choices of Haskell that I don't like them.
05:50:01 <kqr> since we don't want to choose randomly, we just give you the result for all chocise
05:50:11 <eatman> I tryed with and without config file.
05:50:17 <eatman> With or without reboot.
05:50:21 <eatman> No changes.
05:50:28 <frerich> JordiGH: The other definition of 'determinism' comes from state machines AFAIK. For instance, I know 'nondeterministic' parsers which, given some input, yield all possible parse trees instead of just one of them. https://en.wikipedia.org/wiki/Deterministic_parsing may be releated.
05:50:53 <JordiGH> bernalex: Wikipedia disagrees again: https://en.wikipedia.org/wiki/Nondeterministic_computation
05:50:56 <frerich> JordiGH: I.e. those parsers are not random in any sense of the word, but they do not yield a single input to a single output either.
05:50:57 <bernalex> JordiGH: this is much older lingo than haskell.
05:51:39 <JordiGH> bernalex: Yes, and it's not what Turing meant by it either.
05:52:33 <frerich> JordiGH: Note that the Wikipedia page I linked explicitely says "This meaning of the words "deterministic" and "non-deterministic" differs from that used to describe nondeterministic algorithms.)"
05:52:51 <JordiGH> Nobody says that a list comprehension in Python or C++ is "nondeterministic". This usage is a Haskellism.
05:53:16 <kqr> heh. do python or C++ people use any words that sound vaguely mathy?
05:53:19 <barrucadu> If we're going for wiki articles, http://en.wikipedia.org/wiki/Non-deterministic_Turing_machine#Resolution_of_multiple_rules
05:53:27 <kqr> last I checked they didn't talk about isomorphisms either
05:53:32 <JordiGH> Yes, C++ has a weird definitino of functor. I don't know where they got it from.
05:53:35 <frerich> JordiGH: A list comprehension in Haskell is not non-deterministic either. A list can simply be used to model non-deterministic functions, i.e. functions which return all possible results for a given input.
05:54:13 <frerich> JordiGH: If you write a recursive-descent parser in C++ which yields a std::list<> of possible syntax trees, then you could call that parser 'non-deterministic' basedon the same groups as why the list monad can be 'nondeterministic' in Haskell.
05:54:33 <c_wraith> Yes..  Model and implementation are very different things.  You can model non-determinism fully deterministically.
05:54:41 <frerich> JordiGH: I.e. it's not specific to lists in particular but rather to the 'yield multiple plausible results' aspect.
05:54:53 <JordiGH> Okay, I see.
05:55:49 <frerich> JordiGH: This isn't Haskell-specific terminology, at least to me this definition of non-deterministic parsing was known long before I heard about Haskell.
05:55:59 <frerich> but who knows, maybe the people who taught it to me got it from Haskell after all :-)
05:57:30 <geekosaur> lists as "non-determinism" seems to me to be a very math-y concept
05:58:22 <geekosaur> when everything is expected to be ruled by logic and equations, "produce all possible results" pretty much is as close as youy get to non-determinism...
05:58:37 <Dodek> 14:54 < c_wraith> Yes..  Model and implementation are very different things.  You can model non-determinism fully deterministically.
05:58:49 <Dodek> it depends -- you cannot model nondeterministic push down automata using deterministic ones
05:59:11 <Dodek> which is kinda important in parsing
05:59:46 <c_wraith> I didn't say with an identical complexity class. :)
05:59:54 <barrucadu> Dodek: But you can model nondeterministic pushdown automata deterministically, which is what's important
06:01:19 <Dodek> well, from church turing thesis it follows that you can model everything using anything
06:01:37 <Dodek> as long as it's obviously not too stupid
06:05:50 <c_wraith> It's true that's it's not very mind-blowing.  But treating monadic bind in lists as nondeterministic selection can be a really nice model for solving certain kinds of problems.
06:07:27 <kqr> it's very nice
06:07:29 <isomorphic> What's a tilde at the front of a lambda function mean, eg:\ ~(a, b) -> (f a, b) 
06:07:31 <isomorphic> ?
06:07:33 <kqr> it lets me write code that looks like it deals with single values
06:07:40 <kqr> but it actually works with all the values
06:07:45 <merijn> isomorphic: lazy pattern match
06:07:50 <kqr> isomorphic, lazy pattern. tries not to evaluate the tuple to WHNF
06:08:02 <isomorphic> gotcha, thanks :) 
06:19:10 <hexagoxel> aleator_: no black magic required. what's the issue?
06:27:51 * hackagebot smallcheck-series 0.2 - Extra SmallCheck series  http://hackage.haskell.org/package/smallcheck-series-0.2 (jdnavarro)
06:38:09 <nstj> wow
06:38:13 <nstj> hi everyone
06:39:03 <kqr> hi
06:39:11 <xplat> such greetings
06:39:22 <kqr> very welcome
06:44:47 <fvgvxmpv1> much hello
06:45:07 <narendraj9_> nstj: Hi! :)
06:46:49 <bitonic> what would be an efficient way to fold a bytestring Word32-by-Word32, folding eventual leading and trailing Word8s first and last?
06:47:52 * hackagebot twentefp-eventloop-trees 0.1.0.1 - Tree type and show functions for lab assignment of University of Twente. Contains RoseTree and RedBlackTree  http://hackage.haskell.org/package/twentefp-eventloop-trees-0.1.0.1 (sebaslafleur)
06:49:17 <chpatrick> bitonic: O(1) conversion to storable vector, then fold?
06:49:21 <chpatrick> assuming host endianness
06:49:56 <chpatrick> I have a snippet to do the conversion if you want it
06:50:32 <bitonic> chpatrick: well that would work but wouldn't take into account the leading and trailing Word8s
06:50:41 <bitonic> if the conversion has to be O(1) anyway
06:50:44 <chpatrick> I'm not sure what you mean by them
06:50:44 <bitonic> (which it does)
06:51:06 <bitonic> chpatrick: if the bytestring is not aligned to 4, I want to first fold the leading unaligned bytes
06:51:22 <bitonic> e.g. let's say that the bytestring starts at address 14 up to 35
06:51:29 <bitonic> I want to fold the first two Word8s first
06:51:35 <chpatrick> I see
06:51:47 <bitonic> then Word32-by-Word32 up to 32
06:51:49 <bitonic> then the last 3
06:52:09 <chpatrick> I would just do that manually I think
06:52:26 <bitonic> mh mh
06:52:32 <chpatrick> trailing bs `f` fastFold bs `f` leading bs
06:52:50 <bitonic> yeah I suppose so, I was wondering if there is one weird trick to fold aligned words :P
06:53:00 <chpatrick> cpu architects hate him
06:53:04 <bitonic> ahahahaha
06:53:07 <bitonic> exactly
06:53:31 <chpatrick> although new bytestrings are always aligned I think
06:53:41 <chpatrick> but then they might be sliced of course
06:53:48 <bitonic> well they can't possibly be aligned at the end
06:53:53 <StoneToad> couldn't you just slice off the missaligned bits?
06:53:59 <chpatrick> yeah that's what I'm saying
06:54:21 <bitonic> StoneToad: yeah that's what I'm doing, create 3 bytestrings
06:54:38 <StoneToad> that's not getting optimized nicely?
06:54:43 <bitonic> then fold them in succession, the first is the leading Word8s, the second the aligned chunk the third the trailing Word8s
06:54:52 <bitonic> I was just curious if there was some cleverer way
06:55:16 * StoneToad nods
06:55:31 <StoneToad> it's amazing what experienced haskellers can pull out of their bag of tricks sometimes
06:55:46 <bitonic> those rascals
06:55:56 <kqr> you should steal their bag
06:56:23 <StoneToad> the problem is the bag is some high dimentional construct in category theory space that I can't grab yet :)
06:57:06 <chpatrick> you can use the classic bag generator
06:57:07 <chpatrick> http://cokmett.github.io/cokmett/
06:57:14 <kqr> I was gonna suggest studying until you can grab it, but then I realised at that point you probably don't need it anymore
06:57:52 * hackagebot one-time-password 1.0.0.1 - HMAC-Based and Time-Based One-Time Passwords  http://hackage.haskell.org/package/one-time-password-1.0.0.1 (AlekseyUymanov)
07:17:49 <hodapp> how might I avoid forcing all of my code to be parametrized over a GHC.TypeLits.Nat (including the ugliness involved in aggregation) because one record has one field that is parametrized over it?
07:19:09 <hodapp> short of just replacing it with an Int, and elsewhere having a big ugly case-statement that just checks over all of the Nats I'm likely to actually use (which is probably 0... 30, tops) and dispatches accordingly
07:20:20 <merijn> hodapp: Existentially wrap the typeparameter?
07:20:27 <merijn> See the SomeNat type?
07:20:53 <lokathor> @pl length $ filter (\c -> c `elem` "aeiou") str
07:20:53 <lambdabot> length (filter (`elem` "aeiou") str)
07:21:13 <lokathor> hmm, that's not quite what i was asking lambdabot, but thanks pal
07:21:21 <hodapp> merijn: what can I then do with a SomeNat?
07:21:39 <merijn> hodapp: Use KnownNat voodo to reflect it to th value level
07:22:19 <hodapp> merijn: problem is that I'm using a type in an external package that is parametrized over a Nat
07:22:31 <bennofs> merijn: it seems that the method of KnownNat is not actually exported though? I'd really like to get a singleton out of Nat, do you know how this is possible?
07:22:54 * hackagebot language-puppet 1.1.1.2 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-1.1.1.2 (SimonMarechal)
07:24:03 <hodapp> merijn: so does the disconnect there make sense?
07:24:52 <chpatrick> bitonic: out of interest what do you mean specifically about folding on word32s?
07:25:18 <chpatrick> (Word32 -> a -> a) -> ByteString -> a?
07:25:24 <bitonic> chpatrick: yes
07:25:39 <chpatrick> and then how do you apply that to the word8s?
07:26:34 <bitonic> `BS.foldl' crc32Word8Step (V.foldl' crc32Word32LittleStep (BS.foldl' crc32Word8Step prevC leading) aligned) trailing`
07:26:52 <chpatrick> ah ok
07:26:52 <chpatrick> cool
07:28:10 <merijn> hodapp: Hard to say, tbh
07:28:45 <hodapp> merijn: in other words, getting a *value* out of it doesn't help me any, because what I need is type-level due to this API.
07:29:30 <hodapp> I get why Ivory did this for arrays, but still, it's a pain in the ass.
07:29:47 <merijn> hodapp: Well, if you need the type parameterised by a Nat then you have to have that parameter, yes
07:30:56 <hodapp> That's what I'm trying to find some way around, somehow. It doesn't matter particularly that the record has that type if I can find some other way to acquire the proper type from an instance
07:31:35 <hodapp> e.g. some function of type: forall n . GHC.TypeLits.KnownNat n => FooRecord a -> AnnoyingType n
07:32:26 <hodapp> sorry, just FooRecord, not FooRecord a
07:34:02 <Gothmog_> @pl \x -> length $ filter (\c -> c `elem` x) str
07:34:02 <lambdabot> length . flip filter str . flip elem
07:34:30 <hodapp> of course I don't even know if that will work. Yeah, it probably won't, because then I'd have the return type of the function depending on a value.
07:34:41 <lokathor> :t sqrt
07:34:42 <lambdabot> Floating a => a -> a
07:34:48 <Gothmog_> lokathor: Is that what you were looking for?
07:34:56 <lokathor> yep
07:35:58 <zerokarmaleft> with persistent, I've got an existing table keyed on three columns (EAV)...how do I define that with persistLowerCase?
07:37:30 <lokathor> Gothmog_, just need to check types for this: isSquare n = let root = truncate $ sqrt $ fromIntegral n in root * root == n
07:42:47 <hodapp> I suppose I could not make a function's type depend on a value (or, I dunno, can I do that?) but I could have a function give some specific call that resolves that type... bleah
07:43:09 <kqr> hodapp, having a type depend on a value is dependent typing, which haskell does not support
07:43:17 <kqr> hodapp, (though you might get close with various extensions to the type system)
07:43:30 <hodapp> kqr: that's precisely what I was thinking, but was also aware of the things that the Hasochism paper discusses
07:44:06 <hodapp> which are sort of kind of dependent typing, and this library uses GHC.TypeLits.Nat which sort of forces me into that territory
07:46:12 <hodapp> I don't know how a lot of this works, but if I had, for instance, forall n . GHC.TypeLits.KnownNat n => Int -> Proxy n  - then I'd assume that the *type* of first argument alone has to somehow resolve 'n'
07:46:59 <hodapp> either that or I'd have to explicitly specify the type
07:47:04 <hodapp> which would sort of defeat the function's purpose
07:49:00 <hodapp> but I could get rid of any reference to the existential 'n', yet still have the function internally rely on some KnownNat n, provided that is hidden in the type signature...
07:49:11 <hodapp> I'm sure there's some term for what I just described, I just don't know what it is
07:56:14 <c_wraith> hodapp: that's what SomeNat is for
07:57:24 <c_wraith> hodapp: pattern-matching on the SomeNat constructor allows you to get at the KnownNat instance.
07:57:25 <hodapp> c_wraith: merijn suggested that but the problem is that I don't know of any way to recover the KnownNat so that I can parametrize that external type over it
07:57:57 <hodapp> KnownNat instance as in type-level?
07:59:22 <c_wraith> yes.  You can call natVal with the Proxy value you get out of the pattern match.
07:59:57 <hodapp> I don't need to call natVal, I need some external type parametrized over the KnownNat
08:00:25 <c_wraith> You can do that, so long as it's entirely inside the pattern match.
08:00:44 <hodapp> not sure what you mean
08:01:28 <c_wraith> The type can't escape the scope in which it exists - the scope introduced in the pattern match.  But you can use it however you like inside that scope.
08:02:44 <hodapp> ahh... that might be able to work.
08:03:18 <merijn> hodapp: You'd have to write a Rank2 continuation passing style
08:03:24 <hodapp> not sure what other options I have, besides using heterogeneous collections or something
08:03:56 <merijn> i.e. "foo :: SomeNat -> (forall (n::Nat) . FooRecord n -> Bar) -> Bar"
08:05:31 <hodapp> I'll have to see if that works... I guess I may end up having to wrap large parts of the external API that all demand to be parametrized over 'n'
08:07:18 <hodapp> that or just ripping out all this crap and doing a pull request
08:12:15 <Denommus> :t (2^)
08:12:17 <lambdabot> (Integral b, Num a) => b -> a
08:12:22 <Denommus> what is this Integral typeclass?
08:12:44 <c_wraith> @src Integral
08:12:44 <lambdabot> class (Real a, Enum a) => Integral a where
08:12:44 <lambdabot>     quot, rem, div, mod :: a -> a -> a
08:12:44 <lambdabot>     quotRem, divMod :: a -> a -> (a,a)
08:12:44 <lambdabot>     toInteger       :: a -> Integer
08:13:05 <c_wraith> More or less, it's the class of things that can be converted to Integers
08:13:32 <c_wraith> Though integral division is also thrown in.
08:13:47 <Denommus> why does (^) require the second argument to be an Integral? Is there an equivalent function that accepts a division?
08:13:56 <Denommus> *that accepts a Fractional
08:13:56 <c_wraith> :t (^^)
08:13:58 <lambdabot> (Fractional a, Integral b) => a -> b -> a
08:14:02 <c_wraith> :t (**)
08:14:03 <lambdabot> Floating a => a -> a -> a
08:14:12 <c_wraith> You probably want that last one.
08:15:05 <mau}{ke]> Denommus: ^ simply does repeated multiplication
08:15:16 <Denommus> mau}{ke]: ah
08:15:17 <c_wraith> I thought it was repeated squaring
08:15:18 <mau}{ke]> ^^ also allows negative exponents
08:15:30 <mau}{ke]> squaring is multiplication
08:15:39 <mau}{ke]> ** is the fully general exp thing
08:15:47 <mau}{ke]> (but requires Floating)
08:16:12 <mau}{ke]> @src (^)
08:16:12 <lambdabot> x ^ 0            =  1
08:16:12 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
08:16:12 <lambdabot>   where f _ 0 y = y
08:16:12 <lambdabot>         f x n y = g x n
08:16:12 <lambdabot>           where g x n | even n    = g (x*x) (n `quot` 2)
08:16:14 <lambdabot>                       | otherwise = f x (n-1) (x*y)
08:16:16 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
08:16:59 <mau}{ke]> here x only needs to support *, which only requires Num
08:17:46 <Denommus> thanks for the help
08:25:30 <ysr> I was reading http://en.wikibooks.org/wiki/Haskell/Understanding_arrows article, but I am confused. If  "a b c" is an arrow from b to c, what is the difference between a function and an arrow
08:27:13 <mau}{ke]> functions are one kind of arrow
08:27:56 * hackagebot cndict 0.5.5 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.5.5 (DavidHimmelstrup)
08:28:15 <ysr> I am having difficulty understanding what might be a computation from a value to another but not be a function
08:28:16 <haskell192> anyone have experience installing gtk2hs for windows 8
08:28:41 <dolio> sinelaw: Yes, T -> (forall a. a -> a) and (forall a. T -> a -> a) are the same barring name capture.
08:28:46 <Denommus> ysr: a wire: http://hackage.haskell.org/package/netwire
08:29:21 <haskell192> anyone have experience installing gtk2hs for windows 8
08:29:35 <sinelaw> dolio, thanks! I have a complex example that still confuses me, will try to get the minimal confusing case later 
08:29:41 <sinelaw> variance is tricky
08:29:44 <sinelaw> (for me)
08:29:53 <dolio> Yeah, I think I saw it, and didn't feel like figuring out what the answer was. :)
08:30:03 <Denommus> ysr: an arrow is a more general abstraction than a function, just like a functor is a more general abstraction than a list
08:32:57 * hackagebot text-position 0.1.0.0 - Handling positions in text and position-tagging it.  http://hackage.haskell.org/package/text-position-0.1.0.0 (akrasner)
08:34:55 <Denommus> ysr: so there are some things that you can do with both functions and arrows (like composition), but some things that are specific to functions (like... function application)
08:35:31 <fr33domlover> Hackage question: It seems I can't edit tags for my package
08:35:35 <fr33domlover> Is this normal?
08:35:37 <ysr> so you cant for example apply and arrow to a list?
08:35:48 <ysr> *apply an arrow*
08:36:37 <Denommus> ysr: what do you mean? Making a list of arrows? Of course you can, you can make a list over any value, including arrows and functions. I don't see how that's related, though
08:37:07 <ysr> no I mean can you fmap an arrow to a list?
08:37:25 <ysr> what would you get if you can
08:37:28 <Denommus> ysr: I have no idea what that means
08:37:52 <jameseb> ysr: no, fmap takes a function as it's first argument
08:37:57 <Denommus> ysr: I used lists as an example of a specific abstraction. Lists and arrows have no relationship
08:38:45 <Denommus> ysr: except both are applicative functors, but you can't fmap a functor from one type to a functor of other type (e.g., you can't fmap from a IO to a Maybe)
08:38:58 <Denommus> :t fmap
08:38:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:39:49 <Denommus> ysr: what I meant was that if you have a variable foo :: Arrow a => a Int Int you can't do foo 1
08:40:53 <Denommus> ysr: but if you have foo :: Arrow a => a b c and bar :: Arrow a => a b c you can do bar . foo, because you can compose arrows just like you can compose functions
08:41:35 <ysr> But a function is an arrow and you can apply a function, why can't you apply an arrow?
08:42:31 <mau}{ke]> but a list is a monad and you can take the length of a list, why can't you take the length of a monad?
08:42:48 <Denommus> ysr: a list is a monad and you can call the function head on a list. Why can't you call head on IO?
08:43:08 <mau}{ke]> > length getChar
08:43:09 <lambdabot>      No instance for (Foldable IO) arising from a use of ‘length’
08:43:10 <lambdabot>      In the expression: length getChar
08:43:21 <Denommus> > head getChar
08:43:22 <ion> @hoogle Arrow a => a b c -> a [b] [c]
08:43:22 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
08:43:22 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
08:43:23 <lambdabot>      Couldn't match expected type ‘[a]’ with actual type ‘IO Char’
08:43:23 <lambdabot>      In the first argument of ‘head’, namely ‘getChar’
08:43:23 <lambdabot>      In the expression: head getChar
08:44:08 <Denommus> ysr: function application is specific from functions. That's it. Arrows don't describe application, they describe composition
08:49:44 <joneshf-laptop> is there something like aeson but for any arbitrary data format?
08:50:29 <heatsink> joneshf-laptop: You mean parsing and serializing data to/from an arbitrary data format?
08:51:02 <joneshf-laptop> heatsink, yeah, though more concerned about the from at the moment
08:51:41 <heatsink> Seems like attoparsec is popular for that
08:51:45 <heatsink> it's a parser combinator library
08:54:15 <joneshf-laptop> well i'm using parsec right now, and though I've never used attoparsec in anger there's not much difference between these two is there?
08:54:32 <heatsink> No, there's not
08:58:24 <samgd> Is there an idiomatic way to finding the max value in a, for example, `Map String Integer' and returning its associated key?  I've got `http://pastebin.com/V3Y6fJFv'
08:59:17 <samgd> Map.foldr1WithKey would be a little nicer but I don't think it exists
08:59:57 <heatsink> samgd: You could use foldr from Foldable
09:00:09 <heatsink> Oh wait, I missed the "associated key" part
09:00:21 <bartavelle> samgd, you can have something shorted with maximumBy
09:00:27 <bartavelle> except it's partial :/
09:01:06 <samgd> Sorry, shorted?
09:01:13 <bartavelle> errr, shorter
09:01:16 <samgd> ah
09:01:28 <bartavelle> maximumBy snd . M.toList
09:01:40 <bartavelle> but you'll have to handle the empty list case
09:04:08 <samgd> Makes it a little neater though, thanks bartavelle!
09:04:16 <bartavelle> np
09:04:47 <michaelt> doesn't findMax :: Map k a -> (k, a) work samgd ?
09:04:48 <joneshf-laptop> i feel like there's a case forinverting the map
09:04:53 <joneshf-laptop> andjust using `findMax`
09:05:04 <joneshf-laptop> or `maxView`
09:05:06 <michaelt> oh, I see
09:05:33 <joneshf-laptop> if you're using `max` or somehting you kow it's got an `Ord a` constraint
09:05:37 <joneshf-laptop> so you know you can invert it
09:06:02 <joneshf-laptop> and if you have more than one of the same value, you'd have to handle collisions anyway with any other method
09:06:07 <bartavelle> it's much more expensive to invert it than to simple fold through the values
09:06:24 <bartavelle> simply
09:06:35 <joneshf-laptop> thats probably true
09:06:39 <michaelt> does maxView :: Map k a -> Maybe (a, Map k a) yield the largest value and the 'rest of the map'?
09:07:25 <joneshf-laptop> michaelt, yeah, wrapped in a `Maybe`
09:07:43 <bartavelle> michaelt, give the  value associated with the maximal *key*
09:08:04 <bartavelle> the question was the key associated with the maximal value if I'm not mistaken
09:08:46 <michaelt> yeah I failed to register this at first, but now I see it clearly enough ...
09:09:47 <michaelt>  maxView goes by the maximum value, not key, it seems.
09:10:36 <michaelt> > M.maxView $ fromList [("b",1), ("a", 2)]
09:10:37 <lambdabot>  Just (1,fromList [("a",2)])
09:10:57 <bartavelle> maximum key right ?
09:11:01 <michaelt> > M.maxViewWithKey $ fromList [("b",1), ("a", 2)]
09:11:02 <lambdabot>  Just (("b",1),fromList [("a",2)])
09:11:21 <joneshf-laptop> it can't go by value
09:11:24 <michaelt> Isn't this the answer ^^^?
09:11:35 <joneshf-laptop> there'sno `Ord` on the value
09:11:44 <michaelt> oh man forget this, I'm suffering from a different confusion
09:11:52 <michaelt> yes it's nonsense
09:12:02 <michaelt> the fold is the way forward clearly
09:13:53 <michaelt> > (foldr1 max . M.fromList) [("b",1), ("a", 2)]
09:13:55 <lambdabot>  2
09:14:27 <bartavelle> then you don't have the key ;)
09:14:53 <bartavelle> > maximumBy  snd $ M.toList $ M.fromList [("b",1), ("a", 2)]
09:14:54 <lambdabot>      Occurs check: cannot construct the infinite type:
09:14:54 <lambdabot>        a ~ ([Char], a) -> Ordering
09:14:54 <lambdabot>      Expected type: ([Char], a) -> ([Char], a) -> Ordering
09:15:08 <bartavelle> oh
09:15:48 <bartavelle> > maximumBy  (comparing snd) $ M.toList $ M.fromList [("b",1), ("a", 2)]
09:15:49 <lambdabot>  ("a",2)
09:17:43 <michaelt> > let maxval = foldrWithKey (\k a m -> case m of Nothing -> Just (k, a); Just (k',a') -> if a' > a then Just (k',a') else Just (k,a)) Nothing  in maxval $ fromList  [("b",1), ("a", 2)]
09:17:44 <lambdabot>      Not in scope: ‘foldrWithKey’
09:17:44 <lambdabot>      Perhaps you meant one of these:
09:17:44 <lambdabot>        ‘IM.foldrWithKey’ (imported from Data.IntMap),
09:17:53 <michaelt> > let maxval = M.foldrWithKey (\k a m -> case m of Nothing -> Just (k, a); Just (k',a') -> if a' > a then Just (k',a') else Just (k,a)) Nothing  in maxval $ fromList  [("b",1), ("a", 2)]
09:17:54 <lambdabot>  Just ("a",2)
09:19:03 <hodapp> c_wraith: I'm trying to figure out how to use a scope in a pattern match like you were saying, but can't seem to figure out the means of doing this
09:19:53 <c_wraith> hodapp: I'll put together an example.  Give me a couple minutes.
09:20:19 <hodapp> just trying to write a function like foo :: SomeNat -> Foo, foo (SomeNat n) = getFoo (blah :: SomeType n)
09:21:02 <c_wraith> hodapp: Ok, I'll give an example..
09:22:01 <hodapp> alright, thanks
09:22:11 <rui1> So, what's new with haskell these last 2 months?
09:22:24 <c_wraith> GHC 7.10 released with huge prelude changes.
09:22:44 <rui1> :)
09:23:10 <mau}{ke]> :t length
09:23:11 <lambdabot> Foldable t => t a -> Int
09:23:14 <hodapp> I have not ever worked with type scopes that a pattern match introduces and I'm having a hard time finding much in searches about this
09:23:14 <Denommus> ... I just noticed I'm using GHC 7.10, and that class Applicative m => Monad (m :: * -> *) where ... :D
09:24:02 <michaelt> > let maxval = M.foldlWithKey' op Nothing; op Nothing k b = Just (k,b) ; op p@(Just (k',b')) k b = if b > b' then Just (k, b) else p in maxval $ M.fromList  [("b",1), ("a", 2)]
09:24:04 <lambdabot>  Just ("a",2)
09:24:35 <michaelt> a left fold is maybe best here? 
09:25:58 <notthemessiah> best picture of edwardk: bodil.org/how-to-get-shit-to-work-right/#29
09:27:13 <mau}{ke]> real url: http://bodil.org/how-to-get-shit-to-work-right/m/kmett.jpg
09:27:49 <joneshf-laptop> wait
09:27:49 <joneshf-laptop> wait
09:27:50 <joneshf-laptop> wait
09:28:02 <joneshf-laptop> doesn't `fromList` give you an already sorted list?
09:28:06 <joneshf-laptop> by key?
09:28:13 <michaelt> sorted by key surely
09:28:24 <joneshf-laptop> why not just use that to your advantage?
09:28:33 <c_wraith> hodapp: http://lpaste.net/271722879802933248
09:28:50 <joneshf-laptop> erm `toList`
09:28:57 <c_wraith> hodapp: note that I went a little roundabout just to demonstrate creating values of another type using the same type literal
09:29:08 <c_wraith> hodapp: But that works just fine.
09:29:23 <joneshf-laptop> > M.toList $ M.fromList [(1, 'a'), (10, 'b'), (5, 'c')]
09:29:24 <lambdabot>  [(1,'a'),(5,'c'),(10,'b')]
09:29:43 <joneshf-laptop> > snd $ last $ M.toList $ M.fromList [(1, 'a'), (10, 'b'), (5, 'c')]
09:29:44 <lambdabot>  'b'
09:29:59 <c_wraith> hodapp: the most important thing is that GHC won't allow the type `n' to escape from foo, because it only exists *inside* foo.
09:30:06 <joneshf-laptop> last makes it O(n) though doesn't it?
09:30:19 <c_wraith> last will always be O(n), yes.
09:30:50 <joneshf-laptop> oh wait, you want max value, dang i forgot that again
09:31:09 <c_wraith> as long as M is Data.Map, though, that won't matter much.  Using the Map for anything will require it to force the entire structure of the tree
09:31:52 <c_wraith> > foldr1 max $ M.fromList [(1, 'a'), (10, 'b'), (5, 'c')]
09:31:53 <lambdabot>  'c'
09:32:03 <c_wraith> yay, GHC 7.10 tricks.
09:32:13 <hodapp> c_wraith: okay, that makes some more sense. I was matching over (SomeNat n) when I needed (SomeNat (p :: Proxy n))
09:32:43 <c_wraith> hodapp: you could even match on (SomeNat (_ :: Proxy n)) if you only need the type in scope, and not the proxy
09:32:45 <hodapp> though, I still need to get a better handle on what "data Bar (n :: Nat)" means
09:33:02 <michaelt> > maximum  $ M.fromList [(1, 'a'), (10, 'b'), (5, 'c')]
09:33:04 <lambdabot>  'c'
09:33:18 <c_wraith> oh, right, maximum was generalized too
09:33:25 <joneshf-laptop> ah
09:33:29 <joneshf-laptop> then that makes sense
09:33:33 <joneshf-laptop> well there you go
09:33:55 <hodapp> is that a constraint on what kinds Bar may be parametrized over?
09:34:03 <c_wraith> hodapp: yes
09:34:07 <hodapp> okay
09:34:27 <c_wraith> hodapp: it's the kind signature that the extension was turned on to allow
10:02:27 <nschoe> Hey fellow haskellers, I'm trying to experiment with happstack sessions: http://hackage.haskell.org/package/happstack-clientsession-7.2.7/docs/Happstack-Server-ClientSession.html , they mention a link (on patch-tag) demonstrating an alternate version of the demo with newtypes used rather than long transformer monad names, but the link is broken
10:02:38 <nschoe> Any chance you guys know the new location of that code?
10:09:40 <michaelt> nschoe: like so https://github.com/Happstack/happstack-temporary/blob/master/happstack-clientsession/demo/demo.hs
10:10:04 <safinaskar> class (Monad m) => MonadError e m | m -> e where
10:10:11 <safinaskar> what means this strange syntax?
10:10:15 <edwardk> could someone do a quick review on https://www.fpcomplete.com/user/edwardk/fibonacci/search before it goes out to a wider audience?
10:10:23 <safinaskar> i understand "class (Monad m) => MonadError e m where"
10:10:29 <safinaskar> but what means this "| m -> e"?
10:10:33 <geekosaur> safinaskar, the type of m determines the type of e
10:10:38 <nschoe> michaelt, Thank !
10:10:40 <nschoe> +s
10:10:49 <geekosaur> without something like that type inference would fall apart and you would have to annotate all uses of that monad
10:10:51 <edwardk> safinaskar: | m -> e tells you that if you know m you get to know e. there can't be two different instances with the same m and different 'e's
10:11:22 <edwardk> safinaskar: it describes a "functional dependency" which is nomenclature borrowed from the database/relational algebra world.
10:12:39 <safinaskar> geekosaur: edwardk: thanks
10:18:00 * hackagebot list-t-text 0.2.0.0 - A streaming text codec  http://hackage.haskell.org/package/list-t-text-0.2.0.0 (NikitaVolkov)
10:18:17 <safinaskar> runMaybe :: (MonadError String m) => Maybe a -> m a
10:18:23 <safinaskar> what is wrong with this code?
10:18:32 <safinaskar> why it gives compilation error?
10:19:22 <geekosaur> that's just a signature, not code
10:19:27 <geekosaur> @paste full code, full error message
10:19:27 <lambdabot> Haskell pastebin: http://lpaste.net/
10:23:01 * hackagebot matrices 0.4.1 - native matrix based on vector  http://hackage.haskell.org/package/matrices-0.4.1 (kaizhang)
10:23:03 * hackagebot fasta 0.5.4.0 - A simple, mindless parser for fasta files.  http://hackage.haskell.org/package/fasta-0.5.4.0 (GregorySchwartz)
10:23:13 <safinaskar> please type this site in your browser: http://www.tutorialspoint.com/codingground.htm
10:23:19 <safinaskar> is it work for you?
10:23:24 <safinaskar> it is not working for me
10:23:49 <ackthet> is there a way in command line hoogle to only search specific libraries?
10:25:15 <alpounet> ~~
10:25:25 <alpounet> oops, sorry
10:25:55 <Twiggles> Has anyone happen to run into this error with GHC 6.10.1 while trying to import Data.Graph?
10:25:56 <Twiggles> Main.o: In function `sTp_info': (.text+0x26b3): undefined reference to `__stginit_containerszm0zi2zi0zi0_DataziGraph_' collect2: ld returned 1 exit status
10:26:08 <Twiggles> Not sure what is going on there
10:26:35 <ackthet> i guess not
10:28:08 <belst> question: how can i read sth like "5F" to Word8?
10:28:25 <Twiggles> Oh, I added "--make" to the arguments for GHC and it compiled
10:31:09 <michaelt> Twiggles: you are using ghc 6.10?
10:31:30 <Twiggles> michaelt:  yes
10:31:45 <Twiggles> is there a way to get it to link without designating --make?
10:31:51 <bennofs> Twiggles: btw, you might want to update GHC. 6.10 is pretty old in Haskell world ... (current "stable" would be 7.8 which should be able to compile most packages, while 7.10 could still lead to some failures b.c. packages have not been adapted yet)
10:32:33 <michaelt> Twiggles: it's really really old; what operating system are you using.  
10:33:01 * hackagebot diversity 0.6.0.1 - Return the diversity at each position for all sequences in a fasta file  http://hackage.haskell.org/package/diversity-0.6.0.1 (GregorySchwartz)
10:37:01 <nschoe> Hum.. I'm trying to use happstack-clientsession. But it won't build as-is because I have a more recent version of happstack-server. So I created a saparate sandbox, usd cabal get happstack-clientsession, remove the upper bound, made cabal install --only-d in it. Then in my first sandbox (my project) I cabal sandbox add-source the folder in which I created the second sandbox.
10:38:11 <nschoe> But then, 1) if I add 'happstack-clientsession' in 'Build depend', it tries to install the old version of happstack-sever, so I suppose it is actually tryign to install the hackage version of happstack-client session, and 2) if I don't add it in the .cabal file, it doesn't compile :/
10:38:15 <nschoe> What am I missing?
10:38:35 <geekosaur> I think you're suppsoed to just unpack into a subdirectory of the first sandbox and add-source that
10:38:44 <geekosaur> and cabal will build it as part of the sandbox
10:39:03 <geekosaur> not make a separate sandbox for happstack-clientsession
10:39:38 <geekosaur> oh, I see, you did that backwards
10:39:45 <nschoe> geekosaur, okay so I do cabal get happstack-clientsession, then it gives me a folder named 'happstack-clientsession-7.2.7'
10:39:49 <geekosaur> but, same answer. no second sandbox
10:39:53 <geekosaur> yes
10:39:54 <nschoe> And that is *that* folder that I must add-source ?
10:39:58 <geekosaur> yes
10:40:23 <nschoe> geekosaur, and I should add 'happstack-clientsession' as a dependendy in my .cabal project, right?
10:40:30 <geekosaur> well, wait. not sure exacvtly, I think I understood youy backwards last time
10:40:48 <nschoe> ah ^^
10:40:50 <geekosaur> happstack-clientsession depends on happstack-server
10:40:54 <nschoe> yes.
10:41:08 <geekosaur> you do not want to make happstack-server depend on happstack-clientsession
10:41:17 <nschoe> No no
10:41:27 <nschoe> But I want to make my project depends on happstack-clientsession
10:41:40 <geekosaur> ok, so what I said should work
10:41:44 <nschoe> BUt my projectalreayd depends on happstack-server-the-latest
10:41:58 <geekosaur> does it absolutely require the latest?
10:42:16 <geekosaur> hm, wait, you were looking to adjust the bound on happstack-clientsession
10:42:17 <nschoe> geekosaur, no it doesnt. I simply did not put any version and so it picked the latest.
10:42:48 <geekosaur> so probably what I said would work
10:43:12 <geekosaur> but it also seems to me that a possibly easier workaround, with a sufficiently recent cabal, is --allow-newer=happstack-server
10:43:53 <geekosaur> rather than editing dependencies
10:44:13 <nschoe> geekosaur, ah! I did not even know that option existed.
10:44:18 <belst> hey guys, how can i get my own MAC Address as ByteString?
10:44:33 <geekosaur> it's fairly recent, and intended exactly for this use case because it comes up so much
10:44:55 <nschoe> geekosaur, but in this case, where should I put that option ?
10:45:01 <geekosaur> command line
10:45:25 <geekosaur> I don't know if there's a corresponding thing you can stick in cabal.sandbox.config
10:45:34 <nschoe> No I mean, should I simply add 'happstack-clientsession' into my original .cabal file, and simply use cabal isntal --only-d --allow-newer=happsta...
10:45:35 <nschoe> ?
10:45:45 <geekosaur> yes
10:45:56 <nschoe> geekosaur, thank you very much. I'm trying that right now.
10:45:58 <safinaskar> why this doesn't compile? http://paste.debian.net/169667/
10:46:11 <geekosaur> you could also see if you can put that in the cabal.sandbox.config as: allow-newer: happstack-server
10:46:19 <c_wraith> safinaskar: because you didn't enable FlexibleContexts
10:46:25 <c_wraith> safinaskar: (just like the error message says)
10:46:30 <geekosaur> belst, not sure you can becuase it's horribly system dependent
10:46:40 <geekosaur> windows does one thing, bsd/os x another, linux a third
10:47:00 <c_wraith> safinaskar: FlexibleContexts is a 100% safe extension.  You should never feel the slightest bit worried about enabling it.
10:47:25 <belst> geekosaur: well it only works on linux atm anyway since i use AF_PACKET. So only for linux would be sufficent
10:47:28 <michaelt> safinaskar: (MonadError String m) =>  is a 'flexible context' MonadError s m => Monad (Goo s m) where ... wouldn't be
10:48:21 <michaelt> safinaskar: so you need to add {-#LANGUAGE FlexibleInstances #-} or adopt some other measure
10:48:37 <safinaskar> michaelt: c_wraith: thanks
10:48:45 <michaelt> FlexibleContexts rather. bah
10:50:44 <geekosaur> belst, you'll need to turn http://stackoverflow.com/questions/1519585/how-to-get-mac-address-for-an-interface-in-linux-using-a-c-program into a function and FFI to it
10:51:50 <belst> well thats bad :/ another thing is, How can i bind a socket to a specific interface?
10:53:23 <geekosaur> you have to know the interface address (use ifconfig or ip; this too is nasty and nonportable from C and not available directly from Haskell unless there's something on Hackage)
10:53:26 <KaneTW> @src (++)
10:53:26 <lambdabot> []     ++ ys = ys
10:53:26 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
10:53:26 <lambdabot> -- OR
10:53:26 <lambdabot> xs ++ ys = foldr (:) ys xs
10:53:30 <geekosaur> and bind to that address specifically
10:53:57 <KaneTW> what's the runtime of ++ when strictly evaluated depending on length of xs and ys
10:54:01 <belst> geekosaur: damn... i want to get the interface as an argument. like ./a -i eth0 or so
10:54:48 <geekosaur> strace tcpdump and see what it does
10:56:52 <nschoe> geekosaur, Thank you for your help.
10:56:56 <nschoe> It seemed to have worked.
10:57:42 <nschoe> Although it downgraded monad-control from 1.0.0.4 to 0.3.3.1. I hope nothing is broken ^^
10:58:02 * hackagebot dove 0.0.0 - The Dove verification language.  http://hackage.haskell.org/package/dove-0.0.0 (TomHawkins)
10:58:07 <geekosaur> as long as it's inb the sandbox you're probably ok
10:59:08 <nschoe> Everything is in the sandbox.
10:59:19 <geekosaur> belst, actually, save yourself some trouble: http://hackage.haskell.org/package/pcap-0.4.5.2/docs/Network-Pcap.html
10:59:25 <nschoe> I make a point of never building anything (but happy, alex and haddock) in global ^6
11:00:06 <geekosaur> and http://www.tcpdump.org/#documentation for details on using libpcap
11:00:22 <Hijiri> any binaries I want I install in user db
11:00:55 <Hijiri> until things start clashing, then I clear the db and leave the already-compiled binaries there
11:01:15 <geekosaur> install in sandbox, copy the binary to somewhere common
11:05:58 <michaelt> nschoe: I may or may not have repaired it. The monad-base-control business is a little painful  https://github.com/michaelt/happstack-temporary/tree/master/happstack-clientsession
11:06:41 <nschoe> michaelt, xD well I got it working apparently.
11:06:50 <nschoe> I'm trying the demo as we speak.
11:07:05 <michaelt> actually, it occurs to me there is certainly at least one disaster ... hm.
11:07:08 <nschoe> I have a little work to do because I'm not familair with Lens, so I'm tryign to figure out what parts to remove and how to replace them.
11:07:32 <nschoe> michaelt, one disaster... by downgrading to 0.3* as I did or by using your new version with 1.* ?
11:08:20 <michaelt> i was trying to update it. MonadBaseControl now uses an associated type, not an associated newtype
11:10:06 <nschoe> michaelt, okay. So it might be tricker to fix, is that what you ar esaying ?
11:10:39 <michaelt> nschoe: I think it's pretty simple, but I made it a little simple ... 
11:11:02 <nschoe> ah ahok
11:11:43 <arboris> has anyone gotten auto-completion that takes into account symbols from imported packages to work in emacs, so far all I have achieved is either haskell-mode reloading all symbols of one package on every keystroke, or no completion at all... it is really frustrating, I had it working before, but can't figure out what changed
11:13:03 * hackagebot BCMtools 0.1.0 - Big Contact Map Tools  http://hackage.haskell.org/package/BCMtools-0.1.0 (kaizhang)
11:15:42 <gremble> The first paragraph on "what is a monad" is probably the most complicated piece of prose that I've ever read.
11:15:51 <gremble> *in the haskell wiki
11:17:05 <Denommus> gremble: I still don't understad why people overcomplicate monads so much
11:17:37 <Denommus> "a type that has a bind and a return operations that follows left identity, right identity and associativity laws is a monad"
11:17:39 <Denommus> that's it
11:17:46 <Denommus> I defined a monad
11:17:53 <Denommus> everybody understands that
11:18:12 <johnw> you realize that doesn't motivate what monads are useful for to anyone who doesn't alreday know what they are useful for?
11:18:27 <johnw> it's not just about defining what the Monad type class consists of
11:18:46 <BlackCrypt0> What would anyone say about allowing a stored procedure to make a call to a web application.  We have typically always prevented it through a security zone configuration but now a vendor says that want to do this for a specific reason.  I understand their reason and it is valid but we have never let a DB make a call to a web app
11:18:48 <Denommus> johnw: I realize that. What I don't realize is how you want to explain what something is useful for before trying to explain what it is
11:19:11 <johnw> because people need a context in which to slot information sometimes
11:19:35 <Denommus> johnw: if you try to first explain what it's useful for you'll end up with "a monad is like a burrito"
11:19:35 <geekosaur> BlackCrypt0, this is probably not the best channel to ask that
11:19:59 <BlackCrypt0> geekosaur, sorry wrong window...
11:20:15 <johnw> well, I prefer not to jump into "monads in the abstract" in the first place at all
11:20:28 <Denommus> johnw: another approach is to present how you can work with bind and return over lists, Maybe and IO and then say "look what they have in common. They have bind and return, they follow these laws. They are monads"
11:20:38 <Denommus> johnw: that's it. No stupid "a monad is like a burrito" analogy
11:20:52 <dolio> Who said anything about burritos?
11:21:03 <Denommus> dolio: that's a common joke
11:21:44 <Denommus> https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
11:27:34 <dolio> I don't think 'burritos' has anything to do with explaining what monads are useful for. It is (a parody of) an attempt to give an intuitive account of the bare operations of the class.
11:28:03 * hackagebot singleton-nats 0.1.1.0 - Unary natural numbers relying on the singletons infrastructure.  http://hackage.haskell.org/package/singleton-nats-0.1.1.0 (AndrasKovacs)
11:28:07 <johnw> I don't even get how the burrito analogy helps.  It's not like you use the innards of one burrito to make a new one, and then merge the tortillas together
11:28:35 <gremble> I don't even know what a burrito is. 
11:28:47 <johnw> stuff wrapped in flat bread
11:28:54 <cite-reader> Food in tube form.
11:29:08 <gremble> Ah
11:29:14 <edwardk> johnw: clearly this analogy is about a dystopian future where that is the way you have to conserve food
11:29:20 <fryguybob> I'm pretty sure a burrito has to be experienced, not explained.
11:29:21 <johnw> edwardk: hahaha
11:29:54 <johnw> edwardk: "This burrito's wrapper sucks!  I know, I'll bind this improvement function and incorporate the old tortilla to conserve food"
11:30:15 <nschoe> michaelt, sorry to ask, but I'm wondering about the 'emptySession'
11:30:24 <cite-reader> I wrapped a burrito in another burrito. I call it a burrito transformer.
11:30:40 <johnw> you'd have to wrap it in another tortilla
11:30:43 <benzrf> auugh why cant i build this crap on ghc 7.10
11:30:51 <dolio> I think that's enough burritos.
11:30:51 <nschoe> When I make my custon type SessionData an instance of ClientSession I must define what an emptySession is. In case of a counter like in the demo, it's okay, empty counter is 0.
11:31:00 <johnw> dolio: it was about a year ago in fact
11:31:13 <koala_man> Super is a burrito transformer that adds guacamole and sour cream to any burrito
11:31:17 <dolio> More than that.
11:31:31 <johnw> it's a very hardy meme
11:31:37 <nschoe> But I'm dealig with a user on a website. What is my emptySession now?
11:38:03 * hackagebot Earley 0.7.0 - Parsing all context-free grammars using Earley's algorithm.  http://hackage.haskell.org/package/Earley-0.7.0 (OlleFredriksson)
11:38:12 <gremble> With the risk of showing my ignorance, according to what I understand from the haskell wiki, "main" could be understood as a monad as it combines a bunch of computations?
11:38:46 <c_wraith> only types are monads.
11:38:53 <gremble> Ah
11:39:00 <johnw> only type formers are monads
11:39:02 <johnw> of kind * -> *
11:39:08 <johnw> only those *can be*
11:39:14 <johnw> not all are
11:40:40 <geekosaur> main is a monadic computation. in IO these are often referred to as monadic actions
11:40:58 <geekosaur> (the "action" terminology is dubious at best when applied to monads like Maybe or [])
11:41:13 <johnw> note that in the case of a definition like "main = print "foo"", no Monad is ever involved
11:41:36 <johnw> so it's not that main or IO is monadic, but that Monad can be used to chain multiple action within main in a conveniant way
11:44:20 <guest1> I seem to remember a GHC bug where a concat was done with `foldl (++)' causing an O(n^2) step in compilation and it was changed to foldr (or possibly the other way around?) which led to a huge speed-up in compilation times. Does anybody remember which patch that was in? I tried search for articles about it but to no avail.
11:44:38 <mizu_no_oto> gremble: the 'joke' that "A monad is just a monoid(al object) in the (monoidal) category of (endo)functors" boils down to "A monad in Haskell is the functions fmap, return and join for a given type"
11:44:45 <c_wraith> guest1: cabal-install had a bug like that not too long ago.  Is that what you're thinking of?
11:44:54 <guest1> c_wraith: yes, thanks
11:45:05 <ReinH> geekosaur: "monad action" makes me sad because it collides with "monoid action"
11:45:18 <Chousuke> gremble: the way I understand it is that values of type IO a are abstract representations of sequential programs that can be executed by something (the haskell runtime). main is just a special value.
11:45:41 <Chousuke> and one way to compose such values happens to fit the monad abstraction
11:46:52 <ReinH> You could use a special function then :: IO a -> (a -> IO b) -> IO b instead: readLine `then` \line -> putStrLn line
11:48:40 <Chousuke> the key point in understanding the signature of the bind function in the above case is that while "readLine" is a program on its own, "putStrLn" isn't. Think about it: what are you putting to the screen?
11:49:09 <Chousuke> so you need that function to take the output from readline and feed it to putStrLn so you have a program again
11:50:54 <eacameron1> I have ` -with-rtsopts="-I0 -qg -qb" ` in cabal's ghc-options field, but it's complaining; something about the quotes is not right. anyone hit this?
11:51:34 <dcoutts> eacameron: if you need to use quotes in a .cabal file, you need to use Haskell String syntax
11:51:35 <dcoutts> e.g.
11:51:47 <dcoutts> ghc-options: "-with-rtsopts=-I0 -qg -qb"
11:51:55 <dcoutts> to make it a single argument
11:52:20 <dcoutts> it's not bash/shell quoting syntax
11:52:26 <ReinH> dcoutts: have you seen the project that uses yaml to represent and generate a cabal file?
11:52:33 <dcoutts> ReinH: yes
11:52:36 <ReinH> dcoutts: thoughts?
11:52:43 <lumo_e> Hi
11:52:50 <dcoutts> ReinH: I've had it pointed out before that it's similar to yaml
11:52:54 <lumo_e> is there any library to write data in ELF format?
11:52:57 <ReinH> modulo libyaml being a POS, I think it's promising.
11:53:00 <lumo_e> I can't find any
11:53:01 <dcoutts> ReinH: but I'm not sure quite where it gets us
11:53:04 <lumo_e> what should I use instead?
11:53:07 <eacameron> dcoutts: Sweet! that did it
11:53:09 <eacameron> thanks
11:53:09 <hexagoxel> eacameron: -with-rtsopts "-H2G -M4G -N"
11:53:14 <hexagoxel> should work as well
11:53:27 <ReinH> dcoutts: I guess the question could be what having a unique, non-standard format gets us.
11:53:50 <dcoutts> ReinH: the difficulty of moving is we'd need our own parser that understood both
11:54:17 <ReinH> dcoutts: You can parse both into the same IR, yeah
11:54:39 <dcoutts> ReinH: I just got to the stage of having the existing cabal syntax with a proper parsec grammar :-)
11:54:56 <ReinH> dcoutts: The advantage to YAML is that it already has a grammar
11:55:12 <ReinH> You just need to do an AST transform
11:55:47 <ReinH> A minor annoyance to .cabal files is I still haven't gotten emacs to handle indenting them properly
11:58:21 <dcoutts> ReinH: it's not too bad. There's a few things that are syntactically less nice, but it's not too bad.
11:58:58 <ReinH> dcoutts: I think custom file formats should justify their existence with something stronger than "it's not too bad" ;)
11:59:10 <dcoutts> ReinH: I was talking about the yaml form
11:59:17 <ReinH> dcoutts: heh :)
11:59:20 <dcoutts> :-)
11:59:26 <mmachenry> When I was on cabal-1.20 my unit test coverage .tix files was created in dist/hpc/tix/hspec/hspec.tix and worked fine on reruns. Now that I've upgraded to 1.22 it's created in the root directory of my project and I get an error message saying I need to delete it every time I try to do a "cabal test" What am I doing wrong?
12:01:52 <vin-ivar> so
12:01:56 <dcoutts> ReinH: I'd like to see if there's a better approach than the " tests: \n spec: " style, syntactically.
12:02:07 <dcoutts> ReinH: and how one would do the if-then-else conditionals
12:02:15 <vin-ivar> if i want to install a package
12:02:28 <vin-ivar> and it doesn't compile correctly with the latest GHC
12:02:28 <ReinH> dcoutts: if:\n  then:\n  else: I suppose
12:02:31 <vin-ivar> what options do I have?
12:02:31 <michaelt> mmachenry: I noticed that it defaults to putting the tix files in the main directory. there is also an .hpc subdirectory .  
12:02:58 <michaelt> vin-ivar: well, what is causing the disaster? you can patch it ... 
12:03:04 * hackagebot list-t-text 0.2.0.1 - A streaming text codec  http://hackage.haskell.org/package/list-t-text-0.2.0.1 (NikitaVolkov)
12:03:09 <vin-ivar> I tried, unfortunately, but no luck
12:03:25 <vin-ivar> "Ambiguous occurrence ‘<*>’" is the error
12:03:37 <vin-ivar> I tried both the prefixes but they just lead to more errors
12:03:52 <mmachenry> michaelt: Does everyone just delete that file every time they run cabal test? I imagine not. 
12:04:35 <_m_ryan> hi what is the function that i use to read and excel file? thank you
12:04:42 <vin-ivar> so, yeah - what options? downgrade GHC?
12:04:52 <michaelt> mmachenry: there are options for cabal test or indeed for the dist/x/y/z test executable ... I'm powerless before these curiosities though
12:05:27 <michaelt> vin-ivar: what's the package. If it has its own implementation of (<*>) I'm a little worried it's an antique
12:06:03 <vin-ivar> http://hackage.haskell.org/package/fst-0.10.0.0/
12:06:14 <napping> ollef: Hi, are we both online now?
12:06:15 <vin-ivar> it is rather old, but nonetheless
12:08:43 <bernalex> napping: ollef's online nearly 24/7. if you OTOH mean if he's at his keyboard, you'd have more luck 6h ago I think. it's 9pm here. :)
12:08:57 <napping> Ok
12:09:09 <michaelt> _m_ryan: http://hackage.haskell.org/package/xlsx-0.1.0.4/docs/Codec-Xlsx.html maybe?
12:09:53 <michaelt> _m_ryan: it uses lenses; the other up-to-date seeming option uses conduits... hm
12:11:02 <michaelt> vin-ivar: https://github.com/johnjcamilleri/fst seems to have recent updates not yet on hackage
12:11:44 <vin-ivar> oh, fancy that
12:11:48 <vin-ivar> it looks recent
12:13:05 * hackagebot UISF 0.3.0.2 - Library for Arrowized Graphical User Interfaces.  http://hackage.haskell.org/package/UISF-0.3.0.2 (dwincort)
12:13:32 <michaelt> vin-ivar:  git clone https://github.com/johnjcamilleri/fst && cabal install ./fst worked here ...
12:15:03 <chpatrick> anyone have a need for a conduit that processes JSON arrays element by element?
12:16:01 <vin-ivar> yes, it works for me too, michaelt 
12:16:07 <vin-ivar> thanks, i'm awfully grateful :)
12:16:50 <michaelt> vin-ivar: oh I see he does have a slightly deranged choice of operators https://github.com/johnjcamilleri/fst/blob/master/FST/RegTypes.hs you will have to hide stuff from Control.Applicative or import something qualified 
12:17:16 <vin-ivar> ah, I don't plan to use it, it's a dependency for another library i'm using
12:17:21 <vin-ivar> i'm sure they're aware
12:17:48 <michaelt> ah yes
12:19:30 <michaelt> vin-ivar: if it works you should patch the version number on github and tell him to upload it.
12:19:51 <vin-ivar> yeah, waiting for it to compile, i'll tell him
12:20:02 <vin-ivar> thanks again!
12:21:02 <Wizek> Good Morning!
12:22:34 <Wizek> If want to transform between two data stractures and want to ensure that `(f (g x))  = x` always, is it possible to write the transformation once that returns `f` and `g` instead of having to write them manually?
12:22:36 <silviogreuel> just curious, where are you from guys/girls?
12:22:52 <Wizek> silviogreuel: I am chatting from Copenhagen atm.
12:23:01 <Wizek> silviogreuel: Denmark, that is
12:23:05 * hackagebot list-t-html-parser 0.2.2.0 - Streaming HTML parser  http://hackage.haskell.org/package/list-t-html-parser-0.2.2.0 (NikitaVolkov)
12:23:34 <Wizek> I meant to write `(f (g x)) == x`
12:23:39 <chpatrick> Wizek: you mean an isomorphism?
12:24:13 <Wizek> chpatrick: Could be, reading up on it
12:24:49 <chpatrick> Wizek: there's https://hackage.haskell.org/package/lens-4.9.1/docs/Control-Lens-Iso.html
12:24:52 <chpatrick> if you like lens
12:29:38 <ollef> napping: I'm here actually :)
12:30:03 <napping> Hello.
12:30:24 <napping> Yes, I don't entirely know what I'm talking about, I've just read that the Earley algorithm can't handle certian things
12:30:36 <napping> Actually, I might be confusing it with Tomita's GLR parser.
12:30:51 <michaelt> Wizek: once you write your magic two way Iso "fg", then  view fg x ≡ f x and view (from fg) x = g x
12:31:28 <napping> You wouldn't have any trouble delivering all infinite parses, if you changed to some kind of cycle-preserving parse forest as the result, right?
12:32:20 <ollef> napping: I think I read somewhere that there were bugs in earlier presentations of it. other than that, none that I'm aware of.
12:32:33 <ollef> napping: yeah, something like that might work.
12:32:36 <byorgey> Wizek: I don't know if it's directly applicable, but you might be interested in http://lambda-the-ultimate.org/node/4191
12:32:47 <ollef> napping: the problem with infinite parses exists with any generalised parsing algorithm
12:32:58 <napping> Yeah, but they are nice finite cycles
12:33:05 <napping> Nice finite graphs, if you allow cycles
12:33:30 <ollef> napping: yeah, true
12:33:36 <napping> As long as you compactly represent ambiguities, cycles don't seem to be too much more trouble
12:34:19 <napping> The GLL paper cites Earley, so I assume there's some kind of difference
12:34:36 <Wizek> byorgey: It might be related, thanks!
12:34:43 <ReinH> michaelt: of course, an easy way to write your Iso is to write f and g and use ``iso'' ;)
12:35:06 <michaelt> yeah of course.  
12:35:37 <ollef> napping: looks like the main difference is that they are generating code for their grammar (like normal parser generators) and use this graph-structured stack data structure to share work.
12:35:50 <ollef> napping: the GSS is in Earley as well, only it's sort of hidden in the item sets
12:35:54 <napping> interpreter/compiler, what is difference?
12:36:26 <ollef> napping: you could probably make an interpreter as well, true, so that point is probably not super important.
12:37:03 <napping> Yeah, I was just hoping you might know a bit more - I've had trouble following the papers like Earley that come more from the parsing side with item sets
12:37:24 <napping> The programming-language tone of the GLL papers was a lot easy for me to follow
12:37:28 <napping> but you seem to have no 
12:37:46 <napping> no trouble following Earley, so I thought I'd ask if you knew of any big difference
12:37:57 <ReinH> Wizek: (btw, you need both f . g = id and g . f = id for it to be an isomorphism, as isomorphisms are two-sided inverses)
12:37:57 <napping> I think the Tomita algorithm has somewhat more significant defects
12:38:12 <joneshf-laptop> can ghc output the regular haskell from the unlit pass?
12:38:32 <Wizek> ReinH: That is not a problem. In fact, that is desired.
12:38:35 <ollef> napping: the wikipedia description of earley is quite good IMO.
12:38:47 <ReinH> Wizek: Sure, just letting you know the "rules" :)
12:39:12 <napping> My code was pretty much literally writing a grammar, and running it in a moand that made calls into a GSS
12:39:28 <napping> using an explicit call operation instead of direct recursion to capture sharing
12:40:10 <Wizek> ReinH: Btw, doesn't `(f (g x)) == x` already entail both `f . g == id` and `g . f == id`?
12:40:10 <michaelt> ReinH: yes, that was his initial premise; Wizek was tired of carrying them both around, so to say
12:40:16 <napping> ollef: thanks. That linear-time paper is a nice reference too. I think it might be the parser version of an optimization I thought of as tail-call elimination
12:40:21 <mauke> I don't know what you're talking about but do you know the Marpa parser?
12:40:28 <ReinH> Wizek: no, it only entails the former
12:40:46 <napping> mauke: more or less about ollef's Earley library for Haskell
12:40:51 <ReinH> since \x -> f (g x)) = f . g
12:41:18 <napping> and more specifically me hoping ollef could clear up a few points on parser theory for me
12:41:27 <mauke> https://metacpan.org/pod/distribution/Marpa-R2/pod/Marpa_R2.pod#Description
12:41:42 <ReinH> for example, left- and right-shifting are one-way inverses.
12:42:08 <arkeet> Wizek: f . g = id implies (g . f) x = x when x is in the image of g, but for other x it says nothing
12:42:40 <ReinH> since right-shifting loses information if the LSB is 1
12:42:50 <arkeet> (or if it's 0)
12:43:06 * hackagebot octohat 0.1.4.2 - A tested, minimal wrapper around GitHub's API.  http://hackage.haskell.org/package/octohat-0.1.4.2 (sestrella)
12:43:40 <ReinH> arkeet: well :p
12:43:41 <ollef> napping: btw, how did you handle infinite parses in your implementation?
12:43:52 <ollef> it seems like you'd have the same problem using GLL
12:44:32 <mauke> there's a paper: https://docs.google.com/file/d/0B9_mR_M2zOc4Ni1zSW5IYzk3TGc/edit?pli=1 not sure how useful, though
12:44:34 <sveit> is the opinion here (it's just the one bolded sentence) http://dev.stephendiehl.com/hask/#lenses actually widely held in the community, and reason to avoid the lens library in favor of lens-family?
12:44:37 <napping> Much like happy - the general form of the parse result is a table indexed by nonterminal plus start plus end
12:45:16 <mauke> sveit: I've never heard of lens-family
12:45:48 <napping> with table entries being a list of such parses, represnted as a list of the keys of nonterminals
12:45:59 <arkeet> sveit: no, it's not.
12:46:09 <sveit> mauke: ok, thank you. i was mostly wondering because it's a strong statement and i definitely don't have the experience to know what qualifies as "idiomatic" Haskell
12:46:19 <sveit> arkeet: thank you as well
12:46:25 <ollef> napping: ah, alright. I specifically set out to make it using Applicative since I like that interface.
12:46:26 <arkeet> some people are somehow morally opposed to lens for whatever reason
12:47:01 <napping> ollef: I did that too
12:47:15 <sveit> arkeet: but it's not the situation of "most" people in the community not liking it?
12:47:17 <napping> ollef: I just didn't let calls return a whole lot
12:47:47 <ReinH> sveit: No, his assertion is unfounded FUD
12:47:49 <napping> sveit: if you are not releasing code as a library, use whatever
12:48:16 <napping> One thing to remember is that lens is designed so you don't actually needed to depend on the lens package to provide usable lenses
12:49:25 <michaelt> sveit: lens-family is the precursor of the going lens library, it is much simpler and does less of course. most lenses can be read by either library (where they overlap)
12:49:30 <dolio> arkeet: Zeros aren't information, clearly.
12:50:19 <napping> sveit: I think it is fairly widely agreeded that lens is a pretty big dependency, and all else being equal it might be nicer for a library not to require it
12:50:21 <michaelt> sveit: if you are defining lenses in your own library, in theory you don't need to depend on either of them, since the relevant types are in scope as soon as RankNTypes is on
12:50:36 <arkeet> you don't even need RankNTypes
12:51:07 <ReinH> napping: although tbqh almost all of my projects end up compiling it anyway, so the cost is well amortized
12:51:16 <napping> Yeah, me too
12:51:27 <arkeet> @let _snd f (a,b) = fmap ((,) a) (f b)
12:51:29 <lambdabot>  Defined.
12:51:30 <arkeet> :t _snd
12:51:31 <lambdabot> Functor f => (t -> f b) -> (a, t) -> f (a, b)
12:51:33 <arkeet> that's a lens.
12:51:37 <napping> and something like wreq that's designed around it didn't seem to draw too many complaints
12:51:42 <arkeet> > (3,5) & _snd .~ "hi"
12:51:43 <ReinH> Actually lens is the main reason I want to be able to share compiles between sandboxes
12:51:44 <lambdabot>  (3,"hi")
12:51:52 <ReinH> napping: wreq is great
12:52:22 <napping> just that if you only make incidental use of it, for something you could easy turn into e.g a traverse or two, then it's polite to rewrite it
12:52:50 <michaelt> arkeet: yes, lens-family-core doesn't use it
12:52:58 <napping> and as ReinH reminds me, if cabal gets fixed up for better sharing, even that wouldn't really mater
12:53:24 <edwardk> lens is secretly a plot to drive everyone to nixos
12:53:30 <ReinH> edwardk: <3
12:55:13 <dmj`> edwardk: loool, the truth comes out
12:55:58 <michaelt> arkeet: I need to define type Lens' a b =  forall f . Functor f => (b -> f b) -> (a -> f a) to get haddock to give the right signatures 
12:56:24 <linman16> when is a recursive type better to use than a list and vice versa?
12:56:36 <c_wraith> linman16: list is a recursive type
12:56:45 <arkeet> michaelt: sure.
12:56:50 <arkeet> but that's just documentation :p
12:56:56 <michaelt> yes. 
12:57:08 <arkeet> or you can avoid rank 2 types with LensLike or whatever.
12:57:16 <michaelt> yes
12:57:29 <geekosaur> linman16, were you confusing lists with Vector or Array?
12:57:32 <edwardk> michaelt: you don't have to export that type if everyone using the code understands what a lens is though =)
12:57:39 <edwardk> then it shows up in the haddocks just unexplained
12:57:44 <michaelt> of course not, thats the point
12:58:02 <c_wraith> linman16: if it was syntactically valid, lists would be exactly    data [] a = [] | a : ([] a)
12:58:40 <michaelt> I was trying to remember what in that procedure forces you to the rankntypes pragma; just the unexported haddock visible Lens synonym
12:58:42 <c_wraith> linman16: or possibly that would read better as    data [a] = [] | a : [a]
12:58:46 <linman16> https://github.com/Euterpea/Euterpea/blob/master/Euterpea/Music/Note/Music.hs
12:59:20 <linman16> his "data Music" is recurisve. but could also be a sum type with a list [typea | typeb, etc]
13:00:22 <geekosaur> so there, there is the distinction between series and parallel
13:00:31 <c_wraith> linman16: Music is recursive, but it's a tree, not list
13:00:31 <RaceCondition> has anyone tried to use ghc-ios + an FRP framework to build an iOS GUI app?
13:00:31 <linman16> true
13:00:34 <napping> the two-argument constructors like :+: and :=: make it more of a tree
13:00:38 <geekosaur> which could be modeled with a list of lists, and 1-element lists for series
13:00:48 <geekosaur> assuming it doesn't actually use the inherent tree-ness, yeh
13:00:51 <RaceCondition> not 2D/3D but Cocoa Touch (or equivalent)
13:01:05 <linman16> but you could define it as a list of sum types. right?
13:01:18 <latk> I'm getting this error: http://lpaste.net/131635
13:01:20 <c_wraith> linman16: well, only really inconveniently
13:01:26 <latk> any ideas how I can fix this ?
13:02:03 <c_wraith> linman16: I mean, you *can* store a binary tree in a one-dimensional list, but it's decidedly inconvenient for all uses.
13:02:36 <ysr> Lets say you want to see what a function is called with, do you usually make that function a Writer until you finished debugging and turn it to a regular function later?
13:03:06 * hackagebot cabal-helper 0.3.3.0 - Simple interface to Cabal's configuration state used by ghc-mod  http://hackage.haskell.org/package/cabal-helper-0.3.3.0 (DanielG)
13:03:33 <linman16> this is how i am defining it, but wondering if there is a better way: http://lpaste.net/131636
13:03:45 <linman16> the two applications are similar, but not identical...
13:04:06 <linman16> *euterpea from github link vs lpaste link
13:04:09 <c_wraith> linman16: how do you indicate chords in your notation?
13:04:26 <linman16> notes in parallel. 
13:04:45 <c_wraith> linman16: what's that look like in your version?
13:04:48 <linman16> or with a Modifier. really, it is a modifier and annotation type
13:05:07 <c_wraith> linman16: chords are trivial in euterpea.  I don't understand in the slightest how to do them in your system.
13:05:08 <linman16> what do you mean? you mean parallel notes? or an annotation?
13:06:08 <linman16> [(0, [F3,G3,B3])] Those are parallel notes
13:06:16 <linman16> c_wraith: does that answer your question?
13:07:02 <geekosaur> linman16, one thing that occurs to me is that Euterpea supports multiple instruments
13:07:03 <c_wraith> linman16: ok, now how about two melodies in counterpoint?  Still trivial in Euterpea.  Insanely complicated in your systeml.
13:07:41 <c_wraith> linman16: especially if the melody and countermelody have different rhythms
13:08:06 <caseof> I'm doing a bunch of calls using http conduit (more specifically httpLbs). I am using a simple manager created with newManager. However I have the 'too many open files' exception. I thought that couldn't happen with a single manager?
13:08:11 <linman16> c_wraith: ok, i see what you are getting at. the app i'm working on is meant to parse musicxml and display it on a webpage. different apps
13:08:47 <linman16> geekosaur: yes. i would need to add an additional type, or something. it is still early in project
13:09:08 <linman16> geekosaur: parallel measures too...
13:10:02 <nak> good day all
13:10:47 <linman16> but is it better to use recursive type, or list? list is recursive, i know. but i'm not experienced enough to know if one design is better than other
13:12:12 <napping> linman16: if the type you want has a constructor with more than one recursive argument, you can't use a list
13:12:55 <c_wraith> linman16: you do recognize that each of :=: and :+: have *two* recursive values, right?
13:13:06 <napping> It's a more difficult question if your type is equivalent to a list.
13:14:10 <napping> You might also want to convert between two types, depending what that input looks like - start with a tree allowing easy parallel composition like Euterpea, then convert that to a list of notes in time order at some point in the processing
13:14:40 <linman16> hmm. i think i see what your driving at. if there was a need for recursive args, then one would have to use it instead of using a list
13:14:58 <napping> Just see what kind of recursive structure your input XML allows
13:15:13 <napping> separate subtrees for different instruments, maybe?
13:16:17 <linman16> c_wraith: but i use position to keep track of notes. if i were not to use position, then i think there would be need for recursive args
13:16:57 <napping> linman16: A list representation based on position sounds entirely reasonable for some uses
13:17:11 <napping> A basic question is what operations you want to be easy on your data
13:17:34 <linman16> napping: es. i haven't actually looked at that entirely. that is a good suggestion
13:17:42 <linman16> *yes. i haven't...
13:19:14 <napping> I think there are enough parts and chords and stuff in music xml that you will want to start with a tree
13:19:23 <phy1729> What the function to map [(1+), (2+), (3+)] onto 4 resulting in [5, 6, 7] ?
13:19:32 <napping> and then probably transform it into something more linear to parse
13:19:35 <michaelt> it's xml so you want to start with a tree
13:20:01 <pavonia> phy1729: map ($ 4)?
13:20:04 <geekosaur> > map ($ 4) [(1+),(2+),(3+)]
13:20:05 <lambdabot>  [5,6,7]
13:20:10 <sveit> edwardk: i am actually coming from a mathematics background, could you point me to some resources that describe and place the insights of lens in this context?
13:20:36 <phy1729> pavonia: interesting, thanks
13:20:37 <edwardk> sveit: not much written up on the topic in a very formal way currently
13:20:43 <edwardk> mostly just chatter on #haskell-lens and the like
13:21:07 <geekosaur> > map (`id` 4) [(1+),(2+),(3+)]
13:21:09 <lambdabot>  [5,6,7]
13:22:00 <Aruro> > [(1+), (2+), (3+)] <*> [4]
13:22:01 <lambdabot>  [5,6,7]
13:22:14 <Aruro> not exactly "map" but still
13:23:17 <phy1729> I need to read LYAH again. I forgot all the applicitive stuff
13:23:41 <phy1729> thanks all
13:24:33 <Aruro> read typeclassopedia
13:24:38 <Aruro> you are ready.
13:25:03 <michaelt> > [(*),(+)] <*> [1,2] <*> [10,100]
13:25:03 <gremble> I'm reading some haskell code, and there is something like: blah blah where forever a = do a; forever a. What is the ; there?
13:25:04 <lambdabot>  [10,100,20,200,11,101,12,102]
13:25:14 <gremble> I understand that it is supposed to be an infinite loop
13:25:21 <geekosaur> it's part of do syntax
13:25:32 <geekosaur> could also be written: forever a = a >> forever a
13:25:36 <cite-reader> gremble: Semicolons and curly braces are an alternative to layout.
13:25:59 <michaelt> gremble: usually you would indent at the second 'forever' and line it up with a
13:26:08 <gremble> Ah
13:27:01 <c_wraith> :t \a -> let x = a >> x in x
13:27:02 <lambdabot> Monad m => m a -> m b
13:27:25 <c_wraith> Huh.  Are there cases where the increased sharing from that definition can be bad?
13:28:07 * hackagebot redis 0.14 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.14 (GaneshSittampalam)
13:29:08 <Aruro> any interesting mathematical examples of fix?
13:29:22 <hodapp> I really wish those maintaining Ivory could either have documented their quasiquotation crap, or simply not had it in the first place...
13:29:42 <hodapp> I'd really like to just use the underlying non-quasiquoted syntax but I don't see a single example of it.
13:32:45 <meretrix> I have a library that provides serialization for Haskell primitives and want to extend it to work on arbitrary ADTs.  Would you recommend using Generics or Template Haskell?
13:33:56 <Cale> Generics probably ends up nicer if it's sufficient for what you're doing.
13:34:32 <ReinH> Aruro: if you view a binary relation as a graph, the least fixed point of that relation is (isomorphic to) the transitive closure of the graph
13:34:38 <ysr> So, if I understand correctly, reader monad is just another name for a function?
13:34:56 <Aruro> ReinH
13:34:57 <Cale> ysr: For the type constructor for functions, yeah
13:35:06 <Aruro> i wanted some working example in one line :)
13:35:13 <Aruro> something interesting
13:35:29 <Cale> ysr: newtype Reader r a = Reader { runReader :: r -> a }
13:35:34 <meretrix> Cale: Thanks.  I'll start with that and see how it goes.
13:35:41 <ReinH> Aruro: well, I think mine fulfills half of your requirements :p
13:35:56 <Aruro> ReinH: and btw when are we gonna see nother episode of HaskellCast? :)
13:35:58 <Denommus> meretrix: if you can use just generics, use just generics
13:36:01 <Aruro> another*
13:36:21 <ysr> So, what can Reader monad offer to us that (->) r monad cant?
13:36:34 <Cale> Nothing, they're isomorphic.
13:36:35 <ReinH> Aruro: Once we schedule our next guest :)
13:37:08 <ReinH> It's ReaderT that offers you something extra
13:37:19 <Cale> ysr: I suppose that since it's a type which is distinct from functions, perhaps the error messages are a little easier to understand.
13:37:30 <Cale> (in some cases, at least)
13:38:13 <ysr> so, reader monad is usefull when you want to apply the same argument to couple of functions, right?
13:38:29 <Cale> ReaderT gets you a little extra, but not much. Honestly, even though it's a good simple example of a monad and monad transformer, I think people should just stay away from Reader/ReaderT in almost all real code.
13:38:58 <ReinH> Cale: I've found it useful for storing mutable references when working with other people's transformer stacks, that's about it
13:39:57 <Cale> You pay syntactic overhead for using ReaderT which usually outweighs the cost of passing the parameter around by hand, unless you go to great lengths to set up all the stuff you'll need to never have to lift.
13:40:23 <Cale> I suppose in cases where you already have to use liftIO and such, it's not going to make matters worse
13:41:51 <ysr> As a beginner, I find it quite confusing that everything is haskell is wrapped in something else using layers and layers
13:41:56 <Aruro> ReinH: can you interview Dan Piponi? 
13:42:09 <ReinH> Aruro: we'd love to. He's on the list.
13:42:21 <Aruro> tell him its urgent :)
13:42:23 <ReinH> We asked last year iirc and he was interested, so hopefully soon
13:42:25 <ReinH> heh :)
13:43:06 <nschoe> Hey guys. I am having troubles finding the best way to compare or subtract two ZonedTime
13:43:29 <nschoe> (from Data.Time.LocalTime)
13:45:10 <nschoe> Given two LocalTime or two ZonedTime, I'd like to know if they differ from more than, say X minutes.
13:46:31 <nak> i'm trying to type the following two commands in ghci. 
13:46:34 <nak> x :: Int
13:46:35 <nak> x = 5
13:46:47 <ion> Input the following: let x :: Int; x = 5
13:47:15 <nschoe> nak, you can do "let x = 5 :: Int" instead.
13:47:26 <pavonia> nak: Note that the syntax in Haskell files is different fom what you type in GHCi
13:47:33 <nak> i see that
13:47:39 <nak> let both of those work
13:48:32 <napping> It's closer to the syntax allowed in a do block
13:49:08 <napping> There is a command :{ that starts a multiline input, ended with :}, but that also doesn't allow a declaration x :: Int ; x = 5
13:49:39 <Aruro> nschoe: what about this https://downloads.haskell.org/~ghc/7.0.3/docs/html/libraries/time-1.2.0.3/Data-Time-Clock.html ???
13:49:42 <napping> other top-level stuff like data and class declarations are alloweed
13:50:10 <Aruro> nschoe: it has function to find time difference in UTC format
13:50:35 <nschoe> Aruro, that would have been by guess yes. But unfortunately, I have to stoer / fetch my time into a PostgreSQL table
13:50:35 <Aruro> nschoe: and then there is this https://downloads.haskell.org/~ghc/7.0.3/docs/html/libraries/time-1.2.0.3/Data-Time-Format.html
13:50:45 <nschoe> So I have to use something that is an instance of FromRow.
13:52:13 <nschoe> Aruro, hum you mean I could convert my ZonedTime / LocalTime to UTCTime, then compute the difference...
13:52:16 <nschoe> That could work :-)
13:52:41 <exio4> Cale: I think ReaderT is cool to hide the argument passing, but only when you use it with other monad transformers, and you keep it as a somewhat implementation detail
13:53:07 <enthropy> there's also ":set +m" which lets you enter multiline expressions without the :{ :} business
13:53:08 * hackagebot aeson-t 0.0.5 - Transform JSON  http://hackage.haskell.org/package/aeson-t-0.0.5 (begriffs)
13:53:41 <Aruro> nschoe: indeed
13:53:50 <nschoe> Aruro, thanks.
13:54:03 <Aruro> nschoe: uwm :)
13:54:06 <m_ryan> hi what is the function that i use to read and excel file? thank you
13:54:08 <ReinH> nak: ghci is similar to IO do notation
13:54:22 <ReinH> so, e.g., you need let to define bindings, but not let ... in ...
13:54:35 <Aruro> m_ryan: excel? readn an excel file?
13:54:59 <ReinH> @google Haskell excel file
13:55:00 <lambdabot> https://hackage.haskell.org/package/xlsx
13:55:31 <m_ryan> Aruro: yes is it posible?
13:55:44 <ReinH> m_ryan: see above
13:55:52 <Aruro> m_ryan: ReinH found package for you
13:56:12 <napping> m_ryan: "read and excel" is a slightly amusing typo
13:56:44 <subleq> Is there a haskell style guide like PEP8 for python?
13:56:51 <m_ryan> thank you
13:57:14 <subleq> Am I supposed to do `record { field = 1 }` or `record { field=1 }`?
13:57:21 <geekosaur> subleq, not really. haskell isn't much about the There Is Only One Way
13:58:11 <nak> ReinH thanks :)
13:58:15 <nak> i am stumped by this one
13:58:20 <nak> y :: Int; y = y + 1
13:58:26 <Aruro> m_ryan: check out also this read only package http://hackage.haskell.org/package/hs-excelx
13:58:34 <nak> that looks like a function to me, but `f 5` does not return 6
13:58:39 <nak> sorry `y 6`
13:58:43 <saml> yo i try to learn haskell but too hard
13:58:47 <pavonia> subleq: I think spaces around infix operators are preferred
13:59:26 <ReinH> nak: y is not a function, y is an Int
13:59:32 <ReinH> f y = y + 1 is a function
13:59:36 <saml> http://www.seas.upenn.edu/~cis194/spring13/hw/10-applicative.pdf     https://gist.github.com/saml/f809bf27742fcc83c75c
13:59:44 <Aruro> subleq: i usually write like this https://wiki.haskell.org/Obfuscation :)
13:59:51 <nak> ReinH but what the heck is `y = y + 1` then ?
14:00:11 <geekosaur> an infinite loop? :)
14:00:31 <ReinH> nak: in y + 1, replace y with y + 1 and keep doing this until you run out of "y"s
14:00:33 <saml> if i have nested cases... how can i flatten?
14:00:40 <ion> nak: Let’s evaluate it manually step by step:
14:00:40 <saml> this is worse than node.js callbacks
14:00:46 <geekosaur> saml, I've been known to use tuples
14:00:47 <ion> y
14:01:00 <napping> saml: this is where do notation comes in!
14:01:02 <ion> (substitute the definition of y) y + 1
14:01:08 <ion> (substitute the definition of y) (y + 1) + 1
14:01:15 <ion> and so on forever
14:01:17 <nak> right
14:01:19 <nak> but like...
14:01:19 <Aruro> nak: y=1 + y == 1 + (1 + (1+ ..))
14:01:34 <saml> napping, do  over Maybe?
14:01:35 <nak> how is this a valid defintion ?
14:01:42 <napping> saml: for Maybe, >>= is defined like (a >>= f) = case a of Nothing -> Nothing; Just x -> f x
14:01:48 <ReinH> nak: why wouldn't it be?
14:01:55 <saml> is there ide or something that lets me select some code and it gives type of that selection
14:01:57 <geekosaur> it's syntactically valid but semantically "bottom"
14:02:05 <Aruro> saml: yes, emacs, vim
14:02:07 <ion> nak: The creators of Haskell wanted a Turing-complete language and they haven’t quit solved the halting problem yet.
14:02:07 <ReinH> saml: yes, vim and emacs can do this, there are probably others
14:02:09 <ion> quite
14:02:15 <saml> not out of the box
14:02:20 <saml> what vim bundle do you use?
14:02:51 <ion> > let ones = 1 : ones in ones
14:02:52 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:02:53 <geekosaur> the reason it's allowed is that, if you use a lazy expression that can produce results before processing the entire expression, you have what some other languages call a "generator"
14:03:09 <ion> nak: All definitions with that “shape” aren’t useless either.
14:03:29 <joneshf-laptop> is there already something like: `Applicative f => a -> b -> f b` ?
14:03:34 <joneshf-laptop> hoogle didn't turn up anything
14:03:39 <Aruro> nak: > take 5 [1..]
14:03:45 <arkeet> joneshf-laptop: const . pure?
14:03:50 <joneshf-laptop> arkeet, right
14:03:56 <arkeet> :t const . pure
14:03:57 <lambdabot> Applicative f => a -> b -> f a
14:03:59 <arkeet> oops
14:04:03 <ReinH> :t flip const . pure
14:04:03 <arkeet> almost.
14:04:04 <lambdabot>     No instance for (Applicative f0) arising from a use of ‘pure’
14:04:04 <lambdabot>     The type variable ‘f0’ is ambiguous
14:04:04 <lambdabot>     Note: there are several potential instances:
14:04:08 <arkeet> :t const id . pure
14:04:09 <lambdabot>     No instance for (Applicative f0) arising from a use of ‘pure’
14:04:09 <lambdabot>     The type variable ‘f0’ is ambiguous
14:04:09 <lambdabot>     Note: there are several potential instances:
14:04:14 <arkeet> well then.
14:04:27 <arkeet> :t const pure
14:04:28 <lambdabot> Applicative f => b -> a -> f a
14:04:28 <arkeet> yeah that.
14:04:29 <arkeet> haha
14:05:01 <joneshf-laptop> arkeet, does that already exist somewhere?
14:05:10 <arkeet> no, because you can just write const pure.
14:05:16 <joneshf-laptop> ...
14:05:24 <napping> saml: A big use of do notation is getting the benefits of a continuation heavy style, while still having sane syntax
14:05:51 <joneshf-laptop> arkeet, you can just write `fmap . const` but `(<$)` exists
14:05:53 <saml> yah maybe this type is all bad
14:06:04 <napping> seems to be on the right tract
14:06:05 <arkeet> yeah, but it exists because it might be more efficient than fmap . const
14:06:07 <saml> f :: String -> Maybe (a, String)
14:06:12 <arkeet> also it's probably a lot more useful
14:06:13 <napping> just maybe want to use do notation to clean up the cases
14:06:15 <saml> so can't compose with >>=
14:06:19 <nak> hmm
14:06:33 <saml> cause  String  vs. (a, String)
14:06:34 <arkeet> because you often have values of type f () lying around that you want to tag for whatever reason
14:06:36 <nak> ion the ones definition there seems more useful
14:06:43 <arkeet> > "hi" <$ guard (1 < 2) :: Maybe String
14:06:45 <lambdabot>  Just "hi"
14:06:52 <napping> saml: threading the String through explicitly should be okay for now
14:07:06 <napping> try replacing your case with >>= at first
14:07:10 <saml> is there good answers to http://www.seas.upenn.edu/~cis194/spring13/lectures.html   homeworks?
14:07:11 <nak> ion i'm guess i'm a little curious how we could even *use*  y = y + 1
14:07:15 <napping> runParser p1 s >>= ....?
14:07:20 <arkeet> and it's also fits in nicely with <$ <$> <* <*>
14:07:33 <saml> type won't check unless you use lambda 
14:07:33 <arkeet> nak: it's only useful if + is lazy enough.
14:07:41 <arkeet> :t ($>)
14:07:42 <lambdabot>     Not in scope: ‘$>’
14:07:43 <lambdabot>     Perhaps you meant one of these:
14:07:43 <lambdabot>       data constructor ‘Seq.:>’ (imported from Data.Sequence),
14:07:43 <napping> yeah, >>= needs a function
14:07:51 <napping> so like runParser p1 s >>= \? -> ?
14:07:52 <arkeet> mildly surprised that doesn't exist though.
14:07:55 <saml> runParser p1 s >>= (\s -> runParser p2)
14:07:59 <arkeet> but of course that's just flipped <$
14:08:04 <napping> (sometimes you make the function with composition with (.) or whatever)
14:08:16 <napping> saml: ok, how about just the inner one?
14:08:31 <saml> runParser p1 s >>= (\(Just (a, rest)) -> runParser p2 rest)
14:08:56 <napping> how to fill in runParser p2 rest >>= \? -> ?  to mean the same as case runParser p2 rest of Nothing -> Nothing; Just (x, rest) -> Just (f x, rest)
14:09:09 <napping> with the >>= you don't need the Just
14:09:36 <saml> that doesn't make much sense
14:09:41 <napping> It's the job of >>= to deal with the Maybe, and just pass a the wrapped value inside to you
14:09:51 <napping> (>>=) :: m a -> (a -> m b) -> m b
14:10:06 <ReinH> Is there a lazy natural or integer type in lambdabot's scope?
14:10:10 <saml> runParser p1 s >>= (\(a,b) -> runParser p2 b)
14:10:12 <napping> "I give you a wrapped-up a, and a function taking an a to a m b, you combine them for me)
14:10:23 <arkeet> ReinH: no, unless you count [()]
14:10:24 <kuribas> I have noticed haskell is asymetric in the use of tuples.  It prefers currying for input parameters, but tuples for output parameters.  I suggest that for symmetry sake, outputs should be curried too.
14:10:46 <c_wraith> @define data Nat = Z | S Nat deriving (Show, Eq, Ord, Read)
14:10:47 <lambdabot>  Defined.
14:10:51 <c_wraith> ReinH: now there is
14:10:55 <napping> saml: that's half of it, now you just need to catch the result from runParser p2 the same way
14:11:02 <napping> so you can stick f and x together
14:11:08 <ReinH> c_wraith: yes, now pls give it a Num instance
14:11:19 <kuribas> So "myfun a b = (a+1, b+1)" should become "myfun a b c = c (a+1) (b+1)"
14:11:22 <c_wraith> ReinH: that's more than 1 line of code.  Way too much. :)
14:11:37 <arkeet> nah, you can fit it in one line.
14:11:41 <arkeet> a fairly long line.
14:11:53 <napping> saml: the people running #haskell-beginners claim it's nice, never visited myself
14:12:59 <ReinH> > let { Z > _ = False; _ > Z = True; S n > S n' = n > n'; y = S y } in y > S Z
14:13:00 <lambdabot>  True
14:13:23 <arkeet> > fix S > S Z
14:13:24 <lambdabot>  True
14:13:30 <joneshf-laptop> what i really wanted was `void . pure`
14:13:34 <arkeet> :t void . pure
14:13:35 <lambdabot> Applicative f => a -> f ()
14:13:36 <joneshf-laptop> that should exist
14:13:36 <ReinH> Wait. Where did (>) come frmo?
14:13:43 <arkeet> joneshf-laptop: but that's just cosnt (pure ())
14:13:46 <arkeet> ReinH: Ord.
14:13:56 <ReinH> doh
14:14:00 <ReinH> nice
14:14:00 <joneshf-laptop> arkasizer, right
14:14:08 <arkeet> the derived instance does the right thing.
14:14:14 <ReinH> Indeed.
14:14:21 <saml> https://gist.github.com/saml/f809bf27742fcc83c75c  i did it this way
14:14:41 <napping> looks good to me
14:15:01 <saml> i don't like repeating name, rest.   and not sure why i can't  return (Just ...)
14:15:12 <napping> You'd say return (f a, rest)
14:15:18 <napping> for Maybe, return is Just
14:15:27 <saml> oh, return (f ..)  yah
14:15:35 <napping> the name is misleading, return :: (Monad m) => a -> m a
14:15:57 <saml> what would you do with repeating  `rest` ?
14:16:02 <napping> I might be easier to definte Monad Parser
14:16:11 <napping> and then use return and "ap" to get the Applicative
14:16:19 <saml> probably eventually they will do that in later homework
14:16:33 <napping> threading the rest kind of forces it to be sequenced like a monad anyway
14:16:45 <ReinH> The Parser type being used is type Parser a = String -> Maybe (a, String)?
14:16:46 <napping> one option is to use a fancier monad
14:16:53 <saml> yes ReinH 
14:16:55 <ion> @let instance Num Nat where { a + Z = a; a + S b = S (a + b); fromInteger 0 = Z; fromInteger n = S (fromInteger (n - 1)); (*) = undefined; (-) = undefined; abs = undefined; signum = undefined }
14:16:57 <lambdabot>  Defined.
14:17:07 <ion> > let y :: Nat; y = y + 1 in y > 3
14:17:09 <lambdabot>  True
14:17:33 <ion> (Don’t try y = 1 + y. :-P)
14:18:02 <napping> saml: String -> Maybe (a, String) is approximately equal to StateT String Maybe a
14:18:15 <napping> but monad transformers might be a touch fancy
14:18:32 <saml> yah everything is monad out of the box
14:18:40 <Se_> how do i return the n element of a list ? elementAt n xs = if( n > length xs || n < length xs) then xs[n] else Nothing
14:18:44 <napping> don't be afraid to go to the basics and look at implementations of stuff and so on
14:18:45 <kuribas> Haskell should have a dual of uncurry: "yrrucnu :: (a -> b -> (c, d)) -> a -> b -> (c -> d -> e) -> e"
14:18:58 <Aruro> Se_: (!!)
14:19:04 <Aruro> @src (!!)
14:19:04 <lambdabot> xs     !! n | n < 0 = undefined
14:19:04 <lambdabot> []     !! _         = undefined
14:19:04 <lambdabot> (x:_)  !! 0         = x
14:19:04 <lambdabot> (_:xs) !! n         = xs !! (n-1)
14:19:16 <napping> but basically State s a takes care of passing along an "s", and letting each thing in the monad maybe modify it
14:19:18 <Se_> X_x
14:19:46 <napping> StateT s m a is a wrapper around s -> m (a , s), so it includes some inner monad
14:19:52 <Aruro> Se_: if element is close to the end there are other methods :)
14:19:59 <napping> return x = (\s -> return (x, s)) is the definition for StateT
14:19:59 <Aruro> Se_: or start
14:20:10 <napping> and if your inner monad is Maybe ...
14:20:12 <enthropy> > listToMaybe $ drop 4 [ 1 .. ]
14:20:13 <lambdabot>  Just 5
14:20:14 <Se_> Aruro:okay i will look into it
14:20:16 <Se_> thanks
14:20:18 <Hijiri> Se_ your definition will fail on infinite lists
14:20:44 <kuribas> This is plainly wrong: https://wiki.haskell.org/Composing_functions_with_multiple_values
14:20:47 <ReinH> String -> Maybe (a, String) is the type of deterministic parsers
14:20:50 <napping> and actually, some of those things have applicative instances...
14:20:51 <Se_> wait is [1..] a infinite list?
14:20:54 <Hijiri> yes
14:21:03 <Aruro> Se_: indeed
14:21:12 <napping> newtype Parser a = Parser (StateT String Maybe a) deriving (Functor,Applicative) ;)
14:21:35 <Aruro> > length [1..]
14:21:36 <kuribas> Sorry, the dual of uncurry would be: "yrrucnu :: (a -> (b, c)) -> a -> (b -> c -> d) -> d"
14:21:39 <lambdabot>  mueval-core: Time limit exceeded
14:21:48 <ReinH> napping: or StateT String [] a for the usual nondeterministic parser :)
14:22:19 <Hijiri> Se_: Instead of getting the length, you can try using recursion while keeping track of how many more elements you need to go through to reach your target
14:22:21 <ion> https://github.com/ekmett/ersatz/blob/master/src/Ersatz/Internal/Parser.hs#L26
14:22:36 <napping> Yeah, the advantage of writing stuff in terms of a general Monad or Applicative instance is that you won't have to go back and change it if you modify the implementation to be fancier
14:22:39 <arkeet> ion I don't see why 1+y wouldn't work ;p
14:22:44 <napping> adding backtracking or keeping line numbers or what
14:22:48 <enthropy> kuribas: what's wrong on that wiki page?
14:22:52 <Se_> Hijiri: okay i will try that
14:22:55 <ReinH> Which gives us the nice Seussian rhyme http://goo.gl/uC7Bc5
14:23:07 <kuribas> enthropy: "You can't convert a pair to something that fits a function that accepts two arguments in curried form."
14:23:13 <ion> > let y :: Nat; y = 1 + y in y > 3
14:23:17 <lambdabot>  mueval-core: Time limit exceeded
14:23:19 <kuribas> enthropy: you can, using my dual of uncurry.
14:24:07 <jle`> a/b 11
14:24:17 <arkeet> ion oh duh.
14:24:21 <arkeet> nm
14:25:03 <Aruro> > take 1 $ reverse [1..]
14:25:07 <lambdabot>  mueval-core: Time limit exceeded
14:25:12 <Aruro> :)
14:25:53 <kuribas> :t :t let yrrucnu f a cont = let (b, c) = f a in cont b c in yrrucnu . partition
14:25:54 <lambdabot> parse error on input ‘let’
14:25:56 <kuribas> :t let yrrucnu f a cont = let (b, c) = f a in cont b c in yrrucnu . partition
14:25:57 <lambdabot> (a -> Bool) -> [a] -> ([a] -> [a] -> t) -> t
14:26:33 <enthropy> kuribas: I disagree: you're taking that function as an argument which doesn't seem like an option in my interpretation
14:27:04 <Se_> what does this do import Prelude hiding ((!!))?
14:27:11 <Se_> "import Prelude hiding ((!!))"
14:27:21 <Hijiri> It makes it so you don't get !! automatically from prelude
14:27:30 <Hijiri> normally Prelude is imported automatically, with all its functions
14:27:31 * enthropy reads that sententce as you cannot write an f such that  (++) (f (a,b)) == a ++ b
14:27:41 <Hijiri> If you explicitly import it, you can control which members are visible
14:27:42 <Se_> so it is excluding !!
14:27:45 <Hijiri> yes
14:27:52 <Hijiri> it makes it so you can't see !! from your code
14:28:23 <Hijiri> It's useful if you wanted to define your own !!, or you were using someone's library that defines its own !!
14:28:30 <napping> Se_: the "hiding" part is perfectly ordinary, like (import List hiding (intercalate)). The kind of tricky bit is that if you don't explicitly import Prelude, you get an implicit "import Prelude"
14:28:35 <Hijiri> (and you don't want ugly qualified operators)
14:29:53 <kuribas> enthropy: It's the dual of taking two arguments, namely delivering two arguments to the continuation.  Except the continuation has the be explicit.
14:31:04 <mniip> anyone have a link to something about continuations, and most importantly why they are useful?
14:31:30 <gremble> www.haskellinteriors.com the link you get when you search for "asks haskell"
14:31:50 <kuribas> mniip: http://en.wikipedia.org/wiki/Continuation-passing_style
14:32:57 <napping> mniip: an interesting application is http://www.cis.upenn.edu/~stevez/papers/abstracts.html#LZ07
14:33:38 <kuribas> enthropy: Of course it isn't very useful, at first sight...
14:33:58 <ackthet> this is kinda off topic but is monad pronounced moan-ad
14:34:06 <napping> mon-ad
14:34:13 <ackthet> i don't want to sound like a fool
14:34:15 <ackthet> thanks
14:34:23 <napping> like dyad or triad or whatever
14:34:27 <ackthet> like a jamacan saying man?
14:35:00 <napping> It's an o, like in mono
14:35:05 <napping> monoid / monad
14:36:03 <ion> Interestingly, you can embed classical logic in constructive logic by doing a CPS transformation; thus you can’t have a native LEM or callCC in Haskell but in Cont you can. https://gist.github.com/ion1/9803dbd77cf88147bde7
14:36:20 <kuribas> :t let yrrucnu f cont a = let (b, c) = f a in yrrucnu
14:36:26 <lambdabot>     parse error in let binding: missing required 'in'
14:37:03 <kuribas> :t let yrrucnu f cont a = let (b, c) = f a in cont b c in yrrucnu
14:37:04 <lambdabot> (t3 -> (t1, t2)) -> (t1 -> t2 -> t) -> t3 -> t
14:37:11 <Aruro> ackthet: 
14:37:16 <Aruro> @all-dict monad
14:37:18 <lambdabot> *** "Monad" gcide "The Collaborative International Dictionary of English v.0.48"
14:37:18 <lambdabot> Monad \Mon"ad\, n. [L. monas, -adis, a unit, Gr. ?, ?, fr.
14:37:18 <lambdabot>    mo`nos alone.]
14:37:18 <lambdabot>    1. An ultimate atom, or simple, unextended point; something
14:37:18 <lambdabot>       ultimate and indivisible.
14:37:20 <lambdabot> [130 @more lines]
14:37:23 <ackthet> :D nice
14:37:45 <Hijiri> we are all part of one big monad
14:38:09 * hackagebot aws-kinesis-client 0.4.0.1 - A producer & consumer client library for AWS Kinesis  http://hackage.haskell.org/package/aws-kinesis-client-0.4.0.1 (JonSterling)
14:38:40 <Aruro> Leibnitz invented monads, so haskell is just very small subset :)
14:38:51 <Aruro> or somebody before him
14:39:18 <kuribas> :t let yrrucnu f cont a = let (b, c) = f a in cont b c in \p -> (yrrucnu $ partition p) (++)
14:39:19 <lambdabot> (a -> Bool) -> [a] -> [a]
14:39:26 <Aruro> http://en.wikipedia.org/wiki/Monadology
14:39:33 <Aruro> our new religion :D
14:45:41 <Aruro> is there any cover vesion on Principal type-shcemes for functional programs ?? which is more clear to modern reader ?
14:45:53 <Aruro> i really have hard time after page 2, his notation...
14:46:20 <kuribas> :t yrruc (b, c) cont = cont b c
14:46:21 <lambdabot> parse error on input ‘=’
14:46:23 <ReinH> kuribas: yrrucnu is a nice one for djinn too
14:46:52 <ReinH> @djinn (a -> (b, c)) -> a -> (b -> c -> d) -> d
14:46:53 <lambdabot> f a b c =
14:46:53 <lambdabot>     case a b of
14:46:53 <lambdabot>     (d, e) -> c d e
14:47:21 <kuribas> @djinn (a, b) -> (a -> b -> c) -> c
14:47:21 <lambdabot> f (a, b) c = c a b
14:47:35 <ReinH> djinn is good at polymorphic, linear functions
14:47:46 <kuribas> ReinH: yeah :)
14:48:18 <ReinH> @. pl djinn (a, b) -> (a -> b -> c) -> c
14:48:18 <lambdabot> f = uncurry (flip . flip id)
14:49:48 <Aruro> @djinn (a->a)->a
14:49:48 <lambdabot> -- f cannot be realized.
14:49:52 <Aruro> :t fix
14:49:53 <lambdabot> (a -> a) -> a
14:50:22 <mniip> djinn can't into recursion
14:50:25 <mniip> or recursive types
14:50:51 <mniip> let alone bottom values
14:51:14 <kuribas> let yrruc (a, b) c = c a b in yrruc (partition even [1, 4, 3, 7, 4]) (++)
14:51:49 <Aruro> mniip: i have a hard time to grasp what djinn actually can do
14:52:27 <enthropy> > (++) `uncurry` partition even [1, 4, 3, 7, 4]
14:52:28 <lambdabot>  [4,4,1,3,7]
14:52:53 <Aruro> @djinn a->Bool
14:52:53 <lambdabot> f _ = False
14:53:02 <Aruro> why False why not True?
14:53:10 <mniip> Aruro, chain case-of and ADT constructors
14:53:14 <mniip> is all djinn can do
14:53:23 <bernalex> @djinn a -> Maybe a
14:53:24 <lambdabot> f = Just
14:53:33 <bernalex> @djinn Maybe a
14:53:33 <lambdabot> f = Nothing
14:53:35 <mniip> Aruro, because lambdabot's instance of djinn is set to only produce one result
14:53:51 <mniip> if you fire up djinn and allow multiple results you get both implementations
14:54:11 <bernalex> ah. yeah. that makes sense. I seem to recall getting both out of djinn.
14:54:15 <Aruro> mniip:  ok
14:54:24 <bernalex> djinn's UI was annoying though AFAIR.
14:54:34 <ReinH> > minBound :: Bool
14:54:36 <lambdabot>  False
14:54:40 <mniip> false just happens to be the first Bool constructor
14:54:56 <ReinH> mniip: Well, there's a principled reason for it, but yeah
14:55:00 <mniip> I wonder though
14:55:03 <mniip> @djinn Maybe ()
14:55:04 <lambdabot> f = Nothing
14:55:04 <bernalex> ReinH: I think it takes the leftmost declared constructor, not the minbound first.
14:55:22 <bernalex> ReinH: it's just that in haskell we tend to write the "smallest" value leftmost.
14:55:23 <ReinH> bernalex: minbound also takes the leftmost constructor of a sum though, right?
14:55:30 <bernalex> ReinH: yep.
14:55:30 <ReinH> (when derived)
14:55:35 <mniip> only when derived
14:55:39 <hexagoxel> :exf -u -m "a -> Maybe a"
14:55:40 <exferenceBot> pure
14:55:40 <exferenceBot> \ b -> fmap (\ f -> f) (pure b)
14:55:40 <exferenceBot> \ b -> fmap (\ f -> b) (pure b)
14:55:40 <exferenceBot> \ b -> Nothing
14:55:40 <exferenceBot> \ b -> join Nothing
14:55:45 <hexagoxel> there, multiple solutions :D
14:55:45 <ReinH> well yes, when defined it takes whatever you define...
14:55:54 <Aruro> actually is it possible to install @src command separately from lambdabot?
14:55:57 <nschoe> Hi again, I'd like to make a simple "enum-like" data type (data MyType = One | Two | Three) an instance of FromField or FromRow (I'm not yet sure which one I need). The thing is I have privilege levels implemented as simple number (1,2,3) in a PostgreSQL database, and I'd like to be able to 'query' it and get back a MyType.
14:56:02 <ReinH> hexagoxel: what is this wizardry?
14:56:04 <mniip> [00:55:13] <exferenceBot> \ b -> join Nothing
14:56:05 <mniip> what
14:56:11 <nschoe> I've looked here: http://hackage.haskell.org/package/postgresql-simple-0.4.10.0/docs/Database-PostgreSQL-Simple-FromField.html#v:fromField but I don't know how to implement 'fromField'
14:56:42 <mniip> oh
14:56:52 <nschoe> The basic idea is: fromField "1" = One, fromField "2" = Two, etc. But it seems more tricky than that.
14:56:54 <hexagoxel> ReinH, mniip: https://github.com/lspitzner/exference/
14:56:58 <ReinH> mniip: (False is the minbound because booleans form a lattice with False as bottom)
14:57:07 <mniip> nevermind, I was trying to apply the function monad
14:57:22 <mniip> ReinH, hm? what kind of lattice
14:57:37 <mniip> last time I checked bools are symmetric
14:58:00 <ReinH> mniip: a complemented distributive lattice
14:58:11 <ReinH> more specifically, a boolean algebra
14:58:13 <nschoe> Can anybody point me to somewhere that might help?
14:58:27 <mniip> yeah but how is boolean algebra not symmetric
14:58:29 <hexagoxel> :exf Bool
14:58:30 <exferenceBot> maxBound
14:58:30 <exferenceBot> minBound
14:58:34 <hexagoxel> heh
14:58:39 <ReinH> mniip: what does symmetric have to do with it?
14:58:57 <mniip> if it's symmetric how do you arbitrarily choose one of the two
14:59:08 <ReinH> arbitrarily.
14:59:39 <ReinH> which eventually becomes "conventionally"
15:02:26 <ReinH> also you have for some set A, bottom = {}, top = { a \in A }, and {} ~ False seems more intuitive than {} ~ True
15:03:52 <mniip> intuition eh
15:04:41 <ReinH> Well, these things are defined by humans after all
15:05:06 <ReinH> but yes, you could have an equally valid system where top = False
15:57:59 <JagaJaga> How can I get data constructor for B? `data A = A { foo :: [String]}` and `type B = A`
15:58:26 <ion> The data constructore for B is A
15:59:18 <JagaJaga> ion: oh! But how can I make it B? Create new data B = ... ?
15:59:44 <kadoban> JagaJaga: Yeah, use a newtype or data instead of 'type'
16:00:19 <JagaJaga> kadoban: how to use newtype?
16:03:41 <sweater> Hey, people. I wonder about those of us who use Haskell in production — how do you approach record problem?
16:04:09 <ion> lens
16:04:52 <sweater> I'm having lens with plain Haskell records 
16:05:01 <sweater> and TH generating code with makeLens
16:05:34 <sweater> Now I'm refactoring some code and feel pain and frustration :)
16:06:47 <JagaJaga> It's ok to write smth like `data A = A [String]; getFoo (A a) = a` or there is another way?
16:07:31 <ion> That is fine. But you get that getFoo for free from data A = A { getFoo :: [String] }
16:08:04 <JagaJaga> ion: yeah, that what I realised after I've typed the message :D
16:25:36 <sweater> JagaJaga: hey man
16:25:41 <sweater> I'm MagBo :)
16:26:07 <sweater> what's your take on using plain records with TH lens?
16:27:42 <sweater> I'm refactoring now types for my hydra wrapper and I'm really disgusted with the fact that I end up having stuff like data ``data Jobset = ... _jobset_name :: Name`` instead of just ``data Jobset = ... _name :: Name`` 
16:30:01 <sweater> But I guess it's de-facto the way to do it — https://github.com/bgamari/gl-plot/blob/aeaff6f104870b0b6e116963c714aa3891979386/Graphics/Rendering/GLPlot/Types.hs etc
16:30:42 <chpatrick1> ok guys check this out: https://gist.github.com/chpatrick/ddffd201889b83ff4de2
16:30:53 <chpatrick1> composable bidirectional serialization in whatever Applicative you want
16:31:19 <chpatrick1> supplying the fields of a record in any order
16:37:10 <Denommus> wait wait wait
16:37:28 <Denommus> (<$>) and (<*>) are on Prelude now?
16:37:29 <Denommus> :D
16:41:24 <pacak> Denommus: And Monoid. And some other stuff. Lots of warnings to fix.
17:00:53 <begriffs> I just switched to using Stackage and have gotten rid of my cabal sandboxes. I'm wondering what is the analogue of cabal sandbox add-source that I can use to rely on a non-published package in another directory? Seems like I might have to add a package database to the stack, but not sure how to do this.
17:02:53 <kadoban> begriffs: Why dump sandboxes?
17:03:59 <c_wraith> Yes.  Why stop using the feature that does exactly what you want and asking how to do what you want without it?
17:07:37 <geekosaur> because of a misplaced belief that hackage is the problem and sandboxes mitigated ghackage and stackage cures it, instead of that ghc's library management is the problem and stackage only delays the problem for some packages?
17:07:41 <begriffs> kadoban: thought it would be nice to not have to rebuild lens, haskell-src-exsts etc per project. Just let them share a user-level package db that contains packages whose versions are fixed to work by Stackage.
17:08:00 <geekosaur> wghich is sadly common; stackage is the great messiah, to hear some
17:08:13 * hackagebot spatial-math 0.2.3.0 - 3d math including quaternions/euler angles/dcms and utility functions  http://hackage.haskell.org/package/spatial-math-0.2.3.0 (GregHorn)
17:08:17 <kadoban> begriffs: Look at stackage-cli, it should let you share packages between sandboxes
17:08:35 <begriffs> Oh I was just trying this as an experiment because I heard good things. I didn't know it's been known to have problems.
17:09:02 <kadoban> It's known not to fix every possible wrong. I think it's great in general.
17:11:35 <begriffs> Is stackage-cli pretty well used or should I maybe go back to classic sandboxes and deal with the repeated builds?
17:13:37 <creichert> can  you share a sandbox with 'cabal sandbox --sandbox=/path/to/shared/sbx' ?
17:13:59 <creichert> ah, 'cabal sandbox init --sandbox=/shared/sbx'
17:15:51 <begriffs> creichert: looking into stackage-cli it seems like it does some of this management of where the sandboxes live, so you create a different sandbox per stackage configuration. https://github.com/fpco/stackage-cli/wiki/Example
17:19:11 <kadoban> begriffs: It's pretty new, so I doubt it's all that well used. It's just a wrapper on cabal sandboxes that automatically sets stuff up for you though, so it shouldn't be that radical.
17:31:10 <teurastaja> hey, id like a few links to examples using the ST monad with STRefs. im wondering how i can pass pointers around if it says i cant escape the ST monad. also, i wonder where runST should be used. im building a complex data structure and using separate functions for initializing pointers to null then another function setting the state. 
17:32:00 <teurastaja> also, how do i free pointers?
17:32:20 <ronh> teurastaja you call runST at the end of your computation. 
17:32:22 <ronh> :t runST
17:32:23 <lambdabot> (forall s. ST s a) -> a
17:32:42 <teurastaja> where is "the end"?
17:33:24 <ronh> pressumably, computerSomething :: a -> ST b c function
17:33:27 <ronh> compute*
17:33:55 <teurastaja> before returning the value at the end of the function?
17:33:57 <lokathor> So, using a Map a Int, I want to insert a 1 if the key isn't there, and otherwise i want to update the current value to be +1. Do I need an if statement for this? or is "alter" what i want?
17:34:04 <lokathor> the docs seem a little vague
17:34:43 <Hijiri> there is a bunch of modification functions with varying flexibility, let me check
17:34:46 <ronh> teurastaja that is one way of doing it. what is it that you're trying to do, though?
17:35:09 <Hijiri> lokathor: alter will do it
17:35:19 <lokathor> oh, hmm, reading the second example it seems like, given the right func, alter will do it, yeah
17:35:21 <glguy> teurastaja: You don't free STRefs, they are garbage collected
17:36:11 <glguy> teurastaja: Here's some old example code I had on the paste bin using ST to implement a merge sort If you want ST examples: http://lpaste.net/119204
17:37:09 <chpatrick1> anyone interested in automatic bidirectional serialization? :)
17:37:39 <ronh> perhaps you misunderstood the purpose of ST.. they are not a haskell's way to have general mutable variables.. they are used to write mutable algoirthms outside of IO, usually for performance reasons. if you want something similar in IO, where you can have persistent "mutable variable" during the runtime of your program, use IORef
17:38:50 <lokathor> cool
17:39:10 <lokathor> i've now actively chosen to use foldr to solve a list probelm for the first time
17:41:28 <cdk> I've always wondered what exactly about ST gives it better performance than IO (in some cases). I know the internal implementations of ST (forall s. s -> (a, s)) and IO (RealWorld# -> (a, RealWorld#)) which are obviously very similar. The only difference I can think of is that the compiler might realize that the "forall s. s" state token being passed around in the ST computation doesn't escape and can elimina
17:41:34 <cdk> te passing it around, essentially turning it into a pure computation. Is that the general idea?
17:42:10 <cdk> lokathor: you're on your way to functional enlightenment :)
17:42:55 <lokathor> cdk: for an RNG, for example, if you have several RNGs going on at once, each can run in its own thread using its own ST, but if it's all using randomIO then they have to synchronize randomization
17:43:02 <kadoban> I don't know a lot about it, but ST is more restricted, so it makes sense it could sometimes be better optimized.
17:43:04 <ronh> cdk I didn't know it was faster.. interesting
17:43:06 <lokathor> so that's one situation at least
17:43:58 <geekosaur> it's not always faster. IO is usually slower because you're using IO to communicate or synchronize, and communication and synchronization are expensive
17:45:01 <Hijiri> I thought the point was to be able to use it in pure computations, not that it's necessarily faster
17:45:12 <Hijiri> faster than IO, I mean
17:45:25 <geekosaur> also things like IOArrays may include such synchronization automatically on the assumption that they're in IO for a reason
17:45:41 <geekosaur> Hijiri, yes, that's the main reason to use ST instead of IO
17:45:42 <lokathor> cdk: functional enlightenment is easy to notice when the problem question mysteriously suggests limiting the problem to Ord instead of just Eq :P
17:47:00 <athan> if I have something of `Foo -> m Bar`, how could I turn that into a `m (Foo -> Bar)`?
17:47:20 <cdk> :t sequenceA -- athan
17:47:21 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
17:47:30 <athan> :O! thank you cdk!
17:47:51 <RenRenJuan> is the breakage from 7.10 massive?
17:51:47 <pacak> RenRenJuan: Not really
17:52:46 <pacak> A few Prelude changes, a few type signatures changes...
17:53:04 <RenRenJuan> pacak, the release notes implied breaking changes if the indicated things weren't disabled by default
17:54:50 <pacak> Haven't checked those, but I personally updated about 30 or 40 packages since rc1 and it wasn't hard.
17:55:39 <RenRenJuan> ah, good that's sort of thing wanted to know
18:01:15 <ReinH> athan, cdk: No, that won't work.
18:01:25 <ReinH> The superficial reason is that ((->) r) is not Traversable.
18:01:42 <athan> ReinH: I had a feeling
18:01:49 <ReinH> The real reason is that it is impossible. If that function did exist, all Applicatives would be Monads.
18:02:36 <athan> mind = blown
18:02:53 <athan> ReinH: if foldable ~ catamorphism, is traversable ~ hylomorphism?
18:03:00 <ReinH> a -> m b allows the m to be determined by a
18:03:13 <ReinH> m (a -> b) does not. That is precisely the added power of Monad over Applicative
18:03:29 <ReinH> athan: I don't think so, but I'm not sure
18:03:56 <enthropy> @type \f -> flip lookup <$> mapM (\x -> (x,) <$> f x)  [minBound .. maxBound]
18:03:57 <lambdabot> (Bounded a, Enum a, Eq a, Monad f) => (a -> f b) -> f (a -> Maybe b)
18:04:03 <athan> ReinH: That's awesome, thank you for your help
18:04:13 <ReinH> athan: np
18:09:58 <ReinH> pacak: Most of the breakage comes from trying to install cabal packages with incompatible version constraints. This is fixable but tedious, although it is improving quickly.
18:10:38 <ReinH> (of course some packages are probably still broken with 7.10 anyway)
18:12:39 <pacak> ReinH: When I started (about 3 hours after rc1 release) most of the packages were broken. Dependencies, AMP, traversible stuff and so on. Fix, check, commit, pull request...
18:12:54 <ReinH> pacak: thanks for your hard work :)
18:13:06 <teurastaja> if monoids generalize fold, what are generalizations of unfold called?
18:13:37 <ReinH> You'd like to say comonoid, but it isn't.
18:13:50 <teurastaja> hmm...
18:13:57 <teurastaja> so then...?
18:14:30 <pacak> > "foo" <> ("bar" <> "more bar") <> "more foo"
18:14:31 <lambdabot>  "foobarmore barmore foo"
18:14:41 <pacak> Fold is more like
18:14:49 <pacak> "foo" <> ("bar <> ( ...
18:14:56 <pacak> (or in reverse)
18:15:04 <ReinH> pacak: But because it's a monoid, the parenthesis don't matter
18:15:14 <ReinH> so it can be either
18:15:25 <pacak> ReinH: But not for fold
18:15:42 <athan> foldr ~ foldl with monoids
18:15:44 <teurastaja> i know what fold and unfold are, just searching for a name for anamorphisms
18:15:59 <athan> (I think)
18:16:21 <pacak> :t mconcat
18:16:22 <lambdabot> Monoid a => [a] -> a
18:16:31 <ReinH> athan: with monoids and with other list homomorphisms
18:16:37 <pacak> :t foldl1 (<>)
18:16:38 <lambdabot> (Foldable t, Monoid a) => t a -> a
18:16:53 <ReinH> monoids aren't "generalizations" of folds in the sends that all folds are also monoids.
18:16:56 <ReinH> *the sense
18:17:14 <ReinH> folds with non-associative operations are obviously not monoids)
18:17:54 <teurastaja> what is the opposite of a monoid?
18:18:05 <pacak> ReinH: To have a monoid you need to have identity element. You can fold list of positive numbers with addition but you can't make monoid for positive numbers with addition.
18:18:40 <ReinH> pacak: I know what a monoid is.
18:19:41 <ReinH> teurastaja: The relationship you might be thinking of is list -> monoid is a fold, monoid -> list is an unfold
18:19:51 <teurastaja> not asking for what monoids are.... if catamorphisms are to monoids, then anamorphisms are to...?
18:19:55 <ReinH> At least to the extent that a list in Haskell is a free monoid, which it isn't.
18:19:56 <teurastaja> oh
18:20:34 <teurastaja> so yeah.... does it have a name?
18:21:03 <teurastaja> monoid reciprocal?
18:21:41 <ReinH> free monoid -> monoid is a cata, monoid -> free monoid is an ana. That's the only such relationship I know of.
18:22:10 <teurastaja> what does the "free" mean?
18:24:36 <ReinH> teurastaja: informally, an object is "free" if the only relationships between the elements of the free object are those that follow from the defining axioms of the structure.
18:24:49 <ReinH> There is a formal definition in category theory that involves adjunctions
18:26:08 <arkeet> http://en.wikipedia.org/wiki/Free_object
18:28:06 <teurastaja> thanks
18:28:22 <ReinH> A magma has only a binary operation and no laws. Binary operations form binary call trees. Thus, binary trees are free magmas. When you add associativity, you get the property that your tree can be rearranged by reassociating its subtrees. This allows you to rearrange the tree in the shape of a nonempty list. Thus, (finite) nonempty lists are free semigroups.
18:28:57 <ReinH> monoids add an identity element. You can consider that an empty tree is the equivalent of performing no operations. This, combined with the semigroup property of rearranging the tree into a list-shape gives (finite) lists as the free monoid.
18:30:13 <lokathor> i'm sorry.... magma?
18:30:25 <ReinH> A magma is a set with a binary operation.
18:30:30 <ReinH> The operation has no laws.
18:30:34 <ReinH> It's not a very interesting structure.
18:30:40 <HeladoDeBrownie> (a, a -> a -> a)
18:30:44 <lokathor> oh okay, a math magma
18:30:54 <HeladoDeBrownie> woops
18:30:59 <HeladoDeBrownie> i'm confusing values and types there
18:31:03 <HeladoDeBrownie> ignore that
18:31:10 <lokathor> i guess i missed a line, i thought you meant like... the liquid rock stuff
18:31:15 <idnar> .oO("Now you're thinking with volcanos!")
18:31:22 <ReinH> lokathor: :)
18:31:51 <SwashBuckla> is there a monadic action akin to 'sleep'?
18:32:15 <SwashBuckla> e.g. sleep 5 -- sleep 5 seconds
18:32:16 <arkeet> what do you mean by monadic.
18:32:18 <ReinH> :t thredDelay
18:32:19 <arkeet> you mean IO?
18:32:19 <lambdabot> Not in scope: ‘thredDelay’
18:32:21 <ReinH> :t threadDelay
18:32:23 <lambdabot> Not in scope: ‘threadDelay’
18:32:23 <arkeet> (monads aren't IO.)
18:32:30 <arkeet> @hoogle threadDelay 
18:32:30 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
18:32:30 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
18:32:30 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
18:32:45 <ReinH> sleep n = threadDelay n * 1000000
18:32:54 <arkeet> (with more parentheses)
18:32:57 <Hijiri> magma operation has closure
18:33:01 <ReinH> woops thanks
18:33:10 <ReinH> Hijiri: that's implied by it being an operation
18:33:11 <arkeet> Hijiri: I wouldn't call it a binary operation otherwise.
18:33:11 <SwashBuckla> arkeet: is it right to say "something in the IO Monad" then?
18:33:17 <Hijiri> oh, right
18:33:20 <ReinH> SwashBuckla: "something in IO"
18:33:22 <SwashBuckla> as opposed to "a monadic action"
18:33:23 <arkeet> SwashBuckla: I guess, but it still has nothing to do with monads.
18:33:26 <SwashBuckla> ah ok
18:33:28 <arkeet> IO is a monad, but that has nothing to do with sleeping
18:33:39 <idnar> SwashBuckla: I think you would normally say "an IO action"
18:33:45 <SwashBuckla> ok
18:34:05 <Sai__> hi i am trying to display a new sudoku puzzle .But i get the same puzzle every time. This is my code http://pastebin.com/AuzyQs5a  . The random puzzle generator was running properly when tested independently. Here the "New puzzle" button is link to getSudokuR in which the random question generator is placed. Can anybody give tips on how to solve this problem?
18:34:17 <HeladoDeBrownie> SwashBuckla, people do often say "in the [whatever] Monad", but it's more of an idiom as opposed to something strictly accurate to say.
18:35:03 <kadoban> It's weird because IO is just as much a Functor, an Applicative, etc. and often people aren't talking about anything specific about any of those typeclass instances
18:35:20 <arkeet> Sai__: I don't see any sort of definition for question or puzzles.
18:35:31 <arkeet> or anything that looks random.
18:35:47 <idnar> yes, I think it's a bit misleading; when you're referring to a specific thing (IO, Maybe, whatever), the fact that it is a Monad is just a property that happens to be useful in various ways
18:36:04 <jmcarthur> s/IO Monad/Sin Bin/g
18:36:06 <Sai__> <arkeet> : I will post that also. I didn't include ast it was running cirrectly
18:36:13 <Sai__> *correctly
18:37:02 <idnar> IO is useful because it lets you do IO, the fact that it's a Monad just gives you a convenient way to manipulate values of IO a
18:37:50 <HeladoDeBrownie> Monad is basically an interface for composing values in a specific way.
18:37:54 <jmcarthur> IO is useful because it is a place we can put stuff we don't understand well enough to write declaratively.
18:38:12 <Sai__> <arkeet>: this is the random question generator code
18:38:39 <Sai__> http://pastebin.com/KaSpkz5m
18:39:23 <Hijiri> well the issue here is unsafePerformIO
18:39:38 <homovitruvius> any tool to generate pictures from eventlogs without going through threadscope screenshots? I'd like to script the process as part of a hakyll site generation
18:40:10 <Hijiri> you are not supposed to use it unless you are sure the effects aren't visible from outside
18:40:32 <Hijiri> but you did use it, and I think you expected z to get a random puzzle each time
18:40:40 <Sai__> <Hijiri>: But I was getting random question when I ran that part of code
18:40:44 <Hijiri> (On line 46)
18:41:02 <Hijiri> But GHC can save the result of z, because GHC assumes that it isn't doing any IO
18:41:11 <Hijiri> so it thinks it's safe to keep the value for reuse later
18:41:26 <Hijiri> So when you reuse it, you get the same z
18:42:09 <Hijiri> Sai__: Did you just test it in ghci? It might have not shared the result because of the different environment
18:42:48 <Sai__> <Hijiri>: yes I have tested in ghci and it worked. i will test again 
18:43:16 * hackagebot templater 0.0.2.0 - Simple string templater  http://hackage.haskell.org/package/templater-0.0.2.0 (geraud)
18:43:22 <Hijiri> I am saying testing it in ghci, especially with something like unsafePerformIO, might not give you the same results
18:43:51 <arkeet> don't use unsafePerformIO
18:45:17 <Hijiri> your code would also benefit from more top-level type annotations, but that's a side issue
18:45:39 <arkeet> like
18:45:47 <arkeet> completely forget it exists
18:45:50 <Sai__> <Hijiri>: it was working as expected. Should I be changing it
18:46:13 <Sai__> is the issue not with the getSudokuR?
18:46:14 <arkeet> (there are a couple use cases for it if you really know what you're doing but this is not one of them)
18:46:53 <Hijiri> Sai__: Work your code to not use unsafePerformIO
18:47:46 <Sai__> <Hijiri> : ok thanks . I will do that see
18:48:02 <arkeet> what exactly is happening here is that 
18:48:17 <arkeet> 'randelem xs' is being executed exactly once 
18:48:41 <arkeet> when you evaulate question puzzles
18:49:33 <Sai__> <arkeet> : ok, thanks. I will try to work without unsafePerformIO
18:49:40 <arkeet> ok
18:49:57 <arkeet> that means question will have to be an IO action or something
18:50:11 <Hijiri> you could also feed a random seed as an input to the function
18:50:21 <Hijiri> and then generate a seed in your main IO stuff
18:50:24 <arkeet> you could, but that just moves the IO stuff elsewhere.
18:50:56 <jmcarthur> not that pushing IO elsewhere is bad...
18:51:18 <jmcarthur> i do it whenever i can, in fact
18:51:22 <arkeet> sure
18:51:23 <Sai__> I am using randomRIO. I think it should be fine
18:53:17 <isomarcte> Does anyone have a favorite HTTP client library in Haskell? Something for connecting to REST APIs?
18:53:50 <ronh> I like MonadRandom. you can call the same random functions in both IO and non-IO code
18:54:28 <peddie> @hackage wreq isomarcte 
18:54:28 <lambdabot> http://hackage.haskell.org/package/wreq isomarcte
18:55:20 <isomarcte> peddie: Thanks, I'll take a look
18:55:53 <glguy> I like the standard HTTP library in general. Did wreq update to work on GHC 7.10.1 yet?
18:56:18 <arkeet> it doesn't have a new version so I'd assume no.
18:58:16 * hackagebot atlassian-connect-descriptor 0.4.0.2 - Code that helps you create a valid Atlassian Connect Descriptor.  http://hackage.haskell.org/package/atlassian-connect-descriptor-0.4.0.2 (RobertMassaioli)
19:00:30 <defanor> i'd like to write a basic gui application, but not sure which package to pick. looking for something lightweight (wrt dependencies), cross-platform (though primarily for linux), maintained, visually nice, and not too low-level. any suggestions?
19:04:01 <arkeet> light dependencies I guess rules out gtk and qt then? 
19:04:28 <defanor> arkeet: not necessary, that's probably the required minimum anyway
19:04:38 <arkeet> fltkhs gives you fltk bindings 
19:04:40 <defanor> (if not counting web-based gui as gui)
19:04:40 <paperManu> defanor, you can try imgui, it's great for basic guis
19:05:02 <arkeet> for web based gui you could use something like threepenny-gui
19:05:07 <defanor> arkeet, paperManu: thanks, will check those
19:13:09 <arkeet> can't seem to find any sort of haskell bindign for imgui
19:14:02 <defanor> same here
19:24:41 <Zemyla> Does newtype M a = M (forall m. (Monad m) => m a) give a well-founded type?
19:25:37 <Sai__> Hijiri , arkeet : thanks it is working now without the unsafePerfromIO
19:25:58 <arkeet> Zemyla: you can write that but it's not very useful.
19:26:31 <arkeet> it's only as good as a
19:26:37 <Zemyla> arkeet: Well, ideally what I want is something along the lines of:
19:27:30 <Zemyla> newtype M c a = M (forall m. (Monad m, c m) => m a) with ConstraintKinds.
19:27:50 <arkeet> still sounds not very useful.
19:38:18 * hackagebot libconfig 0.3.0.0 - Haskell bindings to libconfig  http://hackage.haskell.org/package/libconfig-0.3.0.0 (peddie)
19:39:20 <georgyy> if I want to shoot ultra wide angle do I have buy dslr? under 20mm equivalent (ideally 16mm)
19:40:15 <ackthet> wrong channel?
19:42:37 <echo-area> Is there Gentoo user here?  I use the haskell overlay and after upgrading today I got this: http://pastebin.com/n7Zjbqix  Should I ask this here or in #gentoo?
19:43:56 <shachaf> You should ask in #gentoo-haskell
19:44:05 <echo-area> Thanks
19:44:22 <shachaf> @where+ gentoo #gentoo-haskell
19:44:22 <lambdabot> Done.
20:21:19 <Denommus> @src (<*>) 
20:21:19 <lambdabot> Source not found. I am sorry.
20:21:33 <Denommus> @src Applicative 
20:21:33 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
20:22:02 <Denommus> @src fmap
20:22:03 <lambdabot> Source not found.
20:22:14 <Denommus> I quit 
20:22:46 <kazagistar> @src isn't very smart, it just has a limited dictionary
20:22:46 <lambdabot> Source not found. :(
20:27:52 <jle`>  @src is just a text lookup on a text file
20:28:28 <glguy> (<*>) and fmap don't have source in general. They have one implementation per instance
20:28:29 <georgyy> yeah wrong channel, sirry
20:29:35 <ronh> @info fmap
20:29:35 <lambdabot> fmap
20:29:42 <ronh> @info (<*>)
20:29:42 <lambdabot> (<*>)
20:29:46 <ronh> useful..
20:31:40 <pavonia> ronh: @info redirects to @undo
20:32:18 <pavonia> @info do { x <- m; return (f x) }
20:32:18 <lambdabot> m >>= \ x -> return (f x)
20:33:20 * hackagebot witherable 0.1.2.3 - Generalization of filter and catMaybes  http://hackage.haskell.org/package/witherable-0.1.2.3 (FumiakiKinoshita)
20:34:23 <arkeet> @@ @pl @undo do { x <- m; return (f x) }
20:34:23 <lambdabot>  f `fmap` m
20:34:29 <arkeet> infix
20:43:20 * hackagebot rethinkdb-client-driver 0.0.17 - Client driver for RethinkDB  http://hackage.haskell.org/package/rethinkdb-client-driver-0.0.17 (wereHamster)
20:47:45 <ronh> still not smart enough to do `f <$> m' :P
20:48:06 <ronh> but nice still
20:53:53 <georgyy> f# or haskell on windows?
20:54:26 <arkeet> yes, both run on windows
20:54:50 <georgyy> which is a better choice
20:55:09 <arkeet> well, naturally the answers here will be biased toward haskell.
20:55:52 <arkeet> there are pretty significant differences between them.
20:56:05 <georgyy> thats fine (about bias)
20:56:46 <arkeet> haskell is laz and (thus necessarily) pure, while as far as I know, F# is strict and has side effects 
20:56:50 <arkeet> haskell is lazy*
20:56:56 <arkeet> much like my typing
20:57:33 <arkeet> so F# is closer to languages like ocaml in that sense
20:57:39 <georgyy> unfortunately I only have a vague idea about what those words mean
20:57:58 <jeffdc> https://msdn.microsoft.com/en-us/library/dd233247.aspx
20:58:18 <arkeet> I would suggest learning haskell.
20:58:39 <arkeet> because it forces you to think about programming in a different way, I guess.
20:58:49 <georgyy> someone told me that haskell is a better language, but that f# is a better choice for windows. agree or disagree? 
20:59:05 <arkeet> rather than the other languages which I guess make it a bit easy to fall back to imperative or whatever habits.
20:59:35 <georgyy> I see.. I do want to learn about functional  programming
20:59:37 <arkeet> I think the main reason one might want to use F# is just the fact that it's .net
21:00:16 <arkeet> haskell runs perfectly fine on windows, but if you want to do windows-specific stuff then it's probably a little less friendly
21:00:44 <pacak> On #haskell channel obvious answer will be Haskell.
21:01:13 <arkeet> if anything, learning haskell will make you a better programmer in any language. :p
21:01:24 <echo-area> arkeet: You might be implying GHC :P
21:02:04 <arkeet> well yes, it would have been more correct to say ghc instead sometimes.
21:02:18 <peddie> georgyy: if your goal is to learn about functional programming, try haskell :)  if your goal is to build some particular windows program, having easy access to .NET will probably be the main factor
21:02:20 <arkeet> but the distinction isn't terribly important in this case 
21:03:09 <arkeet> random googling http://stackoverflow.com/questions/44961/what-are-the-primary-differences-between-haskell-and-f
21:03:21 * hackagebot dynamic-graph 0.1.0.8 - Draw and update graphs in real time with OpenGL  http://hackage.haskell.org/package/dynamic-graph-0.1.0.8 (adamwalker)
21:03:21 <arkeet> http://www.quora.com/What-are-the-pros-and-cons-of-F-versus-Haskell-as-functional-programming-languages
21:03:37 <arkeet> just google "haskell vs f#" (or "haskell vs ocaml" or whatnot)
21:03:54 <georgyy> i know c#, so f# would be an easier transition. but haskell attracts me more :)
21:04:32 <arkeet> then follow your attraction :)
21:04:40 <montagy> someone use spock? i stuck with http://lpaste.net/131654
21:04:58 <kadoban> georgyy: Give it a shot then, it's a fun language. https://github.com/bitemyapp/learnhaskell has good recommendations
21:05:54 <arkeet> montagy: well, as it says, it's expecting a SpockM Connection (Maybe SessionId) BlogState ()
21:06:22 <arkeet> where yo uhave blogApp
21:06:22 <arkeet> but you have a SpockM ConnectionPool (Maybe SessionId) BlogState ()
21:06:30 <arkeet> I'm not familiar with spock but maybe all you need to do is change that type synonym.
21:06:36 <montagy> arkeet, yes but if i change to Connection ,it also get an error to need a ConnectionPool
21:07:14 <montagy> very confused ,i cant find where the Connection come out
21:10:17 <georgyy> just one more ill-formed, vague question and I will stop :). just how much more functional is haskell than f#? one of my goals is to learn fp
21:11:09 <ackthet> georgyy: you might check out #haskell-beginners 
21:11:18 <georgyy> purely functional means you can only fo functional programming?
21:11:29 <georgyy> ackthet: ok
21:11:52 <arkeet> purely functional means your functions have no side effects - given the same input, a function will always produce the same output 
21:11:55 <arkeet> without doing anything else
21:12:05 <arkeet> i.e. they are pure functions
21:12:16 <ackthet> it will be fairly different from F#
21:12:22 <arkeet> which makes reasoning about code very nice
21:12:44 <pacak> But makes functions like getChar() or random() a bit strange...
21:12:49 <arkeet> but it also means you have to handle side effects a bit differently
21:12:59 <pacak> You'll need to use warm fuzzy things called Monads.
21:13:05 <pacak> :t print
21:13:06 <lambdabot> Show a => a -> IO ()
21:13:10 <arkeet> no, you use IO.
21:13:11 <Rotaerk> bleh
21:13:13 <Rotaerk> yea, IO
21:13:23 <Rotaerk> the fact that IO is a monad is kind of beside the point
21:13:28 <Rotaerk> that just lets you chain them together
21:14:02 <pacak> :t (>>=)
21:14:03 <lambdabot> Monad m => m a -> (a -> m b) -> m b
21:14:13 <arkeet> :t (>>=) :: IO a -> (a -> IO b) -> IO b
21:14:13 <lambdabot> IO a -> (a -> IO b) -> IO b
21:14:15 <echo-area> All side effects are controlled
21:14:16 <arkeet> no Monad here!
21:14:29 <pacak> :k IO
21:14:30 <lambdabot> * -> *
21:14:41 <arkeet> right, so instead of saying haskell has no side effects
21:14:59 <arkeet> it's better to say that haskell gives precise control of side effects
21:15:11 <pacak> They are there (bless unsafePerformIO) but it's much easier to control them.
21:15:12 <arkeet> and gives you a nice separation between pure code and effectful code
21:15:21 <arkeet> don't even mention unsafePerformIO.
21:15:34 <Rotaerk> IMO it can be thought of as IO being a value that *describes* or *represents* a block of side effects
21:15:42 <Rotaerk> and then the runtime receives this and runs it
21:15:42 <arkeet> mhm
21:16:08 <pacak> And when they failed to implement STM monad in F# Simon with help of a few minions managed to do that relatively easy :)
21:16:10 <ronh> i think it is useful to understand how putChar and other functions can be implemented without any effects at all.. and actually implementing them and a limited stdout/stdin-only Monad
21:16:20 <pacak> :info RealWorld
21:16:22 <ackthet> is it me or does command line hoogle blow
21:16:26 <arkeet> this IO thing isn't a general aspect of functional programming, it's just how haskell chooses to tackle side effects.
21:16:30 <Rotaerk> so you never print "hello world" from haskell, you just create an IO value that describes this, and call it "main"
21:16:57 <Rotaerk> wonder if georgyy's even paying attention anymore :P
21:17:05 <arkeet> I'd say we lost him :(
21:17:25 <georgyy> I am.. I just dont understand much of what is going on :)
21:17:27 <pacak> Too bad, I haven't even started...
21:17:33 <pacak> He's back :)
21:17:55 <arkeet> georgyy: anyway, I highly recommend learning haskell, whether you decide later you want to use F# or not.
21:18:10 <Rotaerk> warning: you may not want to use F# after you learn it
21:18:17 <arkeet> this is true :-)
21:18:21 * hackagebot avers 0.0.5 - empty  http://hackage.haskell.org/package/avers-0.0.5 (wereHamster)
21:18:23 <pacak> Or any other language...
21:18:30 <arkeet> anyway, 
21:18:33 <arkeet> @where learnhaskell
21:18:34 <lambdabot> https://github.com/bitemyapp/learnhaskell
21:18:43 <arkeet> this is a good starting point for learning haskell.
21:18:52 <georgyy> I already bookmarked it
21:18:56 <arkeet> cool.
21:19:13 <arkeet> and #haskell-beginners is sort of the channel associated with that guide
21:21:59 <pacak> georgyy:  https://pbs.twimg.com/media/B56eMt7CQAAaVJq.png:large
21:23:10 <arkeet> you should link the page with all of them.
21:23:15 <georgyy> pacak :)
21:23:28 <arkeet> http://www.reddittimemachine.com/comics/00001.html
21:31:09 <georgyy> php is funny too
21:34:45 <Jonno_FTW>  I'd say php becomes more productive when you start using a framework which alleviates all the cruft of the standard functions, plus some frameworks can spit out an entire CMS if you feed it your entity relationships
21:37:43 <arkeet> how much can you trust those frameworks though
21:38:40 <pacak> mysql_real_connect()....
21:43:22 * hackagebot cmark 0.3.2 - Fast, accurate CommonMark (Markdown) parser and renderer  http://hackage.haskell.org/package/cmark-0.3.2 (JohnMacFarlane)
21:52:54 <naevathecat> Hey folks, is there a library out there that implements efficient binary min heaps? Data.Binary.Heap looks promsing but I was wondering if there was one using arrays/in place updating and sorting
22:18:23 * hackagebot http-client 0.4.11.2 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.11.2 (MichaelSnoyman)
22:26:58 <lpaste> funfunctor pasted “No title” at http://lpaste.net/131657
22:27:24 <funfunctor> Hi, any folks around who can help me make better use of GetOpt here?
22:28:13 <funfunctor> Would be nice to have help / usage / version switches and such like
22:33:23 * hackagebot aws-route53 0.1.2 - Amazon Route53 DNS service plugin for the aws package.  http://hackage.haskell.org/package/aws-route53-0.1.2 (DavidTerei)
22:38:58 <jle`> anyone know who i can talk to about getting locked out of my hackage packages?
22:39:10 <jle`> i'm logged on to the right account but i keep ong etting access denied/forbidden access
22:46:48 <georgyy> you cant change value of a variable at all in haskell?
22:47:19 <mniip> georgyy, haskell variables are not variables like in other languages
22:47:24 <mniip> they are variables like in math
22:47:43 <georgyy> yeah I see
22:47:54 <mniip> f(x)=x+1, x is a variable, but it doesn't make sense to change that
22:48:21 <arkeet> variables are names 
22:48:29 <arkeet> you can give a name to different things
22:48:33 <arkeet> but you can't change the things you name
22:48:45 <arkeet> ...if that made any sense
22:49:55 <naevathecat> You could think of = in haskell meaning "means". So x=3 just says. Whenever I use x substitute 3. You can't do something like x=x+1.
22:50:17 <georgyy> it does make sense.. its just a radical shift from the languages I know, where most things involve changing variables
22:50:25 <arkeet> well you can write x = x + 1, it just means x is a thing that is 1 more than itself.
22:50:38 <naevathecat> Doesn't the error arkeet?
22:50:42 <arkeet> no
22:50:43 <arkeet> it's recursive
22:50:48 <arkeet> it'll just loop forever.
22:51:07 <ronh> > let x = x : x in x
22:51:08 <lambdabot>      Occurs check: cannot construct the infinite type: a1 ~ [a1]
22:51:08 <lambdabot>      Relevant bindings include x :: [a1] (bound at <interactive>:1:5)
22:51:08 <lambdabot>      In the first argument of ‘(:)’, namely ‘x’
22:51:13 <ronh> > let x = 1 : x in x
22:51:15 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
22:51:20 <ronh> ^^ a more useful example
22:52:03 <naevathecat> Yeah fair enough.
22:52:20 <naevathecat> Well recursion forver = sad anyway
22:52:40 <ronh> yes, unless it is productive
22:52:58 <jle`> well, infinite recursion can be useful :)
22:53:31 <georgyy> how does that work?
22:53:43 <naevathecat> Then its not forever :P like you never actually do the whole thing. take 5 on [1..] doesn't actually compute the natural numbers
22:54:38 <jle`> it semantically defines it, recursively
22:54:39 <jle`> like induction
22:54:49 <jle`> it denotes an infinite list
22:55:29 <jle`> @let ones = 1 : ones
22:55:30 <lambdabot>  Defined.
22:55:33 <jle`> > ones
22:55:35 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
22:55:36 <jle`> > take 10 ones
22:55:38 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
22:55:56 <jle`> ones "means", mathematically, an infinite list of ones. that's what it denotes
22:56:09 <jle`> "take 10 ones" denotes the first ten items of an infinite list of ones.  so it's just ten one's
22:56:24 <naevathecat> Yes. Although the rest of the ones aren't ever computed
22:56:37 <naevathecat> Which is an important point. Or it would just hang
22:56:53 <jle`> mhm.  but defining infinite structures with infinite recursion is useful
22:57:00 <naevathecat> Yes I agree
22:57:06 <naevathecat> Although let x=x+1 would not be
22:57:27 <jle`> it depends on your Num instance ;)
22:57:35 <naevathecat> Oh fine :P
22:57:36 <jle`> but yeah. *can* be useful
22:57:37 <naevathecat> You win
22:58:18 <jle`> i get your point though :)  infinite recursive computation is kinda silly, but infinite recursive mathematical definitions are useful
22:58:26 <jle`> luckily in haskell we get to work with the latter
22:58:36 <jle`> (in addition to the first)
22:58:42 <naevathecat> Well georgyy at any rate. If in c you write x=1 that does some computation. In haskell it might do some of a computation at some point if it would be useful to
23:00:59 <naevathecat> So you don't use variables as such. If you have some function f x = x*x. and at some point you want to use f 5. You can assign a name to that f 5 = 5*5 and use it in scope
23:01:53 <naevathecat> it's not really that different in practice. Unless you want to have something be mutable to avoid copying subsequent versions of it everywhere
23:03:59 <georgyy> can you change a value pointed to by the variable?
23:04:51 <pacak> georgyy: There are no variables in Haskell.
23:05:21 <jle`> georgyy: it's like definition, not assignment
23:05:28 <jle`> there's also not a built-in notion of sequencing in haskell
23:05:37 <jle`> if you say x = 1, and then later x = 2...which x is true?
23:05:44 <naevathecat> There sort of are, Mvars and stuff.
23:05:55 <jle`> and if something uses x, how will it wknow which definition to use?
23:06:02 <Axman6> we'll ignore them how this discussion though
23:06:15 <jle`> naevathecat: yeah, but that's not built-in.  and they aren't the same type of variables we're talking about
23:06:15 <pacak> If you say x = 5 then that's it. x will stay 5 forever!
23:06:34 <jle`> it doesn't make sense to say something like "x = 4; y = x * 2; x = 6"
23:06:36 <jle`> what is y?
23:06:41 <jle`> is it 8, or 12?
23:07:08 <jle`> these are just definitions
23:07:23 <georgyy> I would expect it to be 8 but i see your point
23:07:31 <naevathecat> georgyy: possibly easier to understand with an example. Say I have input n and I need output n+1. I say, f x = x+1. Let name = n let name2 = f name (do stuff with name2). if name 1 is never used again the value will be gargage collected
23:07:50 <jle`> like if you look in a dictionary, and you see, "x word: see the definition of y word"
23:07:57 <jle`> and then y word was defined twice
23:08:01 <jle`> once in the beginning, and once in the end
23:08:06 <jle`> which definition would "x word" be referencing?
23:08:19 <jle`> this is a dictionary...there's no notion of "sequencing", "assigning" definitions
23:08:26 <jle`> it's just a bunch of definitions
23:08:37 <Axman6> georgyy: in imperative languages, = is assignment, in Haskell, = is definition
23:08:54 <georgyy> got it
23:09:22 <jle`> georgyy: "y = x*2; x = 6" makes sense as two definitions: defining y, and defining x
23:09:44 <jle`> so there's no sense of "ordering" of definitions.  in a dictionary, the fact that one word is defined before another word doesn't really mean anything
23:10:25 <naevathecat> You are allowed to "shadow" giving two definitions of a name. But only one will be used (is there ever a point to it?)
23:10:47 <georgyy> I understand all that.. just wondering how tou can gwt anything done like this.. I guess I will learn in next chapters
23:10:56 <jle`> georgyy: yes :)
23:11:02 <jle`> instead of defining "how to do" things, you define "what things are"
23:11:37 <naevathecat> georgyy: do you have a mathematical background? It's easy to understand in terms of linear transforms
23:12:00 <jle`> let's say you had a list [1,2,3] and you wanted a list where everything is doubled.  instead of creating a new list, creating an index variable, increasing it by one, setting the new value in the new list, increasing the index again, etc.
23:12:07 <jle`> you can just say, "my new list is the first list doubled."
23:12:18 <jle`> list2 = map (\x -> x * 2) [1,2,3]
23:12:19 <jle`> and there you go
23:12:28 <georgyy> naevathecat: only highschool level (i am second year)
23:12:32 <jle`> you don't say "how to make" the new list.
23:12:35 <jle`> you say "what the new list is"
23:14:15 <naevathecat> georgyy: In the concrete world. Using the same kind of ideas as in haskell. If I told you an equation for, idk, the cost of apples and the number of apples you needed to buy. You could tell me the amount of money you needed. You didn't change the value I gave you but you could do things with it because you understood the way "n apples" related to "total cost"
23:15:42 <naevathecat> as jle` said. in haskell you are not defining proceedures. You are defining relationships between things
23:16:17 <FreeFull> That's even more true of Prolog compared to Haskell
23:16:35 <naevathecat> I keep meaning to look at that language
23:17:13 <mishach> Hello guys, is there anyone who finished Breny Yorgey course?
23:18:10 <FreeFull> naevathecat: Do look at it
23:19:11 <naevathecat> With all that free time I have :P I will though. One day, currently spending my evenings reading about making haskell play nice with memory limitations
23:24:11 <Axman6> mishach: I haven't, but do you have a specific question?
23:24:28 <mishach> Just wanted to clarify a few things about a quetion on HW 5
23:24:40 <mishach> its more about, making sure I am reading the problem correctly
23:25:11 <Axman6> well, feel free to ask here. there is also #haskell-beginners which has plenty of others who've done the course
23:28:31 <mishach> I am also on haskell beginners
23:28:39 <mishach> it is not as lively as # haskell
23:28:48 <seangrove> Just ask the question, either here or there
23:29:10 <seangrove> "The Ask To Ask protocol wastes more bandwidth than any version of the Ask protocol, so just ask your question."
23:29:18 <arkeet> @where justask
23:29:18 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
23:30:47 <pacak> seangrove: Well, it's still better than Ask to Ask to Ask...
23:30:50 <kadoban> mishach: Nobody on IRC is going to give you an engraved invitation to ask about your actual question, or to discuss what you want. Just … ask or talk or whatever. That's why you're not getting much response.
23:31:22 <mishach> ohh, ok sorry, if my manners came across as being inpolite
23:31:45 <seangrove> mishach: Not impolite at all, just helping you get a sense of the culture ;)
23:31:46 <mishach> ok, In problem #5 HW#5  asks to implement typeclass for Program
23:32:07 <mishach> instance Expr Program where
23:32:20 <pacak> mishach: lpaste for code?
23:32:21 <arkeet> @where cis194
23:32:21 <lambdabot> http://www.seas.upenn.edu/~cis194/fall14/spring13/index.html
23:32:53 <mishach> http://www.seas.upenn.edu/~cis194/fall14/spring13/hw/05-type-classes.pdf
23:33:20 <arkeet> @where+ cis194 http://www.seas.upenn.edu/~cis194/spring13/
23:33:21 <lambdabot> It is forever etched in my memory.
23:35:04 <mishach> this is link to pastebin, but i think for full understanding other two files are required
23:35:05 <mishach> http://pastebin.com/hqfUardf
23:36:02 <mishach> so the question is, once you declare the instance of Program which belongs to Typeclass Expr, how do you separate PushI and PushB
23:36:17 <mishach> in the lit
23:36:18 <mishach> part
23:43:58 <georgyy> jle`: I am familiar with map from other languages.. but still dont see how I could do something useful without modifying variables.. like, for example, how would you do something simple like pushing received items on a stack?
23:44:40 <jle`> georgyy: my suggestion is to let go of worries like this
23:44:55 <georgyy> you have to modify either the variable or the object pointed by it?
23:44:57 <jle`> because in the end you will approach the problem in a way that doesn't even concern this
23:45:08 <teurastaja> how do i enable ParallelListComp in ghci?
23:45:10 <georgyy> I see
23:45:11 <jle`> that's a lot of the vertigo from learbing haskell
23:45:15 <jle`> learning
23:45:34 <jle`> people read it and constantly think, "but how will I do x thing I've done?"
23:45:55 <jle`> but they'll find out it's not even something they would ever need to be concerned about
23:46:16 <solatis> georgyy, i think we've all been there
23:46:29 <solatis> "how can i be productive when i cannot change variables?!"
23:46:50 <jle`> that's what people mean when they say that learning other languages makes learning haskell harder, heh. it's not harder.... there's just this very disorienting and nauseating sense of vertigo that comes from our previous training
23:47:21 <solatis> personally, i was able to "bridge the gap" between imperative and functional languages using scala
23:47:22 <jle`> but if you come at it without any preconceived ideas... this never shows up :)
23:47:51 <solatis> but soon afterwards, i felt very dirty using scala, and was looking for something more pure
23:49:20 <stoopkid> would it make sense to consider something like an "abstract volume" to be a function which takes a bounding surface as input and returns a "concrete volume"?
23:53:28 <jle`> stoopkid: that's one way of looking at functions... and one way of interpreting the Functor instance
23:53:36 <jle`> how useful it is is up to debate
23:54:00 <jle`> but you aren't alone in this idea
23:54:03 <stoopkid> not to look at the functions but to look at the abstract notion of "volume"
23:54:44 <jle`> well, you're looking at a `a -> b` as a sort of "abstract version of b", right?
23:56:02 <stoopkid> yea i guess that makes sense
