00:00:15 <kadoban> nak: Is that [[[[ TRUNCATED ]]]] part of it, or is that your annotation?
00:00:42 <Lis> or how can i merge two lists line by line?
00:01:26 <Lis> like [1..4] [5..8] should be [1,5,2,6,3,7,4,8]
00:01:27 <ski> Lis : iiuc, either use `zipWith', or use the parallel list comprehension extension, `[(mkDate dd mm yyyy,v) | (dd,mm,yyyy) <- dates | v <- vals ]'
00:01:35 <ski> oh, hm
00:01:37 <earthy> Lis: zip
00:01:40 <earthy> ?
00:01:46 <Lis> ok thank you :D
00:01:52 <Lis> both
00:02:13 <ski> > [(x,y) | x <- [1 .. 4],y <- [5 .. 8]]
00:02:15 <lambdabot>  [(1,5),(1,6),(1,7),(1,8),(2,5),(2,6),(2,7),(2,8),(3,5),(3,6),(3,7),(3,8),(4,...
00:02:18 <ski> > [(x,y) | x <- [1 .. 4] | y <- [5 .. 8]]
00:02:19 <lambdabot>  [(1,5),(2,6),(3,7),(4,8)]
00:02:25 <ski> > concat [[x,y] | x <- [1 .. 4] | y <- [5 .. 8]]
00:02:26 <lambdabot>  [1,5,2,6,3,7,4,8]
00:02:38 <ski> Lis : seems like you wanted the last variant ?
00:02:38 <nak> kadoban that is me, i truncated the output
00:02:48 <nak> kadoban in fact, hakyll is still installing lol
00:03:13 <ski> also note that the parallel list comprehension (middle one, also used in third one) can be expressed by `zipWith' :
00:03:33 <Lis> ski, the last variant was just an alternative, so i could use that list for the comprehension above. becouse i didnt know about parallel list comprehension
00:03:34 <ski> > zipWith (\x y -> (x,y)) [1 .. 4] [5 .. 8]
00:03:35 <lambdabot>  [(1,5),(2,6),(3,7),(4,8)]
00:03:39 <Lis> big thanks ski 
00:03:45 <ski> > concat (zipWith (\x y -> [x,y]) [1 .. 4] [5 .. 8])
00:03:47 <lambdabot>  [1,5,2,6,3,7,4,8]
00:04:33 <nak> ski that one is cool
00:04:37 <arkeet> > concat $ transpose [[1..4],[5..8]]
00:04:38 <lambdabot>  [1,5,2,6,3,7,4,8]
00:04:53 <kadoban> nak: It … may be okay, I'm not sure. Those warnings look weird, but … at least they're only warnings.
00:05:03 <ski> nak : which ?
00:05:10 <nak> ski i liked the concat one
00:05:32 <nak> arkeet's is simpler but i don't quite know how that one works yet
00:05:37 <arkeet> > transpose [[1..4],[5..8]]
00:05:39 <lambdabot>  [[1,5],[2,6],[3,7],[4,8]]
00:05:41 <nak> this is day #2 for my haskell
00:05:48 <arkeet> do you know what the transpose of a matrix is?
00:06:05 <nak> > concat transpose [[1..4],[5..8]]
00:06:07 <lambdabot>      Couldn't match expected type ‘[[Integer]] -> t’
00:06:07 <lambdabot>                  with actual type ‘[[a0]]’
00:06:07 <lambdabot>      The function ‘concat’ is applied to two arguments,
00:06:19 <arkeet> needs more parentheses. or $
00:06:21 <ski> nak : use brackets
00:06:28 <nak> > concat (transpose [[1..4],[5..8]])
00:06:30 <lambdabot>  [1,5,2,6,3,7,4,8]
00:06:32 <nak> ah ok
00:06:33 <arkeet> > transpose [[1,2,3],[4,5,6],[7,8,9]]
00:06:34 <lambdabot>  [[1,4,7],[2,5,8],[3,6,9]]
00:06:48 <nak> arkeet yeah the transpose is like a rotation, right ?
00:06:58 <arkeet> yeah. if you think of a list of lists as the rows in a 2D array, transpose just interchanges rows and columns.
00:07:22 <nak> arkeet does it require that each of the lists are equal length ?
00:07:25 <nak> :t transpose
00:07:26 <lambdabot> [[a]] -> [[a]]
00:07:27 <arkeet> nope
00:07:30 <ski> nak : if you arrange it in a two-dimensional matrix, you can think of transposition as mirroring along a diagonal
00:07:32 <arkeet> > transpose [[1,2,3],[4,5],[7,8,9,10]]
00:07:33 <lambdabot>  [[1,4,7],[2,5,8],[3,9],[10]]
00:07:43 <nak> uh
00:07:45 <nak> lol
00:08:01 <arkeet> but then it's a bit harder to interpret what it means.
00:08:03 <ski> > (transpose . transpose) [[1,2,3],[4,5],[7,8,9,10]]
00:08:04 <lambdabot>  [[1,2,3,10],[4,5,9],[7,8]]
00:08:14 <arkeet> and you lose some nice properties, such as transposing twice giving you back the original input.
00:08:46 <nak> (transpose . transpose) [[1,2,3],[4,5,6],[7,8,9]]
00:08:50 <nak> > (transpose . transpose) [[1,2,3],[4,5,6],[7,8,9]]
00:08:51 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9]]
00:08:54 <ski> > (transpose . transpose) [[0,1,2,3],[4,5,6],[7,8],[9]]
00:08:54 <nak> ok cool
00:08:55 <lambdabot>  [[0,1,2,3],[4,5,6],[7,8],[9]]
00:09:21 <nak> $ cabal install -j hakyll
00:09:28 <Lis> hm, if i have a list of [int,int,int] and [int] and want to use comprehension (a,b,c) <- list | (d) <- vals it doesnt work. do i need to use a <- (list !!0), ... or is it possible more elegantly?
00:09:33 <nak> ^ this has been running for like 10 minutes or more
00:09:39 <nak> how long does it ordinarily take to install a package ?
00:10:04 <arkeet> depends on the package.
00:10:12 <arkeet> and the machine it's installing on.
00:10:15 <kadoban> nak: hakyll is built on pandoc, which is pretty huge, and a few other things too. It does take /quite/ a while.
00:10:32 <ski> Lis : is the type of `dates' `[(Int,Int,Int)]', and the type of `vals' `[Int]' ?
00:10:48 <nak> kadoban ok
00:10:53 <ski> Lis : what is the type of `mkDate' ?
00:10:58 <kadoban> My computer blows, I usually just start it up and go make $nextmeal$, I would estimate it takes 15ish minutes, or maybe more.
00:10:58 <Lis> no, the type of dates is [Int]
00:11:39 <ski> then it's not clear what you intend by `(dd,mm,yyyy) <- dates'
00:11:57 <Lis> ski i thought it's some sort of linear list transformation
00:12:11 <ski> can you give an example value of `dates', and how you in that case (successively) want values for `dd',`mm',`yyyy' to be drawn from it ?
00:14:20 <Lis> [1,2,2000,2,2,2000,...] now in c i could just get 3 elements and put them into my initialization function
00:15:48 <Lis> also know as linear transformation, where you store ever data construct as 1d and create 2d out of that later, becouse of speed reasons
00:15:56 <kadoban> Lis: It seems kinda icky to me that that's how you're storing dates. Can you change that part? Having a list of Date, howevery you want to define that seems to make much more sense
00:16:24 <Lis> kadoban, yea shure i can change that to [(Int,Int,Int)] if thats better
00:16:30 <kadoban> Options would be just tuples, a newtype, a whole data type, etc.
00:16:45 <kadoban> Lis: It seems more sane to me, yeah. And it should be easier to work with as well.
00:17:05 <ski> Lis : you could try `[dd,mm,yyyy] <- chunksOf 3 dates', using `chunksOf' from the `split' package (module `Data.List.Split')
00:17:19 <zaquest> jle`, im doing NICTA exercises and was wondering if i can write it in point free style
00:17:21 <ski> > chunksOf 3 [1,2,2000,2,2,2000]
00:17:23 <lambdabot>  [[1,2,2000],[2,2,2000]]
00:18:03 <ski> > [(dd,mm,yyyy,v) | [dd,mm,yyyy] <- chunksOf 3 [1,2,2000,2,2,2000] | v <- [111,222]]
00:18:05 <lambdabot>  [(1,2,2000,111),(2,2,2000,222)]
00:19:48 <ski> Lis : yes, if you can use `[(Int,Int,Int)]' or similar, that would be better. but if you're getting a `[Int]' from somewhere, and can't change that part of the interface, then `chunksOf' would be a way to convert to the preferred format after you receive the `[Int]'
00:20:12 <Lis> ok thank you kadoban and ski
00:26:08 <jle`> also consider using an ADT instead of a three-tuple
00:26:18 <jle`> data Date = Date Int Int Int
00:26:37 <arkeet> data Date = Date{ day, month, year :: Int }
00:27:01 <ski> well, they're using some `mkDate dd mm yyyy'
00:27:39 <xandaros> I try to avoid records for small datatypes, it creates so many globals :/
00:29:21 <jle`> do you avoid utility functions too? :|
00:29:51 <Lis> jle`, i am using the chart package, it wants (int,int,int)
00:29:58 <jle`> ah i see :)
00:33:09 <Lis> Unexpected parallel statement in a list comprehension not i have [(Int,Int,Int)] and [Double] with [(mkDate dd mm yyyy,v) | (dd,mm,yyyy) <- dates | v <- vals ]
00:33:40 <jle`> you might have to enable a language extension
00:33:55 <jle`> {-# LANGUAGE ParallelListComp #-}
00:34:01 <ski> add `{-# LANGUAGE ParallelListComp #-}' to the top of your file
00:34:21 <bitemyapp> `'
00:34:30 <bitemyapp> there's a TeX'ism if I ever saw one
00:34:36 <bitemyapp> ``''
00:34:43 <Lis> ski, done, still same error
00:34:51 <ski> what is the exact error ?
00:35:13 <Lis> Unexpected parallel statement in a list comprehension Use ParallelListComp
00:35:36 <kadoban> Lis: It has to be at the /very/ top of the file or it has no effect.
00:35:43 <Lis> ah ok
00:35:59 <ski> before the `module ...' line, if any
00:36:13 <Lis> yea, now it works, thank you :D
00:39:39 <Lis> No instance for (Fractional [Double]) arising from a use of `/'    In the expression: ([0.0] ++ vals) / vals ??
00:40:04 <jle`> Lis: you can't really divide a list normally
00:40:10 <Lis> :(
00:40:17 <Lis> so alot of map
00:40:21 <jle`> what do you expect [1,2,3] / [1,2] to be?
00:41:00 <jle`> component-wise division?
00:41:36 <jle`> if so then you can use zipWith, although keep in mind zipWith ignores all "unmatched" items
00:41:50 <jle`> > zipWith (/) [1,2,3] [2,3,4,5]
00:41:52 <lambdabot>  [0.5,0.6666666666666666,0.75]
00:42:09 <arkeet> > let (./) = zipWith (/) in [1,2,3] /. [2,3,4,5]
00:42:11 <lambdabot>      Not in scope: ‘/.’
00:42:11 <lambdabot>      Perhaps you meant one of these:
00:42:11 <lambdabot>        ‘./’ (line 1), ‘.’ (imported from Data.Function),
00:42:15 <arkeet> > let (./) = zipWith (/) in [1,2,3] ./ [2,3,4,5]
00:42:15 <arkeet> hur
00:42:16 <lambdabot>  [0.5,0.6666666666666666,0.75]
00:42:26 <jle`> are we matlab now :)
00:43:04 <arkeet> > let (-/-) = liftA2 (/) in [1,2,3] -/- [2,3,4,5]
00:43:05 <lambdabot>  [0.5,0.3333333333333333,0.25,0.2,1.0,0.6666666666666666,0.5,0.4,1.5,1.0,0.75...
00:43:24 <frerich_> Can anybody un-tangle my mind regarding dependent types? I just became aware of this nice Reddit ocmment on how dependent types are more powerful than abstract types (+ smart constructors): http://www.reddit.com/r/haskell/comments/31lru4/necessityutility_of_dependent_types/cq2t6i6 -- there is an example of a Vector type wich has the length encoded in the type.
00:44:01 <arkeet> > (zipWith (/) <*> tail) [1..10]
00:44:02 <lambdabot>  [0.5,0.6666666666666666,0.75,0.8,0.8333333333333334,0.8571428571428571,0.875...
00:44:20 <arkeet> > (zipWith (/) <*> tail) [1..] :: [Float]
00:44:21 <lambdabot>  [0.5,0.6666667,0.75,0.8,0.8333333,0.85714287,0.875,0.8888889,0.9,0.90909094,...
00:44:25 <frerich_> Now, it might be my utter lack of experience with GADTs, but the '(:@) :: a -> Vector n a -> Vector (S n) a' declaration confuses me: Is the first argument to Vector a type, or a value?
00:44:38 <arkeet> it is a type.
00:44:47 <arkeet> n is a type-level natural number.
00:44:48 <frerich_> It looks like a plain value (of type Nat) to me, but then I don't see how anything is encded in the type of Vector.
00:45:06 <frerich_> arkeet: but 'Z' and 'S Z' and 'S (S Z)' all have the same type, no?
00:45:11 <arkeet> it is a type of kind Nat.
00:45:13 <jle`> they are all different types
00:45:20 <jle`> Z is a type, and S Z is a type
00:45:25 <jle`> just like Int is a type, and Maybe Int is a type
00:45:28 <jle`> different types
00:45:53 <frerich_> Huh? They are just different data constructors for the same 'Nat' type, no?
00:45:58 <frerich_> > data Nat = Z | S Nat
00:45:59 <lambdabot>  <hint>:1:1: parse error on input ‘data’
00:46:06 <jle`> we're using DataKinds
00:46:09 <frerich_> Hm, not sure whether I can test this in lambdabot...
00:46:11 <arkeet> with DataKinds, "data Nat = Z | S Nat" defines two things.
00:46:22 <jle`> which lets us use Nat as a Kind, Z as a Type, and S as a type constructor
00:46:24 <arkeet> it defines a type called Nat, with values Z, S Z, S (S Z), etc.
00:46:26 <frerich_> Ahaaa, DataKinds. That's a term which wasn't mentioned.
00:46:38 <jle`> mhm. that's why we can use S at the type level
00:46:40 <arkeet> it also defines a kind called Nat, which contains types Z, S Z, S (S Z), etc.
00:47:05 <frerich_> Ok, thanks for dropping that term, I'll read up on it. As it is, that comment didn't mention DataKinds and I got really confused :-}
00:47:10 <arkeet> okay.
00:47:17 <jle`> ah yes haha.  that'd probably be some important context :)
00:47:37 <arkeet> before DataKinds existed, 
00:47:43 <arkeet> one could have done something like this:
00:47:45 <arkeet> data Z
00:47:46 <frerich_> I guess if you already knew what DataKinds does, then the line 'data Vector :: Nat -> * -> * where' might have given away that the code only works because of it.
00:47:48 <arkeet> data S n
00:47:56 <arkeet> then Z is a type, and then S Z is a type, etc.
00:48:21 <jle`> frerich_: mhm :)  you're using a kind called Nat...but it's hard to make your own custom kinds without DataKinds
00:48:45 <arkeet> the disadvantage of this is that you could write some nonsense thing like S (S Int) or something.
00:48:45 <jle`> with DataKinds we can make kinds as easily as we make types
00:49:07 <arkeet> DataKinds restricts that (and makes S Int a kind error).
00:49:31 <arkeet> (for we have S :: Nat -> Nat instead of S :: * -> *)
00:50:16 <jle`> next up is DataSorts
00:50:25 <arkeet> I hope not!
00:50:26 <arkeet> :p
00:51:05 <jle`> or how about we just flatten/merge all the layers into one
00:51:13 <Lis> jle`, sorry phone. no but we are alot better then matlab ...
00:51:15 <jle`> values, types, kinds, sorts...
00:51:25 <Lis> jle`, i was forced to use it at my study course
00:51:27 <frerich_> Hm, so would it be safe to say that 'DataKinds' gets some extra 'safety' (to avoid that you do 'S Int') but the crucial feature for making this work is GADTs since they allow to yield a Vector with a different length type?
00:52:05 <arkeet> jle`: that would mean full-blown dependent types, no?
00:52:18 <jle`> GADT's let you specify type signatures in a way that lets you take advantage of this yes
00:52:25 <arkeet> frerich_: yeah.
00:52:27 <jle`> arkeet: yeah i think my joke was alittle too subtle
00:52:43 <arkeet> it could be done without DataKinds but it's nicer with it.
00:52:53 <arkeet> where's that paper
00:53:05 <arkeet> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.2636
00:53:41 <arkeet> this paper describes length-annotated vectors using GADTs, but it's from well before DataKinds existed.
00:53:48 <arkeet> I think.
00:56:29 <frerich_> arkeet: Hmm, from that page I got to 'Cayenne -- a Language With Dependent Types (1998) -- by Lennart Augustsson' and now I feel like I'm reaaaallly late for the party.
00:56:47 <capisce> everyone feels that way
00:56:49 <arkeet> dependent types aren't *that* new.
00:56:49 <arkeet> :p
00:57:10 <arkeet> Coq has been around since 1989.
00:57:36 <arkeet> and I'm sure there are older.
00:58:31 <ollef> we're all late: https://en.wikipedia.org/wiki/Automath :)
00:59:31 <arkeet> 1967. not bad.
00:59:57 * frerich_ thinks it's evidently clear that everyone is really just standing on the shoulders of giants
01:00:09 <arkeet> :)
01:00:26 <jle`> or maybe it's just a really tall chain of various-sized people
01:00:28 <frerich_> I sometimes look at the Wikipedia page of e.g. Haskell Curry and then move backwards in time via the 'doctoral advisor' links
01:01:16 <arkeet> relevant http://genealogy.math.ndsu.nodak.edu/id.php?id=7398
01:01:34 <frerich_> Ha, Hilbert was his advisor!
01:01:44 <arkeet> neat.
01:01:57 <jaseemabid> Just read this short transcript of #haskell. Awesome! I had a good laugh :) https://gist.github.com/quchen/5280339
01:03:07 <arkeet> I vaguely remember this.
01:03:12 <frerich_> jaseemabid: Yeah, that's a good one. I recently had the idea that since Haskell is really a 'research' language with a lot of crazy (more or less new) features, everyone always stays humble because things are evolving so quickly. And the staying humble part helps a great deal with dealing with 'beginnger' questions.
01:03:28 <arkeet> oh. I'm in that log.
01:03:35 <frerich_> It seems as if knowledge of Haskell converges a lot slower than in other language.
01:03:51 <timothyh> any way to look up available instances of a typeclass? (MonadZip)
01:04:06 <jle`> timothyh: you can use :i in ghci if the instances are in scope
01:04:06 <arkeet> timothyh: ghci's :info will tell you which instances are in scope
01:04:16 <jle`> there's also the haddock documentation too
01:04:24 <timothyh> oh, I guess I have none in scope 
01:05:00 <timothyh> mm none ship in Control.Monad.Zip, i'm just curious who else ships MonadZip instances
01:05:04 <jaseemabid> frerich_: Yeah. I've been fiddling with haskell for around a year now and its loads of fun. I'm failing constantly at convincing others though..
01:05:12 <arkeet> https://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Monad-Zip.html#t:MonadZip
01:05:15 <arkeet> just lists [] and Identity
01:05:34 <arkeet> it ought to have (r ->) too
01:05:59 <timothyh> bound to be more out there, and i am curious how to find them mechanically
01:06:17 * jaseemabid decided to write the most IO heavy program in a purely functional lang and is working on a tiny little bittorrent client atm
01:06:48 <timothyh> jaseemabid: haskell is a great procedural language too :)
01:08:58 <jaseemabid> timothyh: Yeah. The learning curve though...
01:10:05 <ski> jaseemabid : it has been opined that that kind of response isn't necessarily that good, insofar as it could turn more reasonable beginners off the channel
01:10:56 <timothyh> yeah, it's a shame. learning fundamentals is easy, and learning all the idioms can be overwhelming 
01:10:58 <jaseemabid> ski: Sure. I don't want to demotivate anyone. Apologies. 
01:11:35 <jaseemabid> If I had to write software that my life depended on, I would seriously consider using Haskell - John Carmack https://twitter.com/ID_AA_Carmack/status/585871417855516672
01:11:56 <jaseemabid> This is what I show haskell beginners :) ^ 
01:12:37 <grumpi> basically, as someone who knows functional programming but not the finer points of Haskell (and neither the standard libraries of Haskell), I feel that learning Haskell doesn't look harder than learning the finer points of object oriented programming
01:12:55 <frerich_> ski: I think opinions which prefer not to mention that Haskell may have a steep learning curve might well be detrimental to beginners as well, suggesting that it's "inappropriate" to consider something difficult.
01:13:33 <arkeet> I do C++ at work and I find it much more unsettling to use than haskell.
01:13:37 <arkeet> D:
01:13:37 <grumpi> and I have the strong feeling that there are less ways to shoot yourself in the foot
01:14:23 <ski> frerich_ : yes
01:14:35 <Aruro> Is stackage similar to cabal sandbox? or it puts new packages in global database?
01:15:00 <arkeet> stackage is just a vetted set of package versions
01:15:39 <Aruro> arkeet: k
01:19:54 <Aruro> so if i want to have general compilation command it better be something like cabal exec ghc ? which will pick sandbox if present and use system wide packages otherwise?
01:36:45 <jle`> btw i haven't announced this yet here but if anyone here in this channel is located in vietnam or is vietnamese i've started #haskell.vn
01:36:54 <jle`> non-vietnamese and non-located-in-vietnam also welcome of course
01:37:51 <jle`> mostly just for people interested in the vietnamese haskell community
01:37:54 <jle`> ty
01:39:28 <ski> jle` : perhaps you could add it to
01:39:29 <ski> @wiki IRC channel
01:39:29 <lambdabot> http://www.haskell.org/haskellwiki/IRC_channel
01:39:59 <jle`> ski: thanks :)
01:45:06 <Lis> i get  "Non-exhaustive patterns in function tuple3" tuple3 :: [Int] -> (Int,Int,Int); tuple3 [] = (0,0,0); tuple3 [x,y,z] = (x,y,z) what do i miss?
01:45:11 <sgronblo> I can take the opportunity at the same time to advertise Tokyo Haskell Meetup which has an event tomorrow http://www.meetup.com/Tokyo-Haskell-Meetup/
01:46:10 <arkeet> Lis: any list of length other than 0 or 3
01:46:39 <Lis> arkeet, ah ok, i am not sure if i understand that
01:46:58 <arkeet> the first case tells what to do on a list of length 0 (namely, the list [])
01:47:05 <arkeet> the second case tells what to do on a list of length 3
01:47:12 <arkeet> but what if I give you a list with 2 elements, or 5, or ...
01:47:28 <Lis> ok, and how do i just return (0,0,0) for all other lists?
01:47:31 <ski> Lis : if you evalaute e.g. `tuple3 [2,4]', you will get an error, since you're not handling the list dupleton case
01:47:41 <arkeet> you can use a wildcard pattern
01:47:41 <arkeet> _
01:47:46 <arkeet> tuple3 _ = (0,0,0)
01:47:48 <Lis> ty
01:47:49 <arkeet> (but make sure to put this one last)
01:47:54 <kadoban> Lis: blah _ = (0,0,0)    -- make sure it's after the others.
01:48:06 <ski> Lis : oh, just write `tuple3 _ = (0,0,0)' as the last defining equation
01:48:06 <kadoban> Heh … too slow
01:48:26 <ski> Lis : .. however, do you really need to define it for other number of elements than three ?
01:48:57 <arkeet> if you're certain it should only take lists of length 3, you can just make the other cases an error.
01:49:05 <Lis> i just get the error if i run my programm ski
01:49:13 <Lis> adding foo _ solved the error
01:49:14 <arkeet> something like: tuple3 _ = error "tuple3: wrong number of elements"
01:49:51 <frerich_> Lis: I think it would be interesting to consider the caller of that tuple3 function, I suspect there's a good way to change it such that you don't need to turn a list into a 3-tuple in the first place.
01:49:54 <arkeet> that would please the compiler (but it would still blow up at runtime with that message)
01:50:46 <Lis> hm as quick fix it is working, but i will look into that deeper
01:52:33 <Lis> how do i catch a read error and return 0? stringToDouble (x:xs) = (read x :: Double) : stringToDouble xs if read x fails i want 0.0 to be returned
01:53:06 <aleator> A strange question, but I'm designing a homework assignment about testing code and I need to autograde the assignment. How would a smart person do that?
01:53:17 <ski> > (reads :: ReadS Double) "12.34"
01:53:19 <lambdabot>  [(12.34,"")]
01:53:23 <ski> > (reads :: ReadS Double) "bad input"
01:53:24 <lambdabot>  []
01:53:44 <ski> > (reads :: ReadS Double) "12.34extra stuff at end"
01:53:45 <lambdabot>  [(12.34,"extra stuff at end")]
01:54:08 <frerich> Lis: 'stringToDouble' sounds like something which could fail, so maybe it should yield a 'Maybe Double'
01:54:14 <aleator> Lis, ski: import Safe; readDef 0 "17" ?
01:54:25 <frerich> Lis: ...in which case you could also use a readily existing 'readMaybe' function (or 'maybeRead'?)
01:54:30 <ski> you can use `case', or a helper function, to discriminate amongst the cases
01:54:42 <ion> http://hackage.haskell.org/package/base-4.8.0.0/docs/Text-Read.html#v:readMaybe
01:54:53 <frerich> Yeah, that's the one.
01:55:36 <Lis> ok, thank you
01:55:38 <ion> > (fromMaybe 0 . readMaybe) "42" :: Double
01:55:39 <lambdabot>  Not in scope: ‘readMaybe’
01:55:55 <ollef> aleator: I've done something like that using quickcheck. you could also have a look at the various testing frameworks, e.g. tasty.
01:55:56 <ion> > (fromMaybe 0 . Text.Read.readMaybe) "42" :: Double
01:55:58 <lambdabot>  Not in scope: ‘Text.Read.readMaybe’
01:56:54 <ski> @let import Text.Read
01:56:55 <lambdabot>  Defined.
01:57:00 <ski> > (fromMaybe 0 . readMaybe) "42" :: Double
01:57:02 <lambdabot>  42.0
01:57:09 <ski> > (fromMaybe 0 . readMaybe) "42blah" :: Double
01:57:10 <lambdabot>  0.0
02:00:19 <Aruro> why parser -->  many (satisfy $ not . isDigit)  , can not parse arbitraty end of string having no digits?
02:00:59 <Aruro> in particular case parser many letter_ascii does job well
02:02:04 <Aruro> so the question is if:  many letter_ascii == many (satisfy $ not . isDigit) in case we dont need rest of string ?
02:06:24 <aleator> ollef: The main problem is that suppose I have a working test 't', students test 'ts', I'd need to show that 't x == ts x' for all x that are functions of suitable type. Where do I get sensible x's?
02:10:59 <Lis> need to go to the office later
02:11:22 <kqr> aleator, sounds like exactly what quickcheck is good for
02:11:28 <ollef> aleator: ah. in some instances you may be able to generate functions, e.g. if they have finite domains. smallcheck might do the trick actually. or you could use carefully chosen unit tests.
02:11:53 <kqr> oh functions. that might be a bit trickier
02:12:08 <kqr> but shouldn't be impossible
02:12:28 <ollef> if you can choose the types yourself it should be doable :)
02:13:38 <roflha> Hey everyone, I am learning and had a quick question I am hoping somebody may know the answer to. I am messing around with writing a compiler, and have a list of tokens that I pass into the parse function. I am using the State Monad to represent the list of tokens remaining to be parsed, but I don't really want to return the state [token] ident or whatever to main. Is there some way to use state internally but never expose its usage t
02:13:49 <roflha> the function is technically pure anyway if i forgo state
02:14:01 <nshepperd_> quickCheck has CoArbitrary for generating random functions
02:14:32 <ollef> oh cool
02:15:00 <kqr> roflha, evalState :: State s a -> s -> a
02:15:22 <kqr> roflha, in other words, it feeds an initial state into your state computation and then just returns the value the state computation returned
02:15:46 <roflha> oh. well that was easy and sounds exactly like what i wanted lol.
02:15:49 <roflha> thank you.
02:15:51 <aleator> ollef: Sure, but the problem is that generated functions practically never pass either test so I don't get coverage that way
02:16:07 <kqr> roflha, there's also runState :: State s a -> s -> (a, s)
02:16:15 <ski> roflha : cut off near "... Is there some way to use state internally but never expose its usage t"
02:16:17 <kqr> roflha, and execState :: State s a -> s -> s
02:17:46 <safinaskar> how ParsecT works?
02:17:47 <roflha> oh i had just said "since its technically a pure function anyway"
02:17:56 <safinaskar> i mean ParsecT and not Parsec
02:17:57 <nshepperd_> aleator: ah, if you need the functions to have specific structure you may need a more advanced producer
02:18:10 <ollef> aleator: quickcheck also allows you to use a custom generator (see forAll), which can be used to generate stuff more cleverly
02:18:31 <nshepperd_> aleator: like, maybe start with a passing function and perturb the output somehow
02:18:54 <roflha> kqr: What is the difference exactly between evalState and execState
02:18:55 <roflha> oh nv
02:18:56 <roflha> mm
02:18:56 <ski> roflha : doesn't fit the end of "but never expose its usage t"
02:19:09 <roflha> i saw the fst / snd
02:19:51 <roflha> oh lol my bad ski, i had said "usage to outside the module?"
02:19:53 <aleator> nshepperd_: Perhaps that is a good idea. Breaking the output is easier than making a broken function.
02:20:08 <kqr> safinaskar, what does the question mean/why are you asking?
02:20:14 <roflha> but it appears evalState is what I was missing.
02:20:33 <nshepperd_> A nice way to make custom value generators is a newtype wrapper 'newtype SpecialFunction = Special (Int -> Int); instance Arbitrary SpecialFunction where {...}'
02:21:00 <nshepperd_> and then in your test just do \(Special f) -> ... to get one of your special functions for testing on
02:21:56 <safinaskar> kqr and others: i use parsec library. i already get started with it, all is ok. but now i want to understand what is "ParsecT" type constructor, i. e. what if i pass non-Identity monad to this "ParsecT" constructor
02:22:32 <safinaskar> kqr: unfortunately, official docs ( https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec.html ) doesn't say anything useful
02:22:32 <kqr> safinaskar, if you pass IO instead of Identity you can run IO operations inside your parsers
02:22:40 <safinaskar> kqr: how to do this/
02:22:42 <safinaskar> ?
02:22:54 <aleator> nshepperd_: Still, generating the reasonable functions is not so easy.
02:23:00 <kqr> safinaskar, pass IO instead of Identity and then you can lift (putStrLn "hello i'm in a parser")
02:23:14 <ollef> aleator: what is an example of reasonable functions?
02:23:16 <safinaskar> kqr: maybe there is some examples?
02:23:22 <kqr> safinaskar, https://github.com/kqr/gists/blob/master/articles/gentle-introduction-monad-transformers.md
02:23:35 <kqr> safinaskar, that's probably a good place to start with monad transformers
02:23:42 <kqr> safinaskar, which parsecT is an example of
02:24:27 <aleator> ollef: To take a trivial example, suppose we are testing 'sort'. Now the function passed to the test should be very much like sort. Perhaps it misses few elements from here and there or something.
02:25:20 <aleator> But if I limit myself to simple functions, perhaps I can come up with a generic list of perturbations on the output and go with that.
02:27:01 <ollef> aleator: that's a reasonable approach I think.
02:27:13 <safinaskar> kqr: thanks
02:27:36 <aleator> For sorting it seems that (\f g xs -> goodTest (f . sort . g) xs == badTest (f . sort . g)) is already quite good
02:28:14 <ollef> nice!
02:29:37 <aleator> I can't imagine how, but that catches even 'badTest2  f xs = let r = f xs in (length xs == length r) && and (zipWith (<=) r (tail r))'
02:30:08 <aleator> The counter-example is naturally totally useless.
02:31:52 <phaazon> is there a yitz here?
02:32:25 <phaazon> https://www.reddit.com/r/haskell/comments/33imdr/is_there_any_radical_rewrite_of_the_prelude/
02:32:28 <phaazon> yits from this ^
02:32:45 <phaazon> we're having a discussion about abstractions that I find interresting
02:34:23 * hackagebot libconfig 0.1.0.0 - Haskell bindings to libconfig  http://hackage.haskell.org/package/libconfig-0.1.0.0 (peddie)
02:34:25 * hackagebot HDBC-sqlite3 2.3.3.1 - Sqlite v3 driver for HDBC  http://hackage.haskell.org/package/HDBC-sqlite3-2.3.3.1 (ErikHesselink)
02:36:49 <jle`> Cale: I'd like to credit you in something i'm writing...is there a name you prefer to go by?
02:42:09 <ollef> aleator: what's the counter-example out of interest?
02:44:13 <ollef> ah, it can just invent whatever it likes
02:44:23 * hackagebot warp 3.0.12.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.12.1 (MichaelSnoyman)
02:46:26 <davison>  /quit
02:46:27 <davison> \quit
02:49:10 <Schrostfutz> Coming from OOP, would it make sense to try haskell for my (smallish) projects? I kinda have the prejudice that doing UI, or user interaction in general will be dificult...
02:53:24 <jle`> i haven't found haskell as a language limiting for ui or user interaction in general.  it seems to work just as well if not better than
02:53:29 <jle`> other languages
02:53:56 <ion> I’m not sure what would make that especially difficult in Haskell/FP.
02:54:36 <kqr> Schrostfutz, it always makes sense to try! if it doesn't work out you just don't keep doing it
02:55:05 <phaazon> since we have monads
02:55:09 <kqr> Schrostfutz, the general consensus re. UI seems to be that it's just as good as in those OOP languages... which isn't very good compared to the rest of haskell
02:55:16 <phaazon> you can do it the same way you do it in OOP language
02:55:26 <phaazon> (I think you meant imperative, though)
02:56:13 <phaazon> I don't which abstractions is the best for UI though
02:56:18 <phaazon> +know
02:56:26 <ania12> I am interested for the position announced.
02:56:38 <ania12> is it correctly written in english?
02:56:45 <ania12> can one tell me?
02:56:47 <kqr> ania12, interested *in* the position
02:56:56 <ania12> thx
02:56:59 <kqr> ania12, but this is probably the wrong place to ask that kind of question :)
02:57:04 <phaazon> in the announced position
02:57:08 <ania12> :)
02:57:09 <phaazon> I'd rather say
02:57:11 <kqr> ania12, #haskell-blah is a good place if you want haskell people
02:57:18 <phaazon> though I'm French so...
02:57:22 <Schrostfutz> ion: its not that it necesarily is more difficult, just that my understanding of functional languages lets me think that
02:57:32 <kqr> phaazon, if you're french you should like the position announced, no?
02:57:32 <phaazon> kqr: « if you want haskell people »
02:57:35 <dockdock> phaazon: I'm so sorry about that
02:57:35 <phaazon> that's kinky :D
02:57:51 <kqr> Schrostfutz, lets you think that what?
02:58:10 <Schrostfutz> kqr: that doing user interaction in such a language will be more difficult
02:58:18 <phaazon> quyse: I read that as, hm, I should like the position to be annouced
02:58:26 <kqr> Schrostfutz, ah, yes, everything is more difficult when you are inexperienced with it
02:58:34 <phaazon> not the position that's been announced
02:58:34 <kqr> Schrostfutz, but it's not inherently more difficult, it's just unfamiliar to you
02:59:02 <kqr> Schrostfutz, so if you're afraid of new things, stay away. it's gonna be *very* new
02:59:03 <phaazon> kqr: *, not quyse (sorry pal)
02:59:03 <arw> Schrostfutz: imho there is a gradual increase of pain in UI programming, the further away you get from Qt and C++. but thats only because all Qt bindings suck and all other UI libs suck.
02:59:08 <Schrostfutz> kqr: okay, thats what I wanted to check. Then I will try to familiarize with it
02:59:23 <phaazon> arw: I think Qt sucks in C++
02:59:30 <phaazon> it's an awful design
02:59:59 <kqr> phaazon, yeah I understand what you mean. it was just a jab at french. wouldn't it directly translated from french be "position announced"?
03:00:20 <arw> phaazon: agreed. but given that the rest is either worse or less complete than Qt, design is not the only thing to consider.
03:00:41 <phaazon> kqr: it would yeah
03:00:45 <phaazon> « position annoncée »
03:00:47 <phaazon> :)
03:00:55 <phaazon> or « poste annoncé »
03:01:09 <phaazon> arw: well, yeah.
03:01:11 <phaazon> :D
03:10:32 <quyse> phaazon: ;)
03:24:25 * hackagebot bindings-saga-cmd 0.1.1.0 - Wrapping saga_cmd  http://hackage.haskell.org/package/bindings-saga-cmd-0.1.1.0 (michelk)
03:30:22 <sudomilk> howdy all
03:31:13 <gustavn> Are Haskell functors related with functors from category theory in any way?
03:32:04 <capisce> gustavn: well yes, Haskell derives a lot of things from category theory
03:32:24 <nshepperd_> they are endofunctors in the category of haskell types and functions
03:32:28 <yasar11732> I want to use this package which is not installed by default. How can I install it? https://hackage.haskell.org/package/http-conduit-1.2.4/docs/Network-HTTP-Conduit.html
03:32:31 <nshepperd_> i seem to vaguely recall
03:32:53 <shachaf> What nshepperd_ said.
03:32:54 <capisce> those are monads I believe
03:33:09 <shachaf> In particular the type constructor is the object mapping and fmap is the arrow mapping.
03:33:24 <capisce> ah, never mind
03:33:35 <P4Titan> Hello all, is there a way to parse a non-deterministic string using Parsec?
03:33:36 <capisce> a monad is a monoid in the category of endofunctors
03:34:26 <jle`> yasar11732: you ca use cabal
03:34:29 <jle`> *can
03:34:54 <yasar11732> I guess cabal is a package installer? Does it come with ghc?
03:35:04 <jle`> yes, it should
03:35:14 <yasar11732> yes, I seem to have it
03:35:21 <jle`> you can install globally with `cabal install http-conduit`, but global install is generally not recommended
03:35:36 <yasar11732> how should I install it then?
03:35:39 <saep> P4Titan: What is a "non-deterministic string"? Sounds like chimps writing Shakespeare. 
03:35:45 <jle`> if you are making a project with haskell, you can use a "cabal file" to specify which packages your project depends on
03:35:59 <jle`> and then use `cabal sandbox init; cabal install` to build your project
03:36:06 <jle`> (it'll download the appropriate dependencies)
03:36:09 <yasar11732> I am just trying to follow https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/tagsoup
03:36:19 <jle`> if you are just playing around, you can use sandboxing in a folder of your choice
03:36:31 <jle`> `cabal sandbox init; cabal install http-conduit`
03:36:54 <jle`> and then to run your file you'd do something like cabal exec runghc myfile.hs
03:37:12 <yasar11732> ok, I will try and see
03:37:17 <jle`> if you installed it globally, you can just do `runghc myfile.hs`
03:37:19 <P4Titan> saep: Well, I am tring to parse a simple english grammar. A sentence in this grammar is a nounphrase + verbphrase. It may so happen that a word can be both a noun and a verb. My nounphrase parser will eat that word, leaving a non-complete verb phrase, which errors. I want to still be able to parse that, somehow, non-greedily
03:37:31 <jle`> cabal exec is what loads the sandboxed packages for runghc to use
03:39:26 <yasar11732> it says I should do  cabal update. Does it matter if I do it inside or outside sanbox
03:39:49 <jle`> it doesn't
03:41:16 <yasar11732> it says there is a new version of cabal-install available, I guess I should install it first?
03:41:46 <saep> P4Titan: Maybe something like: `try parseNextWordAsNoun <|> parseNextWordAsVerb`. But I must confess: I've only parsed structured text with parsec. :-)
03:41:52 <xandaros> If you use ghc-mod, don't update just yet, otherwise go ahead :)
03:42:02 <jle`> yasar11732: yeah heh, you probably should, although it might not matter for this actual tutorial
03:42:05 <jle`> be sure to do it globally, though
03:42:23 <yasar11732> so, I should get out of sandbox before installing it?
03:42:44 <P4Titan> saep: This thing is that parseNextWordAsNoun does not fail, but since it parsed it, there is no verb for the verb phrase, that is what fails
03:42:53 <jle`> yeah, install it from somewhere else.  honestly though i think there's a good chance whatever version of cabal-install you're using should work for the tutorial
03:42:59 <jle`> unless it's really old
03:43:18 <yasar11732> I installed haskell platfrom a week ago or so, never used cabal before
03:43:30 <jle`> a lot of people stay behind on updating cabal-install
03:43:43 <jle`> if it's the haskell platform within the past year or so you should be good
03:43:56 <jle`> so, the decision is yours :)
03:44:19 <yasar11732> I am installing it, it seems like it is compiling something
03:44:36 <jle`> mhm, it's compiling the new version for you
03:45:07 <yasar11732> I would assume it would just download and unpack compiled version :)
03:50:19 <saep> P4Titan: I meant with `parseNextWordAsNoun` a parser, that itself uses the verb-phrase parser. So that if it fails, you end up at the try block and execute `parseNextWordAsVerb`.
03:50:53 <chpatrick> is there a package for scheduling execution with a delay?
03:51:02 <P4Titan> I am not sure what you mean
03:51:36 <chpatrick> I would like to schedule events to occur at a given time
03:51:42 <chpatrick> and then execute them with one thread
03:52:08 <chpatrick> the tricky bit is that I might schedule new stuff while the thread is currently waiting for the first thing
03:52:14 <chpatrick> and then it should be woken up
03:54:26 * hackagebot cereal-text 0.1.0.1 - Data.Text instances for the cereal serialization library  http://hackage.haskell.org/package/cereal-text-0.1.0.1 (ulikoehler)
03:56:56 <saep> P4Titan: `let parseNextWordAsNoun = do { n <- pNoun ; v <- pVerb ; ... } ; let parseNextWordAsVerb = do { v <- pVerb ; ... } in try parseNextWordAsNoun <|> parseNextWordAsVerb`. If the parser `pVerb` in `parseNextWordAsNoun` fails, then your parsed state will be at the same state where you used try and then the second parser (`parseNextWordAsVerb`) is tried.
03:59:22 <P4Titan> Yes, but the structure of a nounphrase is a bit more complicated than that, with multiple different variations. Than you though. Currently I am looking at how to use a "chart parse" which apparently can parse non-deterministically and efficiently.
04:01:26 <yasar11732> by the way what installing packages globally is not recommended
04:07:23 <yasar11732> I meant *way*
04:08:39 <saep> P4Titan: Using `try` implies backtracking. Is that really an issue for sentences in an "english" language as they are short? Anyhow, I don't think I can be a lot of help for you.
04:08:39 <nshepperd_> P4Titan: btw attoparsec does unlimited backtracking by default if you're not stuck with parsec
04:09:38 <jkarni> chpatrick: maybe https://hackage.haskell.org/package/cron ?
04:09:53 <jkarni> chpatrick: in particular, System.Cron.Schedule
04:10:07 <P4Titan> nshepperd_: I'll look into that, I have seen it before. First I want to try using the chart parse parsing algorithm to implement it, as it would also be more efficient than backtacking.
04:11:16 <P4Titan> saep: It does, however, in a grander retrospect, it not is not that applicable
04:12:13 <safinaskar> kqr: your monad transformer intro is excellent! thanks!
04:13:23 <kqr> safinaskar, glad to hear, thank *you*!
04:24:14 <yasar11732> my cabal doesnt have "cabal exec" option
04:24:34 <yasar11732> it says unrecognized command exec
04:25:16 <yasar11732> I tried cabal run, but I guess it does something else
04:25:24 <yasar11732> how should I run my program in sandbox?
04:27:12 <bennofs> yasar11732: cabal run can run any executable build by cabal
04:27:20 <bennofs> yasar11732: just type cabal run <executable name>
04:27:33 <bennofs> yasar11732: for cabal exec, maybe your cabal version is too old?
04:27:56 <yasar11732> I just did cabal install cabal-install
04:28:15 <bennofs> yasar11732: cabal --version?
04:28:44 <yasar11732> cabal-instal version 1.18.0.5 using cabal library 1.18.1.3
04:29:04 <yasar11732> I am on windows xp 32 bit
04:29:34 <bennofs> yasar11732: that cabal version might not support cabal exec. I know it works with 1.20 and later though (just tested 1.20)
04:31:16 <yasar11732> I will try cabal update && cabal install cabal-install again
04:31:47 <bennofs> yasar11732: do you have the directory where cabal installs executables in your path?
04:42:34 <quetzakubica1> Hello guys. In functional programming everything is immutable, does it mean that if I have big object graph and I modify small object on bottom of the graph, then all object up to the top are being recreated?
04:43:28 <breadmonster> quetzakubica1: Nope, Haskell might reuse unused nodes.
04:43:54 <bennofs> breadmonster: how do you mean that?
04:44:06 <arw> quetzakubica1: in principle, yes. but optimizations are allowed where possible.
04:44:09 <ski> the path down to the replaced object will have to be recreated, yes
04:44:10 <mau}ke}> quetzakubica1: yes
04:44:41 <ollef> it will have to update the pointers to the objects
04:44:48 <ski> (unless you have uniqueness, as in Clean and Mercury, or possibly internal in an implementation)
04:44:59 <mau}ke}> see also zippers
04:46:25 <quetzakubica1> thanks
04:46:49 <quetzakubica1> I heard that I can use memoize to make it faster
04:47:09 <quetzakubica1> btw I'm implementing it in javascript, not haskell
04:48:10 <arw> memoization does not necessarily make things faster. and its always a tradeoff between memory usage and calculation time anyways.
04:48:23 <arw> so the answer is "it depends"
04:52:45 <yasar11732> bennofs: second iteration of update && install upgrading cabal to 1.22
04:52:52 <yasar11732> i think it would solve the problem
04:55:12 <quetzakubica1> I also read somewhere that in functional programming functions should always take at least one parameter
04:55:26 <quetzakubica1> or even that they take always one parameter
04:55:40 <quetzakubica1> is that right?
04:55:41 <srhb> quetzakubica1: Functions take exactly one parameter in Haskell
04:55:45 <ski> quetzakubica1 : in Haskell, every function takes exactly one input, by definition
04:55:59 <ski> @type getLine
04:56:00 <quetzakubica1> is that true for functional paradigm, or just haskell?
04:56:01 <lambdabot> IO String
04:56:03 <ski> e.g. is not a function
04:56:11 <srhb> quetzakubica1: Not just Haskell, not every FP lang
04:56:15 <ski> quetzakubica1 : depends on the language
04:56:28 <srhb> Even some imperative languages do it.
04:56:37 <ski> Erlang has multi-argument functions
04:56:58 <ski> in Haskell, you simulate multi-argument functions either by tupling the arguments together, or by using currying
04:57:05 <ski> (or some combination thereof)
04:57:23 <ski>   curriedFun x y = ..x..y..
04:57:30 <ski>   tupledFun (x,y) = ..x..y..
04:59:42 <ski> (iow, it's not the case that "Haskell functions are curried". currying is a convention. albeit one that is made nicer to use, by light syntax)
05:00:17 <quetzakubica1> if there can't be function no arguments, then how do we read properties of structure? is coordinations.x to get x ok?
05:00:24 <srhb> x foo
05:00:43 <xenog> x coordinations
05:00:53 <soud> hi, in ghc, is there a compiler flag to make it clean up .hi and .o files afterwards?
05:01:01 * ski here prefers the way SML (or OCaml) did record accessors, to the way Haskell does it
05:01:10 <xenog> data Coordinations = Coordinatios { x :: Int }
05:01:23 <xenog> coordinations = Coordinations 583344
05:01:24 <srhb> quetzakubica1: where x :: SomeCoordinatedStructure -> SingleCoord
05:01:35 <xenog> x coordinations == 583344
05:02:04 <xenog> Coordinations n = coordinations
05:02:06 <xenog> n == 583344
05:02:24 <srhb> quetzakubica1: We also have more advanced functorial approaches to that, but they are mostly limited to Haskell afaik (ie. Lens)
05:02:35 <yasar11732> so, cabal install cabal-install installes the executable to c:\documents and settings\mdairesi\cabal\bin and when I do cabal --version, I still get 1.18.0.5 am I doing something wrong?
05:02:39 * ski also isn't fond of using `==' for semantic equality :)
05:02:52 <srhb> yasar11732: You need to have the new version on your path, presumably
05:03:25 <yasar11732> Doesn't cabal replace the old version? Do I need to add new version to path everytime I install it?
05:03:48 <quetzakubica1> thanks, so in javascript if I have object coords = { x, y }, I can do coords.x and it's not violating any functional paradigms?
05:04:04 <bennofs> yasar11732: cabal install places executables in a path in your user directory, while you probably have cabal installed globally (which would need more rights to modify)
05:04:23 <jameseb> quetzakubica1: pattern matching on the structure may also be an option in Haskell, depending on how big the structure is
05:04:25 <xenog> yasar11732: If you installed the new cabal-install using the cabal command, you will need to be sure that the path variable contains the cabal bin directory before the original cabal installation directory.
05:04:32 <bennofs> yasar11732: so if you did cabal install happy, it would also be placed in c:\documents and settings\mdairesi\cabal\bin
05:04:43 <jameseb> pattern matching on big structures is tedious
05:04:53 <srhb> quetzakubica1: Presumably there's no mutation going on, but really it's hard to talk about (especially in #haskell)
05:04:54 <xenog> yasar11732: On Unix the shell remembers locations of files.
05:05:26 <quetzakubica1> srhb: on #javascript people cannot help me with that :/
05:05:32 <srhb> quetzakubica1: In Haskell, object coords = ... could be violating purity by mutating an existing coords?
05:05:41 <srhb> To Haskell people, it might look like *
05:05:46 <xenog> yasar11732: In bash you have to issue 'hash -r' to reset the hash table where these locations are stored. Windows may require a similar trick.
05:07:44 <xenog> yasar11732: “echo %PATH%” should be all you need to see the current path and check if it contains the path to your local user-specific cabal bin directory before any system-wide directory where the main cabal installation resides
05:08:24 <xenog> yasar11732: “cabal install cabal-install” will not replace your system-wide cabal installation. It will just install a new “cabal” command in your user directory.
05:10:29 <ski> quetzakubica1 : it also depends on what you mean by "functional paradigm"
05:11:58 <quetzakubica1> ski: I suppose there are some generic rules, like for OOP
05:12:11 <yasar11732> ahh, finally it works :)
05:12:51 <srhb> quetzakubica1: Very few well defined ones, really.
05:13:00 <srhb> quetzakubica1: And Haskell takes most of them to their extreme.
05:13:08 <srhb> (And imo the same applies to OOP)
05:14:54 <arw> imho "functional" is defined in a stricter way than "OOP". people are less unsure about what is still functional and what isn't, compared to OOP.
05:15:18 <bartavelle> arw, I disagree :)
05:15:57 <bartavelle> most people mean Java when they say OOP, while functional might mean "I have map on collections in my language"
05:16:11 <srhb> I mean Smalltalk when I say OOP :-)
05:16:20 <bartavelle> (most people I know)
05:17:33 <ski> "functional" might mean an ease of using functions as first-class values
05:17:58 <marchelzo_> @pl \a b -> fromEnum (compare a b) - 1
05:17:58 <lambdabot> flip flip 1 . (((-) . fromEnum) .) . compare
05:18:05 <ski> sometimes people also use it to mean that they can do equational reasoning, or something similar
05:18:18 <marchelzo_> I feel like there is a better way
05:18:42 <marchelzo_> What can I do to get something like this to work: subtract 1 . fromEnum . compare
05:18:53 <srhb> :t fromEnum
05:18:54 <ion> signum (a - b) or something?
05:18:54 <lambdabot> Enum a => a -> Int
05:18:57 <marchelzo_> I want the type to be: Int -> Int -> Int
05:19:30 * hackagebot th-inline-io-action 0.1.0.0 - Simple inline IO action into compiled code using TH  http://hackage.haskell.org/package/th-inline-io-action-0.1.0.0 (tolysz)
05:19:44 <arw> bartavelle: right. but with functional, there is a very limited set of possibilities, from "I can pass a function as an argument" over "functions are values" to "there is a lambda". whereas for OOP, there are more aspects to cover, like the various types of inheritance, prototypes, interfaces, accessor syntax, (non-)existence of types, etc.
05:19:53 <marchelzo_> @pl \a b -> signum (a - b)
05:19:58 <lambdabot> (signum .) . (-)
05:20:02 <marchelzo_> sweet
05:20:05 <marchelzo_> thanks ion
05:20:05 <bartavelle> arw, for some people functional mean Haskell ;)
05:20:18 <ion> No, @pl made it worse.
05:20:20 <barrucadu> marchelzo_: Why are you trying to make it pointfree? The pointful code is clear and simple
05:20:38 <arw> bartavelle: yes, thats a shortcut. like "java" is for a certain style of OOP
05:21:00 <marchelzo_> Pointfree code satisfies me
05:21:02 <srhb> marchelzo_: There's a reason that we often call pointfree style "pointless" :-)
05:21:03 <bartavelle> arw, what I mean is that laziness and immutability can be part of being functional in some discourses
05:21:39 <nshepperd_>  @pl is the point-less command :>
05:21:47 <barrucadu> I tend to dislike pointfree for more than one parameter, as you get all sorts of weirdness
05:21:56 <barrucadu> Like partially applied (.) sections
05:21:59 <arw> bartavelle: agreed
05:22:26 * ski find `(signum .) . (-)' pretty readable ..
05:22:37 <ski> (however `flip flip 1 . (((-) . fromEnum) .) . compare' is not)
05:22:50 <bennofs> barrucadu: exactly. except that in this case, even '\a -> signum . (-) a' looks ugly imo
05:22:51 <marchelzo_> ski: right. I wouldn't use that
05:23:12 <ski> @let infixr 9 .:; (.:) = (.) . (.)
05:23:14 <lambdabot>  Defined.
05:23:18 <bennofs> I would probably write, if it all, fmap signum . (-), although that might be even more confusing :)
05:23:25 <ski> @type signum .: (-)
05:23:26 <lambdabot> Num c => c -> c -> c
05:24:08 <barrucadu> bennofs: I'd probably go for `\a -> signum . (a-)` if I was set on avoiding the second parameter, but would almost certainly stick with `\a b -> signum $ a - b`
05:24:30 * hackagebot clash-vhdl 0.5.2 - CAES Language for Synchronous Hardware - VHDL backend  http://hackage.haskell.org/package/clash-vhdl-0.5.2 (ChristiaanBaaij)
05:24:32 * hackagebot clash-ghc 0.5.3 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.5.3 (ChristiaanBaaij)
05:26:12 * ski would possibly settle on `\a b -> signum (a - b)' in practice
05:29:31 * hackagebot flowlocks-framework 0.1.3 - Generalized Flow Locks Framework  http://hackage.haskell.org/package/flowlocks-framework-0.1.3 (NiklasBroberg)
05:30:49 <arbelos> What happened to splitWith in Data.Text? Did it move to another package or just disappear?
05:32:10 <arbelos> Oh wait. That is the function simply called "split" now, or...
05:33:04 <quetzakubica1> http://jsfiddle.net/5f0L3z8c/ does it look like functional app? :P my first attempt
05:36:17 <frerich> It sure has a lot of functions!
05:36:38 <c_wraith> It doesn't appear to mutate anything, which is a good step
05:37:08 <quetzakubica1> what would you do better?
05:38:47 <frerich> quetzakubica1: I think the mutation in the update( ) function and in showUnitCoords() could be improved.
05:38:59 <voidzero> arbelos, there is a Data.List.Split
05:39:12 <frerich> quetzakubica1: Instead of updating the coordinates over time, you could compute them all up front without any modification.
05:40:52 <Stratege_> quetzakubica1 the update function inside the create Coords object could be moved outside of it, but that's probably just my bias against OOP talking.
05:41:13 <quetzakubica1> Stratege_:  yes, I saw that too, already moved it out
05:41:23 <kqr> quetzakubica1, if you're interested in functional browser-based code, check out Elm: http://elm-lang.org/
05:41:28 <quetzakubica1> frerich: I don't get how can I do that
05:42:02 <quetzakubica1> kqr: I read that, but I can't understand it, probably because of syntax I don't know
05:42:11 <Stratege> well ... the mutability in the update function can be trivially changed by simply not rebinding unit but binding it to a different name.
05:42:13 <kqr> quetzakubica1, learn the syntax – it's similar to haskell
05:42:32 <kqr> quetzakubica1, you can start here: http://elm-lang.org/learn/courses/beginner/Programming.elm
05:42:36 <kqr> quetzakubica1, assumes no prior experience
05:45:07 <arbelos> It is definitely easier than trying to re-invent functional programming in JavaScript :)
05:45:33 <yasar11732> cabal init ask me about project synopsis, what is that?
05:46:11 <yasar11732> can I leave it empty?
05:46:13 <kqr> yasar11732, just a short description of what the code does
05:46:17 <kqr> yasar11732, yes, you can leave it empty
05:46:27 <srhb> quetzakubica1: Did you see that post on moving from Python to Haskell yesterday? You had just left the channel I think, but it addressed some of your concerns re. readability really well, and better than we did in the channel, I think. :)
05:46:33 <arbelos> you can skip most of the steps in cabal init
05:46:51 <arbelos> it'll tell you when input is required
05:47:11 <quetzakubica1> srhb: no, I didn't
05:47:19 <srhb> quetzakubica1: http://mechanical-elephant.com/thoughts/2015-04-20-becoming-productive-in-haskell/ -- It's a short read. :)
05:47:38 <Stratege> well... JS could be used as a functional language, since it's trivially got first class functions and closures. The problem that I see is more the utter lack of typechecking.
05:48:43 <arbelos> to me, referential transparency is very closely associated with a functional way of thinking
05:48:50 <kqr> me too
05:49:01 <arbelos> but then again, languages like f# etc.. are considered functional, so
05:49:10 <kqr> referential transparency is to me the difference between declarative and imperative code
05:49:18 <kqr> and declarative is to me more functional
05:49:39 <quetzakubica1> people says that doing oop in javascript is masochism, so I wanted to try functional js
05:49:39 <ski> logic programming is also included under the declarative umbrella
05:49:56 <quetzakubica1> but I didn't have actual problems with oop in js
05:50:01 <quetzakubica1> it was just fine
05:50:59 <arbelos> hmm, that is interesting. were they not talking about class-based oop in particular?
05:51:35 <arbelos> oop in javascript feels pretty idiomatic in my opinion
05:52:02 <quetzakubica1> arbelos: dunno, I didn't need classes in js
05:52:15 <bennofs> quetzakubica1: did you do inheritance?
05:52:26 <quetzakubica1> since I didn't do much inheritance, only for polimorphism
05:52:37 <quetzakubica1> mostly composition
05:54:22 <arbelos> poor javascript; Java/C# people are bashing it for not beeing OOP enough, and FP people because it is not functional enough
05:54:27 <quetzakubica1> but it's true for every oop language, that inheritance should be used only for polimorphism. L from SOLID
05:54:32 * hackagebot io-region 0.1.1 - Exception safe resource management with dynamic regions  http://hackage.haskell.org/package/io-region-0.1.1 (YurasShumovich)
05:55:33 <quetzakubica1> people are bashing js for not having privates, which is stupid. Python has no privates, nor interfaces etc. and it works
05:56:04 <quetzakubica1> anyway, I want to learn functional js for comparision
05:57:05 <kqr> ski, I've been thinking this for many years but I haven't said it until now I don't think: you have the coolest nickname
05:57:26 <ski> heh
05:57:38 <ski> i mostly think of it as an accident that has stuck
05:57:57 <Stratege> don't forget that JS gets bashed for having the worst dynamic type system in existance.
05:58:43 <kqr> arbelos, oop in javascript is rough. {f = o.m; f(x);} is a different program to {o.m(x);}
05:58:54 <srhb> It's also not on topic for #haskell. :)
06:00:27 <Stratege> quetzakubica1 you could start looking into how to translate typical functional concepts into JS, like map. Also a bit silly a video but possibly helpful: https://www.youtube.com/watch?v=dkZFtimgAcM
06:01:22 <quetzakubica1> Stratege: js has native map
06:01:32 <quetzakubica1> reduce, etc.
06:01:55 <Stratege> *shrugs* still worth implementing oneself to understand what it is, how it works and how it can be used. Atleast in my opinion.
06:03:54 <qiv> hi there, anyone familiar with dogelang http://pyos.github.io/dg/ ? 
06:04:14 <quetzakubica1> Stratege: I know that it works recursively if you mean that
06:04:57 <qiv> is it worth a try? I am heavily relying on python libraries for my daily work ...
06:04:59 <safinaskar> why tuples are implemented such non-flexible? ( http://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc-prim-0.4.0.0/src/GHC-Tuple.html )
06:05:15 <kqr> qiv, no, I would not depend on it
06:05:17 <indiagreen> safinaskar: what do you mean, non-flexible?
06:05:37 <kqr> qiv, if you are desperate to get away from python, running microservices or the like might be a more helpful approach
06:05:38 <safinaskar> it is possible to implement it good way (data Nil = Nil; data Cons a b = Cons a b)
06:06:19 <kqr> safinaskar, what about tuples with 3 elements?
06:06:23 <safinaskar> indiagreen: (,) and (,,) are absolutely different things. they just look similar. so, you cannot, for example, define function, which will take first element in any tuple
06:06:38 <kqr> safinaskar, that's more of a limitation in the standard haskell type system
06:06:51 <mau}ke}> safinaskar: same as your Nil/Cons
06:07:01 <mau}ke}> (Nil = (), Cons = (,))
06:07:10 <kqr> safinaskar, what would be the type of a function that takes the first element of any tuple?
06:07:19 <qiv> kqr, not that desperate -- i just started looking a little into haskell and start missing certain features ...
06:07:43 <kqr> qiv, ah yeah, you'll largely miss those features in dogelang too
06:07:49 <indiagreen> safinaskar: there are some disadvantages when you work with nested tuples, at least the way GHC is implemented now
06:07:51 <safinaskar> kqr: tuple with 3 elements is Cons a (Cons b (Cons c Nil))
06:07:52 <indiagreen> see here: http://stackoverflow.com/questions/14973459/why-is-a-b-c-d-not-sugar-for-a-b-c-d
06:07:52 <kqr> qiv, it's just a thin syntactic wrapper around python
06:08:28 <kqr> safinaskar, how is that different from (a, b, c)?
06:08:30 <mau}ke}> a.k.a. (a, (b, (c, ())))
06:08:38 <qiv> kqr, well, maybe "featuers" was wrong -- synthactic sugar might be more accurate :D
06:08:40 <kqr> or what mau}ke} said
06:08:47 <qiv> i really like the "where" in haskell
06:08:54 <safinaskar> i can implement true general "fst" (which return first element in any tuple) as    fst (Cons x _) = x
06:08:58 <webchat041> In which circunstances a a thread does does not die after a killThread?
06:09:05 <mau}ke}> safinaskar: that's exactly the same as Prelude.fst
06:09:14 <Stratege> I think what he's missing is the sugar you get in a lisp for such tuples.
06:09:18 <mau}ke}> only in your proposal (,,) and friends don't exist
06:09:29 <safinaskar> mau}ke}: () corresponds to Nil and (a, b) to Cons a (Cons b Nil)
06:09:34 <kqr> qiv, ah. sure, I don't mean to discourage you from trying. I just think the eventual cost (not getting updates, bugs in the compiler etc) will outweigh whatever syntactic benefit you get
06:09:59 <kqr> safinaskar, Cons a (Cons b Nil) = (a, (b, ()))
06:10:12 <Stratege> since (a,b,c) in a lisp desugars into (cons a (cons b (cons c nil))) just is written more nicely.
06:10:14 <mau}ke}> HList does this
06:10:31 <safinaskar> kqr: type of my fst is "Cons a b -> a"
06:10:41 <mau}ke}> type of Prelude.fst is (,) a b -> a
06:10:59 <mau}ke}> nothing keeps you from using nested tuples right now
06:11:18 <mjhoy> Is there an easy way to create a Num newtype that only can operate (addition etc) on itself?
06:11:25 <safinaskar> indiagreen: "there are some disadvantages..." - what do you mean?
06:11:32 <mau}ke}> mjhoy: what do you mean?
06:11:36 <kqr> mjhoy, that's how all Nums work
06:11:43 <kqr> mjhoy, (+) :: Num a => a -> a -> a
06:11:53 <kqr> mjhoy, you have to convert numbers to the same type to add them together
06:12:14 <quetzakubica1> btw anyone here familiar with domain driven design?
06:12:15 <mjhoy> mau}ke}: i.e. a newtype "Capacity Int" deriving num that can only add/etc with itself
06:12:20 <safinaskar> indiagreen: okey, i see stackoverflow link
06:12:24 <safinaskar> indiagreen: thanks
06:12:35 <mjhoy> mau}ke}: so (Capacity 5) + 6 would not typecheck
06:12:39 <exio4> by going the HList approach you basically _force_ certain structure 
06:12:44 <mau}ke}> mjhoy: why wouldn't it?
06:12:44 <exio4> mjhoy: well, it would 
06:12:47 <kqr> mjhoy, that's more of a problem with literal numbers
06:12:50 <safinaskar> kqr: "how is that different from (a, b, c)?" - now i can implement my general "fst"
06:13:00 <kqr> mjhoy, when you type 57 in haskell code it automatically gets translated to "fromInteger 57" by the compiler
06:13:00 <mau}ke}> mjhoy: newtype Capacity = Capacity Int deriving (Num) works, btw
06:13:00 <exio4> because numbers are polymorphic
06:13:26 <kqr> mjhoy, if you do x :: Int; x = 57 then Capacity 5 + x would not work
06:13:58 <mau}ke}> > Sum 5 + 6
06:13:59 <lambdabot>  Sum {getSum = 11}
06:14:02 <mau}ke}> > Sum 5 + (6 :: Int)
06:14:03 <lambdabot>      Couldn't match expected type ‘Sum a’ with actual type ‘Int’
06:14:03 <lambdabot>      In the second argument of ‘(+)’, namely ‘(6 :: Int)’
06:14:03 <lambdabot>      In the expression: Sum 5 + (6 :: Int)
06:14:15 <mjhoy> mau}ke}: Yes, that's the problem though! I don't want to be able to add Capacity and, say, Value, or some other newtype num
06:14:23 <mau}ke}> mjhoy: no, that's not the problem
06:14:29 <kqr> mjhoy, you can't do that already
06:14:39 <mau}ke}> mjhoy: you can't add Capacity and Value/Int/whatever
06:14:43 <kqr> mjhoy, it's only that when you type 5 it's not a Value or some other newtype num
06:15:11 <SrPx> Is there any structure with O(1) append and O(1) indexing?
06:15:13 <mjhoy> kqr: Ah! I see now.
06:15:26 <mjhoy> kqr: Sorry. didn't realize what it was doing in ghci
06:15:38 <kqr> mjhoy, no problem. that's a confusing part of haskell before you know about it
06:17:41 <lyxia> SrPx: Dynamic vectors have amortized O(1) cons and O(1) indexing.
06:19:17 <brbblnch> About what mjhoy asked: Would it be doable/usefull to implement physical units in the type system ?
06:19:20 <SrPx> Ah! I didn't know this existed. Obvious name, I should've googled. Thanks.
06:21:59 <chpatrick> brbblnch: that exists I believe
06:22:01 <lyxia> SrPx: Dynamic array is its wikipedia name actually.
06:22:25 <SrPx> Yes, that is why it was obvious. I just assumed haskell didn't have it :) beautiful.
06:24:12 <chpatrick> @hackage units
06:24:12 <lambdabot> http://hackage.haskell.org/package/units
06:24:33 * hackagebot stateWriter 0.2.3 - A faster variant of the RWS monad transformers.  http://hackage.haskell.org/package/stateWriter-0.2.3 (SimonMarechal)
06:32:51 <saml> i think i'm gonna learn haskell
06:33:06 <frawgie> do it!
06:33:09 <brbblnch> chpatrick: nice, thanks!
06:34:29 <kqr> learning haskell is a wise investment
06:34:49 <Xe> lots of silicon valley companies pay big fr it
06:34:51 <Xe> for*
06:35:00 <slack1256> saml: How are you gonna approach that? is worthy to look to "learn you a haskell"
06:35:05 <slack1256> @where lyah
06:35:05 <lambdabot> http://www.learnyouahaskell.com/
06:36:06 <laserguns> i just started reading "learn you a haskell" and joining here because the channel is mentioned in the first paragraph :)
06:36:48 <kqr> oh didn't know that
06:36:50 <kqr> cool
06:37:15 <saml> slack1256, i recommend following http://dev.stephendiehl.com/fun/   and https://github.com/NICTA/course
06:37:36 <SwashBuckla> 'it is common to use the letter k for the second argument of (>>=) because k stands for “continuation”. I wish I was joking.'
06:37:50 <Stratege> Xe they do now? Cool, I thought haskell was still more something you do because you want to, not because it pays well.
06:37:59 <SwashBuckla> -- Brent Yorgey's lecture on Monads
06:38:09 <Xe> Stratege: oh yeah
06:38:13 <Xe> they've seen the light
06:38:23 <Preyer> Xe: examples?
06:39:34 * hackagebot scotty-session 0.0.5 - Adding session functionality to scotty  http://hackage.haskell.org/package/scotty-session-0.0.5 (AlexanderThiemann)
06:39:42 <slack1256> saml: Holy, I recall reading "things I wish I knew when learning haskell" by him. I really enjoyed, but a didn't know about this. Awesome
06:40:43 <slack1256> Sincerely I learned just by following for like 2 years whatever came on r/haskell and following each tutorial. Almost like osmosis. Maybe I ought to put a "tutorial" on haskell-wiki which is just a series of already made blogposts
06:41:19 <saml> can you make cms in haskell?
06:42:12 <kqr> yes
06:42:31 <slack1256> saml: it seems. There was a announcement of lambdacms-core. Built on top of yesod
06:42:44 <kqr> there's also clckwrks built on snap (?)
06:42:51 <saml> wanna write haskell cms and solve all business problems?
06:42:55 <kqr> happstack
06:42:57 <kqr> it is
06:42:59 <kqr> not snap
06:43:25 <slack1256> oh clckwrks has a nice video I recall
06:44:34 * hackagebot reroute 0.2.3.0 - abstract implementation of typed and untyped web routing  http://hackage.haskell.org/package/reroute-0.2.3.0 (AlexanderThiemann)
06:45:12 <saml> is haskell platform still a thing?
06:45:41 <alexbiehl> Is there a way to build a statically linked shared object with ghc? I mean, your application as a shared object, statically including ghcs runtime etc.? 
06:45:54 <kqr> saml, generally, I'd avoid it
06:46:11 <saml> i'm using ubuntu and ghc and cabal-install are old
06:46:24 <kqr> how old are old?
06:46:33 <slack1256> old /=> bad though
06:46:41 <kqr> I guess most of them are too old now with 7.10
06:47:05 <saml> cabal-install version 1.16.0.2        The Glorious Glasgow Haskell Compilation System, version 7.6.3
06:47:28 <saml> looks like ghc comes with cabal-install now?
06:47:45 <saml> actually https://www.haskell.org/downloads/linux seems like up to date doc
06:47:49 <kqr> possibly. either way you can upgrade cabal-install with cabal-install heh
06:48:05 <kqr> saml, that uses ghc 7.8 which is old :(
06:48:43 <kqr> hm
06:48:54 <saml> i guess doc is old.  https://launchpad.net/~hvr/+archive/ubuntu/ghc  seems to have 7.10
06:49:02 <kqr> ah good
06:58:20 <laserguns> quit
06:58:31 <laserguns> -.-
07:01:39 <saml> is cabal sandbox similar to virtualenv of python?  or is it only based on current working directory?
07:02:15 <saml> actually cabal sandbox --sandbox=DIR
07:03:21 <kqr> saml, cabal sandbox is similar to virtualenv, but you don't have to "activate" the environment like with virtualenv
07:03:27 <geekosaur> saml: sandboxes are partial. hsenv is more like virtualenv... but rarely necessary
07:03:34 <kqr> saml, just going into the directory activates the environment
07:04:05 <saml> i want to have shared sandbox for multiple projects
07:05:45 <saml> https://www.haskell.org/cabal/users-guide/installing-packages.html#sandboxes-advanced-usage  this documents how
07:06:45 <kqr> why would you want that?
07:19:55 <bartavelle> kqr, reducing build time and disk usage
07:20:07 <bartavelle> saml, stackage-utils does that for you IIRC
07:20:37 <bartavelle> perhaps stackage-cli
07:20:53 <bartavelle> saml : https://github.com/fpco/stackage-cli#stackage-sandbox-init
07:20:54 <kqr> bartavelle, ah, makes sense
07:28:11 <bartavelle> Is ghc 7.10 the doom weapon of the anti-TH crowd ? It seems to punish me from using it with horrible compilation times :/
07:28:22 <bartavelle> s/from/for/
07:30:17 <laserguns> to learn haskell, start with vim or search for some "IDE Like" with more support and distractions?
07:30:33 <mau}ke}> I use vim for everything
07:32:37 <luite> bartavelle: are you using a dynamically linked compiler?
07:33:10 <kqr> laserguns, i'd recommend starting with the simple text editor of choice, for two reasons
07:33:36 <kqr> laserguns, there aren't that many really great IDEs for haskell, and it gives you an idea of what happens "under the hood", which is quite simple when it comes to haskell anyway
07:34:19 <bartavelle> luite: I think I am ?
07:34:42 <laserguns> kqr: ah, thanks
07:36:20 <saml> what does "section form" mean?
07:36:31 <saml> Operators can be written in section form: (x+) =  \y -> x+y
07:36:40 <saml> i guess currying
07:36:49 <geekosaur> partial application of operators
07:37:14 <saml> aren't all operators binary?
07:37:16 <luite> bartavelle: that can slow down compilation
07:37:22 <geekosaur> > map (1+) [1,2,3]
07:37:23 <lambdabot>  [2,3,4]
07:37:29 <luite> although for some things dynamic is faster
07:37:41 <bartavelle> luite : thanks for the pointer
07:37:47 <bartavelle> I think I'll just wait it out
07:38:13 <geekosaur> `(1+)` there si a section, or a partially applied operator
07:38:43 <kqr> sí, sí
07:38:56 <MP2E> bartavelle: this may be of interest ! https://mail.haskell.org/pipermail/ghc-devs/2015-April/008766.html
07:39:20 <MP2E> GHC devs are looking for spots where GHC's speed could be increased, profiling of builds that are taking much longer and posting the results to the thread could help
07:39:37 * hackagebot singleton-nats 0.1.0.0 - Unary natural numbers relying on the singletons infrastructure.  http://hackage.haskell.org/package/singleton-nats-0.1.0.0 (AndrasKovacs)
07:40:22 <bartavelle> MP2E, yeah I saw that ... that's why I am not too surprised that it's so slow ...
07:41:03 <luite> MP2E: hmm, but that's 7.8 vs 7.6
07:41:54 <saml> how do you pronounce <*> and <$> ?   bind and apply?
07:42:40 <kqr> saml, ap and fmap
07:43:01 <kqr> saml, or just "angle-bracket-star" and "angle-bracket-dollar" or something
07:43:20 <hodapp> huh, I am liking the notion of an 'oracle' in the Shake build system
07:43:20 <MP2E> ah, yes it is 7.8.4
07:43:24 <voidzero> badaboom and badabing
07:43:46 <voidzero> but <$> could also be called infix fmap i guess.
07:44:07 <mau}ke}> mo and dem
07:44:08 <hodapp> in part because I discovered exactly why I needed one, after weeks of seeing them as a curiosity: if I change the compiler flags of a build, this doesn't register as a source file changing, but everything must be rebuilt
07:44:32 <saml> oh it's like monad apply
07:45:19 <kqr> saml, applicative
07:45:22 <kqr> not monad
07:45:33 <kqr> well <*> is applicative, <$> is functor
07:45:51 <hodapp> I am going to name one of my kids Applicative Functor.
07:45:56 <mau}ke}> :t [ap, (<*>)]
07:45:57 <lambdabot> Monad m => [m (a -> b) -> m a -> m b]
07:46:04 <chpatrick> lil' appy
07:46:10 <mau}ke}> ooh, superclass. super classy
07:46:21 <chpatrick> supergeil
07:48:18 <saml> basically you  got a burrito but wanna change content.  if you use a burrito to do that, it's <*>.  if you use burrito without wrap, it's <$>.   so i'll call them safe and bare respectively.
07:48:50 <kqr> ...suuure
07:49:21 <chpatrick> I thought monads were a dildo factory staffed by midgets
07:49:29 <hodapp> chpatrick: they are
07:49:33 <hodapp> now let's go get some burritos
07:49:49 <slack1256> yeah, let go with burritos, please
07:50:08 <hodapp> did you hear that Chipotle will soon be delivering?
07:50:13 <saml> <$> really makes sense since $ is bare but <$> is same as $ but inside wrap
07:50:23 <saml> how did <*> come from?
07:50:37 <mau}ke}> .oO( from some asshole )
07:50:50 <saml> * is product. product inside wrap, <*>
07:51:38 <slack1256> * is kind of binary operation on algebra
07:51:39 <ion> hi mauåkeå
07:51:47 <slack1256> though redifining + is also popular
07:51:51 <hodapp> I'm not sure I understand what burrito even means here...
07:51:57 <hodapp> could someone explain it in terms of monads or something?
07:52:08 <arbelos> not to mention <|>
07:52:11 <saml> is there <+> ?
07:52:25 <hodapp> what is <|>?
07:52:31 <yasar11732> saml, what was the purpose of <$>
07:52:35 <saml> i saw <|> in parsec
07:52:42 <geekosaur> @remember hodapp I'm not sure I understand what burrito even means here... could someone explain it in terms of monads or something?
07:52:42 <lambdabot> It is stored.
07:52:50 <saml> <+> is arrow plus
07:53:04 <slack1256> <|> is from alternative
07:53:38 <slack1256> wrapBurrito :: a -> m a
07:53:42 <hodapp> geekosaur :P
07:54:53 <slack1256> changeFillingBurrito :: m a -> (a -> m b) -> m b
07:54:53 <kqr> saml, the original paper used something like ⍟ that except with ٭ that inside
07:54:53 <kqr> saml, <*> is a decent representation of that I guess
07:54:53 <saml> yasar11732, purpose of <$> is when you want to call a function inside a wrap.  like  (+1) <$> wrappedInt2    gives wrappedInt3
07:55:49 <RGamma> I'm planning to write a parsing/editing library for various related binary/textual formats (all are descriptions of input (digital button presses, I don't want to deal with analog input yet) to an emulator, some are binary some text). Any tips on how to write this most concisely? Planned functionality is: file validation, data extraction from file, conversion between formats (if possible), editing. Any
07:55:51 <RGamma> suggestions for idioms/libs?
07:56:07 <saml> RGamma, you can use parsec
07:56:32 <fractalsea> I want to have an STM transaction occur as the last computation in a thread created with forkIO. If I print out the result of the transaction afterwords, everything seems fine. However, if I don’t, then I end up with a very sever memory leak. Presumably because the thread is holding onto a thunk to do the transaction but not actually executing it. Is there any way to force it to be evaluated other than doing some IO with the result afterwords (e.g.
07:56:32 <fractalsea> print)? I have tried seq and bang patterns with no luck…
07:57:29 <mau}ke}> :t evaluate
07:57:30 <lambdabot> a -> IO a
07:57:38 <RGamma> saml: You think that plays well with binary formats?
07:57:44 <mau}ke}> :t evaluate . length . show
07:57:45 <lambdabot> Show a => a -> IO Int
07:57:57 <saml> oh i don't know about binary. probably parsec is mostly for String
07:58:03 <hexagoxel> fractalsea: you probably need deepseq
07:58:09 <slack1256> he didn't want to do IO though
07:58:28 <saml> RGamma, http://hackage.haskell.org/package/attoparsec  i don't have experience with this though
07:58:34 <Stratege> RGamma there is attoparsec which is for binary
07:59:01 <fractalsea> Thanks. I will look into those suggestions now
07:59:04 <slack1256> The thing is that `seq` doesn't really evaluates, 'a `seq` b' promise that when you evaluate b it will also evaluate a to whnf.
07:59:12 <RGamma> So attoparsec for binary and parsec for text? Do they work well together? E.g. if I had to convert a binary format to text and back?
07:59:51 <fractalsea> slack1256: I should have said that I don’t mind doing trivial IO. I just don’t want to do actual IO (printing etc) for the sake of forcing the computation
08:00:22 <kqr> RGamma, you can use attoparsec for text too
08:00:31 <RGamma> Well, I guess I'll just start and see whether there are issues of any sort. (atto)parsec seems quite popular
08:00:37 <kqr> RGamma, the difference between attoparsec and parsec is that attoparsec is faster but gives you terrible error messages
08:00:51 <RGamma> kqr: Speed is no concern to me
08:01:14 <kqr> you should be able to do what you want with either
08:01:26 <RGamma> Alright, I'll try Parsec first
08:01:34 <RGamma> Thanks
08:01:54 <bartavelle> (also attoparsec is always backtracking, and you have to use the "try" combinator with parsec)
08:02:44 <bartavelle> (and parsec API isn't too great, I usually go for "parsers" instead, which is a common API for several underlying parsers)
08:02:46 <kqr> bartavelle, do you have any explanation as to why they did it that way? it would seem to me "always backtracking" is slower than having opt in backtracking
08:03:13 <fractalsea> mau}ke}: Is there a reason evaluate is in Control.Exception? Seems like a very general function to be in thet module.
08:04:15 <bartavelle> kqr, I would expect the same thing in general
08:04:38 * hackagebot pdf-toolbox-core 0.0.3.3 - A collection of tools for processing PDF files.  http://hackage.haskell.org/package/pdf-toolbox-core-0.0.3.3 (YurasShumovich)
08:04:40 * hackagebot pdf-toolbox-content 0.0.3.3 - A collection of tools for processing PDF files  http://hackage.haskell.org/package/pdf-toolbox-content-0.0.3.3 (YurasShumovich)
08:04:42 * hackagebot pdf-toolbox-document 0.0.5.1 - A collection of tools for processing PDF files.  http://hackage.haskell.org/package/pdf-toolbox-document-0.0.5.1 (YurasShumovich)
08:04:44 * hackagebot pdf-toolbox-viewer 0.0.3.3 - Simple pdf viewer  http://hackage.haskell.org/package/pdf-toolbox-viewer-0.0.3.3 (YurasShumovich)
08:05:08 <bartavelle> attoparsec is still faster, probably because it doesn't keep the position, you can parse Text or ByteString bits directly, and the monad looks like a crazy church encoding of something ...
08:05:18 <kqr> haha
08:06:26 <RGamma> Well, ideally I would want to store the format specs in an external file, read that in and marshal it to a parser
08:06:45 <slack1256> isn't that what alex/happy do?
08:06:59 <mau}ke}> Parser (Parser a)
08:07:14 <mau}ke}> fractalsea: it probably goes with throw
08:10:58 <RGamma> Also, (unrelated question). Haskell's FFI only allows interfacing with C at this point, right?
08:11:43 <chpatrick> RGamma: trust me the parser combinator approach is a million times nicer than code generation :)
08:11:47 <chpatrick> and yeah
08:12:37 <RGamma> Well, C is fine though. Wonder whether there'll be some abstraction for interfacing with any language some day
08:12:39 <andyf> newbie question: what does <> mean in Haskell?  Having a difficult time finding a definition, even using symbolhound.com
08:12:47 <SrPx> How are constructors with one argument represented on GHC.Generics? I know Unit is used for 0 arguments and products are used for 2+ arguments. But and 1?
08:12:49 <chpatrick> andyf: it's mappend
08:12:56 <chpatrick> from Data.Monoid
08:13:10 <slack1256> @whereis hoogle
08:13:10 <lambdabot> Maybe you meant: where+ where
08:13:20 <slack1256> @where hoogle
08:13:20 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
08:13:22 <RGamma> chpatrick: Yeah, I'm not a big fan of generated code either
08:13:37 <chpatrick> I'd even say monadic parsing is one of haskell's killer apps
08:13:37 <andyf> chpatrick: thx
08:13:52 <slack1256> andyf: hoogle also lets you locate functions and operators
08:13:55 <hodapp> I'm not a fan of generated code, but I am even less a fan of horrible hand-maintained C
08:14:18 <chpatrick> sure but you can get better performance than handwritten C with attoparsec right?
08:14:21 <chpatrick> at least in some cases
08:14:34 <chpatrick> didn't it beat the node http parser?
08:15:28 <chpatrick> RGamma: pretty few languages do anything other than C :( the most common approach I see is serializing messages with protobuf or messagepack and deserializing in the other language
08:17:05 <andyf> When equational reasoning is done, is it always done with ‘=‘ ?  That is, does anyone ever try to do equational reasoning, or something like it, using ‘==‘ ?
08:17:38 <RGamma> BTW, I recently found http://www.cs.york.ac.uk/fp/reduceron/ (The Reduceron: High-Level Symbolic Computing on FPGA). I feel this could deserve more attention :)
08:17:45 <kqr> RGamma, any particular reason you want to store the format spec in an external file?
08:17:59 <kqr> RGamma, a parsec parser reads almost like BNF, if that's what you're worried about
08:19:02 <RGamma> kqr: Yeah, I thought you could make it have a nicer format, be a tad easier to modify too. It doesn't really matter in the end if I hardcode it or have it external
08:20:00 <RGamma> But I like the idea of having a universal description of a format in a seperate file, so that everyone can use that
08:20:24 <RGamma> (because right now, the specs of the formats in question are, err.. messy)
08:20:38 <RGamma> Or not as rigid as one would expect them to be
08:21:01 <c_wraith> andyf: equational reasoning is usually not done with ==, because many times the things you are reasoning about cannot implement ==
08:22:23 <andyf> c_wraith: Do you know of any examples of equational reasoning done with == ?
08:23:40 <c_wraith> no
08:23:46 <RGamma> kqr: We're all probably a bit obsessed with formalizing everything :P
08:24:39 <RGamma> (or with "eternal code" for that matter)
08:29:56 <duncanhill> Hey guys! Quick question, how would you structure something like this? I'm trying to associate types (or errors) with nodes in an AST as I type check it. I've tried creating a map from node to type, but that got very messy and lost the convenience oassociated with just walking the AST. I've tried to avoid modifying the AST's nodes to have fields for the types, just as that's a lot of redundancy. Any ideas on a clean design? For context,
08:29:56 <duncanhill> it's a toy Rust compiler, but I doubt that matters. Thanks :).
08:31:00 <pleiosaur> duncanhill: toy rust compiler? link please :)
08:31:46 <duncanhill> pleiosaur: I'll get it up on Github or Bitbucket real fast. :). So it may be a moment.
08:32:01 <chpatrick> Applicative f => (forall a. Arg a -> f a) -> Args r -> f r
08:32:14 <chpatrick> is this some form of lens type?
08:39:22 <duncanhill> pleiosaur: https://bitbucket.org/duncanhill/rustcompiler/
08:39:40 * hackagebot pred-trie 0.0.8 - Predicative tries  http://hackage.haskell.org/package/pred-trie-0.0.8 (athanclark)
08:39:56 <duncanhill> Some of it's been for school, but I deviated a bit and decided to use Haskell, which worked wondersssss for parsing ;)
08:41:23 <jkbbwr> Hey all, need help with ghc-modi NG BUG: GMEIOException /home/jakob/projects/personal/hs/lushs/dist/setup-config: hGetContents: invalid argument (invalid byte sequence)
08:42:59 <maybefbi> given a type constructor, i want to count the number of unused type contructors for the same type. is this possible in haskell?
08:43:54 <mau}ke}> what do you mean by unused?
08:43:59 <rancidpolecat> jkbbwr: what version of ghc and cabal are you using?
08:44:46 <jkbbwr> rancidpolecat: https://gist.github.com/jkbbwr/f39766e96fdf7407fea1
08:45:07 <Cale> maybefbi: Unused type constructors for the same type? What?
08:46:10 <duncanhill> Hmm, is there some way to attach additional information to a node of an AST (or just a type in general) without modifying the type directly? Like a wrapper of sorts, but not really a full wrapper because it would break the links between the nodes...
08:46:45 <maybefbi> Cale, data T = A | B | C; data UnusedCounter a; unusedCounter :: UnusedCounter a -> Int;
08:46:51 <maybefbi> mau}ke}, ^
08:47:00 <mau}ke}> what?
08:47:26 <mau}ke}> so we have three type constructors there: T, UnusedCounter, Int
08:47:45 <mau}ke}> and three data constructors: A, B, C
08:48:01 <mau}ke}> what is the "same type" you were talking abotu?
08:48:04 <Cale> I'm still completely in the dark about what maybefbi wants
08:48:26 <maybefbi> um never mind its ok. i will come back with a more concrete version of the problem
08:48:54 <rancidpolecat> jkbbwr: see https://github.com/kazu-yamamoto/ghc-mod/issues/429
08:49:18 <RGamma> Cale: Possibly some kind of introspection?
08:49:40 <rancidpolecat> jkbbwr: you might need to downgrade cabal
08:50:47 <mau}ke}> > dataTypeConstrs (dataTypeOf (Just ""))
08:50:47 <Cale> maybefbi: What value would unusedCounter A have?
08:50:48 <lambdabot>  [Nothing,Just]
08:50:52 <Cale> er
08:51:02 <Cale> No, we can't apply that, nevermind
08:51:08 <RGamma> maybefbi: And "data UnusedCounter a" is malformed syntax
08:51:09 <jkbbwr> rancidpolecat: how?
08:51:23 <Cale> The unusedCounter function is pretty much impossible to apply in that example
08:51:29 <Cale> Except to undefined
08:51:35 <Cale> So, we could write something like
08:51:42 <mau}ke}> RGamma: no, it's not
08:51:49 <Cale> unusedCounter (undefined :: UnusedCounter T)
08:52:17 <Cale> Since there are no defined values of type UnusedCounter a, we're sort of forced to
08:52:45 <Cale> But I don't know if maybefbi intended that type to be empty or not
08:52:53 <rancidpolecat> jkbbwr: maybe something like: cabal install --constraint "Cabal < 1.22" cabal-install
08:53:03 <jkbbwr> Kinky
08:53:27 <maybefbi> Cale, my formulation was flawed
08:53:27 <RGamma> mau}ke}: Mhh, what semantics does this have then?
08:53:43 <RGamma> mau}ke}: Nullary type?
08:53:50 <mau}ke}> RGamma: "the obvious semantics" :-)
08:54:02 <mau}ke}> contains no values except _|_
08:54:11 <maybefbi> Given a type can i count the number of type constructors it has?
08:54:19 <maybefbi> count :: a -> Int
08:54:20 <mau}ke}> if it's an instance of Data, yes
08:54:20 <RGamma> Oh wait, no
08:54:29 <mau}ke}> count :: (Data a) => a -> Int
08:54:32 <pleiosaur> duncanhill: how complete is this intended to be? I don't suppose you've managed to reimplement the borrow checker quite yet :)
08:55:10 <Cale> maybefbi: In general, no. But you statically know how many constructors your types have.
08:55:24 <RGamma> mau}ke}: Well, have never seen such a thing
08:55:24 <maybefbi> ok
08:55:32 <RGamma> I take everything I said back then
08:55:37 <mau}ke}> :t length . dataTypeConstrs . dataTypeOf
08:55:37 <lambdabot> Data a => a -> Int
08:55:46 <maybefbi> wow
08:55:47 <Cale> and as mauke points out, it's possible to encode information about how the type is defined using a type class instance
08:56:03 <maybefbi> where can one fine docs on this Data?
08:56:03 <mau}ke}> > (length . dataTypeConstrs . dataTypeOf) (undefined :: Maybe Int)
08:56:06 <lambdabot>  2
08:56:08 <mau}ke}> > (length . dataTypeConstrs . dataTypeOf) (undefined :: Int)
08:56:10 <lambdabot>  *Exception: Data.Data.dataTypeConstrs is not supported for Prelude.Int, as i...
08:56:19 <maybefbi> i see
08:56:32 <mau}ke}> http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Data.html
08:56:52 <maybefbi> thanks man!
08:57:05 <RGamma> "To address that concern, Haskell 2010 (or GHC with EmptyDataDecls) allows you to just not specify any constructors at all: data Void", I see
08:57:08 <mau}ke}> import qualified Data.Data; count :: Data.Data.Data data => data -> Int
08:57:54 <mau}ke}> import qualified Data.Data; type Data = Int; data :: Data.Data.Data data => data -> Data
08:58:23 <mau}ke}> RGamma: in H98 you have to write newtype Void = Void Void
08:58:32 <RGamma> Yeah, that I understand
08:59:05 <RGamma> Although it seems weird to ever use that
08:59:27 <mau}ke}> Void (Void (Void ...)) == undefined
09:00:26 <maybefbi> i would need it to implement a method to count the cardinality of a borel set of an ADT
09:00:29 <RGamma> mau}ke}: That's undergrad FP education for you :)
09:00:30 <maybefbi> *GADT
09:01:10 <maybefbi> i would need that  length . dataTypeConstrs . dataTypeOf
09:01:21 <RGamma> mau}ke}: No exceptional cases, no advanced features allowed. To be fair, that course was only a half year and the only one I had about Haskell/FP
09:04:32 <mishac> Hi guys, does anyone know how to fix missing c library erro?
09:04:49 <mau}ke}> install the missing C library?
09:05:23 <c_wraith> or just the headers for it, if you're on a debian-derived system
09:05:34 <c_wraith> Since they often put the headers in a separate -dev package
09:05:41 <cite-reader> It usually starts with lots of Googling. "What fscking library defines that missing symbol?!"
09:09:12 <mishac> I am not sure how to do it in windows environment
09:09:17 <mishac> does anyone have any pointers?
09:09:31 <mishac> besides google of course.
09:09:41 <oconnore> mishac: what are you doing that triggers this?
09:09:54 <mishac> i am tryin to install snappy library,
09:10:00 <mishac> and during the installation it says
09:10:04 <mishac> missing C library snappy
09:10:12 <mau}ke}> is that all it says?
09:10:24 <mishac> i can past detailed description
09:10:26 <mishac> gimme a sec
09:11:42 <mishac> Hi Mau}ke}
09:11:48 <mishac> this is the http://pastebin.com/usQBcTjn link
09:12:24 <mishac> i have been trying to figure out how to solve the problem, but still could not find solution
09:12:30 <mishac> so asking people was my last resourt
09:12:41 <oconnore> mishac: you need this: https://code.google.com/p/snappy/
09:13:01 <mishac> how do I install it in windows?
09:13:12 <mishac> do I need to go for C or C++
09:14:06 <ElMoloko> hmm
09:14:48 <ElMoloko> just install it manually
09:14:55 <k0ral> is there a way to use Data.IntSet lazily ? E.g. "take 5 . IntSet.toList $ IntSet.fromList [1..]" causes an infinite loop, while I expect it to lazily evaluate the 5 first elements
09:15:38 <oconnore> mishac: yeah, you will need a tool like 7zip to extract the tarball, then a c++ compiler and all the build tools -- autoconf, make, etc.
09:15:41 <Cale> k0ral: How would it know what the least 5 elements are in an infinite list?
09:16:00 <ElMoloko> why does cabal try to install snappy 0.2.0.2?
09:16:06 <Cale> k0ral: Well, I guess for Int, that list isn't really infinite.
09:16:15 <mishac> it is bindings to c library snappy
09:16:21 <Cale> k0ral: So the loop should terminate actually
09:16:51 <k0ral> Cale: right, but you see my point, it should not evaluate the complete range of Int
09:16:57 <Cale> k0ral: Why not?
09:16:59 <ElMoloko> you need the library itself before you can install the bindings for it
09:17:06 <k0ral> by "should" I mean "I don't expect it to"
09:17:06 <ElMoloko> ahh yeah i see
09:17:17 <Cale> k0ral: There might be elements later in the list which are less than 1
09:17:27 <Cale> k0ral: and it can'
09:17:33 <Cale> k0ral: and it can't know that without looking
09:18:11 <Cale> (or less than 5 even)
09:18:19 <oconnore> mishac: GHC for windows has a built in MingW, and if you install MinGhc you get make, autoconf, etc in C:\Program Files\MinGHC-7.10.1\msys-1.0.1\bin\
09:18:21 <mishac> Just a few more questions, I should try to install snappy-1.1.1.tar.gz tarball
09:18:45 <mau}ke}> you don't "install" tarballs
09:18:49 <mishac> oconnre: thank you. so it means that I do not need to install c++ compiler
09:18:55 <k0ral> Cale: I think I misunderstood what was IntSet then, I didn't know it had some logic about the order of its elements
09:18:58 <mishac> because i just installed MnGhc
09:19:38 <ReinH> k0ral: you know that the smallest Int in the list is 1. GHC does not. It doesn't matter if you use IntSet or some other means, if you're asking for "smallest elements" there's no way to get them.
09:19:41 * hackagebot logging 2.2.0 - Simplified logging in IO for application writers.  http://hackage.haskell.org/package/logging-2.2.0 (JohnWiegley)
09:20:05 <oconnore> mishac: cool ya, MingW comes with one, and the msys tools include the build tooling you need.
09:20:20 <mau}ke}> > (take 5 . nub) [1..]
09:20:21 <lambdabot>  [1,2,3,4,5]
09:20:21 <haskell377> hey guys, quick q: http://lpaste.net/131392
09:20:39 <mishac> Thanks..
09:20:40 <oconnore> mishac: if you get it building on windows you should add some documentation to the snappy project about windows support: https://github.com/bos/snappy
09:20:57 <mishac> If I get it to work, i will most definitely going to do this
09:21:08 <mau}ke}> haskell377: seems complicated
09:21:12 <Cale> haskell377: consider using group
09:21:14 <oconnore> mishac: cool, good luck!
09:21:15 <mau}ke}> I'd do it the lazy way
09:21:39 <mishac> just one more question, is there a good generic guide on how to build C++ tools in windows
09:21:44 <Cale> > group "mississippi"
09:21:46 <lambdabot>  ["m","i","ss","i","ss","i","pp","i"]
09:21:47 <mishac> i mean how to use autocom make to compile from source
09:21:50 <Cale> > group . sort $ "mississippi"
09:21:52 <lambdabot>  ["iiii","m","pp","ssss"]
09:22:51 <haskell377> ah.
09:23:14 <mau}ke}> :t ((==) <*> nub) . map toLower
09:23:15 <lambdabot> [Char] -> Bool
09:23:15 <Cale> But you should be able to use foldr
09:23:30 <oconnore> mishac: I'm not sure about a guide per se, but http://sourceforge.net/p/mingw-w64/wiki2/Home/ http://www.mingw.org/wiki and http://mingw-w64.yaxm.org/doku.php are good resources
09:23:34 <Cale> > S.empty -- just checking how this is qualified...
09:23:36 <lambdabot>  fromList []
09:23:39 <jemu1> hi, i've got a function "field :: Parser (String, TypeName)", how can i combine this function with this type constructor "ConstField :: String -> TypeName -> ClassMember" to get a "Parser ClassMember"?
09:23:40 <Cale> okay, good
09:23:43 <mishac> thank you
09:24:05 <mau}ke}> jemu1: that doesn't look like a function to me
09:24:30 <mau}ke}> jemu1: do { (x, y) <- field; return (ConstField x y) }
09:24:51 <mau}ke}> jemu1: uncurry ConstField <$> field
09:25:55 <jemu1> mau}ke}: nice solution that type checks :) thx
09:26:58 <Cale> > foldr (\x r s -> S.member x s || r (S.insert x s))  (\s -> False) [1,2,3,1,4] S.empty
09:27:00 <lambdabot>  True
09:27:03 <Cale> > foldr (\x r s -> S.member x s || r (S.insert x s))  (\s -> False) [1,2,3,4] S.empty
09:27:05 <lambdabot>  False
09:27:38 <Cale> haskell377: ^^ there's a rather fancy way to do it
09:28:08 <SwashBuckla> I get this back from cabal: 'checking whether the C compiler works... no' -- why might I get this?
09:28:30 <mau}ke}> because your C compiler doesn't work?
09:28:45 <Cale> SwashBuckla: That looks like cabal ran a configure script
09:29:13 <Cale> (and yeah, you tend to get that if your C compiler isn't installed or is otherwise completely incapacitated)
09:29:20 <SwashBuckla> is there a log I can check as to how it came to that conclusion?
09:29:42 <haskell377> thanks cale! Ill study that way as well. 
09:30:08 <mau}ke}> strace = best log
09:30:13 <imPure> Is it possible to define a type family on an index that's either a Natural or List of Naturals?
09:30:45 <Cale> imPure: By defining a datatype with constructors for those cases and lifting it...
09:31:01 <imPure> Cale: I see. Trying that...
09:31:13 <imPure> Cale: Well, wait.. sorry..
09:31:33 <imPure> Cale: I'd like to be able to define T [3] or T 3
09:31:40 <SwashBuckla> mau}ke}: see config.log for more details
09:31:43 <imPure> It's syntactic sugar, but it's important for the application.
09:31:50 <Cale> imPure: Nope, can't do that.
09:32:00 <imPure> Cale: :(
09:32:02 <Cale> imPure: Those two things have different kinds.
09:32:16 <imPure> Cale: But they both share the fact they have a kind.
09:32:24 <imPure> Cale: Is there no level arithmetic like in Agda?
09:32:25 <Cale> imPure: So the only way that they'd both be valid is if T were kind-polymorphic
09:32:40 <yasar11732> can someone help me with this error: http://lpaste.net/131396
09:32:47 <Cale> In which case, there would be no way for T to inspect the types there.
09:33:04 <imPure> Cale: I'm not familiar with kind polymorphism. I can tease out the meaning from the phonemes, but is there something specific I can read
09:33:26 <Cale> imPure: This has nothing to do with level arithmetic, Agda wouldn't accept this sort of thing either.
09:33:47 <Cale> Well, maybe you could get away with giving T an additional hidden type parameter in Agda.
09:33:59 <Cale> and having Agda infer it
09:34:11 <mau}ke}> ysr: Text and String are different types
09:34:25 <imPure> Cale: What about data families?
09:34:42 * hackagebot pred-trie 0.0.8.1 - Predicative tries  http://hackage.haskell.org/package/pred-trie-0.0.8.1 (athanclark)
09:34:44 * hackagebot nested-routes 0.2.2 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-0.2.2 (athanclark)
09:34:58 <imPure> Cale: It's suboptimal to have to deal with the cases everywhere, but I'm more interested in the syntactic sugar in this case.
09:35:11 <imPure> Cale: Of being able to use either a type or a list of that type.
09:35:13 <Cale> I mean, you can just do  data NL = N Nat | L [Nat]
09:35:17 <ysr> mau}ke} is there a function like lines but return Text?
09:35:30 <Cale> and then T (N 5) or T (L [3])
09:35:36 <mau}ke}> ysr: yes, Data.Text.lines
09:35:52 <imPure> Cale: I'm trying to make these work: ℤ/n && ℤ/[n, m, ...]
09:36:19 <Cale> Use different notation.
09:37:16 <Cale> Actually, what do you even mean by Z/[n,m,...]? Modulo the ideal generated by [n,m,...]?
09:37:23 <imPure> Cale: Yes.
09:37:37 <imPure> Cale: Well, an RNS, but I'm pretty sure that's the same thing.
09:37:40 <Cale> Z is a principal ideal domain, so you could always just take the gcd.
09:37:50 <javjarfer> hello there! Anyone knows who i should read this: "(Endo #. f)"?
09:38:06 <nshepperd_> surely the most sensible way to do that is ℤ/n && Z//[n, m, ...]
09:38:12 <Cale> javjarfer: Which library is #. from?
09:38:13 <mau}ke}> read me it
09:38:18 <nshepperd_> just use a similar but different operator
09:38:47 <javjarfer> Cale: it's from Data.Foldable
09:39:01 <imPure> nshepperd: Or I could just do ℤ/[n]. I'm not being sensible, I'm being irrational. Progress demands it.
09:39:01 <javjarfer> Cale: foldr definition
09:39:06 <nshepperd_> I mean if this was at the value level you would support such syntactic sugar with a typeclass. But I don't think type-level typeclasses exist
09:39:18 <nshepperd_> (yet??)
09:39:35 <mau}ke}> (#.) _f = coerce  -- pfft
09:39:39 <imPure> nshepperd_: Exactly what I was going to lob at Cale next. In Agda, I could use a record to make a type class and do this.
09:41:20 <Cale> imPure: I would tend to stay clear of all of this sort of thing in Haskell unless absolutely forced into it.
09:41:22 <nshepperd_> (at the value level too it would be considered frivolous misuse of typeclasses, but eh)
09:41:48 <Cale> imPure: You can theoretically do type level computation in Haskell, but it's not pretty.
09:42:08 <ysr> when I import Data.Text.Lazy.IO readFile, it collides with Prelude readFile
09:42:17 <ysr> do I have to import it qualified
09:42:20 <imPure> Ok, what about a larger question / issue I have. Is there any way to represent the concept of subgroups?
09:42:40 <imPure> That is... If I add two integers, I want an integer, but if I add an integer and a complex, I'm really adding two complex numbers.
09:42:41 <Cale> imPure: As values, or as types?
09:43:06 <mau}ke}> ysr: yes, or hide it from Prelude
09:43:17 <mau}ke}> import Prelude hiding (lines, readFile)
09:43:24 <imPure> Cale: Specifically... I want 0 to be an existential concept. Like mzero, or mempty
09:43:36 <imPure> Cale: Except, I want to build a lattice of types.
09:43:45 <Cale> imPure: Well, there isn't much in the way of suitable representations of the complex numbers which would actually extend Integer, unless you pull in some library for computable reals.
09:44:07 <imPure> Cale: Gaussian. I have my own implementation.
09:44:09 <Cale> The conversion Integer -> Complex Double is lossy.
09:44:18 <Cale> hm
09:44:26 <ysr> I am starting to love hoogle
09:44:41 <imPure> Cale: Gassuains are a field. Integers are a sub-field.
09:44:43 <mau}ke}> hoogle is good for search-by-type
09:44:50 <mau}ke}> for the rest, hayoo is better
09:45:02 <Cale> imPure: ring.
09:45:06 <Cale> imPure: But okay
09:45:21 <benzrf> hey
09:45:26 <imPure> Cale: Quaternions are merely a ring, why aren't Complex a field?
09:45:35 <benzrf> does quickcheck support pure testing
09:45:38 <benzrf> using Rand or somethin
09:45:43 <imPure> Cale: Gaussians... oh, division
09:45:51 <imPure> Cale: Ok, well, a UFD at least.
09:46:00 <athan> Is there a co-takeWhile? Where it just throws away contents until a predicate is satisfied?
09:46:06 <benzrf> :t dropWhile
09:46:07 <lambdabot> (a -> Bool) -> [a] -> [a]
09:46:09 <athan> ><
09:46:11 <benzrf> athan: im not sure i'd call that "co"
09:46:11 <athan> thanks benzrf
09:46:18 <benzrf> what category are you taking the opposite of?
09:46:19 <Cale> Yeah, while you absolutely can define a type class for addition of things of different types, and put a functional dependency on it to let it infer the result type from the argument types, I think you'll find actually using such a type class to be painful.
09:46:20 <benzrf> :>
09:46:20 <mau}ke}> consider a ring of rings (a ring ring). a ring ring ring ... bananaphone
09:46:21 <athan> benzrf: yeah yeah :S
09:46:37 <imPure> Cale: Yea, I tried that and gave up.
09:46:37 <Cale> imPure: It's better just to make conversions explicit.
09:46:51 <ysr> ok, I have a new problem
09:46:53 <ysr> http://lpaste.net/131397
09:47:06 <imPure> Cale: I just need the concept of subclass. Sort of, promotion between objects of the same level.
09:47:18 <Cale> Just use a function :)
09:47:40 <Cale> There's a function  Integer -> GaussianInteger  which does this promotion.
09:48:05 <mau}ke}> ysr: do you want to use strict Text or lazy Text?
09:48:07 <imPure> Cale: The reason people use python is they don't have to deal with the type system. The reason they abandon Python is that they don't get to use a type system. I want the type system, I just want it to be as invisible as possible.
09:48:28 <imPure> Cale: And no more.
09:48:43 <Cale> imPure: Then define a Number type and have constructors for Integer and GaussianInteger
09:48:58 <Cale> and compute the type of the result at runtime
09:49:00 <ysr> mau}ke} I didn't even know there was 2 types of strings :)
09:49:08 <Cale> "type"
09:49:29 <imPure> Cale: Ok - for now :) I'll come back when I'm feeling more unreasonable.
09:49:43 <mau}ke}> ysr: http://hackage.haskell.org/package/text-1.2.0.4/docs/Data-Text.html#g:1
09:49:49 <mau}ke}> right at the top of the documentation
09:50:46 <nshepperd_> imPure: you can easily define a Promote typeclass that will do the promotion from Integer to Gaussian Integer
09:50:53 <Cale> imPure: In Haskell, the split between what is part of the terms and what is part of the types almost entirely corresponds to the split between what is done at runtime vs. what is done at compile time.
09:50:56 <nshepperd_> foo i x = promote i * x
09:51:27 <Cale> If you want the type system to get out of your hair, and be less precise, you can always just encode more information at the value level instead.
09:52:07 <imPure> nshepperd_: That's a good point. But... I still have to do it. The property I'm preserving closure.
09:52:18 <nshepperd_> (and presumably also promotion from Integer to Rational or what have you)
09:52:21 <Cale> But if you really want to do fancy computations of what types things should have at compile time, you get into a space where Haskell is only sort of borderline usable.
09:52:26 <imPure> nshepperd_: I want the promotion to kick in on violation of that closure. Every time.
09:53:15 <Cale> imPure: Yeah, doing that would completely obliterate the ability to do type inference.
09:53:16 <imPure> I think you're both right. I really need to just sit down and reason out what's knowable at compile time. That's the limit.
09:53:46 <nshepperd_> even aside from that, invisible type conversions just make it harder to think
09:54:27 <imPure> nshepperd_: I'd agree, except there's a very clear and reasonable reaction to adding something of a sub-group to a member of the larger group.
09:54:43 * hackagebot nested-routes 0.2.2.1 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-0.2.2.1 (athanclark)
09:55:26 <imPure> nshepperd_: Sure, there are an infinite number of generalizations, but there's a infinum response.
09:55:42 <imPure> nshepperd_: Convert to the larger of the two.
09:58:24 <nshepperd_> of course, if your hierarchy is closed at the top you could use liquid haskell... and compute with the top type all along
09:58:37 <oconnore> athan: nested-routes looks cool -- I wrote something like that for Node.js once
09:58:47 <nshepperd_> and represent the rest of the hierarchy as range restrictions of the top type
09:58:50 <Cale> imPure: It works for the lattice of subgroups of a group or something like that, but in general, that kind of capacity is pretty hairy to specify. You need your conversions to be coherent, or else converting via one intermediate type will produce different results from another, and that will rapidly lead to things being very difficult to reason about.
09:58:54 <athan> oconnore: Thanks :) It's taken me forever to get it implemented
09:59:10 <athan> there are still some bugs and insufficiencies, but hopefully it'll be ready soon!
09:59:14 <nshepperd_> whether that's an awful idea idunno
09:59:19 <oconnore> athan: sweet :)
09:59:38 <lifter> ooo
10:00:17 <imPure> Hmmmm. If only Haskell was fully dependently typed :) I'd use Agda, but it's soooo darn slow.
10:00:27 <nshepperd_> 'type Integer = { GaussianInteger | imaginaryPart = 0 }' to use a fake syntax I just made up that isn't how liquidhaskell actually works
10:00:31 <Cale> imPure: You need the property that any two chains of implicit conversions that you could possibly do to get from type A to type B via some intermediate types will produce the same outcome.
10:00:55 <Cale> imPure: Or else that way lies madness.
10:01:20 <oconnore> athan: when I wrote the js version, a feature I liked was authentication checks to access sub-trees, and exception handlers that bubble up the tree
10:01:30 <imPure> Cale: Isn't that the case with sub groups? I'm taking the supremum at each step.
10:01:33 <nshepperd_> imPure: you have seen liquid haskell I assume
10:01:35 <imPure> Cale: It's just a lattice.
10:01:40 <imPure> nshepperd_: I haven't.
10:01:43 <Cale> imPure: Yeah, it's true with inclusion maps in general.
10:01:47 <athan> oconnore: Hmm, okay that sounds interesting! I haven't thought about that
10:01:49 <imPure> nshepperd_: I'm looking at the PDF now.
10:02:01 <athan> maybe something like a state index that trickles down the tree?
10:02:06 <athan> hmm
10:02:19 <oconnore> athan: yeah -- this was my impl -> https://github.com/oconnore/tree-router
10:02:23 <athan> oconnore: The most I have right now are nested 404s :\
10:02:28 <Cale> imPure: If you were defining all your subgroups using Sigma types of the same base type, that'd be fine.
10:02:28 <imPure> nshepperd_: The main question, is it a drop-in replacement for GHC.
10:02:31 <athan> oconnore: Awesome :)
10:02:40 <Cale> Well...
10:02:54 <Cale> provided that you don't care about which proof that an element lies in the subgroup you have
10:03:14 <nshepperd_> imPure: I think it lives alongside ghc
10:03:16 <imPure> If liquid haskell was a syntax extension or such of GHC I'd be using it :)
10:03:17 <Cale> That'll usually be a proposition anyway
10:04:44 * hackagebot list-t-text 0.1.0.2 - A streaming text codec  http://hackage.haskell.org/package/list-t-text-0.1.0.2 (NikitaVolkov)
10:05:04 <johnw> imPure: there's a GSoC for that
10:05:48 <Cale> But yeah, in a dependently typed setting, it might make sense to define an implicit coercion Sigma A P -> Sigma A Q whenever P -> Q and every fibre of P and of Q is a proposition.
10:06:07 <nshepperd_> imPure: Liquid Haskell source code is valid GHC source code, with special comments containing the refinement types stuff iirc.
10:06:48 <imPure> johnw: Hmmm. Interesting.
10:07:03 <nshepperd_> imPure: you run the liquidtypes verifier separately at the moment
10:07:27 <imPure> Ok. I see. This is making sense.
10:07:33 <nshepperd_> although I'm very sleepy so I might say something wrong
10:10:23 <nshepperd_> anyway that's an option if you're feeling particularly hardcore
10:11:42 <imPure> nshepperd_: I may pursue it. Not today, it gives me a sense of scale for the problem so I can plan around it though. It's definetly something to pursue though.
10:16:40 <c_wraith> nshepperd_: those assertions about liquidhaskell are all valid
10:17:27 <MP2E> liquidhaskell looks really great, haven't tried it yet but I want to
10:17:36 <MP2E> s/want/plan/
10:17:41 <johnw> liquidhaskell is pretty awesome, I've used it for some toy programs
10:17:46 <johnw> although, you can't yet use it much with type classes
10:17:53 <johnw> proving Monad laws is something I would love for it to be able to do in future
10:18:07 <MP2E> yes, that would be great :D
10:19:45 * hackagebot pred-trie 0.0.9 - Predicative tries  http://hackage.haskell.org/package/pred-trie-0.0.9 (athanclark)
10:24:30 <ansible1> ok so I'm importing 'Import' in yesod, which brings in Database.Persistent.  I'm importing Database.Esqueleto, which conflicts with Persistent.  
10:24:55 <ansible1> I tried hiding persistent with 'import qualified Database.Persistent as P', but I still get ambiguity problems
10:25:00 <safinaskar> what is standard way to print error message and stop a program in IO monad? error? i. e. "main = error "message"" is standard way, right?
10:25:11 <ansible1> is there a way to hide the whole Database.Persistent?
10:25:11 <niklasb> safinaskar: fail?
10:25:21 <niklasb> error is pure actually
10:25:26 <niklasb> so it's a bit of a hack
10:28:40 <safinaskar> niklasb: "fail" prints "user error". i don't like this
10:29:13 <mau}ke}> hPutStrLn stderr "error message" >> exitFailure
10:31:24 <SrPx> I am comparing 2 data structures that offer the same API for performance. I want to create informative graphs. Any library that can help me on this?
10:31:31 <safinaskar> mau}ke}: niklasb: thanks
10:31:31 <johnw> I keep waiting for m}au}ke} to appear
10:31:32 <SrPx> graphics*
10:33:38 <mau}ke}> SrPx: http://www.serpentine.com/criterion/fibber.html like this?
10:38:21 <SrPx> ah I didn't know criterion could do this, thakns
10:41:51 <enthropy> SrPx: I don't think those charts are that informative, especially if you have say 2 modules × 5 functions × 10 sizes of data
10:42:30 <enthropy> but criterion can write a csv file for you with that mean and SD
10:42:58 <SrPx> yep I'm looking at it, seems like it targets something different, i.e., the benchmark probability curve for a specific setup
10:44:04 <SrPx> What I wanted is something that benchmarked a function against different input sizes (ints, perhaps) and made a pretty informative graphic of the benchmark times vs input size so you can visualize the complexity
10:44:46 * hackagebot nested-routes 0.2.2.2 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-0.2.2.2 (athanclark)
10:46:36 <athan> Alright, here's what it looks like so far: http://lpaste.net/131398 - comments? questions? :)
10:48:36 <athan> I want to get rid of the Either thing going on, and also make the url syntax... cleaner, but so far it works
10:51:27 <enthropy> SrPx: I dunno about pretty but criterion + ggplot is probably going to be the most informative
11:02:45 <SrPx> How do I benchmark functions that take some time to complete (> 1 second) on Criterion?
11:03:02 <jle`> Cale: not sure if you got my ping, but i am planning on crediting you in a post of mine...is there a name you prefer me to use? :)
11:03:03 <SrPx> It seems like it will keep benchmarking the function a billion times so it never completes...
11:03:32 <Denommus> is there anything similar to merlin for Haskell?
11:06:01 <SwashBuckla> is there a haskell action that keeps on making successive applications until some condition is false?
11:06:17 <SwashBuckla> some 'applyWhileM'
11:06:47 <nomeata> Is David Himmelstrup here?
11:08:11 <enthropy> ask quchen?
11:08:40 <quchen> ?
11:09:05 <jle`> SwashBuckla: it might be in monad-loops ?
11:09:30 <Cale> jle`: Cale is fine
11:09:49 <Cale> My last name is Gibbard in case you need one :)
11:10:30 <quchen> A first name that serves as a unique identifier is quite enviable.
11:11:16 * SrPx sighs
11:12:05 <SrPx> I'm using `--time-limit 1` (second) on Criterion and it is on the same benchmark since a minute ago...
11:13:13 <SrPx> guess I'll just do it manually...
11:13:23 <koala_man> quchen: I know someone with a unique name. She has to use an alias instead of her first name when meeting new people, otherwise they'll all be able to google her
11:14:32 <haskell467> can someone tell me if it´s possible to implement a sudoku game (not solver) with user interactions in haskell? or has anyone a source for an implementation?
11:14:34 <Denommus> SwashBuckla: hm, that doesn't... make a lot of sense
11:14:45 <Denommus> SwashBuckla: Haskell doesn't have variadic functions
11:14:47 * hackagebot aws-kinesis-client 0.4.0.0 - A producer & consumer client library for AWS Kinesis  http://hackage.haskell.org/package/aws-kinesis-client-0.4.0.0 (JonSterling)
11:14:55 <arkeet> Denommus: it sort of does!
11:15:00 <Denommus> SwashBuckla: how would you apply an arbitrary number of times?
11:15:16 <arkeet> haskell467: yes, it is possible.
11:15:20 <Denommus> arkeet: yes, you can use lists instead of variadic functions - but then you just need to use some sort of takeWhile
11:15:21 <SwashBuckla> haskell467: certainly :)
11:15:34 <arkeet> Denommus: no, you can do variadic functions with some typeclass hackery.
11:15:37 <arkeet> a la Text.Printf
11:15:49 <SwashBuckla> there probably is an implementation out there, too
11:15:50 <Denommus> arkeet: ah, that's true
11:15:53 <haskell467> @SwashBuckla @arkeet but how do i start? 
11:15:53 <lambdabot> Unknown command, try @list
11:16:07 <Denommus> haskell467: don't use @ to mention someone
11:16:19 <haskell467> Denommus thanks :)
11:16:33 <haskell467>  SwashBuckla arkeet but how do i start?
11:16:44 <SwashBuckla> haskell467: that question is quite vague. Could you elaborate?
11:16:53 <arkeet> think about how your program should work.
11:16:55 <arkeet> and then write it.
11:17:05 <hiptobecubic> haskell467, I'd start by decided what kinds of things you want to be able to do, then figuring out a datastructure for holding a 'sudoku game' and associated data
11:17:16 <hiptobecubic> then write a function to visualize that somehow so you have some hope of debugging
11:17:18 <NemesisD> ugh. hackage is being dumb. i've got a flag lib-Werror that defaults False, manual True that enables -Werror and hackage is rejecting the package on the grounds of Werror. i've seen other packages do this .what gives?
11:17:23 <haskell467> SwashBuckla I´m kind of new to haskell but have experience in java, c#
11:17:49 <Denommus> haskell467: imagine your program as a function from the input (the current state of the table plus the user input) to the output (the new state of the table)
11:18:17 <Denommus> haskell467: or you can look into FRP to make it real time
11:18:43 <Denommus> haskell467: like reactive-banana if you're going to use a GUI library like gtk, or netwire if you're going to use something like SDL
11:19:11 <haskell467> Denommus it just need to be a super simple one. I was searching on google for an example solution I could use but without any luck, only found solver
11:19:47 * hackagebot conversion-bytestring 1.0.0.1 - "Conversion" instances for the "bytestring" library  http://hackage.haskell.org/package/conversion-bytestring-1.0.0.1 (NikitaVolkov)
11:19:50 <arkeet> if only I could always google for an example code for the problem I am trying to solve in the language of my choice.
11:20:21 <hiptobecubic> haskell467, yeah I wouldn't look at FRP just yet :)   I would write a function to take a sudoku board, a coordinate, and a value, and return a new board with that filled in or an error. Then wrap that in a loop.
11:20:32 <Denommus> haskell467: you can make a terminal program that outputs the current state of the table, the user inputs three numbers (x and y coordinates and inputed number), then a new table is generated and printed
11:21:19 <haskell467> arkeet it´s only for learning how haskell works to write my own solution
11:21:37 <arkeet> maybe you should read some general learning haskell material?
11:21:40 <arkeet> @where learnhaskell
11:21:40 <lambdabot> https://github.com/bitemyapp/learnhaskell
11:21:44 <Denommus> haskell467: after you do that, you may think on how to generate a new table
11:21:48 <haskell467> Denommus that´s actually a good idea :O thnaks
11:22:14 <Denommus> haskell467: a new BLANK table, I mean
11:22:43 <Denommus> haskell467: I also suggest you to make "0" mean "empty"
11:23:02 <arkeet> if you are writing an interactive sudoku game, you will need more state than that.
11:23:24 <arkeet> e.g. which cells are the unmodifiable starting cells?
11:23:26 <haskell467> Denommus why 0 mean empty? is there something i have to consider when using"0"?
11:23:32 <arkeet> I wouldn't use 0 for empty.
11:24:15 <Denommus> arkeet: it's simpler than using a Maybe
11:24:23 <arkeet> it's also wrong.
11:24:25 <arkeet> :p
11:24:29 <Denommus> there isn't 0 in Sudoku anyway
11:24:48 <haskell467> but there is an empty field in sudoku
11:25:03 <Denommus> ok, then use Maybe Int :-P
11:25:04 <arkeet> this is haskell. you should use an ADT.
11:25:08 <Denommus> it was just a suggestion
11:25:44 <arkeet> special-casing some digit for this purpose is the kind of thing you do in languages that don't have sum types.
11:25:59 <arkeet> it's not a bad way to expose yourself to bugs, either.
11:26:47 <Denommus> arkeet: that's fair
11:31:30 <haskell467> Denommus But what if I print out a sudoku like that: 9,A2,6,5,A5,7,A7,A8,A9; B1,B2,2,B4,B5,B6,4,B8,9; etc. and the user wants to set a number for A2? Can my program hold the correct number for each variable and tell the user if his input was correct? Or am I thinking too complicated? 
11:32:25 <nomeata> What is the policy of uploading build fixes to other people's packages?
11:32:42 <c_wraith> nomeata: it's pretty difficult these days unless you're a hackage trustee. :P
11:32:53 <nomeata> I’d like to update SDL with the quite trivial ghc-7.8 compatibility patch that Debian also uses.
11:33:04 <nomeata> Ok, where is the next trustee?
11:34:01 <nomeata> c_wraith: I think you are wrong: Trustees cannot upload new versions of packages, only maintainers can do this. 
11:35:29 <nomeata> lemmih: Ah, you are David. I was confused by nicknames and real names.
11:36:03 <nomeata> lemmih: would you mind uploading a new version of SDL that works with GHC-7.8? The patch is simple: http://anonscm.debian.org/darcs/pkg-haskell/haskell-sdl/patches/ghc-7.8-compat
11:43:35 <SrPx> is there any obvious way to implement the "show" instance for list? Anything I can think of is either ugly or wrong (includes an additional "," on the end)
11:45:39 <quchen> SrPx: Use intercalate ", "
11:45:51 <quchen> > intercalate ", " ["hello" "world"]
11:45:53 <lambdabot>      Couldn't match expected type ‘[Char] -> [Char]’
11:45:53 <lambdabot>                  with actual type ‘[Char]’
11:45:53 <lambdabot>      The function ‘"hello"’ is applied to one argument,
11:45:59 <quchen> ಠ_ಠ 
11:46:13 <quchen> > intercalate ", " ["hello", "world"]
11:46:14 <lambdabot>  "hello, world"
11:46:37 <geekosaur> lisper :p
11:47:34 <quchen> Pfff
11:55:48 <lifter> ghci
11:59:49 * hackagebot list-t 0.4.5.1 - ListT done right  http://hackage.haskell.org/package/list-t-0.4.5.1 (NikitaVolkov)
12:01:00 <xekmafcert> Hi. I'm playing with lenses for the first time. Right now I'm trying to figure out if there is a lens or something that could take me from (a, [b]) to [(a,b)]
12:02:15 <lifter> xekmafcert: You can always roll your own
12:02:48 <SrPx> using haskell-chart with the cairo backend doesn't work here since cairo is broken here and I can't fix it... is there any alternative?
12:02:57 <xekmafcert> lifter: the thought has occurred to me, but I have no idea where I'd even start. I'm so new to lens.
12:03:29 <edwardk> xekmafcert: my first question is, can it pass the laws?
12:04:38 <xekmafcert> edwardk: I'm not sure. I don't know whether it's a lens or a traversal or what. Maybe it's an iso, because I want it to convert between two representations?
12:04:41 <P4Titan> Hello all, I want to have a Map as a lookup from some data. Would it be good practice to make a function that takes no args and returns the desired map. The only issue is that does a new map get created everytime the function execute?
12:05:35 <kadoban> P4Titan: There is no such thing as a function that takes no args.
12:05:38 <frodwith> xekmafcert, how is what you want different from a function?
12:05:44 <sebastianrkg> Is it possible to hide a submodule in cabal files?
12:05:56 <sebastianrkg> I want to use filemanip and Glob, but they both have a System.FilePath.Glob
12:05:56 <quchen> P4Titan: Top-level identifiers are usually cached, and not recalculated on every use. Can you show us your code?
12:06:01 <kadoban> P4Titan: Do you mean having it as a top-level definition or something? In that case, no it won't be created anew every time, it's shared.
12:06:06 <P4Titan> kadoban: Well, what is this: fn :: Int
12:06:08 <sebastianrkg> however I only need one for one cabal package, and the other for the other, it's only in the top-level sandbox for my project that they conflict
12:06:12 <lifter> xekmafcert: You can use the "lens" function to make your own lens
12:06:37 <kadoban> P4Titan: An Int :) also a definition, a value, and possibly a top-level definition.
12:07:40 <P4Titan> I haven't written code, but I will be using the fromList function to make a Map, which has a complexity of nlog(n), I don't want that to be executed every call.
12:08:08 <lifter> xekmafcert: Also FYI there is a #haskell-lens channel, I've gotten a lot of help there :)
12:08:22 <xekmafcert> lifter: Hey, that's cool. Thanks.
12:08:29 <latk> are there any guides showing how to use opaleye with record types ? As in, generating queries etc.
12:08:46 <kadoban> P4Titan: That should be fine. It'll be shared/cached/whatever.
12:08:58 <P4Titan> OK
12:09:03 <P4Titan> Thanks
12:09:07 <EvanR-> P4Titan: a lot of operations involving rebuilding a Map each time would be faster just using the list
12:09:20 <lifter> xekmafcert: This tutorial is quite good and it shows how to use the aforementioned "lens" function: http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html
12:09:21 <EvanR-> n vs n log n
12:09:32 <P4Titan> EvanR: I want the map to be created once though
12:09:39 <EvanR-> makes sense
12:09:40 <P4Titan> not on every function call
12:09:57 <EvanR-> the list is a constant?
12:10:13 <P4Titan> It is pre-programmed
12:10:20 <P4Titan> manually
12:10:21 <EvanR-> you can make it a top level value
12:10:29 <P4Titan> How, what does that mean?
12:10:30 <EvanR-> or if its from a file, pass it in
12:10:45 <P4Titan> What is a top level value?
12:10:51 <EvanR-> x :: X
12:10:56 <EvanR-> x = whatever
12:11:02 <P4Titan> Basically, like a global variable
12:11:11 <kadoban> P4Titan: Just a value defined anywhere but in a 'where' block or 'let'
12:11:13 <EvanR-> not a global mutable variable
12:11:13 <lifter> P4Titan: right
12:11:23 <P4Titan> Yes, that is what I was planning on doing
12:11:35 <P4Titan> It is immutable por supuesto.
12:11:47 <EvanR-> its not rebindable
12:11:58 <P4Titan> Yes
12:12:11 <P4Titan> Thanks
12:14:13 <hexagoxel> sebastianrkg: what error do you get?
12:16:29 <sebastianrkg> hexagoxel Ambiguous module name ‘System.FilePath.Glob’:
12:16:30 <sebastianrkg> it was found in multiple packages: filemanip-0.3.6.3 Glob-0.7.5
12:16:32 <Cale> P4Titan: A function which takes no arguments is not a function at all :)
12:16:57 <Cale> (Possibly other people already said that, I haven't read the entire backlog yet :)
12:16:58 <P4Titan> Cale: I call it like that, it has the same syntactical look as a function
12:17:14 <EvanR-> i dont think so
12:17:17 <P4Titan> It was not really about non-argumental functions, but, yeah ...
12:17:33 <P4Titan> EvanR: why?
12:17:38 <EvanR-> a function type has a -> in it
12:17:39 <quchen> Cale: Doesn't context matter here? A CAF is pretty similar to a function on () after all
12:17:53 <hexagoxel> sebastianrkg: when installing one of the packages that only depend on one of {Glob, filemanip} ?
12:17:54 <EvanR-> a CAF isnt like a function
12:18:01 <Cale> P4Titan: So long as the type of the Map isn't type class polymorphic, it will be evaluated at most once.
12:18:20 <P4Titan> What do you mean polymorphic?
12:18:33 * shapr polymorphs into a highly paid programmer
12:18:37 <sebastianrkg> hexagoxel: When installing a package within the larger sandbox that includes both dependencies but only needs one
12:18:38 <EvanR-> Show a => Map X (a,a)
12:18:48 <Cale> P4Titan: I mean if you give your Map a type signature like   foo :: Num a => Map String a
12:19:09 <sebastianrkg> hexagoxel These two cabal packages reference each other as dependencies, though, so they cannot be sandboxed independently
12:19:16 <Cale> P4Titan: Then foo will be implemented as a function of the type class dictionary for Num a, and so will be recomputed wherever it is used
12:19:18 <P4Titan> Yes, It'll have a concrete type
12:19:51 * hackagebot conversion-text 1.0.0.1 - "Conversion" instances for the "text" library  http://hackage.haskell.org/package/conversion-text-1.0.0.1 (NikitaVolkov)
12:20:00 <hexagoxel> sebastianrkg: "includes both dependencies" as in "has transitive dependency on both, but direct dependency on one"?
12:20:28 <sebastianrkg> My cabal packages A and B reference each other as direct dependencies
12:20:30 <EvanR-> the corresponding thing in haskell of the js or C "function" with no arguments would be a IO X where X is the return type
12:20:36 <sebastianrkg> A needs filemanip, B needs Glob
12:20:57 <Cale> But if it's, say,  foo :: Map String Integer  then you're fine, it'll be computed once. Note that the computation of the keys (which give the internal tree structure) and the values in the Map is separate. Each value will remain computed once it has been used though, so long as the Map remains in scope and there are references to it.
12:21:35 <EvanR-> Cale: i thought top level stuff never gets reclaimed?
12:21:59 <Cale> EvanR-: It should be possible to garbage collect top level stuff if there are no references left to it.
12:22:04 <hexagoxel> sebastianrkg: uhh how does that even work? i thought cycles in package dependencies are not possible..
12:22:11 <EvanR-> that makes sense but
12:22:24 <sebastianrkg> hexagoxel: actually sorry, A references B as a dependency, not B to A
12:22:37 <sebastianrkg> but then yeah, A needs filemanip, B needs Glob
12:22:44 <EvanR-> whether it is or not is a critical thing to know in real life
12:23:23 <EvanR-> for example if the CAF is an infinite list you are consuming
12:23:29 <Cale> EvanR-: Somewhat critical. Usually if you define something global like that, you tend to use it from a lot of places and it pretty much has to remain in memory.
12:23:55 <Cale> EvanR-: but yeah, if you have an infinite list which you're consuming at exactly one place, it should get GCed as you consume it
12:24:12 <EvanR-> uhg i had someone say the opposite 
12:24:20 <EvanR-> need to somehow check
12:24:34 <Cale> Should be really really easy to check
12:24:44 <Cale> numbers = [1..]
12:24:47 <Cale> main = print numbers
12:25:12 <Cale> If GC doesn't happen, that'll leak memory like crazy
12:27:06 <c_wraith> ghc can collect CAFs these days
12:28:03 <EvanR-> memory stats are not moving
12:28:05 <EvanR-> on top
12:31:54 <EvanR> that makes me feel better that was one case i thought it might be easy for people leak memory
12:35:38 <SrPx> nobody? :(
12:36:18 <latk> Is it even possible to e.g. insert something using record types and opaleye ?
12:36:28 <latk> I must be missing something really obvious..
12:38:05 <sebastianrkg> Okay this Michael Snoyman article says that I can use "package imports" to disambiguate between packages with the same name http://www.yesodweb.com/blog/2014/02/module-name-conflicts
12:38:32 <sebastianrkg> unsure what that means
12:38:44 <c_wraith> sebastianrkg: you can, but it's often a sign of a deeper problem in your environment.
12:39:01 <quchen> sebastianrkg: There's a GHC extension that lets you specify which module to take a package from.
12:39:15 <c_wraith> quchen: module <-> package
12:39:19 <quchen> Woops, right.
12:39:41 <quchen> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#idp23944304
12:39:51 <quchen> ^ see there
12:40:19 <sebastianrkg> c_wraith well, I don't think that just wanting to use Glob and filemanip indicates a larger problem with my environment, I have valid reasons for using both
12:40:59 <sebastianrkg> c_wraith, quchen: interesting, quchen, but is this "package imports" a built in way of doing it? If so, would that be better than using an extension?
12:41:21 <EvanR> extensions are all built-in
12:42:03 <sebastianrkg> ah sorry I didn't realize it was just a normal extension like this. Okay, that looks pretty good.
12:42:12 <quchen> sebastianrkg: GHC contains a number of "language extensions" that add additional non-standard capabilities to the language. Some of them are mature, stable, and tested; others are more questionable or of research-y nature.
12:42:13 <sebastianrkg> Is that the best option? I guess it should work
12:42:19 <hexagoxel> sebastianrkg: i cannot reproduce your problem
12:43:08 <hexagoxel> although, maybe i have changed one detail, let me check
12:43:52 <sebastianrkg> I should add that I am importing the specific conflicting module in the smaller package on which the larger package depends.
12:44:05 <sebastianrkg> hexagoxel, I don't think the problem appears otherwise.
12:45:54 <napping> ollef: do you know how Earley compares to GLL?
12:46:22 <latk> How can I make "testInsert" work, in the following? http://lpaste.net/131401
12:46:32 <napping> sebastianrkg: 
12:46:58 <napping> The "problem in your environment" is that those packages used conflicting module names
12:48:41 <sdegutis> Are there any GHC extensions that add metadata such that you can get a reference to a function at runtime based on its fully qualified name as a dynamically created String?
12:49:17 <napping> Maybe in the GHC API?
12:49:57 <napping> I've heard of it used to dynamically load a module, and get at a function in that by name
12:50:42 <sdegutis> Thanks that sounds similar.
12:51:15 <napping> I haven't tried myself, and I have no idea whether it works on functions in your own program
12:54:57 <adnam> =ss----------------------ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss
12:55:24 * EvanR uses watergun on adnam's cat
12:55:33 <napping> Hello kitty
12:55:51 <adnam> bad kitty
12:59:53 <jeffburdges> https://pyos.github.io/dg/   :)
13:03:18 <Denommus> hi
13:05:08 <hexagoxel> sebastianrkg: sorry, i cannot help you; the extension might be a solution.
13:09:53 * hackagebot th-context 0.13 - Test instance context  http://hackage.haskell.org/package/th-context-0.13 (DavidFox)
13:10:07 <SrPx> Suppose that I have a typeclass that is sufficient to define a show instance. That is, any instance of my class can have a show instance. How do I implement it? "instance (MyClass c) => Show c where show x = show . foo" ?
13:10:23 <SrPx> woops, without x
13:11:53 <quchen> You can't add superclasses to existing ones without modifying them.
13:12:05 <quchen> You can manually write Show instances using the functions provided by your superclass, of course.
13:15:12 <SrPx> Hm okay, thank you
13:16:30 <sebastianrkg> hexagoxel, okay, thanks for trying though
13:25:02 <quchen> SrPx: If we could just add superclasses, the AMP would have been really easy, and similarly for Semigroup if that happens
13:26:35 <kadoban> I don't think what he's trying to do is add a superclass. I think he's saying is if 't' is an instance of MyClass, I can write a Show instance for 't' easily. How do I do that?
13:31:21 <glguy> SrPx: You'd write: myClassShow :: MyClass a => a -> String; and then use that to write instances: instance Show MyType where show = myClassShow
13:32:49 <kadoban> Can't you just do it in general, instead of type by type?
13:33:14 <glguy> You can do it in a fragile/broken way with overlapping instances
13:33:37 <kadoban> Ah, right I guess that'd be a problem.
13:33:44 <EvanR-> a lot of times you think oop lets you do stuff "in general" but then you realize its not general at all, and then you leave it in a broken state
13:34:25 <kadoban> OOP? O.o
13:34:44 <EvanR-> making something a super class to do something in general
13:34:54 * hackagebot tokenize 0.3.0 - Simple tokenizer for English text.  http://hackage.haskell.org/package/tokenize-0.3.0 (GrzegorzChrupala)
13:35:36 <slack1256> I know you can interchange a class instance with some record field on a data structure. I also know about church encoding of common ADTs. But how is implemented associated datatypes on ghc?
13:36:02 <MuffettMan> Why did hackagebot just link to tokenize?
13:36:14 <EvanR-> new version was just pushed to hackage
13:36:24 <kadoban> MuffettMan: It announces updates on hackage. It mostly tends to just be annoying, heh.
13:36:52 <MuffettMan> That sounds rather annoying actually
13:37:36 <kadoban> MuffettMan: You can just ignore it or something in most clients. It doesn't do anything else, AFAIK, so you won't be missing anything if you don't want to see them.
13:38:00 <frerich> 'Warning: The package list for 'hackage.haskell.org' is 23.5 days old.' <-- of course, saying '23 days' would to too imprecise. ;-)
13:38:14 <monochrom> :)
13:38:37 <glguy> "Oh, that's right; I updated cabal in the morning 23 days ago"
13:38:38 <MuffettMan> kadoban: Ah okay, I'll go ahead and ignore that then, thanks
13:39:00 <kadoban> lambdabot is where the real fun is :)
13:39:13 <dcoutts> fredsir, glguy: it's ridiculous. I sent in a patch to change it.
13:39:28 <dcoutts> oops, frerich not fredsir 
13:39:58 <glguy> dcoutts: Well, as things go, that one bothers me about the least ^_^
13:40:44 <dcoutts> no silly and small
13:43:57 <Chobbes> I'm going through Parallel and Concurrent Haskell... Is the reason I would only evaluate to WHNF just if I didn't want to force evaluation of the entire structure? It just seems weird when talking about tuples.
13:45:11 <MuffettMan> I'm about to start a new haskell project, I've done one before and in the beginning it was a nightmare, but after the first 20% it was the easiest coding I've done, so I'm wondering how I can make the start less painful? Do you guys start bottom-up, or top-down? I've heard of hole-driven development, looked like some witchcraft at first, is that useful for real projects?
13:45:47 <josephle> hole-driven is basically top-down, right?
13:45:54 <Chobbes> MuffettMan: why did you find the start painful?
13:46:17 <kadoban> MuffettMan: I can't think of a first project I've ever done in a language that wasn't a complete mess. If only the first 20% sucked, you're probably 80% better off than I usually am (for a first project)
13:48:09 <Denommus> :k Alternative
13:48:10 <lambdabot> (* -> *) -> Constraint
13:50:20 <MuffettMan> Chobbes: I think it was partly because I felt I had to know exactly what all the functions below would have to have access to, so it felt like I had to do top-down and bottom-up simultaneously, if that makes any sense. I also struggle to determine a good 'flow' for a haskell program, it ends up as recursive function after recursive function and it gets hard to follow
13:55:28 <bennofs> MuffettMan: I often start sketching out the main functions, leaving undefined everywhere I'm not sure how to implement it yet, while simultaneously creating the required data types
13:56:00 <bennofs> also making data types like data Foo = Foo if I'm not sure about the fields of Foo yet
13:56:42 <bennofs> at then it helps to just write the most obvious and simple and stupid version first, and refactor when it works.
13:57:16 <slack1256> Also thinking of programs as data structures transformations
13:57:17 <slack1256>  
13:58:50 <MuffettMan> bennofs: Thanks, that sounds like a good method, I'll try it out
13:59:02 <MuffettMan> slack1256: Could you elaborate a bit more on what you mean by that?
13:59:55 <rvxi> hi
14:00:02 <rvxi> .join #numerical-haskell
14:01:38 <slack1256> MuffettMan: I think a good example on this style is probably XMonad. It defines a data structure for the problems at hand (managing windows) and operations over it.
14:02:24 <Chobbes> MuffettMan: one thing to keep in mind is that you don't have to be too worried about the arguments to your functions and what you need "way down" the line. It's usually pretty easy to recognize what you will need before hand, and writing down type signatures is a good way to get you thinking in the right direction.
14:02:40 <Chobbes> And if you DO need to change something the type system will help you do that refactoring.
14:03:07 <Chobbes> Much easier to spot where you need to change your function calls when the compiler catches all of them.
14:07:36 <rvxi> hi
14:11:21 <ski> lo rvxi
14:12:37 <sdegutis> The one thing I miss from Clojure is the ability to lookup functions at runtime (even in different namespaces) based on a given String. That's a cool feature I want from Haskell.
14:13:00 <sdegutis> At the same time, I really appreciate Haskell's being static and having all the optimizations that come with that.
14:13:00 <bennofs> sdegutis: what do you need that for? 
14:13:24 <sdegutis> bennofs: for a back-end web API that has an automatic router that maps URLs to Clojure functions automatically.
14:13:46 <bennofs> sdegutis: you can stuff like that with TH at compile time to create a table of functions
14:13:59 <bennofs> (TH = Template Haskell)
14:14:07 <sdegutis> bennofs: that wouldn't be too bad actually
14:14:39 <Adeon> StaticValues extension also gives you something like that
14:14:56 * hackagebot crypto-classical 0.0.3 - An educational tool for studying classical cryptography schemes.  http://hackage.haskell.org/package/crypto-classical-0.0.3 (fosskers)
14:15:27 <Adeon> but haskell being rather static the dynamic experience of being able to look up anything dynamically is not as smooth
14:15:32 <Adeon> but you can do it
14:18:57 <rvxi> hi ski
14:19:48 <slack1256> sdegutis: How is that experience on clojure? is it something else of what haskell-mode on emacs does?
14:20:42 <Denommus> I'm... confused regarding the Applicative instance of a Wire in Netwire
14:21:17 <Denommus> http://hackage.haskell.org/package/netwire-5.0.1/docs/src/Control-Wire-Core.html#Wire
14:21:32 <Denommus> wouldn't wf <*> wx create an infinite recursion?
14:23:55 <sdegutis> slack1256: not sure I understand your question
14:25:01 <slack1256> sdegutis: It's OK, it's badly formulated. I need to watch videos on clojure development to understand what are you looking for. And see if we have an equivalent on haskell
14:25:37 <sdegutis> slack1256: it's not really Clojure-specific
14:26:20 <sdegutis> slack1256: the general principle is that if you have a file at foo/bar/quux.hs containing a function called wibble, I want to be able to get that function as a value given the string "foo.bar.quux/wibble" or something similar.
14:30:05 <slack1256> Oh, so would you like to do something, for example type 'Data.List.len<tab>' and get rest of the function name?
14:31:33 <Adeon> I think sdegutis is talking about behaviour in a program that is running, not editing
14:31:37 <Adeon> sdegutis: am I right?
14:32:52 <slack1256> Oohh
14:32:52 <slack1256>  
14:33:16 <sdegutis> Adeon: yes
14:33:26 <slack1256> That indeed would be awesome
14:33:38 <Adeon> and the answer is that you can do that but it's not a beautiful, smooth experience
14:34:54 <Adeon> GHC API can load code at runtime and you can use it like a normal package
14:35:13 <Adeon> but IIRC it's not as simple as "loadFunction :: String -> Function pointer thing"
14:35:22 <Adeon> there may be packages on hackage that give you something close to that
14:35:26 <Adeon> I haven't checked
14:35:40 <slack1256> @where hint
14:35:40 <lambdabot> I know nothing about hint.
14:35:46 <slack1256> @hackage hint
14:35:46 <lambdabot> http://hackage.haskell.org/package/hint
14:35:58 <slack1256> does something of the sort.
14:36:09 <Adeon> ah, that looks like a nice package
14:36:13 <slack1256> but yeah, not as pleasant as what is described here
14:37:24 <sdegutis> Well even if I have to make a map of String -> Fn, that's not toooo bad.
14:37:53 <Adeon> check out the StaticValues extension if you are thinking of making a map like that
14:38:02 <Adeon> that extension can create a table behind the scenes for you
14:38:15 <Adeon> but with a slightly different API that may or may not suit you
14:38:30 <Adeon> that extension came in GHC 7.10 so you need bleeding edge
14:38:48 <Adeon> er
14:38:50 <Adeon> StaticPointers
14:39:37 <slack1256> Static Values does exist though (cloud haskell thingy)
14:39:58 <Adeon> yeah, I think StaticPointers was precisely motivated for cloud haskell purposes
14:40:25 <Adeon> I use cloud haskell for some of my projects and it's little annoying to TH everything but manageable
14:45:44 <dst1> Hi guys... is there some trick to make "hpc report XXX.tix" deal with cabal sandbox?? 
14:45:51 <dst1> This is what I get..
14:45:54 <dst1> $ hpc report dist/hpc/vanilla/tix/tests/tests.tix --exclude=CoreTests --exclude=Main
14:46:06 <geekosaur> cabal exec?
14:46:06 <dst1> hpc: can not find paizo_I20xwLmKhX98FICmL337xo/Paizo.Core.Player in ["./.hpc"]
14:46:12 <dst1> Any help would be appreciate! Thank you guys!
14:46:17 <dcoutts> dst1: cabal test itself has some support for using hpc
14:47:03 <hpc>  hey, i can find it if i want to
14:47:15 <dst1> of course.. but I would like to get in text mode the same result through "hpc report"
14:47:18 <hpc> ;)
14:47:29 <dst1> To avoid opening browser with results..
14:48:24 <dst1> Everything works fine when I use "cabal test"... it generates tix file and html files.. the only thing missing is the coverage report through console
14:48:37 <dst1> But I fail using hpc report..
14:48:49 <dcoutts> dst1: I think it puts the generated files in somewhere other than .hpc/
14:49:01 <dcoutts> so you might need an extra flag to tell hpc where to look
14:49:13 <michaelchurch> Can I do a quick community poll here? It pertains to web offerings and frameworks.
14:49:58 * hackagebot wreq-sb 0.4.0.0 - An easy-to-use HTTP client library.  http://hackage.haskell.org/package/wreq-sb-0.4.0.0 (sestrella)
14:50:07 <levi> Not sure this is really a representative group. And might not be a great time of day for a representative sampling of the channel, either.
14:50:23 <michaelchurch> I'm (partially, meaning that if 5 people are FT Haskell by mid-2016 I'll call it a success) Haskellizing a company that has a lot of Ruby developers. 
14:50:27 <dst1> yes.. all files are generated at dist folder.. 
14:50:27 <dst1> The problem comes when command tries to find libraries..
14:50:27 <dst1> $ hpc report dist/hpc/vanilla/tix/tests/tests.tix --exclude=CoreTests --exclude=Main
14:50:27 <dst1> hpc: can not find paizo_I20xwLmKhX98FICmL337xo/Paizo.Core.Player in ["./.hpc"]
14:50:36 <michaelchurch> levi: that's fine. Just some opinions and useful data would be a starting point.
14:50:36 <dst1> the module missing is present at: src/Paizo/Core/Player.hs
14:50:38 <arkeet> you can try asking on reddit too
14:51:32 <michaelchurch> The question is: which is most likely to be most accessible to someone who's new to Haskell but familiar with Ruby/Rails? (1) Yesod. (2) Snap. (3) Happstack. (4) Scotty. (5) "Bare metal" / no framework.
14:52:02 <levi> Hrm.
14:53:49 <dst1> michael, as a ruby developer I would recommend scotty... a ruby developer would appreciate the sinatra taste :)
14:54:04 <michaelchurch> dst1: Thanks. Any experience with the others?
14:54:07 <levi> In some ways Yesod is the most Rails-like.
14:54:31 <dcoutts> michaelchurch: yesod is more of a rails-like framework; snap and happstack are more like modular collections of libraries you can use together. scotty is dead simple.
14:54:33 <SrPx> How can I connect a type signature inside a function to a type variable outisde it? i.e., "foo :: a → a; foo = do { let listOfA = ... :: [a]; ... }" ? Notice the [a] inside must match the "a" outside
14:54:39 <bennofs> michaelchurch: Snap uses lenses (at least if you use snaplets), so it might not be the best for a beginner
14:54:48 <arkeet> related http://www.reddit.com/r/haskell/comments/332s1k/what_haskell_web_framework_do_you_use_and_why/
14:54:58 * hackagebot snaplet-postgresql-simple 0.6.0.2 - postgresql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-postgresql-simple-0.6.0.2 (DougBeardsley)
14:54:59 <dcoutts> SrPx: with the ScopedTypeVariables extension and forall.
14:55:13 <SrPx> that's what I thought but I still get teh error after adding forall a :(
14:55:14 <dcoutts> foo :: forall a. a -> a; ...
14:55:34 <SrPx> oh. nevermind
14:55:39 <michaelchurch> bennofs: my finding is that Lenses aren't hard to use... it's the type sigs that are not so newb-friendly
14:55:51 <SrPx> I was getting the error for another function /stupid
14:56:09 <bennofs> michaelchurch: yes, that's true. yesod also uses a lot of TH so error messages are probably not much better :|
14:56:39 <SrPx> (thank you)
14:56:41 <dcoutts> michaelchurch: and tbh, if you're doing a rest-like api rather than a html web site, you hardly need much of these frameworks anyway
14:56:42 <michaelchurch> bennofs: Yeah. That could very easily get me stuck maintaining everything. :)
14:56:47 <levi> Yesod comes with a bunch of scaffolding and ORM/Template/Routing DSLs, which are the basic things someone coming from Rails might expect. And someone coming from Rails is probably used to dealing with magic stuff that they don't necessarily understand how it works.
14:57:20 <michaelchurch> levi: I feel like frameworks serve the same purpose as college courses. you learn one to have the confidence that you "know web". :)
14:58:01 <dmj`> dcoutts: so true, I just use snap-core + snap-server now, way lighter
14:58:02 <slack1256> :O
14:58:22 <glguy> dmj`: I'm with you on that
14:59:28 <dcoutts> dmj`: right, and we've got clients with rest apps that are using a tiny bit of wai. Most real projects end up with so much of their own custom framework for various reasons
15:01:31 <webchat041> there was a time when functional programmers wanted to program web applications functionally
15:02:03 <dmj`> dcoutts: yea, exactly. Big fan of not depending on things you don't need. 
15:02:11 <webchat041> now they just copy things from other languages
15:03:15 <michaelchurch> webchat041: Interesting observation. What specific examples do you have in mind?
15:03:59 <michaelchurch> webchat041: I'm a total newb in this space but I generally do like the idea of a web service as being "as close to" a function at possible.
15:04:04 <michaelchurch> It seems like the right way to do things.
15:04:12 <SwashBuckla> can anyone recommend some good games written in Haskell? I have found Nikki and the Robots which is quite polished, but I can't get it to compile as it was written a while ago (when Maybe was not in Data, and Random not in System, for example) so requires a few edits
15:04:58 * hackagebot al 0.1.3 - OpenAL 1.1 raw API.  http://hackage.haskell.org/package/al-0.1.3 (DimitriSabadie)
15:05:14 <webchat041> When I was learning Haskell in the year 2005 there were continuation-based frameworks
15:06:21 <webchat041> all functional languages used continuation frameworks. Now scarcely any haskeller know about it
15:07:00 <michaelchurch> webchat041: what are the advantages of a continuation-based framework? (This is the first time I've heard the term.)
15:07:04 <MuffettMan> Hey guys, I'm just trying to get ghc-mod to work on my system, and I can't seem to get it, and at this point I fear I've messed up my installation somehow. Does anyone know what versions of ghc and cabal-install ghc-mod needs? And what I can do to completely wipe ghc/cabal/haskell/etc from my system so I can start clean?
15:07:23 <michaelchurch> (BTW, I'm not asking the ? to be confrontational. I just don't know about it and I'm very curious. It sounds like a cool idea.)
15:07:43 <monochrom> continuation-based frameworks live today as monadic frameworks, i.e., in "a >>= b", b is clearly a continuation.
15:07:59 <webchat041> michaelchurch:  for example a continuation-based framework express a navigation in a monadic expression
15:08:06 <michaelchurch> I've been doing machine learning and back-end R&D for most of my life so I don't know as much as I should about "real" website programming.
15:08:21 <hiptobecubic> michaelchurch, "real" is pretty subjective
15:08:39 <hiptobecubic> Most websites would not be very interesting without their backends :)
15:09:12 <enthropy> quite possibly webchat041 is refering to http://www2.informatik.uni-freiburg.de/~thiemann/WASH/
15:09:36 <PhysoniumI> Google without a backend would be so great :P
15:09:56 <bennofs> it should a bit like mflow
15:10:03 <bennofs> @hackage MFlow
15:10:03 <lambdabot> http://hackage.haskell.org/package/MFlow
15:10:24 <bennofs> sounds*
15:13:42 <SrPx> Is it possible to have a value in a typeclass that doesn't mention any of the type variables?
15:13:55 <bennofs> SrPx: no
15:14:00 <SrPx> :( ok
15:14:04 <webchat041> enthropy:  yes
15:14:24 <bennofs> SrPx: how would the compile pick the instance to use for such a method?
15:15:09 <ski> @let class Foo where foo :: Int
15:15:09 <lambdabot>  Defined.
15:15:22 <ski> @let instance Foo where foo = 42
15:15:23 <lambdabot>  Defined.
15:15:27 <ski> @type foo
15:15:28 <lambdabot> Int
15:15:29 <ski> > foo
15:15:30 <lambdabot>  42
15:15:43 <SrPx> bennofs: from the other values I guess...
15:15:52 <michaelchurch> So this is a 0-parameter type class?
15:16:02 <michaelchurch> I've never seen that before. 
15:16:10 <ski> @undefine
15:16:10 <lambdabot> Undefined.
15:16:13 <ski> @let class Foo where foo :: Int
15:16:14 <lambdabot>  Defined.
15:16:16 <ski> @type foo
15:16:17 <lambdabot>     No instance for Foo arising from a use of ‘foo’
15:16:17 <lambdabot>     Possible fix:
15:16:17 <lambdabot>       add Foo to the context of the inferred type of it :: Int
15:16:21 <ski> @type foo :: Foo => Int
15:16:22 <lambdabot>     No instance for Foo arising from an expression type signature
15:16:22 <lambdabot>     Possible fix:
15:16:22 <lambdabot>       add Foo to the context of the inferred type of it :: Int
15:16:24 <ski> interesting
15:16:50 <michaelchurch> This feels dangerously close to Scala's Implicit Hell
15:17:03 <ski> there can be at most one instance of `Foo'
15:17:03 <michaelchurch> -XNullaryTypeClasses... a magic spell?
15:17:19 <michaelchurch> True. So that is good.
15:19:04 <f|`-`|f> What is "REST"
15:19:46 <enthropy> without that extension I think you can get the same result from "class Foo a where foo_ :: a -> Int; instance Foo a where foo_ = const 42; foo = foo_ ()"
15:19:57 <ReinH> f|`-`|f: http://en.wikipedia.org/wiki/Representational_state_transfer
15:21:13 <hiptobecubic> i'm a little confused about mflow. If it does the things it says it does, I would have expected *someone* to use it for something by now
15:21:23 <hiptobecubic> instead it looks pretty much abandoned
15:24:33 <f|`-`|f> Welcome to FL's
15:25:01 <f|`-`|f> It's like being a esolang enthusiast
15:27:28 <sdegutis> Is 'newtype' often used to add additional type checking to configuration options?
15:27:53 <sdegutis> That seems like a decent technique, but I'd be more comfortable going that route if it's commonly used.
15:28:49 <michaelchurch> sdegutis: it's a separate type that is identical at runtime.
15:29:08 <michaelchurch> sdegutis: ergo zero runtime performance cost
15:29:18 <augur> how can i convert a Ratio to a decimal representation?
15:32:01 <SwashBuckla> what is going wrong here? http://lpaste.net/7337669123742105600
15:32:17 <SwashBuckla> I am trying to do a cabal install of a package
15:32:23 <MuffettMan> eitherFromRational, from the decimal module?
15:33:56 <augur> ahh, got something
15:38:13 <EvanR-> augur: realToFrac converts fractional types, show produces decimal string
15:38:24 <EvanR-> in practice
15:40:04 <oconnore> is there a better queue library vs. `dequeue' out there?
15:40:42 <oconnore> better meaning -- compiles on 7.10, or has a public version control repo where I can submit patches?
15:42:06 * mjrosenb wants to do something that I suspect is impossible.
15:43:00 * mjrosenb has a record, data Widget t = Widget {visible :: Behavior t Bool, other...}
15:43:14 <mjrosenb> and a value of this type
15:43:26 <mjrosenb> and I want to update the visible field
15:43:45 <mjrosenb> *but* the other fields of widget hold references to the original widget.
15:44:34 <ski>   oldWidget {visible = newVisible}  -- ?
15:45:09 <arkeet> so your widget holds a reference to itself?
15:46:39 <mjrosenb> arkeet: yes.
15:46:52 <EvanR-> mjrosenb: you can do it with a closure
15:47:02 <mjrosenb> EvanR-: how?
15:47:17 * ski isn't clear yet on what mjrosenb want
15:47:18 <EvanR-> the widget ctor has a fixed point
15:47:33 <EvanR-> if you pass it into itself
15:48:11 <mjrosenb> so I have w1 = Widget {visible = (pure true), paint = doPaint w1 }
15:49:02 <mjrosenb> now I want to create w2, which has visible = foo && pure Ture, but is otherwise the same as w1.
15:49:05 <arkeet> does paint have to hold a reference to your widget? why can't it just be a function that takes a widget?
15:49:22 <EvanR-> w1 = mkWidget (pure True)
15:49:25 <mjrosenb> arkeet: it does hold a reference.
15:49:31 <arkeet> I know it does.
15:49:37 <arkeet> but does it need to?
15:49:41 <mjrosenb> arkeet: yes.
15:49:58 <arkeet> "why can't it just be a function that takes a widget?"
15:50:51 <Marshall> Hey guys. Maybe this is a weird place to ask, but I find this to be a very friendly channel. I'm having girl issues right now. I'm wondering, do you guys find that coding cures a broken hearth? Or at least dampens the pain?
15:51:18 <EvanR-> #haskell-blah
15:51:21 <arkeet> Marshall: maybe you're looking for #haskell-blah 
15:51:31 <Marshall> Thank you!
15:52:13 <EvanR-> mjrosenb: by ctor i was talking about a function to return a Widget but not literally Widget the data constructor
15:52:15 <mjrosenb> arkeet: mostly because every field would need to take a function
15:52:53 <EvanR-> that function can refer to the widget it is constructing to build the fields
15:52:55 <oconnore> where do I send patches for hackage packages that list no way to contact the author?
15:52:59 <mjrosenb> also, I didn't care for passing the widget in twice *everywhere*
15:53:03 <arkeet> oconnore: which package?
15:53:25 <oconnore> arkeet: oh, I guess I could email him, it's dequeue
15:53:35 <oconnore> i'm used to github pages being the preferred channel
15:54:21 <arkeet> I want to say that there is a replacement, but I can't find one immediately.
15:54:25 <arkeet> heh
15:54:26 <SwashBuckla> any ideas as to what is going wrong here? http://lpaste.net/7337669123742105600
15:54:46 <oconnore> arkeet: yeah... i looked too
15:54:52 <SrPx> How do I add type constraints to a value with scoped variables? "foo :: forall a . (Show a) => ManyFunctions; foo = ManyFunctions ...; where someFunc :: (Show a) => a → ...". Notice that the "a" of someFunc is the same "a" from "foo", but I want that one to be further refined as to need the Show instance (but not the others). How?
15:54:53 <SwashBuckla> this is just from running cabal install --only-dependencies
15:55:43 <Pamelloes> Are there any Haskell compilers written in Haskell?
15:56:03 <EvanR-> mjrosenb: not twice
15:56:13 <SrPx> "foo :: forall a ...; foo = ... where bar :: (Show a) => a ..." <- that might be better... how do I add that (Show a) there, since "a" is actually the "a" above (that doesn't need show)... hm
15:56:18 <kadoban> Pamelloes: IIUC GHC is almost completely haskell
15:56:33 <EvanR-> and not everywhere
15:56:49 <mjrosenb> EvanR-: that was in respone to arkeet, not your suggesion, which I am stil trying to figure out.
15:56:50 <geekosaur> Pamelloes: most of them? ghc is written in itself (the first version was written in Lazy ML), jhc and I think uhc are written in ghc
15:57:17 <Pamelloes> Interesting, that's exactly what I wanted to know.
15:57:33 <geekosaur> hugs was written in C but was not a compiler and has not been actively developed since the early 2000s or thenabouts (minimally patched in 2006 to continue to build, IIRC)
15:58:01 <Pamelloes> Where is the source for GHC hosted (if it is hosted somewhere)?
15:59:03 <EvanR> mjrosenb: http://lpaste.net/131403
15:59:03 <ski> SrPx : seems to work here ..
15:59:14 <geekosaur> https://git.haskell.org/ghc.git
15:59:32 <geekosaur> I think there's a mirror on github
15:59:45 <Pamelloes> Thanks :)
16:00:23 <ski> SrPx : you probably have to tell more details about what you're doing, and what doesn't seem to work
16:01:28 <SrPx> :( okay, this is the code: http://lpaste.net/131404
16:01:55 <SrPx> ski: I can't understand what GHC is trying to say with "add (Hashable a1) to the context of         a type expected by the context: (a1 -> b1) -> a1 -> b1         or the type signature for hashedIntList :: IntList Hashed"
16:04:38 <ski> SrPx : as written, this can't possibly work
16:04:59 <ski> you have `memo :: forall a b . (a -> b) -> a -> b', which promises to work for *any* `a' and `b' whatsoever
16:05:37 <ski> otoh `memoize :: forall a b . (Hashable a, Eq a) => (a -> b) -> a -> b' only works for some such `a' and `b', and so can't fit in there
16:05:57 <SrPx> ah I see!
16:06:06 <SrPx> ski: oh I guess I can just move "memo" out of IntList and add it as an argument to functions that could use it :)~
16:07:20 <ski> SrPx : i suppose it would be possible to make the constraint a parameter of `IntList', if you really wanted to
16:07:36 <SrPx> How?
16:08:32 <ski>   data IntList con list = MkIntList {nil :: list,...,memo :: forall a b. con a => (a -> b) -> (a -> b)}
16:08:35 <ski> something like that
16:11:42 <ski> i suppose you might need to do something like
16:11:58 <ski>   class (Hashable a,Eq a) => HashableAndEq a
16:12:08 <ski>   instance (Hashable a,Eq a) => HashableAndEq a
16:12:25 <ski>   class Trivial a
16:12:30 <ski>   instance Trivial a
16:12:37 <ski> and then you should (i think) be able to say
16:12:47 <ski>   hashedIntList :: forall a b. IntList HashableAndEq Hashed
16:12:48 <ski> and
16:13:00 <ski>   normalIntList :: IntList Trivial NormalIntList
16:13:16 <ski> (er, s/forall a b.//)
16:14:07 <ski> SrPx : so the extra argument to `IntList' will tell what constraints the `memo' field can expect on its `a' parameter
16:16:10 <ski> (if you do `type HashableAndEq a = (Hashable a,Eq a)', then you can't say `hashedIntList :: IntList HashableAndEq Hashed', which is why i manually bundled them together with a new class above)
16:17:39 <SrPx> oh my...
16:17:59 <SrPx> why I asked... thank you
16:18:09 <SrPx> not for me yet, I guess
16:19:54 <ski> SrPx : quite possibly it's not what you want here (i dunno). i was just mentioning the possibility
16:20:25 <SrPx> I know, thank you ! It is just that kind of type hackery is still a little scary to me.
16:21:53 <ski> anyway, as you say, if the type of `memo' doesn't mention `list', it's not clear (to me) why it should be a field here ..
16:23:40 <ski> SrPx : imho, the only nontrivial thing about it was having to bundle `Hashable' and `Eq' into a single class, and having to invent a vacuous class to use in the case where we don't really want to impose any restrictions on what `a's can be passed to `memo'
16:24:37 <ski> other than that, it's just factoring out the differing things in `memoize :: forall a b. (Hashable a,Eq a) => (a -> b) -> (a -> b)' vs. `id :: forall a b. (a -> b) -> (a -> b)')
16:25:32 <SrPx> there is probably a better solution for this but the point is that I wanted to write functions to two list-like types implemented completely differently
16:25:54 * ski nods
16:26:07 <SrPx> so I made a typeclass defining "nil", "cons" and "caseOf" ... there was only one issue, I wanted the functions for one of the types to be memoized, but not for the other (since that'd be impossible anyway)
16:26:40 <ski> perhaps you could have some more specific type for `memo' in that case ..
16:27:06 <SrPx> so I thought about throwing a "memo" value on the typeclass and set "memo = memoFix" in one and "memo = fix" on the other, something like that ... dunno
16:27:36 <SrPx> but I guess just having "memo" as an argument of the functions solves it
16:28:00 <ski> (except you have an explicit dictionary of methods in the paste, not a type class)
16:28:21 <SrPx> ah I switched to that because I thought it would help :(
16:28:48 <ski> if you're passing `memo' as an argument, you might need rank-2 types
16:29:06 <ski>   blah :: (forall a b. (a -> b) -> (a -> b)) -> ...
16:29:23 <ski> requires `{-# LANGUAGE Rank2Types #-}' at the top of your source file
16:32:29 <SrPx> Ah okay, thank you!
16:34:05 <ski> SrPx : if you're only using the `memo' argument monomorphically inside `blah', then you don't need this, though
16:34:18 <ski> (and then you wouldn't have the `forall' there in the type signature)
16:35:02 <ski> if you really have something like
16:35:25 <ski>   blah :: (forall a b. (a -> b) -> (a -> b)) -> [a] -> [a]
16:35:41 <ski> which really means
16:35:46 <ski>   blah :: (forall a b. (a -> b) -> (a -> b)) -> (forall a. [a] -> [a])
16:35:50 <ski> or, which is the same thing
16:36:00 <ski>   blah :: forall c. (forall a b. (a -> b) -> (a -> b)) -> [c] -> [c]
16:36:23 <ski> and you're actually using the first argument with its `a' and `b' always being `[c]' (say), then you could instead use
16:36:39 <ski>   blah :: forall c. (([c] -> [c]) -> ([c] -> [c])) -> [c] -> [c]
16:38:22 <ski> for a given call to `blah', `c' will correspond to some fixed type. inside the body of `blah', the first argument of `blah' will then have type `([c] -> [c]) -> ([c] -> [c])' (*not* `forall c. ([c] -> [c]) -> ([c] -> [c])' !). because there's no `forall' heading the type of this argument, this argument is no longer polymorphic
16:38:47 <ski> (and so `blah' itself no longer has a rank-2 type)
16:40:05 <ski> (the fact that the type `([c] -> [c]) -> ([c] -> [c])' contains a type variable `c' is irrelevant. it is still monomorphic here. it's just that at this point, it's unknown what actual type `c' will turn out to be (it is determined when `blah' is called/used))
16:42:14 <SrPx> but wait, why is it bad to require RankNTypes? I am using it for something else anyway...?
16:42:39 <ski> it's not bad
16:43:02 <ski> .. but in case you don't need to extra power, why invoke it ?
16:43:05 <Kreatinonisilobi> hi folks
16:43:11 <SrPx> hmm I see
16:43:28 <Kreatinonisilobi> can I some how rename cabal in same productivity_chain and it will still work?
16:43:38 <Kreatinonisilobi> I prefer more positive names
16:43:44 <Kreatinonisilobi> rest look pretty neat to me
16:43:54 <monochrom> have you tried?
16:43:58 <Kreatinonisilobi> not yet
16:44:10 <Kreatinonisilobi> I am yet to see how it works
16:44:14 <SrPx> but on this case I need it, right? I can't say that the arguments are always [c]... righ? is this wrong? http://lpaste.net/131408 
16:44:48 <monochrom> you can safely set up an alias, e.g., symlink.
16:45:33 <Kreatinonisilobi> cool
16:45:41 <Kreatinonisilobi> haskell looks interesting
16:45:59 <Kreatinonisilobi> is it used much say as much as php or java?
16:47:42 <ski> SrPx : i see no need for `RankNTypes' in there
16:48:17 <ski> SrPx : also, `foldr memo cons nil xs' can be replaced with `memo foldrMemo xs'
16:48:52 <camlorn> So. I'm evaluating a possible project and have two questions.  How easy is it to learn whatever library is most popular for parsing, assuming that one's knowledge is right about the point where monads aren't frightening anymore but writing them still is, and how is the haskell landscape for talking to midi?
16:49:17 <ski> SrPx : you can then replace `foldrMemo = caseOf caseCons caseNil' by `foldrMemo = memo (caseOf caseCons caseNil)', while replacing both instances of `memo foldrMemo' by just `foldrMemo'
16:50:33 <ski> (SrPx : fwiw, i'd replace `((a -> b) -> a -> b)' with `(a -> b) -> a -> b' (or `(a -> b) -> (a -> b)'), and `(IntList list)' with `IntList list')
16:50:40 <kadoban> camlorn: Parsec style parsing isn't too difficult, which probably means either Parsec itself or attoparsec.
16:51:17 <kadoban> camlorn: Also, if writing them is difficult, you should do the NICTA course. It'll get you pretty familiar with how the big-name typeclasses work
16:51:44 <kadoban> (And, as a bonus, one of the exercises has to do with parsing, basically in the style of Parsec)
16:51:49 <camlorn> kadoban: What other type of parsing is there?  I mean, that is, you make it sound like it's divided somehow.
16:52:17 <ski> SrPx : oh, right .. for `caseOf :: forall a . (Int -> list -> a) -> a -> list -> a', you need `ExplicitForAll'
16:52:50 <ski> (alternatively, you could simply just say `caseOf :: (Int -> list -> a) -> a -> list -> a')
16:53:10 <kadoban> camlorn: I don't know a ton about parsing, so there's probably more variation than I know about. The only other style I know of is the more traditional kind, with like lex and yacc or whatever, or people sometimes try to use regex for parsing (fun)
16:53:39 <ski> SrPx : do you really need `Hashable a' on `mFoldr' ?
16:54:09 <camlorn> kadoban:  And to clarify my monads knowledge, I no longer facepalm when I try to read the real world Haskell monads chapter.  But I'm approaching Haskell really weirdly in that I decided that monads would be the sticking point while at the same time being essential to do anything but toys, and therefore focused on them first.
16:55:09 <camlorn> kadoban:  Also, god no on regex.  I'm doing at least a recursive descent parser or I'm going home without even trying.
16:55:33 <kadoban> camlorn: Hehe, sounds painful (and weirdly not-that-uncommon). I too learned via RWH first, mostly. If your haskell skills are still a bit flakey, you might benefit from doing cis194 and stuff first. Haha, good, yeah I wouldn't recommend regex for sure, people just do it because … I dunno they like pain maybe.
16:55:54 <ski> SrPx : you could possibly replace `caseOf cons nil (HProd ptr) = cons (hInside (hFirst (HProd ptr))) (hSecond (HProd ptr))' by `caseOf cons nil list@(HProd ptr) = cons (hInside (hFirst list)) (hSecond list)'
16:56:05 <camlorn> kadoban:  I took a course that tought very basic rcd.  People stumble over it so much.
16:56:28 <camlorn> kadoban:  Er. RDP. But that's not even an official acronym anyway.
16:56:36 <kadoban> Works
16:56:37 <ski> SrPx : `RankNTypes' implies `Rank2Types', which implies `ExplicitForAll'
16:57:08 <camlorn> kadoban:  I'm bookmarking this stuff.  I've got finals and graduation next week, and then I've got a bit of time.
16:58:26 <ski> SrPx : i hope the above helps some. i have to leave now, though
16:58:31 <SrPx> ahhh
16:58:44 <kadoban> Cool. Throw https://github.com/bitemyapp/learnhaskell in your bookmarks too, it's where I learned about NICTA and cis194. Also #haskell-beginners is kind of the official channel of that learning guide, some fun in there.
16:58:45 <SrPx> okay, I'm processing all that ... so bad you have to go, but thank you!
16:59:36 <camlorn> kadoban:  Cis194 is the course from university of Pennsylvania?
16:59:46 <monochrom> yes
17:00:13 <kadoban> camlorn: Yeah. The spring '13 class is pretty good for learning (the lectures and homework is online there). The other ones aren't as good
17:01:05 <camlorn> kadoban:  Thanks.  It's surprisingly hard to find good learning stuff.
17:01:49 <kadoban> It is. Teaching well is hard as hell apparently.
17:03:54 <SrPx> ski: btw, are you sure I can replace foldr how you said? I tested that transformation with "fib" and it made memoization not work
17:03:55 <camlorn> kadoban:  heh. My problem is more like Google loves real world Haskell and learn you some Haskell.  And everything is totally about explaining something, not suggesting a project that isn't implement factorial or something equally useless.
17:04:28 <SrPx> http://lpaste.net/131412 the function above isn't memoized but the function below is
17:04:35 <kadoban> Haha, yeah.
17:04:46 <camlorn> kadoban:  That's kinda why I stick with real world Haskell so much--barcode recognition by like chapter 10, a topic i've never even considered trying to implement in any language.
17:05:36 <kadoban> camlorn: Yeah, that project was pretty neat
17:06:00 <camlorn> kadoban:  I still need to actually read all the proceeding chapters. Then I can follow it. Heh.
17:06:13 <lexir> I keep getting these weird errors where the build log can't be found after it's been created by cabal http://lpaste.net/2538422948650287104
17:06:35 <lexir> It's like cabal creates and deletes it.
17:06:59 <kadoban> camlorn: Haha, yeah that would probably be a good idea. At the time I found it pretty difficult even on subsequent reads. Look at cis194 too though, it's more modern and IMO better, although you can certainly read RWH too
17:08:08 <lexir> kadoban: but cs194 didn't talk about parsec. I wish it did.
17:08:20 <lexir> or does it now?
17:09:36 <camlorn> lexir, kadoban:  I can probably figure out parsec.  I've worked with grammars and such before.  All I really need should be right recursive anyway, so that helps.
17:09:59 <kadoban> lexir: It doesn't, but nicta has you implement something parsec-like.
17:10:21 <lexir> camlorn: Well I haven't been able to figure about parsec but again I've never put effort into it.
17:10:30 <lexir> kadoban: Oh
17:10:45 <camlorn> lexir: I haven't looked  at it yet.  For all I know, it's special or turns parsing on its head.
17:12:26 * lexir out. Good night.
17:20:35 <SwashBuckla> cis194 '13 did not cover Parsec, but it does cover parser combinators
17:21:13 <SwashBuckla> the lectures (and corresponding homeworks) 10 & 11 are all about parsers and Applicative
17:21:24 <ronh> what unit test library is usually recommended?
17:21:54 <SwashBuckla> bah, lexir is gone :(
17:22:34 <pavonia> ronh: HUnit, I think
17:25:37 <verement> how should I interpret this: infixl 0 `fromInteger`
17:25:43 <verement> :t fromInteger
17:25:44 <lambdabot> Num a => Integer -> a
17:26:41 <benzrf> how can i disable AMP temporarily to allow return to be used w/o Applicative
17:26:51 <benzrf> i need to install something old :|
17:27:06 <verement> I don't understand what `fromInteger` means or how it could be used in any infix manner
17:27:35 <pavonia> verement: It's like an fixity annotation for infix functions with symbols
17:27:40 <moises> hi, have a question. what does "lists are compared in lexicographical order" mean?
17:27:54 <hpc> moises: front to end
17:28:08 <Hafydd> moises do you know what "lexicographical order" means?
17:28:11 <hpc> > [1,2] < [4,0]
17:28:12 <lambdabot>  True
17:28:16 <pavonia> verement: Are you used how to use functions with infix syntax`foo`?
17:29:13 <verement> pavonia: I understand `foo` as an infix function. I don't understand `fromInteger` specifically, since the arity is wrong?
17:29:37 <pavonia> Oh, I see
17:29:39 <moises> <Hafydd> no, I dont
17:30:05 * hackagebot atlassian-connect-core 0.5.1.0 - Atlassian Connect snaplet for the Snap Framework and helper code.  http://hackage.haskell.org/package/atlassian-connect-core-0.5.1.0 (RobertMassaioli)
17:30:21 <enthropy> the "a" type variable could be a function, or maybe somebody felt like enabling -XPostfixOperators so they can write (x `fromInteger`)
17:30:23 <benzrf> verement: functoins in haskell dont really have arity
17:30:33 <benzrf> > id (+1) 2
17:30:34 <lambdabot>  3
17:30:35 <benzrf> :t i
17:30:37 <lambdabot> Expr
17:30:37 <benzrf> :t id
17:30:38 <lambdabot> a -> a
17:30:50 <pavonia> > (123 `fromInteger`) :: Int
17:30:51 <lambdabot>  123
17:31:23 <pavonia> Didn't know you can do that
17:31:34 <mniip> that's a syntactic extension
17:31:38 <Hafydd> moises: then I suggest reading a definition of that, because it's a well-documented concept; but, informally, it means they're compared in the same way you put words in alpahbetical order.
17:32:00 <verement> benzrf: I get that too. So what purpose does this serve: infixl 0 `fromInteger`
17:32:03 <enthropy> there is no sanity check for infix things you can never use: http://lpaste.net/3581191392656883712
17:32:18 <benzrf> verement: no clue
17:32:32 <benzrf> how can i disable AMP temporarily to allow return to be used w/o Applicative
17:32:36 <benzrf> is there a -X for it
17:32:42 <arkeet> you can
17:32:43 <arkeet> er
17:32:50 <glguy> U can use 7.8
17:32:53 <arkeet> you can't disable parts of the standard library no
17:33:24 <pavonia> verement: Where have you seen that usage of infixl?
17:34:04 <ronh> checking out Test.HUnit.. examples don't even look like valid haskell.. https://hackage.haskell.org/package/HUnit-1.2.5.2/docs/Test-HUnit.html
17:34:04 <verement> pavonia, :i fromInteger in ghci (7.10.1)
17:34:46 <moises> @Hafydd ok i'll do that
17:34:46 <lambdabot> Unknown command, try @list
17:35:01 <benzrf> i mean like
17:35:05 * hackagebot clafer 0.3.10 - clafer compiles Clafer models to other formats, such as Alloy, XML, HTML, Dot.  http://hackage.haskell.org/package/clafer-0.3.10 (mantkiew)
17:35:10 <benzrf> is there some way of telling ghc "uhhh this is broken now can u pretend its not pls"
17:35:41 <enthropy> ronh: I think you might be better off looking at the code in https://hackage.haskell.org/package/HUnit-1.2.5.2/docs/src/Test-HUnit.html
17:36:06 <athan> benzrf: undefined? :\
17:37:09 <benzrf> but what inm doing is installing a paackage
17:37:35 <ronh> enthropy thanks.. is hackage removing quotes only for me?
17:37:40 <athan> benzrf: Just... just....
17:37:44 <athan> do it on a different os
17:37:52 <benzrf> shoo
17:38:00 * athan gets swept under the rug
17:38:21 <enthropy> ronh: whoever wrote that example didn't look at how haddock rendersit
17:38:49 <Lokathor> when reading about Erlang, I read about "last call optimization", which is like tail-call optimization but just always replaces the stack frame with the last expression, even when it's not recursion.
17:39:07 <Lokathor> I hadn't heard of this before, but when I thought about it I guess haskell probably does this too, right?
17:39:41 <arkeet> haskell doesn't have a call stack.
17:40:41 <ronh> this seems pretty concise.. but I wish I didn't have to repeat (and potentially update) a function call in two places.. test [ "test1" ~: "read \"10\"" ~: 10 ~=? (read "10")]
17:41:01 <Lokathor> arkeet, not... at all?
17:41:02 <ronh> is there a unit library where you don't need to repeat this?
17:41:07 <ronh> unit test library
17:42:08 <arkeet> Lokathor: it has a stack for evaluating expressions, but it's not exactly a call stack.
17:42:09 <geekosaur> Lokathor, every call immediately returns an unevaluated thunk. there is a stack for pattern matches, because those force evaluation
17:42:18 <arkeet> because of lazy evaluation.
17:42:20 <ronh> I guess I could use CPP
17:42:32 <geekosaur> non-strict evaluation is *very* different from what you are used to
17:42:42 <geekosaur> and TCO as you know it is meaningless
17:42:48 <kadoban> ronh: Doesn't exactly fit what you said, but quickcheck kinda
17:44:23 <Lokathor> yeah
17:44:33 <Lokathor> lazyness is always a little strange to think about
17:44:37 <enthropy> ronh: http://hspec.github.io/hspec-discover.html is one option
17:45:05 * hackagebot claferIG 0.3.10 - claferIG is an interactive tool that generates instances of Clafer models.  http://hackage.haskell.org/package/claferIG-0.3.10 (mantkiew)
17:45:47 <Lokathor> so if you call (head (sort someList)), it doesn't sort the whole list, right? just enough to figure out what head will be with some unevaluated stuff leftover?
17:46:02 <arkeet> mhm
17:46:15 <Lokathor> lazyness is a little weird to think about
17:46:37 <Lokathor> I usually just imagine "magically sometimes things will go faster because it'll skip things you didn't end up needing"
17:48:19 <benzrf> pleaze help
17:48:34 <benzrf> Lokathor: the key is to understand how laziness works
17:48:49 <benzrf> Lokathor: do you know about 'weak head normal form'
17:49:05 <Lokathor> i have heard the phrase
17:49:09 <Lokathor> in a presentation once
17:49:15 <benzrf> it is pretty easy actually!
17:49:15 <Lokathor> i do not recall what it applied to
17:49:26 <benzrf> if you have a partially-evaluated expression
17:49:34 <benzrf> it is in weak-head normal form IF:
17:49:37 <benzrf> *iff
17:49:44 <benzrf> 1. it is a lambda, no matter the body
17:50:03 <benzrf> 2. it is an application of a constructor
17:50:23 <benzrf> i think "partially-applied" functions might count, but im not 100% sure
17:50:24 <Lokathor> so
17:50:48 <Lokathor> the result of (+ 2) is WHNF?
17:50:54 <benzrf> i think so
17:50:58 <benzrf> or:
17:51:05 <benzrf> 1:repeat 1 <- whnf
17:51:11 <benzrf> repeat 1 <- NOT whnf
17:51:39 <benzrf> so basically
17:51:50 <benzrf> evaluation is forced when you pattern match
17:51:56 <benzrf> or force it using seq or something
17:52:08 <benzrf> in general! if evaluation of an expression is forced, it evalutes UP TO WHNF
17:52:16 <benzrf> example:
17:52:24 <benzrf> > (1:undefined) `seq` ()
17:52:25 <lambdabot>  ()
17:52:29 <benzrf> ^forced, already in WHNF
17:52:34 <benzrf> > id undefined `seq` ()
17:52:35 <lambdabot>  *Exception: Prelude.undefined
17:52:37 <Lokathor> so
17:52:38 <benzrf> ^NOT in whnf
17:53:44 <Lokathor> print (getX (Location (someXCoordCalculation) (someYCoordCalculation))) would print X, but not calculate Y at all
17:53:51 <Lokathor> since the constructor is "Location"
17:53:52 <benzrf> yes!
17:53:56 <arkeet> benzrf: partially applied functions end up as lambdas anyway.
17:54:01 <benzrf> arkeet: oh thx
17:54:20 <Lokathor> arkeet, what functions *don't* end up as lambdas, is my question
17:54:29 <benzrf> Lokathor: and this is why lazy sorting (probably) works
17:54:35 <benzrf> @src head
17:54:35 <lambdabot> head (x:_) = x
17:54:35 <lambdabot> head []    = undefined
17:54:48 <arkeet> > (undefined :: Int -> Char) `seq` ()
17:54:50 <lambdabot>  *Exception: Prelude.undefined
17:54:56 <benzrf> Lokathor: it pattern matches on the argument, so the arg (sort someList) is evaluated up to WHNF
17:54:56 <arkeet> that's a "function".
17:55:06 * hackagebot claferwiki 0.3.10 - A wiki-based IDE for literate modeling with Clafer  http://hackage.haskell.org/package/claferwiki-0.3.10 (mantkiew)
17:55:10 <benzrf> @src sort
17:55:10 <lambdabot> sort = sortBy compare
17:55:13 <benzrf> @src sortBy
17:55:13 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
17:55:23 <arkeet> but @src lies.
17:55:27 <benzrf> D:
17:56:26 <benzrf> Lokathor: each of these is reduced in turn
17:56:29 <benzrf> @src foldr
17:56:29 <lambdabot> foldr f z []     = z
17:56:29 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:56:37 <benzrf> lambdabot: and then you hit pattern-match
17:56:53 <benzrf> * Lokathor
17:56:59 <benzrf> Lokathor: then it forces someList, and... blah blah
17:57:05 <Lokathor> undefined functions don't end up in WHNF
17:57:07 <Lokathor> okay
17:57:15 <benzrf> @src map
17:57:15 <lambdabot> map _ []     = []
17:57:15 <lambdabot> map f (x:xs) = f x : map f xs
17:57:20 <Lokathor> do all defined functions end up in WHNF?
17:57:23 <benzrf> ^notice that the return of map is an application of :
17:57:28 <benzrf> so you can lazily consume results
17:57:42 <benzrf> Lokathor: i dont know
17:57:42 <arkeet> > (let f = f :: Int -> Char in f) `seq` ()
17:57:44 <benzrf> arkeet: ?
17:57:45 <lambdabot>  mueval-core: Time limit exceeded
17:57:52 <arkeet> does that count as defined?
17:58:12 <Lokathor> I can't fully comprihend what that snippit is saying
17:58:18 <Lokathor> probably because i dont' quite know what seq does
17:58:35 <benzrf> Lokathor: seq, when forced, forces its first arg up to WHNF, then returns its 2nd
17:58:36 <Lokathor> something about forcing the first arg to be evaluated at least before the second arg is
17:58:44 <benzrf> Lokathor: so like
17:58:58 <benzrf> seq l v = case l of {_:_ -> v; [] -> v}
17:58:59 <arkeet> (well actually, seq doesn't guarantee anything about evaluation order)
17:59:01 <benzrf> except that it works on all types
17:59:08 <mniip> Lokathor, you know lazy evaluation, right
17:59:13 <benzrf> arkeet: oops right
17:59:13 <Lokathor> so a seq, if not forced, naturally won't force the first argument and return the second
17:59:18 <benzrf> Lokathor: yeah
17:59:29 <mniip> when the result of seq is demanded, seq demands the WHNF of the first argument, and returns the second
17:59:47 <benzrf> Lokathor: arkeet brought up: the actual specification of haskell only requires that an implementation make seq be undefined when its 1st arg is undefined and otherwise be its 2nd arg
17:59:50 <Lokathor> mniip, it seems i only sort of know lazy evaluation
17:59:52 <benzrf> Lokathor: it says nothing about evaluation order
18:00:09 <Lokathor> hmm
18:00:30 <benzrf> Lokathor: in practice though most of the time it's gonna be "force the 1st then return 2nd"
18:00:33 <Lokathor> so seq helps avoid thunks being too large?
18:00:37 <benzrf> Lokathor: yeah
18:00:46 <Lokathor> but only 1 layer down
18:00:49 <arkeet> yeah
18:00:50 <benzrf> @src ($!)
18:00:50 <lambdabot> f $! x = x `seq` f x
18:01:09 <benzrf> > const "hi" $ undefined
18:01:11 <lambdabot>  "hi"
18:01:11 <benzrf> > const "hi" $! undefined
18:01:13 <lambdabot>  "*Exception: Prelude.undefined
18:01:13 <arkeet> so you use seq when you want to be less lazy.
18:01:31 <arkeet> because sometimes laziness is bad (uses a lot of memory)
18:01:36 <Lokathor> i have yet to encounter when i would want to be more or less lazy
18:01:53 <benzrf> > foldl1 (+) [1..1000000]
18:01:55 <lambdabot>  *Exception: stack overflow
18:01:58 <benzrf> > foldl1 (+) [1..1000000]
18:01:59 <benzrf> er
18:02:00 <lambdabot>  *Exception: stack overflow
18:02:01 <Lokathor> i've only really written one significant program in haskell though
18:02:01 <benzrf> > foldl1' (+) [1..1000000]
18:02:03 <lambdabot>  500000500000
18:02:46 <arkeet> > let fun n = go 0 n where go a 0 = a; go a k = go (a+1) (k-1) in fun 100
18:02:47 <lambdabot>  100
18:02:49 <arkeet> > let fun n = go 0 n where go a 0 = a; go a k = go (a+1) (k-1) in fun 1000000
18:02:52 <lambdabot>  *Exception: stack overflow
18:03:03 <arkeet> > let fun n = go 0 n where go a 0 = a; go a k = a `seq` go (a+1) (k-1) in fun 1000000
18:03:06 <lambdabot>  1000000
18:03:22 <benzrf> Lokathor: what happens is
18:03:30 <Lokathor> this abstract one-liner stuff is kinda hard to follow
18:03:34 <benzrf> Lokathor: well, picture an expression graph that ghc reduces at runtime
18:03:41 <benzrf> Lokathor: say it looks something like
18:03:45 <Lokathor> but it seems to be, "sometimes you use seq"
18:03:53 <benzrf> App (Var "f") (Var "x")
18:04:06 <Lokathor> makes senes so far
18:04:12 <arkeet> uh let's shorten this.
18:04:15 <Lokathor> sense*
18:04:17 <benzrf> arkeet: ?
18:04:31 <arkeet> > let add a 0 = a; add a b = add (a+1) (b-1) in add 2 3
18:04:33 <lambdabot>  5
18:04:35 <arkeet> > let add a 0 = a; add a b = add (a+1) (b-1) in add 2 1000000
18:04:37 <lambdabot>  *Exception: stack overflow
18:04:41 <benzrf> Lokathor: ok so
18:04:47 <arkeet> this is just a recursive definition of addition.
18:04:51 <benzrf> Lokathor: i can reach down and expand the definitions of f and x in one step
18:04:52 <arkeet> now
18:04:59 <benzrf> Lokathor: without having to recurse at all
18:05:03 <benzrf> Lokathor: yeah?
18:05:06 <arkeet> okay I'll wait.l
18:05:12 <benzrf> arkeet: soz :|
18:05:21 <stoopkid> question: "(:)  :: a -> [a] -> [a]" ?
18:05:42 <benzrf> stoopkid: what about it
18:05:45 <arkeet> putting a question mark on something does not make it a question
18:05:47 <arkeet> :t (:)
18:05:47 <lambdabot> a -> [a] -> [a]
18:06:12 <stoopkid> arkeet, yea it does, benzrf i'm asking if that's correct
18:06:16 <benzrf> oh
18:06:21 <benzrf> stoopkid: yes :)
18:06:28 <arkeet> yes, and ghci can tell you that with :t (:)
18:06:41 <stoopkid> oh
18:06:44 <stoopkid> i see
18:07:02 <Lokathor> so the unevaluated portion behind the top level WHNF can get too large
18:07:13 <arkeet> yeah.
18:07:14 <Lokathor> and you use seq to avoid that
18:07:24 <benzrf> Lokathor: there's more than just that
18:07:28 <benzrf> Lokathor: stack overflows are a thing
18:07:30 <Lokathor> does "seq" mean "sequence"?
18:07:42 <arkeet> well, unevaulated stuff is fine.
18:07:51 <arkeet> but your stack might blow up when you try to evaluate it.
18:07:59 <stoopkid> arkeet, can it also give me the way (:) is defined?
18:08:08 <benzrf> stoopkid: it;s a constructor of the list type
18:08:13 <ncthom91> hi all! Is there anything in the way of embedding javascript engines in Haskell? For example, it's straightforward to embed V8 into C++ applications, Java has Nashorn and Rhino, etc. Surely I could bridge haskell/C++/V8 but I'm just wondering if there's something in this vein that's already been done / is freely available?
18:08:15 <benzrf> stoopkid: if you dont know about constructors yet, accept it as magic :)
18:08:19 <arkeet> stoopkid: (:) is defined by ghc.
18:08:32 <arkeet> stoopkid: but you can think of it as part of the data definition:
18:08:35 <Lokathor> ncthom91, https://github.com/ghcjs/ghcjs
18:08:38 <arkeet> data [a] = [] | (:) a [a]
18:08:54 <arkeet> [] and (:) are constructors for the type [a]
18:08:56 <benzrf> Lokathor: isnt that the other way around
18:09:11 <arkeet> Lokathor: https://wiki.haskell.org/Foldr_Foldl_Foldl%27
18:09:30 <ncthom91> Lokathor I'm looking for something more along the lines of evaluating javascript expressions in haskell
18:11:19 <Lokathor> not sure about that one
18:11:33 <benzrf> Lokathor: so if i have something like `App (Var "f") (Var "x")'
18:11:45 <benzrf> Lokathor: i can, in one step, reach down and expand them then hop back up, right?
18:11:51 <benzrf> no stack space added
18:12:07 <Lokathor> arkeet, yes, i've read that folds article before. I get the general concept, i'm just less sharp on the precise technical details like what WHNF is and such
18:12:09 <benzrf> (in C terms, i mean. like if this were in C)
18:12:15 <arkeet> ok
18:13:04 <Lokathor> sadly i must leave the house for a bit now, but this has been illuminating
18:13:20 <Hijiri> I think WHNF means you know the constructor
18:13:34 <arkeet> yes, WHNF was defined earlier.
18:13:37 <Hijiri> oh
18:13:49 <Lokathor> what's the WHNF to the expression "2 + 2"
18:14:13 <benzrf> Lokathor: depends on your representation
18:14:19 <arkeet> let's say 2 + 2 :: Int
18:14:34 <benzrf> Lokathor: i believe that goes straight to machine code and you get out a 4 before you're done forcing
18:14:49 <arkeet> well, the short answer is that an Int is in WHNF if it's just a number.
18:14:53 <arkeet> like 4.
18:14:59 <stoopkid> arkeet, can lambdabot do things from the happstack framework
18:15:04 <stoopkid> :t simpleHTTP
18:15:04 <arkeet> stoopkid: don't believe so
18:15:04 <lambdabot> Not in scope: ‘simpleHTTP’
18:15:12 <stoopkid> answers that question
18:15:13 <arkeet> it can't run IO actions in any case
18:15:15 <benzrf> stoopkid: lambdabot doesnt do IO for security reasons
18:15:16 <geekosaur> no, not loaded and anything in IO can't be done with lb anywya
18:15:20 <stoopkid> oh
18:15:26 <stoopkid> i see
18:15:34 <arkeet> Lokathor: the longer answer is that you can look at the definition of Int
18:16:03 <geekosaur> conceptually a value like 2 :: Int is a constructor, so in WHNF
18:16:14 <arkeet> data Int = I# Int#
18:16:21 <arkeet> I# is just the name of the constructor.
18:16:27 <arkeet> Int# is the type of unboxed ints.
18:16:36 <geekosaur> (in reality it's (I# 2#) where I# is a constructor (so still WHNF) and 2# is an unboxed representation, so nothing to be done to evaluate it)
18:16:44 <arkeet> unboxed means 
18:17:09 <a2> the raw representation, essentially
18:17:09 <arkeet> a value of Int# is really just an int in memory. no code pointer or anything
18:17:54 <bdamos> Hi, new Haskeller here, sorry for the simple question. What's the best way to obtain [0..6] from [Just([0,1]),Nothing,Just([2,3,4,6])]? My obviously suboptimal way of doing this is `concat $ map Data.Maybe.fromJust $ filter (/= Nothing) $ a`, where `a` is the list above.
18:18:06 <benzrf> bdamos:
18:18:08 <benzrf> :t catMaybes
18:18:09 <lambdabot> [Maybe a] -> [a]
18:18:12 <geekosaur> a constructor is a box of sorts, which may have zero or more things in it. and it's passed around by means of a pointer to that box
18:18:14 <arkeet> so an Int in memory just looks like a tag for the I# constructor, next to an int.
18:18:20 <benzrf> > catMaybes [Nothing, Just 1, Just 2, Nothing, Just 3]
18:18:22 <lambdabot>  [1,2,3]
18:18:27 <benzrf> bdamos: found in Data.Maybe
18:18:42 <arkeet> the point is that if you see a I# constructor in your value, it's already fully evaluated.
18:18:52 <bdamos> benzrf: Thanks for the quick response! Exactly what I want.
18:19:11 <benzrf> np
18:19:19 <ronh> given  10.123 :: Double how can I get (10::Integer, 0.123 :: Double)?
18:19:23 <benzrf> @src catMaybes
18:19:23 <lambdabot> catMaybes ls = [x | Just x <- ls]
18:19:31 <geekosaur> (the box is a chunk of memory containing (constructor-tag [value ...]) --- for Bool the values False and True are constructor tags with no associated values, for Int it's the tag for I# followed by the machine word with the value)
18:19:36 <benzrf> crud i always forget about list comps
18:19:41 <arkeet> also see mapMaybes
18:19:45 <arkeet> er mapMaybe
18:19:51 <benzrf> bdamos: fyi, partial functions are almost never the best solution
18:19:53 <arkeet> :t mapMaybe
18:19:53 <lambdabot> (a -> Maybe b) -> [a] -> [b]
18:20:11 <arkeet> (catMaybes = mapMaybe id)
18:20:15 <benzrf> bdamos: if you're using `head' there's probably a better way; if you're using `fromJust' there fucking BETTER be a better way
18:22:27 <arkeet> > toListOf (traverse.traverse.traverse) [Just([0,1]),Nothing,Just([2,3,4,6])]
18:22:29 <lambdabot>  [0,1,2,3,4,6]
18:22:31 <ronh> I can use truncate to get the whole part of the double. how about the decimal part? should I just subtract truncated part from the double
18:23:21 <benzrf> arkeet: cute.
18:23:42 <homovitruvius> I've simplified a question of yesterday to the bone and I still cannot see the two asyncs running on two separate cores. Somebody has time to take a look at http://dpaste.com/00D152N? thx
18:23:53 <benzrf> hmm... traverse is effectively the same as _Just, but not reviewable
18:23:55 <benzrf> isnt it
18:24:03 <arkeet> for Maybe, it is.
18:24:07 <benzrf> yeah
18:25:07 <arkeet> > properFraction (3.25)
18:25:08 <lambdabot>  (3,0.25)
18:25:11 <arkeet> > properFraction (-3.25)
18:25:12 <lambdabot>  (-3,-0.25)
18:25:21 <arkeet> > properFraction (-3.75)
18:25:22 <lambdabot>  (-3,-0.75)
18:25:36 <arkeet> ronh: looks like you can use this, at least for Double.
18:25:46 <ronh> cool thanks. I only need it for Double
18:26:10 <arkeet> oh I should read the docs more carefully.
18:26:12 <a2> > concat . catMaybes $  [Just([0,1]),Nothing,Just([2,3,4,6])]
18:26:13 <lambdabot>  [0,1,2,3,4,6]
18:26:16 <a2> simplest dolution imo
18:26:35 <arkeet> ronh: it works for any RealFrac.
18:26:46 <arkeet> ronh: and truncate = fst . properFraction
18:26:58 <ronh> ah ok
18:27:16 <arkeet> the doc says that both parts of properFraction have the same sign as the input.
18:27:27 <mauris> heya. is there a function that lets me specify an alternative value for an empty list?
18:27:42 <a2> mauris: not sure what you mean
18:27:42 <arkeet> an alternative to what?
18:27:44 <mauris> like "foo" `f` "alternative" == "foo", but "" `f` "alternative" == "alternative"
18:28:02 <mauris> basically, just  f [] x = x; f y _ = y
18:28:10 <arkeet> yes, and you just wrote it. :-)
18:28:17 <arkeet> uh
18:28:26 <mauris> yes, i know it's easy to define myself but i was wondering if that's in some package out there, or if there's a generalization
18:28:42 <mauris> (for any Eq Monoid i guess?)
18:29:41 <arkeet> well, that's not quite <|> / mplus
18:29:47 <mauris> also, it's surprisingly hard to name :)
18:30:14 <mauris> maybe: a `butIfNull` b
18:30:24 <stoopkid> in the following: "data Tree a                = Leaf a | Branch (Tree a) (Tree a) ", Leaf and Branch simply come into existence as part of the definition of Tree?
18:30:37 <arkeet> stoopkid: yes. that line defines the constructors Leaf and Branch
18:31:15 <arkeet> mauris: I'm thinking <?>, by analogy with the thing of the same name in parsec
18:31:27 <stoopkid> arkeet, so it defines Leaf as something that pattern matches a, and Branch as something that pattern matches (Tree a) (Tree a)
18:31:28 <arkeet> uh
18:32:05 <arkeet> mauris: never mind, that's not what <?> does. heh
18:40:07 * hackagebot base-compat 0.8.1 - A compatibility layer for base  http://hackage.haskell.org/package/base-compat-0.8.1 (ryanglscott)
18:52:53 <h-core> so i can't figure out why this little anagram function isn't case-insensitive even though im mapping toLower over every string that i'm comparing http://lpaste.net/131414
18:53:02 <h-core> i mean what can i be doing wrong here
18:55:19 <SrPx> How can I force a function to be called only once? I have "memoize func" but for some reason it is being called more than once so it creates different memo tables
18:56:50 <stoopkid> i see do statements written like this usually:
18:56:58 <stoopkid> do putChar 'b'
18:57:02 <Welkin> you can memoize by just creating a List or a Map
18:57:03 <stoopkid>    putChar 'c'
18:57:14 <stoopkid> can i write it like this instead:
18:57:16 <stoopkid> do
18:57:22 <stoopkid>     putChar 'b'
18:57:26 <stoopkid>     putChar 'c'
18:57:27 <stoopkid> ?
18:57:36 <Welkin> a do-block or do-expression, you mean
18:57:39 <stoopkid> yea
18:57:45 <Welkin> you can write is however you want
18:57:48 <Welkin> it*
18:57:56 <Welkin> you can even disable the formatting using { and }
18:58:13 <ronh> h-core:
18:58:15 <ronh> > map toLower (sort "test")
18:58:16 <lambdabot>  "estt"
18:58:19 <Welkin> just know that do-notation is just syntactic sugar for bind
18:58:27 <ronh> > sort (map toLower "Test")
18:58:28 <lambdabot>  "estt"
18:58:36 <ronh> uh, lets try again
18:59:44 <ronh> > (map toLower (sort "Test"), map toLower (sort "test"))
18:59:45 <lambdabot>  ("test","estt")
19:00:13 <arkeet> > sortBy (comparing toLower) "Test"
19:00:14 <lambdabot>  "esTt"
19:00:15 <ronh> basically, you should first map toLower, and then test
19:00:23 <ronh> or that
19:00:28 <ronh> and then sort*
19:00:45 <h-core> i see, thanks ronh and arkeet 
19:01:01 <h-core> i was unaware that sort would sort "Test" and "test" differently
19:01:04 <h-core> that's so weird
19:01:09 <arkeet> > 'T' < 'e'
19:01:11 <lambdabot>  True
19:01:29 <arkeet> it just compares them by their unicode values.
19:01:45 <geekosaur> SrPx: depends on a number of things, but if it's being inlined then it may well be creating a separate table for each use site that got inlined
19:01:49 <ronh> > ['A'..'z']
19:01:50 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
19:02:33 <h-core> arkeet, thanks, i guess it's just counter-intuitive
19:02:58 <h-core> especially since every other sort i use does it in a case-insensitive way
19:04:23 <SrPx> geekosaur: specifically this http://lpaste.net/131416 shouldn't output that :(
19:05:23 <SrPx> if I could somehow force that "M.memoFix foldrMemo" is called right on
19:05:32 <athan> > filter (Data.Char.isAlpha) ['A'..'z']
19:05:33 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
19:06:42 <mjrosenb> @hoogle Int -> Float
19:06:44 <ronh> > length $ filter (Data.Char.isAlpha) [minBound..]
19:06:45 <lambdabot> Data.Set elemAt :: Int -> Set a -> a
19:06:45 <lambdabot> Prelude (!!) :: [a] -> Int -> a
19:06:45 <lambdabot> Data.List (!!) :: [a] -> Int -> a
19:06:46 <lambdabot>  102725
19:07:02 <athan> :o
19:07:20 <h-core> that's a lot to account for
19:07:24 <arkeet> > filter Data.Char.isAlpha [chr 256 ..]
19:07:25 <lambdabot>  "\256\257\258\259\260\261\262\263\264\265\266\267\268\269\270\271\272\273\27...
19:07:27 <h-core> and now i can see why sort is the way it is
19:07:28 <arkeet> heh.
19:07:32 <arkeet> > text $ filter Data.Char.isAlpha [chr 256 ..]
19:07:33 <lambdabot>  ĀāĂăĄąĆćĈĉĊċČčĎďĐđĒēĔĕĖėĘęĚěĜĝĞğĠġĢģĤĥĦħĨĩĪīĬĭĮįİıĲĳĴĵĶķĸĹĺĻļĽľĿŀŁłŃńŅņŇňŉŊŋ...
19:08:03 <athan> mjrosenb: fromIntegral, maybe?
19:08:22 <SrPx> I've tried bang patterns, noinline, everything
19:08:22 <arkeet> filter Data.Char.isAlpha $ randoms (mkStdGen 0)
19:08:27 <arkeet> > text $ filter Data.Char.isAlpha $ randoms (mkStdGen 0)
19:08:31 <lambdabot>  mueval-core: Time limit exceeded
19:08:33 <arkeet> heh.
19:08:43 <arkeet> oh wait.
19:08:51 <arkeet> > text . take 100 $ filter Data.Char.isAlpha $ randoms (mkStdGen 0)
19:08:53 <lambdabot>  삇豞𡙩笁𨛬𞣄𤃠𣹃𩋎帷థሧ쵾𡨊𪎃𢰻𧖲뗽𠮛𨺽𠻁𡹯𖧎𖠉霰첽ඹꤡ𓍁긣ꕸ궬𣼶י顂㼿햳挒𪢿ኁ䢷𧦕䩱㳥𫋷溢蠀洜𢑤ﾵ탔抅𦵲虅Ӽꩉ븀𦿏𓊢𩧙ὁ𩟡ⵎ峎泮𧲡䱂𡁁𨸻糽𠄫驦𣫛𧸂呃禪...
19:08:56 <arkeet> oh joy
19:13:34 <dfeuer> Ping edwardk.
19:15:21 <dfeuer> Cale, for that matter?
19:16:09 <Cale> ?
19:27:52 <yohanobs> ji
19:27:53 <yohanobs> hi
19:27:55 <yohanobs> hi
19:27:59 <yohanobs> hiskell
19:28:00 <yohanobs> :)
19:29:52 <athan> *depression ensues*
19:30:36 <SrPx> ... uhm? 
19:30:38 <SrPx> > text . take 100 $ filter Data.Char.isAlpha $ randoms (mkStdGen 0)
19:30:40 <lambdabot>  삇豞𡙩笁𨛬𞣄𤃠𣹃𩋎帷థሧ쵾𡨊𪎃𢰻𧖲뗽𠮛𨺽𠻁𡹯𖧎𖠉霰첽ඹꤡ𓍁긣ꕸ궬𣼶י顂㼿햳挒𪢿ኁ䢷𧦕䩱㳥𫋷溢蠀洜𢑤ﾵ탔抅𦵲虅Ӽꩉ븀𦿏𓊢𩧙ὁ𩟡ⵎ峎泮𧲡䱂𡁁𨸻糽𠄫驦𣫛𧸂呃禪...
19:30:52 <SrPx> but that is the same
19:31:18 <FreeFull> What do you mean by the same?
19:31:21 <ronh> you used the same seed
19:31:29 <FreeFull> Oh, yeah
19:31:34 <FreeFull> You started with a seed of 0
19:35:10 * hackagebot ess 0.1.0.0 - The type-level S combinator in Haskell.  http://hackage.haskell.org/package/ess-0.1.0.0 (MichaelOChurch)
19:36:41 <mniip> that... doesn't sound particularly useful
19:36:56 <mniip> point-free types eh
19:37:14 <KaneTW> "I will be deeply impressed if anyone finds a use for this."
19:37:23 <KaneTW> "But where is our S combinator? More importantly, is it useful at all? This repository exists, because I want to know."
19:37:29 <KaneTW> that's some next level stuff
19:39:16 <ronh> seems that whatever language I use I always fallback to printf.. :P
19:39:18 <ronh> > printf "%.*f" 2 1.2345 :: String
19:39:19 <lambdabot>  "1.23"
19:40:03 <mniip> please don't tell me you're comparing floats
19:40:35 <ronh> me? no I'm printing them
19:40:44 <mniip> phew
19:44:05 <dfeuer> Cale, I was thinking about the Applicative instance for lists. It satisfies the peculiar law that <,> distributes over ++. I was wondering if there's a name for such.
19:44:27 <dfeuer> (left and right distribution).
19:46:25 <nocturne777> why does "as pattern" not work while pattern matching after the case statement 
19:47:23 <geekosaur> ???
19:47:23 <nocturne777> case foo input of z@(Left e) -> z        _ -> Right 2
19:47:43 <nocturne777> this is what I meant
19:48:13 <nocturne777> something like this results in a compilation error for me
19:48:33 <pavonia> > case Left "foo" of { z@(Left e) -> z; _ -> Right 2 }
19:48:35 <lambdabot>  Left "foo"
19:49:27 <geekosaur> so at a guess, you missed the semicolon that;s needed if you put them on the same line
19:49:48 <nocturne777> they are actually on seperate lines
19:49:49 <geekosaur> if you put them on different lines then I suggest you
19:49:52 <geekosaur> @paste your actual code
19:49:53 <lambdabot> Haskell pastebin: http://lpaste.net/
19:50:59 <ronh> is there a way to force haskell to provide line number when an uncaught exception was thrown?
19:51:48 <geekosaur> not currently
19:52:04 <geekosaur> there is ongoing work on this
19:52:32 <lpaste> nocturne777 revised “No title”: “as pattern” at http://lpaste.net/6413026427997782016
19:52:52 <geekosaur> (it's not exactly trivial given laziness; the exception tends to get thrown at a different place than its location in the source, when something gets forced)
19:53:00 <nocturne777> geekosaur: this is the actual code
19:53:08 <nocturne777> I did not pasted in the entire thing
19:53:42 <nocturne777> but if change the line 5 to "(Left e) -> Left e", it compiles
19:55:21 <geekosaur> can you attach the full error message as well?
19:55:43 <geekosaur> I now suspect the problem is you're assuming the same Left value can be returned, but it's actually the wrong type
19:56:14 <geekosaur> that is, the type of z there is Either String something_that_is_not_Board
19:56:37 <geekosaur> yes, this does matter.
19:56:41 <dfeuer> Ah yes, *that* unfortunate bit.
19:56:56 <arkeet> Left "a" :: Either String Int and Left "a" :: Either String Board are different values.
19:57:10 <arkeet> for example.
19:57:14 <dfeuer> Unfortunate because the distinction survives through core-to-core and can interfere with optimization.
19:57:20 <dfeuer> Otherwise not unfortunate.
19:57:31 <tejing> and unwrapping and rewrapping the Left constructor allows you to switch from one to the other
19:57:32 <nocturne777> geekosaur: updated with annotation
19:57:48 <geekosaur> yep, that is exactly the problem
19:58:00 <geekosaur> you cannot reuse that value as is
19:58:09 <nocturne777> validateDimensions :: Dimensions -> Either String Dimensions
19:58:17 <nocturne777> oh I see
19:58:24 <geekosaur> Either String Dimensions is not compatible with Either String Board
19:58:42 <geekosaur> the part you aren't using doesn';t disdappear from the type just because you;re not using it
19:59:06 <nocturne777> is there a better practice to avoid this 
19:59:19 <arkeet> just do Left e -> Left e
19:59:30 <nocturne777> yes, when I do that it compiles
19:59:37 <arkeet> yes, and that is how you should do it.
19:59:43 <geekosaur> as dfeuer commented, this is sometimes unfortunate (as here, or in the case dfeuer cited)
20:00:06 <geekosaur> other times, it's a feature; we call these "phantom types" and they're very useful in ensuring that you don;t axxidentally mix things that shouldn't be mixed
20:00:13 <geekosaur> *accidentally
20:00:19 <dfeuer> Yup.
20:00:34 <geekosaur> but it does mean you don;t get to use shortcuts like that (and neither does the compiler, hence dfeuer's complaint)
20:01:14 <nocturne777> I see. thanks for the expalantion guys
20:01:20 <nocturne777> explanation*
20:01:25 <nocturne777> can't type today, sorry
20:02:04 <geekosaur> pfeh. you saw my typing :)
20:03:34 <nocturne777> do people find continuation passing style useful? or does it make things more complicated than they should be?
20:05:54 <ElMoloko> I find it fun
20:05:54 <ElMoloko> Useful, I dunno
20:06:35 <ElMoloko> apparently can be good for error handling depending on the control flow of your program
20:08:14 <stoopkid> :t ($)
20:08:15 <lambdabot> (a -> b) -> a -> b
20:08:46 <simpson> CPS is useful for compilers sometimes. It's definitely harder for humans to grok though.
20:10:12 * hackagebot hans 2.5.0.0 - IPv4 Network Stack  http://hackage.haskell.org/package/hans-2.5.0.0 (TrevorElliott)
20:11:35 <dfeuer> Full-on CPS, not so much. 
20:12:03 <dfeuer> But occasionally thinking in terms of continuations? Sure.
20:12:57 <nocturne777> the argument I came across is that with CPS you chain some functions and then the entire chain gets executed once you feed the input
20:14:34 <nocturne777> since Haskell is lazy evaluation by default, CPS may not be need in it as much as  it is needed in other languages.
20:16:19 <ElMoloko> that's interesting
20:16:55 <ElMoloko> nocturne777: can you share that resource? I'm kinda interested now
20:18:28 <pavonia> I think one of the main arguments for CPS is that it allows easier descriptions of complex control flows
20:18:36 <nocturne777> ElMoloko: https://wiki.haskell.org/All_About_Monads
20:18:44 <nocturne777> 16.2 Motivation section
20:18:47 <simpson> It permits a near-trivial definition of call/cc, for sure.
20:21:04 <spindas> Is there a great way to derive a Monoid instance like this? http://lpaste.net/131421
20:21:09 <spindas> It feels like a lot of boilerplate.
20:22:04 <spindas> "Spec" is just a datatype with a bunch of records.
20:25:01 <zenguine> hey all.. hoping someone can help me with this
20:25:09 <zenguine> im trying to get ihaskell running with ghc 7.8
20:25:22 <zenguine> everything seemingly built okay
20:25:46 <zenguine> but when trying to use it (i.e. evaluate an expression in a notebook) I get the following error
20:26:14 <zenguine> ihaskell: You can't call hscCompileCoreExpr in a profiled compiler
20:26:38 <zenguine> upon googling this, it looks like the error comes from the ghc source when some flag "rtsIsProfiled" is set
23:06:11 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org | Learn, Teach, or Get Out of the Way!'
23:06:11 --- topic: set by shapr!~shapr@84.200.228.78 on [Tue Mar 17 12:32:20 2015]
23:06:41 <jle`> Functor, Applicative, Monad, etc. let you use values while they're "still in Maybe", and combine different Maybe's together, etc.
23:07:01 <jle`> in the end though you eventually need to "get out" of Maybe somewhere.  you can do that with case statements, maybe, fromMaybe...
23:07:21 <MuffettMan> kadoban: Ah okay, I'll look into those more, thank you
23:07:58 <stoopkid> ah i see now
23:11:31 <sgronblo> So to upgrade a package I'm just supposed to cabal install it again?
23:16:17 <saulzar> sgronblo, You can do that - but as it will warn you it can break things
23:18:24 <saulzar> sgronblo, You're better off using a sandbox to install things where you can more easily start again  (though for all I know you're already using a sandbox, cabal operates exactly the same)
23:27:38 * srid completed migrating from Jekyll to Hakyll, and published a blog post on the whole process (includes using CircleCI to automate everything) => http://www.srid.ca/posts/2015-04-24-hakyll-and-circleci.html
23:30:23 <kadoban> srid: Might want to clarify that those limitations you mention aren't limitations of hakyll itself, just … github pages when not using jekyll I guess?
23:32:06 <srid> kadoban: valid point; edited. s/hakyll/this setup/
23:32:48 <kadoban> srid: Also, your email is obfuscated on your resume, but intact as a mailto on your home page. Not sure that was intentional or not
23:33:53 <srid> kadoban: obfucated? it is a clear mailto: to me.
23:34:42 <kadoban> srid: Yes, but on your resume it's "srid at srid dot ca", which seemed odd. Usually you're trying to hide it from spiders when you do that, at least I thought, but then it's clear on the other page. Just thought it was odd.
23:35:08 <kadoban> srid: Oh, it's a javascript thing. I don't run js usually.
23:36:02 <srid> my site has no JS. does your browser run some extension on my site to obfuscate the email?
23:36:30 <srid> i see nothing but google analytics js in view-source
23:37:08 <dmj`> criterion is so awesome
23:37:17 <nshepperd_> srid: there's js on the resume page
23:37:48 <kadoban> No. pandoc probably added it automatically. There's a setting for it somewhere. search for <script> on http://www.srid.ca/resume.html in the source.
23:38:06 <srid> aha. yes
23:38:21 <nshepperd_> hakyll seems to obfuscate emails with js by default, which is nice, but it doesn't work on stuff that's directly in templates
23:38:33 <srid> at least the JS doesn't run on chrome browser here.
23:38:40 <nshepperd_> if pandoc does it that makes sense
23:38:56 <kadoban> Yeah I'm relatively sure it's a pandoc thing
23:40:04 <srid> so this only happens if the user has JS disabled, which is an unlikely scenario. normal users get the email rendered as is. and bots don't get to scrap the actual email (except it is shown in the front page)
23:42:33 <kadoban> Ya, probably doesn't matter. I didn't realize it was because I have js disabled or I wouldn't have mentioned it.
23:42:33 <srid> why do you disable JS? just for performance? or to block some annoyance? how big is your white list? 
23:42:52 <kadoban> Mostly as part of advertising avoidance/malware prevention. Pretty big whitelist by now I'm sure, heh.
23:45:35 <srid> dailymail is the mostly annoying site to me. with all those sidebar celebrity distractions. 
