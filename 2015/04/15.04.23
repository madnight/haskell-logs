00:00:00 <srhb> That is, the ``
00:00:09 <tejing> nak: (x:) == (\xs->x:xs), so it prepends x onto a list
00:00:21 <tejing> > ('a':) "bc"
00:00:22 <lambdabot>  "abc"
00:00:24 <nak> srhb what about a function that takes 3 arguments? like: quad a b c
00:00:46 <srhb> nak: You can either section the first two or apply one and section the last two
00:01:10 <nak> ah
00:01:18 <srhb> nak: (`foo` 1) 2 3 vs (`foo 1` 2) 3 
00:01:18 <nak> tejing i think that might be a little bit over my head right now
00:01:36 <srhb> nak: Remember, if foo takes three functions, foo 1 takes two :)
00:01:39 <srhb> er
00:01:42 <srhb> three arguments
00:01:42 <kadoban> nak: Mostly you only see it for operators (which are all binary operators)
00:02:23 <nak> srhb right, i got that part. very cool
00:02:29 <nak> no wonder you guys are all so happy in here
00:02:38 <nak> haskell is like a dream come true
00:02:45 <srhb> It's like candy land for programmers. :-)
00:02:48 <nak> y'all are living the dream
00:02:52 <nak> lol
00:03:08 <nak> candλland
00:03:18 <kadoban> hah
00:03:22 <srhb> Better to replace the 'l' :P
00:03:30 <nak> ah true haha
00:03:36 <nak> candyλand
00:04:44 <nak> ok so, map
00:04:46 <nak>  :: (a->b) -> [a] -> [b]
00:04:59 <nak> i'm having trouble understanding the syntax there
00:05:18 <srhb> nak: Takes two arguments, a function from a to b, and a list of a
00:05:23 <srhb> And produces a list of b
00:05:33 <nak> oh !
00:05:40 <tejing> >map (+2) [1,2,3]
00:05:50 <tejing> oops
00:05:57 <tejing> > map (+2) [1,2,3]
00:05:59 <lambdabot>  [3,4,5]
00:06:00 <nak> tejing yeah i undersatnd how it works, just the :: ... part
00:06:07 <tejing> ah
00:06:17 <nak> tejing i did 
00:06:22 <nak> > map (+5) [1,2,3]
00:06:24 <lambdabot>  [6,7,8]
00:06:36 <nak> and that's when the (+5) just *poof*... brains on the wall
00:06:52 <tejing> hehe
00:06:57 <srhb> nak: And in that case, a ~ b (type equality)
00:07:13 <nak> at first i was thinking (+5) was a sugared syntax for (lambda (x) (+ x 5)) 
00:07:27 <nak> forgive my scheme usage there, i don't know how to represent a lambda in haskell yet
00:07:37 <srhb> \x -> x + 5
00:07:46 <srhb> Is what it is
00:07:49 <nak> ah ok
00:07:50 <kadoban> nak: It pretty much is
00:08:12 * hackagebot engine-io-growler 0.1.0.0 -   http://hackage.haskell.org/package/engine-io-growler-0.1.0.0 (IanDuncan)
00:08:12 * hackagebot engine-io-growler 0.1.0.1 -   http://hackage.haskell.org/package/engine-io-growler-0.1.0.1 (IanDuncan)
00:08:38 <srhb> > ((\x -> x + 5) 2, (+5) 2)
00:08:40 <lambdabot>  (7,7)
00:08:54 <nak> yeah
00:09:08 <nak> very neat
00:09:14 <nak> they effectively do the same thing, 
00:09:15 <srhb> Of course, it's a bad operator for explaining sections because of commutativity, but I think you've got it. :)
00:09:17 <nak> but!
00:09:23 <nak> yeah
00:09:26 <nak> exactly
00:09:33 <HEGX64> the '\' is instead of 'λ'
00:10:08 <nak> today is a remarkable day for me
00:10:10 <kadoban> Yeah, it's supposed to vaguely look like a lambda symbol. Which … it mostly doesn't, heh.
00:10:19 <tejing> '\' precedence always trips me up, so I've taken to always wrapping it in parens or putting a $ before it
00:11:01 <igniting> :t 5 (+)
00:11:02 <lambdabot> (Num a, Num ((a -> a -> a) -> t)) => t
00:11:10 <igniting> :t (5+)
00:11:11 <lambdabot> Num a => a -> a
00:11:34 <nak> :t (+5)
00:11:35 <lambdabot> Num a => a -> a
00:11:47 <nak> :t (+)
00:11:48 <lambdabot> Num a => a -> a -> a
00:12:12 <nak> so that's saying `a` has to be of type Num ?
00:12:18 <srhb> Has to implement the Num type class
00:13:08 * hackagebot conversion 1.1.0.0 - Universal converter between values of different types  http://hackage.haskell.org/package/conversion-1.1.0.0 (NikitaVolkov)
00:13:08 <srhb> nak: You can ask ghci about it with :info Num (or :i Num for short)
00:13:10 * hackagebot conversion-bytestring 1.0.0.0 - "Conversion" instances for the "bytestring" library  http://hackage.haskell.org/package/conversion-bytestring-1.0.0.0 (NikitaVolkov)
00:13:10 <igniting> what'
00:13:18 <igniting> oops, what's 5 (+) ?
00:13:31 <srhb> igniting: Not meaningful. You're claiming 5 is a function
00:13:43 <nak> :t 5
00:13:43 <frerich> :t 5 (+)
00:13:44 <lambdabot> Num a => a
00:13:44 <lambdabot> (Num a, Num ((a -> a -> a) -> t)) => t
00:14:02 <nak> 5 is a function? seriously?
00:14:08 <igniting> yeah, thought so.
00:14:09 <ElMoloko> :D
00:14:10 <srhb> Nope.
00:14:18 <kadoban> igniting: Heh. You know how 5 is  :: Num a => a  ?    Well, it doesn't care there that that doesn't make sense. It says "hey 5 must be a function, since you're using it like one … but 5 is a Num, so … okay, here's your useless type signature!
00:14:38 <kadoban> nak: Not really, no. It's kinda just a goofy quirk of integer literals.
00:14:39 <ElMoloko> it's a first class citizen
00:14:49 <nak> ok
00:14:51 <srhb> nak: But that is the only way to parse it. The type system will since say that it cannot find a Num instance for type (a -> a -> a) where a also implements Num
00:14:58 <srhb> > 5 (+)
00:14:59 <lambdabot>      Could not deduce (Num a0)
00:15:00 <lambdabot>      from the context (Num a, Num ((a -> a -> a) -> t))
00:15:00 <lambdabot>        bound by the inferred type for ‘e_15’:
00:15:00 <srhb> Boom
00:15:31 <nak> srhb can you elaborate on "Boom"
00:15:31 <tejing> well you might theoretically be able to write a Num instance such that that expression makes sense... would be a very weird instance though
00:15:36 <srhb> nak: Boom -- breaks!
00:15:40 <nak> srhb what have you demonstrated there tho?
00:15:48 <srhb> nak: That it does not type check.
00:15:52 <igniting> so, (+) 5 and (+5) are same, I thought of trying that with (5+) and 5 (+)
00:16:10 <srhb> igniting: No, those are subtly different
00:16:13 <kadoban> nak: Honestly, it's not something you should really worry about yet. It's not terribly profound or useful, it's just a quirk that will make sense later when you understand the type system more
00:16:22 <tejing> igniting: it works with (+) 5 because functions are normally specific in prefix notation
00:16:31 <srhb> igniting: (+) 5 is (\x -> 5 + x) and (5+) is (\x -> x + 5)
00:16:44 <tejing> igniting: there is no way to do postfix notation really
00:16:54 <tejing> specified*
00:16:54 <srhb> igniting: Instead, (+) 5 is equivalent to (5+)
00:17:16 <igniting> srhb: yes, got that.
00:18:08 * hackagebot conversion-text 1.0.0.0 - "Conversion" instances for the "text" library  http://hackage.haskell.org/package/conversion-text-1.0.0.0 (NikitaVolkov)
00:18:10 * hackagebot conversion-case-insensitive 1.0.0.0 - "Conversion" instances for the "case-insensitive" library  http://hackage.haskell.org/package/conversion-case-insensitive-1.0.0.0 (NikitaVolkov)
00:18:28 <nak> in this :: (a -> b) -> [a] -> [b]
00:18:34 <srhb> nak: You can save this for later https://wiki.haskell.org/Num_instance_for_functions
00:18:35 <nak> how does 'a' differ from 'b' 
00:18:44 <srhb> nak: It only says that a and b can be different
00:18:45 <jle`> nak: they are just type variables
00:18:57 <Lokathor> nak it might or might not be different, but could be the same
00:19:00 <srhb> nak: (a -> a) -> [a] -> [a] would be a more restrictive function
00:19:13 <srhb> nak: If map had that signature, we could not do...
00:19:17 <srhb> > map show [1,2,3]
00:19:18 <lambdabot>  ["1","2","3"]
00:19:19 <jle`> you could also do :: (type1 -> type2) -> [type1] -> [type2]
00:19:20 <srhb> :t show
00:19:21 <lambdabot> Show a => a -> String
00:19:22 <kadoban> (z -> q) -> [z] -> [q]     would be the same function
00:19:33 <jle`> or :: (foo -> bar) -> [foo] -> [bar]
00:19:34 <srhb> Because whereas a is some Num-implementing type, String is not.
00:19:36 <jle`> nothing inherently special about x and y
00:19:48 <Lokathor> "if you give me a thing that takes an 'a' to a 'b', and a list of 'a', i can make you a new list of 'b'"
00:19:49 <jle`> i mean, a and y
00:19:51 <srhb> Or more directly, String and Num a are different
00:20:35 <tejing> nak: if you're familiar with quantifiers in math you could say there's an invisible "for all types a, for all types b," on the front.
00:21:05 <nak> not familiar with quantifiers, but the other explanations helped clear it up quite a bit
00:21:14 <srhb> > let badMap = map :: (a -> a) -> [a] -> [a] in badMap show [1,2,3]
00:21:15 <lambdabot>      No instance for (Num String) arising from the literal ‘1’
00:21:16 <lambdabot>      In the expression: 1
00:21:16 <lambdabot>      In the second argument of ‘badMap’, namely ‘[1, 2, 3]’
00:21:17 <srhb> :(
00:21:26 <jle`> if you've ever written another programming language, it's like asking what is the differenve between x and y in function foo(x, y) { ... }
00:21:48 <masse> I'm testing type families and typelits. I have a basic list (DList a k) where k is a typelevel integer designating the size of the list. The cons operator is defined as `(:|) :: a -> DList a k -> DList a (k+1)`. I have `head :: (k > 0) => DList a k -> a` working as intended, but I'm having trouble with tail. `tail :: (k > 0) => DList a k -> DList a (k-1)` complains that "Could not deduce (k1 ~ (k - 1))"
00:22:41 <nak> > show 1
00:22:42 <lambdabot>  "1"
00:22:44 <srhb> :t show
00:22:45 <lambdabot> Show a => a -> String
00:22:56 <nak> OH
00:23:02 <nak> srhb ok i was wondering why it was blowing up
00:23:07 <nak> and it's because show outputs string
00:23:07 <srhb> nak: Right :)
00:23:08 <nak> got it
00:23:08 * hackagebot conversion 1.1.0.1 - Universal converter between values of different types  http://hackage.haskell.org/package/conversion-1.1.0.1 (NikitaVolkov)
00:23:19 <nak> unbelievable 
00:23:26 <nak> this is the coolest language ever
00:23:34 <nak> i'm gonna say that 100 more times at least
00:23:36 <nak> sorry
00:23:37 <srhb> nak: You will believe that for a few months, sure. :-)
00:24:00 <kadoban> Yep :) https://github.com/bitemyapp/learnhaskell has some good learning advice, by the way. Especially cis194
00:24:13 <srhb> nak: And #haskell-beginners goes well with that.
00:24:15 <Lokathor> it's cool right up until you try to get your sandbox to compile your project >_>
00:24:30 <kadoban> Lokathor: Heh, it's not that bad XD
00:24:40 <srhb> Lokathor: I was thinking more like the inevitable "but can I have dependent types?" :-)
00:24:55 <masse> Lokathor: nah, the problem comes with trying to recompile the project after it hasn't been touched in 6 months
00:24:56 <Lokathor> srhb, don't even know what those are
00:25:00 <Lokathor> "magic", i assume
00:25:07 <srhb> Yes, let's keep it at that for now. :-)
00:26:50 <tejing> I'm trying to write a program to determine the asymptotic probabilities of landing on particular locations in monopoly (the board game), and while I can solve it by finding the eigenvectors of a large matrix, I'm having trouble generating that matrix in a readable way. I'd sort of like to use some kind of List-like monad to accumulate a probability distribution, but it seems like overkill to write my own monad. Any suggestions on a simpler way
00:27:17 <srhb> tejing: There was a question on SO about legible matrix generations yesterday, maybe it has gotten some nice answers
00:27:45 <Lokathor> you mean the odds of landing on any space ever?
00:28:20 <srhb> Hmm, can't seem to find the question.
00:28:22 <arkeet> > 0/0 == 0/0
00:28:24 <lambdabot>  False
00:28:37 <tejing> Lokathor: I mean the limit of the probability distribution for a piece location after infinite turns
00:28:58 <nak> > 0/0
00:28:59 <lambdabot>  NaN
00:29:13 <srhb> nak: Those equality rules are defined in IEEE Floating Point. 
00:29:56 <nak> yeah with me coming from js. that's not surprsing
00:30:07 <jle`> tejing: there are probability monads, but i'm not sure if that's what you want here
00:30:14 <jle`> sounds like you just want a big sparse matrix representation?
00:30:17 <nak> just curious how haskell represented NaN. turns out it's the same :)
00:30:29 <Lokathor> tejing, are you trying to account for jail and rent and cards and stuff?
00:30:30 <kadoban> :t (0/0)
00:30:31 <lambdabot> Fractional a => a
00:31:00 <joneshf-laptop> nak,  srhb http://stackoverflow.com/questions/29805771/what-is-the-linguistic-way-to-program-matrices-on-haskell
00:31:02 <joneshf-laptop> ?
00:31:04 <jle`> tejing: if so, you might be able to just build an IntMap (IntMap Double)
00:31:11 <jle`> which is fairly clean maybe.
00:31:24 <srhb> joneshf-laptop: Yes, that. See joneshf-laptop's link, tejing 
00:31:36 <srhb> (Not for nak) :-)
00:31:40 <joneshf-laptop> oh sorry
00:31:59 <srhb> But yeah, the question is not really answered yet. Meh.
00:34:42 <tejing> Lokathor: yes, I'm trying to account for all that, but my problem isn't the matrix arithmetic itself... it's encoding the logic of a single turn in a readable way
00:35:14 <nak> joneshf-laptop lol yeah that's over my head as a person that just started learning haskell ≈2 hours ago
00:35:22 <schoppenhauer> hi. is there an implementation of http://www.usma.edu/eecs/SiteAssets/SitePages/Faculty%20Publication%20Documents/Okasaki/focs95cat.pdf (or similar) in haskell?
00:35:25 <jle`> maybe fgl might offer something for you too tejing 
00:35:26 <joneshf-laptop> nak, sorry, wrong mention,
00:35:33 <jle`> but i think the IntMap (IntMap Double) might be easy to build
00:35:51 <srhb> tejing: Is this useful, perhaps? https://idontgetoutmuch.wordpress.com/2014/06/15/gibbs-sampling-in-haskell/
00:36:18 <Lokathor> tejing, so it sounds like what you need is some Monopoly AIs? And run a bunch of simulations until you get approximate answers. Unless you need precise ones for some reason.
00:36:35 <frerich> jle`: I'm currently working on a turn-based game (think 'Memory') in which players can either be local, CPU-controlled or connect via TCP/IP; i.e. the method for getting a move from some player differs. That sounds like a good use case for 'auto', doesn't it?
00:36:50 <frerich> I'd like to not fall back to some callback-driven system...
00:37:30 <schoppenhauer> I'm asking this because ... if not, I'd have to write it myself, which I can do, but would be ... work.
00:37:48 <jle`> frerich: you know, i really believe so. the game logic can definitely be modeled with Auto well, i believe.  i've been working on some proof of concepts.  i've also tried having auto drive the matchmaking/connection/server things but i'm still working on a solid poc for that
00:37:57 <jle`> i had a nice connect4 implementation
00:38:07 <srhb> schoppenhauer: Is this related to DLists?
00:39:06 <jle`> tejing: fromList $ [(spot1, fromList [(spot2, 0.2), (spot3, 0.4), ...]), ... ], for example
00:39:27 <jle`> then you don't have to have all those 0's
00:39:53 <Lokathor> is that $ not a normal $ there?
00:40:04 <jle`> between like St. James place and Boardwalk
00:40:15 <jle`> Lokathor: no heh, it was an unnecessary $
00:40:22 <Lokathor> oh
00:40:23 <Lokathor> ha
00:41:02 <jle`> frerich: i want to say yes, it's a good application.  but i wish at this point i could point you to some concrete examples
00:41:12 <schoppenhauer> srhb: well, I can probably try to use DLists for the same purpose (though, not sure what O(spine) means), not sure if they are related but they have similar bounds.
00:41:17 <schoppenhauer> srhb: thx.
00:41:46 <srhb> schoppenhauer: My CompSci is bad, so I'm not sure how closely related they are, sorry. I hope perhaps the term can help you find the right answer. :)
00:41:47 <jle`> tejing: i'd be cleaner on multiple lines :) but you're basically declaring a tree this way, sorta
00:41:52 <tejing> what I'd like is the ability to write sequentail/branching code for what to do on a particular turn. in pseudocode: "do {if onchance then do {card <- chancecards;do etc} else do {etc}"
00:41:58 <jle`> oh
00:42:07 <jle`> interesting
00:42:30 <jle`> i think probability monad can help you with that
00:42:34 <schoppenhauer> ah, append takes O(1) (misread that) → it is what I am searching for
00:42:35 <srhb> tejing: Is this really anything more than a State monad with some nice combinators?
00:42:50 <jle`> if you have a bunch of `Space -> Probability Double Space`
00:43:01 <jle`> you could write a function [Space] -> Matrix Double
00:43:10 * hackagebot objective 1.0.4 - Composable objects  http://hackage.haskell.org/package/objective-1.0.4 (FumiakiKinoshita)
00:43:12 <srhb> schoppenhauer: Perfect :)
00:43:12 * hackagebot getopt-generics 0.6.1 - Simple command line argument parsing  http://hackage.haskell.org/package/getopt-generics-0.6.1 (SoenkeHahn)
00:43:23 <jle`> and then find the eigenvectors on that
00:43:38 <jle`> probability monads exactly like the one you want are well-established in literature
00:43:54 <jle`> i am sure there is a canonical hackage one somewhere...
00:44:02 <tejing> jle`: yea that's pretty much what I'm looking for
00:44:07 <jle`> Probability Double a ~ [(Double, a)]
00:44:47 <jle`> yeah.  if you can write a `Space -> Prob Double Space` function, then you could easily create the dense matrix
00:44:59 <jle`> and then eigen the crap out of it
00:45:42 <jle`> (making sure you normalize your probabilities)
00:45:53 <jle`> (which i presume the probability monad would handle)
00:47:53 <Zemyla> Huh.
00:47:56 <Zemyla> :t Data.Coerce.coerce `asTypeOf` fmap
00:47:56 <tejing> looks like I want the 'probability' package
00:47:57 <lambdabot> (GHC.Types.Coercible b (f b), GHC.Types.Coercible a (f a), Functor f) => (a -> b) -> f a -> f b
00:48:22 <jle`> Zemyla: that's cute :)
00:51:59 <shachaf> Zemyla: That was a lot of the original motivation for coerce, wasn't it?
00:53:11 * hackagebot html-tokenizer 0.2.1.1 - An "attoparsec"-based HTML tokenizer  http://hackage.haskell.org/package/html-tokenizer-0.2.1.1 (NikitaVolkov)
00:53:58 <arkeet> :t const coerce `asTypeOf` fmap
00:53:59 <lambdabot> (Functor f, Contravariant f) => (a -> b) -> f a -> f b
00:54:07 <arkeet> :t const Data.Coerce.coerce `asTypeOf` fmap
00:54:08 <lambdabot> (GHC.Types.Coercible (f b) (f a), Functor f) => (a -> b) -> f a -> f b
00:54:23 <mikeplus64> :t coerce
00:54:24 <lambdabot> (Functor f, Contravariant f) => f a -> f b
00:54:26 <nak> > let (a,b) = (10,12) in a * 2
00:54:28 <lambdabot>  20
00:54:49 <nak> how does "pattern matching" relate to "destructuring assignment" ?
00:54:51 <nak> similar?
00:55:15 <arkeet> that is another case of pattern matching.
00:55:29 <mikeplus64> > let Just a = Nothing in ()
00:55:31 <lambdabot>  ()
00:55:35 <mikeplus64> > case Nothing of Just a -> ()
00:55:36 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
00:55:52 <mikeplus64> that's the only difference I can think of
00:55:52 <arkeet> let pat = expr in ... is the same as
00:56:24 <arkeet> uh.
00:56:34 <jle`> case expr of pat -> ... ?
00:56:42 <arkeet> case expr of ~pat -> ...
00:56:46 <jle`> ah
00:56:50 <merijn> nak: It's basically the same, with the major difference being the "assignment" part, which implies assigning to a variable which is not possible in haskell :)
00:56:57 <Zemyla> > let Just a = Nothing in a
00:56:58 <lambdabot>  *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Just a
00:57:02 <mikeplus64> > case Nothing of ~(Just a) -> ()
00:57:03 <lambdabot>  ()
00:57:10 <mikeplus64> :)
00:57:18 <arkeet> > let Just a = Nothing in 5
00:57:20 <lambdabot>  5
00:57:27 <nak> merijn ah... ok i thought there was something up re: assignment
00:57:35 <nak> i was beginning to suspect that assigning vars was not possible lol
00:57:43 <nak> radical stuf !
00:57:45 <merijn> nak: Also, I think pattern matching is more general/powerful than destructuring assignment
00:57:47 <arkeet> = is definition, not assignment.
00:58:06 <nak> merijn yeah, i just did 
00:58:11 * hackagebot list-t-attoparsec 0.2.0.0 - An "attoparsec" adapter for "list-t"  http://hackage.haskell.org/package/list-t-attoparsec-0.2.0.0 (NikitaVolkov)
00:58:13 * hackagebot list-t-libcurl 0.2.0.0 - A "libcurl"-based streaming HTTP client  http://hackage.haskell.org/package/list-t-libcurl-0.2.0.0 (NikitaVolkov)
00:58:15 * hackagebot list-t-text 0.1.0.1 - A streaming text codec  http://hackage.haskell.org/package/list-t-text-0.1.0.1 (NikitaVolkov)
00:58:16 <jle`> like when you say pi = 3.14, you're saying, "anywhere you see pi in my code, you can just pop in 3.14 instead."  you're defining pi as 3.14
00:58:31 <motox> does anyone know a good reference, I am trying to get a list of macros from a program?  I have read through Learn You a Haskell for Great Good and I can't figure it out.
00:58:33 <nak> > let (a : b : c : []) = "xyz" in a
00:58:35 <lambdabot>  'x'
00:58:40 <mikeplus64> > let pi = 3.14 in let pi = 4 in pi
00:58:42 <lambdabot>  4
00:58:50 <merijn> motox: What do you mean by a "list of macros"?
00:58:51 <jle`> if you say pi = 3.14 and then later on say pi = 3...it's like...okay, what are you, a liar?
00:58:52 <mikeplus64> (that's just shadowing)
00:59:09 <arkeet> > let 2 + 2 = 5 in 2 + 2
00:59:11 <lambdabot>  5
00:59:15 <mikeplus64> > let pi = 3.14 in (let pi = 4 in pi, pi)
00:59:16 <lambdabot>  (4,3.14)
00:59:33 <bitemyapp> arkeet: hi
00:59:34 <mikeplus64> > (let pi = 3.14 in (let pi = 4 in pi, pi), pi)
00:59:36 <lambdabot>  ((4,3.14),3.141592653589793)
00:59:38 <arkeet> bitemyapp: hi
00:59:49 <nak> arkeet ok wow how is that possible
00:59:55 <arkeet> nak: I redefined (+).
01:00:00 <merijn> nak: You're defining a new +
01:00:06 <merijn> > let 2 + 2 = 5 in 2 + 3
01:00:07 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
01:00:14 <motox> I'm trying to define a function - macros:: Prog -> [Macro]
01:00:31 <nak> hmm
01:00:32 <arkeet> motox: you'll have to explain what Prog and Macro are.
01:00:35 <jle`> > let 2 +*++*++*++* 2 = 5 in 2 +*++*++*++* 2
01:00:37 <lambdabot>  5
01:00:51 <merijn> nak: You're defining a new (+) function which says that "2 + 2" - 5, however you're not defining any other cases so anything else crashes
01:01:06 <nak> oh weird !
01:01:25 <jle`> it's called "shadowing"...if something is defined in the "let ... in" part, in the ensuing part after the 'in', it'll always refer to that thing as top priority
01:01:27 <nak> > let a + b = 5 in 2 + 2
01:01:29 <lambdabot>  5
01:01:31 <srhb> nak: Partial functions are bad, and partial confusing functions are worse. :P
01:01:34 <nak> holy smokes 
01:01:37 <nak> that's so cool
01:01:37 <merijn> nak: Remember that haskell allows you to define your own operator functions (as long as you use names consisting only of characters allowed for operators in the report)
01:01:54 <jle`> it's just confusing because you gave it a name (+) that happens to corresponding to a name that is commonly used in normal code
01:02:04 <merijn> > let x ☃ y = x*x + y*y in 3 ☃ 4 -- whoo! Snowman operator
01:02:04 <jle`> but you can name it something else, like `f`, and it is clearer
01:02:05 <lambdabot>  25
01:02:09 <mikeplus64> > (let a+b = 5 in 2+2, 2+2) -- ~shadowing~
01:02:10 <lambdabot>  (5,4)
01:02:11 <srhb> The well known snowman operator.
01:02:11 <jle`> > let f 2 2 = 5 in f 2 2
01:02:13 <lambdabot>  5
01:02:29 <mikeplus64> Control.Lens.Snowman
01:02:31 <bitemyapp> mikeplus64: good example
01:02:32 <jle`> here we're defining a function called `f` that is `f 2 2 = 5`.  so when we call `f 2 2`, we get 5.
01:02:40 <srhb> mikeplus64: I think it belongs in ACME :P
01:02:47 <srhb> But I'm a purist like that.
01:02:52 <mikeplus64> lol
01:02:54 <merijn> srhb: Check out Acme.LookOfDisapproval :)
01:02:59 <srhb> merijn: Seen it. :P
01:03:01 <nak> merijn ok snowman operator example makes it very clear
01:03:11 * hackagebot list-t-http-client 0.1.0.1 - A streaming HTTP client  http://hackage.haskell.org/package/list-t-http-client-0.1.0.1 (NikitaVolkov)
01:03:13 * hackagebot list-t-html-parser 0.1.0.0 - Streaming HTML parser  http://hackage.haskell.org/package/list-t-html-parser-0.1.0.0 (NikitaVolkov)
01:03:26 <merijn> nak: You can define operators as prefix too, but infix is usually nicer
01:03:35 <arkeet> merijn: haha.
01:03:37 <merijn> > let (☃) x y = x - y in 5 ☃ 2
01:03:39 <lambdabot>  3
01:03:51 <nak> yeah i thought infix had to be deinfed like this ^
01:04:07 <nak> so that's where i was a little confused at first
01:04:11 <jle`> merijn: i feel like (ಠ_ಠ) could be defined in a way to reflect its disapproval in the error message
01:04:29 <nak> but the thing that is really different, is having the Num literals there
01:04:35 <jle`> time to pull request
01:04:38 <nak> it's cool that you can override like that
01:04:45 <arkeet> nak: it's just pattern matching on numeric literals.
01:04:47 <srhb> nak: The other way works as well. There's no override.
01:04:49 <jle`> you're not overriding the num literals here
01:04:52 <merijn> nak: I can recommend reading the Haskell Report, it's one of the most readable language specs and it teaches you all sorts of subtleties about syntax most books skips. Haskell syntax is more flexible than people think
01:04:53 <nak> > let 5 = 10 in 5 * 5
01:04:55 <lambdabot>  25
01:05:01 <srhb> > let x `foo` y = x+y in foo 1 2
01:05:02 <lambdabot>  3
01:05:07 <arkeet> f 2 2 = 5 is the same as
01:05:08 <jle`> you can't "override" Num literals :3
01:05:11 <arkeet> f x y | x == 2, y == 2 = 5
01:05:25 <merijn> nak: You've probably already seen numeric literals in patterns, though
01:05:45 <arkeet> > let fac 0 = 1; fac n = n * fac (n-1) in fac 6
01:05:47 <lambdabot>  720
01:05:54 <merijn> nak: Think about "drop :: Int -> [a] -> [a]; drop 0 xs = xs; drop n (x:xs) = drop (n-1) xs"
01:06:22 <nak> let f 2 2 = 20 in f 1 2
01:06:29 <nak> > let f 2 2 = 20 in f 1 2
01:06:31 <lambdabot>  *Exception: <interactive>:3:5-14: Non-exhaustive patterns in function f
01:06:31 <merijn> nak: The report specifices that numeric patterns get desugared into guards with equality comparisons like arkeet's example
01:06:39 <motox> arkeet: I am working with Mini Logo and have type Prog = [Cmd]  so that Prog is a list of commands and I have defined  data Cmd as Def Macro [Var] Prog where type Macro = String
01:06:47 <nak> ah !
01:06:47 <nak> ok
01:06:49 <jle`> > let f 1 2 = 10; f 2 2 = 20 in f 1 2
01:06:51 <lambdabot>  10
01:06:54 <merijn> "f 2 2 = 5" -> "f x y | x == 2, y == 2 = 5"
01:07:07 <nak> ok this is becoming more clear
01:07:18 <jle`> > let f 1 2 = 10; f 2 2 = 20; f x y = x*y in f 3 9
01:07:19 <lambdabot>  27
01:07:27 <arkeet> :t let f 1 = () in f
01:07:28 <lambdabot> (Eq a, Num a) => a -> ()
01:07:36 <arkeet> hence the Eq constraint here ^%
01:07:37 <arkeet> ^
01:07:38 <merijn> nak: Note the Eq constraint above
01:07:45 <merijn> Actually, that's a GHC-ism :p
01:07:52 <arkeet> well, yeah.
01:07:58 <merijn> The report says that Eq is a superclass of Num, but GHC doesn't obey the report there
01:08:05 <arkeet> the report is wrong!
01:08:08 <merijn> Because you may want Num instances that don't support sane equality
01:09:05 <motox> arkeet: so now I am trying to be able to load the module and type macros <name of a prog> and get a list of the macros inside that prog
01:09:33 <lieven> merijn: can you give an example of such a Num instance?
01:09:45 <merijn> lieven: Num instance for functions
01:09:46 <arkeet> lieven: instance Num a => Num (r -> a)
01:10:43 <lieven> where the arithmetic operations are pointwise. true.
01:11:17 <jle`> @let instance Num a => Num (r -> a) where f + g = \x -> f x + g x; f * g = \x -> f x * g x; f - g = \x -> f x - g x; negate f = negate . f; abs = abs . f; signum = signum . f; fromInteger x = const (fromInteger x)
01:11:19 <lambdabot>  .L.hs:159:21:
01:11:19 <lambdabot>      Could not deduce (Show r) arising from a use of ‘f’
01:11:19 <lambdabot>      from the context (Num a)
01:11:52 <jle`> something like that would probably have been worth testing in pvt first
01:12:27 <arkeet> I thought Show wasn't a superclass of Num.
01:12:34 <arkeet> so I don't understand that message.
01:12:43 <lieven> yeah I get it. mathematically equality is defined for such instances. It's just not decidable.
01:12:46 <jle`> oh
01:12:49 <jle`> someone defined f
01:12:51 <arkeet> oh.
01:12:53 <arkeet> haha
01:12:56 <jle`> @let instance Num a => Num (r -> a) where f + g = \x -> f x + g x; f * g = \x -> f x * g x; f - g = \x -> f x - g x; negate f = negate . f; abs = abs . f; signum f = signum . f; fromInteger x = const (fromInteger x)
01:12:57 <bitemyappPrime> @ty f
01:12:57 <srhb> Meanies. :/
01:12:57 <lambdabot>  .L.hs:159:21:
01:12:57 <lambdabot>      Could not deduce (Show r) arising from a use of ‘f’
01:12:58 <lambdabot>      from the context (Num a)
01:12:58 <lambdabot> FromExpr a => a
01:13:00 <jle`> because why not
01:13:05 <arkeet> also
01:13:07 <arkeet> you need to fix your abs
01:13:11 <bitemyappPrime> f is defined because the magic library Twan wrote is in scope.
01:13:20 <jle`> @let instance Num a => Num (r -> a) where f + g = \x -> f x + g x; f * g = \x -> f x * g x; f - g = \x -> f x - g x; negate f = negate . f; abs f = abs . f; signum f = signum . f; fromInteger x = const (fromInteger x)
01:13:22 <lambdabot>  Defined.
01:13:24 <bitemyappPrime> > foldr f 0 [1..5]
01:13:26 <lambdabot>      No instance for (Show a0)
01:13:26 <lambdabot>        arising from a use of ‘show_M9974530070701493838960’
01:13:26 <lambdabot>      The type variable ‘a0’ is ambiguous
01:13:29 <bitemyappPrime> SERIOUSLY
01:13:38 <arkeet> > sum [(+1),(*10)] 2
01:13:40 <lambdabot>  23
01:13:41 <bitemyappPrime> fuck it I give up
01:13:51 <arkeet> > foldr f 0 [1..5] :: Expr
01:13:53 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 0))))
01:14:23 <bitemyappPrime> arkeet: thank you
01:14:26 <arkeet> np
01:14:29 <bitemyappPrime> it's 0313 and I am rapidly losing sanity
01:14:39 <arkeet> > foldr (f :: Expr -> Expr -> Expr) 0 [1..5] 
01:14:40 <jle`> > map (sin^2 + cos^2) [1..10]
01:14:41 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 0))))
01:14:41 <lambdabot>  <no location info>: can't find file: L.hs
01:14:44 <arkeet> sorry.
01:14:47 <jle`> > map (sin^2 + cos^2) [1..10]
01:14:48 <lambdabot>  [1.0,1.0,0.9999999999999999,1.0,0.9999999999999999,0.9999999999999999,0.9999...
01:14:57 <jle`> :(
01:15:03 <arkeet> that instance is in NumInstances anyway.
01:15:44 <arkeet> it kind of sucks that div and toInteger are in the same class.
01:15:53 <arkeet> since div makes sense for a lot of things that aren't integers.
01:16:17 <arkeet> like functions. or euclidean domains I guess.
01:16:36 <jle`> yeah toInteger prevents a lot of cute instances i've wanted to write
01:16:43 <jle`> sad life
01:16:54 <arkeet> well, same goes for abs and signum.
01:17:01 <jle`> nah abs and signum are aigh't
01:17:16 <arkeet> how do you write abs for Complex Rational
01:17:25 <jle`> UMM
01:17:48 <jle`> yeah :/
01:18:05 <jle`> i've written a lot of nonsensical signum/abs implementations
01:18:49 <jle`> all for the sake of that elusive group
01:18:57 <jle`> *ring
01:19:18 <lpaste> motox pasted “Can't get a list of macros” at http://lpaste.net/131290
01:19:45 <motox> I hope that helps
01:23:13 * hackagebot list-t 0.4.5 - ListT done right  http://hackage.haskell.org/package/list-t-0.4.5 (NikitaVolkov)
01:23:32 <kadoban> motox: The type of toMacro doesn't seem to make any sense? Shouldn't it be  Cmd -> Macro ?
01:25:20 <motox> kadoban: I'm not sure.  I'm new to Haskell and trying to make sense of it.  That does seem logical though
01:26:28 <kadoban> motox: Yeah, the macros part seems to make sense to me, and isMacro, but then toMacro is the odd man out.
01:28:40 <kadoban> motox: Note also that isMacro should really have a False case :) Otherwise your program will just crash instead of False, heh. Partial functions are kinda icky. toMacro has the same kind of problem, even when implemented correctly, but for how you're using it, it'll work anyway. (A more rigorously correct way to go might be something like toMacro :: Cmd -> Maybe Macro), but that might be for later if none of that made sense. Just thought I'd 
01:28:42 <kadoban> mention.
01:29:14 <motox> kadoban: would it be Cmd -> [Macro] because I am trying to put the macros in a list?
01:29:49 <kadoban> motox: I don't believe so.   Remember the type of map:
01:29:50 <kadoban> :t map
01:29:51 <lambdabot> (a -> b) -> [a] -> [b]
01:31:33 <motox> kadoban: ahhhh, thank you I forgot about that.  Types have been kicking my tail lately
01:31:42 <kadoban> motox: (Cmd -> Macro) -> [Cmd] -> [Macro]   would make sense, right?  If you have Cmd -> [Macro], like if each Cmd could potientially define several macros, that would make sense and you could write based on that, but … it'd be different
01:32:04 <arkeet> well, from the looks of it, a Cmd may contain no macros.
01:32:59 <kadoban> arkeet: Yeah … which could make Cmd -> [Macro] make sense, but Cmd -> Maybe Macro makes more sense there … I just think maybe as a first step he might not want to care about that.
01:33:30 <arkeet> well, Cmd -> Macro would be a partial function.
01:35:35 <kadoban> Yes. Which isn't 100% ideal (and I did mention that earlier). But if he's strugling to get it working as-is, it probably makes sense to ignore that as a rough draft *shrug*.
01:35:56 <arkeet> okay.
01:38:13 * hackagebot list-t-libcurl 0.2.0.1 - A "libcurl"-based streaming HTTP client  http://hackage.haskell.org/package/list-t-libcurl-0.2.0.1 (NikitaVolkov)
01:40:14 <motox> kadoban: at compile I get 3 errors because of type.  two are could not match type Cmd with [Cmd] in isMacro and in toMacro
01:41:29 <motox> the third was could match expected type [Macro] -> [Macro] with actual type [Char]
01:41:51 <kadoban> motox: Paste code? Or you talking about with the code above? 'cause the above code definitely won't typecheck.
01:43:13 * hackagebot network-api-support 0.2.0 - Toolkit for building http client libraries over Network.Http.Conduit  http://hackage.haskell.org/package/network-api-support-0.2.0 (MarkHibberd)
01:43:26 <motox> kadoban: the pasted code from earlier with the Cmd -> Macro change
01:44:24 <kadoban> motox: Well, you have to change the code too, line 36 is not the right type at all.
01:46:17 <motox> kadoban: that doesn't match the condition in the Cmd definition?  
01:47:18 <kadoban> motox: I don't think I understand the question. Probably doesn't help that we're talking about code I can't see.
01:47:41 <Lis> i have 2 predefined lists, and one dynamic created list. "[1..5] list a" and "[6..10] list b" i want to multiplicate 1 with 6 and add the result to list c, which is then [6] then i want to multiplicate 2 with 7 with "element of list c" therefore 2*7*6, how could this be done?
01:48:33 <lpaste> motox revised “Can't get a list of macros”: “macro still” at http://lpaste.net/131290
01:51:01 <kadoban> motox: If that's the only change you made, look at line 36. Your function takes two arguments, but the type annotation has one. The result isn't what the type sig says, etc. Also line 3 has a typo.
01:51:40 <lyxia> Lis: Uh, what's the type of the output you want at the end?
01:52:36 <Lis> lyxia, double
01:56:24 <motox> kadoban: it is the same code from earlier.  I guess I am lost how to get it from isMacro into a list then.  Do you know of any good tutorials for this type of thing?  I have been trying to find something for about 10 hours so far and nothing has explained it really.
01:57:16 <srhb> motox: Are you just trying to get Prog -> [Macro] ?
01:57:29 <lyxia> > foldl (*) 1 $ [1..5] ++ [6..10] -- Lis
01:57:30 <lambdabot>  3628800
01:57:33 <kadoban> motox: Well, the thing is I think you're mostly there. You seemed to see why the type of toMacro needed to be Cmd -> Macro, but … you have to make the implementation of toMacro actually match still.
01:58:40 <kadoban> I don't really know good haskell tutorials, except like cis194 and the other advice linked from https://github.com/bitemyapp/learnhaskell , which isn't really specifically about your problem, but is a good way to learn haskell IMO
02:02:02 <Lis> lyxia, thank you
02:05:54 <Lis> ah lyxia is this also possible for a return value of [Double] where results are stored in a list for each go?
02:05:58 <motox> srhb: yes
02:06:57 <srhb> motox: If you were to write a function that only extracts the single Macro from a Def, how would that look?
02:07:56 <lyxia> > scanl (*) 1 $ zipWith (*) [1..5] [6..10] -- Lis, something like that?
02:07:57 <lambdabot>  [1,6,84,2016,72576,3628800]
02:08:28 <Lis> wow awesome, thank you
02:10:18 <motox> srhb: I think I see where you are going with this but that is where I'm stuck.  Once I determine the Cmd is a Macro according to the def of Cmd, I don't understand what to do
02:10:41 <srhb> motox: Does this look sane to you? toMacro' (Def m _ p) = m
02:10:51 <srhb> motox: That should have type Cmd -> Macro
02:11:59 <motox> kadoban: thanks for the advice.  I've seen CIS194, I'll check out the other too
02:14:10 <motox> srhb: No, that doesn't look right to me but it was all I could think of to put there.  I don't have much of a clue so I'm using trial and error here lately.  
02:14:25 <srhb> motox: Well, that would be correct if we wanted Cmd -> Macro
02:14:39 <srhb> motox: All we're doing is unwrapping the single Macro from the Def constructor
02:17:17 <motox> srhb: so it would it be def Macro = Macro?
02:18:21 <srhb> motox: No, I'm just trying to guide you slowly there. toMacro (Def m _ p) = m is correct if we wanted just the one Macro. But we also want to extract the macros from p. So the right hand side needs to look like m : ??? p
02:18:34 <srhb> Now, p is a Prog
02:18:45 <srhb> So you need ??? to be Prog -> Macro
02:18:54 <srhb> Er
02:18:57 <srhb> Prog -> [Macro]
02:19:10 <nak> is there a way to get prelude to always show :t of return values ?
02:19:16 <nak> ghci i mean
02:19:38 <srhb> nak: :set +t I think
02:20:10 <nak> srhb awesome
02:20:35 <nak> srhb weird.... on tryhaskell repl i could do
02:20:39 <motox> srhb: I need to look up ??? I don't recall that
02:20:40 <nak> λ (+)
02:20:48 <srhb> motox: I was just using it a placeholder
02:20:48 <nak> > (+)
02:20:50 <lambdabot>  <Integer -> Integer -> Integer>
02:20:52 <srhb> motox: as a
02:21:06 <nak> srhb yeah lambdabot allows it to
02:21:07 <srhb> motox: You need to figure out what to put instead of that in order to transform p to a list of macros
02:21:16 <nak> in ghci, i get an error when i do Prelude> (+)
02:21:25 <srhb> nak: Normally functions don't have a Show instance
02:21:26 <nak> No instance for (Show (a0 -> a0 -> a0))
02:21:31 <nak> oh
02:21:43 <nak> how come it works on lambdabot or tryhaskell repl ?
02:21:53 <srhb> nak: Because they do have a Show instance for functions. :)
02:22:04 <motox> srhb: Oh, thanks.  I'll do some reading
02:22:07 <nak> oh i see ^.^
02:22:18 <srhb> nak: https://wiki.haskell.org/Show_instance_for_functions
02:22:21 <arkeet> but it only prints the type.
02:22:29 <srhb> nak: Normally we don't use it, because we expect read . show to be id
02:22:44 <srhb> ie. read should be the inverse of show
02:22:54 <arkeet> it's not very useful outside of an interactive environment
02:23:15 * hackagebot list-t-html-parser 0.2.0.0 - Streaming HTML parser  http://hackage.haskell.org/package/list-t-html-parser-0.2.0.0 (NikitaVolkov)
02:24:01 <srhb> motox: Hint: If your macros function were correct, that would be what you should plug there.
02:24:54 <srhb> (is that the correct usage of were, or should that be was? I can never remember)
02:24:58 <nak> srhb you just have all the answers tonight :)
02:25:11 <srhb> nak: Probably because it's morning here and I had all the coffees! :-)
02:32:47 <nak> > let dbl x = x * 2 in map (\x -> dbl (dbl x)) [1..2]
02:32:48 <lambdabot>  [4,8]
02:33:19 <nak> if i have this function dbl, is there an easier way i can express
02:33:29 <nak> dbl dbl dbl [1,2,3]
02:33:29 <motox> srhb: would a list go there?
02:36:42 <kqr> nak, dbl dbl dbl = (!!2) . iterate dbl
02:36:48 <mrkkrp> Can someone tell me why `Text.Parsec.Token.float' parses string "4.23808622486133" as 4.2380862248613305? We all know that it's easy to introduce «fluctuations» in floating point numbers, but 4.23808622486133 is clearly can be represented in memory, so why can't it parse it «as is»?
02:36:55 <kqr> nak, uh, dbl . dbl . dbl = (!!2) . iterate dbl
02:37:12 <kqr> nak, dbl dbl dbl is nonsense if dbl x = x*2
02:37:22 <srhb> motox: Yes, as said, it needs to be a function that transforms p to a list of Macros
02:38:16 * hackagebot curlhs 0.1.4 - bindings to libcurl, the multiprotocol file transfer library  http://hackage.haskell.org/package/curlhs-0.1.4 (KrzysztofKardzis)
02:38:24 <srhb> nak: Do you remember the function composition operator from math, usually called o? as in (f o g)(x)
02:38:30 <srhb> nak: We have that, we call it (.)
02:38:36 <srhb> nak: so we can do (f . g) x
02:38:39 <rzetterberg> anyone with experience using haskell-mode on emacs? can't seem to get syntax highlighting with it and solarized
02:39:08 <srhb> rzetterberg: There's #haskell-emacs -- but do you have font-lock-mode enabled?
02:40:01 <rzetterberg> srhb: Ah, nice! Yes: (global-font-lock-mode t)
02:40:14 <nak> srhb i don't think i got that far in math :{
02:40:34 <nak> oh
02:40:44 <nak> you're doing f(g(x)), right, srhb ?
02:41:16 <rzetterberg> srhb: The only thing that is highlighted are strings :S
02:42:18 <nak> > let dbl x = x * 2 in map (dbl.dbl.dbl) [1..3]
02:42:19 <lambdabot>  [8,16,24]
02:42:23 <nak> srhb bingo!
02:42:47 <nak> srhb indulge me:
02:43:06 <nak> let n = 5, let's compose dbl n times and map that to [1..5]
02:43:09 <nak> can we do that ?
02:43:14 <nak> srhb ^
02:43:24 <mniip> nak use the iterate function
02:43:29 <srhb> :t iterate
02:43:30 <lambdabot> (a -> a) -> a -> [a]
02:44:04 <mniip> > let dbl x = x * 2 in map (\x -> iterate dbl x !! 5) [1..5]
02:44:05 <lambdabot>  [32,64,96,128,160]
02:44:09 <nak> > let dbl x = x * 2 in iterate dbl n [1..5]
02:44:10 <lambdabot>      Couldn't match expected type ‘[Integer] -> t’
02:44:10 <lambdabot>                  with actual type ‘[Expr]’
02:44:10 <lambdabot>      The function ‘iterate’ is applied to three arguments,
02:44:15 <srhb> > map ((!!4) . iterate (*2)) [1..5]
02:44:17 <lambdabot>  [16,32,48,64,80]
02:44:19 <mniip> > let dbl x = x * 2 in map ((!! 5) . iterate dbl) [1..5]
02:44:20 <lambdabot>  [32,64,96,128,160]
02:44:31 <mniip> dang beat me to it
02:44:54 <srhb> nak: iterate f x produces an infinite list of repeated applications of f to x
02:45:28 <nak> > (!!4)
02:45:30 <srhb> nak: So by taking the nth element of that list, we get (that many - 1) repeated applications
02:45:30 <lambdabot>      No instance for (Typeable a0)
02:45:30 <lambdabot>        arising from a use of ‘show_M155678884464611164510866’
02:45:30 <lambdabot>      In the expression:
02:45:39 <srhb> > [1,2,3,4] !! 2
02:45:41 <lambdabot>  3
02:45:55 <srhb> List indexing operator
02:45:59 <nak> ah ok
02:46:13 <srhb> > iterate (*2) 2
02:46:15 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
02:46:26 <mniip> srhb, sure we get n repeated applications
02:46:34 <mniip> 0th element is 0 applications aka id
02:46:37 <srhb> mniip: errr... Yes. :D
02:47:40 <nak> srhb it just clicked
02:47:47 <srhb> nak: :)
02:47:54 <nak> srhb it's wonderful
02:49:02 <nak> > let sq x = x * x in map ((!!2) . (iterate sq)) [1..5]
02:49:03 <lambdabot>  [1,16,81,256,625]
02:49:26 <srhb> nak: Parens on iterate sq are superflous
02:49:29 <nak> so this is sq(sq(sq(n)))
02:49:36 <nak> oh
02:49:44 <srhb> nak: Function application has highest precedence (over even operator application)
02:50:10 <srhb> nak: As mniip pointed out, the first element does not even have f applied, so it's sq(sq(n))
02:50:14 <nak> srhb you might not be surprised i've been reading a lisp/scheme book :)
02:50:23 <srhb> nak: Indeed :P
02:50:30 <mniip> that's not how lisp works either
02:50:53 <nak> ah, ok right
02:50:54 <nak> duh
02:50:56 <mniip> lisp's (sq (sq (sq n))) is not as superfluous
02:50:59 <nak> sq(sq(2)) is 16
02:51:09 <nak> mniip yah lol
02:51:13 <nak> i'm so used to (((((((( )))))))))))
02:51:23 <kqr> you can do (((()))) in haskell too!
02:51:23 <nak> (( ( ( )) ( ) ( ) ((()  ) ) () ( )( ))) ) ) )
02:51:51 <nak> srhb people say ruby is expressive ...
02:52:14 <kqr> (let sq x = ((*) x x) in (map ((.) (!!2) (iterate sq)) [1..5]))
02:52:20 <kqr> there you go! lispell!
02:52:26 <kqr> liskell* perhaps
02:52:30 <MP2E> haha
02:52:33 <nak> > map ((!!3) . iterate (*2)) [1..]
02:52:35 <lambdabot>  [8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128,136,144,152,160,168,176,...
02:52:47 <nak> i just had to see it one more time
02:53:06 <nak> that's ..
02:53:07 <nak> lol
02:53:12 <nak> that's dynamite
02:53:18 <nak> liskell lol
02:53:31 <motox> srhb: would macros (Def m [v] p:xs) = m : [m] work in the macros function?
02:53:46 <srhb> motox: Try to explain to me what [m] is
02:54:27 <motox> srhb: a list of macros
02:54:41 <srhb> > let foo m = m : [m] in foo 1 -- yes, but a very specific list of Macros
02:54:42 <lambdabot>  [1,1]
02:54:44 <nak> > 5 * (-3)
02:54:46 <lambdabot>  -15
02:54:50 <nak> > 5 * -3
02:54:51 <lambdabot>      Precedence parsing error
02:54:52 <lambdabot>          cannot mix ‘*’ [infixl 7] and prefix `-' [infixl 6] in the same infi...
02:55:01 <nak> makes sense 
02:55:12 <srhb> Namely the list of Macros that is exactly the one macro m which you also prepended to that list.
02:56:16 <srhb> motox: Another hint: macros = ??? . map toMacro . filter isMacro
02:56:25 <jle`> @let sq x = x*x
02:56:27 <lambdabot>  Defined.
02:56:41 <srhb> motox: We need to plug something into ??? because map toMacro gives you [[Macro]] because toMacro :: Cmd -> [Macro]
02:56:42 <jle`> > foldr (.) id [sq,sq,sq,sq,sq] 3
02:56:43 <lambdabot>  1853020188851841
02:56:55 <nak> > 5/2
02:56:56 <lambdabot>  2.5
02:56:59 <jle`> > foldr (.) id (replicate 5 sq) 3
02:57:01 <lambdabot>  1853020188851841
02:57:05 <nak> > :t 5/2
02:57:07 <lambdabot>  <hint>:1:1: parse error on input ‘:’
02:57:12 <nak> > :t (5/2)
02:57:13 <lambdabot>  <hint>:1:1: parse error on input ‘:’
02:57:18 <jle`> :t 5/2
02:57:19 <nak> :t 5/2
02:57:19 <lambdabot> Fractional a => a
02:57:20 <lambdabot> Fractional a => a
02:57:24 <nak> ok "Fractional"
02:57:33 <nak> is it possible to get nominator and denominator from this?
02:57:39 <srhb> nak: With a different type.
02:57:47 <jle`> yes, there are some Fractional instances that give you denominators and numerators
02:57:54 <jle`> all you have to do is pick your instance :)
02:58:18 <srhb> > numerator (5 % 2)
02:58:19 <lambdabot>  5
02:58:35 <jle`> > numerator (5 / 2)
02:58:37 <lambdabot>  5
02:58:50 <jle`> > denominator (5 / 2)
02:58:52 <lambdabot>  2
02:59:00 <jle`> polymorphic numeric literals are great :3
02:59:04 <srhb> Funtimes.
02:59:09 <nak> > let x = 5/2 in numerator x
02:59:10 <lambdabot>  5
02:59:14 <nak> sweet
02:59:26 <srhb> I'm actually confused why that works. More coffee.
02:59:27 <jle`> note that earlier when you did 5/2, it picked a Fractional instance for you...it picked Double
02:59:43 <motox> srhb: would the def go there?
02:59:46 <jle`> you can't get a "numerator" out of a Double without doing some math tricks
02:59:59 <nak> > 5 % 2 
03:00:00 <lambdabot>  5 % 2
03:00:02 <srhb> motox: No, you want something that transforms [[Macro]] to [Macro]
03:00:03 <jle`> but there's a type called `Rational` where you can
03:00:11 <nak> :t (5 % 2)
03:00:12 <lambdabot> Integral a => Ratio a
03:00:13 <jle`> numerator :: Rational -> Integer
03:00:17 <srhb> motox: map toMacro . filter isMacro :: [[Macro]] -- but you want [Macro]
03:00:27 <jle`> Rational is an instance of Fractional
03:00:36 <srhb> Ah!
03:00:38 <jle`> so what's happening is that it's prasing (5/2) as a Rational
03:00:38 <phaazon> aaaw
03:00:43 <phaazon> I just discovered class-prelude
03:00:44 <jle`> *parsing
03:00:46 <srhb> I didn't realize that.
03:00:48 <nak> jle` ah interesting... so % will keep thins a little nicer
03:00:51 <phaazon> is there a way to put that as a default Prelude?
03:00:56 <phaazon> so that I don't have to import it?
03:01:00 <srhb> phaazon: In a cabalized project, yes
03:01:02 <jle`> nak: (%) is actually a "constructor" for the Rational type
03:01:07 <phaazon> srhb: cool :3
03:01:13 <phaazon> I'm gonna do that then
03:01:14 <jle`> it's a different type, its not Double
03:01:16 <srhb> phaazon: You'll need to enable NoImplicitPrelude and import that everywhere
03:01:20 <phaazon> the new Prelude is still very wrong
03:01:28 <phaazon> (the one shipped with GHC 7.10.1)
03:01:40 <phaazon> srhb: ah
03:01:40 <jle`> Double's are machine doubles.  so 5/2 can parse as a Double (machine double), or as a Rational (a data type that preserves denominators and numerators)
03:01:47 <jle`> it can also parse as a Float, too
03:01:50 <phaazon> I thought there was a way to import it by default
03:01:52 <phaazon> like hm
03:01:54 <jle`> it can parse as any instance of Fractional
03:01:58 <phaazon> prelude-src: ...
03:02:04 <nak> jle`very cool
03:02:10 <nak> srhb sounds like maybe you got to learn something too :)
03:02:34 <nak> ^^
03:02:39 <phaazon> classy-prelude even has Semigroups exported :3
03:02:43 <srhb> nak: I just did! I didn't know that Rational was an instance of Fractional.
03:02:53 <motox> srhb: would using head work then?
03:02:55 <arkeet> it is the prototypical Fractional.
03:02:56 <jle`> to be fair, haskell is almost designed to be a language that becomes unwritable when you are tired/sleepy
03:02:57 <phaazon> holy
03:02:58 <arkeet> after all:
03:03:00 <arkeet> :t fromRational
03:03:01 <lambdabot> Fractional a => Rational -> a
03:03:09 <phaazon> it has map :: (Functor f) => (a -> b) -> f a -> f b
03:03:11 <phaazon> how cool is that
03:03:17 <srhb> motox: Then you would get the very first list of macros and ignore the rest. What do you want the function to do, on a high level?
03:03:20 <arkeet> who needs that, we have fmap in prelude alreayd.
03:03:22 <srhb> motox: Ie. explain it in words
03:03:31 <phaazon> arkeet: fmap should be called map
03:03:32 <shachaf> phaazon: So does Haskell 1.4.
03:03:39 <phaazon> Haskell 1.4?!
03:03:42 <phaazon> what is that
03:03:47 <srhb> Ancient.
03:03:50 <phaazon> ah
03:03:55 <jle`> yeah, we're on 2010
03:04:05 <phaazon> arkeet: Functor should export map, not fmap
03:04:07 <jle`> that's like 2008.6 versions later
03:04:11 <arkeet> haha
03:04:11 <phaazon> ok :)
03:04:21 <shachaf> Ad-hoc classes like the ones in that library isn't the direction that things should go.
03:04:50 <motox> srhb: I want to be able to pass a program name to macros and get a list of all the macros in the program
03:05:03 <jle`> i always thought that it was a really weird regression to go from windows 2000 to windows 7
03:05:18 <srhb> motox: Right. And now you have a list of list of macros, where each sublist represents the list of macros from each Def
03:05:20 <nak> srhb are you on github?
03:05:25 <arkeet> jle`: haven't you heard?
03:05:27 <srhb> nak: Yes, but I have nothing to show for it.
03:05:29 <phaazon> shachaf: why?
03:05:32 <srhb> nak: No repos. :)
03:05:33 <arkeet> > "Windows 7" > "Windows 2000"
03:05:34 <lambdabot>  True
03:05:38 <jle`> ha
03:05:53 <nak> does the haskell community much use git ?
03:05:57 <mniip> > "linux" > "Windows"
03:05:57 <srhb> nak: Yes.
03:05:58 <lambdabot>  True
03:06:01 <arkeet> very much.
03:06:01 <MP2E> :D
03:06:07 <nak> ok cool
03:06:10 <jle`> there was a big darcs fad but people mostly use git or mirror on git
03:06:13 <safinaskar> :))))
03:06:22 <arkeet> my experience with darcs is slowness.
03:06:33 <nak> oh thank god i missed the darc days
03:06:35 <nak> knee slapper
03:06:38 <safinaskar> i have "m :: Data.Map.Map Int SomeType". how to get smallest natural which is not key in this map?
03:06:51 <srhb> motox: So more basically, you want to flatten the list. You can ask hoogle how to do that by querying hoogle for [[a]] -> [a]
03:07:02 <jle`> i think darcs was particularly appealing for haskellers because it was written in haskell
03:07:35 <nak> yeah i know very little about it
03:07:36 <MP2E> yeah, that's what drew me to it initially. It does seem like a minor, incremental improvement to git in terms of the idea, but it's far too slow for use in medium-large projects in practice.
03:07:41 <arkeet> and it existed well before git
03:07:58 * jle` thinks back to a time before git
03:07:58 <MP2E> and also I find that a well managed git repository doesn't really hit the snags darcs addresses.
03:08:05 <nak> how is the speed of a compiled haskell program in general? 
03:08:08 <safinaskar> jle` and others: also, windows 10 named such (and not windows 9) because "windows 9" clashes with windows 95 and 98. and lots of software has check (speaking haskell-like) "case x of "Windows 9" ++ _ -> ..."
03:08:13 * phaazon remembers the fucking CPOLD times...
03:08:14 <nak> slow compared to C/JavaScript?
03:08:18 * hackagebot list-t-html-parser 0.2.1.0 - Streaming HTML parser  http://hackage.haskell.org/package/list-t-html-parser-0.2.1.0 (NikitaVolkov)
03:08:20 * hackagebot html-tokenizer 0.2.1.2 - An "attoparsec"-based HTML tokenizer  http://hackage.haskell.org/package/html-tokenizer-0.2.1.2 (NikitaVolkov)
03:08:24 <arkeet> nak: competitive with C.
03:08:27 <srhb> safinaskar: pred . head . keys
03:08:30 <arkeet> if written well.
03:08:31 <nak> ok that's cool
03:08:47 <nak> it's fricken 5 am here
03:08:50 <jle`> it depends on the application and domain and how it's written, but people usually put it around C < haskell ~ java < interpreted languages
03:08:50 <MP2E> Yeah, I've been pleasantly surprised by Haskell's performance. Provided I use the right datatypes anyway :P
03:09:08 <MP2E> If you just throw in Lists everywhere you might get slowness hehe
03:09:10 <nak> that's good news
03:09:11 <jle`> but simple orderings like that really don't have too much meaning
03:09:39 <arkeet> but lists are so *easy*
03:10:00 <jle`> by the way, if you are using ghc haskell, all haskell is compiled haskell.  the difference is just how optimized it is :)
03:10:02 <kqr> nak, haskell can be expected to be around java performance, which is a small multiple of C
03:10:10 <kqr> nak, if optimised for speed, you can get much better results than that
03:10:23 <safinaskar> srhb: no. i need smallest natural not present in keys
03:10:38 <srhb> safinaskar: Then I don't understand the question.
03:10:48 <MP2E> arkeet: true! but OverloadedLists + vector makes for some reasonably easy to use, very fast datatypes
03:10:50 <Lis> you can't really say something about speed. it's all about optimizing your programm and coding style
03:10:57 <NewB> Hi! I want to create faceted charts/diagrams like this (http://www.cookbook-r.com/Graphs/Facets_(ggplot2)/figure/unnamed-chunk-6-1.png) in ggplot2. Any suggestions for libraries?
03:10:59 <MP2E> arkeet: though if you're careful to make sure your lists are all fused away, it can still be very very fast
03:11:03 <arkeet> > head $ [0..] \\ [0,1,2,4,5,7]
03:11:04 <Lis> also it's important what your programm is used for
03:11:05 <lambdabot>  3
03:11:14 <nak> kqr yeah that's totally acceptable for my uses
03:11:18 <motox> srhb: I just tried to compile with concat . map toMacro . filter isMacro
03:11:30 <safinaskar> arkeet: thanks!
03:11:40 <srhb> motox: That is correct. If you're still having problems, there's an error elsewhere. :)
03:12:16 <srhb> Oh, now I understand.
03:12:26 <safinaskar> sorry, i ocassionally closed the window
03:12:28 <arkeet> safinaskar: also see (iirc) the first chapter in Bird's book.
03:12:31 <safinaskar> thanks all
03:12:41 <safinaskar> *everybody
03:12:57 <nak> ok without giving me the answer right away, maybe someone can help talk me through a problem i just invented !
03:13:00 <jle`> safinaskar: thank you for the trivia. everyhting makes sense now
03:13:29 <nak> :t min
03:13:30 <lambdabot> Ord a => a -> a -> a
03:13:37 <nak> right, so it only takes 2 args
03:13:55 <nak> if i have a list or Nums, how can i find the min of that list ?
03:13:55 <arkeet> safinaskar: except that's for getting the first natural number not in an *unsorted* list, in linear time.
03:14:02 <arkeet> the keys in a map are sorted.
03:14:04 <arkeet> oops you're gone.
03:14:26 <arkeet> the thing I wrote is probably quadratic time anyway.
03:14:33 <srhb> :t min
03:14:33 <arkeet> please come back.
03:14:34 <lambdabot> Ord a => a -> a -> a
03:14:37 <srhb> :t minimum
03:14:38 <lambdabot> (Ord a, Foldable t) => t a -> a
03:14:55 <Lis> kqr, java has an average speed without optimazion for every programming task, where haskell is better in parallel operations and some recursion styles http://benchmarksgame.alioth.debian.org/u64q/haskell.html
03:14:55 <srhb> > minimum [2,5,0,20]
03:14:57 <lambdabot>  0
03:15:03 <nak> srhb ah
03:15:11 <nak> srhb let's say minimum wasn't available
03:15:16 <nak> and all we could use was 
03:15:17 <nak> :t min
03:15:18 <lambdabot> Ord a => a -> a -> a
03:15:19 <srhb> nak:  Something something foldr
03:15:33 <srhb> > foldl1 min [2,4,0,20]
03:15:35 <lambdabot>  0
03:15:50 <nak> foldl1 ?
03:16:03 <srhb> It's a left fold with the first element of the list as the starting element
03:16:07 <arkeet> or you could do it with explicit recursion.
03:16:09 <arkeet> it's all the same.
03:16:17 <arkeet> and since you say it's 5am, you should consider sleep.
03:16:18 <arkeet> :p
03:16:25 <nak> arkeet but this is so much fun
03:16:28 <srhb> 5 am is obviously the best time to start understanding folds. :-)
03:16:36 * srhb gives horrible advice
03:16:40 <nak> ^.^
03:16:41 <arkeet> a lot of things do become more fun at 5am!
03:16:53 <arkeet> or at least seem more fun.
03:16:55 <Lis> nak, sleeping is more fun, becouse if you are rested you do fewer mistakes and work faster
03:17:04 <jle`> if you don't know about folds, you can do explicit recursion too
03:17:08 <arkeet> you can't make *any* mistakes while sleeping!
03:17:14 <Lis> nak, most of the time i worked while tired i made mistakes i had to fix while rested
03:17:17 <jle`> min (x:[]) = ...?
03:17:17 <arkeet> but you probably won't get any work done.
03:17:27 <nak> but i'm not really tired lol
03:17:29 <jle`> min (x1:x2:xs) = ?
03:18:03 <nak> hhmm
03:18:08 <Lis> nak, you didn't mentoin that :D
03:18:19 <nak> Lis i *should* be tired but i'm learning haskell
03:18:24 <nak> who could be tired through that
03:18:25 <nak> :)
03:18:30 <Lis> if your not tired dont sleep. simple as that
03:18:56 <solatis> is there anything such as a haskell recommended coding style ?
03:19:02 <solatis> similar like python has, for example
03:19:26 <quchen2> solatis: There are many, I like that one. https://github.com/chrisdone/haskell-style-guide
03:19:54 <solatis> is there anyone haskell core maintainers use ?
03:20:03 <jle`> oh boy
03:20:14 <quchen2> Mimicry is what GHC uses ;-)
03:21:28 <montonero> Hey guys, noob haskell user here trying to learn the language. Wondering if anyone could help me to decipher the compiler error in this code: http://www.everfall.com/paste/id.php?7edrem4z2y31
03:21:46 <montonero> it says "parse error on input `b0'" on line 16
03:22:04 <mniip> monochrom, your layout is messed up
03:22:12 <montonero> but nothing is wrong there! (at least it looks like that)
03:22:27 <jle`> to the untrained eye, perhaps :)
03:22:33 <mniip> you need to indent the bindings, or outdent the 'where' like you did in the previous function
03:22:40 <solatis> montonero, you're missing indentation
03:22:50 <solatis> montonero, starting on line 15
03:23:20 <mniip> montonero, on line 7 your where is less indented than the following block
03:23:31 <mniip> on line 14 where has the same indentation
03:24:03 <montonero> oh, god. that's true (I mixed spaces and tabs)
03:24:18 <arkeet> never use tabs.
03:24:27 <jle`> just say no (tm)
03:24:30 <shachaf> GHC style is to mix spaces and tabs.
03:24:46 <arkeet> has GHC ever tried compiling itself with -Wall?
03:24:51 <arkeet> (does -Wall include -fwarn-tabs?)
03:24:55 <arkeet> (pre-7.10)
03:25:20 <shachaf> OK, it looks like it's been detabbed somewhat.
03:25:40 <jle`> it was one of the simons that insisted, right?
03:26:07 <shachaf> Detabbing was policy for a long time.
03:26:17 <shachaf> But they didn't want to do it all in one go for whatever reason.
03:26:20 <jle`> i meant, in insisting on using tabs
03:26:31 <shachaf> So a bunch of files had "when you modify this file, detab it too"
03:27:31 <fabian__> I forgot the name of a cool monad used by implementors of Pipes (or maybe ConT) that isn't well heard of but mind blowing
03:27:52 <lpaste> motox revised “Can't get a list of macros”: “No title” at http://lpaste.net/131290
03:28:07 <arkeet> oh, I didn't see the original source with the tabs.
03:28:24 <arkeet> apparently that site converts tabs to 4 spaces. or whatever.
03:28:31 <jle`> fabian__: ListT ?
03:28:49 <jle`> oh
03:29:13 <jle`> do you mean the coroutines
03:29:37 <motox> srhb: thanks, I was messing with it some more, could you take a look at it now?  I am getting an error saying the equations for macros have different numbers of arguments
03:29:50 <srhb> motox: Yep. That should be an easy error to fix though
03:30:00 <srhb> motox: A function can't have a mixed number of arguments :)
03:31:31 <jle`> fabian__: https://themonadreader.files.wordpress.com/2011/10/issue19.pdf -- the third article?
03:31:42 <fabian__> jle`: No something more obscur
03:31:48 <srhb> motox: Link?
03:32:04 <lpaste> motox revised “Can't get a list of macros”: “No title” at http://lpaste.net/131290
03:32:04 <jle`> hm. pipes is basically a library built on Coroutine
03:32:35 <fabian__> jle`: it might start with C, the monad name
03:32:46 <jle`> and it's not Coroutine? :3
03:33:27 <fabian__> jle`: ill read up on it
03:34:19 <fabian__> jle`: I might confuse things :( It was something about making stuff linear bla bla
03:34:48 <fabian__> And the description of the monad made no sense at the time. It might be related to ConT
03:34:59 <fabian__> or Cond
03:35:25 <srhb> motox: I don't understand that first clause of macros
03:35:45 <srhb> motox: data Prog = [Cmd], not Cmd
03:37:00 <motox> srhb: it should read = m:[m]
03:37:26 <srhb> motox: No, it still doesn't make sense. By having a Def ... argument, you're implying that the argument to macros is of type Cmd
03:37:37 <lpaste> motox revised “Can't get a list of macros”: “macro woes” at http://lpaste.net/131290
03:37:39 <srhb> But in the second clause, you're implying that it is of type [Cmd]
03:37:41 <srhb> You need to decide.
03:38:55 <motox> srhb: it should be a type of Cmd
03:39:15 <srhb> motox: But you said earlier that you wanted Prog -> [Macro]
03:39:19 <srhb> Prog is [Cmd]
03:39:28 <motox> srhb: based on the def of Cmd
03:40:13 <srhb> motox: also, why didn't you use the correct definition of toMacro that we worked out before?
03:40:18 <nak> jle` arkeet srhb mniip MP2E thank you for all of your assistance this evening. you've made my intro to haskell a very rewarding one. i'm gonna catch some sleep but i'll be back in the morning :)
03:40:24 <srhb> o/
03:40:28 <nak> o/
03:41:35 <motox> srhb: I thought Prog =[Cmd] but Macro was a type of Cmd
03:42:51 <srhb> motox: http://lpaste.net/288733763498672128 -- This should adhere to your specifications
03:43:04 <zenguine> @pl f a b = length (show (max a b))
03:43:04 <lambdabot> f = ((length . show) .) . max
03:43:17 <srhb> motox: And I would suggest getting some practice with some simpler data types. :) I think the nested-ness is causing your troubles.
03:43:39 <srhb> motox: Also, types types types.
03:44:50 <srhb> motox: I imagine you'll still need to figure out what to do with the Macro in Call
03:45:55 <phaazon> hey
03:46:04 <phaazon> what's the name of people leading a project alone again?
03:46:10 <phaazon> something with « good dictator »
03:46:15 <phaazon> or something like that
03:46:18 <srhb> Benevolent? 
03:46:18 <ibid> benovelent?
03:46:21 <phaazon> nope
03:46:26 <phaazon> it's a very precise word
03:46:33 <phaazon> there's a wikipedia page about that
03:46:37 <srhb> Try #haskell-blah :)
03:46:41 <phaazon> Linus Torvalds is one
03:46:56 <ibid> http://en.wikipedia.org/wiki/Benevolent_dictator_for_life
03:47:12 <phaazon> oh yeah
03:47:13 <phaazon> BDFL
03:47:15 <phaazon> thank you
03:47:25 <ibid> "nope" :D
03:47:43 <phaazon> ibid: yeah, I remembered « dictatory » instead of benevolent
03:47:44 <motox> srhb: I started trying to get rid of compile errors and was changing stuff.  This is what we talked about earlier
03:47:52 <lpaste> motox revised “Can't get a list of macros”: “No title” at http://lpaste.net/131290
03:48:24 <srhb> motox: Use my working definitions and try to figure out why they are correct. Ask if you don't understand them :)
03:50:07 <srhb> I should have renamed toMacro to toMacros
03:51:21 <lpaste> motox revised “Can't get a list of macros”: “No title” at http://lpaste.net/131290
03:52:15 <lpaste> motox revised “Can't get a list of macros (annotation)”: “No title” at http://lpaste.net/288733763498672128
03:52:23 <srhb> motox: You're spamming the channel with your revisions :)
03:52:47 <motox> sorry everybody
03:53:02 <srhb> Just remove #haskell from the channel field next time, unless you need us to see it.
03:53:26 <motox> srhb: Will do, thanks
03:53:29 <srhb> :-)
03:57:11 <jle`> this has been asked here many times, but...does anyone actually know how to use fgl?
03:59:53 <solatis> jle`, does it even work? it says the latest update was in 2008
04:00:23 <solatis> ah wait the original website doesn't reflect the module anymore
04:01:06 <solatis> the names of the functions in that module couldn't be more cryptic
04:11:35 <pharpend> Morning, everyone!
04:12:34 <Aruro> guys , could you take a look at following error message http://lpaste.net/131301
04:13:03 <Aruro> does attoparsec import bytestring library?
04:13:29 <Aruro> looks like two versions are colliding
04:16:11 <pharpend> Aruro: yep
04:16:26 <pharpend> Aruro: "cabal update && cabal install attoparsec" should fix it
04:17:37 <motox> srhb: Why can't I comment out the first equation for macros and have the second without concat since calling isMacro has it defined there?
04:18:02 <srhb> motox: Link please. I'm not sure what you're doing.
04:18:49 <Aruro> pharpend: ty
04:18:55 <Aruro> will try it now
04:21:49 <duga3> hi, what am I doing wrongly, when I try to link HSrts-ghc7.8.4.so in extra-libraries (cabal) and it says it cannot find the library
04:22:07 <duga3> but when I am linking with ghc -llib it correctly finds the library
04:22:16 <lpaste> motox pasted “No title” at http://lpaste.net/131302
04:22:51 <srhb> motox: There are several errors there.
04:23:05 <srhb> motox: For one, you're applying [m] to p, which is nonsense, because [m] is not a function.
04:24:26 <pharpend> duga3: well first off, you're using an old version of GHC =P
04:25:19 <motox> srhb: I thought that was what you were saying earlier with the = m ??? p
04:26:38 <srhb> motox: No, I was saying that you needed some function foo so that you could do m : foo p -- in toMacro, such that foo p was a [Macro]. 
04:26:43 <srhb> Or that was what I was trying to say.
04:26:59 <srhb> motox: You realize that the code I gave you earlier was completely working and compiling, right?
04:27:14 <srhb> Not the one with ??? but what I pasted to you.
04:27:40 <duga3> pharpend: http://www.vex.net/~trebla/haskell/so/eval.cabal which version of ghc I should to use? arch 7.8.4 ghc
04:28:01 <motox> srhb: I didn't see you paste anything.  I'll go back and look
04:28:08 <srhb> motox: I'll repaste it, hang on.
04:28:36 <srhb> motox: http://lpaste.net/7820994858851500032
04:29:04 <srhb> motox: That code compiles and works according to your specification, but still needs work if you want to include the Macro from the Call values
04:29:31 <motox> srhb: thanks, I'll check it out
04:48:36 <motox> srhb: the Call value for isMacro is straightforward but for toMacro I don't understand what would go on the right side of = because p is not an argument of Call
04:49:06 <srhb> motox: No, there's just the one Macro in a call
04:49:15 <srhb> motox: Do you have the left hand side nailed?
04:49:54 <spdionis> hello, anyone knows which is the best haskell plugin for IntelliJ IDEA?
04:50:28 <spdionis> there are 4 of them and I don't know which to choose
04:51:42 <motox> srhb: toMacro (Call m _) =
04:51:57 <srhb> motox: Right, and what type does the right hand side need to have?
04:52:03 <srhb> motox: And what type does m have?
04:52:23 <motox> srhb: Macro
04:52:28 <srhb> The right hand side or m?
04:53:00 <motox> srhb: m is type Macro
04:53:05 <srhb> Correct
04:53:10 <srhb> And what type does the right hand side need to have?
04:53:35 <motox> srhb: [Macro]
04:53:37 <srhb> Right
04:53:44 <srhb> So now you have something of type Macro, and you need [Macro]
04:53:51 <pharpend> duga3: It's usually a good idea to use the lastest GHC, which is 7.10.1 IIRC
04:53:52 <srhb> How do you take an element and with it make a list of those elements?
04:54:12 <srhb> (Well, of *that* element)
04:54:25 <motox> srhb: m : [m]
04:54:36 <srhb> > 1 : [1] -- motox
04:54:37 <lambdabot>  [1,1]
04:54:39 <srhb> Does that look right to you?
04:55:05 <srhb> That gives you a list of exactly two m's
04:55:19 <srhb> How many m's should there be?
04:55:44 <motox> srhb: with the Call just 1?
04:55:46 <srhb> Yes
04:55:55 <srhb> So, how do you make a list of ONE element
04:56:09 <motox> srhb: m : []
04:56:14 <srhb> Yep, also known as [m]
04:56:33 <srhb> So that is your right hand side.
04:57:09 <motox> srhb: thank you very much
04:57:14 <srhb> motox: You're welcome. :)
04:58:00 <motox> how can I exit a module that I loaded without having to :q ?
04:58:09 <srhb> motox: :m -ModuleName I think
04:59:12 <motox> srhb: thanks, that works
05:02:25 <R0b0t1> https://pyos.github.io/dg/tutorial/ ?
05:07:30 <srhb> "With Haskell's syntax but none of its type system, dg is the best way to make fans of static typing shut up already."
05:07:33 <srhb> Beautiful.
05:08:48 <spdionis> why does this docs talk about the .ghci file when in fact it should be "ghci.conf"? https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-dot-files.html
05:09:53 <flux> spdionis, so the documentation is wrong?
05:10:03 <srhb> spdionis: Do you mean it doesn't check ./.ghci?
05:10:13 <spdionis> i didn't try .ghci
05:10:25 <spdionis> but it surely didn't check %appdata%/ghc/.ghci
05:10:33 <srhb> spdionis: ", in this order, if they exist:"
05:10:43 <spdionis> it works with %appdata%/ghc/ghci.conf
05:10:43 <srhb> spdionis: And it says ./.ghci
05:10:45 <flux> it clearly says which files it checks, and yours isn't in it :)
05:10:56 <srhb> spdionis: As in "that file under THIS directory"
05:10:58 <srhb> cwd
05:11:10 <spdionis> but i didn't want it to load it from ./.ghci
05:11:19 <srhb> spdionis: Then don't have ./.ghci
05:11:20 <spdionis> i wanted it to load from %appdata%/ghc/.ghci
05:11:23 <spdionis> i didn't
05:11:26 <flux> well, you either cd to that dir
05:11:30 <flux> or use ghci.conf there
05:11:47 <flux> it's the option "2" in the list, which doesn't mention .ghci at all
05:12:06 <spdionis> the focs said that if there's no ./.ghci then it will use %appdata%/ghc/.ghci , but in fact it tries to find %appdata%/ghc/ghci.conf
05:12:21 <srhb> spdionis: No it doesn't?
05:12:22 <flux> spdionis, can you quote the appropriate part?
05:12:36 <spdionis> (facepalm)
05:12:40 <spdionis> it was me misreading
05:12:40 <srhb> :-)
05:13:00 <spdionis> i'm sorry ;)
05:13:03 <srhb> No worries :P
05:15:47 <motox> what does prog	::=	ε   |   cmd ; prog mean?  The ; prog throws me off.
05:16:36 <ronh> in emacs's haskell-mode is there a command to jump to the first error after calling inferior-haskell-load-file?
05:16:45 <srhb> motox: Is that an EBNF?
05:16:54 <KaneTW> motox:  a prog is either nothing or a cmd, then another prog
05:17:22 <motox> srhb: what is EBNF?
05:17:28 <srhb> Extended Backus Naur-form
05:17:35 <motox> KaneTW: thanks
05:17:36 <srhb> Backus-Naur form even
05:17:52 <exio4> separated by ;s 
05:18:20 <motox> srhb: I don't have  a clue, I'm just reading trying to get a grasp on things
05:18:40 <srhb> Heh, okay. What exactly are you reading? You seem to be diving in at the very, very deep end.
05:19:34 <motox> srhb: I am reading about grammars
05:24:02 <dredozubov> ronh: С-x ` iirc
05:26:51 <stoopkid> haskell is a cool language
05:26:58 <stoopkid> ...idk that's all i have to say :D
05:28:37 <dmj`> stoopkid: agreed
05:32:21 <ronh> dredozubov great it worked! thanks
05:35:00 <bartavelle> how to prevent GHC 7.10 from using multiple cores during compilation ?
05:35:51 <srhb> bartavelle: -j1 iirc
05:36:03 <bartavelle> srhb: thanks, will try that
05:36:40 <bartavelle> awesome, thanks !
05:38:25 * hackagebot cabocha 0.1.0.0 -   http://hackage.haskell.org/package/cabocha-0.1.0.0 (MiyazawaAkira)
06:03:26 * hackagebot Earley 0.6.0 - Parsing all context-free grammars using Earley's algorithm.  http://hackage.haskell.org/package/Earley-0.6.0 (OlleFredriksson)
06:10:23 <mrkkrp> There may be a bug in Parsec, those who interested can visit http://stackoverflow.com/questions/29820870/floating-point-numbers-precision-and-parsec
06:11:33 <brycelane> Is there a way to get printf like formatting using Data.Text? I've seen text-format, but it doesn't work on Windows (haskell platform 2013) and I'm not thrilled about a non-portable solution (I'm also not sure it would be sufficient, couldn't check).
06:12:33 <chpatrick> @hackage formatting
06:12:33 <lambdabot> http://hackage.haskell.org/package/formatting
06:13:21 <srhb> Depends on text-format
06:13:36 <chpatrick> oops, sorry
06:13:47 <mrkkrp> brycelane: I use `text-format' without problems. I've tested it on Windows too.
06:13:49 <chpatrick> why doesn't it work on windows?
06:13:58 <brycelane> https://github.com/bos/text-format/issues/13
06:14:13 <brycelane> Maybe its fixed in later haskell platforms? mrkkrp, what version do you use?
06:15:47 <brycelane> this is the more precise issue with double-conversion https://github.com/bos/double-conversion/issues/7
06:16:43 <mrkkrp> brycelane: I usually work on Arch Linux... Let me check what I have on Windows.
06:19:34 <mrkkrp> Haskell Platform 2014.2.0.0 and text-format >= 0.3.1.1
06:19:58 <brycelane> mrkkrp: Ok, maybe I'll try upgrading and see if that helps. Thanks for looking.
06:25:56 <SrPx> Is there anything like that: https://hackage.haskell.org/package/vector-0.10.12.3/docs/doc-index-All.html except with types? 
06:27:07 <SrPx> Also, the "frames" link seems to be broken... https://hackage.haskell.org/package/vector-0.10.12.3/docs/frames.html
06:46:07 <bananagram> :t (+) . (+)
06:46:08 <lambdabot> Num a => a -> (a -> a) -> a -> a
06:49:11 <brycelane> mrkkrp: I've updated to haskell platform (2014.2) and it still doesn't work. Maybe you have stdc++ on your path, maybe I have something non-standard going on. Anyway, thanks for looking it up.
06:52:33 <brycelane> It might also be worth noting I installed the 64 bit haskell platform. Maybe the 32-bit version behaves better.
06:53:58 <StrangeLoop> http://pastebin.com/D6HF2dZm <--- Hi, why does this run only once and not indefinitely?
06:54:56 <srhb> StrangeLoop: when is not a loop
06:55:04 <mau{ke}> @src when
06:55:05 <lambdabot> when p s = if p then s else return ()
06:55:08 <dgpratt> StrangeLoop, why would you think it would run indefinitely?
06:55:15 <ronh> can I make a cabal project with two executables?
06:55:23 <dcoutts> ronh: yes
06:55:25 <srhb> StrangeLoop: I think you want whileM or something like that.
06:55:31 <StrangeLoop> OK, could be
06:56:02 <srhb> StrangeLoop: (Or maybe even something simple like forever. hard to tell without knowing what you're trying to do)
06:56:16 <dcoutts> ronh: in general 0-1 library, and 0-n executables
06:56:20 <StrangeLoop> I'm not trying to do anything in particular, just experimenting
06:56:25 <srhb> :P
06:56:31 <srhb> Then i have no idea what you want!
06:57:17 <ronh> dcoutts I just put two executable entries in the cabal file?
06:57:26 <dcoutts> ronh: yep
06:57:32 <ronh> nice
07:00:55 <brycelane> mrkkrp: also note: double-conversion works fine in once compiled, just not using interpreted mode (ghci, runhaskell). I should have read the issue rabbit hole a bot more before posting. Sorry.
07:03:11 <mrkkrp> brycelane: I don't write Haskell on Windows. I just test/compile it there :)
07:06:03 <srhb> Hmm!
07:06:17 <srhb> Can I construct new evidence with TypeLits? inspired by this question: http://stackoverflow.com/questions/29823345/lists-of-fixed-length-and-type-literals
07:08:47 <albeit> Is there a way to have multi-line comments in .cabal files other than lots of "--"?
07:11:19 <quchen2> Can I put Stackage's cabal.config in .cabal and it'll globally enforce the constraints?
07:11:21 <srhb> I feel like one has to actually add a new plugin to provide the evidence necessary for that code to work...
07:12:35 <mrkkrp> albeit: what's bad about -- ?
07:12:49 <geekosaur> albeit: {- ... -}
07:13:15 <albeit> mrkkrp: Just want to comment out an entire Test-Suite section...
07:13:36 <albeit> geekosaur: That works?! I couldn't find documentation for it, and the syntax highlighter doesn't show it as comments
07:13:57 <geekosaur> sounds like a broken syntax highlighter to me
07:14:17 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-170002.3
07:14:18 <mrkkrp> albeit: Select it and press M-; ;D
07:14:27 <albeit> geekosaur: Doesn't seem to work... results in a parse error of hte cabal file
07:14:56 <geekosaur> oh, in cabal config. somehow I thought you meant haskell programs, sorry. I don't think cabal's parser is smart enough to do that
07:23:34 <StrangeLoop> Hi, I am trying to write a method which generates a random tree. It has signature "genRandom :: (Random a, RandomGen g) => Int -> Int -> g -> RootedTree a"
07:23:50 <StrangeLoop> I don't know how to call this method in a way which determines what a is
07:24:09 <mau{ke}> what are you doing with the result?
07:24:16 <StrangeLoop> For now, printing it
07:24:30 <mau{ke}> use a type annotation
07:24:38 <StrangeLoop> Where?
07:24:42 <mau{ke}> print (genRandom x y gen :: RootedTree Int)
07:24:44 <mau{ke}> or whatever
07:24:53 <StrangeLoop> Oh OK, call
07:24:57 <StrangeLoop> *cool
07:31:14 <c_wraith> StrangeLoop: note that for friendliness with other code that uses randomness, I'd recommend returning (g, RootedTRee a).  I always twitch a bit when I see a function that doesn't return the final RandomGen state.
07:31:48 <mau{ke}> :t split
07:31:49 <lambdabot> Splitter a -> [a] -> [[a]]
07:31:56 <mau{ke}> oh?
07:31:58 <StrangeLoop> yeah, I actually just did that because I noticed it makes the recursion much easier, I guess this is a good practice in general
07:32:07 <c_wraith> Yeah, split exists.  But I don't like it because it's not well-implemented for StdGen
07:33:51 <dhess> Hi all, strange issue I can't seem to resolve.
07:34:01 <dhess> class C m is in module C.hs, exported as C (..). It defines a function f :: m -> a and also provides a default implementation of f.
07:34:09 <dhess> data D is an instance of C in module D.hs, imports C as C (C (..)), and does not override f.
07:34:16 <dhess> Both D.hs and C.hs are Exposed-Modules in project.cabal
07:34:17 <dhess>  
07:34:24 <dhess> When I cabal build the project and run it, everything works fine, until I change the implementation of f. When I cabal build again, if I haven't touched D.hs, D.hs is not recompiled and running f on a value of type D does not see the new version of f.
07:34:46 <dhess> I must be missing something but not sure what.
07:35:11 <merijn> dhess: I think the answer is: cabal isn't smart enough to notice that
07:35:28 <dhess> merijn: Hmm, so this is a known issue?
07:35:30 <merijn> dhess: And the answer to why not is: Either no one thought of that or it was too hard to implement
07:35:31 <bennofs> dhess: which GHC version? can you produce a minimal example that demonstrates the problem? (cabal uses ghc --make, so you should be able to reproduce it using ghc --make C D)
07:35:50 <merijn> Oh, is it a GHC issue?
07:35:56 <dhess> bennofs: 7.8.4 with cabal 1.22.
07:35:59 <dhess> .something
07:36:15 <orion> I heard someone say that function application is just like multiplication. How does that work?
07:36:22 <dhess> bennofs: Sure, I could whip something up.
07:36:30 <srhb> So erm... Type wizards, please? http://stackoverflow.com/a/29826322/288913 -- Does this mean (if the plugin is actually working) that the correct way to add this kind of evidence is currently only doable via type checker plugins?
07:36:50 * srhb wonders if this should be "kind wizards"
07:37:03 <merijn> srhb: There is work being done on a smarter solver, but it isn't done yet
07:37:13 <srhb> Well, it appears to work!
07:37:54 <bennofs> dhess: ok nvm, just reproduced. i would report as a bug if there isn't one already
07:38:08 <merijn> srhb: Then I don't understand what your question is?
07:38:12 <bennofs> dhess: (still appears with GHC 7.10)
07:38:50 <srhb> merijn: Using the plugin as stated in my answer -- is that how we provide evidence currently? ie. it is smart enough, the question is whether the evidence can be provided ad-hoc in a module, instead of having to use the plugin.
07:38:58 <dhess> bennofs: OK, will do. I'm surprised this hasn't been encountered before.
07:39:31 <dhess> bennofs: This should be reported on GHC and not cabal-install?
07:40:15 <bennofs> dhess: yes, creating two files D.hs and C.hs with your described contents and then running ghc --make (before and after changing default impl) produces the same behavior as you described
07:40:18 <bennofs> @where trac
07:40:18 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
07:40:34 <merijn> srhb: You can't do that without the plugin, afaik
07:40:40 <srhb> merijn: Thanks!
07:40:42 <dhess> bennofs: OK, thanks for the pointer.
07:41:05 <merijn> srhb: But, as I said, someone is working on a smarter solver for Nat constraints in GHC. So Soon (TM) you shouldn't need a plugin at all
07:41:15 <srhb> merijn: yav, right?
07:41:19 <merijn> bennofs: FYI --make is redundant
07:41:29 <bennofs> merijn: oh right, almost forgot about that
07:41:36 <merijn> bennofs: GHC has assumed "--make" as default since I think like 6.12 :)
07:41:55 <bennofs> merijn: I know, i never even used haskell when GHC required --make
07:41:59 <dhess> https://ghc.haskell.org/trac/ghc/register --> "You don't have permission to access /trac/ghc/register on this server."
07:42:30 <dhess> where do I report bugs on reporting bugs? :)
07:42:37 <geekosaur> dhess: ask in #haskell-infrastructure
07:42:43 <dhess> geekosaur: thanks
07:43:01 <geekosaur> but it may be disabled temporarily because a spambot has been hitting the trac registration very heavily for the past week or so
07:43:05 <chpatrick> https://gist.github.com/chpatrick/00f57dd114cbe7c33e97
07:43:11 <chpatrick> ^ what do you guys think?
07:44:57 <merijn> dhess: Registration is currently disabled because trac has been spammed so badly that devs could barely use it becase it was so slow
07:45:08 <dhess> merijn: got it, I'm working with them now.
07:45:16 <merijn> dhess: If you mail me your report I'd be happy to file it for you
07:45:46 <dhess> merijn: That's very kind. Do you want basically what I flooded the channel with? Or do you want a tarball as well?
07:46:28 <merijn> See PM
07:53:31 * hackagebot yet-another-logger 0.2.2 - Yet Another Logger  http://hackage.haskell.org/package/yet-another-logger-0.2.2 (larsk)
07:56:26 <Lis> i have a function which returns values with either. now i want to change it to only return [[String]] my idea was to use case ... of but i can't get it to work. http://lpaste.net/131315
07:57:15 <geekosaur> first off, if you want to keep that putStrLn, then it must be IO [[String]]
07:57:30 <srhb> readFile is sufficient for that.
07:57:35 <geekosaur> as the original was actually IO (Either ParseError [[String]])
07:57:43 <geekosaur> ah, yes, readFile too
07:58:11 <geekosaur> additionally, you need to decide what to do other than print the error
07:58:17 <geekosaur> because you must return *something*
07:58:34 <geekosaur> empty list? throw an exception? invoke "fail"?
07:59:02 <Lis> geekosaur, print the error and exit is what i want
07:59:25 <Lis> geekosaur, but my thoughts with case are the right way?
07:59:32 <geekosaur> roughly yes
07:59:38 <Lis> great ty
08:00:25 <StrangeLoop> OK, I have this implementation: http://lpaste.net/131316. It feels a bit too cumbersome, do you have tips on making it more elegant?
08:00:25 <geekosaur> in IO there's still severl ways to exit. you can use System.Exit.exitFailure or you can throw an exception (default action = exit) or `fail` (which throws an IOError)
08:03:56 <Lis> @hoogle ParseError -> String
08:03:58 <lambdabot> Prelude show :: Show a => a -> String
08:03:58 <lambdabot> Text.Show show :: Show a => a -> String
08:03:58 <lambdabot> Test.QuickCheck.Text showErr :: Show a => a -> String
08:09:29 <Lis> geekosaur, thank you, this perfectly works: http://lpaste.net/131315
08:12:14 <sh1ken> Can I evaluate a function call completely before sending it as an argument to another function?
08:13:40 <geekosaur> seq, or one of the things that uses it e.g. ($!)
08:13:57 <geekosaur> @src ($!)
08:13:57 <lambdabot> f $! x = x `seq` f x
08:14:28 <dhess> bennofs: Hmm, I can't reproduce this build problem with GHC 7.8.4 using "ghc --make Main.hs" and a Main.hs that calls f on D. I can't reproduce it with "ghc Main", either. Just cabal build and cabal run. What command-line did you use?
08:14:45 <dhess> (I've never used ghc --make before, so didn't occur to me to test it until you mentioned it.)
08:15:03 <sh1ken> geekosaur: Yeah, thanks! That's exactly what I'm trying to use but I'm not quite sure why it doesn't work
08:15:16 <geekosaur> @paste actual code?
08:15:16 <lambdabot> Haskell pastebin: http://lpaste.net/
08:15:19 <fabian__> At some time ago I hard about a Monad (or Comonad) used as the base for some library (lenses or pipes) that were really cool and fundamental, but I cant remember the name
08:15:45 <srhb> fabian__: Sounds like Free. It's always Free, isn't it... :P
08:15:59 <dhess> fabian__: not sure that it's used in lens but the Free monad maybe?
08:16:26 <fabian__> hmm
08:16:33 <fabian__> no started with C i thing
08:16:37 <fabian__> like Condensed
08:16:38 <srhb> CoFree!
08:16:40 <srhb> Oh
08:16:42 <fabian__> or something like that
08:16:58 <geekosaur> Codensity?
08:17:23 <srhb> lambdabot needs a "guess the monad" module
08:17:26 <dhess> Cont ?
08:17:38 <sh1ken> geekosaur: It's something like this: http://lpaste.net/131322
08:17:40 <fabian__> Codensity might be it
08:18:00 <dhess> I can barely read the lens Hackage page, let alone the code ;)
08:18:02 <sh1ken> I need that anotherfun is totally evaluated before calling apply
08:18:16 <dhess> s/read/follow/
08:18:17 <fabian__> Could someone explain it?
08:19:30 <srhb> sh1ken: seq? Though I'm not sure what you're actually trying to achieve.
08:20:00 <geekosaur> sh1ken, if it absolutely needs to be completely evaluated then you're looking at http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/deepseq-1.3.0.1/Control-DeepSeq.html
08:20:43 <lpaste> geekosaur annotated “No title” with “No title (annotation)” at http://lpaste.net/131322#a131323
08:20:46 <geekosaur> but I would expect ^^ to work
08:20:51 <geekosaur> in most cases
08:21:31 <sh1ken> srhb: anotherfun goes to an error in certain cases. I need to raise that error before calling apply.
08:21:38 <bennofs> dhess: oh sorry, I might have reacted too fast. I just noticed that even though D.hs is not recompiled, C.hs is and it picks up the new default from there
08:21:42 <michaelt> fabian__: maybe these exercises? http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/
08:21:48 <sh1ken> otherwise apply would have another result based on lazy evaluation of anotherfun.
08:21:59 <bennofs> dhess: I have to go now, sorry. I'll be back later
08:22:13 <srhb> sh1ken: I think you would benefit from giving us more details. Sounds like you're doing something funky / wrong :)
08:22:31 <dhess> bennofs: No problem, I think this is a cabal issue now, however.
08:22:42 <dhess> As I can't reproduce it using just ghc.
08:23:33 * hackagebot digestive-functors 0.8.0.0 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.8.0.0 (JasperVanDerJeugt)
08:23:35 * hackagebot digestive-functors-blaze 0.6.0.6 - Blaze frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-blaze-0.6.0.6 (JasperVanDerJeugt)
08:23:36 <sh1ken> srhb: Indeed. I have several data structures so let me come up with a toy example that can be self explanatory of what I'm trying to achieve
08:23:37 * hackagebot digestive-functors-snap 0.6.1.2 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.6.1.2 (JasperVanDerJeugt)
08:23:44 <srhb> sh1ken: Cool :)
08:26:46 <chpatrick> fabian_: Codensity is to monads what DList is to lists
08:28:33 * hackagebot digestive-functors-heist 0.8.6.2 - Heist frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-heist-0.8.6.2 (JasperVanDerJeugt)
08:28:35 * hackagebot digestive-functors-happstack 0.6.1.1 - Happstack backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-happstack-0.6.1.1 (JasperVanDerJeugt)
08:29:55 <michaelt> fabian__: the pipes type is a typical 'free monad', if that's what you are interested in, the basic type is sort of Pipe a b m r = FreeT (Data.Functor.Sum.Sum ((,)b) ((->)a)) m r -- or something like that
08:31:47 <sh1ken> srhb: Here http://lpaste.net/131327
08:32:09 <sh1ken> if I do: run [(1,1),(2,2),(3,2)]
08:32:15 <sh1ken> I need to raise that error either way
08:32:28 <sh1ken> and with lazy evaluation I'm geetting 1.
08:32:36 <srhb> sh1ken: I don't think you should be using error at all.
08:33:07 <sh1ken> what should I use?
08:33:14 <srhb> sh1ken: Unless you're specifically trying to play with exceptions, and then you should probably be doing something else entirely.
08:33:34 * hackagebot pred-trie 0.0.6.1 - Predicative tries  http://hackage.haskell.org/package/pred-trie-0.0.6.1 (athanclark)
08:34:21 <srhb> sh1ken: There are nicer ways to represent error. What exactly do you mean for anotherFun to do?
08:34:33 <srhb> There are *often* nicer ways, I should say.
08:38:19 <peacememories> hey, i've got a question. have any of you used the recycling bin functionality on windows from haskell?
08:38:40 <peacememories> i'm kind of missing a starting point here^^
08:39:10 <sh1ken> srhb: Sounds about right but I really need to raise that exception for what I'm trying to achieve.
08:39:15 <sh1ken> Is deepseq the only way around it?
08:39:35 <srhb> sh1ken: I have no idea what you're really trying to do, so I don't know. Sorry.
08:40:22 <sh1ken> srhb: That's okay. Thanks either way :)
08:40:29 <srhb> Sure, good luck :)
08:41:40 <Lis> did i mentoin that haskel is the pure epic of epicness
08:42:17 <Lis> reall. i got to know the language about 2 years ago. never looked into it. but if you get used to it you code faster, with less work. it doesnt look like that at first
08:43:18 <Lis> i created a full chart programm with about 1/3 the code of my old c++ application. if you dont count the installed package length however...
08:48:14 <dhess> Is anyone around who works on cabal-install? I have a test case for a possible bug.
08:48:28 <dhess> And if it's not a bug I could benefit from an explanation of what I'm doing wrong.
08:49:02 <dhess> https://drewhess.com/dist/cabal-bug.tar.xz in case anyone is interested.
08:49:59 <stoopkid> in the following type declaration "simpleHTTP :: (ToMessage a) => Conf -> ServerPartT IO a -> IO ()"
08:50:04 <stoopkid> what does => mean
08:50:11 <srhb> stoopkid: What precedes it is the context
08:50:27 <dhess> stoopkid: it means a is an instance of class ToMessage
08:50:32 <srhb> stoopkid: (ToMessage a) => ... means roughly that in the follow, a implements the ToMessage type class
08:50:39 <srhb> following*
08:50:45 <stoopkid> okay, thank you
08:51:41 <humanoyd> Anyone here who uses Turtle?
08:52:00 <saml> how would haskell look like without garbage collection?
08:52:11 <srhb> saml: Not Haskelly.
08:52:18 <dhess> saml: Like a big pile of uncollected garbage :)
08:52:22 <saml> is there such language?
08:52:33 <stoopkid> would this do the same thing: "simpleHTTP :: Conf -> ServerPartT IO ToMessage -> IO ()"
08:52:35 <srhb> There's not much left of Haskell if you take that away.
08:52:42 <KaneTW> a functional language without a gc?
08:52:56 <KaneTW> sounds difficult
08:52:57 <hodapp> I guess Rust is... vaguely like that?
08:53:05 <dhess> If you think Swift is functional, then sort of.
08:53:07 <geekosaur> stoopkid, no, a typeclass is not a type
08:53:19 <adnam> saml: lazy evaluation in particular needs a gc
08:53:33 <srhb> stoopkid: What you _can_ do is choose a concrete type (that implements ToMessage) instead of a
08:53:43 <glguy> dhess: I believe that the bug you're experiencing is just a misconfiguration in your cabal file
08:53:57 <glguy> You have overlapped the source directories of your executable and library
08:54:01 <dhess> glguy: OK, I figured it had to be something like that.
08:54:21 <KaneTW> stoopkid: ToMessage a => a means "anu type a that is an instance of ToMessage"
08:54:21 <glguy> dhess: but you didn't list the library as a dependency and you didn't list modules C or D in 'other-modules' for the executable
08:54:26 <glguy> so cabal doesn't know C and D are related
08:54:33 <KaneTW> stoopkid: simply ToMessage is just a type
08:54:36 <dhess> glguy: Ahh... in the past I've always put the executable in a different directory but for this new project I'm working on, I merged them.
08:54:44 <srhb> Laney: What
08:54:50 <srhb> KaneTW: What
08:54:50 <dhess> glguy: OK, that makes sense.
08:54:53 <srhb> Laney: Sorry, mistell
08:54:54 <glguy> dhess: You should separate them and add a build-depends: cabal-bug to the executable
08:55:27 <srhb> KaneTW: "Simply ToMessage is just a type" <-- I think you a word here. "Not" for instance. :-)
08:55:27 <dhess> glguy: OK, that's normally what I do. I figured this couldn't really be a bug, it would break so many things.
08:55:49 <KaneTW> srhb: i was going off his example
08:56:02 <KaneTW> srhb: lemme elaborate a bit more because i think i cut too much context
08:56:07 <srhb> Yes... :-)
08:56:13 <KaneTW> in simpleHTTP :: Conf -> ServerPartT IO ToMessage -> IO () it -would be- just a type
08:56:17 <dhess> glguy: Thanks! I'll fix that in my project.
08:56:28 <KaneTW> in simpleHTTP :: (ToMessage a) => Conf -> ServerPartT IO a -> IO () it's what i said above
08:56:55 <KaneTW> but ToMessage is a typeclass, so the ServerPartT IO ToMessage -> IO () is invalid
09:04:23 <tsahyt> When representing a triangle mesh using a face-vertex structure where vertices reference faces and vice versa, is there something more idiomatic than this: http://lpaste.net/5549185557038366720 ? It feels strange to basically hack my own pointer/reference system like this.
09:04:54 <tsahyt> I think I could alternatively just rely on laziness but I'm not quite sure if this is gonna work. The mesh is static, so it's read once and then no modifications are done.
09:12:20 <latk> How have people's experiences with opaleye been? It sounds pretty great.
09:15:09 <dhess> latk: It's kind of a pain to parameterize all of your types, which opaleye requires
09:15:34 <joneshf-laptop> tsahyt, which part do you feel is not idiomatic?
09:15:49 <dhess> latk: Especially if you have large aggregate record types. 
09:15:55 <latk> hmm
09:16:07 <dhess> latk: I had to break a few of them up in order to get them to compile with the required number of parameters.
09:16:09 <latk> dhess: What do you tend to use for dealing with dtabases ?
09:16:28 <dhess> latk: Well this is my first Haskell DB app so... opaleye :)
09:16:39 <latk> Haha, fair enough :)
09:16:44 <adnam> latk: i like opaleye a lot, we use it in production at silk
09:16:57 <latk> adnam: How does it compare to, say, persistent /
09:17:01 <dhess> latk: I'm not saying it isn't worth it. It is pretty much unparalleled. But it does have some costs.
09:17:18 <latk> dhess: All haskell db stuff I've used so far has some "interface cost" 
09:17:18 <adnam> latk: i spent a while trying to migrate our code to persistent, but it wasn't flexible enough to handle our schemas
09:17:52 <latk> adnam: Yeah - I've never tried to migrate towards it, only ever used it on small new projects
09:17:54 <adnam> also seems you lose a lot of functionality when you cater to multiple backends like persistent does
09:18:01 <latk> adnam: indeed.
09:18:26 <tsahyt> joneshf-laptop: The fact that I have to resort to explicit indexing.
09:18:50 <dhess> adnam: How do you deal with Haskell types whose best-match DB type are views, and not actual tables?
09:18:57 <latk> I'll give opaleye a go. I guess that is the only thing you can ever do !
09:19:37 <adnam> dhess: i haven't needed to look into that so far!
09:19:39 <dhess> adnam: I haven't gotten to that point yet but it seems I'm going to have to create Haskell types that exist solely to "carry" data from the tables in the DB to my in-memory Haksell representations.
09:20:05 <adnam> dhess: you don't need to, but we do it like that because our domain types seldom have the same representation as in the db
09:20:06 <dhess> adnam: Hmm, lucky guy. Or just really good at DB stuff :)
09:20:38 <srhb> More RAM, acid-state all the things! :-)
09:20:51 <adnam> my experience is that things like this are accidental deduplication, sooner or later they will diverge and that's more painful to deal with than having two separate types to begin with
09:21:14 <safinaskar> hi. let's assume i have a :: Parsec String A Int, b :: Parsec String B Int (i. e. this parsers use different state types). is this possible to do somehow "a = do { b; ... }"? maybe using ParsecT or something else?
09:21:30 <adnam> latk, dhess we also have this: https://github.com/silkapp/silk-opaleye
09:21:46 <safinaskar> i have place in my language where i need big state, but in other places i don't need it
09:22:17 <dhess> adnam: So that sounds exactly like what I'm facing: my Haskell types are different than my DB types, so the types that are parameterized for Opaleye are really just used to load/unload the DB, and are not the same types that I use in the core of my program. Is that also the case for you?
09:22:33 <adnam> dhess: right
09:22:58 <latk> dhess: I've basically found exactly the same in e.g. persistent. You usually store stuff in normal form or whatever, and this is rarely reflected in the haskell type.
09:23:00 <adnam> our opaleye types map directly to the db schema
09:23:00 <dhess> adnam: OK, I was worried this was a code smell and I was doing it wrong, so to speak. That's reassuring.
09:23:13 <dhess> latk: I suppose that's true.
09:24:32 <dhess> srhb: Maybe in 10 years when our phones can cache the Internet :)
09:25:10 <srhb> dhess: That would be nifty!
09:25:19 <dhess> adnam: Does opaleye have any way to mechanize that Haskell type <-> opaleye type glue?
09:25:23 <srhb> Though I'm pretty sure that would render me a criminal in most countries.
09:25:27 <dhess> I haven't seen it if so
09:25:39 <dhess> srhb: shit, what doesn't these days?
09:25:47 <srhb> Good point.
09:30:06 <adnam> dhess: we use polymorphic fields for the data types, that way we can use the default conversions to map e.g. `Column Bool` (or `Column PGBool`) to `Bool`, then we do another conversion to our domain type from there
09:30:20 <adnam> https://github.com/silkapp/silk-opaleye/blob/master/example/Example.hs#L69
09:30:56 <adnam> with the general type that function can map to anything with a Conv instance, which is either PersonH or our domain type
09:32:34 <dhess> adnam: OK, thanks. 
09:33:49 <dhess> I think I'm doing something similar, but I have a few record types that are too large to be parameterized. I've broken them into mulitple Opaleye types but eventually they need to be merged into my core type. That's where it gets boring.
09:34:14 <adnam> yeah writing our Conv instances isn't particuarly interesting
09:34:18 <dhess> that's a GHC issue really, though. Or my schema's , I suppose
09:34:25 <adnam> but luckily it's haskell so it's really hard to make mistakes when doing it :-)
09:35:13 <dhess> adnam: Conv is one of the types in your -extras package?
09:35:37 <adnam> dhess: yeah, https://github.com/silkapp/silk-opaleye/blob/master/src/Silk/Opaleye.hs#L155
09:36:30 <adnam> it basically just says that a domain types has exactly one corresponding opaleye type
09:37:01 <dhess> Most of my large record types only use 2 or 3 different element types, but Opaleye wants you to give each element type its own parameter. That's the real problem.
09:37:24 <dhess> adnam: Cool, that will come in handy. Thanks!
09:38:24 <adnam> dhess: you only need to parametrize them separately if you are doing aggregations
09:38:48 <dhess> adnam: Right, which I am. All over the place.
09:38:55 <adnam> ok :-)
09:39:00 <dhess> so it blows ;)
09:39:36 <dhess> it's just one of those domains where everything is a container of atomic types
09:39:44 <adnam> we have very few aggregations so i haven't looked into this yet
09:40:10 <dhess> adnam: I think GHC gives up somewhere around 20 parameters.
09:40:21 <adnam> really?
09:40:58 <dhess> adnam: Yes, somewhere around there.
09:41:52 <dhess> maybe it's TH and not GHC. TH is currently a black box to me.
09:42:49 <adnam> "as of GHC 6.12.2, the maximum size of a tuple is 62:"
09:43:34 <adnam> @type (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
09:43:35 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 ->
09:43:35 <lambdabot> t59 -> t60 -> t61 -> t62 -> t63 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63)
09:44:04 <bennofs> Is there a writer monad that uses a strict accumulator? Something like (!w,a) >>= f = let (!w',b) = f a in (w <> w', b)
09:45:04 <dhess> adnam: Sorry, I mean the polymorphic parameters in data types.
09:45:49 <adnam> i assumed that was the same :-/
09:46:30 <ryantrinkle> is there a way to get cabal to install build tools automatically?
09:46:51 <ryantrinkle> i've noticed that gtk packages require gtk2hs-builtools, and that requires alex
09:47:02 <ryantrinkle> is there anywhere in the cabal file that those dependencies could be set up explicitly?
09:47:03 <dhess> I'm pretty sure none of my original data types had more than 30 or 40 parameters and I had to break them up with GHC 7.8.4.
09:47:16 <adnam> i defined one with 64 now
09:47:17 <dhess> easy enough to test I suppose.
09:47:22 <adnam> on 7.8
09:47:28 <srhb> bennofs: I  Control.Monad.Trans.Writer.Strict, there is this (unexplained) note, that may be useful? Although the output is built strictly, it is not possible to achieve constant space behaviour with this transformer: for that, use "Control.Monad.Trans.State.Strict" instead.
09:47:32 <srhb> In*
09:48:08 <dhess> adnam: as in, "data Foo' t1 t2 t3 ... t62 = ... "?
09:48:21 <adnam> dhess: yep
09:48:29 <dhess> adnam: Ahh, maybe it was makeAdaptorAndInstance.
09:48:50 <adnam> yes that has a pretty low limit
09:49:08 <adnam> i think i increased it slightly to fit one of our tables ;-)
09:49:12 <dhess> adnam: Like I said, couldn't remember if it was GHC or TH. :)
09:49:22 <adnam> dhess: that's not TH, that's product-profunctors
09:49:49 <bennofs> srhb and anyone else wondering: I believe what that comment is refering to is this: http://stackoverflow.com/a/7735240/2494803
09:49:53 <bennofs> thanks
09:49:57 <dhess> adnam: I assumed it was using TH. TIL.
09:50:03 <srhb> bennofs: Thanks :)
09:50:45 <dhess> it's something in lines that look like $(makeAdaptorAndInstance "pFoo" ''Foo'), anyway
09:53:11 <srhb> bennofs: Also: http://permalink.gmane.org/gmane.comp.lang.haskell.libraries/18980 -- perhaps interesting
09:53:36 <chpatrick> is there a standard type isomorphic to Compose ((,) d) m?
09:53:44 <bennofs> :t Compose
09:53:45 <lambdabot>     Not in scope: data constructor ‘Compose’
09:53:45 <lambdabot>     Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
09:53:54 <bennofs> :t Data.Functor.Compose.Compose
09:53:55 <lambdabot> f (g a) -> Data.Functor.Compose.Compose f g a
09:53:57 <adnam> dhess: yes it's using TH, but it's product-profunctor that's missing instances
09:54:00 <chpatrick> so an "applicative" transformer that also appends a monoid
09:54:07 <dhess> adnam: Got it.
09:54:14 <bennofs> chpatrick: WriterT?
09:54:25 <chpatrick> there the monoidal value is in the functor
09:54:29 <chpatrick> here it's next to it
09:54:37 <bennofs> chpatrick: oh no, right, I see
09:54:59 <bennofs> chpatrick: I've always used Product (Const d) m for that though
09:55:23 <chpatrick> that works too :)
09:55:58 <dhess> bennofs: FYI from earlier, no ghc make or cabal bug, I was being stupid in my .cabal file as I suspected.
09:56:50 <bennofs> dhess: what was the issue? could cabal have warned about the case?
09:58:25 <dhess> bennofs: Maybe, but probably not worth it. It was pilot error. Typically (and I think cabal by default) I put my executable in a separate source directory and add the package lib as a dependency, but I decided on this project to put it in the same subdir as the library source.
09:59:58 <dhess> bennofs: If you just put everything in one directory and don't give the modules a library name, and expect cabal to link the exe properly when you've changed the default instance but not the derived type's source, then you get this problem.
10:00:09 <dhess> I don't know how common that is, maybe for smallish projects.
10:00:40 <dhess> bennofs: I have a tarball that reproduces the problem if you want to see it: https://drewhess.com/dist/cabal-bug.tar.xz
10:00:42 <srhb> Hum, it seems like an oversight that WriterT hasn't been fixed/deprecated. At least there seemed to be sort-of consensus in 2013.
10:01:04 <srhb> But mailing list archaeology is iffy. :P
10:01:05 <dhess> but I am satisfied that it was my problem and I've changed my project to be correct.
10:01:09 <bennofs> srhb: I just noticed that too. looking for at least a package thtat implements it now
10:01:33 <srhb> bennofs: I suppose Gabriel might be of help there.
10:01:57 <bennofs> @hackage contstuff just found this @srhb
10:01:57 <lambdabot> http://hackage.haskell.org/package/contstuff just found this @srhb
10:02:06 <srhb> bennofs: Neat, thanks.
10:04:01 <dockdock> is it just me or is 7.10 almost impossible to use due to cabal hell?
10:04:08 <bennofs> srhb: also stateWriter
10:04:29 <srhb> dockdock: Just you.
10:04:54 <srhb> dockdock: (And others who use packages that are outdated.)
10:04:54 <dockdock> In a clean environment there is few packages that I can install
10:05:24 <dockdock> random picks at hackage sugests 1/10 works
10:05:34 <dockdock> maybe I was unlucky
10:05:39 <srhb> dockdock: A lot of Hackage is dead and outdated. 
10:05:56 <dhess> srhb: Are you using Stackage?
10:05:58 <srhb> dockdock: So far my process has been: Relax upper bounds on base, fix time stuff.
10:06:01 <srhb> dhess: No.
10:06:40 <ni291187> slm
10:07:06 <dockdock> been trying to try out yesod yesterday and today. learnt a lot about cabal, sandboxes and dependency resolution, very little about yesod
10:07:46 <dcoutts> dockdock: 7.10 is very new, if you want max compat stick to 7.8 until the new platform comes out
10:07:59 <srhb> dockdock: The only thing I had to fix with Yesod was, surprisingly, fay bounds -- and that is fixed now.
10:08:58 <dhess> dockdock: That was me recently with Nix. Took awhile but now I'm happier than I was before Nix.
10:08:59 <srhb> But yeah, you will be in hell quickly if you didn't use sandboxes before. :-)
10:09:22 <dockdock> Over a month old, not sure I know of any other software that could be called very new 
10:09:32 <dockdock> I wiped all my global packages
10:09:32 <dhess> dockdock: Pretty sure Yesod will also work if you use Stackage and/or Haskell LTS.
10:09:35 <bennofs> dockdock: you can get a quite good overview of what builds on GHC 7.10 here: http://hydra.cryp.to/eval/376342#tabs-still-succeed (everything that doesn't mention another ghc version should be 7.10 afaik)
10:09:44 <dhess> as they're the people developing that infrastructure.
10:09:48 <bennofs> dhess: stackage does not support GHC 7.10 iirc yet
10:09:59 <dhess> bennofs: Oh yeah, forgot about the GHC 7.10 part.
10:10:04 <dhess> never mind.
10:10:05 <yasar11732> I created this Monad, but I am not sure how I can use it in do notation http://lpaste.net/131339
10:10:19 <dockdock> dhess: do you mean that you are no longer using Nix?
10:10:47 <dhess> dockdock: No, I mean that it was a struggle for about 3-4 days and I got no actual code written, but now I've figured it out well enough that I'm using it and benefiting from it.
10:11:09 <dockdock> that is almost encouraging
10:11:20 <dhess> hehehe :) It was mean to be almost encouraging, so good.
10:11:46 <dhess> dockdock: however I would wait until they release the new haskellng package stuff with 7.10 before you jump in, if you want to use GHC 7.10
10:12:17 <dockdock> I used what was in my distros package manager, not really choosen it
10:12:20 <dhess> I initially tried with 7.10 but it's just not ready yet, so I backed off to 7.8.4. However, when 7.10 is ready it will be really easy and just a matter of installing a different package version in my environment.
10:12:23 <dockdock> gonna try out 7.8 now
10:12:54 <dhess> (I'm speaking about using 7.10 with Nix here, not in general, in case that wasn't clear.)
10:13:14 <srhb> dockdock: I'm surprised what you did though, since I'm fairly sure that cabal install yesod in a sandbox just worked for me.
10:13:20 <srhb> Maybe something was fubared since last wekk.
10:13:45 <dockdock> I can install yesod-bin tho
10:13:53 <dockdock> can't*
10:14:04 <srhb> Hmm.
10:14:17 <dockdock> Now I don't have ghc anymore so can't compare, compiling 7.8.4
10:14:24 <srhb> Alright.
10:15:02 <dhess> I am so glad we all have enough disk space now to use sandboxes for development. Fixes soooo many problems.
10:15:07 <srhb> Indeed.
10:15:21 <dhess> OSes are just big shells now :)
10:16:23 <dockdock> hehe yeah
10:16:40 <dockdock> My company made a C fork that can only be compiled statically
10:16:52 <dockdock> who cares if our binaries are 10MB
10:17:12 <dhess> If it's not for an embedded/mobile platform, I'm pretty convinced that's the way to go now.
10:17:57 <dockdock> we get to have awesome things like segmented stacks
10:18:12 <dhess> Someday it may be whole VMs for a single binary.
10:18:23 <c_wraith> isn't that the docker dream?
10:18:35 <dhess> but then your service APIs are the part that breaks when you push :)
10:18:48 <dhess> c_wraith: I think Docker is smaller granularity than VM.
10:19:06 <dhess> c_wraith: I suppose it's semantics.
10:19:07 <c_wraith> dhess: well, sure.  Throw out the parts that aren't needed for more than the binary you're running. :)
10:19:25 <dockdock> In a way a process is a VM
10:20:09 <dockdock> to me the concept of VM's is very unclear, I've worked with linux containers and such for too long
10:22:13 <yasar11732> is this how I should use the do notation? http://lpaste.net/131339
10:22:44 <Chousuke> containers are a lazy man's deployment system :P
10:23:04 <dockdock> We actually use containers for viritualization
10:23:21 <dhess> Chousuke: I assume you use Haskell so I don't have to tell you the virtues of being lazy ;)
10:23:36 <Chousuke> dhess: well... it depends :)
10:23:40 <dockdock> Chousuke: also, implyying lazy is bad
10:24:10 <dockdock> http://www.reddit.com/r/archlinux/comments/32n9tx/haskell_arch_hell_on_earth/
10:24:14 <dockdock> heh, not just me then
10:24:32 <Chousuke> dockdock: what do you mean containers for virtualization?
10:24:40 <Chousuke> you run hypervisors in containers?
10:25:15 <dockdock> We viritualize everything that is accessible in the container
10:25:28 <dockdock> you can't tell you're in one
10:25:46 <Chousuke> how do you accomplish that?
10:26:01 <dhess> dockdock: In my experience, trying to use the system's GHC (i.e., the one that Arch packages) is trouble in the end. Compile one and stick it /usr/local/stow and use that, or if you're crazy try Nix (you can run it sidecar-style in your OS).
10:26:07 <dockdock> you mostly only have to make /proc lie
10:26:14 <Chousuke> I mean, containers as they are currently don't offer enough isolation to be secure. :/
10:26:27 <Lis> whats the prefered way to convert a date to a list of [dd,mm,yyy] ?
10:26:33 <Lis> from string
10:26:34 <dockdock> they can't isolate users with CAP_SYS
10:26:38 <dhess> dockdock: but you basically want to decouple your dev environment from the system's packages, as you don't control those, when they're upgraded, what packages they install, etc.
10:26:46 <dockdock> so don't give them that capability
10:26:47 <dhess> Chousuke: no argument there.
10:27:04 <dhess> dockdock: but then container root == system root.
10:27:47 <Chousuke> containers are good for dealing with services as independent units but I'm skeptical that they're any good for security, yet.
10:28:04 <dockdock> nope, I'm not in the business of selling arbitrary systems thankfully. We just make it seem like they are more bare metal than they are
10:29:39 <dockdock> and on a side note, I haven't seen a single "cloud hosting company" that has not had insane security issues with hypervisors leaking and breaking
10:29:59 <Chousuke> an "ideal" scenario with containers would be that all services on a system operate on their own view of the world, so that if you need to migrate a service from one system to another, it just means migrating the container and its associated data.
10:30:27 <Chousuke> dockdock: well, at least with hypervisors such things are significantly less common.  with containers you don't have it at all :)
10:30:37 <Chousuke> and by it I mean security
10:31:05 <Ryanar> if you are trying to get the first value in the tuple returned by reads, how is that done? ex. lex "hello world" returns ReadS String [("hello"," world")] and I am trying to get the fst
10:31:53 <Cale> case reads s of (x,s'):_ -> ... ; [] -> ...
10:32:05 <Ryanar> ah I see
10:32:09 <Ryanar> thanks!
10:32:13 <Cale> No problem
10:32:47 <dockdock> Chousuke: There has never been an issue that has been relevant to us, on the other hand we don't give the users much 
10:33:09 <Chousuke> One thing containers are good for is running multiple instances of the same service on one host; eg. several apache servers or database instances. It makes administration easier when the service can just assume it owns the world (as they tend to do) and is the "only" instance running on the system.
10:33:56 <Cale> Ryanar: If you have a bunch of things which need to be parsed, you might find it useful to use a list comprehension or do-notation
10:33:57 <dhess> Chousuke: except for the mess that is hooking up the container network to the host's. Ugh.
10:34:40 <dockdock> also, our service is as is a webhosting one, many containers doing similar things. at most they need to install stuff in their filesystems
10:34:44 <dockdock> dhess: tell me about it
10:35:03 <dockdock> Most our container related code is about network
10:35:04 <Chousuke> dhess: yeah, that seems to be the main thing missing at the moment, besides better isolation.
10:35:21 <dockdock> device cloning and sending fds over fds
10:35:29 <dhess> Chousuke: the appeal to me of containers is that they're buildable with (fairly) portable, free software user-space tools, so that you can create them and tear them down really easily.
10:35:53 <Ryanar> Cale, what I am doing is defining a reads based parser, and I am using do notation to continue parsing
10:35:54 <dhess> It's a lot nicer than trying to build VM instances in (choose your vendor of choice's tools)
10:35:55 <dockdock> to me they are more what processes should have been
10:36:05 <tdammers> the networking part is pretty manageable with something like vagrant though
10:36:07 <Cale> Ryanar: yeah
10:36:23 <dhess> tdammers: But you don't deploy to Vagrant, right?
10:36:30 <Chousuke> dhess: well, vm instances are pretty easy nowadays too. but if you're just running a single instance of a software to do a single thing, a vm is pretty overkill
10:36:41 <tdammers> dhess: nope
10:36:59 <Cale> > do (n,s') <- reads "1 2 [3,4,5]"; (m,s'') <- reads s'; (ks,[]) <- reads s''; return (n :: Integer, m :: Integer, ks :: [Integer])
10:37:01 <lambdabot>  [(1,2,[3,4,5])]
10:37:09 <tdammers> Chousuke: the nice thing about developing in a VM is that I can go ahead and do wild stuff without messing up my main OS
10:37:19 <dhess> Chousuke: in the long run a VM/service is overkill, but for now, as you've pointed out, I don't think the tradeoffs are worth the risks. Better just to buy bigger servers for the time being.
10:37:26 <dockdock> hypervisor based vm's suck for a lot of stuff, massive performance hit and memory usage
10:37:30 <dhess> I'm not anti-container, just anti-current-container-implementation.
10:37:42 <Chousuke> tdammers: I'd definitely develop my containers on a test VM before putting any in production :P
10:37:46 <dhess> In the end it's all rump kernels anwyay :)
10:37:51 <dockdock> I'm more anti the current linux networking in general
10:38:00 <dhess> dockdock: have you checked out OVS?
10:38:05 <dockdock> nope
10:38:09 <Chousuke> ovs is great
10:38:11 <dhess> Pretty sweet. You should.
10:38:16 <dhess> Open Virtual Switch.
10:38:19 <dockdock> oh
10:38:20 <dockdock> yes
10:38:26 <dockdock> use it
10:38:34 <dhess> how's the performance?
10:38:39 <dhess> vs. native?
10:38:48 <dockdock> almost exactly the same
10:38:57 <dhess> I loooked into it recently but all of the off-fast-path cases worried me
10:39:06 <dhess> I know they're working on that.
10:39:18 <dockdock> use it in our openstack cluster
10:39:25 <dhess> dockdock: do you do any "VXLAN"-type stuff?
10:39:51 <dhess> (I feel bad talking about this in #haskell.)
10:40:12 <bennofs> dhess, dockdock: try #haskell-blah
10:40:14 <dockdock> I don't know, I can the guy who built that
10:40:18 <dockdock> hehe
10:40:20 <dhess> bennofs: OK, I'm sorry.
10:41:05 <bennofs> dhess: no problem, just answering to your question :)
10:43:39 * hackagebot crypto-classical 0.0.2 - An educational tool for studying classical cryptography schemes.  http://hackage.haskell.org/package/crypto-classical-0.0.2 (fosskers)
10:44:35 <dhess> Hmm that's an interesting one.
10:45:17 <dhess> OK, thanks for the help today, everyone! This is a very nice IRC community.
10:45:23 <dhess> cya
10:52:29 <sebastianrkg> I have the following build error, and I can't figure out what is going wrong: "cannot satisfy -package-id <mypackagename>"
10:52:40 <sebastianrkg> has anyone else encountered this before?
10:57:08 <sebastianrkg> blah, destroyed my sandbox config file and my dist/ folder and started from the beginning and it went away
10:57:12 <srhb> Does Christiaan Baaij hang around here under some name?
11:01:34 <Lis> has someone here experience with the chart package?
11:01:41 <hexagoxel> sebastianrkg: can happen when you reinstall a dependency, but do not reconfigure. `cabal configure`ing again should fix it
11:02:02 <Lis> i try to fill the x axis with dates, i got to the tuple part but only get Expected type: [[(x0, y0)]]
11:02:10 <Lis> Actual type: [((Int, Int, Int), LogValue)]
11:02:17 <sebastianrkg> hexagoxel, okay I'll try that next time I see it, would be easier
11:07:18 <yunxing> Hi, I was reading the mio paper. It makes sense for async io, but I'm just wondering what happens when one of the green threads executes a blocking system call? Will it block the underlying os thread? 
11:13:52 <nak> srhb good morning
11:13:57 <nak> afternoon
11:13:58 <srhb> nak: Morning!
11:14:01 <nak> whatever i was up too late last night lol
11:14:10 <nak> it's 13:00 it can't be morning lol
11:14:13 <srhb> Morning is also when I awake, usually.
11:14:19 <nak> yeah! 
11:14:22 <nak> exactly
11:14:31 <nak> someone who Gets It™ ^
11:18:40 * hackagebot parseerror-eq 0.1.0.1 - Adds and Eq instance for Parsec's ParseError if needed  http://hackage.haskell.org/package/parseerror-eq-0.1.0.1 (sestrella)
11:21:01 <nak> srhb i was playing around with the . operator a little more last night
11:21:24 <nak> > filter ((==0) . (`mod` 2)) (map ((!!3) . iterate (^2)) [1..10])
11:21:26 <lambdabot>  [256,65536,1679616,16777216,100000000]
11:21:43 <srhb> Looks like you've got pointfree style nailed, too. :P
11:21:45 <nak> "display even results for the 3rd square of each of the numbers 1-10"
11:21:48 <srhb> Yep
11:21:59 <srhb> :t isEven
11:22:01 <lambdabot> Not in scope: ‘isEven’
11:22:02 <srhb> :t even
11:22:03 <lambdabot> Integral a => a -> Bool
11:22:04 <nak> what is "point free"
11:22:34 <srhb> nak: Points are variables. In the argument to filter you're not using, say \x -> (... long stuff ...) x
11:22:40 <srhb> No variable, no point.
11:22:48 <nak> nice
11:22:57 <srhb> (Removing points like that is called eta reduction)
11:23:16 <nak> yeah this whole (+5) returns a function thing...
11:23:23 <nak> i mean... you can compose/decompose the hell out of anything
11:23:29 <srhb> That's the idea :D
11:23:32 <nak> automatic currying...
11:23:35 <nak> so fricken elegant
11:27:49 <KaneTW> > intersperse ' ' "ＴＥＳＴ"
11:27:50 <lambdabot>  "\65332 \65317 \65331 \65332"
11:28:41 * hackagebot ghc-prof-flamegraph 0.1.0.0 - Generates data to be used with flamegraph.pl from .prof files.  http://hackage.haskell.org/package/ghc-prof-flamegraph-0.1.0.0 (FrancescoMazzoli)
11:31:36 <myShoggoth> hey I'm a n00b to both Haskell and Yesod, totally stuck on one thing that seems like it should be minor but I cannot figure it out. I want to take a list of model objects from selectList and turn it into a list of just the model object like: getDomainModel :: ParentModelId -> [DomainModel].  cannot figure out how to get the IO monad out of the return signature
11:32:09 <bernalex> how do I say ':: a -> NOT a'? i.e. a -> b where b can't be a
11:33:26 <KaneTW> i don't think you can do that
11:34:14 <bernalex> KaneTW: are you sure? I thought I've seen it someplace. with some extensions.
11:34:20 <KaneTW> hmm
11:34:25 <KaneTW> no i'm not sure at all
11:34:27 <srhb> Data.Type.Equality plus some negation?
11:34:28 <hiptobecubic> bernalex, Out of curiosity why would you want such a function?
11:34:29 <KaneTW> just can't think of a way
11:34:56 <safinaskar> for example, i have data X = A | B | C. is this possible to write somethink like case x of { A|B -> ...; C -> ...} ?
11:35:00 <bernalex> hiptobecubic: I don't. someone asked me if you *can* express such a type, and I seem to remember reading about it somewhere. maybe even in this channel.
11:35:03 <srhb> bernalex: http://stackoverflow.com/a/17756741/288913
11:35:03 <phaazon> hey, is there a lib to enhance HTTP so that it supports https?
11:35:17 <mniip> safinaskar, yes
11:35:22 <mniip> C -> ...; _ -> ...
11:35:24 <hiptobecubic> phaazon, I think no. I use http-client
11:35:37 <hiptobecubic> which has a tls version i think
11:35:39 <bernalex> srhb: oh yes, that's it! I even had this in my history. thanks.
11:35:42 <safinaskar> mniip: *facepalm*
11:35:58 <mniip> otherwise no, use a where-binding
11:36:05 <phaazon> hiptobecubic: thanks
11:36:38 <safinaskar> mniip: thanks
11:37:19 <joneshf-laptop> srhb, does the ordering matter there?
11:37:37 <srhb> joneshf-laptop: I have absolutely no idea, I've only been exposed to type families today and my face is like whaaaaaa :-)
11:37:43 <joneshf-laptop> oh
11:37:44 <srhb> and DataKinds
11:38:06 <srhb> I would assume not, though.
11:42:50 <Ryanar> Did anyone see or have thoughts on the Earling library?
11:43:25 <srhb> lots of upboats on Reddit, presumably yes :)
11:44:01 <Ryanar> upboats haha
11:53:44 * hackagebot pgdl 8.1 - pgdownloader  http://hackage.haskell.org/package/pgdl-8.1 (sifmelcara)
11:55:26 <tempname11_> tricky / vague question: how could evaluation order possibly cause a bug?
11:55:49 <tempname11_> I know it shouldn't, but I think it does have an effect on my I/O
11:56:21 <tempname11_> I feel like I'm banging my head against the wall with this bug :/
11:56:24 <indiagreen> tempname11_: if you're using lazy IO, for instance
11:56:35 <tempname11_> indiagreen: yep, checked that throughly
11:56:43 <indiagreen> then paste your code
11:57:07 <indiagreen> or at least tell what it deals with (network, GUI, what libraries, etc.)
11:57:13 <tempname11_> the program is too big. and it's difficult to reduce it to a minimal case
11:58:17 <tempname11_> I'm reading files, transforming the data, and then using the SDL2 library to create textures from that data.
11:58:21 <chpatrick> what goes wrong?
11:58:39 <tempname11_> Sometimes, the texture becomes garbage
11:58:44 * hackagebot keyword-args 0.2.0.2 - Extract data from a keyword-args config file format  http://hackage.haskell.org/package/keyword-args-0.2.0.2 (sestrella)
12:00:38 <tempname11_> I feel I'm being terribly vague, and I wish I could be more descriptive, but it's pretty tricky to explain
12:07:11 <haasn> tempname11_: does the corruption happen inside haskell code (ie. can you see the garbage pixels inside haskell, before sending it to SDL), or is it perhaps caused by some weird SDL interaction?
12:08:56 <tempname11_> haasn: good thinking, thanks. I'll check it right now
12:12:57 <ParahSailin> cabal sdist is making tarballs with bad timestamps
12:14:19 <dmj`> ParahSailin: how bad
12:14:54 <ParahSailin> 2 hours ahead
12:15:55 <ParahSailin> wait, is the hackage server's system time off?
12:16:23 <nshepperd_> it must be broken, timezones have no place in a timestamp
12:18:45 * hackagebot getopt-generics 0.6.2 - Simple command line argument parsing  http://hackage.haskell.org/package/getopt-generics-0.6.2 (SoenkeHahn)
12:19:01 <haasn> nshepperd_: but how well we adjust for relativity?
12:21:19 <nshepperd_> just give up™
12:23:26 <ParahSailin> is it just me or can anyone upload tarballs to hackage
12:23:35 <nshepperd_> (but actually I think they call it mean geoid time? and you use the earth as an arbitrary frame of simultaneity)
12:24:42 <nshepperd_> it works as long as none of your servers fall through a wormhole
12:26:32 <tempname11_> haasn: I don't think it happens inside the Haskell code. It's probably me doing something wrong with SDL and blaming it on tools :)
12:27:41 <haasn> tempname11_: If the issue happens at random, then perhaps SDL is reading outside of the defined buffer ranges
12:28:00 <haasn> (check size/stride/format/depth etc. parameters?)
12:28:45 * hackagebot strive 1.0.1 - A Haskell client for the Strava V3 API.  http://hackage.haskell.org/package/strive-1.0.1 (fozworth)
12:29:25 <bennofs> ParahSailin: anyone can upload new packages. for existing packages, you need to be in the package's maintainers group to be able to upload new versions
12:29:49 <bennofs> ParahSailin: (you still need to have a hackage account to upload new packages though)
12:29:53 <haasn> fun fact: that used to not be the case, and anybody could just intentionally or accidentally clobber another package
12:30:14 <adnam> did anyone ever abuse that? :-)
12:30:14 <ParahSailin> no, i know you can, its just that hackage keeps rejecting mine for bad timestamp
12:33:17 <peacememories> heya
12:33:36 <ParahSailin> dangit Error 503 backend read error
12:33:46 * hackagebot bgzf 0.1.0.0 - Blocked GZip  http://hackage.haskell.org/package/bgzf-0.1.0.0 (rcallahan)
12:33:49 <ParahSailin> after all that effort opening a wormhole to get a timestamp right
12:33:54 <ParahSailin> oh ^ there it worked
12:34:03 <peacememories> is there a way to specify cabal dependencies for only one os? like depending on the win32 lib only if you're on windows
12:34:42 <galderz> hi all, trying to use ghc-mod on Emcas
12:34:44 <galderz> Emacs
12:35:38 <galderz> trying to execute "C-u M-t" on an unfinished declaration
12:35:46 <galderz> keep getting "Cannot obtain initial code"
12:35:56 <galderz> declaration is: 
12:35:56 <galderz> instance Eq ExampleType where
12:36:10 <galderz> any ideas?
12:38:10 <galderz> i also see "Haskell failed Ind" at the bottom
12:39:15 <eddsteel> does anyone have a good example of a type class that breaks the monad associativity law but otherwise "feels" like a monad?
12:39:27 <eddsteel> I couldn't really come up with one
12:40:11 <eddsteel> i.e. (m >>= f) >>= g ≡ m >>= (\x -> f x >>= g) (from https://wiki.haskell.org/Monad_laws)
12:40:24 <boxfire> hmm I can not do [1..] \\ [2..] eh
12:40:52 <EvanR> :t [1..] \\ [2..]
12:40:53 <lambdabot> (Enum a, Eq a, Num a) => [a]
12:40:59 <EvanR> > [1..] \\ [2..]
12:41:04 <lambdabot>  mueval-core: Time limit exceeded
12:41:19 <boxfire> EvanR: I fully expected [1]. Was dissapointed
12:41:34 <EvanR> blame the algorithm, which doesnt know the lists are sorted
12:41:46 <EvanR> you might be able to write one that assumes they are sorted
12:41:49 <boxfire> I guess I have to write a smart \\ for sorted list
12:41:51 <boxfire> yeah
12:42:35 <EvanR> it still wont complete though and would be more like 1:bottom
12:42:43 <boxfire> but then there is the case [1..] \\ [1,3..]
12:43:01 <boxfire> I guess I do not know how infinite lists work internally
12:43:03 <latk> How do people deal with sum types in opaleye ?
12:43:05 <boxfire> research time
12:43:36 <adnam> latk: for one column?
12:43:53 <EvanR> boxfire: while youre at it understand lazy evaluation
12:43:57 <mniip> [22:42:07] <boxfire> I guess I do not know how infinite lists work internally
12:44:00 <latk> adnam: Yes. Is there some special way of doing it ?
12:44:01 <mniip> there's nothing special
12:44:02 <EvanR> and evaluation to weak head normal form
12:44:08 <mniip> just lazy evaluation like everywhere else
12:44:23 <latk> adnam: Or do you just have to do some kind of string reading/writing ?
12:44:45 <adnam> latk: pick a type and map to it somehow, usually i just go to Text/PGText
12:45:03 <boxfire> so is there a way to detect an infinite list?
12:45:06 <EvanR> no
12:45:19 <alynn> depends what you mean by detect
12:45:25 <tdammers> boxfire: there is one, but if the list is infinite, you'll wait forever
12:45:35 <EvanR> that doesnt count
12:45:47 <tdammers> I know. It's the Halting Problem.
12:46:02 <hexagoxel> peacememories: have a look at https://hackage.haskell.org/package/directory-1.2.2.1/directory.cabal
12:46:06 <StoneToad> boxfire: if you're willing to decide arbitrarily that any number above some finite limit is practically equivalent to infinity, then it's fairly easy
12:46:13 <EvanR> >_>
12:46:15 <boxfire> being able to make a [1..] \\ [1,3..] yield [2,4..] would require that
12:46:24 <EvanR> no it wouldnt
12:46:24 <peacememories> hexagoxel, ah, nice. thank you
12:46:50 <adnam> latk: sometimes i derive json instances, that way you can migrate to a new version easily if you need to
12:47:06 <StoneToad> boxfire: map (+1) [1..]
12:47:13 <mniip> [22:44:09] <boxfire> so is there a way to detect an infinite list?
12:47:16 <mniip> halting problem
12:47:19 <StoneToad> and [1..] gives [1,2,3...]
12:47:34 <latk> adnam: Yeah, I was thinking of doing this. I'm still not clear how I should lay out my tables etc, need to do a bit of experimenting.
12:48:29 <tdammers> > [1,1..]
12:48:30 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
12:48:41 <boxfire> StoneToad: map(+1) [1..] /= [1..] \\ [1,3..]
12:48:42 <tdammers> maybe this is the intention here?
12:48:52 <EvanR> boxfire: if you care about the distinction between finite and infinite list you might be able to use a different data type. for example Stream is definitely infinite
12:48:55 <quetzakubica> Hello, I'm just starting with haskell and functional programming. I have a question, is functional programming easy to read? because when I look at examples or yesod source, it is extra difficult to understand what it does. I have some experience with OOP (5 years) and readability is the most important part for me. So is it because I don't know functional programming?
12:49:18 <EvanR> quetzakubica: you mean haskell code?
12:49:24 <StoneToad> boxfire: yes, but [1..] doesn't equal [1,3..] either
12:49:33 <EvanR> which is different from say lisp, javascript, or something people might call functional
12:49:33 <boxfire> not supposed to
12:49:37 <quetzakubica> EvanR: yes, code
12:49:45 <boxfire> [1..] \\ [1,3..] should equal [2,4..]
12:49:46 <mmachenry> quetzakubica: Carefule not to conflate Haskell, functional, and Yesod.
12:49:47 <boxfire> but haskell hangs
12:49:55 <StoneToad> <boxfire> being able to make a [1..] \\ [1,3..] yield [2,4..] would require that <-- please explain this again then?
12:50:02 <boxfire> > take 10 $ [1..] \\ [1,3..]
12:50:06 <lambdabot>  mueval-core: Time limit exceeded
12:50:08 <tdammers> quetzakubica: functional programming is as easy or as hard to read as the language in question makes it
12:50:11 <EvanR> boxfire: thats different because of the algorithm, imagine trying to sort an infinite list
12:50:14 * StoneToad facepalms
12:50:21 <StoneToad> arg, right \\ is an operator
12:50:31 <StoneToad> too much language changing
12:50:56 <tdammers> quetzakubica: and being familiar with FP concepts is kind of a requirement for understanding functional code, just like being familiar with OOP concepts is kind of required for understanding OO code
12:51:27 <EvanR> boxfire: you can never produce the first element because you need to see what the minimum is of the entire list
12:51:40 <EvanR> @src (\\)
12:51:40 <lambdabot> (\\) = foldl (flip delete)
12:51:48 <tdammers> quetzakubica: and, fwiw, Yesod makes heavy use of DSLs, so even if you're perfectly comfortable with reading Haskell, Yesod would still have you learn all those DSLs in order to make sense of it
12:51:48 <boxfire> ahh. so infinite lists cant be bounded. even though they are guaranteed to have a bound!
12:51:52 <boxfire> that seems like a deficiency
12:51:59 <ski> boxfire : `(\\)' can't know that the `2' element of `[1 ..]' won't occur later in `[1,3 ..]', and so it can't know that it shouldn't remove it
12:51:59 <EvanR> what
12:52:04 <boxfire> they must have either an upper or lower bound. Why not be able to see it
12:52:18 <tremon> quetzakubica: I'd say Haskell code is more terse than the popular OO languages (anything starting with J or C), which makes it easier to "read", but harder to understand at first glance (although that's probably because of unfamiliarity for me).
12:52:23 <koala_man> I had the same problem learning French. I could read English just fine, but the exact same text in French was really hard to understand. I don't know how the french live like that
12:52:29 <ski> boxfire : you can make a variant of `(\\)' that assumes that the input lists are both *ordered*, and then you can get what you expect here
12:52:33 <quetzakubica> hmm, my question should be, am I able to write self describing code in functional paradigm
12:52:37 <tdammers> quetzakubica: and then on top of that, each programming language introduces a bunch of its own idiosyncrasies on top of what comes with a given paradigm
12:52:46 <tdammers> quetzakubica: sure.
12:52:46 <StoneToad> boxfire: you could reimplement a version of the \\ operator for your case
12:52:49 <EvanR> boxfire: a list of Integer may not have a bound
12:52:55 <EvanR> if infinite
12:53:03 <StoneToad> the problem in this case is it dosen't know the list is sorted
12:53:04 <ski> boxfire : "they must have either an upper or lower bound. Why not be able to see it" -- it is not computable
12:53:13 <boxfire> Is it possible to have an infinite list in both directions? e.g.  [..1..]
12:53:17 <StoneToad> no
12:53:21 <StoneToad> well, not with the default type
12:53:24 <EvanR> youd need a zipper instead
12:53:30 <boxfire> Then the list type must have an upper or lower bound
12:53:32 <ski> boxfire : you can have a pair of two infinite lists ..
12:53:37 <EvanR> boxfire: false
12:53:38 <ski> boxfire : no
12:53:48 <StoneToad> boxfire: what about [1,-1,2,-2...
12:54:07 <tdammers> quetzakubica: maybe look into Parsec to get an idea of how self-documenting Haskell code can be
12:54:13 <boxfire> StoneToad: thanks, I see that now
12:54:30 <srhb> boxfire: Maybe you want Data.List.Ordered from data-ordlist
12:54:42 <quetzakubica> tdammers: what is Parsec?
12:55:06 <boxfire> srhb: my goal is understanding in depth the limits of the list type, but thanks
12:55:07 <StoneToad> quetzakubica: parser combinator library
12:55:08 <tdammers> quetzakubica: parser combinator library. You could say it's an EDSL for constructing parsers
12:55:12 <srhb> boxfire: Okay :)
12:55:25 <EvanR> boxfire: lists are very simple, they are just a linked list of values
12:55:32 <ski> boxfire : this is more like the limits of computation, in general
12:56:06 <tdammers> e.g.: boolean = true <|> false; true = string "true" >> return True; false = string "false" >> return False -- this is what a simple parser for boolean literals might look like
12:56:33 <quetzakubica> http://code.haskell.org/parsec3/Text/Parsec/String.hs - tbh for now it looks like assembler code,  I can't guess a thing from it :P
12:56:50 <EvanR> youre asking how readable haskell code is when you dont know haskell?
12:56:54 <tdammers> quetzakubica: oh, I didn't mean Parsec source; I meant parsers written with it
12:57:08 <EvanR> people are not born knowing how to read code
12:57:10 <tdammers> but then again, what EvanR said
12:57:19 <EvanR> in any language
12:58:23 <tdammers> some languages make it easier to write code that gives a layman the illusion of understanding, but that's not the same as "readability"
12:58:47 * hackagebot dotenv 0.1.0.8 - Loads environment variables from dotenv files  http://hackage.haskell.org/package/dotenv-0.1.0.8 (sestrella)
12:58:49 * hackagebot openssh-github-keys 0.1.1.0 - Fetch OpenSSH keys from a GitHub team  http://hackage.haskell.org/package/openssh-github-keys-0.1.1.0 (sestrella)
12:59:18 <srhb> Presumably the question is really "How well do Haskellers read Haskell code" and that's the end of it.
12:59:23 <srhb> (Pretty well!)
12:59:33 <EvanR> its pretty easy
12:59:36 <quetzakubica> I wonder if it's hard to read for me because of haskell syntax or just functional paradigm, if I am learning haskell because I want to program functionally in javascript.
12:59:42 <EvanR> there arent many syntax gotchas
12:59:45 <srhb> quetzakubica: Both.
13:00:05 <srhb> Though I would say less syntax and more paradigm.
13:00:13 <boxfire> what about the International Obfuscated Haskell Code Contest?
13:00:18 <boxfire> exception to the rule
13:00:24 <nbouscal> most of Haskell syntax very clearly reflects pure functional semantics, so most of the difficulty is in the semantics
13:00:38 <EvanR> srhb: ive experienced many people who report being unable to read specifically the syntax, of course they also dont really get the rest of it either
13:00:47 <srhb> :)
13:00:57 <EvanR> boxfire: uh well if its going to use template haskell 
13:01:05 <srhb> boxfire: This? :-) https://mail.haskell.org/pipermail/haskell/2004-August/014387.html
13:01:06 <sinelaw> oy, still no new release of edit-distance
13:01:11 <sinelaw> 7.10 broken
13:01:31 <KaneTW> there's a person on a famous internet forum that absolutely hates haskell with a passion and his arguments essentially boil down to "i can't read haskell thus i don't like it"
13:02:05 <boxfire> srhb: oh yes
13:02:16 <EvanR> yes "i can't read it" is common, and reflects a combination of laziness, apathy, and conflating literally reading and understanding what the code says
13:02:19 <boxfire> shining examples of clarity
13:02:22 <srhb> boxfire: It's beautiful, the RSA logo.
13:02:44 <hexagoxel> but extensions such as PatternGuards, MultiWayIf, ViewPatterns, FunctionalDependencies all overload existing syntax. a beginner might have some problems reading code that makes heavy use of such.
13:03:06 <KaneTW> not particularly different from other languages
13:03:47 * hackagebot SeqAlign 0.1.0.0 - Sequence Alignment  http://hackage.haskell.org/package/SeqAlign-0.1.0.0 (rcallahan)
13:04:09 <quetzakubica> another question, is "Real world haskell" book good for a start?
13:04:21 <ion> import Prelude renaming (reverse to (#), interact to (=*), …
13:04:23 <ion> Cute
13:04:56 <kadoban> quetzakubica: https://github.com/bitemyapp/learnhaskell is better (cis194 and etc.)
13:05:25 <KaneTW> i began with real world haskell but i never finished it
13:05:36 <KaneTW> it's a good book though, but that github guide is better imo too
13:05:47 <marchelzo_> quetzakubica: RWH is fine. A lot of the code and the libraries used are outdated, but the general ideas are still largely applicable.
13:06:00 <quetzakubica> to be precise, what I want to learn is how to do functional programming, not haskell programming really, it's just a tool for job
13:06:16 <ski> quetzakubica : SICP might also be worth a look
13:06:38 <marchelzo_> quetzakubica: RWH may not be your best bet, then.
13:06:39 <quetzakubica> thanks guys
13:07:38 <bitemyapp> quetzakubica: https://github.com/bitemyapp/learnhaskell
13:08:06 <bitemyapp> quetzakubica: the courses there will get you on the right track.
13:08:54 <jackhill> What do people think of _Write Yourself a Scheme in 48 hours_ ?
13:08:54 <EvanR> quetzakubica: then you probably dont want haskell
13:10:11 <dmj`> jackhill: I enjoyed it
13:10:41 <jackhill> dmj`: cool!
13:10:57 <slack1256> jackhill: it has spawned some real good programmers and projects
13:11:01 <slack1256> @hackage husk
13:11:02 <lambdabot> http://hackage.haskell.org/package/husk
13:11:02 <srhb> quetzakubica: I second the feeling that you probably don't want Haskell. You'd be buying into a lot of very strong type system things that might distract from your goal.
13:11:14 <srhb> quetzakubica: (Of course, this is the reason a lot of us use Haskell in the first place... :-))
13:11:48 <tremon> quetzakubica: additionally, there's a risk you'll start hating javascript once you know haskell
13:12:10 <srhb> ... and start doing Haskell->JS from now on
13:12:12 <EvanR> i still like javascript
13:12:35 <EvanR> as a "C of the browser"
13:12:45 <quetzakubica> I can't do haskell in frontend, so it won't happen :P
13:13:08 <srhb> .oO(GHCJS)
13:13:14 <srhb> But yeah, probably not for you. :)
13:13:56 <dmj`> tremon: javascript hatred comes way before haskell fluency
13:14:11 <sinelaw> mokus_, any luck with compiling lambdabot on ghc 7.10?
13:15:46 <boothead> How does one early terminate in a pipe when you get a Left from the underlying action? If I'm yielding on Right the only thing I can do return () on Left and then you loose the context when you runEffect. What's the right thing to do here? throw?
13:18:02 <hexagoxel> boothead: context? what monad is this in?
13:18:19 <KaneTW> quetzakubica: you can compile haskell to javascript
13:18:38 <quetzakubica> sure, but there are always problems with transpillers
13:18:49 <michaelt> boothead: in a series of pipes p >-> q >-> r  it's generally best that only one of them has a return value, the others are potentially infinite
13:18:53 <quetzakubica> mostly with debugging
13:19:02 <ion> GHCJS is nice as long as you don’t mind a megabyte-sized hello world. :-P (Well, 100 kilobytes if you minify and gzip.)
13:19:19 <zmbmartin> How do you manage different versions of ghc installed?
13:19:21 <mokus_> sinelaw: haven't had a chance to try much, but IIRC I wasn't able to build some of the dependencies
13:19:33 <zmbmartin> Anything like rvm for ghc?
13:19:49 <ion> zmbmartin: Install them into different directories and set PATH.
13:20:47 <michaelt> boothead: if you want to omit Left r you can use P.concat :: (Monad m, Foldable f) => Pipe (f a) a m r , if you want to stop when you get a left, you might reconsider organization. 
13:21:00 <zmbmartin> ion: Is that the preferred method currently?
13:21:27 <boothead> hexagoxel, it's a Pipe.Procuder Stuff (SafeT m) () the underlying IO action (reading a kafka consumer) is Either error Stuff I want to terminate the pipe when I get a left and ideally have a m (Either error Stuff) when I run the pipe
13:21:58 <boothead> michaelt, what do you do when either end of a pipe can fail?
13:22:46 <michaelt> boothead: do you want to recover the rest of the producer that is sending stuff
13:23:25 * tdammers is toying with the idea of an eDSL for generating JS
13:23:47 * hackagebot Shrub 0.1.0.0 - 4-way trie fuzzy search  http://hackage.haskell.org/package/Shrub-0.1.0.0 (rcallahan)
13:24:14 <michaelt> boothead:  of course if the producer and the pipe both have the same return value, you will get whatever comes first. 
13:24:48 <boothead> michaelt, no I think I wouldn't if the reader of a kafka consumer (which is my Producer) fails then I guess I'd let it die
13:25:02 <michaelt> these can always be made to match, fmap Left p >-> fmap Right q with make p and q agree 
13:25:13 <latk> Another opaleye question: How do you tend to create tables for types that e.g. come from a library (meaning they are not polymorphic). Just have some boilerplate ?
13:25:28 <michaelt> boothead: so your basic producer is Producer (Either a b) m r 
13:25:46 <michaelt> boothead: so you want a regular function not a pipe. 
13:26:08 <boothead> michaelt, but how do you get the Producer to return Either?
13:26:09 <michaelt> boothead: i'm trying to think if this reduced to a regular library function
13:26:41 <boothead> my producer is Producer KafkaMessage (SafeT m) ....
13:26:51 <michaelt> boothead: you mean, return Either  rather than producing them?
13:26:54 <lpaste> chpatrick pasted “Generalized uncurry without OverlappingInstances” at http://lpaste.net/131353
13:27:07 <sinelaw> mokus_, yeah, my problem too
13:27:08 <boothead> yeah thats it michaelt 
13:28:11 <michaelt> boothead: is it that you want to stop on some kind of kafkamessage, or on something from the SafeT monad?
13:28:48 * hackagebot FastxPipe 0.2.0.0 - Fasta and Fastq streaming  http://hackage.haskell.org/package/FastxPipe-0.2.0.0 (rcallahan)
13:29:43 <michaelt> boothead: oh wait I missed a crucial sentence to hexagoxel  "Pipe.Procuder Stuff (SafeT m) () " is what you start with but  m (Either error Stuff) is what you want to end with.
13:29:47 <boothead> I have a call to consumeMessage ... which is IO (Either KafkaError KafkaMessage) if I get an error I'd want to terminate the pipeline and let downstream know that's happened
13:30:15 <ski> (latk : presumably you mean s/polymorphic/parametric/ ..)
13:30:23 <boothead> michaelt, yep that's it (unless I'm missing something in the way you should treat Pipes)
13:31:08 <latk> ski: I might, but I don't think I do. https://github.com/tomjaguarpaw/haskell-opaleye/blob/master/Doc/Tutorial/TutorialBasic.lhs suggests that datatypes be polymorphic in all of their fields.
13:32:07 <sinelaw> mokus_, just sent you a pull request for dependent-sum-template
13:32:16 <michaelt> boothead: I think though that it isnt downstream that you want to be inspecting for the left value, if you have Producer (Either KafkaError KafkaMessage) m r you can turn it into Producer KafkaMessage m (Producer (Either KafkaError KafkaMessage) m r)
13:32:31 <mokus_> sinelaw: cool, thanks... i have a few to catch up on since 7.10, guess i better get on that
13:32:51 <boothead> michaelt, using next?
13:32:52 <michaelt> boothead: which to say, make that producer break on the first left value, but only produce values that are actual messages. then downstream doesnt worry
13:33:19 <mokus_> unfortunately 7.10 arrived in the middle a bit of a crunch for me at work
13:33:42 <michaelt> boothead: yeah, i'm trying to think if it reduces to dumb combinators, but yes, you could just write the obvious recursive thing. 
13:33:48 * hackagebot cql-io 0.14.1 - Cassandra CQL client.  http://hackage.haskell.org/package/cql-io-0.14.1 (ToralfWittner)
13:35:40 <ski> latk : that is incorrect terminology
13:35:58 <boothead> michaelt, how are other people doing this? Presumably a Producer that encounters a problem with it's underlying monad must be a fairly common usecase...?
13:36:16 <latk> Ah. On the part of the tutorial writer, or did I misunderstand something ?
13:36:32 <latk> Could you explain the distinction ?
13:36:38 <latk> ski: ^
13:36:44 <ski> on the part of the tutorial writer, yes
13:36:56 <michaelt> boothead: If you turn the left values into something about the underlying monad, which is here SafeT m for something, then yes. 
13:37:05 <ski> unfortunately, it's a pretty common confusion. i'm trying to dispel it, when i can
13:37:32 <ski> latk : do you know about kinds ?
13:37:35 <michaelt> boothead: the main point Im making is you dont want generally to be using a pipe in the middle of things to be testing for the error and ending. 
13:37:58 <latk> ski: I believe so, but I've never really thought about them in detail, so perhaps not.
13:38:39 <latk> ski: They are indications of the sort of things that should be passed to a function ?
13:38:48 * hackagebot tellbot 0.5.1 - IRC tellbot  http://hackage.haskell.org/package/tellbot-0.5.1 (DimitriSabadie)
13:39:01 <latk> so * -> * requires a constructor.. or something
13:39:13 <boothead> michaelt, no I don't :-) I really want Producer MyThing (SafeT m) (Either Error ())
13:39:14 <latk> I did read about them ages ago, but never had any practical dealings
13:39:27 <michaelt> boothead: for example if you had a Producer KafkaMessage (EitherT KafkaError (SafeT m)) r things would be different .
13:39:56 <ski> latk : kinds are the "types of types". "concrete" types like `Bool', `Maybe String',`[Integer -> Double]' (which means `[] ((->) Integer Double)') all have kind `*'
13:40:15 <michaelt> boothead: from Producer (Either Error MyThing) (SafeT m) r
13:40:27 <boothead> hmmm, SafeT is both MonadThrow and MonadCatch
13:40:47 <boothead> but I don't want downstream to have to deal with left and right
13:40:52 <ski> latk : `Maybe' and `[]' are type functions, you have to provide an additional type, before getting a concrete type
13:41:51 <ski> latk : in this case, they both have kind `* -> *', so they're type functions mapping concrete types to concrete types. `Either' (and `(->)') has kind `* -> * -> *' (meaning `* -> (* -> *)'), so it's a curried type function, taking two concrete kinds, and yielding a concrete kind
13:42:14 <kaw_> SDL-0.6.5 is failing to cabal-install for me, might that be a problem on my end or does it not work with GHC 7.8.4? http://lpaste.net/5470906058627088384
13:42:21 <ski> latk : one can also have types of kind `(* -> *) -> *', `(* -> *) -> * -> *', and so on ..
13:42:25 <ski> latk : is all this clear ?
13:42:28 <latk> ski: Right, I think so.
13:42:41 <latk> ski: Types of types makes sense as an explanation.
13:43:02 <michaelt> endEarly = loop where loop p = do {m <- next p; case m of Left r -> return (Right r); Right (Left err, p) -> return (Left err); Right (Right a, p') -> yield a >> loop p'}
13:43:04 <boothead> michaelt, I just had a look in Pipes.Network.TCP.Safe and even here all of the Producers are returning ()
13:43:19 <ski> latk : now, by "parametric type" i basically mean the same as "type function". so `Maybe' is a parametric type. in the definition `data Maybe a = Nothing | Just a', `a' (occuring to the left of `=') is the type parameter
13:43:28 <latk> ski: Actually, wait. Mapping concrete types to concrete types. Is this not somehow constructing the type? Or is there no difference?
13:43:42 <michaelt> boothead: yes the producers tend to be the finite limited ones 
13:43:54 <ski> latk : doesn't matter much
13:43:58 <latk> ski: Okay.
13:44:11 <latk> ski: So, I see what you are saying. But is this not also in some sense polymorphic? 
13:44:18 <latk> ski: What would be an example of a polymorphic type ? 
13:44:25 <michaelt> boothead: my dumb endEarly above is obvious enough
13:44:45 <ski> latk : now, consider a value like `Nothing'. it is *polymorphic*, meaning that it can be used at potentially many types. like `Maybe Integer',`Maybe String',`Maybe (Maybe (Int -> Bool))',&c.
13:44:55 <boothead> so how do you get information like "the socket you were listening to died because reason" out of a Producer .. ()? 
13:45:18 <latk> ski: Ah.
13:45:26 <ski> latk : in short, for every actual type we can replace the type variable `a' with, `Nothing' *can* have type `Maybe a'
13:45:41 <michaelt> boothead: I'd have to look at the types. Just a sec . I'm not to competent with network libraries by the way ...
13:45:44 <boothead> I missed your endEarly sorry michaelt 
13:45:50 <latk> ski: So a constructor can't be polymorphic ? 
13:46:11 <ski> latk : we abbreviate the contents of the previous sentence by saying that (the most general) type of `Nothing' is `forall a. Maybe a'
13:46:12 <michaelt> Producer (Either a b) m r -> Producer b m (Either a r) 
13:46:19 <ski> latk : a type constructor, or a data constructor ?
13:46:30 <latk> ski: data
13:46:41 <ski> (`Nothing' (and `Just') is a data constructor. `Maybe' is a type constructor)
13:46:56 <ski> latk : by the above, `Nothing' is a polymorphic data constructor
13:47:03 <latk> Right, I had them the wrong way around :P
13:47:25 <boothead> michaelt, I'm just confused about the general case: you have a producer with an underlying resource you're getting stuff from and yielding. The underlying goes wrong, how do you know what happened?
13:47:52 <boothead> I assume it must throw into the SafeT...
13:48:02 <ski> latk : so. polymorphic values (like `Nothing', `[]', `[[],[],[]]', `length', `return', ...) have types which *start* with a `forall'
13:48:10 <latk> ski: I've seen this forall a. type stuff mentioned a few times, but haven't really grasped the significance. If you can just say Maybe a, what is the point ? 
13:48:47 <ski> latk : now, if the `forall' occurs just before the `::' in a type signature, then you can usually elide it. but conceptually it's still there
13:48:49 * hackagebot cql-io 0.14.2 - Cassandra CQL client.  http://hackage.haskell.org/package/cql-io-0.14.2 (ToralfWittner)
13:48:58 <sinelaw> latk, 'a' could mean "the same type variable 'a' that is also the type of some other expression"
13:48:58 <latk> (if this is a deep topic please feel free to just point me to some reading)
13:49:19 <michaelt> boothead: all the usual ways; in this case you are using SafeT so the combinators for 'MonadSafe' are around. 
13:49:21 <ski> latk : the `forall' binds the type variable(s). just like `let' and lambda abstraction bind value variables
13:49:35 <latk> ski, sinelaw: Ah, I see.
13:49:37 <sinelaw> latk, for example, consider the sentence, "there is some type 'a' , and the type of this expression here is Maybe a"
13:49:39 <sinelaw> vs.
13:49:40 <ski> latk : if i ask you what the value of `x + 1' is, then you can't answer without knowing the value of `x'
13:49:56 <latk> So you can do some kind of type level restrictions that you would otherwise be unable to do
13:49:58 <latk> ?
13:50:00 <ski> latk : if i ask you the value of `let x = 3 in x + 1', or the value of `\x -> x + 1', then you can answer
13:50:00 <sinelaw> "for all types, call them 'a', the type of this expression is Maybe a"
13:50:20 <ski> (in the first case, the value is `4'. in the second case, the value is the incrementation/successor function)
13:50:44 <latk> ski: Yes, okay
13:51:02 <ski> latk : strictly speaking, if someone says "its type is `Maybe a'", you ought to ask "with `a' being what type ?"
13:51:22 <ski> (just as you'd ask about the value of `x' in the first example above)
13:51:35 <latk> ski: Well, is there not some assumption about how haskell works here ?
13:51:37 <boothead> ok, thanks for the help michaelt :-)
13:51:45 <latk> ski: Or rather an assumption it makes, that is hidden ?
13:51:51 <ski> latk : i'm not sure what you're asking about now
13:52:19 <latk> ski: So the fact that there is no typeclass in the definition means it is valid for all types, no? 
13:52:34 <latk> ski: Which is like an implicit forall a. ?
13:52:35 <ski> which definition ?
13:52:39 <latk> of Maybe a
13:53:03 <ski> are you talking about the type signature `Nothing :: forall a. Maybe a' ?
13:53:09 <timothyh> anyone here know much about the GHC build system?
13:53:20 <latk> ski: Yes
13:53:25 <michaelt> boothead: the thing is you represent the producer as itself issuing Either values, so it's already made the errors explicit. In that case the easy solution is to break the sequence when you get the first Left. Then you can recover the resot of prodcuer and continue
13:53:28 <timothyh> if I wanted to make hsc2hs build statically, where would I start googling?
13:53:36 <ski> (or are you talking about the data type definition `data Maybe a = Nothing | Just a')
13:53:38 <latk> ski: Actually wait, no I wasn't, but I see what you mean now
13:54:03 <latk> ski: Yes indeed the data type definition. 
13:54:15 <latk> ski: I seem to be a bit confused about some of this terminology.
13:54:36 <ski> anyway, type class constraints is another complication over the basic idea. i'd rather skip it initially
13:54:49 <latk> ski: Fair enough :)
13:55:02 <ski> anyway, it's important to understand that `Maybe a' is not at all the same as `forall a. Maybe a'
13:55:31 <ski> if they were the same, then `Maybe a -> Bool' would have to be the same as `(forall a. Maybe a) -> Bool', which is plainly false
13:56:06 <latk> ski: ohhh
13:56:32 <latk> ski: Okay I think I get it now. 
13:56:41 <latk> ski: Or at least, I get it more than I previously did
13:57:10 <michaelt> boothead: if the monad in Producer a m r is catching errors you can approach the matter with  distribute:: Pipes.Proxy a' a b' b (t m) r -> t (Pipes.Proxy a' a b' b m) r
13:57:20 <srhb> ski: can you elucidate on the plainly part?
13:57:30 <ski> if we have `example :: forall a. ..a..', where `..a..' is any type expression which is allowed to mention `a', then this means that `example' *can* be used as having type `..A..', where `A' is any actual type (expression), that have been (systematically) substituted for `a' in `..a..'
13:57:57 <ski> iow, from
13:58:02 <ski>   example :: forall a. ..a..
13:58:04 <ski> we can deduce
13:58:09 <ski>   example :: ..A..
13:58:19 <ski> an actual example, from
13:58:35 <ski>   take :: forall a. Int -> [a] -> [a]
13:58:39 <ski> we can deduce
13:58:49 * hackagebot cql 3.0.3 - Cassandra CQL binary protocol.  http://hackage.haskell.org/package/cql-3.0.3 (ToralfWittner)
13:58:54 <michaelt> boothead: e.g. distribute :: Producer a (EitherT a m) r -> EitherT a (Producer a m) r
13:58:55 <ski>   take :: Int -> [Either String Int] -> [Either String Int]
13:59:18 <ski> (iow, that is one of the actual types we can use the polymorphic value `take' at)
13:59:35 <ski> srhb : for you or latk ?
13:59:49 <srhb> ski: Me. How is that take different from take :: Int -> [a] -> [a] ?
14:00:39 <ski> your type signature is, strictly speaking, incomplete, without specifying where the type `a' is supposed to come from
14:00:55 <srhb> But... There's an implicit forall a. ?
14:01:13 <michaelt> boothead: it occurs to me, this would reduce to combinators with one that does  Producer (Either a b) m r -> Producer b (EItherT a m) r  
14:01:20 <ski> (it's a fact that Haskell usually allows you to elide the `forall a.'. but it's still there, conceptually speaking)
14:01:36 <srhb> Ooooh, okay. Good. Then I follow again. I thought everything I knew was a lie for a second there.
14:02:03 <latk> ski: Is there a name for this kind of thing in haskell? (so I can do some further reading )
14:02:39 <ski> latk : anyway, even `forall a. Maybe a -> Bool' (which means `forall a. (Maybe a -> Bool)') and `(forall a. Maybe a) -> Bool' are very different
14:03:17 <latk> ski: Right. I think I see that now.
14:03:25 <ski> the first is the type of a polymorphic function, that can accept a `Maybe a' for any type `a', and will return a `Bool'
14:04:07 <ski> the second is a *monomorphic* (not polymorphic) function, that will only accept a *polymorphic* argument (one that has type `Maybe a' for *every* type `a'), before returning a `Bool'
14:04:39 <ski> you can pass `Just "abc"' to the first. you can't pass that to the second. (ignoring non-total values) you can only pass `Nothing' to the second
14:05:13 <latk> ski: Right. Is this often useful? 
14:05:15 <ski> sometimes, the ability to pass polymorphic arguments to a function can be very useful
14:05:21 <latk> ski: hah :)
14:05:53 <ski> however, the opportunity doesn't arise *that* often. but it can be good to know about, so that you can recognize it, when it's what you want
14:06:28 <latk> ski: Sure. It seems interesting, if nothing else.
14:07:07 <ski> latk : one of the problems i have with the sentence "It will save you a lot of headaches if you define your data types to be polymorphic in all their fields." in that tutorial is that this means something completely different to me (which can sometimes be useful)
14:07:18 <ski> latk : if you have something like
14:07:53 <ski>   data Foo = MkFoo ([a] -> Either Int [a])
14:08:06 <ski> then this is incomplete. it doesn't say where `a' comes from
14:08:21 <ski> one way to fix this is to parameterize `Foo' on `a' :
14:08:26 <ski>   data Foo a = MkFoo ([a] -> Either Int [a])
14:08:28 <latk> ski: Okay. So you would instead say parameterized ?
14:08:30 <ski> this gives you
14:08:43 <ski>   MkFoo :: forall a. ([a] -> Either Int [a]) -> Foo a
14:08:50 <ski> a polymorphic data constructor
14:09:00 <ski> sometimes, this is what you really wanted to do
14:09:30 <ski> at other times, possibly you instead wanted to make the data constructor argument/field itself polymorphic :
14:09:37 <ski>   data Foo a = MkFoo (forall a. [a] -> Either Int [a])
14:09:40 <ski> this gives you
14:09:48 <ski>   MkFoo :: (forall a. [a] -> Either Int [a]) -> Foo a
14:09:48 <HaskellStudent81> can anyone please help me? I don't understand I'm doing wrong here http://lpaste.net/131355
14:09:55 <ski> which, as we've seen above, is very different
14:10:12 <latk> ski: Right - to check I'm following, this requires that the value passed in is [] ?
14:10:16 <ski> er, it should be
14:10:21 <ski>   data Foo = MkFoo (forall a. [a] -> Either Int [a])
14:10:21 <ski> and
14:10:24 <ski>   MkFoo :: (forall a. [a] -> Either Int [a]) -> Foo
14:10:25 <c_wraith> Haskellfant: (:) and (++) are not interchangeable.
14:10:26 <ski> in this case, `MkFoo' will store a polymorphic value (in this case a function) inside it
14:10:41 <c_wraith> HaskellStudent81: err.  I mean. (:) and (++) are not interchangeable
14:10:42 <glguy> HaskellStudent81: (x:y) is the problem, it makes a new list where the first element is x and the REST of the list is y
14:10:50 <c_wraith> Haskellfant: sorry for the accidental ping
14:10:54 <frerich> HaskellStudent81: The issue with 'myZip (x:xs) (y:ys) = x:y ++ myZip xs ys' is that 'x:y' only yields a list if 'y' is a list itself, but that's impossible according to the type signature.
14:10:59 <Haskellfant> c_wraith: np
14:11:16 <ski> latk : in this case `a' does *not* appear on the left of `=' in the data type definition. it doesn't need to, because it's bound by the `forall a.'
14:11:40 <latk> ski: Hm, okay. 
14:12:17 <latk> ski: If you did include it on the left side, would the compiler find an error ? 
14:12:31 <latk> ski: ah, no I suppose not
14:12:36 <ski> latk : in the former case, if you have a `Foo String', then you know that the component function will have type `[String] -> Either Int [String]' -- by controlling what you "pass" to `Foo', you can control what the `a' in the type of the argument(s) of the data constructor(s) will actually be
14:13:46 <glguy> x:y++z   parses as    x:(y++z) , and ++ works on lists. y isn't a list
14:13:47 <ski> latk : in the latter case, if you mistakenly (as i did above) included it on the left hand side, then it would mean the same as if you had typed `data Foo a = MkFoo (forall b. [b] -> Either Int [b])' -- exactly analogous to how `\x -> \x -> x + 1' is interpreted the same as `\x -> \y -> y + 1'
14:14:42 <latk> ski: I think I will have to make some toy examples myself to make this stick.
14:14:42 <ski> latk : in the latter case, `Foo String' is a kind error. there is only `Foo' and a single value of that type always contains a polymorphic value, that can behave as a `[A] -> Either Int [A]', for any actual type `A' you like
14:15:13 <ski> latk : in the former case, `Foo String' is not at all polymorphic, nor does it contain a polymorphic value
14:15:34 <latk> ski: Okay, that makes some sense.
14:15:36 <ski> latk : there is a third possibility here ..
14:16:46 <ski> latk : in the first case above. `Foo String' in a sense "wears on its face" the type of its contents. since the argument is `String', we know that the contents has type `[String] -> Either Int [String]'
14:17:11 <latk> ski: Right. This is the common case that I am used to.
14:17:34 <ski> latk : in the second case, `Foo' hides a (polymorphic value), that can (is required to) behave as a `[A] -> Either Int [A], for any possible `A', including `String'
14:17:46 <HaskellStudent81> Ok, but I keep getting a "cannot construct the infinite type [a] == a" error for line 2? http://lpaste.net/131355
14:17:59 <latk> ski: I suppose I'm finding it hard to imagine when doing something like the second case would be useful.
14:18:44 <geekosaur> you seem to be trying to ++ an item (well, two items) with a list
14:18:48 <ski> latk : the third case is picking a specific type for `A' (like `String'), but then *not* "wear it on your face", iow the type will still be just `Foo', so you get no clue as to what the actual type `A' is by looking at the type of the whole thing
14:19:14 <geekosaur> which causes Haskell to think that it must be a list of lists, but then it finds that it's [a] -> [a] -> [a] so `a` has to be both a list and not-a-list at the same time
14:19:28 <ski> latk : in this case, the type signature for `MkFoo' will be
14:19:37 <ski>   MkFoo :: forall a. ([a] -> Either Int [a]) -> Foo
14:19:52 <geekosaur> you may want (:) instead of (++) for that
14:19:53 <ski> (iow, the same as in the first case, except it's just `Foo', not `Foo a')
14:20:19 <latk> ski: Hm. Okay wait a sec.
14:20:40 <HaskellStudent81> @geekosaur thats what I had first but was told I should change it
14:20:40 <lambdabot> Unknown command, try @list
14:20:46 <ski> this says that, `MkFoo' is a polymorphic value that, for any type `a', can accept a value of type `[a] -> Either Int [a]', and will return a value of type `Foo' (leaving no trace in the final type about what type was used for `a')
14:21:01 <HaskellStudent81> @list
14:21:02 <lambdabot> What module?  Try @listmodules for some ideas.
14:21:02 <sebastianrkg> Do I need to do an extra step somewhere to allow "cabal build"'d executable to access the filesystem?
14:21:14 <sebastianrkg> My application accesses folder contents a-okay in cabal repl
14:21:27 <ski> HaskellStudent81 : it is not IRC custom to prefix nicknames with `@'
14:21:54 <latk> ski: Okay, I follow that. 
14:21:57 <sebastianrkg> But once I build the executable, it returns empty arrays for the contents of folders
14:21:58 <geekosaur> I think someone just glanced and thought they knew the problem. given your original form (and you still have this problem), it's not the (:)s that were wrong but the `= x` and `= y`
14:22:02 <HaskellStudent81> sorry :P
14:22:12 <geekosaur> which want to be `= [x]` and `= [y]`, from the looks of it
14:22:13 <sebastianrkg> using "getDirectoryContents" from System.Directory
14:22:34 <geekosaur> because you were saying the type should be "list of a" but the result you were giving back was just `a`
14:22:36 <ski> latk : logically speaking, `forall a. (..a.. -> ...)' (where the latter `...' doesn't mention `a') is equivalent to `(exists a. ..a..) -> ...'
14:22:49 <geekosaur> that's if I'm reading this correctly...
14:22:50 <Gurkenglas> Should it be a Foldable law that fold be well-defined?
14:22:56 <ski> latk : this means that, conceptually, another way to think about the last type signature above is
14:23:06 <ski>   MkFoo :: (exists a. [a] -> Either Int [a]) -> Foo
14:23:07 <Gurkenglas> (as in, preserve equality)
14:23:13 <geekosaur> but it looks suspicious that a function [a] -> [a] -> [a] is doing (x:xs) = x
14:23:39 <latk> ski: I've not come across exists before. What is an example of something that doesn't satisfy exists?
14:23:52 <ski> latk : iow, `MkFoo' will return a `Foo', provided that there *exists* *some* type `a' such that the argument has type `[a] -> Either Int [a]'
14:24:31 <HaskellStudent81> geekosaur I think that did it!
14:24:57 <HaskellStudent81> thank you I've been trying to figure that out for an hour!
14:25:14 <ski> latk : `exists' isn't part of current Haskell (or common extensions (i think one compiler accepts some uses of it)). i use it to talk conceptually about types here (and it's useful to understand the (existing) extension that is sometimes called "existentially quantified data types")
14:25:25 <worldsayshi> Any user of the haste-compiler that understand how it determines the version of base? I get compilation errors when trying to install a package that require a newer version of haste.. 
14:25:52 <worldsayshi> *require a newer version of base..
14:25:56 <latk> ski: Ah, okay. 
14:26:07 <ski> latk : here's another example. we know `length :: forall a. ([a] -> Int)'. according to the above, we could also think of this as `length :: (exists a. [a]) -> Int'
14:26:52 <latk> ski: I'm not sure I quite get the significance of the different bracketing.
14:27:24 <latk> ski: What would length :: exists a. ([a] -> Int) mean?
14:27:38 <ski> latk : now, we also know `[(0,"zero"),(1,"one")]' has type `[(Integer,String)]'. therefore, there exists a type `a' (namely `(Integer,String)') such that this value has type `[a]'. we summarize that as `[(0,"zero"),(1,"one")] :: exists a. [a]'
14:27:43 <latk> ski: Ah, because it is some type rather than all types
14:28:21 <ski> latk : therefore, the type of `[(0,"zero"),(1,"one")]' matches the argument type of `length' (in `length :: (exists a. [a]) -> Int'), so `length [(0,"zero"),(1,"one")]' is valid, and has type `Int'
14:28:53 <ski> latk : `length :: exists a. ([a] -> Int)' would mean that there is some (unknown) type `a' such that `length' has type `[a] -> Int'
14:30:05 <latk> ski: Interesting. Are these kind of ideas common in type theory ?
14:30:15 <latk> I've never really looked in detail at these things
14:30:25 <ski> latk : in some cases, it could be useful to use `exists' in the return type of a function. consider something like `parseAnything :: String -> Maybe (exists a. (a,String))' (this is only meant to give you an idea. this actual example is useless)
14:31:08 <ski> (the second `String' is meant to account for the remainder of the input `String' after parsing the value)
14:31:56 <ski> latk : anyway, i haven't yet said how to actually write the data type definition for the third possibility yet
14:32:09 <latk> ski: true
14:32:32 <ski> (latk : and yes, `forall' and `exists' types is a common idea in type theory)
14:33:20 <ski> this third possibility is what is often (a bit inaccurately) called "existential data type" or (more inaccurately) "existentials"
14:33:46 <ski> "existentials" proper is the (conceptual) types of the form `exists a. ..a..'
14:33:59 <latk> ski: Okay.
14:34:17 <ski> (just like types of the form `forall a. ..a..' (the types of polymorphic things) can be called universal types (they are *not* "polymorphic types"))
14:34:24 <michaelt> boothead: if you are still around here are some manipulations using hoist lift and ExceptT to transform the monad the producer acts in http://sprunge.us/iLXa
14:34:52 <ski> but this third possibility is related to existentials because of the (conceptual) `exists' in
14:34:55 <ski>   MkFoo :: (exists a. [a] -> Either Int [a]) -> Foo
14:35:03 <ski> (which is what we want in this third possibility)
14:35:18 <ski> as stated, this is (logically speaking) equivalent to
14:35:26 <ski>   MkFoo :: forall a. [a] -> Either Int [a] -> Foo
14:35:36 <ski> (meaning `MkFoo :: forall a. ([a] -> Either Int [a] -> Foo)')
14:35:48 <latk> ski: Right.
14:36:22 <ski> the traditional way to write the data type definition for this (using the `ExistentialQuantification' extension, which is somewhat of a misnomer) is
14:36:46 <ski>   data Foo = forall a. MkFoo ([a] -> Either Int [a] -> Foo)
14:37:05 <ski> note that the `forall' here comes *before* the data constructor
14:37:14 <ski> it is the data constructor that is polymorphic
14:37:31 <alynn> that doesn't look like a very useful data type?
14:37:44 <ski> alynn : it's not useful in this particular case, no
14:38:19 <ski> this is not to be confused with the second possibility from above, the case where the *argument* type was polymorphic, namely `data Foo a = MkFoo (forall a. [a] -> Either Int [a])'. here the `forall' occured in the argument type
14:39:12 <ski> some people get confused that one uses the `forall' keyword to declare an "existentially quantified data type" (it's really more the data constructor, than the data type itself, which is "existential" here, though that's still not quite right)
14:40:07 <ski> but that is because of the logical equivalence between `(exists a. ..a..) -> ...' and `forall a. (..a.. -> ...)' and (presumably) because they didn't feel like introducing another keyword (`exists') when they already had `forall'
14:41:14 <ski> note that since your data type can have several constructors, some of them could be "existential" in the above sense, and some of them just "ordinary constructors" (and some could have polymorphic arguments, if you felt like that)
14:41:14 <latk> ski: I think this terminology may take a while to become comfortable with.
14:41:32 <ski> anyway, some examples might be nice here
14:42:00 <ski> things that have to do with existentials often have an "object-oriented" feel
14:42:17 <ski> consider
14:43:05 <ski>   data QueueOps a = forall q. MkQO {empty :: q,enqueue :: a -> q -> q,dequeue :: q -> Maybe (q,a)}
14:43:16 <ski> the type signature for the data constructor here will be
14:43:39 <ski>   MkQO :: forall a q. q -> (a -> q -> q) -> (q -> Maybe (q,a)) -> QueueOps a
14:44:09 <ski> `a' is the type of the elements in the queues. `q' is the "internal state type" of the queue (it is hidden from view)
14:45:38 <ski> when you construct a `QueueOps a' (for some particular `a', e.g. `Bool'), you may choose any type `q' at all, that you can implement the three operations for (e.g. you might in this case want to pack the `Bool's as bits in "bitfields", for efficient storage)
14:46:49 <ski> when you deconstruct a `QueueOps a' (for some particular `a', such as `Bool'), you have *no* idea at all what the type `q' was. you only know that the five `q's in the components `empty :: q',`enqueue :: a -> q -> q',`dequeue :: q -> Maybe (q,a)' are all the *same* (unknown) type
14:47:32 <ski> if you have two `QueueOps a's, then for all you know there could be two different `q's "inside" them, so you can't mix and match the operations from those two with each other
14:47:45 <ski> latk : makes any sense ?
14:48:17 <latk> It starts to. I can see that this would be useful, but I have trouble imagining what the internals of these things might look like.
14:49:34 <latk> I think looking at some libraries that use these ideas would be useful.
14:49:53 <ski> the obvious implementation here is to just store values of type `q',`a -> q -> q',`q -> Maybe (q,a)', and then forget what the type `q' actually is. the type system will ensure that we never actually pass a value of incompatible type to some operation
14:50:05 <ski> latk : do you know C ?
14:50:28 <latk> ski: Eh, kinda. Not really.
14:50:51 <ski> Java ?
14:51:01 <latk> ski: Python/R/matlab/haskell/javascript
14:51:39 <ski> ok (not really any statically typed language, other than Haskell, then)
14:51:50 <latk> ski: nope :)
14:52:05 <latk> ski: Scientific computing sadly has not embraced statically typed languages
14:52:09 <ski> here's a (somewhat silly) example
14:52:17 <latk> at least, not where I work.
14:52:30 <ski>   data Showable = forall a. Show a => Wrap a
14:52:33 <ski> this yields
14:52:43 <ski>   Wrap :: forall a. Show a => a -> Showable
14:53:01 <ski> now you can write
14:53:33 <ski>   format :: [Showable] -> String
14:54:18 <ski>   format [Wrap x     ] = show x
14:54:33 <ski>   format (Wrap x:rest) = show x ++ "," ++ format rest
14:54:59 <ski> and you can now evaluate `format [Wrap 2,Wrap False,Wrap "goodbye"]'
14:55:23 <ski> latk : sometimes when people ask for "heterogenous lists", they want something like the above
14:55:30 <latk> ski: Huh, okay.
14:56:02 <latk> ski: Okay I think I follow that
14:56:05 <ski> note how `2',`False',`"goodbye"' here have different types, but can still be put alongside each other as (part of) the list elements
14:56:22 <ski> (`Wrap' makes them have the common type `Showable')
14:56:35 <latk> ski: That is acutally really cool
14:57:32 <ski> if you get a `Showable' value, and match it on the pattern `Wrap x', then you *only* knows that `x' has type `a', for *some* (unknown) type `a', about nothing else is known but that it is an instance of `Show' (and so you can pass `x' to `show' and similar functions)
14:57:44 <ski> note that if you did
14:57:55 <ski>   data Anything = forall a. WrapIt a'
14:57:56 <ski> er
14:57:57 <ski>   data Anything = forall a. WrapIt a
14:58:04 <ski> then this is actually completely useless
14:58:44 <ski> because you know nothing about the type `a' when you unpack a value of type `Anything', and so you can do nothing
14:58:58 <latk> Right. 
14:59:02 <ski> there is no "is this an `Int' ?" or "is this a `String' ?" &c.
14:59:13 <latk> so the format function could only use show. I see that.
14:59:53 <ski> now, you asked about polymorphic arguments of data constructors ..
15:00:17 <ski> consider a function like
15:00:19 <ski> @type lookup
15:00:20 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
15:00:25 <ski> @src lookup
15:00:26 <lambdabot> lookup _key []                      = Nothing
15:00:26 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
15:00:26 <lambdabot>                         | otherwise = lookup key xys
15:00:45 <ski> note the `Eq a =>' constraint in the type signature
15:00:53 <latk> ski: Yes.
15:01:07 <ski> this ensures that `lookup' can assume that `(==)' will work on values of type `a' here
15:02:00 <ski> one possible way of implementing this is to pass a dictionary of the methods of the particular instance of the type class `Eq' used
15:02:14 <ski> iow, we can imagine the above as being translated into
15:02:25 <ski>   lookup :: EqDict a -> a -> [(a, b)] -> Maybe b
15:02:40 <ski>   loopup _eqDict _key []                      = Nothing
15:03:17 <ski>   lookup  eqDict  key ((x,y):xys) | (==) eqDict x = Just y
15:03:41 <ski>                                   | otherwise     = lookup eqDict key xys
15:04:03 <ski> where `EqDict' is defined as
15:04:25 <ski>   data EqDict a = MkEqDict {(==),(/=) :: a -> a -> Bool}
15:04:48 <latk> Okay
15:04:55 <ski> (this results in `(==),(/=) :: EqDict a -> a -> a -> Bool', as always happens with the record notation)
15:04:58 <ski> compare with
15:05:02 <ski> @src Eq
15:05:02 <lambdabot> class Eq a where
15:05:02 <lambdabot>     (==), (/=) :: a -> a -> Bool
15:05:48 <latk> Hmm, okay
15:05:54 <ski> so you can think of the type class resoution mechanism as inserting all these implicit arguments like `eqDict' above, to be passed to any function that needs it
15:06:05 <ski> and an instance declaration, like
15:06:10 <ski>   instance Eq Bool
15:06:11 <ski>     where
15:06:18 <ski>     True == True = True
15:06:24 <ski>     False == False = True
15:06:30 <ski>     _ == _ = False
15:06:38 <ski> will be translated into
15:06:51 <ski>   dictEqBool :: EqDict Bool
15:07:10 <ski>   dictEqBool = MkEqDict {(==) = eq}
15:07:12 <ski>     where
15:07:21 <ski>     eq True  True  = True
15:07:23 <ski>   eq ...
15:07:36 <ski> (eliding the `(/=)' part, since it's similar)
15:07:50 <ski> now, the point
15:07:50 <latk> Yep, I can see that :)
15:07:52 <ski> consider
15:07:57 <ski> @src Functor
15:07:57 <lambdabot> class  Functor f  where
15:07:57 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
15:08:03 <voidzero> hm.. is it too 90s to ask whether you can use a pastebin?
15:08:18 <ski> note that, this should strictly say
15:08:29 <ski>     fmap :: forall a b. (a -> b) -> f a -> f b
15:08:50 <ski> (the `f' is *not* bound in the type signature. it is bound by `Functor f' in the head of the class declaration)
15:08:53 <voidzero> oh it's an interactive tutorial. never mind me.
15:09:19 <ski> `fmap' is a *polymorhic* method (unlike `(==)' above)
15:09:28 <ski> if we apply the same translation as above, we get
15:09:52 <ski>   data FunctorDict f = MkFunctorDict {fmap :: forall a b. (a -> b) -> f a -> f b}
15:09:52 <Pamelloes> Within a do statement, is there a way to define a variable x <- .... and then specify x's type in a separate statement? for instance do { x :: Int; x <- return 0 }? The listed example won't work but is there another syntax that has the same effect?
15:10:28 <ski> iow, a data type with a polymorhic component/argument (extension enabled by `PolymorphicComponents')
15:11:10 <ski> latk : that should hopefully give you some vague idea of what polymorphic components can be useful for
15:11:47 <lpaste> edwardk pasted “open ended Fibonacci search” at http://lpaste.net/131363
15:11:48 <ski> > do x :: Int <- [2]; return (x + 1)  -- Pamelloes ?
15:11:49 <lambdabot>  [3]
15:12:03 <latk> ski: I think it does. Thanks - you've been very helpful :)
15:12:05 <ski> (you need some extension for this)
15:12:05 <slack1256> Pamelloes: do {x <- return 0; return (x `asTypeOf` (8 :: Int))}
15:12:17 <ion> edwardk: Is there a discussion somewhere?
15:12:39 <ski> latk : now, functions (in general, as opposed to data constructors that happen to be functions) with polymorphic arguments can also be useful
15:13:14 <edwardk> ion: not yet. just banged that out
15:13:16 <ski> latk : sometimes you don't want to decide at which type to use the argument until after you've seen the *values* of other arguments (say)
15:13:17 <Pamelloes> ski: I'm aware of that syntax, but my type is relatively complicated so I'd like to split it off onto a separate line to prevent the statement from becoming too unwieldly
15:13:37 <ski> latk : sometimes you want to use the same argument function at different types, in the same function call
15:13:47 <edwardk> ion: thought it was a fun way to use the Z(phi) stuff i had in fractions, but then i simplified it away
15:13:52 * hackagebot dependent-sum-template 0.0.0.3 - Template Haskell code to generate instances of classes in dependent-sum package  http://hackage.haskell.org/package/dependent-sum-template-0.0.0.3 (JamesCook)
15:13:58 <ski> latk : sometimes you don't want to *expose* at which type you use an argument (so that's information hiding)
15:14:18 <edwardk> ion: basically it uses the log time "fast fibonacci transform" to find a pair of adjacent fibonacci numbers where the larger ha the predicate hold
15:14:30 <ski> latk : those are all possible uses of functions with polymorphic arguments (also called functions with "rank 2" types)
15:14:37 <edwardk> then it tests a tree of points below using the fibonacci sequence to bias to the left.
15:14:42 <Pamelloes> slack1256: That's an interesting idea. Would that work if I use undefined :: MyType?
15:14:53 <slack1256> yes
15:14:54 <ski> Pamelloes : ok, then i dunno :(
15:15:03 <ski> Pamelloes : i suppose you could use `let' ?
15:15:09 <edwardk> this has the same asymptotics as an open ended binary search, but because it uses a smaller power (phi rather than 2) it tends to avoid using the predicate on entries that are quite so large
15:15:21 <edwardk> without requiring anything too complicated, just arithmetic
15:15:21 <slack1256> Although that idiom has its detractors. I don't find it harmful
15:15:27 <Pamelloes> ski: slack1256 suggested I use asTypeOf, so I'm going to try that
15:15:28 <edwardk> ion: that is the idea anyways
15:15:34 <latk> ski: Interesting. I'll do some reading about these things - I think getting comfortable enough with them that I realise when they might help me will take some time..
15:15:57 <slack1256> what we need is a `asTypeOf` that uses Data.Proxy
15:16:37 <edwardk> :t Data.Proxy.asProxyOf
15:16:38 <lambdabot> Not in scope: ‘Data.Proxy.asProxyOf’
15:16:42 <edwardk> :t Data.Proxy.asProxyTypeOf
15:16:43 <lambdabot> a -> Proxy a -> a
15:16:59 * slack1256 is happy then
15:17:04 <kaw_> Is there a binding/library for SDL that's mature and not painfully low-level? I started using sdl2-1.0.2, but it seems like it's so low-level that I need to call Foreign.* functions for practically every SDL call
15:17:08 <edwardk> that is rather unfortunate. it was _supposed_ to be a -> proxy a -> a -- but when it moved into base someone monomorphized it =(
15:17:30 <edwardk> so i had to take a crap ton of code that was working find before and make my own local copy of that function =(
15:17:36 <edwardk> er working fine
15:17:44 <ski> latk : yes. one final point. one can imagine such a thing as a "polymorphic type". let's say you have a type that you want to use both at kind `(* -> *) -> * -> *' and `((* -> *) -> *) -> (* -> *) -> *' .. in general, you want it to have kind `(k -> *) -> k -> *', for any kind `k'. iow you want it to have kind `forall k. (k -> *) -> k -> *' .. such a type would be a "polymorphic type"
15:18:15 <slack1256> edwardk: is that bad? is there a case where you would want anything else than a `Proxy` on there?
15:18:18 <edwardk> ion: the code in fractions for Fib for multiplying numbers in Z(phi) should give insight into the bound recursion.
15:18:18 <ski> latk : if you're interested, i can suggest a relatively basic paper on types, that might be helpful
15:18:29 <latk> ski: I suspect the more basic the better, at this point :)
15:18:32 <edwardk> slack1256: sure. a -> [a] -> a -- where you have a list lying around.
15:18:47 <slack1256> oh, that's convenient
15:18:48 <edwardk> i tend to pass all sorts of things to that function
15:18:49 <latk> ski: But yes, I would be interested in reading about this stuff.
15:19:13 <ski> latk : "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)>
15:20:03 <ski> latk : you can also try at least the initial portions of "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>
15:20:39 <kaw_> Alternately, is there a mature UI library that anyone can recommend for, with a minimum of fuss, handling keyboard events and possibly putting very very simple stuff on the screen?
15:20:45 <latk> ski: excellent, thanks.
15:20:51 <ski> latk : both of these talk about universal and existential quantification in types
15:21:19 <ski> latk : i remember i read these two relatively early on, when learning about (modern) type systems
15:21:37 <latk> ski: How much background maths do these assume? 
15:21:39 <edwardk> ion: so basically what it does is square phi in Z(phi) repeatedly. and the coefficients you get for phi when you do this are all fibonacci numbers. you get F_(n-1) + F_n(phi) then F_(2n-1) + F_2n(phi)
15:22:28 <latk> ski: It seems that the first one mostly defines the operators it uses, which I appreciate!
15:22:34 <edwardk> ion: when thats done i have a bound. it lies between (F_n,F_2n]  -- but i don't have a nice structure to that space so i restart the count at 0, and look at (0,F_2n]
15:23:09 <ski> latk : not much. it will probably help if you know about basic algebra (know what variables are, and how to manipulate and reason about equations. iow basic symbol manipulation)
15:23:19 <edwardk> if i had a better recurrence i could find something where the growth rate was comparable, but where the space from (L_n, and L_2n) had the right shape for me to recurse with a slight bias
15:23:22 <ion> edwardk: Interesting
15:23:32 <ski> latk : having a vague idea of what sets are (and intersection, union) might also help a little
15:23:37 <latk> ski: Yeah, my background is in physics, so I'm pretty comfortable in general - but I didn't study much pure maths.
15:23:40 <edwardk> biasing means branch prediction works better, and it favors smaller values.
15:23:53 <latk> proofs are something of a mystery to me
15:24:17 <athan> Is there a way to declare fixity for unary functions? Ideally I would like `foo "foo" </> bar "bar"` to turn into `(foo "foo") </> (bar "bar")`
15:24:25 <athan> unless I could just make </> weaker
15:24:33 <ski> latk : i first understood proofs via the "Curry-Howard correspondence" (iow proofs are basically the same as programs. propositions are basically the same as types)
15:24:36 <benzrf> athan: that's what it does...
15:24:47 <arkeet> athan: function application binds tighter than any infix operator.
15:24:49 <athan> benzrf: :S
15:24:52 <arkeet> so it already does.
15:24:55 <athan> ><
15:24:59 <arkeet> (and you can't change it.)
15:25:03 <athan> thanks benzrf
15:25:04 <monochrom> > sin 0 + 3
15:25:05 <lambdabot>  3.0
15:25:09 <monochrom> is an example
15:25:13 <benzrf> > sin 3
15:25:14 <lambdabot>  0.1411200080598672
15:25:33 <slack1256> oh, then I've been putting extra parenthesis for free
15:25:36 <latk> ski: Huh, okay. Well perhaps this is reading for tomorrow. Thanks for your help! :)
15:25:55 <ski> latk : at least the first paper i mentioned talks a little about CH at the end ..
15:27:26 <edwardk> @oeis 1,1,3,21,987,2178309,10610209857723
15:27:26 <lambdabot>  (2^n)-th Fibonacci number.[1,1,3,21,987,2178309,10610209857723,2517288256835...
15:27:34 <edwardk> that has no useful structure
15:27:45 <edwardk> well not the differences between them
15:28:13 <athan> Does anyone here have module re-export interface issues when using sandboxes? Something like this: http://lpaste.net/131364
15:28:24 <edwardk> @oeis 0,2,18,966,2177322,10610207679414,251728825683538877940566538
15:28:24 <lambdabot>  Sequence not found.
15:28:47 <edwardk> you know its bad when oeis doesn't even recognize something =)
15:29:08 <ion> heh
15:29:53 <arkeet> > map snd $ iterate (\(a,b) -> (a*a+b*b,2*a*b+b*b)) (0,1)
15:29:55 <lambdabot>  [1,1,3,21,987,2178309,10610209857723,251728825683549488150424261,14169381771...
15:30:05 <edwardk> arkeet: sure
15:30:10 <edwardk> that is the fast fib transform
15:30:18 <arkeet> FFT?
15:30:39 <Gurkenglas> If Set isn't a Functor because fmap accepts function that dont preserve equality, then why is Set Foldable when fold accepts noncommunative monoids?
15:30:57 <arkeet> because Foldable has no laws.
15:30:57 <Gurkenglas> *functions
15:30:58 <edwardk> arkeet: http://www.inwap.com/pdp10/hbaker/hakmem/recurrence.html
15:31:03 <arkeet> (aside from the free one.)
15:31:23 <edwardk> Set has invariants that are exposed in its api about the fact that it uses the ordering of the numbers to keep them in sequence
15:31:30 <arkeet> edwardk: you don't need to tell me how to compute fibonacci numbers :p
15:31:37 <edwardk> arkeet: i know =)
15:31:49 <arkeet> ah that's where you got the term.
15:32:03 <edwardk> providing a reference for the other 1517 people in the channel, and the source of the name
15:32:20 <arkeet> ic
15:32:50 <monochrom> I guess the url isn't joking when it says "PDP 10"
15:32:53 <edwardk> anyways that nicely gives consecutive pairs of fibonacci numbers, which is what i needed to bootstrap the search
15:33:06 <arkeet> > iterate (\(a,b) -> (a*a+b*b,2*a*b+b*b)) (0,1)
15:33:07 <lambdabot>  [(0,1),(1,1),(2,3),(13,21),(610,987),(1346269,2178309),(6557470319842,106102...
15:33:08 <edwardk> monochrom: yeah that was from the 70s
15:33:22 <athan> Cale: Check out the types lol http://hackage.haskell.org/package/nested-routes-0.2/docs/Web-Routes-Nested.html
15:33:43 <schell> i’m using bindings-DSL and would like to represent a pointer to a function that takes a variable number of arguments - is that possible?
15:33:53 * hackagebot nested-routes 0.2 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-0.2 (athanclark)
15:34:24 <michaelt> kaw_: gloss can handle some keyboard input http://hackage.haskell.org/package/gloss-1.9.2.1/docs/Graphics-Gloss-Interface-Pure-Game.html see the Event and Key types
15:34:35 <edwardk> arkeet: had a little bit of fun trying to figure out how to put an Ord instance on Z(phi) earlier today
15:35:05 <Gurkenglas> Don't forget people of the distant future browsing the log. Why should Foldable have no law like fold preserving equality?
15:35:22 <edwardk> fold how?
15:35:29 <ion> edwardk: http://hackage.haskell.org/package/quadratic-irrational-0.0.5/docs/src/Numeric-QuadraticIrrational.html#instance%20Ord%20QI :-)
15:35:32 <edwardk> Foldable doesn't know if your type is a monoid
15:35:58 <edwardk> ion: heh same basic idea i think
15:36:16 <edwardk> i cheat a bit more
15:36:32 <Cale> athan: ridiculous :P
15:36:46 <athan> Cale: MUST... HAVE... SOUNDNESS
15:36:52 <edwardk> in my case i check if both signs agree and shortcut, then otherwise compare squares once i convert from Z(phi) to Z(sqrt 5)
15:37:35 <arkeet> edwardk: I tried figuring that out a while ago.
15:37:45 <Gurkenglas> Foldable provides fold :: Monoid m => t m -> m. The law would rule that all of its "specializations" (inventing that word) preserve equality.
15:37:54 <Gurkenglas> *to a monoid m
15:38:04 <arkeet> I forget where I put it.
15:38:10 <edwardk> https://github.com/ekmett/fractions/blob/master/Fractions.hs#L294
15:38:53 * hackagebot hipbot 0.2 - A library for building HipChat Bots  http://hackage.haskell.org/package/hipbot-0.2 (purefn)
15:39:40 <kaw_> michaelt: Excellent, gloss looks like it might meet my needs. Thanks
15:39:41 <arkeet> edwardk: https://gist.github.com/arkeet/ca8951fa2fba7cf57e46
15:40:01 <arkeet> edwardk: see gtPhiDiv
15:40:12 <edwardk> tsk you should be able to compute abs =)
15:40:16 <michaelt> kaw_: it's very simple, just make sure it will do what you want before getting buried, there are examples if you do cabal unpack gloss-examples
15:40:18 <arkeet> lazy!
15:40:32 <arkeet> actually then I'd need an Integral constraint or something.
15:40:49 <slack1256> What is the most extensibility you can get from a program without a haskell compiler?
15:41:00 <slack1256> For doing stuff as xmonad without is recompilation hack
15:41:22 <slack1256> *its
15:42:28 <geekosaur> http://hackage.haskell.org/package/dyre
15:42:29 <geekosaur> ?
15:43:01 <edwardk> arkeet: Hrmm, by Lamé's theorem ZPhi (fib n) (-fib (n-1)) -- would kinda suck that way
15:43:09 <edwardk> arkeet: since you're basically computing it gcd style
15:43:23 <arkeet> ?
15:43:24 <edwardk> and then you have literally the worst case
15:43:27 <arkeet> what would suck
15:43:35 <edwardk> checking if that was positive or negative
15:43:52 <edwardk> it takes ~4.7x the number of digits in steps =)
15:43:53 * hackagebot nested-routes 0.2.0.1 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-0.2.0.1 (athanclark)
15:43:59 <arkeet> yeah.
15:44:42 <edwardk> and i guess you'd actually see that case in practice when you look at the ZPhi's you get when computing negative fibonacci numbers
15:45:40 <Pamelloes> Is (a->a) defined as a Monoid within the standard library or do I have to define it myself?
15:45:49 <glguy> It's called "Endo"
15:45:53 <arkeet> Pamelloes: it isn't, but look at Endo
15:45:57 <arkeet> (which is a newtype for that)
15:46:06 <Pamelloes> Ok
15:46:15 <arkeet> Pamelloes: the reason is that (a->m) has a different Monoid instance, where m is a Monoid
15:46:26 <slack1256> geekosaur: the ghc-path dependency maybe rules it out? or is there for another reason?
15:47:00 <arkeet> edwardk: ok yeah your thing makes sense heh.
15:47:11 <geekosaur> ghc-paths doesn't appear to depend on ghc, only base
15:47:14 <edwardk> the algorithm i used?
15:47:17 <arkeet> yeah.
15:47:23 <edwardk> for ord or for upward closed search?
15:47:24 <geekosaur> and it's not part of ghc
15:47:25 <arkeet> for Ord.
15:47:29 <edwardk> ah good
15:47:34 <edwardk> i kinda pulled it out of my behind =)
15:47:44 <arkeet> should have been obvious in retrospect :p
15:53:54 * hackagebot nested-routes 0.2.0.2 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-0.2.0.2 (athanclark)
15:54:21 <edwardk> of course now you've convinced me that my abs/signum are wrong, and i don't want to add an Ord requirement to get Num.
15:54:32 <edwardk> so i'm kinda hosed anyways =)
15:55:15 <arkeet> heh
15:55:53 <Aruro> guy, how does cabal know my default name? im on archlinux
15:56:02 <Aruro> he offered me Aruro, during cabal init
15:56:06 <Aruro> :)
15:56:23 <Aruro> guys*
15:56:37 <c_wraith> Do you have it listed as your real name in your system account?
15:56:41 <ion> getent passwd $(id -u)
15:56:43 <Adeon> have you set that as your name in your...what c_wraith said
15:57:46 <arkeet> Aruro: it gets it from the current directory or something.
15:58:00 <arkeet> or do you mean for the author part or something.
15:58:05 <arkeet> yeah.
15:58:07 <Aruro> yes
15:58:28 <Aruro> he was able to suggest this name which i use i guess only for irssi
15:59:00 <Aruro> i dont think i have Aruro listed in my sistem
15:59:07 <Aruro> my user name is different
15:59:23 <srhb> Aruro: So your null hypothesis is that cabal is psychic? :-)
15:59:28 <Aruro> :)
16:00:10 <Aruro> well there is emacs psyhotherepist :)
16:00:44 <Aruro> ok i repeated, he suggests author name as Aruro
16:00:49 <ion> env | grep Aruro. Anything? EMAIL?
16:00:55 <Aruro> nope
16:00:58 <Aruro> no email with that name
16:01:00 <rom1504> use cabal to know your future
16:01:03 <Aruro> :D
16:01:09 <Aruro> wait
16:02:08 <Aruro> env | grep Aruro yields nothing
16:03:34 <michaelt> Aruro: it seems to be using my github information ...
16:04:11 <michaelt> Aruro: cat .gitconfig  
16:05:08 <Aruro> yep
16:05:09 <Aruro> that
16:05:16 <Aruro> in home directory
16:05:20 <Aruro> ty
16:05:21 <Aruro> :)
16:05:25 <michaelt> funny, i wouldn't have thought it would snoop around like that...
16:05:30 <Aruro> yeah :)
16:05:44 <Aruro> i was running it from different directory in sandbox
16:09:52 <rom1504> cabal is parsing all your infos and sending it to the nsa, don't worry about it
16:10:52 <c_wraith> The part that concerns me is that the NSA is responding to its requests.
16:12:08 <michaelt> surely the NSA knows what license I prefer.
16:14:49 <Pamelloes> michaelt: Well obviously the NSA knows which license you prefer, but they're going to tell you which license /they/ prefer. And let's be real here, they've been fighting over that for the past decade.
16:15:14 <dst1> Hi guys.. I'm trying to run "cabal test" with -fhpc flag (coverage), but cabal fail with: "hpc: can not find ansi-terminal-0.6.2.1/System.Console.ANSI.Unix" ...
16:15:32 <dst1> What is wrong? Any help will be appreciated!!!
16:15:45 <dst1> Thanks to everyone in advanced :)
16:19:48 <mniip> Pamelloes, GPL is love GPL is life
16:20:14 <Pamelloes> mniip: LGPL 4 lyfe
16:20:32 <Pamelloes> (though that's still a pain. I actually prefer MIT or BSD)
16:20:37 <Pamelloes> BSD 4 clause anyone?
16:23:48 <Pamelloes> What's the best way to make a function with the type signature of (a,b->c) -> b -> (a,c)
16:23:58 <michaelt> dst1: oh wait, you are using system.console.ansi.unix?
16:24:31 <arkeet> :t (??)
16:24:32 <lambdabot> Functor f => f (a -> b) -> a -> f b
16:24:52 <arkeet> (??) f a = fmap ($a) f
16:24:54 <schell> Pamelloes: (a, f) b = (a, f b) 
16:24:58 <schell> ?
16:25:33 <Pamelloes> Is that a true statement?
16:25:36 <arkeet> :t (??) :: (a,b -> c) -> b -> (a,c)
16:25:37 <lambdabot> (a, b -> c) -> b -> (a, c)
16:25:53 <Pamelloes> arkeet: Ooh, nice :)
16:26:48 <Pamelloes> Is (??) part of base, or do I need to define it myself?
16:27:11 <ion> lens
16:27:31 <Pamelloes> Interesting. I've never used lens.
16:27:44 <arkeet> it's not really an important part of lens, it's just sorta there.
16:27:47 <arkeet> it generalizes flip.
16:28:20 <edwardk> we put it in the package because everyone kept asking for prefix versions of all the combinators with the arguments in ever so slightly different orders
16:28:23 <edwardk> it fixed that need
16:28:31 <edwardk> i really should have stuck to my guns and taken (?) though
16:28:47 <arkeet> heh
16:29:34 <arkeet> well at least 7 different packages already have (?)
16:50:07 <jophish> Can one just generate the docs for a package, rather than compile it
16:50:26 <jophish> for example, generate documentation for a package which doesn't compile
16:52:43 <monochrom> try "cabal haddock". it may succeed or it may still fail.
16:53:16 <sydneyhacker> Pamelloes: Is it possible?
16:53:51 <arkeet> is what possible?
16:54:14 <Clint> it
16:54:19 <jophish> monochrom: hmm, seems to need dependencies installed
16:55:13 <sydneyhacker> arkeet: Forget I said that I misread somethign
17:08:57 * hackagebot aeson-better-errors 0.6.0.0 - Better error messages when decoding JSON values.  http://hackage.haskell.org/package/aeson-better-errors-0.6.0.0 (hdgarrood)
17:12:05 <joneshf-laptop> I know this is wrong, but I'm not sure how to make it correct: http://lpaste.net/131368
17:12:25 <joneshf-laptop> I want to "demote" the kind to a type
17:13:45 <Hijiri> use singletons?
17:14:02 <Hijiri> instead of => n, have singleton type with n as the parameter
17:14:37 <joneshf-laptop> updated
17:14:42 <joneshf-laptop> Hijiri, what does that mean?
17:15:30 <Hijiri> not sure, maybe you have to make n's kind explicit
17:18:20 <Hijiri> oh, Nat is *
17:18:35 <Hijiri> so your type instance Reify Nat = Int made it infer Reify's type to be * -> **
17:18:41 <Hijiri> * -> *, I mean
17:19:04 <Hijiri> so maybe if you annotate Nat's kind?
17:21:53 <joneshf-laptop> Hijiri, no bueno
17:21:57 <Hijiri> n isn't going to be Nat
17:22:03 <Hijiri> it is going to be kind Nat
17:22:21 <Hijiri> so you wouldn't be able to apply Reify to it like that I think
17:23:07 <Hijiri> I haven't done too much with type families though, so I don't know how much I can help
17:23:40 <joneshf-laptop> Hijiri, no worries
17:23:53 <joneshf-laptop> i just need a type wizard to show up and blow my mind
17:26:02 <pavonia> Is "type family Reify n :: *" the same as "type family Reify :: n -> *"?
17:27:06 <enthropy> joneshf-laptop: http://lpaste.net/131368#line43 should be type family Reify (n :: Nat) :: * -- assuming you want the instance below to be accepted
17:27:31 <enthropy> either that or enable PolyKinds and then deal with type families not reducing because the kind variables are not specified
17:28:51 <Jesin> I seem to recall reading somewhere that the Monad (or maybe it was something else like MonadPlus?) instances in Parsec do not satisfy all of the axioms that are usually assumed for that class. Is this correct? Or am I misremembering?
17:30:00 <joneshf-laptop> pavonia, no clue
17:30:03 <enthropy> pavonia: no, the second one can only have one instance like type instance Reify = Proxy -- though I don't know off hand if we have NullaryTypeClasses for type families
17:30:33 <joneshf-laptop> enthropy, that doesn't seem to help, it moves the error to the line with the type instance.
17:31:00 <enthropy> while the first can have type instance Reify Int = (); type instance Reify Char = Double
17:33:44 <enthropy> well your http://lpaste.net/131368#line47 doesn't give ghc any way to decide what n should be (0, 2, 4, ...)
17:34:08 <pavonia> enthropy: in "type family Reify (n :: Nat) :: *" is "Nat" a kind or a kind of a kind (forgot what is was called)
17:34:18 <arkeet> Nat is a kind.
17:34:47 <arkeet> in haskell there is only one kind of kinds, called BOX.
17:35:06 <arkeet> (I think people call BOX a "sort".)
17:35:23 <Welkin> I thought haskell didn't have sorts
17:35:27 <pavonia> Ah, "sort" was the word
17:35:29 <arkeet> it has just one.
17:35:41 <arkeet> and since there's only one there's no value in talking about it.
17:36:29 <schell> has anyone written a C parser that can auto generate haskell FFI code?
17:37:06 <arkeet> yes, what was it called uh
17:37:07 <enthropy> joneshf-laptop: and there isn't any way for some later use of evenTwo to work out what n should be
17:37:14 <arkeet> c2hsc might be what I'm thinking of.
17:37:32 <enthropy> c2
17:37:35 <enthropy> oops
17:37:36 <arkeet> or c2hs
17:37:36 <joneshf-laptop> enthropy, okay
17:37:48 <schell> arkeet: those both sound familiar, thanks
17:38:05 <pavonia> Hhm, I'm still not sure I understand the difference between "Reify n :: *" and "Reify :: n -> *"
17:38:22 <enthropy> some time it can pick Any for a type variable that makes no difference, but I don't think it can be used here
17:38:26 <arkeet> pavonia: the thing on the left of :: is a type. the thing on the right is a kind.
17:38:53 <pavonia> Ah!
17:39:47 <schell> arkeet: i think it was c2hsc http://hackage.haskell.org/package/c2hsc
17:39:59 <joneshf-laptop> enthropy, i'm 100% sure i'm not doing this correctly, i just don't know what do to do to make it correct.
17:40:16 <pavonia> arkeet: But isn't the kind of Reify * -> * in the first case?
17:40:35 <joneshf-laptop> what I want is to have the type reflect that it's even.
17:40:36 <enthropy> pavonia: in both cases ghci will tell you the same thing for :kind Reify (if you have PolyKinds)
17:40:46 <arkeet> pavonia: depends on whether you have PolyKinds.
17:41:18 <arkeet> pavonia: maybe you wonder what the difference is between
17:41:25 <arkeet> Reify (n :: Nat) :: * 
17:41:28 <arkeet> Reify :: Nat -> *
17:41:46 <pavonia> Someone told me "n" can't have kind "* -> *", IIRC
17:41:56 <pavonia> but "*" can
17:42:02 <arkeet> it can have any kind, if you have PolyKinds. but without it it defaults to *
17:42:17 <acowley> Has anyone used Data.Constraint.Forall?
17:43:32 <pavonia> While we're on it, I recall I wanted to read that paper on polykinds ...
17:48:59 * hackagebot riff 0.3.0.1 - RIFF parser for Haskell  http://hackage.haskell.org/package/riff-0.3.0.1 (RobertMassaioli)
17:52:07 <benzrf> is int-e here
17:52:38 <bitemyapp> benzrf: well, their IRC client is.
17:54:46 <enthropy> joneshf-laptop: I think you need a class (not a type family) to convert the `n' to a number
17:54:50 <enthropy> to an Int
17:55:40 <enthropy> GHC.TypeLits.natVal :: KnownNat n => proxy n -> Integer -- probably the function to be using
18:02:54 <travgmon> How would I specify in a list comprehension the step I want to increment through the list?
18:03:26 <benzrf> hmm
18:03:53 <mokus_> @tell sinelaw made some progress on lambdabot on 7.10.  it's not ready for hackage, but i have a working docker build so we at least know where the pain points are.  Created a tracking ticket with link to the docker build at: https://github.com/lambdabot/lambdabot/issues/120
18:03:53 <lambdabot> Consider it noted.
18:06:40 <enthropy> travgmon: you could do something like [ f x | (x, True) <- xs `zip` cycle [True, False, False] ] -- if you want every 3rd element
18:08:08 <travgmon> hmmm
18:08:10 <enthropy> another option is [f x | (x, n) <- xs, mod n 3 == 0 ]
18:08:33 <enthropy> another option is [f x | (x, n) <- xs `zip` [0 .. ], mod n 3 == 0 ]
18:09:47 <enthropy> ie. list comprehensions go through every element of the list, and you have to use some other features to fake what you're asking for
18:10:04 <acowley> Whenever I try to use Forall, the A and B skolems are all over my error messages :(
18:10:26 <travgmon> Yeah that is where it was troubling me
18:10:49 * Maxdamantus didn't know list comprehensions could have failing patterns.
18:11:17 <Maxdamantus> > [4 | 5 <- [1..10]]
18:11:19 <lambdabot>  [4]
18:12:11 <Maxdamantus> @undo [4 | 5 <- [1..10]]
18:12:11 <lambdabot> concatMap (\ a -> case a of { 5 -> [4]; _ -> []}) [1 .. 10]
18:13:00 <arkeet> > [ x | (n,x) <- zip [0..] "abcdefghijklmnop", n `mod` 3 == 0 ]
18:13:02 <lambdabot>  "adgjmp"
18:13:07 <KaneTW> > [ x | (x:_:_) <- [1..10]]
18:13:08 <lambdabot>      No instance for (Show t0)
18:13:09 <lambdabot>        arising from a use of ‘show_M585784680652166840325343’
18:13:09 <lambdabot>      The type variable ‘t0’ is ambiguous
18:13:19 <KaneTW> > [ x | (x:_:_) <- "abcdef"]
18:13:20 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘[t]’
18:13:21 <lambdabot>      In the pattern: x : _ : _
18:13:21 <lambdabot>      In a stmt of a list comprehension: (x : _ : _) <- "abcdef"
18:13:25 <arkeet> that won't work.
18:13:38 <KaneTW> yup
18:13:39 <arkeet> (x:_:_) matches a list.
18:13:42 <KaneTW> yeah
18:13:47 <KaneTW> that was a brainfart
18:15:38 <mjrosenb> so, if I have (let x = ... in x), it is reasonable that I can't just replace x with its definition, right?
18:15:50 <arkeet> it is?
18:16:18 <arkeet> you sure can. (if it's not a recursive definition.)
18:16:23 <mjrosenb> right. this is
18:16:46 <arkeet> if it's recursive then you can eliminate the let by using fix.
18:18:54 <mjrosenb> unfortunately, this is a bit crazier
18:19:11 * mjrosenb could probably use fix, but it'll almost certainly make it uglier
18:19:30 <SrPx> I believe this is stupid, but how do I fix this? http://lpaste.net/131370 notice that "rendered :: [Sphere V3 Float] -> Quaternion Float -> [Int] -> V.Vector [Float]" is called for each pixel each frame. So it essentially renders the whole image for each pixel and selects the specific pixel (lol)
18:20:14 <SrPx> But how can this be fixed, if "draw" is called for each pixel and not for each pass? '-' Damn I know there is probably a simple obvious solution
18:22:33 <akurilin> I have an issue with s
18:23:07 <akurilin> my sandbox with add-source dependency in it. When I try to build the project that has the dependency, it says "cannot satisfy -package-id foo ...."
18:23:16 <akurilin> this is usually when the dependency got updated
18:23:38 <akurilin> I tried install with --force-reinstall --upgrade-dependencies and all sorts of other stuff, nope.
18:23:49 <akurilin> I tried cabal sandbox hc-pgk -- unregister foo --force, nothing
18:23:56 <akurilin> I have to delete the sandbox and start from scratch
18:24:15 <akurilin> Which makes me sad. Advice>
18:24:16 <akurilin> ?
18:24:32 <arkeet> you mean cabal exec ghc-pkg?
18:25:05 <akurilin> oh.. cabal sandbox hc-pgk ran just fine, no errors
18:25:32 <arkeet> oh that's a thing.
18:25:34 <arkeet> hc-pkg
18:26:07 <akurilin> So it definitely should be cabal exec?
18:30:05 <akurilin> arkeet: yeah cabal exec doesn't work in that context, it has to be cabal sandbox
18:41:43 <saml_> do you recommend hsenv?
18:49:05 <Welkin> saml_: what's wrong with cabal sandboxes?
18:49:25 <saml_> oh i didn't know about cabal sandboxes
18:59:55 <SrPx> How can "memoize" from Data.Function.Memoized work if its concept breaks purity? That is, in order for it to work it has to set a state somewhere recording the result of the function whenever it is called... so when it is called on another place it reads and returns it. But that shouldn't be doable without IO, which `memoize` doesn't use.
19:01:27 <geekosaur> laziness. once a thunk is evaluated, the result is retained
19:03:05 <SrPx> Uhm but it has to return the same thunk on the second call
19:03:23 <SrPx> right?
19:04:21 <geekosaur> so, you combine laziness with something like a map from parameters to result thunks. the first time a call is forced, the thunk in the map is replaced by the result; further invocations with that parameter value will return the precomputed value instead of the thunk
19:05:20 <geekosaur> (this is somewhat related to "tying the knot", where the knot is hidden in the map)
19:08:41 <geekosaur> so instead of a call to that function, memoize gives them a thunk representing a lookup in the map. when one of those is forced, the map's result thunk is replaced with the value; subsequent calls do the map lookup and get the value instead of the thunk that would compute it
19:08:56 <alexv19> I have sandboxed cabal project at ./ The source code is loacted at ./src I want to make -ddump-simpl of ./src/Main.hs If I do "ghc ./src/Main.hs -ddump-simpl" ghc fails to find sandboxed packages and my other modules. If I do "cabal exec ghc -- ./src/Main.hs -ddump-simpl" ghc fails to find my other modules.
19:09:14 <alexv19> What sould i do?
19:09:58 <geekosaur> cabal exec ghc -- -isrc src/Main.hs -ddump-simpl ?
19:10:40 <SrPx> ah I see how it is done now, thank you geekosaur 
19:11:30 <SrPx> that is enlightening... so it doesn't scape purity at all
19:11:46 <geekosaur> nope, just makes clever use of non-strict evaluation
19:12:08 <SrPx> uh huh
19:12:18 <geekosaur> I think you actually need purity to have it work reliably
19:13:41 <alexv19> geekosaur: Thanks!
19:15:08 <geekosaur> without purity, the runtime can't safely share the map lookups, so you get no memoization. As the docs for the module state, it's not an absolute guarantee *with* purity --- but at least so far, ghc does share them
19:16:04 <SrPx> is there any way to scape purity, though? what I want to do will probably not break pure code
19:16:09 <mniip> just implement Eq1 IO :)
19:16:30 <geekosaur> like I said, this relies on purity not being broken
19:16:49 <geekosaur> if you do something that breaks it (e.g. the thunk does unsafePerformIO), all bets are off
19:17:20 <SrPx> oh you answered my question, thanks!
19:17:58 <SrPx> unsafePerformIO, I forgot about it
19:18:09 <SrPx> (I was not talking about Data.Function.Memoize anymore, it was another question)
19:18:23 <geekosaur> actually, as I understand how ghc works, it will still share them and you will get unfortunate results if the unsafePerformIO-d evaluation would be expected to produce different values at different times
19:19:05 <geekosaur> this is, for example, why the unsafePerformIO-for-global-variables hack requires a NOINLINE pragma --- if it's inlined then they're not shared
19:19:58 <SrPx> if I am not mistaken, unsafePerformIO can never break pure code as long as you don't reflect the effects on your results, right? For example, if you use unsafePerformIO to increase a global counter, the global counter will be undeterministic and will depend on how the program is evaluated, compiled, etc. 
19:20:05 <SrPx> but the program itself will not be affected. correct?
19:21:18 <Hijiri> if you never use the counter value?
19:21:33 <geekosaur> not sure what you mean by "not be affected"
19:21:45 <geekosaur> you can't cause a core dump that way
19:22:02 <ski> SrPx : with `unsafePerformIO' (and parametric mutable references) you can implement `unsafeCoerce :: a -> b'
19:22:19 <geekosaur> depending on what assumptions are made --- by your code and by the compiler and by the runtime --- it may lead to unexpected behavior
19:23:20 <SrPx> I mean - `add a b = unsafePerformIO $ do { print "ha"; return $ a + b }` -- if you replace (+) by "add" in all Haskell programs, I don't think any of them would stop working, right? They would just spam the console
19:24:03 <ski> yeah, the compiler is allowed to treat `unsafePerformIO act' as if it was equivalent to `return x' for some value `x'. e.g. it is allowed to duplicate `unsafePerformIO act' (so that `act' may be executed more times than you expected)
19:24:34 <Pamelloes> Is there a way to parse a Num from a String where it will either be an Int or a Double depending on the presence of a decimal point?
19:25:21 <geekosaur> SrPx: you just reinvented Debug.Trace :)
19:25:36 <ronh> all this talk about unsafePerformIO makes me wonder how evil this is? logPath = unsafePerformIO (getAppFile "log.txt")
19:25:47 <mryan> hi everyone is it even possible to get the first 10 word from a text?
19:25:58 <ronh> it is a top-level variable, shared by various modules
19:26:03 <SrPx> so what I said is right :)
19:26:06 <geekosaur> Pamelloes, that's kinda a badly defined question. Num is not a type, and a function Num a => String -> a is caller-specified a, not specified by your function
19:26:28 <geekosaur> worse, if it were specified by your function, you could never *use* that function because the caller would never know what type to expect
19:27:04 <geekosaur> you could use an existential wrapper type, with the Typeable constraint, but that's typically not the best way to do things
19:27:23 <geekosaur> (nevertheless, applications such as JSON parsing must indeed do that; go look at the implementation of aeson)
19:27:31 <Pamelloes> geekosaur: that's true, I never thought about it that way. From a type perspective this method would make very little sense.
19:27:37 * ski was interpreting what Pamelloes said as asking for something of type `ReadS (Either Int Double)' (or how you want to express the parsing bit)
19:27:44 <SrPx> mryan: from a Text or from a String? You can use `take 10 . words`
19:28:05 <monochrom> ronh: it is not too evil, provided that it actually succeeds, as opposed to running into I/O errors such as file-not-found
19:28:41 <Pamelloes> ski: That's roughly what I want, but that would require a bit of refactoring that I would rather not deal with.
19:29:03 * hackagebot pred-trie 0.0.7 - Predicative tries  http://hackage.haskell.org/package/pred-trie-0.0.7 (athanclark)
19:29:10 <Pamelloes> It occurred to me that this solution is really not the best solution at all.
19:29:20 <mryan> SrPx - String
19:29:29 <ronh> monochrom it just returns path, it does not check if the file actually exists or not
19:29:40 <SrPx> mryan: same answer actually
19:29:52 <mryan> SrPx- thank you.
19:30:19 <Pamelloes> Now, to fix my issue in a much simpler fashion: is there a way to have (show x::Double) not include a decimal point followed by a zero?
19:30:36 <ronh> do I need to use NOINLINE for it? I didn't even know I should.. at worst, without it, getAppFile will be called times? which should always return the same result
19:30:45 <ronh> multiple times*
19:31:43 <geekosaur> Pamelloes, in general you shlould not rely on the output format of show. if you need a specific format, consider Text.Printf or the various show* functions in the Numeric module
19:32:15 <Pamelloes> geekosaur: Makes sense, I'll look into it.
19:32:19 <SrPx> TIL haskell has implicit parameters
19:34:45 <mryan> srPx - question what is the meaning of "." in take 10 . words?
19:34:59 <Welkin> mryan: compose
19:35:06 <ski> mryan : function composition
19:35:09 <Welkin> it is function composition
19:35:31 <ronh> :t (.)
19:35:32 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:35:35 <mryan> can you explain it to me - :-) noob here.
19:35:38 <ronh> @src (.)
19:35:38 <lambdabot> (f . g) x = f (g x)
19:35:42 <ski> > (drop 4 . take 10) ['a' ..]
19:35:44 <lambdabot>  "efghij"
19:35:49 <ski> > drop 4 (take 10 ['a' ..])
19:35:50 <Welkin> mryan: mr yan or m ryan?
19:35:50 <lambdabot>  "efghij"
19:36:10 <mryan> thank you :-)
19:36:50 <ronh> mryan it composes two functions. take 10 . words creates a new function that accepts a String, passes it to words, and then passes the result of that call to take 10
19:37:18 <ski> mryan : conceptually : `f . g' is that function that, when applied to an argument input, will pass that argument as input to `g', and then pass the result of that as input to `f', whose result will be the result of this particular call of the `f . g' function on the current input
19:37:52 <mryan> ski: nice explanation tnk you :)
19:38:04 <ski> > map ((3 +) . (10 ^)) [0,1,2,3,4]
19:38:05 <lambdabot>  [4,13,103,1003,10003]
19:38:24 <ski> here `map' applies the function `(3 +) . (10 ^)' on every element of the list
19:39:20 <ski> mryan : note that you shouldn't read what i said as being the *order* in which things are to be evaluated. i was only describing how the inputs and outputs of those functions are to be *connected* (data flow)
19:39:29 <P4Titan> Hello, I am trying to parse using Parsec. I want to use it in a non-greedy manner. IE: I am trying to parse a simple english context-free grammar. It is just that noun phrases and verb phrases can overlap. Right now, as a greedy parser, the noun phrase parse may sometimes eat up too much of the sentance, leaving a non-valid verb phrase which errors on parsing
19:40:49 <mryan> ski - got it - so as SrPx give me this code take 10 . words - the "words" is another input, ouput right? or wrong?
19:42:35 <Maxdamantus> P4Titan: basically in a non-deterministic manner then.
19:42:46 <SrPx> mryan: words is a function on the standard library that splits a string into words
19:42:58 <P4Titan> Maxdamantus: what do you mean exactly?
19:43:04 <ski> mryan : `words' is a function. in `take 10 . words' is not an input to `take 10'. comparing with `f . g', `take 10' would play the role of `f' and `words' the role of `g'
19:43:16 <ski> > words "This is a dream"
19:43:17 <lambdabot>  ["This","is","a","dream"]
19:44:03 * hackagebot pred-trie 0.0.7.1 - Predicative tries  http://hackage.haskell.org/package/pred-trie-0.0.7.1 (athanclark)
19:45:14 <mryan> ski - so if the words is a function - i have a code like this - take 50 . words (unpack content) - which content is a text - but it gives me this error - Couldn't match type ‘a0 -> [a1]’ with [Char]
19:45:32 <SrPx> mryan: essentially, "(take 10 . words) yourString" is the same as "take 10 (words yourString)", which, first, calls words on yourString (splitting it into a list of words), and then calls "take 10" on that, getting the first 10 words...
19:45:35 <arkeet> that parses as take 50 . (words (unpack content))
19:45:35 <Maxdamantus> P4Titan: how would you know when to stop reading one phrase so that another phrase can begin after it?
19:45:47 <arkeet> what you need is something like (take 50 . words) (unpack content) or perhaps just take 50 (words (unpack content))
19:45:54 <ski> mryan : `take 50 . words (unpack content)' is parsed as `(take 50) . (words (unpack content))'. perhaps you meant `(take 50 . words) (unpack content)' ?
19:46:12 <ronh> mryan do you know lambdas already? (take 10 . words) is the same as (\x -> take 10 (words x))
19:46:51 <SrPx> mryan: the problem with your code is precedence. What you wrote is the same as "take 50 . (words (unpack content))" . The correct is either: ((take 50 . words) (unpack content)) ... or ... (take 50 (words (unpack content))) ... or (take 50 . words $ unpack content) ... whatever you prefer
19:47:14 <P4Titan> Yes, that is tricky. I have an idea, but I came here to see if there is a "smart[er]" way to do it. My idea was to keep a list of all possible parses from least-greedy to most-greedy. If one fails, it traces back to the parse right before the most-greedy and does this until one succeeds. If none do, then it errors.
19:47:34 <P4Titan> SrPx: lisp much?
19:47:48 <SrPx> is it so obvious
19:48:12 <benzrf> :>
19:49:04 * hackagebot nested-routes 0.2.1 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-0.2.1 (athanclark)
19:56:51 <mryan> SrPx, ronh, arkeet, and to everyone - thank you :)
20:03:22 <nshepperd_> P4Titan: parsec has 'try' to do that
20:04:30 <nshepperd_> P4Titan: ie. 'try thingOne <|> thingTwo' will first attempt to parse a thingOne but backtrack and parse a thingTwo if it fails
20:04:41 <P4Titan> All try does is if the parser fails, it won't "eat" any of the text. I am tring to do non-determinisitic parsing
20:05:57 <SrPx> mryan: np :)
20:06:10 <P4Titan> Example: parsing the sentence "fly fly" where if this were a sentence, the noun phrase parser would eat both the flies, when really it should treat the first fly as a noun and leave the second as a verb, to complete the nounphrase + verbphrase structure of a sentence.
20:06:24 <SrPx> Is there any way to get the pointer address of a value on Haskell?
20:09:12 <arkeet> SrPx: what for?
20:10:46 <SrPx> trying to implement hash consing
20:10:58 <arkeet> SrPx: haskell values can move around in memory during gc
20:11:13 <SrPx> uhm okay
20:11:21 <nshepperd_> manyTry1 p q = try (p >> q) <|> (p >> manyTry p q) ?
20:11:33 <SrPx> thanks :(
20:11:37 <arkeet> well
20:11:46 <ronh> is it possible to see a type signature of a locally defined function?
20:12:45 <mniip> ronh, locally defined?
20:12:54 <mniip> does :t not work?
20:12:57 <ronh> inner function, defined with let or where
20:13:06 <ronh> function within a function
20:13:15 <mniip> holes
20:13:44 <ronh> only way? I am still using 7.6.3
20:14:28 <pavonia> ronh: Can't you make it a top-level binding temporarily?
20:15:11 <mniip> I guess you could deploy a hack like this
20:15:17 <mniip> class Fail a where fail :: a -> a
20:15:29 <mniip> you'll get a 'Non instance Fail yourtypehere' error
20:15:40 <ronh> that is actually what I am trying to do, to move a complex inner function to top-level, but I am getting ambiguous type errors
20:16:49 <nshepperd_> SrPx: Foreign.StablePtr? it will work for comparison at least
20:17:58 <ronh> I just thought of a goofy solution (print innerFunction, within the inner function) and it worked :). I got the type
20:18:14 <ronh> within the top-level function that contains it, even
20:19:24 <SrPx> nshepperd_: :D
20:28:08 <mryan> everyone - does haskell is also applicable in desktop app?
20:28:23 <SrPx> Okay but can I convert a StablePtr to an int?
20:29:04 <arkeet> why an int?
20:29:15 <arkeet> you can convert it to/from a Ptr ()
20:29:28 <arkeet> (but don't try to actually dereference it)
20:30:00 <arkeet> ...you can then convert it to an IntPtr if you must
20:31:39 <SrPx> uh I just want an Ord... or Hashable value
20:31:40 <Hijiri> mryan: You can use haskell to write GUI applications, but the choices are limited, especially for windows
20:31:46 <ronh> I don't think I'll use RecordWildCards again.. makes code hard to read and debug months after you've written it
20:31:46 <SrPx> lemme see
20:31:57 <Hijiri> I think HsQML is known to be decent, but I haven't used it myself
20:32:18 <mryan> Hijiri: does haskell more focus on web? how about mobile and game?
20:32:40 <arkeet> SrPx: well, Ptr has an Ord instance.
20:33:01 <Hijiri> mryan: haskell doesn't focus on any particular kind of program
20:33:18 <glguy> Srpx stable pointer isn't likely to help with your hash cons
20:33:33 <arkeet> yeah there's that.
20:33:38 <arkeet> mryan: haskell is a general purpose programming language.
20:33:40 <Hijiri> there has been some game development in haskell, and there is activity in writing better bindings for graphics libraries etc
20:33:54 <Hijiri> but there aren't any go-to big popular game frameworks
20:34:03 <Hijiri> mobile I have no idea
20:34:07 <SrPx> glguy: why? :(
20:34:14 <arkeet> you probably wouldn't use it for writing, say an OS kernel.
20:34:56 <Welkin> the fun part is writing your own game engine
20:34:56 <glguy> Srpx you won't get the same stable pointer is you create two of them for the same value
20:35:10 <Hijiri> mryan: here is the haskell wiki page on android: https://wiki.haskell.org/Android (I don't guarantee that it's up-to-date)
20:35:14 <Welkin> for mobile you can compile haskell to ios
20:35:48 <glguy> So it means you'd have to create them once and use them repeatedly but at that point you're better off just tracking hashes yourself
20:36:09 <Welkin> mryan: the tools for making games in haskell are quite good -- we have complete sdl2 and opengl bindings
20:36:27 <Welkin> haskell for web is the best I have used
20:36:34 <mryan> Welkin: can you give me some site  for that?
20:36:44 <Welkin> I have not yet tried compiling haskell for ios yet
20:36:49 <Welkin> but I heard it works fine
20:37:03 <mryan> Welkin: im using yesod for web and it good :-)
20:37:06 <glguy> They are intended to help pass references to objects out to C and dereference when you get them back from C
20:37:21 <Welkin> mryan: https://hackage.haskell.org/package/sdl2 https://hackage.haskell.org/package/gl
20:37:39 <Welkin> mryan: yes, I sed yesod for most of my web projects and find it to be great
20:37:42 <Welkin> use*
20:39:53 <SrPx> glguy: but that's the idea, I create them once wheneve I const 2 values... and whenever I try to cons 2 values that were already consed before I return the first pointer
20:40:05 <SrPx> whenever* cons*
20:41:45 <SrPx> glguy: but what do you mean with tracking hashes myself?
20:47:08 <neuroserpens> oy guys where is this function "ord" I hear of?
20:47:28 <johnw> should be Data.Char
20:47:37 <johnw> @hoogel ord
20:47:37 <lambdabot> Maybe you meant: hoogle+ hoogle
20:47:39 <johnw> @hoogle ord
20:47:41 <lambdabot> Data.Char ord :: Char -> Int
20:47:41 <lambdabot> Data.Text.Internal.Unsafe.Char ord :: Char -> Int
20:47:41 <lambdabot> package ord-adhoc
20:48:02 <Hijiri> what does the unsafe version do?
20:48:03 <neuroserpens> johnw: wow nice I didn't know I could do that.
20:48:11 <Hijiri> breaks on code points above ascii?
20:48:21 <neuroserpens> johnw: thanks a lot
20:48:40 <ronh> neuroserpens you can do even more, you can search by function signature
20:48:46 <ronh> @hoogle Char -> Int
20:48:47 <lambdabot> Data.Char digitToInt :: Char -> Int
20:48:47 <lambdabot> Data.Char ord :: Char -> Int
20:48:47 <lambdabot> Data.Text.Internal.Read digitToInt :: Char -> Int
20:48:57 <johnw> you can also use the Hoogle web page, rather than asking lambdabot
20:49:00 <neuroserpens> ronh: WOW
20:49:06 <neuroserpens> that's incredible
20:49:08 <neuroserpens> awesome
20:49:11 <ronh> yes :P
21:03:52 <kaidelong> I ran cabal update and now cabal will not work because it got a bad tar archive
21:06:54 <Welkin> first the dinosaurs, now cabal!
21:06:59 <Welkin> the tar pits strike again!
21:08:06 <kaidelong> I am wondering how to fix this
21:08:20 <kaidelong> either roll back to the package list before I ran update or purge the tar cabal has now
21:08:43 <kaidelong> I can't do anything with cabal including building simple things locally
21:16:03 <mjrosenb> It seems like it should be safe to have partial field initialization.  Is there a ghc extension that does this, or is there some inherent reason it is unsafe?
21:17:57 <kaidelong> mjrosenb; "partial field initialization"? Like on records? I think that's supported in plain Haskell
21:18:19 <mjrosenb> e.g. data Test = Test {x :: Int, y :: Bool, z :: String }; Test {y = 5} :: Int -> String -> Test
21:18:37 <kaidelong> oh, you mean curried
21:18:40 <mjrosenb> err, y= True
21:19:10 <kaidelong> well I think the choice that was made was to just set all of the others to undefined
21:19:26 <kaidelong> it still works somewhat the same because you can chain record expressions to fill in the missing bits
21:19:44 <mjrosenb> oh
21:19:48 <mjrosenb> that is only a warning.
21:19:55 * mjrosenb swears he's reading.
21:20:44 <mjrosenb> ooh, even better than undefined
21:20:46 <mjrosenb> *** Exception: <interactive>:8:10-24: Missing field in record construction x
21:21:53 <mjrosenb> ok, much less ideal than just returning the lambda...
21:22:15 <kaidelong> I'm not sure about that, look at it this way
21:22:31 <kaidelong> you can pass a partially filled record to a function if you know that it will not actually use all the fields
21:22:46 <kaidelong> and record expressions can build up a record incrementally
21:23:06 <kaidelong> of course the way OCaml does it is nicer
21:23:15 <kaidelong> since you actually have some type safety
21:23:29 <jmcarthur> you mean ocaml objects?
21:24:00 <kaidelong> jmcarthur: are they called that? Last time I used them they were pretty much exactly like Haskell records but with real types and subtyping?
21:24:09 <jmcarthur> ocaml records don't have subtyping
21:24:14 <kaidelong> oh and open recursion
21:24:15 <jmcarthur> but the objects do
21:24:18 <kaidelong> although it was explicit
21:24:34 <jmcarthur> open recursion?
21:24:37 <kaidelong> "this"
21:24:47 <jmcarthur> yeah, this is all the object system, not records
21:24:51 <mjrosenb> much less ideal for my uses, at least.
21:25:09 <kaidelong> alright
21:25:19 <jmcarthur> ocaml records are basically like haskell's, just with a more tradition syntax for accessors and no ability to combine them with ADTs without nesting multiple types
21:25:24 <jmcarthur> *traditional
21:26:01 <jmcarthur> ocaml objects are basically objects done right. it beats all "OO" languages i know of
21:26:08 <jmcarthur> that said, i still basically never use objects in ocaml
21:26:41 <SrPx> Is there any difference between "do { let k = Foo a b; someEffect k; return k }" and "do { someEffect (Foo a b); return (Foo a b) }" ?
21:26:43 <jmcarthur> i just don't find objects all that useful, and they don't encourage the greatest habits
21:26:51 <SrPx> Can those behave differently?
21:27:20 <SrPx> Not just behave differently - can (Foo a b) be allocated twice on the second?
21:27:29 <jmcarthur> SrPx: they are not allowed to be observably different, though they might perform differently or use different amounts of memory
21:27:37 <nshepperd_>  SrPx yes, cse is not done by default
21:27:46 <jmcarthur> SrPx: Foo a b can be allocated twice in either, technically
21:27:57 <jmcarthur> by which i mean it is allowed to be
21:28:17 <SrPx> can I guarantee that it is allocated once ? 
21:28:22 <kaidelong> there is NOINLINE
21:28:47 <jmcarthur> SrPx: you can with knowledge of ghc and ghc features, just not with haskell itself
21:29:20 <SrPx> maybe if I do "(\ foo → do { someEffect foo; return foo }) (Foo a b)" ?
21:29:26 <SrPx> jmcarthur: so how?
21:29:28 <jmcarthur> SrPx: kaidelong's suggestion to use NOINLINE for this purpose is good
21:29:40 <SrPx> I don't get it... hmm no inline for what
21:29:47 <jmcarthur> SrPx: for k
21:30:03 <kaidelong> NOINLINE is a GHC pragma that prevents the compiler from rewriting "Foo a b" in place of "k"
21:30:04 <SrPx> but k isn't a function
21:30:06 <jmcarthur> SrPx: if k isn't allowed to be inlined, it must be allocated no more than once
21:30:20 <jmcarthur> SrPx: it's an expression
21:30:29 <SrPx> makes sense
21:31:13 <jmcarthur> there are big downsides to playing with pragmas like this, though
21:31:25 <jmcarthur> SrPx: you should be careful, because inlining enables some of ghc's best optimizations
21:32:04 <jmcarthur> SrPx: for example, perhaps both someEffect and the continuation of your function will just immediately pattern match on k. maybe inlining would allow ghc to see there is no point in allocating it in the first place
21:34:09 * hackagebot polynomial 0.7.2 - Polynomials  http://hackage.haskell.org/package/polynomial-0.7.2 (JamesCook)
21:35:37 <kaidelong> okay well that push allowed cabal to fetch a working tarball
21:35:44 <kaidelong> but now it is segfaulting instead
21:37:26 <kaidelong> does "--allow-newer" do what I hope it does?
21:37:27 <SrPx> I know :) thank you!
21:38:05 <kaidelong> I'm trying to get leksah to build against GHC 7.10, if it just wipes all upper bounds and lets builds fail, that would be great
21:59:30 <homovitruvius> somebody sees why in http://dpaste.com/03W3BWB all activity is shown by threadscope to be on one core even when run with ./parallel 6 +RTS -ls -N6?
22:01:02 <nshepperd_> did you compile with -threaded?
22:01:09 <homovitruvius> nshepperd_: yes
22:01:32 <homovitruvius> nshepperd_: ghc -threaded -eventlog -rtsopts --make parallel.hs
22:02:14 <kaidelong> okay so, I have a cabal sandbox, I want to download other dependencies and unpack them into subdirectories
22:02:29 * nshepperd_ doesn't know then
22:02:36 <kaidelong> do I use cabal sandbox init --sandbox path to share the sandbox?
22:02:41 <kaidelong> or do I use add-source?
22:04:06 <kaidelong> I think I'm misunderstanding what "add-source" does though
22:54:12 * hackagebot newtype-deriving 0.1.2 - Instance derivers for newtype wrappers  http://hackage.haskell.org/package/newtype-deriving-0.1.2 (NikitaVolkov)
22:55:07 <joneshf-laptop> if im already in ghci, and i want to install a package with cabal, how can i let ghci know about the newly installed package without restarting it?
23:03:01 <octalsrc> I'm having trouble finding a function that escapes strings for use in an SQL query
23:03:29 <octalsrc> specifically an sqlite3 query
23:06:21 <cmears> joneshf-laptop, as far as I know you just have to restart it
23:07:08 <joneshf-laptop> cmears, :(
23:07:47 <joneshf-laptop> octalsrc, i've not used in anger, but there's a few db things that just have `IsString` instances for sql queries
23:08:41 <kadoban> octalsrc: Escaping strings for SQL is like … bad 90s PHP. Use parameterized statements, so it's impossible for data to be treated like code.
23:09:04 <cmears> joneshf-laptop, it's a pain to have to restart but it's bearable in Emacs+haskell-mode since there is a convenient command to do it
23:10:10 <joneshf-laptop> cmears, yeah, i think it just means i should being using ghci to hold 50+ lines of experiment code
23:10:44 <octalsrc> kadoban: okayy
23:10:47 <cmears> Yes, it also enforces a certain discipline (:
23:11:37 <ecraven> greetings :) is it possible to look at the llvm ir that ghc generates when compiling?
23:12:58 <cmears> ecraven, maybe -ddump-llvm is what you're after?
23:14:17 <ecraven> cmears: that looks exactly right :)
23:14:19 <ecraven> thank you!
23:14:28 <cmears> You're welcome
23:16:56 <zaquest> @pl \n fa -> sequence $ replicate n fa
23:16:56 <lambdabot> (sequence .) . replicate
23:18:36 <peddie> does anyone know how to put test program command-line arguments in a .cabal file?
23:23:51 <cfoch> o/
23:28:11 <Lis> morning everyone
23:28:24 <_mryan> hi can i ask does Haskell can communicate in nodejs?
23:29:02 <hexagoxel> @pl \n fa -> replicate n <$> fa
23:29:02 <lambdabot> (<$>) . replicate
23:30:12 <hexagoxel> :t replicateM
23:30:13 <lambdabot> Monad m => Int -> m a -> m [a]
23:30:22 <_mryan> hi can i ask does Haskell can communicate in nodejs? or vice versa?
23:30:48 <ecraven> _mryan: you want to communicate *with* nodejs? as in send and receive json?
23:31:20 <_mryan> ecraven: sending and reiving emails :) is that possible
23:32:54 <ecraven> _mryan: google gives me many hits for "haskell send email"
23:34:24 <_mryan> ecraven: thank you for reminding me about google sorry :)
23:44:56 <jle`> zaquest: are you looking for replicateM?
23:49:51 <mishac> Hi guys, is there anyone who understands class declarations?
23:50:01 <arkeet> yes, probably many people here do.
23:50:04 <arkeet> what's your question?
23:50:34 <mishac> http://pastebin.com/XcdcHYpA
23:50:38 <mishac> here is the snippet code
23:50:44 <mishac> what i am trying to find out
23:50:55 <mishac> if it is possible to declare a monoid instance for Meter
23:50:59 <nak> good evening everyone
23:51:01 <mishac> and then another monoid for Length
23:51:12 <arkeet> Meter is not a type, so it doesn't make sense to have an instance on it.
23:51:18 <mishac> so that unit lengths are monoids under mutiplication
23:51:23 <mishac> but monoid meter is under addition only
23:51:45 <mishac> I see
23:52:21 <mishac> so in other words, I would have to declare a datatype meter
23:52:23 <Lis> is there a difference of tuple (1,2,3, 4, 5) to (1, 2, 3, 4, 5) ??
23:52:30 <mishac> and made  a monoid under addition
23:52:32 <arkeet> Lis: spaces do not make a difference.
23:53:04 <Lis> ah no, i found my mistake
23:53:05 <Lis> ty
23:53:11 <arkeet> mishac: perhaps. but it might not be terribly useful.
23:53:23 <mishac> hmm
23:53:39 <mishac> i am just trying to write somethig that woukd allow me to keep track of unit operations
23:53:48 <mishac> on top of the number operation
23:54:08 <mishac> it seems like i have look in to some algebras
23:54:14 <mishac> to properly define rules
23:54:24 <mishac> any ideas where i might be able to find anwsers?
23:57:12 <nak> does this cabal install look correct? https://gist.github.com/naomik/ffe5ff5efb964d6aa626
23:57:18 <nak> the output looks quite weird to me
23:57:22 <nak> but i'm not sure what it's supposed to look like
23:59:47 <Lis> i have a list comprehension which should generate a tuple of (LocalTime,Double) from two Lists. How can i merge two tuples with a list comprehension like [(mkDate dd mm yyyy,v) | (dd,mm,yyyy) <- dates (v) <- vals ] ?
