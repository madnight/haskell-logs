00:04:38 <mjrosenb> Cale: [mjrosenb@primer reactive-banana-sdl2]$ cabal exec repl
00:04:38 <mjrosenb> cabal: unrecognised command: exec (try --help)
00:05:05 <arkeet> sounds like you have an old cabal-install
00:05:15 <arkeet> what version?
00:06:15 <mjrosenb> 1.18.0.5
00:06:58 <Cale> I'm on 1.22.0.0
00:07:07 <__ryan> hi how to replace  space " " to dash "-" in a Text?
00:07:15 <__ryan> hi how to replace  space " " to dash "-" in a Text/String?
00:08:46 <arkeet> you can do it with map
00:08:48 <Cale> Perhaps just  T.map (\c -> if c == ' ' then '-' else c)
00:08:49 <mjrosenb> __ryan: map will do the trick in a String.  Probably something similar for Text.
00:09:05 <ChristianS> __ryan: Data.Text has a replace function
00:09:09 <Fuuzetsu> Text.replace
00:09:43 * hackagebot geoip2 0.1.0.1 - Pure haskell interface to MaxMind GeoIP database  http://hackage.haskell.org/package/geoip2-0.1.0.1 (ondrap)
00:09:43 * hackagebot bower-json 0.5.0.0 - Read bower.json from Haskell  http://hackage.haskell.org/package/bower-json-0.5.0.0 (hdgarrood)
00:10:00 <Fuuzetsu> but for single character in Text map may be faster
00:10:27 <arkeet> replace replaces substrings yes.
00:10:34 <Fuuzetsu> at the very least map fuses
00:11:28 <__ryan> lets say "HELL WORLD" -> "HELLO-WORLD"
00:11:52 <Fuuzetsu> we understand your goald and few solutions were posted
00:11:55 <Fuuzetsu> goal*
00:11:55 <Fuuzetsu> afk
00:13:32 <arkeet> :t each %~ \c -> if c == ' ' then '-' else c
00:13:33 <lambdabot> Each s t Char Char => s -> t
00:14:45 <arkeet> :t each . filtered (== ' ') %~ '-' -- I'm bad.
00:14:46 <Cale> haha
00:14:47 <lambdabot>     Couldn't match expected type â€˜Char -> Charâ€™ with actual type â€˜Charâ€™
00:14:47 <lambdabot>     In the second argument of â€˜(%~)â€™, namely â€˜'-'â€™
00:14:47 <lambdabot>     In the expression: (each . filtered (== ' ') %~ '-')
00:14:52 <arkeet> oh.
00:15:00 <arkeet> :t each . filtered (== ' ') .~ '-' -- I'm bad.
00:15:01 <lambdabot> Each s t Char Char => s -> t
00:15:12 <arkeet> :t "a b c" & each . filtered (== ' ') .~ '-'
00:15:13 <lambdabot> [Char]
00:15:16 <arkeet> > "a b c" & each . filtered (== ' ') .~ '-'
00:15:18 <lambdabot>  "a-b-c"
00:15:38 <Cale> Of course, you have to use backwards application just to be that little bit weirder
00:16:35 <__ryan> thank you everyone - it works :-)
00:16:50 <Axman6> :t filtered
00:16:51 <lambdabot> (Applicative f, Choice p) => (a -> Bool) -> Optic' p f a a
00:17:29 <arkeet> this isn't a lawful use of filtered.
00:18:09 <Axman6> why not?
00:19:14 <arkeet> modifying through a filtered is only lawful if you preserve the predicate.
00:19:59 <mjrosenb> arkeet: ok, so make the predicate \x -> x == ' ' || x == '-'
00:20:01 <frerich> Does anybody know other mainstream languages with good support for algebraic data types (sum types in particular) and pattern matching, i.e something more sophisticated than C unions?
00:20:06 <arkeet> yes, I could have done that.
00:20:09 <arkeet> but that's more code :p
00:20:21 <mauke> (`elem` " -")
00:20:40 <arkeet> how mainstream is swift?
00:20:45 <Axman6> I don't see the sense in doing that
00:20:45 <Cale> frerich: Coq
00:20:46 <mauke> how mainstream are the MLs?
00:20:51 <mjrosenb> mauke: or that.  that is *much* shorter.
00:20:52 <arkeet> how mainstream is scala?
00:20:56 <mauke> sml, ocaml, f#
00:20:56 <Cale> so mainstream
00:21:13 <Cale> But yeah, pretty much anything from the ML family
00:21:18 <srid> does anyone use spacemacs here, with an usable indentation behaviour? 
00:21:22 <srid> i would like to see your config
00:21:25 <srid> cf. https://github.com/syl20bnr/spacemacs/tree/master/contrib/lang/haskell#install
00:21:26 <frerich> Ok, I don't have a good definition of mainstream except "Can be sold to a team of 16 people who are mostly used to C++/Java"
00:21:29 <mauke> arkeet: yeah, I grinned when I saw swift's "enums"
00:21:30 <srid> nothing works for me :/
00:21:46 <mjrosenb> frerich: rust.
00:22:06 <frerich> Ah, Rust can up here as well... I didn't realize it had nice sum types, let me read up on that!
00:22:06 <arkeet> I was going to mention rust but I didn't think that would count as mainstream.
00:22:12 <arkeet> well then
00:22:30 * frerich regrets having used the bloat word 'mainstream' :-]
00:22:53 <mjrosenb> speaking of ML, does haskell have any equivalent of 'local'?
00:23:05 <arkeet> what is 'local'? (I don't know ML)
00:23:23 <Axman6> from the starting point swift started at ("We need a language which is better than Obj-C but is also completely compatible with Obj-C"), I think Apple have done an excellent job. it's far from perfect (it's not even Haskell), but still a huge leap from Obj-C
00:23:45 <arkeet> yeah it seemed fairly nice from what I read about it.
00:23:56 <mjrosenb> local DECLLIST in DECLLIST end
00:24:13 <KaneTW> > let a = 1 in a
00:24:14 <mjrosenb> it is like let DECLLIST in EXPR end
00:24:14 <lambdabot>  1
00:24:20 <Axman6> and it seems the bugs and warts are being worked out pretty quickly
00:24:20 <arkeet> mjrosenb: not really.
00:24:33 <arkeet> there are where clauses, but those can only attach to one declaration.
00:24:38 <mjrosenb> but you can declare multiple things
00:24:41 <Axman6> mjrosenb: that seems redundant to me
00:25:24 <mjrosenb> Axman6: if you want to have a helper function or type shared between two declaraions, and not pollute the namespace?
00:25:25 <arkeet> probably you'd just write some top-level things and not export them.
00:26:06 <Axman6> Ah I see. seems like it's a rare enough situation, particularly with module export lists, for it not to be necessary
00:27:52 <mjrosenb> you can also change the fixity of a variable locally
00:28:01 <mjrosenb> c.c really don't do that though.
00:28:43 <shachaf> You have to declare it, you can't only change the fixity.
00:29:42 <mauke> > let infixr 1 -; (-) = (Prelude.-) in 2 - 3 - 5
00:29:43 <lambdabot>  4
00:30:26 <mjrosenb> this still seems like a spectacularly bad idea :-)
00:30:57 <mauke> mjrosenb: (x, y, z) = let DECLLIST in let x = ...; y = ...; z = ... in (x, y, z)
00:31:05 <mauke> (workaround)
00:32:20 <mjrosenb> mauke: that is quite the hammer.
00:33:10 <mauke> the only annoying bit is the repeated (x, y, z) at the beginning and end
00:33:24 <mauke> the rest should be identical
00:37:14 <mjrosenb> if I have a change for pqueue, should I just email the author/maintainer?
00:46:11 <mjrosenb> can I use hiding inside of a constructor in an import?
00:47:54 <mjrosenb> e.g. import Data.Foldable (Foldable(..) hiding null)
00:51:46 <shachaf> No.
00:52:15 <shachaf> In GHC 7.10 null is the one from Foldable.
00:52:19 <mjrosenb> :-(
00:52:23 <mjrosenb> yup.
00:52:33 <mjrosenb> pqueue no longer builds because of this
00:52:56 <mjrosenb> most instances, I can simply add null to the hiding list
00:53:21 <mjrosenb> except there, where it gets included implicitly from the .. in Foldable
00:57:03 <mjrosenb> a let statement in a do block doesn't have a requited in, right?
00:57:18 <mjrosenb> err, expression?
00:57:29 <shachaf> A let statement doesn't require "in". A let expression does.
00:57:43 <mjrosenb> let is normally an expression, but in a do block, it is not always an expression
00:58:35 <shachaf> do { let { ... }; ... } means let { ...} in do { ... }
00:58:37 <mjrosenb> ok, it is telling me that the in is required
00:58:55 <mjrosenb> I think I'm messing up my indentation here.
00:59:11 <mauke> be aware that both 'do' and 'let' trigger layout
00:59:28 <mauke> (if you paste your code, we can tell you more)
00:59:36 <mjrosenb> mauke: the let was working before I added the where.
01:00:05 <mauke> <morpheus> show me
01:00:33 <mjrosenb> https://gist.github.com/e139107a0c1aa7d72135
01:01:14 <mauke> 'where data'? is that legal?
01:01:14 <mjrosenb> ooh, in X, copying from emacs de-prettifies the text
01:01:33 <mauke> 'data buttonState' would be a syntax error in any case, though
01:02:25 <shachaf> You can't declare types locally.
01:02:35 <mauke> > let { foo = bar where { bar = () } } in foo
01:02:37 <lambdabot>  ()
01:02:43 <mjrosenb> gah, I can't make a new datatype local to a single expression?
01:02:44 <mauke> > let { foo = bar where { data T = T; bar = () } } in foo
01:02:45 <lambdabot>  <hint>:1:25: parse error on input â€˜dataâ€™
01:03:08 <shachaf> You can only declare types on the module level. Sorry.
01:03:19 <mauke> > let foo = bar where data T = T; bar = () in foo
01:03:21 <lambdabot>  <hint>:1:1: parse error in let binding: missing required 'in'
01:03:25 <mauke> interesting
01:03:47 <mauke> I get why that happens, but why does it also happen in a 'do' block?
01:04:03 <mjrosenb> it isn't complaining about it in the  let, which isn't the module level?
01:04:32 <mauke> my last line is parsed as 'let { foo = bar where {} } data ...'
01:04:51 <mauke> because clearly the 'data' can't be part of the where block, so it gets an implicit empty where block
01:05:03 <mauke> and then 'data' is invalid because it's expecting an 'in'
01:07:28 <mauke> ah, because it sees that there is no ';' so the current statement isn't done yet
01:07:45 <mauke> so it must be a 'let X = Y in Z' statement
01:07:51 <mauke> only with a missing 'in'
01:07:54 <arkeet> also the name of the data type has to start with a capital letter.
01:08:36 <mauke> vim++  " surprisingly painless refactoring of filetype specific config
01:09:43 <mauke> (:source <sfile>:h/blah is my new friend)
01:31:37 <mjrosenb> ugh, I'm back to a mysterious missing 'in'
01:31:51 <arkeet> code/error again?
01:32:13 <shachaf> arkeet wants to play on easy mode.
01:32:41 <arkeet> this isn't the kind of thing where I look for challenge.
01:33:25 <mjrosenb> https://gist.github.com/cff53ce0360c03c81c81
01:33:31 <mjrosenb> there, that is everything this time
01:33:53 <mjrosenb> I even removed the where because they always seem to trip me up.
01:34:55 <arkeet> so what's the error message
01:35:12 <mjrosenb> src/test.hs:50:9: parse error in let binding: missing required 'in'
01:35:19 <arkeet> what's line 50
01:35:24 <mjrosenb>  let mousePosX :: Behavior t CInt
01:37:07 * mjrosenb has now fixed 3 errors without changing the error message
01:37:24 <arkeet> I don't get that error message.
01:37:31 <arkeet> I just get a complaint about the data .
01:37:37 <arkeet> is this the right paste?
01:38:07 <mjrosenb> yes.
01:38:27 <arkeet> test.hs:55:13: parse error on input `data'
01:38:29 <arkeet> that's all I get.
01:38:45 <arkeet> I don't see anything wrong with the let mousePosX line.
01:38:51 <arkeet> or anything nearby.
01:39:08 <joneshf-laptop> is there a more elegant way to rotate the head of a list to the end than `uncurry (++) . swap . splitAt 1`?
01:39:24 <joneshf-laptop> maybe something simple i'm not seeing
01:39:50 <arkeet> joneshf-laptop: I can't imagine you could do much better than that.
01:40:14 <aidecoe> hm, standard Data.Set doesn't have functor instance?
01:40:21 <merijn> mjrosenb: Are there tabs/spaces being mixed by any chance?
01:40:22 <arkeet> nope, because of the Ord constraint on the element type.
01:40:26 <merijn> aidecoe: It can't have one
01:40:37 <arkeet> oh yeah.
01:40:47 <merijn> aidecoe: Set uses an ordered tree for lookups, which relies on the ordering of the elements
01:40:55 <arkeet> there aren't any tabs in the gist but maybe xcut from a terminal would convert tabs to spaces.
01:41:00 <arkeet> mjrosenb: check for tabs.
01:41:02 <{AS}> https://hackage.haskell.org/package/set-monad-0.2.0.0/docs/Data-Set-Monad.html has one though
01:41:12 <merijn> aidecoe: Functor can't guarantee that the resulting type after fmap has an Ord constraint
01:41:38 <mjrosenb> https://gist.github.com/0f226a406b8ee732400b ... the errors that I found got fixed.
01:41:40 <aidecoe> merijn: ah, indeed
01:41:52 <Cale> It's possible to make a Set type which has a Functor instance, but you just defer the computation, so it's no better than just converting your sets to lists and then converting back at the end.
01:42:03 <aidecoe> sad but trueâ€¦
01:42:12 <arkeet> mjrosenb: at this point I'm thinking its tabs.
01:42:35 <Cale> (similarly for Monad)
01:42:35 <arkeet> try grep -n $'\t' test.hs
01:42:59 <mjrosenb> hexdump src/test.hs  | grep \ 09
01:43:04 <arkeet> or that heh
01:43:09 <mjrosenb> doesn't print anything
01:43:17 <arkeet> okay, that's weird then.
01:43:45 <arkeet> because I don't get that error.
01:44:09 <mjrosenb> arkeet: what version of ghc are you using?
01:44:14 <arkeet> 7.8.3
01:44:25 <arkeet> in fact now I get no parse errors.
01:44:28 <arkeet> with that last one.
01:44:36 * mjrosenb is using 7.10.1
01:44:48 <arkeet> I doubt it makes a difference.
01:44:53 <arkeet> 7.10.1 has -fwarn-tabs on by default anyway I guess
01:45:58 <arkeet> I have no clue.
01:46:06 * mjrosenb has his tab key configured to never actually emit a tab character
01:46:19 <arkeet> how do you indent?
01:46:47 <kaidelong> it's the same rule used by the ML languages, the basic rule is really simple
01:47:07 <arkeet> ?
01:47:12 <mjrosenb> ;0x09 sucks
01:47:13 <mjrosenb> (setq-default indent-tabs-mode nil)
01:47:15 <kaidelong> you cannot have something less indented than something that comes before it
01:47:20 <mjrosenb> e.g. it inserts spaces.
01:47:26 <arkeet> kaidelong: oh you just joined. that question was part of a larger conversation.
01:47:29 <arkeet> not a general question.
01:47:38 <kaidelong> ah, sorry
01:47:43 <mjrosenb> kaidelong: ml doesn't have tab based parsing, does it?
01:48:05 <kaidelong> mjrosenb: I don't know if the original ML did, but I think a lot of modern ones are indent sensitive
01:48:14 <kaidelong> SML/NJ and F# both are, at least
01:48:27 <kaidelong> the "offside rule" predates Haskell
01:48:48 * mjrosenb is at least 50% certain that sml/nj doesn't do that at all.
01:48:48 <arkeet> mjrosenb: well, I have no idea why you get a parse error and I don't.
01:48:55 <mjrosenb> :-(
01:48:57 <arkeet> :(
01:49:00 * mjrosenb is so confused.
01:49:12 <arkeet> what if you just try to like
01:49:14 <arkeet> ghci src/test.hs
01:49:28 <kaidelong> mjrosenb: I haven't used SML/NJ in a while. Did it need semicolons sprinkled everywhere?
01:49:33 <kaidelong> I might be misremembering
01:49:54 <mjrosenb> arkeet: that dies with ~30 missing imports.
01:49:59 <arkeet> but no parse error.
01:50:27 <arkeet> hmm.
01:50:31 <mjrosenb> Failed, modules loaded: none.
01:50:37 <arkeet> does it try to import before parsing.
01:50:45 <mjrosenb> does it even bother parsing if the imports fail?
01:50:50 <arkeet> that's what I'm wondering.
01:50:51 <arkeet> I thought it did.
01:51:12 <arkeet> it seems like it doesn't.
01:51:34 <f|`-`|f> what would you do for a free bitraversable
01:51:53 <mjrosenb> Assuming let case in where x = = = = 5 <- do
01:51:54 <arkeet> ok, if I remove all the imports, I still get a parse error on line 48
01:52:04 <arkeet> but none on 43
01:52:07 <mjrosenb> is not a valid sequence of tokens, it doesn't bother parsing.
01:52:25 <mjrosenb> arkeet: I removed a bunch of lines.  I can paste the new file.
01:52:40 <mjrosenb> wait, which line is now 48 for you?
01:52:45 <arkeet> the data ButtonState = ..
01:53:00 <arkeet> because types must be declared at the top level.
01:53:34 <arkeet> I remove that line and it parses fine.
01:53:49 <arkeet> (just a bunch of "not in scope" errors because I removed all the imports.)
01:55:41 <mjrosenb> ... did this not parse before, when I tried it, and declared that it worked?
01:55:59 <arkeet> ???
01:57:02 <mjrosenb> about 50 minutes ago, I declared that it wasn't complaining about the data in the let statement.
01:57:07 <arkeet> oh.
01:57:17 <arkeet> well
01:57:22 <arkeet> that's because it complained about something else instead first.l
01:57:29 <arkeet> I guess.
01:57:33 <mjrosenb> ok, so haskell doesn't actually have an equicavalent to local.
01:57:37 <arkeet> it doesn't.
01:57:42 <arkeet> just put your things at the top level.
01:57:51 <mjrosenb> this is going to make my life very very painful.
01:58:22 <arkeet> you can just move the data declaration to the top level.
01:58:23 <arkeet> the rest is fine.
01:58:27 <jstolarek> I'm reading OutsideIn paper about GHC's type inference and it uses # to denote some sort of relation but it doesn't explain what that relation is. Any ideas what can it be? Example usage from the paper: dom(\sigma)#fuv(Q_g,Q_r)
01:58:59 <mjrosenb> arkeet: yes, but this is only test.hs
01:59:09 <arkeet> so?
01:59:20 <mjrosenb> I'm going to need a data declaration per button for every button in the entire UI
01:59:28 <arkeet> you are?
01:59:34 <mjrosenb> yup.
01:59:51 <arkeet> by data declaration I meant the line: data ButtonState = Up | Down
02:00:03 <arkeet> you are free to define btn in a let statement.
02:00:23 <mjrosenb> which is why I *really* want that to be local to the declaration of the actual definition of the button (in this case btn)
02:00:41 <arkeet> every button in the UI has a different type of button states?
02:01:18 <mjrosenb> arkeet: yeah.
02:01:24 <mjrosenb> most buttons do different things.
02:02:25 <arkeet> of course.
02:02:29 <arkeet> but most buttons are also either up or down.
02:02:44 <arkeet> maybe I'm misinterpreting ButtonState.
02:03:06 <mjrosenb> that is a dummy
02:03:23 <mjrosenb> it will move the button up and down on the screen when you click on it.
02:03:31 <arkeet> I see.
02:03:57 <arkeet> well, the fact remains that you can't define data types locally.
02:04:40 <mjrosenb> and there isn't some Language feature I can turn on?
02:04:43 <arkeet> no.
02:06:43 <mjrosenb> bummer.
02:07:48 <arkeet> jstolarek: this paper? http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/jfp-outsidein.pdf
02:08:03 <arkeet> I have a feeling they meant to write \neq
02:08:46 <arkeet> or maybe not.
02:08:48 <arkeet> I don't know.
02:08:49 <hexagoxel> arkeet: what about an associated data type for some button typeclass?
02:09:06 <arkeet> hexagoxel: ah yes, there is that.
02:09:10 <arkeet> but then you need to write an instance for each one.
02:09:21 <hexagoxel> type classes may be overused, but this is not haskell-beginners :p
02:09:35 <arkeet> so I don't see the improvement.
02:09:44 <f|`-`|f>  /wrists
02:10:13 <hexagoxel> it seems that mjrosenb _wanted_ a different data type for each one..
02:10:18 <arkeet> right.
02:10:31 <arkeet> but if you have an associated data type in a class,
02:10:45 <arkeet> you can only have as many instances for that type as instances of the class.
02:11:04 <arkeet> so you have to define a type to make it an instance of the class ...
02:11:13 <arkeet> (or steal an existing one...)
02:11:30 <arkeet> (stealing is bad)
02:12:24 <arkeet> I don't know why one should need to define a new type for each possible behaviour of a button anyway.
02:12:32 <arkeet> can't do it with just a function or something?
02:13:00 <arkeet> anyway it's past 2am and I ought to be asleep. bye
02:14:39 * hackagebot yesod 1.4.1.5 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.4.1.5 (MichaelSnoyman)
02:14:40 * hackagebot yesod-bin 1.4.7.1 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.7.1 (MichaelSnoyman)
02:15:16 <mjrosenb> oh, wow.  it is after 5.
02:16:03 <arkeet> jstolarek: or actually \notin, considering it looks right in http://research.microsoft.com/en-us/um/people/simonpj/papers/gadt/implication_constraints.pdf
02:16:07 <arkeet> yep bye
02:16:21 <hexagoxel> mjrosenb: so associated data types might provide something in your direction, but with caveats. i am also somewhat doubtful that the resulting design will be good to work with
02:19:07 <f|`-`|f> "Stealing is bad"
02:19:14 <f|`-`|f> "Would you download a car!?"
02:19:24 <bernalex> f|`-`|f: who wouldn't
02:19:40 <aleator> Hi! What is the currently recommeded logging library? I need something lightweight and simple.
02:20:07 * f|`-`|f dials 1-FBI-9999, "Party Van services?"
02:20:15 <bernalex> aleator: what kind of logging? & are you sure some other library your using doesn't do it already? ;)
02:23:47 <jstolarek> arkeet: yes, \notin makes sense. thanks
02:24:39 * hackagebot text-manipulate 0.2.0.1 - Case conversion, word boundary manipulation, and textual subjugation.  http://hackage.haskell.org/package/text-manipulate-0.2.0.1 (BrendanHay)
02:33:06 <aleator> bernalex: Well, I use bytestring and sha so I don't think so. I'm writing an ssh forced command so I'd really like rotated logs on who is using it and how
02:33:53 <NateUni> Any Haskell wizards arounds?
02:33:56 <NateUni> *around?
02:34:29 <mauke> NateUni: dude, you can't just ask to ask a question. first you have to ask to ask to ask
02:34:40 <NateUni> haha
02:34:54 <NateUni> ok mauke.. I know your a wizard.
02:34:57 <NateUni> ;)
02:35:11 <mauke> I know the difference between "your" and "you are"
02:35:33 <NateUni> shhh let us no worry about grammer for the moment that is the least of my worries
02:35:39 <NateUni> ...
02:35:44 <NateUni> ;)
02:35:57 <bernalex> "grammer" isn't of concern to any of us.
02:36:21 <NateUni> arhg grammar
02:36:34 <NateUni> brb.. 
02:36:34 <bernalex> did you have some sort of question?
02:36:40 <bernalex> lol
02:36:59 <NateUni> back
02:38:52 <NateUni> Yes I have a [Particles] where Particle is (Float, (Float, Float),  (Float, Float)) 
02:39:39 * hackagebot plugins-multistage 0.5.3 - Dynamic linking for embedded DSLs with staged compilation  http://hackage.haskell.org/package/plugins-multistage-0.5.3 (AndersPersson)
02:40:10 <NateUni> I know about about mapping a function across the particle list. But I need to have each particles (Float, Float) effect the others.. 
02:40:46 <NateUni> I know how to get ou tthe (Float, Float)s and I know have to map a function into the list of particles.. but I am confused as there is an extra layer to the problem.
02:41:39 <NateUni> foldr1 is ideal for the (Float, Float) effecting each other part..
02:42:10 * frerich scans for question mark signs...
02:43:19 <NateUni> Well it is hard to ask a question when you are not really sure what you are looking for.. 
02:43:24 * bernalex goes to work
02:43:43 <saulzar> NateUni, Do you need them to interact pairwise?  e.g.  each particle affects each other particle?
02:43:56 <NateUni> Yes
02:44:02 <NateUni> yes
02:44:45 <NateUni> So I need to pass in a function that gets out the (Float, Float) from a particle and then does an operation on that with all the other (Float, Float) from the other particles
02:45:04 <NateUni> and then moves onto the next item in the list and does the same. 
02:45:52 <frerich> NateUni: When you say 'with all the other (Float, Float)' do you mean only the particles coming next in the list, or including the preceding ones?
02:46:36 <NateUni> everyone including itself.
02:46:39 <saulzar> Right, so you probably need something which traverses the lists twice..
02:47:35 <NateUni> so a with a, a with b, a with c, a with d, then b with a, b with a, b with b etc
02:47:57 <NateUni> so a with a, a with b, a with c, a with d, then b with a, b with b etc
02:48:01 <tomjaguarpaw> Is there are package that wraps IORef and/or STRef to provide `ConstantIORef` and/or `ConstantSTRef` that cannot be overwritten once created?  I want them for observable sharing.
02:48:27 <saulzar> e.g:  map (\p -> foldr1 f particles) particles 
02:49:59 <NateUni> whats the f here?
02:50:08 <NateUni> are the other funct
02:50:13 <saulzar> Some kind of accumulation function e.g.
02:50:19 <NateUni> ok.. 
02:50:23 <NateUni> let me think about it
02:50:30 <saulzar> Particle -> Particle -> Particle
02:51:00 <frerich> NateUni: When you say ' then does an operation on that with all the other (Float, Float) from the other particles', what's the result of that operation: a new list with 'transformed' particiles? Or a single particle? Or something else?
02:51:01 <saulzar> So the outer map transforms the particle list, then the inner foldr1 accumulates something across the other particles
02:51:52 <saulzar> Or probably more like this:
02:52:43 <saulzar> e.g:  map (\p -> foldr1 (f p) particles (0, 0)) particles ...  and f :: Particle -> Particle -> r-> r
02:53:15 <saulzar> Where r is some kind of accumulation thingey (e.g. force or difference)
02:53:24 <NateUni> I find functional programming soooooo difficult. I still dont think functionally.
02:53:40 <dserban> Are QuickCheck-related questions welcome here?
02:53:53 <NateUni> let me come back in a second
02:53:56 <tomjaguarpaw> dserban: Yes
02:53:56 <saulzar> dserban, Yeah.. anything Haskelly..
02:54:00 <NateUni> I will go look at the issue
02:54:17 <saulzar> NateUni, You'll get used to it - at first it seems really bewildering 
02:54:53 <dserban> my question is how to sistematically go about coming up with ideas for QuickCheck? It seems like more of an art form
02:55:05 <dserban> I mean QC properties
02:55:52 <dserban> how to extract the abstract essence of an algorithm
02:56:03 <dserban> and write a property for it
02:56:28 <tomjaguarpaw> Well, what should your algorithm do?
02:56:55 <dserban> take for instance the pure function that does the swipeLeft in the 2048 game
02:57:14 <tomjaguarpaw> OK
02:57:32 <tomjaguarpaw> Can you think of a property that the output of that function satisfies?
02:57:57 <dserban> yes, it's that empty cells are all on the right-hand side
02:58:08 <tomjaguarpaw> Right, so that's one property.
02:58:10 <dserban> and there is a clean separation
02:58:11 <tomjaguarpaw> Can you think of another?
02:58:41 <dserban> yes, it's that the number of empty cells always goes up, but never down
02:59:08 <tomjaguarpaw> Great.  Your understanding of the process seems sound.
02:59:27 <dserban> but the testing isn't very rigorous
02:59:32 <tomjaguarpaw> In what sense?
03:00:28 <dserban> in the sense that the few properties I can come up with don't necessarily guarantee the correctness, they only make sure it is more likely the function is correct
03:00:49 <dserban> but the sure-fire guarantee isn't there
03:00:50 <flux> testing only increases your confidentiality on the algorithm, it doesn't prove it :)
03:00:53 <tomjaguarpaw> Right, I agree.  It sounds like you are looking for the *defining* propety.
03:00:57 <merijn> dserban: Guaranteeing correctness requires you to prove correctness
03:01:02 <dserban> yes
03:01:02 <frerich> dserban: Testing never guarantees correctness. It doesn't prove the absence of bugs, it only proves their presence.
03:01:23 <tomjaguarpaw> Let's not get ahead of ourselves.  We're just talking about properties, not about how to verify them.
03:01:45 <dserban> so in my example, what would be the defining one?
03:01:57 <tomjaguarpaw> Well, this is a good question!
03:02:22 <tomjaguarpaw> In some sense "the defining one" is the same thing as "the rules of the game"
03:02:39 <dserban> ok, I see
03:02:43 <tomjaguarpaw> I guess the most important quality of a defining property is that it defines a unique thing.
03:02:55 <NateUni> saulzar is an understatement 
03:03:14 <tomjaguarpaw> That is there is some behaviour that satisfies it, and there is *no more than* one behaviour that satisfies it.
03:03:24 <NateUni> the term â€˜ really bewilderingâ€™
03:03:49 <NateUni> Need a few swear words thrown into to help explain my situation 
03:05:16 <frerich> NateUni: One thing I didn't understand about your task: when you say that you want to do an operation on some particle and all the others in the list - what's the result of that operation? A new list of 'transformed' particles?
03:08:13 <NateUni> if I have a list have a list that I am changing .. how do I retain a copy of it in its original state in a function? 
03:09:33 <tomjaguarpaw> NateUni: You can't change a list.  When you try to "change" it you get back a new one.
03:11:00 <NateUni> yeah but if I have state A.. and I want to pass in a function that gets that state of all particles in the list and thir pull on each other I want to retain it is its original state .. 
03:11:07 <saulzar> NateUni, Maybe this would be simpler to think about... if you use a list comprehension to combine the pairs, then use something later to add them up
03:11:39 <dserban> NateUni: use a let..in construct
03:11:58 <NateUni> ok off to read..
03:12:00 <saulzar> e.g.   pairs = [ (\p1 p2 ->  something)  |  p1 <- particles, p2 <- particles ] 
03:12:30 <saulzar> then zip them with the original particles
03:13:47 <saulzar> newParticles = zipWith update particles pairs      where update :: Particle -> [Difference] -> Particle 
03:14:54 <NateUni> func :: Float -> [Particle] -> [Particle]
03:14:55 <NateUni> funct t xs = map (\(Particle m p@(px,py) (vx,vy)) -> map (foldr1 (\(a,b) (c,d) -> ((a+c)*t,(b+d)*t))) (getVelocityList xs) ) xs
03:15:34 <NateUni> But I need to make that transformation based on their original state.. 
03:16:46 <tero-> what could be the reason for "setup-Simple-Cabal-1.23.0.0-x86_64-linux-ghc-7.8.3: : does not exist"
03:17:02 <tero-> when running cabal install inside a sandbox
03:19:40 * hackagebot optparse-simple 0.0.1 - Simple interface to optparse-applicative  http://hackage.haskell.org/package/optparse-simple-0.0.1 (ChrisDone)
03:34:40 * hackagebot aeson-better-errors 0.4.0.1 - Better error messages when decoding JSON values.  http://hackage.haskell.org/package/aeson-better-errors-0.4.0.1 (hdgarrood)
03:37:29 <aleator> hslogger vs. fast-logger vs. logging? Any reason to prefer one over another?
03:38:53 <TRManderson> What do people recommend for parsing CSVs?
03:39:03 <TRManderson> I know it's a simple task but I'd rather use a package
03:39:24 <aleator> TRManderson: It isn't simple. If you got pretty standard csv then Cassava (see hackage) is good.
03:39:44 <frerich> TRManderson: Due to the lack of a common standard, parsing CSV data is hideous!
03:39:55 <TRManderson> Agreed on Cassava though?
03:40:03 <hpc> there's a standard, but it's mostly ignored
03:40:04 <rom1504> parsing a specific csv file is one line though
03:40:12 <frerich> hpc: Well that's not a standard then. :)
03:40:30 <aleator> I've used Cassava before and it is good. Except when you get some csv that is not-quite-csv and then I had trouble.
03:40:31 <frerich> hpc: I mean 'standard' as in 'what everyone does', not as in 'what somebody wrote down and then expected everyone to implement'.
03:46:38 <NateUni> :i sum
03:46:50 <NateUni> ops.. wrong place.
03:59:40 * hackagebot bower-json 0.6.0.0 - Read bower.json from Haskell  http://hackage.haskell.org/package/bower-json-0.6.0.0 (hdgarrood)
04:10:12 <saulzar> Hmm. Having an instance issue, I've declared this class for some operation on a Monad stack, made an instance of it for StateT and ReaderT - but for some reason it won't pass through both layers  while the instance is in a different file. Works fine in the same file, no idea why.
04:10:43 <saulzar> (Module is definitely being imported)
04:11:05 <mauke> I don't understand the problem description. what's the error message and what's the code?
04:14:20 <saulzar> I have this:  class Monad m => HasNamespace m where   askNamespace :: m (Maybe String)  localNamespace :: Maybe String -> m a -> m a
04:15:08 <saulzar> It's basically a Reader (or part of a reader)
04:15:56 <saulzar> I'm trying to write the code so I can use it on this stack:  type WidgetInternal t m a = ReaderT WidgetEnv (StateT (WidgetState t m) m) a
04:16:36 <saulzar> So I have instances for  HasNamespace m => HasNamespace (ReaderT  r m)
04:16:45 <saulzar> (and same for StateT)
04:16:56 <mauke> why is your stack not a newtype?
04:17:46 <saulzar> It is, but I'm trying to simplify it here..
04:17:53 <mauke> why?
04:18:26 <saulzar> I mean, so that I can ask the question here more simply :)
04:19:08 <saulzar> It's part of Reflex-Dom, I'm trying to add something in to keep track of the namespace being used (for svg)
04:19:16 <mauke> that'll get you simplified answers
04:19:45 <saulzar> Alright, so I have this newtype... newtype Widget t m a = Widget { unWidget :: WidgetInternal t m a } deriving (Functor, Applicative, Monad, MonadFix, MonadIO)
04:20:01 <saulzar> and then I'm defining my HasNamespace instance on that..
04:20:24 <saulzar> Except - it can't seem to find the StateT instance (unless that StateT instance is in the same file)
04:20:46 <mauke> I don't understand the problem description. what's the error message and what's the code?
04:20:54 <saulzar>   
04:20:54 <saulzar> instance HasNamespace m => HasNamespace (Widget t m) where  askNamespace = lift askNamespace   localNamespace ns w = Widget $ localNamespace ns (unWidget w)
04:20:59 <saulzar> Alright, that's the offending code
04:21:06 <saulzar> in the localNamespace definition
04:21:20 <mauke> blargh, I give up
04:21:51 <saulzar>     Could not deduce (HasNamespace (StateT (WidgetState t m) m))     arising from a use of ‘localNamespace’
04:22:25 <saulzar> But I have the StateT instance, and it compiles if I put it in the same file. Not if it's in the other module.
04:23:24 <pavonia> Do you import two different StateT version by chance?
04:23:36 <saulzar> Ah, that could be it.
04:24:07 <kuribas> When I want to run my tests I get: cabal: The field 'build-depends: mfsolve' refers to a library which is defined within the same package. To use this feature the package must specify at least 'cabal-version: >= 1.8'
04:24:11 <kuribas> Isn't that dumb, since that's the purpose of testing?
04:24:19 <joneshf-laptop> is there some way to clean up this repetition: http://lpaste.net/130865
04:24:27 <joneshf-laptop> the `spaces *>`
04:25:29 <saulzar> pavonia, Yeah, I think that's it. Thanks!
04:25:54 <pavonia> Cool
04:27:28 <i_rony> Yo, everyone!
04:27:38 <i_rony> How come that lambdabot replies on every message in channel?
04:27:48 <mmaruseacph2> it's a bot
04:27:56 <i_rony> Yes, but
04:27:58 <mauke> it doesn't
04:28:04 <i_rony> It should reply only on commands
04:28:06 <i_rony> but
04:28:18 <saulzar> The code imports Strict in one and Lazy in the other. He has another typeclass doing exactly the same thing, but avoids the problem by using lift 
04:28:20 <i_rony> 14:25 < yarr> hey
04:28:37 <i_rony> 14:25 < lambdabot> hiya
04:28:58 <pavonia> i_rony: In what channel does it do that?
04:29:08 <i_rony> another oftc server
04:29:24 <i_rony> pavonia: i assume it's some kind of module, or debug mode
04:29:30 <i_rony> can't figure it out
04:29:34 <mauke> how do you know that user is a lambdabot?
04:29:53 <i_rony> mauke: because on of us launched it
04:30:14 <mauke> how do you know someone isn't playing a prank with @msg?
04:30:28 <mauke> @msg #haskell hiya
04:30:28 <lambdabot> Not enough privileges
04:30:33 <i_rony> mauke: it's unlikely. it responses really fast
04:30:44 <i_rony> mauke: on differenet channels
04:30:54 <i_rony> mauke: i'm almost sure it's some kind of module i cant identifyt
04:31:10 <i_rony> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty  quote search
04:31:20 <i_rony> seen slap source spell system tell ticker todo topic type undo unlambda unmtl url version vixen where
04:31:35 <i_rony> i've tried to @help for each of it
04:31:43 <i_rony> nothing looks like "replying all messages"
04:31:45 <gienah> yarr is a lambdabot command
04:32:42 <i_rony> 14:10 < yarr> wat
04:32:43 <i_rony> 14:10 < lambdabot> nothin
04:32:59 <i_rony> i know, but it should be with @ 
04:33:01 <i_rony> @yarr
04:33:01 <lambdabot> Smartly me lass
04:33:26 <yarr> wat
04:33:57 <i_rony> okay. 
04:34:06 <i_rony> it was 'vixen' module
04:34:13 <i_rony> issue resolved :)
04:34:40 <i_rony> thanks all
04:35:12 <i_rony> seems like vixen module is kinda broken.
04:48:32 <NateUni> How can I achieve this: ((foldr1 (\(x1,_) (x2,_) -> (x1+x2)) xs), (foldr1 (\(_,y1) (_,y2) -> (y1+y2)) xs)
04:48:35 <NateUni> with the _
04:49:34 <KaneTW> what do you mean
04:49:52 <NateUni> I I mean I donâ€™t care about the _ it wont complile
04:49:58 <NateUni> *compile
04:50:17 <chpatrick> what are you trying to do?
04:50:19 <NateUni> Couldn't match expected type â€˜Floatâ€™ with actual type â€˜(Float, t0)â€™
04:50:19 <NateUni>     In the pattern: (x1, _)
04:50:40 <KaneTW> what does the error say?
04:50:49 <NateUni> I just want to go through a list of (xy pairs and sum all the components )
04:51:07 <NateUni> Error: Couldn't match expected type â€˜Floatâ€™ with actual type â€˜(Float, t0)â€™
04:51:08 <NateUni>     In the pattern: (x1, _)
04:51:09 <NateUni>     In the first argument of 
04:51:13 <chpatrick> why are you doing it with a foldr?
04:51:39 <benzrf> NateUni: thats the wrong type for a foldr im pretty sure
04:51:44 <NateUni> ok.
04:51:47 <KaneTW> NateUni: i mean what do you think the error says? also, don't paste long stuff in this channel
04:51:48 <benzrf> :t foldr1 (\(x1,_) (x2,_) -> (x1+x2))
04:51:49 <lambdabot>     Occurs check: cannot construct the infinite type: t1 ~ (t1, t2)
04:51:49 <lambdabot>     Relevant bindings include
04:51:49 <lambdabot>       x2 :: t1 (bound at <interactive>:1:19)
04:51:54 <benzrf> NateUni: ^
04:51:55 <NateUni> hmm ok.. 
04:51:58 <benzrf> :t foldr1
04:51:59 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
04:52:08 <benzrf> replace the t a with a [a] in your head
04:52:53 <NateUni> ok
04:53:26 <chpatrick> NateUni: think if you could build this operation out of two others
04:53:53 <pavonia> Is that only in lamdabot of is the version with Foldable in the Prelude now too?
04:54:13 <pavonia> *or is
04:54:22 <chpatrick> it is since 7.10
05:12:18 <joehh1> I'm learning to use STM and seem to be getting <<loop>> in my output
05:12:33 <joehh1> Does this mean an infinite loop has been detected?
05:12:49 <KaneTW> no, that'd be a pretty cool feature
05:12:53 <joehh1> it only occurs when using -threaded
05:12:55 <KaneTW> that's an infinite data structure
05:12:57 <nomeata> Iâ€™m confused. If I compile the module "main = return ()" with ghc -c, why does it get type "main :: IO ()"? I did not specify the monad there. Is that normal?
05:14:46 <chpatrick> IO is the only thing you can run :)
05:15:08 <joehh1> an infinte data structure? Not sure I can see where it is occuring?
05:15:10 <joehh1> http://paste.debian.net/167286/
05:15:13 <KaneTW> nah not quite
05:15:14 <KaneTW> i was wrong
05:15:22 <merijn> nomeata: The report specifies that main *must* have a type that unifies with 'IO a'
05:15:42 <KaneTW> that is an infinite loop, but one that happens when you need to evaluate a constructor to evaluate a constructor
05:15:51 <merijn> nomeata: So logically given "return ()" main :: IO () is the only possible option
05:15:56 <ion> Wouldnâ€™t Monad m => m () still unify with IO a?
05:16:16 <merijn> ion: It would, but the resut would be "IO ()"
05:16:18 <nomeata> merijn: indeeD; if I add "module Foo where" to the file, it complains about an ambiguous type variable
05:16:42 <nomeata> so GHC treats a module without a module name (or the name "Main") special here
05:16:47 <joehh1> :) ahahah
05:16:52 <joehh1> thanks for that
05:16:53 <ion> nomeata: With NoMonomorphismRestriction?
05:16:55 <merijn> nomeata: Modules without names are assumed to be Main, yes
05:16:58 <merijn> Anyway, time to go
05:17:14 <joehh1> adding $ after the forever meant the right part was repeated
05:17:27 <joehh1> KaneTW: thanks very much for your help, much appreciated
05:17:31 <nomeata> ion: with the restriction. without it compiles to "Monad m => m ()"
05:17:34 <KaneTW> np
05:17:40 <KaneTW> > let x = x + 1 in x
05:17:44 <lambdabot>  mueval-core: Time limit exceeded
05:17:49 <KaneTW> aww
05:18:00 <KaneTW> it should output *** Exception: <<loop>>
05:18:06 <KaneTW> but i guess it needs more time for that
05:19:30 <phaazon> hm
05:19:39 <phaazon> PartialTypeSignatures sounds pretty neat
05:19:55 <phaazon> though, does GHC warn what they're used?
05:19:57 <phaazon> I think it should
05:22:59 <mpickering> phaazon: yes
05:23:05 <bennofs> phaazon: you need to enable an extension I think
05:23:27 <mpickering> You can use them liked typed holes without an extension 
05:23:39 <bennofs> ah I see
05:23:42 <mpickering> or turn on the extension but get a warning when they are used
05:23:53 <mpickering> or turn on the extension and surpress the warning
05:24:30 <phaazon> bennofs: yeah
05:24:51 <phaazon> I think they're some kind of dangerous
05:24:57 <bennofs> phaazon: why?
05:25:05 <phaazon> I wouldn't allow my code to compile without a warning if type signatures are not complete
05:25:15 <phaazon> weren't*
05:34:31 <NateUni> Can someone throw an eye on this:
05:35:10 <NateUni> I have a function that is getting some points adding themâ€¦ scaling them and then adding them to the original value
05:35:18 <NateUni> let vList = [(1,1),(2,2),(3,3)]
05:35:24 <NateUni> sumScaleAdd 3 (1,1) vList
05:35:29 <NateUni> (19.0,19.0)
05:36:20 <NateUni> I also have a a function that maps the force of a list of vectors onto a vector:
05:36:29 <NateUni> map (force p1) pList
05:36:35 <NateUni> [(0.0,0.0),(-2.3597143e-11,-2.3597143e-11),(-5.899286e-12,-5.899286e-12)]
05:36:41 <NateUni> But.. 
05:37:44 <NateUni> when I: ScaleAdd 1 (-10,-10) (map (force p1) pList)
05:37:45 <NateUni> (-10.0,-10.0)
05:38:00 <NateUni> I get back the same value
05:39:28 <bennofs> > 10 - 2.3*10**(-11) :: Float
05:39:30 <lambdabot>  10.0
05:39:34 <bennofs> So this is your problem?
05:40:16 <NateUni> I just found that: (-10.000000000029496,-10.000000000029496)
05:40:32 <NateUni> So there is a rounding issue with the float
05:41:00 <bennofs> > 10 - 2.3*10**(-11) :: Double -- but just raises the bound at which there will be rounding
05:41:02 <lambdabot>  9.999999999977
05:41:02 <NateUni> But it is supposed to be a float.. so maybe it is not that my logic is crappy but that my test values are too small
05:42:18 <NateUni> ok.. so its not so bad after all
05:42:39 <bennofs> > 10 - 2.3**(-16) :: Double
05:42:41 <lambdabot>  9.99999836937302
05:42:48 <bennofs> > 10 - 2.3*10**(-16) :: Double
05:42:50 <lambdabot>  10.0
05:42:53 <NateUni> Jesus haskell is a mind bender at first
05:43:36 <bennofs> NateUni: floating point math is not exact, so there will always be rounding errors
05:44:39 <NateUni> yeah i didnt factor that in.. I was thinking that my logic was not sound. 
05:44:56 <bennofs> NateUni: the Rational type is exact afaik
05:45:09 <bennofs> > 10 - 2.3*10^^(-30) :: Rational
05:45:11 <lambdabot>  99999999999999999999999999999977 % 10000000000000000000000000000000
05:45:12 <NateUni> The whole currying thing sucks at first but then it is pretty cool once you start to get the gist
05:45:47 <FireFly> It makes the code a lot more clear sometimes (but not always)
05:46:31 <NateUni> Well it def makes it more compact
05:53:47 <sbidin> A travis-ci build ran fine until I started using TemplateHaskell. Now it gives me a "can't find shared object file" error, while everything still works fine locally. Anyone had a similar issue? http://is.gd/FJp5cd (line 1488)
05:53:48 <sbidin>  
05:54:37 <Lis> is spacectrl official? it does ctcp version
05:55:17 <bennofs> sbidin: is SDL2 installed on the CI system?
05:56:02 <sbidin> bennofs: Yes. Everything was fine before I started using TemplateHaskell. No new dependencies were added.
05:56:27 <sbidin> I use TH to generate foreign imports from SDL2.
05:56:44 <sbidin> (They were hand-written before.)
05:57:25 <Lis> ah sorry was wrong channel.
05:57:43 <Lis> however http://lpaste.net/130866 gives me an error on line 87 can someone help me with that problem?
05:58:21 <bennofs> sbidin: hmm, then idk. The error seems like when executing the TH, ghc needs to load haskell code (since it is doing TH) and fails because it cannot find libSDL2-2.0.so.0
06:00:36 <NateUni> Guys best way to sum up x,y pairs in a list.. I am summing up after using map to get only the x and the y values independently. 
06:00:53 <NateUni> But there surely is a nicer way
06:02:06 <sbidin> NateUni: You mean something like map (uncurry (+))?
06:02:07 <opqdonut> > liftM2 (+) [1,2,3] [1,10,100] -- NateUni: like this?
06:02:08 <lambdabot>  [2,11,101,3,12,102,4,13,103]
06:02:10 <bergey> Lis: `main = toFile .. do` on L86 introduces a do-block in a monad defined by Chart.  parseCSVFile returns IO (stuff), not ChartMonad (stuff).
06:03:08 <NateUni> no it would be [(x,y)]  
06:03:13 <sbidin> > map (uncurry (+)) [(1,2),(5,7)]
06:03:14 <lambdabot>  [3,12]
06:03:16 <Lis> bergey, yes, but how can i change the code to fix this error. i am new to haskell and don't understand it fully yet. I don't actually know where to insert the expression
06:03:22 <lexir> :t undefined
06:03:23 <lambdabot> t
06:03:31 <NateUni> hmm unzip looks good right
06:03:43 <lexir> :info undefined
06:04:42 * hackagebot mfsolve 0.1.0 - Equation solver and calculator à la metafont  http://hackage.haskell.org/package/mfsolve-0.1.0 (KristofBastiaensen)
06:04:51 <osfameron> > foldl1 (\(a,b) (a',b') -> (a+a', b+b')) [ (1,1), (2,3) ]
06:04:52 <lambdabot>  (3,4)
06:05:08 <chpatrick> I would write a function to add vectors
06:05:09 <luzie> can i see lambdabot's current L.hs somehow?
06:05:16 <chpatrick> maybe even give them their own data type and add a Num instance
06:05:26 <NateUni> they havce one already
06:05:26 <chpatrick> then it's just sum
06:05:30 <sbidin> bennofs: Yes. The CI system is lacking something I have locally I guess. Maybe a envvar or a cabal flag or something... 
06:05:31 <osfameron> yeah
06:05:41 <chpatrick> then sum?
06:06:09 <NateUni> let me try
06:06:24 <bergey> Lis: how about https://gist.github.com/fa049fd428ac19658579
06:06:36 <Lis> bergey, http://lpaste.net/130866 fixed it :D
06:06:39 <NateUni> no but sum wont work with [(1,2),(3,4),(5,6)]
06:06:40 <NateUni> will it?
06:06:44 <bergey> Read the CSV in IO, then construct the graph with the read value.
06:06:48 <chpatrick> why not?
06:06:52 <frerich> NateUni: Can you give the type of the function you're looking for? When you're saying that you want to sum up x,y pairs, it's not clear whether you want '[(Int, Int)] -> Int' or '[Int] -> Int' (and in the latter case, [a,b,c,d] is turned into [a+b, c+d])?
06:07:03 <bergey> Lis: Yep, just like that. =)
06:07:05 <Lis> bergey, yea i just tried that and it worked. thank you i had the same solution. haskell rocks :D
06:07:06 <chpatrick> you just need Num a => instance Num ( a, a ) where
06:07:24 <Lis> bergey, slowly i start to understand the logic behind it
06:07:40 <chpatrick> the only problem is that a lot of Num stuff doesn't really make sense for vectors since it's not granular enough
06:07:59 <chpatrick> @hackage vector-space
06:07:59 <lambdabot> http://hackage.haskell.org/package/vector-space
06:08:13 <mniip> is 'case âŠ¥ of (# _, _ #) -> ()' âŠ¥ or ()
06:08:45 <chpatrick> mniip: unboxed types can't be bottom can they?
06:08:49 <lexir> Do we ever plan on having GHC extensions entered into GHC so that we don't have to add extentions to the top of our source files?
06:09:09 <chpatrick> so it would be stack overflow
06:09:11 <voidzero> huh, like -XOverloadedStrings ?
06:09:17 <voidzero> already works, doesn't it?
06:09:27 <chpatrick> or infinite loop rather
06:09:37 <NateUni> chpatrick ??  vectors since it's not granular enough?
06:09:42 * hackagebot cabin 0.1.0.3 - Cabal binary sandboxes.  http://hackage.haskell.org/package/cabin-0.1.0.3 (nclarke)
06:10:07 <lexir> voidzero: Yes like overloaded strings or the new partial type signatures I just discovered.
06:10:21 <chpatrick> NateUni: Num defines a bunch of operations and some don't make sense for vectors, like signum
06:10:30 <lexir> Basically why do we prefer to keep things as GHC extenstions and not part of GHC?
06:10:48 <chpatrick> I mean you could invent them but they're not really well defined mathematically speaking afaik
06:11:46 <chpatrick> vector-space has smaller classes for addition, etc
06:14:52 <Lis> how can i shift a list to right?
06:15:24 <Lis> like i have [1,2,3] and want to remove the first element [2,3]
06:15:26 <tromp> :t (:)
06:15:27 <lambdabot> a -> [a] -> [a]
06:15:29 <Saulzar> Lis, tail
06:15:35 <Lis> ah thank yiz
06:16:05 <bergey> lexir: Because there is a Haskell standard, and other Haskell compilers.
06:16:05 <ion> > tail []  -- note
06:16:07 <lambdabot>  *Exception: Prelude.tail: empty list
06:16:14 <ion> > drop 1 []  -- also
06:16:16 <lambdabot>  []
06:16:19 <bergey> Presumably some extensions will make it into future versions of the standard.
06:16:54 <jerbome> super noob question : how do i get an executable created for a main function inside a module ?
06:16:58 <Lis> and if i want to remove n elements from the start?
06:17:09 <ion> drop n
06:17:11 <bergey> And because it's easier to discuss language changes and portability if we can say "This module is Haskell2010+MultiParameterTypeClasses" than if we say "This is GHC Haskell.  Good luck building with anything else."
06:17:14 <Lis> thank you again
06:17:15 <Saulzar> jerbome, ghc --make MyModule.hs ?
06:17:27 <jerbome> Saulzar, I tried that, no executable created
06:17:44 <frerich> Lis: In general, try to think of the type of the function you're looking for, e.g. if you want to remove n elements fomr a list, then something like 'Int -> [a] -> [a]' would be plausible. You can feed such types to Hoogle.
06:17:50 <frerich> @hoogle Int -> [a] -> [a]
06:17:53 <lambdabot> Prelude drop :: Int -> [a] -> [a]
06:17:53 <lambdabot> Data.List drop :: Int -> [a] -> [a]
06:17:53 <lambdabot> Prelude take :: Int -> [a] -> [a]
06:18:04 <ion> jerbome: Does the file specify a module name? Make it Main.
06:18:09 <Lis> ok, thank you
06:18:09 <Saulzar> jerbome, Suspect it needs to be module Main
06:18:18 <jerbome> ion: do I have to ? I'd like to avoid that
06:18:27 <ion> jerbome: Why would you like to avoid that?
06:18:40 <lexir> bergey: There's a haskell standard? Which ones? Hugs? Pugs?
06:19:02 <jerbome> ion, I find it ugly for what I'm doing
06:19:05 <Saulzar> jerbome, You can always make another module Main and import things from the first..
06:19:06 <bergey> lexir: https://www.haskell.org/onlinereport/haskell2010/
06:19:32 <jerbome> I'm solving project euler problems, and I'd like to be able to reuse my stuff, but still be able to run them from one file
06:19:33 <lexir> bergey: The only haskell compiler people know about is GHC. So if GHC extentions don't work on other compilers people using them must really get frustrated too often.
06:19:49 <kuribas> I wrote an equation solver: https://github.com/kuribas/mfsolve  It takes a list of equations and returns the dependencies.  I wonder if it is better to use a state + error monad for the interface?
06:20:11 <jerbome> Saulzar, thet's what I've been doing until now, but it's a (small) hassle to create a new file just for that
06:20:17 <Lis> later
06:21:03 <Saulzar> jerbome, Or just use it from ghci if you want to have a whole lot of them together ... shrug
06:21:06 <bergey> lexir: I think Hugs & UHC are research projects; they probably don't aim to compile most of Hackage.
06:21:59 <jerbome> Saulzar, I want to compile my stuff to see if it performs well enough$*
06:22:01 <bergey> Haste and Fay are used commercially.  From http://haste-lang.org/ "Haste supports the full Haskell language, including most GHC extensions".  (But not all GHC extensions.)
06:25:57 <mniip> hm
06:26:00 <mniip> interesting
06:26:15 <mniip> apparently tabs mess up :list in the debugger
06:26:35 <mniip> not by a whole lot but the bold highlight is off
06:28:13 <Fuuzetsu> don't use tabs
06:28:40 <voidzero> ^ sadtrombone.com
06:28:47 <geekosaur> tabs are strongly disrecommended for haskell code, so it's not surprising that it doesn't compute screen offsets right when they're used
06:28:51 <lytchi> win 32
06:28:52 <lytchi> oups sorry
06:28:57 <ion> lose 33
06:29:42 <Fuuzetsu> if you absolutely must use tabs, make them display as 8 spaces but really, just don't use them
06:30:03 <mniip> aren't they interpreted as 4 chars?
06:30:09 <ion> If the thing youâ€™re using doesnâ€™t display tabs as 8 spaces, file a bug report.
06:30:14 <Fuuzetsu> mniip: no
06:30:15 <lexir> geekosaur: What? I used to use tabs all the time without any issues.
06:30:19 * mniip notes
06:30:27 <lexir> mniip: I also thought they are.
06:30:39 <lexir> Now I use structured haskell mode and it does everything for me.
06:30:45 <mniip> I prefer tabs to spaces, but I sure never mix the two
06:30:50 <Fuuzetsu> GHC interprets a hard tab as 8 spaces
06:31:03 <osfameron> 8 spaces is a ridiculous number of spaces though :-(
06:31:09 <Fuuzetsu> so don't use tabs
06:31:23 <geekosaur> more precisely I'm pretty sure it means go to next multiple-of-8-spaces column
06:31:24 <mniip> the way I use tabs the amount of spaced doesn't matter
06:31:29 <mniip> as long as it's constant I guess?
06:31:34 <osfameron> yeah, I don't, tbh.
06:31:35 <Fuuzetsu> http://urchin.earth.li/~ian/style/haskell.html standard reference
06:32:01 <voidzero> I prefer how vim is able to treat spaces as tabs
06:32:05 <Fuuzetsu> mniip: clearly it matters when you complain that it messes something up
06:32:29 <kuribas> osfameron: linus can't be wrong?
06:32:57 <geekosaur> lexir: tabs "work". they work differently in pretty much every editor, they are hard for people to reason about because people want to think tab = N spaces when they're really skip-to-next-multiple-of-N-spaces (except for some editors which treat them as N spaces)
06:33:07 <geekosaur> python disrecommends tabs for the same reasons
06:33:55 <kuribas> I prefer to keep all code as much to the left margin as possible.
06:34:01 <frerich> That's not why Python disrecommends tabs. The thing is that most people don't distinguish indenting code from aligning code. Tabs are good for indentation, but you want spaces for indentation. Since most people don't get this, it's better to just resort to spaces and live with the inability to reconfigure the indentation depth.
06:34:02 <mniip> "Unfortunately, it constrains you to a code layout that we believe is ugly."
06:34:14 <mniip> well duh! your understanding of beauty is wrong then!
06:34:17 <voidzero> lol
06:34:19 <lexir> I think my emacs config has set tab key to 2 spaces while haskell mode makes tab key 4 spaces. I'm not sure about the haskell mode thing though.
06:34:33 <lexir> I'm talking purely from the perspective of an emacs user.
06:34:38 <frerich> s/you want spaces for indentation/you want spaces for alignment/
06:35:26 <lexir> frerich: I didn't know that.
06:36:14 <mniip> hmm
06:36:22 <mniip> is there a way to make singlestepping more verbose
06:36:51 <mniip> like print a 'stack'-trace everytime or something
06:38:55 <mniip> not call stack but rather evaluation stack
06:39:05 <mniip> stack of currently demanded values, idk
06:56:20 <mniip> hmm weird
07:02:05 <mniip> is there a better way to say 'let (a, b) = case f x of (# a, b #) -> (a, b) in ...' 
07:02:30 <mniip> I want the evaluation of 'f x' to be deferred
07:02:49 <mniip> (It isn't deferred in 'case f x of (# a, b #) -> ...'
07:02:50 <mniip> )
07:02:55 <kuribas> lexir: yeah, 2 spaces is the default in indentation-mode
07:03:48 <chpatrick> mniip so you want to box an unboxed tuple?
07:04:35 <mniip> chpatrick, uhh
07:04:36 <mniip> no
07:04:43 * hackagebot ghc-typelits-natnormalise 0.1.1 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  http://hackage.haskell.org/package/ghc-typelits-natnormalise-0.1.1 (ChristiaanBaaij)
07:05:10 <mniip> 'f x' returns 2 values, I want to get both of them, but lazily, so that I can return a construct containing them without actually evaluating 'f x'
07:05:53 <chpatrick> I think that's what you get anyway though, no?
07:06:11 <chpatrick> I mean, if you have the case on f x then it won't actually get evaluated until you want the case
07:06:43 <chpatrick> the only difference is that once you do force the case, it will force f x
07:06:51 <chpatrick> but nothing will magically force f x out of nowhere
07:07:14 <int-e> mniip: I don't see a better way to get that behavior.
07:07:37 <int-e> chpatrick: the point is, evaluating either a or b will cause f to be called, but even if you use both a and b, it'll only be called once.
07:07:56 <int-e> chpatrick: wheras case f x of (# a, b #) -> ...  will call f immediately.
07:08:01 <chpatrick> ok, yeah
07:08:32 <chpatrick> wait, I'm still confused
07:08:56 <chpatrick> let's say you have let ( a, b ) = wrapF or whatever
07:09:13 <chpatrick> wrapF will only be forced when you want a or b right?
07:09:19 <int-e> let (a,b) = f in ... is about the same as let t = f; a = fst f; b = snd g in ...
07:09:19 <chpatrick> regardless of what's inside wrapF
07:09:33 <int-e> ouch.
07:09:45 <int-e> I want let t = f; a = fst t; b = snd t in ...
07:10:16 <chpatrick> mniip: I mean, do you want f x to only be evaluated when you use a or b? or what?
07:10:17 <int-e> chpatrick: so yeah.
07:10:22 <mniip> yes
07:10:22 <kuribas> > let (a, b) = undefined in 5
07:10:24 <lambdabot>  5
07:10:26 <mniip> only once
07:10:43 <chpatrick> why doesn't
07:10:43 <chpatrick> where
07:10:43 <chpatrick>   ( a, b ) = case f x of
07:10:43 <chpatrick>    ... 
07:10:45 <chpatrick> achieve that?
07:11:17 <int-e> chpatrick: that's the same as the let version, semantically.
07:11:19 <chpatrick> when you want something from the tuple, it'll force the case which will force f
07:11:33 <chpatrick> sure but what other way is there?
07:11:51 <chpatrick> I mean sure if you do case f x of { ... -> the rest of the code } then yeha
07:11:54 <kuribas> > let (a, b) = case (Just 1) of Nothing -> 3; Just x -> x in 5
07:11:55 <lambdabot>      Could not deduce (Num (t, t0))
07:11:56 <lambdabot>      from the context (Num (t, t1))
07:11:56 <lambdabot>        bound by the inferred type for â€˜aâ€™: Num (t, t1) => t
07:11:59 <int-e> chpatrick: let ~(# a, b #) = f x in ... <-- but this doesn't exist.
07:11:59 <chpatrick> then it'll force f x first
07:12:28 <chpatrick> so just do the case
07:12:31 <chpatrick> I don't see the problem
07:12:51 <int-e> mniip: the way I see it, the code makes explicit the fact that the results have to be combined into a tuple, to get the necessary sharing.
07:13:10 <int-e> chpatrick: there are no irrefutable pattern matches for unboxed tuples.
07:13:33 <kuribas> > let (a, b) = case undefined of Just 3 -> (1,2); Nothing -> (3,4) in 5
07:13:34 <lambdabot>  5
07:18:52 <nshepperd> is there a good reason we don't have 'let (# a, b #) = f x in _'?
07:19:57 <int-e> nshepperd: We do. But it's strict.
07:20:15 <int-e> > let (# a, b #) = error "aaa" in a
07:20:17 <lambdabot>  *Exception: aaa
07:20:38 <nshepperd> > let (# a, b #) = error "aaa" in 5
07:20:39 <lambdabot>  *Exception: aaa
07:20:40 <bennofs> int-e: a lazy (# a, b #) does not make sense, does it?
07:20:53 <nshepperd> ah, hmm
07:20:56 <geekosaur> unboxed anything is strict, pretty much
07:21:00 <nshepperd> so that's no normal let binding
07:21:16 <int-e> > let !(a,b) = error "aaa" in 5
07:21:16 <geekosaur> this includes unboxed tuples
07:21:17 <lambdabot>  *Exception: aaa
07:21:32 <mniip> hm
07:21:44 <mniip> then I invented a haskell time machine!
07:22:01 <bennofs> > let f :: a -> Int; f _ = 3 in f (# 3, 4 #)
07:22:02 <lambdabot>      Couldn't match kind â€˜*â€™ with â€˜#â€™
07:22:02 <lambdabot>      When matching types
07:22:02 <lambdabot>        a0 :: *
07:22:30 <int-e> > let (a, b) = let (# a, b #) = error "aaa" in (a, b) in (5, a)
07:22:32 <lambdabot>  <no location info>: can't find file: L.hs
07:22:39 <int-e> > let (a, b) = let (# a, b #) = error "aaa" in (a, b) in (5, a)
07:22:41 <lambdabot>  (5,*Exception: aaa
07:22:48 <bennofs> > let f :: (# Int, Int #) -> Int; f !_ = 3 in f (error "a")
07:22:49 <lambdabot>  *Exception: a
07:22:53 <bennofs> > let f :: (# Int, Int #) -> Int; f _ = 3 in f (error "a")
07:22:55 <lambdabot>  *Exception: a
07:23:33 <lpaste> mniip pasted â€œTimeMachineâ€ at http://lpaste.net/130870
07:23:37 <bennofs> Anyway, using unboxed tuples directly should rarely be required
07:26:06 <nshepperd> I'm a bit confused that you can write 'error "a" :: (# Int, Int #)' at all.
07:26:42 <nshepperd> but I haven't really read about unlifted types so
07:27:00 <nshepperd> (are unboxed tuples unlifted?)
07:27:09 <bennofs> nshepperd: there is a hack in GHC to make error polykinded
07:32:49 <nshepperd> hmm... I need to read up on the execution model I guess
07:33:28 <nshepperd> er, evaluation
07:37:40 <jerbome> is this correct : zip (map f [1..1000]) [1..] performs as well as map (\n->(f n, n)) [1..1000] ?
07:37:45 <jerbome> thanks to lazy eval ?
07:45:46 <Darwin226> So I'm testing stuff with quickcheck. When it finds a counter example it prints it out using it's regular show instance. Is there any way I can hook into that and do my own printing once a counter example is found?
07:50:19 <slomo> Darwin226: newtype with a custom Show instance maybe
07:51:14 <saml> what assembly does ghc generate for  expression 2+2   ?
07:51:17 <Darwin226> slomo: Hmmm, I guess I could also just write my Show instance manually instead of deriving it.
07:51:56 <chpatrick> saml: I'd imagine nothing
07:53:55 <frerich> jerbome: Based on the code generated by ghc 7.8.3 with -O, I'd say that the latter generates more efficient code than the former. There are no two lists.
07:55:00 <ivanchuk> hi haskellers
07:55:37 <int-e> Darwin226: the call to 'show' is quite deeply embedded in QuickCheck, so writing a custom Show instance seems to be the best bet. ( https://hackage.haskell.org/package/QuickCheck-2.4.0.1/docs/src/Test-QuickCheck-Property.html#forAll ; forAllShrink is used for implementing the Testable prop => Testable (a -> prop) instance that lies at the very heart of QuickCheck.)
07:56:02 <ivanchuk> Is there an applicative instance of a data structure more "complex" than Maybe ?
07:56:20 <Darwin226> int-e: Yeah. Once I decided to do it it turned out I had to write 2 lines of code.
07:56:53 <frerich> jerbome: Running the generated code on longer lists (10 million elements instead of 1000) supports this, the second version is about 2.5x faster.
07:56:59 <Darwin226> ivanchuk: Sure. There are tons of them
07:57:01 <int-e> ivanchuk: everything that is a monad (lists, trees with labels at leafs)
07:58:15 <ivanchuk> oh ok
07:59:56 <int-e> Fixed length arrays (say, arrays of length 42) would be something that's naturally an applicative (you can zip them) but not a monad.
08:01:07 <orion> Hi. What's the best way to deploy a haskell application (yesod) with configuration management tools like Puppet?
08:01:35 <ivanchuk> basically, I have a simple expr tree and I'd like to make it an instance of Traversable, together with a custom applicative to throw different exceptions
08:02:16 <ivanchuk> but appart from basic results such as : data Eval a = Value a | TypeError
08:02:31 <zennist> I changed my .cabal/config to set documentation to True now I have docs for each new package installed - problem: how do I need to do further to be able to have the source of the libraries downloaded as well?
08:03:07 <dcoutts> zennist: see the hyperlink-source setting in the config file?
08:03:14 <dcoutts> zennist: and you need hscolour installed
08:03:18 <ivanchuk> I don't know how to instanciate an applicative
08:04:01 <zennist> dcoutts: okay thanks 
08:04:03 <ivanchuk> for instance, data Eval a = Value a | TypeError | End
08:04:20 <ivanchuk> i.e. just adding another "exception"
08:06:37 <zennist> dcoutts: magical! now I need to reinstall all my packages again! (after I've reinstalled all packages to enable profiling..)
08:21:42 <ivanchuk> I should rethink my problem to expose it more clearly :)
08:26:26 <zennist> does anyone know a vim plugin that allows me to go the source definition of a function?
08:26:52 <zennist> currently I have vim2hs which only lets me 'gf' on an import statement
08:27:32 <Gothmog_> no plugin needed, try hasktags -c and C-[ / :tj / :ts
08:28:59 <b_jonas> can't you just search by typing /^nameOfFunction then pressing enter, just like you do in C?
08:29:04 <b_jonas> that's supposed to work in haskell too
08:30:24 <apollo1993> that can yield multiple results
08:30:25 <zennist> Gothmog_: b_jonas: thanks but I was hoping to get around to functions defined outside the current file 
08:30:28 <apollo1993> also it doesn't span files
08:32:37 <b_jonas> apollo1993: sure, multiple results especially if you define a function like rev [] = []; rev a:d = (rev d) ++ a;
08:32:54 <b_jonas> as for multiple files, I don't know how to search in multiple files in vi, I don't use vi much
08:34:47 <yac> Is there a ($) that would "end" before operators like >>=, so `x $ y z >>= foo` == `x (y z) >>= foo` ?
08:36:04 <guesting> My program uses up a TON of memory when it shouldn't. It reads in a very large file and should theoretically only need one line at a time. In profiling, I see a huge linear growth in the [] type and that same growth in DRAG. What is drag? Why is it in the list? What should I be looking for in the memory usage?
08:36:52 <c_wraith> guesting: the problem is almost certainly excessive laziness.  drag is the time between allocation of a thunk and its evaluation
08:37:20 <guesting> So it isn't a buildup of thunks, right? Because there is no thunk type in any profiling i've done
08:37:28 <guesting> Like it must be in "trace elements"
08:38:00 <c_wraith> guesting: is the code available?
08:38:23 <guesting> a little, but it has changed a bunch since the last commit
08:39:37 <guesting> in my profiling, it appears to have most of the memory in Map.fromListWith (Map.unionWith (+)), but that works in simple tests so I don't think that's actually the main issue
08:39:50 <guesting> that was able to work line by line in large files in a simple test
08:40:09 <guesting> the profiler must be missing something, that must just be a sympton
08:40:11 <guesting> m
08:40:57 <guesting> also, that Map is Map.Strict
08:41:29 <guesting> let me post the code
08:42:38 <guesting> c_wraith: The code, http://pastebin.com/TdaC2rqw
08:42:52 <guesting> ALL of the memory in the program is due to generatePositionMap
08:43:00 <guesting> which calls fragmentPos
08:43:25 <c_wraith> wow, pastebin's haskell formatting is *awful
08:43:27 <guesting> sorry for splitting up the posSeqList into tests, but I did that to see where the memory was in that function from the profiler
08:43:32 <guesting> yeah that was stupid
08:43:41 <guesting> never saw that before in pastebin
08:44:13 <guesting> ah, it thinks the strict fold was a string haha
08:45:03 <apollo1993> b_jonas: yeah but it also gives you all uses of the function too which can be undesireable (which is why hasktags is preferable when reading code)
08:45:34 <guesting> c_wraith: So theoretically I think that it should form a running count and throw away each FastaSequence once it's a map and joined with unionsWith
08:45:47 <guesting> like, a simple example worked before (pasting it now)
08:46:59 <guesting> c_wraith: This example works with GIANT files as well, but if you use lazy maps it does NOT. http://pastebin.com/bfwxRmDh
08:47:20 <b_jonas> apollo1993: no, that's why you have the ^ in there
08:47:30 <b_jonas> apollo1993: so that it finds only mentions of the function name in the first column
08:47:47 <b_jonas> that's only the definitions in sanely formatted code, not other uses
08:48:28 <b_jonas> this won't help you distinguish between multiple functions with the same name of course, you need more magic for that
09:01:58 <jophish> I'm havign trouble building default data instance containers
09:02:16 <jophish> with ghc 7.10.1
09:06:50 <hesiod> Is it possible to make mapM parallel (by using the parallel package), i.e. something like parMapM?
09:08:06 <jophish> installing from source worked
09:08:26 <shachaf> What would parallel mapM do?
09:09:21 <hesiod> shachaf: spawn a spark for every thunk resulting from the map
09:09:37 <hesiod> but I already managed: it's just sequence (parMap f xs)
09:09:43 <shachaf> You just want sequence ( -- yes, that.
09:10:37 <shachaf> But that won't do much except parallelize figuring out which action to run, of course.
09:16:05 <rabisg> can someone help me understand https://bpaste.net/show/92045967d30d
09:18:20 <bergmark> rabisg: is that your own package?
09:18:27 <rabisg> yes
09:18:41 <bergmark> did you add all modules to either exposed-modules or other-modules in the cabal file?
09:20:22 <rabisg> bergmark: no. should I add even those modules that I'm not exporting to other-modules? I mean is it necessary?
09:20:37 <bergmark> yes, that's what other-modules is for
09:20:44 <int-index> I'm looking for a typeclass like this: http://lpaste.net/130875 - a monoid with zero element
09:21:13 <int-index> is it defined anywhere?
09:21:20 <glguy> a monoid with a zero element is a monoid...
09:21:37 <int-index> glguy: no, a different zero element. see the paste
09:22:03 <int-index> I mean this kind of zero element: http://en.wikipedia.org/wiki/Absorbing_element
09:22:10 <shachaf> glguy: You're thinking of a one element. :-)
09:22:32 <glguy> You're thinking of <> as *
09:22:48 <glguy> (is this getting us anywhere?)
09:23:15 <jophish> int-index: search for NullSemigroup?
09:23:28 <jophish> I don't know if it exists, but that's what I've heard this called
09:23:29 <glguy> I don't know of a standard implementation of that class
09:23:52 <jophish> err, disregard me
09:24:02 <shachaf> The monoid [A] is interesting because it has lots of left zeros but no right zeros.
09:27:15 <kvelicka> Hey guys, I'm having some trouble with ghc's sync-all script. I'm trying to get all the submodules for my fork of the compiler but sync-all's -r parameter that is meant to use a different remote root to locate all the libraries does not work and I still get error messages about the repositories for submodules missing at my forked repo's url. Anyone have any experience with this?
09:33:32 <Gothmog_> zennist: Writing a tags file does allow you to jump to definitions in different files.
09:34:42 <zennist> Anyone knows what does the 'hoogle' option under 'haddock' means in ~/.cabal/config?
09:35:35 <zennist> Gothmog_: thanks. might give it a shot next time. Currently I have lushtags installed and view the tags in tagbar so it feels a bit of a setback to generate tags manually
09:36:41 <zennist> also, 'html' option is set to False, but I thought I get html documentations under ~/.cabal/share/doc?
09:36:48 <mpickering> kvelicka: any reason you need to sync-all rather than git clone --recursive?
09:38:13 <kvelicka> mpickering: no, I simply wasn't aware that it'd do the same thing. Trying it now.
09:38:43 <mpickering>  If you just want to build GHC HEAD then the best way is with git clone --recursive
09:38:53 <mpickering> what is your goal?
09:39:27 <kvelicka> mpickering: I want to work on the 7.10 branch, making some changes to its RTS for an university project.
09:39:42 <joneshf-laptop> let's say i'm writing a quickcheck property
09:40:00 <joneshf-laptop> prop_foo :: [Foo] -> Int -> Prop
09:40:20 <joneshf-laptop> how can i make the `Int` bounded by (0, length foo)?
09:40:29 <joneshf-laptop> without resorting to `(==>)`
09:40:47 <joneshf-laptop> as this generates too many discarded cases
09:42:35 <mpickering> kvelicka: I assume you are following the instructions here?
09:42:36 <mpickering>  https://ghc.haskell.org/trac/ghc/wiki/Building/GettingTheSources
09:42:42 <kvelicka> Hmm, it seems I'm getting the same issue with clone --recursive
09:43:57 <glguy> joneshf-laptop: You can use: mod
09:44:14 <ion> joneshf: forAllShrink (choose (0,x)) shrink
09:44:38 <kvelicka> mpickering: Not quite - I'd like to have my own fork of it in my github but the instructions in the link would just give me the sources that would still point to the original ghc repos. Am I misunderstanding something?
09:45:04 <cschneid> joneshf-laptop: totally a guess on how this could work, but `data FoosAndLength = FoosAndLength { foo :: [Foo], len :: Int }, then make the Arbitrary instance using the monad interface to do `let foo = arbitrary :: [Foo]`, then `len <- choose(0, length foo)`.  Then destructure it. 
09:45:17 <cschneid> joneshf-laptop: but glguy and ion seem to actually know the quickcheck functions :)
09:46:42 <mpickering> kvelicka: right but you can always "git remote add kvelicka  ..."
09:49:08 <kvelicka> mpickering: Thanks, I'll look into it. Someone's not done their research on git it seems ^^
09:49:43 <mathu> y'all would know more than me; is writing a webserver a good goal for a final project after a semester of studying haskell?
09:49:44 <ion> joneshf: Or the other way around: \n -> forAllShrink (vectorOf n arbitrary) shrink â€¦
09:50:29 <mmaruseacph2> mathu: too easy to create a bad webserver, too hard to create a good one based on only one semester of studying
09:50:36 <mmaruseacph2> I'd rather choose something else
09:50:41 <ion> and choose (0,n)
09:51:50 <mathu> mmaruseacph2: i don't mean an entirely naive webserver. i was thinking being threaded and returning files and not just http status codes. do you think that's still too primitive?
09:52:23 <mmaruseacph2> still easy
09:53:08 <mathu> what constitutes a good webserver then? i'm not entirely new to haskell; i've read LYAH and think i know what a monad is now haha
09:53:13 <joneshf-laptop> glguy, ion cschneid thanks
09:54:41 <mathu> another project i was considering is finishing the card game engine i was writing in like 2012. but that's kind of boring haha
10:04:05 <maxxdev> Hey?
10:05:10 <Jefffrey> Hello
10:05:26 <Jefffrey> Does someone know if it's possible to get an identifier value for a type?
10:06:05 <c_wraith> Jefffrey: I don't even know what that means.
10:06:11 <Jefffrey> Like of type (a -> ID) for some type
10:06:33 <Jefffrey> I don't know either.
10:06:41 <c_wraith> do you mean Typeable?
10:06:52 <c_wraith> > typeOf "foo" == typeOf ()
10:06:54 <lambdabot>  False
10:06:57 <c_wraith> > typeOf "foo" == typeOf "bar"
10:06:59 <lambdabot>  True
10:07:05 <c_wraith> :t typeOf
10:07:06 <lambdabot> Typeable a => a -> TypeRep
10:07:34 <Jefffrey> I think so yeah
10:07:40 <Jefffrey> Thanks
10:07:58 <c_wraith> Sometimes that's useful, but often there are better ways to solve the same problem.  What are you actually trying to solve?
10:13:58 <Jefffrey> Well, ok.
10:14:01 <Jefffrey> This is the problem.
10:14:07 <Jefffrey> I have a bunch of data types.
10:14:25 <Jefffrey> And each one needs to be initialized with a value of type (X a) where `a` is one of these types
10:14:39 <Jefffrey> But I want to keep a cache of these (X a) for each type
10:15:37 <Jefffrey> Like say I have a class `class Init t where init :: X t`
10:15:47 <ProofTechnique> > typeOf "foo"
10:15:49 <lambdabot>  [Char]
10:15:53 <ProofTechnique> Oh, neat
10:16:09 <Jefffrey> And I need to keep a cache of these initialized `X t`.
10:18:08 <Jefffrey> Oh I don't know.
10:18:10 <Jefffrey> Anymore.
10:22:43 <Jefffrey> Yeah, sorry for wasting your time.
10:29:43 <slack1256> Jefffrey: You need an associated type for your types? asi in associated data types?
10:30:43 <cschneid> Is anybody aware of any sort of MeteorJS equivalent work in haskell? It seems all the parts & pieces are there (GHCJS, Databases, Websockets) but has anybody actually tied it all together?
10:33:14 <Gurkenglas> Why is print $ sum $ map length $ lines $ file so much slower than print $ length $ file ?
10:34:04 <ProofTechnique> cschneid: Like this? http://arianvp.me/hom-react-js-for-haskell/
10:35:33 <Gurkenglas> Oh, it runs out of memory on big files, so it's that diverging thunks thing
10:35:37 <cschneid> ProofTechnique: well, the ghcjs frontend story isn't too bad - I'm using blaze-react for somet stuff. But meteor is a full-stack solution where it does liveupdate across several clients, data syncing, etc. 
10:35:55 <Gurkenglas> Why is sum implemented via foldl, not foldl'?
10:35:58 <cschneid> ProofTechnique: thats what I'm saying though - we have lots of different components of a really slick system, just doesn't seem anybody has put them all together.
10:36:46 <Gurkenglas> (And that can't be the whole problem, can it? The file is a mere ~70 KB and the memory quickly overtaken is 1 GB)
10:37:44 <ProofTechnique> What are you using to read the file?
10:38:05 <ProofTechnique> I can't imagine the sum step being the memory hog
10:38:06 <Cale> Gurkenglas: are you compiling with optimisations turned off?
10:38:26 <Cale> Gurkenglas: You need -O at least, if not -O2 to have any expectation that things will perform well.
10:39:03 <Cale> Usually the difference between foldl and foldl' doesn't matter if optimisations are on.
10:39:29 <Cale> (though the strictness analyser isn't perfect, so sometimes you really want to use foldl' explicitly)
10:39:35 <Gurkenglas> ProofTechnique, print $ length $ concat $ lines $ file gets it done quickly
10:40:17 <Gurkenglas> I'm on Windows and doubleclicking .hs files in my explorer to run them
10:40:26 <c_wraith> oh, well that's the problem
10:40:34 <Cale> Okay, try actually compiling stuff :)
10:40:38 <c_wraith> sum leaks space unless compiled with optimizations on
10:40:49 <ProofTechnique> Oh, that would do it
10:41:09 <Gurkenglas> And why isn't that fixed?
10:41:23 <Cale> It's not a bug, it's just what happens if the optimiser is turned off.
10:41:50 <Gurkenglas> Is there a reason to have it off?
10:41:56 <Cale> Faster startup time
10:42:14 <Cale> For shell-scripty like things which have almost no performance requirements
10:42:35 <c_wraith> runghc *interprets* code.  It doesn't care about execution speed, just simplicity.
10:42:43 <Gurkenglas> "-O conflicts with --interactive; -O ignored."
10:42:43 <c_wraith> If you care about execution speed, compile.
10:42:50 <c_wraith> So *compile* it
10:42:55 <c_wraith> not interpret it.
10:43:10 <solrize_> > let sum' = foldl' 0 in sum' [1..100]
10:43:12 <lambdabot>      No instance for (Typeable t0)
10:43:12 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
10:43:12 <lambdabot>        arising from a use of â€˜show_M59866869072405076969330â€™
10:43:15 <solrize_> oops
10:43:19 <solrize_> > let sum' = foldl' (+) 0 in sum' [1..100]
10:43:21 <lambdabot>  5050
10:44:52 <Runda> hello?
10:45:34 <marchelzo_> Runda: hi
10:46:48 <ProofTechnique> Though I'm not seeing that crazy memory usage even in ghci, so
10:47:09 <Runda> how's it going?
10:48:22 <Gurkenglas> ghc -O2 BioInfAufgabe0.exe BioInfAufgabe0.hs makes a .hi and a .o file, but no .exe
10:49:07 <ProofTechnique> ghc --make
10:50:58 <Gurkenglas> https://wiki.haskell.org/Haskell_in_5_steps doesn't include that options, should it be added? (Ctrl-F "$ ghc -o hello hello.hs")
10:51:05 <Gurkenglas> -s
10:51:36 <ProofTechnique> Ctrl+F for ghc -O2 --make
10:51:52 <ProofTechnique> That could reasonably be added, though
10:52:17 <ProofTechnique> Probably should be, reall
10:52:19 <ProofTechnique> *really
10:52:52 <ProofTechnique> Done
10:53:15 <Gurkenglas> "ghc -O2 --make BioInfAufgabe0.hs -threaded -rtsopts" still makes .hi and .o
10:53:34 <Gurkenglas> (and no exe)
10:54:02 <ProofTechnique> When you compile, does it say "Linking BioInfAufgabe0.exe"?
10:54:33 <Gurkenglas> No, just "[1 of 1] Compiling BioInfAufgabe0   ( BioInfAufgabe0.hs, BioInfAufgabe0.o )"
10:55:21 <ProofTechnique> Oh
10:55:34 <ProofTechnique> Is there a main in your file?
10:55:50 <slomo> and if it is in a module, do you export it?
10:57:09 <Gurkenglas> Yes, there's a main. I don't know about that export thing, so I assume I didn't do it or it can be deduced from the source. http://lpaste.net/130877
10:58:23 <Gurkenglas> The import is there because I was trying to shrink my sourcecode from the original hogger to find the reason, and I left it in before pasting before I missed it earlier and now thought that I should rather wrongfully paste it than it being the reason for all the overflow.
10:59:00 <ProofTechnique> Gurkenglas: Change your module name to Main
10:59:13 <ProofTechnique> Or I think you can say --main-is or something like that
10:59:29 <Cale> Or just delete the module declaration altogether
10:59:34 <ProofTechnique> Also that
10:59:45 <Cale> Main executable modules generally shouldn't need a module declaration.
11:01:07 <ProofTechnique> ghc --make -main-is Overflowhuh.main <file>, just in case
11:01:20 <ProofTechnique> But yeah, just removing the declaration is easiest
11:01:32 <Gurkenglas> (Without module declaration and without -main-is, still .hi and .o instead of .exe)
11:01:38 <athan> Type-level lambdas would make my life so much easier ._.
11:01:38 <Gurkenglas> *--
11:02:19 <eacameron1> MonadBaseControl scares me for various reasons: is there an alternative to getting lifted "bracket" etc?
11:02:43 <Gurkenglas> (It does some linking now, though.)
11:03:07 <ProofTechnique> There ought to be an exe there, then
11:03:10 <Cale> eacameron1: Avoid monad transformers? Implement your own bracket by hand?
11:03:11 <Gurkenglas> Oh, "-" it is.
11:03:27 <Gurkenglas> Right, I must have missed it.
11:04:03 <eacameron1> Cale: not happy yet... ;)
11:04:08 <supki> @hackage exceptions -- eacameron1 
11:04:08 <lambdabot> http://hackage.haskell.org/package/exceptions -- eacameron1
11:04:17 <Gurkenglas> Can I make it not make .hi and .o files?
11:05:32 <ProofTechnique> Nope
11:05:43 <ProofTechnique> You can use -outputdir to shove them somewhere else, though
11:05:53 <eacameron1> supki: Happines!
11:06:00 <Cale> In my experience, a large fraction of the time where people are transforming the IO monad with StateT or ReaderT, they'd be better off just not doing so.
11:06:56 <eacameron1> Cale: maybe so, but I'm writing a library and I like my interfaces to be generic if possible; and monadbasecontrol is a pricey
11:07:39 <Cale> Ah, so you're writing something which doesn't actually involve IO in any way, but you need an exception mechanism?
11:08:03 <eacameron1> right
11:08:06 <Cale> In that case, fair enough :)
11:08:28 <Cale> Usually I'd just use Maybe/Either for that
11:08:34 <Cale> But yeah, there's that exceptions library
11:09:06 <eacameron1> Cale: well specifically I want to convert between various forms of throwing/Maybe/Either etc.
11:09:12 <eacameron1> It's an internal lib
11:09:30 <Gurkenglas> http://lpaste.net/130878 <- compiled with C:\Users\Gurkenglas\Desktop\Haskell>ghc -O2 --make -main-is BioInfAufgabe0.main
11:09:30 <Gurkenglas> BioInfAufgabe0.hs -threaded -rtsopts, this still goes over 1.3 GB processing that 70 KB file
11:10:15 <Gurkenglas> (Actually 60 KB apparently)
11:11:25 <Gurkenglas> Ohh. 60,085 KB means 60 MB. In Germany, ',' delimits the digit with 1 multiplier from the one with .1 multiplier, but I changed the system language to English.
11:11:33 <Gurkenglas> Still, 60 MB to 1.3 GB is no joke
11:13:17 <Gurkenglas> Also how do you copy the line currently being edited from the windows command line without copying a rectangle of text including newlines?
11:14:42 <mniip> welcome to windows command line
11:16:26 <Gurkenglas> Maybe I should get a linux VM if Haskell is so much better supported on there...
11:16:52 <Gurkenglas> What's the slowdown factor on Haskell in a VM?
11:17:16 <tulcod> Gurkenglas: that would depend on the VM...
11:17:16 <mniip> same as of any other program?
11:17:32 <mniip> Gurkenglas, there's something called Console
11:17:44 <tulcod> Gurkenglas: for raw computation, if you have a processor that supports virtualization (a certain extension), it might be pretty efficient
11:18:04 <mniip> Console2?
11:18:33 <Gurkenglas> I guess that would be a Windows program imitating a unix shell? That sounds like an easier solution.
11:18:52 <tulcod> Gurkenglas: it's much more likely that you have a laziness problem though
11:19:13 <tulcod> Gurkenglas: like, this is a pretty simple program. the OS you run it on is not going to affect its memory usage.
11:19:53 <Gurkenglas> Well the compiling is a chore and -O2 didn't help
11:20:09 <Gurkenglas> And since this is such a simple program, O2 shouldn't already fail... right?
11:20:14 <tulcod> Gurkenglas: for one thing, what you tell it to do is *first* put the entire file into RAM, and *then* start processing lazily. i'm actually not really surprised that blows up RAM usage
11:20:43 <tulcod> Gurkenglas: this is not an -O2 thing. this is not a windows thing. this is you not using laziness and strictness appropriately.
11:20:46 <Gurkenglas> That would be 70 MB of the problem
11:21:02 <Gurkenglas> *60
11:21:50 <tulcod> Gurkenglas: try using stream IO
11:22:50 <Gurkenglas> I assumed that since -O2 apparently makes the sum implementation using foldl vs foldl' irrelevant, it would handle laziness problems. "Gurkenglas: You need -O at least, if not -O2 to have any expectation that things will perform well." | "Usually the difference between foldl and foldl' doesn't matter if optimisations are on."
11:23:23 <c_wraith> Gurkenglas: depends on whether the strictness analyzer picks up that the operation you're folding is always strict.
11:24:45 * hackagebot lens 4.9.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.9.1 (EricMertens)
11:24:59 <c_wraith> that's a strangely non-edwardk releaser
11:26:27 <tulcod> Gurkenglas: in particular, the default implementation of "unlines" is completely lazy, and in your program, will construct an unbelievably large collection of thunks
11:26:35 <Gurkenglas> Running "main = readFile "sequence.fasta" >>= print . length" takes only 20 MB, so readFile apparently doesn't necessarily load the whole file into the RAM first thing.
11:26:59 <tulcod> Gurkenglas: what if you readFile mapM both files, as you're doing in your code?
11:28:39 <quchen> "(maybe you haven't applied enough arguments to a function?)" -- Cool! I didn't know GHC added useful error hints
11:29:15 <glguy> c_wraith: Actually it's pretty common for me to be the one to upload lens to hackage
11:30:41 <c_wraith> glguy: oh, hey.  I hadn't associated your name with your nick.
11:33:29 <slack1256> data Char = C# Char#. Is Char# what is called a primop?
11:33:46 <slack1256> if so where is the defined size of Char#? Is it a Word32?
11:34:30 <c_wraith> slack1256: it's not a primop, it's a primitive type. :)
11:34:41 <c_wraith> slack1256: I believe it's usually just a single machine word.
11:35:56 <shwouchk> Hi
11:36:51 <shwouchk> I see the @ symbol, and don't remember it being defined. Does anyone know its meaning?
11:37:39 <slack1256> c_wraith: right, not a PRIMitive OPeration, but a primitive type
11:37:41 <glguy> shwouchk: @ is for "as patterns"
11:37:58 <shwouchk> glguy: right right
11:38:16 <shwouchk> glguy: I now remember it being defined... Thanks!
11:39:03 <shwouchk> whats the best place to look for such info? ghci wouldn't agree to talk about @
11:39:30 <kadoban> @ is syntax, so that's not surprising
11:39:48 <glguy> shwouchk: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
11:39:49 <ProofTechnique> Gurkenglas: There's an example on the wiki that seems to fit your case: https://wiki.haskell.org/Haskell_IO_for_Imperative_Programmers#IO
11:40:48 <ProofTechnique> And you should probably work on that big scary chain of functions and see if you can decompose it a bit. I'm not sure that groupBy even does anything.
11:41:35 <ProofTechnique> Oh, actually, I guess it's https://wiki.haskell.org/Haskell_IO_for_Imperative_Programmers#More
11:41:52 <shwouchk> glguy:thanks again!
11:42:47 <shwouchk> kadoban: yeah, I realize that now that I know what it is :)
11:43:39 <flixil> Hello everyone, first time in the channel
11:43:55 <ProofTechnique> Hi, flixil 
11:45:19 <neuroserpens> wazzap flix
11:46:52 <flixil> Well, just joining to see what people talk about here, how popular this is and so on
11:47:12 <boothead_> Hi all. What's the function used to lift an action in an underlying monad into something that fits MonadFree f m => m a?
11:48:08 <boothead_> emacs is telling me I need  m0 (Either Redis.Reply Account) -> m (Either t0 Account)
11:48:38 <slack1256> boothead_: Doesn't the MonadFree class has a wrap method that fits?
11:49:03 <slack1256> or liftF function
11:49:07 <slack1256> @type liftF
11:49:08 <lambdabot>     Not in scope: â€˜liftFâ€™
11:49:08 <lambdabot>     Perhaps you meant one of these:
11:49:08 <lambdabot>       â€˜liftMâ€™ (imported from Control.Monad.Writer),
11:49:52 <boothead_> No liftF wasn't quite right
11:50:13 <Gurkenglas> tulcod, (I'm running these in the interpreter), both orders (pattern.fasta shows as only 1 KB) leave it at 20.7 MB. Curiously, after having run one order, updating and reloading the code and subsequently running it doesn't change the memory allocation Task Manager shows for ghc
11:51:38 <Gurkenglas> Cale, why is sum not being done through foldl' not a bug? As it seems, it makes no difference when you compile, and leaks space if you interpret.
11:52:11 <boothead_> slack1256, what should the argument of wrap be?
11:52:36 <Cale> Gurkenglas: Because not all instances of Num are strict. Perhaps there ought to exist sum'
11:53:05 <Gurkenglas> Ah. Yes, that does be a pretty good reason.
11:53:28 <Cale> To be fair, most of the commonly used instances *are* strict, and benefit from taht
11:53:30 <Cale> that*
11:55:07 <boothead_> What I'm trying to do is like am MonadIO action into a free monad so I can use the result as input to one of my commands later on.
11:55:39 <boothead_> I'm not sure exactly what the name of this concept is so I'm having a hard time figuring out what I'm trying to ask for :-)
11:57:04 <boothead_> I thought that somthing in MMorph might do it.. The type above certainly seems to be a natural transformation
11:57:19 <slack1256> boothead_: go to the documentation of the Free package, specially Control.Monad.Free. The type could help you clear what you mean
11:59:23 <haskell521> Hello! First time haskell-er here. And I've dug myself into a bit of a hole. 
11:59:55 <ProofTechnique> haskell521: Go on
11:59:58 <boothead_> slack1256, type holes tell me I need this:  m0 (Either Redis.Reply Account) -> m (Either t0 Account)
12:00:56 <haskell521> If given a list [0,0,2,3,4,8,9] how would I create a list that looks like [(0,1),(0,2),(2,3)...]
12:01:12 <Cale> haskell521: zip xs [1..] ?
12:01:15 <ProofTechnique> ^
12:01:25 <Cale> > zip [0,0,2,3,4,8,9] [1..]
12:01:26 <ProofTechnique> > zip [0,0,2,3,4,8,9] [1..]
12:01:27 <lambdabot>  [(0,1),(0,2),(2,3),(3,4),(4,5),(8,6),(9,7)]
12:01:28 <lambdabot>  [(0,1),(0,2),(2,3),(3,4),(4,5),(8,6),(9,7)]
12:02:06 <haskell521> Oh wow. I feel ridiculous. I've been trying at this for an hour.  You guys are awesome!
12:02:20 <ProofTechnique> @hoogle [b] -> [a] -> [(a, b)]
12:02:24 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
12:02:25 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
12:02:25 <lambdabot> Data.ByteString.Builder.Prim (>*<) :: Monoidal f => f a -> f b -> f (a, b)
12:02:34 <ProofTechnique> I always want there to be a flipped zip for decorator stuff like that
12:02:51 <Cale> haskell521: It's more conventional to put the indices in the first component of the pairs whenever that makes sense
12:02:52 <ProofTechnique> Actually, no
12:02:53 <ProofTechnique> I'm dumb
12:03:11 <ProofTechnique> Hahaha
12:03:42 <Cale> haskell521: because zip [0..] or zip [1..] are functions on their own
12:07:38 <boothead_> slack1256, it was my type. I went from MoandFree f m to FreeT m and then it's just:  lift $ runQuery $ myQuery where runQuery  is a function that goes from query monad to m
12:07:57 <hesiod> So, it's possible to have a monadic version of parMap by doing sequence (map f xs `using` parList rseq). But that evaluates only to WHNF, not to NF. It's not possible to use rdeepseq because there is no NFData instance for any monad transformer or for monads. How could that be circumvented?
12:08:37 <hesiod> (I currently use a monad transformer stack consisting of a StateT on a Reader)
12:09:46 * hackagebot ed25519-donna 0.1 - Haskell bindings to ed25519-donna (Elliptical Curve Signature Scheme)  http://hackage.haskell.org/package/ed25519-donna-0.1 (ThomasDuBuisson)
12:24:46 * hackagebot sws 0.3.1.1 - A simple web server for serving directories, similar to weborf.  http://hackage.haskell.org/package/sws-0.3.1.1 (DerekElkins)
12:31:42 <horny-sama> I don't understand why this is consider a higher-order function. A higher order function just means it takes a function as an argument but how can I can f1 x y z = x y + x z is a higher order funciton
12:31:53 <horny-sama> is it because of the space between x y 
12:31:55 <horny-sama> and x z
12:32:05 <horny-sama> which means x applies to y plus x applied to z?
12:32:18 <Fuco> horny-sama: if x is a function, yes
12:32:26 <Fuco> which in this syntax it must be
12:32:30 <Gurkenglas> It applies to y, not y plus x applied to z ^^
12:32:53 <horny-sama> Gurkenglas, Fuco 
12:33:02 <horny-sama> thank I wish they come out with ghci for raspbian
12:33:33 <Fuco> Gurkenglas: silly english with multiple parse trees
12:33:34 <horny-sama> install haskell-platiform will take up 1.1gb of my computer space (fedora )
12:33:35 <horny-sama> :<
12:35:31 <mniip> in haddock, can one make links in code blocks?
12:35:37 <horny-sama> length' :: [a] -> Int
12:35:37 <horny-sama> <interactive>:6:1:
12:35:37 <horny-sama>     Not in scope: length'
12:35:38 <horny-sama>     Perhaps you meant `length' (imported from Prelude)
12:36:03 <horny-sama> trying to implement my length' function and the type signature is blowing up
12:36:04 <horny-sama> :<
12:37:02 <geekosaur> you're doing it in ghci. ghci is not a file top level
12:37:25 <geekosaur> > let length' :: [a] -> Int; length' = ...
12:37:26 <lambdabot>  <hint>:1:38: parse error on input â€˜...â€™
12:37:31 <geekosaur> hush, you
12:38:40 <horny-sama> I think I will write the function first then load it to ghci
12:39:22 <linman16> is it possible to ignore a value when mapping over a list? with map or mapM.
12:39:38 <mniip> linman16, ignore as in?
12:40:03 <linman16> map double [1,'a',2,'b'] ... [2,4]
12:40:28 <kadoban> linman16: You can't have that list to begin with â€¦
12:40:36 <kadoban> > [1, 'a']
12:40:38 <lambdabot>      No instance for (Num Char) arising from the literal â€˜1â€™
12:40:38 <lambdabot>      In the expression: 1
12:40:38 <lambdabot>      In the expression: [1, 'a']
12:41:06 <linman16> data CharInt = CIInt Int | CIChar Char
12:41:30 <FireFly> You could filter and then map
12:41:33 <linman16> [..] :: [CharInt]
12:42:09 <kadoban> linman16: Then you can do it, and your 'double' function can work differently on CIInt vs. CIChar
12:42:20 <linman16> FireFly: that is a good idea
12:43:02 <linman16> kadoban: sure double handles both types. but then how is chars ultimately filtered?
12:43:30 <kadoban> Yeah, you'd have to filter.
12:43:49 <tulcod> linman16: you may be interested in GADTs
12:44:04 <linman16> was thinking of returning a list of each singular value, then concating. with empty list being ignored
12:44:08 <linman16> but filter is a better idea
12:44:35 <linman16> tulcod: yeah i'm interested. i'll look it up
12:44:46 * hackagebot usb 1.3.0.1 - Communicate with USB devices  http://hackage.haskell.org/package/usb-1.3.0.1 (BasVanDijk)
12:47:36 <akurilin3> question: how frequently does the .prof file generated by profiled executables save itself?
12:48:25 <akurilin3> Do I have to SIGINT it / reboot it somehow to get the file to be saved?
12:48:39 <geekosaur> afaik it only gets written at normal exit
12:49:46 * hackagebot pgp-wordlist 0.1 - Translate between binary data and a human-readable  collection of words.  http://hackage.haskell.org/package/pgp-wordlist-0.1 (quchen)
12:50:18 <mishac> Hi guys
12:50:26 <mishac> can I ask a few haskell questions?
12:50:36 <akurilin3> geekosaur: I have a web app I'm profiling, looks like I want to save it to some kind of file created with mktemp otherwise it will immediately wipe the contents of the .prof file as it rebbots
12:50:38 <akurilin3> *reboot
12:50:43 <akurilin3> or I have to keep the application down for a bit
12:50:46 <tdammers> mishac: just ask
12:51:04 <horny-sama> I guess the best way to prepare a haskell exam is to write the dam functions
12:51:38 <mishac> Do you know any essential data structures and algorithms that any aspiring haskell enthusiast must learn?
12:52:18 <horny-sama> mishac: factorial, fib ?
12:52:19 <c_wraith> nothing's essential that isn't covered in a standard CS course.
12:52:22 <horny-sama> quick sort?
12:52:26 <ChristianS> akurilin3: profiling massively slows the application down, i doubt it's a good idea to run it on a "live" web app
12:52:30 <c_wraith> But there's lots of cool stuff that isn't essential. :)
12:52:40 <avocado> mishac: purely functional data structures by okasaki is pretty good
12:52:59 <mishac> any specifics that have universal and nearly universal applciability
12:53:13 <mishac> I am familliar that finger trees are really really good in this regard
12:53:25 <mishac> so I wonder is there anything else?
12:53:33 <akurilin3> ChristianS: very true, but I'll need to give it a shot for a little bit to get some accurate data
12:53:36 <avocado> you probably know more than i do
12:53:39 * avocado goes back to menial work
12:53:51 <akurilin3> ChristianS: wish I already had a scaled-out system where I could make only one machine do profiling, alas... :)
12:54:13 <kadoban> mishac: Check out the okasaki book, "Furely Functional Datastructures", it's good and sounds vaguely like what you're asking for.
12:54:19 <kadoban> Purely*
12:54:25 <ChristianS> akurilin3: ah you just have no way to gracefully shutdown? hmm...
12:54:47 <akurilin3> ChristianS: I'll swap the binary in, run it for a bit, swap the normal binary back in after I'm done
12:55:14 <akurilin3> dropping a couple of hundred requests won't hurt anybody too much in the big scheme of things at this stage :P
12:56:56 <enthropy> people describe putting "import Prelude" last to make code compile without warnings with ghc-7.10
12:58:53 <quchen> enthropy: Could you expand on that? I use CPP to suppress these kinds of warnings.
13:00:44 <geekosaur> if you explicitly import Prelude, it suppresses the implicit import. since Prelude just pulls in the Control.Applicative definitions, the later import of Prelude will silently note they're already imported from Control.Applicative instead of warning or etc.
13:00:53 <mniip> I can't seem to wrap my head around dependency resoution
13:01:09 <enthropy> quchen: http://lpaste.net/130882 to me it seems that trick only works if you don't explicitly list anything from Data.Traversable
13:01:19 <mniip> I'm asking for 'transformers>=2.0.0.0', it says 'rejecting: transformers-0.3.0.0/installed-645'
13:01:47 <enthropy> which is bad because maybe there I need Prelude.sum to make return :: a -> [a]
13:01:50 <horny-sama> https://github.com/mr-fool/haskell/blob/master/examPractice/mylast%27.hs <---can someone give me a hand please. I basically reverse the last line of head' and it is blowing up on me and I can't quite figure out why
13:01:51 <horny-sama> :<
13:01:59 <quchen> enthropy: Why isn't Prelude a redundant import warning though?
13:02:03 <byorgey> mniip: does it say why?
13:02:23 <mniip> yeah, it says my package is asking for transformers>=2.0.0.0
13:02:40 <byorgey> mniip: can you paste the entire output somewhere?
13:02:58 <enthropy> quchen: I think it is redundant
13:02:59 <kadoban> horny-sama:  (:) is a constructor for a single element (on the left side) and a list (on the right side). You're pretending the right side is a single element. It's not.
13:03:06 <mniip> rejecting: transformers-0.3.0.0/installed-645..., 0.4.3.0, 0.4.2.0, 0.4.1.0, 0.3.0.0, 0.2.2.1, 0.2.2.0, 0.2.1.0, 0.2.0.0, 0.1.4.0, 0.1.3.0, 0.1.1.0, 0.1.0.1, 0.1.0.0, 0.0.1.0, 0.0.0.0, 0.4.0.0 (conflict: mypackage => transformers>=2.0.0.0)
13:03:27 <kadoban> :t (:)
13:03:28 <lambdabot> a -> [a] -> [a]
13:03:30 <geekosaur> horny-sama, you understanbd that the list [a,b] is actually (a : (b : [])) ?
13:03:39 <horny-sama> Geekingfrog: yes
13:03:44 <byorgey> mniip: no, please paste the *entire* output in a pastebin, e.g. lpaste.net
13:03:54 <geekosaur> so y is a list, not a single element
13:04:22 <horny-sama> okay
13:04:28 * horny-sama start shitting on his pants
13:04:29 <lpaste> mniip pasted â€œdependency stuffâ€ at http://lpaste.net/130884
13:04:42 <geekosaur> also you understand that pattern matching (a:b) does not give you the last element of the list?
13:04:51 <geekosaur> a will be the first element and b the rest of the list
13:04:53 <enthropy> all the people that +1 these base change proposals should be sending me patches to fix what they broke
13:04:58 <horny-sama> geekosaur: jsut learn that 
13:04:58 <int-e> mniip: why does your package depend on transformers>=2?
13:04:59 <horny-sama> :P
13:05:07 <horny-sama> from u
13:05:08 <horny-sama> :P
13:05:09 <enthropy> or maybe I should just turn off that redundant import warning
13:05:26 <quchen> mniip: Your dependency says >= 2.0.0.0, you've got flipped numbers in the beginning
13:05:30 <quchen> You probably mean 0.2.0.0
13:05:37 <mniip> oh
13:05:47 <mniip> oohhhh
13:05:49 <quchen> :-)
13:06:10 <byorgey> oh, haha, I hadn't even noticed that yet =)
13:06:11 <int-e> mniip: the message is essentially enumerating the versions of transformers that actually exist (as far as cabal-install knows)
13:06:37 <horny-sama> http://stackoverflow.com/questions/1199887/implementing-the-last-function <_--according this the type signature should be mylast :: [a] -> Maybe a
13:06:50 <horny-sama> but if I did :t last the type signature is [a] -> a
13:06:51 <geekosaur> re warnings, this was about C++ but certainly applies to Haskell: <kilobyte>	-Wall -Werror stands for "I don't care about portability"
13:06:52 <mniip> int-e, the zero at the beginning was my blind spot
13:06:56 <horny-sama> which one should I use?
13:07:04 <mniip> I was confused about how it went 4.0.0.0 < 2.0.0.0
13:09:27 <pavonia> horny-sama: The safe version with Maybe is preferable, but many Prelude functions like head, tail, last, etc. are partial
13:09:44 <horny-sama> pavonia: ok
13:09:46 * hackagebot csound-expression-dynamic 0.1.4.1 - dynamic core for csound-expression library  http://hackage.haskell.org/package/csound-expression-dynamic-0.1.4.1 (AntonKholomiov)
13:09:48 * hackagebot csound-expression-typed 0.0.7.3.1 - typed core for the library csound-expression  http://hackage.haskell.org/package/csound-expression-typed-0.0.7.3.1 (AntonKholomiov)
13:14:47 * hackagebot csound-expression 4.6.1 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-4.6.1 (AntonKholomiov)
13:19:47 <linman16> tulcod: the GADTs look very helpful
13:32:18 <mniip> let's try this...
13:34:03 <mniip> eh, I expected it to be more instant
13:34:47 * hackagebot acme-timemachine 0.0.0.0 - An easy way to perform and unperform IO actions.  http://hackage.haskell.org/package/acme-timemachine-0.0.0.0 (mniip)
13:35:55 <horny-sama> I need to unfuck myself from mixing haskell and prolog syntax
13:35:56 <fresheyeball> any lambda bot devs out there?
13:37:13 <pchiusano> question - I have {-# LANGUAGE DeriveGeneric #-} at the top of my file, but data Foo = Blah deriving Generic is complaining that " Not in scope: type constructor or class â€˜Genericâ€™"
13:37:42 <mauke> you didn't import Generic
13:37:43 <pchiusano> ghc 7.8.2
13:37:50 <geekosaur> import GHC.Generics ?
13:37:53 <pchiusano> ahâ€¦ 
13:38:23 <mniip> horny-sama, undo
13:38:32 <pchiusano> huzzah, that did it, thanks mauke and geekosaur
13:38:44 <mniip> or if you have a nearlier Suspension Universe, resume that
13:38:48 <mniip> earler*
13:38:55 <horny-sama> mniip: I mean the way of writing recursion is so similiar that you mix it up :<
13:49:47 * hackagebot np-extras 0.3.0.1 - NumericPrelude extras  http://hackage.haskell.org/package/np-extras-0.3.0.1 (BrentYorgey)
14:42:04 <horny-sama> tomorrow's exam is gonna be a killer. Gonna have to not mix up prolog, java and haskell
14:43:37 <moghedrin> Does threadDelay force a context switch if possible?
14:45:44 <hpc> my expectation would be that it yields immediately, yes
14:46:05 <hpc> not sure that "context switch" is the term i would use
14:46:43 <hpc> since that generally applies to multi-process
14:46:52 <moghedrin> hpc: You're right - what I meant to ask was whether or not it yields immediately. Bad phrasing.
14:46:55 <moghedrin> XD
14:49:52 <hpc> moghedrin: if you're really curious, you can use the source:
14:49:54 <hpc> http://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Conc-IO.html#threadDelay
14:50:35 <moghedrin> hpc: Oh. Right. I forgot I could look at that. I feel stupid.
14:51:50 <hpc> don't feel stupid, it's a bit of a rabbit hole
14:52:12 <dimsuz> hi. trying to get used to the do notation, I wanted to unwrap some simple stuff and it fails to compile, while in do notation it's ok. Please help me understand: http://paste.hskll.org/get/2525
14:52:48 <hpc> it looks like you just need (>>=) instead of (>=)
14:53:18 <dimsuz> oh god. one moment
14:53:49 <dimsuz> hpc: yay!
14:54:01 * dimsuz started hoogling about >=
14:54:23 <dimsuz> and I just couldn't understand where this Bool comes from :)
14:58:13 <arkeet> heh
14:59:41 <arkeet> btw
15:00:05 <arkeet> dimsuz: f >>= \r -> return ("hello" ++ r) 
15:00:13 <arkeet> = fmap ("hello" ++) f
15:00:25 <arkeet> I dunno why I called it f.
15:02:45 <dimsuz> arkeet: yeah, I know this is something called applicative, but I plan to learn it in more depth - next thing :)
15:03:48 <dimsuz> hoogle still didn't clear for me what '>=' is, it seems to not have a docstring for it, just lists it as one of instance methods
15:03:53 <arkeet> actually fmap is just Functor
15:04:05 <arkeet> > 5 >= 3
15:04:06 <lambdabot>  True
15:04:12 <arkeet> :t (>=)
15:04:13 <lambdabot> Ord a => a -> a -> Bool
15:04:17 <arkeet> it's just "greater than or equal"
15:04:28 <dimsuz> hahaha, I'm silly (its midnight after all)
15:04:42 <dimsuz> I thought it's some fancy monad operator
15:04:46 <arkeet> :p
15:05:19 <dimsuz> I've read about functors and applicative, but I feel like I need to actually use them in practise to grasp better
15:05:39 <trolling> play with their actual instances
15:05:53 <trolling> after a bit you'll see how the operations generalise, but start with specifics
15:05:58 <arkeet> mhm
15:06:03 <trolling> like what the reader applicative does, or maybe, rather than "applicatives"
15:06:22 <arkeet> Functor comes first.
15:06:33 <arkeet> try to fully understand it before moving on to Applicative/Monad
15:07:36 <quchen> My advice is skipping Applicative, and going from Functor to Monad directly. When you're comfortable with Monad you see that it's often too powerful, and less is enough as well. That's when Applicative starts making sense.
15:07:43 <arkeet> perhaps.
15:08:10 <oconnore> so, my program doesn't throw an "Error: thread blocked indefinitely in an MVar operation" when I add putStrLn statements, but it does, sometimes, when I don't.
15:08:23 <dimsuz> I feel like I'm already comfortable with Monad, I write some parsec parser as we speak
15:08:25 <arkeet> anyway, looking at lots of examples for these things is probably the best way to get intuition for them.
15:08:38 <arkeet> mhm
15:08:44 <oconnore> is that a runtime bug, or could I be doing something to cause that?
15:09:47 <arkeet> oconnore: sounds like you have a deadlock problem.
15:24:48 * hackagebot cabal-debian 4.27 - Create a Debianization for a Cabal package  http://hackage.haskell.org/package/cabal-debian-4.27 (DavidFox)
15:41:04 <NemesisD> i think i found a bug in the containers doc, i'm hoping someone can show me that i'm not right: http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Map-Strict.html#g:6 it says insert == insertWith const, but insertWith const says the combining function f is f new_value old_value
15:41:59 <NemesisD> oh wait, i wrote it out and they're right, const would ellide the *second* arg not the first
15:44:48 * hackagebot Spock 0.7.9.0 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.7.9.0 (AlexanderThiemann)
15:59:48 * hackagebot language-ecmascript 0.17.0.1 - JavaScript parser and pretty-printer library  http://hackage.haskell.org/package/language-ecmascript-0.17.0.1 (AndreyChudnov)
16:05:40 <EponymicCycloid> Is there any way to write two versions of a function, depending on if a type satisfies a constraint? Use case: I'm testing a data structure T :: * -> *, and the tests for (Floating a) => T a need to be different from the tests for (Â¬ Floating a) => T a. 
16:06:03 <mniip> with some typeclass magic, yes
16:06:24 <mniip> https://wiki.haskell.org/GHC/AdvancedOverlap
16:07:33 <broma0> Does anyone have some familiarity with the scotty library? I'm wondering how set the "root" directory for served html files
16:07:51 <EponymicCycloid> I like how Haskell's support for ' as a name element confuses a lot of syntax highlighters
16:09:35 <ij> How do I use Numeric.readHex?
16:09:46 <EponymicCycloid> Thanks for the article mniip, but that looks a bit excessive for me haha
16:10:20 <Cale> EponymicCycloid: Just the really terrible ones :P
16:10:42 <srhb> > readHex "abc" [(Int, String)]
16:10:43 <lambdabot>      Not in scope: data constructor â€˜Intâ€™
16:10:43 <lambdabot>      Perhaps you meant one of these:
16:10:43 <lambdabot>        â€˜Inâ€™ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
16:10:55 <srhb> Say what now
16:10:57 <srhb> Oh
16:11:01 <srhb> > readHex "abc" :: [(Integer, String)]
16:11:02 <lambdabot>  [(2748,"")]
16:11:13 <Cale> EponymicCycloid: and yeah, not really -- you can never insist with confidence that an instance of a class doesn't exist, while compiling a module
16:11:24 <EponymicCycloid> Cale: True
16:11:26 <Cale> EponymicCycloid: because a future module might provide that instance
16:11:35 <sebastianrkg> Is there a clever way to write an Ord instance for a type with a ton of constructors?
16:11:43 <srhb> ij: [] plays the role of Nothing in case nothing could be parsed.
16:11:50 <EponymicCycloid> sebastianrkg: "deriving Ord"
16:11:51 <srhb> sebastianrkg: deriving (Ord) ?
16:12:06 <sebastianrkg> haha but for a type from a library that isn't mine
16:12:11 <EponymicCycloid> yes
16:12:20 <sebastianrkg> specifically XNode: https://hackage.haskell.org/package/hxt-9.3.1.1/docs/Text-XML-HXT-DOM-TypeDefs.html#t:XmlTree
16:12:21 <EponymicCycloid> {-# LANGUAGE GeneralizedNewtypeDeriving #-}
16:12:32 <EponymicCycloid> instance Class Ord where
16:12:37 <EponymicCycloid> I think that will auto-generate it
16:12:40 <ij> srhb, Got it. Somehow it didn't click that it's a function â€” didn't see a -> in ::, even though I saw the type.
16:12:49 <EponymicCycloid> Oh wait, nevermind, that only works for newtypes
16:12:57 <ij> I mean I saw the "type ReadS a =" definition.
16:13:22 <srhb> sebastianrkg, EponymicCycloid: StandaloneDeriving?
16:13:56 <srhb> sebastianrkg: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/deriving.html#stand-alone-deriving
16:15:59 <nuttycom> Has anyone here ever used postgresql-simple to access columns of postgres enum type? How does one go about writing the FromField instance that can be used to retrieve data from such a column? I've attempted decoding from Text and ByteString, but I get an Incompatible error thrown.
16:16:38 <ij> Can regex-tdfa substitute?
16:17:38 <srhb> ij: Sure, or Data.Text.Read from text, which is more common
16:18:58 <sebastianrkg> srhb, EponymicCycloid: Thanks, that seems to have worked. Much appreciated.
16:19:32 <ij> srhb, You mean D.T.R subtitutes?
16:19:51 <srhb> ij: Oh sorry. I misunderstood your question.
16:19:57 <srhb> ij: No.
16:20:52 <ij> Ok, thanks.
16:23:40 <ij> Hmm, it looks like Text.Regex doesn't accept function for subtitutions. 
16:23:51 <ij> That's disappointing.
16:26:01 <d-snp> man state monads make everything so awkward
16:27:03 <ij> Suppose, I want to map all hexadecimal numbers through flip xor 255. This feels like a job for a regex lens, though seems it doesn't exist.
16:27:16 <ij> Are there other approaches?
16:27:35 <edwardk> such a lens would violate the lens laws
16:27:42 <edwardk> same for a traversal
16:28:04 <edwardk> not that this should stop you from writing them
16:28:09 <edwardk> just be sure to document that fact ;)
16:28:56 <ij> Ii'm guessing you've lens on highlight?
16:29:10 <edwardk> i plead the fifth
16:29:17 <ij> :)
16:30:28 <jmcarthur> lens lens lens
16:30:53 <srhb> d-snp: How so?
16:32:08 <ij> Yeah, view l (set l b a) = b wouldn't be true. 
16:35:02 <d-snp> srhb: well, I had everything I needed nicely defined in a where clause, and the result was a single line so no need for a do block
16:35:21 <d-snp> but then I realized I needed some state
16:35:35 <d-snp> so I have a do block, and a somethings <- gets 
16:35:50 <d-snp> and then I need to get that value into my definitions in the where clause
16:36:05 <srhb> d-snp: lets are usually better for that.
16:36:50 <d-snp> hmm I suppose so
16:37:13 <srhb> d-snp: Because you can do { foo <- ...; let bar = baz foo; ... }
16:37:48 <d-snp> alright I'm going to try that now
16:38:57 <srhb> d-snp: Often you can get away with some creative functor usage on the rhs of <- and not need a let block at all.
16:39:28 <d-snp> the let worked, much nicer than my other solution
16:39:29 <d-snp> thanks :)
16:39:42 <d-snp> creative functor usage?
16:40:21 <lpaste> d-snp pasted â€œlet syntax for state monadâ€ at http://lpaste.net/130891
16:40:30 <d-snp> that's what it looks like now
16:41:09 <d-snp> don't mind the awful function names, I'm glueing two libraries of other authors together
16:41:15 <d-snp> names are a total nightmare :P
16:46:51 <cfoch> Hello
16:47:05 <cfoch> I've written this post today about HaskellSrcExtensions
16:47:17 <cfoch> Maybe it could be useful for someone
16:47:18 <cfoch> http://cfoch-dev.tumblr.com/post/116657796367/analyzing-the-parseresult-of
16:47:23 <cfoch> (some day)
16:47:25 <cfoch> :)
16:48:14 <buckmaster> hey, does anyone know of an alternative to deb.haskell.org? I'm trying to install GHC profiling packages on debian from https://launchpad.net/~hvr/+archive/ubuntu/ghc
16:56:05 <athan> Can someone show me an example of a multi-line LANGUAGE pragma?
16:57:52 <Kron> @athan: https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/rewrite-rules.html
16:57:52 <lambdabot> Unknown command, try @list
16:57:58 <Kron> athan: https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/rewrite-rules.html
16:58:01 <Kron> rewrite rules
16:58:38 <Kron> can anyone tell me what happens if you try to derive Ord on a data type with nullary constructors mixed with unary ones?
16:58:48 <athan> Kron: Oh, the #'s need to line up. Thank you
16:58:51 <Kron> data Foo = Blah | Bloo Int | Blee deriving Ord
16:59:03 <athan> Kron: Usually the first declared are "least"
16:59:19 <arkeet> Kron: the first constructor is always less than the second constructor
16:59:20 <Kron> will it declare Blah to be lower than all Bloos, all Bloos lower than Blee
16:59:22 <arkeet> which less than the third
16:59:23 <arkeet> and so on
16:59:25 <Kron> and the Bloos are compared via the ints?
16:59:28 <arkeet> yes
16:59:34 <Kron> hah, perfect
16:59:42 <Kron> that makes writing a utility type really trivial
16:59:49 <arkeet> if you have multiple arguments to a constructor it compares them in order
16:59:55 <Kron> data Utility = Lose | Draw | Ongoing Int | Win deriving Ord
17:00:01 <Kron> then I can just max on searching
17:00:04 * Kron whistles
17:01:25 <EvanR> data Labor
17:04:49 * hackagebot LambdaHack 0.4.101.1 - A game engine library for roguelike dungeon crawlers  http://hackage.haskell.org/package/LambdaHack-0.4.101.1 (MikolajKonarski)
17:05:07 <Twiggles> Hello again!  I have a nxm char matrix represented using list of lists and I am interested in rotating the contents by 45 degrees. I've been able to do 90 degrees easily enough with transpose. Does anyone happen to know some functions that can accomplish what I am looking for?
17:06:18 <arkeet> what does it mean to rotate by 45 degrees?
17:06:19 <Kron> hmmm, I'm not sure if that question is even well formed
17:06:19 <koala_man> Twiggles: how does that work? 
17:06:21 <Kron> yeah
17:06:24 <Kron> like I can't even imagine that
17:06:38 <Kron> let's say you have this matrix, okay:
17:06:41 <Kron> 12
17:06:41 <Kron> 34
17:06:44 <Kron> how do you rotate that?
17:06:48 <arkeet>  1
17:06:48 <Kron> what's the 45 degree turn?
17:06:49 <arkeet> 3 2
17:06:49 <arkeet>  4
17:06:52 <Kron> lol
17:06:53 <EvanR> you can rotozoom
17:06:57 <Twiggles> arkeet: yes
17:07:04 <arkeet> that's not a matrix.
17:07:06 <Kron> oh, you mean printing?
17:07:11 <EvanR> a default value goes somewhere which transforms outside the original zone
17:07:12 <Kron> do you mean PRINT it at a 45 degree angle?
17:07:27 <Kron> becausethis is no longer a matrix
17:07:36 <Kron> unless you mean, like ["1", "32", "4"]
17:07:41 <Twiggles> Kron: , I do
17:07:48 <Kron> aha
17:07:49 <Twiggles> well, 1  23 4
17:07:57 <Kron> no, 32
17:07:58 <arkeet> I wasn't even being serious.
17:08:00 <Twiggles> oh sorry, your representation has 32
17:08:01 <arkeet> haha
17:08:03 <koala_man> so a list of diagonals basically. how about for non-square matrices?
17:08:10 <Kron> okay, I see what your perspective is here
17:08:19 <Twiggles> koala_man: it is nxm, nonsquare
17:08:24 <Twiggles> err can be
17:09:04 <schell> is anyone actively writing iOS applications in haskell?
17:09:08 <Kron> the basic trick is this: each new row has elements whose indices have the same sum (measuring from top left in this case)
17:09:13 <Twiggles> If I may link, I have found this in regards to javascript http://stackoverflow.com/questions/22236852/rotate-a-matrix-45-degrees-in-javascript
17:09:26 <Twiggles> but I am struggling with the Haskell, and obviously forming a proper question ;)
17:09:32 <Kron> top left is (0,0), top right and bottom left are (0,1) and (1,0), bottom left is (1,1). {0, 1, 2} sums
17:09:49 * hackagebot Allure 0.4.101.1 - Near-future Sci-Fi roguelike and tactical squad game  http://hackage.haskell.org/package/Allure-0.4.101.1 (MikolajKonarski)
17:09:55 <Kron> think about decomposing the system into a new one based on index sums
17:10:27 <Twiggles> since these are lists of lists, is it appropriate to use indices in this scenario?
17:10:46 <Kron> ideally you'll want to use an array for efficiency
17:10:55 <Kron> but yeah you can still write your own indexing function
17:10:57 <arkeet> nah you can do it with just lists.
17:11:00 <arkeet> and no indices.
17:11:20 <Kron> hmm, how?
17:11:29 <arkeet> cleverly.
17:11:30 <Kron> wait I think I can see how
17:11:50 <Kron> start with a new accumulating list of lists that's empty
17:12:06 <Kron> each recursive iteration you add a new list in from the original matrix and then shave all the first elements off into a new row
17:12:19 <Kron> repeat until the accumulator is empty and you have no new lists to add
17:12:38 <arkeet> yeah something like that
17:12:41 <Kron> right
17:12:44 <Kron> that is clever
17:12:46 <Kron> I like it
17:12:49 * Kron shakes head
17:12:56 <Kron> sorry, I'm literally working on immutable array code right now
17:12:59 <arkeet> haha
17:13:01 <Kron> hard to shake the representation
17:13:06 <Kron> chess engines woo!
17:13:25 <Twiggles> would you be willing to assist me on the haskell side of your algorithm?
17:14:49 * hackagebot Win32-dhcp-server 0.3.1 - Win32 DHCP Server Management API  http://hackage.haskell.org/package/Win32-dhcp-server-0.3.1 (MichaelSteele)
17:15:00 <Kron> sure
17:20:57 <dufus> :t (!!)
17:20:58 <lambdabot> [a] -> Int -> a
17:22:10 <dufus> Is there a way to replace an element in a list?  I.E. get is-to (!!) as put is to what?   
17:22:34 <EvanR> you have to splitAt and concat
17:22:43 <koala_man> if you want to modify a regular list, chances are you'd be better off with a different data structure
17:22:56 <dufus> ps, I know I'm not really "replacing", just getting a copy
17:23:09 <EvanR> try Data.Sequence
17:23:13 <Hijiri> you can get a modified copy more efficiently with other structures
17:23:29 <dufus> Yeah, I know that, but that's not what I'm asking.... Of course I could just roll my own...
17:23:52 <EvanR> theres no library function for it
17:23:56 <EvanR> its not encouraged
17:24:15 <Hijiri> do you just want to not do anything if the list is smaller than where you want to change
17:24:35 <dufus> neither is (!!) :-)
17:24:53 <pavonia> It's funny to see all these verbose answers in that rotate link above when in Haskell you can solve that with a short one-liner
17:25:05 <dufus> yeah, just like (!!)
17:25:14 <Twiggles> pavonia: really?
17:25:45 <pavonia> I think so
17:26:47 <Hijiri> (!!) is discouraged because it's partial
17:27:07 <hpc> also slow as bananas
17:27:19 <dufus> so is head
17:27:35 <Hijiri> yep
17:27:38 <hpc> head is discouraged too
17:28:10 <athan> What does it mean for a functor to be "digestive"?
17:28:15 <athan> jaspervdj: ^ ?
17:28:17 <solrize_> projects.haskell.org is responding really painfully slowly
17:28:18 <Twiggles> pavonia: i'd be curious to know if you think of it
17:32:24 <pavonia> Twiggles: Do you want me to post my version or find one yourself first?
17:32:44 <Twiggles> pavonia: I would be interested in your version if you are willing
17:33:32 <pavonia> Is that homework?
17:34:40 <Kron> http://lpaste.net/130893
17:34:43 <Kron> here's my quick version
17:35:15 <Twiggles> It is related to an contest problem I am attempting to solve but I've translated it into something else so I can understand the concept behind it and apply it to what I am doing
17:35:36 <Twiggles> if that makes sense
17:36:07 <pavonia> > map (filter (/= ' ') . reverse) . transpose . zipWith (++) (iterate (' ':) []) $ ["123", "456", "789"]
17:36:09 <lambdabot>  ["1","42","753","86","9"]
17:36:33 <Kron> that is beautiful.
17:36:36 <arkeet> > map reverse . transpose . zipWith (++) (iterate (' ':) []) $ ["123", "456", "789"]
17:36:37 <lambdabot>  ["  1"," 42","753","86","9"]
17:38:39 <Twiggles> okay, that is going to take me a while to digest
17:42:20 <Kron> is there a takeUntil function?
17:42:29 <Kron> takeWhile plus the element that stopped the search
17:45:19 <EvanR> you mean Maybe the element
17:46:00 <athan> Haddock still doesn't support -- ^ for GADT data constructors? :\
17:46:41 <Twiggles> arkeet, Kron, pavonia: thank you
17:51:47 <Twiggles> pavonia: so it looks like you skewed the matrix with padding, rotated clockwise, and then filtered out the padding you introduced
17:52:00 <Twiggles> is this a correct understanding?
17:53:11 <pavonia> Yeah, the transposition + map reverse has the effect of a rotation
17:53:34 <Twiggles> fantastic
18:03:17 <octalsrc> is there a strict foldM, like foldl' for foldl?
18:03:17 <octalsrc> or does foldM end up being already strict?
18:10:14 <slack1256> I though the strictness of foldM dependended on the strictness of the monad
18:10:25 <slack1256> as in the difference between State.Lazy and State.Strict
18:10:27 <buckmaster> anyone have any idea why I might be allocating like 1G of RAM to parse an 8MB CSV file?
18:10:41 <buckmaster> I'm heap profiling at the moment, but all I can tell is the space is being used by... bytestrings?
18:11:04 <octalsrc> slack1256: that seems likely
18:11:07 <octalsrc> thanks
18:11:53 <pavonia> buckmaster: Did you write your own parser or are you using a package for that?
18:11:54 <ReinH> Fun story: foldlM uses foldr and foldrM uses foldl.
18:12:18 <ReinH> (foldM is foldlM)
18:12:45 <buckmaster> pavonia: I'm using cassava
18:12:51 <octalsrc> ReinH: somehow I'm not surprised
18:13:15 <buckmaster> which is based on attoparsec
18:14:08 <pavonia> buckmaster: Can you show some code?
18:14:17 <slack1256> ReinH: holy buckets
18:14:41 <buckmaster> pavonia: https://github.com/eightyeight/nearest_neighbour/blob/haskell-improvements/haskell/haskell-k-nn.hs
18:14:57 <buckmaster> I'm trying to optimise someone else's program, which is a simple k-nearest-neighbours deal
18:15:04 <buckmaster> learning about RTS flags!
18:17:35 <buckmaster> here's a heap profile: http://i.imgur.com/pfRIu16.png
18:18:49 <buckmaster> I assume the mutable array stuff are the unboxed vectors of features inside the Observations, but I can't work out why there's so much bytestring hanging about, or why it needs so much memory when parsing
18:21:01 <tar_> If I have foo :: State Cache String and bar :: State Cache Int, is there a way to call foo from bar without taking the cache out with runState and putting it back in with put?
18:22:26 <tar_> umm, never mind. I must have made a typo somewhere.
18:22:58 <slack1256> Not with trollish intentions. But does anybody use the Foldable instance of Maybe?
18:23:12 <slack1256> Better asked. Does anybody think of Maybe as a list?
18:28:15 <pavonia> buckmaster: I can only guess that it's allocating much more new vectors than the GC is able to collect old ones
18:28:26 <buckmaster> hm
18:28:38 <buckmaster> I just did another test - just orinted out the data after parsing it
18:28:52 <buckmaster> using strinct bytestrings I should say
18:29:18 <buckmaster> there's a tiny peak then a massive one - the reading seems fine but then the parsing must generate a ton of stuff
18:29:19 <buckmaster> hrm
18:29:37 <SrPx> Hey I believed Data.Sequence was supposed to be used as an intermediate structure when you are using (++) a lot (say, when flattening a tree to a list), but I couldn't find a "toList" function to retrieve the result. Did I miss something?
18:29:50 * hackagebot pred-trie 0.0.1 - Predicative tries  http://hackage.haskell.org/package/pred-trie-0.0.1 (athanclark)
18:33:22 <pavonia> SrPx: It's in Data.Foldable
18:33:40 <pavonia> :t toList
18:33:41 <lambdabot> IsList l => l -> [Item l]
18:33:49 <pavonia> :t Data.Foldable.toList
18:33:50 <lambdabot> Foldable t => t a -> [a]
18:34:47 <pavonia> > Data.Foldable.toList (Data.Sequence.singleton 'a')
18:34:49 <lambdabot>      Not in scope: â€˜Data.Foldable.toListâ€™
18:34:49 <lambdabot>      Perhaps you meant â€˜Data.Foldable.foldâ€™ (imported from Data.Foldable)Not ...
18:35:10 <pavonia> Err, what?
18:36:15 <SrPx> I'm glad to know toList is on foldable but I'm sad to know it's not
18:37:02 <pavonia> What do you mean?
18:38:15 <SrPx> ah nevermind, I read it wrong
18:39:00 <SrPx> unrelated question, is there any binary space partitioning structure on hackage? Specifically, I want to add elements using bitvectors as keys
18:39:23 <pavonia> If you mean the lambdabot error ... yeah, I'm wondering too
18:40:03 <SrPx> so for example, I could add the string "a" with key [1,0,0,1,0,1,1] and then I could query for all elements with a key starting with [1,0,0,1]
18:40:26 <SrPx> I know this is trivial to create with binary trees, just don't want to reinvent the wheel?
18:54:41 <tejing> is there a way to get around the fact that you can't change the type of the state value in the State monad?
18:55:35 <arkeet> you need something a bit more general than a monad to express that.
18:56:15 <tejing> yea, I suppose you do
18:56:51 <arkeet> there's something called an indexed monad
18:57:26 <arkeet> https://hackage.haskell.org/package/indexed-0.1/docs/Control-Monad-Indexed.html
18:57:28 <arkeet> https://hackage.haskell.org/package/indexed-extras-0.1.1/docs/Control-Monad-Indexed-State.html
18:57:50 <arkeet> well, regular State is like State s a = s -> (a,s)
18:58:01 <arkeet> so instead you have IxState s t a = s -> (a,t)
18:58:15 <arkeet> and you can only sequence state actions that have compatible state types.
18:59:10 <arkeet> uh, trying to find an article
18:59:40 <arkeet> ah yes http://lambda-the-ultimate.org/node/4273
19:01:33 <tejing> interesting...
19:01:49 <tejing> gonna go bury myself in those for a while :-)
19:03:02 <buckmaster> pavonia: FYI I added bangs to both members of Observation and the heap usage is now 50MB :p
19:03:06 <buckmaster> if only I understood why
19:03:38 <pavonia> Oh wow
19:05:47 <buckmaster> I think the FromRecord instance is doing something funny and keeping lots of intermediate bytestrings, I guess
19:13:38 <buckmaster> what's the difference between 'maximum residency' and 'total memory in use' in GHC's -s profile?
19:14:45 <hpc> maximum residency is what any other profiler would call "peak memory use"
19:15:08 <buckmaster> hm ok
19:15:25 <buckmaster> time -f '%M' is showing 130MB, which is the number I get from 'total memory in use'
19:15:31 <buckmaster> but max residency is about half that
19:17:08 <hpc> not sure, not totally familiar with profiling
19:22:11 <pharpend> edwardk: Your lecture on semantic editor combinators was really something to behold. My code has more "fmap.fmap.traverse.fmap fmap . fmap (. .)"s than ever before
19:22:40 <Javran> what does "whole program" in "whole program optimization" mean?
19:23:06 <Javran> is that saying defintions in that program is closed?
19:23:42 <pharpend> edwardk: That sounded like a backhanded insult, oops. No, it really makes my code a lot cleaner though. Substantially fewer 'do' blocks
19:26:18 <octalsrc> semantic editor combinators?
19:26:18 <octalsrc> that sounds interesting
19:26:56 <pharpend> octalsrc: it's fancy speak for combining polymorphic combinators with (.)
19:27:02 <pharpend> :t fmap
19:27:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:27:04 <pharpend> :t fmap . fmap
19:27:05 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:27:10 <pharpend> :t fmap . fmap . fmap
19:27:11 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
19:27:35 <arkeet> this is the origin of that term I think http://conal.net/blog/posts/semantic-editor-combinators
19:27:51 <pharpend> octalsrc: So, if you have the type IO Maybe [x], you can use fmap.fmap.fmap to get at an individual 'x'
19:28:18 <octalsrc> oh
19:28:29 <octalsrc> those can get tricky
19:28:38 <pharpend> octalsrc: very tricky. That's why edwardk wrote lens
19:29:04 <arkeet> or if you have several nested record types
19:29:11 <arkeet> if you're getting, you can just compose the accessor functions
19:29:17 <pharpend> octalsrc: ^ Yes,that's the main reason
19:29:18 <arkeet> but it normally really sucks for setting
19:29:33 <arkeet> which lenses solve very nicely
19:29:57 <octalsrc> I really need to learn to use lens
19:30:02 <pharpend> IMO, The law of demeter should prevent you from doing that in the first place
19:30:54 <pharpend> octalsrc: edwardk's talk is good, but very dense. I think johnw_ wrote an article for FP Complete that is really good
19:31:16 <pharpend> octalsrc: https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial . Not johnw_, it was Joseph Abrahamson
19:31:32 <octalsrc> thanks!
19:32:52 <jmcarthur> Javran: it means that optimizations are performed which take the whole program into account, not just a single module at a time
19:33:27 <jmcarthur> Javran: a lot of optimizations are impossible when you don't even know how the function is to be used
19:33:44 <Javran> jmcarthur: sort of like including all source codes?
19:33:52 <jmcarthur> basically
19:34:33 <Javran> I see, it's like a closed program so all usages are known .. good for analysis?
19:34:46 <Javran> and optimization
19:37:29 <tar_> in MaybeT IO a, return seems analogous to Just. What's the analog of Nothing?
19:37:48 <buckmaster> hpc: thanks anyway, appreciate it :)
19:38:13 <pharpend> tar_: mzero
19:38:37 <pharpend> tar_: Or fail, but the error message would be ignored
19:38:44 <buckmaster> tar_: fail?
19:38:55 <buckmaster> oh heh
19:40:02 <tar_> Thanks! This makes sense.
19:40:40 <carter> whole program analysis is kinda crazy :)
19:42:00 <ldesgoui> Greetings ! I was wondering if anybody could explain to me why my function stops an "interact" when something like "id" does not ?
19:43:48 <pavonia> ldesgoui: What is your function?
19:44:16 <ldesgoui> It gives the result of a simple parsec parser
19:45:10 <pavonia> I don't understand the problem, could you paste some code that shows the issue?
19:45:13 <pavonia> @lpaste
19:45:13 <lambdabot> Haskell pastebin: http://lpaste.net/
19:45:25 <ldesgoui> Sure, thanks
19:46:34 <ldesgoui> there: http://lpaste.net/1871047204798464000
19:46:48 <ldesgoui> feel free to make any comments on my code as well :D
19:47:55 <ldesgoui> but yeah, "interact solve" just stops after the first line sent, and it seems weird to me, as something like "interact id" doesnt
19:48:24 <pharpend> ldesgoui: Have you heard of optparse-applicative
19:48:26 <pharpend> ?
19:48:47 <ldesgoui> Not really, no?
19:49:02 <pharpend> @hackage optparse-applicative
19:49:02 <lambdabot> http://hackage.haskell.org/package/optparse-applicative
19:49:21 <pharpend> ldesgoui: takes some of the tedium out of defining option parsers
19:49:57 <ldesgoui> Oh, for the argument parsing, yeah I guess that would be better, but it's a really simple program I don't think it would be that much of a help. I'll be sure to use it next time, thanks :)
19:51:24 <ldesgoui> oh wait, is it because my parser is trying to reach a something like a newline character, cannot, and therefore has emptied out the getContents ?
19:54:13 <monochrom> enter newlines to find out
19:54:47 <ldesgoui> what do you mean?
19:56:59 <pharpend> ldesgoui: He means "try it and see"
19:57:43 <ldesgoui>  Well, sending newlines would just give me a parse error, and on the interact it just stops after the first error
19:58:31 <ldesgoui> s/first error/first parse/
20:03:02 <pavonia> Btw, when does "interact id" finishes?
20:03:27 <ldesgoui> on CTRL+D
20:04:54 <pavonia> Hhm, that doesn't seem to work on Windows :/
20:05:42 <ldesgoui> Ah :/ Thanks for trying anyways, I'll just have to deal with the unlines+lines.
20:18:07 <DanC> what's the trick for getting from cabal 1.16.0.2 to something current? I get Could not find module `Data.Binary.Put' when I try `cabal install cabal`
20:21:19 <DanC> I think I found it...
20:21:21 <DanC> Sep 02 21:34:49 <geekosaur>	DanC__, ~/.cabal isn't what needs to be removed. ~/.ghc is
20:22:22 <DanC> I seem to be winning now...
20:27:54 <DanC> hmm... `cabal install cabal` finished, but I don't see anything in ~/.cabal/bin
20:28:30 <gp5st> so, this isn't a haskell specific question, but I figured you guys would be able to point me in the right place. Are there type systems that specify the length of an iterable object?
20:29:06 <DanC> dependent types, yes
20:29:12 <DanC> cf Agda, idris, ...
20:29:23 <DanC> and scala, I suppose
20:29:55 <dfeuer> Scala has dependent types?
20:30:09 <gp5st> oooo, interesting!
20:30:11 <gp5st> thank you:)
20:30:23 <DanC> yes, scala's type system has all sorts of wierd stuff.
20:30:23 <Ralith> don't forget Coq
20:30:28 <DanC> seen scalaz?
20:30:38 <dfeuer> Heard of it; never actually touched it.
20:30:48 <DanC> all sorts of type-level programming
20:34:26 <DanC> I might be confusing scalaz with https://github.com/milessabin/shapeless
20:35:48 <sgwizdak> ok, let's say I'm in a bad state cabal-wise -- how do I nuke and restart? I attempted to delete .cabal, and .ghc, reinstalled haskell platform, and now nothing installs
20:36:11 <DanC> .ghc and .cabal are it, AFAIK
20:36:37 <HeladoDeBrownie> keep in mind that if you had updated cabal, you will need to update it again after deleting .cabal. also your config will be gone.
20:36:37 <sgwizdak> sigh :-(
20:36:53 <horny-sama> cna someone please explain to me what Just does?
20:36:55 <HeladoDeBrownie> cabal update && cabal install cabal-install
20:37:04 <horny-sama> is it the then case?
20:37:10 <HeladoDeBrownie> horny-sama, it's the "there's an element" case.
20:37:12 <DanC> Just is one of the constructors of the Maybe type.
20:37:35 <horny-sama> HeladoDeBrownie: okay
20:37:36 <horny-sama> comrad3
20:37:37 <horny-sama> e
20:38:25 <HeladoDeBrownie> horny-sama, does that help? are you confused about something else?
20:38:37 <horny-sama> HeladoDeBrownie: I think I overthink it
20:39:00 <HeladoDeBrownie> horny-sama, Maybe a represents either the presence of a single a (Just), or its absence (Nothing).
20:39:26 <horny-sama> HeladoDeBrownie: kinda for error prevention?
20:39:53 <HeladoDeBrownie> well, you can think of it in a way as sort of a "controlled null", where instead of having null be pervasive, it is announced exactly where it's needed.
20:40:11 <HeladoDeBrownie> and in those cases you have things that result in Maybe Whatever instead of Whatever.
20:40:15 <horny-sama> got it
20:42:22 <sgwizdak> HeladoDeBrownie: cabal install cabal-install fails due to HTTP-4000.2.10...
20:44:29 <HeladoDeBrownie> sgwizdak, hmm, maybe ghc and cabal versions are mismatched? not sure. incidentally, what versions do they say? ghc -V ; cabal -V
20:45:03 <sgwizdak> ghc = 7.8.3, cabal-install is 1.22.2.0
20:46:49 <HeladoDeBrownie> i have the same versions, i'll try updating cabal, i bet there's a more recentâ€¦
20:47:21 <HeladoDeBrownie> (also i know my setup functions properly for sure)
20:48:45 <jle`> gp5st: you can have a data type that has its length in the type, too
20:49:19 <gp5st> jle`: oh?
20:49:20 <jle`> gp5st: data Pair a = P a a, is something iterable that only has two elements
20:49:25 <jle`> for a simple example
20:50:31 <jle`> for a slightly more complex example, you can have type-level numbers, like () meaning "zero" and `S a` meaning "one more than a", and you can encode the number 3 as S (S (S (())).  then you can make types that take something like that as a parameter
20:50:51 <sgwizdak> HeladoDeBrownie: more annoyingly, I can't install anything without a myriad of failures, which makes me suspect something is seriously fubared on my setup 
20:50:52 <HeladoDeBrownie> my upgrade to 1.22.2 was successful. sorry, not sure what the problem could be
20:50:53 <jle`> so the full type, `Vec n a`, has `n` as a type that tells you how many elements is in there
20:51:14 <gp5st> jle`: ah. how is that different from a dependent type?
20:51:24 <jle`> this isn't dependent typing, but thit is a way to have the type itself specify how many items.  `Vec 3 a` is different than `Vec 5 a`...they're different types
20:51:29 <jle`> and they have different "slots"
20:51:34 <sgwizdak> HeladoDeBrownie: well, that sucks. This is a fresh install on a fresh os
20:51:38 <gp5st> jle`: because what you're describing is what I was playing with in this little thing I'm designing
20:51:57 <HeladoDeBrownie> sgwizdak, what os?
20:52:02 <sgwizdak> HeladoDeBrownie: osx
20:52:14 <jle`> it's not really dependent typing because the types are all fixed as-they-are
20:52:23 <jle`> you aren't branching on a new type based on the return type of a function
20:52:33 <jle`> i mean, the return value of a function
20:52:34 <HeladoDeBrownie> mine is linux-based. i'm not aware of what the differences in procedures ought to be
20:52:43 <jle`> the return type of a function is independent of any value it might be
20:52:44 <gp5st> ah
20:52:54 <jle`> ...at least i think that's the main reason
20:53:33 <HeladoDeBrownie> a dependent type would let you name the value in addition to the type and use it in the type expression, i believe
20:53:34 <dfeuer> jle`, HeladoDeBrownie, can either of you help DanC with that Cabal issue?
20:53:48 <DanC> rm -rf ~/.ghc
20:53:50 <DanC> that did it
20:54:16 <dfeuer> DanC, from all I've heard, nuking .cabal is rarely if ever a good idea. Nuke .ghc.
20:54:40 <sgwizdak> dfeuer: so, let's say you did take out .cabal
20:54:47 <HeladoDeBrownie> DanC, did you actually enter `cabal install cabal`? the cabal executable is provided by the cabal-install package
20:54:48 <sgwizdak> dfeuer: how would I just restart from scratch?
20:55:16 <DanC> I used Ubuntu's cabal to start
20:55:38 <HeladoDeBrownie> DanC, that's fine; you'll likely want to upgrade it using itself anyway though.
20:55:53 <dfeuer> sgwizdak, I am NOT the right person to ask Cabal questions.
20:55:54 <HeladoDeBrownie> your PATH ought to contain ~/.cabal/bin
20:56:09 <dfeuer> I am, to be more specific, the WRONG person to ask Cabal questions.
20:56:28 <HeladoDeBrownie> sgwizdak, i believe that if you delete .ghc mainly, and also possibly .cabal, then you're basically fresh.
20:56:51 <HeladoDeBrownie> (i'm not necessarily suggesting to delete everything in .cabal; e.g., the config is worth keeping if you modified it)
20:57:18 <HeladoDeBrownie> beyond that it's a question of what ghc and what cabal you have installed on the system
20:58:08 <HeladoDeBrownie> DanC, sorry, should have said $HOME/.cabal/bin, since PATH doesn't interpret ~. and that's assuming linux-based os.
20:58:45 <DanC> I'm all set; have been for a while now. thanks.
20:59:20 <HeladoDeBrownie> okay.
20:59:33 <HeladoDeBrownie> so then it's just sgwizdak who needs help, preferably from someone familiar with os x. that is not i.
21:01:56 <sgwizdak> looks like the failure is "cannot satisfy -package-id HTTP-4000.2.10-da371776b88c2889959897a2dc40abe7"
21:02:33 <sgwizdak> (at least, for cabal-install. The package I'm attempting to install fails with a similar message for what looks to be the entire dependency closure)
21:03:48 <sgwizdak> though in the other case, it looks mtl + transformers-compat seem to be at the root of that fail tree
21:04:37 <HeladoDeBrownie> those sound like things included in the platform.
21:04:49 <HeladoDeBrownie> perhaps if you removed the platform, then installed just ghc and cabal.
21:05:05 <sgwizdak> that's what I'm investigating now...
21:12:39 <sgwizdak> jeez, I think that haskell-platform should not be recommended for osx, seems incredibly out of date
21:15:15 <jle`> we can probably generalize scanl/scanr to Traversable but the list version has too many items.  if we drop the first (initial state) item then it would work well
21:19:51 <sgwizdak> oh wow, this is going way better now. if there's a faq anywhere, this is way more stable: https://ghcformacosx.github.io/ than the haskell platform
21:20:54 <bananagram> @hoogle [Maybe a] -> [a]
21:20:56 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
21:20:56 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
21:20:56 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
21:21:00 <bananagram> ah
21:21:08 <HeladoDeBrownie> @type catMaybes
21:21:09 <lambdabot> [Maybe a] -> [a]
21:21:25 <HeladoDeBrownie> > catMaybes [Nothing, Just 10, Just 1, Nothing, Nothing, Just 8]
21:21:27 <lambdabot>  [10,1,8]
21:21:35 <bananagram> > sequence [Just 1, Nothing, Just 3]
21:21:36 <lambdabot>  Nothing
21:21:42 <bananagram> damn
21:21:49 <bananagram> > sequence [Just 1, Just 2, Just 3]
21:21:51 <lambdabot>  Just [1,2,3]
21:21:53 <bananagram> that's cool
21:25:59 <jle`> sgwizdak: blog about it :D
21:27:04 <sgwizdak> jle`: heh, sadly, I'm somewhat verboten from doing tech blogging due to a restrictive non-compete
21:27:13 <HeladoDeBrownie> i do wonder if there's an appropriate place on the wiki
21:27:16 <jle`> darn
21:27:18 <carter> HeladoDeBrownie: sgwizdak  i recommend folkd add "constraint: transformers installed" to their ~/.cabal/config
21:27:32 <carter> sgwizdak: are they paying for that noncompete?
21:27:52 <sgwizdak> carter: what does that line do?
21:28:01 <sgwizdak> carter: for the most part
21:28:16 <carter> sgwizdak: it prevents a lot of transformers and mtl sadnesses that people hit but dont realize
21:28:35 <HeladoDeBrownie> sgwizdak, by the way, did you see this page? https://www.haskell.org/downloads/osx
21:29:53 <sgwizdak> HeladoDeBrownie: oh interesting, they recommended the platform for pre 10.9 -- guess that's what I get for thinking "oh this worked well last time..."
21:30:32 <bobbylappy> I think I already answered this withh web searching, but I wanted to check in here to be sure
21:30:53 <bobbylappy> Is there any way to get ghci on an ARM linux distro?
21:31:25 <HeladoDeBrownie> carter, what requires transformers but doesn't depend on it?
21:31:41 <carter> HeladoDeBrownie: no, its mor elike people mixing up which version they should be using
21:31:52 <carter> you generally should stick to whichever version ghc comes with
21:32:01 <carter> and then just use transformers-compat
21:32:20 <sgwizdak> HeladoDeBrownie, carter: thanks for the help
21:36:10 <dfeuer> Transformers: robots in disguise.
21:37:10 <carter> monad stacks even
21:46:09 <wz1000> Are infinite structures classified as _|_?
21:46:21 <exio4> what is an infinite structures?
21:46:24 <exio4> are*
21:46:34 <kaw_> Does anyone happen to know the status of protocol-buffers-2.0.17? cabal install gives me a build error, kind mismatch: http://lpaste.net/5493348418094891008
21:47:29 <wz1000> exio4: [1..]
21:47:58 <nshepperd> wz1000: I believe not
21:48:14 <wz1000> exio4: Structures that can never be fully beta-reduced, but still give you information.
21:49:26 <nshepperd> I mean, they're considered 'more defined' than _|_ itself. I'm not sure how they compare to finite structures in definedness
21:49:30 <glguy> kaw_: The status is that the author didn't bother with version contraints and now it doesn't build any more because packages have moved on
21:50:09 <nshepperd> but for instance 1:âŠ¥ â‰  âŠ¥, which is how we prove that fix (1:) isn't âŠ¥
21:51:38 <glguy> kaw_: Which version of GHC are you trying to build it with?
21:51:57 <kaw_> ghc 7.6.3
21:51:58 <exio4> wz1000: beta-reducing a data structure? 
21:53:18 <exio4> nshepperd: data vs codata? 
21:53:25 <glguy> kaw_: 7.6.3 is 2 years old now. This package appears to build with the 7.8 series of GHC (I just tested with 7.8.4) but it doesn't build with the current release (7.10.1)
21:53:44 <wz1000> exio4: beta-reducing a term to get a data structure. 1 : (replicate 3 2) is a data structure that can be further beta-reduced. 1 : 2 : 2 : 2 : [] can not be further beta-reduced.
21:55:16 <kaw_> Huh. Brittle on both ends, that's not particularly encouraging
21:55:47 <kaw_> I'm running ghc from the Ubuntu repo, I guess that's not a particularly good idea for Haskell?
21:56:20 <glguy> kaw_: If you're using GHC from the Ubuntu repo you should also stick with Haskell libraries from the Ubuntu repo
21:58:29 <kaw_> Well, it doesn't seem like this library has been packaged at all in the Ubuntu repo? So that's not really an option
21:58:36 <kaw_> So I guess I should upgrade GHC?
21:58:42 <kaw_> But not too much?
21:59:08 <glguy> If your goal is to use this particular library you need to upgrade to GHC 7.8.4
22:00:37 <kaw_> Well, my goal is to use protocol buffers, I'd be happy to switch libraries if there's a better one
22:02:08 <glguy> If you want to use libraries that aren't packaged with Ubuntu you shouldn't bother using old GHC packaged with Ubuntu, it'll just make things harder. I don't have any insight into which protocol buffers libraries are good/better, maybe someone else will chirp up. The phrase
22:02:25 <glguy> protocol buffers does appear in the descriptions of other packages on hackage, though, so one might be worth trying
22:03:24 <kaw_> There was one other module I looked at, but it looked less mature to me
22:04:51 * hackagebot cf 0.2 - Exact real arithmetic using continued fractions  http://hackage.haskell.org/package/cf-0.2 (mvr)
22:05:19 <exio4> wz1000: basically, things that wouldn't terminate under strict evaluation? 
22:05:56 <kaw_> So what you're suggesting in terms of upgrading is just getting the binaries from haskell.org, right?
22:06:32 <glguy> There's a section on Ubuntu here: https://www.haskell.org/downloads/linux
22:07:39 <kaw_> The "manual install" part?
22:08:53 <glguy> I was thinking of the Ubuntu part, but either ought to work
22:09:15 <kaw_> Hmm, those instructions lead to https://www.haskell.org/ghc/download_ghc_7_8_4 which has "Stop!" in big red letters at the top of the page, recommending that I install the Haskell Platform instead
22:09:31 <jle`> which is a bit unfortunate...nobody uses the haskell platform
22:09:46 <glguy> It's a bit of an open discussion to figure out who the platform is for
22:09:53 <kaw_> Huh, okay
22:09:56 <jle`> (i lie, i actually use it for windows)
22:10:03 <jle`> but it's a bit weird to put it as a big red warning
22:10:23 <jle`> the big red warning probably should be, "consider if haskell platform is right for you...in many cases it might not be."
22:10:29 <kaw_> Well, good thing there's an IRC channel
22:10:35 <glguy> Ask your doctor if HP is right for you
22:11:00 <glguy> side-effects include arbitrarily pinned, outdated versions of packages
22:11:19 <jle`> isn't that supposed to be a feature?
22:11:32 <glguy> I think it has *potential* to be a feature
22:11:49 <glguy> like if the versions that were picked weren't picked because they were whatever was available the day the platform went together
22:30:58 <sgwizdak> hmm -- cabal install diagrams fails with "rejecting: base-4.8.0.0/installed-901... (conflict: diagrams-svg => base>=4.3 && <4.8)
22:31:40 <Hijiri> diagrams-svg wants earlier version of base
22:31:47 <glguy> sgwizdak: That means that the package hasn't been upgraded to support GHC 7.10.1 yet
22:31:50 <Hijiri> which means it hasn't been updated for 7.10
22:32:07 <sgwizdak> that's what I feared
22:32:11 <sgwizdak> any workarounds?
22:32:16 <glguy> GHC 7.8.4
22:32:55 <sgwizdak> is it possible to have two versions of ghc living side-by-side happily?
22:32:59 <glguy> Yes
22:33:23 <glguy> The git repository for that package has been updated but they aren't quite ready to do a release yet
22:33:28 <glguy> (as of 2 days ago)
23:05:42 <solidsnack> System Information: Model: MacBook Air (11-inch Mid-2013) â€¢ Screen Resolution: 1366 x 768 
23:16:37 <cfoch> what is the easy way to create a list of N elements with a default value for each element ?
23:16:48 <glguy> :t replicate
23:16:49 <lambdabot> Int -> a -> [a]
23:17:07 <cfoch> thanks
23:22:27 <ReinH> sgwizdak: you can --allow-newer=base
23:23:16 <ReinH> glguy: if the update is just a trivial version bump, someone can add just a revision on hackage
23:24:03 <ReinH> *just add
23:24:16 <glguy> The package author knows about GHC 7.10.1 but has chosen not to do that
23:24:21 <sgwizdak> ReinH: oh neat, thanks
23:25:03 <ReinH> glguy: doesn't have to be the package author
23:25:45 <glguy> It has a be a maintainer or a trustee and a trustee isn't going to bump the version up while the maintainer is active
23:27:49 <ReinH> glguy: fair enough
23:28:01 <glguy> And I don't know if it's a trivial bump
23:28:17 <glguy> Presumably you just checked that though
23:30:56 <sgwizdak> well, allowing newer has some compilation failures in the actual code which seems to be outside the realm of package dependency issues, so that might explain why they need to do more
23:33:37 <ReinH> glguy: it's 11:30 on a Friday night, I'm not checking anything ;)
23:33:56 <ReinH> sgwizdak: well, it's worth a shot.
23:55:42 <HeladoDeBrownie> cfoch, the phrasing of your question suggests a subtle misunderstanding: did you know that all data in haskell are immutable?
23:56:13 <HeladoDeBrownie> (for some value of "immutable")
23:56:48 <cfoch> you can't 'change' the value, do you mean that?
23:57:22 <HeladoDeBrownie> right, instead of changing elements in a list from what they were, you make a new list with the new elements.
23:58:02 <HeladoDeBrownie> one upshot being that once you have a list somewhere, actions elsewhere can't change its value
23:58:08 <cfoch> yes, I knew that. But it is okay. The "replicate" function is what I wanted.
23:58:25 <HeladoDeBrownie> all right.
23:58:44 <HeladoDeBrownie> i had seen someone else talk about "default values" who was confused about that, which is why i mentioned it.
23:59:24 <cfoch> I said "default values" 
23:59:38 <cfoch> yes, it was confusing
23:59:53 <HeladoDeBrownie> no, i mean someone besides you, a while ago.
23:59:54 <cfoch> I wanted to do something like [0, 0, 0, 0, 0] 
23:59:56 <Mishac> Hi guys, is there anyon who completed Brent Yorgey course?
