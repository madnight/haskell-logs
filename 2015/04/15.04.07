00:00:17 <AshyIsMe> is there a linter that does that style yet?
00:00:26 <ane> well.. it'll certainly be less error prone than bash!
00:00:46 <ohxvoa> i'm asking if is ok doing it
00:00:52 <ohxvoa> or if someone is actually doing 
00:00:53 <mrmyers> ohxvoa: If you're looking for a good scripting language, try python. Generally, haskell is only for occasional academic use.
00:01:13 <mrmyers> 3..2..1..
00:01:31 <ohxvoa> oh? i was thinking that functional programming was really nice
00:01:35 <caconym_> frerich: thanks, this was exactly what i was looking for; looks like i haven't been too far off the mark
00:01:35 <MP2E> http://www.haskellforall.com/2015/01/use-haskell-for-shell-scripting.html
00:02:07 <MP2E> ohxvoa: pretty sure that was to get one of us to chime in and say Haskell is great for pretty much any use :p
00:02:13 <mrmyers> ohxvoa: Not really. Functional programming is pretty dry and abstract. Mutation is awesome.
00:02:54 <ohxvoa> sad :(
00:03:24 <caconym_> ohxvoa: haskell is a great general purpose language and you should learn it
00:03:26 <MP2E> Well you *can* mutate things in Haskell.. you just need to encode it in the type
00:04:06 <peddie> ohxvoa: https://donsbot.wordpress.com/2007/03/10/practical-haskell-shell-scripting-with-error-handling-and-privilege-separation/
00:04:10 <ohxvoa> i'm not a programmer. i just used shell script and python sometimes, but just by using their documentation
00:04:11 <Maxdamantus> You can't mutate things. There's no assignment operator.
00:04:18 <mrmyers> Also, Turing Machines and Register Machines are way more awesome than the lambda calculus.
00:04:27 <MP2E> https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-IORef.html
00:04:54 <Maxdamantus> in the IO monad.
00:05:06 <Maxdamantus> as in: we don't mutate things; we just denote it.
00:05:38 <Maxdamantus> that's like saying: `jsCode = "var a = 4; alert(a);"` is an example of mutation.
00:06:05 <mrmyers> Why use lambda when you can just goto?
00:06:15 <ohxvoa> goto is evil (?)
00:06:18 <peddie> ohxvoa: you might find that haskell programming and shell scripting make different tradeoffs; you might write more Haskell code to do some things that are pretty short in a shell script, but you will probably have fewer surprising bugs when you're using it :)
00:06:34 <peddie> mrmyers: around here we call that "call/cc"
00:07:05 <nuser> is there a better way to write fmap (fmap (+1)) [[9]] ?
00:07:07 <ohxvoa> what about web scraping and things like that?
00:07:34 <peddie> ohxvoa: I've never web-scraped from bash, so I can't compare . . . have you?!
00:07:45 <ohxvoa> uhm compare in general
00:07:50 <ohxvoa> maybe python?
00:08:01 <ohxvoa> you can use python as shell scripting
00:08:24 <peddie> O.o
00:08:39 <bramgg> peddie: I have with Common Crawl's data
00:08:54 <peddie> ohxvoa: ok I guess I think of shell scripting as "using the shell language (bash, csh, etc.) to write scripts"
00:08:58 <peddie> bramgg: how was it?
00:09:02 <mniip> 'Avoid over-using point-free style. For example, this is hard to read: f = (g .) . h'
00:09:08 <mniip> seems rather readable
00:09:12 <mniip> to me
00:09:29 * hackagebot base-compat 0.7.1 - A compatibility layer for base  http://hackage.haskell.org/package/base-compat-0.7.1 (SimonHengel)
00:09:29 * hackagebot clash-prelude-quickcheck 0.1.1.0 - QuickCheck instances for various types in the C»aSH Prelude  http://hackage.haskell.org/package/clash-prelude-quickcheck-0.1.1.0 (JohnEricson)
00:10:15 <bramgg> peddie: very fast and easy, considering Common Crawl did the crawling. For example the following script returns all URLs of sites with the script "foo.js": `grep -B7 '"Scripts":.*"url":"foo.js"' records.wat" | awk '/^WARC-Target-URI/ {print $2}'`
00:10:20 <bramgg> but that's for another channel :p
00:10:41 <peddie> bramgg: oh, I see, the shell was just used to postprocess the output of the crawler?
00:10:48 <nuser> Ok, I'll stick with it, thanks.
00:10:55 <bramgg> yes, "scraping" as you said, not crawling ;)
00:11:00 <peddie> gotcha
00:12:35 <frerich> mniip: For very small value of 'readable' maybe.
00:12:50 <caconym_> > getCompose $ fmap (+1) $ Compose [[1..10]]
00:12:51 <lambdabot>  Not in scope: â€˜getComposeâ€™    Not in scope: data constructor â€˜Composeâ€™
00:12:51 <lambdabot>      Perhaps you meant variable â€˜icomposeâ€™ (imported from Control.Lens)
00:13:18 <arkeet> @let import Data.Functor.Compose
00:13:19 <lambdabot>  Defined.
00:13:27 <arkeet> > getCompose $ fmap (+1) $ Compose [[1..10]]
00:13:28 <lambdabot>  [[2,3,4,5,6,7,8,9,10,11]]
00:13:29 <caconym_> nuser: you could do it that way with Data.Functor.Compose, I think, but it doesn't really make it "better"
00:13:39 <arkeet> > (fmap.fmap) (+1) [[1..10]]
00:13:40 <lambdabot>  [[2,3,4,5,6,7,8,9,10,11]]
00:13:53 * caconym_ golf claps
00:14:09 <mrmyers> Oi, so much syntax...
00:14:21 <arkeet> > [[1..10]] & mapped.mapped +~ 1
00:14:23 <lambdabot>  [[2,3,4,5,6,7,8,9,10,11]]
00:15:52 <caconym_> :t (+~)
00:15:53 <lambdabot> Num a => ASetter s t a a -> a -> s -> t
00:16:04 <caconym_> :t (&)
00:16:05 <lambdabot> a -> (a -> b) -> b
00:16:11 <Gurkenglas> > (map.map) (+1) [[1..10]]
00:16:13 <lambdabot>  [[2,3,4,5,6,7,8,9,10,11]]
00:16:24 <Gurkenglas> Oh wait someone already did that oe.
00:17:05 <nuser> Cool, had a feeling another way could lead to learning something new. Thanks guys :)
00:18:32 <jle`> mniip: add my vote to the not-immediately-readable camp :)
00:19:15 <jle`> compare (g .) . h to (\x y -> g (h x y))
00:19:43 <jle`> one is meaningful immediately and the other takes at least a few seconds
00:20:49 <malte> Hey, i started learning haskell today :)
00:21:05 <malte> I have a question regoarding infinte lists with list-comprehension
00:21:15 <bramgg> howDoIReferenceTheMatchingValue | x =~ "regex pattern" :: String = {- HERE? -}
00:21:32 <jellie> Can anyone help me parse some xml in this channel?
00:22:12 <malte> take this example: > leapYears = [ x | x <- [0..], x `mod` 4 == 0, if x `mod` 400 == 0 then True else x `mod` 100 /= 0 ]
00:23:03 <malte> and when i want to test a specific year i would do that by testing > 1996 `elem` leapYears ?
00:23:52 <lyxia> it would terminate only if the year is actually a leap year.
00:24:07 <lyxia> otherwise it will keep looking in the list
00:24:40 <bramgg> ah nevermind
00:24:50 <bramgg> will use let/where
00:25:31 <malte> i noticed that too, so I rewrote it to > leapYearsUntil y = [ x | x <- [0..y], x `mod` 4 == 0, if x `mod` 400 == 0 then True else x `mod` 100 /= 0 ] so it just checks all years before and the specified year
00:25:43 <malte> but it will still keep testing all years, right?
00:25:56 <malte> and not use the predicates, which would be way more efficient?
00:26:21 <lyxia> right
00:26:28 <frerich> malte: Your last name doesn't happen to be 'Starostik', does it?
00:27:12 <malte> frerich: no ;) thanks lyxia!
00:27:51 <frerich> malte: Ok, I just happen to know a guy whom I haven't seen in a long time (and he's also a programmer who goes by the name 'malte', even on IRC). Nevermind. :)
00:31:54 <jle`> malte: the second way won't test anything after year y
00:32:16 <malte> yeah, i know that. But I had to make the list finite
00:32:27 <jle`> malte: another way you can do it is instead of using `elem`, you can use dropWhile (< 1996)
00:32:32 <jle`> for the infinite list case
00:32:36 <jle`> and then see if the head is 1996
00:33:07 <malte> so I have a function isLeapYear x = x `elem` leapYearsUntil x
00:33:40 <malte> i just hoped - as awesome as heskell is ;) - it would do a lazy-evaluation for that specific year
00:33:59 <jle`> well you have to look at the source of elem :)
00:34:10 <jle`> it lazily evaluates exactly what you tell it to
00:34:12 <jle`> @src elem
00:34:12 <lambdabot> elem x = any (== x)
00:34:17 <jle`> @src any
00:34:17 <lambdabot> any p = or . map p
00:34:23 <jle`> how unhelpful ><
00:34:30 <jle`> @src or
00:34:30 <lambdabot> or = foldr (||) False
00:34:42 <Gurkenglas> Why do you want to have those years in a list anyway?
00:34:49 <malte> but i see that elem is a function operating on lists, not on the handy-way of list-comprehension
00:35:07 <jle`> elem is literally a function you can implement yourself
00:35:11 <jle`> elem p [] = False
00:35:23 <jle`> elem p (x:xs) = (x == p) || elem p xs
00:35:30 <Gurkenglas> A way I see to make this work is to instead of a list of leapyears, have a list of booleans that encode a map from nonnegative integers to whether that year is a leapyear
00:35:38 <jle`> so it can't skip all of the 'first' years before 1996
00:35:45 <jle`> because from the definition, it has to check all of the items in order
00:36:22 <jle`> the laziness comes into play here because of the source if (||)
00:36:24 <jle`> @src (||)
00:36:24 <lambdabot> True  || _ =  True
00:36:24 <lambdabot> False || x =  x
00:36:38 <jle`> if x == p, then it will return True immediately before evaluting `elem p xs`
00:36:58 <jle`> laziness isn't "magical"...it's exactly the semantics you'd expect when evaluating things by substituting in their definitions :)
00:36:59 <malte> and there is probably no way to specify that a list is ordered, so haskell would know, if it runs past the specified year?
00:37:46 <jle`> you might be able to create an "ordered list" type, and write your own `elemOrdered` for that ordered type.
00:37:57 <jle`> but for normal haskell lists...all you see is "a head and a tail".  that's all `elem` sees
00:38:01 <jle`> from the definition
00:38:10 <jle`> elem is right there, implemented like that
00:38:14 <jle`> there's no compiler or language magic
00:38:48 <jle`> haskell works using "evaluation by substitution": substitute function applications with their definitions
00:39:11 <malte> okay, thank you! i just hoped there was a way to reuse the predicates of the list comprehension :(
00:39:22 <jle`> elem 2 [1..] = elem 2 (1:[2..]) = (1 == 2) || elem 2 [2..]
00:39:45 <jle`> we did all that by simply substituting the defitino of elem p (x:xs) for elem 2 (1:[2..]), where p = 2, x = 1, xs = [2..]
00:40:15 <malte> and hoped that elem xould use that^^
00:40:16 <jle`> (1 == 2) || elem 2 [2..] = False || elem 2 [2..] = elem 2 [2..]  -- definition of (||), False || x = x
00:40:49 <jle`> elem 2 [2..] = elem 2 (2:[3..]) = (2 == 2) || elem 2 [3..] = True || elem 2 [3..] = True    -- definition of (||), True || _ = True
00:40:55 <jle`> and that's how it works
00:41:16 <malte> i never questioned the implementation of elem :D
00:41:31 <jle`> yeah. so there's no way that implementation of elem could know that the list was ordered
00:41:35 <jle`> all it knows is p, x, and xs
00:42:00 <jle`> and lists don't keep track of whether or not they are ordered, they are just a normal algebraic data type
00:42:08 <jle`> data [a] = [] | a : [a]
00:42:33 <jle`> that's all it is; no ordering information encoded :)
00:42:56 <jle`> you can make a separate data type that does have ordering information encoded, like data Ordered a = OrdNil | OrdCons a (Ordered a)
00:43:06 <malte> and the list-comprehension is just a short-hand-way to define lists, right? i still don't get why the information of the list definition gets lost/unusable for infinte sets/lists
00:43:21 <bramgg> > type fullRgx = (String, String, String, [String])
00:43:22 <lambdabot>  <hint>:1:1: parse error on input â€˜typeâ€™
00:43:25 <jle`> and then write an `orderedElem :: Ord a => a -> Ordered a -> Bool`
00:43:35 <bramgg> "Malformed head of type or class declaration: fullRgx" ^ ?
00:43:37 <jle`> malte: all elem "sees" is (x:xs)
00:43:42 <jle`> it doesn't see the function that generated the xs
00:43:44 <jle`> or the x
00:44:08 <jle`> compare to a function like addToThree x = x + 3
00:44:13 <jle`> all it "sees" is x, a number
00:44:26 <jle`> it doesn't see how you calculated x...and it doesn't see if it's obviously positive or negative
00:44:37 <malte> yes, I see that, but if i would implement my own elem' function, i still couldn't use the list-comprehension-definition
00:44:49 <jle`> elem only "sees" (x:xs)...which is basically a tuple with an `a` and an `[a]`.  it doesn't see the fucntion that created the list
00:45:10 <jle`> malte: well, if you *know* the list you're getting is ordered (as a precondition), you could write your own elemOrdered
00:45:15 <bramgg> Ah it wasn't capitalied, that was my issue
00:45:49 <jle`> elemOrdered p xs = case (dropWhile (< p) xs) of [] -> False; (x:_) -> x == p
00:45:57 <malte> but I still couldn't use the predicates at first hand to eliminate elements
00:46:19 <jle`> if you could, you'd have to encode it into the definition of `elem`
00:46:31 <jle`> you could write a "smart" elem with your invariants in mind
00:46:37 <malte> as I said, I could make elem' which does that
00:46:39 <jle`> but elem has to do what it does because that's what it is
00:46:51 <jle`> oh, you could still use list comprehension definition
00:46:58 <jle`> what do you mean when you say you can't?
00:47:13 <jle`> @let elemOrdered p xs = case dropWhile (< p) xs of [] -> False; x:_ -> x == p
00:47:15 <lambdabot>  Defined.
00:47:22 <jle`> > elemOrdered 100 [1..]
00:47:24 <lambdabot>  True
00:48:06 <malte> doesn't the definition (eg. predicates) get lost within the creation of the list? all i know is haskell stores them for "later" evaluation as needed, but can i still test a number against these?
00:48:21 <jle`> in what way?
00:50:03 <jle`> when you make a list using a list comprehension...all your functions get is a (x:xs) / [].  the head, and the rest of the list
00:50:12 <malte> yeah, i like that. Althogh it doesn't seem so clean to me (codewise) as i don't like the drop in there ;D
00:50:39 <jle`> if you run a function on the resulting list, you don't have access to the list comprehension lexically or the predicates, all you have is (x:xs), or [].
00:51:19 <jle`> what the list comprehension gives you is an "unconser", of sorts.  basically it gives you a way to "ask for the first" if you want, and a way to "produce the tail" if you want
00:51:44 <jle`> that's what the list comprehension -- and any function returning a list in haskell -- gives you.
00:52:30 <jle`> @let countFrom n = n : countFrom (n+1)
00:52:31 <lambdabot>  Defined.
00:52:31 <malte> so there is no way to reuse the predicates? the compiler/interpreter hides the nature of the list, right? and only evaluates list- functions (head/tail)
00:52:35 <jle`> > countFrom 1
00:52:36 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
00:52:57 <jle`> i just specified a list by saying, "if you want the head of countFrom 1, it's 1.  if you want the tail of countfrom 1, it's countFrom 2.  and that's all i'm giving you."
00:53:14 <jle`> yeah, you can say that it hides it, by the nature of what [a] is.
00:53:34 <jle`> from the definition of []
00:53:46 <jle`> if you're familiar with ADT's, you actaully can create a reified list comprehension data type
00:53:51 <jle`> that does encode your predicates
00:54:15 <malte> thank you, that's all I wanted to hear :D 
00:54:18 <jle`> data Comprehended a = C [a] [Predicate]
00:54:28 <jle`> or however precise you want
00:54:43 <jle`> data Comprehended a = OrderedComprehend a [Predicate] | ...
00:54:50 <jle`> basically encode everything first-class
00:55:03 <jle`> then you can write a function toList :: Comprehended a -> [a], and use normal functions
00:55:21 <jle`> or you can write special `elem`s, elemComprehended :: Ord a => a -> Comprehended a -> Bool
00:55:23 <malte> I'll do that in a later haskell-session^^ I don't understand data types yet, but I'll have a look into a tutorial for that :)
00:55:53 <jle`> ah yeah.
00:55:59 <jle`> usually though it's just best to know what's being evaluated and why
00:56:06 <jle`> and then write algorithms tailored for that
00:56:49 <malte> of course. as i said, i started haskell today and just wanted a little advice on how the list-comprehension works in the haskell-interpreter :)
00:57:30 <jle`> ah.  well, yeah :)  in a way it's disappointing at first when you realize that the "magic" has limitations...but it's comforting to know that it's not actually magic --- and that it's possible to really understand what's going on meaningfully, and it's not complex at all
00:58:26 <jle`> less magic = better.  laziness isn't that tricky of a beast because at its heart its purpose is to make programs more meaningfully understandable and composable
00:59:13 <jle`> not work as a magic compiler optimizer
00:59:38 <malte> exactly. i worked with C before where you have to know the language-specifications to know why your programs disbehave^^ and the tutorial and quick online-research didn't answer my question :( 
01:00:47 <riaqn> hello, anyone know how is the list comprehension implemented in syntax level?
01:00:49 <malte> im more than happy to learn about the compiler, so thank you again. many tutorials seem to try to hide as much technical input as possible
01:00:50 <jle`> c can be another crazy affair altogether ><.  a lot to both love and hate :P  haskell is different in many ways, so i hope you have fun discovering the differences :)
01:01:04 <halenrain> hi,all
01:01:04 <riaqn> I mean, are [ ] |  three funcitons?
01:01:26 <jle`> hi & bye halenrain ?
01:01:33 <jle`> riaqn: nah, it's syntax
01:02:26 <jle`> malte: you can understand simple list comprehensions as a combination of maps and filters
01:02:53 <riaqn> jle`: do you mean there 's some "if it's a list comprehension then ..." in the syntax parser?
01:02:58 <jle`> actually i think the language spec has full details on how things are desugared
01:03:12 <jle`> riaqn: yes, on the same level as things like case statements, module imports, function declarations, etc.
01:03:38 <riaqn> jle`: huh, then haskell is not as "clean" as I thought... scheme is much cleaner...
01:03:40 <malte> and i hoped that haskell-elem would use these filters^^ well, now I know it does not and that is okay :) I was just curious :)
01:04:00 <jle`> malte: here ya go, a full spec https://www.haskell.org/onlinereport/exps.html#list-comprehensions
01:04:34 <jle`> riaqn: yeah, this does get brought up a lot.  perhaps when people say haskell is "clean", they mean that haskell has a very minimal *core* syntax, with a lot of syntactic sugar
01:04:47 <malte> suitable for a nightly read! :D
01:05:02 <jle`> haskell's core syntax is pretty small, and you can express all of haskell with a small core syntax
01:05:20 <jle`> but there's a whole lot of syntactic sugar people often use...and that's where a lot of complaints come from
01:05:39 <jle`> for the most part, i don't mind, as long as i know that i can do everything and state everything with a small set :)  but there are moments when there is some cognitive overhead
01:06:18 <riaqn> jle`: well.. maybe haskell should adopt the syntax from scheme, then you can define your "sugar" by macro...
01:06:47 <jle`> or we can embrace it ^^
01:07:13 <jle`> sugar everywherrreeee
01:08:05 <riaqn> jle`: tons of sugar make me tired..
01:08:35 <jle`> it's been a complex relationship. various forms of sugar have gone in and out of fashion over the past couple decades when people realize that something is unecessary or just causes extra cognitive baggage
01:08:42 <Malar> diagrams failed to build with this error http://lpaste.net/130292 ghc version 7.10.1
01:09:14 <jle`> so i think we're mostly aware of the "dangers" of too much sugar in that we know that we should not go overboard, but we also accept that some is good and useful, and we're trying to find the equilibrium
01:10:12 <riaqn> jle`: as to me, sugar brings more confusion than convinience...
01:10:18 <Malar> is there any workaround for diagrams?
01:10:23 <benma> riaqn: it's not too much sugar though. almost everything is sth you would use
01:10:23 <benma> riaqn: i.e. pattern matching, if/else, ...
01:10:23 <benma> f a b c = .., instead of lambdas all the way
01:10:41 <jle`> i think there is a balance, and it might be a bit overkill to make blanket statements
01:10:49 <jle`> or absolute statements
01:10:57 <benma> riaqn: you wouldn't want to do a chain of >>= function applications when you can do a nice readable do-block
01:11:23 <jle`> benma: i think riaqn's point was that do blocks could be implemented as macros that are written in the language itself
01:11:34 <jle`> instead of being baked into the compiler
01:11:57 <tdammers> whoa whoa... let's not turn haskell into lisp
01:12:05 <benma> might be a worthwhile idea
01:12:07 <jle`> i don't think you can make any absolute statements about sugar/macros being good/bad in every case
01:12:20 <benma> there are many extensions introducing some little syntax sugar
01:12:33 <m0rphism> jle`: I agree.
01:12:41 <benma> on the other hand, a small blessed set keeps the code readable across projects
01:13:00 <tdammers> I like "rebindable" syntax sugar
01:13:15 <riaqn> tdammers: try scheme then, huh!
01:13:29 <m0rphism> If you describe a concept using syntactic sugar or macros doesn't eliminate the need of learning the concepts lying beneath them. In both scenarios you basically creating a DSL for a certain concept
01:13:32 <MP2E> GHC has rebindable syntax sugar too :)
01:13:59 <tdammers> riaqn: I have, at least a bit. It's pretty good.
01:14:00 <m0rphism> s/beneath/underneath/
01:14:16 <tdammers> but I'm talking more about things like monad comprehensions
01:14:33 <tdammers> generalize existing sugar to the widest possible range of applications
01:24:20 <merijn> tdammers: I want -XApplicativeDo !
01:24:43 <tdammers> merijn: so much.
01:24:54 <sagittarian> what's the name of the funtion that looks like \f x -> [x, f x , f (f x) , ..]
01:25:16 <merijn> :t iterate
01:25:17 <lambdabot> (a -> a) -> a -> [a]
01:25:25 <sagittarian> that's it, thanks merijn
01:28:58 <sagittarian> why do i get a stack overflow exception when i do take 15 . drop 10000000 $ infiniteList?
01:29:10 <sagittarian> can't ghc figure out how to do that without actually recursing?
01:29:19 <sagittarian> tail-call elimination or something?
01:29:40 <tdammers> tco wouldn't help
01:29:45 <tdammers> adding some strictness would
01:29:48 <merijn> sagittarian: There is no such thing as tail-call elimination because haskell doesn't have a function call stack
01:29:49 <jle`> it might be because it's deferring your call to f x
01:30:10 <jle`> instead of storing 2, it might store succ 1.. or succ (succ (succ 1)) instead of 4.
01:30:12 <merijn> sagittarian: Alternative view: All function calls in haskell are TCO
01:30:20 <merijn> But yeah, iterate lacks strictness
01:30:30 <sagittarian> okay, so how do i force strictness?
01:30:51 <merijn> Which function are you iterating?
01:31:04 <merijn> Easiest way is probably to add a BangPattern to it
01:31:07 <jle`> so it's not a stack overflow because of a call stack...it's more of a heap overflow because the giant succ (succ (succ ... )) chain (speciffying a succ applied to a succ applied to...) overflows memory
01:31:09 <sagittarian> it's a simple mathematical calculation
01:31:29 <hnfmr> what's the command to ask lambdabot to show signature of a function?
01:31:46 <pavonia> :t succ
01:31:47 <lambdabot> Enum a => a -> a
01:32:06 <merijn> FYI, that shows the signature of an arbitrary expression, not just functions
01:32:08 <hnfmr> @lambdabot help
01:32:08 <lambdabot> Unknown command, try @list
01:32:28 <hnfmr> :t withSqlitePool
01:32:29 <lambdabot> Not in scope: â€˜withSqlitePoolâ€™
01:33:03 <merijn> hnfmr: You only have access to the types of functions in scope in lambdabot (which are fairly restricted)
01:33:19 <hnfmr> i am confused when using this function "withSqlitePool" which takes "Text -> Int -> (ConnectionPool -> m a) -> m a
01:33:32 <hnfmr> merijn: OK i will elaborate
01:34:07 <hnfmr> e.g. withSqlitePool "example.db" 10 $ \ pool -> scotty .......... (<- which returns IO ())
01:34:20 <merijn> Hold on, let's rewind: Let's start with *which* package you are talking about
01:34:22 <hnfmr> but GHC complains, no instance for MonadLogger
01:34:42 <hnfmr> the "m a" in withSqlitePool has the following constraints
01:35:01 <hnfmr> Database.Persist.Sqlite
01:35:18 <hnfmr> (MonadBaseControl IO m, MonadIO m, MonadLogger m)
01:35:47 <merijn> Right, so "IO" is not allowed as a result type there because IO is not a MonadLogger instance
01:36:23 <hnfmr> then I wrap " runNoLoggingT $ ..." before "scotty..."
01:36:25 <hnfmr> that still doesn't help
01:37:08 <hnfmr> then it complains e.g. NoLoggingT IO () is not IO ()
01:37:39 <hnfmr> the compiler is correct, but I don't know how I can get out of it.....
01:37:52 <sagittarian> so to get strictness with iterate i have to implement it myself with a ! or seq?
01:37:53 <quchen2> merijn: "All calls are TCO"? This is about the ominous pattern-match-stack again, isn't it?
01:38:17 <merijn> quchen2: :)
01:38:34 <merijn> quchen2: Go add an entry to your FAQ explaining it so I don't have to write it :p
01:38:38 <quchen2> And everything is CPS'd and so on. Is there some reading about that? I keep hearing about it regularly, but I never found anything conclusive
01:38:46 <quchen2> merijn: Patches welcome :-D
01:38:57 <sagittarian> quchen2: where is your faq?
01:39:12 <merijn> quchen2: Sure, if you look at the specification of STG you see that all function calls are basically jumps
01:39:14 <quchen2> It's an FBUT because the things answered in it were actually asked at some point
01:39:22 <quchen2> https://github.com/quchen/articles/blob/master/fbut.md
01:39:30 <merijn> quchen2: See here: http://research.microsoft.com/apps/pubs/default.aspx?id=67083
01:40:08 <quchen2> merijn: STG tells me *nothing*. Which tells me I should finally read up on it.
01:40:29 <quchen2> My GHC pipeline looks like this: Source -> typecheck -> desugar -> Core -> magic -> elf
01:41:36 <merijn> quchen2: Core -> STG -> LLVM/native code/deprecated C
01:41:37 <quchen2> merijn: But seriously, I'd gladly add a remark like that to the FBUT, but I'm not competent to do so myself
01:42:10 <merijn> quchen2: That link basically explains STG (the language) and STG (the machine model) and A way to compile STG to actual machines
01:42:40 <merijn> The language is pretty simple, because it's basically Core but with even less stuff :p
01:42:53 <merijn> You have let, case, function application and constructors
01:43:03 <quchen2> And that's it?
01:43:14 <shachaf> STG has things Core doesn't.
01:43:29 <merijn> quchen2: Mostly
01:43:33 <shachaf> Read the STG paper to learn about them.
01:43:37 <shachaf> @where stg
01:43:37 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
01:44:21 <quchen2> shachaf: merijn linked that paper just above already
01:44:36 <quchen2> I'm just checking the scope of it, I guess.
01:44:46 <shachaf> So he did.
01:54:29 * hackagebot basic-sop 0.1.0.5 - Basic examples and functions for generics-sop  http://hackage.haskell.org/package/basic-sop-0.1.0.5 (AndresLoeh)
01:59:29 * hackagebot json-sop 0.1.0.4 - Generics JSON (de)serialization using generics-sop  http://hackage.haskell.org/package/json-sop-0.1.0.4 (AndresLoeh)
02:37:14 <Geraldus_> Hi everybody!
02:37:26 <sagittarian> hi
02:39:08 <Geraldus_> Recently I've removed GHC 7.8.3 by hand, and switched to GHC 7.8.4 for OS X, downloaded from haskell.org. Now I have strange things happening almost all time I want to `cabal install` something. I see this is build log: setup-Simple-Cabal-1.18.1.5-x86_64-osx-ghc-7.8.4: dist/package.conf.inplace: inappropriate type. What does it mean
02:39:19 <Geraldus_> cabal version shows me 1.22.0.0
02:40:03 <bennofs> Geraldus_: does the version of the Cabal library and cabal-install displayed by cabal --version match?
02:40:31 <Geraldus_> yes, it does
02:40:39 <Geraldus_> both have 1.22.0.0
02:40:55 <bennofs> Geraldus_: does ghc-pkg list Cabal also show 1.22?
02:41:06 <merijn> Geraldus_: How did you remove 7.8.3 and install 7.8.4?
02:41:31 <Geraldus_> huh, ghc-pkg shows me 1.18.1.5
02:41:46 <bennofs> Geraldus_: ok, then I recommend that you cabal install Cabal
02:42:30 <Gurkenglas> Should the content from the top of https://hackage.haskell.org/package/free-4.11/docs/Control-Monad-Free.html be displayed both there and at the bottom of https://hackage.haskell.org/package/free-4.11/docs/Control-Monad-Trans-Free.html ?
02:42:30 <Geraldus_> merijn: I've uninstalled haskell platform, which I had installed by homebrew, then I've deleted .ghc, .cabal folders. I suppose that's all I've done
02:42:38 <hexagoxel> wait, what? why would that cause any problems? shouldn't the first suggestion be to `cabal clean`?
02:42:56 <Geraldus_> cabal clean does not help
02:43:13 <Geraldus_> I able to build everything, but installation always fails
02:43:20 <bennofs> hexagoxel: it will cause problems for packages using build-type: Custom
02:43:33 <Geraldus_> Thus, I believe I should cabal install Cabal
02:43:56 <bennofs> hexagoxel: since then, the building is performed by compiling Setup.hs which will use Cabal 1.18, but all "native" cabal install operations will pick Cabal 1.22
02:44:34 <bennofs> hexagoxel: and because Cabal 1.18 and Cabal 1.22 use different formats for dist/inplace.package.conf, you get an error (Cabal 1.22 switched to using directory-based inplace package db instead of the old file-based one)
02:44:45 <hexagoxel> bennofs: ah, indeed, you are right, thanks for reminding me.
02:45:29 <Geraldus_> hmmm... `cabal install Cabal --dry` reports me, that 1.18.1.5 already installed and I can reinstall it.
02:45:47 <bennofs> Geraldus_: try cabal install Cabal --constraint "Cabal >= 1.22"
02:47:24 <Geraldus_> bennofs: oh, that's because cabal.config constraint "Cabal installed" in my project dir
02:47:43 <bennofs> Geraldus_: oh, I'd install Ca
02:48:10 <bennofs> Geraldus_: i'd install the Cabal lib in as your user, outside of the sandbox, since you will need for almost all projects with non-trivial dependencies
02:48:42 <Geraldus_> bennofs: surely!
02:49:17 <Geraldus_> bennofs: thank you a lot
02:49:32 * hackagebot monad-unlift 0.1.0.1 - Typeclasses for representing monad transformer unlifting  http://hackage.haskell.org/package/monad-unlift-0.1.0.1 (MichaelSnoyman)
02:50:23 <Geraldus_> by the way, what is proper way to remove haskell installation entirely from OS X (say, to upgrade later to new version)?
02:50:40 <merijn> Geraldus_: uninstall-hs script
02:51:05 <merijn> It should be in your path if GHC is
02:51:07 <Geraldus_> merijn: But it comes with Haskell Platform if I not mistaken.
02:52:05 <Geraldus_> merijn: oh, no, I do have this binary. Thanks
02:52:45 <merijn> There's no 7.10 platform out yet, is there?
02:54:32 * hackagebot text-and-plots 0.2.1.0 - EDSL to create HTML documents with plots based on the C3.js library.  http://hackage.haskell.org/package/text-and-plots-0.2.1.0 (andersjel)
02:55:33 <Geraldus_> merijn: likely
02:55:58 <gienah> merijn: I think, no, most of the stuff in the haskell-platform could be persuaded to build, but some stuff looks more tricky (like gnutls)
02:56:13 <Geraldus_> bennofs: can I now unregister version 1.18 of Cabal?
02:56:37 <bennofs> Geraldus_: you can hide it, but unregistering is impossible since it is shipped with GHC iirc
02:57:32 <Geraldus_> oh, well, it's not a big deal at all. BTW, what iirc is? The only association I have (believe wrong) is IRC :D
02:57:32 <gienah> (gnutls is not part of the haskell-platform, just a package that looks hard to compile with ghc 7.10.1)
02:57:59 <bennofs> Geraldus_: iirc = if i recall correctly
02:58:42 <Geraldus_> got it xD
02:59:01 <Geraldus_> thanks once again, issue gone
02:59:30 <Geraldus_> finally, the last one thing is to fix my Emacs
03:05:31 <Geraldus_> bennofs: by the way, I was inattentive and installed Cabal version 1.22.2.0. However `cabal --version` shows version 1.22.0.0. Should I install another one version of Cabal? (:
03:06:24 <Geraldus_> this version mismatch brings some issues with Interactive Haskell Mode in Emacs
03:06:51 <bennofs> Geraldus_: hmm, i don't know what changed between 1.22.2 and 1.22.0
03:07:27 <Geraldus_> let me rephrase: is it okay to have three versions of Cabal lib registered?
03:08:48 <Geraldus_> also, it turns that all packages I have installed after 7.8.4 migration was installed with Cabal version 1.18.1.5. Should I rebuild everything?
03:08:57 <bennofs> Geraldus_: ah, that would probably not solve your issue, since GHC always picks the latest. In that case, I think you should just install 1.22.0 and unregister 1.22.2
03:09:20 <Geraldus_> good
03:09:29 <bennofs> Geraldus_: no, you don't need to rebuild the packages. They only depend on Cabal for building, so if they built fine, then there is no need to reinstall them
03:09:47 <Geraldus_> thanks you for clarifications
03:10:29 <Geraldus_> _forgive me mistakes_
03:19:38 <cYmen__> When I use Maybe to signify an error. How do I tell a monad "only print this if it is not nothing"?
03:21:18 <cYmen__> hm...return ()
03:21:28 <frerich_> cYmen__: You could use 'unless (isNothing x) printMyFile'
03:21:39 <frerich_> cYmen__: Or 'when (isJust ...' if you're a more positive guy.
03:22:36 <cYmen__> if bla == Nothing then return () else dofoo bla <- how do I get the bla out of the Maybe? Do I need a case?
03:22:43 <kadoban> :t maybe (return ()) print
03:22:44 <lambdabot> Show a => Maybe a -> IO ()
03:23:04 <KaneTW> :t maybe
03:23:05 <lambdabot> b -> (a -> b) -> Maybe a -> b
03:23:19 <frerich> cYmen__: Right, you could also do 'case x of Just blah -> doSomethingWith blah; Nothing -> return()'
03:23:47 <cYmen__> So there is no "just" function or something to extract the value from a just?
03:23:55 <Cale> case bla of Nothing -> return (); Just x -> print x
03:24:31 <merijn> cYmen__: Well, what would you extract from Nothing?
03:24:39 <frerich> cYmen__: There is, it's called "fromJust". It's just not a very friendly function if you give it a 'Nothing'.
03:25:01 <merijn> frerich: à² _à² 
03:25:27 <Cale> It's good to know about fromJust
03:25:35 <Cale> Sometimes you *know* you have a Just
03:25:42 <Cale> and you don't care about what happens when you don't
03:25:53 <Cale> But ordinarily, you should just pattern match
03:25:54 <cYmen__> Well, I mean if I use "when isJust bla (dofoo fromJust bla)"....?
03:26:02 <Cale> Yeah, don't do that
03:26:14 * cYmen__ scowls at Cale.
03:26:17 <Cale> Use a case expression
03:26:20 <kadoban> cYmen__: I personally think my solution is much better, or the explicit case thing.
03:26:37 <Geraldus_> merijn: xD
03:26:53 <kadoban> Testing for isJust and such is too â€¦ it's what you'd do in C, and if you screw it up, it'll crash.
03:26:55 <cYmen__> kadoban: I'm not sure what your solution is. :)
03:27:51 <Geraldus_> cYmen: take a look a `maybe` function
03:28:01 <merijn> isJust followed by fromJust is awful
03:28:04 <Geraldus_> cYmen__: take a look a `maybe` function
03:28:06 <merijn> Use case and/or maybe
03:28:09 <kadoban> cYmen__: maybe (return ()) print yourMaybeThing    <-- will print what's in the Maybe if it's a Just, otherwise it'll do nothing.
03:28:13 <cYmen__> yeah, yeah I'm not doing it
03:28:24 <merijn> :t forM
03:28:25 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
03:28:27 <merijn> :t forM_
03:28:28 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
03:28:31 <Cale> You should only ever use one of isJust and fromJust on any given variable. If you are using both, then you're doing something wrong.
03:28:49 <Cale> and fromJust is something that should usually be treated with a lot of care
03:29:14 <merijn> :t flip forM_ print :: Show a => Maybe a -> IO ()
03:29:15 <lambdabot> Show a => Maybe a -> IO ()
03:29:22 <Cale> You may even prefer writing (\(Just x) -> x) in place of it, because at least then when you get a Nothing, the error message will include a line number
03:29:27 <merijn> Wait, I guess that's mapM_
03:29:31 <merijn> :t mapM_ print
03:29:32 <lambdabot> (Show a, Foldable t) => t a -> IO ()
03:30:13 <kadoban> merijn: That's neat
03:31:00 <merijn> Yay, go FTP ;)
03:31:32 <Cale> Any time where you use isJust/isNothing to test for whether you have Nothing or Just x, and then you proceed to use fromJust to extract the element, you've just implemented a case expression in an error prone way.
03:31:54 <cYmen__> http://i.imgur.com/JfWlYtw.jpg
03:32:08 <Cale> This has nothing to do with monads whatsoever, btw
03:32:37 <Cale> I mean, Maybe happens to be a monad, but we're not making use of that fact.
03:32:59 <cYmen__> http://i.imgur.com/2WQ3qAF.jpg
03:33:00 <Cale> Maybe also happens to be instances of lots of other classes that we're not making use of. :)
03:33:05 <kadoban> Well, the mapM_ thing does, but â€¦ you shouldn't use that yet I guess, since it won't actually work in GHC <7.10. Even though it's cool.
03:33:42 <Cale> Oh, yeah, mapM_ is making use of the fact that Maybe is a monad, but I don't think I'd usually use mapM_ like that. :P
03:33:53 <kadoban> :)
03:34:06 <_rgn> why doesn't mapM_ work in GHC <7.10?
03:35:02 <Cale> _rgn: It does, but you have to import the one from Data.Foldable
03:35:10 <Cale> _rgn: Rather than the one from Control.Monad
03:35:29 <_rgn> maybe I confused it to forM_
03:35:33 <kadoban> Oh, yeah I forgot you could do that
03:35:47 <Cale> Actually, we're not making use of the fact that Maybe is a monad, we're making use of the fact that Maybe is a Traversable
03:35:57 <Cale> (or a Foldable, I guess)
03:36:14 <Cale> I kind of hate Foldable as an abstraction
03:36:26 <kadoban> Oh right, yeah the Monad bit was the other part.
03:36:42 <frerich> I think this is all pretty good evidence why 'mapM_ print someMaybeValue' isn't such a good idea in real code. Except maybe in merijns code :-)
03:37:10 <ane> does traverse work concurrently or what am I missing here: https://code.facebook.com/posts/302060973291128/open-sourcing-haxl-a-library-for-haskell/ why do they say mapM works concurrently there, or that Applicative works concurrently?
03:37:26 <ane> it... just does?
03:37:43 <peddie> ane: the Applicative instance for that type is clever
03:37:45 <Cale> ane: They've implemented an instance of Applicative in such a way that it does
03:38:44 <Cale> Applicative basically just says that their library has a certain shaped API, it doesn't actually tell you how that API is implemented.
03:38:54 <Cale> So indeed, it can be implemented concurrently
03:43:12 <cYmen__> ,(read (show (Just 3))
03:44:35 * hackagebot html-conduit 1.1.1.2 - Parse HTML documents using xml-conduit datatypes.  http://hackage.haskell.org/package/html-conduit-1.1.1.2 (MichaelSnoyman)
04:20:54 <mniip> jle`, how about fmap g . h
04:29:38 * hackagebot memcache-haskell 0.0.10 -   http://hackage.haskell.org/package/memcache-haskell-0.0.10 (junjihashimoto)
04:37:08 <aleator> Anyone want to help me golf attoparsec code? https://gist.github.com/aleator/d8d72ebbb9f80dd458b3
04:37:38 <aleator> It tries to parse pandoc style markdown code block while preserving all characters.
04:41:05 <jellie> Trying to convert Data.ByteString.Lazy.Internal.ByteString to Data.ByteString.ByteString
04:41:12 <jellie> Any ideas?
04:41:46 <aleator> jellie: Doesn't Data.ByteString.Lazy.toStrict work for that?
04:41:46 <srhb> Aren't those the same?
04:42:00 <jellie> srhb: They aren't
04:42:06 <jellie> aleator: Let me try that
04:42:12 <srhb> I can never remember which one is the Strict one.
04:42:27 <aleator> Ah. Could it be that there are two different bytestring libs loaded at the same time? Are you doing this in ghci?
04:42:56 <bennofs> Data.ByteString is the strict one I think
04:42:59 <srhb> That's what I thought, but there would probably be more noise in the type.
04:43:01 <kqr> hello! I'm making a little command-line application which uses getContents to read from stdin. when I test it in GHCi, I can't get it to stop reading on the EOF character (ctrl-D). am I doing something wrong?
04:43:26 <kqr> (if it matters, I'm using Data.Text.IO.getContents)
04:43:37 <srhb> kqr: No, due to various ghci stuff, that is expeced.
04:43:40 <srhb> kqr: Use runhaskell
04:43:54 <bennofs> kqr: or use a file and readFile for testing
04:44:13 <kqr> I've been using runhaskell so far. the reason I want ghci now is because I want to set a breakpoint and step through the evaluation
04:44:39 * hackagebot stackage-curator 0.7.3 - Tools for curating Stackage bundles  http://hackage.haskell.org/package/stackage-curator-0.7.3 (MichaelSnoyman)
04:44:39 <kqr> I might have to create a file then
04:45:13 <kqr> though the bug might not appear when I'm reading from a file
04:45:28 <kqr> oh it does
04:46:06 <srhb> kqr: I wonder if hSetBuffering stdin LineBuffering would work
04:46:32 <srhb> Oh nah, it won't.
04:46:48 <jellie> aleator: I am
04:47:18 <jellie> aleator: Also uh converting a lazy bytestring to lazy text? or should I just fix my imports?
04:49:54 <jellie> @hoogle Data.ByteString.Lazy.ByteString -> Data.Text.Internal.Lazy.Text
04:49:55 <lambdabot> Parse error:
04:49:55 <lambdabot>   Data.ByteString.Lazy.ByteString -> Data.Text.Internal.Lazy.Text
04:49:55 <lambdabot>        ^
04:50:22 <aleator> Wait what? You are trying to convert a bytestring to text?
04:50:30 <aleator> I read your original wrong then.
04:50:50 <aleator> Data.Text.Lazy.Encoding is your friend then
04:50:51 <jellie> aleator: Yes
04:51:08 <aleator> Sorry, I got things wrong in the first place. 
04:51:52 <jellie> aleator: It's okay
04:52:12 <aleator> The text.encoding is needed for bytestring->text conversions since you have to specify the format.
04:53:04 <jellie> aleator: Well decodeUtf8 is what I get but it's not working that's for sure.
04:53:13 <jellie> :t decodeUtf8
04:53:14 <lambdabot> Not in scope: â€˜decodeUtf8â€™
04:53:40 <jellie> aleator: decodeUtf8 :: ByteString -> Text but what I have is a lazy BS
04:54:25 <aleator> jellie: https://hackage.haskell.org/package/text-1.2.0.4/docs/Data-Text-Lazy-Encoding.html says it should take lazy. Do you have the right encoding module?
04:58:45 <jellie> aleator: Uh yeah. Let me give you a paste
04:59:05 <jellie> Oh wait no
04:59:24 <jellie> The one I was using is from Data.Text.Encoding not Data.Text.Lazy.Encoding
05:00:39 <aleator> That's probably it.
05:02:25 <seye> Hi - I'm having a problem where when ghci (7.8.3) loads a .hs file that imports a module (one directory deeper), it always loads the uncompiled .hs file when there exist newer .o and .hi files in the same directory as the .hs file it imports. Any ideas? 
05:11:16 <seye> -fobject-code works, but is not what I want
05:27:00 <seye> ghci verbose
05:30:07 <Cale> seye: You may also want to ask in #ghc just to see if it gets the attention of one of the GHC devs there. I honestly am not quite sure what to do in that case.
05:33:18 <kqr> does attoparsec have some sort of function that basically does "\p d -> p <|> return d" ?
05:33:58 <seye> Cale: thanks - will do
05:33:59 <kqr> ah yeah
05:34:01 <kqr> option
05:34:12 <mniip> ((. return) . (<|>)) obviously doesn't suffice?
05:36:39 <kqr> not when the option function already exists in the combinator part of the library :)
05:52:00 <kqr> can you force an attoparsec parser to fail and backtrack if some specific value is read?
05:52:29 <kqr> I tried using the monad "fail" function but I'm not sure it does the trick â€“ it doesn't seem to trigger the ordinary backtracking
05:53:05 <merijn> kqr: Yes
05:53:24 <merijn> iirc bos added my suggestion for a "satisfy" function
05:53:35 <merijn> So you'd just have to invert your check
05:54:01 <kqr> that just applies to single characters though
05:54:19 <kqr> I'm reading a whole bunch of stuff, and then I want to check if what I just read is the empty string after I've stripped it
05:54:24 <merijn> ah
05:55:56 <kqr> what I'm really trying to do is stop the parser from reading more if it encounters a line of only whitespace
05:58:45 <merijn> Isn't that just 'blahParser >> fail "whoops"' ?
05:58:56 <merijn> I guess I don't understand what you want
05:59:43 * hackagebot jukebox 0.1.3 - A first-order reasoning toolbox  http://hackage.haskell.org/package/jukebox-0.1.3 (NickSmallbone)
06:02:45 <KorriX> Hello! I have a liitle question about attoparsec: How to fail parsing after testing all options in context?
06:03:39 <KorriX> i have a parser p = a <|> b <|> c. I'd like to make p = a <|> b <|> c <|> fail "fail here with error"
06:03:52 <merijn> KorriX: That's redundant
06:04:05 <KorriX> merijn: Why?
06:04:19 <merijn> KorriX: The second is the same as the first, you probably want to use the <?> to annotate failure
06:04:21 <kqr> merijn, apparently that should work, yeah, must be an error elsewhere in my code. thanks :)
06:04:24 <wz1000> If I want to parse UTF8 strings with parsec which string type do I use?
06:04:42 <merijn> wz1000: What do you mean "UTF8 strings"
06:04:48 <merijn> wz1000: Do you mean unicode text?
06:05:00 <wz1000> yes
06:05:02 <kqr> Text
06:05:15 <merijn> wz1000: Text and String are both unicode, so either will works
06:05:20 <KorriX> marijn: But parsing is not failing even if I have <?> at the end
06:05:25 <merijn> wz1000: Text will have better performance, though
06:05:36 <wz1000> Whats the difference between Text and ByteString?
06:05:53 <merijn> wz1000: ByteString is bytes, Text is text...
06:06:12 <merijn> The name ByteString is a horrific historical accident, they have nothing to do with strings
06:06:20 <KorriX> *merijn: Sorry :) I missed key
06:06:33 <tdammers> merijn: better than calling them just "string"
06:06:40 <tdammers> (looking at you, C++)
06:06:42 <merijn> KorriX: Then one of your parsers is succeeding
06:06:45 <kadoban> KorriX: Then one of them is succeeding.
06:06:54 <wz1000> Does Text use ByteString internally?
06:06:54 <merijn> KorriX: So adding fail won't do anything
06:06:59 <merijn> wz1000: No
06:07:13 <KorriX> merijn: Thanks. I got it
06:07:17 <merijn> wz1000: Text uses it's own internal representation that you need not worry about
06:13:51 <Tazmain> hi all, I am trying to get leksah but its failing the whole time , I am using cabal install 
06:17:29 <benzrf> hello both ghc-mod and hdevtools seem to fail to build on 7.10
06:17:33 <benzrf> please help i am now sad
06:18:22 <merijn> benzrf: If you use emacs, try ghci-ng
06:18:33 <merijn> benzrf: If you use vim, write a plugin for ghci-ng so I can use it :D
06:18:45 <merijn> benzrf: https://github.com/chrisdone/ghci-ng
06:18:51 <benzrf> i use vim
06:18:55 <Tazmain> I am sad I can't get leksah to isntall 
06:19:20 <zinfandel> Tazmain: You would have to give more details about 'failing the whole time'
06:19:46 <merijn> benzrf: Lemme check if my "god, why is hdevtools broken?!?" branch still works with 7.10
06:20:23 <bdha> Hey folks, could someone me to whoever runs (ran?) deb.haskell.org?
06:20:34 <Tazmain> here is the output of cabal install leksah http://pastie.org/10078278 
06:20:43 <merijn> bdha: #haskell-infrastructure
06:20:50 <bdha> merijn: Thanks!
06:22:03 <merijn> hmmm
06:22:11 <merijn> cabal is having a fit: "Unrecognized field data-dir on line 20"
06:23:06 <clrnd> hey, what do you think of this? https://travis-ci.org/switchface/helm/builds/56784631
06:23:16 <clrnd> why is it trying to install integer-simple O.O
06:24:12 <merijn> Ugh, why did I believe people saying "ghcformacosx" is the new super cool way to install GHC, now I have a cabal that whines about a bunch of stuff and no installed libraries >.>
06:29:45 * hackagebot plugins-multistage 0.5.2 - Dynamic linking for embedded DSLs with staged compilation  http://hackage.haskell.org/package/plugins-multistage-0.5.2 (AndersPersson)
06:29:48 <clrnd> and why doesn't integer-simple exist ...
06:34:15 <Franciman> Hi all
06:34:23 <Franciman> I'm updating cabal install but get this error:
06:34:26 <Tazmain> merijn, so no clear way to fix it ?
06:34:36 <benzrf> Franciman: thats a pretty concise error
06:34:50 <Franciman> ahah sorry
06:34:53 <Franciman> was copy pasting
06:34:55 <Franciman> Resolving dependencies...
06:34:55 <Franciman> Configuring network-2.6.0.2...
06:34:55 <Franciman> cabal: The package has a './configure' script. This requires a Unix
06:34:55 <Franciman> compatibility toolchain such as MinGW+MSYS or Cygwin.
06:34:55 <Franciman> Failed to install network-2.6.0.2
06:34:55 <Franciman> cabal: Error: some packages failed to install:
06:34:55 <Franciman> HTTP-4000.2.19 depends on network-2.6.0.2 which failed to install.
06:34:56 <Franciman> cabal-install-1.22.2.0 depends on network-2.6.0.2 which failed to install.
06:34:56 <Franciman> network-2.6.0.2 failed during the configure step. The exception was:
06:34:57 <Franciman> ExitFailure 1
06:35:06 <merijn> Tazmain: it was using the wrong cabal >.> Still, I'd rather use the platform :)
06:35:25 <merijn> Don't paste into the channel
06:35:52 <Franciman> sorry
06:36:11 <Franciman> here's the error:
06:36:13 <Franciman> http://pastebin.com/1XmTU7hs
06:36:16 <Franciman> what should I do?
06:37:34 <merijn> rerun with -v3
06:37:37 <gienah> Franciman: http://blog.johantibell.com/2011/01/setting-up-haskell-development.html
06:38:06 <merijn> oh, actually
06:38:23 <clrnd> I see it ahs to do with https://github.com/bos/text/pull/96
06:38:29 <merijn> Install from platform so you don't have to install betwork by hand
06:38:43 <clrnd> now, how can I say in a cabal file that a dependency should be installed with a flag??
06:38:55 <merijn> clrnd: you can't
06:39:12 <clrnd> merijn, you must be kidding me
06:39:36 <clrnd> any possible alternatives?
06:40:08 <merijn> Install text first with the right flag, then install whatever depends on it
06:40:41 <clrnd> merijn, oh taht's easy, thanks!
06:42:10 <Franciman> thanks
06:43:15 <Tazmain> merijn, so what do I do now, stop trying to get leksah 
06:44:46 * hackagebot language-c-quote 0.10.2.1 - C/CUDA/OpenCL/Objective-C quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.10.2.1 (GeoffreyMainland)
06:45:58 <gienah> Franciman: installing the haskell platform might be easier. Some more hints on mingw here: https://ghc.haskell.org/trac/ghc/wiki/Building/Preparation/Windows#msys2setup
06:46:17 <merijn> Wait, how does that library quasiquote CUDA but C++?
06:46:54 <merijn> s/but/but not
06:47:02 <merijn> Tazmain: I don't know, I've never used leksah
06:47:34 <StoneCypher> merijn: c++ can use the c abi, so it's probably not necessary to handle them separately
06:49:20 <merijn> StoneCypher: CUDA can contain C++ code (in fact, all of C++11 in the new release)
06:49:29 <gienah> Tazmain: you could look at line 108 of what you pasted earlier
06:49:35 <merijn> StoneCypher: Therefore the ability to quasiquote CUDA requires the ability to quasiquote C++
06:49:56 <merijn> StoneCypher: Note also that this is quasiquoting, so ABI is irrelevant
06:50:37 <merijn> benzrf: Ugh, this might be harder to fix than I hoped >.<
06:51:52 <benzrf> welp
06:53:25 <hodapp> gross
06:54:38 <nuser> Can't find the Safe.Util module imported here http://hackage.haskell.org/package/safe-0.3.8/docs/src/Safe.html
06:56:27 <nuser> Oh dear seen it on github.
06:56:30 <bennofs> nuser: it's not exposed from the package, so it can only be used for implementing the package itself
06:57:29 <Myrl> Hi guys.
06:59:17 <nuser> bennofs: yup :)
07:05:19 <Myrl> I decided to make this as a joke program, but is there a way to write it in less characters? http://ideone.com/Nfv3Jz
07:09:02 <johnw> you mean, besides using lessThan?
07:09:25 <johnw> in fact: print x < y
07:09:28 <Myrl> johnw: We were having a discussion about english in programs.
07:09:29 <johnw> so I'm not sure what the obective is
07:11:10 <Myrl> johnw: It's a joke program about using English in programming languages.
07:11:56 <johnw> then why do you want to write it in less characters?  English is full of characters :)
07:13:20 <Myrl> johnw: Well, I wanted to learn more about how to do point-free. And stuff.
07:13:39 <johnw> ah
07:13:50 <merijn> Any cabal experts?
07:13:59 <bennofs> merijn: ? what is your question
07:14:19 <bennofs> Myrl: is = flip ($) or is = flip id
07:14:22 <merijn> Should I use Distribution.Package.PackageId or Distribution.Package.InstalledPackageId in place of PackageIdentifier
07:14:24 <bernalex> Myrl: 'is' is just flip id
07:14:33 <Myrl> I see.
07:16:33 <Myrl> How does this work/
07:16:55 <Myrl> Ah.
07:17:02 <bennofs> merijn: hmm, the haddocks say that PackageId = PackageIdentifier ?
07:17:04 <Myrl> Oh wait.
07:17:26 <Myrl> ID is a function of (a -> a) How does it fit into flip's (a -> b -> c)
07:17:41 <bennofs> Myrl: take a ~ (b -> c)
07:17:49 <bennofs> Myrl: so you get id :: (b -> c) -> (b -> c)
07:18:06 <Myrl> I see.
07:18:33 <bennofs> Myrl: then notice that you can omit the final parens due to currying: id :: (b -> c) -> b -> c, therefore flip id :: b -> (b -> c) -> c
07:19:32 <Myrl> hmmm
07:20:19 <merijn> bennofs: Yeah, I found it
07:24:24 <merijn> Oh, bah, duncan isn't here...
07:25:11 <kqr> is there a neater way of accomplishing "void p <|> return ()" in attoparsec?
07:25:23 <bennofs> merijn: I don't quite understand? so you're asking if you should use PackageId or InstalledPackageId? Or did you mean that you found the solution to your question?
07:25:42 <bennofs> :t optional
07:25:43 <lambdabot> Alternative f => f a -> f (Maybe a)
07:25:50 <bennofs> :t void . optional
07:25:51 <lambdabot> Alternative f => f a -> f ()
07:25:53 <bennofs> kqr: ^^^
07:25:54 <merijn> bennofs: The existing code used PackageIdentifier, so knowing PackageId = PackageIdentifier is enough to make it work :)
07:26:05 <bennofs> ah ok
07:26:24 <kqr> bennofs, thanks!
07:28:22 <Myrl> bennofs: After 10 minutes, I finally understand, thanks.
07:29:16 <lachenmayer> is there an alternative to gitlib for dealing with git repositories in haskell?
07:30:07 <Lis> hello everyone
07:30:27 <Myrl> I see.
07:32:09 <merijn> benzrf: What do I get if I get hdevtools working again? :p
07:32:41 <bennofs> oh, why would anyone still use hdevtools?
07:33:14 <merijn> bennofs: What else?
07:33:17 <bennofs> I thought that it became obsolete when ghc-mod introduced ghc-modi
07:33:51 <bennofs> merijn: ghc-mod
07:34:32 <merijn> bennofs: Does ghc-mod grab ghc options from cabal files, run sandbox aware and maintain a persistent session instead of continuously restarting?
07:34:44 <bennofs> merijn: yes, i think so
07:34:50 <bennofs> merijn: (ghc-modi is persistent)
07:36:19 <bennofs> merijn: note that getting any such program working with Cabal 1.22 and ghc 7.8.* is impossible except if you use a separate program to extract cabal flags
07:36:21 <frerich> bennofs: How is ghc-modi better than hdevtools?
07:36:28 <johnw> lachenmayer: can I help you with gitlib?
07:36:37 <johnw> lachenmayer: there's also "hit"
07:36:38 <bennofs> frerich: better maintained. i don't think that hdevtools is actively maintained?
07:36:42 <merijn> bennofs: I only care about 7.10
07:37:14 <bennofs> merijn: ok, ghc-mod should work with 7.10 and Cabal 1.22. There was an issue about it, so I believe they do use Cabal :)
07:37:22 <merijn> hdevtools isn't maintained, the version on hackage is broken, I have a version on github with some community fixes merged in and I just got it to compile with ghc 7.10 again, but still fixing
07:37:56 <frerich> I see commits about a day ago.
07:38:06 <frerich> I don't know what repository of hdevtools you guys use though.
07:38:22 <lachenmayer> hi johnw! I'm having difficulties with constructing a "RepositoryFactory", or indeed how to do anything useful - it seems that the tutorial in Git.Tutorial is outdated.
07:38:39 <johnw> it is quite outdated, so for now the best resource is to ask me. :)  Meet me in #gitlib?
07:38:41 <merijn> frerich: The last update on hackage is Sept 2014, last commit on the maintainers repository is 2013
07:38:48 <merijn> frerich: https://github.com/bitc/hdevtools/
07:38:51 <lachenmayer> johnw: thanks for the tip about hit, I'll have a look at that first - might come back to you with a few questions about gitlib later :)
07:39:01 <johnw> ok.  there is also a hit backend for gitlib
07:39:10 <frerich> merijn: That is the maintainer? Being the maintainer and being inactive contradicts somehow, no?
07:39:18 <johnw> plus, I'm going to simplify gitlib's user-facing code significantly in the next major version
07:39:27 <bennofs> Also, I wonder: isn't it much more useful to run a REPL instead of a persistent compile server? Since the REPL will also provide syntax errors / type errors, but you additionally are able to run code in GHCi
07:39:37 <merijn> frerich: That's the person who put it on hackage and has access to update hackage
07:39:53 <merijn> bennofs: I barely run code in ghci
07:40:11 <bennofs> merijn: right, but why replicate GHCi when you can just use GHCi ? :)
07:40:12 <merijn> bennofs: I use hdevtools to get highlighting of errors in my files
07:40:33 <bennofs> merijn: ah, emacs haskell-mode can do that for a REPL too using ghci
07:40:52 <bennofs> but that is an argument
07:41:24 <merijn> I don't use emacs, so :)
07:42:34 <merijn> Christ, how many dependencies does ghc-mod have? >.>
07:43:02 <bennofs> and it doesn't even have lens
07:44:02 <frerich> merijn: FWIW I've been using schell's fork all the time, I didn't even notice that hdevtools is available via hackage... you can use http://www.toddsifleet.com/projects/github-forks#bitc/hdevtools to find active repositories.
07:45:19 <bennofs> everyone's got their own hdevtools
07:45:28 <merijn> frerich: Yeah, but if ghc-mod supports all my use-cases I might as well switch
07:46:05 <frerich> *shrug*, I don't care who maintains hdevtools - as long as it's somebody else than me :)
07:46:32 <frerich> Just addressing the 'advantage of ghc-mod is that it's maintained' thing.
07:46:36 * bennofs wonders if anyone fixed all memory leaks in the GHC API
07:47:02 <bennofs> at least when I used hdevtools, it consumed an increasing amount of memory
07:47:33 <frerich> I never actually paid attention. It always just worked for me.
07:48:34 <johnw> lachenmayer: just so you know, the way I normally recommend getting started with gitlib is to look at what "git-monitor" does, since that's a working example I use every day
07:49:50 * hackagebot orgmode-parse 0.1.0 - A parser and writer for org-mode flavored documents.  http://hackage.haskell.org/package/orgmode-parse-0.1.0 (ParnellSpringmeyer)
07:52:55 <Lis> is it possible to force the usage of a function? i have trace in Debug.Trace.trace and trace in HXT
07:53:13 <Lis> and i dont want to write Debug.Trace.trace all the time
07:53:21 <lachenmayer> johnw: ah, thanks a lot! that should get me started
07:54:13 <bennofs> Lis: you can hide 'trace' when importing hxt, using import Text.XML.HXT.... hiding (trace)
07:54:26 <Lis> ah, ok thank you
07:54:55 <bennofs> Lis: or you could import Debug.Trace qualified so you can use an abbreviation, such as import qualified Debug.Trace as D and then use D.trace to refer to the trace from Debug.Trace
07:59:50 * hackagebot pseudo-trie 0.0.4.2 - A tagged rose-tree with short circuited unique leaves  http://hackage.haskell.org/package/pseudo-trie-0.0.4.2 (athanclark)
07:59:52 * hackagebot nested-routes 0.0.3.1 - Like scotty, but nested  http://hackage.haskell.org/package/nested-routes-0.0.3.1 (athanclark)
08:02:29 <bigs> hey folks -- was wondering if anyone knew of any good blog posts regarding more advanced usages of applicatives. i've gotten the feeling that i've only been taking advantage of a few of their use cases
08:03:28 <merijn> Holy crap, how long does haskell-src-exts take to compile?
08:03:34 <johnw> bigs: oh, yes
08:03:45 <bigs> oo thx!
08:03:46 <bennofs> bigs: well, this post is not really describing the use cases, but it's a type that is only Applicative and not a Monad and can be useful in practice for "batching": http://twanvl.nl/blog/haskell/non-regular1
08:03:50 <johnw> bigs: start here: http://comonad.com/reader/2012/abstracting-with-applicatives/
08:03:56 <johnw> there are 3 posts in that series you simply must read
08:04:04 <bigs> fantastic, thank you both
08:04:12 <johnw> also, the paper on Free Applicatives is revealing
08:04:16 <bigs> cool
08:04:47 <bigs> i've got a pretty strong grasp on the algebra & category theory associated with most of what i do in haskell, but i stumbled across an intriguing use of applicatives recently
08:04:53 <bigs> that made me realize i could be doing more
08:05:24 <johnw> well, from the CT angle there are a few ways of thinking about applicatives
08:05:46 <johnw> you might also then enjoy this: http://www.fceia.unr.edu.ar/~mauro/pubs/Notions_of_Computation_as_Monoids.pdf
08:06:01 <bigs> beautiful
08:06:12 <johnw> yes, that was a very eye-opening paper for me
08:06:18 <johnw> solidified a lot of things edwardk had been telling me for months
08:06:24 <bigs> aye
08:07:04 <merijn> argh
08:07:13 <merijn> ghc-mod wasn't updated for 7.10 yet either >.>
08:07:13 <bigs> excellent -- i'm going to read through some of these today :)
08:07:22 <StoneToad> edwardk's 'blog' is awesome reading too
08:07:26 <StoneToad> https://www.fpcomplete.com/user/edwardk
08:07:53 <bigs> absolutely
08:07:58 <bigs> you know, i've always avoided RSS readers
08:08:04 <bigs> but it may be worth something to aggregate the blogs linked
08:08:19 <StoneToad> that's more of a list of stuff he's published on fpcomplete
08:08:33 <benzrf> does syntastic work with ghc mod i
08:08:36 <bigs> aye
08:08:45 <johnw> bigs: I use feedly to aggregate some 40 Haskell-related blogs
08:08:48 <johnw> it does help
08:08:58 <bigs> hmmm do you have a publishable list you could share?
08:09:02 <johnw> yeah, one sec
08:09:13 <merijn> benzrf: Dunno
08:09:34 <merijn> benzrf: Well, ghc-mod claims syntastic works with it, so presumably it uses ghc-modi
08:11:01 <bigs> i recently started a company developing a performant distributed stream processor in c++14 w/ all the latest goodies
08:11:14 <johnw> bigs: http://dl.dropbox.com/u/137615/haskell.opml
08:11:15 <bigs> but i think i'd like to move some of the scheduling logic to haskell
08:11:22 <bigs> awesome, thx!
08:11:55 <johnw> note that I include math, Coq and Agda in my general definition of "Haskell" :)
08:12:21 <bigs> yeah, quite fine with me
08:13:00 <bigs> don't play much coq, but have written a decent amount of agda & idris
08:13:15 <bigs> seems as though the two of those have come quite a ways since i last used them
08:16:27 <quintus> Hi there everyone. I know 'map' takes a function and applies it to a list of values, but is there a way to take a list of functions and apply a single value to each?
08:16:45 <merijn> Sure
08:16:48 <Clint> yes
08:16:50 <merijn> :t map ($5)
08:16:51 <lambdabot> Num a => [a -> b] -> [b]
08:16:57 <bennofs> :t \a -> map ($ a)
08:16:58 <lambdabot> a -> [a -> b] -> [b]
08:17:00 <oakwhiz> :t map (\x -> zipWith id x a) fl
08:17:00 <merijn> hmm, better use
08:17:01 <lambdabot>     Not in scope: â€˜flâ€™
08:17:01 <lambdabot>     Perhaps you meant one of these:
08:17:01 <lambdabot>       â€˜fâ€™ (imported from Debug.SimpleReflect),
08:17:06 <merijn> :t map ($'c')
08:17:07 <lambdabot> [Char -> b] -> [b]
08:17:14 <quintus> holy shit everyone okay hang on
08:17:32 <quintus> ahah you folks are better than ##C at response time, wow
08:17:49 <merijn> quintus: Also better at friendliness and usefulness than ##c :p
08:17:57 <quintus> you speak the truth
08:18:19 <bigs> yeah jeeze! ##c++ as well. so much hate
08:18:53 <Profpatsch> I wonder if thereâ€™s a better way to check the value of parsed ByteStrings, other than this: 
08:18:58 <Profpatsch> https://bigmac.caelum.uberspace.de/paste/Data.Binary.html
08:19:05 <oakwhiz> :t \a b -> map (flip (zipWith id) a) b
08:19:06 <lambdabot> [b] -> [[b -> c]] -> [[c]]
08:19:25 <Profpatsch> Maybe something with <|>, but Iâ€™m not sure how.
08:19:40 <Profpatsch> Oh, wait, Iâ€™m using cereal.
08:19:45 <Profpatsch> But that should be the same.
08:19:52 <quintus> bennofs: what's going on there with $ being used as a function?
08:20:00 <merijn> quintus: Eh, $ *is* a function
08:20:07 <merijn> A pretty trivial one, but still
08:20:11 <indiagreen> Profpatsch: if you're going to fail anyway, you don't have to do it in an if
08:20:13 <merijn> :t ($)
08:20:14 <lambdabot> (a -> b) -> a -> b
08:20:25 <indiagreen> you can do â€œunless (magic == ...) $ fail ...â€
08:20:34 <merijn> In fact, ($) is just 'id' with a more specific type :p
08:20:37 <bennofs> quintus: ($ a) is just a special syntax called "sectioning" and means the same as \x -> x $ a
08:20:42 <merijn> > succ `id` 'c'
08:20:44 <lambdabot>  'd'
08:20:53 <merijn> > succ $ 'c'
08:20:54 <lambdabot>  'd'
08:20:59 <quintus> bennofs: like (== 0) for \x . x == 0
08:21:06 <bennofs> quintus: yes
08:21:09 <merijn> quintus: Right
08:21:15 <Profpatsch> merijn: But how would I combine it with the Applicative?
08:21:18 <quintus> thanks folks!
08:21:38 <Profpatsch> Quote <$> <failpart> getByteString 5 <*> â€¦
08:21:44 <merijn> quintus: And since the function $ does "f $ x = f x", ($5) does "\f -> f $ 5" which is f $ 5 :)
08:21:58 <bennofs> Profpatsch: you could take advantage of the fact that fail aborts the parsing, and write it as magic <- getByteString 5; unless (magic == "...") $ fail "..."; ...
08:22:47 <Profpatsch> bennofs: I wanted to use applicatives.
08:23:32 <bennofs> Profpatsch: I don't see a way to use Applicatives there, since the effect depends on the value of magic, and therefore you need at least a Monad to write this
08:24:54 <Profpatsch> Quote <$> ( unless (== "...") (fail "...") <$> getByteString 5) <*> â€¦ ?
08:28:46 <Profpatsch> Nah, that doesnâ€™t work.
08:30:04 <bennofs> :t bool
08:30:06 <lambdabot> a -> a -> Bool -> a
08:30:17 <bennofs> > bool 3 4 False
08:30:19 <lambdabot>  3
08:32:37 <bennofs> Profpatsch: so if you really want, you could write join $ (\x -> if x == "..." then fail "..." else return $ Quote x) <$> getByteString 5
08:32:54 <bennofs> Profpatsch: but I don't see how that is any better than what you have (you still need Monad b.c. of join)
08:33:34 <Profpatsch> haha
08:33:54 <KorriX> I have problem with TemplateHaskell: What is the shortest way to get fully qualified function name?
08:34:02 <bennofs> @pl \x a b -> if x == "a" then a else b x
08:34:02 <lambdabot> ap (flip . ((.) .) . if' . ("a" ==)) (flip id)
08:34:29 <Profpatsch> Yeah. My problem with the monadic way is that I have to name all the fields.
08:34:33 <KorriX> if I do varE 'fmap it fails with Not in scope: â€˜GHC.Base.fmapâ€™
08:34:52 * hackagebot hoauth2 0.4.7 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.4.7 (HaishengWu)
08:34:54 <Lis> if i have a function :: String -> String and i want to use with <- within a function :: [String] -> [String] -> IO (ExitCode) what would be the best way to do so?
08:38:32 <quchen> Lis: What's the problem you're trying to solve here? What functions are you talking about?
08:39:53 * hackagebot http-client 0.4.11 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.11 (MichaelSnoyman)
08:41:32 <oconnore> Lis: return ((fn :: String -> String) "string") will give you a result of type IO (String), but it doesn't sound like you need to do that.
08:41:41 <Profpatsch> bennofs: I just define a function valueIs :: a -> String -> Get a -> Get a
08:41:53 <Profpatsch> That does that if then.
08:53:46 <indiagreen> KorriX: does Â«show 'fmapÂ» do what you want?
08:58:10 <Lis> quchen, http://lpaste.net/130305
09:01:54 <Lis> oconnore, what does the fn stand for?
09:05:29 <edwardk> StoneToad: most of my content over the years has gone up at http://comonad.com/ but i've taken to using fpcomplete to post things where having haskell run on the site would be beneficial.
09:07:36 <StoneToad> edwardk: ah, thx, I randomly ran across your cellular automata page and read around from there
09:09:58 <tsahyt> Is there a way to use a package not listed in build-depends in the cabal file in a cabal repl session? I'd like to load quickcheck to test some invariants while debugging.
09:10:15 <oconnore> Lis: your function String -> String
09:10:24 <oconnore> I didn't know what you named it
09:11:40 <jhance> What do people tend to think about using `pure` in a monad (where you could use `return`)?
09:12:12 <indiagreen> tsahyt: â€œ:set -package packagenameâ€ in repl might work
09:12:20 * bennofs sometimes uses it b.c. it's shorter
09:12:42 <jhance> I always feel like its nicer but I never see anyone else use it over return... Especially given that we now have AMP so return is kind of... useless?
09:13:36 <tsahyt> indiagreen: Oh thanks, I just got the package name wrong! I didn't think it was case sensitive.
09:13:38 <oconnore> Lis: just do: let outname = Debug.Trace.trace ("Statistics file: " ++ (configUrlEntry config)) (configUrlEntry config)
09:14:55 * hackagebot nested-routes 0.1 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-0.1 (athanclark)
09:14:56 <oconnore> Lis: it's not in the IO monad, so there is no need to get it out of the IO Monad with <-
09:16:52 <exio4> oconnore: using Debug.Trace.trace for what?
09:18:00 <geekosaur> Lis: you know about `let` in do, yes?
09:18:07 <Cale> Lis: when you write  v <- x  in a do-block for IO, it means "execute the IO action x, and call its result v"
09:18:11 <oconnore> exio4: his example already used trace.
09:18:36 <Cale> Lis: More generally, do-notation works for the actions of any monad, but you don't have to care about that.
09:19:51 <Cale> Lis: What you do need to be aware of is that whatever is to the right of the <- had better be an IO action of type (IO t), which is a sort of description of something which could be done (potentially involving I/O), and which if it terminates normally, produces a result of type t
09:19:54 <exio4> ah, didn't see it
09:20:29 <Cale> Lis: and if the thing on the right of the <- is an action of type IO t, then the thing on the left is the result of that action, which has type t
09:21:02 <Cale> Lis: You can't use <- just for defining arbitrary things, it *specifically* is used for running actions.
09:22:23 <Cale> Lis: So here, your problem is that (configUrlEntry config) (and hence the traced version of it), is not an IO action, but rather is a String.
09:22:53 * hodapp sets off to learn Shake
09:22:56 <wz1000> I have a part of code that should be unreachable. However, its type is an "ErrorT...". Should I raise a regular exception with throwError or should I use error?
09:23:03 <hodapp> this cannot possibly be worse than Gradle.
09:23:51 <Cale> wz1000: Depends on what you want the behaviour to be when the code is reached
09:23:58 <jhance> wz1000: I would use error in that case but I'd say its preference. I wouldn't want the unreachable code to contaminate the rest of my program if it was reached. Alternatively, structure your code so it can't be reached
09:24:04 <Cale> wz1000: Do you want that failure to be catchable?
09:24:05 <Lis> ah ok thank you Cale 
09:24:22 <jhance> Err, so that there is no "unreachable code" but that might not be possible
09:24:30 <wz1000> Cale: But the code should never be reached...
09:24:45 <jhance> wz1000: Is it unreachable for all inputs, or unreachable for all "sane" inputs only?
09:24:45 <Cale> wz1000: In that case, you could use error
09:24:55 * hackagebot HFuse 0.2.4.5 - HFuse is a binding for the Linux FUSE library.  http://hackage.haskell.org/package/HFuse-0.2.4.5 (M15K)
09:25:06 <oconnore> hodapp: I said the same thing, but s/gradle/maven|make|ninja|cmake/
09:26:23 <wz1000> jhance: As of now its unreachable, but if I mess up while writing more code, there is a possibillity it could be reached. If it is reached, it would be my fault, not the users.
09:27:06 <hodapp> oconnore: I'm just a little in awe at how they consider it an improvement to go from stringly-typed things like Make to dynamically-typed, loosely-typed, overly-syntactically-sugared, severely-OOP-abusing systems like Groovy.
09:27:19 <Cale> hodapp: heh
09:27:58 <hodapp> but Shake is looking good so far
09:28:07 <Cale> Yeah, Shake is decent
09:28:18 <octalsrc> question
09:28:44 <octalsrc> I'm doing a thing where I read a bunch of text from a file and then process that text character by character
09:29:02 <octalsrc> would I benefit at all from using Data.Text instead of [Char]?
09:29:14 <octalsrc> like, in between reading it and processing it?
09:29:28 <Cale> Also, propellor is really cool, I almost wish I had some sysadminning I needed to automate so that I could use it. :)
09:29:42 <Geraldus> jellie: o/
09:29:53 <jhance> wz1000: Ideally you just structure the code differently so there isn't something liek that
09:29:55 <hodapp> Cale: http://hackage.haskell.org/package/propellor ?
09:29:58 <Cale> octalsrc: probably not
09:30:07 <Cale> hodapp: yeah
09:30:15 <Cale> https://propellor.branchable.com/
09:30:21 <hodapp> Cale: huh, this is the first I've heard of it
09:30:49 <octalsrc> ok thanks
09:31:45 <Cale> octalsrc: Data.Text is more useful if you're *not* processing the text character by character. Lists of characters are pretty much ideal for that case.
09:33:45 * geekosaur had thought about doing that, but needs ghc to support more platforms >.>
09:36:54 <jhance> text could still have better memory usage...
09:37:30 <jhance> although I guess if you are doing character by character you should just do char processing over a pipe-like
09:37:51 <geekosaur> if it fuses, String might well have better memory usage
09:39:09 <wz1000> error (error "foo") behaves differently from (error $ error "foo")
09:39:34 <hodapp> alright, a little confuzzled about why system-filepath is not System.FilePath
09:42:13 <c_wraith> wz1000: GHC is free to compile imprecise exceptions any way it likes, so long as *some* exception in the code is thrown
09:42:50 <hodapp> imprecise exceptions?
09:43:07 <c_wraith> any exceptions not thrown in IO
09:43:43 <c_wraith> and error throws an exception in a non-IO context
09:44:34 <c_wraith> @src error
09:44:34 <lambdabot> error s = throw (ErrorCall s)
09:45:18 <RaceCondition> can activate-hs only work with installations of Haskell Platform, not just GHC?
09:47:29 <oliv_> hello
09:54:57 * hackagebot network-bitcoin 1.8.1 - An interface to bitcoind.  http://hackage.haskell.org/package/network-bitcoin-1.8.1 (ClarkGaebel)
10:11:17 <oconnore> how do I get the behavior of do { x <- Nothing; return $ x + 1 } => Nothing with MaybeT?
10:12:10 <oconnore> I have (not compiling) do { x <- return Nothing :: MaybeT IO (Maybe String); lift $ putStrLn x }
10:12:37 <c_wraith> you need MaybeT (return Nothing)
10:12:46 <c_wraith> I don't know why that's not defined in the library - it'd be handy
10:13:23 <oconnore> c_wraith: ah, thanks!
10:13:31 <oconnore> c_wraith: yeah, that does seem awkward
10:17:45 <quintus> Hi again
10:19:07 <quintus> If I have a list of matrixes (lists of column-lists of bools) and I want to combine them such that only cells which are true in every matrix are true.
10:20:04 <bramgg> Is there a reason besides "legacy" why the default String isn't just like Text? And why would you ever use String over Text besides to save a few seconds?
10:20:11 <stelleg> I'm trying to find that project that infers functions from types, but not having any luck, anyone remember the name of that project?
10:20:27 <bramgg> stelleg: Hoogle?
10:20:34 <quintus> so if I had [[T, T], [T, F]] and [[F, T], [F, T]] the output would be [[F, T], [F, F]]
10:20:59 <geekosaur> bramgg: because if you're processing character at a time, String will usually beat Text handily
10:20:59 <stelleg> bramgg: good guess, but it's a program that generates the function that defines a type (for non recursive types)
10:21:03 <quintus> I've been in hoogle looking at zipWith and the nesting is just making this seemingly indecipherable
10:21:54 <quintus> I could deal with it if it were lists, but it's lists of lists of lists
10:22:44 <quintus> matrix_and :: [[[Bool]]] -> [[Bool]]
10:23:16 <fizbin> stelleg: You mean djinn ?
10:23:38 <stelleg> fizbin: yes! thanks!
10:23:43 <caconym> > zipWith (zipWith (&&)) [[True, True], [True, False]] [[False, True], [False, True]]
10:23:45 <lambdabot>  [[False,True],[False,False]]
10:24:25 <quintus> caconym: that's excellent, can I get it to take a list of matrixes rather than taking them as arguments?
10:24:58 <quintus> so matrix_and :: [[[Bool]]] -> [[Bool]] rather than matrix_and :: [[Bool]] -> [[Bool]] -> [[Bool]]
10:25:08 <caconym> hmm
10:25:51 <caconym> > foldr1 (zipWith (zipWith (&&))) [[[True, True], [True, False]], [[False, True], [False, True]]]
10:25:53 <lambdabot>  [[False,True],[False,False]]
10:26:05 <quintus> You're a shining star caconym
10:26:26 <caconym> quintus: :) i'm sure some clever people in here can give you a cleaner solution than that
10:30:46 <Ainieco> hello, why people still use mtl if there is extensible effects?
10:32:31 <movsb> /wc/
10:34:51 <EvanR> @hoogle [[[a]]] -> [[a]]
10:34:53 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
10:34:53 <lambdabot> Prelude concat :: [[a]] -> [a]
10:34:53 <lambdabot> Data.List concat :: [[a]] -> [a]
10:35:03 <EvanR> that actually worked
10:35:08 <ReinH> Ainieco: because there isn't, really.
10:36:04 <Ainieco> ReinH: what do you mean? here it is https://hackage.haskell.org/package/extensible-effects
10:36:27 <ReinH> The package exists, but it isn't much more than a proof of concept.
10:36:35 <bramgg> I don't want to write T.head, T.length, T.readFile, etc. Is there an extension or something that makes "Text" functions default of "String" functions? I also don't want to have to import Prelude as qualified :p
10:36:45 <bramgg> *default over
10:37:04 <EvanR> an extension instead of a couple lines of imports ;)
10:37:34 <EvanR> perhaps make an extension sub language which does the job of imports
10:37:35 <bramgg> EvanR: an extennsion over working with imports every time I want to use a new function 
10:37:54 <bramgg> maybe I'm crazy though
10:38:00 <EvanR> exactly whats wrong with importing Prelude hiding the things you are hiding?
10:38:40 <bramgg> EvanR: nothing I guess, just thought there might be something that managed that on the fly
10:38:44 <bramgg> Will do though
10:38:48 <EvanR> if its invisible, that is bad
10:39:17 <EvanR> but if its an extension, not sure how it would be super customizable to solve similar issues
10:39:44 <EvanR> and if it were, not sure how thats better than just using imports as is
10:41:28 <octarin> Hi everybody, i'm a beginner in haskell, and I just encountered a problem for defining a simple math function :
10:41:34 <octarin> f x =  2^x / x^2
10:41:46 <c_wraith> :t (^)
10:41:47 <lambdabot> (Integral b, Num a) => a -> b -> a
10:41:55 <octarin> I've tried to manually set the prototype though
10:41:55 <c_wraith> well, that type isn't compatible with (/)
10:41:56 <octarin> f :: Integer -> RealFloat
10:42:08 <c_wraith> You can't just magically change types
10:42:09 <EvanR> RealFloat isnt a typ
10:42:24 <c_wraith> really, I think you want something more like (**)
10:42:27 <c_wraith> :t (**)
10:42:28 <lambdabot> Floating a => a -> a -> a
10:42:50 <octarin> oh, interesting
10:43:13 <octarin> the difference between ^ and ** is only the prototype so
10:43:23 <EvanR> no they are different
10:43:36 <EvanR> they have different algorithms
10:43:49 <verement> :t ((/), (^), (**))
10:43:50 <lambdabot> (Floating a2, Fractional a, Integral b, Num a1) => (a -> a -> a, a1 -> b -> a1, a2 -> a2 -> a2)
10:44:26 <EvanR> what does prototype mean?
10:44:37 <octarin> ^ is something like (product (repeat a b)) ?
10:44:39 <hodapp> I'd assume function signature
10:44:49 <octarin> Yes
10:44:51 <EvanR> octarin: right, but more efficient than that
10:44:53 <octarin> (i come from C)
10:45:35 <EvanR> **, power for fractional types, cant just be treated like repeated multiplication
10:45:36 <octarin> So thanks, it works better using **
10:47:14 <vikstrous> Hey guys, what approach would you recommend for writing c bindings? I'm trying hsc right now. Is there anything easier? I need bindings for a large number of c structs that contain pretty much only char arrays.
10:48:36 <ClaudiusMaximus> vikstrous: bindings-dsl adds some extra macros etc to hsc2hs, there's also c2hs but that's a lot more heavyweight and i've never used it
10:49:18 <johnw> ClaudiusMaximus: and c2hsc
10:49:30 <ClaudiusMaximus> johnw: not heard of that one
10:49:41 <johnw> it generates .hsc files from C headers
10:49:59 <johnw> with the intention that you edit them afterward
10:50:18 <vikstrous> Heh. Any ideas which one makes it easiest for structs of char arrays?
10:50:46 <vikstrous> Okay, maybe c2hsc is what I want.
10:50:57 <gwm_> What's the easiest way to return the last tuple in a list?
10:51:16 <ClaudiusMaximus> :t last
10:51:17 <lambdabot> [a] -> a
10:51:22 <Welkin> the last item of a list can be retrieved with last
10:51:42 <Welkin> the type doesn't matter
10:52:12 <Welkin> > last []
10:52:14 <lambdabot>  *Exception: Prelude.last: empty list
10:52:19 <Welkin> though it is unsafe
10:52:23 <Welkin> as shown above
10:52:27 <gwm_> hmm
10:52:36 <gwm_> i'm getting match type errors
10:52:48 <gwm_> winner xs = last (results xs)
10:53:00 <Welkin> okay
10:53:04 <Welkin> paste the code
10:53:06 <Welkin> @lpaste
10:53:06 <lambdabot> Haskell pastebin: http://lpaste.net/
10:53:06 <gwm_> results is a function which returns a list of tuples
10:53:19 <Welkin> show us the full source
10:53:25 <Welkin> and the error message
10:53:33 <gwm_> http://lpaste.net/130308
10:53:50 <gwm_> http://lpaste.net/130309
10:54:02 <ReinH> gwm_: winner has the wrong type signature
10:54:07 <Welkin> winner has the wrong type
10:54:18 <Welkin> it produces (Int, Party)
10:54:23 <Welkin> not `Party`
10:54:36 <gwm_> oh i see
10:54:45 <gwm_> how would i return just the first part of the tuple then
10:54:47 <gwm_> on it's own
10:54:56 <ReinH> the first part of the second part?
10:54:58 <Welkin> :t fst
10:54:59 <lambdabot> (a, b) -> a
10:55:03 <gwm_> first part
10:55:05 <clrnd> :t trd
10:55:07 <lambdabot>     Not in scope: â€˜trdâ€™
10:55:07 <lambdabot>     Perhaps you meant one of these:
10:55:07 <lambdabot>       â€˜ordâ€™ (imported from Data.Char),
10:55:10 <Welkin> > fst (3,5)
10:55:11 <lambdabot>  3
10:55:15 <gwm_> so it it would return [(a,1)] it returns a
10:55:15 <Welkin> > fst (3,5)
10:55:16 <ReinH> Your code seems to want the Party not the Int
10:55:17 <lambdabot>  3
10:55:25 <Welkin> gwm_: see above: use fst
10:55:32 <gwm_> okay
10:55:35 <Welkin> for the second item in the pair use snd
10:55:38 <Welkin> :t snd
10:55:39 <lambdabot> (a, b) -> b
10:55:46 <ReinH> :t snd . last
10:55:47 <lambdabot> [(a, c)] -> c
10:56:35 <Welkin> gwm_: if you are unsure what he type is for one of your functions, you can always leave the type declaration off and ask ghci to tell you
10:57:06 <gwm_> ahh okay
10:57:12 <Welkin> use `:type winner` in ghci once you load in your source file, after commenting out or deleting the type declaration
10:57:36 <Welkin> the shorthand version is `:t winner`
10:57:44 <Welkin> without the backticks, of course
10:57:52 <Welkin> just like on lambdabot 
11:06:38 <dmj`> is Tekmo around ?
11:07:03 <ackthet> given how there is nobody in here with that nick, I'll go with no
11:08:11 <dmj`> ackthet: thanks
11:09:14 <ackthet> :q
11:09:17 <ackthet> woops :D
11:11:07 <Newb> Hey yall, could anyone tell me where I am going wrong? http://lpaste.net/7713259164759228416
11:13:18 <Newb> Trying to insert an element into the set..
11:15:09 <oconnore> Newb: the type is "Set a" for some a. You could have a Set Int, or a Set Text, etc. But you can't have just a "Set" type
11:16:46 <oconnore> Newb: you also can't treat set's as lists. So instead of s:sn, you call "insert s sn"
11:17:44 <oconnore> Newb: also instead of `elem` you would use member
11:18:31 <Newb> Im assuming I need to derive Ord to use member and insert?
11:19:36 <oconnore> Newb: yeah
11:20:15 <Newb> I am trying not to use Data.set though, is there a way to do it without member?
11:21:16 <faux___> i have a function `func a b c` that will have one behavior if a == i or a == j or a == k, and another behavior if a == l or a == m or a == n. what's a good way to write this?
11:21:24 <oconnore> Newb: for that, your implementation works, you just got the type wrong
11:22:06 <oconnore> Newb: insertSet :: Eq a => a -> [a] -> [a]
11:22:23 <oconnore> Newb: lists don't require Ord, so you derive Eq
11:22:43 <Newb> Ok
11:23:23 <Newb> So this is my revised version which is still wrong
11:23:23 <haasn> Newb: insert x xs = x : xs
11:23:24 <Newb> http://lpaste.net/7713259164759228416
11:24:03 <Cale> Newb: You'll want your insertSet function to pattern match on the Set data constructor
11:24:12 <Cale> i.e.  insertSet x (Set xs) = ...
11:24:30 <Cale> here, xs will be the list used in the original construction of whatever Set it was
11:25:02 * hackagebot jose-jwt 0.5 - JSON Object Signing and Encryption Library  http://hackage.haskell.org/package/jose-jwt-0.5 (LukeTaylor)
11:25:03 <Cale> Or else, you could use the list function which got defined due to your use of the record syntax, to extract the list from xs
11:25:03 <haasn> Oh, yes; for my suggestion to work â€˜xsâ€™ has to refer to the list itself
11:25:07 <bramgg> Can I launch a terminal emulator with System.Process so it's not just running in the background?
11:25:48 <Cale> In your program, the list field of the record automagically defines a function  list :: Set a -> [a]  for extracting the given field from the record
11:26:19 <lpaste> Newb revised â€œSet helpâ€: â€œNo titleâ€ at http://lpaste.net/6612930440930000896
11:26:24 <Cale> bramgg: Yes
11:26:43 <bramgg> Cale: I couldn't find anything, would you mind linking to the relevant part of docs?
11:26:56 <Newb> Hi Cale, so nice to see you again, you were so helpful yestyerday.
11:27:00 <Cale> bramgg: In that, if you pick a terminal emulator as the executable to run, it will run.
11:27:27 <bramgg> heh, got it thanks :)
11:27:29 <geekosaur> define in the background
11:27:51 <bramgg> geekosaur: hidden, will exit when the Haskell script exits
11:28:18 <haasn> You can run most terminal emulators with an explicit command to execute, eg. â€œurxvt -e programâ€ will launch â€˜progrmaâ€™ inside â€˜urxvtâ€™.
11:28:24 <Cale> Newb: Yeah, I'm pretty much always here, except when I'm sleeping, which according to some people is never, but that's not really true.
11:28:30 <clrnd> FRP question (using helm): https://github.com/alvare/hsker/blob/master/src/Main.hs, how can I spawn a new enemy "every second"?
11:28:36 <Cale> (but I might not always be paying attention)
11:28:38 <clrnd> also, why if I move the mouse everything slows down
11:28:46 <bramgg> gtg, thanks all
11:28:59 <geekosaur> see, "hidden" is not something that haskell (or anything else that is not your window manager) has any control over
11:29:01 <Welkin> clrnd: did you set VSync?
11:29:03 <Cale> Newb: Okay, so your next problem is that your result is a list instead of a Set now
11:29:18 <Cale> Newb: So you need to apply the Set data constructor to turn it into a Set again
11:29:47 <geekosaur> unless you are asking about Windows in which case I think you get foreground by default with System.Process and need to indirect through cmd.exe or use the win32 interfaces to get something else
11:29:49 <Welkin> Cale: you mean apply fromList
11:29:58 <clrnd> Welkin, no, I'm not touching SDL, Helm is supposed to do that (I guess?), anyway I'm pretty sure it's because of my missuse of Signals
11:30:16 <Cale> Welkin: No, he's not using Data.Set, he's implementing his own Set data structure using lists.
11:30:23 <Welkin> Cale: I see
11:31:15 <lpaste> Newb revised â€œSet helpâ€: â€œNo titleâ€ at http://lpaste.net/6612930440930000896
11:31:18 <clrnd> my code is deffinetly faulty because as it is, `render` is called at 30fps and when I move my mouse (faster than 30fps), duplicating the first signal
11:31:46 <Newb> Hm lpaste seemss to have went down for me
11:32:53 <lpaste> Newb pasted â€œSet helpâ€ at http://lpaste.net/4427010550777511936
11:33:03 <Cale> Newb: Okay, so let's think about what elem does. x `elem` xs needs to look through the elements of the given list xs to see if the given element x occurs within it somewhere. In order to do that, it needs a way to test whether x is equal to some element of the list xs
11:33:04 <Newb> There we go :)
11:33:06 <geekosaur> Newb: insertSet :: Ord a => a -> Set a -> Set a
11:33:10 <Cale> Right
11:33:31 <faux___> how can i create a set of elements not in Ord?
11:33:36 <faux___> using Data.Set
11:33:40 <Cale> faux___: You don't.
11:34:03 <Newb> Does that mean I have to divide Ord?
11:34:09 <Cale> Data.Set (and really any efficient Set implementation) pretty much needs Ord in order to operate.
11:34:17 <int-e> faux___: you cannot use 'insert' without Ord.
11:34:35 <clrnd> whatever, I'm tired of this FRP thing, gonna use lenses and State, f**k it
11:34:41 <Cale> Newb: *Your* set implementation could get by without using insert, by simply putting new elements at the beginning of the list, say.
11:34:55 <vikstrous> Hey guys, I tried c2hsc and I'm getting a really strange error: Elf/External.hsc:256:1: parse error on input â€˜}â€™
11:34:55 <faux___> okay. what's a concise way of checking if an argument a == some value b or c or d, etc. Eg a == b || a == c || a == d ...?
11:35:03 <Newb> using x:xs ?
11:35:05 <vikstrous> Can someone take a look? https://github.com/vikstrous/binary_stream_patcher
11:35:08 <Cale> Newb: right
11:35:13 <indiagreen> faux___: elem
11:35:21 <indiagreen> a `elem` [b,c,d]
11:35:22 <Luke> Hey guys I need help w/ this problem starting in 7.10: "hpc: can not find text_IINWRW1LxFGIctooOLjJAI/Data.Text.Unsafe ..."
11:35:25 <Cale> Newb: But in really practical implementations, you'd want to insist on Ord, so that you could use some sort of balanced tree data structure which was efficiently searchable
11:35:33 <Luke> anyone know enough about hpc to help me out here?
11:35:41 <faux___> indiagreen: what if b, c, d are not in Ord?
11:35:46 <int-e> faux___: (==) needs Eq as well. (That's what Eq does: it provides an equality test for a type.)
11:35:49 <Cale> :t elem
11:35:50 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
11:35:53 <geekosaur> Data.List.elem doesn't require Ord
11:35:55 <geekosaur> only Eq
11:35:59 <faux___> okay thank you
11:36:02 <Cale> :t Data.List.elem
11:36:03 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
11:36:05 <Cale> heh
11:36:10 <maple> hello everyone
11:36:10 <geekosaur> Data.Set.Elem needs Ord
11:36:20 <int-e> :t Data.OldList.elem -- ?
11:36:21 <lambdabot>     Not in scope: â€˜Data.OldList.elemâ€™
11:36:21 <lambdabot>     Perhaps you meant â€˜Data.List.elemâ€™ (imported from Data.List)
11:36:24 <Cale> There is no escape from Foldable :D
11:36:50 <Cale> I guess we're all just teaching beginners about Foldable now :S
11:37:01 <int-e> :t GHC.List.elem
11:37:02 <lambdabot> Eq a => a -> [a] -> Bool
11:37:16 <int-e> (Don't use that one...)
11:37:19 <maple> I am trying to parse some JSON data, the schema of which allows for "OneOf" fields. I was wondering if anyone knows how to handle this using Aeson
11:37:49 <indiagreen> maple: what is OneOf? can you give an example of data you want to parse?
11:38:42 <indiagreen> you can combine aeson parsers with <|>, for instance
11:38:44 <geekosaur> vikstrous, I suspect the real problem is line 252?
11:38:49 <lpaste> Newb revised â€œSet helpâ€: â€œMore Set Helpâ€ at http://lpaste.net/4427010550777511936
11:39:23 <geekosaur> (and that hsc2hs is not handling anonymous unions properly)
11:39:31 <maple> indiagreen: in JSON, a "OneOf" field is a field that can have different types. For example, the value might be either a string, or a list of strings, or a list of objects... etc
11:39:41 <geekosaur> Newb: => was not a typo
11:39:45 <Cale> Newb: You used a -> where you needed a =>
11:40:06 <maple> indiagreen: specifically, I'm dealing with two things. 1) A field that can be either a string or a list of strings 2) A field that contains a list of either strings or another object
11:40:17 <Newb> Ah, that was dumb of me
11:40:25 <indiagreen> maple: then <|> still works
11:40:41 <vikstrous> geekosaur: Makes sense. I'll try commenting it out in the original .h
11:40:57 <Cale> maple: Yeah, if you're writing an aeson Parser, you can write Parsers for each of the cases, and then combine them together with <|> which will try each one in turn
11:41:01 <indiagreen> the string example would go like this: (a .: "field" <|> (concat <$> a .: "field"))
11:41:16 <maple> indiagreen, Cale: would I be too much of a bother if I asked for an example? I'm not sure what you mean
11:41:27 <indiagreen> sure, a sec
11:41:36 <maple> even just a pointer in the general direction will do
11:42:02 <Cale> indiagreen: Perhaps an example which doesn't concatenate would be a little better, but that'll involve defining a data type :)
11:42:25 <vikstrous> geekosaur: that was it. Thank you!!
11:42:58 <caconym> where are operators like (<|>) documented for aeson?
11:43:13 <Newb> Wohooo!!!! Got it working! Thank you guys so much!
11:43:14 <caconym> i was using it recently and had no idea that (or other operators like it) existed
11:43:19 <maple> caconym: I wonder too :(
11:43:30 <Cale> caconym: Click the Parser type, you'll see a list of instances
11:43:42 <Cale> One of which is  "Alternative Parser"
11:43:49 <Cale> (<|>) is one of the methods of Alternative
11:44:00 <Cale> http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson-Types.html#t:Parser
11:44:02 <Cale> i.e. here
11:44:15 <caconym> Cale: ah, good to know, thanks
11:45:03 <Cale> The documentation of Alternative is probably a bit too abstract to understand if you don't already know what it's for :/
11:45:13 <indiagreen> maple: http://lpaste.net/130310
11:45:57 <Luke> Cale: do you know anything about hpc?
11:46:08 <maple> indiagreen: thanks!
11:46:48 <lpaste> Cale annotated â€œNo titleâ€ with â€œexample with a proper data typeâ€ at http://lpaste.net/130310#a130314
11:47:14 <Cale> Luke: I know of it
11:47:57 <Cale> maple: I annotated it with an example which uses the constructors of a data type (like you might have in your program, only with hopefully better names than I used)
11:48:04 <Luke> hpc: can not find text_IINWRW1LxFGIctooOLjJAI/Data.Text.Unsafe in ["./.hpc"
11:48:09 <Luke> Cale: does that mean anything to you?
11:48:14 <Luke> i started getting that in 7.10
11:48:22 <Cale> Luke: hrm, not really
11:48:23 <Luke> I'm not even sure where to get help about something like this
11:48:37 <maple> thanks Cale and indiagreen, you guys rock :)
11:48:53 <Luke> Cale: where would I go for help on this?
11:48:53 <Luke> mailing list maybe?
11:49:19 <Cale> Luke: Try asking in #ghc perhaps
11:49:27 <Luke> oh I didn't even know they had that
11:49:29 <Luke> thanks
11:49:57 <Cale> (Some of the ghc devs seem to pay more attention to that, even though they're also in here)
11:52:04 <lpaste> Newb revised â€œSet helpâ€: â€œSet Questionâ€ at http://lpaste.net/4427010550777511936
11:52:42 <Newb> Can someone explain why I need the (Eq a) for setMember but not for insertSet even though both call `elem`?
11:52:57 <geekosaur> Ord implies Eq
11:53:03 <Newb> ah
11:53:05 <Newb> Gotchya thanks
11:53:16 <geekosaur> that is, Ord is defined as: class Eq a => Ord a where ...
11:53:40 <Newb> That makes sense because to determine order you need to determine equality, thanks for the helpp
11:57:08 <maple> ehm, Cale? Sorry to bother you again... but your example won't compile :/
11:57:20 <maple> Not in scope: data constructor `Foo'
11:57:25 <Cale> er, sorry
11:57:32 <maple> (and rightly so, I think: Foo is not a constructor)
11:57:42 <Cale> There wasn't supposed to be a Foo data constructor, one sec :P
11:57:51 <maple> ah ok sorry ^^
11:57:58 <maple> uh wait maybe I know how to fix it
11:58:19 <Cale> Yeah, just replace the Foo <$> with return $
11:58:30 <indiagreen> no, wait
11:58:34 <indiagreen> why return?
11:58:35 <maple> ... exactly what I was about to do (lie)
11:58:48 <indiagreen> shouldn't it be just â€œjustStr <|> listStrâ€?
11:58:49 <Cale> oh, no
11:58:51 <Cale> yeah
11:59:02 <Cale> no return :P
11:59:54 <Cale> I suppose you could use 'in' and just remove the 'do' altogether
12:00:06 <maple> Cale: it works! thanks!
12:00:23 <maple> (although it's pretty much black magic now... off to study applicative, again)
12:00:31 <indiagreen> Cale: is there something like â€œchoiceâ€ but for Alternative instead of specific parsers?
12:00:47 <Cale> maple: So, okay, to demystify that a little, you can replace <$> with fmap or liftM if you like
12:00:54 <Cale> (if you know what either of those are)
12:00:55 <indiagreen> ah, right
12:00:56 <indiagreen> asum
12:01:59 <KorriX> I have one algorithmic consideration. What is the fastest method of finding text in file, without loading whole contents into memory?
12:02:01 <maple> I'm comfortable with fmap, less with liftM
12:02:08 <maple> I love haskell, unfortunately I still suck at it
12:02:11 <Cale> maple: Okay, well, they're the same thing
12:02:28 <Cale> maple: liftM is just fmap specialised to Monad and implemented in terms of return and (>>=)
12:03:29 <caconym> Cale: thanks much for the pointer to alternative; it's one of those typeclasses that i've been completely ignoring since i started learning haskell
12:03:37 <maple> Cale: ah ok, thanks
12:03:47 <caconym> Cale: even to the point where i've written a bunch of monads with that functionality :(
12:03:47 <KorriX> I have a huge dictionary with metadata associated to every word. I want to query metadata without having whole dict in memory (is too big)
12:03:58 <Cale> caconym: It's mostly convenient as an interface when using parser libraries
12:04:03 <Cale> ah, haha
12:04:15 <Cale> Well, there's also MonadPlus, which is kind of the same thing with different notation
12:04:39 <caconym> Cale: yeah i kinda wrote it off as part of that big constellation of error/exception monad stuff
12:05:03 <aupiff> how does the "cabal configure --enable-executable-profiling" flag work with ghc to allow the use of the -pa RTS flag?
12:05:23 <caconym> Cale: it seems like every time I write a complicated program with errors/exceptions i end up doing something slightly different :/
12:06:13 <indiagreen> KorriX: it's possible that â€œbreakOnâ€ from Data.Text.Lazy would discard chunks as they are checked (so you can fuse it with readFile), but this has to be tested
12:06:38 <Luke> Cale: great suggestion w/ #ghc. they are helping a ton!
12:06:51 <Cale> Luke: Yeah, I saw that :)
12:07:32 <Luke> the guys from 1984 are helping me ;-) big brother
12:08:29 <sinelaw> recommendation for pretty printing lib? hughesPJ, the Wadler-based ones; etc
12:08:31 <KorriX> indiagren: Thanks
12:08:36 <sinelaw> too many options
12:09:13 <Welkin> what about 1984?
12:09:30 <Luke> Welkin: the guy that's helping me is named thoughtpolice ;-)
12:09:38 <caconym> KorriX: do you want to do better than a linear search for each lookup?
12:10:12 <Welkin> on freenode?
12:10:32 <KorriX> caconym: I can do linear preprocessing. But I want to query as fast as possible
12:10:39 <Luke> yes
12:11:32 <KorriX> caconym: Any ideas? It's dict of words in natural language
12:12:06 <caconym> KorriX: I am not really a systems programming type but could you do some kind of binary search using random access into the file?
12:12:16 <caconym> KorriX: assuming that the dictionary is sorted
12:12:39 <KorriX> caconym: Yes it is
12:13:15 <KorriX> caconym: I was thinking about binsearch, but indexing lists is O(n)
12:13:21 <maple> ok, now I am trying to use that new type in a new type. This code (http://lpaste.net/130315) won't compile because of "No instance for (GToJSON (Rep AuthorInfo))"... Cale, indiagreen, do you mind if I ask you again?
12:13:31 <KorriX> caconym: Is there any lazy datastructure with O(1) indexing?
12:13:55 <bennofs> maple: can you paste the full error?
12:14:07 <caconym> KorriX: nothing comes to mind :)
12:14:19 <indiagreen> maple: you want an autoderived insance for AuthorInfo, but it's not an instance of Generic
12:14:28 <indiagreen> maybe this is what's wrong?
12:14:44 <indiagreen> not sure, 'cause never used autoderived instances
12:14:45 <Cale> yes
12:14:50 <Cale> That's what wrong
12:14:58 <maple> indiagreen: did I mention i really suck at haskell? that was it, thanks
12:15:16 <caconym> KorriX: by "binary search" i meant more just enter the file at the middle, seek to the "nearest word", and then rinse and repeat using random access into the file without first iterating over any part of it
12:15:22 <Cale> The ToJSON instance is blank, which in order to do that, requires generics, so you need to add deriving (Generic) if you really wanted to do that.
12:15:42 <caconym> KorriX: but I am embarrassed to admit that I do not know the specifics of how random file access works and whether or not that would be efficient
12:15:43 <Cale> However, in this case, since you're writing a custom parser, you probably also want to write a custom toJSON
12:16:06 <sammecs> Hi, if I have a string like "hello%20world" (from http get variable), is there an easy library for converting it to "hello world"?
12:17:08 <indiagreen> sammecs: yes, network-uri
12:17:20 <indiagreen> look at unEscapeString in Network.URI
12:17:59 <sammecs> inidagreen: Thanks!
12:18:07 <Cale> I kind of feel like this ought to be the job of something earlier on in whatever it is that sammecs is probably doing, but without more details it's hard to say.
12:19:00 <Cale> Just note that network-uri also contains lots of other functions for deconstructing and reconstructing URIs which will automatically do the escaping and unescaping for you, at least.
12:19:03 <KorriX> caconym: I was thinking about some hash function giving the byte offset of the word + fseek
12:19:32 <caconym> KorriX: you could definitely do a linear preprocessing first and build a bap from words to byte offsets, if you have enough memory for that data structure
12:20:10 <KorriX> caconym: bap?
12:20:15 * hackagebot users 0.2.0.1 - A library simplifying user management for web applications  http://hackage.haskell.org/package/users-0.2.0.1 (AlexanderThiemann)
12:20:17 * hackagebot users-postgresql-simple 0.2.0.0 - A PostgreSQL backend for the users package  http://hackage.haskell.org/package/users-postgresql-simple-0.2.0.0 (AlexanderThiemann)
12:20:26 <caconym> KorriX: hahaha s/bap/map/
12:21:00 <clrnd> @pl f a b = a b
12:21:00 <lambdabot> f = id
12:21:07 <KorriX> caconym: Ok. Now is clear.
12:21:24 <caconym> KorriX: for the initial pass through the file, something like pipes or conduit might be a good choice, they are designed to deal with streaming problems like this while being careful about memory usage
12:21:33 <clrnd> @pl f a b = b
12:21:33 <lambdabot> f = const id
12:22:49 <KorriX> caconym: I'll try them
12:24:19 <caconym> KorriX: unfortunately i can't recommend one over the other because i've used neither seriously and i'm not sure if either one has more momentum in the community than the other
12:25:15 * hackagebot users-test 0.2.0.0 - Library to test backends for the users library  http://hackage.haskell.org/package/users-test-0.2.0.0 (AlexanderThiemann)
12:25:28 <maple> bye guys, thanks for the help
12:29:07 <Cale> By the way, ryantrinkle's talk on his new FRP system Reflex here: https://www.youtube.com/watch?v=mYvkcskJbc4 + https://www.youtube.com/watch?v=3qfc9XFVo2c interactive slides here: https://obsidian.systems/reflex-nyhug/ was really great, and I recommend everyone watch it at some point :)
12:33:42 <levi> Cale: Cool, thanks for the link.
12:34:09 * bennofs will watch
12:38:08 <Newb> Finally managed to implement 5 functions by myself with no errors, maybe im finally getting the hang of this lol. Thanks for all the help again Cale and everyone else who helpeed me
12:38:31 <Cale> Newb: No problem, feel free to ask any questions you might have :)
12:40:59 <Newb> Well. Since your offering ... haha . Could you maybe expand out this code for me or break it down for me, it is so conscise its hard for me to understand, I know it's making pythagorean triples but I am not sure how http://lpaste.net/856899714182807552
12:42:01 <bramgg> "data Count = One | Two | Three" <-- How can I pattern match which constructor a "Count" variable is? Or by wanting to do this does this mean I've designed my data structure badly?
12:42:27 <bramgg> (any way besides case of, eg in guards?)
12:43:08 <mauke> are you asking how to do pattern matching without using pattern matching?
12:43:14 <mauke> because that's what case/of is for
12:43:22 <bramgg> isn't that also what guards are for?
12:43:24 <caconym> bramgg: do you mean like `isJust` kinda?
12:43:27 <caconym> :t isJust
12:43:28 <lambdabot> Maybe a -> Bool
12:43:38 <bramgg> @hoogle isJust
12:43:39 <mauke> no, guards just add arbitrary conditions
12:43:39 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
12:43:56 <mauke> on top of a pattern
12:44:09 <mauke> unless you include pattern guards, then it's matching again
12:44:17 <bramgg> caconym: i don't think so
12:44:32 <bramgg> mauke: thanks
12:44:48 <mauke> see also: view patterns
12:45:34 <Xe> is IO confused as a monad because the IO actions of a haskell program technically form a monad in terms of the fact that it is a sequence of steps?
12:45:47 <Tazmain> hi all, is ghc like for beginners the best compiler. Also I am on arch linux as well 
12:45:52 <arkeet> IO *is* a monad
12:46:01 <arkeet> but most monads are not IO
12:46:02 <mauke> Tazmain: ghc is *the* compiler
12:46:12 <jhance> ghc is the only compiler for Haskell, others don't exist, don't let others fool you otherwise
12:46:23 <Cale> Well, there's also ghcjs ;)
12:46:41 <jhance> js is a figment of your imagination
12:46:56 <indiagreen> I wish
12:46:59 <Cale> Javascript is the new machine language
12:47:18 * Clint twitches.
12:47:35 <Tazmain> yeah that would make you twitch 
12:47:52 <dmj```> js is the new js
12:48:30 <Cale> Xe: In my experience, the fact that IO is a monad rarely confuses beginners so much as the fact that there is a type of IO actions in the first place.
12:48:34 <bramgg> Tazmain: also check out runhaskell
12:48:55 <Tazmain> bramgg, what is that ?
12:49:23 <Cale> Xe: Just getting your head around the fact that there are these things called IO actions, and you can only execute them from inside other IO actions, and evaluation and execution are separate things...
12:49:33 <Xe> I've heard inconsistent reports that IO is a monad and that it is not
12:49:40 <jhance> runhaskell is ghc
12:49:49 <Clint> Xe: does it matter?
12:50:01 <bramgg> Tazmain: GHC but interpreter-like, so you don't need to wait for your program to compile every time you want to run it in development
12:50:02 <Cale> Xe: The fact that IO happens to be a monad (it is), just tells you something about the API you use to combine IO actions together into more complicated ones.
12:50:05 <bramgg> I don't know how it's made
12:50:11 <jhance> Xe: instance Monad IO where is a thing, therefore, it is a monad
12:50:17 <MP2E> IO is a type, it just happens to be an instance of Monad. I don't think anyone would say 'IO is not a monad' just that it's better not to say 'IO Monad' every time you want to refer to IO
12:50:23 <kadoban> Xe: Monad is just a typeclass that IO is an instance of. It's other things as well, and you don't need to understand Monads fully to use IO.
12:50:28 <dmj`> Xe: it's like a state monad for RealWorld
12:50:30 <Tazmain> bramgg, basically like c or c++ or jav
12:50:31 <Tazmain> java
12:50:47 <johnw> dmj`: that doesn't take exceptions into account
12:50:59 <indiagreen> or parallelism, I think?
12:51:00 <Cale> Well, not only is it an instance of the Monad type class, but it is an honest to goodness monad. It's implemented in a bit of a hacky way in GHC, but it could just as well be implemented as a free monad.
12:51:11 <mauke> johnw: or threads
12:51:32 <bramgg> Tazmain: I don't understand the correlation you're making, sorry :/
12:51:37 <dmj`> type IO a = RealWorld -> (a, RealWorld)
12:51:51 <bramgg> Tazmain: AFAIK its just GHC but you don't need to compile and run the binary, it just runs it on the fly
12:51:56 <Cale> Saying that it's like a state monad for RealWorld is more confusing than it is helpful, and it's not even formally useful, because there's no type RealWorld, no matter how complex, which could possibly serve that purpose.
12:52:06 <jhance> bramgg: It compiles it then runs it
12:52:17 <bramgg> ^
12:52:29 <Cale> Inside GHC, the implementation looks a little like that, but the "RealWorld" values are 0-byte tokens, and the functions are impure.
12:52:32 <jhance> Cale: Isn't RealWorld# a thing though somewhere? With ST monad or something
12:52:36 <Cale> yes
12:52:36 <bramgg> I'm assuming in /tmp
12:52:51 <Cale> But that's a terrible way to understand how the IO monad works as a user.
12:53:48 <Tazmain> bramgg, oh I see now 
12:53:48 <Cale> Like, basically, it's just a hack to get the existing dependency analysis stuff in GHC to keep track of the order in which effects occur
12:53:58 <Cale> It's not a good mental model for the IO monad at all.
12:54:16 <ggVGc> how can I find the number of leading spaces in a string?
12:54:25 <Cale> ggVGc: length . takeWhile isSpace
12:54:39 <ggVGc> thanks
12:56:35 <SrPx> How can I simplify `f >>= (g . pure)` ?
12:56:40 <bennofs> Cale: reflex looks really nice, but it seriously needs some documentation :( Also, I feel like the interface could be simplified
12:56:50 <SrPx> return*
12:56:52 <bennofs> SrPx: g f ?
12:57:13 <ggVGc> Cale: hm, actually what I need is to turn a string into only its leading spaces. Do you have a quick trick for that too?
12:57:14 <dmj`> g <$> f
12:57:21 <bennofs> dmj`: that would be f >>= pure . g
12:57:29 <mauke> ggVGc: takeWhile isSpace
12:57:34 <ggVGc> ahh
12:57:36 <ggVGc> thanks :)
12:57:37 <dmj`> f <*> g
12:57:45 <dmj`> er, g <*> f
12:57:49 <SrPx> None of those...
12:57:52 <ggVGc> mauke: ahh, now I get it.
12:57:52 <ttt_fff> is there a way in haskell to separate out into *.h and *.c files? i.e. the *.h files just has type signatures of top level defs; and the *.c file has the actual definition of the functions; the goal here is to have faster compilation
12:57:54 <ggVGc> silly
12:58:07 <ttt_fff> where during compilation, it just reads the type signature top level of the modules, instead of recompiling the entire module
12:58:09 <kadoban> :t \f g -> f >>= (g . pure)
12:58:10 <lambdabot> (Monad m, Applicative f) => m a -> (f a -> m b) -> m b
12:58:24 <vikstrous> How do I read bytes from a file into a Storable struct / instance defined with FFI? I know how to get a ByteString, but how to I turn that ByteString into a C struct?
12:58:25 <jhance> ttt_fff: why are you using that backend...
12:58:31 <bennofs> oh, I missed that f doesn't have to equal m :|
12:58:40 <Cale> bennofs: Yes, I think Ryan is aware of both of those things. He mentioned he wanted to clean up the type of merge.
12:58:42 <SrPx> This is the case, btw... you might know better â†’ http://lpaste.net/130317
12:58:43 <ttt_fff> jhance: err? I want to separte *.hs into *.hs_header and *.hs_body
12:58:48 <dmj`> :t \f -> fmap (f<*>)
12:58:49 <lambdabot> (Functor f, Applicative f1) => f1 (a -> b) -> f (f1 a) -> f (f1 b)
12:59:10 <SrPx> Can certainly be improved
12:59:19 <SrPx> a lot
12:59:27 <bennofs> Cale: oh nice, I'd be really interrested in that. Also, some of the typeclasses used there seem like overkill (some with only one instance?)
13:00:10 <Cale> bennofs: which?
13:00:32 <bennofs> Cale: FunctorMaybe or smth
13:00:51 <Cale> oh, yeah :P
13:00:56 <bennofs> Seems pretty adhoc for a typeclass to me
13:01:23 <indiagreen> SrPx: this looks kinda like â€œchar ' ' *> parseTerm <* char ')'â€ to me
13:01:44 <Cale> bennofs: Well, there are other types which could fit that.
13:01:56 <SrPx> interesting lmg *>
13:03:04 <Cale> (most container-like functors, or ones which support nondeterminism somehow)
13:03:08 <arkeet> :t \f g -> f >>= g . pure
13:03:09 <lambdabot> (Monad m, Applicative f) => m a -> (f a -> m b) -> m b
13:03:18 <arkeet> g f?
13:03:31 <Cale> bennofs: But it doesn't really belong in Reflex exactly.
13:03:32 <arkeet> maybe not.
13:03:54 <bennofs> I'm considering if I should switch to reflex from reactive-banana for my implementation of a FRP-based interface for HsQML
13:03:55 <arkeet> > [1,2,3] >>= map (+1) . pure
13:03:56 <lambdabot>  [2,3,4]
13:04:00 <arkeet> maybe it is.
13:04:08 <arkeet> if g is fmap of something.
13:04:15 <arkeet> but otherwise who knows.
13:04:17 <bennofs> Cale: I'm not exactly a fan of making up lots of little typeclasses that do not exist somewhere already :)
13:04:41 <Newb> Cale is there an easy way to alter my Show set or create a helper function that prints the elements of my set between curly braces? http://lpaste.net/211554768852615168
13:04:50 <jhance> bennofs: Its okay if you put them in their own package imo
13:05:50 <arkeet> ttt_fff: why do you want to do that?
13:05:59 <ttt_fff> arkeet: faster compile times
13:06:10 <jhance> ttt_fff: Not sure how you'll get fast compile times that way.
13:06:12 <Cale> Newb:  show (Set xs) = "{" ++ intercalate ", " (map show xs) ++ "}"
13:06:24 <arkeet> you'll miss out on cross-module inlining and stuff.
13:06:34 <arkeet> modules already are compiled separately.
13:07:06 <arkeet> ghc makes .hi files
13:07:16 <ttt_fff> well, there is compile final fast version
13:07:21 <ttt_fff> andrepl-ish-compile fast slow version
13:07:23 <arkeet> that contain what you ened to import a module
13:07:35 <ttt_fff> i just want a fast compilation during development
13:07:39 <ttt_fff> even if the output binary is slow
13:08:13 <jhance> ttt_fff: then don't use -O2?
13:08:17 <arkeet> maybe you can try disabling some optimizations then
13:08:41 <Newb> Hm intercalate you say
13:09:46 <arkeet> > intercalate "," (words "abc def g")
13:09:48 <lambdabot>  "abc,def,g"
13:10:03 <Cale> > intersperse "-=-" ["one", "two", "three"]
13:10:05 <lambdabot>  ["one","-=-","two","-=-","three"]
13:10:10 <Cale> > concat (intersperse "-=-" ["one", "two", "three"])
13:10:11 <lambdabot>  "one-=-two-=-three"
13:10:20 <Cale> > intercalate "-=-" ["one", "two", "three"]
13:10:21 <lambdabot>  "one-=-two-=-three"
13:10:44 <Cale> intercalate xs ys = concat (intersperse xs ys)
13:10:55 <Newb> Ahh
13:11:40 <brbblnch> Hi. So, I'm still having troubles getting the Curry-Howard correspondence, mainly for the (=>-intro) part. Can somebody read http://lpaste.net/3008250305922990080 and tell me their opinion?
13:15:28 <arkeet> ttt_fff: so yeah, use -O0
13:15:37 <arkeet> and if you just want to typecheck stuff you could use -fno-code
13:15:53 <Cale> brbblnch: I'm a bit confused about what you're asking...
13:16:32 <arkeet> but -O0 is the default anyway.
13:18:38 <brbblnch> Cale: I've got those two "versions" of natural deduction. One in which you have to kill one unique hypothesis, the other in which you are free to kill zero or more (for =>-introduction). None seems satisfying. The first because the term corresponding to "A=>Top" doesn't have the same structure as the proof, the second because there is no unique/intuitive way to get a lambda term corresponding to the proof
13:18:39 <monochrom> =>-intro corresponds to lambda abstraction, i.e., the typing rule "from (x::T |- expr::U), deduce (|- (\x -> expr) :: T -> U)
13:19:36 <vikstrous> How do I turn a ByteString into a [CUChar]?
13:19:37 <Cale> brbblnch: You should use the one which looks like  from Gamma, A |- B, deduce that Gamma |- A -> B
13:19:54 <Cale> Or similar without the Gamma
13:19:57 <dmj`> vikstrous: what is a CUChar
13:20:08 <solidus-river> vikstrous search for a function of type ByteString -> [CUChar] on hackage :P
13:20:18 * hackagebot optimal-blocks 0.1.0 - Optimal Block boundary determination for rsync-like behaviours  http://hackage.haskell.org/package/optimal-blocks-0.1.0 (tsuraan)
13:20:19 <vikstrous> I tried :(
13:20:31 <solidus-river> is cuchar a constant unsigned char?
13:20:33 <vikstrous> http://hackage.haskell.org/package/base-4.8.0.0/docs/Foreign-C-Types.html#t:CUChar
13:20:48 <vikstrous> I think so
13:20:51 <indiagreen> wouldn't it be just (fmap CUChar . unpack)?
13:20:59 <indiagreen> no, map, not fmap
13:21:15 <solidus-river> :t fmap CUChar . unpack
13:21:16 <lambdabot>     Not in scope: data constructor â€˜CUCharâ€™
13:21:16 <lambdabot>     Perhaps you meant one of these:
13:21:16 <lambdabot>       variable â€˜fpCharâ€™ (imported from Text.Printf),
13:21:22 <brbblnch> Cale: You mean the first one, where you have to always kill one unique hypothesis?
13:21:35 <Cale> brbblnch: Yes.
13:21:46 <dmj`> vikstrous: if you can convert it to a CString...
13:21:49 <dmj`> packCString :: CString -> IO ByteString
13:22:01 <dmj`> oops, that's backwards
13:22:04 <vikstrous> Well, it's binary data...
13:22:13 <dmj`> useAsCString :: ByteString -> (CString -> IO a) -> IO a
13:22:18 <indiagreen> vikstrous: CUChar is just a wrapper over Word8
13:22:25 <indiagreen> convert a ByteString to [Word8]
13:22:33 <indiagreen> then apply CUChar and you'd get [CUChar]
13:22:40 <brbblnch> Cale: But then the term of type "A => \top" is "\x -> *" which structure doesn't fit the proof of "A => \top". 
13:22:46 <vikstrous> But isn't ByteString already a [Word8]?
13:22:54 <indiagreen> no, it's a special type of array
13:22:56 <Cale> brbblnch: Sorry, what?
13:22:59 <indiagreen> and [Word8] is a list
13:23:07 <Cale> brbblnch: Which proof?
13:23:13 <indiagreen> so you need to unpack it first, using Data.ByteString.unpack
13:23:16 <brbblnch> Cale: The proof of "A => True"
13:23:16 <vikstrous> oh, yeah, it's multiple [Word8]'s
13:23:18 <Newb> Can anyone expand out this code for me or break it down for me, it is so conscise its hard for me to understand, I know it's making pythagorean triples but I am not sure how http://lpaste.net/856899714182807552
13:23:25 <Cale> Any proof that A => T should invoke implication introduction.
13:23:55 <solidus-river> Newb: it takes an int and produces a list of 3-tuples of ints
13:23:57 <Cale> Your rule regarding T only gives you a derivation of T from A, not an implication
13:24:25 <brbblnch> Cale: At line 56 of the link I gave, there is the proof of "A => \top"
13:24:43 <solidus-river> adnon the right its a big comprehension, so it produces an x,y,z for all x's from 0 -> n, y's from 0->n, z's from 0->n, onlywhere x^2 + y^2 == z^2 and x>0, and y>0
13:24:44 <Cale> I'm not sure I understand your notation
13:25:14 <Newb> I got that much solidus-river, but what is all the stuff that comes after that
13:25:27 <Newb> (the qualifications, lists etc.)
13:25:31 <Cale> brbblnch: What is [x:A]?
13:25:34 <brbblnch> Cale: Which notation ? [x:A] denotes the hypothesis x:A killed
13:25:37 <solidus-river> Newb: its a list comprehension, assigning x, y, z then filtering based on 3 comparisons
13:25:48 <Cale> Okay, what do you mean by "killed"?
13:25:53 <solidus-river> Newb: when those comparisons are all tru it spits them out in a tuple
13:26:02 <cfoch> Hello, folks o/
13:26:25 <cfoch> When I am going to use the parseModule function I need to pass the entire content of the .hs as a string?
13:26:25 <Cale> brbblnch: You ought to have some rule that from an empty context, or from an arbitrary one, you can derive T
13:26:27 <cfoch> https://hackage.haskell.org/package/haskell-src-exts-1.16.0.1/docs/Language-Haskell-Exts-Parser.html#g:3
13:26:43 <brbblnch> Cale: x:A is killed if it has been consumed by an implication introduction, ie you don't use it as an hypothesis anymore
13:26:45 <Newb> solidus-river okay, so to understand it better I should look up filtering?
13:26:48 <Cale> okay
13:27:03 <cfoch> I mean, I need to read the .hs file as a simple string, then I can parse it. Is that correct?
13:27:18 <brbblnch> Cale: The rule is "Assuming nothing, top is true"
13:27:43 <solidus-river> Newb: yeah, you should look up list comprehension syntax, its really just syntactic sugar for a monad if i'm remembering right
13:28:25 <brbblnch> Cale: But it doesn't work, because I need to have a hypothesis of A if I want to do a legal =>-intro. So I changed the rul for top to "Assuming anything, top is true"
13:28:26 <ryantrinkle> bennofs: it would be great to talk about HsQML and Reflex
13:28:27 <solidus-river> Newb: learn you a haskell, then real world haskell are the best books I think to recommend for someone, starting with learn you a haskell
13:28:28 <Cale> brbblnch: Okay, so you can apply a structural rule to dismiss A and get back to an empty context
13:28:32 <solidus-river> Newb: both are available online
13:28:39 <brbblnch> Cale: Yes, 
13:28:41 <Cale> brbblnch: from which you can invoke your rule to obtain T
13:28:45 <ryantrinkle> bennofs: also, I totally agree about FunctorMaybe and the other API cleanups you mentioned
13:28:46 <brbblnch> Cale: Yes
13:28:56 <brbblnch> Cale: (Thanks to take the time)
13:28:58 <bennofs> ryantrinkle: I just started looking at reflex, not quite sure how to use it yet :D
13:29:11 <Newb> Thanks solidus-river, Ive seen the word monad here quite frequently and have been avoiding it, but I guess now is the time to figure it out. and Yeah ive been looking at learn you a haskell a lot
13:29:39 <bennofs> ryantrinkle: so Reflex.Spider seems to be the implementation of the FRP system?
13:29:40 <Cale> brbblnch: and then you use that whole derivation in the rule for implication introduction, which requires a derivation A |- T, and gives you that |- A -> T
13:29:48 <ryantrinkle> bennofs: yeah, that's correct
13:29:53 <brbblnch> Cale: Yes
13:30:03 <solidus-river> : [(x,y,z) | x <- [0..10], y <- [0..10], z <- [0..10], x^2 + y^2 == z^2, x > 0, y > 0]
13:30:07 <Cale> brbblnch: The very same thing is going on when you add the types into the picture
13:30:10 <ryantrinkle> bennofs: i've got a couple of other implementations kicking around, but that one is the best
13:30:11 <solidus-river> darn, i forgot how to make lambdabot eval
13:30:13 <Cale> er, the terms :)
13:30:41 <Cale> So, given x:A, we can apply a structural rule to dismiss x:A and get an empty context, i.e. x:A |-
13:30:47 <bennofs> ryantrinkle: btw, any particular reason you didn't use something like ref-fd for Control.Monad.Ref?
13:30:52 <nitrix> Hi, I'm using pipes and I'm a little confused as to the last type argument for Consumers, Producers, Pipes, etc. The documentation/tutorial says it'd be an `Producer ProducedType IO ()` and so on, the function `each` seems to agree with this, although, what if I want to eventually return a value? I tried changing the (), it made me refactor all my producers and consumers, and I hit a wall because `each` is
13:30:54 <nitrix> apparently assuming `()`.
13:30:58 <ryantrinkle> bennofs: i probably didn't know about it :P
13:31:02 <nitrix> Is it because I'm using runEffect? I don't get it.
13:31:12 <solidus-river> > [(x,y,z) | x <- [0..100], y <- [0..100], z <- [0..100], x^2 + y^2 == z^2, x > 0, y > 0]
13:31:14 <brbblnch> Cale: But it seemed to me that the correspondence preserved the structure of the proof to the structure of the terms
13:31:15 <lambdabot>  mueval-core: Time limit exceeded
13:31:17 <Cale> and then from the empty context, we can get ():T
13:31:21 <ryantrinkle> bennofs: i looked around for a little while, but didn't find anything that fit quite perfectly
13:31:27 <brbblnch> Cale: ie the form of the tree stays the same
13:31:42 <Cale> bear with me here, it should...
13:31:57 <ryantrinkle> bennofs: there are a few oddities with my MonadRef, such as supporting atomicModifyRef
13:31:58 <solidus-river> > take 10 [(x,y,z) | x <- [0..100], y <- [0..100], z <- [0..100], x^2 + y^2 == z^2, x > 0, y > 0]
13:32:00 <lambdabot>  [(3,4,5),(4,3,5),(5,12,13),(6,8,10),(7,24,25),(8,6,10),(8,15,17),(9,12,15),(...
13:32:06 <solidus-river> there you go
13:32:11 <hexagoxel> Newb: it should be equivalent to `do { x <- [0..n]; y <- [0..n]; z <- [0..n]; guard (x^2 + y^2 == z^2); guard (x>0); guard (y>0); return (x,y,z) }`
13:32:12 <bennofs> ryantrinkle: ref-fd has an additional class for that too
13:32:14 <ryantrinkle> it should really be in a separate package
13:32:18 <hexagoxel> if that helps .. :)
13:32:31 <Cale> So, the corresponding rule for implication introduction is that from x:A |- y:B we can deduce |- (\x -> y) : A -> B
13:32:44 <bennofs> ryantrinkle: http://hackage.haskell.org/package/ref-fd-0.4/docs/Control-Monad-Ref.html#t:MonadAtomicRef :)
13:32:58 <Cale> So, we have a derivation x:A |- ():T
13:33:11 <solidus-river> and it will consider those outs id in so if you look at that its goin 0,0,0 -> 0,0,1 -> 0,0,2
13:33:21 <Cale> and from that, we deduce  |- (\x -> ()) : A -> T
13:33:58 <Cale> brbblnch: Does that make sense?
13:34:10 <Cale> brbblnch: I'm not sure if I'm addressing your question...
13:34:40 <sagittarian> i just wrote a simple PRNG in order to teach myself about the state monad
13:34:58 <ryantrinkle> bennofs: ah, cool
13:35:02 <ryantrinkle> i should probably switch it over, then
13:35:11 <bennofs> ryantrinkle: there is even ref-tf for the typefamilies version. 
13:35:12 <sagittarian> once I wrote all the functions and got it working, I wanted to make a function that would take a seed and return an infinite list of pseudorandom numbers
13:35:20 <Cale> brbblnch: Maybe it's confusing because we're using the structural rule to discard the x because we don't need it since we have a constructor for T anyway?
13:35:24 <sagittarian> I implemented it like this: ranList seed = evalState ran01 seed : ranList (nextSeed seed)
13:35:43 <sagittarian> ran01 is the function that advanced the state and returns a new pseudorandom number
13:36:04 <sagittarian> so in an imperative language that would worry me, because i'm calculating (nextSeed seed) twice
13:36:10 <Cale> brbblnch: There's a way to set things up so that you don't have to apply structural rules, but you pay for it by having lots of arbitrary contexts in your rules, rather than empty ones.
13:36:17 <sagittarian> is it possible to know if ghc optimizes that and only calculates it once?
13:36:19 <brbblnch> Cale: If I'm understanding right, the "type derivation tree" of the term is the same as the proof in natural deduction ?
13:36:31 <Cale> (well, you get rid of one of the structural rules that way, at least)
13:36:49 <Cale> brbblnch: yeah
13:36:49 <sagittarian> I also had a more complicated implementation that definitely only calculates (nextSeed seed) once, but i was wondering if there was any point to doing that
13:37:17 <Cale> brbblnch: *All* we've done is stick in some terms.
13:37:20 <brbblnch> Cale: What I wanted was for the structure of the term itself to be the same as the one of the proof.
13:37:43 <Cale> The structure of the term does reflect the structure of the proof, ignoring structural rules.
13:37:55 <ryantrinkle> bennofs: where should i look at HsQML to see the FRP-related bits?
13:38:03 <bennofs> ryantrinkle: ah, it's not released yet
13:38:10 <bennofs> ryantrinkle: going to be a separate package
13:38:13 <Cale> We don't have explicit syntax in terms to say "please forget that x is in scope here"
13:38:18 <bennofs> ryantrinkle: https://github.com/bennofs/hsqml-react
13:38:18 <brbblnch> Cale: And as the structural rules only apply in =>-intro, that's where it gets bad?
13:39:03 <ryantrinkle> bennofs: ok, cool :)
13:39:06 <ryantrinkle> looks nice
13:39:15 <ryantrinkle> it would be great to have an FRP way to write native GUIs
13:39:18 <bennofs> ryantrinkle: here is an example I'm currently using as a test case: http://lpaste.net/130318
13:39:23 <exio4> sagittarian: you could use "runState", and reuse the old state, or do everything in the State monad (while making sure it is still lazy)
13:39:24 <solidus-river> > take 5 [(x,y,z) | x <- [0..100], y <- [0..100], z <- [0..100], x^2 + y^2 == z^2, x > 0, y > 0]
13:39:26 <lambdabot>  [(3,4,5),(4,3,5),(5,12,13),(6,8,10),(7,24,25)]
13:39:35 <brbblnch> Cale: But if you allow any number of hypothesis to be killed, you get a proof of "A => top" without the "assume x of type A" part
13:39:38 <solidus-river> interesting, whtas lambdabots cutoff limit for computations?
13:39:45 <solidus-river> *what's
13:39:48 <bennofs> ryantrinkle: the idea is that you provide the QML data via FRP but specify the layout using QML
13:39:49 <Cale> brbblnch: what?
13:40:14 <Cale> brbblnch: oh, using a different rule?
13:40:17 <brbblnch> In another source, they don't say you have to kill one hypothesis at each introduction
13:40:33 <ryantrinkle> bennofs: yeah, that sounds cool
13:40:41 <Cale> brbblnch: Yeah, you need to choose a form of the logic to start with which is explicit and picky about copies of A.
13:40:47 <vikstrous> Thanks indiagreen and dmj`! It worked! I used unsafeCoerce to then turn the [Word8] into the actual C struct I needed. I think it's safe because the whole struct is just char arrays anyway.
13:40:54 <brbblnch> Cale: They say: "When doing the introduction, take any number of hypothesis of A, kill them"
13:41:01 <sagittarian> exio4: right so the other implementation i had was like this:
13:41:05 <sagittarian> ranList seed = start : rest where { (start, next) = runState ran01 seed; rest = ranList next }
13:41:13 <sagittarian> is that what you're referring to?
13:41:20 <indiagreen> vikstrous: um, just in case
13:41:23 <Cale> brbblnch: What book are you reading, btw?
13:41:26 <brbblnch> Cale: The advantage (it seems to me) is that you get a quicker proof of A=>T (only 2Â lines)
13:41:37 <indiagreen> you turned an actual *list* of Word8s into a C struct?
13:41:50 <Cale> This sort of language feels old-timey to me, but it might just be from a different culture than I'm used to :)
13:41:55 <vikstrous> uhh into a Storable
13:41:59 <exio4> sagittarian: yes
13:42:06 <bennofs> ryantrinkle: for now, I just need to get diffing working (bc you only want to do minimal updates, so that QML animations behave properly) and then I can release a first version
13:42:08 <brbblnch> Proofs and Types by Girard+Lafont+Taylor (that's the one with free killing)
13:42:35 <sagittarian> exio4: so this second approach does avoid a second calculation of (nextSeed seed), unlike the first?
13:42:38 <sagittarian> okay thanks
13:42:40 <indiagreen> vikstrous: can you show the code?
13:42:42 <ryantrinkle> bennofs: ah, ok; you know, you might be able to get diffs for free with FRP ;)
13:42:44 <brbblnch> Cale: and "Lectures Notes on the Lambda Calculus" by Peter Selinger (it's a pdf) (the one where you kill exactly one hypothesis)
13:42:52 <vikstrous> indiagreen: https://github.com/vikstrous/binary_stream_patcher/blob/master/main.hs
13:43:15 <yac> is there a version of `proc` from turtle that returns () and `error x` when the command fails?
13:43:46 <yac> I don't see one
13:43:49 <brbblnch> Cale: So I quite prefer the one when you kill as many hypothesis as you want, even more so as then the tree of the proof for "A => T" is the same as the tree of the term itself. But then choosing the abstraction variable isn't as natural
13:44:53 <exio4> sagittarian: is there any reason you aren't doing this (directly) in the state monad? 
13:45:04 <Cale> brbblnch: Well, okay, you can just regard that one as a combination of a bunch of structural rules which forget all the other copies of A, together with an implication intro which uses the only remaining one, after you've done that.
13:45:21 <sagittarian> exio4: probably because i'm ignorant.  how would i do it directly in the state monad?
13:45:31 <indiagreen> vikstrous: unsafeCoerce just blindly circumvents the type system. In your case, it takes a pointer to some structure (which represents a linked list) in the Haskell heap, and casts it to C'Elf32_External_Ehdr
13:45:54 <indiagreen> have you actually checked whether it works? because I'd be surprised if it did
13:46:18 <Cale> brbblnch: Like, if we write something in a type theory along the lines of from: Gamma, x : A, Gamma' |- Delta, y : B, Delta', we can derive Gamma, Gamma' |- Delta, (\x -> y) : A -> B, Delta'
13:46:31 <Cale> brbblnch: Then Gamma and Gamma' are allowed to contain other terms of type A
13:46:47 <brbblnch> Cale. Yeah. But you also have to take care of the case where no hypothesis is killed. For example for the proof of "A=>T" which is "| T |- A=> T"
13:46:48 <vikstrous> indiagreen: yeah, it seems to work. You can clone it and run make test
13:46:49 <Cale> brbblnch: and when we apply the rule, we may choose which term of type A we're picking out
13:47:59 <indiagreen> vikstrous: oh, wait
13:48:25 <vikstrous> indiagreen is there a safer way to do what I'm doing? To read data into a custom Storable?
13:48:38 <indiagreen> vikstrous: what is it even supposed to do? in patchHeader you're ignoring payload
13:48:54 <brbblnch> brbblnch: Yeah. But you have a degree of freedom in your killing+choice of abstraction variable. Which you haven't in the other "system", right?
13:48:56 <vikstrous> indiagreen so far it just prints out the elf header
13:48:56 <indiagreen> so, patchElf amounts to doing 2 unsafeCoerces
13:49:00 <indiagreen> and packing and unpacking
13:49:16 <Cale> brbblnch: Well, that's a little more problematic, yeah, because then you nothing to which to attach the variable for your lambda to abstract over.
13:49:29 <indiagreen> it works only because it's just Â«B.pack $ unsafeCoerce $ unsafeCoerce $ B.unpack(getHeader elfIn)Â»
13:49:37 <indiagreen> so it all gets cancelled out
13:50:01 <vikstrous> indiagreen it calls getHeader in the middle
13:50:11 <Cale> brbblnch: But the Curry-Howard correspondence is really just a recognition that if you erase the terms from type theories, then you get logics. It's not a claim that you can take any old logic, and make a sensible type theory trivially from it.
13:50:13 <vikstrous> oh I see
13:50:16 <vikstrous> nvm
13:50:41 <haskell571> Hey guys, can you check this out for me?
13:50:42 <haskell571> http://lpaste.net/130319
13:50:44 <vikstrous> indiagreen okay, I don't know if this will work
13:50:54 <exio4> sagittarian: you'd have an State RandomState [Int] (or whatever the real type would be) that's be something like infiniteNumbers = (:) <$> randomNumber <*> infiniteNumbers or something similar, and make sure you don't use the "final" state, as you don't have one
13:50:57 <brbblnch> I would have said: To any implication introduction, with any number of hypothesis killed, choose some new variable and do the abstraction over it
13:51:01 <haskell571> Basically I am trying to pattern match on SqlError found in Database.HDBC but not sure why I get the parse error
13:51:14 <Cale> haskell571: Data constructors are not allowed to begin with a lowercase letter
13:51:31 <Cale> haskell571: Are you sure that the constructor isn't called something like SEState or SeState?
13:51:56 <bennofs> ryantrinkle: hmm, how would that work? Say for example I got a list of search results, which are automatically updated as you type. I might model this as a Event t [SearchResult] (where each SearchResult is represented as QML object and also can have some FRP state internally). Now, when the list of search results changes, I'd like to keep objects that are the same in the set of old and new search results. I
13:51:57 <bennofs> read that react handles this by allowing list items to have an assigned key, and I planned doing something similar. Does FRP have a way to solve this easier?
13:52:09 <haskell571> Using this doc for SqlError
13:52:09 <haskell571> https://hackage.haskell.org/package/HDBC-2.2.6.1/docs/Database-HDBC.html
13:52:42 <Cale> brbblnch: But that *only* addresses the case where you're proving something which is trivially true
13:53:19 <dmytrish> Hello. I have a small Cabal project I want to build on two machines with base=4.6 and base=4.7 . My problem is that System.Time has been deprecated in 4.7, so I have to specify `old-time` package in my Cabal file, but I'm afraid that this will break the build on base 4.6. As far as I see, there's no way to specify different build-depends for different bases. How to get builds on both machines with the same Cabal file?
13:53:21 <brbblnch> Cale: oh, bad
13:53:26 <Cale> brbblnch: Well, okay, to put it another way, it only lets you write constant functions
13:53:31 <haskell571> The constructors are seState :: String, seNativeError:: Int, and seErrorMsg :: String
13:53:46 <haskell571> Am I correctly pattern matching on it correctly?
13:54:22 <Cale> brbblnch: I suppose it does give you the same results as far as truth is concerned, but if you care about which proof you have, it does a bad job.
13:54:36 <pavonia> haskell571: These aren't constructors but record fields. They are like functions woring on an SqlError value
13:54:51 <haskell571> so i can do
13:54:52 <Cale> (always introducing a fresh variable)
13:54:55 <haskell571> seState SqlError
13:54:56 <haskell571> ?
13:55:11 <brbblnch> Cale: But there isn't any other sensible strategy for that ?
13:55:12 <pavonia> haskell571: No, you need an actual SqlError value
13:55:48 <Cale> brbblnch: Well, write something down and we can analyse it.
13:56:02 <pavonia> haskell571: "seState err" in your code would work
13:56:16 <haskell571> ah..
13:56:46 <haskell571> so there isn't a way to pattern match on them?
13:56:49 <ryantrinkle> bennofs: FRP doesn't help with the specific problem of matching up things in a list that are "the same" - that's an application-specific concept
13:57:19 <ryantrinkle> bennofs: but FRP helps with aggregating changes (represented by firing events) into a diff without needing to consider whether data is different or not
13:57:40 <pavonia> haskell571: If you want tto pattern match, you can use "SqlError { seState = s }" where s binds to the value of seState
13:57:44 <ryantrinkle> so, you don't actually need to run a "diff" - you just need to collect up the changes
13:57:50 <ryantrinkle> FRP makes it easy to do that in a composable way
13:57:53 <ryantrinkle> basically because of how 'merge' works
13:58:19 <brbblnch> Cale:Â I've got a good one: http://lpaste.net/8307557977099862016
13:58:50 <bennofs> ryantrinkle: yes, but for a list, the FRP unit of change is too much ... if an Event [a] fires, it always looks like the whole list changed, even if part of the elements might have stayed the same
13:59:02 <haskell571> So the SqlError has 3 attributes? 
13:59:19 <haskell571> seState, seNativerError, and seErrorMsg?
13:59:27 <solidus-river> bennofs: you would have to make that list of search results uniquely addressable maybe with a Set and have the identifier be a hash of the result and do inserts / updates
13:59:34 <Cale> brbblnch: Oh, sorry, I was ambiguous, I meant "propose a rule for a type system to correspond to the funny meta-rule which let you eliminate any number of occurrences of A from the context"
13:59:35 <ryantrinkle> bennofs: right, definitely; in reflex-dom, i use Map k v, for a user-supplied k and v
13:59:37 <Cale> But okay
13:59:39 <pavonia> haskell571: Yes
13:59:41 <solidus-river> bennofs: otherwise you'd have to make it a Comperable object and iterate over the whole list every time
13:59:45 <hexagoxel> dmytrish: see http://hackage.haskell.org/package/time-compat; my guess is that you are probably fine with using old-time
13:59:45 <ryantrinkle> bennofs: then i can just use 'align' to update things partially
13:59:51 <Cale> I kind of hate this bracket notation.
14:00:03 <bennofs> ryantrinkle: yes, and this is what I meant with diffing :)
14:00:14 <Cale> I would really rather we write two-sided sequents everywhere.
14:00:19 <brbblnch> Cale: Yeah, I use what I see :)
14:00:21 <hexagoxel> dmytrish: (those compat packages are one way of handling the problem you descibed)
14:00:37 <ryantrinkle> bennofs: right; i only meant that you get the "big picture" diff for free; individual datastructures may need diffing
14:00:50 <ryantrinkle> bennofs: this does boil down, usually, to animations and such working themselves out
14:01:10 <ryantrinkle> reflex-dom never removes things from the dom and re-adds them spuriously, for example
14:01:12 <brbblnch> Cale: No, killing any number of variables is stupid
14:01:16 <dmytrish> hexagoxel: thanks, I'll look at it
14:01:17 <Cale> brbblnch: You didn't say which structural rules you were applying when obtaining A from A, A in each case, so I don't know whether it's x or y there.
14:01:54 <SrPx> Is there any obvious way to simplify (\x y -> if goodEnough x y then x else max x y) ? 
14:02:12 <brbblnch> Cale: When doing an abstraction, you bind the variable. When doing a =>intro, you should bind the hypothesis (ie not assuming it anymore)
14:02:21 <SrPx> It is supposed to get the maximum element of a list lazily, with foldr, with an early exit condition (goodEnough)
14:02:26 <haskell571> Cool. Next question.  
14:02:42 <haskell571> Can I check whether or not catchSql returned to me an IO Connection or a IO String
14:02:49 <Cale> brbblnch: But also, why are there both [x:A] and [y:A] here?
14:02:57 <brbblnch> Cale: So, if I kill many hypothesis, but don't abstract the corresponding variables, The corresponce doesn't work anymore
14:03:10 <Cale> Oh, okay I see what's going on
14:03:19 <Cale> All right, yeah, this is just becoming nonsense
14:03:34 <brbblnch> Cale: Why are there both killed, or why are there 2 instances ?
14:04:10 <Cale> I didn't realise you were using the rule that let you "kill" both x and y in this way.
14:04:17 <brbblnch> Cale: oh
14:04:40 <brbblnch> Cale: It's true that in logic this works, right?
14:04:48 <Cale> But my immediate concern was that you didn't say whether it was x or y that got passed down to the A's on line 3 (or 2 depending how you count)
14:04:50 <pavonia> haskell571: I don't understand your question. The result type of catchSql is fixed at compilation time
14:05:05 <haskell571> well it gives me a IO a
14:05:10 <Cale> brbblnch: In a proof irrelevant logic, it works
14:05:14 <brbblnch> Cale: Yeah, it's x on the left and y on the right
14:05:26 <haskell571> but for my purposes, I want to return a IO Connection for my function if the connection to the db succeeds
14:06:06 <brbblnch> Cale: So: The two systems are logically equivalent, but the one with arbitrary killing (sorry, I have no other word) doesn't behave well with the correspondence. Thus I have to use the one with only one killing. 
14:06:23 <Cale> brbblnch: Or at least *picked* killing
14:06:34 <pavonia> haskell571: Yes, but 'a' is fixed. You can return (Either String Connection) if you want to indicate an error or success
14:06:38 <brbblnch> Cale: which means?
14:06:44 <Cale> You can kill off lots of things from the context whenever you like
14:06:58 <haskell571> what does a being fixed mean. 
14:07:04 <haskell571> doesnt a mean it can return anything?
14:07:19 <pavonia> haskell571: It's type can't change at runtime
14:07:31 <pavonia> But yes, it can return any time
14:07:36 <Cale> But you have to say which thing you're abstracting over when you apply the the intro rule. You could even have a separate intro rule for the case where there's no occurrence of something of the appropriate type
14:07:36 <pavonia> *type
14:08:36 <Cale> Like you could have: (Gamma |- y : B) |- (Gamma |- const y : A -> B)
14:09:08 <Cale> (or you could introduce a fresh variable and use a lambda there)
14:10:20 * hackagebot mysql-simple-typed 0.1.1.0 - Typed extension to mysql simple  http://hackage.haskell.org/package/mysql-simple-typed-0.1.1.0 (tolysz)
14:10:22 * hackagebot hdevtools 0.1.0.7 - Persistent GHC powered background server for FAST haskell development tools  http://hackage.haskell.org/package/hdevtools-0.1.0.7 (SchellScivally)
14:10:43 <haskell571> Okay, this is what I have now. But how do I make it so that it returns either the IO String or IO Connection? 
14:10:45 <haskell571> http://lpaste.net/130320
14:10:48 <brbblnch> Cale: So I would make the intro rule more precise so that when I kill many hypothesis, I have to specify which one is the abstracting one. and when I kill none, it has to be because there is none to kill ?
14:11:09 <Cale> brbblnch: It doesn't have to be because there is none to kill
14:11:20 <brbblnch> Cale:(So many details that we have to take care of)
14:12:08 <Cale> brbblnch: There might be things of type A in Gamma, this just represents the case where you don't use your hypothesis.
14:12:27 <brbblnch> Cale: Yeah, ok
14:13:38 <Cale> brbblnch: Think of it like you're writing a function. The context before the |- consists of all the things which are in scope for you to make use of. Since this isn't linear logic, you're free to ignore as many of them as you like, and they don't do any harm just sitting there.
14:14:27 <Cale> brbblnch: But if there are a bunch of variables of type A in there, it really matters which one you end up binding with the lambda
14:15:07 <Cale> (\x -> y) and (\x -> x) are very different functions
14:15:46 <brbblnch> Cale: So you think precising the natural deduction system should do the trick?
14:15:48 <haskell571> catchSql :: IO a -> (SqlError -> IO a) -> IO a
14:15:51 <Cale> Even if y is something of the same type as x which just happens to be in scope
14:15:58 <haskell571> Does the a have to be the same type throughout the function?
14:16:08 <barrucadu> haskell571: Yes
14:16:44 <pavonia> haskell571: Once you are in IO context, you can't escape it. So you return type could be "IO (Either String Connection)"
14:16:54 <brbblnch> Cale: But the correspondence is about types, which don't care for the variables as long as the types are good, no?
14:17:11 <Cale> brbblnch: I guess it's a legit question that comes up if you're starting from some logic which was not previously a type theory and saying "oh boy, how do we apply Curry-Howard to this?" -- well, it just might not work.
14:17:23 <vikstrous> Guys, I think my overall approach is completely wrong and I need some advice... The short version is that I want to write something the modifies streaming data using haskell I thought that lazy ByteString's are a great way to do that optimally. However, I need to use structs defined in c header files. I thought that using c2hsc and ultimately the Storable type in FFI would be the way to go, but it seems like
14:17:25 <vikstrous> I'm running into all kinds of weird issues. For example, poke and put on Storable do "IO" operations, so I feel like I can't actually take advantage of lazyness. Does what I'm trying to do make sense? Am I going down the wrong path? Is there a better way?
14:17:53 <brbblnch> Cale: Yeah, my problem is that I want to write some neat little notes on that, so i've got to write one of those system down
14:18:02 <Cale> brbblnch: Type theories care *very much* about terms.
14:18:14 <barrucadu> haskell571: You could do: catchSql (fmap Right $ connectSqlite3 dBFile) (\err -> return . Left $ "The state is " ++ ...)
14:18:37 <barrucadu> The constructors of Either are Left (typically indicating an error) and Right (typically indicating success)
14:18:49 <Cale> brbblnch: The correspondence is really only for proof-relevant logics where we care about *which* proof of A we're using in every place where we use a proof of A.
14:18:51 <barrucadu> And so your return type will be IO (Either String Connection)
14:19:23 <Cale> brbblnch: Or logics which are already in a form which is amenable to making that choice in a natural way, at the very least.
14:20:04 <brbblnch> Cale: mmh, ok. 
14:20:04 <haskell571> Can you explain that
14:20:07 <Cale> brbblnch: As another example, think about LEM
14:21:05 <Cale> brbblnch: We can introduce a rule for LEM into one of these type theories, but we pretty much have to invent a mysterious new sort of term for it.
14:22:16 <brbblnch> Cale: Yeah I saw something about call/cc and LEM somewhere
14:22:36 <Cale> brbblnch: |- P \/ ~P -- but which term do we put there? The context is empty. We obviously can't put inl or inr, because we have no evidence that either of those is actually right.
14:23:15 <djahandarie> edwardk, I just saw your discrimination package. How are the constant factors on this thing?
14:23:17 <meoblast001> does such a function exist? Monad m => (m a, m b) -> m (a, b)
14:23:30 <Cale> Yeah, that can be viable, you can have LEM come out as a theorem in terms of call/cc : ((A -> B) -> A) -> A
14:23:37 <Hijiri> meoblast001: yes
14:23:51 <brbblnch> Cale: interesting, I'll look into that if I find time
14:23:51 <Hijiri> uncurry $ liftM2 (,)
14:24:03 <brbblnch> Cale: But I've got to go to bed now!
14:24:04 <Hijiri> :t uncurry $ liftM2 (,)
14:24:05 <lambdabot> Monad m => (m a, m b) -> m (a, b)
14:24:08 <ion> meoblast001: That doesnâ€™t even need the Monad constraint, Applicative is enough.
14:24:18 <meoblast001> Hijiri: ion: oh. thanks :)
14:24:19 <brbblnch> Cale: Thanks a lot for the help, I really appreciate it
14:24:24 <Cale> brbblnch: No problem
14:24:35 <ion> :t uncurry (liftA2 (,))
14:24:36 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
14:24:37 <brbblnch> Cale: good night
14:24:42 <Cale> g'night!
14:24:45 <Hijiri> @djinn Applicative t => (t a, t b) -> t (a, b)
14:24:45 <lambdabot> Error: Class not found: Applicative
14:25:13 <Hijiri> @djinn Functor t => (t (a -> b) -> t a -> t b) -> (t a, t b) -> t (a, b)
14:25:14 <lambdabot> Error: Class not found: Functor
14:25:21 * hackagebot steeloverseer 1.1.0.4 - A file watcher.  http://hackage.haskell.org/package/steeloverseer-1.1.0.4 (SchellScivally)
14:25:23 * hackagebot mysql-simple-typed 0.1.1.1 - Typed extension to mysql simple  http://hackage.haskell.org/package/mysql-simple-typed-0.1.1.1 (tolysz)
14:25:39 <hexagoxel> :exf "Applicative t => (t a, t b) -> t (a, b)"
14:25:39 <exferenceBot> \ b -> let ((,) d e) = b in liftA2 (\ i -> \ j -> (j, i)) e d
14:25:39 <exferenceBot> \ b -> let ((,) d e) = b in liftA2 (,) d e
14:26:34 <lpaste> barrucadu annotated â€œNo titleâ€ with â€œNo title (annotation)â€ at http://lpaste.net/130320#a130321
14:26:42 <barrucadu> haskell571: Annotated your paste ^
14:29:49 <haskell571> thx a lot
14:29:52 <meoblast001> ion: so if i just liftA, it shouldn't totally blow up?
14:30:22 <bramgg> Sorry if I'm missing something obvious, but is there not a way to just run a raw String as a command with System.Process? I know it may be bad practice, etc.
14:31:13 <geekosaur> define "raw String"
14:31:41 <Cale> callCommand :: String -> IO ()  ?
14:31:47 <ion> meoblast001: The only thing that can go wrong is if you have a GHC older than 7.10, you may end up with something having a type signature like (Applicative f, Monad f) => something. Upgrading to 7.10.1 will fix that.
14:31:52 <Cale> spawnCommand :: String -> IO ProcessHandle
14:31:52 <geekosaur> because to me that means using `proc` so the shell doesn't interpret anything
14:32:11 <Zemyla> What is exferenceBot?
14:32:38 <bramgg> geekosaur: "blah --blah blah | blah > blah.txt"
14:32:45 <Cale> Zemyla: What *is* exferenceBot?
14:32:46 <geekosaur> so you want shell
14:32:49 <bramgg> Cale: I don't see those
14:32:52 <geekosaur> which is not "raw"
14:32:52 <bramgg> geekosaur: yes
14:32:57 <bramgg> mb :/
14:33:04 <meoblast001> ion: i do have an older GHC :(
14:33:05 <Cale> bramgg: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/process/System-Process.html
14:33:11 <Zemyla> That's what I want to know!
14:33:16 <Cale> bramgg: Which documentation for System.Process are you reading?
14:33:20 <worldsayshi> Hi, Iâ€™m currently working a non-released version of a lib (Haste). So the documentation is lacking. But all I really need is a way to search by name and/or type. A list of names and their type would go a long way I suppose. Can a local Hoogle work with this (since there isnâ€™t documentation).
14:33:23 <geekosaur> runCommand?
14:33:54 <geekosaur> Zemyla, I believe it's related to https://github.com/lspitzner/exference
14:33:57 <bramgg> Cale: IDK, mb. Thanks.
14:34:13 <bramgg> thanks both
14:34:32 <quchen> worldsayshi: A poor man's way of searching by name is looking at the index of Haddock documentation
14:34:41 <Cale> geekosaur: Oh, cool
14:35:31 <lpaste> drewbert pasted â€œNo titleâ€ at http://lpaste.net/1848272049789730816
14:35:58 <drewbert> Could someone help me with the error I'm encountering? http://lpaste.net/1848272049789730816
14:36:02 <worldsayshi> quchen: Yeah, but it seems the haddock docs didnâ€™t get created for this version. At least I couldnâ€™t clean the old ones out and the new ones failed to overwrite.
14:36:18 <drewbert> Not really understanding what I'm doing wrong.
14:36:25 <quchen> worldsayshi: Have you run "cabal haddock"?
14:37:02 <barrucadu> drewbert: You're saying in your return type you'll return an 'e', which means that the *caller* decides what that is
14:37:10 <barrucadu> It doesn't mean you can return whatever you want
14:37:18 <barrucadu> You could wrap your exceptions up in SomeException
14:37:25 <drewbert> I see.
14:38:07 <indiagreen> @tell vikstrous regarding your Storable thing: I think you can do â€œunsafePerformIO . unsafeUseAsCString (peek . castPtr)â€ on your ByteString to get what you want
14:38:07 <lambdabot> Consider it noted.
14:38:11 <worldsayshi> quchen: Thatâ€™s what I otherwise would do. Hmm, no. Didnâ€™t try that. Although I had â€˜documentation: Trueâ€™ so I expected them to be created anyway.
14:39:31 <drewbert> barrucadu: Got it working.  You explained exactly where my thinking was incorrect.   Thank you.
14:39:48 <worldsayshi> quchen: Yeah. Run that now. it still seems to be docs for the older version.
14:41:23 <worldsayshi> quchen: Oh, nope. It wasnâ€™t. It just looked like that.
14:41:31 <worldsayshi> Eh
14:42:01 <quchen> :-)
14:43:22 <worldsayshi> quchen: Heh. Yeah. Seems that haddock docs should suffice. Although it would be so much nicer if it added type signatures to the indexes as well. Or had a special index with such signatures.
14:44:11 <quchen> worldsayshi: I proposed adding types to the index in some form at a certain point, but didn't get much resonance
14:44:21 <worldsayshi> â€¦ And linked to source in case ther was no docs.
14:44:28 <worldsayshi> Heh. Bummer :/
14:45:10 <quchen> I think if I just went for it it would be merged, but I didn't get to it yet.
14:45:19 <worldsayshi> ah
14:45:32 <quchen> And it's not really on my screen :-|
14:46:53 <worldsayshi> I noticed the links to offline install of hoogle seem dead.
14:47:01 <hodapp> okay... I really don't understand. I have two freshly-created cabal sandboxes on two different hosts, both of which have just had 'cabal update' run (I think)
14:47:07 <hodapp> but one refuses to install HStringTemplate-0.7.3, and the other doesn't
14:47:24 <quchen> No markdown, typeclass instances shown by default, and no types in the index are, in descending order, my main issues with Haddock. Might be cool weekend projects though at some point.
14:47:54 <quchen> The Markdown thing has already been tried though, so I don't expect this to happen anytime soon. I don't know why it failed, probably politics.
14:48:31 <hodapp> can someone else run 'cabal update', then init a sandbox and see if "cabal install HStringTemplate-0.7.3" works?
14:48:42 <indiagreen> hodapp: okay, a sec
14:49:05 <jhance> whats wrong with typeclass instances being shown by default?
14:49:05 <worldsayshi> quchen: Hmm. Mixing markdown into haddock seems slightly weird.
14:49:10 <tonyday567> What failed was an attempt to replace haddock with markdown.
14:49:24 <jhance> And haddock documentation is part of the code, and I don't want any part of markdown in my code.
14:50:06 <quchen> jhance: You already have some form of markup language "in your code", namely Haddock's homebrewn one.
14:50:07 <hodapp> does a cabal sandbox inherit more than the package list?
14:50:25 <jhance> quchen: Yea, and it makes sense for Haskell. I don't want some generic markdown stuff in my comments, thats dumb
14:50:44 <jhance> to begin with, markdown is not a good markup language
14:50:52 <hexagoxel> hodapp: the ghc version?
14:51:12 <quchen> It's the current de-facto standard (idea) for writing unobtrusive text files you can render in a pretty way.
14:51:29 <quchen> (And that you can also read.)
14:51:30 <hexagoxel> hodapp: i.e. the global packages / "boot-libraries"
14:51:33 <hodapp> hexagoxel: maybe that's it. One box has 7.10.1, the other 7.8.4, despite both being Arch and (I think) being updated recently
14:51:38 <jhance> the de-facto standard for writing programs is certainly not haskell, does that mean we should all just not use it
14:51:57 <hexagoxel> hodapp: 7.10.1 is like.. two days old on arch
14:52:20 <hexagoxel> probably need to -Syu the 7.8.4 box :)
14:52:21 <hodapp> ahh, I just updated this box this morning
14:52:29 <hodapp> the 7.8.4 box is the one that is working
14:52:33 <hodapp> so I'm not touching anything on there at the moment
14:52:51 <quchen> Haskell is a good idea, Haddock syntax is not. It invents its own syntax for things that already exist elsewhere. Linking is awkward. Escaping quotes is awkward. Rendering literal quotes is awkward.
14:53:00 <quchen> @code@ is awkward.
14:53:07 <quchen> Linking to arbitrary places on the web is awkward.
14:53:14 <tonyday567> The main point with including markdown within haddock is that much documentation is already written in markdown - haykll-driven blobs is one example.  Right now, it has to be re-written in haddock.
14:53:31 <lambdabot> Error: <<timeout>>
14:53:32 <lambdabot> *** "Awkward" gcide "The Collaborative International Dictionary of English v.0.48"
14:53:32 <lambdabot> Awkward \Awk"ward\ ([add]k"we[~e]rd), a. [Awk + -ward.]
14:53:32 <lambdabot>    1. Wanting dexterity in the use of the hands, or of
14:53:32 <lambdabot>       instruments; not dexterous; without skill; clumsy; wanting
14:53:33 <lambdabot>       ease, grace, or effectiveness in movement; ungraceful; as,
14:53:35 <lambdabot> [44 @more lines]
14:53:37 <jhance> Why is it awkward? Because its not what markdown does?
14:53:41 <ion> Thanks lambdabot
14:53:56 <kadoban> Haha, good job lambdabot XD
14:54:43 <kadoban> jhance: Hmm? I think he was saying it's awkward in haddock's syntax, not markdown's. Maybe I misread though.
14:54:53 <hodapp> hexagoxel: what version of GHC are you on?
14:54:54 <jhance> kadoban: And I'm asking why its awkward in haddock's syntax
14:55:05 <bramgg> wait, lambdabot does dictionary definitions too?
14:55:16 <hexagoxel> hodapp: you could just manually install ghc-7.8.4 then, and --with-compiler it on the updated box.
14:55:40 <hexagoxel> hodapp: still 7.8.4, have not come around to upgrade my system yet
14:55:46 <quchen> jhance: Escaping quotes makes comments illegible in the source, not escaping quotes breaks links in the HTML rendering. Putting a word in quotes because that's what one sometimes wants to do when writing text renders as a module link, unless you escape the quotes, in which case you have \"this\" in your source.
14:56:01 <d-rock> Looking for a little help with types. I'm using Aeson and I have an Object that I'd like to convert to a data type with fromJSON. It looks like Object should be an Aeson.Value, but I get a compilation error that it expects a Value but got an Object
14:56:14 <jhance> quchen: What does that have to do with linking
14:56:31 <quchen> I mentioned several things, one of which was what I just explained in detail.
14:56:33 <hexagoxel> hodapp: but i have 7.4, 7.6, 7.8, 7.10 installed manually
14:56:47 <jhance> And in any case, \"this\" doesn't look particularly bad to me.
14:56:59 <quchen> Good for you.
14:57:37 <jhance> Haddock isn't a general-purpose markup and therefore it shouldn't be inheriting for things designed for general-purpose markup
14:57:49 <quchen> <https://www.haskell.org/haddock/doc/html/ch03s08.html#idm140354810727840 title>  is probably not particularly bad to have in a comment in your source as well, interspersed with what the comment means to actually say.
14:58:29 <jhance> because you'd rather do that ridiculous separation of link text with link url?
14:58:56 <jhance> I'm not sure what the alternative is here
14:59:03 <quchen> Yes, I'd rather not inline everything. It's a form of abstraction to not do this.
14:59:11 <jhance> ... no, thats not what abstraction is
14:59:58 <quchen> That is quite close to lambda abstraction, actually. I take an expression containing something, replace that something with a hole, and specify it elsewhere.
15:01:01 <indiagreen> jhance: this ridiculous separation has been widely used for hundreds of years as â€œfootnotesâ€ and â€œcitationsâ€, and it doesn't seem that ridiculous to me
15:01:25 <jhance> indiagreen: Thats for presentation though, not for writing.
15:01:42 <jhance> indiagreen: The whole reason we don't have to do it is because we have hyperlinks now
15:01:51 <quchen> Oh, and slashes make quote render in italics.
15:01:54 <quchen> I forgot that one.
15:02:07 <quchen> s/quote/text/
15:02:25 <kadoban> Personally I'd have a much better time using haddock if I could use markdown syntax instead, heh. It seems like it'd fit great. As it is, I have to look up yet another markup every time I use it, which isn't ideal.
15:02:28 <indiagreen> jhance: if I never had to read original markup for documentation (in code), I wouldn't care, yep
15:02:51 <indiagreen> but since I do sometimes have to edit documentation, I also have to read it when it's not rendered
15:03:00 <jhance> indiagreen: The problem is that for the most part all of the documentation is so small anyway that moving something from inline to not-inline is often not worth it
15:03:13 <jhance> the only desired scenario would be the header for a particular module, really
15:03:28 <fionnan> anyone know what is the simplest way to get the intersection of two lists?
15:03:47 <jhance> fionnan: intersect.
15:04:43 <indiagreen> jhance: agreed, but still being able not to inline things is an improvement for me. Also, it's nice when you want to include a tutorial in your package (like Pipes.Tutorial)
15:05:06 <kadoban> fionnan: Keep in mind that if it's used often or with big lists, you're probably using the wrong data structure.
15:06:23 <fionnan> jhance: thanks, I'm a total noob but in ghci `intersect [1,2] [2,3]` give me a `not in scope` error
15:06:34 <fionnan> s/give/gives/
15:06:38 <jhance> fionnan: :m +Data.List
15:07:04 <fionnan> jhance: thanks! :)
15:07:23 <jhance> fionnan: if you need intersection though you might want to consider using a Data.Set.Set instead
15:09:23 <fionnan> jhance: cool, thanks
15:11:57 <fionnan> jhance: could you give me an example/hint how I could load/use Data.Set.Set pls?
15:12:12 <indiagreen> jhance: I think the real problem with Haddock is that it's not better than Markdown and thus nobody bothers to learn it enough to avoid all of its subtle trapdoors. I see links to unexistent modules all the time, for instance, because somebody put some word in quotes and Haddock autolinked it. Or links looking like â€œhttp:foo.combarbazâ€, because someone forgot that slashes are for italics. Or just broken links, because
15:12:12 <indiagreen> somebody used word wrapping and Haddock doesn't understand the <link text> syntax if there's a newline in it. And so on, and so forth.
15:13:18 <athan> >< so I've got a complcated monad stack, where the result turns into something like `foo :: MonadIO m => t m a -> i -> (i -> m b) -> m b`, but I've got to push `foo` into something that accepts  `i -> (i -> IO b) -> IO b`, however, `m` turns out to be some kind of ReaderT, so I've dug myself into a lambda ditch. Any suggestions? :\
15:13:20 <jhance> > Data.Set.intersect (Data.Set.fromList [1, 2]) (Data.Set.fromList [2, 3])
15:13:22 <lambdabot>      Not in scope: â€˜Data.Set.intersectâ€™
15:13:23 <lambdabot>      Perhaps you meant one of these:
15:13:23 <lambdabot>        â€˜Data.List.intersectâ€™ (imported from Data.List),
15:13:30 <indiagreen> Oh, and I forgot about broken lambdas in code blocks (because â€œ\â€ gets eaten).
15:13:34 <Mion> markdown is horrible since it is ambigious like heck and everyone has their own flavour of it
15:13:51 <EvanR> athan: unstack your transformers
15:13:51 <Mion> commonmark fixes all of that, but no one uses commonmark yet
15:14:04 <quchen> Fuuzetsu mentions a couple of good reasons against Haddock Markdown in his post here, http://fuuzetsu.co.uk/blog/posts/2013-08-30-why-Markdown-in-Haddock-can%27t-happen.html
15:14:26 * Mion prefers reST
15:14:30 <athan> EvanR: =(
15:14:34 <joelteon`> hi, what might this "ld: illegal text reloc in '_c2OoA_info' to '__hpc_tickboxes_webapp2zm0zi0zi0_Settings_hpc' for architecture x86_64" mean
15:14:35 <athan> mer
15:15:13 <EvanR> i would bother to learn all of haddock if i didnt run into several cases where a thing i wanted it to do just isnt possible
15:15:22 <EvanR> so now i feel like its not worth it
15:15:45 <EvanR> i.e. its "good enough"
15:16:13 <Lokathor> A person was remarking the other day that Java has a culture of trying to protect stupid programmers from bad mistakes whenever possible, wouldn't it generally be the case that haskell does that to a greater degree?
15:16:22 <jhance> Lokathor: No
15:16:27 <jhance> Case in point: operators
15:16:44 <fionnan> jhance: thanks
15:16:57 <Lokathor> hmm, i suppose that can make things hard to look at
15:17:18 <quchen> Lokathor: Sounds right to me. Although you might want to replace "stupid" with "fallible" there.
15:17:28 <koala_man> Lokathor: do you have an example?
15:17:31 <MP2E> http://www.reddit.com/r/haskell/comments/31a7hf/obfuscated_haskell_attempt/
15:17:35 <quchen> And take Java out, because that's not what Java does.
15:17:45 <quchen> :-|
15:17:48 <EvanR> Lokathor: that sounds a lot like its coming from the idea that the more brainpower you have the more unrestrictive programming languages benefit you more, like "too close for C switching to asm". and the idea that this is good
15:17:50 <jhance> quchen: it definitely *tries*
15:18:23 <jhance> it just doesn't succeed at it :D
15:18:34 <quchen> I haven't seen it try yet.
15:18:34 <tonyday567> All I'm looking for is an ability to put markdown in a multi-line comment, and then for the haddock/hackage chain to render it.  {- :markdown: (here)[github.com] -} 
15:18:37 <EvanR> instead of the idea that the programming language should be optimized for easy understanding by human beings
15:18:55 <jhance> quchen: it doesn't allow operator overloading, explicitly forcing the GC to run, etc
15:19:02 <jhance> because "bad programmers" could misuse that or something
15:19:09 <Lokathor> koala_man, i do not have a particular example i suppose
15:19:25 <drewbert> Hrmm massive mysterious memory leak.
15:23:37 <EvanR> protection might be a red herring, instead there should be guidance. a totall safe language which is a turing tarpit would protect you and be totally impractical
15:23:56 <EvanR> so haskell has guidance, which subsumes safeety
15:23:58 <quchen> EvanR: Most languages claim to be very readable, so that one doesn't really say much anymore.
15:24:12 <quchen> (That video about COBOL is now playing in your head.)
15:24:25 <indiagreen> quchen: what video?
15:25:40 <EvanR> quchen: well readable is one thing, easy understanding of something only begins with reading
15:26:10 <EvanR> the long range implications of pure functions and haskells types goes beyond reading
15:26:29 <EvanR> sometimes you dont even need to read
15:26:51 <quchen> Right, even the most insane functions have simple types in many cases.
15:26:57 <quchen> (Data.Set is a good example.)
15:27:05 <jhance> having simple types can still fall under reading though
15:27:31 <jhance> All types in Java for example are simple simply because there isn't complicated machinery in its type system
15:27:59 <shachaf> Java types aren't that simple.
15:28:29 <c_wraith> Java types used to be simple
15:29:14 <jhance> the most complicated thing you see is some XXXFactorBuilderFactory
15:29:29 <koala_man> method resolution has always been a bit iffy, but it certainly wasn't made easier with autoboxing and generics
15:29:37 <EvanR> and java types dont mean anything a lot of the time
15:29:58 <EvanR> when you see the type signature, then ignore it and read the code, the type i useless
15:30:09 <jhance> hence reading not understanding
15:30:16 <quchen> jhance: That's more "purposeful hungarian notation" rather than typing.
15:30:24 * hackagebot jose 0.3.41.1 - Javascript Object Signing and Encryption and JSON Web Token library  http://hackage.haskell.org/package/jose-0.3.41.1 (frasertweedale)
15:30:26 * hackagebot hakyll 4.6.8.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.6.8.0 (JasperVanDerJeugt)
15:30:28 * hackagebot aeson-casing 0.1.0.1 - Tools to change the formatting of field names in Aeson  instances.  http://hackage.haskell.org/package/aeson-casing-0.1.0.1 (andrewrademacher)
15:41:22 <trengo_> I am 40 years old and assuming I am not to old, is haskell a good choice for a first programming language? I only know css and html. No phd's and no programming experience. Thank you.
15:42:35 <hpc> your first programming language is rough no matter what
15:42:38 <Stratege_> I don't think there's really such a thing as too old to learn something. I've heard people who liked haskell as a first language, so I'd just say give it a shot and look at a tutorial or two.
15:43:40 <monochrom> I saw a blog post by a non-programmer who learned Haskell and wrote what she found. the only two hurdles were computer usage (e.g., what is an "editor"?) and computer science jargon. I think since you already did css and html, you have at least got the editor part done.
15:43:45 <kadoban> trengo_: It could be a good first language, it's better than many in that regard for sure. https://github.com/bitemyapp/learnhaskell has some suggestions of where to start
15:43:59 <Stratege> I'd still recommend, at some later point, looking into some low level imperative language, like C, to learn more about how the machine works.
15:44:38 <quchen> trengo_: The post monochrom is talking about: https://superginbaby.wordpress.com/2014/11/18/learning-haskell-as-a-nonprogrammer/
15:44:42 <Lokathor> you're only too old to learn if you refuse to learn
15:44:48 <EvanR> word i found odd when learning programming "argument"
15:44:51 <kadoban> Stratege: IMO just learning C doesn't teach you a whole lot about how the machine works. Using it as a side-thing when you're otherwise learning computer architecture might.
15:44:52 <sagittarian> trengo_: i've heard a number of anecdotal stories that suggest that haskell is easier for non-programmers to grasp than for people with programming experience
15:45:08 <monochrom> her advantage, though, was that she was a linguist, so she was already eating recursion for breakfast.
15:45:10 <jhance> sagittarian: only because the vocal people with programming experience share their nightmare-stories of haskell, really
15:45:27 <EvanR> C is good to know because not to learn how machines work
15:45:33 <EvanR> s/because/but/
15:45:56 <jhance> I don't understand the problem people have in recursion; recursion is an important part of mathematics, how do you get by through even like high school withou tit
15:46:23 <yac> sagittarian: if it is true, it's probably just because there is so little material explaining things properly
15:46:27 <EvanR> recursion is an important part of programming in most languages :S
15:46:32 <yac> just look at the first chapter at wikibooks
15:46:33 <sagittarian> so it's a selection effect?  people who have programming experience and try haskell and have difficulties are likely to gripe, but people without programming experience who try haskell and have difficulties are likely to just give up or try a different language, i guess
15:46:34 <Stratege> jhance mutually recursive functions where part of the final output is the original input of the function is still something I struggle with ^^
15:46:34 <EvanR> the ones that support it at least
15:46:39 <kadoban> jhance: The math most people learn in high school is awful. It's just algebra, and sometimes very basic stuff beyond that, nothing more. None of the cool stuff.
15:46:40 <yac> straight into some complicated app
15:46:56 <Lokathor> Knowing a C-like language lets you read the code that others present to you, because they'll usually present it in C-style pseudocode (if not real code)
15:47:15 <yac> while I find I first need to explain IO type and algebraic data types to do anything
15:47:18 <jhance> Knowing how a computer works isn't particularly important in CS at least, but it can be useful to know for programming
15:47:23 <Lokathor> jhance, you can easily pass through american high school without once being told what recursion is
15:47:33 <kadoban> Lokathor: Pseudocode is â€¦ rarely much like C. If that's the goal, you could save yourself a few weeks and learn python instead of C.
15:47:47 <barrucadu> Don't US high schools teach, say, induction?
15:47:53 <Lokathor> hahahahaha
15:47:56 <kadoban> barrucadu: Ehhh, no?
15:48:00 <Lokathor> that's a good one barrucadu 
15:48:00 <quchen> In physics maybe.
15:48:01 <EvanR> dont python
15:48:01 <jhance> barrucadu: Ironically my high school only taught induction to remedial students. I don't even
15:48:03 <zinfandel> O_o
15:48:12 <barrucadu> huh
15:48:12 <trengo_> Thank you all for the suggestions.
15:48:13 <jhance> Physics is almost exclusively continuous, not discrete...
15:48:26 <Lokathor> actually, you learn induction in AP Calc, but most students don't take AP classes
15:48:33 <jhance> Lokathor: Nope.
15:48:36 <barrucadu> I did basic proof by induction for my maths GCSE (16 years old)
15:48:52 <EvanR> so haskell
15:48:54 <jhance> You do not need induction for the AP Calc exam, all you need is a Ti-nspire to do 90% of the problems for you, then know how to do a few basic integrals
15:48:58 <Lokathor> jhance, nope?
15:49:05 <kadoban> I don't remember induction in AP Calc â€¦ but maybe it was there and I just already knew it (learned enough coding and math on my own by then to be familiar with it I'm sure)
15:49:18 <caconym> >  let { h 0 _ _ _ = []; h d f t e = h (d - 1) f e t ++ [(f, t)] ++ h (d - 1) e t f } in h 3 1 2 3
15:49:20 <lambdabot>  [(1,2),(1,3),(2,3),(1,2),(3,1),(3,2),(1,2)]
15:49:37 <monochrom> jhance: why recursion is hiding there somewhere every time you write a huge algebraic expression (the grammar is recursive), it is hard to notice or draw inspiration from if no one points it out to you. and don't forget that most students write huge expressions imperfectly to begin with.
15:49:47 <monochrom> s/why recursion/while recursion/
15:50:26 <sagittarian> oh how would you explain algebraic data types simply and concisely?
15:50:28 <aupiff> hey all, I'm looking for a haskell library like Data.Set but with a faster "check if member/member/elem" function. Data.Set's "member" runs in n log n.
15:50:41 <sagittarian> i was trying to explain them to a programmer friend the other day and found myself completely at a loss for some reason
15:50:47 <sagittarian> it doesn't seem like it sohuld be that hard
15:50:48 <caconym> i don't want to say the math i learned in high school was completely useless, but in retrospect i can think of better ways my time could have been spent
15:50:49 <glguy> aupiff: Set's member function is log n
15:50:54 <glguy> not n log n
15:50:54 <jhance> sagittarian: discriminated union
15:51:05 <Lokathor> just looked at a calc book i had nearby
15:51:09 <jmcarthur> sagittarian: for a C programmer, i would say it's a tagged union
15:51:10 <Lokathor> index didn't have induction, actually
15:51:11 <sagittarian> jhance: even i don't know what that's supposed to mean
15:51:18 <Lokathor> (Stewart, 5e)
15:51:19 <aupiff> glguy: yeah, i was wrong
15:51:25 <jhance> sagittarian: A union that is discriminated
15:51:31 <sagittarian> this guy is a javascript programmer (as are many of the programmers i know)
15:51:35 <Ralith> sagittarian: a progerammer certainly should
15:51:47 <aupiff> glguy: is there something hash-map based that's faster?
15:51:49 <Lokathor> sagittarian, it might be best if you explain in terms of java generics, to get the initial concept across
15:51:53 <mpickering> http://mpickering.github.io/extensions.html - Number of source files each GHC extension is used in (from every file on hackage)
15:51:57 <mpickering> if that interests anyway
15:51:57 <jhance> union { enum { ... } type; struct { ... } x1; struct { ... } x2; } disc_union;
15:51:59 <monochrom> OTOH, divide-and-conquer is natural to everyone. to search a huge but disorganized library for a book, you get the help of two friends. with 3 persons, each person searches 1/3 of the library. recursion can be taught more nicely if you invoke divide-and-conquer.
15:52:03 <kadoban> caconym: I just remember "learning" 90% the same thing every year. It was pretty much a waste of time.
15:52:04 <sagittarian> us younguns never had to learn compiled pointer-arithmetic stuff
15:52:47 <sagittarian> i don't really know know java, but aren't java generics like parametric types?
15:52:52 <jmcarthur> sagittarian: i guess 
15:52:53 <caconym> kadoban: my greatest regret is spending so much time learning nearly useless algorithms (long division) when they could have been teaching useful ones (sort) while also teaching basic programming
15:52:55 <jmcarthur> oops
15:52:59 <sagittarian> which is only part of what adt is, no?
15:53:01 <EvanR> sagittarian: yes
15:53:10 <jmcarthur> i meant to type control k to clear the line, but instead i did something else...
15:53:15 <EvanR> parametric polymorphism as an orthogonal concept
15:53:19 <jhance> a parametric type is just an endofunctor in a sense
15:53:20 <Lokathor> sagittarian, well, yes
15:53:35 <jhance> well, more primitive than that i guess
15:53:39 <sagittarian> anyway, to someone coming from dynamic languages like python/ruby/javascript none of this is a very good explanation
15:53:41 <EvanR> sagittarian: look. const :: a -> b -> a, this is parametric but not an ADT
15:53:50 <kadoban> caconym: Hah, yeah that was kind of a huge waste of time, wasn't it? I've done long division a total of zero times in actual life that I remember.
15:54:02 <meteo> is there a generic name for the function that gets passed to a fold?
15:54:06 <monochrom> sagittarian: at the beginning, you don't have to present a polymorphic ADT. you can just do "data IntTree = End | Branch Int IntTree IntTree"
15:54:06 <Stratege> sagittarian perhaps try saying that it's restricted/statically checked ducktyping?
15:54:08 <quchen> sagittarian: "Enum with heterogeneous entries"
15:54:15 <caconym> kadoban: the closest i've come to needing long division is in coding interviews and in project Euler problems haha
15:54:18 <Lokathor> sagittarian, if they're a javascript progammer they hardly believe in types to begin with :P
15:54:20 <jhance> well, python/ruby/javasccript don't have real types so they basically have no relevant experience at all
15:54:39 <EvanR> sagittarian: indeed its sometimes hard to convince ruby/js/whatever people to use ADT-like structure. which would be like {"left": 5} or {"right": "blue"}
15:54:40 <jhance> statically typed ducktyping?
15:55:12 <EvanR> or [:left 5] [:right "blue"]
15:55:15 <EvanR> or...
15:55:32 <jhance> Just tell them an ADT is like a hoon %kelp
15:55:33 <kadoban> caconym: Haha, yeah. Which means, I guess some of the concepts involved were kinda useful and stuck around. But the actual practice of doing it â€¦
15:55:37 <monochrom> sagittarian: perhaps look at how various FP books explain ADT
15:55:39 <Lokathor> this sounds suspiciously close to a Blub Paradox situation
15:55:57 <sagittarian> well yeah, if you don't have pattern matching i can't see much of a point to ADTs (correct me if I'm missing something)
15:56:03 <Lokathor> i hate that Abstract Data Type and Algebraic Data Type are both "ADT"
15:56:04 <jmcarthur> sagittarian: maybe the sum of products explanation is the way to go. a product is a record of other types of values. a sum is a choice of other types of values. a sum of products is a choice of records of other types of values. an adt is a sum of products.
15:56:05 <quchen> Dynamic languages like Python, JS and so on do have types, and leave it entirely to the programmer to check them. A language without types is Brainfuck, for example.
15:56:06 <jhance> sagittarian: yes, yes you are
15:56:28 <jhance> the discriminated safety is incredibly important
15:56:30 <sagittarian> jhance: what?
15:56:32 <jhance> regardless of how you do it
15:56:52 <jmcarthur> sagittarian: by "choice" i mean that the value can be one of multiple possible types, and you can tell which type it is
15:56:57 <sagittarian> by discriminated safety, you mean type checking by the compiler?
15:57:01 <EvanR> swift explains them by renaming them to enums
15:57:01 <EvanR> enums with parameters
15:57:04 <caconym> kadoban: yeah, and I think for less mathematically inclined people who never go on to use algebra or trig or calc or whatever, they just forget it and never need to remember it again
15:57:17 <Stratege> EvanR oO that sounds harmful.
15:57:19 <Lokathor> outside of Haskell, you can do an Algebraic Data Type in Java with an Enum
15:57:21 <kadoban> Indeed.
15:57:23 <indiagreen> meteo: maybe â€œcombineâ€? or â€œcombining functionâ€, if you weren't asking about a name you can use in code
15:57:32 <jhance> kadoban: long division can be extremely useful over many PIDs
15:57:37 <Lokathor> C allows for a Union, which usually has some sort of "mode" flag to tell you what you should treat it as
15:57:49 <EvanR> sagittarian: well you have to emulate the pattern matching
15:57:51 <monochrom> sagittarian: we probably mean my http://www.vex.net/~trebla/haskell/crossroad.xhtml :)
15:57:53 <EvanR> or in the case of clojure a macro
15:57:55 <jmcarthur> sagittarian: e.g.   this value can be (an Int AND a String) OR (a Double) OR (a list of Bools)
15:57:59 <quchen> Lokathor: That's one way to emulate a sum type. Another way is inheritance, Animal > [Cat, Dog, Elephant].
15:58:15 <jmcarthur> sagittarian:    data Foo = A Int String | B Double | C [Bool]
15:58:29 <jhance> its not as useful for computation but its an extremely important algorithm that yields, for example, a proof that F[x] is a PID for any field F
15:59:08 <EvanR> Stratege: its might be stupid to arbitrarily rename an established pre existing language feature, but people do it. and its not entirely a bad analogy
15:59:53 <Stratege> My understanding of Enums from my C# times was that they are very limited, only sometimes useful and for, well ... enumerations.
16:00:01 <sagittarian> okay, so i think the analogy to a c union sounds like a promising route to go next time this comes up
16:00:01 <quchen> sagittarian: A place where sum types often appear and are a huge pain in the ass is when parsing to an AST, which contains of several alternatives at each junction
16:00:11 <sagittarian> even for someone not familiar with c i can probably explain what a union is
16:00:14 <EvanR> yeah enums are limited. and swift added parameters, so now they arent limited ;)
16:00:14 <Stratege> and I'd be wondering what the point of parametrizing them is.
16:00:16 <quchen> +lack of, somewhere in my last sentence
16:00:29 <jhance> huge pain? they are a huge relief
16:00:39 <sagittarian> quchen: thanks! i'll memorize it and repeat it verbatim
16:00:48 <jmcarthur> sagittarian: it's important to note that it's a *tagged* union
16:00:51 <quchen> jhance: Hence the "lack of" I added, I was thinking in terms of parsing in e.g. Java.
16:00:54 <EvanR> Stratege: well in haskell enums are implemented with ADTs
16:01:12 <meteo> indiagreen, yes i mean a non-specific comp-sciency name for the 'folding function' . 
16:01:15 <Stratege> EvanR well yeah but I wouldn't know what the point of parametrizing is. (and yes I know the goodness of ADTs. And also that in haskell you can just slap a deriving Enum on it)
16:01:21 <SrPx> Hey guys, this function will timeout: `foldr (\ x sum -> if sum > 10 then x else x + sum) 0 [1..]` . What is the correct way to express it so it won't? I.e., I want to get the first number of an infinite list such that the sum of its predecessors > 10.
16:01:25 <jhance> the enum is the tag, the union is the rest
16:01:30 <EvanR> not really related to Enum
16:01:31 <jhance> (here the tag is the constructor-id)
16:01:39 <sagittarian> jmcarthur: a tagged union is one where you have a data member that indicates what type is stored in the union? (i'm not very good at c if it wasn't obvious)
16:01:39 <caconym> SrPx: you can't foldr an infinite list
16:01:47 <EvanR> caconym: yeah you can
16:01:51 <jhance> hence why a ADT with only constructors and no data is an Enum
16:01:53 <jmcarthur> sagittarian: correct
16:01:56 <quchen> Pattern match failure on tagged unions can have interesting results :-s
16:02:12 <EvanR> caconym: you cant foldl an infinite list
16:02:23 <SrPx> caconym: I'm almost sure you can... if you use `foldr (\x xs -> if cond x then x else xs)` you will find the first `x` satisfying `cond` in finite time
16:02:37 <quchen> > foldr const 7 [1..] -- caconym 
16:02:38 <lambdabot>  1
16:02:50 <jmcarthur> SrPx: caconym is wrong. you can.
16:02:56 <SrPx> okay
16:03:33 <caconym> whoa, sorry
16:03:45 <monochrom> "if sum > 10" is the one requiring processing the whole list
16:03:47 <EvanR> another use case is a running total, like a scan
16:04:11 <monochrom> instead, combine scanl and filter
16:04:24 <monochrom> err, combine scanl and takeWhile
16:05:00 <jmcarthur> > fmap snd . find ((>=10) . fst) $ zip (scanl (+) 0 [1..]) [1..]
16:05:01 <lambdabot>  Just 5
16:05:05 <jhance> map each element to the sum of its predessors, filter by >= 10, and use take
16:05:09 <jhance> err, use head
16:05:22 <monochrom> not to mention that in "foldr (\x sum -> ...)", that "sum" is the sum of a suffix, not of a prefix. whereas your problem statement wants prefix sums.
16:05:25 <EvanR> all of the above may result in bottom
16:06:01 <quchen> sagittarian: A tagged union is a union with an additional "tag" field. A C union is a data type that reserves enough memory to take any of its member's values. A union of (int, char, char*) could contain an int, or a char, or a char*. This sounds like a sum type, but it has a problem: you cannot tell from a union what kind of data it currently holds, so you can't say "if you're an int right now then ...". That's where the tag come
16:06:02 <quchen> s into play: it assures the programmer that the union holds a value of a certain type. The problem is obvious, when the tag is wrong your program does what C programs do when you do these kind of things, which is nobody knows.
16:06:38 <SrPx> I don't understand - you *can* use scanl on infinite lists?
16:06:50 <jmcarthur> @src scanl
16:06:50 <lambdabot> scanl f q ls = q : case ls of
16:06:50 <lambdabot>     []   -> []
16:06:50 <lambdabot>     x:xs -> scanl f (f q x) xs
16:07:01 <jmcarthur> ^^ scanl is still lazy. it's not the same as foldl
16:07:02 <SrPx> @src foldl
16:07:02 <lambdabot> foldl f z []     = z
16:07:02 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:07:04 <EvanR> the l and r seems to be reversed on scanl/r vs foldl and foldr
16:08:43 <quchen> last . scanl f z == foldl f z, if that helps.
16:09:09 <quchen> scanl is foldl that gives you access to the intermediate accumulator values in the form of a list.
16:09:18 <EvanR> ... in reverse
16:09:31 <quchen> Hm?
16:09:51 <EvanR> i mean, foldl operates from right to left so the scan list appears reversed
16:10:17 <pdxleif> @type scanl
16:10:18 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
16:10:21 <SrPx> hmmm...
16:10:22 <quchen> I don't know what you mean with "right to left", but that doesn't sound like foldl.
16:10:28 <EvanR> uhg. and that doesnt explain why scanl would allow lazy. because foldl will never even start on an infinite list
16:11:19 <quchen> > take 10 (scanl (+) 0 [1..]) -- left to right, first intermediate result first.
16:11:21 <lambdabot>  [0,1,3,6,10,15,21,28,36,45]
16:11:21 <SrPx> Not sure I get it, so scanl is actually "accumulating foldr" misnamed?
16:11:27 <EvanR> foldl algorithm starts by making a bunch of thunks out of the list before reducing from the end
16:12:05 <Stratege> so if one wants to consume a list from the beginning to end, should foldr be used instead of foldl?
16:12:14 <EvanR> yes
16:12:18 <frerich> My new favorite in the Prelude: http://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Enum.html#line-157
16:12:32 <shachaf> Stratege: From beginning to end is the only way to consume a list.
16:12:59 <Stratege> shachaf I ment without first producing a bunch of thunks
16:13:12 <EvanR> foldr still might produce a bunch of thunks depending on what you do
16:13:55 <Stratege> okay, I have no idea how to decide between foldl or foldr then, or if it even matters.
16:14:07 <EvanR> for infinite lists the choice is obvious
16:14:18 <shachaf> It matters.
16:14:28 <shachaf> @google foldr foldl foldl'
16:14:28 <lambdabot> https://wiki.haskell.org/Foldr_Foldl_Foldl'
16:14:36 <Stratege> thanks
16:14:42 <shachaf> You should almost never use foldl, only foldr and foldl'.
16:15:09 <EvanR> almost never in the probability sense ;)
16:16:38 <frerich> Stratege: Sometimes choosing the right fold can also make the code considerably easier. For instance, try defining a function 'readInt :: String -> Int' which turns a string like "1234" into the integer 1234 using foldr and foldl.
16:16:57 <glguy> > let findLast p = foldl (\rest x -> if p x then Just x else rest) Nothing in findLast even [undefined,2,3,4,5]
16:16:59 <lambdabot>  Just 4
16:17:27 <shachaf> glguy: Yes, almost. :-)
16:18:19 <frerich> Stratege: Sorry, I guess I was being a bit ambiguous: when I wrote 'the right fold' I meant 'the appropriate fold'. Not a 'right fold'. :-]
16:18:30 <EvanR> eh, findLast is like find . reverse
16:22:38 <Stratege> well. I'm still a tad confused, but thanks for the pointers :)
16:23:06 <oconnore> GHC is telling me "getModificationTime: does not exist (No such file or directory)" for a .o file that is a dependency I'm trying to build
16:23:13 <EvanR> take the @src definitions of foldl and foldr and go through them to evaluate the sum of a list of numbers
16:23:21 <oconnore> what is going on? Of course it doesn't exist, that's why I specified --make
16:23:23 <EvanR> step by step
16:23:37 <EvanR> it will also give you practice understanding lazy evaluation
16:25:26 * hackagebot llvm-general-pure 3.3.14.2 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.3.14.2 (BenjaminScarlet)
16:25:28 * hackagebot llvm-general-pure 3.4.5.2 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.4.5.2 (BenjaminScarlet)
16:25:30 * hackagebot llvm-general 3.3.14.2 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.14.2 (BenjaminScarlet)
16:25:32 * hackagebot llvm-general 3.4.5.2 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.4.5.2 (BenjaminScarlet)
16:25:39 <Stratege> EvanR k, will do.
16:30:30 <oconnore> oh, --make and -o don't like each other
16:30:34 <Stratege> EvanR ... why does Foldable define the strict versions of foldl and foldr via the use of the nonstrict version of the other (that is foldl' defined via foldr and foldr' via foldl)?
16:31:08 <shachaf> How else would you want to define them?
16:31:24 <EvanR> those are the default implementations
16:31:48 <EvanR> if you dont implement something in that chain it will just loop forever
16:32:10 <Stratege> ah
16:32:39 <EvanR> like Eq defines == and /= in terms of each other
16:33:18 <hunteriam> hey, what are my cahcens of finding a google summer of code group or getting to participate in google summer of code at this point?
16:33:35 <hunteriam> i know the deadline for proposals passed- is it at all possible in any way that i participate at this point?
16:33:52 <hunteriam> maybe join an existing group or solo project?
16:34:06 <jhance> is groups even a thing in Gsoc? I thought it was just mentor+mentee
16:34:18 <hunteriam> isnt the mentor an organization?
16:34:31 <hunteriam> popssibly groups are not a thing
16:34:41 <jhance> i think the mentor is part of an org
16:34:48 <jhance> but like, theres a designated mentor to the gsoc student
16:34:49 <hunteriam> does anyone know though? im looking for something to do this summer 
16:35:01 <jhance> if proposals deadline is past, i think you are out of luck
16:35:01 <hunteriam> that doesnt sound too good for me
16:35:25 <hunteriam> i think so too, but im trying to hear from people who are really involved to see if its possible somehow
16:35:44 <hunteriam> just in case
16:36:25 <jhance> I would say even if it is technically possible the chances aren't worth your time though
16:37:01 <SrPx> Is there an alias for `zip xs (scanl f i xs)` ? i.e., an scanl that preserves the initial values?
16:37:34 <SrPx> > zip [1..10] (scanl (+) 0 [1..10])
16:37:36 <lambdabot>  [(1,0),(2,1),(3,3),(4,6),(5,10),(6,15),(7,21),(8,28),(9,36),(10,45)]
16:38:09 <hunteriam> jhance: whys that?
16:38:15 <hunteriam> jhance: its basically this or nothing afaik
16:38:21 <hunteriam> id say thats worth my time 
16:38:27 <jhance> hunteriam: Why this or nothing?
16:38:35 <hunteriam> idk what else i would do
16:38:40 <hunteriam> i kinda need something formal to do
16:38:42 <monochrom> . o O (because it's a Maybe type)
16:38:50 <jhance> internship?
16:39:02 <srid> how do I get the empty value of a type variable?
16:39:05 <hunteriam> i think its pretty late to find an internship too, but that does seem like the other thing
16:39:10 <hunteriam> this is way more attractive than that to me
16:39:10 <srid> i.e. take 10 (Data.List.repeat [])
16:39:15 <srid> i want to replace [] with empty value of [a]
16:39:17 <hunteriam> but i mean ill take what i can get
16:39:42 <hunteriam> srid: do you have a function f :: [] -> a
16:39:49 <hunteriam> cause then you can just map
16:40:28 <srid> hunteriam: ctx -> https://gist.github.com/srid/9830609acba3dd752b71
16:40:43 <srid> â€˜aâ€™ is a rigid type variable bound by
16:40:56 <srid> ^^ i believe that occurs due to use of [] in the repeat function, instead of [a]
16:41:19 <hunteriam> can i reccomend not using single letters
16:41:27 <hunteriam> i think thats a fair thing
16:41:30 <srid> sure. but this is code golf
16:41:36 <hunteriam> i c
16:42:23 <hunteriam> so lets clear some things up, just for figuring this outs sake
16:42:28 <hunteriam> s :: [[a]]
16:42:31 <hunteriam> :t foldl
16:42:32 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
16:42:39 <hunteriam> oh wow foldable is a thing now'?
16:43:28 <kadoban> hunteriam: Yep. lambdabot runs GHC 7.10 now
16:43:36 * srid just added clarification of `skip` in that link
16:43:50 <rcyr> Question somewhat unrelated to haskell... If I want to have the latest ghc without too much trouble, what distro can I install in a VM?
16:44:03 <apo> lfs
16:44:06 <KaneTW> any?
16:44:14 <shachaf> rcyr: Any of them, and then download GHC from the website and install it yourself.
16:44:16 <monochrom> must it be the latest? not even second latest?
16:44:28 <monochrom> but what shachaf says
16:44:30 <shachaf> Usually it takes a while for it to get into repositories and so on. Installing your own GHC is easy.
16:44:39 <rcyr> monochrom: 7.10 has some big changes... that's why I wanted 7.10
16:44:57 <rcyr> Nevemind.. sorry.
16:45:05 <Stratege_> srid is there a reason your zip there isn't just (zip [1..] xs)?
16:45:20 <monochrom> did you know: a benefit of that big change is that most of hackage has not caught up?
16:45:28 <srid> Stratege_: ah. that's better
16:45:39 <shachaf> More of Hackage has caught up than I expected.
16:45:42 <hunteriam> srid
16:45:54 <hunteriam> srid you cant zip a is in f a
16:46:00 <hunteriam> srid a :: [a]
16:46:07 <hunteriam> well i guess you could
16:46:16 <hunteriam> but a is always empty list
16:46:18 <hunteriam> i think
16:46:37 <hunteriam> oh wait nvm
16:47:18 <shachaf> Stratege: To clarify: foldl' and foldr' have correct default implementations.
16:47:30 <shachaf> All you need to define is foldMap, and you get default implementations of everything else.
16:47:36 <shachaf> No loop.
16:48:09 <Stratege> okay
16:48:12 <srid> hunteriam: the error is complaining about (zip is xs)
16:48:21 <srid> but it is of correct type, afaict
16:48:38 <srid> > Data.List.zip [1..] "Hello"
16:48:39 <lambdabot>  [(1,'H'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
16:49:11 <hunteriam> srid: thats probably not what its complaining about
16:49:18 <hunteriam> errors not wrong, but it is hard to read
16:50:58 <monochrom> "take 1 (repeat [])" is the same as []
16:51:07 <monochrom> err, [[]]
16:51:12 <srid> ah got it
16:51:27 <srid> foldl -> foldr
16:51:36 <hunteriam> :t foldl
16:51:37 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
16:51:38 <hunteriam> :t foldr
16:51:39 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
16:52:30 <hunteriam> i dont think that will work srid although it compiles
16:52:34 <hunteriam> srid tell me if i tdoes
16:53:42 <srid> i have to grocery shopping now. feel free to leave a comment in that gist, i'll get back to this later. haskell is fun.
17:13:46 <mjrosenb> what is the recommended way to have a multi-dimensional array, create an array of arrays, or have the index type be a tuple?
17:14:30 <pacak> hmatrix?
17:15:17 <mjrosenb> this isn't going to contain anything resembling numbers.
17:15:51 <EvanR> Array works (with tuple inex)
17:16:42 <mjrosenb> ok, that is what I was thinking of doing.
17:16:46 <mjrosenb> just wanted to be sure.
17:54:52 <schell> is there a channel specifically for cabal?
17:55:24 <shachaf> There is #hackage.
17:55:32 <schell> hmmm
17:56:38 <sm> and there's #cabal
17:56:48 <schell> ahh - thatâ€™s it, thanks
17:57:24 <sm> I think it needs more publicity
17:57:42 <monochrom> the problem with the name "cabal" :)
18:03:34 <dpwright> edwardk: Sorry if this isn't an appropriate place to ask this, but it seems a bit trivial to open a github issue: is there a reason Linear.Matrix doesn't provide either an "m44_to_m33" or a "rotation" function (both different names for the same goal -- to get a rotation matrix out of a full transform)?
18:04:09 <dpwright> since there is "translation" provided as a lens I thought "rotation" would make sense alongside it.  I could make it / open a pull request, but I wanted to check if there's something I'm missing first
18:07:37 <dpwright> "rotation = _xyz . column _xyz" seems like a reasonable definition, assuming a lens in the vein of "translation"
18:08:15 <edwardk> i don't have a particular objection to providing it
18:10:59 <dpwright> ok, thanks -- I guess I'll submit the pull request and then if there are any issues we can discuss them there. Probably should have done that in the first place!
18:19:50 <idem-pyon-tent> I've installed GHC 7.10 from source. The program itself installed just fine, but the documentation for the packages GHC comes with contains broken links.
18:25:15 <fresheyeball_> hey folks
18:25:29 <fresheyeball_> and hi master Hardy
18:25:45 <fresheyeball_> oh it said has quit
18:25:47 <fresheyeball_> anyway
18:25:56 <fresheyeball_> I have a really easy question
18:26:20 <jle`> ask away :D
18:26:35 <fresheyeball_> ok, so I have a string that is a response from a bash command
18:26:51 <fresheyeball_> so data is separated with /n and /t
18:27:01 <fresheyeball_> it looks like a little table in the shell
18:27:07 <fresheyeball_> but its just a string in haskell
18:27:22 <fresheyeball_> is there a good way to parse this?
18:27:32 <fresheyeball_> or is using regex the way to go here?
18:27:42 <jle`> you can use lines to split on lines, and words to split on words
18:27:56 <jle`> regexes are rarely ever going to be a good solution in haskell
18:28:00 <fresheyeball_> ok thats helpful
18:35:40 <fresheyeball_> or so actually another question
18:35:44 <fresheyeball_> so long as I'm on here
18:36:12 <fresheyeball_> x :: IO Int
18:36:24 <fresheyeball_> y :: Int -> [Int]
18:36:44 <fresheyeball_> z :: Int -> String
18:36:53 <fresheyeball_> how can I compose x and y
18:37:14 <fresheyeball_> so that IO Int -> [String]
18:37:42 <fresheyeball_> (y <$> x) :: IO [Int]
18:38:01 <fresheyeball_> what can I do next to introduce z on each ember of the array?
18:38:17 <fresheyeball_> (z <$> (y <$> x)) ?
18:38:32 <fresheyeball_> that doesn't work
18:38:40 <fresheyeball_> I need to use <$> on a lower level monad
18:38:48 <fresheyeball_> first thought was
18:38:59 <fresheyeball_> (liftM z <$> (y <$> x))
18:39:03 <fresheyeball_> but no
18:39:48 <kadoban> fresheyeball_: Do it in pieces. Make a function Int -> String that does the whole thing for you. Then fmap (<$>) that onto the IO Int
18:40:17 <kadoban> Or Int -> [String]
18:40:31 <fresheyeball_> aww
18:40:48 <fresheyeball_> I was hoping there was some kind of uber slick operator that was like double fmap
18:40:55 <fresheyeball_> fmap below the fmap
18:41:06 <gcganley> :t join
18:41:07 <lambdabot> Monad m => m (m a) -> m a
18:41:08 <fresheyeball_> get the monad under the monad
18:41:08 <kadoban> You can certainly do it as a one-liner, but â€¦ what's the point? Won't it just be an unreadable mess to you?
18:41:19 <fresheyeball_> I don't know
18:41:30 <fresheyeball_> if its an unreadable mess than I don't want that
18:41:44 <fresheyeball_> but if its x <$$> y <$> z
18:41:50 <fresheyeball_> then I'm happy
18:42:49 <kadoban> (map z . y) <$> x -- <-- that I guess
18:42:54 <gcganley> hey doest anyone know how i can run a function in a haskell frame in emacs from a key combo? im trying to make it so when ever i press f6 it runs my main function and when i run f7 it stops the execution of the main function
18:44:13 <pavonia> @hoogle (a -> b -> m c) -> m a -> m b -> m c
18:44:14 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
18:44:14 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
18:44:14 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
18:46:27 <tonyday567> fresheyeball_: looks like fmap z <$> y <$> x
18:46:48 <fresheyeball_> oh that is cool
18:46:51 <tonyday567> :t \ x y z -> fmap z <$> (x <$> y) :: IO Int -> (Int -> [Int]) -> (Int -> String) -> IO [String]
18:46:52 <lambdabot> (a1 -> (Int -> [Int]) -> a) -> (IO Int -> a1) -> (a -> (Int -> String) -> IO [String]) -> IO Int -> (Int -> [Int]) -> (Int -> String) -> IO [String]
18:47:07 <tonyday567> yeah, there should be a <$$> for that
18:52:11 <kadoban> Is it me or does that type â€¦ pretty messed up?
18:52:20 <MP2E> lol
18:52:29 <tonyday567> :t (\ x y z -> fmap z <$> (x <$> y))
18:52:31 <lambdabot> (Functor f, Functor f1) => (a1 -> f1 a) -> f a1 -> (a -> b) -> f (f1 b)
18:52:36 <tonyday567> better
18:56:13 <kadoban> :t (\x y z -> fmap z <$> (y <$> x)) :: IO Int -> (Int -> [Int]) -> (Int -> String) -> IO [String]
18:56:14 <lambdabot> IO Int -> (Int -> [Int]) -> (Int -> String) -> IO [String]
18:56:25 <kadoban> I'm pretty sure ^ that is more like it, tonyday567
18:57:06 <kadoban> Oh I guess that means the same thing, sorry. Just more specific.
18:57:07 <tonyday567> kadoban: thanks :-)
18:57:27 <kadoban> I got confuzzed by the extra functor, haha â€¦ didn't realize that was the list.
19:03:46 <fresheyeball_> double fmap <$$>
19:03:54 <fresheyeball_> its going in my toolkit :)
19:15:35 * hackagebot hdevtools 0.1.0.8 - Persistent GHC powered background server for FAST haskell development tools  http://hackage.haskell.org/package/hdevtools-0.1.0.8 (SchellScivally)
19:16:32 <haasn> fresheyeball_: fmap (y >=> z) x -- how's this?
19:17:10 <benzrf> x >>= f >=> g = x >>= f >>= g, right
19:17:24 <haasn> Oh, that's not what you want. You want just (map y . z) I think
19:18:58 <newsham> whats preferred style in do-notation when doing lots of nested "if something return () else { ... }" ?
19:19:05 <newsham> (or case)
19:19:40 <newsham> is there any good example in some code up on github or hackage?
19:20:02 <shachaf> newsham: unless?
19:20:05 <pacak> newsham: guard/unless/when?
19:20:15 <hunteriam> does anyone know if its possible to get into google SoC still/
19:20:22 <hunteriam> maybe join an existing project or something like that?
19:20:30 <newsham> ok, reword -- whats preferred style when using lots of nested "when/unless" in do blocks?
19:21:07 <pacak> If they are nested - you probably need a different monad. Or a monad transformer.
19:21:09 <newsham> do people tend to use parens and (do <indent>block) ?
19:22:06 <arkeet> people tend to use $
19:22:11 <platz> > let wither f (x:xs) = maybe id (:) <$> f x <*> wither f xs; wither _ _ = pure []
19:22:12 <arkeet> when b $ do ...
19:22:13 <lambdabot>  <no location info>:
19:22:13 <lambdabot>      not an expression: â€˜let wither f (x:xs) = maybe id (:) <$> f x <*> withe...
19:22:45 <arkeet> newsham: ^
19:23:40 <newsham> perhaps I should give an example.
19:23:43 <arkeet> sure.
19:23:50 <platz> i don't get the maybe id (:) part
19:23:55 <arkeet> :t maybe id (:)
19:23:56 <lambdabot> Maybe a -> [a] -> [a]
19:23:57 <idem-pyon-tent> benzrf: I don't think the first one is even syntactically legal.
19:23:57 <newsham> arkeet: if I do "$ do" wont I need to indent furthe rthan the do?
19:24:10 <arkeet> no
19:24:18 <arkeet> you need to indent further than the enclosing block
19:24:23 <lpaste> newsham pasted â€œa question of monadic-do styleâ€ at http://lpaste.net/130324
19:24:40 <arkeet> it's the first line inside the do block that determines the indentation level you need
19:24:45 <benzrf> idem-pyon-tent: er
19:24:50 <benzrf> x >>= (f >=> g) = x >>= f >>= g, right
19:24:53 <benzrf> =)
19:24:56 <arkeet> so you can take exactly your paste, repliace ( with $, and get rid of )
19:25:04 <idem-pyon-tent> benzrf: Yep, that's right.
19:25:06 <arkeet> replace.
19:25:15 <arkeet> (I've been making a lot of weird typos lately.)
19:25:36 <newsham> are there any style options where i dont have to keep indenting further and further?
19:25:37 <arkeet> oh, inside a case you don't need $ or any punctuation at all.
19:25:44 <arkeet> you can use braces :-)
19:25:49 <newsham> yah, looks like that example just needed one $
19:25:57 <Zemyla> Question. If State# s is 0 bytes, how does the compiler tell one State# from another?
19:26:03 <platz> clearly (:) is useful for concatenating 'f x' to 'go xs'
19:26:05 <arkeet> but maybe you should reconsider what you're doing.
19:26:08 <newsham> yah, but braces then require semicolons :(
19:26:10 <newsham> boo hiss
19:26:16 <platz> but how 'id' typechecks..
19:26:22 <arkeet> platz: maybe id (:) Nothing = id
19:26:27 <arkeet> maybe id (:) (Just x) = (:) x
19:26:28 <arkeet> = (x :)
19:26:34 <newsham> ok, i'll use $ do..  thank you arkeet.
19:26:50 <arkeet> newsham: you should try MaybeT.
19:27:10 <bracket> super noob q.. is there any library (perhaps using template haskell/generics) which, I can declare a record and create some kind of map (or nested map) where i can access fields by name?
19:27:14 <newsham> arkeet: adding FooT only makes sense when that exact pattern keeps coming up
19:27:21 <newsham> thats not the case here :)
19:27:35 <platz> so, so when 'maybe id (:) Nothing = id'
19:27:38 <lpaste> arkeet annotated â€œa question of monadic-do styleâ€ with â€œa question of monadic-do style (annotation)â€ at http://lpaste.net/130324#a130325
19:27:43 <Zemyla> bracket: Is the answer Lens?
19:28:00 <bracket> i've been looking at lenses but havn't found that exact functionality
19:28:07 <platz> that will result in an 'f Nothing' <*> go xs
19:28:36 <arkeet> newsham: well, just saying that it would help in your case.
19:28:51 <hunteriam> sorry - does anyone know if its still possible to get into haskell.org's google summer of code program?
19:28:52 <arkeet> you could think about ContT if you need more complicated control flow.
19:28:53 <newsham> yah, but in my real examples, i'm doing case analysis, not if's
19:28:57 <platz> so then i guess it's up to the applicative instance
19:29:03 <newsham> and not always on the same types
19:29:08 <hunteriam> i know the deadline passed, im just wondering if its maybe possible to join an existing project or something like that
19:29:19 <bracket> Zemyla: do you have a specific module/func I can search?
19:29:27 <jhance> there are not groups in gsoc, we went over this
19:29:41 <Zemyla> Hmm. Join #haskell-lens?
19:29:47 <jhance> you don't "join" a project, thats not a thing
19:29:54 <hunteriam> i understand jhance
19:29:58 <hunteriam> im hoping to hear from someone else now
19:30:01 <arkeet> hunteriam: the student application deadline is passed.
19:30:16 <hunteriam> arkeet: is there any possibility of getting in still somehow?
19:30:19 <Zemyla> What does a mentor do?
19:30:54 <arkeet> hunteriam: I don't think so, based on my understanding of the word "deadline"
19:30:57 <jhance> deadline ===> if you didn't already apply you aren't getting in
19:31:00 <carter> yes
19:31:35 <hunteriam> yes i too understand the word deadline, but i dont understand the system behind this program well enough to know how set in stone the projects are etc.
19:31:56 <hunteriam> or if there might be someone i could talk to 
19:31:56 <arkeet> you can always contribute to a project.
19:31:59 <arkeet> but google won't pay you for it.
19:32:30 <jhance> if google wanted to hire 1 more person, they would have hired that person from the list of applicants
19:32:39 <hunteriam> i understand jhance
19:32:50 <arkeet> I don't understand what the problem is, then.
19:33:00 <hunteriam> theres not a problem
19:33:09 <laudiacay_mobile> Someone is salty
19:33:11 <laudiacay_mobile> Omh
19:33:15 <hunteriam> omh?
19:33:20 <Axman6> bracket: sounds like you're looking for something akin to objects in other languages like javascript or python (often referred to as hashes). you might want to think about what the types of things for such a thing might look like and begin to realise the difficulty in having a consistent type system in the presence of such an idea
19:33:32 * laudiacay_mobile eats popcorn
19:33:47 <hunteriam> are you talking about me?
19:33:56 <laudiacay_mobile> Nah
19:34:02 <laudiacay_mobile> The angry one
19:34:05 <hunteriam> i dont think anyone is salty
19:34:12 <jhance> pjsalt
19:34:16 <hunteriam> its maybe a little more heated than it should be
19:34:18 <hunteriam> but w.e.
19:34:23 <bracket> Axman6: right. for example, when I 'derive Generic' in aeson, it has some template haskell which it uses
19:34:38 <Axman6> jhance: is just being unnecessarilly rude hunteriam
19:34:52 <hunteriam> its not a big deal
19:34:54 <Axman6> s/://
19:34:58 <jhance> what, by telling him he won't get into gsoc past the deadline? he already asked once an hour ago
19:35:17 <hunteriam> its nbd
19:35:28 <laudiacay_mobile> I think jhance is salty and didn't get in
19:35:34 <jhance> I didn't apply?
19:35:38 <laudiacay_mobile> Lol
19:35:42 <laudiacay_mobile> Joked
19:35:48 <Axman6> just saying "no" is much less helpful than "no, but you could look at X"
19:35:53 <hunteriam> ^
19:35:56 <hunteriam> thats what i was looking for
19:35:58 <hunteriam> not speculation
19:36:03 <hunteriam> you werent very helpful, frankly
19:36:05 <jhance> Axman6: He said he needed something for the summer earlier and I suggested he look at internships instead.
19:36:26 <Axman6> well in that case, maybe you should listen to jhance's advice hunteriam ;)
19:36:43 <hunteriam> im looking at internships too
19:36:51 <hunteriam> i just wanted to give a good shot at getting in
19:37:01 <hunteriam> jhance doesnt seem to know very much about this, so i asked again
19:37:05 <hunteriam> he was just giving his opinion
19:37:37 <laudiacay_mobile> hunteriam: startups are generally thirsty for interns
19:37:39 <Axman6> Tsuru capital have a good internship, I was accepted for that a few years ago
19:37:48 <laudiacay_mobile> Might be something to try
19:37:57 <hunteriam> yea ive been trying to find haskell startups
19:38:09 <hunteriam> seems like most are financial, which im ok with but id rather do something else
19:38:14 <Axman6> there's plenty around, particularly if you're willing to travel
19:38:33 <laudiacay_mobile> Haskell startups are a thing?!
19:38:34 <hunteriam> how do you find them? i searched on linked in and one other website, but are there more?
19:38:40 <hunteriam> a better resource, maybe?
19:38:51 <Axman6> http://functionaljobs.com
19:39:06 <laudiacay_mobile> Omg Axman6 you da best
19:39:17 <hunteriam> neat
19:39:22 <hunteriam> oh god ive got a competitor
19:39:27 <hunteriam> just pretend you didnt see anything laudiacay_mobile 
19:39:30 <SrPx> How do I invert a map from Data.Map?
19:39:40 <benzrf> SrPx: explain
19:39:53 <Axman6> Map k v -> Map v k?
19:39:56 <SrPx> I have a map from ints to strings, I want the inverse map from strings to int. Yes
19:40:12 <benzrf> SrPx: i mean you could fromList . map swap . toList
19:40:15 <benzrf> cant imagine its efficient :-o
19:40:18 <jhance> Too bad somehow Node.js counts as functional according to one of the listings, haha
19:40:31 <Axman6> fromList . map (\(x,y) -> (y,x)) . toList
19:40:31 <SrPx> Good idea benzrf 
19:40:36 <benzrf> gaaaaaah are there any even MARGINALLY decent haskell libraries for typechecking and evaluating haskell GAAAAAAH
19:40:42 <hunteriam> Axman6: you think i should contact some of these companies about an internship? this seems to mostly be listing full time jobs
19:40:48 <laudiacay_mobile> hunteriam: oh lol i have a friend that send out my resume to research people don't worry unless i get rejected from literally everything
19:40:52 <benzrf> at this point i'd settle for fuckin EVAL
19:40:54 <benzrf> GOD
19:40:55 <jhance> benzrf: I hear ghc does this quite well
19:40:59 <benzrf> :\
19:41:06 <jhance> Pipe to runhaskell!
19:41:07 <SrPx> tgo
19:41:11 <hunteriam> laudiacay_mobile: what year of school are you in? 
19:41:12 <benzrf> SrPx: tgo?
19:41:15 <Axman6> hunteriam: why not? doing something is much more likely to succeed than doing nothing
19:41:17 <SrPx> my bad
19:41:29 <hunteriam> laudiacay_mobile: ive been wanting to find research opportunities myself but i have no idea where to start
19:41:33 <laudiacay_mobile> hunteriam: 11th grade :)
19:41:37 <hunteriam> laudiacay_mobile: no way!
19:41:43 <laudiacay_mobile> GOVERNMENT AGENCIESSS
19:41:46 <hunteriam> laudiacay_mobile: and youre doing haskell research?  or something else?
19:41:51 <pavonia> SrPx: Maybe have a look at Data.Bimap
19:42:07 <laudiacay_mobile> Yeah I'm hoping physics and math, haskell is more of a side bae
19:42:16 <hunteriam> you have so many baes
19:42:33 <hunteriam> pretty neat you can do math research in 11th grade
19:42:33 <SrPx> cool, thank you pavonia 
19:42:35 <bob_twinkles> benzrf: I assume you've seen https://wiki.haskell.org/GHC/As_a_library ?
19:42:44 <laudiacay_mobile> hunteriam: hbu?
19:42:57 <hunteriam> laudiacay_mobile: never done any formal ressearch myself, im a college freshman
19:43:06 <laudiacay_mobile> Ooh where
19:43:16 <hunteriam> laudiacay_mobile: probably wouldve helped to have gotten started on that stuff in 11th grade though..
19:43:23 <hunteriam> laudiacay_mobile: no where fancy
19:43:29 <hunteriam> laudiacay_mobile: a liberal arts school in the midwest
19:43:41 <laudiacay_mobile> I haven't either but hopefully I will this summer
19:43:42 <benzrf> bob_twinkles: looking at it now
19:43:46 <benzrf> it seems obtuse as fuck u_u
19:43:46 <hunteriam> laudiacay_mobile: bet you will
19:43:49 <bob_twinkles> of course, that API looks like it involves hooking in to some really deep guts of GHC which could be quite pleasent
19:43:50 <laudiacay_mobile> Ooh Midwest is it pretty there?
19:44:05 <hunteriam> laudiacay_mobile: surprisingly it is, supposed to get pretty cold in the winter but it was pretty mild this year
19:44:09 <bob_twinkles> *unpleasent lol
19:44:09 <hunteriam> very flat where i am
19:44:14 <enthropy> @hackage hint -- benzrf
19:44:14 <lambdabot> http://hackage.haskell.org/package/hint -- benzrf
19:44:14 <hunteriam> i thinkn were off topic though
19:44:21 <em> do any of you like the show breaking bad?
19:44:23 <johnw> hunteriam: :)
19:44:23 <arkeet> yeah, -blah would be better for that.
19:44:32 <hunteriam> johnw: hey john
19:44:39 <laudiacay_mobile> hunteriam: it was brutal here in dc :|
19:44:41 <benzrf> em: hmmmmmmmmmmmMM!
19:44:42 <johnw> hey
19:44:44 <benzrf> * enthropy
19:44:53 <johnw> and I'm agreeing with hunteriam, this should go off channel
19:45:05 <hunteriam> got it, wasnt sure 
19:45:23 <johnw> I was thanking you for saying it a few seconds before I was planning to
19:45:26 <laudiacay_mobile> bob_twinkles: hi frend
19:45:33 <enthropy> benzrf: it's simpler / less powerful than using the ghc api directly
19:45:40 <hunteriam> yea wasnt sure if it was that or something else entirely
19:45:55 <benzrf> enthropy: not looking for a great deal of power :u
19:46:03 <benzrf> enthropy: will it let me evaluate ASTs?
19:47:15 * enthropy thinks it only has String -> IO result
19:47:18 <benzrf> rip
19:47:30 <jhance> Hint is pretty unflexible
19:47:37 <jhance> Yi has been having troubles with it but I don't know much about the details
19:47:58 <benzrf> times like this are when lisp seems appealing
19:48:01 <benzrf> >_>
19:48:10 <jhance> benzrf: And then you remember no types
19:48:27 <benzrf> yep
19:48:43 <enthropy> benzrf: well you somehow got to AST from somewhere?
19:49:20 <enthropy> it seems like you could pretty print the ast and have ghc parse it
19:49:28 <benzrf> hmm true
19:49:53 <newsham> if I declare a top-level "something = unsafePerformIO getSomething" will that be thunked until I actually use the "something" for the first time?
19:49:58 <bob_twinkles> what's the higher-level goal here? i.e. why do you want to exec an AST
19:50:12 <bob_twinkles> could be there's a better solution =P
19:50:24 <newsham> for example, if I need to run code inside of "withSockets $ do" or "withOpenSSL $ do", is it still safe to use unsafePerformIO ?
19:50:30 <newsham> at the top-level
19:50:35 <jhance> newsham: I'd say yes? I wouldn't see it being executed immediately, so being thunked is the only option - and not only that, only when the result of "something" is needed to get something else into WHNF
19:51:15 <Lokathor> I have implemented a functional method in Java
19:51:16 <Lokathor> yay
19:51:28 <jhance> i'm not sure how that connects though... Are you saying that the unsafePerformIO will need sockets or need ssl?
19:52:24 <jhance> I would say avoid the unsafe io in the first place though...
19:53:08 <newsham> live a little, jhance! :)
19:54:10 <MP2E> Take chances, make mistakes, get messy! [/magicschoolbus]
19:54:14 <newsham> :)
19:54:34 <doweaver> Anyone in here use Arch Linux and have an opinion on managing packages? It looks like there are about fifteen different approaches I could use. I'm just trying to get darcs on my machine at this point, but I'm wondering what you guys would recommend
19:55:16 <sellers> doweaver: I asked that in #archlinux the other day, and the consensus was cabal + sandboxes
19:55:30 <sellers> doweaver: with a few people using nix
19:55:46 <doweaver> sellers: Cool - sounds reasonable. Thanks!
19:56:56 <sellers> doweaver: there's also https://wiki.archlinux.org/index.php/Haskell#Managing_Haskell_packages 
19:57:02 <sellers> but YMMV I guess
19:58:06 <doweaver> sellers: Yeah, I started messing around with ArchHaskell, but it doesn't actually seem like many people do things that way
19:59:20 <Javran> what's the difference between "hpc combine" and "hpc sum"? is it just like the differences between mappend and mconcat?
20:00:38 * hackagebot hledger-lib 0.25 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.25 (SimonMichael)
20:00:40 * hackagebot hledger 0.25 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.25 (SimonMichael)
20:00:42 * hackagebot hledger-web 0.25 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.25 (SimonMichael)
20:10:38 * hackagebot stm-io-hooks 1.0.1 - STM with IO hooks  http://hackage.haskell.org/package/stm-io-hooks-1.0.1 (PeterRobinson)
20:25:24 <gwstell> so ghc just gave me this: Couldn't match type â€˜t1 -> t0 -> t1â€™ with â€˜forall a b. a -> b -> aâ€™
20:27:04 <kadoban> gwstell: No more context or anything?
20:27:11 <slack1256> gwstell: weird. Any code snippet that triggers it?
20:27:18 <glguy> Rank-2 types?
20:27:25 <gwstell> RankNTypes enabled
20:27:35 <gwstell> the forall type is an alias
20:27:47 <gwstell>     Expected type: True
20:27:47 <gwstell>       Actual type: t1 -> t0 -> t1
20:28:06 <glguy> That means it needed to work for all types a and b, but yours only worked for t1 and t0
20:28:40 <gwstell> glguy: so t1 and t0 have been bound to some concrete type?
20:28:42 <glguy> Anyway, paste something to lpaste for us?
20:28:52 <gwstell> sure one sec
20:28:58 <gwstell> i'll clean it up first
20:30:17 <hunteriam> those of you on arch, do you use the official repos for haskell things or cabal?
20:30:38 <gwstell> http://sprunge.us/WZCd
20:31:18 <gwstell> apologies if its a bit weird looking
20:31:25 <slack1256> hunteriam: all the haskell things in the arch-repos the rest on sandbox of cabal
20:31:31 <gwstell> just scott encoding with some type aliases
20:48:26 <Geraldus> good news everyone %)
20:49:27 <Geraldus> Does anyone use GHC 7.10 on OS X?
20:50:55 <ttt_fff> text-format -- is thre a way to 0-pad ?
20:51:08 <ttt_fff> alterantlvely, is there a way to 0 pad a lazytext ?
20:52:04 <hunteriam> Geraldus: im on arch, maybe i can help?
20:55:37 <glguy> gwstell: You're trying to instantiate a type variable with polymorphic type (which you can't do) specifically in the case where you try to use "pair"
20:55:42 <Geraldus> hunteriam: well, let's see. I have two questions. First, is it good idea to migrate to 7.10 right now? I'm afraid, that some packages possibly will not build with GHC 7.10, though my current project is simple Yesod web site, so I suppose things should go smooth. 
20:55:59 <glguy> gwstell: To make your example work you can have:
20:56:00 <glguy> example 07:: Pair True False; example p 07= p true false
20:56:11 <glguy> Geraldus: I use GHC 7.10.1 on OS X, yes.
20:57:31 <glguy> But you shouldn't necessarily feel rushed to migrate. If you're using Stackage or plan to with Yesod you should probably hold off
20:58:12 <hunteriam> Geraldus: what do you think of yesod? i looked at it for doing a web project a while back but was intimidated and decided to go with something that seemed simpler
21:00:25 <Geraldus> glguy: well, in past I've used GHCJS, so 7.10 was the thing I've waiting for a long time. Other caveat is ghc-mod, which not works correctly now with cabal 1.22, and 7.10 could resolve this. And finally 7.10  released, but now I scary bit (: and want to know how things work with GHC 7.10. (excuse me my poor English)
21:00:52 <gwstell> glguy: thanks for the fix, still not entirely sure why it doesnt work though
21:02:35 <Geraldus> hunteriam: as for me, Yesod is something like a nuclear missile (: I have looked at other simpler frameworks, but I decided not to switch; Yesod was a bit hard at the very beginning, but now I'm pretty comfortable with it
21:03:02 <hunteriam> Geraldus: nuclear missile as in incredible?
21:03:06 <Geraldus> and Yesod is actively developed
21:03:28 <hunteriam> Geraldus: i think a few of the others are as well, although no doubt yesod is the biggest
21:04:04 <Denommus> hi
21:04:26 <glguy> gwstell: the type of pair :: a -> b -> Pair a b
21:04:30 <indiagreen> @tell ttf_fff you can use Â«left N '0'Â» (where N is the number of chars you want to have). For lazy Text, use justifyRight
21:04:30 <lambdabot> Consider it noted.
21:04:36 <indiagreen> ouch
21:04:44 <indiagreen> @tell ttt_fff you can use Â«left N '0'Â» (where N is the number of chars you want to have). For lazy Text, use justifyRight
21:04:44 <lambdabot> Consider it noted.
21:04:45 <glguy> gwstell: You have to pick specific types for 'a' and 'b' when you instantiate pair
21:04:55 <Denommus> this is a really interesting talk for those who haven't seen it: https://www.youtube.com/watch?v=mYvkcskJbc4
21:04:57 <Geraldus> and Yesod is actively developed, I wanted to say Â«Yesod is a big gunÂ», but then I though that's is much powerful than big gun 
21:05:05 <glguy> gwstell: You can't pick polymorphic ones like (forall a b . a -> b -> a)
21:06:03 <Geraldus> hunteriam: well, do your GHC 7.10 workflow involve much packages?
21:06:04 <hunteriam> Geraldus: mind telling me what makes it so powerful?
21:06:31 <hunteriam> Geraldus: i havent been developing web stuff lately, and generally no im not a package heavy kinda guy
21:06:36 <hunteriam> Geraldus: i tend to work on small projects
21:06:56 <Geraldus> hunteriam: I can't answer, it's just a feeling came after a while
21:07:15 <hunteriam> Geraldus: gotcha,like the feeling that you could make anything you want pretty easily?
21:07:34 <Geraldus> hunteriam: yeah, and also robust 
21:08:01 <Geraldus> but this is true for entire Haskell experience (:
21:08:05 <hunteriam> Geraldus: mind sharing any snippets you thought were particularly awe-inspiring? powerful frameworks kinda excite me
21:08:12 <hunteriam> yea word, thats why im in #haskell in the first place
21:08:31 <Geraldus> Haskell is the most amazing think I ever seen in programming world
21:08:32 <gwstell> glguy: thanks, that makes some sense
21:09:18 <Geraldus> glguy: may I ask how you installed GHC 7.10? 
21:09:40 <MP2E> For years I thought that I could never design a large application because of the huge abstraction towers built up in other languages. OOP particularly never clicked with me, I found it easier to make solutions in pure C vs OOP. It still amazes me today how people get work done with conventional languages
21:09:57 <MP2E> Haskell is the first time I've felt capable of designing something big
21:10:17 <MP2E> before I just felt caught in the toy project phase forever
21:10:18 <glguy> I build all my GHCs from the source tarball (because the binary tarballs are never available on release day) I'd recommend the GHC for OS X binary distribution though, now that it's out
21:10:22 <pacak> MP2E: Did you actually designed anything big?
21:10:27 <MP2E> nope, not really
21:10:34 <MP2E> ported a medium size game engine to Linux
21:10:37 <MP2E> that's about as far a I got in C
21:10:50 <MP2E> it was fairly win32 specific code but it still wasn't that difficult
21:10:54 <glguy> Geraldus: https://ghcformacosx.github.io/
21:10:54 <hunteriam> MP2E: i think youve got the chops for OOP
21:11:07 <Geraldus> glguy: I can't find installer on haskell.org. Though I've downloaded tarball announced by  MiÃ«tek Bak in Haskell Cafe from Halcyon
21:11:09 <hunteriam> MP2E: its pretty important to know i think, and its even got useful concepts for haskell!
21:11:31 <hunteriam> MP2E: i can explain confusing things to you if you want
21:11:33 <MP2E> fair enough :P I know it in the context of C++ but that's about it
21:11:39 <AfC> Large applications in Haskell have anti-patterns same as are present in any other large system. I think they're more _interesting_ problems, but the challenges of building complex systems remain.
21:12:03 <hunteriam> MP2E: well i think OOP in C++ isnt much different from OOP anywhere else
21:12:08 <mietek> Geraldus: the tarballs are in https://downloads.haskell.org/~ghc/7.10.1/
21:12:15 <hunteriam> AfC: what are antipatterns?
21:12:15 <mietek> Geraldus: they are still not linked from https://www.haskell.org/ghc/download_ghc_7_10_1
21:12:33 <glguy> mietek: We're talking about OS X
21:12:38 <mietek> Geraldus: and so am I
21:12:41 <glguy> OH, yay
21:12:48 <mietek> er
21:12:49 <mietek> glguy: ^^
21:13:06 <MP2E> It's difficult to break down my confusion into concrete questions. The main thing I always think is : where is the line seperating when I should make something a class vs just having a simple structure and some associated functions?
21:13:12 <mietek> Geraldus: Of course, getting the GHC for Mac OS X app might be a better choice anyway
21:13:24 <glguy> In any case the one I linked to is probably still a better choice
21:13:28 <Halfwit> Heh. The thing with OOP is that, you aren't missing anything useful in your inability to grasp it.
21:13:37 <mietek> glguy: :)
21:13:39 <Geraldus> glguy: oh, thank you. Let me ask one another question: do you experienced any inconveniences so far? (I believe OS X could be a bit nasty in oppose to Linux)
21:13:54 <MP2E> It's not so much reading code that is written in an OOP style, it's writing my own
21:13:58 <MP2E> figuring out when things should be objects
21:14:01 <MP2E> or when I should use inheritance
21:14:02 <MP2E> thigns like taht
21:14:04 <Axman6> hunteriam: I think the Servant web framework (if you can call it that) is a pretty good example of the power of Haskell; you can do things like ensure your whole app won't compile if you haven't written documentation for your whole API
21:14:05 <glguy> Geraldus: In general OS X works just as well as Linux. Windows is the one where you run into problems
21:14:16 <Geraldus> mietek: oh thanks a lot!
21:14:19 <hunteriam> MP2E try writing a program, i think thats a good way to acquaint, ill try and think o f a way to answer that question though
21:14:46 <hunteriam> MP2E: thats actually a tough question. I have intuition about it but not words to explain it
21:15:06 <hunteriam> MP2E: generally make something a class if its broader purpose than an object
21:15:07 <Geraldus> glguy: agree, but OS X some times also could be tricky (I hate Windows xD )
21:15:11 <mietek> Geraldus: you may also be interested in https://halcyon.sh
21:15:13 <hunteriam> MP2E: objects are specific vresions of classes
21:15:32 <hunteriam> MP2E: so you have a class Plant and an object Tree that implements Plant
21:15:48 <Halfwit> MP2E: You have to think in terms of scoping. When you want something to be accessed by thing A and or B, it needs to be a member of C, etc. 
21:15:51 <hunteriam> MP2E: i mean if you get haskell types and type classes its relatively similar
21:16:08 <Geraldus> mietek: I have looked at Halcyon several times already, but never tried it because of unknown reason
21:16:19 <MP2E> Hmm that's an interesting analogy :) types being objects, typeclasses being classes?
21:16:28 <MP2E> Halfwit: that makes sense
21:17:05 <hunteriam> MP2E: yea, although its a bad one because types are far from objects, although i think i would unofficially call them a superset
21:17:11 <mietek> Geraldus: https://robots.thoughtbot.com/building-haskell-projects-with-halcyon probably explains it better than myself
21:17:12 <hunteriam> its all pretty shitty though
21:17:21 <hunteriam> any one who takes this stuff seriously would kill me for that
21:17:26 <MP2E> haha
21:17:33 <mietek> Geraldus: if youâ€™re deploying Haskell apps, maybe join #haskell-deployment
21:18:06 <hunteriam> MP2E: also understanding the sorts of things youre going to be doing with your data helps you decide a lot how you want to structure it
21:18:32 <hunteriam> MP2E: its an architectural descision and you wanna choose a system that fits what youre building as best as possible
21:18:43 <hunteriam> so it totally varies from program to program
21:19:29 <Geraldus> mietek: Just few days ago I've dowloaded GHC 7.8.4 from haskell org as standalone application bundle, which contains ghc and cabal inside and I liked it; is ghc-7.10.1-x86_64-apple-darwin tarball something similar (I mean app bundle)? 
21:19:48 <mietek> Geraldus: no.
21:19:51 <MP2E> yeah, guess it's a question that can only be answered by intuition
21:19:57 <MP2E> and prior usae
21:19:58 <MP2E> use*
21:20:14 <mietek> Geraldus: thatâ€™s the link you already got above; https://ghcformacosx.github.io
21:20:35 <pacak> Geraldus: Be a man and compile it yourself :)
21:20:37 <hunteriam> MP2E: if you build a real program itll become clear pretty quickly what youd gain from using classes over objects
21:20:49 <mietek> pacak: please stop.
21:20:53 <Halfwit> There are always books on the matter of Data Structures and Algorithms
21:21:55 <Geraldus> mietek: well, I have not deployed any haskell app now (I've made some deploys in past), but I plans to have a VPS server, where I will run my apps built with docker locally (in past I had entire Haskell platform installed on VPS, and made productions builds right on VPS, but this is very slow process)
21:22:30 <mietek> Geraldus: Halcyon helps with that. See the linked article.
21:23:10 <Geraldus> pacak: I don't scary of compiling GHC myself, but I want to simplify further migrations, clean up is what scaring me
21:23:54 <Geraldus> mietek: aha, got it it (both about app and Halcyon, will study Halcyon article later)
21:24:34 <pacak> Geraldus: In our system we have a bunch of different ghc versions which allows us to switch between different version independently of system version. More controlled environment.
21:25:09 <pacak> Geraldus: Just build and install it under a place similar to /usr/local/ghc/ghc-7.10.1.XXX
21:25:20 <mietek> Halcyon supports automatically installing GHC versions from 7.10.1 to 7.0.4, as needed
21:25:29 <pacak> And then just prepend it to your PATH variable
21:25:47 <Geraldus> pacak: and I don't need that (: I've trained to build different GHC versions on OS X and Linux in past, but my current workflow allow me to use only single version
21:27:59 <Geraldus> pacak: and when I need to remove some old version I always confused, because it's hard to keep in mind all the places, where the its files are located (well, just for now, maybe in future this it will be easier to me)
21:28:25 <Geraldus> *where all the files
21:28:36 <Geraldus> doh, never mind
21:29:15 <pacak> Geraldus: Everything related to one version of ghc lives either under /usr/local/ghc/blah or  inside project's local cabal sandbox, which gets recreated and reinstalled from scratch on every clean build.
21:31:49 <kadoban> Is there any way to use this cool "partial type signatures" stuff in lambdabot? Like, type wildcards, extra-constraints wildcards, etc?
21:34:06 <Geraldus> pacak: this means I ball up something (:
21:36:35 <hunteriam> when you pacman -Syu in arch, does that fuck up your cabal at all? also does that make cabal-install cabal-install unnecessarry?
21:37:15 <sellers> hunteriam: things installed with cabal aren't managed by pacman at all
21:37:43 <sellers> oh, I think I see what you mean, um... nevermind, not sure
21:38:09 <Halfwit> It shouldn't touch your cabal.
21:39:36 <hunteriam> has anyone done anything neat with Foldable yet?
21:39:46 <Axman6> "yet"?
21:40:04 <Axman6> foldable is used extensively in lens
21:40:13 <Axman6> and probably heaps of other places
21:40:21 <edwardk> heaps uses Foldable, yes =)
21:40:35 <Axman6> heh =)
21:41:11 <sellers> Halfwit: but if pacman updated something that a cabal package depended on.. wouldn't that break things?
21:41:35 <sellers> I'm an idiot
21:41:36 <hunteriam> i think =) is #haskells favorite emoticon
21:41:48 <MP2E> :P is up there!
21:41:58 <hunteriam> definitely is, asa well as :)
21:48:41 <Geraldus> by the way, when migrating to newer version I will: nuke .ghc, .cabal folders; ghc-pkg recache; ensure that Cabal version match the one mentioned by `cabal --version`; modify PATH; install all packages needed globally (e.g. yesod-bin, hlint, ghc-mod, etc.); finally `uninstall-hs` if I want to remove old version. Am I missing something?
21:49:23 <kadoban> Geraldus: Saving your cabal config?
21:50:08 <Geraldus> kadoban: hmm, I'm not using global cabal config yet. 
21:51:01 <Geraldus> Oh, by the wayâ€¦ Is Stackage ready to be used with GHC 7.10?
21:52:41 <glguy> no
21:53:44 <Geraldus> hmm, hope this will not be an issue for current project
21:54:19 <newsham> lets say you are running some stuff in "MaybeT IO" and you have some computation of type "IO (Maybe a)" you want to run, is there an eays way to lift that to be of type MaybeT IO a?
21:54:44 <newsham> so that it treats the Nothing as failure and the Just val as "val" as other MaybeT IO a computations would?
21:54:44 <glguy> Yes, use the "MaybeT" data constructor
21:55:06 <newsham> hmm. thats almost like cheating :)
21:55:08 <newsham> so direct :)
21:56:30 <Geraldus> oh, ghci-ng does not support GHC 7.10 too
21:57:17 <newsham> glguy: works great, thank you.
21:59:03 <newsham> I'm enjoying MaybeT.
22:01:46 <glguy> yw
22:04:14 <kadoban> Geraldus: Stackage says about August for LTS 3, which is supposed to be aimed at 7.10
22:06:59 <Geraldus> kadoban: yes, I know (I read Stockage news). Tanks anyway 
22:16:48 <benzrf> hmm
22:17:21 <benzrf> is there some kind of haskell library for binding a wysiwyg-ish gui to some kind of backend logic that says "ok well if this is dragged here..."
22:17:52 <benzrf> er, to be clear this is for mathematical expressions
22:18:08 <benzrf> i mean something that already knows about subexpressions such that you can select and drag them around, or something
22:18:12 <benzrf> ok maybe this is a little too specific
22:22:34 <benzrf> night
22:37:13 <johnw> I was going to go with too general :)
22:37:46 <Javran> what's the difference between "hpc sum" and "hpc combine", except arity?
22:39:40 <Javran> hpc --help just says "combine tix files" and "sum fix files", isn't offering too much help.
22:39:51 <Javran> fix/tix
22:45:47 * hackagebot dataflow 0.1.0.0 - Generate Graphviz documents from a Haskell representation.  http://hackage.haskell.org/package/dataflow-0.1.0.0 (owickstrom)
22:46:29 <__ryan> hi everyon how get the velue from the persistentsql inside the handler
22:47:38 <Axman6> __ryan: have you read the examples? I assume you're using Yesod?
22:49:12 <__ryan> Axman6: yes i'm using yesod... but the example is they get the data in the hamlet - i want to manipulate the data in handler before they got to the hamlet
22:50:05 <Axman6> I would be very surprised if they get the data in a hamlet template, it is after all just a templating framework. the data will have been fetched earlier in the handler
22:50:16 <Axman6> do you have a link you're referring to?
22:51:37 <__ryan> nope for example i have - people <- selectList [PersonAge >. 25, PersonAge <=. 30] [] - now i want to get first the eg. age field or name field.
22:51:39 <Geraldus> __ryan: can you clarify a nbit?
22:52:18 <Axman6> well, `people` there is the result of the query
22:52:46 <Geraldus> let p = head people; name = PersonName p;
22:52:59 <Geraldus> now you can use #{name} in template
22:53:20 <Geraldus> but don't use head, it's just an example
22:53:22 <Axman6> don;t use head :(
22:53:27 <Axman6> heh
22:53:43 <__ryan> why?
22:53:52 <Geraldus> __ryan: because it's partial function
22:54:18 <Geraldus> and if you give to empty list list this will produce runtime error
22:54:23 <__ryan> ok so any suggestion?
22:54:35 <pacak> Yea, it's better to unsafeCoerce lists into Maybe and use maybe function.
22:54:36 <pacak> :t maybe
22:54:38 <lambdabot> b -> (a -> b) -> Maybe a -> b
22:55:29 <Axman6> you can also use templates to decide what to do based on patterns, so you can have different behaviour for empty and non-empty lists
22:55:36 <Axman6> pacak: ...
22:56:09 <Geraldus> you can also use safe `case` expression: case people of [] -> doNothing; (firstPeople:rest) -> doSomethingWithHim;
22:56:46 <pacak> Axman6: but it works just fine :)
22:56:46 <pacak> Prelude Unsafe.Coerce> maybe "Nothing here" id (unsafeCoerce [])
22:56:46 <pacak> "Nothing here"
22:56:46 <pacak> Prelude Unsafe.Coerce> maybe "Nothing here" id (unsafeCoerce ["foo", "bar"])
22:56:46 <pacak> "foo"
22:57:05 <Axman6> please don't do that either...
22:57:13 <pacak> :t listToMaybe
22:57:14 <lambdabot> [a] -> Maybe a
22:57:18 <Geraldus> __ryan: but also you can use `$if null people â€¦ $else`  in your template as Axman6 says
22:57:18 <Axman6> much better
22:59:11 <__ryan> i created a snippet for better explanation. http://lpaste.net/130327
22:59:31 <__ryan> hope that will help
22:59:46 <Geraldus> __ryan: anyway, this is not good practice in Haskell to use partial functions (e.g. that one which could produce runâ€”time errors). This is a kind of habit, you need to get used to it
23:00:12 <__ryan> Geraldus: what do you mean?
23:00:14 <platz> > traverse Just [1..100000000]
23:00:16 <lambdabot>  *Exception: stack overflow
23:00:40 <Geraldus> __ryan: look, people <- selectList [PersonAge >. 25, PersonAge <=. 30] [] gives you a list or Person's which potentially could be empty
23:00:52 <ricky_clarkson> __ryan: head fails when the list is empty, so there are ways of doing what you want without that failure.
23:00:54 <pacak> I though stuff like head/last are not exported by default in yesod projects...
23:00:57 <ricky_clarkson> > head []
23:00:59 <lambdabot>  *Exception: Prelude.head: empty list
23:01:40 <Geraldus> __ryan: by the way, do you need only first Person?
23:02:05 <Axman6> __ryan: well poeple <- people <- .. is clearly wrong
23:02:07 <platz> > let traverse' f = Data.Foldable.foldl' (\ys x -> (:) <$> f x <*> ys) (pure []) in isJust $  traverse' Just [1..100000000]
23:02:09 <lambdabot>      Not in scope: â€˜Data.Foldable.foldl'â€™
23:02:09 <lambdabot>      Perhaps you meant one of these:
23:02:09 <lambdabot>        â€˜Data.Foldable.foldâ€™ (imported from Data.Foldable),
23:02:14 <__ryan> lets say that the code result only one row of data
23:02:49 <__ryan> Geraldus: lets say that it result one row.
23:04:30 <platz> how to avoid the stack overflow with traversals?  seems like it uses foldr internally, but the Just prevents the results from being consumed eagerly?
23:04:55 <__ryan> Geraldus: I update the code can you check? http://lpaste.net/130327
23:05:08 <__ryan> Axman6: i update the code can you check? http://lpaste.net/130327
23:05:08 <Geraldus> __ryan: if you totally sure that you have at least one row, you can extract this from list in different ways; I prefer pattern match, look: let (firstRow:_) = people
23:05:51 <Axman6> __ryan: I still have no idea what you're actually trying to achieve
23:06:14 <Geraldus> __ryan: by the way this is illegal code `poeple <- people <- â€¦`
23:06:22 <Geraldus> Axman6: so do I
23:06:24 <Geraldus> :)
23:08:31 <__ryan> sorry wrong code :) here's the update http://lpaste.net/130327
23:08:40 <Geraldus> __ryan: `let (firstRow:_) = people`. Now you have first people stored in firstRow variable.  And you can extract it's fields easily: `let name = personName firstRow; age = personAge firstRow;`. And then use this new vars in your template: `First found persona name is #{name}`. etc.
23:09:41 <pacak> case blah { Nothing -> Nothing .... }  -- you probably want fmap here
23:10:16 <pacak> (not that this case makes any sense as it is btw)
23:10:20 <__ryan> Geraldus: does this code fit to the code? or?
23:11:12 <Geraldus> __ryan: but if I were you I would write in template: $if null people <p>No one found $else <ul> $forall p <- people <li> Info: #{personName p} #{personAge p} years old. Of course you have to structure code as multiline text (take a look at examples in the book)
23:12:42 <__ryan> Geraldus: which is faster?
23:13:50 <hunteriam> are there any distros besides arch that package 7.10?
23:13:56 <__ryan> Geraldus: i will try you suggestion thank you.. :)
23:13:58 <Geraldus> __ryan: but if you really want only first match, not a list of persons, you can use `selectFirst` instead of `selectList`, this gives you a Maybe value instead of list. In this case you should `$maybe p <- people <p> Found this person: #{personName p}; $nothing <p> Can't find a person!`
23:14:03 <hunteriam> arch doesnt quite work for me
23:14:17 <platz> is there a strict traverse for lists?
23:14:29 <__ryan> thanks to everyone.
23:16:55 <Javran> hello, I'm wondering what's the difference between "hpc sum" and "hpc combine"?
23:17:38 <Javran> sorry for asking again, but I've not yet got any answer :(
23:18:05 <hunteriam> :t hpc
23:18:06 <lambdabot> Not in scope: â€˜hpcâ€™
23:18:11 <Geraldus> __ryan: but if you need to do some manipulations over that person in your handler you can easily do it. Look: `maybePerson <- selectFirst [â€¦] []; let mPersonName = case maybePerson of Nothing -> Nothing; Just p -> personName p;` And now you can use mentioned $maybe condition in your template (again): $maybe name <- mPersonName <p> Person name is #{name} $nothing <p> Ooops!
23:18:11 <Geraldus> something wrong! Can't find a person in DB!`
23:18:17 <hunteriam> what is hpc Javran ?
23:18:34 <arkeet> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/hpc.html
23:18:41 <idnar> damnit, UTCTime doesn't have a Show instance
23:18:44 <Javran> https://wiki.haskell.org/Haskell_program_coverage 
23:19:04 <pacak> idnar: It does, import Data.Clock
23:19:15 <hunteriam> ah, probably cant help you there
23:19:16 <pacak> Or whatever the topmost module is
23:19:20 <arkeet> Javran: see docs ^
23:19:23 <Geraldus> __ryan: oh, there was a mistake: Just p -> Just (personName p); missed Just contractor
23:19:24 <indiagreen> Data.Time
23:19:31 <indiagreen> idnar: ^
23:20:02 <pacak> Or there's a better package - thyme. It's a bit infested with lens, but much faster.
23:20:38 <idnar> oh huh, thanks
23:20:38 <Geraldus> arkeet: Have been beaten by this few days ago. To deal with that you can use `formatTime` of `iso8601-time` package (the latter option is what I've choosen)
23:20:57 <__ryan> Geraldus: can you edit the code i create? got confuse :)
23:20:57 <idnar> pacak: I'm busy infesting all my code with lens myself, so that's not objectionable, I'll check that out too
23:20:59 <arkeet> was that meant to be directed at someone else?
23:21:05 <Geraldus> arkeet: sorry )
23:21:52 <idnar> I need Aeson (FromJSON, specifically) instances, but that seems to be taken care of too
23:22:04 <Javran> arkeet: I should have looked at the user guides first, yeah that's more clear than --help messages, thanks!
23:22:04 <Geraldus> idnar: `iso8601-time` could help to show/read UTCTime to and fro and guarantee equality
23:22:28 <Geraldus> __ryan: let me see
23:22:28 <idnar> Geraldus: I just want this for convenience, I'm not too worried about the exact representation
23:22:52 <Geraldus> idnar: I understood
23:22:54 <hunteriam> what do you guys program in haskell? all im planning on doing is some ghc contributions, not got any ideas otherwise that seem worth implementing
23:23:25 <ane> anything
23:23:30 <Geraldus> hunteriam: currently web sites, but I plan to do more in future, e.g. desktop apps
23:23:42 <hunteriam> Geraldus: have you completed any web sites?
23:23:49 <hunteriam> or any WIP?
23:23:49 <pacak> hunteriam: vector instructions would be nice to have.
23:23:56 <hunteriam> pacak: ?
23:24:03 <hunteriam> pacak: is that something youre implementing?
23:24:18 <Geraldus> hunteriam: I had only one moved to production, but unfortunately it's down for now
23:24:34 <Axman6> ghc sort of already does have access to vectore instructions (and LLVM can do smart things occasionally to add more)
23:24:51 <Geraldus> hunteriam: yes, I have WIP one 
23:24:51 <hunteriam> Geraldus: aw id love to see it
23:25:52 <pacak> Axman6: If you use llvm which we don't. And using instructions from AVX/SSE is kind of PITA at the moment even though code works much faster with them.
23:26:38 <Geraldus> __ryan: hold a sec
23:26:49 <__ryan> Geraldus: Thanks
23:27:01 <Geraldus> hunteriam: unfortunately I can't share it right now :( sorry
23:27:18 <pacak> Axman6: Even with LLVM those arbitrary AVX/SSE instructions are not exposed.
23:27:20 <hunteriam> Geraldus: aw, could you at least describe it?
23:27:31 <Javran> for me I don't write much web apps, just messing around hakyll for my personal pages
23:27:42 <Geraldus> my VPS is out of service now 
23:29:05 <Geraldus> hunteriam: the first site I've launched on Yesod was very simple and mostly statical web site for PVC window store
23:29:39 <Geraldus> my current web site mostly is a singe page web app, communicating with clients by web sockets
23:30:23 <hunteriam> Geraldus: can you do websockets in haskell, or are you writing it in javascript?
23:30:41 <hunteriam> the front end i mean
23:30:57 <hunteriam> also, are they nice to work with?
23:31:15 <jle`> websockets are nice on ghcjs :3
23:31:16 <jle`> :3
23:32:39 <hunteriam> do people actually use ghcjs?
23:32:43 <hunteriam> also does it output good js?
23:32:56 <jle`> it doesn't output idiomatic js
23:32:59 <hunteriam> the whole concept always seemed kinda shakey to me
23:33:03 <hunteriam> jle`: idiomatic?
23:33:11 <Geraldus> hunteriam: let me finish with __ryan. I do use GHCJS
23:33:12 <jle`> like javascript you would write if you were to write it natively
23:33:20 <hunteriam> ah
23:33:23 <hunteriam> Geraldus: sure thing
23:33:30 <hunteriam> Geraldus: not trying to interrupt
23:33:52 <__ryan> its ok.. nothing to rush
23:34:03 <hunteriam> jle`: so how do you interface with the DOM in ghcjs?
23:34:06 <Javran> I've never succeeded at compiling ghcjs.. and end up writing purescript...
23:34:20 <hunteriam> jle`: id assume theres a special library that goes hand in hand with ghcjs?
23:34:28 <jle`> hunteriam: there is a low-level DOM manipulation library
23:34:33 <safinaskar> > 0
23:34:33 <jle`> but there are also abstractions, ideally
23:34:34 <lambdabot>  0
23:34:40 <hunteriam> jle`: that sounds beautiful
23:34:48 <jle`> abstractions written over DOM manipulation that is analoguous to like GUI libraries in normal haskell
23:34:54 <hunteriam> jle`: you cant just write any old haskell,t hough, write? main probably isnt IO() either?
23:34:56 <jle`> declarative gui statements, rendered into javascript
23:35:01 <jle`> no, it's literally all of haskell
23:35:10 <jle`> you can compile almost any haskell program and it'll run on your browser
23:35:11 <jle`> as-is
23:35:17 <hunteriam> thats incredible
23:35:18 <jle`> stdout goes to the console
23:35:37 <hunteriam> thats the right way to do it too
23:35:53 <hunteriam> just map the essentials onto the world of html
23:36:05 <hunteriam> which GUI libs are supported jle` ?
23:36:21 <hunteriam> or i guess, any are? if you implement them with the DOM interface?
23:36:29 <jle`> well most gui libraries use C libraries heh
23:36:35 <jle`> right now the space is still open
23:36:52 <jle`> this is the space of "this is possible but nobody has stepped up and done it yet" area :)
23:36:53 <lpaste> Geraldus revised â€œSample Codeâ€: â€œ__ryan getting startedâ€ at http://lpaste.net/130327
23:37:02 <hunteriam> jle`: it doesnt sound so hard, does it?
23:37:05 <jle`> ghcjs in usable form is still fairly young
23:37:07 <jle`> nope, does not
23:37:24 <jle`> but you'll find that gui in haskell has historically been a neglected area in library development for some reason
23:37:28 <lpaste> Geraldus revised â€œSample Codeâ€: â€œ__ryan getting startedâ€ at http://lpaste.net/130327
23:37:28 <jle`> so...it's our bad :/
23:37:32 <hunteriam> jle`: any idea of what this mythical lib will look like when it finally exists?
23:37:49 <Geraldus> __ryan: have a look at last link I've posted
23:37:52 <hunteriam> i might take a swing at it, but i dont feel confident defining the structure
23:37:57 <jle`> you probably could copy the interface of any existing GUI library...like threepenny-gui
23:38:12 <hunteriam> jle`: and map it onto canvas, or dom?
23:38:19 <jle`> and just adapt it to ghcjs with dom manipulations instead of ffi calls to a c library
23:38:23 <Geraldus> hunteriam: you can very easy use web sockets with Yesod 
23:38:25 <jle`> hm...dom sounds more ideal
23:38:39 <hunteriam> jle`: i guess you could quite easily map gl to webgl
23:38:43 <jle`> right now there's already a virtual dom wrapper if you want to go ahead and start now with a low-level abstraction
23:38:45 <hunteriam> jle`: and use that with canvas
23:38:52 <hunteriam> i cant start now
23:38:56 <hunteriam> i cant start till schools out, basically
23:38:59 <hunteriam> im very very busy atm
23:39:08 <hunteriam> thanksfully thats only 4 weeks away
23:39:14 <jle`> oh i mean, if you wanted to use ghcjs *today* to build gui
23:39:25 <__ryan> Geraldus: i will check this out.. thank you very much..
23:39:38 <jle`> there's a library that wraps over the js virtualdom library...and has a nice declarative-ish interface
23:39:39 <hunteriam> ah sure
23:39:40 <Geraldus> hunteriam: as for GHCJS output code is huge, but writing code with it is amazing (personally for me). 
23:39:56 <hunteriam> Geraldus: the project youre working on sounds really great
23:39:59 <jle`> but by the nature of virtualdom (the js library) means that it's fairly close to HTML/dom
23:40:03 <hunteriam> i really wanna see the code or the product eventually
23:40:31 <hunteriam> jle`: ill take a look at all this stuff
23:40:34 <hunteriam> it sounds very cool
23:40:41 <jle`> the best part about ghcjs though is like you can really write both frontend and backend in the same project and use the same types, same libraries, etc.;  and all of the libraries, everything works the same.  being able to share types between your frontend and backend opens a lot of doors too
23:40:47 <hunteriam> jle`: do you think its a better use of my time than working on ghc?
23:41:03 <hunteriam> jle`: that sounds dreamy
23:41:03 <Geraldus> I hoped that GHC 7.10.1 will eliminate inconveniences of ghc-mod and cabal-1.22, however `ghc-mod` is not buildable under 7.10.1 :(
23:41:29 <jle`> it's great because when you use things like websockets, you can send and receive the exact same ADT/data type
23:41:38 <jle`> in both your backend and frontend
23:41:49 <hunteriam> i guess websockets would work like an IORef?
23:41:51 <jle`> well, it's really up to you
23:41:54 <hunteriam> if so, thatd be awesome
23:41:59 <Geraldus> hunteriam: yes, this is one of the coolest things GHCJS gives (as for me)
23:42:17 <hunteriam> jle`: do you think a websocket would be analagous to IORef in this case?
23:42:18 <jle`> well my websockets library treats it like an input stream through an IO handle, like Handle
23:42:29 <jle`> it'd be something like a TCP socket in normal haskell
23:42:29 <hunteriam> jle`: ah im not familiar with handle
23:42:33 <Geraldus> but another cool thing is that you can use a lot of preexisting packages in your GHCJS code
23:42:52 <hunteriam> also does anyone write iOS apps with ghc -> ios?
23:42:53 <jle`> the typical way of doing networked haskell on computers
23:43:01 <hunteriam> i gotta try all this stuff
23:43:03 <hunteriam> it all sounds so cool
23:43:19 <jle`> i should probably push my ghcjs-websockets library to hackage
23:43:36 <jle`> it's been done for a year...
23:44:09 <Geraldus> there was many troubles in past with GHCJS (and I believe there is still something broken now). But I was very happy with it in general 
23:44:19 <jle`> it's a grand vision :)
23:45:36 <hunteriam> you should!
23:45:50 <Geraldus> by the way, this is why I wanted to migrate to GHC 7.10, GHCJS require cabal-1.22, and ghc-mod can't deal with projects initiated with cabal-1.22
23:47:40 <Geraldus> jle`: very appreciate! I've implemented web socket function I needed in GHCJS using low level foreign functions. It's worked perfectly though. But now I interest in a higher level things (:
23:48:20 <jle`> https://github.com/mstksg/ghcjs-websockets if you want something now.  it is a low-level interface based on the interface for io-sockets and normal websockets
23:48:37 <jle`> i originally had a high level interface like cloud-haskell's interface with typed channels but i decided to scale it down heh
23:49:02 <jle`> as in, set up multiple "awaiters" on the same websocket, each one wakened when something of a specified type came through
23:49:22 <jle`> so you could have a thread waiting on an Int from a channel, a thread waiting on a Double, a thread waiting on a MyCustomType...
23:49:43 <jle`> i decided that'd probably be better for people to implement on their own if i needed it...and that a low level library was the most generally useful
23:50:50 * hackagebot stackage-curator 0.7.4 - Tools for curating Stackage bundles  http://hackage.haskell.org/package/stackage-curator-0.7.4 (MichaelSnoyman)
23:51:09 <hunteriam> neat
23:51:18 <hunteriam> ill have to check thta out when i start looking at all this
23:58:25 <__ryan> Geraldus: sorry i here again it gives me this error - Couldn't match expected type People with actual type â€˜Entity Peopleâ€™
23:59:02 <Geraldus> __ryan: oh sorry for that, let me check.
