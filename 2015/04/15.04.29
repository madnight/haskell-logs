00:07:37 * hackagebot http-client 0.4.11.2 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.11.2 (MichaelSnoyman)
00:07:37 * hackagebot aws-route53 0.1.2 - Amazon Route53 DNS service plugin for the aws package.  http://hackage.haskell.org/package/aws-route53-0.1.2 (DavidTerei)
00:17:25 <krgn_> I'm writing a client to a CouchCB changes feed, and am wondering which http client library will let me use feed=continuous and consume the response one line at a time. Is http-client a viable choice?
00:20:16 <krgn_> using HTTP atm, and longpoll which is fine. `continuous` mode is just more elegant imo :)
00:27:32 * hackagebot bitcoin-types 0.9.0 - Provides consistent low-level types used commonly among Bitcoin implementations  http://hackage.haskell.org/package/bitcoin-types-0.9.0 (solatis)
00:58:21 <jle`> is there a better way of checking if constraints are valid in ghci than doing something like :t undefined :: (Bool ~ Int) => () 
00:58:38 <jle`> (if i wanted to check Bool ~ Int, for example
00:59:17 <mau|{e> does :k Bool ~ Int work?
00:59:33 <arkeet> it would not
00:59:34 <jle`> nah it gives Bool ~ Int :: Constraint
01:00:00 <merijn> It's Awodey hour again! After introducing the slice category C/c of a category C, where the objects in C/c are the arrows f from C such that cod(f) = C and the arrows are arrows in C such that 'g : (x -> c) -> (x' -> c)' in C/c corresponds to an arrow "x -> x'" in C he mentions the "obvious" functor "U : C/c -> C" which just forgets about the base object 'c'.
01:00:04 <arkeet> maybe use Dict from the constraints package
01:00:09 <arkeet> Dict :: Dict (Bool ~ Int)
01:00:13 <arkeet> (no need for :t)
01:00:29 <arkeet> haven't tested this
01:00:31 <jle`> that's an interesting type
01:00:38 <jle`> i wonder if Proxy works, as it is polykinded
01:00:45 <arkeet> no
01:00:53 <merijn> So far it (mostly) makes sense, although I'm not quite sure I understand the functor U, I can see how you map the objects 'x -> c' back to just 'x', but then wouldn't you be missing the arrows 'x -> c'?
01:01:26 <jle`> Proxy works but it has no error. i guess that makes sense
01:01:49 <arkeet> :t Dict
01:01:50 <lambdabot> Not in scope: data constructor ‘Dict’
01:01:55 <merijn> Anyway, the bigger issue is that he then asks me to find a functor "F : C/c -> C->" such that "dom . F = U", now since C/c is filled with triangles and C-> wants commutative squares I don't understand how to do this without adding new arrows, which I don't think functors are allowed to do?
01:02:00 <jle`> data Constraint :: BOX
01:02:00 <arkeet> @let import Data.Constraint
01:02:01 <lambdabot>  .L.hs:75:1:
01:02:01 <lambdabot>      Failed to load interface for ‘Data.Constraint’
01:02:01 <lambdabot>      Use -v to see a list of the files searched for.
01:02:03 <jle`> what is this, DataSorts?
01:02:17 <arkeet> no, it's haddock
01:02:33 <arkeet> re-exporting the Constraint kind
01:02:33 <jle`> my first time seeing a sort signature in haddock
01:02:37 <arkeet> heh
01:02:37 <jle`> oh i see
01:02:50 <merijn> jle`: BOX is the kind of kinds :p
01:02:51 <ysr> if I have a list of filenames of arbitrary size, how can I open every file?
01:02:53 <arkeet> anyway, the thing should work because
01:02:56 <arkeet> Dict :: c => Dict c
01:03:07 <merijn> ysr: You're probably looking for mapM
01:03:16 <jle`> > unsafePerformIO $ system "cabal install constraints"
01:03:17 <lambdabot>  Not in scope: ‘unsafePerformIO’Not in scope: ‘system’
01:03:26 <jle`> was worth a shot
01:03:48 <merijn> jle`: Hah, like no one tried *that* before :p
01:04:05 <jle`> well i mean i was doing it with good intention so lambdabot should recognize.
01:04:10 <ysr> merijn: I have heard about mapM before, but I am not really sure what it does
01:04:12 <merijn> Drat, looks like all the math people are sleeping
01:04:14 <merijn> :t mapM
01:04:15 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
01:04:27 <merijn> Actually, let me specialise that a bit
01:04:48 <merijn> :t mapM :: Monad m => (a -> m b) -> [a] -> m [b]
01:04:48 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
01:05:06 <arkeet> (a -> IO b) -> [a] -> IO [b]
01:05:30 <mau|{e> :t mapM `asAppliedTo` readFile
01:05:31 <lambdabot> Traversable t => (FilePath -> IO String) -> t FilePath -> IO (t String)
01:05:37 <merijn> ysr: So, suppose you have "openFile :: String -> IO Handle" and "[String]" you'd get "mapM :: (String -> IO Handle) -> [String] -> IO [Handle]"
01:05:53 <ysr> oh, actually, I don't have a list of files I have a IO [String]. 
01:06:03 <merijn> ysr: Oh, but that's easily fixed to
01:06:06 <merijn> :t (>>=)
01:06:07 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:06:18 <kqr> ysr, if it's easier, mapM f xs = sequence (map f xs)
01:06:27 <kqr> ysr, only needs you to know how sequence and map works :)
01:07:04 <jle`> arkeet: it works, thanks :)
01:07:16 <kqr> :t asAppliedTo
01:07:17 <lambdabot> (a -> b) -> a -> a -> b
01:07:25 <merijn> ysr: Given "myFiles :: IO [String]" and "mapM readFile :: [String] -> IO [Handle]" we get "(>>=) :: IO [String] -> ([String] -> IO [Handle]) -> IO [Handle]"
01:07:41 <ysr> so, if I did main = getArgs >>= openFile do I get IO [list of file handles] ?
01:07:48 <merijn> ysr: So you'd do "myFiles >>= mapM openFile" (just realised I wrote the wrong name)
01:08:08 <arkeet> getArgs :: IO [String]
01:08:13 <arkeet> openFile :: String -> IO Handle
01:08:21 <arkeet> mapM openFile :: [String] -> IO [Handle]
01:08:24 <merijn> ysr: Which happens to be the same as "do { fileNames <- myFiles; mapM openFile fileNames }"
01:08:41 <merijn> @undo do {fileNames <- myFiles; mapM openFile fileNames }
01:08:41 <lambdabot> myFiles >>= \ fileNames -> mapM openFile fileNames
01:08:51 <merijn> Well, modulo eta reduction
01:08:51 <arkeet> @@ @pl @undo do {fileNames <- myFiles; mapM openFile fileNames }
01:08:51 <lambdabot>  mapM openFile =<< myFiles
01:09:20 <merijn> ysr: Although you might wanna sit and ponder the flood of explanation for a bit :p
01:09:36 <ysr> I need to time to process this information :D
01:10:31 <merijn> ysr: A good exercise would be to take the type signatures of all the functions mentioned, grab some paper, write them down and by hand specialise/substitute the times in them to see how they fit together
01:10:58 <igniting> ysr: what do you want to do with files? depending on that openFile may not be the function you are looking for
01:11:34 <merijn> igniting: Sure, openFile is just an example, the same approach can be used for any number of other functions
01:12:01 <brbblnch> Hi
01:14:27 <brbblnch> Is there an interpretation of the term Λα.x^{∀β.β} in System F ? The closer thing I find is the closed term λx^{∀β.β}.Λα.x which would be some uselessly polymorphic identity function on ⊥, right?
01:14:47 <brbblnch> *closest
01:17:22 <jle`> does douglas auclair hang out around here ever?
01:18:20 <ysr> igniting sorry, I have been away for a while. In the long run, I want to create a very simple archiving application (no compression, just put some together kind of thing). But for now, I just want to open them see filesizes and print file sizes to terminal
01:18:46 <ysr> I do this as an exercise, it will not be used for anything :D
01:18:48 <mau|{e> you don't need to open a file to get its size
01:19:23 <frerich> mau|{e: Chances are that you do want to open a file to avoid races though.
01:19:39 <ysr> getFileStatus is defined in System.Posix, I am on windows machine and I can't use that
01:19:46 <kqr> ysr, that works on windows
01:19:55 <mau|{e> frerich: how does that avoid races?
01:20:44 <ysr> doing :m + System.Posix says it cant find the module
01:20:45 <frerich> mau|{e: If you put the right fairy dust on the openFIle call you can avoid that the file size changes.
01:21:23 <mau|{e> show me
01:21:35 <merijn> frerich: *bzzzt*
01:21:54 <merijn> frerich: I'm sorry, but that answer is incorrect :) There's posix locks, but even those are optional and ignorable
01:22:11 <frerich> You dont need locks. On WIndows, which is what ysr talks about, you can open with exclusive access.
01:22:27 <frerich> I.e. it's a CreateFile() flack, independant of what LockFile() does.
01:22:31 <frerich> flag, too.
01:22:33 <mau|{e> show me
01:22:47 <frerich> mau|{e: Google for 'msdn CreateFile exclusive'
01:23:11 <kqr> frerich, but what if one file is changed when you print the size of another one?
01:23:12 <mau|{e> bzzt, wrong
01:23:19 <kqr> frerich, can you get exclusive access to all files atomically?
01:23:35 <kqr> partial atomicity is hardly worth much
01:23:49 <frerich> mau|{e: Hold on, somebody on the Internet is wrong? :-)
01:24:00 * frerich imagines mauke doing a 'strike' gesture ;-)
01:24:12 <mau|{e> frerich: how does googling CreateFile help me with openFile?
01:25:03 <merijn> frerich: mau|{e is like the magical oracle of standards, my theory is that he's a bored AI
01:25:06 <mbuf> what could I be missing? https://gist.github.com/shakthimaan/62518eeecafa31789bf0 
01:25:16 <frerich> mau|{e: I was going out on a limb here, but I hope there's a openFIle function in the Win32 modules which can take flags to pass to the native API
01:25:42 <frerich> mau|{e: In System.Win32 maybe? 
01:26:52 <frerich> kqr: I don't know whether you can get a nice lock on a whole set of files. Maybe a directory of files. On Windows, at least.
01:27:34 * hackagebot filediff 0.1.0.8 - Diffing and patching module  http://hackage.haskell.org/package/filediff-0.1.0.8 (bgwines)
01:27:39 <ollef> mbuf: does it work if you remove the space before the colon?
01:28:30 <merijn> mbuf: "deadsimple magic" usually isn't
01:30:08 <mau|{e> mbuf: have you tried 'parse'?
01:30:20 <frerich> mau|{e: https://github.com/haskell/win32/blob/master/System/Win32/File.hsc#L418 looks good!
01:32:33 <kqr> mbuf, what ollef says. it works without the space
01:33:41 <lpaste> ysr pasted “parse error on last line” at http://lpaste.net/131662
01:34:00 <ysr> Why am I getting a parse error?
01:34:06 <kqr> ysr, skip the "in"
01:34:21 <arkeet> or indent it further
01:34:25 <kqr> ysr, inside do notation, "let" doesn't need "in"
01:34:36 <arkeet> but yes, in do notation I'd just delete the "in"
01:35:15 <mau|{e> remove 'let'
01:35:24 <merijn> ysr: FYI, I tend to strongly recommend explicit use of >>= and >> for beginners until you get comfortable with that and only THEN switching to using do-notation
01:35:29 <arkeet> don't remove let.
01:35:44 <mau|{e> arkeet: how are you going to do I/O with let?
01:35:57 <mau|{e> also, you're leaking filehandles
01:36:09 * frerich wonders whether it's that time of the week with mauke again ;-)
01:36:10 <merijn> arkeet: At least some of those are mixing up what's going on
01:36:56 <merijn> ysr: There's some confusion going on with that code you wrote (i.e. with IO effects) that would go away with explicit use of >>= and >>
01:37:31 <kqr> merijn, do you have any sort of evidence >>= helps for beginners? because my experience has been the opposite
01:37:32 <igniting> ysr, you can use withFile so that you don't forget to close handles
01:37:50 <kqr> merijn, (sure, do notation is more confusing, but it has IME let beginners become productive faster, which is encouraging)
01:37:51 <mau|{e> mapM (\p -> withFile p ReadMode getFileSize)
01:38:08 <mau|{e> kqr: it helped me enormously
01:38:23 <mau|{e> do notation was a confusing mess at the beginning
01:38:27 <merijn> kqr: I value correctness and understanding of types over "productivity"
01:38:31 <kqr> ah
01:38:33 <kqr> fair enough
01:38:40 <mau|{e> (because none of the tutorials at the time explained how IO worked)
01:38:41 <merijn> kqr: I've noticed beginners getting lost for hours not understanding what's happening
01:39:09 <kqr> yeah it might help if you are working without guidance
01:39:10 <mau|{e> and because they conflated do notation, monads, and IO
01:39:13 <merijn> kqr: Using >>= and >> crystallises how things tie together and once you can write like that it's easy to transition to do-notation while still understanding what's going on
01:39:25 <merijn> Yeah, that conflation is a problem too
01:39:41 <kqr> with guidance, people can reach operational understanding of IO through do notation fairly quickly
01:40:04 <merijn> ysr: http://lpaste.net/131662
01:40:13 <kqr> I recently tutored a couple of beginners whose reaction was "wait. it's that easy? that's basically what I'd do in any other language except a separation between pure and side effectful computations"
01:40:17 <merijn> ysr: As an exercise, try writing down the types of the various smaller expressions in there
01:40:19 <earthy> as another datapoint: most of my coworkers do not understand C#'s LINQ from expressions, but are perfectly happy with Select and SelectMany (the C# variants of >> and >>=)
01:40:27 <kqr> they had previously tried to go the >>= route and thought it too arcane =)
01:41:06 <merijn> kqr: Well, in case someone has two separate pieces "a -> IO b" and "IO a" I find that understanding >>= happens kinda quickly :)
01:41:35 <frerich> kqr: It's a very easy start, but it starts to become confusing once you notice e.g. how 'return' doesn't return from the function or how you can use 'let' or 'let .. in'. I.e. the mental image may collapse once you hit problems (and when you hit problems, it's always good to be able to view something on a 'lower level')
01:41:45 <_rgn> kqr: but it's "magic" until you understand how it really works
01:42:06 <mau|{e> kqr: that sounds more like a problem than a solution
01:42:11 <merijn> Right, I don't like teaching people magic, especially if it confuses right as they feel they get a grasp on things
01:42:30 <kqr> _rgn, I don't accept the "avoid magic" argument, because garbage collection, laziness, caches, out-of-order execution, ALUs etc
01:42:37 <mau|{e> "IO" is not a tag that marks functions as impure
01:42:57 <kqr> frerich, the good thing about 7.10 is that now we can use pure instead of return, which should limit confusion about that bit at least
01:43:37 <mau|{e> I'd say if you don't understand that putStr is pure and getLine is not a function, you don't understand IO
01:44:04 <kqr> merijn, fair enough. I might just be a bit too focused on getting people to view haskell as a fairly normal and easy language as they are learning. might depend on the kind of crowd I hang out with
01:44:10 <merijn> mau|{e: "but everything's a function in haskell!"
01:44:33 <merijn> kqr: I always say there's two paths to learning haskell and they're equally frustrating, but in different ways :p
01:44:36 <kqr> mau|{e, yeah, I value being able to do IO over understanding how it's modeled when it comes to beginners
01:44:50 <mau|{e> I was completely unable to do IO without understanding
01:44:51 <merijn> kqr: There's "trying to build something real ASAP" which leads due to frustration from confusion and complexity
01:45:14 <mau|{e> I mean, I could copy/paste "hello world"
01:45:15 <merijn> And there's "trying to understand the basics properly" which leads to frustration from the inability to write "real" code
01:45:47 <merijn> Different approaches work for different people, however, I don't consider myself able to help the former group, as I'm from the latter
01:46:12 <mau|{e> for bootstrapping beginners I'd give them 'main = interact transform' as magic
01:46:19 <mau|{e> and let them write transform functions
01:47:10 <kqr> merijn, with good tutoring, at least IME, writing "real" code doesn't lead to too much frustration. I think operational learning is really strong
01:47:23 <kqr> merijn, but then again, I just realised I might be in the "have to understand the basics" camp myself, so...
01:48:37 <merijn> kqr: I think you can get to "working" code from the basics in a few days
01:49:14 <merijn> But by "real" code I mean: transformers, pipes and all the usual suspects of libraries you have to know to write REAL haskell
01:49:34 <kqr> oh that's not how I used "real"
01:50:07 <kqr> I was just talking about being able to write programs that interface with $world_part_of_choice
01:50:19 <merijn> I mean, I sometimes see beginners starting with stuff like Yesod/aeson and that just seems like a painful experience as a complete beginner
01:50:23 <kqr> be it sockets, files, unix environment etc
01:50:37 <kqr> totally
01:51:44 <kqr> I see a basic divide in learning material: some of it focuses on living in ghci and writing pure expressions, while the other focuses on creating a main top-level definition and often starts with "hello world" and "what's your name" type of programs
01:51:56 <kqr> the latter kind is what I refer to as "real" in this case
01:53:13 <kqr> and the one I prefer to start with, unless I know that particular person would rather start with the basics
01:53:15 <merijn> I think there especially focusing on >>= and >> early can solidify the most important lessons: first class IO, IO is not impure, composing IO and "IO a" is not a function
01:53:39 <merijn> I mean, if you make sure to drill home those points early and clearly you can avoid a lot of confusion later
01:53:53 <kqr> I agree 100%, unsurprisingly
01:53:55 <merijn> I like the "map print [1..10] !! 3" example
01:54:07 <kqr> I've just had a much lower retention rate by going that way
01:54:13 <mau|{e> > let foo = print 42 in length [foo, foo, foo]
01:54:14 <lambdabot>  3
01:54:41 <kqr> I've attributed that to the "weirdness" that is IO combinator operators, but it might very well just be me sucking at presenting it well
01:55:40 <merijn> The great thing about #haskell is that I don't have to care about retention rates, just about being helpful and if people don't care for my way of explanation they're free to get a refund for the money they paid me :p
01:55:46 <kqr> haha
01:56:24 <kqr> yeah >>= might actually be better for "drive by" teaching too
01:56:57 <frerich> merijn: *chuckle*
01:57:01 <kqr> my experience is mostly limited to longer, focused sessions with the same people over a larger timespan
01:57:35 * hackagebot stackage-install 0.1.0.0 - Secure download of packages for cabal-install  http://hackage.haskell.org/package/stackage-install-0.1.0.0 (MichaelSnoyman)
01:59:45 <merijn> Man, why does haskell spoil me so? Now I want Rank2 types in C++... :\
02:00:18 <merijn> Actually, I probably wouldn't even need the Rank2 types if I was writing haskell...
02:00:30 <jle`> you have them. untyped pointers :D
02:00:36 <kqr> I want purity every day :(
02:00:40 <kqr> so hard to refactor impure code
02:00:46 <kqr> and debug it
02:01:08 <kqr> I love it when only some of the seemingly identical requests trigger an exception
02:01:10 <merijn> jle`: Nope, that doesn't work with templates
02:01:17 <merijn> kqr: const all the things!
02:01:23 <jle`> oh yeah
02:01:24 <merijn> kqr: And noexcept
02:01:41 <kqr> merijn, if only those things were things I had in Python...
02:02:00 <ggVGc> is there a PEG library for haskell? I can't seem to find one
02:02:42 <kqr> ggVGc, parsing is commonly done through parser-generators in Haskell which might explain low count of other kinds of parsing libraries
02:03:08 <merijn> kqr: Don't you mean parser-combinators?
02:03:09 <kqr> parser-combinators*
02:03:10 <kqr> sorry hah
02:03:19 <ggVGc> yeah
02:03:26 <ggVGc> I know, but I really like PEG :(
02:03:27 <ollef> ggVGc: https://hackage.haskell.org/package/frisby
02:03:32 <ggVGc> guess I'll learn parsec
02:03:37 <Rintrah> Hello, I'm trying the "build yourself a scheme" tutorial and I'm stuck with a data constructor error: http://lpaste.net/131664 .  Can anyone  help me please?
02:03:52 <kqr> Rintrah, big T in TagName
02:04:08 <merijn> ggVGc: There's happy/alex, which are basically lex/yacc for haskell, but I've never used them
02:04:28 <ggVGc> merijn: that's parser generators though isn't it?
02:04:33 <ggVGc> not PEG libraries
02:04:48 <ggVGc> ollef: 
02:04:51 <ggVGc> thanks will check it
02:04:51 <merijn> ggVGc: I dunno what PEG stands for, I guess :p I was guessing since google wasn't helpful
02:04:56 <lpaste> ysr pasted “working code” at http://lpaste.net/131666
02:04:56 <Rintrah> thanks a bunch
02:05:08 <merijn> Rintrah: Type names and constructors *have* to start with a capital letter
02:05:09 <ggVGc> merijn: Parsing Expression Grammar
02:05:23 <ggVGc> merijn: this is a PEG library for Lua which I like a lot, http://www.inf.puc-rio.br/~roberto/lpeg/
02:05:27 <merijn> Rintrah: (The advantage being that you never have to ask yourself whether something is a type or constructor when reading code)
02:05:30 <ysr> above paste is working now, how does it look?
02:06:34 <ggVGc> ollef: cool that seems very much like what I was looking for!
02:06:41 <ggVGc> wonder how active this project is though
02:06:55 <merijn> ysr: You can probably simplify, but it looks ok
02:07:00 <merijn> ysr: You may want to read: https://en.wikibooks.org/wiki/Haskell/do_notation
02:07:08 <kqr> ggVGc, last uploaded november 2014, so not too bad, perhaps?
02:07:16 <ggVGc> yep, seems good
02:07:19 <ggVGc> I'll try it
02:07:36 * hackagebot stackage-install 0.1.0.1 - Secure download of packages for cabal-install  http://hackage.haskell.org/package/stackage-install-0.1.0.1 (MichaelSnoyman)
02:07:42 <ggVGc> merijn: if youäre interested, this page actually has a very good summary of what PEG is under description, http://repetae.net/computer/frisby/
02:08:12 <ggVGc> this is my favourite thing, "you never need a separate lexing pass with PEG parsers, since you have arbitrary lookahead there is no need to break the stream into tokens to allow the limited LALR or LL lookahead to work."
02:08:53 <merijn> ggVGc: I'm interested, but I should probably be working instead xD
02:12:36 * hackagebot stackage 0.7.1.0 - Dummy package forcing installation of other Stackage packages  http://hackage.haskell.org/package/stackage-0.7.1.0 (MichaelSnoyman)
02:16:11 <ollef> ggVGc: if I'm allowed to toot my own horn, you might also be interested in https://github.com/ollef/Earley which from the sounds of it should also do what you want
02:22:59 <Aruro> any alternatives to coq in haskell?
02:23:31 <merijn> Aruro: What do you mean by that?
02:23:54 <merijn> Aruro: Are you looking for Agda?
02:25:12 <gremble> If I use the import statement to load in some modules, are those libraries dynamically or statically linked to my executable?
02:26:27 <merijn> gremble: By default GHC links all *haskell* libraries statically
02:27:01 <gremble> Ah okay
02:27:04 <gremble> Thank you merijn 
02:31:22 <merijn> gremble: But in recent (7.4 or 7.6?) GHCs you can optionally link dynamically
02:33:13 <gremble> That is good to know
02:36:04 <Rainb> how'd you group boolean values on a list?
02:36:25 <kqr> Rainb, group? what does it mean to group them?
02:36:46 <kqr> > > group [True, True, True, False, False, True, False, False]
02:36:48 <kqr> whoops
02:36:48 <lambdabot>  <hint>:1:1: parse error on input ‘>’
02:36:50 <kqr> > group [True, True, True, False, False, True, False, False]
02:36:51 <lambdabot>  [[True,True,True],[False,False],[True],[False,False]]
02:37:00 <Rainb> wut
02:37:01 <Rainb> magic
02:37:06 <Aruro> merijn: i was just trying to install yesterday coq on arch and could not make it :D so i was wondering abour alternatives in the world of haskell
02:37:08 <Rainb> yeah, that was it
02:37:16 <arkeet> > grou [1,2,2,2,3,3,2,2,4]
02:37:17 <lambdabot>      Not in scope: ‘grou’
02:37:17 <lambdabot>      Perhaps you meant one of these:
02:37:17 <lambdabot>        ‘BSC.group’ (imported from Data.ByteString.Char8),
02:37:18 <arkeet> > group [1,2,2,2,3,3,2,2,4]
02:37:20 <lambdabot>  [[1],[2,2,2],[3,3],[2,2],[4]]
02:37:48 <Aruro> :t group
02:37:49 <lambdabot> Eq a => [a] -> [[a]]
02:38:46 <mbuf> ollef, yes, it works without the space in front of the colon; thanks!
02:40:14 <Aruro> merijn: yes it looks like agda is what i need
02:41:31 <Aruro> merijn: is it alive project?
02:41:38 <merijn> Very much so
02:41:47 <Aruro> k, good to hear
02:42:08 <lpaste> ysr pasted “can I simplify this function” at http://lpaste.net/131667
02:42:25 <ysr> Can you guys check my function above?
02:42:38 * hackagebot hmm-hmatrix 0.0 - Hidden Markov Models using HMatrix primitives  http://hackage.haskell.org/package/hmm-hmatrix-0.0 (HenningThielemann)
02:43:12 <jle`> ysr: `map length`, and then scanl (+) 0
02:43:42 <jle`> > scanl (+) 0 [5,7,3,3,3]
02:43:43 <lambdabot>  [0,5,12,15,18,21]
02:43:58 <jle`> sorry, scanl'
02:44:02 <jle`> > scanl' (+) 0 [5,7,3,3,3]
02:44:03 <lambdabot>  [0,5,12,15,18,21]
02:44:29 <jle`> > (scanl' (+) 0 . map length) ["yasar","arabaci", "foo", "bar", "baz"]
02:44:30 <lambdabot>  [0,5,12,15,18,21]
02:44:40 <jle`> it adds an extra element at the end for you though
02:44:49 <jle`> > (init . scanl' (+) 0 . map length) ["yasar","arabaci", "foo", "bar", "baz"]
02:44:51 <lambdabot>  [0,5,12,15,18]
02:44:56 <jle`> might be a cleaner way to do this than with `init`
02:45:02 <jle`> *there might be
02:46:17 <merijn> Why scanl instead of fold?
02:46:33 <fvgvxmpv1> :t scanl
02:46:34 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
02:46:37 <fvgvxmpv1> :t fold
02:46:38 <lambdabot> (Foldable t, Monoid m) => t m -> m
02:46:48 <merijn> Well, foldl/foldr
02:47:00 <jle`> they want the list of intermediates
02:47:10 <merijn> jle`: So?
02:47:13 <merijn> :t foldl
02:47:13 <jle`> you could do it using fold too i suppose, but it might be a bit messier
02:47:14 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
02:47:18 <jle`> hm
02:48:09 <Aruro> how do i install agda on archlinux?
02:48:20 <Aruro> aur version seems to be broken
02:49:26 <Aruro> haskell-agda package is not there :(
02:49:29 <Aruro> hmhm
02:51:27 <igniting> Aruro: you can ask on #agda
02:52:40 <Aruro> igniting: ty, probably i can just attempt to build it from source
02:53:03 <igniting> there is no "cabal install Agda"?
02:53:16 <Aruro> there is cabal install agda-executable :)
02:54:40 <ollef> Aruro: have you 'cabal update'd?
02:54:50 <Aruro> yes
02:55:08 <Aruro> seems this is not correct what i wrote 
02:55:11 <ollef> Aruro: "cabal list agda" gives you nothing?
02:55:31 <mbuf> how do I render a json response with scotty to show { "text" : "Hello, World!"}; the examples I see return json $ ( "hello world" :: String ), but, that doesn't look like a JSON 
02:56:07 <Aruro> ollef: it does give me many packages , one of the is agda and another agda-executable
02:56:14 <Aruro> should i install agda first?
02:56:49 <ollef> Aruro: I _think_ agda-executable isn't needed anymore
02:56:54 <igniting> Aruro: Installing just Agda should be enough
02:57:04 <Aruro> ok, ty
02:57:04 <ollef> Aruro: just 'cabal install agda' should do it
02:57:24 <liste> mbuf scotty uses aeson for json rendering
02:58:14 <mbuf> liste, so how should the returned string be formatted?
02:58:37 <Aruro> cabal hell is real :D
02:59:01 <liste> mbuf you could use a Data.Map.Map or define your own data type
02:59:19 <liste> and define a ToJSON instance for that data type
02:59:36 <mbuf> liste, something that can be hard-coded for example?
02:59:38 <kqr> mbuf, do you want to return a json string or do you want to convert some data to json and then return that?
03:00:09 <liste> mbuf http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson.html here's help for that
03:00:47 <kqr> mbuf, if you just want to return a hard-coded string, you might do something like
03:01:07 <kqr> mbuf, return (text "{\"foo\": true}")
03:01:29 <kqr> mbuf, but that will set the content-type to text/plain
03:01:36 <kqr> mbuf, in case that's unwanted
03:03:28 <liste> mbuf you could also use direct aeson Values
03:03:46 <liste> for example json $ object ["foo" .= "bar"]
03:03:51 <mbuf> liste, okay
03:03:56 <liste> if you import Data.Aeson
03:05:51 <mbuf> liste, do I need to include any extensions?
03:06:12 <liste> mbuf OverloadedStrings (for Text literals)
03:07:13 <mbuf> liste, I get No instance for (ToJSON a0) arising from a use of `.=' 
03:07:32 <liste> mbuf you may need type annotations
03:07:43 <liste> object ["foo" .= ("bar" :: Text)]
03:08:14 <kqr> or NoMonomorphismRestriction?
03:08:56 <mbuf> liste, nice! works
03:08:59 <mbuf> liste, thanks!
03:10:48 <hashing> Hi all
03:11:06 <hashing> I don't understand why, in GHCi, "62.0 - 62" works but "62.0 - floor(62.2)" doesn't
03:11:39 <luzie> :t floor
03:11:40 <lambdabot> (Integral b, RealFrac a) => a -> b
03:11:47 <liste> hashing ghci doesn't know what type you want
03:12:40 <kqr> hashing, 62.0 is a float, while floor(62.2) is an integer, and it can't do maths on floats and integers together
03:12:54 <kqr> hashing, when you type 62 it actually secretly converts it to float
03:12:58 <kqr> hashing, for convenience
03:13:27 <hashing> Yeah, but why doesn't it convert float(62.2) ?
03:13:33 <hashing> Uh, floor(62.2)
03:13:36 <mniip> it's not a coercion
03:14:07 <kqr> hashing, it only converts literal numbers
03:14:16 <hashing> Ah, okay
03:14:18 <hashing> Makes sense
03:14:24 <kqr> hashing, when you say float(62.2) it assums you *want* an integer, but when you say 62 you might actually have meant 62.0
03:14:55 <mniip> 62 is of the type Num a => a
03:15:01 <mniip> 62.0 is of the type Fractional a => a
03:15:09 <mniip> which is a subclass of Num
03:15:26 <mniip> note that '62 - floor 62.2' does work
03:15:37 <mniip> because of this
03:17:19 <hashing> Hm, gotta understand types much better then
03:17:39 * hackagebot cndict 0.6.0 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.6.0 (DavidHimmelstrup)
03:18:23 <kqr> hashing, basically, when you type a literal 62 it can become any object which supports "Num" operations
03:18:46 <kqr> hashing, while 62.0 becomes any object which supports "Fractional" operations
03:18:54 <hashing> But floor(something) won't, because it's not a literal ?
03:19:20 <kqr> hashing, yeah, the floor function returns an object which supports the "Integral" operations
03:19:30 <hashing> Or because it's an Integral and won't be cast--- okay
03:19:52 <hashing> What would be the most elegant way to write the function, though ?
03:20:04 <hashing> turan a = [(n*a - (floor(n*a))) | n <- [1..100]]
03:20:39 <kqr> hashing, explicitly converting the integral type to a floating point number with the fromInteger
03:20:41 <kqr> hashing, is one option
03:21:07 <ronh> hashing 62 is Num a => a. if floor returned Num a => a 62.0 - floor(62.2) would work as well
03:21:10 <kqr> > 62.3 - fromIntegral (floor 62.2)
03:21:12 <lambdabot>  0.29999999999999716
03:21:21 <kqr> (mind the floating point errors heh)
03:21:24 <hashing> Ah, great !
03:21:47 <hashing> And what would the function's type be ?
03:21:57 <hashing> turan :: (Num a) => a -> [a]
03:22:14 <hashing> RealFrac instead of Num ?
03:22:45 <kqr> hashing, turan :: Float -> [Float]
03:22:48 <kqr> hashing, is the simplest option
03:22:57 <kqr> hashing, or similarly, turan :: Double -> [Double]
03:23:11 <kqr> hashing, if you want the most general type, you can ask ghci with :type
03:23:48 <kqr> Prelude> :t turan
03:23:50 <kqr> turan :: (RealFrac a, Enum a) => a -> [a]
03:23:52 <kqr> like so
03:24:08 <robin007bond> I made a simple recursive division function, without using the "/" operator. http://lpaste.net/131676
03:24:10 <hashing> Ohh
03:24:19 <robin007bond> Did I do good? I just started out with Haskell.
03:25:22 <arkeet> I don't understand this condition. (x < 0 || y < 0) && (x > 0 || x > 0)
03:26:26 <arkeet> and I don't think, e.g. divide 1 2 terminates
03:26:43 <robin007bond> arkeet: Hmm, Ok. It checks if one of the values is lower than zero, while also requiring that one of them is higher
03:27:05 <brbblnch> Hi. It's not possible to use the Data.List version of isPrefixOf on Text because Text isn't a list, right ?
03:27:09 <robin007bond> arkeet: You're right, it doesn't terminate. 
03:27:11 <arkeet> did you mean to put a y > 0?
03:27:36 <robin007bond> Oh yes, it was a typo.
03:27:36 <lpaste> arkeet annotated “No title” with “robin007bond” at http://lpaste.net/131676#a131677
03:27:42 <arkeet> you can put all the guards together like this
03:28:10 <robin007bond> Wow, that's a nice feature. 
03:28:12 <robin007bond> Thanks! 
03:28:13 <arkeet> okay, well I guess now you have to think about what divide 1 2 *should* be.
03:28:15 <arkeet> np
03:31:04 <kqr> brbblnch, correct
03:31:16 <kqr> brbblnch, but there is a Text version of the same function
03:33:32 <brbblnch> kqr: But isn't it possible to make Text an instance of List ? I guess the internal representation is a lot different, but from the outside, a string is a list of chars, no?
03:33:55 <arkeet> List isn't a class.
03:34:06 <arkeet> it doesn't make sense to say a thing is an instance of List.
03:34:16 <arkeet> a String is a list of Char.
03:34:19 <arkeet> a Text isn't a list of anything.
03:34:40 <arkeet> type String = [Char]
03:34:47 <kqr> brbblnch, you can convert it to a list of chars if you wanted to, but I do not recommend it
03:34:53 <ysr> is there a binary version of Text type. I mean I don't want to treat the file as Unicode array but a char array
03:35:00 <arkeet> what's a char?
03:35:04 <arkeet> there is ByteString if you want byte arrays.
03:35:06 <robin007bond> arkeet: Improved: http://lpaste.net/131676
03:35:06 <kqr> ysr, if by char you mean 8 bits, then yes, that's bytestring
03:35:19 <ysr> I mean 8 bit values
03:36:09 <brbblnch> arket: yeah ok
03:36:28 <cognub> Hello. 
03:36:50 <brbblnch> arkeet: But wouldn't it make sense to keep Text as [Char] from the outside, and simply work differently under the hood?
03:37:39 <kqr> brbblnch, yes and no
03:37:40 <arkeet> no, that doesn't make sense 
03:37:46 <arkeet> Text is a data type with a specific representation.
03:37:50 <arkeet> [Char] is a data type with a specific representation.
03:37:54 <arkeet> you can't pretend one is the other.
03:38:00 <kqr> brbblnch, what you really mean, is to make Text an instance of Traversable (or Foldable)
03:38:04 <kqr> brbblnch, which would be possible
03:38:06 <arkeet> what you can do is make a class that both types are instances of.
03:38:11 <kqr> brbblnch, but not necessarily a good idea
03:38:14 <kqr> brbblnch, for efficiency reasons
03:38:47 <merijn> kqr: Actually you can't make it traversable
03:38:49 <arkeet> and what you end up with is something like https://hackage.haskell.org/package/ListLike
03:38:51 <merijn> Kind error
03:38:59 <brbblnch> kqr, arkeet: ok, thanks
03:39:03 <kqr> merijn, ah
03:39:06 <kqr> brbblnch, also see what merijn just said
03:39:18 * frerich thinks kqr seems to be a pretty nice guy all-around and wonders whether he (kqr) works on some github project which he (frerich) could join :)
03:39:31 <merijn> Traversable and Foldable want types with kind "* -> *" and Text/ByteString are kind *
03:39:37 <kqr> I just realised that
03:39:42 <kqr> there's an extension for that, right?
03:39:53 <arkeet> no
03:39:56 <merijn> Nope
03:40:06 <merijn> I think there's monotraversable class in a library somewhere
03:40:10 <kqr> hm. yeah, never mind. i'm dumb :D
03:40:24 <arkeet> @hackage mono-traversable
03:40:24 <lambdabot> http://hackage.haskell.org/package/mono-traversable
03:40:32 <arkeet> there is also lens
03:40:34 <kqr> frerich, almost. there's one thing I'd really like to work on but my time is so tight these days
03:41:10 <frerich> I really need some project to work on *with others* because that's the only way I can maintain motivation over a longer period of time :-}
03:41:10 <cognub> I'm curious about if any of you have suggestions about a good language to learn after Haskell that allows you to bring over some Of your skills. Haskell was the first language I learned.
03:41:25 <arkeet> > over each (+5) (BS.pack [1,2,3]
03:41:26 <lambdabot>  <hint>:1:32:
03:41:27 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
03:41:29 <arkeet> > over each (+5) (BS.pack [1,2,3])
03:41:30 <lambdabot>  "\ACK\a\b"
03:41:39 <arkeet> > over each (+0x30) (BS.pack [1,2,3])
03:41:41 <lambdabot>  "123"
03:42:02 <arkeet> that maps a Word8 -> Word8 function over a ByteString
03:42:06 <hodapp> cognub: wellll, F# and Scala have some similarities...
03:42:31 <arkeet> (and `each` works on many things other than bytestrings
03:42:34 <kqr> frerich, https://github.com/kqr/hmenu
03:42:36 <kqr> frerich, check if you're interested
03:42:44 <arkeet> mono-traversable is fine if you don't like lens.
03:43:18 <hodapp> cognub: Frege is very Haskell-like but still rather new
03:43:26 <cognub> hodapp: hos commonly used are those languages in proffesional enviroments?
03:44:14 <hodapp> cognub: In other words, how average are they?
03:46:12 <hodapp> cognub: also, add Idris and PureScript to that list.
03:46:21 <cognub> hodapp: Not sure what that means, not my first language. How likely am I to use them in a job
03:46:45 <hodapp> cognub: I don't know. How likely *are* you to use them in a job?
03:47:34 <hodapp> cognub: you're not going to find very many code-monkey jobs with those as the target language, for instance.
03:50:16 <cognub> hodapp: I'm not sure hos to formulate my question vetter. I'll chech out your suggestions an think about what it is I acrually want to know. Thanks for the help!
03:50:53 <kqr> cognub, scala is probably the most haskell-like language that's not unheard of in the job market
03:51:13 <kqr> cognub, but if you're optimising for finding a job, looking at haskell-like languages might not be your best bet
03:51:31 <kqr> cognub, most jobs are for Java/C#/C++/Python/JavaScript devs
03:51:36 <lpaste> ysr pasted “combine files” at http://lpaste.net/131679
03:51:49 <ysr> can you check my paste please?
03:51:52 <lesshaste> I am trying run someone else's haskell code using ghc in ubuntu. It complains Could not find module `Data.HashSet'
03:51:58 <lesshaste> is that something standard one can install?
03:52:07 <jle`> lesshaste: you'd have to install it
03:52:22 <kqr> ysr, does it work? if so, it looks ok
03:52:24 <lesshaste> jle`, using apt-get install or is there a ghc installer?
03:52:27 <kqr> ysr, we're not your compiler!
03:52:30 <jle`> you can install it globally with `cabal install unordered-containers`
03:52:35 <kqr> ysr, if you have a specific problem, you can ask about that
03:52:40 * hackagebot persistent-postgresql 2.1.5 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-2.1.5 (MichaelSnoyman)
03:52:41 <jle`> or you can start a sandbox in a folder with cabal sandbox init; cabal install unordered-containers
03:52:53 <jle`> and then cabal exec (my command) to run your thing with the package in scope
03:53:15 <lesshaste> jle`,  thanks!
03:53:21 <jle`> np!
03:53:23 <ysr> kqr, I was just wondering if there was an obvious beginner mistake that I ve done.
03:53:49 <lesshaste> it needs 43 packages! :)
03:53:51 <liste>  /whois kqr
03:58:08 <cognub> kqr: Good to know. I'm not sure IF I am  optimising for a job yet, I've still got a minimum Of four years of education left. I'm not sure what my next step is so I'm mostly looking at possible paths forward
03:58:13 <aleator_> Is it safe to concurrently install to same cabal sandbox?
03:58:53 <aleator_> Or should I jump through hoops to get all my stuff under same cabal command and use -j?
03:59:29 <jle`> somehow i feel like that might be a bad idea
04:00:04 <ysr> so, B.writeFile overrides the file if it already exists. What is the safe way to to write to a file if it doesnt exist in Haskell
04:00:08 <merijn> kqr: I would argue that Scala is *very* unhaskell-like
04:00:25 <merijn> kqr: Albeit it one of the languages where it's easier to write haskell-like code in
04:01:57 <merijn> cognub: Ah, I missed your initial question. As for languages to learn after haskell. First off, if haskell was your first language and you feel moderately competent in it, you're in good shape already!
04:02:37 <merijn> cognub: I can suggest some languages, but I would advise against learning languages for the sake of being "in professional demand"
04:02:41 <ysr> I am guessing Python should be nice after Haskell. C would be a nightmare because of the type system
04:02:55 <merijn> python is TERRIBLE after haskell
04:02:59 <bartavelle> indeed
04:03:02 <merijn> I hate python now
04:03:02 <ysr> why do you think so?
04:03:21 <merijn> ysr: Because I don't know what anything is and I don't know where it's being changed
04:03:52 <merijn> cognub: I would actually recommend focussing on learning many different (as different as possible!) languages and understanding the underlying paradigms
04:04:10 <merijn> cognub: If you know a couple of weird languages, then picking up something boring like C#/java is a piece of cake
04:04:43 <merijn> cognub: Hell, despite being, supposedly, one of the hardest languages to learn I did an internship writing C++ without knowing C++ and was doing template meta-programming within 2 weeks
04:05:38 <ousado> C++ is never a piece of cake. 
04:05:46 <ousado> cognub: check out ocaml
04:05:49 <merijn> cognub: Some languages I'd recommend: Definitely C and/or x86 assembler, something lisp-y (Racket or Clojure would be good), prolog, rust, APL (or J)
04:05:56 <merijn> ousado: Too boring if you already know haskell
04:06:03 <merijn> ocaml and haskell are almost the same
04:06:04 <ousado> it's sufficiently different
04:06:36 <merijn> cognub: Smalltalk or something related wood be a good idea too
04:06:58 <igniting> ysr: check if the file exists?
04:07:14 <merijn> igniting: Nope
04:07:20 <merijn> igniting: TOCTOU race
04:07:31 <aleator_> I'd actually recommend sml. Small and not so different from haskell making it easy to learn, but enough different to give Haskeller a new perspective
04:07:37 <merijn> ysr: Open the file explicitly using the POSIX interface and error if it exists
04:08:21 <hodapp> aleator_: he's gone
04:08:53 <hodapp> and does anyone use SML for any use, except for Bob Harper when trying to criticize Haskell? >_>
04:09:00 <merijn> ousado: Where did I say C++ was piece of cake? I just said it wasn't difficult
04:09:13 <merijn> hodapp: Ur/Web is written in SML
04:09:25 <hodapp> is Ur/Web written by Bob Harper to criticize Haskell?
04:09:37 <merijn> hodapp: It's this need dependently typed ocaml/haskell hybrid for web development
04:09:41 <merijn> s/need/neat
04:09:56 <merijn> Row type polymorphism for records, etc.
04:11:34 <hodapp> Ur itself is written in SML?
04:11:44 <merijn> The Ur compiler, yes
04:12:05 <merijn> At least, I needed to install milton to build it, which is an SML compiler, so :p
04:12:20 <exio4> merijn: have you checked/heard of Dan Grossman's "Programming Languages" course? what do you think about it? 
04:12:41 <exio4> http://courses.cs.washington.edu/courses/cse341/13wi/  // https://www.coursera.org/course/proglang
04:12:47 <exio4> also, for anyone else out there :P 
04:13:02 <basiq> Is there a type like data X a = X that people actually use?
04:13:11 <ousado> merijn: you didn't explicitly say it, but you somehow implied anyone could "learn" C++ in 2 weeks after mentioning "piece of cake"-PLs, which is enough of an implication to that end for my taste
04:13:55 <hodapp> within 2 weeks? hell, I had compiler errors that it took my longer than 2 weeks to resolve at my last C++ job.
04:14:20 <peddie> basiq: Data.Proxy.Proxy
04:14:21 <hodapp> s/took my/took me/
04:14:24 <aleator_> basiq: Data.Functor.Constant.Constant also
04:14:57 <merijn> ousado: Assuming you know 5+ languages, including at least C and Java/C# I don't see why you'd need more than 2 weeks to start writing code in C++
04:14:59 <basiq> cheers peddie, aleator
04:15:14 <kqr> merijn, yeah, I don't mean to say scala is haskell-like, it's just more haskell-like than e.g. python
04:15:49 <exio4> well, knowing a static typed functional programming language makes learning haskell relatively easy
04:16:21 <hodapp> two weeks just to *start* writing code?
04:16:33 <merijn> ousado: I mean, I still don't understand what makes people claim that C++ is so hard compared to other languages...it just has a lot of syntastic noise
04:17:07 <saulzar> It's not particularly hard, there's just a lot of it - and lots of silly details
04:17:10 <merijn> hodapp: Well to be fair, I got dumped into >100k LOC codebase, so it takes a while to find your bearings enough to actually write code
04:17:29 <kqr> merijn, manual memory management is probably one of those things
04:17:40 <kqr> merijn, granted, modern C++ is more about RAII which I guess is simpler but still
04:17:40 <merijn> kqr: Right, but I was assuming knowledge of C
04:17:45 <kqr> ah
04:18:07 <kqr> I don't think anyone is claiming C++ is hard if you know C
04:18:10 <merijn> kqr: We were talking about a "knows multiple languages" scenario and that better include C imo
04:18:21 <saulzar> I'd say C gets you 0.1 of C++... the number of people who learn C and Java and start writing C++, not good.
04:18:29 <kqr> I think it's more about people who learned php and javascript and want to do "real" programming
04:18:32 <merijn> saulzar: Agreed
04:18:34 <hodapp> Okay, it's not "hard", but you will spend your time navigating mindless realms of crap and yak shaving.
04:18:50 <merijn> saulzar: C is to understand the memory bits, other languages are for the "knowing how to abstract" bits ;)
04:18:53 <kqr> where real programming = c++ because that's what all the pros use
04:18:59 <merijn> hodapp: C++11/C++14 aren't so bad
04:19:13 <merijn> hodapp: You even get to have lambda's!
04:19:13 <hodapp> merijn: compared to what, C++?
04:19:26 <kqr> hodapp, compared to most mainstream languages
04:19:32 <hodapp> ....oh
04:19:36 <merijn> hodapp: Compared to most languages that are not haskell :)
04:19:47 <kqr> you can easily do much worse than modern C++ if you stick to the mainstream
04:19:57 <kqr> well, C++ gives you the tools, at least. does not force you to use them
04:19:58 <exio4> merijn: well, if you know C, Haskell, Coq, Prolog, Smalltalk, Scheme and APL, I bet learning pretty much any anything will feel somewhat easy :p 
04:20:13 <merijn> I mean, manual memory management is a bit of a pain, but with std::shared_ptr and RAII it's not so bad
04:20:26 <hodapp> kqr: It only does not force you to use them in the sense that it doesn't actually force you to solve the problem.
04:20:28 <merijn> exio4: I haven't gotten around to Prolog, Smalltak, Scheme or APL :p
04:20:36 <merijn> exio4: And I only know a little bit of Coq
04:20:38 <saulzar> merijn, Yeah, which is why it's a mystery why people choose to make it so hard for themselves.. :)
04:20:55 <merijn> saulzar: Template all the things! \o/
04:20:58 <kqr> dang I can cross off 4.5 of the languages exio4 mentioned
04:21:15 <merijn> Actually, lemme stop being off-topic if there's any C++ experts I have a question in #-blah for you
04:21:47 <exio4> kqr: heh :P 
04:22:02 <saulzar> unsafePerformC++
04:22:11 <kqr> isn't that basically the FFI
04:22:23 <merijn> kqr: No, that's unsafePerformC
04:22:30 <hodapp> kqr: but, more or less, as soon as you start dealing with "real world code" and solving "real world problems", yes, it does force you to use said features, unless you simply don't want to try to abstract anything ever.
04:22:34 <kqr> :( joke destroyed on technical formality
04:22:49 <merijn> hodapp: Disagreed
04:22:50 <comodo_dragon> HASKELL IS ABSOLUTE GOBSHITE
04:23:13 <merijn> hodapp: I've written plenty of (high performance!) C++ using lambda's and std::shared_ptr
04:23:16 <comodo_dragon> fuck  HASKELL
04:23:29 <kqr> merijn, I think you misunderstood hodapp 
04:23:30 <comodo_dragon> punkass losers
04:23:30 <merijn> comodo_dragon: Thanks for your contribution, have a nice day. Preferably elsewhere
04:23:36 <lesshaste> argh Could not find module `Control.Parallel'
04:23:39 <merijn> @where ops
04:23:39 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
04:23:41 <lesshaste> how do I install that?
04:23:46 <merijn> lesshaste: Well, do you have the right package installed?
04:23:57 <kqr> lesshaste, cabal install parallel
04:23:58 <lesshaste> merijn,  I have never used ghc before.. so.. no :)
04:23:59 <hodapp> merijn: Wow, after that drive-by by comodo_dragon, I'm just... not sure I can take Haskell seriously anymore.
04:24:01 <kqr> lesshaste, preferably in a sandbox
04:24:12 <lesshaste> kqr,  thanks!
04:24:19 <merijn> lesshaste: Looks to be from the "parallel" package
04:24:22 <saulzar> hodapp, It was a convincing argument
04:24:34 <merijn> lesshaste: For future reference: https://www.haskell.org/hoogle/?hoogle=Control.Parallel
04:24:42 <hodapp> saulzar: I don't know what 'gobshite' is, but I have a feeling that that is a failing on my part.
04:25:15 <lesshaste> merijn,  thanks!
04:25:26 <saulzar> hodapp, Sounds a little British to me
04:25:35 <merijn> lesshaste: Incidentally, also works for searching type signatures, functions, and operators
04:25:52 <xelxebar> saulzar: you mean Bri'ish?
04:25:58 <funfunctor> @hoogle String -> Float
04:25:58 <lambdabot> Prelude error :: [Char] -> a
04:25:59 <lambdabot> Debug.Trace trace :: String -> a -> a
04:25:59 <lambdabot> Network.BufferType buf_fromStr :: BufferOp a -> String -> a
04:26:14 <funfunctor> @hoogle String -> Int
04:26:14 <lambdabot> Test.HUnit.Base Label :: String -> Node
04:26:14 <lambdabot> Test.QuickCheck.Test labelPercentage :: String -> State -> Int
04:26:14 <lambdabot> Prelude error :: [Char] -> a
04:26:40 <merijn> funfunctor: You can @hoogle in privmsg too
04:26:41 <saulzar> xelxebar, Yes, not quite the queens English :)
04:26:41 <funfunctor> Anyone well versed in HXT ?
04:27:06 <funfunctor> merijn: yes, sorry I was gearing up for a likely question..
04:27:43 <funfunctor> is there a readInt in HXT like so? smajor  <- readInt ^<< getAttrValue "SoftwareMajor"      -< x
04:33:00 <manjunaths> Hello
04:33:26 <manjunaths> I created a cabal sandbox and built a package from source
04:33:53 <manjunaths> When I run the binary I get an error Failed to load interface for 'blah.blah'
04:34:15 <manjunaths> Is there a LD_LIBRARY_PATH equivalent for haskell that I need to set to the local cabal directory ?
04:34:34 <srhb> manjunaths: I think that's usually due to missing module dependencies in the cabal file
04:34:40 <srhb> Or rather, exposed modules
04:35:07 <manjunaths> It complains about missing Data.Conduit.Shell, but I see that it is installed
04:35:22 <manjunaths> It is not installed globally though, only in the sandbox
04:35:45 <kqr> manjunaths, does the package have a dependency entry in the cabal file of the project?
04:36:18 <manjunaths> Yes
04:36:37 <manjunaths> I did a cabal build --dependencies-only
04:36:51 <manjunaths> So I think that is taken care of...
04:37:54 <mpickering> maybe you need to run "cabal configure"
04:38:44 <manjunaths> Hmm...I did that and I get the same error ?
04:50:01 <manjunaths> How to make a haskell build binary find the packages inside a cabal sandbox
04:51:01 <kqr> manjunaths, do you have the source for a dependency in a separate sandbox?
04:51:10 <kqr> manjunaths, if so, cabal add-source /path/to/other/sandbox
04:51:17 <manjunaths> I think I figured it out.
04:51:32 <manjunaths> There are some dependencies that I have to install separately
04:51:35 <manjunaths> hmm...
04:51:47 <manjunaths> Let me figure it out and get back to you....
04:54:01 <manjunaths> All the dependencies are installed in the sandbox
04:54:12 <manjunaths> The binary is built and it still complains
04:54:51 <manjunaths> What is the haskell equivalent of LD_LIBRARY_PATH ?
05:04:05 <tdammers> manjunaths: normally, your binary doesn't depend on the packages at runtime
05:04:50 <manjunaths> hell: Failed to load interface for 'Data.Conduit.Shell'
05:05:16 <manjunaths> tdammers, I am not sure what the above means ?
05:06:02 <tdammers> what I mean is that if you have successfully built your binary, it shouldn't have any runtime dependencies except maybe libc, libgmp, and any C libraries you talk to through FFI
05:07:08 <manjunaths> Ok.
05:07:49 <gremble> i.e. GHC statically links the modules that you import. I learnt that here earlier :)
05:09:04 <merijn> gremble: The problem is that most people coming to haskell seem to come from interpret/VM languages and thus don't quite understand linking and libraries, so such an explanation isn't always helpful
05:09:15 <manjunaths> I don't understand why it cannot load the interface.
05:09:52 <gremble> Oh. I come from C and have never worked with VM languages :x So to me it makes more sense. I understand what you mean though merijn 
05:10:28 <manjunaths> I will debug this tomorrow
05:11:00 <merijn> gremble: If you come from C it's easy, since it's basically exactly the same. GHC is perfectly capable of generating/accessing symbols from, e.g. C in libraries
05:12:38 <gremble> Yes that I saw. I was curious about the linking because if I build I binary, I don't know the the person running it has the haskell libraries installed, so I wanted to know whether haskell dynamically or statically links libraries
05:12:53 <gremble> Someone was nice enough to tell me that it is default behaviour
05:13:04 <gremble> for the GHC to statically link the imported modules
05:14:34 <merijn> gremble: If you want a completely standalone binary you will also have to statically link the runtime system
05:15:06 <gremble> Ah. How would you do that?
05:15:31 <jemu> hi, how can i write a utf-16 le file with byte order mark? do { hSetEncoding h utf16le; hPutStrLn h "Test"} writes utf-16 without bom, with the "utf16" encoding i get a utf16 be file with byte order mark.
05:16:40 <fvgvxmpv1> I want to write a tool to change some things in a mime email for use in unix pipes ( cat mail | changeThings | sendmail, or some such).
05:16:41 <fvgvxmpv1> Since the libraries I found on hackage to act on mime seem to me incompatible (mime parses to a type, mime-mail serializes from a different type) I would like to write my own parser and serializer using, preferrably uu-parsinglib.
05:16:41 <fvgvxmpv1> Now, since emails are big "things" need to be as lazy as possible, which leads to my question: how would I "interface" uu-parsinglib with pipes, such that at no point I need to concatenate the entire input in ram
05:16:46 <merijn> gremble: I don't know of the top of my head, I think you need -static as ghc argument and specify the location of the runtime library
05:17:03 <gremble> merijn: thank you though. I will go have a look at it ;)
05:17:06 <gremble> :)*
05:17:11 <merijn> fvgvxmpv1: I'm not sure uu-parsinglib can do incremental parsing, if it can't then you're boned
05:18:10 <fvgvxmpv1> it advertises "online parsing" which might be what I´m looking for
05:18:39 <Manas1484> Hi all, there's a very serious situation going on with a dear friend of mine. He's being threatened things are getting out of hand. I wan't to help him out by trying to stay one step ahead what people are planning to do. So I've been trying to figure out a way to get into their whatsapp accounts without installing an app on their devices. This should be simple I've been told. I do have a Mac Address of their devices.
05:19:25 <kqr> Manas1484, I'm going to guess europe, so go to the police
05:20:05 <Manas1484> Kgr: not enough evidences to go to the authorities.
05:20:44 <kqr> fvgvxmpv1, it appears as though the `parse` function in uu-parsinglib runs a parser on some input
05:21:27 <arw> Manas1484: in any jurisdiction I can think of what you are proposing is a crime. and sometimes even proposing those things is a crime. the only people in a position to help you are the police.
05:23:18 <frerich> Manas1484: Maybe whoever told you that it 'should be simple' can also tell you how to do it.
05:23:18 <Manas1484> I don't want to lose my friend or him getting hurt. So I need to do this.
05:23:49 <Cale> Manas1484: This discussion has nothing to do with Haskell and as such does not belong here.
05:24:52 <Manas1484> Ok thanks. I thought I was at the right place. First time here. I'll take this somewhere else.
05:26:24 <merijn> I wonder who keeps telling people to join #haskell to learn to "hack"
05:26:45 <arw> #hackskel?
05:27:43 <gremble> Have you read the syntax of this language? If that isn't hacking, then I don't know what is 
05:27:45 * hackagebot asn1-parse 0.9.1 - Simple monadic parser for ASN1 stream types.  http://hackage.haskell.org/package/asn1-parse-0.9.1 (VincentHanquez)
05:27:46 <gremble> :P
05:28:38 <arw> unfortunately there are a lot of different meanings to the word. yes, writing haskell is hacking. but so is turning soil in the garden...
05:28:38 <kqr> we even have a hack-agebot
05:28:49 <Guest84284> it does have "hack" in the title, in "Hackage status"
05:28:59 <Guest84284> so maybe these people just do "/list *hack*" or something
05:29:04 <kqr> good point
05:29:09 <bernalex> arw: pffft. hacking furniture and haskell isn't *that* different.
05:29:35 <kqr> hackage status sounds like a very jargon file-y way of telling someone how the hacking goes
05:29:58 <keko_> and then they understand nothing in the title text, so they figure it _must_ be about hacking!
05:30:12 <bernalex> kqr: I have used "hackage" in the same way as winnage or lossage or whatever.
05:30:23 <kqr> bernalex, exactly
05:32:16 <gremble> This is probably off-topic, but what is a nice reference to learn category theory? I'm a math undergrad and so far it looks like it could be interesting (from having taken a look at plato.stanford.edu's article about it)
05:32:29 <bernalex> gremble: do you know CS/programming?
05:32:36 <gremble> Yes
05:32:42 <bernalex> gremble: if so, I wholeheartedly recommend A Taste of Category Theory for Computer Scientists or whatever it's called.
05:32:58 <kqr> I recall a title similar to that which seemed really good
05:33:38 <bernalex> it's by Benjamin Pierce.
05:33:39 <Denommus> Hm, is LYAH in some repository I can contribute to? It needs a revision 
05:33:40 <merijn> gremble: Awodey's book
05:33:59 <merijn> gremble: There's also http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
05:34:16 <merijn> gremble: But for actual mathematicians Awodey and Mac Lane are better suited, I think
05:34:49 <merijn> Also, CT is always on topic here, else I'd have nowhere for people to explain Awodey to me when I get confused :p
05:35:55 <bernalex> most things are on topic here if they are peripherally related to haskell or learning haskell. at least during quiet hours.
05:39:40 <kqr> are these hours quiet hours?
05:40:50 <pavonia> Compared to other hours, yes
05:41:31 <kqr> i'm glad i'm not here other hours heh
05:43:18 <KaneTW> staistically, yes
05:44:17 <KaneTW> most quiet hours are around 6-7 gmt using my irc logs as a sample
05:45:13 <pavonia> Here's also a graphics on that http://ircbrowse.net/haskell
05:45:54 <srhb> Ooo, I'm spammy. top 10!
05:46:18 <merijn> srhb: High five!
05:46:22 <srhb> o/
05:46:30 <merijn> srhb: You could see when I was focussed on finishing my internship
05:46:40 <merijn> I dropped out of the top 5 for the first time in a long time >.>
05:47:18 <srhb> merijn: Pretty sure one can measure my courseload month by month as well.
05:47:50 <merijn> srhb: You're still at uni?
05:47:55 <srhb> Yep
05:48:29 <merijn> srhb: Looking to do a master project that involves writing compilers and type system stuff for functional languages? :p I'm trying to sucker someone into the work I don't have time for :p
05:48:54 <kqr> oh god
05:48:56 <kqr> I'm up there in that list
05:48:58 <kqr> how did that happen
05:49:13 <kqr> 23rd
05:49:19 <srhb> merijn: I wish, I still don't have my bachelors degree and I probably won't get one either (probably dropping out this summer :P)
05:49:25 <srhb> Otherwise yes!
05:49:29 <kqr> srhb, why dropping out?
05:49:35 <merijn> srhb: I can scale it down to a bachelor project :p
05:49:42 <merijn> And what kqr said
05:49:58 <srhb> kqr: Long term illness put me too far behind.
05:50:03 <kqr> ah that sucks
05:50:11 <kqr> I've temporarily dropped out due to economic concerns
05:50:22 <bitonic> I need to test a small Haskell program on a big endian architecture -- if anybody has can run some Haskell code on ARM I would be very grateful
05:50:34 <kqr> my next step is my bachelors, pretty much, but I'll wait a year or so with that to not go broke
05:50:42 <srhb> kqr: Good luck with that. :)
05:50:44 <kqr> thanks
05:51:53 <bernalex> pavonia: what's a "conversation"?
05:53:15 <bernalex> Cale is absolutely crushing it on the all-time stats at least.
05:53:45 <jackhill> bitonic: I can't do it on arm, but I can run haskell code on SPARC which I believe is big endian.
05:58:04 <pavonia> bernalex: I don't know
05:59:09 <pavonia> bernalex: I guess it's the number of messages
05:59:47 <bernalex> pavonia: isn't that what the "lines" are?
06:00:23 <bernalex> I would assume "conversation" is some kind of metric wherein if I type three msgs without anyone talking between me, it is only counted as one "conversation" or something like that. idk though.
06:00:37 <kqr> bernalex, lines = joins, quits, nick changes etc
06:00:42 <kqr> bernalex, conversation = privmsgs
06:00:47 <bernalex> kqr: oh right. that's stupid.
06:00:57 <kqr> (privmsg = general message, for people who are less irc protocol literate)
06:01:29 <bernalex> so we'll get more and more activity each year, since freenode seems to have more and more netsplits each year? :p
06:03:21 <pavonia> No, that's not conversation IIUC
06:04:11 <kqr> not conversation, but activity
06:05:28 <arkeet> but what if people commenting on netsplits counts as conversation?
06:07:38 <Aruro> > (+1+2) 3
06:07:40 <lambdabot>      The operator ‘+’ [infixl 6] of a section
06:07:40 <lambdabot>          must have lower precedence than that of the operand,
06:07:40 <lambdabot>            namely ‘+’ [infixl 6]
06:07:46 <Aruro> >(1+2+) 3
06:07:57 <Aruro> > (1+2+) 3
06:07:58 <lambdabot>  6
06:08:17 <Aruro> > (+2*3) 3
06:08:19 <lambdabot>  9
06:08:29 <Aruro> > (2*3+) 3
06:08:30 <lambdabot>  9
06:08:51 <Aruro> > (*(3+1)) 3
06:08:53 <lambdabot>  12
06:09:08 <solarus> Aruro: you can do /q lambdabot
06:09:15 <Aruro> :) i know :)
06:09:30 <Aruro> only in irssi somehow it does not work, only /query works
06:09:55 <mau|{e> Q          QUERY
06:10:03 <mau|{e> /Q is literally an alias for /QUERY
06:11:17 <Aruro> nope tells abiguous command
06:11:29 <Aruro> probably in newest version its not true anymore
06:12:14 <Aruro> there is also quote command
06:12:46 * hackagebot fst 0.10.0.1 - Finite state transducers  http://hackage.haskell.org/package/fst-0.10.0.1 (JohnCamilleri)
06:12:53 <kqr> but who uses irssi these days anyway
06:13:14 <Aruro> what do u use?
06:13:46 <KaneTW> i use weechat
06:13:52 <KaneTW> but irssi is fine too
06:14:15 <gremble> irssi is nice
06:15:37 <Aruro> KaneTW: so weechat has tmux'like interface right?
06:17:17 <Aruro> europe really has not that active haskell irc :) 
06:17:25 <Aruro> its visible when usa wakes-up 
06:17:57 <hashing> Speaking of that, anyone going to ZuriHac this year ?
06:18:03 <Aruro> i am :)
06:18:05 <kqr> I was mostly kidding, but yes, I do think weechat is like irssi except much better
06:18:30 <Aruro> i even hangedout a bit on #zurihac channel but seems inactive at the moment
06:18:31 <bernalex> hashing: I was. but when I was going to book there were no more spots left. =/
06:18:36 * luite__ will be at zurihac
06:18:43 <Aruro> cool
06:18:51 <Aruro> bernalex: there is waiting list
06:18:55 <Aruro> apply anyway
06:19:08 <Aruro> if someone quits you get their place
06:19:09 <bernalex> Aruro: ordering tickets to Switzerland is not exactly cheap here. especially on short notice.
06:19:19 <luite__> i hope i'll be recovered from the long flight from australia by then :)
06:19:21 <Aruro> i assumed you are in bern :D
06:19:34 <Aruro> oh man :) Australia is nice :)
06:19:41 <Aruro> when do u arrive in Zurich?
06:19:52 <Aruro> thursday?
06:20:23 <gremble> If I use HDBC, I can interface with Sqlite?
06:20:30 <Aruro> hashing: you got registration?
06:20:44 <gremble> It says standard SQL, but these days I don't know who does standard SQL anymore
06:20:46 <gremble> >x
06:21:19 <luite__> Aruro: I saw a kookaburra today! https://plus.google.com/102252268895890191681/posts/Q4MYPborbkd and an opera house: https://plus.google.com/102252268895890191681/posts/XDfb6h2Ft8J =)
06:22:07 <gremble> I can. Thanks guys :P
06:22:10 <kqr> are the zurihac presentations recorded? the tibbe one sounds really interesting
06:22:29 <luite__> Aruro: not sure yet
06:22:33 <Aruro> very fine pics! :) we have red kites swirling around every day :)
06:22:38 <hashing> Aruro, yup
06:22:54 <Aruro> kqr: they should be i guess
06:23:34 <hashing> I'm trying to grok as much Haskell as I can till then
06:23:57 <Aruro> hashing: good point
06:24:03 <hashing> (Not sure whether Haskell can be grokked, though :) )
06:29:55 <Ryanar> TIL : Grok means to understand so thoroughly that the observer becomes a part of the observed—to merge, blend, intermarry, lose identity in group experience. It means almost everything that we mean by religion, philosophy, and science—and it means as little to us (because of our Earthling assumptions) as color means to a blind man.
06:30:30 <Aruro> @all-dict grok
06:30:32 <lambdabot> *** "grok" wn "WordNet (r) 3.0 (2006)"
06:30:32 <lambdabot> grok
06:30:32 <lambdabot>     v 1: get the meaning of something; "Do you comprehend the
06:30:32 <lambdabot>          meaning of this letter?" [syn: {grok}, {get the picture},
06:30:32 <lambdabot>          {comprehend}, {savvy}, {dig}, {grasp}, {compass},
06:30:34 <lambdabot> [46 @more lines]
06:31:07 <gremble> Grok is interesting jargon :P
06:31:13 <Ryanar> When you claim to 'grok' some knowledge or technique, you are asserting that you have not merely learned it in a detached instrumental way but that it has become part of you, part of your identity. For example, to say that you "know" Lisp is simply to assert that you can code in it if necessary — but to say you "grok" LISP is to claim that you have deeply entered the world-view and spirit of the language, with the implication that it ha
06:31:14 <gremble> It comes originally from Sci-Fi
06:31:14 <Ryanar> s transformed your view of programming. Contrast zen, which is a similar supernatural understanding experienced as a single brief flash
06:31:29 <Ryanar> 1961 stranger in a strangeland
06:31:52 <Aruro> who wrote it?
06:32:14 <Ryanar> in that sense of the definition, for an imperative/object oriented programmer to enter the world of Haskell, you almost are certain to "grok" it, because learning pure functional programming just changes the way you think
06:33:11 <hashing> Wow
06:33:18 <Aruro> :) wow indeed
06:33:42 <Ryanar> its like riding a bike that is reversed https://www.youtube.com/watch?v=MFzDaBzBlL0
06:33:49 <Aruro> Ryanar: good stuff!
06:33:51 <KaneTW> Aruro: it's pretty customizable, you can get it to be similar to irssi or whatever else you want
06:33:57 <hashing> I assumed that 'to grok' meant 'to learn quickly'
06:34:38 <Ryanar> I dont remember the author
06:35:15 <mniip> Ryanar, interesting
06:35:25 <bernalex> hashing: interesting. I've always understood grok as the hacker jargon, which Ryanar summed up nicely.
06:35:26 <mniip> I too was merely guessing the meaning of the word grok
06:35:29 <geekosaur> Heinlein
06:35:48 <geekosaur> iirc literal meaning was "to drink deeply" or some such
06:35:57 <Ryanar> To understand intuitively or by empathy; to establish rapport with.
06:36:03 <Ryanar> from Oxford English Dictionary
06:36:28 <Ryanar> mniip, yeah its like re-establishing the neural pathways in your brain, as you grow older you have less neural plasticity so it is harder to do
06:36:32 <Aruro> Ryanar: its Heinlein
06:37:03 <mniip> Ryanar, now I have some fancy examples to use it in...
06:37:18 <lpaste> funfunctor pasted “No title” at http://lpaste.net/131684
06:37:43 <Ryanar> mniip, also interesting that once he could ride the bicycle with handlebars reversed, he could no longer ride it the normal way, until about 20 minutes in it just clicked and he could do it again. I drew some parallels to learning functional paradigm coming from an OO/Imperative perspective, at one point functional just clicked and I suddenly got it, and then going back to OO required some difficulty, though switching is getting easier
06:37:45 <funfunctor> Hi, I really need a hand getting going with the XML parser HXT in the above paste
06:38:08 <mau|{e> 0-1 is an interesting way to write -1
06:38:09 <Ryanar> also might be interesting to see how easily a child could learn a functional paradigm as compared to an adult who grew up learning OO
06:38:15 <mau|{e> also don't write -1
06:38:40 <funfunctor> I think I am most of the way to getting a chunk parsed out but I encounter type errors while trying to deal with the tree structure
06:38:46 <mniip> Ryanar, I know the guy you're talking about but you don't see you referencing it anywhere
06:38:51 <mniip> but I don't*
06:39:07 <mniip> ho
06:39:08 <mniip> nevermind me
06:39:10 <Ryanar> oh it was the video I linked earlier :P
06:39:12 <mniip> oh*
06:39:31 <mniip> can't type today
06:39:31 <Ryanar> Dustyn (sp?) from Smarter Every Day
06:39:57 <Aruro> Ryanar: he pulls handlebars too much too fast
06:40:05 <ggVGc> man, reading the learnyouahaskell chapter on applicative functors is twisting my brain a bit
06:40:09 <Aruro> Ryanar: you can ride bike almost not moving handlebars
06:41:05 <ggVGc> does it bother anyone else that C++/java etc. chose the word functor for something that has nothing to do with functors in functional programming?
06:41:25 <kqr> ggVGc, functor is a common word
06:41:31 <hodapp> ggVGc: yes.
06:41:37 <ggVGc> whenever I mention the word functor to someone not versed in FP, I have to correct myself because I know the semantics are not all wrong inb the other persons head
06:41:41 <kqr> ggVGc, functor means something else entirely in prolog as well
06:41:46 <ggVGc> oh
06:41:50 <ggVGc> kqr: what does it mean there?
06:41:53 <kqr> so just in programming, there are three different meanings of functor
06:41:56 <merijn> In ocaml too
06:42:07 <kqr> a functor in prolog is a truth relation between objects
06:42:12 <ggVGc> merijn: I thought ocaml and haskell had the same semantics for functor?
06:42:13 <arw> ggVGc: there are a lot of words that are misused that way. my favourite is "orthogonal" (i'm a physicist and I go nuts when people use it in any non-geometric sense)
06:42:37 <Aruro> @all-dict orthogonal
06:42:38 <lambdabot> *** "Orthogonal" gcide "The Collaborative International Dictionary of English v.0.48"
06:42:38 <lambdabot> Orthogonal \Or*thog"o*nal\, a. [Cf. F. orthogonal.]
06:42:38 <lambdabot>    Right-angled; rectangular; as, an orthogonal intersection of
06:42:38 <lambdabot>    one curve with another.
06:42:38 <lambdabot>    [1913 Webster]
06:42:40 <lambdabot> [76 @more lines]
06:42:48 <Aruro> mm
06:42:48 <ggVGc> arw: but isn't the daily use of orthogonal at least quite similar conceptually to the geometric sense? that's what I've always felt at least
06:42:50 <hodapp> my boss uses the word 'asynchronous' all the time to mean all sorts of things
06:42:55 <bernalex> ggVGc: usually there are legitimate etymologies for other lang's choices too. like monads & dyads in J versus monads in haskell.
06:43:03 <hodapp> sometimes literally to just mean 'synchronous' in some very convoluted way
06:43:07 <mniip> arw, what other word do you propose for two linearly independent properties of something?
06:43:09 <mau|{e> ggVGc: no, an ocaml functor is a parameterized module
06:43:14 <ggVGc> damnit
06:43:37 <arw> ggVGc: there is the "orthogonal == independent" use, which perhaps comes from "orthogonal vectors are linearly independent". 
06:43:44 <ggVGc> this makes it really hard to communicate programming concepts over language barriers
06:43:55 <Ryanar> Aruro, there is more to it, in the video he takes the bike to conventions where he talks and offers people $200 to ride the bike 10ft, people have tried every trick to get it just 10ft and never can
06:44:02 <bernalex> ggVGc: s/programming//
06:44:10 <bernalex> ggVGc: welcome to language. :)
06:44:24 <ggVGc> arw: oh, I never used it like that. I'd always use it as "things side by side" for a better way of expresing myself
06:44:27 <ggVGc> maybe that's wrong
06:44:27 <mau|{e> this is what design patterns
06:44:30 <Ryanar> Aruro, because normally balancing without touching the bars as the wheel moves in one direction you have to reverse your natural instinct I believe
06:44:43 <arw> ggVGc: problem is, orthogonal => linear independence. but linear independence =/> orthogonal
06:45:05 <Aruro> Ryanar: no, the wheel is ok only handlebars are reversing direction :)
06:45:21 <Aruro> Ryanar: thats why he did not show riding without touching handlebars
06:45:48 <Aruro> Ryanar: but i get it, handlebars is good brain train on its own
06:45:50 <ggVGc> arw: I still think orthogonal share a lot more etymology than functor in C++ and functor in haskell
06:45:51 <Ryanar> Aruro, ah I see, yeah I thought I would just ride without handlebars
06:46:08 <Ryanar> Aruro, but at some point you would need to presumably use your handlebars
06:46:13 <manek> Hello! :) Is there any simple example how to use Bound library in Haskell? I know that ekmett provides some examples in the github repository, but even the "simple" does not show just a very simple use case and has over 170 lines of code. I've read the "boud crash course" but now I need to practise using it on a very simple use case :(
06:46:30 <Aruro> Ryanar: thats true
06:47:24 <kqr> Ryanar, you can't ride without handlebars
06:47:30 <kqr> Ryanar, you need them to initiate a turn by counter-steering
06:47:37 <ggVGc> hodapp: have you ever told your boss he's being a bit asynchronous today? Or that you'll be doing some asynchronous work today by not coming into the office?
06:48:03 <hodapp> ggVGc: there's an idea.
06:48:25 <peddie> kqr: you really don't need handlebars to initiate a turn, but this probably belongs in #-blah
06:48:39 <Ryanar> hahaha yeah sorry guys for the derailing
06:49:00 <ggVGc> would you say you derailed the handlebars?
06:49:08 <kqr> peddie, how else would you do it?
06:49:19 <peddie> just lean!  I do it all the time :)
06:49:38 <bernalex> peddie: uh but torque
06:49:41 <frerich> Ryanar: That bike-riding video was really cool, thanks for sharing!
06:49:48 <mniip> arw, there's also use when describing an architecture, when there's no exceptions to some combining rule
06:49:52 <Ryanar> no problem :)
06:50:14 <Aruro> kqr: you can ride without handle bars, childhood proves it, and the fact that your turns will have big radius
06:50:16 <peddie> bernalex: what about it?
06:50:21 <mniip> for example in C# you can make something nullable, but you can't make a nullable nullable
06:50:41 <mniip> and that is unortogonal
06:51:06 <bernalex> peddie: without countersteering do you not just uh tip?
06:51:27 <Rotaerk> Nullable<Nullable<T>> works in C#
06:51:39 <Rotaerk> though that's only for value types
06:52:09 <bernalex> peddie: do you mean "you don't need to *use* the handlebars" rather than "you don't need handlebars"? because I'd believe the former all right.
06:52:17 <kqr> Aruro, very, very big, yes. tried riding along a curb and steering away from it? :)
06:52:38 <peddie> bernalex: handlebars and a stable steering system are different things :)
06:53:10 <bernalex> peddie: OK. we probably don't disagree then. that's how language works. people violently agreeing and not realising it.
06:53:10 <Ryanar> I am pretty sure if you lean with reversed handlebars to initiate a turn, the handlebars will turn in the reverse direction and you will probably fall off, but I am not sure, if it was the case then riding without handlebars isn't an option either
06:53:16 <mniip> Rotaerk, hmm, maybe I had some other language in mind
06:53:26 <peddie> bernalex: sweet :)
06:53:26 <kqr> Ryanar, yes, that's the idea
06:53:55 <mniip> Ryanar, on a bike you learn to turn the wheel in the direction you are leaning
06:54:22 <mniip> if you lean to the left but turn to the right you're going to flip over
06:54:31 <mniip> that's what happens then the handlebar is reversed
06:54:38 <peddie> haha where is ##dynamics when you need it
06:54:41 <Ryanar> yeah that makes sense
06:54:46 <kqr> mniip, technically you start by turning to the right briefly
06:54:51 <kqr> mniip, to shift the centre of balance
06:54:56 <kqr> mniip, *then* you turn sharply to the left
06:55:01 <Aruro> guys we should finish our spam with this : https://www.youtube.com/watch?v=Sm9j0S_dCZ0
06:55:10 <kqr> mniip, if you wouldn't, the bike would try to continue ahead and tip over
06:55:14 <Aruro> you dont need helmet though :D
06:55:39 <bernalex> peddie: I rather quite enjoy these whismical sidetracked discussions of #haskell. I especially enjoy the thought of people opening this channel for haskell help, going "lolwtf does haskell maybe mean something else too?"
06:55:40 <mniip> kqr, huh
06:55:47 <Ryanar> im laughing so hard at the tackniness of the video
06:55:53 <Aruro> :D
06:55:56 <mniip> I'm not sure what you're talking about
06:55:56 <Aruro> indeed
06:56:04 <Aruro> its important video :)
06:56:32 <Aruro> step 6 is what we were talking about here, leaning 
06:56:36 <mniip> you lean and then immediately turn in the same direction to counteract the changed direction of gravity with centripetal force
06:56:50 <Aruro> mniip: its in the video too 
06:57:06 <peddie> bernalex: I like dynamics, and I appreciate the humor that comes from surprising unsuspecting visitors -- I don't think it matters since we're not crowding out lots of real haskell questions
06:57:36 <peddie> but I would hope ##dynamics could clear up some confusion that #haskell doesn't seem to :)
06:57:52 <Aruro> its there? there is ##physics
06:57:58 <peddie> Aruro: no I just made it up
06:58:15 <kqr> mniip, sure, it's possible to initiate the turn by leaning instead of countersteering, but it's going to be a really wide turn
06:58:31 <Aruro> kqr: so you can drive like that only in usa :D
06:58:37 <kqr> lol yeah
06:58:58 <peddie> kqr: it's just a slow start to the turn, not a wide turn
06:59:07 <mniip> huh
06:59:21 <peddie> once you get a little angle it's easy to tighten it up
06:59:30 <kqr> hm, that might be possible
06:59:36 <mniip> if you turn the handlebar without shifting your weight you are going to be thrown off by the centripetal force
06:59:56 <mniip> otoh I haven't ridden a bicycle since february though
07:00:09 <mniip> my memory might be inaccurate
07:00:23 <peddie> I think you guys should install hmatrix-gsl and try to plot this
07:00:31 <kqr> but yeah, I find riding a regular bike backwards is hard enough
07:00:52 <Aruro> peddie: diagrams wont do?
07:01:04 * mniip wonders what kinds of modern gear system can be driven backwards
07:01:05 <peddie> Aruro: if you do the dynamics on paper, sure
07:01:24 <arw> mniip: no, it really works that way. but the destabilization by the centripetal force isn't as bad as it could be because of the gyroscopic stabilization that the rotation of your wheels provide you with.
07:01:35 <mniip> true but
07:01:42 <arw> mniip: thats also the reason why standing still on a bike is very hard, while driving is easier
07:01:47 <peddie> arw that force is insignificant on most bikes
07:01:50 <mniip> yes but
07:02:15 <arw> peddie: nack. it enables most people to ride a bike at all.
07:02:24 <manek> Hello! Does anybody have any simple examples for Bound library? I'm looking just for explanation on a small code snippet how to use it :)
07:02:28 <peddie> riding forward is easier because the wheel's contact patch is behind the steering axis, so your bike stabilizes itself
07:02:48 * hackagebot timerep 2.0.0 - Parse and display time according to some RFCs (RFC3339, RFC2822, RFC822)  http://hackage.haskell.org/package/timerep-2.0.0 (HugoGomes)
07:02:50 <mniip> peddie, try replacing your bike wheels with cartwheels and try riding that
07:02:52 <peddie> arw: tell me how much stabilization torque I can expect from riding at 20 km/h?
07:02:58 <Aruro> ok everybody who mastered handsfree bike riding next step is this: https://www.youtube.com/watch?v=u-hDEEl67_Y
07:03:27 <srhb> What's with the bike spam?
07:03:44 <srhb> :D
07:03:57 <mniip> discussing groking, and in turn learning and unlearning
07:04:13 <mniip> and in turn why is it hard to ride a reversed handlebar bike
07:04:43 <SrPx> Okay who made that bot that favorites every single haskell tagged question on SO immediately ?
07:05:00 <Aruro> genius
07:05:45 <Ryanar> that is genius
07:05:48 <Ryanar> lets make more of them
07:05:52 <Ryanar> repo to clone?
07:06:04 <SrPx> oh my
07:06:23 <Aruro> yes from different ip's
07:06:39 <arw> peddie: not a lot, true. but its noticable.
07:06:50 <Ryanar> theres ~1600 of us here, that is a lot of favorites :D
07:07:18 <Aruro> insta 1500 likes, not bad
07:07:32 <Aruro> maybe one dislike for honesty
07:07:36 <peddie> arw: you may feel the angular momentum if you are travelling quickly, but that's not what's primarily stabilizing it :)
07:08:01 <SrPx> oh now it is fine
07:08:02 <Aruro> peddie: you will be surprised but bike physics is not simple at all
07:08:13 <peddie> Aruro: I'm not surprised, I've studied it a lot
07:08:29 <Aruro> peddie: there are articles in physics today on the possible types of bikes
07:08:36 <Aruro> peddie: o then you know :D
07:08:40 <mniip> [17:06:51] <Aruro> insta 1500 likes, not bad
07:08:44 <mniip> free reputation
07:22:32 <tulcod> so this recursive do code, after a few seconds, errors out with "test.hs: thread blocked indefinitely in an MVar operation". i get that it isn't supposed to work, but why does it even compile, and what is going on behind the scenes? http://lpaste.net/131687
07:23:45 <MagneticDuck> can anybody reccomend me a way to learn elerea?
07:24:05 <merijn> tulcod: Why would it not compile?
07:24:15 <tulcod> because it doesn't make sense
07:24:37 <tulcod> "first output some variable, then find out what its value is supposed to have been"
07:25:08 <merijn> tulcod: That's only a problem in this specific case of IO
07:25:18 <tulcod> but it is a problem
07:25:46 <hjulle> Why is this leaking memory? "last [1..10e7]"
07:26:26 <tulcod> hjulle: it's probably not "leaking" memory, just using a lot of it because haskell is a lazy language and constructs a shitton of thunks before it can give you the output
07:26:26 <merijn> tulcod: The only problem here is "if I want impossible things it doesn't work"
07:27:08 <tulcod> merijn: yes i understand it's not supposed to work, but what is going on behind the scenes? how is this implemented? when *can* i get guarantees this is supposed to work?
07:27:29 <tulcod> "this" meaning "recursive do"
07:28:00 <merijn> tulcod: It's supposed to work if the IO action can partially return before running it's effects
07:28:33 <tulcod> what does "partially return" mean?
07:28:40 <merijn> tulcod: It's syntactic sugar for MonadFix, so maybe you want read the thesis mentioned here: https://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Monad-Fix.html#v:mfix
07:28:51 <tulcod> i did :-/
07:29:01 <tulcod> oops no not the thesis
07:29:17 <merijn> tulcod: Well, I mean that in the same way as
07:29:22 <merijn> > fix (1:)
07:29:23 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
07:30:02 <merijn> Since part of the result of infinitely applying (1:) is already know, we can start consuming the result before "finishing" the infinite recursion
07:30:12 <tulcod> merijn: you mean in terms of guarded recursion?
07:30:28 <merijn> I'm not familiar with the term "guarded recursion"
07:31:02 <merijn> tulcod: Oh, actually the wiki page has a useful example
07:31:08 <merijn> Consider the following
07:33:22 <merijn> Actually, let me just link it
07:33:25 <merijn> https://wiki.haskell.org/MonadFix
07:34:12 <tulcod> merijn: where on this page?
07:34:29 <mniip> neat trick: zipWith const, truncate one list to the length of another
07:34:30 <Aruro> anybody knows beautiful fix examples?
07:35:07 <merijn> tulcod: The doubly linked list one
07:35:34 <OutlawStar> question: If I have a monad that makes use of IO which uses MonadThrow, do I need to make my monad an instance of MonadThrow as well so that exceptions work?
07:35:39 <tulcod> merijn: i don't see how this is relevant to my question
07:36:27 <mniip> Aruro, fix $ (1:) . join (zipWith(+) . (1:))
07:36:34 <merijn> > let fixMap = fix (\mapLambda f l -> case l of [] -> []; (x:xs) -> f x : mapLambda f xs) in fixMap (+1) [1..10]
07:36:36 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
07:37:13 <tulcod> Aruro: every recursively defined pure function can be written as the fix of some recursion-free function, iirc
07:37:27 <merijn> tulcod: Then I don't understand your question
07:37:44 <tulcod> merijn: how is MonadFix implemented for IO and when am I guaranteed it works?
07:38:22 <merijn> tulcod: https://hackage.haskell.org/package/base-4.8.0.0/docs/src/System-IO.html#fixIO
07:38:59 <merijn> tulcod: And it works if 'k' can produce output without forcing the argument it takes
07:39:10 <hjulle> tulcod, Isn't that what you usually mean by "leaking" in the context of haskell? The problem itself only needs constant memory. (And if I compile it with ghc -O, it only uses constant memory)
07:39:46 <merijn> hjulle: Right, so your problem is "if I compile without optimisations my code is slow/uses a lot of memory"?
07:40:33 <hjulle> I had some similar code which still leaked with optimizations on.
07:41:06 <merijn> tulcod: The "takeMVar" won't happen until the 'ans' thunk is evaluated (due to unsafeInterleaveIO), so as long as "k ans" produces a result that gets written into the MVar before it forces it's input argument it works
07:42:13 <merijn> tulcod: Hence, you get the "blocked indefinitenly on MVar" error if you *do* force the argument, because you're trying to read from an empty MVar that can only be filled after your read finishes (i.e. will never happen)
07:42:32 <tulcod> merijn: and why does that take a while (seconds)?
07:42:51 <merijn> tulcod: Because it won't happen until GC notices that the MVar is unreachable
07:43:07 <kqr> aaaah *that's* how the runtime detects things like that. clever
07:43:20 <merijn> The blocked indefinitely error isn't guaranteed to happen, since turing completeness means you can't always decide that
07:43:36 <inaoel> Is it considered bad form to do something like `type A = Int -> Char; foo :: Double -> A`?
07:43:43 <kqr> inaoel, no
07:43:49 <merijn> kqr: It's simple, if someone is blocked on a read AND there are no further references, it must blocked indefinitely
07:44:19 <frerich_> inaoel: Not at all
07:44:22 <tulcod> merijn: so the GC can decide it because it somehow compares the states of all threads?
07:44:29 <merijn> kqr: I believe blocking on a read let's go of the reference, so you only need to detect "ref count == 0" and then async except all blocked threads when you GC the MVar
07:44:59 <hjulle> But mostly my problem is "This code snippet is using lots of memory and I do not know why". My guess was that it is allocating memory faster than the gc can release it, but then it should settle eventually, not continue to grow unboundedly.
07:45:19 <merijn> tulcod: Once it decides to garbage collect the MVar due to lack of references it async interrupts all blocked reading threads with "sucks to be you, you're hanging indefinitely"
07:45:52 <kqr> merijn, yup. I just had never considered that
07:45:53 <tulcod> merijn: thanks :)
07:46:12 <merijn> hjulle: Unlikely, if there's anything the GHC is good at it's releasing memory fast. A lot of programs can have allocation rates measured in Gb/s
07:46:34 <inaoel> kqr, frerich_: I thought it might be a little misleading in terms of number
07:46:34 <inaoel> of arguments expected
07:47:02 <kqr> inaoel, not if it's made clear that a value of type A needs an argument
07:47:03 <merijn> inaoel: I would says it's not *necessarily* bad, but that specific example would be :)
07:47:15 <kqr> inaoel, I was assuming A was just a metasyntactic variable
07:48:17 <inaoel> okay, thaks
07:48:30 <S11001001> @remember merijn if there's anything the GHC is good at it's releasing memory fast.
07:48:30 <lambdabot> I will never forget.
07:48:51 <merijn> tulcod: Of course it's possible to deadlock in undetectable ways, consider two MVars A and B and two threads having references to both and each thread reading from the other MVar
07:49:12 <merijn> tulcod: Now every MVar has a live reference even though they're both clearly deadlocked.
07:49:32 <merijn> So the exception is more of a courtesy, like the <<<loop>>> exception then something to rely on
07:49:37 <hjulle> Aha, last uses foldl. That explains it. http://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-List.html#last 
07:49:46 <merijn> Wait, really?
07:49:52 <merijn> Wut?
07:50:11 <hjulle> "-- use foldl to allow fusion"
07:50:13 <kqr> I love that USE_REPORT_PRELUDE is the slow version everywhere except last, apparently
07:50:28 <merijn> kqr: Hard to say, depends on how rules interact with foldl
07:50:37 <hjulle> It is the slow version if you have enabled optimizations.
07:50:58 <merijn> That's dumb...
07:51:26 <hjulle> s/It/USE_REPORT_PRELUDE/
07:51:38 <nshepperd> i would have thought they would optimize into the same thing
07:51:55 <ggVGc> so, is there any fundamental difference between type classes and structural typing? To me it seems basically the same thing?
07:53:03 <mizu_no_oto> ggVGc: there's one pretty important difference between OO and typeclasses: with OO the methods are bundled with the data, but typeclasses move methods to a companion 'implementation dictionary'
07:53:30 <halvorg> how do I compare two LocalTime values?
07:53:54 <halvorg> I want to see if their difference is larger than some amount of hours.
07:54:26 <mizu_no_oto> ggVGc: this means that you can call typeclass methods without actually having a value of whatever type lying around
07:54:51 <ggVGc> hmm, not sure I understand.. I'll have to think about it some more
07:55:07 <ggVGc> mizu_no_oto: could you give me a minimal example of what you just said?
07:55:18 <mizu_no_oto> For example, what would the structually subtyped equivalent of 'read "1.0"' or 'fromInteger 5' look like?
07:55:35 <mizu_no_oto> 'read 1.0' is a value of type Read a => a
07:56:07 <mizu_no_oto> if you say 'read "1.0" :: Integer', it will try to parse it into an Integer
07:56:11 <kqr> halvorg, perhaps by converting to utctime, adding with timediff and then converting back?
07:56:36 <mizu_no_oto> 	if you say 'read "1.0" :: [Double]', it will try to parse it into a List of Doubles
07:56:39 <kqr> halvorg, with utctime you have the luxury of diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime
07:57:19 <nshepperd> halvorg: you probably want to convert it into some kind of wall clock time
07:57:20 <mizu_no_oto> ggVGc: so you can think of it as giving you 'return type polymorphism' or 'polymorphic values'
07:57:30 <nshepperd> "seconds since the epoch" or whatever
07:57:41 <nshepperd> just from a "handling time sensibly" point of view
07:58:04 <funfunctor> HXT is really hard to get ones head around..
07:58:05 <mizu_no_oto> ggVGc: mempty is another good example.  mempty :: Monoid m => m
07:58:20 <nshepperd> I don't know if or how the libraries support that though
07:58:21 <halvorg> kqr: looks smart, ill look into that.
07:58:55 <mizu_no_oto> ggVGC: so I can say something like 'foldl (<>) mempty :: Monoid m => [m] -> m' 
07:59:04 <kqr> halvorg, generally you want to only deal with UTCTimes inside your application, and convert to LocalTime at boundaries with the user
07:59:05 <ggVGc> hm, thanks
07:59:17 <ysr> I was reading about some other functional programming languages, they all call their standard library prelude. Anyone know where does it originate from?
07:59:26 <ggVGc> mizu_no_oto: I'll kepe this in mind and run it in my head for a while :) It hasn't really clickde for me yet
07:59:34 <kqr> mizu_no_oto, I tried to explain that to a friend recently. very difficult
07:59:44 <kqr> mizu_no_oto, he kept on saying "sure but that's just the type inference in haskell"
07:59:45 <luzie> or TAI if possible but I dunno if any Haskell libs do that
07:59:47 <kqr> mizu_no_oto, and I was sad :(
08:00:42 <frerich_> halvorg: It seems to me that given two LocalTime values, you can use 'timeOfDayToTime . localTimeOfDay' to get a DiffTime for each - and those can be subtracted
08:01:33 <frerich_> halvorg: You get a result in seconds, which 'timeToTimeOfDay' turns back into a TimeOfDay (out of which you can get the hours)
08:01:51 <mizu_no_oto> ggVGc: basically, something like Monoid m => m means that if you give me an implementation dictionary for monoids on m, then I can give you an m
08:02:03 <frerich_> Everytime I look into Data.Time I'm amazed at home complicated dealing with time stamps can be...
08:02:14 <orion> Hi. In Aeson, how do I deserialize an object of sums as opposed to an object of products? Basically I have a "Response" type which can either be a "Result" OR an "Error" but not both. I am struggling to determine the best way to write the FromJSON instance for this type.
08:02:16 <mizu_no_oto> ggVGc: the language itself controls creating and passing that dictionary
08:03:01 <mizu_no_oto> ggVGc: and the interesting side effect is that unlike in something like Java, the type ascribed to a term can actually change the value of the term
08:04:15 <mizu_no_oto> because the type ascribed to the term determines which implementation dictionary you ultimately end up using
08:05:53 <grizwako> hey guys, is xmonad good haskell code to study?
08:06:00 <luzie> no
08:06:05 <grizwako> http://code.haskell.org/xmonad/src/XMonad/Core.hs
08:07:14 <grizwako> any projects that are "recommended" for newbies to read a little bit?
08:07:47 <frerich_> Does anybody know why defining 'repeat x = xs where xs = x : xs' is preferrable over 'repeat x = x : repeat x'? Something to do with inlining or so?
08:08:22 <creichert> grizwako: what is your experience level?
08:09:01 <creichert> that XMonad source file is fine to study imo, btw
08:09:11 <flux> frerich_, I don't know, but I guess the former creates a loopy data structure, but the latter evaluates repeat x, well, repeatedly
08:09:16 <kqr> frerich_, sharing is what I've heard, but I can't give you details
08:09:25 <grizwako> mid/senior, mostly dynamic langs (python and php..), did first scala course on coursera relatively easy
08:09:31 <nshepperd_> grizwako: there's a good answer on SO about this http://stackoverflow.com/questions/6398996/good-haskell-source-to-read-and-learn-from
08:09:55 <tdammers> frerich_: I'd stammer something about local scope and optimization if asked in an interview situation
08:11:00 <grizwako> i would prefer something that i can use, than i have motivation for playing with source
08:11:53 <nshepperd_> frerich_: the first one "ties the knot" resulting in a single circular list
08:12:05 <creichert> grizwako: the XMonad source you linked is good. GND (generalized newtype deriving) is still very common practice
08:12:18 <creichert> read Prelude, I like the Propellor source code as well
08:14:49 <grizwako> ok, tnx
08:15:24 <nshepperd_> frerich_: so 'let y = repeat1 x in ...' only ever allocates one list constructor
08:15:28 <creichert> Haskell libraries can be very readable, so if you are writing an app definitel take a look at anything in your cabal depends sections
08:16:08 <nshepperd_> frerich_: whereas 'let y = repeat2 x in ...' could allocate arbitrarily many list constructors, depending how y is used
08:16:27 <nshepperd_> (assuming repeat1 is your first definition, and repeat2 is the second one)
08:20:43 <funfunctor> Is there something simpler than HXT I can use to deal with XML in Haskell, HXT is just too confusing for me
08:21:15 <creichert> funfunctor: have you tried xml-conduit?
08:21:21 <frerich_> nshepperd_: Ah, interesting. I resorted to asking on StackOverflow ( http://stackoverflow.com/questions/29947951/why-is-repeat-defined-using-a-local-definition ), let me digest your exlpanation - I'm not quite sure I get it yet...
08:21:41 <frerich_> Oops, a duplicate.
08:22:07 <creichert> funfunctor: it *might* have a non conduit based interface as well
08:22:19 <ggVGc> mizu_no_oto: hm, why did you mention java? Java doesn't have structural typing afaik. To me structural typing means what i.e F# has(and I think OCaml by extension)
08:23:01 <mizu_no_oto> ggVGc: the same comment applies to almost every statically typed language
08:23:22 <frerich_> flux, kqr, tdammers: The answer seems to be http://stackoverflow.com/a/16632403/91757 (to avoid potential stammering in future interview situations)
08:23:31 <mizu_no_oto> In most statically typed languages, types and semantics are orthogonal
08:23:44 <funfunctor> creichert: nope but I find Snoyman's design choices a bit confusing sometimes
08:24:02 <mizu_no_oto> in Haskell, semantics depends on type information
08:24:15 <kqr> frerich_, does not help my stammering, unfortunately, becuase I have no idea why one would tie the knot when the other wouldn't :(
08:24:18 <creichert> funfunctor: yea, that thought occurred to me only after I recommended it
08:24:23 <funfunctor> creichert: can you help me resolve a type issue, maybe I can work out HXT..
08:24:43 <ggVGc> mizu_no_oto: hmm, I guess a better question is the difference between interfaces(i.e java) and type classes
08:24:49 <mizu_no_oto> I remember edwardk calling this distinction "typing a la Curry vs typing a la church"
08:24:50 <kqr> frerich_, about that much I knew already, but I have no idea why and the technicalities behind it
08:25:21 <creichert> funfunctor: I can try
08:25:32 <funfunctor> creichert: thx! been stuck for hours.. http://lpaste.net/131691
08:25:35 <mizu_no_oto> ggVGc: the difference is the same between interfaces and typeclasses as structural typing and typeclasses
08:25:36 <Denommus> whoa, HXT seems awesome
08:26:01 <mizu_no_oto> ggVGc: try to define a Num interface in Java and use it
08:26:05 <ggVGc> mizu_no_oto: yeah.. but I still don't completely understand what you've told me, sorry :( Anyway, I'll think about it some more. Thanks for your explanaitions1
08:26:08 <ggVGc> !
08:26:17 <funfunctor> creichert: and this is the XML I am trying to parse http://lpaste.net/131692
08:26:27 <mizu_no_oto> ggVGc: you'll run into issues with the fromInteger function
08:26:36 <mizu_no_oto> and things will hopefully click
08:27:05 <funfunctor> Denommus: I agree, HXT has a excellent design! I am just having trouble resolving type issues
08:28:10 <kqr> mizu_no_oto, didn't click for me when I tried going that way :(
08:28:13 <frerich_> kqr: I think the key is that in '(:) a b' you create a thunk. So far, so good. The interesting thing is what 'b' is. In 'repeat x = x : repeat x', the compiler doesn't realize that the recursive 'repeat x' application can actually reuse the same thing it's currently defining. Instead, it builds a new thunk and references that. In 'repeat x = xs where xs = x : xs', the compiler is basically force-fed that the second argument to (:) is ac
08:28:13 <frerich_> tually the exact same thing being defined, which makes it generate a circular reference instead.
08:28:45 <mizu_no_oto> kqr: what caused it to click for you?
08:28:52 <kqr> frerich_, ahhh yeah that makes a ton of sense
08:28:55 <kqr> mizu_no_oto, hasn't clicked yet
08:29:08 <kqr> mizu_no_oto, I know the words to describe it, but no grokking has occurred
08:29:14 <frerich_> kqr: I think this is because the function application in 'repeat x = x : repeat x' itself is a "new" thunk, i.e. the inner 'repeat x' needs to be evaluated separately.
08:29:23 <funfunctor> creichert: I have the core data structures in place there and the XML isn't all that complex
08:29:48 <kqr> frerich_, yup. it's the same thing as people asking why two applications of "reverse [1, 2, 3]" don't point to the same thunk
08:29:48 <ggVGc> mizu_no_oto: so, what I'm thinking is that with interfacesyou could define something as being equatable, meaning it has an equals function basically. So how is that difference from the eq type class?
08:30:04 <kqr> frerich_, I guess it can with the right optimisation which I've forgot the name of, but maybe not by default? I don't know
08:30:25 <mizu_no_oto> ggVGc: that part of it is the same
08:30:32 <ggVGc> oh
08:30:34 <ggVGc> right
08:30:36 <frerich_> kqr: Yep, I think that's the reason. Maybe one could argue that in 'repeat x = x: repeat x' the compiler could just "see it" but well, the people working on the compiler are probably way smarter than me and there are good reasons for why this is not feasible or practical
08:30:40 <creichert> funfunctor: and it doesn't compile for you?
08:30:47 <ggVGc> mizu_no_oto: so, hm, how do I stumble upon the thing where "oh here I need type classes"
08:31:04 <funfunctor> creichert: no
08:31:05 <kqr> frerich_, yup, I can accept that
08:31:09 <mizu_no_oto> ggVGc: Look at Read, for example
08:31:26 <frerich_> kqr: I guess it boils down to 'definitions are shared, function applications are not'
08:31:53 <mizu_no_oto> ggVGc: Basically, some typeclass methods are polymorphic on the return type.  You can't do that with interfaces.
08:31:56 <kqr> frerich_, the optimisation I was thinking of is called common subexpression elimination, which might or might not work so well on definitions
08:32:06 <creichert> funfunctor: i think you have naming conflicts in your record definitions. for exampl, you have multiple records with a 'name' field
08:32:13 <funfunctor> creichert: I just want to create a typed AST tree of whats in the XML document and then print out one of the nodes as a test
08:32:38 <ggVGc> mizu_no_oto: oh, hm, I thin ksomething is starting to form in my head now. thanks!
08:32:39 <creichert> the easiest way out, initially, is to prefix record fields.
08:32:44 <funfunctor> creichert: oh, sure I can fix all that.. I just wrote those structures, you can comment them out if you want
08:32:48 <creichert> ah
08:32:57 <creichert> just checking :)
08:34:45 <frerich_> kqr: That makes me wonder whether ther eis a tool which can generate those pretty thunk graphs out of Haskell source code automatically :-)
08:34:46 <mizu_no_oto> ggVGc: You can actually do something like Read in Java.  You'll just need a type signature like 'A read<A>(String s, Read<A> manuallyThreadedImplementationDictionary)'
08:35:00 <nshepperd_> frerich_: I think you're basically right
08:35:22 <funfunctor> creichert: ok I fixed them http://lpaste.net/131691
08:35:27 <nshepperd_> a (monomorphic) let binding creates a single thunk, where future references refer to that *same* thunk
08:35:35 <mizu_no_oto> ggVGc: But you can't do something like 'class Foo extends Read<Foo>'
08:35:53 <mizu_no_oto> because you won't have a Foo around when you want to call read
08:36:04 <mizu_no_oto> You get the Foo *from* calling read
08:36:10 <kqr> nshepperd_, monomorphic and not a function? I guess
08:36:18 <funfunctor> creichert: I probably don't need all those getters/putters but I just made them any way because its useful for testing
08:37:44 <ggVGc> mizu_no_oto: yeah, it's starting to make some sense now. But it feels very much like interfaces are basically special cased type classes
08:38:34 <nshepperd_> kqr: well, "let f x = ... in (f 1, f 1)" won't share "f 1", yes
08:38:43 <kqr> nshepperd_, yeah, that's what I thought
08:39:04 <kqr> ggVGc, you can view them a little like typeclasses but where the implementation dictionary is bound to the object they belong to, rather than able to exist freely
08:39:07 <mizu_no_oto> ggVGc: the other big difference is that you can add functionality to an already existing data type using typeclasses, but with interfaces/structural subtyping, you can't
08:39:11 <nshepperd_> kqr: it's not that the rules are really different for functions though, "f" itself is indeed shared, but applying f to things follows the normal rules
08:39:54 <kqr> nshepperd_, ah so when you say "a monomorphic let binding" you mean just the f, in that case?
08:40:04 <nshepperd_> yeah
08:40:07 <kqr> very cool
08:40:10 <kqr> I might be able to remember that now :D
08:40:16 <frerich_> Yeah, me too :-)
08:40:30 <kqr> and not stammer in whatever interview someone throws at me
08:40:32 <frerich_> I think I never realied how much of a runtime, performance, difference where or let bindings can make.
08:40:39 <ggVGc> mizu_no_oto: aha! that is a big difference and now I see that :) I actually had that epiphany a few years ago when dabbling in F# and wanting to do it
08:40:42 <ggVGc> but couldnät
08:40:53 <ggVGc> thanks a lot
08:40:58 <ggVGc> I think I get it now
08:40:58 <mizu_no_oto> ggVGc: Also, conditionally available methods are hard to do with interfaces.  For example, it's easy in Haskell to define a method on lists to sum it if it contains any Num type.  This is difficult to do with structural types
08:41:04 <mizu_no_oto> Great!
08:41:14 <ggVGc> mizu_no_oto: it makes sense to me now what you say about type classes being able to exist without any instance of them
08:41:27 <kqr> frerich_, there are so many little things you can do to get a lot of performance out of haskell but I'm really bad at knowing what. that's why I thought tibbes zurihac presentation sounded so interesting! shame I'm not there
08:41:30 <ggVGc> while interfaces only exist as part of real instances
08:41:52 * nshepperd_ hopes not to be asked about details of ghc evaluation model in an interview :p
08:41:58 <kqr> haha
08:42:26 <ggVGc> nshepperd_: please write a naive example implementation of the ghc evaluation model
08:42:27 <kqr> it would be cool to be asked as long as they don't expect too much of an answer
08:42:51 * hackagebot Earley 0.7.1 - Parsing all context-free grammars using Earley's algorithm.  http://hackage.haskell.org/package/Earley-0.7.1 (OlleFredriksson)
08:44:09 <ggVGc> kqr: then why would they ask though?
08:44:52 <mizu_no_oto> ggVGc: figuring out the limits of someone's knowledge is useful
08:44:57 <ggVGc> true
08:45:10 <ggVGc> mizu_no_oto: also seeing how someone acts in the situation where they are actually out of their depth
08:45:26 <kqr> might lead to an interesting theoretical exploration too
08:45:30 <ggVGc> which sometimes happens in real world work
08:45:46 <ggVGc> i.e "we need to do this thing, but we actually don't have the expertise. We still need it, do it!"
08:45:48 <kqr> when I interviewed for google they asked me to architect some crazy real-time thing
08:45:50 <ggVGc> hapened to me many times
08:46:00 <kqr> I had no idea but I guess the purpose was just to see what kind of ideas/concerns I had
08:46:15 <mizu_no_oto> It also helps if you're at all involved with salary negotations - if they blow you away with the depths of their knowledge, you can probably offer them more money
08:46:23 <mizu_no_oto> since you really want them
08:47:08 <ggVGc> kqr: I hear google interviews are kind of wild west. They seem to have a huge range of ways of going about it
08:47:11 <ggVGc> for good reason I reckon
08:47:16 <kqr> maybe
08:47:21 <kqr> they've changed recently too
08:47:29 <kqr> although I didn't make it it was a really fun day
08:47:48 <ggVGc> kqr: what area in google were you interviewing for? I guess that makes a big difference
08:48:06 <kqr> software development
08:48:10 <kqr> I guess?
08:48:31 <ggVGc> kqr: well, I mean, they have a lot of very varying divisions as far as I understand
08:48:45 <ggVGc> like, the android team is completely separate from other teams
08:48:53 <ggVGc> and chrome/chromeOS is one single entity
08:49:03 <ggVGc> and the google maps guys are also one
08:49:06 <ggVGc> if I understand correctly
08:49:15 <ggVGc> so it's like a lot of smaller companies under one ubrella name
08:49:16 <kqr> ah yeah
08:49:25 <kqr> this was mostly for google hangouts/webRTC stuff
08:49:33 <ggVGc> I see
08:49:38 <ggVGc> I guess that question makes a lot of sense then
08:49:42 <ggVGc> sounds fun
08:50:16 <ggVGc> I used to really want to work at google. Now I don't feel much interst in even interviewing for them
08:50:34 <kqr> haha
08:51:07 <ggVGc> I mean, not because of what you said now, but because of how my ideas have changed over the past years
08:52:54 <kqr> they'd be useful to have on your resume though
08:53:04 <creichert> funfunctor: ok, one moment, I have the type error resolved but testing if my changes were meaningful
08:53:34 <ggVGc> kqr: yeah, but I don't really care about my "career" in programming
08:53:47 <ggVGc> I'd rather let what I do and say speak for itself, rather than "I have worked for these guys"
08:53:59 <kqr> I care mostly because I want my kids to have unlimited money heh
08:54:24 <kqr> I don't want them to have to take a break from school because things are getting financially tight like I am
08:54:45 <ggVGc> 'pure foo <*> Just bar' is the same as 'fmap foo Just bar', right?
08:54:59 <kqr> ggVGc, modulo parentheses, yes
08:55:04 <kqr> ggVGc, you probably mean fmap foo (Just bar)
08:55:16 <mau|{e> pure f <*> x = f <$> x
08:55:30 <mau|{e>   where (<$>) = fmap
08:55:38 <funfunctor> creichert: thx
08:55:47 <Denommus> (<$>) is on Prelude, don't worry
08:55:59 <Denommus> all is well
08:56:17 <creichert> funfunctor: what are the command line options?
08:56:35 <funfunctor> creichert: to pass the xml file to be parsed
08:56:38 <funfunctor> let me paste it
08:56:45 <creichert> what the 'al' option for?
08:56:48 <creichert> thanks
08:57:04 <creichert> I  did get it compiling with some commented code. It might lead you in the right direction at the very least
08:57:18 <lpaste> funfunctor pasted “No title” at http://lpaste.net/131699
08:57:19 <creichert> It's typechecking with the 'ServicePack' type, 
08:57:25 <funfunctor> creichert: ^
08:57:38 <creichert> funfunctor: what is the 'al' command line option for?
08:57:52 * hackagebot rethinkdb-client-driver 0.0.18 - Client driver for RethinkDB  http://hackage.haskell.org/package/rethinkdb-client-driver-0.0.18 (wereHamster)
08:58:01 <funfunctor> creichert: nothing at the moment.. I was reading example code on the haskell wiki
08:58:15 <funfunctor> i'll expand on it later
08:58:57 <creichert> right, np
09:00:38 <mau|{e> > (map (show <<< length) <$> words >>> intercalate ",") "what's all this then?"
09:00:40 <lambdabot>  "6,3,4,5"
09:00:58 <mau|{e> Denommus: ALL IS WELL
09:01:51 <kqr> gotta admit it took me a second to read the arrow <<< >>> stuff
09:02:13 <bennofs> yeah, not used to mixing <$> and >>> :)
09:02:34 <orion> What's the difference between mzero and empty?
09:02:52 * hackagebot avers 0.0.6 - empty  http://hackage.haskell.org/package/avers-0.0.6 (wereHamster)
09:03:08 <mau|{e> bennofs: that's because it's a terrible idea
09:03:08 <Denommus> orion: mzero is the identity monoid, empty is an empty arrow
09:03:21 <mau|{e> no, mempty is monoidy
09:03:29 <mau|{e> mzero is from MonadPlus
09:03:32 <Denommus> mau|{e: ah, sorry
09:04:01 <orion> What should be used if you can't parse something in Aeson (in your implementation of FromJSON), mzero or empty?
09:04:23 <bennofs> orion: doesn't matter, although I'd probably prefer empty
09:04:30 <Denommus> orion: then they represent a similar concept. But one is for Monad and the other for Arrow. Some types are both, but not all types are both
09:04:38 <bennofs> :t empty
09:04:39 <lambdabot> Alternative f => f a
09:04:44 <bennofs> no arrow Denommus 
09:04:52 <Denommus> bennofs: I'm getting crazy
09:05:20 <Denommus> bennofs: I'm confusing it with zeroArrow
09:05:29 <Denommus> which is basically the same as mzero and empty
09:05:35 <Denommus> but for arrows
09:05:36 <ocramz> Hi all; (\x -> sin x) pi = 1.2246467991473532e-16, but (\x -> sin x) 0 = 0.0 . I'm not sure I like this
09:06:01 <Denommus> ocramz: (\x -> sin x) is the same thing as sin
09:06:17 <ocramz> sure :)
09:06:22 <ocramz> but still
09:06:33 <mau|{e> > sin pi == 0
09:06:33 <Denommus> ocramz: I'm sorry if you don't like it, but floating pointers can't possibly be precise
09:06:34 <lambdabot>  False
09:06:47 <mau|{e> close enough
09:06:50 <Denommus> *floating pointer numbers
09:06:52 <ocramz> sheisse
09:06:59 <enthropy> ocramz: most languages use the same double
09:07:00 <mau|{e> > sin pi == (0 :: CReal)
09:07:02 <lambdabot>  True
09:07:11 <ocramz> ha
09:07:19 <Denommus> sin (pi :: CReal) == 0
09:07:22 <Denommus> > sin (pi :: CReal) == 0
09:07:23 <lambdabot>  True
09:07:51 <ocramz> interesting ; so the precision gets lost in translation
09:07:52 <KaneTW> never test floating points for equality
09:08:00 <mau|{e> ocramz: translation?
09:08:10 <Denommus> ocramz: you must always take rounding problems into account when working with floating points
09:08:41 <Denommus> ocramz: even a simple number like 0.1 will have rounding errors because of base 2
09:08:49 <ocramz> so the Boolean comparison above takes finite precision into account?
09:08:53 <bartavelle> This is unexpected. Using Control.Parallel.Strategies, I get a <<loop>> as soon as I use -Nx
09:08:59 <bartavelle> programs seems to work fine otherwise
09:09:25 <Denommus> ocramz: yes, it probably rounds 1.2246467991473532e-16 to 0
09:09:30 <mau|{e> what
09:09:38 <mau|{e> it doesn't round; that's why the result is False
09:09:38 <Denommus> > sin pi :: CReal
09:09:39 <lambdabot>  0.0
09:09:48 <KaneTW> when comparing floating points, always compare within an epsilon. instead of sin x == 0 you do abs (sin x) < eps with eps being some sufficiently small value
09:09:53 <Denommus> mau|{e: we're talking about sin pi :: CReal
09:10:02 <mau|{e> Denommus: that's not a floating point number
09:10:11 <c_wraith> CReal can't have perfect equality
09:10:39 <Denommus> ah, I didn't know
09:10:46 <Denommus> > pi :: CReal
09:10:47 <lambdabot>  3.1415926535897932384626433832795028841972
09:10:51 <mau|{e> > showCReal 100 pi
09:10:53 <lambdabot>  "3.1415926535897932384626433832795028841971693993751058209749445923078164062...
09:11:06 <ReinH> CReal checks "equality" by truncating, right?
09:11:09 <mau|{e> CReal is computable reals
09:11:20 <mau|{e> ReinH: I thought it did by going into an infinite loop
09:11:26 <ReinH> I suppose there isn't another way.
09:11:45 <ocramz> mau|{e : computable reals?
09:11:55 <mau|{e> yes
09:12:08 <mau|{e> ocramz: what did you mean by translation?
09:12:38 <ocramz> I thought CReal was from Foreign.C
09:12:39 <Denommus> ocramz: there is such a concept for "computable" information. There is a subset of real numbers that are computable. CReal represent such numbers
09:12:52 * hackagebot hledger-lib 0.25.1 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.25.1 (SimonMichael)
09:12:52 <ReinH> ocramz: I don't believe C has real numbers.
09:12:54 * hackagebot hledger 0.25.1 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.25.1 (SimonMichael)
09:12:58 <sopvop> Is it me or7.10 is much slower?
09:13:04 <ocramz> ReinH: yes I misunderstood
09:13:24 <Denommus> ocramz: the "C" means "constructive"
09:13:42 <ocramz> and they are represented to be comparable
09:13:55 <ocramz> in .. linear time I suppose
09:14:00 <Denommus> not exactly
09:14:28 <ReinH> The comparison is a lie.
09:14:44 <ocramz> ReinH : thanks, that explains many things
09:15:03 <ReinH> It just checks to a certain precision and goes "ok it's probably equal"
09:15:42 <Denommus> ReinH: can the precision be specified somehow?
09:15:42 <ocramz> so computable reals are .. a stochastic data struct in a way
09:15:53 <ReinH> ocramz: There's nothing random about them
09:16:39 <KaneTW> "Note that the comparison operations on CReal may diverge since it is (by necessity) impossible to implementent them correctly and always terminating.
09:16:56 <ocramz> KaneTW : very interesting
09:18:29 <ocramz> > :i CReal
09:18:30 <funfunctor> creichert: still stuck also?
09:18:30 <lambdabot>  <hint>:1:1: parse error on input ‘:’
09:18:36 <Denommus> ocramz: anyway, use an epsilon instead of comparing for equality
09:18:47 <Denommus> ocramz: lambdabot doesn't have :i
09:18:55 <Denommus> ocramz: https://hackage.haskell.org/package/numbers-2009.8.9/docs/Data-Number-CReal.html
09:20:00 <ocramz> yep I was browsing
09:20:02 <ocramz> instance Eq  CReal where
09:20:02 <ocramz>   x == y = s' (digitsToBits digits) == 0 where (CR s') = x-y
09:20:37 <creichert> funfunctor: yea, you might try something like this http://lpaste.net/131700
09:21:24 <creichert> funfunctor: I only copied in the functions I changed fyi, it doesn't process the document inside the arrow. It parses it out. I couldn't get it working with the xml document you pasted but I'm not sure what else is wrong. ran out of time :)
09:23:04 <funfunctor> creichert: ok thx
09:23:35 <creichert> funfunctor: the types jus might need to be restructured to first get the Version then a [FileName]
09:23:47 <creichert> ah, so maybe a fulle Device
09:24:27 <ggVGc> grokking applicative is really opening doors for me mentally
09:24:42 <ggVGc> especially the List instance of applicative
09:24:45 <ggVGc> sweet stuff
09:25:10 <ggVGc> wait, that is wrong I guess
09:25:22 <ggVGc> it would be written "The applicative instance of List", right?
09:25:46 <creichert> yes
09:27:41 <joneshf-laptop> is there a tool to convert haskell to lit haskell?
09:27:56 <joneshf-laptop> aside from some awk/sed
09:28:01 <ReinH> s/^/> /g ? :p
09:28:08 <joneshf-laptop> :)
09:28:51 <funfunctor> creichert: sorry, how do you mean?
09:31:20 <funfunctor> creichert: I only get a empty list printed back
09:33:42 <creichert> funfunctor: I mean the easiest way is to structure your data type and parser to handle the entire document, you start at "Bootloader" but that is nested
09:34:18 <funfunctor> creichert: I know but I was just trying to get something basic working before doing the whole thing
09:34:53 <funfunctor> i.e. writing all the parsers and combining them
09:37:51 <creichert> not sure then, possibly try breaking down the xml document or the code until it works, sorry
09:37:53 * hackagebot base-orphans 0.3.0 - Backwards-compatible orphan instances for base  http://hackage.haskell.org/package/base-orphans-0.3.0 (ryanglscott)
09:37:55 * hackagebot hledger-web 0.25.1 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.25.1 (SimonMichael)
09:40:52 <naudiz> @hoogle Int -> (a->b) -> a -> b
09:40:53 <lambdabot> Data.Sequence iterateN :: Int -> (a -> a) -> a -> Seq a
09:40:53 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
09:40:53 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
09:41:24 <funfunctor> creichert: [withTrace 1] amazingly useful !
09:41:33 <funfunctor> creichert: its hitting \n
09:42:03 <funfunctor> +---XText "\n         " how can I drop those?
09:42:37 <naudiz> is "(iterate f x) !! n" a good idea?
09:43:03 <creichert> funfunctor: possibly just "_ <- read ^<<" it and ignore it
09:43:40 <funfunctor> creichert: but then I need to put that everywhere it may or may not occur
09:43:56 <funfunctor> I need something that I can arrow combine it with
09:44:13 <naudiz> or should I consider using Data.Sequence?
09:48:09 <funfunctor> creichert: hasText (all (`elem` " \t\n"))  where hasText :: (String -> Bool) -> a XmlTree XmlTree
09:48:15 <funfunctor> but not sure how to fit that in
09:50:50 <ocramz> how about this?  (\x -> sin x / x) 0
09:50:50 <ocramz> NaN
09:50:58 <ocramz> how can I teach Haskell some limits?
09:57:30 <mniip> is there any Bool -> (a -> a) -> a -> a sort of function?
09:57:46 <mniip> maigc b f x = if b then f x else x
09:57:50 <srhb> :t bool
09:57:51 <lambdabot> a -> a -> Bool -> a
09:58:08 <mniip> hmm
09:58:08 <srhb> Almost
09:59:25 <supki> :t ap bool  
09:59:26 <lambdabot> (a -> a) -> a -> Bool -> a
10:07:05 <chpatrick> automatically bidirectional tar file serialization: https://gist.github.com/chpatrick/5ce8eee8bf2a99d5dfb9
10:07:28 <mniip> > map (ap bool (+1) 3) [True, False]
10:07:30 <lambdabot>  [4,3]
10:07:32 <mniip> ooh
10:07:35 <mniip> fancy
10:17:59 * hackagebot Concurrential 0.3.0.0 - Mix concurrent and sequential computation  http://hackage.haskell.org/package/Concurrential-0.3.0.0 (alexvieth)
10:23:23 <hiptobecubic> That seems like the kind of code that I wouldn't like to see in review
10:23:57 <jle`> :t \b f -> bool const f b
10:23:58 <lambdabot> Bool -> (a -> b -> a) -> a -> b -> a
10:24:37 <dolio> :t bool id
10:24:37 <lambdabot> (a -> a) -> Bool -> a -> a
10:30:52 <Rotaerk> :t bool
10:30:53 <lambdabot> a -> a -> Bool -> a
10:36:44 <athan> Are there any tools out there to check for needless module imports?
10:36:56 <ion> GHC
10:37:02 <athan> :x
10:37:14 <athan> ion: Is that with `cabal install --dry-run`?
10:37:21 <ion> I at least think it warned about that.
10:37:34 <ion> athan: If the .cabal file doesn’t set -Wall, you may be able to set that using cabal parameters.
10:37:49 <athan> thank you ion :)
10:37:59 <ion> Also, it needs to actually compile the files.
10:38:04 <glguy> cabal install --dry-run just checks dependencies as listed in the .cabal file. It doesn't have anything to do with imports
10:38:46 <athan> Whenever compilation succeeds in my package, even with -Wall, I still don't get warnings :\
10:39:14 <glguy> Then you probably don't have any redundant module imports
10:39:47 <athan> glguy: I mean to say, I /never/ do - even when there are redundant imports
10:40:26 <glguy> Are you thinking of redundant package dependencies listed in the .cabal file, perhaps?
10:41:28 <ggVGc> why was mappend named that way? seems pretty unfortunate?
10:41:35 <ggVGc> I mean, not really fitting generally
10:42:16 <humanoyd> If only hoogle could be found at hoogle.com...
10:42:24 <bsmt> that would be nice
10:45:13 <ggVGc> why doesn't haskell enforce things like the monoid laws for monoid etc.? Are there extensions for GHC that does?
10:46:13 <mizu_no_oto> ggVGc: proving laws in the code really requires dependent types
10:46:32 <mizu_no_oto> so you can do something like that in Agda or Idris
10:48:10 <mizu_no_oto> ggVGc: Also, mappend and mempty presumably come from List being the free monoid
10:48:21 <dmj`> hello
10:48:58 <dmj`> When I add -fhpc to my project a lot of .mix files are created in the .hpc directory. How do I generate code coverage documentation from this ?
10:49:30 <ggVGc> mizu_no_oto: hm, okay, I imagined it would be easier, but I guess not. I don't really understand dependant types yet, but in due time
10:49:37 <mizu_no_oto> But they really were just poorly (i.e. verbosely and not-terribly-descriptively) named.
10:50:13 <creichert> dmj`: hpc report, this blog might help a bit http://taylor.fausak.me/2014/03/04/haskeleton-a-haskell-project-skeleton/#test-coverage
10:51:19 <creichert> It adds the coverage to the test-suite, but otherwise explains how to generate it manually as well. I *think* some aspects of hpc has changed, e.g. the location of the generated tix files
10:51:58 <mizu_no_oto> ggVGc: http://en.wikipedia.org/wiki/Free_monoid
10:52:16 <creichert> I think it's neat adding hpc to the test since you can fail if the percentage falls below a certain threshold
10:53:00 * hackagebot auto 0.4.2.0 - Denotative, locally stateful programming DSL & platform  http://hackage.haskell.org/package/auto-0.4.2.0 (jle)
10:53:41 <dmj`> creichert: omg I have to run it
10:53:55 <dmj`> creichert: that's cool 
10:54:26 <hiptobecubic> I think "lens" might be haskell's "boost".
10:54:32 <creichert> hpc is very cool, It can be a bit tricky to setup but totally worth it
10:57:18 <athan> glguy: yay: http://stackoverflow.com/questions/12273315/how-to-recompile-haskell-with-cabal-build-showing-only-warnings
10:59:01 <ysr> How do I apply read to getline? "read . getLine" seems to cause problem
10:59:40 <geekosaur> fmap
11:00:28 <sweater> Hey, people. I need to parse a really stupid API with Aeson. In this API some booleans are represented with "on" / "off"; some booleans are represented with 1 / 0; some are represented with true/false. Naturally, a type to represent that sort of mess without forgetting is "data HBool = S Bool | I Bool | B Bool". The question is how to write a FromJSON instance for such a type. I haven't used Aeson previously
11:00:28 <mizu_no_oto> ysr:  getLine :: IO String, but read :: Read a => String -> a 
11:00:29 <geekosaur> also, take some time to learn how IO works in Haskell
11:00:30 <sweater> and I don't really want to invent any Parsec bicycles, so any help'd be highly appreciated.
11:01:09 <mizu_no_oto> ysr: as geekosaur mentioned, fmap read :: Read a => IO String -> IO a
11:01:21 <marchelzo_> @pl \a s -> s `elem` (fst a)
11:01:21 <lambdabot> flip elem . fst
11:02:01 <kqr> sweater, is it not okay to convert everything to true/false?
11:02:55 <sweater> kqr: I don't want to forget initial value, so it's okay to convert things to tagged Bools :(
11:03:27 <sweater> Because instance ToJSON S Bool is not the same as ToJSON I Bool :) 
11:06:32 <kqr> sweater, something like withText might help you there, then
11:06:49 <kqr> sweater, not sure otherwise
11:06:50 <sweater> kqr: can you explain the type of withX?
11:06:55 <sweater> types*
11:07:36 <sweater> withText has String -> (Text -> Parser a) -> ... IIRC
11:07:48 <sweater> I understand -> Value -> Parser a part
11:07:53 <sweater> and (Text -> Parser a) part
11:07:57 <sweater> but what is String -> ?
11:13:00 * hackagebot aur 2.0.4 - Access metadata from the Arch Linux User Repository.  http://hackage.haskell.org/package/aur-2.0.4 (fosskers)
11:13:26 <kqr> sweater, if the value matches the string, it applies the text -> parser function to it... I *think*
11:13:53 <sweater> kqr: thanks :) I'll read the code to be sure
11:26:09 <ysr> if something is Ord, is it also an Eq?
11:26:58 <mniip> ysr, it can't be an Ord without being Eq
11:27:05 <mniip> the definition of Ord prohibits that
11:27:12 <frerich> ysr: Yes, that's what the 'Eq a =>' means in http://hackage.haskell.org/package/base-4.8.0.0/docs/Prelude.html#t:Ord
11:27:56 <ysr> ok, so it is official :D
11:36:07 <nschoe> Ah man... I just love Haskell: "No instance for .... (maybe you haven't applied enough argument to a function?)" 
11:36:15 <nschoe> Wel... yes, indeed! Thanks GHC.
11:38:01 * hackagebot swagger 0.2.2 - Implementation of swagger data model  http://hackage.haskell.org/package/swagger-0.2.2 (ToralfWittner)
11:40:41 <hiptobecubic> nschoe, if it *didn't* say those things it would be pretty hard to figure out what the hell is going on sometimes.
11:41:14 <nschoe> hiptobecubic, totally, 100%. I was not critizing, I was ... being in awe ^^
11:43:15 <monochrom> I think this one is pretty new
11:53:28 * hackagebot geniplate-mirror 0.6.0.6 - Use Template Haskell to generate Uniplate-like functions.  http://hackage.haskell.org/package/geniplate-mirror-0.6.0.6 (DanRosen)
11:57:01 <athan> Hi everyone, I guess I have duplicate modules in my library, but I can't find which files are claiming to be the duplicates. How do I find out?
11:58:29 * hackagebot modular-arithmetic 1.2.1.0 - A type for integers modulo some constant.  http://hackage.haskell.org/package/modular-arithmetic-1.2.1.0 (TikhonJelvis)
11:59:09 <athan> oh wait I found it in Exported-Modules, sorry folks
12:00:16 <ggVGc> what is the opinion here on this? http://degoes.net/articles/principled-typeclasses/
12:06:39 <User_475986> Can someone help me with an algorithm?
12:06:46 <c_wraith> ggVGc: the underlying objection is solid, but it's overstating the degree of the problem.
12:07:37 <c_wraith> ggVGc: also, it has quite a few technical inaccuracies.
12:10:04 <athan> Alright guys, if anyone needs a web server quick-and-dirty, use this: https://github.com/athanclark/hi-basic-web-server
12:11:06 <ggVGc> c_wraith: it seems like quite a serious issue to me. I like his idea of enforcing only one instance of a certain type class for a certain type, and if you need two, you'd define a sub-type class
12:11:15 <ggVGc> like addition and multiplicatrion for integer like he showed
12:11:23 <ggVGc> c_wraith: why do you feel it's overstated?
12:13:02 <blogle> whats the best way to capture key presses (ie Enter or Shift+Enter) in IO?
12:13:03 <c_wraith> ggVGc: I can define infinite different Monoid instances for Integer.  I think it becomes impossible to write generic code if every single one of those needs to be a different class.  And most of them have no laws over the laws of Monoid
12:14:20 <ggVGc> c_wraith: but the problem is in infering which instance implementation you want at the point of usage, isn't it?
12:14:23 <ggVGc> how do you do that
12:16:29 <blogle> anybody?
12:16:56 <hiptobecubic> blogle, that is the job of something that has a gui layer
12:17:35 <monochrom> blogle, perhaps use a terminal library, for example "vty". but I have not tried.
12:17:44 <hiptobecubic> blogle, so yes it will be in IO, but if you want to capture actual key presses you need something that either interfaces with the terminal in raw mode or can interpret keypresses from X11, etc
12:19:02 <c_wraith> ggVGc: the current state is that you use a newtype that describes the intended semantics. I can't even see how, with that proposal, you'd call something that depends only on Monoid and indicate which subclass of Monoid you want to use.
12:19:03 <blogle> I want to be windows compatible so I dont want to tie to X11. 
12:19:19 <hiptobecubic> blogle, is this going to be a GUI application?
12:19:36 <blogle> terminal repl
12:19:37 <c_wraith> ggVGc: that is, I think there's something to the underlying problem that article discusses.  But I don't think it's proposed solution improves anything.
12:20:24 <hiptobecubic> blogle, then you'd want a library to work with the terminal in raw mode. I'm not sure what's best in haskell, maybe vty as monochrom suggested?
12:20:30 <ggVGc> c_wraith: yeah, I felt the same way. But, I still feel there are some major warts in type classes
12:20:41 <ggVGc> wonder if it's possible to solve without dependent types
12:21:08 <blogle> hiptobecubic & monochrome thanks I will take a look at vty
12:21:48 <blogle> hiptobecube, awesome userid btw
12:22:03 <blogle> cubic*
12:22:50 <hiptobecubic> :)
12:23:05 <marchelzo_> What happened to splitOn from Data.List.Split? (I upgraded GHC and I don't have it anymore).
12:23:26 <ysr> I am making data RPS = Rock | Paper | Scissors an Ord type. If I define Paper `compare` Rock = GT, do I need define Rock `compare` Paper = LT ?
12:23:39 <hiptobecubic> marchelzo_, I do. What version of ghc?
12:23:49 <hiptobecubic> i have 7.10.1
12:24:25 <marchelzo_> so do I
12:24:39 <marchelzo_> I don't have the Data.List.Split module. Is it not in base?
12:24:49 <hiptobecubic> no, I don't think so
12:24:54 <hiptobecubic> I think it's called "split"
12:24:59 <marchelzo_> oh ok
12:25:00 <marchelzo_> my mistake
12:33:30 * hackagebot flowlocks-framework 0.1.3.1 - Generalized Flow Locks Framework  http://hackage.haskell.org/package/flowlocks-framework-0.1.3.1 (NiklasBroberg)
12:33:49 <tromp> ysr, yes, but you can instead say deriving Ord
12:35:24 <ysr> tromp I don't understand, if I derive it, how can it know that Rock > Scissors, Scissors > Paper, Paper > Rock
12:35:29 <ysr> it is circular
12:36:27 <tromp> oh, you shouldnt use Ord then, that's for proper orderings
12:37:01 <tromp> define your own "beats" relation
12:38:30 <e4x> could anyone help me with this error? http://lpaste.net/131707
12:38:59 <deavmi> how do you declare a variable in haskell
12:39:32 <verement> > let x = 10 in x + 1
12:39:34 <lambdabot>  11
12:39:55 <hiptobecubic> > let 10 = 11 in 10
12:39:56 <lambdabot>  10
12:39:59 <hiptobecubic> dang
12:42:12 <t7> way pythonic bro
12:42:15 <t7> true = false
12:42:51 <verement> e4x: doc_open returns 'IO Document'; doc_close expects 'Document'. To feed one to the other, use (>>=)
12:46:16 <deavmi> this language...
12:46:21 <deavmi> is too different
12:46:27 <deavmi> 10 = 11
12:46:37 <deavmi> one does not simply give a value a value
12:46:59 <verement> no one is doing that
12:47:00 <monochrom> "one does not simply give a value a value" is correct.
12:47:20 <monochrom> you're mistake is in assuming that "10 = 11" gives a value a value.
12:47:27 <monochrom> s/you're/your/
12:47:28 <e4x> verement: where I have to put >>=?
12:47:47 <verement> e4x: doc_open … >>= doc_close
12:48:10 <deavmi> is 10 a variable identifier
12:48:17 <deavmi> a.k.a the name of a variable
12:48:19 <deavmi> ?
12:48:20 <monochrom> no. it is a pattern.
12:48:29 <e4x> verement: nice, thanks
12:48:30 * hackagebot hashabler 0.1.0.0 - Principled, cross-platform & extensible hashing of types, including an implementation of the FNV-1a algorithm.  http://hackage.haskell.org/package/hashabler-0.1.0.0 (BrandonSimmons)
12:50:10 <verement> > let (10, x) = (10, 5) in x + 1
12:50:11 <lambdabot>  6
12:50:25 <verement> > let (10, x) = (11, 5) in x + 1
12:50:27 <lambdabot>  *Exception: <interactive>:3:5-21: Irrefutable pattern failed for pattern (10...
12:50:36 <Aruro> > 10 = 11
12:50:37 <lambdabot>  <hint>:1:4: parse error on input ‘=’
12:50:53 <Aruro> deavmi: here is your desired behaviour
12:52:20 <monochrom> Aruro, the context of "10 = 11" is either part of let-in or top-level.
12:53:07 <Aruro> top level
12:53:16 <Aruro> lets say
12:53:26 <monochrom> then it is not a parse error.
12:53:30 * hackagebot hashabler 0.1.0.1 - Principled, cross-platform & extensible hashing of types, including an implementation of the FNV-1a algorithm.  http://hackage.haskell.org/package/hashabler-0.1.0.1 (BrandonSimmons)
12:54:20 <kadoban> deavmi: Interested in learning haskell? You should start with https://github.com/bitemyapp/learnhaskell
12:54:46 <Aruro> monochrom: yes, you are correct no even error at all :D
12:54:51 <CapitalSigma> deep recursion can't cause a stack overflow in GHC, right? since it executes via graph reduction rather than as a stack machine
12:55:17 <monochrom> the conclusion is right, the reason is wrong
12:55:19 <Aruro> kadoban: he sould start from LYAH not that
12:55:34 <CapitalSigma> monochrom: thanks -- what's the right reason?
12:55:53 <t7> spineless tagless gmachine brah
12:55:55 <monochrom> the stack is growable like the heap. in fact the stack is just another heap object.
12:56:19 <kadoban> Aruro: no.
12:56:42 <Aruro> kadoban: how did you learn haskell? using bitemyapp?
12:56:49 <Aruro> i bet no.
12:57:08 <monochrom> I learned haskell from the gentle introduction.
12:57:25 <monochrom> does that imply that I should suggestion the gentle introduction today?
12:57:36 <monochrom> or does that imply that I should suggest LYAH today?
12:57:41 <monochrom> what logic is this?
12:57:44 <kadoban> Aruro: Mostly puttering around a lot via RWH for a long time, which took forever. cis194 is much better. LYAH doesn't even have exercises or anything. The time I read it, besides the annoying tone … I read the whole thing, understood it, and then I'm like "okay … how do I actually write anything again?"
12:58:04 <CapitalSigma> monochrom: isn't stack size fixed by the OS? or does Haskell introduce a layer of indirection on top of that?
12:58:28 <geekosaur> stack size isn't fixed by the OS in any meaningfuil way in any language supporting threads
12:58:45 <geekosaur> because thread stacks muust be allocated out of the heap
12:59:16 <monochrom> GHC builds its own stack (stack pointer is a different register from SP) and leaves SP's stack for calling C
12:59:35 <CapitalSigma> geekosaur: i'm not sure that's true -- C pthreads do have their own stacks afaik
13:00:01 <xpilot> hello
13:00:07 <geekosaur> threads by definition share an address space. how do they all use the main stack at the same time?
13:00:17 <xpilot> I'm trying to find the source code for StateT (particularly, the MonadFix instance)
13:00:25 <xpilot> I've looked here https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Lazy.html
13:00:30 <monochrom> read some GHC-generated asm code some day. (I already did.)
13:00:33 <xpilot> but haven't been able to find it
13:00:44 <Aruro> kadoban: i disagree about annoying tone :) book is written nicely, from the literary point of view
13:01:32 <ysr> Looking for review: Rock Paper Scissors game implemented in haskell; http://codereview.stackexchange.com/q/88395/13063
13:01:39 <geekosaur> and C pthreads indeed have their own stacks. allocated from the heap, because where else do they come from?
13:01:41 <kadoban> Aruro: Do you disagree about it completely lacking exercises? Not actually asking the reader to write any code at any point isn't a very good way to teach.
13:01:54 <geekosaur> you can specify the size to allocate from the heap in pthread_create
13:02:38 <rui2> I wish fedora's ghc was more up to date..
13:03:09 <CapitalSigma> geekosaur: hmmm i suppose, i'm just weirded out by the idea that stack == heap
13:03:17 <Aruro> kadoban: good question, i dont think exercises are that important, they are part of the readers responsibility
13:04:16 <Aruro> i think its better to have huge good book of JUST exercises , and good book of just ideas
13:04:36 <e4x> verement: last question: http://lpaste.net/131708
13:04:44 <geekosaur> this does not mean stack == heap. it does mean that a chunk of heap memory was repurposed as thread stack, and can return to the heap when the thread is joined
13:05:05 <kadoban> Aruro: Then someone who has no idea about the language and is using their brainpower to try to learn has to somehow come up with a realistic set of exercises, with ramping difficultly. Since in haskell, some things are not-beginner-friendly that are fine in other languages, that seems questionable.
13:05:45 <kadoban> Aruro: Okay, but … if you're not also suggesting a book with exercises, how is LYAH good advice then? And exercises should follow the text of the book, so what's taught is also exercised, so how could they be separated usefully?
13:06:11 <geekosaur> also "heap" is itself a kind of outdated concept, since modern systems tend to map pages in random open areas of the process address space instead of having a single "heap" following the initialized data
13:07:14 <sinelaw> Hi, does anyone have an example of contravariance in rank-n types?
13:07:35 <sinelaw> maybe for these functions: http://lpaste.net/131709
13:08:36 <sinelaw> I mean an example where you can use a type that has a less polymorphic argument (contravariant position) making the entire type more polymorphic
13:09:06 <verement> e4x: In this case dict_contains does not return IO Bool, so you can't use (>>=). Instead, try fmap (<$>): dict_contains … <$> dict_load …
13:12:23 <e4x> verement: perfect :)
13:13:19 <Aruro> kadoban: i just think exercises is something much more private than ideas, some people need easy obvious stuff, others want to write something more real, and others want to dig deep from start
13:13:39 <ysr> If I post the same thing both in here and haskell-beginners, will it be considered bad?
13:13:47 <Aruro> kadoban: so choice of exercises is basically choice of experience, i dont trust author to do that :)
13:14:07 <Aruro> only reader should decide if he wants to exercise or not
13:14:32 <ggVGc> has anyone done any serious work in Idris here?
13:14:43 <ggVGc> well, serious, as in a program you actually use for something?
13:14:59 <sinelaw> ggVGc, did you try #idris? :)
13:15:46 <kadoban> Aruro: That doesn't make /any/ sense at all to me.
13:17:15 <Aruro> kadoban: bad exercise can do much more harm than no exercises at all, does it sound real?
13:17:56 <Aruro> and LYAH does have code in it, you can enter it and try
13:18:02 <kadoban> Aruro: Yes. You're the one suggesting that a reader should somehow come up with an appropriate exercise at each step. How an ignorant person is supposed to do that appropriately, I have no idea.
13:18:03 <Aruro> here is "exercise"
13:18:14 <kadoban> Aruro: That's not exercises …
13:18:29 <Aruro> kadoban: so you assume reader is ignorant? :) mistake.
13:18:46 <kadoban> Aruro: I assume they're relatively ignorant about haskell, yes.
13:18:52 <Aruro> kadoban: you can play with that code modify it, what is it then?
13:18:55 <kadoban> If they're reading a beginner text.
13:19:13 <Aruro> kadoban: professional from other area can read beginners text
13:19:34 <kadoban> Aruro: Yes, and they'll have no idea what an appropriate exercise to do in haskell is, at various points in their learning.
13:20:06 <Aruro> kadoban: my point is if you teach them conceptions well they will find good exercises themself
13:20:09 <kadoban> Aruro: Which is pretty obvious when you get a bunch of people in here trying to do a web app when they barely know anything about haskell, and unsurprisingly getting frustrated and annoyed.
13:20:30 <Aruro> kadoban: why they need web app in haskell?
13:20:49 <Aruro> kadoban: you said beginners
13:20:53 <geekosaur> because web apps are whatthey're familiar with
13:20:55 <mniip> Aruro, you can only come up with excercises yourself if you're pretty advanced
13:20:59 <kadoban> Aruro: Okay, but that seems like hopeful nonsense to me. I don't think anything you've said has come close to convincing me otherwise. How is a haskell newbie supposed to know what a good exercise is?
13:21:11 <mniip> for beginners I'd say you do need to provide excercises
13:21:43 <Aruro> kadoban: tell me how do YOU know what is good exercise for what you call newbie?
13:22:17 <Aruro> kadoban: it will be your subjective opinion nothing else/
13:22:23 <kadoban> Aruro: I don't. I know that authors should provide them, so that a reader can exercise the knowledge that they've gained at regular intervals.
13:22:35 <kadoban> Aruro: Oh, I forgot how what you're saying is objective truth </sarcasm>
13:22:41 <Aruro> kadoban::D
13:22:46 <Aruro> kadoban: good one :)
13:22:55 <geekosaur> so exercises should never be provided, for Haskell or anything else, because by your definition nobody can ever know what exercises are appropriate.
13:23:06 <kadoban> Aruro: Have you ever taken a class that didn't have homework?
13:23:08 <Aruro> geekosaur: indeed :)
13:23:12 <geekosaur> any more complete nonsense to offer?
13:23:28 <geekosaur> because somehow I think there's a lot of proof otherwise out there
13:24:43 <verement> better to offer exercises people can ignore than to offer none and assume people are capable of coming up with their own
13:24:51 <Aruro> geekosaur: you did not notice how it started all i said book should not be gudged by presence of exercises in it
13:26:02 <nak> computational theory time ! is a function "impure" just because it throws an exception?
13:26:27 <geekosaur> actually I did notice. and it's still nonsense
13:26:49 <Aruro> @all-dict nonsense
13:26:50 <lambdabot> *** "Nonsense" gcide "The Collaborative International Dictionary of English v.0.48"
13:26:50 <lambdabot> Nonsense \Non"sense\, n. [Pref. non- + sense: cf. F. nonsens.]
13:26:50 <lambdabot>    1. That which is not sense, or has no sense; words, or
13:26:50 <lambdabot>       language, which have no meaning, or which convey no
13:26:50 <lambdabot>       intelligible ideas; absurdity.
13:26:52 <lambdabot> [82 @more lines]
13:27:15 <pranz> nak: I woulg argue yes, because then the type of it is a lie
13:28:01 <verement> nak: I think it depends whether the exception is deterministic
13:28:39 <Aruro> kadoban demoted LYAH because it has no exercises -- that is main point.
13:29:12 <verement> if the exception is due to the fact you've written a partial function, I don't think that qualifies as "impure"
13:30:41 <nak> verement let's consider an easy example: 
13:30:44 <verement> if the exception is instead because you're hiding some I/O in the background that goes awry, I think I would call such a function "impure"
13:30:46 <nak> > 5 `div` 0
13:30:47 <ryanprior> I'm pretty new to Haskell and I have couple lambdas that could maybe be replaced with something standard. The first is a difference of functions: (\s -> funcOne(s) - funcTwo(s)), the second is the sequence of ints from 1 to n: (\n -> [1..n]). Are there standard patterns I could replace those with or am I doing the right thing by using those lambdas?
13:30:48 <lambdabot>  *Exception: divide by zero
13:30:59 <nak> is div "impure" because it throws?
13:31:23 <verement> nak: I don't believe so
13:32:39 <pranz> ryanprior: regarding the first, I would use the lambdas for readability
13:32:42 <nak> verement can you provide your reasoning tho?
13:33:33 <pranz> ryanprior: but 'liftA2 (-) funcOne funcTwo' is equivalent to that statement
13:33:49 <verement> nak: you'll get the same exception every time you provide 0 as divisor; this is deterministic behavior that depends solely on the arguments you provide to the function
13:34:19 <pranz> ryanprior: for the second there is a function for that
13:34:20 <frerich> ryanprior: As for the second thing, '\n -> [1..n]' is the same as 'enumFrom'
13:34:28 <pranz> yeah that one
13:34:40 <frerich> err no
13:34:41 <srhb> nak: I think you will find people that argue either case. Similarly, IO actions are by some (many) considered pure because simplistically, they will produce the same instructions for the runtime every time.
13:35:04 <pranz> :t enumerate
13:35:04 <lambdabot> Not in scope: ‘enumerate’
13:35:06 <pavonia> > enumFromTo 1 7
13:35:06 <frerich> ryanprior: \n -> [1..n] is the same as 'enumFromTo 1'
13:35:07 <lambdabot>  [1,2,3,4,5,6,7]
13:35:33 <mniip> srhb, IO are pure on the outside, but impure in the implementation because they depend on evaluation order a lot
13:35:35 <ryanprior> pranz, thanks for that info. I agree that the lambda as I have it is more readable. is there any benefit to using liftA2?
13:36:04 <ryanprior> pranz, frerich: thanks, I'll use enumFromTo.
13:36:20 <kadoban> ryanprior: Not really, no.
13:36:36 <Aruro> ryanprior: it is in Haskell report 2010 called Arithmetic Sequences
13:36:38 <srhb> mniip: I don't understand or agree with that distinction, but I don't care either way. :)
13:39:10 <mniip> srhb, read up on how does GHC implement IO
13:39:25 <srhb> mniip: I know how GHC implements IO. :)
13:39:39 <mniip> then what is there to not understand!
13:39:41 <ryanprior> Aruro: I've never read any of the Haskell reports. Do you recommend it? Are they relatively accessible to newcomers? I don't have a good handle on where the best Haskell documentation is yet.
13:40:00 <srhb> mniip: The outside/inside distinction. 
13:40:16 <srhb> mniip: But as I said, it doesn't interest me. I merely wanted to point out that this is a point of contention.
13:40:39 <mniip> I mean the Functor/Applicative/Monad api versus importing GHC.IO and setting MagicHash
13:40:43 <ryanprior> Hoogle, in particular, comes up in a lot of searches and apparently documents many Haskell topics; but I don't know how to read it and it never helps me understand the things I find on there.
13:41:02 <indiagreen> ryanprior: Hoogle is merely searching for functions
13:41:10 <kadoban> ryanprior: The report is way more readable than some on other languages, but … I don't know that it'd be all that useful to someone trying to learn the language, except as a reference like.
13:41:28 <nak> srhb verement i'm inclined to subscribe to teh same way of thinking: i.e., if the same inputs provide the same behaviors... it is a "pure" function
13:41:29 <indiagreen> it's useful because you can give it a type and it would search by it (the haskell.org/hoogle version)
13:42:01 <srhb> nak: We usually call it partial, though, because it is undefined for division by zero
13:42:11 <srhb> nak: This is when we usually introduce Maybe, etc.
13:42:30 <verement> nak: right, there is a difference between pure/impure and total/partial
13:42:33 <srhb> As in, the exception machinery is way too heavy and hard to reason about compared to just wrapping the result.
13:42:50 <ryanprior> indiagreen: what's the best way to find out what a function does or see it used in context? grep? ;-)
13:43:05 <Aruro> kadoban: we are opening cis194 lecture one and what do we see? sugessted reading : LYAH chapter 2. Thus establishing a bridge betwenn different opinions on whats best for beginner. 
13:43:24 <indiagreen> there are sometimes examples in docs, it's often enough
13:43:34 <indiagreen> when it's not enough, you'd be better off Googling for a topic
13:43:59 <indiagreen> (lenses in Haskell, <whatever web framework> in Haskell, JSON parsing in Haskell, etc.)
13:44:01 <kadoban> Aruro: Yes, it's suggested reading (which even some people disagree with). But guess what? It has exercises, which was my /entire/ point, so what are you thinking your proved or something?
13:44:04 <ronh> mniip monads handle evaluation order.. in `x >>= f' f x can't be executed before x is executed
13:44:24 <ronh> or rather, f with the result of running x action
13:44:33 <Aruro> kadoban: no your entire point LYAH is not good for beginner
13:44:37 <Aruro> is*
13:45:03 <frerich> ryanprior: I think 'hackage' is pretty nice for learning what a function does, because that's where the API documentation is. For finding use cases, I often search github for e.g. "hGetContents language:Haskell'
13:45:34 <kadoban> Aruro: *because it has no exercises*
13:45:44 <nak> srhb we'll have to talk about wrapping sometime :)
13:45:52 <srhb> nak: Sure :)
13:46:21 <srhb> nak: I basically meant safeDiv _ 0 = Nothing; safeDiv x y = Just (x `div` y)
13:46:59 <kadoban> Aruro: I pointed someone towards learnhaskell, which suggests cis194. You said that was wrong and I should instead point people towards LYAH. I pointed out why that's a bad idea. Are we going to go through the entire conversation again?
13:47:07 <mniip> ronh, can
13:47:10 <ryanprior> frerich: thanks for those suggestions. Can you recommend any open-source Haskell codebases that you consider to be quality code and representative of good habits?
13:47:40 <mniip> ronh, there is nothing in the definition of >>= that prevents monads from being lazy in the first argument
13:47:41 <frerich> ryanprior: Not really, sorry.
13:47:52 <mniip> and some implementations do that
13:48:06 <mniip> some instances I mean
13:48:34 <verement> > minBound `div` (-1) :: Int
13:48:35 <lambdabot>  *Exception: arithmetic overflow
13:49:00 <nak> srhb but then say we have a function, average, that depends on safeDiv
13:49:10 <nak> how do we reason with the return values from safeDiv ?
13:49:28 <srhb> nak: case div x y of Nothing -> we divided by zero; Just result -> we're good
13:49:30 <Aruro> kadoban: you opinion clear
13:49:33 <Aruro> r*
13:50:02 <nak> average xs = sum xs `safeDiv` $ length xs
13:50:11 <nak> not sure that notation is correct
13:50:14 <srhb> nak: That would be in the Just case then
13:50:34 <srhb> nak: Basically using safeDiv forces the programmer to reason about the Nothing case
13:50:45 <srhb> nak: Either by pattern matching or with some combinator.
13:50:55 * nak nods
13:51:05 <nak> but by using normal `div` we are forced to handle the exception
13:51:10 <nak> so i'm struggling to see the difference
13:51:15 <mniip> ronh, see for example
13:51:16 <mniip> > (undefined >> const ()) ()
13:51:17 <lambdabot>  ()
13:51:21 <ronh> mniip, sensible definition of IO's bind won't be lazy in the first argument. the point is, IO can be implemented without any side effects, it could just build a tree that describes execution
13:51:21 <srhb> The difference is that exceptions are much more difficult to reason about
13:51:23 <srhb> So we avoid it altogether
13:52:18 <mniip> ronh, so then a Writer basically?
13:52:19 <verement> nak: Exceptions can't be handled in pure code. They can only be caught from IO.
13:52:32 <mniip> no wait
13:52:42 <mniip> more like Writer and []
13:52:44 <srhb> :t try
13:52:45 <lambdabot> Exception e => IO a -> IO (Either e a)
13:52:47 <srhb> :t maybe
13:52:48 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:52:53 <srhb> The latter is much nicer.
13:54:15 <ronh> some article implemented a subset of IO (just stdin and stdout) like htis. let me see if I can find it.
13:57:41 <nak> interesting
13:57:46 <nak> reading about Maybe and Just
13:57:49 <nak> i still have so much to learn
13:58:03 <srhb> nak: Just is a value constructor of the Maybe a type, along with Nothing
13:58:21 <srhb> @src Maybe
13:58:21 <lambdabot> data Maybe a = Nothing | Just a
13:58:44 <monochrom> Did someone want to know about exceptions? my exception tutorial is at http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml
13:58:57 <srhb> nak: You can consider Nothing our very much nicer way of avoiding null or similar altogether :P
13:59:21 <monochrom> although, it won't tell you about x/0
14:01:50 <nak> @monochrom thanks regardless. i was just using x/0 as an example
14:01:51 <lambdabot> Unknown command, try @list
14:02:04 <nak> srhb monochrom verement i have to run for now, but i'll catch up with you all later
14:02:07 <nak> thanks for the insights :)
14:02:10 <srhb> nak: o/
14:02:15 <verement> cheers
14:03:57 <nak> o/
14:05:18 <ronh> mniip here: http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/ the only "impure" part of that code (assuming one consider IO impure, which the article argues against) is `run :: IOAction a -> IO a'. everything else is just building pure data structures that represent execution
14:07:17 <dpl> Hi everyone, I'm going to ask you guys something...
14:07:27 <srhb> dpl: Thanks for the warning!
14:08:28 <dpl> do you why "(==2) $ length $ primeFactors n 2 []" works correctly (or so I think) in ghci, but "(length $ primeFactors n 2 []) == 2" doesn't? Also...noob warning :)
14:08:33 * hackagebot tttool 1.4 - Working with files for the Tiptoi pen  http://hackage.haskell.org/package/tttool-1.4 (JoachimBreitner)
14:08:41 <dpl> srhb: np :)
14:08:55 <benzrf> dpl: they should both work
14:09:52 <dpl> benzrf: Could something be wrong with primeFactors, or is that irrelevant?
14:10:56 <benzrf> dpl: are you sure those are both precisely the thing you're putting in, on a line by themselves
14:10:56 <srhb> dpl: Errors will help us help you
14:12:45 <P4Titan> Hello all, why is it illegal to define a function that takes 2 arguments, with a pattern match that matches on both arguments and a different pattern match where only the 1st is matched on and returns a function that takes a type of the second argument and returns the return type of the larger function? Haskell complains of multiple definitions of a function with different number of arguments.
14:13:06 <srhb> P4Titan: Because definitions
14:13:14 <srhb> P4Titan: A different language than Haskell might not have that restriction.
14:13:17 <srhb> P4Titan: Haskell does.
14:13:18 <dpl> benzrf, srhb: http://lpaste.net/131710
14:13:38 <P4Titan> Why is defining a function with 0 paternmatches does not complain about argument number mistmatch.
14:14:30 <srhb> P4Titan: Because the limitations is _same number of parameters on the LHS for equations for the same function"
14:14:48 <P4Titan> What do you mean?
14:14:49 <pavonia> I always wondered why we have this limitation
14:14:59 <bennofs> If I have type family Not a where Not 'True = 'False; Not 'False = 'True, can I prove to GHC that Not (Not a) ~ a ?
14:14:59 <dpl> benzrf, srhb: The current code is: "isAlmostPrime n = (==2) $ length $ primeFactors n 2 []"
14:15:14 <benzrf> dpl: try
14:15:29 <benzrf> isAlmostPrime n = length (primeFactors n 2 []) == 2
14:15:32 <benzrf> that should work
14:15:43 <srhb> P4Titan: I mean, the issue isn't that you need to put all the paremeters on the LHS instead of directly having functions on the RHS, but that you cannot have equations with different numbers of verbatim arguments on the LHS for the same function.
14:15:45 <shachaf> bennofs: That's not true, is it?
14:16:01 <dpl> I'll try (I remember trying) If I get any error, I'll let you know
14:16:07 <P4Titan> Ohh, is there any reason as to why so?
14:16:16 <bennofs> shachaf: hmm, I'm not sure. It might require classical logic, right?
14:16:21 <dpl> benzrf:  what I'm wondering though is why is this happening
14:16:47 <srhb> P4Titan: Nope.
14:16:48 <shachaf> bennofs: I was just thinking about Not Any.
14:17:00 <P4Titan> Thanks anyway
14:17:01 <shachaf> Since Any :: Bool, after all. :-(
14:17:01 <dpl> benzrf: It works, thanks :D
14:17:04 <bennofs> shachaf: oh, Any inhibits every kind? :|
14:17:08 <bennofs> ah
14:17:20 <shachaf> bennofs: It's a real scow, isn't it?
14:17:23 <shachaf> You can even match on it.
14:17:45 <srhb> P4Titan: One might argue that definitions are easier to read when they have the same number of parameters in every equation, but I think the exact reason is lost to history.
14:18:02 <bennofs> shachaf: yes, that sucks. I wanted to annotate my game tree with the player who currently has to do the next turn (2 player game)
14:18:17 <srhb> (There are some slightly semantic justifications too, but...)
14:18:44 <ReinH> Where can I find cabal-install binaries these days? I read https://www.haskell.org/cabal/download.html but it lies.
14:18:50 <srhb> P4Titan, pavonia: http://stackoverflow.com/a/8745774/288913
14:18:50 <dpl> benzrf: Thanks for the help :)
14:18:53 <verement> I would imagine it simplifies the pattern matching code to have the same number of arguments in each case
14:19:06 <ReinH> It says "Binaries for cabal-install-1.22.2.0 for the following Linux & OSX platforms are available on Halcyon." but they aren't anywhere on that site that I have been able to find.
14:19:12 <saml> is there name for \a b -> ()   ?
14:19:18 <saml> mute?
14:19:32 <srhb> saml: Shouldn't that be mute2 if anything
14:19:33 <saml> fmap (\a b -> ())  m1 <*> m2
14:19:36 <benzrf> dpl: no problem o.O
14:19:43 <saml> @pl fmap (\a b -> ())  m1 <*> m2
14:19:43 <lambdabot> fmap (const (const ())) m1 <*> m2
14:20:07 <benzrf> saml: 
14:20:08 <benzrf> :t (<$)
14:20:08 <benzrf> @ping
14:20:08 <lambdabot> pong
14:20:08 <lambdabot> Functor f => a -> f b -> f a
14:20:10 <benzrf> ah
14:20:21 <benzrf> () <$ (m1 >> m2)
14:20:33 <benzrf> or alternatively
14:20:41 <benzrf> (const () <$ m1) <*> m2
14:20:52 <mniip> ronh, interesting
14:20:53 <benzrf> you might prefer (*>) for applicative
14:21:41 <pavonia> srhb: I don't understand that explanation :S
14:21:54 <saml> man those operators
14:23:59 <saml> what's name of <$ ?
14:24:08 <saml> and why no $> ?
14:24:24 <bennofs> shachaf: hmm, but if I have a singleton for my bool, I can just pattern match the singleton and deal with the cases manually :)
14:27:06 <saml> so   fmap (\a b -> ())      vs.   (const () <$)    which one is better to read?
14:28:17 <Rotaerk> saml, I'd go with the latter
14:28:33 <saml> any reason?  i don't even know how to pronounce <$
14:28:47 <saml> const unit lift ?
14:28:54 <Rotaerk> should it be pronounceable?
14:29:04 <arkeet> I pronounce it like "uhh"
14:29:19 <arkeet> in my head
14:29:21 <arkeet> maybe
14:29:21 <mniip> lift would be fmap
14:29:22 <monochrom> neither is better.
14:29:30 <mniip> <$ is less money
14:29:34 <saml> yah, i think pronouncing things is good
14:29:36 <monochrom> ((\a b -> () <$>) is better
14:29:37 <arkeet> where are you using this anyway
14:29:40 <saml> monochrom, how would you write?
14:29:51 <monochrom> err, ((\a b -> ()) <$>)
14:29:58 <bernalex> saml: isn't that fmap (const (const ()))? lol
14:30:13 <saml> monochrom, why <$> instead of fmap?
14:30:24 <bennofs> monochrom: I don't like that at all (to much ()'s for me)
14:30:28 <saml> <$> has higher priority.. so i gues it's okay
14:30:29 <monochrom> they are all close ties. I wouldn't seriously pick a winner.
14:30:36 <saml> i used fmap so that i won't need to parenthesize
14:30:43 <bernalex> I might have srsly written 'fmap $ const . const ()'
14:30:45 <glguy> There's always:   x *> y $> ()
14:30:54 <bernalex> glguy's is nice
14:31:05 <saml> actually <$> and <*> have same priority
14:31:12 <KaneTW> is there a random generator available in lambdabot  (like getStdGen, but not bound to IO)
14:31:26 <mniip> newStdGen
14:31:26 <arkeet> :t mkStdGen -- make a StdGen with a given seed
14:31:27 <lambdabot> Int -> StdGen
14:31:31 <mniip> er mk
14:31:33 <benzrf> saml: 05:19:32       benzrf │ () <$ (m1 >> m2)
14:31:33 <benzrf> or equivalently, () <$ (m1 *> m2)
14:31:46 <saml> fmap (,) (char 'a') <*> char 'b'        vs.    (,) <$> (char 'a') <*> char 'b'
14:31:57 <arkeet> vs. liftA2 (,) (char 'a') (char 'b')
14:32:09 <monochrom> I stick to <$> and <*>. I don't use all those <*, *>, <$, $> variants.
14:32:21 <saml> does hslint help me?
14:32:24 * saml tries
14:32:27 <knite> I hear this channel is super friendly. how do you guys feel about Haskell newbies with silly questions?
14:32:34 <monochrom> my reason is not "they are symbols". if they were alphabetical, I would still not use them.
14:32:38 <mniip> knite, as long as you're tring
14:32:40 <arkeet> silly questions are welcome! (as long as they're about haskell)
14:32:41 <mniip> trying*
14:32:42 <monochrom> my reason is "too many variants"
14:32:52 <Tene> knite: You might also consider #haskell-beginners if you want more beginner-focused conversation.
14:33:00 <arkeet> mhm
14:33:20 <glguy> #haskell is just fine for beginners and beginner questions
14:33:23 <frerich> Tene: Beginner questions are perfectly fine here AFAIK.
14:33:31 <bernalex> they are.
14:33:34 <Tene> frerich: Yep, certainly.
14:33:39 <knite> Tene: well, I'm an experienced developer, just not with Haskell specifically.
14:33:42 <saml> monochrom, <*, *>, <$, $>  aren't needed at all?
14:33:45 <bernalex> #haskell love beginners. new people using haskell? weee. :)
14:33:54 <kadoban> They are, just sometimes conversations move quite quickly here, so it can be hard to keep up.
14:33:56 <saml> why are they there when not needed?
14:34:08 <knite> I'll try to route questions to the appropriate channel based on *how* beginnerish they seem.
14:34:09 <ReinH> saml: Why does anything that isn't necessary exist?
14:34:18 <ReinH> Some people like that they do exist, enough to make them exist.
14:34:30 <Tene> frerich: Some people happen to be more comfortable in beginner-specific spaces; I was just mentioning it as an option, since they seemed concerned about it.
14:34:41 <saml> maybe haskell should be more ass like Go
14:34:47 <saml> i mean more opinionated
14:34:49 <Tene> knite: I've never seen anyone express concern about beginner questions in here.
14:35:09 <monochrom> "need" is a huge subjective grey area
14:35:12 <srhb> knite: It really changes a lot based on the current audience and their questions. Rest assured all questions about Haskell are welcome. :)
14:35:21 <bernalex> knite: this chan has a bunch of beginner questions. they often dominate the channel even. :)
14:35:30 <saml> <*, ... can be expressed with <*> and <$>  right?
14:36:05 <monochrom> 50 shades of need
14:36:30 <monochrom> "do you *need* to handcuff me?!"
14:36:55 <ToBeReplaced> evaluating haskell for an embedded project -> ARMV7, will need syscalls (ioctl)... stability matters in this case -- haskell an okay fit?
14:36:56 <knite> so, I'm working through some programming challenges as (hopefully) a quick ramp up into Haskell. a bit stumped on the "right" way to do the following: given a string like "5Stuff", I need to parse that into (5, "Stuff"), and then get the 5th char from the word. I have a good idea on how to do the second part, but not the first.
14:37:08 <monochrom> "yes! and I need <$ engraved in the handcuff!"
14:37:09 <knite> do I have to use a regex library?
14:37:29 <srhb> knite: You almost never use regex libraries in Haskell
14:37:35 <shachaf> What is a string like "5Stuff"?
14:37:38 <srhb> (Well, there are often better ways!)
14:37:46 <knite> srhb: that was why I asked. :-)
14:37:48 <arkeet> > (reads :: ReadS Integer) "5Stuff"
14:37:50 <lambdabot>  [(5,"Stuff")]
14:37:57 <srhb> arkeet: Was just about to call that method cheaty :P
14:38:00 <arkeet> lol
14:38:03 <hiptobecubic> regex libraries in haskell are also pretty terrible to use
14:38:07 <saml> is there a way to list all files an installed cabal package contains
14:38:08 <ski> > case (reads :: ReadS Integer) "5Stuff" of [(n,rest)] -> rest !! (n-1); _ -> error "sorry"
14:38:08 <ToBeReplaced> also, where can i find out how to use ioctl? i don't see anything in LTS haskell
14:38:09 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘Integer’
14:38:09 <lambdabot>      In the first argument of ‘(-)’, namely ‘n’
14:38:09 <lambdabot>      In the second argument of ‘(!!)’, namely ‘(n - 1)’
14:38:18 <ski> > case (reads :: ReadS Int) "5Stuff" of [(n,rest)] -> rest !! (n-1); _ -> error "sorry"
14:38:19 <lambdabot>  'f'
14:38:25 <saml> i did cabal install hlint.. but not sure where hlint executable is
14:38:28 <bennofs> hiptobecubic: I like regex-applicative, which is not really regex though :)
14:38:33 <saml> not under ~/.cabal/bin
14:38:43 <knite> er, just to be clear, the head of the string is an integer, but that integer may be greater than 10. eg "450AReallyLongString".
14:38:44 <frerich> knite: One idea might be to build a tuple '(a,b)' where 'a' is all the digits at the start of the given string and 'b' is everything except the leading digits. The two functions 'takeWhile' and 'dropWhile' may be useful for this (together with 'isDigit')
14:39:12 <knite> ooh, takeWhile and isDigit, those sound like exactly what I need!
14:39:21 <bennofs> frerich: or just use span
14:39:26 <bennofs> > span isDigit "123abc"
14:39:28 <lambdabot>  ("123","abc")
14:39:44 <frerich> bennofs: Sure, there are a lot of ways to do this. I'm just proposing something to get started. :-)
14:39:56 <ski> knite : `reads' is for parsing Haskell (expression) representations of values, including parsing numeric literals, for the number types
14:40:16 <ski> > (reads :: ReadS Integer) "-8Stuff"
14:40:18 <lambdabot>  [(-8,"Stuff")]
14:40:55 <monochrom> you can safely use "read" in this case, since you have already used isDigit to cleanse the string.
14:41:10 <arkeet> > (reads :: ReadS Int) "1234blah"
14:41:11 <monochrom> oh, you want to use reads to do both
14:41:11 <lambdabot>  [(1234,"blah")]
14:41:13 <knite> oh, hm. I originally started with read and a Maybe type. hadn't found reads yet. let me jump in the hole for a bit and try all the functions you guys just introduced.
14:41:25 <arkeet> > (reads :: ReadS Int) "notanumber"
14:41:27 <lambdabot>  []
14:41:51 <arkeet> you could also use some other parser library
14:41:53 <srhb> knite: reads is often considered a bit dated (it uses empty list rather than Nothing to represent failure, but is really the same)
14:41:59 <arkeet> :t parse
14:42:00 <lambdabot> Not in scope: ‘parse’
14:42:03 <arkeet> :<
14:42:04 <frerich> bennofs: For some reason I start out suggesting a simple (though length) solution and then incrementally go 'oh, but there's a function for this already' :-)
14:42:14 <knite> by the way, I like your convention of ">" for sharing code. have never seen that in any other channel, I dig it.
14:42:26 <srhb> knite: lambdabot reacts to that, hence... :)
14:42:41 <frerich> knite: It's understood by the 'lambdabot' IRC command.
14:42:46 <monochrom> actually > is not really for sharing code
14:42:59 <ski> @paste
14:42:59 <lambdabot> Haskell pastebin: http://lpaste.net/
14:43:14 <ski> if you want comments on some non-trivial code
14:44:37 <kadoban> knite: Just as an aside, programming challenges don't sound like a good way to learn haskell. Haskell is quite a bit different from most programming languages people know. A good focused introduction, like https://github.com/bitemyapp/learnhaskell will probably save you a lot of time.
14:46:45 <knite> kadoban: that's fair. I've already read a few of the beginner guides. but I need an excuse to actually *write* some code, y'know?
14:47:26 <monochrom> exercises will get you to actually write some code
14:47:39 <knite> FWIW the one I'm working on (already expired, so I'm not "cheating") is billed as specifically for functional languages. I figured that was good enough.
14:47:50 <monochrom> exercises are referenced in https://github.com/bitemyapp/learnhaskell
14:48:44 <monochrom> for example it links to a CIS 194 course.
14:48:52 <MP2E> I think exercises are a great way of learning haskell, just it's more difficult to jump into examples from the get-go. You need some theory first
14:48:57 <monochrom> the exercises in CIS 194 are famous
14:49:38 <flixil> Hello, I have a Seq of Int  [a,b,c,d,e]  and I would like to produce  [b+d,c+e,a+d,b+e,a+c]...   so to speak, each position should go to 2 positions on the right and to 4 positions on the right thinking the list as a circular list
14:50:18 <flixil> This doesn´t look like a map, or fold, or scan... what is it like and how could it be achieved?
14:50:32 <arkeet> > take 5 (let l = cycle [a,b,c,d,e] in zipWith (+) (drop 1 l) (drop 3 l))
14:50:34 <lambdabot>      Ambiguous occurrence ‘a’
14:50:34 <mietek> ReinH: hi. I see you’re looking for cabal-install binaries?
14:50:34 <lambdabot>      It could refer to either ‘L.a’, defined at L.hs:144:1
14:50:34 <lambdabot>                            or ‘Debug.SimpleReflect.a’,
14:50:37 <arkeet> uh
14:50:38 <arkeet> @undefine
14:50:38 <lambdabot> Undefined.
14:50:47 <arkeet> > let l = cycle [a,b,c,d,e] in take 5 (zipWith (+) (drop 1 l) (drop 3 l))
14:50:48 <lambdabot>  [b + d,c + e,d + a,e + b,a + c]
14:50:49 <ReinH> mietek: Hi! Yep.
14:50:50 <kadoban> flixil: Sounds vaguely like zipWith (+), except Seq
14:51:01 <mietek> ReinH: perhaps join #haskell-deployment, as it’s lower-traffic
14:52:13 <blogle> can you capture metakeys with haskeline?
14:52:16 <knite> if anyone's curious, here's the short list of Haskell resources I've collected: https://gist.github.com/pikeas/03da229ef398c21d7171 haven't read through all of them yet, of course.
14:52:31 <knite> let me know if any of them are secretly terrible.
14:52:44 <monochrom> haskeline probably intercepts metakeys for its own purpose and not let you see it.
14:52:50 <gremble> knite: that takes the fun out of it
14:53:05 <monochrom> haskeline is the exact opposite of "let me know raw key events"
14:53:28 <knite> gremble: well, then I'll be sure to ask you all of my most misguided questions. :-)
14:53:35 <flixil> wow arkeet... that is it
14:53:43 <blogle> bummer.. vty looks like it could possibly do what I want, however it is lacking docs and looks like I would have to largely restructure my code around it
14:53:52 <gremble> knite: Jokes on you. I know nothing about haskell. :P
14:54:03 <knite> then we're roughly on par!
14:54:56 <flixil> kadoban: I said Seq because is a list... But it is just that as I need to update the list on indices I was thinking on Seq or array
14:55:06 <blogle> yeah, it would be nice if you could extract more out of haskeline
14:55:50 <flixil> arkeet: I am impressed I was thinking that what I was asking for was more difficult to express without using index
14:56:53 <ski> knite : i suppose you've seen <http://norvig.com/21-days.html> at some point ?
14:57:45 <knite> ski: a long time ago. :-)
14:57:57 <ski> good
14:58:10 <knite> never said I was in a rush to learn Haskell. making sure I do it right, not quickly.
14:58:45 <ski> yes (i just reacted on seeing <https://wiki.haskell.org/Learn_Haskell_in_10_minutes>)
14:59:15 <knite> ah, well, poor title, eh? "A brief overview of Haskell" wouldn't have the same ring to it.
15:02:40 <monochrom> I am just a bit disappointed that there is no sequel to "9 topics that don't fit in 10 minutes"
15:03:43 * hackagebot pred-trie 0.1 - Predicative tries  http://hackage.haskell.org/package/pred-trie-0.1 (athanclark)
15:03:44 <monochrom> someone should add a "8 subjects that don't fit in 9 topics". and continue with "7 ditto 8 ditto" etc.
15:04:44 <ryanprior> 3 UTF-8 code points that don't fit in 4 bytes
15:05:06 <glguy> monochrom: I think that eventually leads to "6-Minute Abs"
15:05:16 <levi> One weird trick that drives functional programmers crazy.
15:05:24 <monochrom> 5 golden rings that don't fit in 6-minute abs?
15:05:40 <rui2> When cabal install in a sandbox says "all packages are required to have consistent dependencies", what does it mean?
15:06:07 <rui2> That if pckg A requires B and C, and both B and C require D, then both D versions must be the same?
15:07:32 <hiptobecubic> i believe so
15:08:34 <a_cowley> ey
15:08:34 <ReinH> rui2: it must be able to unify each transitive dependency to a single version that satisfies all constraints.
15:08:44 <hiptobecubic> essentially you should be able to have one and only one version of each library that you transitively depend on or it gets upset.
15:08:47 <hiptobecubic> Yes, that
15:09:29 <rui2> ReinH makes sense. If it can't there's not much one can do, right?
15:09:30 <ReinH> hiptobecubic: heh, this is on my mind at the moment as I once again dive into our build system.
15:09:39 <ReinH> rui2: It can let you know in a more or less helpful way!
15:10:10 <hiptobecubic> rui2, you can adjust the constraints on the offending packages, which are often too tight, and then hope.
15:10:29 <rui2> hiptobecubic: great
15:10:35 <rui2> and what are backjumps?
15:10:52 <hiptobecubic> backtracking in the search space i think
15:11:18 <ReinH> That's my understanding
15:11:38 <ReinH> something like --max-backjumps=100 --reorder-goals can sometimes help
15:11:44 <ReinH> other times it just makes it take longer for no effect
15:11:49 <rui2> thanks!!
15:12:01 <rui2> Any tool to visualize the dependencies?
15:16:14 <benzrf> what do you call it when u have a Kleisli w where w is for Comonad
15:16:50 <hpc> this feels like the setup to a joke
15:16:58 <PlotCitizen> ^
15:17:28 <benzrf> legit question tbh
15:17:32 <benzrf> well to be precise
15:17:44 <benzrf> oh nvm
15:18:07 <hpc> and the funnies triumph over math yet again!
15:18:24 <PlotCitizen> Hey I'm trying to install a package on Hackage using cabal-install and it has ncurses as a dependency and it's trying to build it but fails because it's already installed. I'm on OS X if that helps. What do I do?
15:19:53 <glguy> PlotCitizen: Put as much of the output and error messages as you can on the pastebin so that people will have what they need to help
15:21:24 <PlotCitizen> Here you go glguy
15:21:26 <PlotCitizen> http://lpaste.net/131712
15:21:43 <disgrntld> hey gang, silly question but how can I produce a Maybe value from a predicate? something like (a -> Bool) -> a -> Maybe a.. I'm sure there's a simple built-in but I'm brain-farting
15:21:46 <glguy> PlotCitizen: setup-Simple-Cabal-1.22.2.0-x86_64-osx-ghc-7.10.1: The program 'c2hs' version
15:21:47 <glguy> >=0.15 is required but it could not be found.
15:22:35 <PlotCitizen> I saw that as I was copying it
15:22:51 <arkeet> :t \f a -> a <$ guard (f a)
15:22:52 <lambdabot> Alternative f => (a -> Bool) -> a -> f a
15:23:13 <bitemyapp> :t bool
15:23:14 <lambdabot> a -> a -> Bool -> a
15:23:15 <arkeet> :t \f -> (<$) <*> (guard . f)
15:23:16 <lambdabot> Alternative f => (a -> Bool) -> a -> f a
15:23:27 <glguy> or just
15:23:32 <glguy> 07\f a 07-> 07if f a 07then Just a 07else Nothing
15:23:46 <arkeet> or
15:23:50 <bitemyapp> glguy: no no. not fancy enough ;P
15:23:52 <arkeet> [a | f a] (with MonadComprehensions)
15:24:01 <glguy> oh, it just got real
15:24:06 <bitemyapp> LOL
15:24:39 <arkeet> am I missing a joke or something
15:24:47 <disgrntld> cool, thanks guys
15:24:49 <bitemyapp> arkeet: don't be afraid!
15:27:39 <glguy> arkeet: You just took it to a level that was going to be hard to compete with
15:27:46 <arkeet> ah
15:27:52 <glguy> I was ready to play: \f x -> find f [x]
15:28:00 <glguy> and you blew me out of the water
15:28:05 <arkeet> :t find <*> pure
15:28:06 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ a -> Bool
15:28:06 <lambdabot>     Expected type: (a -> Bool) -> t0 a
15:28:06 <lambdabot>       Actual type: a -> t0 a
15:28:09 <arkeet> oops
15:28:16 <arkeet> wrong
15:28:38 <arkeet> @pl \f x -> find f (pure x)
15:28:38 <lambdabot> (. pure) . find
15:53:09 <mjrosenb> does anyone here know if the pango bindings can be used to render to an SDL2 texture?
15:53:17 <flixil> Can someone give me a tip on how to use let in and where and why is not correct in the following function? http://pastebin.com/Wiinsz5q
15:53:29 <mjrosenb> which may or may not be distinct from an opengl texture
15:54:27 <mjrosenb> flixil: the syntax for let in is |let BINDINGS in EXPRESSION|
15:54:34 <mjrosenb> flixil: you don't have an expression there
15:54:46 <mjrosenb> so an example could be let x = 30 in 2*x
15:54:57 <mjrosenb> which would evaluate to 60.
15:55:16 <FireFly> Hehehe, that looks oddly familiar
15:55:49 <mjrosenb> rock, paper, scissors, lizzard, spock?
15:55:59 <mjrosenb> s/zz/z/
15:56:00 <FireFly> Yeah
15:56:16 * mjrosenb thinks he saw that in high school.
15:56:25 <FireFly> One of the tasks in a local programming compo had a problem involving that game
15:56:39 <mjrosenb> hah, not horribly surprised.
15:56:39 <FireFly> local programming compo last week*
15:56:59 <FireFly> Yeah, it's pretty common I guess
15:57:07 <flixil> ahh, lizard with one z :P
15:57:21 <hpc> but which z was the extra z?
15:57:47 <flixil> so what is wrong with http://pastebin.com/N2UpHcnw  there is no let clause now ??
15:58:30 <mjrosenb> FireFly: best variant I've seen thusfar: http://www.smbc-comics.com/index.php?db=comics&id=2131
15:58:36 <karshan> the single best change in ghc710 is that <$> is now in prelude. would everyone agree ?
15:59:16 <flixil> FireFly: I was in a meetup today on Scala (no haskell meetups in my city) that involved this game and I just started trying to solve it in haskell
15:59:36 <ski> flixil : perhaps you wanted `fmap select (randomRIO (0,k))' ?
16:00:15 <FireFly> mjrosenb: :D
16:00:25 <FireFly> flixil: I see
16:00:39 <kadoban> flixil: What's the error? You should really paste error messages with your code. By the way … that seems like the hard way to choose a random value of that type. Why not use randomIO ? (You might have to derive Bounded for the type)
16:01:22 <ski> kadoban : seems like they want to use a custom distribution, derived from `ls' ?
16:01:35 <kadoban> Oh, maybe
16:01:50 <Aruro> what is status of view patterns extension? is it going to become standard ? 
16:02:39 <srhb> Aruro: I don't think there's any current drive to create a new standard
16:02:47 <srhb> Aruro: I don't think that View Patterns are going away either.
16:03:01 <JagaJaga> filtered from lens doesn't guaranties me the order?
16:04:34 <srhb> Aruro: (They are from 2008 or so)
16:06:00 <flixil> Ok, looks like the game is now working (more or less) and should learn from playing against you to make it harder (if you use always the same things...)
16:06:08 <flixil> Please criticize http://pastebin.com/Ri0xeUgm
16:06:46 <Aruro> srhb: ok thanks, just wanted to understand what is consensus of the community on them
16:06:47 <flixil> I started with the code from http://rosettacode.org/wiki/Rock-paper-scissors
16:07:00 <ski> flixil : `fromEnum(a)' can be just `fromEnum a'
16:07:08 <flixil> :) thanks ski
16:07:10 <srhb> Aruro: "They are occasionally pretty nice."
16:07:36 <rui2> What's the problem with compiling 2 dependencies of a package, each requiring a different version of the same package?
16:08:45 <mjrosenb> does Ord imply a partial order?
16:08:55 <ski> flixil : i don't think you should instance `Ord Choice' like that at all
16:09:21 <monochrom> we take Ord to be a total order
16:09:23 <ski> mjrosenb : total order, i think
16:09:29 <mjrosenb> ski: even better!
16:09:30 <arkeet> if B and C depend on different versions of A, then data types from A used by B won't be compatible with the same types from A used by C.
16:09:33 <arkeet> rui2
16:09:37 <monochrom> however, every total order is a partial order, too
16:09:43 <arkeet> monochrom got there before me.
16:09:44 <mjrosenb> yearh, I guess it has equal, but not uncomparable
16:10:15 <mjrosenb> ski: then again, there is Ord for ieee-754 values, isn't there?
16:10:23 <ski> flixil : i suggest just defining `beats' directly
16:11:30 <flixil> ski i didn´t know how to do that without defining the Ord
16:12:33 <flixil> ski, the Ord Choice is based on the fact that the game of rock, paper, scissors, lizard, spock is a pentagon
16:12:43 <arkeet> well, you just defined (<=) for Choice
16:12:45 <kadoban> flixil: Just define beats in terms of something else … like pattern matching would work.
16:12:48 <arkeet> and you are using (>) for Choice
16:12:52 <arkeet> where a > b = not (a <= b)
16:13:01 <arkeet> so just inline your definition of (<=) in there.
16:13:03 <flixil> ski, and that a hand on the pentagon will beat the next and 3rd next after him
16:13:18 <arkeet> also it doesn't look like you're defining a valid ordering anyway.
16:13:36 <rui2> arkeet: Oh, right
16:13:40 <arkeet> (doesn't look transitive.)
16:13:45 <rui2> What if they just use it internally, and don't reexport anything?
16:14:10 <arkeet> rui2: then it might work I suppose.
16:16:23 <ski> flixil : defining `(<=)' suggests that if `a <= b' and `b <= c' are both `True', then `a <= c' should also be `True'. this isn't the case for your definition
16:16:46 <flixil> ski, let me think on this
16:16:53 <ski> (take e.g. `a = Scissors; b = Spock; c = Lizard')
16:17:41 <arkeet> and thus anything that relies on having a well-behaved Ord instance will go wrong.
16:18:00 <flixil> Why am I implying transitivity?
16:18:11 <kadoban> flixil: Because that's what Ord means.
16:18:28 <flixil> mmmm... I just wanted to define it for pairs
16:18:29 <arkeet> Ord instances are supposed to correspond to total orderings.
16:18:32 <kadoban> flixil: You're not using it for anything except the definition of 'beats', so just … define 'beats' without that, and get rid of the Ord instance.
16:19:06 <monochrom> partial orders are transitive
16:19:27 <pdxleif> Why doesn't getArgs give you args[0]?
16:20:00 <arkeet> pdxleif: because you use getProgName for that.
16:20:05 <slack1256> Guys what was the name of that library to play beats/sound programatically from haskell
16:20:09 <flixil> ok kadoban ski done :) thanks for this input
16:20:16 <flixil> Didn´t think of Ord as total ordering
16:21:08 <trizko> hi guys
16:21:12 <arkeet> lots of things (like sorting, or binary search trees (which are used by e.g. Map)) rely on Ord giving a total ordering to work properly.
16:21:18 <flixil> Is it ok to use Data.Sequence, then convert it back to list and so on?
16:21:25 <arkeet> what for?
16:21:29 <kadoban> pastebin really makes haskell look like crap … does it really have to do that to strings? So ugh. Even ignore that it doesn't recognize ' as being part of a variable name …
16:21:50 <arkeet> you're not actually using Data.Sequence anywhere.
16:21:55 <arkeet> or are youy
16:22:39 <arkeet> well
16:22:41 <flixil> inside game function, to udpate the list in an index position
16:23:18 <trizko> can someone help me understand why i'm getting an error from this code: http://pastebin.com/5UQk0yPc
16:23:44 <arkeet> if your list only ever is 5 elements long, then there's probably no value in using Data.Sequence
16:24:07 <trizko> i'm an extreme newb to haskell and i'm just trying to understand the basics
16:24:19 <arkeet> but I guess your list is supposed to represent some sort of count for each choice.
16:24:24 <arkeet> so maybe you should just use a Map.
16:24:26 <arkeet> Map Choice Int
16:24:47 <arkeet> (except it should be a total map, so uh.)
16:25:09 <kadoban> trizko: The type of your function is is [a] -> [a], but you haven't specified that, and in the recursive use, you're treating it like it's [a] -> a
16:25:22 <kadoban> trizko: What are you using to learn haskell, out of curiosity?
16:26:21 <trizko> a tutorial on plural sight called "Haskell Fundamentals Part 1"
16:26:31 <flixil_> sorry my laptop ran out of batery
16:26:51 <kadoban> trizko: I dunno what that is. You should look at https://github.com/bitemyapp/learnhaskell instead, it has good advice
16:26:56 <flixil_> I was just asking about using data.seq and lists for the same data
16:28:09 <Aruro> after reading this https://wiki.haskell.org/Arrays i got confused, what do i use for bicubic interpolation?  http://en.wikipedia.org/wiki/Bicubic_interpolation
16:28:18 <trizko> kadoban: thank you!
16:28:23 <srhb> trizko: Your code will be a lot more legible if you eschew head and tail for destructuring via patterns
16:28:50 <imPure> I'm using GHC 7.10.1 - {- LANGUAGE UnicodeSyntax -} isn't being picked up, but using -XUnicodeSyntax on the command line works.
16:29:21 <srhb> trizko: doubleNumbers [] = []; doubleNumbers (x:xs) = 2*x : doubleNumbers xs -- for instance. And you might consider making a generic version of this function that uses a parameter as the function instead of (*2)
16:29:25 <kadoban> imPure: Is it at the very top? Also that looks not quite right, isn't it supposed to have # or something in there?
16:29:25 <imPure> I expect that this is a bug, but I could be misinterpreting things.
16:29:26 <glguy> imPure: Use: {-#
16:29:26 <monochrom> trizko: see my http://www.vex.net/~trebla/haskell/crossroad.xhtml for why pattern matching
16:29:42 <imPure> Doh.
16:29:44 <glguy> imPure: {-# LANGUAGE Whatever #-}
16:30:45 <imPure> Ok, that worked. Now... is there a way for me to get ghc compiles to pickup the contents of my .ghci file?
16:31:01 <monochrom> no, .ghci is just for ghci
16:31:18 <imPure> monochrom: Is there any way to specify system-wide settings for ghc?
16:31:25 <srhb> imPure: You should probably cabalize your project at the point where you start asking these questions :)
16:31:26 <imPure> monochrom: Or project-wide.
16:31:37 <trizko> srhb: thank you, i'm very new to the language(i've only been coding in it for about 1 hour) and i was wondering why if i remove the ": []" at the end of my else it work but if i leave it in i get that error in the title
16:31:38 <kadoban> imPure: Sounds like a job for a cabal file
16:31:52 <srhb> trizko: Because you're constructing an infinite type
16:32:09 <imPure> srhb/kadoban: I may work somewhere where we have a custom build system.
16:32:10 <kadoban> trizko: Because (:) constructs a list.   The thing on the left is an element of the list. The thing on the right is the rest of the list.
16:32:25 <Aruro> monochrom: who was first to introduce pattern matching?
16:32:27 <srhb> trizko: If (doubleNumbers (tail numbersList)) is [a], and you cons it onto [a], then you get [[a]], but then in the next recursion if you cons onto that you get [[[a]]]
16:32:30 <srhb> trizko: etc
16:32:30 <lpaste> arkeet pasted “flixil_” at http://lpaste.net/131713
16:32:44 <imPure> srhb/kadoban: Not that I can't use cabal files... Any way to make ghc pick up the settings in a cabal file?
16:32:45 <srhb> Cons it onto []* rather
16:32:50 <monochrom> I don't know. the oldest I saw is ML
16:32:58 <kadoban> imPure: Then we may have a different answer. Should we continue the rest of the conversation in weird hypotheticals?
16:33:03 <trizko> oooooohhhhhhh 
16:33:04 <arkeet> flixil: ^
16:33:05 <srhb> imPure: Sorry, I don't know
16:33:07 <Aruro> monochrom: so it comes from logic?
16:33:17 <srhb> trizko: Penny dropped? :D Such a nice feeling.
16:33:28 <trizko> srhb kadoban thank you!
16:33:42 <imPure> srhb/kadoban: Actually, the most immediate issue: I'm using hdevtools and I want to pick up project wide settings rather than putting them on every file. Will hdevtools pick cabal settings up?
16:33:58 <monochrom> I cannot answer.
16:34:02 <kadoban> imPure: Yeah, it seems to
16:34:13 <imPure> kadoban: Then I'll give that a try. Thank you.
16:34:51 <srhb> imPure: I think the only non-cabalized solution is to use an alias for ghc with the options
16:35:34 <flixil> arkeet: map Choise int :)   so you mean creating a function different each time that would map all Choises to 0 and the actual one to 1 and   map   this and (+) somehow to sum?
16:36:16 <arkeet> flixil: I'm suggesting that you don't need to use Enum, and you use your Choice values directly to index your history.
16:36:20 <Aruro> monochrom: ok, it seems to be one of the first is again lisp. https://en.wikipedia.org/wiki/Pattern_matching#History
16:36:21 <flixil> sorry for the possibly stupid questions, it is my very first attempt on a writing a haskell program (and I didn´t even write the skeleton)
16:36:42 <arkeet> so start off with a Map (from Data.Map) that maps each value to 0
16:37:26 <arkeet> and then use Map functions to update them.
16:37:29 <arkeet> update it.
16:38:31 <flixil> I see... using a map as a kind of hash(choise) = newvalue somehow
16:39:00 <flixil> and then traerse the map to construct back the list to construct the computer strategy on playing hand
16:39:04 <flixil> traverse
16:39:26 <flixil> the map is a tree, so it should be foldable
16:39:53 <arkeet> btw
16:39:57 <arkeet> for Map to work with Choice as key
16:40:02 <arkeet> you really do need a valid Ord instance on Choice
16:40:07 <arkeet> (just derive Ord)
16:40:29 <flixil> ok, I can do that now that I don´t have an Ord defined
16:40:31 <knite> why can't I/how do I let s <- readFile 'foo' in the repl?
16:40:42 <arkeet> s <- readFile foo
16:40:57 <glguy> 'foo' isn't "foo"
16:40:59 <ronh> remove let, and use "foo" or foo
16:41:08 <arkeet> oh yeah, if 'foo' is supposed to be a filename then it's "foo"
16:41:30 <knite> er, yes, I meant double quotes. typoed here, did correctly in ghci, still fails.
16:41:31 <arkeet> > 'foo'
16:41:32 <lambdabot>      Syntax error on 'foo'
16:41:32 <lambdabot>      Perhaps you intended to use TemplateHaskell
16:41:32 <lambdabot>      In the Template Haskell quotation 'foo'
16:41:37 <arkeet> lol
16:41:39 <srhb> knite: Still get rid of the let.
16:42:02 <knite> gotcha. so I need let for plain variable assignment, but not when doing IO?
16:42:21 <flixil> Thanks a lot arkeet, I will continue tomorrow changing the game and incorporating the Map
16:42:22 <srhb> knite: Right
16:42:23 <pavonia> arkeet: Is that parsed as TH variable foo'?
16:42:25 <Denommus> is there a haskell library for SOAP clients?
16:42:35 <srhb> knite: Basically the repl is a giant IO do block
16:42:37 <arkeet> pavonia: I guess so.
16:42:39 <Denommus> yes, I know, SOAP sucks balls, REST is better, and I wish I could do something about that
16:42:49 <srhb> knite: Which is also why let foo = blah is legal at all
16:42:52 <Denommus> but the server is SOAP and there's nothing I can do about it
16:42:56 <srhb> knite: (It's not in top level Haskell)
16:43:46 * hackagebot edit-distance-vector 1.0.0.2 - Calculate edit distances and edit scripts between vectors.  http://hackage.haskell.org/package/edit-distance-vector-1.0.0.2 (ThomasSutton)
16:43:48 * hackagebot nested-routes 0.3.1 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-0.3.1 (athanclark)
16:44:50 <srhb> Denommus: Hackage says soap is up to date
16:45:22 <Denommus> srhb: it didn't compile here
16:45:24 <imPure> hdevtools doesn't pick up the default-extensions.
16:45:33 <srhb> Denommus: Might want to try with Stackage
16:49:34 <Denommus> srhb: I guess the problem is with a library that has a type that doesn't implement applicative for a monad
16:49:44 <srhb> Denommus: Right, iconv. You'll have to fix that manually
16:50:05 <Denommus> srhb: ah
16:57:57 <rui2> arkeet: If it might work, how would you compile that?
16:58:14 <arkeet> you don't.
16:58:50 <athan> How long does it usually take for an upload to hackage to reciporacate with `cabal update` calls?
16:58:51 <arkeet> actually I dunno if cabal lets you.
16:59:02 <rui2> arkeet: I see
16:59:13 <arkeet> but it's not a good idea anyway.
17:00:58 <erikd> anyone know if ghc eventlogs are cross platform compatible? ive got an eventlog from armhf/linux, can i open that in threadscope on x86_64/linux?
17:01:11 <rui2> arkeet: Humm, why not? If you create your library L that uses D internally, wouldn't it be useful to "hard code" the version of D that it uses, so that if some other guy needs L, it can link to whatever version of D it needs?
17:01:31 <arkeet> rui2: I dunno.
17:01:38 <rui2> Ok thanks :)
17:01:53 <rui2> Just trying to understand the dependency mess...
17:01:55 <knite> so reads, which someone recommended earlier, has a lovely "feature". 
17:01:59 <knite> > (reads :: ReadS Int) "0xCkz"
17:02:01 <lambdabot>  [(12,"kz")]
17:02:15 <rui2> If anyone knows of a nice read about all that, please send link
17:02:15 <knite> expected 0, was parsed as hex instead.
17:05:00 <knite> how can I get it to, well, not do that?
17:05:57 <benzrf> > read "0xC" :: Int
17:05:58 <lambdabot>  12
17:06:07 <benzrf> knite: read does the same thing
17:06:22 <benzrf> knite: you could use takeWhile isDigit or something
17:07:36 <geekosaur> :t readDec
17:07:37 <lambdabot> (Eq a, Num a) => ReadS a
17:07:46 <benzrf> ooh nice
17:07:50 <arkeet> > readDec "0xckx"
17:07:51 <lambdabot>  [(0,"xckx")]
17:07:52 <geekosaur> @index readDec
17:07:52 <lambdabot> Numeric
17:08:24 <knite> woo, that'll do.
17:08:31 <knite> so many stdlib functions to learn...
17:08:46 <knite> quite the kitchen sink you guys have going here.
17:08:53 <srhb> knite: Kitchen sinks are best sinks!
17:09:05 <Aruro> knite: or you can just learn parsec
17:09:19 <srhb> knite: Also what good is a language that rocks at combining functions if you don't have a boatload of them :-)
17:12:43 <grandpascorpion> test
17:16:12 <johnw> funtions are the vocabulary of our language
17:16:19 <JagaJaga> @pl \a -> foo (bar a) a
17:16:19 <lambdabot> foo =<< bar
17:16:48 <Aruro> > Text.Show.showsPrec 0 12 ""
17:16:49 <lambdabot>  Not in scope: ‘Text.Show.showsPrec’
17:17:02 <arkeet> > showsPrec 0 12 ""
17:17:03 <lambdabot>  "12"
17:17:08 <Aruro> > showsPrec 0 0xC ""
17:17:10 <lambdabot>  "12"
17:17:15 <arkeet> well duh.
17:17:22 <arkeet> no one asks for show . read = id
17:17:25 <JagaJaga> :t (<<=)
17:17:26 <lambdabot>     Not in scope: ‘<<=’
17:17:26 <lambdabot>     Perhaps you meant one of these:
17:17:26 <lambdabot>       ‘<=’ (imported from Data.Ord), ‘<<<’ (imported from Control.Arrow),
17:17:28 <JagaJaga> :t (=<<)
17:17:29 <lambdabot> Monad m => (a -> m b) -> m a -> m b
17:17:30 <Aruro> :)
17:17:45 <JagaJaga> Can you explain me this, guys?
17:17:52 <arkeet> what part?
17:18:03 <srhb> The reader monad, I think?
17:18:07 <arkeet> are you wondering why that's equivalent to the thing?
17:18:07 <JagaJaga> \a -> foo (bar a) a == foo =<< bar
17:18:15 <arkeet> consider m = (r ->)
17:18:16 <JagaJaga> yeah
17:18:22 <arkeet> (=<<) :: (a -> r -> b) -> (r -> a) -> r -> b
17:19:19 <JagaJaga> What kind of sorcery is this? :)
17:19:25 <JagaJaga> awesome
17:20:01 <srhb> JagaJaga: We call it the Reader monad if you want to read up on it more.
17:20:18 <JagaJaga> srhb: thx, gonna read
17:21:11 <Aruro> > join (*) 5
17:21:12 <lambdabot>  25
17:21:56 <Aruro> @pl f x=x*x
17:21:56 <lambdabot> f = join (*)
17:22:34 <arkeet> also consider (^2)
17:25:24 <Aruro> @src join
17:25:24 <lambdabot> join x = x >>= id
17:29:41 <Aruro> JagaJaga: to demystify look here http://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Base.html#line-621
17:30:49 <Aruro> JagaJaga: see how (>>=) defined for functions
17:31:29 <mmaruseacph2> or http://adit.io/posts/2013-06-10-three-useful-monads.html
17:32:02 <Aruro> JagaJaga: by the way its defined exactly as you wrote it :)
17:33:23 <JagaJaga> Aruro: nicely ^_^
17:33:43 <JagaJaga> Aruro: thank you :)
17:34:06 <Aruro> JagaJaga: uwm :)
17:36:58 <stepcut> I maintain a lot of packages. What is the best script for detecting which source repositories have changes that are newer than what is on hackage? I use nix if there are any nix-specific tools..
17:37:31 <ocramz> hi there
17:38:32 <ocramz> why doesn't this work? (flip.flip)==id 
17:38:44 <arkeet> you can't use == on functions
17:38:45 <stepcut> ocramz: halting problem
17:38:49 <Aruro> @src flip
17:38:49 <lambdabot> flip f x y = f y x
17:39:10 <Aruro> @src id
17:39:10 <lambdabot> id x = x
17:39:18 <ocramz> stepcut, arakeet: but one can substitute equals with equals
17:39:38 <ocramz> > :t \f x y -> f y x
17:39:39 <lambdabot>  <hint>:1:1: parse error on input ‘:’
17:39:40 <mmaruseacph2> but not let a computer program do the substitution
17:39:50 <arkeet> yes, and you can replace flip . flip with id in your code
17:40:01 <Aruro> :t \f x y -> f y x
17:40:02 <arkeet> because you can show externally that they are the same function
17:40:02 <lambdabot> (r1 -> r2 -> r) -> r2 -> r1 -> r
17:40:20 <blogle> is there a list of commands for lambdabot? 
17:40:30 <mmaruseacph2> @help
17:40:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:40:33 <mmaruseacph2> ^
17:40:38 <arkeet> blogle: /msg lambdabot @list
17:40:47 <Aruro> @listmodules
17:40:47 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
17:40:53 <blogle> arkeet thanks!
17:40:56 <Aruro> @help activity
17:40:56 <lambdabot> activity seconds. Find out where/how much the bot is being used
17:41:18 <pavonia> :t flip . flip
17:41:19 <lambdabot> (b -> a -> c) -> b -> a -> c
17:41:32 <mmaruseacph2> btw guys, HCAR submission deadline is on 17th of May, don't forget to send every piece of text about your packages :D
17:42:06 <stepcut> ocramz: it is unclear what exactly you are asking. But the reason the specific code you pasted can not be compiled is due to the halting problem. The compiler would need to prove that the functions of both sides of the == are equivalent, and that is known to be impossible in the general case. aka, the halting problem
17:42:17 <stepcut> eeek! I must submit!
17:42:37 <verement> what is HCAR?
17:42:41 <arkeet> well, the real reason is that there is no Eq instance on function types.
17:43:16 <mmaruseacph2> verement: Haskell Community and Activities Report
17:43:17 <arkeet> but the reason for that is that having a nontrivial total instance would solve the halting problem.
17:43:24 <mmaruseacph2> verement: haskell.org/haskellwiki/Haskell_Communities_and_Activities_Report
17:43:32 <arkeet> ocramz: == and = are different.
17:43:36 <arkeet> basically.
17:44:00 <ocramz> stepcut, arkeet: but the type expression coincides. This still puzzles me. So should I understand that they inferred types do not carry a forall ?
17:44:09 <arkeet> ?
17:44:31 <arkeet> there is an implicit forall.
17:44:32 <verement> thanks
17:44:44 <kadoban> ocramz: (==) doesn't compare types, it compares values
17:45:12 <ocramz> I mean, (a -> b -> c) -> (a -> b -> c) structurally coincide with a -> a
17:45:30 <ocramz> kadoban: good point, thank you
17:45:57 <stepcut> ocramz: (+) and (-) have the same type but are definitely not equal ;)
17:46:25 <ocramz> oh god now I got it. Sorry guys must be the late hour. Thanks stepcut
17:46:42 <pavonia> @check \x y -> x + y == x - y
17:46:43 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 2 shrinks):
17:46:43 <lambdabot>  0 1
17:46:47 <stepcut> :p
17:46:57 <stepcut> A solid proof!
17:47:13 <ocramz> stepcut: solid gold
17:48:48 * hackagebot aeson-diff 0.1.1.2 - Extract and apply patches to JSON documents.  http://hackage.haskell.org/package/aeson-diff-0.1.1.2 (ThomasSutton)
17:48:56 <Aruro> @hoogle a->a
17:48:57 <ocramz> pavonia: thanks for the example
17:48:57 <lambdabot> Prelude id :: a -> a
17:48:57 <lambdabot> Data.Function id :: a -> a
17:48:57 <lambdabot> GHC.Exts breakpoint :: a -> a
17:49:09 <Aruro> @hoogle Bool->Bool
17:49:09 <lambdabot> Prelude not :: Bool -> Bool
17:49:09 <lambdabot> Data.Bool not :: Bool -> Bool
17:49:09 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
17:50:05 <Aruro> @hoogle (a->b)->a->b
17:50:06 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
17:50:06 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
17:50:06 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
17:52:41 <Aruro> @djinn a->a
17:52:42 <lambdabot> f a = a
17:52:53 <Aruro> @djinn (a->b)->a->b
17:52:53 <lambdabot> f a = a
17:53:02 <jle`> Aruro: you can also use lambdabot in private message :)
17:53:30 <ocramz> might I rephrase my previous question? how can I reduce formulas that apply an operator A and its dual At to some data x to the identity?
17:53:33 <Aruro> jle`: seems djinn agrees with ocramz :)
17:54:24 <ocramz> Aruro: what's djinn?
17:54:50 <Aruro> @help djinn
17:54:51 <lambdabot> djinn <type>.
17:54:51 <lambdabot> Generates Haskell code from a type.
17:54:51 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
17:55:03 <ocramz> i.e. At A x -> Id x
17:55:42 <Cale> ocramz: Hm? If you're talking about linear operators, A^t A is rarely equal to A.
17:55:56 <Cale> er to Id rather
17:56:13 <Cale> You mean a function and its inverse?
17:56:14 <ocramz> sorry, not the transpose, the inverse
17:56:24 <ocramz> yes of course
17:56:35 <Cale> Okay, so what collection of functions are you working with?
17:57:10 <Cale> Perhaps there's a way to formally represent the fact that you have the inverse of a particular function, or to work with function and inverse pairs?
17:57:11 <arkeet> and what do you mean by "reduce"
17:57:31 <arkeet> equational reasoning in haskell is something you do by hand.
17:57:50 <ocramz> let's say linear operators, so the inverse is in general approximate. But I think in Haskell we can defer having to compute things numerically and reduce formulas symbolically as a first pass
17:57:54 <arkeet> (well, something outside haskell in any case.)
17:58:30 <Cale> ocramz: So you want to define some type of expressions for whatever it is that you're manipulating, along with a simplifier for those expressions and an interpreter for them
17:58:49 * hackagebot lenses 0.1.7 - Simple Functional Lenses  http://hackage.haskell.org/package/lenses-0.1.7 (JobVranish)
17:58:49 <ocramz> Cale: yes
17:59:39 <Cale> That's not going to just magically exist, you need to actually define the data type yourself, and write functions to do the manipulations.
18:00:36 <Aruro> @check \ x -> (read (show x)) == id x
18:00:38 <lambdabot>  +++ OK, passed 100 tests.
18:00:50 <Axman6> that only tests the () instance though
18:00:52 <arkeet> Aruro: that defaults to x :: ()
18:01:07 <Aruro> mm
18:01:12 <arkeet> @check \x -> show x == "()"
18:01:13 <lambdabot>  +++ OK, passed 100 tests.
18:01:15 <ocramz> Aruro: that's a very interesting example!
18:01:15 <jle`> @check \x -> x <> x == x
18:01:16 <lambdabot>  +++ OK, passed 100 tests.
18:01:18 <Axman6> @check \ x -> (read (show x)) == (x :: Double)
18:01:19 <lambdabot>  +++ OK, passed 100 tests.
18:01:27 <Axman6> much more interesting
18:01:29 <dmj`> jle`: makin' it rain
18:01:32 <Aruro> ocramz: seems its wrong :)
18:01:46 <jle`> ikr
18:02:19 <Axman6> @check \ x -> (read (show x)) == (x :: [Int])
18:02:20 <arkeet> ocramz: btw, ghc has such a thing as rewrite rules
18:02:21 <lambdabot>  +++ OK, passed 100 tests.
18:02:29 <arkeet> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/rewrite-rules.html
18:02:47 <arkeet> which might interest you
18:03:02 <Cale> ocramz: But be careful if you choose to use rewrite rules. GHC has no way of knowing that your rewrites are actually correct.
18:03:16 <arkeet> it at least typechecks them right
18:03:33 <Cale> Yeah, I believe it does at least that much
18:03:39 <ocramz> arkeet, Cale: yes I was reading the docs
18:04:04 <arkeet> ocramz: and it can be pretty useful for optimization
18:04:05 <arkeet> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.104.7401
18:06:33 <ocramz> arkeet: stream fusion, like what repa does
18:06:38 <arkeet> mhm
18:07:14 <arkeet> well, fusion at least.
18:08:49 * hackagebot paypal-adaptive-hoops 0.11.0.0 - Client for a limited part of PayPal's Adaptive Payments API  http://hackage.haskell.org/package/paypal-adaptive-hoops-0.11.0.0 (fanjam)
18:10:00 <ocramz> so: if we have Monoids, with an associative operation and an identity, what's needed to declare a Group class, with an invertible group operation?
18:10:23 <arkeet> just an additional method for the inverse.
18:10:39 <arkeet> but groups don't show up in haskell nearly as much as monoids.
18:10:59 <arkeet> so there's no such class in the standard libraries
18:11:19 <ocramz> but we cannot guarantee exact invertibility for all operators, or forall inputs
18:11:38 <c_wraith> ocramz: you can't guarantee associativity for Monoid instances, either
18:11:39 <arkeet> and we cannot guarantee that the monoid operation is associative.
18:11:52 <c_wraith> ocramz: you just declare instances that aren't associative to be buggy
18:11:57 <arkeet> it's not something you can prove to ghc.
18:12:14 <arkeet> so you just have to prove it to yourself and be satisfied.
18:12:33 <ocramz> c_wraith, arkeet: halting problem?
18:12:40 <ReinH> arkeet: I wish there were. Groups are still quite useful.
18:12:40 <arkeet> no
18:12:50 <arkeet> dependently typed languages let you do this.
18:13:02 <Aruro> arkeet: so its not really a monoid -- its something which talks, walks and barks like a monoid
18:13:14 <ocramz> let you _prove_ associativity to the compiler. very interesting
18:13:44 <arkeet> in a DT language you might have something like a monoid class where
18:13:47 <arkeet> the data in a monoid is
18:14:03 <arkeet> a binary operation, an element representing the identity, and then proofs that the operation is associative and the identity is an identity.
18:14:59 <ocramz> and isn't there anything in Hs that lets us approximate dependent types?
18:15:22 <arkeet> you can sort of fake it, but it's kind of impractical.
18:15:34 <arkeet> not to mention that in haskell, everything is provable.
18:15:42 <arkeet> :t undefined
18:15:44 <lambdabot> t
18:16:10 <ocramz> Hindley-Milner
18:16:38 <arkeet> nah it's not the type system, it's the fact that haskell is non-strict
18:16:46 <arkeet> by everything I mean
18:16:50 <arkeet> even things that are false.
18:17:08 <arkeet> thinking curry-howard here.
18:17:19 <arkeet> every type has at least one value, namely undefined
18:17:24 <arkeet> (or fix id, or let x = x in x ...)
18:17:49 <arkeet> which means via curry-howard, every proposition has a proof.
18:18:01 <arkeet> so the logic defined by haskell is inconsistent.
18:18:10 <shachaf> arkeet: @quote kmc curry
18:18:14 <shachaf> Er.
18:18:14 <arkeet> @quote kmc curry
18:18:14 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
18:18:17 <ocramz> or rather, it's missing some appropriate boundary conditions
18:18:30 <shachaf> Can't trust phones.
18:19:00 <arkeet> but that just means haskell is not a very good theorem prover.
18:19:14 <arkeet> doesn't really imply any weakness about haskell as a programming language.
18:19:23 <monochrom> agda is a very good theorem prover written in haskell
18:19:25 <shachaf> Alternatively, an extremely good theorem prover.
18:19:45 <arkeet> well, agda is a strict dependently-typed language.
18:19:49 <arkeet> rather unlike haskell.
18:21:12 <ion> shachaf: Haskell can prove any proposition, yes, but it pales in comparison to PHP which doesn’t even need a proposition to prove it.
18:21:48 <shachaf> Haskell can only prove prepositions that its type system is powerful enough to express.
18:21:54 <arkeet> well php makes it very easy to foot yourself in the shoot.
18:23:20 <ocramz> arkeet: :D
18:23:32 <ocramz> but getting back to Hs
18:24:31 <ocramz> rather than a full theorem proof, I was more looking for syntax that could be used to write stepwise reductors, if that's the term
18:24:54 <arkeet> well, you'll need some data type to represent expressions.
18:25:16 <arkeet> and then define some ways of transforming them.
18:25:34 <ocramz> and something that "looks for invariants"
18:25:41 <arkeet> that's called a human.
18:26:29 <halvorg> hey, how do I replace variables within strings in hamlet? anyone know?
18:26:58 <halvorg> <h3>Hello #{username} <- this works fine.
18:27:04 <halvorg>  <input type="text" name="username" disabled="true" value="${username}"> <-- this does not work at all
18:27:36 <arkeet> I don't know anything about hamlet, but are # and $ supposed to be different?
18:27:38 <pacak> # and $?
18:27:43 <halvorg> lol
18:27:46 <halvorg> thanks...
18:27:59 <ocramz> arkeet: or a dynamic program
18:28:00 <dmj`> arkeet++
18:28:08 <TallerGhostWalt> halvorg: I don't know  about ${} 
18:28:14 <TallerGhostWalt> where is that in the docs?
18:28:21 <TallerGhostWalt> #{} is how you do interpolation 
18:28:26 <halvorg> it was a typo, # i the correct yeah
18:28:51 <TallerGhostWalt> value=#{username} doesn't work?
18:28:53 <TallerGhostWalt> what error?
18:29:01 <Aruro> ocramz: you do not look for invariants, you calculate
18:29:32 <ocramz> Aruro: care to expand?
18:29:49 <halvorg> TallerGhostWalt: It works, arkeet and pacak had me on the right way. everything is fine now : )
18:31:42 <Aruro> ocramz: im just saying everything is calculation at the end, and its up to you to create "advanced" algorithm 
18:32:01 <TallerGhostWalt> halvorg: cool
18:32:49 <ocramz> Aruro: actually, when one does symbolic computations on paper, the constants are plugged in only at the end
18:33:32 <Aruro> ocramz: on paper you first think :) then write, computer can write, but can not think.
18:34:30 <Aruro> ocramz: so invariants you will search for you will have to plug in by hand, at design stage or later on
18:34:41 <Aruro> for,you*
18:35:35 <monochrom> sometimes I calculate invariants
18:36:46 <monochrom> I once calculated an algorithm, too
18:38:50 <ocramz> yes, I was ready to do that. But some systems, such as linear algebra, seem to be simple enough to be "rewritten" safely. There are a few interesting identities, and deciding whether they appear within a given formula seems to be "not too hard"
18:39:12 <ocramz> or perhaps I'm missing something really basic from computational theory
18:39:51 <ocramz> monochrom: m? :)
18:39:53 <c_wraith> systems like mathematica are term-rewriting systems.  They work well for certain classes of problems.
18:40:08 <arkeet> yeah, that doesn't sound too far from what a CAS does.
18:40:51 <small-wolf> Is there a good cabal tutorial somewhere? I keep running into problems with missing foreign dependencies (mostly c libraries)
18:41:18 <arkeet> have you read the cabal user's guide?
18:41:25 <ocramz> small-wolf: foreign deps of cabal itself?
18:41:32 <arkeet> well
18:41:39 <arkeet> you are just trying to install some package with C deps?
18:42:24 <small-wolf> I have not. Where is that? I frantically googled how extra-lib-dirs and extra-include-dirs modify the build process but couldn't figure it out
18:42:45 <arkeet> google will find it.
18:42:58 <arkeet> here https://www.haskell.org/cabal/users-guide/
18:48:50 * hackagebot Concurrential 0.4.0.0 - Mix concurrent and sequential computation  http://hackage.haskell.org/package/Concurrential-0.4.0.0 (alexvieth)
19:05:58 <haskellNewbie999> @help
19:05:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:06:05 <haskellNewbie999> @list
19:06:05 <lambdabot> What module?  Try @listmodules for some ideas.
19:06:13 <haskellNewbie999> @pl
19:06:14 <lambdabot> (line 1, column 1):
19:06:14 <lambdabot> unexpected end of input
19:06:14 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
19:06:14 <arkeet> please do this in /msg lambdabot 
19:06:37 <haskellNewbie999> whoops, new to irc and lambdabot sorry
19:08:20 <haskellNewbie999> @list
19:08:20 <lambdabot> What module?  Try @listmodules for some ideas.
19:08:43 <athan> haskellNewbie999: cmon man you're cramping our style
19:08:51 * hackagebot diagrams-haddock 0.3.0.2 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.3.0.2 (BrentYorgey)
19:09:05 <haskellNewbie999> @pl sum $ zipWith (\x y -> if x == y then 1 else 0) xs ys 
19:09:05 <lambdabot> sum (zipWith (flip flip 0 . flip flip 1 . (if' .) . (==)) xs ys)
19:09:29 <athan> haskellNewbie999: pl doesn't work well with if statements :\
19:09:33 <athan> it assumes them to be functions
19:09:41 <haskellNewbie999> ah, I see
19:09:48 <athan> Isn't there a choice function, anyway?
19:10:00 <arkeet> what's a choice function?
19:10:29 <haskellNewbie999> thanks, I
19:10:35 <haskellNewbie999> I'll try to look it up
19:10:41 <pacak> > length . filter id $ zipWith (==) [1,2,3] [1,4,5]
19:10:42 <athan> @hoogle (a -> Bool) -> b -> b -> a -> b
19:10:42 <lambdabot> Foreign.C.Error throwErrnoPathIf :: (a -> Bool) -> String -> FilePath -> IO a -> IO a
19:10:42 <lambdabot> System.Posix.Error throwErrnoPathIf :: (a -> Bool) -> String -> FilePath -> IO a -> IO a
19:10:42 <lambdabot> System.Posix.Error throwErrnoPathIfRetry :: (a -> Bool) -> String -> FilePath -> IO a -> IO a
19:10:43 <lambdabot>  1
19:11:07 <athan> arkeet: Something with that type signature
19:11:33 <arkeet> hum.
19:11:38 <athan> > let choice p a b x = if p x then a else b in choice (== 1) 4 6 1
19:11:39 <lambdabot>  4
19:12:01 <athan> fresheyeball is all over it if he were here :\
19:13:07 <ronh> :t if'
19:13:08 <lambdabot>     Not in scope: ‘if'’
19:13:08 <lambdabot>     Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
19:13:25 <shachaf> arkeet: It's a function that gives you an element of the cartesian product of a set of non-empty sets.
19:13:36 <arkeet> that sounds different from athan's choice function.
19:13:45 <KaneTW> :t bool
19:13:46 <lambdabot> a -> a -> Bool -> a
19:13:51 * hackagebot diagrams-contrib 1.3.0.1 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.3.0.1 (BrentYorgey)
19:13:52 <athan> ah!
19:13:59 <arkeet> bool is nice.
19:14:09 <knite> bit of a philosphical thought: I'm getting the feeling that Haskell pushes you toward functions that take a single argument, which is often a list. functions of multiple values seem clunky, and often would be better as a single arg that's a tuple.
19:14:15 <knite> am I off-base?
19:14:29 <athan> :t curry
19:14:30 <lambdabot> ((a, b) -> c) -> a -> b -> c
19:14:35 <athan> knite ^ :)
19:14:36 <arkeet> every function takes a single argument.
19:14:52 <arkeet> functions that take tuples are fairly uncommon.
19:14:55 <athan> every function _is_ a single argument o_o
19:15:28 <pacak> :t unzip
19:15:29 <lambdabot> [(a, b)] -> ([a], [b])
19:15:50 <dmj`> knite: the more generic the better, or at least ghc will always infer the least specific type
19:15:53 <ronh> knite I usually find `a -> b -> c' a lot nicer than `(a, b) -> c'. easier to get (b -> c) out of it, just apply a single argument
19:15:56 <arkeet> :t \f -> fmap f . traverse
19:15:57 <lambdabot> (Applicative f, Traversable t) => (f (t b1) -> b) -> (a -> f b1) -> t a -> b
19:16:01 <athan> shachaf: wait is that sigma?
19:16:02 <arkeet> :t \f -> fmap f . sequenceA
19:16:03 <lambdabot> (Applicative f, Traversable t) => (t a -> b) -> t (f a) -> f b
19:16:17 <ronh> knite not sure why such functions appear clunky to you
19:17:17 <athan> I really want to put some of my libs in lambdabot, namely poly-arity. How could I do this?
19:17:31 <arkeet> bug lambdabot's owner, int-e 
19:17:36 <knite> ronh: I'm not sure either. it's just a general vibe I'm getting being new to the language.
19:18:10 <athan> sweet :)
19:18:11 <arkeet> working with tuples in haskell is rather clunky.
19:19:06 <athan> oh wait
19:19:09 <ronh> knite most functions in prelude (and elsewhere) are in the form of a - >  b - > c, not (a, b) -> c
19:19:24 <athan> can lambdabot do type functions / scoped type variables?
19:19:36 <arkeet> :t \(x::Int) -> x
19:19:37 <lambdabot> Int -> Int
19:19:41 <athan> awesome
19:19:44 <arkeet> looks like STV is ok
19:19:45 <KaneTW> :t let a = (1 :: Int) in a
19:19:46 <lambdabot> Int
19:19:56 <arkeet> that one doesn't use STV.
19:19:59 <KaneTW> yeah
19:20:39 <athan> wait nvm
19:20:41 <KaneTW> brain's falling asleep
19:20:46 <athan> I'd also need HList
19:20:54 * athan gives KaneTW a sensu bean
19:21:19 <KaneTW> i wish they existed :(
19:21:37 <athan> ):
19:21:47 <meiji11> it doesn't seem ghc 7.8.3 can parse the code generated by template haskell, which I can't find it anything wrong. it looks like correct haskell to me. is this a known problem?
19:22:00 <meiji11> can't find anything wrong *
19:22:01 <meiji11> whoops
19:22:25 <athan> meiji11: What's the error?
19:22:48 <Pamelloes> Is there a way in Template Haskell to identify if a type is an instance of a class?
19:22:52 <meiji11> "Shentong\Backend\Toplevel.hs:28:94: parse error on input `!'"
19:22:57 <arkeet> ok, now what's the code?
19:23:00 <meiji11> it would help if I pasted the bit of offending code, one sec
19:23:43 <meiji11> here it is: http://lpaste.net/131715
19:23:56 <arkeet> TH works at the AST level anyway, so what it generates does not need to be parsed
19:24:13 <arkeet> which line is line 28?
19:24:35 <meiji11> arkeet, "!appl_5 <- applyWrapper aw_4 [];"
19:24:38 <meiji11> without the quotes..
19:24:41 <meiji11> of course. :P
19:25:20 <meiji11> the AST is fed through pprint, which I'm then trying to compile..
19:25:21 <yellow13> How can I deal with an exception from System.Process.callProcess?
19:25:22 <yellow13> https://gist.github.com/willianpts/5d1a9f530ff4d98b68f2
19:25:33 <athan> Do you have -XBangPatterns enabled, meiji11?
19:25:48 <athan> (I'm not even sure that's legit syntax)
19:25:48 <meiji11> it's in there, yes.
19:25:56 <arkeet> hm, not obvious to me what's wrong.
19:26:03 <athan> I know you can do it with let statements
19:26:12 <meiji11> the source compiled under ghc 7.6.3.
19:26:13 <arkeet> what if you change the previous line to look like let { ... = ... };
19:26:34 <arkeet> putting braces
19:28:00 <meiji11> and that pprint'ed source included none of the curly braces/semicolon stuff
19:28:27 <meiji11> the problem is that I'm generating thousands of lines of code this way, so.. I need to pin down a cause I can solve programmatically.
19:28:33 <arkeet> mmmm
19:28:53 <arkeet> does modifying it that way by hand get it compile, though?
19:29:14 <pavonia> meiji11: Why do you mix indentation and semicolons?
19:29:23 <arkeet> pavonia: the code is generated by pprint
19:29:31 <pavonia> Oh
19:29:41 <pavonia> Why does pprint does that then?
19:29:41 <meiji11> right.
19:29:54 <meiji11> I don't know. it's a change that was made between major ghc releases, apparently
19:30:43 <arkeet> anyway, putting those braces fixes the parse error for me.
19:32:00 <meiji11> in the whole file adding braces moves the parse error down 3 lines.
19:32:11 <arkeet> yes, because there is another offending let.
19:32:16 <meiji11> right.
19:33:16 <arkeet> I guess something's wrong with pprint then.
19:33:35 <arkeet> I'm not aware of any changes between 7.6 and 7.8 that would have made it succeed before.
19:34:03 <meiji11> looks like. :/
19:34:22 <meiji11> I'd revert back to 7.6.3 but there are other problems I have with it on windows
19:34:25 <enthropy> Pamelloes: reifyInstances and then implement however much of ghc's instance resolution you need
19:34:28 <blogle> I asked a bit earlier, but I am still at a loss... Anyone know of a way to catch modifier keys from the terminal?
19:35:17 <arkeet> actually I'm not sure why it's a parse error now heh
19:35:49 <geekosaur> blogle, you can't
19:36:28 <meiji11> is there a better place to go with this problem?
19:36:33 <meiji11> somewhere less synchronous
19:37:22 <blogle> @geekosaur, well curses or vty let you handle them... but I was hoping for something lighter weight
19:37:22 <lambdabot> Unknown command, try @list
19:37:40 <geekosaur> you might erxplain exactly what you want
19:37:52 <geekosaur> you can't detect a modifier key as a modifier key
19:38:24 <arkeet> terminals don'
19:38:25 <geekosaur> you can detect the modified sequences that a terminal generates when some key is pressed with a modifier --- for some combinations of keys and modifiers
19:38:33 <arkeet> t send anything when you press a modifier key.
19:38:55 <solrize> anyone know anything about gitit?  like does it have such a thing as administrators and is there a way to protect specific pages from public editing?
19:38:59 <geekosaur> there's no truly lightweight way to do it though, neither is there a portable way except via things like curses and vty (and even those need help)
19:39:30 <blogle> Im working on a REPL, I want to get another line of input on <Enter> and eval on <Shift + Enter>
19:39:44 <meiji11> would haskell-cafe be an appropriate place for me to post about this?
19:39:53 <AfC> blogle: are you writing a GUI application? If so, then the widget toolkit you're using should provide low level facilities to deal with key press events.
19:39:59 <geekosaur> blogle, shift-enter on unix does not send a distinct sequence
19:40:03 <geekosaur> in a terminal
19:40:28 <AfC> blogle: But (putting my human/machine interface hat on) it's not a good idea, as existing widgets have wired in functionality that represents conventions that a user should reasonably be able to expect. You mess with that, you're messing with people's minds, yo
19:40:42 <geekosaur> maybe it does in some specific terminal emulator somewhere, but not in iTerm2 and not in a VTE-based terminal (gnome-terminal, mate-terminal, xfce4-terminal)
19:41:10 <blogle> I am trying to avoid, gui... I want something next next to vim in tmux
19:41:16 <geekosaur> if you are working in an actual gui widget then you can detect shift+enter
19:41:32 <AfC> blogle: just use curses (if 'ansi-terminal' won't get you what you need)
19:43:35 <blogle> I mean I could do what ghci does and use :{}: for multiline, but ultimately want to progress towards ipython notebook cell style editing
19:43:56 <geekosaur> you still can't detect shift-enter in a terminal
19:44:21 <geekosaur> ipython can because it's a gui
19:45:22 <bob_twinkles> some terminals can do it, but supporting it and correctly detecting support is a pain
19:45:42 <blogle> I understand that, but theres terminal ui's that can..
19:45:51 <geekosaur> sure, in xterm I can define a translations resource to do it. which applies to everything, not just your program
19:46:06 <geekosaur> and in vte-based stuff there's a pane to define keyboard translations, with the same shortcoming
19:47:02 <geekosaur> if your instructions start with "find the instructions for your terminal to add these special key bindings" (or even "you will use this terminal emulator with this config"), you aren't going to get very far
19:47:30 <geekosaur> also you said tmux
19:47:54 <geekosaur> which means you may have to teahcd tmux about it as well, depending on what exactly you're looking for
19:48:02 <geekosaur> since tmux has its own terminal emulator
19:48:14 <blogle> I am not married to <Shift + Enter>, are any modifier keys possible. 
19:48:41 <blogle> I agree requiring a special terminal config is non viable
19:48:43 <geekosaur> (that is, it must recognize the keys on the terminal you are actually using and then translate them to the keys used by the terminal it pretends to be in the window)
19:51:00 <blogle> does vim/emacs sit atop curses or something similar to handle mod keys?
19:51:51 <joneshf-laptop> so i've seen people take an algorithm, and encode it to a data type so that when it's evaluated there's not much to be done in the evaluation, but I can't remember an example of that, anyone know what i'm talking about?
19:52:13 <Myrl-chan> I'm making abytecode interpreter, what would be the best data structure for RAM?
19:55:15 <geekosaur> blogle, curses is more or less the I/O mechanism from the original vi. emacs -nw also uses curses. again, you get limited ability to recognize keys, because the terminal cannot generate arbitrary key events
20:01:34 <blogle> geekosaur, seems like I might have to try and make it work with curses...
20:02:33 <geekosaur> I would actually start with vty (and more precisely vty-ui which is the high level wrapper around the low level vty stuff)
20:02:40 <geekosaur> curses is, shall we say, well named
20:04:30 <blogle> I looked at vty, per suggestion of irc... I couldnt get text to the screen, and docs are sparse. I will look at vty-ui
20:04:41 <blogle> thanks for the help!
20:06:05 <geekosaur> the problem with curses is it's all special cases that made sense in the original vi but not for much else. things that seem obvious don't work as you expect, and are "documented" in ways that only really make sense after you trip over them :/
20:06:39 <geekosaur> and sometimes require *very* careful reading to spot
20:07:09 <geekosaur> (that is, something that just seems like an odd way of describing something obvious is actually describing a pitfall)
20:09:03 <blogle> It seems general consensus is pretty negative regarding curses.
20:09:22 * hackagebot wai-request-spec 0.8.5.0 - Declarative request parsing  http://hackage.haskell.org/package/wai-request-spec-0.8.5.0 (alcabrera)
20:09:37 <pikhq> It's a uniquely terrible API with little that offers equivalent functionality in place.
20:10:05 <pikhq> Though the functionality you *need* of it is rather a lot less, and you can just about get away with simply knowing VT codes. :)
20:10:47 <bob_twinkles> it works OK-ish in C, but I had difficulty with how it interacted with GHC's handling of file handles
20:11:19 <bob_twinkles> mostly that curses has its own getch function that doesn't play ball with System.IO at all
20:12:03 <blogle> I cant say I am suprised though.. I have heard vim is a nightmare under the hood
20:12:23 <kasabian> hello, I have an issue with monads
20:12:36 <kasabian> I am using monads transformers
20:12:54 <bob_twinkles> misc1.c and misc2.c constitute several lines of code together =P. The neovim project has made some pretty big steps towards cleaning up the Vim internals though which is pretty sweet to follow
20:12:55 <kasabian> On the top of the stack I have a StateT
20:13:23 <kasabian> and I want to get the result of the previous computation without re running it again
20:13:51 <bob_twinkles> *several thousand LoC, of course they have several lines of code...
20:13:53 <kasabian> Is that even possible?
20:14:22 * hackagebot wai-request-spec 0.8.5.1 - Declarative request parsing  http://hackage.haskell.org/package/wai-request-spec-0.8.5.1 (alcabrera)
20:14:25 <blogle> bob_twinkles, I switched to neovim a while back on my laptop. I'd say its already as stable as vim 
20:15:09 <blogle> I need a redraw every now and then, but I think tmux might be the culprit there
20:15:25 <naevathecat> Hey so I asked this yesterday but wth I'll try again. Are there any existing libraries for efficient priority queues that support deleting arbitrary elements?
20:15:28 <bob_twinkles> blogle: yep, I'm mostly just waiting on Shogu to port his completion magic before I switch to nvim full time... YCM is too heavy weight for me most of the time
20:16:42 <naevathecat> (mutability = ideal. My structure will large and change many times each time an elemtn is acted on)
20:16:54 <blogle> bob_twinkles: I always wanted to use YCM, but even after it seemingly compiles with no errors I get nothing
20:17:43 <geekosaur> blogle, I mentioned that curses came from the original vi, but vim is actually an independent reimplementation with its own problems
20:18:11 <bob_twinkles> yeah, it's always a bit fidly to get working unfortunately... when it works it's pretty great though (at least for C work, ghc-mod 'n friends tend to play better with haskell)
20:20:46 <blogle> I think neco-ghc ties together YCM and ghc-mod
20:21:26 <blogle> geekosaur, ah silly of me to make such assumptions between vi and vim
20:22:00 <bob_twinkles> I vaguely recall poking that and not having a good time, but that may have just been my environment killing something important
20:22:31 <bob_twinkles> and neovim ripped out vim's terminfo handling and replaced it with LeoNerd's libunibilium =P
20:22:59 <geekosaur> well, the historuy of vi is rather tangled. original vi was developed at UC Berkeley but is now owned by AT&T; the BSD folks rewrote from scratch to make nvi, and vim was written from scratch by someone else who thought it was a good idea to take on emacs
20:23:14 <geekosaur> (vim +huge's executable is bigger than emacs...)
20:23:37 <Fylwind> geekosaur: but emacs has a lot more extensions in elisp, no?
20:24:19 <geekosaur> probably, if only because voimscript seems to be trying to make elisp look sensible >.>
20:24:22 * hackagebot wai-request-spec 0.8.5.2 - Declarative request parsing  http://hackage.haskell.org/package/wai-request-spec-0.8.5.2 (alcabrera)
20:25:13 <bob_twinkles> https://github.com/saep/nvim-hs =D
20:25:31 <geekosaur> also because emacs has been at it longer
20:25:33 <bob_twinkles> haven't gotten a chance to play with it, and it may be broken because the API is a bit of a moving target right now...
20:27:23 <blogle> I want to like emacs, but I tries to be so much more than an editor that it overwhelms.. I think I could get on board if they had a no frills version + evil
20:29:07 <bob_twinkles> plus on some distributions emacs has a nasty tendency to pull in all kinds of crap that I don't want (like X in some cases...)
20:30:20 <bob_twinkles> eh, each to his own and all that (don't hurt me emacs fans!)
20:30:32 <ackthet> most sane distros package the X dependent emacs seperatly 
20:30:43 <ackthet> not that i have any love for emacs
20:31:01 <ackthet> plus this is #haskell, isn't everybody using yi? :P
20:34:38 <geekosaur> yi is still very much experimental
20:35:52 <blogle> does yi *support* languages outside haskell?
20:35:53 <ackthet> man, so it hasn't come very far int he 5 years since i used it?
20:36:04 <geekosaur> it stagnated for a while before being picked up again
20:36:18 <ackthet> oh ok
20:37:01 <geekosaur> partly because it really wanted to use ghc-api but until people started hammering on it and figured out how to use it, it was completley incomprehensible
20:37:42 <ackthet> does it have vim emulation mode?
20:38:00 <geekosaur> so you can thank tools like ghc-mod and before that scion for getting past that hump
20:38:21 <geekosaur> there's at least 3 vi emulators, dunno if any of them are sufficiently like all vim's additions
20:44:44 <blogle> anyone versed in APL namely q, or know an irc channel?
21:03:37 <octalsrc> is there any reason why "MonadWriter" can't be deduced for something like "MaybeT (Writer [a]) b"?
21:12:33 <benzrf> octalsrc: can it not?
21:13:39 <octalsrc> the compiler says it can't
21:13:49 <octalsrc> I'm probably not using it right
21:14:00 <geekosaur> newtype deriving would let you derive MonadWriter [a]
21:14:13 <geekosaur> not simply MonadWriter, you need to specify
21:16:07 <octalsrc> oh I got it now
21:16:14 <octalsrc> it was a MonadWriter [a]
21:16:20 <octalsrc> but I was calling "tell a"
21:16:27 <octalsrc> instead of "tell [a]"
21:19:24 * hackagebot HandsomeSoup 0.4 - Work with HTML more easily in HXT  http://hackage.haskell.org/package/HandsomeSoup-0.4 (AdityaBhargava)
21:19:38 <inaoel> I'm not missing something, am I? There's no way to do O(1) `delete :: Int -> Vector a -> Vector a`?
21:20:36 <geekosaur> it's a flat chunk of memory, wouldn't deleting an element have to copy the rest of the vector over the element being removed?
21:21:22 <octalsrc> if all the values are in a row in memory, then you just have to increment a pointer, right?
21:21:42 <Axman6> no?
21:21:46 <monochrom> yes if "delete the first" or "delete the last"
21:21:57 <monochrom> consider "delete the middle guy"
21:22:20 <octalsrc> oh, I thought it meant "delete the first {INT} values"
21:22:30 <octalsrc> I've never used Vector
21:22:44 <inaoel> That usually goes by `drop`
21:22:52 <octalsrc> ah
21:27:38 <Myrl-chan> What data structure should I use to mimic RAM for my bytecode interpreter? I'm guessing a fast index and fast update would be preferable. It's of fixed size.
21:28:46 <ttt_fff> what is a good high-res webcam for _taking_ stills (i.e. I'm writing notes, and I want to take a picture of a piece of apper) -- I only need to take stills; I don't need to capture video
21:28:47 <athan> Myrl-chan: Maybe take a look at vector?
21:30:14 <Myrl-chan> athan: Okay. Thanks. I plan on using it as a list of 4096-sized blocks.
21:31:37 <ackthet> why do people keep asking camera questions in here?
21:32:43 <ElMoloko> I just assumed they're talking about some sufficiently advanced Haskell concept I have no hope of understanding
21:32:52 <monochrom> a scanner is a good high-res webcam for taking stills of paper sheets
21:33:21 <athan> I think you can actually use a mouse now-a-days
21:33:31 <monochrom> make it a flatbed scanner
21:33:34 <Myrl-chan> ElMoloko: `import System.Camera`
21:33:54 <athan> http://hacknmod.com/hack/convert-an-optical-mouse-to-hand-held-scanner/
21:34:29 <monochrom> both movies Despicable Me and The Lego Movie will also show you other pictures you can take using a flatbed scanner.
21:35:10 <bros> Can somebody help me understand this line? I have a very basic understanding of Haskell (read none at all)
21:35:43 <bros> type ServerApp = PendingConnection -> IO (). Then the line it is referenced in is: runServer :: String -> Int -> ServerApp -> IO ()
21:35:56 <Myrl-chan> athan: Also, it'd be preferrable if it's constant size.
21:36:00 <bros> A function called runServer takes a type ServerApp as a parameter
21:36:01 <athan> Here's a vid for anyone that want's to see me embarrassed and try to teach type programming: https://www.youtube.com/watch?v=iwj3Bni4uYE
21:36:03 <athan> ._.
21:36:06 <bros> But what is the type?
21:36:26 <athan> Myrl-chan: Wat, you expect me to make your code for you? :P
21:36:27 <subleq> Is it possible to get the n'th fibonacci number with  the normal one-liner fibonacci implemention without using memory to store all the n-1th numbers?
21:36:41 <gwaszczuk> Whenever you have a type alias, you can just substitute it for the original
21:36:41 <athan> Myrl-chan: If you're really concerned with performance, I suggest criterion
21:37:01 <heatsink> bros: It's the type of a function that takes a PendingConnection and returns an IO action
21:37:05 <gwaszczuk> So runServer has type String -> Int -> (PendingConnectino -> IO ()) -> IO ()
21:37:10 <gwaszczuk> *PendingConnection
21:37:13 <Myrl-chan> athan: Nope. Lol. :P. Vectors look good, but it being resizable has no use for me.
21:37:31 <heatsink> bros: So, when you give a PendingConnection to a ServerApp, it can do some IO
21:37:38 <athan> Myrl-chan: You might check out arrays then :P
21:37:42 <athan> @hackage arrays
21:37:42 <lambdabot> http://hackage.haskell.org/package/arrays
21:37:54 <athan> erm
21:37:56 <athan> array*
21:38:02 <bros> gwaszczuk: so I need to pass a connection to it?
21:38:21 <heatsink> runServer will pass connections to it
21:38:30 <gwaszczuk> You need to pass a function, that when given a connection, it does some IO
21:38:46 <bros> I see. It's almost like a Javascript callback.
21:38:49 <gwaszczuk> Yes, runServer will call your function with one, or potentially more connections, like "f conn1", then "f conn2", etc
21:38:52 <Myrl-chan> athan: Thanks. :)
21:39:00 <bros> heatsink: I just read the comments for the code (it's the websocket package) "Note that this is merely provided for quick-and-dirty standalone applications, for real applications, you should use a real server."
21:39:01 <athan> no prob!
21:39:04 <bros> What should be done instead?
21:40:19 <heatsink> That's a complicated question
21:40:44 <bros> heatsink: I thought to make a real application, you'd use this library. It makes it sound like you shouldn't?
21:41:31 <heatsink> For example, it's common for real servers to use databases, so that if the computer is switched off, important data isn't lost
21:41:49 <heatsink> and logging so that if there is a rare error, you can examine the logs to try to figure out what happened
21:42:27 <heatsink> I guess this server doesn't take care of any of that
21:43:16 <heatsink> I haven't written any web servers, so I don't have much advice about making them.
21:43:25 <bros> heatsink: a server serves requests over websockets. it makes it sound like this is the wrong choice. If you were going to write a production server with a WebSocket API, would you use the package?
21:43:30 <bros> oops
21:43:31 <bros> lol
21:44:31 <bros> Could anybody here give me some web server advice?
21:45:42 <gwaszczuk> What package/library is it? There's little to go on with what runServer is supposed to do (for instance, we don't know what PendingConnection is, or what the other parameters are supposed to do)
21:45:58 <gwaszczuk> But since you can do IO.....you can do anything you want, from logging, to accessing the database, etc
21:46:18 <gwaszczuk> It's just that this library doesn't give you any meaningful abstraction for it, and forces you to do everything on your own
21:46:41 <bros> gwaszczuk: I realize this, which leads me to believe this is a fine solution for any serious application. But the documentation mentions 3 times this is geared towards quick-fix apps.
21:46:51 <bros> https://github.com/jaspervdj/websockets/blob/master/src/Network/WebSockets/Server.hs
21:47:12 <bros> Oh, is that what it is trying to say? It's suggesting a framework?
21:47:25 <bros> I'm reading too far into it. Thank you so much gwaszczuk and heatsink !
21:48:04 <gwaszczuk> Yes, it does mention that if you want a serious approach, you could use something like Snap
21:48:27 <gwaszczuk> Snap is a library/framework (I'm not sure which) that gives you more functionalities for creating web servers
21:49:06 <gwaszczuk> For example, it let's you specify in the type signature whether you want to use a MongoDB database, or a PostgreSQL one, or if you want Logging, and allows you to compose these into a single app
21:50:27 <gwaszczuk> But yeah, it's a little more complex than doing something simple with websockets, which that runServer function seems to have been designed for
21:50:44 <e4x> could anyone help me with this? http://lpaste.net/131721
21:50:55 <bros> gwaszczuk: An example calls runServer like this: WS.runServer ip port $ application state
21:50:59 <bros> What does $ represent/do here?
21:51:18 <Jeanne-Kamikaze> f $ x = f x
21:51:23 <gwaszczuk> $ is an infix operator. Its basically defined like so
21:51:26 <Jeanne-Kamikaze> it's just a way to avoid parenthesis
21:51:30 <gwaszczuk> Yeah that ^
21:51:47 <Jeanne-Kamikaze> f g b = (f g) b
21:51:52 <Jeanne-Kamikaze> f $ g b = f (g b)
21:52:03 <Jeanne-Kamikaze> = f . g $ b
21:52:16 <bros> So we know from before that runServer is looking for a function that takes PendingConnection as a parameter
21:52:44 <bros> but this call infixes two variables as the parameter, neither one of them being a PendingConnection?
21:54:00 <bros> Oh. I see. It passes application as the parameter, and it says application requires state? how would that look with parenthesis and not the infix?
21:54:22 <bros> WS.runServer ip port (application state) ?
21:55:56 <gwaszczuk> Yes, it's just like the 3rd pattern Jeanne posted
21:55:59 <rui2> Anyone uses ihaskell installed from nix? I just installed it but don't know how to get it started
21:57:46 <rui2> "ihaskell install" doesn't work. "ihaskell console" says it fails to load interface for 'IHaskell.Display'.
21:59:29 <rui2> ihaskell notebook opens the web interface but I can't get it to print output
22:02:19 <bros> gwaszczuk: receiveData is defined as receiveData :: WebSocketsData a => Connection -> IO a
22:02:26 <bros> Does this mean it will return a String?
22:02:31 <bros> if necessary?
22:02:48 <Axman6> if String is an instance of WebSocketData
22:02:57 <Axman6> s/t/ts
22:03:06 <bros> Axman6: It's not. I'm getting  No instance for (WS.WebSocketsData String)       arising from a use of ‘WS.receiveData’
22:03:14 <bros> The source shows I should be looking for Text instead?
22:03:23 <Axman6> what things are instances of WebSocketsData?
22:03:37 <Axman6> try using Text and unpack to get a String then
22:04:07 <gwaszczuk> Apparently for Text and Bytestring, yes
22:04:14 <bros> Axman6: awesome. thank you. what is the difference between Text and String?
22:04:34 <gwaszczuk> String is defined as a list of characters. type String = [Char]
22:05:11 <bros> What is Text defined as?
22:05:20 <Axman6> magic
22:05:30 <kadoban> Text is like String, except actually performant. String is quite slow in practice with any real amount of data.
22:05:31 <gwaszczuk> Text is abstract, you wouldn't know how it's implemented without looking at the source code
22:05:39 <Axman6> (it's basically a UTF-16 encoded ByteString)
22:05:50 <gwaszczuk> You just know how to create them (like packing a string), and how to do stuff with it
22:07:51 <gwaszczuk> The consensus, from what I've gathered, is to use Text for textual data, Bytestring for unencoded sequences of bytes, and String when you really need to use the fact that you have a list of characters
22:08:30 <bros> gwaszczuk: is there a way to do standard input/output to a terminal using Text?
22:08:37 <kadoban> String is mostly for toys or times when you're dealing with small amounts of data and don't care it's slow.
22:08:54 <gwaszczuk> The "Data.Text" module has some useful functions for I/O
22:09:20 <kadoban> bros: There's an interact :: (Text -> Text) -> IO () somewhere in there, or some signature like that
22:10:22 <kadoban> bros: (It gives you all the input from stdin and you give it what to output)
22:10:32 <bros> From what I can see, putStrLn only accepts a String, so it would need packed text. Data.Text provides a function to circumvent this? I can't find it.
22:10:38 <gwaszczuk> If you import Data.Text unqualified, and hide the functions from Prelude that use String, you can use Text without any issues, just as if you'd use String normally
22:11:25 <kadoban> bros: Data.Text.IO has putStrLn
22:11:29 <kadoban> (And others)
22:11:45 <bros> Why am I allowed to do this: import qualified Data.Text as T import qualified Data.Text.IO as T
22:12:08 <bergmark> bros: for the same reason you are allow to import them both unqualified, i reckon
22:12:15 <kadoban> bros: Because. It just combines them. If there's ambiguity, it yells at you.
22:12:16 <bergmark> allowed*
22:12:37 <bros> What does qualified do in this context?
22:12:46 <bros> The support I'm getting here is great. Thank you all so much!
22:13:17 <gwaszczuk> qualified means you need to put the whole module name before the function. Like "Data.Text.pack"
22:13:47 <bros> Why would anybody ever want that?
22:13:48 <gwaszczuk> unqualified means you can put the function name only without anything else, and the typechecker finds out from which module to take it, like writing just "pack"
22:14:33 <kadoban> bros: So it doesn't pollute the whole namespace with stuff that, for some modules, may be really ambiguous/conflicting. If you give it an alias, like T, then it's nice.  T.pack will work then.
22:14:35 <bros> This works well for the websocket functions, but there is obviously a collision on putStrLn
22:14:48 <subleq> How do I make (+) strict?
22:14:51 <gwaszczuk> To disambiguate, for instance between the String "putStrLn" and the Text "putStrLn". Both have the same name, so if you just put "putStrLn" the typechecker wouldn't know which one you'd be referring to (in some cases)
22:14:54 <bros> kadoban: ok. so it's good practice to import qualified and use the nickname?
22:15:36 <bros> gwaszczuk: it didn't know in this case. is there something special I could have written?
22:16:00 <kadoban> bros: It depends on the module. Mostly I do one of the two: give an explicit list of stuff I'm importing: import Data.Blah (hi, there, stuff)     or import qualified Data.Blah as B    or sometime both
22:16:26 <subleq> Like, is there an f such that foldl (f (+)) === foldl' (+)   ?
22:16:48 <bros> I'm used to separating lines for clarity in other programming languages. Is that not a common practice in Haskell?
22:17:07 <bros> Example: https://gist.github.com/brandonros/d865a8db968df0e43b65
22:17:09 <gwaszczuk> Usually you just import qualified using an alias/nickname, so yes, in this case you could import Data.Text and Data.Text.IO as T and use "T.putStrLn"
22:17:10 <kadoban> bros: Separating lines like … double spacing your code or something?
22:17:47 <bros> kadoban: pretty much :/ It just all seems to run together. I usually separate initialization, then try to group like elements.
22:17:47 <naevathecat> subleq: You but seq between things to ensure they are evaluated. So + you can't but a series of +'s you can
22:17:50 <kadoban> bros: The spacing in that looks pretty idiomatic. Adding extra lines in there would look weird probably.
22:18:16 <bros> kadoban: Awesome. Thank you.
22:18:20 <kadoban> bros: In haskell, you usually have a bunch of quite small functions, which you generally separate from each other by a line. So it's not one big mass of crap, generally.
22:19:25 <gwaszczuk> Yeah, in haskell it's pretty easy to divide a function into smaller ones. In other languages it may be a little bit more cumbersome (creating new clases/files, etc) so it's much easier and convenient to separate lines like that (at least in comparison)
22:19:50 <subleq> naevathecat: so f does not exist
22:20:50 <bros> gwaszczuk: kadoban I have a question sort of specific to this library. The way it is written makes it seem that it is accepting a request every time, then reading one message. This isn't the case as the connections are persistent. How is that working?
22:21:02 <bros> Am I not understanding the <- operator properly? What does <- do?
22:21:18 <bros> I thought it was an assignment variable. Is it a co-routine or a channel or something?
22:21:28 <gwaszczuk> <- is syntactic sugar
22:21:40 <bros> my favorite
22:21:49 <bros> What does it coat?
22:21:58 <gwaszczuk> "do {x <- m; y}" = m >>= (\x -> y)
22:22:04 <kadoban> do notation is one big syntatic sugar for …   >>=  >> and pattern matching
22:22:06 <naevathecat> subleq: you can do strictF f a = let fa = f a in seq f fa
22:22:12 <kadoban> <- is part of do notation
22:22:14 <naevathecat> subleq: I am not sure what yo uwant?
22:22:22 <kadoban> bros: I don't really know that library offhand, heh.
22:22:32 <bros> kadoban: why's that?
22:22:41 <gwaszczuk> Basically, treat "x <- m" as defining a new function \x -> ....., where the body is defined below in the next line
22:22:47 <bros> What is the >>= operator?
22:22:52 <bros> and the backslash? and the -> ?
22:23:02 <gwaszczuk> Oh yeah. Backlash defines a function
22:23:10 <kadoban> (>>=) and return  together make a Monad
22:23:23 <gwaszczuk> "\x -> putStrLn x" for instance
22:23:27 <kadoban> So 'do' is sugar for working with Monads, that's about it.
22:23:46 <gwaszczuk> You could pass it everywhere where you need a function of type "String -> IO ()"
22:23:50 <bros> I'm a bit lost. You have x as a parameter, and \ defines a function.
22:24:27 <gwaszczuk> Yes. "\x -> body" defines a function, where "x" is the parameter and "body" is the function itself (which may use "x")
22:24:29 <kadoban> bros: You can … probably ignore the details until you get a bit further into learning, usually Monads shouldn't be the first thing you dive into head-first. Learning what do notation actually desugars to is … not the easiest thing to understand without understanding Monads themselves.
22:24:53 <gwaszczuk> I think it wouldn't be that hard to understand, if you just check the type
22:24:54 <bros> kadoban: as I feared.
22:25:16 <bros> Is a Monad like a lightweight thread responsible for this magic?
22:25:16 <gwaszczuk> (>>=) has basically this type. (>>=) :: m a -> (a -> m b) -> m b
22:25:42 <bros> I'm not sure what -> does. Does -> have a type? I used it in function definitions
22:25:51 <kadoban> bros: Monads are just a typeclass, which is kind of like a design pattern that the language can actually encode.
22:26:20 <kadoban> They're used for IO, amongst several other things.
22:26:44 <kadoban> Technically they're used to chain together IO actions, one of several ways you can do so.
22:27:14 <bros> kadoban: Why do you not care for the library?
22:27:30 <subleq> naevathecat: no, I think that still produces a thunk doesn't it?
22:27:38 <kadoban> bros: Oh I didn't mean to imply I don't care for it, I just don't know what library it is at all, or probably know much about it.
22:27:56 <gwaszczuk> There are 2 ways to think about (->)
22:28:06 <bros> msg <- WS.receiveData conn translates to WS.receiveData >>= (\msg -> conn) ?
22:28:37 <gwaszczuk> One is as part of defining functions, telling you what type it has as an argument and what type it has as a result
22:28:50 <gwaszczuk> "String -> Int" for instance
22:29:07 <gwaszczuk> The next way to think about -> is as something called "type constructor"
22:29:12 <Rotaerk> bros, msg <- WS.receiveData conn  translates to WS.receiveData conn >>= \msg ->
22:29:23 <naevathecat> subleq: the final call will never be evaluated until you use it. But you can make sure everything before then is evaluated. seq has type a->b->b. It forces a thunk which will evaluate to a to be evaluated.
22:29:25 <Rotaerk> i.e. it's incomplete on its own...
22:29:35 <bros> Rotaerk: is that correct? it truncates on -> ?
22:30:12 <naevathecat> Like foldl' stops the (a+(b+(c...+n))) stuff by making it always (n-1 + n) at the end
22:30:40 <naevathecat> Why do you need a strict + anyway?
22:30:40 <bros> WS.receiveData conn >>= \msg -> doesn't compile
22:30:43 <gwaszczuk> A type constructor is a kind of function that takes 2 types, and returns a new type. "String -> Int" would be equal to "(->) String Int". An example of a type constructor is IO. You have "IO String", or "IO ()". Basically "IO" takes a type, like "String" and gives you an new type, like "IO String". Same with (->) in this case, it takes 2 types, and gives you a new one
22:30:43 <subleq> naevathecat: yeah, i want to force the final call. not the things being called
22:30:50 <Rotaerk> bros, as I said, they are both incomplete
22:31:01 <Rotaerk> you can't end a do-block with "msg <- blah"
22:31:05 <bros> What did <- add that is missing?
22:31:08 <bros> or what did it imply
22:31:45 <naevathecat> subleq: Why? what's the point in evaluating it if it isn't used? If it is used then seq finalOutput ThingUsingIt
22:31:49 <gwaszczuk> Basically, you complete the definition with anything that is in the line below
22:31:54 <Rotaerk> bros, foo >>= (\bar -> baz)   corresponds to:   do { bar <- foo; baz }
22:31:59 <subleq> naevathecat: because it's a stack overflow otherwise
22:32:07 <naevathecat> From 1 thunk?
22:32:55 <bros> Are all functions defined as do blocks? No, right?
22:33:00 <Rotaerk> heck no
22:33:25 <bros> main :: IO () main = do 	WS.runServer "0.0.0.0" 9160 app Does that need to be in a do block?
22:33:52 <Rotaerk> a do block is syntax sugar for chains of >>=
22:34:06 <kadoban> No. You only need a do block, or (>>=), (>>), or others if you're chaining together actions. That's just one thing.
22:34:09 <Rotaerk> or maybe it's better to say... recursively nested >>=
22:34:52 <bros> https://gist.github.com/brandonros/62ecfcb8d07a01bdd516 How would I write this with no syntactic sugar/do block?
22:34:56 <bros> What is <- called?
22:35:09 <Rotaerk> "do foo" is legitimate, but it's the same as just "foo"
22:35:22 <L8D> in fact
22:35:27 <L8D> you can use do blocks for non-monads
22:35:33 <Rotaerk> oh?
22:35:46 <L8D> > do { let x = 5; let y = 6; x + y }
22:35:47 <lambdabot>  <hint>:1:34: parse error on input ‘}’
22:35:51 <L8D> > do { let x = 5; let y = 6; x + y; }
22:35:52 <lambdabot>  <hint>:1:33: parse error on input ‘;’
22:36:09 <L8D> o.O
22:36:31 <gwaszczuk> If you get confused about do-blocks, try to perform the manual convertion to the chains of (>>=)
22:36:45 <L8D> > do let x = 5; let y = 6; x + y
22:36:45 <Rotaerk> hmm, I suppose you could also locally-redefine >>= with a certain extension, to abuse do-blocks for other purposes
22:36:46 <lambdabot>  <hint>:1:31:
22:36:47 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
22:36:47 <gwaszczuk> Then you'll get a better idea of what is a function or not
22:36:47 <bros> I'm trying to do that now.
22:36:55 <L8D> I don't even know anymore
22:36:55 <bros> They have to be passed onto something else? They can't be assigned to a variable?
22:37:42 <L8D> > (do { let x = 5; let y = 6; x + y; })
22:37:43 <lambdabot>  <hint>:1:34: parse error on input ‘;’
22:37:46 <L8D> > (do { let x = 5; let y = 6; x + y })
22:37:47 <lambdabot>  <hint>:1:35: parse error on input ‘}’
22:37:49 <L8D> whatever
22:37:51 <ski> @undo do let x = 5; let y = 6; return (x + y)
22:37:51 <lambdabot> <unknown>.hs: 1: 15:Parse error: Last statement in a do-block must be an expression
22:37:56 <Rotaerk> bros, what are you learning haskell from?
22:38:03 <bros> This channel.
22:38:06 <ski> @undo do let {x = 5}; let {y = 6}; return (x + y)
22:38:06 <lambdabot> let { x = 5} in let { y = 6} in return (x + y)
22:38:08 <Rotaerk> ugh
22:38:23 <kadoban> bros: Something like https://gist.github.com/kadoban/7a31d5685b01ca67e385 but that's really not going to help understand much. You need to learn from the start really.
22:38:34 <lpaste> MP2E pasted “Desugared app” at http://lpaste.net/131726
22:38:36 <Rotaerk> get an actual resource designed to teach the language
22:38:43 <kadoban> bros: https://github.com/bitemyapp/learnhaskell is a good resource
22:38:58 <MP2E> I desugared the do example given, though I don't know how much that will necessarily help :P
22:39:04 <bros> kadoban: are there any performance implications/differences in either?
22:39:14 <kadoban> bros: No
22:39:26 <bros> Which is more common to write? do, obviously?
22:39:55 <MP2E> it really depends what you are doing. If you're simply sequencing 2 things, >>= or >> works fine. But if you've got a lot of things being wired around, do is the obvious choice
22:39:56 <L8D> > do { let {x = 5}; let {y = 6}; x + y }
22:39:57 <lambdabot>  11
22:39:57 <kadoban> It depends, some things are clearer one way, some the other. Some authors perfer one, some the other.
22:39:59 <L8D> ^ boom
22:40:04 <MP2E> for the example given I think do notation is clearer
22:40:15 <bros> kadoban: Say I wanted to omit the putStrLn of the function. How would it end then?
22:40:16 <kadoban> Often you don't need either, you can use other combinators.
22:40:26 <L8D> You can use do-notation with let statments to make the transition from procedural programming easier
22:40:39 <L8D> especially since you can re-bind variables
22:40:55 <kadoban> bros: Remove the >> and the putStrLn.
22:41:00 <Rotaerk> don't stay that way for too long or you'll not stop doing that
22:41:11 <Rotaerk> and then you'll do stuff like:  add :: Int -> Int -> IO Int
22:41:15 <Rotaerk> *shudder*
22:41:33 <bros> kadoban: I get an error saying ambigious type
22:41:39 <bros> ambiguous*
22:42:27 <bros> kadoban: is there another way to write the 3 lines? (accept, receive, send) using different combinators?
22:43:35 <kadoban> bros: Not an obviously better one. You'd have to show the error … and again I don't know what this code is a part of.
22:43:50 <kadoban> … and you really need to learn haskell before coding in it :)
22:43:55 <bros> Also, what is handling the connections that are already accepted from not having to go through the handshake/connection reinitiating process again? Is it a side effect of this code or is it the library?
22:44:50 <bros> kadoban: last question, I promise. I don't want to be a burden. https://gist.github.com/brandonros/2883d5f7c5fc89fa92fa
22:45:58 <kadoban> bros: You need to tell it that msg is a Text somewhere probably
22:46:23 <kadoban> Before it could figure it out because you were outputting it, but now it could be any of several things and it doesn't know which.
22:46:24 <bros> How would I do that?
22:47:03 <kadoban> WS.sendTextData conn (msg :: Text)       maybe  I dunno what modules you have imported or what they're called or anyhing, so you might have to make Text more specific.
22:48:46 <bros> import qualified Data.Text as T then (msg :: T.Text) is fine and proper?
22:48:55 <kadoban> Sounds possible, heh.
22:49:19 <bros> from what you can see, is app being called everytime there is a connection? After sendTextData, app is exited, correct?
22:50:37 <kadoban> I wouldn't really know without knowing more about the library. It probably drops connections after that though … maybe.
22:51:07 <bros> It doesn't, which I don't understand. 
23:08:40 <mjrosenb> wow, these examples look weird.
23:13:46 <bros> What does this translate to: sendClose :: WebSocketsData a => Connection -> a -> IO () 
23:17:01 <Axman6> "translate" to?
23:17:37 <bros> app :: WS.PendingConnection -> IO () means it takes a parameter of type PendingConnection
23:17:46 <bros> waht does WebSocketsData a => mean?
23:17:58 <MP2E> given a Connection and some type that is an instance of WebSocketsData, it will give you an IO ()
23:18:06 <Axman6> it means that a must be an instance of WebSocketsData
23:19:34 * hackagebot bitcoin-types 0.9.1 - Provides consistent low-level types used commonly among Bitcoin implementations  http://hackage.haskell.org/package/bitcoin-types-0.9.1 (solatis)
23:19:37 <bros> Ok. How do I call WS.sendTextData conn msg and directly after it: WS.sendClose conn "closed"? It seems like they are being combined because I have them written as WS.sendTextData conn msg  	WS.sendClose conn "closed"WS.sendTextData conn msg  	WS.sendClose conn "closed"
23:30:31 <bros> I just wrote the same websocket code in node that I did in haskell. node has 20% CPU usage, 100mb memory while haskell has 2% CPU usage, 3mb memory.
23:31:59 <kadoban> Nice.
23:32:31 <bros> kadoban: Thanks for the help. I just need to learn Monads, function flow. 
23:32:48 <kadoban> Also haskell :)
23:32:53 <FreeFull> It's because Haskell is a compiled language, probably
23:35:02 <bros> kadoban: How long is it going to take me to learn? I had been reading Learn You a Haskell
23:36:08 <kadoban> I don't know. LYAH isn't a very good way to learn, IMO. Most obviously it doesn't have any exercises, so at best you'll kind of recognize some parts of haskell when you're done.
23:36:25 <kadoban> https://github.com/bitemyapp/learnhaskell has better recommendation(s)
23:37:36 <bros> kadoban: awesome. will use. thank you. do i really have to do all 3 courses listed?
23:38:21 <arkeet> bros: cis194 is pretty much recommended for everyone
23:38:47 <arkeet> to get a solid foundation I guess
23:38:47 <kadoban> cis194 and NICTA are pretty important. The other I didn't really do.
23:39:09 <bros> does it really take 3 months to do the first course?
23:39:18 <arkeet> you can do it at any pace you like.
23:39:31 <arkeet> 3 months is just how long it took to teach the course at the university. 
23:39:35 <bros> how much is left unknown once the course is completed in its entirety?
23:40:00 <arkeet> well you'll still be far from an expert with just that heh
23:40:30 <bros> haha oh shit. when i finished node tutorials, i felt like i learned everything there was to know :P
23:40:33 <arkeet> well, you can read the explanations for those courses
23:41:05 <kadoban> cis194 is kind of a pretty quick primer. NICTA will give you in-depth knowledge and experience with important typeclasses, then you'll at least have a good base
23:41:13 <arkeet> mhm
23:41:38 <arkeet> haskell is pretty deep on concepts, so it takes some time to get a good grasp of the kind of stuff you'll encounter in the wild
23:41:46 <kadoban> bros: Well, haskell is quite a bit different from most languages that people know. Learning one procedural, imperative language isn't really that hard when you already know one … you basically learn the syntax and the few different things, and that's about it.
23:42:07 <arkeet> and yeah, there's also the fact that it's just different from most popular languages
23:42:13 <arkeet> in a fundamental way
23:43:08 <Axman6> bros: I've been writing Haskell for about 7 years and feel like I've only scratched the surface. that's not to say that I'm not productive (I'm using haskell to write allservices for our projetc)
23:49:34 * hackagebot list-t-html-parser 0.3.0.0 - Streaming HTML parser  http://hackage.haskell.org/package/list-t-html-parser-0.3.0.0 (NikitaVolkov)
23:54:35 * hackagebot bitcoin-tx 0.12.1 - Utility functions for manipulating bitcoin transactions  http://hackage.haskell.org/package/bitcoin-tx-0.12.1 (solatis)
