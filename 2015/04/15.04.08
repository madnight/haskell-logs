00:01:15 <__ryan> Geraldus: it's ok .. thank you in advance. :-)
00:01:55 <Geraldus> __ryan: surely, I was inattentive; selectFirst returns `Entity Person`, not Person. replace `Just p` to `(Just (Entity _ p))` and `found` to `Entity _ found`
00:03:11 <__ryan> Geraldus: thanks it work - so my code earlier nearly correct :-) thank you very much
00:03:26 <Geraldus> __ryan: glad to be helpful. 
00:12:24 <Javran> is it possible to write shebang line in a sandbox-ed source file? I tried "#!/usr/bin/cabal exec -- runghc" but "exec -- runghc" is wrongly passed as one single argument
00:12:28 * Geraldus reverting 7.8.4 back
00:12:55 <Javran> I don't want to compile it though
00:13:28 <__ryan> Geraldus: here again what does this erro mean? No instance for (ToMarkup (Maybe Text))
00:14:30 <Geraldus> __ryan: this means Yesod does not know how to make HTML code for Maybe value. If you want to simply show value you an use #{show myMaybeValue}
00:15:03 <Geraldus> __ryan: or you can use $maybe condition again
00:15:30 <__ryan> Geraldus: does show will result diff output?
00:15:52 * hackagebot persistent-sqlite 2.1.4.1 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-2.1.4.1 (MichaelSnoyman)
00:15:54 * hackagebot dataflow 0.1.0.1 - Generate Graphviz documents from a Haskell representation.  http://hackage.haskell.org/package/dataflow-0.1.0.1 (owickstrom)
00:15:55 <Geraldus> __ryan: did not understand you
00:15:57 <hunteriam> __ryan: what are you making?
00:16:25 <Geraldus> __ryan: hold for a while, I have to AFK for a few minutes
00:19:25 <__ryan> Geraldus: i got it show returns Nothing if the data has a Maybe on it :-) thank you
00:20:05 <Geraldus> __ryan: good (:
00:23:10 <wildsebastian> Hello! Is anyone of you using the nix package manager or nixos? Is it production ready? I am thinking of using at least nix on my laptop because the concept sounds very promising to me.
00:23:45 <wildsebastian> And sometimes development gets hard if you have to compile on different ghc versions
00:25:59 * hackagebot dataflow 0.2.0.0 - Generate Graphviz documents from a Haskell representation.  http://hackage.haskell.org/package/dataflow-0.2.0.0 (owickstrom)
00:46:01 * hackagebot equivalence 0.3.0.1 - Maintaining an equivalence relation implemented as union-find using STT.  http://hackage.haskell.org/package/equivalence-0.3.0.1 (PatrickBahr)
00:46:12 <cYmen__> I'm using blaze's stringValue to create the destination for an href but an & in my string is replaced by &amp;. Does anybody know what the correct conversion function is?
01:00:23 <cYmen__> hm...why does my haskell say it imported stringValue from Text.Blaze.Html5 and that it is defined in Text.Blaze.Internal but grepping through the source on github doesn't find it?
01:01:52 <mattyw> Hey folks - history question, It's my understanding that haskell existed as a language for a number of years before monads. Is that right? If so how long approx?
01:03:15 <dpwright> mattyw: This paper is the go-to resource for early haskell history: http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf
01:03:42 <dpwright> I can't remember if it answers that question specifically, but it's worth a read
01:03:43 <mattyw> dpwright, awesome, thank you very much!
01:04:15 <mattyw> dpwright, I think it does answer my specific question as well
01:08:54 <haskell734> Hi, where can I find >>= operator? (Its hard to google)
01:09:12 <cYmen__> Apparently the answer to my questions is that there is another repository https://hackage.haskell.org/package/blaze-markup and the function I wanted was preEscapedStringValue
01:09:23 <Freundlich> haskell734: You can use hoogle.
01:09:52 <cYmen__> haskell734: or just use ghci 
01:10:13 <freusque> Hello
01:10:19 <freusque> https://wiki.haskell.org//Typeclassopedia is empty
01:10:19 <sternenseemann> hi
01:10:25 <merijn> haskell734: Use Hoogle when searching for haskell operators
01:10:31 <freusque> does somebody have an idea?
01:10:35 <sternenseemann> freusque: https://wiki.haskell.org/Typeclassopedia is not
01:10:45 <sternenseemann> freusque: you had a / to much
01:10:45 <freusque> indeed
01:10:49 <freusque> :) thx
01:11:39 <oakwhiz> :t >=>
01:11:40 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
01:13:39 <quchen2> haskell734: It's known as the "bind" operator, which is one of the monad operations.
01:17:00 <haskell734> I forget to use parenthes at first. It should be: :t (>>=)
01:27:52 <jdnavarro> is there any decent alternative to ghc-mod out there?
01:28:31 <merijn> jdnavarro: ghci-ng is a work in progress, I think it works for emacs, but no vim plugin yet
01:29:12 * jdnavarro looking to something to get by until ghc-mod supports GHC 7.10.1
01:30:00 <jdnavarro> merijn, looks promising... but I use vim
01:32:00 <merijn> jdnavarro: GitHub repo for ghc-mod claims to support 7.10
01:32:09 <merijn> I just compiled it, but haven't tried to use it yet
01:35:22 <jdnavarro> merijn: sorry, it's not just 7.10, it's 7.10 together with cabal-install 1.22
01:35:24 <jdnavarro> merijn: https://github.com/kazu-yamamoto/ghc-mod/issues/437
01:36:14 <jdnavarro> there is also this: https://github.com/kazu-yamamoto/ghc-mod/wiki/InconsistentCabalVersions
01:38:20 <jdnavarro> now that I think about it, maybe it works if I downgrade to `cabal-install-1.20`
01:39:12 <jdnavarro> although is not the cabal version shipped with GHC-7.10.1, will I run into problems because of that?
01:42:00 <jdnavarro> jdnavarro, yeah, there may be issues: https://github.com/kazu-yamamoto/ghc-mod/wiki/InconsistentCabalVersions#what-is-happening-here
01:44:56 <Profpatsch> So I love the Data.Default.Generics Module.
01:45:26 <Profpatsch> But I wonder: Would it be possible to generalize a default for all Monoids?
01:45:28 <Profpatsch> Something like
01:45:34 <Profpatsch> instance Default Monoid where
01:45:39 <Profpatsch>    def = mempty
01:46:09 <idnar> @pl \f x -> (f x, x)
01:46:09 <lambdabot> ((,) =<<)
01:48:06 <idnar> hrm, maybe not
01:49:35 <mniip> idnar, (,) <*> f
01:50:38 <idnar> I guess what I really want is `foldr (\x m -> M.insert (f x) x m) M.empty xs`
01:51:04 * hackagebot keter 1.3.9.2 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-1.3.9.2 (MichaelSnoyman)
01:52:23 <Tazmain> are there haskell irc bots ?
01:52:27 <solatis> yes
01:52:31 <idnar> mniip: I like that spelling though, didn't think of using <*> like that
01:52:58 <Tazmain> solatis, are there examples 
01:53:02 <mniip> yeah you can just
01:53:05 <solatis> Tazmain, https://github.com/lambdabot/lambdabot is active in this channel
01:53:13 <idnar> mniip: oh wait, that tuple is the wrong way around
01:53:15 <Tazmain> thanks 
01:53:15 <mniip> flip M.insert <*> f
01:53:51 <idnar> flip, of course
01:56:04 * hackagebot filediff 0.1.0.4 - Diffing and patching module  http://hackage.haskell.org/package/filediff-0.1.0.4 (bgwines)
02:05:09 <whitelin`> i got the original zork source in MDL
02:05:35 <whiteline> but i can't make the MDL interpreter compile :(
02:07:47 <bartavelle> is there a canonical "isEmpty" typeclass ?
02:08:35 <dramforever> Nullable?
02:08:43 <dramforever> @hoogle Nullable
02:08:45 <lambdabot> No results found
02:09:00 <dramforever> I remembered seeing one...
02:09:04 <bartavelle> it's at least in fay and persistent
02:09:16 <bartavelle> doesn't look generic though
02:09:42 <bartavelle> ho well, lens has what I am looking for !
02:10:28 <dramforever> lol lens has everything
02:10:36 <bartavelle> yeah, that rocks
02:12:00 <ocramz`> FFI question: do I need to write Storable instances of C structs if I only access them through (FFI-bound) library functions? I.e. I won't have to look or modify their internal fields
02:13:25 <dramforever> ocramz`: IMHO no, if you pass everything by pointer
02:13:29 <dramforever> @hackage hslua
02:13:29 <lambdabot> http://hackage.haskell.org/package/hslua
02:13:39 <dramforever> ^ not too complex example
02:14:31 <solatis> eh, silly question, but what function am i looking for when i want to generate a list with the outputs of calling a function 100 times?
02:14:46 <solatis> hmm wait
02:14:51 <solatis> i think where my mistake is
02:14:55 <solatis> +i know
02:15:08 <solatis> i am looking for replicateM
02:15:13 <solatis> not replicate
02:15:47 <dramforever> solatis: Always look at the type.
02:15:57 <dramforever> just too useful
02:15:58 <solatis> well
02:16:00 <ClaudiusMaximus> :t iterate
02:16:01 <lambdabot> (a -> a) -> a -> [a]
02:16:05 <solatis> in this case i am generating random numbers
02:16:16 <dramforever> solatis: randoms?
02:16:18 <dramforever> :t randoms
02:16:20 <lambdabot> (RandomGen g, Random a) => g -> [a]
02:16:24 <solatis> ah!
02:16:36 <solatis> almost what i'm looking for
02:16:48 <solatis> too bad i'm using crypto.random and not system.random :/
02:16:50 <ocramz`> dramforever: thanks, I'll look into that example :)
02:16:59 <dramforever> oh
02:17:08 <dramforever> ocramz`: :)
02:21:28 <jle`> bartavelle: what kind of interface are you looking for?
02:21:35 <jle`> isEmpty :: t a -> Bool ..?
02:21:59 <jle`> :t null
02:22:00 <lambdabot> Foldable t => t a -> Bool
02:22:10 <dramforever> hmm...
02:22:15 <dramforever> wow
02:22:31 <dramforever> :t traverse id -- isn't that cute?
02:22:33 <lambdabot> (Applicative f, Traversable t) => t (f b) -> f (t b)
02:22:48 <jle`> traverse id == sequenceA
02:22:57 <dramforever> oh
02:23:01 <bartavelle> jle`, _Empty from Control.Lens is exactly what I am looking for
02:23:03 <jle`> mapM id == sequence
02:23:03 <dramforever> sure
02:23:09 <dramforever> yep
02:23:15 <jle`> bartavelle: cool :)
02:23:20 <bartavelle> indeed !
02:24:26 <safinaskar> @src monad
02:24:26 <lambdabot> Source not found. :(
02:24:29 <jle`> i guess _Empty has the advantage of being kind-polymorphic
02:25:05 <jle`> safinaskar: Monad is a typeclass, so you can find the members of the typeclass by using :i in ghci
02:25:13 <safinaskar> @src monad
02:25:13 <lambdabot> Source not found. Whoa.
02:25:13 <jle`> or hoogle
02:25:15 <safinaskar> @src monad
02:25:15 <lambdabot> Source not found. Just what do you think you're doing Dave?
02:25:16 <jle`> @hoogle Monad
02:25:19 <lambdabot> Prelude class Monad m
02:25:19 <lambdabot> Control.Monad class Monad m
02:25:19 <lambdabot> Control.Monad.Instances class Monad m
02:25:21 <safinaskar> @src monad
02:25:21 <lambdabot> Source not found. Just try something else.
02:25:23 <safinaskar> @src monad
02:25:23 <lambdabot> Source not found. My mind is going. I can feel it.
02:25:23 <jle`> er, hoogle online :)
02:25:27 <safinaskar> @src monad
02:25:27 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
02:25:34 <jle`> hm.
02:25:36 <bartavelle> jle`, it also have the advantage of already being in my imported modules :)
02:25:41 <dramforever> jle`: I think safinaskar is playing with error messages
02:25:53 <jle`> bartavelle: well in 7.10 null is in prelude :)
02:25:54 <dramforever> safinaskar: /query lambdabot
02:26:00 <jle`> so nothing to import :D
02:26:20 <bartavelle> oh, that's nice !
02:26:32 <ocramz`> @src Monad
02:26:32 <lambdabot> class  Monad m  where
02:26:32 <lambdabot>     (>>=)  :: forall a b. m a -> (a -> m b) -> m b
02:26:32 <lambdabot>     (>>)   :: forall a b. m a -> m b -> m b
02:26:32 <lambdabot>     return :: a -> m a
02:26:32 <lambdabot>     fail   :: String -> m a
02:26:39 <dramforever> jle`: this reminds me of a lens type I made (nothing compared to van Laarhoven lens)
02:26:45 <dramforever> doesn't even require prelude
02:26:58 <jle`> also there's a good chance that you're importing Data.Foldable anyway even if you're pre-7.10
02:27:45 <safinaskar> int-e: hi, your bot says to me very unpleasant phrases, when @src cannot find source, for example, "Are you on drugs?", "You untyped fool!", "I've seen penguins that can type better than that.". please, remove this phrases. programs should not swear
02:28:59 <ocramz`> safinaskar: only programmers should :D
02:29:04 <merijn> That's not even swearing
02:29:33 <safinaskar> merijn: okey, but this phrases should be removed anyway
02:30:08 <dramforever> safinaskar: yeah
02:30:33 * dramforever imagines a haskell noob types @src monad....
02:30:41 <dramforever> *typing
02:32:18 <Fuuzetsu> What a productive use of someone's time to complain about something like this.
02:34:06 <idnar> I did always find the error responses from lambdabot a bit disconcerting
02:35:09 <f|`-`|f> @src fmap
02:35:10 <lambdabot> Source not found. Whoa.
02:35:18 <f|`-`|f> @src Maybe
02:35:19 <lambdabot> data Maybe a = Nothing | Just a
02:35:35 <dramforever> maybe you should never use it
02:39:35 <f|`-`|f> @src AccumFail
02:39:35 <lambdabot> Source not found. Take a stress pill and think things over.
02:49:43 <aawe> @src stress pill
02:49:43 <lambdabot> Source not found. It can only be attributed to human error.
02:49:43 <safinaskar> Javran: about "exec -- runghc": you run this on linux, right? this "exec -- runghc" passed as one argument because this is way linux kernel works. so, you need some hack, for example: http://paste.debian.net/165671/
02:53:51 <rockfruit> can pattern matching enable me to make a function which can receive zero arguments, in addition to other patterns?
02:54:04 <opqdonut> no
02:54:18 <opqdonut> unless you use something like Nothing or [] to signify "zero" arguments
02:54:27 <rockfruit> okay, thanks.
02:54:52 <opqdonut> haskell isn't really compatible with variable arguments, but you can use typeclass hacks to get them
02:56:51 <tdammers> [] is probably the best general-purpose approach
02:57:05 <tdammers> unless you need heterogenous arg lists
02:58:21 <rockfruit> Don't really need them now, just going through tuts.
03:09:44 <Hi-Angel> Hello, I am trying to understand «newtype», and come across these examples at Haskell wiki: α) «Any . getAny $ Any False = Any False» — okay, I executed in ghci the «Any . getAny $ Any False», and got the answer, it's fine, next I look at the β) «Any . getAny $ Any ⊥     = Any ⊥ », so I execute the «getAny $ Any undefined», and… Obviously I am getting an error, but I didn't got what the author wanted to show with the β example?
03:11:26 <rockfruit>  
03:12:09 <Hi-Angel> Ah,  «Any . getAny $ Any undefined», anyway
03:12:16 <notdan> Hi-Angel: can you paste the link to the wiki?
03:12:30 <Hi-Angel> It is here https://wiki.haskell.org/Newtype
03:12:55 <Hi-Angel> https://wiki.haskell.org/Newtype#The_messy_bits
03:12:57 <opqdonut> Hi-Angel: the difference between newtype and data is that for a newtype N, "N undefined" is undefined, but for a data D, "D undefined" is ok
03:13:53 <opqdonut> Hi-Angel: that's what the example is trying to show, Any is a data so "Any undefined" is distinct from "undefined" as the case pattern match shows
03:14:42 <opqdonut> Hi-Angel: in practical terms, "data D = D Foo" is at runtime a "boxed" Foo, i.e. there's a D object in memory that has a pointer to a Foo
03:15:14 <opqdonut> Hi-Angel: on the other hand "newtype N = N Foo" is at runtime just a Foo, i.e. the newtype disappears during compilation. so a newtype is like a type-safe type alias
03:16:19 * hackagebot hakyll 4.6.8.1 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.6.8.1 (JasperVanDerJeugt)
03:16:55 <Hi-Angel> Okay, I think I need some time to understand it, but I think is's pretty good explanation, thank you very much!
03:20:48 <quchen2> Hi-Angel: A note about naming, don't think too much about it. If we started again, we should probably replace "type" with "synonym", "newtype" with "wrapper", and "data" with "type" or something along those lines.
03:21:19 * hackagebot getopt-generics 0.2 - Simple command line argument parsing  http://hackage.haskell.org/package/getopt-generics-0.2 (SoenkeHahn)
03:21:25 <narendraj9> shachaf: Got the proof. Now I am trying to understand how the alternative formulation for applicative works. 
03:21:55 <quchen2> Hi-Angel: A good first-order approximation to newtype compared to data is that newtype is more efficient, but you're limited to a single constructor. newtype compared to type gives you type safety at the cost of having to wrap/unwrap everything.
03:23:38 <Hi-Angel> Okay, thank you, I think I just need some practice to see that
03:40:50 <int-e> I wonder whether I'd get more complaints about disabling lambdabot's snarks than about having them (I hardly get any about the latter...)
03:43:18 <hpc> well, there was that one time with nixon
03:43:30 <hpc> or vixen maybe?
03:56:21 * hackagebot dataflow 0.3.0.0 - Generate Graphviz documents from a Haskell representation.  http://hackage.haskell.org/package/dataflow-0.3.0.0 (owickstrom)
04:23:37 <lolisa> Hello guys, I had seen an article on research journal describing an algorithm, I want to implement it, prove it (via Coq), but how can I do it so I will not violate any copyright law? Also, my code will be opensource on github...
04:24:15 <opqdonut> by not copying the code verbatim
04:24:23 <opqdonut> copyright only applies to the exact code, not the ideas / architecture
04:24:26 <opqdonut> IANAL
04:24:28 <merijn> opqdonut: not true
04:24:48 <merijn> Writing it after reading may constitute a derived work
04:25:04 <merijn> Hence why cleanroom implementations exist
04:25:41 <opqdonut> hmm, right
04:25:44 <merijn> lolisa: I wouldn't worry about copyright of academic papers, though. If you're really worried, email the author
04:27:31 <lolisa> merjin, are there any links/webpages which said I don't really need to worry at all? I don't want to ruin my life because of copyright stuff...
04:28:37 <merijn> lolisa: Because most academics publish their stuff so it gets used :)
04:29:06 <merijn> Certainly they wouldn't care enough to "ruin your life", but emailing the authors can't hurt
04:32:25 <arkeet> it might please the authors that someone is using their work :-)
04:32:56 <ocramz`> how does the Hackage account registration work? I\ve filled in the form a few months ago but I'm pretty sure nobody/nothing ever replied
04:33:02 <arkeet> you just register.
04:33:11 <arkeet> http://hackage.haskell.org/accounts
04:43:39 <merijn> hmm, so anyone using ghc-mod with vim? I tried installing the current HEAD to get it to work with ghc7.10, but I only seem to get errors in syntastic and be unable to query types
04:50:25 <merijn> Any suggestions how to avoid this: http://lpaste.net/130342 ?
04:51:09 <merijn> I don't understand why it's trying to install cabal-1.22 when I run a syntax checker...
04:51:30 <merijn> Like...wut?
04:54:15 <pacak> merijn: (global constraint requires ==1.22.0.0) - try modifying cabal file to relax this constraint a bit.
04:55:24 <merijn> pacak: Which cabal file
04:55:30 <merijn> There is not cabal file, that's the problem
04:55:50 <pacak> Whichever it tries to install
04:56:20 <merijn> pacak: The problem is: I don't understand why it's trying to install ANYTHING?
04:56:38 <pacak> --verbose ?
04:56:52 <merijn> I have ghc-mod compiled and a working cabal package (with no Cabal dependency) and running "ghc-mod check" inside that directory suddenly tries to install cabal
04:57:05 <merijn> But I have no clue why the hell ghc-mod would try to install anything at all
04:57:34 <merijn> There is no --verbose for ghc-mod...
04:58:06 <pacak> Hmmm.... Something like `strace` then :)
04:58:55 <mniip> woah
04:59:03 <mniip> apparently you can combine record syntax with operators
04:59:47 <tdammers> mniip: what do you mean?
04:59:52 <mniip> data Test = (:|) { getInt :: Int, getBool :: Bool }
05:00:04 <tdammers> ah
05:00:21 <mniip> can do stuff like getBool (1 :| True)
05:00:23 <tdammers> I thought you meant something like data Test = Test { (:|) :: Int }
05:01:44 <tdammers> or, probably more useful, data Test = Test { (:|) :: Int -> Int }
05:02:17 <lolisa> Thankyou, I decide to email the author first just in case :) I think his email address is still valid...
05:03:46 <merijn> pacak: That doesn't help at all, just shows forking to something
05:03:58 <merijn> bah
05:04:28 <merijn> So hdevtools is broken and despite all the people telling me to use ghc-mod there appears to be no explanation of how I'm supposed to get that working
05:05:02 <pacak> merijn: You can ask it to follow those fork to find out what exactly it tries to execute.
05:05:17 <frerich> merijn: hdevtools doesn't build either?
05:06:14 <merijn> frerich: hdevtools has been broken since 7.8 I had merged a few community fixes to get it working, but 7.10 broke it again and I don't wanna keep patching it up every GHC release
05:06:41 <frerich> merijn: https://github.com/schell/hdevtools had a 'Add 7.10 support' commit a few days ago
05:06:45 <frerich> merijn: Maybe that's worth a try at least.
05:06:59 <frerich> Disclaimer: I didn't try it myself (the 7.10 support).
05:17:54 <jdnavarro> merijn: I ended up downgrading to GHC-7.8.1 and cabal-1.20 to get ghc-mod working
05:19:19 <jdnavarro> apparently ghc-mod doesn't work with cabal-install-1.22 and GHC-7.10.1 needs cabal-install-1.22
05:20:07 <merijn> Right, back to patching hdevtools it is, then
05:20:43 <jdnavarro> the relevant  ghc-mod bug: https://github.com/kazu-yamamoto/ghc-mod/issues/437
05:20:58 <phaazon> hey, what's the kind of assembly generated by GHC?
05:21:02 <phaazon> AT&T?
05:22:19 <jdnavarro> merijn: hdevtools doesn't depend on ghc-mod?
05:22:41 <jdnavarro> does it work as a checker for syntastic?
05:23:07 <merijn> jdnavarro: Why would hdevtools depend on ghc-mod?
05:23:09 <merijn> And yes
05:23:55 <sagittarian|2> what do i need to install in order to be able to do import Control.Monad.State?
05:23:58 <jdnavarro> merijn: I thought it was a wrapper around other tools, ghc-mod among them
05:24:04 <jdnavarro> I'll check it out
05:29:35 <jdnavarro> phaazon: there is a nice overview of GHC compilation process at http://dev.stephendiehl.com/hask/#ghc
05:36:40 <benzrf> hmmmmmm
05:37:11 <benzrf> if i have some kind of reified pattern and an indication as to which subpart of a data structure corresponds to a variable in it
05:37:20 <srhb> sagittarian|2: Nothing, it should be in base
05:37:34 <srhb> Or wait, is it actually mtl...
05:37:50 <benzrf> what would be the best solution for then getting out, like, confirmation or not that it matches and, if it does, a dictionary of matches
05:37:57 <srhb> sagittarian|2: It's mtl, sorry.
05:38:08 <benzrf> is there a lib for this?
05:38:11 <sagittarian|2> srhb: thanks
05:38:42 <srhb> sagittarian|2: You can always check the package name on hackage :)
05:39:00 <sagittarian|2> srhb: yeah but I saw a few and I wasn't sure
05:39:07 <srhb> sagittarian|2: Gotcha.
05:39:08 <sagittarian|2> what's the difference between mtl and transformers?
05:39:16 <benzrf> e.g. if i have `BranchPat "cool" (VarPat "a") (VarPat "b")' and then `Branch "cool" (Leaf 1) (Leaf 2)', get out a True and `fromList [("a", Leaf 1), ("b", Leaf 2)]'
05:39:16 <sagittarian|2> also I also thought I shouldn't have to install anything
05:39:53 <benzrf> and further, how can i do that given that that branch is further down into a data structure and i only know that the `Leaf 1' should match with the a
05:40:08 <benzrf> i could manually write something that runs around and does the match, i guess
05:40:19 <benzrf> i feel like this is probably already done though
05:40:27 <srhb> sagittarian|2: I've never _not_ had Control.Monad.State available by default, but it depends how you've installed everything. There are both historical differences and differences on approach between transformers and mtl, but nowadays they are used together, irrc
05:41:13 <srhb> sagittarian|2: (In fact, mtl depends on transformers)
05:42:18 <benzrf> hmm
05:43:08 <merijn> srhb, sagittarian|2: transformers contains the implementation of common monad transformers like StateT, ReaderT, etc. mtl is the library that uses typeclasses for "autolifting" and working with unspecified transformer stacks
05:43:47 <merijn> You might be thinking of the typefamilies approach to mtl which competed with mtl in terms of design, but almost everyone uses mtl nowadays
05:44:22 <srhb> merijn: You are right. Thanks for clearing that up. :)
05:44:28 <srhb> I actually thought it was about fundeps though.
05:44:35 <srhb> Oh, same thing I guess.
05:45:29 <merijn> mtl uses multiparam typeclasses + fundeps, the other (forgot the name) uses typefamilies
05:46:53 <srhb> monads-tf and mtl-tf probably.
05:51:11 <ane> does hdevtools support cabal sandboxes yet?
05:51:42 <merijn> ane: There's some patches floating around that
05:51:51 <merijn> But it's not being updated on hackage anymore anyway
05:52:10 <ane> where is it being updated? nowhere?
05:52:26 <merijn> ghc-mod is still maintained, but the person maintaining hasn't had time to release a 7.10 ready release
05:52:29 <merijn> ane: github forks
05:53:14 <ane> right, well, that's the reason i'm using ghc-mod as well, and it supports cabal sandboxes
05:54:09 <gwm_> How would I go about making a function which removes all occurences of an empty lists inside another list?
05:54:34 <srhb> gwm_: filter (/=[]) 
05:54:34 <frerich> gwm_: 'filter (not . null)' might do what you want.
05:54:48 <gwm_> okay i'll look into that
05:55:12 <lachenmayer> ryantrinkle: just watched your Reflex talk, really great!
05:55:24 <merijn> srhb: :(
05:55:33 <merijn> srhb: That only works on lists with Eq instance elements
05:55:45 <tdammers> filter (not . null) -- would be the most straightforward way
05:55:52 <srhb> Aye.
05:56:12 <tdammers> > let theList = [ [1,2,3], [], [4,5,6] ] in [ x:xs | x:xs <- theList ]
05:56:13 <lambdabot>  [[1,2,3],[4,5,6]]
05:56:22 <tdammers> a bit more esoteric :D
05:57:14 <quchen2> Smells like golf time.
05:59:30 <benzrf> ooh, nice
06:02:09 <crvs> hi!
06:04:39 <hexagoxel> > let theList = [ [1,2,3], [], [4,5,6] ] in theList >>= (maybeToList . listToMaybe >>= ($>))
06:04:40 <lambdabot>  [[1,2,3],[4,5,6]]
06:20:33 <zinfandel> Hmm. What is the good way of managing data-files which are used during compilation with TH?
06:20:41 <zinfandel> Just adding them to extra-source-files?
06:21:53 <zinfandel> Because when I add them to data-files, and try to access location given by 'getDataFileName' at compile time, there is no file at given location.
06:22:37 <slack1256> We can I get a shared ghci session for me and a pal?
06:23:01 <hodapp> alright, what's the quickest way to get a GHC 7.10.1 installation on a DigitalOcean droplet so I can put together a minimal test case for a bug?
06:23:08 <zinfandel> slack1256: Sure, use tmux.
06:23:14 <wei2912> does haskell have a function for modular exponentiation?
06:23:20 <slack1256> possible in the web browser
06:23:39 <zinfandel> slack1256: Ohh. There was such a project. But I am not sure how did it go.
06:23:47 <hodapp> I'm on Arch now, but no Arch on DigitalOcean.
06:24:18 <Tazmain> so haskell is completely open source? 
06:24:25 <zinfandel> Tazmain: yup
06:24:36 <merijn> Tazmain: Yes?
06:24:44 <RageD> slack1256: https://coderpad.io/
06:24:52 <merijn> Well, technically speaking Haskell is just a spec
06:24:54 <zinfandel> Tazmain: And it's that kind of open source where contributions are welcome
06:25:04 <RageD> not quite ghci
06:25:05 <merijn> But the GHC implementation is open source
06:25:10 <zinfandel> merijn: Yeah, I meant GHC
06:25:16 <merijn> (and so is UHC)
06:25:18 <RageD> but a shared notepad that will compile and run code, anyway
06:25:46 <zinfandel> slack1256: https://ghclive.wordpress.com/
06:26:01 <hodapp> silly question: Can I just update GHC through cabal?
06:26:40 <slack1256> zomfadeñ RageD: Just what I needed, thanks
06:28:02 <merijn> hodapp: No
06:28:15 <hodapp> dang.
06:28:22 <hodapp> I saw the 'ghc' package and was curious.l
06:28:30 <merijn> hodapp: Because there's no cabal package for GHC and because Cabal the library part ships as part of the compiler
06:28:49 <merijn> hodapp: That package is the GHC-as-a-library API
06:28:52 <hodapp> oh.
06:28:59 <crvs> oh that sort of answers part of my question, I guess
06:29:13 <hodapp> merijn: should I just go a GHC build then?
06:29:18 <crvs> is anyone using vim + syntastic + ghc-mod?
06:29:30 <merijn> hodapp: Why not download the binary release of 7.10?
06:29:40 <merijn> crvs: I tried, but there's no 7.10 compatible ghc-mod yet
06:29:40 <srhb> Does anyone know if there's a channel for the spock framework somewhere? I'm looking for some hand holding in implementing a server-side facebook auth system, and doing it via Snaplets feels too daunting right now.
06:29:53 <srhb> (Even though Snap is obviously awesome. :-))
06:30:22 <crvs> ... and that answers why that stopped working for me a few days back
06:30:27 <bennofs> ryantrinkle: in reflex, could merge be implemented in terms of align (from the Align class) ? or will that be less efficient
06:30:40 <hodapp> merijn: hmm, wasn't aware that was an option. I've only done Haskell thus far via distro packages
06:30:58 <crvs> damn you pacman and your up-to packages
06:31:11 <crvs> *up-to-date package repository
06:33:17 <crvs> downgrading ghc... fingers crossed...
06:33:23 <RaceCondition> what's my best option to manage 2 or more installed GHC and/or Haskell Platform versions on an OS X 10.9 system?
06:33:54 <srhb> RaceCondition: Probably some kind of hsenv usage.
06:34:11 <srhb> Or simpler, virtual machines.
06:34:21 <crvs> oh great now that part is working... So last question (for now) how do you get ghc-mod to work with a cabal sandbox?
06:34:31 <srhb> crvs: I think it "just does" these days?
06:34:43 <RaceCondition> the installed set of cabal packages would also have to be isolated to a single version, generally?
06:34:51 <srhb> RaceCondition: Yes, absolutely.
06:35:29 <crvs> i feared you would say that :( for some reason it tells me that Control.Parallel isn't installed even though I installed it in the sandbox
06:35:40 <crvs> also it doesn't find my modules
06:35:57 <Geraldus> hey guys, does anybody knows where can I see a translation table of curl options (e.g. CURLOPT_URL) to corresponding command line args? 
06:36:00 <srhb> crvs: Is the project also cabalized?
06:36:12 <crvs> yep
06:36:44 <crvs> i ran cabal init + cabal sandbox init and edited the .cabal file to reflect what is going on in the package
06:36:45 <srhb> crvs: And ghc-mod check just spews missing modules?
06:37:14 <merijn> hodapp: There's binary builds on the GHC site
06:37:33 <merijn> RaceCondition: No, GHC always maintains a per version database
06:37:46 <merijn> RaceCondition: So usually I have platform installed + a custom install whereever
06:38:01 <merijn> RaceCondition: Cabal just uses whichever comes first in your PATH, so I switch by changing my path
06:38:06 <RaceCondition> merijn: so cabal installs to whatever it sees is the currently "active" haskell version
06:38:07 <crvs> oh wait my working directory was outside of the package
06:38:10 <RaceCondition> GHC version, I mean
06:38:12 <crvs> now it just doesnt run
06:38:14 <merijn> RaceCondition: Yeah
06:38:20 <srhb> crvs: What doesn't run?
06:38:24 <crvs> ghc-mod
06:38:40 <srhb> Oh. :P
06:38:44 <RaceCondition> merijn: so I can then have my non-primary/non-HP GHC versions managed by 1 or more hsenvs and just point my PATH to wherver I want
06:38:49 <srhb> Sorry, I don't know what the problem might be.
06:38:55 <merijn> RaceCondition: I have a ~/ghc/7.8.3 ~/ghc/head etc. paths and just change my path to have the one I want first
06:39:14 <merijn> RaceCondition: I don't even use hsenv or anything fancy like that
06:39:27 <RaceCondition> merijn: that's good to know
06:39:42 <merijn> RaceCondition: As long as you didn't want multiple installs of the same version you shouldn't need anything more
06:39:52 <RaceCondition> a cabal sandbox won't then be associated to a specific GHC version, and instead will use whatever is visible?
06:40:14 <RaceCondition> even if it's not the GHC version that sandbox should be using
06:40:31 <merijn> RaceCondition: A sandbox will have a local package database, which will also be version specific, so if you switch between versions in the sandbox it will just see a empty one and rebuild for whatever version is active
06:40:43 <crvs> gonna try a few things and report back
06:41:06 <RaceCondition> merijn: that's the info I wanted :)
06:41:13 <srhb> RaceCondition: Sorry I lied, apparently. :)
06:41:30 * hackagebot dataflow 0.3.1.0 - Generate Graphviz documents from a Haskell representation.  http://hackage.haskell.org/package/dataflow-0.3.1.0 (owickstrom)
06:41:30 <RaceCondition> srhb: no probs
06:42:19 <merijn> RaceCondition: It's all surprisingly easy if you're used to the pain of trying to have multiple versions/user local installs of, say, python :p
06:43:29 <crvs> and unsurprisingly ghc-mod doesn't have --package-db flag :(
06:43:38 <crvs> sdness ensued
06:45:10 <crvs> oh wait, it does...
06:45:14 <bennofs> crvs: I think ghc-mod has a way to pass arbitrary options to GHC
06:45:30 <crvs> yeah just found it :p
06:46:38 * hackagebot concurrent-split 0.0.0.1 - MVars and Channels with distinguished input and output side  http://hackage.haskell.org/package/concurrent-split-0.0.0.1 (HenningThielemann)
06:46:40 * hackagebot stm-split 0.0.0.1 - TMVars, TVars and TChans with distinguished input and output side  http://hackage.haskell.org/package/stm-split-0.0.0.1 (HenningThielemann)
06:46:42 * hackagebot pooled-io 0.0.1 - Run jobs on a limited number of threads and support data dependencies  http://hackage.haskell.org/package/pooled-io-0.0.1 (HenningThielemann)
06:55:21 * hodapp twiddles thumbs while bootstrapping cabal-install
06:59:09 <hellertime> is there a way to get ghci to break at the point where an exception is thrown, rather than at the top level function in which the exception was raised?
06:59:45 <merijn> hellertime: I think so, but the exception might not be thrown when you think it is (if you're using "error")
07:00:09 <arkeet> because of laziness
07:00:34 <hellertime> its a client library throwing the exception, but it appears to be using throwIO
07:01:07 <hellertime> (will that have a simmilar effect as error — since IO)?
07:02:13 <crvs> ok so what ghc-mod is giving me now is dist/setup-config 
07:03:01 <slack1256> crvs: Are you using Ghc 7.8
07:03:02 <slack1256> ?
07:03:07 <crvs> yep
07:03:25 <crvs> downgraded it just a bit ago
07:03:41 <slack1256> you have to install Cabal < 1.22, because it uses a different format for dist/setup-config
07:04:16 <crvs> Cabal the cabal package or cabal-install or are those completely unrelated
07:04:30 <slack1256> https://github.com/kazu-yamamoto/ghc-mod/wiki/InconsistentCabalVersions
07:05:10 <slack1256> I think you need both
07:05:35 <crvs> meh... not good...
07:05:59 <slack1256> it's not so bad. But yeah, could be better
07:06:38 <slack1256> But I can't think of anything that much different between 1.20 and 1.22
07:07:10 <crvs> only have versions 1.22.0 and 1.22.2 in cache...
07:07:50 <crvs> fortunately it's on git...
07:11:39 * hackagebot darcs-scripts 0.1.1 - Shell scripts for support of darcs workflow  http://hackage.haskell.org/package/darcs-scripts-0.1.1 (HenningThielemann)
07:14:28 <RaceCondition> $ hoogle data fails with http://lpaste.net/130346 -- any suggestions?
07:14:28 <RaceCondition> hoogle --version == Hoogle v4.2.39
07:16:39 * hackagebot cabal-scripts 0.1.1 - Shell scripts for support of Cabal maintenance  http://hackage.haskell.org/package/cabal-scripts-0.1.1 (HenningThielemann)
07:17:03 <crvs> it lives!!!!
07:17:17 <crvs> (where is a thunder storm when you need one?)
07:17:26 <slack1256> crvs: ghc-mod?
07:17:30 <crvs> yep!
07:17:46 <crvs> slack1256: thank you so much
07:18:09 <slack1256> Glad to be helpful ;-)
07:18:24 <slack1256> Weird how once you try ghc-mod, you can't program without it
07:19:05 <crvs> I can but it's just so painful to have to rely on ghci to tell me where I slipped up
07:19:30 <crvs> also once it's integrated in syntastic it's just so beautiful
07:41:40 * hackagebot binembed 0.1.0.3 - Embed data into object files.  http://hackage.haskell.org/package/binembed-0.1.0.3 (ClaudeHeilandAllen)
07:41:42 * hackagebot binembed-example 0.1.0.3 - Example project using binembed to embed data in object files.  http://hackage.haskell.org/package/binembed-example-0.1.0.3 (ClaudeHeilandAllen)
07:43:18 <gcganley> Hi, is ghcjs failing with 7.10 or is it just failing for me, i can lpaste the error message if someone wants to help. thank you
07:45:24 <lpaste> gcganley pasted “Error from compiling ghcjs” at http://lpaste.net/130348
07:51:41 * hackagebot pooled-io 0.0.1.1 - Run jobs on a limited number of threads and support data dependencies  http://hackage.haskell.org/package/pooled-io-0.0.1.1 (HenningThielemann)
07:51:53 <cow_2001> edid you guys see my GUI SIMULATOR 2001? I'm going to release it on Steam Green Light. https://i.imgur.com/YC8oCMZ.png
07:52:24 <slack1256> 9/10 -- IGN
07:55:30 <dredozubov> Call of GUI
07:56:23 <cow_2001> i think i'll start releasing all of my tutorial mishaps on Steam Green Light
07:57:13 <frerich> Grand Theft GUI
07:57:31 <dredozubov> oh, got it
07:57:34 <dredozubov> GUI of War
07:57:45 <frerich> Gianna GUI
07:58:28 <frerich> Need For GUI
08:06:44 <cow_2001> this place isn't #haskell-blah D:<
08:06:52 <cow_2001> can't talk offtopic D:<
08:09:52 <frerich> > unwords . zipWith (\i s -> if i == 3 then "GUI" else s) [0..] . words $ "The Adventures of Indiana Jones"
08:09:54 <lambdabot>  "The Adventures of GUI Jones"
08:11:37 <RaceCondition> hoogle data is trying to access https://wiki.haskell.org//Keywords instead of https://wiki.haskell.org/Keywords -- a bug in hoogle?
08:13:13 <c_wraith> RaceCondition: technically, yes, but last I saw the URI spec considered those to be basically the same URL
08:13:49 <RaceCondition> 404 is what the HTTP server at haskell.org returns for //Keywords...
08:13:57 <merijn> c_wraith: Unfortunately, the wiki runs some php wiki written by someone who probably doesn't know what a spec is if it hit them in the face repeatedly
08:14:32 * ski . o O ( "GUI Joe" )
08:14:59 <RaceCondition> until the wiki gets fixed, hoogle data is broken?
08:16:05 <cow_2001> ski: :D
08:16:30 <cow_2001> frerich: :D
08:18:49 <Athas> Is there a standard name for 'flip <$>'?
08:19:12 <lolisa> flop :-P
08:19:17 <Tazmain> lol 
08:19:19 <frerich> hehe
08:19:36 <frerich> @hoogle a -> (a -> b) -> b
08:19:38 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
08:19:38 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
08:19:38 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
08:19:49 <frerich> Err sorry, wrong $.
08:26:41 <ski> @type (\flip -> (flip `fmap`)) (flip (fmap . flip ($)))
08:26:43 * hackagebot yesod-auth-oauth2 0.1.0 - OAuth 2.0 authentication plugins  http://hackage.haskell.org/package/yesod-auth-oauth2-0.1.0 (PatrickBrisbin)
08:26:43 <lambdabot> (Functor f, Functor f1) => f (f1 (a -> b)) -> f (a -> f1 b)
08:51:44 * hackagebot pseudo-trie 0.0.4.3 - A tagged rose-tree with short circuited unique leaves  http://hackage.haskell.org/package/pseudo-trie-0.0.4.3 (athanclark)
08:52:54 <john_doe_jr> I'm trying to build a package and I am getting the following error: "Could not find module `Control.Monad.Catch'"….any ideas why I am getting this error?
08:54:40 <crvs> do you happen to be missing that particular module?
08:55:48 <john_doe_jr> crvs: I did a cabal update; cabal install mtl…
08:56:02 <c_wraith> that module isn't in mtl
08:56:05 <crvs> try cabal install exceptions
08:56:15 <c_wraith> are you attempting to install a package without a cabal file?
08:56:28 <john_doe_jr> c_wraith: nope….
08:56:35 <c_wraith> Usually packages list their requirements in their cabal file
08:56:58 <john_doe_jr> c_wraith: I'm trying to install git-annex from source: https://git-annex.branchable.com/install/fromsource/
08:57:43 <c_wraith> john_doe_jr: ok, but that lists a bunch of different methods.  are you using cabal to build it?
08:58:16 <hexagoxel> Athas: (<&>), see http://hackage.haskell.org/package/lens-4.9/docs/Control-Lens-Lens.html#v:-60--38--62-
08:59:34 <john_doe_jr> c_wraith: yes 
08:59:52 <hexagoxel> (also, hayoo seems to do a better job for searching here, as the index is somewhat larger)
09:00:12 <john_doe_jr> c_wraith: I used "cabal configure" 
09:00:16 <JoshieAS> I have a question about Streams
09:00:27 <JoshieAS> I'm doing the CIS194 homework and I don't understand how to represent a Stream as input
09:00:37 <JoshieAS> streamToList :: Stream a -> [a]
09:00:56 <crvs> john_doe_jr: are you building it sandboxed
09:01:04 <glguy> JoshieAS: Are you asking how to define a new algebraic data type with "data"?
09:01:10 <c_wraith> john_doe_jr: and did cabal configure tell you that you were missing dependencies?
09:01:15 <JoshieAS> I've already defined my Stream type
09:01:26 <JoshieAS> I want to -use- my function streamToList but I don't know how to represent the Stream
09:01:43 <JoshieAS> streamToList (Stream 1 -what goes here?!-)
09:01:47 <john_doe_jr> c_wraith: yes
09:02:01 <glguy> JoshieAS: more stream. streams don't end
09:02:22 <glguy> repeatStream x 07= Stream x (repeatStream x)
09:02:25 <glguy> for example
09:02:27 <ReinH> JoshieAS: you construct a Stream using whatever constructors you defined
09:02:35 <c_wraith> john_doe_jr: so did you run "cabal install --dependencies-only"?
09:02:40 <JoshieAS> I suppose that confuses me
09:02:42 <JoshieAS> here is my Stream type
09:02:50 <JoshieAS> data Stream a = Stream a (Stream a)
09:03:04 <ReinH> So then glguy's example would work
09:03:21 <JoshieAS> oh, oh, I see
09:03:23 <JoshieAS> *click*
09:03:25 <JoshieAS> Thank you
09:03:52 <ReinH> JoshieAS: It's a bit confusing because Stream is both a type and a value there.
09:04:05 <ReinH> It might be more obvious to say data Stream x MkStream x (Stream x)
09:04:17 <ReinH> er, data Stream x = MkStream x (Stream x)
09:04:44 <JoshieAS> gotcha, that makes a lot of sense now
09:06:39 <john_doe_jr> c_wraith: I tried to run "cabal install --dependencies-only" but it states that —dependencies-only  is not an option
09:06:59 <c_wraith> john_doe_jr: what version of cabal is it?
09:07:06 <slack1256> it --only-dependencies
09:07:09 <slack1256> *it's
09:07:12 <c_wraith> slack1256: both work
09:07:23 <benjwadams> what are some reasons I might want to use Haskell compared with Python for web applications?  I'm mostly doing read-only queries of databases and netCDF4/HDF5 files and plotting out the results
09:07:25 <slack1256> Nice
09:07:26 <c_wraith> slack1256: both have always worked, since the flag was added
09:07:28 <raek> john_doe_jr: looks like the -- was turned into an "en dash" in the instructions you copied it from...
09:07:41 <c_wraith> raek: oh, good catch
09:07:44 <crvs> so after two years I just realized the name of the package a library belongs to is in the hackage url...
09:08:11 <john_doe_jr> c_wraith: should I be using "cabal install ." 
09:08:19 <c_wraith> john_doe_jr: no
09:08:20 <john_doe_jr> raek: thanks for the catch
09:08:22 <benjwadams> I know some Haskell, but I don't really have enough experience to say that "hmmm, haskell might excel at x, y, z" other than perhaps for code correctness with the type checker
09:08:46 <c_wraith> benjwadams: in my experience, haskell excels at pretty much everything but hard realtime.
09:09:07 <c_wraith> (though people have used it successfully for hard realtime tasks with libraries like atom)
09:09:31 <crvs> c_wraith: what do you mean by hard realtime?
09:09:33 <Zemyla> Why is lazy ST something that is at all needed?
09:09:54 <c_wraith> crvs: where it is considered a critical program failure if a deadline is missed.  
09:10:01 <slack1256> Zemyla: Do build for example lazy array that serve to memoization quite nicely
09:10:08 <c_wraith> Zemyla: it's really useful for imperative algorithms that provide streams of data
09:10:11 <slack1256> *To
09:10:15 <Luke> what's the benefit or difference between -fhpc vs. configure --enable-coverage?
09:10:19 <ReinH> crvs: http://stackoverflow.com/questions/17308956/differences-between-hard-real-time-soft-real-time-and-firm-real-time
09:10:38 <Zemyla> slack1256: Yeah, but that's a difference between lazy references and lazy ST itself.
09:10:59 <benjwadams> I don't need hard realtime.  do go on about the streams of data.  many times I'm working with observation/sensor data and would be interested in streaming it rather than fetching it all at once
09:11:23 <slack1256> zemyla: oh, right. I would then argue that make the insntace to MonadFix possible
09:11:29 <benjwadams> this would be coming from a relational database or an array based file format
09:11:45 <c_wraith> Zemyla: consider something like common PRNG algorithms.  They often involve some significant amount of mutable state internally, but the results are fully deterministic (given the seed)
09:12:01 <lpaste> Fode pasted “Newrelic” at http://lpaste.net/130351
09:12:12 <c_wraith> Zemyla: lazy ST can be used to write an efficient implementation of such an algorithm that streams output
09:12:28 <Fode> Hello!
09:12:30 <crvs> thanks c_wraith and ReinH 
09:12:45 <crvs> very enlightening.
09:12:56 <c_wraith> Zemyla: in the larger case, lazy ST is useful when the result of the calculation is a lazy data structure that may be consumed incrementally or partially
09:12:56 <Jaak> Hey, is here someone familiar with the "OutsideIn(X)" and "Let should not be generalized" type checking/inference approach (one used by GHC)? I have a rather long-winded question about it.
09:13:06 <Fode> I was wondering if I might have some help figuring out what i don't understand about these aeson lenses
09:13:11 <crvs> does anyone know of any libraries in haskell to deal with large datasets
09:13:32 <ReinH> crvs: define "large"
09:13:41 <haskell606> HI all, I need some cabal help
09:13:41 <haskell606> http://lpaste.net/130352
09:13:43 <crvs> or any source material that exposes some of the concerns one should have when dealing with large samples
09:13:45 <bennofs> Jaak: if you don't get an answer here, you could try #ghc
09:13:56 <ReinH> It's better to ask questons than to ask questions about asking questions.
09:13:57 <crvs> say you want to work on sets with billions of datapoints
09:14:34 <Jaak> bennofs: cheers, I will try there if no luck here
09:15:27 <ski> Zemyla : perhaps monochrom's "lazy ST example"s in 2012-02-18,2012-05-26,2013-03-29 at <http://lpaste.net/63925> could be interesting
09:15:27 <Fode> Good point...I am having a hard time understanding what type line 28 of should be http://lpaste.net/130351
09:15:45 <glguy> haskell606: Your 'hs-source-dirs' should point to your library 'src' dir and not your tests dir. Your test dir should be referenced in a test section, generally, but not the executable section
09:15:59 <Fode> I was thinking that it should be a Vector Value
09:16:07 <haskell606> so src/ instead
09:16:31 <glguy> haskell606: and you'll list your extra modules in the 'other-modules' section
09:16:45 <haskell606> ah. so like I would put
09:16:45 * hackagebot bitwise 0.1.0.2 - fast multi-dimensional unboxed bit packed Bool arrays  http://hackage.haskell.org/package/bitwise-0.1.0.2 (ClaudeHeilandAllen)
09:16:48 <Fode> But the type checker really wants IO Value (Sorry line 25)
09:17:00 <haskell606> DBManager/SqliteDBManager.hs?
09:17:24 <haskell606> how do I do that red thing here?
09:18:14 <john_doe_jr> c_wraith: well, now I am getting the error message of "Could not find module `System.PosixCompat.Files'"
09:18:46 <hexagoxel> haskell606: also, "module SqliteDBManager .." should probably be "module DBManager.SqliteDBManager .."
09:19:27 <haskell606> okay
09:21:00 <haskell606> Cabal file now: http://lpaste.net/130353 error: Parse on other-modules failed
09:21:05 <john_doe_jr> what does cabal unpack do?
09:21:54 <haskell606> No packages requested. Nothing to do.
09:23:13 <hexagoxel> haskell606: "other-modules: DBManager.SqliteDBManager". it expects (newline-separated) haskell qualified module names, not paths.
09:23:17 <geekosaur> cabal unpack is the old name for cabal get, which retrieves a package from hackage and unpacks it into a local directory so you can inspect or modify it
09:24:19 <haskell606> Still parse error =[
09:25:59 <john_doe_jr> geekosaur: I'm getting the following error message, "Could not find module `System.PosixCompat.Files'" ..any ideas what package I need to install to build this haskel project?
09:26:36 <geekosaur> http://hayoo.fh-wedel.de/?query=System.PosixCompat.Files says http://hackage.haskell.org/package/unix-compat
09:27:19 <john_doe_jr> geekosaur: did not even know about a haskel search page
09:27:39 <geekosaur> @where hayoo
09:27:40 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
09:28:05 <geekosaur> (in general, hayoo better for search by name, hoogle for search by type)
09:28:27 <john_doe_jr> geekosaur: so "cabal install unix-compat"
09:28:33 <geekosaur> yep
09:28:48 <Fode> Nevermind figured it out, I was missing a parameter, until next time :) !  
09:29:24 <geekosaur> mm, be nice if cabal find-module were a thing, given that it has the package database...
09:29:56 <john_doe_jr> geekosaur: yup…
09:31:13 <john_doe_jr> geekosu	
09:31:34 <john_doe_jr> geekosaur: I finally got this haskel project to compile…that was difficult
09:31:43 <john_doe_jr> geekosaur: thank you
09:31:46 * hackagebot partial-handler 0.1.1 - A composable exception handler  http://hackage.haskell.org/package/partial-handler-0.1.1 (NikitaVolkov)
09:31:48 * hackagebot nested-routes 0.1.1 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-0.1.1 (athanclark)
09:31:51 <geekosaur> ideally it'd have that in its dependencies though...
09:32:13 <john_doe_jr> geekosaur: apparently the guy did not know all the dependencies 
09:32:23 <john_doe_jr> geekosaur: *or girl
09:34:23 <glguy> haskell606: other-modules takes module names, not file paths
09:34:33 <glguy> haskell606: A.B, not A/B.hs
09:35:04 <haskell606> got it. new error now.
09:35:39 <haskell606> http://lpaste.net/130354
09:36:38 <glguy> haskell606: Are you trying to have a library and tests for that library?
09:36:46 * hackagebot partial-handler 1.0.0.0 - A composable exception handler  http://hackage.haskell.org/package/partial-handler-1.0.0.0 (NikitaVolkov)
09:36:48 <haskell606> yes
09:37:50 <glguy> haskell606: Then you'll need a library section and a separate executable section. The library section will use your src/ directory and list its modules. It will need to put the modules that its exposes in exposed-modules:
09:38:17 <haskell606> ahhh. okay ill try setting it up
09:38:19 <glguy> haskell606: and then your test executable will depend on that library and use those modules. It's source files should be in a separate directory from the library src/, not inside
09:38:53 <glguy> haskell606: This is an example of a separate library and executable https://github.com/glguy/irc-core/blob/master/irc-core.cabal
09:39:37 <ryantrinkle> bennofs: merge can't be implemented *in terms* of Align, or there will be performance loss; but I do have an instance Align (Event t) :)
09:39:57 <ryantrinkle> lachenmayer: awesome; thanks! let me know if you have any questions :)
09:40:19 <haskell606> What does the other-modules mean in the library section?
09:40:55 <glguy> haskell606: That's for modules that the library uses internally, but which are not exposed to users of the library
09:41:05 <haskell606> ah
09:41:06 <meoblast001> is there a way to determine if a floating value is round.. such as Floating a => a -> Bool ?
09:42:37 <haskell606> is irc a folder in yur src?
09:43:11 <glguy> haskell606: Yeah
09:44:16 <indiagreen> meoblast001: you can check whether “snd . properFraction” is 0
09:44:30 <meoblast001> hm.. that could work. thanks
09:45:35 <haskell606> so my test directory has to live outside of the src directory
09:45:36 <haskell606> ?
09:46:04 <glguy> haskell606: Right, the library source directory is different from the executable source directory
09:47:44 <haskell606> Okay and because you exposed the library then the glirc executable should be able to see all of them?
09:48:17 <glguy> haskell606: The executable can see the exposed modules because it lists the library in its own build-depends:
09:48:36 <haskell606> is that irc-core?
09:48:47 <glguy> right
09:50:30 <haskell606> now is irc-core the name of the module in your core.hs file?
09:51:10 <glguy> haskell606: There can only be one library defined per cabal-file. The name of the library is defined by that file's name: section
09:52:49 <haskell606> The name of the library is defined by that file's name: section <-- A little confused about this part
09:53:01 <glguy> haskell606: first line of the file
09:53:37 <haskell606> ah..
09:53:51 <kadoban> haskell606: You know how if you have an executable or test-suite section you have to specify a name? The reason you don't have to specify for the library is that its name is the same as the project's name.
09:53:52 <haskell606> So in my case it would be
09:53:54 <haskell606> CH21
09:55:17 <Zemyla> meoblast001: What do you mean, is round?
09:55:59 <Zemyla> Like, is an integer?
09:56:07 <meoblast001> Zemyla: yeah
09:56:11 <meoblast001> i managed to figure it out. thanks :)
09:56:14 <meoblast001> i have to leave right now though
09:56:24 <haskell606> So it looks smeting like this? http://lpaste.net/130355
09:59:33 <Zemyla> :t \a -> a == fromInteger (trunc a)
09:59:35 <lambdabot> Not in scope: ‘trunc’
09:59:45 <Zemyla> :t \a -> a == fromInteger (floor a)
09:59:46 <lambdabot> RealFrac a => a -> Bool
10:00:37 <spdionis> hello
10:00:48 <spdionis> can someone help me understand this error?
10:00:51 <ski> @type truncate
10:00:52 <lambdabot> (Integral b, RealFrac a) => a -> b
10:00:56 <spdionis> https://www.irccloud.com/pastebin/5kfDroQJ
10:01:34 <ski> spdionis : it says "IRCCloud pastebins require JavaScript to be displayed."
10:01:47 * hackagebot inflections 0.1.0.10 - Inflections library for Haskell  http://hackage.haskell.org/package/inflections-0.1.0.10 (jsl)
10:01:57 <ski> @paste
10:01:57 <lambdabot> Haskell pastebin: http://lpaste.net/
10:02:12 <kadoban> ski: You can view the raw. Why the hell that's not the default though *shrug*
10:02:19 <spdionis> ski: http://pastebin.com/tKCpZ3Zu
10:02:28 <mauke> ಠ_ಠ
10:02:33 <Luke> anyone else getting cert issues with running `hoogle` locally?
10:02:58 <geekosaur> splitAt appears to want an Int, fromRational is...
10:03:02 <geekosaur> :t fromRational
10:03:03 <lambdabot> Fractional a => Rational -> a
10:03:21 <geekosaur> Int does not have a Fractional instance, for jhopefully obvious reasons
10:03:32 <ski> spdionis : why are you using `fromRational' there ?
10:03:46 <kadoban> > 5 `div` 2 -- spdionis
10:03:47 <lambdabot>  2
10:04:33 <spdionis> because i misunderstood (/) type
10:04:44 <spdionis> maybe, or maybe not... i am a beginner
10:05:00 <kadoban> spdionis: As I'm sure you noticed, haskell doesn't automatically convert between numeric types, so you have to be pretty careful what you're doing with them. This is good because the meaning ends up clear, but it can be hard to figure out sometimes.
10:05:01 <ski> > floor (5 / 2)
10:05:02 <spdionis> my mistake was using (/) instead of div
10:05:03 <lambdabot>  2
10:05:08 <Zemyla> Yeah, Int not allowing (/) is kind of a problem.
10:05:19 <kadoban> spdionis: Yeah, there's a separate function for integer division.
10:05:27 <ReinH> Zemyla: not really?
10:05:33 <spdionis> thank you for your help
10:05:39 <ReinH> It wouldn't make sense.
10:05:44 <kadoban> Zemyla: Not really. (/) doesn't do the same thing as `div`. Just because other languages conflate them …
10:06:15 <ReinH> (5 / 2) :: Int doesn't have a correct answer.
10:06:31 <Zemyla> Well, it is, if not a problem, a bugaboo for people familiar with other languages.
10:06:50 <kadoban> It is that, sure.
10:07:06 <ReinH> Well yes, it's a different language.
10:07:15 <ReinH> So it won't be entirely the same as other languages.
10:08:12 <kadoban> It's not that unheard of. Like in python there's / and //. Except there it'll just silently "work" if you pick the wrong one, which … sounds better, but isn't actually I don't think.
10:09:58 <schell> where can i find the documentation for the GHC API? it seems hackage documentation is a bit spotty
10:10:45 <EvanR> ocaml has two divisions too
10:10:55 <EvanR> and people familiar with other languages *should* know theres two kinds of division
10:11:03 <mauke> ocaml has two of everything
10:11:08 <Cale> schell: You mean https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc-7.10.1/index.html ?
10:11:23 <schell> Cale: yes! thank you
10:11:26 <Cale> schell: The documentation *is* a bit spotty
10:11:36 <ReinH> I wish people didn't expect Haskell to be so similar to ALGOL-family languages, but I suppose we don't help matters by calling things "return" and the like.
10:11:48 * hackagebot pooled-io 0.0.1.2 - Run jobs on a limited number of threads and support data dependencies  http://hackage.haskell.org/package/pooled-io-0.0.1.2 (HenningThielemann)
10:12:04 <mauke> did algol have "return"?
10:12:14 <Cale> schell: For more detail, you pretty much have to read the GHC source code, but there's also the GHC wiki. It's basically the GHC internals made into a library directly.
10:12:27 <ReinH> Although actual ALGOL had pattern matching and lacked braces, so perhaps I mean C-family
10:12:55 <schell> Cale: okay, thanks - I basically just need to know some differences between the 7.8 and 7.10 api's
10:12:55 <ReinH> Mainly the point is that different language families aren't always similar and we shouldn't expect them to be.
10:13:06 <Cale> That's a good point, I think ALGOL had result variables instead.
10:13:10 <schell> type signatures should be enough…i hope
10:13:47 <mauke> http://en.wikipedia.org/wiki/Man_or_boy_test
10:13:53 <seanhess> Can someone help me understand getChanContents from  Control.Concurrent.Chan? Having a list block while it waits for async results feels dirty. Is that function any different from normal laziness? 
10:13:57 <ReinH> No one expects APL or other non-Von Neumann languages to behave like Python...
10:14:25 <mauke> seanhess: yes
10:15:15 <seanhess> mauke: yes it's different from normal laziness? Is this some new kind of black magic I was previously unaware of?
10:15:33 <mauke> yeah, it's lazy IO
10:15:40 <mauke> as used by getContents
10:15:41 <ReinH> Excepting, as mentioned, Haskell. So never mind that.
10:15:58 <ReinH> At least APL makes it pretty clear that it isn't a traditional language.
10:16:14 <seanhess> mauke: crazy. ok. I guess it seemed like a new concept for some reason. I haven't done enough with Lazy IO I suppose. 
10:17:17 <ReinH> Ok, enough philosophizing, apologies.
10:17:25 <EvanR> lazy IO is weird 
10:17:37 <Cale> seanhess: It's basically enabled by unsafeInterleaveIO :: IO a -> IO a, which turns any IO action x into one which finishes instantaneously when executed and produces a magical result whose evaluation causes the execution of x.
10:17:41 <mauke> it is a truth universally acknowledged, that lazy IO is evil
10:17:54 <ReinH> mauke: is it really?
10:17:57 <seanhess> lol. ok, so I'm not crazy to think it feels dirty then :)
10:18:08 <Cale> I don't think that lazy IO is entirely evil.
10:18:27 <ReinH> Then we have at least two counter-examples.
10:18:35 <EvanR> when you eventually get around to executing the IO, which is triggered by evaluation, you may get an IO exception in pure code
10:18:44 <Cale> It's appropriate for certain tasks, and very inappropriate for others.
10:18:51 <seanhess> Cale: but see, what's weird about it in this case, is evaluating the list can't produce a result, because it hasn't been added to the channel yet
10:19:10 <Cale> seanhess: The evaluation will block until there's an element in the Chan.
10:19:15 <ReinH> It's almost as if lazy IO, like everything else, has pros and cons and should be evaluated based on those.
10:19:17 <napping> seanhess: lazy IO is definitely a bit strange, but not entirely impure
10:19:45 <napping> As far as pure computation goes, it will only ever evaluate to one particular result in a run of the program
10:19:52 <mauke> ReinH: but that evaluation may have side effects!
10:20:02 <EvanR> you could use unsafeInterleaveIO appropriately in at least the same situations you can use unsafePerformIO
10:20:05 <ReinH> mauke: :p
10:20:08 <napping> you could write a pure list that takes a long time to produce some entries
10:20:10 <seanhess> more practical question: if you were writing a function that needed to read a channel until it got some terminator, then collect all the results, would you use getChanContents or something else?
10:20:23 <Cale> seanhess: I'd just write a loop.
10:20:33 <ane> in case of T-1000 hit throwT
10:20:56 <ReinH> napping: everything in Haskell is pure, including IO... at least to the extent that anything is pure... which is that nothing is pure. Mostly because "pure" is an almost meaningless term...
10:21:25 <EvanR> philosophizing again!
10:21:43 <napping> right, but unsafePerformIO violates referential transparency, and lazy IO doesn't quite
10:21:45 <ReinH> EvanR: you caught me. :(
10:22:06 <EvanR> lazy IO might
10:22:35 <napping> Nah, see, the lazy value comes from IO
10:22:41 <EvanR> a list of random numbers generating using IO for example
10:22:48 <ReinH> Is referentially transparent.
10:23:02 <Cale> seanhess: Using getChanContents is almost like giving up your right to read the Chan in any other way. It's possible to read from the Chan elsewhere, but you probably shouldn't.
10:23:16 <ReinH> EvanR: IO [Int] is not a function. There is no referential transparency to break.
10:23:16 <EvanR> evaluating that list twice in parallel universes could give different answers
10:23:18 <napping> so formally, it makes a nondeterminstic choice of results that just happens to be consistent with the way the program evaluates and triggers side effects by forcing stuff later on ...
10:23:24 <EvanR> the list itself
10:23:36 <EvanR> not the result of unsafeInterleaveIO
10:23:38 <ReinH> referential transparency has to do with the results of functions, of which IO [Int[ is not one.
10:23:40 <Cale> (unless you want to lose some hair, and have a bunch of headache pills handy)
10:23:56 <haskell606> Can you guys take a look at this
10:23:56 <haskell606> http://lpaste.net/130356
10:24:12 <seanhess> Cale: yeah that makes sense. You have a lot more control with a loop. I think I've trained myself to resist loops from my early training (use foldl noob!). 
10:24:20 <EvanR> it has to do with expressions, so i guess since this list has no expression
10:24:33 <EvanR> its fucking weird
10:24:47 <Cale> seanhess: Well, when I say loop, I mean that you can write or make use of any sort of higher order function that's available
10:24:52 <ReinH> EvanR: referential transparency is a quality of functions.
10:25:09 <ReinH> IO [Int] is not a function, so referential transparency is not a quality of IO [Int]
10:25:11 <EvanR> you should be able to replace the expression with its evaluation
10:25:13 <seanhess> Cale: is there anything higher order for an IO loop like that? Maybe I'll post a gist
10:25:34 <ReinH> EvanR: That's not what referential transparency means.
10:25:49 <EvanR> are you talking about pure functions?
10:25:51 <Cale> seanhess: I don't think there's anything totally appropriate for this kind of thing in the base library. I'm sure there are packages on hackage which define just the sort of while loop you'd need.
10:26:00 <ReinH> EvanR: Well, the term is poorly defined, so maybe we both have valid definitions.
10:26:15 <ReinH> EvanR: Anyway, IO [Int] isn't *evaluated* to produce an [Int].
10:26:30 <ReinH> So it doesn't break referential transparency under that definition either.
10:26:35 <Cale> seanhess: and it's easy enough to write one yourself -- that's kind of the nice thing about IO actions being values, you get to invent your own control structures whenever you like.
10:26:46 <ski> (referential transparency has to do with contexts ..)
10:26:49 * hackagebot hp2pretty 0.6 - generate pretty graphs from heap profiles  http://hackage.haskell.org/package/hp2pretty-0.6 (ClaudeHeilandAllen)
10:26:51 * hackagebot slave-thread 0.1.6 - A principal solution to ghost threads and silent exceptions  http://hackage.haskell.org/package/slave-thread-0.1.6 (NikitaVolkov)
10:27:06 <EvanR> unsafeInterleaveIO gives an IO action and all IO is pure, thats fine. but im the list object itself is what i was referring to
10:27:26 <EvanR> so not directly related to RT i guess
10:27:29 <ReinH> EvanR: The iist doesn't exist during program evaluation. Only during execution.
10:27:45 <ReinH> And during execution, there will be exactly one value for that list.
10:28:02 <Cale> ReinH: You can certainly write deterministic programs using unsafeInterleaveIO such that otherwise semantically valid transformations to pure functions change the outcome of the program.
10:28:07 <EvanR> ReinH: hold on now
10:28:24 <ReinH> Cale: Well yes, with unsafe* all bets are off.
10:28:36 <napping> EvanR: the actual value the list has may depend on when you first force entries, compared to other IO stuff in the program, but it only has one value in an execution
10:28:51 <napping> Cale: that depends what you consider the specification of the unsafeInterleaveIO-using definition to be
10:29:05 <ReinH> A value of type IO [Int] is in normal form. There is nothing more to evaluate.
10:29:08 * ski . o O ( "Referential Transparency, Definiteness and Unfoldability" by Harald Søndergaard,Peter Sestoft in 1987-11-30 - 1990-01-04 at <http://www.cs.tufts.edu/~nr/cs257/archive/peter-sestoft/ref-trans.pdf> )
10:29:27 <Cale> ReinH: So the argument becomes one about whether getChanContents etc. are "safe" usages or not. I don't think getChanContents actually is, but it may be if you only ever use it once and you do not read from the Chan in any other way.
10:29:29 <EvanR> no ones disputing that part
10:29:57 <EvanR> but ok, theres only one list, theres no way to re-evaluate it to get new IO
10:30:01 <ReinH> Cale: We can try to come up with a subset of unsafe* uses that are not observably impure, but good luck...
10:30:03 <napping> Cale: I don't see why you are obliged to say that (f x == f' x) implies makeLazyIO >>= f behaves the same as mkLzyIO >>= f'
10:30:10 <seanhess> Cale: any way you would clean this loop up? https://gist.github.com/seanhess/1f9e47f60804d25b86e4
10:30:20 <napping> Function in IO are allowed to do all kinds of crazy stuff like peek at the current continuation
10:30:41 <Cale> napping: Well, are they?
10:30:47 <ReinH> Cale: This is why we like to use unsafe* when it's hidden by some API wherein the developer has made a claim about its safety and then we ignore it...
10:30:59 <napping> Or more precisely, I guess you'd need a semantics for IO before saying whether or not lazy IO should be allowed
10:31:01 <Cale> IO doesn't have first class continuations. I suppose you're allowed to read memory, but you don't have any portable way of interpreting it.
10:31:11 <ReinH> napping: Good thing there is no denotation for IO :D
10:31:12 <EvanR> napping: you just defined one ;)
10:31:21 <EvanR> allowed to do all kinds of crazy stuff
10:32:09 <ReinH> A value of type IO [Int] is a statement that anything can happen and maybe a [Int] value will be produced...
10:32:33 <napping> anyway, unsafeInterleaveIO is definitely weirder that ordinary laziness or IO, but doesn't horribly break pure code like unsafePerformIO
10:32:34 <Cale> seanhess: It might be nice to factor it into a whileJustM which executes an action (such as readChan done) until it produces Nothing, and collects elements like that.
10:32:45 <napping> isn't that unfoldM?
10:32:45 <EvanR> there are safe ways to use both
10:32:48 <ReinH> ski: Thanks for the link. Defining terms is always useful...
10:33:19 <napping> which doesn't seem to be in base, right
10:33:34 <Cale> seanhess: So then you could write  xs <- whileJustM (readChan done)
10:35:04 <Cale> napping: It would certainly be nice that if f = f', then x >>= f = x >>= f'
10:35:15 <john_doe_jr> I'm trying to build a haskel project from source following instructions found @ https://git-annex.branchable.com/install/fromsource/ and I get the following error, "cabal: unrecognized option `-j'" after entering in the command, "cabal install -j --only-dependencies" …does anyone have any idea why?
10:35:16 <ski> ReinH : also see Uday Reddy's comments on "What is referential transparency?" <http://stackoverflow.com/questions/210835/what-is-referential-transparency/9859966#9859966>
10:35:37 <seanhess> Cale: cool, I'll try that, thanks!
10:35:56 <frerich> seanhess: I think 'whileJust' from http://hackage.haskell.org/package/monad-loops-0.4.2.1/docs/src/Control-Monad-Loops.html#whileJust may be useful
10:36:02 <ReinH> ski: thanks
10:36:11 <ReinH> john_doe_jr: what version of cabal?
10:36:22 <Cale> Yeah, see, I knew there would be some package on hackage which defines exactly the loop you need :P
10:36:36 <ReinH> Cale: monad-loops is almost always that package.
10:36:39 <john_doe_jr> ReinH: cabal-install version 0.14.0 
10:36:48 <ReinH> john_doe_jr: That is a very old version of cabal. How did you install it?
10:37:01 <napping> Cale: and threads are already enough you can't generally
10:37:05 <napping> expect that
10:37:09 <john_doe_jr> ReinH: its running on an old Ubuntu 12.04.4 LTS
10:37:29 <ReinH> john_doe_jr: so via apt-get? Unfortunately, the apt packages for ghc are severely out of date.
10:37:31 <john_doe_jr> ReinH: how do I update my cabal version then?
10:37:33 <Cale> napping: Are you sure?
10:37:42 <ReinH> john_doe_jr: what version of GHC?
10:37:59 <napping> don't even need that, really - do x <- getTimeOfDay; (evaluate (return () >>= f)); y -> getTimeOfDay; return (y-x)
10:38:08 <Cale> napping: If we're assuming some sort of nondeterministic semantics for what actions do, then I think under most reasonable circumstances, the set of possible outcomes should be the same.
10:38:12 <john_doe_jr> ReinH: The Glorious Glasgow Haskell Compilation System, version 7.4.1
10:38:25 <napping> already behaves differently if you change f in ways that never change the result value for any input value
10:38:32 <ReinH> john_doe_jr: Yeah, that's a few years old.
10:38:45 <Cale> napping: The set of possible results is the same.
10:38:54 <john_doe_jr> ReinH: well, I can't upgrade my distro due to some limitations here
10:39:00 <ReinH> john_doe_jr: I wouldn't expect many things to install properly on GHC 7.4.1. I'd recommend using these installation procedures https://github.com/bitemyapp/learnhaskell#ubuntu
10:39:28 <michaelt> john_doe_jr: I wonder if you can get https://www.haskell.org/ghc/download_ghc_7_10_1#x86linux on. It's pretty simple to install.  Or anyway the corresponding distribution for ghc-7.8
10:39:30 <Cale> napping: At least, given some reasonable semantics which nobody's bothered starting to write down.
10:39:38 <ReinH> john_doe_jr: even up-to-date distro package managers usually have old versions of ghc :/
10:39:57 <ReinH> michaelt: I wouldn't recommend 7.10 for actually-installable-packages yet either...
10:40:09 <napping> Cale: if you go with that kind of "possible results", you can probably say that getChanContents also give you the same set of possible results
10:40:25 <michaelt> ReinH: yeah I'm using it but immediately regretting linking it
10:40:26 <Cale> napping: Actually, I think there might be a start on the operational nondeterministic semantics of concurrent Haskell somewhere...
10:41:09 <ReinH> Cale: that would be interesting to see
10:41:19 <ReinH> I wonder which formalism is used
10:41:26 <napping> In particular, imprecise exceptions makes the orders in which bits of the arguments may be forced part of the "pure" semantics of a function
10:41:50 <michaelt> john_doe_jr: you could try 'cabal install cabal-install' to get a new version, but I think ghc-7.4 won't be able to build it. 
10:42:06 <ReinH> michaelt: ghc 7.4.1 is hopeless, best upgrade it
10:42:22 <ReinH> I don't know of anyone who still checks their packages for 7.4 compatibility
10:42:24 <michaelt> ReinH: okay okay okay
10:42:27 <Cale> napping: Yeah, catching exceptions thrown by evaluation is evil.
10:42:54 <michaelt> ReinH: I was more articulating some of the considerations at issue.
10:42:56 <napping> I'm not talking about catching, just a semantics that makes it observable which error calls might be hit
10:42:57 <seanhess> frerich: Cale: yeah monad-loops was great: `whileJust (readChan done) return`
10:43:01 <ReinH> michaelt: fair enough
10:43:23 <ReinH> michaelt: although "you could try this but it won't work" isn't great advice... ;)
10:43:44 <ReinH> seanhess: :)
10:43:56 <michaelt> ReinH: it was self-cancelling advice, really information about how version interact; but it doesn't matter. 
10:43:58 <ReinH> It's a very handy package.
10:44:01 <ReinH> michaelt: :)
10:44:17 <hexagoxel> i think cabal-install-1.22.2.0 works with ghc-7.4.2
10:44:38 <Cale> napping: In a single thread, we could write a bunch of elements to some c :: Chan (), and then do xs <- getChanContents c; ys <- getChanContents c; f xs ys, and the order in which f matches on xs and ys operationally will then determine how many elements end up in each list.
10:44:56 <tahmid> hey, all. trying to make a simple function i can map over that will print and return a result. it works on single values, but map is yelling. i'm just trying to see how lazy Haskell is. with a take n $ map ...
10:45:01 <michaelt> I think they worry a bit about old version, but ReinH is right that hackage-in-general doesn't 
10:45:02 <ReinH> hexagoxel: Cool, maybe they'll be able to upgrade cabal and get stuck later on instead. ;)
10:45:21 <Cale> napping: While the nondeterministic semantics of a program which doesn't fork would probably otherwise be able to offer a unique outcome.
10:45:23 <michaelt> I'm worried we've alarmed the good john_doe_jr 
10:45:26 <hexagoxel> ReinH: :p true
10:45:39 <ReinH> michaelt: Which is why I just said "you should update ghc" :)
10:45:52 <napping> Cale: right, and just with the pure results on partial inputs you usually often almost tell what order it peeks at the entries in, and if your pure semantics lets you use distinct error calls or something you can precisely tell what order it forces stuff in
10:45:53 <john_doe_jr> michaelpj: not alarm…just learning haskell
10:45:57 <kadoban> tahmid: More info? Not sure what is going wrong with what you tried, or … what you tried.
10:46:09 <ReinH> john_doe_jr: distro package managers are unfortunate. :/
10:46:09 <napping> Cale: and then you can define your IO semantics of getChanContents only in terms of that forcing in pure code
10:46:13 <michaelt> ReinH: yeah, that's what I thought might be most alarming; even more alarming is that it's true.
10:46:17 <napping> It won't be a very nice or compositional semantics, I suppose
10:46:20 <ane> if i want to create a merge operation for a record type, does it make sense to provide a Monoid instance for it?
10:46:50 * hackagebot hmatrix-csv 0.1.0.2 - CSV encoding and decoding for hmatrix.  http://hackage.haskell.org/package/hmatrix-csv-0.1.0.2 (lyzrd)
10:46:51 <ane> by making mempty return a record with default values and then mappend to provide the merging?
10:46:58 <tahmid> example code: http://pastebin.com/eHEeMEvz
10:47:06 <tahmid> kadoban: thanks.
10:47:25 <napping> ane: if that default record is actually an identity for the  merge and the merge is associative, then sure
10:47:29 <michaelt> john_doe_jr: there is an absurd level of avant gardism compared to many languages. It's not that hard to figure out how things can go wrong to due to time lags etc., though; I mean I can do it ...
10:47:54 <Cale> napping: and what's worse is that f xs ys might just be return (g xs ys), and g might be something provided by someone else who doesn't even know that any of this is going on :)
10:48:17 <indiagreen> ane: if your merge is biased (so that “def <> record” isn't the same as “record <> def”), then you should make it a Semigroup instead
10:48:58 <indiagreen> (where “def” is your default value for the record)
10:49:08 <Cale> napping: Obviously we're in a bit of a contrived setting, but you'd hope not to have people always worrying about whether their pure functions are matching on stuff in some sort of ideal order with effects considered...
10:49:09 <michaelt> tahmid: oh, are you thinking you should just be able to do 'take 2 $ map printSquare [1..5]
10:49:09 <bennofs> indiagreen: def = mempty? :)
10:49:12 <napping> Cale: yes, lazy IO certainly makes the observable IO behavior hrader to understand.
10:49:15 <kadoban> tahmid: Hmm, that won't really work that well I bet. What you should do instead is separate it. Make a function to produce the list of numbers you want, and then make (or use) another to print it
10:49:16 <ane> as far as i can tell they're non-biased... the default values are all zeroes and similar values
10:49:38 <napping> Cale: The distinction I'm considering is that it still can't break code that depends on referential transparency to maintain invariants
10:49:38 <tahmid> michaelt: yes. i just want to know if it performs all of the calculations, which i think it does, or if it knows to only do 2
10:49:39 <Cale> napping: Lazy IO complicates reasoning about changes to otherwise pure functions.
10:50:03 <kadoban> tahmid: Start with the map part, IMO. Make a function :: [Int] -> [Int] that squares every number in the list.
10:50:20 <tahmid> kadoban: that i can do
10:50:21 <michaelt> tahmid: it will perform only two when you find out how to make it happen.  map printSqare is a list of actions-that-return-a-number
10:50:31 <napping> like, it's plausible for f x = if x () then <result1> else if x () then <illegal object> else <result1> to return <illegal object> on an argument constructed with unsafePerformIO
10:50:36 <Cale> napping: As soon as you're using this stuff, you sort of do have to worry about the operational semantics of all the pure functions which the data obtained by lazy IO is going to be shoved through.
10:51:07 <tahmid> kadoban: map (\x -> x * x) [1..5]
10:51:11 <michaelt> kadoban: but doesn't tahmid want to print the old number are return the squared number .
10:51:13 <ane> indiagreen: what are the benefits given by this abstraction? i can now merge a list of them with mconcat?
10:51:24 <tahmid> kadoban: but that gives me the whole list. if I take, i can't see if that whole list is made or not.
10:51:45 <Cale> napping: but not with unsafeInterleaveIO
10:51:47 <michaelt> > map (\x -> (x,x*x)) [1..5]
10:51:49 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25)]
10:51:58 <indiagreen> ane: to be honest, whenever I do it it's to get the <> operator
10:51:59 <tahmid> michaelt, kadoban: the printing isn't necessary. it's just so see if the whole list is being made or not.
10:52:11 <Cale> napping: But there are still issues of roughly that sort with unsafeInterleaveIO and multiple variables.
10:52:13 <kadoban> michaelt: I ignored his attempt because it seems doomed, so I thought I'd point him towards what seems more idiomatic to me. If you can find a way to save his original, sure.
10:52:21 <michaelt> > take 2 $ map (\x -> x*x) [1..]
10:52:23 <tahmid> ...with the take after the map
10:52:24 <lambdabot>  [1,4]
10:52:37 <napping> Yeah, that's a good way to put it -using Lazy IO makes your IO behavior depend on operational semantics of pure code, but can't invalidate otherwise safe reasoning about pure code
10:52:41 <michaelt> tahmid: ^^^ it didnt calculate all the integers from 1
10:52:58 <tahmid> michaelt: yeah, i know that, but i can't see if it's mapping over the whole collection or not that way.
10:53:04 <michaelt> > take 2 [1,2,3, error "we never get here"]
10:53:06 <lambdabot>  [1,2]
10:53:29 <kadoban> tahmid: [1..] is infinite. It would never finish if it was mapping over the whole thing.
10:53:30 <tahmid> michaelt: but how can i be sure? 
10:53:41 <michaelt> > take 2 [1, error "we never get here"]
10:53:43 <lambdabot>  [1,*Exception: we never get here
10:53:54 <michaelt> that got to the error, the other one didn't.
10:54:03 <Cale> tahmid: Any program which evaluates a call to error stops immediately with an exception which is visible.
10:54:05 <tahmid> kadoban: perfect.
10:54:11 <michaelt> @src take 
10:54:11 <lambdabot> Source not found. My brain just exploded
10:54:16 <napping> Cale: even with multiple variables, a pure function that works "correctly" with any input will continue to do so with lazy IO involved, but you may have to worry about hanging up the program dependeing what IO you are being lazy about
10:54:55 <tahmid> michaelt: so it seems like a chain of ho functions produces the a 'recipe' in a way. yes?
10:55:12 <indiagreen> ...wait, that's weird
10:55:15 <indiagreen> @src take
10:55:15 <lambdabot> take n _      | n <= 0 = []
10:55:15 <lambdabot> take _ []              = []
10:55:15 <lambdabot> take n (x:xs)          = x : take (n-1) xs
10:55:26 <Cale> napping: Well, the trouble is that the meaning of your overall program (which includes the lazy I/O) might be affected by otherwise valid refactorings of pure functions justified by denotational semantics.
10:55:34 <indiagreen> okay, why didn't it work the first tim— ah, probably because of the space
10:55:54 <Cale> napping: Because you might accidentally affect the operational behaviour of those functions, which you don't ordinarily care too much about.
10:56:21 <michaelt> tahmid: I guess thats a way of putting it.  [1..5] might be thought of as a 'producer' and the composition of functions as a 'consumer'. Only as much is produced as the consumer demands, in this semi-utopian economy.
10:56:50 * hackagebot io-streams 1.2.1.3 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.2.1.3 (GregoryCollins)
10:57:45 <Cale> napping: So with lazy I/O present, you absolutely can do things which denotationally seem fine but which turn correct programs into incorrect ones. You might also just be the author of a library which is entirely pure, and your users who are using lazy I/O might hate you for adjusting the operational behaviour of your functions (but I think we can blame them instead of you anyway)
10:57:51 <napping> Cale: I think it's pretty rare to affect the operational behavior without also affecting the results on partial values, but often you don't care about that either
10:58:03 <EvanR> id like to see a listing of the "good" (and correctly described) properties of programs involving lazy IO, because emphasizing some corner cases where it has no observable effect might lead people to actually use it for things that are not good
10:58:38 <michaelt> funny, i just sent a patch to io-streams ...
10:59:03 <napping> EvanR: I'm not sure it extends to "good". Maybe just using interact?
10:59:33 <Cale> The *nice* thing about lazy I/O is that a lot of the time it really *doesn't* have any observable problems in the face of denotationally correct transformations, and everything is actually just fine.
11:00:02 <Cale> Its main problems have to do with resource management, which is actually kind of a different issue from what we've been talking about again.
11:00:42 <Cale> (and I suppose handling of exceptional cases, but that could be solved, it's just we're using too many lists instead of something list-like but with more nils)
11:00:53 <napping> I'm not sure when it doesn't have observable problems in sufficiently perverse contexts
11:01:18 <napping> like, if some other process is doing stuff based on monitoring reads to some file or whatever
11:01:37 <napping> well, maybe not "problems", but at least weirdness
11:01:47 <Cale> Yeah, I'm just putting the counterpoint on the table that for many simple programs, it can be entirely fine, and save you from a lot of obnoxious hassle and/or heavy-weight machinery.
11:01:57 <napping> in the "exposing otherwise internal-behavior of pure functions" sense
11:02:09 <EvanR> if using strict IO would have caused an IO error at some point, then using the lazy value will delay the error to perhaps after another error
11:02:19 <statusfa1led> When I see something like the following, what exactly is it? "Main.hs: <stdin>: hGetLine: end of file"
11:02:36 <napping> statusfa1led: looks like an exception
11:02:46 <statusfa1led> napping: right. is that part of the IO monad? it's not part of hGetLine's type
11:03:01 <napping> yeah, IO includes exception handling stuff
11:03:11 <statusfa1led> is there a way to catch it? and is it the same kind of exception as when I call "error" ?
11:03:13 <napping> see Control.Exception.
11:03:22 <statusfa1led> ok first question answered :p
11:03:26 <napping> It's the same exception system in the end, but a different type
11:03:40 <statusfa1led> napping: could you clarify that?
11:03:42 <napping> ErrorCall and IOException, I think
11:03:44 <Cale> statusfa1led: It's *sort of* the same kind of exception as when you call error, but I highly recommend never trying to catch exceptions that have been thrown by error.
11:04:09 <Cale> statusfa1led: The point being that error throws exceptions *during evaluation* rather than during the execution of an IO action.
11:04:36 <Cale> and getting those to line up correctly is only something to be done as a last ditch effort when dealing with poorly designed upstream libraries
11:04:49 <statusfailed> Cale: getting them to "line up"? Could you clarify that?
11:04:57 <EvanR> IO exceptions can also be thrown by evaluating the result of the result of unsafeInterleaveIO ;)
11:05:26 <EvanR> no error
11:05:40 <statusfailed> I can see why catching "error" is morally bad- total functions are nice, etc., but I can't see why it would have practical issues?
11:05:41 <napping> statusfailed: for one thing, with laziness it's pretty easy to not evaluate far enough to hit the error call before you return the value outside the scope of your exception handler
11:05:44 <Cale> statusfailed: You're aware of how running a Haskell program consists of execution (carrying out the steps described by IO actions), and evaluation (converting expressions into values for the purposes of pattern matching), and these two things are separate, yeah?
11:05:52 <statusfailed> Cale: yep
11:05:56 <Cale> statusfailed: So...
11:05:58 <Cale> :t catch
11:06:00 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
11:06:20 <ski> Cale,napping : my preferred understanding of `unsafeInterleaveIO' is treating it as akin to concurrency
11:06:39 <napping> statusfailed: It's not entirely inconceivable that catching an exception thrown from pure code might sometimes be a sensible design, but if so you should at least make and use a specific exception type of your own, rather than trying to cram data into error's string
11:06:46 <Cale> This *executes* the action it's given, using the provided function to handle an exception of an appropriate type if that exception fires during that execution.
11:06:51 * hackagebot pooled-io 0.0.2 - Run jobs on a limited number of threads and support data dependencies  http://hackage.haskell.org/package/pooled-io-0.0.2 (HenningThielemann)
11:06:53 * hackagebot stitch 0.1.0.0 - lightweight CSS DSL  http://hackage.haskell.org/package/stitch-0.1.0.0 (Intolerable)
11:07:15 <Cale> statusfailed: But the IO action may, for instance, return an unevaluated expression with a call to error inside it, which will not be caught.
11:07:26 <napping> statusfailed: anyway, error and pure exceptions and stuff is all pretty far from your IO exception there
11:07:27 <ski> iow, the code should expect that the `action' may be performed at *any* point after the execution of `unsafeInterleaveIO action'
11:07:38 <statusfailed> Cale: hm, could you give a concrete example of a type "Exception e"? Would that be "String" in the expression 'error "foo"' ?
11:07:45 <napping> just using try or whatever around the call will work just fine, if you want to catch that eof
11:07:47 <Cale> statusfailed: Or, what's a little more rare, the evaluation of the IO action itself may be an exception, and it may occur earlier than the catch trying to execute it.
11:08:06 <napping> statusfailed: there's a nice list in the docs for Control.Exception
11:08:34 <Cale> statusfailed: In that case, the exception type is ErrorCall
11:08:39 <napping> The instance related to error is on the newtype ErrorCall = ErrorCall String
11:08:52 <statusfailed> right
11:09:02 <statusfailed> actually I totally forgot how typeclasses worked for a moment :|
11:09:08 <statusfailed> nevermind
11:09:08 <statusfailed> heh
11:09:25 <Cale> It's very easy to make new instances of Exception, you can just add  deriving (Typeable) to your data declaration, and then write  instance Exception MyType
11:09:34 <statusfailed> so "catch" will catch any exception that is thrown, and you can deal with them via the "Exception" typeclass
11:09:54 <Cale> Yeah, or more likely through operations which use the Exception typeclass
11:10:03 <statusfailed> right
11:10:22 <napping> Control.Exception.catch catches the specific type e
11:10:38 <ski> Cale : did you mention any example of "with lazy I/O present, you absolutely can do things [...] which turn correct programs into incorrect ones" ?
11:10:59 <Cale> By implementing the operations in the Exception type class in clever ways, you can define new types which effectively represent the union of an arbitrary set of exception types, or any computable subset of an exception type.
11:11:20 <Cale> ski: I sort of kind of did, but it was very contrived.
11:11:40 <Cale> ski: My example involved using getChanContents twice on the same Chan.
11:12:10 <Cale> ski: and then passing the resulting lists to a pure function
11:12:11 <ski> yes, i consider that wrong anyway (should raise an exception)
11:12:19 <statusfailed> napping: oh whoops, I did have it right the first time then
11:12:28 <statusfailed> napping: of course, you have to say which "e" you want to catch
11:12:51 <statusfailed> napping: so I use "SomeException" if I want to catch everything
11:12:52 <napping> It's set up so you can catch SomeException if you really want to catch every kind of exception, but usually you can just be more specific
11:13:46 <Cale> I'm glad that all the IOExceptions have been split up nicely
11:13:49 <statusfailed> napping: that's a bit unsatisfying- it's nice to be forced to deal with errors using things like Either. It feels like the exception system is a bit error prone?
11:13:52 <Cale> That seems new
11:14:02 <Cale> :t try
11:14:04 <lambdabot> Exception e => IO a -> IO (Either e a)
11:14:10 <statusfailed> ha :-)
11:14:11 <Cale> statusfailed: When used appropriately it's not.
11:14:14 * ski isn't sure it's a good idea for `SomeException' to be able to catch any exception
11:14:44 <statusfailed> Cale: This might be a big ask, do you know of any examples of how to "do it right"?
11:14:50 <EvanR> statusfailed: exceptions are good especially for IO stuff
11:15:01 <statusfailed> I'm happy to just read code
11:15:05 <Cale> statusfailed: From whose perspective?
11:15:08 <statusfailed> Cale: yours :-)
11:15:16 <Cale> statusfailed: The guy throwing exceptions, or the guy catching them?
11:15:19 <EvanR> whether EOF is a good use case for exceptions i dont know but theres plenty of good use cases
11:15:21 <statusfailed> ah
11:15:33 <napping> statusfailed: you can get pretty far just using this stuff to catch IO exceptions
11:15:50 <statusfailed> napping: "this stuff" == try, catch, etc?
11:15:54 <napping> Yeah
11:15:55 <Cale> statusfailed: If you're throwing exceptions or providing information about errors, whether to use IO exceptions really comes down to a consideration for how you expect your users to want to deal with them.
11:16:00 <napping> Or the whole exception system in general
11:16:12 <ski> EvanR : good
11:16:22 <statusfailed> napping: right
11:16:23 <napping> If you're writing the code that returns errors, it's probably pretty reasonable to return problems with Either or whatever
11:16:28 <EvanR> ski: EOF?
11:16:32 <ski> yes
11:16:44 <Cale> statusfailed: If you think you'll have a lot of users who'll just want to drop everything on the floor when the exception happens, or else to defer the handling of a bunch of exceptions until farther up in their program, then use IO exceptions.
11:17:07 <ski> (whether it's a good idea to not have the possible exceptions visible in the interface is another question)
11:17:09 <EvanR> thats an important aspect of file descriptor semantics
11:17:09 <Cale> statusfailed: If you expect it'd be better for the exceptional cases to be handled immediately, produce Either or Maybe as appropriate.
11:17:14 <napping> Also, as mentioned throwing exceptions from pure code is generally a pretty bad idea, or at least annoying for users to deal with
11:17:26 <statusfailed> napping: sure, on board with that :D
11:17:45 <statusfailed> Cale: to be honest I always just return Either/Maybe in my code, mainly because I wasn't that familiar with the exception system
11:17:50 <EvanR> not very exceptional
11:17:52 <Cale> Note that Either SomeException a is a thing which is theoretically possible to use reasonably. :D
11:18:03 <Cale> But I've never seen it in the wild.
11:18:15 <Cale> (Well, as the result of an IO action anyway)
11:18:21 <statusfailed> Cale: "theoretically possible" sounds like "practically unadvisable"? :-)
11:18:23 <napping> statusfailed: If you do that, it's easy enough for your users to turn that into an exception if they would prefer
11:18:54 <napping> either (throw . mkMyExpcetion) return :: Either <mkExceptionArg> a -> IO a
11:19:05 <Cale> statusfailed: I don't even know if it's practically unadvisable. The Exception type class gives you a really nice extensible hierarchy of exception types.
11:19:19 <Cale> It's just that usually something marginally better is available
11:19:39 <ronh> should I expect some things to break when switching from 32 to 64 bit builds on linux? how about on windows?
11:19:41 <Cale> It's a little sad, because it's a well-designed library imo, but that's the way things are, I guess. :)
11:19:55 <napping> ronh: besides if you depend on C libraries, probably not
11:20:04 <statusfailed> Cale: I think my concern is that it seems like the set of possible exceptions is hidden 
11:20:05 <Cale> We tend to have a culture of being very cautious about handling exceptional conditions in Haskell.
11:20:15 <Cale> Yes, that's true.
11:20:26 <napping> ronh: I think Int changes size
11:20:30 <Cale> It's explicitly not part of the type, unless you make it one, using Either.
11:20:41 <statusfailed> right
11:20:49 <napping> statusfailed: checked exceptions haven't worked out too well so far
11:20:56 <Cale> and we like types to be fairly precise in Haskell, usually
11:21:11 <napping> maybe the reasearch into effect systems and stuff will turn up something
11:21:12 <Cale> But the whole point of types is to be a little bit imprecise.
11:21:38 <EvanR> the total number of exceptions that can be thrown is huge, you would have a hard time listing them all in a useful way. of course most of the time they never happen. and thats not even considering async exceptions
11:21:59 <napping> and polymorphism over exception sets for higher-order code, yeah
11:22:14 <napping> you could certainly experiment with trying to define your own monad that did track effects
11:22:19 <Cale> Yeah, that's also a good point. IO exceptions are good for things which almost never happen, and when they do, you usually don't have a reasonable way of coping.
11:22:35 <EvanR> yeah IO exceptions in particular
11:22:38 <KorriX> Hi! Is there any Word8 based IO library?
11:22:43 <statusfailed> EvanR: Would a tagged union of possible exceptions not suffice?
11:23:01 <Cale> KorriX: Not totally sure what you mean by that, but perhaps ByteString is what you're looking for?
11:23:10 <EvanR> it would be inconvenient to always be dealing with things that almost never happen but you cant deal with anyway
11:23:11 <statusfailed> EvanR: or is your point that IO is so fraught with peril that that approach quickly becomes horribly verbose?
11:23:12 <refried_> what's a good example of the kind of business rule you'd need a haskell-like type system to enforce?
11:23:14 <cfoch> does someone know what does that function filterOut do? 
11:23:15 <napping> KorriX: I'm not sure how fancy of a "library" you wnat
11:23:18 <cfoch> here ---> https://github.com/ghc/ghc/blob/master/ghc/InteractiveUI.hs#L1148
11:23:28 <refried_> or multiple examples, for my arsenal :)
11:23:34 <EvanR> see most C code and its error handling strategy
11:23:37 <statusfailed> "fraught with peril"- closing file descriptors, threads being killed, etc. etc.
11:23:51 <EvanR> statusfailed: all of that stuff is handled for you usually
11:23:55 <Cale> statusfailed: Yeah, the problem is just that there's a lot of stuff which could reasonably go into the types of I/O performing things
11:24:06 <ggVGc> Cale: what do you mean by not having a reasonable way of coping? If for example a file is unable to be opened, or an input stream is abruptly closed, the program should easily be able to cope with that by giving an error message and asking to retry with a different file or something?
11:24:13 <Cale> statusfailed: If you have a dependently typed language like Idris, you can go really crazy with this :D
11:24:20 <ronh> the least a program can do when facing an IO error is to provide "try again" functionality. it could be something as simple and fixable as no free space
11:24:24 <KorriX> Cale, napping: I'm seeking for hLookAhead equivalent, but returning Word8 instead of Char
11:24:47 <EvanR> ronh: no free memory? thats simple and fixable?
11:24:47 <statusfailed> Cale: I can imagine :D
11:25:02 <Cale> ggVGc: Yeah, sometimes. It can be reasonable for many programs just to complain with the default exception message that the file doesn't exist or whatever.
11:25:15 <ronh> EvanR sure. let the user free it before pressing "try again"
11:25:31 <statusfailed> So final question: I want to write a network client that stays alive: my current best idea is that I write an "inner catch", which handles common failures scenarios, and an "outer catch" which handles any exception, and just restarts the program if something goes wrong
11:25:32 <EvanR> ggVGc: most of the time when this happens its "impossible" and you need to fix your code, in my experience
11:25:35 <statusfailed> does that sound reasonable?
11:25:39 <Cale> ggVGc: But in a GUI application, you might want to catch the exception and prompt the user for a different file instead.
11:26:12 <Cale> EvanR: Well, no, ggVGc is talking about IO exceptions which really do happen with correct code
11:26:16 <EvanR> ronh: having designed systems where "you" explicitly are inserted into a role of fixing system problems when they appear, i can tell you that is a horrible idea
11:26:33 <EvanR> Cale: ah
11:26:34 <Cale> EvanR: Your program's user might have just supplied an incorrect filename, for instance.
11:26:41 <ggVGc> statusfailed: if I were you I would write the core handler as a haskell program, and then write an erlang wrapper that uses the haskell program to do the work. Because the "restart when errors occur" idea you proposed is exactly the core of erlang's design
11:26:43 <EvanR> yeah thats different
11:26:44 <Cale> EvanR: or maybe a network connection died
11:26:54 <napping> KorriX: I think the lookhead and stuff is specifically handled by Handle. Maybe you want to look at hSetEncoding and related options?
11:27:03 * frerich wonders what Cale meant when he wrote 'the whole point of types is to be a little bit imprecise.' but doesn't want to hijack the discussion. :-)
11:27:07 <statusfailed> Cale: adding a whole erlang runtime sounds a bit overkill? :-)
11:27:08 <Cale> It *can* be reasonable for a CLI app to just die with an exception message if the network dies.
11:27:11 <statusfailed> frerich: (I too wonder that)
11:27:18 <EvanR> ggVGc: when your code is broken though, restart when an error occurs is bad (unless you are explicitly there to always manually fix problems)
11:27:40 <ronh> EvanR what is the alternative? crashing with an error, without giving user a chance to fix the problem (free disk space, close some programs) before trying again?
11:27:51 <KorriX> napping: Thanks :) You solved my problem
11:28:21 <EvanR> ronh: in a hopefully autonomous system, it might not be so simple to "simply get more space"
11:28:25 <Cale> Well, I mean that types help us check that programs are correct to varying extents based on our tastes, but don't necessarily specify absolutely everything about the behaviour of the program.
11:28:31 <napping> ggVGc: I would instead say that in your example you have at least a complicated enough system that you can give up on one operation and have the rest of the program, and I think you need a certain level of complexity before exceptions start being nice
11:28:33 <Cale> When they do, then the terms become redundant.
11:28:39 <EvanR> ronh: the linux kernel for example does this for you, it kills the program that is misbehaving the most with memory
11:28:48 <EvanR> ronh: it knows better than you, faster than you what to kill
11:28:56 <ronh> EvanR autonomous system wasn't mentioned until now
11:29:04 <Cale> Why write the program at all, if you can write the type in such a way that there's only one program of that type? :)
11:29:14 <napping> ggVGc: That should be "give up on one operation and have the rest of the program continue"
11:29:14 <EvanR> ronh: well GUI apps were just mentioned, and i wasnt thinking of that so
11:29:21 <statusfailed> ggVGc: oops, that message to cale was for you :-)
11:29:25 <Cale> We *ought* to be able to do that, and it's a little bit upsetting that we can't yet.
11:29:50 <Cale> Once we're all programming in dependently typed languages, we'll be a lot closer to that.
11:29:50 <ggVGc> statusfailed: well, that might be true(regarding adding erlang). Just saying that is exactly the type of thing that erlang was created for
11:29:53 <EvanR> ronh: in many ways on this topic GUI apps simplify a hell of a lot of these questions
11:30:06 <Cale> But even in a dependently typed language, I don't think it's always the best possible idea to put everything in your types.
11:30:08 <ggVGc> statusfailed: it gives you all the monitoring and restarting of crashed processes for free
11:30:13 <statusfailed> ggVGc: ah :) point well made then, at least from what i've heard!
11:30:14 <EvanR> theres a user sitting there ready to deal with whatever
11:30:37 <Cale> The point of dependently typed languages is just to expand the space of properties which can be expressed there.
11:30:38 <ronh> yup. also "out of memory" error could be simply because the user made a mistake. such as trying to open 40GB iso file instead of 4MB image
11:30:39 <statusfailed> ggVGc: oh, I didn't know it had free monitoring
11:30:48 <Cale> Not necessarily to require us to do so
11:31:06 <Cale> Which things you want to check at compile time is up to you :)
11:31:08 <EvanR> ronh: well you dont really want to write code over again every time to deal with something like that, and many things similar to it
11:31:15 <ggVGc> statusfailed: well, it's a core part of erlang to let parts of the system crash, and have it automatically restarted etc. I.e "let errors happen", but also making sure it is logged when it happens.
11:31:31 <EvanR> ronh: especially when that mistake would lock up the entire system unless the kernel helped you out
11:31:39 <statusfailed> ggVGc: I may actually look into using erlang for this :p
11:31:45 <ggVGc> statusfailed: I don't have that much in depth knowledge of erlang actually(I just read about it quite a lot), but what you described is exactly the scenario where I would attempt using it
11:32:00 <statusfailed> ggVGc: don't 'spose you have a favourite tutorial/reference ?
11:32:06 <EvanR> ronh: out of memory is seriously not a simple problem to just fix
11:32:20 <EvanR> especially in user space
11:32:41 <ggVGc> statusfailed: no unfortunately, I haven't actually managed to find the project for myself where I can argue using erlang, since I don't do much backend/service stuff currently
11:33:04 <Cale> frerich: anyway, does that clarify things?
11:33:12 <EvanR> we like to write programs assuming you have infinite memory, the effect of which is to not function at all once that isnt true
11:33:21 <EvanR> at least in haskell
11:33:47 <frerich> Cale: Hmm, a language with dependent types may be 'a lot closer', but is it really upsetting that we cannot do that yet - because even with dependent types you will still want to do IO, and IO can fail in wonderous ways so you'll need to do error handling -- which can be missing or incorrect.
11:34:21 <EvanR> frerich: you can encode the possible errors (quite finite in C world) into the types
11:34:34 <EvanR> including signals
11:35:15 <frerich> EvanR: Even if you can express that something can fail (assuming that the things which can go wrong can be counted in the first place), you'll still have to handle the error somehow, no?
11:35:24 <frerich> And that handling may be inappropriate,  I guess?
11:35:25 <Cale> Types are machine checked properties of programs for which the program itself can be used as a proof. Even if you're totally concerned with correctness, you don't necessarily even want to put all the correctness of your program into the form where the program itself is its own proof of correctness. You might want to separate some properties out.
11:35:41 <EvanR> frerich: the possible ways to handle certain errors could also be encoded in the types
11:36:30 <EvanR> at some point correctness has to get subjective right
11:36:42 <frerich> Cale: but yeah, thanks for clarifying. It reminds me a bit of approximating a circle with polygons: dependently typed languages let you approximate the circle more closely because there's less "variance" in the lines.
11:36:50 <frerich> Cale: (I hope that made some sense...)
11:36:52 * hackagebot tslogger 0.1.0.0 - Thread-safe logging.  http://hackage.haskell.org/package/tslogger-0.1.0.0 (peter_fogg)
11:36:58 <Cale> and sometimes, you really don't have the time for that level of precision, and just want to write a one-off hack to get something done, you're reasonably confident that you can do it right without too much help from the compiler, and you don't want to have to convince the compiler with some kind of proof of correctness.
11:37:17 <ggVGc> Cale: and that's when you use javascript!
11:38:27 <Cale> Nevermind that you might not even completely know what it should mean for your program to be correct
11:38:49 <Cale> and that you can get the specification wrong too :)
11:39:00 <EvanR> but trying to figure that out might help you realize youre headed for disaster
11:39:07 <Cale> Yeah, for sure
11:39:50 <EvanR> or get you in trouble with "normal programmers just trying to get stuff done" ;)
11:39:50 <Cale> But you don't necessarily want the type of the program which prints "Hello, World!" to express that the program prints "Hello, World!" and does nothing else.
11:40:05 <EvanR> why not!
11:40:13 <Cale> Because that is redundant.
11:40:17 <karshan> Hey, so what happens when two packages use the same module names. can you depend on both packages ? (e.g. zlib and zlib-pure)
11:40:21 <EvanR> yeah drop the program part ;)
11:40:37 <Cale> EvanR: Well, types ought to be values too.
11:40:44 <Cale> (perhaps!)
11:40:58 <EvanR> makes sense to me
11:41:03 <Cale> They aren't yet in Haskell, but we're inching along in that direction.
11:42:55 <Cale> karshan: You can... but it's kind of awful. There's a provisional syntax which was put in place to let you specify the package you want when importing a module, but I don't think the GHC devs intended it for anything other than transitional use when there was a major version bump on the base package at one point. I think it still works though.
11:43:16 <Cale> karshan: Do you really need to depend on both at the same time in the same program?
11:43:55 <karshan> Cale: I don't actually I'm using IHaskell so I don't have a cabal file :/
11:44:26 <karshan> Cale: but this syntax you're talking about may solve my problem. I want to use zlib-pure but I get zlib when I import Codec.Compression.Blah
11:44:41 <indiagreen> karshan: there is the PackageImports extension which lets you import modules using the «import "blah" Blah.Foo» syntax
11:44:45 <Cale> yeah
11:44:59 <Cale> import "zlib-pure" Codec.Compression.Blah
11:45:19 <Cale> and add {-# LANGUAGE PackageImports #-} to the very top of your file
11:46:58 <osa1> any ideas why haskell-src-exts printing my top-level declarations as `id = \arg1 arg2 -> ...` instead of `id arg1 arg2 = ...` ? am I generating wrong hs-src-exts syntax for that?
11:47:01 <newsham> is there a standard lib function for running a "State s a" program inside of a "State s' a" program where s is a member of s'?
11:47:21 <indiagreen> newsham: there is “zoom” is the lens package
11:48:01 <Zemyla> Question. I want to make a continuation-passing list monad that stores and passes its length. Sort of like a monad of (Int, [a]) where the Int is always the length of the list.
11:48:01 <newsham> that looks like what i want.
11:48:45 <Cale> osa1: What declaration constructor are you using?
11:48:56 <osa1> Cale: FunBind
11:48:57 <kadoban> Zemyla: Dumb question: why not just make a list type that caches its length instead?
11:49:01 <Cale> huh
11:49:07 <Cale> That's interesting then!
11:49:48 <osa1> hm wait, I think I'm doing it wrong
11:50:01 <newsham> now I have to ask: is today the day I go down the lens rabbit hole or not..
11:50:15 <Zemyla> kadoban: Yes, but I'd like to do it in CPS style so it doesn't spend all its time constructing and deconstructing lists.
11:50:38 <Cale> osa1: Are you not giving a list of patterns to that?
11:50:46 <kadoban> I don't really know what that means, so I'll let someone else help, heh.
11:50:54 <fmapE> Is there any way to reference the cabal executable version inside a .cabal file?
11:51:19 <fmapE> i.e. to make sure that the Cabal library (as a dep of a detailed-0.9 test) matches the executable?
11:51:56 * hackagebot vcache 0.2.5 - semi-transparent persistence for Haskell using LMDB, STM  http://hackage.haskell.org/package/vcache-0.2.5 (dmbarbour)
11:51:59 <fmapE> (Otherwise minor version discrepancies break things)
11:52:16 <kadoban> fmapE: You can set the required cabal version, is that what you're looking for?
11:52:37 <fmapE> No because I'd rather let people with disparate cabal versions build and test it
11:52:38 <Zemyla> Like, a value in CPS form generally takes the form of its deconstructor.
11:52:41 <Zemyla> :t maybe
11:52:43 <lambdabot> b -> (a -> b) -> Maybe a -> b
11:52:51 <fmapE> kadoban: The issue isn't that I need a particular cabal version
11:53:04 <fmapE> kadoban: But rather that I need the versions of the Cabal library and cabal executable to match
11:53:28 <fmapE> kadoban: because otherwise the cabal executable generates test boilerplate that fails to compile against the Cabal library
11:53:37 <kadoban> fmapE: To match what? They never seem to match each other on my systems.
11:53:38 <Zemyla> So newtype MaybeCPS a = MaybeCPS (forall r. (a -> r) -> r -> r).
11:53:49 <osa1> Cale: yeah sorry, I wasn't...
11:53:49 <fmapE> kadoban: precisely, nor on mine
11:54:05 <fmapE> kadoban: But I need them to otherwise the detailed-0.9 test style breaks
11:54:16 <kadoban> fmapE: Well … it works though on my system, so apparently it's not required?
11:55:12 <kadoban> fmapE: You should probably just assume your library users have a working cabal installation I would think … trying to check it seems, backwards. You're going to use cabal to check if cabal is working? O.o
11:55:16 <YellowOnion1> I want to know how I could approach parallelising a function that is called from Juicy Pixels "generateImage" function.
11:55:31 <fmapE> kadoban:I get tests failing to compile when I use cabal-install 1.22.0.0 with Cabal-1.18.1.5 or with Cabal-1.22.2.0
11:55:49 <fmapE> kadoban: The issue isn't the generally not-brokenness of the cabal installation
11:56:13 <fmapE> The issue is that the particular test style doesn't work without matching versions of cabal-install and Cabal
11:56:41 <kadoban> fmapE: Well, you should probably fix up your installation? Err, maybe I'm not understanding, but that sounds like /exactly/ the issue. Isn't your system just broken then?
11:56:54 <fmapE> because it requires cabal-install to general boilerplate code that uses modules exported by the Cabal module, and those modules have changed their exports
11:56:56 * hackagebot slave-thread 1.0.0.0 - A principal solution to ghost threads and silent exceptions  http://hackage.haskell.org/package/slave-thread-1.0.0.0 (NikitaVolkov)
11:56:58 <fmapE> kadoban: no
11:57:04 <fmapE> This isn't about me testing cabal
11:57:12 <fmapE> This is about me including tests with my cabal package
11:58:12 <fmapE> kadoban: But those tests not compiling due to incompatibilities between boilerplate generated by one version of cabal-install and APIs used by the boilerplate and exported by a different version of Cabal
12:00:14 <fmapE> kadoban: this is the error I get: http://lpaste.net/130362
12:05:00 <kadoban> fmapE: Sorry, I don't know what that is without looking into it more than I'm willing. I still don't see how it's not either a dependency thing (specify in the test-suite build-deps that in needs whatever version of Cabal), or a broken install.
12:06:32 <johnw> ah, that moment when you've been struggling with a concept for many months, and then happen upon a single academic paper that feels as though it was written just for you
12:07:28 <ski> johnw ?
12:07:40 <johnw> apropos of nothing at all
12:07:50 <xelxebar> so I've convinced myself that taking a slice category ((->) r) is a functor/applicative/monad. are there places where we actually use this? I cooked up a silly way of computing percent error from, say 100, (+(-100)) >>= (/) though.
12:07:57 <ski> what is the concept ? what is the paper ?
12:08:38 <ski> xelxebar : `Reader r'
12:08:39 <johnw> using algebraic signatures to represent strict positive functors, as described in Kleisli Arrows of Outrageous Fortune, but finally clarified for me by: http://www.duplavis.com/venanzio/publications/Universal_Algebra_TPHOLs_1999.pdf
12:08:47 <johnw> strictly*
12:09:03 <ski> ty
12:09:14 <johnw> i've been breaking my head against this concept for >6 months
12:09:39 <johnw> also, thanks to that paper, now container types finally make sense (even though the paper doesn't address them at all)
12:12:17 <johnw> Haskell is one community where the contributions of academics cannot be taken for granted
12:13:00 <xelxebar> ski: hmmm. I'm gonna have to figure out what this means. For now I just sort of played "make the types work out" to define fmap, (<*>), (>>=) etc. Do you find it helpful reasoning about types with commutative diagrams?
12:14:03 <xTEMPLARx> silly question from a complete novice:  is haskell compilable?
12:14:34 <ski> xTEMPLARx : yes
12:14:41 <kadoban> xTEMPLARx: Yep, it's a compiled languaged generally.
12:14:48 <xTEMPLARx> excellent ty
12:15:13 <xTEMPLARx> was asking some ppl I know who love python whether they'd used haskell or not, and they thought that it wasn't compilable
12:15:21 <xTEMPLARx> so figured I'd ask
12:15:29 <ski> xelxebar : sometimes
12:15:29 <fmapE> kadoban: k thanks for your help
12:15:33 <xTEMPLARx> ty for the responses :D
12:15:40 <kadoban> fmapE: Sorry it wasn't that helpful help :-/
12:15:57 <ski> xelxebar : `Reader r' is isomorphic to `(r ->)'
12:16:37 <ski> xelxebar : btw, i'm not sure why you said "slice category"
12:17:16 <xelxebar> ski: huh. that's cute.
12:19:57 <xelxebar> ski: oh, well having something like (r -> Integer) looks like a slice category over Integer.
12:20:17 <ski> xelxebar : `(r ->)' is, in the sense of CT, a functor. a slice category is something different
12:24:04 <ski> xelxebar : given a category `C', and an object `r' in it, the objects of the slice category "under" `r' are pairs `(a,f)' of an object `a' (in `C') and a morphism `f' (in `C') from `r' to `a'
12:24:19 <KorriX> napping: I still have problem and need function reading single Word8 from binary file
12:25:16 <xelxebar> ski: I'm handwaving here, but given the yoneda embedding and that Hask is (roughly?) cartesian closed, then you can embed any slice category fully and faithfully into Hask, no?
12:26:50 <ski> xelxebar : given two objects `(a,f)',`(b,g)' of the slice category under `r' (iow, we have in `C' : `f : r >---> a' and `g : r >---> b'), a morphism `m' in the slice category, from `(a,f)' to `(b,g)' consists of a morphism (in `C') `g : a >---> b' such that the obvious commutative triangle commutes (iow, `h . f = g')
12:27:45 <ski> xelxebar : hm .. you could try asking Cale about that :)
12:28:49 <ski> xelxebar : my point here is mainly just that the functor (or, properly equipped, the monad) `(r ->)' is different from the slice category under `r'
12:31:00 <xelxebar> ski: oh, yes, (r ->) wouldn't be the slice over r, rather it'd be the slice over whatever implementation you provide
12:31:17 <Exception221> Hi, I got totally stuck, I need some exception examples, is there someone willing to help me?
12:31:44 * ski doesn't follow xelxebar
12:31:52 <KorriX> How to dereference pointer in Haskell?
12:32:10 <xelxebar> Exception221: people here are exceptionally helpful, throw it out there!
12:32:29 <newsham> ?type \act ma -> maybe (return ()) act ma
12:32:31 <lambdabot> Monad m => (a -> m ()) -> Maybe a -> m ()
12:32:39 <ski> @type Foreign.Storable.peek  -- KorriX
12:32:40 <lambdabot> Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> IO a
12:32:41 <newsham> ?type \ma act -> maybe (return ()) act ma
12:32:42 <lambdabot> Monad m => Maybe a -> (a -> m ()) -> m ()
12:32:54 <amf> how do you convert a json array to a json object with aeson? the array is a fixed length and i have a custom data type with either Word32 or Maybe Word32 for each field
12:33:09 <newsham> ?hoogle Monad m => Maybe a -> (a -> m ()) -> m ()
12:33:09 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
12:33:09 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
12:33:09 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
12:33:27 <amf> ultimately just having trouble yanking the values from the Array in my FromJSON instance definition
12:33:33 <ski> newsham : `forM_' ?
12:33:34 <KorriX> ski: Thx
12:33:53 <Exception221> Well, I would like to know an example of a synchronous exception detected by the application
12:33:53 <Exception221> For example, what in java would be a fail of an assertion.
12:34:04 <newsham> ski: nope.
12:34:28 <newsham> i'm calling it "whenJust"
12:34:36 <newsham> just checking to see if it already existed
12:34:37 <ski> @type forM_ :: Monad m => Maybe a -> (a -> m ()) -> m ()
12:34:39 <lambdabot> Monad m => Maybe a -> (a -> m ()) -> m ()
12:34:58 <newsham> hrmm..
12:35:05 <newsham> ?type forM_
12:35:07 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
12:35:18 <newsham> huh,  forM_ is foldable now.  
12:35:22 <newsham> didnt know that!
12:35:30 <ski> yeah, i meant `Data.Foldable.forM_' anyway
12:36:28 <newsham> ty.
12:36:58 * hackagebot audacity 0.0 - Interchange with the Audacity sound signal editor  http://hackage.haskell.org/package/audacity-0.0 (HenningThielemann)
12:47:21 <platz> why does "traverse Just [1..100000000]" overflow?  the instance for traversable [] uses foldr with (:), and the Applicative instance for Maybe seems only strict in the first argument..
12:47:45 <platz> but it also makes sense that the results can't be consumed eagerly
12:47:54 <platz> so something must be building up, but where?
12:48:36 <xelxebar> ski: I think that I was looking at it backwards and really wanted the coslice category (r,(r->)), does that make more sense?
12:49:17 <ski> xelxebar : no
12:49:36 <ion> platz: traverse (\n -> if n == 100000000 then Nothing else Just n) [1..100000000] needs to return Nothing so it can’t know it will return a Just thing until reaching the end.
12:49:41 <ski> xelxebar : what i called "slice category under" is sometimes called "coslice category"
12:50:11 <ski> xelxebar : also, `(r,(r->))' doesn't make sense, in connection to (co)slice categories
12:50:13 <napping> platz: the applicative is strict Maybe's constructor on the second argument
12:50:50 <_rgn> i have trouble printing IO [String] with putStrLn, do I just fmap with putStrLn and then sequence or something?
12:51:33 <napping> something like that works. mapM_ putStrLn is easy
12:51:39 <ski> _rgn : `mapM_ putStrLn =<< ...' ?
12:51:52 <monochrom> mapM_ and sequence_ are related. you thought right.
12:51:56 <napping> you'd need to fmap by map putStrLn, if you were going that way
12:52:08 <ski> @src mapM_
12:52:08 <lambdabot> mapM_ f as = sequence_ (map f as)
12:52:39 <karshan> has anyone here used a zlib library for haskell that doesn't call error on failure ?
12:53:04 <napping> If you mean fmap over the list that works too - I was thinking something like do x <- fmap (map putStrLn) <myIO>; sequence x
12:54:32 <_rgn> yay mapM_ putStrLn =<< (map getMessageStr) <$> testParse parse 10 "error.log"
12:54:58 <ski> _rgn : the brackets are redundant there
12:55:12 <_rgn> mapM_ (putStrLn . getMessageStr) better i guess
12:55:19 <ski>   mapM_ (putStrLn . getMessageStr) =<< testParse parse 10 "error.log"  -- yeah, what you said
12:57:29 <_rgn> i was thinking about fmap all the time and didn't realize i could use mapM because bind takes (a -> m b)
12:59:37 <xelxebar> ski: goodness. am I just completely confused? We have a functor that takes a type `a` to `(r -> a)` for some given type r, no? and then we have the relevant commutative diagrams via (.) :: (b -> c) -> (a -> b) -> a -> c which give us our arrows for a coslice category (r,Hask), no?
13:00:11 <xelxebar> ski: and it just so happens that such a functor is natural in r
13:01:35 <aruro> ls
13:01:58 <ion> rm -fr ~
13:02:31 <ski> xelxebar : i'm not sure what it means for a functor to be natural in anything
13:03:22 <aruro> ghc gives following error while compiling file with UTF-8
13:03:53 <aruro> stderr:commitBuffer : invalid argument (invalid character)
13:03:53 <xelxebar> ski: it just means that you have the relevant natural transformations for arrows r -> s and stuff
13:04:04 <aruro> im trying to use UTF-8 symbol as identifier
13:04:39 <ski> xelxebar : the functor `(r ->)' maps morphisms `f : a >---> b' into morphisms `fmap_(r ->) f : (r ->) a >---> (r ->) b'. this relies on there being exponentials in the category
13:05:19 <xelxebar> ski: and the yoneda embedding, no?
13:05:25 <indiagreen> aruro: are you using Linux / OS X? can you say what “echo $LANG” outputs?
13:05:32 <ReinH> xelxebar: Well, you have the rather boring result that all polymorphic functions are natural transformations because of parametricity, so I think this is trivially true.
13:05:37 <EvanR> aruro: well symbols cant be identifiers
13:06:11 <ski> xelxebar : the slice category under `r' (or coslice category, if you prefer) has morphisms of the form `(h,p) : (a,f) >---> (b,g)', where (in the base category `C') `f : r >---> a',`g : r >---> b',`h : a >---> b' and where `p' is a proof that `h . f = g'
13:06:16 <aruro> why not?
13:06:27 <ReinH> aruro: because of the grammar rules of the language.
13:06:28 <EvanR> because symbols are operators
13:06:37 <aruro> what is sense int UTF-8 support then?
13:06:38 <ski> xelxebar : the slice category doesn't require there to be any exponentials in `C'
13:06:51 <ReinH> aruro: ?
13:06:59 <EvanR> not utf-8, unicode
13:06:59 <aruro> hm
13:07:06 <aruro> yea unicode
13:07:08 <ReinH> Unicode classifies code points as symbols or non-symbols.
13:07:08 <aruro> sorry
13:07:14 <ski> xelxebar : i don't understand the Yoneda embedding that well, so i can't really comment on that
13:07:17 <EvanR> you can use letters in identifiers
13:07:20 <EvanR> like lambda
13:07:28 <ski> xelxebar : i don't understand "it just means that you have the relevant natural transformations for arrows r -> s and stuff"
13:07:28 <aruro> let me try
13:10:21 <platz> napping: ah, so in "instance Applicative Maybe where Just f <*> m = fmap f m"
13:10:36 <circ-user-LgpZV> I'm trying to define/use Fix at the type level, but getting caught up with some inconsistency I don't understand. Here's an example: http://lpaste.net/130366  -- the LocFoo type isn't happy, says it needs another argument
13:10:43 <platz> it's not strict in m argument, but in fmap f m
13:11:01 <platz> because instance  Functor Maybe *is* strict in the second argument
13:11:13 <platz> so that forces m
13:12:42 <monochrom> circ-user-LgpZV: when using type synonyms, ghc (or haskell altogether? I forgot) insists on having all type parameters present.
13:13:26 <circ-user-LgpZV> why does Foo work then?
13:13:44 <monochrom> I am referring to LocFooF, not LocFoo
13:14:11 <monochrom> since FooF is not a type synonym, it is alright to write "FooF" alone without parameters
13:14:23 <napping> monochrom: that's certainly in the standard, partially applied type synonyms amount to type-level lambdas
13:15:16 <monochrom> since LocFooF is a type synonym and you wrote "type LocFooF a = ..." not "type LocFooF = ...", now every mention of LocFooF must have the form "LocFooF blahblah", never "LocFooF" alone
13:15:32 <karshan> can you "catch" error exceptions ?
13:15:49 <napping> yes
13:16:05 <warrenharris> monochrom how would you write FooF without the parameter?
13:16:25 <karshan> napping: how ? I'm talking about error from prelude used in a pure context. example head
13:16:35 <karshan> for example head*
13:16:56 <monochrom> I was mis-stated the requirement. when using type synonyms, we insists to fill in all parameters that you listed back when you wrote "type X <params>  = ..."
13:17:50 <monochrom> I don't understand the question. aren't FooF and Foo working perfectly already?
13:17:56 <napping> karshan: error s is approximately throw (ErrorException s)
13:18:08 <monochrom> do you want to ask how to do LocFooF and LocFoo?
13:18:25 <warrenharris> monochrom: yes Foo type checks, but LocFoo doesn't - and they look the same to me
13:18:47 <monochrom> I would define LocFooF by a newtype, not a type synonym
13:18:55 <napping> warrenharris: LocFoo is fine, the problem is LocFooF
13:19:15 <monochrom> and yes, <monochrom> I am referring to LocFooF, not LocFoo
13:20:43 <monochrom> FooF is clearly different from LocFooF because the former is not a type synonym, the latter is.
13:21:01 <platz> so is there any rule-of-thumb when working with "traverse" to avoid building up thunks?  a lot of the definitions are fixed in instances
13:21:22 <warrenharris> monochrom: ok, this fixed it: newtype LocFooF a = LocFooF (Loc (FooF a))
13:21:28 <warrenharris> thanks very much
13:21:36 <beum> hello, is it possible to have a function use a variable type as a parameter in a function? example: funct :: Type -> Bool. I want the the function to work with both TypeA and TypeB
13:21:52 <aruro> guys, correct me here, so this block of unicode http://en.wikipedia.org/wiki/Mathematical_Operators
13:22:00 * hackagebot nonce 1.0.2 - Generate cryptographic nonces.  http://hackage.haskell.org/package/nonce-1.0.2 (FelipeLessa)
13:22:02 <aruro> is allowed to use as operators?
13:22:07 <napping> platz: didn't you get a stack overflow?
13:22:19 <aruro> ty, i managed to use greek letters as identifiers
13:22:33 <karshan> napping: Ohh, I didn't notice the Control.Exception.evaluate which is needed to catch exceptions from pure functions. Thanks!
13:23:19 <platz> napping: um, yes?  I was just thinking the default implementations for many types e,g, [] and Maybe, Either, etc.. kind of make it hard to avoid these stack overflow exceptions
13:23:23 <napping> karshan: yeah, that's why it's good to avoid it if possible
13:23:29 <arkeet> beum: there are a couple options
13:23:36 <arkeet> you could have some Either TypeA TypeB -> Bool
13:23:39 <platz> maybe I'm thinking about this the wrong way, i.e. pathological
13:23:39 <napping> platz: stack overflow comes from deep strict recursion, rather than excess thunks
13:23:51 <arkeet> or have some type class C that TypeA and TypeB have instances for
13:23:54 <arkeet> and C a => a -> Bool
13:24:02 <napping> I guess you're right either way that it depends on strictness properties of the operations
13:24:29 <karshan> napping: yea I completely agree, I tried finding a zlib library that doesn't throw errors in pure functions, but I couldn't :(. There's even pure-zlib which has `decompress :: ByteString -> Maybe ByteString` but it still throws errors!
13:24:43 <platz> i know I can avoid it if i write my own definitions to work with traversable
13:25:01 <platz> but the default implementations seem to lead down this path
13:25:06 <napping> platz: For a first guess, I'd assume traversable instances are at least spine-strict, and not tail recursive
13:25:34 <c_wraith> how can a Traversable instance be tail recursive?  It needs to be in terms of <*>
13:25:51 <c_wraith> That more or less makes it impossible for it to be tail recursive
13:26:35 <monochrom> use a larger stack
13:26:53 <napping> karshan: sounds like you are stuck then. At least it should be pretty easy to make sure that result type is completely forced
13:27:03 <monochrom> just like you have always used a larger heap for other problems
13:27:50 <beum> arkeet: Either TypeA TypeB gives me the error "Couldn't match expected type 'Either TypeA TypeB' with actual type 'TypeA' "
13:28:01 <arkeet> beum: well, you have to use them properly.
13:28:11 <arkeet> beum: do you have a specific example?
13:28:23 <napping> karshan: what library are you trying
13:28:39 <monochrom> Suppose a program uses 9MB of memory.
13:28:58 <monochrom> if those 9MB are in the heap, no one asks how to reduce it
13:29:03 <napping> platz: what version of GHC are you using?
13:29:32 <monochrom> if those 9MB are in the stack, people are very loud about "how do I use less stack?"
13:29:35 <platz> 7.8.4
13:29:35 <napping> 7.8 release notes say "The default maximum stack size has increased. ... Now, GHC will use up-to 80% of the physical memory available at runtime."
13:29:39 <monochrom> I don't understand their logic.
13:29:48 <benzrf> what's the true minimal definition for a Read instance
13:30:03 <benzrf> cause it seems like if you just define `read' then theres no way to implement reads?!
13:30:07 <c_wraith> I'm pretty sure the minimal definition is reads
13:30:20 <benzrf> alright sweet :D
13:30:21 <beum> arkeet: yes, http://lpaste.net/8586149725084844032
13:30:22 <benzrf> :t reads
13:30:22 <napping> monochrom: if 9MB of heap made your program crash unless you passed obscure runtime flags people would complain about that too
13:30:23 <lambdabot> Read a => ReadS a
13:31:08 <benzrf> hmm
13:31:19 <napping> platz: weird, how bit was that list again?
13:31:28 <benzrf> is there a way to destruct a constructor and release knowledge of an instance
13:31:45 <platz> > traverse Just [1..100000000]
13:31:47 <lambdabot>  *Exception: stack overflow
13:32:01 * hackagebot hoogle 4.2.40 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.40 (NeilMitchell)
13:32:18 <monochrom> napping: I am happy to report that I was the main lobbying effort that convinced SPJ to change from "8MB stack cap" to the now flexible stack
13:32:43 <napping> congratulations
13:32:44 <monochrom> basically by being sarcastic about the illogic I described
13:33:17 <napping> platz: I see that allocating over 6GB before failing!
13:33:47 <platz> it's the same as the classic foldr (+) 0 [1..100000000]
13:33:58 <monochrom> it was particularly bad because from GHC 6.something onwards, "stack" has been growable and part of the heap. but stack cap was a legacy that never went away
13:34:20 <benzrf> is there an existing solution to convincing ghc that the parameter to a type constr must have a Read (for example) instance since the type in question is a GADT with phantom types in that slot
13:34:23 <napping> > let l = [1..100000000] in length l `seq` l
13:34:26 <benzrf> right now i plan on making a class for it
13:34:29 <lambdabot>  mueval-core: Time limit exceeded
13:34:29 <lambdabot>  mueval: ExitFailure 1
13:34:37 <napping> that's a pretty darn big list
13:35:05 <benzrf> > let l = [1..100000000] in genericLength l `seq` l :: Nat
13:35:06 <lambdabot>      Not in scope: type constructor or class ‘Nat’
13:35:06 <lambdabot>      Perhaps you meant ‘Not’ (line 151)
13:35:08 <benzrf> wait
13:35:25 <monochrom> To be completely clear, I have high respect on people who, logically and consistently, care about "I want to keep my space usage below 7MB, heap or stack".
13:35:27 <napping> I run out of memory trying to run that locally
13:36:16 <napping> monochrom: and the relevant point here from that is that traverse has a pretty hard time being lazy
13:36:52 <platz> so my uninformed conclusion here so far is avoid traverse and resort to pipes/conduit
13:37:08 <platz> but surely this must've come up in lenses which use traverals heavily
13:37:23 <napping> Saying "traverse" is too specific
13:37:46 <napping> The right generalization is that if you want to work with data too big to fit into memory, pipes or conduit is probably a good idea
13:37:51 <platz> unless lenses tend to instances somehow that fuse better
13:38:33 <napping> You need laziness more than fusion here, but maybe lens tends to
13:39:04 <napping> also, if you're squishing to a monoid with Constant you don't need to keep the same kind of space
13:39:11 <napping> which lens likes to do, alot
13:40:16 <platz> so as long as the `t` in the Traversable is lazy enough.. but I'm wondering how often that is actually that case
13:40:19 <napping> traverse pure [1..] () is lazy, for one example
13:40:27 <napping> using (r ->) as the applicative
13:40:40 <napping> Well, that's up to you
13:40:46 <platz> err, my bad not the t, the applicative
13:40:57 <napping> sounds like you are working with data big enough that you absolutely need to be sure things are lazy
13:41:13 <napping> or use something like pipes/conduit that specializes in constant-space streaming
13:41:32 <platz> i'm not sure id call 10000000 big data, just trying to understand idomatic traversal usage
13:41:58 <napping> a single list taking up more than 4GB of heap is pretty big
13:43:48 <napping> karshan: what zlib libraries are you using?
13:45:14 <napping> karshan: zlib packages seems to expose some pure error reporting functions in Codec.Compression.Zlib.Internal
13:46:49 <karshan> napping: Yea you're correct, I just assumed I cant import *.Internal because usually those are hidden modules
13:51:19 <c_wraith> karshan: *.Internal modules exist specifically to not be hidden.  They provide useful features that might be dangerous if used improperly - but are still useful.
13:51:49 <glguy> If you use an Internal module you should set a fairly strict version constraint bound
14:00:39 <karshan> c_wraith: Hmm I guess Network.Wreq is an exception becuase Network.Wreq.Internal is totally a hidden module
14:01:35 <geekosaur> looks like they didn't follow convention, yeh
14:02:02 * hackagebot fay-builder 0.2.0.5 - Compile Fay code on cabal install, and ad-hoc recompile during development  http://hackage.haskell.org/package/fay-builder-0.2.0.5 (AdamBergmark)
14:02:21 <ocramz`> hey there, anybody with some C2HS experience?
14:07:11 <ronh> starting fresh.. should I install platform or go with sandboxes?
14:07:50 <ion> ronh: One does not exclude the other.
14:08:26 <ronh> ion but platform already ships with global libraries, and the whole point of sandboxes was to make libraries local, no?
14:08:59 <ion> You can use both.
14:09:31 <ronh> does sandbox then use a globally installed libraries or does it download local ones anyway
14:10:37 <ronh> and one other thing i'm kind of worried about.. if I have several projects that depends on a complex package will it have to be recompiled for each project?
14:11:11 <ion> A sandbox will reuse the globally installed package.
14:11:14 <ocramz`> no the package won't be recompiled
14:11:21 <ion> You could share a sandbox between some projects.
14:26:08 <sammecs> Hi, I'm having problems using HDBC: If I insert something into a table (MySQL, SqlValue is SqlString "foo"), the value in the table is "f\NULo\NULo\NUL". Any ideas why this could happen?
14:28:56 <sammecs> Or, in other words, it seems like HDBC uses ASCII chars while my database uses UTF8. How can I tell HDBC to use UTF8-Strings?
14:34:12 <geekosaur> sammecs, that looks more like something is using UTF16
14:36:04 <geekosaur> more specifically, the database is using UTF8 but HDBC or something in between is using UTF16
14:36:34 <sammecs> geekosaur: Yes, "something in between" is ODBC - maybe it has to be configured?
14:38:17 <geekosaur> likely. ODBC drivers in my experience assume Windows, which would certainly explain UTF16
14:38:49 <beum> I get an "Couldn't match expected type" error, can someone help me? http://lpaste.net/1741265108568375296
14:39:30 <geekosaur> beum, your Expr type is not what you think it is
14:39:49 <ski> beum : `BExpr' and `IExpr' in `data Expr = BExpr | IExpr' are data constructors (not type constructors), they have nothing to do with your previous types `BExpr' and `IExpr'
14:40:08 <geekosaur> you expected to be either an IExpr value or a Bexpr value. what it is is an enum <BExpr, IExpr> with no other values.
14:40:37 <monochrom> data Expr = ItsB BExpr | ItsI IExpr
14:40:38 <beum> ah I see, hmm so how could I get the result that I want?
14:40:42 <geekosaur> data Expr = BExp Bexpr | IExp IExpr -- and now you can pagttern match the constructor BExp or IExp
14:40:53 <geekosaur> to determine which one it is
14:41:29 <monochrom> in "data MyType = X | Y", X and Y are not type names.
14:48:09 <linman32> does anyone have experience with pickling xml with HXT? trying to ignore "unprocessed XML content"
14:50:52 <YellowOnion1> Could someone point me in the right direction on how to parallelize this code? http://lpaste.net/130373
14:50:57 <sammecs> geekosaur: Ok, I tested a few ODBC configurations using ASCII, UTF8 and UTF16. None worked - I don't know why. The result is always "f\NULo\NULo\NUL"...
14:51:28 * geekosaur is not either an HDBC or ODBC expert, and can't really help
14:51:34 <geekosaur> I just recognized UTF16
14:53:07 <sammecs> Then I thank you for your help, geekosaur.
14:53:25 <carp> fr33domlover: ah cool, i have got half way through 'leran you a haskell so far' how about u
14:53:52 <carp> *'learn you a haskell for great good' so far..
14:56:53 <fr33domlover> carp, I decided to use only free culture resources (not sure if the one you mention is, need to check)
14:56:59 <fr33domlover> so I started with the Wikibook
14:57:22 <fr33domlover> also there's "Scheme in 48 hours" and some other book, also at Wikibooks
14:57:32 <fr33domlover> (all are haskell tutorials)
14:57:54 <beum> geekosaur: I still get the "Couldn't match expected type ‘Expr’ with actual type ‘IExpr’" error, is this the right way to use the pattern matching? http://lpaste.net/8005574604565250048
14:58:10 <Welkin> all the best haskell materials are free
14:58:45 <ski> beum : looks fine
14:58:58 <Welkin> Learn You A Haskell, Real World Haskell, Concurrent and Parallel Haskell, Typeclassopedia, Write Yourself A Scheme, etc.
14:59:22 <Welkin> oh, the UPenn course
14:59:56 <sammecs> OK, so it seems like MySQL uses UTF8, but GHC outputs UTF16. My ODBC configuration does nothing. Is there a compile option to tell GHC what charset to use?
15:00:42 <ski> carp,fr33domlover : perhaps also consider <http://www.seas.upenn.edu/~cis194/spring13/lectures.html>
15:01:26 <fr33domlover> ski, thanks
15:01:49 <geekosaur> beum, it is, my guess is the problem is elsewhere, like, you're invoking zetom with an IExpr instead of (ItsI yourIExprHere)
15:02:04 * geekosaur has to go for a while...
15:02:05 * hackagebot breve 0.0.1.0 - a url shortener  http://hackage.haskell.org/package/breve-0.0.1.0 (rnhmjoj)
15:04:50 <beum> geekosaur: that was indeed the solution, awesome, thanks, I will try to continue now :)
15:15:15 <ocramz`> a little c2hs help plz ? https://gist.github.com/ocramz/7b22d6cf2eb1ec4f5400 
15:15:23 <koala_man> I tried to  ''cabal install transformers-0.4.3.0'' but it says ''rejecting: transformers-0.4.3.0 (global constraint requires ==0.3.0.0)''. Where does this constraint come from?
15:15:48 <liyang> koala_man: ZA WARUDO.
15:17:57 <liyang> koala_man: I'm not sure about your particular case, but https://www.google.com/search?q=cabal+"global+constraint+requires" might help.
15:18:30 <monochrom> also, ghc 7.8 comes with transformers approx 0.3.0.0
15:18:56 <monochrom> it is usually a bad idea to add multiple versions, especially when ghc already comes with one.
15:19:16 <monochrom> an expert knows how to survive it. but few people are experts.
15:20:39 <koala_man> I'm still on debian stable's ghc 7.4.1 :/
15:21:08 <Clint> koala_man: you might want to upgrade to jessie
15:21:12 <monochrom> then you should be free to choose which version of transformer you like, but you should still stick to one
15:22:07 <monochrom> it is unfortunately that cabal-install goes gun-ho in adding multiple versions behind your back. most of the time this confuses ghc and you later.
15:22:40 <carp> Welkin: ski: thanks, i made a big list now.
15:24:22 <carp> ski: ur link 404 error though. but i can find it no worries.
15:30:31 <sammecs> Does anyone now how I can format the encodings of SqlValues of HDBC? I can encode strings to utf8, but it seems like HDBC encodes them back to utf16, while my db needs utf8!
15:31:08 <beum> monochrom: I have a question about the guard, I want to know which form the data types is currently being used, code for clarification here: http://lpaste.net/7459765255736918016
15:33:19 <monochrom> no, that is not what guards are for. that is what pattern matching is for.
15:34:01 <monochrom> zetom (ItsI (Vermenigvuldig (IWaarde 1) (IWaarde 2))) = ...
15:34:28 <monochrom> and if you don't really care about the 1 and 2,
15:34:35 <monochrom> zetom (ItsI (Vermenigvuldig (IWaarde _) (IWaarde _))) = ...
15:34:53 <monochrom> and if you don't care about the IWaarde's either,
15:35:02 <monochrom> zetom (ItsI (Vermenigvuldig _ _)) = ...
15:35:05 <ski> carp : works here ..
15:35:41 <monochrom> "a == Vermenigvuldig" is like taking an imprecise intuition too far
15:36:22 <beum> monochrom: I see, thanks!
15:42:05 <sm> woo! 
15:43:01 <sm> types got you down ? monads, zippers and prisms frying your brain ?
15:43:16 <sm> rest your eyes on this! http://www.filfre.net/misc/oregon1975.bas
15:44:01 <ocramz`> ooo pretty Basic
15:44:22 <murz> Hi, I'm trying to get started with Haskell web development by following this tutorial: http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html ... However, when I paste the example cabal file and run "cabal install" I get hit with this: http://lpaste.net/130391  .. I tried just updating base==4.6.* to 4.7.*, which seems to help, but then I hit:
15:44:22 <murz> http://lpaste.net/130392  ... any tips on how to modify the cabal file to get things building? Or maybe pointers to tutorials/examples that are more up to date?
15:44:32 <ski> square brackets for arrays ? .. strange
15:45:20 <ski> oh, i see, it's for strings (still strange)
15:45:23 <carp> ski it nots 404 for me, that was incorrect, it actually says 'Not Found' The requested URL /~cis194/spring13/lectures.html> was not found on this server.
15:45:45 <ski> carp : the delimiting angle brackets are not part of the URL
15:46:35 <carp> ski ah yep the link included the ending one. nice
15:46:51 <sm> murz: following an old outdated tutorial will be tough, your best chance is probably to use the GHC version current when it was posted
15:47:17 <platz> sammecs: are you using hdbc-mysql ?
15:47:31 <sammecs> platz: no, ODBC.
15:47:57 <sm> murz: but sure try adding --allow-newer
15:48:26 <ski> sm : here's another one for you <https://web.archive.org/web/20150215080553/http://www.dunnington.u-net.com/public/startrek/STTR1> (star trek)
15:49:40 <murz> cabal: unrecognized option `--allow-newer'
15:50:04 <murz> cabal-install version 1.18.0.5 ... is this old? I just installed by downloading the Haskell Platform osx installer
15:50:17 <platz> sammecs: here's an interesting comment, not sure if it helps https://github.com/hdbc/hdbc-odbc/blob/ab03a6b944f0e5d4901de3b646f321b54211225d/Database/HDBC/ODBC/Statement.hsc#L318
15:50:35 <kadoban> murz: A bit, but it's not that bad. I'm running near that version by choice (since some things don't work with newer, like ghc
15:50:38 <kadoban> -mod)
15:52:57 <platz> there's just something about markup with blaze and other embeddings into haskell that i will never get used to 
15:54:02 <sammecs> platz: Hmm. So on my system (ubuntu), the driver gets an utf8 string. Then it should work fine, shouldn't it?
15:55:35 <sm> ski: nice!
15:56:06 <sm> I'm reading http://www.filfre.net , highly recommended
15:58:30 <platz> sammecs: i guess maybe try to find documentation about the odbc lib/driver installed on your system?
16:00:31 <platz> sammecs: maybe add params to the connection string http://stackoverflow.com/questions/1000636/mysql-odbc-3-51-driver-utf-8-encoding
16:01:09 <ocramz`> c2hs FFI question; minimal (not)working example here: http://stackoverflow.com/questions/29526738/linker-error-in-c2hs-generated-c-binding
16:01:40 <sammecs> platz: Oh, I used that earlier, but it didn't seem to work... ODBC accepts the parameter (because I get error messages when I type in something bad), but nothing really happens.
16:05:49 <aruro> how can i read systemwide keystrokes on linux?
16:06:03 <aruro> preferably being a background process
16:06:11 <ocramz`> aruro: wrong channel bro
16:06:18 <aruro> whY?
16:06:28 <aruro> i need some haskell library for that
16:07:16 <hpc> first, it's not a language issue
16:07:16 <aruro> kinda like systemwide hotkey
16:07:30 <hpc> second, you can't just go asking for keyloggers
16:07:43 <aruro> hotkey/=keylogger
16:08:12 <hpc> same underlying mechanism
16:08:18 <aruro> ok not systemwide, just xssesion wide
16:08:24 <aruro> so?
16:08:42 <hpc> you just need to clarify in your opening question
16:08:54 <aruro> there is linux app called autoit
16:08:58 <hpc> or people will assume "hai can me be haz of the haxxors kthxbai"
16:09:07 <aruro> as sorry autokey
16:09:12 <aruro> it does that i think
16:09:30 <aruro> lol :)
16:09:46 <hpc> to be clear, people /do/ come in here asking that
16:09:48 <aruro> ok suggest me then some nice hotstrings app for linux
16:09:55 <aruro> and you would spare me lots of time :)
16:10:41 <ocramz`> @google linux keylogger
16:10:41 <lambdabot> https://logkeys.googlecode.com/
16:10:44 <ocramz`> there
16:10:50 <hpc> heh
16:12:26 <aruro> google provided us with keylogger :)
16:12:28 <aruro> niiice :)
16:13:20 <pavonia> So you won't get any help here if you want to write hacking tools with Haskell?
16:13:31 <aruro> its not hacking
16:13:36 <Welkin> what is "hacking"?
16:13:46 <hpc> haskell acking
16:13:47 <aruro> its same as reading one character just being on the background
16:13:48 <hpc> it's a tcp thing
16:14:07 <aruro> so every automation tool is hacking?
16:14:30 <pavonia> Welkin: e.g. a keylogger
16:15:07 <aruro> ok for security concerned people :)
16:15:11 <aruro> there is xdotools
16:15:23 <aruro> which i think can make keyboard hooks
16:15:30 <aruro> you can call it from haskell
16:15:41 <aruro> as external program
16:16:28 <jhance> hai can me be haz of the haxxors
16:16:57 <ski> aruro : <http://hacks.mit.edu/Hacks/by_year/2001/the_one_ring/> is a hack
16:18:29 <aruro> im wondering if writing a kernel driver is also considered hack here :D
16:18:51 <hodapp> if I'm doing a pull request for something that's on Hackage, and would like for it to be updated at Hackage too, what's the mechanism to make this happen?
16:18:56 <hodapp> bumping a version number in the cabal file?
16:19:02 <joof> if it's in haskell... probably :P
16:19:29 <jhance> hodapp: You upload it to hackage. But normally you let the maintainer do that.
16:19:50 <Clint> the answer is social pressure
16:20:14 <bramgg> can I have multiple "case of's" on one line?
16:20:16 <sammecs> platz: Thank you for your help - I tried using "SET NAME utf8", but it didn't work for me... And I'm to tired to move on (now).
16:20:24 <ski> bramgg : yes
16:20:37 <hodapp> jhance: hmm, so not much I can do to expediate that except for ask him/her?
16:21:02 <ski> > case () of () -> case () of () -> () where where
16:21:03 <lambdabot>  ()
16:21:13 * sammecs bows while slowly walking away.
16:21:17 <jhance> hodapp: I _think_ it may be possible to upload it to hackage yourself. But it would be incredibly rude to do so. So yea, you just ask her, or you upload a fork under a different name and use that
16:21:34 <bramgg> ski: how?
16:21:53 <jhance> (I don't remember  what the exact policy is but I feel like I remember some case where someone uploaded a copy of someone else's package and took priority and it had to get fixed. I feel like it shouldn't be possible at all, though)
16:21:54 <hodapp> jhance: I wouldn't go to the trouble of doing a pull request in that case
16:22:08 <jhance> hodapp: Is it really incredibly urgent?
16:22:09 <ski> bramgg : you might need `{',`;',`}', in case you have more than one parallel branch
16:22:17 <AfC> hodapp: there's no guarantee that current 'master' is releasable. I think the consensus is that that's a good idea, but if you aren't the maintainer it's not your call to make
16:22:19 <jhance> If its a huge bug fix, the maintainer will want to release very quickly anyway
16:22:41 <kadoban> hodapp: … so if you can't yourself update an arbitrary package on hackage, that you don't own, you won't bother with a pull request? That seems … odd.
16:22:42 <hodapp> jhance: It's not that it's urgent, it's that the maintainer is rather busy and I'd like to make his work here minimal.
16:22:57 <hodapp> kadoban: No, what I mean is that, if I were going to do a fork and upload that, *then* I wouldn't bother with a pull request.
16:22:58 <DerisiveLogic> Hey could anyone help me write this in Haskell? 
16:23:00 <DerisiveLogic> https://github.com/VoydLogic/Project-Euler-JavaScript/blob/master/Problem001.js
16:23:09 <kadoban> Ahh
16:23:18 <DerisiveLogic> Basically I just want to iterate through 1-1000 and add each multiple of 3 || 5
16:23:19 <AfC> hodapp: Please don't do that
16:23:21 <hodapp> kadoban: That is, if I were going to ignore the maintainer anyway, it'd seem a little senseless to do a pull request.
16:23:35 <kadoban> Right, gotcha. Yeah, I'd avoid that.
16:24:21 <AfC> Before we build a mountain out of this, what is the problem you're seeking to address; and, what communications have you had with the existing maintainer?
16:25:58 <hodapp> kadoban: What I'd not realized is that it had to be explicitly uploaded, as I've never done it before. I had thought that it pulled automatically from a specific git repo or something like that.
16:26:24 <kadoban> DerisiveLogic: Sounds like a nice simple thing that I don't want to spoil for you. What resources are you using to learn haskell? https://github.com/bitemyapp/learnhaskell has good advice
16:27:08 <kadoban> hodapp: Yeah, I could see where you'd think that, but it's totally separate. Although uploading to hackage is pretty simple it seems like, once you have it set up already.
16:27:09 <DerisiveLogic> kadoban: You would only be helping, I just need to get the syntax down.
16:27:11 <ronh> if I installed GTK in sandbox will it have to be recompiled for everz new sandbox_
16:27:21 <ronh> gtk2hs
16:27:21 <DerisiveLogic> kadoban: It's not like I haven't already solved the problem before.
16:27:38 <kadoban> DerisiveLogic: Yes, but solving it in haskell would be a nice test once you learn a bit.
16:27:59 <kadoban> DerisiveLogic: Just seeing the answer is … probably not going to be very helpful. It won't teach you much of anything.
16:29:04 <ocramz`> DerisiveLogic: look up pattern guards and maps
16:29:36 <kadoban> DerisiveLogic: Haskell is quite a bit different than most languages, including JavaScript (although JS does have some nice support for functional programming). So just seeing the syntax will be … just not that helpful.
16:30:03 <DerisiveLogic> kadoban: Yeah that's the problem lol, even the solutions I've seen are still a mindfuck. 
16:30:29 <hodapp> DerisiveLogic: Haskell isn't just a re-syntax-ed version of a bunch of other languages; you really have to understand a lot of it from the ground up.
16:30:43 <DerisiveLogic> hodapp: That's what I'm starting to notice.
16:30:46 <kadoban> DerisiveLogic: Try the cis194 class. Haskell is a cool language once you get into it.
16:31:30 <hodapp> a cool language that will turn your brain inside out if you've no exposure to pure-ish FP.
16:31:47 <ocramz`> hodapp: word
16:31:52 <DerisiveLogic> Hence why I want to learn it.
16:31:56 <hodapp> ocramz`: is your name a mashup of 'occam's razor'?
16:32:03 <hodapp> it has all those letters... sort of.
16:32:58 <ocramz`> hodapp: :D also
16:33:10 <hodapp> DerisiveLogic: best thing then is probably to get started with some of the guides kadoban mentioned. There's also LYAH, but that one's less favored here.
16:33:12 <ocramz`> Marco, nice to meet you
16:33:13 <Jello_Raptor> is it possible to create a self contained (i.e. single executable) haskell interpreter/compiler that has a number of libraries compiled in? 
16:33:56 <DerisiveLogic> hodapp: Hmm, I see.
16:34:07 <Jello_Raptor> I want to be able to write something like `runhaskell` which can run a specific subset of scripts which use a fixed set of libraries. 
16:34:38 <ocramz`> also FP101x, if you care to do quite a bit of extra digging
16:35:36 <ocramz`> Jello_Raptor: you mean statically linking in external libraries or just pure Hs bits?
16:36:36 <Jello_Raptor> ocramz: statically linking in external libraries, including some with FFIs 
16:37:37 <ocramz`> it is certainly possible, though your specs are still a bit vague
16:41:19 <ocramz`> Jello_Raptor: go through the Real World Haskell chapter on FFI, then look at c2hs. I'll see you here in a couple of days ;)
16:41:24 <Jello_Raptor> ocramz: I suppose the obvious example would be something like "ghci" but a simple self contained binary, that has some set of libraries built in (say control.len) so that interpreted code can use those libraries. 
16:42:28 <Jello_Raptor> ocramz: mind the spec is vague in and of itself :P 
16:42:39 <Jello_Raptor> I'm trying to see whether some things I want are possible at all. 
16:43:49 <hpc> so, running haskell from C, not the other way?
16:44:44 <hpc> what i expect you want is ghc as a library
16:44:59 <alex____2> does ghci support the unicode symbol with code 1D706 ?
16:45:03 <hpc> plus objects for the rest of the stuff you want compiled in
16:45:11 <alex____2> which is greek lambda
16:45:34 <hpc> your C code loads the RTS, then does whatever
16:46:02 <hpc> https://wiki.haskell.org/Calling_Haskell_from_C -- basic example
16:46:25 <hpc> if you want it as a single executable, static link all the libraries you want to include
16:46:54 <hpc> what are you planning to use this for?
16:47:07 <ErichKeane> So I hope this is OK, and some of you may have seen this, but the Haskell Thompson-Wheeler logo keycaps group-buy finally went live!  Sign up here: http://www.pimpmykeyboard.com/deals/haskell-logo-keycaps/
16:47:59 * ocramz` wishes all of #haskell a good night and foldrs to bed
16:51:31 <Jello_Raptor> hpc: I want to build a build system similar to shake (but with a few additional properties I can't just add) and being able to distribute a single executable that can run a build file or compile it is a must. (Since I want it to be an EDSL)
16:51:49 <hpc> fun
17:01:20 <Jello_Raptor> in the same vein, is there something like a libcontainer binding for haskell? 
17:03:26 <Jello_Raptor> there's lxc specific bindings, but I want something that could (at least theoretically) work on all POSIX systems. 
17:11:57 <hodapp> hmm, sort of wish I didn't have to make the documentation follow the module structure in Haddock, but I suppose it makes sense that I must
17:12:52 <hodapp> e.g. with https://hackage.haskell.org/package/atom it's annoying to have to click around those 10 modules to actually get to the docs, but the only way I can see to change this is to change what's imported
17:13:31 <dmwit> I've seen packages that have a Doc. hierarchy.
17:15:02 <dmwit> You can also help things a lot by having your top-level module specify its export list explicitly (rather than just exporting a bunch of submodules).
17:15:23 <dmwit> e.g. Data.SBV is a good example of this
17:16:48 <hodapp> dmwit: yeah, it seems a little clunky to have to repeat everything there, but I suppose that works
17:17:13 <hodapp> dmwit: then I don't require 'hide' in OPTIONS_HADDOCK, and there are still individual module pages
17:17:46 <hodapp> dmwit: Data.SBV seems to have impeccably awesome docs though :) I need to learn that library further
17:20:26 <mauris_> hey, there's a pattern i keep running into and worrying about: suppose i define something like
17:20:57 <mauris_> mySplitAt k xs = (take k xs, drop k xs)
17:21:34 <mauris_> is that going to be twice as slow as writing the 3-4 lines of explicit recursion, as opposed to looping over xs twice (in "take" and in "drop")?
17:21:54 <Zemyla> Yeah, it is. Sorry.
17:22:08 <c_wraith> it'll iterate over the first k elements of xs twice, but that will be less than twice the execution time
17:22:19 <mauris_> that's too bad :( even with -O3?
17:22:25 <c_wraith> there is no -O3
17:22:29 <c_wraith> The max is 2
17:24:18 <byorgey> mauris_: the compiler has lots of clever optimizations.  'take' and 'drop' might fuse with other list functions, whereas your explicit recursion might not.
17:24:39 <byorgey> mauris_: if I were you I would not worry about this at all, unless your program actually is too slow and you can prove that this is why.
17:24:49 <mauris_> yeah, i guess!
17:32:39 <Zemyla> c_wraith: I think the compiler has an optimized splitAt, too.
17:33:24 <c_wraith> That's the library more than the compiler, but yes.  splitAt avoids the double traversal.
17:38:43 <hodapp> grrr... I'm reading section 3.4.1 in https://www.haskell.org/haddock/doc/html/ch03s04.html and I have re-exported, but not completely, several modules, yet Haddock is still just inserting cross-references
17:40:10 <Jello_Raptor> is there an haskell analogue to __WEAK__? 
17:40:33 <arkeet> what is __WEAK__?
17:40:38 <hodapp> and if I put {-# OPTIONS_HADDOCK hide #-} in the module then it does not cross-reference...
17:41:03 <hpc> http://en.wikipedia.org/wiki/Weak_symbol
17:41:05 <Axman6> I believe GHC has a weak pointer type somewhere
17:41:10 <c_wraith> hodapp: try the argument something like not-home
17:41:11 <Axman6> if that's the same thing
17:41:25 <arkeet> it does https://hackage.haskell.org/package/base-4.8.0.0/docs/System-Mem-Weak.html
17:41:41 <c_wraith> hodapp: the one that tells haddock that the module defining something isn't the one to consider the home for documenting it
17:42:22 <hodapp> c_wraith: that doesn't do anything different
17:43:11 <hodapp> https://www.haskell.org/haddock/doc/html/ch03s04.html#idm140354810853776 GAH footnotes
17:44:05 <hodapp> so I could do it like https://github.com/ndmitchell/shake/blob/master/src/Development/Shake.hs does it I suppose...
17:47:12 <root> How can I determine if a files is text or not ?
17:50:54 <c_wraith> Guest80712: There's no good way, given how many different encodings there are for text.  EBCDIC encoding looks like binary data to everything that isn't aware of it, for instance.
17:51:14 <c_wraith> Guest80712: all you can do is apply heuristics
17:52:29 <Guest80712> c_wraith: what about assuming ascii and utf only ?
17:53:21 <arkeet> ascii is a subset of utf-8 so you can just test for utf-8 then.
17:53:26 <c_wraith> then look at the first few hundred bytes and see if they look like text in utf-8
17:54:07 <arkeet> there is a program called 'file' that tries to determine what kind of file a thing is (text/executable/other binary data)
17:54:16 <arkeet> which is probably a reasonable thing to use in general
17:54:21 <arkeet> (not haskell related)
18:18:12 <JagaJaga> I'm using lenses. After using ^. I'm getting a list of results. Is there a way to map over that list with next lens? Like `a ^.b(?)b` And result is going to be [[MyType]].
18:19:04 <c_wraith> JagaJaga: in general, you compose the lenses *before* using ^.
18:19:36 <c_wraith> JagaJaga: also, if you want to be getting a list of things out, you'd use ^.. instead of ^.
18:20:25 <Axman6> well, depends on the lens, it might be a lens focussing on a list
18:20:41 <c_wraith> in which case you'd compose it with traverse
18:21:14 <c_wraith> traverse is the magical lens that people don't even know they're implementing! :)
18:26:30 <JagaJaga> c_wraith: what should I know about "traverse"?
18:27:05 <JagaJaga> Well, one lens gives me a list, and the other one can only use item of that list
18:27:17 <c_wraith> JagaJaga: then traverse is exactly what you need.
18:27:23 <c_wraith> :t traverse
18:27:24 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
18:28:40 <c_wraith> When used as a lens, it focuses on all elements of a structure
18:29:28 <c_wraith> Well, technically, that's when used as a traversal.  traversals are a modification of lenses that can have multiple targets
18:29:32 <JagaJaga> c_wraith: oh! seems to be what I need
18:29:48 <JagaJaga> So I use it as `a ^..b.traverse.c`?
18:30:05 <c_wraith> JagaJaga: well, that'd be my guess. :)
18:30:08 <bananagram> :t traverse_
18:30:09 <lambdabot>     Not in scope: ‘traverse_’
18:30:09 <lambdabot>     Perhaps you meant one of these:
18:30:09 <lambdabot>       ‘F.traverse_’ (imported from Data.Foldable),
18:30:19 <JagaJaga> c_wraith: that works :)
18:30:51 <JagaJaga> c_wraith: can you explain me this thing? I mean traversable in general. Can't get it `kernel idea` :)
18:30:54 <KaneTW> :t F.traverse_
18:30:55 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
18:31:27 <c_wraith> JagaJaga: traverse is the main point of the Traversable class.  It came out of a paper called The Essence Of The Iterator Pattern
18:32:05 <JagaJaga> c_wraith: gonna read it, thank you.
18:32:06 <c_wraith> JagaJaga: The Traversable and Foldable classes both came out of that paper, actually.
18:34:27 <JagaJaga> Oh! one more question of how to use lenses. Is there a way to filter structure by them? I have lens name. Using it like `a^..b.traverse.name` and return in result only if (name == "foo")? 
18:34:54 <c_wraith> Now you're beyond my knowledge. :)
18:35:24 <JagaJaga> c_wraith: I hope that lenses can do anything :D
18:36:00 <c_wraith> there's a whole #haskell-lens channel for getting into deeper details.  You might check it out.
18:36:21 <JagaJaga> c_wraith: oh! thx.
18:37:18 <enthropy> > ["bar","foo"] ^? traverse . filtered (== "foo")
18:37:20 <lambdabot>  Just "foo"
18:39:28 <JagaJaga> enthropy: awwwww, thank you!
19:54:23 <hnfmr> hi, is it possible to keep TemplateHaskell generated file when compiling a program?
19:54:43 <adu> oh, like gcc -E?
19:54:56 <hnfmr> e.g. Database.Persist generates files for schema I guess?
19:55:06 <pacak> hnfmr: -ddump-splices?
19:55:22 <adu> hnfmr: my first guess would be ghc -E, but I don't know
19:55:23 <pacak> There's something to dump that into files AFAIR...
19:55:41 <dmwit> ?hackage zeroth
19:55:41 <lambdabot> http://hackage.haskell.org/package/zeroth
19:57:28 <hnfmr> adu: it says "--make" doesn't work with "-E"
19:57:46 <adu> hnfmr: hmm
19:58:40 <hnfmr> packa: -ddump-splices kind of worked, but I need to study the huge amount of output :)
19:58:51 <hnfmr> pacak: sorry misspelt name
19:59:14 <pacak> hnfmr: -ddump-to-files maybe?
19:59:23 <pacak> hnfmr: -ddump-to-file maybe?
20:24:31 <hnfmr> anyone familiar with digestive-functors?
20:25:18 <dmwit> ?where justask
20:25:18 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
20:25:26 <hnfmr> i have been digging for a day, without any answers, I will try my luck here. Here is my question posted on Stackoverflow
20:25:27 <hnfmr> http://stackoverflow.com/questions/29519507/how-can-i-parse-custom-type-in-a-digestive-functors-form
20:25:51 <hnfmr> ok :)
20:27:28 <dmwit> Presumably you would just (CountryKey . SqlBackendKey) <$> stringRead "blah" Nothing
20:28:57 <dmwit> Heck, it might even work to spell that as toSqlKey instead.
20:29:07 <dmwit> toSqlKey <$> stringRead "blah" Nothing
20:30:35 <hnfmr> dmwit: right, thanks! I will to fit it into the clientForm function
20:32:34 <hnfmr> dmwit: worked, I will then study the function signatures...Thanks
20:34:21 <dmwit> hnfmr: By the way, my ?hackage query an hour ago or so was also aimed at you.
20:34:28 <dmwit> Dunno whether you realized that.
20:34:47 <dmwit> half an hour
20:36:04 <hnfmr> dmwit: the zeroth package, that's gonna be helpful also, Thanks!
20:42:21 * hackagebot ekg-statsd 0.2.0.2 - Push metrics to statsd  http://hackage.haskell.org/package/ekg-statsd-0.2.0.2 (JohanTibell)
20:44:26 <johnw> benzrf: ping
20:44:32 <benzrf> johnw: pong
20:44:44 <johnw> https://github.com/jwiegley/notes/blob/master/PipesFreeT.hs
20:44:50 <johnw> you like that sort of thing :)
20:45:05 <benzrf> =o
20:45:39 <benzrf> ah, this reminds me of that one time i glued together half of a Proxy purely from Compose and Free and stuff w/o writing any instances
20:45:43 <benzrf> it was gross as hell
20:45:55 <benzrf> ...bUT COOL
20:45:56 <johnw> so, I'm doing this as groundwork for transporting the problem into Coq
20:46:14 <johnw> was wondering if you wanted to take a crack at the eq. reasoning proofs I marked as TODO
20:46:21 <johnw> since I can't do those in Coq
20:46:30 <benzrf> hmm
20:47:13 <benzrf> heuh
20:47:16 <benzrf> johnw: why cant you?
20:47:20 <johnw> of course I can
20:47:28 <johnw> i'm crowd-sourcing :)
20:47:41 <benzrf> then why did you say you couldnt ¬_¬
20:47:50 <johnw> oh, I can't do them in _Coq_
20:47:57 <benzrf> yeah, why not
20:47:58 <johnw> if I could, I wouldn't need a different representation
20:48:01 <johnw> they aren't strictly positive
20:48:06 <benzrf> oh hm
20:48:13 <johnw> so, I'm doing this piece-wise
20:48:15 <benzrf> could you do something coinductive?
20:48:35 <johnw> Proxy -> Free+FreeT+ProxyF -> Free_over_Container_type+FreeToCt+ProxyF_Container
20:48:58 <johnw> so long as I can show isomorphisms along the way, then I'll be able to work on some proofs that should transport back to the real Proxy type
20:49:13 <benzrf> wait, hold on
20:49:15 <benzrf> oh, i see
20:49:29 <benzrf> you mean pipes Proxy doesnt fit in coq
20:49:33 <johnw> yep
20:49:37 <johnw> nor does Free
20:49:41 <benzrf> interesting
20:51:59 <benzrf> hmmmm
20:52:06 <benzrf> is there a resource on type polarity
20:52:13 <benzrf> ive been unable to find anything about it :|
20:52:22 <johnw> what is it?
20:52:27 <benzrf> er maybe thats the wrong term
20:52:30 <benzrf> positive vs. negative occurrence
20:52:34 <benzrf> variance, sorry
20:53:21 <johnw> ah, I haven't found a  good resource
20:53:24 <benzrf> ;-;
20:53:25 <johnw> let me know if you do
20:53:32 <benzrf> tfw folklore
20:57:00 <benzrf> hmm
20:57:21 * hackagebot extensible 0.3.3 - Extensible, efficient, lens-friendly data types  http://hackage.haskell.org/package/extensible-0.3.3 (FumiakiKinoshita)
20:57:56 <benzrf> remind me why free isnt allowed in coq again?
20:58:29 <johnw> not strictly positive
20:58:35 <benzrf> yeah but why is that inconsistent
20:58:36 <johnw> f (Free f a) -> Free f a
20:58:52 <johnw> if f itself is strictly positive, there's no reason it should be inconsistent
20:59:03 <johnw> but Coq can't tell which f you're going to use in future
20:59:07 <benzrf> err
20:59:15 <benzrf> what does strictly positive mean, then
20:59:21 <benzrf> i thought it was about argument pos?
21:01:30 <johnw> you know, that's a good question
21:01:37 <johnw> since Free f a -> Free f a works fine
21:01:37 <benzrf> lol
21:01:42 <johnw> as does (Free f a -> a) -> Free f a
21:01:57 <benzrf> i believe variance flops for each arrow
21:01:58 <johnw> but (Free f a -> Free f a) -> Free f a does not work
21:06:21 <benzrf> johnw: this works:
21:06:23 <benzrf> Inductive Proxy_ (a' a b' b r : Type) : Type :=
21:06:25 <benzrf> | Request : a' -> (a -> Proxy_ a' a b' b r) -> Proxy_ a' a b' b r
21:06:27 <benzrf> | Respond : b -> (b' -> Proxy_ a' a b' b r) -> Proxy_ a' a b' b r
21:06:29 <benzrf> | Pure : r -> Proxy_ a' a b' b r.
21:06:33 <benzrf> johnw: it's the part where you make it a transformer that blows up
21:06:36 <benzrf> or i'd assume
21:07:02 <johnw> yep
21:08:48 <johnw> an effectless Pipes is equally well represented as just a list
21:08:58 <johnw> or at least,  a tuple of a list and a result
21:09:07 <benzrf> :I
21:09:17 <benzrf> johnw: well, no
21:09:19 <benzrf> it needs to consume inputs
21:09:36 <johnw> how do you consume without effects?
21:09:42 <benzrf> ...functionns
21:09:42 <johnw> other than folding over an input structure?
21:09:46 <johnw> well, ok
21:09:56 <johnw> then a Cont representation of a list, which is isomorphic to a list :)
21:10:04 <benzrf> pfft, whatevs
21:10:09 <johnw> that's what simple-conduit over Identity becomes
21:10:13 <benzrf> well, yeah
21:10:24 <benzrf> simple-conduit is flow-control-reversed pipes
21:10:26 <benzrf> p much
21:19:00 <johnw> yeah, mostly just that
21:38:34 <cschneid> is there an easy way to go from Ordering to Bool (equal or not)
21:38:38 <cschneid> I have `comparing fn x y`, but just need a yes/no
21:39:12 <johnw> == EQ?
21:39:20 <arkeet> ^
21:39:38 <arkeet> ((==) `on` fn) x y
21:47:24 * hackagebot dataflow 0.3.2.0 - Generate Graphviz documents from a Haskell representation.  http://hackage.haskell.org/package/dataflow-0.3.2.0 (owickstrom)
21:57:32 <Halfwit> What is the beginner channel # again?
21:58:21 <johnw> #haskell-beginners
21:58:50 <shachaf> #haskell is the beginner channel.
22:02:29 <johnw> #haskell is the all levels channel, -beginners has a more specific focus
22:03:17 <arkeet> #haskell-beginners 
22:03:35 <arkeet> but you're already there.
22:03:43 <arkeet> and I can't read.
22:54:04 <petercommand> how does the "let"s in do notations desugars?
22:55:07 <kadoban> petercommand: Just  'let blah = whatever in <rest of lines>' I believe.
22:55:37 <heatsink> do {let x = E; SS} ==> let x = E in do SS
22:56:49 <petercommand> how about do {A; B; let x = E; C; }?
22:57:51 <jle`> A >> B >> let x = E in C
22:57:53 <kadoban> petercommand: A >> B >> let x = E in C   ?
22:58:02 <petercommand> oh...
22:58:05 <petercommand> I got it
22:58:13 <petercommand> thanks guys
22:58:15 <jle`> it's basically giving an alias that is scope for the rest of the block
22:58:16 <ion> do {A; B; let { x = E }; C; } that is
22:58:22 <kadoban> Sure
22:58:26 <jle`> "every time you see x, replace with E"
22:58:46 <petercommand> yeah, bindings is like that
22:59:04 <petercommand> are
23:09:31 <sabalaba> I'm topkeking lainradio right now
23:11:30 <sabalaba> Sorry, wrong channel on previous comment. Has anybody here successfully installed Accelerate on Ubuntu with CUDA 6.5? I seem to be stuck in dependency hell. If I need to install an earlier version of cuda, that's fine too.
23:19:52 <muyfine> trying to refactor some code working with a IO (Maybe a) type
23:19:59 <muyfine> http://lpaste.net/836105080263409664
23:21:03 <muyfine> is there a better way to iterate here without explicitly unpacking the Maybe?
23:22:51 <kadoban> :t forM_
23:22:52 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
23:23:02 <kadoban> :t forM_ `asAppliedTo` (Just 5)
23:23:03 <lambdabot> (Monad m, Num a) => Maybe a -> (a -> m b) -> m ()
23:23:10 <kadoban> muyfine: Those seem usable?
23:23:51 <solatis> is there any way to search reverse dependencies ? as in, i want to find all packages that depend upon 'network-bitcoin', to see code samples
23:24:04 <muyfine> kadoban: thanks - looking!
23:24:05 <ion> @google hackage reverse dependencies
23:24:07 <lambdabot> http://packdeps.haskellers.com/reverse
23:24:07 <lambdabot> Title: Reverse Dependencies
23:24:34 <pacak> :t asAppliedTo
23:24:35 <lambdabot> (a -> b) -> a -> a -> b
23:24:50 <solatis> ion, awesome
23:24:57 <pacak> :info asAppliedTo
23:25:05 <solatis> except the package i'm looking for isnt there :)
23:25:14 * pacak pokes lambdabot
23:25:30 <mauke> there is no :info command
23:25:36 <ion> Nothing depends on it then.
23:25:55 <pacak> Oh noes! No :info command! Panic!
23:26:05 <ion> @src asAppliedTo
23:26:05 <lambdabot> Source not found. Whoa.
23:26:08 <kadoban> muyfine: I can explain more if that wasn't clear, heh. Which is quite possible.
23:26:40 <ion> pacak: asTypeIn :: a -> (a -> b) -> a ; a `asTypeIn` f = a where { _ = f a } ; infixl 0 `asTypeIn` ; asAppliedTo :: (a -> b) -> a -> a -> b ; f `asAppliedTo` x = f `asTypeIn` ($ x) ; infixl 0 `asAppliedTo`
23:26:57 <pacak> ion: What package is it from?
23:27:09 <ion> lambdabot defines it.
23:27:29 <pacak> o_O
23:27:45 <pacak> Magic.
23:29:07 <kenta_> Is the canonical way to convert a strict ByteString into a Lazy ByteString the following: Lazy.fromChunks [x] ? 
23:29:32 <ion> kenta: Lazy.fromStrict
23:30:45 <muyfine> @kadoban I follow forM_ - but not what `asAppliedTo` is showing there - wrt merging the Maybe Monad and the IO Monad
23:30:45 <lambdabot> Unknown command, try @list
23:31:08 <ion> It’s not using the Maybe monad.
23:33:02 <ion> forM_ Nothing _ = return (); forM_ (Just x) f = f x >> return ()
23:34:02 <ion> With asAppliedTo it just shows the type of forM_ when applied to a Maybe value.
23:34:11 <ion> the specialized, less polymorphic type
23:35:21 <muyfine> ion:  got it - so I should be able to do something like? http://lpaste.net/3452001855884754944
23:35:37 <ion> yeah
23:36:08 <muyfine> hmm, that's giving me a - Couldn't match expected type ‘[a0]’ with actual type ‘Maybe Msg’
23:37:03 <ion> You seem to have a GHC version older than 7.10.1. You’ll need to use the forM_ in Data.Foldable instead of the one in Control.Monad.
23:37:11 <ion> or upgrade
23:37:26 <muyfine> oh yeah of course - should have caught that
23:37:36 <muyfine> let me try with the forM_ out of Data.Foldable
23:37:53 <kadoban> muyfine: Oh, sorry. `asAppliedTo` is just lambdabot thing, it just makes the type more specific. I was using it to show that Maybe is a Foldable, so you can use forM_ with it.
23:40:01 <muyfine> beauty! thanks kadoban and ion - worked great!
23:40:34 <kadoban> Nice
