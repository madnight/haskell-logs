00:01:04 <narendraj9> Mishac: Which exercise are you on?
00:01:13 <Mishac> HW 5
00:01:19 <Mishac> Ex 4
00:01:26 <Mishac> it is where you have to define a typeclasses
00:01:49 <Mishac> I am just having a difficulty understanding and thought that someone who finished it could clarify
00:02:18 <Mishac> It is where you write your own calculator
00:49:56 <Mishac> Hi guys, is there anyone who completed cis194 course?
00:50:01 <Mishac> I mean did the exercises?
00:54:22 <frerich> Mishac: A couple, yes.
00:54:48 <Mishac> did you finish HW #5?
00:55:12 <frerich> Mishac: What was #5 again?
00:55:24 <Mishac> you have to write a caculator
00:55:31 <Mishac> the parser for string expressions is provided
00:55:41 <Mishac> you have to implement a typeclass
00:55:42 <frerich> Mishac: Sounds familiar, yes. You're stuck?
00:55:45 <Mishac> yep
00:55:49 <Mishac> i just dont understand
00:55:53 <Mishac> a few things
00:56:04 <frerich> Mishac: What have you tried so far, do you have some code to upload at lpaste.net to look at?
00:56:23 <Mishac> doing it now, 1 sec please
00:57:11 <Mishac> this is the link
00:57:12 <Mishac> http://lpaste.net/130898
00:57:50 <Mishac> http://www.seas.upenn.edu/~cis194/fall14/spring13/hw/05-type-classes.pdf
00:58:25 <Mishac> this is the link to the course, it probably would be easier to link it than post walls of text
00:58:56 <Mishac> so what I am trying to understand, is: a) are you suppose to modify the parser file that was provided
00:58:57 <frerich> Mishac: Sure. What are the things you don't understand?
00:59:09 <Mishac> in exercise 4 you have write a typeclass
00:59:17 <Mishac> for bool, minmax and other
00:59:25 <Mishac> but the way i understand the problem
00:59:35 <Mishac> is the input is string expression
00:59:48 <Mishac> with numbers plus and minus and so on
00:59:59 <Mishac> ie " 2 + 3*4
01:00:32 <frerich> Mishac: I see no reason to modify the provided parser file, no. The first part of the exercise is to create a typeclass with three methods, mirroring the three data constructors of Expr.
01:00:51 <Mishac> yep, i think i got that part
01:01:11 <Mishac> so then, I understand you have to create a new typeclass that would have values
01:01:35 <Mishac> lit Bool, add Or, mul and - right
01:02:02 <frerich> Mishac: I think you're right on track with that ExprT class you created, except that it needs two more methods.
01:02:14 <Mishac> add and mult
01:02:30 <Mishac> yep I tried expressing them as ExpT but compiler does not accept so it makes me think that
01:02:44 <Mishac> i am either missing something or
01:03:01 <Mishac> you can just define them outside typeclass, like I did
01:03:36 <frerich> Mishac: When you wrote that 'the compiler does not accept', can you should the code you tried and the error message given by the compiler?
01:04:04 <Mishac> what i did before is
01:04:10 <Mishac> i added
01:04:26 <Mishac> mul, add :: e -> e -> e 
01:04:26 <Mishac>     mul :: e -> e -> e
01:05:03 <Mishac> and make ExprT as typeclass instance
01:05:14 <Mishac> just like it is in the curly braces
01:05:22 <Mishac> but i dont think that was the right way
01:05:37 <Mishac> because later you need to create other typeclasses besides Integer
01:05:51 <Mishac> so the next step was to use this, 1 sec sending link
01:06:36 <Mishac> class Expr e where 
01:06:36 <Mishac>     lit :: e -> ExprT 
01:06:37 <Mishac>     add, mul :: ExprT -> ExprT -> ExprT
01:06:49 <Mishac> I hope I did not lose you
01:07:31 <Mishac> but the add, mul compiler rejects it, because they are inside of a typeclass, but they dont have value e in them, so I moved it outside the typeclass definition
01:08:50 <frerich> Mishac: Nope, I'm fine. However, using 'ExprT' defeats the purpose a bit. The idea is that instead of having a single data type 'ExprT' which hardcodes Integers as the type of the values (and then having a single 'eval' funciton evaluating 'ExprT' values), you rather define a type class which abstracts away the type of the values and how to add/multiply them.
01:09:11 <Mishac> I see
01:09:38 <Mishac> if I understand correctly
01:09:46 <frerich> Mishac: I.e. you will later instantiate that 'Expr' class for the existing ExprT type -- but that's not the only instantiation. Hence, using 'ExprT' in the declaration of Expr is probably not a good direction.
01:10:32 <Mishac> so i need to figure out how to use other values to declare the typeclass signature for add and mul
01:10:40 <Mishac> and then implement the instance of them
01:11:23 <frerich> Mishac: Note that the type of the expression 'mul (add (lit 2) (lit 3)) (lit 4)' should not be 'ExprT' but 'Expr a => a', i.e. 'mul' cannot possibly yield an ExprT.
01:12:23 <Mishac> can you paraphrase the last part
01:12:33 <Mishac> 'mul' cannot possibly yield an ExprT
01:12:44 <Mishac> i think i understand what you mean
01:13:49 <frerich> Mishac: In the type of 'mul', you cannot hardcode 'ExprT', i.e. 'ExprT -> ExprT -> ExprT' cannot be correct. It needs to be something more generic. Otherwise, 'mul .. ... ' will always have the type 'ExprT'.
01:14:02 <Mishac> I see, yep
01:14:19 <Mishac> that was my original guess
01:14:46 <frerich> Mishac: Yep, I think your original guess was right on track - I think it's worth revisiting that compiler error to see why it barfed.
01:15:04 <Mishac> oh, compiler did not work because I used ExpT in the typeclass declaration
01:15:31 <Mishac> I just did not realize at that momet that I have abstract away from ExpT type and make it more generic
01:16:25 <Mishac> am I correct?
01:17:35 <frerich> Mishac: Yes. Note how the type of 'Mul' (the data constructor) is 'ExprT -> ExprT -> ExprT'. Generalizing this such that ExprT is no longer hardcoded gets you 'Expr e => e -> e -> e'
01:18:20 <frerich> I.e. your generalized 'mul' function must be of just that type: a member of the 'Expr' class, taking two 'e's and yielding a new 'e'.
01:18:59 <Mishac> so in other words this was the correct approach? http://lpaste.net/130899
01:19:38 <Mishac> sorry if I am double asking, just want to make sure i am on the same page with you
01:19:46 <frerich> Mishac: I think that looks just fine. I just realized that when I talked about 'Integer', I was getting ahead of myself (abstracting away the 'Integer' is the task of the next exercise, #4).
01:20:35 <Mishac> ok
01:20:45 <Mishac> so i think I was wrong first time and sorta right second time
01:20:57 <Mishac> you are abstracting away from the Integer
01:21:20 <Mishac> and ExpT?
01:22:28 <frerich> Not sure I understand. For Exercise #3, staying with 'Integer' is just fine. AFAICS you have all the pieces at hand now to make 'reify $ mul (add (lit 2) (lit 3)) (lit 4)' yield 'Mul (Add (Lit 2) (Lit 3)) (Lit 4)'
01:23:08 <Mishac> yep
01:23:16 <Mishac> Exercise 3 is working just fine
01:23:33 <Mishac> with only lit inside typeclass declaration
01:23:34 <frerich> Mishac: A good moment to have a glass of red wine!
01:23:47 <Mishac> haha, I do not drink,
01:24:02 <Mishac> there is just something that does not make sense entirel
01:24:03 <Mishac> y
01:24:29 <Mishac> the data declaration use Lit as (Intger -> Lit Integer)
01:25:25 <frerich> Mishac: I think having only 'lit' in the typeclass does not sound right. You need to have a class with three methods (that was also mentioned because it's a prerequisite for exercise #4). If I understood you correctly, you now have a global 'mul :: Expr e => e -> e -> e' ?
01:25:35 <frerich> Mishac: ...and same for 'add'?
01:26:00 <Mishac> Lets step back,
01:26:11 <Mishac> the first time I did the exercise,
01:26:27 <frerich> Mishac: I gotta run now, but the issue with just having 'lit' in the class is that 'lit' is the only thing of which you know that you can apply it to values of type 'Expr e => e', i.e. it's the only thing you can use in a global 'mul' definition.
01:26:41 <frerich> You'll have to move mul and add into a class, too.
01:26:54 * frerich afk
01:26:55 <Mishac> so it means that i have to abstract away from both integer and ExpT?
01:27:08 <Mishac> by the wya, dont want to detain you for too much,
01:27:12 <Mishac> thank you for your time
01:27:25 <Mishac> It has helped me to clarify some ambiguities
01:34:48 <mniip> how often are hackage haddocks regenerated nowdays
01:34:58 <quchen> … not?
01:35:12 <mniip> hm?
01:35:19 <quchen> I don't think Hackage generates docs right now, or at least it takes so much time I upload my own
01:35:25 <mniip> I've read that they're auto-generated once a while?
01:35:47 <mniip> how do you upload your own?
01:36:31 <quchen> I have a (small hacky) script by Fuuzetsu that automates the process, hold on.
01:36:36 <lisbeth> What is wrong with this function? let powerme x y = if y == 0 then x else x = x * (powerme x (y - 1))
01:36:42 <lisbeth> when trying to determine the powers of numbers
01:37:00 <lisbeth> Can't get it to compile
01:37:03 <Cale> lisbeth: usually x^0 = 1
01:37:04 <Cale> oh
01:37:16 <Cale> "else x = x * ..."
01:37:16 <lisbeth> I have not mastered it yet
01:37:26 <Cale> is not syntactically correct
01:37:30 <quchen> mniip: http://lpaste.net/130901
01:37:32 <Cale> what is that = sign doing there?
01:37:41 <lisbeth> OH I see what you mean
01:38:19 <mniip> quchen, does that just include the docs in sdist?
01:40:10 <quchen> mniip: ?
01:40:14 <Cale> http://cale.yi.org/jsexe/boardtest/source.jsexe/ -- Not much of a game yet, but there's one piece and you can attach upgrades to it. :)  This is written in Haskell using the diagrams library and reflex-dom, and compiled to Javascript by ghcjs.
01:40:50 <Fuuzetsu> I wish yi.org was used by Yi editor ;(
01:41:00 <Cale> It could be
01:41:06 <quchen> mniip: It takes your HTML docs and makes them appear on Hackage.
01:41:07 <Cale> It's a free subdomain provider
01:41:19 <Fuuzetsu> I mean top level domain
01:41:31 <mniip> quchen, yeah but on the insude, it does what
01:42:29 <quchen> It configures your build, builds it, builds the docs, targz-s the docs, logs in on Hackage, puts the docs there.
01:42:42 <mniip> Fuuzetsu, I take it, the script linked above is yours?
01:43:23 <Fuuzetsu> sure though I think it's less popular than it was before
01:43:42 <Fuuzetsu> I think there is a better one in lens somewhere
01:46:35 <mniip> Fuuzetsu, where does it place the docs?
01:47:16 <Fuuzetsu> in ./dist somewhere
01:47:48 <mniip> yeah but in the tarball where are they
01:48:05 <Fuuzetsu> ?
01:48:13 <lisbeth> Why can't I make the function multiply' = (*)
01:48:13 <lisbeth> ?
01:48:33 <Fuuzetsu> lisbeth: what makes you say that you can't?
01:48:43 <lisbeth> > let multiply = (*)
01:48:44 <lambdabot>  <no location info>: not an expression: ‘let multiply = (*)’
01:48:47 <Fuuzetsu> > let multiply' = (*) in multiply' 1 2
01:48:48 <lambdabot>  2
01:49:15 <mniip> Fuuzetsu, you upload sdist tarballs to hackage right
01:49:21 <mniip> so the docs have to be somewhere in there
01:49:25 <lisbeth> Mine doesn't work.
01:49:37 <Fuuzetsu> no, the docs are separate to sdist tarball
01:49:49 <mniip> huh
01:49:51 <Fuuzetsu> lisbeth: your is not an expression, it tells you that
01:50:15 <lisbeth> :l (*)
01:50:21 <lisbeth> >:l (*)
01:50:31 <mniip> oh
01:50:34 <Fuuzetsu> mniip: look at the linked script
01:50:43 <Fuuzetsu> it calls cabal haddock, tars the result and uploads it to Hackage
01:51:11 <Fuuzetsu> lisbeth: what do you expect :l to do?
01:51:20 <lisbeth> Not sure.
01:51:24 <Fuuzetsu> lambdabot is not like GHCi to begin with
01:54:53 * hackagebot type-list 0.1.0.0 - Operations on type-level lists and tuples.  http://hackage.haskell.org/package/type-list-0.1.0.0 (mjmrotek)
01:59:22 <Gurkenglas> In what situation would Store s a (meaning (s -> a, a)) be more useful than (s, a)? (Does the second version duplicate the thunks or something?)
02:00:40 <chaosmasttter> Store s a is something different than (s, a), you cannot convert one into the other
02:01:07 <kqr> how can I tell what version of a package I have installed?
02:01:11 <kqr> (in this case I'm curious about base)
02:01:32 <Gurkenglas> Umm sorry I mean Store s a means (s -> a, s)
02:02:05 <Gurkenglas> And you mean that one could use it in situations where you might acquire a different s to produce a different a? Hmm, okay.
02:02:06 <chaosmasttter> oh, than forget what i said
02:02:55 <Cale> kqr: ghc-pkg list base
02:03:12 <Cale> kqr: or leave off the 'base' for a list of all packages
02:03:14 <kqr> Cale, cheers
02:03:24 <kqr> that's exactly what I was looking for :)
02:03:43 <chaosmasttter> well Store s a can contain many 'a's (one for each s), but (s, a) only contains one 'a'
02:08:30 <hunteriam> do any high quality windows tools exist for Haskell?
02:08:40 <hunteriam> id think they would since Microsoft research is so amazing
02:08:43 <ragnaros> Hi all, just wondering why I get an error when I do [LT..GT] but no issues when I do [LT ..GT] (i.e. a space after LT). The error I'm getting in ghci is: <interactive>:86:2: Not in scope: ‘LT..’  <interactive>:86:2: A section must be enclosed in parentheses thus: (LT.. GT)
02:10:21 <mniip> ragnaros, LT.. is a valid identifier name
02:10:39 <mniip> operator '.' in package imported as, or named 'LT'
02:10:57 <Cale> It would be kind of nice if it didn't *look* for an operator section there, seeing as it's syntactically invalid anyway
02:11:14 <Cale> s/package/module/ :)
02:11:25 <mniip> I'm not sure whether report allows that kind of behavior
02:16:39 <ragnaros> hmm, I think I need a simpler explanation - I'm a complete noob :)
02:20:14 <Cale> ragnaros: It's just an awkward ambiguity in the parser
02:20:33 <Cale> ragnaros: You're allowed to name an infix operator (.) (after all, composition is named this)
02:21:13 <Cale> ragnaros: and when you qualify an infix operator with a module name, you use  ModuleName.&*$ 
02:21:29 <ragnaros> Cale: ah, gotcha
02:32:49 <Myrl-chan> Good afternoon.
02:33:19 <Myrl-chan> Is there a point-free way to write `f x = g x (tail x)`
02:33:38 <Myrl-chan> Or that would be the cleanest way to do it?
02:35:58 <pavonia> :t ap tail
02:35:59 <lambdabot>     Couldn't match type ‘[a1]’ with ‘a -> b’
02:35:59 <lambdabot>     Expected type: [a1] -> a -> b
02:35:59 <lambdabot>       Actual type: [a1] -> [a1]
02:36:19 <chaosmasttter> Myrl-chan: f = g <*> tail
02:36:34 <chaosmasttter> oh wait thats wrong
02:36:50 <Myrl-chan> Or at least a better way to write, doesn't necessarily have to be point-free.
02:36:50 <chaosmasttter> f = flip g <*> tail
02:37:49 <Myrl-chan> chaosmasttter: Cool.
02:37:52 <Myrl-chan> chaosmasttter: Thanks.
02:37:53 <pavonia> :t \g -> ap g tail  -- That's what I meant
02:37:54 <lambdabot> ([a] -> [a] -> b) -> [a] -> b
02:38:43 <pavonia> which is "flip ap tail"
02:39:02 <chaosmasttter> :t g -> ap g head
02:39:03 <lambdabot>     Pattern syntax in expression context: g -> ap g head
02:39:07 <chaosmasttter> :t \g -> ap g head
02:39:08 <lambdabot> ([a] -> a -> b) -> [a] -> b
02:39:52 <chaosmasttter> Myrl-chan: oops, my first version was correct
02:40:34 <Myrl-chan> chaosmasttter: Ah. Thanks.
02:44:15 <Myrl-chan> chaosmasttter: Is it fine if I ask for an explanation? I don't quite understand.
02:44:40 <Myrl-chan> I have very basic understanding of monads and basically no understanding of applicatives.
02:51:37 <chaosmasttter> well the used applicative is (-> r) (the Reader type)
02:51:54 * mniip mumbles something about ((->) r)
02:52:10 <chaosmasttter> oh right
02:53:07 <chaosmasttter> and f <*> x = \ r -> f r (x r)
02:53:55 <chaosmasttter> (<*>) :: (r -> a -> b) -> (r -> a) -> (r -> b)
02:55:00 <Myrl-chan> Hmm...
02:55:29 <Myrl-chan> So if I apply zipWith...
02:57:16 <chaosmasttter> what do you mean by "apply zipWith"?
02:57:37 <Myrl-chan> I really have no idea.
02:57:39 <Myrl-chan> Lol.
02:58:23 <ion> Cale: Nice
02:58:58 <mniip> [12:55:42] <Myrl-chan> I really have no idea.
02:59:02 <mniip> you should figure typeclasses out
02:59:13 <mniip> the typeclasses, I mean
02:59:49 <Myrl-chan> mniip: Is there more to typeclasses than "instances of this typeclasses must have x functions"?
03:00:13 <ij> In do's let block, can I do any monadic magic or is it simply like a where clause?
03:03:11 <pavonia> ij: You can't run monadic actions there
03:03:22 <mniip> Myrl-chan, rules, intuition, laws, instances
03:04:29 <jle`> ij: it's basically like an alias
03:04:50 <jle`> `let x = blah; ...` is, "every time you see 'x', put 'blah' instead"
03:05:11 <mniip> well semantics are a tad bit different too
03:05:14 <ij> pavonia, So "state <- gets (splitAt 1)" and "let ((head:_), rest) = state" is ugly, but that's how it has to be?
03:05:39 <jle`> you can also pattern match at the binding too
03:05:45 <mniip> ij, it's better to say 'case state of'
03:06:10 <pavonia> ij: Not sure what you mean, those are different things
03:06:41 <jle`> ((head:_), rest) <- gets (splitAt 1) works, but yeah, you should probably be binding and then pattern matching
03:06:47 <pavonia> Maybe you want "((head:_), rest) <- gets (splitAt 1)"?
03:06:47 <jle`> *case switching
03:07:09 <ij> I'm very sorry, I really thought I'd tried that once and it didn't work. :/ 
03:07:23 <paxcoder> Does the existence of Control.Parallel mean there is no good theoretical basis for automatically parallelizing programs?
03:07:54 <jle`> do you mean by virtue of someone deciding to write it?
03:08:31 <paxcoder> jle`, are you talking to me?
03:08:34 <jle`> yeah
03:08:42 <jle`> i'm not sure what the causal connection is
03:08:46 <paxcoder> I mean by the sheer necessity.
03:09:00 <jle`> oh
03:09:10 <jle`> well, i wouldn't say it's a proof
03:09:17 <jle`> someone could write it and yet there still could be a theoretical basis
03:09:34 <paxcoder> I didn't say it was a proof :/
03:09:34 <jle`> i don't think it'd fly as evidence in a journal article or something
03:09:51 <jle`> i don't think it's evidence either way
03:10:01 <paxcoder> It's an indication. Hence the question.
03:10:10 <jle`> it could exist, and there could be a theoretical basis...or it could not exist, and there still be one
03:10:13 <mniip> does the existence of GHC.Prim mean there is no good monadic way to perform computations with side effects?
03:10:19 <paxcoder> jle`, troll in the dungeon
03:11:24 <paxcoder> Anyone care to address the question seriously?
03:11:53 <jle`> i'm sorry i'm not trying to troll, i really don't see how there can be a causal connection :|
03:12:00 <jle`> can you rephrase your question?
03:12:30 <paxcoder> I probably could, but it would be a waste of my time.
03:12:54 <jle`> "seeing that Control.Parallel exists, does that mean that I should assume that there is no good theoretical basis for automatically parallelizing programs?"
03:13:03 <jle`> in which case, i don't think that that's a good conclusion to make from that
03:13:13 <jle`> i'm really trying to figure out what you're asking, here :'(
03:13:39 <jle`> "does Control.Parallel exist indicate that there is no good theoretical basis..."
03:13:52 <jle`> in which case, I also think the answer is that you can't really make any meaningful conclusion from that
03:14:33 <paxcoder> *Hence the question.*
03:14:34 <jle`> this is really the only way i can interpret this question :'(  if i'm misinterpreting it then i'd be happy to answer it if you clarified
03:15:22 <jle`> what's the question?
03:15:29 <paxcoder> Sigh. Anyone else can jump in here with something constructive at any time. Anyone? Anyone at all?
03:16:03 <jle`> i'm not sure what "hence the question" is referring to.  which question?  the question that, if control.parallel existing implies that there is no theoretical basis for ...?
03:16:34 <jle`> but i just gave my answer :|
03:16:42 <paxcoder> I'm gonna have to default to "probably no theoretical basis". The probability just increased slightly since my question.
03:17:30 <ij> Maybe you mean that it hasn't been created yet?
03:19:07 <paxcoder> That's sad. FP advocates use the theoretical parallelism of all expressions, but it seems that, in reality, we need to create threads manually, like everyone else.
03:19:21 <paxcoder> *as an argument for FP
03:20:01 <jle`> i don't think that you can rul out automatic parallelizing of programs.  it's definitely within the realm of possibility of things we could do and implement
03:22:49 <jle`> ghc haskell just wasn't designed to be something that was meant for implicit automatic parallelization at all levels.  it made the choice to have things be explicit
03:23:26 <jle`> it was a design choice...not a theoretical fundamental one
03:23:51 <paxcoder> Sincerely, I'm not sure I trust you.
03:24:04 <paxcoder> Anyway, it might be that the problem is NP hard.
03:26:36 <jle`> you might not trust me, but you don't have to be so pessimistic :)  if you don't have any real evidence that it's impossible.
03:27:24 <jle`> (do you mean you don't believe my honest claims, or that you believe I am trying to deceive you?)
03:29:06 <MP2E> asking a loaded question, refusing to clarify, calling someone a troll who was pointing out the hole in the logic of the original question, then telling someone who answered that they are lying.
03:29:12 <MP2E> Yeah I don't see why anyone would want to help.
03:30:06 <paxcoder> The question was not as confusing as purported, and I clarified sufficiently to remove any doubt in my co-speakers inability to comprehend.
03:31:55 <paxcoder> *co-speaker's
03:32:06 <paxcoder> (one person)
03:34:25 <EvanR> theoretical parallelism of all expressions seems like a strawman
03:34:49 <EvanR> for the sake of performance we should do what is fastest which is usually not parallel so far
03:34:51 <paxcoder> I don't know, that's the impression I got from things I read.
03:34:56 <EvanR> not parallel for the sake of it
03:35:04 <paxcoder> And that's what I desire.
03:35:42 <paxcoder> In practice, it would not spawn a new thread for each expression, of course.
03:36:02 <EvanR> for you to get any performance gain at all you have to carefully place the parallelism
03:36:10 <EvanR> you cant even say, spawn a thread for half the expressions
03:36:30 <paxcoder> EvanR, I understand that.
03:39:26 <EvanR> at some point people will have to admit to the crapping out of moores law ;)
03:40:00 <statusfailed> EvanR: NEVERRR!!!! - Intel 
03:46:55 <ij> I wrote this: http://sprunge.us/hKDi I concluded that state is awful. 
03:48:42 <EvanR> ij: for a stateful loop, you can pass the new state to the worker directly and avoid a transformer
03:49:55 <ij> I'm passing environment, does that change anything?
03:50:26 <EvanR> if IO is involved you can also use a classic while loop that modifies an ambient IORef
03:50:34 <EvanR> while loop / forever loop
03:50:53 <ij> Again is RWS — thus RWST .. Identity, so no IO.
03:51:00 <EvanR> ij: well, that can be a second argument or just part of the state that isnt modified
03:51:46 <EvanR> if your "worker" is not doing IO, and youre processing some sequence, seems like a regular functional program might work better
03:53:11 <EvanR> ij: asks (splitAt 1), this is the kind of thing you usually see done with a function that pattern matches on a list, with two cases: empty list and x:xs
03:55:01 <EvanR> and if the big picture here is parsing a format string, then a parser might be better
04:02:08 <ij> Yeah, rewriting that without state monad is so much clearer.
04:03:50 <ij> Much better: http://sprunge.us/CCJO
04:05:02 <EvanR> using head as a variable is weird
04:05:06 <EvanR> :t head
04:05:07 <lambdabot> [a] -> a
04:05:12 <ij> I know, first would be better.
04:05:29 <EvanR> idiomatically, you have x:xs or y:ys or something
04:05:41 <paxcoder> herbstluftwm
04:05:42 <EvanR> your dont have a case for [], but you should, even if its an error
04:06:29 <EvanR> first is also a standard function
04:06:32 <ij> Oh, right. Then I could make it stop screaming about 'non-exhaustive patterns'.
04:06:38 <ij> Yeah, true. 
04:07:14 <CindyLinz> case ... of [] -> error "non-exhaustive patterns"
04:08:04 <ij> paxcoder, Yes?
04:10:19 <paxcoder> ij, nvm, didn't know it was a tiling wm
04:10:41 <paxcoder> thought you just mashed some keys
04:11:26 <ij> In german Herbst = fall, Luft = air. 
04:13:19 <zq> is there a way to chain an array of monads without resorting to arrows, a la [a -> m a] -> a -> m a ?
04:13:37 <ij> :t mapM
04:13:38 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
04:13:42 <zq> no
04:13:47 <sleepomeno1> if I have set "library-profiling: True" in my cabal config does that imply that the resulting executable might run slower because profiling is activated?
04:13:48 <zq> that's not it at all
04:14:15 <zq> :t join
04:14:16 <lambdabot> Monad m => m (m a) -> m a
04:14:32 <ij> What do you mean chain?
04:15:10 <jle`> zq: you mean a compose a list of monadic functions?
04:15:27 <zq> i think the path of least resistance is arrows
04:15:29 <zq> frick
04:15:32 <jle`> you can use foldr (>>=) maybe, depending on what you want
04:15:34 <jle`> :t foldr (>>=)
04:15:35 <lambdabot>     Occurs check: cannot construct the infinite type: b ~ a -> b
04:15:35 <lambdabot>     Expected type: (a -> a) -> (a -> b) -> a -> b
04:15:35 <lambdabot>       Actual type: (a -> a) -> (a -> a -> b) -> a -> b
04:15:39 <zq> jle`: it's not strict, though
04:15:41 <jle`> oh yea that doesn't work.
04:15:50 <jle`> Arrow isn't really the right abstraction here...Category is more fitting
04:16:07 <zq> s/arrow/kliesli composition/
04:16:27 <zq> categories are too general, i just want to think about monads
04:16:38 <jle`> you don't need anything Arrow here tho
04:16:44 <zq> then how?
04:16:47 <jle`> it's just (.) from Control.Category
04:16:52 <zq> :t (.)
04:16:53 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:16:59 <zq> alright hang on
04:17:02 <jle`> :t (Control.Category..)
04:17:03 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
04:17:06 <jle`> welp
04:17:20 <int-e> :t (foldr (>=>) return, flip (foldM (flip id)))
04:17:21 <lambdabot> (Monad m, Monad m1, Foldable t, Foldable t1) => (t (c -> m c) -> c -> m c, t1 (b -> m1 b) -> b -> m1 b)
04:17:28 <zq> what the heck is the box kind
04:17:39 <zq> :t (>=>)
04:17:40 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
04:17:42 <jle`> ignore the quantifier, heh. it's actually a sort
04:17:48 <jle`> :t foldr (>=>)
04:17:49 <lambdabot> (Monad m, Foldable t) => (b -> m c) -> t (b -> m b) -> b -> m c
04:18:00 <zq> yeah that's basically it
04:18:14 <zq> :t foldr (>=>) (return 3)
04:18:15 <lambdabot> (Monad m, Num (m c), Foldable t) => t (b -> m b) -> b -> m c
04:18:18 <jle`> (>=>) is `flip (.)`
04:18:53 <int-e> zq: no, 'return' is a Kleisli arrow.
04:18:56 <jle`> Arrow doesn't really add anything here. if you wanted to use the Kleisli type, all you need is Control.Category
04:19:13 <int-e> :t foldr (>=>) return 3
04:19:14 <zq> i'm trying my best not to learn category theory
04:19:14 <lambdabot> (Monad m, Num (t (c -> m c)), Foldable t) => c -> m c
04:19:33 <int-e> uhm.
04:19:37 <int-e> :t flip (foldr (>=>) return) 3
04:19:38 <lambdabot> (Monad m, Num c, Foldable t) => t (c -> m c) -> m c
04:19:42 <jle`> (>=>) is to (.) as map is to fmap
04:20:14 <zq> but is (Prelude..) a specialization of (Category..)?
04:20:20 <jle`> yes, technically
04:20:38 <jle`> you can think of it like an map/fmap kind of thing.
04:20:51 <jle`> it's not actually map = fmap.  it's a name written specifically for []
04:21:01 <int-e> jle`: but map is a particular case of fmap for the list monad; (.) is a particular case of (>=>) in the identity monad. I don't see the relation.
04:21:29 <jle`> there's a newtype wrapper here that i'm handwaving away
04:21:41 <jle`> if it wasn't for the newtype wrapper, (.) = (<=<) for Kleisli
04:21:52 <zq> what
04:21:54 <zq> so it's backwards?
04:21:55 <jle`> and (.) = (Prelude..) for normal functions
04:22:05 <fikusz> I've got into a friendly performance competition over the 14th project euler problem (collatz sequence) with a cpp guy, these are my different approaches in Haskell so far: https://gist.github.com/reaper-thresher/97c001d8f2ba2caa32af
04:22:12 <jle`> this is like saying, instance Functor [] where fmap = map
04:22:26 <jle`> instance Category (->) where (.) = (Prelude..)
04:22:47 <jle`> instance Category (Kleisli m) where (.) = (>=>)     -- sans newtype wrappers
04:22:54 <jle`> * (<=<)
04:23:01 <int-e> oh, *that* (.).
04:23:03 <int-e> :t (.)
04:23:04 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:23:14 <int-e> :t (Control.Category..)
04:23:15 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
04:23:21 <fikusz> runtime / total memory use is pretty good already: naive (1MB / 1s), parallel (4MB / 0.7s), imperative / caching (9MB, 0.17s)
04:23:37 <fikusz> just wanted to ask if someone has ideas how to make an even faster solution
04:23:38 <jle`> in any case going into a newtype wrapper and then using (.) and then going out might be a bit overkill here
04:23:42 <zq> so, why does ghc feel the urge to be explicit about the sort of k in the type of (.)? example of a non-box sort?
04:23:59 <int-e> jle`: every time you write (.) I'm assuming (Prelude..)
04:24:03 <jle`> it's from PolyKinds, which came in 7.8+
04:24:20 <jle`> int-e: no worries, i would too.  context was a bit fragile :)
04:24:25 <int-e> hence the confusion.
04:24:39 <jle`> my bad
04:25:10 <jle`> in any case, going into Kleisli and using (.) in this case would be like doing getSum (mconcat (map Sum [1,2,3])) instead of foldr (+) 0 [1,2,3]
04:25:33 <jle`> mconcat = foldr (+) 0 for the Sum monoid instance
04:25:40 <jle`> (sans newtype wrappers)
04:25:51 <jle`> so it's basically the same sort of thing here
04:26:49 <jle`> `runKleisli (foldr (C..) C.id (map Kliesli [f,g,h]))` vs. `foldr (<=<) return [f,g,h]`
04:27:04 <kuribas> pattern synonyms rock!  I used them in my code, and it's much cleaner now.
04:28:25 <ion> Can one make a pattern synonym work as a smart constructor as well? I should look up the documentation.
04:28:37 <fikusz> maybe I should've rather posted this on the project euler forums
04:31:20 <jle`> zq: so really, no category theory here.  we're just using a typeclass that abstracts over (Prelude..)/(<=<) and Prelude.id/return.  and it's like getSum (foldr mappend mempty) [1,2,3] instead of foldr (+) 0 [1,2,3].  runKleisli (foldr (.) id (map Kleisli [f,g,h]) instead of foldr (<=<) return [f,g,h]
04:31:58 <jle`> (using Control.Category.. and Control.Category.id)
04:33:52 <zq> :i Monoid
04:34:46 <zq> instance Monad m => Monoid (a -> m a) where { mempty = return; mappend = (>=>); }
04:34:50 <zq> is what you're saying
04:35:44 <zq> so why do we need category?
04:35:47 <zq> Category, that is
04:36:20 <zq> because Category has bunch of instances that aren't Monoids? is Category a strict superset of Monoid?
04:37:37 <Lis> hello everyone. what would be the best way to divite the n-1 element of a list with the n element.
04:38:23 <Lis> like i have [1,2,3,4] and want to do 1/2 then 2/3 then 3/4 ?
04:39:55 <zq> > (\xs -> zipWith (/) xs $ drop 1 xs) [1..4]  -- Lis
04:39:57 <lambdabot>  [0.5,0.6666666666666666,0.75]
04:40:10 <Lis> ty
04:46:37 <tulcod> does a foreign import ccall "wrapper" call allocate memory?
04:46:49 <tulcod> and if it does, how to properly free it?
04:48:31 <mniip> join $ zipWith (/) . drop
04:48:48 <mniip> er drop 1
04:48:56 <mniip> which is actually tail
04:49:25 <wakalabis> Hey, guys.. Can when declaring a foreign import what should I use to declare a C `size_t` type?
04:49:53 <wakalabis> I tried using CSize, but I get the following error: "Unacceptable argument type in foreign declaration: CSize"
04:50:07 <kuribas> mniip: safe tail :)
04:50:14 <kuribas> > tail []
04:50:15 <lambdabot>  *Exception: Prelude.tail: empty list
04:50:19 <kuribas> > drop 1 []
04:50:20 <lambdabot>  []
04:51:12 <EvanR> tulcod: its explained in the ffi docs
04:51:20 <tulcod> ah yes i just found it, apologies
04:51:41 <tulcod> for those interested: freeHaskellFunPtr frees the allocated memory
04:52:37 <kuribas> tulcod: see http://hackage.haskell.org/package/base-4.8.0.0/docs/Foreign-ForeignPtr.html#v:newForeignPtr
04:53:16 <kuribas> tulcod: you can let the garbage collector delete it.
04:53:54 <tulcod> kuribas: yes, i know about this infrastructure. i have to think about my particular situation though. thanks for the pointers ;)
04:54:01 <mniip> > zipWith (,) [] undefined
04:54:02 <lambdabot>  []
04:54:05 <mniip> kuribas, ^
04:55:13 <kuribas> mniip: yeah, tail would work too :)
04:55:19 <kuribas> :t join
04:55:20 <lambdabot> Monad m => m (m a) -> m a
04:55:43 <kuribas> :t join $ zipWith (/) . drop
04:55:44 <lambdabot>     Couldn't match type ‘[c]’ with ‘Int’
04:55:44 <lambdabot>     Expected type: Int -> Int -> [c]
04:55:44 <lambdabot>       Actual type: Int -> [c] -> [c]
04:55:51 <kuribas> :t join $ zipWith (/) . tail
04:55:52 <lambdabot> Fractional c => [c] -> [c]
04:56:51 <EvanR> just to clarify drop 1 is not the same as tail
05:00:32 <kuribas> Hm, does that join work on the function monad?
05:01:10 <kuribas> :t zipWith (/) . tail
05:01:11 <lambdabot> Fractional c => [c] -> [c] -> [c]
05:01:37 <mniip> > join (*) 5
05:01:39 <lambdabot>  25
05:01:48 <mniip> > join (++) "hello"
05:01:50 <lambdabot>  "hellohello"
05:09:55 * hackagebot hmidi 0.2.2.0 - Binding to the OS level MIDI services  http://hackage.haskell.org/package/hmidi-0.2.2.0 (BalazsKomuves)
05:11:13 <kuribas> Why do I get a syntax error when I specify a pattern signature?
05:11:30 <kuribas> I am using ghc 7.8.3
05:12:00 <mniip> kuribas, elaborate?
05:15:14 <kuribas> mniip: http://lpaste.net/130907
05:26:30 <pavonia> kuribas: What is the error message?
05:26:46 <kuribas> pavonia: syntax error
05:27:31 <pavonia> Only that?
05:28:35 <kuribas> parse error on input '..'...
05:29:01 <kuribas> ehm input '::'
05:29:08 <grpala> ...
05:29:19 <grpala> kuribas: you are making it reeeeaaaallly annoying to help you
05:29:21 <grpala> seriously
05:29:23 <grpala> get real
05:29:37 <mniip> what
05:29:37 <grpala> either paste the whole thing or take it to another place
05:31:18 <pavonia> Maybe type annotations are not supported there
05:32:55 <mmachenry> kuribas: Take TrigE out of your type signature.
05:33:04 <mmachenry> The first TrigE.
05:33:16 <kuribas> grpala: since you asked for it: http://lpaste.net/130907
05:33:50 <kuribas> MFSolve.hs:152:17: parse error on input ‘::’
05:33:51 <kuribas>  
05:37:32 <kuribas> grpala: Btw, then don't help me.  I don't like your attitude.  I gave all information in the original post.
05:39:06 <grpala> it believed the error contained more information
05:39:15 <kuribas> http://lpaste.net/130907
05:40:33 <rasen__> How GHC version relates to version of base?
05:40:33 <kuribas> I am using the syntax from: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html
05:42:04 <int-e> fikusz: http://lpaste.net/5248364286689935360 ... basically: unrolling loops manually still pays off, but don't be afraid of non-tail recursion.
05:42:30 <int-e> fikusz: err, not unrolling. I mean implementing loops manually as tail-recursive functions.
05:43:41 <kuribas> hm, I guess patter type signatures aren't supported in my version of ghc.
05:43:56 <kuribas> I should have checked the manual version...
05:45:25 <int-e> fikusz: But it's still quite a bit slower than C.
05:46:03 <fikusz> int-e: I see, I'll check how it compares. thank you :)
05:47:02 <kuribas> mniip, pavonia, grpala: it's not in the manual for 7.8.3, my bad...
05:47:23 <grpala> kuribas: You could try adding a type signature like this: pattern LinearE l = (Expr (l :: Num n => LinExpr v n) [] [] :: Num n => Expr v n)
05:49:04 <int-e> fikusz: Oh and note that unsafeRead/unsafeWrite always use zero-based indices and don't do any bounds checking. So they make Haskell about as bad as C, too.
05:49:56 <fikusz> int-e: I'm aware that this is absolutely not worth it under normal circumstances
05:50:31 <fikusz> int-e: I always thought I should avoid non-tail recursion where possible, what's the rationale here?
05:51:02 <int-e> fikusz: using the stack is far more efficient than building a list and traversing it.
05:52:11 <kuribas> grpala: That doesn't work, but thanks anyway.  I am using a normal function for now.
05:52:37 <int-e> fikusz: one big contributor is that stack space can actually be reused, while each list item has to be allocated from the heap. so you destroy locality of memory accesses
05:52:39 <fikusz> int-e: so I should only do list-building if I know it would be too much for the stack?
05:52:40 <kuribas> It's too cutting edge anyway...
05:54:24 <kuribas> fikusz: did you try using lazyness?
05:54:50 <fikusz> kuribas: in what way?
05:55:00 <int-e> fikusz: I'd say rhar you shouldn't regard non-tail-recursion as a big deal, unless the depths reaches tens of thousands, I think.
05:57:05 <fikusz> int-e: thanks, I understand your point. there's always some compromise I guess
05:57:17 <kuribas> fikusz: Create an array with for every number the chain length.
05:58:02 <kuribas> fikusz: Define chainlen !! 1 == 1, and define the other recursively.
05:59:24 <kuribas> You may need a sparse structure for elements above 1 milion.
05:59:25 <fikusz> kuribas: I think the numers can go very high here and it's not really worth to cache all of them
06:00:05 <kuribas> fikusz: you can cache only the numbers upto 1 million, or any other arbitrary amount.
06:01:38 <fikusz> kuribas: I didn't try this yet, but I'm not sure how I'd go about implementing it
06:01:49 <int-e> http://lpaste.net/589649334149054464 is what kuribas has in mind, I think. It's about 10x slower than the IOUArray thing.
06:02:34 <kuribas> int-e: maybe because you generate a list?
06:02:59 <fikusz> int-e: thanks again, I'll take a look at it in a second.
06:05:23 <kuribas> int-e: it looks wrong, what about elements > 999999?
06:05:48 <int-e> kuribas: no, the list is fused away; however, it was using Integer. http://lpaste.net/2836623855156461568  is a bit better, but still not nearly as fast as the unboxed array version. Laziness is actually quite expensive.
06:06:18 <int-e> kuribas: s is just a cached version of s'
06:06:28 <int-e> kuribas: s' is the Collatz iteration.
06:09:43 <zq> class Category cat where Source
06:09:43 <zq> A class for categories. id and (.) must form a monoid.
06:09:59 <zq> why not just class Monoid cat => Category cat
06:10:46 <int-e> kuribas: actually I was too optimistic, the lists are still in there. However, that accounts for at most 30% of the running time (measured by replacing s' by a noinline, constant function)
06:11:18 <kuribas> int-e: It may spend a lot of time garbage collecting the list...
06:12:53 <kuribas> int-e: maybe Data.Vector has better performance...
06:18:00 <wakalabis> Hey, guys.. I am trying to call a C function from haskell. I'm getting an error message: "Unacceptable argument type in foreign declaration: CSize" -> http://lpaste.net/3328745794957213696
06:18:43 <wakalabis> How do I declare a C function that receives an argument of type `size_t` ?
06:21:05 <int-e> kuribas: http://lpaste.net/4088951806598578176 ... about 20% faster.
06:24:58 <kuribas> int-e: so ugly-imperative code still wins :(
06:25:04 <kuribas> At least speedwise.
06:25:29 <int-e> kuribas: I stand by what I said, laziness is quite expensive. However, it's also *very* convenient, which is why I'm usually willing to pay that price. I'd rather write that boxed array or vector code than the imperative one.
06:26:22 <kuribas> int-e: I wonder if putting that throug a supercompiler would help.
06:27:39 <paxcoder> int-e, what's it convenient for?
06:28:20 <Forgetaboutit> @pl \l -> filter (/= ' ') $ nub l
06:28:20 <lambdabot> filter (' ' /=) . nub
06:28:55 <int-e> paxcoder: well, in the code I just pasted, I don't have to track dependencies of the values myself; laziness takes care of that for me.
06:29:32 <paxcoder> I wasn't paying attention, I might need some time to figure what you're talking about.
06:29:54 <int-e> paxcoder: In fact the construction of 'cache' and s in terms of s' can easily be tucked away into a reusable memoization library, so I could, essentially, just write down the Collatz recurrence and be done.
06:31:27 <Forgetaboutit> @pl \a b c -> Right (,,)
06:31:27 <lambdabot> const (const (const (Right (,,))))
06:31:51 <Forgetaboutit> @pl \a b c -> Right $ (,,) a b c
06:31:51 <lambdabot> ((Right .) .) . (,,)
06:32:10 <paxcoder> Don't you have a REPL, Forgetaboutit?
06:32:46 <Forgetaboutit> paxcoder: Unfortunately, I don't know how to do that in GHCI :/
06:32:50 <lyxia> wakalabis: Try importing the CSize constructor as well.
06:35:07 <paxcoder> int-e, yeah, i don't know what your code does. Can you explain what "value dependencies" mean?
06:35:37 <hexagoxel> paxcoder: indeed, standard repl does not include `pointfree`
06:36:03 <hexagoxel> Forgetaboutit: you can private message lambdabot, or install the pointfree executable from hackage.
06:36:19 <paxcoder> hexagoxel, see what hexagoxel said ;)
06:36:40 <Forgetaboutit> hexagoxel: Excellent, thank you!  Sorry for bothering you :(
06:36:46 <hexagoxel> no problem :)
06:36:48 <paxcoder> no problem
06:37:40 <paxcoder> int-e?
06:40:08 <paxcoder> Apart from infinite data structures, what's laziness good for, if anything?
06:41:14 <ackthet> simple concurency 
06:41:48 <paxcoder> ackthet, explain please
06:42:25 <kuribas> paxcoder: datastructures which refer to themselves.
06:42:52 <kuribas> paxcoder: for example memmoizing.
06:46:53 <sagittarian> I don't suppose it's possible to pattern match on a positive vs a negative integer, is it?
06:47:02 <paxcoder> kuribas, so just on-demand datastructures?
06:47:15 <paxcoder> *datastractures with on-demand values
06:47:19 <kuribas> paxcoder: that's a way to see it, yes
06:47:39 <paxcoder> that can be solved without laziness
06:47:55 <paxcoder> so there are no other benefits?
06:48:02 <paxcoder> what about speed?
06:48:06 <kuribas> paxcoder: Even when working with finite datastructures, lazyness can change the asymptotic complexity of a program.
06:48:15 <paxcoder> wut
06:48:16 <hodapp> Yes. It can be solved without laziness by implementing laziness some other way.
06:48:40 <paxcoder> hodapp, actually, it can be done without thunks :P
06:48:54 <paxcoder> kuribas, memoization can, but laziness on it's own? o.O
06:49:00 <kuribas> paxcoder: I am thinking of an example...
06:49:02 <paxcoder> *its
06:49:06 <paxcoder> ok
06:52:03 <paxcoder> hodapp, actually, I'm fine with calling it all laziness. In fact, I call the fact that fun f() = 1 + 2 is not evaluated until called (in SML, used for thunks) laziness too.
06:52:08 <int-e> paxcoder: The array entry at index 312 depends on the one at 156. That's encoded in s', of course, but I don't have to worry about evaluating the entry at 156 before the entry at 312, because lazy evaluation does it for me.
06:53:14 <kuribas> paxcoder: It's different though, f() gets evaluated every time it's called, while f = 1 + 2, would only be evaluated once.
06:53:21 <hodapp> paxcoder: So... what are you actually saying then?
06:56:12 <paxcoder> kuribas, not necessarily
06:56:39 <paxcoder> hodapp, i'm saying maybe making the whole language lazy for the sake of infinite structures is not beneficial
06:57:59 <paxcoder> kuribas, not sure if we're thinking about the same thing. You might be thinking memoization, but my example was simple laziness.
06:58:23 <hodapp> paxcoder: In other words, "Sometimes, things have tradeoffs."
06:59:11 <merijn> paxcoder: The response to that is the following: It's easier to make lazy things strict than strict things lazy
06:59:21 <merijn> paxcoder: Therefore, I'm more and more convinced that lazy is the right default
06:59:26 <fikusz> int-e: I have a question about the last (lazy) version you pasted, the one using Data.Vector. I understand why it's slower than the IOUArray version, but don't get why it's using this much memory (~60MB) 
06:59:37 <hodapp> paxcoder: Also, as kuribas has said, it's not "for the sake of infinite structures".
06:59:57 <srhb> paxcoder: I only skimmed the conversation, but "infinite data structures" is probably not in any way the biggest boon of laziness
06:59:58 <merijn> hodapp: not JUST ;)
07:00:01 <srhb> Performance probably is.
07:00:03 <int-e> paxcoder: well, I see three main uses. 1) infinite data structures. 2) an important subclass of 1), important enough to be considered a separate use, are streams (infinite lists). they encode loops in a composable fashion, and there's a lot of work of making the actual data structure disappear (stream fusion). 3) memoization. The collatz example is a memoization one.
07:00:17 <fikusz> int-e: the IOUArray one is using only ~9MB
07:00:38 <paxcoder> hodapp, no, "this time, the opportunity cost of the choice might be higher than the gain"
07:01:01 <merijn> Don't forget the fac that laziness leads to better composability
07:01:14 <paxcoder> sec, reading your replies
07:01:27 <srhb> paxcoder: Perhaps this link will be of interest to you: http://www.quora.com/When-did-you-realize-the-power-of-lazy-evaluation-in-terms-of-performance
07:01:32 <merijn> "filter pred . map foo . map bar" is O(3n) in a strict language, whereas it is O(n) (plus a little allocation overhead)
07:01:47 <hodapp> paxcoder: That's the same thing as what I said. Pick a stronger word than 'might'.
07:01:53 <int-e> fikusz: well, in the IOUArray one you have a million element array with a word per entry. in the vector one, you have a one million element array, where each entry is a pointer to a closure that has at least 3 words (tag, one placeholder for locking, and a data field encoding the index). So that's a factor of 4 at least.
07:02:06 <merijn> So laziness lets us write/compose naive code that is asymptotically faster than the strict equivalent
07:02:09 <kuribas> merijn: O(3n) == O(n)?
07:02:13 <merijn> kuribas: I know
07:02:23 <merijn> kuribas: Do you have a better way of explaining that point?
07:02:31 <srhb> Small o, or omega?
07:02:50 <merijn> I don't know small o/omega, just O and theta
07:02:52 <merijn> Anyway
07:02:54 <int-e> fikusz: it's another cost of laziness for memoization, really. instead of values, you'll have to deal (and encode, somewhere on the heap, closures)
07:03:14 <int-e> ... deal with (and encode, somewhate on the heap) closures
07:03:18 <merijn> paxcoder: It's one of the reasons why haskell's map is much nicer than, say, ocaml's too
07:03:57 <merijn> paxcoder: In haskell we can write "map f (x:xs) = f x : map f xs" and it's efficient. In ocaml/other strict languages you need to rewrite map to a more complex tail recursive version to not explode your stack
07:04:41 <int-e> paxcoder: I forgot one key use, maybe already mentioned... you can easily define custom control structures. if-then-else does not have to be built in (the builtin one is just syntax sugar); short-cut evaluation of || and && isn't built in... it all relies on laziness.
07:04:43 <paxcoder> snrb, i meant ad-hoc data in general. i guess lazy progs could be more performant but in my ideal world, with automatic parallelism, they wouldn't be.
07:04:53 <srhb> paxcoder: That's just wrong.
07:04:58 <paxcoder> i'm so far behind in the log right now
07:05:01 <srhb> :)
07:05:07 <kuribas> merijn, paxcoder: well I think  (inits l !! n) = O(n) in a lazy language, and is O(m^2) in an eager language, where m == length l
07:05:47 <hodapp> paxcoder: 'in my ideal world' is quite a big gap over which to call a design into question.
07:05:48 <paxcoder> srhb, :S
07:06:03 <paxcoder> hodapp, i'm thinking ahead :P
07:06:13 <fikusz> int-e: I didn't think the factor could be as big as 4, guess it's not that bad when you have fewer & larger elements
07:06:15 <paxcoder> but i guess that's true
07:06:16 <srhb> paxcoder: Sorry, that came out really harsh. I meant that your point there doesn't touch on laziness at all, and laziness doesn't preclude having those same advantages over eager even in "automatic parralellism"
07:06:17 <hodapp> paxcoder: how is that?
07:06:19 <merijn> paxcoder: I don't think your ideal world of automatic parallelism will happen any time soon
07:06:39 <merijn> paxcoder: I've seen 5 research projects trying to make it happen (and even more proposals) they invariably never work out
07:06:44 <merijn> Anyway, time to run :)
07:06:53 <hodapp> oh, automatic parallelism has been due out "real soon now" for like the past 4 decades
07:07:04 <hodapp> maybe they'll use neural networks and genetic algorithms to figure it out
07:07:09 <hodapp> er, wait, no, big data
07:07:20 <merijn> hodapp: You forgot "deep learning"
07:07:32 <paxcoder> srhb, not as hard as uninformative. laziness would forbid things that aren't yet needed from being evaluated in parallel.
07:07:37 <paxcoder> *harsh
07:08:04 <paxcoder> basically i'm just talking with srnb now ignoring other chatlines. i have to force myself to continue reading the log.
07:08:18 <srhb> Don't, I'm probably not the smartest person on this topic. :-)
07:09:15 <paxcoder> i need to for other people's sake
07:09:36 <paxcoder> oh you mean don't reply to you. darnit
07:10:09 <int-e> fikusz: well, in addition to what I wrote, the array itself is a large object that's managed separately from the main heap; it won't be copied during garbage collection. All those closures are small objects which will be copied, and that's another factor of 2 overhead (excluding the array itself).
07:10:12 <hodapp> paxcoder: So, you are saying that, on a machine that does not exist and has shown no real promise of existing, Haskell's implementation of laziness would be suboptimal.
07:10:57 <paxcoder> int-e, thanks for your 3 uses, i am aware of the lot, i was hoping there are other benefits. I guess speed of execution currently is.
07:11:14 <mmachenry> hodapp: I know I can at least conceive of such a machine, so I agree. :)
07:11:40 <paxcoder> srhb, thanks for the link, will take a loot when I finish reading
07:11:47 <srhb> paxcoder: Sure thing. :)
07:11:52 <fikusz> int-e: it's still surprisingly fast, considering all those things (this also explains the GC time of ~50%)
07:12:43 <paxcoder> merijn, dataflow is a nice example. btw when I said there were non-thunked solutions, I meant dataflow variables.
07:13:02 <hodapp> paxcoder: the given uses are not exactly cases to trivialize.
07:14:50 <statusfailed> I often need to install packages direct from github (when their hackage packages are out of date). Is there a good way to do that in a cabal sandbox?
07:15:04 <statusfailed> right now I "cabal install /path/to/cloned/repo" for each one :\
07:15:18 <paxcoder> int-e control structures are a good example too. no need for magic.
07:15:40 <srhb> statusfailed: What's wrong with git clone foo, cd foo, cabal sandbox init, cabal install?
07:15:56 <srhb> statusfailed: You can always script that if you want.
07:16:14 <paxcoder> merijn, bye XD
07:16:32 <statusfailed> srhb: oh I'm not trying to build the git packages as my end goal- I need the more up to date versions as deps for my own package
07:16:46 <srhb> statusfailed: Ah, so cabal sandbox add-source ?
07:17:13 <statusfailed> srhb: so I would do "cabal sandbox add-source /path/to/repo.git" for each package?
07:17:14 <kuribas> int-e: This version is still faster: http://lpaste.net/130912
07:17:25 <srhb> statusfailed: Just the root directory of each of them, yes.
07:17:29 <statusfailed> or can I do /path/to/directory/containing/all/repos
07:17:44 <statusfailed> actually that's pretty scriptable
07:17:47 <paxcoder> hodapp, no that's what i asked for. and thank you all for responding, i'll note the advantages somewhere
07:17:48 <statusfailed> so maybe nevermind :-)
07:17:52 <srhb> statusfailed: for d in `ls all-repos-path`; do cabal sandbox add-source $d; done
07:17:59 <kuribas> int-e: still 5x slower than your version...
07:18:03 <statusfailed> srhb: I don't even have to write it myself now~
07:18:04 <statusfailed> thanks much!!
07:18:07 <srhb> statusfailed: :)
07:22:41 <int-e> kuribas: funny. I guess it improves locality somwhat.
07:25:37 <kuribas> yes
07:29:21 <k0ral> is it the right place to ask about a problem with emacs' haskell-mode ?
07:29:27 <kuribas> int-e: It's hard to beat C...  But I still prefer slightly slower but correct over fast and crashing :)
07:29:38 <kuribas> k0ral: better go to #haskell-emacs
07:30:24 <k0ral> kuribas: right, thanks
07:32:43 <int-e> kuribas: the same idea applies to the unboxed version, very nice: http://lpaste.net/3854178023636992000
07:36:29 <kuribas> int-e: I thought that's what you were using already...
07:45:08 <int-e> kuribas: no, I actually checked whether an entry had been populated by reading it
07:47:39 <kuribas> int-e: strange the lazy code is so slow, since it is actually doing the same thing...
07:50:20 <statusfailed> do I need to do anything special to get cabal to build with optimization for an executable?
07:50:27 <statusfailed> in a project with a *cabal file
07:50:35 <dcoutts> statusfailed: on
07:50:38 <dcoutts> erm no
07:50:44 <dcoutts> default is -O
07:50:45 <statusfailed> dcoutts: "on" makes sense too :p
07:50:48 <dcoutts> :-)
07:51:00 <statusfailed> ok, thanks :)
07:51:03 <dcoutts> for hacking, for quicker builds you can: cabal configure -O0
07:52:20 <int-e> kuribas: not really. it allocates a million closures, it updates each of them by an Int, and it spends almost half its time doing GC... all this effort adds up.
07:52:57 <kuribas> I see...
07:58:43 <Phillemann> I have a "Lazy.Map Text.Xml.Name Text" on which I call "m ! (Text.Xml.Name "foo" Nothing Nothing)". This fails because apparently, the key is not in the map. traceShowId, however, tells me that the map is "fromList [(Text.Xml.Name "foo" Nothing Nothing),"bar"]"
08:00:01 <Phillemann> (There's a closing paren missing at the end, sorry)
08:00:26 <int-e> kuribas: note this minor improvement by tail recursion: http://lpaste.net/7576322499122561024
08:04:57 * hackagebot json-autotype 1.0 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-1.0 (MichalGajda)
08:07:15 <statusfailed> does `flip fmap` live as an operator somewhere?
08:07:20 <statusfailed> (lens or base I guess)
08:07:28 <statusfailed> I feel like I should know this :|
08:08:35 <hexagoxel> :t (<&>)
08:08:36 <lambdabot> Functor f => f a -> (a -> b) -> f b
08:08:51 <kuribas> :t flip fmap
08:08:52 <lambdabot> Functor f => f a -> (a -> b) -> f b
08:09:04 <hexagoxel> statusfailed: i think lens
08:09:07 <kuribas> @hoogle f a -> (a -> b) -> f b
08:09:09 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
08:09:10 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
08:09:10 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
08:09:23 <statusfailed> :i (<&>)
08:09:28 <statusfailed> aw :-)
08:09:38 <statusfailed> yes lens
08:09:39 <statusfailed> thanks :)
08:11:29 <zq> yes hi this is zq
08:11:43 <zq> how can zq import type families
08:11:53 <zq> import GHC.TypeLits ((+)) does not work
08:14:02 <hexagoxel> zq: judging by the export list, you need `import GHC.TypeLits (type (+))`
08:15:17 <zq> hexagoxel: that worked. zq thanks you.
08:18:09 <zq> why can't gcc just use a separate keyword for kinds
08:18:23 <zq> instead of polluting the type namespace with DataKinds
08:18:27 <zq> oh right existing programs
08:25:19 <statusfailed> I'm using the "ekg" package, and all the counters are showing as zero... that's wrong, isn't it?
08:26:33 <athan> Is the danger of unsafeCoerce undetermined runtime exceptions?
08:29:37 <ggVGc> which of these do you guys reckon reads best? https://gist.github.com/73b20a5dffbd9215a188
08:31:37 <yenda> Hi, I'm a pure beginner trying to get started with haskell but I can't install ghc-mod is the package broken ?
08:32:09 <yenda> This is the error : Language/Haskell/GhcMod/Gap.hs:256:18:
08:32:09 <yenda>     Not in scope: data constructor ‘ExposePackageId’
08:32:10 <yenda>     Perhaps you meant ‘ExposePackage’ (imported from DynFlags)
08:32:10 <yenda>  
08:33:28 <MichielDC> How are you installing? And what OS?
08:33:52 <yenda> ArchLinux
08:34:02 <yenda> I'm just doing cabal install ghc-mod
08:34:31 <bergmark> yenda: it probably doesn't build with that version of ghc
08:37:45 <yenda> I have to use these sandboxes ?
08:49:13 <zq> ugh, sandboxes
08:53:27 <paolino> hello , is it me or hackage is a bit hostile to gather help ? I have fixed a minor glitch in a package but there is no way to patch
08:54:19 <athan> paolino: It's defensive :p
08:54:30 <athan> I'd go the github - pr - beg way :)
08:55:01 <athan> You can also make your own isolated sandbox and use `cabal sandbox add-source ~/dev/foo` to add your functionality
08:55:19 <athan> (but it might be wise to also edit the version number for `foo`, too)
08:55:25 <paolino> mh, there is no github repository for https://hackage.haskell.org/package/HDBC-sqlite3-2.3.3.0
08:55:39 <athan> paolino: You can also `cabal unpack` :)
08:55:49 <paolino> that's what I have a 2.3.3.1 in a sandbox
08:55:53 <athan> It might be a matter of tracking down the person :\
08:57:30 <int-e> paolino: https://github.com/hdbc/hdbc-sqlite3 might be the right thing
08:58:25 <int-e> (but looks unmaintained)
09:00:46 <paolino> IIRC I could upload a new version of a package a little while ago
09:02:01 <paolino> has it been abused and it's no more a feature of hackage ?
09:03:38 <merijn> paolino: Are you talking about your package? Or someone else's?
09:03:51 <paolino> someone else's
09:03:56 <merijn> paolino: I think old-hackage didn't track package ownership, but new hackage does, for obvious reasons
09:04:08 <paolino> IIRC I patched random
09:04:27 <merijn> paolino: Contact the Hackage trustees to request maintainership/upload a fix of abandoned packages
09:05:33 <paolino> that's what I meant with a "bit hostile"
09:07:03 <merijn> paolino: That's not hostile, the fact that Hackage ever allowed anyone to update someone else's package was a huge bug
09:07:10 <merijn> paolino: https://wiki.haskell.org/Taking_over_a_package
09:08:22 <paolino> how helping is a bug ?
09:08:52 <zq> would you leave your front door unlocked so that the cleaners can come by to help
09:09:26 <paolino> it's a choice not a bug
09:10:00 <monochrom> no, I leave my back door open :)
09:10:05 <merijn> paolino: Template Haskell can execute arbitrary code at compile time, 1) create hackage account 2) upload new yesod version with trojan TH 3) Profit
09:10:20 <zq> oh so innuendo, sir monochrom
09:10:46 <merijn> Not to mention Custom cabal scripts can execute arbitrary commands too
09:11:48 <zq> now that seems like a bit of a bug
09:12:04 <merijn> zq: How else would you run autoconf/whatever ?
09:12:37 <zq> the point of cabal is to supplant autoconf
09:12:44 <merijn> zq: Custom installs cabal compile an executable that gets run to configure/install the package, what that executable does is not defined
09:12:52 <merijn> zq: You're assuming a package contains only haskell code
09:12:53 <dcoutts> IO () :-)
09:13:03 <zq> merijn: yes i am. works with cbits too, though.
09:13:06 <merijn> zq: What if my package contains C/C++ wrappers that need to be build using autoconf?
09:13:08 <yenda> how do I find a version of ghc-mod that will install properly ?
09:13:15 <merijn> zq: Only if you have trivial cbits
09:13:26 <dcoutts> zq: it's plausible to try an pin it down, but there's a lot of features you'd have to restrict
09:13:30 <merijn> yenda: By waiting, the fixed version for 7.10 isn't out yet, because the maintainers are busy with their job
09:13:32 <dcoutts> there are better approaches to security
09:13:44 <zq> like what?
09:13:51 <zq> either you allow arbitrary exec or you don't
09:14:16 <dcoutts> you can establish some degree of trust that the package is by the author
09:14:29 <zq> yes, 'tis by me, sir evilalot
09:14:33 <zq> then what?
09:14:48 <paolino> I don't understand why trustee should trust me and not an offender
09:14:55 <dcoutts> then you're still screwed, but at least it's not happening with e.g. containers
09:15:13 <merijn> yenda: See https://github.com/kazu-yamamoto/ghc-mod/issues/437
09:15:46 <merijn> zq: Then don't install it :)
09:16:44 <dcoutts> zq: there's not a whole lot we can do against an existing author going postal
09:16:49 <zq> yes, you're right
09:17:16 <zq> even if you restrict to pure Haskell, you'd still have access to System.FilePath
09:17:16 <dcoutts> zq: but if you imagine that you want to, you'd need both what you're talking about with build-time limitations, and also full SafeHaskell
09:17:55 <dcoutts> zq: it's not implausible, but it's a significant effort, and one that could only apply to a subset of packages
09:18:31 <zq> disregard my "bug" statement, it wasn't thought out properly
09:18:55 <dcoutts> zq: if you want to do a safe-haskell equiv for Cabal, where you identify a safe subset, then that'd be great, patches accepted :-)
09:19:11 <paolino> At least let me upload a patch and taint it as awfully mine and untrustable
09:19:47 <dcoutts> paolino: we've got a new trustee mechanism for minor patches for awol maintainers
09:20:08 <dcoutts> as well as the existing mechanism to simply take over a package
09:20:41 <paolino> it's not on the package page, is it ?
09:20:59 <dcoutts> no, it's very new and not well advertised yet
09:21:04 <paolino> ok
09:21:15 <yenda> merijn: since I'm totally new to haskell I'll guess I'll wait, does it happen often that packages break like that ?
09:21:40 <dcoutts> paolino: simplest of course is to contact the maintainer and ask them to delegate to you, by adding you to the maintainer group
09:21:49 <paolino> I did that
09:22:01 <paolino> noone answered
09:22:32 <dcoutts> ok, and if they're awol, that's where you can use the new trustee policy, or the existing "take over a package" policy
09:23:26 <dcoutts> paolino: final draft is here https://gist.github.com/bergmark/76cafefb300546e9b90e
09:23:29 <paolino> takeover is too much for me
09:23:34 <dcoutts> and we'll put it on the hackage site soon
09:29:42 <yenda> well at least today I learned how to downgrade a package
09:31:29 <paolino> dcoutts, is hackage automatically forking on github or needs manual intervention? Waiting 2 weeks to have a fix will make a lot of developers reply the fix and ask hackage the NMU
09:31:44 <yenda> if I understand it correctly cabale doesn't even handle dependencies properly ?
09:32:15 <dcoutts> paolino: it'd be done manually by the trustees
09:32:37 <dcoutts> paolino: I'm not sure what you mean about "reply the fix and ask hackage the NMU"
09:33:07 <paolino> replicate the fix
09:33:18 <dcoutts> yenda: it handles most dependencies, with some limitations, and it does require correct info in the .cabal files to work really well
09:33:52 <statusfailed> I've got a program with 3 threads, two writers and a reader (which outputs to stdout). The writers get a dup'ed Chan which the reader reads from. I seem to have a space leak- is dupChan likely the cause?
09:33:58 <dcoutts> yenda: e.g. limitations: the cabal-install solver doesn't handle C libs. And we don't yet support specifying deps of Setup.hs scripts (though that'll be covered in the next release)
09:34:46 <dcoutts> paolino: there's a balance to be struck between doing things quickly and trampling all over the rights of authors/maintainers
09:35:17 <dcoutts> paolino: ideally we can get more authors to nominate secondary people to be maintainers for when they're not available / too busy
09:35:49 <dcoutts> or opt-in to letting the trustees do things with less notice, but we need to strike a balance
09:36:00 <paolino> IMHO a fast undo should be useful
09:36:32 <dcoutts> that's not something we can support easily, since we cannot delete package versions
09:36:46 <paolino> right
09:37:15 <dcoutts> (if we did, no downstream consumers could trust us for hosting)
09:38:24 <paolino> hackage service is too broad in some way
09:41:53 <dcoutts> paolino: hosting is the wrong word really, could not trust us as a distribution point. Most of the distros rely on immutable upstream tarballs
09:51:18 <paolino> statusfailed, newBroadcastTChan needs not to be read
09:52:36 <paolino> *a TChan made with that needs not
10:06:51 <Hijiri> Does attoparsec provide a parser that always fails?
10:09:58 * hackagebot uu-parsinglib 2.9.1 - Fast, online, error-correcting, monadic, applicative, merging, permuting, interleaving, idiomatic parser combinators.  http://hackage.haskell.org/package/uu-parsinglib-2.9.1 (DoaitseSwierstra)
10:10:19 <glguy> Hijiri: fail "I always fail" or mzero
10:15:45 <mpickering> mzero?
10:16:35 <glguy> http://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Monad.html#v:mzero
10:18:10 <monochrom> attoparsec is an instance of MonadPlus.
10:25:37 <athan> When using `unsafeCoerce` for application, do pattern-matches simply check data constructors?
10:25:45 <athan> > head $ unsafeCoerce [1,2]
10:25:47 <lambdabot>  Not in scope: ‘unsafeCoerce’
10:25:54 <athan> > head $ Unsafe.Coerce.unsafeCoerce [1,2]
10:25:56 <lambdabot>  Not in scope: ‘Unsafe.Coerce.unsafeCoerce’
10:26:31 <athan> shoot
10:26:51 <dcoutts> athan: lambdabot doesn't like running code that can segfault ;-)
10:26:56 <athan> :x
10:27:43 <dcoutts> athan: there's nothing special about unsafeCoerce when it comes to pattern matching
10:27:46 <athan> dcoutts: At any rate, this still fails in ghci. Does this mean that unsafeCoerce has no use for (and destroys, in a sense) runtime values?
10:27:52 <athan> hmm
10:28:03 <athan> that code returned nothing in ghci :\
10:28:13 <exio4> I guess it is the defaulting
10:28:18 <Xnuk> > 1;
10:28:19 <lambdabot>  <hint>:1:2: parse error on input ‘;’
10:28:29 <dcoutts> :t head (Unsafe.Coerce.unsafeCoerce [1,2])
10:28:30 <lambdabot> a
10:28:54 <dcoutts> which as exio4 says, ghci will default to ()
10:28:58 <dcoutts> and so not print anything
10:29:17 <athan> oh!!
10:29:21 <athan> thank you dcoutts
10:29:43 <athan> Awesome :)
10:29:45 <dcoutts> athan: but note that this is a seriously bad idea
10:29:56 <athan> dcoutts: Excessively bad :x
10:29:58 <dcoutts> head (Unsafe.Coerce.unsafeCoerce [1 :: Int,2]) :: Integer
10:30:00 <dcoutts> for example
10:30:11 <athan> oh wow
10:30:28 <athan> are there any techniques for pseudo-safe coercion?
10:30:48 <dcoutts> there are plenty for safe coercion
10:30:50 <athan> for instance, coercing `1` to Integer before?
10:30:53 <athan> hmm
10:31:05 <dcoutts> including typeable/dynamic
10:32:49 <athan> thank you dcoutts
10:34:18 <zq> ugh
10:34:33 <dcoutts> athan: btw, note that that example above is simply reinterpreting the memory structure as an Int, or Integer
10:34:41 <dcoutts> but they don't have the same memory representation
10:34:52 <dcoutts> so it'll quickly go squiffy (read, segfault)
10:34:58 * hackagebot scalpel 0.1.3 - A high level web scraping library for Haskell.  http://hackage.haskell.org/package/scalpel-0.1.3 (fimad)
10:35:02 <zq> how come ghc doesn't know that m <=? n ~ 'True implies that (m - 1) <=? n ~ 'True
10:36:02 <athan> dcoutts: I had a feeling haha. I'm doing a lot of type-level computation, and variables are diverging, so I'm _thinking_ unsafeCoerce might be "safe"
10:36:13 * athan crossing my fingers
10:37:54 <monochrom> zq: because ghc has not been coded to know this. or most other arithmetic theorems
10:38:19 <zq> monochrom: it's pretty simple to add the instances to satisfy that
10:38:32 <zq> there's already a <=?
10:38:35 <monochrom> in fact, quite by design, so far the Nat kind is only good for statically known constants
10:38:54 <zq> and?
10:39:04 <monochrom> the end.
10:39:27 <zq> that was completely tangential
10:39:57 <monochrom> I agree to disagree.
10:42:24 <webchat099> safeCoerce :: a -> a
10:42:50 <exio4> safeCoerce :: a -> Maybe b ; safeCoerce = const Nothing
10:43:05 <monochrom> @quote monochrom safeHead
10:43:05 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
10:43:13 <monochrom> @quote monochrom safeFromJust
10:43:13 <lambdabot> monochrom says: I use safeFromJust :: Maybe a -> Maybe a
10:43:39 <monochrom> in light of the new status of Foldable and Traversable, I need to update that
10:44:01 <monochrom> safeFromFoldable :: Foldable f => f a -> f a
10:44:32 <webchat099> ;)
10:44:55 <phale> hey, I want to get into haskell, saw a lot of good things about it, where do i start
10:45:34 <hpc> @where lyah
10:45:34 <lambdabot> http://www.learnyouahaskell.com/
10:45:38 <hpc> @where rwh
10:45:39 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:45:54 <phale> i'll try the first link, thanks
10:47:00 <phale> Also, is it any better than C?
10:47:09 <phale> easier to use, less memory management
10:48:16 <exio4> @where learnhaskell
10:48:16 <lambdabot> https://github.com/bitemyapp/learnhaskell
10:52:43 <dashster18> Hi
10:55:49 <Mishac> Hi Guys, is there anyone who completed a Brent Yorgey course cis 194?
10:57:25 <Mishac> or do you happen to know if there is a channel where I can find people?
11:00:05 <supki> Mishac: I'd try #haskell-beginners
11:00:14 <Mishac> Thank You
11:00:45 <athan> Is gloss the go-to functional image library?
11:05:46 <anks> Hi, I need to work with cloud-haskell, but can't install it, due to deps problems. My system package manager updated ghc to 7.10 and cabal to 1.22.2. What is the quickest or the cleanest way to get cloud-haskell working?
11:05:50 <wedens> what can I read about extensions such as GADTs and type families?
11:06:25 <anks> @wedens, did you mean 'where' ?
11:06:25 <lambdabot> Unknown command, try @list
11:06:49 <dcoutts> anks: add another ghc version in /usr/local
11:07:21 <dcoutts> anks: just download the binary tarball from the ghc site, it installs to /usr/local by default
11:11:23 <Kron> what's the best haskell data type for a simple bidirectional Map
11:11:33 <Kron> map objects to char codes and char codes back to objects
11:11:38 <Kron> that sorta thing
11:14:53 <Hijiri> glguy: thanks
11:18:08 <paolino> there is a Data.Bimap
11:19:59 * hackagebot json-stream 0.2.0.0 - Incremental applicative JSON parser  http://hackage.haskell.org/package/json-stream-0.2.0.0 (ondrap)
11:21:02 <webchat099> I think that cloud haskell is not being used
11:21:56 <webchat099> I think that it is not the haskell solution for the problem
11:23:11 <wedens> anks: yeah. where
11:24:50 <webchat099> the haskell solution is cloud data structures, cloud monads, cloud applicative....category theory applie to the cloud
11:35:53 <monochrom> what is a cloud data structure?
11:36:19 <monochrom> I need to be more precise
11:36:23 <monochrom> what is a cloud data structure, mathematically?
11:37:13 <danilo2> Hello all! :) Are there any explanations in the web how exactly error (undefined) is implemented in haskell and why it is faster than using Either? (Or why either cannot be optimized this way durign compile time) ?
11:37:54 <monochrom> the second question is strange. error is faster because it kills the program faster.
11:38:27 <monochrom> err, that is not the clearest. error is faster because it kills the program.
11:39:11 <monochrom> error is unimplemented in haskell. it is implemented in which compiler/interpreter.
11:39:52 <monochrom> if you are interested in implementation, you will have to consult each compiler/interpreter.
11:40:18 <monochrom> hugs is an interpreter in fairly short C code
11:41:01 <danilo2> monochrom: but we can catch errors, so they do not "kill" imediatelly the program, do they? We can catch them in simmilar fashion to Either. I see the difference, I'm just lookiing for some detailed explanation about the implementation
11:41:12 <danilo2> in GHC
11:44:41 <monochrom> in GHC, error is implemented as an exception, and this can be done in GHC because GHC begins by allowing even pure expressions to throw exceptions. this is about all I know. to know more you may like the paper about "imprecise exceptions" by SPJ
11:45:27 * yenda just realized I was doing imperative programming, no wonder why the compiler was getting mad
11:46:36 <monochrom> but I guess I know some more since I know the asm code for pure expressions, and it certainly doesn't matter if one expression happens to say "throw exception".
11:47:37 <monochrom> as for whether it is faster than Either, I wouldn't believe any claim without hard data evidence support
11:47:53 <monochrom> no data suuport, ---> /dev/nul
11:48:54 <monochrom> if more people do "no supporting data ===> /dev/null", people would be more productive
11:49:20 <webchat099> monocrom a cloud data structure is a data container that is stored in the cloud
11:49:44 <monochrom> that is not very mathematically
11:50:04 <webchat099> Data.Map is not mathematical
11:50:18 <monochrom> I disagree
11:50:52 <jdreaver> Does anyone know of good Haskell replacements for parts of the Python pandas library? I am messing with a lot of financial time series right now. I am using Python mainly because of pandas, but if I could get something with the same order of magnitude in speed in Haskell I would love to use Haskell.
11:51:19 <webchat099> well, mathematical is everithing
11:52:19 <webchat099> a set of random numbers is  mathematical
11:52:41 <danilo2> monochrom: thank you very much for the help and the paper! :)
11:55:36 <monochrom> you may like a sequence, not a set, when it comes to random numbers
11:56:22 <webchat099> with mathematical usually people means: some set of elements that have interesting properties that have been discovered by someone and are in some book
11:56:27 <monochrom> "a sequence of random numbers is mathematical" is likely true, but you still want to spell out how to obtain that sequence mathematically.
11:57:28 <monochrom> I wouldn't lock myself into "a set of elements". but I agree with the rest.
11:57:36 <bros> I currently have a Node.js app server that I suspect to not be too efficient. I'm seeing 37% CPU load spikes on single WebSocket server requests. I know Haskell is known for its concurrency, but I'm worried I'll just recreate the same bottlenecks/problems in Haskell if I were to rewrite. Hitting Redis, parsing JSON, calculating MD5s, finding indexes should cause equal CPU load in any language (Erlang, Haskell, node.js, C) sans a 
11:57:36 <bros> little overhead, correct?
11:57:51 <rasca> Hello everyone!! I'm working on a fold function over a logical Expressions type I defined. The code is here: http://lpaste.net/130918  I'm sure there's a better way of writing this without repeating "foldExp fVar fNot fOr fAnd fD fB z" so many times!! Can someone help me?
11:57:56 <monochrom> what are interested properties of cloud data structures that have been discovered by someone and are in some book?
11:58:04 <monochrom> s/interested/interesting/
12:00:11 <webchat099> monocrom: I don´t mean that a cloud data structure has to be "mathematical" you say so
12:00:50 <monochrom> yes, and I stand by it
12:01:48 <webchat099> but for example, a container probably has to have two operations such that   retrieve(store a)== a
12:02:16 <earthy> monochrom: look at the ECOOP paper 'Cloud types for eventual consistency' (http://www.msr-waypoint.net/pubs/163842/CloudTypes-ECOOP12.pdf)
12:02:27 <webchat099> or something more general like that
12:02:29 <monochrom> I'm sure we agree that all containers satisfy that equation
12:03:26 <monochrom> if you only have that kind of properties, then "cloud data structures" equals "data structures". but I don't suppose you intend it.
12:03:40 <nullic> hey
12:03:40 <webchat099> one problem of cloud haskell is that it deliverately avoid such abstraction
12:04:07 <earthy> 'Cloud Haskell is a library for distributed concurrency in Haskell.' ??
12:04:14 <webchat099> CH is as low level as it can
12:04:21 <earthy> sorry, what are you on about webchat099 
12:04:53 <webchat099> about abstracting cloud computation at the level that haskell deserves
12:05:02 <earthy> so, implement something like the mentioned paper on top of that fabric.
12:05:14 <monochrom> I am not wed to abstractions.
12:05:58 <nullic> What do you guys think about a cross-platform system for drone-to-drone communication to avoid collisioins and collaboration
12:06:17 <monochrom> you can speak high-level or low-level, and there will still be a way to speak mathematically. even transistors can be described mathematically, and I will understand.
12:06:44 <monochrom> (how many programmers can even speak at the transistor level?)
12:06:46 <webchat099> monochrom: I mean the right level of abstraction
12:07:42 <monochrom> ok, if you want to work at the level of Cloud Haskell, then every data structure you define using Cloud Haskell is a cloud data structure, is that right?
12:08:01 <earthy> webchat099: there is no 'right' level of abstraction. there hopefully is a consistent level of abstraction.
12:08:05 <webchat099> earthy:  thanls for the link
12:09:12 <earthy> webchat099: there's an implementation in javascript on https://github.com/ticup/CloudTypes
12:09:26 <webchat099> well some abstraction that allows programming without explicitly using node pointers
12:09:46 <webchat099> I was thinking more about a monad/applicative for cloud computing
12:10:19 <webchat099> seamless computing
12:10:30 <earthy> what do you consider cloud computing?
12:10:48 <webchat099> work with two or more nodes
12:10:51 <earthy> would I be able to put a function into the cloud? have it calculated at an arbitrary node?
12:11:03 <webchat099> that is the goal
12:11:19 <webchat099> to run it "in the cloud"
12:11:40 <webchat099> not to run it in that node and then pass to other node so that I receive it in.....
12:11:59 <webchat099> also you don´t run it "in the computer"
12:12:23 <webchat099> you run it in the CPU, which call for some operations to the GPU and the IO and.....
12:12:26 <earthy> right... I think I understand what you're on about. The Cloud Haskell stuff is a necessary precursor to that.
12:12:54 <webchat099> sometines it run in one core, sometimes in other core....
12:13:07 <earthy> (because the cloud still is composed of cpus...)
12:13:46 <webchat099> earthy:  yes, CS is a precursor, but HTTP connections can do it to
12:14:20 <rasca> guys, can anyone help me or guide me in the correct direction please?
12:14:37 <Adeon> I thought cloud haskell was erlang in haskell but with a fancy name
12:14:52 <earthy> Adeon: yah.
12:14:59 * hackagebot lambdacms-core 0.1.0.0 - LambdaCms Core subsite for Yesod apps  http://hackage.haskell.org/package/lambdacms-core-0.1.0.0 (cies)
12:15:16 <roconnor> @check \xs -> (scanl (flip (:)) [] xs) == (inits xs)
12:15:17 <lambdabot>  +++ OK, passed 100 tests.
12:17:32 <quchen> roconnor: Careful with Quickcheck in here, the defaulting rules are strange.
12:17:39 <quchen> ?check \xs -> reverse xs == xs
12:17:40 <lambdabot>  +++ OK, passed 100 tests.
12:17:44 <roconnor> oh right
12:18:07 <roconnor> @check \xs -> (scanl (flip (:)) [] xs) == (inits (xs `asTypeOf` [1,2,3]))
12:18:08 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 3 shrinks):
12:18:08 <lambdabot>  [0,1]
12:18:49 <quchen> ?where justask 
12:18:50 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
12:18:51 <quchen> rasca: ^
12:19:08 <quchen> Or were you referring to something form earlier
12:19:47 <rasca> quchen: it was from before:
12:19:50 <rasca> I'm working on a fold function over a logical Expressions type I defined. The code is here: http://lpaste.net/130918  I'm sure there's a better way of writing this without repeating "foldExp fVar fNot fOr fAnd fD fB z" so many times!!
12:19:58 <rasca> quchen: ^
12:20:24 <quchen> rasca: There is a way indeed, by using `case` to share patterns. One moment.
12:20:44 <rasca> thanks !
12:20:51 * roconnor wonders what I was thinking when I wrote this garbage code.
12:20:56 <webchat099> eventual consistency is synchronization. Why people invent new names for old concepts
12:20:59 <srhb> rasca: Several! For one, you could share one definition with all the parameters in one function, and then call one function that only takes the last parameter as argument
12:21:05 <srhb> rasca: Or pattern synonyms, or case expressions
12:22:30 <quchen> rasca: http://lpaste.net/130919
12:22:55 <roconnor> oh wait, it is actually correct and good.
12:22:55 <quchen> Oh, I messed up one prettyprinting line break in the type sig.
12:23:17 <quchen> roconnor: When you have to read it because you think it's garbage it's not good.
12:23:31 <quchen> Sounds like it should be refactored, and if impossible, at least commented on.
12:23:57 <roconnor> quchen: hah, you are right.
12:23:59 <rasca> quchen srhb: thank you so much!! that's why I was trying to do!!
12:24:26 <quchen> rasca: The "case match on just some arguments" pattern is pretty useful, I use it a lot
12:24:29 <roconnor> quchen: one nice thing about garbage Haskell code is that it is still only 5 lines long.
12:24:37 <roconnor> so at least I can look at it all at once.
12:24:45 <EvanR> webchat099: you can observe inconsistency in eventually consistent systems
12:24:51 <quchen> roconnor: One bad thing about garbage Haskell is that even tremendously complicated code can be 5 lines long ;-)
12:24:59 <roconnor> ;)
12:25:23 <roconnor> quchen: and one line is taked up entirely by the word "where"
12:25:53 <quchen> roconnor: One plus is that even a strange implementation is "abstracted away" by the name and the type signature. Other languages have only the name.
12:26:04 <quchen> My go-to example is Set.insert.
12:26:23 <roconnor> :D
12:26:48 <quchen> (if you inline balance{L,R}, that is)
12:26:55 <webchat099> EvanR: I can not interpret that without learning the jargon. Can this be expreseed in other way as:  two nodes can be synchronized,  but there may be delays such that some events in some nodes have not ben processed?
12:31:09 <yenda> I'm doing my first Haskell program http://pastebin.com/2sdEvuzd and i get "Warning : defaulting the following constraint to type integer", cound someone explain me ?
12:31:14 <elfeck> heyoh, anyone can tell me why I get this: Couldn't match type ‘GHC.Int.Int64’ with ‘Int’
12:32:02 <mniip> yenda, let me guess, -Wall?
12:32:49 <athan> yenda: Number literals are polymorphic - when they get "forced" to a direct implementation, like Integer, it's usually "safer" to have that coercion explicit
12:32:56 <quchen> After working with Java I always have difficulties writing tests for Haskell libraries. Most tests simply won't typecheck. :-D
12:33:46 <meretrix> Is there any scenario where an uncaught "error" exception shouldn't be printed immediately?
12:34:06 <bergmark> athan, yenda: it's not because of number literals here, it's because `read' and `+' are both polymorphic, several types could apply and GHC picks Integer for you in this case
12:34:12 <ion> yenda: You are not saying what type you want to use read at, so it uses defaulting and warns about it. (read n :: Integer)
12:34:21 <athan> bergmark: :x
12:34:52 <mniip> yenda, also no one writes that many parentheses
12:34:59 * hackagebot calculator 0.3.1.1 - A calculator repl, with variables, functions & Mathematica like dynamic plots.  http://hackage.haskell.org/package/calculator-0.3.1.1 (sumitsahrawat)
12:35:35 <ion> yenda: You’ll want to avoid head and (!! 1). You could use pattern matching: [a,b] <- getArgs. Or you could get all args and use sum and map: args <- getArgs; print (sum (map read args) :: Integer)
12:35:49 <quchen> bergmark, athan, yenda: This behaviour is also why "default" is a keyword. Whenever there's a Num ambiguity, Haskell chooses Integer or Double, whichever works first. -Wall warns about this implicit type change.
12:35:55 <quchen> s/change/specialization/
12:36:43 <yenda> thanks for all the tips, I'm gonna clean my code a bit will all of these
12:37:37 <roconnor> @tell haasn I'm not familiar with deltaE metrics.  Can you email me some references (or code :)?
12:37:37 <lambdabot> Consider it noted.
12:50:55 <tar_> Is there a record field naming convention?
12:51:18 <quchen> tar_: Depends on the field. run* is often used for wrappers around functions, for example.
12:51:26 <quchen> runState, runReader, runRWST, runMyStuff, …
12:51:50 <shachaf> The runFoo convention has nothing to do with functions.
12:52:13 <shachaf> nwetype Writer w a = Writer { runWriter :: (w,a) }
12:52:15 <tar_> I'm thinking of records that are basically structs for marshaling JSON, where several of them have "id" fields, for example.
12:52:38 <tar_> The first project I checked used _recordName_fieldName, but hlint complains that it's not camel case.
12:52:41 <quchen> shachaf: I said nothing about Writer.
12:52:49 <quchen> Writer also uses run, yes.
12:53:04 <breadmonster> quchen: What does runRWST do?
12:53:59 <quchen> breadmonster: RWS is a hardcoded combination of (R)eader, (W)riter and (S)tate. The "T" is for transformer.
12:54:10 <breadmonster> quchen: Isn't just ST good enough?
12:54:20 <quchen> ST is something completely different.
12:54:24 <quchen> ST is not a transformer.
12:54:35 <breadmonster> Oh right, yeah.
12:54:40 <breadmonster> There's no ST transformer?
12:54:48 <breadmonster> Also, that's another thing I want to ask.
12:55:24 <breadmonster> What's the difference in the order in which you stack monads?
12:56:07 <pavonia> The result value will have a different type
12:56:20 <quchen> breadmonster: To make that clear, look at the types they encapsulate.
12:56:29 <quchen> ?unmtl MaybeT (ReaderT m) a
12:56:29 <lambdabot> (ReaderT m) (Maybe a)
12:57:04 <quchen> Eh, argument to ReaderT missing.
12:58:51 <quchen> Hm, unmtl is being evil to me. Anyway, the one way round it's r -> Maybe a, while the other one is Maybe (r -> a).
12:59:09 <Fuco> I'm using Text.XML.HXT to read an xml document.  My entire program is: main = runX $ readDocument [] "WX_nouns.xml"  the XML file is 20 megabytes, haskell uses 1300 megabytes of ram then crashes.  Is there maybe some library that can handle 20 megabyte file?
12:59:11 <breadmonster> ?unmtl StateT s (Maybe a)
12:59:12 <lambdabot> Plugin `unmtl' failed with: `StateT s (Maybe a)' is not applied to enough arguments, giving `/\A. s -> (Maybe a) (A, s)'
12:59:13 <quchen> So in the first case you always get a result (which might be Nothing), in the second case you might not even have something to compute a result from.
12:59:36 <quchen> ?unmtl StateT s Maybe a
12:59:37 <lambdabot> s -> Maybe (a, s)
12:59:55 <quchen> ("Maybe a" is not a Monad, "Maybe" is.)
12:59:59 * hackagebot HaskellForMaths 0.4.6 - Combinatorics, group theory, commutative algebra, non-commutative algebra  http://hackage.haskell.org/package/HaskellForMaths-0.4.6 (DavidAmos)
13:05:14 <meretrix> Any tips on debugging an application with a thread that throws an exception, but doesn't print the error until I kill the whole process?
13:05:41 <meretrix> The source of the error is obvious; I'm just trying figure out why it's not being raised properly.
13:07:13 <meretrix> I'm guessing it has something to do with a library's FFI interface and MVars.
13:09:03 <benzrf> hey, hdevtools has begun acting up:
13:09:05 <benzrf> benzrf@benzrf-laptop:~/codes/haskell/board$ hdevtools check src/Game/Board/Internal/Types.hs 
13:09:07 <benzrf> Cabal error: Cannot find the program 'ghc'. User-specified path '/home/benzrf/codes/haskell/board/./board.cabal' does not refer to an executable and the program is not on the system path.
13:09:17 <benzrf> ghc *IS* in my path
13:09:19 <monochrom> Fuco: if you don't mind using conduit, xml-conduit may be more space efficient. the main inefficiency in HXT and most xml libraries are in using [Char]. xml-conduit uses Text.
13:09:50 <Fuco> monochrom: I don't mind using anything. I need to get the job done :) I'll look at it, thanks
13:10:06 <monochrom> recall that length n [Char] means at least n*12 bytes. n*24 if 64-bit
13:10:07 <Fuco> I can use SAX or DOM, doesn't matter
13:10:13 <dcoutts> benzrf: looks like cabal is being told --with-ghc=/home/benzrf/codes/haskell/board/./board.cabal
13:10:25 <benzrf> dcoutts: wat
13:10:39 <dcoutts> benzrf: which is clearly bonkers
13:10:48 <monochrom> n length Text means n*2 + small constant bytes
13:11:10 <dcoutts> benzrf: so cabal is right, that file is not the ghc executable
13:11:16 <mniip> monochrom, utf-16? ಠ_ಠ
13:11:20 <monochrom> yes
13:11:26 <mniip> ಠ_ಠ intensifies
13:11:55 <mniip> are surrogates handled properly at least
13:11:59 <monochrom> yes
13:12:09 <dcoutts> benzrf: ignore the bit about the path, searching for an absolute filename on the path doesn't make sense
13:12:48 <monochrom> therefore, my n*2 is a lie. it is true for those below the ffff threshold
13:12:49 <dcoutts> benzrf: the bit about the path is for when you say things like --with-ghc=foobar, it'll look for foobar on the path.
13:13:14 <benzrf> ah
13:13:19 <dcoutts> benzrf: as for why hdevtools is telling cabal stupid things, sorry, don't know.
13:13:22 <monochrom> if you have n emojis, it's going to be n*4 bytes
13:13:25 <benzrf> :\
13:14:16 <quchen> breadmonster: Having a STT would require you to run the ST part on every >>=, which means your ST would just be a strange version of an Identity monad
13:14:23 <monochrom> there was some debate on whether utf-8 uses less space of 16 uses less space
13:14:57 <monochrom> that debate will never end because each camp can simply cite supporting corpus
13:14:57 <breadmonster> quchen: What about StateT?
13:15:20 <breadmonster> Don't ST and State provide the same implementation?
13:15:35 <quchen> breadmonster: When you run a StateT, you get the state (and the value). When you run ST, you get only the value. That's the value of ST, actually: you cannot leak the state out.
13:15:59 <quchen> (And it's not really a state anyway, it's a dummy parameter.)
13:16:04 <monochrom> but don't worry, no one in the debate said anything like "O(1) indexing". they knew what they're doing.
13:16:37 <monochrom> wouldn't you love the old days when Unicode was small and so "O(1) indexing" was true for 16?
13:16:55 <quchen> monochrom: What do you mean with indexing?
13:17:26 <monochrom> I have a sequence of length n. get me item at position i, i<n.
13:18:44 <quchen> Shouldn't that be O(1), independent of the n in UTF-n?
13:19:35 <quchen> (Assuming the structure has O(1) lookup)
13:20:59 <tar_> how do I get Data.ByteString.Lazy.ByteString from String?
13:21:25 <monochrom> well, perhaps I wrote wrong. I have a sequence of n code points. get me the ith code point.
13:21:37 <quchen> tar_: Data.Binary.encode
13:21:38 <srhb> tar_: I think it's called pack. It's in the Haddocks
13:21:42 <srhb> Oh, right.
13:21:58 <quchen> Or convert the String to Text and encode that.
13:22:06 <quchen> (Text comes with various encodings.)
13:22:19 <monochrom> when storing the code points in utf-8 bytes, some code point takes 1 byte, some other code point takes 3 bytes. the ith code point is not necessarily at the ith byte.
13:22:19 <srhb> Right, pack is for [Word8]...
13:22:31 <tar_> quchen: thank you! I was searching specifically for String -> BinaryString
13:22:44 <quchen> tar_: There are many ways to do that conversion.
13:22:52 <monochrom> utf-16 began to have the same issue when we went beyond the BMP
13:23:44 <quchen> monochrom: BMP?
13:24:17 <quchen> tar_: Here are some example encodings for Text. http://hackage.haskell.org/package/text-1.2.0.4/docs/Data-Text-Encoding.html
13:24:25 <monochrom> basic multi-lingual plain, the stuff below ffff
13:24:27 <quchen> All of these are applicable to String as well.
13:25:28 <quchen> monochrom: That's the same issue that you get when going beyond ff in UTF-8?
13:25:56 <monochrom> yes, but Unicode went beyond ff since day one
13:26:14 <monochrom> it stayed below ffff for several years
13:26:55 <monochrom> in fact, utf-8 was invented after Unicode was invented, so utf-8 never saw the days of staying below ff
13:33:35 <arw> in a way its not even "below ff", its "below 7f" and the lower part is called US ASCII
13:33:36 <tar_> fun fun, Bin.encode "" yields "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL" in ghcjs
13:35:20 <glguy> That's how it works in general using binary's Binary instance for lists. It's a length followed by the elements
13:35:21 <tar_> nm, that happens in ghc too. I must be confused.
13:35:37 <tar_> boy, that's not what I expected at all. thanks, glguy.
13:35:40 <breadmonster> How do you calculate and prevent cache misses in Haskell?
13:36:13 <mniip> eh
13:36:29 <breadmonster> mniip: ?
13:36:46 <mniip> well the general approach is a 10-foot pole I beleive
13:37:10 <breadmonster> as in?
13:37:26 <breadmonster> Someone told me that cache misses are expensive.
13:37:32 <arw> calculating cache misses is hard to impossible in easier languages such as C
13:37:55 <breadmonster> Sorry, this is all hearsay, I'm not very well versed in the fundamentals of a computer.
13:38:00 <arw> you can make educated guesses that are often right.
13:38:14 <breadmonster> And she said they are really expensive.
13:38:17 <arw> breadmonster: then don't worry about that topic. algorithmic complexity is a far larger problem.
13:38:25 <breadmonster> So good code will avoid all of that.
13:38:40 <quchen> breadmonster: I don't know how to answer your question, but there's a very interesting talk by edwardk on the subject of cache-oblivious algorithms. http://www.techcast.com/events/bigtechday7/pranner-1450/?q=pranner-1450
13:40:32 <srhb> Is there a name for this issue? Worrying about some obscure issue that one might never have to deal with? It seems common with people coming to #haskell (no offense intended)
13:40:48 <srhb> I'm just wondering whether it's studied in psychology, surely others experience it as well.
13:41:21 <srhb> Inverse bikeshedding... :-)
13:41:24 <glguy> That sounds like a better topic for #haskell-blah, if anywhere
13:41:27 <srhb> Sure.
13:41:32 <quchen> YAGNI-ish
13:43:29 <tar_> Data.Text.Encoding can make ByteString, but not the right kind? http://pastie.org/10100460
13:44:05 <quchen> What's B8?
13:44:15 <quchen> Is it ByteString.Char8? Don't use that.
13:44:22 <quchen> https://github.com/quchen/articles/blob/master/fbut.md#bytestringchar8-is-bad
13:44:38 <tar_> I'm not actually using it.
13:44:48 <tar_> But it's imported, so it used that qualifier
13:44:51 <quchen> Other than that, you can convert easily between strict and lazy text. I forgot the function's name, but it's easy to find in Text's docs.
13:45:25 <statusfailed> quchen: tar needs to convert between strict and lazy ByteString though, right?
13:45:40 <quchen> Oh. Well, there's a ByteString function like that as well.
13:49:23 <cschneid> Is there a good book to learn category theory? I know its not strictly haskell, but the wiki pages on stuff like Kan Extensions makes too many assumptions for me to understand it 
13:50:06 <hodapp> I have an ebook or two on it, but having not read any of them, I can't really recommend them as being anything except free...
13:50:13 <quchen> cschneid: I recently cross-read Leinster and Awodey.
13:50:44 <cschneid> quchen: "basic category theory" ?
13:51:24 <cschneid> quchen: yep, thank you.
13:51:53 <quchen> cschneid: http://lpaste.net/130920
13:51:54 <quchen> Those
13:52:05 <tar_> quchen: found it, thanks. fromStrict
13:52:59 <cschneid> euros! :)  quchen: thanks for the links, those do look good from a quick skim of the reviews
13:53:50 <tar_> orrrr, switch to Data.Text.Lazy, apparently
13:53:58 <quchen> cschneid: I found Leinster to be a bit more approachable. He almost drowns you in examples. Awodey goes a bit deeper, and often takes a different perspective. He sticks to a couple of examples that he keeps applying to new concepts, which is pretty nice.
13:54:07 <quchen> cschneid: And Awodey has monads :-)
13:54:55 <quchen> cschneid: I can also recommend watching Awodey's lectures when reading his book, https://www.youtube.com/watch?v=ZKmodCApZwk
13:55:31 <quchen> (4 lectures, ~80 mins each)
13:56:03 <cschneid> awesome
13:57:27 <quchen> The lecture in particular mentioned some things that made the book click for me.
13:57:46 <quchen> I don't remember the occasions, but Awodey making simple remarks about some things was a *huge* help.
13:59:20 <quchen> I somewhat understand monads now, but I don't think that knowledge is very useful for me in Haskell. What I did learn to understand was what an impressive discovery their *practical* use in functional programming is though.
14:01:14 <ion> I have been reading <http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/>, it has been very nice so far.
14:01:52 <cschneid> ion: that blog series has been one of the things that makes me want to dive in more. The explainations are great
14:02:56 <cschneid> quchen: yeah, I don't have much hope it'll actually help me program better :)  
14:05:00 * hackagebot species 0.3.2.4 - Computational combinatorial species  http://hackage.haskell.org/package/species-0.3.2.4 (BrentYorgey)
14:07:38 <quchen> cschneid: That's very hard to quantify, even subjectively.
14:08:37 <quchen> I haven't noticed any particular thing that I could apply, but maybe I've started seeing patterns in some places. Or maybe I'm less scared of certain things.
14:09:04 <quchen> One thing that is probably very useful is realizing what a primitive concept a category is.
14:09:05 <ion> I’m seeing patterns, dude!
14:09:11 <quchen> It's almost useless.
14:09:16 <quchen> (On its own)
14:10:37 <quchen> Also, I've been wondering what a monad in Java (or in subtyping-ish polymorpihsm) would be. ;-)
14:10:51 <quchen> (I now know what it is, and it is probably utterly useless.)
14:12:43 <jle`> i'm sure the monad itself wouldn't be useless...but maybe abstracting out a general pattern would be less than optimally useful :)
14:13:57 <quchen> jle`: I'm probably talking about a different kind of monad. You can see a lot of similarity between subtyping and poset (partially ordered sets). A subtyping relation "Oak < Tree" can be seen as an arrow from Tree to Oak.
14:15:03 <quchen> Some generic can then be seen as a Functor, taking objects Tree to Enumerable<Tree>, and arrows Tree->Oak to arrows Enumerable<Tree> -> Enumerable<Oak>
14:15:17 <quchen> (Java messes this up gloriously of course)
14:15:39 <mccn> I've been given an exercise that includes data Program = Move Direction Program | Radar (Robot -> Point) Program | ... and I don't know what the -> part means. What should I look up?
14:16:21 <quchen> mccn: It's the function arrow. Your Radar entry consists of a) a function from Robot to Point, b) a Program.
14:16:34 <Cale> mccn: A -> B is the type of functions which accept an argument of type A, and produce a result of type B.
14:17:55 <Cale> mccn: So in this case, a value of type Robot -> Point is a function which assigns to each value of type Robot, some value of type Point.
14:18:03 <Cale> (perhaps the location of that Robot)
14:20:00 * hackagebot lambdacms-media 0.2.0 - LambdaCms "media" extension  http://hackage.haskell.org/package/lambdacms-media-0.2.0 (cies)
14:22:45 <mccn> thanks. now I need to make a function that, given a program (which can be a bunch of nested programs) finds all cases of a certain program and changes one of the parameters to a certain value. That's why I was asking for something to read on, I'm yet to understand some concepts
14:22:46 <ajtulloch> Does anyone have suggestions for a good guide to OCaml for someone with a decent Haskell background?
14:25:06 <rgrinberg> Just skim through rwo
14:26:18 <ion> Someone should write Academic World Java for the people who are turned off by its real world aspects.
14:27:03 <tulcod> ion: i would also be turned off by its academic aspects...
14:27:20 <yenda> is it better to write x `mod` 7 or mod 7 x ? I'm following a tuto that does the former but I find the later to be easier and more logical
14:27:23 <monochrom> Wadler's previous project "Pizza" was an academic world java :)
14:27:39 <quchen> yenda: Whatever you think is easier to read in the context.
14:27:54 <ion> yenda: Assuming you meant “mod x 7”… what quchen said
14:28:01 <glguy> yenda: using mod infix is the norm in Haskell code and in addition it has its fixity set to match *
14:28:15 <monochrom> the project stopped because it was a great success. its main point "parametric polymorphism" is today Java's "generics"
14:29:22 <quchen> monochrom: Does Wadler's book mention why the hell there is no variance in Java? I'd read it just for that.
14:30:18 <monochrom> I don't know
14:30:47 <yenda> glguy: if it's the norm why does it need backquotes ?
14:31:25 <glguy> yenda: In Haskell you can make any function into an operator by surrounding it with backticks
14:31:27 <ion> yenda: Haskell does not have infix non-operator functions without them. Some languages, such as Agda, do.
14:31:28 <monochrom> if I write "f mod 7", what do you think it means?
14:31:55 <monochrom> in fact, if I write "f g 7"
14:32:29 <yenda> apply f to g and 7
14:32:40 <monochrom> not apply g to f and 7?
14:32:51 <monochrom> maybe g is infix like mod
14:32:57 <monochrom> can you be sure?
14:33:21 <yenda> thats why i didnt like x `mod` 7 in the first place
14:33:34 <monochrom> do you want "x mod 7"?
14:33:47 <glguy> x` mod `7 ?
14:33:57 <monochrom> recall that "mod" is not a reserved word. what can be called "mod", can easily be called "g".
14:34:45 <yenda> no i like mod x 7 :D
14:34:57 <monochrom> ok, you can do that
14:35:02 <quchen> monochrom: To be fair, Scala allows stuff in that spirit, so some people might expect this kind of behaviour.
14:37:22 <monochrom> I do not oppose it. instead, my series of questions are designed to force the answerer to be self-consistent (or expose inconsistency)
14:38:17 <monochrom> and they are questions, not assertions, because I am fine with several choices, at least for the first few questions.
14:41:56 <yenda> actually I got it when glguy talked about operators, backquotes made sense that way
14:42:13 <yenda> coming from lisp I'm not a big fan of it but it's nice to know that it's there
14:42:55 <ReinH> god the `parsers' library is hard to google for
14:43:08 <srhb> ReinH: Needs more search bubble.
14:43:12 <glguy> At least while you're starting out it might be good to avoid allowing yourself too many opinions about how things should be. Then once you have a better handle on everything you can start deciding what you like and now :)
14:43:27 <glguy> s/and now/or not/
14:44:11 <ReinH> I'm trying to figure out how to wrote a parser for a particular comment style https://hackage.haskell.org/package/parsers-0.12.1.1/docs/Text-Parser-Token-Style.html
14:44:14 <ReinH> *write
14:44:41 <ReinH> But I can't figure out how to write the rest of the typeclass member funcs because you can't just inherit part of some other instance
14:45:00 * hackagebot aws 0.11.4 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.11.4 (AristidBreitkreuz)
14:45:37 <ReinH> Like, how do I use buildSomeSpaceParser properly?
14:46:07 <ReinH> Oh cool johnw_ did something I can steal https://github.com/jwiegley/hnix/blob/master/Nix/Parser/Library.hs
14:49:18 <sagittarian> haskell lists are immutable, right?
14:49:36 <tulcod> sagittarian: everything is immutable
14:49:57 <sagittarian> so why can't the runtime keep track of how many times it has consed something onto a list and make length xs a constant time operation?
14:49:59 <tulcod> (in a very particular sense that does not imply that you cannot have anything "change" in haskell)
14:50:00 * hackagebot flamingra 0.1.0.0 - FlameGraphs of profiling  http://hackage.haskell.org/package/flamingra-0.1.0.0 (AntonNikishaev)
14:50:18 <Cale> sagittarian: Because it doesn't construct lists in that order.
14:50:27 <Cale> sagittarian: Evaluation is outermost-first.
14:50:29 <sagittarian> oh right
14:50:51 <Cale> like with  ones = 1 : ones
14:51:00 <sagittarian> yeah, obviously
14:51:01 <sagittarian> thanks
14:51:56 <tulcod> i want a certain type class to expose a constant value of type Int. can i somehow guarantee with type signatures that this value is constant?
14:52:16 <Cale> sagittarian: There is a very controlled kind of mutation which lazy evaluation provides -- you're reducing expressions to values and replacing the corresponding parts of data structures with the result.
14:52:17 <ion> tulcod: Haskell has mutable things, only Haskell values are immutable.
14:52:35 <tulcod> the naive way of asking for a constant is to say "class myClass a where myConstant :: a -> Int", but now myConstant may depend on the input variable
14:53:34 <ion> tulcod: You could use myThing :: proxy a -> Int
14:53:46 <Cale> yeah
14:53:46 <sagittarian> well wait, if the runtime were to keep track of the length of lists, then when i ask it for the length of an infinite list it will obviously get permanently busy
14:53:58 <sagittarian> but that's no different from length xs when xs is an infinite list now
14:54:46 <Cale> sagittarian: Well, there's not much difference between lazily computing lengths and putting that information in the cons cells from just not computing lengths
14:54:51 <sagittarian> so obviously if I say length xs but xs hasn't actually been constructed yet, then it will have to construct the list in order to find out the answer, which will be linear time
14:54:54 <Cale> sagittarian: consider something like  permutations xs
14:55:04 <tulcod> ion: "proxy" as in Data.Proxy?
14:55:27 <Cale> tulcod: Yeah -- you don't actually have to use the Proxy type, you can just have it be a variable type constructor
14:55:46 <Cale> class MyClass a where myConstant :: p a -> Int
14:55:58 <ClaudiusMaximus> it's more convenient to leave it variable, so you can use [] or Maybe as well as Proxy
14:56:28 <ion> tulcod: "proxy" as in anything of kind * -> *, the caller can choose it to be Data.Proxy.Proxy.
14:56:40 <Cale> myConstant gets a value of type p a, it doesn't actually have access to any particular value of type a, and since it doesn't know which type constructor p is, it can't inspect anything there either.
14:57:00 <tulcod> but now how do I call myConstant?
14:57:22 <monochrom> myConstant (Just False)
14:57:30 <tulcod> oh right. that makes too much sense.
14:57:35 <tulcod> nice
14:57:35 <ion> myConstant (Proxy :: Proxy Foo)
14:57:44 <monochrom> mine is a degenerate example
14:58:25 <monochrom> but it's shorter than the production code example, Proxy :: Proxy Bool
14:58:31 <Cale> You can even pass undefined with a reasonable level of safety. As long as the definition of myConstant doesn't seq its parameter for no reason, that'll work.
14:58:52 <ion> Just is useful if you have a value of the desired type.
14:59:02 <Cale> Or an empty list :)
14:59:12 <Cale> Or a list of length 1
14:59:18 <Cale> Whatever you have on hand :)
14:59:36 <shachaf> Proxy works even for kinds other than *.
14:59:41 <Cale> Yeah
15:00:21 <tulcod> i think for my purpose i'll just leave it an abstract kind variable
15:00:29 <monochrom> I propose a syntax change in Haskell. so that {} is a reserved word. its semantics is Proxy.
15:00:44 <tulcod> ie: class MyClass a where myConstant :: p a -> Int
15:00:53 <monochrom> oh wait, I have a cunning plan
15:01:32 <monochrom> define a class in Prelude, "class Singleton a where () :: a"
15:01:47 <ion> I'd still like to have (:: A) = (\x -> x :: A)
15:02:05 <monochrom> accompanied by the syntax change: () is a reserved word for that method name
15:02:23 <tulcod> ion: then you might as well define (::)
15:02:31 <monochrom> the unit type is an instance of Singleton. another instance is Proxy a.
15:03:15 <monochrom> then when you write "()" at the value level, it can stand for the unit value, or it can stand for the Proxy value
15:04:30 <monochrom> like all cunning plans, this has many flaws.
15:05:06 <monochrom> so if you find some, please just have a good laugh :)
15:10:00 * hackagebot sdl2-ttf 0.2.1 - Binding to libSDL2-ttf  http://hackage.haskell.org/package/sdl2-ttf-0.2.1 (schalmers)
15:23:54 <ReinH> Ok. I figured it out. Parsers is awesome.
15:25:40 <ReinH> monochrom: and they gang aft agley?
15:28:28 <ReinH> In other news, I'm very glad that pretty-show exists
16:00:01 * hackagebot infernu 0.0.0.1 - Type inference and checker for JavaScript (experimental)  http://hackage.haskell.org/package/infernu-0.0.0.1 (NoamLewis)
16:36:11 <SrPx> Can I politely ask GHC to print error messages on the reverse order? I always have to scroll up to find the first errors, that is unproductive. 
16:37:56 <HaskellStudent81> Hi, I'm trying to learn Haskell as part of the CS program I'm in, but I'm having a bit of trouble. Can anyone answer some basic questions?
16:38:05 <mniip> SrPx, 2>&1|tac
16:38:20 <mniip> HaskellStudent81, don't ask to ask
16:38:23 <geekosaur> just ask your questions
16:38:43 <HaskellStudent81> well right now I'm looking at this
16:38:56 <HaskellStudent81> Write a function that takes a string and returns True if the string is "hello" and False otherwise. This can be done by specifying each element of the string in the list pattern (e.g. ’h’:’i’:[] )
16:39:08 <HaskellStudent81> when I try to pattern match that way it doesnt like it
16:39:15 <Welkin> so you want us to do your homework
16:39:17 <mniip> that sounds awfully inefficient but carry on
16:39:35 <mniip> HaskellStudent81, what is the code you have
16:39:43 <HaskellStudent81> is_hello :: String -> Bool is_hello ['h':'e':'l':'l':'o' : [] ] = True is_hello x = False
16:39:58 <mniip> why the extra [] around that
16:40:06 <Welkin> that is [String]
16:40:08 <Welkin> not String
16:40:13 <HaskellStudent81> ooh
16:40:21 <mniip> > 'h':'e':'l':'l':'o' : []
16:40:22 <lambdabot>  "hello"
16:40:24 <mniip> > ['h':'e':'l':'l':'o' : []]
16:40:25 <lambdabot>  ["hello"]
16:40:28 <Welkin> you can just check for "hello"
16:40:35 <SrPx> mniip: I don't have tac but won't that reverse every line
16:40:36 <HaskellStudent81> a String is a list of chars so I thought I needed it
16:40:36 <mniip> Welkin, ssh! that's homework
16:40:46 <mniip> SrPx, no, that would be rev
16:41:02 <HaskellStudent81> I got it to work with "hello" but I wanted to get the example to work also
16:41:05 <mniip> HaskellStudent81, 'h' 'e' 'l'... are the chars
16:41:17 <SrPx> okay, how do I use it, though? "ghc .... | 2>&1|tac"? 
16:41:19 <mniip> and 'h':'e':... is a list of chars
16:41:34 <Welkin> : is the list constructor
16:41:38 <mniip> SrPx, no pipe before 2>&1
16:41:46 <HaskellStudent81> right, but [1,2,3] is a list of nums, so I thought ['a','b','c'] woud be a list of chars
16:41:52 <geekosaur> exactly
16:41:53 <mniip> correct
16:41:54 <Welkin> HaskellStudent81: it is
16:41:59 <mniip> but [1,2,3] is also 1:2:3:[]
16:42:00 <geekosaur> a String is a list of Char
16:42:09 <Welkin> String = [Char]
16:42:21 <HaskellStudent81> so wait then why didnt my code work?
16:42:31 <Welkin> you constructed a list inside of the list
16:42:35 <mniip> because you wrote [1:2:3:[]] and not 1:2:3:[]
16:42:59 <Welkin> ['a', 'b', 'c'] is not the same as ['a':'b':'c':[]]
16:43:35 <HaskellStudent81> is_hello :: String -> Bool is_hello ['h':'e':'l':'l':'o' ] = True is_hello x = False 
16:43:37 <HaskellStudent81> doesnt work either
16:43:51 <mniip>  the last has to be []
16:43:58 <glguy> : and , are different
16:43:59 <mniip> also you put the extra [] again
16:44:06 <Welkin> HaskellStudent81: do you know about the type system?
16:44:13 <HaskellStudent81> yes
16:44:15 <HaskellStudent81> somewhat anyway
16:44:27 <HaskellStudent81> ok I think i get it
16:44:29 <Welkin> you can check this yourself
16:44:45 <mniip> HaskellStudent81, open ghci
16:44:50 <Welkin> in fact, if you read the errors you got when trying to compile your function, you would have immediately known the problem
16:44:55 <mniip> experiment with : until you get "hello" to display
16:45:02 <geekosaur> one thing to note is you generally need parentheses
16:45:05 <SrPx> HaskellStudent81: ... (a : b : []) is the same as [a,b] ... so [(a : b : [])], which you typed, is the same as[[a,b]] ... there is a extra list there and that's it. Just use parens instead of [ ] ...
16:46:07 <rola> > 'h':'i':'!':[] == "hi!"
16:46:08 <lambdabot>  True
16:46:11 <rola> > ['h':'i':'!':[]] == ["hi!"]
16:46:13 <lambdabot>  True
16:46:28 <HaskellStudent81> is_hello :: String -> Bool is_hello ['h','e','l','l','o' ] = True is_hello x = False
16:46:30 <HaskellStudent81> I got it
16:46:46 <HaskellStudent81> it was the commas instead of colons that I was hung up on
16:46:48 <geekosaur> ,,,no
16:46:55 <geekosaur> oh, yes
16:47:04 <mniip> well your task asked for : as I get it
16:47:04 <geekosaur> not quite what you were originally saying
16:47:19 <mniip> try to rewrite it using :
16:47:49 <HaskellStudent81> 'h':'e':'l':'l':'o':[]
16:47:58 <HaskellStudent81> right?
16:48:04 <Cale> HaskellStudent81: Yeah, ['h','e','l','l','o'] and "hello" and 'h':'e':'l':'l':'o':[] and 'h':('e':('l':('l':('o':[])))) are all ways of writing the same thing
16:48:07 <Welkin> test it
16:48:27 <mniip> HaskellStudent81, right
16:48:44 <Cale> > 'h':('e':('l':('l':('o':[]))))
16:48:46 <lambdabot>  "hello"
16:48:51 <mniip> but to use it in a function argument pattern, you need parentheses around it
16:48:54 <geekosaur> you will probably need some parentheses because of the way Haskell parses it, though
16:49:08 <Cale> > let f "hello" = True; f _ = False in f "holla"
16:49:09 <lambdabot>  False
16:49:12 <Cale> > let f "hello" = True; f _ = False in f "hello"
16:49:14 <lambdabot>  True
16:49:16 <geekosaur> foo ('h':'e':'l':'l':'o':[])
16:50:28 <HaskellStudent81> is_hello :: String -> Bool is_hello ('h':'e':'l':'l':'o':[]) = True is_hello x = False
16:50:32 <HaskellStudent81> got it to work with that also
16:50:40 <HaskellStudent81> thanks guys, that helped 
16:50:44 <SrPx> :t deleteBy
16:50:45 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
16:50:48 <SrPx> wtf?
16:50:56 <SrPx> I was expecting (a → Bool) → [a] → [a]
16:50:57 <enthropy> Data.List.stripPrefix is nice for that in "real code"
16:51:21 <SrPx> as in "delete the first element satisfying a predicate". The heck it does?
16:51:36 <glguy> Did you check the haddock?
16:51:46 <Cale> SrPx: You provide the "equality testing" predicate
16:52:02 <Cale> SrPx: It does the same thing as delete, only you say what to use in place of (==)
16:52:06 <Welkin> HaskellStudent81: we are not all "guys"
16:52:10 <SrPx> Yes it just says: "The deleteBy function behaves like delete, but takes a user-supplied equality predicate." not helpful
16:52:15 <Cale> Welkin: Everyone is a "guy"
16:52:38 <Cale> Welkin: You've never heard "guys" used in a gender non-specific way?
16:52:58 <davidshore> :t guys
16:52:59 <lambdabot> Not in scope: ‘guys’
16:53:17 <glguy> Sounds like off topic noise
16:53:49 <Welkin> Cale: is your mother a "guy"?
16:54:25 <mniip> @let guys = guys
16:54:27 <lambdabot>  Defined.
16:54:48 <mniip> Welkin, "guy" and "guys" are differnet things
16:55:02 <mniip> second is a collective plural noun
16:55:11 <mniip> so the gender-highlighting role is much relaxed
17:05:01 * hackagebot atlassian-connect-core 0.5.0.1 - Atlassian Connect snaplet for the Snap Framework and helper code.  http://hackage.haskell.org/package/atlassian-connect-core-0.5.0.1 (RobertMassaioli)
17:10:55 <HaskellStudent81> so to write a function that removes a space from the beginning of a string, both of these seem to work fine: 
17:11:00 <HaskellStudent81> delSpace (' ':xs) = xs delSpace x = x
17:11:08 <HaskellStudent81> delSpace (' ':xs) = xs delSpace xs= xs
17:11:16 <mniip> they are the same
17:11:25 <HaskellStudent81> I'm wondering why are they the same?
17:11:34 <HaskellStudent81> how come Haskell doesnt care?
17:12:13 <mniip> simple explanation: you're saying that 'xs' is the argument and then saying that the result is also 'xs'
17:12:18 <mniip> you could use any other variable name in there
17:12:39 <mniip> (the two lines of definition of 'delSpace' aren't related in that aspect)
17:12:48 <HaskellStudent81> ok, so only in the context of (x:xs) does xs have a special meaning?
17:12:50 <mniip> complex explanation: alpha equivalence
17:12:52 <jle`> the formal name is called "alpha equivalence"
17:12:56 <jle`> oh darn
17:13:07 <jle`> you can pick any name for your variables
17:13:09 <HaskellStudent81> or could (x:xs) also be written as (a:b) ?
17:13:12 <mniip> yes
17:13:16 <HaskellStudent81> ooh ok
17:13:26 <mniip> as long as you put b after the =
17:13:34 <mniip> (in place of xs)
17:13:44 <HaskellStudent81> see I'm used to Java and the way Haskell works is just so different it confuses me
17:13:50 <jle`> there is one thing about haskell...you can't use identifiers that start with a capital letter as variables
17:13:58 <jle`> so (x:xs) is different than (x:Xs)
17:14:22 <jle`> you can pick a name as long as it's lowercase/alphanumeric/_/', and begins with a lowercase letter
17:14:24 <mniip> HaskellStudent81, in java you can also use different kinds of names in function arguments
17:14:37 <mniip> int f(int x) { return x; }
17:14:38 <Welkin> but in erlang, they must begin with a capital letter
17:14:50 <mniip> int f(int foo) { return foo; }
17:15:31 <mniip> (that's java, right?)
17:15:38 <HaskellStudent81> I know miip, but the syntax in Haskell is different so looking at examples I sometimes don't realize what I'm looking at is just a variable name, since they aren't declared like they are in java
17:15:44 <HaskellStudent81> yeah that would work in java :)
17:15:45 <mniip> syntax pfft
17:15:53 <mniip> syntax is the least thing you should care about
17:16:06 <HaskellStudent81> lol?
17:16:10 <jle`> syntax might be the first thing you should care about....just so that you can forget about it as soon as possible
17:16:12 <jle`> and look past it
17:16:16 <jle`> heh
17:16:21 <SrPx> What is the simplest way to start an interactive command line application (the user types a letter and it "refreshes" the terminal). I want that for visualization purposes, no need to be complex
17:16:22 <mniip> does haskell happen to be your second language? (after java)
17:16:22 <jle`> you need to know it first :p
17:16:34 <HaskellStudent81> that's where I'm at now, is trying to learn the syntax so I can forget it haha
17:16:36 <Welkin> variables in haskell are like variables in math
17:16:42 <Welkin> not like in java
17:16:50 <jle`> SrPx: you can use getChar/getLine and clrScreen
17:16:53 <HaskellStudent81> well I've done a bit of Java and C++ and Javascript, so Haskell is my first functional language
17:16:58 <jle`> that'd be the simplest way...i've done it....
17:17:06 <jle`> the next level would be bindings to something like curses
17:17:11 <SrPx> jle`: yea that would do it actually, will getChar work without <return> ?
17:17:14 <mniip> well then you should understand that syntactic differences aren't the hardest part
17:17:19 <jle`> you might need to change your buffering mode
17:17:33 <abayley> anyone know how to use fast-logger? Trying to figure out how to get a rotating file logger.
17:17:35 <jle`> you know about buffering in unixy systems right?
17:17:39 <geekosaur> on unixlikes you'd have to either run from ghci/runhaskell or use termios to switch the terminal mode
17:17:39 <SrPx> no :(
17:18:18 <SrPx> hmm..
17:18:24 <jle`> usually stdin will only be "sent" to the program that's reading stdin in chunks
17:18:39 <jle`> the buffering mode is what sets how this chunking/sending works
17:18:55 <sagittarian> can anyone give me some kind of a hint as to what I'm missing here? Can anyone give me a hint as to what I'm missing here? http://lpaste.net/130922
17:18:57 <jle`> normal buffering mode is...wait to send anything until a newline is seen.  then send it all at once
17:19:06 <jle`> but you can set buffering modes that are 'send all characters, as they come'
17:19:29 <sagittarian> I'm trying to write a DFA that will recognize the regex /ing$/, and the compiler is griping on line 34 because I used a Char instead of a Letter (I guess)
17:19:37 <sagittarian> even though I declared instance Letter Char
17:19:57 <mniip> sagittarian, paste the error too
17:20:47 <geekosaur> jle`, buffering mode is only half of it. tty devices also have a "buffering" mode independent of the program
17:21:06 <jle`> life is complicate :|
17:21:20 <sagittarian> here's the error: http://lpaste.net/130922
17:21:27 <geekosaur> and ghci and runhaskell default it differently from ghc
17:21:53 <glguy> sagittarian: Your definition of "transition" has to work for ALL Letter types, not for a particular one
17:22:09 <geekosaur> sagittarian, the fact that you have only one instance there for Letter does not mean that is the only possible instance
17:22:15 <glguy> sagittarian: The fact that you have a class Letter with now methods suggests you might have the wrong idea about type classes
17:22:21 <SrPx> well
17:22:27 <sagittarian> okay, I understand, but how can I solve that?
17:22:33 <SrPx> so "hSetBuffering stdin NoBuffering" ...
17:22:57 <sagittarian> at first I didn't even have a Letter class but then the transition function has to work for all types period
17:23:14 <SrPx> :)
17:23:16 <glguy> sagittarian: You could add a method to your Letter class that turns things into Chars
17:23:22 <SrPx> nailed, thanks
17:23:24 <mniip> sagelywizard, here's your problem
17:23:26 <glguy> class Letter a where letterAsChar :: a -> Char
17:23:38 <mniip> the typeclass says that the function should take all kinds of Letter
17:23:41 <mniip> you only take Char's
17:24:22 <sagittarian> but then anyone who implemented Letter would have to provide a letterAsChar function, what if I want it to be more general than that?
17:24:32 <mniip> that's what it means when it says "Could not deduce (a ~ Char) from the context (Letter a)"
17:24:51 <jle`> SrPx: that's worked for me :3 that won't work on things like ghci and stuff.  and you might get complications going cross platform...i'm not sure, you might want to look into it more deeply befre taking my word for it :)
17:24:59 <mniip> sagittarian, you could solve this with MultiParamTypeClasses
17:25:06 <sagittarian> okay, I understand the error, but I don't understand how I can fix it without requiring that typeclass StateSet work only with Chars or with something that maps to Chars
17:25:11 <SrPx> a quick question, I have found no reliable way to clear the terminal... putStr "\ESC[2J" doesn't have the effect I want (it makes the text be placed in different positions each time)
17:25:20 <sagittarian> ah extensions, I knew it :-)
17:25:25 <mniip> "class StateSet s l" where s is the state and l is the letters it operates on
17:25:32 <SrPx> jle`: no problems, I just wanted a quick visualization tool here :) this will be removed anyway
17:25:40 <mniip> much like "class MonadState m s"
17:26:00 <geekosaur> SrPx: "\ESC[H\ESC[J"
17:26:00 <mniip> might also want to add FunctionalDependencies and | s -> l
17:26:20 <sagittarian> mniip: and MonadState uses MultiParamTypeClasses also?
17:26:26 <geekosaur> 2J is defined to leave the cursor where it is
17:26:38 <mniip> sagittarian, yes
17:26:40 <jle`> SrPx: there should be something in the same module as wherever you found hSetBuffering
17:26:43 <exio4> sagittarian: you basically don't need a typeclass
17:26:47 <sagittarian> okay, thanks, I'll check that out
17:26:51 <exio4> sagittarian: but just a datatype with functions
17:27:15 <SrPx> geekosaur: thanks this will be labelled geekosaursTerminalCleaningWitchcraft
17:27:18 <geekosaur> no, I doubt that module includes clear-screen, that's what curses/terminfo/vty is for
17:27:24 <davidshore> is there a ranking of language extensions by popularity somewhere?
17:27:43 <jle`> huh i don't remember ever having to use those
17:27:46 <jle`> let me see
17:28:02 <geekosaur> win32 probably has a clear-screen
17:28:14 <jle`> oh yeah, my bad.
17:28:23 <jle`> i've used ansi-terminal
17:28:31 <geekosaur> right, that would work
17:31:51 <exio4> sagittarian: you could have something like data DFA s a = DFA { accepted :: s -> Bool; delta :: s -> a -> s } and a function like runDFA :: DFA s a -> s -> [a] -> Bool or similar 
17:33:59 <sagittarian> exio4: so it's not even a typeclass?
17:34:27 <exio4> sagittarian: a typeclass doesn't feel like a nice solution for this (at least for me)
17:34:45 <lpaste> glguy annotated “DFA for matching /ing$/” with “DFA for matching /ing$/ (annotation)” at http://lpaste.net/130922#a130924
17:34:56 <glguy> sagittarian: I'm apparently inclined to agree with exio4
17:37:12 <enthropy> davidshore: http://www.reddit.com/r/haskell/comments/31t2y9/distribution_of_ghc_extensions_on_hackage/
17:38:00 <enthropy> but that count is a bit misleading because it's what gets enabled, and not what people request to be enabled
17:41:48 <davidshore> enthropy: cool, thanks!
17:42:43 <augur> i wonder if type class existentials can be seen as capturing OO classes
17:43:11 <augur> like..   data Class c = forall a. c a => Instance a
17:43:31 <augur> using constraint kinds, obviously
17:44:00 <sagittarian> thanks guys for the help
17:44:12 <divVerent> !pl \ a -> f a >>= g a
17:44:23 <arkeet> liftA2 (>>=)
17:44:38 <arkeet> @pl \ a -> f a >>= g a
17:44:38 <lambdabot> liftM2 (>>=) f g
17:44:44 <divVerent> ah right
17:44:48 <enthropy> augur: I think we're missing an "instance c (Class c) though"
17:44:49 <arkeet> except use liftA2 instead.
17:44:52 <Zekka>    glguy: Thanks for the super terse DFA regex example
17:45:09 <augur> enthropy: why? no. you wouldnt do that
17:45:12 <Zekka> have been meaning to learn about it
17:45:17 <glguy> Zekka: Thank sagittarian, I just made it a data type :)
17:45:31 <Zekka> Oh fine you're OK too sagittarian 
17:45:41 <enthropy> augur: I mean you have to pattern match on Instance to get the instances in scope
17:46:02 <augur> enthropy: yes
17:46:18 <enthropy> but I think that step is implicit in normal OOP languages
17:47:13 <augur> enthropy: well, or you could define some generic accessors like...    getX :: Class c -> Int   ;   getX (Instance s) = getX_ s
17:48:04 <augur> this is silly for those sorts of things, but less silly for modelling OO, i think
17:48:37 <augur> type OOList c = [Class c]
17:48:57 <enthropy> f (Instance x) (Instance y) = Instance (x+y) -- how do you deal with this?
17:49:00 <augur> actually no, you dont need generic accessors like that
17:50:44 <SrPx> Read a => String -> Maybe a ... anyone?
17:50:51 <exio4> readMaybe 
17:50:52 <SrPx> could only find it on a network library o.O
17:50:57 <exio4> @type readMaybe
17:50:59 <lambdabot> Not in scope: ‘readMaybe’
17:51:01 <augur> you need this:   (.~) :: Class c -> (forall a. c a => a -> b) -> b    or something like that
17:51:04 <SrPx> see
17:51:06 <exio4> @readMay
17:51:06 <lambdabot> Unknown command, try @list
17:51:09 <exio4> uh
17:51:15 <arkeet> it's readMaybe
17:51:15 <augur> Instance s .~ method = method s
17:51:16 <arkeet> from Text.Read
17:51:19 <exio4> Text.Read.readMaybe
17:51:27 <exio4> I thought lambdabot had it
17:51:31 <arkeet> @let import Text.Read
17:51:33 <lambdabot>  Defined.
17:51:36 <arkeet> :t readMaybe
17:51:38 <lambdabot> Read a => String -> Maybe a
17:51:41 <SrPx> interesting, thanks... why Hoogle didn't find it?
17:51:44 <augur> enthropy: im not sure what you mean by that example
17:51:45 <arkeet> it shold
17:51:59 <SrPx> https://www.haskell.org/hoogle/?hoogle=maybeRead
17:52:28 <arkeet> it's readMaybe, not maybeRead
17:52:40 <arkeet> http://hoogle.haskell.org/?hoogle=Read+a+%3D>+String+->+Maybe+a&scope=set%3Astackage
17:53:38 <SrPx> ooh woops. My bad
17:53:51 <srhb> SrPx: Presumably the main hackage doesn't yet index 4.6? That's weird though.
17:54:18 <arkeet> base 4.6 is old though
17:54:20 <arkeet> ghc 7.6
17:54:21 <enthropy> augur: can you make that type of thing work?
17:54:30 <augur> enthropy: sure, why not?
17:54:38 <arkeet> but I guess old hoogle is that old
17:54:43 <srhb> arkeet: Indeed, but that's how it looks.
17:54:50 <arkeet> hayoo finds it
17:55:22 <enthropy> augur: well when I write "f :: Class Num -> Class Num -> Class Num", I get an error regarding Couldn't match expected type ‘a’ with actual type ‘a1’
17:55:36 <arkeet> indeed
17:55:49 <enthropy> so I think there needs to be some kind of cast
17:56:08 <arkeet> you have two types that have Num instances
17:56:15 <arkeet> nothing guarantees that they're the same type
17:56:27 <usr> what is a haskell
17:56:30 <exio4> you'd have all functions in multiparam typeclasses
17:56:30 <augur> enthropy: well of course no
17:56:30 <usr> ?
17:56:50 <augur> enthropy: the two existential types arent guaranteed to be the same
17:57:28 <augur> enthropy: this is the same as doing   (Num a, Num b, Num c) => a -> b -> c
17:57:52 <enthropy> augur: right but can we get some kind of cast to a least upper bound in the hierarchy of types?
17:58:03 <arkeet> there is no hierarchy of types.
17:58:09 <exio4> the idea is that a function of that type, would actually be something like f :: NumF a b c => a -> b -> c
17:58:14 <enthropy> we're modeling an "OOP language" here I think
17:58:15 <arkeet> there is no subtyping.
17:58:20 <augur> enthropy: al thats a good question
17:58:21 <exio4> that's the nicer way I could think for modeling that here
17:58:54 <enthropy> arkeet: I'm trying to show that "data Class c = forall a. c a => Instance a" is inadequate
17:59:03 <arkeet> you just did.
17:59:05 <augur> enthropy: i dont know. then again, i dont know how OO normally does this either
17:59:51 <augur> what's a non-num-y example of this, enthropy
17:59:55 <augur> just in normal OO
18:00:21 <augur> because i think you're trying to treat Class Num differently than I intended
18:00:31 * enthropy doesn't know
18:01:13 <augur> the intention here is, the type class's variable represents the hidden internal state of objects
18:01:30 <augur> its whatever goes on inside an object that you cant see from the outside
18:01:49 <arkeet> this is interesting. https://hackage.haskell.org/package/objective
18:02:06 <augur> so Class Num isn't really how its intended, since there the argument of Num _is_ the relevant stuff
18:02:15 <augur> its not some hidden internals
18:03:41 <exio4> augur: we'd have a different Num instance, too 
18:20:28 <dressguard> @type map
18:20:29 <lambdabot> (a -> b) -> [a] -> [b]
18:20:57 <dressguard> @instances MonadPlus
18:21:00 <lambdabot> Alt f, Either e, IO, Maybe, ReadPrec, Seq.Seq, []
18:27:13 <blast_hardcheese> In attoparsec, how should I create a Parser of [a] that provides the previously accumulated values to the next parser?
18:27:37 <blast_hardcheese> I'm trying to write a PNG file parser, I need to reference previously parsed data chunks: https://gist.github.com/blast-hardcheese/c3793fb242f41095f447
18:28:29 <blast_hardcheese> I'd love to turn this into a many', but I'm not even really sure what this should look like
18:32:09 <blast_hardcheese> Actually, I just realized, this should be sequence $ fmap
18:32:14 <blast_hardcheese> err, foldl
18:33:57 <HaskellStudent81> can anyone tell me what is wrong with this
18:33:58 <HaskellStudent81> maybeAdd :: [Maybe Int] -> [Maybe Int] -> [Maybe Int] maybeAdd [x] [y] = zipWith (maybeComp) [x] [y]  maybeComp :: Maybe Int -> Maybe Int -> Maybe Int maybeComp (Just x) (Just y) = Just(x+y) maybeComp (Just x) Nothing = (Just x) maybeComp Nothing (Just y) = (Just y) maybeComp Nothing Nothing = Nothing
18:35:26 <blast_hardcheese> HaskellStudent81: Please create a gist
18:35:28 <geekosaur> @paste
18:35:28 <lambdabot> Haskell pastebin: http://lpaste.net/
18:35:38 <geekosaur> that's too difficult to decipher all jammed into one line
18:36:04 <shachaf> Especially without semicolons.
18:37:00 <pavonia> HaskellStudent81: Also paste the error message if you get one or clarify why do you think there's something wrong with it
18:37:27 <HaskellStudent81> thanks, http://lpaste.net/130926
18:37:50 <HaskellStudent81> *** Exception: maybeAdd.hs:2:0-45: Non-exhaustive patterns in function maybeAdd
18:38:09 <HaskellStudent81> trying to add two lists of maybe ints and create a new list of results
18:38:32 <pavonia> What is the actual input?
18:38:34 <kaw_> You're pattern-matching for single-element lists as arguments to maybeAdd
18:38:52 <HaskellStudent81> so I should say [x:xs] ?
18:39:00 <HaskellStudent81> I tried that and it didnt like it
18:39:30 <blast_hardcheese> This isn't a "just do this" kind of fix
18:39:42 <geekosaur> you are still confused about how list patterns work, apparently
18:39:44 <HaskellStudent81> it compiles and will add single element lists so I figured it was something like that
18:39:50 <geekosaur> think back to the last one
18:40:00 <HaskellStudent81> I'm still confused about Haskell :P
18:40:12 <HaskellStudent81> ok
18:41:26 <HaskellStudent81> I don't see the connection...
18:42:54 <pavonia> [x] is a pattern for a list with a single element
18:43:19 <HaskellStudent81> I tried it with [x:xs] and got an error, I'll try again
18:44:15 <pavonia> That's a list with a single element, which in turn is a list with a first element x and a rest list xs
18:45:38 <pavonia> HaskellStudent81: Can you think of a pattern that matches any list?
18:46:41 <HaskellStudent81> [...]?
18:47:11 <pavonia> No, that's not legal syntax
18:48:52 <pavonia> Maybe an easier one: What would be a pattern that matches any number?
18:50:26 <HaskellStudent81> I got it
18:50:39 <HaskellStudent81> I just needed to say x and y rather than [x] and [y]
18:51:11 <pavonia> Yup
18:51:14 <HaskellStudent81> thank you
19:01:46 <srhb> HaskellStudent81: We often call them xs and ys (think of them as plural forms, like cats!) to make the distinction clearer for the reader. :)
19:02:19 <shachaf> all the x's are out of the bag
19:02:25 <srhb> as they should be!
19:07:20 <blast_hardcheese> so, I'm pretty sure I need an attoparsec parser that acts like a many, but with the signature of MonadPlus m => ([a] -> m a) -> m [a]
19:08:14 <blast_hardcheese> effectively sequence $ foldl, but inside a Parser.
19:09:50 <blast_hardcheese> Is there something that does something like this that I should know about, or is this a "please don't do this, we don't offer this for a reason" type of situation?
19:10:21 <pavonia> Maybe you want a foldM?
19:11:01 <glguy> blast_hardcheese: I'm struggling to guess what that would do. Do you have an example of what you're trying to parse that you can share?
19:11:44 <blast_hardcheese> glguy: https://gist.github.com/blast-hardcheese/c3793fb242f41095f447
19:11:58 <blast_hardcheese> Trying to parse an arbitrary number of chunks of a PNG file
19:12:31 <blast_hardcheese> pavonia: foldM looks promising, trying to wrap my brain around how to make it consume until the end
19:13:08 <blast_hardcheese> maybe just fold over an infinite list and wait for the parse to fail?
19:14:13 <blast_hardcheese> What I probably should have done was parse the chunk data out first, then actually parse the structure in a different parse attempt after the fact
19:14:42 <blast_hardcheese> It just feels like the "right way" would be to attempt to parse everything in one go.
19:14:48 <pavonia> Isn't the number of parses static?
19:15:08 <blast_hardcheese> pavonia: No, and worse, they can be in any order
19:15:22 <blast_hardcheese> but some chunks need metadata from other chunks
19:15:31 <pavonia> Oh dear
19:15:39 <blast_hardcheese> so I need to make sure IHDR is available before IDAT and such.
19:16:24 <pavonia> Parsec has a user state that could be used for that
19:16:45 <blast_hardcheese> Yeah, I've used that in the past, it's quite nice
19:17:10 <blast_hardcheese> I was kind of surprised attoparsec didn't have something similar
19:18:14 <glguy> blast_hardcheese: It appears that every chunk has a uniform header describing how big the chunk is, so you'll be able to "chunk" the file without regard for any context
19:18:42 <glguy> and then you can process those chunks in a separate phase, even the chunking and processing happen to be interleaved due to laziness
19:20:29 <blast_hardcheese> glguy: Yeah, I was just hoping to not have to do that. It does seem like the more resiliant approach though, so I should just refactor and proceed with that approach.
19:20:35 <blast_hardcheese> Thanks for the advice
19:24:28 <davidshore> is there a tool that lets you easily add a dependency to your cabal file without editing it directly?
19:26:13 <arkeet> davidshore: it's not that hard to do it manually is it?
19:26:37 <glguy> Whether or not it's necessary I haven't heard of such a tool
19:27:13 <davidshore> arkeet: it takes longer than i'd like
19:27:38 <glguy> blast_hardcheese: Since you know the header chunk is first you can always do: do hdr <- getHeaderChunk; rest <- many (getChunk (stuffYouneededFromtheheader hdr)); ...
19:27:53 <arkeet> anyway, I am also not aware of such a tool.
19:27:56 <arkeet> maybe you should write one :-)
19:28:39 <enthropy> `cabal init' figures out the dependencies
19:28:48 <enthropy> but it'll overwrite your existing file
19:30:36 <davidshore> how does it figure them out? couldn't there be some abiguity?
19:35:11 <blast_hardcheese> glguy: That's actually a really good idea
19:36:00 <enthropy> davidshore: I think it just looks at what packages ghc loads when importing your Main
19:36:34 <enthropy> but of course there could be ambiguity (which is why sometimes you will have ghci complain about two packages providing the same module)
19:37:33 <davidshore> I see
19:43:24 <kaw_> Are Chan and/or TChan appropriate for inter-thread communication that is meant to be nearly real-time?
19:43:59 <kaw_> I'm seeing delays of around 700ms-1.2s, is there anything I might be doing wrong or am I just using the wrong tool?
19:44:08 <Cale> That sounds insane
19:44:18 <Cale> It should be much much faster than that
19:44:35 <Cale> How are you measuring the delay?
19:45:15 <Cale> Note that it is possible for the readers to get behind
19:46:12 <Cale> The contents of the Chan are unbounded, so if the writer is writing faster than the reader is reading, the elements that the reader is looking at will gradually get older and older.
19:46:12 <kaw_> I threw in a putStrLn of getUnixTime by the writeTChan and by the readTChan
19:46:49 <kaw_> Hm, it's not writing very quickly at all, it's just reacting to a keypress
19:47:29 <Cale> http://lpaste.net/ -- could you put your test program here?
19:48:21 <kaw_> I'll try to whittle it down a bit first.. I'm probably doing something wrong
19:56:57 <Cale> kaw_: I just wrote a program to measure the delay between a single Chan write/read (by writing the current UTCTime into the Chan and then getting the current time after the read and taking the difference). It's generally about 0.000006s or so
19:57:25 <Cale> and that's running the program in ghci
19:57:52 <Cale> It's about 0.000002s compiled with -O2
19:58:13 <Cale> +-0.000001s
19:59:22 <solrize_> 2 microseconds?
19:59:35 <c_wraith> throw criterion at it!
19:59:43 <Cale> solrize_: yes
20:00:51 <Cale> Yeah, criterion might be able to measure it more reliably
20:01:16 <solrize_> even 2 microseconds sounds kind of slow
20:02:44 <Cale> Also, that was with whatever the default runtime is in GHC 7.10.1 (which might not be the threaded runtime, but I don't know if that's changed)
20:03:21 <Cale> haha, the threaded runtime is much slower
20:03:49 <Cale> I'm seeing everything between 9 and 95 microseconds with -threaded and -N2
20:05:44 <solrize_> wow that's disappointing, especially 95 msec?  that's much slower than python queues
20:05:47 <solrize_> usec
20:06:48 <Cale> Note that this is just a one-shot test
20:07:48 <enthropy> also check how small the difference between successive UTCTimes is if you don't have any threads
20:08:55 <Cale> enthropy: 0 microseconds, occasionally 1 microsecond
20:09:22 <giogadi> hey everyone! does anyone here have experience with the ad package?
20:09:36 <enthropy> yes
20:09:47 <enthropy> alang especially
20:09:55 <Cale> I'm sure edwardk does :)
20:10:03 <giogadi> enthropy: what type constraints do I need on my function in order to differentiate it?
20:10:22 <giogadi> I've been able to differentiate functions without any type signature, but I can't get it to work when I have a type signature
20:11:28 <srhb> giogadi: You can always probe the inferred type, if need be
20:11:55 <giogadi> srhb: I mean, I can see in the compiler error the type that it's trying to deduce, and it's a long, complex ad-specific thing
20:12:04 <Cale> giogadi: Yeah, if you pick a concrete monomorphic type, you'll interfere with the way that ad computes derivatives
20:12:28 <Cale> giogadi: I would expect things with their natural polymorphic type (the one ghci will tell you) should be fine though
20:12:49 <giogadi> Cale: how do I probe the natural polymorphic type
20:12:49 <enthropy> probably not since there are RankNTypes iirc
20:12:55 <Cale> :t myFunction
20:12:57 <lambdabot> Not in scope: ‘myFunction’
20:14:11 <Cale> For example, if you write something like  f x = x^2 + x + 1, you should get a type signature which looks like f :: Num a => a -> a
20:15:28 <enthropy> nevermind my comment, it only applies if you're calling diff from your function
20:15:50 <giogadi> Cale: ah yeah, that was a good idea! the constraint in question appears to be (Mode a, Scalar a ~ Double)
20:16:17 <giogadi> I've never seen such a signature before but I guess that's how it works
20:16:28 <giogadi> Is there a possibility that there's a shorter synonym for that I'm missing?
20:16:33 <srhb> giogadi: The Mode bit refers to the Forward, Reverse or Mixed modes of AD
20:16:34 <Cale> giogadi: If your program works without a type signature, you should almost always be able to ask ghci to tell you the inferred type and just write that in
20:16:51 <giogadi> thanks for the advice!
20:17:27 <giogadi> srhb: thanks; do you know what the tilde is doing in that?
20:17:34 <srhb> giogadi: type equivalence
20:18:08 <shachaf> Type *equality*.
20:19:09 <srhb> Woops, yes. Sorry.
20:20:12 <giogadi> woof, looks like I needed TypeFamilies/GADT just to specify that type signature at all
20:20:24 <srhb> Yep.
20:20:27 <giogadi> a small price to pay for such an amazing ad library
20:20:51 <giogadi> thanks for all your help!
20:21:03 <giogadi> the ghci tip is something that will be very useful
20:21:05 <srhb> Since we're on the topic, does anyone have some papers on AD?
20:21:24 <srhb> I tried to ask my professor in a numeric diff class on the differences between the methods, but he hadn't even heard of AD.
20:22:51 <giogadi> shrb: can't help you specifically besides to point to wikipedia, but I will say that it's alarming just how unknown AD is
20:22:56 <giogadi> given how useful it can be
20:23:36 <srhb> giogadi: That was my feeling too, but since it was unknown among the (comp) physicists who seemed to have use for it, it felt like there was some specific reason they didn't even know about it. :P
20:23:41 <srhb> Probably not, though!
20:24:55 <srhb> I guess what I'm looking for is "when to use numerical differentiation over AD"
20:25:36 <peddie> srhb: tell them it's the method of adjoints and maybe a light bulb will go on
20:25:37 <Cale> Probably the answer is "whenever you can"
20:25:39 <lexir> What is an existential type in haskell. I read the wikipedia answer but it's too math specific.
20:26:12 <Cale> lexir: Are you familiar with GADT syntax?
20:26:16 <srhb> Cale: Right, I'm thinking it's useful whenever your AD isn't depending on the original function being a sufficient approximation while it's really not. :P
20:26:27 <srhb> peddie: I will try that (and try to figure out why that makes sense :))
20:26:39 <lexir> Cale: You mean record types?
20:27:11 <Cale> lexir: an example of an existential type might be something like   data Counter where MkCounter :: a -> (a -> a) -> (a -> String) -> Counter
20:28:16 <Cale> lexir: Here, for any given value x :: Counter, there *exists* some type a, such that x = MkCounter z f s where z :: a, f :: a -> a, and s :: a -> String
20:28:42 <Cale> lexir: When we pattern match to take x apart again, we don't know which type a is any more
20:29:08 <lexir> Cale: Pause. I'm still trying to understand what you wrote :)
20:30:26 <lexir> Cale: Okay, I got it. So how will we know the type of a when we pattern match?
20:30:57 <enthropy> srhb: how do you apply AD to a root you found with say a binary search?
20:31:08 <lexir> Cale: In this case a is the existential type? or is it Counter?
20:31:10 <Cale> lexir: We won't.
20:31:14 <srhb> enthropy: I don't know!
20:31:17 <Cale> Counter is called an existential type
20:31:36 <lexir> Cale: So it's lost unless we specified it when defining MkCounter.
20:31:38 <peddie> enthropy: same way you apply numerical differentiation :)
20:31:59 <Cale> lexir: Yeah, unless we provided ourselves with some way to recover the type information, it's just forgotten
20:32:30 <kaw_> Okay, in case someone else has my problem in the future; my Chan delay issue seemed to be that I needed GHC-Options -threaded (possibly because of interaction with NCurses in the other thread?)
20:32:31 <lexir> Cale: Thanks. I hope I'll remember that explanation. It's very good. Problem is when we don't use something we tend to forget it.
20:32:34 <Cale> lexir: However, we can write things like  case x of MkCounter z f s -> s (f (f (f z)))
20:33:04 <Cale> lexir: Because we know that f :: a -> a and s :: a -> String and z :: a all for the same type a, even if we don't know which
20:33:51 <monochrom> kaw_: yes that sounds right
20:34:13 <monochrom> or generally if you forkIO but also calls C functions
20:34:39 <lexir> Cale: Isn't what you wrote the same as `s (f z)` ? 
20:34:46 <Cale> lexir: no
20:35:01 <monochrom> if you don't use -threaded, then when you call a C function, the whole world is put on hold.
20:35:03 <Cale> lexir: For instance I might have x = MkCounter 0 (+1) show
20:35:25 <kaw_> Ah right, makes sense then
20:35:42 <lexir> Cale: I see
20:35:45 <Cale> lexir: I might also have y = MkCounter "" ('#':) id
20:36:08 <Cale> and then both x and y have type Counter
20:36:25 <Cale> I can write
20:36:30 <Cale> incr :: Counter -> Counter
20:36:44 <Cale> incr (MkCounter z f s) = MkCounter (f z) f s
20:37:07 <Cale> and of course:
20:37:11 <Cale> say :: Counter -> String
20:37:21 <Cale> say (MkCounter z _ s) = s z
20:37:46 <Hijiri> just got back from a couple hours of debugging
20:37:48 <Hijiri> it turns out I put forever before evalStateT, when I should have put it after
20:38:07 <lexir> Cale: Yes they're totally different. a can be just about anything.
20:38:15 <Cale> lexir: right
20:38:28 <lexir> Cale: In which case do we need existential types though?
20:38:32 <srhb> Hijiri: Good times! Though they are quite a bit different :P
20:38:48 <lexir> Cale: So GADT is a value constructor that is a function?
20:38:52 <Cale> lexir: You rarely really *need* existential types
20:39:38 <lexir> I hope I won't end up forgetting them.
20:39:53 <monochrom> co-Yoneda uses an existential type
20:39:58 <Cale> GADTs are a generalisation of ordinary algebraic types that include these existential types (you can have data constructors which are polymorphic in new type variables which don't occur as parameters to the type)
20:40:16 <Cale> GADTs also let you have data constructors whose result type is specialised
20:40:21 <Cale> For example...
20:40:26 <Cale> data Expr a where
20:40:37 <Cale>   Lit :: Integer -> Expr Integer
20:40:45 <orion> Does there exist an attoparsec parser for x-www-urlencoded data?
20:40:46 <Cale>   IsZero :: Expr Integer -> Expr Bool
20:41:05 <Cale>   IfThenElse :: Expr Bool -> Expr a -> Expr a -> Expr a
20:41:39 <Cale> (you can imagine adding other constructors to this language from there...)
20:41:46 <Hijiri> I used a GADT to have bind terms in AST
20:41:56 <shachaf> I'm always confused when people bring up GADTs out of nowhere for answering a question.
20:42:05 <lexir> Cale: heh I'm still rereading what you wrote.
20:42:16 <Hijiri> Bind :: Thing a -> (a -> Thing b) -> Thing b
20:42:21 <Cale> shachaf: I brought them up because they're related to existential types
20:42:36 <shachaf> They object to "data K a => T a = T a", but for some reason they say "use GADT syntax", not "use data T a = K a => T a"
20:42:47 <Cale> shachaf: and that's what lexir was asking about (and I think the notation using GADTs is more intuitive to grasp)
20:43:48 <lexir> Cale: I believe I got it. :)
20:43:48 <Cale> It's nice to have the type of the constructors written explicitly once things get complicated like this
20:44:18 <Cale> Rather than trying to infer it from an over-taxed syntax which was trying to look like BNF :)
20:44:18 <shachaf> I think GADT syntax is fine, but learning about GADT syntax and existentials (or "existential constraints") at the same time is way more complicated, and mixes up unrelated concepts.
20:44:41 <shachaf> I don't think the other syntax is over-taxed. It's not much of an abuse of forall.
20:44:56 <Cale> Oh, I agree, the use of forall there makes sense
20:45:22 <Cale> But still, it requires more explanation than "here is the type of the constructor"
20:45:39 <shachaf> If you're already used to GADT syntax, sure.
20:46:11 <Cale> I've often found that complete beginners will understand GADT syntax more readily than the usual data declaration syntax
20:47:00 <Cale> (If someone is having trouble understanding ordinary data declarations, I'll sometimes translate it to GADT syntax just to see if that makes any more sense for them)
20:47:02 <shachaf> It does lead to conflating the concepts. People say "don't use DatatypeContexts, use a GADT".
20:47:38 <Cale> But aaaaanyway
20:48:20 <Cale> lexir: I should probably point out that there's another notation for existentials, we could have written  data Counter = forall a. MkCounter a (a -> a) (a -> String)
20:52:09 <Cale> lexir: Another reason that it's called an existential type, is that in languages with slightly fancier type systems, you might be able to write something like (exists a. (a, a -> a, a -> String)) to mean something like our Counter type.
20:52:58 <lexir> :t forall
20:52:59 <lambdabot>     Not in scope: ‘forall’
20:52:59 <lambdabot>     Perhaps you meant ‘forAll’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
20:53:09 <lexir> Cale: forall?
20:53:20 <Cale> lexir: It's a keyword
20:53:59 <SrPx> What is the simplest way to do this? "main = do { x <- [0..10]; y <- [0..10]; print (x,y) }" i.e., I want to combine the list monad and the IO monad... I don't remember very well how monad transformers work
20:54:08 <lexir> Cale: thanks
20:54:14 <lexir> I'm out.
20:54:17 <lexir> :D
20:54:23 <SrPx> (the actual case is more complicated than that obviously)
20:54:40 <lexir> SrPx: Uh list comprehension
20:55:00 <Cale> SrPx: main = forM_ [0..10] $ \x -> forM_ [0..10] $ \y -> print (x,y)
20:55:35 <lexir> > [print (x,y) | x <- [0..10], y <- [0..10]]
20:55:37 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO...
20:55:42 <Cale> There's stuff like ListT in pipes you could use.
20:55:55 <Cale> Yeah, you could do that, and sequence
20:56:06 <Cale> > sequence [print (x,y) | x <- [0..10], y <- [0..10]]
20:56:07 <lexir> OMFG why did that list comprehension fail?
20:56:08 <lambdabot>  <IO [()]>
20:56:12 <Cale> It didn't fail
20:56:29 <Cale> It produced a list of IO actions
20:56:31 <lexir> Cale: It didn't print the value. It printed the return type.
20:56:34 <SrPx> ...
20:56:38 <lexir> hmmm
20:56:43 <tsani> that's just lambdabot
20:56:54 <Cale> lexir: The bot only evaluates expressions, it doesn't execute IO actions
20:57:02 <tsani> imagine if people on IRC could execute arbitrary IO on the machine that's hosting lambdabot
20:57:03 <lexir> SrPx: I see.
20:57:07 <glguy> It didn't print the type, the type would have been [IO ()]
20:57:11 <Cale> lexir: also, the result of your expression wasn't an IO action, it was a list of IO actions
20:57:18 <glguy> It printed an alternate representation of the value
20:57:22 <lexir> tsani: True. It would be abused.
20:57:28 <SrPx> as I said the example is more complicated than that ...
20:57:45 <Cale> SrPx: Well, maybe you should tell us more about the actual example?
20:57:52 <lexir> SrPx: Why not just show us what it is.
20:57:56 <lexir> *?
20:58:01 <lexir> *tell
20:58:18 <lexir> I can't even think. I'm going to bed.
21:00:03 <Cale> SrPx: ?
21:00:56 <tsani> Anyway perhaps some can shed some light on this cabal issue: my package depends on a library that I've patched, so I'm using add-source in my cabal sandbox, but when I attempt a cabal build, cabal says I'm missing dependencies, and if I try cabal install --only-dependencies, it installs the (unpatched) library from hackage.
21:01:25 <srhb> SrPx: The general rule is to stick liftIO on the IO'y thing and runYourTransformer ...
21:02:02 <Cale> Ah, thought that might've happened
21:02:09 <srhb> Oh.
21:02:13 <Cale> Freenode seems to be dropping people
21:02:19 <srhb> :/
21:27:08 <narendraj9> How does the catesian product form a bi-functor in the Set category? How is a singleton set an identity element of the Monoid formed?
21:27:46 <narendraj9> I am trying to read this -- http://nattermorphisms.blogspot.co.nz/2009_01_01_archive.html
21:38:09 <Cale> narendraj9: Okay, so a bifunctor on Set is a functor Set × Set -> Set, where × there is the product of categories. Set × Set has as its objects pairs of sets, and an arrow (A,B) -> (C,D) in this category is a pair of functions (f,g) with f: A -> C and g: B -> D
21:40:57 <Cale> narendraj9: So, when we say that × is a bifunctor on Set, we're saying that it sends pairs of sets to sets, i.e. (A,B) |--> A × B, and moreover it needs to send a pair of arrows (f: A -> C, g: B -> D) to a function f×g: A × B -> C × D somehow, well, there's only one obvious way to do that: (f×g)(a,b) = (f a, g b)
21:43:12 <Cale> narendraj9: A singleton set is not an identity for this bifunctor on the nose, because {0} × A is not identical to the set A, for instance. However, there is a natural bijection.
21:43:41 <Cale> lambda_A: {0} × A -> A
21:43:50 <Cale> lambda_A(0,a) = a
21:44:08 <Cale> This is obviously invertible, regardless of which set A happens to be
21:45:28 <narendraj9> Cale: There is a natural bijection. So, the equality here is based on being isomorphic?
21:45:38 <Cale> Which equality?
21:45:51 <narendraj9> A x {0} = A?
21:46:19 <Cale> Unless you're working in a system like HoTT, you won't normally write that
21:46:37 <Cale> A × {0} is only isomorphic to A, not equal to it.
21:46:41 <homovitruvius> hi there! is there a library that takes a list of functions, evaluate them in arallel and depending on the results, decides which functions need to be re-evaluated? think of optimistically evaluate things that should depend on each other and re-run the ones where the dependency was for real
21:46:47 <CMCDragonkai> [Roger Qiu] Basically why are singleton sets considered the identity property if you were to consider Set as a monoidal category?
21:47:04 <narendraj9> Cale: ^^ 
21:47:38 <Cale> homovitruvius: I don't understand the question.
21:47:48 <narendraj9> Cale: Considering the definition of a Monoid, how do we convince ourselves of the statement that the singleton elements are the identity elements.
21:48:07 <Cale> homovitruvius: Why would you want to re-evaluate the functions?
21:48:08 <narendraj9> Cale: s/singleton elements/singleton sets/
21:48:23 <Cale> narendraj9: Set is not a monoid
21:48:29 <Cale> It's a monoidal category
21:48:37 <Cale> see here: http://en.wikipedia.org/wiki/Monoidal_category
21:48:45 <narendraj9> Cale: Yes, I mean monoidal category.
21:49:44 <Cale> Well, you check that when we pick the tensor product in that definition to be the Cartesian product of sets, that we can define the associator and left and right identity such that they satisfy the given laws.
21:49:57 <Cale> I already told you what λ_A ought to be
21:50:11 <Cale> ρ_A is very similar
21:50:18 <homovitruvius> I've a language where files are compiled as if they were concatenated together, but good designs don't define macros in one file that affect the following ones. So in general, the parsing functions can be evaluated in parallel, but if after the fact you discover that a file has defined macros that following files use, you have to recompile those. The language is Verilog
21:50:35 <Cale> α_A,B,C((a,b),c) = (a,(b,c)), somewhat obviously
21:51:10 <Cale> and then all that's left to check is that the pentagon and triangle given on that page actually commute
21:54:59 <HeladoDeBrownie> homovitruvius, you might use the async package in implementing that. i don't know of any package that does *exactly* what you asked though.
21:55:01 <Cale> narendraj9: For the pentagon, if we start with any (((a,b),c),d) in ((A × B) × C) × D (at the top left), and we move along the top, applying α_A,B,C × 1_D gets us ((a,(b,c)),d), and then applying α_A,(B×C),D gives (a,((b,c),d)), and finally applying 1_A × α_B,C,D gives us (a,(b,(c,d)))
21:55:32 <HeladoDeBrownie> homovitruvius, in particular, i'm thinking race from it might be of use.
21:56:18 <Cale> narendraj9: If instead, we first apply α_(A×B),C,D we get ((a,b),(c,d)), and then applying α_A,B,C×D gives (a,(b,(c,d))) which is equal to what we got by the other route
21:56:47 <Cale> narendraj9: So the pentagon commutes.
21:57:07 <narendraj9> Cale: Okay. Give me some time to digest this. Reading the page.
21:59:12 <homovitruvius> HeladoDeBrownie: isn't race intended to compute functions expected to yield the same result until the first alternative succeeds? if so, I don't think it is what I need.
21:59:42 <HeladoDeBrownie> homovitruvius, there's no such requirement. it just waits for one to finish then cancels the other.
22:01:08 <Cale> homovitruvius: race doesn't compute functions, it executes actions concurrently. The first to complete wins and the other action is terminated. The result of race x y will be Left r where r is the result of x, or Right s where s is the result of y.
22:01:35 <Cale> Just to be clear,  race :: IO a -> IO b -> IO (Either a b)
22:01:44 <Cale> So its arguments aren't functions at all.
22:01:47 <HeladoDeBrownie> actually waitAny might be more like it
22:02:02 <HeladoDeBrownie> and yeah i was assuming that by "function", "procedure" was meant.
22:02:35 <homovitruvius> HeladoDeBrownie: but I need all of them to finish (e.g. I need to compile all files), but when the result of one makes clear that the others have used wrong assumptions, I need to rerun some
22:03:57 <Cale> homovitruvius: You could start them all as Async computations, and indeed use waitAny to wait for the first one to complete. You can then, based on its result, decide whether you'd like to cancel any of the other Async computations.
22:04:03 <SrPx> Sorry I got disconnected..
22:04:50 <homovitruvius> Cale:, HeladoDeBrownie: ok, thanks I'll take a look
22:05:34 <Cale> (waitAnyCatch might be more convenient if you're doing this, because the cancelled Asyncs will result in exceptions)
22:05:52 <SrPx> is there any trivial way to parallelize a forM_ ?
22:06:07 <Cale> SrPx: A forM_ in IO?
22:06:32 <Cale> SrPx: forM_ xs $ \x -> forkIO $ do ...
22:07:34 <Cale> That will of course result in concurrency rather than just parallelism though.
22:07:53 <SrPx> yep, I'm running a brute force program that has to test 800000 possibilities ... like `results <- forM [0..800000] $ \ i → test_possibility i` ... it will take a few hours this way
22:08:07 <SrPx> uhm...
22:08:15 <Cale> You might want to split the list up into smaller chunks
22:08:33 <Cale> and forkIO just a few threads which do each chunk sequentially
22:08:34 <SrPx> and then what
22:08:48 <SrPx> so those will run in parallel?
22:09:06 <Cale> and then compile your program with -threaded, and run it with +RTS -N4 or something like that
22:09:16 <SrPx> interesting. thank you!
22:17:31 <davidshore> let x = 1 + 2
22:17:45 <davidshore> show x
22:17:51 <davidshore> :sprintf x
22:18:14 <HeladoDeBrownie> davidshore, wrong buffer?
22:18:56 <davidshore> when I type that into ghci it gives me x = _
22:19:05 <davidshore> shouldn't showing x force it to be evaluated?
22:19:43 <glguy> davidshore: In that context, x is effectively a function: x :: Num a => a
22:19:58 <glguy> This is why we have the MonomorphismRestriction (outside of GHCi)
22:20:23 <HeladoDeBrownie> x is polymorphic, show x only evaluates it at one type
22:20:56 <davidshore> i see
22:22:12 <davidshore> yep, if I do x :: Int it works as expected :)
22:23:35 <HeladoDeBrownie> oh, my explanation is lacking actually. the problem is the constraint as glguy made explicit, not that it's polymorphic
22:28:57 <orion> I want to create a function composition like this: getVal = decodeUtf8 . fromJust . lookup -- unfortunately, the parameter I want to compose is the second to last, not the last. What can I do?
22:29:30 <HeladoDeBrownie> orion, the most straightforward way is probably to write it explicitly
22:29:56 <srid> > foldr (\x y -> x) 0 [1..]
22:29:57 <lambdabot>  1
22:30:01 <srid> how is this not a infinite list?
22:30:10 <srid> shouldn't it result in [1 1 1 ...]?
22:30:15 <glguy> If the point of the code is to use (.) you can either do:   flip lookup x,   or (`lookup` x)
22:30:43 <orion> HeladoDeBrownie: What do you mean?
22:31:03 <SrPx> okay I understand how forkIO can easily spawn a few threads, but what I want is to spawn 4 of then in parallel and then collect the 4 results
22:31:12 <glguy> orion: Using all the operators isn't a virtue. Often it's clearer to write the code "directly"
22:31:14 <HeladoDeBrownie> orion, expand the composition, writing out all the parameters and applications.
22:31:34 <srid> n/m
22:31:35 <SrPx> is there any obvious/simple way to do it other than dealing with mvars & such? something like a "join" function that receives a list of threads and returns their results...
22:31:43 <orion> HeladoDeBrownie: like this?: getVal v = decodeUtf8 $ fromJust $ lookup v headers
22:32:05 <glguy> SrPx: Have you looked over the "async" package? It has some stuff relevant to what you're doing.
22:32:41 <HeladoDeBrownie> orion, essentially.
22:32:57 <jmcarthur> SrPx: i second the suggestion for the async package
22:33:05 <glguy> I agree with jmcarthur
22:33:08 <SrPx> Looks like that's what I need, thanks guys :)
22:33:18 <jmcarthur> async is great
22:33:32 <SrPx> yes it is!
22:33:57 <orion> HeladoDeBrownie, glguy: Ok, thank you.
22:34:31 <fragamus> hi i have been going through the excellent webpage http://dev.stephendiehl.com/hask/ and I have a minor question about the typeholes example
22:36:36 <fragamus> he says that GHC suggests a solution, but really one has to make the inference that since [a] matches one of the relevant bindings... 
22:36:49 <fragamus> that this is the "suggestion" right?
22:37:36 <fragamus> it does not really suggest anything right
22:40:00 <SrPx> So, async seems to work but I guess I missed/misunderstood something since there was no speedup on this example: http://lpaste.net/130930 
22:40:35 <davidshore> fragamus, I'm not sure what you mean
22:40:48 <HeladoDeBrownie> SrPx, not sure if it will help, but did you enable multithreading?
22:41:02 <fragamus> davidshore: me neither
22:41:08 <SrPx> HeladoDeBrownie: that's what I'm asking, did I? I used -threaded and +RTS -N2, not sure if that is enough
22:41:24 <HeladoDeBrownie> SrPx, you just answered what i meant to ask
22:44:00 <SrPx> ah okay
22:44:36 <Cale> SrPx: Your problem is that both of the threads finish immediately
22:44:57 <Cale> (without doing any work to evaluate fib 37)
22:45:04 <SrPx> ah...
22:45:14 <SrPx> fair enough
22:46:24 <Cale> If you write  async (evaluate $ fib 37)  instead
22:46:43 <Cale> using Control.Exception.evaluate  (kind of silly that it's in Control.Exception, but whatever)
22:46:58 <Cale> Then you should see a 2x speedup
22:48:08 <Cale> You could also use $!
22:48:18 <Cale> where you presently have $
22:48:34 <Cale> But that's a more fiddly way to get it to happen
22:53:19 <SrPx> I'm confused - "test = return $ seq (fib 37) (fib 37)" has no speedup, but "test = do { let x = fib 37; return (seq x x) }" has a speedup. I thought those were equivalent...
22:55:18 <Cale> First of all, seq x x is always equivalent to x
22:55:51 <Cale> the first of those expressions though might trick the compiler into evaluating fib 37 twice for no reason.
22:57:20 <SrPx> hmm..
22:59:27 <Cale> SrPx: But in neither case does executing the action test require evaluation of fib 37
23:00:10 <Cale> SrPx: executing return x never causes x to be evaluated
23:00:53 <SrPx> I think I'm getting what you mean.
23:01:03 <__ryan> hello how to set a session with a boolean value?
23:01:25 <HeladoDeBrownie> __ryan, you need to describe your problem more clearly
23:02:40 <__ryan> HeladoDeBrownie: i want to set a boolean value on my session  - i use yesod - but it gives me this erro - Couldn't match expected type Text with actual type Bool
23:03:20 <HeladoDeBrownie> __ryan, okay, "yesod session" was important to know. (i'm not familiar with it but maybe someone else is.) either way showing code will probably help.
23:03:27 <HeladoDeBrownie> use lpaste; see the topic
23:06:00 <__ryan> HeladoDeBrownie: here is the code - http://lpaste.net/130931
23:07:51 <HeladoDeBrownie> __ryan, it looks like the type is restricted to Text. perhaps render the Bool to text and parse it back out later?
23:08:19 <HeladoDeBrownie> again, i'm not familiar with yesod, so i have no idea if this is a reasonable suggestion.
23:08:57 <Cale> __ryan: http://hackage.haskell.org/package/yesod-core-1.4.9.1/docs/Yesod-Core-Handler.html#v:setSession
23:09:08 <Cale> yes, it's a very reasonable suggestion :)
23:09:35 <__ryan> HeladoDeBrownie: how do i render the Bool to text? does haskell has a function for that? or?
23:09:41 <Cale> show?
23:09:51 <HeladoDeBrownie> __ryan, read/show are one way, but it could be done any way you like.
23:10:43 <HeladoDeBrownie> it could even be something like encoding the value as the result of Data.Text.null on the Text :)
23:10:44 <Cale> The fact that you're asking that question makes me wonder whether dealing with Yesod is really a reasonable thing at this point. :)
23:13:12 <Cale> (but don't be too discouraged if you're the sort who doesn't mind jumping off the deep end in order to learn to swim)
23:13:47 <__ryan> > show True
23:13:48 <lambdabot>  "True"
23:14:04 <HeladoDeBrownie> that gives you a String; Data.Text.pack will then give you a Text from that
23:14:18 <HeladoDeBrownie> @type T.pack . show
23:14:19 <lambdabot>     Not in scope: ‘T.pack’
23:14:19 <lambdabot>     Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
23:14:34 <__ryan> > show "True"
23:14:35 <lambdabot>  "\"True\""
23:14:47 <__ryan> how about string to bool?
23:15:01 <Cale> > read "True" :: Bool
23:15:03 <lambdabot>  True
23:15:27 <__ryan> > read "True"
23:15:29 <lambdabot>  *Exception: Prelude.read: no parse
23:15:49 <Cale> You may prefer to use reads
23:16:21 <HeladoDeBrownie> i suggest readMaybe for this
23:16:23 <HeladoDeBrownie> @type readMaybe
23:16:24 <__ryan> Cale: y?
23:16:24 <lambdabot> Read a => String -> Maybe a
23:16:33 <Cale> ah, is that new?
23:16:34 <HeladoDeBrownie> that way you avoid invalid input crashing your program
23:16:37 <__ryan> read True :: String
23:16:40 <__ryan> > read True :: String
23:16:42 <lambdabot>      Couldn't match type ‘Bool’ with ‘[Char]’
23:16:42 <lambdabot>      Expected type: String
23:16:42 <lambdabot>        Actual type: Bool
23:16:48 <HeladoDeBrownie> (reads accomplishes the same but deals with a list instead of a Maybe)
23:17:05 <HeladoDeBrownie> Cale, i think it got added to base sometime last year?
23:17:37 <Cale> ah, apparently 4.6.0.0
23:20:02 <mjrosenb> Is it possible to allow pattern matching with a Constructor, but not using it to construct a value?
23:21:08 <Cale> mjrosenb: Not really, no.
23:21:28 <HeladoDeBrownie> you could get close with pattern synonyms maybe?
23:21:30 <Cale> mjrosenb: Maybe there's some hackery you could do with pattern synonyms...
23:21:31 <Cale> yeah
23:22:02 <HeladoDeBrownie> you can also provide a fold over your type
23:22:06 * mjrosenb looks into pattern synonyms
23:22:18 <__ryan> > readMaybe True
23:22:19 <lambdabot>      Couldn't match type ‘Bool’ with ‘[Char]’
23:22:19 <lambdabot>      Expected type: String
23:22:19 <lambdabot>        Actual type: Bool
23:22:20 <HeladoDeBrownie> e.g., the fold for Maybe is maybe :: b -> (a -> b) -> Maybe a -> b
23:23:13 <dynetrekk> hi, can this code (project euler 1) be typed up nicer? main = putStrLn (show (sum (filter (\ x -> mod x 3 == 0 || mod x 5 == 0) [1..999])))
23:23:22 <dynetrekk> the parentheses make it almost feel like lisp :P
23:24:02 <mjrosenb> dynetrekk: you can use $ and .
23:24:09 <Cale> main = print . sum . filter (\x -> x `mod` 3 == 0 || x `mod` 5 == 0) $ [1..999]
23:24:15 <HeladoDeBrownie> that may be one case where a list comprehension looks nicer than a filter
23:24:19 <Cale> putStrLn . show = print
23:24:22 <mjrosenb> dynetrekk: or a list comprehension.
23:24:41 <dynetrekk> mjrosenb: yeah, sum over a list comprehension is how I would have done it in python
23:24:51 <dynetrekk> Cale: oh, didn't know about print
23:25:00 <mjrosenb> HeladoDeBrownie: I am not a huge fan of list literals in list comprehensions.
23:25:11 <mjrosenb> dynetrekk: they are way cooler in haskell :-p
23:26:26 <Cale> print . sum $ [x | x <- [1..999], x `mod` 3 == 0 || x `mod` 5 == 0]
23:26:27 <dynetrekk> mjrosenb: cooler, how?
23:26:36 <dynetrekk> what does $ do?
23:26:45 <Cale> f $ x = f x
23:26:51 <Cale> But $ has really low precedence
23:26:53 <dynetrekk> Cale: so nothing?...
23:26:58 <dynetrekk> ah
23:27:10 <Cale> while (.) has fairly high precedence
23:27:24 <mjrosenb> dynetrekk: you can think of $ as the 'remove parentheses' operator
23:27:30 <Cale> So that becomes  (print . sum) [x | x <- [1..999], x `mod` 3 == 0 || x `mod` 5 == 0]
23:27:36 <mjrosenb> occasionally, it'll be useful in another context.
23:27:55 <Cale> Function application (whitespace) has higher precedence than any infix operator
23:27:56 <HeladoDeBrownie> i keep thinking of shortcuts for the two mods but realizing that what i'm thinking of only applies if it's (&&). curses
23:28:07 <dynetrekk> does ghc/ghci have a "compile-and-run" or "run this file interpreted" mode?
23:28:07 <Cale> So if you were to write  print . sum [x | x <- [1..999], x `mod` 3 == 0 || x `mod` 5 == 0]
23:28:11 <Cale> this would be a type error
23:28:19 <Cale> since sum [x | x <- [1..999], x `mod` 3 == 0 || x `mod` 5 == 0] is an Integer
23:28:30 <Cale> and not a function which you could compose with print
23:28:33 <HeladoDeBrownie> e.g., comma in list comprehension instead of the operator, or, less obviously, x `mod` a && x `mod` b → x `mod` a * b
23:28:59 <mjrosenb> HeladoDeBrownie: x `mod` 15 `in` [0,3,5,6,9,10,12]
23:29:09 <HeladoDeBrownie> mjrosenb, what?
23:29:19 <Cale> elem
23:29:22 <mjrosenb> oh
23:29:23 <mjrosenb> elem
23:29:31 <mjrosenb> \me <- derp
23:29:36 <HeladoDeBrownie> i still don't understand
23:29:56 <Cale> > sum $ [x | x <- [1..999], x `mod` 15 `elem` [0,3,5,6,9,10,12]]
23:29:57 <lambdabot>  233168
23:30:05 <HeladoDeBrownie> oh okay now i see what you were suggesting
23:30:07 <mjrosenb> HeladoDeBrownie: that should be equicalent to x `mod` 3 == 0 || x `mod` 5 == 0
23:30:21 <mjrosenb> assuming I actually remembered Data.List correctly.
23:30:21 <HeladoDeBrownie> that's even less obvious than the (||) thing, i think :P
23:30:25 <dynetrekk> Cale: I don't think I quite got why the $ was necessary
23:30:52 <mjrosenb> HeladoDeBrownie: you just asked for it gone, you never asked for it to be obvious! :-)
23:31:06 <mjrosenb> dynetrekk: it gets rid of parentheses.
23:31:08 <dynetrekk> print . sum [something] is illegal code?
23:31:14 <dynetrekk> mjrosenb: right
23:31:16 <Cale> dynetrekk: Well, f (g x) can be written as (f . g) x, but not as f . g x, because that means f . (g x), since function application binds more tightly than any infix operator
23:31:41 <mjrosenb> dynetrekk: it is legal, but it won't do what you want (or typecheck)
23:31:57 <Cale> dynetrekk: So by inserting a low precedence application operator, we get f . g $ x = (f . g) $ x = (f . g) x = f (g x)
23:32:00 <dynetrekk> Cale: ah, I thought it removed the latter parentheses, when in fact it removed the former :)
23:32:46 <dynetrekk> so print . sum . filter in fact menas that I'm composing a function (print . sum . filter)
23:32:50 <dynetrekk> before applying it
23:32:53 <Cale> yeah
23:33:24 <Cale> Well, in this case, it's  (print . sum . filter f) ...
23:33:47 <dynetrekk> Cale: right
23:51:49 <davidshore> is undefined the only value that can satisfy any type?
23:52:47 <HeladoDeBrownie> i'm going to answer the question i think you meant with "yes".
23:53:22 <davidshore> how should I phrase it?
23:53:25 <HeladoDeBrownie> and will clarify by saying that you can define a type data Void which contains *only* bottom.
23:53:49 <HeladoDeBrownie> i'm actually not sure the best way to phrase it.
23:54:36 <HeladoDeBrownie> one thing to note though is that undefined is not a value per se, it's a polymorphic binding.
23:55:06 * hackagebot yaml 0.8.11 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.11 (MichaelSnoyman)
23:55:35 <HeladoDeBrownie> but there is nothing that is not semantically equivalent to undefined at a specific type that occupies every type.
23:55:38 <HeladoDeBrownie> does that make sense?
23:55:52 <HeladoDeBrownie> i'm not sure it does. i think i said it poorly.
23:56:14 <HeladoDeBrownie> it gets more complicated when you note that there are not fully defined values that are not bottom. e.g., Just undefined.
23:56:24 <HeladoDeBrownie> there are not-fully-defined values*
23:56:41 <HeladoDeBrownie> but not every type has such a value.
23:57:34 <davidshore> i'm not sure i understand the relationship between undefined and bottom
23:57:52 <HeladoDeBrownie> the value of undefined at any given concrete type is bottom.
23:58:09 <HeladoDeBrownie> undefined is essentially a name for the bottom that inhabits various types.
23:58:17 <HeladoDeBrownie> bottom is a value, not a name.
23:58:38 <davidshore> oh, i thought bottom was a type
23:59:32 <HeladoDeBrownie> bottom is "the least-defined value"
23:59:37 <HeladoDeBrownie> which indeed inhabits every type
