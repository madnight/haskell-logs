00:00:26 <arkeet> (where lists are finite lists, and you're not allowed to apply infinitely many operations in a monoid.)
00:00:45 <EvanR> so this isnt math? ;)
00:01:00 <mauke> it's unconventional math
00:01:03 <arkeet> everything is provable in Haskell, so I hope not!
00:01:05 <EvanR> new math
00:01:19 <EvanR> awesome
00:01:22 <mauke> http://inutile.club/estatis/falso/
00:01:31 <nshepperd> are lists in math normally defined to be finite?
00:01:37 <mauke> see bottom for a coq implementation
00:01:43 <arkeet> nshepperd: in the context of free monoids, yes.
00:01:50 <nshepperd> I think they call infinite ones 'sequences'
00:01:52 <arkeet> ^
00:02:53 <arkeet> you can kind of go in the other direction.
00:03:17 <arkeet> construct what you want to call the "free monoid", and define "monoid" to mean "(free monoid)-algebra"
00:03:18 <EvanR> lol Falso is a joke axiomatic system, i think ?
00:03:35 <arkeet> EvanR: it was, until it was proven with coq!
00:03:41 <EvanR> what
00:03:46 <EvanR> scrolling down
00:03:55 <arkeet> [23:54:12] <EvanR> or a zipper
00:03:55 <arkeet> er
00:04:06 <arkeet> https://github.com/clarus/falso
00:05:47 <arkeet> anyway 
00:05:50 <arkeet> in haskell terms
00:06:01 <arkeet> by definition, a monoid structure on m is just a functoin FM m -> m
00:06:18 <arkeet> (satisfying the laws that FM is already supposed to have)
00:06:55 <arkeet> oh no.
00:07:00 <arkeet> it's supposed to be a monad algebra.
00:07:02 <arkeet> FM is a monad.
00:07:34 <arkeet> let's call it fold :: FM m -> m
00:07:40 <arkeet> then the laws are supposed to be like
00:07:50 <arkeet> fold . return = id
00:08:02 <arkeet> and fold . join = fold . fmap fold
00:08:07 <arkeet> or something
00:08:29 <arkeet> ( m -> FM m -> m is the identity, and the two ways of goin FM (FM m) -> FM m -> m are equal)
00:08:39 <mauke> I have reported you to the haskell police for breaking things out of monads as it is a crime
00:08:55 <arkeet> ???? :)'
00:10:12 * hackagebot vtegtk3 0.13.0.2 - Binding to the VTE library.  http://hackage.haskell.org/package/vtegtk3-0.13.0.2 (HamishMackenzie)
00:10:14 * hackagebot vte 0.13.0.2 - Binding to the VTE library.  http://hackage.haskell.org/package/vte-0.13.0.2 (HamishMackenzie)
00:10:39 <arkeet> oh dear.
00:10:43 <arkeet> I made a grave error
00:10:51 <arkeet> it shold be data FM a = Pure a | Mempty | Mappend (FM a) (FM a)
00:11:09 <arkeet> I think
00:11:32 <EvanR> that makes even more sense
00:12:00 <EvanR> who broke what out of a monad?
00:12:14 <mniip> lol
00:12:19 <mauke> do you need an explicit Mempty?
00:12:21 <arkeet> exercise: show that FM is a monad
00:12:22 <mniip> hdevtools appears to freeze vim on an empty file
00:12:22 <arkeet> mauke: yes
00:12:28 <arkeet> how else would one define mempty for it?
00:12:30 <mauke> oh, right
00:12:51 <arkeet> let's just use the newtype versoin.
00:12:54 <arkeet> CPS version.
00:13:06 <arkeet> newtype FM a = FM (forall m. Monoid m => (a -> m) -> m)
00:14:10 <EvanR> so it is a monad?
00:14:24 <EvanR> seems odd
00:14:58 <arkeet> it's supposed to be.
00:15:33 <EvanR> ok so the freeness adds a type parameter
00:15:40 <EvanR> * to * -> *
00:15:41 <arkeet> return a = FM ($ a)
00:15:55 <arkeet> actually the implementatoins for return and join should be exactly the same as for Cont.
00:16:02 <arkeet> I think
00:16:10 <EvanR> a given monoid has kind *, the free monoid is a * -> *
00:16:25 <arkeet> given any type, you get a free monoid on that type.
00:16:31 <jle`> Cont only makes sense if the result types are the same under every join/bind
00:16:37 <jle`> i do'nt think you can enforce that here
00:16:42 <arkeet> hm
00:16:49 <jle`> or maybe you can
00:16:51 <arkeet> no
00:16:53 <arkeet> stop.
00:17:00 <arkeet> forall r. Cont r a is just a
00:17:09 <arkeet> and of course identity is a monad.
00:18:17 <arkeet> oh yeah.
00:18:26 <arkeet> join (FM x) = FM (x . foldMap)
00:18:45 <arkeet> where foldMap f (FM x) = x f
00:19:16 <arkeet> return a = FM (\k -> k a)
00:19:31 <arkeet> join (FM x) = FM (\k -> x (foldMap k))
00:19:53 <arkeet> none of this depends on the Monoid constraint I guess.
00:19:58 <arkeet> which it shouldn't.
00:20:07 <arkeet> CPS is weird.
00:20:10 <arkeet> I don't quite get it yet.
00:23:05 <arkeet> and of course a map t a -> FM a is the same as a map Monoid m => t a -> (a -> m) -> m
00:23:14 <arkeet> which is flipped foldMap
00:23:28 <arkeet> on t
00:24:01 <arkeet> so FM is the universal Foldable or something.
00:25:13 * hackagebot gconf 0.13.0.2 - Binding to the GNOME configuration database system.  http://hackage.haskell.org/package/gconf-0.13.0.2 (HamishMackenzie)
00:25:42 <arkeet> what is the universal Traversable? (does that exist?)
00:25:56 <arkeet> FM is clearly traversable.
00:26:09 <arkeet> (in view of the tree version of it.)
00:27:12 <mniip> hmm, what would be the nicest way to extract the first Just from a list of Maybes
00:27:19 <mniip> and in case there are none, use a supplied default
00:27:34 <jle`> asum ?
00:28:08 <mniip> I'd rather msum
00:28:10 <jle`> > asum [Nothing, Just 1, Nothing, Just 3]
00:28:11 <lambdabot>      Not in scope: ‘asum’
00:28:12 <lambdabot>      Perhaps you meant one of these:
00:28:12 <lambdabot>        ‘F.asum’ (imported from Data.Foldable),
00:28:17 <mniip> msum with maybe?
00:28:18 <jle`> > F.asum [Nothing, Just 1, Nothing, Just 3]
00:28:20 <lambdabot>  Just 1
00:28:23 <arkeet> asum and msum are the same.
00:28:45 <arkeet> and yes, use maybe after that.
00:28:47 <arkeet> or fromMaybe
00:29:16 <jle`> :t \d -> fromMaybe d . F.asum
00:29:17 <lambdabot> Foldable t => c -> t (Maybe c) -> c
00:33:25 <jle`> :t foldr (flip fromMaybe)
00:33:26 <lambdabot> Foldable t => a -> t (Maybe a) -> a
00:33:30 <jle`> that'll do it too :)
00:33:32 <mniip> hmm, :info doesn't say what's the precedence of !!...
00:34:55 <jle`> hm. perhaps there is no fixity defined
00:35:33 <pavonia> If my data type is too big to fit into an Int, do I have to give an implementation for all of Ord's functions?
00:35:54 <pavonia> becasue the minimal complete definition is fromEnum + toEnum
00:36:02 <jle`> do you mean Enum ?
00:36:15 <pavonia> Err, yeah, sorry
00:40:07 <jle`> it looks like it's undefined behavior
00:41:07 <arkeet> Enum is kind of a hack.
00:41:30 <pavonia> jle`: What do you mean?
00:41:46 <jle`> it's not specified in the spec so you really can do whatever you want/feel is most useful
00:42:12 <mniip> pavonia, consider implementing EnumFromTo and friends
00:42:12 <jle`> compiler will ask you to give a definition of both but because one of them doesn't really make sense then it's up to you
00:42:26 <bennofs> I just noticed that you can write: class T a where type family T a
00:42:50 <bennofs> Is this a bug? (Writing type family T a instead of just type T a inside a class definition for an associated type)
00:43:28 <pavonia> mniip: That's my question, if I have to implement all of them if fromEnum/toEnum doesn't make sense
00:43:49 <bennofs> After all, you can't write instance T Int where type instance T Int = ()
00:44:17 <jle`> pavonia: implement them in a way that is most useful in how you'll be doing it
00:44:27 <jle`> if you want `succ` to progress on forever, then you'll need to define it that way
00:44:37 <mniip> I guess treat Int as if it were Integer, that is, ignore values taht don't fit within int and let it overflow or whatever
00:44:39 <jle`> tell it how to succ forever :)
00:44:53 <mniip> but do implement succ and enumFromThenTo  separately
00:45:14 * hackagebot msgpack 1.0.0 - A Haskell implementation of MessagePack  http://hackage.haskell.org/package/msgpack-1.0.0 (HideyukiTanaka)
00:45:16 * hackagebot msgpack-rpc 1.0.0 - A MessagePack-RPC Implementation  http://hackage.haskell.org/package/msgpack-rpc-1.0.0 (HideyukiTanaka)
00:45:18 * hackagebot msgpack-aeson 0.1.0.0 - Aeson adapter for MessagePack  http://hackage.haskell.org/package/msgpack-aeson-0.1.0.0 (HideyukiTanaka)
00:48:04 <pavonia> jle`, mniip: Let me rephrase... My type is basically an Integer plus additional information. Is there a way to avoid having to write a lot of boilerplate for the Enum instance?
00:48:25 <arkeet> why do you want an Enum instance?
00:48:43 <pavonia> To use [..]
00:49:09 <mniip> can you paste your type?
00:49:26 <jle`> question is too parametric :)
00:50:05 <mniip> my terrible architectural decision sense is tingling
00:50:17 <jle`> we can give you an answer that works for all such types you describe, but it likely won't be as good or nice as an answer that works for your specific situation
00:51:20 <pavonia> "data Year = Year Integer Bool", where the Bool may change in later definitions
00:51:50 <mniip> consider: data Year = Year Bool Integer
00:52:04 <mniip> then you can 'Year True <$> [0..10]'
00:52:17 <mniip> (I'm assuming that's what you want)
00:52:52 <pavonia> No, I want something like [startYear ... endYear]
00:52:57 <pavonia> *..
00:53:07 <arkeet> what is [Year 1 False .. Year 10 True]?
00:53:27 <pavonia> All bools false
00:54:18 <jle`> how would you expect any automatically derived definition to know that? :)
00:54:34 <jle`> it sounds like it's something you'd have to say explicitly
00:54:40 <mniip> so [x..y] wouldn't contain y then?
00:56:00 <mniip> pavonia, then you need no boilerplate
00:56:20 <mniip> enumFromTo (Year m a) (Year _ b) = Year m <$> enumFromTo a b
00:56:36 <mniip> that's rather unboilerplateish
00:56:44 <mniip> oh wait you wanted it the other way around
00:57:15 <arkeet> enumFromTo (Year a m) (Year b _) = Year ?? m <$> enumFromTo a b
00:57:30 <pavonia> But I still have to implement all function, that was my question
00:57:31 <mniip> (`Year` m) heheheh
00:57:32 <arkeet> = Year ?? m <$> [a..b]
00:57:35 <arkeet> yeah or that.
00:57:42 <arkeet> well yes
00:57:46 <arkeet> you do
00:57:53 <mniip> Year <$> [a..b] <*> pure m
00:58:01 <arkeet> no thanks.
00:59:04 <jle`> flip Year m <$> [a..b]
00:59:09 <jle`> it's a party now
01:00:57 <arkeet> I did that, with (??) = flip
01:01:05 <pavonia> Thinking about it, maybe I should just implement toEnum and fromEnum as years very likely won't go out of the range :)
01:01:22 <arkeet> if you want.
01:01:32 <arkeet> you'll probably lose fromEnum . toEnum = id
01:01:39 <arkeet> but Enum is a hack anyway.
01:01:46 <arkeet> it does lots of unrelated things.
01:02:08 <arkeet> I don't know why from/toEnum exist.
01:02:34 <jle`> presumably just for this reason
01:03:20 <jle`> or maybe it exists to pose Enum as "things with an isomorphism to Int"
01:03:31 <jle`> ...whcih most instances are not
01:03:34 <mniip> arkeet, do { x <- [a..b]; return $ Year x m }
01:04:04 <jle`> [ Year m x | x <- [a..b] ]
01:04:57 <jle`> s/m x/x m
01:05:09 <jle`> this is my friday night
01:06:57 <arkeet> I don't know how to implement Traversable for FM without either converting to the binary tree version and back or using reflection
01:11:50 <sammecs> What do you mean by FM?
01:14:29 <pavonia> sammecs: "newtype FM a = FM (forall m. Monoid m => (a -> m) -> m)" from earlier discussion
01:15:01 <arkeet> :t \f -> fmap f . sequenceA
01:15:02 <lambdabot> (Applicative f, Traversable t) => (t a -> b) -> t (f a) -> f b
01:15:33 <arkeet> I think I called this "untraverse" once.
01:15:40 <arkeet> no idea why
01:15:52 <jle`> :t traverse
01:15:54 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
01:29:14 <narendraj9> Can fpcomplete.com be used like lambdabot? For evaluating haskell experssions in IRC.
01:33:32 <narendraj9> Can anyone make lambdabot join a channel? lambdabot is in #haskell-books and there is no one there. My channel #fp@nith has atleast a few people. :-D I was thinking of making my bot talk to lambdabot in #haskell-books to and post replies in my channel to evaluate Haskell expressions. But if anyone can make lambdabot join my channel, that would be great! Thanks.
01:36:40 <arkeet> narendraj9: I think int-e runs lambdabot
01:37:08 <narendraj9> int-e: ^^
01:37:26 <arkeet> not sure who exactly has the ability to make it join channels
01:38:42 <narendraj9> @join #fp@nith
01:38:42 <lambdabot> Not enough privileges
01:38:47 <narendraj9> :_D
01:38:58 <narendraj9> @admin 
01:38:58 <lambdabot> Not enough privileges
01:39:06 <mauke> @join #fp@nith
01:39:06 <lambdabot> Not enough privileges
01:39:10 <mauke> oh well
01:39:16 <narendraj9> I think I should do this in #haskell-books.
01:40:13 <narendraj9> Oh there is a categorytheroy channel.
01:40:15 <narendraj9> @listchans
01:40:15 <lambdabot> ##categorytheory ##crypto ##logic ##manatee ##megaharem ##proggit ##scalaz ##villagegreen #agda #archlinux-haskell #aurapm #bfpg #csa_uva #darcs #diagrams #dreamlinux-es #esoteric #fedora-haskell #friendly-coders #functionaljava #gentoo-haskell #gentoo-uy #ghc #hackage #happs #haskell #haskell-arcade #haskell-beginners #haskell-blah #haskell-
01:40:15 <lambdabot> books #haskell-br #haskell-by #haskell-cn #haskell-fr #haskell-freebsd #haskell-game #haskell-gsoc #haskell-id #haskell-in-depth #haskell-infrastructure #haskell-lens #haskell-llvm #haskell-overflow #haskell-pl #haskell-soc #haskell.au #haskell.cz #haskell.de #haskell.dut #haskell.es #haskell.fi #haskell.hr #haskell.it #haskell.jp #haskell.no #
01:40:15 <lambdabot> haskell.ru #haskell.se #haskell.tw #haskell_ru #hscraft-srv #jhc #jtiger #learnanycomputerlanguage #learnmath #learnprogramming #ledger #lpmc #lw-prog #lysa #macosx #macosxdev #mainehackerclub #nicta-course #numerical-haskell #plaimi #rosettacode #scala #scalaz #scannedinavian #snapframework #tanuki #unicycling #vinyl #xmonad #yi
01:40:27 <arkeet> that's a lot of channels.
01:40:29 <edwardk> lambdabot gets around
01:40:44 <arkeet> edwardk: do you have admin privileges on lambdabot?
01:40:53 <edwardk> i think so, whats up?
01:40:54 <arkeet> or know who does?
01:41:03 <arkeet> narendraj9 wants it to join some channel.
01:41:16 <narendraj9> edwardk: My college's fp group.
01:41:57 <narendraj9> edwardk: lambdabot is in a lot of channels where aren't any people. Like #haskell-books. So, in my channel people discuss Haskell atleast sometime. 
01:42:10 <edwardk> check your channel =P
01:49:28 <jellie> Hey guys.
01:50:07 <jellie> What does an error: " 'xyz' is not a record selector" mean?
01:50:17 * hackagebot svgcairo 0.13.0.3 - Binding to the libsvg-cairo library.  http://hackage.haskell.org/package/svgcairo-0.13.0.3 (HamishMackenzie)
01:50:19 * hackagebot slack-api 0.4 - Bindings to the Slack RTM API.  http://hackage.haskell.org/package/slack-api-0.4 (mpickering)
01:50:26 <mauke> > undefined { xyz = () }
01:50:28 <lambdabot>  ‘xyz’ is not a (visible) constructor field name
01:50:33 <mauke> not that, then
01:53:05 <pavonia> > ReaderT { head = 1 }
01:53:06 <lambdabot>      Constructor ‘ReaderT’ does not have field ‘head’
01:53:07 <lambdabot>      In the expression: ReaderT {head = 1}
01:55:07 <jellie> In Network.Wreq I am finding it impossible to add a header that will say that I want to accept xml
01:55:11 <jellie> How can I do this?
01:55:30 <jellie> The errors seem to be filled with lens jargon :(
01:56:24 <pavonia> jellie: Ah, yesterday you had left before I was able to answer. Could you show your code again?
01:57:55 <jellie> pavonia: Okay, uh the one that is currently failing. http://lpaste.net/5348804862865833984
01:59:41 <pavonia> It's header and you need to wrap the header nam into a CI constructor, I think
01:59:50 <pavonia> *header name
02:00:48 <pavonia> jellie: Do you use OverloadedStrings?
02:00:58 <jellie> pavonia: No
02:01:07 <jellie> Oh I do
02:01:23 <jellie> sorry I am using OverloadedStrings
02:01:57 <m4ple> hello everyone. I am trying to understand how to use Aeson. I found many examples defining record fields as !Text, but I don't understand the syntax and I'm having no luck with google. What does that ! mean?
02:02:06 <pavonia> jellie: So accoring to the examples "defaults & header "Accept" .~ ["*/*"]" should work
02:02:40 <jellie> pavonia: but it doesn't in my repl
02:02:49 <k-u> m4ple: strictness http://stackoverflow.com/questions/993112/what-does-the-exclamation-mark-mean-in-a-haskell-declaration
02:03:12 <pavonia> jellie: Did you change "headers" to "header"?
02:03:32 <m4ple> k-u: thanks!
02:03:58 <k-u> that link can explain it better than I can
02:04:08 <k-u> :^)
02:04:49 <jellie> No I didn't
02:05:17 <jellie> pavonia: What makes you say that I should change headers to header?
02:05:22 <jellie> Where did you get that?
02:05:32 <m4ple> now I only need to understand why they used strict Text instead of a plain String, but that's a whole different issue I'm not that interested in anyway
02:05:37 <pavonia> jellie: From the documentation
02:06:07 <jellie> pavonia: A link? I've been reading the docs too.
02:06:16 <k-u> http://hackage.haskell.org/package/wreq-0.3.0.1/docs/Network-Wreq.html#v:header
02:06:34 <jellie> pavonia: I just changed it to header and got a different error that I probably could fix with changing strings to bytestrings
02:07:07 <pavonia> That one http://hackage.haskell.org/package/wreq-0.3.0.1/docs/Network-Wreq.html#v:header
02:08:29 <jellie> @hoogle String -> ByteString
02:08:30 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
02:08:30 <lambdabot> Graphics.Rendering.OpenGL.GL.Shaders.ShaderObjects packUtf8 :: String -> ByteString
02:08:30 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
02:09:13 <Geraldus> I've installed GHC-7.8.4, and now when I try to install my yesod project dependencies (using Stackage LTS 2.1) I have error http://lpaste.net/130117
02:09:31 <Geraldus> Could not find module ‘Yesod.Form.Core’
02:09:56 <pavonia> jellie: fromString
02:12:08 <jellie> pavonia: Uh sorry the lights just went offline
02:12:16 <jellie> I just went offline
02:13:03 <pavonia> You're probably looking for "fromString"
02:16:21 <jellie> @info fromString
02:16:21 <lambdabot> fromString
02:16:32 <jellie> @hoogle fromString
02:16:34 <lambdabot> Data.String fromString :: IsString a => String -> a
02:16:34 <lambdabot> GHC.Exts fromString :: IsString a => String -> a
02:16:34 <lambdabot> Data.Text.Internal.Builder fromString :: String -> Builder
02:18:09 <jellie> pavonia: Thanks
02:18:15 <jellie> pavonia: Works
02:30:33 <m4ple> sorry to bother again. I want to decode the contents of a file from JSON. Aeson's decode expects a ByteString, readFile gives me an IO String. I tried using "pack" to convert the String to ByteString, but ghci tells me it can't match 'Char' with 'GHC.Word.Word8'
02:34:43 <supki> m4ple: strict Text is (usually) much faster than String and eats much less memory
02:36:25 <supki> m4ple: Data.ByteString.Lazy.readFile will read file contents into a ByteString directly
02:36:43 <supki> (it's also much faster than reading a String and then packing it)
02:37:05 <wz1000> Is there any way to generate functions for newtypes?
02:37:38 <wz1000> Similar to GeneralizedNewtypeDeriving, but for functions, not instances.
02:38:58 <pavonia> Generate in what way?
02:39:53 <wz1000> Adapt functions that work on the original type to functions that work on the wrapped type.
02:45:03 <arkeet> wz1000: see Data.Coerce
02:45:42 <arkeet> (since ghc 7.8)
02:45:52 <arkeet> in fact, GeneralizedNewtypeDeriving basically uses coerce to implement derived instances
02:46:36 <m4ple> The JSON data I'm trying to parse has a pretty rich schema, especially I have many OneOf fields. anyone knows how to parse them in aeson?
02:50:32 <pavonia> What syntax is used in "Coercible * a b => a -> b" that allows the '*' there?
02:50:37 <wz1000> arkeet: Thanks, that's what I was looking for
02:52:01 <echo-area> Will MTL eventually supersede transformers?
02:52:54 <arkeet> why would it do that?
02:52:58 <arkeet> it currently depends on transformers
02:53:49 <arkeet> transfomers implements all the actual monad transformers.
02:53:59 <arkeet> mtl just gives class like MonadState and such
02:54:21 <arkeet> as such there are a few mtl alternatives
02:55:58 <echo-area> I see, thanks
02:56:10 <arkeet> such as monads-tf
02:56:57 <arkeet> and some more radical things
02:59:49 <echo-area> Okay.  I had developed a wrong intuition based on the order I discovered the libraries.  It's time to break them all down.  Thank you.
03:02:32 <jle`> echo-area: mtl is not a monad transformer library.  transforms is a monad transformer library.  mtl provides typeclasses that abstract over different types of effectful behaviors
03:03:04 <jle`> *transformers
03:03:14 <jle`> pavonia: PolyKinds
03:03:26 <jle`> oh wait maybe not
03:05:51 <pavonia> It doesn't make sense there syntactically, IMHO
03:06:15 <AshyIsMe> i want something similar to splitAt but that will do the whole list:
03:06:26 <AshyIsMe> f :: Int -> [a] -> [[a]]
03:06:39 <pavonia> :t groupsOf
03:06:40 <lambdabot> Not in scope: ‘groupsOf’
03:06:53 <pavonia> :t Data.List.Split.groupsOf
03:06:54 <lambdabot>     Not in scope: ‘Data.List.Split.groupsOf’
03:06:54 <lambdabot>     Perhaps you meant one of these:
03:06:54 <lambdabot>       ‘Data.List.Split.chunksOf’ (imported from Data.List.Split),
03:06:55 <AshyIsMe> ie: f 3 [1..]  =>  [[1,2,3],[4,5,6]...]
03:06:55 <arkeet> chunksOf
03:07:00 <pavonia> Ah
03:08:08 <arkeet> > (\n -> map snd . groupBy (const fst) . zip (cycle $ take n (False : repeat True))) 5 [0..]
03:08:10 <lambdabot>      Couldn't match type ‘[(Bool, Integer)]’ with ‘(a0, b)’
03:08:10 <lambdabot>      Expected type: [(Bool, Integer)] -> [(a0, b)]
03:08:10 <lambdabot>        Actual type: [(Bool, Integer)] -> [[(Bool, Integer)]]
03:08:12 <arkeet> hm.
03:08:30 <arkeet> > (\n -> (map . map) snd . groupBy (const fst) . zip (cycle $ take n (False : repeat True))) 5 [0..]
03:08:31 <lambdabot>  [[0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20,21,22,23,24],...
03:09:07 <arkeet> or you can just use chunksOf.
03:09:15 <jle`> pavonia: it's because Coercible can take things of different kinds
03:09:24 <jle`> pavonia: so the * says which kind you're talking about
03:09:49 <jle`> s/take/consider
03:10:09 <pavonia> Shouldn't it be "Coercible (a :: *) (b :: *)" then?
03:10:22 <jle`> the a and b are always *
03:10:46 <arkeet> pavonia: if you were writing code, sure. 
03:10:49 <jle`> it's something...deeper
03:10:54 <arkeet> pavonia: but ghc's ouptut makes kind applications explicit.
03:11:21 <arkeet> what was the question exactly? I missed it.
03:11:21 <pavonia> What does that mean?
03:11:41 <pavonia> What syntax is used in "Coercible * a b => a -> b" that allows the '*' there?
03:11:47 <arkeet> none.
03:11:54 <arkeet> you can't write that.
03:11:59 <arkeet> ghc just shows it as output.
03:12:05 <arkeet> because Coercible is poly-kinded.
03:12:21 <arkeet> so it's like
03:12:26 <arkeet> class Coercible (a :: k) (b :: k)
03:12:50 <arkeet> what you don't see here is a kind parameter, k
03:13:10 <arkeet> uh, let me show an example one level lower.
03:13:10 <pavonia> Why isn't it outputting that instead?
03:13:10 <echo-area> If I compose StateT and MaybeT but don't use MTL, is it true that I need to write bare `lift get`?
03:13:15 <arkeet> I dunno.
03:13:35 <jle`> echo-area: it depends on what you want to do
03:13:42 <jle`> and in what way you have structured your type
03:13:45 <arkeet> echo-area: yes.
03:13:54 <arkeet> assuming you mean you have like a MaybeT of a StateT.
03:14:14 <arkeet> mtl just exports its own version of get that's generalized to MonadState.
03:14:28 <arkeet> pavonia: anyway, here's the example.
03:14:31 <arkeet> consider id :: a -> a
03:14:46 <arkeet> it's polymorphic, which means there's a version of id for every type a
03:14:59 <jle`> echo-area: `lift get :: t (StateT s m) s`
03:15:31 <arkeet> there is id for Int, id for Bool, and so on.
03:15:45 <arkeet> in principle we could make such type applications explicit.
03:15:57 <jle`> so if you had MaybeT on the outside, you'd have `MaybeT (StateT s m) s`.  An action that returns underlying state
03:15:58 <arkeet> so you might think of id :: (a :: Type) -> a -> a
03:16:01 <arkeet> so one would have
03:16:04 <arkeet> id Int :: Int -> Int
03:16:07 <arkeet> id Bool :: Bool -> Bool
03:16:11 <echo-area> I see, thank you :)  I'm closer to understanding monads and monad transformers
03:16:16 <arkeet> and instead of writing id 5, one might write id Int 5.
03:16:19 <jle`> but `get :: StateT s m s`, so you might have `get :: StateT s MaybeT s`
03:16:41 <arkeet> pavonia: of course we don't actually do this because there's little value.
03:16:48 <jle`> also an action that returns the state.  but at the "outermost level"
03:16:49 <echo-area> jle`: Yes, one way needs lift but the other way doesn't
03:17:02 <arkeet> but in principle if we asked for the type of some polymorphic thing, ghc *could* tell us what type it's applied to.
03:17:20 <jle`> be aware that the order does change the semantics/meaning of what you are using
03:17:20 <arkeet> pavonia: it's the same sort of thing that is what ghc does at the kind level.
03:17:38 <arkeet> pavonia: if some data or class or whatever is poly-kinded and you ask for its type,
03:17:46 <arkeet> it will show you explicit kind annotations.
03:17:59 <arkeet> e.g. consider data Proxy (a :: k) = Proxy
03:18:10 <arkeet> with polykinds
03:18:15 <arkeet> if you write :t Proxy
03:18:25 <arkeet> it'll tell you it has type Proxy k a
03:18:41 <arkeet> (even though in code you can only write Proxy a)
03:18:54 <pavonia> That's really confusing
03:18:59 <arkeet> it makes explicit that k is the kind that this Proxy is using.
03:19:06 <arkeet> basically, you are free to ignore it.
03:19:16 <arkeet> :t Proxy
03:19:17 <lambdabot> forall (k :: BOX) (t :: k). Proxy t
03:19:22 <arkeet> heh.
03:19:24 <arkeet> that's a bit different.
03:19:45 <pavonia> What does poly-kinded mean exactly?
03:20:03 <arkeet> well, you know what a kind is, right.
03:20:09 <pavonia> Yes
03:20:29 <arkeet> and how data types or classes can have arguments of various kinds.
03:20:52 <arkeet> polykinds just lets you have a single data/class that can take types of varying kinds.
03:21:08 <arkeet> so with the above definition
03:21:18 <arkeet> you can talk about stuff not only like Proxy Int
03:21:26 <arkeet> but also Proxy Maybe, or Proxy Eq, or whatever.
03:21:41 <pavonia> Oh, I see
03:22:16 <pavonia> So is (t :: *) different from (t :: k)?
03:22:19 <arkeet> yes.
03:22:25 <arkeet> t :: * means t has the specific kind *
03:22:30 <arkeet> (the kind of plain types)
03:22:33 <AshyIsMe> arkeet: ah cheers, chunksOf
03:22:38 <arkeet> t :: k means t has kind k, which could be anything.
03:23:24 <arkeet> (when you see k :: BOX, that just means k has sort BOX. in theory one could classify kinds by sorts, but haskell only has one sort, which we call BOX.)
03:23:31 <arkeet> (basically it means "k is a kind")
03:24:09 <pavonia> Wait, BOX isn't a kind but a kind of a kind? :)
03:24:14 <arkeet> yeah.
03:24:17 <arkeet> but there is only one kind of kind.
03:24:36 <arkeet> I suggest you find something to read about PolyKinds if you're interested.
03:26:06 <pavonia> In the docs a paper "Giving Haskell a Promotion" is linked, which is probably a good start
03:27:35 <tempay> Has anyone here used easyVision? Any idea if there's documentation?
03:27:57 <pavonia> Oh well, I have to go now. Thanks for the explanation, arkeet!
03:28:00 <anderslundstedt> hello all. I am relatively new to Haskell. Is it possible to do something like the following in Haskell or with some dependently typed extension? http://lpaste.net/130121
03:28:07 <arkeet> np. I probably ought to sleep
03:28:08 <anderslundstedt> (the paste is Coq code)
03:28:32 <pavonia> See you!
03:28:59 <anderslundstedt> and more general: what is a good way to do type safe fx conversions in haskell?
03:31:13 <zerkms> spent 2 hours on this: http://pastebin.com/C2eULtPn
03:31:17 <zerkms> say anything?
03:31:37 <Darwin226> Hey, is there any particular reason why Gen from QuickCheck doesn't have an alternative instance?
03:41:13 <kaidelong> mmm, what would the alternative instance be?
03:41:29 <kaidelong> it's not clear to me you could come up with a zero for Gen
03:42:14 <kaidelong> also an associative <|> would require you to track state for a kind of running mean
03:42:35 <arkeet> it could just add weights.
03:42:49 <arkeet> but then you need to introduce weights somewhere
03:43:28 <kaidelong> making <|> isn't that hard and would probably be worth it, it's the zero that seems like the killer here
03:44:15 <arkeet> yeah, there'd be no way to define empty.
03:44:43 <nishant_nawarkhe> hi
03:47:56 <Darwin226> arkeet: How does parsec define it's empty?
03:48:06 <arkeet> empty is the parser that always fails.
03:48:20 <arkeet> without consuming input.
03:49:10 <Darwin226> arkeet: Hmmm... Yeah. That's a problem
03:50:41 <kaidelong> Data.Semigroups doesn't help
03:50:58 <arkeet> semigroupoids provides a class Alt
03:50:59 <kaidelong> although maybe there is a "functorized semigroup" thing somewhere in another package
03:51:05 <arkeet> which is basically Alternative minus empty
04:19:44 <browndawg> hey
04:21:09 <browndawg> could somebody explain to me why this function works? I never told it to terminate when x == 0. Does haskell infer that somehow? https://pastee.org/c63xg
04:22:12 <browndawg> I mean, this function should run indefinitely until we run out of memory, no?
04:22:43 <browndawg> oh
04:22:49 <browndawg> sorry, huge brainfart
04:23:12 <browndawg> it works because it's calling replicate instead of replicate'
05:21:57 <Lis> hello everyone. i still have an error http://www.mathematek.de/paste:haskell_map_list someone suggested to use statlist <- map runParser config :: [String] -> [IO [String]] but that doesnt work
05:25:12 <byorgey> Lis: as I mentioned yesterday, I think you want to use mapM instead of map
05:26:05 <Lis> byorgey, that doesnt work either. now i get Couldn't match expected type `[[String]]' with actual type `Either ParseError [[String]]'
05:26:27 <byorgey> aha, well that is progress at least.
05:26:30 <kaidelong> so you need to handle a parse error
05:26:42 <kaidelong> case statlist of
05:26:59 <kaidelong> (Left _) -> putStrLn "Parse Error"
05:27:13 <kaidelong> Right x -> writeStates config statlist
05:27:19 <kaidelong> would be one way to go about it
05:27:39 <byorgey> Lis: writeStats expects a [[String]], but runParser might succeed or fail.  So it gives you an  Either ParseError [[String]], meaning it could be  Left containing a parse error, or Right containing the [[String]] result
05:27:41 <kaidelong> you could also use this function
05:27:43 <Lis> ok thank you i try
05:27:44 <kaidelong> @type either
05:27:46 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
05:27:56 <byorgey> so you have to pattern-match as kaidelong shows, to see which it is
05:28:24 <byorgey> kaidelong: you mean  Riht x -> writeStats config x
05:28:27 <byorgey> *Right
05:28:37 <kaidelong> yes I do
05:28:39 <kaidelong> sorry
05:29:19 <kaidelong> either (const (putStrLn "Parse Error")) (writeStates config) statlist
05:29:24 <kaidelong> would be a way to use either
05:30:13 <Lis> hm but either allows to write back the parse error
05:30:27 <Lis> so i see where the parser encountered an error
05:30:27 * hackagebot tasty-silver 3.1 - Golden tests support for tasty. Fork of tasty-golden.  http://hackage.haskell.org/package/tasty-silver-3.1 (PhilippHausmann)
05:31:17 <kaidelong> oh yeah presumably the ParseError has some information you could use for a more detailed error message with something like a line number
05:31:37 <kaidelong> that was just meant as a quick hack
05:32:35 <Lis> how do i transform the <- notation to a case? 
05:32:46 <Lis> case x <- foo bar ?
05:34:37 <Lis> http://en.wikibooks.org/wiki/Haskell/Control_structures has an example
05:37:32 <Lis> hm, whats the best way to define a variable before using it in the case expression?
05:39:25 <Lis> http://www.mathematek.de/paste:haskell_map_list i wrote the changes here. but get Not in scope: `statlist'
05:43:59 <Cale> Lis: I believe you're looking for mapM
05:44:33 <Lis> cale, do i need it somewhere other than here? case statlist (mapM runHtmlParser config) of
05:45:46 <Cale> yes
05:45:51 <Cale> :t mapM
05:45:52 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
05:45:56 <Cale> oh, lol
05:46:02 <Cale> okay
05:46:06 <Cale> let's specialise that to lists
05:46:30 <Lis> now i'm confused
05:46:31 <Cale> mapM :: (Monad m) => (a -> m b) -> [a] -> m [b]
05:46:41 <Cale> and in your case, I think you want
05:46:52 <Cale> mapM :: (a -> IO b) -> [a] -> IO [b]
05:47:44 <Cale> i.e. it takes a function which says which IO action to carry out given a value of type a, and a list of values of type a, and produces an action which will basically perform a for-each loop over the list, applying the function to work out what to do
05:48:33 <Lis> ok, but i still can't guess where to change the code for it to work
05:48:52 <Cale> okay, one sec and I'll help you work through your problem :)
05:50:33 <Husel> Hey, I'm a beginner in Haskell and I was just wondering whether I could get a little help with a very basic game I'm making to practise? http://lpaste.net/7632152100398432256
05:53:00 <Cale> Lis: Okay, I'm back.
05:53:07 <Lis> wb
05:53:22 <Cale> Lis: So, what is the type of config here?
05:53:35 <Lis> [[String]]
05:53:39 <maxc01> hello everyone, I want to implement this function, but I cannot figure it out,
05:53:39 <maxc01> f g (x:xs) = if g x
05:53:39 <maxc01>               then x : f g xs
05:53:39 <maxc01>               else -- directly return Nothing and no need to continue
05:53:58 <Lis> cale i paste the whole source, whait
05:54:08 <Cale> Lis: maybe use lpaste.net
05:58:44 <Lis> maxc01, hello, i dont know much about haskell but dont you need to use a compare function for if? like if a < b?
05:59:13 <lyxia> maxc01: did you mean to return an empty list when g x is False?
05:59:41 <lyxia> maxc01: basically, are you trying to implement takeWhile?
06:01:01 <Cale> Lis: g itself might produce a Bool
06:01:10 <Cale> (in maxc01's code)
06:01:19 <maxc01> yes , Lis
06:01:41 <maxc01> I want to return an Empty list when g x if false
06:01:57 <lyxia> maxc01: else []
06:02:02 <maxc01> lyxia, it is not takeWhile
06:02:16 <Cale> maxc01: It is :)
06:02:20 <lyxia> Why not?
06:02:33 <lyxia> "While g x is true, take it"
06:02:34 <maxc01> lyxia, it is not right
06:03:00 <maxc01> for example, f even [2,4,6] = [2,4,6]
06:03:05 <Lis> ah ok
06:03:06 <Cale> > takeWhile even [2,4,6,7,8,10]
06:03:07 <lambdabot>  [2,4,6]
06:03:11 <maxc01> f even [2,4,6,1] = []
06:03:15 <lyxia> maxc01: Well you didn't cover the case when the list is empty
06:03:29 <Cale> maxc01: In that case, that's not what you wrote
06:03:48 <maxc01> takeWhile even [2,4,6,7,8,10] = [2,4,6]
06:04:00 <maxc01> but I expect it to be []
06:04:09 <Lis> cale you got my message? http://www.mathematek.de/paste:haskell_html_parse is the full code
06:04:16 <Cale> Note that even without knowing what the other branch of the function is with your f
06:04:16 <lyxia> oh I see you want the whole result to be empty when one element does not satisfy g
06:04:27 <Lis> sorry if it's uggly however i don't yet understand haskell fully
06:04:31 <Cale> We can see that f even [2,4,6,1] will be 2 : <something>
06:04:44 <Cale> Because even 2 is True
06:04:57 <Cale> So in that case, the result is  2 : f even [4,6,1]
06:05:13 <Cale> So the resulting list is *definitely* nonempty, if you write it like that
06:05:30 <Cale> If you want the list to be empty when any element fails to satisfy the predicate, you'd need something like:
06:05:59 <Cale> f g xs = if all g xs then xs else []
06:06:29 <maxc01> Cale, in fact, this is not I want
06:06:48 <maxc01> sometimes I want to do something with xs
06:06:57 <Cale> maxc01: Can you describe the function you want to write in English?
06:07:09 <Cale> Lis: oh, sorry
06:07:35 <maxc01> so f g xs = if all g xs then xs else [], will need two pass to implement this function
06:07:39 <lpaste> Cale pasted “Lis' code” at http://lpaste.net/130133
06:07:48 <maxc01> and I want just one pass
06:07:49 <Cale> ^^ there, it's a little more readable at lpaste :)
06:08:13 <maxc01> Cale, your implementation is right but it need two pass
06:08:34 <Cale> maxc01: What do you mean "two pass"?
06:08:44 <Cale> It only needs to go through the list once
06:09:06 <maxc01> in this case, it is
06:09:26 <Cale> The all g xs will test to see if all the elements of the list satisfy g. If that's true then the result is simply xs with no further computation.
06:09:41 <Cale> Otherwise, it's [], and again, no further computation needs to be done
06:09:42 <Husel> Hey, I'm a beginner in Haskell and I was just wondering whether I could get a little help with a very basic game I'm making to practise? http://lpaste.net/7632152100398432256
06:10:03 <Cale> Husel: Sure, but it might help if you had a more specific question? :)
06:10:22 <Husel> Cale: Sorry, the question is in the paste :)
06:11:14 <maxc01> for example, f g (x:xs) = if g x
06:11:14 <maxc01>                              then succ x
06:11:14 <maxc01>                              else -- directly return [] and no need to continue
06:11:21 <maxc01> sorry
06:11:55 <maxc01> f g (x:xs) = if g x
06:11:55 <maxc01>                 then succ x : f g xs
06:11:55 <maxc01>                 else -- directly return [] and no
06:12:54 <Cale> Husel: ah, okay, well, to understand why it's like that, you'll need to think carefully about how you're describing the rooms. You effectively have a tree structure
06:13:59 <Cale> Husel: When you replace the room to the north, you're passing along the current room, not the new room which gets constructed
06:14:22 <Cale> So when you go back south again, it's like you never created it, because you went back to the old version
06:14:41 <lyxia> maxc01: Please post code that takes more than one line on lpaste
06:14:42 <Cale> Lis: okay, so config :: Either ParseError [[String]
06:14:44 <Cale> oops
06:14:46 <Cale> Lis: okay, so config :: Either ParseError [[String]]
06:15:04 <Cale> So you can case config of ... if you like
06:15:25 <maxc01> Cale, lyxia, I have figured it out
06:15:52 <maxc01> let f g = mapM (\x -> x <$ guard (g x))
06:15:54 <maxc01> thanks
06:15:56 <Lis> cale where to write that ? i dont find any examples for your :: syntax
06:15:57 <Husel> Cale: Ah I see, I guessed it had something to do with immutability but couldn't work out where I was going wrong
06:16:24 <Cale> case config of Left e -> print e; Right xs -> do stats <- mapM runHtmlParser xs; writeStats config stats
06:16:28 <Cale> Lis: something like that
06:16:49 <Cale> Lis: When I say something like v :: t that's read as "v has type t"
06:16:57 <Lis> ah, ok thank you
06:17:00 <phaazon> aw
06:17:04 <phaazon> fsnotify is lovely!
06:17:44 <hjulle> Is there any class that generalizes zip/zipWith?
06:18:44 <hjulle> The same way that Traversal and Foldable generalizes fold and other list-operations
06:20:56 <Cale> :t mapM -- does anyone else find it mildly ironic that I caught flak for a long time for generalising the type of (.) in lambdabot, and now we have stuff like this?
06:20:58 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
06:21:29 <hpc> there was some debate about which generalization of (.) to use
06:21:35 <hpc> the ironic one was generic flip
06:21:39 <hpc> which was damn cool
06:22:08 <Cale> (I'm not saying the generalisation is a bad thing... it's just that Traversable in Prelude comes with all the same problems)
06:24:40 <Lis> Cale, another question, if i am done parsing the config, it would be useless to work with the parserror all the time, how can i discard it from the other functions?
06:25:11 <Lis> Cale, like, if a parseerror occurs, it should be written, but i dont need parserror in writeStats
06:28:25 <Cale> Lis: I did that in the code I gave you
06:28:45 <Cale> Lis: That's what the case expression does
06:29:11 <Cale> Lis: In the branch where an error occurred, the Left e pattern matches
06:29:29 <Cale> Lis: In the branch where it didn't occur, the Right xs pattern matches, with xs :: [[String]
06:29:31 <alynn> hjulle: yes
06:29:33 <Cale> ugh, can't type
06:29:36 <Cale> xs :: [[String]]
06:29:48 <alynn> hjulle: Applicative
06:30:38 <hjulle> > (,) <$> [1,2] <*> [3,4]
06:30:40 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
06:30:50 <hjulle> > (,) <$> ZipList [1,2] <*> ZipList [3,4]
06:30:51 <lambdabot>  ZipList {getZipList = [(1,3),(2,4)]}
06:31:50 <Lis> Cale, the code in irc ? ah ok. i didnt knew case is used for "filtering out" types
06:31:53 <Lis> ok thank you
06:34:15 <Cale> Lis: It's not exactly "filtering out", it's pattern matching the value of type Either ParseError [[String]], which *must* be of the form Left e where e :: ParseError, or of the form Right x where x :: [[String]]
06:34:40 <Cale> Lis: So, in either case, you get access to the data which you're interested in.
07:02:39 <thalaiva> Is there any thing better than Elimination Backoff for stack?
07:07:12 <thalaiva> Is there any thing better than Elimination Backoff for stack?
07:13:18 <jmcarthur> Zemyla: is that behavior for STT [] really desirable? it sounds really difficult to reason about, to me.
07:22:59 <eacameron1> I need a "persistent channel" of sorts: just like a normal channel, but the data is always backed by the filesystem in case of a crash/shutdown: any recommendations?
07:25:33 * hackagebot netrc 0.2.0.0 - Parser for .netrc files  http://hackage.haskell.org/package/netrc-0.2.0.0 (HerbertValerioRiedel)
07:31:29 <meretrix> eacameron1: This package seems like it could help:
07:31:30 <meretrix> https://hackage.haskell.org/package/Workflow-0.8.1
07:31:54 <meretrix> Or you could just use ActiveMQ bindings if you don't mind it being a bit heavyweight. 
07:33:53 <eacameron1> meretrix: Thanks! Oh yes, I remember reading about Workflow (used by MFlow web framework?). I had completely forgotten about it, but it looks really promising. I've never heard of ActiveMQ but I'll take a look
07:37:34 <eacameron1> meretrix: Do you know how Workflow handles "clean-up" of the log? When does it "garbage collect"?
07:56:27 <ahmadi> Hi , I Am looking for botnet , does anyone can help ?! skype: ankassis
08:14:53 <product--> I find it hard to read other people's code in most languages. Would I find it easier to read other people's HASKELL code?
08:16:46 <Rotaerk> product--, IMO, in other languages, a lot of people tend not to write their code in terms of abstractions, but in terms of the same, primitive language mechanisms (if statements, loops, etc), so the challenge is figuring out their intent from such low level mechanisms
08:17:24 <Rotaerk> product--, in haskell there's a lot more opportunity for abstraction, and a lot more tendency to use it, so the intent is clearer, but the challenge now is to learn all the abstractions they use
08:17:55 <Rotaerk> but once you learn them, you could use them yourself, so it's not a waste to learn it just for that one-off piece of code
08:18:02 <product--> interesting
08:18:09 <Rotaerk> that's just how I see it though
08:18:13 <product--> ok
08:32:36 <Lis> how do i convert a FilePath to String?
08:33:13 <hpc> src FilePath
08:33:16 <hpc> @src FilePath
08:33:16 <lambdabot> type FilePath = String
08:33:22 <hpc> they're already the same type
08:33:23 <geekosaur> there's another one that isn;t'
08:50:37 * hackagebot diagrams-cairo 1.2.0.7 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-1.2.0.7 (bergey)
08:50:39 * hackagebot gnuplot 0.5.3 - 2D and 3D plots using gnuplot  http://hackage.haskell.org/package/gnuplot-0.5.3 (HenningThielemann)
08:52:35 <zhiayang> anybody here familiar with shake?
08:52:55 <zhiayang> getEnv doesn't seem to be returning me anything, it's always an empty string
08:55:37 * hackagebot gnuplot 0.5.3.1 - 2D and 3D plots using gnuplot  http://hackage.haskell.org/package/gnuplot-0.5.3.1 (HenningThielemann)
08:58:47 <enthropy> zhiayang: you're calling System.Environmen.getEnv from something you've passed to shake?
08:59:08 <zhiayang> maybelconf <- getEnvWithDefault "default" "LLVM_CONFIG_APPEND"
08:59:13 <zhiayang> always returns "default"
09:00:09 * enthropy thought there might be a withEnv just like withArgs
09:00:37 * hackagebot dgim 0.0.2 - Implementation of DGIM algorithm  http://hackage.haskell.org/package/dgim-0.0.2 (musically_ut)
09:00:43 <zhiayang> nope
09:05:11 <zhiayang> enthropy: any ideas?
09:07:02 <ownclo> @pl \x y -> y * x
09:07:03 <lambdabot> (*)
09:07:51 <jmcarthur> I used to prefer Free over Operational, because I found Free simpler to understand. However, with the approach of Reflection Without Remorse, I'm wondering why one would ever prefer Free.
09:08:45 <mpickering> jmcarthur: can you explain more?
09:08:48 <jmcarthur> The RWR approach makes both about equally complicated, and the Operational implementation seems to be more efficient almost all the time.
09:09:12 <jmcarthur> I suppose the "almost" is my answer.
09:09:27 <osa1> hmm.. any ideas why ghci doesn't fail with <<loop>> ? is there a way to enable that check somehow?
09:09:49 <jmcarthur> osa1: I think you can only get that exception without -threaded, and GHCi uses -threaded.
09:11:07 <osa1> jmcarthur: I just tried and it fails with <<loop>> even with -threaded
09:11:17 <osa1> it should be something else
09:11:52 <jmcarthur> interesting. i know that didn't used to work. maybe it writes the threadid into the thunk now? seems weird. i don't know how else it could work.
09:12:21 <osa1> yeah, it should keep track of which thread blackholed it somehow
09:13:56 <jmcarthur> mpickering: not sure what aspect of this you are looking for more explanation of. was my mention of efficiency explanation enough?
09:14:20 <Geraldus> Hi folks! I have a question about Emacs' haskell-mode: I have never been able to make Emacs capable of inferring type (C-c C-t). Does anyone why this feature not working?
09:16:37 <Lis> Geraldus, do you have added haskell to your system path? can you compile programms with emacs or do you need to compile from a separate shell?
09:17:52 <noteventime> Geraldus: Does it give you any kind of feedback?
09:18:32 <Geraldus> Lis: what do you mean by «have added haskell to your system path»? Looks like I've never used Emacs to build haskell code (but I can build everything in `eshell`). How can I test is Emacs able to build haskell code?
09:18:47 <Geraldus> noteventime: it gives me «Can not guess type» message
09:19:12 <mpickering> jmcarthur: Your efficency explanation was sufficent but I was under the impression that neither Free nor Operational were actually implemented like that (yet)
09:19:27 <mpickering> free is the "cleaner" abstraction as well
09:19:44 <m4ple> hello everyone. I'm having some issues installing haskell on a new windows machine. everything installs fine, but then when I try to upgrade cabal-install, it crashes during the upgrade.
09:19:55 <mpickering> m4ple: What is the error/
09:19:59 <jmcarthur> mpickering: i'm not talking about the packages of the same names, but the concepts
09:20:14 <m4ple> Actually I'm not even sure it crashes: the process just seems to hang, but the log file is cut in the middle of a line and the process never ends
09:20:38 <jmcarthur> mpickering: i'm not sure i can convince myself which is "cleaner". sometimes i think it's one, sometimes the other.
09:20:46 <kstuart> Geraldus: is there a space in the path to the source file?
09:21:10 <kstuart> Geraldus: if so, try using path without space, see if that works.
09:21:10 <jmcarthur> mpickering: i suppose free is simpler categorically
09:21:17 <m4ple> mpickering: this is the last line of the log: http://hastebin.com/gofisazivi.tex
09:21:21 <m4ple> you will see it's cut in half
09:21:34 <Geraldus> kstuart: nope, there is no
09:21:47 <jmcarthur> mpickering: though operational is not that far off, and seems to relate more directly to using bind rather than join, which most of us do
09:21:48 <noteventime> Geraldus: Does the repl (inferior-haskell or whatever the newer one is called) work?
09:21:57 <mpickering> jmcarthur: Right, but you can't really  talk about efficency without an implementation 
09:21:59 <kstuart> Geraldus: and running ghc-mod from command line works?
09:22:06 <Geraldus> noteventime: let me check. 
09:22:52 <mpickering> and if you've been following kmett's and alex lang's type level catenable deque adventures -- I suspect that the theoretical work will see no payback for a while
09:23:10 <mpickering> didn't someone benchmark free with RWR? maybe roche?
09:23:10 <Geraldus> kstuart: Just installed upcoming ghc-mod version 0 from Daniel's repo. It works, but have to recheck with current project. Wait a bit 
09:24:03 <noteventime> Geraldus: My current setup require me to first (explicitly) load the module, dunno if that's due to something local I did, or if that's standard behaviour though
09:24:07 <dolio> Isn't the RWR stuff harder to implement for operational?
09:24:08 <kstuart> Geraldus: note, I don't use emacs so that's about all the help I can give ;)
09:24:22 <jmcarthur> mpickering: that is fair. at least in my currently non-public implementations, operational seems significantly more efficient, and i can't find a way to make free as efficient for the same use cases. i believe it has to do with the fact that free requires fmap but operational does not. also with the RWR approach, operational can be optimized to avoid the queue when the left argument is just (return x), but
09:24:23 <jmcarthur> it's less clear how to do this with free
09:24:39 <dolio> Because it has the GADT stuff with a sequence of type changing functions that have to match up?
09:24:43 <Geraldus>  noteventime: well, I switched to `Inf-Haskell-mode`. In shows me «no process»
09:24:44 <jmcarthur> *the left argument of bind
09:25:05 <jmcarthur> dolio: i find them about equivalent in terms of difficulty
09:25:33 <dolio> I thought edwardk mentioned to me that that kind of thing required a completely different queue implementation than Free.
09:25:52 <dolio> Hence the deque stuff mpickering is talking about.
09:25:59 <jmcarthur> i don't know why he said that, but i disagree with it
09:26:05 <dolio> Maybe that was something else, though.
09:26:13 <jmcarthur> i suspect so
09:26:17 <dolio> Oh, maybe it's because he has multi-way branching or something.
09:26:22 <jmcarthur> afaik, edwardk is after deques for free categories
09:26:29 <noteventime> Geraldus: Switched to, you mean you changed the mode? If so, that's not what you want to do, reopen your haskell file in haskell-mode and press (I believe) C-c C-l
09:26:53 <Geraldus> kstuart: it's ok. BTW, gcc-mod fails with current project: Warning:: Could not find a componenet assignment, falling back to sandbox only
09:26:54 <Geraldus>           project options.
09:27:01 <jmcarthur> since with a free category it makes more sense that you might want to access *either* end in constant time
09:27:05 <Lis> Geraldus, this seems like a bug. if eshell works your environment setup is ok btw. but you should try the github version. https://github.com/haskell/haskell-mode be shure to remove any compile elc files
09:27:30 <m4ple> update: the same happens if I try to install another package without upgrading cabal first. This time the log is just empty, completely.
09:27:32 <dolio> Well, now maybe I am confused, because operational looks a lot like a free category.
09:28:27 <Geraldus> Lis: I'll try in few minutes.
09:29:15 <jmcarthur> dolio: this is off the top of my head rather than copied from my implementation, so it might be wrong, but this should give you an idea:   data Operational f a where Return :: a -> Operational f a; Bind :: f a -> Steque (Kleisli (Operational f) a b) -> Operational f b
09:29:22 <Geraldus> noteventime: ok, tried your suggestion. haskell-mode complained: haskell-mode-enable-process-minor-mode: You tried to do an interaction command, but an interaction mode has not been enabled yet.
09:29:37 <Geraldus> Run M-x describe-variable haskell-mode-hook for a list of such modes.
09:30:39 * hackagebot fixed-length 0.0 - Lists with statically known length based on non-empty package.  http://hackage.haskell.org/package/fixed-length-0.0 (HenningThielemann)
09:30:41 * hackagebot Concurrential 0.1.0.0 - Mix concurrent and sequential computation  http://hackage.haskell.org/package/Concurrential-0.1.0.0 (alexvieth)
09:30:48 <jmcarthur> dolio: so i guess Steque (Kleisli (Operational f) a b) is your free category. it's just that there is no need to access the back in this case.
09:31:00 <dolio> Oh.
09:31:16 <dolio> You only ever look at the f a?
09:31:18 <jmcarthur> and i got the parens wrong, sorry
09:31:30 <jmcarthur> well, you only need to look at one f a at a time
09:31:37 <jmcarthur> usually
09:31:59 <jmcarthur> the view function just transforms the steque into an operational
09:32:02 <Lis> bb later
09:32:13 <Geraldus> noteventime: can you suggest anything? Description of haskell-mode-hook is not very helpful
09:33:00 <noteventime> Geraldus: That might be the issue, I think it's related to there being different interactive modes, give me a sec, I'll check what I've set (I set this up rather a long time ago, and I don't remember exactly what I did)
09:33:26 <Geraldus> thank you very much!
09:33:49 <jmcarthur> dolio: you can think of (Operational f) as something like Free (CoYoneda f), if it's just that you weren't quite clear on what it actually is.
09:34:38 <m4ple> well, I guess I'm dual booting linux... again.
09:34:55 <dolio> No, I knew what it was.
09:35:17 <AshyIsMe> is there a way to do pattern matching on Vectors?
09:35:19 <Fuuzetsu> (repost from sleeping ##categorytheory): surely the γ in http://fuuzetsu.co.uk/images/1428164992.png is meant to go on the other diagonal, right?
09:35:26 <dolio> I guess I don't know why Ed needs deques, though.
09:35:32 <noteventime> Geraldus: Is haskell-process-type set?
09:35:39 * hackagebot fixed-length 0.0.0.1 - Lists with statically known length based on non-empty package.  http://hackage.haskell.org/package/fixed-length-0.0.0.1 (HenningThielemann)
09:35:41 <jmcarthur> yeah, i think it's just for free categories in general
09:35:53 <AshyIsMe> i basically want to do: f :: Vector Word8 -> [Word]
09:36:09 <AshyIsMe> (Word is 4 Word8s)
09:36:43 <Geraldus> noteventime: I believe it is not. Haven't seen anything about it in docs (guess it's my bad)
09:36:46 <AshyIsMe> i spose i could go Vector Word8 -> [Word8] and then just do list pattern matching
09:37:01 <AshyIsMe> and performance issues can be a problem for future AshyIsMe 
09:37:15 <noteventime> Geraldus: Try customize-variable on haskell-process-type, it should give you a couple of different options
09:37:20 <Geraldus> noteventime: I have `auto` value stored in it
09:37:20 <jmcarthur> dolio: here's a full implementation of operational in the RWR style, though it uses, i believe, a less efficient representation than mine: https://github.com/atzeus/reflection-without-remorse/blob/master/Control/Monad/Operational/Reflectable.hs
09:37:50 <jmcarthur> (by just some little constant factor, due to more allocations)
09:38:30 <noteventime> Geraldus: What happens if you set it to something explicit (the options here are: ghci, cabal-repl, cabal-dev, cabal-ghci)?
09:39:12 <noteventime> Try ghci just to see if it changes anything (I have it set to cabal-repl because I tend to use cabal sandboxes)
09:40:15 <dolio> jmcarthur: If it's based on sequence it probably has a couple other problems, too. I've been biding my time trying to decide whether to figure out how to fix everything convincingly, or for Ed's free package to get all this stuff.
09:40:21 <jmcarthur> anyway, i am working on this in ocaml at the moment. i ended up designing my own catenable steque (which i should eventually port to haskell), but it's comparing quite favorable to the naive free so far.
09:40:49 <Geraldus> noteventime: no matter what I choose, I still have same message about interaction mode. Note, I save state for current session
09:41:12 <jmcarthur> dolio: by "sequence" you mean "Data.Sequence"? either way, what problems are you talking about?
09:41:38 <dolio> No, I mean the package the author of that wrote.
09:41:41 <jmcarthur> ah
09:41:49 <jmcarthur> yeah, i don't like that one
09:42:37 <jmcarthur> it kind of falls apart with things like recursive catenation
09:42:41 <noteventime> Geraldus: What happens if you run inferior-haskell-load-file in the haskell-mode buffer?
09:43:02 <jmcarthur> and the underlying real time non-catenable steque is too slow
09:43:48 <dolio> I was thinking more basic stuff. It's kind of code that was written for a research paper; not the most polished stuff.
09:44:01 <dolio> Probably because it was written for a research paper. :)
09:44:25 <Geraldus> noteventime: well, it tries to load my file into ghci (and fails, cause this is yesod project, thus I need cabalish ghci in this case).
09:44:52 <jmcarthur> i have implemented a steque that sort of combines the ideas of a banker's queue and implicit recursive slowdown, and it's quite fast so far. gc overhead grows a bit too much for very large numbers of elements, but i think for an Operational implementation it won't typically be used at such sizes
09:45:10 <Geraldus> noteventime: very appreciate your help
09:45:30 <jmcarthur> but for sane sizes it has faster cons, snoc, and viewl than Data.Sequence, and it has a fast constant-time append
09:45:43 <noteventime> Geraldus: Sorry about just trying random stuff, hoping it will give some sort of usable error message :)
09:45:50 <mpickering> jmcarthur: this sounds very interesting 
09:46:05 <Geraldus> oh, I guess this is because I've set haskell process type to ghci. Let me check auto
09:46:06 <noteventime> Geraldus: Do things work in other projects?
09:46:11 <jmcarthur> i haven't proven the bounds of it yet though
09:46:23 <jmcarthur> but i think it intuitively makes sense
09:46:26 <noteventime> Geraldus: I don't think haskell-process-type affects inferior-haskell mode, but try it anyway :)
09:47:34 <Geraldus> noteventime: yep, it is not. Let me check another project…
09:47:46 <noteventime> Geraldus: Just do some trivial dummy file
09:48:40 <jmcarthur> mpickering:   a not-optimized, non-type-threaded representation:   data Steque a = Empty | Singleton a | Steque !Int !(TwoOrMore a) (Steque (Entry a)) !Int !(ZeroOrMore a);  data Entry a = Entry (TwoOrMore a) (Steque (Entry a))
09:49:34 <Geraldus> noteventime: Well, I'm able to `inferior-haskell-load-file` some files from another project
09:49:45 <Geraldus> but still can't infer type :(
09:50:07 <jmcarthur> mpickering: the idea is that the "front" is made up of the two fields (TwoOrMore a) and (Steque (Entry a)), for purposes of counting the elements in the front. when the back has more elements than the front, you enqueue the reversed back in the middle. catenation consists of enqueueing the front of the right steque into the back of the left one, with a little extra shuffling of spare elements in the back of
09:50:08 <jmcarthur> the left steque
09:51:07 <jmcarthur> mpickering: so it's like a banker's queue that doesn't rebuild the front over and over. or it's like an implicit recursive slowdown queue that can push much larger sequences of elements down per step, if the front is large
09:51:26 <noteventime> Geraldus: I'm guessing that's because the type lookup tries to use the newer haskell-interactive-mode 
09:51:37 <noteventime> Geraldus: What happens if you try C-c C-l instead?
09:51:59 <noteventime> (since C-c C-l seemed to be set up for interactive rather than inferior mode)
09:52:15 <jellie> noteventime: I get a repl for that
09:52:19 <jellie> I mean with that
09:52:56 <noteventime> jellie: Yes, but an inferior-haskell or a haskell-process thing?
09:53:08 <Geraldus> noteventime: still same output. Well, maybe I should ask a question on StackOverflow…
09:54:31 <jellie> noteventime: This is what I have in my .emacs "  (define-key haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-or-reload)"
09:54:37 <jellie> noteventime: That's all I know.
09:54:38 <noteventime> Geraldus: My best guess is that there's something not properly set up, have you tried following something like https://github.com/haskell/haskell-mode/wiki/Haskell-Interactive-Mode-Setup ?
09:55:06 <noteventime> jellie: Yes, that's the newer one, for some reason it fails for Geraldus 
09:55:41 <Geraldus> noteventime: nope, I'll have a look now.
09:55:43 <noteventime> Geraldus: You already seem to have their keybindings, but perhaps there's something else you missed?
09:55:44 * ion watched and learned a lot from Adventure with Types in Haskell by SPJ: https://www.youtube.com/playlist?list=PLs-L6w88OnEZzTtynMEEThz4LZY2HDP7g
09:55:45 <jellie> Geraldus: Did you get your haskell mode from melpa or whatever package manager emacs uses?
09:56:00 <jellie> noteventime: Version issues
09:56:08 <jellie> noteventime: Maybe an update could help
09:56:19 <Geraldus> jellie: yes, I do have MELPA installation
09:56:42 <noteventime> Version issues is a good point
09:56:43 <jellie> Geraldus: Um when did you do this install?
09:56:51 <elfeck> hello. I have a xs :: [Html] and want to expand it to something like this: "do x1; x2; ..."
09:56:58 <elfeck> how can I do that?
09:57:14 <Geraldus> jellie: I've updated haskell-mode today
09:57:31 <jellie> Geraldus: and it broke today?
09:57:44 <Geraldus> elfeck: maybe you are looking for mapM?
09:58:15 * jellie notes not to update his emacs packages
09:58:15 <noteventime> elfeck: sequence?
09:58:24 <Geraldus> jellie: no, in fact I have never been able to infer types in Emacs :(
09:58:27 <elfeck> yes I want them in a sequence
09:58:30 <elfeck> how can I do that
09:58:32 <AshyIsMe> how do i construct a Word32 from four Word8s?
09:58:33 <elfeck> list to sequence?
09:58:52 <noteventime> elfeck: There is a function called sequence (or probably sequence_ in your case)
09:58:56 <orion> Hi. Is there a Haskell package which allows me to not only read configuration files, but write back to them?
09:58:58 <noteventime> that does exactly that
09:58:58 <Geraldus> :t mapM
09:59:00 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
09:59:05 <noteventime> :t sequence_
09:59:06 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
09:59:24 <Geraldus> :t mapM undefined [a]
09:59:25 <lambdabot> Monad m => m [b]
10:00:41 * hackagebot tasty-silver 3.1.1 - Golden tests support for tasty. Fork of tasty-golden.  http://hackage.haskell.org/package/tasty-silver-3.1.1 (PhilippHausmann)
10:01:12 <noteventime> elfeck: sequence is, roughly, foldl1 (>>), so it should do what you want 
10:01:52 <jellie> Geraldus: It sucks that I can't find the resource that I used when setting up emacs for haskell.
10:02:08 <ion> ashyisme: (fromIntegral a `shiftL` 24) .|. (fromIntegral b `shiftL` 16) .|. (fromIntegral c `shiftL` 8) .|. fromIntegral d
10:02:16 <jellie> Geraldus: It was a really nice walkthrough as a Github readme. What did you use when setting up?
10:02:25 <elfeck> I am trying it right now noteventime
10:03:19 <jellie> Geraldus: AH here https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md
10:03:21 <Geraldus> jellie: and I have a lot of them opened in browser, but have no time to read them :D let me check one more thing: `(add-hook 'haskell-mode-hook 'interactive-haskell-mode)
10:03:27 <jellie> Geraldus: If you don't mind reinstalls
10:03:55 <noteventime> Actually, I think my install is just pure emacs-prelude
10:04:09 <noteventime> with just one or two customised variables 
10:05:21 <jellie> Geraldus: I'm almost sure that will work. You don't have to install/follow everything. Just the ones you need.
10:06:20 <AshyIsMe> ion: cheers
10:06:21 <laudiacay_mobile> https://downloads.haskell.org/~ghc/7.0.4/docs/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html WTF
10:06:32 <Geraldus> jellie: ok, I've this one opened in browser too. I've added interactive-haskell-mode, and now I have a progress! 
10:06:42 <jellie> Geraldus: Trye to get ghc-mod. It's awesome
10:06:49 <jellie> Geraldus: Nice
10:06:51 <Geraldus> now it complains: haskell-interactive-session: No session associated with this buffer. Try M-x haskell-session-change or report this as a bug.
10:07:03 <Geraldus> jellie: I do have ghc-mod
10:07:30 <Geraldus> BTW I've reinstall haskell environment completely to make GHC-MOD working with GHC 7.8.4 and cabal-1.22
10:07:32 <Luke> i recently ditched ghc-mod for ghci 
10:08:06 <jellie> Luke: Do they do the same thing?
10:08:08 <Geraldus> and now I want to make Emacs even more awesome (making it capable to infer types :D )
10:08:10 <jellie> Geraldus: The issue with me is that I hardly get how emacs works :(
10:08:35 <jellie> Geraldus: All I did was follow tutorials and remember how to use.
10:08:42 <Luke> jellie: the haskell-mode guys have been doing a ton of work to actually get a lot of cool new features in ghci
10:08:47 <Luke> is has more code nav stuff than ghc-mod
10:08:57 <Luke> ghc-mod is a separate process. i'm already running ghci anyway
10:09:07 <ownclo> Hi! How would you write a function that extracts first elements from a nested list, such as 'f [[1,2],[3,4]] =?> [(1, [[2],[3,4]]), (3, [[1,2],[4]])]'?
10:09:12 <athan_> In Wai, there are warnings of Lazy I/O: http://hackage.haskell.org/package/wai-3.0.2.3/docs/Network-Wai.html#v:lazyRequestBody - what exactly are these warnings?
10:09:14 <Geraldus> Luke: how can exploit all that stuff with Emacs?
10:09:29 <Luke> basically haskell-mode can use one ghci process for flycheck, code nav, REPL, etc etc
10:09:39 <Luke> Geraldus: i wrote a blog about it. let me find it
10:09:43 <jellie> Luke: hmmm I don't know. Does `cabal repl` run ghci in the background?
10:09:57 <Luke> jellie: yeah
10:10:12 <jellie> Luke: Yeah show me. I need to reinstall my emacs and haskell stuff.
10:10:23 <Luke> http://blog.hoersten.co/post/110096363794/modern-emacs-haskell-mode
10:10:25 <Luke> found it
10:10:47 <Luke> also hi2, which I use for indentation, just got included in haskell-mode since this blog post as the main indentation mode
10:11:05 <elfeck> hm can someone tell me how I get [Html] to Html by just putting the htmls after each other? sequence is not working
10:11:37 <Geraldus> jellie: now, when I tried `haskell-session-change` it asks me quite confusing question: Start a new project named "gameoflife". It's strange, cause this is already a cabal project
10:11:48 <jellie> Luke: Will that indentation stuff work automatically in emacs?
10:12:02 <Luke> jellie: Geraldus you guys should check out #haskell-emacs - i'm certainly not an expert on this stuff like chris done or gracjan
10:12:14 <Luke> jellie: what do you mean automatically?
10:12:24 <jellie> Luke: I have this line in my .emacs "(add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)" will I still need it?
10:12:33 <Luke> yes. that's what you need
10:12:35 <noteventime> Geraldus: I think "project" is an emacs thing here
10:12:38 <noteventime> It asks me the same
10:12:40 <jellie> Geraldus: Say yes
10:12:43 <Luke> jellie: that used to turn on some old indentation mode, now that turns on hi2
10:12:45 <jellie> Geraldus: It's about to work
10:12:53 <noteventime> Not sure if it's some sort of projectile intergration or something like that
10:13:03 <jellie> Geraldus: Mine always does that for me. It like creates a temp haskell project that it throws out.
10:13:25 <jellie> Geraldus: It will ask a few questions. Just don't resist. Keep hitting enter.
10:13:30 <Geraldus> Luke: thanks, I'll study your article now. I've visited #haskell-emacs, but have got no response there.
10:13:31 <Luke> Geraldus: the project thing for haskell-mode doesn't actually make any files. it just means "track your cabal as a project"
10:13:46 <Geraldus> jellie: oh, got it, let me check!
10:13:51 <Luke> project in haskell-mode doesn't actually make new files or anything
10:14:00 <jellie> Luke: WHat you said makes more sense
10:14:15 <Luke> yeah it took me a long time to figure all this out. that's why I blogged it
10:14:42 <Luke> there's like 5 indentation modes for example so I tried them all and figured out which one is the most supported and the latest etc
10:14:58 <Luke> then I realized there's really only hindent and hi2
10:15:22 <Luke> i used ghc-mod for a long time but I wanted to minimize the number of modes and processes running etc
10:15:30 <koala_man> could someone with OS X try http://lpaste.net/8625597118502928384 (with regex-compat) and see if it gives you a runtime error?
10:15:38 <Geraldus> jellie: wow, now I have cool λ—prompt. Though dunno what it actually is. Let me check type inferrense now
10:15:43 <Luke> if I assume I'll always be running ghci anyway then it makes sense to run everything code checking wise through ghci
10:15:58 <jellie> Geraldus: Yeah that's what you want
10:16:04 <jellie> Geraldus: You have a repl
10:16:25 <Geraldus> Luke: I use Structured-Haskell-Mode. Very helpful. 
10:16:26 <jmcarthur> athan_: lazy IO means that IO will happens just as a result of evaluation. this can be very difficult to reason about. resources might not be freed when you expect them to. you might get exceptions in unexpected places. some lazy IO doesn't even tell you about errors and just does something like terminating a lazily generated list, as though it was correct...
10:16:37 <Geraldus> There is its own indentation
10:17:00 <jmcarthur> athan_: sometimes it's okay for quick and dirty stuff, but i avoid it for anything large
10:17:02 <jellie> Luke: Are you uh on twitter with the Name Luke Hoer... (I don't want to say your full name).
10:17:04 <athan_> jmcarthur: That sounds terrible! Thank you for the insight
10:17:35 <noteventime> Geraldus: You got it working?
10:18:14 <Geraldus> jellie: Voila! Now it works! Thank you very very much, pal! Pity, but it can't infer types in `where` and `let` blocks :( 
10:18:23 <Luke> Geraldus: yeah but that doesn't do formatting. basically if you're using shm hindent is recommended i think
10:18:28 <Luke> jellie: yeah
10:18:30 <Geraldus> noteventime: Yes! Thank you too!
10:18:37 <noteventime> nice
10:18:58 <wolf_mozart> does haskell promote code re-use?
10:19:01 <noteventime> Geraldus: So the problem was just that you hadn't added interactive-mode to the haskell-mode hook?
10:19:05 <jellie> Luke: The website listed there is different from the one in your blog though :(
10:19:08 <Geraldus> Luke: when using SHM you have to disable any indentation-mode, this mentioned in SHM's wiki
10:19:22 <Luke> jellie: on twitter?
10:19:32 <Geraldus> noteventime: right
10:19:42 <Luke> jellie: one's personal and one's for coding stuff
10:19:45 <jellie> Geraldus: What do you mean infer types? Are you writing functions in the repl? I have never written functions in the repl. Maybe lambdas
10:19:53 <jellie> Luke: Yes on twitter
10:20:32 <wolf_mozart> does haskell enable one to re-use code better?
10:20:37 <Luke> Geraldus: yeah it interferes- that's why it think chris done wrote hindent
10:20:46 <Geraldus> I will be really happy when I will be able to exploit recently open sourced FP Complete IDE tools with Emacs
10:20:49 <wolf_mozart> better than OO does?
10:21:02 <Geraldus> wolf_mozart: much better
10:21:09 <jmcarthur> wolf_mozart: tons of code reuse. a lot of functions are made which would be considered too trivial in other languages (or too difficult to abstract out at all)
10:21:10 <jellie> Geraldus: Welcome but don't thank me alone. I hardly helped. Thank noteventime and Luke 
10:21:12 <Luke> Geraldus: chris done is a major contributor to haskell-mode and I think works for FPComplete
10:21:26 <Geraldus> Actually, I've never seen language much modular and composable than Haskell
10:21:36 <jellie> Luke: Oh my does he now?
10:21:44 <monochrom> I think in practice almost everything else reuses code better than OO does.
10:21:53 <Luke> monochrom: agreed =)
10:21:56 <noteventime> jellie: I just ran around in circles trying random stuff :P
10:22:38 <Geraldus> :D 
10:22:53 <jellie> Luke: Yeah Chris Done is very helpful on irc. Though he's hardly ever here nowadays.
10:23:03 <jellie> noteventime: That's me all the time when using emacs
10:23:10 <Luke> jellie: he's on #haskell-emacs all the time
10:23:11 <wolf_mozart> i feel like OO limited code re-use for me, I make a class, and the functions go in there, and they are for the object's use only
10:23:20 <monochrom> instead, it is more informative to ask "does Haskell reuse code better than, say, SML does"
10:23:27 <Luke> jellie: gracjan too for haskell-emacs stuff
10:23:44 <wolf_mozart> well does it monochrom?
10:23:59 <monochrom> "informative" in the information theory sense, i.e., the probability is actually closer to 50-50
10:25:32 <Geraldus> jellie: I often need to check the the type of functions I wrote in where clause, when compiler complains on me, I mean it will be very helpful to see what type I've got just moving point to function name and pressing some keys
10:25:57 <wolf_mozart> it's certainly interesting, it's like creating specific stand alone functions that can be used in more than one application
10:26:53 <noteventime> Geraldus: Sometimes you can use typed holes for that
10:27:41 <noteventime> the warning message will include relevant local bindings 
10:28:19 <jellie> Geraldus: You can do that with :t <functionName>
10:28:40 <jellie> Geraldus: Since the repl has already loaded your module.
10:28:47 <wolf_mozart> when building libraries, how would u group the fuctions of some type, all math functiions go in file math
10:28:48 <noteventime> jellie: Only if its in global scope though, right?
10:28:56 <jellie> noteventime: Right
10:29:17 <Geraldus> jellie: sorry, maybe I was unclear, :t fun_name will not work with functions defined inside let or where clauses, will it?
10:29:17 <mpickering> Geraldus: What are you using to infer types?
10:29:28 <jellie> Geraldus: It wont.
10:29:34 <Geraldus> mpickering: C-c C-t
10:29:35 <koala_man> is anyone using OS X? I'm getting reports of a runtime error when regex matching unicode strings, but I can't reproduce it on Linux.
10:29:44 <jellie> Is there a way to check these types? I don't know.
10:29:52 <jellie> Geraldus: ^
10:30:07 <monochrom> to compare Haskell with SML you will have to go above functions. you will have to 1. compare non-strictness vs strictness and how they affect composition; 2. compare type classes vs parameterized modules and how they affect abstraction. if you haven't known those 4 things, then I would be talking wind even if I talked.
10:30:48 <Geraldus> noteventime: hole driven programming is the technique I want to learn. I've seen it only once on youtube. Is there some articles about?
10:30:58 <jellie> noteventime: Man I tried using typed holes and failed the other day. I don't even know why things sometimes fail on me.
10:31:04 <Geraldus> koala_man: I do
10:31:35 <koala_man> Geraldus: would you mind trying this in ghci and see if you get a runtime error? http://lpaste.net/8625597118502928384
10:31:36 <phaazon> hey, I’m looking for ideas to implement a « resource manager », that is, being able to load stuff from IO once, and used cached version afterwards
10:31:38 <jellie> @hoogle _hole -> IO ()
10:31:40 <noteventime> Geraldus: I think there's a tutorial on the wiki
10:31:40 <lambdabot> Control.Concurrent.SampleVar writeSampleVar :: SampleVar a -> a -> IO ()
10:31:40 <lambdabot> Control.Concurrent.MVar putMVar :: MVar a -> a -> IO ()
10:31:40 <lambdabot> Data.IORef writeIORef :: IORef a -> a -> IO ()
10:31:56 <phaazon> I’m not sure a “Store” is what I’m looking for
10:31:57 <jellie> Geraldus: it's that simple. You don't need an article
10:32:00 <noteventime> Geraldus: https://wiki.haskell.org/GHC/Typed_holes
10:32:01 <Geraldus> jellie: well, have you seen FP Complete IDE? It's completely able to infer type of any marked expression
10:33:14 <jellie> Geraldus: No I haven't such a shame considering my github says I'm part of that org. Though I'm just a noob. I should be doing something with it's newly open sourced backend if all goes well.
10:33:45 <jellie> Geraldus: Forgive my punctuation. I'm always in a hurry.
10:34:19 <mpickering> jellie: like what precisely :) ?
10:34:33 <jellie> mpickering: What do you mean?
10:34:42 <mpickering> "I should be doing something with it's newly open  sourced backend if all goes well.
10:34:45 <mpickering> "
10:35:01 <mpickering> I'm interested about what kind of projects will start to use it
10:35:16 <Geraldus> koala_man: I need to install something. I have not Text.Regex module. Which package should I use?
10:35:26 <koala_man> Geraldus: regex-compat
10:35:35 <Geraldus> koala_man: hold a while
10:35:41 <koala_man> thanks
10:36:00 <Geraldus> noteventime: thanks!
10:36:43 <wolf_mozart> when building libraries, how would u group the fuctions of some type, all math functiions go in file math
10:36:46 <jellie> mpickering: Let me look fot it.
10:37:22 <mpickering> wolf_mozart: It's very hard to answer that question, you get to know by experience
10:37:46 <jellie> mpickering: I don't know if it' right for me to show you a google summer of code project proposal.
10:37:46 <mpickering> a good thing to do is to try using your own library and see what kind of functions you import 
10:37:58 <jellie> mpickering: I don't even know if you can view it.
10:38:02 <lpaste> Geraldus pasted “Text.Regex fail on OS X” at http://lpaste.net/130149
10:38:11 <noteventime> wolf_mozart: check out some packages on hackage 
10:38:20 <jellie> mpickering: Title is improvements to yesod-devel
10:38:22 <mpickering> I posted mine publicly on the mailing list
10:38:35 <Geraldus> koala_man: it fails, details in paste above
10:38:39 <jellie> mpickering: are you talking to me?
10:38:43 <mpickering> yes
10:39:02 <koala_man> Geraldus: blerk. yes, that's the one. really appreciate it
10:39:21 <jellie> mpickering: Did you get it?
10:39:33 <koala_man> Geraldus: does this regex-tdfa version work better? http://lpaste.net/350699992572231680
10:39:34 <Geraldus> koala_man: glad to help, sorry, ignored your question first time
10:40:40 <Geraldus> koala_man: which package should I install this time? (:
10:41:00 <koala_man> Geraldus: regex-tdfa :)
10:42:10 <Geraldus> jellie: in case you haven't seen FP Complete IDE have a look: it's amazing tool! https://www.fpcomplete.com/
10:42:29 <Geraldus> I dream my Emacs have same functionally 
10:42:32 <jellie> Geraldus: I have sampled it but never actually used it in a project
10:42:56 <Geraldus> koala_man: still building it
10:44:21 <Geraldus> koala_man: well, it works. I've got `True False  False True` as output
10:44:44 <koala_man> Geraldus: awesome, thanks!
10:47:48 <Geraldus> koala_man: not at all! glad to be helpful!
10:50:25 <Geraldus> jellie, noteventime, Luke, mpickering thank you all
10:50:33 <noteventime> no worries 
10:52:07 <jellie> Geraldus: Welcome, talk to me about haskell and emacs anytime.
10:52:41 <Geraldus> jellie: appreciate!
10:52:46 <johnw> Geraldus: you can hook up your Emacs to the FPco IDE
10:53:11 <jellie> johnw: What exactly do you mean by that?
10:53:29 <johnw> you edit the code in Emacs, but it saves it on their server and gives you the same syntax highlighting and editing capabilities
10:53:42 <Geraldus> johnw: wow, can you share some instructions? All I knew is from recent announcement about open sourcing FPco
10:53:43 <johnw> ask chrisdone in #haskell-emacs if you see him on
10:53:47 <Geraldus> IDE
10:53:59 <johnw> i don't use it, so I can't help
10:54:09 <Geraldus> johnw: got it. Thanks!
10:54:20 <noteventime> they're releasing the source code?
10:55:01 <Geraldus> noteventime: https://www.fpcomplete.com/blog/2015/03/announce-ide-backend
10:56:23 <noteventime> Geraldus: neat
10:56:24 <johnw> ide-backend isn't what you need to hook up Emacs
10:56:36 <johnw> ide-backend is just an API for talking to a resident GHC
10:56:42 <johnw> it's a low-level tool
10:56:50 <johnw> FPco also has a way to integrate editors with their IDE
10:57:38 <Geraldus> johnw: but if I want write GHCJS code? I suppose FPco IDE is not able to compile it, does it?
10:57:51 <johnw> that I have no idea
10:57:54 <Geraldus> *what if
10:58:44 <johnw> actually, the only part of that sentence you needed to correct was s/does it/will it
10:58:55 <Geraldus> so, though I've seen, that IDE-backend uses GHCJS internally, I believe for building client side IDE code
10:59:06 <noteventime> Geraldus, johnw: Looks like ide-backend-mode supports the kind of local binding type lookup Geraldus was asking for earlier though
10:59:19 <johnw> noteventime: for Emacs?
10:59:25 <noteventime> johnw: Yes
10:59:27 <Geraldus> right
10:59:28 <johnw> cool
10:59:35 <johnw> ok, then things have advanced since I last knew that library
10:59:36 <noteventime> I'm looking at the video on the blog post Geraldus linked
10:59:37 <johnw> carry on :)
10:59:48 <noteventime> I might be missing something, but it looks like it
11:00:35 <Geraldus> johnw: very appreciate your notice, I really miss this kind of interaction with native English speakers
11:01:37 <Geraldus> noteventime: there is FPView tool overview, it looks great, but I want this as part of my Emacs workflow
11:01:49 <noteventime> Geraldus: I was looking at the first video in the post
11:02:08 <johnw> Geraldus: until you made that correction, I didn't know you weren't a native speaker ;)
11:02:16 <noteventime> Geraldus: https://www.youtube.com/watch?v=Cwi1p2CLW54
11:04:23 <Geraldus> johnw: oh, thank you, but English is very error prone and ugly from time to time. A lot of troubles with tenses and articles (a, the) 
11:04:34 <johnw> haha, from time to time
11:04:39 <johnw> a good euphemism for all the time
11:04:40 <Geraldus> *my English
11:04:49 <johnw> oh, it was still equally true
11:05:02 <johnw> with or without the "my"
11:06:12 <noteventime> English has a lot of implicit coercion going on :P
11:10:32 <johnw> s/with//
11:10:36 <Geraldus> johnw: thanks, got it (:
11:11:17 <johnw> so, English bad, Geraldus good :)
11:12:51 <Geraldus> :D 
11:16:25 <Geraldus> it was so fun to char with all of you, making me forgot what I wanted to do after fixing type inference (%
11:16:45 <Javran> /chat/
11:17:29 <Geraldus> oh, it was a typo
11:18:07 <noteventime> It's leet hacker slang, let's Char a bit 
11:18:29 <Geraldus> :)
11:18:43 <Javran> xD
11:20:46 * hackagebot fixed-length 0.0.0.2 - Lists with statically known length based on non-empty package.  http://hackage.haskell.org/package/fixed-length-0.0.0.2 (HenningThielemann)
11:20:48 * hackagebot fixed-length 0.1 - Lists with statically known length based on non-empty package.  http://hackage.haskell.org/package/fixed-length-0.1 (HenningThielemann)
11:22:45 <Javran> @let map' f (a,b) = (f a, b+1)
11:22:47 <lambdabot>  Defined.
11:22:57 <Javran> > map' id . map' id $ (1,1)
11:22:59 <lambdabot>  (1,3)
11:23:06 <Javran> > map' (id . id) $ (1,1)
11:23:08 <lambdabot>  (1,2)
11:23:34 <Javran> any more interesting example to say that the first functor law is useful?
11:24:34 <johnw> the first functor law rules out definitions like: fmap _ xs = [] for []
11:25:22 <monochrom> life would suck seriously if the first law were absent.
11:25:46 * hackagebot filediff 0.1.0.2 - Diffing and patching module  http://hackage.haskell.org/package/filediff-0.1.0.2 (bgwines)
11:26:01 <jle`> almost every instance that the first law was not true for would be very silly and annoying to work with v.v
11:26:25 <Javran> :(
11:26:50 <jle`> why  :( ? this just means that every Functor instance is good because they all follow the first law :D
11:26:56 <monochrom> this is one of those instances where you have always taken something for granted, so you don't see them useful until one day they are removed. for example air, water, electricity, internet.
11:27:03 <Javran> the second law looks more interesting though
11:27:14 <johnw> the second law is the less interesting of the two!
11:27:29 <jle`> second law is actually "derivable" from the first law + parametricity i think
11:27:36 <johnw> yes, it follows from the free theorem for fmap
11:27:46 <johnw> I don't think you even need the first law for it
11:27:50 <Javran> well I don't know that part
11:28:49 <Javran> what I understand about free theorem is that if it's forall a something, you can do nothing specific about a
11:28:57 <jle`> fmap (+2) (Just 3) ==> Nothing
11:29:02 <jle`> oops!
11:29:13 <monochrom> top 7 things that look trivially useless until one day you are deprived of them: air, water, electricity, internet, 0+x=x, 1*x=x, fmap id = id
11:29:16 <jle`> (the first law prevents things like this)
11:30:05 <johnw> Javran: right, so if you have (a -> b) -> f a -> f b, the only thing you can do is either use that function to map a -> b, or concoct an arbitrary f b (which the 1st law rules out); there's no other way to get the 'b' that you need
11:31:37 <Javran> johnw: I see
11:34:48 <johnw> and I can know that by parametricity, without needing a specific proof, whereas I need a proof for the first law
11:36:00 <Javran> I'm still thinking about how does the first law rules out the possibility of creating an arbitrary f b
11:36:10 <johnw> fmap _ _ = []
11:36:17 <johnw> means: fmap _ [1, 2, 3] = []
11:36:24 <johnw> and fmap id [1, 2, 3] != id []
11:39:20 <noteventime> Javran: the second law rules out that the behaviour depends (non-trivially) on what the function does (parametricity), and the first law then means that it can't change the structure of the list independently of the function 
11:39:43 <noteventime> Sorry about being vague and hand-wavy :P
11:40:07 <Javran> I see
11:40:23 <noteventime> Otherwise you have weird things like johnw's example
11:40:36 <noteventime> or more generally anything like foo . map where foo is some [a] -> [a]
11:40:47 * hackagebot non-empty 0.2.1 - List-like structures with static restrictions on the number of elements  http://hackage.haskell.org/package/non-empty-0.2.1 (HenningThielemann)
11:40:50 <noteventime> like, a function that maps and then reverses 
11:41:08 <Javran> or I should find another way to make something :: f b
11:41:24 <Javran> then it turns out I have to use fmap
11:46:39 <Javran> so why functors are useful -- because it allows you to reuse functions for containers/contexts/computations/whatever?
11:49:06 <johnw> Functors are so amazingly useful that it's kind of hard to explain
11:49:30 <johnw> it's like, binary is useful even though it's just a 0 and a 1
11:50:22 <johnw> in category theory, a category is a fairly basic notion; but once you add functors, you get a 1,000 page long book, becaues of all the structures that arise from their application ;)
11:50:40 <Javran> hmm
11:52:10 <johnw> not all of that is readily apparent as being applicable to Haskell, of course
11:52:47 <Javran> wanted to write something about functors, turns out it's far more than I've ever thought
11:53:05 <johnw> i'm pretty much focusing my studies on functors right now, because I have failed to fully appreciate them
11:53:42 <noteventime> Javran: If functions are what describe the structure of the things they go between (e.g. Haskell types) then functors turn out to be the "right" definition of how different kinds of structure relate to each other 
11:54:10 <noteventime> This isn't the whole story of course, and very vague :P 
11:54:25 <Javran> different kinds of structure relate to each other?
11:54:29 <johnw> and that statement of it would include natural transformations, for example in going from a Maybe structure to a List structure
11:54:49 <Javran> yeah that sounds like natural transformations to me
11:54:54 <noteventime> johnw: And transformations between natural transformations, and ... ;)
11:55:40 <Javran> btw what exactly enforces that fmap (fmap f) === (fmap . fmap) f ?
11:56:01 <noteventime> isn't that just the definition of .?
11:56:16 <Javran> seems like I'm talking about 2 different fmaps here
11:57:08 <noteventime> (fmap . fmap) f = (\x -> fmap (fmap x)) f = fmap (fmap f)
11:57:09 <noteventime> ?
11:57:38 <Javran> oh right, never mind
11:58:32 * Javran is looking at the instance of Functor (Compose f g)
11:59:00 <johnw> the composition of two functors is a functor
12:00:26 <Javran> I was wondering what's the difference between fmap (fmap f) x and (fmap . fmap) f x --- and then realize they are the same
12:01:20 <LAC1213> Do you guys think haskell is a good language to do symbolic algebra ?
12:01:22 <Javran> think newtype wrappers as ids and things become more clean
12:01:58 <hodapp> LAC1213: what other languages are you looking at?
12:02:03 <hodapp> I've mainly only done it in Maxima
12:02:15 <Javran> that instance of Compose collapses 2 layers of fmaps into one 
12:02:16 <LAC1213> well c++
12:02:20 <noteventime> Javran: About my earlier comment, what I was trying to say was the somewhat trivial statement that the functor instance is what specifies the sense in which "Maybe A" inherits structure from A
12:02:31 <hodapp> yeah, I'd give C++ a miss for most things
12:02:32 <LAC1213> isn't maxima an cas already ?
12:02:45 <hodapp> yes, which is why I use it for symbolic algebra
12:02:54 <LAC1213> I'm interestet in trying to implement something like maxima
12:03:13 <LAC1213> of course in a very simple fashion
12:03:21 <Javran> noteventime: if "inherits" is like "preserves" :)
12:04:00 <noteventime> Javran: I'd say the functor preserves structure, such that the image of the functor inherits structure form the domain :)
12:04:16 <hodapp> LAC1213: Have you a particular reason you want to implement this?
12:04:30 <LAC1213> because  I find it a very interesting problem
12:04:36 <hodapp> LAC1213: do you know Haskell already?
12:04:44 <LAC1213> not very well
12:05:15 <Javran> hmm
12:05:16 <LAC1213> that's kinda why I'm asking, the language is fascinating but I'm not sure if I really want to learn it
12:05:39 <dmj`> LAC1213: what's holding you back
12:05:54 <hodapp> LAC1213: It seems a little silly to judge it on the basis of an already-solved problem.
12:06:12 <Javran> well, something to say about contravariant functors?
12:06:24 <LAC1213> haskell isn't very popular so there aren't many programs from which I could learn
12:06:36 <hodapp> LAC1213: Are those two statements connected...?
12:06:43 <jle`> there are a lot of programs from which you could learn :)
12:07:33 <LAC1213> ok say I want to program my own cas in haskell
12:07:52 <LAC1213> do you think this is possible for  a beginner
12:08:02 <Javran> all instances from contravariant packages are just functions in disguise, it is a coincidence?
12:08:06 <LAC1213> I know other languages pretty well
12:08:18 <hodapp> LAC1213: what other languages?
12:08:20 <dmj`> LAC1213: you are confusing industry adoption with a quality tool. Industry has adopted many terrible things. 
12:08:32 <LAC1213> c, c++, java, python
12:08:48 <Javran> I hardly have any example of a non-function contravariant stuff in mind though.
12:09:09 <dmj`> LAC1213: It's a non-sequiter to say that something isn't worth learning because it isn't popular
12:09:18 <kadoban> LAC1213: You'll have to spend some time learning haskell first
12:09:24 <noteventime> Javran: The dual category is one of a few things that "make sense" for any category, so I don't think it's strange that certain constructs work on the dual of whatever category you're working with
12:09:26 <hodapp> LAC1213: those are pretty much the same language.
12:09:32 <dmj`> s/sequiter/sequitur
12:09:34 <LAC1213> I know ;)
12:09:37 <hodapp> LAC1213: Haskell is going to be very different.
12:09:55 <LAC1213> I already started with http://learnyouahaskell.com/
12:10:13 <LAC1213> I understood the basic concepts (at least I think so)
12:10:40 <LAC1213> but i'm very slow in programming it
12:10:42 <kadoban> LAC1213: https://github.com/bitemyapp/learnhaskell has IMO better recomendation(s), specifically the cis194 class. LYAH doesn't have exercises or anything.
12:10:42 <andbroby> python's touch of FP should have introduced you to the basic concepts already
12:10:44 <Javran> noteventime: sorry I don't get it, more details?
12:11:17 <andbroby> LYAH is more like reading a reference than a tutorial or guide.
12:12:12 <noteventime> Javran: I just meant that since any category has a dual category (this construction always works, and you lose no information), there seems no reason to believe that that direction you happen to choose initially is the "right" one for everything you want to look at 
12:13:09 <kadoban> LAC1213: The cis194 class uses LYAH as suggested reading material, if that helps. So it won't be like you're starting over completely.
12:13:40 <andbroby>  there are some exercises here to supplement with https://wiki.haskell.org/99_questions
12:13:43 <LAC1213> kadoban: ok ty I'll look at it
12:13:49 <Javran> noteventime: that sounds good to me -- but how does that relate to the question I have?
12:15:19 <Javran> I meant they are contravariant functors -- but is there any non-function contravariant functor?
12:15:49 * hackagebot dgim 0.0.3 - Implementation of DGIM algorithm  http://hackage.haskell.org/package/dgim-0.0.3 (musically_ut)
12:16:52 <johnw> Javran: Const
12:17:07 <johnw> see http://hackage.haskell.org/package/contravariant-1.3.1/docs/Data-Functor-Contravariant.html for a list
12:18:22 <Javran> johnw: I'm looking at the page exactly as you gave :)
12:19:17 <Javran> "   even though the dual of a Functor is just a Functor. As with Functor  the definition of Contravariant for a given ADT is unambiguous. " BTW how to interpret this sentence?
12:19:34 <Javran> some CT background required?
12:20:06 <johnw> means you could auto-derive the functor instance
12:20:18 <jmcarthur> Javran: all non-trivial contravariant functors will involve a function somewhere, but it can be more complicated than just  a -> B
12:20:22 <johnw> there's only one possible law-abiding Contravariant, if one can be written
12:21:15 <jmcarthur> Javran: for example, this is also a contravariant functor:    newtype Thing a = Thing (((a -> Int) -> Int) -> Int)
12:22:44 <jmcarthur> Javran: of products, sums, and functions, functions are the only way to flip the variance of a type variable.
12:23:16 <Javran> jmcarthur: thanks, that starts to make sense!
12:23:39 <johnw> Javran: if you think of 'a' as a function '() -> a', then all covariant functors involve functions too :)
12:23:55 <noteventime> Javran: I don't know about Haskell
12:24:36 <noteventime> But in mathematics they turn up for example (almost by definition) in various duality relationships, for example when looking at topological spaces in terms of their open set lattices 
12:24:37 <Javran> I find there's a simple way to find the variance, just mark a -> b as "-a -> +b" and push negative signs into parentheses
12:25:21 <Javran> then that Thing becomes " Thing (((-a -> +Int) -> +Int) -> +Int) "
12:25:59 <Javran> so it's not a coincidence ... it somehow has to be
12:26:16 <Luke> anyone know of a base 56 byte string encoder?
12:26:21 <Luke> can't find one in google
12:26:38 <jmcarthur> Javran: exactly, though i'm not sure it even makes sense to put variance annotations on Int, which is not a type variable. also i think the second Int would be in a negative position, if that made sense.
12:26:39 <Javran> as (->) seems to be the only way of introducing "negations"
12:27:27 <Javran> jmcarthur: yeah there might be some mistake, I was only focusing on figuring out "a"
12:28:05 <jmcarthur> Javran: you will find that contravariant functors work on type variables in negative (contravariant!) position and covariant functor work on type variables in positive (covariant!) position
12:28:31 <noteventime> Javran: Another one (in mathematics) that involves functions though in a somewhat non-trivial way is the duality between spaces (topological, manifolds, ...) and their algebraic structure (ring, vector space, ...) of functionals 
12:30:32 <Javran> noteventime: that might be beyond my reach, topological stuff sounds too abstract to me :(
12:31:56 <Javran> jmcarthur: and contravariant + covariant together you can do nothing on that value.. id :: a -> a for example xD
12:32:12 <Javran> and there's even a proof involving Void, IIRC
12:32:38 <jmcarthur> yup
12:33:15 <Javran> I want to make sense of that proof, but haven't found it yet.. someone happen to know that link?
12:37:09 <Javran> http://hackage.haskell.org/package/void-0.7/docs/Data-Void.html#v:absurd well I guess this is the first thing I need to understand, how can this function be used?
12:41:31 <Gurkenglas> Was isElem recently renamed to elem?
12:42:39 <heatsink> It's been elem for long
12:42:48 <heatsink> I don't remember isElem
12:45:08 <Javran> should be something like "member" for containers like Set IIRC
12:45:17 <Gurkenglas> dafuq is going on with my brain. I used isElem, then got confused when the compiler didnt have it in scope even though i had Data.List imported, asked lambdabot for its type as a test, not in scope, asked hoogle for it, not in scope
12:45:54 <Gurkenglas> I remember using it like a dozen times
12:46:12 <Javran> if elem doesn't work, try member :)
12:46:14 <Gurkenglas> And all those examples with 'isElem' in '' because people don't like putting it in front
12:46:31 <Gurkenglas> it works, I just wonder why my brain put an "is" in front of all the memories
12:46:40 <Gurkenglas> Damn matrix glitches
12:47:43 <noteventime> Gurkenglas: Apparently there's an isElem in hxt
12:48:15 <Gurkenglas> Never heard of that before your post I think
12:48:33 <Gurkenglas> And I remember using it as a -> [a] -> Bool
12:48:42 <Javran> btw I like the way scheme name isFoo like "foo?" to indicate it returns a boolean
12:49:00 <Javran> but that's not a valid identifier in Haskell
12:50:17 <Javran> https://hackage.haskell.org/package/classy-prelude-0.11.1/docs/ClassyPrelude.html#v:elem oh there's a general version
13:00:50 * hackagebot messente 0.1.0.0 - Messente SMS Gateway  http://hackage.haskell.org/package/messente-0.1.0.0 (kaiko)
13:10:51 * hackagebot numeric-prelude 0.4.2 - An experimental alternative hierarchy of numeric type classes  http://hackage.haskell.org/package/numeric-prelude-0.4.2 (HenningThielemann)
13:15:33 <wayne> what's the best way to persist ADTs with no recursion?
13:16:27 <wayne> i guess it would involve using TemplateHaskell
13:17:09 <suppi> Hi, I'm looking for a recommended resource to learn about compilers from. I have written a toy interpreter once but have no formal education on the subject. any advice?
13:17:24 <wayne> suppi: the dragon book should be great
13:17:39 <wayne> http://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811
13:17:59 <wayne> don't be afraid of getting the first edition instead (it's waaay cheaper). not much has changed in the past 3 decades
13:18:40 <suppi> wayne, thanks. do you think I'll be able to use the knowledge from it with Haskell in a straightforward manner?
13:19:07 <suppi> and will it cover techniques about functional languages too?
13:19:23 <wayne> suppi: depends on what part of compilation you're interested in. there are many steps, and some are pretty language-agnostic
13:19:57 <wayne> for example, knowing the theory of parsing will help you understand parsec much more easily
13:20:32 <suppi> ok :)
13:21:11 <wayne> and haskell itself has a bnf-style language definition: https://www.haskell.org/onlinereport/syntax-iso.html
13:21:36 <wayne> so going through such a classic text would absolutely help you learn about the implementation of functional languages too
13:22:49 <suppi> I'm a bit more interested in other aspects of a compiler than parsing at the moment, because I was able to write a parser
13:23:47 <suppi> thank you for the advice wayne, I will look into the dragon book :)
13:24:09 <wayne> code generation is probably what you want to read up on. np
13:24:46 <suppi> thanks
13:29:27 <uucico> how do scc annotations interact with partial function application?  since the partially applied function thunk can't get forced until fully applied, does this mean an scc annotation on partial applications will report ~zero?
13:38:13 <boothead> I'm looking at some code that has Aeson.ToJSON and FromJSON in the deriving bit... How does that work because I'm getting  ToJSON is not a derivable class
13:42:30 <byorgey> boothead: perhaps with GeneralizedNewtypeDeriving
13:42:52 <balboa> halo
13:42:59 <balboa> !list please
13:42:59 <monochrom> balboa: http://hackage.haskell.org/packages/
13:43:31 <mister-metaphor> is there a guide anywhere on how to install gcc-mod with GHC 7.10 and Cabal 1.22 ?
13:43:44 <mister-metaphor> *ghc-mod
13:44:04 <boothead> byorgey, yeah that's what I thought - but I have that and it isn't working on 7.101. Ho hum, I added instance {To,From}JSON MyThing. Just curious why it wasn't working...
13:44:20 <byorgey> boothead: well, is MyThing a newtype?
13:45:52 * hackagebot resource-embed 0.1.0.0 - Embed data files via C and FFI.  http://hackage.haskell.org/package/resource-embed-0.1.0.0 (TobiasDammers)
13:45:57 <pavonia> What is that Italians always joining only for sending !list to the channel? O.o
13:46:46 <alex_____> can be they really respect lists
13:47:13 <boothead> byorgey, I haz teh stoopid. I know I should have drunk my tea before it went cold! Thank you :-)
13:47:22 <byorgey> =)
13:48:42 <athan> Is there a lifted version of >>=? Something like `lift x >>= (lift . f)`?
13:52:09 <athan> ...I wonder if there could be some kind of extension to hoogle to give equational reasoning queries like this
13:53:10 <mpickering> mister-metaphor: there's no official support yet
13:54:16 <mister-metaphor> mpickering, so how do people with GHC 7.10 get by? :D
13:55:10 <mister-metaphor> is GHC 7.10 even recommended yet for day-to-day use?
13:55:27 <athan> wow I'm an idiot, sorry guys
13:58:00 <andbroby> mister-metaphor: why wouldnt it be? i doubt they'd release it if it wasnt ready for day to day use.
13:58:45 <noteventime> athan: ?
13:59:38 <athan> noteventime: `lift x =<< (lift . f)` ~ `lift $ x =<< f` :\
13:59:46 <athan> I asked if there was a "lifted version" of =<<
14:00:21 <noteventime> Right, that's basically a law for lift, right?
14:00:27 <athan> yeah :\
14:00:49 <noteventime> I didn't realise it when you asked either :) 
14:01:13 <mpickering> mister-metaphor: there's a branch which works if you want that
14:03:00 <reallynotbob> when using snap (a haskell web framework) how would I do a IO action every hour?
14:03:26 <mister-metaphor> mpickering, do you have a repo address?
14:03:38 <elfeck> why can I do
14:03:38 <elfeck> testBody :: Html
14:03:38 <elfeck> testBody = div "" ! class_ "testbody"
14:03:38 <elfeck> while div :: Html -> Html
14:03:38 <elfeck> ?
14:04:17 <tdammers> reallynotbob: depends what backend you use... the most fool-proof way that I can think of is adding a route that triggers the action, expose it only on localhost, and use curl (or wget) in a cron job to kick it off
14:04:57 <mpickering> mister-metaphor: https://github.com/alanz/ghc-mod/tree/ghc-7.10
14:05:02 <mpickering> that branch builds fine
14:05:17 <mister-metaphor> thanks
14:05:17 <tdammers> reallynotbob: but if your backend has a long-running process execution model (like Warp), then you could also do the scheduling in a separate thread that you create at startup
14:05:29 <tdammers> you'd need a bit of synchronisation, but not really anything wild
14:06:03 <tdammers> for something like CGI/FastCGI/SCGI though, this won't work, because your process is subject to termination at all times
14:07:03 <MP2E> random question (pun intended!), what difference is there between using getStdRandom and getting an StdGen through newStdGen and splitting it?
14:07:14 <hpc> :t getStdRandom
14:07:15 <lambdabot> (StdGen -> (a, StdGen)) -> IO a
14:07:46 <MP2E> I mean in terms of random numbers produced. I have a markov IRC bot that I want to reply 4% of the time but if it replies once, there is a high tendency of it replying multiple times in a row
14:08:01 <hpc> there's a global StdGen that it looks like getStdRandom uses
14:08:36 <hpc> for a markov chain relatively little about the rng matters
14:08:43 <hpc> just make sure you're using the same one every time
14:09:19 <MP2E> the sentences themselves are fine, it's more the fact that it doesn't actually seem like it is replying 4% of the time
14:09:24 <MP2E> since it will reply multiple times in a row
14:09:27 <mister-metaphor> mpickering, well, I'm still getting Not in scope: data constructor ExposePackageId with that repo :(
14:09:56 <reallynotbob> tdammers: ok thanks. I didn't think about creating new threads.
14:10:55 <MP2E> https://github.com/MP2E/divebot/blob/master/src/Main.hs#L111
14:10:59 <MP2E> relevant lines are 111 and 112
14:15:36 <caconym> howdy, does anyone here have any real-world experience building production web APIs using haskell?
14:15:56 * hackagebot cblrepo 0.15.0 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.15.0 (MagnusTherning)
14:15:58 * hackagebot synthesizer-core 0.7.1 - Audio signal processing coded in Haskell: Low level part  http://hackage.haskell.org/package/synthesizer-core-0.7.1 (HenningThielemann)
14:16:06 <caconym> i'm looking for an honest assessment of how suitable haskell's ecosystem currently is for this purpose, as I'd like to use it in this way
14:16:43 <geekosaur> fpcomplete does that kind of thing, with yesod
14:17:03 <caconym> hmm, yes, maybe they have some interesting articles
14:17:22 <geekosaur> (I am not really the person to ask about it, I'm core infrastructure sysadmin and generally avoid web stuff...)
14:17:38 <caconym> heh, yeah, i'm in the same boat
14:17:41 <whisky> Hi, I'm new to haskell. I've made a minor addition to Numeric to allow for a more generic showIntAtBase. What process do I need to follow to make this contribution? Is there a link maybe that I missed?
14:18:15 <caconym> geekosaur: i've so far been steering clear of yesod because it reminds me a lot of rails and has a bunch of TH stuff going on
14:18:17 <geekosaur> email to libraries@haskell.org. I think there's something on the haskell wiki but no idea if you can readily find it currently...
14:18:37 <caconym> geekosaur: but i hear it mentioned a lot in the context of actual deployed projects out there, so maybe i should give it a chance, it seems pretty mature
14:18:44 <geekosaur> well, yesod's not the only one that's in wide use but fpcomplete certainly is doing commercial stuff with it
14:18:44 <whisky> Thanks geekosaur!
14:19:08 <geekosaur> snap is another framework in common use
14:19:15 <heatsink> I found this https://wiki.haskell.org/Library_submissions
14:19:22 <caconym> geekosaur: yup, snap looks pretty cool from what i've seen
14:19:38 <caconym> geekosaur: what about this "spock" business?
14:19:48 <geekosaur> I have heard of it but that's it
14:19:56 <geekosaur> like I said, not really a webby type
14:20:03 <mopvcc> Hi does anybody know of an example using the 'indenatation' package?
14:20:05 <michaelt_> caconym: http://www.yesodweb.com/book
14:20:15 <caconym> geekosaur: yeah, no worries, thanks for replying :)
14:20:57 * hackagebot Unixutils 1.53 - A crude interface between Haskell and Unix-like operating systems  http://hackage.haskell.org/package/Unixutils-1.53 (DavidFox)
14:20:59 * hackagebot confsolve 0.5.4 - A command line tool for resolving conflicts of file synchronizers.  http://hackage.haskell.org/package/confsolve-0.5.4 (DanielTrstenjak)
14:21:12 <elfeck> what about Scotty Webframework? What do you guys think about that?
14:21:40 <caconym> michaelt_: i'm more curious to hear from someone who's actually used one or more of these frameworks in production about the pitfalls they encountered
14:22:36 <caconym> michaelt_: thanks for the link though, i will peruse, it seems like a well-written resource and I don't know yesod
14:22:52 <suppi> I wrote a simple static blog with Scotty. was pretty easy for a beginner
14:23:00 <caconym> elfeck: scotty is what i've been favoring so far
14:23:25 <suppi> there is also Happstack which seems kinda nice
14:23:48 <caconym> elfeck: it reminds me of sinatra, which i like, but i'm concerned about using a library like it only to find that it isn't mature enough for legit real-world use
14:23:51 <suppi> I have no idea about production though :O
14:27:14 <elfeck> okay interesting
14:27:19 <athan> Hey everyone, I've got a functor of monad writers, and I'm trying to turn it into a functor of it's it's inner monoid. How should I do this if the writer is in transformer-form?
14:27:38 <athan> In that I need to extract the transformer's inner monad to `m (functor monoid)`?
14:27:42 <elfeck> what do you mean by not "mature enough"? Not enough support / ongoing development?
14:28:58 <caconym> elfeck: i'm worried mostly about security issues, which come up a lot no matter what framework you're using
14:29:36 <caconym> elfeck: things like rails have a lot of built-in functionality to help you out there
14:30:08 <geekosaur> happstack is easily the most mature of the haskell web frameworks
14:30:10 <athan> caconym: The thing about pure languages like Haskell is you can consolidate vulnerable contexts like IO
14:31:15 <michaelt_> athan: wait what is the type you are starting with? 
14:31:59 <caconym> athan: sure, in theory, but if you're writing a web app you're likely to be spending a lot of time in IO
14:32:08 <athan> michaelt_: Something like `f (writer w m ())`, where w is my monoid
14:32:20 <caconym> athan: still, i love haskell because it makes reasoning about that kind of thing easier; that's why i want to use it for everything, this project included
14:32:36 <athan> caconym: That's what I'm going for :)
14:32:50 <athan> caconym: There's no replacement for discipline
14:33:06 <michaelt_> athan: you want f (WriterT w m ()) -> f w ?  
14:33:20 <elfeck> how can one do authentication with Scotty?
14:33:24 <elfeck> cant find anything?
14:33:36 <caconym> athan: indeed, which is why I don't think "just use rails because it does everything for you" is a particularly good argument
14:33:43 <hjulle> What is the problem with the definition "duplicate b = const b <$> b" for a comonad?
14:33:47 <athan> michaelt_: Something like `f (WriterT w m ()) -> m (f w)`, I think
14:33:54 <nitrix> Is there a simpler form for `return . pure` ?
14:34:02 <athan> because (naievely), I'm sharing `m` in another wrapper monad :)
14:34:07 <hpc> :t \b = const b <$> b
14:34:08 <lambdabot> parse error on input ‘=’
14:34:14 <hpc> :t \b -> const b <$> b
14:34:15 <lambdabot> Functor f => f b -> f (f b)
14:34:34 <athan> caconym: Rails is also pretty unstable in terms of dependency management & linking (imo)
14:34:41 * athan douces the forest fire before it starts
14:35:01 <athan> michaelt_: I might just have to redesign this :\ sorry
14:35:16 <nitrix> I want an IO that returns its argument unmodified and does nothing. Is there cleaner than  return . pure ?
14:35:26 <caconym> athan: Data.Functor.Compose?
14:36:07 <michaelt_> athan: fmap execWriter or whatever will give you f (m w) but there will be trouble getting to f (m w) without the right f and m
14:36:09 <athan> caconym: That's sweet :) I think I just need to rethink what I'm doing
14:36:15 <caconym> athan: (is something i learned about the other day which superficially sounds related to your problem) :D
14:36:19 <hjulle> It typechecks as 'duplicate', but it doesn't require anything more than Functor, so I assume it fails at some law.
14:36:25 <michaelt_> athan: I meant, there will be trouble getting to m (f w)
14:36:28 <athan> michaelt_: Yeah :\ thank you for the help
14:36:46 <athan> caconym: Yeah, monad transformers are like higher-order monads
14:36:56 <athan> ...and I'm nesting them at the value level
14:36:58 <athan> ...with functors
14:37:03 <athan> not smart :|
14:37:15 <vandenoever> is there a readers-writer-lock for haskell? http://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock
14:37:29 <michaelt_> if f is Traversable 
14:38:13 <michaelt_> @type sequenceA
14:38:13 <caconym> elfeck: there seems to be a whole ecosystem of modular web components for Haskell that's growing at a pretty quick rate
14:38:14 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
14:38:20 <vandenoever> oops, nm, found it Control.Concurrent.ReadWriteLock
14:38:35 <caconym> elfeck: i expect there's middleware or whatever that helps you do authentication and sessions
14:38:36 <athan> michaelt_: Now that's what I call programming vol. 12!
14:38:39 <athan> Thank you!!
14:40:03 <elfeck> okay caconym, Ill look into it thanks
14:40:45 <okic> hi everyone, im noobing it up hardcore.. any tips on how to make thise 'arg parser' (ParseOptions/ParseState) polymorphic? https://github.com/adarqui/argparser-hs/blob/master/src/Data/ArgParser.hs .. i've tried playing with existential types etc, no luck. Usually I just 'paramaterize' the record, ie, data ParseOptions a = ParseOptions { blah :: a } etc, but i'm not doing that here so, having trouble with this.
14:42:45 <jxv> okic, why not use optparse-applicative?
14:43:40 <okic> ya I could.. but, i'm writing this 'separate' because I also need to write it in a few other langs.. so I started with haskell first
14:44:16 <jxv> okic, in that case there's docopt?
14:44:42 <okic> optparse-applicative would be able to break up a "String" though? I know it takes args as: [String], but, this arg parser is supposed to break up just one string into arguments, so that I can then pass it to optparse-applicative for example
14:46:08 <okic> nice, never heard of docopt.. really cool
14:46:12 <caconym_> elfeck: http://hackage.haskell.org/package/users ?
14:46:36 <noteventime> I haven't been able to figure out exactly what it is it stackage does? Is it a whole separate repository, an (automatically) maintained set of version constraints?
14:47:01 <athan> michaelt_: So, I've got a writer monad of lists of writer monads. What do you think I should do? First execWriterT before I place that written object in the list (to write on)?
14:47:48 <athan> er... a writer monad _writing_ lists of writer monads
14:47:57 <geekosaur> noteventime, it started out as a version base for yesod
14:48:59 <okic> jxv: ya so my argparser lib could be used to parse some string into an array/list for docopt for example
14:49:50 <nitrix> inodeDelete :: Ledger -> InodeId -> IO Ledger
14:50:05 <nitrix> How would I make this function return the Ledger unmodified, and perform no action?
14:50:13 <nitrix> So far, I have inodeDelete = return . pure
14:51:02 <nitrix> What is more idiomatic, return . return? pure . pure? I'm still confused as to why I need two of them, but I'm following the type system so yeah.
14:51:22 <geekosaur> I don't think you do? you may be confused by needing to get rid of the InodeId
14:51:31 <noteventime> geekosaur: I'm not sure I know what that means, a set of exact package versions known to work?
14:51:36 <nitrix> geekosaur: I think so too.
14:51:45 <nitrix> geekosaur: Do you have anything to suggest me :( ?
14:51:49 <nitrix> It looks clumsy.
14:51:51 <geekosaur> noteventime, yesod is tested against them, in theory other things are as well
14:51:55 <Luke> anyone know who to set a default on an option: https://hackage.haskell.org/package/optparse-applicative-0.11.0.2/docs/Options-Applicative-Builder.html
14:51:59 <Luke> i can't seem to see it
14:52:20 <geekosaur> @unpl \l x -> return l
14:52:21 <lambdabot> \ l x -> return l
14:52:24 <elfeck> thanks for the link
14:52:25 <Luke> oh I found it: "value"
14:52:26 <geekosaur> whoops
14:52:29 <geekosaur> @pl \l x -> return l
14:52:29 <lambdabot> const . return
14:53:00 <nitrix> Brilliant.
14:53:05 <nitrix> inodeDelete = const . return
14:53:12 <nitrix> inodeDelete x _ = return x
14:53:19 <nitrix> I think I prefer the point free.
14:54:28 <jxv> okic, I'm not exactly sure if you mean: you want to convert a String or [String] to some type which hasn't been decided? 
14:54:48 <jxv> under ParserOptions/ParserState?
14:55:12 <allyraza> hello everyone
14:55:21 <mantovani2> hello
14:55:58 * hackagebot haskell-spacegoo 0.2.0.1 - Client API for Rocket Scissor Spacegoo  http://hackage.haskell.org/package/haskell-spacegoo-0.2.0.1 (JoachimBreitner)
14:56:19 <allyraza> I have been learning haskell for some time now I have grasped the syntax and the rules I would like to build something more practical is anyone in here working on a open source project needs an extra hand
14:57:57 <noteventime> geekosaur: Ok, makes sense, thanks
14:59:08 <okic> nah jxv. I just would like that lib to be polymorphic, instead of [Char] i'd like [a] etc.. so I mean I need to satisfy Eq a, Ord a etc. Right now i'm just parsing Char/[Char], but i'd like the lib itself to be a/[a] so that I can use it with other types.
15:00:58 * hackagebot stack-prism 0.1.1 - Stack prisms  http://hackage.haskell.org/package/stack-prism-0.1.1 (MartijnVanSteenbergen)
15:04:56 <okic> if i paramaterized all of those funcs with the spaces, quotes, and quoteChar, i could make it polymorphic.. the problem i'm having is with the record. I'd like to still use records which contain quoteChar, spaces, quotes etc
15:05:29 <okic> my trouble seems to be with how i'm constructing the record.. i think ;/
15:06:16 <okic> ie, if i could do something like this: data ParseState = ParseState { quoteChar :: a } .. but i can't obviously so, not sure what to do right now
15:06:43 <noteventime> okic: I haven't followed you initial question, but can't you just add a type parameter to ParseState?
15:07:35 <noteventime>  data ParseState a = ParseState { quoteChar :: a ... }
15:07:47 <okic> ya.. in my initial question i stated i could do that. Is that the best way to go about it?
15:07:50 <okic> ya
15:08:29 <okic> i veered off into this ExistentialTypes language extension etc, so, I guess i'm wondering if there's a "more ideal" way to do it?
15:13:50 <noteventime> okic: I don't see how
15:14:30 <okic> ok cool. i'll stop trying to overcomplicate it 8| thanks noteventime, jxv!
15:14:40 <noteventime> Since you presumably want the type checker to make sure the kind of data contained in your parse state coincides with the type of data in your stream
15:15:35 <monochrom> how to polymorphize depends on why you polymorphize, i.e., for what purpose
15:16:16 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #5
15:19:50 <Gurkenglas> I don't know, and don't you dare tell me, how to construct foldl from foldr. Can you recommend something that teaches the techniques needed to deduce the way?
15:20:45 <monochrom> I dare to tell you an url that has the solution
15:20:55 <Gurkenglas> I already have one
15:21:13 <Gurkenglas> It starts with lmgtfy x)
15:21:48 <monochrom> read most of Richard Bird's papers and books on how to calculate a program
15:25:16 <Guest98766> hello
15:26:02 <aruro> guys
15:26:21 <aruro> any interesting data types apart from this one ? http://twanvl.nl/blog/haskell/non-regular1
15:26:43 <aruro> does not have to be non regular though
15:28:46 <monochrom> look for "polymorphic recursion"
15:28:57 <orion> .wc
15:29:15 <monochrom> the poster boy example is "data P a = L | P (a, a)"
15:29:27 <aruro> poster boy?
15:29:56 <monochrom> "poster boy" is a metaphor for "example of examples"
15:29:57 <aruro> your example seems no regular too?
15:30:04 <aruro> right?
15:30:09 <aruro> non*
15:35:41 <aruro> so the things which allow polymorphic recursion are basically operators on types
15:35:56 <aruro> like [a], (a,a), (a->a)
15:36:17 <aruro> or actually any other polymorphic type
15:37:18 <alynn> https://hackage.haskell.org/package/recursion-schemes may be of interest to you
15:37:54 <aruro> ty
15:39:13 <aruro> anyone goes for zurihack? :)
15:40:43 <Gurkenglas> Are those papers and books freely available somewhere?
15:42:47 <Forgetaboutit> What's the Haskell way of testing functions internal to a module?  Just exporting them?
15:43:03 <monochrom> the books are not. the papers are. find Richard Bird's home page
15:46:27 <erikd> Forgetaboutit: i sometimes export them conditionally using CPP and wrapping the exports in #if TESTING / #endif
15:46:49 <noteventime> Forgetaboutit: you can define an internal module, which you import only for testing 
15:47:02 <hakujin> Forgetaboutit: you can import all functions from a module by prepending * to the module name
15:47:23 <hakujin> e.g. `cabal repl; :m + *ModuleName`
15:48:46 <Forgetaboutit> erikd: I like that even if it feels a bit too C-ish
15:49:12 <Forgetaboutit> noteventime: I'm not sure if that's really worth for really small modules
15:49:42 <Forgetaboutit> hakujin: But can I do that for quickchecking/HUnit as well?
15:49:56 <hakujin> Forgetaboutit: afaik ghci only
15:50:14 <erikd> an internal module also works fine
15:50:38 <noteventime> Forgetaboutit: You could shove everything into an "internal" module and have the "front-end" module just reexport those you want to export 
15:51:11 <noteventime> That's barely any extra code, since you have to declare the exports anyway 
15:51:16 <noteventime> Not they're just in a separate file
15:51:32 <Forgetaboutit> noteventime: I'll probably go with that, thanks!
16:01:05 * hackagebot stack-prism 0.1.2 - Stack prisms  http://hackage.haskell.org/package/stack-prism-0.1.2 (MartijnVanSteenbergen)
16:01:19 <caconym> Gurkenglas: heh, that's actually a fun exercise, i remember it being mentioned in RWH but i never tried it
16:01:40 <Gurkenglas> RWH?
16:01:49 <caconym> Gurkenglas: Real World Haskell
16:02:23 <caconym> Gurkenglas: i'd say maybe go learn about how the State monad works, and try to implement it yourself
16:04:10 <caconym> Gurkenglas: which is not trivial if you're a beginner and you don't cheat by peeking; it used to tie my brain into knots
16:08:49 <Gurkenglas> Looking at https://hackage.haskell.org/package/mtl-1.1.0.2/docs/Control-Monad-State-Lazy.html it seems simple
16:11:10 <caconym_> Gurkenglas: yeah, it's not a huge and complicated thing
16:12:17 * apo puts a cucumber in Gurkenglas
16:14:15 <caconym_> Gurkenglas: but if you can grok how that monad instance works, you may be on the right track to foldl via foldr
16:16:05 * hackagebot happstack-server 7.4.3 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.4.3 (JeremyShaw)
16:18:06 <Gurkenglas> Is this correct? http://lpaste.net/130164
16:19:41 <caconym_> it looks pretty close; does it work? :)
16:19:45 <Gurkenglas> (Looked only at the Constructors part)
16:20:01 <Gurkenglas> I don't know whether it works because I'm not sure how State is supposed to work :P
16:20:55 <caconym_> oh :)
16:21:26 <pavonia> Gurkenglas: return doesn't return the correct type yet
16:21:42 <Gurkenglas> right
16:22:18 <Gurkenglas> http://lpaste.net/130164
16:22:31 <caconym_> Gurkenglas: well I'd see if it typechecks first, that's usually a good indication that you're on the right track
16:22:43 <Gurkenglas> I thought lpaste checks that.
16:22:43 <caconym_> Gurkenglas: i gotta run but good luck!
16:22:54 <caconym_> Gurkenglas: oh, maybe it does, i have not used it
16:23:13 <Gurkenglas> Apparently not or it would have caught my mistake
16:27:54 <Gurkenglas> http://lpaste.net/130167 <- This typechecks. How do I use where in anonymous functions?
16:29:45 <caconym_> Gurkenglas: afaik, you don't
16:30:01 <caconym_> Gurkenglas: but you can use let..in if it doesn't make things too unreadable
16:30:38 <dmj`> Gurkenglas: you can use where in instance defintions IIRC, try newlining, added two spaces then 'where <function> ='
16:31:06 * hackagebot messente 0.1.0.1 - Messente SMS Gateway  http://hackage.haskell.org/package/messente-0.1.0.1 (kaiko)
16:31:52 <Gurkenglas> dmj`, but I then can't use the a from the \a above in there
16:36:06 * hackagebot geoip2 0.1.0.0 - Pure haskell interface to MaxMind GeoIP database  http://hackage.haskell.org/package/geoip2-0.1.0.0 (ondrap)
16:36:24 <pavonia> Gurkenglas: You can't use where for that, AFAIK
16:36:52 <a_porcupine> heya. i need a function like digitToInt, but with type Word8 -> Word8
16:37:16 <a_porcupine> i know fromIntegral can change the resulting Int into a Word8, but i'm not sure how to go from Char to Word8
16:37:40 <Gurkenglas> From Word8 to Char, you mean
16:37:52 <a_porcupine> err, yes
16:38:11 <geekosaur> :t Data.Char.digitToInt . toEnum . fromIntegral
16:38:12 <lambdabot> Integral a => a -> Int
16:38:51 <a_porcupine> :t fromIntegral . Data.Char.digitToInt . toEnum . fromIntegral
16:38:53 <lambdabot> (Integral a, Num c) => a -> c
16:39:03 <a_porcupine> i guess that fits Word8 -> Word8 ?
16:39:20 <a_porcupine> i'll give it a try! thanks!
16:39:27 <pavonia> What does that even do?
16:39:47 <pavonia> > fromIntegral . Data.Char.digitToInt . toEnum . fromIntegral $ 5
16:39:48 <lambdabot>  *Exception: Char.digitToInt: not a digit '\ENQ'
16:39:54 <a_porcupine> should map 0x51 to 0x03
16:40:07 <a_porcupine> i.e. ascii code for '3' to the byte 3
16:40:15 <geekosaur> :t chr
16:40:16 <lambdabot> Int -> Char
16:40:23 <geekosaur> :t ord
16:40:24 <lambdabot> Char -> Int
16:40:52 <a_porcupine> those are just toEnum and fromEnum restricted to Char, right?
16:41:01 <pavonia> > fromIntegral . Data.Char.digitToInt . toEnum . fromIntegral (50 :: Word8) :: Word 8
16:41:03 <lambdabot>      ‘Word’ is applied to too many type arguments
16:41:03 <lambdabot>      In an expression type signature: Word 8
16:41:03 <lambdabot>      In the expression:
16:41:08 <pavonia> > fromIntegral . Data.Char.digitToInt . toEnum . fromIntegral (50 :: Word8) :: Word8
16:41:10 <lambdabot>      Couldn't match expected type ‘Word8’
16:41:10 <lambdabot>                  with actual type ‘a0 -> Integer’
16:41:10 <lambdabot>      In the expression:
16:41:25 <pavonia> Meh
16:41:45 <pavonia> > fromIntegral . Data.Char.digitToInt . toEnum . fromIntegral $ (50 :: Word8) :: Word8
16:41:47 <lambdabot>  2
16:42:10 <a_porcupine> right, that seems to work!
16:42:20 <a_porcupine> (i was wrong about the 0x earlier -- reading the wrong column on an ascii table)
16:43:12 <pavonia> > (subtract 48) 50 :: Word8
16:43:14 <lambdabot>  2
16:43:29 <a_porcupine> not quite
16:43:31 <a_porcupine> > fromIntegral . Data.Char.digitToInt . toEnum . fromIntegral $ (97 :: Word8) :: Word8
16:43:32 <lambdabot>  10
16:44:06 <a_porcupine> ("digit" secretly actually means "hex digit"! which is a sort of weird thing about digitToInt, i think.)
16:44:50 <pavonia> > (\x -> if x <= 57 then x-48 else x-87) 97 :: Word8
16:44:52 <lambdabot>  10
16:44:54 <pavonia> :p
16:45:21 <pavonia> At least more readable, IMHO
16:47:13 <nolrai66> Anyone here know liquid haskell?
16:47:22 <allyraza> quick one why haskell has constants as primitive values 
16:47:44 <allyraza> nolrai66: I have seen a very interesting talk about liquid haskell
16:48:11 <allyraza> here https://www.youtube.com/watch?v=vYh27zz9530
16:48:12 <nolrai66> I have a specification that fails to parse in a way that makes no sense to me.
16:48:29 <nolrai66> (Trying to work through the tutorial.)
16:49:04 <nolrai66> What does primitive mean here: "quick one why haskell has constants as primitive values"?
16:50:42 <nolrai66> "{-@ null      :: xs:[a] -> {v:Bool | notEmpty xs => v} @-}" produces a parse failue on the colon between xs and [a].
16:51:54 <kadoban> nolrai66: What syntax is that supposed to be exactly? :-/
16:52:29 <nolrai66> Liquid haskell.
16:52:49 <nolrai66> Its a refinement type system for Haskell.
16:54:16 <nolrai66> For comparison "{-@ null      :: xs:[a] -> {v:Nat | v > 3} @-}" does parse.
16:54:43 <nolrai66> (Though it then gives me an error about the refinement type not being a refinement of the normal type.
16:55:13 <nolrai66> (Because null's code has type [a] -> Bool)
16:55:22 <allyraza> nolrai66: I have been programming in imperative PLS mostly 
16:56:01 <allyraza> the littleral values in c are int, char, strings 
16:56:22 <allyraza> literal*
16:56:50 <allyraza> I see haskell has constants as literal values 
16:57:05 <nolrai66> Err sort of.
16:57:12 <allyraza> for example data Color = Red | Blue 
16:57:26 <nolrai66> >.<
16:57:26 <allyraza> here Red is a value but its not a string 
16:58:23 <nolrai66> "Constant" is a bad term for those in haskell. 'Nullay Constructor' is better.
16:58:30 <arkeet> nullary*
16:58:44 <nolrai66> But..those aren't literals, and literals aren't those.
16:58:45 <arkeet> just constructor is fine too
16:59:02 <L8D> https://ocharles.org.uk/blog/posts/2014-12-03-pattern-synonyms.html
16:59:14 <L8D> that might be what you're looking for
16:59:17 <monochrom> if you only restrict yourself to C terminology and concepts, there is no name or concept for Red and Blue
16:59:20 <nolrai66> (Yes, though non nullary constructors aren't constants.)
16:59:30 <arkeet> (sure they are!)
16:59:33 <nolrai66> (I..mean..)
16:59:51 <nolrai66> (Constant is a bad term to use in haskell.)
17:00:33 <monochrom> nolrai66, Red and Blue are constants. the only problem is that many other unrelated things are also constants, so it is an uninformative category. for example, (\x -> x && not x) is also a constant.
17:01:15 <bnsjkdf9> 'Couldn't match type ‘Data.Functor.Identity.Identity’ with ‘tran    sformers-0.3.0.0:Data.Functor.Identity.Identity’' ??
17:01:22 <nolrai66> Yes, but ":" is a function and so not a "constant" in the C language sense, but is something you can match on.
17:01:26 <monochrom> anyway, this is a reason why you cannot learn new things by mapping new things to old things. by definition of "new", there is no such mapping.
17:01:50 <arkeet> bnsjkdf9: you have some packages that depend on conflicting versions of transformers
17:02:02 <bnsjkdf9> arkeet: how do i fix it?
17:02:22 <arkeet> don't install multiple versions of transformers.
17:02:29 <arkeet> uh
17:02:33 <bnsjkdf9> i didnt install transformers at all
17:02:43 <bnsjkdf9> it was a dependency for something
17:02:45 <arkeet> well you did, indirectly
17:02:49 <bnsjkdf9> but
17:02:54 <bnsjkdf9> now that i have them installed
17:02:57 <bnsjkdf9> how do i fix it?
17:02:57 <arkeet> right
17:02:58 <monochrom> it is really too bad that cabal-install brings in multiple versions without your approval
17:03:11 <arkeet> monochrom can help.
17:03:18 <monochrom> instead, you have to go out of your way if you want to forbid it
17:03:44 <monochrom> and the sandboxing fans simply assume: sandboxing will make that problem go away
17:04:25 <monochrom> the problem doesn't go away. cabal-install is just as happy to bring multiple versions to your sandbox. you are none the wiser.
17:04:47 <michaelt_> bnsjkdf9: you will have to unregister the new transformers .  Then adjust your ~/.cabal/config
17:05:10 <bnsjkdf9> hmm michaelt_ are u sure its the new transformers and not the old one?
17:05:11 <Forgetaboutit> monochrom: what if I installed a package in a sandbox and globally with different versions?
17:05:17 <bnsjkdf9> how do i decide what version?
17:05:33 <Forgetaboutit> will Cabal resolve to the sandboxed version?
17:05:39 <monochrom> then when in that sandbox, you still see multiple versions
17:06:07 <michaelt_> bnsjkdf9: you need to keep the transformers that came with ghc , unless you are doing something really advanced
17:06:20 <arkeet> (ghc doesn't come with transformers)
17:06:39 <michaelt_> it's a 'boot package' or whatever, no?
17:06:40 <arkeet> bnsjkdf9: are you using the haskell platform?
17:06:43 <bnsjkdf9> no
17:06:51 <monochrom> depends on ghc version
17:06:56 <michaelt_> i just got a new transformers with my new ghc-7.10 
17:06:58 <L8D> arkeet: did you see my link?
17:06:59 <arkeet> oh, I guess ghc does come with it.
17:07:01 <arkeet> L8D: no
17:07:11 <arkeet> oh the pattern synonyms thing
17:07:12 <arkeet> what about it
17:07:17 <L8D> I mean
17:07:19 <michaelt_> ah wait right. depends on the ghc maybe, as monochrom is saying. 
17:07:19 <L8D> allyraza
17:07:23 <monochrom> ghc comes with transformers since 7.8
17:07:24 <arkeet> oh
17:07:35 <monochrom> did not when 7.6 or something
17:07:36 <allyraza>  L8D
17:07:43 <L8D> allyraza: https://ocharles.org.uk/blog/posts/2014-12-03-pattern-synonyms.html
17:07:53 <michaelt_> that sounds right, this 'constraint: transformers installed' thing is fairly new ...
17:08:45 <athan> Is a Monad & Comonad a profunctor in the category of Hask?
17:08:53 <monochrom> think of it as the Republican and the Democrats taking turn to become president and reverting the previous president's decision to include or not include transformers in ghc
17:08:57 <athan> or category of *->* or something?
17:09:23 <bnsjkdf9> ok i unregistered the more recent version of transformers now the indentation package doesnt work -_-
17:09:36 <arkeet> yes, because it depended on the newer one.
17:09:50 <bnsjkdf9> so
17:09:51 <michaelt_> did it depend on it, or just feel like having it, so to speak. 
17:10:02 <bnsjkdf9> ...
17:10:06 <bnsjkdf9> wat do??
17:10:11 <arkeet> it was built against the newer one.
17:10:23 <arkeet> maybe you can reinstall it and tell it to use the other version.
17:10:32 <bnsjkdf9> arkeet: have you used this package?
17:10:35 <arkeet> I have not.
17:10:39 <bnsjkdf9> ah ok
17:10:56 <bnsjkdf9> should i try removing the older transformers instead?
17:11:08 <arkeet> no.
17:11:17 <arkeet> you shouldn't remove parts of ghc.
17:11:29 <bnsjkdf9> :S
17:11:42 <arkeet> you can specify versions constraints when installing packages.
17:12:05 <arkeet> so try adding a constraint for transformers == 0.3.0.0
17:12:35 <bnsjkdf9> ok i removed the newer transformers, and reinstalled indentation and the issues seems to be resolved... for now at least
17:12:36 <michaelt_> bnsjkdf9: you can't remove it really.  you can put " constraint: transformers installed " in $HOME/,cabal/config before reinstalling indentation
17:12:48 <michaelt_> bnsjkdf9: oh good!
17:12:54 <arkeet> oh, didn't know about the "installed" thing.
17:13:20 <arkeet> bnsjkdf9: it's probably worth looking at `ghc-pkg list` to see what other packages have multiple versions installed.
17:13:26 <arkeet> and also `ghc-pkg check` to make sure nothing is broken.
17:13:50 <bnsjkdf9> arkeet: im guessing half my packages are broken like they always seem to be
17:14:32 <bnsjkdf9> simply installing packages with default settings seems to break lots of stuff quite often
17:14:36 <bnsjkdf9> -_-
17:14:46 <michaelt_> bnsjkdf9: if you havent unregistered any that wouldn't be too surprising. 
17:15:16 <michaelt_> bnsjkdf9: if you aren't using a sandbox it might be time to get rid of your locally installed packages do cabal update and ask for the ones you need anew
17:15:45 <bnsjkdf9> michaelt_: i do that sometimes
17:16:01 <bnsjkdf9> too much work tbh, im just trying to learn some simple haskell stuff
17:16:22 <michaelt_>  bnsjkdf9: if you install a few things, then do cabal update a month later and install a few more and so on, in the end you have given poor cabal install too many cross sections of hackage history
17:17:07 <bnsjkdf9> is sandboxes where u install packages per projects locally?
17:17:18 <michaelt_> bnsjkdf9: yes. 
17:17:20 <bnsjkdf9> i should probably use that i think
17:19:15 <michaelt_> bnsjkdf9: make a new directory ; enter it; do 'cabal sandbox init' and you have a sandbox.  How to manage it depends on what you are doing. (I'm not exactly user, but am a user nonetheless)
17:19:38 <bnsjkdf9> ah seems simple
17:19:52 <michaelt_> bah, bnsjkdf9 I meant, I'm not a 'power user' just a dumb user.
17:20:13 <bnsjkdf9> lol
17:20:34 <michaelt_> bnsjkdf9: do you have a 'cabalized' project?  If you so you can install its prerequisities in the sandbox. 
17:20:58 <bnsjkdf9> no im just playing around with a simple file as i read a tutorial
17:22:00 <michaelt_> if you want to call ghc MySimpleFile.hs with the sandbox you need to direct it to the sandbox package registry.  
17:22:32 <athan> Does anyone have tips for implementing a transpose function for 2d association lists? ie: of type `[(k0, [(k1, x)])] -> [(k1, [(k0, a)])]`
17:23:30 <michaelt_> bnsjkdf9: if you are inside your sandbox directory you can call MySimpleFile.hs inside ghci if you call it with 'cabal repl' with directs itself to the local sandbox.
17:24:03 <michaelt_> bnsjkdf9: that is, if you :l MySimpleFile.hs inside a ghci opened with "cabal repl" you get this result. 
17:26:10 * hackagebot multihash 0.1.0 - Multihash library and CLI executable  http://hackage.haskell.org/package/multihash-0.1.0 (LukeHoersten)
17:26:35 <benzrf> athan: s-sequence maybe?
17:26:52 <benzrf> > sequence 
17:26:53 <lambdabot>      No instance for (Typeable t0)
17:26:53 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
17:26:53 <lambdabot>        arising from a use of ‘show_M288335638447161624929418’
17:26:55 <benzrf> oh na
17:27:31 <athan> benzrf: hmm...
17:27:33 * athan banters
17:27:52 <benzrf> flatten rotate inflate
17:28:58 <athan> benzrf: Ahh! Thank you
17:29:08 <benzrf> > T.sequenceA ("foo", [("bar", 3), ("baz", 4)])
17:29:10 <lambdabot>  [("foo",("bar",3)),("foo",("baz",4))]
17:47:05 <tempay> Does anyone have easyVision installed? I am having a very unfun time installing it
17:47:06 <athan> @tell benzrf Do you think it would be possible with keys that aren't monoids, but just ordered?
17:47:07 <lambdabot> Consider it noted.
17:47:31 <benzrf> athan: you dont need either
17:47:55 <tempay> Can't get it to find my ipp libraries
17:48:05 <tempay> Save me from this hell
17:48:15 <athan> benzrf: Yes you do!! Don't you?
17:48:23 <athan> shoot :S
17:48:29 <benzrf> noo
17:48:34 <benzrf> hmm 1 sec
17:50:43 <a_porcupine> i can think of a really dumb algorithm that needs only Eq i think?
17:51:08 <benzrf> nay
17:52:06 <a_porcupine> benzrf: as in "that's impossible" or as in "you don't even need Eq"?
17:52:17 <a_porcupine> (on the keys, i mean)
17:52:48 <benzrf> the latter
17:52:52 <benzrf> as far as ican tell
17:53:33 <a_porcupine> ah. hmm, maybe... but an assoc list without Eq on the keys sounds sorta useless (as `lookup` needs it)
17:53:35 <athan> benrf: Thank you
17:54:31 <a_porcupine> i'm reminded of this somehow http://stackoverflow.com/a/12872133/257418
18:01:20 <zygentoma> a_porcupine: [like]
18:03:15 <dmj`> jle` ping
18:06:18 * hackagebot bytestring-trie 0.2.4.1 - An efficient finite map from (byte)strings to values.  http://hackage.haskell.org/package/bytestring-trie-0.2.4.1 (WrenThornton)
18:06:20 * hackagebot JsonGrammar 1.0.1 - Combinators for bidirectional JSON parsing  http://hackage.haskell.org/package/JsonGrammar-1.0.1 (MartijnVanSteenbergen)
18:17:58 <lebek> hello! I'm looking for a tool that will draw the expression tree for a haskell program
18:19:40 <sabalaba> Has anybody here had success installing accelerate-cuda on an Ubuntu machine? I'm on 12.04 LTS (Precise Pangolin) When I try to install cuda it simply gives me: http://lpaste.net/130171
18:20:19 <sabalaba> s/try to install cuda/try to install accelerate-cuda/
18:21:19 * hackagebot multihash 0.1.1 - Multihash library and CLI executable  http://hackage.haskell.org/package/multihash-0.1.1 (LukeHoersten)
18:22:13 <Gurkenglas> Doesn't "∂[] x = ([x], [x])" fail to enforce that the left list is finite?
18:25:22 <dmj`> is Tekmo here?
18:26:29 <cschneid> is there a `Min` monoid? Min x <> Min y => getMin x or y depending 
18:26:58 <c_wraith> cschneid: it's really only a Monoid for groups with a greatest element.
18:27:14 <c_wraith> cschneid: otherwise, it's more of a semigroup
18:27:23 <cschneid> c_wraith: ok sure. But in prelude :)
18:27:24 <Gurkenglas> Sounds like it should be a monoid constructor that takes a (a->a->Bool)
18:27:28 <cschneid> which lacks the semigroup
18:27:46 <c_wraith> looks like semigroup may be in the next version of GHC!
18:30:21 <a_porcupine> cschneid: https://hackage.haskell.org/package/semigroups-0.16.2.2/docs/Data-Semigroup.html#t:Min
18:30:32 <Gurkenglas> Hmmno, it should take a (a -> a -> a). The mappend operation, one could say. At that point, one could just allow anonymous typeclass instances
18:31:03 <cschneid> a_porcupine: cool, thanks
18:31:11 <cschneid> not that it helps for trying to impress my friend w/ a one-liner
18:31:23 <cschneid> if it then is: "ohh and use cabal to install packages"
18:31:28 <Axman6> :t Min
18:31:29 <lambdabot>     Not in scope: data constructor ‘Min’
18:31:30 <lambdabot>     Perhaps you meant one of these:
18:31:30 <lambdabot>       variable ‘sin’ (imported from Prelude),
18:31:33 <Axman6> :(
18:35:08 <caconym> Gurkenglas: did you figure out the foldl thing?
18:35:22 <Gurkenglas> nope
18:36:07 <Gurkenglas> The problem description told me not to make multiple passes, could that mislead me away from the intended solution?
18:37:09 <caconym> Gurkenglas: I don't think so
18:41:06 <Luke> After upgrading to 7.10 I get this on my profiling: hpc: can not find text_IINWRW1LxFGIctooOLjJAI/Data.Text.Unsafe
18:41:11 <Luke> anyone know what that is or how to fix it?
18:42:40 <doweaver> I'm trying to set up unit-testing on a beginner project I'm messing around with. It looks like HUnit is probably the way to go here, but I'm curious if you guys have any opinions on whether or not I should build a Cabal package to get automated test and build right from the start
18:43:02 <Luke> doweaver: I would set up cabal
18:43:09 <Luke> just run "cabal init" and it will set it up for yoy
18:43:11 <Luke> you*
18:43:16 <Luke> then you can easily hook in your tests
18:43:50 <doweaver> Luke: Cool - I haven't yet found a good guide for setting up HUnit with Cabal (well, I've found some stuff but everything seems to be different)
18:44:04 <doweaver> Luke: I'll keep poking at it, though :)
18:44:06 <Luke> let me copy you what I have
18:44:10 <Luke> it was pretty easy
18:44:24 <doweaver> Luke: Thank you!
18:45:31 <Luke> doweaver: https://gist.github.com/LukeHoersten/963bc5031493c339d830
18:45:44 <Luke> put your test sources in a different dir than your library sources
18:45:53 <Luke> then you just run "cabal test" and it will run that stuff
18:46:43 <TheMG> i'd like to assign the few few elements of a list to some variables
18:46:54 <TheMG> e.g. (a, b, c) = take 3 mylist
18:47:09 <johnw> let [a, b, c] = take 3 mylist in
18:47:28 <TheMG> oh, right
18:47:33 <TheMG> that makes sense
18:47:39 <doweaver> Luje: Awesome. I'll give that a shot
18:47:52 <Luke> doweaver: good luck
18:48:07 <Luke> doweaver: learning cabal is super helpful. it's an awesome package and will make your life a lot easier
18:51:48 <benzrf> @check \l n -> length (take n l) = n
18:51:48 <lambdabot>  <unknown>.hs: 1: 27:Parse error: =
18:51:50 <benzrf> @check \l n -> length (take n l) == n
18:51:52 <lambdabot>  *** Failed! Falsifiable (after 2 tests):
18:51:52 <lambdabot>  [] 1
18:51:56 <benzrf> :)
18:54:36 <Luke> After upgrading to 7.10 I get this on my profiling: hpc: can not find text_IINWRW1LxFGIctooOLjJAI/Data.Text.Unsafe
18:54:44 <Luke> also: anyone know if I can use 7.10 on hackage?
18:58:19 <d3dave> hey, cabal has a problem building test suites with `type: detailed-0.9`. is this documented somewhere?
19:06:19 <Fuuzetsu> > cos pi
19:06:21 <lambdabot>  -1.0
19:06:48 <nshepperd> Luke: is that a confusing way of saying it can't find the profiling build of 'text'?
19:07:30 <Luke> nshepperd: even if it is, why would that be the case?
19:08:14 <Luke> nshepperd: I think it's looking for the mix files
19:09:20 <nshepperd> i don't know
19:10:49 <Luke> nshepperd: do I need all my dep libraries to be compiled for profiling to profile my libs?
19:11:09 <Axman6> it's usually a good idea to do that
19:12:03 <Gurkenglas> @check \l -> length l < 2 || (l !! 0) == (l !! 1)
19:12:05 <lambdabot>  +++ OK, passed 100 tests.
19:12:12 <Gurkenglas> :/
19:13:26 <caconym> hm
19:13:45 <mauris> Gurkenglas: wow, what's causing that?
19:13:56 <Gurkenglas> I guess it's only checking [()]?
19:14:06 <Luke> Axman6: where do I need to put the -fhpc flag to make that happen?
19:14:18 <Luke> Axman6: right now I only have it on my `test` cabal directive
19:14:54 <mauris> @check (\l -> length l < 2 || (l !! 0) == (l !! 1)) :: (String -> Bool)
19:14:56 <lambdabot>  *** Failed! Falsifiable (after 4 tests and 1 shrink):
19:14:56 <lambdabot>  "ab"
19:15:05 <mauris> interesting
19:19:56 <Francisco> > sortBy (\x y -> if minNum x y == x then LT else GT) [nan,nan,2,3,1,nan,2]
19:19:58 <lambdabot>      Not in scope: ‘minNum’
19:19:58 <lambdabot>      Perhaps you meant one of these:
19:19:58 <lambdabot>        ‘minimum’ (imported from Data.List),
19:21:07 <Gurkenglas> Ooh, clrnd apparently got an instance of lambdabot running and had it join #lambdabot as deltabot so we now have a place to spam lambdabot when we don't want to spam this channel, but want to allow people who want to listen to do so. *advertising done*
19:23:24 <Gurkenglas> @free a -> b
19:23:24 <lambdabot> Extra stuff at end of line
19:23:29 <Gurkenglas> What went wrong here?
19:24:16 <Axman6> @free map
19:24:17 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
19:27:10 <int-e> @free foo :: a -> b
19:27:10 <lambdabot> g . foo = foo . f
19:28:34 <int-e> oh. that's @free's way of expressing that there is no such foo. (afaik the version in lambdabot is unaware of bottom)
19:31:20 <Gurkenglas> If it isn't, then foo is const _|_ and it assumes all functions are strict
19:31:45 <SEllhopany> Is it possible to show the description of a function in ghci?
19:32:28 <Gurkenglas> "Description"? You mean its type? :t does that. You mean what it does? No.
19:32:55 <hakujin> SEllhopany, :info may do what you want
19:33:12 <SEllhopany> I mean, what it does. So you can only see it in hoogle?
19:33:31 <Gurkenglas> Huh, I was wrong.
19:33:32 <Axman6> or in the actual docs for the package
19:33:41 <geekosaur> ghci is more a desk calculator and debugging aid than a fancy interactive environment like python and ruby provide. it is possible to hook hoogle up to ghci, though
19:33:42 <Gurkenglas> :info apparently is pretty good or pretty hardcoded
19:35:20 <geekosaur> https://wiki.haskell.org/Hoogle#GHCi_Integration
19:36:21 <SEllhopany> okay let me  check that.
19:38:01 <geekosaur> that may be out of date, though; scroll up to the top and you'll find a pointer to the current manual, which might have better suggestions about integration
19:51:05 <drbean> The Hoogle 5 development manual appears to have taken out the part about ghci integration.
19:52:09 <refried_> Could someone help me choose among the Haskell plugins for IntelliJ?
20:01:54 <d3dave> finally found it... the cabal `type: detailed-0.9` test-suites can only build as of v1.22 (https://github.com/haskell/cabal/commit/2b50d0a74ac8c460f2fb49711de1fb069d572ee5). this was not mentioned anywhere and has caused me a great deal of pain :(
20:02:30 <d3dave> refried_: as long as you stick to Haskell Platform, HaskForce will work fine for you
20:02:54 <refried_> thanks d3dave.  What does it mean to stick to Haskell Platform?
20:03:35 <d3dave> meaning don't update cabal, or other important libs, or ghc-mod will fail
20:07:30 <Fuuzetsu> switch to saner package manager…
20:10:57 <azure-satellite> hey guys. how can I use lambdabot here?
20:11:34 <caconym> https://wiki.haskell.org/Lambdabot
20:12:01 <glguy> azure-satellite: You can use lambdabot in private message with /msg lambdabot ?command
20:13:10 <azure-satellite> caconym: Obviously that was the first link I read. glguy: Thanks!
20:31:42 <AshyIsMe> > "azure-satellite: " ++ "also like this"
20:31:43 <lambdabot>  "azure-satellite: also like this"
20:32:14 <Gurkenglas> Why do so many functions have an alternative ending in _ to throw away the result when you could simply compose fmap (const ()) or an alias in front of it?
20:32:25 <Fuuzetsu> because we're lazy
20:32:53 <Fuuzetsu> @src mapM
20:32:53 <lambdabot> mapM f as = sequence (map f as)
20:32:55 <Gurkenglas> (I should probably say "to its left" there)
20:32:57 <Fuuzetsu> @src mapM_
20:32:57 <lambdabot> mapM_ f as = sequence_ (map f as)
20:33:02 <caconym> Gurkenglas: the _ versions are just shorter and more readable i think
20:33:03 <Fuuzetsu> @src sequence_
20:33:03 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
20:34:21 <Gurkenglas> Hmm. Someone should scour all the public sourcecodes for the most often used combinations of tokens so we can combine them into aliases
20:35:00 <Fuuzetsu> just search proposals for adding stuff to base on libraries@
20:35:15 <Gurkenglas> @?
20:36:16 <Gurkenglas> Where are those?
20:36:43 <glguy> Gurkenglas: the _ versions can be more efficient that fmap and const
20:37:02 <Gurkenglas> How so? Shouldn't laziness equate the two?
20:44:38 <glguy> No, it doesn't quite work out like that. Values can still be built up and things can be held on to longer than the _ version would require
20:47:03 <monochrom> lazy evaluation does not mean omnisciently know and skip everything unneeded
20:48:20 <monochrom> instead, it only means a fixed set of rules that short-circuits some things (but not all things)
20:48:44 <glguy> Fortunately the haskell report doesn't preclude omniscient evaluation
20:48:51 <glguy> So maybe one day...
20:48:52 <monochrom> "if b then () else ()" is an example of not skipping b although an omniscient being may
20:49:16 <monochrom> and "case xs of _:_ -> (); [] -> ()" too
20:49:19 <caconym> is the distinction that lazy evaluation prevents evaluating everything to WHNF but doesn't prevent thunks building up? or is the truth significantly more complicated than that
20:49:29 <caconym> i need to learn about this stuff
20:49:39 <monochrom> unfortunately those two examples imply that the Haskell Report precludes omniscient evaluation
20:50:28 <glguy> If is declared strict in the condition? :(
20:51:10 <pavonia> Is there a typeclass like Monoid but with only a single operation of type (a -> a -> a)?
20:51:27 <monochrom> See 2010 section 3.17.3, Figure 3.2, rule (r)
20:52:18 <monochrom> case ⊥ of { K ... -> e; _ -> e' } = ⊥ for non-newtype constructor K. without even looking at e and e'
20:53:40 <caconym> pavonia: Semigroup?
20:54:34 <arkeet> pavlicek: semigroup
20:54:36 <arkeet> pavonia: *
20:54:48 <pavonia> Yeah, thanks
21:04:45 <maxc01> @pl map (\x -> (length x, head x)) (group xs)
21:04:45 <lambdabot> map (liftM2 (,) length head) (group xs)
21:07:28 <refried_> d3dave oops, ok
21:07:34 <hjulle> How does memoSecond (http://hackage.haskell.org/package/data-memocombinators-0.5.1/docs/src/Data-MemoCombinators.html#memoSecond) work? Will it create a new memo table each time the memoized function is applied to its first argument?
21:09:17 <refried_> here i am trying to install probability-0.2.4.1 and failing
21:11:00 <refried_> any idea how i can learn to install it successfully?
21:14:40 <pavonia> refried_: What problem do you have with it? Paste the log, please
21:15:50 <refried_> thanks pavonia: http://lpaste.net/130175
21:17:38 <pavonia> Uh, I guess you base version is too old for that package
21:17:43 <pavonia> *your
21:17:50 <refried_> how can you tell?
21:18:04 <refried_> how can i fix it
21:18:07 <refried_> what's a base version :)
21:20:07 <pavonia> e.g. Could not deduce (Show prob) from the context (Num prob, Ord prob, Ord a, Show a)
21:20:35 <refried_> ah hm
21:20:35 <pavonia> AFAIK Show was a superclass of Num once but that may have changed in newer versions of base
21:20:55 <pavonia> Which meas your base version is too new, not too old :)
21:21:10 <refried_> does base version mean my ghc version?
21:21:26 <pavonia> No, but it's tied to it
21:21:36 <pavonia> What GHC version do you use?
21:22:07 <refried_> tonight somehow i've used both 7.8.4 and 7.10.1
21:22:39 <refried_> i definitely get the errors with 7.10.1; not sure if i got it with 7.8.4 but i can try reinstalling it
21:23:24 <d3dave> you should keep away from 7.10.1 for now until Haskell Platform gets an update and more packages support it
21:24:08 <pavonia> The changes have been active since GHC 7.4.1 apparently
21:26:39 <refried_> what's a good version for a newbie?
21:26:49 <refried_> I don't have to use that package, i just wanted to
21:27:00 <monochrom> 7.8.*
21:27:01 <Gurkenglas> ((Int -> a) -> Int) <- Would such a function receive a function that can produce a member of any type given an int, or a member of some type?
21:27:04 <refried_> I can just use Double for now
21:27:05 <AshyIsMe> is there a guide somewhere for how to implement a Typeable instance?
21:27:08 <refried_> thanks monochrom 
21:27:11 <AshyIsMe> from the hint package
21:27:16 <refried_> & pavonia, d3dave 
21:28:43 <pavonia> Gurkenglas: Of any type, where the caller chooses what type
21:29:17 <Gurkenglas> So I can't expect to be able to invoke the given function to produce, say, an Int.
21:29:59 <monochrom> depends on who "I" is, caller or callee.
21:30:07 <monochrom> the caller can. the callee cannot
21:30:21 <Gurkenglas> Yep, I'm playing the callee.
21:30:33 <Gurkenglas> Meaning that I can't possibly extract any information from the argument function.
21:30:51 <d3dave> refried_: what OS are you using?
21:30:59 <refried_> d3dave osx / homebrew
21:31:06 <refried_> yosemite
21:31:45 <monochrom> programming is a dialectic class struggle between the user and the implementer
21:32:47 <d3dave> i know nothing about osx, sorry. if you used windows, i could have helped
21:32:52 <Gurkenglas> Then why does @free goo :: ((Int -> a) -> Int) give another result than @free goo :: (a -> Int) ?
21:33:08 <Gurkenglas> @free goo :: ((Int -> a) -> Int)
21:33:08 <lambdabot> goo = goo . (.) f
21:33:12 <Gurkenglas> @free goo :: (a -> Int)
21:33:12 <lambdabot> goo = goo . f
21:33:36 <monochrom> I don't understand the question. do you have a proof that they should be equal?
21:33:37 <Gurkenglas> Couldn't you strengthen the first theorem into the second one?
21:34:05 <d3dave> monochrom: except the user is usually the only side that struggles... :/
21:34:20 <refried_> d3dave: no problem.  i was able to reinstall 7.8.4 — was that what you were offering to help with?
21:35:05 <d3dave> yea
21:35:14 <refried_> thanks though
21:35:47 <Gurkenglas> I have no proof, I'm just hoping someone sees where my intuition went wrong
21:37:28 <monochrom> they don't even have the same type. even if you prove that the two types are isomorphic, you have to add an explicit converter to convert from one type to another
21:42:43 <Gurkenglas> Misunderstanding? Repeating the question: Why can you only without consequence first put the argument to an ((Int -> a) -> Int) through a function of form (f.) :: (Int -> a) -> (Int -> a), rather than any function of type (Int -> a) -> (Int -> a) ?
21:42:49 <Gurkenglas> *Rephrasing
21:45:36 <Maxdamantus> Gurkenglas: unless you've enabled rank-two types, function values themselves have a single type without type variables.
21:46:40 <Maxdamantus> when you define something like: `f :: (Int -> a) -> (Int -> a)`, you're saying f is defined for types of the form `(Int -> a) -> (Int -> a)` for all a.
21:47:01 <xywsxp> ：）
21:47:19 <Maxdamantus> so the substitute for `a` has already been decided by the time you receive the argument.
21:51:28 <nshepperd> is 'goo = goo . f' supposed to mean that that is true for all f of the right type?
21:51:49 <monochrom> yes
21:51:59 <nshepperd> something like 'forall a. (goo :: a -> Int) = (goo :: a -> Int) . (f :: a -> a)'?
21:52:03 <monochrom> but mind the type of goo, too, to see why
21:52:38 <monochrom> yes
21:54:56 <nshepperd> ok so, then it seems like Gurkenglas's question makes sense. why shouldn't "forall a. (goo :: (Int -> a) -> Int) = (goo :: (Int -> a) -> Int) . (f :: (Int -> a) -> (Int -> a))"?
21:58:06 <maxc01> hello, how can I understand this 
21:58:22 <monochrom> I had an error.
21:58:23 <maxc01> (,) <$> length <*> head
21:58:29 <nshepperd> 'goo = goo . (.) f' does seem to be actually weaker than 'goo = goo . f' though, so I guess there must be a good reason
21:58:57 <monochrom> do you mind not calling two different things goo?
21:59:18 <nshepperd> er, right
21:59:21 <Gurkenglas> Good point, sorry. I shall rename both to quash any confusion
21:59:30 <maxc01> I know this will apply length and head to the parameter and use (,) to pack the results, but I cannot understand the details
22:00:14 <Cale> maxc01: What do you know about Applicative and/or Monad so far?
22:00:15 <Gurkenglas> hoo :: ((Int -> a) -> Int), joo :: (a -> Int)
22:01:02 <monochrom> the free theorem for joo is actually forall a b. (joo :: b -> Int) = (joo :: a -> Int) . (f :: a -> b)
22:01:19 <maxc01> Cale: I can understand some, but not so much
22:01:37 <Gurkenglas> a->Int and a->b don't compose.
22:01:43 <Cale> maxc01: The basic idea is that (->) e is an Applicative functor, as well as a Monad, for that matter. Specialising the types of the relevant operations by replacing f a with e -> a, we get...
22:01:53 <monochrom> sorry, then I have to correct it
22:02:04 <Cale> (<$>) :: (a -> b) -> (e -> a) -> (e -> b)
22:02:10 <monochrom> forall a b. (joo :: a -> Int) = (joo :: b -> Int) . (f :: a -> b)
22:02:22 <Gurkenglas> Yes, that's what @free said
22:02:33 <Cale> (<*>) :: (e -> (a -> b)) -> (e -> a) -> (e -> b)
22:03:02 <Gurkenglas> Waaait nvm I see your objection now lemme think again
22:03:27 <Cale> :t (,)
22:03:28 <lambdabot> a -> b -> (a, b)
22:03:53 <Cale> you can read that as  a -> (b -> (a,b))
22:03:53 <maxc01> Cale, Danke, I got it
22:04:05 <Cale> ah, cool :)
22:05:16 <maxc01> Cale, I don't realize (->) e is an Applicative functor
22:05:27 <nshepperd> 'hoo = hoo . f' does _seem_ like it should be a theorem
22:05:41 <Cale> The monad instance is a lot of fun:
22:05:57 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
22:05:58 <lambdabot>  ("hello","olleh","HELLO")
22:06:37 <Gurkenglas> I too have the feeling this disassociation of a and b will also not have me realize why that isn't a theorem once I manage to think it through.
22:06:47 <DerisiveLogic> Can someone mentor me to become pro at Haskell.
22:06:59 <DerisiveLogic> And so I can become a god at programming or something.
22:07:07 <Cale> So, what it means to "run" a function is just to apply it to the parameter of the overall combined function.
22:07:32 <laudiacay_mobile> DerisiveLogic: are you just now starting to code?
22:07:39 <DerisiveLogic> I'm not.
22:07:42 <DerisiveLogic> I'm not new to coding.
22:07:52 <DerisiveLogic> Just new to Haskell.
22:07:59 <laudiacay_mobile> Alright what's your experience level then?
22:08:28 <Cale> http://www.seas.upenn.edu/~cis194/fall14/spring13/index.html -- this course is generally regarded as good
22:08:28 <DerisiveLogic> Ehh, not so hot. I've been coding for the past 5 months consistently, for what it's worth.
22:08:45 <Cale> (click lectures and assignments at the top)
22:08:46 <DerisiveLogic> Except I've focused mostly on computer science topics and problem solving skills.
22:09:16 <Gurkenglas> Having explored lambdabot tells me someone would want me to post this link
22:09:18 <Gurkenglas> @learn
22:09:18 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
22:09:57 <Gurkenglas> But I understand if you can derive more motivation from IRC conversations than tutorial websites
22:10:11 <laudiacay_mobile> DerisiveLogic: i dont know if i would start haskell yet, id try to have java python and c under my belt first. But if you are really determined, learn you a haskell is an ebook that is funny and holds your hand through the first month or so
22:10:27 <DerisiveLogic> I've read about the first 40 pages of it.
22:10:41 <laudiacay_mobile> Yeah keep going
22:11:07 <laudiacay_mobile> And code little things that you've learned from his examples as you go
22:11:33 <DerisiveLogic> It's just, I always learn tons more through programming with someone.
22:11:38 <DerisiveLogic> So much faster and better.
22:11:44 <laudiacay_mobile> True...
22:11:47 <Gurkenglas> True...
22:12:15 <laudiacay_mobile> Idk. I would honestly wait, haskell is a big challenge and kind of a mind fuck
22:12:36 <Gurkenglas> I'll mentor you if someone better than me mentors me.
22:13:14 <kadoban> laudiacay_mobile: Personally I don't think imperative languages are fundamentally easier or required to learn haskell. And I /highly/ doubt that C is easier to learn than haskell.
22:13:16 <DerisiveLogic> Gurkenglas: How long have you been doing Haskell for?
22:13:26 <Gurkenglas> April 2014 I think? I could check
22:13:36 <DerisiveLogic> Hell, good enough for me rofl.
22:13:38 <monochrom> in the given theorem for hoo, (hoo :: (Int->a) -> Int) = (hoo :: (Int->b) -> Int) . ((f :: a -> b) .)
22:13:43 <DerisiveLogic> I spend usually 6+ hours a day coding.
22:14:04 <laudiacay_mobile> kadoban: ehhhhh i think he needs to know how to syntax well and get awesome at imperative algorithms first
22:14:10 <monochrom> in other words, (f .) :: (Int->a) -> (Int->b)
22:14:10 <Gurkenglas> I expect the same for the next about 10 days then college term starts again
22:14:14 <kadoban> laudiacay_mobile: Why?
22:15:08 <kadoban> laudiacay_mobile: Learning C syntax isn't going to teach much necessary for haskell, or teach you something fundamental about syntax itself.
22:15:16 <nshepperd> monochrom: right, the mystery is that (f.) doesn't match (const id), even though 'hoo = hoo . (const id)' is true (I think)
22:15:18 <laudiacay_mobile> kadoban: you need to think like a computer scientist first, know your algorithms, because learning basic computer science while trying to lambda is just a recipe for a mess
22:15:44 <DerisiveLogic> I learn by tackling the hardest things first though.
22:15:52 <Stratege> kadoban I'd argue that it's easier to get a toy python program going than a toy haskell program if one's new to programming. And then probably spend a lot of time debugging, but still.
22:15:54 <laudiacay_mobile> True that's a good plan
22:15:58 <DerisiveLogic> Screw tradition of starting with the easy things first.
22:16:04 <kadoban> laudiacay_mobile: Imperative languages aren't fundamentally more computer-sciency or algorithmic
22:16:31 <nshepperd> '(f .) :: (Int->a) -> (Int->b)' is a more restricted class of functions than 'g :: (Int->a) -> (Int->b)'
22:16:34 <kadoban> Stratege: python I could see, but I'm unsure if it's just easier because it's so much more similar to the languages that everyone knows or if it's fundamentally easier.
22:16:36 <laudiacay_mobile> kadoban: they aren't, but they make more sense at first look
22:16:47 <Stratege> DerisiveLogic that can run you into some mighty nasty walls and destroy motivation, speaking from personal experience, still sort-of worth it though.
22:17:07 <DerisiveLogic> That's what motivates me in the first place, challenges. Stratege 
22:17:12 <laudiacay_mobile> DerisiveLogic: im not kidding when i say you need to love learn you a haskell
22:17:15 <kadoban> laudiacay_mobile: I don't think that's true. It's just what more people are familiar with.
22:17:21 <DerisiveLogic> Plus, I have adderall on my side. I can't fail.
22:17:39 <DerisiveLogic> https://twitter.com/AdderalIHadMe/status/479398965931020289/photo/1
22:17:50 <Stratege> I know, but getting stuck and having no idea and no idea how to even get further can demotivate. A lot. I also tend to just pick the highest mountain I can find and start scaling it, figuratively. ^^
22:18:26 <DerisiveLogic> Yeah I can imagine.
22:19:09 <laudiacay_mobile> DerisiveLogic: yeah work through those handbooks, skip what you learned previously in other ones. Come here for support, then start coding real projects :D
22:20:10 <Stratege> kadoban: python looks a lot like the normal pseudocode, but yeah I can see the point of it just being similiar, guess one would have to ask someone who taught a lot of people from the start
22:20:11 <DerisiveLogic> Yeah, but I was hoping someone would want to "mentor" me along the way, since teaching something is a great way of pushing your knowledge and mastery as well.
22:20:51 <Stratege> DerisiveLogic: I'd give it a shot if I were confident in having sufficiently better skills in Haskell in the first place ^^;
22:21:18 <DerisiveLogic> Stratege: How long have you been coding in Haskell for?
22:21:30 <DerisiveLogic> I think even with a few months of experience, you'd have enough to teach.
22:22:09 <Stratege> first contact / starting to learn was probably January 2014? Switched to coding entirely in Haskell in August 2014
22:22:25 <DerisiveLogic> Yeah, I think I could learn a lot from you.
22:23:44 <Stratege> sure :) I'm anyway looking for people to talk haskell with ^^ sadly most of my friends aren't programmers or not really interested in haskell for some reason.
22:30:37 <zerkms> ghcjs + its dependencies are being installed for > 1hr at the moment
22:30:48 <zerkms> it reminds me when I was young and was using gentoo
22:32:15 <Fylwind> looking up .cabal fields is rather tedious, especially if I want to see if X is available in some cabal version; turns out the API docs is much easier for this purpose: https://hackage.haskell.org/package/Cabal is more u
22:32:27 <Fylwind> (disregard the 'is more u')
22:33:15 <Fylwind> but yeah I think the Cabal API docs are easier to read than the Cabal dev docs, but that's probably because I sort of already know where to look for things and don't need all the extra explanatory 'fluff'
22:44:56 <jle`> any reason why ZipList is not Traversable?
22:47:25 <Gurkenglas> Okay, I'm bad at tutoring :D
22:49:29 <Stratege> Gurkenglas ?
22:50:13 <Gurkenglas> Tried to get him to the Cofree constructor and failed at unfoldr ^^
22:56:32 * hackagebot sandman 0.1.0.0 - Manages Cabal sandboxes to avoid rebuilding packages.  http://hackage.haskell.org/package/sandman-0.1.0.0 (abhinav)
23:03:11 <zerkms> guys, is `cabal install` supposed to install dependencies for the project?
23:03:38 <monochrom> yes
23:04:05 <zerkms> what if it fails with "cabal install --only-dependencies" and adding `-v` does not bring any obvious issues?
23:04:21 <zerkms> oops
23:04:33 <zerkms> what if it fails with "cabal: Could not resolve dependencies:"
23:04:45 <zerkms> so - it does not tell what particular dependency it failed to install
23:04:54 <zerkms> trying to build this: https://github.com/ghcjs/ghcjs-examples/blob/master/ghcjs-hello%2Fghcjs-hello.cabal
23:06:49 <zerkms> seems like it's webkit-sodium that is not found :-S
23:07:31 <monochrom> the output of -v3 is long. however, experts know how to read it
23:08:28 <zerkms> yep thanks
23:08:38 <zerkms> now I realized there was a reference to what is not resolved
23:08:45 <zerkms> just didn't know where to look at
