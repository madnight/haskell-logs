00:05:42 <farrioth> I'm now trying to figure out why my question seemed to confuse everyone.
00:10:06 <yan4138_> exit
00:22:47 <Axman6> what's the extension for the Rec {..} syntax?
00:26:31 <nshepperd> RecordWildCards! I used it just today
00:27:16 <Axman6> thanks =)
00:29:27 <joneshf-laptop> I've got a design question for anyone still awake
00:29:42 <joneshf-laptop> i'm parsing files with a documented format
00:30:21 <joneshf-laptop> there's a field say, Type := A | B | C
00:31:01 <joneshf-laptop> and then there's the data, Data := { <int> <real> <real> }+
00:31:12 <joneshf-laptop> the type tells how to manipulate the data
00:31:38 <joneshf-laptop> so i figured i'd have `data Node = Node Int Double Double` for the data
00:32:02 <joneshf-laptop> `data Types = A | B | C`
00:32:23 <joneshf-laptop> and `type NodeA = Const Node A`, `type NodeB = Const Node B`, etc
00:32:59 <animesh> anyone up for dicussion on interesting problem
00:33:01 <animesh> ?
00:33:14 <joneshf-laptop> however, when I go to parse it, how can i ensure that it creates the correct type based on the `Type` field?
00:33:24 <animesh> for two arrays p and c of same size....minimize this function==> myfunction = max(p `div` c + p `mod` c)
00:33:35 <animesh> arrays are only integers
00:33:50 <joneshf-laptop> animesh, what does: p `div` c` mean for arrays?
00:34:00 <animesh> for instance p = [1,10000]
00:34:05 <animesh> c = [1,6]
00:34:18 <animesh> the input given is that....the sum of elements of c = 7
00:34:21 <animesh> so it can be 1,6
00:34:21 <animesh> 2,5
00:34:23 <animesh> or 4,3
00:34:31 <animesh> and length of c = length of p
00:34:44 <animesh> for [1,1000] = p
00:34:53 <animesh> and sum (c) = 10
00:34:57 <animesh> answer is choose 1,9
00:35:04 <animesh> and function value is 1112
00:35:16 <joneshf-laptop> :t div
00:35:18 <lambdabot> Integral a => a -> a -> a
00:35:27 <joneshf-laptop> how does taht work for arrays?
00:35:33 <animesh> the minimization function is let my_min  p c = foldl1 max $ zipWith (\p c -> (p `div` c) + (p `mod` c)) p c
00:35:43 <animesh> sorry lists
00:35:54 <animesh> assume lists not arrays in haskell
00:36:05 <joneshf-laptop> oh, you mean element-wise?
00:36:09 <animesh> yes
00:37:06 <joneshf-laptop> okay, so what's the question?
00:37:22 <joneshf-laptop> you want to convert the maximization to a minimization?
00:37:45 <animesh> k lemme clarify
00:37:56 <animesh> if c = [1,9] and p = [1,10000]
00:38:53 <animesh> then f = max (( 1 `div` 1 + 1 `mod` 1) , ( 10000 `div` 9 + 10000 `mod` 9))
00:39:00 <animesh> which gives 1112
00:39:14 <animesh> if i try 2,8 it will give some other number
00:39:23 <animesh> for 3,7 it will be some other value
00:39:33 <animesh> i need to find the c which gives minimum value
00:39:38 <animesh> it's minimum of a maximum
00:39:44 <joneshf-laptop> oh
00:40:10 <animesh> i have the solution which uses splitting a number in parts
00:40:24 <animesh> but it's too lame...and doesn't work for > 20 (takes too much time)
00:40:29 <animesh> nparts 0 = [] nparts n = [n] : [x:xs | x <- [1..n`div`2], xs <- nparts(n - x)]
00:40:51 <animesh> i filter the list for length == sum(c)
00:40:57 <animesh> where sum will be given by the user
00:41:06 <animesh> 1,9 = 10...2,8 = 10...
00:41:23 <animesh> if i do *Main> filter (\x->length x == 2) $ nparts 100 [[1,99]
00:41:26 <animesh> and it hangs…for a lot of time….so time constraint?
00:41:27 <animesh> :D
00:41:50 <joneshf-laptop> > let parts n = zip [1..n] [n, n-1..] in parts 10
00:41:51 <lambdabot>  [(1,10),(2,9),(3,8),(4,7),(5,6),(6,5),(7,4),(8,3),(9,2),(10,1)]
00:41:59 <joneshf-laptop> > let parts n = zip [1..n] [n-1, n-2..] in parts 10
00:42:01 <lambdabot>  [(1,9),(2,8),(3,7),(4,6),(5,5),(6,4),(7,3),(8,2),(9,1),(10,0)]
00:42:06 <joneshf-laptop> > let parts n = zip [1..n-1] [n-1, n-2..] in parts 10
00:42:08 <lambdabot>  [(1,9),(2,8),(3,7),(4,6),(5,5),(6,4),(7,3),(8,2),(9,1)]
00:42:12 <animesh> k how about 3 pairs
00:42:13 <animesh> ?
00:42:21 <joneshf-laptop> too much now
00:42:24 <animesh> i need to split 10 into 3 pairs or 4 pairs or n pairs
00:42:35 <joneshf-laptop> 3 pairs?
00:42:43 <joneshf-laptop> which pairs?
00:43:46 <animesh> Prelude> filter (\x -> length x == 3) $ nparts 10 [[1,1,8],[1,2,7],[1,3,6],[1,4,5],[2,1,7],[2,2,6],[2,3,5],[2,4,4],[3,1,6],[3,2,5],[3,3,4],[4,1,5],[4,2,4],[4,3,3],[5,1,4],[5,2,3]]
00:44:01 <animesh> Prelude> filter (\x -> length x == 2) $ nparts 10 [[1,9],[2,8],[3,7],[4,6],[5,5]]
00:44:13 <animesh> Prelude> filter (\x -> length x == 5) $ nparts 10 [[1,1,1,1,6],[1,1,1,2,5],[1,1,1,3,4],[1,1,2,1,5],[1,1,2,2,4],[1,1,2,3,3],[1,1,3,1,4],[1,1,3,2,3],[1,1,4,1,3],[1,1,4,2,2],[1,2,1,1,5],[1,2,1,2,4],[1,2,1,3,3],[1,2,2,1,4],[1,2,2,2,3],[1,2,3,1,3],[1,2,3,2,2],[1,3,1,1,4],[1,3,1,2,3],[1,3,2,1,3],[1,3,2,2,2],[1,3,3,1,2],[1,4,1,1,3],[1,4,1,2,2],[1,4,2,1,2],[2,1,1,1,5],[2,1,1,2,4],[2,1,1,3,3],[2,1,2,1,4],[2,1,2,2,3],[2,1,3,1,3],[2,1,3,2,2]
00:44:28 <animesh> coz in this case c will have these options and p will be list of 5 numbers
00:44:34 <animesh> problem remains same
00:45:07 <joneshf-laptop> i dunno what you tell you, i'm not good with combinatorics
00:45:18 <joneshf-laptop> it might not be a poly algo
00:45:32 <animesh> yeah am a bit confused too
00:45:34 <nak> animesh you can write (\x -> length x == 2) as ((==2) . length)
00:45:36 <animesh> my solution is not time bound
00:46:07 <animesh> problem is not the filter...problem is the recursion which runs too deep for nparts function i wrote
00:46:21 <animesh> basically i need a way to split a number into it's parts and length of parts = n
00:46:22 <nak> i undersatnd that, i was just pointing out another thing
00:46:22 <joneshf-laptop> it seems sort of like that sum of subsets thing
00:46:42 <animesh> so 5 3 should give....[1,2,2] or [3,1,1] etc.. 
00:46:43 <joneshf-laptop> which is NP-complete yes?
00:46:51 <animesh> yes
00:47:09 <animesh> or there might be another way to approach this problem rather than just brute forcing
00:47:28 <jle`> a little bit of np-hardness never hurt anyone
00:47:36 <animesh> to be more precise...the actual statement is this
00:47:36 <animesh>  The World Health Organization (WHO) wants to establish a total of B vaccination clinics across Ncities to immunization people against fatal diseases. Every city must have at least 1 clinic, and a clinic can only vaccinate people in the same city where they live. The goal is to minimize the number of vaccination kits needed in the largest clinic. For example, suppose you have:  2 cities and 7 clinics to be opened. If 200,000 is th
00:47:38 <nak> yeah if time isn't an issue, you can just create every combination and filter out the ones that match ?
00:47:39 <jle`> (disclaimer: probably not true)
00:48:02 <joneshf-laptop> or not
00:48:05 <joneshf-laptop> animesh, http://en.wikipedia.org/wiki/3SUM
00:48:21 <joneshf-laptop> thats got a big-theta(n^2) which sounds very promising
00:48:42 <nak> θ(n²) ^.^
00:48:48 <nak> ok good night everyone
00:48:58 <nak> i'll be back tomorrow
00:49:01 <animesh> k reading this...sounds interesting
00:49:29 <joneshf-laptop> but, you'd still have to create the elemnts
00:49:33 <joneshf-laptop> which is probably exp
00:50:18 <animesh> hmm 
00:50:35 <animesh> probably not the same thing as 3sum
00:50:39 <animesh> this problem seems very simple
00:51:03 <animesh> coz here i have to choose c such that condition is satisfied
00:51:09 <nak> animesh does this help you at all ?
00:51:15 <nak> > [(a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10], a+b+c == 10]
00:51:16 <lambdabot>  [(8,1,1),(7,2,1),(6,3,1),(5,4,1),(4,5,1),(3,6,1),(2,7,1),(1,8,1),(7,1,2),(6,...
00:51:38 <joneshf-laptop> yeah, you could probably use `replicateM`
00:51:45 <nak> you could do that with 4 parts really easily too
00:51:58 <nak> > [(a,b,c,d) | d <- [1..10], c <- [1..10], b <- [1..10], a <- [1..10], a+b+c+d == 10]
00:51:59 <lambdabot>  [(7,1,1,1),(6,2,1,1),(5,3,1,1),(4,4,1,1),(3,5,1,1),(2,6,1,1),(1,7,1,1),(6,1,...
00:52:54 <nak> i'm not clever enough to know how to abstract that into a `nparts` function tho
00:52:59 <animesh> how about a,b,c,d,.....N for a sum of (a+b+c+d+....) = X
00:53:09 <animesh> but k...i get an idea...
00:53:12 * nak nods
00:53:16 <nak> sorry i'm not more helpful!
00:53:20 <nak> good night 4 real this time
00:53:25 <igniting> > let listWithSum n 1 = [[n]]
00:53:26 <animesh> i seem to have coded up nparts horribly :(
00:53:27 <lambdabot>  <no location info>:
00:53:27 <lambdabot>      not an expression: ‘let listWithSum n 1 = [[n]]’
00:53:38 <igniting> uhh
00:53:48 <igniting> anyways, here is one definition
00:54:00 <joneshf-laptop> > let nparts n k = filter ((== k) . sum) $ replicateM n [1..k] in nparts 10 3
00:54:02 <lambdabot>  []
00:54:08 <joneshf-laptop> > let nparts n k = filter ((== k) . sum) $ replicateM n [1..k] in nparts 3 10
00:54:10 <lambdabot>  [[1,1,8],[1,2,7],[1,3,6],[1,4,5],[1,5,4],[1,6,3],[1,7,2],[1,8,1],[2,1,7],[2,...
00:54:26 <igniting> listWithSum n k = do m <- [1..n-1]; map (m :) $ listWithSum (n - m) (k - 1)
00:54:32 <igniting> animesh: ^
00:56:36 <joneshf-laptop> > let nparts n k = fmap sort $ filter ((== k) . sum) $ replicateM n [1..k] in nparts 3 10 -- if you need it sorted
00:56:37 <lambdabot>  [[1,1,8],[1,2,7],[1,3,6],[1,4,5],[1,4,5],[1,3,6],[1,2,7],[1,1,8],[1,2,7],[2,...
00:56:46 <joneshf-laptop> oh, there's dups
01:01:12 <joneshf-laptop> but, 
01:01:21 <joneshf-laptop> i wonder if there' a better approach to it
01:01:40 * hackagebot html-entities 1.0.0.3 - An "attoparsec" parser and a decoder of HTML entities  http://hackage.haskell.org/package/html-entities-1.0.0.3 (NikitaVolkov)
01:01:40 * hackagebot curlhs 0.1.5 - bindings to libcurl, the multiprotocol file transfer library  http://hackage.haskell.org/package/curlhs-0.1.5 (KrzysztofKardzis)
01:01:46 <animesh> yeah am still wondering :)
01:01:57 <joneshf-laptop> it seems like that a network flow problem
01:02:30 <animesh> how?
01:02:41 <igniting>  > let nparts n 1 = [[n]]; nparts n k = do m <- [1..n-1]; map (m :) $ nparts (n - m) (k - 1) in nparts 10 2
01:02:49 <igniting> > let nparts n 1 = [[n]]; nparts n k = do m <- [1..n-1]; map (m :) $ nparts (n - m) (k - 1) in nparts 10 2
01:02:50 <lambdabot>  [[1,9],[2,8],[3,7],[4,6],[5,5],[6,4],[7,3],[8,2],[9,1]]
01:03:00 <animesh> try for 100 and 3 
01:03:11 <igniting> > let nparts n 1 = [[n]]; nparts n k = do m <- [1..n-1]; map (m :) $ nparts (n - m) (k - 1) in nparts 100 3
01:03:12 <animesh> will hang
01:03:12 <lambdabot>  [[1,1,98],[1,2,97],[1,3,96],[1,4,95],[1,5,94],[1,6,93],[1,7,92],[1,8,91],[1,...
01:03:17 <joneshf-laptop> > let nparts n k = fmap sort $ filter ((== k) . sum) $ replicateM n [1..k] in nparts 3 100
01:03:19 <lambdabot>  [[1,1,98],[1,2,97],[1,3,96],[1,4,95],[1,5,94],[1,6,93],[1,7,92],[1,8,91],[1,...
01:03:35 <joneshf-laptop> > let nparts n k = Data.Set.fromList $ fmap sort $ filter ((== k) . sum) $ replicateM n [1..k] in nparts 3 100
01:03:37 <lambdabot>  Not in scope: ‘Data.Set.fromList’
01:03:41 <joneshf-laptop> > let nparts n k = S.fromList $ fmap sort $ filter ((== k) . sum) $ replicateM n [1..k] in nparts 3 100
01:03:43 <lambdabot>  fromList [[1,1,98],[1,2,97],[1,3,96],[1,4,95],[1,5,94],[1,6,93],[1,7,92],[1,...
01:04:03 <animesh> k it works 
01:04:03 <animesh> cool
01:05:35 <joneshf-laptop> animesh, the problem was cut off, can you link to the whole thing?
01:05:42 <joneshf-laptop> or use a paste
01:06:01 <joneshf-laptop> @paste
01:06:01 <lambdabot> Haskell pastebin: http://lpaste.net/
01:06:33 * hackagebot Network-NineP 0.3.0 - High-level abstraction over 9P protocol  http://hackage.haskell.org/package/Network-NineP-0.3.0 (SergeyAlirzaev)
01:07:10 <joneshf-laptop> but just from the part that went through, it seems like you could spin bipartite matching on it
01:08:00 <joneshf-laptop> and if so, there are poly time algos for that
01:10:09 <animesh> by definition replicateM n a = repeat action n times
01:10:29 <animesh> Prelude Data.List Control.Monad> replicateM 2 [1..10] [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7],[1,8],[1,9],[1,10],[2,1],[2,2],[2,3],[2,4],[2,5],[2,6],[2,7],[2,8],[2,9],[2,10],[3,1],[3,2],[3,3],[3,4],[3,5],[3,6],[3,7],[3,8],[3,9],[3,10],[4,1],[4,2],[4,3],[4,4],[4,5],[4,6],[4,7],[4,8],[4,9],[4,10],[5,1],[5,2],[5,3],[5,4],[5,5],[5,6],[5,7],[5,8],[5,9],[5,10],[6,1],[6,2],[6,3],[6,4],[6,5],[6,6],[6,7],[6,8],[6,9],[6,10],[7,1],[7,2],[
01:10:38 <animesh> so repeat action [1..10] 2 times...
01:10:51 <animesh> a bit confused here
01:14:17 <joneshf-laptop> > let xs = [1..10] in replicateM 1 xs == do {x <- xs; return [x]}
01:14:18 <lambdabot>  True
01:14:29 <joneshf-laptop> > let xs = [1..10] in replicateM 2 xs == do {x <- xs; y <- xs; return [x, y]}
01:14:31 <lambdabot>  True
01:14:42 <joneshf-laptop> > let xs = [1..10] in replicateM 3 xs == do {x <- xs; y <- xs; z <- xs; return [x, y, z]}
01:14:44 <joneshf-laptop> etc
01:14:44 <lambdabot>  True
01:15:18 <joneshf-laptop> you left off the important part at the end
01:15:38 <joneshf-laptop> replicateM n act performs the action n times, *gathering the results.*
01:17:19 <animesh> i found the xplanation here...thanks
01:17:21 <animesh> http://sleepomeno.github.io/blog/2014/06/25/Explaining-the-Magic/
01:17:32 <animesh> bit weak in haskell monads
01:17:38 <animesh> still learning!
01:18:33 <joneshf-laptop> maybe looking at the implementation would help?
01:18:50 <joneshf-laptop> @src replicateM
01:18:50 <lambdabot> replicateM n x = sequence (replicate n x)
01:19:05 <joneshf-laptop> replicate 2 [1..10]
01:19:09 <joneshf-laptop> > replicate 2 [1..10]
01:19:11 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10]]
01:19:17 <joneshf-laptop> > sequence $ replicate 2 [1..10]
01:19:18 <lambdabot>  [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7],[1,8],[1,9],[1,10],[2,1],[2,2],[2...
01:30:00 <Myrl-chan> :t sequence
01:30:01 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
01:30:14 <Myrl-chan> All these times, I thought sequence was for IO only.
01:35:16 <joneshf-laptop> Myrl-chan, before 7.10 it was `sequence :: Monad m => [m a] -> m [a]`
01:35:35 <Myrl-chan> Ah, cool.
01:36:24 <animesh> as per source code sequence ms = let k m m' = [x:xs | x <- m, xs <- m'] in foldr k (return []) ms
01:36:32 <yan4138_> 
01:36:51 <Myrl-chan> I don't even know how that works. Lol
01:37:03 <animesh> am trying to grasp that
01:37:10 <Myrl-chan> Lol. :D
01:41:02 <joneshf-laptop> that's the pre 7.10 implementation
01:42:33 <nshepperd> animesh: is that MonadComprehension syntax?
01:44:19 <animesh> yes
01:44:20 <nshepperd> the list implementation should be like 'foldr (liftM2 (:)) (return [])'
01:44:41 <nshepperd> ah, yes, that makes sense then
01:47:07 <animesh> k here's the confusing function 
01:47:09 <animesh> what happens here
01:47:10 <animesh> let s1 ms = let k m m' = do { x <- m; xs <- m'; return (x:xs) } in foldr k (return []) ms
01:47:16 <animesh> s1 ["01","01"]
01:47:31 <animesh> k is the function applied with foldr
01:47:43 <animesh> initially x<-0 and m' is the accumulator value
01:47:51 <animesh> return should be (x:xs) or 0
01:48:10 <lpaste> Phyx- pasted “Regex not support classes?” at http://lpaste.net/4390812149794996224
01:48:13 <animesh> how come k m m' = do { x <- m; xs <- m'; return (x:xs) } 
01:48:17 <animesh> returns multiple values
01:48:25 <Phyx-> lol, thanks lpaste :P
01:48:28 <absence> http://lpaste.net/131547 <- how can i reduce duplication here?
01:49:05 <Phyx-> http://lpaste.net/4390812149794996224 <- does anyone know if Text.Regex.Posix supports classes? e.g. \d \s etc
01:51:36 * hackagebot base58string 0.9.1 - Fast and safe representation of a Base-58 string  http://hackage.haskell.org/package/base58string-0.9.1 (solatis)
01:57:18 <kqr> Phyx-, posix regexes does not support classes in the style of \d, \s
02:00:01 <Phyx-> kqr: ah, was not aware of that. Thanks!
02:03:55 <latk> Probably a stupid question, but is there an easy way of getting monadlogger to log to a file? 
02:04:12 <latk> I can see functions to ignore logs, log to stdout and log to stderr only
02:06:29 <kqr> absence, http://lpaste.net/1831587879961231360
02:06:32 <kqr> absence, does that help?
02:06:59 <kqr> latk, well, depends on how easy you want to make it. you can log to stdout and then redirect in your terminal to a file
02:07:24 <kqr> latk, in fact, that idea is supported by http://12factor.net/logs
02:07:25 <Cale> You can use runLoggingT directly
02:07:43 <latk> kqr: I guess that doesn't deal with filerotation though.
02:08:13 <kqr> latk, you can direct it to a log router that deals with rotation and such
02:08:18 <kqr> latk, meaning you don't have to reinvent the wheel
02:08:30 <latk> kqr: That is what I am attempting to avoid :)
02:08:54 <latk> kqr: Could you recommend such a router? I'm not that experienced with doing this kind of thing.
02:09:20 <Cale> kqr: Are you talking about the same library what latk is?
02:09:36 <Cale> I'm assuming that we're talking about https://hackage.haskell.org/package/monad-logger-0.3.13.1/docs/Control-Monad-Logger.html
02:09:47 <latk> Cale: This is indeed what I'm talking about.
02:10:31 <Cale> (Personally, I would probably not use this library myself, I think it's kind of silly.)
02:11:04 <kqr> latk, logplex and fluent are two options – I haven't personally used either
02:11:04 <Cale> (But I tend to avoid any monad transformer that I can reasonably avoid)
02:12:26 <kqr> latk, syslog should be more or less standard for that kind of thing too
02:12:39 <latk_> Sorry, computer crashed on me.
02:12:54 <latk_> So I have missed the last couple of minutes of your responses.
02:12:59 <kqr> latk_, I was saying logplex and fluent are recommended by the 12factor.net guys
02:13:05 <kqr> latk_, and syslog should be something standard-ish
02:13:15 <Cale> What the heck is 12factor.net?
02:13:37 <kqr> latk_, I personally have experience of neither of them, but the general idea is to not have *your* application deal with managing log files, and let an external service do that
02:14:27 <latk_> Right. Do you know what e.g. yesod tends to do ?
02:14:33 <Cale> I'm not sure why a library wouldn't be sufficient. Do you really need a separate process?
02:14:35 <kqr> no idea what yesod does, sorry
02:14:38 <frerich> Cale: It clearly leverages the synergies to establish an improved methodology for devising scalable SaaS applications.
02:14:46 <Cale> frerich: lol
02:14:47 <latk_> I would assume the various web frameworks have this sorted.
02:14:48 <kqr> lol
02:14:50 <kqr> yes that ^
02:15:11 <kqr> latk_, I know django logs to stdout/stderr
02:15:24 <kqr> Cale, you could say that about anything, though
02:15:36 <kqr> Cale, in the end, I prefer keeping processes simple and having them communicate with each other
02:15:42 <latk_> I just want the most sensible solution that is the least effort for me :)
02:17:04 <latk_> I guess I'm either going to have to learn how syslog works, or learn how to get file-based logging working with a haskell lib. 
02:17:51 <lpaste> Cale pasted “Short example of logging” at http://lpaste.net/131549
02:17:56 <Cale> latk_: I'd just write something along the lines of this ^^
02:18:24 <Cale> Possibly I should make a library which does that just so that people might use it instead of the monad transformer nonsense
02:19:03 <latk_> Cale: What is the problem with the monad-transformer stuff ?
02:19:06 <kqr> Cale, isn't that doing precisely what ./myprogram > foo.log would do?
02:19:36 <Cale> kqr: The program might also emit messages on stdout and stderr separately
02:19:41 <Cale> So no.
02:19:47 <kqr> ah okay
02:21:34 <Cale> Also, the main thing which is going on here is picking out messages whose priority are large enough to go in the log, and apart from that, it's just a bracket-style open/close sort of operation.
02:22:06 <Cale> Obviously if you want things like log rotation, this code isn't doing that.
02:22:34 <kqr> http://tener.github.io/haskell-minirotate/doc.html
02:22:39 <kqr> that might though
02:22:49 <kqr> (random google search, no experience with it)
02:23:19 <Cale> latk_: The problem with monad transformers is that it's a lot of work to abstract over a bunch of monad transformers applied to IO in such a way that you don't have to liftIO everywhere. Also, you have the issue of how to deal with things like exceptions (catch) and forkIO
02:24:43 <Cale> latk_: Apart from ContT, most of the mtl monad transformers aren't very useful over IO, since IO already has a lot of facilities for state of various sorts.
02:24:45 <latk_> I don't really know anything about forkIO, or why exceptions would be hard in such a transformer stack. Also, if you are already in a MonadLogger monad, aren't you necessarily in MonadIO ?
02:25:13 <latk_> (clearly I'm not that experienced with regards to transformers, so forgive my ignorance)
02:26:18 <Cale> Well, okay, I used to have an article which explained this carefully, but I lost it to a hard drive failure.
02:26:50 <latk_> Cale: Ah, damn :(
02:27:25 <Cale> Monad transformers have lots of problems and tend to result in code with suboptimal readability and maintainability unless you're careful about the way in which you use them.
02:28:16 <Cale> You really almost always want to be defining a newtyped monad, and not exporting the newtype's data constructor from the module in which it's defined. Ideally, you don't want anyone to know that you used monad transformers, pretty much.
02:29:11 <Cale> mtl takes this totally non-scalable approach of defining lifting instances which turn FooT m into a MonadBar whenever m is an instance of MonadBar
02:29:58 <Cale> That doesn't work for arbitrary Foo and Bar, and even if it does, you need a lot of instances to do that lifting.
02:30:54 <latk_> Cale: From what I've seen, it seems that there are a few commonly used monad transformers.. is it often a problem that someone has to define these instances?
02:30:58 <Cale> What's worse is that if you expose the implementation of your monad in terms of transformers, and the clients of your library use lift a bunch to transform actions of the base monad into actions in your monad, then when you want to adjust the implementation of your monad, the clients of your library need to change
02:31:56 <latk_> Cale: Could you give a simplified example of this last point ? 
02:32:19 <latk_> I don't see why you would have to change code, as a user of a library.
02:32:28 <int-e> Cale: The best practice to avoid that is to wrap your own stack in a newtype, and implement MonadTrans for that newtype.
02:32:51 <int-e> but that wouldn't "expose" the stack, of course.
02:32:52 <Cale> So, okay, suppose I write something which just uses StateT MyState M directly, and I use lift :: M a -> StateT MyState M a in a bunch of places throughout the program
02:34:26 <Cale> Now I decide that StateT isn't enough, I need, I dunno, ExceptT or something. Now the lifts will have to become lift . lift
02:34:27 <int-e> And of course the MonadFoo (MonadState, MonadIO, etc.) classes are also designed to alleviate that particular problem.
02:34:54 <Cale> Of course, yes, that's sort of what these MonadFoo classes are for
02:35:26 <latk_> Cale: Okay, that makes sense.
02:35:33 <Cale> The idea being that you write everything polymorphically, and your functions have type signatures which constrain the monad in various ways.
02:36:05 <latk_> Cale: So that is what monadlogger does, right? I just added logging to stdout by simply changing (MonadIO m) to (MonadIO m, MonadLogger m)
02:36:05 <Cale> I kind of find that entire style of programming to be uglier than it has to be in a lot of cases where the base monad is IO and none of the monad transformers in use are very interesting though.
02:36:20 <Cale> Yeah, but okay, now you want to use threads
02:36:25 <Cale> :t liftIO
02:36:26 <lambdabot> MonadIO m => IO a -> m a
02:36:50 <latk_> Cale: I have to admit, I've done nothing with threads so far.
02:37:21 <Cale> That type has changed recently to use MonadIO, but you still have a bit of an issue. The action argument to it needs to be an IO action.
02:37:48 <Cale> So, if you want to send log messages from your new thread, you're out of luck now.
02:38:41 <Cale> and for many transformers it doesn't even make complete sense to have the new thread interacting with whatever the monad transformer is doing
02:39:23 <Cale> e.g. if you use StateT over IO, what would it mean for the other thread to manipulate the StateT's state? That doesn't work.
02:39:24 <int-e> Cale: I mostly agree btw. (Once you end up with packages like monad-control something has gone terribly wrong.)
02:40:18 <latk_> Cale: Okay. So what happens when you want to use multiple monads? Or are you just advocating not using them as much as possible ?
02:41:08 <Cale> Well, we have to be clear about what is meant by "use multiple monads".
02:41:20 <Cale> It's like asking "So what happens when you want to use multiple libraries?"
02:41:40 <latk_> Hm, fair enough. 
02:42:03 <latk_> How about, what situations would you use transformers ?
02:42:22 <Cale> Remember that monad is just an abstract interface to a pattern which shows up in many otherwise dissimilar libraries.
02:44:09 <Cale> Okay, so I'm mostly all right with it when the monad transformer is doing something nontrivial in terms of control -- such as ContT or Proxy from pipes or something like that. It tends to be the case that unfolding a use of one of those monad transformers isn't trivial.
02:45:04 <Cale> I also really like using stuff like StateT over [] (or another nondeterminism monad)
02:45:42 <latk_> Cale: Okay then. I'm not sure I completely understand all of your concerns, but thanks for explaining it :)
02:45:47 <Cale> Or stuff like WriterT (Product Rational) [] to get a nondeterminism monad which computes weights (like probabilities)
02:46:13 <Cale> I'll tend to newtype those anyway, but monad transformers are a good way to quickly construct a certain class of libraries
02:46:24 <visof> hi guys
02:46:28 <Cale> But I tend to avoid direct use of them in application code.
02:46:34 <MP2E> I was bit by using monad transformers carelessly recently, had an IRC bot with StateT over IO, holding my markov chain. I used bracket_ from exceptions to make sure the markov chain was written to on exit, but to my surprise, it would only ever write the initial state given at the beginning of the program! heh
02:46:44 <visof> i'm trying to install HLearn, i fetched it from github and http://sprunge.us/DXBU
02:46:59 <Cale> It's really hard to briefly explain all the problems that one runs into when using monad transformers
02:47:14 <Cale> MP2E: yes
02:47:52 <latk_> Cale: Hah, I can appreciate that!
02:47:52 <MP2E> I get it now, but it required the help of #haskell. I was very bewildered :P
02:48:07 <Cale> and when the transformer is StateT over IO, you could just be passing an IORef, or better yet, split up the ends of an IORef and pass the actions for reading and writing to it separately.
02:48:41 <Cale> Or ReaderT similarly is just parameter passing
02:49:03 <Cale> But you've replaced the syntactic noise of passing around a parameter with the syntactic noise of doing liftIO everywhere and making your types hard to read
02:49:04 <MP2E> ooh I like that idea
02:49:32 <Cale> So, usually I think you're just worse off in those cases
02:49:53 <Cale> I see a lot of people jumping to use ReaderT and StateT in places where it's not really going to help them
02:50:25 <latk_> Cale: It sounds like not everyone agrees with you, though - I mean, these other packages exist. If there are ways of doing it without using these transformers, why have the library writes chosen to do it in this way?
02:50:26 <Cale> They each have their uses, but most programs should avoid them altogether.
02:51:02 <Cale> Because there are a lot of beginners who don't know better and we do a poor job of warning them :)
02:51:18 <Cale> Well, that's one way of looking at it
02:52:09 <latk_> Cale: Hah, I salute those beginners with enough confidence to publish anything on hackage :p
02:52:13 <Cale> It's altogether possible to disagree with my claim that ReaderT r IO a code usually looks uglier than r -> IO a.
02:52:22 <Cale> It is a matter of taste
02:52:28 <latk_> Cale: Okay then.
02:53:27 <Cale> But I dunno, I've written a lot of programs both ways, and I like avoiding monad transformers, especially over IO, and especially when they're ReaderT, WriterT or StateT.
02:54:25 <latk_> It does seem that there is more cognitive overhead using transformers.
02:54:36 <Cale> The idea of abstracting algorithms over the choice of a monad though is a good one wherever it makes sense.
02:55:27 <Cale> One time Paolo Martini and I wrote a program to draw nondeterministic L-system fractals. At first we wrote the code to expand rules naively using the list monad.
02:56:25 <Cale> If you don't know, an L-system is a kind of string rewriting system where you successively replace symbols in a string with other strings, and interpreting the symbols as drawing commands can produce lots of interesting natural-like structures
02:57:38 <latk_> Cale: I didn't know. That sounds cool.
02:57:41 <Cale> So, I realised that we weren't really using too much about the list monad specifically in the code which was unfolding the rules, so I generalised it to use an arbitrary monad. By using a random generation monad, we could use the same code to pick an element at random from what would otherwise have been a list (without generating all the others, which was expensive)
02:58:51 <ocramz> jle` : I'm reading your latest blog post, good stuff!
02:59:05 <Cale> (the right hand side of each rule would just have to become an action for picking a rewriting for the symbol randomly)
02:59:26 <Cale> Using another monad would allow us to collect up the probability of each string occurring
03:00:01 <browndawg> Hey! How do I get a string value out of readOct and readHex just like I can with read?
03:00:24 <browndawg> they return ReadS and I have no idea what it is...
03:00:42 <Cale> > readHex "78d893"
03:00:43 <lambdabot>  [(7919763,"")]
03:00:47 <Cale> > readHex "78d893x"
03:00:49 <lambdabot>  [(7919763,"x")]
03:01:03 <browndawg> oh
03:01:04 <Cale> > readHex "78d893 392ff"
03:01:05 <lambdabot>  [(7919763," 392ff")]
03:01:10 <browndawg> k! got it!
03:01:12 <browndawg> thanks
03:01:12 <browndawg> :D
03:01:24 <Cale> > [(x,y) | (x,s) <- readHex "78d893 392ff"; (y,s') <- readHex s]
03:01:25 <lambdabot>  <hint>:1:41: parse error on input ‘;’
03:01:29 <Cale> > [(x,y) | (x,s) <- readHex "78d893 392ff", (y,s') <- readHex s]
03:01:31 <lambdabot>  []
03:01:37 <Cale> heh, oops!
03:02:06 <Cale> > [(x,y) | (x,s) <- readHex "78d893 392ff", (y,s') <- readHex (dropWhile isSpace s)] -- a little more disappointing
03:02:08 <lambdabot>  [(7919763,234239)]
03:02:48 <pentar_> Hi all. I just found a bug where I forgot the "deriving" in a freestanding deriving instance. The code compiled, but yielded a hard to trace stack overflow. Now I am curios: What is the meaning of "instance Eq T" (with neither deriving prepended nor a where-clause appended)? Why does it make expressions like "T == T" compile but produce neither warning nor the desired code?
03:03:27 <Cale> pentar_: That means an empty instance, where you haven't declared any of the methods.
03:03:50 <Cale> pentar_: The Eq class defines default implementations of (==) and (/=) in terms of each other, so that you only need to implement one of the two.
03:04:00 <Cale> pentar_: If you leave both definitions out, then you get an infinite loop.
03:04:43 <pentar_> Cale: that explains all the strange behaviour, thanks at lot.
03:05:26 <Cale> class  Eq a  where
03:05:26 <Cale>     (==), (/=) :: a -> a -> Bool
03:05:26 <Cale>     x /= y     =  not (x == y)
03:05:26 <Cale>     x == y     =  not (x /= y)
03:06:03 <lieven> isn't there a minimal implementation check to catch these?
03:06:30 <Cale> yes, in sufficiently recent GHCs...
03:07:20 <Cale> If I write instance Eq T without providing methods in GHC 7.10.1, I get:
03:07:25 <Cale> minimal.hs:2:10: Warning:
03:07:25 <Cale>     No explicit implementation for
03:07:25 <Cale>       either ‘==’ or ‘/=’
03:07:25 <Cale>     In the instance declaration for ‘Eq T’
03:07:50 <pentar_> I used 7.6.3
03:08:00 <pentar_> (and get no warning)
03:08:16 <Myrl-chan> Things that can be mapped over is part of applicable, right?
03:08:44 <Cale> Myrl-chan: Applicative, and yeah, Functor is a superclass of Applicative
03:08:55 <Myrl-chan> Cale: Lol, sorry for that mistake.
03:08:58 <Cale> :t fmap
03:08:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:09:05 <Myrl-chan> Cale: Thanks.
03:09:15 <Myrl-chan> I'm making a skew binary list implementation, just for the heck of it.
03:09:38 <Myrl-chan> Hmmm....
03:10:00 <kqr> pentar_, 7.10 is the brand new version, 7.8 is the one before that, and 7.6 is kinda old
03:10:20 <Myrl-chan> I think I now know why the skew binary list package has an array dependency.
03:11:23 <Cale> Yeah, I can't recall for sure if the minimal complete instance messages are in 7.8, but I suspect they are.
03:11:52 <pentar_> I just updated from 7.4 :-)
03:12:39 <Myrl-chan> I could just use arrays instead of trees... right?
03:13:30 <kqr> Cale, i can confirm it's in 7.8
03:13:46 <kqr> I long to the day I gather energy to upgrade to 7.10. /drool
03:15:44 <Cale> Myrl-chan: Arrays have fast (pointer indirection) lookups, but if you need to insert an element, you have to allocate a new Array
03:16:09 <Myrl-chan> Cale: Yeah, but random access list trees are complete trees anyway, so you wouldn't have to insert.
03:16:42 <Myrl-chan> Cale: Rather, you'd only be joining trees.
03:16:56 <Cale> Myrl-chan: Yeah, I don't know exactly what you're attempting, but if your data structure is expected to be created once and read many times, then an Array is appropriate.
03:17:54 <Myrl-chan> data STree a = Node a (STree a) (STree a) | Leaf a
03:17:55 <Myrl-chan> type SList a = [(Int, STree a)]
03:18:04 <Myrl-chan> Is there a better way to do that?
03:18:20 <Cale> You could use IntMap (STree a)
03:18:22 <Myrl-chan> One thing I can do is to recursively declare SList.
03:18:45 <Cale> At least, if the order of that SList doesn't matter
03:18:56 <Myrl-chan> Cale: It does.
03:19:03 <Cale> ah, okay then
03:19:22 <Myrl-chan> Cale: I also would need to extract the left and right trees later on.
03:19:36 <Myrl-chan> Cale: Such as when using tail.
03:19:58 <Cale> What do the Int values represent?
03:20:04 <Myrl-chan> Cale: Also, when should I use type and when should I use data?
03:20:12 <Myrl-chan> Cale: It represents the size of each tree.
03:20:57 <Cale> type doesn't actually define a new data type, it just gives a new name for an existing type
03:21:17 <Cale> You can think of it as just being macro-expanded everywhere that it occurs
03:21:18 <Myrl-chan> Cale: I see.
03:21:54 <Cale> Probably a better keyword would have been alias or something
03:22:06 <Myrl-chan> Cale: Thanks.
03:22:11 <Myrl-chan> Cale: What's newtype then?
03:23:45 <Myrl-chan> Cale: Would `data SList a = Int (Stree a) (SList a) | Nothing` be better too?
03:24:00 <browndawg> Parsec question. I have two parsers, where parser2 matches a subset of values of parser1. What do I have to do to make sure that subset only gets matched by parser2 and not 1?
03:25:08 <browndawg> I'm trying to work through the write you a scheme book
03:25:30 <browndawg> there's a parseAtom and a parseNumber that both accept '#d5'
03:25:36 <Cale> Myrl-chan: That's a confusing choice of data constructor names
03:25:39 <browndawg> but I want #d5 to always be parsed as a number
03:25:44 <browndawg> instead of an atom
03:26:03 <Cale> Myrl-chan: That will define  Int :: STree a -> SList a -> SList a  and  Nothing :: SList a
03:27:00 <Cale> Myrl-chan: Nothing is already in use by Maybe which is in the Prelude, so while you can import the Prelude hiding it, probably you'd want to just not trample on that name... and as for Int, I think maybe that's just you forgot to give a name there :)
03:28:05 <Cale> browndawg: You can use notFollowedBy which is described here: http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Combinator.html#v:notFollowedBy
03:28:54 <Myrl-chan> Cale: How about SNothing?
03:29:02 <Cale> Myrl-chan: sure :)
03:29:13 <browndawg> Cale: I don't understand. Both parseAtom and parseNumber will pass on "#d5"
03:29:21 <Myrl-chan> Cale: Also, I meant SNode Int (STree a) (SList a), Hahaha. what a mistake.
03:29:29 <browndawg> Cale: oh I see now
03:29:52 <browndawg> wait.. I don't
03:30:03 <browndawg> let me try something..
03:30:18 <Cale> browndawg: I mean, you can write parser1' = notFollowedBy parser2 >> parser1
03:41:56 <qiv> https://ideas.repec.org/p/mse/cesdoc/10076.html
03:41:59 <qiv> is that any good?
03:42:09 <qiv> "Time in discrete agent-based models of socio-economic systems"
03:42:14 <qiv> anyone knows it? :-)
03:46:24 <Phillema1n> Can I somehow just pattern match for a type constructor name, regardless of the number of parameters? I currently do: f (TypeA _ _ _) = x; f (TypeB _) = y; and so on
03:50:11 <kqr> Phillema1n, TypeA{}
03:50:13 <kqr> Phillema1n, I think
03:50:58 <kqr> Phillema1n, or maybe TypeA{..} which might require {-# LANGUAGE RecordWildcards #-}
03:51:16 <kqr> Phillema1n, no not wildcards
03:51:33 <kqr> Phillema1n, wildcards will set your local variables as well, which you probably don't want
03:52:06 <Phillema1n> Ahhh, great, I'll try.
03:52:15 <kqr> Phillema1n, yup TypeA{} should work
03:52:21 <kqr> > case Just 5 of { Just{} -> "just!!"; Nothing -> "nothing :(" }
03:52:22 <lambdabot>  "just!!"
03:52:30 <Phillema1n> Yes, TypeA{} works, thanks :)
04:01:41 * hackagebot stackage-upload 0.1.0.0 - A more secure version of cabal upload which uses HTTPS  http://hackage.haskell.org/package/stackage-upload-0.1.0.0 (MichaelSnoyman)
04:03:13 <fr33domlover> hello!
04:03:48 <fr33domlover> is there an approach in parsec and/or happy for returning smart meaningful error messages, like the ones GHC returns?
04:04:03 <fr33domlover> I mean, GHC can even guess what the error is and so on
04:04:57 <fr33domlover> none of the parsec examples I see have manually written messages, they just print the default "expected X or Y" which parsec provides
04:05:12 <exio4> fr33domlover: GHC parser errors are actually pretty crappy
04:06:03 <fr33domlover> exio4, maybe it's the semantic analyzer errors. The point is, I see compilers, GCC and clang too, which have errors beyond the plain "failed in line X column Y"
04:06:18 <fr33domlover> so I wonder how they even provide those useful messages
04:06:29 <fr33domlover> (i.e. is there a general approach for this)
04:06:36 <exio4> trifecta is a parser that tries to offer nicer errors and whatnot
04:08:13 <fr33domlover> exio4, thanks, i'll take a look
04:09:00 <fr33domlover> I'm writing some parsers and having errors like "invalid predicate found in statement #645" could be nice
04:09:10 <exio4> anyway, GHC normally outputs "parse error: (possibly ...)" or "expected )"-like errors after parsing 
04:16:41 * hackagebot stackage-upload 0.1.0.1 - A more secure version of cabal upload which uses HTTPS  http://hackage.haskell.org/package/stackage-upload-0.1.0.1 (MichaelSnoyman)
04:22:03 <Myrl-chan> I'm so tempted to convert both to list, then just use <*> on the two lists. Lol
04:24:35 <Myrl-chan> Oh my God.
04:26:42 * hackagebot eventloop 0.3.0.0 - A different take on an IO system. Based on Amanda's IO loop, this eventloop takes a function that maps input events to output events. It can easily be extended by modules that represent IO devices or join multiple modules together.  http://hackage.haskell.org/package/eventloop-0.3.0.0 (sebaslafleur)
04:26:44 * hackagebot twentefp-eventloop-trees 0.1.0.0 - Tree type and show functions for lab assignment of University of Twente. Contains RoseTree and RedBlackTree  http://hackage.haskell.org/package/twentefp-eventloop-trees-0.1.0.0 (sebaslafleur)
04:31:42 <safinaskar> ghci knows about Parsec's LanguageDef, but not about GenLanguageDef. http://paste.debian.net/169305/ . why?
04:31:55 <safinaskar> maybe am i running old version of parsec? how to determine this?
04:34:45 <kqr> safinaskar, check the latest version on hackage?
04:35:18 <Myrl-chan> How to avoid code reuse...   fs <*> xs = sfromlist $ (stolist fs) <*> (stolist xs)
04:35:56 <kqr> @pl \fs xs -> sfromlist $ stolist fs <*> stolist xs
04:35:56 <lambdabot> (sfromlist .) . (. stolist) . (<*>) . stolist
04:36:01 <kqr> uhhhh.. no
04:36:07 <Myrl-chan> kqr: LOL
04:36:28 <kqr> sfromlist . (<*>) `on` stolist
04:36:32 <kqr> something like that might work though
04:36:43 <Myrl-chan> @pl   pure x = SList 1 (Leaf x) SNothing
04:36:43 <lambdabot> pure = flip (SList 1 . Leaf) SNothing
04:36:57 <Myrl-chan> I was expecting that it'd use flip.
04:37:41 <kqr> is pure = flip (SList 1) SNothing . Leaf way wrong?
04:37:48 <kqr> looks easier to read to me, but it might not typecheck
04:38:14 <Myrl-chan> Let's not point free everything. :P
04:38:40 <kqr> point free ALL the things
04:38:51 <kqr> because if you can, you have to!!
04:39:12 <Myrl-chan> lol
04:41:52 <safinaskar> kqr: my version of parsec (as reported by ghci) is 3.1.9. official docs for 3.1.9 ( https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Token.html ) says that this version contains this identifier
04:42:08 <safinaskar> kqr: so, there should be no error. so, why i see an error?
04:42:45 <kqr> safinaskar, you have imported GenLangaugeDef from Text.Parsec.Token?
04:42:51 <kqr> safinaskar, nad you're sure there's no misspelling?
04:44:01 <safinaskar> kqr: i typed "import Text.Parsec.Token", so GenLanguageDef should be imported
04:44:11 <safinaskar> kqr: and there is no misspeling
04:44:21 <safinaskar> kqr: does my code work for you?
04:44:36 <kqr> I don't have your code
04:45:05 <kqr> oh sorry
04:45:07 <kqr> you linked it
04:45:20 <kqr> or did you
04:45:35 <kqr> no you did not
04:46:43 * hackagebot hruby 0.3.1.2 - Embed a Ruby intepreter in your Haskell program !  http://hackage.haskell.org/package/hruby-0.3.1.2 (SimonMarechal)
04:46:57 <safinaskar> kqr: well, there is no code. i just typed "import Text.Parsec.Token" to ghci, and then "let def = Text.Parsec.Token.GenLanguageDef { Text.Parsec.Token.commentStart = "" }". does this work for you?
04:47:42 <Phillema1n> kqr: Apparently, someone liked that {} thingy: http://www.reddit.com/r/haskelltil/comments/340oox/you_can_use_f_x_instead_of_f_x/ :D
04:48:56 <kqr> safinaskar, I get the same error, correct
04:48:58 <kqr> safinaskar, I'm confused
04:49:28 <kqr> Phillema1n, hah yeah. it's not a very well-known feature
04:51:01 <kqr> safinaskar, that's really weird actually
04:51:20 <kqr> safinaskar, you can even explicitly import it with import Text.Parsec.Token (GenLanguageDef)
04:51:31 <kqr> safinaskar, and still it doesn't think it exists when you try to access it
04:51:48 <kqr> safinaskar, you can do :info GenLanguageDef
04:51:53 <kqr> safinaskar, but not :type GenLanguageDEf
04:52:49 <kqr> safinaskar, that might very well be a bug in GHC(i). try creating your own data GenLanguageDef = Nada
04:52:54 <kqr> safinaskar, doesn't work either
04:53:08 <safinaskar> kqr: this is type constructor
04:53:15 <safinaskar> kqr: so you can do :k, but not :t
04:53:17 <kqr> oh
04:53:47 <kqr> but the rest applies
04:54:01 <safinaskar> kqr: but there is a problem: LanguageDef is type constructor, too. but i can do "let def = LanguageDef { ... }". and cannot "let def = GenLanguageDef { ... }". why?
04:54:52 <safinaskar> kqr: i found cause!
04:55:09 <safinaskar> kqr: GenLanguageDef is not a type constructor. this is just higher order type.
04:55:37 <safinaskar> kqr: and it is declared as "data GenLanguageDef -some-args-to-this-higher-order-type- = LanguageDef { ... }"
04:57:13 <kqr> safinaskar, ah of course! sorry. I'm so tired
05:00:43 <safinaskar> kqr: i misspelled terminology, again :(. well, GenLanguageDef is type constructor. and LanguageDef is type constructor (in fact, abbreviation) AND data constructor
05:16:29 <Myrl-chan> How the heck do I do this
05:17:22 <tony32lin> exit
05:21:37 <Myrl-chan> I'ma go for now.
05:35:27 <analia-arg> hi
05:49:53 <cYmen__> hi
05:49:58 <cYmen__> just stopped by to say:
05:50:02 <cYmen__> equalP' f k w x y z = f w x y z  == k    ....hahahahah
05:50:09 <cYmen__> (from rwh)
05:50:27 <kqr> haha
05:50:41 <kqr> useful
05:51:15 <mau}{ke]> @pl equalP' f k w x y z = f w x y z  == k
05:51:15 <lambdabot> equalP' = flip . ((flip . ((flip . ((flip . ((==) .)) .)) .)) .)
05:51:23 <mau}{ke]> that's the stuff
05:51:52 <cYmen__> -_-
05:51:56 <cYmen__> what have you done...
05:55:53 <cYmen__> @pl equalP' f k w x y z = k == f w x y z
05:55:54 <lambdabot> equalP' = flip ((.) . (.) . (.) . (.) . (==))
05:56:17 <kqr> that looks more like what I expected to see
05:56:23 <cYmen__> @pl equalP' f k w x y z = k == (f w x y z)
05:56:23 <lambdabot> equalP' = flip ((.) . (.) . (.) . (.) . (==))
06:08:14 <elflaclo> hi
06:08:25 <elflaclo> "!list"
06:08:47 <elflaclo> hello
06:08:50 <elflaclo> !list
06:08:51 <monochrom> elflaclo: http://lpaste.net/browse
06:10:02 <mau}{ke]> elflaclo: ciao
06:11:02 <elflaclo> http://lpaste.net/browse
06:13:00 <cYmen__> duck norris
06:19:36 <benzrf> hmm
06:19:46 <benzrf> is there a notion of dev dependencies for cabal
06:19:58 <benzrf> things that are not required for build but are available when developing
06:20:31 <benzrf> i have a sample testing thing that im not including in my repo but that lives in that dir, and it uses lens even though the project itself doesnt, but i dont wanna put lens in the cabal deps since it's not actually one >_>
06:20:46 <mpickering> install it globally?
06:22:51 <benzrf> mpickering: but then it doesnt play well with tools that ue the sandbox
06:22:58 <cYmen__> liftP :: (a -> b -> c) -> InfoP a -> b -> InfoP c \n liftP q f k w x y z = f w x y z `q` k
06:23:10 <benzrf> i have it installed in the sandbox, but hdevtools and stuff seem to go through cabal and ignore deps that arent there :\
06:23:15 <benzrf> and i use hdevtools with vim
06:23:43 <elflaclo> hello
06:23:49 <elflaclo> !list
06:23:49 <monochrom> elflaclo: http://lpaste.net/browse
06:24:18 <mpickering> install it in the sandbox but don't add it to the cabal file?
06:24:22 <cYmen__> I'm not quite sure what to think of this. I can understand it but it seems more difficult than necessary...
06:24:58 <benzrf> mpickering: thats what i did
06:25:16 <benzrf> >Could not find module ‘Control.Lens’ It is a member of the hidden package ‘lens-4.9@lens_E7yAyXiOp...
06:28:27 <elflaclo> "lwlist"
06:28:31 <elflaclo> ??
06:29:53 <elflaclo> ??
06:39:01 <benzrf> hmm
06:39:12 <benzrf> is there some kind of pragma to use a package that's not in the dependencies list
06:40:27 <lnode> hey guys, has anyone worked with gtk2hs here
06:40:39 <benzrf> use OPTIONS_GHC somehow?
06:41:17 <lnode> ghc won't import Graphics.UI.Gtk even tho i have the entire bundle installed
06:42:09 <solarus> benzrf: you could use a test-suite target in cabal and add lens as a dependency to that
06:42:22 <benzrf> sounds dishonest
06:42:27 <solarus> why?
06:42:36 <benzrf> i havent actually written any tests, just a trivial hacky use-case
06:42:38 <benzrf> :>
06:42:42 <solarus> :)
06:43:11 <lnode> hey guys, has anyone worked with gtk2hs here
06:43:12 <solarus> in any case, if you do that you can then do something like `cabal install --only-dependencies --enable-tests' and lens will be downloaded
06:43:24 <solarus> if you don't have --enable-tests lens will not be downloaded
06:43:45 <solarus> I believe :)
06:43:46 <pavonia> lnode: What error do you get?
06:44:07 <hexagoxel> benzrf: and using a package flag and conditional build-depends is not an option?
06:44:20 <benzrf> hexagoxel: im not sure
06:44:28 <fryguybob> lnode: You might want to run with more verbose output to see more error details as well, -v3 for lots of noise.
06:44:29 <benzrf> i'd probably have to add something to my vim config
06:44:29 <RaceCondition> is mail.haskell.org offline?
06:44:40 <benzrf> this is honestly seeming like more work than this hack is worth
06:44:42 <RaceCondition> nvm, just came up
06:44:51 <benzrf> i'll add a target if i write any actual tests or demos
06:44:58 <benzrf> for now ill just use a pragma hack :>
06:45:09 <benzrf> is there a ghc flag to use a package even though it's hidden by the cabal file
06:45:23 <lnode> @pavonia it wasn't able to find Graphics.UI.Gtk, even though it searched for it as shown using -v
06:45:24 <lambdabot> Unknown command, try @list
06:45:27 <benzrf> oh wait it does that by default, hm
06:45:56 <benzrf> brb
06:46:18 <pavonia> lnode: And you have installed the gtk package successfully?
06:46:25 <lnode> yeah, the gtk3-demo works
06:46:53 <lnode> and im just trying to make a file on my own right now, but it won't import Graphics.UI.Gtk
06:47:09 <pavonia> Is gtk3-demo a Haskell package?
06:47:25 <lnode> it comes within the gtk2hs bundle from the site
06:47:37 <lnode> apparently if it runs, then the package has installed correctly
06:47:59 <lnode> but i just can't import this module for some reason
06:48:04 <kqr> what is the error
06:48:19 <fryguybob> lnode: Can you paste the exact error message: lpaste.net
06:49:59 <fryguybob> lnode: And also you might try  ghc-pkg check  and  ghc-pkg list gtk
06:50:13 <fryguybob> And paste error messages from those.
06:50:46 <lpaste> lnode pasted “Gtk” at http://lpaste.net/131556
06:52:03 <kqr> it looks like you're not using sandboxes
06:52:06 <kqr> of which little good can come
06:52:50 <fryguybob> lnode: Your paste is consistent with gtk not being installed or it is in a sandbox and ghc doesn't know about it.
06:53:42 <fryguybob> lnode: What steps did you follow to install it?
06:55:44 <lnode> all i did was extract the entire bundle into a folder
06:56:25 <lnode> nothing too much, i tried doing cabal install gtk on cmd but it wasn't detecting some files 
06:57:09 <fryguybob> lnode: Ok, there are many more steps unfortunately: https://wiki.haskell.org/Gtk2Hs/Installation
06:57:28 <fryguybob> I don't know if that is up to date, it has been a while since I tried to install on Windows.
06:58:33 <askatasuna> hello! we are having a discussion with a coworker. he has written some tree data structure and has a bunch of associated functions, one of which takes a function and applies it to every node in the tree, returning a list of results, and another which does the same but preserves the tree structure. the debate is whether the name map always implies a list is returned or if it conveys the idea of an isomorphic
06:58:35 <askatasuna> application
06:59:06 <askatasuna> he has called the list-returning funcion map, and the tree-returning function edit
07:00:59 <askatasuna> what are your opinions?
07:01:35 <kqr> askatasuna, the one that preserves the structure is a Functor fmap
07:01:49 <kqr> askatasuna, the one that returns a list is a fold of some sort
07:01:53 <kqr> maybe even foldmap
07:02:06 <hodapp> is it common to put a function in a typeclass (including a definition) when it's never intended for an instance to define it... or does one just generally do that instead as a function with a typeclass constraint?
07:02:34 <cYmen__> ghc -c complains about no main...isn't -c for compiling modules?
07:05:36 <askatasuna> kqr: thanks!
07:06:12 <kqr> cYmen__, -no-hs-main
07:06:26 <cYmen__> hm... and -c? :)
07:07:00 <kqr> -c just doesn't combine the binaries into an executable file
07:07:13 <kqr> not sure where main comes into that
07:07:43 <lpaste> cymen pasted “indent” at http://lpaste.net/8232917750507372544
07:08:22 <cYmen__> Could somebody explain to me why the second indent form in that example doesn't work?
07:08:39 <mau}{ke]> cYmen__: must be indented more than 'bar'
07:08:46 <mau}{ke]> because you're in a 'where' block
07:09:07 <geekosaur> being less indented then the `where` ends the where block and the top level declaration
07:09:18 <geekosaur> then the thing after the where, that is
07:09:18 <lnode> im having trouble using cabal install gtk
07:09:27 <cYmen__> but it is indented MORE than the where
07:09:39 <cYmen__> and in the first example I didn't have to indent it more than the =
07:09:42 <kqr> cYmen__, but less than the thing after where
07:09:43 <lnode> anyone have experience installing gtk on windows
07:09:46 <kqr> cYmen__, which is what's important
07:09:50 <mau}{ke]> cYmen__: = isn't special
07:10:53 <cYmen__> fine...
07:11:38 <mau}{ke]> cYmen__: you could move the 'where' to the preceding line or start a new line after it
07:11:56 <mau}{ke]> what matters is the column of the token after where/do/let/of
07:12:00 <mau}{ke]> (unless it's '{')
07:12:25 <cYmen__> mau}{ke]: somehow that makes is worse
07:12:43 <cYmen__> so if I indent "bar" on its own line I can actually indent the following line LESS and it will work
07:12:57 <kqr> not less than bar
07:13:10 <cYmen__> but less than the end of where
07:13:11 <kqr> as soon as you indent less than the function name you break out of the function
07:13:16 <mau}{ke]> cYmen__: of course
07:13:18 <kqr> yes
07:13:32 <mau}{ke]> this happens all the time
07:13:35 <mau}{ke]> case foo of
07:13:39 <mau}{ke]>   Blah -> ...
07:13:46 <mau}{ke]> ^ indented less than "of"
07:14:02 <kqr> the function body must be more indented than the function name. it's not that weird
07:14:05 <mau}{ke]> or:
07:14:09 <mau}{ke]> module Main where
07:14:11 <mau}{ke]> main = ...
07:14:18 <cYmen__> alright, I guess that's a rule I can remember
07:14:26 <mau}{ke]> whole module body indented less than 'where'
07:15:45 <cYmen__> okay, thanks
07:16:24 <mau}{ke]> personally I use this kind of formatting:
07:16:26 <mau}{ke]> foo = bar
07:16:28 <mau}{ke]>   where
07:16:30 <mau}{ke]>   bar = 42
07:16:50 <osfameron> bah, 2-indent space... you young people
07:16:57 <osfameron> 2-space indent even...
07:17:09 <kqr> personally I find `where` formatting awkward regardless of how I do it so I avoid it :(
07:17:11 <mau}{ke]> this is for demonstration on IRC :-)
07:17:17 <mau}{ke]> in files it's 4 spaces
07:17:26 <ion> hi mauåäkeÅ
07:17:28 <mau}{ke]> or tabs
07:17:28 <osfameron> ah,hehe
07:17:37 <mau}{ke]> but things line up the same way
07:17:43 <kqr> haha ion uses a very modern character set, I see
07:18:13 <ion> kqr: IRC nicknames are specified to be encoded in ISO646-FI. All clients just do it wrong.
07:18:19 <kqr> ion, of course
07:18:47 <mau}{ke]> ion: is that in the RFC?
07:19:01 <kqr> can't find it in any of them
07:19:44 <JordiGH> Is there a succinct way to define a list where the nth entry is the sum of the squares of all entries before?
07:21:21 <JordiGH> Blegh, never mind, it's too easy to find a formula that doesn't depend on solving the problem of finding the nth entry in terms of all previous ones in a short idiom.
07:21:59 <mau}{ke]> > iterate (\x -> x + x * x) 0
07:22:01 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
07:22:34 <JordiGH> iterate (\x -> x + x * x) 1
07:22:39 <JordiGH> > iterate (\x -> x + x * x) 1
07:22:41 <lambdabot>  [1,2,6,42,1806,3263442,10650056950806,113423713055421844361000442,1286493868...
07:23:02 <JordiGH> Yeah, the actual problem I'm trying to do is to write the Catalan numbers from their recursive definition.
07:23:18 <JordiGH> So I actually need to reverse the init of the list before I can add a new term.
07:23:27 <JordiGH> Or just use a completely different formula for the Catalan numbers.
07:23:48 <kqr> that iterate function doesn't do the right thing anyway
07:23:48 <JordiGH> I was trying to learn a new Haskell trick. I suppose iterate could be what I learned, but it's not what I was after.
07:23:54 <mau}{ke]> there's haskell code in https://oeis.org/A000108
07:23:54 <kqr> 3rd item should be 5, not 6
07:24:21 <KaneTW> is it possible to make fix work with something like phi x = 1 + 1/x
07:24:23 <JordiGH> kqr: And 2nd item should be 1, not 2.
07:24:31 <KaneTW> > iterate (\x -> 1 + 1/x) 1
07:24:32 <kqr> that too I guess
07:24:32 <lambdabot>  [1.0,2.0,1.5,1.6666666666666665,1.6,1.625,1.6153846153846154,1.6190476190476...
07:24:45 <mau}{ke]> kqr: and the first item should be 0
07:24:58 <kqr> if first item is 0, how will you get anythign other than 0
07:24:59 <KaneTW> fix doesn't converge for that (obviously) but i have a feeling there should be a way to
07:25:04 <JordiGH> mau}{ke]: Let's avoid trivialities.
07:25:06 <mau}{ke]> you don't :-)
07:25:26 <mau}{ke]> but the iterate function assumes the preconditions are valid
07:26:12 <lnode> anyone have experience installing gtk2hs for windows
07:26:25 <JordiGH> mau}{ke]: I was trying to write this without needing an n variable, and without reversing the list: http://codepad.org/RvFIkUeA
07:27:11 <ion> mauåäkeÅ: “Because of IRC's scandanavian origin, the characters {}| are considered to be the lower case equivalents of the characters []\, respectively. This is a critical issue when determining the equivalence of two nicknames.” That’s longhand for ISO 646-FI.
07:28:00 <mau}{ke]> ion: no, it's not. it's talking about the characters {}|[]\, not åä...
07:28:24 <c_wraith> JordiGH: You know that zipWith replaces that crazy comprehension you have going on?
07:28:49 <JordiGH> c_wraith: I think the comprehension version is easier to read.
07:29:04 <c_wraith> JordiGH: because it has more tokens and more transformations?
07:29:15 <JordiGH> c_wraith: Yes, redundancy helps humans readers.
07:29:30 <JordiGH> This is what I'm going to tell you. I'm telling you now. This is what I just told you.
07:29:44 <mau}{ke]> doesn't help me
07:29:47 <mau}{ke]> humans suck
07:29:47 <c_wraith> JordiGH: it's far easier to say "multiply the contents of these two lists pointwise" than it is to say "build a list of pairs out of these two lists, then dissassemble the pairs, then multiple the two components of each pair"
07:30:06 <JordiGH> c_wraith: I'm not interested in this problem, but your interest is noted.
07:30:17 <johnw> pointwise and line foolish
07:30:54 <lnode> anyone have experience installing gtk2hs for windows
07:31:15 <kqr> > let xs = 1 : [sum (map (**2) ys) | ys <- inits xs, not (null ys)] in take 10 xs
07:31:17 <lambdabot>  [1.0,1.0,2.0,6.0,42.0,1806.0,3263442.0,1.0650056950806e13,1.1342371305542185...
07:31:19 <manju> Hello
07:31:27 <kqr> JordiGH, ^
07:31:43 <manju> https://github.com/cyga/real-world-haskell/blob/master/ch16/csv5.hs <- Why doesn't this example work ?
07:31:49 * hackagebot hpack 0.1.2 - An alternative format for Haskell packages  http://hackage.haskell.org/package/hpack-0.1.2 (SimonHengel)
07:31:56 <c_wraith> JordiGH: in any case, it's pretty easy to do without n *if* you go the other direction.  that is, just create an infinite list of all catalan numbers in increasing order.
07:31:59 <kqr> manju, what's the error message?
07:32:00 <manju> I tried :l csv5.hs
07:32:18 <JordiGH> c_wraith: It's not easy for me, can you show me why it's easy for you?
07:33:05 <lpaste> manju pasted “csh5.hs” at http://lpaste.net/131560
07:33:22 <manju> kqr, http://lpaste.net/131560
07:33:30 <kqr> manju, looks like it wants you to add type signatures!
07:33:37 <manju> Oh.
07:33:46 <mau}{ke]> monomorphism restriction?
07:33:58 <kqr> maybe that too. I never know when that's the problem
07:34:12 <mau}{ke]> when it doesn't work without a type signature
07:34:16 <mau}{ke]> :-)
07:34:42 <johnw> monomorphism is when a function that you think should be polymorphic is getting fixed to a specific type by your use of it, due to lack of a type signature and where it is defined
07:34:43 <JordiGH> kqr: Why did that turn into floats?
07:34:47 <mau}{ke]> you can try adding {-# LANGUAGE NoMonomorphismRestriction #-} at the top
07:34:58 <mau}{ke]> if that fixes it ...
07:35:10 <kqr> JordiGH, I used x**2 to square, and ** works on floats
07:35:14 <mau}{ke]> > let xs = 1 : [sum (map (^2) ys) | ys <- inits xs, not (null ys)] in take 10 xs
07:35:15 <kqr> JordiGH, you can use x^2 if you want integers
07:35:15 <lambdabot>  [1,1,2,6,42,1806,3263442,10650056950806,113423713055421844361000442,12864938...
07:35:33 <JordiGH> Ah, inits...
07:35:50 <mau}{ke]> johnw: except in this case it's not a function and there is no use, so it stays a type error
07:36:02 <JordiGH> Maybe inits is the piece I was missing.
07:36:23 <johnw> mauåäkeÅ: Ah, that's not usually when I run into NMR I guess
07:37:26 <kqr> 16:33 <mau}{ke]> when it doesn't work without a type signature
07:37:45 <kqr> mauke, is that really it? ghc can infer the types of everything when you turn off the monomorphism restriction?
07:40:27 <kqr> JordiGH, disclaimer: i have no idea how that code works, I just tried a bunch of things and that appears to produce somewhat correct results
07:41:04 <JordiGH> kqr: Amazingly, I can read that and it makes sense to me.
07:41:41 <cYmen__> kqr: actually with -no-hs-main it still complains about main not being defined
07:42:37 <gremble> I am trying to make a simple function that strips vowels from sentences that I type into the terminal, http://sprunge.us/LYBc I get a parse error: "Parse error on input '''" I think my datatype is entirely incorrect as it is not supposed to have constants. But I'm not completely sure how to fix it
07:44:18 <kadoban> gremble: Instead, just do vowels = "aeoui"   or alternatively, vowels = ['a', 'e', etc.]
07:44:49 <JordiGH> > take 20 1:[sum $ zipWith (*) c (reverse c)|c <- inits catalan, not (null c)]
07:44:50 <lambdabot>  Not in scope: ‘catalan’
07:45:31 <JordiGH> > let catalan = 1:[sum $ zipWith (*) c (reverse c)|c <- inits catalan, not (null c)] in take 20 catalan
07:45:33 <lambdabot>  [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,3...
07:45:39 <JordiGH> Yay, Catalan numbers.
07:45:57 <kadoban> gremble: When you do 'data', the bits on the right need to have actual constructors. Like: data vowel = Blah Char  -- but then that doesn't really give you a way to say "just vowels". So I'd just just a function (isVowel) or a data structure you can look up the vowels in.
07:46:14 <JordiGH> c_wraith: I guess it's easy if you're aware that inits exists in the stdlib.
07:46:14 <lpaste> Exio4 pasted “catalan numbers (explicit recursion, using an helper)” at http://lpaste.net/131561
07:46:39 <exio4> @letlpaste 131561
07:46:40 <lambdabot>  Defined.
07:46:42 <exio4> > take 20 cat
07:46:43 <lambdabot>      Ambiguous occurrence ‘cat’
07:46:44 <lambdabot>      It could refer to either ‘L.cat’, defined at L.hs:185:1
07:46:44 <lambdabot>                            or ‘Text.PrettyPrint.HughesPJ.cat’,
07:46:50 <exio4> > take 20 L.cat
07:46:52 <lambdabot>  [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,3...
07:47:58 <exio4> JordiGH: another version, using explicit recursion, which is just an unfoldr
07:48:08 <gremble> Thanks kadoban 
07:48:36 <JordiGH> > let catalan = 1:[sum $ zipWith (*) c (reverse c)|c <- tail.inits $ catalan] in take 15 catalan
07:48:37 <lambdabot>  [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440]
07:48:46 <JordiGH> Can I assume that the empty list in inits is always the first element?
07:49:03 <JordiGH> Also, I keep wishing that . had higher precedence than function application.
07:49:13 <kqr> JordiGH, there's $ for that
07:49:20 <kqr> JordiGH, $ is function application with really low precedence
07:49:23 <JordiGH> Ugly, but too late to argue about syntax.
07:49:36 <kqr> heh
07:49:39 <kqr> you can define your own version
07:49:40 <JordiGH> You can see I know $, I just don't like how ti looks.
07:49:57 <JordiGH> Can you define anything with higher precedence than application?
07:50:08 <kqr> no
07:50:12 <JordiGH> ;_;
07:50:31 <indiagreen> you can't, but braces (when working with records) have higher precedence
07:50:59 <indiagreen> something like “f x {field = value}” is parsed as “f (x {field = value})”
07:52:02 <tromp> so do at markers: f x@(h:t) = foo
07:52:14 <indiagreen> well, that's only in patterns
07:52:27 <tromp> right
07:53:33 <indiagreen> if (.) had higher precedence than function application, we wouldn't be able to do things like “someFunc x . otherFunc y”, and it'd have to look like “(someFunc x) . (otherFunc y)”... and it actually sounds like a good thing
07:54:41 <kqr> lol
07:54:45 <kqr> but muh lenses
07:54:58 <kqr> traverse . (at 1) . _1
07:55:19 <JordiGH> indiagreen: You can always override any precedence with parens.
07:55:19 <indiagreen> to be honest
07:55:30 <indiagreen> I was always annoyed by “traverse.at 1._1”
07:55:40 <indiagreen> it is so broken in the middle
07:55:52 <kqr> I like it better than traverse.(at 1)._1
07:56:01 <haasn> traverse . at 1 . _1
07:56:16 <kqr> and that best
07:56:34 <haasn> JordiGH: foo.bar x = foo $ bar x
07:56:45 <haasn> I tend to find that cleaner than foo . bar $ x
07:56:59 <haasn> I mean (foo.bar) x
07:57:30 <JordiGH> haasn: I don't. It makes it seem to me like you gotta contort the syntax more if you want to compose functions and apply them at once.
07:57:48 <JordiGH> I wish I could write: sin.cos pi/2
07:58:03 <JordiGH> Since that's actually how I would write it on paper.
07:58:30 <gremble> Can't you write it as sin ( cost pi/2) ?
07:58:38 <haasn> sin.cos $ pi/2 is probably the best compromise here
07:58:42 <JordiGH> Of course I can, I'm just whinging pointlessly about syntax.
07:58:47 <gremble> Oh
07:58:49 <haasn> gremble: cos pi/2 = (cos pi)/2 ≠ cos (pi/2)
07:59:05 <haasn> he probably wants the latter
07:59:08 <haasn> $ solves both problems
07:59:39 <gremble> Oh.
07:59:40 <gremble> TIL
08:00:20 <gremble> so $ defers the application of the composition, until pi/2 was evaluated? 
08:00:22 <gremble> I think
08:00:26 <OutlawStar> question: How do I Interpret this: "instance MonadState s (State s) where"? IE Is that a class with two type parameters or one, I'm confused because 's' is used twice.
08:01:46 <indiagreen> yes, it's a multiparameter type class
08:01:51 * hackagebot basic-prelude 0.3.13 - An enhanced core prelude; a common foundation for alternate preludes.  http://hackage.haskell.org/package/basic-prelude-0.3.13 (MichaelSnoyman)
08:01:58 <nshepperd> as the ancient greeks liked to say, "$ has the lowest precedence of all the operators, and will divide your expression in twain"
08:02:16 <haasn> gremble: Huh?
08:02:21 <indiagreen> it says that “State s” is a monad which gives you access to state s
08:02:22 <gremble> I have no idea
08:02:24 <OutlawStar> indiagreen: what is the type of s in this case then?
08:02:25 <haasn> gremble: ($) is a no-op
08:02:33 <haasn> gremble: f $ x = f x
08:02:48 <haasn> (also known as: ($) = id)
08:02:49 <indiagreen> s has no type, it's a type itself
08:03:06 <indiagreen> the definition of MonadState is “class Monad m => MonadState s m | m -> s”
08:03:16 <indiagreen> it says that:
08:03:22 <indiagreen> • m is a monad
08:03:22 <haasn> OutlawStar: do you understand how single-parameter type classes work?
08:03:30 <OutlawStar> hassn: yes
08:03:38 <indiagreen> • m gives you access to state of type s
08:03:46 <OutlawStar> i'm just confused because 's' is used twice
08:03:59 <OutlawStar> is 's' the same type in both cases?
08:04:08 <indiagreen> • and s depends on m (i.e. you can't get 2 different kinds of state from the same monad)
08:04:15 <indiagreen> </end of interruption>
08:04:37 <athan> crap, I broke haddock: http://hackage.haskell.org/package/nested-routes-0.3/docs/Web-Routes-Nested.html
08:04:56 <haasn> OutlawStar: class Monad m => MonadState s m | m -> s where modify :: (s -> s) -> m ()
08:05:19 <haasn> OutlawStar: The type of ‘modify’ needs access to the particular state ‘s’
08:05:31 <haasn> But ‘m’ is opaque - it could be any monad
08:05:37 <geekosaur> athan, haddock's known to be kinda dumb about that kind of thing
08:05:38 <haasn> (that has a State s nested inside it somewhere)
08:06:11 <haasn> OutlawStar: For example, you can write the “base case” instance: instance MonadState s (State s)
08:06:12 <athan> geekosaur: Shoot, I might tweak it a bit
08:06:29 <haasn> OutlawStar: but you can also write recursive instances on top of it. For example: instance MonadState s m => MonadState s (ReaderT r m)
08:06:41 <haasn> modify :: (s -> s) -> ReaderT r (State s ())
08:06:41 <Ferdirand> hello #haskell, why is (.) right-associative ? is it for performance when composing non-strict functions ?
08:06:42 <OutlawStar> hassn: so it might be "instance MonadState Foo (State Foo)
08:06:50 <Ferdirand> (sorry for interruption)
08:06:51 * hackagebot nested-routes 0.3 - Declarative, compositional Wai responses  http://hackage.haskell.org/package/nested-routes-0.3 (athanclark)
08:06:53 * hackagebot smallcheck-series 0.1 - Extra series for smallcheck  http://hackage.haskell.org/package/smallcheck-series-0.1 (jdnavarro)
08:07:10 <haasn> OutlawStar: yes, although the instance itself is polymorphic over the state. You can instantiate it at some particular type Foo, though
08:07:19 <geekosaur> the really funb part is that it treats e.g. handleLit and handleParse differently --- and neither one very well
08:08:26 <haasn> Ferdirand: There's probably some minor performance aspect to it, but the most theoretically fulfilling answer is probably going to be “because it can't be neither”
08:09:00 <haasn> Ferdirand: Another reason for why it may be the case is because mixing operators that associate differently can lead to parse errors
08:09:14 <haasn> So maybe (.) shares the precedence with something else. I don't remember any off the top of my head
08:09:16 <Ferdirand> actually, the question is more: is it still relevant with today's ghc ? (because i can see the difference when reducing by hand, but not sure how much of it can be optimized away)
08:09:51 <Clint> sm_: could you update the network bounds of rss2irc?
08:09:55 <haasn> Ferdirand: For stuff like f . g . h $ x, I'd be willing to guess that it won't make a difference because of inlining; for something like map (f . g . h) I have no idea
08:10:06 <haasn> Ferdirand: You could probably check the simplified core output that GHC provides to see for certain
08:10:58 <OutlawStar> haasn: this would not be valid, right? "instance MonadState Foo (State Bar) where"
08:11:00 <hodapp> does some idiom already exist for ((fmap f) . g)? It's kind of sort of <$> but not
08:11:49 <ion> What's wrong with fmap f . g?
08:11:51 * hackagebot stackage-curator 0.8.0 - Tools for curating Stackage bundles  http://hackage.haskell.org/package/stackage-curator-0.8.0 (MichaelSnoyman)
08:12:10 <hodapp> ion: I just like to use shorter idiomatic constructs if they exist.
08:12:11 <haasn> OutlawStar: That can actually be a legal instance, eg. if newtype Bar = Bar (Foo)
08:12:30 <hodapp> I have lost track of the number of times I wrote something longer out that ended up just being equivalent to <$> or <*>.
08:12:45 <indiagreen> haasn: I don't think it can, since we already have a more general instance
08:13:02 <haasn> indiagreen: OutlawStar: Yes, you would need to get rid of the polymorphic instance first (or use weird extensions)
08:13:07 <OutlawStar> haasn: ok, thx. I'm going think about this some more. This helps
08:13:17 <indiagreen> not even with weird extensions
08:13:18 <OutlawStar> indiagreen: thx as well
08:13:20 <indiagreen> there's a fundep
08:13:30 <haasn> indiagreen: ah, right
08:14:06 <hodapp> I also feel like (\x -> x arg) has some simpler form I just don't remember.
08:14:16 <haasn> hodapp: const arg
08:14:17 <exio4> ($ arg) 
08:14:18 <haasn> oh, no
08:14:22 <haasn> ($ arg) is right :)
08:14:26 <safinaskar> consider this parsec code: do { a; b; } <|> c. if a succeeds and b fails, then c will not be run. why? why parsec designed such way?
08:14:43 <johnw> safinaskar: um, why do you think that?
08:14:43 <hodapp> exio4 & haasn: thanks.
08:15:01 <johnw> also, I'm not sure about the precednce of 'do' there
08:15:02 <haasn> safinaskar: I think you may be misinterpreting the situation. If ‘a’ consumes input and then ‘b’ fails, then this input will not be rewound before attempting c
08:15:12 <johnw> does (do {a ; b ; }) <|> c mean the same thing?
08:15:16 <haasn> So ‘c’ will most likely fail too
08:15:19 <johnw> ah, he's asking about rewinding
08:15:21 <safinaskar> johnw: why do i think c will not be run? this is how parsec works. read docs. do experiment
08:15:23 <haasn> johnw: Very sure it does, because of { }
08:15:24 <johnw> in which case, surround the 'do' with 'try'
08:15:30 <exio4> Parsec doesn't do backtracing by default, 
08:15:38 <geekosaur> do doesn;t have precedence as such, but the braces delimit so yes
08:15:39 <johnw> and attoparsec *does* do backtracking by default
08:15:44 <johnw> which is confusing at times
08:15:48 <haasn> safinaskar: If ‘a’ consumes input, and you want to rewind this input if ‘b’ fails, then you need to use ‘try’
08:15:50 <kadoban> safinaskar: It's actually /not/ how parsec works.
08:15:54 <safinaskar> johnw: "mean the same think" - of course, yes :)
08:16:07 <haasn> eg. try (a >> b) -- or try a >> b
08:16:21 <exio4> I'd try to reduce the scope of 'try'
08:16:24 <OutlawStar> haasn: On your earlier example: "instance MonadState s m => MonadState s (ReaderT r m)" is something missing from that declaration? I'm confused about 'm' is there something that states it's type
08:16:27 <ion> safinaskar: Forgetting other backtracking branches whenever one consumes any input has a performance benefit.
08:16:39 <safinaskar> haasn: okey, thanks. so why this consumed input will not be placed back?
08:16:51 * hackagebot conduit 1.2.4.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.2.4.1 (MichaelSnoyman)
08:16:52 <KaneTW> OutlawStar: MonadState s m implies m is a Monad
08:16:55 <haasn> OutlawStar: ‘m’ can be any type. It's just important that it has a MonadState s m instance
08:17:35 <haasn> OutlawStar: maybe it would help to compare this to  ‘newtype ReaderT r m a’ + ‘instance Monad m => Monad (ReaderT r)’
08:17:50 <safinaskar> johnw: in which situations attoparsec's backtracking is confusing?
08:18:02 <OutlawStar> so in this case MonadState defines what m is thorugh its class definition??
08:18:26 <KaneTW> yeah
08:18:31 <OutlawStar> ok, thx
08:20:11 <safinaskar> ion: "has a performance benefit" - in what situations we need current behavior? i. e. let's assume we have do{a;b;}<|>c. why we may need to run a and then c?
08:20:28 <haasn> safinaskar: I'm not 100% sure; but I think something like do { keyword "foo"; parseInt } <> keyword "bar" when applied to "foo a" would produce something to the effect of “expected foo or bar” when it should actually say “expected int”
08:20:34 <haasn> if you backtrack after ‘foo’ fails
08:21:48 <Sven1986> Could anybody explain to me why the output for (\x->"nope!") [c | c <- "yes!"] is "nope!"? I don't understand the first part of the input. What does (\x->"nope!") do?
08:21:52 * hackagebot conduit-extra 1.1.7.3 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.7.3 (MichaelSnoyman)
08:21:57 <safinaskar> if "b" fails then we run "c" and assume that "a" was parformed. so "do{a;b;}<|>c is equivalent to do{a;b<|>c;}<|>c, right?
08:22:18 <haasn> Sven1986: (\x -> foo) is a function that ignores its input x and always returns foo
08:22:45 <haasn> Sven1986: So if you apply (\x -> "nope!") L  where L is your list, it gets evaluated to just "nope!"
08:25:43 <safinaskar> haasn: i disagree here. do { keyword "foo"; parseInt } <|> keyword "bar" should work as i said (i. e. as if we place "try" everywhere) and still should give right error message (i. e. expected int). moreover, the following code: do{kwd"foo";int;}<|>do{kwd"foo";double;}<|>kwd"bar" should give error "expected int or double" on input "foo foo"
08:25:57 <Sven1986> haasn: Thanks!
08:26:38 <haasn> safinaskar: What actually happens (in parsec)?
08:26:42 <haasn> Would be interesting to know
08:28:17 <MagneticDuck> how do I make cabal manage, say, resource files?
08:28:22 <MagneticDuck> that I want to use at runtime?
08:28:34 <MagneticDuck> this is a problem I've had for a while
08:28:37 <MagneticDuck> google is silent here
08:28:50 <kadoban> safinaskar: That doesn't seem to make any sense to me. Are you sure that's what should even conceivably happen?
08:29:25 <KaneTW> MagneticDuck: data-files:
08:29:32 <KaneTW> i think
08:29:47 <MagneticDuck> and how do I access them?
08:30:12 <KaneTW> https://www.haskell.org/cabal/users-guide/developing-packages.html#accessing-data-files-from-package-code
08:30:32 <kadoban> safinaskar: In short … parsec doesn't work that way. You might hope it does, but it doesn't. I … don't think it even /could/ work that way, but regardless it doesn't.
08:35:20 <safinaskar> haasn: "What actually happens (in parsec)?" - i think it just says "int expected". you can do experiment
08:36:17 <safinaskar> kadoban: "any sense to me" - this is not how parsec works. this is how i want it to work. my question is why it doesn't work as i want? :)
08:36:52 * hackagebot uri-bytestring 0.1 - Haskell URI parsing as ByteStrings  http://hackage.haskell.org/package/uri-bytestring-0.1 (MichaelXavier)
08:37:13 <Elite6809> > :pointfree
08:37:15 <lambdabot>  <hint>:1:1: parse error on input ‘:’
08:37:29 <mniip> Elite6809, you're looking for @pl
08:37:34 <Elite6809> sweet thanks
08:37:57 <mniip> without the >
08:38:10 <Elite6809> @pl f x = [toLower x, 'o', x]
08:38:10 <lambdabot> f = liftM2 (:) toLower (('o' :) . return)
08:40:15 <Elite6809> @pl f x = if isDigit x then ' ' else x
08:40:15 <lambdabot> f = flip if' ' ' =<< isDigit
08:40:45 <kadoban> safinaskar: Well, in your last one … it'd have to do backtracking that it doesn't do for performance reasons (unless you tell it to). It'd also have to recognize that both branches parse the same "foo" first, which for something so trivial isn't that hard, but in general is pretty expensive and annoying.
08:42:11 <MagneticDuck> KaneTW: I'm having some trouble using that feature
08:42:19 <MagneticDuck> I put Paths_whclan_bot into other-modules
08:42:26 <ion> We should teach @pl about bool.
08:42:30 <MagneticDuck> but I can't seem to import Paths_whclan_bot anywhere
08:42:50 <MagneticDuck> just "could not find module"
08:42:58 <safinaskar> parsec CAN work as i said!! i just tried the following code:
08:42:59 <safinaskar> runParser (try(do{kwd"foo";n;return ();})<|>try(do{kwd"foo";i;return ();})<|>do{kwd"bar";return ();}) () "-" "foo "
08:43:19 <safinaskar> and parsec said "expecting natural or identifier" just as i want!
08:43:34 <safinaskar> (here kwd, i and n are reserved, identifier and natural)
08:44:12 <safinaskar> so, why i need "try" here? why not make this default parsec behavior?
08:44:16 <kadoban> safinaskar: That's if you explicitly tell it you want to do something potentially really expensive.
08:46:01 <MagneticDuck> can anybody help me figure out what's going on with cabal not doing the Path_pkgname and getDataFileName stuff in my project?
08:46:03 <MagneticDuck> https://github.com/WH-Admins/whclan-bot
08:46:53 * hackagebot language-puppet 1.1.1.1 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-1.1.1.1 (SimonMarechal)
08:48:14 <safinaskar> kadoban: what is this backtracking? why it is so heavy? i don't see any performance penalty here. we just need to try another branch. we don't need to "undo" anything, because haskell is pure functional language. we don't need to restore "previous" state, because we already have it, it is not gone
08:48:50 <safinaskar> kadoban: and why parsec should recognize we parse same "foo"? it should not. it should just try one branch, then another etc
08:48:53 <woddy> how common is haskell in commercial embedded systems?
08:50:17 <johnw> woddy: not sure how to give any kind of meaningful answer to that
08:50:19 <kadoban> safinaskar: If it's not the same prefix, then the error message would make /no/ sense. It's heavy because haskell has to keep around the prefix it's parsing until it can't be bracktracked to anymore.
08:50:21 <johnw> it's common among those who use it
08:50:24 <hodapp> woddy: I'm using it for code generation there.
08:51:13 <hodapp> but most questions that start with 'how common' don't have meaningful answers.
08:51:15 <Elite6809> @pl f g = g . g
08:51:15 <lambdabot> f = join (.)
08:51:23 <woddy> hodapp, no statistics?
08:51:26 <woddy> or anecdotal evidence
08:51:29 <woddy> "used on a space probe"
08:51:29 <woddy> etc.
08:51:30 <woddy> :D
08:52:01 <stoopkid> ok.. i've read quite a number of articles on monads and IO and i'm still having trouble getting it
08:52:13 <hodapp> woddy: I'm not really sure why you'd even need or want statistics on that.
08:52:15 <shapr> woddy: I know Haskell is used to make garbage trucks work
08:52:26 <woddy> shapr, ok
08:52:31 <shapr> woddy: Galois uses it for embedded systems of some sort
08:52:52 <shapr> I know Galois produced Copilot and some other libraries for embedded Haskell
08:53:01 <stoopkid> woddy, people use it for web, that's what i'm trying to learn how to do now
08:53:19 <shapr> woddy: there's the #haskell-embedded channel if you have question about specific uses
08:53:56 <Elite6809> @pl f k = [k]
08:53:56 <lambdabot> f = return
08:54:07 <mniip> or you could say (:[])
08:54:19 <jle`> ocharles_: thanks :)
08:54:23 <bartavelle> is there something faster than Data.Attoparsec.Zepto that will let me write readable code ?
08:54:34 <Elite6809> mniip: good point, thanks
08:54:37 <ion> stoopkid: Have you read the Typeclassopedia?
08:54:38 <ocharles_> jle`: huh? what'd i do :)
08:54:53 <safinaskar> kadoban: well, okey, we should determine whatever this is same prefix to make good error message. but let's imagine we should not give message, we just should return result or "Nothing".   "to keep around the prefix" - what is wrong with just keeping string in memory?
08:55:12 <c_wraith> stoopkid: here's the thing.  You don't need to understand monads to understand IO.  Trying to learn about both at the same time only gets in the way.
08:55:53 <ion> Also what c_wraith said.
08:56:12 <jle`> ocharles_: oh sorry, i oc<tab>'d.  gotta stop with the reckless tabbing
08:56:21 <ocharles_> aw, I thought I did good
08:56:28 <jle`> in any case i'm sure i have some reason to thank you :p
08:56:30 <ocharles_> haha
08:56:31 * shapr hugs ocharles_ 
08:56:43 <jle`> your serialization-deserialization category post was a nice read :3
08:57:05 <c_wraith> stoopkid: so do you want to know how to do IO?  It's the easier one to learn, since it's nice and concrete.  Monads are so super-abstract that it's easy to think there must be more to them. (There isn't. Monads are very abstract, but also pretty minimal)
08:57:18 <kadoban> safinaskar: Memory is a finite resource. Parsec can parse more than just toy strings. You could be lazily reading it from the network, from a file, from anywhere, or just creating it programatically. It could be infinite.
08:57:43 <c_wraith> jle`: did you ever come to a conclusion about using the rank-2 trick to mark which autos can and can't be serialized?
08:57:51 <stoopkid> c_wraith, well, i want to learn both ultimately, i have a somewhat better grasp of IO, at least.. i can make some basic things work with it even without knowing what's going on really
08:58:04 <kadoban> stoopkid: Did you finish cis194 yet? Ideally, did you do it more in-depth than you said you did before?
08:58:33 <c_wraith> stoopkid: believe it or not, that's an important step along the way.  Being able to use IO is building familiarity with the thing you will eventually abstract over.
08:58:34 <stoopkid> kadoban, yea i went through their examples and now i'm stuck on monads
08:58:59 <jle`> c_wraith: i think i decide that i didn't want serialization to be an all-or-nothing thing.  having something specified as "non-serializable" using the trick didn't say much about what portions were serialized or unserialized, so i think an all-or-nothing flag is probably going to convey information that might not always be meaningful
08:59:09 <jle`> but it was a great idea though and i might end up using a variation :)
08:59:10 <kadoban> stoopkid: Also consider doing NICTA, it will give you a better base to work with typeclasses and etc. What do you mean you "went through their examples"? That kinda sounds like you skimmed it?
08:59:11 <jle`> thanks :)
08:59:25 <stoopkid> kadoban, the homework lessons
08:59:58 <ocharles_> jle`: yea, that was good fun
09:00:00 <hodapp> hmmm... I have some record types that have (Maybe foo) fields, where 'foo' is some other record type that behaves in similar ways
09:00:04 <c_wraith> stoopkid: all monads do is abstract over a pattern of composition. It's just the type signatures that make it look opaque.
09:00:31 <c_wraith> jle`: you wrote the "my own world" article, right?
09:00:44 <hodapp> and I'm finding it a bit clumsy to do operations that collect everything into, say, [String], following a 'Maybe' if possible
09:00:58 <hodapp> is this a candidate for Foldable? Traversable?
09:01:04 <L29Ah> how do i push a fix to an orphan package on hackage?
09:01:05 <kadoban> stoopkid: Yes … what I'm saying is, did you actually read all of it and do the homework, or did you just kind of skim through? Last time I remember we chatted, you seemed a bit fuzzy on some of the stuff even covered by cis194, which is itself a /very/ quick introduction to haskell when used alone.
09:01:15 <stoopkid> c_wraith, and this is what i'm having trouble with because when i go beyond little exercise problems and start trying to look at packages to do more complex things, all of a sudden i'm lost in types that i don't understand
09:01:36 <mniip> that's how haskell works
09:01:37 <stoopkid> kadoban, i went through it much more thoroughly but once it gets up to monads i kind of get lost
09:01:40 <c_wraith> stoopkid: you need to just practice to get past that point.  Take the advice from the others about doing coursework. :)
09:01:47 <stoopkid> kadoban, and did the homework problems, like coding them
09:02:06 <safinaskar> kadoban: okey. consider do{a;b}<|>c again. let's imagine "b" failed". why we run "c" at all? why not we report error immidiately?
09:02:22 <stoopkid> i'm reading that typeclassopedia article on it now
09:02:24 <MagneticDuck> https://github.com/WH-Admins/whclan-bot/blob/master/whclan-bot.cabal
09:02:27 <MagneticDuck> can somebody help me understand
09:02:41 <kadoban> stoopkid: Ah, good. So you're on week 12 then? Is there a specific part you're not understanding, or part of the homework you're not getting?
09:02:44 <MagneticDuck> why when I try to use the Paths_whclan_bot in a module, cabal says it's not in scope?
09:02:55 <MagneticDuck> isn't it supposed to generate a module with exactly that name?
09:03:29 <stoopkid> kadoban, i'm not even sure, it's like i just keep reading through it and it's just not really fully clicking
09:03:41 <stoopkid> kadoban, let me see if i have some specific questions after i read through this typeclassopedia article
09:04:08 <phaazon> dammit, my haddock doesn’t generate documentation with -- ^ in my code :(
09:04:12 <phaazon> is it a bug?
09:04:16 <Elite6809> @pl ai c f = if c then f else id
09:04:16 <lambdabot> ai = flip flip id . if'
09:04:32 <kadoban> stoopkid: Did Applicative and Functor make sense yet? You might be expecting … something more profound to be in Monad than it actually is. It's built up a lot, but in actuality it's not much more than Applicative. It's just (>>=) and return and some sugar if you want to use the sugar.
09:04:47 <shapr> kadoban: that certainly happened to me
09:04:52 <stoopkid> this is a useful diagram i hadn't found yet: https://wiki.haskell.org/File:Typeclassopedia-diagram.png
09:04:59 <shapr> I thought Monad would be far more profound... but it's more like "oh, that's all?"
09:04:59 <bernalex> Elite6809: that's bool with id
09:05:11 <kadoban> stoopkid: I know that was my problem for a while. I kept expecting there to be … more. Eventually I realized I understood it, I just figured I was missing something that … didn't actually exist.
09:05:27 <stoopkid> kadoban, i'm still kind of hazy on applicative and functor as well
09:06:03 <stoopkid> kadoban, really once it starts to get more into the abstract-algebraic-y type stuff
09:06:16 <kadoban> safinaskar: Sorry, I've kind of reached my limit with interest in how it works. Someone else might want to continue the conversation of course.
09:06:24 <hiptobecubic> shapr, indeed
09:06:48 <hiptobecubic> Especially after I asked about it in here and got a very long and thorough explanation about kleisli and so on
09:06:54 <kadoban> stoopkid: Well … you don't really need to know any of that. Category theory is just kind of … where the names came from. From a practical programming perspective, you can just use the things and not really care.
09:07:00 <bernalex> Elite6809: i.e. ai c f = bool c id f -- i.e. ai = flip bool id
09:07:02 <shapr> I had to look at a bunch of monad instances before I realized that's a simple and useful convention with sane and decent laws
09:07:36 <stoopkid> kadoban, lol i have a difficult time doing that, i'm always wondering what every little thing is doing
09:07:40 <ion> @type foldMap toList
09:07:41 <lambdabot> (IsList l, Foldable t) => t l -> [Item l]
09:07:44 <tromp> shapr: it couldn't be profound if it wasn't simple:)
09:07:55 <kadoban> stoopkid: That said, typeclassopedia is great, and NICTA will probably help you I suspect. It's hard, but it'll make a lot of the Functor/Applicative/Monad stuff way more concrete.
09:07:58 <bernalex> shapr: hallo :)
09:07:59 <shapr> hoi tromp! How's life treating you?
09:08:02 <shapr> howdy bernalex!
09:08:23 <shapr> tromp: I ran across your name in the ioccc recently :-)
09:08:30 <Elite6809> bernalex: thanks for the help
09:08:31 <tromp> very well, shapr! happily computing the #go positions
09:08:35 <kadoban> stoopkid: Well that's the thing, you can know /exactly/ what it's doing without knowing /any/ category theory. The category theory I know is pretty much … random terms I heard in here listening to smarter people talk, heh.
09:08:36 <Elite6809> I'm seeing how far I can go, points-free
09:08:47 <hiptobecubic> stoopkid, for me, it clicked when i realized that the type of fmap doesn't even *know* what the 'f' in 'f a' is.
09:08:55 <tromp> my ioccc entry was from 2012; not that recent:(
09:08:55 <hiptobecubic> @type fmap
09:08:56 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:09:10 <ion> @type foldMap F.toList  -- hodapp
09:09:11 <shapr> tromp: oh hey, do you remember our discussion about homomorphic computing? (mind you, it was roughly 10 years ago)
09:09:11 <lambdabot> (Foldable t, Foldable t1) => t (t1 a) -> [a]
09:09:18 <safinaskar> kadoban: "I've kind of reached my limit" - :)))) good answer
09:09:27 <tromp> sorry; my memory is not that good:(
09:09:49 <kadoban> safinaskar: :) Sorry, don't mean that to be rude, just figured I'd say instead of leaving you waiting for an answer …
09:09:50 <hodapp> ion: what about it?
09:09:59 <shapr> tromp: ah well, I'll ping you about that discussion sometime
09:10:04 <safinaskar> kadoban: ok, ok
09:10:19 <hiptobecubic> stoopkid, so 'f a' is some type which is an 'f' applied to 'a'. fmap takes something that turns a's to b's and does literally the only thing it could possible do with the 'f a' to make it into an 'f b'.
09:10:39 <hodapp> ion: what I'm trying to guess at is whether this is a case where I should be deriving from Foldable for my variety of record types
09:10:41 <tromp> shapr: i also dabbled in bitcoin research recently
09:10:41 <shapr> tromp: still cool to see your name in the ioccc winners from any year :-)
09:10:52 <hiptobecubic> namely, applies the function.
09:10:54 <shapr> tromp: oh neat! Anything online about what you've discovered?
09:11:11 * shapr checks tromp's webpage
09:11:15 <tromp> shapr: my winners are at age 23 and 46. will have to prepare something at 69 i guess:)
09:11:28 <ion> hodapp: It sounded like you want to flatten Maybe (Foo a) into [a]. I may have misunderstood.
09:11:41 <kadoban> tromp: Or 92 :)
09:12:10 <hodapp> ion: what I'm needing to flatten is a variety of things that may or may not be wrapped in a Maybe
09:12:34 <hodapp> they form a tree structure, but a heterogeneously-typed one
09:12:39 <stoopkid> hiptobecubic, so fmap :: (Functor f) => (a->b) -> f a -> f b, takes an (a->b) and an (f a) and returns an (f b)
09:13:01 <tromp> kadoban: i expect to be too busy hanging on for dear life then:)
09:13:11 <kadoban> Haha, possibly
09:13:13 <shapr> tromp: I'll be in boston in a coupla weeks, but without a car, so I probably won't visit you :-P
09:13:44 <tromp> shapr: where are you now?
09:13:44 <kadoban> stoopkid: Yes. Or alternatively, it takes an (a -> b) and makes it into a (f a -> f b)
09:14:00 <hodapp> I suppose I may in some cases need to preserve structure, but Traversable implies Foldable anyhow so I suppose I'll need that either way
09:14:12 <shapr> tromp: I've been in Alabama the past few years, Huntsville at the moment
09:14:20 <stoopkid> kadoban, hm, yea that makes sense to me, i'm having trouble interpreting it from the other perpsective though
09:14:55 <kadoban> stoopkid: Which one makes sense to you? Maybe I can explain/demonstrate the other
09:15:01 <tromp> shapr: did your work take you there?
09:15:32 <shapr> tromp: sort of, I usually decide to move somewhere and then find a job.. but hey, I finally got an undergrad degree just over a year ago!
09:15:43 <stoopkid> kadoban, takes an (a -> b) and makes it into an (f a -> f b), that's how i think of fmap. i don't completely understand the interpretation of taking an (a->b) and an (f a) and turning it into an (f b)
09:16:16 <tromp> shapr: gratz on the degree!
09:16:46 <kadoban> stoopkid: Well, it's pretty much just the … less abstract meaning. So if you have    fmap blah arg     it transforms the "blah" to (f a -> f b), and then it applies the arg to the transformed function
09:16:52 <oconnore> stoopkid: I think currying would help there. Like how (+) is Int -> Int -> Int, but if you do :t (+ 5) in ghci, you get Int -> Int. Then (+ 5) 3 => 8
09:17:40 <oconnore> generally you have a function x :: a -> b -> c, then (x a) :: b -> c
09:18:08 <kadoban> > fmap (+1) (Just 5) -- like that
09:18:10 <lambdabot>  Just 6
09:18:47 <stoopkid> Just 5 = f a; Just 6 = f b?
09:18:49 <kadoban> So 'fmap (+1)'   gives you a function that   adds 1 to the thing in a Just. Then you give it a Just 5, and it … applies the function
09:19:04 <kadoban> stoopkid: Yep, exactly
09:19:14 <saml> what extensions do you use very often?
09:19:18 <saml> GeneralizedNewtypeDeriving ?
09:19:21 <stoopkid> but, i thought (+1) is f
09:19:39 <ion> (+1) is the a -> b
09:19:45 <kadoban> stoopkid: f isn't the function, it's the Functor instance. It's Maybe
09:20:13 <stoopkid> kadoban, aha, this is where i'm getting confused, i'm not sure what that means exactly
09:20:42 <bernalex> stoopkid: I think the by far most used extension I see in use is OverloadedStrings. it's followed by GADTs.
09:22:34 <nshepperd> statistically, it looks like I use BangPatterns the most (#boringanswer)
09:22:36 <kadoban> stoopkid: Remember that the type level and the value level are different things, and also that … type variables are arbitrary.   fmap :: (Functor z) => (q -> o) -> z q -> z o     is completely the same thing  as   fmap :: (Functor f) => (a -> b) -> f a -> f b   .     When you're defining the actual fmap instance for something like Maybe, you could use 'f' in it, like   fmap f a = /something here/, but those 'f' and 'a' are /not/ the same thing 
09:22:37 <kadoban> as the f and the a in the type signature.
09:22:53 <MagneticDuck> does anybody here have experience using the "data-file" field in a cabal project?
09:23:02 <MagneticDuck> feild*
09:23:15 <MagneticDuck> *field
09:23:39 <athan> saml: I love ConstraintKinds
09:24:06 <bernalex> MagneticDuck: yes
09:24:21 <MagneticDuck> bernalex: okay
09:24:26 <stoopkid> kadoban, right, okay so in fmap f a: the "f" here is (a->b) from the type signature and "a" is really (f a) from the type signature
09:24:32 <MagneticDuck> I'm having trouble using the Paths_pkgname module that it generates
09:24:37 <MagneticDuck> https://github.com/WH-Admins/whclan-bot/blob/master/whclan-bot.cabal on github
09:24:43 <johnw> stoopkid: 'f a' maps from some 'a' to a type you don't know about (i.e., a family of types).  'fmap' takes a function a -> b and maps it to a function that takes every 'a' in the mapped type to 'b', so 'f a' to 'f b'.  What's cool about this is that 'f' can be a lot of things (it could be as odd as 'Const c', for example), but the *meaning* of fmap is the same for all of them.
09:24:54 <bernalex> MagneticDuck: see https://github.com/alexander-b/hsay/tree/master/src-exec
09:25:03 <bernalex> MagneticDuck: uh I mean https://github.com/alexander-b/hsay/blob/master/src-exec/hsay.hs
09:25:03 <MagneticDuck> oh wait I believe this might be a typo
09:25:37 <MagneticDuck> bernalex: okay thanks
09:25:39 <kadoban> stoopkid: The "f" is   fmap f a  is of /type/ (a -> b). It's just a binding though, it just has that type. It's not a synonym for (a -> b) or anything, any more than 5 :: Int. 5 just has type Int
09:25:42 <MagneticDuck> actually, my problem was a typo
09:25:44 <bernalex> MagneticDuck: OK. I don't have time to look at your stuff right now (going to make dinner). hope you figure it out. I use data-files in that github repo I linked -- & the program is super trivial, so I hope it's an useful example.
09:25:46 <bernalex> MagneticDuck: great.
09:25:54 <kadoban> stoopkid: Not that you implied otherwise, just being … as explicit as I can, because this gets confusing otherwise.
09:26:00 <stoopkid> kadoban, right
09:26:42 <stoopkid> kadoban, so in fmap f a, f :: (a -> b), a :: f a (using the same type signature we've been using)
09:27:50 <kadoban> stoopkid: Yep. actually    a :: (Functor g) => g a .   Where there I'm just using g instead of f to avoid confusion
09:28:30 <rudi_s> Hi. I'm looking for a xterm or vt100 terminal emulator library (e.g. parsing the ansi movements/commands and generating a "virtual" image of the terminal). Any ideas?
09:29:13 <oconnore> stoopkid: so for Maybe, fmap is very simple =>  let myMaybeFmap = \functionOnA aMaybeValue -> if isJust aMaybeValue then (Just $ functionOnA (fromJust aMaybeValue)) else Nothing
09:29:24 <oconnore> stoopkid: the type is myMaybeFmap :: (a -> s) -> Maybe a -> Maybe s
09:29:29 <irishsultan>  
09:29:33 <oconnore> stoopkid: compare with fmap :: Functor f => (a -> b) -> f a -> f b
09:29:33 <johnw> rudi_s: https://github.com/lordi/haskell-terminal?
09:29:38 <mniip> oconnore, that's a terrible definition
09:29:44 <oconnore> mniip: yes
09:29:52 <johnw> rudi_s: http://batterseapower.github.io/ansi-terminal/?
09:29:53 <mniip> fmap f Nothing = Nothing; fmap f (Just x) = Just (f x)
09:30:08 <oconnore> mniip: but it's easy to understand
09:30:16 <mniip> not so sure about that
09:31:02 <rudi_s> johnw: Like haskell-terminal. I was just curious if anybody is using it or knows different packages. haskell-terminal seems to be dead (at the moment).
09:31:36 <oconnore> mniip: my goal was to show the "unpacking" and "repacking" step explicitly, aka, actually using fromJust and Just
09:32:12 <mniip> I'm not sure that's a good idea
09:32:34 <oconnore> mniip: when you're trying to explain that fmap "unpacks" and "re-packs"?
09:32:37 <mniip> I mean, packing and unpacking only makes sense for 'data F x = T x | ...'
09:33:00 <kadoban> I suspect that just using pattern matching is just plain clearer to everyone, even beginners. If not, they should understand that before Functor anyway.
09:40:54 <stoopkid> "From the container point of view, the intention is that fmap applies a function to each element of a container, without altering the structure of the container. From the context point of view, the intention is that fmap applies a function to a value without altering its context."
09:40:58 <oconnore> mniip: huh? When does fmap not unpack a value (f a) into a, pass it through (a -> b), and then re-pack into into f b?
09:41:19 <mniip> 'unpack' is not a good word
09:41:23 <stoopkid> i see, this intuition is what i was lacking
09:41:33 <oconnore> mniip: why?
09:41:38 <mniip> doesn't make much sense if f is Pair, [], or ((->) r)
09:41:47 <stoopkid> it maintains the structure of the f, which is a type constructor, which takes another type as argument and outputs a concrete type
09:41:57 <stoopkid> so this could be Maybe, or List
09:42:00 <stoopkid> or IO
09:42:30 <kadoban> oconnore: That doesn't sound like the definition of fmap for [], for instance.
09:43:04 <stoopkid> so i guess can one do the following: fmap (+1) x , x :: IO Int ?
09:43:05 <mniip> fmap applies the function to a wrapped value
09:43:28 <kadoban> stoopkid: Yeah, definitely.
09:44:29 <oconnore> mniip: I guess I don't understand your holdup about "packed/unpacked", especially when you're replacing it with "wrapped"
09:44:36 <oconnore> mniip: would "unwrapped" be better?
09:44:49 <stoopkid> can i do fmap (+1) x, x :: Int, or does it need a container, like IO Int, Maybe Int, [Int], etc
09:44:56 <oconnore> to me packed and wrapped are both things I do to christmas presents
09:45:18 <kadoban> stoopkid: It needs a Functor, yeah.
09:46:23 <stoopkid> so a Functor and type constructor are the same thing?
09:46:55 * hackagebot CouchDB 1.2.1 - CouchDB interface  http://hackage.haskell.org/package/CouchDB-1.2.1 (SimonMichael)
09:47:12 <ion> stoopkid: “fmap :: (a -> b) -> F a -> F b” where you (need to) pick an “F”.
09:47:15 <kadoban> stoopkid: No. Some things of kind * -> * are Functors. Functors are just … things someone wrote a Functor instance for. There isn't a Functor instance for everything that looks like those
09:47:18 <glguy> A function is a type with kind * -> * and a function for lifting functions into functions on that type
09:47:40 <glguy> A Functor is a *
09:47:50 <mniip> oconnore, consider the ((->) r) functor
09:47:56 <mniip> how do you 'unpack' it
09:48:13 <hiptobecubic> tromp, that ioccc entry is downright beastly
09:48:20 <stoopkid> glguy, *head explodes*
09:48:28 <kadoban> :k Maybe  -- glguy ?
09:48:29 <lambdabot> * -> *
09:48:42 <tromp> thx, hiptobecubic
09:48:49 <hiptobecubic> tromp, how long did you spend on it?
09:49:22 <tromp> my research into tiny universal machines dates back over  a decade
09:49:25 <glguy> kadoban: Yeah, there's a Functor instance for Maybe
09:49:27 <stoopkid> ":k" is "get kind" command?
09:49:38 <stoopkid> :k Functor
09:49:39 <lambdabot> (* -> *) -> Constraint
09:49:48 <kadoban> glguy: The reason I asked lambdabot that is because "<glguy> A Functor is a *"
09:49:56 <glguy> kadoban: Yeah, that was a correction to the line above
09:50:04 <kadoban> Ohh
09:50:06 <tromp> but the C implementation took maybe 4 months
09:50:07 <glguy> that unfortunately collided with the syntax for kinds
09:50:07 <nshepperd> glguy: that was a confusing correction :p
09:50:16 <glguy> people learn
09:50:31 <stoopkid> glguy, haha i see
09:50:34 <kadoban> stoopkid: Yeah, :k is "what's the kind of this?"
09:50:57 <stoopkid> glguy, i was like "a Functor is a * now?" *head explodes*
09:53:49 <seanhess> Is there anything like mapConccurently from async, except it only allows N actions to be running at once?
09:54:46 <ion> seanhess: async-extras perhaps
09:56:03 <stoopkid> "the list functor represents a *context* of nondeterministic choice;" and "Likewise, the Maybe functor represents a *context* with possible failure"
09:56:18 <seanhess> ion: cool, that'll help. thanks!
09:56:29 <narendraj9> 1/go #fp
09:56:36 <stoopkid> i'm trying to get a more concrete handle on this concept of *context* that they're using here
09:57:38 <hiptobecubic> narendraj9, weechat? 
09:58:01 <mniip> stoopkid, context is when you have a value but there's more to it
09:58:22 <mniip> Int is a number, [Int] is a number with a context that there are actually multiple numbers
09:58:22 <kadoban> stoopkid: It's kind of like a computational context. List's Functor instance lets you calculate in the context of nondeterministic choice (i.e. it tries every choice)
09:59:27 <stoopkid> Monad is a type of Functor according to the diagram
09:59:40 <narendraj9> hiptobecubic: Yes. Sorry. :D
09:59:59 <mniip> stoopkid, eh? Monad is a typeclass just like Functor
10:00:07 <kadoban> stoopkid: Yep. That means every Monad is a Functor, and Monads have more stuff you can do.
10:00:09 <mniip> with the AMP proposal, Monad is a subtypeclass of Functor in fact
10:00:19 <stoopkid> mniip, that's what i was about to ask
10:00:28 <stoopkid> ok cool just making sure i got that
10:00:46 <stoopkid> so then Monad instances specify a context as well?
10:00:57 <stoopkid> like a do{} context, or an IO context?
10:01:04 <stoopkid> or.. IO is another typeclass
10:01:11 <stoopkid> it is
10:01:23 <stoopkid> IO is a subtypeclass of Monad?
10:01:37 <stoopkid> with again, more things to do?
10:01:39 <ion> IO is an instance of the type classes Functor, Applicative and Monad.
10:01:46 <stoopkid> oh
10:02:07 <haasn> Haskell is not object-oriented :)
10:02:12 <haasn> Not everything is a class
10:02:45 <ion> I’m not sure the “computational context” explanation is very helpful. It’s just using another abstract thing to explain an abstract thing.
10:03:15 <stoopkid> ah, IO is an instance of a Monad, like "Maybe" is an instance of a Functor
10:03:24 <stoopkid> instance of Monad*
10:03:31 <stoopkid> (IO that is)
10:03:34 <ion> IO and Maybe are both instances of Monad and Functor.
10:03:42 <stoopkid> gotcha
10:04:00 <MagneticDuck> randomRIO is so not random >____>
10:04:09 <MagneticDuck> *randomIO in general
10:04:31 <stoopkid> so by being instances of Monad they are automatically instances of Functor because Monad < Applicative < Functor, where "<" is "subtypeclass of" ?
10:04:37 <ion> MagneticDuck: It doesn’t claim to be anything other than a pseudorandom generator, does it?
10:04:48 <MagneticDuck> ion: but it's like, really bad
10:04:56 <MagneticDuck> probably has to do with how it's maintaining the seed
10:05:10 <ion> stoopkid: Correct.
10:07:49 <haasn> (Although defining an instance Monad will also require you to define an instance Functor)
10:07:56 <mniip> stoopkid, no
10:08:08 <mniip> it's that they can't be instances of Monad until they are instances of Functor and Applicative
10:08:14 <ion> Oh, i may have misinterpreted what he was asking.
10:08:41 <haasn> Yes, but if you have an instance Monad of something (eg. from a constraint), you also automatically have an instance Functor for that thing
10:08:57 <mniip> well yes
10:09:09 <mniip> and you can represent fmap with return and >>=
10:09:13 <haasn> It's important to be careful with your words here :)
10:09:40 <haasn> Yes, the point that ‘Functor+Monad’ is redundant is the reason why Functor was made a superclass of Monad
10:09:40 <stoopkid> haasn, yea that's what i meant (i think)
10:09:54 <mniip> @let data F x
10:09:55 <lambdabot>  .L.hs:191:1:
10:09:55 <lambdabot>      Multiple declarations of ‘F’
10:09:55 <lambdabot>      Declared at: .L.hs:189:1
10:09:58 <mniip> :/
10:10:04 <mniip> @let data T x
10:10:05 <lambdabot>  .L.hs:191:1:
10:10:05 <lambdabot>      Multiple declarations of ‘T’
10:10:05 <lambdabot>      Declared at: .L.hs:175:1
10:10:08 <mniip> oh come on
10:10:09 <ion> @undefine
10:10:09 <lambdabot> Undefined.
10:10:11 <ion> @let data F x
10:10:12 <lambdabot>  Defined.
10:10:17 <mniip> @let instance Monad F
10:10:18 <lambdabot>  .L.hs:144:10:
10:10:19 <lambdabot>      No instance for (Applicative F)
10:10:19 <lambdabot>        arising from the superclasses of an instance declaration
10:10:23 <mniip> that's the error you get
10:10:28 <stoopkid> ah
10:10:36 <stoopkid> @let instance Applicative F
10:10:37 <lambdabot>  .L.hs:144:10:
10:10:38 <lambdabot>      No instance for (Functor F)
10:10:38 <lambdabot>        arising from the superclasses of an instance declaration
10:10:44 <stoopkid> @let instance Functor F
10:10:45 <lambdabot>  .L.hs:144:10: Warning:
10:10:45 <lambdabot>      No explicit implementation for
10:10:45 <lambdabot>        ‘fmap’
10:10:55 <stoopkid> i see
10:11:11 <stoopkid> @let instance Applicative F
10:11:12 <lambdabot>  .L.hs:144:10:
10:11:12 <lambdabot>      No instance for (Functor F)
10:11:12 <lambdabot>        arising from the superclasses of an instance declaration
10:11:14 <StoneToad> I kinda wish you could define a generic functor and applicative instance for anything that was a monad
10:11:25 <StoneToad> just syntax sugar in a way really
10:11:29 <arkeet> yes it's not very automatic.
10:11:30 <stoopkid> well how come that didn't work
10:11:56 <kadoban> stoopkid: It would have in real life, I'm not sure in lambdabot.
10:12:03 <stoopkid> kadoban, ah i see
10:12:09 <StoneToad> well, you need to define fmap for the functor...
10:12:15 <kadoban> (Although in practice you'd have to actually define fmap)
10:12:18 <stoopkid> good to know to always take lambdabot with a grain of salt
10:12:22 <ion> Try /query lambdabot @let instance Functor F
10:12:22 <stoopkid> kadoban, yea i saw that warning
10:12:28 <ion> It uses -Werror
10:12:34 <kadoban> Ohh
10:12:59 <stoopkid> ah ha, i see
10:13:22 <mniip> @let instance Functor F where fmap = undefined
10:13:27 <lambdabot>  Defined.
10:13:32 <stoopkid> thank you
10:13:43 <stoopkid> @let instance Applicative F
10:13:44 <lambdabot>  .L.hs:144:10: Warning:
10:13:44 <lambdabot>      No explicit implementation for
10:13:44 <lambdabot>        ‘fmap’
10:13:52 <StoneToad> o_O
10:13:55 <stoopkid> well
10:13:59 <kadoban> Wat
10:14:01 <mniip> that's weird
10:14:17 <stoopkid> @let instance Monad F where fmap = undefined
10:14:18 <lambdabot>  .L.hs:147:9: ‘fmap’ is not a (visible) method of class ‘Monad’
10:14:28 <stoopkid> @let instance Applicative F where fmap = undefined
10:14:29 <lambdabot>  .L.hs:147:9:
10:14:29 <lambdabot>      ‘fmap’ is not a (visible) method of class ‘Applicative’
10:14:37 <stoopkid> @let instance Applicative F
10:14:38 <lambdabot>  .L.hs:144:10: Warning:
10:14:38 <lambdabot>      No explicit implementation for
10:14:38 <lambdabot>        ‘fmap’
10:14:42 <stoopkid> :)
10:14:52 <ion> That won’t work, fmap is a method of Functor only.
10:14:55 <kadoban> I wouldn't worry too much about that, I'm not sure why it's saying that either …
10:14:59 <mniip> me neither
10:15:02 <mniip> oh
10:15:03 <mniip> I see
10:15:16 <mniip> it keeps complaining about that one 'instance Functor F'
10:15:20 <mniip> need to clear
10:15:20 <ion> You’ll have better success experimenting with a .hs file and ghci.
10:15:44 <kadoban> mniip: Yeah, but doesn't it have an instance after that fmap = undefined bit?
10:15:47 <ion> @undefine
10:15:47 <lambdabot> Undefined.
10:15:58 <mniip> not sure about that
10:16:15 <ion> @let data F x; instance Functor F where { fmap = undefined }; instance Applicative F where { pure = undefined; (<*>) = undefined }; instance Monad F where { return = undefined; (>>=) = undefined }
10:16:16 <lambdabot>  Defined.
10:16:34 * stoopkid falls over
10:17:21 <stoopkid> well
10:17:28 <stoopkid> look at that
10:18:01 <oconnore> what's the best tool to return a C struct as the return value of a Haskell FFI function?
10:18:13 <oconnore> Do I have to manually pack it?
10:18:21 <stoopkid> @undefine
10:18:21 <lambdabot> Undefined.
10:18:25 <stoopkid> @let data F x
10:18:26 <lambdabot>  Defined.
10:18:52 <stoopkid> @let instance Functor F where { fmap = undefined }
10:18:53 <lambdabot>  Defined.
10:19:07 <stoopkid> @let instance Applicative F where { pure = undefined; (<*>) = undefined }
10:19:09 <lambdabot>  Defined.
10:19:23 <stoopkid> @let instance Monad F where { return = undefined; (>>=) = undefined }
10:19:24 <lambdabot>  Defined.
10:19:26 <stoopkid> cool :)
10:19:47 <ion> Some Functor/Applicative/Monad function type signatures contrasted https://gist.github.com/ion1/8384983
10:20:28 <kadoban> ion: Neat, that's a nice list
10:24:00 <stoopkid> why can't Set be made a Functor in Haskell if it is a mathematical Functor?
10:24:09 <hodapp> > traverse (:[0]) [1,2,3]
10:24:10 <lambdabot>  [[1,2,3],[1,2,0],[1,0,3],[1,0,0],[0,2,3],[0,2,0],[0,0,3],[0,0,0]]
10:24:21 <hodapp> can't say I *yet* understand this...
10:24:30 <arkeet> stoopkid: because of that damned Ord constraint.
10:24:51 <arkeet> :t Set.map
10:24:53 <lambdabot>     Not in scope: ‘Set.map’
10:24:53 <lambdabot>     Perhaps you meant ‘S.map’ (imported from Data.Set)
10:24:55 <arkeet> :t S.map
10:24:55 <hodapp> > traverse Just [1,2,3]
10:24:56 <stoopkid> arkeet, what's wrong with the Ord constraint
10:24:56 <lambdabot> Ord b => (a -> b) -> S.Set a -> S.Set b
10:24:57 <lambdabot>  Just [1,2,3]
10:25:02 <hodapp> that's simple enough.
10:25:04 <arkeet> see that Ord constraint?
10:25:09 <arkeet> it doesn't fit with the type of fmap.
10:25:14 <michaelchurch> stoopkid: it can break the monad laws if you fmap from an Eq a to a NOT-Eq b to an Eq c
10:25:38 <arkeet> uh
10:25:38 <michaelchurch> stoopkid: s/monad/functor/
10:25:46 <bernalex> hodapp: that's the same as
10:26:03 <bernalex> > traverse (++[0]) [[1],[2],[3]]
10:26:04 <lambdabot>  [[1,2,3],[1,2,0],[1,0,3],[1,0,0],[0,2,3],[0,2,0],[0,0,3],[0,0,0]]
10:26:09 <arkeet> :t fmap
10:26:10 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:26:11 <arkeet> stoopkid: fmap has to work for *any* two types a and b
10:26:16 <arkeet> without restriction
10:26:56 <arkeet> it's possible to have some sort of restricted functor class
10:26:59 <arkeet> that can cover this case
10:27:03 <arkeet> but it gets messy
10:27:12 <stoopkid> hm..
10:27:27 <stoopkid> :t Either
10:27:28 <lambdabot>     Not in scope: data constructor ‘Either’
10:27:29 <lambdabot>     Perhaps you meant variable ‘either’ (imported from Data.Either)
10:27:30 <hodapp> bernalex: and in either case it's involving some sort of recursive traversal on the results? or something?
10:27:38 <michaelchurch> Also, while it's only a specific implementation of Set that requires Ord, they all require Eq. That's the semantics of a mathematical set.
10:27:39 <stoopkid> :t Data.Either
10:27:40 <lambdabot> Not in scope: data constructor ‘Data.Either’
10:27:59 <michaelchurch> (Also known as extensionality.) {x} /union {x} == {x}
10:27:59 <kadoban> stoopkid: Either is a type constructor. It doesn't have a type
10:28:22 <michaelchurch> List is still well-behaved if you map into a non-equality type.
10:28:28 <kadoban> :k Either
10:28:29 <lambdabot> * -> * -> *
10:28:34 <kadoban> :t Right
10:28:35 <lambdabot> b -> Either a b
10:28:50 <stoopkid> :t Left
10:28:51 <bernalex> hodapp: lists model uncertainty -- cartesian products etc.
10:28:51 <lambdabot> a -> Either a b
10:28:56 <michaelchurch> Set breaks if you map to a type with a radically different equality type (e.g. all things are equal)
10:29:02 <michaelchurch> s/type/relation/
10:29:26 <hodapp> bernalex: I don't really know how this ties into Traversable...
10:30:31 <bernalex> hodapp: traverse operates on an Applicative
10:30:47 <bernalex> hodapp: "Map each element of a structure to an action, evaluate these these actions from left to right, and collect the results. actions from left to right, and collect the results." -- does this help?
10:30:57 <bernalex> @src traverse
10:30:57 <lambdabot> Source not found. Sorry.
10:30:57 <joneshf-laptop> hodapp, maybe some handwaving would help here?
10:31:29 <joneshf-laptop> hodapp, in each of the nested lists, it's inserting some number of `0`
10:31:30 <bernalex> hodapp: 
10:31:31 <bernalex>     traverse f = List.foldr cons_f (pure [])
10:31:33 <bernalex>       where cons_f x ys = (:) <$> f x <*> ys
10:31:44 <hodapp> bernalex: I'm going to assume the part at the end is a typo that needs to be deleted
10:31:59 <joneshf-laptop> hodapp, zero `0`, one `0`, two `0`, or three `0`
10:32:08 <bernalex> hodapp: end of what?
10:32:15 <hodapp> bernalex: what you just quoted
10:32:40 <joneshf-laptop> or maybe tht just hurts
10:32:47 <hodapp> but, no, I cannot exactly see how applying actions left to right somehow gets me to lists modeling uncertainty
10:32:57 <bernalex> hodapp: oh, yeah that's a typo in the ghc src, sorry
10:33:41 <bernalex> hodapp: "Map each element of a structure to an action, evaluate these these actions from left to right, and collect the results." -- that should be it
10:34:33 <ion> hodapp: traverse (:[0]) [1,2,3] = do { a <- 1:[0]; b <- 2:[0]; c <- 3:[0]; return [a,b,c] }
10:34:33 <joneshf-laptop> hodapp, well, traverse doesn't force lists to modell uncertainty, lists do that (that's their computational effect) and traverse lets you evaluate it
10:34:35 <stoopkid> i'm not sure how to define Either as an instance of Functor
10:35:01 <kadoban> stoopkid: You can't.   You can write "Either e" as an instance of Functor though.
10:35:08 <stoopkid> when i look at the example of how Maybe is defined as an instance of Functor, they reference Nothing & Just
10:35:11 <ion> stoopkid: You can’t because Either :: * -> * -> *, but you can make Either e :: * -> * an instance as kadoban said.
10:35:22 <stoopkid> kadoban, oops that's what i meant to say
10:35:55 <hodapp> joneshf-laptop: the point is that between 'left to right' and 'uncertainty' there is a chasm that I am really not seeing how the docs help to close.
10:35:55 <ion> stoopkid: Start by thinking of what the concrete type of fmap is for f = Either e.
10:36:03 <kadoban> stoopkid: You should really do NICTA if you're interested in this stuff. It's … pretty much what it is, except it builds up fairly naturally
10:36:26 <kadoban> (You should do it anyway, but especially if you're interested in this ;) )
10:37:40 <joneshf-laptop> hodapp, do you understand what ion wrote?
10:38:27 <hodapp> joneshf-laptop: not particularly. 
10:38:54 <kadoban> hodapp: What instance are you talking about, by the way? List? List is the part that gives it meaning, specifically it gives it the meaning of computation in nondeterministic fashion.
10:39:07 <kadoban> hodapp: Maybe that's the part you're missing?
10:39:31 <hodapp> kadoban: I'm talking about list, yes.
10:40:52 <ion> > do a <- [1,0]; b <- [2,0]; c <- [3,0]; return [a,b,c]
10:40:53 <lambdabot>  [[1,2,3],[1,2,0],[1,0,3],[1,0,0],[0,2,3],[0,2,0],[0,0,3],[0,0,0]]
10:41:12 <ion> > [ [a,b,c] | a <- [1,0], b <- [1,0], c <- [1,0] ]
10:41:13 <lambdabot>  [[1,1,1],[1,1,0],[1,0,1],[1,0,0],[0,1,1],[0,1,0],[0,0,1],[0,0,0]]
10:41:38 <ion> Whoops, should have been [2,0] and [3,0]. Anyway.
10:43:42 <ion> > [ unwords [a,b,c] | a <- ["hello", "bye"], b <- ["good", "bad"], c <- ["world", "Nether"] ]
10:43:43 <lambdabot>  ["hello good world","hello good Nether","hello bad world","hello bad Nether"...
10:44:06 <ion> hodapp: Are you familiar with how list comprehensions work?
10:44:09 <hodapp> yes.
10:44:19 <joneshf-laptop> hodapp, okay, so ion 's example, `traverse (:[0]) [1,2,3]`, it's saying from left to right, apply the function (:[0]) to the list [1,2,3], so if you apply the the function from left to right you get [[1,0], [2,0], [3,0]].
10:44:26 <hodapp> I'm mostly just not familiar with the use of lists to represent uncertainty.
10:45:12 <kadoban> Mostly it's just … instead of Int, I have [Int], which is … every possible result.
10:45:31 <joneshf-laptop> hodapp, this is the sequence of actions that traverse creates
10:45:35 <joneshf-laptop> hodapp, does that make sense?
10:46:12 <humanoyd> Why don't TupleSections exist by default?
10:47:45 <ion> Someone came up with it after they defined Haskell 98, and the Haskell 2010 committee was rather conservative.
10:47:49 <stoopkid> is any natural language grammar straight-forward enough to have types like this?
10:48:04 <dolio> They may have been implemented after 2010.
10:49:22 <stoopkid> trade :: Object -> Object
10:49:29 <kadoban> stoopkid: Natural languages don't tend to be precise and structured enough to map very well to … pretty much anything in programming languages.
10:49:29 <hodapp> josephle: where does this [[1,0], [2,0], [3,0]] actually manifest itself?
10:50:00 <ion> > map (:[0]) [1,2,3]
10:50:02 <lambdabot>  [[1,0],[2,0],[3,0]]
10:50:13 <ion> > sequence (map (:[0]) [1,2,3])
10:50:15 <lambdabot>  [[1,2,3],[1,2,0],[1,0,3],[1,0,0],[0,2,3],[0,2,0],[0,0,3],[0,0,0]]
10:50:29 <hodapp> josephle: sorry, ignore that. I suck at spelling.
10:50:34 <hodapp> joneshf-laptop: that was for you ^
10:50:49 <joneshf-laptop> hodapp, well yeah, it's as ion showed
10:51:58 * hackagebot yesod-transloadit 0.1.1.0 - Transloadit support for Yesod  http://hackage.haskell.org/package/yesod-transloadit-0.1.1.0 (boblong)
10:52:34 <joneshf-laptop> hodapp, traverse f xs == sequence (fmap f) xs
10:52:52 <stoopkid> can one invite any of these bots into other chatrooms for convenience like ChanServ?
10:53:51 <kadoban> stoopkid: ChanServ is automatically in every channel, I believe. lambdabot you have to ask … whoever runs it. 'int - e' without the spaces I believe
10:54:03 <kadoban> stoopkid: Or you can just private message lambdabot of course
10:54:07 <humanoyd> ion: dolio Thanks...but it's not because it is somehow an unsafe extension?
10:55:54 <stoopkid> ok, let's say i do this "data Optional a = Full a | Empty deriving (Eq, Show)"
10:56:26 <stoopkid> Full and Empty don't exist prior to this declaration, they are essentially patterns i create to be matched later in other definitions that use Optional?
10:57:25 <ion> stoopkid: They will become both a function you can use to construct a value of type Optional a and a pattern you can use to deconstruct one.
10:57:26 <kadoban> stoopkid: They are value constructors. And yes pattern matching is essentially the inverse of construction, it lets you pick apart type constructors.
10:58:14 <stoopkid> for example if i define F :: Optional a -> Maybe a where {F Empty = Nothing; F Full x = Just x} 
10:58:25 <stoopkid> okay
10:58:52 <kadoban> stoopkid: Presumably you mean 'f', not 'F' (it matters in haskell)
10:59:05 <ion> Fixing the syntactic errors: f :: Optional a -> Maybe a; f Empty = Nothing; f (Full x) = Just x
10:59:06 <stoopkid> oh
10:59:07 <kadoban> Oh wait, ignore that sorry.
10:59:08 <stoopkid> yea i do
10:59:09 <joneshf-laptop> hodapp, if that makes sense, then it comes down to what sequence does. For `[[a]]` the implementation chooses all possible combinations of each element from each list.
10:59:26 <joneshf-laptop> > sequence [[1], [2], [3]] -- hodapp 
10:59:28 <lambdabot>  [[1,2,3]]
10:59:45 <joneshf-laptop> there's only one possible element in each list, so it can only construct one list
10:59:45 * MagneticDuck considers using the context of a simple IRC bot to learn elerea
11:00:00 <ion> sequence [as,bs,cs] = [ [a,b,c] | a <- as, b <- bs, c <- cs ]
11:00:02 <stoopkid> right because f takes one argument so Full x needs to be scoped with ()
11:00:02 <joneshf-laptop> > sequence [[1,2],[3,4],[5,6]] -- hodapp 
11:00:03 <lambdabot>  [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
11:00:52 <joneshf-laptop> hodapp, there you can take the first element form the first list, the first element from the second list, the first element from the third list (this is the first entry in the output list)
11:01:16 <joneshf-laptop> hodapp, the next entry in the output list takes the first element from the first list, the first element from the second list, and the second element from the third list
11:01:20 <joneshf-laptop> hodapp, and so on
11:01:40 <joneshf-laptop> > sequence [[1,2,3],[4,5,6],[7,8,9]] -- hodapp 
11:01:42 <lambdabot>  [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[2,...
11:02:03 <joneshf-laptop> > sequence [[1,2,3],[4,5,6],[7]] -- hodapp they don't have to be the same length either
11:02:05 <lambdabot>  [[1,4,7],[1,5,7],[1,6,7],[2,4,7],[2,5,7],[2,6,7],[3,4,7],[3,5,7],[3,6,7]]
11:02:20 <joneshf-laptop> hodapp, does that make more sense?
11:06:58 * hackagebot refined 0.1.0.0 - Refinement types with static and runtime checking  http://hackage.haskell.org/package/refined-0.1.0.0 (NikitaVolkov)
11:12:01 <stoopkid> :k Maybe
11:12:02 <lambdabot> * -> *
11:12:15 <stoopkid> type constructor?
11:12:44 <kadoban> Yep. Give it a concrete type and it'll give you a new concrete type.
11:12:58 <stoopkid> @let data Maybe x = Just x | Nothing
11:12:59 <lambdabot>  Defined.
11:13:03 <stoopkid> is that correct?
11:13:09 <datalligator> anyone got ghci 7.10.1 working with dynamic package libs on OS X?
11:13:41 <ion> Yes. It’s customary to put the “lesser” data constructor first though.
11:13:47 <stoopkid> ah
11:13:58 <stoopkid> @let data Maybe x = Nothing | Just x
11:13:58 <lambdabot>  .L.hs:158:1:
11:13:59 <lambdabot>      Multiple declarations of ‘Maybe’
11:13:59 <lambdabot>      Declared at: .L.hs:155:1
11:14:06 <stoopkid> @undefine Maybe
11:14:06 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
11:14:19 <stoopkid> @undefine
11:14:19 <lambdabot> Undefined.
11:14:25 <stoopkid> @let data Maybe x = Nothing | Just x
11:14:26 <lambdabot>  Defined.
11:14:42 <bernalex> stoopkid: consider not using used words for your examples
11:14:59 <stoopkid> bernalex, what do you mean
11:15:02 <hiptobecubic> or namespace them
11:15:29 <kadoban> stoopkid: Things get weird when you try to call it the same thing, so your example before with Optional, Full and Empty is better.
11:15:51 <bernalex> stoopkid: it gets confusing for people who suddenly get ambiguous messages later on, or in a different channel to where you declared your stuff.
11:16:28 <stoopkid> ah
11:16:41 <stoopkid> i see
11:16:49 <ion> data Maybe' x = Nothing' | Just' x
11:17:01 <stoopkid> oh, that works
11:18:54 <marchelzo_> When you do @undefine, does lambdabot un-define the most recently defined thing, or the most recently defined thing by /you/?
11:19:01 <KaneTW> everything
11:19:06 <KaneTW> @help undef
11:19:06 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:19:11 <KaneTW> @help undefine
11:19:11 <lambdabot> undefine. Reset evaluator local bindings
11:19:39 <marchelzo_> ah
11:19:41 <marchelzo_> thanks
11:19:44 <sinelaw> what would it be like to not have an Eq instance for floating point types?
11:19:51 <sinelaw> horrible?
11:20:15 <KaneTW> marchelzo_: lambdabot stores  a Pristine.hs and L.hs. when you @let something, it puts that in L.hs. when you undef, it replaces L.hs with Pristine.hs
11:20:25 <kadoban> sinelaw: Float and such have an Eq instance, don't they? And yes, it's horrible.
11:20:48 <sinelaw> kadoban, I know they do. I'm trying to imagine how it would be (practically) to not have it
11:20:53 <kadoban> sinelaw: Oh I misread, sorry.
11:29:08 <joneshf-laptop> how do the `OVERLAPPING`/`OVERLAPABLE`/`OVERLAPS` pragmas help things? I can't really find info on it from googling
11:29:19 <joneshf-laptop> it seems like it'd help with granularity
11:29:25 <joneshf-laptop> but does it still make things unsafe?
11:31:05 <joneshf-laptop> oh, i guess if two instances are `OVERLAPABLE` which one would it choose?
11:31:20 <irugihw> Does anyone know if there is a way of printing "vec" in the example in http://stackoverflow.com/questions/29047261/viewing-data-contents-of-generic-container-in-cabal-repl-ghci without resorting to the solution outlined theirin?
11:31:59 * hackagebot webcrank 0.2.0.1 - Webmachine inspired toolkit for building http applications and services.  http://hackage.haskell.org/package/webcrank-0.2.0.1 (purefn)
11:31:59 <irugihw> For more complicated generics, e.g. Vector (Vector (Vector Int)) it becomes tedious to employ the outlined solution
11:37:20 <stoopkid> will this work for product of a list:
11:37:24 <stoopkid> product [] = 1
11:37:32 <stoopkid> product [x:xs] = x * product xs
11:38:09 <stoopkid> product :: List Int -> Int
11:38:50 <stoopkid> oh
11:38:53 <stoopkid> this is a fold
11:39:56 <mauke> stoopkid: no, [x:xs] is wrong
11:41:35 <stoopkid> oh, (x:xs) right?
11:42:26 <mauris> yep
11:42:51 <datalligator> I think I hit ghc issue #10322 - never mind
11:43:51 <stoopkid> so it would be better to do "product x = fold (*) x" or "product x = foldr (*) 1 x" or "product x = foldl (*) 1 x"  
11:48:18 <glguy> product x 07= foldl' (07*) 041
11:48:36 <stoopkid> glguy, where'd the x go
11:48:44 <glguy> product 07= foldl' (07*) 041
11:48:47 <stoopkid> ah
11:48:48 <stoopkid> ok
11:49:04 <stoopkid> why l and not r?
11:49:27 <stoopkid> does this make it an iterative instead of recursive calculation?
11:49:56 <glguy> If we're talking about lists l instead of r because lists lean to the right
11:50:35 <stoopkid> what do you mean, a larger list goes "further right"?
11:50:59 <Denommus> is there a way to write this code without unfolding and then folding back? https://gist.githubusercontent.com/Denommus/6370332/raw/124924838570ef00137d9825502940e882a7b6cd/integral.hs
11:51:55 <Luke> how come I get a forbidden 403 when I try to upload to hackage for a package I own?
11:52:20 <glguy> foldl' f z (x07:xs) 07= (07let 07!z' 07= z07+x 07in foldl' f z' xs)
11:52:38 <glguy> err
11:52:43 <glguy> foldl' f z (x07:xs) 07= (07let 07!z' 07= f z x 07in foldl' f z' xs)
11:53:06 <glguy> anayway, the point is that you can "fold" each element of the list into the running accumulator as you process the list
11:53:24 <glguy> rather than building up a thunk or a stack of expressions to evaluate
12:00:23 <brbblnch> Hi
12:01:03 <brbblnch> \math, I still can't figure out how to prove that the type \forall\alpha.\alpha is empty in System F. Any idea ?
12:01:44 <dolio> What is the statement that it is empty?
12:02:57 <brbblnch> dolio: Well, Girard says so
12:04:53 <stoopkid> would this work for list concatenation? (not including the cases with empty lsits) :
12:05:01 <stoopkid> (++) x y = foldr (:) y x
12:05:49 <stoopkid> (if it would work i'm not claiming it would be efficient)
12:06:07 <nak> > let (++) x y = foldr (:) y x in "ab" ++ "cd"
12:06:08 <lambdabot>  "abcd"
12:06:15 <nak> stoopkid looks like it works 
12:06:23 <stoopkid> cool :)
12:06:42 <dolio> brbblnch: What I mean is, what formula are you even trying to prove?
12:06:49 <nak> > let (++) x y = foldl (:) x y in "ab" ++ "cd"
12:06:50 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ [a]
12:06:50 <lambdabot>      Expected type: [a] -> [a] -> [a]
12:06:50 <lambdabot>        Actual type: a -> [a] -> [a]
12:06:58 <dolio> "forall a. a is empty" is not a very precise specification.
12:07:45 <brbblnch> dolio: I would like to prove that there exists no term of type ∀α.α (or at least no closed term of that, I'm not sure)
12:07:50 <stoopkid> nak, because it left concats a value (value:list), not (list:value)
12:07:56 <dolio> (I also think the formula will be difficult to prove when it's stated precisely, though.)
12:08:30 <nak> stoopkid yeah, i'm on like day 4 of haskell. still haven't gotten to folds much yet :)
12:08:31 <stoopkid> nak, so foldr would go all the way to the end of the first list, and then concat the last character of x to y, and then work backwards
12:08:51 <stoopkid> ah well you got the interpreter down better than i do haha :)
12:08:57 <chaosmasttter> > let (++) x y = foldr (:) y x in zipWith (++) ['a', '', 'ab'] ['', '', 'c']
12:08:58 <lambdabot>  <hint>:1:54: parse error on input ‘,’
12:09:17 <nak> chaosmasttter pretty sure 'ab' is invalid
12:09:44 <chaosmasttter> > let (++) x y = foldr (:) y x in zipWith (++) ["a", "", "ab"] ["", "", "c"]
12:09:45 <lambdabot>  ["a","","abc"]
12:10:04 <stoopkid> hm
12:10:24 <stoopkid> what does zipWith do
12:10:29 <johnw> stoopkid: foldr does not "work backwards"
12:10:33 <brbblnch> dolio: It's bothering because in my book, they don't even take time to show why it is empty, so the proof mustn't be that difficult.
12:10:54 <johnw> stoopkid: if you did a take (length y + 1) on the result of foldr (:) y x, the last element of x would never be considered
12:11:13 <dolio> brbblnch: I'm not sure that's a valid inference. :)
12:11:16 <akurilin> super quick question: how do I suppress orphan instance complains in just one file?
12:11:42 <johnw> {-# OPTIONS_GHC -fno-warn-orphans #-}
12:11:52 <akurilin> thank you!
12:12:07 <Luke> can someone add me to the hackage uploaders group?
12:12:08 <Luke> https://hackage.haskell.org/packages/uploaders/
12:12:17 <Luke> I can't upload packages because my account is to old
12:12:21 <stoopkid> > let (++) x y = foldr (:) y x in "abcde" ++ "12345"
12:12:22 <lambdabot>  "abcde12345"
12:12:32 <johnw> Luke: I can't edit that list
12:12:35 <Luke> damn =/
12:12:43 <Luke> what kind of garbage is this
12:12:58 <Luke> basically older hackage accounts have to be hand-added as far as I can tell
12:13:11 <stoopkid> johnw, so it builds up thunks to the end of "abcde" and then concats "e" to "12345" and then works backwards, d, c, b, a
12:13:14 <Luke> dcoutts: are you here?
12:13:25 <bernalex> Luke: check #hackage or #haskell-infrastructure or whateven
12:13:28 <bernalex> s/n$/r/
12:13:31 <johnw> stoopkid: it only builds one thunk
12:13:32 <Luke> bernalex: already did
12:13:36 <dolio> brbblnch: If you want an argument of sorts... (forall a. a) is 'well known' to represent False in type theory interpreted as a logic. System F is strongly normalizing, and strong normalization implies consistency as a logic. So (forall a. a) must have no terms for all these things to be true.
12:13:42 <johnw> if you ask for more data, then more will happen
12:14:10 <dolio> brbblnch: Making all that precise and proving the parts is not what I'd, personally, call "easy", though.
12:14:47 <stoopkid> > let (++) x y = foldr (:) y x in [0,1,2] ++ [7,8,9]
12:14:48 <lambdabot>  [0,1,2,7,8,9]
12:15:06 <stoopkid> johnw, right, yea that's what i meant
12:15:07 <johnw> initially, what you get is 'a': 'b': 'c': 'd': 'e': <thunk>
12:15:24 <johnw> so if you ask for 6 elements of that, <thunk> is evaluated to 'f':<thunk>
12:15:30 <johnw> and so on, until you finally get to the end of the second list
12:16:08 <johnw> thus, the elements of 'x' are considered from left to right
12:16:44 <stoopkid> johnw, right, foldr 'considers' x, left to right, and then calculates right to left
12:16:56 <johnw> how does it calculate right to left?
12:17:01 * hackagebot seqid-streams 0.3.3 - Sequence ID IO-Streams  http://hackage.haskell.org/package/seqid-streams-0.3.3 (LukeHoersten)
12:17:13 <brbblnch> dolio: Your argument seems the other way around, no ?
12:17:31 <stoopkid> johnw, it first performs (e:y) then d:(e:y) then c:(d:(e:y)) etc.
12:17:36 <dolio> I don't think so.
12:18:10 <dolio> brbblnch: Strong normalization is proved without specifically considering (forall a. a).
12:18:13 <johnw> let's unfold the evaluation
12:18:28 <arkeet> stoopkid: that would be true in a strict language
12:18:42 <nak> > foldr (\x y -> concat ["(",x,"+",y,")"]) "0" (map show [1..13])
12:18:43 <lambdabot>  "(1+(2+(3+(4+(5+(6+(7+(8+(9+(10+(11+(12+(13+0)))))))))))))"
12:18:58 <stoopkid> right to left
12:19:01 <arkeet> > foldr (+) 0 [1..13] :: Expr
12:19:02 <lambdabot>  1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + (11 + (12 + (13 + 0)))))))...
12:19:20 <dolio> brbblnch: I suppose consistency is specifically that (forall a. a) has no proof, assuming that (forall a. a) is False.
12:19:22 <brbblnch> dolio: But if it implies consistency as a logic, you must first decide what type you interpret as false, for which you choose \forall a.a
12:19:29 <nak> arkeet holy smokes
12:19:34 <nak> arkeet that's fricken cool
12:19:43 <geekosaur> @hackage simple-reflect
12:19:43 <lambdabot> http://hackage.haskell.org/package/simple-reflect
12:19:44 <stoopkid> nak, haha yea it was
12:19:45 <arkeet> > foldr f z [1..5] :: Expr
12:19:47 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
12:19:48 <arkeet> > foldl f z [1..5] :: Expr
12:19:49 <lambdabot>  f (f (f (f (f z 1) 2) 3) 4) 5
12:20:04 <brbblnch> dolio: Ok, then
12:20:12 <stoopkid> foldr is right-to-left calculation, foldl is left-to-right calculation
12:20:25 <arkeet> in a strict language, yes.
12:20:35 <stoopkid> in this one, apparently
12:20:37 <arkeet> but haskell is not such a language.
12:20:38 <johnw> and for strict operators in Haskell, but not for operators like (:)
12:20:50 <arkeet> which is why foldr can work on infinite lists.
12:20:56 <stoopkid> ah
12:21:06 <stoopkid> so you might say foldr but it folds left anyway?
12:21:13 <johnw> it's right-associated
12:21:16 <geekosaur> evaluation is always from the outside in
12:21:28 <nak> yeah my understanding of foldl vs foldr was just the association direction
12:21:29 <johnw> geekosaur: that's a good way to put it
12:21:30 <brbblnch> dolio: Could you tell me how strong normalization implies consistency ? Strong normalization + Confluence implies that any type can be normalized, and then ?
12:21:35 <stoopkid> geekosaur, ah i see
12:21:35 <dolio> brbblnch: I'm unsure how you'd do it directly in System F. It'd be easier (to me) if you assumed there were a separate False type with no introduction form. Then you can show that (forall a. a) is isomorphic to False.
12:21:50 <arkeet> > foldr (\x a -> if x == 5 then 0 else x + a) 0 [1..]
12:21:50 <geekosaur> but it's only evaluated at need, so for lazy computations it may be "left hanging" until something actually needs it
12:21:51 <lambdabot>  10
12:21:55 <arkeet> > foldr (\x a -> if x == 5 then 0 else x + a) 0 [1..] :: Expr
12:21:56 <lambdabot>  1 + (2 + (3 + (4 + 0)))
12:22:01 * hackagebot twitter-feed 0.1.1.4 - Client for fetching Twitter timeline via Oauth  http://hackage.haskell.org/package/twitter-feed-0.1.1.4 (stackbuilders)
12:22:03 * hackagebot cabal-helper 0.3.2.1 - Simple interface to Cabal's configuration state used by ghc-mod  http://hackage.haskell.org/package/cabal-helper-0.3.2.1 (DanielG)
12:22:12 <nak> arkeet is there a way i can add :: Expr functionality to my ghci ?
12:22:21 <geekosaur> did you see me point to the package?
12:22:23 <arkeet> nak: it's from the simple-reflect package
12:22:24 <johnw> nak: yes
12:22:39 <nak> how would i go about doing that ?
12:22:41 <johnw> put "import Debug.SimpleReflect" in your .ghci
12:22:43 <stoopkid> arkeet, but 1 + (2 + (3 + (4 + 0)))) still has to be evaluated from the inside out
12:22:59 <arkeet> stoopkid: well sure. but the function I passed to foldr is lazy enough that it doesn't traverse the entire (infinite) list.
12:23:07 <nak> johnw > Could not find module ‘Debug.SimpleReflect’
12:23:18 <arkeet> nak: you have to install that package.
12:23:22 <geekosaur> cabal install simple-reflect
12:23:48 <johnw> stoopkid: folding on lists replaces ':' with f, outside in.  Since '+' is strict in its arguments, calculation is from the inside out, as you said.  This is because of the strictness of +.
12:24:05 <johnw> so you dive in, then climb out
12:24:16 <brbblnch> wait
12:24:17 <neuroserpens> testing 1 2 3
12:24:18 <stoopkid> johnw, so it does compiler magic on concatenation?
12:24:31 <johnw> for lazy operators, you can go only as deeply as you want to
12:24:34 <nak> arkeet johnw thank you. it's working now :)
12:24:38 <dolio> brbblnch: Normalization is like cut elimination. So you'd use it to show that if there's any proof of something, there's a proof via the introduction. But there's no introduction for False.
12:24:39 <brbblnch> dolio: Consistency can be said for a theory, but what does it mean for system f?
12:24:42 <arkeet> > foldr f z [1..5] :: Expr
12:24:43 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
12:24:47 <arkeet> when you evaulate this,
12:24:52 <arkeet> you evaulate the outermost f first.
12:25:13 <stoopkid> right
12:25:14 <arkeet> if f needs to evaluate its second argument to proceed, then it goes into the next one.
12:25:22 <stoopkid> because it doesn't care that the inner is unevaluated yet
12:25:25 <brbblnch> dolio: Oh consistency = "you can't prove false" ?
12:25:35 <dolio> Right.
12:26:00 <stoopkid> so even though it's right-associated, it's still performs left-to-right calculation because it doesn't need the internal values yet
12:26:31 <brbblnch> dolio: Then it's true that proving \forall a.a is empty implies proving that system F is consistent ?
12:26:48 <stoopkid> it basically just composes the outer-functions to build a new outerFunction' on the unevaluated inner values?
12:26:54 <dolio> brbblnch: Yes, I think so.
12:27:09 <dolio> Inasmuch as False = (forall a. a).
12:27:10 <brbblnch> dolio: Oh, thanks!
12:27:43 <dolio> If you assume such a thing as False exists, then they imply one another.
12:27:57 <dolio> <- via instantiation, -> via False elimination.
12:28:24 <johnw> stoopkid: I'm not clear enough on what you're thinking the "outer-functions" are
12:28:57 <johnw> goes goes from f 1 <thunk> to f 1 (f 2 <thunk>), etc. if 'f' is non-strict in the second argument
12:29:26 <dolio> brbblnch: So, I suppose to do what you originally asked, you show that there's no way to prove (forall a. a) via its introduction rules, and then normalization and canonicity give that there's no way at all.
12:29:28 <stoopkid> right
12:29:42 <dolio> But I still don't think that's easy.
12:30:02 <nak> is it possible to get the Expr for something like we were doing before: let (++) x y = foldr (:) y x in "ab" ++ "cd"
12:30:32 <arkeet> nak: Expr is pretty limited.
12:30:34 <stoopkid> >let (++) x y = foldr (:) y x in "ab" ++ "cd" :: Expr
12:30:45 <arkeet> in particular, strings aren't Exprs.
12:30:54 <arkeet> I think.
12:31:05 <geekosaur> > let (++) x y = foldr (:) y x in "ab" ++ "cd" :: Expr
12:31:07 <lambdabot>      Couldn't match expected type ‘Expr’ with actual type ‘[Char]’
12:31:07 <lambdabot>      In the expression: "ab" ++ "cd" :: Expr
12:31:07 <lambdabot>      In the expression:
12:31:11 <geekosaur> nope
12:31:29 <arkeet> I suppose it wouldn't be too hard to give it a IsString instance.
12:31:43 <arkeet> > "ab" :: Text
12:31:44 <lambdabot>  Not in scope: type constructor or class ‘Text’
12:31:46 <arkeet> > "ab" :: T.Text
12:31:47 <lambdabot>  Not in scope: type constructor or class ‘T.Text’
12:31:50 <nak> > let (++) x y = foldr (:) y x in [1,2] ++ [3,4] :: Expr
12:31:51 <arkeet> > "ab" :: Data.Text.Text
12:31:51 <lambdabot>      Couldn't match expected type ‘Expr’ with actual type ‘[Integer]’
12:31:51 <lambdabot>      In the expression: [1, 2] ++ [3, 4] :: Expr
12:31:51 <lambdabot>      In the expression:
12:31:52 <lambdabot>      Not in scope: type constructor or class ‘Data.Text.Text’
12:31:56 <arkeet> :<
12:32:01 <monochrom> [Expr]
12:32:10 <monochrom> err, that still won't help
12:32:16 <nak> > let (++) x y = foldr (:) y x in [1,2] ++ [3,4] :: [Expr]
12:32:19 <lambdabot>  mueval-core: L.hs: removeLink: does not exist (No such file or directory)
12:32:24 <nak> lol
12:32:30 <arkeet> @let import qualified Data.Text as T
12:32:31 <geekosaur> raaaace conditions...
12:32:31 <lambdabot>  .L.hs:111:1:
12:32:31 <lambdabot>      Data.Text: Can't be safely imported!
12:32:31 <lambdabot>      The package (text-1.2.0.4) the module resides in isn't trusted.
12:32:34 <arkeet> :(
12:32:42 <brbblnch> dolio: thanks a lot
12:32:56 <geekosaur> > "foo" :: Text.Text
12:32:58 <lambdabot>      Not in scope: type constructor or class ‘Text.Text’
12:33:10 <geekosaur> I thought it was imported already under some alias, sigh
12:33:17 <monochrom> "ab" ++ "cd" = foldr (:) "cd" "ab" = foldr (:) "cd" ('a' : 'b' : []) = 'a' : 'b' : "cd"
12:33:19 <dolio> brbblnch: You're welcome. Although it seems like that didn't help that much. :)
12:33:35 <arkeet> seems like lambdabot doesn't have OverloadedStrings anyway.
12:33:38 <monochrom> (proof that it takes less time to do it by hand :) )
12:33:51 <stoopkid> monochrom, lol
12:33:53 <brbblnch> dolio could you just expend on : dolio | If you assume such a thing as False exists, then they imply one another.
12:34:11 <stoopkid> it's a handy little string-concatenation definition
12:34:22 <brbblnch> dolio: Well, I was trying to prove it by induction like something quick to show
12:34:31 <brbblnch> dolio: In that way, you helped a lot!
12:34:58 <nak> monochrom lol thx
12:35:14 <dolio> brbblnch: falseElim : False -> t. With t = (forall a. a), you get False -> (forall a. a)
12:35:33 <dolio> brbblnch: You get (forall a. a) -> False via taking a = False.
12:35:48 <monochrom> remember this general rule: foldr (???) zzz ('a' : 'b' : []) = 'a' ??? 'b' ??? zzz. replace : by ???, [] by zzz
12:35:59 <brbblnch> dolio: oh, like that, yeah, good
12:36:30 <monochrom> here I'm assuming that ??? is infixr. i.e., I mean 'a' ??? ('b' ??? zzz)
12:36:37 <brbblnch> dolio: So if False exists it must be the same as \forall a.a
12:36:40 <kadoban> I just remember that foldr (:) []   is  'id' for lists
12:36:50 <dolio> brbblnch: Yes.
12:37:11 <monochrom> and today ??? happens to be : again (and : is right-associative, too), zzz happens to be "cd". so, voila
12:38:49 <stoopkid> kadoban, yea that's just concatenating an empty list like [1,2,...] ++ []
12:39:44 <kadoban> stoopkid: Yep, it makes the definition of (++) in terms of foldr pretty obvious, and helps with 'map' and 'filter' … it's pretty useful to know really.
12:40:15 <stoopkid> i'm trying to figure out 'flatten' now
12:40:20 <stoopkid> concatenate a set of lists
12:41:08 <stoopkid> i can just do "flatten = fold (++)"?
12:41:08 <arkeet> aka concat
12:41:09 <kadoban> stoopkid: That's a neat one, you'll like it once you figure out I think.
12:41:21 <arkeet> well, you need a base case as well
12:41:35 <stoopkid> arkeet, i thought that was just for foldl and r
12:41:43 <kadoban> :t fold
12:41:44 <lambdabot> (Foldable t, Monoid m) => t m -> m
12:41:51 <arkeet> you should do it with foldr
12:41:57 <arkeet> fold is something else.
12:42:03 <stoopkid> "flatten = foldr (++) []"
12:42:06 <arkeet> yep
12:42:11 <kadoban> stoopkid: Nice
12:42:13 <stoopkid> :D
12:42:16 <brbblnch> dolio: good night
12:42:27 <stoopkid> arkeet, kadoban thank you :)
12:44:43 <stoopkid> i'm not sure what flatMap is supposed to do
12:44:56 <arkeet> it just maps then flattens.
12:45:04 <arkeet> flatMap :: (a -> [b]) -> [a] -> [b]
12:45:08 <arkeet> this thing?
12:45:12 <arkeet> :t concatMap
12:45:13 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
12:45:14 <stoopkid> yea
12:45:39 <arkeet> concatMap f = concat . map f
12:45:44 <arkeet> but you should be able to do it with a single foldr
12:46:28 <Fuco> magic of fusion :)
12:46:32 <arkeet> :)
12:46:41 <stoopkid> it looks like it takes a list of functions like (f:g:h), and applies it to a list of values like (x:y:z) to get (fx:fy:fz:gx:gy:gz:hx:hy:hz)
12:46:44 <kadoban> Is there any reason to do it with one foldr, out of curiosity?
12:46:57 <Fuco> kadoban: it saves you iteration
12:47:06 <arkeet> it saves you from building an intermediate list.
12:47:43 <Fuco> hm, wouldn't laziness actually take care of that though?
12:48:00 <kadoban> Does it actually do that though? I thought a compiler would be clever enough to avoid that pretty easily.
12:48:13 <arkeet> well it wouldn't build up the entire list.
12:48:21 <arkeet> but it would build up cons cells only to destroy them immediately.
12:48:27 <Fuco> yea
12:48:35 <arkeet> I believe there are some fusion RULES to optimize that though.
12:49:29 <arkeet> well, I guess not.
12:49:41 <arkeet> @hackage stream-fusion -- hence the existence of this.
12:49:41 <lambdabot> http://hackage.haskell.org/package/stream-fusion -- hence the existence of this.
12:51:44 <hodapp> boo, this library's use of GHC.TypeLits.Nat is complicating things
12:52:05 <hodapp> as it seems now I must parametrize any type I make over that type
12:52:20 <hodapp> and if I want to create a type that involves N of those types?
12:53:45 <arkeet> oh here's the paper I was looking for. https://www.cs.nott.ac.uk/~gmh/fold.pdf
12:54:10 <arkeet> the fusion law for foldr is:
12:54:28 <arkeet> if h w = v and h (g x y) = f x (h y), then h . foldr g w = foldr f v
12:54:48 <hodapp> unless there's some magical way I can make a record which can store N hetereogeneous types (I guess they're a type family?) without itself having to be parametrized over all N types.
12:55:00 <arkeet> in particular, consider h = concat, and foldr f v = map k
12:55:10 <arkeet> (so f = (:) . k and v = [])
12:55:21 <arkeet> er
12:55:32 <arkeet> foldr g w = map k (so g = (:) . k and w = [])
12:56:01 <phaazon> hey, is there a way to hm, create a function that would apply on an object with a typeclass constraint on it and pattern match its type family?
12:56:04 <phaazon> like 
12:56:27 <phaazon> class Foo a where { type Stuff a :: *; foo :: Stuff a -> IO () }
12:56:37 <arkeet> well, concat [] = [], and concat (((:) . k) x y) = concat (k x : y) = ((:) . k) x (concat y)
12:56:41 <arkeet> which tells you that
12:56:42 <phaazon> I’d like to create foo_ that doesn’t take Stuff a because a = ()
12:56:48 <phaazon> I have no idea how to do that
12:56:58 <arkeet> er
12:57:01 <arkeet> wrong.
12:57:04 * hackagebot pseudomacros 0.0.2 - cpp-style built-in macros using Template Haskell  http://hackage.haskell.org/package/pseudomacros-0.0.2 (LukasMai)
12:57:09 <Aruro> Guys, any library which implements bicubic interpolation?
12:57:09 <arkeet> whatever.
12:57:27 <felipedvorak> I'm a noob thinking about learning Haskell. This conversation officialy scared me. Guess I'll learn drawing.
12:57:34 <arkeet> but the point is you can derive concatMap f = foldr ((++) . f) []
12:57:38 <phaazon> Aruro: my smoothie package has several polynomials
12:57:42 <phaazon> but they’re for splines
12:57:45 <phaazon> not sure it’s what you want
12:57:47 <arkeet> from that law
12:57:55 <mniip> felipedvorak, that stuff is really simple though
12:58:07 <Aruro> phaazon: i want 2 dimensional spline :)
12:58:10 <kadoban> felipedvorak: XD you have to just kind of ignore the scary conversations in here sometimes. There's a lot of pretty crazy stuff you can do in haskell. None of them are really necessary to know to use haskell, unless you want them.
12:58:12 <mniip> I mean you just don't know what any of those words mean, but they are really simple
12:58:18 <phaazon> Aruro: I use 3D one
12:58:26 <stoopkid> wait, okay here they give an example for flatMap that i'm supposed to construct:
12:58:28 <stoopkid> flatMap (\x -> x :. x + 1 :. x + 2 :. Nil) (1 :. 2 :. 3 :. Nil)
12:58:28 <stoopkid> -- [1,2,3,2,3,4,3,4,5]
12:58:51 <phaazon> in smoothie, the splines have no fix dimension
12:58:51 <mniip> stoopkid, looks like <*>
12:58:54 <JagaJaga> How to properly write this "if element is a infix of any element of list return true else return false"?
12:58:56 <phaazon> they can be 1D, 2D, 3D, nD
12:58:58 <felipedvorak> kadoban: :D
12:58:59 <Aruro> phaazon: i mean its spline of the surface z(x,y), you have that?
12:59:14 <phaazon> Aruro: ah, hm
12:59:17 <phaazon> I don’t think so
12:59:22 <phaazon> the splines are not surfaces
12:59:37 <Aruro> felipedvorak: you think drawing is easier than haskell?
12:59:43 <felipedvorak> mniip: Really simple if you have a math degree perhaps...
12:59:53 <JagaJaga> :t any
12:59:54 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
12:59:56 <mniip> math degree? nah
12:59:58 <JagaJaga> oh, nice
13:00:03 <Aruro> phaazon: http://en.wikipedia.org/wiki/Bicubic_interpolation
13:00:13 <haskell012> Can I make a haskell function that takes any type and performs something? or does it need a constraint?
13:00:21 <phaazon> Aruro: yeah, smoothie is not about that
13:00:30 <arkeet> Aruro: http://hackage.haskell.org/packages/search?terms=cubic
13:00:43 <arkeet> anything in here look useful?
13:00:44 <Aruro> phaazon: ok, ty
13:00:44 <felipedvorak> Aruro: in my case perhaps it is.. I read a lot of comic books and manga.. kind of understand whats going on... have already a basic experience.. i mean, im not alien to it... this conversation here is something that hurts just to look at
13:00:58 <kadoban> haskell012: Depends what you mean "performs something", but the shortest answer to that question is: Yes, you can.
13:01:08 <stoopkid> so this flatMap is doing flatten [[1+0,1+1,1+2],[2+0,2+1,2+2],[3+0,3+1,3+2]], not flatten [[1,2,3],[1+1,2+1,3+1],[1+2,2+2,3+2]] ?
13:01:15 <haskell012> Ok, cus I have this type signature for my function
13:01:15 <haskell012> sectionBy3 :: [a] -> [[a]]
13:01:22 <phaazon> Aruro: http://hackage.haskell.org/package/smoothie-0.1.3/docs/Data-Spline.html
13:01:32 <haskell012> wait nvm
13:01:34 <arkeet> stoopkid: hard to say, ince those give the same result
13:01:34 <arkeet> :-)
13:01:36 <phaazon> that’s the main interface of my library
13:01:42 <arkeet> since*
13:01:52 <phaazon> I guess it **could** support surface splines
13:01:58 <Aruro> felipedvorak: dont be scared of haskell, its just application of huge function to something. You have troubles with functions?
13:02:06 <phaazon> I use it to smooth my camera’s paths
13:02:09 <timothyh> if I use TH in a library (in this case, to parse some obscure IDL), will those generated types show up in Haddock?
13:02:11 <kadoban> stoopkid: Sounds right, but … those are the same :)
13:02:11 <stoopkid> arkeet, well they give me this: flatMap (\x -> x :. x + 1 :. x + 2 :. Nil) (1 :. 2 :. 3 :. Nil)
13:02:16 <mizu_no_oto> haskell012: that's not really taking 'any type': it's taking a list filled with items of any type
13:02:21 <arkeet> stoopkid: yes
13:02:21 <felipedvorak> Aruro: Not in JavaScript..
13:02:54 <stoopkid> arkeet, kadoban so this "(\x -> x :. x + 1 :. x + 2 :. Nil)" is a single function which gets applied to each element of "(1 :. 2 :. 3 :. Nil)" ?
13:02:55 <arkeet> > map (\x -> [x,x+1,x+2]) [1,2,3]
13:02:56 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5]]
13:02:58 <arkeet> > transpose $ map (\x -> [x,x+1,x+2]) [1,2,3]
13:02:59 <lambdabot>  [[1,2,3],[2,3,4],[3,4,5]]
13:03:00 <felipedvorak> Aruro: better, not superficially... perhaps I have a huge problem with functions in a lower level degree
13:03:10 <arkeet> stoopkid: it is.
13:03:13 <kadoban> stoopkid: Yes
13:03:19 <arkeet> it's not a very good example though.
13:03:32 <Aruro> arkeet: ty, but unfortunately all that packages just do regular interpolation of f(x) = y curve
13:03:53 <stoopkid> okay, this was my confusion, i thought it was supposed to take a list of functions, map each one against the list to generate a list of lists, and then flatten this list
13:04:01 <arkeet> Aruro: oh you said bicubic.
13:04:15 <stoopkid> but it just takes a single function, this function just happened to look like a list of functions because it included concatenation of computed values
13:04:23 <hiptobecubic> hiptobicubic?
13:04:26 <kadoban> stoopkid: Ahh. Naw, make sure you always look at the type signatures too
13:04:28 <hiptobecubic> or regular bicubic?
13:04:58 <stoopkid> kadoban, yea the type signature actually makes sense now haha, they were trying to stump me
13:05:01 <mizu_no_oto> felipedvorak: Functions in Haskell are a little different from functions in javascript.  In javascript, functions are like a list of steps to be followed.  In Haskell, functions are like mathematical functions: they map an input to an output
13:05:08 <Aruro> arkeet: yeah, bicubic on 2 dimensional square
13:05:12 <arkeet> yeah
13:05:20 <arkeet> quick search doesn't find anything :(
13:05:23 <Aruro> looks there is nothing
13:05:28 <Aruro> so i have to write it myself :D
13:05:37 <kadoban> stoopkid: Hehe :)
13:05:51 <arkeet> well, you could do cubic interpolation one axis at a time :-)
13:06:04 <phaazon> Aruro: you could use my smoothie package an provide a bicubic polynomial
13:06:11 <phaazon> which smoothie lacks :)
13:06:13 <Aruro> arkeet: indeed, but that is very naive approach it seems
13:06:17 <kadoban> stoopkid: So glad you're doing NICTA, by the way. It's so cool. It's one of those things I wish I could do again for the first time :)
13:06:20 <arkeet> agreed
13:06:30 <phaazon> http://hackage.haskell.org/package/smoothie-0.1.3/docs/Data-Spline-Polynomial.html#t:Polynomial
13:07:00 <stoopkid> kadoban, so would this work: "flatMap f x = (flatten . (map f)) x" ?
13:07:14 <arkeet> yes
13:07:22 <phaazon> :t flatten
13:07:23 <stoopkid> or i guess i could just say
13:07:24 <lambdabot> Tree a -> [a]
13:07:27 <arkeet> (which can be abbreviated to  flatMap f = flatten . map f)
13:07:34 <stoopkid> yea
13:07:36 <kadoban> Yep, should
13:07:46 <stoopkid> cool :)
13:07:47 <phaazon> flatten . map
13:07:55 <arkeet> flatten is not lambdabot's flatten I think
13:08:11 <kadoban> Yeah, it's not. NICTA has pretty much completely its own set of everything.
13:08:14 <NotMagnap> Have you seen this challenge? https://gist.github.com/jorin-vogel/2e43ffa981a97bc17259#comment-1441725 My solution is anchored. Any kind of constructive criticism welcome!
13:08:30 <arkeet> oh this is from NICTA
13:08:51 <benzrf> argh
13:08:56 <phaazon> oh okay
13:09:03 <felipedvorak> mizu_no_oto: So my math degree assumption isn't entirely wrong ? :D
13:09:15 <phaazon> I got how to specialize a function to match a specific type in the type family
13:09:17 <phaazon> it’s ~ !
13:09:29 <phaazon> foo_ :: (Stuff a ~ ()) => …
13:09:32 <phaazon> pretty nice
13:09:32 <stoopkid> uh oh
13:09:46 <joneshf-laptop> So I'm looking for some way to reify a value into a type, is there a thing for this already?
13:09:48 <phaazon> I never thought I’d need that
13:09:53 <mizu_no_oto> felipedvorak: most stuff learned in a math degree won't help with Haskell, and vice versa
13:09:54 <arkeet> joneshf-laptop: reflection package
13:09:57 <mizu_no_oto> so not really
13:10:00 <stoopkid> they want me to rewrite flatten, but using the flatMap i just wrote, but i just wrote flatMap in terms of flatten
13:10:05 <phaazon> joneshf-laptop: data-reify?
13:10:24 <arkeet> phaazon: that's something different.
13:10:47 <kadoban> stoopkid: That's fine, I think you give it a different name, right?
13:11:18 <joneshf-laptop> arkeet, oh boy, an edwardk package
13:11:29 <stoopkid> kadoban, well yea, but what's the point of a flatten defined in terms of another flatten
13:12:02 <arkeet> stoopkid: for learning!
13:12:10 <stoopkid> oh
13:12:22 <stoopkid> i thought i made a mistake defining the flatMap in terms of the first flatten
13:12:28 <arkeet> nah
13:12:32 <bennofs> joneshf-laptop: but it's fast! :) (uses unsafe ghc tricks to do magic)
13:12:48 <kadoban> stoopkid: Just an exercise, hehe.
13:13:24 <stoopkid> is there an identity function?
13:13:26 <joneshf-laptop> bennofs, that was an excited "oh, boy", not a scared "oh, boy" :)
13:13:28 <arkeet> :t id
13:13:29 <lambdabot> a -> a
13:14:03 <stoopkid> "flattenAgain = flatMap id" ?
13:14:13 <arkeet> try it!
13:14:14 <Aruro> felipedvorak: you dont need any degrees to learn anything , you just need clear head, if you provide that haskell is yours.
13:14:57 <stoopkid> :t flatMap
13:14:58 <lambdabot> Not in scope: ‘flatMap’
13:15:44 <joneshf-laptop> :t (>>=) -- stoopkid 
13:15:45 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:15:46 <kadoban> stoopkid: You have to do that in ghci, since NICTA defines/renames so many things. Unfortunately. Unless you know what the original version is called, heh.
13:15:55 <Aruro> phaazon:  there is a way to realize bicubic interpolation using splines, but i did not get it yet :) can you package handle the needed polinomial?
13:16:06 <Aruro> your*
13:16:21 <stoopkid> >let flatMap :: (a -> List b) -> List a -> List b; flatMap f = (foldr (++)) . map f 
13:16:47 <bernalex> stoopkid: flatmap is just >>= in haskell. also, it's @let not >let.
13:16:59 <arkeet> lambdabot doesn't know List either.
13:17:08 <stoopkid> oh
13:17:15 * stoopkid moves to ghci
13:17:21 <arkeet> mhm
13:17:35 <phaazon> Aruro: well, my package already handles a few polynomials, but it’s very easy to add new ones
13:17:40 <phaazon> I plan to add several soon
13:17:46 <phaazon> catmull rom splines, and so on
13:17:48 <arkeet> stoopkid: ok this doesn't look like an exercise in NICTA but it's fun to think about anyway:
13:17:52 <arkeet> try implementing map using flatMap
13:17:52 <bernalex> I assumed someone had done 'type List = []' or something.
13:18:11 <kadoban> It would be neat to run a lambdabot with all of NICTA's stuff defined in it. Probably not worth the trouble though :(
13:20:58 <kadoban> Actually … that would probably be pretty insanely useful. Then people could experiment to test their own stuff against it too. Wonder how hard lambdabot actually is to set up…
13:21:27 <visof> hi guys
13:21:51 <visof> i'm trying to install HLearn , i cloned it from github and http://sprunge.us/TNeL
13:21:59 <visof> how can i fix this issue?
13:22:08 <visof> anybody faced the same problem ?
13:23:58 <stoopkid> "flattenAgain = flatMap id" worked :D
13:24:42 <goingtolernhaske> oh!
13:24:53 <goingtolernhaske> some people here
13:24:59 <EvanR-> cd ~/annex/
13:24:59 <EvanR-> ls
13:25:39 <EvanR-> thats what i get for trying to use the computer without being able to see
13:25:53 <goingtolernhaske> ;]
13:27:42 <goingtolernhaske> [Test multiline comments] test1 
13:27:45 <goingtolernhaske> ech
13:27:50 <goingtolernhaske> do not work
13:28:26 <KaneTW> do not work? you heard him guys, it's vacation time
13:29:07 <edwardk> could some folks give https://www.fpcomplete.com/user/edwardk/fibonacci/leonardo a once over before it goes into wider circulation?
13:29:12 <goingtolernhaske> :D
13:30:13 <stoopkid> hm.. this is a tough one seqOptional :: [Optional a] -> Optional [a]; data Optional a = Empty | Full a
13:30:16 <ion> edwardk: /me reads
13:30:30 <hiptobecubic> edwardk, "You can take multiple steps given a pair of consecutive Leonardo numbers i,j, you can find the Lenardo number 2 numbers ago:" is that supposed to be two sentences?
13:30:34 <mauke> https://oeis.org/wiki/User:Reinhard_Zumkeller <- I may know this guy
13:30:47 <stoopkid> if any of the Optional a in the list of Optionals is empty, then seqOptional should return Empty
13:30:51 <edwardk> hiptobecubic: I'll try to carve that up into something more resembling english =)
13:31:08 <stoopkid> otherwise it should return Full [a]
13:31:13 <mauke> and "Lenardo" is a typo
13:31:45 <goingtolernhaske> shor question: Should I Start with "http://learnyouahaskell.com"? I know C/C++, Python and some other languages more or less...
13:32:28 <bernalex> goingtolernhaske: sure.
13:32:48 <geekosaur> @where cis194
13:32:48 <lambdabot> http://www.seas.upenn.edu/~cis194/fall14/spring13/index.html
13:32:52 <bernalex> goingtolernhaske: the stuff linked from https://github.com/bitemyapp/learnhaskell is also a popular starting point.
13:32:54 <goingtolernhaske> thx
13:33:14 <mauke> from what I've seen, the cis194 stuff is good
13:33:18 <mauke> (but what an awful name)
13:33:21 <edwardk> hiptobecubic: fixed the graphic in that section i think and mauke's located typo
13:33:34 <bernalex> mauke: I agree. it should be the first thing linked in the learn haskell github repo.
13:33:54 <goingtolernhaske> thanks a lot
13:33:59 <Aruro> edwardk: adding some comment about exclamation in data declaration would be nice, its right in the section growing spine
13:34:12 <mauke> edwardk: you still have two "you can" in one sentence and it's confusing me
13:34:26 <hiptobecubic> edwardk, "e.g. a tree of size 5 has a left child with 1 children, and a right child with 3:" it might be best to leave it to maintain uniformity, but there are very rarely 1 children anywhere :)
13:34:41 <ion> stoopkid: Start by specifying the pattern matches for the possible cases of input.
13:34:46 <mauke> rarely is the question asked
13:35:26 <kadoban> stoopkid: By the way, there's #nicta-course and/or #haskell-beginners if your nicta stuff is getting lost here
13:35:36 <mauke> edwardk: "By the recurrence, leonardo (-1) = prev 1 1 = -1. We can continued to" =~ s/\. We/, we/r =~ s/continued/continue/
13:35:38 <hiptobecubic> edwardk, you also change the way you refer to tree size there. I'd just say "Has a left child of size 1 and a right child of size 3"
13:35:51 <stoopkid> kadoban, cool :)
13:35:53 <mauke> oops, missing r at the end
13:36:21 <stoopkid> ion, well, there's 2 cases: the case where it *does* have an Empty value, and the case where it doesn't
13:36:28 <edwardk> mauke: fixed the you can..you can. Aruro: makes sense. i should note why they are strict
13:36:33 <edwardk> hiptobecubic: fixed
13:36:34 <ion> stoopkid: Remember that the input is a list.
13:37:01 <edwardk> hiptobecubic: i started switching to the 'size' vocabulary and then dropped the ball on changing the first example
13:37:04 <stoopkid> ion, yea that's where i'm having trouble coming up with a pattern match
13:37:12 <edwardk> mauke: fixed continue
13:37:31 <Cuby96> hi there folks :) having an issue with an excercise to understand... having 4 definitions: inc, dec, frac, twice who does what it says and i have an expression to shorten: frac (twice inc 3) 13, afaik the result is frac 8 13 which is 1, cause 13/8 as an integer is 1 right?
13:37:32 <mauke> oh, the other one is actually ok
13:37:36 <stoopkid> i was thinking of defining it recursively
13:37:39 <mauke> I was reading it wrong
13:38:04 <Cuby96> or did i get it wrong?
13:38:18 <mauke> Cuby96: that depends on what exactly twice and frac do
13:38:23 <edwardk> mauke: figured it was a cute, short article and made people think about recurrences
13:38:44 <edwardk> and i wanted to do this and then a quick one on open ended fbonacci search next time
13:38:54 <ion> stoopkid: List is defined as data [a] = [] | x:xs, so you have two cases to start with: seqOptional (x:xs) = _; seqOptional [] = _. The next thing to do is to pattern match on the “x”, which as you said has two cases.
13:39:14 <ion> Uh, i meant data [a] = [] | (:) a [a]
13:39:25 <stoopkid> ion, right
13:39:55 <stoopkid> wait
13:39:55 <MuffettMan> Quick terminology question, if I define a new type Thing like this : data Thing = ThingOne | ThingTwo; What is the term to describe ThingOne and ThingTwo? Are they constructors even though they take no arguments?
13:40:01 <Aruro> i just got a feeling that irc can heavily benefit from tmux interface, where each answer will be grouped out in a separate area
13:40:03 <stoopkid> ion, what is this = _?
13:40:06 <mauke> MuffettMan: yes
13:40:13 <stoopkid> ion, i understand where _ appears on the left
13:40:16 <geekosaur> data constructors, yes
13:40:17 <MuffettMan> mauke: Cool, thank you
13:40:37 <visof> none can help or refer for help?
13:40:52 <ion> stoopkid: A hole. It’s something that needs to be filled in. A recent enough GHC will tell you the type of the hole when you try to compile it.
13:41:26 <Aruro> ion: so can do lambdabot
13:41:38 <mauke> > dataTypeConstrs (dataTypeOf True)
13:41:39 <lambdabot>  [False,True]
13:41:55 <geekosaur> visof, that looks to be an internal module so you'd have to ask the developer, presumably via github issues
13:42:01 <Cuby96> mauke: frac is defined by frac :: (Int -> Int) -> Int -> Int *new line* frac n z = z 'div' n and twice :: (Int -> Int) -> Int -> Int *new line* twice f n = f (f n)
13:42:04 <kadoban> Aruro: Unlikely to be helpful in his case though (he's doing NICTA, which has different family of types/typeclasses than lambdabot)
13:42:10 <mauke> edwardk: "e.g. a tree of size 5" <- shouldn't that be "E.g." because beginning of sentence?
13:42:22 <stoopkid> ion, well, seqOptional [] should be Full [] i think
13:42:23 <Aruro> kadoban: ah, ok , sorry did not read above
13:42:24 <mauke> Cuby96: you can use ; instead of newline :-)
13:42:30 <kadoban> No worries, just saying.
13:42:34 <ion> stoopkid: Correct.
13:42:36 <pavonia> visof: You probably have an incompatible version of HLearn-distributions installed
13:42:37 <mauke> Cuby96: and it's `div`, not 'div'
13:43:01 <edwardk> mauke: fair =)
13:43:02 <stoopkid> ion, ah, to be filled in by *me*
13:43:07 <mauke> except that makes no sense
13:43:12 <ion> stoopkid: yeah :-)
13:43:17 <stoopkid> :)
13:43:25 <mauke> Cuby96: how does frac typecheck if n is a function?
13:43:26 <ion> Until we have self-programming computers
13:43:48 <kadoban> In which case, we're all out of a job, and will have to learn ditch-digging.
13:43:53 <mauke> Cuby96: twice inc 3 is 5, though
13:44:18 <stoopkid> ion, what about using guards and recursion for the (x:xs) pattern
13:44:19 <edwardk> mauke: fixed
13:44:58 <kadoban> stoopkid: Sounds like a plan, except you might want to use a 'case' instead of guards
13:45:09 <stoopkid> kadoban, ah, yea
13:45:17 <Cuby96> mauke: oh i see, it takes the first expression twice, well... so 5 then right :) all the types are trimmed to integer
13:45:29 <mauke> edwardk: "I'll say that i has index n" <- that looks backwards. doesn't n have index i?
13:46:07 <edwardk> mauke: probably =)
13:46:45 <ion> stoopkid: You could use pattern guards, a case expression or perhaps “seqOptional (Empty : xs) = _; seqOptional (Full x : xs) = _; seqOptional [] = _”. As for the last one, i’m not sure if GHC is smart enough to check whether the top-level constructor is (:) just once, so it may have a tiny performance difference.
13:46:48 <edwardk> mauke: yep. i flipped variables and forgot to update the words
13:47:32 <stoopkid> ion, yea that's what i have now, but it looks like on the (Full x : xs) i still need a case & recursion
13:48:50 <octalsrc> are there special rules to consider when printing to stdout from concurrent threads?
13:49:00 <Cuby96> means frac 5 13 with in the definition of frac which is frac n z = z `div` n is => 2 right?
13:49:10 <kadoban> octalsrc: A special rule like "don't" comes to mind :)
13:49:20 <octalsrc> ah :D
13:49:26 <mauke> edwardk: the first guard group in the definition of (!) does not align its '='s, but the second guard group does
13:49:42 <napping> octalsrc: nothing will crash, but output can be randomly interleaved
13:49:49 <ion> ooccttaallssrrcc::  YTohue  moauyt peuntd  muapy  wbiet hm emsessesde du pu.p output.
13:50:01 <octalsrc> well, I was getting some errors like "<stdout>: hPutStr: illegal operation (handle is finalized)"
13:50:03 <kadoban> octalsrc: You can do that, if you're really careful … but usually you want to have only one thread printing if at all possible. This is just general threading advice, I dunno much specific to haskell in that regard (should apply though)
13:50:06 <octalsrc> which would halt the program
13:50:11 <stoopkid> ion, okay, here's what i've got
13:50:21 <stoopkid> seqOptional [] = Full []
13:50:24 <napping> that sounds like something is closing stdout
13:50:28 <octalsrc> but I fixed it by getting rid of all my stray debugging prints
13:50:32 <napping> Maybe the program is quitting earlier than you want?
13:50:37 <stoopkid> seqOptional (Empty:xs) = Empty
13:50:38 <geekosaur> did you hClose it from somewhere?
13:50:41 <Hijiri> Cuby96: The type signature of frac is (Int -> Int) -> Int -> Int
13:50:49 <Hijiri> What is the type of n, then?
13:51:03 <padre_angolano> jjj
13:51:13 <padre_angolano> sorry
13:51:15 <stoopkid> seqOptional ((Full x):xs) = case seqOptional xs of { Empty -> Empty; Full xs -> Full (x:xs) }
13:51:16 <octalsrc> also this was with GHCJS running in the browser, which might make it more complicated
13:51:36 <ion> stoopkid: Nice. Now, does that case expression have a familiar shape? Hint: fmap
13:51:39 <Cuby96> Hijiri: int? cause always integer in it?
13:51:51 <mauke> edwardk: "(Dijkstra ended EWD797 on this note)" <- missing period?
13:51:52 <Hijiri> Cuby96: What does the type signature say
13:51:58 <stoopkid> ion, oh crap.. lemme think hehe
13:52:53 <Cuby96> Hijiri: well thats all i got of information
13:53:06 <Cuby96> the definitions and the code
13:53:13 <Hijiri> Cuby96: I'm talking about the type signature
13:53:17 <Hijiri> which is one of the things you have
13:53:29 <Hijiri> Cuby96: What does the type signature a -> b mean
13:53:46 <kadoban> stoopkid: (Also, make sure you translate that to nicta's list definitions before you wonder why it doesn't typecheck. (:.) and Nil.) I only mention because I did that a /lot/ in that exercise and somehow managed to be really surprised/confused each time ;)
13:54:17 <octalsrc> geekosaur: I guess I must have?
13:54:22 <Hijiri> Or what does it mean if something has type that
13:54:31 <ttt_fff> is "pointfree" all that haskell can learn from forth?
13:54:40 <ttt_fff> is there a way to utilize more of forth in haskell?
13:54:44 <edwardk> mauke: fixed, fixed. =)
13:54:52 <stoopkid> kadoban, yea i noticed that, i just translated their stuff into the more standard stuff i usually see
13:55:04 <kadoban> Right, I kinda figured, just making sure :)
13:55:07 <ion> How does pointfree have anything to do with Forth?
13:55:19 <edwardk> mauke: if this whole programming thing doesn't work ot for you you could make a good living as a copy editor ;)
13:55:20 <Cuby96> Hijiri: well i didnt get it what to answer... whats a typ signature...? idk if i already know it and didn't know the exact name how to say or completely dont know
13:55:26 <edwardk> er out
13:55:38 <mauke> I've reached the end :-)
13:55:41 <Hijiri> Cuby96: The type signature is the part after :: in a type annotation
13:55:55 <Hijiri> Like "banana :: Int" says that banana is of type Int
13:56:07 <stoopkid> ion, nah i don't see how it fits as an fmap although i was looking for a way to use fmap and other stuff earlier before i split it up into cases
13:56:23 <Hijiri> Similarly, "double :: Int -> Int" says that double is a function from Ints to Ints
13:56:31 <Cuby96> Hijiri: okay got it and what signature u need now? :)
13:56:33 <stoopkid> :t fmap
13:56:35 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:56:37 <Hijiri> the type signature for those are "Int" and "Int -> Int" respectively
13:56:54 <f-a> has anyone here `documentation: True` enabled in cabal? (ghc 7.10.1)? The documents are generated correctly but the main index is broken.
13:56:58 <Hijiri> Cuby96: Do you understand function type signatures?
13:57:00 <kaidelong> I'm assuming he's talking about how in FORTH it is necessary to manipulate the stack to reorder it into a way approrpiate for consumption by your procedure
13:57:10 <kadoban> stoopkid: Want a (decent sized) hint?
13:57:18 <kaidelong> which is coincidentally similar to Backus' FP language and how it handles arguments
13:57:28 <ion> stoopkid: Remember the definition of fmap for Optional, let me make it the same shape: fmap f o = case o of { Empty -> Empty; Full a -> Full (f a) }
13:57:29 <f-a> (i.e. has links like `file:///home/f/.cabal/share/doc/i386-linux-ghc-7.10.1/Blaze-ByteString-Builder.html` when it should prepend package name instead)
13:57:40 <kaidelong> (@ ion)
13:58:21 <kadoban> (nevermind on my hint, ion is doing a nice job guiding)
13:59:07 <Cuby96> Hijiri: function type signature? well i know now what a type signature is, but i stuck at func. type signature now
13:59:31 <Cuby96> sry i'm new at haskell, my fault not to mention it
13:59:46 <Hijiri> Cuby96: A function type signature looks like this: a -> b
14:00:00 <Hijiri> It is the type of functions that take an a and return a b
14:00:19 <Hijiri> The -> associates to the right
14:00:30 <Hijiri> So a -> b -> c is a -> (b -> c)
14:01:18 <Hijiri> This is how Haskell does multi-argument functions - the function takes the first argument, and returns a function that takes the next argument, and so on
14:01:19 <kadoban> Cuby96: An example is …     add1 a = a + 1       add1 :: Int -> Int          add1 is a function, where if you give it an Int, it'll give you an Int back.
14:01:51 <Hijiri> So for example, if we have add :: Int -> Int -> Int, the type signature is really Int -> (Int -> Int)
14:02:05 <Hijiri> If you apply add, you can see how the type evolves
14:02:16 <Hijiri> add :: Int -> (Int -> Int), add 5 :: Int -> Int
14:02:24 <Hijiri> And then add 5 6 :: Int
14:02:32 <stoopkid> ion, wait a minute
14:02:47 <Hijiri> Each application gives you the thing to the right of the outermost ->
14:02:49 <stoopkid> ion, fmap (x:xs) (seqOptional xs)
14:02:55 <kadoban> Cuby96: By the way, if you're learning haskell, see: https://github.com/bitemyapp/learnhaskell   not that that should disuade you from asking questions, just a suggestion
14:03:24 <ion> stoopkid: Almost, but x:xs is a complete list and the first parameter of fmap needs to be a function.
14:03:26 <Cuby96> ya i know that i can look up its just that i got confused :D
14:04:13 <stoopkid> ion, ohhh "seqOptional ((Full x):xs) = fmap (x:) (seqOptional xs)" ?
14:04:21 <Cuby96> well, afais it means int -> int -> int is int -> (int -> int) now what do i do now with the twice f n = f (f n) ?
14:05:04 <Cuby96> in the expression twice (frac 2) (dec 16)
14:05:15 <Cuby96> it only has 2
14:05:23 <Cuby96> then there is the )
14:05:24 <kadoban> stoopkid: Nice :)
14:05:37 <Cuby96> so wheres the 2nd parameter?
14:05:59 <Aruro> is there any emacs package whihc can fold haskell functions definition to just there type declarations?
14:06:05 <Hijiri> Cuby96: we need to look at frac first, because frac's definition doesn't match its type signature
14:06:36 <ion> stoopkid: Nice
14:06:39 <Hijiri> frac's type signature is (Int -> Int) -> Int -> Int, so what is the first argument it takes?
14:06:45 <Hijiri> Make sure to look at the outermost ->
14:06:55 <stoopkid> ion, kadoban :D
14:07:39 <Hijiri> (because -> associates to the right, (Int -> Int) -> Int -> Int is the same as (Int -> Int) -> (Int -> Int))
14:07:53 <Hijiri> what is the type of the first argument, I mean
14:07:58 <Cuby96> (int -> int) -> (int -> int) ?
14:08:00 <kadoban> stoopkid: By the way, make sure you're running the doctests as you go. This will help you later on, as a lot of the later exercises use the earlier ones, so you won't have a million tiny typos to fix at a time if you do that.
14:08:17 <Hijiri> Cuby96: that is frac's type signature
14:09:07 <Hijiri> If a -> b means a function that takes an "a" and gives a "b", what does a function of type (Int -> Int) -> (Int -> Int) take and give?
14:09:33 * hodapp grumbles something about type-level naturals and them being a total pain to use in conjunction with aggregation
14:10:35 <Hijiri> Hint: You can substitute (Int -> Int) for a and b in "a -> b" to get (Int -> Int) -> (Int -> Int)
14:10:40 <Cuby96> it takes the (int -> int) and gives himself again?
14:10:58 <Hijiri> Not necessarly the same thing, but something of the same type
14:11:09 <Hijiri> It takes a function from Ints to ints, and gives another function from Ints to Ints
14:11:15 <kadoban> Cuby96: (Just a note:  int isn't the same thing as Int. lowercase are type variables, not types)
14:11:35 <Cuby96> kadoban: ah okay sry
14:11:50 <kadoban> Not a problem, just a good habit to get in, being clear about it.
14:12:18 <Hijiri> So frac takes a function from Ints to Ints, and then you get a new function of type Int -> Int
14:12:24 <Hijiri> And then that takes an Int itself
14:12:38 <Hijiri> So what you end up with is that frac takes a function, then an Int, then returns an Int
14:13:03 <Hijiri> But the definition of frac (frac n z = z `div` n) doesn't match up
14:13:14 <Hijiri> n is supposed to be a function, because frac takes a function as an input
14:13:15 <mauke> edwardk: https://www.fpcomplete.com/user/edwardk/online-lca "identifierss" :-(
14:13:21 <Hijiri> but you can't use div with functions
14:13:22 <Hijiri> :t div
14:13:23 <lambdabot> Integral a => a -> a -> a
14:13:33 <Hijiri> read that as "Int -> Int -> Int" for now
14:13:56 <edwardk> mauke: i swear you feel physical pain at the sight of a typo
14:14:00 <Hijiri> So there's something wrong with either frac's type signature or its definition
14:14:15 <hodapp> edwardk: I definitely do
14:14:37 <Cuby96> Hijiri: so means i have to make the dec first before proceed to frac?
14:14:42 <hodapp> mauke: http://explosm.net/comics/2712/ - is that you?
14:14:49 <Hijiri> It means you need to fix frac's definition, or maybe its type signature
14:15:11 <alex8022> hey, so I'm working on a problem set, trying to learn haskell, and I am either missing something for one of the exercises, or thinking about it wrong.
14:15:16 <mauke> edwardk: if I didn't, how could I write programs where every character is significant?
14:15:16 <Hijiri> What is frac expected to do?
14:15:21 <alex8022> http://pastie.org/10117037
14:15:35 <alex8022> Could someone point me in the right direction?
14:16:22 <ion> alex8022: You don’t need show and read, you can just do integer division.
14:16:24 <coltfred> alex8022: What's your specific question? 
14:16:40 <mauke> alex8022: :: Integer is redundant
14:16:42 <coltfred> ion: Oh... you could have made him at least ask a question!
14:16:43 <Cuby96> it takes number n and z and makes that: z/n..... thats what i got thats all well if its wrong i have to say the excercise maker that he fails :P
14:17:01 <Hijiri> Ok
14:17:07 <Hijiri> So what do the types of n and z need to be?
14:17:08 * hackagebot gll 0.1.0.1 - GLL parser with simple combinator interface  http://hackage.haskell.org/package/gll-0.1.0.1 (ltvanbinsbergen)
14:17:46 <Cuby96> Hijiri: well afais int
14:17:51 <Hijiri> Ok
14:18:05 <Hijiri> So frac is supposed to be a function that takes an Int, then another Int, then gives an Int
14:18:14 <Hijiri> What's the type signature for a function like that
14:18:14 <sinelaw> does forall a. a -> a   subsume   Int -> Int ?  I would say no because 'a' is invariant, am I right?
14:18:48 <dolio> sinelaw: No.
14:18:57 <sveit> it seems the concensus is that any global package install is bad, but if i like to play around with some core packages in ghci often, is it "bad" to install to the global user db? just like in python, i have numpy/scipy globally installed, but create a virtualenv for projects when they begin to get external dependencies
14:19:05 <Cuby96> Hijiri: int -> double?
14:19:15 <sinelaw> dolio, no it doesn't subsume, or no I'm wrong?
14:19:21 <Hijiri> Cuby96: The type signature of "div" is Int -> Int -> Int
14:19:23 <dolio> sinelaw: You are wrong.
14:19:39 <Hijiri> So you get an Int from div
14:19:50 <Hijiri> So frac returns an Int
14:20:09 <Hijiri> Also, your type signature only has one argument
14:20:12 <Hijiri> frac takes two
14:20:19 <sinelaw> dolio, hmm yeah, obviously a -> a can be instantiated to Int -> Int
14:20:23 <dolio> Right.
14:21:02 <Cuby96> Hijiri: means the excercise is wrong?
14:21:12 <Hijiri> probably
14:21:52 <jle`> c_wraith: yes i did
14:21:56 <Hijiri> But we should continue for the sake of knowing what's wrong
14:22:00 <Cuby96> Hijiri: well i have to deal with it as it is right, else i didnt get the needed points for the excercise.... so the prob is: what to do?
14:22:41 <Hijiri> Well first, we should come up with the correct type signature for frac
14:22:47 <Hijiri> so we know what it's supposed to be, and use that
14:23:10 <Cuby96> Hijiri: okay, got it :) so we dont mess up things
14:23:32 <Hijiri> So what's the type signature for a function that takes two Ints, and gives back an Int?
14:23:40 <Hijiri> Don't think of any specific function, just any function like that
14:24:26 <Hijiri> actually, I'm not sure I explained type signatures with multiple arguments adequately
14:25:06 <Cuby96> is it (Int -> Int) -> Int?
14:25:17 <Hijiri> Cuby96: What does that type signature say?
14:25:30 <Hijiri> what does a function of that type take as an argument
14:25:51 <Cuby96> Hijiri: well two integers
14:26:01 <Hijiri> Give a type signature for the argument
14:26:04 <Aruro> Cuby96: each -> thing creates argument, unless its last or enclosed in ()
14:26:14 <Denommus> Cuby96: no, that takes a function
14:26:40 <Denommus> Cuby96: imagine that every function takes a single argument, but may return another function
14:26:41 <Aruro> Cuby96: (Int->Int) --- this is one argument, but its complex, because it is a function itself
14:26:47 <ReinH> @quote fugue
14:26:47 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
14:26:55 <Denommus> Cuby96: so Int -> Int -> Int is a function that returns a Int -> Int, which returns a Int
14:27:12 <Aruro> ReinH: you play any fugue?
14:27:47 <sveit> sorry to bump in case someone responded when I got disconnected, but i was wondering if people installed /anything/ to the global db, or if most people worked exclusively through sandboxes?
14:28:04 <Cuby96> ah i see so its like a recursion alike?
14:28:17 <Cuby96> box in a box
14:28:19 <ReinH> sveit: I think you'll find people who do both
14:28:20 <Aruro> i did first global, then i discovered sandboxes, and i am noob
14:28:26 <Hijiri> sveit: Those aren't the only two options
14:28:31 <kadoban> sveit: I work all in sandboxes except what a bare GHC install does (not platform, just GHC)
14:28:32 <Denommus> Cuby96: it can be seen like that, yes
14:28:32 <Aruro> sandboxes are much much better
14:28:34 <Hijiri> You have the global db, which is system wide
14:28:48 <Hijiri> And you have the user db, which is for you
14:28:51 <Hijiri> and then sandboxes
14:28:53 <ReinH> Cuby96: (->) binds to the right, so a -> b -> c is a -> (b -> c)
14:29:02 <Hijiri> user packages are hidden in sandboxes, but global ones are not
14:29:04 <Hijiri> which is a big difference
14:29:19 <Denommus> there are some packages that must be installed globally
14:29:31 <ReinH> This means that a function f :: Int -> Int -> Int that "takes two arguments" is actually a function f :: Int -> (Int -> Int) that takes an Int and gives a function which takes the second Int.
14:29:34 <Denommus> Cuby96: so a function that takes to ints is Int -> Int -> Int
14:29:47 <Aruro> two*
14:29:48 <Denommus> Cuby96: because you'll call that with f int1 int2
14:29:56 <kadoban> Denommus: There are?
14:30:01 <ReinH> When applying f, function application binds to the left, so f 1 2 = (f 1) 2
14:30:13 <Denommus> kadoban: yes. Like cabal-install itself
14:30:34 <ReinH> so f :: Int -> (Int -> Int), f 1 :: Int -> Int
14:30:40 <Cuby96> so its actually Int -> Int -> Double cause it takes twi integers and outputs a double right?
14:30:43 <sveit> Denommus: i have cabal-install compile in a sandbox, so i am not sure what you mean?
14:30:49 <Denommus> Cuby96: yes
14:30:49 <Aruro> Cuby96: yes
14:30:56 <Hijiri> it doesn't output a Double
14:30:58 <Cuby96> yay finally got it ;)
14:30:58 <ReinH> sveit: Ah, I see the confusion. cabal install installs to the *user* db, not the global db.
14:31:02 <ReinH> The terms are a bit arcane.
14:31:13 <Denommus> sveit: I said "must" but I wanted to say "I find more convenient"
14:31:53 <Aruro> Cuby96: did you get that function (Int->Int->Int->Int->Int)->Int has only 1 argument?
14:32:08 <Hijiri> frac outputs an Int, because div outputs an Int (when given two Ints)
14:32:09 * hackagebot ssh 0.3.1 - A pure-Haskell SSH server library.  http://hackage.haskell.org/package/ssh-0.3.1 (GaneshSittampalam)
14:33:15 <Cuby96> Aruro: well.... isnt it also the imaginary brackets again?
14:33:22 <Aruro> nope
14:33:35 <Aruro> what do you mean imaginary?
14:33:50 <Denommus> Cuby96: no
14:34:03 <Denommus> Cuby96: the brackets are only implicit at the end
14:34:06 <ReinH> Cuby96: There is a big difference between (a -> a) -> a and a -> (a -> a)
14:34:18 <Denommus> Cuby96: in (Int -> Int) -> Int, you're taking a Int -> Int function and returning a Int
14:35:24 <Aruro> Cuby96: think like that arguments are always left part, only most right part is the result
14:36:09 <Cuby96> ya bit Int -> int -> int turns in a Int -> (Int -> Int) again so its (int -> (int->Int)) -> int or not?
14:36:26 <Cuby96> so 2 args
14:36:41 <ReinH> Int -> Int -> Int = Int -> (Int -> Int) = (Int -> (Int -> Int))
14:36:45 <ReinH> there's no fourth Int
14:36:59 <Denommus> it's amazing how simple that is in my head but how difficult it is for me to explain
14:37:06 <Aruro> Cuby96: correct, but now you are thinking about currying :)
14:37:14 <ReinH> Aruro: no, not correct.
14:37:29 <ReinH> Int -> Int -> Int does not unify with (Int -> (Int -> Int)) -> Int
14:37:33 <Cuby96> well im total confused guys sry bout that but your amazing still :)
14:37:55 <Aruro> ReinH: his middle statement is correct, last one is not indeed
14:38:14 <Hijiri> which statement is the middle statement
14:38:15 <kadoban> Cuby96: You should really do a structured course, like cis194 or something. It'll start making much more sense.
14:38:20 <k0ral> is it an abuse of lenses to use Prism to implement parsers ?
14:38:27 <Aruro> Int->(Int->Int)
14:38:37 <ReinH> Cuby96: Let's start again with a statement that might simplify things for you.
14:38:44 <ReinH> Cuby96: All Haskell functions take a single argument
14:38:54 <Hijiri> Aruro: (Int -> Int -> Int) is not (Int -> (Int -> Int)) -> Int
14:38:59 <ReinH> So if we have a function like add n m = n + m
14:39:00 <Elite6809> @pl nr f x | (abs $ f x) < tol = x | otherwise = let y = f x; d = (f x - f (x + tol)) / tol; x0 = x + y / d; in nr f x0
14:39:00 <lambdabot> (line 1, column 29):
14:39:00 <lambdabot> unexpected " "
14:39:00 <lambdabot> expecting operator
14:39:05 <Hijiri> oh
14:39:08 <Hijiri> you meant middles of that
14:39:11 <ReinH> How can we say that add takes a single argument?
14:39:13 <Aruro> Hijiri: yes
14:39:16 <Hijiri> I thought you meant a middle line or something
14:39:18 <Hijiri> sorry
14:39:24 <Aruro> Hijiri: :)
14:39:27 <ReinH> It is because when we say add 1 2, it is evaluated as (add 1) 2
14:39:38 <Aruro> ReinH: you still did not tell me you playing fugues ? :)
14:39:43 <ReinH> add takes 1, which produces a function which takes 2
14:39:54 <ReinH> Aruro: Not often
14:40:14 <ion> Elite6809: Nothing good can come from @pl’ing something anywhere near as complex as that even if it “worked”.
14:40:25 <Elite6809> ion: I wanted to see if it would work at all :)
14:40:38 <ReinH> Cuby96: does that make sense?
14:41:01 <Cuby96> well it cant take one arg cause its two args isnt it?
14:41:15 <Aruro> it can
14:41:16 <ReinH> Cuby96: How many args does add take in (add 1) ?
14:41:19 <Aruro> thats what he wants to say
14:41:37 <Cuby96> well 2 cause addition needs 2
14:41:40 <ReinH> @let add :: Int -> Int -> Int; add = (+)
14:41:41 <lambdabot>  Defined.
14:41:54 <ReinH> Cuby96: Where's the second argument?
14:42:37 <Cuby96> n and m are arguments? :) idk i hionk they are both
14:42:43 <Cuby96> *think
14:42:52 <ReinH> Cuby96: Yes, but if add takes two arguments, how is (add 1) a valid expression?
14:42:55 <ReinH> :t add 1
14:42:56 <lambdabot> Int -> Int
14:43:09 <ReinH> I can apply add to a single argument
14:43:23 <ReinH> Cuby96: Let's rewrite add a bit to make this more clear
14:43:28 <ReinH> add n = \m -> n + m
14:43:33 <ReinH> how many arguments does add take now?
14:44:38 <Aruro> Cuby96: arguments are two indeed but they are always taken step by step so each time you produce function with less arguments
14:44:51 <ReinH> Aruro: please
14:44:54 <Aruro> :D
14:45:16 <Cuby96> what does \m mean?
14:45:18 <Aruro> ReinH: you are overexplaning clearly. He will figure out currying later
14:45:27 <ReinH> Cuby96: it's syntax for an anonymous function
14:45:34 <ReinH> > (\x -> x + 1) 2
14:45:34 <Aruro> ReinH: you see.
14:45:35 <lambdabot>  3
14:45:54 <Aruro> Cuby96: its argument of lambda=anonymous function
14:45:59 <ReinH> Also two thirds of metal hands \m/, but that's irrelevant
14:46:01 <JagaJaga> Reading non ascii file and getting `hGetContents: invalid argument (invalid byte sequence)`. What's the way to fix it?
14:46:12 <ReinH> Aruro: You are determined to confuse Cuby96, aren't you?
14:46:31 <arkeet> JagaJaga: you're trying to read it as a utf8 string I guess.
14:46:31 <Cuby96> well.... yes, sry... ._.
14:46:33 <Aruro> ReinH: i will give you half hour :) go.
14:47:00 <kadoban> ReinH: Not to be a dick, but … are you having better luck alone? He really needs to do some basic haskell learning, IMO.
14:47:11 <Aruro> kadoban: indeed
14:47:12 <ReinH> Cuby96: So add n = \m -> n + m makes it more clear that (add 1) produces a function. If we substitute in n, add 1 = \m -> 1 + m
14:47:33 <ReinH> kadoban: I guess I'll find out once I have a chance to try.
14:47:49 <napping> JagaJaga: try checking with hGetEncoding
14:48:01 <JagaJaga> arkeet: so how to fix it? The problem is that readFile is inside a library..
14:48:04 <ReinH> Cuby96: so add 1 produces a function that adds 1 to somethimg
14:48:06 <Aruro> ReinH: we are all quiet now, try :)
14:48:10 <arkeet> JagaJaga: mmm ...
14:48:16 <ReinH> Cuby96: does that make sense?
14:48:23 <napping> JagaJaga: that's just a readFile?
14:48:33 <arkeet> what library?
14:48:34 <JagaJaga> napping: not sure :(
14:48:39 <Cuby96> ah now i see, from something adding 1 right?
14:48:43 <arkeet> how are you using the library?
14:48:47 <JagaJaga> napping: arkeet: https://hackage.haskell.org/package/directory-tree-0.12.0/docs/System-Directory-Tree.html
14:48:49 <ReinH> Cuby96: right
14:49:02 <ReinH> Cuby96: (add 1) takes a number and adds 1 to it
14:49:08 <ReinH> just like add_1 m = 1 + m does
14:49:13 <JagaJaga> napping: arkeet: just using readDirectoryWith
14:49:36 <JagaJaga> napping: arkeet: and not trying to print the result. Problem is in reading :(
14:49:37 <Cuby96> okay got it ^^
14:49:37 <arkeet> that sounds strange, since it says it's using ByteString.readFile
14:49:38 <napping> that takes a function to read the file with, right?
14:49:45 <ReinH> Cuby96: we could write a bunch of functions, add_2 m = 2 + m, and so on, or we could use (add 2) (add 3) (add 4)
14:49:53 <ReinH> They will behave the same
14:50:10 <arkeet> oh never mind
14:50:13 <arkeet> that's an example
14:50:16 <ReinH> Cuby96: add, in this sense, is an "adder factory". It takes a number and produces a function that adds that number to something.
14:50:17 <JagaJaga> arkeet: napping: well, try it with undofiles of vim (like .foo.un~)
14:50:30 <arkeet> what is the function you are passing to readDirectoryWith?
14:50:32 <Cuby96> okay :)
14:50:41 <ReinH> Cuby96: Once we apply that second number, we get the typical use of add
14:50:44 <napping> JagaJaga: sounds like the encoding stuff you can read about at System.IO
14:50:45 <ReinH> > (add 1) 2
14:50:47 <lambdabot>  3
14:51:05 <Cuby96> so we have to replace the general 1 with another function right?
14:51:11 <napping> in particular that you are reading a binary file that isn't valid as utf8, or whatever your default encoding is
14:51:22 <ReinH> Cuby96: recall the definition: add n = \m -> n + m
14:51:28 <JagaJaga> arkeet: I've tried simple readDirectory, now trying with function that checks name of the file and returns " " if it is like .foo.un~
14:51:34 <ReinH> Cuby96: it already replaces n with the number you provide
14:51:46 <Cuby96> oh i see
14:51:46 <arkeet> readDirectory = readDirectoryWith readFile
14:51:53 <ReinH> Cuby96:  so (add 1) replaces n with 1 in the right hand side
14:51:57 <napping> yeah, that
14:52:03 <arkeet> readFile reads a file into a string, using the default encoding. which is probably utf-8.
14:52:39 <Cuby96> so its like m += m right?
14:52:41 <JagaJaga> arkeet: yeah, now I have smth like `readDirectoryWith (\file -> if file has a suffix like "un~" then return "" else readFile "")`
14:52:45 <ReinH> Cuby96: No, it's just a function
14:52:51 <ReinH> It doesn't assign anything
14:53:05 <Cuby96> oh sry... ^^
14:53:07 <ReinH> Cuby96: I just mean that you can think of it as an equation
14:53:11 <ReinH> when you think about how it works
14:53:23 <napping> JagaJaga: how about something like ByteString.readFile that doesn't try to decode as text?
14:53:26 <Cuby96> okay
14:53:30 <ReinH> add n = \m -> n + m so add 1 = \m -> 1 + m
14:53:51 <ReinH> Cuby96: this is what Haskell does when it evaluates add 1
14:54:09 <Cuby96> okay, got it  :)
14:54:23 <ReinH> Now if you supply (add 1) with another argument, you get (add 1) - \m -> 1 + m so (add 1) 2 = 1 + 2
14:54:39 <JagaJaga> napping: hmm, using string everywhere in my program :/
14:55:00 <JagaJaga> arkeet: I'm guessing why does it try to read this file...
14:55:06 <ReinH> Cuby96: In Haskell, function application always parenthesizes to the left, so add 1 2 = (add 1) 2
14:55:09 <arkeet> JagaJaga: because that's what readDirectory does.
14:55:11 <napping> The bigger question is what you want to do with the data in those files
14:55:17 <arkeet> it reads all the files in a directory into a tree structure.
14:55:26 <ReinH> Cuby96: So it looks like add takes two arguments, when strictly speaking it evaluates a single argument at a time
14:55:31 <JagaJaga> arkeet: I'm talking about readDirectoryWith
14:55:33 <Cuby96> ah now i see
14:55:37 <napping> If you want to only open some, or make a handle or what
14:55:49 <ReinH> Cuby96: So the type works the same way, but it's a mirror image
14:55:50 <arkeet> JagaJaga: well, readDirectoryWith runs whatever action you supply, on each file.
14:55:53 <napping> readDirectoryWith just calls the function you give it on each non-directory file
14:55:55 <ReinH> :t add
14:55:56 <lambdabot> Int -> Int -> Int
14:55:56 <arkeet> and collets the results into a tree.
14:55:57 <ReinH> :t add 1
14:55:58 <lambdabot> Int -> Int
14:56:02 <napping> you could pass "return" to give just a tree of file names, if you wanted
14:56:12 <ReinH> Cuby96: in the type, the parenthesis are applied from the *right*
14:56:16 <JagaJaga> arkeet: I know that and I've wrote my function above :)
14:56:18 <arkeet> if you don't want to read any files, don't pass a function that reads a file.
14:56:32 <ReinH> so add :: Int -> (Int -> Int) and add 1 :: Int -> Int because the first Int on the left is already applied
14:56:40 <JagaJaga> arkeet: in my function I'm reading only "good" files
14:56:51 <Cuby96> so application left and -> right,isn't it?
14:56:52 <arkeet> okay, well clearly you are reading a file that isn't good.
14:57:03 <napping> You can use openBinaryFile to get a Handle for a binary file
14:57:12 <ReinH> Cuby96: yes
14:57:24 <napping> JagaJaga: what is "good"?
14:57:27 <ReinH> Cuby96: So that's why Int -> Int -> Int = Int -> (Int -> Int) and why add 1 2 = (add 1) 2
14:57:46 <arkeet> napping: doesn't that still try to decode utf-8 though?
14:57:51 <JagaJaga> napping: not ".foo.un~"
14:57:59 <Cuby96> okay, another example would be nice so i know it perfectly
14:58:11 <arkeet> it just avoids CRLF translation
14:58:45 <ReinH> Cuby96: Well, let's look at a function that does take a function, so we can see the difference
14:58:46 <arkeet> JagaJaga: well, maybe pass it something that prints the filename before attempting to read it
14:58:48 <napping> also opens it with no codec
14:58:51 <arkeet> JagaJaga: then you can tell which file is the problem
14:59:00 <ReinH> Cuby96: Let's define apply f x = f x
14:59:03 <arkeet> napping: what is no codec?
14:59:19 <JagaJaga> arkeet: ok, I'll try 
14:59:21 <napping> no encoding
14:59:28 <ReinH> Cuby96: So this is a function that performs function application
14:59:30 <arkeet> there is no "no encoding", String is a list of unicode characters.
14:59:31 <sinelaw> dolio, how about this: A = (T -> (forall a. a -> a))   vs.  B = (forall a. T -> a -> a)  - from what I understand, they are equvialent under subsumption?
14:59:37 <napping> they call it "encoding" in the source
14:59:38 <arkeet> you need to translate a sequence of bytes to that somehow.
14:59:40 <ReinH> Cuby96: does that definition make sense?
14:59:44 <sinelaw> *equivalent
14:59:56 <napping> arkeet: it's equivalent to setting char8 encoding
15:00:19 <arkeet> okay
15:00:31 <arkeet> but you probably shouldn't be using String then.
15:00:39 <arkeet> I see it in the source now.
15:00:42 <napping> that's why I asked what the data is for
15:00:47 <napping> yeah, that's where I got "codec"
15:01:00 <napping> but haddocs reference hSetBinaryMode, and that explains it nicer
15:01:12 <arkeet> mhm
15:01:35 <Cuby96> hm... lets see: apply f x = f x means Int->(Int->Int) right?
15:01:38 <napping> JagaJaga: anyway, you can either check out some of the encoding stuff in System.IO to read stuff directly, or catch those exceptions in your callback to avoid this kind of thing generically
15:01:44 <ReinH> Cuby96: Well, let's see.
15:01:54 <ReinH> Cuby96: First, I haven't said what type x is, or what sort of function I'm applying
15:01:59 <JagaJaga> napping: nice. Gonna check this way too
15:02:15 <ReinH> Cuby96: But let's say that X is an Int and f takes an Int (it would have to in order to apply it to x) and produces an Int
15:02:20 <ReinH> er, x is an Int
15:02:37 <napping> JagaJaga: Relying on the name seems like a bit too strong an assumption to me
15:02:41 <ReinH> Cuby96: so we have the types of the arguments. x :: Int, f :: Int -> Int
15:02:47 <ReinH> Cuby96: right?
15:03:13 <napping> Of course, without knowing anything about the program it might be reasonable, if this is for personal use or a very restricted environment or something
15:03:22 <Cuby96> yup cause x is the Int and f the function, right? :)
15:03:36 <arkeet> or you can read it into a ByteString or something.
15:03:38 <JagaJaga> napping: that's an example, indeed there is a function that checks infix and suffix of the name, because I need just files with special names
15:03:47 <ReinH> Cuby96: yep, so apply f x if f :: Int -> Int and x :: Int, do we have apply :: Int -> (Int -> Int)? Which one is f and which one is x?
15:04:06 <ReinH> Cuby96: remember that it takes the function first
15:04:53 <Cuby96> Int->(~) is f and Int->Int is x??
15:05:07 <ReinH> f is a function from Int to Int and x is an Int
15:05:16 <ReinH> f :: Int -> Int, x :: Int
15:05:52 <Cuby96> oh okay
15:06:13 <ReinH> So apply :: ???
15:06:21 <Aruro> Cuby96: which course are you taking?
15:06:58 <Cuby96> Aruro: c.science
15:07:03 <Cuby96> 2nd semester
15:07:04 <ReinH> Cuby96: Int -> (Int -> Int) would be read as a function that takes an Int and produces a function from Int to Int
15:07:20 <napping> JagaJaga: shake has some nice file pattern stuff for that, but I don't see any way to use it outside of the build system
15:08:04 <ReinH> Cuby96: Our function *takes* a function, though.
15:08:17 <ReinH> rather than producing one
15:08:28 <Aruro> Cuby96: would be very usefull to discuss all this in person with Prof. or teachers, real life discussion has much bigger impact
15:09:59 <Cuby96> ReinH: okay, so to the equation again twice (frac 2) (dec 16) i haveto handle the dec first then twice and then frac right?
15:11:04 <ReinH> Cuby96: Well, you have to handle twice, and then whether you handle frac or dec depends on what twice does.
15:11:15 <ReinH> twice could ignore both of its arguments, in which case neither frac or dec would be evaluated
15:11:37 <Cuby96> its frac f n = f (f n)
15:11:42 <ReinH> twice _ _ = () doesn't care what frac or dec do
15:12:08 <ReinH> I think you mean twice?
15:12:33 <Cuby96> ah yeah my bad sry
15:13:40 <ReinH> so given twice f n = f (f n), twice (frac 2) (dec 16) would be evaluated as: (frac 2) ((frac 2) (dec 16)), except that the result of evaluating  (frac 2) will be shared.
15:14:10 <ReinH> What happens next depends on the definition of frac
15:14:57 <oconnore> when I'm using c2hs, how do I import a C header file? {#import ... #} expects .chi(?) files, and {#get #} and {#set #} can't find my struct
15:15:16 <Cuby96> we say that its frac n z = z `div` n with Int ->Int->Int even the last must me double but we have to take that as given
15:15:21 <monochrom> is it simply #include <x.h> ?
15:15:23 <arkeet> oconnore: don't you just do #include
15:15:38 <ReinH> For instance, frac 2 might ignore its argument:
15:15:41 <ReinH> > let twice f n = f (f n) in twice (const 1) undefined
15:15:42 <lambdabot>  1
15:16:21 <Cuby96> yeah
15:16:29 <Cuby96> i think so too
15:16:40 <k0ral> is there a way to report errors in (Either e) rather than Maybe when using Prism from lens ?
15:17:17 <c_wraith> k0ral: what would e possibly be?
15:17:18 <k0ral> when composing many Prism's, it is useful to know which one failed
15:17:39 <oconnore> oh, yeah, it is, thanks monochrom and arkeet. I still can't find where it's documented, but it works! :)
15:17:41 <k0ral> c_wraith: Exception e => e, for example
15:17:50 <ReinH> k0ral: How do you expect a String representing the failed prism to be produced?
15:17:55 <ReinH> or an e of any kind
15:18:17 <c_wraith> k0ral: you realize you'd have to put the error message *in* the prism somewhere?
15:18:27 <sinelaw> which of the following subsumes the other (is more polymorphic than the other):
15:18:28 <sinelaw>     forall a b c. ((() ->            (a -> b)),    a) -> c
15:18:28 <sinelaw>     forall     c. ((() -> (forall d. (d -> d)), Bool) -> c
15:18:30 <c_wraith> k0ral: which would sort of ruin everything, since they're just functions.
15:18:54 <k0ral> ReinH: I would have defined prism' as "Exception e => (b -> s) -> (s -> Either e a) -> Prism s s a b"
15:18:58 <ReinH> sinelaw: Neither?
15:19:10 <sinelaw> ReinH, that's what I think...trying to nail why
15:19:16 <k0ral> c_wraith: yes, I realize that, and it looks fine to me
15:19:20 <sinelaw> the Bool vs. a there
15:19:25 <ReinH> k0ral: How do you expect prism' to produce an arbitrary e value?
15:19:26 <k0ral> c_wraith: cf the function type I provided above
15:19:31 <sinelaw> on the other hand the forall'ed result
15:19:32 <ReinH> sinelaw: The quantification
15:20:04 <ReinH> k0ral: That type states that prism' must be able to produce a value of whatever type e the caller specifies.
15:20:21 <c_wraith> k0ral: how is the prism supposed to know how to produce an error?  It's seriously just a function that fits a particular pattern.
15:20:44 <k0ral> ReinH, c_wraith: indeed, the type I've written is wrong
15:21:27 <k0ral> ReinH, c_wraith: should I give up on precise error handling ?
15:21:38 <ReinH> :t note
15:21:39 <lambdabot>     Not in scope: ‘note’
15:21:40 <lambdabot>     Perhaps you meant one of these:
15:21:40 <lambdabot>       ‘not’ (imported from Data.Bool),
15:22:07 <k0ral> ReinH: I guess you're referring to note from the errors package
15:22:15 <ReinH> Yep.
15:22:19 <Hijiri> Cuby96: Why do you think it's double
15:22:39 <k0ral> but where would you use it ? 
15:22:41 <Cuby96> cause the fraction is the most like double
15:22:45 <Hijiri> :t div
15:22:46 <lambdabot> Integral a => a -> a -> a
15:22:46 <k0ral> I mean, I don't want to break composability
15:22:56 <Hijiri> div takes two arguments, and gives one of the same type
15:23:05 <Hijiri> frac uses the output of div, and gives Ints as input
15:23:13 <Hijiri> so if you input Ints, the result has to be Int
15:23:44 <k0ral> I want to be able to write "x ^? prism1 . prism2 . prism3" but instead of getting a Maybe a, I would like an Either e a for some e
15:24:00 <k0ral> such that e tells me which of prism1, prism2, prism3 failed
15:24:30 <Hijiri> when I said the type signature was wrong earlier, the result being Int was fine
15:24:51 <Hijiri> The problem was the type signature was that it was (Int -> Int) -> Int -> Int rather than Int -> Int -> Int
15:25:11 <c_wraith> k0ral: But how could that possibly work without compile-time annotations of some sort?
15:25:45 <ReinH> c_wraith: How do you think this arbitrary e value is going to be generated by the prism?
15:25:58 <ReinH> Even if we fix our exception type to String. How is it generating the string?
15:26:03 <ReinH> er, k0ral ^
15:26:38 <sinelaw> ReinH, the problem is that the first type has forall a b. .... (a->b) which doesn't make sense as a type
15:26:51 <sinelaw> if it weren't for that, the other type would be more general
15:27:17 <k0ral> ReinH: I guess that would need a completely different set of lenses/operators
15:27:33 <Cuby96> Hijiri: oh i see, well my fault
15:27:58 <k0ral> ReinH: Prism and (^?) are designed to handle errors through Maybe, that's not good enough to me
15:28:01 <Hijiri> I didn't explain it all that well either
15:29:44 <k0ral> c_wraith: the annotation should be part of the prism definition, the same way a parser definition from Parsec can include text to describe the error in case it fails
15:29:58 <sinelaw> ReinH, in other words I think the question was bogus; the first type is not valid
15:30:31 <sinelaw> wait...nope. sorry 
15:30:39 <ReinH> k0ral: You could probably define your own composition operator that handles the eithers
15:30:56 <sinelaw> I confused it with something else, forget it
15:31:01 <ReinH> sinelaw: :)
15:36:13 <k0ral> ReinH: so you confirm there is nothing in the current lens API to fulfill my wish ?
15:37:05 <ReinH> k0ral: No, you're still running up on the whole "it's impossible to generate a String describing the failure for an arbitrary Prism" thing.
15:37:31 <ReinH> s/String/value
15:38:27 <ReinH> I also suspect that the cost of incorporating some sort of <?> type operator into the Prism type would be the composability you're trying to retain.
15:42:59 <arkeet> hm
15:46:20 <Pamelloes> What's a type family?
15:47:18 <shapr> edwardk: when did davean become a mentor?!
15:47:41 <c_wraith> Pamelloes: it's an interesting name for functions from types to types.
15:48:01 <shapr> davean: oh right, I remember having a beer with you once years ago after a Boston Haskell User's Group
15:48:16 <Pamelloes> c_wraith: Can you give me an example?
15:49:08 <c_wraith> Pamelloes: The most common use is called "associated type families", where you make a type family part of a class.
15:49:20 <ReinH> shapr: apparently just recently
15:49:29 <shapr> ReinH: neato
15:49:42 <Cuby96> ReinH: what does a typee of an expression mean?
15:51:04 <c_wraith> Pamelloes: class Container a where type Elem a ; getFirst :: a -> Maybe (Elem a) ...  ; instance Container (Maybe a) where type Elem (Maybe a) = a ; getFirst x = x
15:52:33 <c_wraith> Pamelloes: the important part is that each instance can define its own types.
15:52:48 <oconnore> why doesn't "cabal install --only-dependencies" pull down c2hs when it's listed as "build-tools: c2hs"?
15:52:51 <c_wraith> Pamelloes: http://research.microsoft.com/en-us/um/people/simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf has some more examples
15:53:06 <c_wraith> oconnore: you can add build dependencies that aren't haskell packages
15:53:22 <ReinH> c_wraith: build-tools is for executables, not (necessarily) for haskell packages
15:53:29 <ReinH> ugh
15:53:31 <ReinH> c_wraith: sorry again
15:53:33 <oconnore> also cabal sandbox hc-pkg list c2hs lists nothing
15:53:33 <Pamelloes> c_wraith: Thanks, I think I sort of understand, but I'll take a look at that link :)
15:53:34 <c_wraith> :)
15:53:43 <ReinH> I need to up my irc reply game
15:53:59 <oconnore> c_wraith: if I do that it re-installs every time
15:53:59 <c_wraith> oconnore: c2hs is a binary, not a library
15:54:17 <oconnore> aka cabal can not detect that it already installed c2hs
15:54:21 <oconnore> yeah
15:56:44 <ReinH> oconnore: It detects that an executable with the name given is in the path
15:57:05 <ReinH> It doesn't care whether it's from a cabal package or not
15:57:08 <oconnore> ReinH: ah, so I need to add .cabal-sandbox/bin to my path and it will work?
15:57:15 <oconnore> cool
15:57:17 <ReinH> oconnore: Probably.
15:57:19 <oconnore> thanks ReinH 
15:57:56 <oconnore> I wish it would check the version constraint for executables... but meh
15:57:57 <ReinH> Or perhaps as an argument to cabal that I can't remember or be bothered to look up :D
15:58:15 <oconnore> ok
16:02:47 <k0ral> Pamelloes: the first time I learned about type families, it made me think of typedef-s in C++ (as in "map<from, to>::value_type"); but maybe it's risky to venture such an analogy in this channel :)
16:05:48 <davean> shapr: When sclv strong-armed me into making sure that project had one
16:06:38 <shapr> davean: ah, excellent :-)
16:06:48 <davean> shapr: why?
16:07:12 * hackagebot snap-cors 1.2.8 - Add CORS headers to Snap applications  http://hackage.haskell.org/package/snap-cors-1.2.8 (OliverCharles)
16:07:39 <shapr> davean: just didn't know you'd become an active member of the Haskell community, that's all
16:07:50 <davean> shapr: I try not to admit it
16:08:08 <shapr> davean: ha, fair enough
16:08:13 * shapr finds https://github.com/davean
16:12:13 * hackagebot chart-histogram 1.0.0 - Easily render histograms with Chart  http://hackage.haskell.org/package/chart-histogram-1.0.0 (BenGamari)
16:17:07 <AfC> Does the changelog link on a hackage package page link to a text file named ChangeLog or CHANGELOG.*, or... ? [trying to figure out what to call it before next upload]
16:19:34 <Cale> AfC: http://stackoverflow.com/questions/21076759/how-to-add-a-changelog-to-a-cabal-package/21076816#21076816
16:19:49 <Cale> AfC: I think it's really weird that the .cabal file doesn't have a field for it.
16:22:13 * hackagebot agum 2.6 - Unification and Matching in an Abelian Group  http://hackage.haskell.org/package/agum-2.6 (JohnRamsdell)
16:22:15 * hackagebot cmu 1.10 - Unification in a Commutative Monoid  http://hackage.haskell.org/package/cmu-1.10 (JohnRamsdell)
16:22:17 * hackagebot hspec-core 2.1.7 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-core-2.1.7 (SimonHengel)
16:27:13 * hackagebot hspec-discover 2.1.7 - Automatically discover and run Hspec tests  http://hackage.haskell.org/package/hspec-discover-2.1.7 (SimonHengel)
16:27:15 * hackagebot hspec 2.1.7 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-2.1.7 (SimonHengel)
16:35:47 <athan> Should I cite the 2010 haskell report to SPJ or Marlow? :\
16:36:25 <monochrom> what does its title page say?
16:37:21 <SrPx> Is there any way to **desperately** ask GHC to apply SCE whenever possible? I don't understand why it doesn't convert `foo x = foo (x-1) + foo (x-1)` into `foo x = let fx = foo (x-1) in fx + fx`.
16:38:07 <athan> monochrom: but SPJ is "the maker", "the one"
16:38:30 <monochrom> but what does its title page say?
16:38:32 <SrPx> I mean, I thought that was one of the reasons we liked purity at all. I don't understand why GHC don't apply all those great optimizations that only haskell can do for being pure
16:38:39 <athan> monochrom: that Marlow is the editor ._.
16:39:24 <glguy> Since Marlow is already listed on the title page and SPJ isn't you should probably just go ahead and make it fair and cite SPJ
16:39:41 <AfC> Cale: thanks
16:40:00 <monochrom> then it is Marlow. you can make it clear that he's editor, not author. but it's Marlow.
16:40:13 <athan> thank you monochrom
16:40:25 <enthropy> SrPx: maybe it's not always an optimization
16:40:38 <monochrom> I disagree with glguy. the problem is that if someone asks you, "why is SPJ's name there? I can't find it on the title page", then what you will answer?
16:40:46 <monochrom> "I know from a secret channel"?
16:40:51 <SrPx> I fail to visualize when it wouldn't be an optimization
16:41:27 <glguy> I agree with monochrom's disagreement with a sarcastic comment
16:44:17 <int-e> SrPx: if you compute sum ([1..10000] ++ [1..10000]), then that'll be quite efficient, but not if the two lists are turned into a single expression (whence they become shared, causing a ton of allocation)
16:46:45 <SrPx> I don' get it, how the list becoming the same expr will cause more allocation
16:47:36 <arkeet> because it will have to hold the entire list in memory when it's halfway through.
16:47:55 <geekosaur> because if each is separate then it can go throiugh each list and throw away the part already done, while the rest is an uncomputed thunk
16:48:01 <johnw> when not shared, it only needs a single cons cell in memory at a time
16:48:10 <int-e> SrPx: "allocation" is not the right term, I mean "residency". (to actually affect allocation we need to talk about fusion...)
16:48:10 <geekosaur> if they're shared then the whole first list is held in memory so it can be passed through again the second time
16:48:36 <arkeet> right, sharing will allocate less stuff, but it will have to hold more stuff at once.
16:48:47 <SrPx> hmm... okay I guess
16:49:04 <SrPx> so I can assume that if I'm not doing it manually then two identical expressions are computed twice, always
16:49:20 <monochrom> that may also be wrong to assume
16:49:29 <int-e> https://wiki.haskell.org/Performance/GHC#Common_subexpressions quotes SPJ on this
16:49:36 <geekosaur> reasoning about this is tricky. doing it by rule like a compiler needs to is even tricker. so ghc and most othher compilers don't even try
16:49:37 <SrPx> ah okay
16:49:53 <int-e> (there must be a better source but that's what google offered me on short notice)
16:50:04 <geekosaur> so if you want sharing you need to do it explicitly with a let-binding
16:51:12 <int-e> SrPx: well, there is the opportunistic CSE thing. Even that can cause space leaks, which is why ghc has an -fno-cse flag to switch even that little CSE off.
16:53:52 <monochrom> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/103616/ shows that GHC can add more sharing than your code asks for
16:54:24 <monochrom> the correct conclusion is that GHC will unshare when you want sharing, and share when you don't want sharing.
16:55:12 <monochrom> there is no correct assumption, except for the Murphy law assumption.
17:02:15 * hackagebot rainbow 0.26.0.2 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.26.0.2 (OmariNorman)
17:06:17 <indiagreen> ReinH: this took me embarrassingly long time, but I think errors can be added to prisms
17:06:18 <indiagreen> http://lpaste.net/131594
17:09:56 <ReinH> indiagreen: huh
17:10:42 <indiagreen> one problem here, however, is that all prisms (actually traversals) in the chain have to be annotated, or else you will get the last error from an annotated traversal, as opposed to the last error from a failing traversal
17:10:55 <acmiyaguchi> If I wanted to redefine (!!) as an excercise, how would I do it without having the name clash?
17:10:58 <indiagreen> it could possibly be worked around, but I don't know because I'm sleepy
17:11:28 <indiagreen> no, wait, actually not traversals
17:11:31 <indiagreen> just getters
17:11:31 <ReinH> acmiyaguchi: import Prelude hiding ((!!))
17:11:42 <acmiyaguchi> ReinH: Thanks!
17:16:41 <mamamarrrio> Hello haskellers...running into troubles with LYAH and GHCI. the book is telling me to input "ghci> let g = (\x -> return (x+1)) <=< (\x -> return (x*100))" but its giving me bullshit..its saying
17:16:48 <mamamarrrio> "No instance for (Monad m0) arising from a use of `<=<'"
17:16:56 <mamamarrrio> I've already imported Control.Monad
17:17:00 <mamamarrrio> I'm not sure what else to do.
17:17:15 * hackagebot prednote 0.36.0.2 - Evaluate and display trees of predicates  http://hackage.haskell.org/package/prednote-0.36.0.2 (OmariNorman)
17:17:53 <mamamarrrio> Is <=< syntactic sugar for something else?
17:18:30 <MP2E> mamamarrrio: it's not <=< that is incorrect here, it's that it doesn't know which Monad instance to pick because you're the type of numbers in Haskell is 'Num a => a'
17:18:41 <MP2E> mamamarrrio: in other words, you need to constrain one of the numbers to Int or something
17:18:44 <MP2E> and it should work
17:19:00 <mamamarrrio> Doh!
17:19:07 <MP2E> er wait also
17:19:14 <monochrom> mamamarrrio: which version of ghc?
17:19:17 <MP2E> actually that's kind of incorrect because a is the value but that would have bit you too
17:19:27 <MP2E> also the m seems unspecified here
17:19:29 <MP2E> what should return be returning?
17:19:31 <MP2E> a list?
17:19:35 <mamamarrrio> it is ancient
17:19:37 <mamamarrrio> version 7.6.3
17:19:51 <monochrom> ok, I'll try 7.6.3
17:19:53 <verement> :t (\x -> return (x+1)) <=< (\x -> return (x*100))
17:19:54 <lambdabot> (Monad m, Num c) => c -> m c
17:20:15 <mamamarrrio> ok, if I say "ghci> let g = (\x -> return (x+1)) <=< (\x -> return (x*100))" and I say "ghci> Just 4 >>= g" its supposed to return "Just 401"
17:20:22 <MP2E> ah
17:20:58 <monochrom> ok, does ghc 7.6.3's Control.Monad have <=< to begin with?
17:21:07 <monochrom> err nevermind, it does
17:21:08 <mamamarrrio> That's a good question. Let me see.
17:21:12 <mamamarrrio> ok
17:21:17 <mamamarrrio> Yeah I have no idea what's going on.
17:22:25 <monochrom> to my knowledge ghci never accepted it at or before 7.8, so I don't know why LYAH suggested that example.
17:23:21 <monochrom> there is a "monomorphism restriction" which says that if this definition doesn't make clear which Monad instance to use, then it is an error. among other things.
17:24:13 <mamamarrrio> ok
17:24:24 <mamamarrrio> quick question
17:25:05 <verement> mamamarrrio: you can do ghci> let g = (\x -> return (x+1)) <=< (\x -> return (x*100)) in Just 4 >>= g
17:25:32 <mamamarrrio> suppose i'm running debian jessie, and I apt-get install haskell-platform...could I just up and replace the GHC that comes with it, with binaries for a newer version of GHC? Do you know if the dependencies won't go wonky?
17:25:35 <mamamarrrio> ok let me try
17:25:58 <mamamarrrio> :verement thank you so much
17:26:13 <verement> mamamarrrio: I am running jessie with a local 7.10.1 install, works fine
17:26:57 <mamamarrrio> :verement ok that is encouraging...I'm going to try a new version of GHC when I get home
17:27:18 <chasm> hi all - what I think is a simple lens type question? http://lpaste.net/131597
17:29:12 <enthropy> mamamarrrio: you don't need a new ghc to make it work. You can ":set -XNoMonomorphismRestriction" and the definition will be accepted as-is
17:29:16 <dmj`> can someone else try to cabal install vector-algorithms from hackage, keeps erroring out on me, osx ghc-7.8.3 cabal-1.22
17:30:29 <enthropy> chasm: if you use (cloneLens l) instead of l that'll solve one of your problems
17:31:27 <mamamarrrio> :enthropy thank you so much...is this something I should set in general when I start up ghci? Why did the author LYAH expect me to have set this on my own?
17:32:15 <enthropy> maybe it is described somewhere, or maybe it is a mistake that the author forgot to mention it
17:33:44 <enthropy> mamamarrrio: if you want it enabled all the time you can put that line in your .ghci file
17:36:52 <chasm> enthropy: thanks, I updated the lpaste... cloneLens lets the definition be accepted but then I get a type error when I try to run the example?! but I didn't know about cloneLens so at least I have something to start looking at, thanks 
17:37:50 <mamamarrrio> :enthropy cool...I had no idea ghci supported config files...gonna have to look for other stuff that might be convenient to add
17:39:55 <indiagreen> > (4, "hello") & _2 (take 3)
17:39:57 <lambdabot>  [(4,'h'),(4,'e'),(4,'l')]
17:40:02 <indiagreen> chasm: ^
17:41:30 <indiagreen> > traverseOf _2 (take 3) (4, "hello")  -- alternative version
17:41:32 <lambdabot>  [(4,'h'),(4,'e'),(4,'l')]
17:43:36 <chasm> indiagreen: wow so straightforward ty
17:47:17 * hackagebot http-common 0.8.2.0 - Common types for HTTP clients and servers  http://hackage.haskell.org/package/http-common-0.8.2.0 (AndrewCowie)
17:47:19 * hackagebot http-streams 0.8.3.1 - An HTTP client using io-streams  http://hackage.haskell.org/package/http-streams-0.8.3.1 (AndrewCowie)
18:03:56 <SwashBuckla> the Monoids chapter in LYAH begins with SIX PAGES on the difference between `type', `newtype' and `data'
18:03:59 <SwashBuckla> :(
18:04:08 <SwashBuckla> it doesn't seem particularly relevant
18:04:34 <SwashBuckla> unless there is some point I have missed?
18:05:02 <geekosaur> I think that's the first place where it becomes relevant?
18:05:30 <geekosaur> because you can't make Monoid instances for `type`s and you can use `newtype` to make multiple Monoid instances
18:06:01 <geekosaur> (not just true of Monoid but again, that's where it becomes relevant to LYAH)
18:08:14 <athan> @learn SwashBuckla
18:08:14 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
18:08:21 <athan> Maybe that might give you better info? :)
18:08:54 <geekosaur> @where cis194
18:08:54 <lambdabot> http://www.seas.upenn.edu/~cis194/fall14/spring13/index.html
18:15:36 <travgmon> I’m getting an error at encipher l, that expected type IO Char but actual type IO String, I thought they were the same? http://lpaste.net/5196424594344378368
18:16:01 <geekosaur> String is [Char] not Char
18:16:43 <geekosaur> also you have your let and your <- reversed
18:16:53 <geekosaur> getLine is in IO, needs <-
18:17:13 <geekosaur> encipher is pure, needs let
18:18:04 <geekosaur> as written, I suspect it assumes that it's in the list monad (since that's the only one that could be applicable to [Char]), so you get the mismatch because <- is producing a Char via the list monad
18:19:18 <travgmon> Hmm I’m not understanding what needs changing for that
18:19:42 <geekosaur> l <- getLine
18:19:49 <geekosaur> let e = encipher l
18:20:11 <geekosaur> I even told you why; you should try to understand what I said, or you will keep using the wrong ones and being confused
18:21:47 <travgmon> Ah, ok
18:21:57 <travgmon> Thank you
18:21:59 <Welkin> travgmon: avoid using the syntactic sugar while first learning
18:22:04 <Welkin> don't use <-
18:22:10 <Welkin> use the desugared version
18:22:21 <Welkin> a lambda with bind (>>=)
18:23:59 <fuzzyhorns> newb query: i have some haskell libs installed globally (to support syntastic, is that wrong?) and i have a sandbox i've initialized in a project, which when i try to install to, shows conflicts with things installed globally
18:24:03 <travgmon> so is the list monad still returning a list that is why e is a list of a list?
18:24:22 <fuzzyhorns> im confused about that because id think a sandbox would be its own separate thing?
18:24:28 <fuzzyhorns> also feel free to tell me to go find a cabal channel :x
18:24:39 <geekosaur> global packages are shared and available in all sandboxes
18:24:53 <geekosaur> and must be, because you can't install base in a sandbox
18:25:02 <geekosaur> base can only be installed with the ocmpiler
18:25:03 <Welkin> travgmon: what is the list monad?
18:25:04 <fuzzyhorns> geekosaur: so, i prob should remove all the global ones that conflict then?
18:25:05 <geekosaur> *compiler
18:25:23 <fuzzyhorns> geekosaur: in which case, how do i make ghc-mod and hdevtools available to syntastic in vim? :<
18:25:33 <Welkin> travgmon: do you mean the list instance for (>>=)?
18:25:48 <geekosaur> fuzzyhorns, build them in sandboxes and copy the executables out of the sandboxes
18:25:55 <geekosaur> they shouldn't need the deps at runtime
18:26:00 <fuzzyhorns> ahhhh duh
18:26:02 <fuzzyhorns> that makes sense
18:26:09 <travgmon> No, I’m just really confused trying to understand IO
18:26:15 <fuzzyhorns> any tips on nuking the globals?
18:26:23 <geekosaur> travgmon, you were telling it to use the wrong monad when you used <- on the String
18:26:41 <geekosaur> which made it a Char because the list was used as the monad
18:26:59 <travgmon> geekosaur: I changed it and if I try to putStrLn e it says expected type String but actual type [[Char]]
18:27:08 <travgmon> Ah
18:29:22 <geekosaur> this is because you're using return in rot13
18:29:51 <geekosaur> again it seems to be asusming you meant the list monad because nothing else would typecheck
18:30:02 <geekosaur> except that then fails to typecheck at putStrLn
18:30:58 <geekosaur> also I just noticed that rot13 doesn't :) but maybe you're just getting the basic program working before you address that part?
18:31:24 <travgmon> Yeah I haven’t even been able to test it yet
18:31:30 <travgmon> thanks I appreciate the help!
18:31:33 <geekosaur> oh, no, sorry, it works
18:32:18 <geekosaur> no, I see it, it should work
18:32:34 <geekosaur> somehow I blurred alpha and cipher together when reading :/
18:33:00 <travgmon> Ah yeah worked :)
18:33:33 <travgmon> I got all “I can do this” after reading a gentle introduction to haskell on the part on IO
18:33:33 <travgmon> :|
18:34:28 <geekosaur> gentle intro isn't quite so gentle :) and is somewhat out of date both in terms of the language it describes and in what the community has figured out about teaching Haskell
18:34:33 <geekosaur> @where cis194
18:34:33 <lambdabot> http://www.seas.upenn.edu/~cis194/fall14/spring13/index.html
18:34:55 <geekosaur> ^ this is a modern undergrad course in Haskell and is highly recommended these days
18:35:13 <travgmon> Oh awesome
18:38:12 <maldoror278> hola necesito una ayuda
18:39:50 <peddie> maldoror278: es mejor pedir en inglés si puedes
18:48:38 <kadoban> This is probably good. I have some code that builds against GHC ~5 that I'd like to get working. What's the odds that actually is going to happen XD
18:49:04 <simpson> maldoror278: Hay #haskell.es para hispanohablantes, pero es pequeño.
18:50:01 <maldoror278> ok
18:50:13 <Axman6> hispanohablantes <- spanish speakers?
18:50:51 <mjrosenb> kadoban: do you do anything with monads, IO, or the standard library?
18:51:17 <kadoban> mjrosenb: Well … it's code that parses haskell, and does a bunch of IO … and stuff with prelude probably :-/
18:51:50 <Axman6> sounds like a nice yak to shave =)
18:52:09 <kadoban> Probably, heh.
18:52:47 <simpson> Axman6: Yeah. I don't know if the word's often used, but it's the word I learned for that.
18:52:49 <kadoban> It also doesn't seem to use cabal … or at least there's no cabal file, so I have no godly idea what packages any of this could be from. This is going to be bad.
18:53:59 <Axman6> simpson: google gets confused when it's one work, but hispano hablantes translates to exactly spanish speakers. 
18:54:58 <sagittarian> does anyone know if there's a difference between runhaskell and runghc?
18:55:57 <jmcarthur> :t (~>)
18:55:58 <lambdabot>     Not in scope: ‘~>’
18:55:58 <lambdabot>     Perhaps you meant one of these:
18:55:58 <lambdabot>       data constructor ‘Seq.:>’ (imported from Data.Sequence),
18:56:27 <jmcarthur> @let f ~> g = (. f) . (g .)
18:56:28 <lambdabot>  Defined.
18:56:30 <jmcarthur> @let infixr 2 ~>
18:56:31 <lambdabot>  Defined.
18:56:43 <jmcarthur> :t runReaderT ~> (id ~> runReaderT) ~> ReaderT $ \m f r -> m r >>= ($ r) . f
18:56:44 <lambdabot> Monad m => ReaderT a2 m a1 -> (a1 -> ReaderT a2 m a) -> ReaderT a2 m a
18:56:54 <jmcarthur> realized today just how nestable that operator is
19:02:03 <Denommus> :k (~>) 
19:02:04 <lambdabot> Not in scope: type constructor or class ‘~>’
19:07:33 <Denommus> :t (~>) 
19:07:34 <lambdabot> (a -> b) -> (b1 -> c) -> (b -> b1) -> a -> c
19:08:42 <Denommus> (+1) ~> (+2)
19:08:50 <KaneTW> what's the ghc extension to allow -> as an operator
19:09:23 <KaneTW> oh it's not ->
19:09:30 <KaneTW> stupid font
19:31:38 <sagittarian> :t (~>)
19:31:39 <lambdabot> (a -> b) -> (b1 -> c) -> (b -> b1) -> a -> c
19:32:26 <sagittarian> hmm
19:33:32 <sagittarian> :t (flip .) (~>)
19:33:33 <lambdabot> (a -> b) -> (b -> b1) -> (b1 -> c) -> a -> c
19:36:14 <ElMoloko> What's the average delay between a GHC release and it being included in haskell-platform?
19:40:29 <sagittarian> ElMoloko: https://github.com/haskell/haskell-platform/wiki/ReleaseTimetable
19:42:15 <jle`> sagittarian: try using `which runhaskell`
19:42:43 <jle`> and then follow the symlink :)
19:43:37 <jle`> readlink -f `which runhaskell`
19:43:54 <jle`> spoilers: runhaskell is just a symlink to runghc
19:44:29 <sagittarian> okay, thanks jle`
19:44:45 <sagittarian> that doesn't *necessarily* mean that they have the same behavior
19:46:39 <ElMoloko> sagittarian: thanks!
19:47:37 <jle`> sagittarian: true :)
19:55:48 <joneshf-laptop> let's say you have some data you need to process, one of the fields tells you how to interpret the other fields, what's a good way to model this?
19:56:24 <jle`> joneshf-laptop: can you give an example?
19:56:41 <m_ryan> hi how do i convert "01/01/2015" to Day Type?
19:56:43 <Denommus> josephle: that field is a function? 
19:58:11 <m_ryan> hi how do i convert "01/01/2015" to Day Type? or UTCTime is that possible?
19:58:28 <jle`> m_ryan: you can try the parsing functions in http://hackage.haskell.org/package/time-1.5.0.1/docs/Data-Time-Format.html
20:01:14 <m_ryan> jle`: does formatime can convert the Date String to Day DataType? i thouhg it only returns String?
20:02:22 <joneshf-laptop> jle`, sure, i've got a grammar sort of like this: http://lpaste.net/131607
20:03:27 <pavonia> m_ryan: Have a look at the parse* functions in that module
20:03:40 <joneshf-laptop> josephle, i think that's the second time today, sorry :)
20:03:49 <benzrf> hummm
20:03:59 <joneshf-laptop> Denommus, no, it's just a string
20:04:06 <joneshf-laptop> Denommus, http://lpaste.net/131607
20:04:07 <benzrf> is there a library for typechecking and evaluating step-by-step expr trees
20:04:16 <benzrf> fr haskellish languages
20:04:22 <benzrf> or even haskell
20:04:23 <jle`> m_ryan: scroll down a bit more
20:04:25 <benzrf> argh
20:04:35 <benzrf> still need that
20:04:38 <benzrf> :|
20:04:56 <jle`> joneshf-laptop: it looks like a case for a monadic parser
20:05:22 <Denommus> josephle: create a parsing function that matches that field with what you expect, and each matching corresponds to a different treatment to your data 
20:05:53 <saml_> @pl Parser (\s -> first f <$> p s)
20:05:54 <lambdabot> Parser ((first f <$>) . p)
20:06:43 <jle`> Parser (fmap (first f) . p) i guess
20:07:00 <jle`> (fmap . fmap . first) f p      -- hehe
20:07:34 <joneshf-laptop> jle`, Denommus I guess I have two concerns abotu that though
20:07:41 <joneshf-laptop> or mauybe it's one concern 
20:08:00 <joneshf-laptop> when i parse a file, i get back a list of nodes
20:08:50 <joneshf-laptop> do I unify the nodes under one type?
20:09:12 <joneshf-laptop> like `data Node = FooNode Int Double Double | BarNode Int Double Double ...`
20:09:29 <Denommus> joneshf-laptop: yeah 
20:09:35 <joneshf-laptop> to me that seems like it might make it possible to then have a list with mismatching nodes
20:09:50 <joneshf-laptop> and I don't want that
20:10:47 <joneshf-laptop> so if i have the nodes separated out: `data FooNode = FooNode Int Double Double; data BarNode = BarNode Int Double Double; ...` then I have to have a different parser, yes?
20:11:15 <joneshf-laptop> `Parser (Either [FooNode] (Either [BarNode] [BazNode]))`
20:11:17 <joneshf-laptop> or something?
20:12:57 <Denommus> joneshf-laptop: why don't you make a type of the different lists? 
20:13:06 <Denommus> joneshf-laptop: lile 
20:13:52 <Denommus> joneshf-laptop: like data Foo = Bar [Blah] | Baz [Bleh]? 
20:14:26 <Denommus> joneshf-laptop: Either is not meant to replace algebraic data types of more than two variants 
20:14:38 <jle`> if only we had anonymous sums
20:15:05 <Denommus> jle`: like Ceylon? 
20:15:54 <jle`> not too familiar, but maybe :)
20:16:27 <Denommus> Kotlin also has it 
20:16:53 <jle`> i think swift has anonymous sums too
20:17:34 <jle`> at last we have anonymous products
20:19:45 <joneshf-laptop> Denommus, hmm, I think that might work,
20:22:18 <joneshf-laptop> except, I don't necessarily want lists
20:22:23 <jle`> anyone know who i can contact to add something to https://www.haskell.org/irc ?
20:24:05 <pavonia> jle`: https://github.com/haskell-infra/hl
20:24:15 <jle`> thanks :)
20:25:38 <joneshf-laptop> Denommus, so I'd like to be able to have `data Foo a b c = Foo a | Bar b | Baz c` but then the issue with this is that the types I'm parsing aren't closed. There might only be three today, but later more can be added and then I'd have to go through everything and update
20:27:06 <joneshf-laptop> this really feels like it's something that I could use http://okmij.org/ftp/Haskell/types.html#Prepose for, but I'm not entirely sure about it
20:27:24 <joneshf-laptop> or `reflection` apparently as I was suggested about earlier
20:27:46 <naudiz> can someone tell me how to increase the stack size for ghci?
20:28:18 <jle`> joneshf-laptop: i think this is related to the expression problem
20:28:27 <naudiz> it says I should use -K<size> but typing :set -K50000 gives me "Some flags have not been recognized: -K50000"
20:29:04 * dfeuer offers benzrf some tea.
20:29:20 <johnw> no caffeine for benzrf!
20:29:42 <jle`> is there any way we can get better error messages for the (x <= y) constraint
20:29:43 <dfeuer> benzrf, know ye that some of the biggest Idris experts tend to be in #idris an hour or two from now.
20:29:53 <jle`> right now the error message is "Cannot match 'True with 'False"
20:29:57 <jle`> like, thanks ghc
20:30:12 <dfeuer> :-)
20:30:54 <jle`> oh sorry, "Cannot match 'False with 'True"
20:31:04 <joneshf-laptop> jle`, it does seem that way doesn't it
20:31:17 <naudiz> I can't find anything helpful about increasing the stack size :/
20:31:28 <jle`> expected type: 'True,  actual type: x <= y
20:31:39 <jle`> i mean if i knew what was going on i could probably figure it out with the help of that last line
20:31:49 <jle`> but i feel like something more meaningful could happen here
20:31:51 <dfeuer> jle`, well then, that's a *much* better message. Pshaw.
20:31:53 <dfeuer> :P
20:32:28 <jle`> haha.  well the second line gives you somewhat of a clue...at least it tells you what type/type function is giving problems
20:32:31 <jle`> but still v.v
20:32:37 <jle`> oh
20:32:58 <jle`> i think it might be because of how (<=) is defined... maybe i shouldn't use it
20:33:36 <jle`> CmpSymbol x y ~ LE probably gives better errors
20:33:40 <jle`> not as pretty though
20:34:35 <joneshf-laptop> jle`, isn't `(<=)` supposed to go away?
20:34:43 <pavonia> naudiz: e.g. "ghci +RTS -K1G" for setting it to 1GB
20:34:50 <jle`> <=? is supposed to go away, but <= doesn't have the same note >_>
20:34:58 <joneshf-laptop> oh
20:35:00 <pavonia> naudiz: See also https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime-control.html
20:35:07 <jle`> maybe they forgot to put it in
20:35:39 <jle`> first time i saw the "cannot match True with False" error i did have a nice chuckle.
20:40:24 <jle`> "cannot match type EQ with LT"...that's better :)
20:40:42 <naudiz> pavonia: thanks, didn't know about the rts-part
20:40:44 <jle`> but now i have to define my own >/>=/<=/</== type families
20:41:11 <jle`> oh they can just be type synonyms. sweet
20:42:26 <naudiz> pavonia: doesn't help tough... the limit is still the same
20:42:42 <jle`> why aren't these in base already?
20:44:15 <pavonia> naudiz: What are you compiling?
20:44:30 <pavonia> or evaluating
20:44:32 <joneshf-laptop> jle`, that's a really good question
20:45:01 <jle`> i don't mind defining them myself but eh
20:45:06 <jle`> i feel like they should be there
20:45:07 <dfeuer> jle`, I'm having enough trouble figuring this sort of stuff out in Idris.
20:45:07 <caseof> I'd like to add a function that hits an API and get all the results, and that may require more than 1 call (API has pagination). How do I write something so that the result for the first call can be used as soon as the first http call returns. Following calls will happen in the background and their results dealt with when they return.
20:45:20 <joneshf-laptop> jle`, type level computation like this seems to be very immature at the moment
20:45:34 <dfeuer> caseof, I think you want threads.
20:45:46 <caseof> Yes, I know forkIO
20:46:00 <jle`> all i does is type x > y = CmpNat x y ~ GT
20:46:18 <jle`> type x < y = CmpNat x y ~ LT
20:46:21 <enthropy> jle`: do you have a reference to the <=? discussion?
20:46:23 <jle`> and it works :3
20:46:43 <jle`> enthropy: i don't, it's just on the haddock documentation for (<=?)
20:46:56 <jle`> if there was a larger discussion i don't know where it is
20:47:07 <jle`> it makes sense for it to be deprecated though, now that CmpNat exists
20:47:22 <dfeuer> caseof, there are more refined systems too. I don't know much about them. Things like STM... Much depends on what you need.
20:47:34 <naudiz> pavonia: the energy of a quantum particle
20:47:48 <joneshf-laptop> maybe whatI should be asking is for examples of using `reflection` in the wild
20:48:49 <naudiz> pavonia: I'm using Array for data representation and convert it to [a] to apply sum to it
20:49:28 <caseof> dfeuer: Yes, I could use a STM channel to send the result back. But I was hoping there would be a better way to do that. My function would return IO [a] where the first element of the list would be available first, and then another http call would happen in background for the second and so on. 
20:49:41 <caseof> Thanks anyway :)
20:49:51 <dfeuer> caseof, oh... you want *that*?
20:49:54 <dfeuer> No, you don't.
20:50:23 <dfeuer> Lazy I/O does not belong in complicated settings like that.
20:50:57 <pavonia> naudiz: Ah, sum causes a stack overflow quite easily, IIRC. Try Data.List.foldl' (+) 0 instead
20:50:59 <lpaste> jle` pasted “fixed length vectors with typelits” at http://lpaste.net/131610
20:51:01 <johnw> caseof: sounds like a case for pipes perhaps
20:51:11 <jle`> joneshf-laptop: that's what i'm working on ^^
20:51:23 <naudiz> pavonia: thanks, I'll give it a try
20:52:24 * hackagebot picoparsec 0.1.2.2 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/picoparsec-0.1.2.2 (MarioBlazevic)
20:52:31 <pavonia> > sum [1..1000000]
20:52:33 <lambdabot>  *Exception: stack overflow
20:52:42 <pavonia> > foldl' (+) 0  [1..1000000]
20:52:43 <enthropy> joneshf-laptop: http://hackage.haskell.org/package/ad-4.2.1.1/docs/Numeric-AD-Internal-Reverse.html#t:Reverse is the reflection you're mentioning?
20:52:44 <lambdabot>  500000500000
20:53:03 <edwardk> mauke: awake? =)
20:53:47 <joneshf-laptop> enthropy, is that used somewhere though?
20:54:01 <edwardk> joneshf-laptop: reflection? or ad?
20:54:11 <joneshf-laptop> edwardk, yes :)
20:54:17 <edwardk> ad is used lots of places, based on the number of issues and super-secret requests for help i get ;)
20:54:19 <jle`> edwardk: any reason why type x < y = CmpNat x y ~ LT etc. aren't in base?
20:54:27 <naudiz> pavonia: nope. "GHC stack-space overflow: current limit is 33632 bytes."
20:54:31 <edwardk> jle`: lots of points in the design space
20:54:37 <benzrf> hey edwardk is there gonna be hac boston in aug again
20:54:41 <jle`> i like my point the best
20:55:16 <pavonia> naudiz: Did you set any options? 34k seems pretty low
20:55:18 <edwardk> benzrf: i haven't set about organizing one yet. not sure if imalsogreg will still be at MIT then to get us space, etc.
20:55:21 <joneshf-laptop> edwardk, more specifically `reflection` used somewhere that isn't a simplistic tutorial
20:55:33 <dfeuer> WTF? How do you constructively prove that the reflexive closure of a linear order is total? Or is that not constructively valid?
20:55:48 <naudiz> pavonia: no, I didn't. and as I said mentioned earlier, +RTS -K1G didn't change anything
20:55:51 <edwardk> joneshf-laptop: i use 'reflection' in the public API for rounded to talk about the precision of an arbitrary precision perfectly rounded floating point number
20:56:16 <dfeuer> Hi, edwardk.
20:56:29 <edwardk> i use reflection in the public API for hyperloglog to build "approximate sets" that are more or less optimally space efficient
20:56:47 <edwardk> i use reflection in a bunch of private code for computing tabulations of particular regular expressions
20:57:20 <edwardk> i use reflection in the internals of lens to make it so you can write a Control.Exception.Handler given just an arbitrary fold, rather than a particular type using very very deep black magic
20:57:23 <jle`> edwardk: do you remember when i asked you what a coalgebra was last year and we went looking for things dual to the algebras in the tensor product over modules sense? (maybe that didn't happen but i imagined it) it turns out that they were using algebra to refer to a function F X -> X so coalgebras are X -> F X's i guess.  in case you were waiting on the follow up
20:57:24 * hackagebot alms 0.6.6 - a practical affine language  http://hackage.haskell.org/package/alms-0.6.6 (JesseTov)
20:58:05 <pavonia> naudiz: Could you paste you code at lpaste.net?
20:58:06 <edwardk> jle`: i've forgotten whether we did that or not. it sounds like something i'd do =)
20:58:08 <benzrf> dfeuer: how are linear orders defined, again
20:58:25 <jle`> apparently coalgebras on F X = X * A are moore machines
20:58:33 <jle`> and F X = X^E * A are mealy machines
20:58:34 <joneshf-laptop> edwardk, thanks i'll check those out
20:58:35 <jle`> who'da thought
20:58:52 <benzrf> mealy
20:58:55 <benzrf> ew
20:58:58 <jle`> ur mealy
20:59:06 <edwardk> Linear uses reflection for 'V n'  so you can have V 100 n as a vector of known length at compile time
20:59:14 <jle`> your output is defined by an element in a finite state space and input
20:59:28 <naudiz> pavonia: it's a lot of code, so I'm not sure what parts are relevant, but I could paste the function where I calculate the energy
20:59:35 <edwardk> or reify 100 $ \(Proxy :: Proxy n) -> ... and in here work with V n a -- using the runtime constant 100.
20:59:56 <dfeuer> benzrf, I'm going by this definition: http://ncatlab.org/nlab/show/linear%20order
20:59:59 <edwardk> jle`: oh yeah, of course they are
20:59:59 <jle`> the cool thing is that algebras are all about induction and coalgebras are all about coinduction
21:00:13 <jle`> now it all makes sense
21:00:17 <jle`> my mind is opened
21:00:26 <edwardk> i use that representation these days anyways
21:00:36 <edwardk> because its much more efficient than the recursive data type
21:00:38 <pavonia> naudiz: Please do so
21:00:44 <edwardk> fmap can be faster
21:00:44 <joneshf-laptop> edwardk, rounded doesn't appear to be on hackage though
21:00:58 <edwardk> joneshf-laptop: github.com/ekmett/rounded.git
21:01:02 <jle`> isn't that what you or johnw use in folds
21:01:33 <edwardk> jle`: i'm using an explicit unfold of that sort with a state space i can compare for equality in my current work on exact real arithmetic
21:01:43 <joneshf-laptop> can you install a package from a git repo with cabal?
21:02:23 <dfeuer> joneshf-laptop, yes, but ... use a sandbox.
21:02:24 <naudiz> pavonia: I hope that's enough to understand what's going on http://pastebin.com/f3AigxgH
21:03:07 <jle`> i learned today that...iwht algebras and induction, you can prove things about objects by examining initial objects...and with coalgebras and coinduction, you can prove things about initial objects by examining resulting objects.
21:03:14 <jle`> math is weird
21:03:14 <joneshf-laptop> dfeuer, sounds painful, I'll just do this the old fashion way
21:03:55 <naudiz> pavonia: wave can get pretty big but in my tests it's just 120×120 entries
21:03:57 <jle`> anyways this is much more interesting than exploring the dual of a bilinear tensor product on modules
21:04:04 <edwardk> data Moore a b where Moore :: (s -> s -> Bool) -> (s -> b) -> (s -> a -> s) -> s -- where i maintain the invariant that the 's' s you'll compare always come from a sequence of applications of the (s -> a -> s) function so you can optimize things like the teleporting turtle by doing as much work after you apply the first 's' to the function to get your
21:04:04 <edwardk> predicate as possible.
21:04:05 <jle`> why do people have to use the same word to mean different things
21:05:24 <pavonia> naudiz: I can't see anything obvious. Do you run GHC on a VM or so? I'm still puzzled as to why your stack size is so small
21:05:45 <jle`> interesting encoding
21:05:57 <naudiz> pavonia: no, I'm running it on a gentoo machine with 6GB
21:06:03 <edwardk> er data Moore a b where Moore :: (s -> s -> Bool) -> (s -> b) -> (s -> a -> s) -> s -> Moore a b -- obviously
21:06:37 <edwardk> alternately you can just work with Eq s  but then you make more data types and... some times need reflection ;)
21:07:31 <edwardk> speaking of which, http://hackage.haskell.org/package/folds-0.6.2/docs/src/Data-Fold-M.html#M uses reflection to build monoids to implement the required API, see the calls to reify internally
21:07:56 <pavonia> naudiz: No idea then, sorry
21:08:14 <naudiz> pavonia: thank you for trying
21:08:26 <pavonia> No problem
21:09:15 <naudiz> funny though... I'm doing the same thing with the density (sum of the magnitudes for all coordinates) and it causes no problem at all
21:09:40 <naudiz> shouldn't take much more space
21:10:54 <naudiz> I take that back, it's the same error and I haven't had it earlier. maybe I'll try turning my computer off and on again, later on.
21:12:45 <pavonia> Maybe another process taking all the memory?
21:17:09 <naudiz> pavonia: I closed everything else, only 1G/6G is taken
21:17:42 <naudiz> with "everything else" I mean everything but the browser, mpd and weechat
21:20:34 <pavonia> naudiz: Does it work if you try returning pot, kin and coup separately?
21:22:09 <naudiz> pavonia: seeing that calculating the density (\(dx,dy) -> (*dy) . sum . fillVec . fmap (densityKarth dx) . cols) doesn't work anymore, I doubt it.
21:24:42 <pavonia> Maybe there's already something wrong with the data you feed in
21:25:30 <naudiz> shouldn't be the case. at the moment the program creates data in its own
21:26:33 <pavonia> Could you post the code that is creating the vmat?
21:27:17 <naudiz> I've found the problem
21:27:53 <naudiz> sndDiffKarthDx and sndDiffKarthDy create a hugh overload
21:29:32 <naudiz> unfortunately I don't know how to solve this problem and I don't have any more time right now. I'll have to take a closer look at it later. thanks for your help, pavonia 
21:32:26 * hackagebot stackage-upload 0.1.0.2 - A more secure version of cabal upload which uses HTTPS  http://hackage.haskell.org/package/stackage-upload-0.1.0.2 (MichaelSnoyman)
21:32:28 <pavonia> Ah, okay
21:47:27 * hackagebot yesod-gitrev 0.1.0.0 - A subsite for displaying git information.  http://hackage.haskell.org/package/yesod-gitrev-0.1.0.0 (DanBurton)
21:53:43 <echo-area> Are IORef and STRef valid answers for "Given an example of a type of kind * -> * which cannot be made an instance of Functor (without using undefined)"?  I cannot think of more famous example except these and Set
21:55:15 <Cale> echo-area: try  data To r a = MkTo (a -> r)
21:57:33 <mniip> echo-area, anything with the type variable appearing to the right of ->
21:57:33 <Cale> (and yeah, IORef and STRef are valid answers too)
21:57:49 <mniip> er
21:57:51 <mniip> to the left
21:58:05 <Cale> data Endo a = Endo (a -> a)
21:58:24 <mniip> that doesn't sound like a functor
21:58:39 <Cale> right
21:58:54 <mniip> oh I thought you came up with a counterexample
22:03:24 <kakos_> Is there a way to instruct GHC to ignore LINE pragmas and report the actual line in the generated file?
22:12:02 <ryanprior> I'm on Windows 7 64-bit and I just used the minimum haskell installer. From an msys shell I'm running "cabal install memoize" and I get in return: setup-Simple-Cabal-1.18.1.5-x86_64-windows-ghc-7.8.4.exe: does not exist
22:12:26 <ryanprior> so indeed I tried running "which setup-Simple-Cabal-1.18.1.5-x86_64-windows-ghc-7.8.4.exe" and it's not on my PATH
22:12:52 <ryanprior> where is cabal supposed to find that improbably-named program?
22:13:22 <ryanprior> or what should I do in order to be able to install packages?
22:16:50 <jeffdc> What happens if you type 'which cabal'?
22:18:23 <jeffdc> ryanprior: ping
22:18:45 <echo-area> Cale, mniip: Thanks
22:19:05 <ryanprior> jeffdc: c:\Program Files\MinGHC-7.8.4\bin\cabal.exe
22:54:14 <xelxebar> newbie question here: I've installed about 14 packages locally in my $HOME/.cabal just by running `cabal install <foo>`. However, I've read about cabal hell and how one should be using sandboxes. For individual projects I use a sandbox, but for things like ghc-mod, hasktags *etc.* I just cabal install locally into $HOME/.cabal. Is this accepted practice? What should I be doing?
22:54:54 <jle`> xelxebar: you can create a directory and cabal sandbox init; caball install ghc-mod
22:55:06 <jle`> that'll install it in a sandbox to ./.cabal-sandbox/bin/
22:55:17 <jle`> and then you can symlink or copy it to ~/bin/
22:55:27 <jle`> or whereever your PATH looks
22:55:54 <mniip> or just modify your PATH
22:56:29 <xelxebar> jle`: or just update PATH, I guess. How is that advantageous as opposed to just cabal installing locally?
22:56:36 <xelxebar> mniip: you beat me to it
22:56:59 <xelxebar> or rather, how is my current method disadvantageous?
22:57:01 <jle`> you can install each binary in its own sandbox
22:57:05 <jle`> so you'll never run into hell
22:57:09 <jle`> or anything conflicting
22:57:25 <xelxebar> jle`: oh, so every package gets its own sandbox
22:58:14 <xelxebar> so I should have 14 different sandboxes sitting somewhere?
23:00:04 <jle`> you can also mix binaries together in their own sandbox too
23:00:13 <jle`> but if something happens then the damage is limited
23:01:39 <xelxebar> jle`: okay, I see. this is pretty obvious seeming in retrospect. thanks
23:03:19 <xelxebar> is there simple way to `cabal update` instead of going into each sandbox individually?
23:04:10 <xelxebar> could obviously be scripted, but that's such and obvious idea that I suspect it hasn't been done for some specific reasons
23:23:32 * nak yawns
23:35:25 * xelxebar pgp signs nak's yawn
23:36:34 <nak> xelxebar lol
23:42:32 * hackagebot alms 0.6.7 - a practical affine language  http://hackage.haskell.org/package/alms-0.6.7 (JesseTov)
23:43:03 <nak> i'm skimming LYAH and it seems unclear to me why list comprehensions even exist in haskell
23:43:13 <nak> it seems like most of this can be accomplished with `map` and `filter`
23:43:22 <nak> > [x*2 | x <- [1..10]] 
23:43:23 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
23:43:31 <nak> > map (*2) [1..10]
23:43:32 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
23:43:33 <jle`> nak: there are some use cases where list comprehensions are more expressive
23:43:43 <jle`> but you're right, typically, maps and filters are better choices
23:43:48 * nak nods
23:43:52 <arkeet> well for just mapping or filtering there's not much value in using a list comprehension
23:43:59 <nak> it somewhat bothers me that he reaches for comprehensions right away in LYAH
23:44:00 <jle`> > [ x | Just x <- [Nothing, Just 10, Nothing, Just 3]]
23:44:01 <lambdabot>  [10,3]
23:44:09 <pacak> > [i | Just i <- [Just 5, Just 10, Nothing]]
23:44:10 <lambdabot>  [5,10]
23:44:21 * nak blinks
23:44:22 <jle`> comprehensions are often taught before maps and filters for some reason i think
23:44:32 <nak> what is "Just" ?
23:44:33 <jle`> nak: it filters on only things that matches the pattern
23:44:34 <jle`> oh
23:44:37 <jle`> don't worry about that then :)
23:44:42 <pacak> > t Just
23:44:43 <lambdabot>      Couldn't match expected type ‘(a0 -> Maybe a0) -> t’
23:44:43 <lambdabot>                  with actual type ‘Expr’
23:44:43 <lambdabot>      The function ‘t’ is applied to one argument,
23:44:46 <pacak> :t Just
23:44:46 <arkeet> > [ x * y | x <- [1..4], y <- [1..4], even (x + y) ]
23:44:47 <arkeet> idk
23:44:47 <lambdabot> a -> Maybe a
23:44:47 <lambdabot>  [1,3,4,8,3,9,8,16]
23:44:48 <jle`> you'll learn about other types later
23:45:09 <jle`> > [ x | (x,_,_) <- [(1,2,3),(3,4,5),(6,7,8)] ]
23:45:10 <lambdabot>  [1,3,6]
23:45:16 <jle`> here's an example of pattern matching on a type you probably already know about
23:45:41 <jle`> and yeah, nested loops/picking is nice with list comprehensions too
23:45:51 * nak nods
23:45:54 <jle`> although some people prefer other ways of expressing it, list comprehensions often look cleanest
23:46:07 <arkeet> > [5 | True]
23:46:08 <lambdabot>  [5]
23:46:09 <arkeet> > [5 | False]
23:46:10 <lambdabot>  []
23:46:17 <jle`> people use list comprehensions, but not as often as a lot of courses would have people think
23:47:01 <arkeet> list comprehensions don't compose very nicely
23:47:17 <jle`> yeah, they're essentially specialized syntactic sugar
23:47:26 <jle`> for ad-hoc use cases idk
23:47:39 <jle`> haskell has a lot of syntactic sugar
23:47:43 <jle`> but a very small core language
23:47:44 <RaceCondition> is it possible to call a function returning Integer from C using FFI?
23:47:53 <RaceCondition> I'm not seeing a Foreign.C.Types.CInteger type
23:47:57 <arkeet> there isn't one
23:48:13 <arkeet> you'll have to convert it to a type that can work with C
23:48:26 <RaceCondition> what if I have GMP available on the C side as well?
23:48:28 <jle`> as in, you can write everything in haskell with no sugar, and the language is super small.  and all syntactic sugar compiles to that core language.  so you could write small haskell if you wanted
23:48:54 <jle`> but ghc and haskell has ... a lot of sugar ...
23:49:06 <arkeet> RaceCondition: that doesn't help
23:49:28 <jle`> a lot of it is super specialized too, but.  i think we've reached a bit of an equilibrium
23:49:45 <nak> jle` arkeet ok thanks :)
23:49:52 <nak> i think i'm just more used to map/filter
23:49:58 <nak> so the comprehension looks ugly to me
23:50:01 <nak> i'll try to be less partial to it
23:50:12 <RaceCondition> arkeet: why not?
23:50:18 <jle`> i would use map and filter when they work well, which is most of the time
23:50:27 <jle`> a lot of python people like list comprehensions though
23:50:27 <pacak> jle`: A lot? do, strings and tuples.
23:50:40 <jle`> "wow, haskell copied python with list comprehensions..." :)
23:50:40 <arkeet> because ghc doesn't neccesarily use gmp for Integer
23:50:53 <pacak> also where
23:50:53 <nak> does the <- operator have a more generic use? or is it just part of the list comprehension syntax ?
23:51:03 <nak> i feel like i've seen it other places, but i don't remember where
23:51:05 <arkeet> nak: it's not really an operator, just part of list comprehension syntax
23:51:06 <arkeet> and do notation
23:51:06 <jle`> pacak: foo x y = ... goes to foo = \x -> \y -> ...
23:51:12 <nak> oh
23:51:15 <jle`> nak: in this case it's specifically for list comprehensions
23:51:22 <jle`> but other syntactic constructs use the <- syntax too
23:51:27 <nak> ok
23:51:35 <jle`> well, use <- in their syntax
23:51:50 <jle`> pacak: if then else statements
23:52:01 <jle`> fac 0 = ...
23:52:05 <jle`> fac n | n > 0 = ...
23:52:09 <arkeet> oh and pattern guards
23:52:19 <RaceCondition> arkeet: I've tried finding resources on how to call a bigint returning function over FFI to no avail -- do you have any pointers?
23:52:23 <jle`> fromMaybe _ (Just x) = ...; fromMaybe d Nothing = ...
23:52:31 <jle`> and i haven't even started on non-standard/ghc haskell :P
23:53:08 <pacak> Hmmm... Still not that much compared to other languages.
23:53:15 <arkeet> RaceCondition: do you really need to handle big numbers
23:53:21 <jle`> x `f` y
23:53:28 <arkeet> because you can always convert Integer to Int32 or Int64 or whatever
23:53:35 <jle`> x + y can be considered sugar too for (+) x y
23:53:42 <jle`> (+ 1) is sugar for \x -> x + 1
23:53:42 <bartavelle> anybody got a library for efficient multiple patterns matching against Text or ByteString ?
23:54:06 <pacak> And tuple sections, overloaded strings and lists... But in perl....
23:54:09 <RaceCondition> arkeet: well I'd just like to learn how to do it
23:54:14 <arkeet> I don't know how to do it.
23:54:30 <jle`> ViewPatterns are nice too :)
23:54:55 <jle`> i guess when people complain about haskell they are comparing it to languages like scheme
23:55:03 <jle`> i guess that's a bit of an unfair contest with *any* language
23:55:27 <xelxebar> jle`: where would one go to find out what is in core and what is sugar?
23:55:53 <jle`> i think the Report does a good job
23:56:02 <jle`> and the GHC manual.  also this is a nice informal guide http://www.haskellforall.com/2014/10/how-to-desugar-haskell-code.html
23:57:26 <xelxebar> thanks
23:57:29 <xelxebar> that's helpful
23:58:00 <jle`> np!
23:58:13 <iaoel> Is there a standard data structure for which duplicate elements are permissible,
23:58:13 <iaoel> * but permutations are equal?
23:59:05 <jle`> multiset
23:59:31 <jle`> like [(a, Int)], or Map a Int
23:59:32 <Cale> http://hackage.haskell.org/package/multiset
23:59:42 <iaoel> Ah, thanks
