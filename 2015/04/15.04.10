00:06:45 <srid> if i comment out the type definition, haskell deduces `skips :: [[a]] -> [[a]]` 
00:06:48 <srid> whoa, that's surprising
00:10:15 <mauke> map/zip is zipWith
00:10:25 <ClaudiusMaximus> srid: x ++ [e] i suspect
00:10:32 <mauke> take/repeat is replicate
00:10:53 <srid> ClaudiusMaximus: ah, yes!
00:10:59 <ClaudiusMaximus> srid: which would mean foldr might be better so you can use e:x
00:11:13 <ClaudiusMaximus> srid: note, i didn't test
00:11:29 <mauke> length xs is suspicious: makes function fail on infinite lists
00:11:53 <srid> length is only used to take that much number from the index infinite list
00:12:12 <srid> i want an empty list of [[a]] with the same size as another list (of same type)
00:12:19 <ClaudiusMaximus> @check \xs ys -> take (length xs) ys == zipWith const ys xs
00:12:21 <lambdabot>  +++ OK, passed 100 tests.
00:12:29 <mauke> yes, and if that other list is infinite, it'll fail
00:13:07 <ClaudiusMaximus> doesn't even need to be infinite, just longer than maxBound :: Int
00:13:23 <arkeet> the point is it takes a long time for big lists.
00:13:37 <arkeet> you have to consume the entire list up front to produce anything.
00:13:43 <srid> @zipWith const (repeat []) "worl"
00:13:43 <lambdabot> Unknown command, try @list
00:14:05 <arkeet> > zipWith const (repeat []) "asdf"
00:14:06 <lambdabot>  [[],[],[],[]]
00:14:14 <arkeet> > map (const []) "asdf"
00:14:15 <lambdabot>  [[],[],[],[]]
00:14:20 <arkeet> > [] <$ "asdf"
00:14:21 <lambdabot>  [[],[],[],[]]
00:14:46 <srid> heh, ok
00:14:57 <srid> how does <$ work?
00:15:04 <mauke> :t (<$)
00:15:05 <lambdabot> Functor f => a -> f b -> f a
00:15:26 <mauke> x <$ y = fmap (const x) y
00:15:41 <srid> k
00:15:55 <mauke> at least that's the only definition that makes sense for that type
00:16:10 <arkeet> @src (<$)
00:16:10 <lambdabot> (<$) = (<$>) . const
00:16:11 <srid> what use does <$ serve? other than repeating some value
00:16:29 <arkeet> well, if you have a big structure
00:16:37 <arkeet> and you just want to change all the values to one thing.
00:17:42 <arkeet> another practical use for example
00:17:48 <mauke> > Node 1 [Node 2 [], Node 3 []]
00:17:49 <lambdabot>  Node {rootLabel = 1, subForest = [Node {rootLabel = 2, subForest = []},Node ...
00:17:53 <mauke> > "hi" <$ Node 1 [Node 2 [], Node 3 []]
00:17:54 <lambdabot>  Node {rootLabel = "hi", subForest = [Node {rootLabel = "hi", subForest = []}...
00:18:08 <arkeet> > guard (1 < 2) :: Maybe ()
00:18:09 <lambdabot>  Just ()
00:18:14 <arkeet> > "hello" <$ guard (1 < 2) :: Maybe String
00:18:15 <lambdabot>  Just "hello"
00:18:18 <arkeet> > "hello" <$ guard (1 > 2) :: Maybe String
00:18:19 <lambdabot>  Nothing
00:18:32 <mauke> ooh, interesting
00:19:39 <Ferdirand> there is a one liner for the inverse burrows-wheeler transform that uses <$
00:20:54 <arkeet> oh?
00:20:56 <arkeet> do share
00:21:36 <Ferdirand> you build a matrix by iterating a function to get some matrix
00:22:42 <Ferdirand> so as the starting point you take a list of empty lists the same length as the input
00:27:03 * srid solved it
00:27:06 <srid> https://www.irccloud.com/pastebin/9F318xhE
00:27:28 <srid> if you are curious, that is a solution to http://www.seas.upenn.edu/~cis194/spring13/hw/03-rec-poly.pdf
00:28:41 <srid> ClaudiusMaximus: not sure how foldr can help
00:28:56 <srid> the expression comes in g, which is a function for map (not fold)
00:29:26 <srid> ah, you are right
00:29:27 <srid> it just worked
00:34:30 <sgronblo> whee, I think I used the State monad successfully for the first time
00:46:19 <srid> > filter (\(a, b, c) -> a < b && b > c) zip3 a (drop 1 a) (drop 2 a)
00:46:20 <lambdabot>      Couldn't match expected type ‘Expr -> [a1] -> [a2] -> t’
00:46:20 <lambdabot>                  with actual type ‘[((), (), ())]’
00:46:20 <lambdabot>      The function ‘filter’ is applied to five arguments,
00:46:22 <srid> hmm
00:46:30 <djrenren> hey all I have a question that I can't seem to find the answer for on google. Why can IO operations in haskell fail instead of just returning a result type?
00:49:28 <pavonia> :t \a -> filter (\(a, b, c) -> a < b && b > c) $ zip3 a (drop 1 a) (drop 2 a)
00:49:29 <lambdabot> Ord a => [a] -> [(a, a, a)]
00:50:06 <pavonia> djrenren: What do you mena by returning a type?
00:50:11 <pavonia> *mean
00:50:34 <srid> > map (\(a, b, c) -> b) (filter (\(a, b, c) -> a < b && b > c) (zip3 a (drop 1 a) (drop 2 a)))
00:50:35 <lambdabot>      Couldn't match expected type ‘[a]’ with actual type ‘Expr’
00:50:35 <lambdabot>      In the first argument of ‘zip3’, namely ‘a’
00:50:35 <lambdabot>      In the second argument of ‘filter’, namely
00:50:38 <srid> can that ^ be simplified any further?
00:50:50 <HeladoDeBrownie> djrenren, one motivator for it is asynchronous exceptions, like signaling of errors between threads. this is something that makes it much more feasible to bake errors into the type rather than have everything return an Either or a Maybe
00:50:54 <srid> pavonia: ok
00:52:27 <mauke> > [ b | (a : b : c : _) <- inits [1, 3, 2], a < b && b > c ]
00:52:29 <lambdabot>  [3]
00:52:32 <djrenren> HeladoDeBrownie, I mean I guess that makes sense... especially when it pertains to having top-level error-handling
00:52:53 <mauke> > [ b | (a : b : c : _) <- inits [1, 3, 2, 4, 3], a < b && b > c ]
00:52:55 <lambdabot>  [3,3,3]
00:53:47 <srid> :t inits
00:53:48 <lambdabot> [a] -> [[a]]
00:54:05 <mauke> oh, I'm dumb
00:54:20 <mauke> > [ b | (a : b : c : _) <- tails [1, 3, 2, 4, 3], a < b && b > c ]
00:54:21 <lambdabot>  [3,4]
00:54:33 <srid> > tails []
00:54:34 <lambdabot>  [[]]
00:54:59 <srid> how do I get help of a function from repl?
00:55:35 <djrenren> HeladoDeBrownie, but doesn't having an exception system (sorry I'm new to all the exception stuff in haskell) mean that every function that relies on a function that can preduce exceptions is capable of producing its return type *or* possibly an exception?
00:55:43 <srid>  [ b | (a : b : c : _) <- tails [1, 3, 2, 4, 3, 6, 1, 1, 2, 3, 3], a < b && b > c ]
00:55:46 <srid> > [ b | (a : b : c : _) <- tails [1, 3, 2, 4, 3, 6, 1, 1, 2, 3, 3], a < b && b > c ]
00:55:47 <lambdabot>  [3,4,6]
00:55:48 <opqdonut> srid: I'm not sure that's possible actually
00:56:14 <HeladoDeBrownie> djrenren, essentially. you'd get that with the IO type anyway even if it had no exceptions built-in though. "IO is contagious" as some people say.
00:56:20 <srid> ok that is clever
00:56:22 <Guest31323> djrenren: Haskell exceptions are unchecked, yes (unfortunately)
00:57:16 <djrenren> But exceptions aren't exclusive to IO. can't functions like head and div raise them as well? 
00:57:30 <HeladoDeBrownie> djrenren, ah, in that case we're talking about different sorts of exceptions
00:57:32 <merijn> djrenren: In haskell's semantics exceptions are equivalent to bottom
00:57:57 <merijn> djrenren: Where bottom refers to the "crash/infinite loop" semantics of a program that doesn't terminate
00:58:20 <merijn> djrenren: And yes, every type in haskell is inhabited by bottom in addition to it's other values
00:58:23 <merijn> Hence
00:58:24 <merijn> :t undefined
00:58:24 <lambdabot> t
00:58:54 <merijn> undefined has "any type", this is a result of Haskell's turing completeness. You cannot be both Turing complete and avoid bottom in your semantics
00:59:37 <merijn> There are other language (total languages) which sacrifice Turing completeness (a low price to pay, I'm now convinced) to be able to have a semantics without bottom (i.e. every program terminates and you can statically check this)
01:00:29 <djrenren> ah so what makes undefined different from null?... I guess the property that it's evaluation stalls the program?
01:00:35 <HeladoDeBrownie> djrenren, what is null?
01:00:42 <djrenren> from other languages
01:00:42 <merijn> HeladoDeBrownie: He means as in C
01:00:43 <pavonia> :t null
01:00:44 <lambdabot> Foldable t => t a -> Bool
01:00:54 <merijn> djrenren: The fact that in practice you almost never use undefined
01:01:06 <merijn> djrenren: Whereas people use null all over the place in C/java
01:01:26 <HeladoDeBrownie> djrenren, undefined is not meant to be caught, and is generally avoided whenever possible
01:01:38 <djrenren> merijn, so it's actually just a discipline thing? (you just  blew my mind)
01:01:40 <HeladoDeBrownie> (you *can* catch it, but only in IO)
01:01:51 <HeladoDeBrownie> (and having to catch it is a sign something might be wrong)
01:02:05 <merijn> djrenren: Not even discipline, it's not just that people don't write undefined, it's also not a very useful thing to ever write
01:02:23 <makalu> I use undefined all the time for proxy arguments (undefined :: Bool). Is there another way?
01:02:27 <mauke> can can catch some instances of _|_ but not others
01:02:47 <HeladoDeBrownie> makalu, the api should accept something of type proxy Bool
01:02:52 <mauke> makalu: yeah, (Proxy :: Proxy Bool) but the function has to be written to accept it
01:02:53 <HeladoDeBrownie> makalu, so it's an api flaw if you have to write that
01:02:54 <merijn> djrenren: The only use case I *used* to have for undefined was "foo :: Foo -> Bar -> Baz; foo = undefined" to typecheck code without implementing it yet, but since 7.8 that's not useful anymore
01:03:21 <merijn> mauke: Preferably he should use "proxy Bool" as pointed out so that you can use Proxy values other than Proxy
01:03:30 <mauke> even then, foo = error "Not implemented" would probably be better
01:03:45 <merijn> mauke: Now you should used typed holes for that anyway
01:03:54 <HeladoDeBrownie> i'll throw in undefined for stuff i'm right about to implement, but want to make sure my types make sense first
01:04:00 <merijn> mauke: Especially since I changed it so you can compile and run code with untypes holes in it :D
01:04:13 <merijn> *typed holes >.>
01:04:14 <makalu> is there a standard Proxy or should I define my own?
01:04:24 <djrenren> ah so basically every type has the capability to be an error
01:04:25 <mauke> perl specifically supports the syntax foo = ... for this :-)
01:05:00 <merijn> makalu: There's a standard Proxy type yes, but your api should use "proxy b -> Foo" for example, so that if I happen to have a Maybe instead of a Proxy I can still use it
01:05:00 <HeladoDeBrownie> makalu, Data.Proxy in base
01:05:35 <merijn> djrenren: Right, because a computation could always happen to be an infinite loop (Turing completeness) and haskell treats those things as having the same semantics
01:05:47 <HeladoDeBrownie> one way to sum up a couple things we've said: if you're designing an interface, use a type variable instead of Proxy. if you're using an interface, you may satisfy it using Data.Proxy.
01:06:04 <pavonia> merijn: What would you lose if you'd give up partial functions?
01:06:10 <HeladoDeBrownie> an extra advantage to the former is you don't even have to import anything!
01:06:16 <makalu> you mean in "proxy b" proxy is a type variable with kind "* -> *"?
01:06:19 <mauke> wtf, Proxy is a monad
01:06:21 <HeladoDeBrownie> makalu, yep
01:06:31 <HeladoDeBrownie> mauke, sure, why wouldn't it be?
01:06:38 <merijn> pavonia: Turing completeness :p
01:06:44 <merijn> mauke: That sounds wrong
01:06:48 <makalu> cool, thanks guys. Today was a good day, I learned something :)
01:06:54 <merijn> mauke: You can't implement >>= for Proxy...
01:07:02 <shachaf> merijn: Sure you can.
01:07:04 <HeladoDeBrownie> merijn, you sure about that?
01:07:06 <djrenren> merijn okay cool....so you've basically convinced me Haskell shouldn't be turing complete haha but how would long running processes work?
01:07:09 <shachaf> Why shouldn't Proxy be a monad?
01:07:29 <pavonia> merijn: Well yes, but practically I mean. What programs wouldn't you be able to write anymore
01:07:56 <merijn> shachaf: How is it different from Const not being a Monad?
01:08:01 <HeladoDeBrownie> djrenren, i doubt haskell's design is going to change that radically anytime soon, but if you want there's idris, which is sort of like a dependently typed haskell, and also agda
01:08:35 <HeladoDeBrownie> merijn, with Const you need to invent a value of some other tyep
01:08:37 <HeladoDeBrownie> type*
01:08:42 <shachaf> merijn: Const () is a monad.
01:08:57 <shachaf> HeladoDeBrownie: Well, presumably merijn means instance Monoid w => Monad (Const w)
01:09:00 <shachaf> Which you can't write.
01:09:10 <merijn> djrenren: Then you get into coprogramming and "guaranteed infinite loops" for things like servers, Haskell isn't going to change like that soon. But yeah people are moving into that direction
01:09:15 <merijn> shachaf: oh, right
01:09:21 <djrenren> HeladoDeBrownie, haha yeah I wouldn't expect it to just trying to learn and sift out some of things people claim Haskell solves for you
01:09:27 <shachaf> join :: Monoid w => Const w (Const w a) -> Const w a doesn't work.
01:09:59 <merijn> djrenren: Idriss is moving into "pragmatic dependently typed programming" and has optional totality (termination) checking, Agda I think is total by default
01:10:43 <mauke> join (Const x) = Const x
01:11:09 <merijn> djrenren: I think the biggest point of "no errors" people make about haskell is them overselling some things and underselling others
01:11:48 <ph88> geekosaur: i tried the secret sauce http://pastebin.com/qRL3YEty
01:11:56 <merijn> djrenren: The fact that undefined is kinda useless to deal with COMBINED with the ease of creating/using new (and existing) data structures for handling special cases and errors, mean that in practice you end up using those tools instead
01:12:13 <shachaf> mauke: That doesn't work with the monad laws.
01:12:45 <ph88> geekosaur: the package cabal http://pastebin.com/4FHiLGA4
01:12:46 <mauke> oh yeah? you're not my dad!
01:12:47 <merijn> djrenren: In practice most code you write in haskell will be total anyway, so for that part of your codebase everything is fine.
01:13:04 <makalu> I have a question related to undefineds. If I have a poorly designed ADT and in a function I don't need to handle all cases, what should I use for the _ case? I've used undefined before. I know the correct answer is to design your ADT so that this wouldn't be necessary but I can't change that much.
01:13:18 <HeladoDeBrownie> sometimes you write code that you can't easily prove is total but it ends up being
01:13:39 <mauke> error "Name.Of.Your.function: internal error"
01:13:55 <shachaf> mauke: You have bested me.
01:14:25 <djrenren> merijn, ah okay cool. I guess I understand the  value of all the undefined/error stack but it seems strange that base functionality like IO (though this is most understandable), head, and div would *rely* on it. It seems that it wouldn't be so radical to clean that up a tad
01:15:06 <mauke> exceptions in IO are different. you can reliably catch them
01:15:17 <HeladoDeBrownie> djrenren, they don't rely on it, bottom is not the same as IO exceptions
01:15:28 <makalu> Data.Proxy doesn't exist in base 4.6 :'(
01:15:31 <HeladoDeBrownie> well, IO doesn't rely on it.
01:15:33 <djrenren> ah okay my apologies got a little tied up
01:15:43 <HeladoDeBrownie> head and div are just things you've gotta be careful with or avoid.
01:15:49 * hackagebot avers 0.0.4 - empty  http://hackage.haskell.org/package/avers-0.0.4 (wereHamster)
01:16:02 <merijn> HeladoDeBrownie: IO exceptions are semantically the same as IO exceptions
01:16:06 <merijn> HeladoDeBrownie: They're both bottom
01:16:23 <mauke> but are tautologies the same as tautologies?
01:16:29 <djrenren> HeladoDeBrownie, yeah I guess you'd really need dependent types or Maybes to solve those problems
01:16:32 <merijn> mauke: Only up to isomorphism!
01:17:11 <merijn> djrenren: FWIW, I'm playing with a design for checked exceptions for a haskell-like language. Although I'm not sure it could be retrofitted into haskell without too much of an overhaul
01:17:17 <HeladoDeBrownie> merijn, isomorphically unique isomorphism?
01:17:24 <mauke> > minBound `div` (-1 :: Int)
01:17:25 <lambdabot>  *Exception: arithmetic overflow
01:18:47 <djrenren> mauke there's no way that could produce a compile time error if the right hand side of `div` wasn't known at compile time
01:19:03 <merijn> djrenren: No, but in dependently typed languages like Idriss it can :)
01:20:31 <merijn> Then you get types like (made up inconsistent syntax warning!) "Int -> (Int /= 0) -> Int"
01:20:36 <djrenren> merijn yeah exactly! I'ma have to check out idris then. Seeing as most of my time spent in haskell is purely for self-education anyway might as well
01:20:53 <merijn> djrenren: I would recommend getting comfortable with Haskell first
01:21:27 <merijn> djrenren: Idriss is still in really early stages of development and they're explicitly targetting "haskell programmers" as audience
01:22:08 <merijn> Not to mention, at the moment Haskell is far more practical in terms of libraries, etc. but it's interesting to keep an eye on
01:23:27 <merijn> On a completely unrelated note
01:24:26 <merijn> I have a function whose type is polymorphic in a DataKinds parameter, I need access to the SingI instance of that parameter. I don't suppose there's a way to avoid threading the SingI constraint throughout my entire code? :\
01:24:51 <merijn> All the members of the promoted type are SingI instances, but that's not enough for GHC to figure out which to use
01:26:27 <bennofs> merijn: so the parameter is of a closed kind, and you'd like GHC to automically figure out that there is an instance for each member of this closed kind?
01:27:06 <merijn> bennofs: Well, what I'd like is to not add this constraint to 20+ polymorphic functions. But the problem I see is that GHC can't know where to get the instance from
01:27:47 <merijn> So I'm just doublechecking there isn't a way that doesn't force me to change the types for so many functions before I give up
01:35:50 * hackagebot dataflow 0.4.0.0 - Generate Graphviz documents from a Haskell representation.  http://hackage.haskell.org/package/dataflow-0.4.0.0 (owickstrom)
01:35:52 * hackagebot ede 0.2.8.1 - Templating language with similar syntax and features to Liquid or Jinja2.  http://hackage.haskell.org/package/ede-0.2.8.1 (BrendanHay)
01:36:12 <bennofs> Is there standard package that provides a class for a filterable type, with members like mapMaybe ::$
01:36:21 <bennofs> mapMaybe :: (a -> Maybe b) -> f a -> f b
01:37:41 <bennofs> (f is not a Monad)
01:40:50 * hackagebot cndict 0.5.1 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.5.1 (DavidHimmelstrup)
01:43:40 <ph88> how can i tell cabal to use a FFI/C library/header file on windows ?
01:44:04 <luite> you can use the os(windows) conditional
01:44:57 <ph88> luite: i don't know about the os(windows) conditional ..
01:45:27 <luite> ph88: example here https://www.haskell.org/cabal/users-guide/developing-packages.html
01:45:50 * hackagebot dataflow 0.4.1.0 - Generate Graphviz documents from a Haskell representation.  http://hackage.haskell.org/package/dataflow-0.4.1.0 (owickstrom)
01:45:57 <jellie> @seen hoersten
01:45:57 <lambdabot> |-|0eRS7EN
01:46:36 <ph88> luite: so you think pointing to libraries is done with a conditional? i thought with the extra-libraries option ...
01:47:55 <luite> ph88: you place that under the conditional section
01:47:58 <merijn> ph88: No, but you can use those to conditionally point to libraries
01:49:47 <luite> everyone come to Wellington next weekend for NZHac and I'll teach you GHCJS! and the country itself is worth a visit too: https://plus.google.com/u/0/photos/102252268895890191681/albums/6128979501909823985
01:51:53 <ph88> luite: what would the condition be ?
01:54:08 <luite> ph88: please just take a few seconds to look at the examples, if you search for os(windows) you get a few
01:56:51 <ph88> luite: i don't get it ... i know i am on windows so why put a condition in there *if os = windows* ... this will always be true ... i can just put *if true*  ....
01:57:27 <ph88> why do i even need this to  use include libs header files ... in gcc i can use the linker and i don't have to specificy a conditional that i am on windows
01:58:01 <luite> ph88: oh then the "on windows" part of your question isn't relevant. look at the c-sources field
01:58:17 <luite> and possibly include-dirs and extra-libraries
01:58:24 <ph88> https://gcc.gnu.org/onlinedocs/gcc/Directory-Options.html  -->   i put -I  for header files and   -L  for libraries  and it always works !
02:02:18 <ph88> luite: i already had extra-libraries, but not include-dirs ... i added this now. But my scripts is still unable to find module Math.FFT when i do:  cabal exec runhaskell fuz.hs
02:02:39 <ph88> luite: this is how my files look like http://pastebin.com/sZ3kpWG6
02:05:29 <ph88> luite: i think i made a mistake with the configuration so i try this now  http://pastebin.com/thjiXRkM  but still it doesn't work  --> Could not find module `Math.FFT'       for command:  cabal exec runhaskell fuz.hs
02:11:53 <luite> ph88: you need a recent cabal-install version (1.22) for that to work in a sandbox
02:12:37 <luite> ph88: check if cabal repl works, :l fuz.hs
02:15:36 <ph88> luite: cabal -V      cabal-install version 1.22.2.0
02:15:52 * hackagebot cndict 0.5.2 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  http://hackage.haskell.org/package/cndict-0.5.2 (DavidHimmelstrup)
02:17:01 <ph88> luite: cabal repl does not seem to work    http://pastebin.com/pHQQ130Z
02:17:34 <luite> ph88: uh... so for 'cabal exec' you shouldve installed the package first
02:18:24 <luite> cabal repl will try to build it for you, and it has just told you what's wrong :)
02:18:35 <ph88> luite: what i did was     cabal get fft     then     cabal sandbox add-source fft-0.1.8    then    modify the fft.cabal file
02:20:20 <luite> ph88: and you changed build-type to Custom?
02:20:25 <ph88> no
02:20:52 <ph88> luite: i removed reference to pkg-config and instead added library path / header path
02:21:03 <luite> hm, okay, interesting, that could be a bug then
02:21:36 <luite> anyway, i can't help anymore, need to get some work done, sorry
03:00:54 * hackagebot hxt-pickle-utils 0.1.0.3 - Utility functions for using HXT picklers.  http://hackage.haskell.org/package/hxt-pickle-utils-0.1.0.3 (AdamBergmark)
04:35:58 * hackagebot yesod-websockets-extra 0.1.0.0 - Extension to yesod-websockets  http://hackage.haskell.org/package/yesod-websockets-extra-0.1.0.0 (tolysz)
04:37:39 <esimp> Is there a standard function for "clip" a number in a range?
04:37:46 <esimp> clip val min max
04:38:23 <esimp> obviously easy to write, but am wondering if it's already part of a standard library somewhere
04:39:43 <aawe> esimp: clamp in http://hackage.haskell.org/package/intervals-0.7.1/docs/Numeric-Interval-Kaucher.html#clamp
04:42:13 <esimp> aawe, perfect thanks!
04:42:27 <b_jonas> esimp: dunno, but we have min and max functions
04:45:45 <kuribas> > (max 5 . min 2) 3
04:45:46 <lambdabot>  5
04:45:51 <kuribas> > (max 2 . min 5) 3
04:45:53 <lambdabot>  3
04:45:55 <kuribas> > (max 2 . min 5) 6
04:45:57 <lambdabot>  5
04:45:59 * hackagebot dtw 0.9.2.0 - (Fast) Dynamic Time Warping  http://hackage.haskell.org/package/dtw-0.9.2.0 (fho)
04:45:59 <kuribas> > (max 2 . min 5) 1
04:46:00 <lambdabot>  2
04:46:40 <kuribas> :t \n m -> (max n . min m)
04:46:41 <lambdabot> Ord c => c -> c -> c -> c
04:46:46 <esimp> kuribas, interesting composition
04:47:54 <jellie> Could someone tell me how to fix this error when installing haskell-docs http://lpaste.net/970654044731211776
04:48:15 <kuribas> esimp: that's what I would use...
04:50:00 <Gurkenglas> Why does Quickcheck only pass () as an argument to a type constructor by default?
04:50:37 <esimp> kuribas, I like that it uses only the standard prelude
04:51:15 <kuribas> :)
04:57:06 <bennofs> Anyone here familar with reflex? What functions should I use to create a simple event network where an IO action is executed whenever an Event fires, with a simple timer as input events?
04:59:27 <mniip> :( why aren't (>=>) and join inside the Monad typeclass, allowing minimal complete definition to be 'return & (>>= | >=> | join)'
05:00:01 <bennofs> mniip: historically, it was because Functor was not a superclass of Monad so the default definitions could not be written
05:00:16 <b_jonas> mniip: how do you even make defaults such that you can define any of three methods?
05:00:27 <b_jonas> I don't think that's possible
05:00:36 <bennofs> mniip: now the reason is that it breaks generalized newtype deriving b.c. of some interaction with Roles
05:00:43 <mniip> b_jonas, circular dependence
05:00:49 <b_jonas> oh
05:00:51 <b_jonas> hmm
05:00:54 <bennofs> b_jonas: you can give custom MINIMAL pragmas with newer ghcs
05:01:12 <b_jonas> bennofs: um, let me look that up
05:02:22 <b_jonas> bennofs: that doesn't really help defining the default implementation of the methods. it just makes the compiler give warnigns if an instance has too few methods defined explicitly.
05:02:35 <hexagoxel> Gurkenglas: because ambiguous types are defaulted to (), maybe? Try annotating a different type.
05:04:17 <bennofs> b_jonas: yes, and as mniip said you can define circular default definitions. like join = flip (>>=) id and f >=> g = \x -> f x >>= g and m >>= f = join $ fmap f m
05:04:49 <bennofs> oh right, that wouldn't work if you only defined (>=>)
05:05:02 <mniip> yeah
05:05:04 <mniip> hold on
05:05:25 <bennofs> so only (>>=) or join would work, but having (>=>) doesn't seem to be possible at first glance
05:06:06 * hackagebot ede 0.2.8.2 - Templating language with similar syntax and features to Liquid or Jinja2.  http://hackage.haskell.org/package/ede-0.2.8.2 (BrendanHay)
05:07:55 <jellie> I'm having an issue with installing haskell-docs http://lpaste.net/970654044731211776
05:07:59 <jellie> Can anyone help?
05:10:25 <bergmark> jellie: you need to use the same haddock version that ghc ships with
05:10:56 <jellie> bergmark: hmm let me see if I can fix that.
05:12:42 <jellie> bergmark: Do you know how I can make this file reflect that https://github.com/chrisdone/haskell-docs/blob/master/haskell-docs.cabal
05:15:14 <mrkkrp> Hello. I'm reading «Programming with Arrows» http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf, here author show arrow of stream functions (page 4). I want to define it to test my solutions for some exercises (section 2.5). But I can't. Maybe there is already some library defining this `ST' thing? If not, how to define it?
05:15:42 <mrkkrp> The author seems to be able to define arrow instance for `SF' without defining instance of `Cathegory'.
05:15:51 <mrkkrp> It doesn't work for me too well.
05:16:57 <kuribas> Hi, I use emacs to find toplevel types for my functions, but I don't like the naming of variables (like t t1).
05:17:50 <mrkkrp> I have rather silly error in    SF f C.. SF g = SF (f . g)  — when defining (.) for Category instance. Second (.) should be from Prelude and first should be from Control.Category. However, C.. is not valid syntax.
05:18:28 <bennofs> mrkkrp: i think you can just drop the C.  you don't need qualified names in "binding" positions
05:18:39 <bennofs> mrkkrp: so SF f . SF g = SF (f . g)
05:19:37 <mrkkrp> it removes the previous error, but now it cannot match expected type...
05:20:20 <mrkkrp> Can I just upload my whole mess and ask you to point out how to continue with this?
05:20:26 <bennofs> @where lpaste
05:20:26 <lambdabot> http://lpaste.net/
05:20:28 <kuribas> If I have a datatype (Expr v n), why couldn't ghc output "Expr v n -> Expr v n" instead of "Expr t t1 -> Expr t t1"?
05:20:28 <bennofs> yes
05:20:56 <mauke> you have a type Expr, not Expr v n
05:21:06 * hackagebot dtw 1.0.0.0 - (Fast) Dynamic Time Warping  http://hackage.haskell.org/package/dtw-1.0.0.0 (fho)
05:21:23 <bennofs> kuribas: since it's really hard to preserve the user defined names throughout everything GHC does. It frequently needs to generate fresh names, and having the be equal to userdefined names is not always possible
05:23:00 <lpaste> mrkkrp pasted “SF arrow and other” at http://lpaste.net/130482
05:23:15 <mrkkrp> bennofs: done
05:23:17 <kuribas> bennofs: Could it be done as a post-processing step?
05:24:07 <mrkkrp> " <- couldn't match expected type" should be a comment...
05:24:16 <bennofs> kuribas: idk. i just now that it's hard which is why ghc hasn't implemented it, not sure if it could be improved (i'm not familar with GHC source code)
05:24:36 <mniip> there I figured it out
05:25:02 <mniip> (>>=) = (join .) . flip fmap
05:25:02 <mniip> join = (id >=> id)
05:25:02 <mniip> (>=>) = (. flip (>>=)) . flip (.)
05:25:32 <bennofs> mrkkrp: can you add the full error please?
05:25:38 <kuribas> bennofs: I would guess the names are garbled by the typechecking process, so a postprocessing step for aestetics would make sense.
05:26:23 <kuribas> Take my function: "getTrig :: (Num t1, Eq t1) => Expr t t1 -> Maybe (TrigTerm t t1)"
05:26:57 <kuribas> It could take "Expr v n" from the datatype (as it is the first argument).  The rest follows.
05:27:01 <mrkkrp> bennofs: Couldn't match expected type ‘SF t0 b0 -> SF t0 b0’ … with actual type ‘SF a a’ Relevant bindings include …
05:27:29 <bennofs> mrkkrp: just annotate the paste with the full error
05:28:06 <lpaste> mrkkrp annotated “SF arrow and other” with “SF arrow and other (annotation)” at http://lpaste.net/130482#a130483
05:29:15 <bennofs> mrkkrp: id :: SF a a, so id cannot take arguments
05:30:05 <mrkkrp> oh, indeed...
05:30:32 <mrkkrp> id = SF id   then
05:31:33 <mrkkrp> bennofs: thanks!
05:33:58 <mrkkrp> Flycheck didn't show me this interactively because of missing `main' function... strange
05:53:16 <Gurkenglas> hexagoxel, yes, and those annotations work, but why are ambigious types defaulted to ()? I'd think with 100 tests one could fit a few other types in?
05:57:27 <c_wraith> Gurkenglas: types exist at compile time only
05:57:37 <c_wraith> Gurkenglas: you can't just change types at runtime
06:07:30 <mniip> hold on, Monad doesn't imply Functor?
06:07:42 <zinfandel> mniip: It does now
06:07:50 <zinfandel> mniip: Although indirectly
06:08:05 <exio4> Monad implies Applicative, and Applicative implies Functor 
06:08:06 <mniip> I know about AMP, but I thought it does require a functor instance
06:08:09 <zinfandel> mniip: Monad implies Applicative, which in turn implies Functor
06:08:44 <mniip> that's under AMP
06:09:42 <zinfandel> mniip: yep
06:10:08 <kuribas> Is anyone interested in writing a fontdesign program in haskell?
06:11:55 <kuribas> Or is there a mailing list where you can ask for contributors?
06:14:17 <mniip> kuribas, seems mildly interesting
06:14:20 <ocramz`> kuribas: I'd guess one first has to start the project by himself, set up a skeleton, then u/l it on some github or the like, then wait
06:14:32 <mniip> what do you have working
06:15:49 <kuribas> mniip: I have a low level library which is not quite finished.
06:16:21 <kuribas> https://github.com/kuribas/cubicbezier
06:16:30 <ocramz`> kuribas: have you seen diagrams?
06:16:37 <kuribas> ocramz` yeah
06:16:47 <kuribas> ocramz` but it's high level.
06:17:09 <kuribas> mniip: And I am working on a equation solver.
06:17:17 <ocramz`> there's also an interesting video w BYorgey explaining the design choices
06:17:57 <kuribas> mniip: http://kuribas.github.io/omegafont/
06:18:35 <kuribas> ocramz`: diagrams is very nice.  But my goal is an interactive app.
06:19:56 <kuribas> Guess I should work until I have a good demo to convince others.
06:20:17 <brbblnch> Hi
06:21:06 <brbblnch> Quick question: When you define let's say a function f :: a -> a, it's actually f :: forall a. a -> a , right?
06:21:12 <kuribas> mniip: My starting point is metafont.
06:21:31 <quchen2> brbblnch: Yes.
06:21:38 <quchen2> Top-level foralls are implicit.
06:22:06 <brbblnch> quchen: And does haskell exactly follow systemF?
06:22:47 <quchen2> System F-omega is the basis of Haskell's type system, but I don't know whether it follows it *exactly*.
06:26:17 <brbblnch> quechen2: Ok, thank you!
06:26:52 <kuribas> ocramz`: Some of my functions are used in diagrams for the low level.
06:34:19 <ph88> does anyone know how i can build a library with cabal ?
06:34:56 <ph88> i don't have a Setup.hs
06:35:23 <ph88> sorry i meant how to build a dependency package
06:35:28 <ph88> Math.FFT
06:36:41 <hexagoxel> cabal install --dep (shortcut for --dependency-only)
06:36:50 <hexagoxel> or do you have modifications in the dependency?
06:38:02 <quchen2> --dep???
06:38:11 <quchen2> Does that exist?
06:38:35 <hexagoxel> quchen2: you can use prefixes for all flags, provided they remain unambiguous
06:38:48 <quchen2> Oh wow.
06:38:50 <hexagoxel> --onl might work too..
06:39:11 <quchen2> cabal configure --enable-te --dep --haddock-hyp
06:39:22 <bennofs> heh
06:39:26 <bennofs> --prof
06:39:35 <quchen2> That's not a prefix though
06:39:48 <bennofs> oh right, --enable-pr
06:39:49 <quchen2> Or is it
06:39:55 <quchen2> --enable-library-pr
06:40:04 <hexagoxel> quchen2: git has the feature too.. and i only recently figured this out as well :D
06:40:09 <bennofs> quchen2: newer cabal has --enable-pr instead of --enable-executable-pr
06:43:02 <quchen2> Maybe if my zsh supported Cabal completion I wouldn't be so  happy about this
06:43:11 <quchen2> Hooray for bad rc files ;-(
06:43:55 <Clint> quchen2: file a bug
06:44:06 <quchen2> Clint: I think the bug is on my end
06:44:22 <bennofs> Anyone know why reflex has both runFrame and runHostFrame? At least for the spider implementation, they are identical except for newtype wrappers (which also have pretty much the same instances)
06:44:28 <quchen2> Or at least I'm not sure whether it's my fault or not, so it's not really something worthy of reporting at this point
06:46:49 <Clint> quchen2: nobody's written any cabal completion for zsh yet
06:47:11 <quchen2> But Cabal supports completion out of the box, doesn't it
06:47:20 <quchen2> I mean it would just be a matter of telling zsh about it
06:47:46 <quchen2> i.e. "some zstyle setting"
06:47:49 <Clint> we're talking about cabal-install here, right?
06:48:11 <quchen2> Yes.
06:48:26 <quchen2> cabal configure --enable-te<TAB>, that thing.
06:48:35 <Clint> it has --list-options, which could be useful for that
06:48:46 <quchen2> GHC also started supporting autocompletion in 7.8, iirc.
06:48:49 <Clint> and conceivably you could parse the list of subcommands from cabal --help
06:48:52 <quchen2> Maybe 7.6.
06:49:38 <Clint> anyway i'll write something up if i happen to remember next time i get some free time
06:53:12 <berdario> Uhm, I'm trying to do something with conduit, and I'm looking for something like (a->b) -> Sink a m b 
06:53:50 <berdario> but I'm not sure if that makes sense... I also tried simply by using the Functor instance of ConduitM
06:56:58 <chpatrick> berdario: how would that work? Sink can take multiple as
06:57:24 <chpatrick> what should this sink do?
06:57:46 <berdario> chpatrick: I have a Conduit, and I want to do something on the whole of its output
06:58:02 <berdario> I was also looking at the finalizers in passThrough and the like
06:58:23 <bennofs> berdario: would Monoid b => (a -> b) -> Sink a m b work ?
06:58:55 <chpatrick> you mean you want to take everything it receives and then pass it to a function?
06:58:58 <berdario> bennofs: I was thinking more like Monoid a => (a->b) -> Sink a m b... but maybe I'm just confused
06:59:05 <berdario> chpatrick: exactly
06:59:23 <bennofs> berdario: a Sink a m b takes a variable number of a's and provides one b
07:00:12 <bennofs> berdario: since the function is applied to each incoming 'a', you get a number of 'b's as output
07:00:37 <bennofs> berdario: now you need a way to merge all those 'b's. This is what Monoid b provides
07:00:37 <berdario> bennofs: yeah... I'd like to have a Sink that waits for all the as... mconcat thems, and pass it to (a->b)
07:00:54 <chpatrick> berdario: https://hackage.haskell.org/package/conduit-combinators-0.3.1/docs/Conduit.html#v:foldC
07:00:56 <bennofs> berdario: see Data.Conduit.List.foldMap
07:01:09 <chpatrick> then you run the conduit and run f on the output :)
07:01:15 <berdario> yeah, hoogle pointed me to foldMap
07:01:19 <bennofs> chpatrick: no need for an extra package. Data.Conduit.List.foldMap is in conduit
07:01:28 <chpatrick> he doesn't want to map the incoming stuff though
07:01:33 <bennofs> oh?
07:01:34 <berdario> chpatrick: is there a way to run a conduit without "wrapping" it into a ConduitM () Void ?
07:01:35 <chpatrick> it would be foldMap id
07:02:14 <chpatrick> berdario: I'm not sure what you mean
07:02:22 <bennofs> berdario: there is also consume :: Sink a m [a] btw
07:03:04 <berdario> consume seems nice
07:03:09 <chpatrick> it only makes sense to run a ConduitM if it takes no input
07:03:34 <chpatrick> source sink conduit are just type synonyms for ConduitM with different inputs/outputs
07:04:01 <berdario> chpatrick: I was looking at runConduit, which has type  Monad m => ConduitM () Void m r -> m r ... the problem is that I need to "change" a ConduitM a b m () into a ConduitM a Void m b, and I've no idea how to do that
07:04:04 <bennofs> berdario: in particular, if you have a source :: Source m a , then source $$ consume :: IO [a]
07:04:16 <bennofs> s/IO/m
07:04:17 <chpatrick> berdario: you don't have to do anything
07:04:31 <chpatrick> wait a sec
07:05:11 <mniip> woah
07:05:26 <mniip> monads are much simpler in return-join notation
07:05:31 <mniip> why isn't everyone using return-join D:
07:06:04 <bennofs> mniip: join is also useful with applicative: join $ f <$> ma <*> mb <*> mc <*> ...
07:06:11 <jameseb> mniip: how are they simpler with return-join?
07:06:22 <bennofs> where f :: a -> b -> c -> ... -> m ...
07:06:42 <berdario> ok, `yield 1  $$ CL.consume` returns [1] as I expected... maybe I'll soon stop being confused
07:06:48 <lpaste> mniip pasted “No title” at http://lpaste.net/130488
07:07:18 <chpatrick> berdario: conduits can take input, produce output and return a value
07:07:21 <crvs_> mniip: that is the categorical definition of monad, but since operation sequencing is the main feature of monads in FP, it just became standard
07:07:33 <chpatrick> you can only run them if they don't take input or produce output
07:07:54 <berdario> chpatrick: yeah, that's obvious
07:08:13 <chpatrick> if you use $$ on a source and a sink then the result is something you can run
07:08:14 <crvs_> bennofs: the return-join notation makes the axioms become a mere rewriting of the standard axioms for a monoid
07:08:36 <berdario> what's not obvious to me is how to create a conduit that doesn't produce anything and returns a value, out of a function that takes something and returns a value
07:08:41 <crvs_> (granted, with a bit of abstraction)
07:08:44 <berdario> but I think I'm close to the solution
07:09:01 <mniip> crvs_, what's wrong with saying 'k >>= f = join $ fmap f k' with a decent level of inlination
07:09:13 <chpatrick> berdario: you mean a pure function?
07:09:21 <berdario> chpatrick: yup
07:09:23 <chpatrick> mapC?
07:09:52 <chpatrick> oh hang on, doesn't produce anything
07:10:10 <chpatrick> fmap?
07:10:23 <jameseb> crvs: I've thought of it as return and (>=>) following the axioms of a monoid
07:10:36 <bennofs> crvs: for that purpose, I like (>=>) even more
07:10:36 <crvs> mniip: nothing wrong with that, you can define monads with return-join instead of return-bind but the latter is just the standard way of doing things
07:11:01 <jameseb> because then return behaves as an actual identity of (>=>)
07:11:13 <bennofs> crvs: laws: return >=> f = f; f >=> return = f; f >=> (g >=> h) = (f >=> g) >=> h
07:11:43 <quchen2> I don't think "join . join = join . fmap join" looks like a mere rewriting of monoid axiom.s
07:11:57 <berdario> chpatrick: I tried with fmap, but I apparently haven't used it in the correct place
07:11:58 <crvs> I meant the categorical definition of a monoid object in a monoidal category
07:12:12 <quchen2> jameseb: Those are not the monoid operations, they're the category operations.
07:13:18 <jameseb> quchen2: I mean't that (>=>) and return follow the monoid laws that bennofs stated
07:13:30 <quchen2> They don't.
07:13:58 <jameseb> don't they?
07:14:41 <quchen2> You can't ">=>" any f and g, for example. In a monoid, you can combine any two elements.
07:15:03 <quchen2> <=< is more akin to function composition rather than monoid multiplication.
07:16:16 <quchen2> In a category, you cannot combine arbitrary arrows, only arrow where the tip of the one ends at the start of the other one.
07:18:10 <quchen2> The actual monoid laws that lead to the monad laws are `join . join = join . fmap join` and `join . return = join . fmap return = id`, but as I said, they don't look much like monoid laws at first glance. And also they don't have much to do with Haskell's Monoid.
07:19:34 <quchen2> So in the "monad is just a yadda yadda", the monoid operations in question are not <=< and return.
07:19:46 <jameseb> quchen2: I didn't say they had anything to do with Haskell's monoid type, I'm just assuming monoids don't vary wildly between Categor
07:19:47 <crvs> the thing is that the usual monadic map (foo :: a -> m b) in categorical terms would correspond to a non-standard class of constructions which are "heteromorphisms", meaning that they are allowed to jump between categories
07:19:48 <quchen2> (And I don't think any of this is helpful to learning Haskell, by the way.)
07:20:12 <jameseb> *category theory and semigroup theory
07:20:26 <quchen2> The usual monadic map in categorical terms would correspond to arrows in the Kleisli category.
07:21:05 <crvs> (sort of... because the since it is a functor from a category to itself, it is not really a heteromorphism, but really looks like one)
07:22:13 <Cale> crvs: hm?
07:22:23 <Cale> yeah
07:22:44 <Cale> A monad is an endofunctor that's equipped with some natural transformations
07:23:03 <Cale> So arrows A -> MB are entirely within the category of discussion
07:26:29 <sagittarian> is there some way to compare a value by its address in memory (or some equivalent) in haskell?
07:26:36 <sagittarian> like say i have a list with a cycle
07:26:58 <sagittarian> > let myCycle = 1 : 2 : 3 : myCycle
07:26:59 <lambdabot>  <no location info>:
07:26:59 <lambdabot>      not an expression: ‘let myCycle = 1 : 2 : 3 : myCycle’
07:27:09 <quchen2> You can't decide whether a list has a cycle in Haskell, no
07:27:13 <sagittarian> whatever lambdabot
07:27:49 <quchen2> Not without tagging the entries, at least.
07:28:07 <quchen2> In C that tag would be the memory address, and you have access to that.
07:28:17 <sagittarian> okay
07:28:37 <c_wraith> there are hacks to do it in GHC.
07:28:38 <quchen2> In Haskell you don't have such a tag. There are ways of getting the memory location of something, but I don't know how. And it's an unsafe operation.
07:28:43 <c_wraith> like the observable-sharing package
07:29:29 <c_wraith> err.  Whatever the name of it is.
07:31:12 * hackagebot dataflow 0.4.2.0 - Generate Graphviz documents from a Haskell representation.  http://hackage.haskell.org/package/dataflow-0.4.2.0 (owickstrom)
07:33:25 <indiagreen> can anyone with GHC 7.10 check whether this code compiles? http://lpaste.net/130489
07:36:35 <mniip> I wonder if I can turn ghc into a memory hog with some RULES trickery
07:38:10 <koala_man> I didn't need any trickery for that
07:41:31 <mniip> hahaha
07:48:41 <bennofs> mniip: you can make the GHC inliner loop under the right circumstances
07:48:53 <mniip> there's a limit on ticks
07:49:24 <mniip> hmm, exponential growths
07:50:48 <bennofs> indiagreen: i'll check, just need to compile aeson first
07:52:54 <indiagreen> bennofs: if it doesn't, this should: http://lpaste.net/130490 (and thanks for doing it)
07:55:18 <hodapp> alright, so 'cabal install' just installed Cabal-1.22.2.0, but ~/.cabal/bin/cabal --version still reports 1.22.0.0, which is making Emacs tooling flip out when I try to do anything...
07:58:59 <ph88> hexagoxel: i just modified it's cabal file
08:04:10 <bennofs> indiagreen: first one fails
08:04:22 <bennofs> indiagreen: second one is fine
08:04:28 <indiagreen> okay, thanks
08:10:33 <hexagoxel> hodapp: Cabal /= cabal-install. they are different packages.
08:10:57 <hexagoxel> Cabal is a library, cabal-install an executable
08:13:20 <mrkkrp> Have anyone ever solved those exercises from «Programming with Arrows»? I've solved the first exercise, but I can't check my solution, because there is no solutions on the net. Now I'm feeling really silly, because the exercises says «Experiment with running filterA (arr even >>> delay True) on streams of lists of varying lengths, and understand its behavior.», I do experiment, but it's impossible to understand what it does.
08:13:55 <mrkkrp> I think my solution is simply incorrect.
08:14:34 <mrkkrp> It would be helpful if the author demonstrated correct behavior of filterA...
08:20:33 <chpatrick> is there some nice lens way to get a Maybe in MonadState and mzero if it's not there?
08:20:52 <chpatrick> specifically I want to get an element of an intmap with a given index and mzero if it doesn't exist
08:21:02 <hodapp> hexagoxel: so when I run 'cabal install' and it puts an updated 'cabal' in ~/.cabal/bin... what exactly am I doing?
08:21:47 <hexagoxel> `cabal install` or `cabal install Cabal` or `cabal install cabal-install` ?
08:21:53 <bennofs> :t msumOf
08:21:54 <lambdabot> MonadPlus m => Getting (Endo (m a)) s (m a) -> s -> m a
08:22:08 <bennofs> :t msumOf _Just =<< get
08:22:09 <lambdabot> (MonadPlus m, MonadState (Maybe (m b)) m) => m b
08:22:23 <hodapp> hexagoxel: the 2nd
08:22:43 <kuribas> Is there an equivalent to fromRational for Floating?
08:23:15 <hexagoxel> hodapp: then it puts the compiled Cabal library into one of your package repositories
08:24:03 <ij> Only difference between W and S in the RWST is that W can't be read?
08:24:36 <bennofs> ij: W is accumulated using Monoid to merge values. so tell (Sum 1) >> tell (Sum 2) will produce Sum 3 as W
08:24:36 <hexagoxel> hodapp: it will not put anything into bin, as the "Cabal" package does not contain any executables
08:24:58 <bennofs> ij: The W component behaves like a Writer monad
08:25:04 <hodapp> hexagoxel: this sort of makes sense, it just isn't the sort of thing I'd ever be able to figure out when the Emacs tooling is whining at me that the cabal version is wrong
08:25:21 <ij> bennofs, Oh, I wasn't familiar with it, so I just made assumptions.
08:26:04 <ij> bennofs, I would've made life easier had I known this earlier.
08:26:08 <ij> It*
08:26:17 <hexagoxel> hodapp: the naming Cabal (library package), cabal-install (executable package), cabal (executable "name") is rather bad, i agree
08:26:45 <hodapp> yeah, it's confusing as hell when I'm trying to run this with Emacs tooling and a sandbox
08:31:14 * hackagebot getopt-generics 0.3 - Simple command line argument parsing  http://hackage.haskell.org/package/getopt-generics-0.3 (SoenkeHahn)
08:33:32 <latk> I seem to remember hearing a while ago that the record name clash problem was being fixed. Is this the case ?
08:33:51 <latk> If not, is there some fundamental reason why it can't be fixed ?
08:39:11 <sebleblanc> I am just starting with haskell; I am rewriting this [1] and thought I would use Arrays. On runtime, the program crashes with the message "getElem: index out of bounds". How should I go and debug that? Is there a way to know which occurrence of getElem failed?
08:40:22 <Cale> [1]?
08:40:30 <sebleblanc> https://github.com/nsf/pnoise/blob/master/test.rs
08:40:34 <sebleblanc> oops ;)
08:41:05 <sebleblanc> What I'd like is to give me the line number where it says 'out of bounds'
08:41:28 <bennofs> sebleblanc: looks like wrong channel. this is #haskell, did you mean to ask in #rsut?
08:41:41 <bennofs> #rust*
08:41:42 <Cale> bennofs: He's rewriting that rust code in Haskell
08:41:46 <sebleblanc> Nope, I am rewriting this in Haskell
08:41:59 <bennofs> ops very sorry, I should read more than two lines 
08:42:39 <Cale> That's a bit of an awkward thing about this particular sort of exception. You can try turning on profiling with -prof -fprof-auto and then run your program with the commandline +RTS -xc
08:42:48 <sebleblanc> Oh, I meant getElem in vectors, not arrays
08:42:56 <sebleblanc> I will try
08:42:58 <Cale> which will hopefully tell you which cost centre stack produced the exception
08:43:47 <Cale> However, sometimes the result will be unhelpful (Haskell's evaluation mechanism doesn't really have any notion of a call stack, making things like this a bit tricky)
08:44:11 <sebleblanc> Hmm, "Perhaps you haven't installed the profiling libraries for package Vec-1.0.5 [...]"
08:44:16 <Cale> ah, fun
08:44:45 <Cale> Okay, let's just have a look at your code :)
08:45:14 <Cale> Rather than setting out to fix the fact that building profiling versions of libraries is turned off in cabal-install by default...
08:45:19 <sebleblanc> functional programming is really mind blowing, but it's such a paradigm shift
08:45:33 <sebleblanc> hang on, I'll post the code
08:45:41 <sbidin> Is there a Data.Text equivalent of ByteString's unsafeUseAsCStringLen? I want to expose a Text's underlying data *without* making a copy.
08:46:45 <sbidin> In other words, I'm looking for an O(1) op. All Data.Text.Foreign gives me are O(n) copies.
08:47:24 <juanpablo___> what would be the equivalent of middleware in the Snap world? I'd like to do some processing before a request hits my handlers
08:48:23 <berdario> Uhm, how to set some compile options for my regexes? I created my own Regex with the options I wanted, but I just realized that (=~) only accepts Strings and ByteStrings
08:48:24 <Cale> sbidin: The tricky part is that while you can certainly get hold of the internal ByteArray# using Data.Text.Internal and Data.Text.Array, I'm not sure how safe it would be to get that pointer and hand it off to some C code.
08:48:38 <Cale> sbidin: The garbage collector moves things around all the time
08:48:58 <Cale> sbidin: But I'm rather unfamiliar with how all that works
08:50:10 <nkar`> is there a way to see the code generated by deriving an Ord instance?  or is there a rule that would allow me to reason about derived instances of this class?
08:50:43 <bennofs> nkar`: -ddump-deriv prints derived instances
08:51:00 <nkar`> oh, cool!
08:51:15 * hackagebot html5-entity 0.2.0.3 - A library for looking up and validating HTML5 entities.  http://hackage.haskell.org/package/html5-entity-0.2.0.3 (zudov)
08:51:18 <nkar`> so far, I've found this: "Derived comparisons always traverse constructors from left to right." https://www.haskell.org/onlinereport/derived.html
08:51:44 <sm> g'day all. What's the standard way to transform this recursion to avoid building up thunks ? https://gist.github.com/simonmichael/b4d62e71fe30476a15d7
08:52:07 <sebleblanc> About my code, I'll work on it a bit more, and if the issue persists I'll come back with an example. I am writing the functions but some of the functions are still stubs.
08:52:21 <Cale> sm: That should not build up thunks.
08:52:46 <Cale> sm: Your function is strict in both its arguments.
08:52:49 <sm> Cale: perhaps the wrong word. IT uses a lot of memory due to c:(function call), right ?
08:52:59 <Cale> Well, you're constructing a new list, sure.
08:53:15 <sm> I should have said... building up stack frames ?
08:53:33 <Cale> What's the actual problem you're having? :)
08:54:01 <Cale> Your function will produce a list whose tail is an unevaluated expression (represented by a thunk)
08:54:07 <berdario> what I was looking for was the `match` function
08:54:40 <Cale> however, matching on that tail will immediately produce another such list, and the unevaluated expressions should never be getting very large
08:54:51 <sm> 1. I don't know the right terminology to describe this :) and 2. I want it to not use 500M when I give it a largeish data
08:55:23 <Cale> The pattern match against 0 is forcing the function to evaluate the first argument, so it's not building up large arithmetical expressions
08:55:38 * sm ponders
08:56:04 <oconnore> sm: are you evaluating the list returned by the function somewhere else?
08:56:48 <Cale> oconnore: Probably your problem has something to do with keeping references to strings that you'd rather just be consuming and discarding immediately.
08:56:56 <Cale> oops
08:56:59 <Cale> sm* rather
08:57:06 <sm> yes I'm doing eg length $ takeWidth 5000000 $ replicate 1000000 'り' which takes about 10s and 600M
08:57:30 <Cale> How are you compiling that?
08:57:40 <Cale> Does compiling with -O or -O2 help at all?
08:57:42 <sm> er, in GHCI I mean
08:57:43 * sm tries
08:58:37 <mniip> "replicate 1000000 'り'" on its own sounds like it would take up a couple megabytes at least
08:59:06 <mniip> also what is takeWIdth
08:59:39 <oconnore> mniip: from his gist
09:00:41 <sm> I updated the gist.. but yeah
09:00:47 <mniip> sm, you want to strict-ify the subtraction
09:00:51 <nkar`> is it a good idea to derive an ord instance for an enum (whose value constructors can't really be compared, besides their position) just to derive an ord instance for a type that builds on the said enum?
09:00:59 <sm> Cale: yes, compiled it's faster of course (.5s)
09:01:14 <nkar`> an enum such as data Color = Green | Red | Blue, for instance
09:01:22 <sm> I just want to avoid making it boneheadedly inefficient
09:02:31 <mniip> sm, | r >= 0 = c:takeWidth r cs
09:02:41 <mniip> where r = w - charWidth c
09:02:56 <Cale> sm: How much memory usage when compiled?
09:03:01 <sm> mniip: great, I'll try
09:03:01 <mniip> should sepeed it up by a good amount
09:03:49 <sm> Cale: +RTS -s says 1G allocated
09:03:50 <Cale> mniip: wait, why?
09:03:52 <mniip> because r would be in HNF by the time the function returns (returns whether it's a [] or a :)
09:03:57 <Cale> sm: That number is almost meaningless
09:04:03 <Cale> sm: How much is resident?
09:04:23 <sm> ok.. 44K maxiumum residency. That sounds pretty good
09:04:27 <Cale> yeah
09:05:52 <Cale> mniip: well, okay, I suppose that's true. I was thinking in terms of the fact that takeWidth would surely be evaluating the w - cw regardless.
09:06:16 * hackagebot genifunctors 0.3 - Generate generalized fmap, foldMap and traverse  http://hackage.haskell.org/package/genifunctors-0.3 (DanRosen)
09:06:26 <Cale> But perhaps I'm a little too reliant on the strictness analyser sometimes :)
09:06:44 <mniip> -O0 is love -O0 is life
09:07:55 <magicman> Won't it fully evaluate w and cw anyway, courtesy of the (cw <= w) check? I mean, sure, you'll have a thunk of (w-cw), but no build-up AFAIK.
09:08:05 <Cale> magicman: right
09:08:24 <Cale> magicman: and you may not even have a thunk for w - cw, because GHC knows that takeWidth is strict
09:09:04 <Cale> In fact, I'd expect constructor specialisation to maybe even apply and result in working primarily with unboxed ints
09:09:18 <Cale> I'd have to look at the core to see if that's really happening though :)
09:09:33 <sm> mniip: no measurable difference with that change
09:09:36 <magicman> Well, yes. I was speaking in a non-strictness-analysed case.
09:09:43 <magicman> Sorry if unclear.
09:10:38 <sm> when compiled with default settings. When compiled with -O2, they are again similar except the first variant (mine) now allocates much less in total (100M instead of 1G)
09:10:50 <Cale> sm: Reducing allocation can make things faster, but it doesn't necessarily reduce the amount of space actually needed, and GHC is *really* good at picking up short-lived garbage
09:11:11 <sm> yeah, the maximum resident is the same either way
09:12:02 <sm> oh wait, the first variant also runs much faster with -O2 (.04s instead of .6s)
09:12:05 <sm> go GHC
09:12:24 <sm> so.. I think the code is fine \o/
09:12:43 <slack1256> What is the difference between haskellngPackages and haskellPackages on nix?
09:13:12 <mauke> > "haskellngPackages" \\ "haskellPackages"
09:13:13 <lambdabot>  "ng"
09:13:14 <mniip> +nh
09:13:21 <mniip> argh beat me to it also typo
09:13:37 <ocramz`> mauke: :D
09:13:41 <sm> I'm not yet able to estimate it's performance by looking at it, but nm
09:15:11 <sm> thanks, all!
09:16:35 <slack1256> yez, thanks mauke ;_;
09:16:41 <skilpat_> Off the top of your head, can anyone think of a package (other than ghc and cabal) that defines some .hs-boot files for recursive modules?
09:17:18 <slack1256> skilpat_: AFAIK soon it will be loot of .hs-boot files for backpack
09:17:25 <slack1256> *lots
09:17:36 <mauke> I've written a .hs-boot file once
09:18:04 <skilpat_> Hehe, yeah. I was under the impression they were already quite common in the wild. But I've been checking random popular packages for a while now and I can't find any that use them!
09:19:00 <Cale> skilpat_: People generally try quite hard to avoid them
09:19:08 <skilpat_> I'm trying to test some code that cabal-installs a package and does some extra stuff if it has hs-boot files. But I need a package other than ghc and cabal-install to test it on!
09:19:36 <skilpat_> Cale: Right, I just didn't think they were so successful at it! ;)
09:20:21 <berdario> chpatrick: bennofs Thanks again! I managed to get what I wanted to work
09:20:26 <Cale> I've kind of wished forever that they weren't required.
09:31:15 <roger___> When trying to compile my program, I get "Module ‘Data.Aeson’ does not export ‘ToJson’" despite this appearing to be pretty obviously false. Anyone know why this would be the case?
09:32:15 <seanhess> Is there a library function for this? https://gist.github.com/seanhess/a488ab7ceb49b9915d0f
09:32:30 <seanhess> like span,  over and over again to consume a list
09:32:46 <mauke> maybe in Data.List.Split
09:32:53 <indiagreen> roger___: it's called ToJSON
09:33:39 <seanhess> mauke: they all seem to use equality though
09:34:08 <roger___> indiagreen: *facepalm* Thanks
09:36:25 * hackagebot structural-induction 0.2 - Instantiate structural induction schemas for algebraic data types  http://hackage.haskell.org/package/structural-induction-0.2 (DanRosen)
09:37:50 <Saizan> skilpat_: Agda
09:37:52 <teknokratsevilla> hi
09:38:05 <teknokratsevilla> what's the easiest way to install haskell-cabal in Fedora? 
09:38:42 <skilpat_> Saizan: Fantastic! Thanks!
09:54:18 <eacameron> in pipes-bytestring does using "toLazyM" result in lazy IO?
09:56:39 <hodapp> hmmm. Not sure if I should be finding a way to somehow inspect FooMonad () for certain details contained therein, or if I should be making a monad transformer to accumulate that data.
09:57:19 <hodapp> I feel like I keep running into this when I have various monads in use simultaneously - right now, two of them for code generation (via Atom & Ivory) and one of them for builds (via Shake)
09:57:58 <hodapp> but I guess I am at the whim of what that monad (or its surrounding API) actually exposes
09:58:55 <eacameron> sorry, if someone answered my question in the last 3 I missed it
09:59:04 <hodapp> eacameron: saw no reply myself
09:59:34 <eacameron> hodapp: ok thanks. at least I didn't miss it...
10:03:47 <bennofs> What does the GHC touch# primop (or it's wrapper function touch in primitive) do exactly?
10:06:26 * hackagebot html-entities 1.0.0.0 - An "attoparsec" parser and a decoder of HTML entities  http://hackage.haskell.org/package/html-entities-1.0.0.0 (NikitaVolkov)
10:10:02 <solrize> does ghc 7.4.2 not support overloadedstrings for data.bytestring?  it doesn't seem to work.  
10:10:09 <solrize> i guess that compiler is pretty old by now...
10:10:23 <mauke> how does it fail?
10:12:46 <spdionis> hello
10:13:56 <spdionis> if i have a function called "angle" and this pattern "angle (Point x1 y1) (Point x2 y2) = ..." is there a way to take the first argument or the second?
10:14:29 <mauke> what do you mean, take?
10:14:41 <spdionis> if i match "angle a b" i can use "a" and "b" but then i have a problem if i want to use a.x
10:14:57 <mauke> ah
10:15:08 <mauke> angle a@(Point x1 y1) etc
10:15:16 <solrize>     No instance for (IsString Data.ByteString.Lazy.ByteString)
10:15:16 <solrize>       arising from the literal `"foo"'
10:15:26 <spdionis> mauke: uh, great! thanks
10:15:50 <mauke> solrize: did you import Data.ByteString.Lazy.Char8?
10:16:12 <solrize> i think i tried that let me try again sec
10:16:59 <solrize> hmm that works.  maybe that's the approach to use, though these strings i'm messing with are actual binaries.  thanks
10:17:20 <mauke> import Data.ByteString.Lazy.Char8 ()  -- import no identifiers
10:17:25 <mauke> but the instance is in there
10:18:01 <solrize> hmm it doesn't let me do arithmetic on those char8's
10:18:02 <TallerGhostWalt_> So looking back through the history of view in lens ... I noticed that implementation used to just be: view l = getConst . l Const
10:18:32 <TallerGhostWalt_> what was wrong with such a seemingly elegant implementation?
10:18:34 <mauke> Char8 isn't a type
10:20:16 <solrize> i see, i was using Data.ByteString.Lazy.replicate  which takes a word8 arg, and when i switch to Data.ByteString.Char8.Lazy.replicate that takes a Char arg
10:20:36 <TallerGhostWalt_> The old view returns your record value exactly instead of in a MonadReader
10:21:20 <mauke> right, so don't switch to Data.ByteString.Char8.Lazy.replicate
10:22:55 <enthropy> TallerGhostWalt_: it means you can write  "do a <- view (getA :: Lens' R A); ..." when the monad there isn't just (->) R
10:23:57 <ReinH> Cale: ping
10:24:14 <enthropy> it saves you one function: asks (view getA) -- would be needed with the less general one
10:24:30 <solrize> well i had "import qualified Data.ByteString.Lazy as L" and use L.pack, L.unpack, L.replicate etc
10:24:55 <TallerGhostWalt_> enthropy:  but it also means I have to tack a functor on when ever I want the pure value out 
10:24:58 <solrize> i'll check if i can mix char8 and non-char8 bytestrings in those operations... i'd have expected them to be separate types
10:25:14 <mauke> solrize: there is no such thing as a char8 bytestring
10:25:26 <solrize> data.bytestring.char8.lazy.bytestring
10:25:42 <mauke> that just reimports Data.ByteString.Lazy.ByteString
10:25:47 <enthropy> TallerGhostWalt_: no you don't because there's an instance MonadReader r ((->) r)
10:26:04 <mauke> solrize: import Data.ByteString.Lazy.Char8 (); import qualified Data.ByteString.Lazy as L  -- this should Just Work™
10:26:09 <ReinH> solrize: Char8 is just a way to lie about the contents of a bytestring
10:26:13 <ReinH> It doesn't have a different structure
10:26:17 <enthropy> or maybe I'm misunderstanding what "tack on a functor is"
10:26:20 <solrize> ok will try that thanks
10:26:23 <Cale> ReinH: hi
10:26:33 <ReinH> Cale: Can I ask you a CT-related Haskell question?
10:26:48 <Cale> ReinH: You could have, but you asked me that question instead.
10:26:49 <solrize> that works, thanks!!
10:26:52 <Cale> lol
10:26:58 <ReinH> Cale: :D
10:27:13 <mauke> can I ask to ask?
10:27:21 <solrize> oh boy, haskell conspiracy theories (CT) :)
10:27:28 <mauke> Chrono Trigger
10:27:32 <ReinH> Cale: So lenses are "costate comonad coalgebras". The costate comonad arrises from the free/forgetful slice category adjunction, right?
10:27:35 <ReinH> *arises
10:28:00 <Cale> Ask Edward, he's worked out the details of all that stuff as far as I know.
10:28:08 <ReinH> Heh. I pinged him too :)
10:28:20 <ReinH> I will wait then. Thanks :)
10:28:52 <Cale> I guess I could think about it
10:29:04 <ReinH> Cale: Nah I wouldn't want to tax you.
10:29:12 <Cale> I'll just have to remember the definition of Costate first :P
10:29:32 <ReinH> Cale: Store s a = Store s (s -> a)
10:29:37 <Cale> ah, okay
10:29:43 <ReinH> (The name got changed)
10:30:10 <ReinH> If you fix a, you have an object in the slice category Hask/a
10:30:30 <Cale> You have more than that
10:30:41 <Zemyla> Hmm, is an ST monad transformer anything people would be interested in?
10:30:56 <Cale> (an object in Hask/a is just a function s -> a)
10:31:14 <ReinH> Cale: Really?
10:31:21 <ReinH> A slice is a special comma category
10:31:41 <Cale> http://ncatlab.org/nlab/show/overcategory
10:31:42 <TallerGhostWalt_> enthropy: I am going to have to read more... thanks 
10:32:07 <enthropy> @type [(^.), view]
10:32:08 <lambdabot>     Occurs check: cannot construct the infinite type:
10:32:08 <lambdabot>       s ~ Getting a (Getting a s a) a
10:32:08 <lambdabot>     arising from a functional dependency between:
10:32:16 <enthropy> @type [(^.), flip view]
10:32:17 <lambdabot> [s -> Getting a s a -> a]
10:32:21 <ReinH> A comma category S,T for functors S : A-> C, T : B -> C has objects (a,b,f) for objects a in A, b in B and morphisms f : S(a) -> T(b) in C, right?
10:32:52 <ReinH> Cale: a slice is a comma category where A = C, S is id_C, and T : 1 -> C selects objects in C
10:33:04 <ReinH> So it should be the triple (a,*,f) or just (a,f)
10:33:25 <ReinH> (Where * is the object of 1)
10:33:40 <Cale> ReinH: Don't get confused by the fact that you're picking a type, not an element of that type
10:33:59 <ReinH> But I'm still picking a type.
10:34:04 <ReinH> Store s a picks a type s and a type a
10:34:20 <Cale> an element of Store s a picks an element of s and a function s -> a
10:34:30 <ReinH> Store s a is the object, not a value of type Store s a
10:34:55 <Cale> Well, if you want to think of it on that level, then you're not picking a specific function s -> a
10:35:03 <Cale> So it's again not an object of the slice category
10:35:08 <ReinH> Hmm. Rats.
10:37:20 <Zemyla> Because I wrote one, and it seems to work pretty well, even for monads like [].
10:41:28 * hackagebot union-find-array 0.1.0.2 - union find data structure  http://hackage.haskell.org/package/union-find-array-0.1.0.2 (BertramFelgenhauer)
10:41:30 * hackagebot term-rewriting 0.1.2.2 - Term Rewriting Library  http://hackage.haskell.org/package/term-rewriting-0.1.2.2 (BertramFelgenhauer)
10:42:52 <ReinH> Cale: Ok, I see my mistake. So the adjunction between Hask and Hask/a gives rise to a monad and a comonad, and the coalgebras of this comonad are lenses that get/set a?
10:42:55 <S11001001> Zemyla: what is the type
10:47:45 <Cale> ReinH: which adjunction is this?
10:47:54 <ReinH> Cale: the free/forgetful adjunction
10:48:04 <Cale> Sorry, could you describe the functors?
10:48:20 <Cale> Every adjunction can be described as free/forgetful
10:48:23 <ReinH> The forgetful functor Hask/a -> Hask forgets the a
10:48:31 <Cale> What does that mean?
10:49:10 <ReinH> Cale: it jut discards the slice structure
10:49:31 <Cale> We're sending each function X -> A to the type X, you mean
10:49:41 <haskell207> The composition of two Functors is also a Functor <- is that true?
10:49:46 <haskell207> I think it is right? 
10:49:50 <Cale> haskell207: It is true
10:50:00 <haskell207> A list can be an instance of functor as well as maybe
10:50:04 <haskell207> and you can have a list of maybes?
10:50:14 <Cale> but if you want an instance of the Functor type class, then you'll need to use some explicit newtype
10:50:16 <haskell207> which is a composition of both functor instances?
10:50:33 <ReinH> so given f : S -> A, Forget(f) = S
10:50:41 <ReinH> and it sends morphisms to themselves
10:50:49 <Cale> like  newtype Compose f g a = Compose { unCompose :: f (g a) }
10:51:05 <Cale> You can write instance (Functor f, Functor g) => Functor (Compose f g)
10:51:30 <Cale> ReinH: all right
10:51:51 <ReinH> Cale: The free functor is a bit harder, and I think requires finite products
10:52:12 <haskell207> hmm okay
10:52:13 <Cale> ReinH: hm
10:52:44 <ReinH> Cale: Oh right.
10:54:08 <Cale> haskell207: The fact that list and Maybe happen to be functors has nothing to do with the fact that you can have a list of Maybe values though.
10:54:14 <ReinH> Free :: C -> C/A, Free(S) = f : (A,S) -> A, Free(f) = (id, f) I think.
10:54:25 <Cale> haskell207: You can always apply type constructors to any type at all in Haskell.
10:54:35 <Cale> haskell207: They don't have to be functors for that to be the case.
10:55:36 <Cale> ReinH: ah, okay
10:56:22 <ReinH> Cale: so I guess it's obvious how that induces a Store structure.
10:56:34 <haskell207> when you say
10:56:49 <mmachenry> haskell207: The functor instance wouldn't really be a composition of both functors. 
10:56:53 <Cale> ReinH: Yeah, once you know what the functors making up the adjunction are, it's not hard to check :)
10:56:59 <ReinH> Cale: :)
10:57:00 <haskell207> instance (Functor f, Functor g)
10:57:07 <haskell207> are the f's and g's instances of functor?
10:57:32 <mmachenry> If you have a list of Maybe, you would fmap a function that applies to Maybe. If you want to change something within that Maybe, you'd fmap an fmap.
10:57:34 <Cale> haskell207: Yeah, that says "in order for this instance to apply, there must exist instances of Functor f and Functor g
10:57:50 <Cale> and then we obtain Functor (Compose f g)"
10:57:51 <mmachenry> fmap (fmap (+1)) [Maybe 3, Nothing, Maybe 0]
10:58:15 <ReinH> haskell207: For Compose f g, f and g can be any type constructors of type * -> *. Compose f g is only a Functor when f and g are also Functors.
10:58:18 <mmachenry> > fmap (fmap (+1)) [Just 3, Nothing, Just 0]
10:58:20 <lambdabot>  [Just 4,Nothing,Just 1]
10:58:24 <mmachenry> That's what I meant.
10:58:48 <haskell207> okay, so it is a functor, but it must have a function called fmap right?
10:58:52 <ReinH> haskell207: So I can have Compose Maybe Set, but it is not a Functor.
10:58:58 <mmachenry> haskell207: But you can fmap over the list and have a function that applies only to the maybe and not within it.
10:59:30 <ReinH> (because Set is not a functor)
10:59:42 <mmachenry> > fmap (fromMaybe 0) [Just 3, Nothing, Just 0]
10:59:43 <ReinH> (because mapping a set can change its shape)
10:59:44 <lambdabot>  [3,0,0]
10:59:44 <Cale> haskell207: yeah, to complete the instance, you have to define fmap. In this case,  fmap f = Compose . fmap (fmap f) . unCompose
11:00:21 <ReinH> haskell207: right, notionally you have fmap = fmap . fmap, but you have to stick the newtype wrapping around it.
11:01:30 <haskell207> okay, so @ Cale, you first uncompose your compose instance?
11:01:53 <Cale> haskell207: That just unwraps the newtype wrapper
11:01:54 <ReinH> Cale: lmao, 90% of research is just knowing the right google keywords. "lens slice category" didn't show anything interesting, but "lens algebra slice category" found http://www.cs.ox.ac.uk/jeremy.gibbons/publications/colens.pdf
11:02:02 <ReinH> Cale: Which is exactly what I'm after.
11:02:07 <Cale> ReinH: haha
11:02:15 <ReinH> Also thanks again Dr. Gibbons.
11:02:26 <haskell207> then you fmap (fmap f) over the unwrapped newtype?
11:02:39 <ReinH> Cale: So yes, lenses are both the monad algebras and the comonad coalgebras of the above slice category adjunction!
11:04:43 <Cale> haskell207: yeah, here we have f :: a -> b, and then fmap f :: g a -> g b, and so fmap (fmap f) :: f (g a) -> f (g b)
11:05:53 <Cale> haskell207: and since  unCompose :: Compose f g a -> f (g a)  and  Compose :: f (g b) -> Compose f g b
11:06:20 <Cale> haskell207: we get  fmap (fmap f) . unCompose :: Compose f g a -> f (g a)
11:06:34 <Cale> haskell207: and then  Compose . fmap (fmap f) . unCompose :: Compose f g a -> Compose f g b
11:07:03 <haskell207> okay, let me get back to you. I am going to write these down and think through the tpes
11:08:02 <DoublePlusAwks> Hi, I have a question about self-referencing list definitions
11:08:12 <Cale> DoublePlusAwks: go for it :)
11:08:31 <DoublePlusAwks> http://lpaste.net/9057317069204226048
11:09:19 <Cale> DoublePlusAwks: you'll find that elem a f will take forever with some a
11:09:33 <Cale> DoublePlusAwks: because it's hard to check that something is not an element of an infinite list
11:10:04 <DoublePlusAwks> I also tried using [1..10] in the definition of g, and it also didn't work
11:10:10 <Cale> sure
11:10:44 <sellers> Hm, I'm trying to play around with Data.MemoCombinators, so I coded up a simple 0-1 knapsack problem.  The code gives the correct answer but seems to be running in exponential time (taking several minutes on a dataset that takes ~2 seconds in python).  What's going wrong here? I'm trying to cache the tuple (n, capacity) http://sprunge.us/HSPK
11:10:50 <Cale> The problem is that certain numbers don't occur in f, but the running Haskell program has no way to know that except to test the infinitely many elements of the list forever looking for an occurrence which won't come.
11:11:22 <DoublePlusAwks> hm
11:11:50 <DoublePlusAwks> so is it possible to have it constantly switch between the two lists, and thus generate an infinite list?
11:12:01 <Cale> DoublePlusAwks: You might want to write a version of elem which assumes the given list is sorted
11:12:17 <Cale> DoublePlusAwks: So that it can produce False as the result as soon as it finds an element which is too large
11:12:58 <DoublePlusAwks> ok, so does the definition of g automatically update every time something is appended to f?
11:14:05 <Cale> DoublePlusAwks: As evaluation proceeds, the runtime representations for expressions of f and g get updated
11:14:35 <DoublePlusAwks> ok, i have an idea for how to fix this then, thanks!
11:14:48 <randir> Anyone here have experience with uni-Htk?
11:15:01 <Cale> (by replacing expressions with the result of evaluating them)
11:15:24 <Cale> DoublePlusAwks: I suspect that all you should have to do is what I suggested, replacing the elem function with something a bit more clever
11:19:09 <Cale> DoublePlusAwks: You might also need to give it something more to start with.
11:21:42 <DoublePlusAwks> Cale: I rewrote elem, but it still isn't working as expected 
11:21:49 <DoublePlusAwks> Cale: http://lpaste.net/6419266560212336640
11:22:03 <Cale> @let ordElem x [] = False; ordElem x (y:ys) = case compare x y of LT -> ordElem x ys; EQ -> True; GT -> False
11:22:04 <lambdabot>  Defined.
11:22:19 <Cale> @let f :: [Integer]; f = 1 : [a + b | a <- f, b <- g]; g = 2 : [ a | a <- [1..], not (ordElem a f)]
11:22:20 <lambdabot>  .L.hs:147:23:
11:22:20 <lambdabot>      Ambiguous occurrence ‘f’
11:22:20 <lambdabot>      It could refer to either ‘L.f’, defined at .L.hs:147:1
11:22:24 <Cale> right...
11:22:29 <quchen> Wow, the new Haddock is a lot unfriendlier about missing documentation.
11:22:49 <Cale> @let rs :: [Integer]; f = 1 : [a + b | a <- rs, b <- ss]; ss = 2 : [ a | a <- [1..], not (ordElem a rs)]
11:22:50 <lambdabot>  .L.hs:146:1:
11:22:50 <lambdabot>      The type signature for ‘rs’ lacks an accompanying binding
11:22:50 <lambdabot>  
11:22:58 <Cale> @let rs :: [Integer]; rs = 1 : [a + b | a <- rs, b <- ss]; ss = 2 : [ a | a <- [1..], not (ordElem a rs)]
11:23:00 <lambdabot>  Defined.
11:23:03 <Cale> there we go
11:23:05 <quchen> Especially in generated files with 700 definitions. Sorry build log. But it's probably a good change.
11:23:05 <Cale> > rs
11:23:07 <lambdabot>  [1,3,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
11:23:11 <Cale> ahaha
11:23:19 <Cale> that's a little different than we wanted
11:24:14 <Cale> @undefine
11:24:14 <lambdabot> Undefined.
11:24:19 <Cale> @let ordElem x [] = False; ordElem x (y:ys) = case compare x y of LT -> ordElem x ys; EQ -> True; GT -> False
11:24:20 <lambdabot>  Defined.
11:24:35 <Cale> @let rs :: [Integer]; rs = nub (1 : [a + b | a <- rs, b <- ss]); ss = nub (2 : [ a | a <- [1..], not (ordElem a rs)])
11:24:36 <lambdabot>  Defined.
11:24:39 <Cale> > rs
11:24:40 <lambdabot>  [1,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
11:25:21 <Cale> Oh, did I mess up my definition of ordElem?
11:25:37 <Cale> hmm
11:26:56 <Cale> ah, I did, haha
11:27:03 <Cale> @undefine
11:27:03 <lambdabot> Undefined.
11:29:07 <Cale> @let ordElem x [] = False; ordElem x (y:ys) = case compare y x of LT -> ordElem x ys; EQ -> True; GT -> False
11:29:09 <lambdabot>  Defined.
11:29:32 <Cale> > ordElem 4 [1,2,3,5]
11:29:34 <lambdabot>  False
11:29:38 <Cale> > ordElem 4 [1,2,3,4,5]
11:29:39 <lambdabot>  True
11:29:45 <Cale> okay...
11:32:47 <saml> how can I quickly check if two functions behave the same?
11:33:15 <ReinH> saml: you can't, quickly or otherwise.
11:33:17 <Cale> quickCheck (\x -> f x == g x)
11:33:38 <saml> @quickCheck (\x -> id x == foo x)
11:33:38 <lambdabot> Unknown command, try @list
11:33:51 <Cale> @check (\x -> id x == foo x)
11:33:53 <lambdabot>  *** Failed! Falsifiable (after 2 tests and 1 shrink):
11:33:53 <lambdabot>  "a"
11:33:59 <frerich> ReinH: Well for a function 'Bool -> Bool' I suppose the possible behaviours could be exhausted at some point...
11:34:00 <Cale> > foo "a"
11:34:01 <lambdabot>  "a\n"
11:34:11 <saml> oh i see. thanks
11:34:37 <ReinH> frerich: I took that to mean "for all functions", not "exists a function". Obviously f :: () -> () is easy to check.
11:35:27 <frerich> ReinH: Ah, true - I didn't realize that it might be ambiguous. I read 'if two functions behave the same' as not meaning 'if any two functions behave the same'.
11:35:33 <ReinH> For some functions, quickCheck might give a reasonable amount of confidence that they are the same
11:39:04 <Cale> DoublePlusAwks: ah, this is tricky, you need to provide quite a bit in terms of initial elements or have an even better way of arguing that things are not elements of the first sequence
11:39:58 <DoublePlusAwks> how would adding more initial elements change the nature of the program?
11:40:10 <Cale> DoublePlusAwks: Like, even if we start with the definition that R(1) = 1, and S(1) = 2, and then R(n) = R(n-1) + S(n-1), and {S(n)} being the set of positive integers not present in {R(n)}, okay, so is 4 an element of {R(n)}
11:40:24 <Cale> We know that R(2) = 3
11:41:10 <Cale> But now what is S(2)?
11:41:31 * hackagebot appc 0.0.6 - app container types and tools  http://hackage.haskell.org/package/appc-0.0.6 (wereHamster)
11:41:51 <DoublePlusAwks> Cale: The numbers up to R(2) that aren't contained in R
11:41:55 <Cale> it's not 1 or 3, because they're known elements of {R(n)}
11:42:13 <Cale> and it's not 2 because it's S(1)
11:42:21 <Cale> The next number it could be is 4
11:42:36 <Cale> But we don't know if 4 is an element of {S(n)} or not
11:42:42 <DoublePlusAwks> Right
11:42:53 <Cale> So...
11:42:59 <Cale> @let rs :: [Integer]; rs = 1 : [a + b | a <- rs, b <- ss]; ss = 2 : [ a | a <- [3..], not (ordElem a rs)]
11:43:00 <lambdabot>  Defined.
11:43:08 <Cale> > take 2 rs
11:43:09 <lambdabot>  [1,3]
11:43:12 <Cale> > take 1 ss
11:43:14 <lambdabot>  [2]
11:43:17 <Cale> This much works
11:43:26 <Cale> > take 2 ss
11:43:30 <Cale> ^^ stuck
11:43:30 <lambdabot>  mueval-core: Time limit exceeded
11:43:38 <Cale> and hence
11:43:43 <Cale> > take 3 rs
11:43:47 <Cale> ^^ also stuck
11:43:47 <lambdabot>  mueval-core: Time limit exceeded
11:43:58 <RyanGlScott> Is there an article somewhere that describes the algorithm that -XDeriveFunctor uses?
11:45:56 <DoublePlusAwks> So if we add 7 as the known value of R(3), then does that give sufficient information for S?
11:49:29 <Cale> It gets us slightly farther, and then we get stuck again
11:49:52 <johnw> RyanGlScott: I would think it's as simple as: iterate through the arguments to every constructor; if that argument is a, apply f to it; if it's some Functor f => f a, apply fmap f to it.  If after both of these 'a' is still in the type, fail
11:50:31 <dolio> I think it's smarter than that.
11:50:37 <johnw> oh, and maybe support for Functor f => f (f a), etc.
11:50:42 <RyanGlScott> The thing that trips me up is applying fmap to function types, e.g., data CrazyFun a = CrazyFun ((a -> Int) -> Int)
11:50:44 <johnw> and perhaps it knows how to use liftM too
11:50:45 <quchen> Is there a way to silence Haddock complaining about missing docs on a per-file basis? The pragma approach doesn't seem to work, {-# OPTIONS_HADDOCK --no-print-missing-docs #-}
11:50:50 <johnw> yeah, I'm sure it's smarter
11:51:10 <RyanGlScott> Unfortunately, you can't just fmap ((a -> Int) -> Int)
11:51:43 <dolio> You can't use 'fmap', but it's easy to write the fmap for that.
11:51:44 <Cale> DoublePlusAwks: Oh! Also, we've been writing a <- rs, b <- ss which is wrong, and I didn't notice
11:51:54 <Cale> DoublePlusAwks: we want (a,b) <- zip rs ss
11:52:08 <dolio> a <- rs | b <- ss
11:52:17 <Cale> yeah, or a parallel list comprehension like that
11:52:18 <DoublePlusAwks> Cale: Why do we want a tuple?
11:52:32 <Cale> DoublePlusAwks: what you wrote will take all possible pairs
11:52:37 <RyanGlScott> dolio: OK. Is there an easy way to describe how to generalize the process for several layers of function-nesting, e.g., (((Int -> a) -> Int) -> a)
11:52:38 <Cale> not just all corresponding pairs
11:52:53 <DoublePlusAwks> Cale: OH
11:53:55 <RyanGlScott> That's the part I can't figure out how to make a machine do.
11:54:01 <Cale> so yeah, throwing in 7 works, it seems
11:54:08 <dolio> RyanGlScott: I would write something that kept track of whether I'm negative or positive currently.
11:54:10 <Cale> @undefine
11:54:10 <lambdabot> Undefined.
11:54:18 <Cale> @let ordElem x [] = False; ordElem x (y:ys) = case compare y x of LT -> ordElem x ys; EQ -> True; GT -> False
11:54:19 <lambdabot>  Defined.
11:54:31 <Cale> @let rs :: [Integer]; rs = 1 : 3 : 7 : [a + b | (a,b) <- zip (drop 2 rs) (drop 2 ss)]; ss = 2 : [ a | a <- [3..], not (ordElem a rs)]
11:54:33 <lambdabot>  Defined.
11:54:36 <Cale> > rs
11:54:38 <lambdabot>  [1,3,7,12,18,26,35,45,56,69,83,98,114,131,150,170,191,213,236,260,285,312,34...
11:54:39 <Cale> > ss
11:54:41 <lambdabot>  [2,4,5,6,8,9,10,11,13,14,15,16,17,19,20,21,22,23,24,25,27,28,29,30,31,32,33,...
11:54:45 <dolio> RyanGlScott: So, when you see 'T -> U', you keep whatever polarity you're in for U, and flip it for T.
11:54:59 <DoublePlusAwks> Cale: NICE!
11:55:26 <Cale> However, it might be a bit of a challenge to actually prove this doesn't get stuck at some future point
11:55:30 <dolio> '(T, U)' keeps it the same for both T and U. Etc. If you have a variable 'f' you require a Functor f.
11:56:11 <dolio> RyanGlScott: If you run into an 'a' and you're positive, you use your function. If you run into an 'a' and you're negative, you blow up, because it's not a covariant functor.
11:56:32 <nkp123> hello everyone. just to say something. :)
11:56:34 <Cale> OEIS gives a different Haskell program for the sequence which is a little easier to reason will actually work, because the "ss" it works with is maintained as a function parameter, and is updated as it goes by deleting elements from [1..]
11:56:43 <Cale> i.e.
11:58:06 <RyanGlScott> dolio: I think I get that, but I'm still not sure about how I'd figure out where to put fmap's sometimes.
11:58:11 <Cale> @let rs' = 1 : f 1 [2..] where f n (x:xs) = n' : f n' (delete n' xs) where n' = n + x
11:58:12 <lambdabot>  Defined.
11:58:14 <Cale> > rs'
11:58:16 <lambdabot>  [1,3,7,12,18,26,35,45,56,69,83,98,114,131,150,170,191,213,236,260,285,312,34...
11:58:17 <RyanGlScott> e.g., data CrazyFun a = CrazyFun ((a -> Int) -> Int)
11:58:30 <RyanGlScott> instance Functor CrazyFun where fmap f (CrazyFun g) = CrazyFun (\h -> g (fmap h f))
11:58:33 <dolio> RyanGlScott: I would only use fmap for variables, or recursive calls.
11:58:49 <DoublePlusAwks> Cale: why are we not sure that what we had written will work indefinitely?
11:58:50 <RyanGlScott> How on Earth would you mechanically come up with that?
11:59:20 <dolio> RyanGlScott: Actually, I guess most other defined types I would use it for, too.
11:59:48 <dolio> But some I'd special case, like (,) and Either.
11:59:50 <RyanGlScott> dolio: I think the only exceptions would be nested functions and tuples, at least based on the things I've tried.
11:59:59 <Cale> DoublePlusAwks: Because what happened with 4 originally might happen farther along. It's very unlikely, because the density of ss seems way higher than that of rs, so you're unlikely to run out of elements.
12:00:07 <linman8> is there a class for null values for given types? such as String=""; Num=0; etc...
12:00:10 <Cale> DoublePlusAwks: But hard to prove :)
12:00:11 <dolio> If we had a wider variety of classes, you could eliminate those special cases.
12:00:54 <dolio> RyanGlScott: I guess it's also good to keep track of whether you need to drill into part of a type at all.
12:01:24 <dolio> So if you have 'data Foo a = Foo (Foo a, Bar Int)' you don't care what Bar is.
12:01:52 <DoublePlusAwks> Cale: But since you're adding increasing numbers the 'distance' between each member of r will increase as you progress along the list, and since s is the negative space of r, then it seems like that shouldn't be a problem
12:02:17 <RyanGlScott> Sure, that part seems simple enough. You'd have to tunnel into each tuple field and apply the process to every "element".
12:02:19 <dolio> RyanGlScott: For cases where you do, you'd check whether Bar was a Functor, though.
12:03:37 <dolio> Luckily it doesn't have to account for contravariant functors except (->), so it doesn't have to search for a solution in case Bar is either covariant or contravariant.
12:03:48 <dolio> The only possibility is covariant.
12:04:02 <RyanGlScott> Which is good, that only leaves me one case that I can't figure out :)
12:05:48 <RyanGlScott> I think the derive package derives Functor instances for nested function types correctly, but for the life of me, I can't decipher its source code.
12:06:04 <calef13_> when I do 'cabal install --only-dependencies' in my sandbox, I get an error about a missing .cabal file. I can't find anything on google about this error. Any idea what I might be doing wrong?
12:06:06 <dolio> RyanGlScott: Is that CrazyFun instance correct?
12:06:21 <dolio> Oh, i guess it is.
12:06:28 <RyanGlScott> dolio: I'm pretty sure it is. I'll compare with what derive gives me...
12:06:28 <dolio> I wouldn't write it that way, though. It's pretty weird.
12:07:05 <RyanGlScott> instance Functor CrazyFun where fmap _f (CrazyFun a1) = CrazyFun ((. (. _f)) a1)
12:07:15 <dolio> fmap f (CrazyFun g) = CrazyFun (\h -> g (\a -> h (f a)))
12:07:17 <quchen> linman8: Data.Default
12:07:20 <hexagoxel> calef13_: --only-dependencies means "dependencies of the local cabal package"
12:07:46 <RyanGlScott> dolio: That's the part I don't really have an intuition for.
12:08:08 <calef13_> ah, I'm trying to create a cabal package for a new project, what's the best tutorial to do that?
12:08:21 <quchen> > (def :: String, def :: Char, def :: (Maybe Int, ())) -- linman8 
12:08:22 <lambdabot>      No instance for (Default Char) arising from a use of ‘def’
12:08:22 <lambdabot>      In the expression: def :: Char
12:08:22 <lambdabot>      In the expression:
12:08:29 <quchen> > (def :: String, def :: Double, def :: (Maybe Int, ())) -- linman8 
12:08:31 <lambdabot>  ("",0.0,(Nothing,()))
12:08:31 <dolio> RyanGlScott: Or, fmap f (CrazyFun g) = CrazyFun (contramap (contramap f) g)
12:08:36 <xTessa> My sister sent these creamy pictures of us to share <3 http://bit.do/cam_screenies
12:08:45 --- mode: ChanServ set +o johnw
12:08:52 <dolio> That is what the one is doing. 'contramap f = (. f)'.
12:08:53 <linman8> quchen: thanks. that is what i was looking for
12:09:01 <geekosaur> server ops got there first :)
12:09:03 <quchen> No Char instance is strange though.
12:09:18 <RyanGlScott> dolio: Ooh, that looks much nicer.
12:09:32 <mauke> quchen: what is the default Char?
12:09:41 <quchen> mauke: What is the default Int?
12:09:43 <dolio> You use contramap to enter a negative, function argument context.
12:09:44 <mauke> quchen: 0
12:09:48 <quchen> Why?
12:09:53 <mauke> because it's in the middle
12:09:58 <dolio> And fmap to enter a positive context.
12:10:01 --- mode: ChanServ set +o geekosaur
12:10:14 <quchen> mauke: If you interpolate linearly, yes. I don't see how that makes it the default.
12:10:30 <RyanGlScott> dolio: Hm, that looks promising. Thanks! 
12:10:32 <dolio> Functions actually have both, so there's a function that takes one argument for each and does them at the same time.
12:10:34 <geekosaur> and I see they just found a differenrt account to use
12:10:37 <mauke> quchen: what does "interpolate linearly" mean?
12:11:25 <quchen> There are many "middles" of things, depending on your metric. (a+b)/2 is a possible middle. Point being that the choice of a "middle" is as arbitrary as the choice of any element.
12:11:32 <dolio> Something like: promap neg pos f = pos . f . neg
12:11:53 <quchen> sqrt(abs a * abs b) is another possible "middle", for example.
12:12:04 <mauke> quchen: what are a and b?
12:12:18 <dolio> And (,) has: bimap pos1 pos2 (a, b) = (pos1 a, pos2 b)
12:12:23 <quchen> Arbitrary.
12:12:40 <mauke> that makes no sense
12:12:45 <RyanGlScott> Huh, I didn't think I'd ever find a practical use for profunctors. I'm glad to be proven wrong.
12:13:14 <quchen> Using the "middle" as *the* default also makes no sense.
12:13:39 <quchen> > def :: Word8 -- 127 is sad
12:13:40 <lambdabot>  0
12:14:00 <mauke> it's obviously right
12:14:08 <nkp123> hello everyone. i'm a complete noob and i'd like to have a few links where to start at with haskell. if possible.
12:14:09 <quchen> So is 12
12:14:12 <mauke> but I'd have to think about why it's obvious :-)
12:14:50 <quchen> mauke: Also, 0 isn't even the middle for Int, because it has two middles :-þ
12:15:07 <mauke> but it is the fixed point of both abs and signum
12:15:26 <mauke> wait
12:15:39 <mauke> I mean negate, not abs
12:15:47 <quchen> abs has many fixed points ;-)
12:15:55 <hexagoxel> calef13_: there is `cabal init`; see https://www.haskell.org/cabal/users-guide/developing-packages.html
12:16:05 <bennofs> mauke: 1 is also the fixed point for  the function \x -> 1 / x :)
12:16:13 <mauke> bennofs: type error!
12:16:16 <hexagoxel> calef13_: there are examples down on that page as well
12:16:20 <quchen> I think your "Default" typeclass is going to become quite a complex beast if you want to generically pick out one element like this.
12:16:21 <bennofs> ah, int :|
12:16:26 <mauke> saved by the type system
12:16:58 <mauke> quchen: I didn't pick one for Bool and Char
12:17:26 <hexagoxel> calef13_: and of course looking at existing .cabal files
12:17:35 <calef13_> hexagoxel: thanks very much! I'll have a look
12:17:48 <quchen> "Laws. If your type is numeric, def should be the arithmetic middle of the class. If there are two equally correct middles, it's the one with more functions that have it as fixed point. If it's an unsigned type, the default is 0. Bool can't be an instance because."
12:18:14 <mauke> if it's numeric, def = 0
12:18:22 <bngw4> the hidden language of computer hardware and software
12:18:24 <mauke> so sayeth the lord
12:18:53 <quchen> data N = 1 | 2 | … is numeric as well, but can't be an instance now.
12:19:25 <mauke> why not?
12:19:34 <quchen> Because it's numeric, but doesn't have a 0.
12:19:41 <bennofs> quchen: "definition: numeric = includes 0"
12:19:42 <mauke> the instance still "works"
12:19:43 <ziman> and no middle :P
12:19:56 <mauke> bennofs: no, numeric = instance of Num
12:20:36 <bennofs> oh, I guess Wire from netwire is numeric then? :p
12:20:56 <quchen> Alright, now we have the Default law for Num instances. Why is Num not a superclass? That's right, because there is an infinity of other valid instances, each need their own laws.
12:20:56 <EvanR> "numeric" and "middle" 
12:21:11 <mauke> quchen: right
12:21:26 <bennofs> oh wait, was Netwire the one with the IsString instance or Num? i don't quite remember
12:21:36 <quchen> data 3 = MinusOne | Zero | One -- what's the default?
12:22:05 <EvanR> why should there be laws for Default
12:22:25 <quchen> EvanR: I'm arguing precisely that, they make no sense. Default is about arbitrary choices.
12:22:33 <mauke> > def :: Ordering
12:22:35 <lambdabot>  EQ
12:23:04 <mauris> hey, if i need, say, a constant Set String from a very big english wordlist that i have stored in a txt file, what's the best way to load that into my program?
12:23:13 <mauke> bennofs: it's a lifted Num instance
12:23:17 <mauke> maybe that needs a special case
12:23:50 <mauris> i guess unsafePerformIO is one option but i don't like it. maybe there's some preprocessor/TH magic, or alternatively i can write a little script to turn the file into a .hs file with a very big constant in it
12:24:01 <Cale> DoublePlusAwks: Yeah, a proof would have to use something along those lines.
12:24:20 <quchen> mauris: opening the file and reading from it is a good way.
12:24:27 <EvanR> mauris: i say generate a source file or read it in normally and pass it as a context
12:24:55 <DoublePlusAwks> Cale: Thanks so much, I really appreciate the help
12:25:04 <mauris> hm. i guess i can just pass a "dictionary" argument to whatever needs it
12:25:14 <DoublePlusAwks> Cale: Haskell is exciting but confusing
12:25:15 <EvanR> definitely
12:25:30 <quchen> Java is confusing.
12:25:34 <mauris> i.e. instead of "validWord :: String -> Bool" i would write "validWord :: Set String -> String -> Bool" (trivial example)
12:25:48 <EvanR> i havent seen a programming language that wasnt confusing in some way
12:26:13 <mauris> i was afraid i'd need to force my whole program into the IO context! but i suppose i don't
12:26:30 --- mode: geekosaur set -o geekosaur
12:26:41 <EvanR> you only need IO to load it
12:27:02 <quchen> Your whole program is in an IO context, because your program runs with main :: IO (). Inside main, you can still have pure values. You can load your data in main out of IO, and then pass it to the pure part of the rest of your program.
12:28:00 <quchen> main = fmap (do pure stuff with contents) readMyFile >>= print
12:29:35 <mauke> readMyFile >>= print . doStuff
12:31:33 * hackagebot prosper 0.1.0.0 - Bindings to the Prosper marketplace API  http://hackage.haskell.org/package/prosper-0.1.0.0 (wraithm)
12:32:45 <yac> doStuff <$> readMyFile >>= print
12:33:55 <ReinH> readMyFile >>= \content -> print (doStuff content) ;)
12:35:03 <gfixler> I can retain different heads of a list in, e.g. a recursion, making backtracking to earlier versions of the list easy
12:35:07 <gfixler> can this work for maps, too?
12:35:18 <gfixler> or is the entire map copied every step?
12:36:13 <quchen> Different heads?
12:36:30 <gfixler> quchen: I can keep consing onto a list as I descend a tree, e.g.
12:36:44 <gfixler> and pop back up the tree, and see earlier versions of the list, sans n number of new heads
12:37:05 <quchen> That sounds like a zipper. You can have that for many data structures, yes.
12:37:14 <gfixler> yeah, it's a lot like a zipper
12:37:34 <gfixler> I know there's structural sharing, but wasn't sure how it played out for maps
12:37:44 <quchen> maps as in Data.Map?
12:37:47 <gfixler> yep
12:38:06 <gfixler> which, if I recall, don't actually use hashes
12:38:13 <gfixler> something more like binary trees, I think
12:38:21 <ReinH> They use balanced-ish binary trees
12:38:25 <quchen> :t M.splitLookup -- split a map in two halves
12:38:26 <lambdabot> Ord k => k -> M.Map k a -> (M.Map k a, Maybe a, M.Map k a)
12:38:53 <quchen> This is basically what you need to make a zipper
12:39:08 <ReinH> The correct term is "size balanced" or "bounded balance" according to the haddocks
12:39:13 <ReinH> er, "of bounded balance"
12:40:05 <quchen> gfixler: The problem with applying zippers to Data.Map is that it is an opaque data structure. The binary trees behind it are an implementation detail.
12:40:14 <gfixler> yeah
12:40:22 <gfixler> I'm not entirely sure a zipper is what I want
12:40:24 <quchen> This is also why it's so hard to get a hold of the "root" of a Map.
12:40:32 <gfixler> I don't want to walk around the map - I want to go back to earlier, less-full versions of it
12:40:32 <ReinH> quchen: You need splitLookup but I don't see a way to get left/right equivalents
12:40:39 <gfixler> maybe that's still a zipper, just over time
12:40:54 <quchen> ReinH: oh, right.
12:41:06 <quchen> There's also splitRoot.
12:41:10 <ReinH> if you could access the tree structure you could turn it into a finger tree
12:41:23 <ReinH> But anyway this isn't the sort of view into the map that gfixler wants
12:41:49 <gfixler> I'd like something like a tree, and each node has a map, and as I descend the tree, I add things to the map
12:42:05 <gfixler> and then decide I want to go back up, and the map in the next node up doesn't have the new things in the next node down
12:42:10 <gfixler> which works - it's all immutable
12:42:20 <quchen> > M.splitRoot (M.fromList (zip [1..] "hello world"))
12:42:20 <gfixler> I was just wondering if it was horribly inefficient, especially in space
12:42:21 <lambdabot>  [fromList [(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o'),(6,' '),(7,'w')],fromList...
12:43:33 <quchen> Maps aren't trees, they're key-value associations. You're looking for a tree structure. For all you know, Data.Map could be [(k,v)] internally.
12:43:56 <gfixler> are we sure I'm looking for a tree structure?
12:44:04 <ReinH> I think at best you can achieve logarithmic sharing as opposed to linear sharing for lists
12:44:22 <quchen> Logarithmic sharing?
12:44:28 <ReinH> worst case an insert throws away half the tree
12:45:13 <ReinH> quchen: as in, on average an insert will retain (log |leaves|) of the original tree?
12:46:03 <ReinH> s/retain/share
12:46:05 <dolio> Isn't that how much it should replace?
12:46:12 <quchen> Yeah
12:46:17 <ReinH> dolio: Hmm. Yeah.
12:46:34 * hackagebot lendingclub 0.1.0.0 - Bindings for the LendingClub marketplace API  http://hackage.haskell.org/package/lendingclub-0.1.0.0 (wraithm)
12:46:38 <ReinH> So that's better.
12:47:07 <ReinH> n - log n is pretty close to n?
12:47:19 <quchen> No
12:47:22 <quchen> Yes
12:47:23 <quchen> Pardon.
12:47:24 <ReinH> hah
12:47:24 <quchen> :-s
12:47:32 <johnw> I thought addition and subtraction was pretty much ignored for O()
12:47:35 <ReinH> Well, you've covered all the option
12:47:37 <ReinH> s
12:47:47 <ReinH> johnw: Not talking about big O though
12:47:52 <johnw> ah
12:48:10 <ReinH> I'm trying to describe the (average) amount of expected sharing after an insert
12:48:47 <gfixler> ReinH: isn't that implementation specific?
12:48:50 <EvanR> (n - log n) / n  approaches 1 ?
12:49:15 <ReinH> gfixler: Yes, I'm referring to the Data.Map impl
12:49:27 <quchen> EvanR: Yes.
12:49:38 <quchen> > let n = 10**100 in (log n - 1)/n
12:49:39 <lambdabot>  2.2925850929940456e-98
12:50:06 <ReinH> So the larger the map, the more sharing (on average)
12:50:13 <ReinH> With an infinite map achieving 100% sharing ;)
12:50:37 <EvanR> which would be a function from key to value
12:50:51 <EvanR> nothing to share ;)
12:51:14 <quchen> johnw: O(n + log(n)) > O(n), you can't simply ignore the "+"
12:51:33 <ReinH> Also the smaller the map, the less you probably care about sharing, since it's small.
12:51:34 <dolio> Yes, you can.
12:51:42 <ReinH> quchen: You can for big O.
12:51:59 <ReinH> O(n + n) = O(n0
12:52:02 <quchen> Eh, brainfart. Right, you can.
12:52:06 <ReinH> er O(n)
12:52:17 <dolio> Multiplication is what you can't ignore.
12:52:53 <dolio> Multiplication by non-constants, I guess.
12:53:06 <dolio> Also addition of independent variables.
12:53:17 <ReinH> Now the question is if you can achieve this sharing in practice with Data.Map since it doesn't expose its tree shape. And I'm guessing the answer is "No".
12:53:28 <ReinH> (in the context of some sort of Map zipper)
12:54:32 <ReinH> quchen: the problem with big O is that a heuristic-based understanding like this is probably wrong but a real understanding is too damn hard.
12:55:00 <quchen> ReinH: It's not really complicated, no. The above was just a stupid mistake.
12:55:31 <ReinH> My heuristic is just that n dominates log n, so O(n + log n) = O(n), but n does not dominate m, so O(n + m) =/= O(n)
12:55:46 <ReinH> This is a gross oversimplification but seems to work well enough in practice
12:55:52 <ReinH> quchen: it is for me :p
12:57:23 <quchen> You can break big-O and friends down to pretty simple (but ugly) quantor equations of the form "f ∈ O(n) = starting at some N, for all n > n, f(n) < const*n". So this means that if you go out far enough, your function will be smaller than a linear function.
12:57:36 <quchen> That with some ∀ salt gets you the proper definition.
12:59:40 <quchen> Quicksort is O(n!) in the best case, by the way ;-)
12:59:48 <kadoban> Most simple big-O stuff isn't really that hard to formally mess with, you just have to have practice at it. Spending a couple of days reading the CLRS algorithms book, even just that chapter, will help a lot, heh.
13:00:32 <quchen> Cracking AES-256 is much easier, it's O(1)
13:01:12 <mniip> you mean O(n)
13:01:18 <mniip> the input isn't of a fixed size
13:01:45 <quchen> O(input-size) then.
13:01:49 <ReinH> quchen: :p
13:02:09 <EvanR> for an given input size, its a constant
13:02:15 <EvanR> problem solved
13:02:33 <EvanR> if zeno tried to learn computer science
13:02:46 <quchen> ?quote grows.quadratically
13:02:46 <lambdabot> kmc says: "my algorithm is O(1), but the constant factor grows quadratically as the problem size increases"
13:02:58 <kadoban> Hah
13:03:59 <quchen> Many sorting algorithms are o(n) worst case. Someone made an entire zoo of these things.
13:04:19 <quchen> Good example of when case matters.
13:05:42 <kadoban> Heh, yeah that sounds rather impossible.
13:10:21 <Athas> 'cabal check' complains when I have -auto-all in Ghc-Prof-Options, so what should I put instead?
13:10:36 <Athas> Alternatively, what is the cabal invocation to make it use -auto-all for profiling?
13:10:44 <Athas> 'cabal install --enable-profiling' is pretty useless without.
13:11:35 * hackagebot prosper 0.1.1 - Bindings to the Prosper marketplace API  http://hackage.haskell.org/package/prosper-0.1.1 (wraithm)
13:15:52 <statusfailed> I have two socket streams and I want to merge their output as it arrives, and print to the console. What librar(y|ies) should I be using?
13:16:00 <statusfailed> just Control.Concurrent?
13:16:35 * hackagebot lendingclub 0.1.1 - Bindings for the LendingClub marketplace API  http://hackage.haskell.org/package/lendingclub-0.1.1 (wraithm)
13:21:49 <khs> Hey, could someone help me figure out how to install the GLFW-b package on windows using the latest Haskell-Platform?
13:23:36 <quchen> statusfailed: Control.Concurrent and communication channels sound good to me
13:26:14 <haskell142> Hey guys, I'm reading typeclassopedia
13:26:15 <statusfailed> quchen: 'k. is there a library that makes it feel a bit more like describing a dataflow?
13:26:20 <haskell142> and these are the 2 functor laws
13:26:20 <haskell142> fmap id = id fmap (g . h) = (fmap g) . (fmap h)
13:26:22 <statusfailed> quchen: I was looking at netwire but I'm not sure
13:26:37 <quchen> netwire isn't what you're looking for, no.
13:26:39 <haskell142> I was wondering if there was a functor satisfies the second law but violates the first
13:26:57 <quchen> statusfailed:  pipes and pipes-concurrent would be good choices here, I think.
13:27:24 <quchen> haskell142: If you don't have ⊥, then the first law implies the second.
13:28:01 <statusfailed> quchen: I'll have a look, thanks
13:28:11 <haskell142> But the second one does not imply the first
13:28:17 <srid> is there a package that makes ghc error messages more friendly?
13:28:20 <ReinH> haskell142: (You can see this if you set g to id and apply the first law)
13:28:24 <quchen> ?let data Id a = Id a
13:28:26 <lambdabot>  Defined.
13:28:49 <ReinH> (and the definition of id)
13:29:21 <ReinH> > Identity 1
13:29:22 <lambdabot>  Identity 1
13:29:57 <exio4> instance Functor [] where fmap _ _ = [] would satisfy fmap (f.g) = fmap f . fmap g
13:30:02 <kadoban> haskell142: You can kind of trivially make one. It'd have to do something that lets you tell it's been fmaped once, but doing it twice wouldn't matter. Like, say you were doing a List, and fmap changed every input to [], that would satisfy the second
13:30:18 <kadoban> But obviously not the first.
13:30:24 <haskell142> ah.
13:30:25 <exio4> it is not a valid because you'd breaking the first law, which is way stronger :P 
13:30:31 <quchen> fmapId f x = f `seq` x `seq` (Id . f . runId) x -- satisfies the first, but not the second law
13:31:03 <quchen> (fmap (const ()) . fmap ⊥) x = x         but         fmap (const () . ⊥) x = x `seq` Id ()
13:31:08 <ReinH> quchen: It satisfies it morally ;)
13:31:09 <srid> Can someone help parse this ghc error? I'm pretty sure `fill` is returning [(Integer, Int)), which is getting passed to `draw`, yet ghci complains: https://gist.github.com/srid/042343022314d313fe74
13:31:20 <kadoban> Isn't bottom usually left out of these laws?
13:31:25 <quchen> ReinH: Then morally you can also leave the seq away ;-)
13:31:32 <ReinH> quchen: Deal.
13:31:38 <srid> as an aside, it would be nice if i can interactively introspect inferred type signatures of all inner functions
13:31:53 <srid> in an IDE, you would hover over to get the signature. i wonder how it would work when using Emacs
13:31:57 <ReinH> srid: I can do that.
13:32:00 <ReinH> In emacs.
13:32:05 <quchen> kadoban: It depends. GHC for example can't "morally" assume there is no ⊥ and fuse `fmap f . fmap g` to `fmap (f . g)`.
13:32:08 <srid> ReinH: how?
13:32:14 <haskell142> @ReinH
13:32:14 <lambdabot> Unknown command, try @list
13:32:18 <quchen> ?undef
13:32:18 <lambdabot> Undefined.
13:32:26 <haskell142> so if I set g to id
13:32:49 <haskell142> i get fmap(id . h) = (fmap id) . (fmap h)
13:32:54 <johnw> moral fusion
13:32:55 <haskell142> = id . fmap(h)
13:33:09 <haskell142> which is just (fmap h)
13:33:44 <haskell142> so fmap (id . h) = fmap (h) which satisfies the second law?
13:33:51 <haskell142> if I take the first law for granted
13:33:52 <haskell142> ?
13:34:16 <quchen> -XMorallyCorrectCompiler
13:36:49 <ReinH> srid: I'm trying to find the setting
13:37:41 <ReinH> haskell142: You also need the free theorem for fmap
13:37:43 <ReinH> @free fmap
13:37:44 <lambdabot> Extra stuff at end of line in retrieved type "Functor f => (a -> b) -> f a -> f b"
13:37:48 <ReinH> @free map
13:37:49 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
13:37:55 <haskell142> what's that
13:38:52 <ReinH> Actually, quchen has a proof for this lying around somewhere iirc
13:38:57 <monochrom> fmap (id . h) = fmap (h) is just a special case of the second law. and the first law does nothing to it.
13:39:20 <ReinH> monochrom: That's true. That's why you also need the free theorem.
13:39:28 <quchen> ReinH: I had, until I wasn't sure whether it was right anymore, so I removed it. But Edwardk re-wrote about it somewhere, and he's much more credible because he's a level 3 Haskeller.
13:39:34 <ReinH> heh
13:39:36 <haskell142> how does the free theorem help?
13:40:09 <exio4> level 3 Haskeller? I thought level 2 was the max
13:40:16 <exio4> which kind of cheats did he use? 
13:40:25 <bennofs> exio4: category theory
13:41:06 <ReinH> fmap (f . g)
13:41:09 <ReinH>   = fmap (id . (f . g)) { definition of id }
13:41:17 <EvanR> you can use cheats to go up to 65535 but the universes freezes up
13:41:40 <ReinH> Eh, probably should just find it rather than spamming
13:42:19 <ReinH> haskell142: https://www.fpcomplete.com/user/edwardk/snippets/fmap
13:43:53 <EvanR> whats the natural map of a type constructor ?
13:45:06 <ReinH> EvanR: ?
13:45:49 <ReinH> Ah
13:46:02 <EvanR> $map
13:47:03 <EvanR> its used in the statement of the free theorem in that blog post
13:48:09 <ReinH> EvanR: This is discussed a bit in the comments
13:48:19 <ReinH> If you search for "natural map" you'll find it
13:49:17 <haskell142> whats a natural map?
13:49:20 <haskell142> for a constructor
13:49:42 <haskell142> is it the map that the type has implicitly?
13:50:58 <EvanR> it seems to be confusingly the same or almost the same as fmap
13:51:09 <ReinH> haskell142: It's a term that is introduced in the comments and then lifted up into the body without explanation.
13:51:27 <ReinH> So you should read those comments.
13:51:33 <EvanR> tried
13:51:39 <haskell142> ah great.
13:52:16 <EvanR> the post itself seems to refer to natural map a lot so being completely lifted from comments seems wow
13:52:20 <ReinH> If shachaf were around, he might be able to shed more light. He likes to mention that the proof assumes that F is a functor already. Or at least, that was my interpretation.
13:52:40 <EvanR> yeah thats what it said
13:52:43 <EvanR> :S
13:52:53 <ReinH> edwardk seems to be saying that it only assumes that F can be constructed via coinduction?
13:53:30 <haskell142> $map :: (a -> b) -> F a -> F b -- positive only
13:53:34 <haskell142> isnt that just fmap
13:53:50 <ReinH> Specialized to some type constructor F, yes.
13:53:50 <EvanR> but F isnt necessarily a Functor
13:54:03 <EvanR> or maybe it is
13:54:23 <EvanR> well its not in the type at least
13:54:40 <ReinH> Ah. 'We can construct $map_F by (co)induction on the structure of F being made up of sums, products, (->)'s 1s, 0s, as and other co/contravariant components.'
13:54:40 <haskell142> so F can be any function?
13:54:51 <ReinH> F is a type constructor, not a function
13:55:00 <EvanR> interesting
13:55:08 <haskell142> 'We can construct $map_F by (co)induction on the structure of F being made up of sums, products, (->)'s 1s, 0s, as and other co/contravariant components.
13:55:11 <haskell142> ^^ What does that mean
13:56:16 <EvanR> if you take any single argument type which is defined according to those type building operations, then you can make the $map function
13:56:56 <ReinH> And you can reason algebraically out of "complex" structures made up of those "primitive" structures.
13:57:32 <ReinH> s/out of/about
13:58:46 <EvanR> haskell142: also ghc can automatically make your type a Functor this way ;)
13:59:33 <haskell142> are you guys robots
14:00:20 <Hijiri> what is the different between humans and sufficiently advanced robots
14:00:23 <Hijiri> difference
14:00:25 <rockfruit> magic
14:00:47 <monochrom> perhaps I am. how do you know?
14:01:00 <rockfruit> perhaps I am.  how would I know?
14:01:04 <monochrom> answer: if I make mistakes, I'm a human. if I am perfect, I'm a robot.
14:01:28 <monochrom> so ask me to factor a 20-digit number into prime factors. only robots can solve it.
14:01:37 * hackagebot diversity 0.5.0.0 - Return the diversity at each position for all sequences in a fasta file  http://hackage.haskell.org/package/diversity-0.5.0.0 (GregorySchwartz)
14:01:52 <ReinH> So my understanding is that any polymorphic algebraic type made from a constructor F (of kind * -> *) will have a map that sends F a -> F b. Whether that map is a (co- or contravariant) Funtor, a Profunctor (or whatever coerce is) depends on what position the `a' appears in. If it is contravariant, it will have a "natural map" $map :: (a -> b) -> F a -> F b
14:01:53 <monochrom> or, more relevant to Haskell, ask me to infer types.
14:02:13 <ReinH> EvanR: does that seem right?
14:02:21 <ReinH> er, *if it is covariant* at the end
14:02:55 <ReinH> You can use (co)induction on the algebraic structure to show this, which I can believe but not actually do.
14:03:36 <ReinH> monochrom: Unless you're a robot that is designed to simulate being human by making mistakes
14:03:38 <quchen> Isn't coinduction simply structural induction here?
14:03:49 <monochrom> :)
14:03:49 <ReinH> quchen: probably but it sounds fancier?
14:03:54 <srid> is there a way to do this using function composition? -- f (g x) x
14:04:03 <srid> in terms of f . g
14:04:03 <ReinH> srid: do what?
14:04:12 <EvanR> @pl \f g x -> f (g x) x
14:04:12 <lambdabot> flip flip id . liftM2
14:04:16 <monochrom> coinduction has several relations with structural induction, but they are still different
14:04:38 <srid> ?
14:04:55 <quchen> (f <*> g) x = f x (g x)
14:04:58 <EvanR> ReinH: when it comes to the negative position, im not sure what happens after that
14:05:13 <srid> quchen: great
14:05:13 <ReinH> srid: The goal is to show that fmap distributes over composition, so replacing composition with application won't really help much
14:05:14 <monochrom> for many recursive data types, you can use induction to derive coinduction, but you have to re-do the derivation for each such data type on a case-by-case basis.
14:05:36 <monochrom> for the general case, nothing says you can derive one from the other
14:05:38 <exio4> it's (=<<)
14:05:38 <ReinH> EvanR: I suppose you have a similar law about contramap?
14:05:54 <exio4> @type [(=<<), \f g x -> f (g x) x]
14:05:54 <lambdabot> [(a -> t -> b) -> (t -> a) -> t -> b]
14:06:30 <ReinH> @free contrama :: (b -> a) -> F a -> F b
14:06:30 <lambdabot> g . h = k . f => $map_F f . contrama h = contrama k . $map_F g
14:06:35 <quchen> ReinH: I don't think `Compose [] (-> a)` is functorial, as it is the composition of a co- and a contravariant functor
14:06:45 <EvanR> ReinH: but in the process of attempt to wrap $map, if you encounter the variable in the LHS of ->, does it foil the $map plan. in any case seems like a $contramap is out of the question too
14:07:18 <ReinH> EvanR: left side of -> is negative (contravariant) position
14:07:44 <EvanR> yes, so that messes up an attemp to write a $map at some stage of recursion
14:08:00 <ReinH> quchen: I think that's what edwardk was talking about when he said "The only source of moral ambiguity comes from the fact that things like newtype Compose f g = Compose { getCompose :: f (g a) } have no clear choice of variance for f and g selected."
14:08:43 <ReinH> At this point someone should light the edwardk signal.
14:09:05 <srid> exio4: type signature of =<< involves monads?
14:09:26 <exio4> (r ->) is a monad
14:09:38 <ReinH> exio4: ((->) r) is a monad
14:09:45 <ReinH> Wait that's what you said.
14:10:01 <trent_> hi guys, need a little help with XPCE...
14:10:01 <trent_> http://lpaste.net/130504
14:10:03 <ReinH> At this point co- and contravariance are getting jumbled up and I should probably take a break
14:10:03 <EvanR> ReinH: so if your type was (a -> Bool, a) it seems you cant make a Functor or a Contrafunctor
14:10:05 <shachaf> I can shed light on what?
14:10:35 <ReinH> shachaf: We're talking about the free theorem for fmap and the way it seems to be semi-circular
14:10:35 <evanjs> haha ContraFunctor 
14:10:38 <ReinH> @free map
14:10:38 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
14:10:39 <dolio> Yes, that's neither of those.
14:10:55 <ReinH> shachaf: in that $map assumes the type constructor is a Functor
14:11:19 <ReinH> or rather, the proof that fmap id = id implies the second law seems somewhat circular
14:11:29 <ReinH> "If f is a Functor then..."
14:11:50 <shachaf> It's not circular.
14:11:55 <dolio> It assumes it's a functor.
14:12:20 <shachaf> The proof assumes that $map_F exists and uses it to prove that foo :: (a -> b) -> F a -> F b such that foo id = id is equal to $map_F
14:12:36 <srid> >  (:) (Data.List.maximum [1..5]) [1..5]
14:12:37 <lambdabot>  [5,1,2,3,4,5]
14:12:38 <srid> > ((:) (=<<) Data.List.maximum) [1..5]
14:12:40 <lambdabot>      Couldn't match expected type ‘[Integer] -> t’
14:12:40 <lambdabot>                  with actual type ‘[(a0 -> m0 b0) -> m0 a0 -> m0 b0]’
14:12:40 <lambdabot>      The function ‘(:)’ is applied to three arguments,
14:12:43 <srid> see ^ it is not working
14:12:44 <shachaf> So if you already know that your type is a Functor, you don't need to prove the second law.
14:13:15 <ReinH> shachaf: In https://www.fpcomplete.com/user/edwardk/snippets/fmap, he seems to be saying that $map_F is guaranteed to exist when F a uses a in covariant position?
14:13:29 <ReinH> shachaf: Specifically in this comment https://www.fpcomplete.com/user/edwardk/snippets/fmap
14:13:35 <exio4> > ((:) =<< maximum) [1..5]
14:13:36 <EvanR> if you know something is a functor, then it satisfies the functor laws. how is that interesting
14:13:37 <lambdabot>  [5,1,2,3,4,5]
14:13:37 <ReinH> Uh. Thanks permalink.
14:13:43 <geekosaur> why did you wrap =<< in parens?
14:13:46 <ReinH> https://www.fpcomplete.com/user/edwardk/snippets/fmap#comment-1857527910 sorry
14:13:55 <srid> uh
14:13:58 <geekosaur> do you understans what that does?
14:14:05 <geekosaur> *understand
14:14:09 <trent_> anyone here know prolog xpce ?
14:14:10 <srid> because it is an operator no? same as you wrap (+) etc
14:14:24 <srid> oh ok n/m. got it
14:14:24 <mauke> > 2 (+) 2
14:14:25 <geekosaur> you wrap it when you are using it as a *function* uinstead of as an operator
14:14:25 <lambdabot>      Could not deduce (Num a0)
14:14:26 <lambdabot>      from the context (Num a, Num a2, Num ((a -> a -> a) -> a2 -> t))
14:14:26 <lambdabot>        bound by the inferred type for ‘e_122’:
14:14:30 <mauke> help, (+) doesn't work
14:14:33 <shachaf> Oh, Pseudonym is saying the same thing I am.
14:14:42 <srid> it *is* used as an operator, not as a function application
14:14:50 <srid> > (+) 2 2
14:14:51 <lambdabot>  4
14:15:08 <mauke> > ((=<<) (:) maximum) [1..5]
14:15:09 <horny-sama> out of curiosity, anyone here familiar with prolog?
14:15:09 <lambdabot>  [5,1,2,3,4,5]
14:15:17 <ReinH> shachaf: Right, that's where I got "somewhat circular" from. Edward has a response that I don't fully understand.
14:16:02 * geekosaur has used prolog... some 10 years ago, so it's rather bitrotted
14:16:14 <EvanR> mauke: nice lisp bro
14:16:26 <dolio> EvanR: If you know F is a functor, then any implementation of 'fmap :: (a -> b) -> F a -> F b' that you write is guaranteed to respect composition, as long as fmap id = id.
14:16:31 <mauke> thanks :-))))))))
14:16:39 <dolio> So you aren't obligated to prove it about your implementation.
14:16:59 <shachaf> edwardk is saying that, when we're dealing with Haskell 2010 types -- sums, products, exponents, etc. -- we won't be able to construct a function foo :: (a -> b) -> F a -> F b such that foo id = id unless F is a Functor.
14:17:23 <ReinH> shachaf: (so GADTs screw this up, like everything else nice in the world)
14:17:24 <shachaf> I probably buy that argument. But it still needs to be explicitly argued.
14:17:36 <EvanR> dolio: thats fine, but i thought the original context was, if you know fmap id = id, then you can show via parametricity that the second functor law is true (not necessarily using the fact that it is a functor already)
14:17:49 <shachaf> I don't even think you can make a counterexample with GADTs and other fancy GHC features, though I don't know.
14:17:59 <dolio> You can show that it holds for your implementation.
14:18:28 <ReinH> shachaf: I read it as saying that $map_F is guaranteed to exist if F uses its argument in covariant position. Is that incorrect?
14:20:21 <shachaf> I don't know. What do you do about the Compose example?
14:20:34 <ReinH> shachaf: If contravariant, you get contramap, if both you get dimap, if F doesn't use its argument, you get coerce (Data.Proxy.reproxy for free)?
14:20:52 <ReinH> s/ for free)/) for free
14:21:05 <ReinH> That seems like a pretty strong statement
14:21:05 <shachaf> dimap is for Profunctor. This one is called invmap on Hackage.
14:21:13 <disgrntld> hey gang, is there a sexy way I can do [(Int, Bool)] -> [Int], such that I get a list of all the Ints that are paired with True?
14:21:29 <indiagreen> disgrntld: map fst . filter snd
14:21:34 <disgrntld> yes, I knew it! :D
14:21:38 <disgrntld> thanks man
14:21:48 <mauke> disgrntld: [ n | (n, True) <- xs ]
14:21:54 <ReinH> shachaf: Ah yes, thanks
14:22:03 <disgrntld> filter snd is cool
14:22:06 <disgrntld> I like that one
14:22:16 <apo> mauke: indiagreen's is prettier
14:22:36 <mauke> but it does two loops
14:22:59 <disgrntld> but....cool
14:23:07 <disgrntld> lol, I keed
14:23:15 <ReinH> shachaf: Alright, I think I understand this better now. Thanks.
14:23:57 <shachaf> mauke: It gets fused.
14:24:19 <disgrntld> actually, mauke's is kinda subtle, right? relies on the error function of the list monad to filter, huh?
14:24:30 <disgrntld> I like that now
14:24:34 <ReinH> disgrntld: list comps use pattern matching, not fail
14:24:38 <disgrntld> ahhh
14:24:41 <disgrntld> oh, and fail* not error
14:25:00 <ReinH> monad comprehension extension uses fail, I guess
14:25:05 <disgrntld> ok, thanks for the help guys, projecteuler doesn't stand a chance
14:25:15 <shachaf> The two programs compile to identical code.
14:25:25 <mauke> shachaf: if you compile it, yes
14:25:40 <mauke> but when I'm reading the code, I see two loops
14:25:50 <ReinH> > take 5 . map fst . filter snd $ repeat (1,True)
14:25:52 <lambdabot>  [1,1,1,1,1]
14:26:04 <ReinH> No two loops over an infinite list
14:26:22 <mauke> lazy evaluation. your argument is invalid.
14:26:27 <ReinH> ?
14:26:40 <ReinH> How does lazy evaluation make an argument about lazy evaluation invalid?
14:26:43 <mauke> laziness transposes execution
14:26:47 <ReinH> what
14:26:52 <ReinH> You know what, never mind.
14:26:53 <disgrntld> > map fst . filter snd $ repeat (1,True)
14:26:54 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:26:59 <disgrntld> ...just wondering what would happen
14:27:25 <apo> > map fst . filter snd $ repeat (1,False)
14:27:26 <apo> :p
14:27:30 <lambdabot>  mueval: ExitFailure 1
14:27:36 <apo> :D
14:27:46 <disgrntld> ha
14:27:49 <mauke> instead of doing loop1 on elements x0 .. xn, then loop2 on y0 .. yn, laziness makes it do loop2 (loop1 x0), then loop2 (loop1 x1), ...
14:28:05 <ReinH> mauke: So your point is that my argument is invalid because it's correct?
14:28:26 <mauke> how is it correct?
14:28:26 <ReinH> Yes, that's more or less how laziness works.
14:28:37 <ReinH> Because that's how laziness works.
14:28:43 <mauke> it's still two loops
14:28:53 <mauke> they're just interleaved
14:28:53 <ReinH> In what possible sense is it still two loops?
14:28:55 <Hijiri> is it a loop
14:29:08 <mauke> in what sense is it not two loops?
14:29:09 <indiagreen> guys guys guys it doesn't matter
14:29:12 <indiagreen> okay, it's 2 loops
14:29:14 <indiagreen> what now?
14:29:14 <Hijiri> in what sense is it a loop
14:29:14 <ReinH> mauke: This is ridiculous
14:29:19 <exio4> it's 1.5 loops 
14:29:25 <mauke> ReinH: no, it's not
14:29:36 <indiagreen> like, even if it's 2 loops, I guess the problem is that mauke's mental model is “2 loops are worse than 1”
14:29:37 <ReinH> mauke: Stop trolling me please.
14:29:39 <mauke> (proof by claim)
14:29:40 <ion> There are four lights.
14:29:46 <mauke> ReinH: stop trolling me please
14:29:47 <shachaf> What mauke is saying makes sense to me.
14:29:54 <indiagreen> in which case mauke's mental model should be updated, I guess
14:30:03 <ReinH> It's literally impossible for there to be two loops since you can't traverse an infinite list twice.
14:30:12 <mauke> indiagreen: not necessarily worse, but harder to think about in some cases
14:30:20 <mauke> ReinH: non sequitur
14:30:22 <monochrom> however, it is still poor to get involved in a "is too" "is not" war
14:30:34 <disgrntld> from a novice perspective it's more clear to me that the list comprehension is one loop, where as the other's eventual combination to one loop isn't obvious to me (I'm noob though)
14:30:44 <disgrntld> *shrug*
14:30:47 * ReinH si ghs
14:30:53 <ReinH> This is why people don't like to talk to you
14:30:58 <monochrom> either provide evidence directly, so just say "I ran out of time"
14:31:01 <mauke> disgrntld: yeah, that's an optimization done by ghc (list fusion)
14:31:06 <monochrom> s/so/or/
14:31:25 <ephrion> stop using the word loop, it's a source of confusion
14:31:34 <disgrntld> gotcha, and learning point-free style is making this whole lazy evaluation + thunk + composition a little more clear
14:31:38 <shachaf> What monochrom is saying also makes sense to me.
14:32:10 <ReinH> I'm not interested in having a ridiculous argument about your private definition of "loop" where you respond by parroting my questions back to me in an inane way.
14:32:23 <disgrntld> let's talk about something less controversial, like abortion, or middle east policy
14:32:26 <disgrntld> :D
14:32:31 <mauke> ReinH: then why did you start one?
14:32:49 <ReinH> Now you're baiting me.
14:32:59 <monochrom> I disbelieve that ReinH started one. I believe that he asked a real question.
14:33:09 <EvanR> not even sure what loops are
14:33:28 <mauke> monochrom: I don't believe ReinH asked a question
14:35:27 <Cale> ReinH: Clearly it's going to loop twice over the whole infinite list http://i.imgur.com/jedfXV0.gif
14:35:34 <mauke> parroting ReinH, I believe he made a ridiculous statement about his private definition of "loop" where he responds to my counterarguments by making inane non-sequitur statements
14:35:45 <ReinH> mauke: please stop already
14:35:55 <monochrom> mauke, please stop
14:36:05 <ReinH> Cale: That gif is about right.
14:36:33 <ReinH> Cale: FSVO "loop", obviously.
14:38:29 <shachaf> What meaning of the word "loop" would make it clear?
14:39:27 <Cale> But while it's totally unclear what is meant by loops in any case here, maybe what mauke means is that there is potentially more allocation of intermediate structures being done by map fst . filter snd -- that's really hard to say though. The compiler is going to do a lot of stuff with this expression.
14:39:36 <ReinH> shachaf: We could have had an interesting conversation about when and why map f . filter p does or doesn't traverse the list twice, but instead we had whatever this was.
14:40:00 <ReinH> Cale: And yes, also about deforestation.
14:40:08 <Cale> To say that it goes through the list twice is weird though, when it might not make it through the list at all
14:40:18 <shachaf> I don't think optimizations or runtime performance were the point.
14:40:24 <ReinH> shachaf: Me neither.
14:40:26 <Cale> (for example, the list may be infinite, and we might only look at the first 4 elements)
14:40:41 <shachaf> If you wrote it in C with coroutines, you would have two loops.
14:41:05 <Cale> shachaf: whoa
14:41:17 <Cale> shachaf: I wasn't even thinking about coroutines
14:41:22 <Cale> lol
14:41:23 <monochrom> an interpreter of Haskell needs only one loop to execute all Haskell programs. the loop is inside the interpreter, or you can say meta-level.
14:41:39 * hackagebot html-entities 1.0.0.1 - An "attoparsec" parser and a decoder of HTML entities  http://hackage.haskell.org/package/html-entities-1.0.0.1 (NikitaVolkov)
14:41:56 <ReinH> Cale: Clearly the question is how many quasigroups with an identity element are involved.
14:42:12 <mauke> may I speak again?
14:42:12 <EvanR> -_-
14:47:57 <monochrom> if, on the other hand, you prefer not to look at the object level rather than the meta level, then you can't talk about the matter operationally (or maybe you can but it will be very tricky, and I don't see how). you are then left with syntactically or denotationally.
14:48:37 <monochrom> syntactically, if you write "f (g x)" where f is defined by recursion and g is defined by recursion, then clearly you are using two recursive functions.
14:50:48 <monochrom> denotationally, we're talking about math rather than computing, surely x is an infinite list, g x is g processing that infinite list to produce yet another infinite list, and f processes that to produce the third infinite list, and all this takes no time since the denotational semantics we use is timeless.
14:51:40 * hackagebot breve 0.0.3.0 - a url shortener  http://hackage.haskell.org/package/breve-0.0.3.0 (rnhmjoj)
14:52:13 <monochrom> therefore, the correct answer is that there are 3 loops, on account of the last choice :)
14:52:23 <monochrom> ALL OF YOU WERE WRONG!!!
14:57:09 <ReinH> monochrom: :)
14:57:32 <S11001001> in map fst . filter snd I count 4 loops, in the letters a, p, e, d.  In [ n | (n, True) <- xs ] I count only one, in the e.
14:58:37 <S11001001> on an appropriately configured emacs, the former may have 5 loops, of course.
15:00:04 <ReinH> S11001001: <3
15:00:09 <monochrom> I see what you did
15:01:23 <hpc> eliuv
15:02:25 <ReinH> Cale: I'm sad that you didn't appreciate my group theory joke. :(
15:03:47 <monochrom> but it was a quasi group theory joke...
15:05:54 <haskell513> https://www.fpcomplete.com/user/edwardk/snippets/fmap What is $map? 
15:08:00 <statusfailed> how do you tell if the other end of a Control.Concurrent.Chan has died?
15:09:26 <ReinH> statusfailed: "other end"?
15:10:11 <monochrom> I think you can't
15:11:48 <ReinH> Maybe "Chan" is poorly named? Chan is really a queue and doesn't, as such, have an "other end"...
15:12:04 <ReinH> It might have 0 or more writers
15:12:20 <ReinH> And there's no way to know what that number is.
15:13:56 <schell> has anyone done some nice benchmarks on the general use of IORef vs MVar vs TVar vs TMVar?
15:14:09 <ReinH> ... vs PRef
15:15:09 <arkeet> MVar and TMVar do different things from IORef and TVar.
15:15:19 <arkeet> (TMVar a is basically TVar (Maybe a) with some nice interface.)
15:16:04 <schell> okay, scratch TMVar ;)
15:16:41 * hackagebot cryptol 2.2.2 - Cryptol: The Language of Cryptography  http://hackage.haskell.org/package/cryptol-2.2.2 (AdamFoltzer)
15:16:41 <schell> arent MVar, IORef and TVar pretty interchangeable though?
15:16:51 <arkeet> MVars can be empty, the other two can't.
15:16:53 <schell> ReinH: I’ll have to look up PRef
15:16:57 <schell> aah, i see
15:17:10 <Cale> ReinH: haha, just got back
15:17:16 <ReinH> a "primitive" (unboxed) ref
15:17:25 <ReinH> Cale: :)
15:17:26 <arkeet> IORef is not really a good thing to use in a multithreaded case
15:18:04 <bitemyapp> schell: yeah I dunno about interchangeable.
15:18:24 <hunteriam> how can i get up to date ghc on debian?
15:18:29 <hunteriam> is there a repo I can add?
15:18:37 <bitemyapp> hunteriam: https://github.com/bitemyapp/learnhaskell#debian
15:18:44 <hunteriam> most distros suffer from outdated haskell...
15:18:48 <ReinH> Indeed.
15:18:54 <arkeet> still might be somewhat interesting to compare IORef/MVar/TVar performance in a non-concurrent environment though.
15:19:02 <hunteriam> are there options for other distros too?
15:19:06 <hunteriam> im on fedora right now
15:19:06 <arkeet> (an always-full MVar.)
15:19:21 <bitemyapp> arkeet: that sounds like a pretty easy benchmark to setup if you don't care about contention.
15:19:21 <Hijiri> hunteriam: you can use the binary distribution on the ghc downloads page
15:19:25 <ReinH> arkeet: IORef (Maybe a) and MVar a ;)
15:19:32 <Hijiri> hunteriam: it will just install itself into the prefix you give it
15:19:35 <ReinH> (I know they aren't the same at all)
15:19:50 <arkeet> ReinH: heh
15:19:52 <bitemyapp> yeah MVar has hooks into the runtime system that make queueing efficient.
15:20:01 <hunteriam> Hijiri: yes but having a package managed solution is way more appealing to me
15:20:08 <bitemyapp> hunteriam: that's what I just linked you.
15:20:18 <bitemyapp> you add a third party repo, then you install it.
15:20:25 <arkeet> hunteriam: at least on ubuntu hvr maintains this repo https://launchpad.net/~hvr/+archive/ubuntu/ghc
15:20:25 <schell> bitemyapp: yes - i think it would be nice just to know a comparison of access - reading, modifying
15:20:28 <arkeet> that has up to date ghc
15:20:34 <bitemyapp> arkeet: that's what my instructions tell them how to install
15:20:43 <schell> would that be something that criterion would be good for?
15:20:47 <bitemyapp> schell: yes
15:21:00 <bitemyapp> again, if you don't care about contention, criterion is fine for benchmarking such things
15:21:11 <arkeet> bitemyapp: ah right
15:21:13 <bitemyapp> simulating contention reliably is obnoxious in any framework though.
15:21:42 <schell> what does contention mean in this context?
15:21:54 <arkeet> multiple threads trying to access the same resource.
15:22:07 <schell> ahh
15:22:17 <bitemyapp> STM containers will thrash under contention...pretty badly.
15:22:29 <bitemyapp> MVars will make the threads form nice orderly queues like the good little british threads they are
15:22:36 <schell> lol
15:22:43 <bitemyapp> guaranteed fairness is nice :)
15:22:46 <bitemyapp> spopejoy: good article btw
15:23:24 <ReinH> bitemyapp: which article?
15:23:27 <ReinH> I like good articles.
15:23:52 <schell> ReinH: do you do haskellcast on soundcloud?
15:23:54 <bitemyapp> ReinH: wouldn't interest you, just basics.
15:23:57 <arkeet> I should read simon marlow's book.
15:24:07 <bitemyapp> ReinH: I happened to be writing the section on kinds when I saw spopejoy's tutorial.
15:24:17 <bitemyapp> I'm going to test both on my coauthor and see how the explanations shake out.
15:25:00 <ReinH> Cool.
15:25:09 <ReinH> arkeet: It's a good book! I should read it again.
15:25:32 <bitemyapp> arkeet: probably. It's a good book
15:25:51 <bitemyapp> the concurrency folklore in the Haskell community is actually pretty good though, IME, compared to some of the other stuff going around.
15:26:37 <ReinH> Especially after SimonM published his book!
15:26:50 <ReinH> The original paper was pretty good too
15:26:52 <bitemyapp> I wasn't involved enough to know what it was like before then, but the wisdom seems to have percolated well.
15:27:02 <ReinH> But less accessible.
15:27:07 <ReinH> Or, rather, harder to discover.
15:27:31 <ReinH> Than a book published by O'Reilly and available for free online
15:27:55 <frerich> I think a lot of people became aware of 'async' only because of that book. I think it should be a lot more well-known since getting all the concurrency stuff right in the face of exceptions is pretty tricky.
15:29:12 <bitemyapp> frerich: seen slave-thread?
15:29:19 <bitemyapp> frerich: http://hackage.haskell.org/package/slave-thread
15:31:41 <EvanR> slave-thread makes sense. is it only forkIO ?
15:33:44 <bitemyapp> EvanR: I think the idea is to have deterministic clean-up/hierarchy of lifespans a la supervisor trees.
15:33:52 <bitemyapp> EvanR: I don't know if it's limited to forkIO or not.
15:34:19 <frerich> bitemyapp: I wonder whether the author of that package is a good example of what I just wrote, seeing that his package was written two years after async and (judging by the documentation) it solves (a part of) the stuff which async does.
15:38:47 <gremble> I have a fairly novice question: I want to implement a function that takes a list of numbers as input and gives the mean as output. I've done that for Int values successfully, but I hoped to make it more general. I've tried having duplicate function definitions with the different type declarations. That did not work. Next I tried using the type declaration of sum to see if I can formulate something from t
15:38:53 <gremble> hat. The problem there is that (length xs) returns an Int value and fromInteger requires an Integer, leaving me rather confused
15:39:13 <gremble> (/) doesn't want to just divide with length xs I think
15:39:23 <ion> @type genericLength
15:39:24 <lambdabot> Num i => [a] -> i
15:39:25 <gremble> I get a cryptic error related to a not being int
15:39:50 <gremble> well, that was simple. Thanks ion
15:40:39 <bitemyapp> frerich: async and slave-thread do not solve the same problem.
15:41:20 <ion> Note that sum xs / genericLength xs traverses the list twice.
15:42:16 <ReinH> ion, gremble: genericLength is les efficient than length
15:42:24 <ReinH> :t fromIntegral . length
15:42:25 <lambdabot> (Num c, Foldable t) => t a -> c
15:42:55 <frerich> bitemyapp: Oh? I only glanced at the slave-thread documentation, it seemed to do thread trees (such that child threads are terminated when the parent times) and propagating exceptions. Didn't look very closely.
15:43:02 <ReinH> gremble: This is a nice writeup of the problem and a solution http://www.haskellforall.com/2013/08/composable-streaming-folds.html
15:43:13 <ion> > (\(Sum x, Sum n) -> x / fromInteger n) . foldMap (\x -> (Sum x, Sum 1)) $ [0..10]
15:43:14 <lambdabot>  5.0
15:45:13 <gremble> What is a space leak? I know memory leak and a vegetable leek
15:45:41 <gremble> (apparently prelude's sum causes one)
15:47:08 <barrucadu> A space leak is a memory leak
15:48:58 <gremble> Oh. I hoped it was something far more interesting.
15:49:31 <hpc> it's a bit of a pun
15:49:43 <hpc> because algorithmic complexity is measured separately for memory and time
15:49:45 <hpc> or space and time
15:49:49 <hpc> like physics
15:50:42 <gremble> Ah now I understand. Not just making life difficult with odd naming. 
15:51:13 <hpc> or like when you don't have enough space on your hard drive
15:51:24 <ReinH> Probably more of the latter, yeah
15:51:26 <hpc> most things have reasons for being names what they are
15:51:34 <hpc> except web frameworks, who the hell knows with those
15:52:27 <lachenmayer> "isomorphic" web apps, anyone? :P
15:52:35 <bennofs> yesod????
15:54:15 <frerich> bennofs: It's hebrew, I think
15:54:42 <bennofs> oh right, that makes sense. didn't know that :D
15:54:51 <geekosaur> it is, mneans "foundation"
15:55:09 <frerich> bennofs: I seem to recall Michael Snoyman once gave a Skype interview where he mentioned that (him being from Isreal)
15:55:29 <geekosaur> wghich makes more sense as a name than, say, sinatra
15:55:49 <frerich> 'geekosaur'? :-}
15:56:09 <geekosaur> nobody's named a web framework after me that I know of...
15:56:23 <geekosaur> (then again, these days who knows :p )
15:56:36 <gremble> It's probably been forked already
15:56:38 <bennofs> geekosaur sounds like a mix of geek and dinosaur to me
15:57:07 <gremble> It's latin for `terrible technical`
15:57:35 <bernalex> bennofs: so like tux?
15:57:36 <platz> so it seems the primary difference betweenan MVar and an IORef with atomicModifyIORef' is that MVar allows you to perform arbitrary side effects inside withMVar, whereas atomicModifyIORef must be pure
15:57:39 <bennofs> oh man, I need to learn more languages :)
15:59:52 <gremble> Thank you for this link ReinH. However, it seems about 6 hours more advanced than where I am at the moment (Like chapter 4 in Real World Haskell). Guess I shouldn't want to do difficult things :P
16:00:22 <barrucadu> platz: They're really very different: MVar operations block, for one thing
16:00:37 <bitemyapp> frerich: I don't know if he's from Israel or not, but I think he and his family live there now. I believe he lived in the US for awhile before that.
16:02:09 <ReinH> gremble: Well, it's not a difficult thing in theory but there are gotchas due to lazy evaluation.
16:02:28 <carter_cloud> platz:you could totally define an impure one 
16:04:22 <ReinH> gremble: for instance you might try:
16:04:23 <ReinH> > foldl (\(s,l) a -> (s + a, l + 1)) (0,0) $ [1,2,3,4]
16:04:25 <lambdabot>  (10,4)
16:04:33 <emma> Hi. Does anyone here like Better Call Saul?
16:04:51 <Fuuzetsu> seems like a question better suited for haskell-blah
16:04:53 <frerich> *plonk*
16:05:04 <platz> barrucadu: yeah, i guess if you want the blocking semantics you need MVar for that
16:05:10 <EvanR> or TVar
16:05:14 <ReinH> But this builds up thunks instead of immediately evaluating the accumulating function. So you might try foldl' instead, but this will only evaluate to WHNF and tuples are not strict so you are still building up thunks inside the tuples.
16:05:14 <arkeet> > foldl (\(s,l) a -> (s + a, l + 1)) (0,0) $ [1..1000000]
16:05:16 <lambdabot>  *Exception: stack overflow
16:05:21 <EvanR> (combined with retry)
16:05:21 <arkeet> > foldl (\(!s,!l) a -> (s + a, l + 1)) (0,0) $ [1..1000000]
16:05:22 <lambdabot>  *Exception: stack overflow
16:05:25 <arkeet> oh yeah.
16:05:27 <arkeet> > foldl' (\(!s,!l) a -> (s + a, l + 1)) (0,0) $ [1..1000000]
16:05:29 <ReinH> So you really need > foldl' (\(!s,!l) a -> (s + a, l + 1)) (0,0) $ [1,2,3,4]
16:05:29 <lambdabot>  (500000500000,1000000)
16:05:50 <EvanR> use strict tuple
16:05:56 <ReinH> Or you can just use the foldl package.
16:06:07 <emma> Fuuzetsu: oh thank you i didn't know there was such a channel :)
16:06:38 <ReinH> So you actually need a combination of foldl' and a strict tuple
16:07:19 <frerich> I should get a font where the lower-case L and the digit One looks more different...
16:07:27 <ReinH> frerich: Agree.
16:07:34 <arkeet> make sure capital I also looks different.
16:08:12 <gremble> ReinH: I could. I was just trying to see if I could make a more generic version of my Int implementation (which I guess causes a memory leak?). For now, I'm going to continue and turn a list into a palindrome because that is the next exciting exercise
16:09:48 <ReinH> > uncurry (%) . foldl' (\(!s,!l) a -> (s + a, l + 1)) (0,0) $ [1..1000]
16:09:49 <lambdabot>  1001 % 2
16:15:35 * ion looks at the foldl package… hey! this could be a Profunctor.
16:22:27 <schell> what would you call the class of containers IORef, MVar and TVar?
16:23:56 <arkeet> mutable references?
16:24:18 <mgsloan> Yup, mutable reference is a good name.  See, e.g. http://hackage.haskell.org/package/mutable-containers-0.2.1.2/docs/Data-Mutable.html#t:MutableRef
16:27:12 <oconnore> why do I get "Could not deduce (a ~ b)" here? -> https://gist.github.com/oconnore/dae505ba1e2141c23967
16:31:44 * hackagebot reflex 0.1.1 - Higher-order Functional Reactive Programming  http://hackage.haskell.org/package/reflex-0.1.1 (RyanTrinkle)
16:32:18 <oconnore> on line 31
16:33:04 <oconnore> I'm creating a monad transformer, which should have type CleanupT e m a -> (a -> CleanupT e m b) -> CleanupT e m b
16:33:25 <oconnore> and it's complaining that b may not ~ a, but that's not required
16:34:06 <oconnore> it seems like I'm introducing a constraint somewhere I'm not intending to
16:42:21 <Zemyla> Is there a set of rules fir converting a data type into its Church encoding?
16:42:23 <linman8> is it possible to denote the type variable of a variable in a function?
16:42:41 <hunteriam> oconnore: just a question, whats the intention of the monad cleanup?
16:43:53 <linman8> example:    instance List a where   something = fn1 $ (fn2 :: a)
16:44:21 <oconnore> hunteriam: I want to build a list of [IO ()] as I go, and then run them all when I'm done.
16:44:39 <hunteriam> oconnore: you know sequence does that?
16:44:58 <oconnore> hunteriam: no
16:45:11 <hunteriam> oconnore: no?
16:45:22 <oconnore> hunteriam: no, I didn't know that
16:45:33 <oconnore> hunteriam: hoogle'ing
16:47:34 <monochrom> sequence_ is better
16:47:41 <oconnore> hunteriam: wait, but I want a transformer where I'm guaranteed that anything I create that needs to be free'd will be as the stack unrolls
16:48:06 <hunteriam> oconnore: how can a transformer possibly do that?
16:48:21 <hunteriam> oconnore: id think youre better off adding those guarentees in the function thats returning IO ()
16:50:41 <oconnore> hunteriam: I was thinking I could do something like runCleanupT $ do { x <- liftIO $ newStablePtr z; putCleaner (freeStablePtr x); ... stuff that might throw an exception ... }
16:51:02 <oconnore> and then know that freeStablePtr x got called
16:52:51 <oconnore> I was writing a lot of code that was creating a CString, putting it in an mvar, and then later checking if anything was in the MVar, and freeing it if it is
16:52:56 <oconnore> so it would be nice to automate that
16:52:59 <hunteriam> why do you need a monad for this?
16:53:04 <hunteriam> whats an mvar?
16:53:10 <oconnore> MVar
16:53:18 <hunteriam> yea, idk what it is?
16:53:19 <linman8> is this possible given fn has a type variable of "a"? fn = fn2 :: a
16:53:39 <oconnore> http://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Concurrent-MVar.html <- hunteriam 
16:53:55 <monochrom> what is fn2?
16:54:46 <linman8> monochrom: lets say id
16:55:01 <monochrom> "fn = id :: a" is a type error
16:55:07 <hunteriam> oconnore: sadly ive got to go, good luck resolving this
16:55:11 <ReinH> oconnore: sounnds a bit like resourcet
16:55:15 <ion> oconnore: I commented on the gist.
16:56:07 <ion> You do not seem to be applying k there.
16:56:38 <linman8> monochrom: is it possible to get the 2nd line of code w/o throwing errors? http://lpaste.net/130512
16:56:47 <hunteriam> ion: did you use some sort of utility to help figure that out?
16:57:09 <oconnore> thanks ion hunteriam 
16:57:14 <ion> hunteriam: nope
16:57:16 <oconnore> ReinH: cool, I'll look into that
16:57:20 <monochrom> I do not know xpDefault
16:57:29 <monochrom> or zpZero
16:58:02 <monochrom> however, "def = ... (def :: a) ..." is the same as "def = ... (def :: b) ...", if you know what I mean
16:59:11 <linman8> monochrom: This is what i was looking for! {-# LANGUAGE ScopedTypeVariables #-}
16:59:32 <linman8> monochrom: that allows having the (def::a)
17:00:05 <geekosaur> it enables the syntax but not the semantics you want, I think
17:01:19 <linman8> monochrom: thnx for helping
17:01:32 <ion> linman8: You might be able to constrain a type of one value to match the type of another value you have access to using value-level things only.
17:01:46 <ion> Without seeing your code it’s difficult to be more specific.
17:04:02 <linman8> ion: it compiles and works. i was just trying to add "def" -> "(def::a)" to make things clearer.
17:04:32 <linman8> ion: the function def calls a def within it. but not recursively. adding (def::a) clarifys that
17:06:28 <geekosaur> oh, you weren't looking to force a type? then that is sufficient (and the syntactic extension used to be separate)
17:07:00 <linman8> geekosaur: right
17:08:06 <geekosaur> think I might just go with `def {- :: a -}` since otherwise it looks like it's trying to achieve a semantic effect...
17:08:51 <arkeet> comments are good.
17:11:11 <linman8> geekosaur: interesting. i'll google forcing value to see what u mean
17:11:45 <geekosaur> ?
17:11:50 <geekosaur> {- -} is just a comment
17:11:58 <geekosaur> I'm not forcing anything
17:12:29 <geekosaur> whereas what you wrote looks like you;re trying to force it to be of the type specified in the instance declaration, which won't work
17:12:37 <geekosaur> (at least, not like that(
17:13:03 <geekosaur> (I think you could do it with another extension though)
17:13:52 <geekosaur> or, as ion was hinting, find access to a value of the appropriate type and then use `asTypeOf` or etc.
17:14:05 <geekosaur> but I'm not sure you have one there
17:15:38 <linman8> yeah, i meant look up the situation to see why one see (def::a) as ambiguous. 
17:16:22 <geekosaur> because it looks like you want to "import" the type variable `a` from the instance declaration into that binding
17:16:38 <lisbeth> I'm new to haskel. Can you let me know what you think of my implementation of the * operator?
17:16:38 <geekosaur> people do indeed try to do it that way, and get confused when it works the way you intended instead of the way they wanted it to
17:16:39 <lisbeth> http://hastebin.com/yeyovolufo.pl
17:17:34 <geekosaur> in fact, I suspect most of us thought that was what you were trying to do, because it's a fairly common confusion that gets brought up here somewhat regularly
17:17:54 <geekosaur> (that is why ion answered the way they did)
17:17:56 <ion> lisbeth: You would benefit from using pattern matching. multiply 0 0 = 0; multiply x 1 = x; …
17:17:57 <lisbeth> heh crap frikken nano
17:18:01 <lisbeth> hold on
17:18:54 <lisbeth> Here's the whole thing: http://hastebin.com/memutitinu.pl
17:19:26 <geekosaur> possibly just rename one of the type variables so it doesn't look like you're trying to specifically "invoke" the `a` in `instance (Default a, Eq a) => Default (PU a)`
17:20:19 <teurastaja> so magmas are just binary operations, monoids are structures that fold over, monads sequence computations, functors are structures that map over, now what of thingazoid is there to know?
17:20:55 <teurastaja> groupoids?
17:21:20 <linman8> geekosaur: oh. you mean "a" as in the value it represents? instead of the type variable?
17:21:50 <rkat> #clojure
17:21:54 <rkat> sorry
17:21:56 <geekosaur> no. I'm apparently not gdoing a good job of explaining this
17:22:27 <geekosaur> it looks specifically like you are trying to use the specific type `a` from the instance declaration, to force a type that would otherwise not be determined correctly
17:22:36 <geekosaur> which is something people try to do, and which does not work
17:22:45 <geekosaur> (because it does what you intended it to do instead :)
17:23:22 <geekosaur> it's just a matter of a common confusion about scoping of instance declaration type variables
17:23:43 <geekosaur> and that it makes you look like you're trying to do something that you aren't
17:24:27 <linman8> geekosaur: why would they try to force a type?
17:25:19 <teurastaja> what is the difference between someThing :: (Eq a) => a   and   someThing' :: Eq a => a  ?
17:26:17 <glguy> The () around a single constraint are optional and have no semantic effect
17:26:41 <teurastaja> ok
17:26:57 <geekosaur> most commonly it's because they want to implement a (poorly designed) method which doesn't mention the instance type in its signature, and think they can somehow "import" it from the instance declaration. which doesn;t work because the comnpiler has to be ablew to deduce it from context in order to pick the right instance, and if the context wasn't determinable at instance definition time then it certainly won't be when they try to use it
17:27:44 <geekosaur> but people tend to not understand how typeclasses work, and think that if they just tell the compiler that some type internal to the method implementation is that of the instance, then the compiler will be able to sort it out somehow
17:27:56 <geekosaur> it's confusing, and based in a misunderstanding of how typeclasses work
17:28:41 <geekosaur> but the fact that your (intended to just be a distinct placeholder type) `:: a` looks like the same type variable as in the instance declaration, it looks like you're trying to do that
17:29:18 <linman8> geekosaur: haha.. yes trying to do that. thanks for the clarification.
17:30:33 <geekosaur> (as it turns out, you do intend that type, but have no reason to name it as such because you're not trying to unconfuse the compiler, you're trying to unconfuse a future reader of the code. hence, my proposing a comment instead of something that looks like you're trying to tell the compiler what to do)
17:30:34 <eacameron> Has there ever been talk of adding a "import" variant that eliminates the need for double-imports, like "import Data.ByteString (pack) qualified as B" or something similar
17:31:00 <linman8> geekosaur: yes, the comment idea was clear.
17:32:27 <linman8> geekosaur: ok g2g. there "force type" intention will probably make more sense when i am less tired. thnx agian
17:32:44 <linman8> *their
17:33:00 <geekosaur> maybe it;s better not to understand it since it's rooted in an incorrect idea that many other people have :)
17:33:10 <linman8> lol
17:41:10 <dmwit> eacameron: One would need to be a bit careful, as it's already possible to mix qualified with explicit import lists (with a meaning different than what you seem to want).
17:41:41 <dmwit> eacameron: But e.g. import Data.ByteString (pack) as B will define both pack and B.pack.
17:42:00 <monochrom> indeed, read my http://www.vex.net/~trebla/haskell/module.xhtml for the true meaning of various imports and exports
17:42:01 <geekosaur> I was going to comment that but (a) was already talking to someone else (b) `qualified` in the wrong place for the normal meaning...
17:42:30 <dmwit> sorry, import Data.ByteString as B (pack) -- is the correct syntax
17:42:44 <geekosaur> so I wondered if it was being "clever" (ew, try explaining why `qualified` does different things depending on where it is in the import...)
17:43:03 <monochrom> for example, the meaning of "module X(module Y ...)" is nothing like you intuit
17:44:40 <dmwit> That part may not be what you would guess. But it *is* pretty well-designed, at least.
17:45:05 <monochrom> I agree
17:45:15 <eacameron> dmwit: Quite right. The wording is crucial, but the fact remains that it's far less common to want both pack and B.pack than it is to want pack and B.*
17:45:19 <teurastaja> what would be instances of monads in the real world?
17:45:43 <dmwit> Probability distributions. Parsers. Loggers.
17:45:49 <monochrom> lists
17:45:55 <ion> IO
17:46:03 <dmwit> Depth-first search, a.k.a. lists.
17:46:28 <monochrom> what is real world?
17:46:32 <teurastaja> ehr..... doesnt seem specific at all
17:46:32 <ion> Exception handling
17:46:42 <dmwit> (Also more nuanced search, a.k.a. Omega.)
17:46:52 <dmwit> teurastaja: That's kind of why it's useful.
17:47:15 <dmwit> It's generic enough that many things are monads. So you get to reuse all your monad-y operations in all kinds of unexpected places.
17:47:35 <teurastaja> what is IO in the real world? or loggers?
17:47:42 <monochrom> what is real world?
17:48:20 <teurastaja> the world outside the computer i mean
17:48:22 <monochrom> how about this: are design patterns in real world?
17:48:37 <glguy> "grocery bag of _" is a realworld monad (as long as your bags are expandable)
17:48:48 <Hijiri> burrito filled with _
17:48:54 <monochrom> lists are in my world outside the computer
17:49:00 <monochrom> YMMV
17:49:58 <monochrom> if lists are not in your world outside the computer, my condolence for living in a bland world where there are not lists
17:50:27 <teurastaja> so as long as you have a null type and a "concatenable" type you have a monad?
17:50:45 <monochrom> I don't understand that terminology
17:51:03 <teurastaja> unit and join
17:51:10 <monochrom> "lists" is one single type, not a combination of two types
17:51:12 <teurastaja> if i understood
17:51:20 <monochrom> unit and join are not types
17:51:29 <teurastaja> functions then
17:51:38 <glguy> also if you're going the unit, join route you need a map, too
17:51:56 <monochrom> unit is not analogous to null. far from it.
17:52:19 <monochrom> analogizing join as concatenation also lasts pretty shortly
17:52:31 <teurastaja> what is then?
17:52:42 <monochrom> 0 is analogous to null.
17:54:58 <teurastaja> i thought it went along the lines of "as long as you have a null list and a consing operation that can be anywhere on sets, you have a list monad"? im wrong?
17:55:18 <teurastaja> *that can be applied anywhere on...
17:55:18 <monochrom> yes
17:55:34 <teurastaja> yes im wrong?
17:55:38 <monochrom> yes
17:55:56 <monochrom> unit for lists is (\x -> [x]). is [x] a null list?
17:56:32 <glguy> null/concat sounds more like you were hearing about monoids...
17:56:40 <monochrom> not to mention that unit for lists is (\x -> [x]) rather than [x] itself
17:56:46 <teurastaja> its a 0 to +infinity sized list
17:56:51 <teurastaja> ?
17:57:03 <monochrom> yes. does it matter?
17:58:16 <monochrom> glguy: it is safe to say "wrong" even if monoid is intended, since the part "anywhere on sets" garbles the whole sentence anyway
17:59:28 <teurastaja> by anywhere on sets i was refering to functors
17:59:33 <teurastaja> well fmap
17:59:44 <monochrom> that garbles more, not less
18:00:06 <teurastaja> then what is a correct definition?
18:00:20 <monochrom> unit, join, and fmap
18:00:36 <teurastaja> null and concat are monoids?
18:01:17 <monochrom> and they are functions, not lists, even if we are using the lists example. in the lists example, they are functions with list codomains. they are not lists.
18:01:48 * hackagebot pointfree 1.1 - Tool for refactoring expressions into pointfree form  http://hackage.haskell.org/package/pointfree-1.1 (BenMillwood)
18:01:53 <teurastaja> ok i understand this
18:02:08 <Fylwind> is there a way to figure out what package.conf.inplace cabal is using (w/out hardcoding)?
18:02:49 <Fylwind> in an easy way for a script, that is.  I know I can figure it out by reading the build output with --verbose
18:02:57 <teurastaja> so a monad is just a functor with unit and join?
18:03:04 <monochrom> yes
18:03:12 <teurastaja> yay!
18:03:44 <teurastaja> and monoids have null and concat?
18:03:50 <monochrom> yes
18:05:03 <teurastaja> but join seems like it adds unnecessary lists does it?
18:05:29 <ion> join :: [[a]] -> [a]
18:05:41 <glguy> You'd probably have to tell us what an unnecessary list is
18:06:45 <monochrom> and "add"
18:07:02 <monochrom> time to wave around: explain to me like I don't know what you mean
18:07:27 <teurastaja> xs >>= f = concat (map f xs)
18:08:00 <teurastaja> maybe i confuse bind and join?
18:08:55 <teurastaja> are they different?
18:09:11 <ronh> completely
18:09:24 <teurastaja> :(
18:09:28 <teurastaja> how?
18:10:17 <ronh> is concatMap different than concat?
18:10:23 <ronh> :t concat
18:10:24 <lambdabot> Foldable t => t [a] -> [a]
18:10:25 <ronh> :t concatMap
18:10:26 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
18:11:22 <teurastaja> concat is a monad??
18:12:01 <ronh> yes.. but only because all functions are monads
18:12:18 <shachaf> No Haskell functions are monads.
18:12:27 <hpc> no, ((->) a) is a monad
18:13:06 <teurastaja> why do you say M a sometimes and (a -> b) another then?
18:15:03 <ronh> [] is a monad, [a] is? monadic value?
18:15:19 <jellie> Is ghc-mod a package that is still maintained?
18:16:21 <teurastaja> why do people in #math tell me monads are souls?
18:16:27 <shachaf> [] and [a] the types or the values?
18:16:42 <ronh> the actual list object I mean or object of any monadic. what is it called
18:16:48 * hackagebot directory 1.2.2.1 - Platform-agnostic library for filesystem operations  http://hackage.haskell.org/package/directory-1.2.2.1 (Rufflewind)
18:16:49 <ronh> monadic type*
18:16:54 <Cale> teurastaja: who?
18:17:27 <teurastaja> Magnus_RM
18:17:50 <ronh> lets try again with an example:  [1,2,3] <- monadic value?  getLine <- the same?
18:17:50 <Cale> ronh: a list?
18:17:58 <Cale> getLine is an IO action
18:18:16 <Cale> In general, you could call values of type M a "M actions", but there's usually some better term.
18:18:19 <ronh> what is a more general term? is monadic value correct
18:18:31 <shachaf> "action" is a reasonable word for it, if completely unrelated to the mathematical use of the same word.
18:18:37 <Cale> "Value whose type was constructed with a monad"
18:19:06 <teurastaja> is that the same as arrow?
18:19:13 <Cale> teurastaja: hm?
18:19:22 <teurastaja> "action"
18:19:54 <Cale> no
18:20:13 <Cale> "M-action" = "value of type M a for some type a"
18:21:11 <Cale> This terminology comes from the fact that most monads in Haskell are type constructors for types of computations.
18:21:46 <Cale> Like Parser, IO, STM, State s, etc.
18:21:48 * hackagebot notcpp 0.2.0.3 - Avoiding the C preprocessor via cunning use of Template Haskell  http://hackage.haskell.org/package/notcpp-0.2.0.3 (BenMillwood)
18:22:12 <Cale> So it's natural to think of the values of types like that as actions of some sort.
18:22:32 <teurastaja> people in #math dont like monads they automatically say => #haskell. are they afraid of category theory? lol
18:22:50 <shachaf> Cale: That's easy when you define "computation" to mean "M-action for some monad M". :-)
18:23:05 <Cale> teurastaja: Don't generalise, you just ran into some particular people :P
18:23:19 <Cale> shachaf: Well, sure
18:23:21 <teurastaja> perhaps
18:23:41 <Cale> teurastaja: Also, monad does have a philosophical meaning which has nothing to do with mathematics
18:23:49 <Cale> So maybe one of them thought you were referring to that
18:23:54 <teurastaja> but saying a monad is a soul sounds like bullshit
18:24:03 <Cale> yeah, that kind of silly thing
18:24:18 <Cale> http://en.wikipedia.org/wiki/Monad_%28philosophy%29
18:24:24 <jellie> I'm getting the following error when building ghc-mod http://lpaste.net/8969865534988353536
18:24:41 <jellie> Not in scope: data constructor 'ExposePackageId'
18:24:41 <Cale> It's etymologically distinct from the usage in mathematics though
18:25:04 <Welkin> https://en.wikipedia.org/wiki/Monad_%28philosophy%29
18:25:28 <Welkin> this one is my favorite: http://ergoproxy.wikia.com/wiki/Monad
18:25:33 <jellie> Here is the file https://github.com/kazu-yamamoto/ghc-mod/blob/master/Language/Haskell/GhcMod/Gap.hs#L256 
18:25:34 <Cale> One of the early names for "monad" was "triad", and the things are abstractly very much like monoids
18:25:39 <teurastaja> philosophy also has monisms though which are "first principles" and the word comes from greek meaning "unique". but a soul... call it god then...
18:25:57 <Cale> teurastaja: Yeah, it's just someone pulling your leg
18:26:37 <teurastaja> theres no one pulling my leg :/
18:27:27 <Cale> It's an expression
18:27:47 <arkeet> Cale: you mean "triple"
18:27:53 <teurastaja> i figured but i dont understand it
18:28:07 <Ashandalar> > 1 + 1
18:28:08 <lambdabot>  2
18:28:19 <Cale> arkeet: "triple" as well
18:28:22 <teurastaja> what is a natural transformation?
18:28:32 <Cale> arkeet: also "the standard construction"
18:28:38 <Ashandalar> @pl (\x y -> x ++ [] ++ y)
18:28:38 <lambdabot> (. ([] ++)) . (++)
18:28:39 <arkeet> never heard either of those.
18:28:42 <teurastaja> is it a morphism of functors?
18:28:45 <arkeet> teurastaja: yes
18:28:47 <Cale> teurastaja: Yes.
18:29:03 <teurastaja> Yay im getting smarter!
18:29:04 <Cale> Given categories C and D, and functors F, G: C -> D
18:30:10 <Cale> a natural transformation eta: F -> G consists of, for each object X in C, an arrow eta_X : F X -> G X in D
18:30:23 <teurastaja> ive seen descriptions of monads with a "triple" of 1 natural transformation and 2 other thingamabobs i dont remember/understand
18:30:57 <Cale> such that for each arrow a: X -> Y in C, you have that the square eta_Y . Fa = Ga . eta_X commutes.
18:31:06 <Cale> (i.e. that this equation is true)
18:31:44 <Cale> A monad consists of a functor T: C -> C, together with natural transformations eta: 1 -> T, and mu: T^2 -> T, satisfying some additional laws
18:32:40 <Cale> In Haskell, we represent natural transformations between functors on the category of Haskell types by polymorphic functions
18:32:57 <teurastaja> so its an endofunctor with 2 weird ways of mapping functors?
18:33:06 <Cale> Well, not so weird :)
18:33:19 <Cale> but yeah
18:33:43 <Cale> The natural transformation eta says that for each object X, there's an arrow eta_X: X -> TX
18:33:51 <teurastaja> im impressed by my own speech :P i used endofunctor!
18:33:53 <Cale> In Haskell, this is called return
18:33:59 <Cale> :t return
18:34:00 <lambdabot> Monad m => a -> m a
18:34:18 <ReinH> "...with these 2 weird tricks. ##mathematicians hate them"
18:34:25 <Cale> And for mu, we have for each object X, an arrow mu_X: T (T X) -> T X
18:34:30 <Cale> In Haskell, we call this join
18:34:32 <Cale> :t join
18:34:33 <lambdabot> Monad m => m (m a) -> m a
18:34:49 <teurastaja> oh!
18:35:05 <teurastaja> so its the same description as earlier
18:35:07 <Cale> With fmap and join, you can define (>>=)
18:35:17 <Cale> i.e. x >>= f = join (fmap f x)
18:35:21 <arkeet> :t \m f -> join (fmap f m)
18:35:22 <lambdabot> Monad m => m a1 -> (a1 -> m a) -> m a
18:35:35 <teurastaja> i dont quite understand join though what is it?
18:35:52 <teurastaja> i confused it with bind
18:36:03 <Cale> Well, we can look at some examples
18:36:16 <Cale> For the list monad it's easy to guess :)
18:36:17 <arkeet> :t \m -> m >>= id
18:36:18 <lambdabot> Monad m => m (m b) -> m b
18:36:39 <Cale> For the list monad, it'll have type [[a]] -> [a]
18:36:47 <Cale> Can you think of a reasonable such function?
18:36:50 <arkeet> often the implementation of  join  is more straightforward than that of  >>=
18:36:51 <ReinH> (T^2 = T x T, the product of T with itself, btw)
18:36:56 <teurastaja> wow hold on you asked the type of a lambda??
18:36:57 <Cale> hm?
18:37:10 <teurastaja> makes sense
18:37:14 <Cale> ReinH: That's a confusing thing to say, given that it's the composite :)
18:37:20 <arkeet> ReinH: (of course, that depends on what we mean by "product")
18:37:36 <ReinH> Cale: well, you skipped straight from T^2 to T (T X)
18:37:40 <arkeet> (the monoidal product in a monoidal category of endofunctors is just composition)
18:37:46 <arkeet> T^2 = T . T
18:38:06 <teurastaja> this is going a bit too fast
18:38:06 <ReinH> Cale: right, but X^n generally means the n-fold product of X
18:38:22 <arkeet> and it does.
18:38:26 <ReinH> I think a step was skipped, is all
18:38:27 <ReinH> arkeet: I know
18:39:08 <Cale> ReinH: Yeah, it's just that normally if you say "product of functors", you mean the functor defined by (F × G) X = F X × G X
18:39:16 <ReinH> Cale: fair enough
18:40:07 <teurastaja> so join is like composition?
18:41:12 <Welkin> join is the opposite of return (or pure)
18:41:13 <teurastaja> or were you composing functors?
18:41:40 <arkeet> join :: Monad m => m (m a) -> m a
18:41:43 <Welkin> join just peels off one layer of the monad
18:41:52 <Cale> teurastaja: join is a natural transformation from the composite of T with itself back to T.
18:41:54 <teurastaja> return packs it up in a monad
18:41:56 <teurastaja> right>?
18:42:03 <arkeet> join tells you how to take something wrapped up in 2 layers of your monad
18:42:04 <Cale> i.e. a natural transformation T . T -> T
18:42:06 <arkeet> and squish it down to 1 layer
18:42:26 <arkeet> e.g. join :: [[a]] -> [a]
18:42:36 <arkeet> or (r -> (r -> a)) -> (r -> a)
18:42:46 <Cale> teurastaja: return is a natural transformation 1 -> T, so its component at some object X is an arrow X -> TX
18:42:58 <arkeet> or IO (IO a) -> IO a
18:43:09 <ReinH> (1 being the identity functor, so 1(X) = X)
18:43:19 <Cale> Or in terms of Haskell, for each monad M, return is a polymorphic function of type a -> M a
18:44:06 <Cale> teurastaja: I'm assuming in all this discussion that you're actually interested in mathematics and not just Haskell, or else I'd be describing everything with quite different language :)
18:44:34 <Cale> teurastaja: How much mathematics do you know? Are you familiar with metric spaces?
18:44:37 <arkeet> sure, there are plenty of examples in mathematics too.
18:44:43 <arkeet> of monads.
18:45:03 <teurastaja> im stuck in preengineer post high school math level
18:45:04 <Cale> I could give some examples of monads from around the rest of mathematics which might help.
18:45:10 <Cale> oh, okay
18:45:21 <ReinH> Cale: you can give me some if you want
18:45:46 <teurastaja> my math teacher never heard of category theory
18:46:04 <teurastaja> but he knows set theory
18:46:16 <ReinH> I would hope so
18:46:17 <arkeet> e.g. if your category is a poset, a monad on that is precisely a closure operator.
18:46:23 <Cale> Probably the first example which came up in my undergrad was the double dual of a vector space. (We didn't actually point out that it was a monad, but it is)
18:46:27 <arkeet> and there are a variety that come up in algebra.
18:47:34 <Cale> What we *did* prove was that there's a natural transformation whose components are linear maps V -> V**
18:48:22 <teurastaja> poset is <=?
18:48:27 <lisbeth> Why is it that haskell programs are commonly distritbuted in cabal rather than going through traditional package distribution?
18:48:29 <arkeet> partially ordered set
18:48:43 <arkeet> any poset P forms a category where
18:48:46 <arkeet> the objects are elements of P
18:48:46 <lisbeth> as in trying to get the binaries into the repos
18:48:53 <teurastaja> a set with <= between elements?
18:49:04 <arkeet> yeah
18:49:06 <arkeet> satisfying some laws
18:49:08 <Cale> teurastaja: Yeah, in fact, we can go a little farther than posets
18:49:18 <arkeet> yeah, any preorder will do.
18:49:34 <arkeet> anyway, the arrows are
18:49:46 <arkeet> well there is one arrow from x to y if x <= y, and no arrow otherwise.
18:49:51 <Cale> A preorder on a set S is a binary relation <= which is reflexive, i.e. for every a in S, we have a <= a, and transitive, i.e. for every a,b,c in S if a <= b and b <= c then a <= c
18:50:00 <arkeet> identities exist because <= is reflexive, and composition works because <= is transitive.
18:51:04 <ReinH> lisbeth: Some Haskell programs that are popular outside the Haskell community have distro packages, e.g., http://johnmacfarlane.net/pandoc/installing.html
18:51:30 <arkeet> how popular is git-annex?
18:51:59 <Cale> A functor between such preorder categories is a monotone map, i.e. one which preserves the ordering between elements, because it sends objects to objects in such a way that for each arrow X -> Y, (i.e. if X <= Y), we have an arrow FX -> FY (i.e. FX <= FY)
18:53:13 <teurastaja> are arrows just one-way pipes between 2 objects? ie: objects that link or imply their second argument?
18:53:36 <arkeet> arrows are abstract things.
18:53:42 <arkeet> they're just part of the definition of a category.
18:53:43 <Cale> If C and D are such preorder categories with F, G functors C -> D, and we have a natural transformation eta: F -> G, then it means for each X in C, we have an arrow eta_X: FX -> GX, which you can read as saying that for every X, FX <= GX
18:53:47 <ReinH> arkeet: popular enough to have distro packages, at least https://git-annex.branchable.com/install/
18:54:03 <arkeet> what exactly an arrow represents depends on the category.
18:54:20 <arkeet> in general a category is just
18:54:25 <arkeet> a bunch of things, called objects
18:54:29 <arkeet> another bunch of things, called arrows
18:54:53 <arkeet> and for each arrow there are two associated objects, called its domain and codomain
18:54:54 <teurastaja> morphisms being the same?
18:55:03 <arkeet> morphism and arrow are synonymous, yes
18:55:21 <ReinH> teurastaja: An arrow can represent implication, or some other relationship, depending on the category. Yes.
18:55:27 <arkeet> and then some more data telling you about identity arrows and composition of arrows.
18:55:39 <ReinH> Without knowing anything else, you just know that it has an object at both ends and points from one to the other.
18:55:48 <Cale> If you say "morphism", then it tends to make people think of "structure preserving function" specifically though.
18:56:11 <teurastaja> but does morphism imply homomorphism?
18:56:17 <Cale> yeah
18:56:22 <arkeet> sure, you often hear phrases like "morphism of sets" (or of groups, or of categories, or ...)
18:57:00 <Cale> "morphism" is literally just a short form of "homomorphism"
18:57:06 <arkeet> which just means it's a morphism in whatever category you associated to sets/groups/categories
18:57:23 <arkeet> in which the morphisms are generally defined to be whatever you want to call homomorphisms.
18:57:37 <teurastaja> what are groups?
18:57:48 <arkeet> something in mathematics.
18:57:53 <Cale> Many examples of categories throughout mathematics come in the form where the objects are sets equipped with some additional structure of some kind, and the arrows are functions between those sets which respect that additional structure somehow.
18:58:12 <ReinH> Cale: Right, and in that sense morphism and arrow really are synonymous...
18:58:36 <Cale> A group is a set G equipped with a binary operation *: G x G -> G, typically called multiplication, satisfying a few laws:
18:58:57 <Cale> 1) Multiplication is associative, i.e. for any a,b,c in G, we have a * (b * c) = (a * b) * c
18:59:27 <Cale> 2) There is an element e in G (also often written 1), such that for any a in G, we have e * a = a * e = a
18:59:29 <teurastaja> so a group is a magma?
18:59:39 <arkeet> it's a particular kind of magma.
18:59:45 <Cale> 3) For any a in G, there is some b in G such that a * b = b * a = e
18:59:55 <arkeet> magmas have no laws.
19:00:01 <arkeet> monoids are magmas satisfying 1) and 2) above.
19:00:09 <arkeet> groups are specific kinds of monoids.
19:00:27 <arkeet> that additionally satisfy 3)
19:00:31 <Cale> 2 says that there's an identity element for multiplication
19:00:52 <Cale> and 3 says that every element a has an inverse b which when multiplied together give the identity
19:00:53 <teurastaja> what are groups useful at?
19:01:01 <sellers> *LOTS* of stuff
19:01:02 <Cale> Representing the symmetries of an object
19:01:38 <arkeet> a familiar example might be addition
19:01:39 <arkeet>  integers, with the operation being addition
19:01:46 <teurastaja> is humanity a group?
19:01:46 <arkeet> uh
19:01:50 <arkeet> wtf happened to my line.
19:01:58 <arkeet> a familiar example might be the set of integers, with the operation being addition.
19:02:01 <Cale> teurastaja: Under what multiplication?
19:02:07 <teurastaja> sex
19:02:10 <Cale> no.
19:02:13 <arkeet> or the set of nonzero rational numbers under multiplication.
19:02:26 <sellers> There's no inverse, so...
19:02:32 <arkeet> or the set of permutations on a set, with composition.
19:02:52 <arkeet> this last example being like
19:02:56 <Cale> Actually, maybe?
19:03:11 <teurastaja> if we say that every man has its opposite arent we a group?
19:03:16 <arkeet> all the symmetries of a set.
19:03:52 <arkeet> teurastaja: if you can figure out which set exactly you mean, and what the binary operation on that set is
19:03:58 <arkeet> and show that it satisfies those 3 laws, then sure.
19:04:31 <arkeet> http://en.wikipedia.org/wiki/Group_%28mathematics%29
19:05:06 <teurastaja> is humanity a quasigroup then?
19:05:28 <Cale> teurastaja: You'd have to be a little more careful about exactly what function on chromosomes you're talking about
19:05:37 <Cale> Normally it's thought of as a random process
19:06:01 <Cale> It's kind of a monoid on sets of potential combinations of chromosomes
19:06:51 <Cale> (or at least a semigroup, depending on exactly what operation we're talking about)
19:07:10 <Cale> If you want probability distributions, I don't even think it's a semigroup anymore.
19:07:18 <dreams> guys, when I compile with ghc prog.hs I don't get executable anymore :O
19:07:31 <dreams> It just happened all of the sudden now
19:07:37 <teurastaja> meaning that mutations carry over all elements of the system?
19:07:47 <Cale> dreams: What do you get? Is there a main defined in that module?
19:07:59 <dreams> Cale: yes it was working fine all day
19:08:00 <Cale> teurastaja: I'm not even considering mutations, either.
19:08:13 <Cale> teurastaja: Just what normally happens.
19:08:26 <dreams> Cale: I deleted the executable, when I compile it doesn't produce anymore even when I change something and recompile.
19:08:43 <Cale> dreams: Try deleting the .o and .hi?
19:08:52 <Cale> dreams: do you get back a .o?
19:08:54 <arkeet> try passing -fforce-recomp?
19:08:55 <jle`> probability distributions form a semigroup under conjuctions, don't they?
19:09:04 <teurastaja> i was thinking that the product of 2 human beings is another human no?
19:09:09 <dreams> Cale: I still have .o and .hi, never deleted them. I'll try that.
19:09:20 <carter> jle`: conjunction?
19:09:24 <carter> use real math words
19:09:27 <Cale> teurastaja: Not a well-defined one. Your children aren't clones of each other.
19:09:34 <arkeet> what's not real about conjunction?
19:09:39 <carter> jle`: what do you mean
19:09:55 <arkeet> (although conjunction is a thing you do on events, not distributions.)
19:10:13 <jle`> yeah i think i flew a little fast with the word choice
19:10:23 <dreams> Cale: I get back .o and .hi and bot the executable
19:10:24 <jle`> let me rephrease
19:10:24 <teurastaja> alright so how about a definition which allows folding of mutations?
19:10:36 <dreams> not*
19:10:38 <Cale> teurastaja: mutations will only complicate things further
19:10:48 <teurastaja> its genetics
19:11:03 <teurastaja> there has to be mutation no?
19:11:33 <teurastaja> random mutations one in a while and a fitness function
19:11:40 <teurastaja> *once
19:12:14 <dreams> Cale: I changed the module name to Main, now I get it. Thats weird it used to work before.
19:12:36 <jle`> the semigroup i had imagined has vanished in the light of actual definition
19:12:44 <Cale> teurastaja: There's variation even without mutation, this is the advantage that sexual reproduction has over asexual.
19:12:47 <carter> jle`: whats goal
19:12:50 <jle`> (the process of actually defining it)
19:12:53 <jle`> it is meaningless :O
19:13:22 <jle`> (the thing that i had imagined is meaningless)
19:13:24 <arkeet> perhaps this is drifting a bit off topic
19:13:39 <Cale> Yes, very off topic :)
19:13:51 <Cale> If you want to talk about genetics, we should do that in #haskell-blah
19:13:55 <teurastaja> AI is off topic?
19:14:04 <Cale> I'm not talking about AI
19:14:07 <arkeet> -blah is pretty quiet now
19:14:10 <Cale> I'm talking about actual genetics
19:14:23 <teurastaja> i was talking about genetic algorithms
19:14:36 <Cale> This channel is for discussion of Haskell
19:14:39 <Cale> really
19:14:46 <Cale> and closely related topics
19:15:47 <Cale> teurastaja: In a genetic algorithm, you *might* implement some sort of gene combination operation which happened to be a semigroup or monoid, but it's much more arbitrary what goes on there
19:16:56 <Cale> Even then, you usually don't worry about things being associative there
19:18:05 <Cale> teurastaja: a better example of a group would be something like all the moves you can make on a Rubik's cube
19:18:44 <Cale> teurastaja: If you do move A then (move B then move C), it's the same as doing (move A then move B) then move C
19:19:02 <Cale> teurastaja: there's an identity move, which is just to leave the cube alone
19:19:32 <Cale> teurastaja: and you can undo the effects of any move, by carrying out the opposite of each turn in reverse order
19:20:22 <arkeet> and there's some general group theory machinery that you can throw at this group and solve a rubik's cube :-)
19:20:41 <arkeet> there's some nice comptuational abstract algebra software called GAP that can do this.
19:22:43 <Cale> GAP is such a nice library written on top of such a quirky programming language
19:25:48 <Cale> One of the weirdest things in GAP is the fact that you can have lists that skip particular elements, like [,,3,,,5,,6,]
19:27:01 <Cale> But at least it has a nicely quiet notation for lambdas, just an -> between the variable and body, so it's not too painful to do some functional programming once you've written a handful of things.
19:36:52 * hackagebot esqueleto 2.1.3 - Type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-2.1.3 (FelipeLessa)
19:41:52 * hackagebot fb 1.0.9 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-1.0.9 (FelipeLessa)
19:41:54 * hackagebot skein 1.0.9.3 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-1.0.9.3 (FelipeLessa)
20:23:33 <ryantrinkle> has anyone tried building for iOS lately?
20:23:40 <ryantrinkle> building programs, not GHC
20:26:55 * hackagebot io-streams 1.3.0.0 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.3.0.0 (GregoryCollins)
20:36:53 <TRManderson> how many people here are doing Code Jam?
20:39:57 <carter> ryantrinkle: i sense you'll be doing that which you started
20:40:10 <ryantrinkle> hahaha
20:40:12 <ryantrinkle> could happen :P
20:40:21 <ryantrinkle> https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling/iOS
20:40:28 <ryantrinkle> gotta say, i haven't looked at that project in quite a few years
20:40:34 <ryantrinkle> but it looks like it's going well :)
20:46:56 <johnw> ryantrinkle: good evening :)
20:47:51 <ryantrinkle> johnw: how are you doing? :)
20:49:40 <srid> imagine a world where it is considered normal to write Haskell day and night, and considered geeky to socialize and date.
20:54:57 <johnw> ryantrinkle: doing well, finally got around to my taxes
20:55:07 <ryantrinkle> nice; hope they were favorable :)
20:55:15 <dfeuer> Challenge: get the middle element of a list without using any partial functions or including any unreachable errors.
20:55:23 <johnw> oh yeah, due to a bizarre IT error, I had waaaaaay overpaid them
20:55:30 <ryantrinkle> haha nice
20:55:36 <johnw> well, not so nice
20:55:38 <dfeuer> I haven't come up with a way to do it without fancy type tricks yet.
20:55:44 <johnw> i basically gave the gov't a huge 0% loan for half a year
20:55:51 <johnw> anyway, not #haskell material
20:56:09 <Zemyla> srid: As a Haskell programmer, that sounds like a hellscape. :P
20:56:09 <johnw> dfeuer: you mean, the middle element of any [a]?
20:56:10 <glguy> Dfeuer: write a function to drop every other element
20:56:39 <dfeuer> johnw, yeah, returning Nothing for empty list of course.
20:56:56 * hackagebot gl 0.7.5 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.7.5 (Polarina)
20:57:07 <dfeuer> glguy, what's your scheme there? Do that iteratively?
20:57:15 <johnw> middle [] = Nothing; middle (init -> x:xs) = middle xs <|> Just x
20:57:29 <glguy> Then you can in parallel walk along both the original and that
20:57:49 <glguy> Returning the element in the original when the other runs out
20:57:54 <dfeuer> johnw, init is a partial function.
20:58:00 <johnw> not in this case
20:58:14 <johnw> the case match has ensured the input is valid
20:58:52 <dfeuer> glguy, how do you convince Haskell that the original is at least as long as the shortened? Or do you just stop when you get to the end of either, including an impossible case?
20:59:00 <dfeuer> Not as bad as an impossible error, but still ugly.
20:59:43 <dfeuer> johnw, sure, every function is total on some domain!
21:01:19 * dfeuer suspects a length-indexed GADT-based list is probably the way to go in Haskell, combined with glguy's approach or some similar tortoise/hare.
21:02:03 <Zemyla> Yeah, I was going to say, a tortoise/hare thing.
21:02:28 <glguy> dfeuer: Or you just do: middle xs = listToMaybe (drop (length xs `quot` 2) xs)
21:03:05 <glguy> Involving length-indexed lists would certainly be unnecessary
21:03:48 <dfeuer> glguy, yeah, that looks sensible.
21:04:49 <dfeuer> A tortoise/hare is probably faster though.
21:05:09 <dfeuer> Better cache utilization and faster garbage dropping.
21:06:03 <dfeuer> Although worrying about such in this context seems a bit absurd.
21:08:16 <carter> dfeuer: midpoint xs = if V.length vx == 0 then Nothing else   vxs V.! (div (V.length vxs) 2) where vxs = V.fromList xs  
21:08:42 <dfeuer> carter, that's horrifying.
21:08:49 <carter> but correctl
21:08:53 <carter> ignoring the missing Just
21:09:18 <dfeuer> you even used div because you know how much I hate it.
21:09:37 <carter> quot works too i gues
21:10:25 <arkeet> > let half (x:y:xs) = x:half xs; half _ = []; drop' (_:xs) (_:ys) = drop' xs ys; drop' _ ys = ys in (flip drop' <*> half) [1..20]
21:10:26 <lambdabot>  [11,12,13,14,15,16,17,18,19,20]
21:11:08 <dfeuer> I know there are some things that Knuthian division is supposed to be good for, but I much prefer the "Euclidean" one (remainder guaranteed non-negative).
21:12:22 <dfeuer> arkeet, I bet you could stick zipWith in there if you wanted.
21:12:38 <arkeet> I couldn't immediately see how.
21:12:41 <johnw> middle (x:xs) = case drop (1+ (length xs) `div` 2) (x:xs) of [] -> Nothing; y:_ -> Just y
21:12:50 <johnw> middle [] = Nothing, of course
21:13:06 * dfeuer tries to understand what arkeet is doing with <*> of all things.
21:13:17 <arkeet> (f <*> g) x = f x (g x)
21:13:27 <dfeuer> Oh, it's that one.
21:13:43 * dfeuer is a bit sleepy.
21:13:48 <dfeuer> And distracted.
21:14:36 <johnw> > middle [1..100]
21:14:37 <lambdabot>  Just 51
21:14:40 <arkeet> drop' is like drop except viewing lists as lazy naturals
21:14:55 <arkeet> > let half (x:y:xs) = x:half xs; half _ = []; drop' (_:xs) (_:ys) = drop' xs ys; drop' _ ys = ys in listToMaybe . (flip drop' <*> half) $ [1..20]
21:14:57 <lambdabot>  Just 11
21:15:06 <arkeet> > let half (x:y:xs) = x:half xs; half _ = []; drop' (_:xs) (_:ys) = drop' xs ys; drop' _ ys = ys in listToMaybe . (flip drop' <*> half) $ [1..21]
21:15:08 <lambdabot>  Just 11
21:15:35 <TRManderson> :((((
21:15:37 <vermeille> Is there a haskell ML library able to compete with Torch / Theano / CAFFE / whatever ?
21:15:54 <carter> vermeille: yes
21:16:07 <dfeuer> vermeille, I assume you mean Haskell *or* ML?
21:16:08 <carter> work stuff is finally stable enough that i can put more time into it
21:16:11 <carter> dfeuer: machine learning
21:16:19 <dfeuer> Ahhh...
21:16:21 <carter> vermeille: i've some tech that will shit on those :)
21:16:22 <dfeuer> THAT ML.
21:16:32 <carter> vermeille: been a bit buried with life matters
21:16:35 <vermeille> dfeuer: ML for Machine Learning.
21:16:40 <johnw> carter: any time to research linker issues?
21:16:41 <carter> vermeille: #numerical-haskell is a good channel to ask
21:16:45 <dfeuer> Yes, carter explicated.
21:17:05 <dfeuer> What does numerical stuff have to do with machine learning?
21:17:07 <carter> johnw: i woke up at 540/650am today, and i'm watcing the new dare devel stuff
21:17:10 <carter> dfeuer: everything
21:17:20 <johnw> carter: haha, I have that running in the background right now :)
21:17:34 <dfeuer> carter, eggs-plain?
21:17:41 <carter> dfeuer: no, i've been awake 18 hours
21:17:44 <vermeille> So, guys, if I want to try something now?
21:17:49 <dfeuer> Beyond the fact that everything in a computer is made of numbers....
21:17:58 <carter> vermeille: the ad package is pretty neat
21:18:07 <arkeet> lots of linear algebra in ML
21:18:10 <vermeille> dfeuer: machine learning is just maths
21:18:26 <dfeuer> vermeille, you should go to Brooklyn and offer carter some coffee. But you might want to wait till morning.
21:18:35 <carter> vermeille: join #numerical-haskell and folks can help answer your question
21:18:43 <vermeille> okay :)
21:18:44 <carter> dfeuer: i'm only working in brooklyn
21:18:46 <vermeille> thanks!
21:19:00 <vermeille> Guys I'm in UK, not doable :D
21:19:14 <dfeuer> carter, so you live in Boston?
21:19:20 <carter> no, 
21:19:23 <carter> manhatatan
21:19:33 <carter> vermeille: /join #numerical-haskell
21:19:38 <dfeuer> Ahhhh.... like my brother. But he works there too.
21:19:39 <johnw> manahatatana
21:20:01 <dfeuer> Man-hat-tan -> Tan-man-hat.
21:24:25 <srid> carter: interesting. haskell should be the most fitting language for numerical computing than Python (which is the famous language right now)
21:24:37 <carter> vermeille: yeah, once some stuff matures
21:25:03 <Zemyla> srid: Is there a good matrix library?
21:25:18 * srid knows nothing about numerical computing in haskell
21:25:24 <srid> but python has numpy and scipy
21:27:18 <R0b0t1> Zemyla: I think most are bindings to another language's library, where possible. I looked quite a while ago
21:31:23 <carter> srid: for off the shelf stuff, python is more mature today
21:31:35 <carter> Zemyla: R0b0t1  theres a bunch of blas bindings
21:31:42 <carter> but theres some neat native stuff that should be coming out soon :)
21:31:59 * dfeuer does not actually understand why people like to live in Manhattan. You get a tiny walk-up apartment in a beat-up old building fro the price you'd pay for a real snazzy place anywhere else but Tokyo.
21:32:10 <carter> better commute
21:32:21 <dfeuer> *nod*
21:37:57 <TRManderson> does scanl suffer the same problems as foldl?
21:38:06 <dfeuer> TRManderson, what problems?
21:38:23 <TRManderson> a whole lot of thunks that are only evaluated once the fold is complete
21:38:34 <dfeuer> Depends what you do with it.
21:39:01 <TRManderson> quaternion multiplication
21:39:07 <EvanR> that particular problem also happens with foldr 
21:39:22 <EvanR> sometimes
21:39:57 <dfeuer> If you force the elements of the result list as you pull them, you should be fine.
21:40:24 <dfeuer> Otherwise ... not sure. I haven't looked at that code for a bit, so I don't quite remember details.
21:40:49 <srid> @pl [(head x, length x) | x <- group $ sort h]
21:40:49 <lambdabot> [(head x, length x) | x <- group $ sort h]
21:40:57 <srid> @pl maximum $ map snd freq
21:40:57 <lambdabot> maximum (map snd freq)
21:41:29 <glguy> You can play with lambdabot in /msg
21:41:36 <srid> ok
21:43:09 <TRManderson> would mapping a fold over inits produce better results than a scan?
21:43:18 <TRManderson> because I was replacing the fold/map with the scan
21:44:21 <EvanR> fold that builds a list?
21:44:33 <EvanR> might be more clear as a scan
21:45:04 <TRManderson> more like...
21:45:33 <TRManderson> map (foldl1 (*)) . inits
21:45:41 <TRManderson> but it wasn't over multiplication
21:56:45 <hunteriam> how big a deal is happstack?
21:56:53 <hunteriam> my friends uncle apparently wrote it
21:58:19 <harel_f> very big
21:58:32 <adu> what is happstack?
21:58:40 <johnw> well, it's not used terribly much
21:58:59 <hunteriam> yea its not as big as the one that uses warp
21:59:01 <adu> is that like html and stuff?
21:59:06 <hunteriam> but still i cant get over how cool that is
21:59:18 <adu> or is it like an http server?
21:59:21 <harel_f> http://happstack.com/docs/crashcourse/index.html
21:59:55 <hunteriam> i wish it had a github so i could take vicarious pride in every star and fork it would have
22:00:14 <harel_f> happystack is stable, but yesod is more popula
22:00:26 <adu> it's so hard to standardize server-side stuff
22:00:57 <adu> because someone's going to want some custom hack someday anyways
22:09:02 <R0b0t1> carter: yeah that's what I was remembering, I think
22:09:11 <R0b0t1> wait native stuff?
22:09:14 <R0b0t1> link/keyword?
22:09:40 <EvanR> aol keyword
22:27:18 <Denommus> how do I group every X elements of a list?
22:30:26 <kadoban> Denommus: Data.List.Split.chunksOf  (split package)
22:33:59 <HeladoDeBrownie> let input = [1..100] in map (map snd) (groupBy ((==) `on` fst) (zip (concatMap (replicate 5) [1..]) input))
22:34:02 <HeladoDeBrownie> > let input = [1..100] in map (map snd) (groupBy ((==) `on` fst) (zip (concatMap (replicate 5) [1..]) input))
22:34:04 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]...
22:34:35 <HeladoDeBrownie> that is probably the most complex single exprsesion i've ever written
22:34:40 <HeladoDeBrownie> expression*
22:35:21 <HeladoDeBrownie> okay that's probably an exaggeration :P
22:39:32 <KaneTW> :t unfoldr
22:39:33 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
22:47:27 <KaneTW> > unfoldr (\xs -> case xs of [] -> Nothing; xs' -> Just $ splitAt 5 xs') [1..100]
22:47:28 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]...
23:12:03 * hackagebot packed-dawg 0.2.0.5 - Generation and traversal of highly compressed directed acyclic word graphs.  http://hackage.haskell.org/package/packed-dawg-0.2.0.5 (AndrasKovacs)
23:30:38 <Denommus> I just noticed a complicated recursive function I made for Google Code Jam could be rewritten as a fold with an accumulator
23:48:00 <etqqkoiflwhb> Can anyone explain why this fails https://gist.github.com/anonymous/bf8c93f9d9c470354257 Thanks
23:48:31 <HeladoDeBrownie> etqqkoiflwhb, ghci syntax is a bet different. you need to put "let" in front
23:48:39 <HeladoDeBrownie> let allDirections = [North, East, South, West] -- Cyclic directions list
23:49:06 <etqqkoiflwhb> HeladoDeBrownie: Awesome, thanks
23:49:08 <HeladoDeBrownie> alternatively, throw that code in a file and load it with `ghci YourFile.hs`
23:49:30 <HeladoDeBrownie> s/bet/bit/
23:49:32 <etqqkoiflwhb> HeladoDeBrownie: yea, just trying learning haskell in the repl
23:55:23 <rahulmutt> Has anyone here succeeded in building the lens 4.7 library in the haskellngPackage set in nix? After updating nix I tried to build lens but the SHA verification failed.
