00:00:06 * hackagebot stackage-update 0.1.0.1 - Update your package index incrementally (requires git)  http://hackage.haskell.org/package/stackage-update-0.1.0.1 (MichaelSnoyman)
00:03:25 <davidshore> i think i understand
00:05:07 * hackagebot stackage-update 0.1.0.2 - Update your package index incrementally (requires git)  http://hackage.haskell.org/package/stackage-update-0.1.0.2 (MichaelSnoyman)
00:05:54 <HeladoDeBrownie> feel free to ask for clarification if you need it
00:06:58 <HeladoDeBrownie> in some ways the explanation i gave may have been overly pedantic
00:08:02 <HeladoDeBrownie> although i do think it's useful to be precise even before you fully understand the concept, because that way you can figure out when people are taking verbal shortcuts. e.g., we often talk about bottom being "a value" that inhabits every type but really there's one bottom for each type
00:08:13 * hackagebot stackage-update 0.1.0.1 - Update your package index incrementally (requires git)  http://hackage.haskell.org/package/stackage-update-0.1.0.1 (MichaelSnoyman)
00:08:13 * hackagebot stackage-update 0.1.0.2 - Update your package index incrementally (requires git)  http://hackage.haskell.org/package/stackage-update-0.1.0.2 (MichaelSnoyman)
00:17:01 <davidshore> so the bottom of a type just means a value of that type that isn't really defined?
00:18:01 <HeladoDeBrownie> it's not that it "isn't really defined" so much as it's the bottom value in a lattice of types organized by their "definedness".
00:18:09 <HeladoDeBrownie> s/types/values/, sorry
00:18:22 <arkeet> it's undefined in the sense that it doesn't contain any information.
00:18:55 <arkeet> because it's just an infinite loop or an error or something
00:19:15 <HeladoDeBrownie> example: _|_ (ascii art shorthand for bottom) is less defined than Just _|_ and Nothing, and Just _|_ is less defined than Just 'a'.
00:19:49 <HeladoDeBrownie> does that help?
00:19:54 <kazagistar> isn't Top the one that contains no information and bottom the one that has all information at the same time?
00:19:57 <arkeet> "x is less defined than y" means y contains more information than x, and the information is consistent.
00:20:25 <arkeet> kazagistar: what do you mean by information then?
00:20:47 <HeladoDeBrownie> kazagistar, i'm not sure what "top" means in this context.
00:20:54 <arkeet> there is no top, in general.
00:20:59 <HeladoDeBrownie> in particular i don't think there is a most-defined value.
00:22:10 <arkeet> if someone gives you a _|_ :: Int 
00:22:22 <kazagistar> in isolationistic propositional logic (if I remember at all lol)
00:22:28 <arkeet> you have no idea which Int it could possibly be.
00:22:31 <arkeet> so you have no information.
00:22:53 <arkeet> well
00:23:22 <arkeet> kazagistar: I just mean it in a sort of information theoretic way
00:23:46 <arkeet> someone gives you a computation of type Int.
00:23:55 <arkeet> you run it for a long time
00:24:02 <arkeet> and it doesn't stop
00:24:10 <arkeet> from this observation
00:24:22 <arkeet> you don't know whether it'll never stop, or result in a 1, or result in a 2, or ...
00:24:28 <arkeet> so you have no information about the result
00:24:44 <davidshore> so is it formally defined as _
00:24:57 <HeladoDeBrownie> davidshore, _ is a symbol meaning completely other things in haskell.
00:24:59 <davidshore> * as _|_ = _|_
00:25:01 <davidshore> ?
00:25:03 <HeladoDeBrownie> ah
00:25:10 <kazagistar> if you know (A or B), you know less then (A). Top is like "or-ing everything"... is free, but useless. If you know (A and B), you know more then just (A). Bottom is like "and-ing everything"... you can't prove it true, but if you could, you could prove anything
00:25:30 <HeladoDeBrownie> "_|_" means exactly the same thing as "bottom". it's how you fudge writing the down tick symbol on a standard keyboard.
00:25:39 <arkeet> davidshore: ‚ä• isn't a thing *in* haskell
00:25:48 <arkeet> it's a thing in some denotational semantics for haskell
00:25:58 <arkeet> that represents a computation that never produces a value
00:26:12 <HeladoDeBrownie> i think i misremembered the name of that symbol incidentally. anyone have it handy?
00:26:19 <arkeet> "up tack", apparently
00:26:25 <arkeet> never heard it called that though
00:26:27 <HeladoDeBrownie> ah, yes, that
00:26:29 <kazagistar> (forall a, _|_ -> a) seems to mean it is full of all information
00:26:36 <augur> anyone know about type-level lists?
00:26:55 <HeladoDeBrownie> ‚ä•
00:26:58 <arkeet> kazagistar: I don't know what -> or a is, there.
00:27:37 <arkeet> augur: what about them?
00:27:42 <kazagistar> arkeet: https://proofwiki.org/wiki/Rule_of_Bottom-Elimination
00:27:59 <arkeet> kazagistar: oh, this isn't the same bottom.
00:27:59 <augur> arkeet: how do you use type-class-based membership?
00:28:04 <arkeet> ‚ä• isn't a type.
00:28:20 <augur> arkeet: _|_ is commonly used in type theory to represent what we'd write as Void in Haskell
00:28:25 <arkeet> yeah I get it now.
00:28:32 <arkeet> but we're talking about ‚ä• in denoational semantics.
00:28:44 <arkeet> denotational
00:28:46 <augur> arkeet: even so
00:28:51 <kazagistar> what is the relation then?
00:28:52 <arkeet> where it means something rather different
00:28:54 <HeladoDeBrownie> if you read here: https://en.wikipedia.org/wiki/Up_tack we're discussing the lattice theory one, not the type theory one.
00:28:58 <arkeet> yeah
00:29:06 <davidshore> is Void the same thing as () ?
00:29:09 <arkeet> no
00:29:14 <augur> arkeet: it depends. _|_ could mean the denotation of Void, ie the empty set
00:29:23 <arkeet> davidshore: Void has no (fully-defined) values.
00:29:31 <HeladoDeBrownie> davidshore, Void contains only bottom; () also contains another single value, also called ().
00:29:36 <augur> arkeet: after all, [[Void]] is the bottom of the containment poset!
00:29:39 <arkeet> if Haskell were strict, Void has 0 values, and () has 1 value (namely ())
00:29:44 <davidshore> i see
00:29:48 <augur> Void is the type with no constructors
00:30:19 <davidshore> how is that written in haskell?
00:30:19 <augur> kazagistar: regarding    `forall a. Void -> a`   there are a number of ways to look at this
00:30:31 <HeladoDeBrownie> although there are some definitions of Void that people use that technically have non-bottom values, but no fully defined ones.
00:30:50 <HeladoDeBrownie> Void's entire point, you can say, is to have no fully defined values.
00:31:04 <arkeet> HeladoDeBrownie: such as what?
00:31:09 <augur> kazagistar: one intuition is: since Void has no elements, the only way you can be given an element is if you live in a fantasy world where anything goes, so of course you can have an `a` for any old `a` you want
00:31:16 <HeladoDeBrownie> arkeet, data Void = Void Void
00:31:18 <augur> kazagistar: after all, its fantasy, not reality, so who cares
00:31:22 <arkeet> that's not Void.
00:31:37 <arkeet> that's like saying there are no infinite streams of ()s
00:31:38 <HeladoDeBrownie> arkeet, as i said, it's a definition some people use. mostly because it's haskell 98 valid.
00:31:42 <arkeet> no.
00:31:43 <arkeet> people use 
00:31:45 <arkeet> newtype Void = Void Void
00:31:51 <arkeet> which is rather different
00:31:54 <HeladoDeBrownie> arkeet, you're right, that's what i meant.
00:31:59 <kazagistar> I thought the whole point of defining Void was to have that nice lattice structure
00:32:06 <arkeet> the only way to construct such a thing is fix Void
00:32:08 <arkeet> which is basically fix id
00:32:27 <arkeet> kazagistar: lattices of values.
00:32:34 <arkeet> Haskell types don't form a lattice.
00:32:35 <augur> kazagistar: no, Void is different from _|_ (at least _|_ in the context of termination)
00:32:55 <augur> kazagistar: again, there is unfortunately an ambiguity here, as the symbol _|_ is used to mean a number of different things
00:33:02 <arkeet> and values don't even form a lattice either (there is no join)
00:33:12 <arkeet> just a semilattice
00:33:37 <arkeet> (well, there's some more stuff, but it's not a lattice)
00:33:49 <augur> kazagistar: when you wrote   forall a. _|_ -> a   here the _|_ must mean Void, which is a type with no values. but when people are talking termination and partiality, _|_ is used to indicate a "value" for non-termination/partiality
00:33:49 <HeladoDeBrownie> arkeet, oh, took me a moment. i see how what i said was wrong; that one still only has bottom.
00:34:27 <arkeet> if you wrote data V = V V, that has infinitely many values
00:34:37 <augur> kazagistar: its an ambiguity, like "bank" -- do i mean where i store money, or do i mean the side of a river, or do i mean how i turn a plane? its ambiguous, and you need to grasp the context
00:34:46 <arkeet> namely, ‚ä•, V ‚ä•, V (V ‚ä•), V (V (V ‚ä•)), ...
00:34:50 <arkeet> and V (V (V ...))
00:35:28 <HeladoDeBrownie> that last one is completely defined, even, right?
00:35:33 <arkeet> yes
00:35:50 <arkeet> it is the top value of that type.
00:36:08 <arkeet> being the least upper bound of everyting else.
00:36:59 <mjrosenb> boo, sectioned subtraction doesn't work.
00:37:05 <HeladoDeBrownie> @type subtract
00:37:06 <lambdabot> Num a => a -> a -> a
00:37:07 <kazagistar> ... so why did they reuse the name bottom for something different?
00:37:09 <HeladoDeBrownie> mjrosenb, use that instead ^
00:37:16 <HeladoDeBrownie> (subtract 1) 2
00:37:20 <arkeet> kazagistar: who reused it?
00:37:21 <kazagistar> not that this is the first time mathematicians did that
00:37:22 <augur> kazagistar: for the same reason we have type classes with methods :)
00:37:24 <HeladoDeBrownie> > (subtract 1) 2
00:37:25 <lambdabot>  1
00:37:40 <augur> kazagistar: i mean, look, there are two answers
00:37:58 <arkeet> kazagistar: it's a pretty common term for the lowest element in a poset
00:38:07 <augur> kazagistar: one answer is, two different people were working on two different things and both happened to pick the symbol _|_
00:38:15 <augur> kazagistar: after all, its a nice enough symbol!
00:38:20 <HeladoDeBrownie> i think the type theory one originated from lattice theory, didn't it?
00:38:40 <arkeet> type theory is a fair bit newer than lattice theory I think
00:38:50 <HeladoDeBrownie> though i think it's more useful when there is a subtyping relation, which haskell does not have
00:38:58 <HeladoDeBrownie> (or at best has a trivial one :P)
00:39:08 <kazagistar> ok, thanks for clarifying
00:39:11 <augur> kazagistar: but another reason is that _|_-the-type and _|_-the-non-termination-value happen to both be least-elements in their respective partial orders
00:39:12 <arkeet> well, both of them are sort of instances of the same thing
00:39:15 <arkeet> (the initial object of a category)
00:39:37 <augur> to really bake your noodle: _|_ is also used to represent False and 0
00:39:49 <kazagistar> yeah
00:39:50 <augur> because boolean values form a lattice
00:40:11 <arkeet> isn't that closer to the logic/type theory one
00:40:15 <augur> 0-in-the-binary-sense
00:40:20 <_ryan> hi is there a way to convert a Maybe Text to a Text only?
00:40:25 <kazagistar> I got through JUST enough catsters to have an inkling of what initial and final objects in a category are
00:40:30 <arkeet> _ryan: how do you want it to convert?
00:40:31 <HeladoDeBrownie> _ryan, various ways, what do you want to do if it's Nothing?
00:40:33 <arkeet> what happens to Nothing?
00:40:40 <arkeet> :t fromMaybe
00:40:41 <lambdabot> a -> Maybe a -> a
00:40:45 <augur> arkeet: yes, the termination lattice is actually usually a semi-lattice or not even, its just a partial order
00:40:56 <kazagistar> :t maybe
00:40:57 <augur> arkeet: whereas the type-theoretic one typically is a true lattice
00:40:57 <lambdabot> b -> (a -> b) -> Maybe a -> b
00:41:05 <arkeet> augur: well, any two elements have a lower bound, so sure it's a semilattice.
00:41:40 <augur> also, if you have subtyping, you have _|_ but also a separate type Zero
00:41:53 <augur> where Zero is Void, not _|_
00:42:01 <arkeet> (oh I guess you need there to be a greatest lower bound)
00:42:10 <augur> and conversely you have a type One, but also a type T or Top
00:42:30 <arkeet> okay well
00:42:32 <arkeet> good night guys
00:42:35 <augur> outside of subtyping systems, you find One / Top and Zero / _|_ (aka Bot(tom)) as synonyms
00:42:56 <HeladoDeBrownie> ooh yeah, bedtime sounds like a good idea. it is late
00:43:03 <augur> but when dealing with subtypes, which form a _different_ and _orthogonal_ structure, you find Top and Bot to mean the tops and bottoms of the subtyping lattice, kazagistar
00:43:09 <augur> so there's a further confusion
00:43:51 <augur> kazagistar: this is where some of your notions come from, because its only in the subtyping context that you can say Top is in some sense a "disjunction" of all types
00:43:55 <kazagistar> auger: ah, right, I remember reading about this in the Julia documentation at some point
00:44:17 <kazagistar> (simplified)
00:44:20 <_ryan> arkeet, HeladoDeBrownie - im using the readMaybe function - but the it say that the data is a Maybe Text - i use the unpack of Data.Text - here is the error - Couldn't match expected type Text with actual type ‚ÄòMaybe Text‚Äô
00:44:24 <augur> kazagistar: whereas in the non-subtyping context, Top (aka One) is just the type of 0-ary tuples
00:45:28 <augur> kazagistar: its unfortunate that there is so much ambiguity here. you really have to get used to thinking of _|_ as only a symbol, who's meaning you will discover in context
00:47:33 <kazagistar> auger: eh, I guess thats just kinda how math tends to work most of the time... they aren't very good at declaring their imports either
00:47:46 <augur> kazagistar: yeah :)
00:57:26 <mjrosenb> gah, haskell-mode indents incorrectly
01:09:41 <ggVGc> in a language that doesn't have native currying(i.e needs a curry-function or similar), what are the uses of currying functions outside of partial application?
01:28:09 * hackagebot HaskellForMaths 0.4.7 - Combinatorics, group theory, commutative algebra, non-commutative algebra  http://hackage.haskell.org/package/HaskellForMaths-0.4.7 (DavidAmos)
01:46:22 * hvr wonders what the currrent ration of camel-case vs spinal-case pkg-names on Hackage is
01:46:29 <hvr> s/ration/ratio/
01:46:49 <Rembane> hvr: Well, there is a package list, and a small Haskell program later you should know. :D
01:47:07 <hvr> yeah... I'm just trying to nerd-snipe somebody into doing that =)
01:47:35 <hvr> fwiw, 'cabal list --simple-output' gives you that list
01:47:43 <Rembane> Muaha! :D
01:50:54 <hexagoxel> tsani: cabal is dumb, probably. alter the local package's version number and constrain your dependency on that
02:07:07 <Geraldus> hi friends!
02:08:41 <Geraldus> I have a question about Yesod logs in production. I can't see output of $(logInfo) in production, tried to change logger buffer size to 1, but this does not help. Can anyone suggest something? How can I control logging in production?
02:09:04 <Geraldus> I tried to ask in #Yesod, but nobody answered there
02:47:53 <statusfailed> What's the best option for fixed point arithmetic in Haskell? I see fixed-point and FixedPoint-simple, is there a "base" option?
02:54:48 <slomo> i have a problem here that is quite simple to solve with MVar, but i have no idea how to solve it with STM :) see http://lpaste.net/130940 for some example code and a problem description. short version is that i have an IO action to get an access token that expires at some point, multiple threads use it. when expired, only one should request a new one and the others should be blocked. all this exception-safe and atomic
02:58:10 * hackagebot plot-gtk-ui 0.1.0.0 - A quick way to use Mathematica like Manipulation abilities  http://hackage.haskell.org/package/plot-gtk-ui-0.1.0.0 (sumitsahrawat)
03:03:29 <Geraldus> slomo: maybe you can use a pair (tocken, expires). When read in non‚Äîmain thread use STM `check` to ensure that token is actual, this will cause `retry` until main thread will update token-expire pair
03:04:16 <slomo> Geraldus: there's no main thread, i want the first threading using the token to fetch a new one
03:05:20 <Geraldus> slomo: by main thread I meant that thread which will update token, while others will block
03:08:43 <slomo> Geraldus: but how would it block the others? by getting from the TMVar, then doing the IO action, then putting to the TMVar. and then somehow making all this exception safe, even for async exceptions. but that's all quite tricky to get right it seems :)
03:11:23 <Geraldus> slomo: is it possible to make some special thread to update token?
03:11:50 <Geraldus> and block other threads using `check` or `retry`
03:13:57 <slomo> Geraldus: that other thread would just wait until expiry and then ask for a new token? sure, but that might also mean that tokens are requested although nobody wants to do something with them
03:17:27 <Eliel> is it possible to wait until there's a thread waiting for the value?
03:19:06 <lelf> Any ideas? https://gist.github.com/llelf/8c16a59d402bc049a399
03:19:13 <slomo> Eliel: not atomically i think, i would have to make at least two transactions in the other threads then
03:24:22 <xor-xor> Hi there, I already know that 'T' in names like 'MaybeT', 'ReaderT' refers to monad transformers - but how should I understand names like 'ScottyM', 'ScottyT', 'ActionM', 'ActionT'? (see here: https://hackage.haskell.org/package/scotty-0.9.1/docs/Web-Scotty.html#t:ScottyM) 
03:25:07 <Geraldus> slomo: sorry, I can't clearly understand the problem you are talking about. I believe it's impossible to produce IO action within STM action. So, if I need to update tokens after some time, I will make two STM vars: one for token, and other as semaphore, which indicates that token is expired. Then I'll fork special thread which will update token in some arbitrary time interval.
03:25:26 <xor-xor> I mean, what's the convention behind these 'M' and 'T' postfixes?
03:25:43 <Geraldus> Oh, I think it's possible not to use semaphore at all
03:26:00 <zinfandel> xor-xor: I don't remember for sure, but most likely: ScottyM -- Scotty monad, ScottyT -- Scoty monad transformer, ActionM -- action monad, ActionT -- Action monad transformer
03:26:17 <zinfandel> xor-xor: So, usually: M -- Monad, T -- Transformer
03:26:33 <zinfandel> ^^ s/Transformer/Monad Transformer/
03:28:02 <xor-xor> so it is okay to assume that this 'T' and 'M' thing in names is kind of (strong) convention in Haskell..?
03:28:48 <slomo> Geraldus: thanks, but yes i also think it's not really possible with STM... at least not without making everything much more complicated :) i'm happy with the MVar solution, i'm just playing around with STM a bit and it seems like this would be one of the use cases where there's a disadvantage over other mechanisms
03:29:39 <quchen> xor-xor: T is convention, M is not. There are plenty of monads without an M suffix.
03:30:24 <quchen> (There are also transformers without T, e.g. pipes)
03:31:45 <xor-xor> yes, I know, but when you get 'M'/'T' suffixes, it's safe to assume that we are dealing with monads/transformers here..?
03:32:05 <aarvar> xor-xor: no, names dont mean anything
03:32:50 <xor-xor> allright ;)
03:34:00 <aarvar> technically things like ReaderT aren't even monad transformers, rather (ReaderT e) is a monad transformer
03:42:00 <lelf> If you want to manually upload haddocks, should it include index.html? If not, where does the main page come from?
03:52:19 <lpaste> sagittarian pasted ‚ÄúDFA to match /ing$/‚Äù at http://lpaste.net/130949
03:52:38 <sagittarian|2> so I'm still trying to write a simple DFA typeclass
03:52:50 <sagittarian|2> latest attempt at the paste
03:53:25 <sagittarian|2> I'll check out other solutions later, but right now I want to figure out why I'm getting type errors in the above code, if anyone can give me any idea
03:55:54 <pavonia> sagittarian|2: You class functions use 's' to determine the used instance, but isAccepted doesn't have 's' in it's type
03:56:20 <pavonia> So there's no way to find out what instance is being used
03:58:02 <pavonia> I think in endstate it's something similar, 's' could be different types depending on what 'a' is, so different instances could be used
04:02:38 <dot_Laptop> Hello. Why there's no second case for function lines in prelude? http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-OldList.html#lines
04:03:43 <pavonia> dot_Laptop: Do you mean for that pair?
04:03:59 <dot_Laptop> The first instance of case
04:04:30 <pavonia> (l, s') already matched all possible vlaues
04:04:35 <pavonia> *matches
04:04:46 <dot_Laptop> so why use case at all?
04:04:59 <srhb> To apply the break function and bind names to the result
04:05:12 <srhb> There are other ways to do it, sure.
04:05:50 <srhb> dot_Laptop: But alas, https://ghc.haskell.org/trac/ghc/ticket/4334
04:06:35 <srhb> You probably find that original form more natural.
04:08:11 <dot_Laptop> Thanks.
04:16:14 <dot_Laptop> What is "_|_" called ?
04:16:33 <bernalex> dot_Laptop: do you mean bottom?
04:17:12 <sagittarian|2> thanks pavonia
04:17:16 <dot_Laptop> oh it's called that
04:17:20 <dot_Laptop> thanks again.
04:18:00 <sagittarian|2> so if i have a typeclass with multiple params all functions defined for that typeclass have to use all the type params, otherwise maybe it can't figure out which instance i mean?
04:18:03 <sagittarian|2> seems perverse
04:18:26 <mniip> sagittarian|2, that's when fundeps step in
04:18:36 <pavonia> ^
04:18:49 <sagittarian|2> oh joy, another extension :-)
04:19:02 <sagittarian|2> *this* is why I use haskell
04:19:02 <slack1256> not really, fundep help you infer class constrains, not to use less variables on your class
04:19:03 <bernalex> multiparam typeclasses (& fundeps) is the wrong choice 99.99% of the time though. you might want to just make simpler typeclasses.
04:19:39 <mniip> sagittarian|2, in to time you'll be using TypeOperators, FlexibleInstances, PolyKinds, ConstraintKinds, UndecidableInstances, RankNTypes
04:19:52 <sagittarian|2> mniip: yes, I imagine so
04:19:59 <sagittarian|2> TemplateHaskell too, no doubt
04:20:14 <mniip> where did I put Prolog.Int
04:20:14 <bernalex> UndecidableInstances is *definitely* a red flag that usually indicates YDIW.
04:21:17 <bernalex> sometimes you write something stupid. then GHC tries to help you by suggesting to activate an extension. then down the extension rabbit hole you go. only to resurface three days later and realise that all 15 of them shouldn't be there in the first place, and you should have just used simpler data types. ;)
04:21:53 <sagittarian|2> how nice of ghc, always trying to help
04:23:14 <mniip> bernalex, how would you, otherwise, write http://lpaste.net/1211312748932104192
04:23:15 <mniip> :P
04:23:16 <bernalex> yes. GHC is the Clippy of compilers.
04:24:49 <jesus_couto> I am learning haskell as my first language I got stuck on this: [3,4,3] > [2,3,4]. Why it evaluates to true? Isn't haskell comparing the numbers inside the brackets?
04:25:11 <mniip> jesus_couto, it compares them in lexicographical order
04:25:28 <mniip> the first elements are 3 and 2
04:25:29 <mniip> 3>2
04:27:56 <sagittarian|2> someone should run a contest to write the program that uses the most unnecessary extensions
04:28:13 <sagittarian|2> it could be the haskell equivalent of obfuscated c or perl
04:28:22 <jesus_couto> mniip: so it stops after comparing 4 > 3?
04:28:30 <mniip> jesus_couto, no
04:28:34 <mniip> it stops before that
04:28:38 <bernalex> > [1..] > [2..]
04:28:40 <lambdabot>  False
04:29:05 <srhb> mniip: Eh?
04:29:05 <bernalex> jesus_couto: it stops at the first one
04:29:16 <sagittarian|2> jesus_couto: it compares item by item until it finds a difference, then returns the result of that last comparison
04:29:24 <mniip> sagittarian, well, I have implemented integer arithmetic in the typesystem using mptc and fundeps
04:29:31 <mniip> srhb, hi?
04:29:35 <bernalex> sagittarian|2: it doesn't have to find a difference
04:29:43 <bernalex> > [] > []
04:29:44 <lambdabot>  False
04:29:48 <sagittarian|2> mniip: yes, i've heard of that, scary
04:29:50 <sagittarian|2> jesus_couto: just out of curiosity, how did you decide on haskell for your first language?
04:29:59 <sagittarian|2> right, if it doesn't find a difference then it returns True
04:30:00 <srhb> I'm just confused about the Ord instance now. I'll go read it.
04:30:14 <mniip> I'm yet to finish the Prelude.Prolog package and push it to hackage :v
04:30:14 <nicocbg> > 1 < 2
04:30:16 <lambdabot>  True
04:30:58 <slack1256> sagittarian|2: Haskell is extremely easy as first language, specially if you already had high school algebra
04:31:01 <srhb> Oh, right. I misread them.
04:31:28 <mniip> sagittarian|2, oh right, I even managed to implement bottom in the typesystem!
04:32:48 <sagittarian|2> slack1256: I've heard that, but my question was why jesus_couto specifically came to haskell
04:32:59 <sagittarian|2> even if haskell is easy you have to have heard of it from somewhere
04:33:11 * hackagebot flamingra 0.1.1 - FlameGraphs of profiling  http://hackage.haskell.org/package/flamingra-0.1.1 (AntonNikishaev)
04:33:22 <slack1256> that is easy
04:33:29 <slack1256> the blogosphere loves haskell
04:33:40 <sagittarian|2> the one and only blogosphere, eh?
04:33:44 <bernalex> sagittarian|2: you might be interested to know that there are schools that teach haskell as the first programming language.
04:33:54 <slack1256> really, we have easily one of the better reputations out there
04:34:16 <ion> jesus_couto: Which date is is later, 2013-04-03 or 2012-03-04? Which list is greater, [2013,4,3] or [2012,3,4]?
04:34:56 <mniip> which number is bigger, 343 or 234
04:38:45 <jesus_couto> sagittarian|2: I only know html and css. so I decided to learn a programming language. Made a few basic online tutorilas on javascrip,python,ruby, etc. then I found a post about functional programming saying that functional programming languages teach to think and to write better code.
04:44:00 <jesus_couto> sagittarian|2 : I start searching for functional programming languages and found racket, clojure, haskell, etc. And although I like clojure syntax(?) I found that haskell was something else and after reading that haskell on a "virgin" brain clicks better than a brain from an experienced programmer, I thought to give it a try.
04:44:44 <jesus_couto> sagittarian|2: excuse my poor english. not my native language
04:46:04 <quchen> jesus_couto: Are you following a book to learn Haskell? I don't think random online tutorials work very well in the beginning.
04:46:55 <dot_Laptop> I'm just wondering, if there's anyway for ghc to compute this? http://lpaste.net/130950
04:47:07 <dot_Laptop> funct = sum (zipWith (-) [2,3..] [2,3..])
04:47:17 <MichielDC> Best way to learn Haskell (IMO, I'm currently working through it) is Bitemyapp on Github
04:47:41 <sagittarian|2> jesus_couto: interesting, thanks for the explanation
04:48:11 * hackagebot stylish-haskell 0.5.12.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.12.0 (JasperVanDerJeugt)
04:48:23 <pavonia> dot_Laptop: Not terminating
04:48:59 <dot_Laptop> ok
04:49:03 <jesus_couto> quchen: I am reading "Learn You Haskell for a Greater Good"
04:49:54 <jesus_couto> but I am unsure if it is the right one for a beginner like me
04:50:20 <quchen> It was the right one for me as a beginner at least.
04:51:09 <jesus_couto> MichielDC: found that resource, but video lectures are not my thing. I am more learning by doing (if that makes any sense)
04:51:35 <srhb> jesus_couto: You may be interested in the #haskell-beginners channel and the recommended reading material there, which is very hands on.
04:52:16 <srhb> jesus_couto: CIS 194, in particular: http://www.seas.upenn.edu/~cis194/spring13/lectures.html
04:52:23 <jesus_couto> quchen: but you probably had programming experience. I am starting from zero (aside from those online tuts I made)
04:53:11 * hackagebot stylish-haskell 0.5.13.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.13.0 (JasperVanDerJeugt)
04:55:12 <jesus_couto> srhb: Thank you for the link.
04:55:12 <quchen> jesus_couto: Yes, I had previous programming experience. Unfortunatly, I don't know any book (Haskell or not) that specifically targets people without prior experience, and that are worth reading. 
04:56:32 <aruro> is there a function in Data.List for permutations of length n from the list of length m?
04:57:01 <aruro> elements belong to list length m
04:58:22 <aruro> jesus_couto: whats wrong with LYAH book?
05:01:19 <pavonia> @hackage permutation  -- aruro
05:01:19 <lambdabot> http://hackage.haskell.org/package/permutation  -- aruro
05:02:36 <aruro> pavonia: :(
05:02:48 <aruro> there is no function with type  Num a -> [a] -> [[a]]
05:03:01 <aruro> on hoogle
05:03:09 <aruro> seems its not there
05:03:11 <pavonia> What would that function do?
05:03:21 <aruro> takes length of list
05:03:36 <aruro> then list and generates permutations of that length from that list's elements
05:04:24 <jesus_couto> aruro: So far nothing. I just hope that as the book evolves, the way of teaching reamains the same and doesn't assume that the reader as previous programming experience.
05:04:25 <aruro> 2-[0,1]->[[0,0],[0,1],[1,0],[1,1]]
05:04:53 <aruro> does it assume previous programming experience?
05:04:57 <pavonia> > sequence $ replicate 2 [0,1]
05:04:58 <lambdabot>  [[0,0],[0,1],[1,0],[1,1]]
05:05:04 <pavonia> > sequence $ replicate 3 [0,1]
05:05:05 <lambdabot>  [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
05:05:09 <pavonia> Like that?
05:05:17 <aruro> yes
05:05:18 <aruro> ty
05:05:54 <aruro> you basically used monads for that :)
05:05:54 <gienah> jesus_couto: I think LYAH does assume programming knowledge. The Craft of Functional Programming is a very slow introduction, its about 590 pages, I guess not liked as much by many as its way slower and less advanced than LYAH
05:06:05 <aruro> i was thinking if there is monadless implementation
05:10:42 <sagittarian|2> @src sequence
05:10:43 <lambdabot> sequence []     = return []
05:10:43 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:10:43 <lambdabot> --OR
05:10:43 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
05:12:21 <sagittarian|2> I do keep hearing that haskell is easy for beginners who haven't been spoiled by imperative languages, but is that stuff like the definition of sequence really much easier for beginners than it is for me (for example)?
05:14:01 <zomg> sagittarian|2: I think some concepts may be easier to grasp but I highly doubt a complete beginner would be able to learn the language better than someone with prior experience 
05:15:46 <Hi-Angel> What does mean the @ symbol in ghci output of a variable value? Like this: ´Cursor @ NodeElement (Öª. I know, in a code it helps with pattern matching, but what does do this as a part of a value?
05:18:06 <k_bx> slomo: are you here?
05:23:31 <jesus_couto> sagitarian|2: I am beginning my journey into programming language, but the code you post, I read that it's a sequence where x is passed to v and sequence xs is passed to xs. Am I light years far from it?
05:23:35 <jesus_couto> :)
05:24:31 <aruro> jesus_couto: if you want to understand haskell only thing you need to do is to learn well type system
05:24:48 <aruro> jesus_couto: apart from few function application concepts
05:26:34 <quchen> Hi-Angel: It means that the author of the Show instance thought an @ would be useful there, nothing more.
05:27:27 <jesus_couto> aruro: thanks for the tip :)
05:30:15 <Hi-Angel> HmÖ Thank you quchen 
05:30:37 <aruro> jesus_couto: here is some haskell cheetsheet, it is outdated a bit but usefull -- http://cheatsheet.codeslower.com/CheatSheet.pdf
05:30:45 <aruro> cheat*
05:30:53 <quchen> Hi-Angel: I'm not aware of anything standard that has an "@" in its Show instance, if that helps.
05:31:34 <sagittarian|2> jesus_couto: it's x >>= v <- x; vs <- sequence xs; return (v:vs)
05:31:37 <sagittarian|2> uff
05:32:09 <Hi-Angel> Yeah, it's definitely helps, because I don't yet know the language good to infer such a reasons)
05:32:09 <sagittarian|2> x >>= \v -> sequenc xs >>= \ vs -> return (v:vs)
05:32:34 <sagittarian|2> i still have to think a bit to be able to intuit what those binds mean in the list monad
05:33:47 <jesus_couto> aruro: thanks for that
05:34:52 <jesus_couto> sagittarian|2: It's still very cryptic to me :)
05:35:08 <sagittarian|2> jesus_couto: to me too
05:36:11 <mniip> x >>= (sequence xs >>=) . (return .) . (:)
05:36:39 <sagittarian|2> mniip: might as well use the foldr version
05:36:48 <aruro> there is nothing cryptic just one function applies to other and so on
05:36:57 <aruro> you just dont konw these functions :) no big deal
05:37:15 <aruro> it can easily be + or -
05:37:41 <sagittarian|2> i do know them, i just have to think really hard to put it together
05:37:47 <sagittarian|2> so what is liftM2 (:) in the list monad? (i'm thinking out loud here)
05:38:16 <merijn> sagittarian|2: FYI, it can help a lot to grab some paper, write out the types and specialise them by hand to see what's happening
05:38:17 <sagittarian|2> it takes a list and a list of lists, and conses the list on the list of lists, is that it?
05:38:42 <merijn> :t liftM2
05:38:43 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:38:47 <sagittarian|2> no, couldn't be that simple
05:39:37 <aruro> look at liftM2
05:39:38 <quchen> > liftA2 (:) "HW" ["ello", "orld"]
05:39:39 <aruro> type
05:39:39 <lambdabot>  ["Hello","Horld","Wello","World"]
05:39:41 <merijn> sagittarian|2: ok, so first off, let's specialise that to list and get "(a -> b -> r) -> [a] -> [b] -> [r]" and think what that does
05:39:51 <merijn> Before we look at what "liftM2 (:)" does
05:40:07 <sagittarian|2> is liftA2 the same as liftM2 (just defined for Applicative rather than Monad)?
05:40:20 <merijn> sagittarian|2: For law abiding instances, yes
05:40:26 <aruro> :t liftA2
05:40:27 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
05:40:37 <aruro> u see they are same?
05:40:45 <aruro> :t liftM2
05:40:46 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:40:54 <sagittarian|2> yes, i see the types are the same
05:40:58 <marchelzo_> How should I get GHC 7.10? I'm on OS X and I already have the latest version of Cabal.
05:41:26 <merijn> marchelzo_: Download ghcformacosx or the binary build from the GHC site
05:41:42 <merijn> marchelzo_: https://ghcformacosx.github.io/
05:41:58 <marchelzo_> merijn: There doesn't appear to be an OS X binary on the ghc site. I'll try ghcformacosx
05:42:01 <marchelzo_> thanks
05:42:15 <aruro> types are same with only difference of f a vs m a1
05:42:29 <aruro> and that is type system formula :)
05:42:46 <merijn> marchelzo_: oh, I guess it hasn't been build yet
05:42:52 <aruro> f a = a which belongs to f typeclass -- f is functor
05:43:14 <aruro> m a1 = a which belongs to m typeclass -- m is monad
05:47:46 <aruro> last but not least (:) is a function
05:47:52 <aruro> :t (:)
05:47:53 <lambdabot> a -> [a] -> [a]
05:48:20 <aruro> :i (:)
05:48:28 <aruro> :info (:)
05:48:35 <aruro> @info (:)
05:48:35 <lambdabot> (:)
05:49:20 <aruro> sagittarian|2: type in ghci :i (:) to see where is definition of this function
05:49:25 <whiteline> if i have a cabal sandbox, how do i generate haddock documentation for the dependencies as well as the package itself?
05:49:56 <sagittarian|2> aruro: I'm very well aware of how the cons function works by itself
05:52:17 <sagittarian|2> i guess i don't have a very intuitive grasp of the list monad
05:52:34 <merijn> sagittarian|2: It does the cartesian product of it's arguments
05:52:50 <sagittarian|2> bind takes a list and a function returning a list, it applies each item from the first to the second, collects the results in a list, then calls concat on that
05:52:51 <merijn> > liftM2 (,) [1,2,3] ['a','b','c']
05:52:53 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
05:53:07 <merijn> sagittarian|2: >>= is basically "flip concatMap"
05:53:10 <merijn> :t (>>=)
05:53:11 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:53:16 <merijn> :t flip concatMap
05:53:17 <lambdabot> Foldable t => t a -> (a -> [b]) -> [b]
05:53:56 <sagittarian|2> and concatMap is concat . map ?
05:54:11 <Clint> @src concatMap
05:54:11 <lambdabot> concatMap f = foldr ((++) . f) []
05:54:13 <merijn> sagittarian|2: And "liftM2 f x y = do { x' <- x; y' <- y; return (f x y) }"
05:54:15 <merijn> sagittarian|2: Yes
05:54:16 <sagittarian|2> :t concat . map
05:54:17 <lambdabot> Foldable ((->) [a1]) => (a1 -> a) -> [a]
05:54:29 <merijn> You're missing the function :)
05:54:37 <merijn> :t \f -> concat . map f
05:54:38 <lambdabot> (a1 -> [a]) -> [a1] -> [a]
05:55:02 <merijn> @undo do { x' <- x; y' <- y; return (f x y) }
05:55:02 <lambdabot> x >>= \ x' -> y >>= \ y' -> return (f x y)
05:57:17 <sagittarian|2> okay, so now i have to reremember how to apply the definition of bind to understanding liftM2
05:57:23 <sagittarian|2> @src liftM2
05:57:23 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:57:38 <sagittarian|2> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:57:38 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
05:57:45 <sagittarian|2> oh right
05:57:56 <sagittarian|2> that's what you were just saying
05:58:13 <haskell430> Which would be the best package to use for finding the inverse of a large matrix?
06:01:35 <slack1256> haskell430: I don't know if the best, but a very tested package on this area is hmatrix.
06:01:48 <slack1256> I would go with that and only change if I got problems.
06:02:49 <sagittarian|2> so liftM2 cons takes a list of as, a list of lists of as, and for each item in the first list, it conses it onto each of the lists in the second list, then concats the whole thing
06:02:49 <haskell430> slack1256: cool.. thanks
06:03:34 <MichielDC> :t lift M2
06:03:35 <lambdabot>     Ambiguous occurrence ‚Äòlift‚Äô
06:03:35 <lambdabot>     It could refer to either ‚ÄòControl.Monad.Writer.lift‚Äô,
06:03:35 <lambdabot>                              imported from ‚ÄòControl.Monad.Writer‚Äô at /home/lambda/.lambdabot/State/L.hs:61:1-27
06:03:38 <merijn> sagittarian|2: Right
06:03:41 <MichielDC> :t liftM2
06:03:42 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:04:21 <haskell430> sagittarian|2: It doesn't perform concatenation
06:04:53 <haskell430> sagittarian|2: liftM2 == liftA2
06:05:15 <haskell430> :t liftM2
06:05:16 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:05:37 <haskell430> :t liftM2 (:)
06:05:38 <lambdabot> Monad m => m a -> m [a] -> m [a]
06:05:59 <haskell430> :t liftM2 (:) [1..5]
06:06:01 <lambdabot> (Enum a, Num a) => [[a]] -> [[a]]
06:06:41 <merijn> haskell430: It does, at the end it concats the results
06:06:49 <merijn> Else you'd get a list of lists
06:07:04 <haskell430> merijn: You do get a list of lists
06:07:17 <merijn> In the case of (:), yes
06:07:43 <merijn> > [1..10] >>= \x -> [x+1]
06:07:44 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
06:07:50 <merijn> :t (>>=)
06:07:51 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:08:00 <haskell430> merijn: Yep but liftM2 /= (>>=)
06:08:03 <merijn> It concats all the resulting list of b's
06:08:09 <merijn> haskell430: liftM2 *is* >>=
06:08:13 <merijn> It's twice >>=
06:08:18 <merijn> :t liftM2
06:08:19 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:08:21 <sagittarian|2> (>==) is join . fmap and join is concat for lists so obviously it concats the results
06:08:42 <merijn> :t \f x y -> do { x' <- x; y' <- y; return (f x y) }
06:08:43 <lambdabot> Monad m => (m t -> m t1 -> b) -> m t -> m t1 -> m b
06:08:47 <merijn> eh
06:08:58 <merijn> :t \f x y -> do { x' <- x; y' <- y; return (f x' y') }
06:08:59 <lambdabot> Monad m => (t -> t1 -> b) -> m t -> m t1 -> m b
06:09:08 <merijn> @undo \f x y -> do { x' <- x; y' <- y; return (f x' y') }
06:09:08 <lambdabot> \ f x y -> x >>= \ x' -> y >>= \ y' -> return (f x' y')
06:09:16 <merijn> There you go, liftM2 is just >>=
06:09:24 <MichielDC> liftM2 (:) [1,2] [[1,2,3],[10,20,30]]
06:09:37 <MichielDC> now execute?
06:09:53 <sagittarian|2> add a >
06:09:57 <slack1256> at the beggining
06:10:03 <MichielDC> >[[1,1,2,3],[1,10,20,30],[2,1,2,3],[2,10,20,30]]
06:10:07 <MichielDC> Well
06:10:11 <MichielDC> That's the result :p
06:10:11 <slack1256> > 2 + 2
06:10:12 <lambdabot>  4
06:10:13 <sagittarian|2> and a space
06:10:24 <MichielDC> > [[1,1,2,3],[1,10,20,30],[2,1,2,3],[2,10,20,30]]
06:10:25 <lambdabot>  [[1,1,2,3],[1,10,20,30],[2,1,2,3],[2,10,20,30]]
06:10:26 <MichielDC> Fuck
06:10:27 <MichielDC> my 
06:10:28 <MichielDC> life
06:10:41 <MichielDC> > liftM2 (:) [1,2] [[1,2,3],[10,20,30]]
06:10:43 <lambdabot>  [[1,1,2,3],[1,10,20,30],[2,1,2,3],[2,10,20,30]]
06:10:45 <MichielDC> There we go!
06:11:09 <hexagoxel> whiteline: safest bet was to re-create the sandbox and install everything with enabled documentation flag (in cabal.config or as cmdline flag)
06:11:40 <MichielDC> liftM2 (:) [a,b] [list1, list2] = [a:list1, a:list2, b:list1, b:list2]
06:11:45 <hexagoxel> whiteline: i don't think there was a way to just add the documentation (via --reinstall or smth)
06:12:20 <sagittarian|2> okay, at this moment I understand liftM2 (:), now it's on to sequence as applied to lists
06:16:00 <sagittarian|2> so foldr (liftM2 (:)) (return []) starts with [[]], it then calls liftM2 (:) lastA [[]], where lastA is the last item of the list it was passed, conses it on to the empty list from the initial value, and then passes that result ([lastA]) on to the next to last item
06:18:36 <sagittarian|2> oh it sends [[lastA]] on
06:21:11 <sagittarian|2> :t sequence
06:21:12 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
06:21:41 <sagittarian|2> i have a list of lists, and it gives me a list of lists?
06:21:45 <sagittarian|2> just mixed up
06:23:54 <ggVGc> what would be a good composition operator when . can't be used?
06:23:59 <MichielDC> It has a list of Maybe's and gives a Maybe of lists, you can think of it that way
06:24:42 <sagittarian|2> ggVGc: >>>
06:25:21 <ggVGc> agumonkey: I'd prefer to find a one-character one
06:25:47 <ggVGc> sagittarian|2: this is for a new language, not haskell, I just figured people here might have ideas
06:25:53 <ggVGc> maybe <> would be okay
06:26:05 <ggVGc> three characters is a bit too much
06:27:10 <sagittarian|2> ggVGc: ‚àò
06:27:59 <ggVGc> sagittarian|2: yep, I was thinking that, but then it's not as easily writable, which I am fine with, but still exploring other options
06:28:21 <sagittarian|2> ggVGc: o
06:28:37 <sagittarian|2> i saw some language which did actually use o, iirc, don't remember which though
06:29:31 <ggVGc> sagittarian|2: as in the letter o?
06:29:38 <sagittarian|2> yes
06:29:46 <ggVGc> dunno if I want operators to be valid identifier names :)
06:29:56 <ggVGc> I am playing with backtick now
06:30:16 <ggVGc> foo`bar`baz $ 10
06:37:14 <sagittarian|2> ggVGc: how about use a space for function composition (and then something else, maybe $ or :, for function application)
06:38:50 <exio4> sagittarian|2: SML? 
06:40:52 <sagittarian|2> exio4: regarding using o for function composition?
06:41:05 <exio4> yes
06:41:20 <sagittarian|2> yeah apparently that's it
06:48:37 <ggVGc> sagittarian|2: yeah, I would like to do something like that, but I'm working within the constraints of javascript syntax to a certain degree. This is a superset language over javascript. I have experimented with function application by spaces, but the problem is that foo bar (baz 10) will evaluate to foo(bar(baz(10)) rather than foo(bar, baz(10))
06:49:37 <exio4> ggVGc: if you wanted clean syntax, you should give up on trying to support "syntax compat" with JS, or you may end with C++
06:50:36 <ggVGc> exio4: nah, in a future version I will not support javascript syntax(and I am already breaking it), but I am prototyping this with sweet.js macros, since it's the absolutely fastest way to get things up and running, and I've only had to make a few fairly small syntax tradeoffs so far
06:50:52 <ggVGc> I can't get rid of foo(x) being function application though
06:50:59 <sagittarian|2> ggVGc: sweet.js
06:51:00 <ggVGc> because that happens before macros are expanded
06:52:12 <ggVGc> sagittarian|2: yes?
06:52:13 <exio4> ggVGc: you should learn Racket ;)
06:52:13 <sagittarian|2> yeah, i see you're already there
06:52:22 <ggVGc> exio4: it doesn't fulfill the core demands of why I am making this language
06:52:39 <ggVGc> I think I've looked at pretty much everything that compiles to JS, and decided I needed to do this
06:52:42 <ggVGc> also, it's fun
06:52:55 <exio4> ah, you need to compile to JS
06:53:24 <ggVGc> the real implementation will probably be in haskell at some point, when I've landed on the syntax I want and learnt more haskell
06:54:07 <ggVGc> exio4: yeah, but the main demand is that I want it to compile to JS that looks exactly like it was written by hand, so that the generated javascript can be used later by people who have never seen the original input source(my language)
06:55:22 <ggVGc> so that demands I stay within javascript semantics(so as not to require a runtime dependency) and leverage existing common javascript libraries, like lodash.js
06:55:38 <ggVGc> i.e using existing libraries to be my runtime
06:56:44 <sagittarian|2> ggVGc: you've looked at every item in this list: https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS
06:56:47 <sagittarian|2> ?
06:57:07 <ggVGc> sagittarian|2: pretty much. I spent 2 days installing and testing many alternatives on that list
06:57:25 <ggVGc> wrote 30 or so sample files to see what they generated
06:57:31 <ggVGc> and none of them did what I want really
06:57:42 <ggVGc> i.e the output doesn't look human enough
06:58:05 <ggVGc> some generate good output if you stay within certain subsets of features, but I don't want to accidentally use something that generates some weird code
07:04:19 <learns> hello
07:04:40 <learns> I don't understand this: add :: Number -> Number -> Number
07:04:50 <learns> and then
07:04:50 <learns> add x y = x + y
07:04:59 <lolisa> What part don't you understand?
07:05:06 <learns> how do they work together?
07:05:33 <learns> Number -> Number -> Number
07:05:37 <lolisa> Oh
07:05:38 <oneeman> the first line says what the type of add is, the second one defines its value
07:05:43 <lolisa> This is called currying
07:05:54 <lolisa> so basically, add x return a function
07:06:07 <lolisa> add 1 return a function that always increment a number by one
07:06:09 <ggVGc> lemmih: functions in haskell are curried. That means each function takes exactly one parameter and returns a value. The value might be a new function. So 'add x' returns a new function that takes an y, and when that function is called it returns the value of x+y
07:06:19 <lolisa> add 0 return a id function
07:06:41 <lolisa> and add x y is just (add x) y, haskell just do the bracket for you.
07:07:48 <learns> lolisa: I should look up currying
07:07:57 <oneeman> learns: '->' is right associative, so Number -> Number -> Number is the same as Number -> (Number -> Number)
07:08:08 <lolisa> If you know some other language like C++, you can try implement this by hand :) Just write an accumlator and you'll understand
07:08:14 <lolisa> Wiki is also good.
07:09:05 <learns> x + y = (Number -> Number)?
07:09:36 <ggVGc> lemmih: Number->Number means a function that takes a number and returns a number
07:09:41 <lolisa> x + y is Number
07:10:04 <lolisa> x + y is just shorthand for (+) x y
07:10:16 <lolisa> (+) x is Number -> Number
07:10:32 <MichielDC> I'm doing CIS194, currently at Homework 3 and I can't seem to solve the skips function. Any help?
07:10:44 <ggVGc> lemmih: but yes, read up on currying and you will understand this. It's not very strange at all, but different from most other non-functional languages
07:10:45 <learns> oh, god. I'll go to wiki now :(
07:11:22 <ggVGc> lemmih: the core concept you need to ut in your hand is that in haskell(and other languages with curried functions), no function EVER takes more than one argument
07:11:32 <ggVGc> eh, put in your head*
07:11:36 <lolisa> If you know some logic, just imagine (A->B) is a logic statement, A is premise and B is conclusion. And currying is just specialization of a statement
07:11:55 <lolisa> (A->B->C) A = B->C :)
07:13:08 <oneeman> MichielDC: I can help, I did that assignment pretty recently.  Have you made any progress on it already?
07:13:27 <lolisa> BTW if you are sick of curry, you can just write plus : Number*Number -> Number :)
07:13:47 <MichielDC> oneeman, I build some stuff with accumulators which turned out really ugly
07:14:04 <oneeman> michielDC: I'll send you a private message and we can go into more detail
07:14:12 <MichielDC> How do PMs work? :p
07:14:29 <exio4> oneeman: I'd continue it here, or in #haskell-overflow 
07:14:43 <exio4> or #haskell-beginners, or whatever
07:15:55 <oneeman> exio4: ah, cool, didn't know that was the custom
07:17:30 <lolisa> BTW do anyone know any special number a bit larger than 272? how about one that is a bit larger than 1111?
07:17:47 <ion> 1112
07:17:57 <MichielDC> What properties does  it need to be special?
07:18:09 <lolisa> Nah, just special in anysense...
07:18:14 <ion> MichielDC: ‚ÄúOne greater than another special number‚Äù
07:18:40 <isomorphic> @src mapM
07:18:41 <lambdabot> mapM f as = sequence (map f as)
07:18:50 <lolisa> 10000 is special, 1024 is special, 1729 is cube 10 + cube 9 and cube 12 + cube 1
07:19:02 <lolisa> So, just anything interesting :)
07:20:01 <ggVGc> lolisa: this is my favourite number, http://en.wikipedia.org/wiki/1729_%28number%29
07:20:07 <ggVGc> oh
07:20:13 <ggVGc> lolisa: I missed you wrote it :(
07:20:41 <lolisa> Yeah, but it will be another 600 github commit... So I am looking for something closer :)
07:21:10 <lolisa> I use "let's make my github annual commit and github streak special number" as a motivation :)
07:21:42 <ggVGc> lolisa: maybe you should use this motivation as a carrot to get more into number theory
07:21:54 <lolisa> True lol :)
07:22:25 <oneeman> By contradiction: suppose there are non-special natural numbers.  Then there must be a smallest non-special natural number.  But that in itself makes it special. QED
07:23:08 <lolisa> Yeah, but I need a proof why somenumber is special or there's no motivation behind :) I need a constructive proof
07:24:44 <ggVGc> start making some proofs then!
07:25:06 <ggVGc> lolisa: do the numbers have to be mathematically special, or can they be subjectively special for you based on your personal context?
07:25:34 <ggVGc> lolisa: what number is the age of all your closest friends added?
07:25:59 <lolisa> 18... 404 stuff also work on me, my taste on special is board :)
07:53:37 <hexagoxel> with amp+bbp, is there any convention/suggestion on which of the duplicate methods to use? (`pure` vs `return`, `traverse` vs `mapM`, ..) ?
07:54:40 <hexagoxel> i imagine that in the spirit of making stuff more generic, one should prefer the more generic versions.
07:57:45 <kuribas> I am the only one who thinks "if then else" shouldn't be syntax?
07:58:08 <statusfailed> kuribas: no :)
07:58:09 <hexagoxel> you are free to use `bool` only :)
07:58:21 <kuribas> :t bool
07:58:22 <lambdabot> a -> a -> Bool -> a
07:58:43 <statusfailed> Church encoded bools are better :D
07:59:11 <kuribas> :i bool
07:59:23 <kuribas> @hoogle bool
07:59:25 <lambdabot> package bool-extras
07:59:25 <lambdabot> package boolean-list
07:59:25 <lambdabot> package boolean-normal-forms
07:59:38 <hexagoxel> it is base:Data.Bool iirc
08:00:45 <hexagoxel> > bool "else" "then" True
08:00:48 <lambdabot>  "then"
08:01:06 <kuribas> wouldn't "Bool -> a -> a" be more convenient?
08:02:20 <kuribas> @hoogle if'
08:02:24 <lambdabot> No results found
08:03:43 <geekosaur> the ordering for bool encourages partial application of the Bool
08:04:12 <geekosaur> bool falseCase trueCase . soemthingProducingABool
08:07:05 <ski> learns : currying is a convention
08:08:14 * hackagebot HaskellForMaths 0.4.8 - Combinatorics, group theory, commutative algebra, non-commutative algebra  http://hackage.haskell.org/package/HaskellForMaths-0.4.8 (DavidAmos)
08:08:59 <c_wraith> bool takes its arguments in exactly the opposite order of if'
08:08:59 <haskellBeginner> in ghci, when I type somthing like :t [1,2] or :t 7, it returns me something that I don't understand, respectively Num a => a and Num t => [t]
08:09:17 <c_wraith> haskellBeginner: numeric literals in haskell are polymorphic
08:09:18 <haskellBeginner> why isn't it something like 7 :: Int or [1,2] :: [Int] ??
08:09:35 <c_wraith> haskellBeginner: 7 doesn't have one single type.  It can be any type that allows it.
08:09:38 <lolisa> 7 can be Int or Something else
08:09:55 <ski> because numerals like `1',`2',`7' are overloaded. they can be of type `Int',`Integer',`Double',`Rational',`Complex Double', &c.
08:10:26 <haskellBeginner> ok, and why does it denotes something like that as Num a => a ?
08:10:32 <kuribas> haskellBeginner: 7 is a shorthand for (fromInteger 7)
08:10:32 <c_wraith> :t 7
08:10:33 <lambdabot> Num a => a
08:10:39 <kuribas> :t fromInteger
08:10:40 <lambdabot> Num a => Integer -> a
08:10:57 <kuribas> :t 7.4
08:10:58 <lambdabot> Fractional a => a
08:10:58 <ski> when you get `Num a => a' for `:t 7', that means that `7' can have any type `a' (`a' is a type variable), *provided* that `Num a' holds, iow that `a' is a numeric type
08:11:00 <Myrl-chan> haskellBeginner: Perhaps you're confusing this with other languages such as C and Python where you need an explicit `.0` to make something a float?
08:11:27 <haskellBeginner> no I got the part about polymorphism
08:11:44 <ski> do you get the `Num a => ' part ?
08:11:45 <Myrl-chan> Rather, you got the idea from, not confusing this with.
08:11:46 <haskellBeginner> but the Num a => a way of saying it is still obscure
08:11:46 <c_wraith> Myrl-chan: it's not just about integral/floating types.  Things like matrices can be instances of Num, and therefore be expanded from literals
08:11:50 <kuribas> haskellBeginner: 7.4 is shortHand for (fromRational 7.4)
08:12:26 <c_wraith> haskellBeginner: the => symbol in a type indicates that the types aren't *fully* polymorphic - they're constrained.  The part to the left of the => is the list of constraints
08:12:41 <haskellBeginner> OK!
08:12:47 <ski> @type sort
08:12:48 <lambdabot> Ord a => [a] -> [a]
08:12:59 <c_wraith> haskellBeginner: a constraint like (Num a) means that the type a must obey the Num constraint.
08:13:00 <haskellBeginner> and so in this case, my expression is of one of the types in Num ?
08:13:05 <haskellBeginner> ok
08:13:07 <haskellBeginner> got it
08:13:10 <haskellBeginner> thank you guys
08:13:24 <ski> haskellBeginner : that says that `sort' can have type `[a] -> [a]', for any type `a' that you like, *provided* that the type `a' supports ordering (iow `Ord a' holds)
08:13:34 <c_wraith> haskellBeginner: there are lots of other handy constraints.  Ord and Eq are important things you run into early.
08:14:08 <haskellBeginner> okey I will look into that!
08:14:41 <mpickering> w
08:14:51 <ski> v
08:15:53 <exio4> polymorphic literals are really nice 
08:16:43 <sagittarian|2> could list literals be extended to work polymorphically with anything that has a fromList function?
08:17:07 <kuribas> sagittarian: there is an extension for polymorphic lists.
08:17:32 <sagittarian|2> cool, i have something to look forward to on the other side of the extension forest
08:17:57 <Myrl-chan> I'm quite curious, is it possible to have a data constructor in multiple type constructors?
08:18:02 <ski> kuribas : "polymorphic" ?
08:18:20 <kuribas> ski: sorry, I meant overloaded lists.
08:18:23 <mhitza> what templating package can I use in haskell which supports features like "extends" and "block" (like in jinja2, twig, etc)?
08:18:36 <kuribas> sagittarian|2: https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists
08:18:45 <ski> Myrl-chan : no. however it's possible to have two data constructors, having the same name, belonging to different types
08:19:05 <exio4> sagittarian|2: OverloadedLists does that, pretty much
08:19:31 <ggVGc> does anyone here use haskell or other functional programming in your day job?
08:20:31 <sagittarian|2> a recruiter once contacted me saying that she wants to help me find my dream job
08:20:38 <kuribas> It would be nice if overloadedLists worked with Map, Set, Hashmap, HashSet, etc...
08:20:48 <phaazon> hey what do you think of System.Console.GetOpt?
08:20:51 <sagittarian|2> i told her my dream job is working with haskell, and she said they had positions which use haskell
08:21:01 <sagittarian|2> i was too lazy and/or insecure to actually pursue it though
08:21:02 <liuhui> Hi, can someone explain what I am doing wrong in the following code: http://pastebin.com/4rLJgX5q?
08:21:03 <phaazon> because of it being in base, I guess it‚Äôs a good lib
08:21:14 <ggVGc> sagittarian|2: should have jumped on that
08:21:29 <kuribas> They are hiring haskell programmers here in Belgium now.
08:21:42 <exio4> kuribas: I thought it worked for those? 
08:21:56 <ggVGc> kuribas: what kind of work?
08:22:39 <kuribas> Something to do with storage, I don't know the details.
08:22:44 <kuribas> http://amplidata.com/
08:23:12 <Big_G> Has anyone here used HLearn?
08:23:50 <ski> liuhui : perhaps you meant `let test = ...' instead of `test <- ...' ?
08:24:10 <kuribas> exio4: oh it does?  That would be great!
08:24:49 <ski> liuhui : iow, `(tail .lines) file' is not an I/O-action
08:25:17 <liuhui> oh I see thanks @ski
08:25:49 <liuhui> I intend to use it with a let
08:26:03 * ski would prefer not getting adorned with an `@'
08:26:04 <liuhui> I'm still new @ Haskell!
08:26:18 <liuhui> :)
08:26:45 <ski> liuhui : note that `readFile' uses "lazy I/O", so nothing will actually be read from the file, untill you actually look at `file' or `test'
08:28:26 <liuhui> ski: yes, thanks for the advice :)
08:28:33 <ski> liuhui : in `do'-notation, when using the `x <- foo' syntax, `foo' should have a type like `M T' (where `M' in your case is `IO', and `T', for `file <- readFile (head args)' e.g., is `String'). then `x' will get type `T'
08:29:39 <liuhui> ski: so if I simply want to create a temporary variable, I should use a let right?
08:29:50 <ski> liuhui : also note that you could say `[filename] <- getArgs', then you'd check at this point that there's only one argument (not including the program name), and directly binding that argument to `filename' (iow pattern-matching works to the left of `<-')
08:30:32 <ski> liuhui : if you want to name (the value of) an expression, use `let'. if you want to run (aka execute) an action, and name the result, use `<-'
08:31:29 <liuhui> thanks for the elaborate explanation ski :D!
08:31:29 <ski> liuhui : `(tail .lines) file' is an expression, of type `[String]'. your `let test = (tail .lines) file' names the (value of the) expression
08:31:37 <ski> (so `file' will also have the type `[String]')
08:31:38 <ggVGc> kuribas: hm, don't see anything about haskell in their job listings, but might be they are interested in haskell developers anyway
08:32:27 <kuribas> ggVGc: They will be recruiting in the Leuven Haskell User Group, tuesday :)
08:32:41 <ski> liuhui : otoh, in `args <- getArgs', the type of `getArgs' is `IO [String]', while the type of `args' will be `[String]' (no `IO') .. note how the type is different, because we're not naming the *action* itself, we're naming the result of *executing* the action
08:33:40 <ski> liuhui : i hope that is clear
08:33:54 <liuhui> ski: it is very clear, all the fog is gone
08:34:01 <ski> fine
08:34:08 <liuhui> ski: thank you for everything!
08:34:11 <kuribas> ggVGc: I can give you more information after Tuesday :)  I'll probably pass though...
08:43:46 <ggVGc> kuribas: cool. I am very much new to haskell, but been into functional programming for a few years, and I'm curious what the work landscape looks like. I'm getting a bit fed up not learning anything in the daily work I do
08:43:59 <ggVGc> would be nice working somewhere where I'd also be learning and developoing
08:45:58 <liuhui> :r
08:46:13 <ski> :q
08:46:27 <Rotaerk> :q!
08:46:53 <kuribas> ggVGc: My interest in haskell is merely personal, for my own projects.  If I were to do a programming job, I'd prefer haskell.
08:48:05 <kuribas> ggVGc: If I may ask, what is your daily job?
08:50:29 <liuhui> ski: haha, typed in the wrong window
08:52:18 <ggVGc> kuribas: freelance work since about 2.5 years. Whatever comes up really. Currently it's converting educational flash animations to javascript/canvas, in the past it's mostly been mobile development and web apps(because that's what everyone wants now and is easily made into contract work). I also released this game myself last year, www.berrybounce.com
08:52:45 <ggVGc> the game obviously has not made any money, but that wasn't the point
08:53:39 <kuribas> ggVGc: looks pretty funny :)
08:53:47 <lpaste> yasar11732 pasted ‚Äúbinary tree‚Äù at http://lpaste.net/130954
08:54:27 <yasar11732> I am getting "Couldnt match type a with b" in http://lpaste.net/130954
08:54:28 <ggVGc> kuribas: unfortunately the game is not so fun to play :( But it was more to release something myself that wasn't just contract work for someone else
08:54:46 <yasar11732> what might be the problem?
08:54:51 <ggVGc> kuribas: anyway, I see quite a lot of Ocaml job listings, but don't think I've ever seen a haskell one
08:55:21 <lolisa> As a Coq Programmer, I say Haskeller are lucky enough :)
08:56:04 <ggVGc> lolisa: isn't Coq mostly useful for academic work? Like proving theories etc.
08:56:09 <ggVGc> developing algorithms
08:56:21 <lolisa> Yes, but you can also write software in Coq
08:56:28 <ion> yasar11732: Say, you run fmap show Node 0 (Node 1 EmptyTree) (Node 2 EmptyTree). What would you expect as the result?
08:56:35 <lolisa> And prove the software you write in Coq is free from bug
08:56:41 <ggVGc> lolisa: yeah, but is it a good fit?
08:57:05 <lolisa> It fit when safety is the most important thing :)
08:57:17 <ggVGc> lolisa: right, which is almost no commercial software
08:57:40 <lolisa> Yeah... Too unfortunate for a Coq programmer...
08:57:54 <yasar11732> @ion Node "0" (Node 1 EmptyTree) (Node 2 EmptryTree) I guess
08:57:54 <lambdabot> Maybe you meant: yow wn run nixon join id do
08:58:30 <ion> yasar11732: How about fmap show [0,1,2]?
08:58:53 <yasar11732> ion: ["0","1","2"] ?
08:59:07 <ggVGc> lolisa: I mean, I'm not saying correctness is not important. But it usually comes with development costs, and for most software those development costs come in the way of rapid prototyping, fast turnaround for fixes etc.
08:59:21 <lolisa> Yeah, I know as a programmer
08:59:25 <yasar11732> ion: Ohh, I get it :)
08:59:37 <yasar11732> ion: I should also map the subtrees :)
08:59:46 <lolisa> I am just wishing it is more important :( if so I'd be in great demand
08:59:47 <ion> yasar11732: Bingo
09:00:08 <lolisa> At least I am a decent C++ programmer... Enough to make my living.
09:00:13 <ggVGc> lolisa: well, algorithm development and academic work is also valuable and necessary
09:01:01 <ThreeOfEight> Automatic Theorem Provers are in heavy use in hardware design, I hear.
09:01:29 <ThreeOfEight> And I think HP once verified their printer drivers with HOL 4 or something.
09:01:48 <lolisa> I also do ATP... 
09:01:50 <ggVGc> ThreeOfEight: and yet HP drivers are and have always been terrible..
09:02:03 <ggVGc> but maybe that is windows' fauly
09:02:04 <ggVGc> fault
09:02:25 <lolisa> But I think industrial use of ATP is limited to First Order Logic and Boolean SAT problem...
09:02:32 <ThreeOfEight> Printing on Windows is completely horrible in my experience.
09:02:38 <ThreeOfEight> Just like HDMI audio on Windows.
09:02:53 <ggVGc> lolisa: CNC machines?
09:02:58 <ThreeOfEight> I also don't understand why, to get a laptop up and running on Windows, I have to download 1.5 GB of drivers.
09:02:58 <ggVGc> wikipedia says so..
09:03:07 <ggVGc> <-- knows nothing of ATP
09:03:09 <lolisa> While I am hoping to do ATP on more abstract type system...
09:03:18 <ThreeOfEight> whereas I can get a fully working Linux from a 700 MB Live stick.
09:03:20 <lolisa> I dont know what a CNC machine is...
09:03:28 * lolisa go check
09:03:47 <ThreeOfEight> lolisa: basically an inverse 3D printer
09:04:05 <ggVGc> lolisa: the machines that cut up everything you use daily
09:04:06 <ThreeOfEight> instead of building something out of nothing, it builds something by taking a block and cutting away.
09:04:08 <lolisa> I dont get how it is related to ATP...
09:04:23 <ggVGc> lolisa: wikipedia says this, http://en.wikipedia.org/wiki/APT_%28programming_language%29
09:04:44 <ThreeOfEight> ATP, not APT
09:04:47 <ThreeOfEight> ATP = Automated Theorem Proving
09:04:56 <ggVGc> ohhhhh
09:05:03 <lolisa> .....
09:05:05 <ThreeOfEight> i.e. you give your problem to the ATP and it solves it for you, giving you a proof
09:05:12 <lolisa> Exactly.
09:05:12 <ggVGc> aha
09:05:13 <ThreeOfEight> ITP = Interactive Theorem Proving
09:05:19 <ThreeOfEight> i.e. you guide the computer through the proof
09:05:25 <lolisa> Yeah, but Coq can also do ATP by tactic
09:05:27 <ThreeOfEight> I'm more of an ITP person.
09:05:37 <ThreeOfEight> well, yes, ITPs usually employ ATPs for every single step.
09:05:57 <lolisa> I think both doesn't contradict. When ATP is possible we'll use ATP, and we impossible we'd go by hands :)
09:06:04 <ThreeOfEight> most major ITPs have some degree of automation to make them more usable.
09:06:32 <ThreeOfEight> well but there is a big conceptual difference between something like Coq/Isabelle/HOL Light and something like Z3/SPASS/E
09:06:51 <lolisa> How about Agda and Idris? From what I known of, the first doesnt have tactic and the second have very limited tactic...
09:07:11 <lolisa> So you know something about Z3? Can you elaborate? I only know Coq style stuff...
09:07:13 <ThreeOfEight> ATPs are usually for small problems that appear as side conditions and that can be proven automatically
09:07:20 <exio4> Idris tries to be more of a programming language than a theorem prover
09:07:36 <ThreeOfEight> like verification conditions arising from annotated programs
09:07:44 <lpaste> yasar11732 revised ‚Äúbinary tree‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/130954
09:07:51 <kuribas> ggVGc: I am playing your game :)  It pretty funny.  But it's hard to compete against the likes of Kingdom Rush which sell for almost nothing.
09:07:59 <ThreeOfEight> ITPs are more for big stuff like mathematical theorems, or developing an algorithm fully in the ITP and verifying it there.
09:08:14 <ThreeOfEight> lolisa: I don't really know anything about Z3; I use some tools that use it.
09:08:32 <ThreeOfEight> but I think Z3 is more of a backend tool
09:08:36 <lolisa> OK, I will go do some search myself than, thx...
09:08:46 <lolisa> Than what's the front end?
09:08:56 <ThreeOfEight> well Isabelle's sledgehammer can use Z3, for instance
09:09:02 <ThreeOfEight> Liquid Haskell uses Z3
09:09:18 <ThreeOfEight> And a whole bunch of industrial tools, I would imagine. Probably lots of stuff by Microsoft Research.
09:09:19 <yasar11732> Does treeSortedList look normal here: http://lpaste.net/130954
09:09:49 <ThreeOfEight> But as I said, I'm hardly an expert on Z3. Perhaps there is a way to interface with it directly as well.
09:09:55 <kuribas> yasar11732: your fmap doesn't recurse...
09:10:14 <lolisa> I just want an basic introduction to it so I know what it is...
09:10:27 <ThreeOfEight> better read the Wikipedia article than ask me. ^^
09:10:31 <yasar11732> kuribas: sorry, forgot to change that while editing, a second please
09:10:33 <ggVGc> kuribas: thanks :) well, I have a few ideas that would make it much more interesting to play, but I don't have the time or willpower to implement those. I'd rather make one of the other 10 games I've written down ideas for
09:10:35 <ThreeOfEight> I just know that it's a really powerful SMT solver.
09:10:54 <lpaste> yasar11732 revised ‚Äúbinary tree‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/130954
09:11:09 <ThreeOfEight> I think Idris is really not made for theorem proving. It has tactics, but, as far as I know, no automation.
09:11:17 <yasar11732> kuribas: see this edit: http://lpaste.net/130954
09:11:40 <ThreeOfEight> It's a programming language and its tactics are just there to help the type checker.
09:11:44 <exio4> yasar11732: your fmap is wrong, singleton has an useless constraint, treeSortedList sounds like something that wouldn't mind a difference list
09:11:54 <lolisa> Yeah, I had learn idris for a day, and than gone mad at edwin brad, the leading developer
09:12:08 <ThreeOfEight> Due to Curry-Howard, you can of course prove theorems in it, but that's not what it is designed for.
09:12:24 <lolisa> because he said "tactic is for machine, go write your proof yourself". 
09:12:47 <ThreeOfEight> I don't really know much about Agda, but I don't think it's made for proving mathematical statements.
09:12:54 <yasar11732> exio4: fmap should be fixed in this edit: http://lpaste.net/130954
09:13:04 <ThreeOfEight> More like algorithms with the invariants encoded in the type level, and from what I've heard, that can also become very tedious.
09:13:16 <ThreeOfEight> But that's just my impression, I don't have any first-hand experience.
09:13:16 <lolisa> I dont get a reason why, if tool can prove for me, do I need to do it by hand= =So I quit immediately
09:13:29 <kuribas> yasar11732: looks fine.
09:13:37 <ThreeOfEight> well it can be a good idea to learn how to prove things by hand in a theorem prover
09:13:44 <ThreeOfEight> so that you get a better understanding of the system
09:13:55 <lolisa> Yeah, for educational purpose.
09:14:17 <yasar11732> exio4: things should be Orderable in order for them to be put into trees, why do you think it is useless?
09:14:25 <ThreeOfEight> ah, it wasn't HP printer drivers
09:14:30 <ThreeOfEight> it was buses in their servers
09:14:45 <lolisa> But when I do auto, I can do debug auto to see what it does, but the power of deciding whether I need to do it by hands to learn lies in me, not in him.
09:17:07 <exio4> yasar11732: because it isn't needed for that specific function
09:18:10 <lolisa>  the satisfiability modulo theories (SMT) problem is a decision problem for logical formulas with respect to combinations of background theories expressed in classical first-order logic with equality So basically Z3 is an ATP in First Order Logic? Or ITP?
09:19:04 <ThreeOfEight> Z3 is an ATP.
09:19:20 <ThreeOfEight> And you can translate HOL to something Z3 can work with.
09:19:26 <ThreeOfEight> (HOL = Higher-order Logic)
09:19:34 <ThreeOfEight> that's what Sledgehammer does, for instance.
09:20:11 <ThreeOfEight> I think SMT goes a bit beyond "just" First Order. That's where the "Background theories" part comes in.
09:20:20 <lolisa> Yeah, But I suspect not all of it.
09:20:41 <lolisa> Background theory to me just sound like blackbox of axiom...
09:21:09 <lolisa> Like, I am interest in How do I stuck a general second order logic problem into Z3
09:23:32 <Guest50465> @undo do {t<-takeText; fail ("Unable to parse: " ++ unpack t)}
09:23:32 <lambdabot> takeText >>= \ t -> fail ("Unable to parse: " ++ unpack t)
09:35:34 <yasar11732> I am following http://learnyouahaskell.com/functionally-solving-problems and modified the solveRPN function like this: http://lpaste.net/130958 but I am getting http://lpaste.net/130959 . I am pretty new to haskell and I don't understand what is going on
09:36:52 <Rotaerk> :t (/)
09:36:53 <lambdabot> Fractional a => a -> a -> a
09:37:00 <Rotaerk> that
09:37:16 <ThreeOfEight> yasar11732: you demand, in your type signature, that a be of the typeclasses Num and Read
09:37:17 <merijn> yasar11732: You wrote a type signature that claims to work for any instance of Num, but you use /
09:37:28 <merijn> yasar11732: And / only works for instances of Fractional
09:37:31 <ThreeOfEight> but division requires additional type class constraints, namely Fractional.
09:37:48 <ThreeOfEight> for instance, Integers are in Num and in Read, but not in Fractional
09:37:55 <merijn> Alternatively, you could make it work with only Integrals and use 'div' for integer division
09:38:02 <merijn> > 2/3 :: Int -- error
09:38:04 <lambdabot>      No instance for (Fractional Int) arising from a use of ‚Äò/‚Äô
09:38:04 <lambdabot>      In the expression: 2 / 3 :: Int
09:38:08 <merijn> > 2/3 :: Double -- error
09:38:10 <lambdabot>  0.6666666666666666
09:38:11 <merijn> eh
09:38:19 <merijn> minus error on the second one, obviously :p
09:38:22 <yasar11732> what is the different between `div` and "/"
09:38:38 <merijn> > 2 `div` 3
09:38:39 <bob_twinkles> :t div
09:38:39 <ThreeOfEight> div is integral division
09:38:40 <lambdabot>  0
09:38:40 <lambdabot> Integral a => a -> a -> a
09:38:43 <bob_twinkles> :t (/)
09:38:44 <lambdabot> Fractional a => a -> a -> a
09:38:48 <merijn> > 10 `div` 3
09:38:50 <lambdabot>  3
09:38:54 <merijn> > 10 / 3
09:38:55 <lambdabot>  3.3333333333333335
09:39:10 <yasar11732> So, you can use this channel as ghci I guess?
09:39:10 <ion> > ((-10) `quot` 3, (-10) `div` 3)
09:39:12 <lambdabot>  (-3,-4)
09:39:22 <merijn> yasar11732: So / is "proper" division and div is integer division
09:39:26 <ThreeOfEight> the specification of div and mod is: a = a `div` b * b + a `mod` b
09:39:37 <ThreeOfEight> and a `mod` b < b
09:39:46 <yasar11732> Anyway, I need to change Num to Fractional to fix it, right?
09:39:57 <ThreeOfEight> At least for positive a and b. I can never remember what it is for negative ones.
09:40:08 <ThreeOfEight> that is one way to fix it, yes.
09:40:09 <ion> yasar11732: You can comment out the type signature and see what GHC thinks its type is in the warning.
09:40:28 <ion> yasar11732: Or replace the type signature with _ given a recent enough GHC.
09:40:51 <ion> The type in the type signature, that is
09:41:21 <merijn> yasar11732: Right
09:41:50 <merijn> yasar11732: But if you replace it by fractional then it won't work for Int anymore, for example
09:42:03 <yasar11732> http://learnyouahaskell.com/ always uses strict type signatures, so I figured I should do it like that too
09:42:21 <nshepperd> lolisa: would it be possible to write proof tactics in the language (Idris)? like a polymorphic proof term 'trivial : (Trivial a) => a' to use instead of writing the proofs oneself?
09:42:34 <merijn> yasar11732: You should, because it saves us from having to guess the type ;)
09:42:46 <lolisa> Yeah, you get a tiny bit of automation
09:42:51 <nshepperd> lolisa: or does automation inevitably require built in language support
09:42:58 <lolisa> Nope.
09:43:19 <lolisa> You can write very limited tactic in idris equivalence of ghci
09:43:38 <lolisa> But 1: they are very limited, a few rewrite, apply, intros, that's it.
09:44:26 <yasar11732> it turns out author changes type signature to "solveRPN :: String -> Float" later on :)
09:44:27 <lolisa> 2: You cannot save them for later use, and you cannot group tactic together like Coq's backtracking, || and ;
09:45:19 <lolisa> 3: The author believe it is right to keep tactic in this useless way, because he believe tactic is useless.
09:46:06 <nshepperd> hmm
09:46:35 <lolisa> What struck me the most is, when edwin is building idris, he say on Quora and Stackoverflow, Idris = (Coq+Agda). That's why I joined for a few days, and I found out it is at it's most agda done right.
09:46:39 <nshepperd> so you can't write them as ordinary idris declarations, but only in the shell?
09:46:55 <lolisa> Only in interactive shell.
09:47:27 <haskell776> Hi, I have list of this type: `[Either String MyCustomType]`. I would like to process it and get `String` (containing error message) if it one element is instance of Left and `[MyCustomType]` if every element is instance of Right. How do I achieve it? Thank you!
09:47:43 <merijn> haskell776: sequence
09:48:01 <merijn> > sequence [Right 1, Right 3, Left "foo"]
09:48:02 <lambdabot>  Left "foo"
09:48:12 <merijn> > sequence [Right 1, Right 3, Right 9]
09:48:14 <lambdabot>  Right [1,3,9]
09:48:17 <merijn> :t sequence
09:48:18 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
09:48:34 <merijn> :t Data.OldList.sequence --does this exist?
09:48:35 <lambdabot> Not in scope: ‚ÄòData.OldList.sequence‚Äô
09:48:44 <merijn> hmm, not in lambdabot, apparently
09:48:47 <bennofs> :t sequence `asAppliedTo` [Right 1, Right 3, Left "foo"]
09:48:48 <lambdabot> Num a => [Either [Char] a] -> Either [Char] [a]
09:49:17 <ion> > (sequence . sequence) [Right 1, Right 3, Right 9]
09:49:18 <lambdabot>  [Right 1,Right 3,Right 9]
09:58:51 <jmcarthur> does anybody know of a convenient way to ensure that some part of a STM transaction will *not* be rolled back? i have some logic for thunks in STM and i want to always the save results of evaluating them even if the transaction is aborted. i could always make my own wrapper monad around STM, but if the solution already exists somewhere i'd rather just use it
09:59:26 <jmcarthur> plus it's not immediately obvious how i'd implement it anyway, though surely i could find a way...
09:59:59 <Cale> hmm
10:00:51 <Cale> I guess you could use unsafeIOToSTM for something like that.
10:01:05 <haskell776> merijn: Awesome, it works! :) Thank you very much.
10:01:13 <nshepperd> that sounds like you're asking how to subvert the safety of STM
10:01:33 <jmcarthur> Cale: not sure i see how that'd work. it's not safe to nest calls to atomically and such, after all
10:01:37 <ion> unsafeIOToSTM launchMissiles
10:01:53 <Cale> jmcarthur: I mean, to have effects which persist even when transactions don't commit.
10:01:57 <jmcarthur> nshepperd: sort of... in this case i know it would be safe because evaluating the thunk always yields the same results anyway
10:02:12 <jmcarthur> Cale: the thunks are stored in TVars though
10:02:18 <jmcarthur> at least right now
10:03:17 <nshepperd> well, I would assume that thunks that are evaluated stay evaluated
10:03:33 <jmcarthur> nshepperd: not GHC thunks. my own implementation, using TVar for mutability
10:04:08 <nshepperd> oh
10:08:15 * hackagebot wiring 0.3.0 - Wiring, promotion and demotion of types.  http://hackage.haskell.org/package/wiring-0.3.0 (seanparsons)
10:08:34 <shapr> Is there a graph library that works more like graphviz? I want to build undirected graphs that associate ADT values
10:09:01 <shapr> I read up on FGL, but it seems to want Int to identify vertices, is there more to that?
10:09:20 <nshepperd> I don't suppose you can break it up into a few separate atomic blocks
10:10:35 <jmcarthur> nshepperd: i suppose i could try to arrange to know what thunks i will want to evaluate up front... seems awkward though
10:10:52 <jmcarthur> ah, no, i can't in general
10:12:36 <Cale> shapr: Well, you can label the vertices (and edges), but the reason for that I think is just so that the operations can be backed by something like IntMap.
10:13:18 <Cale> shapr: I've often just used something along the lines of  Map Vertex (Set Vertex)  when I needed a graph representation.
10:38:15 * hackagebot flamingra 0.1.1.1 - FlameGraphs of profiling  http://hackage.haskell.org/package/flamingra-0.1.1.1 (AntonNikishaev)
10:38:17 * hackagebot dash-haskell 1.0.0.4 - Command line tool to generate Dash docsets (IDE docs) from package haddock  http://hackage.haskell.org/package/dash-haskell-1.0.0.4 (jfeltz)
10:48:38 <bananagram> is there a version of member for lists?
10:48:53 <quchen> Waaait, Bifunctor is in Base now?
10:49:29 <quchen> That's pretty useful.
10:49:41 <monochrom> bananagram: perhaps it is "elem"
10:49:57 <bananagram> oh, yeah 
10:50:22 <bananagram> they could be the same name
10:56:55 <yasar11732> is Num a data constructor or a type class?
10:57:12 <ski> it's a type class
10:58:00 <yasar11732> can I check what something is on ghci, :t Num didnt work
10:58:14 <ski> try `:info Num'
10:58:50 <yasar11732> ski: ohh, pretty handy :)
10:59:10 <ski> (`:i' for shorT)
11:00:21 <yasar11732> "let x = 2 + 4 ; :t x" says that type of x is "Num a => a", shouldn't it be a concrete type like Integer?
11:00:36 <c_wraith> not until it has a reason to be concrete
11:00:56 <c_wraith> Like, if you were to attempt to display the value, it would need to be concrete then, since concrete type affects how it displays
11:01:07 <merijn> Obligatory complaint that the term "concrete type" is ill-defined and shouldn't be used
11:01:16 <c_wraith> monomorphic, then
11:01:20 <merijn> :)
11:01:46 <yasar11732> I guess polymorphic is something that can be used as different types?
11:02:22 <merijn> A polymorphic type has "unfixed" variables in it that can change depending on context, whereas monomorphic does not
11:02:38 <merijn> For example, Int is monomorphic, but "Maybe a" is polymorphic (since 'a' isn't fixed)
11:02:54 <c_wraith> ...  That explanation breaks down when you start involving rank 2 types, but..  That's a different issue. :)
11:02:58 <Xnuk> @pl \x -> f x x
11:02:59 <lambdabot> join f
11:03:07 <quchen> merijn: Parametric, no?
11:03:29 <merijn> c_wraith: By the time we get to rank2 types you can use a more rigid definition :p
11:03:38 <merijn> quchen: All polymorphism in haskell is parametric
11:03:44 <Xnuk> @type join
11:03:45 <lambdabot> Monad m => m (m a) -> m a
11:04:10 <c_wraith> merijn: well, sometimes bounded parametretric polymorphism has been called ad-hoc polymorphism - like even by the people who invented it. :)
11:04:46 <quchen> merijn: I was told you'd call a value of type Int monomorphic, because Int isn't parametric in anything.
11:04:53 <merijn> c_wraith: I think "constrained parametric polymorphism" is clearer :)
11:05:11 <merijn> quchen: monomorphic is literally the opposite of polymorphic :)
11:05:24 <merijn> quchen: poly (many) vs mono (one)
11:05:35 <merijn> I guess morphic would be liked "shaped"
11:06:29 <merijn> quchen: Since haskell only has parametric polymorphism (nitpicking about constraints notwithstanding) any non-parametric type is by definition also monomorphic, yes :p
11:06:52 <merijn> quchen: non-parametric and monophoric are probably the same thing in haskell, but I'm not 100% sure
11:06:58 <merijn> *monomorphic
11:07:10 <merijn> quchen: Well, actually
11:07:19 <c_wraith> I just think calling bounded polymorphism parametric is a bit misleading, because it doesn't imply the free theorems you get from parametricity
11:07:29 <merijn> quchen: A trivial counterexample would be the type "a" which is polymorphic and not parametric :p
11:07:33 <yasar11732> am I the only one who doesn't have a PHD in math here? :)
11:07:40 <bennofs> yasar11732: no
11:07:53 <merijn> yasar11732: I didn't know any of this stuff when I started, I just lurked here a lot :p
11:07:55 <c_wraith> yasar11732: I have no math degrees at all.  I just learned some haskell.  Unless you call CS an applied math degree. :)
11:07:58 <mr-_> yasar11732: it's not math anyways :-P
11:08:58 <merijn> c_wraith: Perhaps, but I think it's conceptually easier. So I'm simplifying for pedagogical reasons :p
11:09:01 <quchen> merijn: I had this very discussion here some time ago, me thinking what you just told me. I don't remember who, but I was told the terminology is off if you call types polymorphic. Hence me double checking now.
11:09:14 <quchen> (I have a hunch it was ski. Hmm, IRCBrowse might help.)
11:10:37 <quchen> merijn: Yep, it was ski. Here's the discussion: http://ircbrowse.net/browse/haskell?id=19662897&timestamp=1418666810#t1418666810
11:10:42 * ski blinks
11:10:57 <quchen> Oh, speak of the devil! :-)
11:11:34 <c_wraith> you woke the devil?  good job! :)
11:13:20 * hackagebot hutton 1.0.0 - A program for the button on Reddit.  http://hackage.haskell.org/package/hutton-1.0.0 (fozworth)
11:13:47 <quchen> I think what ski said is pretty reasonable. The type "forall a. Maybe a" doesn't have "many shapes", it has one shape.
11:14:28 <quchen> I guess "polykinded" is what we call "polymorphic types" in Haskell.
11:14:34 <ski> `Maybe a' isn't polymorphic, `forall a. Maybe a' is another matter. however, i prefer being able to say that `Nothing' is what is polymorphic. then its type, `forall a. Maybe a' could be said to be universal
11:15:19 <ski> `Maybe' is parametric (aka a type function). `Maybe a' is an open type (in the sense of open expression, like `\x -> x + y' is open because it has `y' as a free variable)
11:15:25 <quchen> ski: What does "Maybe a" mean that makes it different from "‚àÄ a. Maybe a"?
11:15:35 <quchen> Ah.
11:16:38 <ski> quchen : if we abbreviate `Maybe a' as `<Some type>', then `<Some type> -> Int' means `Maybe a -> Int'. it does not mean `(forall a. Maybe a) -> Int'
11:16:54 <voidzero> When I read about the things you're discussing right now, I always wonder if there's some place (website, pdf, book) where these things are explained to non-programmers like myself
11:17:24 <merijn> voidzero: Depends which parts interest you
11:17:36 <ski> a universal type is distinct from its instantiation, where the bound tyvar is replaced by a free one
11:18:10 <jmcarthur> there are websites, pdfs, and books to explain to non-programmers how to become programmers
11:18:20 * hackagebot monoid-extras 0.4.0.0 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.4.0.0 (BrentYorgey)
11:18:48 <voidzero> I mean like what ski just explained
11:18:52 <quchen> This isn't really about programming though, it's about the logical background. You can study that in math, philosophy, or from a computer science perspective.
11:19:17 <quchen> And from a logical perspective as well, of course. No offense logicians. :-)
11:19:24 <voidzero> sure, but if you're not in the field, not an academic, i.e. just have some books and this IRC channel...
11:19:59 <quchen> I'm an academic and I have not heard about this once in my studies. Which makes sense, because physics isn't really concerned about these kinds of things.
11:20:54 <merijn> voidzero: The background for this is type theory and the best way to get into that is probably TaPL + some intro on propositional logic
11:23:20 <redwing8e> nicklist
11:24:35 <orion> How can I concatenate two objects in aeson?
11:24:45 <voidzero> Alright. I'll search using those keywords when I have the time. Is type theory related to category theory, or is category theory the same thing as type theory?
11:25:14 <voidzero> I should probably just read the wikipedia pages. Currently also producing a radio show, so my mental bandwidth is too limited right now. :-)
11:25:31 <orion> For example, I might have {"x": 0, "y": 1} and {"z": 2}. I want to combine them to make {"x": 0, "y": 1, "z": 2}
11:25:33 <merijn> voidzero: Category theory is something completely different and the relationship between the two is very abstract
11:25:46 <merijn> voidzero: I recommend this book if you can afford it/find it in a library
11:25:48 <merijn> @where tapl
11:25:48 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
11:26:37 <voidzero> Pricey!
11:26:54 <voidzero> But noted, thanks for the tip
11:27:04 <davidshore> does -ddump-splices do the same thing as lisp's macro-expand?
11:28:21 * hackagebot diagrams-core 1.3 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-1.3 (BrentYorgey)
11:33:22 * hackagebot active 0.2.0.0 - Abstractions for animation  http://hackage.haskell.org/package/active-0.2.0.0 (BrentYorgey)
11:33:24 * hackagebot diagrams-solve 0.1 - Pure Haskell solver routines used by diagrams  http://hackage.haskell.org/package/diagrams-solve-0.1 (BrentYorgey)
11:37:03 <redwing8e> exit
11:38:22 * hackagebot diagrams-lib 1.3 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.3 (BrentYorgey)
11:38:24 * hackagebot SVGFonts 1.5.0.0 - Fonts from the SVG-Font format  http://hackage.haskell.org/package/SVGFonts-1.5.0.0 (BrentYorgey)
11:38:40 <t7> @hoogle Int -> a -> [a]
11:38:42 <lambdabot> Prelude replicate :: Int -> a -> [a]
11:38:43 <lambdabot> Data.List replicate :: Int -> a -> [a]
11:38:43 <lambdabot> Prelude drop :: Int -> [a] -> [a]
11:43:30 * hackagebot force-layout 0.4.0.0 - Simple force-directed layout  http://hackage.haskell.org/package/force-layout-0.4.0.0 (BrentYorgey)
11:43:32 * hackagebot diagrams-contrib 1.3.0 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.3.0 (BrentYorgey)
11:43:34 * hackagebot statestack 0.2.0.4 - Simple State-like monad transformer with saveable and restorable state  http://hackage.haskell.org/package/statestack-0.2.0.4 (BrentYorgey)
11:52:00 <OutlawStar> question, I'm trying to figure out how to unwrap my state from my type "TmClient" so that I can perform actions on the state it wraps. But I can't figure out how to unwrap it. I have snippets of the code here "http://pastebin.com/d5XFFFx9" can some one possible look at this and provide me some insight. I'm still relatively new to monads...
11:52:20 <OutlawStar> line 12 is the line that odesn't compile
11:53:31 * hackagebot diagrams-cairo 1.3 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-1.3 (BrentYorgey)
11:53:33 * hackagebot diagrams-gtk 1.3 - Backend for rendering diagrams directly to GTK windows  http://hackage.haskell.org/package/diagrams-gtk-1.3 (BrentYorgey)
11:54:19 <geekosaur> line 2 you want: deriving (Monad, MonadState s)
11:54:42 <geekosaur> (in fact you can drop the Monad because it's implied by deriving MonadState)
11:55:15 <OutlawStar> ok, wow that worked. Thanks!
11:55:32 <OutlawStar> now i just need to figure out what that did :)
11:56:26 <geekosaur> you're trying to use MonadState operations with your newtype-d monad. it's not enough to derive Monad; you need to derive MonadState for get / put / modify to be available
11:56:35 <geekosaur> because MonadState is where they come from
11:56:50 <OutlawStar> right i thought it was somthing like that
11:57:15 <OutlawStar> i tried implementing an instance of MonadSTate manually. Think I would override get/put to unwrap my TmClient
11:57:20 <OutlawStar> but I couldn't get it working :(
11:58:31 * hackagebot diagrams-postscript 1.3.0.0 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.3.0.0 (BrentYorgey)
11:58:33 * hackagebot diagrams-rasterific 1.3.0.0 - Rasterific backend for diagrams.  http://hackage.haskell.org/package/diagrams-rasterific-1.3.0.0 (BrentYorgey)
11:58:35 * hackagebot diagrams-svg 1.3 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-1.3 (BrentYorgey)
11:58:37 * hackagebot diagrams-canvas 1.3 - HTML5 canvas backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-canvas-1.3 (BrentYorgey)
12:03:44 * hackagebot diagrams-builder 0.7.0.0 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.7.0.0 (BrentYorgey)
12:04:03 <OutlawStar> geekosaur: when I remove monad from deriving i get an error saying to using a standalone 'deriving instance' declartion. Any idea what that means
12:08:45 * hackagebot diagrams-haddock 0.3 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.3 (BrentYorgey)
12:08:47 * hackagebot diagrams 1.3 - Embedded domain-specific language for declarative vector graphics  http://hackage.haskell.org/package/diagrams-1.3 (BrentYorgey)
12:09:03 <sagittarian|2> i don't think you can put Monad in deriving
12:09:17 <sagittarian|2> in any case you have to provide implementations of return and (>>=)
12:09:47 <byorgey> sagittarian|2: you can derive Monad if you are using GeneralizedNewtypeDeriving
12:11:24 <OutlawStar> sagittarian|2: using Generalized.... like byorgey says allows the compiler to implement the boiler plate code
12:11:55 <OutlawStar> its nice (in a way). Since i still learning i implemented them first and then used the compiler flag
12:15:19 <OutlawStar> so trying to get the deriving thing working, I now have "newtype TmClient s a = Client (State s a)"
12:15:31 <OutlawStar> followed by "deriving instance  MonadState (TmClient s)"
12:15:41 <OutlawStar> apparently that deriving statement isn't leagal
12:15:56 <ion> Try adding parentheses around MonadState (TmClient s)
12:16:04 <OutlawStar> is it the face that I am using "s"?
12:16:07 <OutlawStar> fact*
12:16:57 <OutlawStar> note parens don't work
12:17:01 <OutlawStar> nope*
12:18:02 <ski> Quashie_ : `deriving instance MonadState s (TmClient s)'
12:18:05 <ski> er
12:18:08 <ski> OutlawStar ^
12:18:10 <monochrom> is State a type synonym? is this type synonym an instance of anything at all to begin with?
12:18:25 <OutlawStar> exact error: The first argument of ‚ÄòControl.Monad.State.Class.MonadState‚Äô should have kind ‚Äò*‚Äô, but ‚ÄòFile.TmClient s‚Äô has kind ‚Äò* -> *‚ÄôIn the stand-alone deriving instance 
12:19:00 <ski> OutlawStar : yes, so you need two arguments. `s' and `TmClient s'
12:19:03 <monochrom> if you write "newtype ... = ... State ..." and State is not an instance of anything at all, for whatever reason, then clearly no amount of generalized newtype deriving will derive anything
12:19:28 <ski> (well, that's not exactly what the error is saying. but it's what you need to do to fix one error)
12:19:40 <ion> @let newtype Foo s a = Foo (State s a) deriving (Functor, Applicative, Monad, MonadState s)
12:19:42 <lambdabot>  .L.hs:152:1:
12:19:42 <lambdabot>      Multiple declarations of ‚ÄòFoo‚Äô
12:19:42 <lambdabot>      Declared at: .L.hs:150:1
12:19:49 <ion> @undefine
12:19:49 <lambdabot> Undefined.
12:19:59 <ion> @let newtype Testing s a = HelloThisIsDog (State s a) deriving (Functor, Applicative, Monad, MonadState s)
12:20:00 <lambdabot>  .L.hs:143:40:
12:20:00 <lambdabot>      Can't make a derived instance of ‚ÄòApplicative (Testing s)‚Äô:
12:20:00 <lambdabot>        ‚ÄòApplicative‚Äô is not a derivable class
12:20:06 <ion> meh
12:20:07 <ion> @undefine
12:20:07 <lambdabot> Undefined.
12:21:04 <c_wraith> ion: I think lambdabot is using safe haskell these days, and safe haskell disallows GND
12:21:29 <ion> ok
12:21:38 <OutlawStar> hmmm so its still not liking it, I've enabled FlexiableInstances and MultiParamTypeClasses
12:22:13 <ion> The error message would help.
12:22:31 <OutlawStar> yeah
12:22:32 <OutlawStar> getting that
12:22:32 <OutlawStar> :)
12:22:35 <OutlawStar> No instance for (GHC.Base.Monad (File.TmClient s)) arising from the superclasses of an instance declarationIn the instance declaration for ‚ÄòControl.Monad.State.Class.MonadState s (File.TmClient s)‚Äô
12:22:49 <ion> You‚Äôll need to derive Monad.
12:23:32 <monochrom> eh, I guess I was wrong
12:24:10 <monochrom> deriving (Functor, ..., Monad, MonadState s)
12:24:21 <OutlawStar> so when I derive monad it claims that it is redundant
12:24:35 <OutlawStar> or wait
12:24:36 <OutlawStar> nvm
12:24:48 <OutlawStar> i think that might be something else
12:26:29 <OutlawStar> hmm so now it says its not a member of applicative. So when I add that, it says it does not exist :)
12:26:44 <monochrom> import Control.Applicative
12:26:48 <OutlawStar> am I doing something fundamentally wrong?
12:27:14 <OutlawStar> monocrhom: thanks, that worked
12:27:24 <ion> Weird, if Monad depends on Applicative you should have Applicative in Prelude.
12:28:18 <OutlawStar> thanks for the help guys!
12:28:38 <monochrom> in 7.10 it is in Prelude
12:29:13 <monochrom> and 7.10 is the starting version that enforces the requirement
12:29:32 <monochrom> 7.8 does not have it in Prelude and 7.8 does not enforce the requirement
12:29:34 <monochrom> all is well
12:30:51 <Cale> I think 7.8 still warned you
12:31:08 <voidzero> yeah.
12:31:10 <OutlawStar> yes it did
12:32:52 <tar_> can I trivially create a monad transformer based on StateT but expose only some helper functions I create and not get & put?
12:33:08 <monochrom> yes
12:33:25 <tar_> I'm not sure what to search for, or where to find an example
12:33:30 <Cale> MonadRandom
12:33:35 <monochrom> for best results, uew newtype, but don't derive MonadState Whatever
12:33:51 * hackagebot gnuplot 0.5.4 - 2D and 3D plots using gnuplot  http://hackage.haskell.org/package/gnuplot-0.5.4 (HenningThielemann)
12:36:03 <tar_> Thanks.
12:36:50 <hexagoxel> tar_: example: https://github.com/lspitzner/exference-exference-core/blob/master/src/Language/Haskell/Exference/Internal/ExferenceNodeBuilder.hs
12:39:12 <hexagoxel> tar_: as suggested, i only derive up to Monad, and expose the type, not the constructor
12:39:41 <tar_> hexagoxel: how do you use it in a monad transformer stack?
12:41:34 <zaquest> @pl (\a b -> f (rootLabel a) (treeFold f b a))
12:41:34 <lambdabot> ap ((.) . f . rootLabel) (flip (treeFold f))
12:41:51 <tar_> MonadRandom has newtype RandT g m a = RandT (StateT g m a) deriving (Functor, Monad, MonadTrans, MonadIO, MonadFix, MonadReader r, MonadWriter w)
12:42:07 <tar_> looks good to me
12:42:36 <hexagoxel> tar_: i don't .. and i think there is no lightweight way to achieve that (unless you accept manual lifting)
12:42:56 <hexagoxel> tar_: but that exposes get/put (and lots more) (i think)
12:43:49 <hexagoxel> the manual way is to create a new typeclass, similar to MonadState
12:43:54 <tar_> ahh
12:45:09 <hexagoxel> another idea is to wrap your _state_ (not the transformer) in some special newtype, and only provide access in and out of that wrapped state via certain functions
12:45:54 <Athas> Is it possible to autogenerate modules in my Setup.hs that will also work with 'cabal sdist'?
12:46:35 <hexagoxel> tar_: but then again the user could save the state at one point and restore it at another, so stuff is still exposed (even if the user cannot do anything directly with the state)
12:47:22 <hexagoxel> s/state/wrapped state/
12:53:29 <orbifx> any of the ArchHaskell devs here?
12:53:55 * hackagebot microlens 0.1.0.0 - A tiny part of the lens library which you can depend upon.  http://hackage.haskell.org/package/microlens-0.1.0.0 (Artyom)
12:53:57 * hackagebot microlens-each 0.1.0.0 - 'each' for microlens  http://hackage.haskell.org/package/microlens-each-0.1.0.0 (Artyom)
12:53:59 * hackagebot microlens-mtl 0.1.0.0 - microlens support for Reader/Writer/State from mtl  http://hackage.haskell.org/package/microlens-mtl-0.1.0.0 (Artyom)
12:54:01 * hackagebot microlens-th 0.1.0.0 - Automatic generation of record lenses for 'microlens'.  http://hackage.haskell.org/package/microlens-th-0.1.0.0 (Artyom)
13:01:33 <davidshore> is there a way to view the definition of a function in ghci if the source is available?
13:02:32 <indiagreen> davidshore: not that I know of
13:04:30 <davidshore> bummer
13:05:37 <voidzero> finding it via hayoo might be the next best thing though
13:05:50 <indiagreen> davidshore: you can create a ghci macros which would open the relevant hoogle/hayoo page for you
13:11:43 <yasar11732> Very newbie question: Why won't forcing recursion instead of loops cause stackoverflows in Haskell?
13:12:18 <srhb> There is no stack. Hooray!
13:12:26 <srhb> (Sort of)
13:12:51 <srhb> Or rather, no call stack. :)
13:13:12 <yasar11732> Coming from C programming, I am having hard time understanding how the memory is managed
13:13:47 <yasar11732> I guess it is pretty normal though, I followed online tutorials for only 5-6 hours total I guess
13:14:09 <srhb> yasar11732: Yes, that's expected :P
13:14:16 <Cale> yasar11732: GHC's evaluator doesn't have a call stack
13:14:26 <yasar11732> still I can't get rid of my need to micro manage memory :)
13:14:47 <Cale> yasar11732: So, right off the bat, all your intuitions about the stack are wrong :D
13:15:29 <Cale> yasar11732: Instead, what corresponds to the C stack effectively represents case expressions who are waiting for their scrutinee to be sufficiently evaluated to match a pattern.
13:15:32 <yasar11732> so, does the evaluator use some kind of loop internally?
13:16:08 <faux___> does haskell support "double list comprehensions"? eg `[(item, subitem) | subitem <- subitems item | item <- items]`
13:16:20 <srhb> faux___: Not sure if you are thinking of parallel list comprehensions
13:16:24 <arkeet> faux___: use a comma instead of the second |
13:16:37 <srhb> But probably what arkeet said.
13:16:42 <faux___> srhb: i don't want to zip
13:16:47 <srhb> What arkeet said then.
13:16:52 <arkeet> and I think you want to switch the order around.
13:16:57 <arkeet> item first
13:17:39 <sagittarian|2> is there an extension to use list comprehension syntax for arbitrary monads?
13:17:45 <arkeet> yes, MonadComprehensions
13:17:51 <faux___> arkeet: if i change the | to a , then `item` is not in scope
13:17:56 <ski> > [[x,y] | x <- "012" | y <- "abcde"]  -- faux___
13:17:58 <arkeet> faux___: like I said, switch the order around.
13:17:58 <lambdabot>  ["0a","1b","2c"]
13:17:58 <sagittarian|2> of course, how could i have ever doubted it
13:18:14 <arkeet> [(item, subitem) | item <- items, subitem <- subitems item]
13:18:20 <ski> > [[x,y] | x <- "012" , y <- "abcde"]  -- respectively
13:18:22 <lambdabot>  ["0a","0b","0c","0d","0e","1a","1b","1c","1d","1e","2a","2b","2c","2d","2e"]
13:18:26 <arkeet> because it goes left to right
13:18:44 <ski> > [[[x,y] | y <- "abcde"] | x <- "012"]  -- also see
13:18:45 <lambdabot>  [["0a","0b","0c","0d","0e"],["1a","1b","1c","1d","1e"],["2a","2b","2c","2d",...
13:18:56 * hackagebot hsreadability 1.0.0.0 - Access to the Readability API.  http://hackage.haskell.org/package/hsreadability-1.0.0.0 (rasendubi)
13:19:08 <Cale> yasar11732: I was going to give a complicated description, but instead, let me just point you to a paper which does an excellent job... it's slightly out of date with what's in GHC right now, but it has a pretty good section discussing the design space
13:19:20 <Cale> http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
13:20:34 <Cale> yasar11732: Basically, you have to be aware that there's a representation for expression graphs which still exists at runtime. Whichever data structure is used to represent expressions at runtime is generally referred to as a "thunk".
13:20:42 <faux___> arkeet: yep that did it thanks
13:25:17 <Cale> yasar11732: In GHC, a thunk consists of a pointer to code along with a table in which a constructor and pointers to its arguments may be written. The first time the code is entered, it computes the value of the expression (i.e. determining the data constructor and its arguments), and then rewrites the pointer to point at a shorter piece of code which will just return that immediately next time, before returning.
13:27:14 <Cale> yasar11732: The continuation that gets put on the stack before entering the code can essentially always be thought of as a case expression which wants to know which constructor the expression's value is constructed with so that it can match.
13:27:30 <Cale> (even if there might be a few other primitive reasons to evaluate an expression)
13:28:46 <Cale> yasar11732: Plain lazy evaluation is outermost-first, so when you have something like f (g (h x)), the code for f gets entered, and its argument is the not-yet-evaluated expression g (h x)
13:29:17 <ski> (the stack consist of evaluation context "frames". it's just that there are fewer of those around in cbn, as compared to cbv)
13:31:08 <Cale> Yeah, I'm failing to mention a technically important case here: if the function you're applying is itself an application, then you get a stack entry that way as well, but I don't think I've ever had a stack overflow where that kind of stack entry was the culprit.
13:32:40 <Cale> This is because usually the types of functions typically restrict the number of parameters you could ever apply them to so that it's not terribly large (or even if it's unbounded in the case of polymorphic functions, after you apply such a function to one or two of its parameters, it tends not to be unbounded any longer)
13:34:05 <ski> > let x :: Monad m => m a; x = x () in runIdentity x
13:34:07 <lambdabot>  *Exception: stack overflow
13:34:12 <c_wraith> does GHC current do eval/apply or push/enter (or some hybrid?)
13:34:20 <ezyang_> Is there a way to make GHC output both the starting and ending column of a line number? 
13:34:34 <ezyang_> sorry, the starting and ending col/lines of an error 
13:34:44 <kuribas> Is it possible to put a warning when an invariant that is not encoded in the datatype is violated?  Or should I give an error?  It means that something probably is wrong, but may not break the program.
13:35:13 <kuribas> For example a function that expects a non-empty list.
13:35:39 <c_wraith> kuribas: if it implies a programmer mistake, error is appropriate.
13:36:04 <c_wraith> kuribas: especially in contrast to guessing what the programmer meant and trying to continue.  Like...  *coughcough*some other languages
13:36:26 <ski> > let x :: a; x = x () in x  -- hmm
13:36:30 <lambdabot>  mueval-core: Time limit exceeded
13:36:31 <kuribas> c_wraith: well, likely my own error...
13:36:34 <ezyang_> -ferror-spans 
13:36:44 <c_wraith> ezyang_: that exists?
13:36:53 <frerich> kuribas: A common approach to solve this issue is to enforce invariants by having abstract newtypes. http://hackage.haskell.org/package/smartconstructor-0.2.0.0/docs/SmartConstructor.html may be useful for this.
13:36:58 <ezyang_> yes. 
13:37:00 <c_wraith> Oh, it must, for things like flymake
13:37:33 <ezyang_> This is frustrating, I'm trying to teach error spans to know about splices but if I combine a splice error location with a real error location, what kind of span should I get 
13:37:44 <ezyang_> in any situation this happens, the span is basically nonsense anyway 
13:38:53 <kuribas> c_wraith, frerich: For example I have (Map k (Set v)), but the set is supposed to be nonempty, because deleting the last v should remove the key.
13:39:36 <Cale> c_wraith: http://community.haskell.org/~simonmar/papers/evalapplyjfp06.pdf suggests that it's presently eval/apply
13:40:19 <Cale> odd, the PDF version of these papers looks markedly worse than the PostScript for me
13:40:37 <Cale> you can find the postscript one here: http://research.microsoft.com/en-us/um/people/simonpj/papers/eval-apply/
13:40:50 <kuribas> c_wraith, frerich: if another function finds an empty set, that means a mistake, but not necessarily a breaking bug...
13:41:07 <kuribas> Though it may lead to spaceleak.
13:41:44 <yasar11732> Cale: Thanks for the explanation, I was trying to read the pdf and didnt see you also had some explanations here for a while
13:41:54 <Cale> yasar11732: I figured :)
13:42:53 <Cale> yasar11732: Anyway, what is going on in my head when I think about program performance in Haskell is not really any of these details
13:43:11 <Cale> yasar11732: Instead, it's more something like this: http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
13:43:47 <Cale> That's from a different functional language which makes the expression graphs quite explicit :)
13:45:20 <Cale> I'll often reason about the behaviour of programs simply by substituting definitions in one by one, in an outermost-first fashion, which gives a decent approximation to lazy evaluation, but you have to be aware than when a variable is used more than once in its scope, lazy evaluation says that it's evaluated at most once, and the result of that evaluation shared between the occurrences.
13:45:22 <yasar11732> Cale: so how do you get the second behaviour instead of first
13:46:37 <Cale> Well, in Haskell, you can't do what was done in HOPS there, but you can write a foldl' instead of a foldr (or you can write a foldl and let the optimisations in the compiler discover that it can evaluate the accumulator early because multiplication is strict)
13:47:14 <Cale> Or, well, I suppose the example isn't explicitly a foldr there :)
13:47:50 <Cale> So the equivalent is to write a tail recursive function, and express the desire to evaluate the accumulating parameter.
13:48:22 <Cale> If you just write a tail recursive function, and don't have optimisations turned on, then what can happen is...
13:48:28 <Cale> Well, let's say we have
13:49:04 <Cale> fac 0 k = k; fac n k = fac (n-1) (n*k)
13:50:45 <Cale> Then fac 5 1 -> fac (5-1) (5*1) -> fac 4 (5*1) -> fac (4-1) (4*(5*1)) -> fac 3 (4*(5*1)) -> fac (3-1) (3*(4*(5*1))) -> ... -> fac 0 (1*(2*(3*(4*(5*1))))) -> 1*(2*(3*(4*(5*1))))
13:51:58 <Cale> During all this reduction, the only things which resulted in stack use were the pattern matches to see if the first argument is 0, and that never had to wait very long because it was only ever a single subtraction which needed to be done
13:52:29 <Cale> But now we have a problem, we have an expression which looks like 1*(...) and (*) needs to know the value of both its arguments
13:52:44 <Cale> So this waits on the stack, and we evaluate 2*(...)
13:53:02 <Cale> and then that waits on the stack, and so on until we get to 5*1
13:53:58 <Cale> So, not only have we used a lot of heap space on accumulating this expression in the first place, if it gets too large, then we'll use lots of stack space in trying to evaluate it, since it's entirely built up from nested applications of strict functions
13:54:12 <Cale> So, to avoid that, you can write something like:
13:54:26 <Cale> fac 0 k = k; fac n k = k `seq` fac (n-1) (n*k)
13:54:53 <Cale> Or using bang patterns,
13:55:07 <Cale> fac 0 k = k; fac n !k = fac (n-1) (n*k)
13:55:38 <yasar11732> I know neither of those things yet :) 
13:55:42 <Cale> okay
13:56:42 <Cale> x `seq` y evaluates to the same thing as y, but makes sure that x is evaluated before the result of evaluating y is made available.
13:57:07 <Cale> Well, you can sort of think of it as "evaluate x before resulting in y"
13:58:17 <Cale> But really the only restriction is that if the evaluation of x doesn't terminate, then the evaluation of x `seq` y must not terminate, and if the evaluation of x does terminate, the result of evaluating x `seq` y must be y.
13:59:21 <yasar11732> Ohh, so it says do some calculation before other calculation
13:59:33 <verement> @src ($!)
13:59:33 <lambdabot> f $! x = x `seq` f x
13:59:43 <Cale> So x `seq` y `seq` z means the same thing as y `seq` x `seq` z, and the compiler is allowed to rearrange them like that if it wants.
13:59:50 <Cale> and x `seq` x means the same thing as x
14:00:14 <Cale> Also, x `seq` y technically means the same thing as y `seq` x `seq` y
14:00:48 <Cale> But generally, if the latter would be bad, and you give the compiler the right to evaluate x first, it will take your option ;)
14:01:46 <Cale> But if you tell GHC x `seq` y and it discovers that it would be bad to evaluate x first, it's allowed to evaluate y first instead anyway (but it will still evaluate x).
14:03:00 <Cale> There's a variant called pseq which is similar but operationally stronger, GHC is not allowed to reorder things however it likes with x `pseq` y -- it really will evaluate x first, and then y.
14:03:34 <Cale> (but usually since evaluation order matters only for performance, you'd rather leave the compiler an out if it's able to discover something clever)
14:04:15 <lpaste> yasar11732 pasted ‚Äúfibo sequence‚Äù at http://lpaste.net/130988
14:04:44 <yasar11732> This is completly different question, but can you have a look at that?
14:05:42 <yasar11732> I think I should use something like a fold but I am not really sure
14:09:27 <ion> > let fibs = 0 : 1 : zipWith (+) fibs (drop 1 fibs) in fibs
14:09:28 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
14:10:25 <kess> yasar11732: this is a fix for what you're trying to do, but it's kinda ugly and really inefficient
14:10:39 <kess> http://lpaste.net/130988
14:12:04 <yasar11732> kess: doesn't it produce the list backward?
14:12:21 <kess> actually I don't think it's too inefficient, but it still does it backward yes
14:12:40 <kess> ion's solution is much more elegant and gives you a nice infinite list
14:13:16 <yasar11732> yeah, I am still tryin to figure that one out :D
14:13:59 <yasar11732> Are you even allowed to do that :D
14:14:07 <kess> why not? :P
14:14:26 <yasar11732> so you can zip something onto itself in its definition?
14:14:32 <ion> > let zeros = 0 : zeros
14:14:33 <kess> sure
14:14:33 <lambdabot>  <no location info>: not an expression: ‚Äòlet zeros = 0 : zeros‚Äô
14:14:42 <ion> > let zeros = 0 : zeros in zeros
14:14:43 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
14:14:57 <ion> > let nats = 0 : map (+1) nats in nats
14:14:58 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
14:15:16 <kess> oh that one's nice
14:15:22 <yasar11732> this is actually pretty neat and mind-blowing
14:15:44 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
14:15:46 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
14:15:50 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in odds
14:15:51 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
14:16:11 <yasar11732> this is friggin awesome
14:16:40 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
14:16:41 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
14:17:23 <yasar11732> Did you just write a oneliner to return an infinte list of primes?
14:17:27 <Cale> yes
14:17:33 <tromp> > nubBy(((>1).).gcd)[2..]
14:17:34 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
14:17:54 <Cale> yasar11732: Note the mutual recursion
14:18:18 <Cale> yasar11732: isPrime n does trial division against the list of primes p for which p*p <= n
14:18:19 <mniip> tromp, dude that's ingenious
14:18:30 <tromp> but Cale's is way more efficient
14:18:35 <mniip> true but
14:19:06 <yasar11732> I didn't understand tromps version though :)
14:19:19 <Cale> yasar11732: and primes is defined as a list starting with 2 (need to give it some place to begin), and followed by the elements of [3,5..] which satisfy isPrime
14:19:25 <monochrom> I dislike using nubBy with a non-equivalence-relation
14:19:50 <tromp> nubBy eliminates duplicates from a list, where gcd x y > 1 defines the notion of duplicate equality
14:19:51 <mniip> > nubBy (((== 0) .) . mod) [2..]
14:19:52 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
14:19:57 <mniip> should be as efficient as cale's
14:20:11 <monochrom> it works out but it relies on a fragile implementation detail of nubBy that's hard to explain
14:20:13 <Cale> It's so efficient that it doesn't even work ;)
14:20:17 <mniip> oi
14:20:22 <mniip> uh
14:20:25 <Cale> monochrom: It's not that hard to explain though
14:20:32 <mniip> extra points to monochrom, because it works over here
14:21:33 <Cale> monochrom: The key to explaining the only complicated part is that you get a lexicographically minimal sequence of indices
14:21:35 <mniip> > nubBy (((== 0) .) . flip mod) [2..]
14:21:37 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
14:21:57 <mniip> interesting, over here nubBy does the opposite
14:23:15 <Cale> mniip: Yeah, due to the Haskell Report insisting that nubBy is only specified for equivalence relations, its behaviour for arbitrary relations has unfortunately changed a bunch in different versions of GHC.
14:23:34 <mniip> fair enough
14:24:06 <mniip> gcd is symmetric though, no?
14:24:08 <monochrom> my ideal nubBy uses unsafePerformIO to ask /dev/urandom for a few bits, to choose from one of many possible implementations that all give the same answer if your relation is an equivalence relation
14:24:16 <tromp> yes, gcd is symmtric
14:24:37 <Pamelloes> Is there a function that represents an if statement? Lambdabot came up with if', but I can't seem to find any references to that.
14:24:50 <mniip> Pamelloes, it's pointfree that came up with if'
14:24:52 <monochrom> so that if your relation is an equivalence relation, you get referential transparency. but if your relation is not, then you get random answers.
14:25:03 <monochrom> but Cale is very vocally against this :)
14:25:14 <Cale> I think it's a useful higher order function regardless.
14:25:55 <Cale> Similarly for groupBy
14:26:02 <Cale> Especially groupBy in fact.
14:26:03 <monochrom> ah, I should have done it for April 1st
14:26:39 <monochrom> let me code up a cron job that will post it next April 1st
14:26:47 <zq> god, i just love wasting my time debugging space leaks
14:27:06 <monochrom> haven't you heard? "space, the final frontier"
14:27:26 <monochrom> "these are your five-year debugging mission"
14:28:53 <Cale> zq: Yeah, I really wish that GHC had a mode of compilation which maintained more information about the expression graphs all the way through so tools could visualise them during graph reduction.
14:28:59 * hackagebot darcs 2.10.0 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-2.10.0 (GuillaumeHoffmann)
14:29:01 * hackagebot diagrams-html5 1.3 - HTML5 canvas backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-html5-1.3 (BrentYorgey)
14:29:07 <Cale> zq: It would make understanding space behaviour so much simpler.
14:29:16 <mniip> Pamelloes, the simplest pointfree implementation I could come up with was 
14:29:19 <mniip> (((head .) . (. return) . (++)) .) . (. return) . takeWhile . const
14:29:58 <Pamelloes> mniip: Thanks. I concluded that it would be better to just write out if ... then ... else in a lambda
14:30:05 <mniip> heh
14:31:26 <exio4> mniip: why not flip (flip . flip bool) ? 
14:31:34 <mniip> what's bool
14:32:20 <exio4> @type bool
14:32:21 <lambdabot> a -> a -> Bool -> a
14:32:32 <tromp> @let ifthenelse i t e = if i then t else e
14:32:33 <mniip> @src bool
14:32:33 <lambdabot>  Defined.
14:32:33 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:32:43 <mniip> exio4, it's not in base
14:32:57 <mniip> I have a feeling it's made up by lambdabot
14:32:58 <exio4> it is in Data.Bool
14:33:13 <mniip> wha
14:33:45 <mniip> well hoogle didn't locate it there
14:33:45 <exio4> https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Bool.html
14:34:38 <mniip> (flip . fmap flip . flip) bool
14:36:19 <floris497> I have the function: "doubleMe x = x + x" if i use "doubleMe (9^2)" i get 162 if i use "doubleMe 9^2" i get 324, why is this?
14:36:48 <HeladoDeBrownie> floris497, doubleMe 9^2 = (doubleMe 9)^2
14:37:07 <HeladoDeBrownie> function application binds tighter than any infix operator
14:37:11 <floris497> HeladoDeBrownie: ah.. just starting Haskell.. :D
14:37:39 <floris497> thank you verry much :)
14:37:49 <HeladoDeBrownie> no problem
14:39:08 <orion> Can you import a data constructor for a record type without importing the accessors?
14:40:50 <matthiasgoergens> Hi.  Anyone know anybody from CapitalIQ?
14:41:07 <kess> orion: why would you want to do that?
14:41:51 <orion> kess: In this particular module, all I ever do is create values.
14:42:27 <pavonia> Do you mean export rather than import?
14:42:43 <orion> Sure.
14:43:24 <pavonia> Have you tried "MyType (MyConstructor)" in the export list?
14:44:29 <orion> pavonia: that did exactly what I want, thank you.
14:44:45 <pavonia> No problem
14:48:29 <ion> Huh, that doesn't export the pattern?
14:48:52 <geekosaur> I think they wanted to avoid the field accessors?
14:49:31 <ion> The pattern still lets you deconstruct it.
14:50:45 <geekosaur> they asked to not import the accessors, not to not import the pattern?
14:51:02 <geekosaur> [19 21:38] <orion> Can you import a data constructor for a record type without importing the accessors?
14:51:11 <geekosaur> note record type
15:00:05 <mniip> hmm, how would I go about comparing numbers represented in binary like
15:00:27 <mniip> data Int = Nil | MinusOne | Zero Int | One Int
15:01:07 <tromp> what is the value of One Int ? 2* Int + 1 ?
15:01:24 <mniip> yes
15:01:40 <mniip> Zero and One are binary digits, Nil is 00000000..., MinusOne is 111111111...
15:02:26 <tromp> then compare them recursively
15:02:51 <mniip> the question is how exactly
15:03:01 <haasn> mniip: I don't even understand how that representation is supposed to work
15:03:07 <haasn> How does it store 5? -3? 10?
15:03:19 <mniip> One (Zero (One Nil))
15:03:24 <mniip> Zero (Zero MinusOne)
15:03:31 <mniip> Zero (One (Zero (One Nil)))
15:03:32 <tromp> good old case distinction...
15:04:00 * hackagebot diagrams-pgf 0.1.0.0 - PGF backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-pgf-0.1.0.0 (BrentYorgey)
15:04:13 <tromp> base cases: cmp Nil MinusOne = GT, ...
15:04:26 <haasn> So MinusOne is like ‚ÄúOne, but the number stops here and is negative‚Äù?
15:04:34 <ski> clearly `-3' must be `(One . Zero) MinusOne' ?
15:05:02 <mniip> haasn, MinusOne means 'preceeded with infinite amount of 1'
15:05:05 <haasn> Wait, that still doesn't make sense. How does one represent -3 in binary, either way?
15:05:17 <mniip> haasn, ...111111111111100
15:05:25 <ski> haasn : two's complement
15:05:36 <mniip> flip that around (00111111111...) and get Zero $ Zero $ MinusOne
15:05:39 <ski> mniip : it should be `...11111101'
15:05:55 <mniip> true
15:05:55 <mniip> my bad
15:06:20 <mniip> Zero $ Zero $ MinusOne is -4, and One $ Zero $ MinusOne is -3
15:06:57 <haasn> mniip: what I would do is writing a recursive routine for turning such a representation into an Int, and then comparing those
15:07:06 <ski> :(
15:07:21 <mniip> unfortunately I can't do that
15:07:39 <haasn> The thing is that your format represents numbers from ‚Äúright to left‚Äù, but comparison proceeds from ‚Äúleft to right‚Äù
15:08:09 <mniip> but proceeding from left to right requires padding
15:08:17 <haasn> so if you want to do it recursively, you'd intuitively have to go all the way to the left and work your way right until you find a difference?
15:08:23 <uwap> wait. isn't return a coalgebra or am I missing something? 
15:09:19 <shachaf> It's a family of coalgebras, since it's polymorphic.
15:09:41 <uwap> ohhh. yeah. right
15:10:44 <shachaf> But I'm not sure how useful that idea is.
15:12:50 <uwap> shachaf, me neither. probably not too much. 
15:14:44 <haasn> mniip: so apart from the base cases, you'd need something like this? cmp (One x) (Zero y) = case cmp x y of EQ -> GT; o -> o
15:15:07 <mniip> hmm
15:15:15 <mniip> that sounds better than what I'm writing
15:15:30 <haasn> Maybe you could approach it like this: generate a list of Orderings, one for each position
15:15:39 <haasn> And then go through this list backwards and find the first one that isn't EQ
15:15:59 <haasn> (To avoid having to explicitly write out every single combination of cases)
15:16:52 <haasn> mniip: You could even try to approach it like this: Start with ‚ÄòEQ‚Äô at the beginning
15:17:13 <haasn> mniip: Whenever there's a mismatch, set it to ‚ÄòGT‚Äô or ‚ÄòLT‚Äô. When you reach the end, return that
15:17:13 <mniip> something bothers me about 'case cmp x y of EQ -> GT; o -> o'
15:17:31 <mniip> that's basically < (or >=)
15:17:46 <haasn> mniip: Well, if you have xxxx1... and yyyy0..., then the first number is greater than the second IFF xxxx=yyyy. If there's a difference before that, it's irrelevant
15:17:47 <mniip> !
15:17:58 <haasn> sorry, not IFF, just if
15:18:29 <haasn> mniip: But thinking about my idea again; you can indeed approach it like this:
15:19:05 <haasn> comp x y = go x y EQ; where go (One x) (Zero y) _ = go x y GT; go (One x) (One y) c = go x y c
15:19:15 <haasn> -- similar for the other two cases (Zero/One and Zero/Zero)
15:19:51 <haasn> and then for the base cases: go Nil Nil c = c; go MinusOne MinusOne c = c
15:20:41 <haasn> Hmm. There's still the issue of comparing  foo Nil with foo (Zero MinusOne)
15:21:11 <haasn> But I'm sure you'll figure something out to cover the case (compare the signs or something)
15:22:31 <haasn> intuitively, this is just the list idea, except instead of getting the ‚Äúlast value‚Äù manually, you're doing it in-place, using something equivalent to the Last monoid (with EQ as the identity)
15:22:46 <haasn> That way you avoid any unnecessary list construction
15:29:01 * hackagebot pell 0.1.0.0 - Package to solve the Generalized Pell Equation.  http://hackage.haskell.org/package/pell-0.1.0.0 (lbrunjes)
15:29:22 <mniip> damn
15:29:30 <mniip> ghc updates broke my type lambdas!
15:29:39 <mniip> that's not fair
15:48:38 <lpaste> mniip pasted ‚ÄúType lambdas‚Äù at http://lpaste.net/130994
15:48:59 <mniip> works in 7.4.1, doesn't in 7.8.4
15:49:19 <calef13> hello, can anyone telle me what the name of the Distribution.TestSuite package is for cabal install? I can't find it using cabal list for some reason
15:49:33 <mniip> I'm guessing I need more extensions?
15:50:17 <dcoutts> calef13: Cabal
15:51:05 <tar_> something compiled!
15:51:25 <derekv> what I think I want to say : "type (Eq x) => FreqCount x = [(Int, x)]" ... but its not legal  
15:51:25 <glguy> calef13: You can find information like this using the ghc-pkg command: ghc-pkg find-module Distribution.TestSuite
15:51:53 <calef13> glguy: ah ok thanks very much!
15:53:44 <mniip> derekv, RankNTypes
15:53:49 <mniip> type FreqCount x = (Eq x) => [(Int, x)]
15:55:07 <shachaf> That's almost certainly not the right answer.
15:55:17 <mniip> yeah
15:55:37 <mniip> you should constrain functions, not datatypes
15:56:23 <derekv> ok
15:56:52 <derekv> it seemed to make sense to me that if I was going to call it FreqCount that the item would need to be Eq
15:56:56 <pavonia> mniip: What is your Lambda supposed to do? Is it like a type-level flip?
15:57:14 <derekv> I'll forget it for now
15:57:21 <mniip> pavonia, a type-level \->
15:58:09 <pavonia> I don't understand its signature
15:58:37 <mniip> Compose a b = \z -> a (b z)
15:59:14 <pavonia> I mean Lambda
15:59:45 <dfeuer> Lambda vs. lambda: cage match!
15:59:46 <mniip> rewritten in constraints, it looks like (b z x, a z y) => Compose a b (\z -> y)
16:00:07 <mniip> er
16:00:11 <dfeuer> ...
16:00:25 <mniip> rewritten in constraints, it looks like (b y x, a z y) => Compose a b (\z -> x)
16:01:03 <dfeuer> mniip, what Compose is that?
16:01:11 <mniip> hm?
16:01:35 <dfeuer> I just stepped in, and do not understand how one composes things of kind *->*->Constraint
16:01:42 <dfeuer> Or...
16:01:51 <mniip> dfeuer, are you familiar with prolog
16:01:53 * ski doesn't think it makes that much sense to think of it as `\z -> x' here
16:01:55 <dfeuer> I should say ...   a->b->Constraint, for any particular a or b.
16:02:07 * dfeuer is not familiar with Prolog.
16:02:38 <mniip> in 'class F x y | x -> y', x is the argument and y is the result
16:02:53 <mniip> obviously
16:03:04 <ski> dfeuer : yes, it could be polymorphic
16:03:30 <pavonia> mniip: What is the third parameter of Lambda?
16:03:58 <mniip> Compose's last argument (r) is of kind *->*->Constraint
16:04:03 * hackagebot simtreelo 0.1.1.0 - Loader for data organized in a tree  http://hackage.haskell.org/package/simtreelo-0.1.1.0 (mgmillani)
16:04:04 <mniip> the first * is the third argument of Lambda
16:05:01 <pavonia> But what is it semantically?
16:05:32 <mniip> uh
16:05:40 <ski> hmm .. actually that `a b -> r' FD on `Compose a b r' makes it strange, i think
16:06:04 <ski> (or rather, that in conjunction with the instance)
16:06:15 <mniip> pavonia, Lambda introduces two 'pipes', r-s and a-b
16:06:37 <ski> mniip : if there's a Prolog correspondent to this, i think it would be interesting to compare
16:06:48 <mniip> prolog equivalent to Lambda?
16:07:07 <hakujin> thoughts on long term readability of `maybe` versus `case x of` with short functions? e.g. `maybe (left "failed") return (decode x)`
16:07:11 <ski> it and `Compare', yes
16:07:27 <ski> (however, you can't enforce the FDs in Prolog. Mercury could possibly do it, though)
16:07:59 <mniip> Prolog has no partial application, but consider
16:08:11 <mniip> Lambda(X, Y, Y, X).
16:08:15 <ski> (you can fake partial application in Prolog)
16:08:31 * ski also isn't sure why that is called "Lambda"
16:09:11 <mniip> Compose(F, G, Lambda(X, Z)) :- F(Y, X), G(Z, Y).
16:09:33 <mniip> ski, originally it was called <~ but 7.4 struggles with TypeOperators
16:09:46 <ski> mniip : i meant, if you already had something in Prolog, that you were trying to express in type classes in Haskell. i can translate your given type classes and instances to Prolog just fine, but that doesn't help me understand what you're trying to do
16:10:37 <mniip> if we consider k->l->Constraint a function k->l
16:10:47 <mniip> then I'm trying to implement composition of such functions
16:10:52 <mniip> as a such function itself
16:11:01 <mniip> and it even works in 7.4
16:11:06 <mniip> but not in some later version
16:11:23 <ski> mapping inputs to a single output relation is different from mapping inputs to many output relations, each of which contains only a single tuple
16:11:42 <mniip> Composition maps 2 inputs to one output
16:11:44 <ski> (you are doing the latter. maybe you meant to do the former ?)
16:12:08 <mniip> in what way am I doing the latter
16:12:37 <augur_> hello everyone!
16:12:39 <augur_> hello ski :)
16:12:42 <ski> let's consider a simple example. say the domain is `{0,1,2}'
16:12:48 <ski> hello augur_
16:12:49 <augur_> ski! i invented a thing!
16:13:25 <augur_> ski: http://lpaste.net/130905
16:13:37 * ski wonders whether to use the Haskell or the Prolog variable names ..
16:13:48 <mniip> ski, I see what you're trying to say
16:14:08 <mniip> k->l->Constraint is not any random typeclass
16:14:16 <mniip> it's a typeclass where l is fundepped to k
16:14:42 <mniip> and thus k->l->Composition and k->l are isomorphic
16:15:16 <ski> mniip : `instance (b x y, a y z) => Compose a b (Lambda z x)' says (informally speaking) that for any particular tuples `(x,y)' and `(y,z)' that happen to be in `b' and `a' (respectively), `Compose' can relate `a' and `b' to the *singleton* relation that only contains the tuple `(x,z)'
16:16:01 <ski> mniip : but if there's many tuples in `a' and `b', that match on a common `y' as above, then `Compose' will relate `a' and `b' to *many* such singleton relations
16:16:21 <mniip> that's impossible
16:16:43 <ski> your FD `a b -> r' contradicts it
16:16:54 <mniip> for any specific y, there(y, z)
16:16:59 <mniip> for any specific y, there's only one (y, z)
16:17:06 <mniip> in a, anyway
16:17:30 <ski> mniip : i don't see how that is enforced in your code snippet
16:17:39 <mniip> it isn't
16:17:45 <mniip> it is implied
16:17:53 <ski> implied by ?
16:18:40 <mniip> it's supposed to fail at use site if the typeclass isn't fundepped correctly
16:18:48 <ski> mhm
16:19:47 <ski> (also, i don't see how "for any specific y, there's only one (y, z)","in a, anyway" would contradict what i said)
16:20:25 <Zemyla_> Hmm, would it be possible to have had MonadIO declared using a default signature so that the default definition of liftIO is lift . liftIO?
16:20:56 <ski> say `(1,0)' is in `a' and `(2,1)' is in `b'. then `Compose' will relate `a' and `b' to a singleton relation containing `(2,0)'
16:21:13 <mniip> correct
16:21:20 <ski> additionally, say `(4,3)' is in `a' and `(5,4)' is in `b'. then `Compose' will also relate `a' and `b' to a singleton relation containing `(5,3)'
16:21:47 <ski> which of course contradicts the FD `a b -> r' on `Compose a b r'
16:21:49 <mniip> not sure if incorrect or informal,
16:22:03 <mniip> but Compose will return a relation containing both (2,0) and (5,3)
16:22:12 <ski> no
16:22:17 <mniip> yes?
16:22:20 <ski> <ski> mapping inputs to a single output relation is different from mapping inputs to many output relations, each of which contains only a single tuple
16:22:50 <mniip> Compose does the former
16:23:00 <ski> `{{(2,0)},{(5,3)}}' is not the same as `{{(2,0),(5,3)}}'
16:23:30 <mniip> again Compose returns a single relation for any given a and b
16:24:04 * hackagebot zlib 0.6.0.1 - Compression and decompression in the gzip and zlib formats  http://hackage.haskell.org/package/zlib-0.6.0.1 (DuncanCoutts)
16:24:22 <ski> assuming the instance for `Lambda' is to be the only instance for it, the relation `Lambda z x' is the singleton relation `{(x,y)}'
16:24:32 <mniip> there can't be another instance for Lambda
16:24:36 * ski nods
16:25:00 <mniip> not really no
16:25:48 <mniip> Lambda z x, is a relation containing all pairs of z and x, which fit into the constraint that happens to be around the Lambda
16:27:06 <mniip> (Foo x y) => Lambda y x
16:27:09 <mniip> is equivalent to Foo
16:27:14 <ski> there is only one pair of `z' and `x'. `(x,z)' in the notation i used above
16:27:33 <mniip> then you are incorrect!
16:27:51 <mniip> hm, the exclamation mark was a tad bit too much
16:28:00 <ski> let's try substituting some concrete values for your variables
16:28:17 <ski> "Lambda 2 0, is a relation containing all pairs of 2 and 0, which fit into the constraint that happens to be around the Lambda"
16:28:31 <ski> clearly "all pairs of 2 and 0" is just a single pair
16:28:33 <mniip> yeah
16:29:07 <ski> so, for each `z' and `y', `Lambda z x' is the singleton relation containing just the pair `(x,z)'
16:29:14 <mniip> no?
16:29:38 <mniip> well if you substitute z and y with concrete values
16:30:00 <ski> `z' and `y' already stand for some particular values (whether known yet or not doesn't matter)
16:30:16 <mniip> true, but they're free variables
16:30:21 <ski> yes
16:30:32 <mniip> hold on
16:30:37 <ski>   instance (b x y, a y z) => Compose a b (Lambda z x)
16:31:06 <ski> means that we're claiming `forall a b. forall x y z. ((b x y,a y z) => Compose a b (Lambda z x))'
16:32:26 <ski> so (for each relation `a' and `b' and) for each particular values for `x',`y',`z', provided `(x,y)' is in `b' and `(y,z)' is in `a', `Compose' is to relate `a' and `b' to the relation `Lambda z x'
16:33:06 <ski> for each particular `x' and `z', the relation `Lambda z x' consists solely of the pair `(x,z)'
16:33:30 <ski> (i hope you agree at least will all but the last of those)
16:34:04 * hackagebot HaskellNet-SSL 0.3.0.0 - Helpers to connect to SSL/TLS mail servers with HaskellNet  http://hackage.haskell.org/package/HaskellNet-SSL-0.3.0.0 (DanielWright)
16:34:06 <mniip> first check
16:34:15 <mniip> second check
16:34:25 <mniip> third check
16:34:46 <mniip> although in the first, "Lambda z x" does not have /particular/ x and z
16:34:53 <mniip> they're free
16:34:59 <ski> it doesn't matter
16:35:29 <ski> in `x + 1', `x' isn't somehow a set of numbers, it's a single number, regardless of whether we actually know it yet or not
16:36:08 <lpaste> mniip pasted ‚ÄúNo title‚Äù at http://lpaste.net/130998
16:36:10 <mniip> consider this
16:36:31 <mniip> notice the argument order for Lambda is a tad bit different
16:36:49 * ski noticed
16:37:41 <mniip> you are correct, for any concrete value of x, "Lambda x x" is a relation of one element: (x, x)
16:37:43 <mniip> but x is free
16:38:19 <mniip> and "Lambda x x" is a relation consisting of all pairs with equal elements
16:38:26 <ski> no
16:38:34 <mniip> how no
16:38:40 <ski> i can give you some Prolog code, if you want to
16:39:12 <mniip> I can fire up ghci and it works
16:40:02 <mniip> also I'm curious how to emulate partial application in prolog
16:40:34 <ski>   graph(Rel,Graph) :- findall((X,Y),( call(Rel,X,Y) ),Graph).
16:40:37 <ski>   lambda(R,A,A,R).
16:41:22 <ski>   compose(A,B,lambda(Z,X)) :- call(B,X,Y),call(A,Y,Z).
16:41:47 <ski> graph/2 is just to be able to collect all the pairs in a relation, so that we can view the output
16:41:55 <ski> some test relations :
16:42:06 * mniip fires up prolog
16:42:33 <ski>   b(0,1). b(3,4).
16:42:49 <ski>   a(1,2). a(4,5).
16:42:53 <ski> and then try
16:43:21 <ski>   ?- compose(a,b,Rel),graph(Rel,Graph).
16:43:29 <ski> (and press `;' to see all solutions)
16:43:41 <SrPx> > let typeof = (\ a b -> b) :: a -> a -> a in typeOf "hi" _
16:43:42 <lambdabot>      Couldn't match expected type ‚Äòt0 -> t‚Äô with actual type ‚ÄòTypeRep‚Äô
16:43:42 <lambdabot>      The function ‚ÄòtypeOf‚Äô is applied to two arguments,
16:43:42 <lambdabot>      but its type ‚Äò[Char] -> TypeRep‚Äô has only one
16:43:57 <ski> if you're correct, then there will be just one solution for `Graph', that includes multiple pairs
16:43:57 <SrPx> > let typeOf = (\ a b -> b) :: a -> a -> a in typeOf "hi" _
16:43:58 <lambdabot>      Found hole ‚Äò_‚Äô with type: [Char]
16:43:58 <lambdabot>      Relevant bindings include
16:43:58 <lambdabot>        typeOf :: forall a. a -> a -> a (bound at <interactive>:1:5)
16:44:16 <SrPx> is that the best way to do it? sorry for getting it wrong
16:44:17 <ski> if i'm correct, there will be multiple solutions for `Graph', that each includes just a single pair
16:44:53 * ski tries it in Prolog now
16:45:22 <ski> (.. and, the result is exactly what i expected)
16:45:31 <mniip> ski, id(A, R) :- lambda(X, X, A, R).
16:45:32 <mniip> correct?
16:45:53 <ski> mniip : is that using the old or the new lambda/4 ?
16:46:01 <ski> (i used the old, above. per your original paste)
16:46:05 <mniip> doesn't matter reallyt
16:46:10 <SrPx> ah I can just do `[myValue, _]`
16:46:20 <mniip> I used yours
16:46:21 <mniip> aka old
16:46:53 <ski> mniip : that `id(A, R) :- lambda(X, X, A, R).' can then be logically simplified to just `id(X,X).'
16:46:59 <mniip> yes
16:47:22 <mniip> but lambda is for cases where it can't be logically simplified
16:47:30 <mniip> but look, ?- graph(id,Graph).
16:47:30 <mniip> Graph = [ (_G2714, _G2714)].
16:47:41 <mniip> "one" pair, as you call it, 
16:47:47 <mniip> but id works as it's supposed to
16:48:01 <ski> hm, actually `id' (conceptually) doesn't contain just one pair
16:48:32 <mniip> in fact 'id2(X, X).' produces a similar graph
16:48:54 <mniip> free variables I'm telling ya
16:48:58 <ski> (it's just that findall/3 arguably (in a logical sense) behaves strangely, when the predicate doesn't fully instantiate the arguments)
16:49:55 <mniip> okay here's an analogy
16:50:00 <ski> if we were restricting outselves to the domain `{0,1,2,3,4,5}', then `id(X,X).' would be logically equivalent to `id(X,X) :- domain(X).', where
16:50:11 <mniip> for any given t, there are plenty of functions t -> t
16:50:15 <ski>   domain(0). domain(1). domain(2). domain(3). domain(4). domain(5).
16:50:17 <mniip> but forall t. t -> t is only one
16:50:41 <ski> and if you try `?- graph(id,Graph).' for that version of id/2, you'll find you'll get six pairs
16:51:01 <ski> mniip : mhm ?
16:51:29 <mniip> ok, 6 pairs
16:51:41 <ski> (strictly speaking `forall t. t -> t' isn't a type of functions. it probably doesn't matter here, though)
16:53:43 <mniip> correct, id produces one graph and compose(id, id) produces six
16:53:56 <mniip> but compose works as expected
16:54:08 <mniip> ?- compose(id, id, Rel), call(Rel, 1, X).
16:54:09 <lambdabot> Maybe you meant: v @ ? .
16:54:09 <mniip> X = 1
16:55:25 <ski> that particular use of it works as expected
16:55:42 <derekv> nice
16:55:58 <mniip> where's the difference between one relation with 6 possible pairs, and 6 possible relations with 1 pair each
16:56:19 <derekv> so the most frequent word pairing in Alice In Wonderland is "mock turtle", followed by "march hare", "white rabbit"...
16:56:26 <mniip> emphasis on the work "possible"
16:56:34 <derekv> need to filter out "project gutenbergtm" lol
16:56:45 <mniip> word*
16:56:56 <ski> (and will also work as you expect, if you use a/2 and b/2, instead of id/2. however, it's still not relational composition, since `A' and `B' doesn't functionally determine `R' in `compose(A,B,R)')
16:57:09 * ski tries to think of another way to explain this ..
16:57:28 <mniip> hmm
16:57:46 <mniip> yeah there comes the difference
16:57:52 <mniip> fundeps
16:58:01 <ski> mniip : if you immediatelly call the composed relation directly after constructing it (and doesn't do anything else with it), then there's no observable difference
16:58:43 <ski> the failure of the FD is only a symptom of the problem (if your goal was to express relational composition)
16:59:04 <Ryanar> !uptime
16:59:08 <lpaste> derekv pasted ‚Äúfind word pairs‚Äù at http://lpaste.net/131001
16:59:12 <mniip> do you have a better idea about how to implement this?
16:59:27 <mniip> also what kind of magic does ghc do to accept the instance
16:59:34 <Ryanar> > uptime
16:59:35 <lambdabot>  Not in scope: ‚Äòuptime‚Äô
16:59:37 <Ryanar> ~uptime
17:00:00 <ski> Ryanar : try `/msg lambdabot @uptime'
17:00:10 <Ryanar> ah thanks
17:00:14 <Ryanar> yeah shoulda messaged my bad
17:00:34 <mniip> 7.6.3
17:00:41 <mniip> 7.6.3 takes it without any complaints
17:00:54 <Welkin> Ryanar: you missed an 'i'
17:00:57 <derekv> my solution is rather ugly... what route should I go to clean it up?  use Data.Map? 
17:01:08 <ski> i'm not quite sure why it's accepted in one version, and not in another
17:01:21 <Ryanar> Welkin, huh?
17:01:35 <Welkin> Ryanar: shady airline companies now use haskell!
17:01:41 <heatsink> derekv: I would start by giving names to some intermediate variables
17:01:53 <Ryanar> I am totally lost
17:01:57 * mniip lends Ryanar an i
17:02:15 <Welkin> Ryanar: of course you are! You are the cheap flight provider for europe
17:02:26 <ski> mniip : if you want to express it as `Compose a b r', where `r' is to be the composed relation of `a' and `b', then logically you want `forall x y z. (b x y,a y z) => r x z' to hold
17:02:35 <Ryanar> Welkin, I don't get it
17:02:35 <dmwit> derekv: You might like the multiset package.
17:02:43 <derekv> heatsink: yea good call
17:02:47 <mniip> ski, pretty much
17:03:02 <pavonia> Ryanar: They are making puns on your nick name
17:03:05 <dmwit> derekv: fromList :: (String, String) -> MultiSet (String, String), where Multiset a is roughly Map a Int.
17:03:09 <ski> mniip : you'd really also want the other direction, `forall x y z. (b x y,a y z) <= r x z' to hold, so `forall x y z. (b x y,a y z) <=> r x z' in total
17:03:16 <Ryanar> ohhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
17:03:19 <Ryanar> Ryanair
17:03:28 <dmwit> derekv: So fromList would cover lines 8-12 of your code.
17:03:33 <Ryanar> no association =X
17:03:40 <srhb> Ryanar: Good, good... :-)
17:03:40 <Ryanar> didn't know they existed until just now
17:03:56 <mniip> ski, true
17:04:02 <Ryanar> I thought you were saying my spelling of "uptime" was missing an 'i' and I was very confused
17:04:05 * hackagebot zlib 0.6.1.0 - Compression and decompression in the gzip and zlib formats  http://hackage.haskell.org/package/zlib-0.6.1.0 (DuncanCoutts)
17:04:25 <derekv> dmwit: I actually started with MultiSet, got lost somewhere, forgot about it, ended up with this
17:04:28 <mniip> just to make sure, you're not implying a r -> b, r b -> a, or anything of that nature?
17:04:35 <ski> mniip : this would suggest `instance (forall x y z. (b x y,a y z) <=> r x z) => Compose a b r' (or, if we're content with only requiring that the composed relation of `a' and `b' is contained *in* `r' : `instance (forall x y z. (b x y,a y z) => r x z) => Compose a b r')
17:05:08 <ski> mniip : however, afaik, we can express neither of these in the current state of the type class system
17:05:10 <mniip> ski, and the typechecker will handle that how?
17:05:14 <mniip> oh
17:05:24 <ski> (it's simply syntax error)
17:05:46 <heatsink> derekv: On lines 10-11, you have map (groupBy (==) `on` snd) . groupBy ((==) `on` fst).  Isn't that the same as map (groupBy (==)) . groupBy ((==) `on` fst) ?
17:05:47 <ski> mniip : another approach would be instead to let `Compose' be a function so that `Compose a b' would *be* the composed relation `r'
17:05:59 <mniip> ski, also in order for the fundep to hold, a and b should also have quite specific fundeps
17:06:12 <mniip> which means we need... fundep signatures!
17:06:53 <Ryanar> @uptime
17:06:53 <lambdabot> uptime: 4d 33s, longest uptime: 1m 10d 23h 44m 29s
17:07:00 <dmwit> derekv: Or if you're more ambitious, perhaps you could use something like a priority search queue.
17:07:02 <ski> mniip : yes, that's another problem (such stuff can be expressed in Mercury, though)
17:07:05 <ski> mniip : with this, you could say `instance (b x y,a y z) => Compose a b x z'. here `Compose :: (* -> * -> Constraint) -> (* -> * -> Constraint) -> (* -> * -> Constraint)'
17:07:06 <Ryanar> is longest uptime broken? 
17:07:09 <dmwit> derekv: e.g. http://hackage.haskell.org/package/PSQueue-1.1/docs/Data-PSQueue.html
17:07:24 <derekv> heatsink yea probably, i was thinking procedurally looks like =P
17:07:26 <Ryanar> probably means 1y 10d 23h 44m 29s?
17:07:26 <dmwit> Ryanar: What makes you think it's broken?
17:07:33 <mniip> Compose ((k -> l) => f :: k -> l -> Constraint) ((m -> k) => g :: m -> k -> Constraint) ((m -> l) => r :: m -> l -> Constraint)
17:07:40 <Ryanar> 1 month
17:07:41 <Welkin> 1 millenia
17:07:48 <Ryanar> I guess that makes sense
17:07:49 <dmwit> Ryanar: I wouldn't be surprised to find out \bot has never been up for more than a month in a row.
17:07:52 <Ryanar> confusing to have 2 definitions of m
17:08:00 <Welkin> miles and meters!
17:08:15 <Ryanar> well that is two different systems
17:08:18 <Ryanar> us and metric
17:08:20 <Ryanar> this is time
17:08:22 <Ryanar> :P
17:08:24 <Welkin> imperial and metric
17:08:42 <Welkin> it came from britain to the US, then britain abandoned it for metric
17:08:42 <heatsink> derekv: Are you trying to list the 15 most common word pairs?
17:08:59 <Ryanar> yeah so I call it US because we are like the only country that still uses it
17:09:01 <mniip> Ryanar, obviously that's 1 meson
17:09:04 <ClaudiusMaximus> derekv: map (\l -> (l !! 0, l !! 1)) . filter (\l -> length l >= 2) . tails $ foo   -- this has nasty complexity (O(n^2) i think), better would be   [ (a, b) | a:b:_ <- tails foo ]
17:09:18 <Ryanar> if its month maybe 1mo 10d?
17:09:20 <dmwit> derekv: Why would it have nasty complexity?
17:09:24 <dmwit> ClaudiusMaximus: You, I mean.
17:09:25 <Ryanar> maybe you can only have 1 character
17:09:40 <izgzhen> Did someone know what does "import {-# SOURCE #-} XXX" means? This is from a "hsc" file 
17:09:40 <dmwit> ...oh, the call to length.
17:09:41 <dmwit> Yeah.
17:10:00 <derekv> ClaudiusMaximus: not sure, but I was very suspicious of that bit of code
17:10:04 <ski> mniip : not knowing why you're defining this `Compose', i'd try using the functional version of it ^ instead of a relational version
17:10:15 <dmwit> Use genericLength and a lazy nat. ;-)
17:10:16 <mniip> I'll try
17:10:41 <derekv> heatsink actually i'm trying to build a list of word pair frequencies,so that using it I can generate random text =]
17:11:17 <mniip> ski, any idea why 'type Free (a :: k -> Constraint) = a b => b' also stopped working
17:11:21 <derekv> "random" text... a gibberish bot 
17:11:51 <Ryanar> :quit
17:12:14 <Ryanar> wrong channel!
17:12:55 <mniip> ah right
17:12:59 <mniip> kind too generic
17:13:03 <tar_> is there any way for me to use foo from bar in this example? http://pastie.org/10102199
17:13:28 <mniip> tar_, constrain it with Monad m
17:13:36 <heatsink> derekv: Word pair frequencies would be a Map (String, String) Int, or equivalently a Map String (Map String Int)
17:13:44 <mniip> (which is what ghc would probably suggest you)
17:13:47 <Cale> mniip: hm? That won't help.
17:13:51 <dmwit> izgzhen: Hrm. I think {-# SOURCE #-} is an hs-boot thing.
17:14:03 <heatsink> derekv: If you generate a list of all word pairs, you can create the frequencies with a fold.
17:14:07 <mniip> oh right
17:14:07 <dmwit> izgzhen: See https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate-compilation.html#mutual-recursion for details.
17:14:15 * mniip smacks himself
17:14:20 <Cale> foo :: StateT a (MaybeT IO) Int. If bar is to be equal to foo, it must be a further specialisation of that type.
17:14:26 <Cale> (or the same type)
17:14:27 <tar_> mniip: like http://pastie.org/10102203 ? same thing :\
17:14:37 <mniip> tar_, you can only use bar in foo
17:14:39 <mniip> not vice versa
17:14:56 <Cale> tar_: You can't define something to be equal to something else, but with a more general type
17:14:58 <mniip> foo only knows how to operate on MaybeT, bar advertises that it knows how to operate on all monads
17:15:08 <izgzhen> dmwit: Thank a lot!
17:15:10 <mniip> or, all m for that matter
17:15:44 <tar_> I was hoping there was some way for me to unwrap the Maybe
17:16:00 <Cale> tar_: For example, if I define x = [1,2,3,4], I'm not allowed to define y :: [a]; y = x
17:16:06 <tar_> I got the IO out with a MonadIO constraint
17:16:21 <derekv> oh this is odd, i converted to use the MultiSet, and i got different output
17:16:31 <tar_> hmm
17:16:37 <mniip> tar_, MaybeT IO is a concrete type
17:16:39 <derekv> "said the" is now the most common word, "mock turtle" is the 15th
17:16:42 <Cale> tar_: Well, you could change the type signature of foo
17:16:57 <tar_> I guess that is what I'm doing, hm. :)
17:16:59 <mniip> haskell instances are generally an open world, no amount of constraints will make m equal to that
17:16:59 <Cale> tar_: foo :: (Num a, Monad m) => m a
17:17:12 <ski> mniip : note that `instance (b x y,a y z) => Compose a b x z' in terms of Prolog would be `compose(A,B,X,Z) :- call(B,X,Y),call(A,Y,Z).', which logically means `all [A,B,X,Y,Z] ( compose(A,B)(X,Z) <= B(X,Y),A(Y,Z) )', which is equivalent to `all [A,B,X,Z] ( compose(A,B)(X,Z) <= some [Y] ( B(X,Y),A(Y,Z) ) )' ..
17:17:27 <ski> mniip : .. which under CWA becomes `all [A,B,X,Z] ( compose(A,B)(X,Z) <=> some [Y] ( B(X,Y),A(Y,Z) ) )', which is equivalent to `all [A,B,R] ( compose(A,B) = R <=> all [X,Z] ( R(X,Z) <=> some [Y] ( B(X,Y),A(Y,Z) ) ) )', or, using set comprehension syntax, `all [A,B] ( compose(A,B) = {(X,Z) | some [Y] ( B(X,Y),A(Y,Z) )} )'
17:17:35 <dmwit> derekv: Is it possible that there are many pairings of exactly equal frequency that are simply coming out in a different order...?
17:17:45 <dmwit> derekv: Seems unlikely, I guess.
17:18:29 <derekv> no, mock turtle got 55 before, 56 now
17:18:33 <derekv> but "said the" got 211
17:18:40 <ski> (just using Prolog syntax there, because i wanted to go via CWA. i could have changed to other logical syntax after that)
17:18:52 <derekv> not sure but "said the" having 211 makes sense
17:19:44 <ski> mniip : yes, in `a b => b', `b' occuring to the right of `=>' forces `b :: *', and so `k = *'
17:20:15 <tar_> Should I use Maybe instead of MaybeT? http://pastie.org/10102209 I use MaybeT's early termination behavior internally, but perhaps I shouldn't propagate that out of the function
17:20:33 <faux___> my function needs to create a .png file as a side effect. its primary purpose is to return a string. i have tried adding "where _ = generatePng". however, no png is generated. I guess that this command is skipped. How can I get this function to create the png? Thanks
17:20:53 <dmwit> tar_: How about using MonadState and MonadError instead?
17:21:07 <srhb>  faux___ Generally you'll use generatePng >> return theString
17:21:14 <ski> Haskell implementations are typically lazy, won't do more work than they think they're required to
17:21:24 <dmwit> tar_: foo :: (MonadState a m, MonadError String m, MonadIO m) => m String -- or whatever
17:21:40 <faux___> srhb: is >> an operator?
17:21:40 <heatsink> faux___: is generatePng an IO action?
17:21:45 <faux___> heatsink: yes
17:21:46 <srhb> faux___: Yes.
17:21:47 <ski> using `_ = generatePng' indicates that the result is not being used, and so an implementation will probably not do the work
17:21:50 <tar_> dmwit: bar would also need MonadError, right?
17:22:08 <srhb> faux___: Meaning do the left action, discard its result, then do right action and return its result
17:22:09 <ski> faux___ : `>>' is monadic sequencing
17:22:18 <dmwit> tar_: bar's type must be at least as specific as foo's, naturally.
17:22:22 <faux___> okay thanks. i'm familiar with >>=
17:22:26 <mniip> ski, one problem with functional approach is that we're limited to * in the result
17:22:31 <srhb> faux___: >> is just >>= \_ -> ...
17:22:33 <tar_> got it
17:22:39 <ski> @src >>
17:22:39 <lambdabot> m >> k = m >>= \_ -> k
17:22:44 <faux___> srhb: that's a good explanation. thanks
17:22:51 <mniip> I assume you meant type Compose (a :: l -> m -> Constraint) (b :: k -> l -> Constraint) (c :: k) = (b c d, a d r) => r
17:23:09 <mniip> here m ~ *
17:23:17 <ski> mniip : no
17:23:51 <ski> <ski> mniip : with this, you could say `instance (b x y,a y z) => Compose a b x z'. here `Compose :: (* -> * -> Constraint) -> (* -> * -> Constraint) -> (* -> * -> Constraint)'
17:23:55 <ski> i meant that
17:24:06 * hackagebot intricacy 0.4.1 - A game of competitive puzzle-design  http://hackage.haskell.org/package/intricacy-0.4.1 (mbays)
17:24:24 <mniip> ski, I fail to see how you got that kind signature
17:24:29 <ClaudiusMaximus> derekv: map (groupBy ((==)`on`snd))  probably won't do what you expect as you only  sortBy (comparing fst) -- replace it with just   sort  and it should work
17:25:03 <ski>   class Compose (a :: * -> * -> Constraint) (b :: * -> * -> Constraint) (x :: *) (y :: *)
17:25:04 <tar_> dmwit: seems weird. I have a function that I want to have the early termination behavior internally, but I want it to bail out of that function, not the caller, and the caller's caller, etc, which I believe it would do if the MonadError constraint went all the way up.
17:25:06 <ski> mniip 
17:25:10 <mniip> yeah that's more like it
17:25:11 <faux___> srhb: generatePng >> return string changes the type of the function
17:25:20 <mniip> not what you origially said
17:25:26 <srhb> faux___: Yes?
17:25:27 <ski> mniip : that gets you `Compose :: (* -> * -> Constraint) -> (* -> * -> Constraint) -> (* -> * -> Constraint)'
17:25:34 <mniip> oh
17:25:38 <faux___> srhb: can i make it just String?
17:25:38 <srhb> faux___: What was its type, and what does it change to?
17:25:40 <mniip> the parentheses
17:25:41 <ski> mniip : which is the same as `Compose :: (* -> * -> Constraint) -> (* -> * -> Constraint) -> * -> * -> Constraint'
17:25:46 <derekv> ClaudiusMaximus: oh good catch, that makes sense
17:25:47 <srhb> faux___: No, not while having IO effects.
17:25:52 <srhb> faux___: That's the whole point, after all.
17:25:55 <dmwit> tar_: You are of course free to monomorphize the MonadError constraint somewhere and "run" the resulting monad transformer.
17:26:08 <dmwit> tar_: e.g. bar = runMaybeT foo
17:26:11 <faux___> srhb: okay i'll have to do redesigning then
17:26:17 <srhb> faux___: Good plan. :) 
17:26:29 <tar_> dmwit: I thought I could do that with StateT a (MaybeT m) Int somehow
17:26:36 <derekv> ClaudiusMaximus: also the list comprehension form did speed it up a lot.  I forgot you could use the list deconstruction for that
17:26:40 <ski> mniip : so instead of `Compose' being a relation that relates three (binary) relations. `Compose' here is a *function* that, when given two (binary) relations, returns a (binary) relation
17:27:06 <dmwit> tar_: It is hard to give good API design advice, period. With the amount of details you've given here, it's damn near impossible.
17:27:10 <mniip> and what would the fundeps on Compose be
17:27:18 <ski> mniip : of course, that is basically the same as saying that `Compose' is a relation that relates two (binary) relations to two elements from the "primary domain" (here `*')
17:27:29 <mniip> a b c -> r fails
17:27:48 <tar_> dmwit: sorry, I tried to make a minimal example.
17:27:50 <ClaudiusMaximus> derekv: the speed up is avoiding the repeated length calls over (n+1) lists of length n, n-1, n-2, ...
17:28:07 <ski> mniip : no fundeps at all, afaiui. if you want to think of it like that, you could say that `a b -> (Compose a b)' already automatically holds (since `Compose' is a function, duh ..)
17:28:20 <dmwit> tar_: Yep, and that's much appreciated. Unfortunately it's not a minimal working example -- it doesn't demonstrate a problem. =P
17:28:33 <ski> mniip : so your earlier `a b -> r' is not automatic, and implicit, in that we're using a function
17:28:48 <ski> mniip : er, s/is not automatic/is now automatic/
17:29:17 * hackagebot boomange 0.1.3.0 - A Bookmarks manager with a HTML generator  http://hackage.haskell.org/package/boomange-0.1.3.0 (mgmillani)
17:29:19 <ClaudiusMaximus> :t M.fromListWith (+) -- derekv, this might simplify counting, no need to sort or group beforehand
17:29:20 <lambdabot> (Num a, Ord k) => [(k, a)] -> M.Map k a
17:30:49 <mniip> ski, are you a wizard
17:30:54 <ClaudiusMaximus> derekv: which i think is what heatsink was suggesting
17:30:59 <ski> not that i know ?
17:31:21 <mniip> I can now use Compose with ~ to implement the /real/ composition and it will even satisfy the fundep
17:31:25 <derekv> ClaudiusMaximus: 1 sec let me post version 2
17:31:33 <dmwit> ClaudiusMaximus: He's already using a proper multiset type.
17:31:39 <ski> mniip : what is "the /real/ composition" ?
17:31:45 <ClaudiusMaximus> dmwit: cool
17:31:56 <mniip> ski, the thing I was implementing originally
17:32:25 <mniip> of kind (k->l->Constraint) -> (m->k->Constraint) -> (m->l->Constraint) -> Constraint
17:32:26 <ski> mhm (i have no idea what that is. i don't believe you've told us ?)
17:32:41 <ski> mniip : oh .. what is the point of that ?
17:32:54 <mniip> it fits in nicely with other things
17:33:08 <ski> .. like ?
17:34:24 <mniip> like all other functions that are k->l->Constraint
17:34:41 <heatsink> derekv: yes, a map can be used to count things like that
17:35:36 <ski> mniip : presumably you're not thinking of stuff like `MonadReader',`MonadState',`MonadWriter',`MonadCont',`MonadError' ?
17:35:47 <mniip> hell no
17:36:11 <mniip> take, for example, class (a + b) r | a b -> r
17:36:22 <lpaste> derekv pasted ‚Äúfind word pairs 2‚Äù at http://lpaste.net/131003
17:37:08 <ski> what's the kind of `a',`b',`r', there ?
17:37:17 <mniip> welllllll it's *
17:37:24 <tar_> dmwit: okay, I think you're right about monomorphization(?). I stacked the transformers the wrong way. The inner function needed MaybeT and I put it on the inside instead of the outside.
17:37:46 <tar_> err, at the bottom instead of the top
17:38:51 <ski> mniip : i'm wondering about what some particular use of `Compose' would be ..
17:39:05 <mniip> I haven't come up with one yet
17:39:15 <mniip> will keep you updated
17:39:19 <ski> i see
17:39:21 <augur_> ski: did you see my lpaste? x3
17:39:34 <mniip> ski, any suggestion for an alternative name for (.)
17:39:52 <augur_> mniip: "after" is a common alternative
17:39:54 <augur_> f.g = f after g
17:39:57 <mniip> symbolic
17:40:08 <mniip> but something different than a single period
17:40:18 <augur_> oh, a symbol? (<<) isnt bad
17:40:27 <ski> augur_ : i was trying to convince mniip why their original code didn't do what they wanted, and was nonsensical ;)
17:40:30 <augur_> f << g   or   f <<< g
17:40:33 <augur_> ski: :D
17:41:17 <dmwit> derekv: Why the Ord x constraint on sortFrequencies?
17:41:56 <dmwit> derekv: Otherwise I like that you broke out the steps and named them.
17:42:54 <ski> augur_ : saw it now, but i'm not sure what it's for ..
17:43:33 <augur_> ski: it was just an idea -- what if you swapped the "case" part and the non-case parts of a type's intros and elims
17:43:46 <augur_> so the intro binds the case body, and the elim uses it
17:44:15 <augur_> https://twitter.com/psygnisfive/status/589502961774161920/photo/1 << like that, see
17:44:50 <mniip> ski, wait till you see the most nonsensical thing
17:45:12 <augur_> ski: then i thought: functions look like the "co" versions, with a body thing in the intro. so what is "->" the "co" version of?
17:45:25 <mniip> class Undefined r; instance (Undefined (Undefined r)) => Undefined r
17:45:27 <ski> augur_ : `CoF' ?
17:45:38 <augur_> ski: yes, what is F, such that CoF = ->
17:45:47 <augur_> ski: and it turns out, F = Identity  :)
17:46:01 <augur_> not very surprising, but wonderfully subtle and beautiful
17:46:43 <augur_> additionally, there are many definitions that resist co-ization
17:47:03 <augur_> split-pairs admit it, but fst/snd pairs dont
17:47:12 <derekv> dmwit: because I'm going to compare on x?
17:47:27 <dmwit> derekv: You aren't though. You're comparing on frequency.
17:48:02 <ski> mniip :)
17:48:17 <augur_> ski: i just thought it was a really interesting ontology :)
17:48:18 <derekv> dmwit: oh, heh
17:48:22 <derekv> right..
17:48:37 <mniip> if haskell's typechecker is as lazy as it used to be, Undefined works like a type bottom
17:48:52 <mniip> type-errors, but only when resolved
17:48:53 <ski> augur_ : because split-pairs are lefty, probably
17:49:04 <augur_> ski: ?
17:49:15 <ski> left adjoint
17:49:18 * hackagebot boomange 0.1.3.1 - A Bookmarks manager with a HTML generator  http://hackage.haskell.org/package/boomange-0.1.3.1 (mgmillani)
17:49:34 <augur_> ahh, maybe
17:49:48 <augur_> ski: part of the problem is that projective elims like fst/snd have a fixed result type
17:49:55 * ski calls them "left datatypes" after Charity
17:50:05 <augur_> and sometimes these types differ
17:50:46 <augur_> there's no clear way to turn them into intros, because there's no "body" to wrap up
17:50:54 <ski> augur_ : anyway, `CoOr' reminded me of continuation terms
17:51:06 <augur_> ski: they're all very much continuationy
17:51:21 <augur_> CoAnd is basically the continuation of a pair
17:51:35 <augur_> CoAnd(A,B,C) ~ Cont C (A,B)
17:51:41 <augur_> er, no sorry
17:52:01 <augur_> cont is ((A,B) -> C) -> C and doesnt represent continuations but continuized values
17:52:05 <ski> augur_ : i mean stuff like `Gamma | c : A |- Delta', where `c' is a continuation term, `Gamma' is a value variable context, `Delta' is a continuation variable context
17:52:23 <augur_> ski: oh yes like noam's stuff
17:52:29 <ski> noam ?
17:52:32 <augur_> zeilberger
17:52:54 * ski str Curien,Herbelin and some others having some papers on this
17:53:12 <augur_> jonsterling made similar comments. only unlike the continuation term stuff, this has fixed return types, not a "dead" judgment # or whatever people use
17:53:15 <Welkin> oh, I thought of Chomsky
17:53:21 * ski obsessed a bit about it, years ago
17:53:26 <Welkin> his papers/books/talks are great
17:53:44 <augur_> additionally, this sort of connective is just run of the mill boring TT stuff
17:53:55 <augur_> no fancy type theory, its just shuffling around the components
17:54:02 <ski> not sure what you mean by "dead judgement"
17:54:27 <augur_> ski: in Noam's work, you have a judgment that represents not quite contradiction
17:54:53 <davidshore> if I use qAddDependentFile "foo.txt" in a module Foo, changes to foo.txt cause Foo to recompile, but not modules that import Foo
17:54:54 <augur_> just.. not anything. so that you have judgments like    G !- M : #
17:55:11 <davidshore> how can I get ghc to recompile those modules too?
17:55:12 <augur_> # is a type-less judgment
17:55:24 <ski> oh
17:55:44 <ski> augur_ : corresponding to a judgement in logic (not type theory) with zero conclusions ?
17:55:46 <augur_> ski: so in noam's work you have something like this:    G, x : A true !- M : #   ===>   G !- cont(x.M) : A cont
17:55:52 <augur_> which shifts you into a continuation judgment or something
17:55:53 <ski> yes
17:56:05 <augur_> ski: no no # is the conclusion
17:56:14 <augur_> the conclusion means something like "nonsense!"
17:56:24 <ski> is `#' really a type/formula ?
17:56:28 <augur_> no
17:56:31 <augur_> its not a type/formula
17:56:33 <augur_> its a judgment
17:56:37 <ski> then it's what i said :)
17:56:39 <augur_> so just as "A true" is a judgment about A
17:56:44 <augur_> where A is a type/formula
17:56:55 <augur_> "#" is a judgment about.. well nothing in particular (or maybe about the context G)
17:57:04 <augur_> (sort of like G !- ctx is a judgment about G)
17:57:30 <ski> i'd prefer writing it as `G,x : A true |-{M}-'
17:57:44 <augur_> i dont know what that means
17:57:45 <ski> (i also don't like writing that as `G |- ctx')
17:57:52 <augur_> well too bad! :p
17:58:12 <ski> augur_ : well, consider a morphism `m : Gamma >---> Delta'
17:58:26 <augur_> ski: ok
17:58:32 <ski> augur_ : another way of writing this would be `Gamma |-{m}- Delta'
17:58:46 <augur_> oh, instead of   G !- M : D
17:58:49 <augur_> sure
17:58:56 <ski> in this case `Gamma' and `Delta' are both single formulae, and both are *focused*
17:59:21 <augur_> but thats a) category theoretic where you really only have a single judgment -- A true
17:59:37 <augur_> and b) # is not a type
17:59:49 <augur_> its not clear to me what the categorical interpretation of that sort of stuff should be
18:00:21 <ski> in `x : |N,y : |N |- x + y : |N', the focus is on the right (hence we have a value term/expression)
18:00:42 <ski> you can also have multiple conclusions on the right, but then you (usually) only have one formula on the right focused
18:00:52 <ski> (the other represent continuations variables)
18:01:40 <ski> so, you'd get a judgement looking like `Gamma |- e : T | Delta'
18:02:16 <ski> if you instead focus one formula on the left, then you get continuation terms, with a judgement `Gamma | c : T |- Delta'
18:02:23 <augur_> yeah this appears in noam's work
18:03:09 <ski> and you can have a rule that says that if `Gamma | c : T |- Delta', then `Gamma |- cont c : not T | Delta'
18:04:38 <augur_> oh also, similar dead judgments are used in Pfenning's notes on continuation-based classical-logic type theory
18:04:50 <zq> omfrickingod psa: IO [a] necessarily plops the entire [a] into your lap
18:04:51 <augur_> for True Negation too
18:05:05 <ski> you can also have a rule that says that if `Gamma,x : T |-{j}- Delta', then `Gamma | gamma x. j : T |- Delta'- this is a focus rule, that focuses the `T' formula on the left (in this case)
18:05:47 <augur_> ski: his presentation of true negation goes something like..    G, x : A true !- M : contradiction   ===>   G !- not(x.M) : ~A
18:05:52 <augur_> er.. ~A true
18:06:25 * ski can't recall the author of the papers which talked about this atm ..
18:06:35 <ski> (maybe Filinski ?)
18:06:53 <augur_> well, filinski DOES love continuations :)
18:08:15 <ski> there's also some relation to logic programming here, i think (goal-directed proof search and all that9
18:08:19 <ski> )
18:08:41 * ski can't recall the term
18:08:45 <Cale> One thing which came up in ##math today was that if you only have things which look like Gamma |- M:t, with a single typing judgment on the right, then when you go to define the arrows in the term model category, you're forced to do it in a way which doesn't take the sequence into account, so general weakening (where you can add new stuff anywhere) will give you the same models as when you throw in exchange and contrac
18:08:45 <Cale> tion.
18:09:11 <ski> which sequence ?
18:09:25 <Cale> I mean, the order in which things in Gamma occur
18:09:27 <ski> ok
18:10:13 <augur_> ski: thats not true
18:10:22 <ski> Cale : as opposed to giving a substitution as "output" ? or as opposed to multiple alternative conclusions ?
18:10:27 <ski> augur_ : which ?
18:10:45 <Cale> You define the arrows Gamma -> Delta where Delta = (v_1:t_1, ..., v_m:t_m) as m-tuples (M_1,...,M_m) of terms for which you have Gamma |- M_i:t_i for each i
18:11:17 <augur_> or maybe do you mean if your model category cannot have products on the right of arrows?
18:11:38 <Zemyla> Question about continuation monads and codensity.
18:11:55 <augur_> if you mean your model category cant have   f : A*B*C ---> D*E*F   then maybe yeah, that seems plausible
18:12:05 <ski> Cale : *nod* (what i meant by substititions)
18:12:33 <ski> augur_ : still not sure what you're disputing ..
18:12:37 <Zemyla> If Codensity m a = Codensity (forall r. (a -> m r) -> m r), then every operation possible on m is possible on Codensity m, correct?
18:12:45 <augur_> ski: im just clarifying what he means
18:13:11 <Zemyla> So if m is a MonadCont, then Codensity m is a MonadCont. So what would its definition be?
18:13:18 <Cale> So, if you define it that way, weakening and identity let you get projections v_1:t_1, ... v_m:t_m |- v_i:t_i
18:13:21 <augur_> in the logic, G !- M : T  with only one judgment on the RHS doesnt do what Cale described, but if your __models__ cannot have product targets, then thats plausible
18:14:17 <augur_> Cale: weakening being projection on the product, fwiw
18:14:24 <Cale> yes
18:14:44 <Cale> and then because the definition of an arrow only requires you to get *a* term for each of the variables in Delta, you can arrange these however you like
18:14:54 <Cale> You can rearrange your projections
18:15:10 <Cale> So exchange doesn't give you anything extra then
18:15:53 <augur_> Cale: exchange is a byproduct of having a monoidal structure on the category
18:16:04 <Cale> It's not in general though.
18:16:16 <Cale> You can have monoidal categories which are not symmetric monoidal
18:16:32 <augur_> symmetric entails A*B ~ B*A
18:16:38 <Cale> right
18:16:44 <Cale> which isn't always true
18:16:44 <augur_> but for categorical type theory, that's not relevant
18:17:07 * ski . o O ( braided )
18:17:07 <Cale> Well, I'm not sure I'd say that :)
18:17:14 <Cale> It may very well be relevant!
18:17:32 <ski> Zemyla : i'm not sure
18:17:46 <augur_> sorry i should clarify, * being a product is what's usually expected in Categorical T
18:17:47 <augur_> TT
18:18:06 <augur_> but that naturally gives rise to arrows p : A*B -> A  and  p' : A*B -> B
18:18:25 <augur_> which by being a product, produces <p',p> : A*B -> B*A
18:18:45 <Cale> In fact, I realised from that earlier discussion that if we really wanted to put ourselves through some pain, we could also change up our notion of sequences for contexts, using trees instead, so as to support nonassociative bifunctors :)
18:19:06 <augur_> Cale: ive discussed this at length before x3
18:19:11 <Cale> :D
18:19:15 <augur_> Cale: what you REALLY want is to use (generalized) multicategories
18:19:29 <augur_> to avoid conflating structural connectives and type connectives
18:19:38 <Cale> Well, what you really want to use is a matter of which categories you're interested in
18:19:43 <augur_> in the usual presentation, * and -> are intimately connected, for instance
18:19:51 <augur_> CCCs have * and must always
18:20:00 <augur_> but the LC need not have *, for instance
18:20:13 <augur_> its because we conflait  A,B !- C   with   A*B !- C
18:20:24 <augur_> but this is incorrect to do
18:21:05 <augur_> A,B !- C   is an arrow with two domain objects, while A*B is an arrow with one
18:21:16 <Cale> Sure
18:21:42 <augur_> what you want in general is a generalized multicategory where your domain is not just a list, but rather a T, for some monad T
18:22:05 <Cale> The context "," needn't correspond to the categorical product. Dependent type theories make that pretty clear too.
18:22:13 <augur_> righ
18:22:39 <augur_> for categorial grammars, "," can be non-associative, non-commutative, etc
18:22:48 * dfeuer looks up and wonders what all this mathematics is about.
18:23:04 <Cale> dfeuer: Categorical models of type theory
18:23:10 * ski probably want to allow more "heterogenous" contexts ..
18:24:12 <augur_> also Cale, interestingly, structure rules end up existing in a separate domain, most likely, and you get some kind of functorial relationships between the propositional and structural inferences
18:24:14 <Cale> lol, use combinatorial species in place of sequences
18:24:49 <augur_> i think what ends up happening is you do some kind of slicing maybe
18:25:01 <dfeuer> Cale, categorical products are commutative up to isomorphism, though, right?
18:25:07 <Cale> dfeuer: yes
18:25:16 * dfeuer is way out of his depth here though.
18:25:48 <dfeuer> So how do you not have A*B~B*A? Is this ~ something stronger than isomorphism?
18:26:25 <ski> (on another note, i think the following explanation of the cut rule is interesting : if, for every way of partitioning the set `Chi' into `Chi0' and `Chi1', `Gamma,Chi0 |- Chi1,Delta' holds, then `Gamma |- Delta' holds)
18:26:26 <Cale> dfeuer: The setup we were originally discussing was one that really did intend to have the sequences of variables correspond to categorical products
18:26:32 <shachaf> Zemyla: What do you man by "every operation possible on m is possible on Codensity m"?
18:26:36 <ski> (consider `Chi' a singleton set, to recover the usual cut)
18:26:41 <dfeuer> o.O
18:27:02 <Cale> dfeuer: It's just that if you try to generalise it by removing some of the rules, and you're not careful, you don't get all the generality you might've hoped for
18:27:32 <dfeuer> Cale, I think I will need to study more math. I'm actually working on that now, but rather too slowly.
18:28:02 <Cale> fwiw, the setup I originally discussed with vladsot in ##math was the one from Chapter 2 of Jacobs' Categorical Logic and Type Theory
18:28:17 <augur_> ski: this sounds very much like the usual classical SC presentation of cut
18:28:19 <Zemyla> shachaf: If you have a function f :: m a -> m b, then you can turn it into a function on Codensity m a -> Codensity m b with liftCodensity . f . lowerCodensity.
18:28:30 <Zemyla> Well, in theory.
18:28:52 <Zemyla> There are others who would know more on how to word this than I do.
18:29:05 <MuffettMan> What math knowledge is helpful for Haskell? Is there some resource I can read to understand what's being said on this channel?
18:29:07 <ski> augur_ : it was formulated in a multiple-conclusion system (but where the two sides were (possibly infinite) sets)
18:29:23 <shachaf> Zemyla: OK. But liftCodensity . lowerCodensity isn't necessarily id.
18:30:12 <shachaf> Zemyla: Er, lowerCodensity . liftCodensity.
18:30:29 <shachaf> No.
18:30:45 <shachaf> lowerCodensity . liftCodensity *is* id, liftCodensity . lowerCodensity isn't. Sorry.
18:31:01 <Zemyla> Well, I'm trying to figure out, if m is a MonadCont, is Codensity m?
18:31:04 <ski> Zemyla : don't you need to assume `Monad m' ?
18:31:22 <Cale> dfeuer: In that setup, he throws in all three of weakening, contraction, and exchange explicitly, and gives a weakening rule which is intentionally weak (hehe), in that it says from Gamma |- M:t you can infer Gamma, v:s |- M:t, i.e. you must put the new variable on the right.
18:31:49 <Zemyla> ski: MonadCont m implies Monad m, yes?
18:32:25 <ski> MuffettMan : algebraic/equational reasoning, and logical reasoning
18:32:28 <dfeuer> Cale, these are typing rules of some sort? Over my head still.
18:32:46 <ski> Zemyla : that was in comment to `liftCodensity . f . lowerCodensity'
18:34:00 <Cale> dfeuer: Yeah, this is a structural rule in a type theory, that says if from some context Gamma, you can derive that the term M has type t, you can still do so from Gamma extended with a new variable v of type s.
18:34:45 <dfeuer> Cale, that seems pretty straightforward. Why would you want to weaken that?
18:35:31 <Cale> That's the already weak form of weakening. A stronger form lets you put the new variable anywhere in the middle of the context.
18:36:08 <ski> if you can reorder the context at will, then it doesn't matter
18:36:20 <Cale> something like: from Gamma, Gamma' |- M:t infer that Gamma, v:s, Gamma' |- M:t
18:37:39 <dfeuer> Even that stronger form *looks* very ... uh ... sensible?
18:38:00 <Cale> yes, it's quite sensible, but interesting things can happen when you give up on rules like this
18:38:13 <dfeuer> Don't they get rather wild?
18:38:36 <Cale> Well, it sort of lets you express the idea that "you must use all your arguments"
18:38:46 <Cale> when you throw out weakening
18:39:02 <dfeuer> Huh.
18:39:15 <dfeuer> And when you weaken weakening?
18:40:03 <Cale> Well, with the weaker weakening, you have to use some initial segment of your arguments, which is weird, but he also includes contraction and exchange, and exchange lets you permute things, so it's the same again.
18:40:56 <dfeuer> So.... what's the point of weakening weakening if you get to the same thing in the end?
18:40:56 <Cale> With the weaker weakening, there's no way to derive  v_1:t_1, v_2:t_2 |- v_2:t_2
18:41:05 <Cale> unless you also use exchange
18:41:18 <Cale> Well, we were discussing what happens when you remove contraction and exchange from the picture
18:41:53 <dfeuer> What are those rules?
18:42:42 <Cale> Contraction says that from Gamma, v_n:s, v_(n+1):s |- M:t, you can get Gamma, v_n:s |- M[v_n/v_(n+1)]:t
18:43:11 <Cale> i.e. if you can derive that M has type t in a context where there are two variables v_n and v_(n+1) both of type s
18:43:58 <Cale> Then you can derive that (M where occurrences of v_(n+1) have been replaced by v_n) has type t, in a context without v_(n+1):s
18:44:14 <dfeuer> Why n+1? 
18:44:26 <Cale> I'm following the book too closely here
18:44:30 <Cale> I would have used v and v'
18:44:40 <dfeuer> What book's this?
18:44:53 <Cale> Categorical Logic and Type Theory by Jacobs
18:45:30 <dfeuer> So this contraction says you can replace one thing with another of the same type, without changing the type of the result?
18:45:37 <Cale> yeah
18:45:40 <Cale> very reasonable
18:45:45 <Cale> But it lets you duplicate information
18:45:59 <dfeuer> Does it hold in dependently typed sorts of contexts?
18:46:10 <Cale> Some form of it, yeah
18:46:14 <dfeuer> Huh.
18:46:42 <Cale> The next one though, you have to be very careful about in dependently typed contexts
18:47:57 <Cale> Exchange says that given  Gamma, v:s, v':s', Gamma' |- M:t   we can infer  Gamma, v':s', v:s, Gamma' |- M[v/v', v'/v]:t
18:48:06 <Cale> errrr
18:48:08 <Cale> oops
18:48:26 <dfeuer> OK...
18:48:28 <Cale> too many swaps!
18:48:38 <Cale> Exchange says that given  Gamma, v:s, v':s', Gamma' |- M:t   we can infer  Gamma, v:s', v':s, Gamma' |- M[v/v', v'/v]:t
18:48:40 <Cale> better
18:48:43 * dfeuer is also wondering what the deal is with two Gammas.
18:48:56 <Cale> Oh, those represent sequences of other typing judgments
18:49:19 <dfeuer> OK, but I'm still not seeing what this thing means.
18:49:58 <Cale> Okay, so this is basically saying that we can swap the variables in our context around, their order doesn't matter
18:50:10 <Cale> Actually, I can write this more clearly without the need for substitution
18:50:21 <dfeuer> But you're swapping which variable has which type, aren't you?
18:50:55 <Cale> dfeuer: Yeah, but I'm also substituting one variable for the other and vice-versa in the term on the right
18:51:18 <dfeuer> Maybe I will understand when you simplify.
18:51:28 <Cale> We could also just say more simply: From  Gamma, v:s, v':s', Gamma' |- M:t   we can infer  Gamma, v':s', v:s, Gamma' |- M:t
18:51:42 <Cale> i.e. we're allowed to swap the order of things in our context around at will
18:52:15 <dfeuer> OK, that's much easier, yes.
18:52:24 <Cale> Very reasonable, usually there's not much of an ordering on the things in scope... but in a dependently typed language this is a problem
18:52:29 <enthropy> does ghc-7.10.1 also suffer from http://lpaste.net/802857631050891264 (ie. telling you to count function arguments when that's not the problem)?
18:52:32 <Cale> because v might occur in s'
18:52:44 <Cale> So you need to be careful then
18:52:53 <dfeuer> Why isn't contraction problematic in a dependently typed language?
18:53:04 <enthropy> (this is with ghc-7.10 RC1)
18:53:10 <Cale> Because the things had the exact same type
18:53:29 <Cale> If you see v:s, v':s in your context
18:53:35 <Cale> You know v can't occur in s
18:54:05 <dfeuer> Hmmm.
18:54:16 <dfeuer> Oookay.
18:54:21 <dfeuer> I think I sorta see.
18:54:36 <Cale> dfeuer: If I have two things of the exact same type in a dependently typed language, anywhere that I can use one, then I can also use the other
18:54:47 <dfeuer> So you have to be careful about reordering things because of that, but that's not so hard to be careful about, is it?
18:54:52 <Cale> sure
18:54:56 <dfeuer> Er ...
18:55:04 <dfeuer> That's not true, but I think it's probably true enough.
18:55:10 <dfeuer> Like ...
18:55:13 <Cale> It's not *that* hard, but it's something to be cautious of
18:55:17 <dfeuer> I mean
18:55:51 <Cale> enthropy: I could tell you if I had a program to try...
18:56:02 <dfeuer> Vect 3 Int has the same type as Vect 4 Int, but they are different types, so you can't use them with the same terms; but I guess when you're dealing with one "level" at a time that's fine?
18:56:39 <Cale> Oh, I see what you mean
18:56:53 <Cale> Well, the contraction rule doesn't say that what you get is equal
18:57:03 <Cale> Right?
18:57:07 <dfeuer> Just that it has the same type, yah.
18:57:15 <Maxdamantus> So you can replace `Vect 3` with `Vect 4` because `3` and `4` have the same type.
18:57:23 <dfeuer> *nod*
18:57:34 <Cale> and infer that they both have type Type
18:58:13 <dfeuer> Yes.
18:58:33 <Maxdamantus> This is meant to be facetious, right?
18:58:36 <Cale> From 4: Nat, 3: Nat |- Vect 3 Int : Type, we can infer 4: Nat |- Vect 4 Int : Type
18:59:02 <ski> you can also simply think of contraction as saying that you can use a variable twice (or more times)
18:59:29 <dfeuer> Maxdamantus, I'm not trying to be facetious. I'm trying to learn some things that are mostly well over my head :-P
18:59:38 <ski> (often contraction (and weakening) are "built in" to other rules, rather than being expressed explicitly)
19:00:52 <enthropy> Cale: darcs get http://code.haskell.org/~aavogt/HList_typeerrr/ ; cd HList_typeerr; cabal configure --enable-tests; cabal test properties
19:01:04 <enthropy> in a couple minutes after it's done uploading
19:01:10 <enthropy> which is now
19:01:13 <Cale> hmm, I suppose you do need to be careful about how you do contraction: in particular, the variable v you're deleting from the context had better not occur in the type of the term on the right of the |-
19:01:16 <Maxdamantus> Cale: but you can't just change the type of a definition from `Vect 3 -> Vect 4 -> Vect 7`
19:01:24 <Cale> Maxdamantus: right
19:01:28 <ski> e.g. in the rule (really axiom) that says that `Gamma0,x : T,Gamma1 |- x : T', we've built weakening (of all the variables in `Gamma0' and `Gamma1') into this rule
19:02:35 <dfeuer> ski, those quotes confused! "" are easier to read when primes are in play.
19:02:59 <ski> and in the rule that says that if `Gamma |- e : T0 -> T1' and `Gamma |- e0 : T0', then `Gamma |- e e0 : T1', we've built contraction of `Gamma' into this rule
19:03:04 <ski> (i used no primes)
19:03:27 <Cale> enthropy: Okay, one sec, apparently the version of gnutls on my system has changed and I need to reinstall darcs
19:03:57 <dfeuer> ski, I know, but they're in the air anyway :P
19:04:06 <Cale> I've been using lots of primes
19:04:22 <ski> to express these two rules without weakening resp. contraction built-in to them, we could say `x : T |- x : T' (so you have to explicitly use weakening (if you have it at all) to get rid of all the other variables in scope, before you can use a variable in an expression)
19:05:10 <ski> for the other rule, we get : if `Gamma_a |- e : T0 -> T1' and `Gamma_b |- e0 : T0', then `Gamma_a,Gamma_b |- e e0 : T1'
19:05:41 <ski> here we must split our variable context into two, one for use in the operator expression `e', the other for use in the operand expression `e0'
19:06:05 <ski> if we want to use some variable in both, then we must explicitly use contraction to copy it, before using this rule
19:06:26 <ski> ("before" when we read the typing derivation tree from the root towards the leaves, i.e.)
19:06:35 <latermuse> Is there any way to get the domain name or subdomain name of the server while using Web.Scotty? Im looking for something similar to PHP's $_SERVER['HTTP_HOST']
19:06:43 <Cale> One thing I think I should say in order to help dfeuer interpret what ski just said is that these inference rules sort of run in reverse when we're typechecking. So when we're typechecking, weakening is what lets us discard unneeded variables from the context, rather than add extraneous ones.
19:07:12 * dfeuer is getting too tired now. Cale, that was helpful. And ski, that would've been had I been more awake.
19:08:02 <ski> yes, one can read the rules from establisged premisses to derived conclusion, or in the other direction (from conclusion goal, to premisses required to establish (as new subgoals))
19:08:04 <Cale> latermuse: I don't know off hand, but I can help look
19:08:14 <ski> dfeuer : np
19:08:46 <latermuse> Cale: That would be fantastic. I dont mind using a lower-level networking library to get that data as long as it is available somehow.
19:10:05 <latermuse> If its not available, ill probably need to code the domain/subdomain into a conf file. This is a pain when working with a large amount of subdomains
19:12:09 <Cale> latermuse: okay, so request :: ActionM Request lets you get the HTTP request that was made
19:12:38 <Cale> which is a type that's defined here: http://hackage.haskell.org/package/wai-3.0.2.1/docs/Network-Wai.html#t:Request
19:13:11 <Cale> requestHeaderHost :: Request -> Maybe ByteString  -- sounds promising
19:13:34 <latermuse> nice!
19:13:37 <latermuse> that sounds about right
19:14:01 <latermuse> thanks cale
19:14:05 <Cale> no problem
19:18:47 <Rainb> can someone remind me what is a monad again
19:19:13 <orion> Rainb: Monads are like a burrito.
19:19:28 <Xe> Rainb: a sequence of computation
19:19:30 <Xe> s*
19:19:37 <dfeuer> orion--
19:19:50 <Cale> Rainb: A monad is a type constructor M for which there are defined operations  return :: a -> M a  and  (>>=) :: M a -> (a -> M b) -> M b  satisfying certain laws
19:19:51 <TRManderson> orion: no they're like a space burrito
19:20:16 <dfeuer> No.
19:20:51 <Rainb> I think I need a haskell tutorial again. I guess I'll eventually remember these terms
19:20:53 <dfeuer> Rainb, https://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Monad.html tells you.
19:21:08 <slack1256> also, play with ghci on a monad you like
19:21:12 <Cale> Rainb: In particular, those laws say that  1) return x >>= f  is always the same as  f x 
19:21:28 <Cale> 2) x >>= return  is always the same as x
19:22:10 <andyf> If there is a writeup on this, I‚Äôd appreciate a link.  Is it assumed by ‚Äúreferential transparency‚Äù that if any two value x and y are equal, then for all functions f, f(x) must equal f(y)?
19:22:12 <Cale> (these two work together to express the idea that "return v is a computation which does nothing except to, well, return v as its result")
19:23:05 <srhb> andyf: Then for _the_ function f, yes
19:23:06 <Cale> and 3) (x >>= f) >>= g is always the same as x >>= (\v -> f v >>= g)
19:23:51 <Cale> This third one basically lets us do refactorings, chopping out the middle of a computation and moving it into its own definition
19:24:32 <Cale> (though when written in this form, it's perhaps not terribly clear that's what it's really doing for us)
19:24:51 <Cale> Rainb: does that help at all?
19:24:52 <andyf> srhb: What I intended was that if you pick any function f, then for all values x and y in its domain, x=y implies f(x)=f(y).  That is, *all* functions are restricted this way, not just some of them.
19:24:55 <srhb> andyf: This SO answer is sort of http://stackoverflow.com/questions/210835/what-is-referential-transparency
19:25:05 <srhb> andyf: Yes, that's fair.
19:25:23 <Cale> Rainb: That's all there is to a monad. Usually we think of values of the type M t as being some sort of computations whose result has type t
19:25:56 <Rainb> Cale: I'll need to review the operators. Hehe. Thank you.
19:26:02 <Cale> Rainb: and so we can interpret x >>= f as being the computation which when executed will first execute x (whatever that means)
19:26:11 <andyf> So are there any Haskell data structures like hash tries that require the keys to be hashable, but do not require a total order on them?
19:26:13 <Cale> and then if the result is v, will then execute f v
19:26:25 <Cale> returning the result of that latter computation as its own result
19:26:56 <Cale> It may help to use do-notation: x >>= f is the same thing as  do { v <- x; w <- f v; return w }
19:27:36 <andyf> And if so, do they implement a function to return a list of all of their keys.  And if so, how do they guarantee that function returns the same order of keys regardless of the order that keys were added to the hash trie?
19:27:43 <Cale> andyf: You'll find some of those in unordered-containers
19:27:45 <arkeet> or just do { v <- x; f v }
19:27:55 <dfeuer> andyes. There are both HashMaps and HashTables.
19:28:03 <Cale> andyf: http://hackage.haskell.org/package/unordered-containers
19:28:18 <Cale> has HashMap and HashSet
19:28:18 * dfeuer introduces some disorder to Cale's containers.
19:28:31 <dfeuer> Which are really IntMap in disguise.
19:29:02 <dfeuer> Therefore a fancy trie.
19:29:02 <Cale> At one point I tried replacing some uses of Data.Map in a game with Data.HashMap and the performance was slightly worse though
19:29:11 <Cale> That's not because Data.HashMap is all that bad
19:29:20 <Cale> It's more because Data.Map is pretty dang good
19:29:22 * hackagebot Dist 0.2.0.0 - A Haskell library for probability distributions  http://hackage.haskell.org/package/Dist-0.2.0.0 (wyager)
19:29:32 <Cale> and computing hashes isn't free
19:29:34 <dfeuer> I have seen some very good results from replacing Data.Set with Data.IntSet though.
19:30:16 <Cale> So sometimes the cost of doing the order comparisons required is less than the cost of hashing.
19:30:32 <srhb> andyf: For the previous question you asked to have a positive answer does not mean that the order of adding things need be irrelevant to the order of keys returned
19:30:39 <echo-area> Is `\ ~(a,s)` intended to be lazy destructuring?
19:30:40 <srhb> (At least, I can't see how that would be a requirement)
19:30:43 <dfeuer> Don't forget the possibility of using a generic trie if the data are structured.
19:30:45 <srhb> echo-area: Yes
19:30:55 <echo-area> srhb: Thanks
19:31:24 <Cale> echo-area: yeah, that's essentially the same as \p -> let {a = fst p; s = snd p} in ...
19:31:31 <srhb> andyf: To put it differently, (/) does not commute.
19:31:43 <andyf> srhb: Can I compare Data.HashSet values for equality, and they are considered equal if they contain the same set of elements, regardless of the order items were inserted into them?
19:31:46 <srhb> It's still referentially transparent by your previous definition
19:31:46 * dfeuer divides srhb.
19:31:55 <srhb> aghhh!
19:32:13 <arkeet> andyf: yes
19:32:42 <andyf> And can two such equal Data.HashSet values return items in a different order via toList ?
19:33:25 <arkeet> it would suck if it didn't
19:33:47 <Cale> uhhh
19:33:48 <Cale> no
19:34:01 <arkeet> er if it did*
19:34:20 <Cale> If x,y :: HashSet and x == y, then toList x == toList y
19:34:37 <andyf> How can they guarantee returning items in the same order if the items are hashable, but there is no total order on them?
19:34:46 <arkeet> there is a total order on the hashes
19:34:56 <andyf> What about items with equal hashes?
19:35:33 <arkeet> mm
19:35:59 <dmwit> I worry that people are not answering carefully.
19:36:19 <arkeet> well I don't know the answer.
19:36:26 <Cale> Well, we should look carefully at how HashMap handles collisions
19:36:37 <andyf> I don‚Äôt see how a hash-based set or dictionary/map can satisfy referential transparency for a function like toList.
19:36:59 <andyf> unless it also requires a total order on the set elements (for set) or keys (for dictionaries/maps)
19:37:28 <arkeet> well, perform an experiment then.
19:37:36 <arkeet> you can write your own data type with a Hashable instance.
19:38:03 <Cale> Okay, so one problem is that the Eq instance for HashMap might as you suggest be broken
19:38:20 <arkeet> which I just did. and the answer is no.
19:38:28 <Cale> So, what I should have written is that if x,y :: HashSet and x = y, then toList x = toList y
19:38:34 <dmwit> I experimentally confirm that x == y does not imply toList x == toList y.
19:38:45 <Cale> dmwit: That's interesting
19:38:48 <Cale> (and bad)
19:39:01 <andyf> so does that mean this data structure and/or the functions that are associated with them are not referentially transparet?
19:39:02 <dmwit> I would argue that it is toList which is broken, not (==).
19:39:07 <arkeet> no.
19:39:22 <Cale> Yeah, you could say that it's really toList's fault
19:39:27 <dmwit> (==) does the correct thing: fromList [NewTrue, NewFalse] == fromList [NewFalse, NewTrue], even though New* both hash to 0.
19:39:58 <srhb> andyf: The difference is that x != y if they were constructed in different orders. When we used x=y before we were not talking about Haskell --
19:40:06 <srhb> Haskell ==
19:40:19 <dmwit> srhb: Careful now. I don't think that claim was precise.
19:40:22 <srhb> Really?
19:40:27 <srhb> Hmm.
19:40:30 <dmwit> (As mentioned, fromList [NewFalse, NewTrue] == fromList [NewTrue, NewFalse].)
19:40:34 <arkeet> the = for referential transparency is definitional equality.
19:40:36 <srhb> I'm pretty sure the order matters when collissions are found.
19:40:38 * geekosaur notes that randomized order in hashes is considered a security feature in the web world, so this may be deliberate?
19:40:44 <arkeet> == is something different.
19:40:47 <andyf> I am asking these questions because Clojure‚Äôs hash sets and maps have a function similar to toList (called seq), and it is also not referentially transparent in the same way that it sounds like Data.HashMap is not.  I was curious whether Haskellers had some tricks up their sleeve that Clojure hasn‚Äôt discovered.
19:40:54 <dmwit> srhb: Or, oh, were you using != as the semantic one, as opposed to /=?
19:40:54 <srhb> dmwit: That's what I'm saying.
19:40:57 <srhb> Yes
19:41:01 <dmwit> Okay, I apologize.
19:41:14 <srhb> No problem :) It's a bit complex
19:41:26 <srhb> (And by that I mean I may not be explaining myself well)
19:41:26 <dmwit> andyf: I don't think there's a referential transparency problem here.
19:41:32 <Cale> andyf: One thing you could do is to insist on an ordering for toList
19:41:41 <srhb> There isn't, because x is not = to y in the sense of referential transparency. Order matters.
19:41:43 <dmwit> andyf: Though there *is* a bit of semantic confusion. toList does not respect (==).
19:41:56 <Cale> It's not exactly the same thing as a referential transparency problem, but it breaks the module abstraction.
19:42:00 <dmwit> right
19:42:12 <arkeet> well, perhaps the thing to do is make a note in the documentation.
19:42:13 <dmwit> It's clearly broken. But none of the guarantees of *the language Haskell* is broken.
19:42:19 <srhb> arkeet: It's in the top
19:42:25 <andyf> dimwit: I‚Äôm not sure what ‚ÄútoList does not respect (==)‚Äù means.  Could you explain that a bit more?
19:42:28 <arkeet> I guess so.
19:42:31 <Cale> We'd like to be able to think of HashMaps for which x == y as completely equal
19:42:43 <dmwit> andyf: Yes; as observed, x == y does not imply toList x == toList y.
19:42:44 <arkeet> it's not terribly clear I suppose.
19:43:11 <srhb> That would only really defer the problem further down the line, or impose arbitrary ordering on the elements in case of collission. But sure, the interface wouldn't make it obvious.
19:43:12 <Cale> But having a toList which deals with collisions like that lets us observe the actual tree structure a little
19:43:22 <srhb> Indeed.
19:44:01 <dmwit> It would be easy to write a toList which respects (==), but it would have to have a type like Ord a => HashSet a -> [a] instead.
19:44:10 <srhb> And come with a performance cost.
19:44:23 <dmwit> (...for instances that have a respectful Ord instance in the first place.)
19:44:33 <dmwit> srhb: Sure. On the assumption that there aren't many collisions, not a large one, though.
19:44:39 <srhb> True true. :)
19:45:04 <andyf> dimwit: Meaning it would require a total order to be given for the set elements?  Agreed if so.  One could even then use a balanced search tree for colliding elements if they wanted to avoid linear worst cases.
19:45:17 <arkeet> dmwit: no, it would still have a significant cost.
19:45:24 <arkeet> hashing need not preserve ordering
19:45:25 <dmwit> andyf: Seems you have understood me well.
19:45:38 <arkeet> seems like toList returns results in order of increashing hash.
19:45:38 <Cale> arkeet: You only sort the collision tables
19:45:40 <srhb> arkeet: You only have to sort in case of Collission
19:45:45 <arkeet> ah, true.
19:46:19 <dmwit> arkeet: One would have to assume that, on elements, x == y implies hash x == hash y, or similar. And probably some assumption relating compare and (==).
19:46:22 <Cale> This should probably be done :P
19:46:24 <andyf> So it seems like it is possible to write completely pure functions that lead to behavior that is not referentially transparent?
19:46:29 <srhb> No
19:46:34 <srhb> Referential transparency does not mean ==
19:46:35 <dmwit> andyf: It doesn't seem like that to me.
19:46:36 <srhb> It means =
19:46:55 <Cale> andyf: Only once you start including module abstractions in your definition of referential transparency
19:47:11 <dmwit> andyf: Be careful to distinguish between the function (==), which can be implemented in any way you like, and meta-equality, which talks about how a term reduces.
19:47:14 <arkeet> x == y doesn't imply that x and y are *identical*
19:47:22 <dmwit> andyf: (==) can't refer to reduction behavior at all.
19:47:26 <arkeet> it just means that whatever the (==) function does, it results in True given x and y.
19:47:30 <Cale> andyf: Like, the actual data structures representing the hashmaps are not really equal, even if we define the equality comparison function to produce True here
19:47:55 <srhb> The fact that the order with which the same elements are added to HashSets x,y means that x != y in referential transparency, not that referential transparency is broken.
19:48:06 <Cale> (==) is really an equivalence relation, and it might give True even for things which are not genuinely equal
19:48:08 <andyf> I understand that Data.HashMap‚Äôs with equal sets of items in them need not be the same thing in memory.
19:48:18 <srhb> It's not about memory
19:48:19 <dmwit> andyf: Referential transparency says you can replace a term with its definition and get the same result. Can you show how to violate this with HashMap?
19:48:21 <srhb> Well, not JUST
19:48:56 <dmwit> s/term/name/
19:49:00 <Cale> However, we usually try to use the module system and define it in such a way that if x == y is True, you can't observe the fact that x and y are distinct using the stuff that's exported from the module.
19:49:11 <Cale> (but that's failing in this case of HashMaps)
19:49:28 <Cale> Unfortunately, it also fails in the case of Float and Double
19:49:34 <Cale> > 0 == -0
19:49:35 <andyf> It just seems that it is possible to define (==) in a very reasonable math-y way for Data.HashSet‚Äôs, where it is a true equivalence relation that only returns true when the sets of items are the same, and want a function like toList, and implement it all with pure functions, and come out with an implementatino where x == y can lead to not (toList x == toList y)for some sets x,y
19:49:36 <lambdabot>  True
19:49:47 <arkeet> > 1/0 == 1/(-0)
19:49:47 <Cale> > isNegativeZero 0 == isNegativeZero (-0)
19:49:48 <lambdabot>  False
19:49:49 <lambdabot>  <no location info>: can't find file: L.hs
19:49:50 <srhb> andyf: Correct!
19:49:56 <Cale> > 1/0 == 1/(-0)
19:49:57 <lambdabot>  False
19:50:08 <dmwit> andyf: I agree! Note that none of what you said dents claims about referential transparency still holding in case you define (==) badly.
19:50:25 <andyf> dimwit: How is (==) defined badly here?
19:50:28 <srhb> andyf: But that does not break referential transparency. x == y might be true even if x != y in the referential sense
19:50:45 <dmwit> andyf: It's not! But even if you *did* define it badly, that doesn't make referential transparency suddenly break.
19:51:00 <srhb> Again, using == and /= for Haskell operators and = and != for "referential equality" for lack of a better term
19:51:16 <dmwit> andyf: I suspect that, rather than you being wrong, you are simply using a fairly technical term slightly incorrectly.
19:51:29 <dmwit> andyf: Namely, I think you may not have quite the right meaning of "referential transparency" in your head.
19:51:31 <andyf> Sorry for my dense-ness here: What do you think referential transparency means, if it doesn‚Äôt refer to (==)?
19:51:37 <dmwit> andyf: Because we all agree with you that something is broken here. =)
19:51:42 <arkeet> definitional equality
19:51:46 <Cale> "referential transparency" gets used to mean a lot of different things though
19:51:50 <arkeet> :<
19:51:51 <dmwit> andyf: Referential transparency says you can replace any name with its definition and get the same result.
19:52:23 <srhb> and addElem 3 (addElem 4 ...) is different from addElem 4 (addElem 3 ...)
19:52:27 <srhb> Even though == might claim differently
19:52:31 <dmwit> andyf: "referential" is about "a name vs. what it references"; "transparency" is about "does it make a difference"
19:52:36 <srhb> Well, it MAY be different, for some datastructures, as seen here
19:52:46 <andyf> srhb: I think that nails it for me.  Thanks.
19:53:02 <srhb> Hooray, I'm useful!
19:53:07 <dmwit> srhb++
19:53:46 <andyf> Is this channel logged anywhere?  Appreciate a link.
19:53:54 <dmwit> See /topic.
20:04:24 * hackagebot hexstring 0.9.0 - Fast and safe representation of a hex string  http://hackage.haskell.org/package/hexstring-0.9.0 (solatis)
20:08:49 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org | Learn, Teach, or Get Out of the Way!'
20:08:49 --- topic: set by shapr!~shapr@84.200.228.78 on [Tue Mar 17 12:32:20 2015]
20:08:49 --- names: list (clog fumieval Slay_ fuzzyhorns blicero otto_s pchiusano frodwith jonmorehouse jeffburdges darkf_ Soft- ZsoL mrd_ gsnewmar` mmachenry LABurn PyroPeter _X_C_V_B_ fujimura small-wolf myst|work rejuvyesh rossberg_ rlsg Nadrieril pimlu mizu_no_oto Quashie DerisiveLogic fread2281 kmels schmity funfunctor boj Big_G eisbehr balaji saiko-chriskun f1u77y jergason char_garoson echo-area rgr_android desophos yfeldblum crymore Goplat solatis hamishmack tvh aaronlevin)
20:08:49 --- names: list (yoshuawuyts2 Lokathor APerson_ dpratt711 tranma L8D slack1256 greenbagels Ryanar l4u- aartamonau enaqx xcthulhu mpereira darkbolt_ sritchie mgomezch cfricke codemiller watabou Kron path[l] ElectricSolstice DocScrutinizer jedws godel iamd3 heatsink exferenceBot lspitzner hexagoxel ships_ xacktm SrPx Stratege______ saml_ doctorinserenity jasonjckn janne Xnuk pikhq predator217 zariuq dfeuer marchelzo_ sea-gull calef13 jack_rabbit troydm tristero ev_ sudog)
20:08:49 --- names: list (Guest79538 ryanakca futuredale centrinia turtil Iskarlar _ashbreeze_ XMunkki Polarina sprang u_ shlevy perspectival tripped verement sabauman infinity0 erikd codefo hhhhhhhh Palmik MP2E kadoban SparkySparkyBoom `szx_ dsantiago tar_ FreeFull enthropy hellome edwinvdgraaf Tanshinan ansible1 ezyang_ dav ``rawr jordanl ThatOtherPerson pavonia DanielDiaz jml osa1_ Oxyd codesoup lu324 earthy Internet13 Jeanne-Kamikaze Noldorin catsup rkazak xiinotulp lodin)
20:08:49 --- names: list (wjlroe indiagreen Betal ellipsis_ agumonkey eddsteel Mon_Ouie Nahra da-x amiri c_wraith emanuelz Rainb whaletechno xahry lnr nshepperd_ _rgn Phillemann juri_ abrar rcyr mitochon lifenoodles dan_f skeet70 www-BUKOLAY-com thatFresh louisjb equinox_ x1n4u trism nominolo jxv zinfandel modori ssn__ EvanR Francisco lritter mathemancer triliyn statusbot dreixel gehr majorseitan thetallguy thegladiator julmac ndrei arjanb mthvedt martintrojer psy DrPete_ gregnwosu)
20:08:49 --- names: list (jonesinator QoI ashnur tlevine goldfire1 ski RGamma oneeman realitygrill noctux thorkilnaur Gothmog_ zorzar xificurC s00pcan fall` kaol therealklanni fengshaun rivarun sdothum isocliff zeiris mceier _augur aaronweiss74 akurilin2 Gurkenglas rdema cyphase sagittarian|2 LnL dxtr johtso_ sw1nn etabot sergey__ Qfwfq tomboy65 djellemah eazar001 Temur SoupE apaku Vorpal latk milessabin hackagebot Dynetrekk ValicekB zso overlord7 Jellydog Longlius whiteline emma)
20:08:49 --- names: list (Zanzare sakirious jpiche pacak BMeph stasku nkpart cloudhead_ Liskni_si AWhetter alynn lenstr jaspervdj brezel nyuszika7h spacebug pyon Xack Hijiri thunderrd_ Plasmastar solrize_ kstuart_ tnks C4Cypher CMCDragonkai ParahSailin wagle theanalyst OutlawStar Tristan-Speccy Cubesoup mecalopolis drewdavis spwhitt renekooi yrdz davidshore bjorkintosh ousado meteo kjanosz jud peterhil tismith buoto negatratoron ixti vin-ivar Guest6727694 Ralith boot13 seagreen)
20:08:49 --- names: list (fryguybob ozialien DrCode phaskell ForNeVeR hooptw mountaingoat Paradisee Floyd_ Slay petercommand prkc reddodgem anders^^ rpaehlig chrisdotcode crlane dlundy mimi_vx dibblego kalz ceii arw jimstutt kqr MultiPurposeHat tejing dewdrop whitesn sagittarian MrWoohoo Taneb barrucadu gds ibid jameseb vikraman gfixler hiratara Cale wedens descender dario` greeny rsynnest kaw_ pfurla dgvncsz0f jle` Frank89RM_ joneshf-laptop Rotaerk Vq Fubar^_ mirsal lamilami)
20:08:49 --- names: list (simonnn dufus sydneyhacker vili fishkandy suls gienah eyck kaictl vmeson unknownloner Guest45299 R0b0t1 johnw_ adzuci_ netj_ haroldwu bsmt robotbrain_ f|`-`|f Orwell84 Sigyn chishiki bdamos shiona frelot schell Talryn Artpicre David tusj orion ctag cdidd hrnz Wamanuz Sorella mrowe_away albel727 elementalest Eliel inr fling ktosiek eniirane hattusili_III ljhms enolan ellinokon ubuntor apollo1993 acmiyaguchi cdk kalloc Zekka rofer newsham permagreen zxq9)
20:08:49 --- names: list (Boney Tesseraction grol arrdem srid lassulus KeelOfSteel dpwright kav spaceships ephemeron Vbitz jessicah avocado k-u jedai SHODAN flux flx aidecoe JZTech101 yusukesuzuki butyoudonot luzie pii4 cchalmers earl qr42 Voldenet somenick robbert ajp canta Dykam andjjj23 miklcct brixen lvh dropdrive bitemyappPrime jcp AntiSpamMeta kloplop321 znutar drbean xpika cosban bitemyapp shwouchk ivan\ sku1d l3france masse MitchW derekv Excureo blenny hemite esssing Twey)
20:08:49 --- names: list (ahihi Pamelloes thomas Bane^ lambdabot kmicu thomie coeus Reiser melter irclogger_com poucet tgeeky lykkin jokester dolio sebastard ephess karshan chirpsalot jaffachief benonsoftware gniourf gratimax gbiv tv1 trevorriles iElectric zaquest dgonyeo| cic eyenx_ jbalint_ lpsmith_ benzrf jerbome RevJohnnyHealey dmilith sorind taksuyu ThePhoeron ps-auxw TallerGhostWalt d3lxa umbriel mak` sdx23 niklasb ayertienna bracket_ cjh` itsmonkt1stic nik_89 jarvi_ keaml_)
20:08:49 --- names: list (klugez runde_ robogoat duga3 lytchi yorick cow-orker TRManderson mokus_ mgaare_ Zemyla ziman zyoung_ sivoais xplat byaruhaf pygospa Tene saiam_ hiredman aaronm04_ buMPnet_ burp M-ou-se guampa rbocquet staffehn mitu yac SuperTux88 Cerise wizonesolutions conehead stvc dgonyeo- besenwesen PinealGlandOptic dgorbik mach maw fr33domlover waern Eiam ortmage proq wayne sellout harski Xe coyotebush hvr Preyer nuser ByronJohnson loz-- mrsolow xeno lahwran Trubydoor)
20:08:49 --- names: list (dsturnbull_ horlicks_ HugoDaniel boothead Athas Or1 ChristianS MoALTz monochrom Khisanth ezrios yukko devi nafis magicman hodapp zugz Gilfoyle kini sebleblanc hpc hbar Profpatsch nmontecc dxld Philonous samertm Tiktalik sbrg andrewsw nemesit|znc nominolo|work xelxebar frogpunc glguy Nik05 aoe_ tromp_ efm ErichKeane voidzero liyang LQYMGT Korri condy linduxed marienz kevin1024 dju joefiorini inuoppai Fylwind quaestor McManiaC Desoxy_ sLite_ Pucilowski_)
20:08:49 --- names: list (amiller certainty CosmicRa` ggVGc capisce anderslundstedt jlind Adios_ bennyklotz Juka Yawgmoth falafel srcerer kriwil cmn zerokarmaleft tsani glowcoil zilinc pii stass DrAwesomeClaws mniip lieven ackthet zpconn__________ cursork Elsi beauby Tehnix pm5 uwap cryon exio4 jrslepak vermeille bergmark Laney jnoah ]OLI[ hator Lutin` mrb_bk BrianHV ixian scott sclv _flow_ Draconx lsep jlamothe haBuu^ Svedrin maurer byorgey bsummer4 korpse_ tarcwynne seabre)
20:08:49 --- names: list (c9sould__ mankyKitty cstrahan AlainODea alekst_ joehh1 eivuokko hpd jtobin luite__ rj-code sys9mm Shagane astocko optocoupler frawgie_ bennyklo1z enomies paperManu Ankhers Moggle1 Natch bjobjo saep gpampara dschoepe WarzoneCommand atn34 DustyDingo otulp colah_ JPohlman1 irishsul1an Fuco simon___ bdha etrepum pieter_ solirc pederindi benwf averell e4x Igloo chpatrick thomassgn MK_FG Elision tg kolmodin blake Flaeme mero c-rog lyxia malglim agam koala_man)
20:08:49 --- names: list (Cathy adnap enojelly dcoutts anoe djanatyn ruukasu mitchty ricardo82 suvash_away _di turinturambar trolling malllle ij Nimatek fold _ikke_ bob_twinkles Ring0` zyla PotatoGim kess nilscox nesqi mindos_cloud____ dustinm- skarn_ drone- Haskellfant hegge Saizan Ferdirand tridacty1a vikram_ lfp__ flori_ SLi zso__ hyPiRion andreass_ Ezku_ edwardk mbrcknl zhulikas kirjs_______ dstockwell NeatBasisW dlackty___ arnihermann mno2 asabil lambdahands caasihuang konne_)
20:08:49 --- names: list (joedevivo jmcarthur haasn mudphone doppioslash martingale abbe nakal jzl yminsky dino- bind m1dnight_ Axman6 niko deavidsedice gmaslov brent80_plow StoneToad usr ollef bernalex uber bgamari_ bgamari imalsogreg RageD dabradley bshelden Plastefuchs _1126 HylianSavior perrier timothyh japesinator Brando753 dqd DanToml pwestlund_away lpaste nrw ircbrowse brisbin raid codehero cin Blkt gandr psacrifice nathanic jvd eikke renzhi defanor rola IanKelling)
20:08:49 --- names: list (Guest90609 jokra sm lyddonb Guest42319 davesilva bafbomb_ jcurbo tolt Guest48087 RustyShackleford jacksnipe mathu devJunk poga fall_ tumdedum Sqt Paprikachu Draggor frontendloader karls iross ttuegel ryantm zalami sdressel jackhill _ether_ Freundlich darkowlzz|afk bigs alevy Maxdamantus paf31_away blast_hardcheese mikel gnusosa si14 wenzowski waxjar seancorfield meretrix tomku bgyss puzza007 Enigmagic Guest55616 Guest60360 geekosaur agrif mikeizbicki wjm)
20:08:49 --- names: list (Hugglesworth Cr8 cjwelborn wolf_mozart neptunepink acfoltzer Spaceghost milli jmct neektza incomprehensibly zero7 carter_cloud sweenzor Forkk comboy ipuustin phaazon absence aseidl tessier arianvp Baughn michaelpj alpounet cowtown bolmar dilinger spdionis kvalle zenzike wrengr_away huonw sharvils serutsubi freusque Nickeeh Jaxan edk mephx nwf Klumben seliopou metaf5 posco rtl_ eagleflo dredozubov mechairo` noplamodo DanZimm geal d-snp sagelywizard amontez)
20:08:49 --- names: list (Nanar jludwig jayne ggreg niluje bcoppens edwtjo Clint betawaffle davean gbarboza apo sujeet phadej yukonjack kennyp gmcintire nikola Kruppe AshyIsMe Willis liste hsyl20 Ptival shmookey1 adlan fractalcat yeltzooo9 gtklocker sunnavy stbuehler cscorley thebnq CindyLinz sbauer322 dicioccio mattp shutdown_-h_now numberten cYmen_ xian tromp tomaw annulus brolin_empey oconnore angryzor gdsx elij joeytwiddle FireFly Jello_Raptor joshc joehillen pmade naudiz)
20:08:49 --- names: list (cynick GaveUp xnyhps anastas mendez_ monsieurp qz asm89 Intensity ChongLi Ted__ [swift] untwisted bartavelle Uritomi2 IbnFirnas heikkih pyrtsa elgot opqdonut Chousuke WSergio KaneTW Mandus f_x_ xaimus ww mikeplus64 majoh Guest37394 orzo Th0mas unsymbol raek albertid Watcher7_ ckw u_quark1 Heffalump banjiewen ReinH callumacrae mp ClaudiusMaximus cross sabalaba cYmen mt mikedanese acharm AncientPC ninzine tomprince wtw shachaf DenSchub Guest85510 jakutis)
20:08:49 --- names: list (dixie_ hive-mind Eldrad __main__ lemmih JamesJRH pingu nbouscal sephiap bcavalier yrashk saolsen ggherdov ehamberg cojy_ Raynos lohkey bkolera andrew__n andreypopp CARAM__ jroesch MMuse_______ ocharles_ jfokkan zph nmashton jonrh bcarrell Erstarrung sokoll bjornars1 xxx zxtx tomphreek Rembane Rastus_Vernon tazjin S11001001 yarou abh twopoint718 dan64 atomi Ke Starfire _klm jabbslad_ hguux___ RasmusWL gridaphobe lurker6 RayNbow`TU lispy platz valdyn Paks)
20:08:49 --- names: list (Chobbes mjo klarrt martinbmadsen _owa asjo eL_Bart0 bbee bananagram ilmig canard Dodek rudi_s mpw Geekingfrog lattenwald fugyk bijumon jorj sevcsik eevar SwashBuckla brennie nisstyre joeyh jtanguy mlen plhk cods mmaruseacph2 tdammers Dtgr mrd tuv pharpend Belgarion0 ninegrid iulian zbrown mads- ft fnordbert spindas Jaak Shapeshifter bvad zq eamelink tjbp cpa_ pharaun paz__ heaumer solarus PHO dawik deni mortberg gargawel rabisg kloeri relrod froztbyte lf94)
20:08:49 --- names: list (stomp koomi igniting ad ndeine pdxleif swen rieper nitrix padre_angolano adimit natte eyem_ KitC BlakeRain foolie tomjaguarpaw ido sternenseemann xiaolin pranz1 rseymour vladan Factionwars theorbtwo kakos fionnan cjay aristid thoradam jstolarek int-e mantovani syk0mantis demolithion ion dowski_ machineslearn thoughtpolice knyppeldynan supki aleator_2 saurik aleator_1 drmegahe1tz marens Guest23539 TDJACR GGMethos zomg hanDerPeder sohum LordDeath BillyIII)
20:08:49 --- names: list (bydo SegFaultAX flaiw LeaChim Sornaensis phuu obiwahn gseitz kipras`away monty jlewis avn oberstein Spockz dp_wiz namuromus mietek lokydor fergusnoble peddie dkua tzaeru Jonno_FTW petantik pleiosaur ElderFain jkarni jix rslima Heero biscarch JonasH__ NemesisD emmanueloga lacrosse__ idnar shelling__ trig-ger julienXX Xorlev DigitalKiwi electrogeek krgn obcode alphonse23_ gws hongminhee jophish Fuuzetsu mpickering sajith dmwit notdan aleator davl grohne)
20:08:49 --- names: list (slasktask rs0 kgadek comma8 wto helgar fredsir dh senseibaka tswett xandaros dpn` cschneid Bigcheese oherrala mami kosmikus brackets mjrosenb statusfailed kazawore_ dabukalam zeroskil1or seanparsons otherchas_ hellschreiber keko-2 liff integral Walther ironChicken zymurgy kwantam felixsch Ornedan pfoetchen alanz killtheliterate alem0lars lachenmayer rray myme chris2 sgronblo spion jlouis ahf isomorphismes arkeet carter scopedTV otterdam taruti friden `0660)
20:08:49 --- names: list (jlyndon Kneiva jrp6 ThreeOfEight fmapE kshannon schlumpi ernst adamse drdo Hafydd tekacs diginet alang srhb greymalkin Adeon bonobo_ Razz biio Boreeas zebr zrl Tritlo chriswk fuziontech tych0 Guest99579 rom1504 pi8029 osfameron poikon n1ftyn8 avdi kjnilsson shennyg howard vodkaInferno shapr s_e kragniz akahn Ulrar Deewiant Atlanis heyj_ca Edox iota_ @ChanServ edran_ arch_ sleepynate aupo tero-)
20:21:19 <tsani> Is it possible to do a case analysis on a bind in do-notation without introducing another binding?
20:21:36 <tsani> I basically want to eliminate the "s" in do { s <- blah ; case s of ... }
20:22:24 <pavonia> "blah >>= \case ..."
20:22:41 <tsani> mm lambdacase
20:22:54 <tsani> Thanks !
20:29:25 * hackagebot fasta 0.5.2.0 - A simple, mindless parser for fasta files.  http://hackage.haskell.org/package/fasta-0.5.2.0 (GregorySchwartz)
20:30:52 <tromp> how to compute the characteristic sequence of primes [False,False,True,True,False,True...] ?
20:32:31 <Cale> map isPrime [0..] ?
20:32:51 <tromp> and how to do it without using any arithmetic?
20:32:55 <Cale> heh
20:33:01 <Cale> There's probably some more artful way
20:33:02 <tromp> without any numbers?
20:33:32 <tromp> in one line?
20:34:25 * hackagebot fasta 0.5.3.0 - A simple, mindless parser for fasta files.  http://hackage.haskell.org/package/fasta-0.5.3.0 (GregorySchwartz)
20:42:33 <tromp> :t ap
20:42:34 <lambdabot> Monad m => m (a -> b) -> m a -> m b
20:42:51 <tromp> @hoogle ap
20:42:53 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
20:42:53 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
20:42:53 <lambdabot> Prelude appendFile :: FilePath -> String -> IO ()
20:45:04 <tromp> > let f=False;o c(x:y)=x:c y;z c(x:y)=f:c y;p n=True:ap fix p(o.n)in f:f:p z
20:45:05 <lambdabot>  [False,False,True,True,False,True,False,True,False,False,False,True,False,Tr...
20:48:13 <pavonia> > map fst $ filter snd $ zip [0..] $  let f=False;o c(x:y)=x:c y;z c(x:y)=f:c y;p n=True:ap fix p(o.n)in f:f:p z
20:48:14 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
20:50:27 <OutlawStar> is it possible to export select type from a module with another modules export ie "module Foo ( module Bar (...) ) where
20:51:33 <dmwit> just module Foo (TypeName(..))
20:51:46 <enthropy> module Foo (module Bar) where import Bar(b1) -- will not reexport everything from Bar (unless bar only exports b1)
20:52:27 <OutlawStar> ahh cool, so i use the import of Bar(..) to control what is exported overall?
20:53:20 <tromp> > let f='.';o c(x:y)=x:c y;z c(x:y)=f:c y;p n='P':ap fix p(o.n)in f:f:p z
20:53:22 <lambdabot>  "..PP.P.P...P.P...P.P...P.....P.P.....P...P.P...P.....P.....P.P.....P...P.P....
20:54:27 <tromp> hmm, maybe prettier without any capitals
20:54:30 <tromp> > let f='.';o c(x:y)=x:c y;z c(x:y)=f:c y;p n='p':ap fix p(o.n)in f:f:p z
20:54:32 <lambdabot>  "..pp.p.p...p.p...p.p...p.....p.p.....p...p.p...p.....p.....p.p.....p...p.p....
21:02:52 <bitemyappPrime> solirc: hey, how do you force failure in an HSpec Spec with a string explaining what happened?
21:03:15 <bitemyappPrime> solirc: are you just supposed to use  fail :: Monad m => String -> m a   or something else?
21:31:22 <lamefun> How can I extendable objects in Haskell?
21:32:26 <heatsink> What do you want to do using them?
21:33:48 <deezn> Hey guys.. how do I go about reading in cmd line args in haskell?
21:34:23 <heatsink> getArgs in System.Environment gets the command line arguments
21:34:40 <MP2E> there's a number of ways, I like to use optparse-applicative to build my command-line parser https://hackage.haskell.org/package/optparse-applicative
21:34:46 <deezn> thanks heatsink.
21:34:46 <MP2E> but yeah for something simple, getArgs works well
21:35:09 <deezn> it is simple.. so that will do. I will go have a look at the doc for it now. 
21:35:47 <ski> @let infix 5 \\\; (\\\) :: Ord a => [a] -> [a] -> [a]; xs \\\ [] = xs; [] \\\ _ = []; xs0@(x:xs) \\\ ys0@(y:ys) = case x `compare` y of LT -> x : (xs \\\ ys0); EQ -> xs \\\ ys; GT -> xs0 \\\ ys
21:35:48 <lambdabot>  Defined.
21:36:01 <ski> @let infix 5 /|\; (/|\) :: Ord a => [a] -> [a] -> [a]; [] /|\ ys = ys; xs /|\ [] = xs; xs0@(x:xs) /|\ ys0@(y:ys) | x <= y = x : (xs /|\ ys0) | otherwise = y : (xs0 /|\ ys)
21:36:02 <lambdabot>  Defined.
21:36:14 <ski> @let merge :: Ord a => [[a]] -> [a]; merge = loop [] where loop xs [] = xs; loop xs ([]:yss) = loop xs yss; loop [] (ys:yss) = loop ys yss; loop xs0@(x:xs) yss0@((y:ys):yss) | x <= y = x : loop xs yss0 | otherwise = y : loop (xs0 /|\ ys) yss
21:36:15 <lambdabot>  Defined.
21:36:37 <ski> > let primes = case [2 ..] \\\ composites of {~(2:ps) -> 2:ps}; composites = merge [[n*p | p <- primes] | n <- [2 ..]] in primes
21:36:39 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
21:37:29 <lamefun> heatsink: so programs can be extended with plug-ins?
21:37:36 <Ryanar> newtype Quantity int volume = Quantity (Int, Volumes)
21:37:36 <Ryanar> instance Monoid (Quantity) where
21:37:36 <ski> "primes are integers greater than one that are not composites (two is a prime). composites are products of primes and integers greater than one"
21:37:45 <Ryanar> I am not sure why this isn't allowed
21:38:09 <glguy> 03newtype Quantity 07= Quantity (Int, Volumes)
21:38:26 <Cale> Ryanar: It's not allowed because a Monoid must have kind *
21:38:34 <glguy> With your definition: Quantity :: * -> * -> *, but Monoid expects something with kind *
21:38:43 <Cale> Ryanar: and you gave your Quantity type two type parameters (which you didn't use)
21:38:47 <ski> Ryanar : your `Quantity' isn't a concrete type (but for any given types `int' and `volumes' (those are type variables), `Quantity int volume' is a concrete type)
21:39:17 <glguy> Let's call it a tie
21:39:23 <Ryanar> ah ok
21:39:31 <Ryanar> I had done that earlier and misread the error I got following
21:39:37 <Ryanar> thinking it was with how I had defined it
21:40:10 * ski ties the knot
21:44:44 <heatsink> lamefun: Pieces of software can take function parameters representing their customizable behavior.
21:45:25 <Axman6> glguy: does your haskell irc client support support multiple servers?
21:45:55 <Axman6> I almost want to drop irssi just for the syntax highlighting stuff =)
21:46:17 <heatsink> lamefun: In Haskell, it's more common to provide functionality as a library instead of as a program.  You customize it by passing your functionality to the library.
21:46:49 <glguy> No. I've segmented off most of the stuff specific to a particular server, but I never actually finished support for it. I don't use more than Freenode so it hasn't been at the top of mind :)
21:47:40 <glguy> I'm sure you could add highlighting to irssi with a couple lines of script shelling out to HsColor or similar though
21:59:29 * hackagebot ide-backend-server 0.9.0 - An IDE backend server  http://hackage.haskell.org/package/ide-backend-server-0.9.0 (MichaelSnoyman)
22:00:46 <deezn> guys: ‚Äú    lexical error in string/character literal at end of input‚Äù
22:01:02 <deezn> does that mean I dont have an EOF in my textfile?
22:01:36 <glguy> It means you forgot to close a string or character literal
22:01:50 <deezn> hmm.. 
22:02:16 <deezn> ops.. 
22:02:25 <deezn> yep thanks.. was missing a ‚Äú
22:14:17 <andyf> Referring back to the discussion earlier on referential transparency, and definitional equality, is there any automated way to prove whether some user-defined (==) is equivalent to definitional equality, for the purposes of referential transparency?
22:14:29 * hackagebot scalpel 0.1.3.1 - A high level web scraping library for Haskell.  http://hackage.haskell.org/package/scalpel-0.1.3.1 (fimad)
22:15:18 <andyf> definitional equality seems like a limited definition of equality that isn‚Äôt nearly as useful as wider equivalence relations, at least for some data types.
22:15:55 <heatsink> Not in Haskell
22:16:07 <enthropy> what's wideness of an equivalence relation?
22:17:33 <ski> presumably they mean "coarser equivalence relations"
22:18:19 <ski> (i'm not sure if by "definitional equality" they mean "structural equality")
22:18:25 <ski> andyf : btw, "Referential Transparency, Definiteness and Unfoldability" by Harald S√∏ndergaard,Peter Sestoft in 1987-11-30 - 1990-01-04 at <http://www.cs.tufts.edu/~nr/cs257/archive/peter-sestoft/ref-trans.pdf> might perhaps be interesting
22:18:29 <ski> you could also check out
22:18:35 <ski> @where purely-functional
22:18:35 <lambdabot> "What is a Purely Functional Language?" by Amr Sabry in 1993-01 at <https://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps>
22:19:33 <andyf> thanks for the pointers.
22:20:23 <ski> (you could also perhaps confirm or deny my guesses)
22:21:20 <andyf> I got into a discussion here a couple of hours ago about what referential transparency means, and whether a hash set type that has an (==) defined to be true when two sets contain the same set of elements, even if a function like toList could return differently ordered lists of items for two (==) sets x and y, would mean referential transparency was ‚Äòbroken‚Äô/
22:21:43 <andyf> The conclusion was not that referential transparency was broken, but that (==) was not the same as definitional equality.
22:22:10 <andyf> That got me thinking on how useful of a concept definitional equality is for such data types.
22:22:18 <andyf> It seems not very useful for such data types.
22:25:06 <heatsink> The hash set sounds like a quotient type
22:26:51 <deezn> gut what do I need to do to use digitToInt '3' 
22:26:53 <deezn> *guys
22:27:04 <heatsink> There's an equivalence relation representing "contains the same key-value pairs"
22:27:25 <heatsink> and I guess you'd rely on definitional equality to help define that equivalence relation?
22:27:31 <erikd> deezn: import Data.Char
22:27:40 <deezn> ahh thx
22:29:30 <andyf> heatsink: from my quick reading of Wikipedia‚Äôs page on quotient type, it sounds like a good fit.
22:30:20 <andyf> heatsink: Are there any Haskell types that don‚Äôt define an equality operator that is different than definitional equality?
22:31:33 <ski> andyf : the conclusion, where ?
22:32:21 <andyf> ski: I don‚Äôt understand if you are asking me a question, and if so, what the question is.
22:32:24 <heatsink> I'm not clear on what definitional equality is.
22:33:09 <ski> andyf : i would consider "a hash set type that has an (==) defined to be true when two sets contain the same set of elements, even if a function like toList could return differently ordered lists of items for two (==) sets x and y" broken
22:33:27 <ski> (as long as that `toList' function was exported)
22:34:00 <andyf> ski: A couple of hours ago, some people believed that Data.HashSet was broken in that way.
22:35:00 <andyf> because it does not require a total order on its set elements, and hash collisions between items mean toList‚Äôs order depends upon the order that (hash-colliding) set elements are added.
22:35:33 <andyf> heatsink: I may not be clear on it, either, but I assumed it meant ‚Äúthe = used in definitions of functions‚Äù
22:36:11 <ski> "Are there any Haskell types that don‚Äôt define an equality operator that is different than definitional equality?" -- how about `Bool' ?
22:37:32 * ski prefers how Mercury handles this issue, to how Haskell does it
22:38:51 <heatsink> IIRC, definitional equality has to do with formalization of logical inference systems
22:39:07 <heatsink> In general, you have to do some computation to decide whether two terms are equal
22:39:27 <andyf> ski: So you would prefer a hash set that had nothing like a toList function defined for it?  Doesn‚Äôt that make the set fairly unuseful if you have no way to enumerate its elements?
22:39:30 * hackagebot timezone-olson-th 0.1.0.0 - Load TimeZoneSeries from an Olson file at compile time.  http://hackage.haskell.org/package/timezone-olson-th-0.1.0.0 (petterb)
22:39:34 <heatsink> but at some point, you get to a point where you can just decide that things are equal
22:39:42 <ski> heatsink : iiuc, andyf is talking about structural equality
22:39:55 <heatsink> oh, okay
22:41:42 <ski> andyf : you could have `toAscList :: Ord a => HashSet a -> [a]' as well as `getList :: HashSet a -> NonDet a', where `NonDet' would be a monad expressing the indeterminacy of the operation (there would be an operation `selectNonDet :: NonDet a -> IO a', and perhaps an `unsafeSelectNonDet :: NonDet a -> a')
22:42:38 <deezn> I need to convert this: words "1 2 3 4 5 6 7" aka [‚Äú1‚Äù,‚Äù2‚Äù,‚Äù3‚Äù,‚Äù4‚Äù,‚Äù5‚Äù,‚Äù6‚Äù,‚Äù7‚Äù] ‚Äî> into [1,2,3,4,5,6,7]. But map (map digitToInt) (words "1 2 3 4 5 6 7") gives me [[]]. Surely this is a smarter way to do this?
22:43:44 <heatsink> > map (map digitToInt) (words "1 2 3 4 5 6 7")
22:43:46 <lambdabot>  [[1],[2],[3],[4],[5],[6],[7]]
22:44:29 <deezn> yeah gives me [[]] meant above.. an list of lists
22:44:31 * hackagebot hruby 0.3.1.1 - Embed a Ruby intepreter in your Haskell program !  http://hackage.haskell.org/package/hruby-0.3.1.1 (SimonMarechal)
22:44:42 <mniip> deezn, are those numbers or digits
22:44:50 <kadoban> > concatMap (map digitToInt) (words "1 2 3 4 5 6 7")
22:44:52 <lambdabot>  [1,2,3,4,5,6,7]
22:44:59 <deezn> kadoban.. 
22:45:06 <deezn> awesomeness.
22:45:07 <heatsink> > concatMap (map digitToInt) (words "12 3")
22:45:09 <lambdabot>  [1,2,3]
22:45:11 <kadoban> :)
22:45:20 <heatsink> Is that what should happen?
22:45:31 <deezn> yeah.. then I can sum them!
22:45:34 <mniip> :t digitToInt
22:45:34 <lambdabot> Char -> Int
22:45:47 <heatsink> Then you don't need 'words'
22:45:59 <heatsink> > map digitToInt $ filter isDigit "1 2 3 4 5 6 7"
22:46:01 <lambdabot>  [1,2,3,4,5,6,7]
22:46:32 <heatsink> That applies digitToInt to the digits in the string
22:47:36 <ski> > [ns | (ns,s) <- many (StateT (reads :: ReadS Integer)) `runStateT` "6 28 496 8128",("","") <- lex s]
22:47:37 <lambdabot>  [[6,28,496,8128]]
22:51:42 <mniip> :t until
22:51:43 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
22:53:46 <deezn> if I have foo :: IO () and I pass it two arguments from the cmdline is that ok?
22:54:29 <deezn> I don‚Äôt think so as I am getting: Couldn't match expected type ‚Äò[Char] -> [Char] -> t‚Äô with actual type ‚ÄòIO ()‚Äô
22:54:53 <ski> `foo' there is not a function, so it doesn't accept any argument(s)
22:55:33 <kadoban> deezn: You can do cmdline arugments in haskell, but ‚Ä¶ you don't do them like that.
22:55:37 <deezn> I am confused?
22:56:16 <deezn> there is more to it‚Ä¶ that is just its decloration
22:57:03 <deezn> it is an action?
22:58:09 <Axman6> deezn: foo :: IO () is not a function, it doesn't accept any arguments. if you want to get access to the command line arguments, you'll need to use the getArgs function from System.Environment
22:58:17 <Axman6> @hoogle getArgs
22:58:19 <lambdabot> System.Environment getArgs :: IO [String]
22:58:19 <lambdabot> System.Posix.Env.ByteString getArgs :: IO [ByteString]
22:58:19 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: MonadIO m => m (String, [String])
23:00:06 <deezn> Axman6: I did use in the getArgs in the body of foo. I am definetly confused
23:00:42 <Axman6> deezn: you'll have to share some code then, becauseyou haven't given us enough information to be able to help you
23:01:12 <nkpart> Is it possible to specify the 'dist' folder location when using cabal?
23:01:39 <deezn> http://lpaste.net/1931964783246966784
23:03:16 <deezn> Axman6: Above‚Ä¶
23:04:29 <Axman6> what exactly is your problem?
23:06:14 <Axman6> > map digitToInt ['0'..]
23:06:15 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,*Exception: Char.digitToInt: not a digit ':'
23:06:50 <Axman6> > map intToDigit [0..]
23:06:51 <lambdabot>  "0123456789abcdef*Exception: Char.intToDigit: not a digit 16
23:07:11 <Axman6> might want to be careful of both those cases; those functions only work on a small range of inputs
23:07:31 <deezn> Couldn't match expected type ‚Äò[Char] -> [Char] -> t‚Äô with actual type ‚ÄòIO ()‚Äô
23:07:32 <deezn>     Relevant bindings include it :: t (bound at <interactive>:5:1) The function ‚Äòmain‚Äô is applied to two arguments, but its type ‚ÄòIO ()‚Äô has none
23:08:10 <Axman6> you don't even have a main function in your paste
23:08:30 <glguy> If you want to execute "main" with specific arguments from GHCi you can use the :main command
23:08:36 <deezn> ignore that I added it in ,, it is the same fucntion you are looking at 
23:08:42 <Axman6> but I am guessing you're doing something like this in ghci: main "infile" "outfile"
23:08:48 <glguy> main :: IO (), so it isn't a function itself, and you can't apply it to arguments
23:08:49 <deezn> same error as I posted originally. 
23:09:05 <deezn> totally confused.. 
23:09:11 <deezn> ok I will go look more. 
23:09:51 <deezn> foo should retrieve two filenames which are given as a command line argument, read the file specified in the first command line argument.
23:10:00 <glguy> deezn: just replace main with :main
23:10:04 <Axman6> deezn: in ghci, you can use :main <args> to call main with some arguments
23:10:17 <deezn> ok I will try
23:11:15 <glguy> If you want to turn an Int into a String, use show rather than [intToDigit _]
23:12:19 <deezn> I will focus on the implementation in a bit. I am confused. If I cannot pass foo args then how can do what is requested?
23:12:46 <glguy> What's foo?
23:12:54 <JohnLIAN_> ...
23:13:39 <Axman6> deezn: getArgs returns the arguments passed to the executable when you compile it
23:13:40 <JohnLIAN_> I thought no body here
23:14:13 <kadoban> deezn: Soo, really not meant as a "go away", but what have you used to learn haskell? https://github.com/bitemyapp/learnhaskell has some good advice if you need some learning materials.
23:14:30 <Axman6> also #haskell-beginners
23:15:05 <glguy> deezn: In Haskell the command line arguments aren't passed to main as function arguments like they are in other languages. In Haskell main isn't a function.
23:15:13 <deezn> I have used http://book.realworldhaskell.org/read/io.html and http://learnyouahaskell.com/input-and-output
23:15:47 <deezn> But functional programming is odd when you come from other styles.. so I am not retarded just confused.
23:16:31 <deezn> ok glguy.. so the arguments aren‚Äôt given at run time?
23:16:44 <deezn> ‚ÄúAxman6: deezn: getArgs returns the arguments passed to the executable when you compile it‚Äù
23:16:52 <glguy> They are specified at run-time, they just aren't passed to main as function arguments
23:17:12 <deezn> So what is the process then?
23:17:19 <Axman6> deezn: helping will be easier if you give us more information though. the more code you can share and the more you can tell us about what you're doing that doesn't work and what you want to happen the easier everyone's life will be =)
23:17:22 <glguy> getArgs doesn't return the "compile time arguments", that was just a misspeak
23:17:54 <glguy> What you pasted was fine, the problem was how you were trying to run your program
23:18:10 <Axman6> deezn: you need to compile your program and then run the executable with the arguments. alternatively you can use :main <arguments in GHCI to run main within ghci
23:18:26 <Axman6> I don't know why I used different cases for ghci there...
23:18:36 <deezn> yeah I have been running it from GHCi and that is the error I get
23:18:52 <glguy> and then we told you to use :main instead 
23:19:04 <Axman6> but you haven't told us exactly what you've been running in ghci
23:19:11 <deezn> foo ‚Äúinput.txt‚Äù ‚Äúoutput.txt‚Äù 
23:19:16 <deezn> tried the main with the same
23:19:25 <deezn> Same error: Couldn't match expected type ‚Äò[Char] -> [Char] -> t‚Äô
23:19:26 <deezn>                 with actual type ‚ÄòIO ()‚Äô
23:19:47 <glguy> write this:  withArgs ["input.txt","output.txt"] foo
23:19:52 <Axman6> right, so that's trying to pass the arguments "input.txt" and "output.txt" to the function foo, but foo doesn't accept any arguments
23:20:09 <Axman6> glguy: that's a thing? :o
23:20:46 <deezn> ok so again what am confused about based on the spec: foo should retrieve two filenames which are given as a command line argument, read the file specified in the first command line argument. That files must contain a list of integers, one per line, and print the sum of these numbers into the second file given as a command line argument. Is how do I get to the cmdline arguements?
23:21:00 <glguy> getArgs
23:21:32 <glguy> Axman6: For as long as I can remember ^_^ http://hackage.haskell.org/package/base-4.8.0.0/docs/System-Environment.html#v:withArgs
23:21:42 <deezn> http://lpaste.net/1931964783246966784
23:21:50 <deezn> arent I using getArgs?
23:22:15 <glguy> What happened when you tried what I wrote here: [23:19] glguy: write this:  withArgs ["input.txt","output.txt"] foo
23:22:28 <deezn> will do it now
23:22:31 <glguy> You're showing me a paste that has no "foo"
23:22:39 <glguy> which makes it hard to guess what you're actually doing
23:24:46 <deezn> sumFile is foo
23:25:45 <deezn> Any person can copy my code and I will get can get in trouble for plagiarism.. hence why I am reluctant paste my code‚Ä¶ and be extremely verbose about what I am doing. 
23:26:03 <deezn> I am sure I am not the only student from my class that pops on here. 
23:26:27 <glguy> Don't worry, if they copy that code they'll lose a bunch of point :)
23:26:36 <glguy> You've got some fixing to do still
23:26:39 <deezn> i know
23:27:06 <kadoban> deezn: Heh, that's pretty paranoid.
23:27:20 <deezn> but the point is that I am seeking help without being told what to do. I want to be nudged in the right direction.. as well. 
23:28:00 <deezn> Well no it isnt university hammer us over this point.. and I have seen students hammered when one copies another in a subject that I tutor. 
23:28:21 <deezn> So I think it is not that paranoid at all. 
23:29:30 <kadoban> If you have IRC logs of you asking for help and some kind of logs of you writing the code, I'd think it'd be pretty easy to prove you were innocent.
23:30:38 <glguy> Anyway, university plagiarism policies are off-topic :) let's get back to the Haskell
23:30:45 <deezn> yeah well yes that is a point but it pays to air on the side of caution in my experience. 
23:30:51 <deezn> ok.. 
23:32:21 <deezn> So why does withArgs ["input.txt","output.txt"] foo work?
23:32:29 <deezn> (it doesnt ‚Ä¶ but it runs)
23:32:41 <verement> err
23:35:05 <solatis> hmmm i'm wondering
23:35:19 <solatis> i have some data types that implement Binary at the moment
23:35:20 <kadoban> deezn: It does magic internal stuff to execute an IO () with pretend "command-line arguments", that you supply. It's the same thing that assigning main = foo  would do when you ran the executable.
23:35:35 <solatis> and they often have to be converted into each other
23:35:47 <solatis> right now, this means doing a Binary.decode . Binary.encode
23:35:52 <solatis> is there a more clever way to do this?
23:35:58 <solatis> this is what I mean:
23:36:06 <solatis> -- | Encodes a 'Transaction' object into a hex representation.
23:36:07 <solatis> encode :: Transaction -> HS.HexString
23:36:07 <solatis> encode = B.decode . B.encode
23:36:45 <solatis> of course this makes it super clear what is going on, so it might be a better thing to just keep it as it is
23:37:02 <solatis> the other alternative seems to be to make HexString a typeclass ?
23:37:46 <solatis> so that each data type that should be convertable to and from a hex string implements the Binary interface ?
23:39:33 * hackagebot elm-compiler 0.15 - Values to help with elm-package, elm-make, and elm-lang.org.  http://hackage.haskell.org/package/elm-compiler-0.15 (EvanCzaplicki)
23:44:33 * hackagebot elm-package 0.5 - Package manager for Elm libraries  http://hackage.haskell.org/package/elm-package-0.5 (EvanCzaplicki)
23:44:35 * hackagebot elm-make 0.1.2 - A build tool for Elm projects  http://hackage.haskell.org/package/elm-make-0.1.2 (EvanCzaplicki)
23:44:37 * hackagebot elm-repl 0.4.1 - a REPL for Elm  http://hackage.haskell.org/package/elm-repl-0.4.1 (EvanCzaplicki)
23:49:33 * hackagebot elm-reactor 0.3.1 - Interactive development tool for Elm programs  http://hackage.haskell.org/package/elm-reactor-0.3.1 (EvanCzaplicki)
23:57:54 <EvanR> solatis: uh dont you want to just have a thing that converts bytestrings to hex strings and back instead and not worry about the content
