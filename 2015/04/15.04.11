00:09:50 * hackagebot gl 0.7.5 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.7.5 (Polarina)
00:09:50 * hackagebot packed-dawg 0.2.0.5 - Generation and traversal of highly compressed directed acyclic word graphs.  http://hackage.haskell.org/package/packed-dawg-0.2.0.5 (AndrasKovacs)
00:10:21 <Polarina> hackagebot, stop repeating yourself!
00:41:20 <quazimodo> does Johan Henriksson (Mahogny) still frequet this channel
00:41:23 <quazimodo> !seen mahogny
00:41:32 <quazimodo> ,seen
00:41:34 <quazimodo> any bots?
00:42:08 <quazimodo> sta
00:54:47 * hackagebot cryptsy-api 0.2.1 - Bindings for Cryptsy cryptocurrency exchange API.  http://hackage.haskell.org/package/cryptsy-api-0.2.1 (bss)
01:02:09 <Gurkenglas> Since https://github.com/ekmett/lens/blob/master/examples/Pong.hs is in the lens package, can I run pong from any ghci prompt? If so, how?
01:10:12 <Gurkenglas> https://www.haskell.org/hoogle/?hoogle=when says when :: Monad m => Bool -> m () -> m () . http://hackage.haskell.org/package/base-4.8.0.0/docs/Control-Monad.html#v:when says when :: Applicative f => Bool -> f () -> f () .
01:23:17 <quazimodo> do I a) learn more abstract category theory or b) sharpen my woodworking plane blade in my living room
01:29:46 <lolisa> quazimodo, do first :) I am also learning cat theory, so we can aid each other :)
01:30:20 <mikeplus64> dog theory has more real world applications
01:30:34 <lolisa> lol :)
01:30:58 <lolisa> I am interested in cat theory only because I wanted to learn HOTT, so I am picking up some basic...
01:46:07 <quazimodo> lolisa
01:46:10 <quazimodo> naw went away?
01:46:20 <quazimodo> anyway
01:47:58 <quazimodo> Is my following assertion accurate: If a type belongs to Functor, that means that the type is a abstractly a category with a specific map (in this case fmap) that behaves as a category theory style Functor, which maps it to another (or the same) category while preserving it's structure?
01:48:29 <quazimodo> and thus fmap can operate on both the elements of the category as well as any morphisms of that category
01:48:47 <quazimodo> pretty reasonable?
01:49:30 <ggVGc> what's the most mature haskell->JS compiler currently?
01:51:13 <rahulmutt> quazimodo, Not necessarily. You have to manually verify that the implementation satisfies the functor laws. You can implement Functor instances that compile but are not valid functors in the category theoretic sense.
01:52:30 <quazimodo> rahulmutt: ok, so if fmap is done correctly and obeys certain rules, then it's a transform on both objects of a category as well as the morphisms on that category
01:52:33 <rahulmutt> ggVGc, GHCJS I would say is the most mature. It supports the largest number of extensions and can compile packages directly from Hackage.
01:53:03 <rahulmutt> quazimodo: Yup
01:53:03 <ggVGc> thanks
01:53:06 <ggVGc> will give it a tryu
01:53:16 <ggVGc> rahulmutt: any reasons to go with another one?
01:53:22 <quazimodo> so if we have ((+) 2) and apply some F being our fmap, then F ((+) 2) is now going to be on some other category
01:53:39 <quazimodo> I wonder if that makes sense
01:53:44 <quazimodo> no it doesn't
01:53:47 <quazimodo> hrm 
01:53:48 <quazimodo> does it?
01:54:31 <quazimodo> hrm
01:54:56 <rahulmutt> ggVGc, depends on what you're going for. GHCJS embeds the entire Haskell runtime into the generated JS so the code will look very nasty. What exactly do you intend to develop?
01:55:52 <ggVGc> rahulmutt: oh, I just want to make a preprocessor/compiler I am writing more platform independent, and it already depends on node.js so I figured I'd just compile the haskell to js and run in node rather than rely on building binaries for each platform
02:00:00 <rahulmutt> quazimodo, F ((+) 2) would be the morphism or function (+) 2 :: (Num a) => a -> a lifted to the morphism in the new category mapped by the functor: F (+ 2) :: f a -> f a, where f denotes the functor itself
02:00:31 <Stratege> is there a Haskell IDE which, at the very least, has a good debugger? (and preferably other features as well)
02:05:08 <quazimodo> rahulmutt: i wish i undestood that on the first read
02:05:14 <quazimodo> hold on, i have to do this to my brain
02:06:07 <quazimodo> https://www.youtube.com/watch?v=DArvPMlxHeQ
02:14:52 <quazimodo> rahulmutt: I think I get it
02:15:49 <quazimodo> rahulmutt: learning category theory has been hard for me, the abstract notions - I've not been good at that, I understand concrete things very well.
02:16:25 <quazimodo> i didn't get around to having even a half formed notion of what monads are till I made them concrete by understanding their purpose
02:17:16 <quazimodo> which, if I'm not mistaken, is to allow arbitrary composition from things that aren't technically functions, and thus can't have certain rules or expectations applied to them
02:17:22 <rahulmutt> quazimodo: Abstract mathematics in general takes a lot of time to  grok well. I find that sleeping on it and doing simple proofs with those concepts enhances the understanding.
02:17:50 <quazimodo> still not sure how accurate that 'reason' for monads is
02:18:03 <quazimodo> from things/of things
02:18:04 <rahulmutt> Learn You a Haskell givesa nice mental model of a Monad as an abstract box with context. I still that mental model even now.
02:18:12 <quazimodo> getting that :)
02:18:32 <quazimodo> i do quite like that publication, the guy/girl who wrote it rocks
02:18:39 <Guest12502> rahulmutt: How does that explain the "((->) r)" monad? :)
02:19:04 <quazimodo> Guest12502: i was readoing about that in learn you a haskell too :P
02:19:05 <ocramz`> quazimodo: composition of control 
02:19:18 <Guest12502> Something to ponder about while I reboot :p
02:19:25 <ocramz`> see the beginning of Ch.14 of Real world Haskell
02:19:56 <ocramz`> freely available online
02:20:01 <quazimodo> ocramz`: shall do
02:20:03 <ggVGc> quazimodo: I am fairly new to haskell, but I have thought of monads kind of like vector fields from calculus
02:20:08 <ggVGc> dunno if that's correct at all
02:20:08 <wz1000> I have a function that maps some characters to their expansions, for example 'a' -> "bc", 'b'->"ca" and so on. How do I write a function that will generate the list of all strings that a character can be expanded to? f 'a' would be equal to ["a","bc","cac"..]
02:20:31 <quazimodo> rahulmutt: your usage of 'lifts', is that idiomatic ?
02:20:32 <ggVGc> does anyone here agree monads share some likeness with vector fields?
02:20:43 <ggVGc> ehh, sorry
02:20:44 <acetoline> well I'm alone on a saturday night and I have no friends; someone show me some interesting haskell code
02:20:44 <rahulmutt> quazimodo: yes
02:20:46 <ggVGc> vector spaces
02:20:46 <ggVGc> not fields
02:21:17 <rahulmutt> ggVGc: Interesting. Can you elaborate on that?
02:23:00 <ggVGc> rahulmutt: well, I don't know haskell/type theory very well(and actually not that much calculus either), but for vector spaces you define a vectory type, and then all operations that are valid on vectors in general are valid for that vector space. So to me a monad is kind of like a vector space
02:23:00 <rahulmutt> wz1000: Seems like non-determinism would help a bit. Have you thought of using the List monad?
02:23:11 <ggVGc> rahulmutt: dunno if that makes sense, or if it is correct in nay way
02:23:14 <ggVGc> any*
02:23:35 <wz1000> rahulmutt: Yeah, I tried but couldn't figure anything out
02:23:44 <quazimodo> rahulmutt: so, if i say it out loud, my ((+) 2) morphism is lifted by F to a new morphism (whatever that may be, depending on what F actually does) that acts on the objects in the collection of another category. Then in haskell does it make sense to use the same F functor to map the objets to the new category?
02:24:27 <ggVGc> rahulmutt: for example getting a dot product is a valid vector operation. And if you define a vector space, then you can get the dot product of vectors in that space. The same way you define a monad and get the monad operators within it
02:24:32 <quazimodo> I noticed you hade F (+ 2) :: f a -> f a ,  F is not f is it
02:24:36 <ggVGc> rahulmutt: I might be completely lost here
02:24:46 <quazimodo> no, f is a type constructor isn't it
02:25:02 <ocramz`> :t fmap
02:25:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:25:30 <rahulmutt> ggVGc: I'm familiar with vector spaces, and I'm not quite getting the parallel. In a very, very general sense I think you'd be correct.
02:25:33 <quazimodo> rahulmutt: does F :: a -> f a
02:25:35 <ocramz`> you take a function, say that turns an apple into a labeled apple, and get a function from boxes of apples to boxes of labeled apples
02:26:27 <ggVGc> rahulmutt: right, so I am probably just wrong then :) I am still very much getting into haskell. I started writing my first real program in it a week ago, and it looks like this, https://github.com/ggVGc/TerseJS/blob/master/indent_to_braces.hs
02:26:34 <rahulmutt> quazimodo: I see here we're suffering from a confusion of notation. I introduced f to denote the Functor itself since you use F to denote fmap.
02:26:48 <quazimodo> rahulmutt: oh
02:26:51 <ggVGc> rahulmutt: what would you say is the biggest error in my parallel that makes it not work out in your head?
02:27:11 <quazimodo> right, i gotcha
02:28:12 <quazimodo> my brain hurts actually
02:31:41 <rahulmutt> quazimodo: You'll learn to love that feeling :P
02:32:27 <ocramz`> quazimodo: keep pushing, great things lie ahead
02:32:39 <quazimodo> rahulmutt: 2 degrees taught me that already :)
02:33:08 <quazimodo> last time i didn't get anything was when I was learning about MRI 
02:33:43 <rahulmutt> quazimodo: your earlier statement about F lifting morphisms as well as F mapping objects to a new category is correct.
02:34:39 <comerijn> Right, so let me repeat my question from yesterday before I give up trying to solve this the pretty way. So I have a type with a promoted kind parameter that I wanna reflect at runtime using the singletons library. But since that requires the SingI instance of that type I have to add this SingI constraint to like 20 functions just to convince GHC that "yes, this parameter always has a SingI instance"
02:34:41 <rahulmutt> As F is a mapping between categories and objects as well as morphisms are the fundamental components, both components should be addressed when defining F
02:35:04 <quazimodo> rahulmutt: excellent
02:35:08 <quazimodo> *hug*
02:35:54 <quazimodo> you just got hugged by a fat iranian with uncharacteristically low density facial hair
02:36:08 <quazimodo> my people... when 2 of them hug it's like velcro
02:36:47 <ocramz`> quazimodo: lol
02:37:05 <Gurkenglas> Recently I was stumbled upon Cofree, which abstracts out the notion of building a datastructure by recursively applying a step function to its own results. What other arcane libraries abstract out oft-repeated patterns?
02:37:32 <ggVGc> quazimodo: is that still a lot of hair by european standards?
02:37:53 <ggVGc> Maybe I'd fit in. I've been called monkey occasionally for most of my post-puberty years
02:38:36 <merijn> Gurkenglas: free, comonad, eh...
02:38:50 <merijn> Gurkenglas: pipes and conduits, but those aren't really arcane
02:41:34 <Byte_> Hey i'm doing a exercise and I could use some opinions about what some properties could mean
02:46:06 <jle`> sure :)
02:51:36 <quazimodo> ggVGc: depends if you're greek or not :P
02:52:16 <quazimodo> i dno, greek is a kind of middle eastern, look at their money management skills and roasted lamb
02:56:04 <ggVGc> so, why does cabal not support having several versions of packages installed at the same time, and instead requires sandboxes?
02:56:09 <ggVGc> or am I misunderstanding something?
02:56:25 <ggVGc> it seems cabal has more dependency problems than any other package manager Ive used
02:57:49 <merijn> ggVGc: No, cabal is just stricter than any other you've used
02:58:52 <ggVGc> merijn: so why are sandboxes necessary rather than just having multiple versions of packages side-by-side?
02:58:52 <merijn> ggVGc: One problem that makes dependencies hard in haskell is that to make performance good GHC fakes whole program optimisation by inlining across modules/packages
02:59:01 <mauke> it does support having several versions installed
02:59:17 <merijn> ggVGc: Oh, that's because GHC only recently supports multiple installed versions of packages
02:59:17 <ggVGc> hm, okay
02:59:18 <mauke> that's what caused the problems that lead to the invention of sandboxes
02:59:33 <merijn> ggVGc: cabal-install hasn't had it's ui updated to work with that
02:59:40 <ggVGc> I see
02:59:45 <merijn> ggVGc: I believe there's a GSoC project to work on that
02:59:56 <ggVGc> so basically in a while, sandboxes won't be needed much?
03:00:10 <merijn> ggVGc: They want to move to a Nix inspired model for GHC and cabal
03:01:45 <merijn> ggVGc: The current problem is that because of this cross library inlining you get into issues where you have package A-1.0 and B-1.0 compiled using A-1.0, resulting in A-1.0 code being inlined into B-1.0, which means that updating your version of A-1.0 would make B-1.0 incompatible, this combined with the huge collection of dependencies of some projects makes things tricky
03:02:13 <ggVGc> yeah, that explains it
03:02:29 <merijn> ggVGc: See also: http://www.well-typed.com/blog/2014/09/how-we-might-abolish-cabal-hell-part-1/
03:02:31 <nshepperd> Gurkenglas: catamorphisms!
03:02:45 <ggVGc> merijn: so basically the core of the issue is that GHC behaves a bit weird in regards to libraries, and library X depending on library Y is actually compiled into library Z
03:02:47 <nshepperd> eh, recursion-schemes
03:03:00 <merijn> ggVGc: One of the big problems is that there's like 2-3 people hacking on cabal, all of whom have full-time jobs unrelated to cabal
03:03:29 <merijn> ggVGc: Well, it's not really "a bit weird", lots of projects are looking at stuff like "link time optimisation" and "whole program optimisation" for performance
03:03:45 <ggVGc> well, I'll try getting involved when I actually know haskell to a decent level, which should be in 5-10 years
03:03:51 <merijn> ggVGc: It's just that whole program optimisation and modularity are kinda of each others enemies :)
03:04:00 <quazimodo> rahulmutt: i like category theory
03:04:06 <quazimodo> so deliciously broad and awesome
03:04:09 <quazimodo> it's like god maths
03:04:33 <ggVGc> merijn: yeah, but it seems a bit strange to me to compile libraries with whle program optimiztion, rather than the final binary
03:05:29 <rahulmutt> ggVGc: I encourage you to try out nix if you want to prevent many headaches later. It's flexible and nice but you need to piece you understanding together from multiple sources.
03:05:35 <merijn> ggVGc: Well, what it's doing is creating interface files and dumping half-compiled versions of "likely" inline candidates in there so that libraries/binaries linking against it can inline those functions
03:05:59 <merijn> ggVGc: For example, lens uses this so that users of lens will end up inlining/compiling away most of the combinators, same for pipes/conduits
03:06:20 <rahulmutt> quazimodo: I do too. Actually, I just recently started venturing into it with Wikipedia articles. So much brain hurt. Still a lot more to explore.
03:06:26 <merijn> ggVGc: But if you have several libraries that are inlining stuff from A and then in turn exposing parts of the inlined stuff in their own inlinable functions...
03:07:04 <merijn> ggVGc: The end result is very efficient/fast code, but the drawback is that it's not easy to update a library without breaking anything depending on it, even if the API doesn't change
03:08:00 <merijn> ggVGc: Now that GHC supports multiple installations of the same library you can just install the same one build with different dependencies, but then you have to make sure the cabal-install UI becomes LESS confusing than it is now, instead of more
03:08:06 <rahulmutt> quazimodo: And yeah the generality is really cool. What fascinates me the most is how cleanly you can represent certain programs using monads and other category theory concepts - something which just seems like some theoretical nonsense .
03:08:08 <merijn> Which is a bit of an unclear issue
03:08:36 <wz1000> Can I use quickselect with the default sort?
03:09:04 <wz1000> Or is it too strict?
03:29:54 * hackagebot html-entities 1.0.0.2 - An "attoparsec" parser and a decoder of HTML entities  http://hackage.haskell.org/package/html-entities-1.0.0.2 (NikitaVolkov)
03:33:16 <ocramz_> just out of curiosity, is anyone else currently doing the Code Jam?
03:34:50 <etqqkoiflwhb> Newbie haskell question. Do lists in haskell support indices which are overboard (negative or exceeded length). Is there any data structure which does?
03:35:43 <kuribas> > [1, 2, 3] !! 4
03:35:45 <lambdabot>  *Exception: Prelude.!!: index too large
03:36:14 <kuribas> etqqkoiflwhb: You mean a safe version of (!!)?
03:36:21 <etqqkoiflwhb> kuribas: yea
03:36:33 <kuribas> idk..
03:37:08 <kuribas> @hoogle [a] -> Int -> Maybe a
03:37:10 <lambdabot> Prelude (!!) :: [a] -> Int -> a
03:37:10 <lambdabot> Data.List (!!) :: [a] -> Int -> a
03:37:10 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
03:37:20 <etqqkoiflwhb> kuribas: For example, in ruby I can do [:north, :west, :south, :east][-1]
03:37:21 <pantsman-> there is 'atMay' in the 'safe' package
03:38:17 <kuribas> You could catch it, but that's ugly.
03:38:50 <alynn> :t (listToMaybe .) . drop
03:38:50 <lambdabot> Int -> [a] -> Maybe a
03:38:53 <kuribas> etqqkoiflwhb: But in ruby doesn that return from the end?
03:38:54 <alynn> ^
03:39:44 <etqqkoiflwhb> kuribas: yea, want to the exact behaviour here
03:40:08 <kuribas> etqqkoiflwhb: Then you need to write it.
03:40:23 <etqqkoiflwhb> kuribas: ah, ok
03:40:32 <pantsman-> that wouldn't be ideal for a lazy linked list, you'd have to compute the whole spine of the list just to find its length first
03:40:40 <jle`> :t \n -> listToMaybe . drop n
03:40:41 <lambdabot> Int -> [a] -> Maybe a
03:40:45 <exio4> etqqkoiflwhb: if you are doing those kind of operations, a different data structure may be better
03:41:22 <ggVGc> are there any intetions of making something like this part of core haskell/ghc/cabal? http://plv.mpi-sws.org/backpack/
03:41:47 <exio4> etqqkoiflwhb: maybe a Sequence is what you want, lazy lists are nice as "first-class control structures", not so good for real world data (normally) :P 
03:42:26 <etqqkoiflwhb> exio4: cool, reading Sequence's docs
03:42:58 <etqqkoiflwhb> Here's what I wrote to find the adjacent direction (both left, right) https://gist.github.com/anonymous/6bc9810c84b427910c2d#file-try-haskell-L8
03:43:02 <etqqkoiflwhb> didn;t seem elegant
03:44:45 <kuribas> etqqkoiflwhb: you can use Enum
03:45:00 <kuribas> :i Enum
03:45:15 <merijn> ggVGc: ezyang is working on backpack in GHC right now
03:45:24 <ggVGc> nice
03:45:33 <kuribas> :t Enum
03:45:34 <lambdabot>     Not in scope: data constructor ‘Enum’
03:45:34 <lambdabot>     Perhaps you meant variable ‘enum’ (imported from Control.Lens)
03:45:35 <ggVGc> merijn: that seems to be the best solution I've read about so far
03:45:36 <kuribas> :t fromEnum
03:45:37 <lambdabot> Enum a => a -> Int
03:45:48 <merijn> ggVGc: Hence the cabal 1.22 ghc-mod issues people are running into, cabal got changed to accomodate backpack's changes in GHC
03:46:56 <ggVGc> nice
03:47:45 <pantsman-> with the ghc package for emacs (i.e. the one for ghc-mod), can I disable the type checking on save? I just want to use the other features like finding the type of an expression
03:48:13 <kuribas> :t succ
03:48:14 <lambdabot> Enum a => a -> a
03:48:27 <kuribas> etqqkoiflwhb: You can use succ and pred
03:48:33 <kuribas> > succ True
03:48:35 <lambdabot>  *Exception: Prelude.Enum.Bool.succ: bad argument
03:49:06 <kuribas> hm, maybe not
03:49:12 <etqqkoiflwhb> kuribas: yea, trying them, thanks
03:50:30 <kuribas> > toEnum $ (% 2) $ (+1) $ fromEnum True
03:50:31 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘Ratio Int’
03:50:31 <lambdabot>      In the second argument of ‘($)’, namely
03:50:31 <lambdabot>        ‘(% 2) $ (+ 1) $ fromEnum True’
03:50:38 <kuribas> > toEnum $ (mod 2) $ (+1) $ fromEnum True
03:50:39 <lambdabot>  ()
03:51:53 <kuribas> > toEnum $ (`mod` 2) $ (+1) $ fromEnum True
03:51:54 <lambdabot>  ()
03:52:23 <kuribas> > (toEnum $ (`mod` 2) $ (+1) $ fromEnum True) :: Bool
03:52:24 <lambdabot>  False
03:53:29 <alynn> there are much more efficient ways of implementing not
03:53:42 <kuribas> lol
03:54:23 <kuribas> alynn: I was going for a wrapping "succ".
03:54:33 <exio4> > ((toEnum . (1-) . fromEnum) :: Bool -> Bool) True
03:54:34 <lambdabot>  False
03:54:37 <exio4> > ((toEnum . (1-) . fromEnum) :: Bool -> Bool) False
03:54:38 <lambdabot>  True
03:54:39 <alynn> a wrapping 'succ' _is_ not
03:55:16 <kuribas> alynn: What would you do then?
03:55:23 <alynn> succ = not
03:55:37 <alynn> also I wouldn't, succ is supposed to error if you pass it maxBound
03:56:26 <alynn> (hooray for slightly questionable laws!)
03:56:30 <jellie> Guys, can anyone build wreq after those library as it is right now?
03:56:37 <arkeet> > let f x = if x == maxBound then minBound else succ x in [f False, f True]
03:56:38 <lambdabot>  [True,False]
03:56:41 <kuribas> alynn: You contradict yourself
03:56:42 <jellie> argghhh bad grammar
03:56:50 <jellie> Can anyone build wreq right now?
03:56:52 <arkeet> > let f x = if x == maxBound then minBound else succ x in [f LT, f EQ, f GT]
03:56:53 <lambdabot>  [EQ,GT,LT]
03:57:04 <jellie> I get the following error: http://lpaste.net/181290560974225408
03:57:10 <alynn> kuribas: let me rephrase then
03:57:15 <jellie> There are so many library errors nowadays :(
03:57:36 <alynn> the wrapping '+ 1' function on bools is 'not'
03:57:41 <alynn> which is rather like succ
03:57:55 <alynn> but Enum requires that succ, if implemented, throws a runtime error if you pass it maxBound
03:57:58 <alynn> which for Bools is True
03:58:10 <kuribas> alynn: So it not like succ at all...
03:58:41 <alynn> succ is non-wrapping by definition
03:58:53 <alynn> you were talking about implementing a wrapping succ, let's call it "wrapSucc"
03:58:56 <alynn> then wrapSucc = not
03:59:28 <alynn> @check \x -> (fromEnum . (`mod` 2) . (+ 1) . toEnum) x == not x
03:59:29 <lambdabot>  Couldn't match expected type ‘Int’ with actual type ‘Bool’
03:59:30 <lambdabot>  In the second argument of ‘(==)’, namely ‘not x’ In the expression: (fromEnu...
04:00:15 <alynn> @check \x -> ((fromEnum . (`mod` 2) . (+ 1) . toEnum) :: Bool -> Bool) x == not x
04:00:16 <lambdabot>  Couldn't match type ‘Int’ with ‘Bool’
04:00:17 <lambdabot>  Expected type: Integer -> Bool Actual type: Integer -> Int In the first argu...
04:00:32 <alynn> hrmph
04:00:44 <exio4> @type (toEnum , fromEnum)
04:00:45 <lambdabot> (Enum a, Enum a1) => (Int -> a, a1 -> Int)
04:00:50 <alynn> :t (fromEnum . (`mod` 2) . (+ 1) . toEnum)
04:00:51 <lambdabot> Int -> Int
04:00:52 <exio4> alynn: you've got toEnum and fromEnum in the wrong order
04:00:56 <alynn> aha
04:01:04 <alynn> :t (toEnum . (`mod` 2) . (+ 1) . fromEnum)
04:01:05 <lambdabot> (Enum c, Enum a) => a -> c
04:01:15 <alynn> @check \x -> (toEnum . (`mod` 2) . (+ 1) . fromEnum) x == not x
04:01:16 <lambdabot>  +++ OK, passed 100 tests.
04:01:21 <alynn> ^
04:07:11 <statusfailed> weird. I have a function which compiles. I take the inferred type signature from ghci, but if I paste it in as the type signature for that function, it no longer compiles
04:07:29 <statusfailed> shouldn't that never happen?
04:07:45 <merijn> statusfailed: Which version of GHC?
04:08:04 <merijn> And how did it stop compiling? Error? Is it a local function?
04:08:05 <statusfailed> merijn: 7.10
04:08:13 <statusfailed> 7.10.1 sorry
04:08:26 <statusfailed> merijn: the function is in a file, i'm compiling with :r in GHCi
04:08:32 <statusfailed> merijn: what do you mean "local function" ?
04:08:39 <merijn> let/where clause
04:09:25 <statusfailed> merijn: no it's top level
04:09:49 <merijn> lpaste the code + error?
04:09:57 <statusfailed> suer
04:09:59 <statusfailed> sure*
04:12:26 <lpaste> statusfailed pasted “Type signature error” at http://lpaste.net/130527
04:12:33 <statusfailed> merijn: pasted
04:13:26 <jellie> guys library breakage left right and center :(
04:14:11 <statusfailed> jellie: ?
04:14:56 * hackagebot csound-expression-dynamic 0.1.3 - dynamic core for csound-expression library  http://hackage.haskell.org/package/csound-expression-dynamic-0.1.3 (AntonKholomiov)
04:15:01 <jellie> statusfailed: Right now it was wreq
04:15:37 <jellie> Yesterday it was ghci-ng and I think ghc-mod. I can't even remember. So much library breakage.
04:15:50 <statusfailed> jellie: I'm totally lost :-)
04:16:11 <merijn> jellie: That's the risk of staying at the bleeding edge...
04:16:19 <jellie> I think I'll just wait for maintainers to fix. When I try to fix it. The deps of e.g wreq in this case are also having issues.
04:16:22 <jellie> merijn: :(
04:16:30 <jellie> statusfailed: What don't you understand?
04:16:58 <jellie> merijn: I was cloning and trying to fix repos almost all night yesterday. I didn't succeed even once :(
04:17:20 <jellie> Deleting all these repos in my ~/src/haskell
04:18:08 <merijn> statusfailed: I have no idea why you expect that type to work?
04:18:28 <merijn> statusfailed: fromChan returns "SourceT m a"
04:18:39 <statusfailed> merijn: that's what GHCi infers if you do :t mergeASync
04:18:46 <statusfailed> I literally just copy pasted it
04:18:56 <merijn> so "return $ fromChan c" would be "SourceT m a" would be like "IO (SourceT m a)"
04:19:18 <jellie> statusfailed: How was I unclear?
04:19:47 <statusfailed> jellie: oh I didn't know what you meant by "breakage". With you now
04:19:56 * hackagebot csound-expression-typed 0.0.7.2 - typed core for the library csound-expression  http://hackage.haskell.org/package/csound-expression-typed-0.0.7.2 (AntonKholomiov)
04:19:58 * hackagebot csound-expression 4.5 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-4.5 (AntonKholomiov)
04:20:00 * hackagebot csound-sampler 0.0.5.0 - A musical sampler based on Csound  http://hackage.haskell.org/package/csound-sampler-0.0.5.0 (AntonKholomiov)
04:20:25 <jellie> merijn: How long do you think one should wait before moving to a new compiler?
04:20:38 <merijn> jellie: Depends on how adventurous you are
04:20:47 <jellie> statusfailed: It means a library won't build anymore.
04:20:56 <merijn> jellie: I usually wait until the new platform comes out before upgrading unless I have a reason to upgrade
04:21:54 <statusfailed> merijn: oh, SourceT m a is a synonym for forall k. MachineT m k a btw
04:22:52 <statusfailed> I just don't get how GHCi can be wrong :\
04:23:12 <jellie> statusfailed: How was ghci wrong?
04:23:55 <statusfailed> jellie: I loaded the file, used :t to ask for the type, then pasted that type into the file
04:24:01 <statusfailed> reloading the file gives a type error
04:24:10 <statusfailed> I'm baffled :|
04:24:23 <merijn> statusfailed: Did you copy the forall part of the type?
04:24:42 <statusfailed> merijn: ghci gives no forall part
04:24:54 <Feuerbach> statusfailed: you may have some missing or extra extensions
04:25:00 <statusfailed> Feuerbach: you mean in GHCi ?
04:25:09 <Feuerbach> statusfailed: in ghci or in your source file
04:25:21 <merijn> Feuerbach: Not in GHC 7.10
04:25:38 <Feuerbach> merijn: Not in GHC 7.10 what?
04:25:41 <merijn> Feuerbach: 7.10 now considers it an error if an inferred type would require an extension
04:25:52 <merijn> Feuerbach: Exactly to avoid this sort of problem
04:26:15 <Feuerbach> I'm just saying that ghci and the file may operate in different modes
04:26:29 <statusfailed> Feuerbach: I tried restarting ghci with -XRankNTypes
04:26:33 <Feuerbach> anyway, why are we guessing? statusfailed can you show us the exact code and error?
04:26:40 <statusfailed> Feuerbach: http://lpaste.net/130527
04:27:07 <jellie> statusfailed: hmmm paste?
04:27:24 <statusfailed> jellie: above :)
04:27:27 <jellie> Oh wait I assume it's the one you just posted
04:27:30 <statusfailed> yeah hehe
04:28:14 <statusfailed> what's even weirder, if I replace "left" and "right" with "fmap Left left" and "fmap Right right", respectively, even GHCi gives a type error. I am reasonably sure that should be valid?
04:28:26 <statusfailed> but that's possibly a seperate problem
04:28:35 <jellie> The whole world has changed in 7.10
04:28:44 <statusfailed> jellie: it's a scary new place :(
04:29:00 <jellie> statusfailed: Which line/function has an issue?
04:29:16 <jellie> Arghhh read comments
04:29:24 * jellie should read comments
04:29:38 <jellie> statusfailed: Ignore my last statement
04:29:46 <statusfailed> jellie: I didn't see anything :p
04:32:46 <aruro> In source code of the GHC.Base function pure is defined, but when i start GHCi it is not visible, why?
04:37:54 <jellie> statusfailed: Oh the issue you're referring to has happened to me several times.
04:38:12 <jellie> statusfailed: It usually fix that by using type holes.
04:38:57 <statusfailed> jellie: I've not used them before, how would I do that in this case?
04:38:58 <jellie> Infering types with ghci often causes issues because I'm not sure of this but I think the types ghc infers can be ambiguous.
04:39:24 <int-e> aruro: what's your ghc version? this is related to the Applicative/Monad changes that are new in ghc 7.10.1
04:39:59 <jellie> statusfailed: I don't know for sure. I haven't delved into topics such as concurrency and lens. I could however show you how types are used generally.
04:40:06 <int-e> aruro: note that not everything defined in GHC.Base gets exported by Prelude; what I said is specific to the `pure` function.
04:40:11 <jellie> I mean type holes.
04:40:16 <jellie> or is it typed holes.
04:41:39 <int-e> aruro: oh and of course `pure` existed before, just import Control.Applicative to get it.
04:44:49 <aruro> int-e, my ghc is pretty new
04:44:54 <aruro> month old maximum
04:45:10 <aruro> so now i see that pure moved to control.applicative?
04:46:35 <aruro> i have ghc 7.8.4
04:51:08 <aruro> typeclassopedia is very good, anyone knows similar source but on type system in general?
04:52:09 <ggVGc> man, I've been trying to install ghcjs for 3 hours now
04:52:11 <ggVGc> no luck yet
04:52:14 <ggVGc> :(
04:54:13 <int-e> aruro: 7.10.1 is very recent (a bit over a week now); there is not even a Haskell Platform release for it yet, and I suspect quite a few packages on Hackage are still broken.
04:56:01 <statusfailed> jellie: did you say you didn't get lens to compile?
04:56:03 <bernalex> aruro: typeclassopedia doesn't have a lot to do with type systems as much as just haskell APIs. if you want type systems, consider TAPL or something like that.
04:56:07 <statusfailed> jellie: under GHC 7.10.1
04:56:18 <statusfailed> or was it just wreq
05:03:02 <aruro> ggVGc my friend uses nix for that purpose
05:03:22 <ggVGc> aruro: not sure I know what nix is
05:03:23 <aruro> he was showing a week ago a few ghcjs examples
05:03:48 <aruro> http://nixos.org/
05:03:53 <aruro> its a package manager
05:04:08 <aruro> which apparently helps you to avoid cabal hell :)
05:04:45 <ggVGc> coo
05:04:46 <ggVGc> l
05:04:48 <ggVGc> I will check it
05:04:51 <aruro> yea
05:04:58 * hackagebot reactive-banana 0.8.1.1 - Library for functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.8.1.1 (HeinrichApfelmus)
05:04:58 <ggVGc> but I think I just got ghcjs building!
05:05:01 <ggVGc> only took me all day
05:05:04 <aruro> :D
05:05:40 <aruro> bernalex, what is TAPL?
05:05:56 <bernalex> aruro: types and programming languages by pierce.
05:06:11 <aruro> it is a whole book? :)
05:06:16 <bernalex> aruro: yes.
05:06:20 <aruro> ty
05:06:58 <statusfailed> jellie: latest wreq on github builds OK, just checked
05:07:49 <aruro> ok seems to be a decent book based on the contents
05:07:55 <aruro> there is no online version right?
05:08:19 <bernalex> aruro: I don't know. you can probably obtain an illegitimate pdf copy somewhere.
05:10:00 <aruro> actually there is also other book, called Advanced types in PL
05:10:19 <bernalex> there are actually several other books.
05:10:58 <aruro> if they are good please mention :)
05:11:09 <bernalex> I can wholeheartedly recommend the lord of the rings
05:11:44 <aruro> I have a book called Purely Functional Data Structures
05:11:54 <aruro> should take a loot at it
05:12:02 <bernalex> if you mean type theory books, Practical Fonudations for Programming Languages is very respected.
05:12:38 <aruro> ty
05:45:11 <f-a> is there any caveat to using {-# Language GADTs #-}? Or is it a 'safe' extension?
05:47:58 <merijn> f-a: Most extensions are safe
05:49:45 <f-a> ok, thanks merijn 
06:01:57 <ggVGc> for a language that is so concerned with correctness, it amazes me how impossible it is to build some packages
06:02:07 <ggVGc> 5 hours trying to get ghcjs running now
06:02:19 <ggVGc> but apparently because of ghc 7.10 or cabal or something it's broken :(
06:05:17 <mniip> ggVGc, just a yet another proof that all build systems suck
06:05:24 <ggVGc> :(
06:08:55 <dmj_> Is there a way to specify different ghc versions in a cabal file that produces two executables
06:10:39 <int-e> dmj_: no. different ghc versions require separate install plans, so that's not really something cabal-install is designed for.
06:13:12 <int-e> dmj_: I guess you could set the 'buildable' flag of the executables based on the ghc version and then build the package twice, once with each ghc version.
06:13:38 <dmj_> int-e: thanks, so if I plan on sharing types between executables produced by two different ghc versions, should I just use one cabal file and cabal install each executable seperately
06:13:54 <dmj_> Buildable flag? Tell me more
06:14:56 <int-e> dmj_: if impl(ghc < 7.10) [next line, indented] Buildable: false
06:15:56 <M-ou-se> if i have a  a :: StateT Foo Maybe Int, and a  b :: State Foo Int, how would I make a  c :: State Foo Int  that first tries a, and if it didn't succeed, does b instead?
06:16:51 <int-e> dmj_: Oh I guess it has to be  False (capital F).
06:25:02 * hackagebot Weather 0.1.0.0 - Library for interacting with the Weather Underground JSON API.  http://hackage.haskell.org/package/Weather-0.1.0.0 (bstamour)
06:30:02 * hackagebot z3 4.0.0 - Bindings for the Z3 Theorem Prover  http://hackage.haskell.org/package/z3-4.0.0 (IagoAbal)
06:37:12 <merijn> M-ou-se: Convert b to "StateT Foo Maybe Int" and use <|>/mplus
06:37:27 <merijn> Look at the mmorph package on how to convert from State to StateT
06:37:50 <M-ou-se> merijn: but then c will also be StateT Foo Maybe Int, right? but c (and b) always succeed.
06:39:36 <merijn> Yeah
06:40:11 <merijn> That or write an explicit combinator using runStateT to try both in the right order
06:45:28 <dmj_> int-e: what if it's ghcjs, would  impl still apply
06:53:27 <int-e> dmj_: I don't know; it's really a #hackage question. http://hackage.haskell.org/package/ghcjs-dom-0.1.1.3/ghcjs-dom.cabal suggests that the current Cabal/cabal-install support this, but hackage does not, yet.
07:04:42 <lynnard> how can I convert Fractional a => a to Integer
07:05:44 <mniip> :t toInteger
07:05:45 <lambdabot> Integral a => a -> Integer
07:05:59 <mniip> oh wait, hm
07:06:37 <kuribas> lynnard: floor, round, etc...
07:07:47 <kuribas> :t floor
07:07:48 <lambdabot> (Integral b, RealFrac a) => a -> b
07:08:01 <phaer> Is there a way to get named fields of a record by string? Or should i just pattern match for each field?
07:08:29 <kuribas> hm...
07:08:32 <lynnard> cool thanks
07:08:47 <kuribas> RealFrac /= Fractional
07:11:08 <kuribas> https://wiki.haskell.org/Converting_numbers
07:15:12 * hackagebot stitch 0.3.0.0 - lightweight CSS DSL  http://hackage.haskell.org/package/stitch-0.3.0.0 (Intolerable)
07:15:14 * hackagebot stitch 0.2.0.0 - lightweight CSS DSL  http://hackage.haskell.org/package/stitch-0.2.0.0 (Intolerable)
07:18:57 <kuribas> Isn't it usually better to use Double instead of Floating?
07:19:10 <kuribas> Double is pretty standard on most machines...
07:19:29 <int-e> kuribas: Floating is a type class. Both Double and Float are instances of Floating.
07:20:12 * hackagebot blunt 0.0.17 - Point-free Haskell as a service.  http://hackage.haskell.org/package/blunt-0.0.17 (fozworth)
07:20:20 <kuribas> int-e: yes, so Double would avoid the overhead of a type-class.
07:21:08 <kuribas> Since Float is pretty much useless, that leaves only Double.
07:22:11 <int-e> Well, obviously it depends on what you want to do in the end. ghc is usually quite good at specializing the code. Also, maybe you want to use the code with complex numbers later on? That's another Floating instance...
07:22:25 <sagittarian> why is Float useless?
07:23:03 <kuribas> Since a Float will probably use the same Floating point unit on a processor.
07:23:13 <opqdonut> sagittarian: AFAIK operations are just as fast. you only win in memory if you have lots of packed Floats (vs Doubles)
07:23:40 <opqdonut> or this was the case some years ago when I last cared
07:24:36 <sagittarian> opqdonut: operations (with Float?) are just as fast as what?
07:24:42 <kuribas> int-e: Complex numbers makes sense...
07:25:37 <kuribas> I am writing a little equation solver.  I guess it could work with complex numbers.
07:28:53 <int-e> > showCReal 50 (sin 1)
07:28:54 <lambdabot>  "0.84147098480789650665250232163029899962256306079837"
07:30:31 <kuribas> :t showCReal
07:30:32 <lambdabot> Int -> CReal -> String
07:32:16 <rasen_> Hey guys! Is there a way to quickly parse dates such as RFC822 and RFC3339?
07:32:50 <kuribas> hm, my solver gives for "sin(a) + cos(a + pi/2)": 1.2246467991473532e-16sin(a + 1.5707963267948966).  I'd prefer that to be 0.  The problem is how to determine roundoff in the Floating typeclass?
07:33:03 <rasen_> I found rfc3339 and time-http packages. But they are a bit dated and cause dependency conflicts
07:33:39 <mniip> kuribas, don't mix symbolic math with floating point arithmetic
07:34:33 <kuribas> mniip: it isn't a symbolic solver, but it needs to solve linear equations and angles.
07:34:41 <kuribas> mniip: That's why I have variables...
07:35:47 <kuribas> mniip: The symbolic manipulation is used for intermediate results.
07:36:04 <kuribas> mniip: like metafont.
07:40:13 * hackagebot blunt 1.0.0 - Point-free Haskell as a service.  http://hackage.haskell.org/package/blunt-1.0.0 (fozworth)
07:47:10 <shourya> Hello!
07:48:25 <AWhetter> hello shourya 
07:48:58 <shourya> Sup?
07:50:33 <mniip> interesting
07:50:51 <mniip> any amount of 'flip flip flip flip flip flip' over 3 is equivalent to 3 of them
07:51:07 <AWhetter> shourya: I'm busy writing my thesis. How are you?
07:59:56 <KaneTW> i'm doing a presentation about frp and i want to create an animated signal diagram. now i'm not really sure if i should do an animated gif to better show off continous time semantics or beamer overlays with noticeably discrete steps
08:00:22 <statusfailed> Is there a nice way to build Aeson "Value"s with Data.Aeson.Lens ?
08:00:55 <statusfailed> for example, I want to build the object {"foo": 1, "bar": [1, 2]}
08:01:07 <statusfailed> I could make a hashmap and set the keys, but perhaps there's an easier way?
08:02:27 <AWhetter> KaneTW: My vote is on using beamer overlays. It'll give you more control because you can go back to parts of the animation if you need to. Plus animated gifs can be quite distracting as an audience member imo
08:03:56 <KaneTW> yeah, that's what i thought too
08:06:42 <supki> statusfailed: you can build it from a string with _JSON, e.g.  "{\"foo\": 1, \"bar\": [1, 2]}" ^? _JSON
08:06:46 <jmcarthur> KaneTW: or you could just switch away from the slides for a live demo
08:06:54 <supki> type annotation may be necessary
08:06:55 <jmcarthur> KaneTW: i take it back. never do live demos :)
08:08:34 <KaneTW> statusfailed: you could implement some json parsing quasiquoter
08:13:05 <statusfailed> supki: Yeah, I was hoping to have a nice sort of lensy DSL to avoid using a string
08:13:08 <statusfailed> but no matter :)
08:13:11 <statusfailed> KaneTW: true!
08:14:06 <statusfailed> I was thinking something like: object & key "foo" .~ 1 & key "bar" .~ [1, 2]
08:14:15 <statusfailed> but of course you need to explicitly use constructors for "1" and "[1, 2]"
08:15:09 <statusfailed> also, what happened to the Show instance for UTCTime?
08:17:40 <statusfailed> oh i'm sposed to use Data.Time... nevermind
08:44:10 <ggVGc> could someone help me with this? The error is at the bottom, https://gist.github.com/38a909f97aa18defd51e
08:44:35 <ggVGc> I upgraded ghc and now that broke, but I didn't write those 4 lines of code that are erroring, so I'm lost to the type errors
08:45:07 <ggVGc> i.e I am using code I don't fully understand yet and now it's broken :(
08:45:16 * hackagebot free-functors 0.6.4 - Provides free functors that are adjoint to functors that forget class constraints.  http://hackage.haskell.org/package/free-functors-0.6.4 (SjoerdVisscher)
08:49:09 <indiagreen> ggVGc: I think the easiest way to fix it would be to add type signatures to aTree, aNode, etc
08:49:34 <indiagreen> aNode :: Parser [Tree], probably
08:49:46 <indiagreen> and you would also have to import Text.Parsec.String
08:49:57 <ggVGc> indiagreen: yeah, but.. I don't know the types which is the problem, because i borrowed that code while learning :(
08:50:00 <ggVGc> thanks, will try it
08:50:16 * hackagebot algebraic-classes 0.6 - Conversions between algebraic classes and F-algebras.  http://hackage.haskell.org/package/algebraic-classes-0.6 (SjoerdVisscher)
09:08:44 <quazimodo> hrm
09:13:52 <quazimodo> so say we have some category C, and a morphism (homomorphism?) C(A,B) where A, B are objects belonging to the collection of C, then C(A,B) can be expressed as f : A -> B. So in haskell do we type this f :: C -> C ?
09:14:01 <quazimodo> since it takes an object in C and returns an object in C
09:16:19 <dfeuer> quaestor, morphism===homomorphism. Two words; one thing.
09:17:00 <dfeuer> What is C(A,B)?
09:17:57 <monochrom> f :: A -> B
09:18:00 <merijn> quazimodo: No, it's a morphism from A to B
09:18:02 <hjulle> Are there any other categories in haskell than "Hask"?
09:18:07 <mniip> quazimodo, in Hask, objects are types
09:18:22 <dfeuer> Sure. But Hask is the one we usually deal with.
09:18:24 <merijn> hjulle: Sure, there's even a typeclass for them
09:18:40 <dfeuer> And Kmett has another one or two such....
09:18:43 <quazimodo> mniip: oh, really?
09:18:50 <quazimodo> i thought types represented categories
09:18:54 <dfeuer> But yeah, Control.Category is actually useful.
09:19:04 <dfeuer> Or so they say :-P
09:19:15 <mniip> quazimodo, Hask is similar to Set, where objects are sets
09:19:24 <dfeuer> Haskell types are the objects of the Hask category.
09:19:31 <quazimodo> weird 
09:19:43 <quazimodo> I guess I should have asked that a long time ago
09:19:58 <hjulle> quaestor, No, there is one category, where the types are objects and functions are morphisms.
09:20:16 <quazimodo> i'm not quaestor lol
09:20:23 <hjulle> sorry :p
09:20:25 <quazimodo> there is a singel category?
09:20:31 <mniip> now to confuse you even more, morphisms are also objects in Hask
09:20:31 <quazimodo> and all of our types live in it?
09:20:33 <merijn> Well, since you can consider types as sets and sets are also a categroy...
09:20:49 <merijn> You could consider types as categories too, but it's not common
09:21:09 <hjulle> Yes. This is why all morphisms are homomorphisms. (iirc)
09:21:12 <quazimodo> if there's one category in haskell then why are things called functors
09:21:13 <mniip> er, hom-sets of morphisms are Hask objects
09:21:26 <mniip> they're all actually endofunctors
09:21:28 <roboguy_> quazimodo: A functor can go from a category to itself
09:21:38 <sellers> Does anybody have a recommendation for something to read on introductory category theory?
09:21:43 <merijn> quazimodo: Functor is really an endofunctor on Hask
09:21:46 <hjulle> quazimodo,  I'm reading this right now. I find it helpful: http://math.ucr.edu/home/baez/rosetta.pdf
09:21:47 <merijn> sellers: Yes!
09:21:47 <quazimodo> hrm
09:21:56 <merijn> sellers: http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
09:21:58 <quazimodo> interesting
09:21:59 <geekosaur> hjulle, Hask is not the only category representable in Haskell. Hask is the category representing Haskell types
09:22:43 <sellers> merijn: That looks perfect, thanks
09:23:17 <mniip> merijn, I wonder what are the other category instances
09:23:28 <mniip> those kleisli things?
09:23:30 <hjulle> geekosaur, ok. thanks.
09:23:43 <merijn> mniip: There's probably hundreds you can invent
09:24:20 <mniip> but the laws
09:24:20 <hjulle> I guess everything that can have a valid instance of Control.Category is a Category.
09:24:32 <roboguy_> quazimodo: so (object mapping of) the Maybe functor for instance takes all the types in Hask to the corresponding types in Hask that have Maybe applied to them
09:24:37 <geekosaur> (in fact I think technically that means Hask can't be represented in Haskell...)
09:24:38 <prophile> lots of things can be categories
09:24:47 <prophile> anything with a valid instance of Data.Monoid can be a category
09:25:05 <mniip> geekosaur, Hask can be represented in haskell indeed
09:25:20 <mniip> id=id and (.)=(.)
09:25:30 <sellers> Deep.
09:25:45 <geekosaur> I'm thinking of that law where any formal system is not expressive enough to represent itself?
09:25:49 <shlevy> Hi all. Is there a way to disable the runtime check for a missing branch in a non-exhaustive pattern match? I know that means segfault or other awful crash, but that's desired
09:25:50 <quazimodo> when all of this clicks it's gonna be awesome
09:25:54 <quazimodo> mniip: nice book
09:25:54 <hjulle> Is there any way to represent a more general functor F:Hask->Hask, than Functor in haskell?
09:25:57 <quazimodo> *boobs
09:26:14 <prophile> shlevy: uncertain, but would a ~ on the last pattern work?
09:26:32 <shlevy> prophile: Never seen that, lemme see if I can find docs
09:26:45 <mniip> geekosaur, http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Control-Category.html#line-46
09:27:39 <shlevy> prophile: Ah that's a bit different I think. I basically want the resulting code not to check the constructor flag at all before the last pattern and assume the data actually has that structure
09:27:45 <hjulle> geekosaur, Depends on what you mean with "represent". 
09:30:14 <hjulle> geekosaur,  You can't use haskell to prove all true theorems about haskell. No, that's a lie. Haskell is inconsistant and you can prove any theorem in it regardless of if it's true.
09:30:18 * hackagebot hlibsass 0.1.0.0 - Low-level bindings to libsass  http://hackage.haskell.org/package/hlibsass-0.1.0.0 (jakubfijalkowski)
09:30:20 * hackagebot rfc3339 1.0.5 - Parse and display time according to RFC3339 (deprecated)  http://hackage.haskell.org/package/rfc3339-1.0.5 (HugoGomes)
09:30:26 <hjulle> https://en.wikipedia.org/wiki/G%C3%B6del%27s_incompleteness_theorems
09:31:06 <quazimodo> that can't be true
09:31:11 <quazimodo> the type int is a category
09:31:15 <sellers> hjulle: that inconsistentcy is a consequence of _|_ existing, right?
09:31:17 <quazimodo> all types are if i'm not mistaken
09:31:27 <hjulle> sellers, Exactly.
09:31:28 <prophile> with what objects and morphisms
09:31:37 <merijn> quazimodo: That doesn't mean much
09:31:50 <quazimodo> wwhy not
09:31:51 <merijn> quazimodo: You need to define what the objects and morphisms are
09:31:58 <quazimodo> you can transform an int into a string representation
09:32:02 <merijn> quazimodo: I can probably invent multiple categories for int
09:32:06 <quazimodo> sure
09:33:07 <hjulle> The most obvious one is the subcategory of Hask, with exactly one object: int, and morpisms=functions from int to int.
09:33:19 <quazimodo> sure
09:33:35 <quazimodo> a functor could be to map an int to it's string representation
09:33:37 <prophile> there's also the category with one object, where the morphisms are ints, and composition is addition
09:34:39 <prophile> quazimodo: how does that preserve morphisms?
09:35:09 <quazimodo> prophile: not sure, need to think more
09:35:20 <quazimodo> still too new to tell honestly
09:35:57 <hjulle> prophile, Composition? What does that have to do with categories?
09:36:08 <prophile> hjulle: composition of morphisms
09:36:11 <quazimodo> hjulle: pretty central to category theory
09:36:32 <hjulle> prophile, Oh, I misread. Yes. That's true.
09:36:48 <prophile> easily done
09:37:39 <Gurkenglas> Given a typeclass C, some instances of it, some type T, foo1 :: C a => a and foo2 :: C a => a -> T, wouldn't foo2 foo1 be ill-defined?
09:38:14 <hjulle> I'm thinking that you could use a type family/type class with functional dependencies in order to represent a more general functor in haskell.
09:38:37 <merijn> Gurkenglas: It's ambiguous yes and GHC will complain
09:41:31 <hjulle> prophile, I keep getting confused by the name "morphisms" and forget that it's more general than I think.
09:41:33 <Gurkenglas> Aw, I was hoping for something along the lines of "Yes, but anologously to Functor, Applicative and Monad laws, the implementer of any typeclass is supposed to make sure that such situations have all ways of obtaining foo2 foo1 be equationally equal."
09:42:03 <merijn> Gurkenglas: Why bother? There's a simpler solution "foo2 (foo1 :: Foo)"
09:42:31 <Gurkenglas> I don't know, it seems a mathematically sound and generally sane sort of principle.
09:43:02 <merijn> How would that work for, for example, read + show?
09:43:14 <Gurkenglas> Like, if I'd read that in some Haskell tutorial I would've had the same feeling I had lotsa times when learning about Haskell :P
09:43:18 <bennofs> :t read . show
09:43:19 <lambdabot> (Read c, Show a) => a -> c
09:43:25 <bennofs> :t show . read
09:43:26 <lambdabot> String -> String
09:43:28 <bennofs> :o
09:43:52 <mniip> > show . read $ "()"
09:43:54 <lambdabot>  "()"
09:43:56 <mniip> so magicl
09:43:57 <bennofs> lambdabot probably has extended defaulting
09:44:02 <merijn> It does
09:44:29 <Gurkenglas> Yes, that was the example that brought this question to mind :P
09:45:10 <Gurkenglas> Like, that this is possible implies that "read . show = id" is a Read/Show law as much as fmaps commuting squares are a Functor law.
09:45:47 <bennofs> Gurkenglas: read . show /= id
09:45:58 <prophile> not really, it's just that lambdabot guesses () for the types it doesn't know
09:45:59 <bennofs> > read . show $ 4
09:46:01 <lambdabot>  ()
09:46:09 <Gurkenglas> Well someone did something wrong then!
09:46:28 <bennofs> > show . read $ "4" --isn't either
09:46:30 <lambdabot>  "*Exception: Prelude.read: no parse
09:46:47 <prophile> @let instance Num () where { _ + _ = (); _ - _ = (); _ * _ = (); abs _ = (); signum _ = (); fromInteger _ = () }
09:46:48 <lambdabot>  .L.hs:143:10:
09:46:48 <lambdabot>      Duplicate instance declarations:
09:46:48 <lambdabot>        instance [safe] Num () -- Defined at .L.hs:143:10
09:46:58 <prophile> interesting
09:47:00 <prophile> > 4
09:47:01 <lambdabot>  ()
09:47:11 <prophile> > read . show $ 4
09:47:13 <lambdabot>  ()
09:47:16 <prophile> looks like an identity to me
09:47:17 <aruro> i just realized there are no true lists in haskell :)
09:47:19 <prophile> :)
09:47:25 <aruro> all lists are trees
09:47:28 <aruro> :(
09:47:31 <prophile> howso?
09:47:41 <prophile> @undefine
09:47:41 <lambdabot> Undefined.
09:47:48 <Gurkenglas> > 4
09:47:50 <lambdabot>  4
09:48:17 <merijn> aruro: huh?
09:48:25 <aruro> because they are nested
09:48:31 <aruro> they are basically one branch trees
09:48:43 <merijn> aruro: You're describing a linked list...
09:48:45 <bennofs> aka linked lists
09:49:04 <aruro> the point is that each element is on different level
09:49:05 <merijn> aruro: That's how lists are implemented in basically every language I know
09:49:08 <Gurkenglas> aruro, you may be interested in https://hackage.haskell.org/package/free-4.11/docs/Control-Comonad-Cofree.html
09:49:13 <merijn> aruro: Define level
09:49:24 <aruro> : gives you level
09:49:39 <bennofs> merijn: ? do you not call C++ vectors or Java ArrayLists lists?
09:49:42 <hjulle> Are there any categories representable in haskell where the objects are something else than types?
09:50:00 <merijn> bennofs: No for the former, because C++ *has* lists in the STL and they're not vectors
09:50:05 <prophile> hjulle: there's the monoid example from earlier
09:50:16 <merijn> bennofs: Java ArrayLists are a thing, but so are linked lists, so
09:50:51 <prophile> or you could have a category of natural numbers as objects and morphisms n -> m being n x m matrices
09:51:01 <prophile> (with morphism composition given by matrix multiplication)
09:57:44 <hjulle> Object=element of the monoidal type, morphisms=one-element sets with the function mappend, identity=mempty, composition=? -- No, that doesn't work.
09:58:09 <hjulle> Yeah, the matrices makes sense to me.
09:58:14 <roboguy_> aruro: I don't think there's another way to have a linked list, is there?
09:59:51 <roboguy_> hjulle: the object in a monoid category doesn't really matter, as long as there is only one. The morphisms are the values
10:00:02 <scott> aruro: a linked list is a degenerate case of some kinds of trees, but that doesn't imply they aren't lists or that haskell doesn't have lists
10:00:13 <prophile> hjulle: there's only one object, *
10:00:21 <prophile> elements of the monoidal type are the morphisms
10:00:29 <prophile> composition is mappend, identity is mempty
10:01:13 <hjulle> All that's needed for something to be a morphism is that there exists identity and composition which follows the laws. The interpretation of being "from object X to object Y" doesn't matter. Am I correct?
10:01:25 <roboguy_> aruro: you might be thinking of arrays. But Haskell does have arrays as well
10:01:36 <roboguy_> but they are a separate data structure from lists
10:02:34 <roboguy_> hjulle: well, they need to have a domain and a codomain
10:03:54 <roboguy_> hjulle: you can't really describe the composition law otherwise
10:04:23 <hjulle> "for every pair of objects (X, Y), a set hom(X, Y) of morphisms from X to Y. We call this set hom(X, Y) a homset. If f ∈ hom(X, Y), then we write f : X → Y." In this definition I guess all morphisms have exactly one element in their domain/codomain.
10:05:11 <roboguy_> I'm not sure what that would be contrasted with, but yeah the domain is an object in the category and the codomain is an object in the category
10:05:20 * hackagebot ldap-client 0.1.0 - Pure Haskell LDAP Client Library  http://hackage.haskell.org/package/ldap-client-0.1.0 (MatveyAksenov)
10:08:36 <hjulle> But there is no restriction for the interpretation of the domains and codomains as far as I understand. You could choose to ignore them if you want to. (But I guess it would be hard to fulfill the laws then, at least with more than one object.)
10:09:18 <roboguy_> hjulle: composition has to be consistent with domain and codomain. You can't compose a morphism f : X -> Z with g : A -> B
10:10:31 <roboguy_> if you have the composition f . g, then cod(g) = dom(f)
10:10:48 <hjulle> Aha, so that's why you can ignore the object if there is only one.
10:10:54 <roboguy_> yep!
10:11:26 <ReinH> hjulle: arrows are defined by their domain and codomain, which are both (single) objects.
10:12:42 <hjulle> Haskell arrows or some categorial concept of arrows?
10:12:57 <ReinH> The categorical concept of arrows
10:13:03 <ReinH> There is only one.
10:14:19 <hjulle> I'll go find the definition then
10:14:25 <roboguy_> ReinH: well... That might depend on what you mean by "defined"
10:14:50 <roboguy_> It has always seemed to me more like they are defined by the relations between their compositions
10:15:20 * hackagebot editor-open 0.1.0.0 - Open the user's @$EDITOR@ for text input.  http://hackage.haskell.org/package/editor-open-0.1.0.0 (pharpend)
10:15:43 <prophile> hjulle: arrows = morphisms
10:15:44 <aruro> roboguy_, ty that looks like alternative
10:15:51 <monochrom> given two objects A, B, there are usually multiple arrows from A to B. so each arrow can't be defined by just knowing "from A to B" alone.
10:16:04 <merijn> hjulle: arrows, morphism and homomorphism are all synonyms (yay! confusion!)
10:16:05 <prophile> alternative name
10:16:10 <hjulle> prophile,  Aha. Was just redirected on wikipedia.
10:16:30 <merijn> hjulle: Have you read Bartosz' "CT for programmers" blog series?
10:17:31 <ReinH> monochrom: Yes, of course, but you can't just ignore the domain and codomain.
10:17:34 <hjulle> I guess that morphisms between different categories are not homomorphisms?
10:17:53 <roboguy_> quazimodo: well, haha this isn't exactly a great work of art, but here's a visualization of part of the object mapping part of the Maybe functor from Hask to itself: http://roboguy.net/haskell-maybe-functor.jpg
10:17:55 <ReinH> hjulle: They are. They preserve the category structure.
10:18:04 <ReinH> morphism is just short for homomorphism
10:18:14 <ReinH> morphisms between categories are called functors
10:18:17 <merijn> hjulle: They are, incidentally, morphisms between categories are functors
10:18:21 <aruro> is it possible to have pattern match on lists from right like this (xs:x) ?
10:18:25 <hjulle> From wikipedia: "In the concrete categories studied in universal algebra (groups, rings, modules, etc.), morphisms are _usually_ homomorphisms."
10:18:28 <roboguy_> hjulle: a functor has homomorphism laws
10:18:34 <monochrom> aruro: no
10:18:34 <merijn> Which happen to be morphisms in the category of categories (where objects are categories)
10:18:51 <merijn> hjulle: That's a non-CT observation
10:18:52 <roboguy_> aruro: that would put the head in xs and the tail in x
10:18:55 <aruro> is there any other implementation of lists which allows simmetrical pattern matching?
10:18:58 <merijn> hjulle: In CT all morphisms are homomorphisms
10:19:10 <monochrom> Data.Sequence is fairly symmetrical
10:19:11 <merijn> hjulle: Anyway, I recommend http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/ over wikipedia
10:19:18 <aruro> roboguy_ i know but i mean  exactly the oposite
10:19:19 <EvanR> merijn: in what sense
10:19:24 <monochrom> but not symmetrical pattern matching
10:19:26 <roboguy_> aruro: no, it is not possible
10:19:30 <merijn> EvanR: In what sense what?
10:19:31 <aruro> why not?
10:19:42 <aruro> because of typesystem?
10:19:57 <roboguy_> aruro: No. The list data type is defined in terms of constructors. When you pattern match, you match on the constructors that define the data type
10:20:05 <aruro> yes
10:20:06 <EvanR> merijn: all morphisms are homomorphisms, i.e. whats the distinguishing characteristic of a homomorphism in CT?
10:20:06 <roboguy_> that's true for any data type
10:20:11 <monochrom> patterns come from how you defined your data type, only. that is, patterns can only use the data constructors you wrote, not any semantic concept you have in your private head
10:20:17 <hjulle> merijn, As a tutorial, of course. But I wanted a quick reference to the definition.
10:20:21 * hackagebot editor-open 0.1.0.1 - Open the user's $EDITOR for text input.  http://hackage.haskell.org/package/editor-open-0.1.0.1 (pharpend)
10:20:26 <aruro> so there is no symmetrical definition for lists?
10:20:30 <roboguy_> aruro: the list type has two constructors: one is the empty list and the other takes an element and a list and it puts the element at the head of the list
10:20:30 <ReinH> monochrom: When I said "defined in terms of" I didn't say "uniquely defined".
10:20:43 <monochrom> therefore, a data type defined asymmetrically must only have asymmetric patterns
10:21:00 <merijn> EvanR: The wikipedia text just quoted says that "morphisms are usually homomorphisms", I'm not aware of any non-homomorphism morphisms, I was just pointing out that, at least in CT, all morphisms are homomorphisms
10:21:02 <ReinH> monochrom: Most CT texts give a definition of arrows in terms of dom and codom operations
10:21:07 <monochrom> a data type defined symmetrically can have symmetric patterns, but then you get a binary tree, not a list.
10:22:08 <aruro> ok that basically concludes the starting point that lists are essentially trees
10:22:13 <EvanR> merijn: im just asking why have a separate name when theres no difference
10:22:19 <aruro> in their current realisation
10:22:24 <merijn> EvanR: Hysterical raisins
10:22:29 <roboguy_> ReinH: well, you just said "defined by"
10:22:38 <ReinH> e.g. in Mac Lane, the only things you know about arrows are that 1) they have dom and codom operations 2) identity arrows are assigned to objects 3) arrows f and g compose when dom g = cod f
10:22:40 <roboguy_> that's why I said it probably depends on what you mean by that
10:22:44 <ReinH> roboguy_: Fair point. I meant "defined in terms of".
10:22:49 <merijn> aruro: The current realisation is exactly the same as C++ lists, C lists, Java's LinkedList, lisp, etc.
10:23:15 <aruro> i dont know other languages :)
10:23:17 <Hijiri> lists are just special cases of trees
10:23:19 <aruro> dont care much
10:23:24 <Hijiri> but they are still lists
10:23:30 <monochrom> no, those lists can be doubly-linked. [] is not doubly-linked
10:23:56 <monochrom> moroever, those lists can come with both "pointer to head" and "pointer to last". [] does not have pointer to last.
10:24:03 <aruro> my main point that horisontality of lists which is accidental in their sintax is actually missing from them :)
10:24:27 <Hijiri> what's horizontality
10:24:34 <aruro> i can see only horisontal construction of the form data F = A | B | C
10:24:46 <aruro> which to me would be true list :)
10:24:46 <ReinH> data F = A
10:24:53 <ReinH>        | B
10:24:57 <ReinH> vertical construction
10:25:04 <aruro> not important
10:25:11 <aruro> important is immediate access to any point
10:25:12 <monochrom> "data F = A | B | C" is not a list in any sense
10:25:13 <ReinH> Neither is "horizontal construction"
10:25:17 <aruro> via pattern matching
10:25:35 <srhb> aruro: So any recursive datatype is a Tree?
10:25:39 <monochrom> ok, I concede. it is a string, a list of characters
10:25:40 <aruro> yes
10:25:47 <Hijiri> cyclic graphs are not
10:25:47 <srhb> I find that distinction silly, but OK.
10:25:49 <aruro> i would say so
10:25:52 <merijn> aruro: "immediate access to any point" is not a property of lists
10:26:01 <merijn> aruro: That's a property of arrays
10:26:03 <aruro> what is?
10:26:14 <aruro> nestedness is neither property of lists
10:26:18 <aruro> or?
10:26:19 <ReinH> foo = 1 : foo is not a tree.
10:26:25 <monochrom> "immediate splitting head from tail" is a property of []
10:26:27 <merijn> aruro: C/C++ lists don't give you that either and neither does Java's LinkedList or Lisp's lists
10:26:45 <monochrom> actually, that is not the most interesting property
10:27:00 <roboguy_> aruro: the structure of a list itself is one dimensional. Usually the structure is drawn like this http://cdn3.crunchify.com/wp-content/uploads/2013/06/Crunchify-Singly-linked-list-Example.png
10:27:09 <monochrom> "immediate joining head and tail" is the most interesting property of [], one that arrays cannot possibly hope for
10:27:10 <roboguy_> It's not purely a syntactic thing
10:27:27 <ReinH> In fact, special treatment of (:) aside, it isn't a syntactic thing at all.
10:28:07 <monochrom> anyway, just use Data.Sequence and be done with it
10:28:24 <ReinH> my data List a= Nil | Cons a (List a) is just a much a list as []
10:28:36 <monochrom> or else, fork GHC and modify things yourself
10:29:05 <aruro> so when people say lists are undecided computation
10:29:09 <aruro> or the one with many results
10:29:11 <aruro> not true
10:29:17 <ReinH> yes it is
10:29:18 <bennofs> aruro: btw, you can write f [x,y,z] = ....     does that constitute "direct access" ?
10:29:29 <aruro> it does
10:29:30 <aruro> bennofs
10:29:41 <ReinH> Well, if it is read is "lists can be interpreted as", it is true.
10:29:47 <aruro> and my point is to understand if this direct access i possible in general
10:29:49 <hjulle> You can interpret lists as undecided computation.
10:29:50 <bennofs> > let [x,y,z] = [1,2,3] in z
10:29:51 <lambdabot>  3
10:29:52 <aruro> not for a finite set
10:29:55 <aruro> of parameters
10:30:05 <bennofs> > let (x:y:z:_) = [1,2,3] in z
10:30:07 <lambdabot>  3
10:30:21 * hackagebot breve 0.0.4.0 - a url shortener  http://hackage.haskell.org/package/breve-0.0.4.0 (rnhmjoj)
10:30:25 <ReinH> bennofs: (those are different ofc)
10:30:31 <monochrom> look, I am happy if you disagree with everything we said. it means we have one fewer competitor.
10:30:35 <bennofs> ReinH: yea, that was the point
10:31:00 <aruro> lol :D he thinkgs in terms of conpetitors :)
10:31:11 <ReinH> so f [x,y,z] is "direct access" because it appears to access the elements simultaneously despite not actually doing so?
10:31:30 <monochrom> what's so funny with it?
10:31:37 <srhb> aruro: I think all you're achieving with this is making tree be synonymous with recursive datatype and thus rendering "tree" a less useful word in general -- exactly because now it's just synonymous to recursive data type, which is a term we already have and use.
10:32:05 <ReinH> srhb: And also changing the definition of "Tree" to mean "graph"
10:32:08 <srhb> Right
10:32:26 <srhb> And a less rich language in programming is something I don't think is a good idea. :)
10:32:31 <ReinH> And we already have a good word for "graph".
10:32:34 <aruro> :)
10:32:39 <ReinH> We'd like to keep "tree" for referring to trees please.
10:32:44 <srhb> Yespls :-)
10:32:49 <aruro> what i want is more reach patterns for lists
10:32:56 <aruro> not baby things like x:xs
10:32:59 <ReinH> "more reach patterns"?
10:33:03 <aruro> rich
10:33:04 <ReinH> What does that mean?
10:33:12 <hjulle> aruro, Examples please
10:33:12 <ReinH> What sort of more rich pattern?
10:33:13 <srhb> But that's what lists can do.
10:33:19 <srhb> If you want other things, you don't want lists.
10:33:26 <aruro> tail patters is one of the examples
10:33:30 <aruro> _:x:y
10:33:36 <roboguy_> aruro: you want Sequence
10:33:38 <aruro> where _ stands for rest
10:33:39 <JuanDaugherty> something is wrong with the transform of "Lead, Follow or Get out of the way" to "Learn, Teach, or Get Out of the Way", in the 1st there's obstruction, missing in the 2nd
10:33:40 <aruro> of the list
10:33:44 <srhb> That's not what a LIst is
10:33:47 <ReinH> And if using the constructors of a data type to pattern mach is "baby things", then ok.
10:33:59 <ReinH> But that means that literally all pattern matching is "baby things" because that's how pattern matching works.
10:34:01 <merijn> aruro: Basically, you're trying to define existing terminology to be different from how everyone is currently using it. Which is fine, but don't expect anyone to talk to you without getting frustrated
10:34:35 <aruro> roboguy_ ty, you say Sequence comes close to what im talking about?
10:34:36 <ReinH> (Except for special cases like [x,y,z] patterns, which are syntastic sugar for actual contructors)
10:34:43 <aruro> i did not say Pattern match is baby thing
10:34:53 <aruro> i said having only ONE list patter is baby thing
10:34:54 <roboguy_> aruro: it is pretty much exactly what you are asking for, if I'm understanding you
10:35:00 <aruro> pattern*
10:35:02 <hjulle> aruro, Yes. Sequence is what you want.
10:35:03 <ReinH> aruro: No, I was drawing the logical conclusion from what you said.
10:35:05 <Hijiri> there are two patterns
10:35:05 <srhb> aruro: Yes, you did, actually. I think you don't understand _why_ that's exactly what you said. :)
10:35:05 <roboguy_> aruro: it's great most of the time though
10:35:08 <Hijiri> [] and x:xs
10:35:12 <ReinH> aruro: In point of fact, lists have two constructors.
10:35:16 <roboguy_> aruro: http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Sequence.html#t:ViewR
10:35:17 <Gurkenglas> JuanDaugherty, that sounds like a topic for #haskell-blah
10:35:36 <monochrom> by the well-ordering principle, in "lead, follow, or get out of the way", "get out of the way" is redundant. since if one isn't following, then one is leading.
10:35:49 <JuanDaugherty> Gurkenglas, well it's currently in the topic here.
10:36:21 <ReinH> aruro: x:xs is how pattern matching works. If you think that example is "baby things" then you must think all pattern matching is "baby things" because x:xs is no different from any other non-sugared pattern match.
10:37:04 <monochrom> pattern matching is baby things. so don't use pattern matching.
10:37:13 <ReinH> Fine. Good luck doing anything at all then.
10:37:16 <aruro> roboguy_, ty! i will check is out , surprisingly it is realised using trees it seems :)
10:37:17 <Gurkenglas> Huh. Okay then. It's probably just a humorous references, but maybe it's there to be pointed at for people who are posting things to the channel in neither of the processes of teaching and learning? :D
10:37:21 <Gurkenglas> -s
10:37:36 <roboguy_> aruro: trees are useful structures
10:37:47 <ReinH> So useful that it's nice to have a name for them.
10:38:00 <aruro> ReinH, you are generalising too much
10:38:10 <aruro> look at this data structure data F = A | B | C
10:38:15 <JuanDaugherty> Gurkenglas, neither / nor
10:38:17 <ReinH> aruro: what about it?
10:38:24 <aruro> it has 3 possible patterns to match
10:38:28 <aruro> list has only one
10:38:31 <Gurkenglas> JuanDaugherty, neither of the elements of a set!
10:38:31 <srhb> What
10:38:32 <aruro> thats all im talking about
10:38:32 <Hijiri> list has two
10:38:35 <aruro> ok []
10:38:42 <Hijiri> and it only has two because those are the two constructors
10:38:42 <ReinH> Lists have an infinite number of possible patterns.
10:38:45 <ReinH> They have two constructors.
10:38:58 <Hijiri> what ReinH said is more accurate than what I said
10:39:01 <aruro> conceptually they have only one pattern match
10:39:05 <aruro> from left to the right
10:39:11 <Hijiri> in aruro concepts
10:39:11 <aruro> thats it.
10:39:22 <aruro> show me 5 different list pattern matches?
10:39:24 <ReinH> aruro: If I pretend those words mean what I think you are trying to make them mean, ok
10:39:37 <ReinH> [], x:[], x:y:[], x:xs, x:y:ys
10:39:42 <aruro> lol :)
10:39:43 <aruro> ok
10:39:59 <aruro> you realize they are all same?
10:40:07 <ReinH> No, of course not, because they aren't.
10:40:08 <monochrom> they are all different
10:40:09 <roboguy_> > case [1,2,3,4] of (_:_:54:_) -> "There are"; (_:_:3:_) -> "many possible"; _ -> "patterns"
10:40:10 <lambdabot>  "many possible"
10:40:11 <Hijiri> if they are the same, they would all match the same patterns
10:40:13 <Hijiri> which they do not
10:40:42 <roboguy_> aruro: usually bigger things are built up in terms of a small collection of things
10:41:06 <ReinH> I'm not sure how much progress we're going to make with someone who things [] and x:[] are the same pattern
10:41:06 <roboguy_> things are not usually built all at once as a whole, especially things that can grow at runtime
10:41:11 <ReinH> *thinks
10:41:24 <aruro> ReinH, relax man :)
10:41:33 <ReinH> aruro: I am quite relaxed.
10:41:39 <aruro> i understand wha YOU mean, you dont understand me :)
10:41:40 <monochrom> I agree, ReinH.
10:41:45 <ReinH> aruro: That much is clear.
10:41:49 <ReinH> Why do you think that is?
10:42:05 <ReinH> Is it because we all have bad reading comprehension? Or maybe some other reason?
10:42:15 <aruro> no all
10:42:25 <ReinH> Just everyone who is talking to you?
10:42:33 <monochrom> this thread should have stopped 10 minutes ago
10:42:44 <aruro> 19:37
10:42:48 <aruro> was usefull comment
10:43:00 <ReinH> aruro: surely you realize we aren't all in your time zone?
10:43:10 <aruro> 2 min ago
10:43:11 <Gurkenglas> Ooh, another German!
10:43:12 <aruro> then
10:43:17 <Hijiri> I have at least 10 messages I can see from minute 37
10:43:24 <srhb> OK, now it's just getting silly
10:43:28 <srhb> Can we close this, please.
10:43:29 <aruro> lol german you realize all europe in same time zone? :)
10:43:40 <aruro> im done
10:43:53 <ReinH> lmao, is there anything about which you can't be wrong?
10:44:01 <ane> (they aren't, not nearly)
10:44:01 <hjulle> aruro, I was just going to say the same thing.
10:44:17 <aruro> most of it
10:44:28 <aruro> ReinH what is your time zone?
10:44:28 <ReinH> There are at least 4 time zones in europe.
10:44:40 <aruro> just for info :)
10:44:58 <ReinH> western, central, eastern, and further-eastern europe.
10:45:22 * hackagebot dozenal 0.1.0.0 - A Haskell library for using Dozenal (Duodecimal - Base 12) numbers.  http://hackage.haskell.org/package/dozenal-0.1.0.0 (siddhanathan)
10:45:25 <ReinH> If you want to count Azores, that's 5. If you want to count the irish time zone, that's 6.
10:45:32 <aruro> lol :)
10:45:34 <aruro> dude chill
10:45:46 <Gurkenglas> When someone builds the software for it we'll all see this section of the #haskell log get voted to the top of some category and have a laugh.
10:45:55 <ReinH> Again, I am quite chill. I just think it's humorous how wrong you are.
10:46:02 <Gurkenglas> (Hi!)
10:46:19 <aruro> it is not, what is humorous is how much you CARE about it :)
10:46:21 <srhb> ReinH: I don't think the rest of the channel is as amused with the spam, so if you could stop as well, it would be nice. :)
10:46:25 <srhb> aruro: You as well.
10:46:29 <ReinH> srhb: Ok.
10:46:41 <roboguy_> anyway, as I see it: Problem: you can't pattern match at the end of an arbitrary list directly. Solution: use Data.Sequence
10:47:01 <aruro> roboguy_ , ty going look into that
10:47:10 <srhb> aruro: You may be interested in ViewPatterns as well.
10:47:16 <ReinH> roboguy_: (And then you can't match on either end. Problem solved!)
10:47:17 <aruro> ty
10:48:12 <roboguy_> ReinH: no?
10:48:13 <hjulle> Is there any way to overload pattern matching so you could pattern match on opaque types?
10:48:23 <ReinH> roboguy_: You can with view patterns, I suppose.
10:48:28 <roboguy_> hjulle: what do you mean?
10:48:52 <ReinH> Which is why it comes with viewl and viewr
10:49:25 <ReinH> hjulle: view patterns, perhaps
10:49:38 <hjulle> Yes, I guess that's it.
10:49:51 <roboguy_> or maybe pattern synonyms depending on what you're looking for
10:50:07 <ReinH> I think the problem is in expecting a list in Haskell to be something other than what you can construct and destruct from [] and :
10:50:14 <emmruld> hey guys, I'm new to haskell and attempting to create functions at run-time but I'm having a hard time figuring it out. What I'd like is, given a list of characters, say "AB", I'll be returned a list of functions that represents every truth assignment to AB
10:50:22 * hackagebot crackNum 1.2 - Crack various integer, floating-point data formats  http://hackage.haskell.org/package/crackNum-1.2 (LeventErkok)
10:50:32 <ReinH> emmruld: what is the type of a truth assignment?
10:50:37 <emmruld> i.e., h(A) = T h(B) = T; h(A) = T h(B) = F
10:50:47 <emmruld> h:: Char -> Boolean
10:51:23 <emmruld> so far I have, genH x = [true, false]; where true x = True; false x = False
10:51:35 <emmruld> but this function can only operate on 1 character
10:51:53 <emmruld> (where x is that char)
10:52:13 <emmruld> so I'm also wondering if there's a way to create a "union" of functions?
10:52:15 <roboguy_> you could represent the functions as association lists
10:52:21 <ion> Re: crackNum, I’m not sure that’s what cracking generally means.
10:52:26 <roboguy_> and then have your actual function lookup in the association list
10:52:40 <emmruld> roboguy_: is an association list just a map?
10:52:42 <hjulle> emmruld,  I don't quite understand what you mean with "every truth assignment"?
10:53:05 <emmruld> emmruld: it's the cartesian product between the list of characters and {T,F}
10:53:09 <roboguy_> emmruld: in this case, it's [(Char, Bool)]
10:53:25 <roboguy_> and you have
10:53:27 <roboguy_> :t lookup
10:53:28 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
10:53:28 <emmruld> so h1 yields True True, h2 TF, H3 FT, H4 FF
10:53:58 <ReinH> emmruld: That's not a function Char -> Bool though
10:54:32 <emmruld> ReinH: that's okay, I'll change my shtuff around
10:55:22 * hackagebot free-functors 0.6.4.1 - Provides free functors that are adjoint to functors that forget class constraints.  http://hackage.haskell.org/package/free-functors-0.6.4.1 (SjoerdVisscher)
10:55:22 <Gurkenglas> Would it be considered spoiling if I attempted my own try at emmrulds problem?
10:55:34 <roboguy_> ReinH: it's not?
10:55:35 <ReinH> :t [\c' -> if c == c' then b else not b | c <- "AB", b <- [True, False]] -- does what you seemed to want originally
10:55:36 <lambdabot> [Char -> Bool]
10:55:59 <ReinH> roboguy_: I'm not sure how h1 can be a function Char -> Bool if it "yields True True"
10:56:30 <roboguy_> ReinH: oh, I assume emmruld was using that as a shorthand for "True for 'A' and True for 'B'"
10:56:33 <Gurkenglas> ReinH, that won't generate exponentially many functions for larger lists
10:56:53 <Gurkenglas> The powerset trick with filterM comes to mind. How did that work?
10:57:14 <emmruld> ReinH: sorry, that was short hand, h1('A') = True, h1('B') = True
10:57:17 <Gurkenglas> > filterM (const [True, False]) "AB"
10:57:18 <lambdabot>  ["AB","A","B",""]
10:57:25 <ReinH> [(c,b) | c <- "AB", b <- [True,False]]
10:57:28 <emmruld> h2('A') = True, h2('B') = False
10:57:34 <Gurkenglas> > map (flip 'isElem') filterM (const [True, False]) "AB"
10:57:35 <lambdabot>      Syntax error on 'isElem'
10:57:35 <lambdabot>      Perhaps you intended to use TemplateHaskell
10:57:35 <lambdabot>      In the Template Haskell quotation 'isElem'
10:57:43 <Gurkenglas> :t map (flip 'elem') filterM (const [True, False]) "AB"
10:57:44 <lambdabot>     Syntax error on 'elem'
10:57:44 <lambdabot>     Perhaps you intended to use TemplateHaskell
10:57:44 <lambdabot>     In the Template Haskell quotation 'elem'
10:57:45 <hjulle> emmruld, What do you want to use it for?
10:57:47 <ReinH> Why use a function when it's easier to use pairs?
10:57:50 <roboguy_> Gurkenglas: those should be backticks: `
10:58:00 <Gurkenglas> :t map (flip `elem`) filterM (const [True, False]) "AB"
10:58:00 <lambdabot>     Couldn't match expected type ‘(b1 -> [Bool]) -> [Char] -> t’
10:58:01 <lambdabot>                 with actual type ‘[Bool]’
10:58:01 <lambdabot>     The function ‘map’ is applied to four arguments,
10:58:10 <Gurkenglas> :t map (flip `elem`) $ filterM (const [True, False]) "AB"
10:58:11 <lambdabot>     Couldn't match type ‘Char’
10:58:11 <lambdabot>                    with ‘(a0 -> b0 -> c0) -> b0 -> a0 -> c0’
10:58:11 <lambdabot>     Expected type: [(a0 -> b0 -> c0) -> b0 -> a0 -> c0]
10:58:25 <scott> Gurkenglas: can you move to PM, please?
10:58:26 <Gurkenglas> Maybe I should test this in private chat before coming back,.
10:58:42 <emmruld> Gurkenglas: I need a sec to figure out what you've written
10:59:37 <Gurkenglas> :t map (flip elem) $ filterM (const [True, False]) "AB" -- Oh, my mistake was stupid.
10:59:38 <lambdabot> [Char -> Bool]
11:00:22 * hackagebot jumpthefive 0.0.1 - an elementary symmetric chiffre for pragmatically protecting one's effects  http://hackage.haskell.org/package/jumpthefive-0.0.1 (mcandre)
11:01:54 <ReinH> > map ($ 'A') $ map (flip elem) $ filterM (const [True, False]) "AB"
11:01:55 <lambdabot>  [True,True,False,False]
11:02:15 <hjulle> > map ($ 'B') $ map (flip elem) $ filterM (const [True, False]) "AB"
11:02:16 <lambdabot>  [True,False,True,False]
11:02:27 <ReinH> Maybe now would be a good time to ask what you want to do with this function.
11:02:50 <roboguy_> is it for SAT solving?
11:03:05 <emmruld> roboguy_: Yea, toy project since I'm learning haskell
11:03:28 <roboguy_> emmruld: that's a good one. I did it a while back and I had fun with it
11:03:50 <ReinH> I don't see what value you get from functions over tuples here
11:04:34 <emmruld> ReinH: I think the function is nicer, yes
11:04:46 <roboguy_> I ended up using tuples
11:04:47 <ion> @hackage ersatz -- emmruld: you might find this interesting
11:04:47 <lambdabot> http://hackage.haskell.org/package/ersatz -- emmruld: you might find this interesting
11:04:50 <ReinH> "Nicer" is a bit non-specific.
11:04:54 <shlevy> What version of __GLASGOW_HASKELL__ should I check for for 7.10? #if __GLASGOW_HASKELL__ < 7100 is succeeding on 7.10.1
11:05:23 * hackagebot crackNum 1.3 - Crack various integer, floating-point data formats  http://hackage.haskell.org/package/crackNum-1.3 (LeventErkok)
11:05:56 <roboguy_> shlevy: https://downloads.haskell.org/~ghc/6.10.3/docs/html/users_guide/version-numbering.html
11:06:34 <shlevy> Ah OK I thought the patch was included
11:06:38 <shlevy> roboguy_: thanks
11:07:26 <roboguy_> yeah the version numbering there is a bit nonintuitive (or at least, it was to me when I first saw it)
11:07:49 <emmruld> ReinH: I don't understand what const is doing in there
11:07:53 <hjulle> [crackNum] That package description makes it sound like date formats are a form of encryption :P
11:08:00 <emmruld> > (const [True, False]) "A"
11:08:01 <lambdabot>  [True,False]
11:08:03 <emmruld> > (const [True, False]) "B"
11:08:03 <ReinH> I like how it says you both should and shouldn't write code that conditionally tests __GLASGOW_HASKELL__
11:08:05 <lambdabot>  [True,False]
11:08:12 <ReinH> emmruld: you should probably ask Gurkenglas
11:08:17 <emmruld> op, sorry
11:08:39 <jbalint> hi, if i have a list of integers , how can i split it where some satisfy a given predicate and the rest don't?
11:08:45 <Gurkenglas> @src filterM
11:08:45 <lambdabot> Source not found. Whoa.
11:09:22 <shwouchk> Hello
11:09:30 <ReinH> :t partition
11:09:31 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
11:09:39 <jbalint> oh, it's partition not filter. not sure how i missed that. Thank you ReinH
11:09:45 <Gurkenglas> @hoogle (a -> Bool) -> [a] -> ([a], [a])
11:09:47 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
11:09:47 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
11:09:47 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
11:09:52 <Gurkenglas> (Welp.)
11:10:03 <ReinH> There are many functions of that type...
11:10:18 <ReinH> Most of them are useless. We managed to find the few that aren't.
11:10:23 * hackagebot alea 0.4.0.0 - a diceware passphrase generator  http://hackage.haskell.org/package/alea-0.4.0.0 (rnhmjoj)
11:10:35 <foofoo> Hi!
11:10:39 <Hijiri> hi
11:10:40 <shwouchk> I'm reading real world haskell (in the chapter about typeclasses) and am a bit confused at the moment about the notation => for types (e.g. "Read a => a"). Anyone care to elaborate?
11:10:51 <foofoo> I want to dabble with multicore programming,but currenlty only have an old Core 2 Duo processor
11:10:59 <ReinH> shwouchk: Read a => a says that a can be any time that is a member of the Read typeclass.
11:11:01 <ReinH> *any type
11:11:16 <foofoo> is there any drawback with getting some used quad core (like an old intel Core) instead of a newer i5?
11:11:29 <foofoo> I only care about seeing the potential speedup when using more than 2 cores
11:11:32 <sellers> ReinH: you type too fast :P
11:11:35 <foofoo> and not so much about absolute numbers
11:11:41 <foofoo> (this is for tinkering)
11:12:47 <emmruld> > filterM (const [True, False]) "A"
11:12:48 <lambdabot>  ["A",""]
11:12:50 <emmruld> > filterM (const [True, False]) "AB"
11:12:51 <lambdabot>  ["AB","A","B",""]
11:13:09 <hjulle> foofoo: This is not the right place to ask about hardware, but if all you want is to see the difference, I don't think there is any drawback.
11:13:19 <Gurkenglas> emmruld, (filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]) takes a function that returns a monadic boolean and uses that boolean (as the specific monad dictates) to decide whether elements from the list should be included in the result.
11:13:37 <foofoo> hjulle: thanks
11:14:08 <shwouchk> ReinH: thanks. So expression1 => expression2 means in general type given by expression2 where expression1's type variables belong to the typeclass in expression1?
11:14:18 <hjulle> foofoo: What kind of drawbacks did you have in mind?
11:14:22 <emmruld> Gurkenglas: In our case, monadic boolean is the list of booleans>
11:14:23 <emmruld> ?
11:14:50 <Gurkenglas> emmruld, it is here specialized to (filterM :: (a -> [Bool]) -> [a] -> [[a]]), where the monad is specialized to [] and thus the way in which monadic values can be used is "nondeterminism", meaning that each element in the list the (a -> [Bool]) returns opens a new "timeline" in which that boolean was used
11:15:29 <ReinH> shwouchk: https://www.haskell.org/tutorial/classes.html
11:15:40 <Gurkenglas> We always want to both choose the "True" path in which the element was used and the "False" path in which it was discarded, regardless of what the element is, so we use the function const [True, False]
11:16:25 <Gurkenglas> And then each element is taken and not taken, resulting in all possible subsets of the list of chars we give it, here "AB" (or, written another way, ['A', 'B']).
11:16:34 <shwouchk> ReinH: I appreciate the link but I would rather read an exact and short definition than a tutorial at the moment...
11:16:56 <emmruld> I'm getting very confused, I need to marinate for a moment with what you guys have said
11:17:27 <ReinH> shwouchk: foo :: Bar a => a -> a means "For every type a that is an instance of Bar, foo has type a -> a"
11:17:35 <hjulle> shwouchk, Yes, that seems pretty correct. 
11:17:48 <shwouchk> hjulle: thanks!
11:18:03 <hjulle> shwouchk, (But the names for them aren't expressions in this case)
11:18:08 <shwouchk> ReinH: cool, thanks!
11:18:19 <emmruld> Gurkenglas: Why is the monadic filter required?
11:18:27 <emmruld> What do we lose by using normal filter?
11:18:30 <shwouchk> hjulle: ah, yes. I was trying to be overly general and failed
11:18:55 <roboguy_> emmruld: filter takes a function that returns a Bool
11:18:56 <roboguy_> :t filter
11:18:57 <lambdabot> (a -> Bool) -> [a] -> [a]
11:19:00 <ReinH> emmruld: filterM with a list represents nondeterministic choice, filter can only represent deterministic choice.
11:19:07 <Gurkenglas> The list monad provides nondeterminism, which is useful to make the powerset we watned.
11:19:11 <monochrom> emmruld: I am not convinced that it is useful to understand "filterM (const [False, True])" by understanding filterM isolated, and const [False, True] isolated.
11:19:13 <ReinH> emmruld: filterM here is being used in an unusual way to say "take both choices"
11:19:45 <monochrom> IMO it is best to simply expand out filterM (const [False, True]) and reason about the recursion underneath directly
11:19:50 <ReinH> filterM (const [True, False]) says "disregard the argument and choose both the True and False paths"
11:19:51 <Gurkenglas> monochrom, I disagree! I just tried to explain both separately :D
11:19:52 <emmruld> Why is nondeterminism necessary?  Calculating a power set is deterministic
11:20:13 <monochrom> Gurkenglas, the evidence supporting my point is that your explanation flopped.
11:20:18 <ReinH> emmruld: nondeterminism here just means that we take multiple paths rather than a single path
11:20:31 <emmruld> nice: https://mail.haskell.org/pipermail/haskell-cafe/2009-July/064338.html
11:20:36 <ReinH> e.g. there are two possible paths, the True path and the False path. We want to take both.
11:20:45 <monochrom> and another piece of evidence is that I did it my way some time ago in another channel (#haskell-tw) and it was successful.
11:20:55 <ReinH> So a list represents the multiple choices
11:21:44 <emmruld> Oh wait, clarify this for me, in the filter case, we do something *only* when our function returns true, i.e. collect the result.  But using filterM, we can do something in the True and False cases both?
11:21:55 <ReinH> Oh, I'm just repeating the explanation in that link by accident
11:22:20 <monochrom> >>= is the one that persues both paths (and all paths)
11:22:28 <monochrom> persue? pursue?
11:22:32 <ReinH> peruse?
11:22:34 <monochrom> persecute?
11:22:35 <emmruld> pursue
11:22:39 <emmruld> purseq
11:23:53 <int-e> emmruld: I think "do something" is too vague there. For example, if you're talking about monadic actions, filter cannot "do" anything at all.
11:24:44 <hjulle> > mapM (\x -> [Left x, Right y]) [1..2]
11:24:45 <lambdabot>  [[Left 1,Left 2],[Left 1,Right y],[Right y,Left 2],[Right y,Right y]]
11:24:57 <ReinH> hjulle: woops
11:25:02 <emmruld> Gurkenglas: I think I get it now, using filterM (const [True, False]) allows us to collect all possible results
11:25:21 <Gurkenglas> monochrom, I concede that your way is easier to explain, but contend that mine is potentially more powerful as it allows the user to more easily conceive of modifications to (const [True, False]) for more use-cases! Granted, I haven't used a modified version myself yet. <.<
11:25:47 <int-e> emmruld: Perhaps it's useful to think of it as "filterM is to mapM as filter is to map": rather than putting truth/false into result list(s), you put those original values for which the map(M) result produced True.
11:25:51 <emmruld> that's what I was just going to ask, what else would you put instead of (const [True, False])
11:25:54 <emmruld> ?
11:26:24 <ReinH> doesFileExist file
11:26:43 <ReinH> er, doesFileExist
11:27:27 <monochrom> I don't see any potential. filterM (const [False, True]) is so specialized that it doesn't shed much light on filterM
11:27:35 <Gurkenglas> emmruld, you can supply any function that decides whether the resulting subsets should contain it, not contain it, or both. (Or even neither, meaning that no subsets are produced at all.)
11:28:22 <Gurkenglas> > filterM (\x -> if x == 'O' then [] else [True, False]) "ABCDE"
11:28:23 <lambdabot>  ["ABCDE","ABCD","ABCE","ABC","ABDE","ABD","ABE","AB","ACDE","ACD","ACE","AC"...
11:28:26 <Gurkenglas> > filterM (\x -> if x == 'O' then [] else [True, False]) "ABCDEO"
11:28:27 <lambdabot>  []
11:28:35 <roboguy_> > filterM (\x y -> x`rem`y == 0) [1..10]   2  -- A kinda silly example with (-> r)
11:28:35 <hjulle> > mapM (const [True, False]) "AB"
11:28:36 <lambdabot>  [2,4,6,8,10]
11:28:36 <lambdabot>  <no location info>: can't find file: L.hs
11:28:56 <monochrom> similarly, explaining natural numbers by category theory ("imagine a category with one single object and many endomorphisms") teaches neither natural numbers nor category theory
11:29:16 <monochrom> there is one thing it does teach. that the teacher is to be worshipped
11:29:39 <Gurkenglas> Nooo, that category theory is to be worshipped, you ad hominemmer!
11:29:58 <hjulle> > mapM (const [True, False]) "AB"
11:29:59 <lambdabot>  [[True,True],[True,False],[False,True],[False,False]]
11:32:02 <ReinH> monochrom: (I think you are missing a bit there)
11:32:12 <monochrom> which bit?
11:32:44 <monochrom> that I didn't flesh out the singleton category for natural numbers?
11:32:49 <ReinH> monochrom: You are describing monoids. A natural number object N needs another terminal object 1 and a global element z : 1 -> N
11:33:23 <ReinH> and an arrow s : N -> N such that some coherence conditions blah blah
11:33:29 <hjulle> But I love how, when you ask a question on #haskell, someone always comes up with a magical oneliner which uses the analogy between profunctors and pink elephants to solve what would otherwise have taken 20 lines of code to solve.
11:33:46 <freinn> hi! i'm having problems defining a working NFA, the code is here http://pastebin.com/7M4s0Nj5
11:33:50 <monochrom> no, I saw a version that doesn't need the terminal object.
11:34:28 <Gurkenglas> I hope you used a DFA implementation and introduced the list monad?
11:34:36 <sellers> boo pastebin, hooray lpaste and sprunge
11:34:40 <Gurkenglas> *nondetermism monad
11:34:48 <freinn> yes
11:34:49 <freinn> I did
11:34:56 <freinn> the problem is to use foldM
11:35:24 * hackagebot rosa 0.2.0.0 - Query the namecoin blockchain  http://hackage.haskell.org/package/rosa-0.2.0.0 (rnhmjoj)
11:35:36 <ReinH> monochrom: Lawvere's definition is isomorphic to this one iirc
11:36:18 <monochrom> must you use foldM?
11:36:43 <ReinH> monochrom: NNO on nlab, for instance http://ncatlab.org/nlab/show/natural+numbers+object
11:36:51 <freinn> nope
11:37:01 <freinn> I can use anything
11:39:15 <Gurkenglas> Hmm, it should be called foldlM.
11:40:46 <monochrom> I wonder why in NFA, transition is not String -> Char -> [String]
11:41:23 <Gurkenglas> Dammit, was just about to say that.
11:41:35 <freinn> my intent was to use a "set of states"
11:41:58 <monochrom> "set of states" happens at the result i.e. codomain. only.
11:42:20 <freinn> ok
11:42:57 <monochrom> DFA has State -> Char -> State. NFA has State -> Char -> "Set of State".
11:43:14 <freinn> okok
11:43:25 <freinn> so the NFA is in only one state at a given time?
11:44:01 <monochrom> I wouldn't say that. but I will say: ...
11:44:34 <monochrom> when you look up the transition relation table, you are told one single current state at a time
11:45:13 <freinn> ok
11:46:21 <monochrom> you are right to imagine: when running an NFA, multiple minions are pursuing different possibilities.
11:46:49 <monochrom> but each minion does not know what other minions are doing. this is an important restriction.
11:46:56 <freinn> okok
11:50:53 <Gurkenglas> Hmm, how can he introduce nubbing into this without disturbing everything too much?
11:53:41 <hjulle> What is a nice category theory tutorial for mathematicians? (which also happens to be haskell programmers)
11:54:39 <emmruld> Why is the type of (>>=) :: M a -> (a -> M b) -> M b?  As opposed to taking a function that "injects" b into the monad, couldn't we instead have (>>=) :: M a -> (a -> b) -> M b, and in our definition of (>>=) call 'return $ g x'?
11:55:02 <Gurkenglas> Depends on the level of mathamatician. Have you heard of the Category Theory for Programmers thing that is being posted on /r/haskell recently?
11:55:02 <roboguy_> emmruld: that is flip fmap
11:55:13 <emmruld> > :t flip fmap
11:55:14 <lambdabot>  <hint>:1:1: parse error on input ‘:’
11:55:27 <roboguy_> :t flip fmap
11:55:28 <lambdabot> Functor f => f a -> (a -> b) -> f b
11:55:46 <roboguy_> that is less powerful
11:56:10 <emmruld> Where is power lost? in letting the caller specify how injection should happen?
11:56:32 <hjulle> Gurkenglas, Too much programming-talk, too little math.
11:56:56 <freinn> I think that you need the type (a -> M b) to get a M b from an a
11:57:03 <mr-> hjulle: Category Theory for the Working Mathematician fits the bill, then
11:57:19 <roboguy_> > [1,2,3,4] >>= (\x -> [x, x])
11:57:21 <lambdabot>  [1,1,2,2,3,3,4,4]
11:57:24 <emmruld> freinn: Not necessarily, you have return :: a -> M a
11:57:28 <roboguy_> emmruld: ^ that is impossible with fmap
11:57:37 <roboguy_> you can't change the structure with fmap
11:58:24 <emmruld> god, again with the list monad
11:58:31 <roboguy_> okay, how about:
11:58:34 <emmruld> that's going to send me in a twirl
11:58:37 <Gurkenglas> freinn, you can get _some_ M b from an a and an a -> b by feeding the resulting b to return. But you can't simulate all the (a -> M b)s with that
11:59:54 <roboguy_> > Just 10 >>= (\x -> Just 3 >>= (\y -> return (x * y)))
11:59:56 <lambdabot>  Just 30
12:00:06 <roboguy_> you can't do that with fmap either
12:00:07 <mr-> hjulle: or maybe Tom Leinster's new book
12:00:21 <roboguy_> well, the inner >>= can be done with fmap. The outer one can't
12:01:13 <ReinH> hjulle: There's always Mac Lane
12:01:15 <ahihi> it doesn't require a Monad though, Applicative is sufficient
12:01:17 <monochrom> @pl \i t inp -> i >>= \i0 -> foldM t i0 inp
12:01:17 <lambdabot> (. (flip . foldM)) . (.) . (>>=)
12:01:26 <monochrom> @pl \inp -> i >>= \i0 -> foldM t i0 inp
12:01:27 <lambdabot> (i >>=) . flip (foldM t)
12:01:46 <monochrom> heh, probably not worth it
12:02:27 <roboguy_> ahihi: yeah, I know. But I wanted to show somewhere where fmap is not enough
12:02:33 <Gurkenglas> monochrom, you could have him rearrange the fields in his record...
12:02:45 <emmruld> roboguy_: fmap (\x -> x*3) (Just 10)
12:02:46 <emmruld> > fmap (\x -> x*3) (Just 10)
12:02:48 <lambdabot>  Just 30
12:02:49 <hjulle> What if I'm cheap and don't want to buy a book? At least not one for $60. ;)
12:02:57 <roboguy_> emmruld: that doesn't handle the outer Just
12:03:07 <mr-> hjulle: ask the russians, then :)
12:03:08 <lpaste> monochrom pasted “NFA” at http://lpaste.net/130543
12:03:17 <hjulle> :P
12:03:28 <freinn> how can I get my function testNFA working?? http://lpaste.net/130542
12:03:28 <monochrom> freinn: http://lpaste.net/130543
12:03:30 <Gurkenglas> hjulle, http://www.maths.ed.ac.uk/~aar/papers/maclanecat.pdf didn't cost me a thing
12:03:51 <freinn> xDDD
12:03:53 <freinn> thanks
12:04:05 <hjulle> Gurkenglas, thanks
12:04:21 <Gurkenglas> (Which I got by googling the title)
12:04:24 <monochrom> my "transitions" is your "t" now
12:04:28 <Gurkenglas> (As the first result)
12:05:11 <freinn> and
12:05:17 <freinn> how do you know too much haskell?
12:05:17 <freinn> xD
12:05:23 <roboguy_> emmruld: in order to handle the outer Maybe, you need something stronger than Functor (Applicative is enough in this case, but Monad works too since Monad is stronger than Applicative)
12:05:25 * hackagebot hlibsass 0.1.1.0 - Low-level bindings to libsass  http://hackage.haskell.org/package/hlibsass-0.1.1.0 (jakubfijalkowski)
12:05:32 <monochrom> I don't know too much haskell yet.
12:06:01 <monochrom> but I patiently, focusedly learned
12:06:34 <emmruld> what do you meean by handle outer maybe?
12:07:09 <roboguy_> emmruld: if you have Just 10 and Just 3, how do you apply (*) to them? fmap isn't enough to do that
12:07:51 <monochrom> may I simply use fromJust? :)
12:08:10 <roboguy_> haha, nope that's cheating
12:08:37 <roboguy_> I should say, given two Maybe Ints, how do you apply (*) to them
12:09:12 <monochrom> do you encourage writing my own pattern matching?
12:09:14 <emmruld> roboguy_: And return a Maybe Int?
12:09:22 <roboguy_> emmruld: yeah
12:09:25 <ane> applicatives!
12:10:10 <ane> (*) <$> Just 1 <*> Just 2
12:10:17 <roboguy_> ane: this is an exercise ha
12:10:26 * hackagebot vty-ui 1.9 - An interactive terminal user interface library for Vty  http://hackage.haskell.org/package/vty-ui-1.9 (JonathanDaugherty)
12:10:36 <ane> wait what
12:10:41 <emmruld> > (Just 10) >>= (\x -> Just (3*x))
12:10:42 <lambdabot>  Just 30
12:10:44 <roboguy_> I'm trying to show that Monad is stronger than Functor
12:10:51 <roboguy_> I know Applicative is enough for this though
12:11:08 <roboguy_> emmruld: yep!
12:11:13 <shlevy> What's meant to replace ClassP in new template-haskell? I see Pred is just Type but I'm not sure which constructor for Type to use
12:11:29 <roboguy_> emmruld: well, except you need to take both vlaues
12:11:30 <emmruld> And this is good because we can chain a bunch of monadic functions?
12:11:30 <roboguy_> *values
12:11:54 <roboguy_> yeah, more or less
12:13:36 <emmruld> roboguy_: What's a function that "gets" the value within a Monad without pattern matching?
12:13:50 <monochrom> >>=
12:13:59 <ahihi> > Just 10 >>= (\x -> if odd x then Just x else Nothing) -- can't do this with Functor or Applicative
12:14:00 <lambdabot>  Nothing
12:14:18 <emmruld> monochrom: That returns something of Monad type!
12:14:19 <shlevy> https://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Lib.html#v:classP for those who were wondering
12:14:27 <roboguy_> emmruld: ?
12:14:40 <monochrom> that does not contradict "gets the value"
12:14:42 <roboguy_> oh, you mean something like m a -> a? That's impossible in general
12:15:06 <emmruld> ok, so that's why there's that if-statement in your function, to pattern match on Just and Nothing, right?
12:15:13 <monochrom> for example, in (Just 10) >>= (\x -> Just (3*x)), the x successfully received 10, no?
12:15:34 <roboguy_> emmruld: there's no pattern matching there
12:16:44 <ane> it's not impossible, you just need to use comonads
12:17:00 <kadoban> It's impossible if all you have is Monad
12:17:03 <roboguy_> ane: I meant for monads, since that's what we're talking about right now
12:17:40 <roboguy_> (it's a convention thing, but I usually use w for comonads and m for monads also)
12:19:47 <wswiss> @pl (\x y -> x:y:[])
12:19:47 <lambdabot> (. return) . (:)
12:20:26 * hackagebot mvc 1.0.4 - Model-view-controller  http://hackage.haskell.org/package/mvc-1.0.4 (GabrielGonzalez)
12:22:07 <emmruld> roboguy_: I think I'm a little lost, I can't write a function of type Maybe Int -> Maybe Int -> Maybe Int in terms of >>= and without pattern matching
12:22:19 <wswiss> @pl \(x:l,r) -> (l,x:r)
12:22:20 <lambdabot> uncurry (ap (flip ((.) . (,)) . (:) . head) tail)
12:23:09 <mniip> emmruld, you can write it in terms of fmap/<*>
12:23:13 <mniip> and thus in terms of ap
12:23:29 <roboguy_> emmruld: maybe it would help to write it in do notation and then convert it
12:23:35 <roboguy_> to >>=
12:23:51 <emmruld> That may be my problem, I need to spend more time learning about monads and do
12:24:03 <monochrom> do you want me to show you?
12:24:21 <emmruld> idk, will that help?
12:24:53 <monochrom> it sometimes helps to see a first concrete solution
12:25:05 <emmruld> ok, do eet
12:25:21 <monochrom> f mx my = do { x <- mx; y <- my; return (x*y) }
12:25:41 <emmruld> so <- is the unwrapping function I was looking for before
12:25:49 <monochrom> g mx my = mx >>= (\x -> my >>= (\y -> return (x*y)))
12:25:58 <kuribas> Monads are just a type level thing.  (except for the laws).
12:26:02 <monochrom> most parentheses up there are redundant
12:26:50 <monochrom> it may be intuitive but imprecise to think "unwrap", since f is always translated to g, where there is no "unwrap"
12:27:12 <monochrom> instead, >>= does the necessary pattern-matching for you so you don't have to do it yourself
12:27:34 <kuribas> I found all "intuitive" explanations meaningless, since it just comes down to the types.
12:27:52 <wswiss> @pl \x y z -> x ++ y ++ z
12:27:52 <lambdabot> (. (++)) . (.) . (++)
12:28:02 <monochrom> I agree. intuition is a cost centre, not a revenue centre.
12:28:04 <roboguy_> emmruld: <- isn't a function
12:28:14 <roboguy_> it's a syntactic thing
12:28:14 <ReinH> There are also monads that can't be "unwrapped", like IO and ((->) r)
12:28:43 <monochrom> to a large extent, Maybe already can't be unwrapped. what is there to unwrap when Nothing?
12:28:46 <ReinH> And kind of the point of the Monad typeclass is that you *can* implement bind via join without needing to "unwrap".
12:29:10 <monochrom> only the identity monad can be unwrapped
12:29:13 <numberten> does anyone know if this exists? (a -> b -> a) -> a -> [b] -> [(a,[b])]
12:29:22 <monochrom> ok, perhaps the writer monad too
12:29:29 <wswiss> and the non empty list
12:29:42 <numberten> like a scanl, but instead of getting just the value accumulated so far you get that + the remaining list to be processed
12:29:42 <ReinH> wswiss: how do I unwrap [1,2]?
12:29:58 <emmruld> What value does x get in x <- Nothing?
12:30:02 <monochrom> numberten: is it either mapAccumL or mapAccumR? in Data.List
12:30:02 <wswiss> use head, 
12:30:14 <numberten> monochrom: unsure will check
12:30:23 <wswiss> emmruld: x get's no value, because (>>=) stops the computation
12:30:35 <monochrom> no value. >>= sees "Nothing" and goes on to "Nothing", too. short-circuits.
12:30:46 <emmruld> ok, got it
12:30:52 <wswiss> ReinH: head on [] is partial, but on non-empty lists, it's always total
12:31:03 <monochrom> "Nothing >>= \x -> ..." gives Nothing, without even caring what's in "..."
12:31:03 <ReinH> wswiss: That's a strange definition of "unwrap"
12:31:07 <numberten> monochrom: i think it is, thanks :)
12:31:33 <aruro> speaking of  ((->) r), could someone explain me how join (*) x == x*x ??
12:31:46 <aruro> @pl f x=x*x
12:31:47 <lambdabot> f = join (*)
12:32:05 <ReinH> aruro: join :: (r -> r -> a) -> r -> a
12:32:29 <aruro> :t join
12:32:30 <ReinH> given a function f and a value a, how can you write join? join f a = ???
12:32:30 <lambdabot> Monad m => m (m a) -> m a
12:32:46 <wswiss> join f = \a -> f a a
12:33:00 <aruro> wswiss, i know that
12:33:05 <ReinH> wswiss: the question was for aruro
12:33:19 <monochrom> join (*) x = ((*) >>= id) x = ... how is >>= defined for (->) r?
12:33:36 <numberten> actually similiar, but not exactly the same
12:33:42 <aruro> there is definition for  it in GHC.base
12:33:52 <aruro> the only problem its rather tricky
12:34:18 <monochrom> numberten: I suspected that, too. but I hope you can just add minimal work on top of calling mapAccumL/R
12:34:56 <ReinH> aruro: just write a function join' :: (r -> r -> a) -> r -> a
12:35:01 <ReinH> There aren't a lot of ways you can write it.
12:35:27 * hackagebot texrunner 0.0.1.0 - Functions for running Tex from Haskell.  http://hackage.haskell.org/package/texrunner-0.0.1.0 (cchalmers)
12:35:49 <aruro> ok i think i get it you mean m (m a) -> m a
12:36:00 <ReinH> I mean (r -> r -> a) -> r -> a
12:36:16 <aruro> translates to (r->r->a)->r-> a in case of (->) r monad
12:36:22 <ReinH> Right.
12:37:38 <ReinH> That's how join (*) works
12:38:39 <ReinH> (I don't think using the ((->) r) instance of Monad in this way is particularly elegant, merely clever)
12:38:58 <mniip> [22:30:45] <monochrom> join (*) x = ((*) >>= id) x = ... how is >>= defined for (->) r?
12:38:58 <mniip> something along the lines of '(. flip) . flip (<*>)'
12:39:07 <roboguy_> monochrom: (->) is an unusual case: (>>=) = flip (<*>)
12:39:16 <roboguy_> I mean (->) r
12:39:21 <aruro> > let a = return 3 :: ((->) Char Int)
12:39:23 <lambdabot>  <no location info>:
12:39:23 <lambdabot>      not an expression: ‘let a = return 3 :: ((->) Char Int)’
12:39:32 <aruro> mmm
12:39:41 <roboguy_> a rare case where the Applicative instance is exactly equal in power to the Monad instance
12:39:51 <hjulle> The "(->) r" monad could be read as "(r->)", but haskell doesn't support that syntax on type level.
12:40:00 <mniip> roboguy_, needs more flip
12:40:10 <aruro> @let a = return 3 :: ((->) Char Int)
12:40:11 <lambdabot>  Defined.
12:40:20 <aruro> > a 'b'
12:40:21 <lambdabot>      Ambiguous occurrence ‘a’
12:40:21 <lambdabot>      It could refer to either ‘L.a’, defined at L.hs:141:1
12:40:21 <lambdabot>                            or ‘Debug.SimpleReflect.a’,
12:40:35 <monochrom> we can, then, ask "how is <*> defined for (->) r", too :)
12:40:43 <ReinH> @. djinn type (>>=) `asAppliedTo` (undefined :: a -> b)
12:40:44 <lambdabot> f a b c = b (a c) c
12:40:52 <aruro> @let abc = return 3 :: ((->) Char Int)
12:40:53 <lambdabot>  Defined.
12:41:01 <aruro> > abc 'b'
12:41:03 <lambdabot>  3
12:41:43 <ReinH> @. djinn type (<*>) `asAppliedTo` (undefined :: a -> b)
12:41:44 <lambdabot> f a b c = a c (b c)
12:41:50 <roboguy_> mniip: oh right, one of the functions needs to be flipped too doesn't it?
12:42:03 <ReinH> There are the definitions :)
12:42:08 <mniip> (. flip) . flip (<*>)
12:42:51 <ReinH> @. pl . djinn type (>>=) `asAppliedTo` (undefined :: a -> b)
12:42:52 <lambdabot> f = flip flip id . (ap .) . flip (.)
12:42:58 <ReinH> :D
12:43:02 <ReinH> Easy!
12:43:26 <aruro> @let abcd = return (return 3) :: ((->) ((->) Char Int) Int)
12:43:27 <lambdabot>  .L.hs:143:8:
12:43:27 <lambdabot>      Couldn't match type ‘m0 Integer’ with ‘Int’
12:43:27 <lambdabot>      Expected type: (Char -> Int) -> Int
12:43:28 <monochrom> I like to make the asker do a bit of the legwork when I explain
12:43:45 <monochrom> there are multiple benefits
12:43:52 <ReinH> monochrom: But it's so much fun to make lambdabot do it all :( (Point taken)
12:44:08 <monochrom> hmm, I forgot djinn
12:44:26 <monochrom> but since you use djinn, why not use it for >>= directly?
12:44:41 <monochrom> even for join directly?
12:44:43 <ReinH> I did.
12:44:48 <ReinH> Earlier.
12:44:52 <monochrom> oops, alright, then I love you
12:45:06 <ReinH> I was answering how to write (>>=) in terms of (<*>) aka ap
12:45:10 <ReinH> monochrom: <3
12:45:54 <aruro> @let abcd = return (return 3) :: ((->) ((->) Int Int) Int)
12:45:55 <lambdabot>  .L.hs:143:8:
12:45:55 <lambdabot>      Couldn't match type ‘m0 Integer’ with ‘Int’
12:45:55 <lambdabot>      Expected type: (Int -> Int) -> Int
12:46:37 <mniip> ReinH, you can't
12:46:45 <ReinH> mniip: I just did.
12:47:01 <roboguy_> aruro: you are missing the monad part
12:47:07 <mniip> ah, (>>=) from ap
12:47:16 <aruro> roboguy_ which one?
12:47:31 <aruro> i did twice return, should be m (m a)
12:47:53 <ion> @type return (return 3) :: ((->) Int ((->) Int Int))
12:47:54 <lambdabot> Int -> Int -> Int
12:48:05 <ReinH> aruro: is ((->) ((->) Int Int) Int) the same as m (m a) for some m?
12:48:06 <roboguy_> oh I see what you're saying, I read it too fast. Let's see
12:48:11 <roboguy_> I think it's associated the wrong way
12:48:30 <hunteriam> how do i update ghc on windows?
12:48:38 <aruro> yes
12:48:46 <aruro> it seems i made it like m1 (m a)
12:48:57 <ReinH> aruro: Are you sure?
12:49:03 <ReinH> (They aren't)
12:49:07 <ReinH> That's why it didn't type check.
12:49:12 <aruro> @let abcd = return (return 3) :: ((->) Int ((->) Int Int))
12:49:13 <lambdabot>  Defined.
12:49:20 <mniip> return (return 3) :: m (m' Int) of course
12:49:22 <aruro> ok now works
12:49:25 <ReinH> Yep.
12:49:41 <ReinH> :t abcd
12:49:42 <lambdabot> Int -> Int -> Int
12:49:59 <ReinH> > join abcd 10
12:49:59 <aruro> ok but they look virtually same? int->int->int ?
12:50:01 <lambdabot>  3
12:50:12 <ReinH> aruro: The parens are different
12:50:15 <ReinH> Which is important
12:50:25 <emmruld> when people talk about nondeterminism in terms of the list monad, what does that necessarily mean?
12:50:25 <ion> (Int -> Int) -> Int ≠ Int -> (Int -> Int)
12:50:28 <aruro> ok, interesting
12:50:29 <emmruld> what is nondeterministic?
12:50:29 <ReinH> ion: yep
12:50:43 <aruro> ion, ty
12:50:48 <ReinH> emmruld: nondeterminism is used to mean specifically that it models multiple choices
12:50:51 <ReinH> not that it is random
12:50:55 <aruro> indeed function of two arguments vs function of one
12:51:15 <ReinH> > do { d1 <- [1..6]; d2 <- [1..6]; return (d1, d2) }
12:51:17 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(3,...
12:51:30 <ReinH> This models a nondeterministic roll of 2d6
12:51:37 <aruro> > abcd 2 5
12:51:37 <ReinH> it doesn't give a random result, it gives all possible results
12:51:38 <lambdabot>  3
12:51:46 <ion> f :: A -> (B -> C)
12:51:49 <ion> f a :: B -> C
12:52:15 <emmruld> ReinH: Seems more like combinations
12:52:19 <monochrom> my way of explaining the difference: in randomness, you know the probabilities. in nondeterminism, you don't even know that.
12:52:31 <emmruld> but 'combinations' and 'nondeterminism' aren't interchangeable
12:53:06 <monochrom> why?
12:53:29 <ReinH> emmruld: nondeterminism is being used in the same sense as its use in http://en.wikipedia.org/wiki/Nondeterministic_finite_automaton
12:54:03 <ReinH> emmruld: not interchangeable, but certainly related
12:54:21 <wswiss> what ReinH wrote is more like an analog of the cartesian product for lists.
12:54:29 <monochrom> there is, clearly, an isomorphism between nondeterminism and exhaustive search
12:54:30 <ReinH> wswiss: it is both.
12:54:43 <ReinH> It depends on your viewpoint
12:55:07 <monochrom> [] is an implementation of nondeterminism by exhaustive search
12:55:54 <monochrom> Haskell has no way of implementing nondeterminism by any non-sequential means, since Haskell is not a quantum computing language
12:56:40 <monochrom> see also: determinizing a nondeterministic [finite] automaton
12:56:59 <ion> Haskell is not a quantum computing language – yet
12:57:13 <monochrom> it is still an open question how to do nondeterministic polynomial time things in deterministic polynomial time
12:57:32 <aruro> so if (*) == \ x-> \ y -> x*y | join makes it to be \y ->\y -> y*y == \y->y*y ?
12:57:49 <athan> Hey folks, how would I alternatively run two parsers of different types? Wouldn't the result be some kind of Either?
12:58:02 <monochrom> fortunately, we can make do in deterministic polynomial space, and [] does exactly that if you ensure enough laziness
12:58:13 <ion> (Left <$> pa) <|> (Right <$> pb)
12:58:47 <ReinH> What is the likelihood that a 2d6 roll will be greater than 10?
12:58:51 <ReinH> > let _2d6 = do { d1 <- [1..6]; d2 <- [1..6]; return (d1 + d2) } in map (head &&& length) . group . sort $ do { roll <- _2d6; if roll > 10 then return "hit" else return "miss" }
12:58:53 <lambdabot>  [("hit",3),("miss",33)]
12:59:11 <athan> ion: Thank you :)
13:03:09 <ReinH> monochrom: There are weighted nondeterminism monads iirc
13:05:28 * hackagebot editor-open 0.1.1.0 - Open the user's $EDITOR for text input.  http://hackage.haskell.org/package/editor-open-0.1.1.0 (pharpend)
13:08:50 <aruro> @let abcd = (\x -> x + x) :: ((->) Int Int)
13:08:51 <lambdabot>  .L.hs:144:1:
13:08:51 <lambdabot>      Multiple declarations of ‘abcd’
13:08:51 <lambdabot>      Declared at: .L.hs:143:1
13:09:00 <aruro> @let abcde = (\x -> x + x) :: ((->) Int Int)
13:09:01 <lambdabot>  Defined.
13:09:05 <hjulle> hunteriam: Just download and run the Haskell platform installer again, if that was how you installed it. (Is my guess)
13:09:14 <aruro> what is monadic value in this case? x+x ?
13:10:43 <roboguy_> aruro: the function
13:10:55 <aruro> yes but isnt it m a? what is a?
13:11:07 <roboguy_> m ~ ((->) Int), a ~ Int
13:11:21 <wswiss> aruro: the type is (((->) Int) Int), the value is a function
13:11:25 <hjulle> If (m ~ (->) Int), then (+x) :: m Int and (+) :: m (m Int) 
13:11:32 <wswiss> the a is Int
13:12:06 <aruro> so m a basically holds whole definition of this function?
13:12:18 <roboguy_> that is the type of it
13:12:23 <monochrom> (x +) is the monadic value
13:12:24 <roboguy_> "it" being the function value
13:13:04 <roboguy_> monochrom: don't you mean \x -> x + x?
13:13:31 <wswiss> aruro: m a is the type, where m ~ ((->) r). It's not a definition
13:13:33 <aruro> ok perhaps im forgetting that monad is typeclass
13:13:58 <hjulle> So (m Int ~ Int -> Int), and (m (m Int) ~ Int -> Int -> Int) in this case.
13:14:10 <aruro> yes, ty
13:14:39 <aruro> so the instance of Int->Int will be  \ x -> ...
13:15:01 <aruro> and instance of Int->Int->Int will be  \y -> \x -> ...
13:15:25 <roboguy_> yep! although, "instance" might be a slightly misleading word to use
13:15:38 <aruro> yes, i dont know, value maybe
13:15:46 <roboguy_> yeah, that works better I think
13:15:47 <ttt_fff> is ther esom ehaskell package where I provide (1) a *.ttf file (2) a string, and (3) the pacakge provides a *.png file with the string rendered using the *.ttf font ?
13:15:56 <rezwu> sooo I heard this is where cool people hang
13:16:13 <ttt_fff> this is where smart people chill
13:18:26 <bennofs> > length "foo"
13:18:27 <lambdabot>  3
13:18:55 <rezwu> length “food”
13:18:59 <monochrom> 4
13:19:04 <rezwu> > length “food"
13:19:05 <lambdabot>  <hint>:1:8: lexical error at character '\8220'
13:19:20 <rezwu> I’m confused
13:19:28 <hjulle> Wrong quotation marks
13:19:29 <bernalex> > let length "food" = 5 in length "food"
13:19:31 <lambdabot>  5
13:19:39 <monochrom> " vs “
13:19:46 <bennofs> Just wanted to make sure they did not break length "xxx" in ghci, since I was getting an error. turned out I had -XoverloadedStrings on through .ghci
13:19:48 <ReinH> monochrom: such nondeterminism wow https://gist.github.com/anonymous/fc59ee92ffd8982b6546
13:19:56 <rezwu> monochrom
13:20:02 <rezwu> I feel dumb
13:20:27 <rezwu> ‘’ “ ; 
13:20:31 <ReinH> rezwu used smart qoutes. They were not effective.
13:20:32 <rezwu> where is it
13:20:39 <rezwu> LOL
13:20:50 <monochrom> ReinH: nice
13:21:20 <monochrom> I dislike OverloadedString
13:22:10 <bennofs> monochrom: you surely will like OverloadedLists then!
13:23:04 <monochrom> when I first proposed OverloadedList, I was making it a joke
13:23:10 <ReinH> hahaha
13:23:24 <yminsky> how should one use sandboxes for installing end-user packages? Should I mint a new directory somewhere for each new haskell package I want to install? (bitemyapp, carter)
13:23:25 <monochrom> 3 years later, it became reality.
13:23:51 <carter> yminsky: good question
13:24:10 <monochrom> now just wonder what wonders the GHC people will accomplish if I propose "OverloadedJuxtaposition"
13:24:25 <carter> yminsky: in this case, the real issue is that implicit has absolutely NO version bounds, and hasn't been kept up to date in over 1.5 years
13:24:58 <yminsky> Sure.  I'm just asking the question more generally, since it seems like people think that version conflicts in cabal are a big deal.
13:25:11 <carter> i personally dont use sandboxes for that
13:25:11 <monochrom> anyway, my dislike of OverloadedStrings is just pedagogical. I think it's fine for production use among experts.
13:25:21 <carter> yminsky: but some peole do a sandbox by default approach now
13:25:29 * hackagebot editor-open 0.2.0.0 - Open the user's $EDITOR for text input.  http://hackage.haskell.org/package/editor-open-0.2.0.0 (pharpend)
13:25:43 <carter> if only because it makes it easier to isolate issues
13:25:45 <newsham> weird question.  I have an api "encode :: LBS.ByteString -> IO LBS.ByteString" that can encode an infinite lazy bytestring.  i want to use it to encode several pieces at different times, but all with the same call..  possible?
13:25:50 <carter> in making sure they build oblviously for new users
13:26:03 <newsham> ie. i want to encode the first 20 bytes "now", and then perhaps 10 bytes later.
13:26:06 <yminsky> Sure, seems totally reasonable.  But how does one do it?
13:26:12 <carter> do which?
13:26:15 <roboguy_> monochrom: I think agda has that actually, haha
13:26:25 <hjulle> ttt_fff, This might work http://hackage.haskell.org/package/Rasterific. It seems to support both png and ttf
13:26:30 <roboguy_> well sorta
13:26:32 <carter> yminsky: i'm happy to walk you through whcihever
13:26:35 <yminsky> Set up a separate sandbox per package install.
13:26:38 <carter> ok
13:26:53 <carter> mkdir FOO ; cd foo ; cabal sandbox init ; cabal installl thingIWant
13:27:17 <carter> yminsky: in the case of the implicitCad project, we'll have to do a wee bit of history spelunking to reconstruct what version bound probably worked
13:27:26 <carter> yminsky: i'm happy to walk you through that process
13:27:33 <yminsky> OK, so if I do this with pandoc, then pandoc gets installed in FOO, and I have to add FOO/pandoc or somesuch to my path?
13:27:41 <carter> yminsky: pandoc odesnt have that problem
13:27:59 <yminsky> Sure, but let's say I want to isolate my pandoc install from other crazy packages that have different version desires.
13:28:08 <carter> cabal install pandoc -fembed_data_files is a totally relocatable binary
13:28:11 <carter> *results in
13:28:21 <carter> yminsky: implicitCad will need a sandbox
13:28:32 <yminsky> is -fembed_data_files a general purpose thing?  or pandoc-specific?
13:28:35 <carter> pandoc
13:28:39 <ReinH> monochrom: "Among experts"... or people who want to use any of the many popular libraries that use them for a variety of often unnecessary things...
13:29:01 <carter> yminsky: otherwise it dpeends on some share/dir for a bunch of default templates
13:29:02 <yminsky> Is this workflow documented somewhere?
13:29:09 <carter> yminsky: pandocs?
13:29:11 <carter> or sandboxes?
13:29:19 <yminsky> Yes.
13:29:39 <carter> yminsky: if you look at the bottom of http://hackage.haskell.org/package/pandoc, you'll see a list of flags
13:29:46 <carter> every package page lists package flags
13:29:50 <carter> at the bottom
13:29:51 <carter> when they exist
13:29:57 <enthropy> newsham: forkIO $ pieces <- getChanContents chan; encode (LBS.concat pieces)?
13:30:13 <enthropy> but I think getChanContents is a bit iffy there
13:30:16 <monochrom> instead, I think that the syntax of import clauses could use a lot of improvements and streamlining
13:30:29 * hackagebot total 1.0.3 - Exhaustive pattern matching using lenses, traversals, and prisms  http://hackage.haskell.org/package/total-1.0.3 (GabrielGonzalez)
13:30:46 <ReinH> enthropy: 9missing a do)
13:30:47 <carter> on the sandboxes front, theres several different work flows people use sandboxes in
13:30:50 <ReinH> s/9/(
13:31:08 <newsham> let me try that out.
13:31:16 <enthropy> more importantly it's missing a way to signal that no more pieces are coming
13:31:33 <carter> i treat sandboxes as a way of doing parallel dev on disjoint apps that may have different api version constraints, perhaps because they're both long running projects with different life cycles of dev
13:31:35 <enthropy> and also it probably you're expecting side effects to happen sooner than in that code
13:31:54 <enthropy> (though maybe getChanContents does unsafeInterleaveIO)
13:31:55 <merdam> https://www.youtube.com/watch?v=5cqy4-vCo0M
13:32:00 <carter> and i otherwise dont use sandboxes and refuse to use libs that have overlly pinned version constraints
13:32:10 <carter> if only because everything builds faster that way
13:32:39 <yminsky> sandboxes seem problematic for ordinary dev work, perhaps, but quite nice for "I want to build this piece of old software"....
13:32:40 <carter> yminsky: thers actually 1-2 gsoc projects this summer to allow normal cabal/ghc pkg dbs to work more akin to how sandboxes work
13:32:44 <carter> yeah
13:33:06 <enthropy> newsham: I think the real solution is to replace encode with something that's an iteratee/conduit/pipe/whatever the popular thing for that is today
13:33:11 <carter> yminsky: i actually push very hard to always engineer code as if its a library which depends on libraries, and which may be used to write a library
13:33:20 <carter> (kinda edwardk style i guess)
13:33:20 <yminsky> OK, I actually need to run, but I now have a working pandoc again, and I at least understand the implicit issue.
13:33:29 <carter> yminsky: yay
13:33:31 <carter> i hope i helped
13:33:35 <yminsky> totally.
13:33:41 <yminsky> thanks again.
13:33:43 <carter> have a great tax weekend
13:33:44 <carter> no problem
13:33:54 <carter> let me know if that coffee is owed at some point :)
13:33:57 <carter> i'm in the city
13:34:01 <newsham> entropy: its in a 3rd party lib
13:34:09 <newsham> that i really would like to avoid patchign or replacing
13:34:31 <l3france> is it possible to pattern match the same thing twice (use the same identifier to indicate that both parameters are equal) or do I have to use a guard to do that?
13:34:47 <hjulle> Why pin version constraints unless you _know_ that it doesn't work?
13:34:52 <merdam> https://www.youtube.com/watch?v=5cqy4-vCo0M
13:35:01 <carter> hjulle: its what peole do in java/ruby land
13:35:30 * hackagebot llvm-general-pure 3.3.14.3 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.3.14.3 (BenjaminScarlet)
13:35:32 * hackagebot llvm-general 3.3.14.3 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.14.3 (BenjaminScarlet)
13:35:40 <hjulle> carter, Which one?
13:35:46 <carter> idk
13:35:50 <carter> version pinning in apps
13:37:19 <hjulle> carter, It was unclear if you meant that they use unneceserily strict bounds or optimistic.
13:37:32 <carter> both suck
13:37:39 <carter> lack of any version bounds is like having no pands
13:37:56 <carter> pinning deps too tightly means i can't reuse things without doing surgery
13:39:12 <hjulle> Have good tests and use newests unless tests fail or api changes. That should be possible to automate. (except the "write good tests" part)
13:39:15 <newsham> i'm not sure i follow. 1) is forkio necessary, 2) how do you recommend I get the output out of the forkio, with a 2nd channel?
13:39:48 <hjulle> carter, What is "pands"?
13:39:54 <carter> a typo
13:40:07 <carter> *dependencies
13:40:30 * hackagebot llvm-general-pure 3.4.5.3 - Pure Haskell LLVM functionality (no FFI).  http://hackage.haskell.org/package/llvm-general-pure-3.4.5.3 (BenjaminScarlet)
13:40:32 * hackagebot llvm-general 3.4.5.3 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.4.5.3 (BenjaminScarlet)
13:41:09 <monochrom> I have long deplored the length of the word "dependencies". maybe it's wise to replace it by "pands" anyway. :)
13:41:49 <mauke> "deps"
13:41:49 * dented42 seconds the motion
13:42:00 <mauke> or "prereqs"
13:42:08 <enthropy> newsham: I originally read it as encode :: BS -> IO (), not encode :: BS -> IO BS. I think you might not need to make another thread if you're going to unsafeInterleaveIO the encode
13:42:13 <ReinH> monochrom: "imminent disasters" is longer but more accurate
13:42:35 * dented42 giggles
13:43:02 <enthropy> ie.   do cts <- getChanContents chan; results <- unsafeInterleaveIO (encode (LBS.concat cts)); ... stuff that can touch results a bit ...
13:43:08 <hjulle> Ok, I guess that using major version numbers for api-change is an acceptable compromise, but I do not see why you couldn't automate the process of selecting version bounds?
13:43:13 <lpaste> newsham pasted “channels and chunks” at http://lpaste.net/130548
13:43:17 <newsham> i think i have it...
13:43:25 <Zemyla> Why does encoding a bytestring require IO?
13:43:34 <hjulle> *breaking api-change
13:44:02 <ReinH> Zemyla: phase of moon checks, probably
13:44:13 <hpc> it's for uploading to the NSA
13:44:19 <newsham> now i hope that the chunks come out the same size as they go in :)
13:45:12 <hjulle> carter, How is having no bounds like having no deps?
13:45:44 <merdam> Eat my diarrhea!
13:45:50 <merdam> Just ate a burger at a sleazy joint!
13:45:55 <merdam> Now i've got to take a shit!
13:45:59 <merdam> Get to the point!
13:46:05 <merdam> Sitting on the toilet.  My ass is a blast!
13:46:15 <merdam> Fiery smelly diarrhea out of my ass!
13:46:17 <merdam> No fucking paper!
13:46:23 <ReinH> @where ops
13:46:23 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
13:46:26 --- mode: ChanServ set +o mauke
13:46:26 --- kick: merdam was kicked by mauke (merdam)
13:46:34 --- mode: mauke set +b $a:Nigrarama
13:46:56 <johnw> hmm... not even really related to FP, sadly
13:47:10 <johnw> same inputs won't always result in the same outputs
13:47:52 <Zemyla> Burger -> IO Diarrhea?
13:48:10 <johnw> well, I suppose producing the action is truly functional
13:48:16 <johnw> ok, I'll let it pass
13:48:38 --- mode: mauke set -o mauke
13:49:14 <newsham> woot! it works!  thank you enthropy!
13:49:17 <ReinH> Aaanyway.
13:53:40 <Zemyla> Hmm, if GHC went from a State#-based IO model to a free monad-based one, how would the subset of IO actions that could be put into ST be handled?
13:54:34 <jle`> I presume you mean some sort of interpreter monad?
13:54:54 <jle`> encoding actions as constructors of an ADT?
13:55:02 <carter> hjulle: again, your'e reading my typoes literally
13:55:03 <carter> no bounds on deps
13:56:24 <lpaste> newsham pasted “lazy codec to stream codec” at http://lpaste.net/130549
13:56:49 <hjulle> "lack of any version bounds is like having no bounds on deps"? I still don't understand.
13:57:13 <carter> no
13:57:20 <Cale> Zemyla: You could have a functor giving the operations of the ST monad, and then a corresponding constructor for the IO monad's functor which "includes" that, essentially.
13:57:26 <carter> youre reading without your brain fixing the typoes
13:57:47 <carter> oh, pands = bounds
13:57:55 <monochrom> haha
13:58:42 <hjulle> carter, I know I haven't gotten the right meaning, but, couldn't you please just say what you meant, instead of just sending patches on the incomprehensable sentance.
13:58:48 <carter> nope
13:58:53 <hjulle> :P
13:58:55 <carter> i'm doing other stuff
14:00:41 <Cale> The package versioning policy kind of bothers me, because upper bounds can never really be taken seriously
14:00:44 <schell> yesterday i asked if anyone had done some quick and dirty benchmarks of various mutable references so last night i just did it real quick - http://zyghost.com/benchmarks/mutable-references.html
14:00:58 <Cale> At least, most of them
14:01:20 <hjulle> carter, At least I'm in good company since you are writing without using your brain. ;) But I don't actually think insults is a constructive way to have a conversation.
14:01:21 <schell> source for that benchmark ^ http://lpaste.net/130540 
14:01:29 <merijn> Cale: That's why I'm in favour of no upperbounds and retroactively fixing them on hackage
14:01:51 <jle`> by editing meta data?
14:01:55 <jle`> that's a nice idea
14:01:56 <merijn> yeah
14:02:01 <merijn> jle`: That's already possible
14:02:06 <jle`> yeah
14:02:10 <merijn> hvr has been doing a lot of fixing like that
14:02:11 <jle`> it seems so obvious now
14:02:19 <monochrom> oh! that's an interesting thought
14:02:30 * jle` goes and removes all of his upper bounds and sets them on hackage metadata
14:02:41 <Cale> In fact, I have a counter-proposal: if you put a bound on a package version, at least one version of the package must already exist which refutes that bound.
14:02:54 <monochrom> ahem, jle`, that is retroactively removing, not adding, upper bounds :)
14:03:00 <Cale> So that the bound is forced to be meaningful, you can't just put some random number there.
14:03:29 <jle`> monochrome I meant remove them on my HEADs, hehe
14:03:40 <monochrom> I agree with Cale too. I think the two requirements can be combined safely
14:03:54 <jle`> retroactively removing them on hackage will definitely be a bad idea
14:04:22 <monochrom> i.e., initially, omit upper bounds; subsequently, every upper bounds added must be sharp
14:04:49 <hjulle> I completely agree too
14:05:39 <jle`> omit upper bounds on the actual cabal file. then update them fluidly on hackage metadata. cabal won't install them if the metadata forbids them, so you can just chop it up or forbid however you want to and change when you notice a breaking change
14:06:45 <carter> no,
14:06:51 <carter> every hackage version needs bounded ranges
14:07:02 <carter> or the solver can pick bad old versions that have weak bounds
14:07:41 <merijn> carter: You can edit bounds after the fact on hackage
14:07:50 <hjulle> Coundn't you add bounds to them before uploading the new version then?
14:08:33 <hjulle> As long as you run tests every time a dependency is uppgraded, it shouldn't be a problem otherwise.
14:10:36 <ReinH> monochrom: That sounds about right. We've been having a lot of internal discussion about upper bounds and I suspect that plan might actually achieve consensus...
14:11:11 <ReinH> merijn: I'm pretty sure carter knows that given that he's added revisions before.
14:11:18 <hjulle> schell, What are PRef, BRef and URef?
14:11:50 <merijn> ReinH: Well, then I don't understand what he was referring to
14:11:59 <schell> hjulle: they’re some other mutable references written by … michael snoyman, i believe
14:12:18 <schell> PRef and URef are for unboxed types 
14:12:26 <schell> hence why they are so fast afaik
14:12:27 <hvr> Cale: https://ghc.haskell.org/~hvr/buildreports/persistent.html
14:12:47 <hvr> Cale: guess what happened at 1.1.0.1
14:13:01 <schell> hjulle: http://hackage.haskell.org/package/mutable-containers-0.3.0/docs/Data-Mutable.html#t:MutableContainer
14:13:07 <Cale> hvr: What is this I don't even
14:13:21 <hjulle> schell, Thanks
14:13:33 <bergmark> hvr: :D
14:13:38 <jmcarthur> there could be two kinds of package bounds. one to describe the range of versions the package is known to work with. the other to describe the range of versions the package is known not to work with. cabal would prefer the first set, but would be willing to try versions outside of those bounds so long as they do not exist in the second set of bounds.
14:13:51 <hvr> Cale: heh... it's a matrix of persistent versions vs. GHC versions
14:14:46 <Cale> hvr: ah, okay, so at some point all versions start failing to build due to dependencies?
14:15:51 <hvr> Cale: yeah... and to be more specific, this is what changed in 1.1.0.1: http://hdiff.luite.com/cgit/persistent/diff/persistent.cabal?id=1.1.0.1
14:16:09 <hvr> Cale: the noteworthy thing is that the stuff before 1.1.0.1 still builds 
14:16:16 <hvr> thanks to upper bounds
14:16:43 <Cale> hvr: I'm not arguing that upper bounds should not occur, I'm saying they should always be meaningful, in the sense that a version of the package should exist which violates the bound.
14:17:44 <hvr> Cale: well, then you don't really need the PVP, do you? :)
14:18:06 <Cale> This would be a different PVP :)
14:18:11 <ReinH> Cale: One of the issues I want to avoid is exactly preemptive upper bounds that erroneously exclude new versions that actually are compatible.
14:18:11 <hvr> (and you should hope that .cabal editing occurs swiftly after the breaking evidence occurs)
14:18:14 <monochrom> I would keep PVP for human consumption
14:18:49 <merijn> hvr: That same problem applies now to swiftly loosening the bounds
14:18:49 <ReinH> The problem isn't PVP in principle, it's PVP in application: we rarely have perfect knowledge about what a new version might break.
14:19:16 <monochrom> think of PVP as human-written doc for human readers
14:19:16 <hvr> merijn: it's a problem in a different direction though; right now delaying only holds back *new* install plans
14:19:24 <Cale> i.e. All constraints on version numbers should be required to have a refutation in existence at the time they're applied, and we should be able to apply them retroactively (as we already can, I suppose)
14:19:44 <hvr> merijn: while delaying to restrict bounds lets install-plans bitrotten into build failures
14:20:25 <bergmark> i'm so happy we switched to dependency freezing :-)
14:20:55 <hvr> bergmark: that only helps those who use that :)
14:21:25 <bergmark> sure sure
14:21:30 <hvr> bergmark: otoh, if you start with a fresh 'cabal install', you don't have any freeze yet
14:21:54 <hvr> i.e. you have to find a valid install plan first
14:21:58 <hvr> you can freeze
14:21:59 <bergmark> we based our first freeze on stackage
14:22:15 <bergmark> i'm not arguing against pvp btw :-)
14:22:54 <Cale> I wonder if we could do some sort of distributed computation of which package combinations work (i.e. have successful builds of each package send a record of the package versions in use to the server) in order to automatically compute upper bounds when a new release of something begins to cause failures.
14:22:58 <hvr> bergmark: ...don't let that get in the way of a good argument =)
14:23:30 <bergmark> Cale: isn't that pretty much stackage?
14:23:32 <hvr> Cale: it's a very large configuration space though
14:23:40 <Cale> hvr: That's true
14:23:51 <Cale> bergmark: I don't know much about stackage
14:23:58 <hvr> bergmark: stackage is a reduced low-dimensional solution
14:24:17 <hvr> bergmark: it doesn't help much with computing proper bounds
14:24:19 <johnw> stackage would be a manually discovered subset of what Cale is proposing
14:24:41 <johnw> if you had Cale's auto-discovery, you could download it as a cabal config file, and bypass the need for stackage altogether
14:24:42 <bergmark> stackage is a "program" where snoyberg tells you that your package is broken
14:24:52 <hvr> bergmark: otoh, it does help detect when upper bounds can be relaxed
14:25:53 <hvr> johnw: how would you select which combination you want?
14:26:25 <hjulle> Specifically checking for upper bounds shouldn't need that big configuration space.
14:26:26 <hvr> there's not necessarily a single unique optimum 
14:26:54 <Cale> Yeah, it's very high dimensional and there might be many maxima.
14:26:55 <johnw> hvr: a query interface saying "I'd like to use lens 4.8 and snap XXX, is there a config that works?"
14:27:01 <hvr> hjulle: btw, it's also not a "convex" config space
14:27:06 <Cale> Well, "very high" compared to some problems at least :)
14:27:17 <hvr> johnw: and what if there are multiple?
14:27:21 <johnw> "I want a config set that maximizes the versions of edwardk packages"
14:27:22 <Cale> It's not like, Google-complete or something :)
14:27:27 <johnw> hvr: you just pick
14:27:35 <johnw> right now, Snoyman is "just picking" for you
14:27:47 <hpc> is that like turing-complete?
14:27:50 * monochrom cringes at the idea of Google-completeness
14:27:58 <Cale> monochrom: lol
14:28:42 <hjulle> Assuming that breakage caused by your dependencies is independent would help a lot. (Should be true most of the time)
14:28:45 <johnw> i mean, ideally you want some machine learning algorithm that can decide the "most functional, most featureful, everything works well together" version set, so you can just track that via GitHub
14:29:20 <johnw> i'm sure you could set some hard criteria to narrow the set of possibilities too
14:29:25 <johnw> like: git-annex, yesod and lens must all work
14:29:35 <hvr> johnw: however, I generally think we should be able to automate a lot more than we do right now
14:29:40 <johnw> absolutely
14:29:53 <johnw> we just need a fleet of build machines to iterate through the graph space
14:30:06 <johnw> note, Nix kind of does this too
14:30:15 <johnw> we're just a lot less conservative than Snoyman
14:30:42 <Cale> Well, I'm also just thinking in terms of the user experience when something goes wrong regarding aggressive version choices, it would be nice if not only we could begin to get data on what doesn't work and hopefully produce decent upper bounds automatically, but also we could say "well, okay, that solution didn't work, but we know a bunch that do work, let's see if we can find one which is consistent with the user's or
14:30:42 <Cale> iginal package configuration and try something conservative"
14:30:46 <johnw> we prefer to track all of "current" Hackage, regressing packages that break as minimally as possible
14:31:44 <johnw> it's a pretty interesting graph solvability problem, I think
14:31:47 <Cale> Or provide some choices to the user
14:32:05 <StoneCypher> windows nt's network setup stuff used to use a prolog to sort of that end
14:32:28 <Cale> "I just want it to work" vs. "Back off the version only slightly even if you don't already know it'll work, I have all day"
14:33:38 <Cale> StoneCypher: There's basically a bunch of prologesque stuff already going on
14:34:09 <hjulle> You could use lazy evaluation and just try version combinations that people asks for (plus some that should obviously be tried).
14:34:13 <Cale> StoneCypher: It's just figuring out how we want to extend our "Prolog database" with new constraints as people add new versions of packages
14:35:13 <Cale> It's a hard problem for computers to do, but it's at least as hard a problem for humans to do.
14:36:07 <johnw> maybe an easier problem to automate would be: take stackage version X, and inch all its packages forward to their furthest compatible extent
14:36:30 <johnw> although, you'd still have to do it as a branching solver
14:37:10 <haskell176> Am I doing this right? http://lpaste.net/130554
14:37:13 <johnw> because you might have a choice of inching one package 1 version, or another package 2 versions, and then you want to know both of these details so you can pick the 2 version move
14:37:24 <Cale> There are also stupid things like that maybe just one intermediate version of a package is sitting there being broken, and all the versions around it work.
14:37:32 <johnw> yeah, that too
14:37:42 <johnw> so you'd probably want to jump to the current version first, and work backwards
14:37:56 <johnw> if only the deciding process weren't so costly
14:38:04 <johnw> but even still, I bet the Net cost would be lower than the human cost
14:39:12 <Cale> haskell176: Does (4) actually apply there? Which way is it supposed to be associated?
14:39:17 <hjulle> The only versions you really need to test
14:39:51 <Cale> haskell176: <*> normally associates to the left, so x <*> y <*> z means (x <*> y) <*> z
14:40:27 <Cale> haskell176: I think you want to lead off by applying (2)
14:40:43 <haskell176> Okay, will try 2 first
14:41:05 <hjulle> ... are the latest and those which another package depends on. If a package doesn't work with the latest, you progressively test older versions until you find one that works and save that.
14:41:15 <haskell176> or should I interchange and then do (2)?
14:41:22 <Cale> er, right
14:41:34 <Cale> You have to interchange because x is not of the form pure x :)
14:41:57 <Cale> hmm
14:42:23 <Cale> But you can't apply interchange either
14:44:39 <haskell176> pure (flip ($)) <*> x <*> pure f /= pure (flip($)) <*> x <*> pure f
14:44:47 <haskell176> oops
14:45:08 <Cale> The thing you're starting with is (pure (flip ($)) <*> x) <*> pure f
14:45:16 <haskell176> pure (flip ($)) <*> x <*> pure f /= pure (flip($)) <*> pure f <*> x
14:45:29 <haskell176> oh
14:45:47 <hjulle> Or are there other reasons than dependency incompability that would cause you to want an older version of a package? I guess regressions, to answer my own question.
14:46:44 <haskell176> then would it be
14:46:53 <Cale> hjulle: Some people also want to keep themselves fixed to certain versions of certain packages just for stability's sake during a project.
14:47:04 <haskell176> pure f <*> pure (flip ($)) <*> x
14:47:19 <bitemyapp> yminsky: hey
14:47:36 <hjulle> Cale, But not fixed versions for all packages?
14:47:44 <bitemyapp> yminsky: usually what I do is make a dir, don't bother making a *.cabal file if I don't need one, and then just cabal sandbox init && cabal install packages i-want to-install
14:48:06 <haskell176> (pure (flip ($)) <*> x) <*> pure f = pure f <*> (pure (flip ($)) <*> x) from (interchange)
14:48:10 <bitemyapp> yminsky: I wrote a guide here that covers some of the basics of using sandboxes, albeit with an actual project, not just for installing stuff: http://howistart.org/posts/haskell/1
14:48:59 <yminsky> bitemyapp: thanks. I'll take a look.
14:51:18 <hjulle> Cale, That problem could probably be solved by something like nix or sandboxes. That way you could keep the dependencies of the project fixed, while upgrading for the rest of the system.
14:51:29 <Cale> hjulle: True, that's more likely.
14:54:24 <bitemyapp> yminsky: so for example, if I wanted a local copy of pandoc, I'd    mkdir pandoc && cd pandoc && cabal sandbox init && cabal update && cabal install pandoc
14:54:35 <bitemyapp> yminsky: then I'd just symlink the pandoc binary into my /usr/bin.
14:54:57 <bitemyapp> yminsky: then if I need to kerplooey my ~/.ghc, it doesn't affect anything isolated in that manner. (You never need to wipe ~/.cabal)
14:55:06 <yminsky> bitemyapp: makes sense.
14:55:18 <lpaste> Cale annotated “No title” with “No title (annotation)” at http://lpaste.net/130554#a130558
14:55:20 <bitemyapp> yminsky: I basically never use my user package-db, for the record. I'm considered an oddball but it means I almost never have breakage.
14:55:26 <bitemyapp> sandbox 99% of the time.
14:55:29 <bitemyapp> just like Python, really.
14:55:29 <Cale> haskell176: ^^
14:56:05 <haskell176> thanks!
14:56:37 <Cale> I guess there really ought to be another step around where I used "definition of section notation"
14:56:43 <Cale> I did a beta reduction there.
14:56:57 <monochrom> bitemyapp: actually, as almost everyone moves towards sandboxing, they end up never adding to or using the user db, too
14:57:02 <Cale> ($ f) is really defined to be (\u -> u $ f)
14:57:33 <monochrom> in fact, I am the oddball who insists that the user db is useful
14:57:34 <merijn> Cale: Is it? I thought sectioning had different strictness from lambda's
14:57:53 <lpaste> Cale revised “No title (annotation)”: “No title” at http://lpaste.net/130558
14:58:23 <hjulle> I'm wondering if there is a good way to allow people to request that old versions of a package should be maintained in the compatability database without it being too abused and cluttered. (assuming my suggestion of automatically selecting the subset of all versions and packagages needed to build the latest version of each package)
14:58:31 <monochrom> merijn: in GHC, sectioning used to have different strictness from lambdas. one day, someone pointed it out, and GHC fixed it
14:59:05 <monochrom> since the Haskell report required sameness. (5 +) = (\x -> 5 + x) rather than (+) 5
14:59:13 <Cale> (I added the extra step there)
15:00:30 <Cale> monochrom: Oh really? Of course, it's not an issue for the section I was discussing, ($ f) has to translate to a lambda, but I actually thought the report specified that (x *) was (*) x
15:00:36 <Cale> I guess not!
15:01:31 <TheKing> $ cabal install aeson Resolving dependencies... cabal: Could not resolve dependencies: trying: aeson-0.8.0.2 (user goal) trying: base-4.8.0.0/installed-1b6... (dependency of aeson-0.8.0.2) trying: vector-0.10.12.2 (dependency of aeson-0.8.0.2) next goal: primitive (dependency of vector-0.10.12.2) rejecting: primitive-0.5.4.0 (conflict: base => ghc-prim==0.4.0.0/installed-7c9..., primitive => ghc-prim>=0.2 && <0.4) Dependency tree e
15:01:41 <TheKing> any help
15:02:28 <merijn> TheKing: You're trying to install using GHC 7.10 and the stuff you wanna install hasn't been updated yet
15:02:32 <haskell176> what is eta expansion?
15:02:40 <bergmark> aeson builds fine on 7.10
15:02:42 <TheKing> oh wait, nvm
15:02:49 <TheKing> wait no
15:02:50 <merijn> TheKing: So the help boils down to: 1) downgrade to GHC 7.8 or 2) patch the stuff that's not building
15:02:58 <monochrom> eta is "f = (\x -> f x)"
15:03:01 <shlevy> *almost* got all the way to building my project with 7.10
15:03:19 <shlevy> Was able to patch around everything but seem to have hit a wall with diagrams-lib
15:03:19 <TheKing> I think I'll downgrade.
15:03:45 <TheKing> @define eta f = (\x -> f x)
15:03:47 <lambdabot>  Defined.
15:03:57 <jle`> :t eta
15:03:58 <lambdabot> (t1 -> t) -> t1 -> t
15:04:03 <bergmark> shlevy: i managed to to that earlier this week :-) still needs some patches though
15:04:03 <Cale> heh
15:04:06 <mniip> eta === ($)
15:04:15 <TheKing> eta === id
15:04:16 <Cale> :(
15:04:26 <mniip> TheKing, type-constrained id
15:04:29 <mniip> which is ($)
15:04:39 <TheKing> yeah
15:04:55 <shlevy> bergmark: How'd you do it? And what's left?
15:04:56 <TheKing> :t id :: (t -> t1) -> t -> t1
15:04:56 <bergmark> TheKing: unless you like mucking around with this stuff i'd recommend staying with 7.8 at least until https://github.com/fpco/stackage/issues/378 is closed
15:04:57 <lambdabot> (t -> t1) -> t -> t1
15:05:01 <Cale> eta expansion is the rule which says that you can replace f with (\x -> f x) without affecting the meaning of the program, it's not a function.
15:05:08 <bitemyapp> monochrom: it's common to beginners that run through the guide, but I wasn't sure how common it was for the wider community.
15:05:12 <jle`> id can be unified with all uses of eta, but eta cannot be unified with all uses of id. so i guess it's a weird ===.  eta and ($) however can always be swapped
15:05:26 <monochrom> I see.
15:05:27 <jle`> disregarding fixity
15:05:31 <Cale> eta is not the same *kind* of thing as id at all
15:05:53 <monochrom> @undefine
15:05:53 <lambdabot> Undefined.
15:05:55 <Cale> eta is a rule *about* programs, not a program itself
15:06:09 <bergmark> shlevy: i fixed a bunch of compile errors? :-) pretty much. I'm still waiting for new versions of 4 packages but have forked them onto our local hackage
15:06:10 <mauke> under what conditions is eta expansion/contraction valid?
15:06:16 <haskell176> is it like you explicitly give some function f some argument?
15:06:27 <mauke> is it just f /= _|_?
15:06:32 <jle`> haskell176: it's replacing `f` with `\x -> f x`
15:06:41 <haskell176> ah.
15:06:49 <jle`> so if you go into your program and find an `f` and replace it with `\x -> f x`, that's eta expansion
15:07:04 <mniip> by the same token, replacing '\x -> f x
15:07:06 <shlevy> bergmark: Are they upstream? I've seen a bunch of changes since hte 1.2 branch and I'm not sure what minimal stuff to pull in
15:07:07 <jle`> for example, map show [1,2,3]...i could eta expand `show` into map (\x -> show x) [1,2,3]
15:07:09 <mniip> ' with 'f' is called eta reduction
15:07:26 <jle`> if you really wanted to.
15:07:50 <jle`> eta reduction is the other way...turning map (\x -> show x) [1,2,3] into map show [1,2,3]
15:08:00 <Cale> mauke: Yeah, in the presence of seq, you have to know that f is not _|_
15:08:36 <shachaf> Unnecessary eta expansion can make your programs asymptotically slower. It's great.
15:09:17 <bergmark> shlevy: 1.2 of what?
15:09:29 <shlevy> diagrams-lib :)
15:09:33 <mniip> why would bottom invalidate the eta expansion/reduction?
15:09:54 <shlevy> bergmark: Sorry, were you just referring to fixing a bunch of packages in general? Maybe there's my confusion :D
15:09:55 <bergmark> shlevy: oh, i missed that part! not using diagrams
15:10:03 <bennofs> mniip: if f = undefined, then f `seq` 3 = undefined while (\x -> f x) `seq` 3 = 3
15:10:15 <shlevy> bergmark: I confused your nick with bergey`  :D
15:10:20 <mniip> fair enough
15:10:31 <bergmark> too many bergs
15:10:41 <mniip> (\x -> f x) has a different WHNF than f
15:10:43 * hackagebot filediff 0.1.0.6 - Diffing and patching module  http://hackage.haskell.org/package/filediff-0.1.0.6 (bgwines)
15:11:25 <shlevy> bergey`: byorgey: Any idea on when a 7.10-compatible diagrams-lib might hit hackage?
15:12:41 <haskell176> whats a beta reduction?
15:13:11 <mniip> function application
15:13:25 <Cale> haskell176: replacing (\x -> y) z with y where all free occurrences of x replaced by z
15:13:33 <TheKing> yep
15:13:42 <monochrom> (\x -> f x x) (g y) becomes f (g y) (g y)
15:14:07 <TheKing> If I have (\x -> bla)(z), it means I can just replace that with bla, except any (free) x in bla becomes a z.
15:14:57 <mniip> the entire ghc is a big beta reduction machine :P
15:15:29 <mniip> with a bit of laziness though
15:15:32 <TheKing> @mniip With shortcuts and type extensions.
15:15:33 <lambdabot> Unknown command, try @list
15:15:51 <sellers> silly lambdabot
15:16:23 <monochrom> no, lambdabot is not silly
15:16:36 <monochrom> lambdabot used @ long before twitter existed
15:17:12 <haskell176> ah. gotcha
15:17:19 <TheKing> I haven't used lambda bot in a while.
15:17:27 <kadosh> hello 
15:17:33 <kadosh> I'm trying to install pandoc
15:17:37 <kadosh> with cabal
15:17:39 <Cale> Yeah, a lazy evaluator is *almost* "find the outermost subexpression which is beta reducible and reduce it", with the caveat that when you do the "substitution", you're putting in a reference to something whose evaluation will be shared between the occurrences of the variable you substituted for.
15:17:57 <kadosh> but I have alot of dependencies issues
15:18:01 <kadosh> i'm unsing
15:18:25 <kadosh> --max-backjumps=-1
15:18:32 <kadosh> cabal install pandoc --max-backjumps=-1
15:18:44 <kadosh> but still it has issues compiling zip 
15:18:57 <kadosh> so I wonder if this should be straight forward or there is something else
15:19:01 <kadosh> because every tutorial is the same
15:19:35 <mniip> monochrom, lambdabot is over 9 years old?
15:20:21 <monochrom> yes
15:20:34 <mniip> fancy
15:23:50 <shlevy> \o/ got it
15:23:53 <haskell176> How does flip turn (\t -> flip ($) t f) into (\t -> ($) f t)
15:24:44 <monochrom> flip x g f = x f g, for all x, g, f. therefore, flip ($) t f = ($) f t
15:25:07 <mniip> you replace flip with its definition and then beta-reduce it
15:33:10 <srhb> ryantrinkle: So, try-reflex gives me a nix-shell, but how do I reopen a nix-shell after dropping out of it the first time?
15:33:30 <ryantrinkle> same way; it will re-use all the downloaded/built resources
15:33:56 <srhb> Ah!
15:33:58 <srhb> Thank you.
15:34:00 <ryantrinkle> srhb: no problem :)
15:35:44 * hackagebot functor-monadic 0.1.0.2 - Monad-style combinators for functors.  http://hackage.haskell.org/package/functor-monadic-0.1.0.2 (jtapolczai)
15:36:18 <jle`> i had such an emotional reaction to that `flow` package that was announced on reddit :|
15:36:38 <StoneCypher> the js typing one?
15:36:40 <jle`> so strongly that i had to check myself and ask myself why it was able to make me feel so strongly ><
15:37:06 <jle`> oh no, the language. i also felt strongly about that too but in a good way
15:37:15 <jle`> *oh no, not the language
15:37:28 <jle`> i meant the recent package on hackage that gives you (|>) and reverse-composition idioms
15:37:43 <jle`> and showed a lot of idiomatic code re-written to use these new ones
15:38:51 <jle`> it was one of those moments that made me step back and consider that my emotional investment in these things has gotten way too high. v.v
15:40:51 <jhance> @find fate stay 14 720
15:40:52 <lambdabot> Not in scope: type variable ‘fate’
15:40:52 <lambdabot> Not in scope: type variable ‘stay’
15:40:57 <jhance> god every time
15:44:55 <roboguy_> jle`: I don't think you're alone in that
15:45:25 <jle`> alone in investing things too much, or alone in reconsidering emotional investment?
15:45:54 <roboguy_> probably both
15:47:10 <roboguy_> compose does seem like a bad name for that one function. It really is backwards from what everyone else calls compose and it's visually backwards from how it's defined
15:49:10 <lamefun> is cabal safe to use? there's this open bug... https://github.com/haskell/cabal/issues/936
15:49:24 <enthropy> newsham: I wouldn't expect your paste to work unless lcodec used unsafeInterleaveIO
15:50:15 <monochrom> is your internet connection safe? that is the only determining factor
15:51:33 <lamefun> monochrom: it shouldn't be a factor. that's why banks, etc. use HTTPS
15:52:15 <monochrom> perhaps I didn't understand your question.
15:52:26 <srhb> I think the question is "does cabal-install use HTTPS"
15:52:37 <lamefun> monochrom: does cabal protect against hacked mirrors or MITM attacks?
15:52:50 <srhb> lamefun: Nope.
15:53:00 <lamefun> srhb: Haskell is a toy then.
15:53:00 <srhb> lamefun: Though mirrors isn't really a big thing.
15:53:03 <srhb> lamefun: OK :-)
15:53:06 <monochrom> srhb: no, cannot be, since the asker knows to link to that issue, which implies that cabal-install does not already use HTTPS
15:53:17 <srhb> monochrom: I was surprised as well.
15:53:37 <srhb> lamefun: But surely you mean that cabal-install is a toy.
15:53:52 <monochrom> or perhaps hackage
15:53:52 <lamefun> srhb: The only sane language I really really really want to use, the sanest in the world, is a toy... This universe is so unfair...
15:53:54 <Peaker> Haskell is in various aspects, behind the times. In many other aspects, it is a head of the times. Overall, it is still ahead of the times :)
15:54:24 <haskell176> Is this right? http://lpaste.net/130563
15:54:46 <lamefun> srhb: Yes, but without cabal-install I'm down to basic libraries.
15:54:46 <srhb> haskell176: Looks right to me.
15:55:01 <haskell176> woot.
15:55:06 <srhb> lamefun: Surely not, you can forego the automatic transfer process if you see fit.
15:55:17 <monochrom> I understood the question as sincere, i.e., "given that cabal downloads in plaintext and without sig, what do I get when I download?", therefore the answer is "then it depends on what's going on in your internet connection"
15:55:24 <srhb> lamefun: Grab whatever repo you trust in your favourite, safe manner, and just cabal install from the root of it.
15:55:27 <jle`> if you can find a way to secure the packages securely, then you can also locally install
15:55:33 <monochrom> clearly, I was wrong. it was a rhetorical question, not a sincere question
15:55:46 <jle`> github has https, for example, and many packages are hosted on github
15:55:51 <monochrom> it was a prologue to someone's pitch
15:55:51 <bennofs> lamefun: I believe you can fetch packages via https from hackage manually
15:56:11 <srhb> Right, but can you trust Hackage?!
15:56:13 <srhb> :-)
15:57:06 <monochrom> haskell176: there is one more case you need
15:57:17 <bennofs> lamefun: so just use a script to mirror all packages via https, and then use your local mirror. Or maybe there is already some script to automatically tunnel requests to hackage through https? I beleive someone mentioned such a tool in the last discussion
15:57:24 <srhb> Urgh, true. Forgot about Nothing. What was THERE looking correct :-)
15:57:48 <haskell176> pure Nothing = Nothing
15:57:49 <haskell176> ?
15:57:55 <monochrom> no, it's for <*>
15:58:03 <monochrom> pure needs not know about Nothing
15:58:27 <Peaker> "This is a HUGE BUG and should be fixed. I just trashed my server hardware and made an order for some fresh hardware" <-- damn
15:58:46 <haskell176> case of Nothing <*> _
15:58:48 <haskell176> ?
15:58:56 <monochrom> yes
15:59:12 <monochrom> sigh, no. how about I just give the answer.
15:59:13 <haskell176> also _ <*> Nothing ?
15:59:17 <monochrom> _ <*> _ = Nothing
15:59:36 <monochrom> the socratic method seldom works
15:59:53 <srhb> monochrom: Your tone and attitude isn't helping. :)
15:59:58 <srhb> Socratic method is fine.
16:00:08 <monochrom> ok, it works
16:01:03 <haskell176> so if the arguments are not in Maybe, then it will be Nothing?
16:01:17 <lamefun> Ruby Gems and NPM use transport security. I just can't consider Haskell a non-toy language with a bug like this in its main package delivery system... I mean, even Arch Linux developers fixed their package manager long ago.
16:01:17 <srhb> haskell176: "not in Maybe" doesn't make much sense.
16:01:38 <haskell176> values are not maybe types?
16:01:44 <monochrom> each argument is either "Just ___" or "Nothing"
16:01:48 <srhb> haskell176: The functions explicitly work on Maybe a, that's what the instance does
16:01:54 <nocturne777> which one of these  functions a seasoned haskell developer prefer? "rightPosExists pos =  pos + 1 <= bWidth" or "rightPosExists = (<= bWidth) . (+1)" 
16:02:02 <srhb> haskell176: And Maybe a has values Just a or Nothing
16:02:15 <srhb> haskell176: You're matching on value constructors. Just is such a constructor, as is Nothing.
16:02:20 <monochrom> and both possibilities happen
16:02:35 <hjulle> Is there a cleaner way to write (\x -> case x of {a -> ...; b -> ...})? (Without introducing x)
16:02:37 <srhb> haskell176: What you mean to say is "if the values aren't Just a..."
16:02:37 <nocturne777> I like the latter one as it involves less repetition
16:02:57 <nocturne777> just curious what you guys think about this
16:03:00 <srhb> hjulle: lambdacase?
16:03:17 <monochrom> hjulle: using the LambdaCase extention, it is \case ... I forgot the real syntax after that
16:03:22 <srhb> hjulle: https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions#lambdacase
16:03:31 <monochrom> but it gets rid of the x
16:03:37 <arkeet> \case { a -> ...; b -> ... }
16:03:37 <merijn> lamefun: Seriously, are you trolling about that again?
16:03:51 <haskell176> ohhh. okay but the _ <*> _ = Nothing has to go after the Just f <*> Just <a>
16:03:52 <hjulle> ok, thanks
16:03:59 <monochrom> yes
16:04:02 <johnw> monochrom: \case ... = \x -> case x of ...
16:04:09 <bennofs> lamefun: "One more idea, you could pretty easily set up an HTTP proxy or stunnel on your own machine and point cabal-install at it, such that it upgrades the connection to TLS."
16:04:11 <arkeet> there's also (let f a = ... ; f b = ... in f) but that also kinda sucks.
16:04:18 <Zemyla> nocturne777: I can't believe I saw your rightPosExists function and thought for a second, "What is the double left arrow <= thing?"
16:04:19 <haskell176> okay i see.
16:04:43 <bennofs> lamefun: copied from https://www.reddit.com/r/haskell/comments/2rm4sb/how_do_you_keep_your_dev_machines_secure/cnh4yms Not sure how it works exactly, since I don't use stunnel myself
16:04:57 <arkeet> nocturne777: I'd pick the first one, for clarity.
16:05:34 <MP2E> Paranoia can extend out however far you want it to, for instance, how do you know you can trust your CPU? It runs microcode under the hood, really AMD/Intel could be replacing your instructions with anything as long as the expected output is the same
16:05:41 <hjulle> Zemyla, Haha. Me too :)
16:05:56 <nocturne777> arkeet: I see, tnx for your input
16:06:01 <jle`> i4 is a toy cpu
16:06:06 <srhb> :-)
16:06:06 <MP2E> ^
16:07:12 <srhb> Anyway, the short story is: Yes, Hackage should have proper auditing but doesn't, cabal-install should pull from HTTPS, but doesn't, all these things are tragic and the way things are, and we get on just fine, whether or not anyone considers Haskell a toy.
16:07:37 <srhb> Or at least that's my perspective.
16:07:44 <Peaker> The ticket explains why HTTPS is a red herring
16:07:49 <Peaker> (a guy on the ticket)
16:08:18 <srhb> True enough. I just meant to put the discussion to rest before anyone else bites, while still accomodating the points (because I don't care much about them)
16:08:20 <srhb> :P
16:08:21 <Peaker> You want to have signatures on the downloaded content, which are necessary and sufficient, whereas HTTPS is neither necessary or sufficient
16:08:28 <srhb> I failed, obviously.
16:08:33 <johnw> "In 1807, William Cobbett wrote how he used red herrings to lay a false trail, while training hunting dogs."
16:09:20 <Peaker> srhb: I was out reading the ticket while you were arguing :)
16:09:23 <srhb> :-)
16:09:47 <lamefun> merijn: yes, assuming every statement of truth that admins find inconvenient counts as trolling.
16:09:56 <hjulle> I need to define some acme-halfmonad with operators like (>=)=halfBind, and (<=) = halfKleisli. 
16:10:07 <MP2E> 'Haskell is a toy' is an opinion, not an incovenient truth.
16:10:10 <srhb> lamefun: It's just that we're not here to soothe your feelings. :)
16:10:12 <MP2E> There is no fact to be found in it
16:10:37 <jle`> Peaker: i wanted to congratulate you on something earlier but you weren't online so i couldn't but i forgot what it was now. so if you did anything significant or public in the past week or so then congratulations :)
16:10:51 <bennofs> haha
16:11:15 <Peaker> jle`: heh, I'm actually not quite sure what that would be about, but thanks! :)
16:11:24 <lamefun> I mean, I've just been told on one forum that Haskell is used for automated done software and by NASA... Surely NASA cares about security...
16:11:28 <bennofs> jle`: sounds like it had a really big influence on you :)
16:11:31 <srhb> lamefun: Shhhh
16:11:37 <srhb> lamefun: We get it. You feel bad about it. Now move on.
16:12:03 <jle`> i remember typing P<tab> and not seeing Peaker and that cognitive dissonance has resonated with me in a lasting manner
16:12:03 <merijn> srhb: This is actually the 2nd or 3rd time he's trolling about this topic here
16:12:14 <srhb> merijn: I recall. :)
16:12:17 <merijn> srhb: Seems to have copy+pasted the exact identical message too
16:12:21 <srhb> Haha
16:12:25 <Zemyla> lamefun: C doesn't distribute packages through HTTPS. Surely it is a toy language and not one used in thousands of apps.
16:13:16 <lamefun> Zemyla: it doesn't have a recommended package system either.
16:13:18 <merijn> Zemyla: C doesn't even have a package manager
16:13:47 <Peaker> jle`: I've not been active on IRC recently much, had a lot of deadline pressure recently (nothing to congratulate about yet :-) )
16:14:15 <jle`> well...carry on then :) hope you made/are on track to make your deadlines
16:14:46 <ryantrinkle> lamefun: I use Nix to build all my Haskell packages; everything is SHA-256ed
16:15:28 <ryantrinkle> nixpkgs itself is served over HTTPS from github, and the binary cache is served over HTTPS from s3.  If you don't trust nixpkgs, you can inspect it, and if you don't trust their binary cache, you can disable it.
16:15:29 <roboguy_> lamefun: wouldn't that make it even more of a toy language then?
16:16:01 <Peaker> jle`: I think I am, thanks :-)
16:18:32 <lamefun> roboguy_: it doesn't. C is just a standard, there's no "official" compiler or package manager.
16:18:58 <johnw> the success of a troll is measured in responses
16:19:03 <roboguy_> lamefun: Haskell is a standard too. GHC is the most popular compiler, but it isn't "official". same with cabal
16:19:20 <Peaker> roboguy_: nobody uses Haskell though, everyone writes GHC Haskell
16:19:37 <roboguy_> Peaker: that is true, to be fair
16:19:41 <merijn> GHC isn't even the first haskell compiler
16:19:50 <merijn> Peaker: That's not true, some people write Mu :p
16:19:56 <merijn> Also, UHC :p
16:20:11 <bennofs> JHC / aJHC
16:20:44 <lamefun> roboguy_: for C, there's gcc, clang, Microsoft compiler. Is there another Haskell compiler that's comparable in maturity/popularity with GHC? If there was one C compiler with insecure recommended package system and another one which is secure, I'd consider the former a toy, but wouldn't consider the other one or C as whole a toy.
16:21:14 <Peaker> merijn: people write Mu in a separate universe which may never communicate with our own :)
16:21:23 <Peaker> merijn: they don't sound like they'll ever release anything
16:21:27 <glguy> lamefun: Your complaint is duely noted. If you have another question about Haskell you're welcome to ask it.
16:21:30 <bennofs> lamefun: maybe you should play a little with Haskell if you consider it a toy? :)
16:21:31 <merijn> Peaker: It's mostly the lawyers
16:21:49 <merijn> Peaker: Lennart's been trying to get it open sourced, but the lawyers are afraid of getting sued
16:22:02 <xplat> so speaking of toy languages, what is your favorite toy language and what cool feature does it have that haskell doesn't?
16:22:12 <Peaker> lamefun: but HTTPS isn't necessary or sufficient to solve the problem -- what you want to complain about are signed packages. And most languages' package managers don't do these
16:24:40 <roboguy_> xplat: I like to mess around with Forth sometimes but mostly, ironically, to do implement lambda calculus style stuff
16:25:29 <lamefun> Peaker: how isn't it sufficient?
16:25:41 <xplat> heh, i implemented a library for writing concatenative programs in haskell once
16:25:44 <lamefun> Is it about bad CAs?
16:25:57 <xplat> it wasn't great, but it was fun to make
16:26:26 <theorb> There was a push some time ago to do signed packages in the perl / cpan ecosystem.  My recollection is that it didn't work very well, and nobody could be bothered fixing it.
16:26:41 <johnw> chrisdone has accomplished some work toward package signing recently
16:26:45 <StoneCypher> what's that?  there's a thing in cpan and nobody can be bothered to fix it?
16:27:04 * StoneCypher acts shocked
16:27:09 <roboguy_> xplat: I have a theory that a small set of stack combinators along with delayed computation is equivalent to lambda calculus, but I haven't proven it yet
16:27:21 <theorb> A security sytem has to introduce very little overhead in terms of false positives, or there has to be a very clear danger of true positives, or people will just bypass it.
16:27:28 <xplat> it's hard to make a package distribution system that actually offers security and not just a security blanket
16:27:29 <roboguy_> I'm also not completely sure what *all* of those combinators would be
16:27:53 <theorb> The big problem is to define what you are securing / asserting.
16:27:55 <johnw> security should be a third topic that is not appropriate at the dinner table
16:27:55 <Peaker> lamefun: The hackage server can be compromised
16:28:13 <xplat> roboguy_: it's easier if you have two stacks
16:28:42 <roboguy_> xplat: you mean two data stacks?
16:28:54 <theorb> Is it "this package passed through hackage" "this package was uploaded by the person listed here" "this package isn't going to mess up your computer"?
16:28:57 <xplat> yeah.  but if you have cons you basically do have two stacks
16:29:09 <theorb> The first two aren't useful, and the third one is impossible.
16:29:29 <xplat> enh, the second one is a little useful
16:29:36 <roboguy_> xplat: well, what do you mean? I think you can implement (essentially) a church encoding of lists using stack combinators
16:29:43 <xplat> first one is completely useless
16:29:50 <kadoban> Peaker: Even so, it'd still be a huge step-up in security using HTTPS. It reduces the attack from "anyone who can mess with my connection" to "people who can take over hackage"
16:30:11 <xplat> roboguy_: well, with two stacks you don't need to be able to permute things arbitrarily deep in the stack
16:30:23 <roboguy_> xplat: ah, I see. That makes sense
16:31:56 <roboguy_> I don't know if it's be too obvious to be very interesting, but sometime I might write about the stack based church encoding thing, because I haven't seen anyone talk about it so far
16:32:26 <xplat> kadoban: hm, i guess just https can actually buy you at least something if you have a sufficiently weak attacker model
16:32:36 <Peaker> kadoban: if you sign packages, you get better security for a smaller cost
16:32:36 <monochrom> I will like to know, roboguy_
16:32:52 <Peaker> and you don't have to depend on a CA
16:32:58 <xplat> kadoban: i think one of the lessons of recent events though is that a lot of people use a way-too-weak attacker model though
16:32:59 <roboguy_> monochrom: cool, maybe I will. Can't hurt either way after all!
16:33:05 <johnw> I want to sign my packages with a fountain pen
16:33:17 <kadoban> Peaker: Who would be signing the packages? Hackage? Then isn't it slightly weaker security your way than HTTPS, at about the same cost?
16:33:30 <monochrom> I use a fountain pen
16:33:31 <RageD> so I am using forever in StateT (with base monad IO for printing) and ghc keeps optimizing it away as <<loop>>... any ideas here?
16:33:44 <johnw> RageD: that's very often a 'let' cycle
16:33:45 <monochrom> maybe I can lend my fountain pen to you for signing
16:33:54 <johnw> monochrom: oh, I have a nice one
16:33:55 <monochrom> that will be 0.1 bitcoins :)
16:33:59 <monochrom> darn
16:34:13 <bennofs> kadoban: i believe the uploaders themselves should be signing the packages. so you can then choose which uploaders to trust or not to trust
16:34:34 <monochrom> anyway, I trust Chris Done for being the CA for this.
16:34:51 <Peaker> kadoban: There's more flexibility there. You could require a package maintainer signature as well as a hackage signature. The signatures can themselves be signed by a separate key, and all of this can be bootstrapped with GHC or the platform, without involving CAs
16:34:54 <kadoban> bennofs: Then we have to go all the way to a whole web-of-trust thing, and hackace would /still/ have to use TLS or it's pretty close to useless for a casual user.
16:34:55 <monochrom> especially since Snoyman and one other have signed up (pun!)
16:35:00 <johnw> Chris Done: Now the alien's first choice for a global take over.
16:35:00 <xplat> bennofs: i feel like without a further mechanism that's just paradox-of-choicing people to death
16:35:32 <monochrom> Neil Mitchell is the other
16:35:49 <kadoban> Peaker: Sounds pretty complicated to set up, but does sound good. But doesn't rule out HTTPS while all of that is being figured out.
16:36:10 <xplat> johnw: need we install webcams under their beds to watch for pods?
16:37:17 <xplat> bennofs: anyway if you want to DIY a web of trust you can use git's signed tag stuff and not even involve hackage
16:38:29 <xplat> you can even audit specific versions of packages and sign them in your own clone
16:38:52 <RageD> johnw: Thanks :) yes i had a "let in" :x
16:44:36 <JagaJaga> I have function that returns (FooBar String). How to make it FooBar Text? Because I'm getting `Couldn't match type ‘[Char]’ with ‘Text’`
16:44:44 <JagaJaga> Or I can't Do it?
16:45:08 <jle`> JagaJaga: is FooBar a Functor?
16:45:13 <jle`> if so, you can use fmap
16:45:25 <jle`> fmap :: (String -> Text) -> FooBar String -> FooBar Text
16:45:54 <JagaJaga> jle`: nice, gonna try
16:46:27 <kadoban> :t fmap Data.Text.pack
16:46:28 <lambdabot> Functor f => f String -> f Data.Text.Internal.Text
16:47:48 <JagaJaga> jle`: Worked. Thank you.
16:48:02 <monochrom> depends on what is FooBar.
16:49:02 <JagaJaga> monochrom: Functor
16:50:47 * hackagebot forecast-io 0.2.0.0 - A Haskell library for working with forecast.io data.  http://hackage.haskell.org/package/forecast-io-0.2.0.0 (stormont)
16:50:59 <jle`> woo hoo!
17:01:28 <byorgey> shlevy: I guess you saw my comment on the monoid-extras repo, but the answer to the question (re: 7.10-compatible diagrams release) is, any day now
17:02:23 <byorgey> I'm working on it right now
17:10:48 * hackagebot HaskellNet 0.4.4 - Client support for POP3, SMTP, and IMAP  http://hackage.haskell.org/package/HaskellNet-0.4.4 (lemol)
17:20:23 <_ryan> hi i would like to use a rawSql but with additional field - can anyone give me a hint?
17:20:58 <carter> ReinH  i definitely  know how bounds work, i just sometimes dont feel like writing about them :)
17:25:48 * hackagebot hsilop 0.1.1.0 - RPN calculator  http://hackage.haskell.org/package/hsilop-0.1.1.0 (rnhmjoj)
17:33:30 <shlevy> byorgey: cool :)
17:34:58 <jle`> i'm about to use unsafePerformIO to provide a nice interactive GHCi interface for a sort of repl calculator thing.
17:35:54 <jle`> just logging this here as my last words if things turn out badly
17:36:02 <monochrom> oh, heh
17:36:36 <monochrom> should be safer than going to Mars
17:37:15 <jle`> those are also famous last words.
17:37:25 <monochrom> haha
17:50:49 * hackagebot timerep 1.0.4 - Parse and display time according to some RFCs (RFC3339, RFC2822)  http://hackage.haskell.org/package/timerep-1.0.4 (HugoGomes)
17:55:09 <JagaJaga> How to use some operator like (^.) when I have StateT MyType IO () as my type of function where I use lenses? I need smth like state ^. foo.bar
17:55:50 * hackagebot cabal-helper 0.3.2.0 - Simple interface to Cabal's configuration state used by ghc-mod  http://hackage.haskell.org/package/cabal-helper-0.3.2.0 (DanielG)
17:59:04 <JagaJaga> Found: `use` function
17:59:06 <JagaJaga> :t use
17:59:07 <lambdabot> MonadState s m => Getting a s a -> m a
18:03:32 <begriffs> Is there a new little function to change the second part of a pair while leaving the first part alone? Hoogle didn't turn anything up. "b->c->(a,b)->(a,c)"
18:03:58 <begriffs> *nice little
18:04:10 <kadoban> :t second
18:04:11 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
18:05:07 <kadoban> begriffs: Heh ^ that. functions are an instance of Arrow (replace all 'a' with (->))
18:05:57 <kadoban> > second (+5) ("a", 2)
18:05:58 <lambdabot>  ("a",7)
18:06:00 <begriffs> Oh fancy! So this package? https://hackage.haskell.org/package/arrows
18:06:27 <begriffs> Oh nevermind it's right in base.
18:06:38 <kadoban> I think it's in base, yeah.
18:06:45 <ClaudiusMaximus> > fmap (+5) ("a", 2)
18:06:46 <lambdabot>  ("a",7)
18:07:37 <kadoban> Yeah, that too, but I think the arrow stuff is clearer. If nothing else, it means you can do 'first' too, so there's some symmetry.
18:09:59 <JagaJaga> How to make debug printing properly? Write everywhere `if debug ...` and pass `debug` to every function? That's wierd
18:10:28 <kadoban> JagaJaga: Not sure what you mean?
18:10:58 <JagaJaga> Well, in c++ I can use debug global flag..
18:11:11 <JagaJaga> Maybe some functions that depend on compilation flags?
18:11:57 <ClaudiusMaximus> JagaJaga: if it's really debug, and not logging, then you won't need it in production and you can use CPP to make something like debugPrint :: String -> IO () have different definitions
18:12:40 <JagaJaga> ClaudiusMaximus: what is CPP?
18:12:52 <ClaudiusMaximus> JagaJaga: C pre-processor
18:12:59 <kadoban> You can have compilation flags, you can have a top-level definition, or you can use Reader I guess, although that last sounds like probably not what you're looking for.
18:13:34 <JagaJaga> ClaudiusMaximus: well, how to use it with haskell? :)
18:13:46 <JagaJaga> kadoban: well. seems that I got the idea
18:14:47 <ClaudiusMaximus> JagaJaga: alternatively you could use cabal flags to include a different module
18:14:55 <jle`> JagaJaga: if it's just for rough debugging, you can just have `debug` declared somewhere at the top level
18:14:58 <jle`> as in, in development
18:15:24 <jle`> you can also abstract away the if/then too
18:16:16 <JagaJaga> jle`: what's what I've just done. Created Debug.hs with debug = true|false and function printDebug. Will include it where it's necessary.
18:17:08 <jle`> it's a rough solution for debugging applications during development heh
18:18:25 <JagaJaga> jle`: that's what I need :D
18:22:41 <ttt_fff> is there any freetype haskell tutorial?
18:22:53 <ttt_fff> i'm looking for something that shows me how to go TTF Font -> String -> PNG File
18:23:44 <_ryan> hi i would like to use a rawSql but with additional field - can anyone give me a hint?
18:33:16 <derekv> Haskell, F#, Scala OCaml etc all have "strong" type systems right? (maybe Rust too, idk what else)... is there a better term than "strong type system" I can use for these things?
18:33:45 <derekv> (well, yea Idris, Coq, Purescript... not listing everything)
18:35:33 <bjz> derekv: statically typed?
18:35:54 <derekv> I guess I'd rather differentiate it from a language like Java, which has static typing.  C has static typing
18:36:36 <bjz> "strong" kind of refers to not having implicit conversions, but it's a fuzzily defined term
18:36:52 <derekv> yea, I know, "strong type system" is a weak term.
18:36:56 <derekv> =[
18:36:57 <sellers> lol
18:37:19 <bjz> https://en.wikipedia.org/wiki/Strong_and_weak_typing
18:41:22 <Cale> I tend to think of the strength of a type system as being a relative term. One type system is stronger than another if it can express and check more properties of the code.
18:43:40 <derekv> maybe is there a line a that can be drawn that would separate languages by type systems that are less expressive like Java or Javascript to ones that are more expressive / powerful and what would that line be called
18:43:54 <derekv> Cale: I like that definition.
18:44:20 <derekv> it's probably more of a continuum isn't it?
18:45:23 <Cale> We sort of informally project it down to a continuum :)
18:45:45 <Cale> But there are really a lot of dimensions along which one type system can do better than another
18:46:04 <derekv> Yea I'm sure its more of some sort of graph
18:46:45 <lpaste> nocturne777 revised “No title”: “Won't compile” at http://lpaste.net/82286904761909248
18:47:41 <nocturne777> guys, I am unable to compile this code. it complains about line 12, saying  Couldn't match type Bool with Piece    Expected type: [Piece] -> Width -> b    Actual type: [Bool] -> Width -> b
18:47:55 <Welkin> nocturne777: we are not all "guys"
18:48:34 <jmcarthur> derekv: "advanced"?
18:48:45 <nocturne777> Welkin: people also say guys to mean everyone. this is part of  the daily language
18:51:21 <derekv> I find myself saying "dude" to girls all the time.  Even "man", like "let me tell you man, ..." 
18:52:04 <derekv> I usually handle that by bailing out the nearest window.
18:52:16 <derekv> Worked for me so far.
18:52:28 <derekv> But it's why I avoid social interactions above the first floor.
18:53:08 <lfairy> nocturne777: is that some tic tac toe thing
18:53:47 <nocturne777> lfairy: kindof, it's an SOS game actually :)
18:54:25 <pavonia> :t all
18:54:26 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
18:54:55 <pavonia> nocturne777: Are you sure ($ pos) matches the type of the argument of "all"?
18:55:44 <nocturne777> pavonia: pos is of type Int
18:56:16 <enthropy> nocturne777: I think foundSeq is the problem
18:56:52 <lfairy> oh wow, lambdabot uses 7.10 already
18:56:53 <enthropy> foundSeq piece1 piece2 piece3 = piece1 == piece2 && == piece1 == piece3 -- possibly better
18:57:19 <lfairy> it feels like there's a cleaner way to do this
18:58:04 <nocturne777> enthropy: you are right
18:58:08 <nocturne777> enthropy: it works now
18:59:28 <nocturne777> enthropy: why my version did not work, tho?
19:00:03 <enthropy> @type \piece1 piece2 piece3 -> (piece1 == piece2) == piece3
19:00:04 <lambdabot> Eq a => a -> a -> Bool -> Bool
19:01:42 <enthropy> that type doesn't fit your use of it which needs a "foundSeq :: Piece -> Piece -> Piece -> Bool"
19:03:05 <derekv> er OK, so my big question: is there something about functional programming languages that links them or makes them more suitable for advanced type systems, or are the two issues really orthogonal 
19:03:54 <bjz> derekv: I would say orthogonal
19:04:11 <geekosaur> derekv, you can have either without the other, but the combination has some synergies
19:04:39 <bjz> derekv: Rust for example is not functional
19:05:09 <bjz> derekv: but I would agree with geekosaur
19:05:13 <derekv> bjz, geekosaur: cool, that's what I suspected
19:05:54 <geekosaur> and going the other way, scheme is functional with effectively no type system :)
19:06:06 <derekv> I mean, I'm giving a talk introducing FP and am itching to include a bit on type systems... wanted to have my facts strait 
19:06:31 <bjz> FP itself is kind of loosely defined
19:06:44 <derekv> bjz yes, that too...
19:06:59 <derekv> that's going to be a nice little chunck of my talk
19:08:21 <derekv> i like the definition on the haskell wiki "Functional programming is a style of programming which models computations as the evaluation of expressions."
19:09:07 <derekv> I like it as a way to introduce FP because it is somewhat encompassing. 
19:09:29 <RageD> has anyone been (ever?) used Haskell in the "big data" space? I work in big data right now, but our stack is pretty much exclusively java/scala/pig/etc... Just curious if anyone has done any yet for this?
19:09:49 <bjz> derekv: http://en.wikipedia.org/wiki/File:Programming_paradigms.svg
19:10:19 <bjz> (by Peter Van Roy)
19:10:58 <derekv> bjz those are a lot of boxes
19:11:06 <bjz> https://www.info.ucl.ac.be/~pvr/paradigms
19:12:06 <bjz> well, the 'paradigms' that we normally talk about are often too course to be super useful
19:12:28 <bjz> that is van roy's argument anyway
19:13:54 <srhb> RageD: Facebook?
19:14:06 <srhb> RageD: Depends what big data means I guess
19:14:44 <srhb> RageD: Or perhaps any of the financial sector companies that build on Haskell.
19:14:45 <carter> RageD: srhb  theres systems written in haskell that ingest terabytes a day
19:14:56 <carter> just in the normal web sphere
19:15:06 <RageD> meh yeah i've seen haxl, but not exactly what i'm looking for.. I guess I'm thinking more distributed data processing, warehousing, etc.
19:15:08 <srhb> RageD: https://wiki.haskell.org/Haskell_in_industry -- perhaps
19:15:35 <srhb> RageD: I can't read minds :-)
19:15:42 <RageD> :)
19:16:00 <carter> i may or may not help a friend build a system this summer (in mostly haskell) that would probably have gigabytes/second of nontrivial compute/data transfer over the network
19:16:52 <RageD> srhb: Thanks for the pointers, I'll take a look. I'm interested in seeing if anyone has done this before because I would like to start integrating Haskell more into my work.. That being said, our company is incredibly risk averse >_> and most people don't like FP there, so I find it unlikely that I will succeed. but worth a shot :D
19:17:05 <srhb> RageD: Sure :)
19:23:48 <derekv> bjz: yes I guess I really don't like paradigms as far as how I feel like I see them being used ... i feel like I see people identifing with being object oriented programmers but you'd get a different answer anyways on what that means with each person.  Which is fair enough, b/c its a nebulous term anyways.. which is what you where saying
19:27:20 <carter> bjz: i kinda think that once rust has better higher kinded types/traits, a sort of "linear imperative functional" style will be doable
19:27:27 <carter> or i could just be a dreamer
19:33:17 <Zemyla> I have to download Haskell for my computer that I got working again.
19:33:36 <Zemyla> Of course, the fact that I got my computer working again is awesome.
19:34:35 <shachaf> Haskell can be downloaded at https://www.haskell.org/definition/haskell2010.pdf
19:42:55 <Zemyla> If Idownload the Haskell Platform, which is 7.8.3, can I upgrade it to 7.10?
19:44:15 <shachaf> I don't know what it means to upgrade the Haskell Platform.
19:44:17 <geekosaur> Zemyla, it won't work with 7.10 as is, you need newer versions of ~everything
19:44:28 <geekosaur> there is not yet a Platform compatible with 7.10
19:44:31 <shachaf> It's just a bunch of libraries. Each version of GHC needs its own libraries, they can't share.
19:44:52 <shachaf> But you can install the libraries yourself, so there isn't much point in the Platform.
19:44:54 <geekosaur> (they're working on it, hoping to have a release by end of the month)
19:45:27 <shachaf> (Unless you're using Windows. For some reason it seems that there's no convenient way to get GHC for Windows without the Platform.)
19:45:42 <Zemyla> Yeah, I am using Windows.
19:45:45 <geekosaur> I thought Snoyman was working on that (minghc)?
19:45:55 <bjz> carter: agreed
19:46:00 <geekosaur> just put out a 7.10-comatible version
19:46:27 <geekosaur> https://www.fpcomplete.com/blog/2015/03/minghc-ghc-7-10
19:57:23 <ronh> shachaf mingw?
20:04:38 <solinent> hey, anyone have any idea why I might be getting a leak when I use Control.Monad.Parallel.mapM vs regular mapM? 
20:39:16 <haskell220> any good introduction to haskell pipes and lenses?
20:41:46 <arkeet> haskell220: for pipes, the documentation in Pipes.Tutorial is quite nice.
20:42:02 <arkeet> for lens, not exactly sure, heh.
20:42:07 <arkeet> there's some stuff here https://github.com/ekmett/lens/wiki
20:42:28 <arkeet> this course has some lecture notes on lenses http://www.scs.stanford.edu/14sp-cs240h/
20:42:38 <arkeet> and you are welcome to hang out in #haskell-lens if you have any questions :)
20:43:12 <slack1256> haskell220: Also play a lot with the libraries
20:43:35 <slack1256> for lens I played like a day with Getter, then Setter, Lens, Folds, Traversable
20:44:04 <slack1256> don't let the size of the library overwhelm you
20:46:14 <arkeet> yeah, there's a lot of stuff in lens
20:46:21 <arkeet> and sometimes it can be a bit hard to find the thing you want
20:48:32 <jmcarthur> have there been any recent developments in the streaming IO world? pipes and conduits seems to have quieted down.
20:48:51 <jmcarthur> i mean that as a good thing, for pipes and conduits
20:49:30 <jmcarthur> that they aren't changing so rapidly now indicates they have probably settled into a decent place
20:55:58 <R0b0t1> is it possible to define types at runtime?
20:56:07 <monochrom> no
20:57:00 <jmcarthur> well, sort of... polymorphism can allow some interesting things to occur at runtime
20:57:31 <ronh> > data NewType = XX | YY
20:57:32 <lambdabot>  <hint>:1:1: parse error on input ‘data’
20:57:46 <jmcarthur> for example, if you only know the depth of your non-regular data type at runtime then there is a sense in which you have created a new type at runtime
20:59:02 <jmcarthur> but there's nothing allowing you to explicitly say "data blah blah blah" in some dynamic way
21:01:50 <arkeet> R0b0t1: types don't exist at runtime.
21:01:58 <conal> Howdy, All. I just saw the Reddit discussion of my recent Haskell-to-hardware talk and left some comments. https://www.reddit.com/r/haskell/comments/31yy5z/from_haskell_to_hardware_via_cccs/ 
21:28:52 <carter> conal: jah
21:30:41 <carter> jmcarthur: theres been some slow baking stuff
21:30:49 <carter> but nothing world shaking
21:33:18 <conal> carter: hey
21:33:31 <carter> conal: hows transitioning to new things going?
21:34:33 <conal> carter: still very up in the air. i'm not rushing into a new thing yet. i really loved my old project, and i want to find something as engaging.
21:34:41 <carter> conal:
21:34:47 <carter> i'll keep my ear to the ground 
21:35:19 <conal> carter: thx. :) i'm up for temp gigs.
21:35:33 <carter> hrmmm
21:35:58 <haskell032> Thanks <arkeet>
21:41:00 * hackagebot second-transfer 0.2.0.0 - Second Transfer HTTP/2 web server  http://hackage.haskell.org/package/second-transfer-0.2.0.0 (dsign)
21:41:29 <noob> how does this work?
21:42:37 <R0b0t1> arkeet: I see, thank you
22:07:07 <joneshf-laptop> is there some standard package for dealing with metric spaces?
22:07:25 <joneshf-laptop> i see `metric`
22:07:33 <joneshf-laptop> just wondering if there might be another i've missed
22:08:30 <solatis> what would be the best way to model a 256 bit type (a hash) in haskell ?
22:08:50 <solatis> i need to be able to make a Binary instance out of it so it can be converted to bytestring
22:09:26 <glguy> You don't need to / shouldn't make new Binary instances just to use the binary package for generating bytestrings
22:09:47 <solatis> what do you mean ?
22:10:19 <glguy> If you're using Binary for one-off serializing/deserializing in general, that's fine, just that you don't need to make new instances to be able to use that package to do stuff
22:10:25 <solatis> hmmm
22:10:40 <solatis> but, my problem is that i am implementing a data structure that is used in a vast amount of other languages
22:10:41 <joneshf-laptop> primarily because `metric` wont install on 7.10
22:10:47 <joneshf-laptop> due to deps
22:10:54 <solatis> so i cannot just say "serialize bytestring"
22:11:01 <solatis> i need to read exactly 4 bytes
22:11:14 <solatis> ehr, 32
22:13:05 <glguy> If you just want to make a 32-byte bytestring out of 4 Word64s, for example: you can just use Data.Binary.Put: runPut (putWord64be a >> putWord64be b >> putWord64be c >> putWord64be d)
22:14:05 <solatis> glguy, yeah i know, so i should just model it as a struct with 4 Word64s ?
22:14:30 <solatis> instead of trying to be fancy and model it as an Integer
22:14:40 <glguy> Just depends on what you're doing with it. You could represent it as a ByteString, 4 Word64s, Integer
22:15:00 <solatis> i think i'll stick with 4 Word64s right now and improve upon it later
22:15:13 <glguy> In general the way you represent something is dictated by the operations you need to be able to support on that data
22:16:07 <solatis> i don't need to do any operations on it, actually, it's just an identifier
22:43:03 <Zemyla> Hmm, can Windows Haskell use LLVM?
22:50:46 <nocturne777> I have some piece of code like so:  foldr (\rowNum map -> Map.insert rowNum (replicate numOfCols E) map) Map.empty rowNums 
22:50:53 <nocturne777> where rowNums is an list
22:51:15 <nocturne777> is it better to use foldl' here to fill up the Map
22:52:00 <nocturne777> foldr is going to create thunks needlessly
22:52:33 <nocturne777> I am going to iterate over all elems and put them into the map.
22:52:57 <nocturne777> but what if the Map is lazy ?
22:55:28 <enthropy> you could look at how Map.fromList is implemented
22:57:18 <enthropy> which seems to be a foldl' even for the lazy Map
22:59:10 <nocturne777> enthropy: wiki says: "if the binary operation is strict use foldl', otherwise use foldr"
22:59:29 <nocturne777> so, am I not suppose to actually check the implementation of the insert ?
23:02:21 <enthropy> > M.insert 1 () undefined `seq` ()
23:02:22 <lambdabot>  *Exception: Prelude.undefined
23:20:16 <browndawg> Hey, I'm a little confused by this paragraph on the haskell.org home page.
23:20:24 <browndawg> "Every function in Haskell is a function in the mathematical sense (i.e., "pure"). Even side-effecting IO operations are but a description of what to do, produced by pure code. There are no statements or instructions, only expressions which cannot mutate variables (local or global) nor access state like time or random numbers."
23:20:50 <browndawg> "Even side effecing IO ops are but a description of what to do..." <-- isn't that procedural? describing what to do?
23:22:23 <EvanR> browndawg: but IO ops arent functions
23:22:28 <kadoban> browndawg: imperative at least, sure. IO actions aren't functions though.
23:23:02 <browndawg> what does the "produced by pure code" mean, then?
23:23:14 <EvanR> :t putChar
23:23:15 <lambdabot> Char -> IO ()
23:23:21 <browndawg> if I say `main = do blah <- getline`
23:23:27 <MP2E> browndawg: there's a phase distinction in Haskell between evaluation and execution, Haskell programs evaluate to return a large value of IO () which is passed over to the runtime for execution
23:23:29 <EvanR> thats a function to produce an IO action from a Char
23:23:36 <EvanR> its an "IO op" factory
23:24:07 <browndawg> Ah! So putChar is something pure that returns an IO ()?
23:24:11 <MP2E> exactly!
23:24:12 <EvanR> yeah
23:24:23 <browndawg> then what exactly "puts" the char on stdout
23:24:28 <browndawg> where does that happen
23:24:31 <EvanR> the runtime system
23:24:43 <MP2E> the haskell runtime executing the IO action, after evaluation
23:24:44 <browndawg> okay!
23:24:50 <browndawg> so all the expressions are pure
23:25:08 <EvanR> your main action is executed by the runtime system. though main = do blah <- getLine would be incomplete as is
23:25:16 <browndawg> and the impure I/O is being done by the runtime based on the IO (whatever) that the program evaluated to?
23:25:20 <HeladoDeBrownie> evaluation of expressions can also happen during execution of IO
23:25:29 <EvanR> yes
23:25:30 <HeladoDeBrownie> but not vice versa
23:25:39 <HeladoDeBrownie> i was just clarifying what MP2E said
23:25:51 <browndawg> I think I get it now.
23:25:58 <browndawg> any other comments?
23:26:03 * hackagebot tls 1.2.17 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.2.17 (VincentHanquez)
23:27:57 <browndawg> I guess not. Thanks a lot HeladoDeBrownie, EvanR, MP2E, kadoban!
23:28:09 <HeladoDeBrownie> sounds like you have the gist of it now, yeah
23:34:13 <nshepperd> One thing: this is the abstraction that the haskell language provides. But the implementation is a bit more complex, and you might need to break the abstraction if you work with low level stuff like FFI. Eg. using unsafePerformIO to let you call C code as if it was a pure function
23:34:54 <shachaf> The FFI will use unsafePerformIO for you. :-)
23:34:59 <nshepperd> but on the whole the purity abstraction is good and proper
23:35:33 <browndawg> "as if it was a pure function" <-- what if it isn't :D
23:35:52 <MP2E> then you broke the abstraction and bad things may happen! hehe
23:37:21 <MP2E> http://hackage.haskell.org/package/base-4.8.0.0/docs/System-IO-Unsafe.html
23:37:31 <MP2E> the docs explain it pretty well
23:37:44 <HeladoDeBrownie> sometimes the programmer knows better than the compiler, but if they take advantage of that and tell the compiler lies, bad things may happen.
23:39:45 <ttt_fff> in haskell, what is easiest way of TTF -> String -> PNG ?
23:39:50 <ttt_fff> I watnt to render a string, using a font, to a png
23:42:48 <HeladoDeBrownie> i have only vague guesses, but it's possible you can do some of the work with this package
23:42:51 <HeladoDeBrownie> @hackage SDL-ttf
23:42:51 <lambdabot> http://hackage.haskell.org/package/SDL-ttf
23:43:52 <HeladoDeBrownie> this takes to from a font and some text onto an sdl surface, but from there to png i don't know
23:43:57 <HeladoDeBrownie> s/takes to/takes you/
23:44:40 <HeladoDeBrownie> also this may be overkill :<
23:45:36 <pavonia> ttt_fff: You could use pango
23:46:02 <ttt_fff> HeladoDeBrownie: pavonia: thanks
23:47:02 <HeladoDeBrownie> pango looks much more suitable
23:52:11 <ttt_fff> HeladoDeBrownie: noted, thanks
