00:00:19 <doctorinserenity> what's a good way to "waste time" doing something computationally intensive?
00:00:55 <oakwhiz> doctorinserenity: infinite loop?
00:00:58 <peddie> doctorinserenity: sum [0..]
00:01:48 <doctorinserenity> oh wait, it also needs to actually do simple addition
00:02:46 <doctorinserenity> so what I need is (+) with extra time wasting (experimenting with parallelism)
00:02:49 <oakwhiz> > iterate (+1) 0
00:02:50 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
00:05:00 <oakwhiz> doctorinserenity: you might be able to construct a recursive function using forkIO
00:05:22 <oakwhiz> of course it will probably freeze up your computer
00:06:34 <quchen2> Slowsort wastes a lot of time.
00:07:00 <quchen2> And it's exponential in the length of the list, so you can tune it to your needs easily.
00:08:51 <doctorinserenity> using iterate seems to just create lots of garbage
00:10:12 <mauke> http://www.researchgate.net/profile/Andrei_Broder/publication/2805500_Pessimal_Algorithms_and_Simplexity_Analysis/links/00b7d5187d62f61ee4000000.pdf
00:11:16 <netroby> Written two bots to ate another and growth itself length . 
00:11:23 <doctorinserenity> haha
00:11:29 <doctorinserenity> mauke: thanks for that
00:19:51 <Cale> oakwhiz: If you can get your computer to freeze altogether using forkIO, I'll be quite surprised. You can allocate enough memory to get your program memkilled pretty quickly though.
00:20:20 <Cale> (the threads each take up a little bit of space, but are fairly lightweight overall)
00:23:07 <oakwhiz> :t forever
00:23:08 <lambdabot> Monad m => m a -> m b
00:26:33 <caconym> ugh i can't believe i just missed an opportunity to spend april 1 at work evangelizing "reluctant algorithms"
00:26:48 <quchen2> Why does main have type `IO ()`, and not `IO a`?
00:27:06 <Cale> quchen2: main has type IO A for any particular type A that you like
00:27:08 <quchen2> Wait, nevermind. :-x
00:28:44 <CapitalSigma> i want to write a list that runs from 1 to x, then ends in n. is there a nicer way to write it than "[1..x] ++ n"?
00:29:11 <quchen2> Cale: But the report demands that main is converted to IO () at some point if I recall correctly. Is there a reason for that?
00:29:24 <Cale> CapitalSigma: You mean [1..x] ++ [n]
00:29:32 <Cale> quchen2: Er, what?
00:30:23 <quchen2> I'm pretty sure it says "main :: IO whatever but during compilation it'll become IO ()", but let me verify that claim
00:30:31 <CapitalSigma> Cale: yes, my mistake
00:31:41 <Cale> oakwhiz: On my machine, my program gets up to around 335 million threads before getting memkilled.
00:32:51 <quchen2> Cale: What I was referring to is "The value of the program is the value of the identifier main in module Main, which must be a computation of type IO τ for some type τ (see Chapter 7). When the program is executed, the computation main is performed, and its result (of type τ) is discarded."
00:32:52 <oakwhiz> Cale: that's rather large
00:33:18 <quchen2> I guess using () as "discarded" is a matter of convenience then
00:34:51 <Cale> oakwhiz: Oh, whoops, just realised there was a mistake in counting, it's probably way smaller
00:34:57 <Cale> oakwhiz: let me retest
00:43:38 <Cale> Yeah, I run into issues way sooner like this, only around 3.3 million threads.
00:43:42 <petercommand> https://ghc.haskell.org/trac/haskell-prime/wiki/NewtypeDeriving # seems that the reference link in this page is broken
00:43:59 <petercommand> ( http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#newtype-deriving )
00:44:16 <Cale> If I do the counting in a bad way, then only 19k threads get to count before everything is dead.
00:45:37 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/deriving.html#newtype-deriving
00:46:05 <Cale> It moved in some more recent version of GHC
00:48:16 <petercommand> Cale: yeah, so the link should be fixed :p
00:49:45 <Cale> I guess -- or pointed at the documentation for the appropriate version of GHC which was being discussed at the time
00:49:59 <Cale> That haskell-prime stuff is only of historical interest at this point.
00:50:18 * hackagebot handsy 0.0.14 - A DSL to describe common shell operations and interpeters for running them locally and remotely.  http://hackage.haskell.org/package/handsy-0.0.14 (utdemir)
00:50:41 <Cale> Or maybe I'm wrong? Is there a new haskell-prime committee?
01:07:20 <quchen2> Cale: I don't think so, since there is no Haskell'.
01:07:37 <Cale> quchen2: hm?
01:08:00 <quchen2> Cale: The plan seems to be stabilizing GHC-Haskell again, and then figuring out the process for how to make a new revision from scratch.
01:09:49 <Cale> Yeah, I think the best thing is to treat the name "Haskell Report" as literal, and simply attempt to report on what exists.
01:12:16 <quchen2> I don't know why it's not called the Haskell Standard either.
01:12:45 <Cale> Well, I'd prefer it
01:13:10 <Cale> It's just that everyone reads it as "Haskell Standard" :)
01:13:34 <Cale> I'd rather they just read it as a report on what Haskell presently is.
01:14:10 <quchen2> That document exists in the form of the GHC manual, which is the standard Haskell. ;-)
01:26:00 <Cale> quchen2: There's also like, the papers on System FC and such
01:28:28 <Cale> quchen2: It would be nice to try to provide some kind of formal view of Haskell which was relevant to modern Haskell and which also contained things which the Report doesn't really cover, like a denotational semantics for some core language.
01:33:23 <quchen2> Cale: Agreed. But everyone I've talked to who would be interested in having this and is competent enough to make it happen doesn't want to, because writing long specifications is not nearly as interesting as other things.
01:34:29 <jellie> ski: Hey, how are you?
01:35:40 <shachaf> I don't think it's very important at the moment.
01:36:50 <jellie> ski: I want to parse JSON files with such structure. However as you see there is an array under RelatedTopics. Would it make sense to make a type of this JSON file if I all I want is: {... RelatedTopics: [... Text:]...}
01:36:57 <jellie> I want to parse JSON files with such structure. However as you see there is an array under RelatedTopics. Would it make sense to make a type of this JSON file if I all I want is: {... RelatedTopics: [... Text:]...}
01:37:09 <jellie> This structure http://api.duckduckgo.com/?q=cat&format=json&pretty=1
01:46:16 <makalu> in GHC 7.6 I can write a Typeable instance. I could give two distinct types the same type representation and then use toDyn and fromDynamic (in Data.Dynamic) to do a broken cast?
01:46:55 <shachaf> No need to use Data.Dynamic.
01:47:33 <mauke> http://okmij.org/ftp/Haskell/types.html#unsound-typeable
01:48:16 <makalu> well yes I can just use unsafeCoerce but my issue is trying to do dynamic typing in Haskell and I thought I could do something like Data.Dynamic
01:48:33 <shachaf> You can use cast from Data.Typeable
01:49:08 <shachaf> In GHC 7.10, there are two distinct types with equal TypeReps (but distinct kinds). I can't figure out how to write unsafeCoerce with them.
01:54:00 <Myrl_> a
01:55:20 <mauke> Myrl: did you know you can identify with nickserv before regaining your nick?
01:55:40 <Myrl> mauke: I tried setting up SASL but failed horribly.
01:55:54 <mauke> I don't see what that has to do with anything but ok ...
01:56:25 <Myrl> mauke: Well, what I wanted to do was that when I reconnected, I'd use SASL to identify.
02:03:36 <jellie> Myrl: Did you use SASL with blowfish or something?
02:03:53 <jellie> Because that doesn't work. You have to use plain and send it over SSL.
02:05:11 <Myrl> jellie: Actually, I think it's because I'm not used to hexchat. I think what happened was that I edited an existing server list, however, you must press enter for it to save changes. Normally, I click the next entry without pressing enter.
02:13:22 <naevathecat> :quit
02:18:45 <swish_> guys, I have a question: if I have a constraint `(Default env) => ... StateT env m a ...`, how then I can tell to use this type inside a definition, something like `... evalStateT foo (def :: env) ...`?
02:19:40 <shachaf> You can turn on ScopedTypeVariables and put "forall env." in front of the type signature to make that work.
02:20:06 <shachaf> Or you can probably have GHC infer it, with that usage.
02:21:29 <tsahyt> is there a way to profile which part of my program eats the most memory?
02:22:19 <bennofs> tsahyt: is this a cabal project?
02:22:22 <tsahyt> yes
02:22:54 <swish_> forall env. doesn't help. Still getting: Could not deduce (Default env0) ... The type variable ‘env0’ is ambiguous ....
02:23:54 <bennofs> tsahyt: ok, then cabal configure with --ghc-options="-fprof-auto -rtsopts" and run the executable with +RTS -hc
02:24:07 <bennofs> tsahyt: what you want is called heap profiling
02:24:33 <bennofs> tsahyt: see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/prof-heap.html for more information
02:25:56 <tsahyt> "invalid heap profile option: -hc"
02:26:45 <bennofs> tsahyt: oh, right. for -hc you need --enable-executable-profiling too (called --enable-profiling in newer versions of cabal-install)
02:26:50 <tsahyt> according to the docs, -h does the same and that works
02:27:55 <bennofs> tsahyt: if you compile with profiling enabled, you can get more information like -hy which counts memory usage by type, etc. This requires that you have profiling versions of all dependencies though, which might require you to reinstall them with profiling enabled if you didn't already have this
02:29:40 <tsahyt> that could be useful. I'm working in a sandbox anyway so I might as well install all the profiling libraries there. I've never done that before, so how would I do it?
02:32:18 <bennofs> tsahyt: ok. As you're going to reinstall all the packages anyway, I'd recommend to first do a cabal sandbox delete first and re-init the sandbox (cabal sandbox init).
02:32:47 <bennofs> tsahyt: then, create a file cabal.config and write library-profiling: true in it
02:33:01 <bennofs> tsahyt: (the cabal.config file should be in the project root)
02:33:34 <bennofs> tsahyt: after that, you should be able to just do cabal install --only-dep and it should give you profiling versions
02:34:28 <tsahyt> Okay thanks! It's building now. I've tried this several times before but always ran into some problems.
02:36:15 <tsahyt> I've never seen base being installed in a sandbox by the way. Don't I need a profiling version of that as well?
02:36:41 <bennofs> tsahyt: oh, base should not be reinstalled.
02:36:46 <bennofs> tsahyt: what OS do you use?
02:36:55 <tsahyt> Linux (Fedora 20)
02:37:02 <tsahyt> It's not being reinstalled. I was just wondering why.
02:37:41 <mjo_> Hello. I have a list of say 1000 doubles. Given some arbitrary double x I'd like to be able to find entries in the list to either side of x. I can easily roll my own tree, but is there a canonically recommended way to do this ?
02:38:17 <tsahyt> mjo_: Why not just filter the list for (< x) and (> x)?
02:38:22 <bennofs> tsahyt: what package did you install to install haskell?
02:38:43 <mjo_> tsahyt: I want it to be fairly efficient, so walking the list every time seems a bit inefficient.
02:39:20 <bennofs> tsahyt: you need to have the -devel versions of the install packages too
02:39:27 <bennofs> s/install/installed
02:39:45 <tsahyt> bennofs: I'm using a repository from copr for GHC 7.8 and that comes with quite a few packages. I'd have to take a look if I have the -devel versions but I'm pretty sure they're there.
02:41:00 <mjo_> Is Data.Sequence and find from its Foldable instance a good way to go ?
02:41:28 <tsahyt> bennofs: Okay it seems to work, ghc isn't complaining about lacking profiling versions anymore.
02:42:26 <bennofs> tsahyt: it's still weird that it installed base. That should come with GHC
02:43:13 <tsahyt> Oh, I must have formulated that badly. It did *not* install base and I've never seen it being installed in a sandbox before. I was just wondering why many packages that I have installed outside of the sandbox get reinstalled but base doesn't.
02:43:39 <bennofs> tsahyt: ah, that's because base is part of GHC. it cannot be installed, but must come with gHC
02:44:13 <tsahyt> Oh that makes sense. So the base version is also coupled to the GHC version?
02:44:52 <bennofs> tsahyt: yes. 
02:54:33 <tsahyt> When breaking down profiling by type with -hy, there's a type named "*" that takes most memory most of the time. What type is that?
02:57:25 <bennofs> tsahyt: I found http://stackoverflow.com/a/24966834/2494803
02:58:00 <jellie> Hey, is there a way to work with only the part of a JSON file that I need?
03:01:30 <bennofs> jellie: you could use lens-aeson. not sure if including lens in this project (also learning it) isn't overkill though
03:01:32 <bennofs> @hackage lens-aeson
03:01:32 <lambdabot> http://hackage.haskell.org/package/lens-aeson
03:03:04 <jellie> bennofs: It's short but I quickly read through it and frankly understood none of it.
03:03:31 <jellie> bennofs: With this http://api.duckduckgo.com/?q=cat&format=json&pretty=1
03:03:52 <bennofs> jellie: what do you want to extract from that?
03:04:09 <jellie> bennofs: I'm trying to extract "Text" under "RelatedTopics"
03:05:55 <bennofs> jellie: with aeson, if you only define a FromJSON instance, you can ignore some of the fields I think
03:06:05 <jellie> bennofs: I already have a type but the type feels like overkill. Plus I'm not sure what I'll do with e.g line 5 so that I get what I want http://lpaste.net/701812701436837888
03:06:30 <jellie> bennofs: I didn't know that I could ignore some of the fields.
03:06:43 <jellie> Okay say I ignore every field save for the one in line 5
03:07:06 <jellie> Do I then write another type to explore that Value that is an array?
03:11:07 <bennofs> jellie: yes, that would work
03:11:18 <bennofs> jellie: you could also inspect the Aeson value directly
03:11:27 <bennofs> s/value/Value
03:12:11 <jellie> bennofs: How can I do that? Like relatedTopics[3] ?
03:12:30 <bennofs> jellie: aseon's Value type is an instance of FromJSON
03:12:54 <jellie> bennofs: I don't see how that helps.
03:13:15 <jellie> Oh I see
03:13:22 <jellie> It'll parse automatically
03:13:36 <jellie> for free i.e on it's own
03:15:26 * hackagebot persistent-sqlite 2.1.4 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-2.1.4 (MichaelSnoyman)
03:15:50 <bennofs> jellie: you can, for example, use (.:) :: Object -> Text -> Parser Value, so you can do parseJSON (Object o) = do v <- o .: "RelatedTopics"; ... now do something with v :: Value ...
03:17:30 <jellie> bennofs: I have issues understanding what you wrote because of indentation. Could you indent that and lpaste it?
03:17:58 <jellie> bennofs: No, wait
03:21:57 <jellie> bennofs: As I see (.:) takes an Object but RelatedTopics is an Array . Care to clarify?
03:25:26 * hackagebot stackage-curator 0.7.1.1 - Tools for curating Stackage bundles  http://hackage.haskell.org/package/stackage-curator-0.7.1.1 (MichaelSnoyman)
03:25:50 <tsahyt> What does CAF mean in the profiling output? All I found was constant applicative form but I'm having trouble understanding what this means in the context.
03:26:06 <bennofs> tsahyt: it's some top-level binding without arguments
03:26:32 <bennofs> tsahyt: so if you had fibs :: [Int]; fibs = ...  in a module, it would be a CAF
03:30:19 <tsahyt> So for instance I have the cost center "rayTrace/main/Main.CAF" eating up most memory. Is that the subtotal used by everything in this function? rayTrace itself is not in CAF
03:30:26 * hackagebot wai-extra 3.0.6 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.6 (MichaelSnoyman)
03:31:06 <bennofs> tsahyt: it's a cost centre stack. It says that Main.CAF calls main which calls rayTrace which uses up all memory
03:32:07 <fro_ozen> I have a problem
03:32:15 <fro_ozen> in the following situation: http://lpaste.net/130017
03:32:32 <fro_ozen> ghc gives the following error: Could not deduce (T a0) arising from a use of ‘recv’ from the context (T i, T a)
03:32:34 <bennofs> jellie: i'm writing an example
03:32:56 <jellie> bennofs: Okay
03:33:10 <fro_ozen> is there a way to tell ghc that the a parameter in the Signal from recv is the same as in Instance?
03:34:35 <bennofs> fro_ozen: can you naje that example produce the error you describe (just supply some stubs for the ...'s)
03:34:42 <bennofs> s/naje/make
03:35:44 <jellie> :t mzero
03:35:45 <lambdabot> MonadPlus m => m a
03:35:52 <jellie> :info mzero
03:36:02 <opqdonut> fro_ozen: it looks to me like you need an explicit type signature in process
03:36:06 <jellie> @hoogle mzero
03:36:07 <lambdabot> Control.Monad mzero :: MonadPlus m => m a
03:36:11 <opqdonut> fro_ozen: because ghc doesn't know what the a in the return type of recv will be
03:36:25 <opqdonut> fro_ozen: and thus can't know it has a T instance
03:36:29 <lpaste> bennofs pasted “Aeson use Value example (jellie)” at http://lpaste.net/130019
03:36:36 <bennofs> jellie: ^^
03:37:17 <opqdonut> fro_ozen: or in other words, you need to give sig a type signature
03:37:19 <jellie> bennofs: Let me try my thing out first before looking at your paste to get a sense of accomplishment. :)
03:37:51 <fro_ozen> what would the signature look like? (T i, T a) => IO (Signal i a) ?
03:38:13 <opqdonut> fro_ozen: yeah that might work. it's hard to say from this amount of code
03:39:16 <fro_ozen> the proble is, that the types are still asigned to new type variables
03:39:21 <opqdonut> fro_ozen: hmm, right, now I think I see how this goes
03:39:34 <bennofs> fro_ozen: you could either use the ScopedTypeVariables ghc extension and write process :: forall i a. ...; process inst = do sig :: Signal i a <- ...
03:39:35 <fro_ozen> so the result ends up Signal i1 a1
03:39:41 <opqdonut> fro_ozen: how about returning "sig" and changing the type to be "process :: (T i, T a) => Instance i a -> IO (Signal i a)"
03:40:02 <opqdonut> fro_ozen: then you can always define a "process_ :: (T i, T a) => Instance i a -> IO ()" in terms of process
03:40:33 <opqdonut> fro_ozen: on a more general level, it seems to me like Handle should maybe carry the "a" type parameter
03:40:48 <bennofs> fro_ozen: or use a local definition: process = do let recv' :: (T i, T a) => Instance i a -> Signal i a; recv' = recv . handle; sig <- recv' inst
03:41:08 <fro_ozen> now that you say it, putting the variable on the handle makes sense
03:41:18 <fro_ozen> that would also fix the problem, right?
03:41:54 <bennofs> fro_ozen: another way would be: asInstanceTypeOf :: Instance i a -> Signal i a -> Signal i a; asInstanceTypeOf x y = y and then do sig <- asInstanceTypeOf inst . recv . handle $ inst  (even if you do not use it here, that's a nice trick to know IMO)
03:42:16 <bennofs> fro_ozen: yes, that should also fix the problem
03:43:47 <fro_ozen> yup, it works
03:43:54 <fro_ozen> thank you very much :)
03:44:16 <tsahyt> When I do "map f xs" and start evaluating it element by element, the entire unevaluated part of the list will be just one thunk, right?
03:44:41 <opqdonut> tsahyt: yes
03:45:07 <bennofs> tsahyt: you just need to sure to not use the list twice
03:45:38 <bennofs> tsahyt: a common pitfall is something like mean xs = fromIntegral (sum xs) / length xs
03:46:11 <bennofs> tsahyt: the problem here is that since xs is used twice, when ghc evaluates sum xs, it cannot GC the elements of xs since they are still needed to calculate the length
03:46:50 <tsahyt> I'm not doing that, but out of curiosity, is there a way to avoid that?
03:47:18 <bennofs> tsahyt: write your algorithms to be single-pass. There are libraries that can automatically fuse some kinds of traversals
03:47:25 <bennofs> @hackage foldl -- is an example
03:47:25 <lambdabot> http://hackage.haskell.org/package/foldl -- is an example
03:47:50 <stacy> Hello, is there a way to compare the constraints in two cabal.config files ?
03:48:42 <tsahyt> Okay. What about using Data.ByteString.pack on a lazy list? Will this suddenly create a whole bunch of thunks?
03:49:39 <bennofs> tsahyt: if you do not hold a reference to the lazy list after that call, then the list elements will be GCed, but the bytestring is strict (i think) and so it needs to keep all bytes in memory
03:49:50 <tsahyt> I think my memory usage problems might be buried in something like this. I'm raytracing an image but the memory profile suggests that rather than evaluating pixel per pixel, I build a whole bunch of stuff for every pixel first and then start evaluating it.
03:51:28 <bennofs> tsahyt: can you show the function that uses all the memory?
03:52:33 <tsahyt> http://lpaste.net/2837654840581029888
03:52:47 <tsahyt> This is what I'm doing at the top level.
03:53:20 <tsahyt> main calls rayTrace and stores the resulting Image in a let binding and then calls imgToBMP with that. It then stores the resulting bitmap to disk
03:53:39 <bennofs> tsahyt: it looks like both planeRes p and cs need p to evaluate
03:53:44 <stacy> I'm trying to build two projects, both have copies of stackage, but I want to have a global copy that they both compare against.
03:54:08 <bennofs> tsahyt: oh, nvm
03:54:22 <bennofs> tsahyt: your problem could be too much laziness
03:54:53 <tsahyt> That's what I've been thinking. I've been frantically adding strictness annotations in various places but I'm not sure I really know what I'm doing
03:55:28 <bennofs> tsahyt: for example, if you create a thunk for the length of a list, you will want to evaluate that thunk as soon as possible, since storing the length of the list is much cheaper than holding the whole list to eventually compute the length later
03:56:03 <bennofs> tsahyt: the thing the helped me is thinking of `seq` as creating dependencies: a `seq` b 
03:56:07 <tsahyt> My guess is that somewhere along the way I create a big data structure holding thunks to thunks to thunks for each pixel in the final image
03:56:27 <bennofs> tsahyt: a `seq` b means: a must be evaluated before a `seq` b = b is evaluated
03:56:28 <tsahyt> If that's the case it must happen in this module though, since everything else only operates on single pixels
03:57:29 <bennofs> tsahyt: does planeRes just return a field of the ImagePlane?
03:57:41 <bennofs> tsahyt: or does it need the list of pixels too?
03:57:41 <tsahyt> just a tuple with the resolution
03:58:02 <bennofs> tsahyt: so ImagePlane has a field for the resultion?
03:58:12 <bennofs> s/resultion/resolution
03:58:14 <tsahyt> Yes
03:58:33 <tsahyt> data ImagePlane = ImagePlane Resolution Float Float
03:58:59 <tsahyt> it's just a type to store information about the plane through which the rays are casted.
03:59:17 <bennofs> tsahyt: can you try to lift the call to planeRes p to a let binding and `seq` that binding before returning the Image?
03:59:47 <bennofs> tsahyt: if planeRes p gets evaluated after cs, it might 
03:59:54 <bennofs> oh no, forget that
04:01:05 <tsahyt> seq only evaluates to WHNF, right?
04:01:09 <bennofs> tsahyt: yes
04:01:44 <bennofs> tsahyt: i wonder if it makes a difference if you manually substitute all the ps/rs/cs let bindings and write it directly as one long chain
04:01:54 <bennofs> tsahyt: smae for rgb binding in imgToBMP
04:02:58 <bennofs> tsahyt: so Image (planeRes p) . concatMap colorToRGBA $ map (computeColor s) . map (cameraRay c . planePoint c p) $ allPixels p
04:03:32 <tsahyt> It actually uses a bit more memory now
04:05:00 <tsahyt> Is it possible that the rgb ByteString is getting filled with thunks up to its full length before they are evaluated?
04:06:08 <bennofs> tsahyt: no, bytestring should be strict in the elements. Can you try using a lazy bytestring? Maybe the memory usage is just coming from creating the whole bytestring
04:06:09 <kvelicka> Hey guys. What is the best way to make a git fork of 7.10.1? The only way I can think of right now is to simply download the sources and make my own git repo of that but is there a better way?
04:06:53 <tsahyt> bennofs: The bmp library that I use for encoding expects strict ByteStrings.
04:07:09 <bennofs> kvelicka: I think that's the way to do it right now. you could probably also fork ghc/ghc on GitHub
04:07:49 <kvelicka> bennofs: But ghc/ghc is HEAD rather than the release version though, right?
04:08:04 <bennofs> kvelicka: it's a git repo, so you can just checkout the 7.10.1 release
04:09:21 <kvelicka> bennofs: hmm, why did I not think of that.. Good point, that's what I'll do. Thanks!
04:10:29 * hackagebot aeson-schema 0.3.0.3 - Haskell JSON schema validator and parser generator  http://hackage.haskell.org/package/aeson-schema-0.3.0.3 (TimBaumann)
04:11:26 <tsahyt> Well, generous application of deepseq has now halved memory usage. It's a start.
04:11:53 <tsahyt> Turns out that pack xs calls length xs at one point, leaving me with a lot of thunks. At least that's how I understand it
04:11:55 <gracjan> hi, I’ll just put this here: https://github.com/haskell/haskell-mode/wiki/Month-in-haskell-mode-March-2015
04:12:50 <ocramz> hi all
04:13:14 <jellie> bennofs: I can't figure it out past this http://lpaste.net/1738684232655437824
04:13:52 <bennofs> jellie: topicsArray :: Vector Value. You can get a [Value] from that using Data.Vector.toList
04:14:00 <bennofs> jellie: does that help?
04:15:30 <jellie> bennofs: This will be a list of what?
04:15:39 <jellie> Because it seems more like a hashmap to me
04:16:20 <bennofs> jellie: it will be the list of json Values. In this case, it will be a list of Object's (so you need to pattern match on each list entry again to extract the object for it and then lookup the Text key)
04:17:01 <jellie> bennofs: That makes sense. Let me try that.
04:17:39 <bennofs> jellie: also helpful: (from Control.Monad module): forM :: Monad m => [a] -> (a -> m a) -> m [a]. In your case, since Parser is a Monad, you can do: forM :: [Value] -> (Value -> m b) -> m [b], so you can create a list of b's by just giving a parser for one value
04:18:42 <bennofs> jellie: also, for the getRelatedTopics field of RelatedTopics, you want a [Data.Text.Text], no
04:18:45 <bennofs> ?
04:20:36 <bennofs> One more point: when using case, do not use otherwise for the remaining cases. 'otherwise' is not reserved keywords, so this will set the 'otherwise' value. For a "catch-all" pattern, you can instead use the "wildcard": _ -> ...
04:22:35 <jellie> bennofs: What I want is Text but what it seems I can put into getRealtedTopics is at best [Object]
04:22:45 <jellie> and that is what I have written as Array
04:22:54 <tsahyt> bennofs: In case you're interested this is how I solved it now http://lpaste.net/5273482685661052928 . It uses unsafePackLenBytes from the bytestring internals, but this way I can retain laziness per pixel while not having to evaluate the whole thing first. I've cut memory usage by a factor of 30 that way. It should also scale better now.
04:23:02 <jellie> bennofs: How would I get a [Text] there?
04:24:21 <jellie> bennofs: If otherwise isn't a reserved keyword why does it work as a catch all pattern?
04:25:15 <toogy> what is "!!" is haskell ?
04:25:18 <bennofs> jellie: it works just as if you had written: case 3 of { 1 -> ...;  x -> ... }
04:25:30 <toogy> in*
04:25:35 <bennofs> jellie: in the example I gave, x would equal 3
04:26:03 <bennofs> jellie: otherwise is just a variable name, so I could also have used otherwise instead of x in the example
04:26:17 <jellie> bennofs: I see that.
04:26:29 <tsahyt> :t (!!)
04:26:30 <lambdabot> [a] -> Int -> a
04:26:48 <bennofs> tsahyt: it returns the element at the given index in a list
04:26:50 <tsahyt> toogy: xs !! 5 returns the element in xs with index 5
04:26:57 <bennofs> toogy: ^^
04:27:03 <toogy> thanks :D
04:27:11 <bennofs> as in many other languages, indices begin at 0
04:27:15 <NateUni> Can someone help clarify something for me with a line of haskell code ?
04:28:26 <NateUni> I am confused about: replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]
04:28:53 <bennofs> NateUni: what part of it do you not understand?
04:29:31 <bennofs> > zipWith max [1,2,3,4,5] $ [4,5,6,7,8]
04:29:33 <lambdabot>  [4,5,6,7,8]
04:29:44 <NateUni> OK so I get what max does.. but the bit I am confused about is ZipWith.. I know it takes two lists.. but I cannot see how it gets it here from max? As max returns one list?
04:29:55 <bennofs> :t max
04:29:56 <lambdabot> Ord a => a -> a -> a
04:30:05 <bennofs> @src max
04:30:05 <lambdabot> max x y = if x <= y then y else x
04:30:18 <bennofs> max a b =   the maximum of a and b
04:30:34 <neuroserpens> wazap
04:30:36 <bennofs> NateUni: so zipWith 
04:30:37 <tsahyt> zipWith takes two lists and a function to combine them elementwise
04:30:41 <NateUni> i understand the compositions it is only.. the zip with in this context that I dont get...?!
04:30:53 <bennofs> > zipWith max [1,2,3,4,5] $ [4,5,6,7,8]   -- takes the maximum elementwise
04:30:55 <lambdabot>  [4,5,6,7,8]
04:31:33 <bennofs> > zipWith max [a,b,c] $ [d,e,f]
04:31:34 <lambdabot>  [max a d,max b e,max c f]
04:32:27 <neuroserpens> Do you really need that dollar sign?
04:32:30 <bennofs> NateUni: does that help?
04:32:46 <bennofs> neuroserpens: no, it was just left over from copy-pasting from the chain before
04:33:09 <NateUni> one sec.. just was playing around with ghci
04:33:15 <NateUni> reading now..
04:33:19 <merijn> bennofs, neuroserpens: In other words, haskellers are lazy ;)
04:33:20 <neuroserpens> bennofs: I see.
04:33:28 <neuroserpens> merijn: lol
04:33:57 <merijn> NateUni: Oh, wait I think I see your problem, I think you're parsing it wrong
04:34:46 <merijn> NateUni: "zipWith max [1,2,3] [4,5,6]" is parsed as: "(((zipWith max) [1,2,3]) [4,5,6])", max isn't applied to the list at all, max is an argument to zipWith
04:34:56 <merijn> :t zipWith
04:34:57 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
04:35:43 <NateUni> oh <merijn> so it is passed in as an argument
04:36:05 <merijn> Yes
04:36:09 <merijn> :t zipWith max
04:36:10 <lambdabot> Ord c => [c] -> [c] -> [c]
04:36:17 <jellie> bennofs: See Objects are key value pairs, right?
04:36:27 <NateUni> hmm ok.. 
04:36:47 <merijn> NateUni: zipWith takes a two argument function and 2 lists and then applies the function pairwise to the elements from the list, producing a new list
04:36:57 <bennofs> jellie: they are hashmaps. you can use the (.:) operator which has type Object -> Text -> Parser a though
04:37:02 <merijn> > zipWith (+) [1,1,1,1] [1,2,3,4]
04:37:03 <lambdabot>  [2,3,4,5]
04:37:22 <bennofs> > zipWith f [a,b,c,d] [e,f,g]
04:37:23 <lambdabot>      No instance for (Show c0)
04:37:23 <lambdabot>        arising from a use of ‘show_M394928447777476004632619’
04:37:23 <lambdabot>      The type variable ‘c0’ is ambiguous
04:37:28 <bennofs> :|
04:37:32 <NateUni> Yeah but how does max work in that case>? as it is not an pperator?
04:37:35 <neuroserpens> lol
04:37:37 <NateUni> *operator
04:37:37 <jellie> bennofs: Thanks
04:37:52 <merijn> NateUni: There's no difference between operator and function, they're both just functions
04:38:07 <merijn> NateUni: The only difference is that functions with operator names have to be written infix
04:38:20 <bennofs> > zipWith f [a,b,c,d] [e,f,g] :: [Expr]
04:38:22 <lambdabot>  [f a e,f b f,f c g]
04:38:22 <merijn> NateUni: Both 'max' and '(+)' are functions that take two arguments
04:38:25 <merijn> :t max
04:38:26 <lambdabot> Ord a => a -> a -> a
04:38:29 <merijn> :t (+)
04:38:30 <lambdabot> Num a => a -> a -> a
04:38:46 <neuroserpens> bennofs: Are you a wizard?
04:39:04 <bennofs> neuroserpens: I'm just a lambdabot assistent
04:39:07 <merijn> neuroserpens: That's just the simple-reflect package
04:39:09 <merijn> :t f
04:39:09 <NateUni> ok.. hmm still getting my head around haskell... it is very different from anything else I have used before.
04:39:10 <lambdabot> FromExpr a => a
04:39:24 <merijn> NateUni: It just takes some practice :)
04:39:24 <neuroserpens> xD
04:39:31 <merijn> :t a
04:39:32 <lambdabot> Expr
04:39:36 <NateUni> yeah and I neeeed a loooot
04:39:58 <merijn> neuroserpens: simple-reflect defines a bunch of single variable names + some typeclass voodoo to pretty print expressions :)
04:40:09 <merijn> You can use it in ghci too
04:40:15 <Aruro> @src map
04:40:15 <lambdabot> map _ []     = []
04:40:15 <lambdabot> map f (x:xs) = f x : map f xs
04:40:35 <NateUni> Ok so that makes more sense now!
04:40:44 <NateUni> thanks merijn
04:40:53 <merijn> NateUni: We can see that "zip :: [a] -> [b] -> [(a,b)]" is really just
04:40:55 <merijn> :t zipWith (,)
04:40:56 <lambdabot> [a] -> [b] -> [(a, b)]
04:41:56 <Aruro> which tool implements @src command in lambda bot?
04:42:04 <Aruro> would like to install it locally
04:42:12 <NateUni> So even , can be an argument ?
04:42:19 <mauke> it's less a tool and more a text file full of lies
04:42:31 <bennofs> Aruro: it's a hardcoded database
04:42:36 <Aruro> text file? :)
04:42:39 <bennofs> Aruro: not what GHC actually uses
04:42:44 <Aruro> hm
04:42:58 <Aruro> so vanilla source on hackage is different?
04:44:21 <indiagreen> yes, GHC code is sprinkled with various RULES and optimisations that @src doesn't show you
04:44:27 <bennofs> Aruro: yes, in many cases. map is actually the same though it looks: http://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-Base.html#map
04:45:27 <Aruro> yep map is same
04:46:12 <Aruro> does actually hoogle package supply possibility of source lookup?
04:46:30 <merijn> Aruro: Haddock automatically creates source links for all functions
04:46:51 <bennofs> Aruro: hayoo has a source link next to results
04:46:54 <NateUni> Sorry connection died.. 
04:46:56 <bennofs> @where hayoo
04:46:57 <lambdabot> http://hayoo.fh-wedel.de/ -- See also Hoogle: http://haskell.org/hoogle http://fpcomplete.com/hoogle
04:46:57 <Aruro> yes
04:47:12 <merijn> NateUni: Yeah, (,) is a bit special (in that it's a name not normally allowed for constructors), but other than that it behaves like any other operator
04:47:19 <Aruro> hackage also has source links
04:47:26 <Aruro> just wanted to use it from terminal
04:47:27 <merijn> NateUni: Hell, if you enable the TupleSections extension you can do even funkier things
04:47:47 <merijn> > zipWith (,1,) ['a','b','c'] [5,6,7]
04:47:49 <lambdabot>  [('a',1,5),('b',1,6),('c',1,7)]
04:47:53 <NateUni> Someone mentioned something to me about constructors in haskell.. how are they different form other languages?
04:48:12 <neuroserpens> watdafaq? ^
04:48:14 <merijn> Aruro: If you set "Documentation: True" in your ~/.cabal/config it will installs sources locally too
04:48:19 <merijn> neuroserpens: :)
04:48:38 <Aruro> ty
04:48:49 <merijn> neuroserpens: Partial sectioned application of tuple constructor :) That's not standard haskell though, as I said it requires the TupleSections extension
04:48:55 <neuroserpens> merijn: Are you a wizard?
04:49:17 <merijn> neuroserpens: Only as a hobby ;)
04:49:23 <neuroserpens> merijn: hahahahahaha
04:49:33 <bennofs> the magic here is called ghc
04:52:10 <NateUni> So merijn.. I was just playing around with haskell trying to think of random examples to learn the language.. (and its std lib) how else could I get the a list of all the vals 1..100 where the values mod 3 arent included? other than [x|x <- [1..100], x `mod` 3 /= 0] 
04:52:56 <Aruro> you just started NateUni?
04:53:02 <neuroserpens> NateUni: You could use the filter function, but I prefer list comprehensions.
04:53:12 <neuroserpens> NateUni: They look cooler.
04:53:31 <NateUni> ok looking now.. brb.. 
04:53:44 <Aruro> @src filter
04:53:44 <lambdabot> filter _ []     = []
04:53:44 <lambdabot> filter p (x:xs)
04:53:44 <lambdabot>     | p x       = x : filter p xs
04:53:44 <lambdabot>     | otherwise = filter p xs
04:54:17 <jellie> bennofs: Okay I kinda tried pattern matching it but it wont typecheck. http://lpaste.net/1738684232655437824
04:54:36 <jellie> bennofs: I think I'm having some major issues understanding how these types work.
04:54:40 <NateUni> Oh yeah this x:xs thing it always has to be in () right?
04:54:48 <earthy> no
04:54:54 <NateUni> That really threw me in lectures.. I was like wtF?
04:54:58 <merijn> NateUni: Well, prefix application binds tighter than infix
04:55:14 <merijn> So "filter p x:xs" would parse as "(filter p x):xs"
04:56:09 <Aruro> space is also operator NateUni
04:56:14 <merijn> That's not true
04:56:18 <merijn> And confusing
04:56:18 <frerich> NateUni: You could of course *also* generate a list which skips every third value and then take all values < 100: takeWhile (< 100) . concat . iterate (map (+3)) $ [1,2]
04:56:22 <Aruro> what is it?
04:56:23 <bennofs> jellie: ah, one thing you need to do is add {-# LANGUAGE OverloadedStrings #-} to the top of the file
04:56:24 <frerich> :-)
04:56:24 <NateUni> yeah I read that today... 
04:56:28 <merijn> Aruro: A space is a space...
04:56:34 <Aruro> f x y
04:56:40 <merijn> Aruro: It separates names
04:56:40 <Aruro> obviously space is not space
04:56:41 <NateUni> Ok so in that filter what is p?
04:56:46 <mauke> Aruro: can be written without spaces
04:56:51 <merijn> Aruro: Why is that obvious?
04:57:05 <merijn> Aruro: Also, consider "(f(x))y" which is the exact same thing
04:57:07 <bennofs> jellie: that's because by default, string literals are of type String in Haskell. (.:) takes a text as second argument though, and OverloadedStrings allows string literals to also have different types
04:57:18 <jellie> bennofs: I do have it at the top of my file
04:57:21 <mauke> or (f)(x)(y)
04:57:22 <Aruro> yes but source code uses space indentation
04:57:23 <bennofs> jellie: ah ok
04:57:25 <Aruro> not brackets
04:57:27 <mauke> or f{--}x{--}y
04:57:31 <bennofs> jellie: so I guess you get Couldn't match type ‘[b0]’ with ‘RelatedTopics’
04:57:41 <Aruro> so space does mean something in original version
04:57:49 <jellie> bennofs: How'd you know the exact error?
04:57:59 <bennofs> jellie: I just compiled it :D
04:57:59 <merijn> Aruro: Yes, it means "this is where the previous token/name ends"
04:58:13 <jellie> bennofs: Oh haha
04:58:23 --- mode: ChanServ set +o mauke
04:58:23 --- kick: perrier was kicked by mauke (msg me back if you're not a bot)
04:58:58 <bennofs> jellie: so, the reason for this is: your forM call returns a list of [Text], but parseJSON should return RelatedTopics!
04:59:16 <NateUni> Anyone recommend a good irc chat program form Mac?
04:59:17 <Aruro> no space means different things in different context you just demonstrated it above
04:59:23 <bennofs> jellie: so your forM ... is of type Parser [Text], but you want Parser RelatedTopics
04:59:30 <Aruro> with function application
04:59:45 <merijn> Aruro: Any two expression in a sequence boil down to "apply the first expression (presumably a function, else you have a type error) to the second expression"
04:59:45 <Aruro> being written like "(f(x))y"
05:00:02 <Aruro> its lambda calculus :)
05:00:08 <merijn> Aruro: That's the exact same meaning as "f x y", there is not different meaning in different contexts for space
05:00:18 <merijn> Space always means the same 'separate two names/tokens'
05:00:23 --- mode: mauke set -o mauke
05:00:26 <bennofs> jellie: now, to solve that type error, you can use fmap :: Functor f => (a -> b) -> f a -> f b. Since Parser is also a Functor, you use fmap :: ([Text] -> RelatedTopics) -> Parser [Text] -> Parser RelatedTopics!
05:00:29 <mauke> f(x)y
05:00:37 <merijn> NateUni: Depends how much you like to be in the terminal
05:00:46 <merijn> NateUni: Personally I just use irssi on OSX
05:01:12 <merijn> > div(4)2
05:01:13 <lambdabot>  2
05:01:20 <merijn> > div 4 2
05:01:20 <NateUni> ok I will look it up... now.. 
05:01:21 <lambdabot>  2
05:01:59 <Aruro> you can also use webinterface
05:02:23 <Aruro> like https://kiwiirc.com/
05:02:58 <jellie> bennofs: You're saying that I should make RelatedTopics an instance of Functor?
05:03:28 <bennofs> jellie: no. forM (toList topicsArray) (\elem -> ...) is right now of type Parser [Text], right?
05:03:50 <jellie> bennofs: Right
05:04:14 <bennofs> jellie: but what you need is Parser RelatedTopics, since parseJSON should be of that type.
05:04:36 <jellie> Aha so need a function ([Text] -> RelatedTopics)
05:04:42 <bennofs> jellie: yes!
05:05:08 <bennofs> and that is exactly the constructor of RelatedTopics:  RelatedTopics :: [Text] -> RelatedTopics
05:06:11 <jellie> bennofs: fmap RelatedTopics $ forM ....
05:06:11 <haskell657> printIt =      putStr "a"     putStr "b"  -- | Hi, what to do to execute couple statements?
05:06:18 <bennofs> jellie: correct
05:06:26 <bennofs> jellie: and then it should typecheck. at least it does for me
05:06:31 <haskell657> It didn't compile what I have written
05:06:55 <NateUni> ok back with a better client..
05:07:00 <mauke> haskell657: printIt = putStr "a" >> putStr "b"
05:07:10 <mauke> haskell657: printIt = do { putStr "a"; putStr "b" }
05:07:29 <jellie> bennofs: It does for me too. It looks like wizardry though. I hope to understand what it's doing by rereading these logs and the code
05:07:52 <NateUni> Ok so a few more haskell Qs..
05:07:53 <haskell657> thank a lot mauke
05:08:55 <bennofs> jellie: ok, so now that it's compiling, a few more things: I'd recommend to import Data.Vector qualified (import qualified Data.Vector as V). Then the names from that module will not conflict with Control.Monad / Prelude, but you need to use V.toList to refer to toList.
05:09:03 <NateUni> Someone suggested filters before… i cant remember their name and I closed the chat window!argh
05:09:33 <bennofs> jellie: Vector is typically imported qualified, since it defines a lot of conflicting names (tail, head, forM, ...)
05:09:41 <jellie> bennofs: It does compile but fails in the repl http://lpaste.net/1738684232655437824
05:09:47 <mauke> NateUni: see /topic for channel logs
05:09:48 <jellie> bennofs: Will do
05:10:40 <bennofs> jellie: also, you do not need to import Data.ByteString.Lazy.Internal. Internal modules are, as the name says, not for regular use but only if you need to do something that is not provided by the normal api. In this case, you can just import Data.ByteString.Lazy
05:10:43 <Aruro> @src filter
05:10:43 <lambdabot> filter _ []     = []
05:10:43 <lambdabot> filter p (x:xs)
05:10:43 <lambdabot>     | p x       = x : filter p xs
05:10:43 <lambdabot>     | otherwise = filter p xs
05:10:57 <NateUni> ahh yes
05:10:57 <Aruro> filter was exactly same conceptually as comprehensions
05:11:06 <Aruro> there is always IF inside
05:11:10 <Aruro> nothing more than that
05:11:10 <NateUni> :t filter
05:11:11 <lambdabot> (a -> Bool) -> [a] -> [a]
05:11:16 <bennofs> jellie: and I would also import that qualified, since bytestring is another package that defines a lot of conflicting names. 
05:11:35 <bennofs> jellie: ok, let me test this
05:11:39 <NateUni> p is the predicate?
05:11:47 <Aruro> it is a question of logic , you can filter elements only if you insert if in the process
05:12:11 <Aruro> yes p is (a->Bool) part
05:12:23 <Aruro> p x is check
05:12:30 <merijn> NateUni: Yeah, 'p' is short for predicate
05:12:31 <Aruro> p applied to x
05:12:55 <NateUni> still getting used to the all the recursion.. 
05:13:10 <Aruro> recursion is that for cycle you missing :)
05:13:14 <jellie> bennofs: Okay
05:13:19 <bennofs> jellie: the error message is better if you use eitherDecode
05:13:19 <Aruro> by coming into the world of fp
05:13:34 <bennofs> jellie: eitherDecode json :: Either String RelatedTopics
05:13:42 <bennofs> jellie: that will give you an error message in case of failure
05:13:50 <bennofs> λ: test
05:13:52 <bennofs> Left "key \"relatedTopics\" not present"
05:13:53 <NateUni> yeah i will be a better cocer at the end of the semester.. but definetly a learning curve..
05:14:01 <NateUni> *coder
05:14:16 <Aruro> no learning curve
05:14:25 <bennofs> jellie: which shows us that you made a typo: relatedTopics should start with uppercase r, not lowercase
05:14:28 <Aruro> just understand how for is translated into functional language
05:14:33 <Aruro> and you will be good to go
05:15:00 <Aruro> what is to learn? function is applied to another function, that is it :) rest is sintax
05:15:33 <jellie> bennofs: Heh, yeah feeling dumb. I fixed that and it says that the key "Text" isn't present.
05:15:50 <NateUni> ok so this is something else that confused me.. .when to use the ++ and when to use the :. Is ++ just for chars and strings? and : to concat lists?
05:15:53 <jellie> bennofs: but it is which means I did something wrong in my toJSON
05:16:08 <jellie> It's looking in the wrong place
05:16:11 <bennofs> jellie: yes, i noticed that. The problem is now that if you look closely, you will see that not all members of RelatedTopics have a "Text" attribute
05:16:18 <Aruro> : does not concat lists, it creates them
05:16:29 <bennofs> jellie: there are also some members which only have a "Topics" attribute which contains another list
05:16:30 <Aruro> what you call concat is pattern mathcing :)
05:16:44 <Aruro> > 1:2:[]
05:16:46 <lambdabot>  [1,2]
05:16:49 <NateUni> @src filter
05:16:49 <lambdabot> filter _ []     = []
05:16:49 <lambdabot> filter p (x:xs)
05:16:49 <lambdabot>     | p x       = x : filter p xs
05:16:49 <lambdabot>     | otherwise = filter p xs
05:17:05 <Aruro> filter p (x:xs) is pattern
05:17:08 <mauke> NateUni: ++ concatenates two lists
05:17:18 <NateUni> So what happens under the hood.. with 1:2:[]
05:17:31 <mauke> NateUni: : effectively prepends an element to a list
05:17:32 <Aruro> it is list constructor
05:17:43 <NateUni> :?
05:17:52 <Aruro> it  is basically operator which is in every list :)
05:17:55 <merijn> :t (:)
05:17:57 <lambdabot> a -> [a] -> [a]
05:18:00 <Aruro> its how list is represented
05:18:02 <merijn> :t (++)
05:18:04 <lambdabot> [a] -> [a] -> [a]
05:18:07 <Aruro> or created if you will
05:18:10 <mauke> [1, 2] is syntactic sugar for (1 : (2 : []))
05:18:11 <merijn> compare those two types
05:18:14 <hexagoxel> verement: constraints for version of base, maybe?
05:18:28 <Aruro> you have to tell computer what [1,2,3,4,4] means
05:18:37 <Aruro> it can be tuple with 5 elements
05:18:40 <Aruro> or list
05:18:49 <Aruro>  (1 : (2 : []))
05:18:51 <Aruro> like this
05:18:52 <NateUni> ahh ok thx mauke
05:19:28 <Aruro> list always have [] element, because : expects 2 arguments
05:19:32 <NateUni> ok that makes more sense..
05:19:36 <Aruro> so one element list is 1:[]
05:19:39 <Aruro> not just 1:
05:19:46 <NateUni> How long did it take you guys to get good at haskell?
05:20:01 <NateUni> good.. I mean proficient?
05:20:13 <Aruro> who needs good
05:20:15 <mauke> a year or two
05:20:16 <Aruro> you have to like it
05:20:24 <Aruro> if you dont like it forget it :)
05:21:00 <jellie> bennofs: Argghhh you know what? I just want the first element of the array so I'll try pass only that to the second argument of forM
05:21:28 <bennofs> jellie: if you only want the first element, you don't need forM at all
05:21:46 <bennofs> jellie: you can just pattern match on the list, and get the first element
05:22:24 <frerich> Is that definition by lambdabot the actual definition of 'filter'? I wonder why it isn't implemented as a fold.
05:22:40 <Aruro> people claim that it is not same
05:22:42 <Aruro> lets check
05:23:01 <jellie> bennofs: Well I'm just looking to pull the definition of a word for an irc bot so I think the first answer is okay with me.
05:23:27 <Aruro> http://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-List.html#filter
05:23:32 <Aruro> real definition
05:23:38 <NateUni> Ok so the next big learning curve I need to get under the belt.. quickCheck!
05:23:57 <NateUni> Where is the best resource to get a good intro to it? Advice guys?
05:24:08 <Aruro> @src filter
05:24:08 <lambdabot> filter _ []     = []
05:24:08 <lambdabot> filter p (x:xs)
05:24:08 <lambdabot>     | p x       = x : filter p xs
05:24:08 <lambdabot>     | otherwise = filter p xs
05:24:24 <bennofs> NateUni: you can start with OCharles 24 days of hackage post
05:24:33 <Aruro> so filter is same
05:24:36 <bennofs> NateUni: those provide a short intro to many hackage packages
05:24:51 <NateUni> bennofs: ok thx 
05:24:57 <Aruro> why do you need quickCheck Nate?
05:25:13 <bennofs> @src take
05:25:13 <lambdabot> take n _      | n <= 0 = []
05:25:13 <lambdabot> take _ []              = []
05:25:13 <lambdabot> take n (x:xs)          = x : take (n-1) xs
05:25:22 <frerich> Aruro: Why isn't it just "filter p = foldr (\x acc -> if p x then x:acc else acc) []"?
05:25:34 <tik_> @pl \[x, y] -> f x y
05:25:35 <lambdabot> (line 1, column 2):
05:25:35 <lambdabot> unexpected "["
05:25:35 <lambdabot> expecting pattern
05:25:38 <Aruro> @src foldr
05:25:38 <lambdabot> foldr f z []     = z
05:25:38 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:26:25 <Aruro> @pl \x y -> f x y
05:26:25 <lambdabot> f
05:26:25 <NateUni> Because my uni course is dove into it straight away.. and it is part of myy first few labs and assignments.. So I need to be able to tailor it.
05:26:56 <Aruro> frerich what you dont like about original source? looks nice to me :)
05:27:53 <tik_> @pl \x:y:[] -> f x y
05:27:53 <lambdabot> (line 1, column 6):
05:27:53 <lambdabot> unexpected "["
05:27:53 <lambdabot> expecting "()", natural, identifier, "_" or "("
05:28:01 <Aruro> tik
05:28:09 <tik_> Yeah?
05:28:10 <Aruro> lambda function is like this  \x t
05:28:14 <Aruro> lambda function is like this  \x y
05:28:17 <NateUni> bennofs: Because my uni course is dove into it straight away.. and it is part of myy first few labs and assignments.. So I need to be able to tailor it.
05:28:33 <Aruro> what do you want to do with pl?
05:28:47 <indiagreen> just add parens
05:28:55 <indiagreen> @pl \(x:y:[]) -> f x y
05:28:55 <lambdabot> (line 1, column 7):
05:28:55 <lambdabot> unexpected "["
05:28:55 <lambdabot> expecting "()", natural, identifier, "_" or "("
05:29:03 <tik_> You can pattern match in lambdas, no?
05:29:04 <indiagreen> okay, then I guess it's @pl's fault
05:29:07 <indiagreen> works in GHCi
05:29:13 <tik_> Heh, fair enough.
05:29:18 <frerich> Aruro: Well notice that in the HTML page you linked, other functions like 'and' are implemented in terms of foldr but only if 'USE_REPORT_PRELUDE' is set. I wonder why that is (and why this define is not used in the 'filter' definition).
05:29:26 <jellie> bennofs: Sorry, I got disconnected. Last thing I saw was me saying "bennofs: Oh wait I think I get what you mean"
05:29:28 <tik_> What's the result? Don't have access to ghci right now
05:29:30 <frerich> Aruro: I didn't say I dislike the definition you linked.
05:29:48 <indiagreen> tik_: the code works in GHCi, not the @pl-isation
05:30:03 <Aruro> good question
05:30:16 <NateUni> ok guys off to bed. Arura: merijn: bennofs: Thanks ffor the help! 
05:30:25 <Aruro> uwc!
05:30:26 <bennofs> jellie: last think I got:  jellie │ bennofs: Well I'm just looking to pull the definition of a word for an irc bot so I think the first answer is okay
05:30:36 <indiagreen> tik_: I think it would be “liftA2 f head (head.tail)”
05:30:53 <tik_> Oh, that's not very nice.. Thanks!
05:31:14 <ocin__> hi, is there a way to do an if/else statment using arithmetic? like ( i `mod` 2)( someFunction someData )
05:31:42 <merijn> ocin__: No
05:31:58 <merijn> Also, that would be awful...
05:32:11 <tik_>  You could make your own type class to achieve if-else with arithmetic, probably.
05:32:13 <ocin__> merijn: why?
05:32:13 <indiagreen> frerich: @src intentionally gives the Report definitions, not GHC definitions
05:32:32 <Aruro> we compared
05:32:36 <Aruro> in this cases they are same
05:32:44 <Aruro> @src filter
05:32:44 <lambdabot> filter _ []     = []
05:32:44 <lambdabot> filter p (x:xs)
05:32:44 <lambdabot>     | p x       = x : filter p xs
05:32:44 <lambdabot>     | otherwise = filter p xs
05:32:47 <Aruro> @src map
05:32:47 <lambdabot> map _ []     = []
05:32:47 <lambdabot> map f (x:xs) = f x : map f xs
05:32:53 <Aruro> are exact same definitions
05:33:11 <merijn> Aruro: Right, so?
05:33:27 <Aruro> to indiagreen
05:33:27 <Aruro> :)
05:33:30 <frerich> ocin__: You could have a list of functions and index into it, as in '([(+1), (*3)] !! (x+1)) 3'
05:34:49 <indiagreen> Aruro: I thought frerich asked about “and”, not about “map”
05:34:55 <indiagreen> and “and” is different
05:34:58 <indiagreen> @src and
05:34:59 <lambdabot> and  = foldr (&&) True
05:35:02 <Aruro> about filter he asked
05:35:09 <Redz> any idea how to write some safe network communication code? e.g. a network monad that guarantee a bit safety. the network package gives me creeps. 
05:35:34 * hackagebot uulib 0.9.19 - Haskell Utrecht Tools Library  http://hackage.haskell.org/package/uulib-0.9.19 (AtzeDijkstra)
05:35:42 <merijn> Redz: What sort of safety are you expecting?
05:36:14 <Aruro> what is if then else using arithmetic?
05:36:21 <frerich> indiagreen: I see, does that mean that a) the report has no definition for 'filter' or b) the definition given in the report does not use 'foldr' (in contrast with many other functions like 'and')?
05:36:43 <indiagreen> the report gives a definition, and it's the same @src gives
05:36:46 <jellie> bennofs: http://lpaste.net/1738684232655437824 I think I'm having a clash between Text and String because I got this from eitherDecode: Left "when expecting a [a], encountered String instead"
05:37:12 <frerich> indiagreen: I see, so my question would be - why does the report use 'foldr' for e.g. concat or 'and' but not for 'map' or 'filter'.
05:37:40 <bennofs> jellie: the problem is that RelatedTopics :: [Text] -> RelatedTopics
05:37:58 <jellie> Oh yeah
05:38:07 <jellie> bennofs: Right after pasting it hit me
05:38:08 <bennofs> jellie: that means that for o .: "Text" :: FromJSON a => a  it will pick a ~ [Text]
05:38:10 <jellie> It now works
05:38:32 <jellie> It's like I'm rubber ducking with you :( so sorry. You're not a rubber duck.
05:39:02 <jellie> getRelatedTopics :: Text not [Text]
05:39:09 <Aruro> > [-2.0 , -1.8 .. 2.0]
05:39:11 <lambdabot>  [-2.0,-1.8,-1.6,-1.4000000000000001,-1.2000000000000002,-1.0000000000000002,...
05:39:16 <butyoudonot> .ц 13
05:39:43 <bennofs> jellie: note that your code now crashes if you get an empty list of RelatedTopics
05:40:02 <jellie> bennofs: I wouldn't want that
05:40:02 <bennofs> not sure if that can happen
05:40:04 <jellie> yeesh
05:40:18 <jellie> bennofs: I want to make sure it can't crash
05:40:31 <bennofs> jellie: you need to deal with the case that V.toList topicsArray is []
05:40:34 * hackagebot uhc-util 0.1.5.3 - UHC utilities  http://hackage.haskell.org/package/uhc-util-0.1.5.3 (AtzeDijkstra)
05:40:41 <bennofs> jellie: so you need another pattern match :)
05:40:52 <Redz> merijn: detection of broken connections and clean aboards, a clean protocol for sending and receiving read/show-able data, io abstraction and everything else that might be reasonable. 
05:42:04 <jellie> bennofs: but can I pattern match like that in a lambda?
05:42:24 <bennofs> jellie: you don't need a lambda. just case V.toList topicsArray of ...
05:44:10 <indiagreen> frerich: I don't know. What's even more curious, in Haskell 1.4 “filter” was more general, and its definition looked like this:
05:44:14 <indiagreen> filter           :: MonadZero m => (a -> Bool) -> m a -> m a
05:44:18 <indiagreen> filter p         =  applyM (\x -> if p x then return x else zero)
05:44:55 <indiagreen> maybe they decided that the explicit definition looked better, or something
05:45:00 <bennofs> Haskell 1.4 was more general in many cases AFAIK. it has been reverted to aid learning
05:45:47 <frerich> indiagreen: I wondered whether maybe the report definition also had the same considerations in mind which made the GHC people not (by default) use the report definitions of e.g. 'and' but rather something supposedly more efficient.
05:46:05 <frerich> but I guess 'explicit looks better' is more likely...
05:46:14 <Aruro> which version is current?
05:46:15 <jellie> @hoogle Text -> Parser Text
05:46:17 <lambdabot> No results found
05:46:47 <indiagreen> Aruro: version of what?
05:46:56 <indiagreen> Haskell? 2010, then
05:47:09 <bennofs> jellie: how about return :: Monad m => a -> m a? (Parser is a Monad)
05:47:25 <Aruro> yes current is 2010
05:47:26 <Aruro> ?
05:47:32 <Aruro> and before it was called  1.4?
05:47:42 <indiagreen> no, before was 98
05:47:54 <jellie> bennofs: Yeah that could work but I just used mzero instead even though I don't really get what mzero is about/for
05:47:54 <Aruro> than what is 1.4?
05:48:11 <frerich> Aruro: https://www.haskell.org/definition/ explains that 2010 is current, succeeding 98. Which in turn was preceded by 1.4
05:48:26 <bennofs> jellie: mzero makes the parsing fail. So when you use decode, you get a Nothing when a case where you call mzero is reached
05:48:46 <Aruro> ty
05:49:01 <bennofs> jellie: if you want to produce a better error message, you can also use fail :: Monad m => String -> m a (it's a bit unfortunate that it's part of the Monad class)
05:49:28 <bennofs> jellie: so instead of mzero, you can use fail "your error message", so "your error message" will appear if you use eitherDecode
05:50:21 <jellie> bennofs: I noticed that your example had a lot of fail but I wasn't familiar with it so I kept away. I planned on asking you about it.
05:51:12 <jellie> bennofs: Sounds like fail is an attractive choice
05:51:57 <jellie> bennofs: This can't crash now can it? Though it would give bad error messages http://lpaste.net/1738684232655437824
05:52:36 <bennofs> jellie: looks ok, but you can replace the lambda in this list case with: (elem:_) -> ... and just use elem in ...
05:54:19 <warbo> I'm writing some Arbitrary instances which use intermediate types, ie. '(arbitrary = show (arbitrary :: Gen (Foo a))) :: Gen String'
05:54:27 <jellie> bennofs: I'm not familiar with that syntax. Could you clarify?
05:54:40 <warbo> what's the "recommended" way to make 'a' unambiguous, whilst preferably being extensible?
05:56:12 <warbo> in this case, I'm generating Strings of Haskell code from values of type "ExpG a"
05:56:20 <lpaste> bennofs pasted “pattern match on list (jellie)” at http://lpaste.net/130025
05:56:29 <bennofs> jellie: does the paste help?
05:56:45 <bennofs> oops, replace a with x there
06:03:57 <jellie> bennofs: I'm not familiar with that syntax. Could you clarify on ` (elem:_) -> ... and just use elem in ...`
06:03:58 <jellie> bennofs: I'll have to do a few more exercises with parsing JSON. I don't feel like I did much there.
06:04:19 <bennofs> jellie:  bennofs pasted “pattern match on list (jellie)” at http://lpaste.net/130025
06:04:35 <bennofs> jellie: replace the a with an x there
06:06:42 <jellie> bennofs: Thanks. :)
06:10:36 * hackagebot iproute 1.4.0 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.4.0 (KazuYamamoto)
06:11:59 <Redz> hm. how should it be formatted? http://code-fight.club/fight/65/data-declaration
06:13:33 <bergmark> i prefix with commas, otherwise i forget them when i move things around
06:13:45 <Aruro> i think first bracket is a problem
06:14:06 * bennofs likes the first one better
06:14:50 <benma> Redz: prefix comma, but move the indentation to align with the second "Foo"
06:16:10 <Aruro> they are both correct
06:16:13 <Aruro> i just checked
06:16:21 <Redz> i like the first one better too. 
06:16:44 <Aruro> so this question for fight club is wrong
06:16:45 <Aruro> :)
06:16:49 <bennofs> benma: I don't like that, since it leaves a lot of free space and depends on the length of the data constructor
06:17:16 <Aruro> i like right one
06:17:16 <Redz> i guess the c# guys voted for the other one. the site is relatively open. 
06:17:38 <Aruro> no but one answer should be wrong :) if i understand correctly the point
06:17:39 <bennofs> Aruro: i think it's about style, not correctness?
06:17:39 <benma> bennofs: align with the "F" of "Foo". it doesnt depend on the constructor
06:17:45 <Aruro> ok
06:17:51 <bennofs> benma: oh, then on the data type name length 
06:17:57 <Redz> Aruro: no. one answer should be better. ;)
06:18:03 <Aruro> aaa :)
06:18:08 <benma> bennofs: true. this is how my haskell-mode in emacs indents it
06:18:08 <Aruro> right one :D
06:18:42 <Aruro> bracket in the same line with foo tells - rest is mine
06:18:53 <Aruro> which is important to quickview
06:19:07 <Aruro> for*
06:19:15 <bennofs> more interesting is: what do you do if you have multiple constructors with record fields?
06:19:35 <Aruro> ooo :D
06:19:45 <Redz> | Bar
06:19:45 <Redz>   { ... 
06:19:45 <Redz>   }
06:20:00 <bennofs> and for the first?
06:20:04 <bennofs> = Foo
06:20:10 <bennofs> on a new line?
06:20:19 <Redz> jup
06:20:28 <bennofs> ok, that's what I do too :)
06:20:36 * hackagebot json-autotype 0.2.5.12 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.5.12 (MichalGajda)
06:20:40 <Redz> :D
06:20:46 * bennofs really wants -fwarn-fixed-space
06:20:51 <benma> bennofs: i think having multiple constructors with record fields is bad practice. has some unexpected behaviour too
06:21:01 <Aruro> then like this http://pastebin.geany.org/12Hzk/
06:21:05 <benma> stick to either records or unions
06:21:18 <bennofs> benma: not if you use it with makeLenses from lens :)
06:21:43 <bennofs> (it will create traversals, not lenses, for fields that don't appear everywhere)
06:21:48 <Aruro> is there any good tutorial on types?
06:22:12 <benma> bennofs: good point
06:22:19 <Aruro> like which goes in nice details about recursive types and so on
06:23:01 <Lis> hello everyone again. how do i loop over a list of list [["a","b"],["c","d"]] so i get ["a","b"] and ["c","d"]
06:23:14 <benma> Aruro: implement lists and binary trees yourself, filling knowledge gaps by googling
06:23:23 <benma> Aruro: should make it pretty clear how recursive types work
06:23:26 <Aruro> sounds very right :)
06:23:35 <Alex-Mes> 2N FREE STEAM GAMES http://tinyurl.com/ptv3gfv
06:24:03 <Aruro> loop over?
06:25:37 * hackagebot arbtt 0.9.0.2 - Automatic Rule-Based Time Tracker  http://hackage.haskell.org/package/arbtt-0.9.0.2 (JoachimBreitner)
06:25:41 <Aruro> @hoogle [[a]]->[a]
06:25:41 <bennofs> Aruro: I'll give you a fun type: data FunList a b = More a (FunList a (a -> b)) | End b    . Btw, this is a Functor :)
06:25:42 <lambdabot> Prelude concat :: [[a]] -> [a]
06:25:42 <lambdabot> Data.List concat :: [[a]] -> [a]
06:25:42 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
06:26:11 <warbo> @Lis it depends on what you want to do with those sub-lists (ie. what your return type is)
06:26:11 <lambdabot> Maybe you meant: oeis list id bid
06:26:29 <Lis> warbo they hold configuration options
06:26:33 <Aruro> ty bennofs :)
06:26:37 <Aruro> i will check it out
06:27:12 <warbo> Lis: that's what they *are*, not what you want to do with them ;)
06:27:22 <bennofs> Aruro: btw, it's also Applicative I think :)
06:27:56 <warbo> Lis: do you want to send them both into a function, ie. "f first second", or send them one-at-a-time into a function, ie. "[f first, f second]", etc.
06:28:02 <Aruro> nice example :)
06:28:21 <Lis> warbo, the second case
06:28:52 <Aruro> so list ends with b that is clear
06:29:01 <Lis> map (show) [["a","b"],["c","d"]] gives ["[\"a\",\"b\"]","[\"c\",\"d\"]"] i want to have [\"a\",\"b\"] and then [\"c\",\"d\"]
06:29:02 <warbo> Lis: then take a look at the "map" function: "map f [a, b, c, ..]" gives "[f a, f b, f c, ...]"
06:30:02 <warbo> Lis: so you want to trim off the "[" and "]" from the strings?
06:30:19 <bennofs> Aruro: and it's isomorphic to data Bazaar a b = Bazzar (forall f. Applicative f => (a -> f a) -> f b)  iirc. That type can be generalized to data Bazaar a b t = Bazaar (forall f. Applicative f => (a -> f b) -> f t)  and now you have just discovered part of the internals of ATraversal from lens :)
06:30:31 <warbo> Lis: what do you mean "and then"?
06:30:54 <Aruro> gosh im not quite there yet :D
06:31:42 <benma> Lis: you'll have to explain in more detail what your goal is. print those one by one, with newlines? process them in some other way?
06:31:54 <benma> basically what warbo said ;)
06:32:00 <Aruro> im slightly confused about (a->b) part
06:32:27 <Aruro> so i have More Int (Funlist Int (Int->Int)) | End Int
06:32:59 <bennofs> Aruro: can you construct an example value of the type?
06:34:05 <Aruro> and then i have:  More 1 (Funlist 1 f) | End f 
06:35:37 * hackagebot wai-extra 3.0.6.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.6.1 (MichaelSnoyman)
06:35:38 <bennofs> Aruro: you seem to be mixing types and values here?
06:36:27 <lpaste> ryanar pasted “need a fresh pair of eyes, what is my error here?” at http://lpaste.net/354754158231814144
06:37:21 <Aruro> i do yes
06:37:50 <Aruro> so ok like this data FList Int Int = More Int (Flist Int (Int->Int)) | End Int
06:38:21 <Aruro> simplest form looks like More Int (End Int)
06:38:48 <Aruro> apart from End Int
06:39:37 <bennofs> Aruro: More 3 (End 4) would be a type error
06:39:46 <merijn> Ryanar: It's hard to see, I don't know the types of all function you use
06:39:47 <LAC1213> How would you make a pattern match like this: f :: Int -> Int -> Bool ; f a a = False
06:39:50 <LAC1213> ?
06:40:10 <merijn> Ryanar: One side note, "(drop ((length xs)-1) xs)" is a really inefficient way to implement "last"
06:40:12 <bennofs> Aruro: maybe we should move this to #haskell-overflow? (idk)
06:40:22 <LAC1213> I get an error: Conflicting definitions for ‘a’
06:40:37 * hackagebot lifted-threads 1.0 - lifted IO operations from the threads library  http://hackage.haskell.org/package/lifted-threads-1.0 (arybczak)
06:40:45 <merijn> LAC1213: You can't, you'd have to do "f a b | a == b = False" using a guard or "f a b = if a == b then False else True"
06:40:51 <Aruro> ok i joined HO
06:40:59 <Ryanar> merijn, is there a built in last? I can write my own, just take head off the list until your tail is empty list and return it
06:41:04 <merijn> :t last
06:41:05 <lambdabot> [a] -> a
06:41:09 <Ryanar> merijn, ha.
06:41:12 <LAC1213> maerijn: ok thx
06:41:13 <merijn> > last [1,2,3,4,5]
06:41:13 <Ryanar> merijn, thanks
06:41:14 <lambdabot>  5
06:41:34 <Ryanar> merijn, the type of [a] is double
06:41:43 <Ryanar> merijn, or int in some cases
06:42:14 <merijn> Ryanar: Incidentally "(take ((length xs)-1) xs)" is init
06:42:16 <Lis> ah. i got that error cause the file was not read. therefore i got [()] and not anything like [[String]]
06:42:18 <merijn> > init [1,2,3,4,5]
06:42:19 <lambdabot>  [1,2,3,4]
06:42:20 <Lis> ty everyone
06:42:33 <Lis> map foo [[String]] is what i was looking for right from the start on
06:43:25 <merijn> Ryanar: Oh, easy, I see it now
06:43:45 <merijn> Ryanar: "solveTriangularSol (x:[]) a = [solveLine x a]" <- this can't possibly work
06:44:12 <merijn> Ryanar: 'x' and 'a' there both have type "Fractional a => a", but solveLine has type "[a] -> [a] -> a"
06:44:25 <merijn> So that can't typecheck
06:44:44 <merijn> Oh, no, 'x' has the right type, it's just 'a' that's wrong
06:45:37 * hackagebot yesod-core 1.4.9.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.9.1 (MichaelSnoyman)
06:46:10 <Ryanar> ok so
06:46:54 <yiin> hi, can i decalre a 2 functions with the same name but different input types ?
06:47:11 <merijn> Ryanar: You can see on line 17 that the error tells you the expression it thinks is wrong and above there which types it thinks the separate parts have
06:47:21 <merijn> yiin: No. Or yes, but only in different modules
06:48:03 <Ryanar> Ah, I see it now, jeez the number of times I have made that mistake
06:48:20 <yiin> ok, then can i break a recursive  function?
06:48:43 <yiin> without returning anithin?
06:48:52 <merijn> yiin: That's a nonsensical question in haskell
06:49:02 <merijn> yiin: Functions always evaluate to some expression
06:49:15 <merijn> Ryanar: It pays to carefully read the type errors ;)
06:49:25 <merijn> Ryanar: Incidentally, "(Num a, Fractional a)" is redundant
06:49:40 <Ryanar> merijn, because Fractional a includes Num?
06:49:43 <merijn> Ryanar: Num is a superclass of Fractional, so the Num is implied when you write "Fractional a"
06:49:46 <merijn> Yes
06:50:30 <yiin> but it looks nonsense to build an empty matrix instead of breaking the recursive
06:51:13 <merijn> What would "breaking the recursive" mean?
06:51:33 <yiin> let me post that on pastbin real quick
06:51:36 <mjboa> bennofs: for the Functor instance i just have run f over the End arg and for More just call fmap (flip (.) f) on the second arg?
06:51:47 <warbo> yiin: perhaps you want to return a "Maybe" type? https://wiki.haskell.org/Maybe
06:51:59 <osa1__> do you know if anything related with FlexibleContexts changed with GHC 7.10?
06:53:20 <glguy> You have to turn them on if you use them
06:53:27 <merijn> osa1__: No, BUT
06:53:41 <glguy> Not just if you write them
06:53:49 <merijn> osa1__: GHC will now demand extensions be enabled if writing the type for an inferred function requires it
06:54:12 <merijn> osa1__: Before, if you didn't write down a type, but GHC inferred one that required, i.e. FlexibleContexts it would just silently work
06:54:15 <Redz> do you guys prefer list comprehension or list monad? 
06:54:22 <bennofs> mjboa: i'd probably write it as fmap (fmap f). I think the flip is not needed
06:54:34 <merijn> osa1__: In 7.10 if it infers a type that requires an extension it will now complain that you have to enable it
06:54:42 <merijn> Redz: I rarely use either, tbh
06:55:26 <mjboa> bennof: because of the functor instance on ->, true
06:55:38 * hackagebot web-routing 0.6.2 - simple routing library  http://hackage.haskell.org/package/web-routing-0.6.2 (HirotomoMoriwaki)
06:55:50 <osa1__> merijn: this makes sense, thanks
06:56:30 <bennofs> Wait, we can even extend this type to data FunList f a b = Next a (f b) | End b . Looks like free something
06:58:10 <merijn> osa1__: It's arguably very weird that it ever worked differently :)
06:58:47 <yiin> merijn: the line 26 bother me http://pastebin.com/AhdwSDP5
06:58:56 <mjboa> bennofs: good point
06:59:57 <lpaste> ryanar revised “need a fresh pair of eyes, what is my error here?”: “does solveLine look cleaner now? thanks merijn :)” at http://lpaste.net/354754158231814144
07:02:10 <merijn> Ryanar: I would personally move the "let" definitions into where
07:02:14 <yiin> merijn: i put "(replicate b [])::Picture" but it looks like it can be avoided
07:02:21 <merijn> where is commonly preferred over let
07:02:51 <Ryanar> just for readability?
07:02:57 <merijn> yiin: Why does it look like it can be avoided?
07:03:08 <merijn> Ryanar: Yeah, it feels less cluttered to read that way
07:04:33 <osa1__> is this a cabal bug: The package 'lattices' requires Cabal library version >=1.19.2 && =1.2 but no suitable version is installed. ?
07:04:34 <yiin> merijn: if i can redeclare the function 'beside' with Picture -> Bool -> Picture, i can then write "0 b = False"
07:04:59 <osa1__> >=1.2, not =1.2
07:05:14 <osa1__> (I deleted that char while deleting newline)
07:05:47 <osa1__> merijn: yeah but now we're having lots of breakages for now very good reason IMO
07:05:58 <osa1__> s/now/no
07:06:29 <osa1__> and some of the libraries are missing maintainers so I don't when when we're able to use them
07:07:48 <lpaste> ryanar revised “need a fresh pair of eyes, what is my error here?”: “yeah I agree I do like it where better for readability” at http://lpaste.net/354754158231814144
07:13:06 <clrnd> just tried lens for the first time: they are super useful, but they don't feel "haskelly"
07:14:01 <merijn> Ryanar: FYI, where doesn't have to be indented that far
07:14:14 <merijn> Ryanar: They only have to be indented further than the start of the line they belong too
07:14:32 <tsahyt> How would I go about having two datatypes that mutually reference each other in two separate modules?
07:14:53 <merijn> Ryanar: Like this: http://lpaste.net/354754158231814144
07:15:09 <mauke> tsahyt: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate-compilation.html#mutual-recursion
07:15:10 <merijn> Ryanar: Also, you're missing a case in solveTriangularSol
07:15:12 <Ryanar> merijn, ack, ok haha
07:15:25 <merijn> Ryanar: Use -Wall while compiling and GHC should warn you
07:16:06 <Ryanar> ok
07:16:17 <tsahyt> merijn: Is there any clean general way to break such a dependency?
07:16:53 <tsahyt> mauke: Is there any clean general way to break such a dependency?
07:16:55 <merijn> tsahyt: Yes, but both in the same file and import it from there. (Although you probably meant mauke :p)
07:17:26 <mauke> tsahyt: yes, see what merijn said (although he probably meant "put")
07:17:55 <tsahyt> I think I'll have to rethink my design a bit here. Thanks.
07:24:53 <merijn> GHC's lack of recursive imports is one of my biggest pet peeves...
07:28:51 <tsahyt> Okay maybe this is my lack of experience with functional programming and someone can help me clear this up. So I have a Scene type, which among other things holds an [Object]. One Object contains a list [Shader]. A Shader is basically a function ShaderContext -> Light -> RGBA, and the ShaderContext contains the whole original scene. That's where the circularity comes from. Does anyone have an idea how to clean this up such that I can 
07:31:29 <merijn> tsahyt: The circularity isn't inherently problematic, it just means you have to either move the data declarations into the same module or use a hs-boot file
07:32:21 <tsahyt> I don't think shaders and scene descriptions logically belong in the same module. I'll have a look at this hs-boot thing.
07:32:31 <merijn> tsahyt: To avoid circular imports I usually have a "MyLib.Types" module that's internal (i.e., hidden) and the other modules import datatypes from there
07:32:50 <merijn> tsahyt: Yeah, I know, it's a bit of a pain in the ass
07:33:26 <merijn> But circular imports are not a big enough painpoint for people to have implemented it. I'm sure GHC HQ would welcome a patch for it, but I too haven't been annoyed enough to write one yet :p
07:34:23 <tsahyt> merijn: I started putting types into internal modules but I ended up doing the same thing in those modules because I somehow want to separate those two things. Then again, mutually recursive imports somehow look like a code smell to me.
07:34:47 <merijn> tsahyt: Actually, there's a third trick, I guess
07:35:38 <tsahyt> merijn: Which is?
07:35:43 <merijn> "data Foo = Foo [Bar]" "data Bar = Bar (Maybe Foo)" <- this circularity can also be broken by: "data Foo a = Foo [a]" "data Bar a = Bar (Maybe a)"
07:36:40 <tsahyt> I don't really see how that works when Foo and Bar are in separate modules
07:36:56 <neuroserpens> merijn: Don't you ever get tired of wizardry?
07:37:07 <stacy> Is there some way to find an unallocated port ?
07:37:20 <merijn> neuroserpens: Yes, that's when I go play videogames
07:37:23 <tsahyt> Oh, okay. Now I see.
07:37:26 <stacy> (don't want to randomly generate & test them myself).
07:39:47 <stacy> :t PortId
07:39:48 <lambdabot> Not in scope: data constructor ‘PortId’
07:40:42 <stacy> @hoogle PortId -> IO Bool
07:40:44 <lambdabot> Did you mean: PortID -> IO Bool
07:40:44 <lambdabot> Control.Concurrent.MVar tryPutMVar :: MVar a -> a -> IO Bool
07:40:44 <lambdabot> GHC.IO.Device getEcho :: IODevice a => a -> IO Bool
07:40:57 <stacy> @hoogle PortID -> IO Bool
07:40:57 <lambdabot> Control.Concurrent.MVar tryPutMVar :: MVar a -> a -> IO Bool
07:40:57 <lambdabot> GHC.IO.Device getEcho :: IODevice a => a -> IO Bool
07:40:57 <lambdabot> GHC.IO.Device isSeekable :: IODevice a => a -> IO Bool
07:41:23 <stacy> @hoogle IO PortID
07:41:23 <lambdabot> Did you mean: :: IO PortID
07:41:24 <lambdabot> No results found
07:41:38 <stacy> @hoogle :: IO PortID
07:41:38 <lambdabot> Network socketPort :: Socket -> IO PortID
07:41:38 <lambdabot> System.Exit exitFailure :: IO a
07:41:38 <lambdabot> System.Exit exitSuccess :: IO a
08:00:16 <haskell408> hey guys
08:00:20 <haskell408> If I got a dtatype
08:00:26 <haskell408> with multiple values
08:00:31 <haskell408> and I am trying to pattern match on them
08:00:36 <haskell408> inside of a function.
08:00:46 <haskell408> Do I need to do this for all the data types
08:00:52 <stelleg> is it possible to get ghc to print type synonyms if they are available?
08:00:53 <haskell408> f d1 = "asdfasdf"
08:00:57 <haskell408> f d2 = "asgasdfasdf"
08:01:03 <haskell408> f d3 = ";qjw;jfasf"
08:01:06 <merijn> stelleg: It already tries it's best to do that
08:01:06 <haskell408> or is there an easier way
08:01:11 <stelleg> e.g. type Id = forall a . a -> a
08:01:18 <stelleg> id :: Id
08:01:20 <stelleg> :t id
08:01:21 <lambdabot> a -> a
08:01:45 <stelleg> merijn: thanks. any way to help it along its way
08:01:46 <stelleg> ?
08:01:53 <merijn> Not afaik
08:01:59 <stelleg> k thanks
08:03:38 <lpaste> ryanar pasted “where clause -- is there a cleaner way?” at http://lpaste.net/9185183403861868544
08:04:20 <merijn> :t map negate
08:04:21 <lambdabot> Num b => [b] -> [b]
08:05:59 <Ryanar> ah
08:06:21 <Ryanar> I haven't really learned about map, fold, etc. yet
08:07:06 <Ryanar> merijn, as far as a where clause in the middle of my pattern matching, should that just be broken up into a separate function?
08:10:00 <haskell408> Hey guys 
08:10:07 <merijn> Ryanar: A where clause is tied to only a single pattern like here. Whether it should be a separate function depends. If it's not useful outside the function you define it in, I would keep it local
08:10:08 <haskell408> if I got a data type f = a | b
08:10:17 <haskell408> and I am trying to do something on a
08:10:20 <merijn> Ryanar: The less things are in the global scope, the less clutter there is
08:10:26 <merijn> haskell408: That's not a valid data type
08:10:30 <Ryanar> merijn, ok that makes sense, thanks
08:10:53 <haskell408> data f = a | b
08:10:55 <haskell408> is not possible?
08:12:17 <stelleg> haskell408: types and data constructors have to start with a capital letter
08:12:18 <Freundlich> haskell408: An alternative must be disjoint. That's guaranteed because you have to put a different type constructor into each case.
08:12:24 <stelleg> data F = A | B
08:12:42 <haskell408> okay, my question wasn't the semantics tho
08:12:53 <haskell408> but if I have a function that takes an F 
08:13:06 <haskell408> but I want to perform an operation on A
08:13:15 <haskell408> so I am using a guard where I say
08:13:26 <haskell408> | F == A = f A
08:13:30 <haskell408> i mean
08:13:38 <haskell408> | F == A = f F 
08:13:44 <haskell408> where f is a function that takes an A
08:14:00 <haskell408> the compiler yells at me
08:14:14 <haskell408> cuts its expecting an A but got an F even though F is constructed with an A
08:14:39 <stelleg> you are asking if a type F is equal to a value A, which doesn't really make sense in standard haskell
08:14:44 <merijn> haskell408: F isn't a constructor of F, though
08:15:27 <stelleg> you probably want something like case variable of A -> f variable
08:15:58 <haskell408> oh use case
08:16:04 <Athas> Do I need to do anyting special in order to make 'cabal sdist' know about the autogenerated modules (i.e. Build_foo.hs)?
08:16:07 <stelleg> or pattern match direcly
08:16:22 <stelleg> so instead of f x | x == A = f x
08:16:29 <stelleg> sorry
08:16:42 <stelleg> g x | x == A = f x -> g A = f A
08:17:25 <stelleg> where a -> b in that context means replace a with b
08:17:32 <stelleg> not the haskell ->
08:17:46 <nrnrnr> I'm trying to find one of the many estimates of how many people have downloaded the Haskell Platform (or other implementation of Haskell)
08:17:51 <nrnrnr> Any idea where to look?
08:20:17 <nrnrnr> hmmm.  quiet here today :-(
08:20:43 * hackagebot Win32-services 0.2.5.1 - Windows service applications  http://hackage.haskell.org/package/Win32-services-0.2.5.1 (MichaelSteele)
08:21:24 <nrnrnr> nobody here but us bots :-(
08:23:45 <nrnrnr> +npt
08:26:18 <merijn> nrnrnr: I'm not sure that's being tracked
08:28:02 <nrnrnr> merijn: I've seen various graphs and slides in particular talks
08:28:25 <nrnrnr> merijn: maybe I need to ask Gershom B
08:29:43 <Ryanar> I am trying to write a function that matches the first occurrence of an element in a list and drops it from the list, appending it to the front, ex foo 3 [1,2,3,4] -> [3,1,2,4]. I am running into the problem where I recurse through the list, find the match, and I can drop it, but I have no idea how to return it back out to get appended to the front of the list because it is buried in recursion by that point
08:30:42 <xplat> Ryanar: use a tuple
08:31:02 <xplat> Ryanar: and a helper function
08:31:13 <Redz> or tuple only. 
08:31:41 <Ryanar> xplat I thought about a tuple but it seemed like the same problem, hm let me play with that idea
08:32:20 <xplat> Redz: no, returning a tuple means you need a wrapper to stick the 3 on the front
08:33:47 <Redz> mom. i wrote this function somewhere. *search*
08:33:51 <Redz> *mom = moment
08:34:43 <xplat> moooooom, Ryanar is writing functions i already wrote!  make him stop!
08:36:05 <Redz> :D
08:37:11 <Ryanar> man I just dont see how to do this
08:38:09 <Ryanar> actually...
08:38:41 <Redz> hm funny. didn't i said lpaste to post it here?
08:39:06 <Redz> http://lpaste.net/130033
08:39:28 <Ryanar> I haven't lpasted anything because nothing is coherent in what I have wrote yet haha
08:39:31 <xplat> well, first write a function 'bar' that if you call 'bar x ys' it will find the first one of ys equal to x and return (x',ys'), with ys' = ys with x' left out
08:39:43 <xplat> then use 'bar' to write 'foo'
08:41:15 <xplat> (this technique is called the 'worker-wrapper transformation')
08:42:14 <jophish> Ryanar: something like this: http://lpaste.net/130035
08:43:01 <jophish> (I've not checked that this works or anything, but it might be a start)
08:43:43 <Redz> i always recommend to supply a predicate instead of a value.
08:44:36 <jophish> although I'd probably replace break with something else :: (a -> Bool) -> [a] -> Either [a] ([a], a, [a])
08:50:48 <jellie> :t parseJSON
08:50:49 <lambdabot> Not in scope: ‘parseJSON’
08:57:40 <allyraza> hello everyone 
08:58:18 <allyraza> I am learning haskell now for the 3rd time tried like twice already and failed 
08:58:47 <Welkin> what does that mean?
08:58:51 <ackthet> try #haskell-beginners
08:58:52 <allyraza> now I am stuck on types can't make sense of types and type classes 
08:58:54 <Welkin> there is no failure in learning
08:59:01 <Welkin> you just do it...
08:59:17 <Welkin> allyraza: I recommend the Typeclassopedia
08:59:23 <Welkin> @where typeclassopedia
08:59:23 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
08:59:35 <merijn> allyraza: If it's any consolation, haskell didn't stick until my 3rd attempt either :)
08:59:48 <merijn> I think typeclassopedia might be a bit too advanced as a starting point
08:59:58 <narendraj9> merijn: I second this.
09:00:09 <Welkin> hm, I suppose the upenn course would be better
09:00:11 <merijn> allyraza: Can you give some idea on where you get stuck/where things stop making sense?
09:00:15 <Welkin> @where learnhaskell
09:00:15 <lambdabot> https://github.com/bitemyapp/learnhaskell
09:00:37 <narendraj9> allyraza: I think Brent Yorgey's course would be best. That's what the learnhaskell guide recommends.
09:00:42 <allyraza> basically what I understood from my readings types are like interfaces and then you define functions to work with types 
09:00:59 <Welkin> you mean type classes?
09:01:35 <allyraza> Welkin: data Color = Red | Blue | Green
09:01:48 <allyraza> thats one
09:02:11 <merijn> allyraza: Right, so that defines a type "Color", which has 3 possible values, "Red", "Blue" and "Green"
09:02:39 <allyraza> okay where does the value come from 
09:02:39 <narendraj9> allyraza: Yes think of type-classes as another organizing methodology. Initially you had types and you said two values had the same type when they looked similar in some sense. Now you are organzing types into classes based on your ability to define certain functions on them.
09:02:59 <haskell217> Hey guys, can you take a look at this for me? http://lpaste.net/130037
09:03:04 <haskell217> I wrote the errors on the bottom
09:03:07 <merijn> allyraza: Typeclasses specify a set of values (usually functions, but not always), often with some set of laws (i.e. guaranteed behaviour). The instance of a typeclass then specificies the implementation of those values for one specific type
09:03:44 <Welkin> allyraza: that is a Type named `Color` with Data Constructors for `Red`, `Blue`, and `Green`, none of which take any parameters
09:03:47 <merijn> haskell217: Line 6 and line 12 you use DBInteger and DBText in the type signature, but those aren't types
09:03:47 <allyraza> I declared them as more like Constants they are not strings 
09:04:02 <merijn> haskell217: Oh...they are, but you've shadowed them...
09:04:38 <geekosaur> haskell217, your type DBText declares two nullary constructors with the same name as your types
09:05:12 <merijn> allyraza: Due to the lack of mutation in haskell, everything is effectively a constant :)
09:05:46 * hackagebot eventstore 0.7.0.1 - EventStore TCP Client  http://hackage.haskell.org/package/eventstore-0.7.0.1 (YorickLaupa)
09:05:48 <allyraza> merijn: I am having hard time to grasp this concept 
09:05:49 <geekosaur> all types require constructors. perhaps you were looking for something like: data DBFieldType = DBFInteger DBInteger | DBFText DBText
09:05:56 <bennofs> For new libraries, should I try to support GHC 7.6 ?
09:06:07 <merijn> bennofs: Depends on whether you care
09:06:18 <merijn> bennofs: I think supporting only 7.8 or 7.10 for new libraries is fine
09:06:21 <haskell217> :geekosaur Can I get an elaboration on nullary constructors
09:06:27 <bennofs> Heh. The question is: should I care? How many are still using GHC 7.6?
09:06:29 <allyraza> in more imperative languages we declare a const and then give it a value either string, int, or bool 
09:06:42 <allyraza> most*
09:07:06 <geekosaur> haskell217: data Color = Red | Green | Blue --- three nullary constructors. think enumerations in other languages
09:07:30 <merijn> allyraza: Right, in haskell every declaration is *always* const :)
09:07:37 <haskell217> ah okay. So I need to change DBText constructor names?
09:07:39 <geekosaur> now take a look at what I said at "all types require constructors..."
09:08:04 <geekosaur> haskell217, all types require constructors. perhaps you were looking for something like: data DBFieldType = DBFInteger DBInteger | DBFText DBText
09:08:29 <haskell217> ah.
09:08:30 <geekosaur> haskell217, compare: data Maybe a = Nothing | Just a
09:09:20 <haskell217> so data use those nullary thingies and types use constructors?
09:09:31 <merijn> haskell217: They're all constructors
09:09:39 <merijn> haskell217: Some constructors just don't take arguments
09:09:46 <Welkin> type constructors and data constructors
09:09:54 <geekosaur> haskell217, your case expression then becomes: 
09:09:57 <Welkin> depending on which side of the equal sign they are
09:09:59 <lpaste> geekosaur annotated “No title” with “for haskell217” at http://lpaste.net/130037#a130041
09:10:20 <allyraza> what is the difference between type constructor and data constructor 
09:10:32 <Welkin> type constructors are for types
09:10:32 <haskell217> ah I see. Thanks a lot
09:10:37 <Welkin> data constructors are for data
09:10:42 <geekosaur> data Maybe a = Nothing | Just a -- Maybe is a type constructor; Nothing and Just are data constructors
09:10:46 <merijn> allyraza: A type constructor constructs a type, a data constructor constructs a value :)
09:10:47 * hackagebot hs-inspector 0.2.1.0 - Haskell source code analyzer  http://hackage.haskell.org/package/hs-inspector-0.2.1.0 (flbulgarelli)
09:11:09 <merijn> allyraza: So "Maybe" is a type constructor and when you apply it to another type, like Int, it returns a new type, i.e. "Maybe Int"
09:11:56 <allyraza> merijn: how do we use a data constructor 
09:12:00 <haskell217> Type and Type make a Type? 
09:12:05 <haskell217> But Type needs data constructor?
09:12:12 <merijn> allyraza: By applying it to other values
09:12:14 <haskell217> but you can make types with types?
09:12:33 <merijn> allyraza: For example, applying the 'Just' constructor to a Char like 'c' we get
09:12:36 <merijn> :t Just 'c'
09:12:37 <lambdabot> Maybe Char
09:12:42 <glguy> haskell217: Yes, you can combine types to make types like you can combine values to make values
09:12:44 <merijn> A new value, with type "Maybe Char"
09:12:54 <allyraza> I guess I have to go thru that course 
09:12:59 <merijn> allyraza: I like to use GADTSyntax, because I think it illustrates things more nicely
09:13:12 <allyraza> thank you everyone brb
09:13:28 <allyraza> have plenty of time not going to give up this time 
09:13:43 <merijn> allyraza: "data Maybe a = Nothing | Just a" can (with an extension) be written as: http://lpaste.net/130042
09:14:30 <b_jonas> (good old gadts)
09:14:51 <allyraza> every time I come across some haskell i am like ahh man this is something different its so elegant and beautiful 
09:15:39 <merijn> b_jonas: You can use GADT syntax without GADTs :)
09:15:47 <merijn> b_jonas: -XGADTSyntax :)
09:15:47 * hackagebot stackage-curator 0.7.2 - Tools for curating Stackage bundles  http://hackage.haskell.org/package/stackage-curator-0.7.2 (MichaelSnoyman)
09:15:50 <b_jonas> sure
09:16:09 <b_jonas> oh, you mean there's even a separate switch?
09:16:10 <b_jonas> I see
09:16:33 <JordiGH> I rather miss Python's argparse. What's the nicest way to parse CLI args in Haskell?
09:17:51 <geekosaur> many like optparse-applicative
09:18:36 <jophish> looks good to me: https://twitter.com/aisamanra/status/582678801051717632
09:18:45 <geekosaur> haskell217, not sure what you're asking there
09:19:27 <JordiGH> geekosaur: "many" is too broad for me, which should I use, what's canonical?
09:19:29 <geekosaur> but if you're ignoring the other srtuff in channel, you might want to look at the merijn/allyraza discussion going on at about the same time
09:20:02 <geekosaur> JordiGH, as far as I know there is no blessed one. Haskell is not Python, there is no dictator giving you The One True Library
09:20:27 <JordiGH> geekosaur: There's a Haskell stdlib, isn't there?
09:20:29 <JordiGH> Prelude or whatever?
09:20:32 <JordiGH> That's your dictator.
09:20:59 <JordiGH> It's annoying when you have to distribute software with extra dependencies. If there's no other way but to distribute the dependencies, so be it, but it's nice when there's an stdlib to depend on.
09:21:05 <geekosaur> if that's your criterion then there is no arg parser
09:21:23 <JordiGH> It's not a criterion, it's a desideratum.
09:21:40 <geekosaur> in general we've been trying to get *rid* of stuff, not build the whole ecosystem into the Prelude
09:22:27 <JordiGH> It's a bit annoying when I want to share quick toy programs and I have to say, "oh, btw, first run cabal this and that, and make sure you run it this way, and don't forget to do this other thing. Now you can try out my code."
09:22:31 <jhance> optparse-applicative is pretty nice. But you have the freedom to choose to use whatever you want, nobody is going to be scared away by a dependency here
09:23:00 <jhance> JordiGH: And thats why you're methodology is wrong... all you have to do is put your package on hackage and just ask them to run cabal install...
09:23:19 <JordiGH> jhance: What if I don't want to make my package public?
09:23:28 <JordiGH> What if they've run into cabal hell?
09:23:32 <geekosaur> then why are you worrying about this?
09:23:55 <JordiGH> Because I may want to share my package without making it public; I'm just trying to say, cabal doesn't solve all problems.
09:23:57 <jhance> JordiGH: Then they deal with it because that means their system is borked, its not your problem
09:24:09 <d-snp> eh
09:24:09 <d-snp> no
09:24:16 <d-snp> you don't let users deal with cabal
09:24:21 <d-snp> only developers have to deal with cabal
09:24:22 <JordiGH> jhance: When I want to quickly share code with people who may not be familiar with Haskell, their problems with their Haskell installation become my problem.
09:24:30 <d-snp> you just ship statically compiled libraries to users
09:24:36 <jhance> depends on if you are distributing by source or compiled
09:24:37 <d-snp> you can build those with cabal just fine I think
09:24:45 <JordiGH> d-snp: For all operating systems?
09:24:50 <d-snp> JordiGH: yes
09:24:54 <JordiGH> Does Haskell compile to bytecode?
09:24:59 <jhance> No it compiles to textcode
09:25:00 <d-snp> no, it's aot
09:25:01 <geekosaur> the Platform was tried, key members of the user community decided the concept was Evil because they couldn't do whatever they wanted, they had to stick to a standard library
09:25:12 <d-snp> well
09:25:21 <d-snp> oh no, it's JIT I mean
09:25:40 <d-snp> but you can just vendor all your dependencies
09:25:44 <d-snp> and only depend on the GHC
09:25:57 <JordiGH> Which is easy to install on Windows, right?
09:26:03 <d-snp> yes
09:26:04 <jhance> ^ and then you are doing it wrong because you shouldn't have to vendor dependencies, thats up for the dependency manager. You only do that for distributing for Windows users
09:26:16 <d-snp> but, you shouldn't ship bytecode to windows
09:26:22 <d-snp> unless you're marketing to developers
09:26:35 <geekosaur> waut, what?
09:26:43 <geekosaur> haskell compiles to native code
09:26:54 <geekosaur> ghci compiles to bytecode but does not save or load it
09:26:58 <d-snp> ohh ok
09:27:04 <jhance> I'm not even sure what we mean by bytecode, everything past the text-phase is binary
09:27:08 * dgpratt us confused by all this discussion of byte code
09:27:14 <dgpratt> *is
09:27:33 <jhance> the actual executable is the GHC RTS which then runs the program, but its totally all native
09:27:35 <d-snp> geekosaur: but the compiled code still has a dependency on GHC right? that's what confused me
09:27:42 <jhance> no.
09:28:04 <d-snp> ok
09:28:15 <geekosaur> only if you have a build that makes the runtime a shared library
09:28:26 <geekosaur> and even then you just need that shared library, not all of GHC
09:29:36 <dmj`> bitemyapp: ping
09:30:00 <d-snp> alright sorry for spreading misinformation, I was obviously confused
09:30:23 <d-snp> JordiGH: disregard everything I said, geekosaur corrected me :)
09:30:30 <dgpratt> I have been wondering if a bytecode/JIT scheme (a la JV or CLR) would be useful for Haskell, but so far as I can tell I am the only one who ponders such things
09:31:01 <dgpratt> which probably means it wouldn't be as useful as I imagine it might be
09:31:59 <geekosaur> people do ponder it; IIRC there's an implementable for buffing the bytecode backend somewher in ghc's ticketing system, but nobody has time+interest+knowledge to do anything about it...
09:33:33 <JordiGH> Alright, now what? http://codepad.org/nZNYwMxt
09:34:50 <dgpratt> it's one of those frustrating situations where I certainly have interest, but no time and even less knowledge to pursue it
09:35:09 <dgpratt> my programmer life seems full of such things, actually
09:35:39 <JordiGH> I wonder why cabal tried to get version 0.8. I see version 0.11 in the Debian repos in unstable, but I'm using stable.
09:35:43 <JordiGH> Yay, dependencies.
09:35:49 * hackagebot pseudo-trie 0.0.3 - A tagged rose-tree with short circuited unique leaves  http://hackage.haskell.org/package/pseudo-trie-0.0.3 (athanclark)
09:36:11 <jhance> JordiGH: Wouldn't be a problem if you were sandboxing.
09:36:29 <JordiGH> Ah, right, cabal is not wrong, the user is wrong. What did the user do wrong?
09:36:39 <d-snp> yeah, JordiGH research 'cabal sandbox' it solves a bunch of this pain
09:36:47 <jhance> The user tried to install all of his dependencies globally.
09:36:47 <JordiGH> It's SLFE, right?
09:37:06 <d-snp> no, the user didn't anything wrong, cabal is wrong for installing stuff globally per default
09:37:25 <jhance> what is it supposed to do? randomly guess which sandbox to install to?
09:37:28 <jellie> Why would this type hole fail to work: parseJSON :: FromJSON _t => Value -> Parser _t ?
09:37:34 <d-snp> cabal is a bit old, installing stuff locally is something we discovered only in recent years is a good idea
09:37:49 <d-snp> jhance: it should alert the user a sandbox doesn't install yet, and create one :P
09:37:54 <JordiGH> I have no installed anything with cabal so far.
09:37:59 <d-snp> i.e. do whatever bundler does
09:38:09 <JordiGH> I suppose the next thing you'll tell me is that Debian is wrong for attempting to package Haskell packages.
09:38:25 <jhance> JordiGH: Did you cabal update?
09:38:37 <d-snp> JordiGH: no, it's haskell platform that comes with cabal stuff
09:38:37 <JordiGH> jhance: Doing that now.
09:38:54 <jellie> What is the "a" in `parseJSON :: FromJSON a => Value -> Parser a` supposed to be?
09:39:06 <jhance> jellie: The data type that you are parsing from JSON
09:39:15 <JordiGH> How old is optparse-applicative, btw? By the version number, I get the impression it's a young package.
09:39:24 <johnw> it's not terribly old
09:39:26 <jhance> JordiGH: 0.11 indicates young?
09:39:31 <johnw> it grew out of the paper on free applicatives
09:39:37 <JordiGH> jhance: It indicates "not production-ready", yes.
09:39:55 <JordiGH> Haskell in general still seems so "young", with fundamental things like monads being applicative functors being done only recently.
09:39:56 <jhance> JordiGH: No it doesn't. Thats not how the version numbers work here.
09:40:09 <JordiGH> jhance: How do version numbers work, everyone defines whatever they want?
09:40:24 <johnw> JordiGH: 0.0.0.1 is sometimes an indicator of not production ready :)
09:40:26 <jhance> JordiGH: The MINOR number defines incompatibilities. The MAJOR number is rarely incremented.
09:40:36 <jellie> jhance: Say I'm writing a FromJSON instance of a type called Definition with constructor definition :: Text. will the a in this case would be Definition or Text?
09:40:39 <Welkin> JordiGH: haskell has been around for 25 years
09:40:42 <JordiGH> jhance: And "1.0" doesn't mean "okay, this thing is out of beta"?
09:40:52 <JordiGH> Welkin: And yet seems young and barely learning things.
09:41:00 <johnw> barely learning things?
09:41:01 <jhance> JordiGH: 1.0 doesn't mean beta in general on hackage.
09:41:06 <jhance> Err, 0.x doesn't mean beta
09:41:25 <jellie> jhance: Because if a is Definition how will that work yet I am just then making Definition an instance of FromJSON
09:41:25 <JordiGH> johnw: Like how to do a package manager. I don't know why it takes each programming language such a long time to learn how to do packages.
09:41:44 <Welkin> a programming language cannot learn since it is not a being with agency
09:41:48 <JordiGH> jhance: "0.x" is supposed to mean beta according to semantic versioning. What does it mean in Haskell?
09:41:49 <jhance> jellie: a is Definition and you can use the text instancce of FromJSON to make it
09:41:52 <d-snp> because packaging for developers is not a simple thing
09:41:56 <johnw> JordiGH: Haskell was a research language created to study programming languages, not to study package management
09:42:02 <d-snp> it's only been solved a few years (like <5) ago
09:42:12 <jhance> The package management system works fine for me, although its in a bit of turmoil from the 7.10 stuff
09:42:38 <JordiGH> johnw: Or having a (de-facto) standard package for CLI parsing or mutable vectors. This is such a fundamental thing that I can't believe it's relayed to experimental new packages.
09:43:17 <JordiGH> johnw: Sure, Haskell is learning. But it still gives me the impression of being young. Having a small userbase no doubt contributes to this impression of "youth".
09:43:36 <d-snp> JordiGH: everything in haskell has been bleedingg edge and experimental for 25 years
09:43:41 <d-snp> it's intentional
09:43:48 <jellie> jhance: That doesn't work. Let me give you a paste
09:43:51 <JordiGH> d-snp: So that everything breaks all the time?
09:43:54 <d-snp> yes
09:44:12 <d-snp> whenever something is new and cool and shown to be better, the old stuff is dumped or left unmaintained and the community moves on
09:44:24 <jellie> jhance: http://lpaste.net/762075147048845312
09:44:24 <johnw> JordiGH: yes, our aim is not industry-perceived maturity :)
09:44:38 <JordiGH> d-snp: Sure, that happens with every programming language, but after a while clear winners arise.
09:44:43 <d-snp> no
09:44:43 <johnw> Java is younger than Haskell, but with a very different focus
09:44:53 <jellie> and it can't because at that very time I am making NowPlaying an instance of FromJSON
09:45:13 <d-snp> Haskell has fundamentally changed a number of times, its whole I/O model was not fixed for a decade
09:45:16 <dmj`> bitemyapp: ping
09:45:35 <jhance> Why does there have to be a de-facto package for everything?
09:45:39 <jhance> Can't you just pick what you like?
09:45:40 <d-snp> that means opening a file in Haskell 1.0 is totally different from opening a file in Haskell 7.0
09:45:49 * hackagebot hquantlib 0.0.2.5 - HQuantLib is a port of essencial parts of QuantLib to Haskell  http://hackage.haskell.org/package/hquantlib-0.0.2.5 (PavelRyzhov)
09:46:16 <JordiGH> jhance: Because I don't write code just for myself. I write it for other people. If it's a constantly changing Tower of Babel, it inhibits communication and collaboration with other people.
09:46:23 <jellie> jhance: Did you see what I was talking about?
09:46:38 <d-snp> JordiGH: there's an idea that Haskell intentionally avoids to be production ready, so that it never has the responsibility to provide backwards compatability
09:46:39 <jhance> jellie: I took a look but I'm also doing homework, I'd need the compile error to help me i think
09:46:49 <d-snp> JordiGH: i.e. it always stays small enough to fail ;)
09:47:08 <jhance> JordiGH: There can be two different packages and that doesn't mean that you have to change from one to the toher
09:47:10 <d-snp> that plan is failing a bit, as Haskell has been picking up quite a popularity
09:47:31 <jhance> JordiGH: Again, we give you the freedom of choice. We don't _make_ you choose a particular library by shoving it into Prelude
09:48:14 <jellie> jhance: Okay I have removed irrelevant material for it to make sense. http://lpaste.net/762075147048845312
09:48:15 <JordiGH> jhance: Recommend one library by putting it in Prelude and let dissenters host their own libraries in Hackage.
09:48:23 <Welkin> JordiGH: it's pretty easy to update your codebase for changes in libraries or the language standard
09:48:34 <JordiGH> Welkin: Okay, how do I do it? http://codepad.org/nZNYwMxt
09:48:50 <Welkin> JordiGH: let the compiler do it for you
09:48:58 <JordiGH> Welkin: What should I tell the compiler to do?
09:49:07 <JordiGH> It's very easy. Show me how easy it is.
09:49:18 <d-snp> >_> tell it to sandbox..
09:49:26 <d-snp> cabal sandbox init .
09:49:30 <d-snp> cabal install
09:49:41 <JordiGH> cabal: unrecognised command: sandbox (try --help)
09:49:42 <d-snp> it'll work I'm 68% sure
09:49:46 <JordiGH> What should I do now?
09:49:52 <d-snp> ok 12% now :P
09:50:30 <d-snp> you have an outdated cabal
09:50:36 <d-snp> as in one that's a year old or something
09:50:46 <JordiGH> Wow, one year is too old.
09:50:47 <JordiGH> Okay.
09:50:50 <JordiGH> How do I fix it?
09:50:52 <JordiGH> Throw out my OS?
09:51:00 <JordiGH> Bootstrap ghc from sources?
09:51:02 <d-snp> :D well you are running *debian*
09:51:03 <JordiGH> So easy!
09:51:16 <Welkin> JordiGH: it does export `columns` http://hackage.haskell.org/package/ansi-wl-pprint-0.6.7.2/docs/Text-PrettyPrint-ANSI-Leijen.html
09:51:17 <JordiGH> Blame me, blame the user. Even eaier!
09:51:22 <d-snp> cabal update; cabal install cabal-install
09:51:23 <d-snp> I think
09:51:52 <d-snp> it's possible you have to add ~/.cabal/bin or something to your path after that
09:51:55 <JordiGH> d-snp: Okay, that seems to be working.
09:52:04 <Welkin> JordiGH: what do you hope to accomplish by whining about it here?
09:52:10 <d-snp> verify that cabal --version is working
09:52:12 <d-snp> Welkin: dont be rude
09:52:19 <JordiGH> Welkin: To get a CLI arg parsing library.
09:52:35 <d-snp> this is the best place to whine about Haskell
09:52:47 <d-snp> the guys who are making it are lurking here after all ;)
09:53:10 <Welkin> d-snp: it is not rude to point out that someone is being unconstructive
09:53:25 <JordiGH> Welkin: I am just disappointed by your description of "easy".
09:53:30 <JordiGH> I wanted to believe.
09:53:35 <JordiGH> But it doesn't seem easy so far.
09:53:40 <jhance> We have multiple CLI line parsing libraries
09:53:46 <Welkin> nothing is easy until you have done it
09:53:52 <JordiGH> jhance: And which one do you recommend?
09:53:53 <jhance> And I highly doubt anyone will place one in Prelude because someone on IRC complained about it
09:54:23 <jhance> And for the record, I personally do use a bootstrapped ghc from sources...
09:54:32 <d-snp> maybe someone will make a ticket because people on irc complained? :P
09:54:53 <jhance> You want your own arg parser? getArgs gives you a [String], go parse it
09:54:53 <jle`> what the heck is even going on here
09:55:13 <JordiGH> jhance: I don't want my own parser. As a Haskell learner, I want to know what's recommended.
09:55:23 <JordiGH> Do you recommend I write my own parser instead of using a library?
09:55:26 <jhance> JordiGH: optparse-applicative is good.
09:55:41 <JordiGH> Okay, so there seems to be consensus that it's good. I believe at least three people have said.
09:55:46 <glguy> JordiGH: System.Console.GetOpti is a fine starting point
09:55:47 <JordiGH> Why not giving it an official recommendation, then?
09:55:49 <jellie> JordiGH: Which OS are you on?
09:55:52 <JordiGH> jellie: Debian.
09:56:06 <jhance> If its good enough for bos its good enough for me
09:56:06 <jellie> Oh man the debain packages are super old
09:56:20 <glguy> jellie: That's a feature of Debian
09:56:23 <JordiGH> d-snp: It appears that your recommendation to do `cabal install cabal-install` is bootstrapping ghc.
09:56:29 <d-snp> awesome
09:56:31 <jellie> JordiGH: Yeah you should probably get rid of it.
09:56:37 <JordiGH> jellie: Get rid of Debian?
09:56:47 <jellie> glguy: Their version of cabal has no sandboxes
09:56:49 <d-snp> well yeah, no sane person would use debian as a development environment :P
09:56:49 <JordiGH> jellie: I am not going to get rid of my OS for a niche programming language.
09:56:51 <jellie> JordiGH: Yes
09:57:02 <JordiGH> jellie: Debian and stability is more important than Haskell.
09:57:10 <jellie> JordiGH: Well I bet the version of git on Debian doesn't even support https
09:57:15 <JordiGH> jellie: Of course it does.
09:57:17 <d-snp> :D
09:57:31 <jellie> JordiGH: There's a difference between stability and being outdated
09:57:38 <JordiGH> d-snp: I have been using Debian stable as my development environment for 12 years.
09:57:47 <d-snp> damn
09:58:03 <d-snp> debian has always used too old packages for my taste
09:58:10 <glguy> The outdatedness of Debian is offtopic for #haskell
09:58:13 <Luke> Anyone know what this is on OS X? "ld: warning: directory not found for option '-L/private/tmp/ghc20150402-41611-1b15z9c/ghc-7.10.1/gmp-static'"
09:58:14 <jhance> JordiGH: https support has been in git for ages now...
09:58:25 <jellie> JordiGH: I once used debian that had a version of git that didn't support SSL/https like 1 year ago. Something that was in arch repos for years.
09:58:25 <JordiGH> jhance: Yes, and so it is in Debian.
09:58:35 <JordiGH> jellie: csb
09:58:59 <JordiGH> Anyways, lunch, ttyl, maybe when I come back I'll have a new ghc and I'll throw out Debian's. I'm sure that will please you mightily.
09:59:06 <realitygrill> a friend of mine is trying to load a simple quicksort (from LYAH) into ghci and is getting a parse error
09:59:13 <d-snp> JordiGH: verify that cabal --version changes after the installation is done
09:59:19 <realitygrill> ..is Windows' carriage-return a problem with ghc?
09:59:21 <d-snp> if it hasn't, you need to find out where it installed all its goodies
09:59:25 <d-snp> and add that to path
10:00:58 <Lis> hello everyone. if i have a function which does foo bar = putStrLn bar and execute it in another function with let bla = foo "baz" why doesnt haskell show me the "baz" ? only if i use bla <- foo "baz" it works
10:01:29 <sm> AFAIK the debian-haskell group is very active and effective, what's the problem with haskell on debian ?
10:01:30 <jhance> Lis: the IO isn't executed if you do let bla = ..., its just storing that "action" into bla for future use which does nothing
10:01:39 <dgpratt> realitygrill, I have not experienced any such issues
10:01:42 <jhance> sm: user error.
10:01:43 <Lis> aaaah ok thank you :D
10:02:00 <realitygrill> dgpratt: just found the problem. tabs vs spaces issues..
10:02:05 <realitygrill> thanks
10:02:09 <dgpratt> realitygrill, that was my next guess :)
10:02:15 <Lis> so let is something like "execute at runtime" ?
10:02:31 <realitygrill> dgpratt: haha. not sure why i didn't think of it til now
10:02:48 <dgpratt> Lis, let is just "assign name to expression"
10:02:49 <quchen> Lis: Look at the types. When you write `let foo = putStrLn "hello"`, then `foo :: IO ()`, so foo is a program that does something. On the other hand, when you write `foo <- putStrLn "hello"`, then `foo :: ()`, so something happened with your putStrLn IO action on the RHS.
10:03:21 <Lis> ok thank you
10:04:07 <Luke> where does ghc get it's linker locations?
10:04:16 <sm> JordiGH: since I haven't seen this mentioned yet: System.Console.GetOpt is the simple args parser that's always available (included in base). For a more powerful, there are two leaders: optparse-applicative (favoured by mathematically-minded haskellers, but undocumented) and cmdargs (your best option IMHO)
10:04:30 <Luke> or I should say where does ghc get it's library search path?
10:04:41 <johnw> JordiGH: you said "Haskell is learning", as though we are immature and just becoming ready for production use.  I'd flip that and say that other, "mature" languages mainly stopped learning, and their production readiness is somewhat specious when you look at how many bugs they allow that Haskell makes impossible (null pointers, anyone?).  Haskell can achieve quite a lot today at production quality, you just need to know more.
10:05:20 <Welkin> I have a production haskell application that has been running for almost 4 months nonstop
10:05:48 <narendraj9> Welkin: What's the application? :) That's cool.
10:05:50 <johnw> the first Haskell app I ever wrote I still use regularly, and I haven't modified the code since then
10:05:50 * hackagebot cabal-lenses 0.4.5 - Lenses and traversals for the Cabal library.  http://hackage.haskell.org/package/cabal-lenses-0.4.5 (DanielTrstenjak)
10:05:54 <Welkin> a yesod app
10:05:59 <johnw> mine is http://hackage.haskell.org/package/una
10:06:23 <quchen> I don't even think you need to know more. You can happily code away with basic haskell the same way some people happily code Java. The difference is that Haskell leaves a lot of room for discovery compared to the mainstream languages, so I'd say the ceiling is just a lot higher.
10:07:03 <johnw> quchen: I meant "know more" in the sense of getting a larger team to successful collaborate on and deploy a Haskell application.  It's not quite as easy as Maven and JBoss, for example.
10:07:24 <johnw> if it's just one person writing a Haskell app, there's not as much difference
10:07:34 <athan> Is there a way to force quickcheck to show the examples of a failure that causes a runtime exception?
10:08:18 <jhance> quchen: It is problematic though if you have a basic-person and an advanced-person on the same codebase, because then the basic-person might not understand some of the wonky stuff the advanced person does
10:08:46 <jhance> and I wouldn't agree that maven is "easy'
10:09:18 <Lis> how can i dump a definition in haskell?
10:09:38 <quchen> jhance: I agree, Haskell suffers a bit from having different levels of code.
10:09:53 <quchen> Lis: show?
10:10:18 <tsahyt> jhance: I'd say that as a *language*, Haskell is actually incredibly simple when you don't take GHC extensions into account. It's the libraries and their design that are hard to grok sometimes.
10:10:43 <Lis> quchen, expected type: IO Char actual type: String
10:10:57 <quchen> What is the source code? What do you want to do? What have you tried? What did your attempts amount to? What do you think was wrong? 
10:11:05 <Lis> and Couldn't match type `[]' with `IO'
10:11:58 <d-snp> I think the bigger problem for newbies is more with the ecosystem and the way the community communicates
10:12:02 <whittle> athan: How are you running QuickCheck? 
10:12:16 <athan> whittle: With the hspec wrapper
10:12:36 <athan> Something like this: https://github.com/athanclark/hi-quickcheck-lib
10:12:40 <d-snp> JordiGH certainly has a point when he wonders what argument parser he should use, in Ruby we have ruby-toolbox.org which solves that problem quite nicely
10:12:41 <whittle> athan: Are you running a test executable, or using `cabal test`? 
10:12:45 <d-snp> perhaps we need that in haskell as well
10:12:51 <athan> whittle: `cabal test` :)
10:12:57 <whittle> athan: Ah. 
10:13:11 <d-snp> and many beginner tutorials don't explain that you really should use cabal sandbox, simply because it's so young
10:13:15 <d-snp> but not using it is very painful
10:13:25 <whittle> athan: It’s a pain, but I usually put an extra stanza in my cabal file that creates a test executable. 
10:13:29 <sm> JordiGH: also, haskell has a stability continuum, not unlike Debian, so you should pick your point of comfort. It looks something like: haskell debian packages .. ubuntu ghc ppa .. haskell platform .. stackage LTS .. stackage nightly .. hackage
10:13:39 <d-snp> so I guess there should be some kind of setup guide on haskell.org itself that explains what the current way of doing things is
10:13:41 <Lis> quchen, http://www.mathematek.de/paste:haskell_dump_show
10:13:42 <whittle> athan: When you run the executable, you get the full output. 
10:13:45 <d-snp> sort of like rubyonrails.org/guides
10:14:02 <athan> hmm, okay, I'll dig around. Thanks whittle
10:14:15 <whittle> athan: Alternatively, `cabal test` should be dumping the output in a log file somewhere. 
10:14:33 <whittle> athan: np
10:14:45 <Lis> oh i forgot the csv parser http://www.mathematek.de/paste:haskell_dump_show
10:17:22 <quchen> Lis: "show" is not an IO action, it's a "to string" converter. If you want to print a string, use putStrLn, giving you `putStrLn (show config)`. There's also a shortcut for this, namely `print`, which is defined as `putStrLn . show`.
10:17:53 <bennofs> d-snp: that is currently under debate. some people recommend haskell platform, some don't
10:18:03 <Luke> Anyone know what this is on OS X? "ld: warning: directory not found for option '-L/private/tmp/ghc20150402-41611-1b15z9c/ghc-7.10.1/gmp-static'" I'm not sure why my ghc is getting this URI for the gmp library
10:18:08 <Lis> thank you quchen 
10:18:57 <quchen> Lis: The usual paste site we use here is lpaste.net, by the way. It features some useful convenience functions, for example it automatically runs HLint over your code.
10:20:50 <Lis> quchen, like can i rightclick -> "send to my site"
10:20:51 * hackagebot filestore 0.6.0.5 - Interface for versioning file stores.  http://hackage.haskell.org/package/filestore-0.6.0.5 (JohnMacFarlane)
10:20:59 <realitygrill> d-snp: seems like a good idea to me
10:21:39 <Lis> quchen, besides i take that pastes for future reference. it's more easy to ornaize it there
10:21:47 <Lis> organize
10:22:22 <quchen> You can use whatever you want as long as it's not bloated with ads (looking at you, pastebin), I was just suggesting lpaste.
10:23:45 <aisqwe> is the sequential order in do notation implemented in compiler or haskell itself?
10:24:14 <tsahyt> aisqwe: As far as I understand it's because of the associativity of >>=
10:24:25 <quchen> aisqwe: It's implemented the same way order is implemented in "f . g . h . j".
10:24:35 <quchen> It's not a compiler thing, it's rooted in the language.
10:25:03 <whittle> Luke: I’m on Yosemite, and I don’t see that dir. However, I’m still on GHC 7.8.4. Other than that, I’m not sure how to help you. 
10:25:14 <bennofs> aisqwe: the only thing about do notation that is implemented in the compiler is its translation to >>= and >>
10:25:31 <Luke> whittle: i'm on OS X beta. I think that's when GMP stopped working. It was broken on 7.8.4 for me so I tried upgrading to 7.10.1
10:25:42 <Luke> whittle: I think the issue is with OS X/Xcode
10:25:47 <Luke> though I'm not sure how to debug this
10:26:05 <aisqwe> is there any `seq` in >>= implementation then!?
10:26:20 <whittle> Luke: Did you use brew for GHC and GMP? 
10:26:31 <Luke> yes
10:26:38 <Lis> aisqwe, i think best would be to search in the main ghc repository
10:26:49 <Luke> whittle: when I try to just "gcc test.c -lgmp" it doesn't work either
10:26:51 <Lis> aisqwe, why you ask?
10:27:13 <whittle> Luke: I understand that there have been some clang vs. gcc problems when compiling GHC, but I don’t have much more information than that. 
10:27:36 <quchen> aisqwe: `>>=` and `seq` don't have anything to do with each other.
10:27:39 <aisqwe> Lis: i'm just wondering how the do notation order is implemented if haskell does not enforce execution order
10:27:40 <Luke> whittle: I think I got a binary version of GHC though I think the brew people installed it
10:27:43 <Luke> whittle: *compiled it
10:28:16 <quchen> aisqwe: For Maybe,  Just x >>= f = f x; Nothing >>= _ = Nothing.  That's all there is to it, no further magic.
10:29:02 <Luke> whittle: what's really weird is how the heck is ghc getting that random dir for the GMP locaiton?
10:29:32 <quchen> There is no sense of direction here apart from what the definition gives you. It requires you to investigate the LHS of the >>= to find out which of the two cases to apply, so this gives it a sense of order.
10:30:17 <athan> Are there partial folds? Something where I want to extract some data from a container, and I have a list of containers, but I only want the first one?
10:30:37 <sm> Luke: perhaps reinstalling "ghc" and "gmp" with brew will fix it
10:30:52 * hackagebot basic-prelude 0.3.12 - An enhanced core prelude; a common foundation for alternate preludes.  http://hackage.haskell.org/package/basic-prelude-0.3.12 (MichaelSnoyman)
10:30:52 <bennofs> athan: with foldr, you can "stop" by not using the accumulator
10:31:01 <whittle> aisqwe: I’m not sure if this is the question you’re asking, but do notation doesn’t impose sequential behavior (as viewed from the outside world). The IO monad imposes sequential behavior (as viewed from the outside world) by threading a token through all of its operations, which token represents the state of the outside world. 
10:31:06 <athan> bennofs: I.... I knew that ._.
10:31:10 <athan> thanks!
10:31:14 <quchen> "accumulator" isn't a very good name here, foldr doesn't accumulate anything in it.
10:31:27 <sm> could be related to multiple/incomplete installations
10:31:31 <quchen> It's more of the "rest to do" in the fold.
10:31:32 <bennofs> or should I say ... continuation? :D
10:32:13 <Luke> sm: just tried that. no luck
10:33:02 <athan> quchen: I was thinking about using (), but I can't wrap my head around it
10:33:11 <athan> meh, I'll get it. Thanks guys
10:33:25 <Lis> whittle, he asked weather the keyword "do" is implemented in haskell or in c
10:33:34 <sm> Luke: which ghc says /usr/local/bin/ghc ? ghc --version says 7.10.1 ?
10:33:43 <Luke> yeah
10:34:08 <quchen> > foldr const 0 [1..] -- aborting foldr, athan 
10:34:09 <lambdabot>  1
10:34:20 <Luke> sm: hold on something was cached. when I uninstalled ghc then did install --with-tests now it seems to be running make etc
10:34:28 <Luke> sm: this didn't happen with normal brew install ghc
10:34:29 <athan> ahh! Okay, thank you!
10:34:30 <Lis> whittle like compilers for usually parse the source, then execute a function if a keyword occurs. now the location and implementation of the function which is executed when the compiler reads "do" is what he wanted to know
10:35:40 <Luke> sm: http://lpaste.net/130046 this is happening now
10:35:50 <whittle> Lis: Ah. My bad. Sorry for muddying the waters, aisqwe. 
10:35:53 <Luke> so it looks like some private temp version of gmp that ghc is trying to use
10:36:36 <sm> Luke: it's normal for ghc to keep a bunch of stuff in a tmp directory while it works
10:36:52 <Luke> but it seems it was trying to use it after it was finsihed
10:37:17 <aisqwe> whittle: actually your answer was really helpful, i'm trying to understand what you said from reading the sources right now.
10:37:29 <sm> you could watch (quickly) what's created under /tmp while ghc works, maybe that will give clues
10:38:01 <Luke> sm: I wonder if I somehow had a partial build or something that was getting installed
10:38:17 <Luke> sm: maybe brew had cached the ghc build from source because I definitely didn't see it build before
10:38:32 <sm> so things are working now ?
10:38:41 <Luke> could be. still building
10:38:53 <whittle> Yay! I’m helpful! 
10:38:58 <Luke> haha thanks guys
10:39:13 <Lis> aisqwe, indeed those guys know everything. thats why i asked why you wanted to know it. mostly they can show you a way arround a problem :D
10:39:47 <Luke> sm: does ghc statically link against gmp?
10:40:16 <sm> I think.. it depends
10:40:40 <aisqwe> Lis: i'm having lots of problems understanding how haskell works coming from languages like python, i'm not even sure i'm asking the right questions :D
10:40:51 <Luke> "./configure --prefix=/usr/local/Cellar/ghc/7.10.1 --build=x86_64-apple-darwin --with-gcc=clang --with-gmp-includes=/"
10:40:54 <Luke> looking promising
10:42:45 <Lis> apple stores gmp includes in /?
10:43:30 <Luke> sm: looks like home-brew for ghc does it's own gmp: https://github.com/Homebrew/homebrew/blob/master/Library/Formula/ghc.rb
10:43:37 <quchen> aisqwe: We like to say that you should try to forget everything you know from languages like Python for your first steps, but that's of course not possible. Might still be useful to keep in mind though.
10:43:39 <Luke> doesn't use the home-brew installed gmp
10:43:41 <joneshf-laptop> is there a parsec combinator for floats i'm not seeing?
10:43:45 <athan> Is there a monoid instance for Maybe, where it's content's don't need to be a Monoid also?
10:43:58 <quchen> athan: First/Last
10:43:58 <Xe> I'm trying to install the haskell platform from the tarball in docker
10:44:01 <Xe> https://gist.github.com/Xe/914e0854a702d4242168
10:44:01 <athan> I'm just looking for the `Just a <> Nothing = Just a` behaviour
10:44:03 <quchen> They're newtypes around Maybe
10:44:07 <athan> Thank you quchen :)
10:44:09 <Xe> I feel like I am doing something /really wrong/
10:44:10 <quchen> athan: That would be Data.Monoid.First
10:44:31 <dolio> Technically you can't tell from that one equation. :)
10:44:51 <quchen> dolio: Woops, right.
10:44:59 <aisqwe> quchen: it is hard thinking in haskell, how do i change my mind to think haskelly?
10:45:16 <quchen> aisqwe: It is hard to think in French, how can I change my mind to think Frenchy?
10:45:51 <quchen> I'm learning to type Neo2 right now, so if you stumble upon a way to change the way you do something you've been doing daily for years let me know :-)
10:45:53 * hackagebot filestore 0.6.0.6 - Interface for versioning file stores.  http://hackage.haskell.org/package/filestore-0.6.0.6 (JohnMacFarlane)
10:45:59 <tsahyt> Is using record syntax with sum types considered bad form?
10:45:59 <Lis> aisqwe, what helped me was thinking of a -> b where the "->" is your function transforming a to b
10:46:24 <geekosaur> Xe: it's likely complaining about the /bin/sh part, knowing linux / docker types they decided /bin/bash is the only thing they needed because /bin/sh is legacy nonsense
10:46:32 <Ankhers> Does GHC's garbage collector still stop the world? Where would I be able to find recent information about this?
10:46:35 <geekosaur> portability doesn't matter to them because they're building a new! world!
10:47:46 <JordiGH> Btw, I wanted to publicly declare that EvanR is a great Haskell tutor, and I great appreciate his help from a couple of days ago.
10:47:56 <Lis> aisqwe, so haskell is about decribing the transformation of things, therefore pure functional. where python is generous and can per default use every type to transform to every type
10:49:38 <aisqwe> Lis: may i ask you for what applications you would consider using haskell instead of a language like python?
10:49:54 <Lis> aisqwe, the duct tape of the internet.
10:50:10 <Welkin> aisqwe: everything and anything
10:50:17 <moghedrin> Xe: There's actually an official haskell image, so you only need to use `docker run haskell`. We take care of that for you ;D
10:50:21 <geekosaur> Xe: the other way you could get that faiulure mode is that /bin/sh exists but the "interpreter" in its header (/lib/libc.so.6 or /lib/ld-linux.so or suchlike) doesn't exist, but if that's the case here then you have a bigger problem somewhere
10:50:29 <quchen> Apart from 10-line bash scripts I can't think of a language like python (with borked type systems) I'd use voluntarily.
10:50:48 <bennofs> Does cabal require that I install the matching Cabal library for every GHC version that I use with cabal?
10:50:48 <aisqwe> Lis, Welkin: would you write a mmorgp server in haskell :D?
10:50:52 <tsahyt> I used to like python a lot. Then I discovered type systems.
10:50:56 <Lis> it's so pure epic to build parsers with haskell. or web pages. i use it as scripting language now (lisp was my scripting language before)
10:50:59 <moghedrin> Xe: Might have to pull it first if you've already got a local image tagged as "haskell", though.
10:51:01 <whittle> moghedrin: I didn’t realize there was an official image. That’s great. 
10:51:31 <Welkin> aisqwe: yes
10:51:48 <moghedrin> whittle: IIRC, ghc isn't at 7.10 yet because the haskell debs are borked (or something like that, I'd have to ask tianon over there).
10:51:54 <Lis> aisqwe, there where some dozens mmorpg servers written already. basically everything which transforms stuff to other stuff is perfect to do in haskell
10:52:18 <Welkin> I use it for web apps, shell scripts, video games, and more
10:52:29 <Xe> moghedrin: I realize
10:52:34 <moghedrin> whittle: But other than that, works fabulously.
10:52:38 <moghedrin> Xe: Just double checking ;D
10:52:39 <quchen> ?quote abstract.research
10:52:39 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatics, phone apps, and web services.
10:52:45 <Xe> I have a dotfiles repo that I want to use in conjunction with the haskell compilers
10:53:15 <whittle> moghedrin: That’s super useful to know. 
10:53:18 <aisqwe> Welkin: doesn't laziness get in your way of making video games?
10:53:50 <tsahyt> That quote needs to be expanded. I'm playing with a raytracer written purely in Haskell right now.
10:54:20 <tsahyt> Lis: Transforming stuff into other stuff is general enough to encompass literally everything
10:54:52 <moghedrin> whittle: You're welcome *polishes 'Official images maintainer bage proudly* ;D
10:55:09 <moghedrin> s/bage/badge
10:55:12 <Xe> moghedrin: I find it easier to just tack things on my existing docker image than reinvent the wheel with my vim setup
10:55:27 <Xe> that and the version of cabal debian ships with is too ancient
10:55:46 <whittle> moghedrin: If #haskell had barnstars, I’d vote for you. 
10:57:30 <sm> aisqwe: sometimes, so then you control it
10:59:51 <moghedrin> Xe: As far as Vim setup, I usually just put my project in a volume so that I can edit with vim on my local machine and just run everthing inside the container. But yeah, the debian packages are old. It makes me sad. *sigh*
10:59:55 <moghedrin> whittle: <3
11:01:52 <dolio> It seems to me people tend to have weird ideas about what is necessary to make video games these days.
11:01:58 <dolio> Not that I know much about the topic.
11:03:03 <sellers> Circuit design? Well.. today I learned about Lava
11:03:05 <sellers> very cool
11:03:23 <moghedrin> sellers: Or hot? ;D
11:04:43 <sellers> moghedrin: http://instantrimshot.com/
11:04:50 <lpaste> ryanar pasted “why cant I call approxFromPowSe 5 piPowSeD” at http://lpaste.net/1535632820444069888
11:05:18 <whittle> aisqwe: I was writing some performance-sensitive server-y stuff and found that laziness did sometimes cause me some problems, yes. But I’m still finding that non-strictness allows me to avoid so many contortions in how I structure code in other languages that it’s amazing. 
11:05:54 * hackagebot api-builder 0.6.0.0 - Library for easily building REST API wrappers in Haskell  http://hackage.haskell.org/package/api-builder-0.6.0.0 (Intolerable)
11:06:54 <sellers> whittle: Out of curiosity, do you have a simple specific example?
11:07:04 <sellers> just something you can describe in a line or two?
11:07:09 <whittle> sellers: Of which? 
11:07:38 <whittle> sellers: Problems or contortions? 
11:07:55 <sellers> whittle: contortions that you could avoid
11:08:22 <sellers> whittle: I'm asking as a Haskell newcomer :)
11:09:22 <whittle> sellers: The biggest thing has probably been macros. In Lisp or Ruby, I spent a lot of time writing code that wrote code. Haskell has Template Haskell, which allows you to do that, but most of the time non-strictness and higher-order kinds make it totally unnecessary. 
11:11:30 <caconym> whittle, sellers I'd agree with that.. i unfortunately do a lot of ruby programming and you often find yourself needing to do weird metaprogramming stuff, where haskell gives you tools to avoid doing that
11:12:10 <caconym> whittle, sellers for instance, in ruby doing a DSL can be a bunch of dangerous and dirty metaprogramming tricks; in haskell, you can just build a monad transformer stack to suit your needs
11:12:44 <whittle> sellers: What primary language(s) are you coming from? 
11:12:46 <quchen> You can even build a stack of actions that aren't specific to any monad and then later evaluate it in a special case.
11:12:59 <quchen> (i.e. the free monad approach)
11:13:55 <sellers> whittle: python and (shudder) c++, but I'm not a particularly serious coder.  I just do things for my own personal enjoyment mostly
11:14:56 <hiptobecubic> sellers, I code python all day and I'm pretty annoyed with it now :(
11:15:18 <hiptobecubic> I find that I can get something off the ground and crashing earlier, but something working later.
11:15:19 <caconym> sellers: if you're in it for personal enjoyment, you'll probably find that learning and using haskell is incredibly satisfying intellectually
11:15:56 <hiptobecubic> Unfortunately most of the tools I need are not really available in Haskell with any ease.
11:17:14 <whittle> sellers: Just a guess, but for you the biggest win in Haskell might be the docs. Once you have a basic grasp of data declarations and Haskell’s typeclasses, you can take a look at almost any Haskell library in Hackage and immediately know how to put many of the pieces together. 
11:17:51 <sellers> hiptobecubic: Yeah, for simple things python is really nice, but the duck-typing gets me in trouble when things get more complex.  I think part of it is that I'm used to static typing (I learned c++ first) and so I didn't develop the right habits for writing python efficiently.  But anyway, that's not really haskell-relevant so I'll shut up about it
11:18:38 <sellers> whittle: I already have a bash function for searching hoogle.  The docs are really, really nice.
11:19:50 <caconym> yeah, the docs are very good and using them is a somewhat different experience from other languages
11:20:11 <whittle> sellers: After using Haskell, what makes me mad about other languages is having to read the source code to have any idea what guarantees libraries do or don’t make. 
11:20:14 <caconym> i always kinda feel like the program i want to write is already out there and i just have to put the pieces together, like lego
11:20:38 <caconym> in other languages it's like ok wtf does this function return? a string? i'm gonna have to boot up a repl and find out
11:20:46 <caconym> that's dumb
11:22:03 <bmuk> Hey everyone; I'm trying to figure out if the problem I'm working on lends itself to a fold implementation
11:22:24 <whittle> There are problems that don’t lend themselves to fold implementations? 
11:23:10 <bmuk> lol
11:23:15 <bmuk> :t fold
11:23:16 <lambdabot> (Foldable t, Monoid m) => t m -> m
11:23:16 <sellers> You're technically right, but readability :(
11:23:22 <bmuk> :t foldl
11:23:23 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
11:23:43 <_d0t> hmm
11:23:45 <_d0t> :t fold1
11:23:46 <lambdabot>     Not in scope: ‘fold1’
11:23:46 <lambdabot>     Perhaps you meant one of these:
11:23:46 <lambdabot>       ‘foldl’ (imported from Data.List),
11:23:49 <bmuk> I haven't actually written any code yet, I'm just designing the algorithm
11:23:50 <_d0t> damn
11:24:29 <bmuk> I receive a set of unique URLs
11:24:34 <Welkin> _d0t: you mean foldl1?
11:24:39 <Welkin> :t foldl1
11:24:40 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
11:25:13 <caconym> :t foldl1'
11:25:14 <lambdabot> (a -> a -> a) -> [a] -> a
11:25:45 <bmuk> I map a function over that set
11:26:22 <bmuk> that takes a depth (number to decrement), a URL, and an empty set
11:26:56 <bmuk> no empty set I don't think
11:27:29 <Welkin> bmuk: what are you trying to do?
11:27:41 <Welkin> to map a function over a set, just use fmap
11:27:42 <quchen> > zipWith [1..] ["url1", "url2", "url3"]
11:27:44 <lambdabot>      Couldn't match expected type ‘[Char] → b → c’
11:27:44 <lambdabot>                  with actual type ‘[Integer]’
11:27:44 <lambdabot>      In the first argument of ‘zipWith’, namely ‘[1 .. ]’
11:27:46 <bmuk> It gets all of the links on the passed in page, then calls itself with each of those links (decrementing depth), until it reaches a call and 0 depth. It then returns a set of all links on that page
11:28:00 <quchen> Eh, zip, not zipWith.
11:28:00 <bmuk> Welkin: that part is what I'm not sure of
11:28:41 <bmuk> I'm thinking this is a simple type of recursion which has been abstracted away for me already (like foldl), but I don't think that foldl works here
11:30:24 <caconym> bmuk: so it's visiting the linked pages down to some depth?
11:30:30 <bmuk> caconym: yes
11:30:48 <bmuk> and once it gets to that depth, it returns the set of links on that page
11:31:10 <caconym> bmuk: seems like a fold in a recursive function could work
11:31:23 <caconym> bmuk: oh hm, maybe i misunderstand
11:31:25 <whittle> bmuk: Maybe I’m too Lispish, but I would just solve that using direct recursion. 
11:31:52 <caconym> bmuk: you only want to return the links at a certain depth, not every link on the way to that depth?
11:32:02 <bmuk> The goal is to crawl out from a page and return a huge set of all pages to a given depth, and then filter out everything that isn't a pdf file
11:32:14 <bmuk> caconym: every link
11:32:35 <caconym> bmuk: so why not have a recursive function whose base case is depth == 0
11:32:38 <bmuk> each link would be a branch in the recursion
11:32:59 <caconym> bmuk: it's called with a url, which it grabs and folds over links, calling itself with depth - 1
11:33:17 <bmuk> caconym: that's what I'm thinking, I was just wondering if there was a way to use functions that already exist
11:33:22 <caconym> bmuk: folding into a set by merging
11:39:04 <newsham> i've got a bunch of stateless marshalling code using Data.Serialize.Get.  I've also got some stateful code using ReaderT Get.  i'm torn between keeping the two separate and interfacing them with lifting functions, or just making everything uniformly use ReaderT Get
11:39:37 <newsham> the latter prob makes the code simpler.. no lifting at the interfaces, but no longer keeps track of which things need to be stateful and which dont.
11:39:39 <bitemyapp> dmj`: yes?
11:39:59 <whittle> bmuk: If you want to do that, it may help to think of it in steps: first you generate a tree-shaped structure like `data Page = Page url [Page]`, then you traverse it, then you fold it. 
11:40:04 <newsham> so ideologically its bothering me a little (would be ideal to keep that info in types, but pragmatically perhaps bad)
11:41:21 <enthropy> newsham: you could have the statless code use   MonadTrans t => (t Get) a
11:41:40 <enthropy> there should be an IdentityT
11:42:00 <nitrix> I feel bad for asking here, because it's not really related to Haskell, but I figured if it has a name and something obvious, you guys would lead me in the right direction, so:
11:42:24 <newsham> entropy: I dont think I can lift all the functions with an arbitrary monad transform. i can def do it for the reader monad.
11:42:46 <nitrix> What I'm trying to do, is create a file format for a very simple block-based device. It breaks your data into chunks of the same size and that's it.
11:42:51 <shachaf> newsham: Isn't the usual solution to define a type class, MonadGet or similar?
11:43:02 <shachaf> So that lifting can happen automatically.
11:43:31 <newsham> I have some functions    (Get a -> Get b)   that I need to lift to (StGet a -> StGet b).
11:43:41 <nitrix> Now, the issue is, currently they are all chained, so appending in the middle of a file, ends up with a chunk mutating, with all the ones before. Similar to haskell Lists.
11:43:51 <shachaf> So you can write MonadGet m => m ... for things that just use Get operations, and (MonadReader s m, MonadGet m) => m ... for things that use both.
11:43:59 <nitrix> How does haskell approach this issue?
11:44:12 <newsham> for reader I can d othis with:     liftF f g = do { st <- ask; lift (f (runReaderT st g)) }
11:44:18 <shachaf> Ah, you're doing something like that.
11:44:24 <newsham> I cant see how I could lift that for a generic monad trans
11:44:35 <shachaf> What's StGet?
11:44:49 <nitrix> Let me rephrase.
11:44:55 <newsham> StGet a = ReaderT st Get a
11:45:27 <newsham> i cant even see how i could possibly liftF for StateT
11:45:32 <nitrix> How would one implement an immutable list that has an amortized cost for modifying the last element?
11:45:36 <newsham> let alone a generic MonadT
11:45:42 <nitrix> Some sort of ordered tree?
11:46:33 <newsham> anyway, wondering if i should ditch idealism and pragmatically make all my getters into StGet even when they dont need the state
11:46:45 <newsham> or if i should fight the good fight and do all the manual heavy lifting
11:50:24 <newsham> (the problem with lifting functions is that the function could be called many times.  for reader it works because the state is immutable.  for State it wouldnt work because the state should be updated and threaded through each invocation)
11:50:54 <whittle> nitrix: You had to ask on the day I don’t have my copy of Okasaki with me. 
11:51:41 <whittle> nitrix: But seriously, isn’t this where FS designers usually start using inodes? 
11:53:04 <newsham> whittle: dont leave home without it :)
11:53:36 <Ryanar> Okasaki?
11:54:06 <whittle> Ryanar: http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
11:54:07 <newsham> ryanar: http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
11:54:24 <whittle> newsham: You owe me a coke. 
11:54:29 <Ryanar> Hahahahaha
11:54:43 <newsham> whittle: you cheated with tab.
11:54:52 <newsham> so i only owe you a Tab cola
11:54:54 <Ryanar> ooooop
11:54:56 <whittle> Hahahahahaha
11:55:17 <Ryanar> that book seems pretty darn cool
11:55:20 <alynn> you know, kids, in a way you're both winners
11:55:23 <whittle> I feel like, given the setting, it should be upgraded to an IRC Cola. 
11:55:30 <newsham> ok, i'm going to make all my getters stateful getters.. you talked me into it! ;)
11:55:32 <Ryanar> I remember Chris Okasaki when I read a paper of his on implement Red-Black trees
11:55:34 <joneshf-laptop> let's say i've got some file i want to parse data from, but the data is in the middle of the file. Is there something in parsec that will skip a whole bunch of lines and then start parsing at a specified point?
11:55:46 <joneshf-laptop> i want to keep position information
11:56:07 <joneshf-laptop> rather than just dropping the lines fromt he file and then parsing
11:57:01 <alynn> joneshf-laptop: I confess I'm not massively familiar with parsec but
11:57:21 <alynn> could you not just have the equivalent of (!'\n'*) '\n' as a nonterminal
11:57:36 <alynn> and parse a few of those followed by what you actually want
11:58:02 <whittle> joneshf-laptop: The way I did that was to create a parser that recognized the parts I was trying to skip, then combine it with the parser for the stuff I want to keep with >> instead of bind. 
11:58:13 <clrnd> is there something like Control.Lens.makeFields in lens-family?
11:58:46 <clrnd> (also: why is family2 not providing type signatures for the generated lenses)
11:59:14 <whittle> joneshf-laptop: Just looked a the package again: looks like you want Test.Parsec.Combinator.skipMany1. 
11:59:41 <RustyShackleford> so I'm writing a chess engine
11:59:55 <RustyShackleford> trying to figure out how to determine castling elligibility
12:00:05 <RustyShackleford> the straightforward way is four bools
12:00:07 <joneshf-laptop> whittle, right, but what am i skipping?
12:00:12 <RustyShackleford> any better ideas?
12:00:32 <joneshf-laptop> whittle, what parser i mean, I don't want to have to encode the rest fo the file format
12:00:45 <alynn> RustyShackleford: have you tried regular expressions?
12:01:01 <RustyShackleford> alynn: how does that fit here?
12:01:27 <alynn> I'm not sure, but I've been programming perl all day
12:01:29 <caconym> nitrix: Data.Sequence comes to mind; I think it uses finger trees
12:02:44 <whittle> joneshf-laptop: I was under the impression that you were skipping a known number of lines. To count lines, you have to count line separator characters. To count line separator characters, you have to scan the file. 
12:03:16 <joneshf-laptop> whittle, ah, no the format can change
12:03:26 <joneshf-laptop> actualyl though, I think I can use `between`
12:07:45 <yukko> hi! what kinds of programs are there for graphically displaying properties of haskell projects, like SourceGraph?
12:08:23 <yukko> id like one to print the package dependency graph, but any others would be appreciated
12:08:34 <athan> ThreadScope (pretty sure)
12:08:39 <athan> oh wait
12:08:40 <athan> sorry
12:09:14 <athan> yukko: You might be able to do something with the output of `cabal --dry-run` :\
12:09:19 <yukko> threadscope sounds interesting!
12:09:37 <RustyShackleford> so I've got a data type with a whole bunch of members
12:09:47 <alynn> joneshf-laptop: there's setPosition in parsec
12:09:48 <RustyShackleford> for testing it, I only need to assign a few of them
12:09:55 <RustyShackleford> is there a way to set the rest to zero?
12:10:02 <RustyShackleford> or some default value?
12:10:06 <alynn> you can tell it you're starting from line whatever that way
12:10:29 <alynn> RustyShackleford: is it a record?
12:11:00 <RustyShackleford> alynn: yeah
12:11:19 <alynn> RustyShackleford: define a default somewhere with defaultValues = MyRecord { ... }
12:11:38 <alynn> then you can use record updates to do defaultValues { changingField = newValue, changingField2 = newValue2 }
12:12:32 <RustyShackleford> alynn: cool. I have one of those laying around already
12:14:31 <Luke> I'm giving up on "brew install ghc" right now. Installing with -j1 from source is just too slow
12:15:19 <joneshf-laptop> alynn, hmm, that might work
12:16:32 <whittle> Luke: How do you feel about Docker? moghedrin has made an official Docker image for GHC 7.8.4. 
12:16:37 <joneshf-laptop> strikes me as odd there's not a thing for this already
12:16:42 <Luke> whittle: OS X =)
12:17:02 <whittle> Luke: http://boot2docker.io/
12:17:03 <Luke> whittle: I think we just need an official binary for OS X
12:17:19 <Yaniel> isn't there a haskell platform binary for osx
12:17:31 <Luke> I don't want haskell platform
12:17:35 <Luke> just ghc and cabal-install
12:17:50 <Luke> also platform looks like it's from feb 2014 for OS X
12:18:01 <Luke> it's on 7.8.3
12:18:07 <Luke> i'm trying to go to 7.10.1
12:21:43 <kstuart> Luke: I didn't have issue installing ghc 7.10.1 using homebrew, can zip binaries to dropbox if that helps
12:22:07 <Welkin> Luke: you can also try useing halcyon
12:22:09 <Luke> kstuart: it looks like the 7.10.1 from brew is source only?
12:22:28 <Welkin> you can set up an dev environment in seconds
12:23:05 <Welkin> although it is meant to be used to set up remote machines, you can still use it to quickly get a working copy of ghc running
12:23:22 <Welkin> it downloades precompiled binaries for your machine
12:23:29 <Welkin> downloads*
12:23:34 <kstuart> Luke: I don't recall, but the update was quick so I wouldn't think so. I'll uninstall, do a brew clean and reinstall (out of curiosity)...
12:23:48 <Luke> kstuart: and you don't have gmp linking issues?
12:24:01 <Luke> kstuart: how do you do a brew clean?
12:24:10 <kstuart> no issues, no.
12:24:27 <kstuart> Luke: brew cleanup
12:24:44 <Luke> kstuart: ah nice!
12:24:52 <kstuart> also once cleanup do brew doctor to see if there are any issues with your installation
12:24:52 <Luke> ok i'm going to try this
12:25:01 <Luke> yeah
12:25:21 <Luke> brew cleanup is not in the help docs
12:25:23 <Luke> brew help
12:27:53 <kstuart> Luke: doesn't appear to be in CLI help, but cleanup in FAQ
12:28:03 <kstuart> https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/FAQ.md
12:28:07 <Luke> cool
12:28:08 <Luke> thanks a lot
12:28:16 <kstuart> yw
12:28:17 <yuung> i have the problem statement: write a function that returns the # of clients in each gender.  i've defined the ADTs client and gender - how should i go about this the haskell way?
12:28:33 <yuung> imperatively it'd be really easy, but i'm not sure how to approach something like this in FP
12:29:29 <yuung> my adts: https://gist.github.com/anonymous/54baaee7483692f69620
12:30:13 <alynn> yuung: well, first thing is usually to work out the type
12:30:21 <alynn> what's the type of the function you're trying to write?
12:30:44 <yuung> i'm thinking [Clients] -> (Integer, Integer, Integer)
12:30:55 <yuung> but if i did it that way i couldnt use recursion
12:31:15 <yuung> s/[Clients]/[Client]
12:31:19 <alynn> well, you could!
12:31:34 <alynn> but explicit recursion isn't often the best way of doing things
12:31:55 <yuung> alynn, i see - but there aren't loop structures in haskell, right?
12:32:04 <alynn> no, but there are functions like foldr
12:32:10 <athan> Is there a way to make hspec print the test cases that cause a runtime exception?
12:32:41 <yuung> alynn hmm, interesting
12:33:06 <Luke> kstuart: "ld: warning: directory not found for option '-L/private/tmp/ghc20150402-41611-1b15z9c/ghc-7.10.1/gmp-static'"
12:33:10 <Luke> i keep getting this error
12:33:20 <alynn> yuung: how much haskell have you done?
12:33:37 <yuung> alynn a few days, heh
12:33:44 <alynn> ah, righty
12:34:15 <alynn> well
12:34:15 <Luke> kstuart: you don't get anything like that
12:34:17 <Luke> ?
12:34:19 <alynn> you can do it with explicit recursion
12:34:20 <kstuart> Luke: could be a pkg-config issue? any issues identified by 'brew doctor'?
12:34:30 <alynn> and that's probably the best way to do it for now
12:34:40 <Luke> kstuart: no issues according to brew doctor
12:34:51 <Luke> i deleted .cabal and .ghc when i started
12:35:17 <yuung> alynn, alright. then i'm thinking ([Client], (Integer, Integer, Integer)) -> ([Client], (Integer, Integer, Integer)) - the tuple of ints is to hold the gender count.  is this overkill?
12:35:31 <alynn> no, the original signature was fine
12:35:36 <alynn> [Client] -> (Integer, Integer, Integer)
12:35:53 <yuung> using recursion?  but doesn't the return type have to match the input for that?
12:36:11 <alynn> no, it doesn't
12:36:19 <kstuart> Luke: did you also cleared any ghc* folders from tmp?
12:36:38 <Luke> yeah there weren't any
12:36:40 <alynn> think about something like sum
12:36:46 <alynn> that's [Integer] -> Integer
12:36:56 <alynn> sum [] = 0; sum (x:xs) = x + sum xs
12:37:07 <yuung> alynn ah i see
12:37:33 <yuung> alynn yeah you're totally right.  alright, i'll take a shot at that
12:37:44 <alynn> good luck
12:38:03 <jhance> i would just filter by gender, then use length
12:38:03 <alynn> if you have trouble, think about how you'd implement something to counter the number of 'True' elements in a list of bools
12:38:22 <alynn> so [Bool] -> Integer
12:38:35 <yuung> alynn gotcha
12:38:57 <L8D> count :: (a -> Bool) -> [a] -> Int
12:39:32 <L8D> count f (x:xs) = if f x then succ (count f xs) else count f xs
12:39:35 <L8D> count _ [] = 0
12:40:25 <exio4> L8D: you mean (count f = length . filter f) ?
12:40:38 <L8D> exio4: but that's slower
12:40:58 <alynn> I don't imagine it is slower
12:41:05 <L8D> count f = foldr (\x -> if x then succ else id)
12:41:07 <alynn> (though I'm happy to be proved wrong!)
12:41:24 <L8D> alynn: it would need to traverse the list twice
12:41:32 <alynn> yes, but list fusion would eliminate the double traversal
12:41:36 <L8D> once during filter, and another during length
12:41:40 <exio4> and length uses foldl 
12:41:58 <exio4> which would also lead to a tailrecursive strict loop, if we go to the paranoic approach
12:42:05 <jhance> where would the rewrite-rules for list fusion even proc?
12:42:39 <alynn> 'length' and 'filter' are both rewritten in terms of build and foldr
12:42:47 <alynn> then foldr/build pairs are eliminated
12:42:55 <alynn> http://hackage.haskell.org/package/base-4.8.0.0/docs/src/GHC-List.html
12:43:05 <jhance> but wouldn't it be more like, (length (filter)) + (lenth (filter)) + (length (filter)) where + is not fused?
12:43:21 <alynn> jhance: oh, for the three of them yes
12:43:36 <alynn> I was comparing L8D's explicit recursion against length . filter f
12:43:49 <jhance> Oh I thought we were talking about doing once for each gender, not more than once per gender, my bad
12:44:20 <jhance> yeah, length . filter would totally get fused
12:44:40 <exio4> also, L8D's definition won't get inlined by GHC
12:44:41 <alynn> if it's once for each gender then yeah, and in practice I'd probably do something like foldMap (\case { Male -> (Sum 1, Sum 0, Sum 0); Female -> (Sum 0, Sum 1, Sum 0); Unknown -> (Sum 0, Sum 0, Sum 1) })
12:45:17 <alynn> but that's not something you can throw at someone who's only been doing haskell a few days
12:45:28 <exio4> and I think it'd stackoverflow on large lists 
12:45:39 <alynn> explicit recursion is often a bad idea
12:46:12 <alynn> sorry, this is kind of unfair
12:46:22 <alynn> L8D: yes, you're right in principle that fewer passes through the list is faster
12:46:43 <alynn> but in this case GHC takes care of merging the two passes together so it makes no odds :)
12:47:00 <sellers> I'm amazed at how much discussion has been raised over such a simple question.  Reasoning about haskell speed/memory usage is so intimidating :<
12:47:03 <kstuart> Luke: is your clang version Apple LLVM version 6.0 (clang-600.0.57) (based on LLVM 3.5svn)
12:47:25 <Luke> Apple LLVM version 6.0 (clang-600.0.57) (based on LLVM 3.5svn)
12:47:39 <alynn> sellers: yeah
12:47:50 <alynn> IMO that's probably the biggest disadvantage of haskell for real-world usage
12:48:19 <Luke> sellers: I haven't had issues with it at all
12:49:17 <Luke> i think a lot of people think they have speed/memory issues but then turn out not to. just semantic issues
12:51:38 <sellers> Luke: You can't always punt the question like that though.  Some things require an understanding of how various solutions will scale
12:52:28 <kstuart> Luke: installing ghc didn't build from source for me
12:52:44 <kstuart> https://gist.github.com/anonymous/27979427044968ef3f64
12:52:46 <Luke> kstuart: it only did for me if I built with the --with-tests flag. without built just fine
12:52:54 <Luke> kstuart: but when I try to build a library I get that linking error
12:52:55 <quchen> Reasoning about memory in any language is hard. Ever tried to understand some nontrivial C? Sure, the kind of memory worries are different, but it's not like memory is a Haskell-exclusive issue.
12:53:15 <kstuart> which library, I'll try build
12:53:17 <ClaudiusMaximus> using a strict tuple would probably eliminate stack overflow when accessing the results of the foldMap, at the cost of computing more when not all the results are needed
12:53:22 <Luke> kstuart: seqid
12:53:50 <Luke> kstuart: just `cabal get seqid` then you have to increase the upper bound for base in the cabal file
12:55:40 <exio4> quchen: in most imperative languages reasoning about memory is "the way to implement things", so it seems easier because you are forced to do it everytime you do anything, I guess
12:56:22 <quchen> exio4: I just spent a week playing the "is the pointer still alive and safe to use" game. :-(
12:56:47 <bennofs> Luke: recent cabal-install have cabal install --allow-newer
12:56:55 <Luke> yeah
12:57:13 <Luke> just saying he'll have to deal with it
12:57:59 <kstuart> Luke: cabal get / cabal install for seqid 0.3.1 built & installed without issue
12:58:06 <Luke> wtf
12:58:11 <Luke> something else is different then
12:58:42 <kstuart> guess so
12:58:45 <Luke> what's your ghc --version say?
12:59:07 <mmachenry> I'm getting an unknown argument —enable-profiling when on certain libraries when I install with that argument. But I get an error that I haven't installed profile libraries when I don't.
12:59:40 <kstuart>  version 7.10.1
12:59:56 <Luke> kstuart: ok well thanks for helping. i'm out of ideas
13:00:15 <S11001001> mmachenry: did you copy and paste that argument "—enable-profiling" to IRC?  (it has an emdash instead of two hyphens)
13:00:44 <mmachenry> S11001001: I typed it out. It's valid in my script. That's just an IRC client issue
13:00:53 <exio4> quchen: nice one! if you want to play that game for me, I wouldn't mind! :P 
13:01:43 <quchen> exio4: Sometimes I write Haskell as a nerve calming medicine substitute
13:02:23 <kstuart> Luke: I did install in sandbox but that shouldn't change anything, also my gmp is homebrew packaged
13:02:32 <Luke> i was using a sandbox too
13:02:38 <Luke> shouldn't matter like you said
13:03:45 <exio4> quchen: Haskell is one of the worst drugs out there, that's a bad excuse to take it!
13:04:25 <quchen> What you said made me angry. I need to calm myself somehow now.
13:04:27 <quchen> :-)
13:06:54 <Luke> kstuart: I still think it's a brew issue
13:06:56 <Luke> kstuart: https://github.com/Homebrew/homebrew/issues/38315
13:12:54 <kstuart> Luke: possibly, anyway did verbose install, here's the log in case it's of use to you
13:12:56 <kstuart> https://gist.github.com/anonymous/2e2a0107fc7aaed1bd5b
13:13:42 <yuung> solving problems in haskell/fp is so much more satisfying than in other languages
13:13:50 <Luke> kstuart: thanks. no mention of gmp at all in there which further leads me to believe it's the way ghc is statically built against gmp in brew
13:14:05 <RustyShackleford> i think i might be getting the hang of this language finally
13:14:25 <RustyShackleford> after a few weeks of very slow progress, this has been my most productive day yet
13:14:42 <Luke> RustyShackleford: you'll speed up exponentially
13:14:47 <kstuart> Luke: agreed, but I don't understand why it would work for me...
13:14:53 <Luke> RustyShackleford: when I could program faster in haskell than in python i knew i made it =)
13:15:20 <Luke> kstuart: me either. hopefully the bug report will help get us in touch w/ whoever knows about the brew install script
13:16:00 * hackagebot multipart-names 0.0.1 - Handling of multipart names in various casing styles  http://hackage.haskell.org/package/multipart-names-0.0.1 (nedervold)
13:21:00 * hackagebot config-value 0.4.0.1 - Simple, layout-based value language similar to YAML or JSON  http://hackage.haskell.org/package/config-value-0.4.0.1 (EricMertens)
13:24:03 <nomeata> joeyh: Hi Joey. Since you maintain a few of the popular-outside-the-haskell-community packages that are therefore important to be well supported by distributions, and given that I’m considering basing Haskell in Debian on Stackage: How do you feel about adding your packages to stackage?
13:24:26 <nomeata> See http://www.stackage.org/authors on how to do that; it’s quite simple and gives you additional QA for your packages.
13:24:36 <johnw> I would prefer if Stackage were more of a community effort
13:24:57 <geekosaur> is it me, or is stackage makiong a major push to become the partly-closed replacemtn for the platform?
13:25:14 <bennofs> what do you mean by partly-closed?
13:25:20 <geekosaur> (the components aren't closed but ther organization is...)
13:25:31 <clrnd> stackage is open source, FPC just provides a server
13:26:00 * hackagebot origami 0.0.3 - An un-SYB framework for transforming heterogenous  data through folds  http://hackage.haskell.org/package/origami-0.0.3 (nedervold)
13:26:02 <johnw> yeah, but the stackage software is not what nomeata is talking about
13:26:10 <bennofs> geekosaur: stackage is different. it provides much more packages, so it doesn't provide binary installers
13:26:11 <johnw> he's talking about pointing Debian at the stackage server maintained by fpco
13:27:04 <nomeata> johnw: also not quite
13:27:23 <nomeata> I’m talking about using Stackage LTS to get a self-consistent package-version-selection
13:27:28 <joeyh> nomeata: wow, really, debian on stackage?
13:27:30 <bennofs> stackage is useful for maintainers since they get pinged when the packages need bumps for newer deps
13:27:34 <kadoban> geekosaur: As long as their only criteria for inclusion is "does it build together?" it doesn't seem like it's actually closed in any meaningful way.
13:27:42 <nomeata> most of the time spent in packaging Haskell for Debian is figuring out what builds with what
13:27:54 <andbroby> does anyone know how to prevent (setq haskell-font-lock-symbols t) in emacs haskell mode from displaying the last >= in >>= as ≥?
13:27:56 <nomeata> and Michael seems to have a better grip on that
13:28:21 <nomeata> joeyh: well, Debian using the Stackage LTS package selection
13:28:47 <nomeata> I want all relevant packages to appear in https://www.stackage.org/snapshot/lts-2.0/cabal.config, as that makes my life easier
13:28:49 <geekosaur> sure, because what yesod wants shapes everything whether it's related or not. like the ruby community de facto being run by rails.
13:28:58 <geekosaur> I don;'t like it there either
13:29:31 <nomeata> geekosaur: I don’t see your point. To me, stackage is a service that tells me (as a package author) when my package does not build anymore against the latest versions of its dependencies.
13:29:39 <nomeata> otherwise, it does not interfere in any way
13:29:45 <joeyh> nomeata: I have not looked at stackage in any depth, but I have no problem with putting most/all of my stuff in it. Ie, if I need to be pinged about version bumps, I welcome the pinging
13:29:49 <geekosaur> no, I suippose to you it doesn't
13:29:57 <joeyh> I guess you're talking about git-annex, anything else in mind?
13:30:11 <nomeata> joeyh: yes, and its dependencies (torrent etc.)
13:30:25 <geekosaur> *I* am the one who's being pushed to chase rails^Wyesod because it defines what is compatible with the ecosystem
13:30:31 <joeyh> which is very much a +1 because I have a few other wanted dependencies up my sleeves
13:30:33 <kadoban> geekosaur: I suppose your point is that since yesod is a pain to build, and since stackage can only have 1 choice for each dep, the deps are kind of locked by what yesod uses?
13:30:40 <geekosaur> yes
13:31:12 <kadoban> That sounds like it could be a valid problem. Is it actually limiting though? Are there things in stackage that could be upgraded if yesod wasn't in there?
13:31:12 <joeyh> nomeata: since I've not looked into it, is it really desirable to have leave package with lots of deps in stackage?
13:31:22 <joeyh> (non-libraries
13:31:24 <bennofs> I don't see how that can have a negative effect though
13:31:35 <geekosaur> and xmonad has approximtately zero reason to care about yesod but we're being pushed to swear fealty to it because it's the new de facto platform that defines all compatibility with everything
13:31:36 <nomeata> joeyh: to me it is :-)
13:31:49 <joeyh> how about to the stackage maintainers?
13:32:20 <lpaste> sebastard pasted “MyrvoldRuskey” at http://lpaste.net/130054
13:32:30 <Clint> depends how poorly-maintained the dependencies are
13:32:35 <johnw> nomeata: ah, I see, you're just going to use the metadata information
13:32:38 <nomeata> joeyh: It might be that your package will not be added if the dependencies are not compatible with the rest
13:32:56 <sebastard> Hi :) can someone help me figure out why I can't convert (Integral i) to Int with `fromIntegral`?
13:33:13 <nomeata> joeyh: but I think we’ll see what happens when you do the pull request adding git-annex :-)
13:34:21 <joeyh> Clint: well, very poorly if you're talking PVP. OTOH, git-annex builds with pretty much any version of anything, at least back to debian stable. Which is better than most stuff.
13:35:05 <nomeata> joeyh: good thing is, stackage does not impose a certain dependency scheme to be used, as it simply tests what works (AFAIK)
13:35:09 <joeyh> nomeata: I'm up for the experiement at least
13:35:21 <geekosaur> sebastard, if I'm reading that correctly, you are trying to take (i `mod` n) where `i has Integral constraint but `n` has Num constraint
13:35:24 <joeyh> nomeata: from a DFSG-free POV, this is making debian depend on github BTW..
13:35:26 <geekosaur> :t mod
13:35:27 <lambdabot> Integral a => a -> a -> a
13:35:32 <joeyh> <cough>
13:35:36 <nomeata> joeyh: feel free to mention @nomeata in the pull request, I’m curious.
13:35:59 <geekosaur> (a) Num does not guarantee Integral (b) those `a`s must be *the same type*
13:36:01 * hackagebot unagi-streams 0.1.2 - Unagi Chan IO-Streams  http://hackage.haskell.org/package/unagi-streams-0.1.2 (LukeHoersten)
13:36:08 <sebastard> geekosaur: no, n has no constraint, it is just an Int
13:36:20 <geekosaur> unrank1 :: (Integral i, Num n) => Int -> i -> V.Vector n
13:36:25 <geekosaur> says otherwise
13:36:37 <geekosaur> maybe I am misreading
13:36:38 <nomeata> joeyh: Nah, there is no automatism. It just means that I’ll stop manually trying out what builds with what and simply use the list provided by Michael. If Github shuts down, he can still send me the list by letter, or I simply go back to do my own tests.
13:37:16 <joeyh> nomeata: I mean, you currently have to have an account to follow the stackage procedures
13:37:18 <sebastard> geekosaur: aaaaaaaah, oh no actually you are correct, that actually is the problem, they need to be the same type
13:37:24 <nomeata> Also, inclusion to Stackage is not a hard requirement for inclusion in Debian.
13:37:31 <sebastard> geekosaur: thanks, I should be able to fix that
13:37:37 <joeyh> (or maybe not, maybe email patches also works)
13:37:38 <geekosaur> even if what you say is correct then your fromIntegral needs to be on just r, not r `mod` n
13:38:11 <nomeata> right. in the end its just another git repo, and Michael would probabyl accept patches in other ways as well. at least theoretically :-)
13:38:13 <geekosaur> because the type clash happens in `mod`, not outside it
13:41:01 * hackagebot seqid 0.3.2 - Sequence ID production and consumption  http://hackage.haskell.org/package/seqid-0.3.2 (LukeHoersten)
13:45:35 <nomeata> good night everyone
13:45:43 <johnw> good night!
13:47:26 <ReinH> johnw: good afternoon!
13:47:39 <johnw> hi ReinH!
13:47:56 <lpaste> sebastard revised “MyrvoldRuskey”: “No title” at http://lpaste.net/130054
13:49:09 <sebastard> geekosaur: I found a fix, but it's not the way you proposed (I needed another `fromIntegral` on n). Is this really the best solution? It looks so ugly...
13:50:20 <kadoban> Number stuff in haskell can get pretty ugly sometimes :-/
13:50:42 <johnw> but uglier as it nears zero, or infinity?
13:51:02 * hackagebot seqid-streams 0.3.2 - Sequence ID IO-Streams  http://hackage.haskell.org/package/seqid-streams-0.3.2 (LukeHoersten)
13:51:31 <sebastard> nope, not uglier. Just littered with fromIntegral's
13:55:28 <johnw> sebastard: why aren't you using a vector of Integral a, rather than Num a?
13:56:24 <johnw> since you seem to be flattening every member to an integral, you could just do an initial pass and convert the whole vector
14:01:00 <sebastard> johnw: I don't think I'm flattening members here, only indices of the vector
14:01:02 * hackagebot tagged 0.8 - Haskell 98 phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.8 (EdwardKmett)
14:01:26 <johnw> the indices aren't already integers?
14:01:38 <johnw> n/m, I haven't read the code carefully enough to be able to comment here
14:02:27 <rnhmjoj> @pl \x -> (,) x . ((length .) . elemIndices) x
14:02:27 <lambdabot> liftM2 (.) (,) ((length .) . elemIndices)
14:03:52 <hannes___> hey, does anyone know what the current status of 7.10.1 is? I seem to recall it was supposed to be finalized sometime Q1 this year, although now I'm not sure anymore.
14:04:03 <shachaf> It has been released.
14:04:51 <hannes___> shachaf: Oh? Missed that. Kept finding the rcs when I looked yesterday. Thanks!
14:06:03 * hackagebot origami 0.0.4 - An un-SYB framework for transforming heterogenous  data through folds  http://hackage.haskell.org/package/origami-0.0.4 (nedervold)
14:06:05 * hackagebot shake-pack 0.1.1 - Shake File Pack Rule  http://hackage.haskell.org/package/shake-pack-0.1.1 (LukeHoersten)
14:06:23 <EvanR> un-SYB ...
14:08:30 <rnhmjoj> @pl \xs x -> (x, l x xs)
14:08:30 <lambdabot> ap (,) . flip l
14:08:32 <shachaf> It's still broken, though.
14:09:35 <hannes___> shachaf: Broken? In what respect?
14:09:47 <shachaf> You can still write unsafeCoerce with -XSafe.
14:10:16 <hannes___> shachaf: Ok bad, but I don't need to write SafeHaskell right now
14:11:03 * hackagebot http-conduit-downloader 1.0.25 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.25 (VladimirShabanov)
14:13:50 <ion> shachaf: How?
14:14:29 <rnhmjoj> @pl \x -> nub . map (f x) $ x
14:14:29 <lambdabot> (nub .) =<< map . f
14:14:47 <shachaf> ion: https://ghc.haskell.org/trac/ghc/ticket/9858
14:14:53 <ion> shachaf: thanks
14:16:03 * hackagebot shake-pack 0.1.2 - Shake File Pack Rule  http://hackage.haskell.org/package/shake-pack-0.1.2 (LukeHoersten)
14:23:43 <erisco> f :: Int -> IntMap String -> IntMap String; f i m = ..     say this function does a lookup on m with i ... typically this returns some Maybe value, but how can I instead guarantee the i is in m statically (no need for the Maybe) ?
14:24:13 <erisco> the only thing I can think of is to use a partial function (such as fromJust) and prove it is not going to crash elsewhere
14:24:20 <erisco> (by elsewhere I mean outside of Haskell)
14:26:03 * hackagebot context-free-grammar 0.1.0 - Basic algorithms on context-free grammars  http://hackage.haskell.org/package/context-free-grammar-0.1.0 (nedervold)
14:26:05 * hackagebot shake-minify 0.1.3 - Shake Minify Rules  http://hackage.haskell.org/package/shake-minify-0.1.3 (LukeHoersten)
14:26:15 <ClaudiusMaximus> :t (Data.IntMap.!)
14:26:16 <lambdabot> IM.IntMap a -> IS.Key -> a
14:26:24 <quchen> That sounds like the right thing to do. You can leverage the type system some more if you tag your IntMap with information about whether it contains something, and then provide access functions only for that case, but that takes some work and you have to write your own API and everything.
14:26:57 <erisco> ClaudiusMaximus well that is just a partial function like I said
14:27:27 <rnhmjoj> @pl \x -> f x (g x)
14:27:27 <lambdabot> ap f g
14:27:29 <ClaudiusMaximus> erisco: oh, sure - i thought you were proving it elsewhere - misunderstood
14:27:46 <erisco> well I preferably would not want to do that
14:28:00 <erisco> it is just gross from the Haskell perspective
14:28:08 <c_wraith> IntMap doesn't give you tools to prove it there.
14:28:11 <erisco> in the same way head is a gross function
14:28:18 <c_wraith> There are other things, like vinyl's records, that do
14:28:42 <ClaudiusMaximus> erisco: anyway, probably better than (!) or fromJust  is something like  let Just s = lookup k m in ... because then you get a line number with the exception...
14:30:10 <EvanR> fast and loose haskell code ;)
14:30:27 <erisco> it would be cool if there was some way to tag it, but I really don't know how that'd work
14:30:57 <erisco> I can certainly give it a bash
14:30:57 <EvanR> making sure dictionary keys really are there is a non trivial problem for types i think
14:31:33 <erisco> well, for example
14:32:14 <EvanR> your trusted kernel that hides the stuff that could break invariants, and an information argument for why user code cant crash in a command would be good
14:32:24 <EvanR> s/information/informal/
14:32:35 <EvanR> s/command/comment/
14:32:37 <erisco> insert :: k -> v -> Map u k v -> (Map u k v, Key u k, Value u v)    the idea being that u is a phantom type that you introduce yourself
14:32:50 <tswett> erisco: I feel like your main choices are either to just use partial functions, or to use a different language that has dependent types.
14:32:52 <erisco> and you discipline yourself to only have one map per phantom type
14:32:57 <erisco> it is like, halfway
14:33:26 <RustyShackleford> i could use a little help. So my chess position representation has four bools, one for each piece that can castle
14:33:26 <erisco> you emulate a linear typing kind of jazzy thing
14:33:42 <EvanR> youre trying to do dependent types in haskell
14:33:57 <RustyShackleford> I want to get a string like "Kq", meaning that white can castle kingside and black can castle queenside
14:33:59 <erisco> so the u type differentiates one map from another, and you're not supposed to reuse old values
14:34:06 <tswett> Maybe I'm not familiar with the relevant culture, but proving that a program can't crash generally seems like a relatively extreme thing to do.
14:34:07 <erisco> EvanR well what else is new oO
14:34:10 <EvanR> and even with dependent types that seems rather inconvenient for many uses of Maps
14:34:20 <RustyShackleford> er, lemme just throw something together and you can critique it
14:35:34 <EvanR> assuming you can even produce the required proofs
14:35:48 <EvanR> either on a absolute level or personal level
14:36:01 <erisco> okay, so instead of Y lets talk about X
14:36:04 * hackagebot twilio 0.1.1.0 - Twilio REST API library for Haskell  http://hackage.haskell.org/package/twilio-0.1.1.0 (andrus)
14:36:43 <erisco> how can I diff trees? the motivation for using maps is to represent the tree as a graph so that I can diff edges and vertices
14:37:03 <EvanR> whats the problem?
14:37:11 <erisco> that is the problem, that is the X
14:37:22 <erisco> well, we can go to W but that is really beside the point
14:37:27 <RustyShackleford> is there a nice way to test a == b == c?
14:37:35 <RustyShackleford> seems like haskell doesn't let you chain those together
14:37:45 <EvanR> :t foldr (==)
14:37:46 <lambdabot> Foldable t => Bool -> t Bool -> Bool
14:37:54 <EvanR> :t foldr1 (==)
14:37:55 <lambdabot> Foldable t => t Bool -> Bool
14:38:04 <c_wraith> types don't work that way
14:38:12 <tswett> erisco: diffing lists is hard enough.
14:38:27 <hpc> no language lets you chain those together
14:38:29 <tswett> RustyShackleford: well, you could define allEqual (x:xs) = all (== x) xs
14:38:36 <RustyShackleford> hpc: python does actually
14:38:50 <hpc> ew
14:38:54 <tswett> (For completeness, define allEqual [] = True)
14:39:04 <EvanR> it might let you chain them together, but not in the way you think
14:39:18 <EvanR> unless you restrict == to only operate on Bools
14:39:21 <tswett> > False == False == True
14:39:22 <lambdabot>      Precedence parsing error
14:39:23 <lambdabot>          cannot mix ‘==’ [infix 4] and ‘==’ [infix 4] in the same infix expre...
14:39:25 <erisco> tswett I have come to accept that any solution is going to be hard
14:39:28 <RustyShackleford> so in this case i'm testing four bools
14:39:41 <RustyShackleford> I want to know if all of them are false
14:39:47 <EvanR> all (== False)
14:40:00 <tswett> Or even "all not", aye?
14:40:07 <EvanR> meh
14:40:19 <EvanR> readability
14:40:30 <tswett> Or (not . any id), but that's getting kind of silly.
14:40:37 * EvanR looks up how to silence join and parts
14:40:41 <tswett> > (not . any id) [False, False, False]
14:40:43 <lambdabot>  True
14:40:46 <caconym> whoa
14:40:49 <ggVGc> can I assign my strings for "__$$INDENT$$__" to a constant and pattern match with it like I am doing? https://gist.github.com/8d909d73078037a224ca
14:41:44 <erisco> > ((==) <*> const b <*> const c) a
14:41:45 <lambdabot>      Couldn't match type ‘Bool’ with ‘Expr → b’
14:41:45 <lambdabot>      Expected type: Expr → Expr → Expr → b
14:41:45 <lambdabot>        Actual type: Expr → Expr → Bool
14:41:45 <EvanR> /ignore #haskell JOINS PARTS
14:41:53 <erisco> nevermind :)
14:42:20 <joeyh> and . map not
14:42:42 <quchen> :t \xs -> unsafePerformIO ((GHC.Exts.the xs `seq` return True) `catch` \(SomeException _e) -> return False) -- or that, tswett!
14:42:43 <lambdabot> Not in scope: ‘unsafePerformIO’
14:44:04 <tswett> :t GHC.Exts.the
14:44:05 <lambdabot> Eq a => [a] -> a
14:44:16 <quchen> > the [1,1,1,1,1]
14:44:17 <lambdabot>  Not in scope: ‘the’
14:44:24 <quchen> > GHC.Exts.the [1,1,1,1,1]
14:44:25 <lambdabot>  Not in scope: ‘GHC.Exts.the’
14:44:35 <quchen> Eh.
14:44:53 <quchen> the = if allEqual then head else error
14:45:13 <byorgey> ggVGc: do you mean can you do something like   ind = "__$$INDENT$$__"  and then later pattern match on ... Node (Leaf ind : ...)  ?
14:46:07 <quchen> tswett: A special pearl is the documentation comment mentioning that it "ensures" something. It's like ensuring you don't have an accident with your car by having you drive into a tree before.
14:46:24 <frerich_> Is anybody here familiar with one of the FRP libraries, e.g. reactive-banana? I tip-toed around FRP so far but by now suspect that it may be a nice way to implement network clients, e.g. IRC bots which listen for magic messages and then say something.
14:46:35 <RustyShackleford> that works wonderfully
14:46:56 <RustyShackleford> now: if all of those bools are not False, then we do something else
14:47:18 <RustyShackleford> so if bool1 == bool3 == True, I want a string that say "13"
14:47:31 <ggVGc> byorgey: yes, exactly
14:47:48 <EvanR> frerich_: for that ive heard people recommend netwire
14:48:00 <byorgey> ggVGc: the answer is no, because the pattern "Leaf ind" matches *any* leaf, and gives the contents the name "ind".  It shadows the definition of ind = "__$$INDENT$$__".
14:48:34 <ggVGc> byorgey: yeah, I know, that's why I wondered if there was a way to mark 'ind' to be evaluated as a constant instead
14:48:37 <ggVGc>  I guess not
14:48:37 <ggVGc> thanks
14:48:39 <NemesisD> does __bold__ no longer bold in haddock?
14:48:53 <NemesisD> it seems to just be taking the underscores literally for me
14:49:05 <byorgey> ggVGc: I suggest instead of having special String values, you should use some algebraic data type to encode what you want.  e.g.  data Leafy = Indent | Dedent | Content String   and then have a   Tree contain Leafy values instead of Strings
14:49:56 <ggVGc> byorgey: yeah, I'll do that. thanks. I just started out with haskell, and getting this to even work the way I wanted was a major hurdle :)
14:50:01 <frerich_> RustyShackleford: You could use something like 'concat . zipWith (\b i -> if b then show i else "")'
14:50:46 <frerich_> RustyShackleford: That'll be odd with more than 9 bools though, since you'll get two-digit numbers and hence cannot tell whether e.g. "13" means "1 and 3" or "just 13".
14:51:02 <byorgey> frerich_: there was a new library just published that even had an example of writing an IRC bot, it looked really nice for "FRP-ish" things which are actually discrete
14:51:05 * hackagebot fixedwidth-hs 0.3.0.0 - Quick parsing of fixed-width data formats.  http://hackage.haskell.org/package/fixedwidth-hs-0.3.0.0 (MichaelOChurch)
14:51:07 <byorgey> but I can't remember the name
14:51:41 <EvanR> frerich_: RustyShackleford what on earth is wrong with all (== False)
14:52:09 <EvanR> oh this has moved on
14:52:22 <frerich_> EvanR: I replied to ' so if bool1 == bool3 == True, I want a string that say "13"' -- but maybe I lack context.
14:52:52 <EvanR> you cant get the text of a variable name
14:53:13 <frerich_> I figured 'bool1' meant 'first bool in the list'.
14:53:35 <EvanR> nevermind i have no idea what this means
14:53:42 <frerich_> byorgey: Now you got me googling...
14:54:09 <EvanR> byorgey: auto?
14:55:23 <byorgey> ah, yes, auto
14:55:30 <byorgey> http://hackage.haskell.org/package/auto
14:55:59 <byorgey> chatbot example is here: https://github.com/mstksg/auto
14:56:05 <byorgey> frerich_: ^^^
14:56:38 <shachaf> If they're actually discrete, how "FRP-ish" can they really be?
14:57:11 <RustyShackleford> http://lpaste.net/130060 well i got my function implemented
14:57:16 <frerich_> byorgey: Ah, I actually read about 'auto' already but "Auto is a Haskell DSL and platform providing an API with declarative, compositional, denotative semantics for discrete-step, locally stateful, interactive programs, games, and automations, with implicitly derived serialization." didn't exactly trigger "FRP" in my mind.
14:57:18 <RustyShackleford> can you think of a cleaner way to do it?
14:57:23 <RustyShackleford> or is that pretty good?
14:57:37 <byorgey> shachaf: they aren't, and in fact the author goes to some length to say that it *isn't* FRP
14:58:26 <byorgey> but there is a link, in that many times when people think "perhaps I should use FRP for this" they actually don't really need FRP and instead want something like auto.
14:58:32 <byorgey> such as frerich_ =)
14:58:44 <EvanR> or netwire
14:58:57 <frerich_> Yeah, I don't actually know whether FRP is such a good tool, so - any links are much appreciated :)
14:59:19 <byorgey> perhaps, I don't know exactly what frerich_ is trying to do, but the example of network clients sounds right up auto's alley to me
15:00:39 <byorgey> RustyShackleford: looks pretty good, I would use 'null' instead of (== "")
15:05:16 <frerich_> RustyShackleford: Instead of checking 'all (== "") [a, b, c, d]' and then either returning "-" or "a ++ b ++ c ++ d" you could maybe do "let x = [a,b,c,d]" and then "if null x then "-" else x"
15:05:46 <frerich_> err, 'let x = a ++ b ++ c ++ d'
15:06:05 * hackagebot maam 0.2.0.0 - An application of the Galois Transformers framework to two example semantics.  http://hackage.haskell.org/package/maam-0.2.0.0 (DavidDarais)
15:06:50 <erisco> can I compute some hash at the type level?
15:06:58 <erisco> that might help for linear typing... hm
15:07:31 <erisco> I could increment a number when a map operation was done, like insert or delete or whatever
15:07:43 <erisco> but the problem is that two different inserts on the same first map will give the same number
15:11:06 * hackagebot maam 0.2.0.1 - An application of the Galois Transformers framework to two example semantics.  http://hackage.haskell.org/package/maam-0.2.0.1 (DavidDarais)
15:23:22 <jellie> Why doesn't an executable's .cabal file have a ghc-options field?
15:25:15 <c_wraith> it can
15:27:14 <mmachenry> I'm having a problem dealing with monad transformers. I am using  Control.Concurrent.AdvSTM but I want to make my own "type MySTM = ReaderT AdvSTM". I can no longer use this as an instance of the MonadAdvSTM type class though.
15:28:02 <mmachenry> I can make it an instance but if I do I think I need to redefine every method of the type class (there are 16) to point to the inner type AdvSTM. 
15:28:26 <mmachenry> Is there a way to do this more easily without duplicating so much code or making it so fragile to updates to AdvSTM?
15:28:45 <dgorbik_> mmachenry: try `deriving Monad`
15:28:58 <caconym> does anyone have an opinion on whether Haskell is currently a good choice for building a relatively compact RESTful web service for which reliability and stability are extremely important?
15:29:11 <mmachenry> dgorbik_: It's already a monad. 
15:30:02 <caconym> I lean towards "yes, absolutely" but am wondering if anyone has first-hand experience
15:30:27 <Maxdamantus> mmachenry: I've never used AdvSTM, but I suspect you'd use liftAdv.
15:30:53 <mmachenry> "ReaderT Foo AdvSTM" is a monad already. Is there a way to say "deriving MonadAdvSTM" but tell it that the way it does this is to use the inner AdvSTM?
15:31:31 <mmachenry> Maxdamantus: Yeah I'd have to basically define all of the 16 menthods as "takeMVar = lift AdvSTM.takeMVar" ...
15:32:30 <Maxdamantus> Hang on, ReaderT AdvSTM? is that well-kinded?
15:32:45 <mmachenry> Maxdamantus: ReaderT Foo AdvSTM
15:32:49 <Maxdamantus> Okay.
15:33:10 <mmachenry> Foo is my own data type of config stuff and dbh handles and logger handles
15:33:41 <exio4> is there a way to detect the threaded runtime? 
15:36:41 <dgorbik_> mmachenry: do you do `atomically` in the end? Do you unpack your type to do that?
15:38:24 <EvanR> one, defining a bunch of dummy wrappers isnt that bad, two blame transformers
15:38:53 <EvanR> not worth the trouble a lot of times
15:39:29 <monochrom> I like wrappers. they are so abstracting.
15:40:29 <exio4> rtsSupportsBoundThreads is what I wanted, skipped it somehow
15:40:49 <EvanR> is that the same as -threaded 
15:41:07 * hackagebot tagged 0.8.0.1 - Haskell 98 phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.8.0.1 (EdwardKmett)
15:42:07 <mmachenry> dgorbik_: Yeah. Basically I have a "type MyIO = ReaderT Foo IO" and "type "MySTM = ReaderT Foo AdvSTM". Atomically allows me to run MySTM from within MyIO.
15:42:43 <mmachenry> But the IO actions that I add with on commit should be MyIO (and have access to the Foo) instead of just plain old IO
15:42:49 <jellie> 1/j wolfram-alpha
15:42:57 <newsham> is there a standard   guardIO b = when b (fail "fail") ?
15:43:11 <mmachenry> I guess I should write up the bad solution and show that in an lpaste for critique but I cringe to write it.
15:44:24 <dgorbik_> mmachenry, I guess you either have to use lifts inside of your STM or just implement all those methods with lift so that you don't have to lift :)
15:44:34 <dgorbik_> not sure there are other ways to deal with it
15:44:58 <exio4> EvanR: the threaded runtime is the one you enable with -threaded, yes
15:45:34 <mmachenry> dgorbik_: Probably :( I guess this is the one time where I want Haskell to have subtyping. 
15:45:42 <jellie> Has anyone done anything with haskell and the wolfram alpha api that is open source?
15:46:33 <dgorbik_> mmachenry, it's probably possible to use template haskell to automate generating these instances. (derive AdvSTM basically) 
15:46:51 <mmachenry> dgorbik_: Yeah that's probably true.
15:47:03 <mmachenry> Okay thanks, I'll be back after I write this up… and get dinner. 
15:47:46 <jellie> Oh my is clojure a lisp?
15:47:58 <dgorbik_> it's Java
15:48:00 <jellie> I'm looking at clojure code and it has a lot of quotes
15:48:00 <dgorbik_> :D
15:48:08 <jellie> This http://blog.markwatson.com/2012/03/using-wolfram-alpha-from-clojure.html
15:48:25 <jellie> dgorbik_: I didn't get that joke.
15:52:43 <josephle> jellie, clojure runs on the jvm, hence why "it's Java"
15:53:05 <jellie> josephle: Well it has a ton of quotes.
15:53:49 <josephle> you mean parentheses?
15:55:29 <hiptobecubic> jellie, clojure is a lisp, yes.
15:56:28 <jellie> josephle: LOL yeah
15:56:38 <jellie> we call them brackets though
15:56:56 <jellie> WOW google has a github page
15:57:14 <jellie> Is there a haskell-offtopic?
15:57:47 <fizruk> jellie: there is #haskell-blah
15:57:47 <pavonia> #haskell-blah
15:58:09 <jellie> Thanks
16:11:08 * hackagebot heaps 0.3.2.1 - Asymptotically optimal Brodal/Okasaki heaps.  http://hackage.haskell.org/package/heaps-0.3.2.1 (EdwardKmett)
16:11:10 * hackagebot snaplet-acid-state 0.2.6.2 - acid-state snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-acid-state-0.2.6.2 (DougBeardsley)
16:25:47 <jellie> People who use haskell mode in emacs. How do you make the haskell repl in emacs read environment variables?
16:29:16 <Fylwind> jellie: wouldn't it simply inherit the environment variables from whatever process that launched emacs?
16:30:42 <jellie> Fylwind: Well I launched emacs from gnome so...
16:31:17 <jhance> jellie: start using the X-less version and launch it from your term then :P
16:31:49 <Fylwind> jellie: you can also set them within Emacs: http://ergoemacs.org/emacs/emacs_env_var_paths.html
16:32:12 <slack1256> Why Double and Float don't implement the class Bits from Data.Bits? In C I can do a sizeof(double) and it will give 8
16:32:17 <jellie> jhance: I used emacs from withing the terminal for like a year then tried using it from within X and it's much better this way.
16:32:27 <jellie> Fylwind: On it
16:32:37 <jhance> slack1256: How do you rightshift a double?
16:32:43 <oconnore> I just installed ghc 7.8.4 on Ubuntu, and I get an error "cabal: ghc: missing -B<dir> option"
16:32:50 <c_wraith> slack1256: because that class is for everything that makes sense to treat as a bit vector, which doubles do not
16:32:52 <oconnore> is there some path configuration I'm missing?
16:32:55 <enthropy> slack1256: sizeOf would be Storable
16:33:24 <slack1256> c_wraith: oh, so it doesn't implement the rest of the methods, that is why doesn't belong. got it.
16:33:38 <jhance> ____functions____
16:33:45 <c_wraith> slack1256: and as enthropy points out, sizeOf is in Storable
16:34:26 <slack1256> right, thanks enthropy
16:34:54 <enthropy> jhance: the haskell (98) report uses the term "class methods"
16:36:03 <slack1256> Also, are proxies useful for the idiom of `sizeOf (1 :: Double)` where the value 1 isn't used?
16:36:27 <c_wraith> slack1256: yes, but unfortunately they hadn't been figured out when the FFI was designed
16:37:05 <slack1256> oh, well. It isn't that annoying
16:37:09 <slack1256> thanks guys
16:38:11 <enthropy> following Data.Typeable we might have sizeRep (since there's typeOf / typeRep)
16:41:10 * hackagebot lens 4.9 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.9 (EdwardKmett)
16:42:42 <netroby> Morning (From GMT+8)
16:44:06 <oconnore> there isn't even a -B in --show-options, what does it do?
16:47:29 <newsham> best part about writing a proj in haskell is getting to play golf all day
16:48:49 <Axman6> without even having to leave the office!
17:06:11 * hackagebot LambdaHack 0.4.101.0 - A game engine library for roguelike dungeon crawlers  http://hackage.haskell.org/package/LambdaHack-0.4.101.0 (MikolajKonarski)
17:14:22 <fr33domlover> hello
17:14:38 <fr33domlover> is my IRC nick an acceptable username for Hackage?
17:14:58 <joneshf-laptop> is there a grammar for cabal files?
17:15:02 <Axman6> I believe the policy is FirstLast
17:15:39 <mikeplus64> there are a few usernames that are just nicknames now though
17:15:49 <mikeplus64> bah, why does HDBC use String and not Text? :(
17:16:04 <edwardk> mikeplus64: we used to have a FirstLast policy, but it was eventually relaxed a bit.
17:16:12 * hackagebot cabal-helper 0.3.1.0 - Simple interface to Cabal's configuration state used by ghc-mod  http://hackage.haskell.org/package/cabal-helper-0.3.1.0 (DanielG)
17:16:22 <edwardk> basically it used to require a manual account creation step, now it just auto-approves
17:16:23 <enthropy> for the most part it's FirstLast http://hackage.haskell.org/packages/uploaders/
17:17:01 <fr33domlover> The website says KittenLover87 won't be accepted
17:17:17 <fr33domlover> Mine is similar except it's not about kittens :P
17:17:48 <glguy> "We ask only that such people choose a name (and username) that looks at home among a collection of real names;"
17:19:09 <edwardk> yeah we have a few, Gwern Branwen, Heinrich Apfelmus, etc. that are pseudonymous, but not many
17:19:33 <edwardk> fr33domlover: sounds like you know the answer to your question then
17:19:55 <pavonia> Well, LnYnp6WCYyKG3yhdLDztVRuQjTFKEy was accepted ...
17:21:12 * hackagebot generic-aeson 0.2.0.3 - Derivation of Aeson instances using GHC generics.  http://hackage.haskell.org/package/generic-aeson-0.2.0.3 (AdamBergmark)
17:21:14 * hackagebot json-schema 0.7.3.2 - Types and type classes for defining JSON schemas.  http://hackage.haskell.org/package/json-schema-0.7.3.2 (AdamBergmark)
17:22:21 <fr33domlover> edwardk, I don't, considering the strange names that were accepted
17:22:52 <edwardk> fr33domlover: the manual check that was in place is currently gone. whether it stays gone will probably mostly be a function of how much abuse is seen in the meantime
17:23:58 <Axman6> mikeplus64: HDBC is probably older than Text is
17:24:07 <Axman6> it's definitely quite old
17:24:41 <edwardk> so the answer is "it'd go through technically, but the site explicitly requests you not to". choose accordingly
17:26:12 * hackagebot rest-stringmap 0.2.0.4 - Maps with stringy keys that can be transcoded to JSON and XML.  http://hackage.haskell.org/package/rest-stringmap-0.2.0.4 (AdamBergmark)
17:28:44 <mikeplus64> Axman6: but interesting packages depending on it are very new and shiny :( (e.g. relational-record)
17:29:58 <bergmark> HDBC is a bit of a mess...
17:30:28 <bergmark> manual refcounting in C anyone? :-)
17:31:51 <bergmark> i'm a bit sad the FirstLast policy was dropped on hackage, everything was o consistent ;-(
17:32:08 <Axman6> agreed
17:37:40 <fr33domlover> FirstLast makes some names long
17:38:19 <bergmark> does the length matter?
17:38:36 <fr33domlover> I don't know, I just created an account a minute ago :P
17:38:37 <RustyShackleford> is there a way to do math on chars?
17:38:57 <RustyShackleford> '0' + 1, for example
17:39:14 <RustyShackleford> you know how C is weakly typed, and you can do these sort of hacks?
17:39:16 <fr33domlover> RustyShackleford, you mean ord and chr?
17:39:59 <fr33domlover> hmmm it's definitely possible to code, but I don't know if e.g. + for chars exists
17:40:04 <verement> > chr $ ord '0' + 1
17:40:05 <lambdabot>  '1'
17:40:06 <RustyShackleford> yep, that looks like what I want
17:40:15 <RustyShackleford> thank you
17:42:27 <pacak> How would I go about declaring Show instance for Any from ghc-prim in ghc 7.10?  Right now it complains - "Illegal type synonym family application in instance: Any     In the instance declaration for ‘Show Any’"
17:45:25 <jhance> I hate the argument that C is weakly typed
17:45:29 <jhance> its the most awful argument I've ever heard
17:46:17 <jhance> If I take the same reasons people say C is weakly typed I can say that haskell is weakly typed
17:47:20 <bergmark> i read weakly typed as "easy to make horrible mistakes"
17:47:58 <kadoban> jhance: Live most things, it's relative.
17:48:01 <kadoban> like*
17:48:09 <enthropy> pacak: instance (Any ~ a) => Show a -- but maybe you don't want OverlappingInstances that will make other type errors confusing
17:48:28 <jhance> I don't know, the reason most people cite to me is that you can cast anything to anything
17:48:37 <jhance> and you can do that in almost any language
17:48:39 <jhance> including haskell
17:48:49 <Axman6> it's quite difficult in haskell though
17:49:14 <glguy> I think the more standard example is that numeric types implictly cast to fit wherever they're used
17:49:23 <Axman6> but it can happen automatically in C
17:49:47 <kadoban> In haskell it's quite obvious you're doing it, and you have to go out of your way. It's not like, "oops, I casted"
17:50:25 <jhance> I'd say that in well-written C its pretty obvious because you usually have no need to cast, though. My PLC teacher is telling everyone to cast malloc explicitly and I'm facepalming.
17:50:39 <jhance> but i guess its a bad idea to discuss C here
17:51:13 * hackagebot blaze-json 0.2.1 - tiny library for encoding json  http://hackage.haskell.org/package/blaze-json-0.2.1 (HirotomoMoriwaki)
17:51:42 <kadoban> jhance: Let's put it this way: I'm an intermediate Haskell programmer, and I'm not sure how you can even do it in Haskell. It's not something you need to do in usual circumstances.
17:52:12 <Axman6> the easiest way is with the unsafePerformIO newIORef :: IORef a trick
17:52:48 <Axman6> then you can do writeIORef ref "hello"; i <- readIORef ref :: IO Int
17:53:15 <pacak> enthropy: That created overlapping instances for all other show instances derived in the same file so that's indeed probably not what I want to do. I guess I'll try to write some other instances manually (trying to fix vacuum to work with ghc 7.10)
17:53:31 <kadoban> Axman6: Ah, gross.
17:53:37 <Axman6> yeah =)
17:53:53 <koala_man> jhance: how about something like   double* foo = malloc(128); float* bar = realloc(foo, 256);  ? 
17:54:01 <Axman6> and obviously using unsafePerformIO again you can writer cast :: a -> b easily
17:54:25 <eacameron> is there an infix operator that allows me to avoid "join" in "join (doSomething <$> a <*> b <*> c)"?  I'm imagining "doSomething <$!> a <*> b <*> c
17:54:32 <jhance> koala_man: I would agree that implicitly casting void * is a valid argument, but of course then you can say Dynamic exists too :P
17:55:17 <jhance> eacameron: it doesn't look too bad with join $
17:56:13 * hackagebot hyphenation 0.5 - Configurable Knuth-Liang hyphenation  http://hackage.haskell.org/package/hyphenation-0.5 (EdwardKmett)
17:56:21 <eacameron> jhance: maybe not, but the question still stands ;)
17:56:55 <Axman6> :t \f a b -> join (f <$> a <*> b)
17:56:56 <lambdabot> Monad m => (a2 -> a1 -> m a) -> m a2 -> m a1 -> m a
17:57:33 <kadoban> jhance: I don't really know Dynamic, but isn't the whole point that it has checks on it? If you do the wrong cast in C, it'll happily just let you crash.
17:58:19 <kadoban> (or worse, not crash, but just have undefined behavior)
17:58:21 <koala_man> jhance: I'm not familiar with Dynamic so I think I'm missing something. how is  Ptr Double -> Maybe (Ptr Float)  the same as Ptr Double -> Ptr Float  ?
17:58:23 <jhance> kadoban: Depends on what you mean by "checks". I define malbehavior as anything that gets to runtime, so its all the same to me.
17:59:15 <kadoban> jhance: Well, it certainly looks from the interface like it's safe. You either give it a default value that you'll get if the types are screwed up, or you get back a Maybe.
17:59:40 <jhance> kadoban: I guess you're right on that. I've never used it outside of statically-safe usages that involve Typeable.
17:59:43 <koala_man> if you do   fromDyn undefined  then yes
17:59:48 <kadoban> jhance: That'd be more like C++'s dynamic_cast than C casts, except it's encoded in the type system so you can't muck it up easily.
18:00:22 <kadoban> Gotta run :-/ back in a while.
18:00:53 <koala_man> someone here once said that unsafeCoerce is just a generalization of id. I'm still chuckling about that
18:07:32 <mikeplus64> woah, why is Query in postgresql-simple a Monoid?
18:08:09 <eacameron> mikeplus64: probably so it can be concatted like strings; I'll bet it's just a newtype around Text or something
18:08:51 <mikeplus64> it is, but the idea of having the newtype was expressly to prevent it being concatted like strings
18:09:03 <mikeplus64> "A query string. This type is intended to make it difficult to construct a SQL query by concatenating string fragments, as that is an extremely common way to accidentally introduce SQL injection vulnerabilities into an application."
18:09:07 <mikeplus64> :s
18:09:27 <Axman6> it's difficult to get aribtrary strings into it though, no?
18:09:42 <mikeplus64> it's also an IsString
18:09:44 <nick_____> I’m looking for a super simple code block that takes html as a string and returns a nested data structure(tagName, attrs, children). It’s been very difficult to find something simple. Thanks!
18:10:10 <mikeplus64> the monoid is the same as the bytestring monoid except wrapped in the newtype
18:10:23 <eacameron> yeah, that's what they all say ;)
18:11:01 <eacameron> it's terribly annoying when they're not monoids. And they're usually IsString instances, so you can just do fromString (... ++ ... ++ ...) anyway
18:11:26 <eacameron> "they" meaning Query types written by bos
18:12:02 <mikeplus64> oh well, time to abuse this so i don't have to write 2^4 individual queries
18:12:19 <Axman6> nick_____: tried tagsoup?
18:12:26 <Axman6> nick_____: https://hackage.haskell.org/package/tagsoup
18:12:37 <eacameron> mikeplus64: Exactly...everyone knows that meta-SQL is just a reality of life ;)
18:12:55 <eacameron> SQL basically forces you to do it a lot of times
18:13:01 <nick_____> Axman6: I have but I’ve only found complicated examples of arrows and such, way overkill for what I need and the docs have not been super helpful
18:13:14 <nick_____> (maybe arrows are required for my need, but deeply understanding them should not be)
18:13:18 <Axman6> nick_____: what do you want to do?
18:13:32 <Axman6> I'm using it in something and it's not using arrows at all
18:14:09 <eacameron> nick_____: I used tagsoup a while ago and it didn't have any arrows
18:14:40 <Axman6> Text.HTML.TagSoup.Tree is particularly nice
18:15:08 <nick_____> eacameron Axman6: basically this https://gist.github.com/ncammarata/c387cfd1ecd64987d19a 
18:15:57 <mauris> :t (<=<)
18:15:58 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
18:16:00 <Axman6> what is 'text' supposed to be?
18:16:05 <Axman6> the second String
18:16:13 <mauris> ^ any way to make lambdabot "plug in" ((->) r) for m?
18:16:14 <Axman6> also, that's exactly what Text.HTML.TagSoup.Tree gives you
18:16:32 <nick_____> it’s a text string that’s a child of the element that isn’t actually another element
18:16:47 <Axman6> tags may have several text elements
18:16:53 <Axman6> and their order is usually important
18:17:19 <nick_____> that’s true, probably not actually a great data structure. But as long as I get something close I can fit it into my usecase. I’ll take a look at TagSoup.Tree
18:18:00 <RustyShackleford> how do I get Ints to use floor division
18:18:08 <RustyShackleford> 3/2 = 1 instead of 1.5
18:18:18 <enthropy> > 3 `div` 2
18:18:19 <lambdabot>  1
18:18:23 <enthropy> > - 3 `div` 2
18:18:25 <lambdabot>  -1
18:18:26 <Axman6> RustyShackleford: that's the onloy way it's impoemented for Ints
18:18:37 <RustyShackleford> awesome
18:18:37 <Axman6> well, round towards zero anyway
18:18:50 <RustyShackleford> er, I don't follow you Axman6 
18:18:52 <enthropy> > (-3) `div` 2 -- actually towards -inf
18:18:54 <lambdabot>  -2
18:19:44 <nshepperd> > (-3) `quot` 2
18:19:46 <lambdabot>  -1
18:19:50 <Axman6> RustyShackleford: there's only two ways to divide Ints, div and quot, and I believe they both do that
18:20:03 <Axman6> > quotRem (-3) 2
18:20:05 <lambdabot>  (-1,-1)
18:20:14 <Axman6> > divMod (-3) 2
18:20:15 <lambdabot>  (-2,1)
18:20:25 <nshepperd> div rounds toward -inf, quot rounds toward 0
18:20:32 <RustyShackleford> okay, modular arithmetic?
18:20:37 <RustyShackleford> i guess we don't use the % operator
18:22:19 <Zemyla> Hmm. Can someone tell me the pros and cons of Parsec vs ReadP? Because ReadP looks very simple compared to Parsec, honestly.
18:22:26 <mikeplus64> RustyShackleford: mod
18:22:32 <mikeplus64> :t mod
18:22:33 <lambdabot> Integral a => a -> a -> a
18:23:03 <mikeplus64> > mod 7 5
18:23:04 <lambdabot>  2
18:23:34 <pacak> Zemyla: If  you need to parse something complex - use Parsec.
18:23:36 <geekosaur> Zemyla, it is. it's a somewhat slow and minimal parser to implement reads / read
18:23:44 <enthropy> Zemyla: ReadP doesn't do error messages (or parsing from not a string)
18:24:25 <Axman6> ReadP is quite difficult to get right IIRC
18:24:42 <nick_____> Axman6: I have it rendering a flat list(which is awesome!) using parseTag, but I want the data structure nested. Any ideas?
18:24:58 <Axman6> huh?
18:25:18 <Axman6> try using tagTree from Text.HTML.TagSoup.Tree
18:25:35 <enthropy> Axman6: it is? I'd say parsec is hard to get right because you need to throw try in / restructure things so that you don't need try
18:26:00 <Axman6> ReadP has many subtlties which only compiler writers seem to understand
18:26:43 <nick_____> Axman6: currently have this: https://cldup.com/EBG71yA-Y--3000x3000.png
18:27:17 <Axman6> in future, lpaste would be more appropriate than screenshots :P
18:27:17 <nick_____> it returns a single list but I wanted a nested data structure
18:27:28 <Axman6> yes, use tagTree from Text.HTML.TagSoup.Tree
18:27:29 <nick_____> okay, good to know. Thanks for being cool about it
18:27:45 <enthropy> Axman6: can you be more specific about what those subtleties are?
18:27:49 <Axman6> tagTree . parseTree
18:29:08 <Axman6> enthropy: maybe it's ShowS which is difficult, but isn't there lots of crap to deal with parens?
18:30:01 <enthropy> that would be Text.ParserCombinators.ReadPrec not ReadP
18:30:55 <nick_____> it works! Consider yourself virtually hugged Axman6 
18:31:53 <Zemyla> enthropy: Well, I like the basic structure of ReadP more than Parsec, which looks massively complicated?
18:32:16 <Axman6> virtual beer would be better next time 🍻
18:32:44 <Axman6> oh no, my emoji doesn't work :(
18:32:54 <Zemyla> I mean, I can use Parsec fine, no problem, but it feels like putting a jet engine in a coffee machine.
18:32:58 <pacak> Axman6: Works for me.
18:33:23 <Axman6> ah excellent. Something always breaks in the layers of irssi, mosh and Terminal.app
18:33:24 <pacak> Zemyla: a jet engine in a coffee machine is perfectly fine if you know what you are doing.
18:34:02 <pacak> Zemyla: https://www.youtube.com/watch?v=-fDM9Eb16Do 
18:34:09 <Axman6> Zemyla: Parsec is beautiful to use. once you've used it a few times you'll never want to do parsing with anything but parser combinators
18:34:49 <Zemyla> I know, but ReadP is a parser combinator.
18:34:54 <Axman6> ha, I immedfiately though of Colin Furze when you said that pacak 
18:35:10 <pacak> Axman6: And those parser combinators should be from attoparsec, since putting "try" all over the place is kind of annoying.
18:35:14 <Zemyla> Hell, if ReadS were a newtype instead of a type, it could be a perser combinator.
18:36:34 <Axman6> pacak: my poor speakers
18:40:31 <shachaf> Any idea who AlexET on the GHC Trac is?
18:40:41 <shachaf> (Maybe they're in this channel?)
18:44:25 <Lis> hello everyone. http://www.mathematek.de/paste:haskell_putstrln_io how to solve this error. i know putStrLn returns IO ()
18:46:50 <Xeironis> Lis: print arglist return IO String, not http://en.wikipedia.org/wiki/Special:Search?go=Go&search=String
18:46:54 <Xeironis> oops
18:47:06 <Xeironis> I meant [ [ String ] ]
18:47:13 <Xeironis> somewhere that got converted to wikipedia
18:47:43 <Xeironis> or rather, it returns IO ()
18:47:56 <Lis> ok, and what to change to solve that error?
18:48:02 <pacak> Xeironis: print is an IO action which returns ()
18:48:10 <Xeironis> yeah I just realized that
18:48:19 <Lis> i dont yet quite understand haskells syntax fully 
18:48:37 <Xeironis> Lis: change the type of runCommands to [String] -> IO ()
18:48:40 <Zemyla> How do I figure out the Church encoding of a type, particularly a recursive type?
18:48:47 <pacak> Lis: Your runCommands function should have type [String] -> IO ()
18:49:24 <Lis> ok, but why change the output type? i though a -> b means i have type a transformed to output type b
18:49:54 <pacak> Lis: It's not doing any  transformation. It performs IO action.
18:50:06 <pacak> :t print
18:50:07 <lambdabot> Show a => a -> IO ()
18:50:08 <Xeironis> Lis: print arglist has the type IO (), but your telling haskell that your function will return http://en.wikipedia.org/wiki/Special:Search?go=Go&search=String
18:50:10 <Xeironis> dammit
18:50:15 <Xeironis> [ [ String ] ]
18:50:39 <pacak> Xeironis: You seem to be obsessed with wikipedia.
18:50:56 <Xeironis> I suppose my client is
18:51:01 <Lis> hm ok, i need to think about that before i understand it. thank you
18:51:56 <oneeman> Lis: I've been reading Learn You A Haskell for Great Good recently, the chapter on IO there is good
18:52:22 <mauris> arguably print transforms an "a" into an IO action that prints it
18:52:57 <mauris> which is sometimes a very useful way to think about IO (to me at least)
18:53:34 <Lis> ah mauris that helped alot thank you
18:53:38 <Lis> and the rest :D
18:55:25 <mauris> like, consider this:
18:55:35 <mauris> > map print [1, 2, 3]
18:55:36 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>]
18:56:14 <mauris> that is a list of three IO actions: "printing a 1 followed by newline and yielding ()", "printing a 2 followed by newline and yielding ()", ...
19:00:00 <mauris> like so http://codepad.org/6WnG2S84
19:00:58 <mauris> or even http://codepad.org/Q3mKdQBd using:
19:01:01 <mauris> :t sequence_
19:01:02 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
19:05:10 <bitemyapp> http://www.reddit.com/r/haskell/comments/316hcm/month_in_haskell_mode_march_2015/ hi2 is pretty sweet btw
19:08:13 <RustyShackleford> so I'm not sure how to solve this one functionally
19:08:49 <RustyShackleford> I have an int with exactly one bit set. I want to return "index" of that bit
19:09:02 <RustyShackleford> where 0 is the LSB and 63 is the MSB
19:09:20 <pacak> RustyShackleford: IntMap.lookup ... 
19:09:24 <RustyShackleford> er, let me reviese that. There are either zero or exactly one bits
19:09:29 <roboguy_> RustyShackleford: probably want something from Data.Bits
19:10:14 <RustyShackleford> roboguy_: yeah i'm looking at that. testBit looks like what i want
19:10:43 <RustyShackleford> so how can I begin testing at the 0-th bit and iterate until I find the one that is set?
19:10:46 <roboguy_> or wait
19:10:49 <roboguy_> what about log?
19:11:07 <roboguy_> you should be able to do it constant time that way
19:11:34 <RustyShackleford> sorry I don't follow
19:12:04 <arkeet> use some bit scan thing.
19:12:13 <roboguy_> RustyShackleford: if y = b^x, then x = log_b(y)
19:12:21 <arkeet> what's log of an Int?
19:12:22 <roboguy_> and a bit pattern with one bit set is of the form 2^n
19:12:36 <roboguy_> arkeet: I'd convert
19:12:41 <arkeet> to what?
19:12:50 <RustyShackleford> oh thats an interesting way to do it
19:12:52 <RustyShackleford> maybe
19:12:52 <roboguy_> arkeet: Double should work, right?
19:12:58 <roboguy_> then back again?
19:13:01 <arkeet> I bet that's way slower than testing all 32/64 bits of your Int
19:13:08 <roboguy_> well, that might be true
19:13:18 <roboguy_> log isn't the fastest operation around
19:13:19 <solirc> athan: Did you manage to do what you tried to achieve with Hspec?
19:13:40 <athan> solirc: No :\
19:13:49 <athan> the logs don't give verbose information for me either
19:13:53 <solirc> athan: Hspec should do that
19:14:03 <kadoban> RustyShackleford: http://graphics.stanford.edu/~seander/bithacks.html might be interesting to you
19:14:05 <athan> Hmm, yeah I haven't had it working yet
19:14:13 <arkeet> I was just going to link that.
19:14:21 <kadoban> Heh
19:14:29 <solirc> athan: Where are you stuck?
19:14:29 <RustyShackleford> kadoban: bookmarked
19:14:40 <RustyShackleford> but yeah, this algorithm isn't horribly complicated
19:14:48 <RustyShackleford> i just don't know how to write it in haskell
19:14:48 <shachaf> edwardk has code for it using a fancy de Bruijn sequence thing.
19:14:59 <arkeet> you can just test with bitmasks like 01010101, 00110011, 00001111 (for 8 bits)
19:15:08 <arkeet> (for example)
19:15:16 <athan> solirc: I'm not stuck anymore, but I was getting an uncaught runtime exception, and hspec wasn't telling me what input caused it
19:15:20 <athan> or really, the data for the test case
19:15:26 <shachaf> https://github.com/ekmett/bits/blob/master/src/Data/Bits/Extras.hs
19:15:39 <shachaf> But that's more general than you need.
19:15:59 <solirc> athan: If you can provide an example that results in that issue, that would be appreciated
19:16:06 <solirc> athan: It was with QuickCheck?
19:16:07 <shachaf> (Counts leading zeros or something for ay Int, not just powers of 2.)
19:16:18 * hackagebot diagrams-core 1.2.0.6 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-1.2.0.6 (bergey)
19:16:20 * hackagebot active 0.1.0.19 - Abstractions for animation  http://hackage.haskell.org/package/active-0.1.0.19 (bergey)
19:16:22 * hackagebot diagrams-lib 1.2.0.9 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.2.0.9 (bergey)
19:16:24 * hackagebot force-layout 0.3.0.11 - Simple force-directed layout  http://hackage.haskell.org/package/force-layout-0.3.0.11 (bergey)
19:16:28 <athan> solirc: Yeah, it's with this package: https://github.com/athanclark/pseudo-trie
19:16:30 <solirc> athan: Which version of QC?
19:16:47 <athan> Not sure right now, actually, one sec
19:16:52 <monochrom> binary search on a binary number. I haven't thought of that.
19:16:55 <RustyShackleford> something like: map (testBit x) [0..63]
19:17:20 <RustyShackleford> test every bit, then find which number in that list is nonzero
19:17:27 <Zemyla> So what would the Church encoding of Parser s a = Partial (s -> Parser s a) | Done a look like?
19:17:29 <monochrom> "are you less than 2^16?" "no" "are you less than 2^24?" ...
19:17:31 <RustyShackleford> sorta gets me close
19:17:50 <athan> solirc: Shoot, do you know if there's a way to check the installed version of a package in a sandbox? :S
19:17:52 <arkeet> monochrom: that's a lot of branches.
19:18:15 <arkeet> oh.
19:18:16 <arkeet> better way.
19:18:18 <solirc> athan: cabal exec ghc-pkg list | grep QuickCheck
19:18:45 <arkeet> in general, lowestBitSet n = popCount (n .&. (n-1))
19:18:49 <athan> solirc: 2.7.6 :)
19:18:50 <arkeet> er
19:18:55 <arkeet> no.
19:19:10 <arkeet> but whateve.r
19:19:12 <solirc> athan: give me a second
19:19:15 <enthropy> if I have many WITH_FOO CPP macros, can they be used in a one-line way (not #ifdef WITH_FOO\n stuff using foo ... )?
19:19:18 <arkeet> if you know n has only one bit set, it's popCount (n-1)
19:19:20 <athan> :)
19:19:28 <pacak> :t countLeadingZeros
19:19:29 <shachaf> You can implement binary search without branches.
19:19:29 <arkeet> bit more work if you just want the lowest or highest bit set.
19:19:29 <lambdabot> FiniteBits b => b -> Int
19:19:44 <pacak> > 64 - countLeadigZeros 8
19:19:46 <lambdabot>      Not in scope: ‘countLeadigZeros’
19:19:46 <lambdabot>      Perhaps you meant ‘countLeadingZeros’ (imported from Data.Bits)
19:19:52 <RustyShackleford> arkeet: am i missing something? That would always return zero
19:20:06 <RustyShackleford> oh, i'm reading it wrong
19:20:09 <pacak> > 64 - countLeadingZeros 8
19:20:10 <lambdabot>      No instance for (FiniteBits b0)
19:20:10 <lambdabot>        arising from a use of ‘countLeadingZeros’
19:20:10 <lambdabot>      The type variable ‘b0’ is ambiguous
19:20:18 <pacak> > 64 - countLeadingZeros (8 :: Int)
19:20:19 <arkeet> RustyShackleford: ignore the lowestBitSet thign I wrote, it's wrong.
19:20:20 <lambdabot>  4
19:20:26 <pacak> Is that what you want?
19:20:32 <arkeet> just use popCount (n-1)
19:20:38 <shachaf> Oh, countLeadingZeros is in base now.
19:20:42 <athan> solirc: I'm not sure if that commit is the failing example, though. It _might_ be. The whole codebase is horrible atm, please try to not cringe :\
19:21:04 <solirc> athan: here is a basic example https://gist.github.com/sol/03992863f632ade8347e
19:21:05 <RustyShackleford> arkeet: that is cool
19:21:18 * hackagebot diagrams-contrib 1.1.2.6 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.1.2.6 (bergey)
19:21:20 * hackagebot diagrams-postscript 1.1.0.5 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.1.0.5 (bergey)
19:21:20 <RustyShackleford> i'd feel way smarter if I figured that out myself :/
19:21:22 * hackagebot diagrams-rasterific 0.1.0.8 - Rasterific backend for diagrams.  http://hackage.haskell.org/package/diagrams-rasterific-0.1.0.8 (bergey)
19:21:24 * hackagebot diagrams-svg 1.1.0.5 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-1.1.0.5 (bergey)
19:21:30 <solirc> athan: Here Hspec prints the exception 
19:21:50 <arkeet> RustyShackleford: well I only came up with it because I've done some bit twiddling stuff before.
19:21:51 <solirc> athan: and the generated Int that result in the exception
19:22:29 <solirc> athan: If you have a case where exceptions are not handled like this, then it may be a bug and we would want to fix it
19:22:31 <arkeet> I suppose, if you want the lowest set bit in general, you'd use uh
19:22:43 <arkeet> popCount (complement n .&. (n-1)), I think that do esit.
19:22:55 <RustyShackleford> arkeet: i could probably pick a better chess representation, but twiddling with bits is kinda fun
19:23:04 <athan> solirc: This looks nearly identical: https://github.com/athanclark/pseudo-trie/blob/master/test/Data/Trie/PseudoSpec.hs
19:23:16 <arkeet> > map (popCount (complement n .&. (n-1))) [0 :: Word32 ..]
19:23:17 <lambdabot>      Couldn't match expected type ‘Word32 → b’ with actual type ‘Int’
19:23:17 <lambdabot>      Possible cause: ‘popCount’ is applied to too many arguments
19:23:17 <lambdabot>      In the first argument of ‘map’, namely
19:23:29 <arkeet> > map (\n -> popCount (complement n .&. (n-1))) [0 :: Word32 ..]
19:23:31 <lambdabot>  [32,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,...
19:23:38 <solirc> athan: I'm looking at your code now
19:23:54 <arkeet> > map (\n -> popCount (n-1)) [0 :: Word32 ..]
19:23:55 <lambdabot>  [32,0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,...
19:24:08 <solirc> athan: which version of Hspec do you use, btw?
19:24:15 <arkeet> of course they coincide on powers of 2.
19:24:34 <pacak> :t countTrailingZeros
19:24:35 <lambdabot> FiniteBits b => b -> Int
19:24:42 <arkeet> > popCount (-1 :: Integer)
19:24:43 <lambdabot>  -1
19:24:48 <arkeet> > popCount (-100 :: Integer)
19:24:49 <lambdabot>  -3
19:24:54 <arkeet> :/
19:24:54 * pacak pokes lambdabot
19:25:02 <athan> solirc: 2.1.5  (sorry, it's a mess :\)
19:25:07 <arkeet> that doesn't even make sense.
19:25:20 <arkeet> > popCount (-1 :: Int)
19:25:22 <lambdabot>  64
19:25:29 <arkeet> that makes sense.
19:26:18 * hackagebot diagrams-canvas 0.3.0.4 - HTML5 canvas backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-canvas-0.3.0.4 (bergey)
19:26:19 <solirc> athan: Ok, trying your code, Hspec tells me which spec item fails
19:26:20 * hackagebot diagrams-builder 0.6.0.4 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.6.0.4 (bergey)
19:26:22 * hackagebot diagrams-haddock 0.2.2.14 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.2.14 (bergey)
19:26:29 <solirc> athan: It also prints the exception
19:26:31 <arkeet> anyway x86 provides a BSF instruction which is really what ought to be used here.
19:26:54 <solirc> athan: But it does not print the generated value that made the test fail
19:26:58 <athan> solirc: ?_?
19:27:05 <athan> ahh yes!
19:27:13 <solirc> athan: Is this your concern?
19:27:15 <athan> that's the issue I was facing
19:27:22 <solirc> ok
19:27:33 <athan> solirc: Was my description of the issue wrong? Sorry
19:28:06 <solirc> athan: May it be that the exception is throws while the value is generated?
19:28:18 <solirc> athan: Say a bug in the arbitrary instance?
19:28:33 <athan> solirc: No, it shouldn't be. The Arbitrary instance is simple
19:28:50 <athan> The exception actually comes from Data.List.NonEmpty.fromList
19:28:56 <athan> when the input is actually empty
19:28:59 <arkeet> RustyShackleford: oh yeah, I guess you can just use countTrailingZeros now if you have ghc 7.10
19:29:13 <arkeet> I would hope that uses bsf on x86
19:29:42 <RustyShackleford> arkeet: i don't have it yet
19:29:51 <RustyShackleford> your method works beautifully though, thanks
19:30:09 <Zemyla> Hmm. Would the type wind up being forall r. ((s -> r) -> r) -> (a -> r) -> r?
19:30:41 <arkeet> or tzcnt I guess
19:30:51 <arkeet> the only difference is what they do when passed 0 
19:30:56 <arkeet> (bsf of 0 is undefined)
19:30:58 <shachaf> The type of what?
19:31:12 <solirc> athan: if you use (==) instead of (===) it seems to work
19:32:17 <vers> Hi all, I'm a Haskell beginner and have never used IRC before so excuse me if I'm doing this wrong, but could I ask a question about using the error monad?
19:32:23 <arkeet> yes, just ask
19:32:31 <athan> solirc: That's interesting! So, I would need the result to be a plain Bool?
19:33:15 <solirc> athan: For now you could just change (===) to (==) and the result type from Property to Bool, yes
19:33:18 <pacak> vers: A monad is just a monoid in the   category of endofunctors, what's the   problem?
19:33:24 <vers> cool, so I'm working on a basic interpreter for a programming language and I'm trying to use the Error monad in my `eval` function
19:33:45 <monochrom> pacak, that joke gets old, and it doesn't help
19:33:51 <athan> solirc: Thank you. I hope this error is at least important, sorry for the trouble
19:34:01 <vers> i have something like `eval (Binary binExp) = evalBinOp binExp`
19:34:50 <vers> actually, it's probably easier if i just link to the code: https://github.com/apollo-lang/apollo/blob/master/src/Eval.hs
19:34:59 <arkeet> yes, that would be good
19:35:45 <vers> so the line I'm talking about is 10: it will call `evalBinOp` which will call `getInt`, say
19:35:56 <solirc> athan: You are welcome
19:36:02 <solirc> athan: Thanks for pointing this out
19:36:10 <athan> :)
19:36:12 <solirc> athan: It may be a bug or missing feature in hspec
19:36:19 <solirc> still investigating
19:36:22 <arkeet> vers: mhm
19:36:22 <Zemyla> How long has ReadP been a codensity monad?
19:36:32 <vers> so I'm trying to change eval to be of type `eval :: Expr -> Either ApolloError Expr` where ApolloError is a datatype for my lang, Apollo
19:37:14 <pacak> vers: (You can probably use some GADTs to avoid "expected ApolloInt" stuff)
19:37:44 <roboguy_> Zemyla: I think it always has been
19:38:04 <wyager> Is there any effort to replace standard prelude functions with more general versions? E.g. change map from "(a -> b) -> [a] -> [b]" to "Functor f => (a -> b) -> f a -> f b" or sum from "Num a => [a] -> a" to "Foldable f, Num a => f a -> a"
19:38:30 <arkeet> wyager: map will stay as it is because Prelude already has fmap. sum is already generalized in ghc 7.10
19:38:31 <vers> pacak: GADT just meaning an algebraic datatype?
19:38:42 <arkeet> vers: a generalized algebraic datatype
19:39:01 <Zemyla> roboguy_: Jeez.
19:39:02 <wyager> arkeet: Why not replace map with fmap? That would be quite nice, aesthetically, and would reduce some code
19:39:11 <pacak> vers: http://en.wikibooks.org/wiki/Haskell/GADT 
19:39:25 <pacak> vers: They are covering example similar to yours
19:39:26 <roboguy_> Zemyla: ?
19:40:17 <Zemyla> roboguy_: Sorry, I was just kind of replying. But that's kind of wow. How long has codensity been a thing?
19:40:31 <vers> pacak: ah okay, thank you! I don't think I've encountered GADTs before so I'll do some reading
19:41:40 <roboguy_> Zemyla: I don't know if it would have necessarily always been called codensity in that context. I think it's just a bit of a generalization of difference lists, which have been around for a very long time
19:43:10 <vers> pacak: the problem I was anticipating is having to handle a `Left` value in line 37 and 42 where `eval` is called; I'm not sure how I would deal with it here. Do you think I'll have a better idea of this once I understand GADTs? Sorry if this is too vague a question.
19:43:13 <roboguy_> I think it just reassociates the operation call tree to the right (I believe)
19:43:40 <pacak> vers: No, it's unrelated to GADTs
19:44:26 <pacak> vers: But you won't need getInt once you use them. So try first.
19:44:56 <roboguy_> Zemyla: also, coincidentally, I just realized something earlier today: I think continuations are Codensity with the identity functor
19:45:03 <vers> pacak: okay will do. Thanks!
19:45:42 <arkeet> vers: GADTs let you encode more invariants at the type level (e.g. the argument to Not *must* be some Bool)
19:46:00 <arkeet> which would remove the need for some error checks
19:46:56 <arkeet> but if you want to proceed with using Either, then there's no need to read about GADTs.
19:47:03 <arkeet> (they're worth reading about though!)
19:47:27 <arkeet> anyway
19:48:21 <Zemyla> roboguy_: Not quite. Continuations aren't forall-quantified.
19:48:47 <roboguy_> Zemyla: IIRC they should be, though, in theory. I think they are not because of a limitation of the type system
19:49:07 <vers> arkeet: ah definitely, that sounds a lot cleaner. I'll look into them now, thanks for the explanation!
19:49:27 <arkeet> ok. are you still interested in knowing how to use Either, though?
19:50:14 <arkeet> or you can come back and ask later. :)
19:50:59 <vers> arkeet: sure, if you don't mind indulging me. I don't have terribly specific questions so much as I don't know what I would do if I were to proceed without GADTs
19:51:10 <arkeet> okay.
19:51:18 <pacak> arkeet: He is gone traveling by The True Path and you won't be able to seduce him with Either monad!
19:51:23 <roboguy_> Zemyla: Yeah, I think Oleg talks about that here http://okmij.org/ftp/continuations/undelimited.html
19:51:24 <arkeet> haha
19:51:24 <dolio> If G -| F, then Codensity G is the monad GF. Identity -| Identity, so Codensity Identity is the Identity monad.
19:51:32 <arkeet> anyway, so your types of things would look like
19:51:50 <arkeet> eval :: Expr -> Either Error Expr
19:51:56 <arkeet> getInt :: Expr -> Either Error Int
19:51:58 <arkeet> and stuff, right?
19:52:08 <dolio> Which, presumably, is not the continuation monad.
19:52:14 <athan> For recursive functions over (rose) trees, I'd like to both accumulate, and "look ahead", if that's possible. Does anyone have suggestions for designing such functions?
19:52:23 <roboguy_> dolio: hmm, does the fact that forall r. (a -> r) -> r ~= a come into play here at all?
19:52:31 <athan> I'm just having some issues making "pruning" functions
19:52:41 <dolio> Yes, that is the same statement.
19:53:12 <arkeet> actually I'm going to go get food, bbl
19:53:17 <roboguy_> dolio: isn't forall r. (a -> r) -> r essentially a continuation except the type system won't quite let you write callCC properly?
19:53:24 <vers> arkeet: ah okay, no worries
19:53:33 <dolio> In what sense is it a continuation monad, then?
19:53:49 <solirc> athan: it's a  bug in QuickCheck
19:53:52 <roboguy_> I guess it wouldn't be
19:53:55 <athan> solirc: !!
19:56:19 * hackagebot warp 3.0.11 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.11 (MichaelSnoyman)
19:57:12 <roboguy_> dolio: my first inclination is that a continuation shouldn't need to care what r is, but I guess that would preclude an implementation of callCC, so it wouldn't really be a continuation
19:58:02 <dolio> I'm not sure quantifying with for all is the right way to 'not care' what r is.
19:58:31 <roboguy_> hmm
20:01:20 * hackagebot wai-app-static 3.0.1 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-3.0.1 (MichaelSnoyman)
20:03:12 <dolio> I'm not sure that oleg blurb is really on target, either.
20:03:44 <dolio> He says that Cont is delimited continuations without any explanation, really.
20:04:33 <dolio> Presumably he means that it is delimited by wherever you unwrap the type and use it.
20:04:53 <dolio> But that seems like it's missing the point.
20:05:28 <dolio> Because the use of monads in Haskell is typically to have embedded languages.
20:06:41 <dolio> And the embedded language has undelimited call/cc. It's just that the scope of the continuation it's capturing isn't magically the entire remainder of your Haskell program, it's the remainder of the embedded program.
20:07:17 <dolio> Although you can also use it in a way that is like delimited continuations.
20:07:57 <johnw> dolio: does "delimited" in this context mean that the extent of the contituation is from some position up to a delimiter?
20:08:23 <dolio> Yes.
20:08:33 <dolio> Delimited continuations (typically?) have two operators.
20:08:38 <johnw> then does Oleg mean that "runCont" implies that delimiter?
20:08:39 <roboguy_> That would be with shift and reset right?
20:08:47 <dolio> reset and shift. Shift captures up to enclosing resets.
20:08:59 <dolio> johnw: Yeah.
20:09:37 <dolio> And if you use them that way, then Cont is a lot like shift, and reset m = runCont m id.
20:09:58 <johnw> right, that makes sense
20:10:08 <dolio> There's a little more manual stuff than most presentations, but it's a lot like delimited continuations.
20:10:48 <johnw> you even say that in your fpco article
20:10:55 <johnw> https://www.fpcomplete.com/user/dolio/monad-transformers-and-static-effect-scoping
20:11:12 <dolio> That's using them fairly differently than just having an embedded language with a call/cc operation, though.
20:11:18 <dolio> Yeah.
20:12:14 <dolio> It's the same difference as using catch vs. using runErrorT or whatever to catch your exceptions.
20:13:11 <Zemyla> How does callCC work if ContT is wrapping an IO monad? Can it read from stdin, then escape so the reading hasn't happened yet?
20:13:48 <dolio> No. But it can't do that in scheme, either, no?
20:13:57 <johnw> Zemyla: any effects that have happened have happened
20:14:04 <johnw> any in the continuation have yet to happen
20:14:27 <johnw> if you capture the continuation and renter it multiple times, you multiply the effect
20:21:21 * hackagebot gitit 0.10.6.2 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.10.6.2 (JohnMacFarlane)
20:23:13 <solirc> athan: https://github.com/nick8325/quickcheck/issues/48
20:26:21 * hackagebot wai-app-file-cgi 3.0.6 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-3.0.6 (KazuYamamoto)
20:31:21 * hackagebot wai-app-file-cgi 3.0.7 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-3.0.7 (KazuYamamoto)
20:36:21 * hackagebot filediff 0.1.0.0 - Diff and patch module  http://hackage.haskell.org/package/filediff-0.1.0.0 (bgwines)
20:36:23 * hackagebot mighttpd2 3.2.7 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.2.7 (KazuYamamoto)
20:41:22 * hackagebot ide-backend 0.9.0.5 - An IDE backend library  http://hackage.haskell.org/package/ide-backend-0.9.0.5 (MichaelSnoyman)
20:41:24 * hackagebot ide-backend-common 0.9.0.1 - Shared library used be ide-backend and ide-backend-server  http://hackage.haskell.org/package/ide-backend-common-0.9.0.1 (MichaelSnoyman)
20:43:26 <ublubu> http://chrisdone.com/posts/structured-haskell-mode-screencasts does anyone have a guide on how to use shm? chrisdone's youtube videos are private
20:55:00 <RustyShackleford> i haven't programmed this much in ages
20:55:06 <RustyShackleford> today was a good day...
20:55:14 <RustyShackleford> although now my brain is totally fried
20:55:28 <bramgg> RustyShackleford: grats :)
20:55:51 <athan> RustyShackleford: Get those fingers beefy
20:56:22 <bramgg> The best days for me are when I produce the most code... It means everything just worked
20:56:23 * hackagebot json-autotype 0.2.5.13 - Automatic type declaration for JSON input data  http://hackage.haskell.org/package/json-autotype-0.2.5.13 (MichalGajda)
20:57:42 <athan> Can look-ahead be facilitated through back-tracking, in terms of a fold?
20:58:33 <RustyShackleford> i got so much of this project done!
20:58:38 <RustyShackleford> with tests too!
20:58:43 <athan> (where back-tracking is just the idea of having a "temporary" accumulator that changes on a condition)
20:58:52 <athan> RustyShackleford: Lucky :(
20:59:02 <RustyShackleford> but yeah, the big hurdle was learning haskell, cabal, and hspec all at the same time
20:59:07 <ublubu> anyone here use structured-haskell-mode?
20:59:13 <RustyShackleford> it's not just the language, but tools and frameworks too
20:59:32 <athan> RustyShackleford: Have you heard of `hi`?
20:59:37 <RustyShackleford> i have not
20:59:43 <athan> @hackage hi :)
20:59:43 <lambdabot> http://hackage.haskell.org/package/hi :)
21:01:44 <RustyShackleford> am I the only one who has no clue how to use lambdabot?
21:01:48 <RustyShackleford> it's kinda cool
21:03:04 <RustyShackleford> woah thats pretty cool actually
21:03:13 <RustyShackleford> but at this point I alread did it all manually
21:03:34 <Zemyla> Also, how do you use the bytecode interpreter in GHC?
21:03:53 <bramgg> > 2 + 1 -- I think lambdabot works like this
21:03:55 <lambdabot>  3
21:04:12 <bramgg> > putStrLn "YUP :)"
21:04:13 <lambdabot>  <IO ()>
21:04:23 <bramgg> lol
21:06:14 <johnw> it is a natural to think that putStrLn prints something, but it does not; it defines an action that prints something when executed by the runtime
21:06:46 <johnw> (or rather, given a string, it defines an action that prints that string)
21:10:03 <cfoch> o/
21:10:15 <cfoch> does active>=0.2 exist?
21:11:55 <mniip> johnw, that's exactly what it does
21:12:12 <mniip> 'String -> IO ()' is a function that takes a string and returns an action
21:12:42 <johnw> is there a library which explores the utility of Monoid m => (m, a)?
21:13:13 <bananagram> like writer?
21:13:18 <pavonia> cfoch: Only on GiHub
21:13:27 <bwiklund> can anyone shed some light on how `error` automagically satisfies any type constraint in a function?
21:13:34 <bwiklund> is it just language-level trickery
21:13:58 <johnw> bananagram: dunno why I wasn't thinking straight
21:14:13 <cfoch> I see
21:17:13 <solirc> RustyShackleford: If there is anything on Hspec to improve the situation then please tell me, open issues and pull requests ;)
21:17:22 <Zemyla> bwiklund: The "bottom" value with nonreturning and error values is of amy type.
21:17:49 <bwiklund> what do you mean by bottom
21:17:53 <bwiklund> :t error
21:17:54 <lambdabot> [Char] -> a
21:18:13 <bwiklund> i'm a relative noob btw
21:18:14 <Zemyla> Actually, bwiklund, there's an easier way to explain it.
21:18:51 <Zemyla> If there were a type that error couldn't be, then a value of that type would never have an error and wouldnalways terminate.
21:19:04 <bwiklund> mind blown
21:19:11 <Zemyla> That is clearly impossible, so error must be every type.
21:19:17 <shachaf> i,i Int#
21:19:51 <bwiklund> still, is the fact that error can satisfy any type
21:19:54 <bwiklund> automatic and magical
21:20:20 <Zemyla> Okay, do you know the fix function?
21:20:21 <bwiklund> like, you couldn't implement a function like that in userland
21:20:25 <bwiklund> not yet
21:20:28 <bwiklund> :t fix
21:20:29 <lambdabot> (a -> a) -> a
21:20:45 <Zemyla> :t fix id
21:20:46 <lambdabot> a
21:21:02 <Zemyla> fix id is an infinite loop that never returns.
21:21:19 <monochrom> but you can implement non-termination
21:21:46 <pacak> :t fix (const 42)
21:21:47 <lambdabot> Num b => b
21:22:30 <bwiklund> ill read up on fix
21:22:33 <bwiklund> hadn't seen it before
21:23:02 <monochrom> bwiklund: http://perl.plover.com/classes/OOPSLA/samples/slide064.html (and onwards) is easier
21:23:07 <Zemyla> Well, fix id is basically just another term for let x = x in x.
21:23:16 <Zemyla> Ah, yeah, or that.
21:24:58 <c_wraith> :t fix . const
21:24:59 <lambdabot> c -> c
21:25:13 <c_wraith> :t fix (fix . const)
21:25:14 <lambdabot> a
21:26:07 <vers> pacak: any chance you're still around? I've been playing with GADTs but I have a few questions on using them
21:26:12 <bwiklund> thanks for the tips guys
21:26:28 <pacak> vers: Don't ask to ask. Just ask. Other people might reply.
21:26:32 <Zemyla> What questions do you have?
21:26:39 <vers> okay!
21:27:03 <vers> so let's say I have a type as follows: data Expr a where [...]
21:27:51 <vers> if I have a type that can contain an Expr, say `data Stmt = StExp Expr`, I have to change it now
21:28:23 <pacak> data Stmt a = StExp (Expr a)
21:28:34 <vers> but if I do `data Stmt = StExp Expr a`, the compiler complains that there is no type variable 'a' in scope
21:28:40 <vers> oh
21:29:02 <vers> that was my follow up question haha. So any type that can contain an Expr needs a type variable now, yeah?
21:29:16 <Zemyla> Or with a specific a, like data Stmt = StExp (Expr Int).
21:29:24 <pacak> Or you can have data Stmt = StExpBool (Expr Bool) | StExpInt (Expr Int)
21:29:54 <vers> that seems to make sense
21:31:08 <vers> so let's say one constructor for Expr a is `ApolloChord :: [Pitch] -> Duration -> <??>`; since this constructor doesn't evaluate to a type like `Expr Int`, would <??> just be `Expr a`?
21:32:32 <pacak> Hmmm... It might as well be Expr ()
21:33:21 <pacak> That depends on how you want to constrain  it's uses and how it composes with other constructors.
21:33:55 <vers> is that in effect the same thing as `Expr` as a normal ADT, in that it can't be substituted for some other type?
21:34:52 <pacak> ಠ~ಠ
21:35:11 <pacak> As far as ghc is concerned Expr () and Expr Int are two different types
21:35:25 <pacak> And you can't have a list with both of them.
21:35:37 <vers> right
21:36:36 <vers> but could I, say, redefine any function that takes some kind of Expr a (ie. Expr Int) as taking Expr ()?
21:36:53 <vers> so Expr () is less constraining?
21:38:00 <pacak> To change it from taking any Expr to specific Expr?
21:38:53 <vers> yeah, I guess that's my question: does Expr () mean "any Expr" (which can include specific Expr's)
21:39:07 <pacak> Expr () means only one type - Expr ()
21:39:25 <pacak> Expr a - means for any a, but you can't do much with it since you don't know it's type.
21:39:56 <vers> ah okay, so I couldn't have a list of Exprs of different types, say, right?
21:40:24 <pacak> You can have a list of type [Expr a]
21:40:42 <pacak> But not with different types.
21:40:55 <pacak> Just look for more examples and play around with them.
21:41:04 <vers> Okay, I will, thanks
21:42:20 <vers> Just trying to figure out how to represent what used to be `Expr = FnCall Id [Expr]` now since the `[Expr]` part represents a list of arguments that can be of different types; I'm not sure how this would be done now with GADTs
21:42:33 <vers> whoops not different types sorry
21:42:57 <vers> I mean of different constructors of type Expr which can themselves contain Ints, Bools, etc
21:43:19 <pacak> Typeable a => FnCall Id [Expr a]
21:43:25 <pacak> Something like that I guess
21:44:34 <vers> hm okay. thanks!
21:44:38 <pacak> So your functions can take arbitrary number of arguments?
21:44:56 <vers> Yep
21:45:32 <pacak> And they can be of arbitrary types?
21:45:37 <vers> Right
21:45:44 <pacak> Magic.
21:46:04 <vers> Hm maybe I'm explaining wrong then lol
21:46:25 * hackagebot buildbox 2.1.6.1 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-2.1.6.1 (BenLippmeier)
21:46:27 * hackagebot pinboard 0.6.3 - Access to the Pinboard API  http://hackage.haskell.org/package/pinboard-0.6.3 (jonschoning)
21:46:37 <pacak> vers: Can you give some examples of those functions?
21:47:55 <vers> pacak: like Java for example; you can define functions with any number of args of any type
21:48:20 <pacak> Java?????? http://www.themarketingmoron.com/wp-content/uploads/2013/05/outta-here.jpg
21:48:49 <vers> pacak: ha I'm just saying that's the same idea for my lang!
21:49:05 <vers> pacak: I'd have used python as an example but there's only one type in python, technically
21:49:19 <bramgg> what is happening to irccloud
21:49:36 <pacak> bramgg: Somebody mentioned java.
21:50:06 <bramgg> haha
21:50:31 <vers> lol ugh
21:55:24 <platz> you can solve the expression problem in java https://oleksandrmanzyuk.wordpress.com/2014/06/18/from-object-algebras-to-finally-tagless-interpreters-2/ 
21:58:50 <platz> try that in clojure
22:04:03 <lpaste> hnfmr pasted “Persistent code error” at http://lpaste.net/130066
22:04:30 <hnfmr> i am having trouble making the above Persistent code work, it's pretty standard
22:04:50 <hnfmr> the error msg:`
22:05:19 <lpaste> hnfmr pasted “Error output persist.TH” at http://lpaste.net/130067
22:05:54 <hnfmr> I am following the Persistent tutorial in Beginning Haskell book and the first code snippet doesn't work :/
22:06:58 <hnfmr> can anyone briefly look at it and point to me the cause of the error?
22:06:59 <pacak> hnfmr: "Use MultiParamTypeClasses if you want to allow more."
22:07:43 <hnfmr> I try to add that pragma, I get a new error message
22:08:10 <lpaste> hnfmr pasted “Persist error continued” at http://lpaste.net/130068
22:08:17 <pacak> Just make sure you are using all the pragmas from that example.
22:08:56 <pacak> "Try GeneralizedNewtypeDeriving for GHC's newtype-deriving extension"
22:10:22 <hnfmr> pacak: That seems to have worked! It's perplexing...
22:21:27 * hackagebot ide-backend 0.9.0.6 - An IDE backend library  http://hackage.haskell.org/package/ide-backend-0.9.0.6 (MichaelSnoyman)
22:21:29 * hackagebot ide-backend-common 0.9.1 - Shared library used be ide-backend and ide-backend-server  http://hackage.haskell.org/package/ide-backend-common-0.9.1 (MichaelSnoyman)
22:43:38 <ReinH> hnfmr: I suppose now isn't the best time to mention that that book is low quality
22:44:14 <ReinH> hnfmr: wait, maybe that isn't the book I'm thinking of
22:44:25 <ReinH> which Beginning Haskell book?
22:44:40 <ReinH> Oh wait. It is.
22:44:45 <ReinH> Yeah, not the best book, unfortunately.
22:46:37 <johnw> a beginning haskell book dealing with template haskell and MPTC?
22:48:30 <ReinH> johnw: it's not a very good book :(
22:48:48 <johnw> no, I'd call that a disservice both to the reader and to Haskell
22:48:56 <ReinH> johnw: and examples that don't compile aren't the only problem
22:49:38 <ReinH> It's a shame
22:50:11 <jle`> dishonor on that book
22:51:30 * hackagebot repa 3.4.0.1 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-3.4.0.1 (BenLippmeier)
23:08:03 <Darwin226> Hey guys. I've heard many times people refering to argument of a function as "in positive/negative position". Where can I read more about this concept?
23:11:13 <johnw> Darwin226: that's a really good question
23:12:00 <Darwin226> johnw: Is it? Why?
23:12:45 <johnw> well, I'm familiar with it, but I don't think I've ever actually read it anywhwere
23:12:55 <johnw> I think what I've learned of it come through this channel, actually
23:13:56 <lf94> ...what
23:14:06 <lf94> What does that even mean
23:14:12 <Darwin226> johnw: Scala calls this varience (I think) but since that name clashes with absolutely everything ever, it's not really googlable
23:14:15 <lf94> an argument in a negative position
23:14:23 <lf94> oh
23:14:25 <lf94> you mean like
23:14:29 <johnw> given a function f :: a -> b, a is in negative position
23:14:32 <lf94> (arg1, arg2, varargs...)
23:14:39 <johnw> it's what the function "doesn't have"
23:14:41 <lf94> mmmm
23:14:55 <lf94> what is positive
23:15:02 <johnw> b
23:15:20 <johnw> or, (a -> b) -> c, a is now double negative, and so positive.  But we say it's not "strictly positive"
23:20:30 <jle`> there's a nice writeup i just read last week
23:21:28 <Zemyla> johnw: I think I know why a double negative is a positive.
23:23:17 <Zemyla> Imagine a function f :: forall r. (a -> r) -> r. It takes a function from a to any type r, and returns a value of that same type r.
23:23:59 <Zemyla> It basically has to be f = ($ a) for some a, and by passing it id you can see what a it is.
23:24:13 <Zemyla> f is in some sense equivalent to a.
23:24:27 <johnw> :t flip ($)
23:24:28 <lambdabot> a -> (a -> c) -> c
23:24:43 <Zemyla> Also, another reason:
23:25:30 <johnw> yes, ($ a) is isomorphic to a (exercise: prove that it is so)
23:25:31 <Zemyla> @djinn (a -> b) -> ((a -> x) -> y) -> (b -> x) -> y
23:25:31 <lambdabot> f a b c = b (\ d -> c (a d))
23:26:17 <Zemyla> It's a functor, not a contrafunctor.
23:26:26 <johnw> yep
23:26:49 <scott> johnw: do you know of a situation where the strictly positive distinction matters?
23:27:03 <arkeet> composition of two contravarant functors gives a covariant functor.
23:27:20 <johnw> trying to find an existence proof of (a -> False) -> False
23:27:52 <Zemyla> But yeah, aToF a = ($ a). fToA f = f id. That is an isomorphism.
23:29:41 <scott> johnw: so what does knowing `a` is non-strictly positive tell us?
23:29:44 <johnw> scott: that is, trying to prove: ((a -> False) -> False) -> a
23:30:17 <johnw> whereas proving a -> ((a -> False) -> False) is trivial
23:30:18 <scott> I know we can't undo double negation, but I'm not sure what the positivity tells us
23:30:36 <johnw> the positivity means you know which a you're talking about
23:30:54 <johnw> non-strict positivity involves some kind of choice
23:32:25 <johnw> here's one article on it: http://blog.ezyang.com/2012/09/y-combinator-and-strict-positivity/
23:32:36 <scott> thanks
23:35:26 <johnw> also, in languages Agda, strict positivity of recursive data types becomes essential
23:35:30 <johnw> like Agda*
23:35:48 <dolio> That's probably debatable.
23:35:54 <johnw> debate!
23:36:00 <dolio> But it's done most of the time.
23:36:23 <johnw> I mean, you can't define a non-strictly positive recursion data type, right?
23:36:28 <johnw> or are there cases where that is possible?
23:36:29 <dolio> Strictly positive types are enforced because they have set theoretic models.
23:36:46 <dolio> And non-strictly positive types don't.
23:36:50 <johnw> ah
23:37:03 <dolio> The latter might also require some care, I'm not totally sure.
23:37:31 <dolio> But you could have a theory with them.
23:37:39 <johnw> interesting
23:37:48 <dolio> System F has encodings of non-strictly positive types, for instance.
23:37:49 <shachaf> That post doesn't mention that this is an application of Curry's paradox.
23:39:15 <shachaf> Anyway, these sorts of restrictions generally prevent invalid programs as well as valid ones.
23:40:35 <scott> intuitively, I want to say strictly positive types are 'actually there' in the enclosing type in some sense (even if it's zero values, like in an empty list), whereas non-strictly positive types are not necessarily there
23:41:11 <scott> like (a -> False) -> False doesn't actually contain an `a` in a way we can recover it
23:41:32 <shachaf> What about forall r. (A -> r) -> r?
23:41:36 <shachaf> Is that strictly positive?
23:42:05 <dolio> No.
23:42:19 <johnw> forall a r, ((a -> r) -> r) -> a. is just as unprovable
23:42:20 <scott> I allowed for that with the words "not necessarily", I think
23:42:58 <arkeet> johnw: but not forall a. (forall r. (a -> r) -> r) -> a
23:43:03 <johnw> right
23:43:18 <dolio> Anyhow, there are certain surprising things you can get out of positive types (in general).
23:43:52 <dolio> Like, I think 'data N = Roll ((N -> Bool) -> Bool)' is equivalent to the natural numbers.
23:43:58 <johnw> arkeet: using that rank-2 type, it's not not provable
23:45:00 <dolio> At least, in the right theory.
23:45:24 <shachaf> dolio: How does that work?
23:45:36 <dolio> I don't remember.
23:46:07 <arkeet> it sounds bigger than the natural numbers.
23:46:54 <dolio> However, I know that if you interpret types as topological spaces, and function spaces as spaces of continuous maps (I think) the natural numbers are equivalent to that functional type over the natural numbers.
23:46:58 <dolio> So that model validates it.
23:47:31 <dolio> Nat ~= ((Nat -> Bool) -> Bool)
23:47:56 <shachaf> How does that work?
23:47:59 <arkeet> but that's the same as N ~= (N -> Bool)
23:48:06 <arkeet> so let's just think about that
23:48:17 <dolio> No, it is not the same as that.
23:48:29 <arkeet> why not?
23:48:37 <arkeet> just iterate twice.
23:50:09 <dolio> Knowing that N ~= ((N -> Bool) -> Bool) doesn't allow you to derive that N ~= (N -> Bool).
23:50:34 <arkeet> so?
23:50:54 <dolio> Which is good, because Cantor's diagonal argument means that N ~= (N -> Bool) is false.
23:51:54 <arkeet> if I define data N' = N' (N' -> Bool)
23:51:59 <arkeet> I assume we're ignoring botoms.
23:52:04 <arkeet> why is it not isomorphic to the N you defined earlier?
23:52:29 <dolio> You aren't allowed to make that definition. It is not a positive type.
23:53:02 <dolio> You could have a system that allowed positive types, but disallowed negative types.
23:53:23 <dolio> And if you are allowed to define negative types, your system is inconsistent.
23:53:24 <wei2912> @source (++)
23:53:25 <lambdabot> Unknown command, try @list
23:53:42 <dolio> But, positive types don't have the same problem, at least not in general.
23:53:48 <wei2912> whoops, sorry
23:54:41 <dolio> Anyhow, regardless, those two assertions are not "the same."
23:56:01 <arkeet> ok, let's talk about topological spaces.
23:56:23 <arkeet> Nat is the discrete space of natural numbers then?
23:56:29 <johnw> I had a dream where I was turning people into coffee mugs
23:56:48 <dolio> Probably.
23:57:14 <arkeet> well I can't imagine it being much else.
23:57:18 <arkeet> what topology do we put on function spaces?
23:57:31 <dolio> Don't know.
23:57:33 <srid> Little love for haskell here: http://www.quora.com/Which-power-programming-language-should-I-put-the-effort-into-learning-this-year-Clojure-or-Haskell
23:58:10 <bramgg> srid: looks like the #2 response to me
23:58:18 <srid> top 2, yes
23:58:20 <shachaf> dolio: How do you know the thing you said you know?
23:58:33 <dolio> I read it.
23:58:44 <shachaf> Where?
23:58:51 <dolio> Andrej Bauer's blog.
23:59:22 <dolio> The vague reason behind it is that N -> Bool is not discrete.
