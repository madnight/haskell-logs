00:06:08 <lpaste> nocturne777 pasted ‚Äúfunction design‚Äù at http://lpaste.net/8325532535492706304
00:06:16 <nocturne777> in OO programming it is recommended that instead of passing the entire object to some method, for loose coupling, it is preferable to pass only the stuff that the method relies on for instance. does this idea also apply in functional programming?  I know this sounds like a goofy question, but please bear with me :) 
00:06:56 <Cale> nocturne777: Basically, that's usually a good idea.
00:07:35 <nocturne777> Cale: if I follow that idea, I miss some opportunities where the reader monad could be used
00:07:38 <Cale> nocturne777: I mean, in general. There are a lot of factors which play into the design of types.
00:09:39 <Cale> nocturne777: Generally I almost never use Reader or ReaderT. They have their uses, but they're quite niche.
00:10:21 <nocturne777> for instance, in the sample code, I only pass the players part as opposed to the entire component thing. but there are also other functions  that rely on the board  and I pass the board part to them only
00:10:25 <nocturne777> hmm, I see.
00:10:30 <Cale> nocturne777: Both are pretty much equivalent to parameter passing, and *usually* just passing parameters explicitly will result in less boilerplate.
00:10:48 <Cale> and indeed, it's easier to refine the types of things that you're passing around then
00:12:42 <nocturne777> I see, the lesson I can take from this is that I should not force my code design to change just to be able to use  a monad
00:12:46 <Cale> In fact, if you're working with IO actions, I would typically just recommend staying away from ReaderT/WriterT/StateT altogether. IO already has lots of facilities for manipulating state, and it also has lots of higher order features like threads and exceptions that monad transformers don't play well with. So you give something up when transforming IO, and in the case of those three transformers especially, you rarely 
00:12:46 <Cale> get back what you paid.
00:13:15 <solatis> i'm currently working with a set of libraries where the author(s) are using the ! operator before almost *all* record variables. is there any sane reason to do so, or is it just the authors unable to embrace laziness?
00:13:38 <solatis> https://github.com/haskoin/haskoin/blob/0c14b25f2ef87bf4f19879c313a9ed78b9d2bcdd/Network/Haskoin/Block/Types.hs#L35
00:13:41 <solatis> an example
00:13:59 <Cale> That ![Tx] is a bit funny
00:14:27 <Cale> In general, there might be reasons that accumulating unevaluated expressions inside record fields would be a bad idea.
00:14:35 * hackagebot tttool 1.4.0.1 - Working with files for the TiptoiÆ pen  http://hackage.haskell.org/package/tttool-1.4.0.1 (JoachimBreitner)
00:14:53 <nocturne777> Cale: thanks for the advice 
00:15:01 <solatis> Cale, is it, really? does it have anything to do with the garbage collector or something?
00:15:28 <Cale> solatis: Well, consider the case where you're doing something vaguely foldl'-like to construct a record of that type.
00:17:08 <solatis> Cale, sorry, i'm either not yet awake or not proficient enough to understand the implications of that :/
00:17:30 <Cale> solatis: If it's a foldl' over a list with a million elements, you might not want to accumulate expressions in the fields which are several megabytes and which might be built up from strict functions that are going to cause a million pattern matches to go on the stack
00:17:53 <solatis> ahhh
00:17:55 <solatis> right
00:18:13 <solatis> so the point is that the expression is larger than the result
00:18:25 <Cale> yeah
00:18:29 <solatis> in which case it's cheaper to only hold the result, in certain cases
00:18:35 <Cale> yeah
00:18:38 <solatis> got it
00:18:39 <solatis> thanks
00:19:01 <Cale> In the case of a list field, it's slightly odd, because this only forces the construction of the list up to the determination of whether it's empty or not
00:19:20 <Cale> But for things like Word32 fields, it makes some sense a lot of the time
00:19:29 <ollef> if you keep adding one element at a time it makes sense, doesn't it?
00:19:31 <solatis> so it would have to be ![!Tx] ?
00:19:48 <solatis> (don't know if that's a valid construct)
00:20:54 <Cale> solatis: yeah, that doesn't work
00:21:27 <Cale> It's usually not so bad just to let list fields be lazy
00:40:53 <joneshf-laptop> anyone know where I'm going wrong here: http://lpaste.net/131728
00:40:56 <joneshf-laptop> ?
00:42:21 <joneshf-laptop> do I need to use something like `instance IsList (Vec n a) => IsList (Vec (S n) a) where` instead?
00:44:36 * hackagebot uhc-util 0.1.5.5 - UHC utilities  http://hackage.haskell.org/package/uhc-util-0.1.5.5 (AtzeDijkstra)
00:48:24 <frerich> Is there a way to influence which class instance GHC picks? For instance, if I have a 'instance C Int' and 'instance (Enum a, Bounded a) => C a', is there a way to make GHC not consider these as overlapping but rather use the former for 'Int' and the latter for anything else?
00:49:38 <frerich> I currently get http://lpaste.net/131729 and it seems the compiler already (correctly, in my case) deduced that it needs 'Random Int' but even though it finds it, it doesn't "prefer" it.
00:49:44 * hackagebot shuffle 0.1.3.3 - Shuffle tool for UHC  http://hackage.haskell.org/package/shuffle-0.1.3.3 (AtzeDijkstra)
00:49:52 <frerich> I hope that it would get preferred because it's monomorphic (I hope I used that word correctly...)
00:52:25 <joneshf-laptop> frerich, I was reading about something similar the other day
00:53:34 <funfunctor> Hi
00:53:39 <joneshf-laptop> frerich, lemme try to find the link, but the basic idea is taht you have to somehow express `(a ~ Int) == 'False`
00:53:54 <joneshf-laptop> frerich, maybe that would be enough of a constraint?
00:54:12 <joneshf-laptop> frerich, wait, no it'll still overlap, I think
00:54:54 <frerich> joneshf-laptop: For my use case, it would. However, it would be nice if there was a more general solution, i.e. monomorphic instances always win over a polymorphic one, and a polymorphic one with more constraints wins over one with less constraints. Something like that.
00:55:41 <funfunctor> Why does my XML parser not print any output at all? XML file: http://lpaste.net/131731 and parser: http://lpaste.net/131730
00:56:17 <gfixler> is idempotency in descent functions expected at the leaves of a tree zipper?
00:57:32 <joneshf-laptop> frerich, that sounds painful for a consumer (maybe yourself in the future) of the type class.
00:58:16 <joneshf-laptop> frerich, but if the overlapping pragmas do what their english denotations suggest, maybe you can get part way there?
00:58:29 <joneshf-laptop> frerich, i'm not entirely up to speed on that
00:58:56 <frerich> joneshf-laptop: Sure, it's probably easy to create a tangled web of classes and being unable to predict which one is chosen. My concrete case at hand is that there are various 'Random' instances for types for which random inhabitants can be picked. See the 'Instances' part on http://hackage.haskell.org/package/random-1.1/docs/System-Random.html#g:4
00:59:33 <frerich> joneshf-laptop: I wonder whether I could define an instance which works for any Bounded and Enum'erable type such that I use toEnum/fromEnum/minBound/maxBound to define the instance in terms of 'Random Int'.
01:00:19 <frerich> joneshf-laptop: My hope is that I could then have e.g. 'data Color = Red | Green | Blue deriving (Enum, Bounded)' and then get the possibility to pick random colors (or generate an infinite list of random colors) for free.
01:02:02 <jle`> you can sort of do it in less-exotic haskell by using a newtype
01:02:25 <jle`> newtype BoundedRand a = BR a
01:02:36 <jle`> instance (Enum a, Bounded a) => Random (BR a) where ....
01:02:45 <jle`> but yeah, it's not as pretty
01:03:37 <frerich> I could also whip up a TH funciton to generate the instance for me, but that's a bit lame :-)
01:04:11 <frerich> OTOH, System.Random.TH... hmmm.
01:04:44 * hackagebot users 0.3.0.0 - A library simplifying user management for web applications  http://hackage.haskell.org/package/users-0.3.0.0 (AlexanderThiemann)
01:04:46 * hackagebot users-postgresql-simple 0.3.0.0 - A PostgreSQL backend for the users package  http://hackage.haskell.org/package/users-postgresql-simple-0.3.0.0 (AlexanderThiemann)
01:04:48 * hackagebot users-test 0.3.0.0 - Library to test backends for the users library  http://hackage.haskell.org/package/users-test-0.3.0.0 (AlexanderThiemann)
01:04:54 <joneshf-laptop> or http://hackage.haskell.org/package/derive
01:07:40 <joneshf-laptop> also, i see what i was missing: https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists#Length-indexedobservedVectors
01:07:49 <joneshf-laptop> that's a pain
01:14:10 <ski> gfixler : not necessarily
01:14:27 <gfixler> ski: trying to find a nice way to handle things down there
01:14:44 * hackagebot ChasingBottoms 1.3.0.12 - For testing partial and infinite values.  http://hackage.haskell.org/package/ChasingBottoms-1.3.0.12 (NilsAndersDanielsson)
01:14:58 <ski> one could use `Maybe'
01:15:25 <gfixler> ski: true, though now I'm 3 levels deep in abstractions :)
01:19:45 * hackagebot haskell-packages 0.3 - Haskell suite library for package management and integration with Cabal  http://hackage.haskell.org/package/haskell-packages-0.3 (RomanCheplyaka)
01:21:47 <quxbam> how could i test the monotonic behaviour of a function with quickcheck efficiently?
01:22:13 <quxbam> That works: f x < f (succ x)  but very inefficient
01:22:26 <jle`> joneshf-laptop: try using Vec n a is your instance
01:22:43 <jle`> and IsList (Vec (n - 1) a) as your constraint instead
01:23:10 <jle`> make sure you're using something like https://hackage.haskell.org/package/ghc-typelits-natnormalise too
01:23:53 <jle`> joneshf-laptop: i got it to work :)
01:24:16 <joneshf-laptop> jle`, now you're just teasing
01:24:26 <jle`> let me draw something up
01:24:38 <joneshf-laptop> jle`, thanksthough i'll try that
01:24:51 <jle`> once you do that it should be pretty straightforward i think
01:25:02 <jle`> your error before wasn't about a fundamental issue with IsList
01:25:16 <jle`> it was that you had a type family application as your instance
01:26:00 <jle`> ...i think you might be able to make it work in some cases, but i seem to get mixed results whenever i do it.  i like to have the type family in the constraints instead
01:26:27 <quxbam> any idea?
01:26:55 <igniting> runPut in Data.Binary.Put gives me a lazy bytestring. how do I use binary with strict bytestrings?
01:30:09 <kolmodin> igniting: you can turn the lazy bytestring into a strict one
01:30:12 <joneshf-laptop> quxbam, what's inefficient about it?
01:30:33 <quxbam> well it tests for example a > b and c > d
01:30:44 <quxbam> so needs to run f four times
01:30:48 <joneshf-laptop> quxbam, also, if it's bounded, maybe make a list
01:30:52 <joneshf-laptop> map the f over it
01:31:06 <joneshf-laptop> and fold with an increasing predicate test
01:31:09 <quxbam> but it could as well make a lot of more comparisons
01:31:57 <quxbam> i would like to have it general, as well for infinites
01:32:10 <quxbam> such as the function (+1)
01:32:30 <joneshf-laptop> well, list still kind of works
01:32:38 <joneshf-laptop> generate random values
01:32:40 <joneshf-laptop> sort
01:32:41 <joneshf-laptop> map f
01:32:47 <joneshf-laptop> fold with pred
01:32:52 <igniting> kolmodin: would that have any performance implications? I am first using putByteString which gives me a strict bytestring and then doing runPut and then again converting it to a strict bytestring :/
01:33:00 <quxbam> ok, i'll try to think about it, thx
01:33:34 <joneshf-laptop> or wait
01:33:47 <jle`> joneshf-laptop: it looks like you don't even need the plugin
01:33:51 <jle`> it works with ghc out of the box
01:34:33 <lpaste> jle` pasted ‚Äúlength-typed vectors and IsList‚Äù at http://lpaste.net/131732
01:34:38 <jle`> ^^ joneshf-laptop 
01:35:16 <igniting> I was using cereal earlier, was thinking of switching to binary
01:35:54 <kolmodin> igniting: it needs to be a strict bytestring when you're done?
01:36:35 <kolmodin> the bytestring you feed to putByteString, is it the result of another runPut ?
01:36:36 <igniting> I am writing it to file and yes I would like to work with strict bytestrings whenever possible
01:37:19 <kolmodin> a lazy bytestring should be perfectly fine here
01:37:27 <jle`> joneshf-laptop: it makes me wonder what the note on the wiki was all about
01:38:03 <kolmodin> the bytestring you give to putByteString, is it small or large?
01:38:04 <joneshf-laptop> jle`, dunno, i've still yet to reimplement it
01:38:11 <kolmodin> igniting: ^^
01:38:13 <jle`> anyways the descent works because in (x :# xs :: Vec n a), x :: a and xs :: Vec (n - 1) a, from the GADT syntax
01:38:21 <igniting> what is the difference between ByteString.hPut and Lazy.hPut?
01:38:44 <jle`> so we can use L.toList xs because we have an IsList (Vec (n - 1) a) constraint
01:39:24 <jle`> (note that i used (:#) :: a -> Vec (n - 1) a -> Vec n a, instaed of your (:<) :: a -> Vec n a -> Vec (n + 1) a)
01:39:33 <kolmodin> igniting: in the documentation, if you push the "Source" link you can read the code
01:39:46 <jle`> it makes more sense for me to have Vec n a as the return type, and to define the type of the arguments
01:39:47 <igniting> yes, was seeing that
01:39:51 <kolmodin> igniting: Lazy.hPut is implemented by calling ByteString.hPut many times
01:39:51 <jle`> in terms of n
01:41:27 <igniting> am I not better off using string bytestring here? why would I like to make multiple syscalls if I can get away with one
01:42:59 <igniting> kolmodin ^
01:43:46 <kolmodin> igniting: you can get away with one, if you have all your data in a single strict bytestring. you have a strict bytestring plus some extra data you write in binary. that will result in a lazy bytestring, and you need to make a copy of it into a strict bytestring
01:44:02 <kolmodin> so you either do a copy of all data (which also isn't free), or you hPut the lazy bytestring
01:44:45 * hackagebot nanospec 0.2.1 - A lightweight implementation of a subset of Hspec's API  http://hackage.haskell.org/package/nanospec-0.2.1 (SimonHengel)
01:45:37 <igniting> huh, cereal's runPut gave me a strict bytestring. What are the benefits of switching to binary?
01:47:33 <kolmodin> igniting: and how do you think it does that? :) it converts the lazy bytestring into a strict, and then gives it to you
01:48:55 <igniting> kolmodin, but I never have lazy bytestrings at the first place. Also what exactly did you mean when you said "you need to make a copy"?
01:49:32 <kolmodin> igniting:  Data.Serialize.Put.runPut uses Data.Serialize.Builder.toByteString, and in turn it calls Data.ByteString.concat
01:49:46 * hackagebot bitcoin-block 0.9.0 - Utility functions for manipulating bitcoin blocks  http://hackage.haskell.org/package/bitcoin-block-0.9.0 (solatis)
01:56:13 <florin36> hi all, I have a small question: when declaring an argument function I have to put it between () and when declaring an list of functions argument I need to put only []. For example func_name::(a->b) -> c and func_name2::[a->b]->c ?
01:57:03 <quxbam> harr, my connection closed
01:57:18 <florin36> the question is why I do not need to put [(a->b)] in func_name2 
01:57:22 <florin36> ?
01:59:04 <quxbam> florin36: the parentheses are there to show grouping, whichs is already clear by []
01:59:51 <kqr> florin36, "a -> b -> c" is interpreted by haskell as "a -> (b -> c)"
02:00:07 <kqr> florin36, "[a -> b] -> c" can only be interpreted as "[(a -> b)] -> c"
02:00:18 <kqr> florin36, it can't be "[a -> (b] -> c)"
02:00:27 <kqr> florin36, so no need to specify because it can only be one thing
02:02:44 <quxbam> why does quickcheck use multiple times the same input for pure functions?
02:03:57 <pavonia> Doesn't it use random values?
02:04:16 <quxbam> yes, but why doesn't it check if it already used the value?
02:04:28 <quxbam> This would make sense if the computation is expensive.
02:06:37 <jle`> florin36: this is similar to asking why you can do x * 3 + 4 instead of (x * 3) + 4
02:06:49 <ski> quxbam : what if the input values can't be compared for equality ?
02:07:36 <florin36> kqr, jle` :thanks
02:08:05 <quxbam> ski: that's a good point, but at least in cases in which they could be compared it would make sense
02:08:27 <jle`> florin36: or a better example, why you can do ((1+3)) + 4 instead of (1 + 3) + 4.  why can't you use two sets of parentheses?
02:09:40 <joneshf-laptop> jle`, after your hint about subtraction I still couldn't get it, then i looked at what you did and saw incoherence, isn't that an issue?
02:09:46 * hackagebot compdata 0.10 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.10 (PatrickBahr)
02:10:55 <jle`> joneshf-laptop: i don't think there's a fundamental reason why they have to be incoherent...i think a sufficiently more expressive Nat/CmpNat/type checker plugin combo like the one i liked earlier might be able to have ghc realize they are incoherent
02:11:04 <jle`> they are however effectively...mutually exclusive
02:11:12 <jle`> one works on m ~ 0 and the other works on m > 0
02:11:16 <jle`> there is no m that satisfies both
02:11:36 <jle`> i guess you have to prove that with your brain, and without ghc's help :/
02:12:14 <joneshf-laptop> the error for me was about the overlap between `IsList (Vec 0 a)` and `IsList (Vec (n - 1) a)`
02:12:17 <jle`> ghc also can't seem to infer that Nil will never show up on the m > 0 instance of toList, if m > 0 is the constraint.  or maybe i'm doing something wrong
02:12:34 <jle`> are those two different instances?
02:12:37 <florin36> jle`: I understand that -> has right associativity and I need to break that. By putting (a->b) in parentheses it is considered a single argument
02:13:18 <frerich> In TemplateHaskell, how can I get from a Name to a Type? Given some 'n :: Name', a quasi quotation like '[d|instance I $(n)]' fails because the splice is supposed to be a 'Q Type' instead of a 'Name'. However, I can't see a way to do that.
02:13:45 <frerich> With 'reify' I get a TyConI but there doesn't seem to be any way to go to a Type.
02:15:33 <danilo2> Hello! Is here anybody who could give me few minutes and explain some details of the Bound library example on github? (Deriving.hs): https://github.com/ekmett/bound/blob/master/examples/Deriving.hs
02:25:52 <joneshf-laptop> jle`, yeah
02:25:58 <joneshf-laptop> jle`, i think i need to sleep on it
02:26:49 <jle`> joneshf-laptop: between the two intsances i gave, no type will ever overlap or fit into both
02:26:51 <jle`> joneshf-laptop: night :)
02:29:01 <merijn> jle`: I missed the initial question, can you repeat?
02:29:28 <mniip> lambda arguments are irrefutable patterns right
02:29:47 * hackagebot timezone-series 0.1.5 - Enhanced timezone handling for Data.Time  http://hackage.haskell.org/package/timezone-series-0.1.5 (YitzGale)
02:29:47 <mniip> no wait, that's not the question
02:29:54 <mniip> are lambda arguments lazy or strict patterns
02:30:48 <merijn> mniip: Strict
02:31:04 <mniip> > (\() -> ()) undefined
02:31:06 <lambdabot>  *Exception: Prelude.undefined
02:31:18 <merijn> > (\(x:xs) -> "boo!") []
02:31:20 <lambdabot>  "*Exception: <interactive>:3:2-18: Non-exhaustive patterns in lambda
02:31:44 <jle`> merijn: http://lpaste.net/131728 was the question, and i submitted http://lpaste.net/131732
02:32:05 <jle`> as a response/answer
02:32:37 <arkeet> > (\ ~() -> ()) undefined
02:32:38 <lambdabot>  ()
02:33:09 <merijn> jle`: oh and the problem is it not erroring?
02:33:33 <jle`> merijn: the original post was by joneshf-laptop and the code wouldn't compile
02:33:45 <jle`> my response works as i expected it to work
02:34:47 * hackagebot compdata-dags 0.2 - Compositional Data Types on DAGs  http://hackage.haskell.org/package/compdata-dags-0.2 (PatrickBahr)
02:35:45 <merijn> jle`: FYI, isn't there already an infix synonym for CmpNat?
02:37:04 <jle`> there is sort of one, but the error it gives is a little less than helpful
02:37:57 <jle`> oh
02:37:59 <jle`> no, there isn't one
02:38:33 <jle`> there's one that is implemented in an apparently unrelated way
02:39:03 <safinaskar> how to catch exception thrown by "error"?
02:39:04 <jle`> and its usage as a constraint gives some unoptimal error messages
02:39:28 <merijn> safinaskar: Practically? You don't, they're near impossible to reliably catch
02:39:33 <merijn> safinaskar: In other words, don't use error
02:39:55 <mniip> oohhhh it just hit me
02:40:26 <jle`> merijn: if you use (x <= y) and the constraint doesn't hold, the error is, "Cannot match 'True with 'False"
02:40:31 <jle`> i mean...thanks
02:40:44 <merijn> safinaskar: Which error are you trying to catch?
02:41:02 <mniip> IO uses unboxed tuples because that implies that the result evaluation is forced to happen as soon as the state is returned
02:41:08 <merijn> jle`: You can use my dirty error trick: https://gist.github.com/merijn/6130082
02:41:14 <jle`> with the version i gave, if you use x < y, it'll say "Cannot match 'EQ with 'GT", or "Cannot match 'LT with 'GT"
02:41:26 <merijn> mniip: Also so the state token can be optimised away during code generation
02:41:51 <merijn> mniip: Since unboxed tuples are returned in registers and the "state" entry is never used it can easily be discarded
02:41:55 <mniip> well optimising (# State# x, y #) to y is a whole another thing
02:42:02 <mniip> but yes, I've seen that code
02:42:16 <mniip> the return convention is the same
02:43:15 <merijn> mniip: Also, rereading your observation
02:43:28 <merijn> "IO uses unboxed tuples because that implies that the result evaluation is forced to happen as soon as the state is returned" <- this is not true at all
02:43:46 <merijn> Unboxed tuples don't magically force their results
02:43:58 <merijn> It just means the tuple *itself* is unboxed
02:45:46 <merijn> btw, I have a totally unrelated question
02:46:35 <merijn> The only reason we need to do exception handling in IO is the fact that it's not possible to track throws leaking out of handlers and handlers being unaware of the exceptions generated internally, right?
02:47:30 <ocharles_> Any type inference pros around? https://gist.github.com/ocharles/cd2b0489640394315571 I can't figure out how to get foo to infer to the same type as bar
02:47:52 <ski> we need to account for the indeterminacy of which exception we actually observe
02:47:54 <ocharles_> My guess is that because GHC doesn't know what 'foo' should ultimately deliver, it can't work out which of those type classes to apply
02:48:15 <ocharles_> actually, let me refine that paste a little bit. In reality, I have call sites using foo which I believe *should* determine the result type
02:49:05 <tulcod> merijn: (thanks for your explanation yesterday on MonadFix and its IO instance)
02:49:05 <jle`> merijn: to me the reason we do exception handling in IO is that exceptions are a part of runtime semantics
02:49:16 <merijn> tulcod: np :)
02:49:17 <jle`> IO runtime environment semantics
02:49:42 <ocharles_> ok, gist updated: https://gist.github.com/ocharles/cd2b0489640394315571
02:50:02 <merijn> jle`: Yeah, but I wanna try prototyping checked exceptions in something haskell-like and this got me thinking that with checked exceptions you don't really need IO to catch/throw since this whole leaking can't happen
02:50:31 <merijn> ski: Right, but suppose we explicitly track exceptions and handlers then you could easily have pure code with exceptions, no?
02:51:48 <merijn> ocharles_: Can you explain what you want to accomplish?
02:51:56 <ocharles_> merijn: type checking? ;)
02:51:59 <ocharles_> but no, i'll be more serious
02:52:11 <merijn> (I suck at fundeps, tbh. I usually end up using TypeFamilies despite "fundeps inferring better")
02:52:21 <ocharles_> I'm basically trying to do what 'lucid' is doing, but I have slightly different types for HTML attributes
02:52:33 <ocharles_> the idea is you can write either of these:
02:52:34 <merijn> I typically write out types anyway, so I dunno whether that matters to you
02:52:41 <ocharles_> merijn: I don't in where clauses
02:52:48 <ocharles_> and that's where this actual problem is occuring
02:53:04 <merijn> ocharles_: I started writing them out there too now >.>
02:53:24 <ocharles_> anyway, you can write  div_ (id .= "login") children  or just  div children
02:53:28 <ocharles_> when you know the types, it all works out
02:53:44 <ski> merijn : explicitly, how ?
02:53:46 <ocharles_> but in this case GHC gets confused and can't work out which of those forms you mean
02:53:53 <bernalex> is there an easy way with cabal/haskell in general to make the source code available? i.e. I have a REST server, and with the server I want to build & deploy the source code it was built with, and serve it as part of the server itself.
02:54:29 <funfunctor> ok I figured out the issue in my parser
02:54:30 <merijn> ski: I'm prototyping (well, writing down thoughts until I have time) to do separate typing for exceptions and handlers
02:54:46 <bartavelle> bernalex, add all your modules in Data-Files: ?
02:54:54 <merijn> ski: i.e., I want checked (but inferred) exceptions that don't clutter up my "functional" types
02:55:03 <funfunctor> how does one deal with the case of parsing <foo><x>1</x><y>2</y></foo> ?
02:55:16 <bernalex> bartavelle: that's very inconvenient when you have a bajillion files that are already added as modules. I wouldn't call this "easy".
02:55:18 <merijn> bernalex: You can host your own hackage with a custom package db?
02:55:20 <ocharles_> oh hey, I got it!
02:55:30 <bernalex> bartavelle: I'd rather use POSIX to run cabal sdist lol.
02:55:43 <bartavelle> bernalex, yeah that's why I put a '?' :)
02:55:45 <ocharles_> instance (f ~ T, r ~ T) => Term (StateT T Identity ()) (f -> r) where -- that's the magic change
02:55:56 <bernalex> merijn: that's not exactly easy either... this needs to work for anyone who grabs a copy of the source & builds it with or without modifications.
02:56:09 <bernalex> bartavelle: :)
02:56:18 <bartavelle> bernalex, you can hack your Setup.hs to do this for you thouhg
02:56:20 <funfunctor> using the arrow >>> consumes all the input so I can parse <foo><x>1</x></foo> fine with:
02:56:20 <funfunctor> func = isElem >>> hasName "foo" /> proc x -> do
02:56:21 <funfunctor>   x  <- read ^<< isElem >>> hasName "x"      /> getText -< x
02:56:34 <merijn> bernalex: Oooh, *now* I see what you want
02:56:37 <bernalex> bartavelle: that was my thinking, that maybe someone had done some Setup.hs hackery.
02:56:41 <ski> merijn : what if you only get an exception when you force a particular element of a list ?
02:56:51 <bernalex> merijn: sorry for not explaining well. this is to be in compliance with GNU AGPL3.
02:57:09 <merijn> bernalex: So do you want the source to be part of your binary or whatever?
02:57:20 <funfunctor> but the following fails:
02:57:21 <funfunctor> func = isElem >>> hasName "foo" /> proc x' -> do
02:57:21 <funfunctor>   x  <- read ^<< isElem >>> hasName "x"      /> getText -< x'
02:57:21 <funfunctor>   y  <- read ^<< isElem >>> hasName "y"      /> getText -< x'
02:57:32 <merijn> bernalex: FYI, you don't really need to make it automatically avaiable for AGPL3, just a written offer to provide the source upon request
02:57:40 <bernalex> merijn: I want the source code to be served by the scotty server that runs, e.g. localhost:8080/src or whatever.
02:57:55 <bernalex> merijn: I know, but I strongly prefer this approach.
02:58:18 <merijn> I don't know how scotty works...would it be easy to serve bytestrings under this source hierarchy?
02:58:34 <bernalex> merijn: hm. maybe?
02:58:43 <merijn> bernalex: You could use TH and file-embed to embed all source files as bytestrings and then return those from /src
03:00:00 <merijn> ski: If your list elements are results of a potentially throwing computation then you infer potential exceptions from any element, which means anything using those elements potentially throws that exception unless caught
03:00:50 <bernalex> merijn: dunno how to do that, but it sounds interesting. I'll look up some examples or whatever. thanks.
03:00:50 <funfunctor> hello?
03:02:55 <ski> merijn : so how would the type of such a list-with-possible-exceptions-among-the-elements look like ?
03:03:09 <merijn> bernalex: file-embed is a TH library that turns compile time files into values built into the program
03:03:18 <bernalex> merijn: yep, looking at it right now.
03:03:55 <merijn> bernalex: So you could read a source file and turn it into a ByteString. So you need some TH that traverses the cabal directory, includes all files and turns it into some ADT you can expose from /src, but that's all just "normal haskell" so should be fairly easy
03:05:09 <ski> merijn : something like `[Int |+ Bad]', where `Int |+ Bad' is the type of the individual elements, `Bad' being an example exception ?
03:05:16 <merijn> ski: I want to type exception separately from functional types (because you get all these messy effect types that become hard to read), so you'd have "foo :type: [a]" and "foo :except: [WhateverException]"
03:05:46 <merijn> ski: Semantically it map to something very Either/sum like, but tracked separately from the functional types
03:06:19 <ski> merijn : i'm not sure how "tracked separately from the functional types" relates to your use of `foo :type: ...' and `foo :except: ...'
03:07:07 <DrGamatos> Hello there!! :)
03:08:13 <merijn> ski: You'd need to have a typing judgment for the type and a typing judgment for possible exceptions thrown by a term
03:09:01 <ski> DrGamatos : ŒöŒ±ŒªŒ∑ŒºŒ≠œÅŒ±
03:09:45 <ski> merijn : ok so far, i suppose. but i don't see how that's enough
03:10:28 <danilo2> Hello! :) Is here somebody who understands exactly how the Bound library (De Bruijn generalization) works? I've got some small questions and would be very thankfull for any help! :)
03:12:58 <ski> merijn : iow, how do i distinguish between a value of type `Maybe Bool' where one may get an exception when looking at the `Maybe' data constructor, and one where one may get an exception when looking at the `Bool' data constructor ?
03:14:35 <merijn> ski: hmmm, I should just get started on my prototype that would hopefully be clearer >.>
03:15:30 <ski> merijn : perhaps you should write down the type system rules that intend
03:18:25 <DrGamatos> So i am a begginer haskeller, and i was wondering: Is there a way to forward multiple arguments of different types to a function, in order to be retrieved by another function later?
03:18:56 <jameseb> DrGamatos: how do you mean?
03:19:13 <HugoDaniel> DrGamatos: case ?
03:19:20 <mniip> you can't exactly manipulate types at runtime like that
03:19:26 <DrGamatos> let me show you
03:19:38 <DrGamatos> i 've been solving the 99 haskell problems
03:19:53 <mniip> then it sounds like you're doing something wrong, if you need that
03:20:00 <DrGamatos> and i would like to make a generic print that takes the function, the parameters and the expected output
03:20:05 <DrGamatos> http://pastie.org/private/bmn0srpotldeqapzvi23pa
03:20:16 <ski> DrGamatos : `((f .) . g) x y' is `f (g x y)'
03:20:21 <NightRa> How to represent in a type safe way any subset of {A,B,C} for example?
03:20:26 <NightRa> data Options = A | B | C
03:20:41 <mniip> DrGamatos, duh, vararg functions are very much different
03:20:41 <HugoDaniel> ski: :O amazing
03:20:50 <ski> NightRa : perhaps use a function of type `Options -> Bool' ?
03:20:53 <HugoDaniel> DrGamatos: pass them in a list :P
03:20:56 <merijn> DrGamatos: Is it possible? Yes, but not using very beginner haskell
03:20:58 <NightRa> Valid values of new type: {A, B, C, AB, AC, BC, ABC}
03:21:18 <DrGamatos> In a list, with different types????
03:21:35 <mniip> DrGamatos, see how printf works
03:21:36 <HugoDaniel> wrap them in a parent type or render them to string before
03:21:43 <mniip> but if you're a beginner you might as well abandon that idea
03:21:46 <NightRa> One option I could take is just make a datatype with all the elements of the subset
03:21:55 <NightRa> But that's not the nicest..
03:22:01 <mniip> NightRa, you forgot the empty subset
03:22:08 <DrGamatos> yes you mean a variant
03:22:09 <NightRa> mniip: Right.
03:22:14 <mniip> also ski already said, Options -> Bool
03:22:39 <mniip> disregarding bottoms, has Bool^Options inhabitants which is 8
03:22:44 <HugoDaniel> use template haskell
03:22:59 <NightRa> And it should be easy to construct them directly for passing manually to functions
03:23:25 <mniip> DrGamatos, you could do something like
03:23:53 <mniip> data Printable = S String | I Int | ...; then print :: [Printable] -> IO ()
03:24:10 <arkeet> why not just
03:24:12 <arkeet> Set Options
03:24:14 <merijn> mniip: You can do it properly generic, but it requires -XKitchenSink
03:24:35 <HugoDaniel> kitchen sink ?
03:24:50 <HugoDaniel> lol
03:24:57 <HugoDaniel> is that really a extension ?
03:24:59 <merijn> HugoDaniel: It's a joke :p
03:25:02 <HugoDaniel> oh lol
03:25:03 <mniip> doesn't sound like one
03:25:07 <ski> NightRa : btw, it would probably be more idiomatic to use the singular (not plural) form for the type. iow `Option', not `Options'
03:25:13 <HugoDaniel> everything but the kitchen sink !!
03:25:14 <HugoDaniel> ahah
03:25:42 <mniip> merijn, you could coerce to and from Any
03:25:44 <merijn> HugoDaniel: https://en.wiktionary.org/wiki/everything_but_the_kitchen_sink#English
03:26:02 <DrGamatos> i suppose the correct design would have been to calculate the solution outside the print function and pass the answer, the arguments and the expected solution to the function
03:26:45 <merijn> mniip: You can actually do it properly type-safe, but it requires some polymorphic typeclass recursion (ala printf) and TypeFamilies voodoo :)
03:28:13 <HugoDaniel> amazing
03:29:02 <NightRa> ski: Sure. Just an example here
03:29:49 * ski . o O ( `data Application :: * -> * where Operator :: a -> Application a; Apply :: Show a => Application (a -> b) -> (a -> Application b)' )
03:29:51 <NightRa> If you are interested, it's for an assembler backend, and I want to support all the BR commands - BR, BRn, BRz, BRp, BRnp, ...
03:30:29 <ski> NightRa : which architecture is that ?
03:30:50 <mniip> merijn, you can avoid TypeFamilies
03:30:53 <NightRa> LC3
03:30:57 <mniip> iirc printf doesn't use those
03:31:48 <NightRa> LC3 is an educational architecture
03:32:15 <merijn> mniip: Sure, but not if you want his function exactly as written
03:32:22 <ski> yes, i just looked it up
03:35:21 <safinaskar> how to catch exception thrown by "error"?
03:35:31 <safinaskar> merijn and others: i want some temporary hack to debug my program. final program will not contain "error"s (except for error which should never be thrown). i'm trying to catch "error "some string""
03:37:23 <kqr> merijn, nowadays, I hear people talk about exceptions and async something in good light
03:37:28 <kqr> merijn, are they not talking about error?
03:39:25 <pavonia> safinaskar: catch the ErrorCall exception
03:39:49 * hackagebot uhc-light 1.1.9.0 - Part of UHC packaged as cabal/hackage installable library  http://hackage.haskell.org/package/uhc-light-1.1.9.0 (AtzeDijkstra)
03:42:14 <safinaskar> is there some way to catch "error" exception not from IO monad? some really dirty-dirty hack, just for debugging?
03:42:39 <kqr> safinaskar, yes and no. it probably won't give you the result you want because lazy evaluation
03:42:47 <ion> safinaskar: http://hackage.haskell.org/package/spoon
03:44:39 <ion> I‚Äôm here to inquire about your spooooooooooons
03:44:58 * hackagebot keyring 0.1.0.4 - Keyring access  http://hackage.haskell.org/package/keyring-0.1.0.4 (lunaryorn)
03:45:01 * hackagebot ampersand 3.0.3 - Toolsuite for automated design of business processes.  http://hackage.haskell.org/package/ampersand-3.0.3 (hanjoosten)
03:45:32 <safinaskar> same question, but if my type is not of class NFData?
03:52:41 <ski> safinaskar : you can use `tryJust (\(ErrorCall s) -> guard (s == "some string"))' or something like that .. (possibly coupled with a use of `evaluate', and possibly also `seq')
03:54:27 <pavonia> :t evaluate
03:54:28 <lambdabot> a -> IO a
03:54:59 * hackagebot timezone-series 0.1.5.1 - Enhanced timezone handling for Data.Time  http://hackage.haskell.org/package/timezone-series-0.1.5.1 (YitzGale)
03:55:24 <safinaskar> ski: i need not in IO monad
03:55:38 <kqr> then how can you guarantee your code will run at all?
03:57:32 <safinaskar> kqr: let's assume i have main :: IO (), pure functions f, g (not in IO monad). main calls f, f calls g. i want to catch exception thrown by g in function f
03:57:53 <jle`> @hackage spoon
03:57:53 <lambdabot> http://hackage.haskell.org/package/spoon
03:58:07 <safinaskar> okey, i just rewrote some code to MonadError to use throwError instead of error
03:58:18 <jle`> might work :) although i'd advise you to think deeply before using it in production
03:58:21 <safinaskar> then i will rewrite it back when the bug will be fixed
03:58:28 <safinaskar> so, thanks. the problem is gone
03:58:29 <phaazon> holy @!#$
03:58:34 <phaazon> cat, the C++14
03:58:40 <phaazon> I look at the implementation
03:58:42 <phaazon> goddammit
03:58:44 <phaazon> :D
03:58:48 <phaazon> looked*
03:58:56 <phaazon> what an awful language C++ is now
03:59:49 <kqr> safinaskar, but function f might not ever see the exception thrown by g
03:59:59 * hackagebot uu-options 0.1.0.2 - Parse command line options using uu-interleave and uu-parsinglib  http://hackage.haskell.org/package/uu-options-0.1.0.2 (DoaitseSwierstra)
04:00:36 <safinaskar> phaazon: implementation of spoon? o_O
04:01:05 <safinaskar> kqr: yes, but currently it sees. because f really uses g result
04:01:13 <kqr> safinaskar, if main = do print (g (f 0)), g x = x and f x = 1/x, then main = print (1/0) as far as Haskell is concerned
04:02:00 <ski> (does this fit with safinaskar's "f calls g" ?)
04:02:01 <kqr> and it might not be as simple as g x = x, obviously. even some really complicated haskell functions might return the result of the inner function without *really* looking deeply into it
04:02:10 <safinaskar> kqr: okey, i solved my problem anyway already
04:02:11 <phaazon> safinaskar: of cat
04:02:13 <kqr> whoops no, but I think the point is the same
04:02:22 <phaazon> like the Functor abstract class
04:03:30 <safinaskar> phaazon: what means this "cat"? kitty? UNIX utility "cat"? some concatenation? what?
04:04:57 <phaazon> safinaskar: https://github.com/cat/cat
04:04:59 <phaazon> that.
04:05:54 <Aruro> is it possible to change lhs style to use other symbol, not '>' ?? 
04:06:14 <Aruro> perhaps even unicode
04:06:55 <Gothmog_> you can use LaTeX...
04:07:03 <indiagreen> yes, ‚Äú:set prompt "? "‚Äù 
04:07:03 <safinaskar> phaazon: thanks
04:07:15 <indiagreen> ouch, lhs
04:07:18 <indiagreen> not GHCi
04:07:19 <indiagreen> sorry
04:07:56 <Aruro> indiagreen: yes prompt i already set to lambda :D
04:08:01 <Gothmog_> Aruro: Or, if you just want to use the lhs Bird style with different chars, have a look at https://wiki.haskell.org/Literate_programming#Transformation_of_.lhs-files
04:08:19 <Gothmog_> You can change the sed or awk script to your liking.
04:09:42 <Aruro> Gothmog_: these scripts just extract code, i would like to compile it or load to ghci, but using another simbol for Bird notation
04:09:57 <Aruro> Gothmog_: preferably without extra sed/awk step
04:10:53 <Aruro> hm, maybe i can somehow hide '>' symbol in emacs
04:11:12 <Aruro> it is anyway color coded in haskell mode
04:14:59 * hackagebot shake-language-c 0.7.0 - Utilities for cross-compiling with Shake  http://hackage.haskell.org/package/shake-language-c-0.7.0 (StefanKersten)
04:17:22 <Aruro> Gothmog_: from haskell report it seems this symbol is hardcoded
04:25:00 * hackagebot timezone-olson 0.1.7 - A pure Haskell parser and renderer for binary Olson timezone files  http://hackage.haskell.org/package/timezone-olson-0.1.7 (YitzGale)
04:25:51 <esimp> I'm trying to run cabal/haddock across two local projects, and would like them to cross-reference each other.  Any pointers on how I can do this?
04:26:50 <dcoutts> esimp: referring to dependencies is straightforward, but if you need to refer to packages you don't depend on that's harder
04:27:18 <dcoutts> haddock has a syntax for fully qualified references, but I'm not sure in practice that works properly
04:27:39 <dcoutts> because haddock doesn't know the version of the package being referred to, only the full module name
04:27:40 <esimp> dcoutts, so I should look to make sure the dependencies are listed correctly in the .cabal file?
04:27:58 <dcoutts> esimp: yes, in the normal case cabal+haddock will do it automatically
04:28:19 <dcoutts> as long as your deps are listed, and they names you're referring to are in scope
04:28:19 <esimp> dcoutts, ok, let me do a run
04:28:21 <dcoutts> ie imported
04:28:39 <dcoutts> esimp: and you have to have locally generated docs for both packages
04:28:42 <amatsu> Is there any library for Haskell that will do what Python's requests does?
04:29:06 <merijn> kqr: Exceptions and async are completely unrelated to "error" (well, not entirely), but the in-depth explanation will have to wait until later today when I have time
04:29:10 <amatsu> (web sessions with easy support for cookies)
04:29:13 <esimp> dcoutts, ah, not previously generating the other packages documentation may have been the issue.  
04:29:58 <dcoutts> esimp: ah right yes. Haddock keeps info about packages and needs that to be able to make links to them. cabal haddock will give you as specific warning if the docs for deps cannot be found
04:30:33 <esimp> dcoutts, perfect -- I'll take a look
04:30:46 <jchmrt> Hey guys, I was playing around with migrating data with safecopy, and when I tried to migrate from a string to a bytestring, the last 4 characters are lost and 4 '\NULL
04:30:56 <jchmrt> ''s get prepended
04:31:51 <jchmrt> I have the code in a repository  here: https://notabug.org/jchmrt/migrate-test, if you run it first with the initial commit and after that with the second commit, you lose some data. Does anyone know why this happens?
04:32:05 <peddie> amatsu: will wreq do what you want?
04:33:06 <amatsu> hmm, looks like it
04:33:28 <amatsu> it's lens-based, is there a tutorial for using lens?
04:33:47 <amatsu> looks like there's one on FP Complete
04:33:55 <amatsu> peddie: thanks
04:34:10 <kqr> merijn, ah, okay. I can wait :)
04:34:47 <peddie> amatsu: wreq has its own tutorial page that explains the basics alongside the haddock documentation
04:45:00 * hackagebot hPDB-examples 1.2.0.2 - Examples for hPDB library  http://hackage.haskell.org/package/hPDB-examples-1.2.0.2 (MichalGajda)
04:46:03 <ij> runhaskell this: http://sprunge.us/WWWj and it will fail with: "hGetContents: invalid argument (invalid byte sequence)". Can haskell ignore the invalid sequences?
04:49:35 <srhb> ij: Why not read a ByteString and handle the encoding manually, if that is your problem?
04:49:56 <ij> What do you mean handle it manually?
04:50:14 <srhb> ij: With Data.Text.Encoding
04:50:28 <srhb> ByteStrings are never invalid.
04:50:37 <srhb> Interpreting a certain sequence of bytes as UTF8 may be.
04:50:57 <srhb> Or am I misunderstanding your issue?
04:51:44 <srhb> ij: Also see Data.Text.Encoding.Error
04:52:06 <srhb> (You have to decide what to do in case you can't parse)
04:53:13 <ij> Mh, I've got code that's all entangled in String already. 
04:53:50 <ij> But I guess i can only do I/O with bytestrings, then remove the invalid parts, then convert to a valid String.
04:54:14 <srhb> ij: Well, your question was "Can haskell ignore the invalid sequences" -- what does ignore mean? Stop parsing if there's not a valid way to do so? Return an error? Replace the characters in question? Etc. :)
04:54:48 <srhb> Haskell can do either thing, but you need to decide.
04:55:18 <srhb> And yes, there's probably no sane way to do Stringy IO if you may encounter encoding errors.
04:55:35 <ij> Well if a program crashes, that's certainly not ignoring them ‚Äî it already returns an error.
04:55:37 <ij> I want them to be simply overlooked.
04:55:37 <srhb> (In any language!)
04:56:21 <srhb> ij: See Data.Text.Encoding.Error.ignore
04:56:25 <srhb> I think that is what you want
04:56:50 <srhb> This may or may not introduce ambiguous parses, I'm not sure.
04:59:11 <ij> srhb, Thanks!
04:59:51 <srhb> ij: Also see: http://en.wikipedia.org/wiki/Variable-width_encoding -- especially the bit about I‚ô•NY -(what happens if E2 is corrupted?)
05:05:08 <ij> You mean if E2 isn't present?
05:06:22 <srhb> ij: I'm not exactly sure what would happen in either case, but I think that particular case would actually go over well (with just the heart symbol missing)
05:06:59 <ttt_fff> sorta off topic, but very important to haskell programming: do you guys use two different types of wipes (one for monitor, one for glasses), or just one type of types for both monitor + glasses
05:07:27 <srhb> ttt_fff: My monitors and glasses are all pure and stateless.
05:07:29 <srhb> No wiping required.
05:07:30 <ij> srhb, Yeah, thought that too ‚Äî this is what I wanted / need.
05:07:40 <ttt_fff> srhb: mine get smudges
05:07:45 <ttt_fff> finger prints + dust
05:07:56 <srhb> ttt_fff: Clearly uou need new monitors and glasses.
05:08:31 <ion> I spread peanut butter on my monitor and let my giraffe lick it clean, taking care of any previous dirt.
05:08:31 <ij> ttt_fff, Yes, different ones. A sock for the monitor, shirt for the glasses. Sometimes soap and water comes along comes for the lenses.
05:08:51 <srhb> ion: Miniature or regular giraffe?
05:09:39 <indiagreen> can anyone say how to catch right-click on a Button in gtk3?
05:09:46 <ion> Regular. It's hard to get miniature peanut butter here.
05:09:57 <srhb> Good point.
05:10:01 * hackagebot yesod-auth-oauth 1.4.0.2 - OAuth Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-oauth-1.4.0.2 (MichaelSnoyman)
05:10:03 * hackagebot yackage 0.7.0.8 - Personal Hackage replacement for testing new packages.  http://hackage.haskell.org/package/yackage-0.7.0.8 (MichaelSnoyman)
05:10:09 <srhb> indiagreen: With which library?
05:10:14 <indiagreen> gtk3
05:10:17 <indiagreen> @hackage gtk3
05:10:18 <lambdabot> http://hackage.haskell.org/package/gtk3
05:13:36 <srhb> indiagreen: Looks like you want eventModifierMouse from EventM
05:14:08 <srhb> indiagreen: https://hackage.haskell.org/package/gtk3-0.13.6/docs/Graphics-UI-Gtk-Gdk-EventM.html
05:14:59 <indiagreen> but wouldn't this catch events like ‚Äúright mouse button was pressed elsewhere, then pointer was moved to the button, then right mouse button was released‚Äù?
05:15:01 * hackagebot shake-language-c 0.7.1 - Utilities for cross-compiling with Shake  http://hackage.haskell.org/package/shake-language-c-0.7.1 (StefanKersten)
05:15:05 <indiagreen> it's a false positive
05:16:07 <srhb> indiagreen: buttonActivated only emits a signal when the button in question has been pressed and depressed, no?
05:17:01 <indiagreen> yes, but right-click doesn't activate the button
05:17:43 <indiagreen> (my usecase: I want to have a button which would do some action on left-click (i.e. when normally pressed), and change its assigned action when right-clicked)
05:21:05 <srhb> indiagreen: Sorry, I don't know then. Looking at the source I guess you may need to use the connect_none__none function to build that particular function, but I don't know.
05:21:39 <indiagreen> okay, I guess it's actually no big deal if the button reacts wrongly to someone performing such shenanigans
05:21:42 <indiagreen> thanks
05:23:40 <srhb> indiagreen: Perhaps a SO question is in order :)
05:24:01 <Gothmog_> Aruro: Yes, but you can simply translate your custom-lhs into an hs file with the scripts there.
05:35:09 <indiagreen> srhb: found it
05:35:20 <srhb> indiagreen: So, what's the solution?
05:35:58 <indiagreen> http://lpaste.net/131739
05:36:30 <srhb> indiagreen: Well, that was simple. :-)
05:36:33 <meretrix> Hi, could someone point me in the right direction with this cabal dependency problem?
05:36:34 <meretrix> http://lpaste.net/131738
05:37:00 <meretrix> I have lens-4.9.1 installed, but I don't understand what it means by a global constraint on lens-4.6.0.1...
05:43:14 <bergmark> meretrix: a global constraint is something passed with --constraint or in a cabal config
05:45:06 * hackagebot hPDB 1.2.0.3 - Protein Databank file format library  http://hackage.haskell.org/package/hPDB-1.2.0.3 (MichalGajda)
05:47:08 <meretrix> bergmark: Thanks.  I didn't notice there was a cabal.config file in the package.  That was it.
05:57:37 <ij> srhb, How do I use the OnError thing?
05:57:51 <srhb> ij: decodeUtf8With ignore $ theByteString...
05:58:20 <srhb> :t decodeUtf8With
05:58:21 <lambdabot> Not in scope: ‚ÄòdecodeUtf8With‚Äô
05:58:22 <srhb> Aw
05:58:26 <ij> Oh, right
06:10:12 <zmbmartin> I have vault in my *.cabal file and I see it installed. If I do caba install vault it shows it is installed. But when trying to build I get an error Could not find module ‚ÄòData.Vault‚Äô
06:10:59 <dcoutts> zmbmartin: the vault package does not provide Data.Vault
06:11:05 <dcoutts> zmbmartin: see cabal info vault
06:11:09 <dcoutts> or the docs on hackage
06:12:06 <zmbmartin> dcoutts: Hmm‚Ä¶ my bad. Thanks!
06:12:25 <dcoutts> zmbmartin: for future reference, cabal info is sometimes helpful :-)
06:13:20 <zmbmartin> dcoutts: How do I find which package does provide Data.Vault
06:13:50 <dcoutts> zmbmartin: you probably do still want the vault package, but use either Data.Vault.Strict or Data.Vault.Lazy
06:14:09 <ij> The answer in general is google, I think.
06:14:24 <dcoutts> zmbmartin: if you look on hackage, you'll see older versions of the vault package do provide Data.Vault
06:14:24 <srhb> zmbmartin: https://www.haskell.org/hoogle/?hoogle=Data.Vault
06:14:32 <zmbmartin> ij: I did use google.
06:14:36 <dcoutts> zmbmartin: so it's been split into two, Lazy and Strict
06:14:47 <zmbmartin> dcoutts: I guess the confusion is I was looking at an old gist.
06:14:48 <dcoutts> zmbmartin: see e.g. http://hackage.haskell.org/package/vault-0.2.0.4  vs the latest version
06:14:53 <zmbmartin> dcoutts: Thanks!
06:17:11 <paxcoder> What would happen if the type constraint was omitted from `instance (Eq m) => Eq (Maybe m) where`?
06:17:45 <merijn> paxcoder: How would you compare "Just x == Just y"?
06:18:21 <paxcoder> merijn, nothing else would change
06:18:45 <merijn> paxcoder: No, I mean how would you implement "Just x == Just y"?
06:19:16 <paxcoder> noam, I just told you implicitly. It's implemented as `Just x == Just y = x == y` already.
06:19:26 <paxcoder> *"No", not "noam"
06:19:29 <merijn> paxcoder: Right, but that means comparing 'x' and 'y'
06:19:34 <paxcoder> Yes it does.
06:19:43 <merijn> paxcoder: Which you can't do if 'x' and 'y' aren't instances of Eq...
06:19:48 <paxcoder> Indeed.
06:20:07 <merijn> paxcoder: Right, so how would "Eq (Maybe m)" possibly work without the constraint?
06:20:14 <paxcoder> That's what I'm asking you.
06:20:46 <merijn> paxcoder: You are asking "what would happen" and the answer is "it wouldn't compile, because that makes no sense"
06:21:33 <paxcoder> Thanks for the anser, but the line of questioning above makes me question whether you're correct, so I'll just have to make my own Maybe :/
06:23:20 <nshepperd> paxcoder: what would you expect (==) to do on an unknown type without an Eq constraint?
06:23:44 <merijn> What's the point in asking if you're not gonna believe the answer?
06:24:26 <paxcoder> nshepperd, nothing. It wouldn't come to that. Either what merijn said would happen, or type inference would implicitly constraint the type.
06:25:09 <mauke]]> type inference isn't going to touch your explicitly declared type
06:25:18 <nshepperd> the inference engine can't add constraints to instance declarations
06:25:30 <mauke]]> > let foo :: a -> a -> Bool; foo x y = x == y in foo "a" "b"
06:25:32 <lambdabot>      No instance for (Eq a) arising from a use of ‚Äò==‚Äô
06:25:32 <lambdabot>      Possible fix:
06:25:32 <lambdabot>        add (Eq a) to the context of
06:25:33 <paxcoder> nshepperd, okay, but why not?
06:26:06 <paxcoder> seedy, the compiler guesses what's wrong correctly.
06:26:09 <nshepperd> well, perhaps it "can", but it won't
06:26:16 <paxcoder> *"see" not "seedy"
06:26:27 <paxcoder> nshepperd, I'm interested in why
06:26:34 <nshepperd> because it would be unnecessarily confusing for your instance declaration to have different context than what you wrote
06:26:40 <mauke]]> why would the compiler ignore your type signatures?
06:26:50 <paxcoder> nshepperd, sorry?
06:26:58 <merijn> paxcoder: Because why would you want the compiler to ignore what you explicitly *tell* it in favour of guesses?
06:27:08 <paxcoder> mauke]], it wouldn't, just would fill in the constraint
06:27:31 <mauke]]> "just"
06:27:33 <nshepperd> paxcoder: if you write 'instance Eq (Maybe a)' what that means is that you *intend* it to be an instance that works for *any* a
06:27:36 <mauke]]> that changes the type
06:27:37 <paxcoder> mauke]], is it not just?
06:27:39 <ski> paxcoder : that *is* ignoring what you told it
06:27:43 <paxcoder> mauke]], so does type inference
06:27:48 <mauke]]> paxcoder: no, it doesn't
06:27:56 <mauke]]> type inference computes the type
06:28:00 <paxcoder> mauke]], if one does, so does the other
06:28:07 <mauke]]> paxcoder: non sequitur
06:28:18 <paxcoder> si sequitur
06:28:28 <mauke]]> do you even latin, bro
06:28:29 <nshepperd> :(
06:28:32 <paxcoder> mauke]], i don't
06:28:40 <paxcoder> one is missing, it is filled. the other is missing, it is filled.
06:28:49 <paxcoder> the only diff is that one is completely missing
06:28:50 <mauke]]> ah
06:28:51 <paxcoder> why not?
06:28:59 <mauke]]> it's not missing, it's empty
06:29:13 <paxcoder> you can say that the the constraint is "empty" too
06:29:18 <mauke]]> that is, you don't have an unknown set of constraints, you have 0 constraints
06:29:30 <paxcoder> well why not view it the way i do?
06:29:36 <mauke]]> because your way is wrong?
06:29:43 <paxcoder> :/
06:29:58 <nshepperd> paxcoder: because you want to be able to deliberately create instances that have no constraints
06:30:08 * hackagebot aeson-schema 0.3.0.4 - Haskell JSON schema validator and parser generator  http://hackage.haskell.org/package/aeson-schema-0.3.0.4 (TimBaumann)
06:30:09 <mauke]]> if you don't declare the type of a function, type inference will kick in for you
06:30:11 <jameseb> an empty type signature doesn't make sense, an empty constraint does make sense
06:30:16 <paxcoder> nshepperd, oh? why?
06:30:32 <mauke]]> it's not like the function has "no type" somehow
06:30:43 <paxcoder> jameseb, ok, but what's the sense?
06:30:45 <mauke]]> it still has one, it's just computed implicitly
06:31:00 <paxcoder> mauke]], there's no need to explain type inference
06:31:03 <nshepperd> paxcoder: 'instance Functor (Const r)' is a random example off the top of my head
06:31:09 <mauke]]> k, bye
06:31:15 <ion> instance _ => Eq (Maybe a) where Just a == Just b = a == b; _ == _ = False, anyone?
06:31:16 <paxcoder> bye, mauke]] 
06:31:23 <nshepperd> paxcoder: the instance holds for any r, with no restrictions
06:31:58 <paxcoder> nshepperd, I'm sorry, I might be missing something. Why is that relevant?
06:32:38 <nshepperd> paxcoder: it's an instance with no constraints
06:33:23 <jameseb> paxcoder: what would a typeless function look like? we can easily come up with functions that need no constraints but not ones that need no type at all
06:33:30 <paxcoder> ion, yeah, if nshepperd proved to me that constraint inference was an undesirable thing in some cases, i would suggest an explicit "no constraints" syntax
06:34:02 <paxcoder> nshepperd, jameseb, i'm not arguing that all types need constraints
06:34:29 <paxcoder> i'm just saying perhaps it would be beneficial to infer them
06:34:47 <paxcoder> if you disagree, i'd like to know why
06:35:46 <ion> paxcoder: I like the present syntax for no constraints. instance _ => ... with PartialTypeSignatures could theoretically result in GHC inferring the constraint.
06:36:23 <paxcoder> ion, why not the other way around (explicit no constraints)?
06:36:44 <nshepperd> a special syntax for no constraints would be inconsistent with ordinary type signatures, where 'a -> a' already means 'forall a. a -> a' with no constraints
06:36:54 <hodapp> if I want a record's accessor functions, then must I automatically also export the constructor?
06:37:04 <indiagreen> hodapp: no
06:37:31 <hodapp> indiagreen: how, without explicitly naming each accessor?
06:37:54 <ion> paxcoder: That increases noise for the case of no constraints, and you'll want to document the constraints in the code anyway.
06:37:56 <indiagreen> hm, don't know how to do it without naming
06:38:15 <ion> for the case of non-empty constraints
06:38:21 <aarvar> wouldn't it be possible to infer the instance head as well
06:38:31 <indiagreen> hodapp: we don't have easy ways to not-export something
06:38:37 <nshepperd> 'instance _ where {...}' lol
06:38:53 <aarvar> make it even shorter, instance where
06:38:53 <ion> instance _ where _
06:39:06 <ion> module Everything where _
06:39:19 <hodapp> it's not a huge deal; I'm just trying to convey that one should use smart constructors to actually build the record
06:39:25 <paxcoder> ion, noise? i guess you could add constraints you don't really want that way, if that's what you're saying.
06:40:48 <paxcoder> Perhaps inferring class constraints (and adding them on-demand) should be the "editor's job". But somehow editors aren't doing half the things we think they should.
06:42:08 <ion> "instance () => C T" has unarguably more noise than "instance C T"
06:43:18 <nshepperd> wanting instance constraints inferred is the unusual case, and therefore is the one that should require new syntax
06:43:36 <nshepperd> if it's even worth doing at all
06:43:46 <paxcoder> nshepperd, don't worry, we're not changing syntax haskell
06:43:51 <paxcoder> nshepperd, or semantics
06:43:52 <paxcoder> ;)
06:44:04 <paxcoder> *haskell syntax
06:44:47 <paxcoder> Just asking. Thanks for the chat.
06:45:08 * hackagebot Workflow 0.8.2 - Workflow patterns over a monad for thread state logging & recovery  http://hackage.haskell.org/package/Workflow-0.8.2 (AlbertoCorona)
06:45:34 <ion> I wouldn't be against PartialTypeSignatures applying to the class constraint, but the programmer better remember to fill in the hole for documentation.
06:47:19 <nshepperd> aww, I was hoping that would already work, heh
06:47:43 <nshepperd> 'Wildcard not allowed In instance head: _ => Monoid (K m)'
06:47:56 <paxcoder> nshepperd, :P
06:48:14 <michaelt> hah, I was just trying it too
06:48:58 <paxcoder> Remember, you heard it from me first. Even though it's probably not a good idea.
06:49:49 <paxcoder> Ok, back to learning me a haskell... or type classes anyway.
06:49:57 <nshepperd> it would have to at least have a warning though, since 'instance _ =>' sure is poor documentation
06:50:12 <nshepperd> or throw an error, printing out the inferred type, like Holes does
06:52:24 <hodapp> waidaminute, I don't even *need* the record accessors. Derp.
06:52:34 * hodapp reaches around on desk for nonexistent coffee cup
06:55:09 * hackagebot ert 0.0.2.1 - Easy Runtime Templates  http://hackage.haskell.org/package/ert-0.0.2.1 (kayo)
07:00:09 * hackagebot stackage-curator 0.8.0.1 - Tools for curating Stackage bundles  http://hackage.haskell.org/package/stackage-curator-0.8.0.1 (MichaelSnoyman)
07:05:33 <merijn> nshepperd: If you like holes, did you see what I did in 7.10? :D
07:10:09 * hackagebot jsonschema-gen 0.3.0.0 - JSON Schema generator from Algebraic data type  http://hackage.haskell.org/package/jsonschema-gen-0.3.0.0 (yuga)
07:10:11 <paxcoder> merijn, I'm alergic to condescension, but I reckon now your line of questioning could have been honest. If so, I'm sorry I jumped to conclusions and thanks for the answers.
07:15:02 <merijn> paxcoder: https://en.wikipedia.org/wiki/Socratic_method
07:15:09 * hackagebot postgresql-simple-sop 0.1.0.6 - Generic functions for postgresql-simple  http://hackage.haskell.org/package/postgresql-simple-sop-0.1.0.6 (glutamate)
07:20:09 * hackagebot groundhog-th 0.7.0.1 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.7.0.1 (BorisLykah)
07:20:11 * hackagebot groundhog-inspector 0.7.1.2 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-inspector-0.7.1.2 (BorisLykah)
07:33:57 <nshepperd> merijn: I haven't used holes that much, actually. What did you change?
07:35:10 * hackagebot hashabler 0.1.0.2 - Principled, cross-platform & extensible hashing of types, including an implementation of the FNV-1a algorithm.  http://hackage.haskell.org/package/hashabler-0.1.0.2 (BrandonSimmons)
07:35:52 <merijn> nshepperd: Ability to defer them until runtime so you can compile and run code with holes in them, plus the ability to silence the warnings so they don't get highlighted in your editor when using ghc-mod/hdevtools/etc
07:35:58 <OutlawStar> question, If I have a State Monad "X s a" and I want to use the value 'a' from it in an IO monad (print the value of 'a'), whats the best way to do that? I thought I should liftM the putStrLn, but that obviously will still give you the wrong type in the end
07:36:29 <merijn> OutlawStar: Is your "X s a" a transformer over IO?
07:36:35 <OutlawStar> not currently
07:36:40 <OutlawStar> is that what i need to do?
07:38:09 <merijn> OutlawStar: If you want to use IO inside it, yes.
07:38:16 <nshepperd> merijn: heh, so no more `error "not implemented"` then
07:38:25 <OutlawStar> merijn: thx
07:38:30 <johnw> OutlawStar: for regular State, that would mean: print $ runState myAction <initialState> 
07:38:38 <paxcoder> merijn, as far as I can see, that's for disproving another's hypothesis. Not answering questions.
07:39:00 <merijn> nshepperd: Exactly, you can just do "_" and get an error that print the line and files and when you remove the "-fdefer-typed-holes" flag they turn into errors so you can't forget them
07:39:16 <johnw> OutlawStar: there's a difference between using the final result value in IO, and using IO while computing that final result
07:39:19 <nshepperd> nice
07:39:52 <OutlawStar> johnw: aw, so i want to just use the final result, which maybe I could just get away with evalState?
07:40:00 <Javran> anybody has experience using mwc-random? https://hackage.haskell.org/package/mwc-random-0.13.3.2/docs/System-Random-MWC.html#v:create wondering if I can use a reader/state to store the created seed.
07:40:05 <johnw> thats' really what evalState would be for :)
07:40:17 <Javran> I guess existential type might help?
07:40:41 <merijn> paxcoder: Well, in this case I was trying to get you to see why your hypothesis/assumption "the constraint is useless" was wrong, but anyway, you get the idea now
07:40:53 <paxcoder> merijn, as for Socratic questioning, that can be a nice tool, but it can also be misused and counterproductive, like in #c. Depending on the "answerer's" attitude.
07:41:03 <OutlawStar> johnw: thx
07:41:23 <paxcoder> merijn, when you assume, you make an ass of u and me ;)
07:42:56 <mauke]]> the things I've seen in ##c weren't so much "socratic questioning" as "making sure someone isn't talking out of their ass"
07:43:17 <paxcoder> mauke]], you and I saw different things then.
07:43:43 <merijn> mauke]]: You're like the only person I expect to be able to have a constructive conversation with the curmudgeons in ##c :p
07:44:21 <mauke]]> I'm talking about things like "int a[10]; what's the type of &a?"
07:44:51 <paxcoder> mauke]], me too
07:45:50 <geekosaur> Javran, did you look at MonadPrim? it's essentially a simpler version of MonadState, and has instances for both STateT and ReaderT
07:45:55 <merijn> paxcoder: Most people I know get the answer to that question wrong
07:46:27 <mauke]]> I'm going to generalize that to: most C programmers don't understand arrays
07:46:36 <dmj`> when did the haskell FFI come out?
07:46:45 <merijn> mauke]]: I would argue that the inventors of C don't understand arrays...
07:46:50 <paxcoder> mauke]], context is key though. This question usually follows one which the asker has no way of inferring the connection. That is, the goal is out of view. That's not pedagogy. That's intellectual onanism. It's a show for others.
07:46:54 <merijn> dmj`: It was an addendum to haskell 98
07:47:07 <mauke]]> paxcoder: non sequitur
07:47:10 <SrPx> Hello, I'm trying to understand prisms. What is the point of review? I indestand preview allows me to go down through branches, `preview (_Left . _Left) (Left (Left 1)) ‚Üí Just 1`, alright. Coming from Lens, I'd expect the opposite operation to be a way to modify those branches to something like (Right (Right 1)).
07:47:14 <merijn> paxcoder: No, it's making sure the foundations for further discussion are solid
07:47:32 <merijn> dmj`: So presumably somewhere close to 1998?
07:47:45 <SrPx> But prisms don't take my value (Left (Left 1)) at all... 
07:47:45 <paxcoder> merijn, the asker has no way of knowing that.
07:48:17 <mauke]]> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
07:48:42 <paxcoder> merijn, I compare their questions to stepping stones that are far apart and go beyond the horizon.
07:49:09 <mauke]]> dmj`: "Copyright (c) [2002..2003] Manuel M. T. Chakravarty"
07:49:51 <johnw> > Left (Left 1) ^? _Left._Left
07:49:52 <lambdabot>  Just 1
07:50:16 <mauke]]> the tarball is from 2005
07:50:22 <dmj`>  I want to make the claim that the haskell FFI is as mature as python's ffi
07:50:23 <johnw> > Left (Left 1) & _Left .~ Right 10
07:50:25 <lambdabot>  Left (Right 10)
07:50:34 <dmj`> python came out in 91 tho
07:50:43 <SrPx> .~ ?
07:50:50 <johnw> "set"
07:50:52 <michaelt> put
07:50:56 <paxcoder> mauke]], what doesn't follow from what?
07:51:03 <hodapp> ##c was exactly like Socratic questioning, if Socrates had a very douchey tendency to conclude that he knew everything after he'd finished asking people a bunch of questions they couldn't satisfactorily answer, instead of, you know, claiming he knew only that he knew nothing
07:51:15 <dmj`> and haskell was 90... not sure the claim works
07:51:39 <michaelt> :t set
07:51:39 <SrPx> I mean, I thought it was for lens
07:51:40 <lambdabot> ASetter s t a b -> b -> s -> t
07:51:47 <mauke]]> paxcoder: "That is, the goal is out of view. ... That's intellectual onanism. It's a show for others."
07:51:51 <paxcoder> hodapp, this
07:52:46 <hodapp> and if I had the benefit of hemlock, too
07:52:59 <michaelt> >  Left (Left 1) & _Right .~ Right 10
07:53:00 <lambdabot>  Left (Left 1)
07:53:04 <mauke]]> just because you don't see the point of something doesn't mean someone's making fun of you
07:53:29 <hodapp> mauke]]: no, I see the point of it
07:54:09 <mauke]]> hodapp: I'm referring to "This question usually follows one which the asker has no way of inferring the connection. That is, the goal is out of view."
07:54:16 <hodapp> oh!
07:54:31 * hodapp disappears
07:54:33 <mauke]]> sorry :-)
07:54:44 <paxcoder> mauke]], If the intent is not to help, isn't it masturbation? Or do you think they're conducting a prolonged social experiment, designed to filter masochists?
07:55:31 <mauke]]> I don't much like your attitude
07:55:36 <dmj`> paxcoder: unnecessary
07:55:45 <paxcoder> dmj`, sorry?
07:56:02 <paxcoder> mauke]], towards whom?
07:56:16 <mauke]]> people on IRC, I guess
07:56:28 <mauke]]> or rather, to talk on IRC
07:56:38 <mauke]]> it's not about persons
07:56:39 <johnw> paxcoder: you'd like Gershom letter to a young haskeller
07:56:52 <johnw> http://comonad.com/reader/2014/letter-to-a-young-haskell-enthusiast/
07:56:56 <paxcoder> mauke]], Well I don't like theirs.
07:57:04 <paxcoder> And that is about persons.
07:58:45 <mauke]]> because you think it's condescension / masturbation / putting on a show, unless it immediately benefits you ("help")
07:58:48 * paxcoder nods to johnw 
07:59:04 <paxcoder> mauke]], i'm actually not talking about myself
07:59:15 <paxcoder> I got into fights with Zhivago because of how he treats other people
07:59:35 <mauke]]> well, duh. Zhivago's a dick
07:59:58 <paxcoder> A lot of the regulars follow his lead.
08:00:30 <merijn> johnw: tbh, I don't think that article applies here
08:00:37 <paxcoder> Anyway, it need not be an immediate benefit, but the prize must be within view. That's how people who want to help do it.
08:00:43 <frerich> Are you guys still talking about some Haskelly thing?
08:00:46 <johnw> merijn: I linked it via the onanism comment
08:00:47 <hodapp> I do not think I have ever encountered a person who utilized more pretense and condescension to the end of being a dick to everyone as Zhivago.
08:00:52 <paxcoder> merijn, from what I read so far, I think it does.
08:01:01 <petternicklas> Hey could someone tell me what the question marks in http://lpaste.net/131755 do?
08:01:19 <merijn> petternicklas: Produce syntax errors
08:01:30 <petternicklas> Haha!
08:01:35 <michaelt> petternicklas: wow something went wrong there
08:01:37 <mauke]]> petternicklas: mark the spot where you need to write your own code, presumably
08:01:40 <frerich> petternicklas: It looks like they are supposed to be replaced with something.
08:02:07 <merijn> petternicklas: Anyway, yes, I'd assume they're supposed to indicate that you have to write your own code there
08:02:22 <petternicklas> Alright thank you!
08:02:30 <michaelt> petternicklas: somehow the arrows ended up on the wrong lines...
08:03:39 <petternicklas> You're right, something wen't wrong when I pasted it
08:04:20 <ion> Did you paste it from a PDF perchance?
08:04:28 <michaelt> I guess it wants something like type Stack a = [a]; push a stack = a : stack
08:04:35 <petternicklas> ion: correct
08:05:41 <ion> For some reason, copying and pasting from PDF files without issues is an unsolved problem.
08:06:23 <mauke]]> "A long time ago on a Haskell IRC, I asked about argument passing in Haskell and whether an array would be passed as a pointer, or copied. I was told I had a ‚Äústrange mental model‚Äù by a helpful snob."  <- that sounds like something I would've said!
08:07:09 <ion> Where is that quote from?
08:07:14 <mauke]]> http://comonad.com/reader/2014/letter-to-a-young-haskell-enthusiast/
08:07:15 <paxcoder> mauke]], umm who are you quoting?
08:07:19 <ion> Ah
08:07:52 <SrPx> okay what exactly are the arguments of prism?
08:08:01 <michaelt> :t prism
08:08:02 <lambdabot> (Applicative f, Choice p) => (b -> t) -> (s -> Either t a) -> p a (f b) -> p s (f t)
08:08:03 <petternicklas> ion: http://lpaste.net/131755 Now it seems to be correct
08:08:04 <SrPx> the source code is using meaningless letters
08:08:18 <funfunctor> what would folks recommend for serialising and deseralising XML?
08:08:33 <SrPx> yes, but what conceptually is (b ‚Üí t) and (s ‚Üí Either t a) ? What would be the variable names of "prism _ _ = ..." ?
08:08:55 <funfunctor> assuming I am just too stupid to understand HXT
08:09:11 <SrPx> i.e., lens takes a getter and a setter. prism takes...?
08:09:47 <dmj`> funfunctor: tagsoup, xml maybe
08:10:22 <merijn> funfunctor: I found http-conduit fairly easy to use and xml-conduit looks very similar, so maybe try that?
08:11:06 <funfunctor> dmj`: merijn thx
08:11:11 <funfunctor> this is all I can pull off https://github.com/Koparo/cc3200-flashtool/blob/cc3x00-xml-parser/parser.hs
08:11:37 <frerich> glguy: Are you around by any chance?
08:15:11 * hackagebot templater 0.0.3.0 - Simple string templater  http://hackage.haskell.org/package/templater-0.0.3.0 (geraud)
08:15:13 * hackagebot cmd-item 0.0.1.0 - Library to compose and reuse command line fragments  http://hackage.haskell.org/package/cmd-item-0.0.1.0 (geraud)
08:18:48 <funfunctor> merijn: I keep getting drawn back to HXT as the best way to do things in Haskell
08:19:12 <c_wraith> HXT?  Really?
08:20:08 <funfunctor> c_wraith: yea, because arrows seem to be the best abstraction
08:20:11 * hackagebot postgresql-simple-sop 0.1.0.7 - Generic functions for postgresql-simple  http://hackage.haskell.org/package/postgresql-simple-sop-0.1.0.7 (glutamate)
08:20:18 <merijn> funfunctor: Arrows are a pretty poor abstraction, imo
08:20:19 <funfunctor> from my current understanding
08:20:29 <funfunctor> ok..?
08:20:51 <merijn> They're fairly rarely used because their interface doesn't nicely map to most things you'd want to use them for
08:20:55 <creichert> xml-conduit has Applicative/Monad interface which I've found much more friendly for xml specifically
08:21:27 <chpatrick> is there some notion of a Category product?
08:21:38 <dmj`> funfunctor: first question, who is making you use xml in the first place, why not json
08:21:39 <chpatrick> so I have two things that are Categories and I'd like to compose both of them
08:22:17 <funfunctor> dmj`: I am trying to replace this shitty Ti flashing tool, it generates XML which I need to stay compat with
08:22:23 <funfunctor> as the config file
08:23:03 <funfunctor> dmj`: thats here https://github.com/Koparo/cc3200-flashtool/blob/cc3x00-xml-parser/test_session/templates/CC3xxx_template.xml
08:24:27 <brenon> Is there a neat way to take a random line from a file? Currently I'm reading all lines to a list, shuffling it and taking the head.
08:25:30 <mauke]]> http://perldoc.perl.org/perlfaq5.html#How-do-I-select-a-random-line-from-a-file?
08:26:37 <kadoban> brenon: Probably not uniformly random, unless you know how many lines there are
08:27:31 <frerich> brenon: You can iterate the file line-by-line and compute a random number for each line. If the number is larger than the largest number you had so far, you memorize the line.
08:27:35 <mauke]]> replace current selection with probability 1 / current_line_number
08:27:46 <frerich> brenon: That way you only need to keep one line in memory at a time.
08:29:20 <brenon> Im trying to learn haskell for a school project and shuffling the list was first thing that came to my mind, but then again i have mostly used imperative languages. But the suggestion frerich made sound better.
08:29:40 <mauke]]> :-(
08:30:12 * hackagebot hjsonpointer 0.2.0.2 - JSON Pointer library  http://hackage.haskell.org/package/hjsonpointer-0.2.0.2 (seagreen)
08:30:23 <Ferdirand> doesn't it have a tiny tiny bias towards earlier lines ?
08:30:46 <michaelt> the perl method has the Donald E. Knuth seal of approval
08:30:49 <frerich> Ferdirand: It's equivalent to assigning a random number to each line (and then picking the line with the largest number), i.e. no.
08:30:52 <lpaste> Geraldus pasted ‚ÄúSQL joins problem‚Äù at http://lpaste.net/131757
08:30:59 <edwardk> srpx: a way to inject a case (like Left/Right, the constructor) and a function that can pattern match to match that case leaving all the other cases. 
08:31:01 <Ferdirand> frerich: what if you have more lines than possible random numbers ?
08:31:09 <edwardk> :t prism
08:31:10 <lambdabot> (Applicative f, Choice p) => (b -> t) -> (s -> Either t a) -> p a (f b) -> p s (f t)
08:31:20 <lpaste> Geraldus revised ‚ÄúSQL joins problem‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/131757
08:31:33 <edwardk> b -> t is the function that embeds, and s -> Either t a is the function that does the match
08:31:38 <lpaste> Geraldus revised ‚ÄúSQL joins problem‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/131757
08:31:44 <edwardk> it is easier to think of at first with a simpler version
08:31:46 <edwardk> :t prism'
08:31:47 <lambdabot> (Applicative f, Choice p) => (b -> s) -> (s -> Maybe a) -> p a (f b) -> p s (f s)
08:32:19 <frerich> Ferdirand: That wouldn't cause a bias towards earlier lines either.
08:32:22 <lpaste> Geraldus revised ‚ÄúSQL joins problem‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/131757
08:32:38 <frerich> Ferdirand: but of course it's difficult either way if you have 1000 lines and only two random states :-)
08:32:49 <edwardk> when a is b there, you can see the connection more directly. the `s -> Maybe a ` would be something like \case Foo a -> Just a; _ -> Nothing
08:33:18 <Ferdirand> frerich: i agree it's equivalent to assigning a random number to each line and taking the largest
08:33:48 <Ferdirand> frerich: but if you end up with the same value on two different lines, what you proposes always selects the first one
08:34:35 <frerich> Ferdirand: Right. If you had less random values than lines in the file, how'd you ensure a uniform distribution with other methods?
08:34:36 <Ferdirand> hence tiny bias towards the earlier lines, or the late ones if you change the larger into a larger-or-equal, right ?
08:35:00 <Geraldus> Hi folks! Sorry, I have some question about SQL joins, but I'm using `esqueleto` and do not know better place to ask my question. If you can help here is link http://lpaste.net/131757 where problem described. Any feedback appreciated. 
08:35:12 * hackagebot mandrill 0.2.2.0 - Library for interfacing with the Mandrill JSON API  http://hackage.haskell.org/package/mandrill-0.2.2.0 (AlfredoDiNapoli)
08:35:22 <brenon> im basically searching a simple solution for it, and i guess that making a list and shuffling that is a lot slower than doing it by comparing random numbers. 
08:35:40 <frerich> Ferdirand: Yeah, in that case you'd get the earlier line. Not sure that's a problem in practice though. A 32bit vaule can handle a fair number of lines, and a 64bit value is even better. ;-)
08:35:58 <Ferdirand> frerich: well i said tiny tiny
08:36:11 <frerich> Ferdirand: Of course, point taken. ;-)
08:36:39 <ion> (someone i know on IRC, not a Haskell programmer) <‚Ä¶> in python i'm traversing a simple hierarchy of data, but at every level of the hierachy, i might not be able to get what i need.  in this case, i need to return None, and move on to the next thing  <‚Ä¶> and suddenly my brain just went "Maybe Monad"  <‚Ä¶> i have been infected!  <‚Ä¶> (this is all your fault, ion and {‚Ä¶})
08:36:44 <frerich> Ferdirand: I first thought you had a typo in your name but now realize that it may be no coincidence that you wake up when it comes to the topic of randomness :-)
08:37:19 <Ferdirand> aha, well, that pun wasn't originally intended
08:37:50 <Ferdirand> in fact i hadn't even noticed, thanks :D
08:41:13 <michaelt> > let read_prism = prism show readEither ; readEither s = case reads s of [] -> Left s; (a,_):_ -> Right a in   ["12","hi","13","thar","14"] & mapped . read_prism %~ (*1000)
08:41:15 <lambdabot>  ["12000","hi","13000","thar","14000"]
08:42:20 <dgpratt> what is the term for a number that has been encoded as a function in e.g. the lambda calculus? peano number?
08:42:36 <michaelt> church numeral, you mean?
08:42:37 <ski> church numeral
08:42:43 <dgpratt> ah
08:42:45 <dgpratt> yes
08:42:57 <dgpratt> thanks michaelt, ski
08:44:20 <paolino> hello, ghc goes out of memory compiling openGLRaw, is there a way to resolve this ?
08:44:45 <dgpratt> moar RAM?
08:44:48 * dgpratt ducks
08:44:56 <funfunctor> merijn: so with xml-conduit how do I chain multiple requireAttr together because I have <Filename name="/sys/mcuimg.bin" category="system">
08:46:02 <creichert> funfunctor: tagName "Filename" parseFileNameAttrs $ \attrs -> ...
08:46:11 <paolino> dgpratt, I have more than 3Gb free, isn't it enough ?
08:46:31 <paolino> GB
08:46:33 <johnw> ((,) <$> requireAttr "name" <*> requireAttr "category")?
08:47:12 <dgpratt> sorry, paolino, I was just trying to be cute -- I'm afraid I have nothing useful to say on the subject
08:47:43 <johnw> ion: wouldn't returning None in the Maybe Monad cause it *not* to "move on to the next thing"?
08:48:19 <funfunctor> johnw: thx!
08:49:02 <ion> johnw: I think he meant the invoker of the traversal will move on to the next thing.
08:49:09 <johnw> ah
08:50:22 <hiptobecubic> paolino, Some libraries really take an outrageous amount of memory to build and link. I remember that using the gold linker was suggested as helpful at one point, I'm not sure what the status of that is now.
08:50:54 <paolino>  you know how to move around compiled libraries, because I could compile it on a 4 GB machine?
08:52:11 <michaelt> paolino: is this with ghc-7.10?
08:52:21 <paolino> yes
08:52:58 <michaelt> https://mail.haskell.org/pipermail/ghc-devs/2015-April/008751.html there are complaints around
08:54:11 <funfunctor> so this is how far I could get with xml-conduit http://lpaste.net/131762
08:54:27 <bergmark> i haven't looked at memory specifically, but compilation of some modules are definitiely a lot slower on 7.10 :-(
08:56:53 <creichert> funfunctor: that's getting there, but i think with xml-conduit you have to go ahead and hash out the parsing of each nested tag as well, so
08:58:35 <creichert> _ <- tagNoAttr "Version" content
08:58:41 <creichert> _ <- tagNoAttr "Type" content
08:58:50 <creichert> just do that until the whole thing compiles, for a start
08:58:56 <creichert> or, runs without err
09:00:34 <funfunctor> creichert: but they are not tag attr they are tags
09:00:47 <creichert> in the \name -> do block
09:00:56 <creichert> you have the attrs parsed correctly, is it working?
09:01:04 <creichert> ah, sorry
09:01:15 <creichert> \(name,category) -> do 
09:01:34 <funfunctor> parser2.hs: XmlException {xmlErrorMessage = "Expected end tag for: Name {nameLocalName = \"CC3xxx\", nameNamespace = Nothing, namePrefix = Nothing}", xmlBadInput = Just (EventBeginElement (Name {nameLocalName = "XML_VER", nameNamespace = Nothing, namePrefix = Nothing}) [])} is how its failing
09:02:31 <creichert> yea, it's not going to skip any tags, either trim down the xml into testable chunks, or write a parser for that too. you'll find it's easier to compose once you get going
09:02:40 <creichert> but i don't see a parser for CC3xx
09:04:13 <funfunctor> creichert: well this is the xml file https://github.com/Koparo/cc3200-flashtool/blob/cc3x00-xml-parser/test_session/templates/CC3xxx_template.xml
09:05:07 <funfunctor> creichert: this is what I have currently http://lpaste.net/131763
09:05:29 <funfunctor> how do I skip the <XML_VER>2</XML_VER> ?
09:06:07 <paolino> it's Graphics.Rendering.OpenGL.Raw.Functions that cannot be compiled in 3GB
09:06:46 <paolino> than I guess it's not a linker problem 
09:06:59 <zmbmartin> How do you split a bytestring? I seem to be having troubles. I have "Number 12345" and I want to split at " " and take the last so I end up with a bytestring of "12345"
09:07:34 <creichert> funfunctor: one moment
09:07:48 <c_wraith> zmbmartin: for that exact use, I'd go with spanEnd isDigit
09:08:31 <c_wraith> well.  isDigit won't work exactly right.  But close enough.
09:08:34 <zmbmartin> c_wraith: But it could be "SomethingElse abcde"
09:09:14 <c_wraith> ah.  Then you want break* instead of span*
09:11:29 <michaelt> funfunctor: are you trying to parse the whole file, or extract some information about Filenames or something?
09:14:06 <zmbmartin> c_wraith: OK so I tried let (_, x) = break (==' ') a. I get an error -> GHC.Word.Word8 with actual type ghc-prim:GHC.Types.Char
09:14:34 <funfunctor> michaelt: parse the whole file, and also write out the file so do both..
09:15:25 <funfunctor> michaelt: I wish to go back and forth between haskell data structures as a internal representation (typed AST) and the actual XML document
09:15:56 <paolino> michaelt, hiptobecubic , it compiled with -O0 :-(
09:16:05 <michaelt> I see, I thought you might be streaming the file
09:16:12 <michaelt> or might be able to, funfunctor 
09:16:46 <funfunctor> michaelt: no, its just a configuration tool
09:16:58 <funfunctor> file is static and updates are atomic
09:17:23 <funfunctor> I don't see why this stuff is always such a pain in the ass
09:18:55 <creichert> funfunctor: it's not, you just need to hash it out fully. i have an example for you
09:19:13 <funfunctor> creichert: oh great, thx!
09:19:19 <WizardOfArc> Has anyone figured out how to get Visual Studio Code to support Haskell?
09:19:22 <Aruro> why this does not work in uterm under ghci -- http://stackoverflow.com/a/2087855 ???
09:19:47 <cite-reader> WizardOfArc: Not currently possible, as far as I can tell. They haven't implemented the plugin architecture yet.
09:20:05 <cite-reader> You could use Atom, I guess.
09:20:29 <funfunctor> yi ftw
09:20:36 <cite-reader> I should try yi.
09:21:13 <Ellah> is it possible to reverse a list of strings using the reverse function?
09:21:32 <Ellah> for some reason keeps coming up with Expected type: [Char] Actual type: [String]
09:21:48 <Aruro> Ellah: it expects string
09:21:54 <Aruro> Ellah: not list of strings
09:21:59 <johnw> foldl' (:) [] <list of strings>
09:22:07 <Ellah> aha
09:22:15 <Ellah> so you actually can't use reverse on a list of strings?
09:22:23 <johnw> :t reverse
09:22:24 <lambdabot> [a] -> [a]
09:22:25 <WizardOfArc> Ellah - are you reversing just each string or all the chars in the string?
09:22:26 <Aruro> Ellah: you can why not?
09:22:31 <Aruro> a is any type
09:22:32 <Ellah> just each string
09:22:35 <Ellah> hmm
09:22:36 <Aruro> in definition above
09:22:37 <Ellah> well i thought so too...
09:22:48 <Aruro> your function expects string
09:22:53 <Aruro> nor reverse itself
09:22:58 <Rotaerk> Ellah, type String = [Char]
09:23:03 <Aruro> what is outside function?
09:23:08 <Rotaerk> so [String] = [[Char]]
09:23:27 <Aruro> @src String
09:23:27 <lambdabot> type String = [Char]
09:23:44 <Aruro> @src reverse
09:23:44 <lambdabot> reverse = foldl (flip (:)) []
09:23:50 <creichert> funfunctor: http://lpaste.net/131765
09:23:54 <Ellah> i'm trying to parse a file
09:23:56 <Aruro> reverse works on anything
09:23:56 <johnw> oh, flip (:)
09:24:00 <creichert> fill in the undefined's with the parsers for those tags
09:24:22 <Aruro> Ellah: maybe you should tell us more details
09:24:37 <WizardOfArc> Ellah - do you mean like this?  ·ö®·õâ·õÅ Œª listOfStrings
09:24:38 <WizardOfArc> ["what","are","you","talking","about?"]
09:24:38 <WizardOfArc> ·ö®·õâ·õÅ Œª reverse listOfStrings
09:24:38 <WizardOfArc> ["about?","talking","you","are","what"]
09:24:39 <creichert> funfunctor: in the parseFilename body (\name -> do, you need to just parse out each tag, similar to how i did tagNoAttr "XML_VER" content)
09:24:51 <Ellah> yeah WizardOfArc 
09:25:04 <WizardOfArc> reverse works fine as is
09:25:14 <Ellah> so i must've had some bad logic somewhere else
09:25:15 <Ellah> ty
09:25:24 <WizardOfArc> yw
09:25:55 <e4x> Hi. How can I solve this? I need to append c to a list: http://lpaste.net/131764
09:26:08 <creichert> funfunctor: adding to that, http://lpaste.net/131766 (make sure to get the other paste first)
09:26:54 <creichert> then, you can improve your types to make sure you're extracting all the data, not just ignoring it
09:26:58 <Rotaerk> e4x, c : list
09:27:14 <Rotaerk> e4x, or what you already have
09:27:26 <Rotaerk> depending on which side of the list it sholud be on
09:27:59 <e4x> Rotaerk: but GHCi says: Couldn't match expected type ‚ÄòIO a0‚Äô with actual type ‚Äò[Char]‚Äô
09:28:14 <Rotaerk> e4x, oh, right, you're in an IO monad, not a list monad...
09:28:17 <Aruro> e4x: append inside print
09:28:22 <dmj`> erc: even if you did, you're not returning, your function is recursing in IO
09:28:25 <Ellah> aha i figured out the issue i'm pretty much retarded =D
09:28:29 <Aruro> print $ list ++ [x]
09:28:31 <dmj`> e4x:*
09:28:45 <Ellah> instead of list concat i was trying to list append
09:29:03 <Aruro> Ellah: and you blamed poor reverse :)
09:29:22 <Ellah> it's 4:30am :p and i haven't been sleeping well lol
09:29:25 <Ellah> i'm a little slow
09:29:45 <dmj`> e4x: I don't see your function terminating either, there's no base case 
09:29:51 <Aruro> Ellah: np, hope irc helped
09:30:09 <Ellah> yeah <3 you guys are like love
09:31:33 <michaelt> e4x: you probably want to write doc_get_word (doc_in, doc_out) = loop "" where loop acc = ... hgetchar etc ... loop (acc ++ [c])
09:32:05 <Ellah> really wish i was just better at haskell but i don't really code outside of work and university assignments, and i fall into that stupid loop of it's not practical to do it in haskell because i'm not comfortable enough in it
09:32:28 <Ellah> then i end up sitting up late at night trying to do everything in haskell and getting confused
09:33:40 <dmj`> Ellah: do it everyday
09:34:02 <Ellah> i'm already lacking sleep as it is :s
09:34:07 <Ellah> i work 20 hours on top of a full course load T_T
09:34:27 <Aruro> Ellah: then maybe ask morequestion in class?
09:34:42 <Aruro> Ellah: i did that 
09:34:49 <Ellah> most of my lectures don't know/like functional programming :p
09:34:52 <Ellah> *lecturers
09:34:55 <creichert> funfunctor: this works: http://lpaste.net/131768
09:34:58 <Ellah> they just expect everyone to do it in java
09:35:03 <Aruro> ah
09:35:17 <Ellah> for like AI they were like here are some libraries that might help, for Java, C, Python
09:35:17 <Aruro> poor people :) god bless them.
09:35:17 <creichert> funfunctor: just use that to parse into you're own types :)
09:35:22 <Ellah> if you're using haskell you're on your own
09:35:40 <e4x> michaelt: i'm trying to write a function that reads a word (alpha chars) from a file and returns it, copying all nonalpha chars before the word to doc_out, sorry for my english
09:35:41 <creichert> funfunctor: you can clean it up tremendously using Applicative
09:35:57 <Ellah> ended up doing it in prolog T_T
09:36:06 <Aruro> niceee :D
09:36:15 <dmj`> Ellah: do all your assignments in haskell
09:36:23 <Ellah> i'm trying dmj`!
09:36:46 <Ellah> it took so long to try and wrap my head around folds
09:36:47 <Aruro> Ellah: dont hesitate asking here, also post on lpaste can speedup process
09:37:10 <Ellah> and like ended up writing this stupid behemoth of a lamba function with like nested folds
09:37:21 <Aruro> @src foldl
09:37:21 <lambdabot> foldl f z []     = z
09:37:21 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:37:22 <Ellah> god that drove me insane
09:37:37 <funfunctor> creichert: thanks! that should keep me started rather than the huge volume of time I was spending on HXT
09:38:33 <Aruro> Ellah: you can lookup source code of prelude and basic functions this really helps
09:38:43 <creichert> funfunctor: no problem, the last example i gave actually parsed everything. good luck
09:39:03 <funfunctor> creichert: yep I know, thank you very much for that!
09:39:35 <kuribas> Is frp already usable for interactive programs?
09:39:36 <michaelt> e4x: here's a beginning http://lpaste.net/2808233897991602176  
09:39:43 <dmj`> Ellah: StateT YouStateType IO () is a good get-things-done stack 
09:39:51 <dmj`> Your*
09:39:57 <Ellah> i'm slowly starting to work my way to things :p
09:40:21 <dmj`> Ellah: are you a comp sci major?
09:40:36 <Ellah> i have a friend that's really good at haskell and i was asking him questions and he starts going into this crazy explanation of how you should use free monads to like separate out IO to keep things more pure and all this stuff and got so lost
09:40:50 <kuribas> For example is it possible to create a canvas in haskell using FRP?
09:40:55 <Ellah> yes dmj` :( well technically yes, comp sci/psych
09:41:04 <creichert> Ellah: we get over excited sometimes :)
09:41:07 <michaelt> e4x: this isn't what is intended, the 'loop' needs to figure out when to return the accumulated string
09:41:13 <dmj`> Ellah: that's not crazy, that's very true. 
09:41:16 <Ellah> omg
09:41:18 <Ellah> don't tell me that T_T
09:41:32 <caconym> anyone know a good article about prisms? I grok lenses, and somewhat grok traversals, but the lens ecosystem is complex and i'm using lens-aeson which is all prisms and it's just magic to me
09:41:36 <Aruro> Ellah: dont listen him, monad is just typeclass no big deal
09:41:43 <e4x> michaelt: oh, thanks!
09:42:01 <schell> is it possible to use TemplateHaskell to generate FFI declarations?
09:42:17 <michaelt> caconym: a prism is a traversal among other things ...
09:42:30 <Ellah> the longer i spend programming the more i realize people are just crazy and there's just different levels of crazy
09:42:33 <schell> meaning, given some Q i‚Äôd like to generate a ‚Äúforeign import ccall‚Ä¶‚Äù
09:43:03 <Aruro> Ellah: they just can not talk simple about simple things.
09:43:26 <caconym> michaelt: yeah, i've gathered that to some degree, but it's not really helping me understand what's happening in lens-aeson on a more practical level
09:43:33 <kuribas> For example let's say I draw elements on a canvas, which has an underlying haskell datatype, is it possible to change the datatype by manipulating control points on the canvas?  Using FRP?
09:43:38 <Ellah> my boss codes everything using constraint handling rules and apparently using that you like write constraints that define your problem and it writes your code for you :(
09:43:42 <c_wraith> schell: the existence of the ForeignD constructor for Dec in Language.Haskell.TH.Syntax suggests the answer is yes.
09:43:51 <Ellah> like wtf
09:44:02 <schell> c_wraith: ah! cool - i will look at that - thank you :)
09:44:02 <Ellah> do i have to learn that i have no idea wtf that is
09:44:42 <Aruro> Ellah: compiler also writes code for you
09:44:53 <Ellah> too much to learn
09:45:03 <Ellah> i just want one thing i'm comfortable with and to venture into other things slowly
09:45:13 <Ellah> but the more i learn the more i'm uncomfortable with everything
09:45:26 <Aruro> Ellah: not too much, everything is function that is IT, and data has types.
09:45:39 <Aruro> too things in total
09:45:41 <Aruro> two*
09:45:46 <Ellah> and template haskell what's template haskell
09:45:50 <Aruro> types+functions
09:46:08 <phy1729> why can't I do 1 + $ 1 + 1  ?
09:46:13 <Ellah> i still have nightmares about templates from C++ :(
09:46:23 <caconym> template haskell is compile-time metaprogramming
09:46:24 <JagaJaga> Is there a function to make a list from 1 element?
09:46:26 <Ellah> the word triggers me :(
09:46:37 <c_wraith> JagaJaga: return/pure/(:[])
09:46:38 <Aruro> phy1729: > (1+) $ 1 + 1 
09:46:47 <Aruro> > (1+) $ 1 + 1 
09:46:47 <godel> JagaJaga: you can hoogle  a -> [a]
09:46:48 <lambdabot>  3
09:46:49 <schell> c_wraith: yes - it seems to all for exactly that - thanks :)
09:46:49 <caconym> it is not the easiest thing to use
09:46:49 <c_wraith> JagaJaga: the last is often called the "robot monkey" operator
09:46:50 <phy1729> Aruro: thanks
09:47:01 <JagaJaga> c_wraith: oh, yeah, stupid am I, forgot that list is a monad
09:47:01 <ion> phy1729: Given two arbitrary infix operators + and *, what does a + * b mean?
09:47:03 <Aruro> phy1729: please meditate on definitions
09:47:48 <Aruro> Ellah: look what monad is
09:47:48 <phy1729> ion: I don't see the relation to the question I asked.
09:47:51 <Aruro> @src Monad
09:47:51 <lambdabot> class  Monad m  where
09:47:51 <funfunctor> > :t unpack
09:47:51 <lambdabot>     (>>=)  :: forall a b. m a -> (a -> m b) -> m b
09:47:51 <lambdabot>     (>>)   :: forall a b. m a -> m b -> m b
09:47:51 <lambdabot>     return :: a -> m a
09:47:51 <lambdabot>     fail   :: String -> m a
09:47:53 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
09:47:58 <Aruro> just 4 functions, BIG deal :)
09:48:10 <funfunctor> :t unpack
09:48:11 <lambdabot>     Not in scope: ‚Äòunpack‚Äô
09:48:11 <lambdabot>     Perhaps you meant one of these:
09:48:11 <lambdabot>       ‚ÄòBS.unpack‚Äô (imported from Data.ByteString),
09:48:12 <Aruro> fail you can even exclude
09:48:59 <ion> phy1729: You might gain insight into why a + $ b can‚Äôt work by thinking of a more familiar operator such as multiplication instead of application.
09:49:11 <Ellah> :( Aruro i had someone trying to explain to me what a monad is and why it's pure mathematically :(
09:49:16 <funfunctor> creichert: any idea how to get the Maybe Text to a String?
09:49:17 <phy1729> ion: oh, I see
09:49:29 <funfunctor> @hoogle Text -> String
09:49:29 <lambdabot> Data.Text.Internal.Lazy showStructure :: Text -> String
09:49:29 <lambdabot> Data.Text.Internal showText :: Text -> String
09:49:29 <lambdabot> Data.Text unpack :: Text -> String
09:49:32 <Ellah> i s till don't understand but it has something to do with type theory or category theory or something :s
09:49:45 <phy1729> I keep thinking of $ as syntax and not a function
09:49:47 <dmj`> Ellah: template haskell is haskell's meta-programming facilities available only at compile time. It's great for generating static things like html/css/js. QuasiQuoters are related, they just give you String argument that can be parsed to generate more haskell. Like a "DSL" - domain specific language 
09:49:54 <creichert> funfunctor: it depends on the intent, you might want to retain the Maybe in your original type, otherwise 'fromMaybe' is probably what you want (with unpack)
09:50:22 <caconym> Ellah: you don't have to know type theory to grok monads, you just have to use them a bunch
09:50:34 <Aruro> Ellah: i told you everything is FUNCTION :) no theories no math. at all.
09:50:35 <wz1000> Does the (->) that appears in the kind of a type have a kind? What kind/type/whatever of thing is it?
09:50:37 <c_wraith> Ellah: Monad is less complex than the reputation it gets.  It's just a (relatively) simple, but highly abstract, pattern of composition.  The IO type is an important concept.  The fact that it forms a monad isn't all that important.
09:50:37 <caconym> Ellah: sorry s/type/category/
09:50:58 <Ellah> hrumphf
09:50:59 <dmj`> Ellah: yea just learn as many type class instances as possible.
09:51:04 <Aruro> Ellah: just read about lambda calculus which is primitive programing language and you good to go
09:51:12 <Ellah> ok :(
09:51:20 <Aruro> Ellah: never be afraid
09:51:24 <caconym> Ellah: they're just so generally useful that it's hard to pin them down with a single explanation that applies to every instance
09:51:25 <Aruro> :)
09:51:25 <WizardOfArc> Ellah: what books are you using to help?
09:51:26 <Ellah> ty for bearing with my rant :p lol
09:51:29 <Ellah> books?
09:51:33 <Ellah> i'm winging everything
09:51:35 <funfunctor> creichert: yea I was trying something like this http://lpaste.net/131772 but it wont typecheck
09:52:05 <creichert> > @hoogle fromMaybe
09:52:06 <lambdabot>  <hint>:1:1: parse error on input ‚Äò@‚Äô
09:52:10 <WizardOfArc> Ellah:  Learn You a Haskell for Great Good  and Real World Haskell are what I am reading now
09:52:12 <creichert> @hoogle fromMaybe
09:52:12 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
09:52:27 <Aruro> @index fromMaybe
09:52:27 <lambdabot> Data.Maybe
09:52:31 <Ellah> i crash coursed haskell in 6 hours and try to remember as i go along
09:52:36 <creichert> funfunctor: takes an a and a Maybe, your a in this case is probably the unpack function
09:52:38 <Ellah> with a lot of googling
09:53:08 <funfunctor> creichert: there is a missing pair of () there but
09:53:09 <WizardOfArc> Ellah: my degree is in Mathematics, so I have a soft spot for things that remind me of Abstract Algebra
09:53:09 <caconym> Ellah: yeah it's gonna take you a lot more than 6 hours :) it's not like learning python or something like that
09:53:59 <WizardOfArc> caconym - I find learning Haskell a bit quicker than Python - but that's probably because I studied some Erlang before
09:54:49 <creichert> funfunctor: yea, i see my bad
09:54:51 <Hijiri> Ellah: this has good resources: https://github.com/bitemyapp/learnhaskell
09:55:02 <Ellah> ok ty :o
09:55:04 <Ellah> i'll bookmark it
09:55:14 <caconym> WizardOfArc: yeah you may be an outlier; the real learning curve seems to me to be imperative -> functional rather than language x -> haskell
09:55:31 <creichert> funfunctor: so, what would the default value be if it's Nothing?
09:55:36 <funfunctor> creichert: but I am just trying to figure out how to unwrap off the Maybe monad nicely here
09:56:00 <funfunctor> creichert: whole thing fails because the XML should always be this schema
09:56:11 <creichert> funfunctor: well, you either need a good default value (for fromMaybe), or apply unpack to what's inside the Maybe, or use an unsafe function like fromJust
09:56:14 <funfunctor> also don't want to put /that/ much effort into this
09:57:22 <funfunctor> creichert: i'll just assume Just
09:57:23 <ion> I‚Äôd say there is never a reason to use fromJust.
09:57:47 <caconym> it's definitely a code smell
09:57:50 <creichert> T.unpack $ fromMaybe (error "You messed up") $ Just "Text"
09:58:12 <funfunctor> I just need this to work enough and revisit this later
09:58:22 <c_wraith> There are cases where I will use fromJust..  But they're less often than times I'll use head
09:58:30 <ion> Even when you‚Äôre completely sure it‚Äôll always be a Just, (\ ~(Just a) -> a) will at least include the location of the pattern match in the error message when your assumption failed.
09:59:18 <creichert> funfunctor: just make sure not to say that too much :), you'll be on to something else and not go back to it
09:59:41 <creichert> ion: that's a good point
09:59:44 <funfunctor> well I don't want to spend days on a perfect XML parser when I need to spend time on reverse eng Ti's stupid flashing tool I am trying to replace here
09:59:51 <WizardOfArc> caconym:  yeah I had an intense learning curve going from Imperative to Functional‚Ä¶  but my Math background helped
10:00:33 <funfunctor> and there is a whole bunch of things to do there.. if I don't get moving with it this project wont ever happen
10:00:41 <funfunctor> since I have limited time for it
10:01:01 <creichert> funfunctor: I would generally recommend retaining the Maybe in the type since that resembles the XML data
10:01:36 <caconym> WizardOfArc: yeah I have a degree in physics and learning Haskell has been a bit like coming full circle... its deep mathematical nature is challenging but very satisfying to me
10:02:03 <funfunctor> creichert: I agree but I need to get moving with this so I can actually get somewhere with the project.. else I am just going to end up with a useless xml parser and no time left
10:02:04 <caconym> WizardOfArc: however I never learned any math that was directly relevant to Haskell :)
10:02:06 <creichert> (the data might not be there), if you're going to a String for some specific reason, like writing to File or whatever, then wait to do it there. fromMaybe is good when there is a clearly sufficient default
10:02:17 <creichert> funfunctor: np, just some tips
10:02:19 <funfunctor> so I am very prepared to cut corners here
10:03:07 <funfunctor> creichert: btw, this is what I am replacing http://www.ti.com/tool/uniflash
10:03:28 <funfunctor> creichert: Ti's Java 800MB windows only binary for flashing SPI chips?!
10:03:51 <Aruro> haskell is a programmers way to feel mathematician :)
10:03:59 <creichert> funfunctor: very cool
10:04:53 <WizardOfArc> caconym: did you ever take Discrete Math or Abstract Algebra?
10:05:17 <funfunctor> creichert: I got some patches ready for flashrom to actually do the flashing, the Haskell tool is to prepare the image in Ti's "value add proprietary format"
10:05:18 <michaelt> > (\ ~(Just a) -> a) Nothing
10:05:19 <lambdabot>  *Exception: <interactive>:3:2-17: Irrefutable pattern failed for pattern (Ju...
10:05:29 <michaelt> very cool ion 
10:05:48 <funfunctor> creichert: the XML file dictates that proprietary format parameters
10:06:02 <breadmonster> michaelt: What does the ~ do?
10:06:04 <funfunctor> creichert: hence I don't really have time to make the XML parser 100% perfect
10:06:22 <michaelt> breadmonster: lazy pattern match. 
10:06:45 <breadmonster> michaelt: Isn't pattern matching lazy by default?
10:06:49 <ion> breadmonster: Tells the compiler you‚Äôre sure it will always match the pattern so it won‚Äôt complain about missing cases.
10:06:56 <ion> breadmonster, michaelt: s/lazy/irrefutable/
10:07:14 <Hijiri> pattern matching is strict
10:07:16 <michaelt> ion: breadmonster right, I was misquoting the error
10:07:17 <ion> It will also refrain from forcing the constructor in the pattern.
10:07:27 <Hijiri> you have to evaluate the argument until you know what the constructor is
10:07:28 <caconym> WizardOfArc: nope, these days I regret not doing more in that vein
10:07:30 <breadmonster> ion: Oh cool, I'll use that from now on.
10:07:34 <Hijiri> (in normal pattern matching)
10:07:48 <mjrosenb> Hijiri: assuming that there is a constructor that you are matching against.
10:08:03 <ion> Which is important in e.g. http://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-OldList.html#partition (see select)
10:08:31 <Hijiri> If you're not matching against a constructor, it's syntax sugar that looks like pattern matching (as far as I know)
10:09:14 <michaelt> ion: what is the standard demonstration of the use of irrefutable patterns. I remember one where you somehow jumpstart an infinite list; it couldn't get started if you inspected the (x:xs) ...
10:09:54 <ion> michaelt: partition is a nice example.
10:10:28 <breadmonster> :t (~) 
10:10:29 <lambdabot> parse error on input ‚Äò)‚Äô
10:10:31 <michaelt> oh, thanks I didn't see you pointed to it
10:10:38 <ion> It‚Äôs syntax, not an operator.
10:10:43 <breadmonster> :t (-~-)
10:10:44 <lambdabot>     Not in scope: ‚Äò-~-‚Äô
10:10:44 <lambdabot>     Perhaps you meant ‚Äò-~‚Äô (imported from Control.Lens)
10:11:14 <breadmonster> ion: Yeah I was wondering if you could use it in operators.
10:11:15 <mjrosenb> ion: that is cute.
10:11:19 <breadmonster> Also, anyone got a nice Lens tutorial?
10:11:33 <CaqueIndyDouche> besenwesen: lol Zak
10:11:52 <WizardOfArc> caconym - by doing Haskell - you are getting close :D
10:14:11 <michaelt> > let bip ~() = () in bip (error "hi")
10:14:12 <lambdabot>  ()
10:14:55 <michaelt> > (let bip ~() = () in bip (error "hi"), let bop () = () in bop (error "hi"))
10:14:57 <lambdabot>  ((),*Exception: hi
10:16:06 <Aruro> michaelt: haskell report tells ~ is used in every let statement implicitly
10:16:46 <ion> > let Just a = Nothing in a
10:16:47 <lambdabot>  *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Just a
10:16:56 <ion> Even the error message reflects that.
10:17:03 <michaelt> indeed, cool
10:17:17 <caconym> WizardOfArc: :) i really love that about Haskell; it's way more enriching than just learning a new programming language
10:17:51 <WizardOfArc> caconym: I think I am getting obsessed
10:19:38 <WizardOfArc> caconym: just an FYI.  A Monoid is any subset of a Group that contains the identity of the Group (Group is an Abstract Algebra term) 
10:21:05 <Aruro> we all should remember this man : http://www.thecorememory.com/Next_700.pdf
10:21:09 <SCHAAP137> R.I.P. Paul Hudak
10:21:15 <SCHAAP137> co-creator of Haskell
10:21:51 <caconym> WizardOfArc: yeah I've been meaning to follow that lead for a while, Groups seem to have a lot of relevance
10:22:06 <caconym> WizardOfArc: and yes I am definitely obsessed :)
10:22:46 <Aruro> R.I.P Pual,  he was rather young
10:22:49 <Aruro> just 62
10:23:28 <Aruro> Paul*
10:25:04 <eacameron> what's the best way to allow internal access to Record fields but prevent the end lib user from using the Record fields directly?
10:25:51 <Aruro> eacameron: providing access funcitons?
10:26:14 <arw> i would alias the record type and not provide exported accessors unless desired.
10:27:36 <WizardOfArc> caconym: A Group is a set of (type x) and an operator (op) such that operating on the types x will always get you type x‚Ä¶. the operator has associativity, set contains and idendity (e) such that e `op` a = a, a `op` e = a.  and all inverses ‚Ä¶  a is inverse of b iff a `op` b = e (identity)....
10:29:48 <SrPx> edwardk: thank you!
10:29:53 <SrPx> I think I'm getting it
10:29:55 <SrPx> trying to implement
10:33:09 <eacameron> Aruro: You mean, only export the accessors in the external interface?
10:33:10 <eacameron> hmm
10:36:17 <Myrl-chan> Why has no one bothered to make a stack monad? Aside from it being able to be done with `State [a] a` or something similar.
10:39:08 <simpson> Myrl-chan: Well, which type were you thinking of?
10:39:22 <Myrl-chan> simpson: What do you mean?
10:39:26 <slack1256> Myrl-chan: Because monads aren't as much about data-structures than semantics
10:39:35 <slack1256> ie the list monad is a monad about non-determinism
10:39:42 <simpson> Myrl-chan: What makes your state example different from a hypothetical staack monad?
10:40:09 <Myrl-chan> simpson: I don't think it'd be any different. I may be wrong though, I only decided to look at stack monads today.
10:40:38 <Myrl-chan> s/stack/state/
10:40:48 <simpson> Myrl-chan: So why not just have `newtype Stack a = Stack { runStack :: State [a] a }`?
10:41:00 <Myrl-chan> simpson: Yeah, I'm thinking of that.
10:41:52 <Myrl-chan> simpson: But since stacks are common things, I'm pretty sure someone else has thought of this before, and if they did, they probably realized it's a bad idea.
10:42:43 <Myrl-chan> (Judging of the absence of topics about stack monads upon searching "stack monad" on google)
10:42:55 <ski> simpson,Myrl-chan : that `Stack' is not a functor
10:43:01 <simpson> Myrl-chan: I can't find it, but there was a very nice writeup of writing stack machines using tuples, and making Haskell type-check the stack depth.
10:43:14 <simpson> ski: Yeah. I'm just derping. Not awake yet.
10:43:41 <Myrl-chan> ski: Well, you could cheat and have it done on every element in the stack? :P
10:43:57 <ski> (i don't understand what you mean)
10:44:18 <Myrl-chan> ski: Like, if we use lists as a stack, then just map it over.
10:44:25 <Myrl-chan> I'm half-joking, of course.
10:44:33 <ski> @unmtl State [a] a
10:44:33 <lambdabot> [a] -> (a, [a])
10:45:10 <Myrl-chan> ski: I don't see any problem with that. Is there a problem with that?
10:45:12 <ski> you can't write a sensible operation of type `forall a b. (a -> b) -> (([a] -> (a,[a])) -> ([b] -> (b,[b])))'
10:45:23 <Myrl-chan> ski: Ah, I see.
10:45:43 <koomi> eacameron: it is common to export the accessors and a default value but not the constructor of a record type
10:45:51 <_nak> so i picked Docker Essentials that comes out in May
10:46:03 <ski> `a' occurs both covariantly (/positively) and contravariantly (/negatively) in `[a] -> (a,[a])' (and therefore in `State [a] a')
10:46:19 <Myrl-chan> ski: So, how should one preserve multiple values in a state monad?
10:46:37 <Myrl-chan> preserver/store
10:46:42 <_nak> my irc has been acting so f weird
10:46:44 <ski> if you say `newtype Stack s a = MkStack {runStack :: State [s] a}', then that'd be a different thing
10:46:54 <simpson> Myrl-chan, ski: Separate type: newtype Stack s a = Stack { runStack :: State [s] a }
10:47:07 <simpson> Damn you, laggy IRC.
10:48:00 <Myrl-chan> I should really hide netsplit rejoins...
10:48:00 <ski> nak : netsplit, 'tseems
10:48:13 <mniip> Myrl-chan, if you say 'type Foo a = State [a] a' that's not even a functor. 'type Foo s a = State [s] a' is a whole different thing
10:48:29 <ski> mniip : already said :)
10:48:45 <Myrl-chan> I see.
10:49:35 --- mode: ChanServ set +o geekosaur
10:49:42 <nak> ski yeah i see that now
10:49:54 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org | Learn, Teach, or Get Out of the Way! | https://news.ycombinator.com' by geekosaur
10:49:56 <Myrl-chan> mniip: I see my mistake now.
10:49:58 <mniip> ski, I wonder, what are other ways to use a type variable contravariantly
10:50:00 <geekosaur> erp
10:50:10 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org | Learn, Teach, or Get Out of the Way!' by hobana.freenode.net
10:50:10 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org | Learn, Teach, or Get Out of the Way! | https://news.ycombinator.com' by ChanServ
10:50:28 <mniip> other than to the left of ->
10:50:33 --- topic: set to 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org | https://news.ycombinator.com/item?id=9465999' by geekosaur
10:50:43 --- mode: geekosaur set -o geekosaur
10:51:27 <ski> mniip : in Haskell, it's the source of contravariance
10:51:37 <mniip> so no other place?
10:52:03 <ski> mniip : in SML/NJ, there's a type constructor for continuations (logically corresponding to negation), which is also contravariant
10:52:14 <Myrl-chan> mniip: Anyways, I don't see a stack monad when I searched in google. Is it because it's too simple to implement that it's nothing special, or is it because people find it a stupid idea?
10:52:32 <Aruro> L T or get out of the way, thats the spirit.
10:52:35 <mniip> Myrl-chan, stack monad as in a state monad implementing push/pop?
10:52:46 <Myrl-chan> mniip: More or less.
10:52:55 <mniip> uh
10:52:58 <mniip> just use State
10:53:00 <slack1256> Myrl-chan: what computational effect does the stack monad models?
10:53:06 <ski> mniip : it is possible to have a write-only view of a mutable cell (or a communication channel end you can only send stuff into). that would be contravariant
10:53:20 <Myrl-chan> slack1256: I really don't know. :|
10:53:32 <Myrl-chan> It might be useful in some cases.
10:53:43 <mniip> push x = modify (x:)
10:54:06 <mniip> pop = get -> \(x:xs) -> put xs >> return x
10:54:13 <slack1256> :-) Usually monads that are popular have defined semantic/use case in mind
10:54:21 <mniip> oops
10:54:25 <mniip> pop = get >>= \(x:xs) -> put xs >> return x
10:54:29 <funfunctor> @hoogle String -> bool
10:54:29 <lambdabot> Did you mean: String -> Bool
10:54:29 <lambdabot> Prelude error :: [Char] -> a
10:54:29 <lambdabot> Debug.Trace trace :: String -> a -> a
10:54:39 <srhb> And the semantics for Stack are exactly those of State, presumably.
10:54:44 <ski> mniip : but this requires being able to compose that sink with a pre-process function (this is a variation of `CoYoneda'). and you *can* think of this as going back to `(->)' again
10:54:44 <srhb> No sense in duplicating anything.
10:54:46 <funfunctor> @hoogle String -> Bool
10:54:46 <lambdabot> Test.QuickCheck.Text isOneLine :: String -> Bool
10:54:46 <lambdabot> System.FilePath.Windows hasDrive :: FilePath -> Bool
10:54:46 <lambdabot> System.FilePath.Posix hasDrive :: FilePath -> Bool
10:55:21 <funfunctor> @hoogle Int -> Bool
10:55:21 <lambdabot> Data.Bits testBit :: Bits a => a -> Int -> Bool
10:55:22 <lambdabot> Data.IntSet member :: Key -> IntSet -> Bool
10:55:22 <lambdabot> Data.IntSet notMember :: Key -> IntSet -> Bool
10:55:33 <mniip> funfunctor, what are you trying to do
10:55:37 <Myrl-chan> Should I use state monad for virtual machines?
10:55:41 <ski> Myrl-chan : `StateT [s] Maybe a' might be more interesting ..
10:56:07 <funfunctor> mniip: parse some xml. I have type Maybe Text but the XML has a bool
10:56:08 <mniip> Myrl-chan, you should use the state monad for universe simulations
10:56:16 <Myrl-chan> My first idea was to simply keep looping with one argument as the state of the mahine.
10:56:39 <mniip> Myrl-chan, that's closure-style state
10:56:41 <funfunctor> mniip: <verify>false</verify> winds up with type Maybe Text
10:57:22 <ski> mniip : it might be possible to make some kind of "subtraction" type operation (subtractive logic, dual-intuitionistic logic)
10:57:25 <Myrl-chan> ski: I think it's a good thing to error if you underflow a stack rather than return nothing.
10:57:54 <ski> mniip : apart from these that i've mentioned, i don't know of any more sources of contravariance
10:58:01 <mniip> funfunctor, maybe False (== "true")
10:58:26 <mniip> assuming you want "true" to mean True, and everything else to mean False
10:58:28 <mniip> including a failure
10:58:45 <ski> Myrl-chan : in a sense, `Nothing' represents an error, a failure. it depends on what you want, what kind of applications you have in mind
10:58:58 <Myrl-chan> ski: True. Thanks.
10:59:05 <mniip> Myrl-chan, EitherT
10:59:28 <mniip> wait isn't it called ErrorT
10:59:48 <ski> (and `Maybe' in `StateT (...) Maybe' will definitely manifest itself as the possibility of a failure, that will abort the whole state computation)
11:01:13 <Myrl-chan> Hmmm
11:01:24 <ski> Myrl-chan : if during sensible computations, you don't expect to ever underflow the stack, then what you're saying is right. otoh, if a sensible computation might sometimes not know whether it'll underflow or not (so you want to check it, or, iow, try and see), then i think using `Maybe' as above is one way to do that
11:01:32 <neuroserpens> Can anyone tell me how to apply read :: Int to a list of strings? I'm always getting errors no matter what I do >:(
11:01:48 <neuroserpens> how to map*
11:01:48 <Myrl-chan> ski: Ah, okay.
11:02:29 <Myrl-chan> So, concerning VMs, I'd probably use a tuple, of (registers, memory). Where the memory is a list of arrays.
11:02:36 <ski> > map (read :: String -> Int) ["1","23","456"]
11:02:37 <lambdabot>  [1,23,456]
11:02:42 <ski> > map (read :: String -> Int) ["1","23","456","oops"]
11:02:43 <lambdabot>  [1,23,456,*Exception: Prelude.read: no parse
11:02:45 <Myrl-chan> But arrays require a specific monad, don't they?
11:02:50 <Cale> > map read ["1","23","456"] :: [Int]
11:02:52 <lambdabot>  [1,23,456]
11:03:01 <neuroserpens> ski:ah i need to write String -> Int
11:03:05 <neuroserpens> ski: thanks a lot
11:03:09 <Cale> Myrl-chan: Mutable arrays require IO or ST in particular.
11:03:09 * neuroserpens tries it
11:03:09 <ski> neuroserpens : or as Cale did it
11:03:26 <ski> (Myrl-chan : or `STM')
11:03:28 <neuroserpens> Cale: thank you too
11:03:35 <Myrl-chan> Cale: How do you think I should go through this?
11:03:38 <Cale> neuroserpens: The important thing is that there's just enough type information in your program *somewhere* for it to be able to work out that you want to read Int values
11:03:58 <Cale> Myrl-chan: Sorry, I haven't caught up on the context... what are you trying to do?
11:04:00 * Myrl-chan wonders if that made sense.
11:04:14 <ski> Myrl-chan : .. there's also immutable arrays, that can sometimes be sufficient
11:04:17 <Cale> Oh, implement a virtual machine?
11:04:23 <Myrl-chan> Mhm.
11:04:58 <ski> neuroserpens : how do you want to handle parse failure ?
11:05:00 <Cale> Well, if performance is not *terribly* important, you might just use an IntMap
11:05:34 <ski> neuroserpens : where is the list of strings coming from ?
11:05:57 <Myrl-chan> Cale: Okay.
11:06:04 <Cale> IntMap has pretty decent performance, but it won't be as fast as reading/writing a mutable array. The advantage is that it's an immutable structure, so you can easily undo things without paying a premium in terms of memory.
11:06:30 <Cale> (i.e. you can keep hold of old versions of the IntMap)
11:06:37 <breadmonster> Interesting.
11:07:02 <Myrl-chan> Cale: Forgive my ignorance, but how would that be useful?
11:07:15 <neuroserpens> ski: interact
11:07:29 <neuroserpens> lines applied to stdin
11:07:38 <ski> Myrl-chan : in case a bulk update (or a recursively defined array) would be enough, immutable arrays could be considered. however i suspect that your "simulation" will require fine-grained update in general ..
11:07:42 <Myrl-chan> forgive? excuse? Meh.
11:08:07 <Cale> Myrl-chan: Well, it really depends on the application. Being able to step backwards in time might be incredibly useful if you're writing a machine simulator for debugging purposes.
11:08:09 <neuroserpens> ski: but it seems I need to map show later on to get strings back after I've done calculation because interact expects string -> string
11:08:40 <Myrl-chan> ski: It's not meant to be a serious VM. Rather, I just wanted to check if my ISA would work. I would use an HDL, but I wanted to try something different.
11:09:01 <Myrl-chan> But a fast read/write would be preferable.
11:09:05 <Cale> (In fact, doesn't everyone wish that debuggers all had an "unstep" command?
11:09:06 <Cale> )
11:09:12 <ski> neuroserpens : and parse failure ?
11:09:19 <Myrl-chan> Cale: Ah!
11:09:29 <neuroserpens> ski: no the parse failure was solved by the String -> Int thing
11:09:32 <ion> Cale: I wish the world had an ‚Äúunstep‚Äù command.
11:09:34 <Hafydd> Yes, I'd love to be able to undo real-world effects.
11:09:34 <neuroserpens> I thought I only needed :: Int
11:09:38 <neuroserpens> ski: that was the problem
11:09:46 <Myrl-chan> Cale: Thank you. It'd be nice to be able to model the differences of states.
11:09:50 <ski> neuroserpens : i don't see how that solves the possibility of parse failure
11:10:01 <Myrl-chan> Cale: Should I use IntMap directly, or should I use a list of IntMaps?
11:10:10 <neuroserpens> ski: well... it did... unless we are talking about different things
11:10:11 <exio4> Cale: that's why I am using an intmap for representing memory on this toy interpreter, it's really cool to have the past available :p 
11:10:14 <mniip> hmm
11:10:25 <mniip> anyone know a shorter way to write 'zipWith const'
11:10:28 <hiptobecubic> Myrl-chan, you can see the idea in action in elm's debugger: http://debug.elm-lang.org/edit/Mario.elm
11:10:58 <Cale> Myrl-chan: Well, you might have the list of all past states
11:11:06 <Hafydd> mniip: zipWith ($)?
11:11:07 <ski> neuroserpens : i'm talking about `map (read :: String -> Int) ["1","23","456","oops"]' -- iow, what happens if the input string data is not of the expected numeric format ?
11:11:10 <Myrl-chan> Cale: Ah, true.
11:11:19 <mniip> Hafydd, that has a differnt type
11:11:20 <Hafydd> Or...
11:11:31 <neuroserpens> ski: It won't be. That's why we are talking about different things.
11:11:46 <Hafydd> Oh, my mistake.
11:11:50 <bdesham> Clojure had a library called kibit that could scan your code and try to point out unidiomatic pieces... is there anything similar for Haskell?
11:11:56 <mniip> > zipWith const [1..5] "hello world"
11:11:57 <lambdabot>  [1,2,3,4,5]
11:12:00 <mniip> oops
11:12:02 <arkeet> bdesham: hlint
11:12:03 <exio4> bdesham: hlint? 
11:12:04 <mniip> > zipWith const  "hello world" [1..5]
11:12:05 <Hafydd> I was thinking of zipWith id, for some reason.
11:12:06 <lambdabot>  "hello"
11:12:08 <Cale> Myrl-chan: Each of which would have an IntMap, and those IntMaps having been constructed in terms of one another, each one will cost only about log(size of memory) (assuming one write was done)
11:12:09 <neuroserpens> ski: And I was getting a "no parse" if I left out the typing or tried :: Int only
11:12:12 <Myrl-chan> mniip: (\x _ -> x) ?
11:12:21 <arkeet> that is const yes
11:12:23 <mniip> Myrl-chan, that's not much shorter
11:12:33 <mniip> than 5-letter const
11:12:34 <neuroserpens> Another question... Can I use guards inside a lambda? If so, what's the syntax?
11:12:36 <Myrl-chan> Oh wait.
11:12:36 <Myrl-chan> mniip: It won't work either, if the other list is shorter.
11:12:37 <ski> neuroserpens : if the input isn't supposed to be in a bad format, and you're ok with the program aborting if it is anyway, then that's ok. i'm just saying that this is a consideration you have to make
11:12:41 <bdesham> arkeet exio4: ah, will check it out. thanks!
11:12:42 <mniip> Myrl-chan, that's not the case
11:12:58 <Cale> neuroserpens: You can use case expressions inside a lambda, and guards in a case expression
11:12:58 <Myrl-chan> mniip: (fst . zip)
11:13:01 <Myrl-chan> :D
11:13:05 <Myrl-chan> Oh wait
11:13:08 <Myrl-chan> It's map fst. zip
11:13:08 <mniip> map fst
11:13:25 <neuroserpens> ski: I know that man. The input is being treated at interface level. It helps more if you keep it to the topic though.
11:13:33 <Myrl-chan> mniip: `map fst . zip` seems shorter, and I think it's equivalent in all cases.
11:13:34 <neuroserpens> Cale: I see. Thanks.
11:13:43 <mniip> that's a 2 char improvement
11:13:43 <arkeet> map fst . zip = zipWith const
11:13:45 <arkeet> same length I guess
11:13:53 <arkeet> but avoids building a tuple
11:13:56 <exio4> what's wrong with zipWith const? 
11:14:03 <arkeet> with zipWith
11:14:05 <Cale> neuroserpens: There's also https://downloads.haskell.org/~ghc/7.8-latest/docs/html/users_guide/syntax-extns.html#multi-way-if
11:14:22 <neuroserpens> Cale: Taking a look
11:14:28 <exio4> and it is (map fst .) . zip, I think
11:14:39 <ski> neuroserpens : i'm sorry if i veered from your question. it just wasn't clear to me how you intended to handle this situation
11:14:44 <exio4> @type (map fst .) . zip
11:14:45 <lambdabot> [b] -> [b1] -> [b]
11:14:47 <exio4> @type zipWith const 
11:14:48 <lambdabot> [c] -> [b] -> [c]
11:14:54 <Cale> neuroserpens: and scroll up a little to see lambda-case which is another extension
11:14:55 <arkeet> > map fst . zip [1..5] $ "hello w"
11:14:56 <lambdabot>  [1,2,3,4,5]
11:14:58 <arkeet> er
11:15:04 <ski> (since if you wanted to catch that parse failure, then `map (read :: String -> Int)' would not be a good way to do the parsing)
11:15:05 <Cale> I wonder if those are on in lambdabot...
11:15:09 <arkeet> > map snd . zip [1..5] $ "hello w"
11:15:10 <lambdabot>  "hello"
11:15:19 <arkeet> but you can zipWith (const id)
11:15:37 <Cale> > map (\case [] -> 0; (x:xs) -> 1) [[],[1,2],[3],[],[4]]
11:15:38 <lambdabot>  <hint>:1:6: parse error: naked lambda expression ''
11:15:53 <arkeet> anyway, zipWith const is fine.
11:16:05 <Cale> seems not
11:16:13 <Myrl-chan> @pl (\x y -> take (length y) x)
11:16:13 <lambdabot> flip (take . length)
11:16:16 <SrPx> Ok I think I get it, but what exactly is bt, seta and afb on "prism bt seta afb = either pure (fmap bt . afb) . seta"
11:16:25 <arkeet> bt :: b -> t
11:16:27 <arkeet> seta :: s -> Either t a
11:16:29 <arkeet> afb :: a -> f b
11:17:05 <neuroserpens> ski: the issue is solved. thanks
11:17:10 <SrPx> ... I mean what do the acronyms... what you are kidding me right
11:17:15 <Myrl-chan> Welp.
11:17:15 <Myrl-chan> That doesn't seem much better.
11:17:17 <arkeet> that's all it is
11:17:21 <mniip> Myrl-chan, that's 0 char improvement
11:17:31 <SrPx> aaaaaaahhhh
11:17:36 <Myrl-chan> mniip: Lol. :P
11:17:44 <arkeet> Myrl-chan: it's worse because it's too strict.
11:17:45 <mniip> well better than negative
11:17:45 <SrPx> wow... really...
11:18:28 * SrPx not sure if he laughs or cries
11:19:07 <Myrl-chan> I know! Pattern matching fixes everything.
11:19:24 <Myrl-chan> jk
11:19:49 <edwardk> srpx: i use that form of sort of 'hungarian notation' when the types get messy and i want to keep all the parts straight
11:20:03 <mniip> ooh
11:20:04 <arkeet> take n = zipWith (const id) [1..n]
11:20:15 <mniip> if I replace iterate-zip with foldr it's much shorter
11:20:17 <arkeet> also for more clever uses of zipWith:
11:20:19 <arkeet> @where sneaky
11:20:19 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
11:20:29 <SrPx> edwardk: I can't believe I didn't see it
11:20:50 <arkeet> @@ @let @where sneaky
11:20:51 <lambdabot>  Defined.
11:20:54 <arkeet> > dropFromEnd 3 [1..10]
11:20:55 <lambdabot>  [1,2,3,4,5,6,7]
11:20:57 <arkeet> > dropFromEnd 3 [1..]
11:20:58 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
11:21:33 <edwardk> i always loved that trick
11:21:51 <breadmonster> edwardk: What's Hungarian notation?
11:21:51 <edwardk> also particularly fond of the lazier reverse
11:21:56 <Hafydd> Oh my.
11:21:57 <arkeet> @where sneaky2
11:21:57 <lambdabot> lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = []
11:21:59 <Hafydd> Sneeeaaakkkyyyy.
11:22:05 <SrPx> okay I'll call those "prism inject match = ...", I guess it makes sense from what you said
11:22:46 <Hafydd> http://fc01.deviantart.net/fs44/i/2009/113/8/8/Charlie_The_Unicorn_3__Sneaky_by_tdrusk.png
11:22:55 <ski> (.. i sometimes use "names" like that `afb')
11:22:55 <Myrl-chan> Welp.
11:22:59 <Myrl-chan> I'm going to sleep.
11:23:00 <joneshf-laptop> edwardk, what's funny was that when I was implementing the ps version of lenses I ended up doing the same sort of thing.
11:23:03 <Myrl-chan> Good night everyone.
11:23:06 <edwardk> breadmonster: it was a tool used in the days of crappy type systems, pushed forth originally by Simonyi to make identifiers contain the info about their types: http://en.wikipedia.org/wiki/Hungarian_notation
11:23:29 <edwardk> breadmonster: be thankful you never had to learn about it =)
11:23:33 <arkeet> @where sneaky3
11:23:33 <lambdabot> I know nothing about sneaky3.
11:23:37 <joneshf-laptop> edwardk, then i peeked at the implementation of something adn was like, "I don't remember writing this..wait, this is haskell."
11:23:47 <breadmonster> edwardk: I had to learn monads instead!
11:26:01 <neuroserpens> Question number 3: Is there a way to throw away a getLine 's result without having to >>= \_ -> ?
11:26:20 <zaquest> neuroserpens, >>
11:26:28 <neuroserpens> zaquest:I tried that and got an error
11:26:38 <neuroserpens> zaquest: That's what I thought... I'll try it again though
11:27:30 <orion> :t (<|>)
11:27:31 <lambdabot> Alternative f => f a -> f a -> f a
11:27:34 <breadmonster> neuroserpens: x >> y = x >>= \_ -> y
11:28:03 <breadmonster> :t (>>)
11:28:04 <lambdabot> Monad m => m a -> m b -> m b
11:28:14 <breadmonster> orion: That's really interesting.
11:28:22 <neuroserpens> http://pastie.org/10122575
11:28:29 <neuroserpens> Here is what's happening with >>
11:28:34 <breadmonster> How does Parsec use it to refer to first match among alternates then?
11:29:02 <breadmonster> I think you're getting it wrong.
11:29:26 <edwardk> joneshf-laptop: =)
11:29:36 <breadmonster> neuroserpens: interact will deal with the IO for you. Just figure out how to decode your input from a string, and how to reencode it into a string.
11:30:18 <neuroserpens> breadmonster: I get you, but the thing is the first line of that input is disposable
11:30:40 <JagaJaga> What does ~(y:ys) mean?
11:30:51 <neuroserpens> breadmonster: If I do getLine >>= \_ -> interact $ etc it works
11:30:53 <breadmonster> neuroserpens: Okay, so the first line just doesn't matter and you wanna then move on to interact?
11:30:53 <ion> JagaJaga: Irrefutable pattern.
11:30:59 <neuroserpens> breadmonster: yes
11:31:14 <srhb> JagaJaga: It's a lazy pattern match on a list of at least one element y and a tail ys which may or may not be []
11:31:16 <ion> JagaJaga: It will not force the constuctor upon the pattern match.
11:31:26 <breadmonster> :t getLine >> interact
11:31:27 <lambdabot>     Couldn't match expected type ‚ÄòIO b‚Äô
11:31:27 <lambdabot>                 with actual type ‚Äò(String -> String) -> IO ()‚Äô
11:31:27 <lambdabot>     Probable cause: ‚Äòinteract‚Äô is applied to too few arguments
11:31:34 <John> hey peeps :)
11:31:35 <neuroserpens> breadmonster: hahaha
11:31:41 <John> I have two files, containing the same fundamental information
11:31:45 <breadmonster> :t getLine >> interact id
11:31:45 <lambdabot> IO ()
11:31:46 <John> They can be converted from one to the other losslessly
11:31:51 <John> but, bit-for-bit, they are different
11:31:55 <JagaJaga> srhb: ion: oh! Interesting, thank you.
11:31:56 <John> what would you call them? 'informationally-identical' ?
11:32:06 <breadmonster> neuroserpens: That. Supply a function to interact, and you should be able to do the rest.
11:32:15 <breadmonster> John: equivalent?
11:32:31 <John> breadmonster:  just straight-up equivalent?
11:32:40 <JagaJaga> :t getLine >>= interact . const
11:32:41 <lambdabot> IO ()
11:32:46 <breadmonster> I'm assuming you're talking about the file formats, but yes.
11:33:00 <neuroserpens> breadmonster: I already supplying a function. Do I really need id though?
11:33:08 <breadmonster> neuroserpens: Can I see your code?
11:33:19 <breadmonster> I don't think you're getting what I'm saying.
11:33:24 <breadmonster> @src interact
11:33:25 <lambdabot> interact f = do s <- getContents; putStr (f s)
11:33:25 <neuroserpens> breadmonster: ok
11:33:39 <neuroserpens> breadmonster:  main = getLine >> interact $ unlines . map (show . (\x -> if mod x 2 == 0 then x else x - 1) . (read :: String -> Int)) . lines
11:33:58 <breadmonster> :t getLine >> interact $ unlines . map (show . (\x -> if mod x 2 == 0 then x else x - 1) . (read :: String -> Int)) . lines
11:33:59 <lambdabot>     Couldn't match expected type ‚Äò(String -> String) -> t‚Äô
11:33:59 <lambdabot>                 with actual type ‚ÄòIO b0‚Äô
11:33:59 <lambdabot>     The first argument of ($) takes one argument,
11:34:04 <ion> That @src interact forgets that interact also closes stdout.
11:34:28 <breadmonster> :t getLine >> interact (unlines . map (show . (\x -> if mod x 2 == 0 then x else x - 1) . (read :: String -> Int)) . lines)
11:34:29 <lambdabot> IO ()
11:34:37 <neuroserpens> breadmonster: wow shit
11:34:40 <breadmonster> neuroserpens: Bing.
11:34:47 <neuroserpens> breadmonster: $ is the fakking culprit
11:35:04 <ion> Oh, wait. I misread an error message from something i tried. It was about stdin after all due to getContents.
11:35:09 <breadmonster> I forget what the parse tree looks like
11:35:15 <neuroserpens> breadmonster: you are my hero <3
11:35:32 <breadmonster> Haha no problem man.
11:35:59 <breadmonster> I'm sure there's a cleaner way of doing that.
11:36:12 <breadmonster> :t getLine >> interact . unlines . map (show . (\x -> if mod x 2 == 0 then x else x - 1) . (read :: String -> Int)) . lines
11:36:13 <neuroserpens> breadmonster: I'm a noob so I'm sure there is
11:36:13 <lambdabot>     Couldn't match expected type ‚ÄòIO b‚Äô
11:36:15 <lambdabot>                 with actual type ‚ÄòString -> IO ()‚Äô
11:36:17 <lambdabot>     In the second argument of ‚Äò(>>)‚Äô, namely
11:36:23 <breadmonster> neuroserpens: Yeah me too.
11:36:36 <neuroserpens> breadmonster: hahahaha woe are us :(
11:37:11 <neuroserpens> breadmonster: but I think you can't compose interact with the function it expects as an argument
11:37:28 <breadmonster> No, there has to be a shorter way.
11:37:29 <neuroserpens> :t interact
11:37:30 <lambdabot> (String -> String) -> IO ()
11:37:47 <breadmonster> :t getLine >> interact $ id 
11:37:47 <lambdabot>     Couldn't match expected type ‚Äò(a0 -> a0) -> t‚Äô
11:37:48 <lambdabot>                 with actual type ‚ÄòIO b0‚Äô
11:37:48 <lambdabot>     The first argument of ($) takes one argument,
11:37:55 <breadmonster> Oh right, now I get it.
11:38:09 <breadmonster> :t (getLine >>) $ (interact $ id)
11:38:10 <lambdabot> IO ()
11:38:11 <Cale> (mod x 2 == 0) = even x
11:38:31 <breadmonster> ($) has the lowest fixity that's why it doesn't work.
11:38:34 <neuroserpens> Cale: shit that's true
11:38:40 <neuroserpens> Cale: that was dumb of my part
11:38:47 <Cale> (\x -> if mod x 2 == 0 then x else x - 1) = x - mod x 2
11:39:03 <Cale> er
11:39:07 <breadmonster> :t (getLine >>) . interact $ unlines . map (show . (\x -> if mod x 2 == 0 then x else x - 1) . (read :: String -> Int)) . lines
11:39:08 <lambdabot> IO ()
11:39:12 <Cale> heh, the body of the lambda is equal to that rather
11:39:15 <breadmonster> there we have it.
11:39:34 <neuroserpens> breadmonster: haha I prefer substituting $ with a set of parentheses
11:39:37 <arkeet> 2 * div x 2
11:40:13 <breadmonster> arkeet: Why waste unnecessary cycles?
11:40:22 <neuroserpens> breadmonster: than having one set of those around getLine >> and still having $
11:40:26 <arkeet> what's a waste about this?
11:40:37 <breadmonster> Oh wait, yeah.
11:40:51 <breadmonster> Albeit if he was dealing with Integer, then you'd have two heavy operations there.
11:40:55 <arkeet> shiftL (shiftR x 1) 1
11:41:01 <breadmonster> Instead of a parity check and a decrement.
11:41:08 <arkeet> x .&. complement 1
11:41:11 <breadmonster> That's better.
11:41:23 <arkeet> I would hope my compiler optimizes 2*x to shiftL x 1
11:41:36 <breadmonster> :t shiftL
11:41:37 <lambdabot> Bits a => a -> Int -> a
11:42:02 <breadmonster> > shiftL (3 :: Integer)  1
11:42:03 <lambdabot>  6
11:42:16 <breadmonster> Oh, okay, so bignums are also Bits.
11:42:27 <arkeet> > complement 1
11:42:28 <lambdabot>  -2
11:42:35 <arkeet> (it defaults to Integer)
11:42:49 <arkeet> > popCount (-1)
11:42:51 <lambdabot>  -1
11:42:54 <arkeet> uhh.
11:42:59 <arkeet> > popCount (-8)
11:43:00 <Rotaerk> > compliment lambdabot
11:43:01 <lambdabot>  -1
11:43:02 <lambdabot>      Not in scope: ‚Äòcompliment‚Äô
11:43:02 <lambdabot>      Perhaps you meant ‚Äòcomplement‚Äô (imported from Data.Bits)Not in scope: ‚Äòl...
11:43:29 <arkeet> > popCount (-6)
11:43:30 <lambdabot>  -2
11:43:31 <arkeet> that's pretty silly.
11:43:33 <arkeet> and useless.
11:43:47 <arkeet> > popCount (-6 :: Word32)
11:43:48 <lambdabot>  30
11:44:13 <Ellah> ok question! So an int/int should return a float
11:44:21 <Ellah> but haskell thinks it's a fractional int
11:44:22 <ski> Ellah : no
11:44:40 <breadmonster> :t (3::Int)/(4::Int)
11:44:41 <lambdabot>     No instance for (Fractional Int) arising from a use of ‚Äò/‚Äô
11:44:41 <lambdabot>     In the expression: ((3 :: Int) / (4 :: Int))
11:44:49 <breadmonster> :t (/)
11:44:49 <Ellah> see?
11:44:49 <lambdabot> Fractional a => a -> a -> a
11:44:57 <arkeet> no it thinks it's a type error because Int doesn't have a Fractional instance
11:44:59 <Ellah> how do i make that into a ... float
11:45:00 <ski> `/' is only defined on number types that support fractional division (as opposed to integral division, with remainder)
11:45:07 <arkeet> use fromIntegral to convert Int to any number type
11:45:10 <arkeet> and then divide
11:45:11 <Cale> Ellah: You can't use (/) to divide values of a non-fractional type. You have to convert the Int values to Double or Rational or something else first.
11:45:15 <Ellah> oh
11:45:28 <arkeet> > fromIntegral (3::Int) / fromIntegral (4::Int)
11:45:29 <lambdabot>  0.75
11:45:30 <breadmonster> arkeet: Isn't that Int -> Float?
11:45:37 <ski> Ellah : the simplest is to not start with an `Int' to begin with. if you already have an `Int', you can use `fromIntegral' to convert it to an appropriate numeric type
11:45:37 <arkeet> :t fromIntegral
11:45:38 <lambdabot> (Integral a, Num b) => a -> b
11:45:45 <arkeet> it would default to Double.
11:47:03 <neuroserpens> breadmonster: Cale: I am dumb hahaha LOL. I could have used tail in the lines instead of a getLine to discard the first line of input
11:47:13 <breadmonster> edwardk: you're a genius.
11:47:33 <edwardk> breadmonster: ?
11:47:46 <Ellah> hmm
11:47:51 <Ellah> what if i want it to ... like floor it
11:48:01 <Ellah> so like 15/2 -> 6
11:48:02 <Ellah> *7
11:48:10 <arkeet> use div
11:48:10 <ski> > 15 `div` 2
11:48:11 <lambdabot>  7
11:48:13 <geekosaur> :t floor
11:48:14 <lambdabot> (Integral b, RealFrac a) => a -> b
11:48:14 <Ellah> ahhhhhh
11:48:23 <geekosaur> either way but div is probably faster
11:48:25 <arkeet> that works on Ints and gets you an Int
11:48:31 <breadmonster> edwardk: Just saw discrimination
11:48:32 <neuroserpens> edwardk: lmfao I think breadmonster meant me with a very weird typo... but thank him anyway and take credit for it
11:48:42 <neuroserpens> xDDD
11:48:46 <Ellah> thank youuuuu
11:48:48 <ski> Ellah : `(/)' is fractional division. `div' is integral division
11:48:48 <Ellah> i love you all
11:48:57 <neuroserpens> Ellah: I <3 U too
11:48:59 <napping> qhat about quot?
11:49:01 <arkeet> if you'd rather round toward 0, use quot
11:49:10 <arkeet> > (-3) `quot` 1
11:49:11 <arkeet> err
11:49:12 <lambdabot>  -3
11:49:13 <arkeet> > (-3) `quot` 2
11:49:14 <lambdabot>  -1
11:49:16 <arkeet> > (-3) `div` 2
11:49:17 <lambdabot>  -2
11:49:22 <breadmonster> neuroserpens: No, I was talking about edwardk :p
11:49:42 <neuroserpens> breadmonster: Crap :(
11:49:44 <napping> That was it. div goes with mod, and mod always gives a non-negative remainder
11:49:55 <napping> > (-12) `rem` 5
11:49:57 <lambdabot>  -2
11:50:17 <mniip> http://codegolf.stackexchange.com/questions/40257/multiply-two-numbers-without-using-any-numbers/49451#49451
11:50:22 <mniip> \o/ everyone can start hating me now!
11:53:10 <kqr> mniip, madness
11:53:26 <Ellah> lol flux just turned off the orange hue for my monitors
11:53:28 <Ellah> everything is so bright wtf
11:56:14 <mniip> hmm
11:56:27 <mniip> what  single-character operators aren't used by prelude
11:56:54 <mniip> aha, & is free
11:57:01 <c_wraith> & is used by lens, though
11:57:15 <Iceland_jack> (&) is in 7.10 (latest)
11:57:18 <Iceland_jack> (Data.Function.&)
11:57:36 <c_wraith> ! isn't used by Prelude, either.  It is used by stuff like Vector and Array, though
11:57:44 <kqr> mniip, !#%&~\| maybe?
11:57:45 <mniip> I've already used ! # % ?
11:57:45 <Iceland_jack> ( # )
11:57:47 <c_wraith> also, you have all of unicode to play with
11:57:56 <mniip> | alone is invalid
11:57:57 <kqr> yeah plus a ton of unicode
11:58:02 <Iceland_jack> (%) is used by Data.Ratio
11:58:03 <kqr> oh yeah because guards
11:58:04 <mniip> unicode is questionable whether it's one codepoint or not
11:59:04 <Iceland_jack> > let a ‚à£ b = b `mod` a == 0 in 5 ‚à£ 15
11:59:05 <lambdabot>  True
12:03:10 <ski> > let a | b = b `mod` a == 0 in 5 | 15
12:03:10 <lambdabot>  <hint>:1:33: parse error on input ‚Äò|‚Äô
12:03:36 <mniip> > let a \ b = b `mod` a == 0 in 5 \ 15
12:03:37 <lambdabot>  <hint>:1:7: parse error on input ‚Äò\‚Äô
12:04:18 <kqr> > let a ÔΩúb = b `mod` a == 0 in 5 ÔΩú15
12:04:19 <lambdabot>  True
12:04:45 <mniip> > let a ‚îÉ b = b `mod` a == 0 in 5 ‚îÉ 15
12:04:46 <lambdabot>  True
12:05:21 <napping> that's going just a bit to far
12:05:28 <kqr> all the unicodes!
12:05:32 <napping> find a whitspace character accepted as an operator and you'll be going way too far
12:05:38 <kqr> hahahah
12:06:00 <kqr> that sounds really neat actually
12:06:04 <kqr> if you can find two
12:06:09 <kqr> make one of them fmap and the other ap
12:06:11 <kqr> ples
12:06:14 <kqr> please*
12:08:18 <mniip> napping, how about
12:08:19 <mniip> ‚ê†
12:12:53 <Geraldus> Hey pals! Can someone help with esqueleto?
12:14:09 <mniip> napping, apparently in ruby U+A0 can be used in identifiers
12:14:15 <P4Titan> Hello all, when I use ghci to debug and load my main file, I try to set a breakpoint and it says that module Main was not interpreted. How do I load it so that it is interpreted?
12:14:17 <mniip> haskell is more strict with unicode though
12:14:27 <napping> mniip: I'm not actually trying to make unreadable code
12:14:48 <napping> I don't see anything that's strictly whitespace in the symbol or punctuation pages, which is what the 2010 report says operators can use
12:15:00 <mniip> you're trying to make undebuggable code :(
12:15:10 <mniip> "f x" oh wait that's "f <$> x"
12:15:24 <napping> no, I said that would be going way too far
12:15:41 <mniip> oh wait
12:15:43 <mniip> it was kqr 
12:15:54 <napping> different width bars are pretty bad to start with
12:16:06 <napping> I tend to like Agda's use of unicode math stuff, though
12:18:18 <mniip> > 3 ‚îº 4 ‚ï≥ 5 --kqr
12:18:19 <lambdabot>  23
12:18:42 <ajf> RIP Paul Hudak :(
12:19:18 <kqr> mniip, I just want my idiom brackets :(
12:19:34 <Geraldus> P4Titan: :l *MyModule
12:19:56 <Geraldus> P4Titan: notice asterisk
12:20:02 <P4Titan> very nice, why is it like that?
12:20:06 <neuroserpens> Anyone know how I can benchmark my own code? Check the total memory and time a binary spent through its execution.
12:20:13 <napping> kqr: maybe try template haskell?
12:20:23 <Geraldus> P4Titan: * mean interpret while loading
12:20:36 <P4Titan> Ok, thanks!
12:20:53 <napping> Now that the plain [| |] doesn't make any attempt to typecheck, you could probably do idiom brackets somehow
12:21:07 <Geraldus> I assume load and interpret is more correct, not sure (:
12:22:37 <kqr> napping, yeah there already is http://hackage.haskell.org/package/applicative-quoters-0.1.0.8/docs/Control-Applicative-QQ-Idiom.html
12:23:59 <TrueMagnap> neuroserpens: one way I know of is to it in ghci. That does make it slower, though. Run "ghci YourFile.hs" then ":set +s" then "main"
12:24:00 <mmachenry> Has justhub.org (Which supported Haskell Platform for unsupported Linux distros) abandoned now? Looks like their last release was 2012.
12:25:33 * hackagebot hdocs 0.4.2.1 - Haskell docs tool  http://hackage.haskell.org/package/hdocs-0.4.2.1 (AlexandrRuchkin)
12:25:47 <neuroserpens> TrueMagnap: Nice. Even if it makes it slower it's still going to tell me what code performed better. Thanks a lot.
12:26:39 <napping> > let a üí© b = a++"üí©"++b in putStrLn $ "Hello" üí© "World"
12:26:40 <lambdabot>  <IO ()>
12:27:12 <Iceland_jack> > let a üí© b = a++"üí©"++b in text ("Hello" üí© "World")
12:27:13 <lambdabot>  Helloüí©World
12:27:31 <kqr> hah
12:27:37 <kqr> like in C! almost
12:27:50 <napping> How is that like C?
12:28:04 <kqr> adjacent string literals are concatenated in C
12:28:15 <kqr> some versions of python do that too
12:28:19 <napping> That's not a space
12:28:23 <kqr> I know
12:29:22 <Iceland_jack> > let a‚ê£b = unwords [a,b] in text ("Hall√≥,"‚ê£"Heimur!")
12:29:23 <lambdabot>  Hall√≥, Heimur!
12:30:54 <mniip> [22:27:07] <kqr> like in C! almost
12:31:05 <mniip> that renders as a box with 01F4A9 in it over here
12:31:13 <kqr> ah to me it looks blank
12:31:33 <mniip> Unicode Character 'PILE OF POO' (U+1F4A9)
12:32:24 <kqr> ah my terminal must be shitty
12:33:06 <mniip> yeah lots of stuff only support basic multilingual plane
12:36:08 <ysr> I implemented the tic tac toe game in Haskell. Anyone up for a code review? http://codereview.stackexchange.com/q/88497/13063
12:36:40 <mniip> you're misusing the Show typeclass
12:36:54 <mniip> tuples for the board are wrong
12:37:02 <neuroserpens> Can I somehow use a parameter of a partially applied function inside a list comprehension or is my question stupid?
12:37:09 <mniip> consider using an Array
12:37:20 <mniip> neuroserpens, example?
12:37:37 <tom____> does anyone have experience installing hdbc-sqlite3 on windows 8?
12:37:55 <haskell806> Hi all, could I get someone to check what I did here: http://lpaste.net/131777
12:37:56 <ysr> mniip How am I misusing the Show typeclass?
12:38:18 <mniip> Show is supposed to output haskell code
12:38:25 <neuroserpens> mniip: just a min
12:38:45 <srhb> ysr: namely read . show = id -- is the law that people expect
12:39:04 * srhb doesn't think it's a big deal
12:39:13 <bossPls> How to count occurrences of an element in a list? I'm trying "count :: (a -> Bool) -> [a] -> Int " ; "count p xs = length (filter p xs)" and I'm getting No instance for (Num a0) arising from the literal...
12:39:14 <mniip> yeah
12:39:15 <Iceland_jack> I ‚Äòmisuse‚Äô Show all the time
12:39:20 <tom____> * Missing C library: sqlite3 is an error I get, and I've followed and tried a number of things suggested in the FAQ for the sqlite3 driver
12:39:22 <mniip> not as big of a deal as the 9-tuple board
12:39:39 <Iceland_jack> bossPls: length (filter (p ==) xs)
12:39:42 <ysr> mniip that was hell of a work to get it done :)
12:39:49 <dolio> ysr: I think you're missing win conditions.
12:39:58 <dolio> Don't have any of the verticals.
12:40:01 <int-e> ysr: I think dolio is right
12:40:09 <Iceland_jack> bossPls: You will need to add an (Eq a)-constraint
12:40:12 * ski thinks `show' ought to yield a string representation of a Haskell expression that in the appropriate environment will evaluate to an equal value
12:40:12 <ysr> ohh, you are right :)
12:40:13 <Myrl-chan> mniip: I should use a 64-element tuple for my VM.
12:40:17 <mniip> ysr, also  your checkWinner is wrong
12:40:32 <Iceland_jack> :t \p xs -> length (filter (== p) xs)
12:40:34 <lambdabot> Eq a => a -> [a] -> Int
12:40:35 <ysr> mniip I just realized I don't check coluns
12:40:37 <mniip> Myrl-chan, consider using a couple ADTs instead
12:40:57 <mniip> Iceland_jack, his type signature was different
12:41:02 <mniip> a preducate was supplied instead
12:41:10 <joneshf-laptop> mniip, i think you can drop a few more characters
12:41:18 <mniip> joneshf-laptop, where
12:41:20 <ysr> I am not a native speaker, which is correct -> "Here is my code" or "Here are my codes"
12:41:22 <Iceland_jack> mniip: That's what I get for being sloppy
12:41:34 <mniip> ysr, the foremr
12:41:34 <ski> > show (listArray (0,3) [2,3,5,7])
12:41:35 <mniip> former
12:41:35 <lambdabot>  "array (0,3) [(0,2),(1,3),(2,5),(3,7)]"
12:41:42 <neuroserpens> :t elem
12:41:43 <lambdabot> (Eq a, Foldable t) => a -> t a -> Bool
12:41:52 <bossPls> lambdabot: now I'm getting Could not deduce (a ~ (a -> Bool))
12:42:01 <ski> (is an example of outputting a representation that doesn't use data constructors)
12:42:09 <mniip> bossPls, your code seems correct, the error seems to be from somewhere else
12:42:09 <Myrl-chan> mniip: Lol. I was joking. I plan to use record syntax.
12:42:12 <Iceland_jack> bossPls: The original code was correct
12:42:44 <neuroserpens> > elem 1 (1, 2)
12:42:45 <lambdabot>  False
12:42:54 <neuroserpens> o,00000000
12:42:58 <mniip> ysr, "code" as in source of a program, is always singular
12:43:06 <joneshf-laptop> mniip, `a%(b:c)=foldr(!)('0':a%c)$f(<b)z>>[a]` becomes `a%(b:c)=foldr(!)('0':a%c)$a<$f(<b)z`
12:43:12 * neuroserpens 's brain has been cooked
12:43:24 <kqr> ysr, in which language do you say "here are my codes"? I've seen that way of saying it a bit but I've never been able to pinpoint it
12:43:27 <Myrl-chan> mniip: Would a 64-element data constructor be bad?
12:43:28 <Iceland_jack> > length (1, 2)
12:43:30 <lambdabot>  1
12:43:30 <mniip> joneshf-laptop, <$ requires an import
12:43:33 <bossPls> Iceland_jack: does it work for you? I'm calling it like "count 'a' ['a', 'b', 'a', 1, 5]" and getting Couldn't match expected type `Char -> Bool' with actual type `Char'
12:43:46 <Iceland_jack> bossPls: That's the problem, not the definition
12:43:48 <mniip> Myrl-chan, is it a tuple of 64 general-purpose registers?
12:43:54 <joneshf-laptop> mniip, 7.10
12:43:55 * ski . o O ( "lite s√•ser" )
12:43:58 <mniip> joneshf-laptop, ehhh
12:44:01 <mniip> I'd rather not
12:44:10 <ysr> kqr, in Turkish equivalent of that phrase we use plural for cod
12:44:17 <kqr> ysr, ah, cool. thanks
12:44:24 <Iceland_jack> bossPls: If you want to invoke your function like that, its definition should be
12:44:25 <Iceland_jack>     count :: Eq a => a -> [a] -> Int
12:44:25 <Iceland_jack>     count elt xs = length (filter (== elem) xs)
12:44:28 <Myrl-chan> mniip: Lol. It's going to use record(update) syntax.
12:44:29 <Iceland_jack> *(== elt)
12:44:54 <Iceland_jack> bossPls: But you can simply write: (count (== 'a') "aba15")
12:44:58 <ysr> kqr, my people are generally sloppy with their English :D
12:45:04 <Iceland_jack> bossPls: Writing ['a', 'b', 'a', 1, 5] will not work
12:45:10 <mniip> Myrl-chan, what will the 64-element data contain
12:45:20 <Myrl-chan> mniip: 64-bit GPRs.
12:45:36 <bossPls> Iceland_jack: DAMN, IT WORKS
12:45:43 <bossPls> I've spent 2 hours on this
12:45:43 <mniip> ground-penetrating radars?
12:45:46 <bossPls> thanks!
12:46:06 <Iceland_jack> bossPls: Do you understand why ['a', '5'] is okay but ['a', 5] is not?
12:46:06 <mniip> Myrl-chan, ground-penetrating radars?
12:46:11 <bossPls> sure
12:46:14 <Iceland_jack> Okay
12:46:16 <bossPls> just new to Haskell
12:46:22 <Myrl-chan> mniip: I'm amazed at how you can make terms on the spot. :P
12:46:32 <mniip> it was google
12:46:38 <Myrl-chan> mniip: general purpose registers. lol
12:46:43 <mniip> then
12:47:05 * ski . o O ( "Gunflint Precatively Rabat" )
12:47:14 <mniip> something tells me you'll be accessing the registers by index
12:47:38 <mniip> x86, for instance, does that all over the place. only a few instructions actually hardcode register names
12:47:39 <Myrl-chan> mniip: Nah. I'll be accessing it using records
12:48:17 * arkeet is frightened by the thought of having 64-way case statements all over
12:48:29 <arkeet> case expressions?
12:48:30 <mniip> Myrl-chan, I mean don't run into code like 'case src of 0 -> eax r; 1 -> ecx r; 2 -> ebx r; 3 -> edx r'
12:48:50 <int-e> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
12:48:51 <lambdabot>     A 64-tuple is too large for GHC
12:48:51 <lambdabot>       (max size is 62)
12:48:51 <lambdabot>       Workaround: use nested tuples or define a data type
12:49:04 <Myrl-chan> mniip: I'd do register renaming irl, but it doesn't mean much in a VM.
12:49:07 <phaazon> huhu
12:49:12 <phaazon> is Elm a Haskell dialect?
12:49:13 <Myrl-chan> mniip: Hmmm
12:49:15 <phaazon> it looks like!
12:49:27 <kqr> yeah because if you want a 64-tuple the best solution must be to make a 2-tuple of 32-tuples
12:49:34 <Myrl-chan> mniip: How should I do this?
12:49:36 <dolio> phaazon: Not exactly.
12:49:37 <kqr> phaazon, no, completely separate languages
12:49:48 <dolio> It's just similar syntax.
12:49:48 <hiptobecubic> but inspired by
12:49:49 <phaazon> I¬†think it‚Äôs based on Haskell though
12:49:51 <mniip> Myrl-chan, an array
12:49:51 <phaazon> yeah, ok
12:49:56 <mniip> in C I did this with unions
12:49:56 <phaazon> it looks very sweety
12:50:01 <phaazon> like, FRP :3
12:50:24 <Myrl-chan> mniip: One thing i plan to do is to use an Int and an Int tree
12:50:33 <mniip> Myrl-chan, what are you emulating btw
12:50:43 <Myrl-chan> mniip: Basically taking the concept of a skew binary list
12:50:51 * hackagebot hdocs 0.4.2.1 - Haskell docs tool  http://hackage.haskell.org/package/hdocs-0.4.2.1 (AlexandrRuchkin)
12:50:51 * hackagebot timezone-olson-th 0.1.0.1 - Load TimeZoneSeries from an Olson file at compile time.  http://hackage.haskell.org/package/timezone-olson-th-0.1.0.1 (petterb)
12:50:55 <Myrl-chan> mniip: My own ISA.
12:51:11 <mniip> individual savings account?
12:51:21 <Myrl-chan> Instruction Set Architecture
12:51:26 <mniip> xD
12:51:30 <Myrl-chan> Hahaha
12:51:54 <mniip> Myrl-chan, make an array, and then creating named aliases
12:52:25 <mniip> eax :: Registers -> Register; eax (Registers a) = a ! 0
12:52:53 <Myrl-chan> mniip: Ah.
12:53:10 <mniip> or maybe even
12:53:15 <mniip> eaxIndex = 0
12:53:19 <haskell806> Am I able to put guards in lambda expressions like this: http://lpaste.net/131777
12:53:26 <Myrl-chan> mniip: What monad should I use?
12:53:30 <mniip> so that you can fuse // together
12:53:44 <Myrl-chan> Should I do everything in IO or use ST?
12:53:45 <mniip> IO or State
12:53:49 <mniip> or ST
12:53:51 <arkeet> haskell806: no, use case
12:54:03 <arkeet> or MultiWayIf
12:54:11 <Myrl-chan> mniip: How would I do it in State?
12:54:13 <arkeet> \x -> case () of _ | x == 0 = ... | etc
12:54:16 <arkeet> \x -> if | x == 0 = ... | etc
12:54:25 <mniip> well, your registers are the state
12:54:28 <arkeet> or
12:54:34 <arkeet> haskell806: in your case, just use if/then/else
12:54:34 <ski> haskell806 : why not use `if ... then ... else ...' ?
12:54:55 <haskell806> thought guards would be neater
12:55:02 <Myrl-chan> mniip: I mean arrays in state.
12:55:06 <ski> you can do that too, if you prefer
12:55:08 <mniip> what about them
12:55:16 <arkeet> you can do that, but only in one of the two ways above
12:56:15 <ysr> mniip what do you suggest instead of 9tuple?
12:56:20 <mniip> Array
12:56:34 <ysr> Array is not a list I guess right?
12:56:40 <ski> correct
12:56:52 <Myrl-chan> mniip: Wait, I'ma go research for a while
12:57:01 <ysr> I have never used arrays before
12:57:14 <arkeet> arrays are constant time access
12:57:18 <arkeet> well, reading
12:57:19 <haskell806> Is this the right way to use it? http://lpaste.net/131777
12:57:26 <arkeet> (but linear time modification, because it has to copy the whole array)
12:57:41 <arkeet> haskell806: should work
12:57:58 <kqr> arkeet, does it? is vector better optimised for modification?
12:57:58 <mniip> Myrl-chan, damn, now I want to finish my x86_64 emulator
12:58:08 <arkeet> kqr: no, it has the same properties
12:58:18 <haskell806> I get parse error D=
12:58:19 <arkeet> you have to copy the whole array to modify it.
12:58:43 <arkeet> haskell806: add the full error message to your paste
12:58:45 <Myrl-chan> mniip: In Haskell?
12:58:48 <mniip> no
12:58:49 <mniip> C++
12:58:54 <Myrl-chan> Thank god
12:59:04 <kqr> arkeet, oh, wow
12:59:06 <arkeet> kqr: because if someone holds a reference to the old array, it shouldn't magically change under them.
12:59:13 <arkeet> actually there are mutable vectors
12:59:16 <ysr> Wont ghc optimize it? Instead of creating a new array and throwing the old one, it should be able to just modify the old one I think
12:59:23 <arkeet> where the mutation is done in IO/ST
12:59:26 <mniip> Myrl-chan, I got it to execute helloworld and then kinda got bored: https://github.com/mniip/highlel/blob/master/test/static/hw.S
12:59:33 <kqr> arkeet, how does this tie in to the clojure arrays (which are basically maps with integer indices)
12:59:45 <arkeet> I dunno how clojure arrays work
13:00:10 <kqr> arkeet, they are basically trees of arrays with a high branching factor, so when you change some bit most of the structure gets shared
13:00:17 <kqr> (like lists in haskell)
13:00:22 <arkeet> yeah, you can use a different structure for that
13:00:23 <Hijiri> you could use an IntMap
13:00:26 <arkeet> like Map or IntMap 
13:00:29 <ski> haskell806 : are you against using `do' ?
13:00:31 <kqr> ah nice
13:00:44 <haskell806> looks like this: http://lpaste.net/131777
13:00:53 <arkeet> Map has log time access/modification
13:00:55 <haskell806> id like to learn how to do that next
13:00:58 <haskell806> do the do
13:01:03 <arkeet> since it uses a balanced binary tree
13:01:17 <arkeet> (well, not-too-unbalanced binary tree)
13:01:29 <arkeet> haskell806: get rid of tabs
13:01:44 <arkeet> why doesn't lpaste warn about tabs
13:01:45 <arkeet> :(
13:03:09 <haskell806> sweet! that whitespace tho. 
13:05:48 <orion> When serializing with Aeson, what's the best way to only include a value, say, "details", if it's Just (as opposed to Nothing)?
13:06:31 <orion> I have a (Maybe a) which I want to label as "details", but I only want to include it if the value is (Just a).
13:07:19 <ion> > let f n xs = zipWith const (drop n (cycle xs)) xs in f <$> [0..] <*> pure "hello"
13:07:21 <lambdabot>  ["hello","elloh","llohe","lohel","ohell","hello","elloh","llohe","lohel","oh...
13:08:18 <ysr> ion that is so cool
13:08:27 <ysr> I am trying to understand it now
13:08:51 <lpaste> ski annotated ‚ÄúNo title‚Äù with ‚Äúone possible variant‚Äù at http://lpaste.net/131777#a131781
13:08:53 <ski> haskell806 ^
13:09:23 <arkeet> > zipWith const (drop 2 (cycle "hello")) "hello"
13:09:24 <lambdabot>  "llohe"
13:09:39 <haskell806> Thanks ski man. Could I get you to do one with the do notation perchance
13:09:40 <haskell806> ?
13:10:01 <arkeet> > let xs = "hello" in map (zipWith const xs) (tails (cycle xs))
13:10:03 <lambdabot>  ["hello","hello","hello","hello","hello","hello","hello","hello","hello","he...
13:10:04 <arkeet> oops
13:10:11 <arkeet> > let xs = "hello" in map (zipWith (const id) xs) (tails (cycle xs))
13:10:12 <lambdabot>  ["hello","elloh","llohe","lohel","ohell","hello","elloh","llohe","lohel","oh...
13:10:36 <hiptobecubic> weird
13:10:47 <arkeet> this one is more efficient I think
13:11:13 <c_wraith> orion: There doesn't appear to be anything magical.  You just either put the value into the object or not.
13:11:26 <ion> arkeet: The first expression emulates Nirvana.
13:11:30 <ski>   cycleList d vals val = do x <- elemIndex val vals
13:11:38 <ski>                             Just $ case d of
13:11:47 <ski>                               L | ...
13:11:50 <ski>                               R | ...
13:12:11 <hiptobecubic> arkeet, why the zipwith?
13:12:22 <ski> haskell806 ^
13:12:27 <arkeet> zipWith (const id) xs is like take (length xs)
13:12:31 <arkeet> except better
13:12:32 <mniip> > zipWith const "hello world" [1..5] -- hiptobecubic
13:12:33 <lambdabot>  "hello"
13:12:43 <arkeet> const id = flip const
13:12:44 <c_wraith> hiptobecubic: zipwith const is a clever trick
13:12:48 <hiptobecubic> > take 5 . map (take 10) . tails $ cycle "hello"
13:12:50 <lambdabot>  ["hellohello","ellohelloh","llohellohe","lohellohel","ohellohell"]
13:12:55 <haskell806> awesome. thanks again
13:13:05 <hiptobecubic> > take 5 . map (take 5) . tails $ cycle "hello"-- oops
13:13:06 <lambdabot>  ["hello","elloh","llohe","lohel","ohell"]
13:13:13 <int-e> > let f xs = cycle (zipWith (++) (tails xs) (init $ inits xs)) in f "hello"
13:13:14 <lambdabot>  ["hello","elloh","llohe","lohel","ohell","hello","elloh","llohe","lohel","oh...
13:13:16 <arkeet> > map (take 5) . tails $ cycle "hello"
13:13:17 <lambdabot>  ["hello","elloh","llohe","lohel","ohell","hello","elloh","llohe","lohel","oh...
13:13:25 <ski> haskell806 : it's also possible to match on `d' directly, instead of using a `case'
13:13:53 <arkeet> int-e wins on asymptotics I think.
13:14:14 <haskell806> you mean like cycleList Left vals val =
13:14:17 <haskell806> cycleList Right vals val =
13:14:18 <haskell806> ?
13:15:17 <arkeet> > let xs = "hello"; foo = zipWith (const id) xs in cycle . foo . map foo . tails $ cycle xs
13:15:19 <lambdabot>  ["hello","elloh","llohe","lohel","ohell","hello","elloh","llohe","lohel","oh...
13:15:51 <arkeet> cycle . foo . map foo . tails . cycle $ xs
13:15:53 <arkeet> almost palindromic
13:16:19 <mniip> what's the point in 'cycle . foo'
13:16:25 <mniip> seems like unneccessary work
13:16:27 <arkeet> > let xs = "hello"; foo = zipWith (const id) xs in foo . map foo . tails $ cycle xs
13:16:28 <lambdabot>  ["hello","elloh","llohe","lohel","ohell"]
13:16:34 <hiptobecubic> I still don't see why you'd want `zipWith (const id)` over take. To avoid computing the cycle length?
13:16:44 <arkeet> hiptobecubic: yes, and also to work with infinite lists
13:16:59 <arkeet> mniip: it shares repeated elements of the resulting list
13:17:08 <mniip> ah
13:17:13 <mniip> neat
13:17:47 <arkeet> one could replace cycle xs with xs ++ xs in that case.
13:17:56 <c_wraith> :t let dropEnd n xs = zipWith const (drop n xs) xs in dropEnd -- hiptobecubic 
13:17:57 <lambdabot> Int -> [b] -> [b]
13:18:04 <arkeet> @where sneaky
13:18:04 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
13:18:21 <arkeet> much better than take (length xs - n) xs
13:18:23 <hiptobecubic> sneaky?
13:18:33 <arkeet> the definition is kind of sneaky
13:18:36 <mniip> can't resist the urge
13:18:39 <mniip> dropFromEnd n = zipWith const <*> drop n
13:18:41 <c_wraith> did I get the args backwards?
13:18:57 <arkeet> nah 
13:19:01 <c_wraith> in any case.  That's by far the best implementation for that
13:19:10 <arkeet> oh yeah you did.
13:19:11 <arkeet> heh
13:19:17 <arkeet> else it's the same as drop
13:19:21 <c_wraith> yeah
13:19:28 <mniip> dropFromEnd = (zipWith const <*>) . drop
13:19:39 <ion> Replace const with pure for further obfuscation.
13:19:42 <arkeet> :-)
13:19:46 <mniip> nah
13:19:47 <arkeet> and (.) with fmap
13:19:47 <mniip> return
13:20:06 <arkeet> :t (zipWith pure <*>) <$> drop
13:20:07 <lambdabot> Int -> [c] -> [c]
13:20:15 <mniip> yeah
13:20:20 <mniip> that's hella fancy
13:20:46 <arkeet> :t (<*>) zipWith pure <$> drop
13:20:47 <lambdabot>     Couldn't match type ‚Äò[a0]‚Äô with ‚Äò[a0] -> b -> c‚Äô
13:20:48 <lambdabot>     Expected type: ([a0] -> b -> c) -> [[a0]]
13:20:48 <lambdabot>       Actual type: [a0] -> [[a0]]
13:20:53 <arkeet> oh duh
13:20:57 <arkeet> whatever
13:22:25 <ion> A reader might assume the three invocations of Functor/Applicative methods have something to do with one another.
13:23:40 <mniip> :t (>>= zipWith (flip pure)) . drop
13:23:41 <lambdabot> Int -> [c] -> [c]
13:23:49 <mniip> :t (>>= zipWith (flip return)) . drop
13:23:50 <lambdabot> Int -> [c] -> [c]
13:24:32 <SrPx> On this example of the prism lib on hackage, why do we need to return "i" on the Left case? http://lpaste.net/131783 will it ever be used? 
13:24:33 <fvgvxmpv1> parseTime from Data.Time.Format takes a TimeLocale ‚Äî since this links to ‚Äòold-locale‚Äô im assuming there is a better way to parse date specifications with a date-compatible format string?
13:24:43 <fvgvxmpv1> What would that way be?
13:25:21 <ion> :t drop >>= return . (>>= zipWith (flip return))
13:25:22 <lambdabot> Int -> [c] -> [c]
13:25:53 <haskell806> <ski>: http://lpaste.net/131784
13:26:19 <haskell806> <ski> http://lpaste.net/131784
13:26:28 <ion> srpx: A non-simple Prism might change the return type, this construction allows for that. You can use prism'.
13:26:46 <ion> uh, not return type
13:26:57 <SrPx> I see, but is the value of "i" ever used?
13:27:44 <SrPx> That is, we have "= Left i" ... is the "i" ever removed from that "Left" after that?
13:28:42 <haskell806> how do you tag someone here?
13:28:54 <geekosaur> just mention their nick somewhere and their client will spot it
13:29:13 <geekosaur> usually at the start of the message, conventionally followed by , or : but not necessary
13:29:16 <bennofs> SrPx: it will be the value of (-1) %
13:29:23 <bennofs> SrPx: it will be the value of (-1) & nat %~ id
13:29:26 <haskell806> geekosaur http://lpaste.net/131784
13:29:30 <haskell806> did that work
13:29:55 <geekosaur> yes
13:30:38 <bennofs> SrPx: this is more important for type changing prisms. There you have over :: (a -> b) -> Prism s t a b -> s -> t. Now if the prism doesn't match, what value should 'over' return? You need to map s -> t even in the "failure" case
13:30:50 <haskell806> can you take alook at that pastebin?
13:30:58 <geekosaur> my client says ski is marked away; hopefully their client has enough scrollback
13:32:23 <arbelos> writing case x of
13:32:45 <arbelos>           x | x == "a" || x == "b" -> ...
13:32:50 <arbelos> doesn't feel very pretty
13:33:06 <geekosaur> this looks like an indentation issue, since the R is being taken as a continuation of the preceding expression
13:33:18 <arkeet> x `elem` ["a","b"]
13:33:36 <arbelos> arkeet.. sure.. 
13:33:57 <arkeet> it would be nice if we had or-patterns.
13:34:04 <arkeet> I haven't quite worked out how they should work though.
13:34:22 <arbelos> i was just about to write that.. like how it works in OCaml
13:34:25 <haskell806> geekosaur my R is on the same column as my L tho.
13:34:35 <arkeet> mostly problems related to binding variables.
13:34:54 <arkeet> if there are no variables it's easy. (aside from figuring out the syntax)
13:35:10 <arbelos> yes, I can imagine that there are some problems lurking behind there
13:35:13 <geekosaur> haskell806, it claims it's in column 95 but your paste isn't showing any 95-column lines. the large ident makes me think tabs
13:35:52 <geekosaur> note that tabs are disrecommended, specifically because editors often have different notions of how big a tab is than compilers/interpreters do
13:36:09 <arkeet> haskell806: get rid of tabs.
13:36:12 <geekosaur> (ghc uses next-multiple-of-8 + 1. editors often use 4)
13:36:14 <arkeet> like I said earlier.
13:36:45 <haskell806> im not tabbing. I'm using spaces. Does the do need to go on the next line?
13:36:51 <arbelos> arkeet, would some syntactic sugar that essentially does x `elem` [..] behind the scenes be a bad idea?
13:37:21 <arkeet> arbelos: yes, because sometimes you want to be able to match things that don't have Eq instances.
13:37:28 <geekosaur> the paste has tabs
13:37:31 <arbelos> hmm.. yes
13:38:23 <geekosaur> and I count ~60 chars on line 48 if it has spaces, so column 95 seems unlikely
13:38:40 <geekosaur> unless you somehow managed to make line 49 part of line 48 by spacing all the way around until it wrapped...
13:41:04 <haskell806> I respaced everything again and it somehow worked now. I'm copying and pasting from notepad ++. The pastebin doesn't reflect the actual look of it that I see on notepad. =[
13:41:24 <arkeet> probably because your notepad++ uses tab stops that aren't 8 columns or whatever.
13:41:38 <arkeet> you should be able to configure it to insert spaces
13:42:44 <arkeet> (occasionally it's useful to actually be able to enter a tab character though...)
13:43:28 <kadoban> It is?
13:43:30 <arkeet> (e.g. vim lets you insert a literal tab with <ctrl-V><Tab> even with expandtabs)
13:43:39 <arkeet> kadoban: maybe?
13:44:43 <dz0004455> > take 5 [1..] ==> [1,2,3,4,5]
13:44:44 <lambdabot>  <no location info>: can't find file: L.hs
13:44:56 <kadoban> Can't say I ever remember needing to. Maybe in a Makefile or something? I seem to recall those need tabs, heh. Hasn't come up though.
13:45:03 * geekosaur sends lambdabot a race condition
13:45:12 <pavonia> :t (==>)
13:45:13 <lambdabot> Testable prop => Bool -> prop -> Property
13:45:16 <mjrosenb> in Reactive.Banana, if I have a Behavior t Int, which is defined entirely in terms of steppers, I should expect the pipeline to only get evaluated once per intersection of read from it, and event, yes?
13:45:30 <arkeet> or maybe I mostly just use it when entering commands
13:46:24 * mjrosenb occasionally finds command line programs that don't expand \t, and need to have a literal tab in them
13:46:35 <happy0> :fit
13:46:39 <happy0> woops ;x
13:47:04 <arkeet> actually I tend to press ctrl-V ctrl-I instead
13:47:30 <geekosaur> $'\t' (bashism)
13:47:33 <mjrosenb> and with emacs' indent-tabs-mode disabled, C-q C-i inserts a tab
13:47:58 <mjrosenb> geekosaur: ahh, I know I've seen that before, but I always forget about it
13:48:11 <mjrosenb> geekosaur: but emacs has better edition support than bash does :-p
13:49:14 <mjrosenb> *editing
13:49:21 * mjrosenb cannot type today, evidently.
13:49:32 <mjrosenb> perhaps I just don't like this laptop's keyboard.
13:49:52 <ski> haskell806 : if you start the message with "<ski> ...", it looks like you're quoting something i said
13:50:02 <mniip> how do I Int -> Double again
13:50:08 <ion> realToFrac
13:50:08 <arkeet> :t fromIntegral
13:50:09 <lambdabot> (Integral a, Num b) => a -> b
13:50:13 <arkeet> :t realToFrac
13:50:14 <ion> what arkeet said
13:50:14 <lambdabot> (Fractional b, Real a) => a -> b
13:50:19 <ski> haskell806 : anyway, the problem is probably your tabs again
13:50:32 <arkeet> both work I guess.
13:53:36 <arkeet> ski: go into your notepad++ settings, under Tab Settings
13:53:43 <arkeet> and turn on "replace by space"
13:53:45 <arkeet> er...
13:53:47 <arkeet> haskell806: ^
13:53:59 * ski blinks
13:54:29 * glguy emotes
13:54:56 * ion consists
14:01:53 <orion> Is FlexibleInstances a fairly harmless extension?
14:02:00 <mauke> yes
14:02:50 <arkeet> I'd say completely harmless.
14:03:18 <ion> unlike the Earth
14:03:24 <arkeet> mhm
14:06:43 <Pamelloes> Can I define a function that has a type of a (Maybe b) -> .... where a (Maybe b) means any type of the form newtype MyType b = MyType (Maybe b)?
14:07:24 <shachaf> MyType b doesn't unify with a (Maybe b)
14:07:54 <shachaf> You can hardly "look inside" newtypes transparently like that -- that's the point of making a new type.
14:08:15 <orion> http://lpaste.net/9150275589012193280 <-- anyone know how to fill in the "???" to accomplish what's described in the comment?
14:08:34 <Pamelloes> shachaf: Thanks, that's what I was wondering.
14:10:47 * hackagebot singletons 1.1.2 - A framework for generating singleton types  http://hackage.haskell.org/package/singletons-1.1.2 (RichardEisenberg)
14:14:02 <titito> Hello, anyone could help me? I have an issue with openFile
14:14:19 <titito> I just want to catch the error that it throws
14:14:24 <geekosaur> just ask your question
14:14:30 <zmbmartin> What is the best way to generate a random string of only letters a-z A-Z and numbers 0-9
14:14:41 <ion> Pamelloes: GHC provides a way to safely coerce between a value and any newtype wrapper for it, but it‚Äôs probably not what you want here.
14:15:06 <mniip> orion, maybe [] (\x -> ["details" .= x]) $ thedetails e
14:15:07 <titito> I'm just doing :  file <- openFile blah ReadMode
14:15:10 <geekosaur> titito, see http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/base-4.6.0.1/Control-Exception.html#v:catch
14:15:22 <titito> thanks
14:15:27 <SrPx> Okay thank you bennofs it makes sense
14:15:30 <Pamelloes> ion: Can you give me a link, that might be what I'm looking for
14:15:30 <mniip> orion, or a plain old case-of
14:15:31 <SrPx> Btw,
14:15:44 <ion> Pamelloes: http://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Coerce.html
14:15:54 <Pamelloes> Thanks :)
14:16:29 <SrPx> (sorry hit return), can I derive Lens/Prisms/etc for arbitrary datatypes, even if I mix records with sums? Is that okay? data Type = Foo { _a :: Int, _b :: Int } | Bar { _c :: Int }
14:16:38 <dbelange_> "Paul Hudak, co-creator of Haskell, has died"
14:16:43 <SrPx> Feels like it is a bad practice 
14:16:47 <dbelange_> what is a co-creator
14:16:52 <Iceland_jack> SrPx: Yes
14:17:04 <dbelange_> is it a destructor function??
14:17:04 <mpickering> I think records as part of sum is bad practice as it creates partial functions
14:17:07 <mniip> the inverse of a creator presumably
14:17:29 <bennofs> SrPx: lens will automatically generate traversals if a field is not present in all constructors
14:17:37 <SrPx> dbelange_: what? :(
14:17:47 <bennofs> SrPx: so in your example, it will make traversals for a, b and c
14:18:17 <bennofs> (not sure if it even builds a prism for c)
14:18:31 <geekosaur> "co-" in this case meaning "with", menaing along with someone else
14:18:44 <mniip> SrPx, think of the co prefix in math
14:18:47 <srhb> dbelange_: Keep in mind many in here probably knew him personally. This might be a case of "too soon"
14:18:51 <glguy> makeLenses builds Getter/Traversal/Lens/Iso, makePrisms does Review/Prism/Iso
14:19:04 <kuribas> How usable is FRP at this time?  Are there alternatives for programming GUI apps in a declarative way?
14:19:45 <mjrosenb> kuribas: I've been writing some special cased FRP bindings to sdl2, and it has so far worked pretty well.
14:20:05 <zmbmartin> Anyone with random string help?
14:20:08 <kuribas> mjrosenb: Which library do you use?  Is there a performance penalty for FRP?
14:20:09 <ion> zmbmartin: You could create an array/vector out of ['0'..'9'] ++ ['a'..'z'] ++ ['A'..'Z'] and use (!) on it to get Int -> Char, or you could create a function like http://hackage.haskell.org/package/lens-4.9.1/docs/src/Numeric-Lens.html#intToDigit' which doesn‚Äôt need to store a table. You can then generate random integers from the correct range and apply the function.
14:20:40 <bam365> zmbmartin: filter (\v -> isAscii v && isAlphaNum v) $ randoms stdgen :: [Char]
14:20:43 <bam365> that should get you close
14:21:19 <orion> mniip: Thanks!
14:25:30 <kidto> If Haskell functions are all deterministic, how does random number generation work in the System.Random module?
14:25:30 <zmbmartin> bam365: What is stdgen part of?
14:25:43 <Pamelloes> Is there a way in template haskell to refer to the type of a class parameter? e.g. Within class MyClass a, refer to ''a?
14:25:47 * hackagebot alarmclock 0.2.0.6 - Wake up and perform an action at a certain time.  http://hackage.haskell.org/package/alarmclock-0.2.0.6 (dcturner)
14:26:01 <ion> zmbmartin: main = do { stdgen <- newStdGen; {- do something with stdgen -} }
14:26:09 <bam365> zmbmartin: that's just a placeholder for your StdGen value, gotten from mkStdGen or getStdGen
14:26:19 <ion> Don‚Äôt use getStdGen.
14:26:26 <orion> kidto: In Haskell, execution and evaluation are separate.
14:26:48 <Pamelloes> kidto: Pseudo-random number generators are deterministic. You set the seed of the generator in IO and then pass a reference to the generator whenever you use it.
14:27:00 <zmbmartin> bam365: Stupid me, Thanks!
14:27:07 <JagaJaga> Guys, I have a big problem. Have in my code function `debug = true; printDebug a = if debug then print a else return ()`. If I have debug = true my code works as expected. But if I turn it false - one thing doesn't work (part of a state isn't updated and that breaks workflow). printDebug isn't related to anything except just printing..
14:27:07 <zmbmartin> ion: Thanks!
14:27:15 <kidto> orion: I'm not sure what is meant by that in this context
14:27:16 <JagaJaga> I can send a link to my code
14:27:28 <kidto> Parnelloes: I guess I hadn't thought of it that way.
14:27:51 <orion> kidto: If you want non-deterministic behavior, you'll want to look in to the IO Monad.
14:28:18 <glguy> kidto: "randomRIO (0,9)" generates a random number when executed. It's not a function, so it's not limited by the fact that functions are pure in Haskell
14:28:57 <titito> Is it possible to catch the error thrown by openFile? Help!
14:28:57 <shachaf> glguy: I like your phrasing.
14:29:20 <orion> kidto: Notice that glguy said, "executed" and not "evaluated".
14:29:28 <Pamelloes> glguy: But RandomGen.next is a function.
14:30:10 <JagaJaga> https://github.com/ctlab/gShell/compare/7a2c0e0aaaa1661feaa239329cdedde2b9003b6e...master that commit helps.. without - no right work :/
14:30:11 <glguy> Pamelloes: That's correct
14:30:17 <JagaJaga> Some lazy things may be?
14:30:21 <kidto> orion: can you explain the difference between execution and evaluation? I've always thought of them as being more or less the same thing. When can something be evaluated but not executed?
14:31:11 <JagaJaga> And the problem is in pushGshell function - `masterState` isn't updated
14:34:01 <enthropy> Pamelloes: http://lpaste.net/1576311276043239424 it doesn't work to use ''a like that example?
14:35:15 <arkeet> enthropy: that works?
14:35:31 <orion> kidto: When you run a Haskell application, the RTS will evaluate `main' (which is of type IO ()), and then it will "execute" the IO action.
14:35:45 <enthropy> arkeet: "Pamelloes | Is there a way in template haskell to refer to the type of a class parameter? e.g. Within class MyClass a, refer to ''a?"
14:35:48 * hackagebot bank-holidays-england 0.1.0.3 - Calculation of bank holidays in England and Wales  http://hackage.haskell.org/package/bank-holidays-england-0.1.0.3 (dcturner)
14:36:10 <arkeet> oh
14:36:20 <Pamelloes> enthropy: Hm, never tried with scopedtypevariables. Let me check if that works like I want it to
14:39:00 <Pamelloes> enthropy: Well I guess that does do exactly what it says. What I wanted though would be for x (1::Int) to evaluate to ''Int
14:39:15 <kidto> orion: so execution is a strictly monadic/side effect thing?
14:39:48 <ion> kidto: You can create and manipulate a list like [ print "hello", print "world" ] without any side effects occurring, the elements are just opaque descriptions of the action of printing something. If you choose to define ‚Äúmain‚Äù as one of them (e.g. main = [ print "hello", print "world" ] !! 0) and run the program, the runtime system will execute that action and a word will be printed. 
14:40:27 <arkeet> it will only print "hello"
14:40:43 <ion> By equational reasoning [ a, b ] !! 0 = a, therefore that is the same as main = print "hello"
14:40:48 * hackagebot active 0.2.0.2 - Abstractions for animation  http://hackage.haskell.org/package/active-0.2.0.2 (BrentYorgey)
14:40:50 <kidto> ion: is main the only thing that ever gets executed in a Haskell program?
14:40:52 <enthropy> Pamelloes: I think that's not really possible because of the stage restriction
14:41:50 * enthropy guesses you could have nameOf :: Typeable a => a -> Name that sort of works
14:41:51 <Pamelloes> enthropy: I guess that makes sense. Since I'm using a class, though, I can probably just add a function to the class (name :: Name) and have the instance define it
14:41:58 <orion> kidto: Sort of. When your code is compiled and evaluated, no side effects happen. All that you get is a value whose type is "IO ()". It doesn't matter how many times you evaluate `main'
14:41:59 <ion> kidto: main is the IO action that will be executed when you run the program, it can then refer to the other parts of the program.
14:43:07 <Pamelloes> Actually no. Stage restrictions.
14:43:11 <kidto> So a compiled haskell file is just an action?
14:43:25 <enthropy> @type mkName . show . typeOf
14:43:26 <lambdabot> Not in scope: ‚ÄòmkName‚Äô
14:43:28 <kidto> or list of actions?
14:43:45 <Pamelloes> kidto: Isn't any compiled program just a list of actions for the processor to execute?
14:43:58 <Aruro> finally.
14:44:01 <marchelzo_> I'm no expert but I imagine a binary produced by GHC is quite similar to a binary produced by any other compiler.
14:44:44 <arkeet> a compiled haskell program is a binary thing not unlike what you'd make with, say, a C compiler.
14:44:49 <enthropy> that has the right type, but it's unhygienic
14:45:42 <kidto> Pamelloes: That's a good point. So functions are evaluated during compile time, and then executed during run time?
14:45:56 <kidto> I guess that's @orion as well
14:46:02 <arkeet> no, no evaluation happens at runtime.*
14:46:02 <Pamelloes> kidto: To a certain extent.
14:46:04 <orion> kidto: At compile time, the complete list of actions to take isn't known. It's only after the RTS evaluates `main' that the list of actions to take is known and ready to be executed.
14:46:06 <arkeet> er, 
14:46:07 <arkeet> at compile time
14:46:28 <arkeet> (aside from stuff like optimizations)
14:46:29 <orion> arkeet: Wait, am I wrong?
14:46:42 <arkeet> the list of actions is determined by evaluating main.
14:46:57 <arkeet> (and also in response to results of earlier actions.)
14:47:22 <orion> arkeet: I thought the evaluation of main happens at runtime.
14:47:26 <arkeet> yes.
14:47:26 <ion> kidto: You can have a program completely evaluate the list [ print "hello", print "world" ] but that will not have any side effects. To arrange an IO action to be executed and have effects, you‚Äôll bind it to ‚Äúmain‚Äù.
14:47:31 <kadoban> It could sometimes know at compile time exactly what actions will be taken, but usually it depends on input and such, which is kind of the whole point of IO.
14:47:32 <arkeet> I mistyped.
14:47:35 <orion> arkeet: ok
14:47:37 <arkeet> no evaluation happens at compile time.
14:48:03 <ion> > print "hello" `seq` ()
14:48:04 <lambdabot>  ()
14:48:19 <ion> lambdabot just evaluated (and discarded) the IO action that prints hello.
14:49:58 <arkeet> (although the way IO works internally, execution is just evaluation of values with side effects in a controlled order)
14:50:00 <Aruro> @all-dict evaluate
14:50:02 <lambdabot> *** "Evaluate" gcide "The Collaborative International Dictionary of English v.0.48"
14:50:02 <lambdabot> Evaluate \E*val"u*ate\ ([-e]*v[a^]l"[-u]*[=a]t), v. t. [See
14:50:02 <lambdabot>    {Evaluation}.]
14:50:02 <lambdabot>    To fix the value of; to rate; to appraise.
14:50:02 <lambdabot>    [1913 Webster]
14:50:04 <lambdabot> [34 @more lines]
14:50:39 <ronh> > undefined `seq` ()
14:50:41 <lambdabot>  *Exception: Prelude.undefined
14:50:58 <arkeet> > (let loop = loop in loop) `seq` ()
14:51:02 <lambdabot>  mueval-core: Time limit exceeded
14:52:03 <kidto> I'm struggling a little bit with this, I think I need to have a think
14:53:08 <arkeet> an IO action is like a recipe for a cake.
14:53:19 <arkeet> reading (evaluating) the recipe by itself doesn't make a cake.
14:53:35 <arkeet> you have to actually perform the steps that you read.
14:53:58 <ion> > cake
14:53:59 <lambdabot>      Not in scope: ‚Äòcake‚Äô
14:54:00 <lambdabot>      Perhaps you meant one of these:
14:54:00 <lambdabot>        ‚Äòtake‚Äô (imported from Data.List),
14:54:01 <Tehnix_> Isn't evaluating the actual performing?
14:54:05 <ion> cake is gone? :-(
14:54:13 <arkeet> cake is gone :-(
14:54:19 <Aruro> kidto: https://wiki.haskell.org/Lazy_evaluation
14:54:26 <arkeet> lazy evaluation has nothing to do with IO.
14:54:40 <magnapPrime> Evaluation is what turns "1+2" into "3"
14:54:42 <Aruro> he was wondering in general about evaluation vs execution, i think
14:54:52 <arkeet> sure, but you can have the same discussion in a strict language.
14:55:33 <Tehnix_> Lazy evaluation is that the "execution" is deferred until it is "used"
14:56:27 <ion> Execution is what sees ‚Äú3‚Äù and carves an image of Rick Astley into a rock if that happens to be your execution model.
14:56:33 <hpc> don't mix execution and evaluation
14:56:45 <arkeet> Tehnix: that's evaluation.
14:57:03 <Tehnix> Hmm, you're right
14:57:09 <arkeet> well, with sufficient quotes, you can make anything mean anything.
14:57:14 <arkeet> but that's misleading.
14:57:24 <magnapPrime> ion: nice metaphor. Could be simplified: Evaluation turns "print 1+2" into "print 3". Execution outputs a 3 to the console
14:57:30 <arkeet> I would say computation instead of "execution"
14:57:54 <arkeet> or maybe just evaluation
14:57:54 <kidto> magnapPrime: aha!
14:58:39 <kidto> Ok, so isn't every value 'non needed' until execution?
14:58:45 <Aruro> kidto:  thats because when you write your programm compiler still does not get you :) he needs to evaluate what you said first.
14:58:57 <magnapPrime> Sorry, that would actually be: Evaluation turns `print 1+2` into `print 3` into `putStrln (show 3)` into `putStrLn "3"`
14:58:59 <kidto> so does all lazy evaluation mean in this context is evaluation at execution time?
14:59:21 <arkeet> no, lazy evaluation has nothing to do with IO.
14:59:50 <hpc> evaluation is computing the value of a thing
14:59:53 <hpc> execution is doing a thing
14:59:55 <arkeet> laziness is just an evaluation strategy.
15:00:13 <Aruro> kidto: your programm in haskell is not command, it is and expression which compiler has to calculate first, before running any commands
15:00:13 <hpc> so for instance
15:00:23 <hpc> let foo = print 1 >> foo
15:00:26 <kidto> so what is 'needed' in the context of lazy evaluation. Because certainly max 12 (9 + 100) needs to evaluate 9 + 100...
15:00:49 <magnapPrime> If you use it, then yes.
15:01:02 <arkeet> well, max (on ints) is a strict function, so when you evaluate max 12 (9+100) you have to evaluate 9+100 first.
15:01:08 <hpc> evaluating foo would be computing "this action is sequenced with this action is sequenced with ..."
15:01:12 <kidto> what do you mean by use it? aren't I using it in the max expression?
15:01:27 <hpc> executing foo would be "do this action, then do this action, ..."
15:01:36 <arkeet> kidto: if you never use the result of max, it doesn't do anything.
15:01:54 <arkeet> the key part of what I said is "when you evaluate max ..."
15:02:07 <kidto> But I'm not 'using' anything until the program is executed. Sorry this is sort of turning my mind to shit
15:02:10 <magnapPrime> In the program "main = let n = max 12 (9+100) in return ()", (9+100) is never evaluated because "max 12 (9+100)" never is, because you don't need that value to run the program
15:02:22 <magnapPrime> Does that make sense?
15:02:27 <arkeet> main = do { let n = max 12 (9+100); putStrLn "hello" }
15:02:31 <arkeet> this will print hello, but never compute 9+100
15:02:35 <arkeet> or n
15:02:42 <magnapPrime> Arkeet: exactly!
15:02:53 <hpc> kidto: there's other scenarios besides execution
15:03:01 <arkeet> because the value of n is not needed to determine the next action to execute (namely, printing that string)
15:03:13 <kidto> It seems to me, then, like lazy evaluation only makes sense in the context of execution, but someone said that IO has nothing to do with lazy evaluation
15:03:16 <hpc> for instance, mueval will evaluate (take whatever (show yourThingYouEntered))
15:03:27 <hpc> > [1..]
15:03:28 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:03:51 <magnapPrime> An informal way of defining laziness would be "ignore everything that you don't need to find the question you've been asked"
15:03:57 <arkeet> (I think whatever = 1024 in lambdabot)
15:04:15 <Pamelloes> kidto: lazy evaluation is the process in which things are only evaluated as needed. It applied everywhere within all functions. However, things are only needed when they are needed somewhere in IO.
15:04:15 <hpc> kidto: on an abstract level, it's useful to think of evaluation happening on its own
15:04:39 <hiptobecubic> kidto, I always think about it as what *I* would do if i were trying to run the program
15:04:45 <hpc> otherwise you get into this weird useless mindset of "main = print theThingToEvaluate" when trying to do anything
15:04:54 <magnapPrime> An example of laziness in a non-IO function: f x = head [x,(x+1)..] == id
15:05:05 <Aruro> kidto: for your next meditation session i suggest this http://en.wikipedia.org/wiki/Evaluation_strategy
15:05:09 <hiptobecubic> kidto, if the program is 4000 lines long and just prints "hello world" at the end, I probably wouldn't do anything else.
15:05:10 <arkeet> (I hope that's not Prelude.id)
15:05:21 <magnapPrime> Why not?
15:05:26 <arkeet> can't == on it
15:05:30 <hpc> and iirc evaluation in haskell isn't defined in terms of IO anyway, so execution never even factors in
15:05:36 <kidto> hiptobecubic: haha
15:05:40 <magnapPrime> Oh, sorry, not what I meant either. And it only works for numbers
15:05:53 <magnapPrime> It was just an informal == to show that they are the same
15:05:54 <arkeet> (functions can be numbers!)
15:05:57 <arkeet> oh.
15:05:59 <hiptobecubic> Printing "hello world" is all that was needed. You can also think about working backwards through the program.
15:06:17 <arkeet> maybe use something like === then :p
15:06:25 <arkeet> or "is the same as"
15:06:34 <magnapPrime> f x = head x:[1..] === id
15:06:38 <magnapPrime> There?
15:06:40 <arkeet> words are better.
15:06:50 <hiptobecubic> "The output should be the literal string \"hello world\"." (you write down hello world) "There are no other outputs." (You throw the rest of the file in the trash and open a beer.)
15:06:56 <magnapPrime> I like brevity better
15:06:56 <kidto> can you really do [x, (x + 1), ..
15:07:01 <arkeet> anyway this is distracting from the point.
15:07:01 <kidto> in Haskell?
15:07:07 <arkeet> > let x = 5 in [x,(x+1)..]
15:07:08 <lambdabot>  [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31...
15:07:08 <ion> > let x = 42 in [x, x+1 ..]
15:07:10 <lambdabot>  [42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,...
15:07:17 <magnapPrime> arkeet: damn, beat me to it
15:07:25 <kidto> Oh cool
15:07:44 <arkeet> > let x = 42 in [x,(x+12)..]
15:07:46 <lambdabot>  [42,54,66,78,90,102,114,126,138,150,162,174,186,198,210,222,234,246,258,270,...
15:08:05 <hiptobecubic> > undefined
15:08:07 <lambdabot>  *Exception: Prelude.undefined
15:08:12 <kidto> > let x = 2 in [x, (x+12), (x + 2), ..]
15:08:14 <lambdabot>  <hint>:1:35: parse error on input ‚Äò..‚Äô
15:08:25 <hiptobecubic> > let x = undefined in "hi"
15:08:26 <lambdabot>  "hi"
15:08:36 <kidto> So why can't you do more complicated patterns?
15:08:40 <hiptobecubic> > let x = undefined in fst ("hi", x)
15:08:41 <lambdabot>  "hi"
15:08:42 <arkeet> kidto: [x,y..] is just special syntax
15:08:51 <arkeet> :t enumFromThen
15:08:52 <lambdabot> Enum a => a -> a -> [a]
15:08:59 <arkeet> it's syntactic sugar for this function
15:09:06 <arkeet> > enumFromThen 42 54
15:09:08 <lambdabot>  [42,54,66,78,90,102,114,126,138,150,162,174,186,198,210,222,234,246,258,270,...
15:09:15 <magnapPrime> kidto: If you can understand why this function actually runs instead of using all the space and time on your computer calculating the sum of all integers, I'd say you understand lazy evaluation: f x = fst (x,sum [1..])
15:09:16 <ion> kidto: What would the element following x, x+12, x+2 even be unambiguously?
15:09:37 <arkeet> you can do [x..] or [x,y..] or [x..z] or [x,y..z]
15:09:46 <arkeet> anything else is invalid syntax
15:10:20 <arkeet> (those correspond to enumFrom, enumFromThen, enumFromTo, and enumFromThenTo)
15:10:31 <arkeet> (from the Enum class)
15:10:44 <kidto> ion: well if [x, x+1..] is [1, 2, 3, 4, 5] I would expect [x, x+1, x+2..] to be [1, 2, 4, 5, 7, 8, 10...]
15:10:49 <hiptobecubic> Which works on other instances too, not just integers.
15:11:01 <hiptobecubic> > ['a', 'c'..]
15:11:02 <lambdabot>  "acegikmoqsuwy{}\DEL\129\131\133\135\137\139\141\143\145\147\149\151\153\155...
15:11:15 <magnapPrime> > fst ("this works",sum [1..])
15:11:16 <lambdabot>  "this works"
15:11:34 <arkeet> @let data Funny = Funny String deriving Show; instance Enum Funny where enumFromThen (Funny x) (Funny y) = Funny "hello " ++ x ++ y
15:11:35 <lambdabot>  .L.hs:150:44:
15:11:35 <lambdabot>      Couldn't match expected type ‚Äò[Funny]‚Äô with actual type ‚ÄòFunny‚Äô
15:11:35 <lambdabot>      In the first argument of ‚Äò(++)‚Äô, namely ‚ÄòFunny "hello "‚Äô
15:11:45 <arkeet> @let data Funny = Funny String deriving Show; instance Enum Funny where enumFromThen (Funny x) (Funny y) = [Funny "hello ", Funny (x ++ y)]
15:11:46 <lambdabot>  .L.hs:149:10: Warning:
15:11:47 <lambdabot>      No explicit implementation for
15:11:47 <lambdabot>        ‚ÄòtoEnum‚Äô and ‚ÄòfromEnum‚Äô
15:11:52 <hiptobecubic> heh
15:11:57 <arkeet> > enumFromThen (Funny "a") (Funny "b")
15:11:58 <lambdabot>  Not in scope: data constructor ‚ÄòFunny‚ÄôNot in scope: data constructor ‚ÄòFunny‚Äô
15:12:03 <arkeet> uhh.
15:12:07 <arkeet> oh right -Werror
15:12:11 <hiptobecubic> Clear as a bell :)
15:12:18 <arkeet> @let data Funny = Funny String deriving Show; instance Enum Funny where enumFromThen (Funny x) (Funny y) = [Funny "hello ", Funny (x ++ y)]; toEnum = undefined; fromEnum = undefined
15:12:19 <lambdabot>  Defined.
15:12:22 <arkeet> > enumFromThen (Funny "a") (Funny "b")
15:12:24 <lambdabot>  [Funny "hello ",Funny "ab"]
15:12:35 <arkeet> > [Funny "a", Funny "b" ..]
15:12:36 <lambdabot>  [Funny "hello ",Funny "ab"]
15:12:53 <hiptobecubic> how zany
15:12:56 <magnapPrime> arkeet: I think you're just confusing kidto by now
15:13:21 <kidto> :O
15:13:22 <arkeet> oh, well kidto can pretend I never said anything.
15:13:25 <magnapPrime> > fst ("Lazy evaluation FTW!",sum [1..])
15:13:26 <lambdabot>  "Lazy evaluation FTW!"
15:13:36 <hiptobecubic> You really like that example
15:13:46 <kidto> Yeah, I think I have a grasp on lazy evaluation now, and the difference between evaluation and execution
15:14:02 <arkeet> evaluation can never* have side effects.
15:14:11 <kidto> *?
15:14:12 <Aruro> magnapPrime: i think kidto got  confused about half hour ago
15:14:18 <arkeet> (* not counting stuff like unsafePerformIO)
15:14:24 <magnapPrime> I do indeed. I think it's extremely understandable once you grok laziness, and very weird if you don't, and thus helps to determine whether someone understands it or not
15:14:29 <hiptobecubic> kidto, there are some backdoors that no one likes to talk about.
15:14:53 <kidto> I feel like Haskell can be sort of cultish in that regard hiptobecubic
15:15:05 <kidto> but I'm starting to understand
15:15:15 <hiptobecubic> kidto, there is a certain discipline that comes with a language like haskell, yes.
15:15:16 <glguy> They aren't a problem (the back doors) they are just explicit escape hatches
15:15:33 <kidto> That asterisk makes many appearances in the haskell learning process ;)
15:15:34 <arkeet> they are a problem if you show them to a beginner.
15:15:47 <arkeet> because they shouldn't be used unless you Really Know what you're doing.
15:15:50 <glguy> Yeah, the problem is that people use them when it's inappropriate
15:15:54 <hiptobecubic> kidto, In languages like python and ruby the culture is much more about "do whatever you have to do to get the result you (think) you need right now"
15:16:16 <magnapPrime> It's more of a safety precaution. unsafePerformIO breaks so many guarantees that you really have to know what you're doing in order to use it safely
15:16:19 <hpc> python's more got a culture of you have to do it exactly the right way
15:16:27 <hiptobecubic> in haskell, the compiler doesn't put up with that stuff :)
15:16:28 <hpc> other ways are wrong, even if they work
15:16:50 <arkeet> perl is "there is more than one way to do it"
15:16:53 <hiptobecubic> hpc, well i think the "we're all consenting adults" attidude is what I'm more trying to invoke
15:17:07 <arkeet> python is "there is only the one way to do it"
15:17:16 <arkeet> haskell is "the ways of doing it form a category"??
15:17:25 <kidto> One of the things that throws me in Haskell is the sheer volume of implicit structure
15:17:30 <arkeet> (I'm bad at jokes.)
15:17:35 <kidto> coming from python, where everything is very explicit
15:17:35 <Pamelloes> hehe
15:17:39 <magnapPrime> Where Haskell is more "you have to read this contract, AND BE MINDFUL OF THE STUFF IN SMALL PRINT, before you can do this"
15:17:43 <magnapPrime> arkeet: lol
15:18:05 <hpc> nah, most of that kind of thing is encoded in the type signature
15:18:24 <orion> < arkeet> (* not counting stuff like unsafePerformIO) <-- if unsafePerformIO can make side effects happen during evaluation, does that mean that I could, in theory, write a Haskell program that, when compiled, will "rm -rf /" ? (After all, evaluation happens during compilation as you said earlier).
15:18:28 <hiptobecubic> kidto, I think your opinion will be the reverse as you get used to haskell
15:18:29 <creichert> haskell is very explicity once you get the hang of it, i feel python is v ery implicit :)
15:18:31 <monochrom> no, I find haskell explicit, python implicit
15:18:35 <srhb> orion: Yes
15:18:37 <arkeet> orion: remember how I said evaluation doesn't happen at compile time?
15:18:46 <srhb> Oh, when compiled
15:19:03 <monochrom> "o.x()" this implicitly depends on a million unsaid variables and affects a thousand others.
15:19:05 <arkeet> yeah sorry about mistyping that haha
15:19:07 <kidto> Well for example, imports in python are scoped very explicitly, but in Haskell they all seem to sit in the same 'namespace' (for lack of a better word?)
15:19:10 <orion> < arkeet> no evaluation happens at compile time.
15:19:11 <Pamelloes> orion: You can't do that with unsafePerformIO but you can do that with TemplateHaskell...
15:19:23 <arkeet> kidto: you can have qualified imports 
15:19:29 <ion> You can write a Haskell program that uses Template Haskell to delete all the files at compile time, but that is beside the discussion about evaluation.
15:19:31 <monochrom> I write explicit imports.
15:19:36 <srhb> orion: What you can do with unsafePerformIO is have a :: Int which deletes your system and fires all the missiles
15:19:38 <orion> arkeet: That was literally the last thing you said to me.
15:19:41 <srhb> When evaluated.
15:19:43 <monochrom> python does not ban "import os.*" anyway
15:19:57 <magnapPrime> kidto: The structure isn't actually implicit, but I guess once you find an abstraction ( :: (specific -> general) ;-) ) you don't use the specific cases anymore, which makes the abstraction seem like "magic" or the slightly more euphemistic term implicit structure
15:20:01 <arkeet> orion: I'm pretty sure I said "no evaluation happens at compile time"
15:20:14 <hiptobecubic> what about template haskell?
15:20:23 <orion> arkeet: Hah, I inserted a phantom comma in to your statement.
15:20:27 <arkeet> yeah, I wasn't counting TH
15:20:30 <srhb> orion: no as in zero
15:20:31 <srhb> Ah, you got it
15:20:35 <arkeet> as in "evaluation doesn't happen"
15:20:37 <orion> Fucking phantom commas.
15:20:40 <srhb> :-)
15:20:54 <arkeet> english is weird.
15:20:59 <monochrom> I would be surprised if you did not know that "import os.*" is legal
15:21:02 <magnapPrime> So ambiguous!
15:21:03 <ronh> kidto there is a qualified import: import Data.Map as Map
15:21:08 <kidto> how do you do explicit imports in Haskell?
15:21:10 <kidto> oh
15:21:17 <magnapPrime> * import qualified Data.Map as map
15:21:19 <magnapPrime> * import qualified Data.Map as Map
15:21:20 <arkeet> there are also explicit import lists:
15:21:29 <monochrom> import System.IO(hFlush, stdout)
15:21:37 <arkeet> ^
15:21:50 <magnapPrime> monochrom: I use those only for operators
15:21:56 <orion> God, life would be so much easier if everyone spoke in Lojban.
15:22:16 <srhb> orion: Is that "God and life would be" ... ?
15:22:17 <Azel> magnapPrime: They're also useful when you're redefining parts of the Prelude
15:22:19 <srhb> :-)
15:22:23 <magnapPrime> orion: So much of philosophy would collapse
15:22:43 <ion> orion: Was that directed to God or was that an exclamation? It was a bit ambiguous.
15:22:50 <orion> haha
15:23:01 <magnapPrime> orion: Correction: so much of (bad) philosophical discussion would be impossible
15:23:10 <kidto> but what if I define a bunch of data types in my module A, e.g. Thing, OtherThing, and someone imports the module A. If they want to use those types, there's no equiv. of python's A.Thing is there?
15:23:26 <magnapPrime> kidto: There is actually, and just as you wrote it
15:23:33 <arkeet> import qualified A
15:23:35 <monochrom> import A(Thing)
15:23:36 <arkeet> ... A.Thing ...
15:23:53 <kidto> Ah, ok
15:24:10 <arkeet> and you can rename modules, like
15:24:21 <arkeet> import qualified Big.Module.Name as A
15:24:21 <magnapPrime> Congratulations, you correctly guessed syntax. This is actually a big step. If you can do so manually, increase your confidence in the code you write
15:24:53 <arkeet> (it's pretty popular to import modules and give them 1- or 2-letter names)
15:25:27 <magnapPrime> An example of my style of imports: "import qualified Control.Applicative as CA; import Control.Applicative (<*>)"
15:25:50 * hackagebot cryptol 2.2.3 - Cryptol: The Language of Cryptography  http://hackage.haskell.org/package/cryptol-2.2.3 (AdamFoltzer)
15:25:57 <arkeet> yeah, but I don't think anyone imports Control.Applicative qualified.
15:26:09 <srhb> And now no one even imports it anymore explicitly. Woo!
15:26:11 <arkeet> more useful for stuff like Data.Text or Data.ByteString or whatever
15:26:12 <kadoban> Well, some people import eevrything qualified
15:26:21 <arkeet> srhb: nah, you still need it for stuff like liftA2
15:26:25 <arkeet> or whatever
15:26:26 <monochrom> did you know? import System.IO as X; import Control.Applicative as X
15:26:42 <arkeet> monochrom: yeah I like doing things like 
15:26:45 <magnapPrime> arkeet: I actually do... Should I be ashamed?
15:26:48 <arkeet> import qualified Data.Text as T
15:26:50 <arkeet> import qualified Data.Text.IO as T
15:27:13 <kadoban> magnapPrime: It's a bit weird, but if it works for you *shrug*
15:27:20 <arkeet> magnapPrime: well, names in Control.Applicative don't really collide with anything else
15:27:31 <arkeet> (library writers try to avoid collisions with stuff in base, I hope)
15:27:43 <arkeet> (unless they intend for their things to be used qualified)
15:27:51 <kidto> woah, monochrom does that work?
15:28:05 <arkeet> yeah, it just imports stuff from both modules into the same namespace.
15:28:09 <srhb> It does, but you'll have to explicitly disambiguate if there are conflicts.
15:28:14 <kidto> erk
15:28:17 <kadoban> kidto: Yep. It just combines them. You can get ambiguities though sometimes.
15:28:19 <srhb> (Well, only if you use something that is conflicting)
15:28:31 <srhb> What would the alternative be, anyway.
15:28:36 <magnapPrime> kadoban, arkeet: Yeah, I know, but I really only have 2 modes: total neatfreak, and total slob.
15:28:37 <srhb> (Type directed resolution, pls)
15:28:41 <arkeet> haha
15:29:19 <arkeet> 7.10 is nice
15:29:22 <kidto> Is the qualified import not being default just a matter of taste, or is there some fundamental reason for it?
15:29:27 <arkeet> I don't have to hide anything when importing both Control.Monad and Data.Foldable \o/
15:30:01 <arkeet> kidto: you can always refer to a thing by its fully qualified name
15:30:09 <arkeet> but those tend to be long 
15:30:20 <srhb> kidto: I seldom use qualified, really.
15:30:26 <srhb> kidto: Aliasing is more common for me.
15:30:41 <srhb> kidto: If I can get away with unambiguously not using a qualifier, I prefer that, obviously.
15:30:51 <arkeet> and when I do import something qualified, I usually try to give it a short name.
15:30:55 <geekosaur> just the way the language was designed. whether it's a good idea or not is still an unanswered question, although leaning toward qualification is looking better all the time (see for example the mess around 7.10 and Dat.List post-BBP)
15:30:58 <geekosaur> Data.List
15:31:23 <arkeet> yeah Data.List is weird :(
15:31:54 <magnapPrime> I really wish we had a briefer way of importing a lot of packages, especially qualified. Maybe we could just map import [(Package,Name)]? That would be cool
15:32:16 <magnapPrime> * [(Module, Maybe Name)]
15:32:28 <arkeet> that sounds annoying tbh
15:32:52 <arkeet> (and how would you do explicit import lists)
15:32:52 <srhb> Obviously modules should be first class citizens.
15:32:57 <srhb> How to do it is a bit trickier...
15:33:04 <geekosaur> (for those unaware: "Bridge Burning Proposal", basically rewired Prelude to default to Foldable and Traversable functions. but then Data.List is always imported unqualified on the assumption that its functions match the Prelude, but they don't any more. so Data.List was made to have the Foldable/Traversable functions instead of list specific, and Data.OldList is a temporary home for the specific ones until the mess is sorted out)
15:33:32 <hpc> that's a vivid name for a proposal
15:33:33 <kidto> If you force qualification and allow renaming, isn't that kind of ideal? aside from the import Thing1 as X; import Thing2 as X; craziness, it eliminates any chance of ambiguity and still allows you to be concise.
15:33:56 <arkeet> yeah but 
15:33:56 <srhb> kidto: Ick, I don't wnat to qualify everything.
15:34:05 <arkeet> not concise enough
15:34:10 <arkeet> particularly qualified operator names are ugly
15:34:11 <magnapPrime> How so? You could reduce "import qualified Data.List as DL; import Control.Applicative" to "map import [("Data.List",Just "DL"),("Control.Applicative", Nothing)]"
15:34:17 <srhb> kidto: Haskell is all about combining functions, if I have to stick qualifiers everywhere it spaghettifies.
15:34:19 <arkeet> array A.! n, etc
15:34:31 <geekosaur> increasingly I find that unqualified names are asking for future problems (of the BBP sort in particular)
15:34:34 <srhb> kidto: Having foo . bar . baz . quuz $ arg -- is not uncommon
15:34:43 <srhb> Now stick qualifiers on and cry...
15:34:45 <kidto> srhb: you're right
15:34:59 <geekosaur> but people want "pretty" and don't care about safety against future changes
15:34:59 <srhb> I think the BPP troubles are minimal.
15:34:59 <magnapPrime> geekosaur: In principle, I agree. But qualified operators are sooooo ugly!
15:35:22 <srhb> BBP*
15:35:26 <magnapPrime> Maybe we should just switch so S-expressions?
15:35:30 <kidto> but there has to be some better solution than dumping everything into a top level namespace
15:35:34 <srhb> magnapPrime: >:/
15:35:40 <geekosaur> arguably a good IDE could solve this by presenting the names with the qualification moved to tooltips or etc.
15:35:41 <arkeet> magnapPrime: I like not having to sprinkle parentheses everywhere.
15:35:44 <srhb> kidto: Yes, qualify when necessary.
15:35:45 <monochrom> kidto: I import System.IO(hFlush, stdout) so I can just cite "hFlush" and you can still look at the header to find where hFlush comes from.
15:35:53 <arkeet> qualify when necessary
15:35:53 <magnapPrime> Haskell as a Lisp, Haskell as a Lisp!
15:35:59 <magnapPrime> ;-)
15:36:00 <arkeet> keep your code up to date with current ghc
15:36:13 <monochrom> for example http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml
15:36:19 <kidto> monochrom: that seems like a good style choice
15:36:22 <magnapPrime> monochrom: That's a good way of doing it too
15:36:30 <mniip> is there something similar to ruby's mechanize in haskell?
15:36:33 <geekosaur> alternately, yeh, you can import specific names unqualified and now you also make it easier for tooling to detect and maybe even fix such problems plus built in documentation
15:36:57 <mniip> like a webscraper but much more like a real browser, with cookies and javascript stuff
15:37:17 <geekosaur> mniip, don't know of one offhand but I['m not a web type. otoh it's been ported everywhere --- it's not a Ruby thing, the original was Perl's WWW::Mechanize
15:37:43 <ronh> kidto it is localized, though. identifiers you import in your own module's top-level namespace won't be automatically exported when you import that module elsewhere
15:38:07 <magnapPrime> mniip: I don't know enough about the ecosystem to answer that, but if there is , it's probably built upon http-conduit
15:38:28 <arkeet> looking around finds me this http://hackage.haskell.org/package/shpider
15:38:32 <magnapPrime> Network.HTTP.Conduit.http seems pretty powerful
15:38:40 <arkeet> it seems unmaintained though
15:38:55 <zmbmartin> What is this error import Crypto.BCrypt
15:38:57 <arkeet> oh there is also https://hackage.haskell.org/package/hs-scrape
15:39:00 <zmbmartin> Sorry wrong one :)
15:39:10 <geekosaur> @paste
15:39:10 <lambdabot> Haskell pastebin: http://lpaste.net/
15:39:15 <geekosaur> full code, full error message
15:39:15 <arkeet> put your code and error message here ^
15:39:16 <srhb> http-conduit-browser is probably useful too
15:39:24 <zmbmartin> Context reduction stack overflow; size = 21Use -fcontext-stack=N to increase stack size to N
15:39:39 <arkeet> srhb: yep it is, but it doesn't parse html or anything on its own
15:39:48 <geekosaur> that's a bit of ghc internals designed to prevent infinite loops in type resolution
15:40:02 <ronh> personally, in my own code, I prefer fixing a future conflict once in a blue moon than making a mess by qualifying everything.. but then I never pusblished a library, if I did I might think differently
15:40:22 <zmbmartin> geekosaur: So I have something wrong then?
15:40:23 <geekosaur> use the option it names to bump the context stack, and possibly report to ghc hq (try #ghc or the GHC Trac if it's recovered from the spammerbot yet)
15:40:27 <geekosaur> not guaranteed
15:40:56 <geekosaur> it often needs some tweaking on new versions, if you've upgraded to 7.10.1 or HEAD then it might just indicate that the default needs to be bumped again
15:41:14 <zmbmartin> geekosaur: No I am on 7.8 but where do I put that option?
15:41:15 <geekosaur> because every new version adds new complications to type resolution
15:41:52 <geekosaur> ghc-options: ... in the cabal file, or {-# OPTIONS_GHC ... #-} at the top of the source file triggering the issue
15:41:56 <magnapPrime> ronh: If you published a library like that, I'd be severely tempted to go through it and qualify *everything*
15:42:03 <arkeet> or in the command line if you're invoking ghc that way
15:42:43 <SrPx> hey someone posted some time ago he solved the problem of identical names on records... does anyone recall what the library was called?
15:43:09 <geekosaur> um, there's lots of solutions. all of which boil down to some form of lenses :)
15:43:15 <ronh> isn't that due in future ghc release? or was it already released?
15:43:20 <geekosaur> (not necessarily the lens library)
15:43:24 <zmbmartin> geekosaur: Is there a unsafe number to set that to?
15:43:34 <magnapPrime> SrPx: Are you referring to this? https://wiki.haskell.org/Name_clashes_in_record_fields
15:43:34 <geekosaur> zmbmartin, I don't know of one
15:43:35 <SrPx> geekosaur: wait what does lens has to do? I'm using lens and still have that problem...
15:43:40 <srhb> SrPx: http://www.reddit.com/r/haskell/comments/2svayz/i_think_ive_nailed_it_ive_solved_the_records/
15:43:54 <SrPx> that's it
15:44:08 <geekosaur> SrPx, are you using the TH goo to derive names for your record elements?
15:44:22 <zmbmartin> geekosaur: Thanks!
15:44:29 <geekosaur> you define them with specific names and then makeLenses ''RecordName or some such
15:44:43 <geekosaur> zmbmartin, anyway at worst it takes longer for an inifinite loop to be detected
15:45:24 <ronh> > view _1 (1,2)
15:45:26 <lambdabot>  1
15:45:27 <geekosaur> which should only happen with certain compiler options and if you've made certain mistakes the compiler can't easily catch
15:45:29 <ronh> > view _1 (1,2,3,4,5)
15:45:29 <magnapPrime> I was just about to say that it hadn't been solved yet to the best of my knowledge, but now the best of my knowledge is better :-D
15:45:31 <lambdabot>  1
15:45:36 <geekosaur> (UndecidableInstances comes to mind)
15:45:38 <SrPx> geekosaur: yes, is there a better way? the derive lens thing
15:45:48 <geekosaur> not really
15:46:04 <SrPx> well it doesn't solve name clashes right
15:46:22 <geekosaur> the idea is you have private field names and then make them instances of some HasField typeclass, with the public accessor defined in terms of that typeclass
15:46:33 <geekosaur> which is what a simple lens is, more or less
15:46:46 <SrPx> hmm
15:47:00 <geekosaur> TH just abstracts away the mechanical, repetitive definition of the typeclass and instances
15:47:10 <srhb> Here's the GHC trac page https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields/Redesign
15:47:21 <srhb> Which is beautiful.
15:47:25 <geekosaur> ^ soem version fo this may be in a future ghc
15:48:00 <geekosaur> but for now lens packages (simple ones like fclabels up to the full blown ekmett one) and TH are the easiest way to deal
15:48:36 <srhb> Or manually disambiguate and cry a little inside.
15:48:44 <srhb> That's my approach. Q_Q
15:49:00 <nshepperd> the TH goo in nikita's solution looks noisier than qualifying A.foo B.foo
15:49:47 <srhb> I like the quasiquoter.
15:50:00 <magnapPrime> I'm not really sure how much I like named function parameters. Currying matters!
15:50:03 <nshepperd> maybe this is a problem that actually /would/ be solved by type-directed disambiguation?
15:50:50 <srhb> nshepperd: Partially, but I think the full blown extension which allows Nikitas solution without the syntactic overhead wins.
15:50:53 <nshepperd> just export 'foo :: Lens A Foo', 'foo :: Lens B Foo' from the different libraries, and disambiguation which foo based on types
15:51:33 <nshepperd> (at the use site)
15:52:10 <geekosaur> nshepperd, there's a wiki page on TDNR, upshot is it's got nasty corner cases
15:52:19 <SrPx> okay see, instead of asking this, can you guys give your opinion on how to improve this design? http://lpaste.net/131791 this is just some parts of the lib
15:52:42 <SrPx> The type signatures get huge quick and this is making my code horrible
15:53:00 <danilo2> Hello! :) I'm learning how to use the edwardk's Bound library. I've modified the Deriving.hs example (https://github.com/ekmett/bound/blob/master/examples/Deriving.hs) and I'm wondering if the results produced by the code are ok. In the main function I'm printing two lambdas with their scopes. One of them has mixed Free and Bound variable in one datatype and I'm wondering what that means and how we can use it further: http://lpaste
15:53:05 <SrPx> but the alternative seems to be making everything not generic
15:53:09 <srhb> SrPx: First off, use contraintkinds to alias your constraints
15:53:29 <srhb> SrPx: Other than that, lensify, and probably use Nikitas records, too.
15:53:48 <danilo2> Is there anybody who could just look at the code I've pasted (http://lpaste.net/131790) and tell me how should Iinterpret the results given by the libary? On the bottom I posted the output and a little more detailed question.
15:54:31 <nshepperd> ah, the OverloadedRecordFields redesign is nice
15:54:31 <SrPx> what exactly do you mean with lensify? just using makeLens or write the functions using them?
15:54:57 <srhb> SrPx: The latter, although as you're manually pattern matching those short types it's not so bad
15:54:57 <SrPx> I never know if I'm supposed to use lists, if I'm supposed to use Data.Traversal & such or if I should just use the traversal lens that do teh same
15:55:16 <magnapPrime> danilo: Is that the output of main?
15:55:21 <nshepperd> so your 'foo' in the redesign is effectively :: Has "foo" a b => Simple Lens a b?
15:55:25 <danilo2> magnapPrime: yes
15:55:37 <srhb> SrPx: What are those f a constraints anyway?
15:55:47 <srhb> Oh, I see it now
15:56:14 <SrPx> srhb: just so I can create a Ray [1,2,3] [4,5,6] or a Ray (V3 1 2 3) (V3 4 5 6)
15:56:48 <srhb> SrPx: If you can find a sensible way to alias your constraints I think your code is looking pretty good
15:56:51 <srhb> Right now that's the major ick.
15:56:58 <magnapPrime> danilo: I haven't read much of it, but isn't there something really wrong if "return ()" gives an output?
15:58:33 <danilo2> magnapPrime: Look, the main with return () is commented out. The real main is above. I'm sorry for not making it clear enough!
15:58:37 <geekosaur> magnapPrime, see line 89ff
15:58:44 <SrPx> Another problem, for example, those functions: http://lpaste.net/131794 they transform a position inside a n-dimensional table into a flat index. Ex: toIndex [4,4,4] [1,1,0] == 5 ... it is useful so I can map the coordinates of a voxel space to the flat array holding its data
15:58:50 <magnapPrime> Ah, sorry. My bad
15:59:02 <SrPx> The problem is that when I use V2 or V3 it doesn't work because there is no zipWith nor scanl for V2/V3
15:59:27 <SrPx> but most of the time I'm using V2 or V3 when I need the concept of a spatial vector/position thing
15:59:27 <danilo2> magnapPrime, geekosaur: Do you understand the results? Do you know how can we iterpret a free "variable" containing a bound one ?
15:59:48 <SrPx> not lists. so those functions are useless. I needed a version that worked for both V2 and V3 but I can't figure it out
16:00:24 <magnapPrime> danilo2: Not at all. I have almost but not entirely no idea what's happening here
16:00:42 <danilo2> magnapPrime: :(
16:00:48 <glguy> YOu can do generic zipWith for V2/V3 with their Representative functor instances
16:00:50 <magnapPrime> Sorry I can't help here :-(
16:01:19 <geekosaur> I have some idea of what's going on although have not studied it in detail
16:01:20 <danilo2> magnapPrime: no problem, thank you for looking at the code :) I hope anybody here has some experience with this library and could tell me a hint :)
16:02:31 <danilo2> geekosaur: hmm, that's interesting. First of all I've got doubts if the results should look like this, but if tat is an "official" example with different (nonempty) main, it shoul work. But I cannot see a way to use it efficintly or just use it in any sensible way
16:02:55 <e4x> Hi, I have a problem with this code http://lpaste.net/131793. doc_get_word returns always the first word of the document, i need a function which returns the next word on suceccive calls, i.e if the document is "i love haskell" it should returns "i", next call "love", and the last call "haskell"
16:02:57 <geekosaur> it looks like lambda bindings represented as an AST
16:03:13 <geekosaur> I assume F and B come from Bound
16:03:23 <geekosaur> ("F"ree and "B"ound?)
16:03:39 <srhb> e4x: Don't stick punctuation in your links! :-)
16:03:54 <SrPx> glguy: what?
16:04:11 <geekosaur> srhb, maybe you need a better client :)
16:04:18 <e4x> srhb: sorry
16:04:30 <srhb> geekosaur: Pretty sure dots are legal in urls :P
16:04:43 <danilo2> geekosaur: yes, thats right. This is exactly what this code does. The question is, what does "(Scope (V (F (V (B 0)))))" - the "0" is a debruijn index, but I don't get why it is nested in a F (free "variable")
16:05:00 <geekosaur> srhb, but unusual as the last character of an URL
16:05:38 <geekosaur> looks to me like the F refers to "y" which is not used anywhere else. without knowing the Bound library, I could not say for certain
16:06:02 <geekosaur> whereas B 0 refers back to "x"
16:06:37 <srhb> e4x: What you are asking for is not generally how we would do things, I think.
16:06:44 <srhb> e4x: (If I understand you correctly anyway)
16:07:20 <magnapPrime> ex4: I agree with srhb. You'd be better of having Document be a lazy String
16:07:28 <danilo2> geekosaur: Hmm, I do not think it is a valid interpetation (again, I could be wrong), because if you look at the first line generating the output, it has 2 patterns and 1 bound variable. In the second case we shoul get exactly the same thing but with different index. I understand that this "F" is some kind of index mapping. I think I have to ask edwardk about it :(
16:07:41 <geekosaur> likely
16:07:52 <srhb> e4x: ie. what you're asking for is pretty close to "I want global state"
16:07:57 <srhb> If you can forgo that, it's easy
16:07:58 <danilo2> geekosaur: than you :)
16:08:12 <srhb> You can either keep the rest of the document around as a parameter or use a State monad transformer or something similar
16:08:21 <srhb> Or indeed a lazy list
16:08:25 <magnapPrime> You could then lazily turn it into a [String] (I think words is lazy) and get
16:08:35 <geekosaur> mm, right, second one shouldn't also be B 0 in that case. so I do not know, but as I have no idea what Bound is doing I can only try to guess
16:08:41 <magnapPrime> ninja'd by srhb
16:08:49 <magnapPrime> * get the words one at a time
16:08:50 <srhb> magnapPrime: :)
16:09:20 <e4x> srhb: thanks, i'll google these concepts :P
16:10:12 <srhb> e4x: I'm not quite sure what you're trying to accomplish. You might be satisfied with an IO action that simply loops everytime you press enter or something, and gets the next item each time
16:10:20 <srhb> More specification would help :)
16:11:41 <average> hey
16:11:43 <average> got a quick question
16:11:56 <geekosaur> @where justask
16:11:56 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
16:11:59 <average> how good is GHC 's garbage collector ?
16:12:08 <magnapPrime> e4x: Think of it in terms of types and information required. To get a certain word in a document, you need some kind of information saying where it is. Here you could use an Int (for the word number), and implement get_word :: String -> Int -> String as get_word doc n = (words doc) !! n (that should be point-freed)
16:12:17 <hpc> paul hudak died
16:12:26 <average> because I wrote some Python web app, and when trying to deploy it, I noticed it was blowing chunks of memory
16:12:46 <magnapPrime> @pl get_word doc n = (words doc) !! n
16:12:47 <lambdabot> get_word = (!!) . words
16:12:56 <average> is GHC's GC intelligent ? or is it bs like all the GCs' of dynamic languages ?
16:13:13 <average> any ideas on that ? or articles/blogposts I can read on this ?
16:13:19 <magnapPrime> I can't believe i'm lazy enough to get lambdabot to @pl such a simple function for me
16:13:26 <hpc> average: look at the ghc trac commentary
16:13:34 <average> hpc: where
16:13:36 <average> link ?
16:13:52 <hpc> https://encrypted.google.com/search?q=ghc+trac+commentary&hl=en&gbv=1&sei=E7dCVaeOAsjmoATR6oHQAw -- :)
16:13:58 <magnapPrime> http://www.caringbridge.org/visit/hudak/journal/view/id/5538f5cea589b4216c04438a
16:14:00 <hpc> https://ghc.haskell.org/trac/ghc/wiki/Commentary
16:14:00 <geekosaur> I guess I know how many people read the /topic now...
16:14:16 <hpc> geekosaur: it's sooooooo long
16:14:20 <average> hpc: also, is that an "yes, GHC's GC is bs" ? or is it a "no, GHC's GC is behaving well and doesn't require external monitoring to restart Haskell programs in order not to run out of memory" ?
16:14:43 <hpc> average: it's "this explains the details better than i can"
16:14:54 <average> ok, thank you for your answer
16:14:56 <geekosaur> average, ghc's gc is pretty good, but in a lazy language it's on you to be careful about unexpected sharing that may hold things alive longer than you expect
16:15:01 <hpc> it's not a simple good vs bad
16:15:10 <average> I guess, like with Python, I will have to read a lot to understand how GHC's GC behaves
16:15:13 <peddie> average: http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/local-gc.pdf is a pretty recent description, but I suggest you try prototyping and see how the GC performs :)
16:15:19 <shachaf> GHC's GC is average
16:15:24 <shachaf> So you would know all about it.
16:15:27 <hpc> for instance, i haven't ever had problems with perl's garbage collector
16:15:39 <average> shachaf: so it's bs just like Python's ?
16:15:44 <hpc> i know problems exist, but they're easy to avoid
16:15:52 <fosskers> Hi, we used to be able to use `GeneralizedNewtypeDeriving` to automatically derive an instance of MonadError. Now with 7.10, Error has been deprecated in favour of `ExceptT`.
16:16:00 <hpc> average: just read the link; understanding trumps yes/no
16:16:01 <magnapPrime> average: That was a pun
16:16:09 <fosskers> Is there an analygous `MonadExcept` for automatic deriving?
16:16:09 <shachaf> A question like "how good is GHC's GC" won't yield a lot of useful information, and looks pretty hostile.
16:16:21 <average> hpc: hm, ok
16:16:30 <magnapPrime> shachaf: I wouldn't go so far as to say hostile
16:16:59 <hpc> i would say "doesn't lead to understanding"
16:17:20 <magnapPrime> hpc: +1
16:17:24 <hpc> someone could hear "ghc gc is top class" and go writing really leaky programs
16:17:32 <geekosaur> not precisely "hostile" but definitely has the "explain $complex_thing while standing on one foot" problem
16:17:34 <hpc> or "perl gc is shit" and never hit a problem ever
16:18:02 <hpc> (perl's a great general example of things that people say are shit, but aren't :D)
16:18:28 <magnapPrime> geeoksaur: Ummm, monads! Yeah, they're burritos... No, wait, spacesuits!
16:18:37 <phy1729> How does one decide what order to put arguments in?
16:18:38 <average> not sure why you bring up Perl, but yes, I've rarely every hit the memory problems I had with Python in Perl
16:18:40 <shachaf> Maybe "hostile" isn't the right word. But it reminds me of the people who join the channel and say "justify Haskell's existence".
16:18:44 <average> s/every/ever/
16:18:47 <shachaf> magnapPrime: Not funny.
16:19:01 <geekosaur> 99% of the time when people say something is shit they mean they can't be arsed to try to understand it so they're going to piss on it to self-justify
16:19:05 <hpc> average: bringing up other languages is a good way to build understanding through comparison
16:19:12 <hpc> average: haskell is pretty alien in many respects
16:19:27 <hpc> but where it lines up with others or has a clear contrast, it helps
16:19:37 <shachaf> One thing that can be said about GHC's GC is that it's in a somewhat different environment from a typical GC.
16:19:44 <shachaf> For instance because GHC tends to do a lot of mutation.
16:20:16 <average> I just wanna know if this thing will leak its guts out and fill all available memory
16:20:19 <fosskers> Is there an class like `MonadExcept` (like the old MonadError) in 7.10 for automatic instance deriving?
16:20:24 <magnapPrime> shachaf: Why not? I think it's ironic that a concept as simple as monads are (2 functions to define one) can so hard to grok
16:20:27 <average> yes I know it depends on how I write the code
16:20:37 <hpc> average: it depends on how you write the code
16:20:43 <average> right
16:20:49 <arkeet> fosskers: MonadError isn't part of ghc, and what's wrong with MonadError?
16:20:53 <hpc> you're asking "how tall is this ladder"
16:20:56 <magnapPrime> That's really the best available answer
16:20:59 <hpc> i dunno, how tall a ladder did you get
16:21:26 <average> hm, let me narrow down my question
16:21:27 <fosskers> arkeet, It's been deprecated in favour of Except
16:21:34 <hpc> average: i can say that ghc is a very tall house though
16:21:37 <hpc> :P
16:21:39 <shachaf> You only need one function to define a monad. But you need zero burrito jokes to do it.
16:21:40 <arkeet> fosskers: says who?
16:21:57 <magnapPrime> hpc: In your analogy, we can still say stuff like "higher than 0 m" and "lower than the distance to space", though such statements aren't very helpful
16:21:58 <arkeet> Except is a type.
16:22:00 <average> when writing a Python web app and deploying it, it's usually necessary to put a monit/supervisor around it to make sure it's being restarted if it takes up too much memory
16:22:01 <arkeet> MonadError is a class.
16:22:11 <average> this applies to Django and it applies to Flask (Python web frameworks)
16:22:23 <fosskers> arkeet, the compiler, and this: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/Control-Monad-Trans-Error.html
16:22:28 <nshepperd> average: I have never run into a bug that resulted in holding memory past its lifetime
16:22:28 <magnapPrime> shachad: (>>=) and return?
16:22:30 <average> is there someone here that has deployed Haskell web apps and has needed to do the same thing ?
16:22:43 <srhb> average: Never :P
16:22:43 <hpc> average: you're asking the wrong question
16:22:53 <srhb> average: You can write leaky web apps though!
16:22:54 <hpc> average: "do i trust my own code to run without supervision"
16:23:00 <srhb> average: I just never did...
16:23:03 <srhb> At least, not yet.
16:23:05 <average> srhb: You swear on what is most precious to you that you didn't ?
16:23:05 <arkeet> fosskers: this has nothing to do wtih MonadError.
16:23:20 <arkeet> fosskers: ErrorT is the thing that's deprecated.
16:23:21 <srhb> average: So far yes, and my VPS has like 500 MB RAM
16:23:21 <shachaf> retract is the only function you need to define a monad.
16:23:21 <JagaJaga> Is there a way to use seq in a monad like `foo >> seq >> bar`?
16:23:28 <srhb> (and no swap)
16:23:33 <arkeet> JagaJaga: what is that supposed to do?
16:23:36 <magnapPrime> shachad: And (genuinely) sorry if monad tutorials are a touchy subject
16:23:37 <hpc> average: if you don't want to put a supervisor on your code, don't
16:23:45 <hpc> average: but it depends on how you write the code
16:23:54 <shachaf> I won't see your messages as long as you keep spelling them with a d.
16:23:57 <average> I'll reserve my rights to be skeptical on this matter.
16:24:00 <magnapPrime> Sorry!
16:24:04 <nshepperd> average: if you write the code in a way where data stays alive too long, no gc can help you
16:24:08 <average> Until I spend more time reading docs and blogposts on GHC's GC ..
16:24:21 <srhb> average: :P
16:24:21 <JagaJaga> arkeet: I dunno, I have a problem - if a delete debug output - program works wrongly. So I thought that problem is related to laziness 
16:24:30 <magnapPrime> shachaf: I've never heard of that before. Enlighten me? What's its type?
16:24:43 <srhb> average: It's not really a GC thing in Haskell, usually.
16:24:43 <nshepperd> apart from that, GHC's gc reliably collects dead data, in my experience
16:24:44 <hpc> average: if it helps, you can assume the ghc gc is correct
16:24:54 <average> nshepperd: it sounds like you only did Haskell book problems so far
16:24:57 <arkeet> JagaJaga: using something like Debug.Trace?
16:24:59 <shachaf> retract :: Monad m => Free m a -> m a
16:25:00 <srhb> ...
16:25:34 <arkeet> JagaJaga: oh never mind what I just said.
16:25:36 <shachaf> average: See, *now* you seem hostile.
16:25:45 <JagaJaga> arkeet: just `print` :(
16:25:52 <arkeet> JagaJaga: there's an IO action to force evaluation of something using `evaluate`
16:26:13 <arkeet> @hoogle evaluate
16:26:14 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
16:26:14 <lambdabot> Control.Exception evaluate :: a -> IO a
16:26:14 <lambdabot> Control.OldException evaluate :: a -> IO a
16:26:22 <magnapPrime> Doesn't that "just" define the monad in terms of a free monad (which I admit to not understanding very well)?
16:26:43 <arkeet> magnapPrime: yes, but you can define free monads without defining monads.
16:26:49 <arkeet> just like how you can define lists without defining monoids.
16:26:57 <JagaJaga> arkeet: nice! Gonna try. Thank you.
16:27:22 <JagaJaga> arkeet: it's ok to use it inside StateT?
16:27:31 <JagaJaga> lift $ evaluate blabla
16:27:33 <JagaJaga> ?
16:28:07 <arkeet> sure.
16:28:08 <fosskers> arkeet, then how does one auto derive an Except{T}?
16:28:09 <nshepperd> average: to paraphrase what someone else said here, why ask if you aren't gonna believe the answer?
16:28:09 <arkeet> or liftIO
16:28:24 <arkeet> fosskers: it doesn't make sense to "derive ExceptT", because ExceptT is a data type, not a class.
16:28:29 <peddie> average: I think you should write a prototype and ask for help if the GC causes problems
16:28:39 <arkeet> fosskers: just use MonadError. nothing is deprecated about MonadError.
16:28:46 <arkeet> you are confusing it with ErrorT
16:29:34 <JagaJaga> arkeet: but generally, it's ok to use this function often?
16:29:35 <average> shachaf: I'm not sure you understand the motivation behind my questions. I'm not asking if "Hello World" will leak in Haskell or if FizzBuzz will leak memory in Haskell's GHC. I'm asking if a production-level web app will leak memory or not in Haskell. If you've ever actually deployed things in production, you would acknowledge their presence and you wouldn't dis them as if "Only fools can write leaky cod
16:29:35 <average> e" or some n00bish statement like that.
16:29:40 <arkeet> JagaJaga: it's not used often.
16:29:52 <arkeet> maybe you can use it to try and understand what your program is doing.
16:29:53 <JagaJaga> arkeet: thank you.
16:30:05 <magnapPrime> shachaf: I've reduced my problem to understanding why lists are a free monoid. I already get the "monoid of endofunctors over composition"
16:30:30 <magnapPrime> And BTW, thanks for being so civil and patient with me even though I make burrito jokes :)
16:30:48 <JagaJaga> arkeet: well, i have structure (like a tree) and one part of it is changed and one part isn't. If I add printing - everything is changed.
16:30:54 <average> shachaf: to be clear, I'm also not asking if your fancy-Monoid-0.1-seconds-running-time-Haskell-program will leak memory in Haskell
16:31:28 <hpc> it depends on the web app
16:31:35 <average> it fucking depends on the world
16:31:37 <average> Fuck you hpc 
16:31:40 <average> bye
16:31:45 <vdg> about e4x problem, there is a method of thinking so we can remember the position in the input buffer to return the next word in each call of doc_get_word ?
16:31:47 <srhb> wWhoa. :)
16:31:50 <nshepperd> good grief
16:31:51 <arkeet> what
16:31:56 <levi> Huh.
16:32:08 <JagaJaga> arkeet: changed print to evaluate -> didn't help :(
16:32:09 <hpc> he wasn't going to leave until he heard "ghc never keals"
16:32:14 <hpc> "leaks"
16:32:32 <arkeet> I'll keal you. ;(
16:32:49 <hpc> i vaguely remember someone from another network named keal
16:32:56 <fosskers> arkeet, thanks, I worked it out.
16:34:20 <ReinH> dcoutts: I found the coolest cabal bug yet!
16:34:32 <magnapPrime> shachaf,arkeet: Would it be correct to say that retract is to a free monad as a general fromList is to a list?
16:34:57 <shachaf> Probably not. fromList doesn't have much to do with monoids.
16:35:16 <shachaf> Maybe try mconcat.
16:35:34 <arkeet> mconcat is the thing yeah.
16:35:59 * hackagebot cubicbezier 0.3.0 - Efficient manipulating of 2D cubic bezier curves.  http://hackage.haskell.org/package/cubicbezier-0.3.0 (KristofBastiaensen)
16:36:23 <JagaJaga> arkeet: any ideas what can it be? :/
16:36:45 <arkeet> mconcat witnesses the fact that monoids are "free monoid" monad algebras
16:36:54 <arkeet> retract witnesses the fact that monad are "free monad" monad algebras
16:36:57 <arkeet> monads are
16:37:04 <shachaf> arkeet: In fact they're free monoid monad monad algebras.
16:37:14 <arkeet> yeah
16:37:40 <arkeet> my statement should be parsed like "free monoid" (monad algebra)
16:37:50 <Pamelloes> So I've defined a TemplateHaskell function in a module, but ghc won't let me use it as a top-level splice within that module. Is there any way around this without making a new module?
16:38:03 <arkeet> no.
16:38:16 <Pamelloes> :(
16:38:25 <magnapPrime> arkeet: thank you, I was having trouble parsing it. You read my mind ;)
16:38:25 <arkeet> because it would have to compile the module in order to compile the module.
16:38:25 <SrPx> When should I use the stateful setters and when should I use the pure ones?
16:38:39 <Pamelloes> arkeet: Huh. That makes a lot of sense.
16:38:43 <Pamelloes> Thanks :)
16:38:51 <arkeet> SrPx: from lens?
16:38:56 <SrPx> yes
16:39:04 <arkeet> use the stateful ones in a state monad.
16:39:21 <arkeet> :t (.~)
16:39:22 <lambdabot> ASetter s t a b -> b -> s -> t
16:39:23 <arkeet> :t (.=)
16:39:25 <lambdabot> MonadState s m => ASetter s s a b -> b -> m ()
16:39:30 <arkeet> they're rather different.
16:39:43 <SrPx> sure but if I'm programming some random thing, should I program my functions like `execState $ do { foo += ... }` or `foo ~= ...` ? Both do the same...
16:39:57 <SrPx> +~ *
16:40:06 <arkeet> use the one that's less noisy.
16:40:32 <arkeet> no need to introduce State just to use +=
16:40:35 <SrPx> so I only use the former if I am already on the state monad
16:40:38 <arkeet> mhm
16:40:39 <nshepperd> probably don't use execState if you're only doing a single operation. that would definitely be noisy
16:40:39 <SrPx> ah okay
16:41:08 <SrPx> ah nvm I see what you mean... 
16:41:09 <pacak> SrPx: You can Fortran  in any language, but why do that if you have Haskell?
16:42:22 <SrPx> ... I just wanted to zip two vectors ... oh well I went far on this one, I can't even recall my stack
16:42:49 <magnapPrime> SrPx: In arbitrary dimensions?
16:43:17 <kirill`> Is there a way to avoid duplicating build-depends fields in a cabal file?
16:43:18 <kirill`> I tried the idea in this answer: http://stackoverflow.com/q/10163604 but it didn't work (should it? it's kind of old)
16:43:58 <arkeet> kirill`: if your executable or whatever depends on a library in the same package,
16:44:02 <arkeet> they must have different src-dirs
16:44:04 <arkeet> source-dirs
16:44:16 <SrPx> yes I'm trying to rewrite this using lens http://lpaste.net/131796
16:45:28 <daganharrington> x
16:45:38 <kirill`> arkeet: I'll try that
16:45:51 <magnap`> shachaf,arkeet: I think I understand free monads now. How great! I don't grok them completely, but I understand them well enough for now. Thank you both for your help and patience
16:46:27 <SrPx> also about the other functions, the problem is that `scanl (+) 0 [1,2,3] == [0,1,3,6]` and `scanl1 (+) [1,2,3] == [1,3,6]` and what I really needed was a generic `foo (+) 0 [1,2,3] == [0,1,3]
16:46:28 <SrPx> hmm...
16:46:52 <arkeet> :t init
16:46:53 <lambdabot> [a] -> [a]
16:47:02 <arkeet> > init $ scanl (+) 0 [1,2,3]
16:47:04 <lambdabot>  [0,1,3]
16:47:14 <arkeet> > scanl (+) 0 (init [1,2,3])
16:47:16 <lambdabot>  [0,1,3]
16:47:22 <SrPx> arkeet: the problem is it has to be generic... that is, I can't write a generic scanl that will work with V2 and V3 because those have no concept of changing their sizes on the fly
16:47:30 <kirill`> arkeet: That works, thanks a lot
16:47:37 <pavonia> > scanl (+) 0 []
16:47:38 <lambdabot>  [0]
16:48:17 <arkeet> :t \l s -> partsOf l s %~ scanl (+) 0
16:48:18 <lambdabot> Num b => Traversing (->) ((->) s) ([b] -> Identity [b]) (Identity t) a a -> ([a] -> s -> [a]) -> s -> t
16:48:34 <arkeet> > (1,2,3,4) & partsOf each s %~ scanl (+) 0
16:48:36 <lambdabot>      Couldn't match type ‚ÄòIdentity b‚Äô with ‚Äò[b0] -> Identity [b0]‚Äô
16:48:36 <lambdabot>      arising from a functional dependency between:
16:48:36 <lambdabot>        constraint ‚ÄòEach ([b0] -> Identity [b0]) (Identity b) b b‚Äô
16:48:42 <arkeet> uh
16:48:45 <arkeet> I forget how to.
16:49:06 <arkeet> :t \l -> partsOf l %~ scanl (+) 0
16:49:07 <lambdabot> Num a => Traversing (->) Identity s t a a -> s -> t
16:49:10 <arkeet> > (1,2,3,4) & partsOf each %~ scanl (+) 0
16:49:11 <lambdabot>  (0,1,3,6)
16:49:51 <abhillman> > (+) 1 1
16:49:52 <lambdabot>  2
16:50:05 <abhillman> > putStrLn "HI"
16:50:06 <magnap`> :t partsOf
16:50:06 <lambdabot>  <IO ()>
16:50:07 <lambdabot> Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
16:50:31 <magnap`> :t (%~)
16:50:33 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
16:50:53 <abhillman> > getLine >>= putStrLn
16:50:55 <lambdabot>  <IO ()>
16:50:59 <Bluebottel> (-) 1 -1
16:51:18 <abhillman> :t unsafePerformIO
16:51:19 <lambdabot> Not in scope: ‚ÄòunsafePerformIO‚Äô
16:51:27 <mniip> abhillman, you can experiment with lambdabot in private
16:51:35 <magnap`> msg it
16:51:39 <abhillman> mniip: thx
16:51:57 <ion> lambdabot likes monosodium glutamate.
16:52:08 <magnap`> ion: ?
16:52:14 <magnap`> Oh, vm
16:52:15 <magnap`> *nvm
16:52:27 <magnap`> Clever joke
16:52:28 <phy1729> I read here earier that fromJust should almost never be used. How else should I write maxIndex xs = fromJust $ elemIndex (maximum xs) xs  ?
16:53:00 <mniip> phy1729, what should happen if xs is []
16:53:22 <phy1729> mniip: well in this case I know it never is
16:53:28 <mniip> then a fromJust is fine
16:53:39 <mniip> given 'maximum' already throws in case of an empty []
16:53:51 <mniip> er
16:53:52 <magnap`> phy: In the cases where it might be, you can use maybe
16:53:54 <magnap`> :t maybe
16:53:54 <mniip> in case of an empty xs
16:53:55 <lambdabot> b -> (a -> b) -> Maybe a -> b
16:54:00 <nshepperd> SrPx: traversal with a State!
16:54:06 <ion> phy1729: (\ ~(Just a) -> a) is a better fromJust
16:54:14 <schell> are you allowed to use $ quotation in a template haskell declaration? like [d| foreign import ccall safe ‚Äúobjc/objc.h objc_msgSend $fun |]   ? 
16:54:17 <SrPx> oh
16:54:39 <nshepperd> :t \xs -> evalState (traverse (\x -> get <* modify' (+x)) xs) 0
16:54:40 <lambdabot> (Num s, Traversable t) => t s -> t s
16:54:47 <schell> because I get a parse error
16:54:56 <mniip> ion, lazy patterns don't exactly work like that
16:54:58 <schell> wherever my first ‚Äú$‚Äù is
16:55:24 <schell> same goes with $(‚Ä¶)
16:55:36 <phy1729> magnap`: I really don't want a maybe since I think it'd complicate the code
16:55:41 <SrPx> arkeet: interesting... thank you... lmgt now
16:55:43 <ion> mniip: This irrefutable pattern isn‚Äôt about laziness, it‚Äôs about telling GHC you‚Äôre sure it‚Äôs a Just so it won‚Äôt complain about the missing Nothing case.
16:55:49 <Bluebottel> do i have to do something in particular to msg lambdabot?
16:55:55 <arkeet> :t scal
16:55:56 <lambdabot>     Not in scope: ‚Äòscal‚Äô
16:55:56 <lambdabot>     Perhaps you meant one of these:
16:55:56 <lambdabot>       ‚Äòscanl‚Äô (imported from Data.List),
16:55:56 <arkeet> :t scanl
16:55:57 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
16:55:58 <mniip> hm
16:56:08 <mniip> Bluebottel, /query lambdabot
16:56:22 <arkeet> evalState (traverse (\x -> get <* modify' (+x)) [1..4]) 0
16:56:24 <Bluebottel> mniip, ty
16:56:24 <arkeet> > evalState (traverse (\x -> get <* modify' (+x)) [1..4]) 0
16:56:26 <lambdabot>  [0,1,3,6]
16:56:50 <arkeet> that's kind of how partsOf works.
16:56:51 <magnap`> phy: if you know it won't matter then that's ok. But, if I understand it correctly, you can get GHC to verify that for you with the "irrefutable pattern match" that ion posted
16:57:26 <SrPx> nshepperd: intersting 
16:57:37 <abhillman> In general, is it bad to use (>>) and (>>=) when a do block will do for relatively long expressions?
16:57:42 <abhillman> * bad style
16:57:47 <phy1729> magnap`: interesting; I'll look into it later
16:57:52 <ion> GHC won‚Äôt verify anything here, (\ ~(Just a) -> a) just gives a more helpful error message than fromJust when your assumption fails and you need to debug it.
16:58:10 <nshepperd> oh, I didn't realise the list conversion with partsOf was two-way, that's pretty magical
16:58:26 <nshepperd> makes sense though
16:58:50 <arkeet> > (1,2,3) ^. partsOf each
16:58:52 <lambdabot>  [1,2,3]
16:59:15 <arkeet> > (undefined,undefined,undefined) & partsOf each .~ [1,2,3]
16:59:17 <lambdabot>  (1,2,3)
16:59:43 <arkeet> if you give too many elements it will ignore them
16:59:50 <arkeet> if you give too few it will just leave the rest unchanged
16:59:59 <magnap`> arkeet: Code like that is why people think Haskell is magical / has implied structure
17:00:02 <shachaf> That's why you want unsafePartsOf.
17:03:46 <magnap`> This channel is so awesome. In the last few hours I've learnt about and/or understood several new (to me) Haskell concepts. Thank you all!
