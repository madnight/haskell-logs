00:02:00 <deezn> can someone explain the difference between an io function and an io action please?
00:03:32 <kadoban> deezn: An IO action is probably the more correct term for "IO function", unless you mean something like: bar :: a -> IO b, I guess that could correctly be kinda referred to as an IO function.
00:03:57 <deezn> foo1:: FilePath -> FilePath -> IO ()
00:04:03 <deezn> foo2:: IO ()
00:04:10 <Axman6> deezn: a function is something which accepts an argument
00:04:18 <Axman6> so foo :: IO () is not a function
00:04:27 <frerich> deezn: An IO action is a value of type 'IO a', e.g. 'getLine'. I don't remember having heard the term 'IO function' before, but I'd guess it's a function which yields an IO action, e.g. 'putStrLn :: String -> IO ()'.
00:04:46 <Axman6> but foo2 :: String -> IO () is a function, which takes a string and returns an IO 'action' (for lack of a better term)
00:04:58 <EvanR> IO function is slang for something like A -> IO B
00:05:29 <EvanR> its not any different from any other kind of function
00:06:39 <deezn> ok thanks guys I will keep reading up on it. 
00:10:31 <EvanR> functions, "IO" or not, can't actually do IO in haskell. they are pure
00:10:54 <EvanR> IO actions do the IO when executed
00:13:16 <solatis> EvanR, well what i actually want, i think, is to make a general type that means 'this is convertable to and from hex'
00:13:24 <solatis> so i think i'll just make a new typeclass out of it
00:13:27 <deezn> Here is what I was missing: I/O actions will only be performed when they are given a name of main or when they're inside a bigger I/O action that we composed with a do block. 
00:13:37 <solatis> so you can have instance HexString FooData where ...
00:13:42 <EvanR> solatis: but "hex" is a way to represent binary right?
00:13:58 <EvanR> so theres only one algorithm for converting binary to hex and back
00:14:02 <EvanR> or you only need one
00:14:23 <EvanR> how to convert to binary (Binary) is the thing which is type-specific
00:15:14 <EvanR> otherwise HexString is just a giant copy of all the Binary instances just with 16 new codes for nibbles
00:15:29 <solatis> hmmm you might be right and i might be overthinking/overengineering it
00:15:31 <EvanR> which is the same for all instances
00:16:24 <solatis> but there are a few components which always needs to be glued together it seems
00:16:28 <solatis> or is it..
00:16:32 <solatis> hmm, i think i know!
00:17:01 <solatis> instead of having a function that converts a ByteString (binary) to a String, have a function that converts a Binary a => a -> String 
00:17:27 <EvanR> toHex :: Binary a => a -> String, or more likely -> Text
00:17:36 <EvanR> toHex :: Binary a => a -> Text
00:17:37 <solatis> yes exactly
00:17:59 <solatis> ok, i was clearly overthinking this
00:18:21 <EvanR> this would be a good usecase for an Ascii type which is sufficient for hex
00:18:49 <EvanR> would have a more efficient implementation for what its doing (i.e. encoding is a no op)
00:19:02 <solatis> isn't ascii deprecated ?
00:19:12 <solatis> at least, when i do decodeASCII with Text, i get a deprecated error
00:19:27 <solatis> i think the closest thing to ascii is ByteString.Char8
00:19:30 <EvanR> i dont know what decodeASCII has to do with it
00:19:49 <EvanR> yeah ByteString Char8 will get the performance its just not as correct
00:20:20 <EvanR> the fact that your ByteString is actually text encoded as ascii is not represented by the types
00:20:39 <__ryan> hi does anyone know how to use rss in yesod? thank you in advance
00:22:11 <Axman6> __ryan: did you look at https://hackage.haskell.org/package/yesod-newsfeed-1.4.0.1 ?
00:22:46 <EvanR> solatis: another way to deal with ByteStrings that have some text or other encoding is to newtype it and use smart constructors to "ensure" thats what it contains
00:22:48 <Axman6> __ryan: also, if you haven't, please try googling your question before asking in here
00:23:21 <solatis> EvanR, ah that's what i want to use, i think
00:23:34 <solatis> to make my newtype HexString which guarantees the range of the chars
00:23:55 <EvanR> toHex :: Binary a => a -> HexString
00:24:15 <__ryan> Axman6: yes i look at it already - just want some help how to start with it.. sorry
00:25:05 <EvanR> solatis: but this function might not be as generally usable as a toHex :: ByteString -> HexString, and then composing the Binary encode method with the toHex, which is what i originally suggested
00:25:45 <solatis> EvanR, toHex :: B.Binary a  => a -> T.Text
00:25:45 <solatis> toHex = TE.decodeUtf8 . BSL.toStrict . B.encode
00:25:58 <solatis> that's what i have now and that works pretty sweet out of the box
00:26:20 <EvanR> thats probably too complex
00:26:52 <solatis> well it's actually this:
00:26:53 <solatis> toHex = TE.decodeUtf8 . BSL.toStrict . BS16L.encode . B.encode
00:27:09 <solatis> BS16L.encode converts "binary" ByteStrings to "hex" ByteStrings
00:27:18 <EvanR> well if you go with the newtype HexString thing you dont have to deal with utf8 at all, which really is irrelevant to the problem
00:27:28 <solatis> yep it is
00:27:46 <solatis> first get this working properly, then refactor
00:27:52 <Axman6> __ryan: it looks pretty simple to me, you newed to create a list of FeedEntry's for the pages you want to link to, create a Feed containing that list and the appropriate fields, and then you return the TypedContent returned by newsFeed or newsFeedText in your handler
00:28:08 <EvanR> and once the ByteString -> HexString and its (partial or Maybe) inverse is implemented, then the Binary function is just a composition of two functions, not four
00:28:33 <EvanR> well, total because you will "prove" HexString is always valid
00:29:10 <solatis> yes that's exactly what i'm looking for, a way to use haskell's type system that HexString is a range of characters which are [0-f]
00:29:31 <EvanR> well the smart construct is probably less of a headache than doing that
00:29:36 <EvanR> smart ctor
00:29:37 <Axman6> __ryan: #yesod might be a better palce to ask (but it will take longer for you to get a response)
00:29:55 <solatis> EvanR, i'll look into that
00:30:09 <__ryan> Axman6: thank you i will try thank very much.
00:31:19 <Zemyla> Why does fmap runST not work?
00:31:24 <Zemyla> :t fmap runST
00:31:25 <lambdabot>     Couldn't match type ‘a’ with ‘forall s. ST s b’
00:31:25 <lambdabot>       ‘a’ is a rigid type variable bound by
00:31:25 <lambdabot>           the inferred type of it :: f a -> f b at Top level
00:37:45 <nshepperd_> I think because that requires `f (forall s. ST s b)` which is ImpredicativeTypes
00:37:54 <nshepperd_> and impredicative basically doesn't work
00:38:02 <Zemyla> So you need to wrap it with a newtype or something.
00:40:02 <nshepperd_> yeah. before you put it into whatever f is
00:40:33 <NicX> I used the openURIString function from http://hackage.haskell.org/package/download-curl-0.1.1/docs/Network-Curl-Download.html to download some csv data and now want to write that data to a csv file. What does it mean for something to have type (Either String String)? How do I turn my (Either String String) data into a String that can be written with writeFile? The Network-Curl-Download URL above once linked to information about Either but tha
00:40:36 <NicX> t link is now stale. I don't think that the functions at https://hackage.haskell.org/package/base-4.2.0.1/docs/Data-Either.html#t%3AEither are relevant, but I'm just learning haskell and have never seen Either before.
00:44:36 * hackagebot optparse-simple 0.0.2 - Simple interface to optparse-applicative  http://hackage.haskell.org/package/optparse-simple-0.0.2 (ChrisDone)
00:46:32 <kadoban> NicX: Are you familiar with Maybe, by any chance?
00:47:25 <NicX> kadoban: little
00:47:46 <NicX> I used it last summer but will need to re-read things
00:49:11 <kadoban> Maybe a   means "You might have an 'a', or if the operation that resulted in it failed, I got nothing".   One (quite common) way of looking at  Either a b  is .. like Maybe b, but you can have an error message instead of just "Nothing" when something goes wrong.
00:49:36 * hackagebot stackage 0.7.0.0 - Dummy package forcing installation of other Stackage packages  http://hackage.haskell.org/package/stackage-0.7.0.0 (MichaelSnoyman)
00:50:27 <kadoban> NicX: So, that's /probably/ what you have there.   Left "Crap, download failed"      or   Right "<some downloaded data>"    That's what Either String String probably means, if that helps.
00:56:02 <NicX> kadoban: I think you're right, the Data.Either documentation seems to say the same. Assuming the download had no errors, how do I access the Right data? I see that the rights function expects [Either a b] but I only have a flat Either a b.
00:56:45 <Mishac> Hi Guys, can i ask a quick question
00:57:35 <Mishac> really quick question
00:57:36 <kadoban> NicX: It depends on the context I guess. The most direct way is to pattern match and handle 'Left foo' differently from 'Right bar'.  The 'bar' there would be your downloaded data.
00:58:24 <kadoban> NicX: There's often some cute way to use 'either' or "|||" or something to make it shorter/easier, but … it comes down to pattern matching eventually.
00:59:33 <kadoban> :t either
00:59:34 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
01:00:52 <kadoban> (By the way,   either id id     would satisfy the type system at least, but is pretty unlikely to be a good idea, since it would entail writing out (or whatever you're doing with it) error messages instead of data when there's an error, with no way to differentiate)
01:06:01 <NicX> kadoban: sorry, I can't seem to figure this out. Can you show me an example of how to go from  Either String String  to  String? I got excited when I tried printing   Right doc  but found the type was Right doc :: Either a (Either String String)
01:07:59 <kadoban> NicX: Well, you probably /can't/ sanely go directly from Either String String to String, without doing a minorly evil thing. What is your goal, like what are you going to do with the String from successful downloading?
01:08:34 <NicX> Basically I just want to call   writeFile "foo.csv" myStringOfData
01:10:25 <kadoban> :t either putStrLn (writeFile "foo.txt")
01:10:26 <lambdabot> Either String String -> IO ()
01:11:03 <kadoban> NicX: ^  that function, given an  Either String String will print the error message to the user, or output to the file, whichever applies. Does that make any sense?
01:12:47 <NicX> kadoban: my question with that is: what about the data?
01:13:23 <NicX> snap, I think I got it
01:13:40 <kadoban> NicX: If there's data, it's output to the file.  The 'either' function takes two arguments, one is what to do with a Left, the other is what to do with a Right
01:14:45 <glguy> The basic way to deal with an Either is to use a case expression
01:15:34 <NicX> sweet I wrote the data to a file
01:15:44 <kadoban> :)
01:22:12 <solatis_> so, back to bikeshed.. is there a GHC extension to do '(48 <= foo < 58)' already ? :)
01:22:56 <kadoban> If there is, I hope it's called PythonComparisons
01:23:31 <solatis> haha
01:23:56 <solatis> https://wiki.haskell.org/Comparison_chain
01:24:16 <solatis> i like how there always is a way to completely over-engineering anything in haskell
01:25:31 <kadoban> Hah, wow
01:27:25 <solatis> hmm if I only want to allow construction of a certain newtype or data through my special 'smart' constructor, what are my options, if any ?
01:27:54 <solatis> similar to OOP's technique of wrapping a class around a specific data object, I want to wrap my constructor around a ByteString
01:28:11 <kadoban> solatis: Throw it in a module, don't expose any ways to construct the type except your favored one(s)
01:28:19 <solatis> and make sure that my type of ByteString (a HexString) always has characters constructed within a range
01:28:38 <solatis> kadoban, but then someone can still do 'HexString (B.pack "foo")', right ?
01:28:51 <solatis> or you're talking about not-exporting HexString
01:29:08 <kadoban> solatis: Not if you don't export that value constructor.
01:29:12 <solatis> right
01:29:19 <solatis> so no HexString(..)
01:29:51 <solatis> of course, this question was way too simple
01:30:26 <kadoban> You can still have the type available outside, just not the value constructor.  So yeah, no HexString(..), just HexString() in the export list I think might be the syntax … or is it just HexString
01:30:38 <solatis> yeah i understand
01:31:03 <solatis> I think HexString() exports the type, HexString(..) exports type and constructors
01:31:18 <tdammers> HexString alone, without the parens, exports only the type
01:31:39 <tdammers> HexString (..) exports the type and all constructors
01:32:06 <tdammers> HexString ( Something ) exports the type and the "Something" constructor
01:32:18 <solatis> thanks
01:32:25 <tdammers> HexString ( hexStringField ) would export the type and a record field, if you had any
01:32:37 <solatis> i don't want to allow access to those
01:32:46 <tdammers> probably not, no
01:49:39 * hackagebot stackage-cli 0.0.0 - A CLI library for stackage commands  http://hackage.haskell.org/package/stackage-cli-0.0.0 (ChrisDone)
02:20:02 <manjunaths> Hello
02:20:15 <jle`> hi manjunaths :D
02:20:20 <manjunaths> In the haskell shell like implementations
02:20:32 <manjunaths> Strings have to be enclosed in " "
02:21:07 <manjunaths> Is it possible to default everything to Strings so that one doesn't have to type " " everytime ?
02:24:08 <frerich> manjunaths: I.e. in '1 + 2', both 1 and 2 should be treated as stirngs and you'd expect a type error?
02:24:40 * hackagebot convertible 1.1.1.0 - Typeclasses and instances for converting between types  http://hackage.haskell.org/package/convertible-1.1.1.0 (NicolasWu)
02:25:03 <manjunaths> Not really + takes numbers, but everytime enclosing everything in string is a pain
02:25:12 <manjunaths> cd "/usr/src/"
02:25:18 <manjunaths> That is a pain
02:29:11 <frerich> manjunaths: If I did 'cd bin', how could I tell whether 'bin' is supposed to be a literal stirng as opposed to a definition like 'bin = "something"'?\\
02:29:49 <fractalsea> I have a multithreaded (using STM) real world application, and after running it for a week or so it ends up using gigabytes of RAM. When I’m testing it now, I see the memory usage increase by about 20KB every 10 mins. Does anyone have any suggestions on tools or approaches I can use to track the problem down? Anything would be better than just reading the source code and hoping to spot it…
02:31:21 <frerich> fractalsea: Gigabytes of RAM sounds a lot. At 20KB/min you should be somewhere around 20MB per week, no?
02:32:14 <fractalsea> frerich: It may not be increasing linearly. Also it might not be quite that much, I can double check…
02:33:34 <merijn> fractalsea: Profiling?
02:33:37 <frerich> fractalsea: I don't know too much about profiling, but I successfully generated heap usage graphs as described on http://book.realworldhaskell.org/read/profiling-and-optimization.html 
02:33:44 <frerich> fractalsea: That may shed some light.
02:34:07 <kadoban> fractalsea: I don't have a lot of experience with that kind of thing, but https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/prof-heap.html looks topical.
02:34:26 <Svajoklis> Hi :)
02:34:36 <fractalsea> Great. Thanks for those suggestions guys. I will give them a read
02:46:59 <Lis> hello everyone. i have two lists. [1..4] and [5..9] i want to take element n-1 from list a and multiplicate it with elment n of list b. how could this be done? zipWith (*) (drop 1 a) b ?
02:47:48 <tulcod> dmwit: ping
02:49:12 <merijn> Lis: That zipWith would work, yeah
02:49:36 <merijn> I'm not sure what the question is? Considering you could just test that in ghci?
02:49:41 * hackagebot mtl-c 0.1 - Very strict CPS'd transformers  http://hackage.haskell.org/package/mtl-c-0.1 (FumiakiKinoshita)
02:49:59 <Lis> ty
02:50:53 <Lis> merijn, i was just looking for a "default" way to do it. since there are many list definitions in haskell like list comprehension etc.
02:53:59 <frerich> Lis: You could shorten 'drop 1 a' to just 'tail a'.
02:55:38 <zaquest> isnt tail considered unsafe?
02:56:02 <slomo> frerich: they are not exactly the same though, tail [] is not the same as drop 1 []
02:56:51 <frerich> Right, but my suspicion was that 'zipWith (*) (drop 1 a) b' may not actually do what's expected in case 'length a == 1' holds.
02:58:21 <merijn> frerich: It does the only sensible thing
02:58:26 <merijn> Whereas tail crashes
02:59:41 <frerich> merijn: The task is to take element n-1 from list a and multiply it with element n of list b. What sensible behaviour is there if 'a' is only one element in size? I think the funciton is plain undefined for that case, so the situation should be caught by the caller.
03:00:15 <frerich> That's just a gut feeling though, dropping elements from 'b' may be just fine depending on what you want, of course.
03:01:56 <merijn> frerich: Since the function is returning a list of results an empty list already covers the error case
03:02:12 <merijn> Which is what drop will result in
03:05:54 <wz1000> Would deleting .cabal and .ghc be enough to wipe all my packages?
03:06:21 <frerich> merijn: I guess that's an alternative point of view: accepting lists which are too short but using the empty list as the error value. My position was that the funciton is undefined for lists of the wrong size, so the input types could enforce that already (think NonEmpty) which in turn means using 'tail' is fine.
03:07:19 <oherrala> wz1000: that's how I do it. but backup your .cabal/config if you have customized it.
03:07:26 <frerich> merijn: I guess my approach really only works if you have dependent types, no wthat I think about it. :-(
03:14:43 * hackagebot hexstring 0.10.0 - Fast and safe representation of a hex string  http://hackage.haskell.org/package/hexstring-0.10.0 (solatis)
03:19:43 * hackagebot gll 0.1.0.0 - GLL parser with simple combinator interface  http://hackage.haskell.org/package/gll-0.1.0.0 (ltvanbinsbergen)
03:23:38 <wz1000> Installing the latest version of ghcmod fails with "Not in scope: data constructor ‘ExposePackageId’" with cabal-install.
03:25:53 <quchen2> wz1000: Known issue. There's a fork that fixes this, it'll be merged "soon".
03:26:25 <quchen2> I had the same problem and asked in the corresponding issue thread on Github.
03:27:16 <wz1000> quchen2: I just found that. Apparently its now fixed in master repo
03:27:17 <quchen2> https://github.com/kazu-yamamoto/ghc-mod/issues/437
03:27:26 <quchen2> Ah, good to know.
03:33:53 <wz1000> Why is "absurd" defined the way it is? Would absurd = undefined not suffice?
03:34:18 <wz1000> Or const undefined
03:37:54 <supki> wz1000: to throw the right exception, probably
03:39:17 <supki> that is, I'd expect the evaluation of  absurd (error "foo")  to result in  *** Exception: foo
03:48:23 <quchen2> supki, wz1000: Yes, that's the reason. If you're talking about the "spin" thing.
03:49:22 <wz1000> quchen2: So why not "absurd a = a `seq` error "Unreachable""
03:51:16 <quchen2> That might evaluate seq's second argument first.
03:53:42 <quchen2> wz1000: seq x y = y if x /= ⊥, seq x y = ⊥ if x == ⊥. So the compiler might evaluate the second argument first because it can.
03:54:18 <quchen2> cf https://github.com/quchen/articles/blob/master/fbut.md#seq-does-not-specify-an-evaluation-order
03:54:35 <wz1000> Ah
03:55:25 <quchen2> GHC will probably evaluate seq's first argument fisrt, but that is not guaranteed. In particular, chained seqs can be shuffled around.
03:55:43 <quchen2> All you have to preserve is the semantics I mentioned above, so there are plenty of possible transformations.
03:56:46 <quchen2> Oh, the new Data.Void.absurd uses an empty case
03:57:04 <quchen2> Anyway, gotta go.
03:58:23 <lolisa> I just get on line, are you guys Talking about why non strict language dont have sum or product type stuff?
04:10:52 <arbelos> If I want to use a TVar inside Scotty, how should I layer the monad stack?
04:21:48 <amaru> Hi! I'm not too familiar with type level nats, but I've been playing around a bit recently with them in the context of fixed size vectors and matrices.
04:23:08 <lf94> Is there a way to run "freopen" in Haskell?
04:23:12 <lf94> s/run/call/
04:23:34 <amaru> And I'm just wondering: why can't KnownNat (a*b) be inferred from (KnownNat a, KnownNat b)? 
04:27:09 <freinn> hi! I've written this code http://lpaste.net/131033 and I don't know where to see how this data type is defined
04:27:28 <freinn> where can I see that and make this code work??
04:28:06 <ChristianS> amaru: hmm, would you expect KnownNat (a/b) to work?
04:28:40 <amaru> That's not necessarily a nat though
04:29:07 <hpc> that's not necessarily even defined
04:29:10 <hpc> 0 is a nat
04:29:20 <amaru> But + * ^ are all closed
04:30:17 <ChristianS> amaru: yes, but type inference doesn't know the semantics of individual operators
04:30:31 <ChristianS> methinks
04:30:47 <nshepperd_> * is a type family, so you couldn't write any ordinary instance declaration for that
04:30:57 <ion> lf94: You can call anything via FFI although it may be a different problem to integrate that with Handles and stuff.
04:31:03 <amaru> true. But does it have to know the semantics to say that given two known nats, the product is also a nat that can be computed? 
04:32:00 <ion> freinn: Which data type? (->) a b?
04:32:09 <ChristianS> amaru: yes. that's how i would understand "semantics"
04:32:27 <freinn> yes
04:36:37 <freinn> ion: yes
04:37:12 <dbushenko> hi all!
04:37:23 <dbushenko> can anyone help me with this simple gist: https://gist.github.com/dbushenko/4d8b68d682acbfa635c2
04:37:40 <dbushenko> just 2 lines of code, but it can't compile with following error:
04:37:51 <dbushenko> No instance for (MonadIO m0) arising from a use of `mapStore_'
04:37:53 <pavonia> freinn: "(->) a b" is an alternative form of "a -> b" which is the built-in function type in Haskell
04:38:08 <dbushenko> mapStore_ :: (Ord k, MonadIO m) => IO (SessionStore m k v)
04:38:45 <amaru> ChistianS: Just knowing that the operators are closed does not feel like knowing much of their semantics ..
04:39:25 <pavonia> dbushenko: It can't infer what instance of MonadIO to use for store because you do nothing with that value
04:40:11 <amaru> It would be a very nice feature though! Now i have to write lots of constraints with loads of language pragmas to allow them.
04:40:20 <pavonia> dbushenko: You could give an explicit type annotation like mapStore_ :: IO (SessionStore IO Int String) or whatever
04:41:16 <dbushenko> pavonia: let me try...
04:42:27 <freinn> pavonia: yes, but how can I create a data type like (->) a b, and make it instance of functor???
04:42:52 <pavonia> You don't create it, it's already there
04:44:18 <pavonia> It's the type of functions from one type to another, probably the most basic data type of the language
04:44:46 <dbushenko> pavonia, no luck...  have a look: https://gist.github.com/dbushenko/a0ff5e3b99992e51acf8
04:45:04 <freinn> pavonia: so I can't create it?? anyway?? So this exercise can't be solved getting code to compile
04:45:41 <brbblnch> Hi
04:46:05 <pavonia> dbushenko: No, you need to give concret types, "SessionStore m k v" is even less specific than "(MonadIO m, Ord k) => SessionStore m k v"
04:46:27 <dbushenko> ok, let me try again...
04:46:48 <pavonia> freinn: What exercise?
04:47:24 <brbblnch> The constructor for "there exists a \beta such that A" in System F is: ∃β.A ⇐⇒ ∀α.(∀β.(A → α)) → α . How is that intuitively true?
04:47:38 <freinn> pavonia: https://wiki.haskell.org/Typeclassopedia the first exercise in there
04:52:14 <pavonia> freinn: It asks for an instance implementation, that is the implentation of fmap. You don't need to create a data type for this
04:53:10 <pavonia> freinn: Can you give the conrete type of fmap for this instance?
04:53:16 <pavonia> *concrete
04:54:20 <freinn> pavonia: fmap :: (a -> b) -> (r -> a) -> (r -> b)
04:54:55 <freinn> pavonia: I know I need function composition, but I can't create a data type for doing that effectivily in code
04:55:30 <pavonia> Oh wait, I just saw that implementation is already correct
04:55:37 <freinn> pavonia: I paste you the complete code http://lpaste.net/131035
04:56:25 <pavonia> Hhm, what is the problem you are having?
04:56:57 <freinn> how can I create
04:57:14 <freinn> a data type that works like (r -> a)?
04:57:34 <pavonia> Why? You already have one?
04:57:54 <freinn> yes
04:58:01 <freinn> is only for learning purpose
04:58:11 <pavonia> Okay
04:58:19 <freinn> I have to make this type instance of Functor typeclass
04:58:28 <freinn> but it is already, so I can't
04:58:30 <pavonia> You could define "data Function a b = Function a b"
04:59:22 <safinaskar> is this true that if pattern matching in do fails then "fail" will be called?
04:59:30 <safinaskar> *in "do"
04:59:33 <pavonia> Or with type operators even "data a :-> b = a :-> b", I think
05:00:31 <lyxia> safinaskar: That's right.
05:02:15 <freinn> okay, but this may not seems to work
05:02:16 <safinaskar> > do { Nothing <- return $ Just (); return (); } :: Either String ()
05:02:17 <lambdabot>  *Exception: Pattern match failure in do expression at <interactive>:3:6-12
05:02:28 <safinaskar> lyxia: okey, so why "fail" is not called in this example?
05:02:53 <safinaskar> lyxia: i think "fail" should be called. in this example "fail" is "Left", so i should see "Left". why i don't see it?
05:03:31 <pavonia> > fail 1 :: Either String Int
05:03:32 <lambdabot>      No instance for (Num String) arising from the literal ‘1’
05:03:33 <lambdabot>      In the first argument of ‘fail’, namely ‘1’
05:03:33 <lambdabot>      In the expression: fail 1 :: Either String Int
05:03:42 <pavonia> > fail "1" :: Either String Int
05:03:43 <lambdabot>  *Exception: 1
05:03:59 <amaru> safinaskar: https://hackage.haskell.org/package/base-4.8.0.0/docs/src/Data-Either.html#line-137
05:04:22 <lyxia> Oh, fail in Either raises an exception.
05:05:05 <lyxia> It wouldn't make sense otherwise if Left contained anything other than a String...
05:06:36 <safinaskar> is there something like "Either String", but with "fail == Left"?
05:06:47 <quchen2> fail is bad and you should not use it.
05:07:17 <quchen2> Many monads don't have a "fail" function that works, so using it means your functions break unexpectedly.
05:08:32 <amaru> safinaskar: Control.Monad.Error from the mtl package seems to have this functionality.  
05:08:55 <quchen2> When you're in a non-monad-polymorphic do block which is guaranteed to have a working fail, then you might argue you can use it. My advice is to stay far away from it if you can.
05:19:29 <safinaskar> thanks
05:20:47 <merijn> Join my campaign to make fail require MonadZero :p
05:21:21 <haasn> Join my campaign to abuse fail for code golf
05:21:31 <quchen2> Join my campaign to shame haasn :-þ
05:22:30 <merijn> Why do you need fail for code golf?
05:24:49 * hackagebot hledger-diff 0.2.0.3 - Compares the transactions in two ledger files.  http://hackage.haskell.org/package/hledger-diff-0.2.0.3 (gebner)
05:24:51 <haasn> merijn: pattern matches inside list comprehensions and Maybe-do blocks, mainly
05:24:59 <haasn> And.. uh, I guess that's the only use case I have
05:25:05 <haasn> Since those are the only two monads where fail really makes sense
05:27:31 <mniip> ski, you there?
05:28:02 <mniip> also join my campaign for fundep signatures!
05:30:34 <merijn> haasn: Pattern matches inside list comprehensions don't use fail
05:31:00 <haasn> Oh, right. Just do blocks in [] would require it
05:31:21 <merijn> haasn: fail makes plenty sense in parsers and any MonadZero/MonadPlus instances
05:31:42 <quchen2> merijn: Except STM, which is MonadPlus but not MonadFail
05:31:51 <merijn> quchen2: Still makes sense there
05:31:57 <merijn> quchen2: "fail _ = retry"
05:31:58 <haasn> Oh, good catch. do Foo x <- someTokenTypeThingy <?> "foo" -- like this I guess
05:32:18 <haasn> I wonder if that error message thing makes sense there. Maybe, maybe not
05:32:26 <quchen2> merijn: That would work, but might lead to always retrying computations implicitly.
05:32:42 <merijn> I'd support MonadFail too, MonadZero just seems more elegant
05:33:08 <haasn> quchen2: Presumably, that would be the intended/expected behavior - if the pattern match fails, we *should* be retrying it whenever the values change, no?
05:33:37 <quchen2> haasn: Sure, but then it assumes that the computation will at some point give you the right pattern, which may never happen
05:34:50 <haasn> The same is true for ‘guard’ and other things where there may not necessarily be the assumption that it actually *would* succeed if we keep retrying
05:35:19 <haasn> But it can have use cases; eg. Just x <- acquireLock
05:36:46 <quchen2> Not having fail there avoids that pitfall. I think such a case asks for explicit code instead of implicit failing.
05:37:31 <kaidelong> is stackage and ghc 7.10 mutually exclusive?
05:37:39 <nshepperd_> hmm. sometimes I use 'Just x <- foo' or the like to document that the value "should always" be Just. implicitly hoping an exception will be thrown if it's not
05:38:26 <nshepperd_> retry semantics breaks that plan, I guess
05:38:59 <haasn> nshepperd_: fromMaybe (error "exception") is *always* a better way to crash and burn on highly illegal input
05:39:04 <merijn> kaidelong: Since stackage is about stable buildplans and ghc 7.10 is only just out I would expect them to not play nice for a while, yes
05:39:08 <haasn> Because that way you can provide a real reason
05:39:32 <quchen2> haasn: Even better is a case match because that gives you its location in the error iirc
05:39:34 <kaidelong> merijn: thank you
05:39:43 <kaidelong> I guess that means I'm not making the switch yet
05:39:49 <StrangeLoop> Hi, a soft question. I am taking a Haskell class, and for grade we need to do a project. We are at liberty to choose a project, where the only description of its scale is "something that a pair of you can do in about 20 man hours". Do you have any idea for a nice project of this scale?
05:40:08 <haasn> StrangeLoop: IRC bot!
05:40:16 <StrangeLoop> Hmmm...
05:40:17 <marchelzo_> StrangeLoop: Lisp interpreter. It's a classic.
05:40:41 <StrangeLoop> I wanted to write a "math dissasembler" :p
05:40:45 <kaidelong> StrangeLoop: is there any particular library or technique you're hoping to explore?
05:40:52 <marchelzo_> StrangeLoop: Then do it.
05:41:00 <exio4> StrangeLoop: what would that do? sounds like a cool project!
05:41:08 <marchelzo_> StrangeLoop: There's no better idea than the one you came up with yourself.
05:41:10 <merijn> StrangeLoop: Depends on your experience in general
05:41:23 <haasn> Write a “math reassembler”. It takes as input any equation and reassembles it into another equation that may or may not be related to the former in any meaningful way.
05:41:30 <merijn> StrangeLoop: i.e. if you have some experience with compilers you could easily write a simple compiler in that time
05:41:38 <hodapp> haasn: so... math salad?
05:41:49 <StrangeLoop> Well, I thought about something like that: It would "break" any mathematical term in it and it breaks it into definitions, up to the "set" level.
05:41:57 <StrangeLoop> It would be a toy, obviously, but could be a cool toy
05:42:31 <merijn> Sounds like it should work, depending on how you complex you make it
05:42:41 <kaidelong> well that doesn't sound like 20 hours worth of programming time
05:42:46 <haasn> StrangeLoop: another idea for a small scale “get to know the language” would be a web-based URL shortening service
05:42:54 <StrangeLoop> Thing is, I want to make it a website. Where people could add new definitions comprised of existing ones, etc. Thing is, I don't know how involved it is to make a webapp with Haskell
05:42:55 <kaidelong> it'd mostly be making a dictionary of math terms
05:42:57 <hodapp> I don't know how obvious it would be that it's a toy. Coq, for instance, does something rather like this.
05:43:00 <merijn> kaidelong: Depends on how comfortable you are with haskell :p
05:43:01 <kaidelong> and writing a small program to reference it
05:43:26 <kaidelong> mmm well
05:43:34 <kaidelong> the website sounds like too much
05:43:34 <merijn> StrangeLoop: We've got plenty of web frameworks by now, ranging from the minimal to yesod :p
05:43:41 <kaidelong> but maybe make a local one first
05:43:50 <kaidelong> and then if you have time left over, adapt it as a web service
05:44:11 <haasn> StrangeLoop: One similar toy I've made a while ago was a thing that takes as input an expression in a basic language (eg. something similar to the lambda calculus or maybe something inspired by lisp) with a few base definitions and breaks it down into a single string of only S and K combinators
05:44:24 <haasn> sort of like a “programming language disassembler”
05:44:31 <haasn> or assembler. Whatever
05:44:50 <StrangeLoop> Sounds similar
05:45:29 <haasn> The good thing about that project is that you can shift the amount of time needed arbitrarily by making your “input language” more and more complex (or adding more layers to it, eg. X -> Y -> lambda calculus -> SK)
05:46:00 <haasn> And it's a nice introduction to using Haskell for parsing and compilers (code translation) in general
05:46:09 <StrangeLoop> Yeah, I want it to be gradual. Otherwise the size of terms would be grow unmanageable very quickly
05:46:41 <wz1000> Can anybody help me with this error(http://lpaste.net/131036) while trying to install ghc-parser
05:47:00 <StrangeLoop> I mean, do you know how much words do you need to completely define "a topological space" using nothing but sets? Well, neither do I, but I am really interested in these kinds of statistics :)
05:47:30 <hodapp> yeahhhh, partly the fault of sets
05:48:38 <haasn> How many sets would you need? :p
05:49:06 <StrangeLoop> Well, yeah. But its not like you can just teach undergrads topology starting with locales
05:50:24 <haasn> StrangeLoop: One interesting thing could be coming up with an efficient representation for these kinds of trees
05:50:42 <haasn> eg. if you use “Int” in 10,000 places - you shouldn't store 10,000 copies of the definition of “Int”
05:50:51 <haasn> It would have to be some kind of DAG
05:51:17 <haasn> Could do that for the SK / lambda calculus stuff as well
05:51:25 <haasn> Share common subterms
05:52:33 <safinaskar> i just read that "return" and monad bind are always non-strict
05:52:36 <safinaskar> why?
05:57:24 <haasn> safinaskar: “return” being non-strict can probably be shown by observing the monad laws for ‘return’ and how it interacts with bind
05:58:41 <safinaskar> haasn: thanks
05:58:57 <fractalsea> I am trying to profile my program with +RTS -hc -P. When I run it though, I can’t seem to close it with Ctrl+c. When I kill it, there is no data written to myprog.prof. Anyone know how to fix this?
05:59:33 <geekosaur> there is no fix, profiling information is written out only on normal program exit
05:59:35 <haasn> safinaskar: You have to be careful about how to parse these things, though. Perhaps the author of that statement meant something different than what I'm interpreting into it. Especially for ‘bind’. (Incidentally, I can't see that being the case for bind)
05:59:51 * hackagebot kansas-lava-papilio 0.3.0 - Kansas Lava support files for the Papilio FPGA board  http://hackage.haskell.org/package/kansas-lava-papilio-0.3.0 (GergoErdi)
06:00:13 <fractalsea> Oh that’s odd. I can exit with Ctrl+c with either -hc or -P, but not both
06:00:43 <geekosaur> you could try intercepting the exception thrown by ctrl-c in your program and doing System.Exit.exitSuccess
06:01:24 <deezn> Can anyone explain: Generalised Abstract Data Types to me? My lecturer was talking about pulling variables up into the type system (that is off memory) but I am not sure what she was talkign about.
06:02:08 <haasn> safinaskar: For me, ‘f is strict’ means ‘f _|_ = _|_’ and therefore ‘f is non-strict’ means ‘f _|_ ≠ _|_’
06:02:31 <haasn> for bind, that would mean ‘(>>=) _|_ ≠ _|_’ but for Maybe this clearly isn't the case
06:02:39 <merijn> deezn: There's a decent wikibook on GADTs
06:02:49 <deezn> http://en.wikipedia.org/wiki/Generalized_algebraic_data_type?
06:02:53 <merijn> deezn: https://en.wikibooks.org/wiki/Haskell/GADT
06:03:03 <mniip> haasn, you're inverting the definition wrong
06:03:15 <deezn> ok thanks.
06:03:49 <mniip> f is strict => f ⊥ = ⊥
06:03:59 <mniip> nothing follows from f being non-script
06:04:34 <phaazon> my GOAD
06:04:47 <phaazon> my PR was merged into clock's upstream, but hackage was never updated
06:04:56 <phaazon> I think I'm gonna lose the clock's dependency
06:05:02 <phaazon> the author is not serious at all
06:05:06 <phaazon> even after many mails
06:05:12 <phaazon> emails*
06:05:23 <merijn> phaazon: You could request whether he's willing to make you a maintainer so you could keep hackage up to date
06:05:35 <deezn> merijn why would we want GADTs?
06:05:52 <merijn> deezn: The wikibook actually gives a good example for when :)
06:05:59 <phaazon> merijn: already done
06:06:01 <phaazon> two months ago
06:06:05 <phaazon> I have the emails as proof
06:06:07 <phaazon> no answer.
06:06:24 <kaidelong> fork the project?
06:06:28 <merijn> deezn: It starts with an interpreter for a normal ADT, shows something you can't write and then shows how you can write it using GADTs
06:06:34 <deezn> I just dont get why? ok keep reading.
06:07:02 <haasn> mniip: But then “f is non-strict” is a tautology, regardless of ‘f’?
06:07:32 <phaazon> kaidelong: why haven't I thought of that yet... :D
06:07:40 <phaazon> I already forked it
06:07:43 <phaazon> hence my PR
06:08:04 <phaazon> my codebase uses my repo (phaazon/clock.git on github)
06:08:24 <phaazon> though, when I release my stuff, I want people to be able to compile through hackage
06:08:43 <merijn> phaazon: I think he means fork it on hackage
06:09:18 <merijn> phaazon: i.e. create a new package from your fork and upload that to hackage and depend on that
06:09:52 * hackagebot clash-prelude 0.7.2 - CAES Language for Synchronous Hardware - Prelude library  http://hackage.haskell.org/package/clash-prelude-0.7.2 (ChristiaanBaaij)
06:10:04 <phaazon> merijn: I don't like that...
06:10:15 <phaazon> names booking is pretty annoying on hackage
06:10:42 <phaazon> I'd like to figure the source of the problem out
06:15:59 <mniip> haasn, "f is non-strict" means that f ⊥ is not neccessarily ⊥
06:16:04 <mniip> but generally, yes
06:16:11 <mniip> as by default haskell functions are non-strict
06:16:48 <haasn> mniip: Do you distinguish between “f is non-strict” and “f is not strict”?
06:17:14 <mniip> aren't they the same?
06:18:07 <merijn> haasn: Those mean the same thing?
06:18:09 <mniip> strict functions are a subset of functions, for which the above property holds
06:18:22 <mniip> it's not like all functions are divided into strict and lazy
06:18:44 <haasn> mniip: I read “f is not strict” as “not (f is strict)”, or “not (f _|_ = _|_)”, or “f _|_ ≠ _|_”
06:19:27 <haasn> I mean, f _|_ can only evaluate to one thing
06:20:01 <tremon> haasn: f = const 1 ?
06:20:44 <mniip> haasn, are you speaking of unary functions?
06:21:08 <merijn> haasn: The objection that was raised is that "strict is defined as 'f _|_ = _|_'" is not sufficient to conclude that "non-strict means that 'f _|_ /= _|_", I'm not sure where I stand on this
06:21:26 <merijn> haasn: I guess it depens on whether you consider "const undefined" to be strict or not
06:21:58 <wz1000> Does GHCJS documentation exist anywhere?
06:22:48 <merijn> wz1000: What sort of documentation are you looking for?
06:24:02 <wz1000> merijn: Hackage-like documentation
06:24:50 <haasn> merijn: The only thing that's tricky about “const undefined” is the fact that in the real world, not all bottoms are created equal
06:24:50 <merijn> hackage-like documentation of what?
06:25:07 <haasn> sure, const undefined is strict; in that const ⊥ ⊥ = ⊥
06:25:30 * hodapp snickers
06:25:39 <haasn> mniip: All functions have only one parameter, certainly in Haskell
06:27:01 <humanoyd> What would be a good file watcher written in Haskell?
06:27:30 <haasn> tremon: f = const 1 is non-strict and not strict. f _|_ = 1, not _|_
06:28:07 <haasn> (Almost no matter how you interpret those words)
06:29:09 <haasn> merijn: But also in the real world, “const undefined (error "foo")” is certainly different from “error "foo"”
06:32:43 <haasn> In the real world, we also have all sorts of things in between, eg. maybe it produces “Just _|_” or maybe it reacts differently to “Just ()” and “Just _|_” being inputs
06:32:48 <tremon> haasn: of course, but I was only replying to your assertion that f _|_ could only evaluate to one thing, which is only true if f is strict in the first place
06:34:54 * hackagebot cabal-rpm 0.9.5 - RPM packaging tool for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.9.5 (JensPetersen)
06:34:56 * hackagebot clash-lib 0.5.1 - CAES Language for Synchronous Hardware - As a Library  http://hackage.haskell.org/package/clash-lib-0.5.1 (ChristiaanBaaij)
06:34:58 * hackagebot clash-vhdl 0.5.1 - CAES Language for Synchronous Hardware - VHDL backend  http://hackage.haskell.org/package/clash-vhdl-0.5.1 (ChristiaanBaaij)
06:35:28 <haasn> tremon: I think you misunderstood me. I mean, ‘f _|_ = x’ can be solved by some x, but no matter what x you pick, that will be the outcome no matter how often you try to re-run ‘f _|_’. What I mean is that functions map each input to exactly one output. And in the case of “f _|_”, that output can either be _|_ or it can be something that isn't _|_. There's no third option
06:36:17 <haasn> Think about it like numbers: say f : ℕ → ℕ; we can say that “f goes through (0,0)” is defined as “f 0 = 0”. And for every function of this type, no matter what, “f 0” is either 0 or it isn't. So we can say that f either goes through (0,0) or it doesn't
06:38:01 <kaidelong> so I cannot "cabal install cabal-install" because directory won't build because it doesn't believe I have cabal >=1.10
06:38:09 <kaidelong> (cabal --version says I have 1.16)
06:38:58 <dcoutts> kaidelong: you could probably install a slightly older one
06:39:12 <dcoutts> cabal install 'cabal-install < x.y'
06:39:54 * hackagebot clash-systemverilog 0.5.1 - CAES Language for Synchronous Hardware - SystemVerilog backend  http://hackage.haskell.org/package/clash-systemverilog-0.5.1 (ChristiaanBaaij)
06:39:56 * hackagebot clash-ghc 0.5.1 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.5.1 (ChristiaanBaaij)
06:40:58 <kaidelong> dcoutts: yeah, was thinking that myself, cabal is telling me I could try installing 1.20 but I'll break "binary" if I do
06:41:10 <kaidelong> is there a revdep lookup for cabal?
06:41:33 <dcoutts> kaidelong: older cabal don't depend on binary
06:41:49 <kaidelong> I guess I could also fetch cabal, build it in a sandbox, and then install it?
06:41:53 <dcoutts> kaidelong: and I think there's a sufficiently recent one that does support sandboxes, so you could then use a sandbox to build it
06:42:01 <dcoutts> to build the latest version
06:42:51 <kaidelong> oh, this version of cabal doesn't support sandboxes =(
06:42:56 <kaidelong> okay
06:43:07 <kaidelong> I guess my strategy is
06:43:07 <dcoutts> kaidelong: that's what I meant about some intermediate version
06:43:15 <kaidelong> force installation of cabal 1.20
06:43:20 <kaidelong> even though it breaks binary
06:43:28 <kaidelong> build cabal 1.22 in a sandbox
06:43:30 <kaidelong> install that
06:54:55 * hackagebot stackage-cli 0.0.0.1 - A CLI library for stackage commands  http://hackage.haskell.org/package/stackage-cli-0.0.0.1 (MichaelSnoyman)
06:55:34 <kaidelong> well
06:55:40 <kaidelong> now cabal is segfaulting
07:06:57 <OutlawStar> probably a long shot, but has anyone tried building http-streams v0.7.2.6 on gentoo? I get a build error complaining about a type match... for reference: http://pastebin.com/HUYkp8JA
07:07:30 <OutlawStar> kind of wondering what package i need to fix to get this to compile
07:14:56 * hackagebot hXmixer 0.1.0.0 - A Gtk mixer application for FreeBSD  http://hackage.haskell.org/package/hXmixer-0.1.0.0 (colinrmitchell)
07:16:56 <OutlawStar> find problem, incase anyone else is interested: https://github.com/afcowie/http-streams/issues/85
07:19:57 * hackagebot hXmixer 0.1.1.0 - A Gtk mixer application for FreeBSD  http://hackage.haskell.org/package/hXmixer-0.1.1.0 (colinrmitchell)
07:19:59 * hackagebot Cabal 1.22.3.0 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.22.3.0 (ryant)
07:20:01 * hackagebot hXmixer 0.2.0.0 - A Gtk mixer application for FreeBSD  http://hackage.haskell.org/package/hXmixer-0.2.0.0 (colinrmitchell)
07:29:50 <f-a> I have a list of, say, 3 resources, and a function f which takes the list and a request, checks if a resource is available and if so returns the new list wrapped in Just (if no resource is available, it returns Nothing).
07:30:02 <f-a> I guess this is a common pattern, but I don't know the name of it. Queue, maybe?
07:35:13 <lpaste> f-a pasted “No title” at http://lpaste.net/131040
07:35:33 <f-a> ^-- I pasted a simple example of what I meant
07:42:15 <frerich> f-a: I.e. 'f [Busy 7, Free, Free] 3' should yield '[Busy 7, Busy 3, Free]'? What should 'f [] 3' give? And what about 'f [Busy 7] 3'?
07:42:56 <f-a> yes frerich , f [Busy 7, Free, Free] 3' should yield '[Busy 7, Busy 3, Free]
07:43:11 <f-a> f [Busy 7] should yeld [Busy 7]
07:43:19 <OutlawStar> is it possible to specify which haskell package to load a module from if they have the same module name. IE http-client and http-streams both have a module named "Network.Http.Client"
07:43:31 <KaneTW> f-a: you're better off using https://downloads.haskell.org/~ghc/latest/docs/html/libraries/containers/Data-Sequence.html
07:44:03 <f-a> yeah, [] is a poor choice
07:44:58 * hackagebot cabal-install 1.22.3.0 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.22.3.0 (ryant)
07:46:35 * geekosaur wonders if this is a psq
07:46:49 <eikke> OutlawStar: https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/syntax-extns.html#package-imports
07:46:50 <geekosaur> although I suspect the update bvehavior says not quite
07:47:46 <OutlawStar> eikke: Thanks alot!
07:48:24 <frerich> f-a: I'm not aware of any name for this 'find first element matching a predicate and replace it' thing.
07:49:51 <KaneTW> nope
07:49:55 <KaneTW> i don't think there is
07:49:58 * hackagebot orchestrate 0.2.0.1 - An API client for http://orchestrate.io/.  http://hackage.haskell.org/package/orchestrate-0.2.0.1 (EricRochester)
07:50:00 * hackagebot hXmixer 0.2.5.0 - A Gtk mixer application for FreeBSD  http://hackage.haskell.org/package/hXmixer-0.2.5.0 (colinrmitchell)
07:50:02 * hackagebot orchestrate 0.2.0.2 - An API client for http://orchestrate.io/.  http://hackage.haskell.org/package/orchestrate-0.2.0.2 (EricRochester)
07:50:34 <f-a> thanks frerich and KaneTW
07:51:02 <KaneTW> but yeah it should be easier and faster to implement using Data.Sequence or Data.PSQueue if you define an Ord for your datatype
07:51:25 <f-a> Just was checking I not to reimplementing the wheel.
07:51:40 <f-a> uhh, thanks for the suggestions KaneTW , I will look into those two modules
08:04:42 <haskell918> Hi, I have problems running ghcjs on windows. I do steps in 
08:06:00 <haskell918> Hi, I have problems running ghcjs on windows. I did use MSYS2, I am not on step "ghcjs-boot --dev", from logs I see that "program autoreconf NOT found, searched for autoreconf", but when I type "which autoreconf" I get the right path.
08:06:44 <haskell918> I failed on this step: https://github.com/ghcjs/ghcjs#build-the-libraries
08:25:00 * hackagebot network-conduit-tls 1.1.2 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-1.1.2 (MichaelSnoyman)
08:34:52 <Ivanchuk> is there any specific math notation for monads bind and return ?
08:37:28 <slack1256> ivanchuk: could you elaborate? what do you look as math notation for monads?
08:38:02 <Cale> ivanchuk: return is usually called η (Greek letter eta), while bind often doesn't show up at all, in favour of join which is called μ, but when I have seen it show up, I've usually seen it displayed as a star
08:38:42 <kqr> ivanchuk, η = return and µ = bind, according to wikipedia
08:38:48 <kqr> ivanchuk, uh sorry
08:38:49 <Cale> no
08:38:53 <Cale> μ = join
08:38:54 <kqr> ivanchuk, η = return and µ = join
08:38:56 <kqr> yeah
08:39:01 <kqr> typing a bit too fast
08:39:09 <ivanchuk> great
08:39:11 <ivanchuk> thanks
08:41:31 <ivanchuk> and do you know of any tutorial explaining the cat equivalence for monads ? I found it very difficult to grasp
08:42:04 <kqr> meow
08:42:05 <Cale> ivanchuk: Sorry, which equivalence are you talking about?
08:42:05 <kqr> sorry
08:43:17 <ivanchuk> euh may be there is no one then... because googling I found that functors are category theory concepts
08:45:00 <ivanchuk> I understand how monads works but I'm trying to understand its categorical meaning, found it very complex to understand
08:45:29 <albeit> Do you guys have a recommended library for parsing command line options?
08:46:11 <kqr> albeit, I've used optparse-applicative
08:46:12 <chpatrick> optparse-applicative
08:46:25 <chpatrick> the docs are a bit weird but it's really good once you figure it out
08:50:01 * hackagebot clock 0.4.2.0 - High-resolution clock functions: monotonic, realtime, cputime.  http://hackage.haskell.org/package/clock-0.4.2.0 (CetinSert)
08:50:14 <albeit> Thanks!
08:53:59 <Ryanar> does anyone know a good resource for learning about embedded data types in Haskell? I went through the chapter in LYAH but didn't find what I was looking for
08:54:20 <ion> What's an embedded data type?
08:54:48 <Ryanar> sorry, I don't really know the phrasing, but something like data TrafficLight = Green | Yellow | Red
08:55:03 <Ryanar> data Wrapper a = TrafficLight a
08:55:31 <Ryanar> so that I can have a function f :: Wrapper -> String which returns green yellow or red
08:57:32 <geekosaur> that sounds confused. TrafficLight doesn't take a parameter, so what is a doing in Wrapper?
08:58:08 <Ryanar> because lets say I have another data Sign = Slow | Yield | Stop
08:58:25 <tulcod> Ryanar: what you want is: data Wrapper a = Wrapper TrafficLight a
08:58:25 <Ryanar> and I want a function that shows either Sign or TrafficLight data
08:58:56 <tulcod> or perhaps WrapperLight TrafficLight | WrapperOther a
08:58:56 <Ryanar> so I wrap them into data Wrapper a = Wrapper TrafficLight a | Wrapper Sign a
09:00:00 <geekosaur> still highly confused, still no point to the a
09:00:02 * hackagebot clock 0.4.3.0 - High-resolution clock functions: monotonic, realtime, cputime.  http://hackage.haskell.org/package/clock-0.4.3.0 (CetinSert)
09:00:22 <Ryanar> well I don't know how to do it, I was asking if anyone knew a resource on it
09:00:23 <geekosaur> well, maybe some point to the a but not enough information to see what it's supposed to be
09:00:46 <tulcod> Ryanar: you should simply search for haskell data types - this is not "embedded" in any particular sense
09:00:53 <geekosaur> so far it sounds like *maybe* you want data Wrapper a = WrapSign Sign a | WrapLight TrafficLight a
09:01:25 <geekosaur> and I'm not convinced that `deriving Show` won't do most of what you want
09:01:33 <Ryanar> let me show you my actual problem domain I guess
09:01:59 <tulcod> Ryanar: what do you want your constructors to look like? what kind of stuff goes into your Wrapper object?
09:02:29 <lpaste> ryanar pasted “No title” at http://lpaste.net/7853917239169253376
09:03:03 <Ryanar> I wanted my symbol function to be able to deal with multiple "lenthunit" types
09:04:00 <geekosaur> so line 16 you're missing a set of parentheses
09:04:09 <tulcod> Ryanar: "LengthUnit" is not a type, it's a kind. so an object never has type LengthUnit, it can have type "LengthUnit Millimeter" - that would be a type
09:04:38 <geekosaur> it's not a kind, it's a type constructor (or type function)
09:04:48 <tulcod> fair enough :)
09:05:18 <geekosaur> lines 11-13 you need a different data constructor for each one
09:05:18 <arkeet> that data type definition looks wrong too.
09:05:19 <Ryanar> well first off, I can't do multiple declarations of LengthUnit
09:05:35 <tulcod> Ryanar: what do you mean by that?
09:05:48 <Ryanar> I can't say LengthUnit a | LengthUnit b
09:05:56 <geekosaur> yes
09:05:57 <Ryanar> its multiple declarations of the same constructor
09:06:05 <geekosaur> use a different data constructor for each one
09:06:29 <geekosaur> data Foo a = FooA (A a) | FooB (B a) | ...
09:06:37 <lpaste> ryanar revised “No title”: “No title” at http://lpaste.net/7853917239169253376
09:06:47 <Ryanar> oh ok
09:07:24 <lpaste> ryanar revised “No title”: “No title” at http://lpaste.net/7853917239169253376
09:07:27 <geekosaur> and then on line 16 you need parentheses, because `symbol LengthUnitMetric Millimeter` (assuming that to fix the data decl) does not mean the same as `symbol (LengthUnitMetric Millimeter)`
09:08:39 <geekosaur> remember, Haskell is functional. it can be entirely sensible to pass a data constructor that normally takes a parameter, without the parameter
09:08:44 <geekosaur> > map Just [1,2,3]
09:08:45 <lambdabot>  [Just 1,Just 2,Just 3]
09:10:02 * hackagebot paypal-adaptive-hoops 0.10.0.2 - Client for a limited part of PayPal's Adaptive Payments API  http://hackage.haskell.org/package/paypal-adaptive-hoops-0.10.0.2 (fanjam)
09:10:04 * hackagebot moonshine 1.2.2.1 - A web service framework for Haskell, similar in purpose to dropwizard.  http://hackage.haskell.org/package/moonshine-1.2.2.1 (taphu)
09:10:06 * hackagebot clock 0.4.4.0 - High-resolution clock functions: monotonic, realtime, cputime.  http://hackage.haskell.org/package/clock-0.4.4.0 (CetinSert)
09:10:40 <jophish> Is it possible to "unnormalize" a value. For example, I might require "foo" at one point in a program, and again later on but it's not feasible to keep the (perhaps large) result in memory
09:11:04 <tulcod> jophish: you mean remember the thunk rather than the value?
09:11:05 <jophish> as in, replace an evaluated thunk with an unevaluated one
09:11:40 <jophish> "reverse" of seq or deepseq
09:11:55 <jophish> I'm asking just out of curiosity :)
09:12:07 <geekosaur> someone came up with a hack for that under some circumstances on -cafe, otherwise no
09:13:05 <lpaste> geekosaur annotated “No title” with “No title (annotation)” at http://lpaste.net/7853917239169253376#a131045
09:13:17 <tulcod> jophish: maybe you can introduce some dummy variable? or compute it in the IO monad?
09:13:28 <tromp> jphish: a non-lazy call by need evaluator will evaluate the same thunk repeatedly, whenever needed
09:13:31 <tulcod> (though that won't give you any guarantees obviously)
09:15:16 <arkeet> jophish: you could define f () = ...
09:15:26 <arkeet> then each use of f () will evaluate the rhs
09:15:33 <mnaser> What's the meaning behind single quotes after function names .. seeing things like this sometimes ... circumference' r = 2 * pi * r
09:15:52 <arkeet> mnaser: it's just another character
09:16:00 <arkeet> instead of circumference2 or whatever
09:16:01 <nshepperd_> jophish: I recall someone discussing a hack (probably the same one geekosaur mentioned) on http://stackoverflow.com/questions/11675807/can-a-thunk-be-duplicated-to-improve-memory-performance
09:16:05 <mnaser> ah okay, arkeet 
09:16:12 <jophish> cool stuff, thanks everyone!
09:16:17 <mnaser> is there a specific coding standard when it's used, or not really?
09:16:30 <geekosaur> ryanar, http://lpaste.net/7853917239169253376#a131045 compare how it's pattern matched (line 16) to how it's declared (line 12). but also, `a` still not being used there as yet
09:16:33 <fuzzyhorns1> it has a math-y type reference
09:16:45 <arkeet> mnaser: ' (read "prime") is often used in math or whatever 
09:16:46 <fuzzyhorns1> in that function' ~= function-prime
09:16:56 <mnaser> okay, fair enouh
09:16:56 <arkeet> circumference' is something that's somehow related to circumference
09:16:57 <fuzzyhorns1> +1 arkeet
09:16:58 <mnaser> enough
09:17:02 <lpaste> ryanar revised “No title”: “No title” at http://lpaste.net/7853917239169253376
09:17:05 <geekosaur> ImperialLengthUnit takes no parameters, at least as yet. (probably it should, but not the way you are currently using it)
09:17:09 <arkeet> https://en.wikipedia.org/wiki/Prime_%28symbol%29
09:17:24 <Ryanar> oh I didnt even see your annotation
09:18:26 <geekosaur> and yes, that final revision looks more sensible
09:20:03 * hackagebot language-puppet 1.1.1 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-1.1.1 (SimonMarechal)
09:20:05 * hackagebot agentx 0.1.0.0 - AgentX protocol for snmp subagents  http://hackage.haskell.org/package/agentx-0.1.0.0 (chemist)
09:20:42 <hodapp> wow, I'm so good at Google that I invented my own Shake cross-compilation tools instead of taking 5 minutes to search and find https://github.com/samplecount/shake-language-c
09:21:06 <lpaste> ryanar revised “No title”: “No title” at http://lpaste.net/7853917239169253376
09:21:20 <Ryanar> that was the idea of not having the a included in the type
09:21:24 <Javran> where can I get a channel logger like clog? I want to keep log for a freenode channel.
09:21:32 <Ryanar> those were strictly enums for the units
09:24:22 <geekosaur> the place where the a might be useful is in place of the Double in the latest revision. *but* that would complicate things much worse, and just using Double is probably the correct answer there
09:24:58 <Ryanar> yeah
09:25:03 * hackagebot pred-trie 0.0.2 - Predicative tries  http://hackage.haskell.org/package/pred-trie-0.0.2 (athanclark)
09:29:28 <mnaser> if i understand correctly, using "Eq" for class constraint means that it implements the == method ?
09:30:03 * hackagebot canteven-config 0.1.0.1 - A pattern for configuring programs.  http://hackage.haskell.org/package/canteven-config-0.1.0.1 (taphu)
09:30:05 * hackagebot agentx 0.1.0.1 - AgentX protocol for snmp subagents  http://hackage.haskell.org/package/agentx-0.1.0.1 (chemist)
09:30:55 <jophish> mnaser: essentially yes, although functions for classes are not usually called methods
09:31:06 <quchen> haasn: ping
09:31:07 <mnaser> what would the term be in this case
09:31:28 <jophish> it means that the type constrained by Eq has to be an instance of Eq
09:32:27 <glguy> jophish: Actually they are called exactly "class methods"
09:32:49 <jophish> mnaser: ignore me then!
09:33:02 <mnaser> :P
09:35:03 * hackagebot agentx 0.1.0.2 - AgentX protocol for snmp subagents  http://hackage.haskell.org/package/agentx-0.1.0.2 (chemist)
09:42:59 <seanhess> I'm trying to make a typeclass automatically convert anything with a value inside into either an error message or the value. 
09:43:21 <seanhess> So I want to end up with: `Either (Int, String) a`
09:43:45 <chpatrick> anything with a value inside it?
09:43:49 <seanhess> For example, if I have a `Maybe User`, I want to convert it into `Either (Int, String) User`
09:43:55 <seanhess> (well, not anything... I'll make instances)
09:44:06 <seanhess> Nothing -> Left (404, "Not Found)
09:44:13 <seanhess> Just user -> Right user
09:44:30 <seanhess> But I can't figure out how to do it. I keep getting errors saying it can't match the type in my instance
09:44:34 <seanhess> Here's what I have so far:
09:44:47 <seanhess> https://www.irccloud.com/pastebin/CKAy3H1P
09:45:37 <chpatrick> the problem is that it can't relate the "type inside the value" to the right type of the either
09:45:47 <geekosaur> perhaps you ingtended val to be a
09:45:53 <chpatrick> so if you the thing you're converting from has a parameter you can just do
09:45:56 <S11001001> seanhess: as geekosaur says
09:46:08 <tulcod> can i tell runhaskell to ignore package hiding constraints and just run the godd*** script?
09:46:09 <chpatrick> toStatus :: f a -> Either (Int, String) a
09:46:13 <seanhess> geekosaur: no, because I don't want to end up with `Either (Int, String) (Maybe User)` 
09:46:19 <chpatrick> and then your instance is instance ToError Maybe where
09:46:26 <geekosaur> but as you wrote it, it is an unknown and unknowable type
09:46:33 <chpatrick> if you don't want to require that it has a parameter, you can use an associated type
09:46:42 <S11001001> seanhess: then you need a HK as chpatrick, or an MPTC/typefamily approach.
09:46:42 <seanhess> chpatrick: ooh let me see if that works
09:46:46 <seanhess> geekosaur: yeah I don't know what I'm doing
09:47:04 <geekosaur> alternately, do you knoiw it will always be Maybe?
09:47:06 <glguy> seanhess: Perhaps you can write a couple of the implementations of "toStatus" you had in mind first
09:47:23 <geekosaur> toStatus: Maybe a -> Either (Int,String) a
09:47:26 <glguy> seanhess: and then we can work out what is actually common between them and if a class makes sense
09:47:54 <seanhess> glguy: that's a great idea! give me 1 min
09:49:01 <sbidin> Is there an inverse of liftIO? Something of type MonadIO m => m a -> IO a?
09:49:11 <arkeet> no
09:49:19 <tulcod> seanhess: the "thing" that's in the class is not (Maybe a), it's Maybe. replace  toStatus :: a   by  toStatus :: a b
09:49:32 <tulcod> or "a val" rather
09:49:44 <lpaste> chpatrick pasted “Spock routes with Applicator” at http://lpaste.net/131047
09:49:58 <seanhess> ok here are 3 instance I want to make: 
09:50:00 <chpatrick> you can do the spock routing stuff without any datakinds magic
09:50:02 <seanhess> https://www.irccloud.com/pastebin/jhpJoduU
09:50:04 * hackagebot stackage-cli 0.0.0.2 - A CLI library for stackage commands  http://hackage.haskell.org/package/stackage-cli-0.0.0.2 (DanBurton)
09:50:05 <hiptobecubic> sbidin, usually 'running' the monadIO value will give you an IO value
09:50:05 <chpatrick> and it generalizes to a lot of other things
09:50:05 <bergmark> sbidin: usually a transformer supplies a function `runFoo' of that type
09:50:07 <seanhess> I'm catching up now
09:50:31 <arkeet> sbidin: that would imply existence of stuff like forall r. ReaderT r IO a -> IO a
09:50:42 <indiagreen> sbidin: are you by any chance trying to use some function like “IO a -> something” with MonadIO?
09:51:03 <indiagreen> if so, there are a lot of functions accepting MonadIO arguments in the lifted-base package
09:51:13 <sbidin> indiagreen: I wanted bracket, but for MonadIO. :)
09:51:36 <indiagreen> http://hackage.haskell.org/package/lifted-base-0.2.3.6/docs/Control-Exception-Lifted.html
09:51:46 <sbidin> arkeet: Ah, I see.
09:52:14 <arkeet> right, so you need something else that stays in your other MonadIO, not going to IO and back.
09:52:20 <arkeet> like that lifted-base stuff.
09:52:57 <sbidin> indiagreen: Nice, I wasn't aware of lifted-base.
09:53:05 <tulcod> seanhess: http://lpaste.net/131048
09:53:10 <tulcod> that's probably what you meant
09:53:32 <lpaste> chpatrick revised “Spock routes with Applicator”: “No title” at http://lpaste.net/131047
09:53:55 <chpatrick> I'm using this in my emulator too
09:54:27 <tulcod> seanhess: with this code, (toStatus (Just "hi")) == (Right "hi")
09:54:50 <seanhess> tulcod: yeah, it works! I *think* I understand it. Thanks! Thanks too chpatrick who suggested the same fix
09:55:23 <lpaste> glguy pasted “errors for seances” at http://lpaste.net/131050
09:55:33 <hexagoxel> how can i obtain a list of instances for a data type, where everything is fully qualified? Is there a way to print haddock with fully qualified identifiers?
09:55:44 <glguy> seanhess: I misspelled your name, but that paste was for you
09:56:42 <seanhess> glguy: cool thanks!
09:56:43 <tulcod> seanhess: it's a bit subtle, but basically you solve the problem of the unknown by varying over something else. that's how i think of it.
10:03:23 <IvanLing> hello
10:03:54 <Ryanar> hi
10:08:13 <indiagreen> is there a way to make cabal try to minimise package versions instead of maximising them? it'd be pretty handy when checking that a package has correct lower bounds for dependencies
10:08:45 <indiagreen> I'm not sure it actually makes sense, but maybe it does
10:09:03 <dcoutts> indiagreen: there was a patch floating around to do that, it shouldn't be hard if you want to fix it up
10:09:17 <slack1256> indiagreen: a la cabal freeze?
10:09:20 <dcoutts> it would be a welcome contribution
10:09:34 <dcoutts> slack1256: no, just to reverse a preference in the solver
10:09:45 <dcoutts> preferring older rather than newer
10:09:56 <dcoutts> it'd be a simple local change, controlled by a flag
10:10:03 <slack1256> oh, I see
10:10:05 * hackagebot pred-trie 0.0.3 - Predicative tries  http://hackage.haskell.org/package/pred-trie-0.0.3 (athanclark)
10:15:05 * hackagebot persistent 2.1.3 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.1.3 (GregWeber)
10:15:07 * hackagebot persistent-template 2.1.3 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.1.3 (GregWeber)
10:18:48 <slack1256> Are semantics differences between MonadPlus and Alternative or is just an historic acciddent?
10:20:05 * hackagebot castle 0.1.0.1 - A tool to manage shared cabal-install sandboxes.  http://hackage.haskell.org/package/castle-0.1.0.1 (EricRochester)
10:20:47 <kaidelong> slack1256, apparently not
10:20:54 <kaidelong> they are different
10:21:57 <kaidelong> I've heard it said that if Alternative is different from MonadPlus then this should be considered a bug but I think there was at least one real library that had them differ (pipes?)
10:23:03 <slack1256> I also have heard their laws to be different, but not once found different implementations
10:23:09 <slack1256> I will check pipes then!
10:25:06 * hackagebot JuicyPixels 3.2.3.2 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.2.3.2 (VincentBerthoux)
10:25:19 <bennofs> kaidelong: pipes has: instance MonadPlus m => Alternative (Proxy a' a b' b m) where
10:25:21 <bennofs>     empty = mzero
10:25:23 <bennofs>     (<|>) = mplus
10:27:02 <kaidelong> anyway looks like the answer is that all mplus instances should be equivalent to alternative instances but there may exist alternative instances that cannot be mplus instances
10:35:06 * hackagebot BlastHTTP 1.2.0 - Libary to interface with the NCBI blast REST interface  http://hackage.haskell.org/package/BlastHTTP-1.2.0 (FlorianEggenhofer)
10:41:44 <ReinH> kaidelong: probably for Applicatives that are not Monads...
10:45:06 * hackagebot pgp-wordlist 0.1.0.1 - Translate between binary data and a human-readable  collection of words.  http://hackage.haskell.org/package/pgp-wordlist-0.1.0.1 (quchen)
10:46:53 <ertdfgcb> I'm trying to generate a visualization of a bunch of events happening at geographic points over time. I'm doing this by generating a bunch of images with juicypixel, but it's really slow
10:47:38 <ertdfgcb> I'm thinking I'll use repa-devil to speed it up, does anyone have any tips on really fast image generation/writing?
10:47:46 <ReinH> ertdfgcb: why are you using images?
10:48:08 <ertdfgcb> I couldn't find a library to generate a video file directly
10:48:19 <ReinH> I'd probably do vis in javascript via canvas or webgl and ship the data from haskell
10:48:34 <ertdfgcb> It has to be a mov file
10:48:36 <ReinH> Ah.
10:48:52 <ertdfgcb> But yeah, that's what I'd like to do
10:50:07 * hackagebot webcrank 0.2 - Webmachine inspired toolkit for building http applications and services.  http://hackage.haskell.org/package/webcrank-0.2 (purefn)
10:50:48 <miguelnegrao> Hi, How do I exit a haskell program from a child thread ?
10:51:09 <miguelnegrao> exitSucess won't do it right ?
10:51:15 <merijn> miguelnegrao: Sure it will
10:51:56 <quchen> Exiting from a child thread (successfully) sounds awkward.
10:52:21 <merijn> Mind you, that will just exit the program without running any cleanup, whatever
10:52:24 <ReinH> I'd rather signal to the control thread and have it exit so it can manage cleanup, etc.
10:52:39 <miguelnegrao> ReinH: with a TVar ?
10:52:58 <ReinH> I suppose it depends.
10:53:16 <miguelnegrao> I'm using glut
10:53:32 <miguelnegrao> there's a thread receiving messages via tcp
10:53:42 <miguelnegrao> when a quit message is received the program should quit
10:55:07 * hackagebot webcrank-wai 0.2 - Build a WAI Application from Webcrank Resources  http://hackage.haskell.org/package/webcrank-wai-0.2 (purefn)
10:57:40 <ReinH> You might just use async and link the child threads
10:58:38 <ReinH> then catch the re-thrown exception in the parent thread and exit appropriately
11:10:25 <orion> In warp, are all requests executed in a separate thread?
11:10:50 <merijn> orion: I'd expect so
11:11:05 <orion> To clarify, I mean green threads.
11:11:21 <lexir> Are guys talking about warp?
11:11:35 <merijn> orion: I assumed you mean that, yes
11:11:40 <orion> Alright
11:11:52 <lexir> Okay... I don't even know how to ask my yesod web server question.
11:11:55 <miguelnegrao> destroyWindow is what I was looking for ~!
11:11:56 <lexir> :(
11:12:18 <miguelnegrao> btw, anyone here knows how postRedisplay works ?...  can't get it to work...
11:12:21 <orion> merijn: I'm writing a web server which receives HTTP requests, converts them to JSON-RPC calls, and sends them over RabbitMQ to workers.
11:12:23 <merijn> orion: I'm not sure, but since GHC can easily scale up to >100k threads I don't see a reason to do something more complicated
11:12:36 <lexir> Like where would I start with building a framework agnostic web server?
11:12:48 <orion> merijn: I'm wondering if I should create a new RabbitMQ channel for each request.
11:12:48 <lexir> After having read about WAI.
11:12:57 <merijn> orion: For comparison, forkIO threads are even lighter-weight than Erlang processes/goroutines
11:15:08 * hackagebot stackage-cli 0.0.0.3 - A CLI library for stackage commands  http://hackage.haskell.org/package/stackage-cli-0.0.0.3 (DanBurton)
11:16:07 <cschneid> Can I have cabal auto-run a command on every :reload?  I want to have my test suite autorun (just a call to `main`) on every reload
11:16:09 <ReinH> orion: You might use a resource pool
11:16:13 <Fuco> is there some implementation of Map which doesn't require 2300 megabytes of ram for 20 megabytes of data?
11:16:27 <Fuco> I'm working with morphological data, mapping forms to stems
11:16:27 <ReinH> Fuco: yes, Data.Map would do.
11:16:28 <merijn> Fuco: Sounds like a strictness leak
11:16:41 <Fuco> ReinH: Data.Map crashes my computer
11:16:42 <dcoutts> cschneid: do you mean make ghci run something?
11:16:44 <orion> ReinH: What resource would I pool?
11:16:45 <merijn> Fuco: Have you tried using Data.Map.Strict ?
11:16:50 <Fuco> merijn: yes
11:16:52 <Fuco> same thing
11:16:53 <ReinH> Fuco: No, the way you're using Data.Map crashes your computer.
11:17:07 <jxv> Is there a way to print the ":info" of a class without printing its instances?
11:17:10 <cschneid> dcoutts: `cabal repl test` -> gets me into a ghci with my test suite loaded and ready to run with `main`. I'd like it to autorun after every :reload
11:17:17 <merijn> Fuco: Oh, are you storing text?
11:17:19 <cschneid> I'm trying to autorun tests w/ ghcid :)
11:17:20 <Fuco> ReinH: you are being very helpful thank you very much
11:17:21 <merijn> Fuco: As a String?
11:17:22 <ReinH> orion: oh, "channel" not "connection". I misread.
11:17:35 <ReinH> Fuco: Blaming Data.Map won't help you solve the problem in your implementation.
11:17:40 <dcoutts> cschneid: yes, ghci's commands are programmable, so you can override :reload
11:17:40 <Fuco> ReinH: shut up thanks
11:17:44 <ReinH> ...
11:17:44 <kaidelong> okay so when building GHC I ran into a duplicate instance, I found it wrapped in CPP with a message saying "remove me when GHC 7.10 is released"
11:17:45 <merijn> I suspect Map is a red herring
11:17:49 <dcoutts> cschneid: see the ghc user guide for details
11:18:01 <Fuco> merijn: yes as string and an `data' which holds the morhological attributes
11:18:01 <cschneid> dcoutts: hmm, will look. 
11:18:05 <Cale> Fuco: Nobody can really know what's wrong with your program if you don't post it.
11:18:07 <merijn> Fuco: There's your problem
11:18:12 <kaidelong> I'm guessing I had the base libraries for GHC 7.10 but since I was using 7.6 to compile it, the CPP macro didn't work
11:18:20 <kaidelong> so I commented it out
11:18:29 <merijn> Fuco: Don't use String for substantial amounts of data, it may use around 20-24 bytes per character (depending on your hardware)
11:18:30 <kaidelong> I'm wondering if I did something really bad
11:18:53 <merijn> Fuco: String is a linked list of characters and completely unsuitable for big datasets. Try using Data.Text instead
11:19:11 <Cale> Yeah, String is a lazy linked list of 32 bit wide unicode characters.
11:19:26 <Fuco> okey
11:19:38 <merijn> Data.Text is densely encoded unicode data (so approximately 1-2 bytes per character + a few bytes overhead per kilobyte or so)
11:20:00 <merijn> It's orders of magnitude better than String if you have more than say a few lines of text
11:20:15 <Fuco> what about ADTs, are those okey?
11:20:31 <Fuco> if I have data Foo = A | B | C | D is that saved effectively somehow?
11:21:14 <geekosaur> that will be a machine word
11:21:20 <quchen> Plus the box.
11:21:25 <Kron> how exactly do I import a library like https://hackage.haskell.org/package/game-tree into my code?
11:21:29 <merijn> quchen: No box there
11:21:31 <Kron> import Data.Tree.Game_tree doesn't seem to work
11:21:35 <quchen> merijn: Not?
11:21:38 <merijn> Kron: Well, is it installed
11:21:47 <Kron> I assume so, it's in my ghc-pkg list
11:21:50 <Kron> I cabal installed it
11:21:51 <merijn> quchen: Well, no. Things *containing* a Foo will be the box
11:21:52 <Cale> merijn: Uh, you can have arbitrarily large expressions which compute values of type Foo
11:21:58 <Fuco> so if I really really need to pack it I should encode it into say integer? I can have as much as 15 of these attached to one word
11:22:05 <Fuco> but they are all binary, is there or is not
11:22:14 <bernalex> Kron: you need to import Data.Tree.Game_tree.Game_tree
11:22:18 <Kron> oh
11:22:23 <Cale> Fuco: You might prefer to use UArray or ByteString
11:22:24 <Kron> huh, thanks
11:22:25 <quchen> merijn: Ah right, the box I was thinking about was a value of type Foo, which will (potentially) be a thunk, and I mixed that up with a box.
11:22:28 <merijn> Fuco: I'd try seeing if Text works first before worrying about that level of optimisation
11:22:38 <Fuco> right
11:22:42 <Cale> Fuco: A UArray of Bool values gets bit-packed
11:23:38 <merijn> Cale: Sure, but that just means that *other* values store Foo as a pointer (i.e. are the box) which points to either 1) a thunk or 2) a machine word, but that's a property of the thing storing Foo, not Foo itself
11:23:50 <Cale> merijn: sure, okay
11:24:50 <Cale> Well, actually, the pointer never points to a machine word
11:25:08 * hackagebot not-gloss 0.7.3.0 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.7.3.0 (GregHorn)
11:25:09 <Cale> Variables are always pointers to code
11:25:32 <Cale> It's just that when the value is already evaluated, it's a pointer to a short piece of code :)
11:25:59 <Cale> (which returns the already computed value immediately)
11:31:25 <linman32> is using lens a bad idea? stephendiehl.com says it is
11:31:50 <Cale> no
11:32:02 <tulcod> yes
11:32:17 <Cale> Overusing lens in cases where it's not really going to help you might be a bad idea
11:32:27 <Cale> But it has reasonable use cases
11:32:46 <infandum> This code, http://pastebin.com/H8v3UY7t, should yield those fastasequences from a fasta file, ">blah\nblah\n>blah2\nblah2" etc. However it's instead returning each line with a header of "" and the sequence as the line entry (even if it's a header). Why?
11:32:51 <Cale> If you have to deal with a lot of nested record structures, it can be quite effective
11:32:54 <tulcod> linman32: you can definitely do well without
11:33:10 <merijn> Also, despite some people describing it as "imperative" or "not functional" I find it rather functional, at least in concepts
11:33:43 <Cale> My recommendation would be just to stay away from most if not all of the infix operators that lens defines.
11:33:46 <infandum> Also, it's a pipes question fyi
11:33:53 <linman32> he says consider lens-family-core or fclabels
11:34:03 <Cale> Yeah, those are reasonable options as well
11:34:39 <Cale> They're less fully featured though, but they might have everything you need.
11:34:44 <hexagoxel> what is the purpose of Control.Applicative.WrappedMonad? What is the difference to IdentityT?
11:35:15 <linman32> the problem is i'm converting btwn 2 data types. one example is one data type has a tuple, but it has to be converted to a tuple and a piece of data in a larger list
11:35:24 <Cale> hexagoxel: If you're on 7.10, apparently nothing
11:35:48 <linman32> was wondering if there is a more elegant solution. was doing backward/forward convert. 
11:35:53 <linman32> idk if this is making any sense.
11:36:22 <Cale> linman32: It might help to see the code in question
11:36:32 <Cale> hexagoxel: When Applicative was not a superclass of Monad, you could end up having to deal with an instance of Monad which was not an instance of Applicative.
11:36:36 <linman32> (t1,t2,t3) <-> [t1, (t2,t3), other type1, other type 2, etc]
11:36:38 <geekosaur> my guess is it was a pre-AMP way to get Functor/Applicative from Monad-s that didn't have them
11:36:55 <Cale> linman32: uhhhh, what?
11:37:11 <linman32> Cale: let me get some code up in a sec
11:37:13 <Cale> So t1 is the same type as (t2,t3)
11:37:14 <Cale> ?
11:37:51 <schell> what’s a standard way to communicate between processes in haskell - i’d like to communicate with a haskell program through ghci
11:38:01 <merijn> schell: unix sockets?
11:38:25 <hexagoxel> Cale: ah i see, the instance constraints are different, thanks!
11:39:14 <schell> merijn: that would mean serializing my request and deserializing, no?
11:40:49 <merijn> schell: You will have to do that regardless for communicating between processes
11:41:19 <schell> merijn: right - and i guess cloud haskell has some method of serializing functions?
11:42:27 <indiagreen> can I simulate this class (from lens) with type families? “class Field1 s t a b | s -> a, t -> b, s b -> t, t a -> s”
11:42:41 <schell> merijn: thanks - i’m looking at Network.Socket
11:42:42 <merijn> schell: Yes
11:42:45 <indiagreen> (specifically, the fundeps)
11:45:54 <Cale> indiagreen: Probably much less elegantly, with lots of type equality constraints on the class
11:46:31 <merijn> I'm not sure about less elegant if you use associated types to eliminate parameters from the class
11:46:44 <merijn> But I've been told, repeatedly, the fundeps infer better than Type Families
11:47:34 <Cale> Well, you'd be able to eliminate a and b
11:53:10 <lpaste> Cale pasted “e.g. you can do this, but it sucks” at http://lpaste.net/131052
11:54:00 <indiagreen> Cale: nevermind, I remembered I can't have MultiParamTypeClasses anyway
11:54:11 <Cale> ah, you could go even farther
11:54:48 <Cale> but then you get into the territory of defining some proxy type from which all four of the original type parameters get derived
11:55:04 <Cale> and the use of type classes at all starts getting really questionable
11:55:21 <c_wraith> If you have four type parameters, you're wandering into lens territory. :)
11:55:32 <Cale> Well, this is clearly a lens class
11:55:54 <indiagreen> I'm kinda trying to make a lens library compilable under JHC
11:56:27 <indiagreen> which would be as compatible with lens as possible (not lens-family-something that is “90% compatible”)
11:56:28 <Cale> Maybe just do without type classes altogether
11:56:31 <c_wraith> The thing about lenses is that you don't need the lens library to create or even use them.
11:56:37 <Cale> Oh
11:56:53 <c_wraith> The lens library just provides a ton of extra sugar for making them easy to work with.
11:57:03 * indiagreen likes sugar
11:57:44 <monadicp> >>=
11:58:00 <infandum> Wow, nevermind, you are looking at the biggest moron ever. It does work, I just used the wrong argument in the command line
11:58:48 <c_wraith> infandum: eh.  You're not a moron.  That happens to everyone.
11:59:12 <infandum> c_wraith: We'll see about that haha
11:59:23 <c_wraith> infandum: I've spent *hours* trying to track down individual problems like that before.
11:59:47 <infandum> c_wraith: But the good news is, in the end, the code is fine! :D
12:00:05 <Cale> The number of people who seem to be using Haskell for genetics-related stuff makes me wonder if we shouldn't have some instances of UArray/unboxed vectors for a type with 4 constructors :D
12:00:51 <c_wraith> There's been a ton of FASTA parsing recently.  Makes me wonder if it's part of some course.
12:01:03 <infandum> No, sorry that's all me
12:01:08 <Cale> I guess unboxed vectors let you use pairs of Bool values
12:01:13 <Cale> infandum: Not just you
12:01:24 <infandum> When I'm at another computer I'm guesting
12:01:31 <infandum> so if it's me or guesting it's me haha
12:01:40 <infandum> I've been trying to optimize my parser
12:01:40 <Cale> ah, possibly if you're using different nicks :)
12:01:51 <infandum> just two different ones though, so...
12:02:18 <infandum> It was hard to pinpoint the memory issues, so I switched to pipes and it's been working like a charm
12:03:37 <fragamus> howdy
12:04:10 <infandum> Cale: Also, you would need 20 AAs as well and need to switch back and forth so it could be a bit more complicated haha
12:05:58 <linman32> cale: the problem is converting between a data type and a data structure
12:06:03 <linman32> Cale: http://lpaste.net/131053
12:06:33 <Cale> linman32: I'm not sure what you mean by this list of types
12:07:02 <linman32> Cale: it has a bunch of unrelated stuff in it. that don't relate to the types there
12:07:04 <Cale> linman32: [String, (Float,Float)] isn't valid syntax for a type
12:07:23 <Cale> Are you talking about type level lists?
12:07:28 <Cale> I'm confused
12:07:44 <linman32> Cale: but is used for a larger purpose... data ListType = LString String | LTup (Float, Float)
12:08:53 <Cale> Well, okay, if the list represents a record of some sort with values of those types in it
12:09:02 <Cale> then yeah, sure, you could make a lens like that
12:09:20 <linman32> Cale: it's like trying to convert between two data bases. example: in database 1 each car is a type that is stored. in database 2 it must store two halfs of the car seperatly
12:09:21 <Cale> which would let you inspect and modify some fraction of the record
12:10:25 <Geraldus> hi folks!
12:10:46 <linman32> Cale: ok, going to read up more on lenes. thanks
12:11:15 <Cale> Geraldus: hello!
12:11:24 <frerich> Geraldus: Hi folk!
12:13:50 <Geraldus> I need to make some HTTP requests in my Yesod project. I'm planning to use `curl` package. And I curious is there other ways to do that or this is optimal choice?
12:14:05 <orion> Does there exist sugar for "y <- x; return y" ?
12:14:25 <Geraldus> return x?
12:14:29 <Clint> Geraldus: i'd probably use http-client instead
12:15:09 <bennofs> orion: how about x?
12:15:16 <Geraldus> Clint: if I not mistaken this one is what Yesod use internally?
12:15:25 <Clint> yes
12:15:29 <Geraldus> bennofs: oh, right, this is just `x`
12:15:36 <byorgey> orion: do y <- x; return y  is equivalent to  x  , that is one of the monad laws
12:15:39 <c_wraith> orion: the monad laws say that your monad instance is invalid if that's not *exactly* the same as x
12:15:53 <Geraldus> Clint: cool, thanks for suggestion. Let me see source code.
12:16:03 <orion> Ah yes. Thank you.
12:16:09 <byorgey> orion: if you want   y <- x; return (f y),  that is the same as   fmap f x
12:16:43 <levi> Geraldus: I don't have any experience directly with Yesod projects that are also HTTP clients, but you certainly shouldn't have to rely on libcurl to do http requests.
12:18:02 <levi> http-client may be a bit low-level; http-conduit is probably more appropriate for usage with Yesod. http://www.yesodweb.com/book/http-conduit
12:18:09 <Geraldus> levi: I have very limited knowledge about CURL and have used it just couple times in past. So I decided to ask community (: Just curious what's wrong with it?
12:18:28 <orion> byorgey: Gotcha, thank you.
12:18:52 <Geraldus> levi: oh, very useful link!
12:18:55 <Geraldus> Thanks
12:19:43 <levi> Geraldus: There's nothing wrong with it in particular, especially if you're writing in C rather than Haskell. I prefer to avoid depending on random C libraries in Haskell programs though unless they're really the best option when compared to native Haskell implementations.
12:20:54 <Geraldus> levi: nope, I'm writing Haskell, and I do agree with your statement
12:21:15 <Geraldus> excuse me my poor English 
12:39:12 <rzl> Hello!
12:39:24 <bitemyapp> rzl: hi
12:44:14 <rzl> I have a bit of an issue here.
12:44:14 <rzl> Let's say I have a data type with a lot of constructors (say, around a hundred? Think network packets) and I want to serialize them into binary format for network transmission.
12:44:14 <rzl> The value (header) of each construtor is not always sequential (in increments of one). I've tried looking at the binary package for serialisation, but I don't see how I could match the constructor with an header number. Any insights?
12:45:14 * hackagebot diagrams-pgf 0.1.0.1 - PGF backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-pgf-0.1.0.1 (cchalmers)
12:48:49 <orion> hmm
12:49:57 <orion> The way Network.AMQP works, I have to register a callback in order to get responses from a queue. However, I specifically want to block the current thread while I wait for a message. How can I achieve this?
12:50:59 <merijn> Register a callback that writes to an MVar/Chan?
12:51:10 * mniip pokes ski with a stick
12:51:33 <orion> merijn: That seems like it would work. What functions should I look at if I want to have a timeout just in case the response never comes?
12:52:19 <merijn> race from async
12:53:29 <orion> merijn: Alright. Do you think STM is called for here?
12:54:04 <merijn> You could try STM + timeout too
12:54:54 <orion> What do you recommend?
12:55:15 * hackagebot hipbot 0.1 - A library for building HipChat Bots  http://hackage.haskell.org/package/hipbot-0.1 (purefn)
12:56:23 <merijn> hard to say without details
12:56:34 <merijn> If there's only 2 or so threads STM shouldn't be very expensive
12:57:01 <mhitza> anyone else encountered similar issues when using scotty http://lpaste.net/131057 ?
12:57:31 <orion> merijn: The number of threads I have is equal to the number of HTTP connections (since I
12:57:36 <orion> 'm using warp)
12:57:50 <arkeet> mhitza: looks like a lazy vs strict Text thing.
12:58:10 <arkeet> it's expecting a Text from Data.Text.Lazy
12:58:32 <merijn> orion: No, I meant the number of threads competing for the TCha/TVar
12:58:54 <mhitza> arkeet, how do I convert from Strict to lazy?
12:59:08 <Kron> can you update multiple record fields at once?
12:59:38 <arkeet> mhitza: Data.Text.Lazy.fromStrict does it. but you might be able to just use lazy text in the first place.
13:00:22 <mhitza> arkeet, thanks the library I'm using is returning the strict Text type. But fromStrict worked
13:00:31 <arkeet> okay
13:01:29 <Kron> is there any way to pattern match on record fields?
13:01:42 <merijn> Kron: Sure, the same way as non-records?
13:02:14 <kadoban> Kron: Yeah you can update multiple record fields at once.
13:02:57 <merijn> kadoban: That's different from pattern matching, though
13:03:21 <geekosaur> foo X { field = Just m } = ... -- ?
13:03:26 <kadoban> merijn: Yeah, but he asked that first, so I figured I'd answer.
13:03:31 <Kron> okay
13:03:55 <orion> merijn: I might use a TMVar instead of a TVar. Regarding the number of threads, just one I suppose.
13:04:14 <orion> One thread waits for the TMVar to become non-empty, and the other is merely a timer.
13:04:30 <merijn> orion: Right, that's what I meant :)
13:04:51 <merijn> orion: The problem with STM is that it suffers from "thundering herd" with many threads waiting on the same data
13:04:52 <quchen> Why not an MVar?
13:05:15 * hackagebot TBit 0.4.2.2 - Utilities for condensed matter physics tight binding calculations.  http://hackage.haskell.org/package/TBit-0.4.2.2 (danielsmw)
13:05:17 * hackagebot TBit 0.4.2.3 - Utilities for condensed matter physics tight binding calculations.  http://hackage.haskell.org/package/TBit-0.4.2.3 (danielsmw)
13:05:37 <orion> merijn: I see. That doesn't seem to be the case here it seems.
13:05:40 <orion> quchen: I have no idea. ;x
13:07:21 <arkeet> is that some problem that's inherent in stm or is it just the implementation?
13:07:34 <quchen> orion: STM gets you composable atomicity and no deadlocks, but it doesn't come for free. merijn mentioned the thundering herd, and then there are livelocks and threads restarting each other to run slow like honey and what not. A simple MVar is often much easier if you don't need STM's benefits.
13:08:39 <geekosaur> I believe the current STM implementation is fairly naïve; smarter ones have been discussed but not implemented
13:08:52 <quchen> orion: Normal stuff like MVars also come with fairness guarantees, so if an MVar wants something, it'll get its fair shot at it. That's not the case with STM to such a great extent.
13:12:07 <Cale> arkeet: You could blame it on the implementation. Better mechanisms for deciding the order in which to allow transactions to complete might fare better
13:15:15 * hackagebot git-annex 5.20150420 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20150420 (JoeyHess)
13:15:36 <merijn> arkeet: It's pretty inherent in the meaning of STM
13:16:18 <merijn> arkeet: the problem is that a change in a TVar might chance the state to suddenly succeed for any transaction, so you have to retry all of them to check
13:20:16 * hackagebot pred-trie 0.0.4 - Predicative tries  http://hackage.haskell.org/package/pred-trie-0.0.4 (athanclark)
13:20:18 * hackagebot diagrams-haddock 0.3.0.1 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.3.0.1 (cchalmers)
13:20:20 * hackagebot diversity 0.6.0.0 - Return the diversity at each position for all sequences in a fasta file  http://hackage.haskell.org/package/diversity-0.6.0.0 (GregorySchwartz)
13:33:21 <fryguybob> If you have the semantic information that changes that cause wakeups will succeed for exactly one waiting thread then there are things that you can do (such as fairness in MVars), but in STM those semantics would have to be inferred.
13:33:54 <fryguybob> This happens in lots of lock free data structures where producers and consumers are "scheduled"
13:35:16 * hackagebot breve 0.1.0.0 - a url shortener  http://hackage.haskell.org/package/breve-0.1.0.0 (rnhmjoj)
13:47:31 <EvanR> git annex's website is fudding about haskell: "Memory usage should be constant. This is a "should", because there can sometimes be leaks (and this is one of haskell's weak spots)"
13:47:55 <EvanR> how do you unpack something like this if trying to explain haskell to somebody who thinks this
13:49:38 <srhb> EvanR: I still find some space leaks hard to diagnose.
13:50:18 <enthropy> EvanR: it's not a big enough problem to stop them from using it
13:50:22 <orion> What primitive should I look at if I want to ensure that an action always takes place at the conclusion of a function, regardless of whether an exception is raised?
13:50:36 <enthropy> @type finally
13:50:37 <lambdabot> IO a -> IO b -> IO a
13:50:49 <enthropy> (or other stuff from Control.Exception)
13:50:55 <EvanR> i mean, space leak sounds really scary, and then i realize i dont even know exactly what its referring to
13:51:07 <orion> enthropy: Thank you!
13:52:31 <EvanR> for someone unfamiliar with haskell "memory leak" sounds sort of catastrophic, after N hours or days your program will crash due to useless memory simply being unrecoverable
13:53:00 <EvanR> and running out
13:53:13 <EvanR> but we talk about "space leak" and that blurb just says "leak"
13:53:36 <mniip> well depends on what your program does, you might actually "leak" some memory into an un-gc-able value
13:54:39 <EvanR> that comes up normally? or you have to go out of your way to create something like that
13:54:59 <mniip> haven't encountered such issue yet
13:55:53 <orbifx> Are the static libraries build when building GHC needed after that for someone not planning to use them?
13:56:01 <orbifx> Are they core to the build process?
13:56:37 <EvanR> then i guess ill file it under "some people talk about leaks but i havent seen any specific easy-to-commit errors to cause this, feel free to provide one"
13:57:41 <phaazon> my god :D
13:57:56 <phaazon> installing my 3D engine installs a shit load of dependencies .D
13:58:13 <phaazon> though, they’re pretty nice :3
13:58:27 <orbifx> phaazon: we are having the same problem in a generic way :P
13:58:35 <phaazon> contravariant, comonad, semigroupoids, profunctors, bifunctors
13:58:36 <phaazon> free
13:58:45 <phaazon> orbifx: not sure it’s a “problem” though
13:58:59 <phaazon> I like the fact we have all abstractions split up that way
13:59:07 <c_wraith> all those packages are about working at high levels of abstraction, which is nice
13:59:12 <phaazon> I’d not like a package “big-abstractions”
13:59:14 <orbifx> the abstractions are great, the fat isn't :P
13:59:26 <phaazon> orbifx: those libraries are pretty standard actually
13:59:30 <phaazon> they should be in base, I guess
13:59:43 <c_wraith> I thought bifunctors were being moved into base
13:59:51 <phaazon> c_wraith: well
13:59:59 <phaazon> it overlaps Control.Arrow a little bit
14:00:18 <orbifx> phaskell: standard is not part of the aspect of the issue, size is
14:00:20 <c_wraith> but in a source-compatible way!
14:00:21 <phaazon> even though the abstractions are completely apart
14:00:37 <c_wraith> > fmap `asTypeOf` second
14:00:38 <lambdabot>      No instance for (Typeable a0)
14:00:39 <lambdabot>        arising from a use of ‘show_M906443877123033287213078’
14:00:39 <lambdabot>      In the expression:
14:00:46 <c_wraith> :t fmap `asTypeOf` second
14:00:47 <lambdabot> (a -> b) -> (d, a) -> (d, b)
14:01:05 <c_wraith> yep!  orthogonal but overlapping!
14:01:16 <c_wraith> :t rmap
14:01:17 <lambdabot> Profunctor p => (b -> c) -> p a b -> p a c
14:02:05 <phaazon> c_wraith: I was talking about hm
14:02:06 <EvanR> moving stuff into base because you use it or use it often doesnt really make sense
14:02:09 <phaazon> :t bimap
14:02:10 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
14:02:11 <phaazon> :t (***)
14:02:13 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
14:02:26 <phaazon> hm, not that one.
14:02:33 <phaazon> :t (&&&)
14:02:34 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
14:02:34 <c_wraith> Those are the same
14:02:38 <phaazon> not that one.
14:02:49 <c_wraith> (&&&) is the one that's not expressable in bifunctor
14:03:09 <c_wraith> :t (***) `asTypeOf` bimap
14:03:10 <lambdabot> (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
14:03:12 <orion> I am trying to use finally, but I think I'm getting hung up on syntax. Anyone know what's wrong with this code?: http://lpaste.net/5482174893170622464
14:03:25 <phaazon> yeah, it splits
14:04:00 <phaazon> :t Control.Arrow.first
14:04:01 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
14:04:07 <phaazon> :t Data.Bifunctor.first
14:04:08 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
14:04:18 <phaazon> :)
14:04:20 <c_wraith> phaazon: source-compatible!  For the common use case
14:04:31 <phaazon> c_wraith: well
14:04:35 <phaazon> not really actually
14:04:46 <orbifx> So any ghc experts here?
14:04:55 <phaazon> a function is not a bifunctor
14:04:57 <orbifx> or is there a dedicated channel for ghc?
14:04:57 <phaazon> it’s a profunctor
14:05:20 <byorgey> orbifx: #ghc
14:05:29 <EvanR> orbifx: because your second argument to finally is indented such that its a statement of the do block instead of an argument
14:05:42 <EvanR> orion: 
14:05:46 <c_wraith> phaazon: I'm saying the stuff in Bifunctor is source-compatible with the pair-manipulation aspect of functions from Control.Arrow, except for (&&&)
14:06:01 <c_wraith> phaazon: first and second on tuples work the same as first and second on tuples. :)
14:06:07 <EvanR> orion: try flip finally (closeChannel ...) $ do
14:06:48 <orbifx> EvanR: that comment wasnt for me right?
14:06:53 <EvanR> orbifx: right
14:07:03 <phaazon> c_wraith: :P
14:07:10 <EvanR> orion: or put the do block in parens, followed by `finally` closeChannel ...
14:08:38 <phaazon> now that I know prounctors
14:08:40 <phaazon> profunctors*
14:08:43 <phaazon> I use lmap everywhere
14:08:48 <phaazon> it’s so powerful :3
14:09:13 <orion> EvanR: Thank you!
14:10:41 <ReinH> c_wraith: anyway I'd prefer to just have the specialized version of (&&&) called fanout with type (a -> b) -> (a -> c) -> a -> (b, c)
14:11:01 <c_wraith> ReinH: It's nice for it to have a short infix name, though
14:11:20 <ReinH> c_wraith: Sure, but I generally don't need all the arrow machinery
14:17:49 <phaazon> hm
14:18:04 <phaazon> isn’t there a way to install a binary in a cabal sandbox? :(
14:18:25 <c_wraith> doesn't cabal install just do that?
14:18:32 <phaazon> no :(
14:18:40 <phaazon> I don’t find my application in the sandbox
14:18:42 <c_wraith> I thought it did that, the problem was that it wasn't in your path
14:18:52 <phaazon> hm
14:18:54 <phaazon> riht
14:18:55 <phaazon> right*
14:18:57 <dcoutts> phaazon: sure, by default it's installed into the sandbox, but you can change the location, with cabal configure --bindir=
14:19:20 <phaazon> oh
14:19:25 <phaazon> .cabal-sandbox/bin/qzr
14:19:27 <phaazon> it’s there
14:19:31 <phaazon> great :)
14:21:15 <phaazon> thank you 
14:37:31 <duairc> Is there any way with wreq to supply a request body with a custom HTTP method? There doesn't seem to be, which is really annoying
14:40:02 <td123> is there a command equivalent to `bundle outdated` for cabal?
14:40:24 <td123> basically lists all the dependencies you depend on that have newer versions
14:44:01 <kqr> how do I runhaskell within a sandbox?
14:44:37 <sh1ken> How can I ask if a certain variable follows a certain data contruct form?
14:46:49 <hexagoxel> kqr: `cabal exec -- runhaskell` (if you don't have parameters, you can omit the --)
14:46:58 <kqr> hexagoxel, brilliant, thanks
14:47:34 <quchen> kqr: `cabal exec env` shows you the environment you have when using cabal exec
14:47:54 <quchen> kqr: It just sets an environment variable to connect to the sandbox
14:49:08 <kqr> ah, elegant
14:53:45 <pavonia> sh1ken: You can use pattern matches, e.g. with a case switch
14:55:40 <pavonia> duairc: Can't you use customMethod for this?
14:55:51 <sh1ken> pavonia: Indeed. I'm using case switch but I think that I need to nest really deep in the structure to get what I want.
14:55:58 <sh1ken> That's the common way to do it, right?
14:56:25 <pavonia> Depends on what you are trying to do, I'd say
15:01:09 <sinelaw> bergmark, did you release edit-distance that's ghc 7.10 - compatible?
15:01:35 <sinelaw> (looks like you didn't)
15:10:42 <bergmark> sinelaw: no an admin needs to do that
15:10:56 <sinelaw> bergmark, did you try reaching the maintainer?
15:11:24 <bergmark> i sent him an e-mail today
15:12:03 <sinelaw> ok, thanks
15:12:29 <sinelaw> bergmark, you can also send a pull request on your ghc 7.10 fix, not sure if you did or not
15:20:20 * hackagebot octohat 0.1.3 - A tested, minimal wrapper around GitHub's API.  http://hackage.haskell.org/package/octohat-0.1.3 (stackbuilders)
15:27:45 <Luke> anyone know how to get the IP4 host and port from a Network.Socket.SockAddr?
15:27:51 <Luke> for logging
15:28:51 <glguy> Luke: For logging you can use "show"
15:30:01 <Luke> glguy: oh i'll look at the show instances and see if it's what I want- thanks
15:30:16 <arkeet> yeah, show for ipv4 addresses uses inet_ntoa 
15:30:17 <Luke> glguy: oh I'm already doing that actually. it prints out like ::[:23423]
15:30:29 <glguy> Luke: That's the IPv6 wildcard address
15:30:37 <arkeet> :: is the zero ipv6 address
15:30:41 <Luke> yeah i'm using ipv4 tho
15:30:46 <arkeet> okay, well you have an ipv6 address.
15:30:47 <arkeet> :p
15:31:01 <Luke> I want to print 0.0.0.0:23424 etc
15:31:16 <glguy> then you'll need to start binding to the IPv4 wildcard
15:31:17 <Luke> hmm why do I have an ipv6 address? i'm on a mac
15:31:26 <glguy> Mac has great IPv6 support
15:31:41 <Luke> I'm using connectTo and listenOn - i'm assuming that's doing ipv4 wildcarding?
15:31:58 <kadoban> Luke: Why do you want to pretend an IPv6 address in an IPv4 address, out of curiosity? Why not just log it as-is and call it good?
15:32:06 <glguy> It's normal to listen on the IPv6 wildcard because it works for both IPv4 and IPv6 connections
15:32:13 <Luke> glguy: ah
15:32:21 <glguy> (that's configurable, but it's the default)
15:32:27 <Luke> ok i didn't know
15:32:29 <Luke> thanks
15:33:01 <Luke> kadoban: I don't want to pretend it's IPv4 I just want to use IPv4 and didn't know why I was using 6
15:33:16 <arkeet> well you can bind to 0.0.0.0 if you really only want ipv4
15:33:53 <kadoban> Luke: Why do you want to use IPv4 only?
15:34:10 <Luke> kadoban: that's what my prod env is
15:34:21 <Luke> arkeet: thanks
15:34:44 <Luke> arkeet: the reason I'm not explicitly is because I'm using the connectTo wrapper around connect
15:34:51 <Luke> which doesn't allow you to specify bind host
15:35:30 <Luke> kadoban: see glguy's responses
15:36:56 <kadoban> glguy's responses seem like reasons to just go with the flow and allow IPv6 to me, heh.
15:38:02 <Luke> kadoban: exactly
15:38:34 <Luke> kadoban: my point is problem is solved already
15:39:33 <Luke> you can keep asking questions if you think it'll lead somewhere though
15:52:16 <phaazon> hm
15:52:30 <phaazon> what’s the extension name to partially alias?
15:52:33 <phaazon> like hm
15:52:38 <phaazon> type Foo = Maybe
15:52:58 <phaazon> or
15:53:02 <phaazon> type Fun = (->)
15:53:19 <phaazon> ghc raises an error currently
15:53:31 <Brads> What does $! mean? I was reading https://wiki.haskell.org/Monad/ST and saw it in the example
15:53:37 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/data-type-extensions.html#type-synonyms
15:53:46 <phaazon>     Type synonym ‘Interval’ should have 3 arguments, but has been given 2
15:53:59 <glguy> phaazon: There isn't an extension for that, it's just wrong
15:54:07 <phaazon> glguy: oh
15:54:12 <phaazon> I thought it would exist
15:54:14 <geekosaur> Brads: it's strict function application
15:54:26 <phaazon> thanks glguy 
15:54:50 <geekosaur> phaazon, with -XLiberalTypeSynonyms you can defer c hecking until the type synonym is used
15:55:05 <geekosaur> but it must be fully applied at that point
15:55:12 <geekosaur> type lambdas being a no-no
15:55:43 <phaazon> ok, I see
15:55:48 * glguy sets about reading https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/data-type-extensions.html#type-synonyms
16:01:22 <phaazon> hm
16:01:40 <phaazon> I don’t know what should I chose between [Event] or just Event for my FRP event stream
16:02:05 <phaazon> if I chose [Event], that requires me to scan and fold events in my behaviors
16:02:25 <phaazon> if I chose just Event, that means I have to call the step functions several types to inject all events in my stream
16:02:30 <phaazon> does it sound correct?
16:02:38 <phaazon> choose*
16:03:45 <lpaste> edwardk pasted “Leonardo random access lists” at http://lpaste.net/131066
16:04:00 <edwardk> ^- not quite sure what to do with these
16:04:07 <inst_> is 7.10.1 OSX-ready?
16:04:29 <edwardk> they were fun to construct though
16:05:03 <edwardk> ski: might be something you'd like
16:06:06 <edwardk> in theory i could use them in place of skew binary random access lists in https://github.com/ekmett/lca/blob/master/src/Data/LCA/Online.hs as they have a little less bookkeeping
16:07:04 <edwardk> what things do we have that use skew-binary numbers other than random-access lists?
16:07:58 <pavonia> edwardk: Is that an already known data structure? I can't find anything under that name
16:08:19 <arkeet> I guess it's just modelled after the Leonardo sequence.
16:08:21 <edwardk> pavonia: leonardo heaps are known. this uses the same recurrence to build a random access list
16:08:36 <edwardk> had the idea after dolio walked me through smoothsort
16:08:57 <edwardk> should match the asymptotics of a skew binary random access list
16:09:08 <pavonia> Ah, hadn't heard of that either
16:09:41 <edwardk> pavonia: https://www.fpcomplete.com/user/edwardk/online-lca <- is me using skew binary random access lists for online lowest common ancestor search
16:09:48 <arkeet> so what's the advantage?
16:10:11 <edwardk> not sure yet =)
16:10:15 <arkeet> :p
16:10:22 <edwardk> mostly just curious what to do with the recurrence
16:10:29 <arkeet> just doing it for science.
16:10:31 <edwardk> and it was fun working out how to do the branch logic
16:11:04 <edwardk> it uses the ability to count up/down in a fibonacci/leonardo sequence given two subsequent members
16:12:04 <edwardk> and i'd just been thinking about that because its the same trick that gives rise to how to deal with affine linear fractional transforms in the context of the nested LFTs i'm playing with for real number arithmetic
16:12:23 <edwardk> so it was a nice way to glue the world together for me
16:12:39 <edwardk> no idea what anybody else would do with it though
16:15:23 * hackagebot wai-cors 0.2.2 - CORS for WAI  http://hackage.haskell.org/package/wai-cors-0.2.2 (JonSterling)
16:21:44 <fragamus> has anybody here ever used a TSP Solver
16:24:08 <enthropy> do IP and SMT count?
16:25:02 <mniip> how would I go about counting how many elements does an intersection of 2 lists include
16:26:28 <hpc> what do you know about the lists?
16:26:47 <mniip> their length is small
16:26:50 <enthropy> length (intersect x y) -- but probably Ord will make it go faster
16:26:59 <mniip> yeah they're lists of ints
16:27:37 <hpc> use http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-IntSet.html#v:intersection
16:28:03 <enthropy> > intersect [1,1,1] [1]
16:28:04 <lambdabot>  [1,1,1]
16:28:22 <mniip> yeah lists consist of unique elements
16:39:17 <mnaser> http://pastebin.com/EkJxp06x .. i know the list currently contains all True false values, using *or* will get me a Bool.. but I'm not sure on how i would use it in this case
16:39:26 <mnaser> or at least this case of 'partial functions' 
16:41:21 <eacameron> Can anyone refer me to a good example of a monad transformer stack in a real project? I want to study it.
16:42:36 <pavonia> mnaser: What partial functions do you mean?
16:43:21 <mnaser> pavonia: the code above doesn't work because it returns [Bool] .. i'd like to apply the "or" function on it to make it return a single value
16:43:34 <mnaser> but or $ before it doesnt seem to work
16:43:47 <pavonia> :t or
16:43:47 <athan> eacameron: I suggest looking at yesod :)
16:43:48 <lambdabot> Foldable t => t Bool -> Bool
16:43:52 <athan> (but it might be difficult)
16:44:09 <pavonia> mnaser: Do you get an error message if you try it?
16:44:16 <mnaser> The same idea using list comprehension .. pythag as = not $ null [True | (a, b, c) <- as, a*a == b*b + c*c] .. I'm trying to do it via lambda
16:44:30 <eacameron> athan: Ok thanks. Any particular component?
16:44:38 <pavonia> > or $ map (\(a, b, c) -> a*a == b*b + c*c) [(1, 2, 3), (10, 6, 8)]
16:44:39 <lambdabot>  True
16:44:54 <athan> eacameron: Most of it, honestly (I haven't played with it in a while)
16:45:04 <duairc> pavonia re: wreq, customMethod provides no way (that I can see) to supply a request body
16:45:11 <athan> but, you might want to check out Scotty, too - but getting the transformer hoisted is a pain
16:45:16 <athan> actually, eacameron, check out Lucid :)
16:45:24 * hackagebot pred-trie 0.0.5 - Predicative tries  http://hackage.haskell.org/package/pred-trie-0.0.5 (athanclark)
16:45:33 <athan> runTextT will give you the text output, wrapped in your monad
16:45:40 <athan> eacameron: I use it often with this project:
16:45:42 <mnaser> pavonia: if you run that code and compile it .. it doesn't work tho :|
16:45:49 <athan> @hackage urlpath -- eacameron
16:45:49 <lambdabot> http://hackage.haskell.org/package/urlpath -- eacameron
16:46:13 <mnaser> pavonia: http://pastebin.com/J3w0bDDy
16:46:33 <eacameron> athan: Sweet! Thanks a bunch. I have a look.
16:46:45 <athan> :)
16:47:14 <pavonia> mnaser: If you don't add the list parameter, you have to use function application (.) instead of function application ($)
16:47:29 <pavonia> Err, function *composition (.)
16:47:29 <geekosaur> that firtst `application` should be `composition`
16:48:05 <mnaser> ooh okay
16:48:14 <mnaser> i understand
16:48:32 <edwardk> arkeet: ok, i have something it might be good at
16:48:33 <mnaser> because composition 'merges' them where as application really tries to apply the "or" first and breaks things, if im correct?
16:48:43 <mnaser> and because composition merges them, the whole thing runs together
16:48:58 <edwardk> arkeet: e.g. something like http://www.cs.au.dk/~gerth/papers/esa06skew.pdf
16:50:02 <pavonia> mnaser: (.) chains two function to another one, while ($) applies a function to an argument
16:50:47 <edwardk> in theory the ratio of weights between the left and right side of the tree is more or less near the optimal alpha in that paper
17:00:25 * hackagebot crypto-classical 0.0.1 - An educational tool for studying classical cryptography schemes.  http://hackage.haskell.org/package/crypto-classical-0.0.1 (fosskers)
17:04:14 <pavonia> duairc: Have a look at the postPayload and putPayload functions, they seem to be used to add some data to a request
17:12:25 <Brads> is there a way to do something like a while loop using ST? I know a little bit about forM_
17:12:47 <Axman6> @hoogle while
17:12:49 <lambdabot> package while-lang-parser
17:12:49 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
17:12:49 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
17:12:54 <Axman6> hmm
17:12:57 <Axman6> @hoogle whileM
17:12:58 <lambdabot> No results found
17:13:12 <Axman6> it's pretty easy to write yourself one
17:15:35 <pavonia> monad-loops has one
17:18:56 <arkeet> @hackage monad-loops
17:18:56 <lambdabot> http://hackage.haskell.org/package/monad-loops
17:41:00 <akurilin> question: when I profile haskell apps, why does it give me a super log "total time" ? e.g. say I run the app for 2 hours, it will give me a "total time" of 500s
17:41:15 <akurilin> is that how long profile haskell code spent being executed in that period of time?
17:57:42 <geekosaur> at a guess, that's CPU time --- actual time your code was running, vs. waiting for IO or in the kernel or waiting while other processes on the system did things?
17:59:28 <geekosaur> (although CPU time is often divided between user and system; the latter is time spent in the kernel running syscalls, excluding time blocked on I/O in the kernel)
17:59:43 <akurilin> I'd guess so. This was taken from a very slow time of the day when I barely get 2% of CPU use
18:13:01 <Owls> I'm working on an assignment for school and I keep running into errors that make no sense. My code is currently http://lpaste.net/7986728648847654912 My issue is that when I try to load it, it says "parse error on input 'visit'" for line 35.
18:14:19 <kadoban> Owls: There's 28 lines in that paste.
18:14:38 <Hafydd> Owls: if you want multiple monadic actions in a branch of an if statement, you have to enclose them in a do block.
18:14:45 <geekosaur> there is no line 35 in there. if it's actually referring to line 21 of the paste then there's at least two problems, one indentation and one incorrectly assuming that the `do` extens inside the `if`
18:14:56 <Owls> Sorry. Line 21
18:15:38 <Owls> So I need to throw a 'do' after 'then'?
18:16:59 <shachaf> When you have an error, you should add the full error to your paste, not just quote a small part of it.
18:17:16 <geekosaur> also fix indentation on line 21, needs to be the same as line 20
18:18:12 <Owls> Ok. I had the bad indentation because it got rid of some errors. Which is weird to me. 
18:19:03 <Hafydd> Heh.
18:19:08 <Hafydd> Nice troubleshooting technique.
18:20:00 <geekosaur> it probably did, by introducing other ones
18:20:11 <xelxebar_> anyone familiar with Posix stuff? I have separate files and I essentially want to "union" them dynamically. So I wrote a really simple script that just cats the contents into a named pipe in a tight loop. However, it needs an explicit threadDelay to make it work. Why? And am I grossly doing something Bad (TM)? Here's the source http://ix.io/i1r/haskell
18:21:52 <hjulle> > words $ unwords ["","x",""] -- Why is words not the inverse of unwords?
18:21:53 <lambdabot>  ["x"]
18:22:04 <hiptobecubic> hjulle, how would that work?
18:22:14 <hiptobecubic> hjulle, how many empty strings are in "foo" ?
18:22:16 <Axman6> how could it be?
18:22:28 <Axman6> > unwords ["","x",""]
18:22:29 <lambdabot>  " x "
18:22:48 <srhb> xelxebar_: Egads, the pointlessness. 
18:22:51 <hjulle> As many as there are white spaces + 1
18:22:56 <srhb> xelxebar_: cat is hard to read :P
18:23:08 <stoopkid> anybody got experience running a web-server in haskell?
18:23:08 <hiptobecubic> hjulle, at the very least, it compresses whitespaces
18:23:21 <Axman6> > words "a   c" -- you seem to want this to be ["a","","","","c"] but that's useless because it doesn't actually give you the words, just repeatedly splits on space
18:23:22 <lambdabot>  ["a","c"]
18:23:23 <srhb> stoopkid: Yes, many of us.
18:23:27 <hiptobecubic> > unwords ["", "", ""]
18:23:29 <lambdabot>  "  "
18:23:46 <Axman6> srhb: man, I was going to say almost exactly that, heh
18:23:57 <stoopkid> srhb, is there like a "standard" setup for this like similar to LAMP systems
18:23:57 <srhb> Axman6: Not a man. But yes. :P
18:24:00 <hiptobecubic> > unwords ["  "]
18:24:01 <lambdabot>  "  "
18:24:08 <hjulle> Axman6, Is there a function which does that? 
18:24:12 <srhb> stoopkid: Mostly each framework provides its own web server
18:24:27 <srhb> stoopkid: The exception (I think) is the warp server, which several frameworks use via the wai interface
18:24:41 <Axman6> hjulle: does what, splits on a certain character?
18:24:56 <srhb> stoopkid: I don't think anyone in Haskell land ever uses MySQL, but often Postgres with various interfaces. Persistent is common in Yesod.
18:24:58 <xelxebar_> srhb: yeah, that could probably be written more lucidly
18:25:01 <hjulle> Axman6, Yes.
18:25:02 <hiptobecubic> hjulle, Data.List.Split.splitOn ?
18:25:21 <srhb> xelxebar_: I'm not sure about the problem though. It does seem weird. Are some of those fd operations nonblocking?
18:25:25 <geekosaur> xelxebar_, what does it do if you don't have the threadDelay?
18:25:27 <Axman6> > splitOn ' ' " a  c x"
18:25:28 <lambdabot>      Couldn't match expected type ‘[Char]’ with actual type ‘Char’
18:25:28 <lambdabot>      In the first argument of ‘splitOn’, namely ‘' '’
18:25:28 <lambdabot>      In the expression: splitOn ' ' " a  c x"
18:25:55 <srhb> stoopkid: And of course, Haskell is the hosted language.
18:25:59 <xelxebar_> srhb, geekosaur: I'm trying to get a pastebin of the error for you. just a sec
18:25:59 <geekosaur> that said, (a) there are some oddities with named pipe handling in ghc's runtime; (b) named pipes have oddities of their own, quite unrelated to Haskell
18:26:01 <hjulle> I just encountered a bug in a program which is caused by the author assuming that behaviour (it being the inverse of unwords) in 'words'.
18:26:05 <srhb> xelxebar_: Cool :)
18:26:14 <Owls> > splitOn " " " a  c x"
18:26:15 <lambdabot>  ["","a","","c","x"]
18:27:33 <geekosaur> in particular, if the program reading from the fifo doesn't close and reopen quickly enough, your reopen will behave incorrectly
18:28:04 <geekosaur> I vaguely recall that ghc's runtime doesn't handle opens that can block, and fifos are a pathological case of that
18:28:36 <hjulle> Nice, thanks everyone. I believe that (splitOn " ", unwords) is an isomorphism in general?
18:28:59 <Tekmo_> Not necessarily
18:29:03 <srhb> stoopkid: To throw a few framework names to Google at you, in the order of most used (I think): Yesod, Snap, Happstack, Scotty, Spock. Those last three seem subject to change rapidly.
18:29:05 <Axman6> no
18:29:29 <Tekmo_> splitOn " " . unwords /= id
18:29:30 <Axman6> > splitOn " " $ unwords [""," ",""]
18:29:31 <lambdabot>  ["","","",""]
18:29:52 <Tekmo_> The counter-example is when you supply `unwords` with a list of words that are not actually words (i.e. they have spaces in them)
18:30:29 <xelxebar_> srhb, geekosaur: here's the error: http://ix.io/i1s
18:30:43 <Axman6> I believe it cannot be true, since indormation is lost by unwords
18:30:48 <Axman6> information*
18:31:00 <xelxebar_> not super informative. foobar.hs is the script, and the second 'foobar' there is the named pipe
18:31:39 <xelxebar_> geekosaur: well, it seems to block fine with that delay in there
18:32:18 <xelxebar_> geekosaur: I also have a shell script doing the same thing and it also needs a `sleep` call
18:32:24 <Tekmo_> You can make it isomorphism if you change the type of `unwords` to require a list of strings without spaces
18:32:40 <hjulle> Axman6, Yes, of course. I didn't think about that case. If the strings in the list contains no spaces, then splitOn " " . unwords /= id, otherwise not.
18:32:40 <Tekmo_> You can't easily do that in Haskell, but you could probably do it in a dependently typed language, I guess
18:33:01 <hjulle> s_/=_==_
18:33:13 <xelxebar_> geekosaur: I even tried writing a C script and ended up needing to sleep the loop there too. So I feel like I'm not understanding something fundamental here
18:33:16 <srhb> xelxebar_: If that's a POSIX thing, the more robust solution could be to wait until it actually does exist, rather than a specific sleep?
18:33:17 <geekosaur> ENXIO is kernel level. come to think of it, I think that's what happens with an O_NONBLOCK open with nothing on the other side,
18:33:26 <srhb> Then again, that wait would have to be slept too
18:33:38 <geekosaur> srhb, it exists
18:33:48 <srhb> Oh. Nevermind me then.
18:34:06 <geekosaur> what doesn't necessarily exist is something on the other side of the fifo (that is, opening or blocked on open for read)
18:34:11 <srhb> Yeah.
18:34:25 <geekosaur> and this is one of the ugly corner cases that make POSIX FIFOs annoying to work with
18:34:45 <xelxebar_> srhb: yeah, I can run the script and the pipe will exist. then in another shell I'll cat it and get the concatted output multiple times before the error
18:34:52 <srhb> There's no way to open it and block until something's on the other end?
18:35:04 <srhb> Well, aside from manually retrying.
18:35:15 <geekosaur> well, ghc runtime specifically avoids blocking operations
18:35:59 <geekosaur> in theory a nonblocking open for write should wait for a reader to open, but throwing ENXIO is within POSIX and in particular Linux has been prone to taking that route
18:36:18 <srhb> Bleh.
18:36:19 <geekosaur> the customary way to use a FIFO is to open it O_RDWR, but then you lose EOF
18:37:25 <geekosaur> basically, FIFOs are pathological and it's often better to find some other way to do whatever it is, because many "obvious" uses don't actually work
18:38:16 <xelxebar_> geekosaur: If pipes aren't the way to go here, I'll be happy to drop them. Essentially, I have two files, foo and bar, and a client that wants to read the concatenated contents of both at filename foobar
18:38:18 <srhb> In this case, would openFileBlocking on the receiving end work?
18:39:41 <geekosaur> more appropriate workaround might be to catch the exception from open and threadDelay a bit
18:39:42 <xelxebar_> srhb: I don't have control over the receiving end. It's expecting a single file
18:39:43 <hjulle> I guess that there is nothing like Data.List.Split.splitOn in base? I prefer to reduce the amount of dependencies, especially when I just use one function once.
18:39:48 <srhb> Ah
18:40:43 <geekosaur> hjulle, no. but we generally assume you have more than base
18:41:15 <geekosaur> base is *removing* stuff not absolutely needed for ghc itself; the assumption is that you have the Platform, or the Stackage equivalent, installed
18:41:22 <hjulle> Is split in the haskell platform?
18:41:26 <xelxebar_> geekosaur: that's a bit cleaner. Could you point me in the right direction to see how I should catch the exception?
18:41:36 <geekosaur> yes
18:41:44 <hjulle> ah. ok
18:42:43 * geekosaur sighs at crappy local network as he tries to load the right documentation...
18:42:53 <geekosaur> anyway it's stuff in Control.Exception
18:43:08 <xelxebar_> geekosaur: okay. thanks. I'll take a look
19:16:44 <sydneyhacker2015> Hello, I am doing the Nicta course https://github.com/NICTA/course/tree/master/src/Course, and I am confused as why they are asking us to define <$> for Applicative when it is already defined for Functor, and an Applicative is a Functor.
19:17:33 <sydneyhacker2015> Infact <$> is already working for me in the examples e.g. (+1) <$> (Id 2) even though the (<$>) is defined to return an error
19:17:35 <shachaf> Probably the question is "if Functor wasn't a superclass of Applicative, how would you define fmap"?
19:17:36 <dibblego> sydneyhacker2015: it is asked, because when the course is run, it is usually done in-person (it was done last week in Sydney). The goal here is to redefine (<$>) using pure and (<*>) to demonstrate to yourself that the Applicative primitives give rise to the Functor.
19:18:11 <dibblego> sydneyhacker2015: you will notice that the import/export list carefully makes sure that this particular (<$>) is not available outside the module, so it doesn't clash with the one that you have already defined in Functor.
19:18:16 <shachaf> Reusing the name (<$>) is confusing.
19:18:26 <shachaf> "fmap defined with Applicative" is usually called "liftA".
19:18:27 <dibblego> sydneyhacker2015: ultimately, the goal is to learn that, "if you have Applicative, you can derive Functor"
19:18:39 <SparkySparkyBoom> hi
19:18:47 <SparkySparkyBoom> im just learning haskell
19:18:58 <dibblego> well, it used to be called Fluffy/furry  the idea of which names are/not confusing is a lengthy, ongoing discussion
19:19:11 <SparkySparkyBoom> why does !! not return `Maybe a`?
19:19:13 <sydneyhacker2015> so my problem is I am loading all the modules? I am using the .ghci script
19:19:34 <dibblego> sydneyhacker2015: what problem might you be having? the exercise is to redefine (<$>) using pure and (<*>).
19:20:43 <sydneyhacker2015> dibblego: I would expect <$> to retun an error given the default NICTA implementation, but it is finding the Functor implementation I wrote earlier
19:21:10 <slack1256> SparkySparkyBoom: it probably make sense to use `Maybe a` on (!!). But using a list as an array (with indexes) is not good practice.
19:21:24 <dibblego> sydneyhacker2015: I am not sure what you mean. You can rename (<$>) to be anythingelse, then do the exercise. What happens now?
19:22:56 <slack1256> SparkySparkyBoom: Also, if you look at the `vector` package, they implement `!?` which has your type signature for vectors
19:24:14 <fragamus> Well I have been using haskell for a number of years now...
19:24:33 <fragamus> I think I am ready to read "A Gentle Introduction to Haskell"
19:25:03 <sydneyhacker2015> dibblego it is not in scope. I need to look at the modules they load by default. Maybe applicative is not one.
19:25:30 <dibblego> sydneyhacker2015: can you be specific with the exercise you are attempting, how you've attempted it, and the error you are receiving?
19:27:43 <sydneyhacker2015> Applicative.hs line 44. I didn't change the code, so the implementation is (<$>) =  error "todo". And I can happy use <$> due to the functor. I am using ghci, loading the .ghci file in the root directory, which loads Course.hs, which imports all of the modules
19:28:08 <sydneyhacker2015> If I change the function name to say abc then it isn't found
19:28:20 <dibblego> ok, yeah I think maybe it is used elsewhere in that file
19:28:50 <dibblego> (<$>) = error "todo: implement this using (<*>) and pure"
19:30:43 <fragamus> :t pure
19:30:44 <lambdabot> Applicative f => a -> f a
19:31:23 <sydneyhacker2015> dibblego: I can just rename and export it to play with it in ghci for now
19:31:29 <sydneyhacker2015> thanks for your help
19:31:39 <dibblego> ok
19:31:47 <sydneyhacker2015> also this is a real course? so can anyone apply or is it just for nicta employees?
19:32:11 <Welkin> sydneyhacker2015: is this real life?
19:32:16 <dibblego> sydneyhacker2015: yes, it is a real course, and many people do it  not just NICTA. Last week, I did it with some people from a different company.
19:32:54 <sydneyhacker2015> Welkin, I mean is it a physical course, or only online
19:32:54 <SparkySparkyBoom> slack1256: thank you
19:33:11 <SparkySparkyBoom> is there a safe way to use head?
19:33:33 <sydneyhacker2015> dibblego ok so how would I go about getting on the course?
19:33:44 <slack1256> SparkySparkyBoom: pattern matching it the go to way for lists
19:33:49 <SparkySparkyBoom> ah
19:34:01 <Welkin> SparkySparkyBoom: or wrap it in your own function with error checking
19:34:02 <dibblego> sydneyhacker2015: join this mailing list. We plan on doing it again this year in Sydney, hopefully soon. https://groups.google.com/group/nicta-fp
19:34:11 <Welkin> and produce a Maybe
19:34:23 <Welkin> maybeHead :: [a] -> Maybe a
19:34:29 <sydneyhacker2015> dibblego: thanks
19:34:34 <SparkySparkyBoom> ah
19:35:33 * hackagebot diagrams-builder 0.7.0.1 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.7.0.1 (BrentYorgey)
19:36:30 <slack1256> yeah, you can do as Welkin says, but you still will have to pattern match on the `Maybe`. If you are going to pattern match anyways, why not do it on the list to begging with?
19:38:44 <Axman6> sydneyhacker2015: you could also move to Canberra and do one sooner =) there are (tentative) dates for that course
19:39:51 <slack1256> *begin with
19:41:46 <SparkySparkyBoom> slack1256: pattern matching on lists is uglier?
19:42:01 <SparkySparkyBoom> it's a superficial reason, ik
19:43:48 <slack1256> Mmm I think it's nice, but hey! experiment with all the approaches, you will find what fits you the most.
19:43:54 <sydneyhacker2015> Axman6: thanks might be a nice excuse for a trip to that big bad city. however I am a Haskell addict so I will probably finish this myself before I get on a course.
19:44:55 <Axman6> "Big bad city" sounds like a highly inaccurate discription of Canberra, in all three cases :P
19:46:16 <sydneyhacker2015> Axman6: :-) I've been there once to watch an MMA match, seems like a nice town
19:46:19 <Axman6> sounds like an excellent description of Sydney though :P
19:46:47 <Axman6> it's the greatest town on earth - that's why we keep letting people think it's a shithole
19:50:52 <stoopkid> has anybody used the apache+hyena+haskell setup?
19:51:28 <stoopkid> other thing i was looking at was happstack
19:52:38 <szatz> hey, all. i'm looking to do a short presentation using haskell that will have some live coding. i plan on showing more than one way to define a function and would like to simply save and :r in my ghci session, but redefinition is not allowed in a file. is there a way to override that?
19:53:12 <fragamus> ...so, infix constructors that begin with a colon are allowed in data declarations
19:53:44 <fragamus> that explains some weird stuff I have seen 
19:54:00 <dmj`> szatz: why not define functions w/ primes... like f :: Int -> Int, f' :: Int -> Int
19:54:48 <szatz> dmj`: i suppose that's a possibility, but i'd like to have them have the same name so that if i have some function that calls the original, i can show the same value is produced without changing that reliant function.
19:54:50 <Axman6> stoopkid: what do you need apache for? haskell webservers are very good (for many things anyway)
19:55:40 <dmj`> szatz: it's impossible to define a function with the same name twice
19:55:58 <Axman6> well, no, it's not. you can use let in ghci to do that
19:56:05 <Axman6> but anything using the old definition will keep using it
19:56:07 <dmj`> Axman6: shadowing
19:56:08 <davidshore> how would it know where one definition ends and another begins?
19:56:28 <dmj`> Axman6: yea, I should have said, "in ghc"
19:56:43 <slack1256> davidshore: scopes?
19:56:50 <Axman6> ghci has :{ and :} to allow multiline definitions, if that's what you're asking davidshore 
19:56:51 <dmj`> Axman6: but that behavior in ghci is crafty
19:56:56 <Axman6> yes
19:57:02 <szatz> Axman6: yeah, let would work, but i want to quickly get it into the repl without copy+paste, and vim-slime puts let in front of some things that shouldn't have a let in front. :(
19:57:25 <szatz> dmj`: OK. i knew there was unsafe io, and was just wondering if there was some unsafe declaration kinda thing.
19:57:27 <dmj`> haskell-mode emacs will clear all previous let bindings when you send to repl
19:58:17 <Cale> szatz: You can comment out the old definition of course, but it's harder to demonstrate that two things are equal if you don't have distinct names for them
19:58:45 <Axman6> stoopkid: also, hyena (assuming you mean http://hackage.haskell.org/package/hyena) is 5 years old, there are much better tools these days
19:58:56 <Axman6> stoopkid: what do you actually want to make?
19:58:57 <dmj`> szatz: you can't get around the ambiguity though, ghc is confused, commenting and uncommenting might be your best bet
19:59:14 <szatz> Cale: well, i planned on showing a call to the original function in the repl and its output, then showing some other way to define it, then showing that.
19:59:22 <Cale> szatz: One option might be to take the function as a parameter
19:59:37 <Cale> szatz: So you can name the two versions of it differently, and try passing each of them
19:59:46 <dmj`> stoopkid: nginx w/ snap/yesod/scotty/happstack would make more sense
20:00:19 <szatz> Cale: yeah, another possibility, but i'd like to not do that much changing of other things. commenting might be the way.
20:00:32 <dmj`> Cale: that's a good idea
20:00:42 <dmj`> szatz: use a higher order function
20:01:00 <dmj`> then you can just send it all to the repl and demo it there
20:02:05 <szatz> dmj`: that could work. let me do a little and see how it looks.
20:05:26 <stoopkid> Axman6, dmj` sorry had to go afk for a min, well, right now i'm trying to make a prototype for what will ultimately be a large database, partially community edited like wikipedia, and i was looking at using haskell to run it
20:05:58 <stoopkid> right now i wont have much data and traffic so i'm just building a system on some computers at home
20:06:05 <stoopkid> for the protoype
20:06:07 <dmj`> szatz: let a = (+1); b = \x -> x + 1; f g x = g x, then in the repl just do g a 1, g b 1
20:06:34 <dmj`> szatz: er f a 1, f b 1
20:06:47 <Axman6> stoopkid: take a look at Yesod, it's pretty nice for those sorts of apps
20:07:12 <dmj`> stoopkid: check out snap too, http://snapframework.com
20:08:38 <stoopkid> ok, ill try these out and see how that goes, thanks
20:11:32 <dmj`> stoopkid: snap 1.0 is nice, the MonadBaseControl let's you control all the monads in the base, so they don't get unhappy and out of line
20:18:56 <Axman6> dmj`: snap 1.0? latest blog post discussing snap releases says 0.13
20:19:45 <dmj`> Axman6: I clone from github
20:20:10 <dmj`> Axman6: and just use snap-server + snap-core
20:20:35 * hackagebot filediff 0.1.0.7 - Diffing and patching module  http://hackage.haskell.org/package/filediff-0.1.0.7 (bgwines)
20:20:37 <Axman6> is there much development happening with Snap these days?
20:20:46 <dmj`> Axman6: yes
20:21:41 <dmj`> Axman6: all major projects have been updated within past 10 days
20:22:02 <dmj`> Axman6: big changes to the server, io-streams based backend
20:24:37 <glguy> I like the snap-core/server route, to
20:24:38 <glguy> o
20:28:24 <szatz> dmj`: it's... working, but i think it makes it a little more difficult to understand for a general audience. i think i'm just going to put in lets where i need them, make vim-slime not auto-let, and just eval from vim. i appreciate the suggestions from you and Cale, though, so thanks!
20:40:35 * hackagebot hexstring 0.11.0 - Fast and safe representation of a hex string  http://hackage.haskell.org/package/hexstring-0.11.0 (solatis)
20:41:00 <solatis> anyone else is also getting backend read errors after uploading new packages to hackage? happened to me yesterday and today
20:56:46 <dfeuer> Does this look properly lazy? http://stackoverflow.com/a/29761761/1477667
20:57:17 <dfeuer> My limited tests suggest it works right, but it's a bit tricky.
20:58:25 <elben> I’m trying to use attoparsec to parse templatized English sentences. For example: “This is a {foo:bar}. This is a test.” I want my parser to transform this to: [Fragment “This is “, ArticleA, Directive foo bar, Fragment “. This is a test.”].Note that the first “a” is parsed as ArticleA, because it preceeds a Directive {foo:bar} (since I may need to transform it to an “an”). But the second “a” can be part of the Fragment. In my 
20:58:26 <elben> fragmentParser, how can I look-ahead to check that an “ a” isn’t followed by the start of a directive? My attempt: http://lpaste.net/47588551172292608
21:01:13 <dfeuer> elben, that sounds complicated. I wonder if Cale would know...
21:01:58 <glguy> (elben left) One way would be to lex the sentence first and then deal in words
21:02:55 <glguy> One way would be to lex the sentence first and then deal in words
21:03:00 <glguy> Another (probably better) way is to have a special way to write ArticleA explicitly (with nicer syntax) so that rather than it being magical that it could be controlled
21:03:50 <glguy> If you were working with words instead of characters you could easily take many words which weren't the word a immediately followed by a directive
21:05:44 <dfeuer> Hmm... this is not quite as lazy as I would like, but it may be as lazy as it can (reasonably) get. :-/
21:06:11 <dfeuer> Oh wait....
21:06:17 <dfeuer> Actually, that may be okay!
21:06:44 <dfeuer> Yeah, I think it is ...
21:07:21 <elben> Sorry, real shaky internet right now. The problem with dealing with words is that there isn’t a good separator between words. For example, “A {foo:bar}, test”, I can’t separate by space, due to the comma
21:10:37 * hackagebot bitcoin-tx 0.12.0 - Utility functions for manipulating bitcoin transactions  http://hackage.haskell.org/package/bitcoin-tx-0.12.0 (solatis)
21:10:38 <elben> The special syntax would indeed be easier. Maybe something like this (http://stackoverflow.com/questions/20894973/is-it-possible-to-efficiently-look-ahead-more-than-one-char-in-attoparsec) could work. Still complicated it seems. I tried peekChar but don’t know how to use it past one char.
21:12:58 <elben> glguy: thanks for the suggestions. Internet too poor to stay on, but I’ll think if tokeniznig to words would help (and how to solve non-space-delimited words.
21:17:22 <solatis> rats, i could've helped elben out
21:17:43 <glguy> If elben comes back you can teach about "try"
21:17:51 <solatis> he's looking at it the wrong way and should use backtracking
21:18:04 <solatis> yeah exactly :)
21:20:04 <dfeuer> Anyone willing to take a look at http://stackoverflow.com/a/29761761/1477667 and see if you think I got it right?
21:45:38 * hackagebot ssh 0.3 - A pure-Haskell SSH server library.  http://hackage.haskell.org/package/ssh-0.3 (GaneshSittampalam)
22:11:40 <CapitalSigma> hey all
22:12:15 <CapitalSigma> i'm trying to write an instance of Foldable for BST's that will let me check if they have the BST property (inorder traversal strictly decreasing)
22:13:21 <CapitalSigma> i've defined "instance Foldable BST = ..." pretty much the same way the documentation for Foldable says, but i'm getting a type error trying to define "isBST = fold (<)"
22:13:37 <CapitalSigma> "Could not deduce (Monoid Bool) arising from a use of `fold'..."
22:13:40 <CapitalSigma> what am i missing?
22:13:48 <shachaf> Why are you defining "isBST = fold (<)"?
22:14:50 <CapitalSigma> shachaf: a binary search tree is valid iff the elements are strictly decreasing in an inorder traversal
22:15:01 <shachaf> OK.
22:15:09 <shachaf> How do you get from that to "fold (<)"?
22:15:44 <CapitalSigma> shachaf: fold will traverse the tree from left to right, applying < on what's inside each node, right?
22:16:12 <shachaf> :t fold
22:16:12 <monochrom> wait, does fold (<) even type-check?
22:16:13 <lambdabot> (Foldable t, Monoid m) => t m -> m
22:16:25 <CapitalSigma> monochrom: no
22:16:50 <arkeet> :t fold (<)
22:16:51 <lambdabot>     Could not deduce (Monoid Bool) arising from a use of ‘fold’
22:16:51 <lambdabot>     from the context (Ord a, Foldable ((->) a))
22:16:51 <CapitalSigma> that's what i'm confused about
22:16:51 <lambdabot>       bound by the inferred type of
22:17:03 <shachaf> You know the type of "fold".
22:17:14 <shachaf> t m -> m, for any Monoid m.
22:17:32 <shachaf> So in your expression, (<) must be :: t m.
22:17:34 <CapitalSigma> ah, okay, so that's very wrong
22:17:50 <joneshf-laptop> but
22:17:51 <shachaf> I can just say "no" but I wonder what thought process led to that expression.
22:17:51 <monochrom> all confusions come from wrong assumptions
22:17:58 <joneshf-laptop> `fold` isn't directed, is it?
22:18:13 <CapitalSigma> shachaf: foldl is what i'm looking for, i suppose, although i'm not sure how to define the base case
22:18:49 <arkeet> it could be done with a foldl. but maybe not in a way you think.
22:18:51 <monochrom> foldl (<) will type-check but it will also be forced to Bool
22:19:01 <monochrom> @type foldl (<)
22:19:01 <lambdabot> Foldable t => Bool -> t Bool -> Bool
22:19:16 <CapitalSigma> akurilin: why not?
22:19:27 <CapitalSigma> monochrom: i have a BST of Ord a
22:19:49 <monochrom> then foldl (<) will not care about your BST, as shown.
22:20:01 <monochrom> it only cares about Bool and t Bool.
22:20:23 <arkeet> let's throw two things that are vaguely related to my problem together, certainly it'll work.
22:20:33 <arkeet> okay. say I gave you a list.
22:20:36 <shachaf> I would say, start with toList :: BST a -> [a]
22:20:36 <arkeet> how would you check if it's in order?
22:20:38 <CapitalSigma> monochrom: okay. well, i know that if it was a list, i could foldl over it to ensure that it's strictly increasing
22:20:44 <arkeet> how would you do that?
22:20:52 <arkeet> write the code that does that.
22:21:24 <monochrom> do you understand "Bool -> t Bool -> Bool"?
22:21:40 <monochrom> at best, "t Bool" becomes [Bool], if you want list
22:21:53 <CapitalSigma> monochrom: yes, i understand
22:22:06 <monochrom> this only cares about list of Bools, not list of whatever data you have in mind.
22:22:16 <CapitalSigma> arkeet: i'd need to compare against some artificially low number
22:22:22 <arkeet> forget about foldl.
22:22:35 <arkeet> from scratch, how would you do it?
22:22:36 <arkeet> for a list
22:23:21 <CapitalSigma> inOrder (x:y:xs) = (x < y) && inOrder (y:xs)
22:23:32 <CapitalSigma> inOrder (y:[]) = True
22:23:38 <arkeet> okay.
22:23:52 <arkeet> see how you are comparing pairs of successive elements
22:24:02 <arkeet> folding does not let you do this.
22:24:16 <arkeet> (at least, not in an obvious manner.)
22:24:28 <CapitalSigma> arkeet: ah, you're right, i'm just completely off base
22:24:53 <arkeet> but it can be done.
22:25:12 <kadoban> You can still do it, but you have to make it a little more interesting than (<)
22:25:15 <arkeet> right.
22:25:32 <arkeet> for example, you could let the accumulator be a pair:
22:25:53 <arkeet> containing a Bool, indicating whether the list is in order so far, and also containing the last element that was fed in.
22:26:01 <CapitalSigma> arkeet: 
22:26:06 <CapitalSigma> okay, that makes sense
22:26:38 <CapitalSigma> probably the most natural solution would be to have something like (\x y -> Just y if x < y else Nothing)
22:26:41 <arkeet> unfortunately, using foldl or foldl' forces you to traverse the entire list, even if you know partway through that it's not in order.
22:26:56 <arkeet> yes, that is even better. 
22:27:02 <CapitalSigma> is there a nice way to propogate down the Nothing using the Maybe monad? 
22:27:18 <arkeet> with some modification it would even work.
22:27:24 <CapitalSigma> i'm an SML programmer trying to wrap my head around typeclasses
22:28:26 <arkeet> you could probably profitably use foldlM on the Maybe monad or something, so that you can exit early once you see that the list isn't in order.
22:28:42 <augur> CapitalSigma: so you know how in ML you can specify a signature for a module, and have multiple implementations for various types?
22:29:06 <joneshf-laptop> is there any benefit to forcing it into a fold rather than just writing a recursive implementation?
22:29:19 <CapitalSigma> augur: yes, i understand the purpose of typeclasses, i'm trying to pick up on the elegant ways to write code with them
22:29:33 <augur> CapitalSigma: and then you do something like   Mod1.foo x   and   Mod2.foo y   to call the foo function from the module at different types
22:29:33 <arkeet> joneshf-laptop: well, you can make it work for an arbitrary Foldable this way. although you might just want to use toList and do a list-specific one.
22:30:07 <joneshf-laptop> arkeet, i thought the `Foldable` was already determined?
22:30:26 <arkeet> joneshf-laptop: I mean then you could use the foldl from Foldable.
22:30:30 <augur> CapitalSigma: type classes are basically like that, only Haskell figures out the "Mod1" and "Mod2" stuff for you. so that's how you write code elegantly with type classes -- same as you do with ML modules
22:31:06 <arkeet> okay, here is an even better idea. it is even more better than any other idea.
22:31:35 <augur> not exactly the same, but at least in the dimension where you're using modules to wrap up instantiations of functionality
22:31:36 <arkeet> I will define a monoid.
22:31:52 <arkeet> the idea is that
22:32:03 <arkeet> given a structure,
22:32:16 <arkeet> I will fold it into a value in this monoid that tells me one of three cases:
22:32:30 <arkeet> the structure is empty (and thus trivially in order),
22:32:43 <joneshf-laptop> maybe I don't understand what the issue is here all that well. I thought CapitalSigma just wanted to see if a BST was "valid"
22:32:45 <arkeet> the structure is in order but nonempty, and I hold onto the smallest and largest element
22:32:48 <arkeet> or, the structure is not in order.
22:33:17 <CapitalSigma> joneshf-laptop: yes, i do
22:33:18 <arkeet> now if I have a big structure, split in half, and I know which of these cases holds for each half,
22:33:33 <arkeet> I can very easily combine that data to tell me what how it is for the whole structure.
22:33:45 <arkeet> and then you just foldMap.
22:40:40 * hackagebot notmuch-haskell 1.0.0.3 - Binding for notmuch MUA library  http://hackage.haskell.org/package/notmuch-haskell-1.0.0.3 (BartonMassey)
22:40:43 <lpaste> arkeet pasted “testing for increasingness monoidally” at http://lpaste.net/131095
22:40:44 <arkeet> ^^
22:43:24 <arkeet> I think it's pretty.
22:44:18 <jle`> it's cute :3
22:44:23 <arkeet> :3
22:44:28 <joneshf-laptop> very nice
22:45:19 <jle`> can't see immediately why you need two fields for the Inc constructor
22:45:38 <arkeet> they hold the smallest and largest values of the structure.
22:45:41 <arkeet> (if it's increasing.)
22:46:05 <jle`> ah. but it's not necessary for just finding out if something is monotonic or not right?
22:46:09 <arkeet> yes it is.
22:46:19 <arkeet> if you have two structures that are in order,
22:46:27 <arkeet> how do you know whether their concatenation is in order?
22:46:40 <arkeet> you have to compare the largest element of the first with the smallest element of the second.
22:47:34 <jle`> oh i see it's required for associativity
22:47:45 <arkeet> maybe that too.
22:47:46 <jle`> i was thinking about just the foldr/foldl case
22:48:20 <jle`> if you merge things one at a time then you only need to keep track of the maximum value seen so far, right?  and see if the next item is not smaller than the max so far?
22:48:37 <jle`> but if you subdivide and subdivide and remerge then you need to also keep track of the smallest elements
22:49:05 <arkeet> right.
22:49:59 <arkeet> scanning linearly doesn't parallelize at all.
22:52:00 <jle`> yeah, this definitely beats the ol' and . ap (zipWith (<=)) tail
22:52:14 <arkeet> heh
22:52:36 <amatsu> anybody know how to get -fllvm working on OSX?
22:52:48 <amatsu> I've installed llvm through brew, symlinked llc and opt
22:53:43 <amatsu> I get this, though http://pastebin.com/kNmB0S5g
22:55:10 <amatsu> with -v: http://pastebin.com/RyAwCYTG
22:58:00 <arkeet> I wonder where CapitalSigma went
23:07:30 <arkeet> unfortunately this never terminates on an infinite list, heh.
23:11:30 <mgomezch> Is there some active channel with the specific topic of GHC on iOS?
23:12:50 <arkeet> I thought there was.
23:13:13 <arkeet> I hope you mean for targeting ios, not running ghc on ios.
23:13:44 <arkeet> apparently the channel is #haskell-iphone, but it seems to be nearly empty.
23:35:43 * hackagebot hexstring 0.11.1 - Fast and safe representation of a hex string  http://hackage.haskell.org/package/hexstring-0.11.1 (solatis)
