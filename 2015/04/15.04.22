00:19:48 * hackagebot getopt-generics 0.6 - Simple command line argument parsing  http://hackage.haskell.org/package/getopt-generics-0.6 (SoenkeHahn)
00:26:43 <solatis> if i want to put a big fat warning sign in the haddock documentation of a function, what would be the best way to do so?
00:26:46 <solatis> just use bold?
00:29:45 <akurilin3> bitemyappPrime / Cale sorry was gone for a bit: there's definitely no forkIO in my libs, just old-fashioned fetch some stuff from the DB once in a while in that same thread, often not even that.
00:30:23 <akurilin3> bitemyappPrime: thanks for linking the conversation
00:32:37 <jle`> solatis: bold and there's also the deprecated pragma which haddocks respect
00:32:57 <akurilin3> Actually I'll need to see if I can repro that issue on my local box instead of directly in production since that's too unwieldy to debug
00:33:02 <solatis> jle`, yeah i know about the deprecated pragma, just wondering whether there was more
00:34:49 * hackagebot json-stream 0.3.0.3 - Incremental applicative JSON parser  http://hackage.haskell.org/package/json-stream-0.3.0.3 (ondrap)
00:39:49 * hackagebot clustering 0.2.0 - High performance clustering algorithms  http://hackage.haskell.org/package/clustering-0.2.0 (kaizhang)
00:44:50 * hackagebot email-validate 2.1.0 - Validating an email address string against RFC 5322  http://hackage.haskell.org/package/email-validate-2.1.0 (GeorgePollard)
00:59:50 * hackagebot nf 1.0.0.1 - NF data type to statically enforce normal form  http://hackage.haskell.org/package/nf-1.0.0.1 (EdwardYang)
01:12:40 <orion> How does monadLib stack up against mtl?
01:29:52 * hackagebot email-validate 2.1.1 - Validating an email address string against RFC 5322  http://hackage.haskell.org/package/email-validate-2.1.1 (GeorgePollard)
01:29:54 * hackagebot clash-prelude 0.7.3 - CAES Language for Synchronous Hardware - Prelude library  http://hackage.haskell.org/package/clash-prelude-0.7.3 (ChristiaanBaaij)
01:44:52 * hackagebot ghc-typelits-natnormalise 0.2 - GHC typechecker plugin for types of kind GHC.TypeLits.Nat  http://hackage.haskell.org/package/ghc-typelits-natnormalise-0.2 (ChristiaanBaaij)
01:46:30 <ttt_fff> from a anskell perspective, does erlang->elixir have any programming langauge features we can steal / make haskell better with? or is it just erlang -> ruby syntactical changes, and no new programming model tricks
01:57:41 <srhb> ttt_fff: I'm sure there are certain things that could be stolen
01:58:02 <srhb> ttt_fff: Part of what Cloud Haskell does is try to replicate the Erlang model for distributed systems.
01:58:11 <srhb> ttt_fff: I don't know about any other specific cases.
02:01:22 <ttt_fff> srhb: yeah, agreed, I'm not sure either
02:01:24 <ttt_fff> (which is why I asked)
02:11:35 <riaqn> hello, I 'm reading some papers on type systems, I just encounter some syntax. What is the meaning of big PI? 
02:12:13 <riaqn> e.g. \PI x.x, seems just a calculus, like \lambda x.x
02:14:45 <shachaf> https://en.wikipedia.org/wiki/Dependent_type ?
02:16:36 <riaqn> shachaf: thx, seems what I 'm looking for.
02:25:45 <orion> How can I pass a parameter to a Spec?
02:39:56 * hackagebot jwt 0.6.0 - JSON Web Token (JWT) decoding and encoding  http://hackage.haskell.org/package/jwt-0.6.0 (StefanSaasen)
02:46:31 <pavonia> orion: What is Spec?
02:49:56 * hackagebot hackernews 0.4.0.0 - API for Hacker News  http://hackage.haskell.org/package/hackernews-0.4.0.0 (DavidJohnson)
02:52:44 <Flonk> iirc I've seen someone use a double colon that was a single character and apparently Haskell supports that
02:52:54 <Flonk> Does it have a special name? I can't seem to find it in the charmap
02:54:15 <shachaf> https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/syntax-extns.html
02:54:31 <shachaf> U+2237 PROPORTION [∷]
02:54:50 <kadoban> "proportion" ? That's unexpected, heh.
02:55:23 <Flonk> Yes, no wonder I didn't find it :P
02:55:30 <Flonk> shachaf: Thanks a lot
02:58:04 <Flonk> kadoban: PHP calls it paamayim nekudotayim, not sure which is better
02:59:08 <merijn> Flonk: There is a UnicodeSyntax extension in GHC
02:59:19 <kadoban> Haha, well haskell probably has some better name for it, that's just unicode's name.
02:59:32 <Flonk> merijn: yes, shachaf just posted the link :)
02:59:41 <merijn> Ah, I'm just blind :)
03:07:33 <sopvop> BLACK STAR
04:15:00 * hackagebot postgresql-query 1.1.0 - Sql interpolating quasiquote plus some kind of primitive ORM  using it  http://hackage.haskell.org/package/postgresql-query-1.1.0 (AlekseyUymanov)
04:36:26 <ejmzro> Hello. Say that I have a function foo :: (Eq a) => [a] -> ... How do I specify this using Traversable instead of a list?
04:37:17 <mniip> (Eq1 t, Traversable t) => t a ->
04:37:52 <ejmzro> mniip: Thanks! Obvious when I see it, but I haven't touched haskell in a while.
04:38:17 <mniip> Eq1 is from Data.Functor.Classes
04:39:35 <ejmzro> mniip: ok. I'm really using another type class in my code, but good to know anyway.
04:39:58 <merijn> ejmzro: You don't even need Eq1, tbh
04:40:28 <merijn> ejmzro: You could also do something like "(Eq (t a), Traversable t) => t a -> ..."
04:41:21 <ejmzro> merijn: Wouldn't that imply equality over the whole list?
04:41:24 <merijn> Or some other variation, it depends on exactly what you wanna do
04:41:33 <merijn> ejmzro: That's what mniip does too, I think
04:41:55 <merijn> ejmzro: If you just need element wise equality you just need "(Eq a, Traversable t) => t a -> ..."
04:42:24 <ejmzro> merijn: That's what I'm after. I'll do some experimenting... Thanks again.
04:43:19 <mniip> Eq (t a) requires FlexibleContexts
04:43:42 <mniip> also yes, Eq a and Eq1 t, depending on whether you need to compare lists or elements
04:55:02 * hackagebot nf 1.0.0.2 - NF data type to statically enforce normal form  http://hackage.haskell.org/package/nf-1.0.0.2 (EdwardYang)
05:05:03 * hackagebot base-orphans 0.1.0 - Backwards-compatible orphan instances for base  http://hackage.haskell.org/package/base-orphans-0.1.0 (SimonHengel)
05:10:03 * hackagebot errorcall-eq-instance 0.3.0 - An orphan Eq instance for ErrorCall  http://hackage.haskell.org/package/errorcall-eq-instance-0.3.0 (SimonHengel)
05:13:16 <beruuwong> Hi, can someone tell me if what I've written does exactly so? http://lpaste.net/131224
05:15:03 * hackagebot classy-prelude 0.11.1.1 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.11.1.1 (MichaelSnoyman)
05:22:33 <ronh> beruuwong it looks fine, except if you're expecting it to work when file1 and file2 contain the same path (in which case you need to fully evaluate content before calling writeFile).
05:23:44 <beruuwong> ronh : How do I run the function? I loaded the .hs file in ghci and then couldn't run capitalise
05:24:00 <beruuwong> ronh : do I do capitalise note1.txt note2.txt?
05:24:12 <ronh> capitalise "note1.txt" "note2.txt"
05:24:20 <beruuwong> oh, alright. Thank you
05:25:04 * hackagebot xml-conduit 1.2.4 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.2.4 (MichaelSnoyman)
05:26:26 <ronh> you could also make it more generic: capitalise : String -> String, transform :: (String -> String) -> FilePath -> FilePath -> IO ()
05:29:38 <beruuwong> I've another question, how do I use getArgs such that my function reads from the first argument and writes to the second?
05:30:04 * hackagebot base-compat 0.8.0 - A compatibility layer for base  http://hackage.haskell.org/package/base-compat-0.8.0 (SimonHengel)
05:30:31 <beruuwong> Is it possible to say, store the first argument in a variable and the second argument in another?
05:31:27 <ronh> args <- getArgs; case args of [in, out]: ...\n_: /* handle case where length of arg was not 2 */
05:32:10 <mauke}> it's ->, not :
05:32:20 <mauke}> you can use ; instead of a newline
05:32:28 <ronh> ^^ yes ->
05:32:29 <mauke}> {- comments -}, not /* comments */
05:32:46 <ronh> indeed.. been a while since I used haskell :P
05:35:04 * hackagebot nf 1.0.0.3 - NF data type to statically enforce normal form  http://hackage.haskell.org/package/nf-1.0.0.3 (EdwardYang)
06:03:33 <cfoch> hi, what is the package of Data.Proxy.HS?
06:05:01 <geekosaur> it's not on hackage, whatever it is. if it's locally installed, try `ghc-pkg find-module Data.Proxy.HS`
06:05:44 <geekosaur> (in a sandbox, `cabal sandbox hc-pkg find-module Data.Proxy.HS`)
06:05:44 <bima> i want to stop IO monads at the point i want to stop like "stop" in this http://lpaste.net/131226. how can i do this?
06:06:39 <tdammers> :t throwIOError
06:06:40 <lambdabot>     Not in scope: ‘throwIOError’
06:06:41 <lambdabot>     Perhaps you meant ‘throwError’ (imported from Control.Monad.Except)
06:06:44 <merijn> :t when
06:06:45 <lambdabot> Applicative f => Bool -> f () -> f ()
06:07:11 <tdammers> when wouldn't short-circuit, really
06:07:14 <merijn> bima: "when" is basically "when b x = if b then x else return ()"
06:07:30 <merijn> tdammers: Obviously everything after stop should be moved inside the when
06:07:47 <isomorphic> 	If I have a function f :: (Integral a) => a -> b, and I'm happy to write specializations for a ~ Int and a ~ Integer, what's the syntax for dispatching each one?  Do I need typeable or is there another way?  
06:07:47 <tdammers> merijn: yes... I assumed something like an "early return" was required
06:08:02 <mniip> unless (x == 3) $ do
06:08:02 <lpaste> merijn annotated “No title” with “No title (annotation)” at http://lpaste.net/131226#a131227
06:08:05 <mniip> rest of the code
06:08:20 <merijn> bima: See the above paste
06:10:00 <bima> i want "early return". i know "when", but it makes indentation and it isn't readable to me.
06:11:07 <mniip> create an exception
06:11:15 <hexagoxel> bima: MaybeT or EitherT can be used to implement early return.
06:11:23 <merijn> bima: There is no early return, other than throwing an exception, but that means needing to catch/handle an exception
06:11:32 <merijn> hexagoxel: That's hardly easier/more readable than using when/unless
06:12:09 <ronh> why am I getting "no prase" error in here?  fmap (read . show) getZonedTime :: IO ZonedTime
06:12:31 <ronh> this works fine: fmap (read . show) getCurrentTime :: IO UTCTime
06:12:37 <hexagoxel> merijn: i disagree. when you have multiple early-return-cases, when creates more indentation levels, while MaybeT keeps things at one level
06:12:38 <ronh> no parse*
06:12:44 <cfoch> because I am trying to install tagged
06:12:53 <mniip> looks like a foolish Show instance
06:12:54 <cfoch> from the git repo
06:13:02 <cfoch> I get this error --> http://fpaste.org/214287/97082981/
06:13:22 <cfoch> It cannot find '<$>'
06:13:30 <merijn> cfoch: That looks like the repo is 7.10 and you're not using 7.10 to compile?
06:13:36 <ronh> mniip but it seems like it contains enough information to be parsable.. it doesn't work for you either?
06:14:06 <cfoch> [cfoch@localhost tagged]$ ghc --version
06:14:07 <cfoch> The Glorious Glasgow Haskell Compilation System, version 7.10.0.20150123
06:14:16 <merijn> cfoch: Oh, looks like someone made a mistake
06:14:34 <merijn> cfoch: Since apparently Prelude doesn't export <$> but it does export <*> (because Applicative is in Prelude)
06:14:37 <mniip> ronh, I get     No instance for (Read ZonedTime) arising from a use of ‘read’
06:14:45 <merijn> And someone blindly deleted the "import Control.Applicative"
06:14:55 <merijn> cfoch: That's pretty awful though, Prelude not having <$>
06:15:06 * hackagebot utc 0.1.0.1 - A pragmatic time and date library.  http://hackage.haskell.org/package/utc-0.1.0.1 (LarsPetersen)
06:15:08 * hackagebot system-filepath 0.4.13.3 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.4.13.3 (MichaelSnoyman)
06:15:27 <merijn> That makes me sad :(
06:16:03 <merijn> So now I *still* need to import Control.Applicative everywhere :\
06:16:04 <cfoch> is it a problem with Prelude? Did I understand correctly?
06:16:22 <cfoch> merijn: ^
06:16:29 <mniip> no, it's a problem in how package's author interpreted the change in prelude
06:16:51 <merijn> cfoch: The problem is that the author assumed <$> would move into Prelude now that Applicative is in there, but apparently it wasn't moved there
06:17:46 <bima> merijn: thanks. i think throw an exception makes my code confusable, but when and unless makes too many indentation when validate many inputs. i wish there were an simple way to return early.
06:17:51 <merijn> No, wait, <$> *is* in Prelude
06:17:53 <kvelicka> in ghci, is there a way to see the value of something that does not implement Show?
06:18:19 <merijn> cfoch: Oh
06:18:20 <kvelicka> e.g. say if I had a value of type Maybe String, can I see whether it's a Just String or Nothing
06:18:27 <merijn> cfoch: You're using a pre-release/dev build
06:18:39 <merijn> cfoch: So you're base (and thus Prelude) is wrong
06:18:51 <mauke}> kvelicka: yes, but that particular type does implement Show
06:19:00 <merijn> $ ghc --version
06:19:01 <bima> hexagoxel: thanks, i'll check it.
06:19:02 <merijn> The Glorious Glasgow Haskell Compilation System, version 7.10.1
06:19:02 <ronh> Maybe String has Show instance.. if you mean Maybe a in general, then you'll have to write showMay :: Maybe a -> String
06:19:20 <mauke}> kvelicka: case foo of Just{} -> "Just"; Nothing -> "Nothing"
06:19:24 <merijn> cfoch: Works for me, so you need to update your GHC to a release version
06:19:45 <cfoch> to 7.10.1 ?
06:19:54 <kvelicka> mauke}: is that the only way? I though there'd be something along the lines of :t
06:19:56 <merijn> cfoch: Yes
06:20:24 <merijn> cfoch: You happen to have a GHC build that is both incompatible with the old way AND the new way
06:20:46 <mauke}> > toConstr (Just id)
06:20:47 <lambdabot>      No instance for (Data (a0 -> a0))
06:20:48 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
06:20:48 <lambdabot>        arising from a use of ‘toConstr’
06:20:56 <mauke}> aww
06:21:30 <mauke}> > toConstr (Just "")
06:21:31 <lambdabot>  Just
06:22:05 <mauke}> > toConstr Nothing
06:22:07 <lambdabot>      No instance for (Data a0) arising from a use of ‘toConstr’
06:22:07 <lambdabot>      The type variable ‘a0’ is ambiguous
06:22:07 <lambdabot>      Note: there are several potential instances:
06:22:14 <mauke}> > toConstr (Nothing :: Maybe String)
06:22:15 <lambdabot>  Nothing
06:22:19 <mauke}> ok, this is annoying too
06:23:08 <kvelicka> Right, so the cumbersome way it is then it seems
06:27:24 <chpatrick> >toConst (Nothing :: Maybe Int)
06:27:32 <chpatrick> oops
06:28:03 <kqr> did I hear that the new Prelude has <$>? awesome
06:28:12 <merijn> kqr: As part of Applicative, yes
06:28:33 <merijn> kqr: I always assumed it would, I just got worried by cfoch's error output :p
06:28:42 <kqr> hah yeah
06:28:54 <kqr> I'm glad to hear that stuff is moving in the direction of what's useful when writing code
06:29:15 <mauke}> > id Prelude.<$> "yay!"
06:29:17 <lambdabot>  "yay!"
06:29:19 <kqr> I understand <$> is scary for beginners but there are few source files where I can avoid importing it at all
06:29:34 <mauke}> cool cool
06:29:50 <merijn> kqr: Right, literally ALL my haskell source has "import Control.Applicative" at the top
06:30:12 <kqr> now I'm only waiting for Text to take the spotlight
06:30:21 <kqr> that's my second unavoidable import
06:30:25 <kqr> along with overloaded strings
06:30:33 <merijn> I think Text has a less strong case
06:30:53 <kqr> I agree
06:31:02 <merijn> I usually only have Text in a few modules so I'm ok with importing that
06:31:42 <kqr> for me it's just a bother that 1. everything in text collides with prelude, and 2. not having text available makes people not use it even when they maybe should
06:32:10 <merijn> kqr: Sure, but how is 1 solved by moving Text into Prelude?
06:32:30 <merijn> kqr: That will just result in having to rename everything in Text...
06:32:53 <merijn> What I'd rather see is a way to combine "import Data.Text (Text); import qualified Data.Text as T" into one import
06:33:05 <johnw> merijn: me too
06:33:16 <johnw> i use that idiom for several types/modules
06:33:22 <kqr> merijn, not sure. haven't thought that through at all =)
06:33:32 <merijn> Yeah, Map/Set/Text/ByteString are the usual contenders for that
06:35:07 <kqr> I just find it silly that regular string handling fns needs to be qualified
06:35:24 <merijn> Maybe
06:35:29 <merijn> I'm undecided
06:35:40 <merijn> On the one hand String is pretty bad, on the other it's pretty convenient
06:36:11 <kqr> I find text more convenient
06:36:14 <johnw> like using pattern matching to dissect Strings...
06:36:14 <kqr> name collisions aside
06:36:25 <hodapp> use a regex
06:36:27 * hodapp runs
06:36:29 <kqr> if you want to pattern match on text values you can always unpack them
06:36:38 <johnw> umm
06:36:53 <johnw> doesn't that potentionally eliminate the efficiency gain?
06:37:14 <kqr> yes, but you're not really in the race for efficiency if you use strings anyway
06:37:31 <johnw> a small number of small strings is plenty efficient
06:38:12 <indiagreen> maybe pattern matching would've been easier if “:” was a pattern synonym instead of a constructor
06:38:20 <indiagreen> maybe we'll even get that one day
06:38:45 <kqr> johnw, I don't see how it would be more inefficient to use text values for everything except the small number of small strings that are going to be pattern matched
06:38:49 <hodapp> indiagreen: pattern synonym?
06:39:21 <StrangeLoop> http://pastebin.com/71v0JRgE <--- is there a nice way to make a pointless version of this?
06:39:27 <johnw> i'm not comparing inefficiencies; I'm weighing convenience against efficiency
06:39:29 <indiagreen> hodapp: it's a new GHC extension
06:39:37 <StrangeLoop> Something like "test = map $ negate ."
06:39:41 <c_wraith> StrangeLoop: lambdabot can answer that.
06:39:51 <StrangeLoop> c_wraith: Teach me!
06:39:52 <kqr> @pl \f -> map $ negate.f
06:39:52 <lambdabot> map . (negate .)
06:39:58 <slack1256> What is the gold standard in effect systems?
06:40:03 <StrangeLoop> Cool!
06:40:06 <ronh> to extract head/tail from a list you would need to copy tail, no? with String there's no need to copy
06:40:10 <slack1256> the most popular one?
06:40:11 <ronh> err
06:40:15 <ronh> to extract head/tail from a Text you would need to copy tail, no? with String there's no need to copy
06:40:40 <kqr> ronh, I trust Text values to be stored intelligently
06:40:40 <indiagreen> ronh: not necessarily, there could be slicing
06:40:46 <c_wraith> ronh: I'm pretty sure Text is sliced internally
06:40:57 <kqr> ronh, likely in some sort of tree of arrays
06:41:07 <c_wraith> kqr: sadly, it's not that intelligent
06:41:10 <StrangeLoop> Ok, so why does map.(negate.) work whereas map@(negate .) does not?
06:41:21 <indiagreen> ronh: apparently cons is O(n), but uncons is O(1)
06:41:32 <kqr> StrangeLoop, did you mean to type @ there?
06:41:44 <StrangeLoop> Nope :P, should be $
06:41:58 <chpatrick> strangeloop: depends on what you're trying to do
06:42:55 <geekosaur> ($) is function application made visible, (.) is function composition. you usually want the latter for pointfree
06:43:08 <StrangeLoop> Oh OK, thanks
06:43:13 <chpatrick> strangeloop: the first one negates the result of a function then uses it to map, the second one uses (negate .) as the function to map with
06:43:52 <indiagreen> hodapp: I think with PatternSynonyms you basically can use functions as patterns
06:44:23 <hodapp> interesting...
06:45:46 <merijn> No
06:45:48 <mauke}> > case negate of (($ 2) -> x) -> x
06:45:50 <lambdabot>  -2
06:45:56 <merijn> PatternSynonyms lets you write "custom" pattern constructors
06:46:06 <merijn> ViewPatterns lets you use functions in matches
06:46:19 <merijn> It's just that ViewPatterns + PatternSynonyms lets you do neat things
06:47:12 <kqr> which reminds me that I should re-read 24 days of ghc extensions
06:47:22 <indiagreen> merijn: I meant that you can create patterns that are more function-like – in particular, you probably could create a “:” pattern which would be in some Cons class and which would give cons/uncons for String, Text, Sequence, etc.
06:47:31 <merijn> "foo :: Set a -> ...; foo (Set.empty -> b) = {- something using boolean 'b' -}"
06:47:40 <mauke}> > let vmap _ [] = []; vmap f ((f -> x) : (vmap f -> xs)) = x : xs in vmap (*2) [1..5]
06:47:41 <lambdabot>  [2,4,6,8,10]
06:48:15 <merijn> mauke}: I didn't know that would work :>
06:48:38 <cfoch> is there an option "cabal --only" when do we need to use --only?
06:49:15 <dcoutts> cfoch: hmm?
06:49:58 <cfoch> cabal install --only
06:49:59 <cfoch> https://github.com/haskell/cabal/issues/2549
06:49:59 <cfoch> dcoutts
06:50:40 <dcoutts> cfoch: oh, it's an internal thing, not listed in the help
06:50:55 <rtpg> hey, I'm using cabal to configure my build process.. is there a way to change the output directory after compiling?
06:52:44 <chpatrick> indiagreen: pattern h :- t <- (Data.Sequences.uncons -> Just ( h, t ))
06:53:31 <dcoutts> rtpg: do you mean the layout of the install image? or intermediate build artefacts?
06:53:44 <rtpg> ah, the build artefacts
06:54:18 <dcoutts> rtpg: the location of the "dist" directory can be specified, with the --builddir flag
06:54:43 <dcoutts> rtpg: but note that it then has to be passed to configure, build, copy, register etc, because the configuration is also stored in dist
06:58:19 <safinaskar> hi. i have function (let's say it is "f") of type "(Monad m) => SomeFixedType1 -> m SomeFixedType2". this function assumes the monad has working "fail" and the function may "fail". how to check whatever a function invocation (for example, "f x") "failed" the most beautiful way (and return Bool)? i may write "case (f x :: Maybe SomeFixedType2) of { Nothing -> False; _ -> True; }", but this expression is
06:58:25 <safinaskar>  too long
06:58:50 <rtpg> thanks, though maybe I don't need to do that at the moment
06:58:52 <mauke}> you can remove the type annotation
06:58:54 <addict10> hey hasskellers
06:59:00 <kqr> safinaskar, isJust :: Maybe a -> Bool
06:59:42 <kqr> safinaskar, so in your case, isJust (f x)
07:02:18 <safinaskar> kqr: thanks
07:02:25 <Athas> Why has switching from the old inferior-ghci interaction mode to the new interactive-haskell-mode changed the indentation rules?
07:02:49 <safinaskar> mauke}: thanks
07:03:10 <mauke}> there's an in-between point: maybe False (const True) (f x)
07:03:29 <mauke}> but that's just because 'maybe' is a helper function for pattern matching on Maybe
07:06:42 <lpaste> ryanar annotated “Trying to implement Either and Maybe error checking” with “Trying to implement Either and Maybe error checking (annotation)” at http://lpaste.net/3480128364050644992#a6224829559611588608
07:07:05 <Ryanar> sorry wrong channel!
07:07:13 <hoelzro> hi Haskellers; I'm having issues with installing a package (namely, elm-compiler and co.).  I'm encountering conflicts with different versions being required by different packages.  Here's cabal install's output: https://gist.github.com/hoelzro/fc604c63ae3763eec94a
07:08:21 <hoelzro> it looks like edit-distance is confused about what version of base it needs, and I checked the Cabal FAQ, but I don't think the conflict example on there applies here
07:09:06 <mauke}> hoelzro: no, it looks like your ghc is too new
07:09:19 <mauke}> edit-distance depends on base < 4.8
07:09:42 <hoelzro> oh, I see now
07:09:50 <hoelzro> I was focusing on the base<3 line
07:10:05 <mauke}> -splitbase is for ancient ghcs
07:10:10 <hoelzro> mauke}: so I need to downgrade ghc, or find an edit-distance that works on ghc-4.8?
07:10:12 <mauke}> (base-2)
07:10:19 <mauke}> I think so, yeah
07:12:14 <hoelzro> ok, thanks for the advice!
07:13:38 <Ryanar> If I have a return value of Right <value> how do I lift the value from the monad?
07:14:32 <mauke}> what do you mean by: lift, the value, from, the monad?
07:14:40 <ion> What does lifting the value mean? Do you want case Right 42 of { Left a -> _; Right b -> _ }
07:14:48 <mauke}> ok, scratch "the value"; it refers to Right <value>
07:15:16 <Ryanar> I have currently Case Right <value> Left <value> expression
07:15:24 <Ryanar> now I want to just get the value
07:15:53 <mauke}> :t either id id
07:15:55 <lambdabot> Either c c -> c
07:17:59 <johnw> Ryanar: in the caes of "how do I get a value out of X" (where yesterday it was Maybe), there are times when you should use fmap or >>= to apply a computation to to what is in X, rather than "extracting" it
07:20:13 <Ryanar> johnw, ah Ok
07:20:21 <add1ct10n> hashkeel
07:20:28 <add1ct10n> i love hashkeell
07:20:35 <add1ct10n> hashkeeel can totally build an OS
07:20:42 <mauke}> 3 marijuanas
07:20:48 <add1ct10n> hashmap is named after hashkeel i
07:21:00 <SrPx> I'm wondering, why libraries such as REPA define operators such as (!) if they will pretty much never be used as intended, since you have to import REPA qualified anyway?
07:21:00 <add1ct10n> how do you count marinjuana s mauke} ?
07:21:06 <add1ct10n> 3 joints, you'd say
07:21:09 <add1ct10n> REPL.
07:21:15 <add1ct10n> read evaluvate print loop
07:21:16 <kqr> SrPx, you can import just the ! operator unqualified
07:21:46 <SrPx> I see
07:22:58 <rtpg> is there a form of "shape equality" function that exists for ADTs that confirms that two elements are of the same constructor? 
07:23:13 <rtpg> like, f (Just "a") (Just "b") = True?
07:23:14 <SrPx> Is there any matrix library that is more convenient than REPA? I don't want all the type annotations and cognitive load of using REPA when I don't need its performance
07:23:40 <kqr> rtpg, for a specific type or for any type?
07:23:43 <mauke}> > ((==) `on` toConstr) (Just "a") (Just "b")
07:23:44 <lambdabot>  True
07:24:12 <kqr> ((==) `on` toConstr) (putStrLn "hello") getLine
07:24:15 <kqr> > ((==) `on` toConstr) (putStrLn "hello") getLine
07:24:16 <lambdabot>      Couldn't match type ‘[Char]’ with ‘()’
07:24:17 <lambdabot>      Expected type: IO ()
07:24:17 <lambdabot>        Actual type: IO String
07:24:27 <kqr> hm ah they need to be the same type
07:24:27 <add1ct10n> this is why i hate haskell
07:24:29 <mauke}> that's because of 'on'
07:24:36 <kqr> > ((==) `on` toConstr) (void (putStrLn "hello")) getLine
07:24:38 <lambdabot>      Couldn't match type ‘[Char]’ with ‘()’
07:24:38 <lambdabot>      Expected type: IO ()
07:24:38 <lambdabot>        Actual type: IO String
07:24:39 <add1ct10n> 'Just' in a language?
07:24:40 <kqr> whoops
07:24:42 <kqr> no
07:24:43 <add1ct10n> that's not english duh!
07:24:53 <mauke}> add1ct10n: please stop being noisy
07:25:12 <rtpg> oh wow, I did not know about Data.Data kqr, thanks!
07:25:20 <kqr> rtpg, don't thank me, thank mauke} 
07:25:39 <rtpg> ah, thanks mauke} :)
07:25:58 <add1ct10n> mauke} sure bro
07:26:06 <mauke}> > toConstr (putStr "") == toConstr getLine
07:26:07 <lambdabot>      No instance for (Data (IO ())) arising from a use of ‘toConstr’
07:26:07 <lambdabot>      In the first argument of ‘(==)’, namely ‘toConstr (putStr "")’
07:26:07 <lambdabot>      In the expression: toConstr (putStr "") == toConstr getLine    No instan...
07:26:15 <mauke}> ^ this is the error you get without 'on'
07:26:46 <kqr> ah yeah just figured it out in ghci :)
07:27:07 <kqr> but still don't understand why `on` worked with Maybe but not with IO?
07:27:20 <mauke}> :t toConstr
07:27:21 <lambdabot> Data a => a -> Constr
07:27:26 <mauke}> IO isn't an instance of Data
07:27:31 <mauke}> because IO has no public constructors
07:27:35 <kqr> I understand that
07:27:40 <kqr> but what does that have to do with `on`?
07:27:55 <mauke}> > ((==) `on` toConstr) (Just "a") (Just ())
07:27:57 <lambdabot>      Couldn't match expected type ‘[Char]’ with actual type ‘()’
07:27:57 <lambdabot>      In the first argument of ‘Just’, namely ‘()’
07:27:57 <lambdabot>      In the second argument of ‘(==) `on` toConstr’, namely ‘(Just ())’
07:28:01 <mauke}> same error with Maybe
07:28:14 <mauke}> :t on
07:28:15 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
07:28:26 <kqr> ohh yeah of course
07:28:28 <mauke}> ... a -> a -> c
07:28:31 <kqr> I messed up when I thought I fixed that
07:28:37 <mauke}> the two values need to have the same type there
07:28:40 <kqr> I meant to void getLine
07:28:43 <kqr> not putStrLn
07:28:53 <merijn> mauke}: Whether IO has public constructors depends on which modules you input :p
07:29:06 <merijn> *import
07:30:21 <dst1> Hi guys.. which is the best approach for testing "Show" typeclass derivation... I think that an "assertEqual" String it is not the best approach because of any change in record type would break the test... Any ideas?
07:31:01 <chpatrick> does that really need to be tested?
07:31:17 <mauke}> why are you trying to test generated code?
07:31:43 <dst1> well... I just wanted full coverage and coveralls is marking that line.. perhaps a flag to avoid it?
07:32:26 <dst1> Also to ensure that your new types are instances of Show
07:32:39 <dst1> case it is not auto derived
07:33:05 <johnw> dst1: if you're also deriving Read, you can QuickCheck test that read . show = id
07:34:27 <SrPx> is it possible to somehow use lens to make working with matrices simpler than Repa? :(
07:35:31 <edwardk> SrPx: we call it 'linear'
07:36:00 * dfeuer offers edwardk a cinnamon roll.
07:36:06 <edwardk> m^._x._y      v^._x, etc.
07:36:18 <edwardk> m^.column _x
07:36:35 <johnw> morning edwardk!
07:36:40 <edwardk> mornin
07:36:45 * ion offers dfeuer a rick roll.
07:38:12 <add1ct10n> gnight edwardk
07:39:20 <SrPx> edwardk: sorry for stupid but I'm not sure I understand, you mean using linear to work with 2D, 3D matrices of arbitrary shape? For example, "matrix = Matrix.romList [10,10] [0..99]; main = print $ get [1,1] matrix" I'm looking for something like that
07:39:57 <SrPx> AFAIK as my understanding goes Linear defines matrixes up to 4x4, no?
07:40:01 <SrPx> matrices *
07:50:17 <johnw> Linear can work with arbitrary sparse matrices too
07:50:31 <johnw> like Data.Map
07:51:20 <SrPx> Is there any tutorial/reference? I'm looking at the types since edwardk answered but I'm not sure I get it :(
07:51:37 <ronh> I love when I change a type of a single function, spend 10 minutes fixing type errors while having my brain on an auto-pilot, and then when it compiles it just works
07:52:09 <frawgie> ronh: the magic of haskell :)
07:52:26 <edwardk> srpx: linear has "V n" for vectors of length n.
07:52:36 <edwardk> srpx: in linear we use 'a vector of vectors' as a matrix.
07:52:48 <edwardk> srpx: so V n (V m a)  -- is an n*m matrix of a's
07:53:11 <edwardk> and there are matrix-matrix, matrix-vector, etc. multiplication primitives
07:53:36 <edwardk> V0-V4 are offered up as special data types, but V n works in general.
07:56:23 <fizbin> Hey, anyone know how to get the ghci ":hist" command to show more than 20 lines?
07:56:36 <fizbin> The documentation claims it remembers 50.
07:57:58 <johnw> SrPx: you can just use the operators on a Data.Map value directly
07:58:09 <johnw> for examlpe, ^+^ will sum two maps
07:59:02 <johnw> it's quite an elegant additions to Map manipulation, especially combined with the power of lens
07:59:35 * SrPx is trying to figure out that V thing so if he takes some time to answer you know
08:00:17 <srhb> (V2 (V3 2 2 2) (V3 2 2 2)) :: V2 (V3 Integer) -- for instance
08:05:33 <siwica> what is he best way to test whether a number is contained within a (sorted) infinite list of numbers?
08:06:07 <srhb> > 42 `elem` [1..]
08:06:09 <lambdabot>  True
08:06:18 <comerijn> srhb: That hangs if the element is missing
08:06:19 <siwica> ("a `elem' primes" runs forever if a not in primes
08:06:21 <srhb> comerijn: Oh
08:06:23 <srhb> Derp
08:06:24 <siwica> thats the problem
08:06:25 <srhb> :D
08:06:27 <srhb> Yeah, got it.
08:06:42 <srhb> Well, a short circuiting fold should be doable
08:07:06 <comerijn> > let f i = elem i . takeWhile (<=i) in f 42 [1..]
08:07:08 <lambdabot>  True
08:07:12 <comerijn> > let f i = elem i . takeWhile (<=i) in f 42 [43..]
08:07:13 <lambdabot>  False
08:07:18 <comerijn> booyah
08:07:47 <siwica> ok, that looks reasonable ;)
08:07:58 <johnw> I would think comerijn only asks questions, rather than providing answers
08:08:11 <srhb> Way simpler than a short circuiting fold :-)
08:08:21 <comerijn> johnw: comerijn boots his computer, unlike merijn who just crashed it :)
08:08:37 <bananagram> > let f i = elem i . takeWhile (<=i) in f 42 [-10000..]
08:08:39 <lambdabot>  True
08:08:54 <tdammers> comerijn: do you expect it to redump after it has cocrashed?
08:08:58 <bananagram> > let f i = elem i . takeWhile (<=i) in f 42 [-1000000..]
08:09:00 <johnw> comerijn: will you be at OPLSS this year? 
08:09:00 <lambdabot>  True
08:09:00 <srhb> bananagram: Needs a step
08:09:23 <srhb> bananagram: If you're trying to show that it breaks for negatives, anyway.
08:09:35 <bananagram> no, I just want to see if it's unperformant
08:09:44 <srhb> (But then it's sorted in the opposite direction, and needs flipping)
08:09:46 <srhb> Ah :)
08:09:51 <comerijn> johnw: Unlikely, hard to get the money approved since it's not really related to my research :)
08:10:09 <comerijn> johnw: I'm going to the HiPEAC summer school to do FPGA stuffs
08:10:18 <johnw> I can't attend due to the fact that I'll be moving to California that week
08:11:02 <sm> johnw: woot!
08:11:22 <tulcod> wow, i haven't seen someone use "woot" in a long time
08:11:22 <johnw> but not near you, sm :(
08:11:28 * sm cues all goin-to-california songs
08:20:11 * hackagebot hspec-snap 0.3.2.5 - A library for testing with Hspec and the Snap Web Framework  http://hackage.haskell.org/package/hspec-snap-0.3.2.5 (DanielPatterson)
08:20:44 <Myrl-chan> Hi guys. Is there a stdlib function or an idiomatic way to do something similar to the intersperse on lists of lists?
08:20:57 <mauke}> huh?
08:21:04 <Myrl-chan> Say, I have [[1,2],[3,4]], I want it to become [1,3,2,4]
08:21:41 <mauke}> > (concat . transpose) [[1,2],[3,4]]
08:21:43 <lambdabot>  [1,3,2,4]
08:21:46 <Myrl-chan> [[1,3],[2,4] works just as well.
08:21:54 <mauke}> > transpose [[1,2],[3,4]]
08:21:54 <Myrl-chan> mauke}: Ah, cool.
08:21:55 <lambdabot>  [[1,3],[2,4]]
08:22:11 <Myrl-chan> mauke}: Exactly what I need. Thanks!
08:22:42 <c_wraith> > concat $ transpose [[1,2,3],[5]]
08:22:44 <lambdabot>  [1,5,2,3]
08:22:51 <c_wraith> Just be sure that's what you want
08:22:57 <c_wraith> If the sublists aren't all the same length
08:23:07 <Myrl-chan> c_wraith: Yeah, thanks.
08:23:29 <Myrl-chan> for lists of 3, say
08:23:51 <Myrl-chan> [[1,2,3],[4,5,6],[7,8,9]] => [[1,4,7],[2,5,8],[3,6,9]]?
08:24:03 <c_wraith> yeah, that's what transpose will do
08:24:21 <k0ral> is there a hoogle-like tool to list all instances of a given typeclass, among a large set of packages ?
08:24:27 <jackhill> > :t transpose
08:24:29 <lambdabot>  <hint>:1:1: parse error on input ‘:’
08:24:39 <k0ral> :t transpose
08:24:40 <lambdabot> [[a]] -> [[a]]
08:24:42 <Myrl-chan> c_wraith: Okay, thanks. :D
08:24:44 <orion> Hi. I am writing a WAI Application and I want to wrap it in a ReaderT (for application configuration). If I do so, how would I run hspec-wai tests on it?
08:25:45 <johnw> k0ral: ghci will do that with ":i"
08:26:18 <k0ral> :i Exception
08:26:35 <k0ral> doesn't lambdabot provide the same feature ?
08:26:43 <johnw> it does not
08:27:21 <SrPx> So I kinda managed to use V properly, but I don't see how it helps? As johnw said I can just use ^+^ etc without it... I guess what I'm asking for is a generic dimensional indexing for structures, is there such a thing?
08:27:33 <c_wraith> johnw: :i only lists instances it knows about (ie, are imported)
08:27:50 <SrPx> i.e., a "!" function that will work for list, vector, REPA arrays or whatever ? "my_structure ! [1,2]"
08:27:53 <c_wraith> johnw: so it doesn't help with "what instances of this are defined across the 30 packages I have installed?"
08:28:31 <johnw> SrPx: you mean like lens' "ix" function?
08:29:30 <Yrogirg> Hi! What would be the antonym for "point-free"?
08:29:51 <johnw> pointful?  having points?
08:30:03 <johnw> pointed
08:30:04 <c_wraith> I like "pointy"
08:30:18 <kqr> pointful is what I've heard
08:30:28 <mauke}> unpointless
08:30:44 <lpaste> ryanar pasted “How do I use Either in this context?” at http://lpaste.net/1916584939151687680
08:30:49 <k0ral> c_wraith: any suggestion then ?
08:31:03 <edwardk> srpx: linear doesn't 'ball all n-dimensions into one thing' it leaves them separate. so it can get away with nesting structures rather than dealing with complex index types. but we can index into something like linear using the fact that interesting vector spaces are representable functors
08:31:22 <edwardk> so that gives rise to a way to lens in with a member of that representation
08:31:27 <c_wraith> k0ral: I don't know of anything that does that across many packages.
08:31:30 <edwardk> "_x" is a lens in linear.
08:31:36 <kqr> Ryanar, mauke} told you earlier, either id id
08:32:04 <Ryanar> ah I guess I didn't or don't understand that, ill go investigate
08:32:13 <edwardk> srpx: http://hackage.haskell.org/package/adjunctions-4.2/docs/Data-Functor-Rep.html
08:32:25 <kqr> Ryanar, "either id id" is a function that will take whatever is in the left or right branch and return it as it is
08:32:34 <edwardk> see 'tabulate' and 'index'
08:32:39 <johnw> Ryanar: your "do" on line 7 in that paste is in the list monad, which is not what you want
08:32:50 <edwardk> tabulate takes a function from the index type to a value and builds a vector
08:32:56 <SrPx> "Representable endofunctors over the category of Haskell types are isomorphic to the reader monad and so inherit a very large number of properties for free."
08:32:57 <edwardk> index treats such a vector as a function
08:33:01 <johnw> either someMoreFun's return type must be Either String String, or you must use either id id, for example
08:33:06 * SrPx brain's freezes.
08:33:10 <johnw> also, you need to use "return v" there
08:33:10 <kqr> Ryanar, more generally "either f g" will inspect the either value, if it's a Left value, pass it to f and return the result, if it's a Right value pass it to g and return the result
08:33:16 <SrPx> Okay, I guess that is more than enough to keep me busy for some hours... hope I get it all
08:33:16 <edwardk> srpx:  that is a fancy way of saying f a is isomorphic to (x -> a) for some x
08:33:17 <SrPx> thanks :)
08:33:26 <emancu> @all hey everyone! I have a simple question: can I use named parameter and pattern matching for the same parameter ? i.e length <label_for_list>(x:xs) = 1 + length(xs)
08:33:38 <edwardk> e.g. Complex a is isomorphic to Bool -> a
08:33:39 <kqr> emancu, label@(x:xs)
08:33:42 <emancu> i want to use label_for_list instead of (x:xs)
08:33:49 <lambdabot> *** "Hey" gcide "The Collaborative International Dictionary of English v.0.48"
08:33:49 <lambdabot> Hey \Hey\, a. [See {High}.]
08:33:49 <lambdabot>    High. [Obs.] --Chaucer.
08:33:49 <lambdabot>    [1913 Webster]
08:33:49 <lambdabot>  
08:33:50 <emancu> kqr: i knew it! thanks very much!!
08:33:51 <lambdabot> [7 @more lines]
08:33:53 <lambdabot> *** "Everyone" gcide "The Collaborative International Dictionary of English v.0.48"
08:33:55 <lambdabot> Everyone \Ev"er*y*one`\, n. [OE. everychon.]
08:33:57 <lambdabot>    Everybody; -- commonly separated, every one.
08:33:59 <lambdabot>    [1913 Webster]
08:34:01 <lambdabot>  
08:34:03 <lambdabot> [10 @more lines]
08:34:03 <Ryanar> I think that makes sense
08:34:05 <lambdabot> *** "I" gcide "The Collaborative International Dictionary of English v.0.48"
08:34:07 <lambdabot> I \I\ ([imac]).
08:34:09 <lambdabot>    1. I, the ninth letter of the English alphabet, takes its
08:34:11 <lambdabot>       form from the Ph[oe]nician, through the Latin and the
08:34:13 <lambdabot>       Greek. The Ph[oe]nician letter was probably of Egyptian
08:34:15 <lambdabot> [190 @more lines]
08:34:15 <mauke}> emancu: look what you've done to lambdabot :-(
08:34:17 <lambdabot> *** "Have" gcide "The Collaborative International Dictionary of English v.0.48"
08:34:19 <lambdabot> Have \Have\ (h[a^]v), v. t. [imp. & p. p. {Had} (h[a^]d); p. pr.
08:34:19 <kqr> that is not well designed, lamba
08:34:21 <lambdabot>    & vb. n. {Having}. Indic. present, I {have}, thou {hast}, he
08:34:21 <edwardk> data Complex a = a :+ a -- so we can go one way with tabulate f = f False :+ f True; and the other with index (a :+ b) False = a; index (a :+ b) True = b
08:34:23 <lambdabot>    {has}; we, ye, they {have}.] [OE. haven, habben, AS. habben
08:34:25 <lambdabot>    (imperf. h[ae]fde, p. p. geh[ae]fd); akin to OS. hebbian, D.
08:34:26 <edwardk> SrPx: ^- that
08:34:27 <lambdabot> [233 @more lines]
08:34:29 <Ryanar> Oh jees.. what is that @all call
08:34:29 <lambdabot> *** "a" gcide "The Collaborative International Dictionary of English v.0.48"
08:34:31 <lambdabot> Gastropoda \Gas*trop"o*da\, n. pl., [NL., fr. Gr. ?, ?, stomach
08:34:33 <lambdabot>    + -poda.] (Zool.)
08:34:35 <lambdabot>    One of the classes of Mollusca, of great extent. It includes
08:34:37 <lambdabot>    most of the marine spiral shells, and the land and
08:34:39 <lambdabot> [592 @more lines]
08:34:43 <lambdabot> *** "Simple" gcide "The Collaborative International Dictionary of English v.0.48"
08:34:45 <lambdabot> Simple \Sim"ple\, a. [Compar. {Simpler}; superl. {Simplest}.]
08:34:47 <lambdabot>    [F., fr. L. simplus, or simplex, gen. simplicis. The first
08:34:49 <lambdabot>    part of the Latin words is probably akin to E. same, and the
08:34:51 <lambdabot>    sense, one, one and the same; cf. L. semel once, singuli one
08:34:52 <Ryanar> how to make lambda stop haha
08:34:53 <lambdabot> [309 @more lines]
08:34:57 <lambdabot> *** "Question" gcide "The Collaborative International Dictionary of English v.0.48"
08:34:59 <lambdabot> Question \Ques"tion\, n. [F., fr. L. quaestio, fr. quaerere,
08:35:00 <emancu> =( im sorry
08:35:01 <lambdabot>    quaesitum, to seek for, ask, inquire. See {Quest}, n.]
08:35:03 <lambdabot>    1. The act of asking; interrogation; inquiry; as, to examine
08:35:05 <lambdabot>       by question and answer.
08:35:07 <lambdabot> [232 @more lines]
08:35:08 <edwardk> emancu: nice
08:35:09 <lambdabot> *** "can" gcide "The Collaborative International Dictionary of English v.0.48"
08:35:09 <emancu> its a convention on my team..
08:35:10 <johnw> wow, what an effective spambot he is
08:35:11 <lambdabot> May \May\ (m[=a]), v. [imp. {Might} (m[imac]t)] [AS. pres. maeg
08:35:11 <Ryanar> emancu, hahahaha, well, it coulda been me
08:35:13 <lambdabot>    I am able, pret. meahte, mihte; akin to D. mogen, G.
08:35:15 <lambdabot>    m["o]gen, OHG. mugan, magan, Icel. mega, Goth. magan, Russ.
08:35:17 <lambdabot>    moche. [root]103. Cf. {Dismay}, {Main} strength, {Might}. The
08:35:19 <lambdabot> [242 @more lines]
08:35:21 <lambdabot> *** "I" gcide "The Collaborative International Dictionary of English v.0.48"
08:35:22 --- mode: ChanServ set +o geekosaur
08:35:23 <lambdabot> I \I\ ([imac]).
08:35:25 <lambdabot>    1. I, the ninth letter of the English alphabet, takes its
08:35:25 <ion> :-D
08:35:27 <lambdabot>       form from the Ph[oe]nician, through the Latin and the
08:35:29 <lambdabot>       Greek. The Ph[oe]nician letter was probably of Egyptian
08:35:31 <lambdabot> [190 @more lines]
08:35:31 <emancu> ok.. i broke the channel xD
08:35:33 <lambdabot> *** "Use" gcide "The Collaborative International Dictionary of English v.0.48"
08:35:34 --- mode: geekosaur set +q lambdabot!*@*
08:35:39 <Ryanar> HAHAHA
08:35:45 <boxfire> wow. what the hell was it reciting
08:35:51 <Ryanar> whatever @all is
08:35:55 <mauke}> boxfire: it was looking up words in a dictionary
08:36:02 <joneshf-laptop> So `Functor`s compose, and `Compose` exists, but is there some way to have an instance of `Functor` for two `Functor`s that doesn't require the use of the data type?, like `instance (Functor f, Functor g) => Functor (f . g) where fmap = fmap.fmap`
08:36:05 --- mode: geekosaur set -q lambdabot!*@*
08:36:07 <mauke}> probably @all-dicts
08:36:11 <Ryanar> thanks geekosaur !
08:36:23 <edwardk> joneshf-laptop: no
08:36:38 <boxfire> so I am curious about using haskell via CLaSH as an HDL, I am wondering if anyone here has messed with it
08:37:16 <geekosaur> lambdabot op will have to bring it back at some point, presumably
08:37:20 --- mode: geekosaur set -o geekosaur
08:37:41 <mauke}> can you /invite it back?
08:37:54 <edwardk> i had it part one sec
08:38:05 <lambdabot> [90 @more lines]
08:38:09 <lambdabot> No match for "<label_for_list>(x:xs)".
08:38:09 <edwardk> damnit
08:38:10 <geekosaur> oy
08:38:11 <lambdabot> *** "=" foldoc "The Free On-line Dictionary of Computing (20 July 2014)"
08:38:13 <ion> :-D
08:38:13 <lambdabot> equals
08:38:15 <lambdabot> =
08:38:16 <Ryanar> HAHAHAHAHA
08:38:16 <joneshf-laptop> haha
08:38:17 <mauke}> nooo
08:38:17 <lambdabot>  
08:38:17 <edwardk> @leave #haskell
08:38:18 <bennofs> ping int-e 
08:38:19 <lambdabot>    <character> "=", {ASCII} character 61.
08:38:21 <lambdabot> [14 @more lines]
08:38:22 <KaneTW> hahah
08:38:23 <lambdabot> *** "1" gcide "The Collaborative International Dictionary of English v.0.48"
08:38:24 --- mode: ChanServ set +o geekosaur
08:38:25 <lambdabot> 1 \1\ adj.
08:38:26 <Ryanar> that is hilarious
08:38:27 <lambdabot>    1. used of a single unit or thing; not two or more; --
08:38:29 <lambdabot>       representing the number one as an Arabic numeral.
08:38:31 <lambdabot>  
08:38:33 <lambdabot> [29 @more lines]
08:38:35 <joneshf-laptop> it's almost over it looks like
08:38:35 <lambdabot> *** "+" foldoc "The Free On-line Dictionary of Computing (20 July 2014)"
08:38:37 <edwardk> that was pretty funny =)
08:38:37 <lambdabot> plus
08:38:39 <lambdabot> +
08:38:41 <lambdabot>  
08:38:43 <lambdabot>    <character> "+", {ASCII} character 43, 0x2B.  The mathematical
08:38:45 <lambdabot> [21 @more lines]
08:38:47 <lambdabot> No match for "length(xs)".
08:38:49 <Ryanar> should we just let it go
08:38:57 <Ryanar> bring it back in an hour
08:38:59 --- mode: geekosaur set -o geekosaur
08:39:07 <joneshf-laptop> that's the end of the line
08:39:07 <edwardk> int-e can restart it with the queue flushed
08:39:10 <mauke}> it's about done
08:39:15 <mauke}> "length(xs)" was the last words
08:39:33 <edwardk> ah
08:39:34 <edwardk> ok
08:39:36 <joneshf-laptop> and then it processed edwardk 's `@leave` it ooks like
08:40:00 <mauke}> > ()
08:40:01 <lambdabot>  ()
08:40:07 <joneshf-laptop> :)
08:40:35 <KaneTW> it might be a freenode branch thing
08:40:39 <KaneTW> oh
08:40:42 <KaneTW> no
08:40:44 <KaneTW> there it goes
08:40:57 <Ryanar> where is the Either function located?
08:41:09 <KaneTW> https://a.pomf.se/hmpwzs.png
08:41:45 <Ryanar> I tried Data.Either but it wasn't working, maybe it's something else
08:42:09 <dmj`> Ryanar: the either function?
08:42:12 <Ryanar> yeah
08:42:14 <dmj`> @src either
08:42:14 <lambdabot> either f _ (Left x)  = f x
08:42:14 <lambdabot> either _ g (Right y) = g y
08:42:17 <mauke}> @index either
08:42:17 <lambdabot> Data.Either, Prelude
08:42:23 <dmj`> it's in Data.Either
08:42:27 <mauke}> it's in Prelude
08:42:29 <srhb> It's also in Prelude nowadays
08:42:31 <Ryanar> ah, I was doing Either not 'either'
08:42:39 <mauke}> @index Either
08:42:39 <lambdabot> Data.Either, Prelude
08:42:45 <mauke}> also in Data.Either and Prelude
08:43:12 <dmj`> Ryanar: anything capitalized will be a data constructor (which is still a function), unless it's in the type sig, then it's a type constructor
08:43:27 <e4x> I have to write a function that reads a file char by char, and returns a word, ignoring all nonalpha characters before the word, for example "/(&/((/this is an example" should return "this", and a second call of this function should return "is". My question is, should i have to use monads? Sorry about my english.
08:43:29 <Ryanar> Ok that makes sense
08:43:29 <mauke}> unless it doesn't take arguments, then it's not a function
08:43:37 <dmj`> mauke}: true
08:43:42 <dmj`> it's just a value then
08:43:57 <mauke}> e4x: no, IO should be enough
08:44:36 <srhb> > head . words . filter (isAlpha) $ "/%^$$##@$this is an example"
08:44:37 <lambdabot>  "thisisanexample"
08:44:41 <srhb> Oh derp
08:44:44 <srhb> or isSpace
08:44:46 <srhb> But that.
08:45:22 <kqr> e4x, why not construct a list of all the words and then loop through that
08:45:28 <kqr> e4x, instead of call the function multiple times?
08:47:27 <srhb> > take 2 . words . filter (\c -> isAlpha c || isSpace c) $ "/%^$$##@$this is an example" ++ undefined -- lazy lists are nice, e4x
08:47:29 <lambdabot>  ["this","is"]
08:47:49 <lpaste> ryanar annotated “How do I use Either in this context?” with “How do I use Either in this context? (annotation)” at http://lpaste.net/1916584939151687680#a4375390897920016384
08:48:06 <Ryanar> So this works and makes sense
08:48:17 <kqr> Ryanar, you don't need the do
08:48:31 <Ryanar> I realize the do is redundant but I was testing it for how it would appear in my actual code
08:48:37 <Ryanar> where it is Either String (String, String)
08:48:55 <kqr> the do might not have the effect you think it does
08:49:10 <Ryanar> in which case it would be Right (Prefix, Abbr) -> do abbr
08:49:15 <kqr> well, in this case it does nothing, but it's not the IO-do, it's the list do
08:49:15 <Ryanar> oh
08:49:26 <Ryanar> well im not trying to do IO I just want to return the sring
08:49:28 <Ryanar> string*
08:49:31 <kqr> then skip the do :)
08:49:35 <kqr> any value is returned as it is
08:50:05 <kqr> the do will only confuse things later on if you're not trying to do IO
08:50:11 <kqr> because code that does the wrong thing might compile
08:50:42 <srhb> Ryanar: And with that type, either id id would do the same as your case
08:50:55 <Ryanar> yeah I just dont understand how the either works haha
08:51:05 <srhb> either (left transforming function) (right transforming function)
08:51:12 <kqr> Ryanar, don't worry about it if you don't understand it
08:51:19 <kqr> Ryanar, it will come to you
08:51:31 <kqr> Ryanar, unless you're curious, of course, in which case by all means
08:51:50 <kqr> Ryanar, as long as you understnd the case…of you have, you'll get by
08:51:57 <lpaste> ryanar pasted “Ok with the removal of do” at http://lpaste.net/7459228427774590976
08:52:16 <kqr> yup. looks good to me!
08:52:18 <Ryanar> yeah I will look at it again more as I fully explore monads
08:52:31 <Ryanar> thanks for the help guys
08:52:47 <orion> I just noticed that mail.haskell.org is secured by TLS, but the form located here does not POST to a HTTPS URL: https://mail.haskell.org/mailman/listinfo/beginners
08:52:48 <srhb> Ryanar: Has nothing to do with the Either monad :)
08:53:07 <Ryanar> but its using the results of the Either monad Left Right?
08:53:11 <srhb> Ryanar: Or to put it differently, you're not using the Either monad at all
08:53:13 <srhb> Nope
08:53:15 <Ryanar> oh
08:53:17 <Ryanar> :(
08:53:21 <srhb> Either l r is just a data type.
08:53:23 <e4x> srhb: thanks
08:53:28 <Ryanar> ah I see
08:53:34 <Ryanar> that makes a lot more sense now
08:53:39 <Ryanar> about why I was so confused
08:53:49 <kqr> Ryanar, either f g e = case e of { Left x -> f x; Right x -> g x }
08:53:51 <srhb> Either l has a Monad instance, but you're not using it :)
08:53:58 <kqr> Ryanar, that's how it's defined, if that helps
08:54:54 <kqr> Ryanar, and id is defined as id x = x
08:55:13 <kqr> Ryanar, it's really silly simple once you understand it, which is a problem if you expect it to be advanced!
08:55:20 <Ryanar> yeah I understand id x = x
08:55:24 <Ryanar> its just the identity
08:55:27 <srhb> Mhm.
08:55:49 <srhb> > either id snd $ Right (4,"2")
08:55:50 <lambdabot>  "2"
08:59:04 <wz1000> What data structure should I use if I want to simulate a large number of particles colliding with each other in gloss?
09:00:13 * hackagebot future-resource 0.4.0.0 - realtime resource handling with manual concurrency  http://hackage.haskell.org/package/future-resource-0.4.0.0 (capsjac)
09:00:27 <kqr> out of curiosity, is there a way to do "either id snd" with prisms or some other optic combination?
09:00:45 <bennofs> :t either id snd
09:00:47 <lambdabot> Either c (a, c) -> c
09:03:33 <srhb> :t over _Right snd
09:03:34 <lambdabot> Either c (a, b) -> Either c b
09:03:41 <srhb> kqr ^^
09:03:49 <srhb> Oh wait
09:03:50 <kqr> then what
09:03:55 <srhb> Yeah, not over
09:04:12 <kqr> well
09:04:16 <kqr> I figured out a way, I think
09:04:47 <kqr> view (to (either id snd))
09:04:49 <kqr> but that doesn't count :(
09:05:02 <srhb> :D
09:05:17 <kqr> because it probably doesn't scale all that well
09:05:25 <srhb> Honestly I don't see the use anyway.. :)
09:05:28 <kqr> I'm imagining wanting to do this as part of a long traversal
09:05:41 <kqr> wait
09:05:49 <kqr> no
09:05:51 <kqr> I don't know
09:05:53 <kqr> :(
09:06:49 <srhb> But still, in a traversal, to (either id snd) would be fine
09:06:59 <srhb> And it's almost English!
09:07:52 <indiagreen> srhb: only if you want to use it as a getter
09:07:58 <srhb> Sure.
09:08:30 <bennofs> :t alongside
09:08:31 <lambdabot> LensLike (Control.Lens.Internal.Getter.AlongsideLeft f b') s t a b -> LensLike (Control.Lens.Internal.Getter.AlongsideRight f t) s' t' a' b' -> LensLike f (s, s') (t, t') (a, a') (b, b')
09:09:00 <glguy> view (choosing id _2) x :: Field2 s s b b => Either b s -> b
09:09:06 <bennofs> :t choosing
09:09:07 <lambdabot> Functor f => LensLike f s t a b -> LensLike f s' t' a b -> LensLike f (Either s s') (Either t t') a b
09:09:08 <KaneTW> jesus christ that type
09:09:13 <kqr> KaneTW, lol
09:09:14 <bennofs> ah, that was what I was looking for
09:09:22 <mauke}> (s t a b, s t a b)
09:09:46 <Lezkus> hi all
09:09:49 <edwardk> choosing id _2 is it
09:09:50 * bennofs always confuses beside, choosing and alongside
09:09:54 <bennofs> :t confusing
09:09:56 <lambdabot> Applicative f => LensLike (Data.Functor.Kan.Rift.Rift (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
09:10:11 <Lezkus> I'm having some problems reading text from a file in ghci 7.10.1
09:10:13 <edwardk> confusing is so named as it has probably the most confusing implementation in lens =)
09:10:22 <Lezkus> with readFile
09:10:31 <edwardk> glguy++
09:10:43 * glguy goes for his half of a high-five
09:11:01 <edwardk> confusing (a.long.chain.of.traversals)   computes a traversal that works faster than a.long.chain.of.traversals
09:11:01 <kqr> bennofs, edwardk: thanks @choosing. just what I hoped for
09:11:25 <Lezkus> it's throwing this exception: Exception: ./quijote.txt: hGetContents: invalid argument (invalid byte sequence), when trying to read a file with the line r <- readFile "quijote.txt"
09:11:36 <edwardk> fusing (a.long.chain.of.lenses) computes a lens that works faster than a.long.chain.of.lenses   whenever the inliner would fail to inline the lens
09:11:50 <Lezkus> anyone knows what can be the problem?
09:12:13 <glguy> Lezkus: readFile is trying to read a UTF-8 encoded text file
09:12:44 <edwardk> e.g. consider _2 f (a,b) = (,) a <$> f b  -- that fmap once. so _2._2 fmaps twice. 'fusing' fuses the fmaps together into a single fmap
09:12:46 <kqr> edwardk, so you like puns, huh
09:12:46 <Lezkus> glguy: What can I do in order to solve this?
09:13:05 <Lezkus> glguy: This same line worked in ghci 7.6.X 
09:13:07 <edwardk> kqr: they are useful mnemonic aids to help me remember what these things are later
09:13:11 <glguy> Lezkus: You can fix the text file or open it as a binary file
09:13:39 <glguy> Lezkus: If you put the code and/or the text file on a paste bin we can be more helpful: http://lpaste.net/new/haskell
09:13:54 <mauke}> :t alongside :: LensLike (Control.Lens.Internal.Getter.AlongsideLeft f type') jesus christ that typе -> LensLike (Control.Lens.Internal.Getter.AlongsideRight f christ) jesus' christ' that' type' -> LensLike f (jesus, jesus') (christ, christ') (that, that') (typе, type')
09:13:55 <lambdabot> LensLike (Control.Lens.Internal.Getter.AlongsideLeft f type') jesus christ that typ5 -> LensLike (Control.Lens.Internal.Getter.AlongsideRight f christ) jesus' christ' that' type' -> LensLike f (jesus, jesus') (christ, christ') (that, that') (typ5, type')
09:14:06 <kqr> hahah
09:14:12 <Lezkus> @glguy well, it's a 2MB file...  jajajajaja
09:14:12 <lambdabot> Unknown command, try @list
09:14:21 <kqr> but whatever you do, don't try @all
09:14:31 <Lezkus> glguy: It has some spanish character, ñ
09:14:37 <kqr> Lezkus, you a windows user?
09:14:51 <Lezkus> @kqr nope, arch
09:14:51 <lambdabot> Har de har har!
09:15:06 <kqr> Lezkus, what kind of file is it? text?
09:15:09 <Lezkus> kqr: but this same program worked on windows with 7.6.X ghci this morning
09:15:25 * slack1256 Oh el poder del espaÑol
09:15:56 <Lezkus> kqr: yep, it's "don Quixote", so it's a spanish texts and thus it has ñ's (an spanish letter)
09:16:12 <kqr> Lezkus, you should be able to save it as UTF-8 using the editor of your choice
09:16:37 <lpaste> Lezkus pasted “Reading from a file ” at http://lpaste.net/131239
09:17:59 <bennofs> Lezkus: using 'file /path/to/your/file' on the command line sometimes prints the encoding of the file
09:19:28 <mauke}> if you have vim: 'vim quijote.txt' to open the file; ':set fenc=utf-8' to switch the encoding; ':x' to save and exit  (this assumes the file is in latin-1 or similar)
09:19:37 <lpaste> glguy annotated “Reading from a file ” with “Reading from a file  (annotation)” at http://lpaste.net/131239#a131240
09:19:50 <glguy> Lezkus: You can specify the encoding like this if it's not actually UTF8
09:19:51 <Lezkus> oh, I see
09:20:09 <Lezkus> I did a :set fileencoding in vim and it said that the format was "latin12
09:20:13 <Lezkus> "latin1"
09:20:36 <glguy> Lezkus: if that's true you can use what I pasted: readFileEnc latin1 "quijote.txt"
09:21:26 <Lezkus> Thank you glguy, mauke} and kqr, now works!!
09:21:36 <Lezkus> glguy++ 
09:21:46 <Lezkus> mauke}++ kqr++
09:21:54 <Lezkus> (does this even works?)
09:22:07 <glguy> I certainly feel more
09:22:12 <mauke}> @karma mauke} 
09:22:12 <lambdabot> You have a karma of 1
09:22:18 <mauke}> :-)
09:22:30 <Lezkus> jajajajajaja
09:22:32 <Lezkus> great!
09:22:35 <Lezkus> thank you again!
09:22:49 <glguy> @karma mauke]
09:22:49 <lambdabot> mauke] has a karma of 0
09:22:52 <glguy> lambdabot: bot
09:22:53 <glguy> bug*
09:23:04 <Lezkus> I'm new in this "functional world"
09:23:32 <kqr> isn't it great
09:23:45 <int-e> eh what have you done to the poor bot?
09:23:52 <mauke}> glguy: debatable
09:23:59 <mauke}> karma is used for non-nicks too
09:24:24 <mauke}> int-e: used @all with a sentence
09:24:30 <mauke}> which I assume runs @all-dict
09:24:44 <int-e> fun :-/
09:24:56 <mauke}> does anyone really use the dict module?
09:25:42 <kqr> yeah emancu does
09:27:59 <mauke}> has anyone really been far even as decided to use even go want to do look more like?
09:29:59 <johnw> mauke}: wut?
09:30:57 <dmj`> mauke}: Only once, but yes
09:31:28 <glguy> I'm not sure that I've ever been that far
09:33:05 <dmj`> even if you look more like, nobody will want to go as far really
09:34:44 <SrPx> edwardk: ha. I finally get what you said with Complex. And it only took one hour. /dances
09:35:00 <indiagreen> I usually get such sentences when I use the “predict next word” button several times in a row
09:35:09 <int-e> @all
09:35:15 * hackagebot bindings-GLFW 3.1.1.3 - Low-level bindings to GLFW OpenGL library  http://hackage.haskell.org/package/bindings-GLFW-3.1.1.3 (SchellScivally)
09:35:16 <lambdabot> Maybe you meant: url tell roll pl ask arr
09:35:23 <SrPx> now on to figuring out how Rep relates to my problem
09:36:15 <int-e> (I just disabled the all-dicts command, hoping that the rest are harmless. I'll try to understand why the "more lines" mechanism didn't catch this one...)
09:37:00 <int-e> I mean if it had said [3000 @more lines] that would have been good for a chuckle, but harmless...
09:37:04 <kqr> int-e, the more lines mechanism did catch, but it applied only to individual lookups
09:37:11 <kqr> maybe that's what you meant though
09:37:16 <int-e> kqr: yes.
09:45:37 <int-e> Ah, I think I fixed the wrong problem.
09:48:07 <edwardk> srpx: 'index' is the function that takes a 'vector' and indexes into it.
09:48:34 <edwardk> e.g. consider      index (index m 1) 2 
09:48:55 <edwardk> looks at row 1, column 2 in a matrix.
09:51:27 <SrPx> Yep I kinda get that, but how? For example, "main = print $ index [0..8] 0" obviously won't compile, so now I'm trying to make an instance for [] that makes sense
09:54:22 <feryll> Anybody else familiar/know how to deal with the issue where backspaces, arrow keys etc. are read by fmap read getLine when running from a command line, which usually results in a "no parse" error?
09:55:09 <SrPx> I guess I don't understand the "Rep" there, tabulate :: (Rep f -> a) -> f a
09:55:27 <SrPx> it is listed as an "associated type", "type Rep f :: *"
09:56:02 <SrPx> I never heard of that, but I guess that somehow refers to the type representing the list? So I can say "List is representable by Int" or "List is representable by [Int] (for ndimensional indexing)" ? Does that make sense?
09:56:02 <Saizan> feryll: maybe if you change the buffering options to LineBuffering?
09:56:20 <feryll> Saizan: Hm, let me look into that
09:57:35 <int-e> @all hello cruel world
09:57:41 <lambdabot> Sorry, look up one word at a time please.
09:59:07 <int-e> kqr: That's what happened, it looked up all the words following @all separately...
09:59:49 <feryll> Saizan: Good, I got the backspaces to work properly, though is there any way it could also be configured to ignore arrow keying?
10:01:45 <orion> What is the purpose of the "other-modules" section in the executable portion of a project's cabal file?
10:02:03 <dcoutts> orion: all modules in a component must be listed one way or another
10:02:05 <SrPx> this is what I have, btw: http://lpaste.net/131242 please don't laugh I know this is stupid
10:02:31 <int-e> orion: Presumably cabal sdist needs a complete list.
10:02:35 <dcoutts> orion: in a lib that means exposed-modules and other-modules, in an exe that means main-is and other-modules
10:02:47 <aidecoe> main = do { _ <- readLn :: IO Int; interact (show . isOk); } where isOk :: String -> Bool
10:03:01 <aidecoe> i have a problem with this code ↑
10:03:02 <dcoutts> orion, int-e: it's also required for pre-processors to work
10:03:45 <int-e> dcoutts: makes sense. it should really be required for ordinary building, but ghc --make is too smart.
10:03:58 <SrPx> interesting, adding "type Rep [] = Int" below "instance Representable [] where" miraculously seems to help ... I guess
10:04:12 <phaazon> hm
10:04:25 <phaazon> I don’t get why for 30 . time always prints 0
10:04:29 <SrPx> But now I need an instance of Data.Distributive.Distributive for []? Hmm...
10:04:36 <aidecoe> if show . isOk returns False, then interact returns immediately
10:04:38 <aidecoe> why?
10:05:34 <indiagreen> would readFile work with a Posix-like path ("a/b/c") on Windows?
10:06:23 <benzrf> whyyy is ghc using 75% memory
10:06:23 <orion> dcoutts: However, if I create a module called "Blah" for my executable and omit the other-modules section entirely, the project still builds just fine.
10:06:26 <benzrf> this CANT be right
10:06:38 <benzrf> can i put resource limits on it :\
10:06:41 <johnw> if you have 512MB, it could be right
10:06:55 <aidecoe> as far as i understand "interact" processes line by line until EOF
10:07:03 <benzrf> VIRT 3959M, RES 2889M
10:07:15 <dcoutts> orion: it's not checked/enforced for exes during build, but "bad things" will happen in the general case
10:07:18 <benzrf> MEM% 75.0
10:07:19 <dcoutts> orion: same for libs
10:07:21 <benzrf> according to htop
10:07:30 <benzrf> im doing `cabal install gloss'
10:07:33 <johnw> using -O2?
10:07:54 <dcoutts> orion: same for libs, only worse.
10:07:54 <benzrf> i dunno
10:07:58 <benzrf> i just did 'cabal install gloss'
10:08:00 <benzrf> >_>
10:08:10 <orion> hmm... "bad things". :)
10:08:11 <johnw> well, that could be normal
10:09:45 <c_wraith> aidecoe: interact processes as a lazy string transformation.  Though the terminal line-buffers, which might be the cause of the misunderstanding
10:10:25 <phaazon> dammit
10:10:28 <Saizan> feryll: maybe you just want to filter out non-printable characters? or go with something fancier like readline
10:10:33 <benzrf> whoa wtf is it building base
10:10:41 <phaazon> I think there’s something I don’t do correctly in the time part of netwire
10:10:43 <benzrf> oh i see
10:10:46 <benzrf> nm
10:10:48 <benzrf> *nvm
10:10:51 <aidecoe> c_wraith: ah… as a single string, right?
10:10:58 <aidecoe> c_wraith: so i need to unlines
10:11:33 <feryll> Saizan: Filtering out non-printable characters is probably best. Is there a quick native function to do that, or just filter alphanumeric + some specials on the getLine string, or...?
10:12:17 <athan> Hey dudes, does a fold over an HList need to have higher-rank quantification?
10:12:33 <slomo> feryll: isPrint
10:12:40 <johnw> athan: I would think so
10:12:40 <slomo> feryll: from Data.Char
10:13:21 <feryll> slomo: Thanks, I'll keep that in mind. Though I found hSetBuffering NoBuffering has sufficed for now.
10:15:01 <b2coutts> is there a nice way to construct strings in haskell, like sprintf? I've used Printf before, but that was kind of an awful hack
10:15:28 <b2coutts> having long lines with strings, ++, and show is getting tiresome
10:16:42 <phaazon> huh
10:16:44 <phaazon> http://lpaste.net/2415365216427573248
10:16:52 <phaazon> I think that is wrong
10:16:59 <johnw> b2coutts: there are several ways, search Hackage
10:18:15 <Saizan> feryll: NoBuffering makes it work?
10:19:04 <fragamus> hey I was messing around with :{ :} in ghci and now im stuck in a weird mode where anything I type, it comes up with Prelude| on the next line
10:19:05 <feryll> Saizan: Yeah, and through some further testing LineBuffering does too, though I had (mistakenly) thought the arrow keys still caused problems.
10:19:19 <fragamus> I even restarted ghci
10:20:29 <hodapp> hrmph, for Shake's addOracle/askOracle I must have a different type for each invocation of addOracle, which is annoying as right now I have 4-5 builds that are defined by different instances of a single type, not 4-5 different types
10:21:25 <hodapp> guess I need to find some way to create types whose only purpose is to be unique
10:23:44 <hodapp> but the main type that is driving everything in the build is a record that is *not* polymorphic... and I'd like to avoid having to parametrize it over some other type, because that'll force me to change every single usage of it, won't it?
10:25:02 <hodapp> but I'm not sure what else I can do, other than make the main Shake call/rule polymorphic
10:25:51 <eacameron> the let syntax indentation is driving me crazy; I want to say "let x = do" and then have an indented block. Any ideas?
10:26:03 <johnw> double indent the do block
10:26:50 <eacameron> johnw: Doesn't it require that the block be after the column of the '=' sign+
10:26:51 <eacameron> ?
10:27:13 <glguy> it has to be to the left of the 'x'
10:27:14 <srhb> Further than the x should be fine
10:27:24 <srhb> Uh...
10:27:35 <slack1256> it ought to
10:27:47 <eacameron> hm, ok. I'll try that....I've reverted to "x <- return $ do..."
10:27:55 <chpatrick> anyone else find that ugly or is it just me
10:28:06 <eacameron> but that makes me cringe too
10:28:07 <chpatrick> I'd much prefer to have a single indent level after that
10:28:40 <hodapp> hm, what's the term for a type whose only purpose is to be unique?
10:28:51 <srhb> hodapp: Uniqueness type?
10:28:56 <hodapp> sure, let's go with that
10:28:58 <yasar11732> can someone help me out here: http://stackoverflow.com/q/29804823/886669
10:29:21 <srhb> Or simply unique type, I guess :P
10:29:25 <hodapp> perhaps I'm using it like a Proxy since I don't actually care about the value...
10:29:55 <srhb> yasar11732: Do you know what foo <- bar is syntax sugar for?
10:30:32 <srhb> yasar11732: https://en.wikibooks.org/wiki/Haskell/do_notation -- might be a good read to start out with :)
10:31:14 <srhb> hodapp: I'm not sure how Shake works, but if you were worried about making your non-polymorphic type polymorphic, can't you invert it and embed your type in some other type and tag it with a phantom type?
10:31:53 <mniip> > do x | False <- [0]; return x
10:31:56 <lambdabot>  <hint>:1:6: parse error on input ‘|’
10:32:02 <mniip> hm not exactly a direct translation then
10:32:22 <grumpi1> is someone here who ported a Python/Django project to Haskell, by any chance? Or someone who came to Haskell web development after being a Django developer?
10:32:42 <srhb> grumpi1: The latter, for me.
10:32:43 <SrPx> Ok I'm out of ideas, does anyone know how to make this work? http://lpaste.net/131246
10:33:01 <yasar11732> srhb: I have a function in a monad, which is quite confusing
10:33:28 <yasar11732> I cant tell if <- would yield the function or the result of the function call
10:33:37 <srhb> yasar11732: Go with the types
10:33:51 <srhb> yasar11732: The right hand side will be m a for some m and a, and the left hand side will be a
10:34:30 <yasar11732> so, it will just return the function in monad, which is again confusing because how the function then got executed?
10:34:43 <grumpi1> srhb: what was the thing that you enjoyed most after switching camps?
10:34:45 <joneshf-laptop> yasar11732, desugaring it might help
10:34:56 <srhb> grumpi1: A real type system. :)
10:35:08 <yasar11732> it just bind function to c1, and return it?
10:35:18 * hackagebot octohat 0.1.4.1 - A tested, minimal wrapper around GitHub's API.  http://hackage.haskell.org/package/octohat-0.1.4.1 (stackbuilders)
10:35:30 <srhb> yasar11732: item is not a function, per se.
10:35:32 <joneshf-laptop> yasar11732, i mean actually desugaring it in the code
10:35:36 <eacameron> grumpi: I've done django but I don't do web in haskell. After using Haskell for a while Python feels like building with jello
10:35:54 <grumpi1> I'm personally at a point where the lack of static typing makes me grumpy
10:35:54 <srhb> eacameron: Basically that, yeah. :P
10:35:58 <joneshf-laptop> yasar11732, trying writing `takeThreeDropSecond'` which is just `takeThreeDropSecond` but without the sugar
10:36:01 <eacameron> it's really easy to use. but hard to make things stand up
10:36:01 <srhb> grumpi1: That's it, indeed. :)
10:36:20 <yasar11732> joneshf-laptop ok, I will try that
10:36:35 <srhb> And I've reached the point where I find Haskell way easier to use. Both because my Python has rusted, but also because having the type system help me is such a tremendous aid.
10:36:43 <eacameron> grumpi1: Python is statically typed: everything's the same type
10:37:05 <grumpi1> eacameron: haha, ok, but that doesn't really help :D
10:37:30 <grumpi1> basically, I started a year ago to learn Python and Django from scratch - after having a background in Isabelle/HOL verification
10:37:30 <eacameron> grumpi1: haha...oh was I supposed to be helpful?? ;) I'm better at pithy sayings
10:38:01 <srhb> grumpi1: I think you will find Haskell webdev pleasing if you find Haskell pleasing.
10:38:24 <eacameron> grumpi1: I'm guessing you've looked at Yesod and Snap?
10:38:30 <srhb> grumpi1: It doesn't feel like you're suddenly doing something else than whatever other thing you're doing in Haskell. Unlike how Django enforces a very django-esque feel on everything.
10:38:36 <eacameron> They are fully-featured like Django
10:39:14 <grumpi1> I looked at Yesod some months back but didn't dare to join in on the fun because I didn't understand a lot - similar to Django
10:39:40 <srhb> Yesod is quite a bit more frameworky than Snap, though.
10:39:51 <eacameron> grumpi1: If you're new to haskell, you might prefer something really lightweight, like Scotty
10:39:53 <SrPx> okay I give up :(
10:40:42 <grumpi1> I recently read about Happstack being quite modular having a minimal place to start from
10:40:46 <srhb> grumpi1: If you haven't seen, there are irc channels for most of the frameworks here on Freenode.
10:41:12 <srhb> grumpi1: Happstack is cool, I started with that. I since moved on, mostly because there are more lively communities around the others.
10:41:34 <eacameron> grumpi1: I don't know much about happstack. I think Snap is also fairly modular too. Happstack seems a bit out of date these days??
10:41:44 <eacameron> I'm going by hearsay
10:41:46 <srhb> eacameron: I think it works just fine.
10:41:53 <srhb> But yes, Snap is very modular with Snaplets.
10:42:14 <eacameron> srhb: ok....just seemed like not much attention was going toward it. maybe because the others are newer
10:42:32 <joneshf-laptop> SrPx, doesn't your `Rep` need to have kind `* -> *`?
10:42:38 <srhb> eacameron: The community has moved on to other things, but I don't think outdated is the right word still. :)
10:42:50 <SrPx> hmm it does? Why?
10:42:50 <eacameron> srhb: fair enough
10:42:55 <joneshf-laptop> @kind Int
10:42:57 <lambdabot> *
10:43:07 <joneshf-laptop> @kind Int -- SrPx 
10:43:08 <lambdabot> *
10:43:24 <grumpi1> sounds like I really have to look at Snap - basically, I'm one of these people that stumble around in the dark until they find something that works :)
10:43:24 <joneshf-laptop> SrPx, http://hackage.haskell.org/package/profunctors-4.4.1/docs/Data-Profunctor-Rep.html#t:Rep
10:43:30 <SrPx> I know, I mean, why does it need to be * → * ?
10:43:34 <joneshf-laptop> because that's how it's defined
10:43:39 <joneshf-laptop> also because the constraint
10:43:39 <SrPx> Oh
10:43:45 <srhb> grumpi1: Otherwise Scotty and Spock are really minimal and nice to get a feel for things.
10:43:52 <joneshf-laptop> `Functor (Rep p)`
10:43:54 <srhb> grumpi1: And migrating between frameworks is surprisingly easy.
10:44:06 <joneshf-laptop> SrPx, so `Rep p` must be `* -> *`
10:44:10 <SrPx> But then I don't get it. Isn't "Rep" like the "key" ? Hmm
10:44:26 <SrPx> what can I use instead of Int?
10:44:27 <eacameron> grumpi1: the tough thing about haskell is that it and the community applies more rigor to *everything* it touches; so while Pythonistas are used to "hand-waving" things; Haskellers tend to get things right at a much deeper level. but that part can take a lot of work to understand
10:44:48 <grumpi1> considering how functional languages seem to be pretty minimal in offering ways how to shoot yourself in the foot, it makes sense that things are more interoperable by default
10:45:31 <SrPx> No, wait. Here it says something different: http://hackage.haskell.org/package/adjunctions-4.2/docs/Data-Functor-Rep.html#t:Representable
10:45:33 <grumpi1> eacameron: yeah, I see a lot of code in Python that makes me cringe and want to run away - but I don't know Python well enough to be able to claim that the code I write is better
10:45:39 <SrPx> type Rep f :: *
10:46:12 <srhb> grumpi1: Safe by construction makes one feel warm and fuzzy inside, but you already know that. :-)
10:46:17 <bennofs> SrPx: you were looking at representable profunctors first, which are different from representable functors
10:46:36 <eacameron> grumpi1: yeah, you'll still scratch your head in Haskell, but for a different reason (not "Why are they doing this? but "What is this doing?")
10:46:39 <SrPx> I was?
10:46:57 <grumpi1> srhb: yep, knowing I can refactor without breaking things all over the place would be a huge gain - definitely worth the effort to learn how things work at the core
10:47:13 <bennofs> SrPx: oh, no, sorry. the link from joneshf-laptop was to profunctors while you linked to functor version
10:47:18 <srhb> grumpi1: Sounds like we sold it. Hooray! ;)
10:47:24 <hodapp> I have noticed how much simpler refactoring has been when doing things in Haskell.
10:47:36 <gyaretto> I can't figure out how to resolve this dependency issue. :/ https://gist.github.com/garrettoreilly/a059ef8a03a9f02c4149
10:47:47 <joneshf-laptop> SrPx, bennofs oh, my bad
10:47:56 <eacameron> grumpi1: I see you've taken the red pill
10:48:00 <srhb> gyaretto: Bump the base requirement to 4.8
10:48:14 <gyaretto> srhb: How do I do that?
10:48:30 <kadoban> gyaretto: base = 4.7.* is  GHC 7.8 I believe. You must be on GHC 7.10.1 ?
10:48:30 <srhb> gyaretto: I think there are cabal switches that I don't recall, but otherwise edit the cabal file.
10:48:46 <gyaretto> kadoban: Yeah.
10:48:54 <kadoban> --allow-newer it might be? But I don't recall how to get it to do only one dep that way
10:48:58 <gyaretto> srhb: Okay, cool. Thanks!
10:49:24 <srhb> --allow-newer=base
10:50:02 <bennofs> benzrf: if your building in parallel maybe it can? (how much RAM do you have?)
10:50:35 <bennofs> benzrf: oops sorry, responded to something you said a long time ago (didn't notice I was scrolling up)
10:51:06 <grumpi1> I think I'll just make a Haskell web service that my Django application can integrate with, that's probably the easiest way to get my feet wet
10:51:09 <yasar11732> joneshf-laptop ohh, I guess I get it now :)
10:51:17 <srhb> grumpi1: Sounds reasonable :)
10:52:35 <SrPx> oh no problems joneshf-laptop 
10:52:57 <bennofs> SrPx: what do you want to do there? make [] an instance of Representable?
10:53:11 <SrPx> yes, to "understand" what a representable is
10:53:22 <SrPx> so I can then understand what edwardk meant by linking me to it
10:53:25 <joneshf-laptop> yasar11732, well that's good 
10:53:40 <joneshf-laptop> yasar11732, what do you get now?
10:54:22 <bennofs> SrPx: I'd say [] is probably not a valid representable, since otherwise adjunctions would already provide an instance for it :)
10:55:04 * SrPx sighs
10:55:12 <S11001001> SrPx: the best explanation is the first paragraph of the class haddock
10:55:12 <bennofs> SrPx: so for representable, it is required that tabulate . index = id and index . tabulate = id
10:55:30 <benzrf> bennofs: ah, proof by edwardk. very popular technique recently
10:55:32 <S11001001> SrPx: there must be an isomorphism to (->) x from your f for some x
10:55:37 <SrPx> okay :( so how does representable relate to my earlier question about a generic way to deal with n-d matrices?
10:55:50 <albeit> Is there an typeclass that I can derive like Show, but for ByteString? Like "ShowBS" and a "showBS function?
10:55:59 <bennofs> SrPx: consider a 3-element vector
10:56:00 <benzrf> albeit: probably not
10:56:24 <SrPx> S11001001: isn't "tabulate f = map f [0..]; index lst i = lst !! i" that isomorphism?
10:56:25 <benzrf> albeit: derivation has to be an extension if its not Show, Eq, Ord, Enum, or one of the one or two others
10:56:46 <bennofs> SrPx: if you define 'data Coord = X | Y | Z', then Coord -> a is isomorphic to V3 a, right?
10:56:49 <srhb> albeit: Also, stuff about encodings...
10:56:55 <SrPx> With that, "tabulate . index == id" indeed no
10:56:58 <albeit> Okay
10:57:02 <SrPx> bennofs: yea
10:57:07 <kadoban> albeit: Why not   myEncodingChoice . show  ?
10:57:31 <S11001001> SrPx: aye, tabulate.index isn't total there
10:57:58 <albeit> kadoban: Yep, that's what I'm doing now. Just was wondering if there was a simper way
10:58:01 <SrPx> but GHC can't know that right
10:58:03 <kadoban> Ah okay
10:58:19 <S11001001> SrPx: no; but it's still an illegal instance
10:58:33 <bennofs> SrPx: so you want to index into a generic V or into a V3?
10:59:35 <SrPx> bennofs: what I want specifically is a way to create functions for matrices that will work for any specific "concrete" type that implements a matrix (such as a vector of vectors, or REPA, or lists of lists)
10:59:52 <SrPx> the same way I can create functions that will work for any mappeable container by using functors
10:59:53 <fizbin> Okay, how do I leave the ghci debugger, and return to "top level", aborting the calculation that threw an exception and got me in there?
11:00:13 <SrPx> i.e. a generalization of matrices, I don't know if that makes sense
11:04:22 <bennofs> SrPx: it seems that at least V3 has Rep V3 = E V3 while Rep (V n) = Int, so it will be hard to write functions than can generically use both Representable instances (since the type of index/tabulate will differ)
11:05:53 <randir> How can I register an IO function, to be run if/when cntrl-c is sent to a process?
11:06:19 <randir> I know I can forkFinally, but is there a simple way to do this in main, without forking? 
11:07:22 <alex____> j
11:10:20 * hackagebot spatial-math 0.2.2.0 - 3d math including quaternions/euler angles/dcms and utility functions  http://hackage.haskell.org/package/spatial-math-0.2.2.0 (GregHorn)
11:11:46 <quchen> randir: I think a UserInterrupt is the exception that it sent to the main thread on ^C.
11:11:56 <quchen> :: AsyncException
11:18:40 <SrPx> Okay I guess this summarizes my issue: http://stackoverflow.com/questions/29805771/how-to-deal-with-matrixes-linguistically any insight or feedback is appreciated !
11:20:20 * hackagebot base-compat 0.8.0.1 - A compatibility layer for base  http://hackage.haskell.org/package/base-compat-0.8.0.1 (ryanglscott)
11:23:01 <randir> Where is UserInterrupt located?
11:23:20 <randir> I included Control.Exception
11:23:39 <randir> however, I got this:
11:23:40 <randir>     Not in scope: type constructor or class UserInterrupt
11:23:40 <randir>     A data constructor of that name is in scope; did you mean DataKinds?
11:24:43 <arkeet> randir: UserInterrupt isn't a type.
11:24:48 <glguy> randir: type this in GHCi:   :i UserInterrupt
11:25:01 <randir> ahh
11:25:08 <randir> of course
11:25:14 <arkeet> "A data constructor of that name is in scope" is sort of a hint.
11:25:21 * hackagebot lorem 0.0.0.0 - Library for generating filler text  http://hackage.haskell.org/package/lorem-0.0.0.0 (StefanFischer)
11:29:58 <lpaste> randir pasted “AsyncException” at http://lpaste.net/131250
11:30:08 <randir> Can one of you guys help me wit this?
11:30:10 <randir> with*
11:30:21 * hackagebot forger 0.0.0.0 - Library for generating fake placeholder data  http://hackage.haskell.org/package/forger-0.0.0.0 (StefanFischer)
11:30:23 * hackagebot darcsden 1.1.1 - Darcs repository UI and hosting/collaboration app (hub.darcs.net branch).  http://hackage.haskell.org/package/darcsden-1.1.1 (SimonMichael)
11:30:37 <randir> Occasionally, when I input control+c, I get the output message
11:30:40 <randir> but sometimes I don't.
11:30:41 <kuribas> Is there a way to prohibit lazyness in the typesystem?  For example make x = x illegal for some types?
11:30:58 <randir> So I'm figuring it has something to do with the threadDelay, perhaps?
11:31:36 <randir> Or perhaps control+c is being passed to the internal process spawned by Control.Process? Any ideas?
11:32:08 <randir> Hmm.. and it seems like sometimes the final message outputs in full, sometimes not.
11:33:11 <srhb> randir: There used to be a problem with catch and UserInterrupt
11:33:15 <srhb> Not sure if that's stille the case.
11:33:35 <quchen> Is the "rts" package, which seems to be the root of the Hackage package hierarchy, some form of an abstract package? It seems like it should be baked into the compiler or something.
11:34:09 <kadoban> kuribas: I don't think so. (But then again, every time I think that, someone comes up with some clever way, usually with some insane extension that I don't understand)
11:34:12 <randir> srhb: What should I do instead?
11:34:26 <srhb> randir: If you're on a POSIX system, maybe installHandler?
11:34:29 <mniip> quchen, iirc it's an abstract package that is hidden by default just like ghc-prim
11:34:32 <kuribas> kadoban: yeah, I had the same thought :)
11:35:06 <kadoban> kuribas: Why do you want to do that? Something like … trying to prove that the evaluation of something will terminate? I think that's beyond haskell's abilities (you get more into Agda and Coq and friends for that)
11:35:38 <randir> srhb: Okay, makes sense.
11:35:50 <kuribas> kadoban: yes in fact.  I have written a linear equation solver.  I was wondering if the haskell system could prove that it is consistent.
11:35:59 <srhb> randir: Do report back... :)
11:36:15 <kuribas> kadoban: for example x = x => type error, x = 5 => fine.
11:36:29 <simpson> Stupid question: One of the MonadPlus laws is this: m `mplus` (n `mplus` o)  =  (m `mplus` n) `mplus` o
11:36:59 <simpson> Which makes sense from the monoid POV. However, there's a comment on this line in the wikibook which claims that not all MonadPlus instances obey this law.
11:37:09 <kadoban> kuribas: Yeah, I think that's impossible, in general. (but again, the earlier caveat)
11:37:19 <simpson> The comment claims that some infinite structures are only possible if this law is relaxed/broken.
11:37:32 <simpson> Can anybody name such an instance? I've never heard of this before.
11:40:22 * hackagebot propellor 2.3.0 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-2.3.0 (JoeyHess)
11:43:17 <quchen> The haddocks of FGL are annoying(ly empty). :-(
11:45:11 <randir> srhb: you'll find this interesting:
11:46:00 <lpaste> randir pasted “weird” at http://lpaste.net/131251
11:46:15 <randir> that's what I get when I pass it cntrl+c
11:47:54 <kadoban> randir: Looks like two or more things are all printing at the same time, interleaved.
11:48:10 <randir> yep
11:48:33 <randir> Even though the handler is CatchOnce
11:48:37 <randir> and the signal is sent one time
11:48:51 <randir> I think what's happening is the child process (by runCommand) is being passed the signal
11:49:17 <randir> and maybe CatchOnce is applied to the child process, by Haskell (or the OS) forwarding the signal handler, basically
11:50:22 * hackagebot arpa 0.0.0.0 - Library for reading ARPA n-gram models  http://hackage.haskell.org/package/arpa-0.0.0.0 (StefanFischer)
12:05:23 * hackagebot stackage-cli 0.0.0.4 - A CLI library for stackage commands  http://hackage.haskell.org/package/stackage-cli-0.0.0.4 (DanBurton)
12:05:55 <srhb> randir: Maybe spawn off a thread for runCommand?
12:11:37 <oconnore> So I'm using test-framework, and I have an error "No instance for (QuickCheck-2.6:Test.QuickCheck.Arbitrary.Arbitrary T.Text) arising from a use of `testProperty'"
12:12:10 <oconnore> I think it's a test-framework specific thing, because I can comment out the "testProperty" line, load my tests in to ghci, and quickCheck prop_myProperty passes all the tests
12:12:19 <oconnore> does anyone know what could be causing that?
12:13:59 <mmachenry> I'm having trouble getting this to type check. I want to fold over a "ListT STM (Int,TVar String)" and get back an STM String by folding them together with orElse but the ListT.fold function pulls the String out of STM in the application to the fold function. So I can't use orElse. http://lpaste.net/131253
12:14:01 <kadoban> oconnore: What exactly are you doing in ghci that works?
12:15:29 <oconnore> kadoban: ":l Test/TreeMTests" -> "quickCheck prop_insertAdds" -> +++ OK, passed 100 tests
12:16:12 <oconnore> after I have commented out "testProperty" in the list of test-framework tests
12:16:43 <kadoban> oconnore: Can you paste the code somewhere?
12:16:53 <oconnore> kadoban: it is linking both QuickCheck 2.6 and QuickCheck 2.8 in ghci
12:17:33 <kadoban> Well, I don't see an Arbitrary instance for Text in either one, so I'm kinda curious what's actually working.
12:17:40 <kadoban> And how …
12:17:53 <oconnore> kadoban: I wrote an instance
12:17:59 <oconnore> kadoban: I can sample it, too
12:18:36 <oconnore> kadoban: sample $ (arbitrary :: Gen T.Text) spits out a bunch of lines "arbText38742...."
12:18:46 <kadoban> Then it shouldn't really matter at all what QuickCheck you're using. Can you paste the code that's not working somewhere? Preferably a minimal example ..
12:20:37 <lpaste> oconnore pasted “test-framework-issues.hs” at http://lpaste.net/131254
12:21:23 <athan> Typeclasses are useful for deconstructing existentially borked recursive types, right?
12:21:24 <oconnore> kadoban: ^^
12:22:19 <kadoban> oconnore: And what's the error? I could see the instance for [T.Text] being a mistake. I think QuickCheck already has an instance for …   [a] for Arbitrary a
12:23:20 <oconnore> kadoban: if I uncomment line 20, the error is: No instance for (QuickCHeck-2.6:Test.QuickCheck.Arbitrary.Arbitrary T.Text) arising from a use of `testProperty'
12:24:00 <benzrf> hmmmmm
12:24:29 <oconnore> kadoban: yeah, if I comment out the [T.Text] instance I can still pass quickCheck in ghci
12:24:37 <benzrf> Haskell> display (InWindow "Nice Window" (200, 200) (10, 10)) white (Circle 80)
12:24:39 <benzrf> *** Exception: user error (unknown GLUT entry glutInit)
12:24:42 <benzrf> what is happen
12:24:55 <benzrf> i have ghc 7.10 installed gloss via cabal install, have freeglut instaad
12:24:58 <benzrf> *installed
12:26:00 <KaneTW> are you on windows?
12:26:31 <benzrf> no
12:26:32 <benzrf> arch
12:27:54 <KaneTW> lemme see
12:27:57 <kadoban> oconnore: Sorry, yeah I don't understand that at all.
12:30:09 <tulcod> benzrf: should you install glut or freeglut?
12:32:05 <oconnore> kadoban: ok, well thanks for looking :)
12:33:09 <KaneTW> benzrf: can you find your gloss .so file and run ldd on it
12:33:22 <Geraldus> hi friends!
12:33:24 <KaneTW> then check whether the libglut it linked against exists
12:34:43 <Geraldus> I want to send POST request with some data attached using http-condiut. Can't figure out how POST data could be attached. Is it just a query string? 
12:38:08 <johnw> Geraldus: the request will have a sink you can stream data into
12:38:12 <orion> I am using -static on an executable. How can I suppress these warnings?: /opt/ghc/7.8.4/lib/ghc-7.8.4/rts-1.0/libHSrts_thr.a(Linker.thr_o): In function `internal_dlopen': (.text+0x145): warning: Using 'dlopen' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
12:39:23 <Geraldus> johnw: hmm, let me see. I'm not familiar with sinks and conduit at all
12:39:48 <johnw> that's the "-conduit" part of http-conduit :)
12:40:02 <johnw> POST requests are sinks, and POST responses are sources
12:40:14 <johnw> or rather, any response possibly
12:41:07 <Geraldus> johnw: I think I should exploit `urlEncodedBody`
12:41:39 <benzrf> KaneTW: here are for the 2 .so's that gloss has placed onto my machine //gist.github.com/ab7fac56311562a02a47
12:41:43 <benzrf> er, https://gist.github.com/ab7fac56311562a02a47
12:42:24 <Geraldus> johnw: thanks anyway
12:44:35 <tulcod> benzrf: does it have the "glutInit" symbol? (try: readelf -Ws /the/lib.so, or otherwise: nm -g /the/lib.so)
12:45:47 <disgrntld> hey gang, I'd like to make this point-free: (\xs acc -> zipWith (+) xs (reduce acc)) , how can I say "apply reduce to one of the inputs of zipWith?" .... I was thinking arrows (I dunno, something like: first reduce >>> zipWith (+)), but it needs to be a binary function (i.e. I don't receive a tuple)
12:45:52 <benzrf> tulcod: i got a buncha gibberish
12:46:20 <tulcod> benzrf: try grepping for "glutInit"
12:46:47 <ion> \xs -> zipWith (+) xs . reduce
12:47:10 <disgrntld> can we get rid of xs with some crazy arrow syntax, ion?
12:47:26 <disgrntld> ...that's cool though, better than before
12:47:28 <kadoban> :t uncurry -- ^ disgrntld  (also curry)
12:47:29 <lambdabot> (a -> b -> c) -> (a, b) -> c
12:47:49 <arkeet> @pl \xs acc -> zipWith (+) xs (reduce acc)
12:47:49 <lambdabot> (. reduce) . zipWith (+)
12:47:57 <tulcod> wow
12:48:00 <disgrntld> that's just neat
12:48:05 <joelteon> does cabal support passing command-line arguments to a test executable?
12:48:07 <ion> disgrntld: That’s just obfuscated.
12:48:10 <disgrntld> lol
12:48:18 <kadoban> disgrntld: It's pretty bad though, don't actually do that :-/
12:48:41 <tulcod> joelteon: yes, put -- before the arguments
12:48:44 <disgrntld> I'm trying to learn _how_ to make things point-free, but I promise I'll try to learn the why and when eventually :D
12:48:49 <disgrntld> thanks guys
12:48:52 <joelteon> tulcod: when running test, or what?
12:48:53 <tulcod> joelteon: e.g. cabal exec myexecutable -- --some-flag
12:49:05 <tulcod> joelteon: oh soryr, a test executable. uh...
12:50:18 <tulcod> joelteon: what kind of flag do you want to pass, by the way?
12:50:34 <joelteon> tulcod: -m to an hspec executable
12:50:36 <joelteon> for patterns
12:50:47 <tulcod> joelteon: can't you write a wrapper test?
12:51:30 <benzrf> tulcod: not literally gibberish
12:51:40 <benzrf> i mean a bunch of readelf output
12:51:47 <lpaste> arkeet pasted “disgrntld” at http://lpaste.net/131258
12:51:47 <benzrf> containing glutInits
12:51:54 <joelteon> tulcod: yes... :(
12:52:13 <arkeet> disgrntld: basically, if each argument only appears once, you work on them one at a time, trying to get them to the far right end
12:52:13 <joelteon> or maybe I can't, I don't know
12:52:18 <joelteon> I'm using the "hspec-discover" preprocessor
12:52:19 <arkeet> and then you can eliminate them with (.)
12:52:23 <tulcod> benzrf: okay, then for some reason it's not finding the library. i guess your best bet is to track down how the haskell package loads your library (it does so dynamically)
12:52:34 <benzrf> :{
12:52:38 <disgrntld> that's just the kind of explanation of the train-of-thought I was looking for, arkeet
12:52:41 <disgrntld> thanks
12:53:07 <arkeet> things get a bit trickier when an argument appears multiple times
12:53:15 <dbushenko> hi all!
12:53:21 <dbushenko> can anyone help me with Vault?
12:53:29 <arkeet> but usually you use something like
12:53:34 <dbushenko> I totally can't understand how it should be used
12:53:36 <arkeet> \x -> k (f x) (g x) = liftA k f g
12:53:41 <dbushenko> this is what I'm trying: https://gist.github.com/dbushenko/901001b6332fd7b130cd
12:53:41 <arkeet> liftA2*
12:53:51 <arkeet> or, \x -> f x (g x) = f <*> g
12:53:57 <dbushenko> and this is what I get:
12:53:57 <dbushenko> No instance for (Data.String.IsString Vault.Vault)
12:53:57 <dbushenko>       arising from the literal `"key"'
12:54:01 <disgrntld> arkeet: yea, I'm noticing that, and currently I'll just kind of "expand" my intermediary results to pass the argument forwards which I know is not the best way
12:54:02 <SrPx> is classy-prelude considered anti linguistic? 
12:54:04 <arkeet> or \x -> f x x = join f
12:54:18 <humanoyd> How can I recursively copy a directory with Turtle?
12:54:31 <arkeet> :t \f -> liftA2 f id id
12:54:32 <lambdabot> (a -> a -> c) -> a -> c
12:54:34 <arkeet> neat.
12:54:39 <arkeet> :t \f -> f <*> id
12:54:40 <lambdabot> (a -> a -> b) -> a -> b
12:54:44 <disgrntld> ...I do `(_ &&& id)` a lot
12:55:13 <arkeet> sometimes going with tuples/arrowy functions/uncurry makes things nice.
12:55:21 <tulcod> dbushenko: a key is not a vault
12:55:23 <disgrntld> noted
12:55:33 <johnw> disgrntld: you mean, 'first'?
12:55:37 <dbushenko> tulcod, how to create it correctly?
12:55:42 <dbushenko> I couldn't find in the documentation
12:55:53 <dbushenko> I tried function 'empty' but it didn't help
12:55:57 <disgrntld> johnw, I'm obviously pretty new at this whole arrow thing ;)
12:56:11 <tulcod> dbushenko: you are trying to lookup a key in a string. that doesn't make sense
12:56:26 <tulcod> dbushenko: i don't know what vault you're trying to use, but you lookup things in a vault, not in a string. in this library, anyway.
12:56:31 <arkeet> :t \f -> f &&& id
12:56:32 <lambdabot> (c' -> c) -> c' -> (c, c')
12:57:16 <dbushenko> tulcod, btw what is 'session' in my code then?
12:57:42 <tulcod> dbushenko: why are you asking me!
12:57:49 <dbushenko> tulcod, :-)
12:58:01 <tulcod> "hey, here is some code, it doesn't work. how do i fix it?"
12:58:03 <dbushenko> tulcod, thanks anyway, your critics was helpful
12:58:17 <tulcod> well i don't know, i don't know what you wanted to write
12:58:44 <tulcod> wow, that came across a bit aggressive. sorry, dbushenko, your question is most welcome here :)
13:00:33 <benzrf> disgrntld
13:00:36 <benzrf> :t first
13:00:36 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
13:00:53 <benzrf> oh wait that's (*** id) not (&&& id)
13:00:56 <benzrf> >.>
13:01:38 <kadoban> Heh, yeah I was wondering why that type made no sense to me XD
13:02:55 <tulcod> dbushenko: also, I would say that a more modern implementation of the same idea is given by dependent maps. but using them requires a bit more knowledge i suppose.
13:03:49 <tulcod> (in particular it heavily depends on GADTs)
13:04:28 <dbushenko> tulcod, yeah, thanks. But I still try to get into Vault, I can't believe I can't understand something that simple...
13:05:02 <tulcod> dbushenko: well maybe you can show us your attempts with a toy example?
13:05:35 <SwashBuckla> what is <$> ?
13:05:39 <SwashBuckla> fmap?
13:05:45 <kadoban> SwashBuckla: Yep.
13:06:08 <SwashBuckla> I will learn this eventually, but for now all these symbols mystify me
13:06:17 <dbushenko> tulcod, I'd apprecieat your help. just in 10 minutes, I need to help my wife with the baby :-)
13:06:45 <SwashBuckla> I heard <*> referred to as 'angle butt' today
13:07:26 <hiptobecubic> That's much catchier than "cat-anus." I should switch.
13:12:02 <hexagoxel> joelteon: --test-option
13:14:29 <EvanR-> SwashBuckla: dont try to pronounce haskell code you might hurt yourself
13:14:41 <EvanR-> or innocent bystanders
13:16:37 <SwashBuckla> ha ha
13:17:24 <geekosaur> pipe it rhrough festival, what could possibly go wromng? >.>
13:19:13 <krgn> hi all. is there a wai middleware that allows me to proxy requests?
13:20:26 * hackagebot active 0.2.0.1 - Abstractions for animation  http://hackage.haskell.org/package/active-0.2.0.1 (BrentYorgey)
13:21:18 <fragamus> :t <=>
13:21:19 <lambdabot>     Not in scope: ‘<=>’
13:21:19 <lambdabot>     Perhaps you meant one of these:
13:21:19 <lambdabot>       ‘<$>’ (imported from Control.Applicative),
13:21:25 <fragamus> :t (<=>)
13:21:26 <lambdabot>     Not in scope: ‘<=>’
13:21:27 <lambdabot>     Perhaps you meant one of these:
13:21:27 <lambdabot>       ‘<$>’ (imported from Control.Applicative),
13:21:29 <dbushenko> tulcod, after you told me that I'm trying to extract something from string but not from vault -- I've finally found the solution, so thanks for you note :-) Sometimes someone need to tell even such evident things :-)
13:21:41 <dbushenko> tulcod, the solution was: let m = Vault.lookup session Vault.empty
13:21:46 <fragamus> @hoogle Ordering
13:21:47 <lambdabot> Prelude data Ordering :: *
13:21:47 <lambdabot> Data.Ord data Ordering :: *
13:21:47 <lambdabot> package COrdering
13:22:00 <athan> Hey folks, can we use type families in typeclass instances? :S
13:22:29 <quchen> Sure, that's what associated types are
13:22:47 <tulcod> dbushenko: the result of that will always be Nothing
13:23:00 <dbushenko> yes, I know. but this is starting point
13:23:03 <tulcod> okay
13:23:47 <athan> quchen: :O!
13:23:54 <athan> erm, sorry I'll try not to drool
13:24:18 <EvanR-> associated types are cool
13:24:36 <quchen> athan: Careful though, TypeFamilies is quite an avalanche extension
13:25:00 <athan> quchen: I can't think of another way to accomplish what I'm doing :\
13:25:12 <athan> basically, I need to "expect" a certain type to a function
13:25:16 <quchen> It's a very interesting and often useful avalanche ;-)
13:25:28 * athan gets goggles
13:25:51 <EvanR-> athan: by itself, the solution to that would be to just use that type in the function sig
13:26:16 <EvanR-> if i autocorrected your grammar correctly
13:26:27 <athan> EvanR-: ):
13:26:45 <athan> the type differs based on the type of another input
13:26:50 <athan> basically something liek this:
13:27:03 <athan> `crazyApp :: HList xs -> ExpectArity xs r`
13:27:09 <EvanR-> you can do that like
13:27:19 <EvanR-> f :: a -> T a -> X
13:27:23 <athan> where ExpectArity takes the stack and turns it into successive function arity, ending in `r`
13:27:33 <EvanR-> arity?
13:27:39 <athan> :|
13:27:54 <EvanR-> sorry i get confused because clojure
13:27:56 <athan> @google arity
13:27:57 <lambdabot> http://en.wikipedia.org/wiki/Arity
13:27:57 <lambdabot> Title: Arity - Wikipedia, the free encyclopedia
13:28:10 <glguy> You don't need a typeclass to implement crazyApp
13:28:11 <SrPx> So, I've been looking @ classy-prelude and it seems like it solves the fact there are many "filters" with different signatures by creating typeclasses do namespace. I find that kinda awkward. Is there another rewrite of the prelude which instead solves this by creating properly polymorphic functions?
13:28:23 <SrPx> Not caring about hackage compatibility 
13:28:25 <athan> glguy: Well, you may need it for deconstructing HLists!
13:28:49 <EvanR-> whats your legitmate use of HList?
13:28:59 <athan> thanks guys :)
13:29:06 <glguy> athan: You're using this HList? http://hackage.haskell.org/package/HList-0.3.4.1/docs/Data-HList-HList.html#t:HList
13:29:17 <athan> glguy: A variant of it :)
13:29:38 <athan> I don't need it to be so general
13:34:35 <f-a_> you probably have seen this already, but just in case https://identi.ca/joeyh/note/YIUYhOitR6qUkc89Cz7CdA
13:34:48 <lpaste> glguy pasted “for athan” at http://lpaste.net/131262
13:34:53 <f-a_> I found the definition "type tetris" quite fit!
13:35:40 <athan> glguy: Heck yeah :) thank you!!
13:36:59 <EvanR-> f-a_: alternatively, have most of those changes done for you using some sort of "proof search"
13:37:19 <EvanR-> with a confirmation or something like find replace
13:37:27 <gyaretto> What would be the best way to create a CST in Haskell? Would I be on the right track with this? data Cst a = EmptyTree | Token a [Cst a] deriving (Showe, Read, Eq)
13:37:31 <f-a_> indeed indeed
13:37:43 <gyaretto> s/Showe/Show/
13:38:26 <EvanR-> try making a data type that specifically allows correct syntax only, and reflects the syntax in the constructors
13:39:01 <hexagoxel> athan: ah, HList-curry, nice.
13:39:11 <EvanR-> then when you are interpreting it later you wont have to put _ -> error "wrong" in each case
13:39:16 <pavonia> gyaretto: What is a CST?
13:39:34 <gyaretto> pavonia: Concrete syntax tree. I'm writing a compiler.
13:39:43 <hexagoxel> *uncurry
13:41:42 <simpson> gyaretto: Most Haskell-based compilers go straight from parse tree to AST. Which language are you compiling?
13:42:43 <gyaretto> simpson: It's a project for my compilers class, so it's a toy language. http://labouseur.com/courses/compilers/grammar.pdf
13:44:49 <simpson> gyaretto: Oh! Cool. Well, then yeah, that CST type that you have will do what you like. I really do recommend an AST with specialized node constructors for any intermediate stuff though.
13:45:26 <EvanR-> gyaretto: that grammar can be represented directly with ADTs
13:45:50 <EvanR-> and your parser outputs a value of the top level type
13:46:15 <gyaretto> Okay, thanks. Unfortunately, the project requires a CST and AST.
13:46:16 <EvanR-> the type definitions follow closely with the grammar description given there
13:46:30 <simpson> EvanR-: gyaretto has to build a CST, or parse tree, as an intermediate step.
13:46:41 <EvanR-> well you can produce a cst from the ast (uselessly) to satisfy the project
13:46:54 <EvanR-> :(
13:47:18 <simpson> Not that big of a deal. TBH I'm expecting that the parser will be exactly as hard to write as before.
13:47:31 <gyaretto> I've already written the parser, actually.
13:47:46 <gyaretto> https://github.com/garrettoreilly/doompiler
13:48:03 <simpson> Oh! Then can't you just claim that the parse trees are your CSTs?
13:48:44 <caconym> anyone know a good way to go from a Unix timestamp to a UTCTime (from the 'time' package)?
13:49:01 <gyaretto> Well, I haven't made any trees yet. I've only verified the grammar of the program so far.
13:49:11 <glguy> Data.Time.Clock.POSIX.posixSecondsToUTCTime
13:49:23 <caconym> glguy: thanks much
13:51:13 <NemesisD> is there an analog to mapM_ that can be terminated early, i.e. the result of a previous iteration determines if the next should be run?
13:51:49 <quchen> NemesisD: When in doubt, look at monad-loops
13:51:51 <EvanR-> takeWhileM
13:52:10 <EvanR-> or for _, whileM
13:53:32 <jle`> NemesisD: there might be something you are looking for in monad-loops
13:53:37 <NemesisD> ah, for some reason i thought that library was frowned upon
13:53:41 <EvanR-> gyaretto: the process of making the tree *is* the verification though?
13:53:47 <jle`> nah
13:53:49 <jle`> i mean
13:54:01 <jle`> it suffers from most of the problems "general utility" packages suffer from
13:54:12 <jle`> but i wouldn't say you should avoid that one in particular
13:54:29 <NemesisD> maybe because every time i mention the word "loop" around other haskell people they trip over eachother to "well actually" me about loops :P
13:54:42 <jle`> haha.  loops here really refers to abstraction over recursion
13:54:51 <gyaretto> EvanR-: I'm doing verification and CST building separately. I'm pretty new to Haskell, so I didn't want to make things too complicated for myself.
13:54:54 <jle`> if you want to stick to base + packages included with ghc, you can use MaybeT and asum
13:55:11 <Denommus> NemesisD: yeah, in Haskell loops are just normal functions that do some kind of recursion
13:55:17 <EvanR-> gyaretto: just saying, doing all these things separately is what makes it more complicated
13:55:40 <EvanR-> since they are all basically the same thing
13:55:51 <gyaretto> EvanR-: Hm, would it be easier to just modify the parser to build the CST?
13:57:05 <EvanR-> you can have one parser create a CST (or fail) and then ignore the CST and have the normal parser which produces the AST (or fails)
13:57:08 <jle`> hm asum doesn't work, nvm
13:57:26 <jle`> oh, it does work if you just want mapM_
13:57:53 <Denommus> NemesisD: anyway, what type signature are you thinking about?
13:58:44 <jle`> `void . runMaybeT . asum . map MaybeT` will stop as soon as it sees the first m (Maybe a) that is a Just
13:59:00 <NemesisD> the simplest thing i can think of can be done with void and allM: Monad m => (a -> m Bool) -> [a] -> m ()
13:59:26 <EvanR-> uh this is whileM
13:59:57 <NemesisD> whileM isn't mapping over a list
13:59:57 <EvanR-> which i usually have defined locally instead of monad-loops
14:00:09 <jle`> :t runMaybeT . F.asum . map MaybeT
14:00:10 <lambdabot> Monad m => [m (Maybe a)] -> m (Maybe a)
14:00:18 <jle`> hehe
14:00:53 <gyaretto> EvanR-: What would the second parser do?
14:00:59 <jle`> it'll stop on the first Just so you will need to make your successes Nothing's and your failures Just's.  if you wanted to only use higher order functions in base and packages that come with ghc
14:01:34 <EvanR-> gyaretto: i was going to ask what the first parser does. because the second parser is that just produces the ast analogous to your grammar is the usual case
14:01:36 <Denommus> :t whileM
14:01:37 <lambdabot> Not in scope: ‘whileM’
14:02:21 <jle`> it's in monad-loops
14:02:53 <fragamus> ghci is behaving very strangely with respect to pressing up arrow to see previous commands...  is this just me or do others have that
14:02:54 <Denommus> it's not whileM
14:03:04 <EvanR-> Monad m => (a -> m Bool) -> [a] -> m () can be done with whileM and map
14:03:10 <arkeet> fragamus: what OS/terminal?
14:03:20 <fragamus> macos 
14:03:27 <arkeet> no idea then
14:03:36 <fragamus> thx n e way
14:03:43 <gyaretto> EvanR-: I don't think I understand it thoroughly enough to be sure, lol.
14:03:54 <gyaretto> EvanR-: I appreciate your help though. I have to run!
14:03:56 <arkeet> :t unfoldrM
14:03:57 <lambdabot>     Not in scope: ‘unfoldrM’
14:03:58 <lambdabot>     Perhaps you meant one of these:
14:03:58 <lambdabot>       ‘BS.unfoldr’ (imported from Data.ByteString),
14:04:26 <arkeet> oh that's also in monad-loops.
14:04:31 <EvanR-> unfoldr builds a list doenst take a list
14:04:35 <arkeet> I know.
14:04:41 <arkeet> a -> m Bool doesn't give a list.
14:04:46 <KaneTW> i'm writing a seminar paper on functional game programming using frp with netwire and a small concrete example written in elm and i'm not sure if i should include an introduction to arrows there since it's pretty fundamental netwire 
14:05:01 <KaneTW> it's aimed at people without knowledge of monads or the like in haskell
14:05:14 <arkeet> but you could write whileM with unfoldrM. I think.
14:05:14 <EvanR-> whileM id (map f xs)
14:05:27 <EvanR-> f :: a -> m Bool
14:05:39 <jle`> KaneTW: it depends on what sort of things you are going to be demonstrating
14:05:52 <EvanR-> nevermind thats wrong *goes to bed*
14:06:09 <arkeet> oh, whileM takes a [a].
14:06:17 <arkeet> er 
14:06:21 <arkeet> not whileM.
14:06:21 <arkeet> whatever
14:06:30 <EvanR-> not in monad-loops
14:06:33 <acowley> whateverM
14:06:58 <KaneTW> i'm not quite sure yet, i'd have to ask my partner on what he wants to implement; main issue is whether he wants to have collision detection or not since that requires knowledge of ArrowLoop
14:07:01 <jle`> also useful is mwhatever, whatever on monoids/monadplus
14:07:02 <EvanR-> its a weird pattern of looping im sure you can just use map somehow
14:07:14 <arkeet> anyM :: Monad m => (a -> m Bool) -> [a] -> m Bool
14:07:19 <arkeet> is pretty close to that thing.
14:07:23 <arkeet> er, allM
14:07:28 <jle`> KaneTW: if anything you can just treat `proc` notation as its own separate syntactic structure
14:07:41 <jle`> like how some people teach `do` notation as syntax without teaching monads in general
14:07:50 <jle`> "to get a String from an IO String, use <-"
14:07:57 <KaneTW> that probably sounds like a good idea
14:08:07 <KaneTW> yeah
14:08:19 <jle`> digressing about ArrowLoop might not be worth it
14:08:25 <KaneTW> i think if i introduce arrows properly half the audience will fall asleep
14:08:27 <jle`> talking about laziness and fixed points...
14:08:36 <jle`> you can just understand it as recursive graph bindings
14:08:48 <jle`> and proc blocks represent building a potentially cyclic directional graph
14:08:53 <jle`> *directed
14:09:09 <Denommus> NemesisD: I just did a recursive function for that
14:10:04 <Denommus> NemesisD: takeWhileM_ f (x:xs) = do { condition <- f x; when result $ takeWhileM_ f xs }
14:10:10 <Denommus> NemesisD: when is defined in Control.Monad
14:10:31 <NemesisD> Denommus: monad-loops was already a transient dependency so no problem ;)
14:11:00 <jle`> this is the sort of thing edwardk promised us would happen
14:11:16 <ion> What is?
14:11:29 <jle`> not having to worry about extra dependencies, because like...
14:11:30 <gr0g_> Hi, i have a function in C which in the first call it returns the first word of a file, the second call returns the second word, and so on. How can I do this in haskell? I need a function which for each call, returns the next word of a file. For example, if the file contains "this is a file", the first call should return "this", second call should return "is", and so on.
14:11:34 * edwardk whistles innocently
14:11:35 <jle`> on any decent project, it'll already be a transient dependency anyway
14:11:44 <jle`> *decently sized
14:11:46 <ion> heh
14:11:47 <simpson> Yeah, but "it" is monad-loops in this case.
14:11:53 <simpson> I bet edwardk was talking about lens. :3
14:12:01 <jle`> i was generalizing his argument :3
14:12:34 <jle`> and...a more appropriate analogy here would be something like semigroups or text
14:12:55 <Denommus> gr0g_: yourFunctionName = words . readFile
14:13:04 <jle`> "but i don't want to add a text dependency" => you probably already have one anyway in your ecosystem
14:13:04 <ion> For all libraries, as project size goes to infinity, the probability of the library being a transient dependency goes to one?
14:13:12 <jle`> yes
14:13:13 <Denommus> gr0g_: sorry
14:13:16 <jle`> :P
14:13:25 <jle`> we only care about asymptotics in programming anyway
14:13:32 <jle`> :) :) :)
14:13:38 <Denommus> gr0g_: I'm wrong
14:13:58 <ion> @type fmap words . readFile
14:13:59 <lambdabot> FilePath -> IO [String]
14:14:33 <hiptobecubic> I think what a lot of people don't realize when they complain about dependencies in haskell is how much concensus there is. There is a semigroups package. If some package depends on semigroups, it will use that package. It's not like having part of your application depend on Snap and the other half on Yesod. The amount of library sharing that occurs is just unprecedented
14:14:34 <Denommus> ion: yes
14:15:14 <Denommus> gr0g_: that pay attention that it returns a IO [String]. That's because Haskell is pure, so IO operations are "boxed" inside a IO type
14:15:50 <gyaretto> I lied.
14:16:02 <Denommus> gr0g_: you have to "unbox" the value so you can use it, using either (>>=), the "do" syntax, or any other helper function that works with IO (like fmap)
14:16:17 <hiptobecubic> Maybe the scientific libraries in python which are all on top of numpy is a solid competitor, but I have trouble thinking of other examples where it's so widespread that you can just say things like "semigroup" in haskell or "array" in python and the package is implied.
14:16:26 <ion> I’m not sure boxing and unboxing is a helpful analogy wrt. IO.
14:16:29 <ackthet> what version of cabal adds sandboxes?
14:16:43 <hiptobecubic> 1.18 I think?
14:16:44 <gr0g_> Denommus: i see, thank you
14:17:03 <ackthet> hiptobecubic: of cource EL7 provides 1.16
14:17:19 <randir> can I mix a case statement with guard syntax?
14:17:22 <hiptobecubic> ackthet, cabal install cabal-install workse fine :)
14:17:26 <hiptobecubic> also works.
14:17:27 <randir> like (pattern) -> 
14:17:33 <ackthet> :D
14:17:36 <ackthet> i was about to ask
14:17:36 <randir>    | True = "hello"
14:17:49 <Denommus> ion: that's the analogy learn you a haskell uses
14:17:49 <randir>    | False = "goodbye"
14:17:57 <ion> > case Just 42 of Just n | even n -> n
14:17:59 <lambdabot>  42
14:18:34 <randir> ah, so no arrow, it seems?
14:18:45 <kadoban> Denommus: Quite a few people have some problems with LYAH in general.
14:18:59 <Denommus> kadoban: that's fair
14:19:23 <Denommus> kadoban: but I am afraid to use the "m" word with someone that looks a beginner
14:19:54 <Denommus> kadoban: even though monads are actually much simpler than the tutorials make them :-P
14:20:17 <kadoban> Heh, yeah. I'm not enough of a teacher to know how to explain that properly without getting too complicated.
14:21:48 <fizbin> Don't you hate it when the library author includes a "pretty print" function in the library, and it turns out that the prettyPrint function randomly leaves huge chunks out of the data structure?
14:21:58 <fizbin> I'm looking at fgl here....
14:23:58 <Denommus> kadoban: I tend to just say that monads are a "family" of types with two associated functions, (>>=) and return, and those functions must follow some laws (then I proceed to list the laws)
14:24:19 <Denommus> kadoban: people usually understand that, and I keep wondering why making so much analogies for such a simple thing
14:24:22 <lpaste> arkeet pasted “gr0g_” at http://lpaste.net/131263
14:24:31 <arkeet> gr0g_: ^ whether this is actually a good idea is a different matter.
14:25:08 <Denommus> kadoban: then, if I get him interested, I explain functors, applicative functors, and that monads are just applicative functors with "join"
14:25:36 <Aruro> guys, is there any library which prints numbers in a given base? like base 5 lets say.
14:25:44 <arkeet> look in the Numeric module
14:25:47 <jle`> Aruro: yes, it's in `base`
14:25:53 <arkeet> in base
14:25:54 <Aruro> how is it called?
14:26:00 <arkeet> import Numeric
14:26:09 <arkeet> https://hackage.haskell.org/package/base-4.8.0.0/docs/Numeric.html
14:26:17 <Aruro> arkeet: ty!
14:27:01 <arkeet> > showIntAtBase 20 ("0123456789abcdefghij" !!) 799 ""
14:27:02 <lambdabot>  "1jj"
14:27:13 <arkeet> kind of unwieldy.
14:27:17 <arkeet> unless you wrap it somehow.
14:27:47 <jle`> here's digitToHex or something i think
14:27:52 <glguy> > base 20 # 799
14:27:54 <lambdabot>  "1jj"
14:27:58 <arkeet> yes, if you have lens you can do this ^
14:28:11 <arkeet> :t review (base 20)
14:28:12 <lambdabot> (Integral a, MonadReader a m) => m String
14:28:18 <arkeet> :t review (base 20) :: Int -> String
14:28:20 <lambdabot> Int -> String
14:28:36 <jle`> :intToDigit
14:28:44 <jle`> *intToDigit
14:28:57 <jle`> > showIntAtBase 20 intToDigit 799 ""
14:28:58 <lambdabot>  "*Exception: Char.intToDigit: not a digit 19
14:29:02 <jle`> oh i guess, base 20
14:29:04 <arkeet> intToDigit works only for 0 to 15.
14:29:08 <jle`> yea
14:29:20 <arkeet> meanwhile lens's base works up to base 36
14:34:05 <joelteon> Is it possible to attach a finalizer function to an arbitrary GC-able thing?
14:34:46 <kadoban> joelteon: I'm not sure that'd make sense in haskell?
14:34:52 <joelteon> ok
14:36:11 <Adeon> joelteon: it's possible but might not be what you want
14:36:27 <Adeon> it's sensible to do it with IORefs and MVars, at least
14:36:43 <ReinH> joelteon: I wonder if https://hackage.haskell.org/package/base-4.8.0.0/docs/System-Mem-Weak.html might be helpful, but I've never used it myself
14:36:57 <joelteon> ReinH: that adds a newtype wrapper
14:37:02 <ReinH> joelteon: indeed
14:37:14 <Adeon> you don't have to use the weak pointer
14:37:19 <Adeon> you can just use it to attach a finalizer
14:37:39 <joelteon> I'm connecting to a sqlite :memory: database and trying to figure out when the old one is destroyed and a new one is created
14:37:43 <joelteon> because it's happening mid-testsuite
14:38:44 <Adeon> https://hackage.haskell.org/package/base-4.8.0.0/docs/Foreign-Concurrent.html there's also this one for finalizers, does it apply there rather than the weak pointer mechanism?
14:39:25 <Adeon> if you want to attach a finalizer to an IORef or an MVar, check their respective modules for a specialized function for them that creates a weak pointer, just don't use the weak pointer if you don't need it
14:40:02 <Adeon> the generic mkWeak is unreliable because it might attach the finalizer to a box around the value rather than the value itself
14:40:09 <Adeon> I don't know how to use it correctly
14:42:45 <meretrix> What's the cheapest way to send ADTs over a socket?  Serialize with Binary or Aeson?
14:43:05 <meretrix> Deserialization performance isn't important.
14:43:16 <Enigmagic> binary will be faster than aeson
14:43:31 <Adeon> I don't the absolutely fastest but I would think binary is faster than aeson, like Enigmagic said
14:43:45 <meretrix> Thanks. And no reason to think it will trigger more GC than Aeson?
14:43:56 <Adeon> unlikely
14:43:58 <Enigmagic> it generates less stuff
14:44:02 <meretrix> Great
14:49:02 <lpaste> acowley pasted “FunDep ambiguity” at http://lpaste.net/131265
14:49:13 <acowley> Anyone have any thoughts on that?
14:49:28 <acowley> It surprised me that the fundep isn't enough to resolve it
14:54:24 <ReinH> acowley: o/
14:54:36 <acowley> ReinH: \o
14:58:02 <acowley> Even adding a Ctx Num Identity constraint on the Add instance doesn't resolve it
14:58:16 <acowley> GHC really doesn't like fundeps :/
14:58:43 <Aruro> what is constructor for Data.Bytestring?
14:58:51 <acowley> But when you have type families in play, you're more likely to run into untouchable type variables
14:59:16 <jle`> Aruro: it's actually hidden, i think, unless you dig deeply.  you can make one by converting various things though, using the functions in the module
14:59:21 <acowley> Aruro: It's used abstractly. Typically, you'd build a ByteString from a list.
14:59:44 <Aruro> acowley: ty, but how i force ghci to think its that? :)
14:59:50 <Aruro> sorta overloaded strings
15:00:18 <Aruro> without invoking :set
15:00:31 <acowley> Aruro: Can you give an example of what you're trying?
15:01:06 <Aruro> this : parseTest parseIP ("245.12.23.1" :: Data.ByteString)
15:01:07 <lpaste> glguy annotated “FunDep ambiguity” with “just narrowed” at http://lpaste.net/131265#a131266
15:01:21 <glguy> acowley: I don't have an answer, just trying to make a smaller failing case
15:01:23 <Aruro> acowley: of course, Data.ByteString is wrong
15:01:40 <randir> how can I access the Infinity data constructor?
15:01:49 <randir> ype*
15:01:51 <randir> type*
15:02:08 <acowley> glguy: Yeah, that's how I first wrote it, but you can draw out the weird missing step pretty far
15:02:53 <Aruro> jle`: so there is no easy way to tell it to ghci? without overloaded strings?
15:03:06 <jle`> you can use the explicit conversion functions
15:03:25 <jle`> you can use `pack` to turn it into a Text, and then the various Text-to-bytestring functions to turn it into bytestring with the encoding you want
15:03:43 <Aruro> i want string to bytestring
15:03:49 <acowley> I'd use Data.ByteString.Char8, but other folks will frown
15:03:51 <jle`> you can use pack to turn it into a Text
15:04:08 <quchen> ಠ_ಠ acowley 
15:04:10 <jle`> but there isn't really a "canonical" way to turn a Text into a bytestring...you have to pick your encoding
15:04:28 <glguy> If you're packing ASCII it's fine to use the Char8 module
15:04:40 <glguy> like say you're packing an IP address and you're looking right at it
15:04:40 <jle`> if you pick your encoding you can use http://hackage.haskell.org/package/text-1.2.0.4/docs/Data-Text-Encoding.html
15:04:54 <jle`> it has a lot of Text -> ByteString's to chose from
15:04:57 <Aruro> jle`: ty
15:05:03 <EvanR> utf8
15:05:09 <EvanR> EVERYWHERE
15:05:09 <jle`> encodeUtf8 :: Text -> ByteString
15:05:17 <jle`> pack :: String -> Text
15:05:25 <jle`> encodeUtf8 . pack :: String -> ByteString
15:06:34 <acowley> glguy: Do you have any idea why that use of fundeps doesn't work?
15:08:28 <glguy> Functional dependencies aren't used to improve concrete variables, only unification variables
15:10:22 <glguy> Iavor said this is the kind of thing we could fix with the new type-checking plugin architecture in GHC
15:10:53 <acowley> glguy: I guess that distinction isn't as clear to me as it should be
15:11:25 <acowley> glguy: There's a unification variable floating around, c, that is uniquely determined by a concrete type
15:11:34 <acowley> glguy: It seems like that should mean something to somebody
15:13:08 <Slothel> Hey guys, quick question
15:13:22 <Slothel> I know that asking "how long does it take to learn language x" is a bad question and kind of unanswerable
15:13:33 <Slothel> but what was the average time that it took any of you guys to learn it?
15:13:40 <Slothel> Maybe if I get a rough estimate of the avg time
15:13:40 <johnw> which time? :)
15:13:45 <acowley> Learn that it's a bad question?
15:13:58 <Slothel> acowley: It's not the same question.
15:13:58 <EvanR> at what point can it be said you learned it
15:14:29 <Slothel> EvanR: Let's say, you're able to build basic applications, you know most of the standard library, and can write programs that are non-trivial
15:14:37 <Zekka> Slothel: I was writing useful programs in Haskell after about six months
15:14:38 <Slothel> EvanR: that will suffice for my definition of "learneD"
15:14:43 <johnw> minimum time for a genius who brain looks like Haskell on the inside: 1 month; maximum time for an old COBOL manager looking to learning something on the side at age 65: 6 years.  There, definitive anecdotal proof.
15:14:43 <jle`> Slothel: what is "it"?
15:14:51 <Zekka> I'd encountered it earlier than that but I hadn't seriously worked in it
15:15:02 <EvanR> basic applications
15:15:06 <Slothel> Zekka: thanks. 
15:15:16 <Zekka> I think you could probably write useful programs in Haskell within two weeks with a good chaperone
15:15:24 <Slothel> jle: what?
15:15:36 <Slothel> I don't have anyone available to mentor me
15:15:38 <jle`> "what was the average time it took any of you guys to learn it?"  <-- what is "it"?
15:15:40 <Slothel> where I work we do Java
15:15:46 <jle`> judging from your responses though it seems that it is haskell
15:15:47 <Zekka> (e.g. if someone who's already working on a haskell program decides to put you on it)
15:15:47 <Slothel> no one here knows anything about functional languages but I'm very interested
15:15:49 <jle`> so we're good now :)
15:16:03 <EvanR> but you might be managing to write basic applications, but you didnt use the best ways that took more time to figure out (without help)
15:16:14 <EvanR> and your code looks like C
15:16:16 <Slothel> jle: Oh yeah, I must have forgot to add Haskell
15:16:18 <jle`> from day 0 beginning to learn and from writing useful applications it was probably about a month
15:16:28 <jle`> but very very minimal applications, heh
15:16:33 <Zekka> I think you can probably pick up Haskell very fast if you just commit yourself to writing useful programs in it
15:16:42 <jle`> my first larger-scale application came in about three or four months
15:16:47 <jle`> maybe two or three
15:16:49 <Zekka> I made the mistake of shying away from abstract stuff like monad transformers which make a difference for usability
15:17:05 <Slothel> Well, I've gone through some of the text on learnyouahaskell, and I'm very interested, but I'm trying to find time to practice because I can't do it at work
15:17:11 <Zekka> (not really a fan of monad transformers, but what are you going to do if you don't have them?)
15:17:22 <lpaste> glguy annotated “FunDep ambiguity” with “much narrowed (annotation)” at http://lpaste.net/131265#a131267
15:17:24 <jle`> Zekka: write your own monads :)
15:17:24 <EvanR> dont use them?
15:17:48 <glguy> acowley: spj intentionally doesn't allow GHC to learn about types from functional dependencies like this
15:17:54 <jle`> instead of ReaderT r IO a, just write your own monad instance for an (r -> IO a) newtype :)
15:18:02 <jle`> etc.
15:18:09 <EvanR> or pass the r in
15:18:16 <EvanR> to an IO 
15:18:19 <Zekka> jle`: It's valid! Uh, minding that you're going to be either reimplementing all your operations from scratch or subjecting yourself to MTL anyway afaik
15:18:35 <jle`> luckily, MTL doesn't have anything to do with monad transformers
15:18:47 <Slothel> I'm not afraid of the abstract stuff, I actually really enjoy math even though Categoruy Theory is far beyond my current knowledge
15:18:56 <Slothel> In fact the abstract stuff is what drew me to haskell in the first place
15:19:02 <Zekka> jle`: You're right, although I think MTL is kind of ugly too
15:19:10 <johnw> monad decepticons
15:19:32 <jle`> :)
15:19:43 <acowley> glguy: As part of an elaborate plot, years in the making, to confound me?
15:19:46 <acowley> glguy: :P
15:20:28 <randir> how can I directly use the Infinity type?
15:20:43 <Zekka> jle`: If you hate monad transformers that much building your own monads from scratch is probably a valid option, but I don't think it's very pretty
15:21:08 <Zekka> ideally they would be non-ugly enough out of the box that doing that doesn't look like a good option (which it rarely does)
15:21:09 <jle`> randir: what is the Infinity type?
15:21:26 <glguy> acowley: e.g. https://ghc.haskell.org/trac/ghc/ticket/9627
15:21:30 <randir> (1/0)
15:21:36 <randir> gives Infinity, in ghci
15:21:48 <jle`> ah.  as a Double/Float type, right?
15:22:00 <jle`> there is no actual constant/binding that gives Infinity
15:22:14 <jle`> sometimes people define it themselves at the top level of their file
15:22:26 <Zekka> IIRC, mostly I don't like that it's a little tricky to characterize what a monad transformer does, the way lifts for an operation look for one monad transformer stack is pretty different from how they look for another, it's hard to write code polymorphic over what transformer stack you use, and although MTL tries to solve a lot of these problems it has nasty fundeps and it does bad things when you throw in monads nobody expects
15:22:32 <Zekka> oh, that might have gotten caught off
15:22:36 <Zekka> cut off*
15:23:51 <acowley> glguy: Ah, thanks, that pins it down pretty well!
15:25:24 <ReinH> randir: fwiw Infinity is a value, not a type.
15:25:45 <randir> ReinH: Thanks
15:26:46 <ReinH> and, since (/) has a Fractional constraint, it is a value of type Fractional a => a
15:26:53 <ReinH> :t 1/0
15:26:54 <lambdabot> Fractional a => a
15:27:40 <ReinH> But it isn't a valid value for all instances of Fractional, which is fun
15:27:42 <ReinH> > 1/0 :: Rational
15:27:43 <lambdabot>  *Exception: Ratio has zero denominator
15:29:03 <EvanR> on the computer we like our numbers to be very surprising
15:29:15 <EvanR> and annoying
15:30:01 <EvanR> unsigned integer mod power of 2 is the only one that remotely makes any sense
15:31:42 <kadoban> Hey now, Integer makes a pretty good deal of sense
15:33:58 <ReinH> as does Rational
15:34:23 <johnw> Rational: voted favorite number for 10/1 years running
15:35:54 <EvanR> Integer maybe, Rational can be a security problem unless constrained
15:37:28 <arkeet> safeDivide :: Fractional a => a -> a -> Maybe a
15:37:42 <EvanR> i like fixed point, dont like Maybe division
16:07:56 <gaze__> Hey is there any more modern theory on multi-hole zippers?
16:08:50 <joelteon> is there a haskell library that can do network fixtures for testing purposes?
16:10:22 <NemesisD> joelteon: what do you mean by network fixtures
16:10:51 <joelteon> i.e. instead of a network request actually reaching the internet, its caught by an intermediate layer and a prepared response is returned
16:11:21 <NemesisD> what level are you looking at? HTTP? TCP/IP?
16:11:29 <joelteon> HTTP
16:11:34 <joelteon> TCP/IP sounds complicated
16:11:43 <EvanR> joelteon: well if you write most of your code with pure functions that is just a normal test
16:11:47 <NemesisD> i actually attempted a few times to do HTTP fixtures like VCR, never got it to a releasable state
16:11:52 <darkroom> Is there a better way to take n chars off a bytestring and then run the hexadecimal parser on it? http://pastebin.com/BCmXyHmE
16:11:55 <EvanR> hooking shit up through IO is a pain the ass and not necessary correct
16:12:16 <NemesisD> one solution was to actually spin up a little http server that mocked and recorded requests, the other was to use a free monad
16:12:21 <joelteon> EvanR: well, the IO performed here is when i make the HTTP call to the authy endpoint to verify the user's input
16:12:28 <joelteon> maybe I can fake failures from authy
16:12:54 <EvanR> :\
16:13:03 <EvanR> maybe one day
16:13:18 <NemesisD> joelteon: this is as far as i got https://github.com/MichaelXavier/HTTPMock
16:13:23 <NemesisD> i don't even remember where that library is at
16:13:25 <joelteon> thanks NemesisD 
16:13:35 <joelteon> no, I don't think even authy's sandbox api can be forced to return arbitrary failures
16:14:16 <NemesisD> joelteon: if you can get it to a releasable state good on ya
16:14:26 <joelteon> i guess the simplest solution would be to change the imported module with an ifdef
16:14:27 <NemesisD> i can't bear to look at haskell code i wrote 2 years ago
16:14:32 <joelteon> and otherwise keep it functionally identical
16:15:23 <SrPx> Can I ask GHC to hide anything from Prelude that is already on Foldable/Traversable? ....
16:15:34 * hackagebot atlassian-connect-descriptor 0.4.0.1 - Code that helps you create a valid Atlassian Connect Descriptor.  http://hackage.haskell.org/package/atlassian-connect-descriptor-0.4.0.1 (RobertMassaioli)
16:15:34 <joelteon> and then have a special case for requests that should go out to the internet
16:16:21 <EvanR> this is a very special case of wanting alternative IO 
16:16:27 <joelteon> it is
16:16:28 <joelteon> very special
16:16:34 <EvanR> and its probably better to just not have IO 
16:16:38 <EvanR> in the first place
16:16:47 <joelteon> ok so what are you proposing
16:16:48 <EvanR> the IO is only for the IO, not for the protocol
16:16:52 <EvanR> or should be
16:17:07 <joelteon> i have code that takes as input a Response ByteString and figures out whether it represents a success state or not
16:17:09 <EvanR> but were still stuck with present technology
16:17:17 <joelteon> should i call that manually in the tests?
16:17:22 <EvanR> is it an IO function?
16:17:33 <joelteon> no
16:17:39 <EvanR> then its testable
16:17:58 <EvanR> producing suitable test ByteStrings would be a good library
16:18:12 <joelteon> oh I could quickcheck it
16:18:14 <joelteon> that's smart!
16:18:16 <SrPx> Where is the generic scanl? That don't depend on list
16:18:25 <joelteon> good idea EvanR 
16:18:30 <joelteon> maybe i will get full coverage after all
16:20:55 <NemesisD> btw testable bytestring is a test library: tasty-golden
16:21:03 <NemesisD> or test-framework-golden or hspec-golden
16:22:37 <pavonia> SrPx: What type would you want it to have?
16:23:56 <glguy> :t scanl1Of
16:23:57 <lambdabot> LensLike (State (Maybe a)) s t a a -> (a -> a -> a) -> s -> t
16:24:27 <glguy> :t scanl1Of traverse
16:24:28 <lambdabot> Traversable t => (b -> b -> b) -> t b -> t b
16:27:15 <SrPx> uhm thanks
16:35:17 <randir> what's an RTS I can use, to understand bottlenecks in my code?
16:35:25 <randir> to see how much time is spent in various functions?
16:35:59 <gaze__> https://pavpanchekha.com/blog/zippers/kiselyov.html ugh what a tease. How the heck do you do multi-hole zippers in O(1)?!
16:41:55 <randir> I have a search tree (minimax) that recursively searches through branches
16:42:28 <randir> and I'm trying to figure out what the best way to parallelise it would be 
16:42:57 <randir> I want the program to concurrently be evaluating each individual node
16:49:28 <alexv19> Why there is no instance for         (Exception e, MonadCatch m) => MonadCatch (EeitherT e m)  in exceptions package? It is possible to define it, isn't it?
16:51:42 <c_wraith> alexv19: it's probably about dependencies.
16:52:31 <glguy> alexv19: This? instance MonadCatch m => MonadCatch (EitherT e m)
16:53:00 <glguy> http://hackage.haskell.org/package/either-4.3.3.2/docs/Control-Monad-Trans-Either.html
16:54:50 <alexv19> @glguy oh, i was looking at older version. Thanks!
16:54:50 <lambdabot> Unknown command, try @list
16:58:06 <athan> Can associated types reference type variables declared in instances? For instance, would something like `instance Foo (Something r) where; type Bar = SomeBar r ...` work / be legitimate?
16:58:25 <athan> I remember seeing an error referencing this issue before, I just want to make sure
16:58:49 <randir> I'm trying to reinstall a package with library profiling
16:59:06 <randir> but it fails, saying the profiling libs for a lot of dependency libs are not installed
16:59:16 <randir> how can I get it to install these too?
17:04:33 <randir> Is this possible?
17:07:17 <athan> Can anyone suggest a paper for mastering associated types with multi-param type classes?
17:19:01 <athan> By stating in a functional dependency that, say `class Foo foo bar r | foo bar -> r where...` means that there should only be _one_ instance of Foo _per_ `r`? Would it be useful to have bijective fundeps, where you have something like `class Foo foo bar r | foo -> bar, bar -> foo where ...`?
17:19:22 <athan> Also, functional dependencies are mainly used for type inference, right?
17:20:36 * hackagebot DAV 1.0.4 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-1.0.4 (ClintAdams)
17:21:18 <seagreen> Say I two modules, Core and Internal. I'd like to define a function f in core, but export it to the outside world through Internal. Is there a way to do that?
17:21:43 <seagreen> s/core/Core, sorry:/
17:22:30 <dolio> athan: To-way fundeps can certainly be useful. Not that I have a go to example.
17:23:00 <athan> seagreen: You can import the Core module hiding the ones you don't want to expose in Internal, then do `module Foo (module Bar) where...`
17:23:42 <athan> dolio: Thank you, definitely struggling with this (type-level programming ><)
17:24:37 <dolio> Also, 'foo bar -> r' means there can only be one instance per pair of foo and bar. Not per r.
17:24:49 <dolio> Two different foo, bar pairs could imply the same r.
17:25:46 <athan> dolio: Oh woah, okay! That helps a ton, thank you
17:28:33 <dolio> athan: I guess one example would be some kind of vector api class, where you included the operations on mutable and immutable vectors.
17:28:44 <dolio> Then you'd have mv -> v, v -> mv.
17:28:59 <dolio> Where the mutable vectors determine the corresponding immutable vectors, and vice versa.
17:29:27 <dolio> Fundeps aren't a great way to design such an api, but it could be done.
17:29:49 <seagreen> athan: Thanks!
17:30:22 <dolio> vector has something similar, but with type families instead of fundeps, because it's nicer to have the correspondence separate from the classes.
17:31:05 <athan> dolio: Thank you, I'm making some kind of crazy HList-like deconstruction stuff. Typeclasses feel like the only way to deconstruct types in a way where terms actually unify with the type variables
17:32:50 <athan> I'm _building_ my GADT with some type families, in a way that's not bijective, so I'd have to use "inductive" typeclass instances to deconstruct the GADT in a way where the type variables don't get generated, like `xs0` `xs1`, etc when type checking
17:37:51 <SrPx> So, suppose you are browsing https://hackage.haskell.org/package/lens-4.9.1/docs/Control-Lens-Fold.html and suddenly you find a symbol which you don't know the definition (element). How do you proceed to find its definition? What is the correct way?
17:38:06 <SrPx> "has (element 0) ..."
17:38:33 <glguy> SrPx: You can use the "index" in the top-right of the page for things that don't have links
17:39:24 <SrPx> Oh thanks!!
17:40:41 <SrPx> Ok so a quick question about lens, is there any reason functions like "mapAccumLOf" don't also have the obvious "mapAccumL = mapAccumLOf traverse" defined?
17:41:00 <edwardk> :t Data.Traversable.mapAccumL
17:41:01 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
17:41:04 <edwardk> ^- because of that
17:41:41 <edwardk> many of the fooOf combinators in lens are modeled after existing combinators in Data.Foldable or Data.Traversable
17:42:19 <arkeet> :t foldrOf folded
17:42:20 <lambdabot> (Foldable f, Indexable Int p) => p a (r -> r) -> r -> f a -> r
17:42:24 <arkeet> oh.
17:42:43 <arkeet> that's cute.
17:43:41 <KaneTW> :t folded
17:43:42 <lambdabot> (Applicative f1, Foldable f, Indexable Int p, Contravariant f1) => p a (f1 a) -> f a -> f1 (f a)
17:45:07 <SrPx> edwardk: uhm okay!
17:45:16 <SrPx> thanks
17:45:30 <arkeet> :t foldrOf folded . Indexed
17:45:32 <lambdabot> Foldable f => (Int -> a -> r -> r) -> r -> f a -> r
17:45:49 <gaze__> edwardk: Do you know of any extensions of zippers to multiple holes which don't involve a O(n) cost to jumping between the holes?
17:45:55 <SrPx> so, does this make sense? "zipWith f a b = snd $ mapAccumLOf traverse foo (b^..folded) a where foo (x:xs) a = (xs, f a x)" ? Or is there something similar already on Lens?
17:46:18 <SrPx> i.e. zipWith :: (T.Traversable f, F.Foldable g) => (b -> t -> c) -> f b -> g t -> f c
17:46:26 <gaze__> edwardk: https://pavpanchekha.com/blog/zippers/kiselyov.html there's this but he never finished the article! Any idea what he might have been onto?
17:46:36 <edwardk> in theory you can build an 'n hold context' by taking repeated derivatives and you'd probably have a log time access to each finger
17:46:42 <edwardk> er n hole context
17:47:09 <gaze__> yeah but like... ew. Doesn't an n-hole context have a really gross type?
17:47:15 <edwardk> well, yes
17:47:19 <gaze__> and doesn't the number of holes get baked into the type?
17:47:22 <edwardk> you asked for asymptotics, not niceness ;)
17:47:36 <edwardk> hence the 'in theory' =)
17:47:52 <gaze__> damn mathematicians.
17:48:09 <gaze__> well hmm
17:48:22 <edwardk> he says as i'm busy literally staring at fractions ;)
17:48:35 <arkeet> SrPx: that wouldn't work if the foldable is shorter than the traversable
17:49:07 <arkeet> (also, mapAccumLOf traverse = mapAccumL, and (^.. folded) = toList)
17:49:18 <SrPx> Ah is that the reason it doesn't exist? (I'm only zipping identical structures)
17:49:31 <arkeet> if you're zipping identical structures, consider Applicative
17:49:39 <edwardk> SrPx: lens typically doesn't supply much for working with multiple structures in parallel at the same time
17:50:02 <gaze__> edwardk: Is there maybe a way to lazily update the other holes? Like an update to the leaf of a tree shouldn't MATTER until you need to look at it.
17:50:15 <gaze__> but that's no good for querying them.
17:50:28 <gaze__> grrrr
17:51:02 <edwardk> gaze__: sure. you could build a structure that had 'segments' of a structure stored in a catenable structure like a finger tree. then lazily rezip the structure when you remove/fill a finger
17:53:19 <gaze__> edwardk: Are there any examples of this?
17:53:39 <edwardk> so you start with some data structure, then define 3 'cut' types. basically everything to the left of some hole, everything between two holes, and everything to the right of some hole. define how to do merges between type 1 and type 2, type 2 and type 2, and type 2 and type 3, with an intervening value for what you put at the finger, now you can maintain the
17:53:40 <edwardk> structures of the type 1 edge at the left, a catenable sequence/indexable structure in the middle, the type 3 edge at the right
17:54:01 <edwardk> then you'd have to define what do to when the you move to where another hole already is
17:54:07 <edwardk> or how to commute past
17:54:21 <edwardk> how to label the intermediate nodes, etc. and then you can have log time finger switching
17:54:30 <SrPx> arkeet: ah I meant identically sized lists, vectors etc
17:55:05 <edwardk> SrPx: well you can always extract the parts of the first, then mapAccumLOf yourself to push the values through
17:56:42 <solirc> joelteon: Did you already figure out your Hspec / cabal question?
17:56:48 <gaze__> ugh okay well... say I'm not necessarily interested in a zipper. Say I just want a nice way to have multiple accessors to a unix-style filesystem with snapshotting
17:56:50 <joelteon> solirc: yes, thanks
17:57:06 <gaze__> is this necessarily the path you'd go down to do something like that?
17:57:08 <solirc> joelteon: ok
17:57:33 <randir> Which would be faster to access: a function with 512 pattern matches, that I computationally generate and compile/load as a module
17:57:49 <solirc> joelteon: You may also take a look at https://github.com/hspec/hspec-example#running-tests for alternate ways of running your tests
17:57:57 <randir> or a Map, from input to an output list, that I'll generate at runtime
17:58:05 <gaze__> where when I say unix-style-filesystem, I mean some haskell datastructure
17:58:11 <gaze__> not like... "the filesystem"
17:58:16 <edwardk> or even get fancy and do things like foo & partsOf bar %~ \xs -> dosomethingwith xs (foo^..baz) that spits out a list of the same length. where bar and baz are both 
17:58:29 <solirc> joelteon: or if you want to try the latest and greatest experimental stuff https://github.com/hspec/autospec
17:58:43 <randir> want to know if (foo x) or (lookup x fooMap)? 
17:58:50 <joelteon> oo autospec
17:58:51 <joneshf-laptop> can  I have pandoc generate a pdf from lhs with the Bird style carets like you get for html?
17:59:10 <joelteon> solirc: does that do browser tests
17:59:32 <randir> is faster*
17:59:49 <solirc> joelteon: How do you mean?
18:00:03 <joelteon> solirc: I mean does it auto-refresh the browser when tests change, like some other frameworks in other languages do
18:00:05 <solirc> like webdriver?
18:00:06 <joelteon> sorry, that was a badly worded question
18:00:54 <solirc> joelteon: I'm still not sure if I understand what you mean.
18:00:56 <simpson> Aw. There's no Bifunctor instance for D.F.Sum.
18:01:23 <joelteon> solirc: Like you'll have the test result page in a browser window, and then when you change a test file it re-runs them and then your browser refreshes.
18:01:24 <solirc> joelteon: with browser you mean a web browser?
18:01:28 <joelteon> yeah, sorry.
18:01:52 <solirc> joelteon: No, the HTTP interface is meant for consumption by curl
18:01:57 <joelteon> oh, ok
18:01:59 <joelteon> cool
18:02:08 <solirc> so that you can e.g. get it into your vim quickfix list
18:02:27 <solirc> joelteon: the whole thing is experimental
18:02:35 <solirc> but we already use it every single day at work
18:05:18 <lpaste> randir pasted “Speed” at http://lpaste.net/131271
18:05:32 <randir> Can someone help me optimize this function? 
18:05:57 <randir> It takes up around 20% of the computational time for my program (it's called a lot), is there any way to do this faster?
18:06:28 <gaze__> edwardk: I think I now understand what you mean. You have several one-hole contexts which each represent some piece of the datastructure and if needed can be joined together
18:06:52 <randir> I'm considering generating all the different possible combinations (512 of them), into a module
18:06:53 <simpson> Never mind. Wouldn't make sense.
18:06:55 <randir> and compiling it
18:08:31 <randir> Or could I make the runtime cache it?
18:09:11 <randir> so that when the same input is given it will spit out the list instead of computing it 
18:09:22 <EvanR> thats memoization
18:09:48 <EvanR> but youd have to see how much time it takes to calculate whether youve seen it before, and how much memory it would take
18:10:11 <EvanR> recalculating my just be faster
18:10:25 <dsturnbull_> like this? https://wiki.haskell.org/Beta_reduction
18:10:57 <randir> Memory isn't an issue, I'm preferring time over space
18:11:18 <randir> what about just having it precalculated?
18:11:22 <edwardk> gaze__: its more of a 'gaping wound' than a single holed context.
18:11:32 <edwardk> gaze__: you're ripping off the entire left or right of the structure or both
18:11:33 <EvanR> randir: oh, rank and file can both by 1 out of 8 things
18:11:40 <edwardk> from two separate gashes
18:11:41 <randir> exactly
18:11:44 <EvanR> randir: so yeah just a lookup table would be fastest
18:11:55 <randir> EvanR how should I generate that?
18:11:55 <edwardk> gaze__: and then relying on invariants that you only stitch up legal structures to keep it from going wrong
18:12:05 <EvanR> if you define the table as a top level value, it will be computed by lazy evaluation
18:12:06 <dsturnbull_> i assume compilers can figure out that 1 * 44 is 44 and not actually execute the multiplication at runtime
18:12:32 <randir> how should I create the table?
18:12:37 <randir> use something like Data.Map?
18:12:38 <EvanR> randir: Map (Direction, Rank, File) [Square]
18:13:30 <randir> so if it's a pure function that takes no arguments, the runtime will cache it, right?
18:13:56 <EvanR> that doesnt make sense
18:14:05 <EvanR> all functions take one argument
18:14:15 <EvanR> that Map is a single value
18:14:27 <EvanR> you just have to define it
18:14:35 <pavonia> randir: Not sure, but maybe making Square a strict pair would also get you some time improvements?
18:15:20 <gaze__> edwardk: Perhaps I'm misunderstanding something. Is this 3 cut thing for two holes, or is it general?
18:15:50 <gaze__> like for 4 holes do I need a left | middle1 | middle2 | middle 3 | right ? 
18:15:57 <edwardk> in general. the 'cuts' aren't 'removing one hole' but they are the one-sided derivatives where you are removing everything to the left or right of a cut
18:15:59 <gaze__> and the insertions happen at the cuts?
18:16:37 <edwardk> left has 'one gaping wound' in it, its missing everything to the right of the |
18:16:53 <edwardk> right has 'one gaping wound' in it, its missing everything to the left of the |
18:17:31 <edwardk> middles have two gaping wounds. you've ripped off both of their arms. given something to patch up the left side and a left hand you could stitch that up and turn a left and middle into a left.
18:17:50 <edwardk> assuming they were originally made from the same cut
18:18:01 <edwardk> stitching up things where the cuts don't match up won't work
18:18:07 <gaze__> ahhh
18:18:10 <edwardk> but you can maintain the invariant that the structure always has this property
18:18:26 <gaze__> so I have to stitch up a left | middle | middle | middle | right
18:18:32 <edwardk> yeah
18:18:37 <edwardk> and you have fingers at each of the |s
18:18:55 <edwardk> and some editable sequence of middles in the middle
18:18:56 <randir> pavonia: what do you mean, a strict pair?
18:19:10 <edwardk> preferably one with fast logish time transitioning
18:19:20 <edwardk> even just a finger tree or two queues or whatever
18:19:37 <edwardk> er 'or two sequences'
18:20:16 <gaze__> right! Okay that makes sense
18:20:25 <pavonia> randir: Something like "data Square = Square !Int !Int", so that all additions get evaluated immediately
18:20:28 <edwardk> data Mutilated a = Mutilated (L a) (Seq (M a)) (Seq (M a)) (R a)
18:20:33 <gaze__> one of my goals is to have the ability to watch activity on a subtree
18:20:36 <edwardk> for L, M and R the various derivatives mentioned above.
18:21:00 <edwardk> now you have an 'active' finger, which is the spot between the Seq's
18:21:09 <edwardk> but switching can be done in log time
18:21:28 <gaze__> so if I decorate something with who is watching, I guess during commutation of holes I apply the different rules of what to report
18:21:44 <gaze__> or rather something being a node
18:21:59 <edwardk> and you can dissolve a finger by stitching up behind you with the L a -> M a -> L a, M a -> M a -> M a, M a -> R a -> R a  operations
18:22:07 <gaze__> well anyway that's getting too complicated for me right now
18:22:22 <gaze__> ah right
18:22:23 <edwardk> or they can be L a -> a -> M a -> L a  -- if you want 'a' shaped values in the middle that you ahve to supply to stitch the finger
18:22:25 <randir> pavonia: I currently have type Square = (Int,Int)
18:22:39 <randir> would type Square = (!Int,!Int)   make sense/improve it?
18:23:05 <pavonia> Not sure if that works
18:23:13 <edwardk> randir: that doesn't work
18:23:26 <edwardk> data Square = Square !Int !Int -- that can work
18:23:49 <edwardk> but now you have to make up your own operations
18:24:02 <pavonia> edwardk: Why doesn't the former work?
18:24:22 <edwardk> pavonia: because !'s aren't something you write in a type signature. they are something you can write in a data declaration
18:24:49 <randir> what about data Square = (!Int,!Int)? 
18:24:58 <randir> Or does that not make sense?
18:25:05 <edwardk> randir:  you can't put "!"s inside another type.
18:25:06 <geekosaur> data requires a constructor
18:25:18 <edwardk> you can put it intside of the direct field members of the constructor you are defining
18:25:32 <randir> okay
18:25:49 <edwardk> (for the peanut gallery, yes, in GADT syntax there are places where they go in a type, but they are for defining fields in a constructor you are making)
18:27:23 <shachaf> GADT syntax kind of breaks down with things like strictness annotations and records.
18:29:33 <randir> EvanR: What's a good way to represent my "ray" function as a toplevel Map?
18:29:58 <randir> I can think of how to construct it, but want to see if I'm missing a really elegant/simple solution
18:31:12 <randir> I can fold insert over an Empty map, for each direction. Is that the best way to construct it? 
18:35:24 <ttt_fff> is there a good tutorial anywhere on implementing a prolog in haskell ?
18:35:33 <ttt_fff> I want a tutorial to walk me through implementing prolog in hasell
18:35:35 <ttt_fff> like tutorials for monads
18:35:42 <SrPx> Is there any reason scanl1 isn't on Data.Traversable but scanl1Of is on Control.Lens.Traverse?
18:35:45 <ttt_fff> but perferably, less analogies, and more "RTF types"
18:36:58 <ReinH> Just noticed "Module ‘Data.Attoparsec.Char8’ is deprecated"... yay!
18:37:20 <arkeet> just need do that for bytestring!
18:37:57 <ReinH> Yeah.
18:41:12 <glguy> It's just deprecated in favor of http://hackage.haskell.org/package/attoparsec-0.12.1.6/docs/Data-Attoparsec-ByteString-Char8.html
18:41:14 <glguy> It's not deprecated
18:41:23 <arkeet> aw
18:51:37 <edwardk> SrPx: because it can be and somebody asked us to add it. its kind of an ugly function in the sense that it assumes an invariant and doesn't follow the internal invariants you'd expect of scanl1, so we don't broadcast it and haven't pushed to standardize it
18:52:00 <edwardk> but its the 'right' notion of scanl1 in many senses, since scanl1 doesn't change the shape of a structure
18:52:42 <edwardk> SrPx: i'm very slow to push to bring things into the standard libraries, because they are _very_ difficult to ever remove ;)
18:54:04 <SrPx> edwardk: uh huh, I was just curious. Thanks.
19:10:05 <randir> I have a where binding: toTrace = (ray) (M.!) (dir,f,r)
19:10:26 <randir> where ray :: M.Map (Direction, Int, Int) [Square]
19:10:54 <randir> but I'm getting the error:
19:10:55 <randir> The function ray is applied to two arguments,
19:10:55 <randir>     but its type M.Map (Direction, Int, Int) [Square] has none
19:11:08 <randir> any idea what could be happening here?
19:11:23 <arkeet> you are trying to apply ray to two arguments, namely (M.!) and (dir,f,r)
19:11:53 <arkeet> you probably just want to write M.!
19:12:00 <arkeet> as an infix operator
19:12:21 <arkeet> (you also probably don't want to use !)
19:12:33 <randir> ah, I thought (M.!) had to be in parentheses, syntactically
19:12:37 <arkeet> no
19:12:40 <arkeet> that makes it a prefix function
19:12:49 <randir> ahh, okay
19:13:06 <randir> I'm using ! because it's only looking up values that should exist
19:13:19 <randir> I'm okay with it giving an error if it can't be found, trying to optimize for speed
19:57:07 <Tristanp> Is learning Happstack without learning Haskell sort of analagous to learning Rails without learning Ruby?
19:57:46 <c_wraith> yes
19:58:42 <Jeanne-Kamikaze> no
19:58:55 <ackthet> opinions, apparently, differ :P
19:59:13 <Jeanne-Kamikaze> it would be analogous if happstack `analogous` rails and haskell `analogous` ruby
19:59:17 <Jeanne-Kamikaze> non of which is remotely true
19:59:32 <Cale> I don't know what learning Rails without learning Ruby is like, but I expect trying to write any Happstack code at all without learning Haskell will be next to impossible.
19:59:42 <ackthet> I wrote an Xmonad config before i know Haskell
19:59:42 <Jeanne-Kamikaze> exactly
19:59:42 <c_wraith> Both are equally impossible.
19:59:49 <c_wraith> so...  quite analogous.
19:59:56 <ackthet> based heavily on the works of others and #xmonad 
20:00:11 <Jeanne-Kamikaze> I'm pretty sure you can write rails without knowing ruby c_wraith 
20:00:24 <Jeanne-Kamikaze> don't underestimate yourself
20:00:33 <c_wraith> Jeanne-Kamikaze: I'm sure you can't, as soon as you want to introduce logic.
20:00:42 <Cale> Yeah, if you already have a fully defined Happstack application, maybe you'll manage to tweak some things successfully.
20:01:13 <Jeanne-Kamikaze> I certainly can't, as I cannot write a program longer than 100 lines in a language with no type system
20:02:34 <Jeanne-Kamikaze> Tristanp, but hey, who are we to lay stones in your way to success, give it a try anyway
20:03:07 <Jeanne-Kamikaze> don't worry if you fail, we've got you covered: http://learnyouahaskell.com/
20:03:42 <Cale> If you're not already familiar with another statically typed functional programming language, you can expect Haskell to be approximately like learning to program from scratch.
20:04:01 <Cale> You might also like this course: http://www.seas.upenn.edu/~cis194/fall14/spring13/index.html
20:04:41 <Tristanp> thanks for the links and comments, this is helpful
20:05:30 <Jeanne-Kamikaze> you quit after getting help? certainly not a regular irc user
20:05:53 <Jeanne-Kamikaze> these new generations, failing to learn the ways
20:06:33 <Jeanne-Kamikaze> may the lurking eye unleash its wrath upon them
20:07:49 <slack1256> > 2 + 2
20:07:51 <lambdabot>  4
20:08:13 <glguy> That's an easy one to forget
20:09:03 <solrize_> @faq add 2+2 and get 5?
20:09:04 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
20:09:32 <slack1256> Sorry, I was trying emacs erc and wasn't getting any output
20:13:12 <Pamelloes> I have a do block with the type Monad1 t () and within the do block I have a variable with the type Monad2 t (). Is there a way I can specify the variable's type so that its t parameter matches the t parameter of the do block as a whole?
20:18:33 <johnw> Pamelloes: can you show me the code?
20:18:58 <johnw> that sounds like a job for ScopedTypeVariables, but I'd have to check to make sure
20:21:16 <athan> What is it called when GHC's typechecker generates new type variable names, like xs0 etc.?
20:23:04 <Pamelloes> johnw: My code's kind of a god-awful mess right about now and I'm not quite sure if I can get a readable excerpt out of it. However, ScopedTypeVariables looks like the exact thing I need
20:24:13 <Lights> When making a type constructor, lets call it myType, what's the difference between delcaring myType with data myType versus type myType?
20:24:31 <arkeet> type makes a type synonym (just another name for the same type)
20:24:34 <ElMoloko> type is just an alias
20:24:35 <arkeet> data creates a new algebraic data type
20:24:45 <arkeet> (also, type names must start with a capital letter)
20:24:47 <johnw> a data type has a constructor, a type synonym is just another name for that type
20:25:09 <arkeet> type Foo = Int  makes Foo exactly the same as Int
20:25:30 <arkeet> data Foo = F Int  makes a new data type. it contains an Int (and is constructed by the constructor F)
20:25:30 <johnw> next you'll want to know how data and newtype differ :)
20:25:43 <arkeet> the difference there is more subtle :p
20:26:38 <ElMoloko> athan: did you find out? i'm curious
20:26:49 <Lights> arkeet and johnw: Thank you guys so much. Taking a senior class on functional programming and the gf and I are confused -_- Your guys' explination is way better than the book and constructor
20:26:55 <athan> ElMoloko: Not yet :(
20:27:00 <Lights> thank you guys so much, and you, too, ElMoloko
20:27:03 <johnw> athan: allocating a binder?
20:27:21 <srobert> constructor = instructor?
20:27:24 <athan> johnw: I think so. The typechecker usually tries to unify the new names... right? :S
20:27:30 <Lights> oops, I meant book and* instructor. hahaha it's been a long day
20:27:43 <srobert> :)
20:28:05 <johnw> athan: it tries to unify the types they are bound to, yes
20:28:17 <athan> ahh, okay!
20:28:22 <athan> thank you johnw
20:47:52 <athan> is there a straightforward way to reduce ambiguous types?
20:48:08 <johnw> example?
20:48:31 <athan> :|
20:48:38 <athan> johnw: it's... painful
20:49:34 <johnw> well, there are a few ways to provide type information, so I'd need more context
20:50:17 <athan> johnw: http://lpaste.net/131278 :\
20:50:52 <johnw> line 68 is?
20:51:35 <athan> johnw: That's 46 in the paste
20:54:38 <Cale> athan: Are you sure type classes are really a good fit for what you're trying to do? Maybe just defining a record data type, or using function parameters of some sort would be better?
20:54:42 <johnw> do you seriously want this code?
20:55:02 <johnw> yeah, even if you get this working, people after you are going to have a hard time unraveling this
20:56:04 <athan> johnw: I don't see any other way for packing a existentially quantified type into a rose tree :\ (that's what RUPTrie is)
20:56:45 <athan> Cale: I'm not sure if it is, but I feel like type families would make it even more difficult to unify types. HList, for instance, takes this approach
20:56:49 <athan> for HFoldR
20:58:04 <johnw> the use of Maybe with EitherUrlChunk is confusing
20:58:49 <johnw> maybe you want to pass a function as an argument to Cons
20:58:52 <athan> johnw: How else would you represent the result of the parse?
20:59:02 <athan> hmm, okay
21:00:27 <athan> The strange thing for me
21:01:06 <nshepperd> athan: should Extrude have a fundep?
21:01:11 <athan> is that `Cons u us :: UrlChunks (x ': xs)` doesn't immediately show that `u :: EitherUrlChunk x`, but rather some side-route that it should be `mx`
21:01:21 <athan> nshepperd: I don't want to mess with that yet
21:01:30 <athan> er wait
21:01:37 <athan> I think you may be right...!
21:02:47 <athan> nshepperd: You're brilliant :)
21:03:07 <athan> the friggin thing type checks
21:04:01 <joneshf-laptop> is there a file glob thing in base or something I might have missed?
21:04:06 <joneshf-laptop> or even regex
21:04:53 <nshepperd> ah, right, it's because trie1 is undetermined without the fundep
21:05:30 <athan> nshepperd: You're exactly right
21:07:13 <nshepperd> I still don't condone use of all these AllowMadness extensions though :)
21:11:02 <athan> nshepperd: How else do you get things done
21:11:05 <athan> ? :P
21:50:48 * hackagebot Zora 1.1.23 - Graphing library wrapper + assorted useful functions  http://hackage.haskell.org/package/Zora-1.1.23 (bgwines)
22:19:43 <simpson> @unmtl EitherT e (WriterT () STM)
22:19:44 <lambdabot> EitherT e (WriterT () STM)
22:19:55 <bitemyapp> simpson: that was helpful
22:19:59 <simpson> Really lambdabot? :T
22:20:01 <jle`> heh
22:20:03 <jle`> well
22:20:08 <jle`> EitherT isn't in transformers/mtl, i think
22:20:14 <simpson> That's true.
22:20:19 <bitemyapp> yep, it's in `either` :)
22:20:21 <jle`> and also unmtl doesn't do any curslve unmtling
22:20:26 <jle`> *recursive
22:20:35 <jle`> so :|
22:20:41 <kadoban> I swear, every time I try to use unmtl, it just gives me lame unhelpful output. I'm starting to wonder if it's just a troll command.
22:20:49 <simpson> I'm thinking which order I want those in; I want to preserve the written effects even if my Either switches to an erroring state.
22:20:50 * hackagebot engine-io-growler 0.1.0.0 -   http://hackage.haskell.org/package/engine-io-growler-0.1.0.0 (IanDuncan)
22:20:59 <kadoban> Or … maybe more likely I just don't understand how to use it.
22:21:00 <simpson> I guess that that means that I want WriterT () (EitherT e STM)
22:21:33 <enthropy> @unmtl ErrorT e (WriterT () STM) a
22:21:34 <lambdabot> (WriterT () STM) (Either e a)
22:22:25 <jle`> @unmtl WriterT () STM a
22:22:26 <lambdabot> STM (a, ())
22:22:33 <simpson> Stupid ErrorT. Trolling forever.
22:22:36 <jle`> STM (Either e a, ())
22:22:45 <simpson> Yep.
22:22:58 <jle`> we have ExceptT now...i wonder if unmtl knows about that
22:23:00 <enthropy> jle`: I think it used to
22:23:06 * enthropy looks at logs
22:23:10 <jle`> used to do it recursively?
22:23:19 <enthropy> yes
22:23:27 <jle`> i feel like it did too
22:23:30 <jle`> but one day it just didn't
22:23:37 <jle`> why you got to be like that
22:24:25 <jle`> on a side note, learning how to do least squares fitting on arbitrary linear functions was one of the most useful math tricks i learned this past year
22:24:40 <jle`> s/on arbitrary/to arbitrary
22:24:45 <nocturne777> do most haskellers use https://hackage.haskell.org/package/safe ?
22:25:32 <jle`> nocturne777: lambabot uses it :)
22:25:32 <simpson> nocturne777: Never seen it before. Looks like a lot of work to use correctly.
22:25:38 <jle`> oh wait
22:25:40 <jle`> i'm thinking of something else
22:25:46 <jle`> i've seen people suggest it here on this channel
22:25:50 * hackagebot engine-io-growler 0.1.0.1 -   http://hackage.haskell.org/package/engine-io-growler-0.1.0.1 (IanDuncan)
22:26:27 <jle`> i've never used it myself though
22:26:29 <nocturne777> I have finished writing a SOS game using the the base library
22:26:33 <nocturne777> things turned out elegant
22:27:31 <nocturne777> I was wondering what are some packages that people use besides the base one to boost productivity?
22:27:37 <friden> quick question, i was doing a course on Agda last year, but they mentioned that there were haskell extentions that made the type system work similar to Agda, any one know it's name?
22:28:04 <enthropy> jle`: http://lpaste.net/4768219185316626432
22:28:51 <jle`> oh my
22:29:41 <jle`> what happened :(
22:29:57 <jle`> algernon scenario?
22:30:04 <arkeet> friden: here's a good paper. http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.2636
22:30:25 <arkeet> but it's from before DataKinds and such existed.
22:33:53 <stoopkid> what is this, a zen koan? :
22:33:55 <stoopkid> Put another way, = does not denote “assignment” like it does in many other languages. Instead, = denotes definition, like it does in mathematics. That is, x = 4 should not be read as “x gets 4” or “assign 4 to x”, but as “x is defined to be 4”.
22:33:55 <stoopkid> What do you think this code means?
22:33:55 <stoopkid> y :: Int
22:33:55 <stoopkid> y = y + 1
22:34:07 <stoopkid> 'you think that's air you're breathing?'
22:34:57 <jle`> the 'you think that's...' is a quote from the matrix
22:35:09 <jle`> (1999)
22:36:34 <Denommus> stoopkid: it means that Turing completion is unforgiving 
22:36:53 <nocturne777> simpson: why do you say that? it looks simple enough
22:41:15 <simpson> nocturne777: Sure. It does look simple. But it also looks like using this library correctly might be more work, at least for me, than just avoiding those particular unsafe functions altogether.
22:41:52 <andyf> If I have a question for a reasonably broad cross-section of Haskell developers, what forum would you recommend asking it in?  comp.lang.haskell?  Haskell sub-Reddit?  Somewhere else?
22:42:59 <arkeet> haskell subreddit is pretty good.
22:43:02 <arkeet> so is haskell-cafe
22:43:26 <verement> do people still use Usenet?
22:43:39 <bitemyapp> verement: for piracy, yes.
22:43:47 <verement> aside from binaries I mean
22:44:03 <bitemyapp> I'm sure there are some c.l.l salts still at it.
22:44:56 <andyf> bitemyapp: I see you’ve found the place where you don’t need to convince anyone of the benefits of Haskell :)
22:47:00 <bitemyapp> andyf: sorry, do I know you from somewhere?
22:47:26 <andyf> bitemyapp: Maybe you don’t know me, but I recall you from some #clojure channel discussions.
22:48:28 <bitemyapp> andyf: I successfully stole the people I wanted to steal from the Clojure community. Flipped a couple startups over too.
22:48:39 <nocturne777> there are many ways of error handling in haskell like shown here http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/ 
22:48:46 <andyf> So, it’s like a crusade?
22:48:55 <nocturne777> what are some of the preffered ones that people lean towards ?
22:48:59 <bitemyapp> andyf: no, I've got everybody I cared about.
22:49:19 <bitemyapp> andyf: the rest can buy the book when it comes out. I don't have time to address the same fears over and over.
22:49:28 <nocturne777> so far I have been only using Maybe, Either, and error for things that the application cannot recover from
22:50:38 <nak> hello haskell people
22:50:50 <nak> you've got another newbie amongst you
22:51:28 <bitemyapp> everybody was at one point or another
22:51:35 <kadoban> nak: 'welcome :)
22:51:37 <bitemyapp> unless that knowledge downloading thing was invented
22:51:45 <bitemyapp> can I buy that on Amazon?
22:51:52 <bitemyapp> nak: welcome :)
22:52:11 <nak> thanks :)
22:52:14 <kadoban> nocturne777: Probably Maybe or Either would be the preferred ways, when they apply. Just depends if you care about having an error message really.
22:52:28 <nak> people here must be incredibly nice because this is *the* most populate irc channel i've ever seen
22:53:10 <kadoban> Yeah, #haskell rocks. It's a way different (better) feel compared to most of the other language channels.
22:53:37 <bitemyapp> #haskell is the most populous programming language IRC channel AFAIK
22:53:45 <nocturne777> kadoban: try and catch sort of stuff is not looked upon favorably in general, am I wrong on this?
22:53:48 <bitemyapp> definitely on Freenode, possibly also in the English-speaking world.
22:54:59 <kadoban> nocturne777: I think it's slightly unsatisfying, but I don't have a lot of experience with it. I've used those kinds of things pretty rarely. Which may tell you something, or may just be my own inexperience.
22:55:27 <bitemyapp> nocturne777: some libraries use exceptions and there's not a ton you can do about it.
22:55:28 <nocturne777> I mean I would definately consider using try-catch if I need do take different actions based on the thrown expcetion
22:55:43 <ElMoloko> huh i'd be curious to see a haskell IRC channel for some other natural language varieties
22:56:21 <kadoban> nocturne777: Well, that's quite possible with Either. You can have a sum type that encodes your possible error states, and do whatever you want based on that. It doesn't always have to be Either String a
22:56:43 <bitemyapp> ElMoloko: non-En speaking Haskell channels are on Freenode, I was hedging in case there was a secret dark pool of Haskellers hiding out in the steppes of Mongolia.
23:02:39 <HEGX64> How does one exit the editor yi with default keybindings?
23:03:16 <Rotaerk> > let　試験　= (+1) in 試験 3
23:03:18 <lambdabot>  4
23:04:39 <stoopkid> "simpleHTTP nullConf $ ok "Hello, World!" "
23:04:41 <Rotaerk> HEGX64, that's googleable :P
23:05:11 <stoopkid> its difficult for me to differentiate functions from other kinds of data
23:05:16 <pacak> HEGX64: The same way as you exit from vi on the first time - by rebooting your machine.
23:05:29 <nak> so it seems like 'a' (single quotes) is for single chars, but "abc" (double quotes) is for multiple chars?
23:05:30 <ElMoloko> I wouldn't be surprised if there was a small group of haskell hackers somewhere in Ulaanbatar, slowly taking over
23:05:44 <stoopkid> is the syntax "simpleHTTP(nullConf,$,ok,"Hello, World!")" allowable? 
23:05:48 <Rotaerk> nak, "a" is also valid.
23:06:05 <nak> Rotaerk is there other reasons to use 'a' instead of "a" ?
23:06:16 <Rotaerk> nak, "aoeu" is syntax sugar for ['a', 'o', 'e', 'u']
23:06:22 <Rotaerk> so "a" is ['a']
23:06:35 <nak> gotcha
23:06:37 <stoopkid> i much prefer "f(x,y,z)" to "f x y z"
23:07:00 <Rotaerk> stoopkid, f (x, y, z) is valid in haskell.  it means something different.
23:07:01 <ryantrinkle> stoopkid: it's entirely possible to write functions like that
23:07:30 <stoopkid> Rotaerk, it would be f evaluated on a triple (x,y,z)?
23:07:31 <Rotaerk> f x y z is the curried form of the other
23:07:31 <ryantrinkle> that just means f needs to be a function that takes a triplet as an argument
23:07:34 <pacak> > uncurry (+) (1,2)
23:07:36 <lambdabot>  3
23:07:42 <ryantrinkle> stoopkid: that's right
23:07:51 <nak> i forget what it's called when you can put the function in between arguments (as in    'a' : []    )
23:07:59 <Rotaerk> stoopkid, it's not just a matter of preference/aesthetics... there is a practical distinction between the two
23:08:02 <ElMoloko> infix?
23:08:03 <ryantrinkle> stoopkid: treating functions more like regular data is one of the big ideas of haskell
23:08:04 <kadoban> stoopkid: You should really just get used to it though. It becomes natural after not very long.
23:08:15 <Zemyla> Why the heck does this work?
23:08:21 <Rotaerk> stoopkid, particularly, the curried function can be partially applied, but the other can't
23:08:21 <Zemyla> :t coerce `asTypeOf` fmap
23:08:23 <lambdabot>     Occurs check: cannot construct the infinite type: a1 ~ f a1
23:08:23 <lambdabot>     Expected type: (a1 -> a) -> a1 -> f a
23:08:23 <lambdabot>       Actual type: (a1 -> a) -> f a1 -> f a
23:08:43 <Zemyla> Okay, it works on my GHCi.
23:08:51 <stoopkid> Rotaerk, hm, so i should read up on 'currying' to understand why they do it this way?
23:09:00 <Zemyla> And it's in Data.Sequence, fmap = coerce.
23:09:07 <Rotaerk> yea, and partial application
23:09:19 <blue_feint> Rotaerk: are you a dvorak user?
23:09:24 <Rotaerk> yes
23:09:33 <blue_feint> heh, same here
23:09:45 <verement> Dvorak users unite
23:09:53 <Rotaerk> dyslexics untie
23:10:02 <kadoban> Yay dvorak
23:10:13 <nak> i've always wanted to learn colemak
23:10:45 <Rotaerk> I don't really have any good way of supporting the belief that switching to dvorak was worth it
23:10:51 <kadoban> nak: You should, whichever layout appeals to you. They're way better than qwerty, and it doesn't take /that/ long to learn.
23:11:02 <Rotaerk> hard to test, since my qwerty speed has dropped
23:11:10 <Rotaerk> anyway, off-topic
23:11:19 <kadoban> It was worth it to me. I don't much care about speed, but typing is /way/ more comfortable.
23:11:21 <nocturne777> kadoban: do you mean like MonadError ?
23:11:35 <kadoban> nocturne777: I don't think so? I don't know what that is.
23:12:06 <nocturne777> kadoban: example 5 -> http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/
23:12:33 <stoopkid> hm, it would still be nice if the curried version was something like "f<x,y,z>"
23:12:50 <Rotaerk> nah
23:13:03 <kadoban> stoopkid: That would have connotations that aren't true.
23:13:33 <kadoban> The way it is makes it more clear that partially applying functions isn't some weird special case, it's what you do every time.
23:13:45 <nak> what's the unsugared version of 'a' : []
23:13:51 <ElMoloko> is that what's used in java?
23:14:05 <glguy> Nak: what you wrote
23:14:26 <verement> > 'a' : []
23:14:27 <kadoban> nak: That is the unsugared. You mean sugared? "a"
23:14:28 <lambdabot>  "a"
23:14:33 <nak> oh
23:14:44 <nak> i thought the (:) form might be special there
23:14:50 <kadoban> nocturne777: No, I just mean using Either MyErrorType a
23:14:52 <Rotaerk> my preferred way of reporting errors is to make my return type Either e Foo, where e is a generic error type... then for each type of error, I take as a parameter an error-constructor that produces an e
23:15:27 <joneshf-laptop> Rotaerk, do you have an example of that?
23:15:59 <Rotaerk> the problem with making an ADT, say, MyError and then doing Either MyError Foo, is that you end up wanting to mix error types in a variety of combinations depending on the function
23:16:01 <Rotaerk> and it becomes a mess
23:16:07 <joneshf-laptop> Rotaerk, example could just be type signatures
23:16:31 <Rotaerk> joneshf-laptop, yes, one sec
23:17:37 <bitemyapp> I take that back, I've been informed we're not the biggest.
23:17:39 <bitemyapp> I forgot #python
23:19:12 <ryantrinkle> bitemyapp: they're not much bigger, though :)
23:19:14 <ElMoloko> what's that like?
23:19:20 <bitemyapp> not much.
23:19:27 <bitemyapp> ElMoloko: what's what like?
23:19:48 <Rotaerk> joneshf-laptop, a little complicated for an example, but a real example:  http://lpaste.net/2946060558161412096
23:20:17 <Rotaerk> joneshf-laptop, (think of the AtomicT as just an EitherT but with an extra rollback capability)
23:21:34 <Rotaerk> a simpler, more abstract example would be something like:  A -> B -> (C -> e) -> (D -> F -> e) -> Either e G
23:21:46 <ElMoloko> oh, #python.
23:22:00 <Rotaerk> A and B are the true parameters to the function, but then (C -> e) and (D -> F -> e) are constructors for certain error scenarios
23:22:17 <aleator> Silly question, but I'm considering to use shake as a build system for a semi-large project. Previously my experience with it has been so-and-so. Any opinions/alternatives on shake?
23:22:50 <ElMoloko> I always get told off for my python code - as I should. ''.join( map( (lambda x: hidden_mm[state][x]), s[last::]) ):'
23:22:50 <ElMoloko> isn't very pretty
23:23:13 <kadoban> Rotaerk: I guess that kind of encodes what error condition a function has then? Can't tell if that's useful or tedious. It works well in practice?
23:23:35 <Rotaerk> kadoban, it makes the function signature more complicated, but it gives me simplicity elsewhere
23:24:05 <Rotaerk> i.e. I don't have to use exceptions or an error-ADT
23:24:25 <kadoban> Hmm. Sounds interesting, I'll have to keep that in mind.
23:24:41 <Rotaerk> ultimately an ADT will probably be created, but it'll be one that encapsulates *all* the errors the calling code has to face
23:24:49 <Rotaerk> rather than just the ones this particular function deals with
23:25:13 <ElMoloko> aleator: i've no experience with shake, but have you thought about just using cabal, with a sandbox?
23:25:16 <Rotaerk> some might argue that in this particular use-case, it should just be an exception... but it stil demonstrates the approach
23:25:18 <kadoban> I think I've probably gotten by just with an ADT because most of what I do so far is pretty simple and small, heh.
23:25:52 <kadoban> I can imagine where it would get unwieldy, never really quite thought about it I guess.
23:25:58 <Rotaerk> kadoban, the problem is if function foo can produce AError and BError, and then function bar can produce AError and CError
23:26:21 <aleator> ElMoloko: Well, this thing needs to do stuff like build containers and provision a server. All haskell stuff is naturally caballed, but even that needs a bit of setup in form of add-sourcing.
23:26:30 <Rotaerk> you can make an ADT to encapsulate all those errors if you want, but then it's unclear from the types which kinds of errors can be produced
23:26:43 <Rotaerk> i.e. you'll have one that's AError | BError | CError
23:27:22 <kadoban> Right, yeah I see what you're getting at. There's no real way to encode "I can give you an AError or a CError"
23:27:35 <aleator> What I especially don't like about shake is that I have to build the build system before building :/
23:27:43 <nocturne777> Rotaerk: I would make an ADT to take different paths in the code 
23:27:56 <ElMoloko> yeah, nevermind :p i'd just use make but i'm lame afraid of change for such things
23:27:59 <joneshf-laptop> Rotaerk, oh, i see what you were saying now. thanks
23:28:03 <nocturne777> the client would just pattern match on the errors that it want to handle
23:28:11 <nocturne777> wants*
23:28:52 <Rotaerk> nocturne777, if we're reporting the error as an Either rather than an exception, the matching would likely be done specifically for the function being called, not in just one catch-all place
23:29:20 <Rotaerk> and if you're doing that it should be clear what the posible values are that you should handle
23:29:47 <Rotaerk> ultimately, you may create an ADT, but that should be up to the calling code
23:29:56 <Rotaerk> not the function that produces the error
23:30:18 <kadoban> Rotaerk: What does 'e' end up being. Is it just some type the caller comes up with, or … hmm I guess ideally it'd be specific to a set of possible error cases?
23:30:45 <Rotaerk> kadoban, it's whatever the caller wants; it's whatever the constructors they pass, return
23:31:04 <Rotaerk> the constructor receives all the information about the error from the failing function
23:31:13 <Rotaerk> and reports it in whatever way the caller sees fit
23:31:29 <kadoban> Rotaerk: Right. I guess your API doesn't care at all what it is, or need to provide anything to use for e …
23:32:18 <kadoban> That's kinda neat too, because then you can just be flimsy about it and use String if you don't care, or use something rigorous if you do.
23:32:23 <Rotaerk> right
23:32:50 <Rotaerk> or you could make e into an IO () or something that logs *shrug*
23:33:16 <kadoban> Cool
23:33:29 <Rotaerk> the primary downside is the complication to the function signature
23:33:58 <Rotaerk> I'm wondering if I should rearrange the order of the parameters, so that the caller can create their own version of the function, with the error constructors already partially applied
23:34:19 <kadoban> If you changed/added what error conditions a function has, I guess that might be kinda tedious, but … usually I guess that doesn't change, even if you change underlying implementation.
23:34:26 <Rotaerk> though generally the error handling is per call, so that doesn't tend to be valuable, I think
23:35:01 <Rotaerk> it's not something I've seen others do; I just came up with it after getting frustrated with other error handling mechanisms
23:35:10 <Rotaerk> so it's not heavily tried-and-tested, afaik
23:35:17 <Rotaerk> but so far, it's worked for me
23:35:53 <Rotaerk> anyway, bedtime
23:36:01 <kadoban> Thanks for describing it, it certainly seems interesting. 'night
23:37:12 <joneshf-laptop> is there a reason this doesn't compile: http://lpaste.net/131285 ?
23:38:37 <harel_f> line six
23:38:41 <kadoban> joneshf-laptop: Yeah. foo is more polymorphic than foo', which … doesn't really make sense.
23:39:03 <kadoban> joneshf-laptop: The /other/ way around would make sense, but … not that way.
23:39:52 <joneshf-laptop> kadoban, I'm not sure i follow. what abput it doesn't make sense?
23:40:16 <Rotaerk> joneshf-laptop, foo returns an Integral b => b.  This doesn't mean it will be a value of some integral type.  It means it is a value that can be constrained to any integral type
23:40:17 <harel_f> no one names things Foo & Bar in the wild
23:40:27 <Rotaerk> Int can only be constrained to Int, not any other integral type
23:40:35 <kadoban> joneshf-laptop: foo :: Bar -> Integer    should be possible, right?   But it wouldn't be, if it was using your foo' definition.
23:41:11 <Rotaerk> :t 5
23:41:12 <lambdabot> Num a => a
23:41:38 <Rotaerk> that means 5 can be constrained to any numeric type, not that it is a specific-but-unknown numeric type
23:41:50 <Rotaerk> (there's probably a more formal way of expressing what I'm saying...)
23:41:56 <kadoban> joneshf-laptop: In other words … foo needs to be able to result in /any/ Integral. You've only told it how to result in Int
23:42:26 <joneshf-laptop> oh!
23:42:32 <kadoban> joneshf-laptop: So what if the caller wants anything else? Then it's totally boned. So it doesn't typecheck (this is obviously totally informal description)
23:42:33 <joneshf-laptop> kadoban, Rotaerk thanks
23:43:00 <Rotaerk> foo's signature suggests this is allowed:  foo (Bar blah) :: Integer
23:43:08 <Rotaerk> but if it's returning an Int, that wouldn't work
23:43:32 <kadoban> harel_f: But they do in testcases :)
23:43:47 <Rotaerk> and NOW bed time..
23:45:19 <ElMoloko> :t return
23:45:20 <lambdabot> Monad m => a -> m a
23:45:35 <harel_f> :t data
23:45:37 <lambdabot> parse error on input ‘data’
23:45:42 <harel_f> :t data Bar
23:45:43 <lambdabot> parse error on input ‘data’
23:46:23 <kadoban> harel_f: 'data' is syntax, it doesn't have a type.
23:46:27 <srhb> harel_f: data is not a regular function in Prelude to the best of my knowledge. :)
23:46:55 <harel_f> exactly
23:51:23 <ElMoloko> huh so why is cps not used for exceptions (well rather not an entry on that list?)
23:53:42 <nak> guys
23:53:47 <nak> this is unbelievable 
23:53:59 <nak> the fact that (+5) is a function in haskell is just blowing my fricken mind right now
23:54:10 <nak> i love it
23:54:41 <kadoban> :)
23:55:44 <HEGX64> nak: and (+) is a function that takes a number and returns another function
23:56:16 <srhb> nak: And (5+) is another, different function! Though it's more fun with non-commutative operators
23:56:42 <tejing> nak: (x:) is a handy one
23:57:37 <nak> srhb can you explain (to a noob like me) how (5+) differs from (+5) ?
23:57:39 <ElMoloko> and 5 is a function! :O
23:57:52 <srhb> > (/2) -- nak
23:57:54 <lambdabot>  <Double -> Double>
23:57:55 <srhb> Er
23:57:59 <srhb> > (/2) 1 -- nak
23:58:00 <lambdabot>  0.5
23:58:01 <srhb> > (2/) 1 -- nak
23:58:02 <lambdabot>  2.0
23:58:03 <kadoban> nak: Only in argument order … which for (+) doesn't really matter.
23:58:33 <srhb> nak: They are called operator sections and the "missing side" is what you'll be applying your function to afterwards. :)
23:58:47 <nak> srhb interesting. is that only possible for infix functions then?
23:59:07 <nak> tejing not sure what (x:) does
23:59:15 <srhb> nak: No, you can section regular functions with (`foo` rightArg) or (leftArg `foo`)
23:59:54 <srhb> nak: `foo` makes any regular function infix. :)
