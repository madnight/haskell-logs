00:03:32 <frerich> NateUni: I may be dense, but - if 'x' and 'y' are velocities, shouldn't the new coordinates be e.g. 'a + t * x'  instead of 'a + (1/t) * x'? Using the reciprocal means that the particle moves a smaller distance the more time elapsed, no?
00:04:13 <NateUni> it should be t/1 (I had it the wrong way around).. 
00:04:30 <NateUni> as velocity is m/s
00:04:55 <frerich> Right, and 't/1' is 't'.
00:05:00 <NateUni> and the float passed in will be measured in seconds (or factions of)
00:05:25 <NateUni> which can just be t
00:05:27 <NateUni> lol
00:05:29 <NateUni> sorry.. 
00:05:43 <NateUni> silly trying to figure it all out ;p
00:07:13 <frerich> NateUni: IIRC velocities (at least in physics) are commonly denoted by a 'v', e.g. 'vx' and 'vy'.  It might be nice to use those terms, because then you could change a/b to x/y, and thus have 'move c v = c + v * t' and 'Point (move x vx) (move y vy)'.
00:07:39 <frerich> Just a minor idea.
00:08:23 <NateUni> noted.. thanks.
00:09:57 * hackagebot bitcoin-script 0.9.0 - Compilation, manipulation and decompilation of Bitcoin scripts  http://hackage.haskell.org/package/bitcoin-script-0.9.0 (solatis)
00:09:57 * hackagebot bitcoin-script 0.9.1 - Compilation, manipulation and decompilation of Bitcoin scripts  http://hackage.haskell.org/package/bitcoin-script-0.9.1 (solatis)
00:30:36 <NateUni> Not in scope: data constructor ‘Position’??
00:31:00 <NateUni> I have loaded the file with the decloration in it, I dont understand what is wrong?
00:32:56 <NateUni> anyone :(
00:34:03 <mauke> NateUni: what's in the file? (put in on lpaste.net)
00:34:10 <mauke> and what command did you use to load the file?
00:36:42 <NateUni> :l
00:39:03 <mauke> hello?
00:41:02 <NateUni> Sorry
00:41:25 <NateUni> I was trying to build a point like (Point x y)
00:41:42 <NateUni> hence the error.. 
00:42:05 <NateUni> gets a little confusing in haskel
00:42:09 <NateUni> *ll
00:42:25 <mauke> are you completely ignoring what I said?
00:42:50 <frerich> NateUni: Sorry, maybe I caused that confusion: my understanding was that you have a type 'Point' (with a data constructor of the same name). If 'Point' is just an alias (something you define like 'type Point = ...') for a tuple of numbers, then you can use '(x, y)' instead of 'Point x y'.
00:43:12 <NateUni> ahh ok bingo.. 
00:43:17 <frerich> NateUni: I think it would be a good idea to read up on the differences between 'data', 'newtype' and 'type.
00:43:27 <NateUni> hence why i was baffled to get it to compile.. 
00:43:32 <NateUni> ok will do now.
00:44:01 <frerich> You're up for a really bumpy ride if you don't have a good understanding of how to define types (or type aliases) in Haskell, since types are a pretty big thing in Haskell.
00:44:36 <NateUni> ok.. I will hit RWH now on the subject. 
00:44:58 <NateUni> Thanks for the pointers.. 
00:46:35 <gfixler> I found learning them was easy, but learning why I learned them was hard
00:46:36 <whiteline> t
00:48:03 <NateUni> lol
00:48:14 <jle`> anyone know a way i can branch on if a number is positive or negative with only a Num constrant
00:48:22 <NateUni> thanks again frerich
00:48:34 <arkeet> jle`: you can't.
00:48:44 <jle`> i want to have x if y is non-negative and -x if y is negative
00:48:46 <jle`> darn.
00:48:59 <arkeet> do x and y have the same type?
00:49:02 <jle`> yes
00:49:05 <arkeet> you could multiply by signum y
00:49:11 <arkeet> or divide
00:49:11 <jle`> yes but that'll zero it out if y == 0
00:49:14 <quchen2> You can hack something with Eq and Num, a la "if abs x == x"
00:49:19 <arkeet> well 
00:49:31 <arkeet> sounds like you should think about what you're doing.
00:49:33 <jle`> yeah, bac in the old days i could do it because Eq was a superclass of Num i think
00:49:58 <arkeet> there are various instances of Num that don't have a good notion of positive/negative.
00:49:59 <jle`> yeah, just wondering if there were any tricks.  i am trying to avoid adding another constrait to a whole bunch of library functions
00:50:05 <arkeet> such as complex numbers
00:50:14 <jle`> good point.
00:50:17 <arkeet> or integers modulo m
00:50:18 <frerich> jle`: You could use 'abs x == negate x' ,which is True for negative values
00:50:37 <merijn> jle`: The report demands Eq and Show are Num superclasses, but GHC is purposefully ignoring the report on that
00:51:04 <jle`> well then
00:51:05 <arkeet> or functions. those can make perfectly good Num instances.
00:51:09 <arkeet> (now that Eq/Show aren't needed.)
00:51:20 <jellie> jle`: Hey human.
00:51:23 <jle`> thanks all.
00:51:24 <frerich> jle`: Sorry, I missed the (==), ahem.
00:51:41 <jle`> hey jellie :)
00:51:57 <jle`> i was able to remove a Floating constraint...but i'd rather have one Floating constrant than two constraints on Num and Eq
00:52:33 <jle`> i guess i just need to remember what it is i'm actaully triyng to state...and cases where it doesn't make any sense
00:52:49 <arkeet> what are you actually trying tod o?
00:52:50 <jle`> it's just an aesthetic thing v.v
00:53:50 <jle`> well, i have a pair of expected value + variance, and i am applying functions to it to get a new expected value and new variance, along with its covariance to the original pair
00:55:00 <jle`> for negate it's simple... (x, vx) goes to (negate x, vx), and the covariance between a value and its negated self is -vx, or perfect anticorrelation
00:55:34 <arkeet> ok
00:55:39 <arkeet> so where you you need this thing
00:55:40 <jle`> for abs it's a bit trickier, (x, vx) should go to (abs x, vx) (if we ignore x close to zero), but the covariance between the value and its abs'd self will be vx (perfect correlation) or -vx, perfect anticorrelation
00:55:51 <jle`> oh, it's a library that exports this functinoality
00:55:58 <jle`> so it's kind of the end-goal here, heh
00:55:58 <arkeet> sounds like you shouldn't ignore x close to zero.
00:56:13 <arkeet> or just multiply by signum x
00:56:33 <jle`> it's a calculator that lets you propagate experimental error with correlated samples
00:56:56 <jle`> yeah, signum x would work if only for the 0 behavior.
00:57:33 <arkeet> I would expect that if E(X) is zero, then the correlation between X and abs(X) is about 0.
00:57:47 <jle`> oh
00:58:00 <jle`> hm
00:58:02 <arkeet> (it is zero if the distribution is symmetric)
00:58:53 <jle`> i totally believe you but i'm going to do some math to verify too
00:58:59 <jle`> if that's the case then thanks :)
00:59:11 <arkeet> because it's equal to the correlation between -X and abs(-X)
00:59:16 <arkeet> and X and -X have the same distribution
00:59:33 <arkeet> or something
01:00:37 <arkeet> having abs and signum in Num kind of sucks.
01:00:56 <arkeet> okay I'm sleepy bye
01:01:08 <jle`> yeah, but it's suitable for hacks like these ^_^
01:01:11 <jle`> night
01:02:56 <jle`> if we consider the negative errors, they have an expected dx*dy of -k...and if we consider the positive errors, they have an expected dx*dy of k...so if we conside rall errors, for a symmetric distribution, the expected dx*dy should be (-k + k)/2...or 0...
01:03:00 <jle`> ...seems legit to me
01:04:08 <jle`> now...defining this for `signum` more or less makes no sense at all v.v
01:25:56 <NateUni> If I am using map, to map a function that takes to parameters.. how do I choose which of the two parameters comes from the list?
01:26:09 <NateUni> *takes TWO params
01:26:28 <gfixler> NateUni: you don't
01:26:28 <NateUni> Not sure if that is clear?
01:26:32 <gfixler> :t map
01:26:33 <lambdabot> (a -> b) -> [a] -> [b]
01:26:41 <gfixler> the function given to map is (a -> b)
01:26:56 <gfixler> it has to take a value of one type and return a value of a [possibly different] type
01:27:28 <gfixler> in other words, you can't give map a function that takes two parameters
01:27:36 <gfixler> do you know about currying?
01:27:42 <NateUni> yeah.. 
01:27:47 <gfixler> and partial application?
01:27:54 <NateUni> That is what I am trying to figure out. 
01:27:57 <gfixler> ok
01:28:33 <NateUni> my function returns the effect that b has on a. 
01:28:58 <gfixler> what's the type?
01:29:08 <NateUni> one sec.
01:29:25 <NateUni> Particle -> Particle -> Accel
01:29:50 <NateUni> which is just Point -> Point -> Point
01:29:58 <gfixler> have you heard that in Haskell, all functions are functions of one argument?
01:29:59 <NateUni> (x,y)
01:30:03 <NateUni> yes
01:30:08 <gfixler> and that makes sense?
01:31:13 <NateUni> Yes..not sure I can describe it correcty but I just think of it as the function grabs an argument and then is applied to the next
01:31:30 <jle`> > map show [1..10]
01:31:31 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10"]
01:31:33 <NateUni> which with currying means you can pass functiosn around and effect lists etc
01:31:43 <gfixler> basically - your function takes a Particle and returns a function with type (Particle -> Accel)
01:31:50 <NateUni> map (+ 5) [1,2,3]
01:31:54 <NateUni> kind a deal
01:32:01 <gfixler> yeah
01:32:13 <jle`> you can use a lambda if you want to explicitly say
01:32:23 <jle`> map (\x -> foo x 10) [1..10]
01:32:25 <gfixler> so you can map (f p) over a list of ps to get as
01:32:37 <gfixler> where p = particle, a = accel
01:32:50 <NateUni> ..yep
01:33:05 <gfixler> NateUni: were you wondering how to change the order of the args?
01:33:16 <NateUni> but with force
01:34:16 <gfixler> NateUni: there is flip
01:34:17 <NateUni> I was for eg.. to do force(a,b), force(a,c), force(a,b), force(a,d).. from a list of [a,b,c,d]. where all the list is applied to a. I am trying to figure out if that is working correctly.
01:34:17 <gfixler> :t flip
01:34:18 <lambdabot> (a -> b -> c) -> b -> a -> c
01:34:45 <jle`> `map (\x -> foo x 10)` is like `map (flip foo 10)`.  or map (`foo` 10) if you like to roll that way
01:34:51 <NateUni> since the second arg influences the next in force
01:34:57 * hackagebot bitcoin-tx 0.9.0 - Utility functions for manipulating bitcoin transactions  http://hackage.haskell.org/package/bitcoin-tx-0.9.0 (solatis)
01:35:52 <NateUni> let me sus out flip for a sec brb
01:35:58 <gfixler> NateUni: are you trying to choose a new ordering of the list while mapping?
01:37:00 <NateUni> not sure.. I am still figuring out how mimic what I want to do on paper in haskell
01:37:27 <NateUni> sorry if that seems stupid .. I am still coming up to seepd
01:37:32 <NateUni> *speed
01:38:34 <gfixler> NateUni: not stupid - fighting to figure out what you actually want to do in the first place is the norm, IMO :)
01:38:53 <NateUni> See map (force a) aList kind of does what I want backwards.. as it applieds a to the list. I want to apply the list to a 
01:39:12 <NateUni> No I meant the my retarded haskell questions
01:39:14 <gfixler> fold, perhaps?
01:39:30 <NateUni> :t fold
01:39:31 <lambdabot> (Foldable t, Monoid m) => t m -> m
01:39:32 <gfixler> do you want to keep taking the next item out of the list and merging it somehow into an accumulation?
01:39:47 <gfixler> i.e. start with a, then change it with b, change that with c, etc
01:39:51 <jle`> do you mean something like
01:40:12 <jle`> > map (\f -> f 10) [(*2), (+3), (^2), negate]
01:40:13 <lambdabot>  [20,13,100,-10]
01:40:23 <NateUni> Yes.. and at the end I want a list of vectors that I can tally to get teh net affect on a
01:40:51 <jle`> NateUni: can you state the type of what is is you are looking for?
01:41:04 <NateUni> sure brb
01:41:24 <NateUni> *Simulation> :t force
01:41:24 <NateUni> force :: Particle -> Particle -> Accel
01:42:22 <gfixler> NateUni: where's the list?
01:42:32 <NateUni> I was thinking if I could.. essectially do: [force(a,a), force(a,b), force(a,c), force(a,d)] then sum the components of the vectors 
01:42:56 <NateUni> it is generated outside of my control
01:43:05 <jle`> what is the type of the list you have?
01:43:10 <NateUni> Ints
01:43:13 <gfixler> sum $ map (force a) [a,b,c,d]
01:43:34 <jle`> hm. how are you going to do anything involving force with a list of Ints/
01:43:36 <NateUni> But the issue is with force.. 
01:43:43 <NateUni> Well sorry.. 
01:43:48 <jle`> force can only take particles and return accel's
01:43:59 <NateUni> Points(Float, Float)
01:44:15 <NateUni> My brain is putty from a long long day of study and haskell
01:44:31 <jle`> how about :t on the list you want to run over
01:44:36 <jle`> [Point] ..?
01:44:39 <NateUni> yes
01:44:41 <jle`> [(Float, Float)] ...?
01:44:47 <NateUni>  Float -> [Particle] -> [Particle]
01:44:54 <jle`> what is that?
01:44:57 * hackagebot ideas 1.3.1 - Feedback services for intelligent tutoring systems  http://hackage.haskell.org/package/ideas-1.3.1 (BastiaanHeeren)
01:45:06 <NateUni> data Particle = Particle Mass Position Velocity
01:45:20 <NateUni> Most are just Points.
01:45:34 <jle`> so you have a (Particle -> Particle -> Accel), and you have a [Particle].  and what do you awnt?
01:45:37 <NateUni> just using ‘type’ to make then more readable. 
01:45:52 <jle`> oh. well, what are the type synonyms, exactly?  that would be helpful to understand :)
01:46:41 <jle`> was that correct?  you have a (Particle -> Particle -> Accel), and you have a [Particle], and you want a...?
01:46:52 <NateUni> http://lpaste.net/7588744167312850944
01:47:40 <jle`> ty
01:47:47 <NateUni> I want to get a list of [Particles] get x:xs and then map (force x) xs 
01:48:42 <NateUni> But map applies force x to each of the xs.. I want to apply each of xs onto x with force
01:49:01 <NateUni> thats my big issue.. its kind of backwards
01:49:25 <jle`> what is the final result you want
01:49:29 <jle`> Accel?
01:49:32 <jle`> Particle?
01:49:44 <gfixler> sounds like map (flip force x) xs
01:49:55 <NateUni> yes I want to sum [Accel] 
01:50:09 <NateUni> what is the dealo with flip?
01:50:16 <jle`> you want [Accel] ?  or Accel?
01:50:22 <jle`> what is the *type* of the final thing you want?
01:50:47 <NateUni> Point(x,y) 
01:50:50 <NateUni> Essentially a vector
01:51:05 <gfixler> NateUni: flip f x y == f y x
01:51:07 <NateUni> which tells me the net effect of all the particles on the current particle 
01:51:14 <NateUni> ahh ok. 
01:51:21 <gfixler> NateUni: iow, flip takes a function and gives you a new one that takes the args in reverse
01:51:23 <jle`> Point(x, y) is not a type...(Float, Float) is a type :)
01:51:27 <jle`> Point is a type
01:51:35 <NateUni> :(
01:51:51 <NateUni> where is a gun emoticon ?
01:51:55 <NateUni> lol.. 
01:52:02 <jle`> but that sounds right.  you want an Accel.
01:52:03 <NateUni> (for me)
01:52:07 <jle`> your final result, after all of this, you'll get an Accel
01:52:09 <jle`> is that right?
01:52:38 <jle`> so you have a (Particle -> Particle -> Accel), and you have a [Particle], and you want an Accel.
01:52:56 <NateUni> yeah sounds right
01:53:11 <NateUni> I think I might be confusing the map.. 
01:53:16 <NateUni> brb
01:53:47 <gfixler> it *almost* sounds like a case for a fold1 now
01:54:07 <jle`> how about foo (p:ps) = sum (map (\p' -> force p p') ps)
01:54:09 <jle`> ..?
01:54:29 <jle`> if you want to include the original point too you can do foo (p:ps) = sum (map (\p' -> force p p') (p:ps))
01:55:09 <NateUni> ok let me go have a look. 
01:55:45 <NateUni> But I need to do this for each elements in the list
01:55:51 <jle`> yes, that's what map does
01:55:58 <NateUni> as in how everything effects the accel of everything else
01:56:02 <echo-area> Is `pure` present in 7.8.4?
01:56:14 <jle`> echo-area: yes, but you have to import it from Control.Applicative
01:56:28 <jle`> NateUni: oh.  yeah, you're going to have to refine your algorithm then
01:56:45 <NateUni> yeah ok.. let me go ponder and I will come back..
01:56:52 <jle`> if you can demonstrate the effect of something on, say, three items, we may be able to help with generlaizing it to an arbitrry amount of items
01:57:01 <echo-area> jle`: Okay, thanks.  I'm reading source code of master but using 7.8.4, sometimes this results in trouble like this.
01:57:12 <jle`> like, if you can make it work with (a, a, a), or (a, a, a, a), etc., then we might be able to help generalize it to a list of a's
01:58:44 <NateUni> ok
01:58:53 <NateUni> going back to pen and paper now
01:59:21 <jle`> have fun :)
01:59:24 <jle`> i always do
01:59:58 * hackagebot irc-colors 0.1 - Colourize your IRC strings  http://hackage.haskell.org/package/irc-colors-0.1 (EdwardTjornhammar)
02:01:28 <NateUni> whats the function that allows to you do something with each element of two lists.. eg add the a1+b1 etc
02:01:52 <gfixler> zipWith (+)
02:01:55 <NateUni> yes
02:01:58 <NateUni> ok perfect
02:02:00 <NateUni> brb
02:03:32 <NateUni> No.. maybe not. I cant sums as thet are tuples.. 
02:05:00 <gfixler> zipWith (\(a,b) (c,d) -> (a+c,b+d))
02:08:47 <NateUni> how do I pass a list of points into that
02:09:09 <gfixler> zipWith f wants two lists
02:09:17 <gfixler> in this case, each of points
02:09:45 <NateUni> I just want to tally one list.. all the component pairs
02:09:58 * hackagebot csound-expression-opcodes 0.0.2 - opcodes for the library csound-expression  http://hackage.haskell.org/package/csound-expression-opcodes-0.0.2 (AntonKholomiov)
02:09:58 <gfixler> that's a fold
02:10:18 <NateUni> Point = (x1+x2+x3, y1+y2+y3) etc
02:10:25 <NateUni> :t fold
02:10:26 <lambdabot> (Foldable t, Monoid m) => t m -> m
02:10:36 <NateUni> What is a monad whilst I am here?
02:10:37 <gfixler> not fold, but foldr, or more likely foldr1
02:10:46 <gfixler> NateUni: that's a bit of a big question :)
02:10:48 <NateUni> :t foldr
02:10:49 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
02:11:00 <gfixler> foldr will want a starting accumulator
02:11:06 <ski> (`Monoid' is different from `Monad')
02:11:08 <gfixler> foldr1 will use the first item in the list as the accum
02:11:38 <gfixler> foldr1 (\(a,b) (c,d) -> (a+c,b+d)) points
02:11:40 <gfixler> NateUni: try that
02:11:50 <ski> NateUni : is `(x1+x2+x3, y1+y2+y3)' the expected output ? what is the corresponding provided input for that example ?
02:13:03 <NateUni> no I was just trying to give an exmaple of what I needed from a single list of [(x1,y1), (x2,y2), …] etc
02:13:26 <ski> that's what i was asking for, yes
02:13:46 <gfixler> > foldr1 (\(a,b) (c,d) -> (a+c,b+d)) [(1,2),(3,4),(4,5)]
02:13:47 <lambdabot>  (8,11)
02:14:12 <NateUni> And we have a winner!
02:14:19 <ski> > foldr1 (\(a,b) (c,d) -> (a+c,b+d)) [(1,2),(3,4),(4,5)]    :: (Expr,Expr)
02:14:20 <lambdabot>  (1 + (3 + 4),2 + (4 + 5))
02:14:23 <NateUni> exactly what I am trying to do
02:14:30 <ski> > foldl1 (\(a,b) (c,d) -> (a+c,b+d)) [(1,2),(3,4),(4,5)]    :: (Expr,Expr)
02:14:31 <lambdabot>  (1 + 3 + 4,2 + 4 + 5)
02:14:50 <gfixler> ski: where'd Expr come from?
02:14:54 <NateUni> kudos gfixalot.. thanks I am still learning all the (many) functions that come with haskell
02:15:05 <gfixler> NateUni: I think we all are :)
02:15:09 <ski> gfixler : i just threw it in, to better display what happened
02:15:24 <gfixler> ski: nice - CIS 194?
02:15:42 <ski> no idea whether they mention `Expr' in that course
02:16:04 <ski> iirc, it's in the package `simplereflect', or something like that
02:16:11 <gfixler> ah
02:16:28 <ski> it can sometimes be a nice trick, to see the expressions that some numerical computation builds
02:16:32 <NateUni> yeah but you guys seem to have it all covered.
02:16:58 <gfixler> ski: yeah, you have to create it in the homework for week 5
02:17:10 <ski> oh
02:17:16 <gfixler> http://www.seas.upenn.edu/~cis194/fall14/spring13/hw/05-type-classes.pdf
02:17:17 <NateUni> Any good cheat sheet where all the functions are located? As right now my info is fragmented.. I dont have any place to sift through a list and find what function i am looking for. 
02:17:29 <jle`> :t (\(xs, ys) -> (sum xs, sum ys)) . unzip
02:17:30 <lambdabot> (Num t, Num t1) => [(t, t1)] -> (t, t1)
02:17:31 <gfixler> NateUni: you should learn to use Hoogle - it's a big help
02:17:50 <gfixler> NateUni: for example, when you wanted to know what function adds things from lists together
02:18:08 <NateUni> yeah I do.. but I mean just a one page table which summarise the options.. 
02:18:15 <gfixler> NateUni: you can search for "(a -> b -> c) -> [a] -> [b] -> [c]" - that finds several functions, including zipWith
02:18:29 <ski> NateUni : a good starting point is to figure out the type of the operation you're looking for
02:18:34 <NateUni> ok.. 
02:18:54 <ski> (which is one reason why you need to learn how the types work)
02:18:55 <NateUni> thanks
02:18:56 <gfixler> NateUni: a lot of these are in the Prelude: https://hackage.haskell.org/package/base-4.7.0.0/docs/Prelude.html
02:19:14 <gfixler> which is imported in GHCi, and by default in anything you compile through ghc
02:19:25 <NateUni> jesus thats huge
02:19:39 <jle`> hoogle is probably the best way
02:19:41 <gfixler> NateUni: yep!
02:19:45 <ski> NateUni : do you know about list comprehensions ?
02:19:47 <jle`> if you know you want a list algorithm you can look at the docs for Data.List too
02:19:47 <gfixler> NateUni: there's a nice synopsis thing in the top-right
02:20:30 <NateUni> Nice. thanks guys I really appreciate it. 
02:21:33 <gfixler> just found this: https://hackage.haskell.org/packages/top
02:21:40 <gfixler> people really like parsing
02:21:49 <fread2281> j #nothaskell
02:28:57 <echo-area> I find deducing of programs with unfamiliar concepts using an text editor better than using a pen and paper, because the compiler can help in the process
02:34:54 <Moggle> Hi, dumb question that Google didn't give an immediate answer to: System.Directory does not seem to have a function to return the path to the running executable, what module would have something like that?
02:34:59 * hackagebot network-simple-sockaddr 0.2 - network-simple for resolved addresses  http://hackage.haskell.org/package/network-simple-sockaddr-0.2 (jdnavarro)
02:35:23 <bazqux> memoize :: Memoizable a => (a->b) -> (a->b)
02:35:39 <bazqux>  ^ The second set of parentheses are redundant right?
02:36:08 <bazqux> i.e. One may just as well write: memoize :: Memoizable a => (a->b) -> a -> b
02:36:12 <fread2281> bazqux, yes
02:36:14 <echo-area> bazqux: Yes
02:36:23 <bazqux> Ok. Thanks guys.
02:37:27 <jle`> Moggle: not a dumb question :)
02:37:45 <jle`> you could always look at the 0th command line argument
02:37:54 <jle`> not sure if there's a better way
02:38:37 <Moggle> thanks for the suggestion! that seems reasonable
02:38:48 <jle`> oh
02:39:04 <jle`> it looks like the program name isn't a part of getArgs, it's under getProgName in System.Environment
02:39:05 <Saulzar> So, I've installed ghcjs, and keen to play with reflex. On installing reflex-dom, it somehow depends via it's dependencies on gtk... how does that even work?!
02:39:11 <jle`> and also getExecutablePath :: IO FilePath
02:39:28 <jle`> http://hackage.haskell.org/package/base-4.8.0.0/docs/System-Environment.html#v:getExecutablePath
02:39:50 <jle`> Saulzar: most likely gtk is the backend when you are installing it non-ghcjs
02:40:58 <Moggle> aha
02:41:01 <Moggle> system.environment
02:41:09 <Moggle> thank you veyr much jle`, sorry I couldn't manage to google that
02:41:17 <jle`> no problem :)
02:41:23 <jle`> @hoogle IO FilePath
02:41:26 <lambdabot> Did you mean: :: IO FilePath
02:41:26 <lambdabot> package filepath-io-access
02:41:26 <lambdabot> System.Process.Internals withFilePathException :: FilePath -> IO a -> IO a
02:41:26 <Moggle> on the plus side I did find System.FilePath has a dropFileName function on my own
02:41:35 <jle`> nice :)
02:41:47 <Saulzar> jle`: Hm, interesting..
02:42:03 <jle`> Saulzar: if you installed via ghcjs, maybe it doesn't use gtk
02:42:39 <Saulzar> jle`: I didn't give it the --ghcjs flag, wasn't sure what it would do
02:44:35 <echo-area> @djinn a -> b -> a
02:44:36 <lambdabot> f a _ = a
02:46:14 <shwouchk> Hello
02:47:24 <shwouchk> I can't import the Control.Monad.State module, despite it being documented (here: https://hackage.haskell.org/package/mtl-2.0.0.0/docs/Control-Monad-State.html)
02:47:26 <shwouchk> why?
02:48:12 <jle`> shwouchk: do you have it installed?
02:48:17 <jle`> `mtl`, that is
02:49:05 <frerich> shwouchk: 'I can't import' sounds like you already tried it; in that case, did you get any error message by any chance? That might shed some light.
02:49:19 <shwouchk> jle`: I was under the impression that is was bundled with GHC. I guess I'm wrong then. What do I install then? 'cabal install control.monad.state
02:49:20 <shwouchk> ?
02:49:27 <shwouchk> sorry about the linebreaks
02:49:27 <jle`> the package is called "mtl"
02:49:34 <jle`> so you can do `cabal install mtl`
02:49:44 <jle`> (you can try it out in a sandbox, too)
02:49:45 <shwouchk> ah
02:49:59 <jle`> go to a folder, cabal init sandbox; cabal install mtl; cabal repl -- gives you a ghci in that sandbox
02:50:11 <shwouchk> ah, cool!
02:50:13 <shwouchk> thanks!
02:51:07 <shwouchk> jle`: How could I have found out (other than random googling or asking here) in which package Control.Monad.State is located?
02:51:19 <jle`> if you look at the docs
02:51:25 <jle`> up near the top of the page, it tells you what package it's in
02:52:04 <jle`> "mtl-2.2.1: Monad classes, using functional dependencies"
02:52:16 <jle`> you can also click on the "contents" link at the top right hand corner
02:52:26 <jle`> and it'll give you an overview of the package you're looking at
02:52:36 <shwouchk> aaah, the mtl-2.0.0.0 part...
02:53:01 <shwouchk> jle`: I see, thanks!
02:53:05 <jle`> yeah. although 2.0.0.0 isn't the most recent version...but if you cabal install mtl, it'll find the most recent compatible version automatically :)
02:53:20 <jle`> np!
02:53:51 <shwouchk> :)
02:55:42 <NateUni> Why would this not work? forceConverter :: [Vector] -> Vector
02:55:49 <NateUni> Not in scope: type constructor or class ‘Vector’
02:56:09 <NateUni> type Point     = (Float, Float)     -- Same definitions as... type: Vector    = Point 
02:56:42 <Saulzar> I see ghcjs-dom supports webkit gtk, so I suppose that is what's going on there
02:57:00 <jameseb> NateUni: do you have Vector imported?
02:57:16 <NateUni> yeah import World
02:57:17 <NateUni> import Physics
02:57:35 <NateUni> world has that def from above..
02:57:42 <NateUni> type Point    = (Float, Float) etc
02:59:12 <jameseb> but that doesn't declare Vector, it just declares Point, or do you mean that "type Vector = Point" was on another line?
02:59:43 <NateUni> type Point     = (Float, Float)     -- Same definitions as...
02:59:43 <NateUni> type Vector    = Point   
03:00:04 <echo-area> The implementation of functional programming languages was written in 1987.  Does anyone know how much of it has changed today?
03:00:07 <NateUni> I just tried to minimse the lines for the chat..
03:00:31 <echo-area> The techniques, I mean
03:01:04 <NateUni> I changed it to : forceConverter :: [(Float, Float)] -> (Float, Float)
03:01:22 <NateUni> now I got this: /Users/nathansturgess/Code/Uni/COMP3141/A1/Simulation.hs:17:76:
03:01:23 <NateUni>     Couldn't match expected type ‘Particle’
03:01:23 <NateUni>                 with actual type ‘(Float, Float)’
03:01:36 <NateUni> But I never mentioned particle there.
03:02:16 <jameseb> hard to know what the error is without knowing what the function definition is, could you lpaste it?
03:02:23 <NateUni> yep
03:03:59 <NateUni> http://lpaste.net/1699875419269890048
03:05:48 <ibid> echo-area: the state of the art has moved significantly, but the basics are still valid, i believe
03:06:15 <frerich> NateUni: On a somewhat related note: Something like 'epsilon = 0.001 -- For floating point comparisons' can cause fairly subtle bugs (the epsilon should depend on the magnitude of the values being compared instead of being a fixed value)
03:06:25 <NateUni>  not my code
03:06:47 <NateUni> cant change it either. I just put that there FYI so you could see what was going on 
03:07:06 <echo-area> ibid: Is it a good start book to read on functional compilers?
03:09:43 <jameseb> NateUni: what is the type of force here?
03:10:07 <NateUni> It is supposed to get a vector and add the components
03:10:08 * hackagebot repa-devil 0.3.2.6 - Support for image reading and writing of Repa arrays using in-place FFI calls  http://hackage.haskell.org/package/repa-devil-0.3.2.6 (RaphaelJavaux)
03:14:11 <jameseb> force must take two arguments if (force x) is used as the first argument of map, and it's expecting the first argument of force to be a Particle
03:15:27 <NateUni> but why a particle?
03:15:54 <NateUni> not once do I mention or pass a particle in this function
03:16:04 <NateUni> fuck.. 
03:16:06 <NateUni> ops
03:16:11 <NateUni> of course force..
03:16:13 <NateUni> so tired
03:16:19 <NateUni> … brain dead.. 
03:16:54 <jameseb> force needs to have type Vector -> Vector -> Vector to work there
03:16:56 <ibid> echo-area: i belive so, yes
03:17:15 <ibid> echo-area: or rather, for compilers for lazy functional programs
03:17:45 <echo-area> ibid: Thank you, I am about to read it :)
03:19:10 <stianhj> What is the recommended way of doing Haskell these days. Stackage and cabal sandboxes? I'm on Arch Linux which has ghc 7.10.1 and cabal-install 1.22.2, while Stackage recommends 7.8.4. and 1.18/1.20. Will the newer versions work with Stackage?
03:19:16 <ibid> echo-area: note that it tells you how to compile lazy fp to imperative code.  the standard compilation techniques beyond that are not covered
03:20:22 <echo-area> ibid: Which books do you recommend for those?
03:20:53 <monna> hi, i wanna use try(Control.Exception) to 'ReaderT a IO r'. how can i use it?
03:20:56 <jle`> stianhj: not yet :) but soon
03:21:02 <ibid> echo-area: the dragon book is the standard textbook.  i've also found appel's books useful
03:21:18 <jle`> for the most part i use hackage+sandboxes
03:21:53 <echo-area> ibid: Okay, I'll search.  Thank you once again
03:22:11 <ibid> echo-area: http://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools
03:22:51 <ibid> echo-area: https://www.cs.princeton.edu/~appel/modern/
03:23:31 <stianhj> jle`: i guess i'll just go with the versions in arch for now. thanks
03:24:16 <echo-area> ibid: So nice of you :D
03:24:16 <NateUni> If I have this: let p1 = (Particle 1.0, (1,1), (2,2))
03:24:20 <NateUni> > let p1 = (Particle 1.0, (1,1), (2,2))
03:24:21 <lambdabot>  <no location info>:
03:24:22 <lambdabot>      not an expression: ‘let p1 = (Particle 1.0, (1,1), (2,2))’
03:24:44 <NateUni> How do I get the (1,1)
03:25:09 <jle`> you probably mean Particle 1 (1,1) (2,2)
03:25:15 <jle`> and you can get the (1,1) by patternmatching
03:25:27 <NateUni> from the cmdline?
03:25:28 <jle`> let (Particle _ the11 _) = p1
03:25:38 <NateUni> ok.. thanks
03:26:45 <NateUni> cant do that from the cmdline
03:27:29 <jle`> you have to do it from ghci
03:27:30 <NateUni> I am trying to just do my calls and build them up on the cmdline first.. but unless I can pullout the component then I cant really test it
03:27:40 <jle`> what do you mean by "can't do that"?
03:27:45 <NateUni> i am 
03:27:50 <jle`> is someone next to you stopping you? :)
03:27:54 <jle`> tell him it's ok
03:28:06 <NateUni> ;p
03:28:25 <NateUni> seriously come on toooooo tired
03:28:32 <jle`> no, really, that's a real question ><
03:28:37 <jle`> what do you mean by "can't do that"?
03:28:55 <mauke> sorry, starfox. I can't let you do that!
03:29:13 <jle`> is there an error?
03:29:49 <jle`> if so, what is it?
03:30:08 <NateUni> let (Particle _ the11 _) = p1
03:30:53 <NateUni> It doesnt give me anything
03:31:03 <mauke> it defines the variable the11
03:31:49 <k-u> echo-area: ibid: yeah, appel's compiler book is nice.  the version with code in ML is convenient if you are writing your code in haskell
03:50:10 * hackagebot pdfinfo 1.5.4 - Wrapper around the pdfinfo command.  http://hackage.haskell.org/package/pdfinfo-1.5.4 (ChrisDone)
03:52:39 <Saulzar> Hm, can't manage to get reflex-dom installed... I guess it depends on dev  versions of  ghcjs-dom, which requires ghcjs-base  ... which doesn't compile
03:55:10 * hackagebot pipes-errors 0.2.1 - Integration between pipes and errors  http://hackage.haskell.org/package/pipes-errors-0.2.1 (jdnavarro)
03:56:15 <kosmikus> enojelly: I'm Andres (just sayign because you were asking Cale ...)
03:59:57 <lpaste> Onielfa pasted “Error installing http-conduit” at http://lpaste.net/130637
04:00:28 <onielfa> Can anyone help me installing http-conduit?
04:00:57 <NateUni> I am really stumped with this:
04:01:50 <NateUni> map iterates over a list.. but I need to up pack the elements in a list how do I do that?
04:01:58 <jle`> monna: you might be able to use something from monad-control.  if anything, you can just manually runreader-re-reader
04:02:36 <onielfa> NateUni: what do you mean by packing? Like suming all the elements?
04:03:37 <NateUni> A bs exmaple would be 
04:03:38 <NateUni> map (\x -> (+3) x) [[1,2,3]]
04:03:56 <NateUni> I want to unpack the subtype (list and then do something with it)
04:04:22 <NateUni> map (\x -> (+3) x) [[1,2,3], [4,5,6]]
04:04:27 <NateUni> I dont know how to do it. 
04:04:54 <onielfa> NateUni: so you have a list of list
04:05:08 <onielfa> NateUni: that's what you want to map over, correct?
04:05:50 <NateUni> No ,, I have data Particle = Particle Mass Position Velocity
04:06:48 <onielfa> NateUni: Ok, and what do you have? A list of Particles?
04:07:20 <NateUni> yes and I want to get at the (Float, Float) that are the velocity
04:08:32 <quazimodo> hay hay
04:08:41 <quazimodo> hodapp: 
04:08:47 <onielfa> NateUni: for the moment, forget the map and focus on writing a functions that recieves a Particle and returns its velocity
04:08:59 <NateUni> got that
04:09:07 <onielfa> NateUni: paste it
04:09:16 <NateUni> getVel :: Particle -> Vector
04:09:17 <NateUni> getVel (Particle _ _ v) = v
04:09:31 <onielfa> NateUni: perfect!
04:09:53 <NateUni> this list thing is hammering me. 
04:10:21 <onielfa> NateUni: Now, the list. What do you have? A list of Particles?
04:10:26 <NateUni> I was going on.. till instead of comparing Points I had to deal with the particles and couldnt get to the points
04:10:32 <NateUni> Yes
04:10:44 <onielfa> NateUni: relax! I will help you out :)
04:10:58 <NateUni> My head hurts.. haskell :(
04:11:16 <NateUni> hardskell ; (
04:11:17 <jle`> sometimes it's good to take a break :)
04:11:25 <onielfa> NateUni: haha Your head will explode when you learn it :)
04:11:28 <NateUni> i know.. but i get all obsessive
04:11:35 <pacak> NateUni: Get a helmet.
04:11:37 <NateUni> argh.. want to get it done!!!
04:11:49 <jle`> for me, ghc and haskell enforce me to get rest
04:11:53 <NateUni> :)——>:(
04:11:57 <onielfa> Well, so you have a [Particle], right?
04:12:01 <NateUni> yes
04:12:16 <jle`> when i'm not well rested, ghc throws type errors at me, and anything meaningless i write gets caught immediately.  so that's when i know i need to take a break
04:12:17 <onielfa> and whats the output you want?
04:12:32 <jle`> in other languages, if i started writing bad things, i could just go along with it and never even know until 6am
04:12:32 <NateUni> haha i should have rested about 6 hours ago
04:12:33 <NateUni> lol.
04:12:46 <jle`> more type errors = time to sleep
04:12:48 <NateUni> :p
04:13:14 <NateUni> ok onielfa list list list.. 
04:13:18 <NateUni> lisssts
04:14:18 <onielfa> NateUni: what do you want as a result? a [Velocity]
04:14:22 <onielfa> ?
04:15:14 <NateUni> type Point     = (Float, Float)  = Vector = Position  = Point  = Velocity  = Vector  =  Accel
04:15:26 <NateUni> they are all the same .. just so you know. 
04:16:22 <onielfa>  NateUni but tell what you do want to compute
04:16:35 <NateUni> I want to map a function with a Point.. over [Particles].. 
04:16:47 <NateUni> but i need to get the pt out of particles.
04:17:19 <NateUni>  (foldr1 (\(a,b) (c,d) -> (a+c,b+d)) (map (force x) xxs)
04:17:36 <NateUni> where x is the first particle. 
04:17:44 <onielfa> NateUni: so you have a function that works on Point. Paste the type signature
04:17:53 <NateUni> and xxs is the whole list!
04:18:33 <NateUni> : type Point    = (Float, Float)  = Vector = Position  = Point  = Velocity  = Vector  =  Accel
04:19:19 <NateUni> make sense ?! Everything is a point.. except a Particle which contains some points
04:20:10 <onielfa> NateUni: paste the code on http://lpaste.net/new/haskell so we can see it
04:20:11 * hackagebot optparse-simple 0.0.0 - Simple interface to optparse-applicative  http://hackage.haskell.org/package/optparse-simple-0.0.0 (ChrisDone)
04:21:56 <NateUni> You know what I will hit the sack.. thanks guys but I have persisted and have limited results.. which means hit the foundation tomorrow and look at curried functions etc and sort this crap out.
04:21:58 <NateUni> ni night.. 
04:41:46 <Guest41249> I'm looking for  a function like diffDays :: Day -> Day -> Integer  from Data.Time.Calendar but for years?! I cant believe that there is no such function predefined in some library. please help
04:45:32 <lyxia> Guest41249: Wouldn't it just be (-)?
04:46:19 <Guest41249> no, that would give me the difference of days I guess, I need the difference in years
04:58:34 <orbifx> hello all
04:59:11 <orbifx> hello srhb 
05:00:13 * hackagebot Weather 0.1.0.1 - Library for interacting with the Weather Underground JSON API.  http://hackage.haskell.org/package/Weather-0.1.0.1 (bstamour)
05:00:15 * hackagebot hledger-irr 0.1.1.6 - computes the internal rate of return of an investment  http://hackage.haskell.org/package/hledger-irr-0.1.1.6 (JoachimBreitner)
05:01:34 <lyxia> Guest41249: Oh, I misunderstood.
05:04:32 <lyxia> Guest41249: I'm not sure what "difference in years" you are looking for, I can think of at least two: the difference between the years the days belong to, and the difference in days divided by 365.
05:07:24 <kuribas> Not every year has the same length
05:07:29 <kuribas> in days
05:08:30 <Moggle> Is anyone here familiar with mueval? I'm trying to get --load-file=L.hs to work, it's just screaming at me NotAllowed "These modules have not been loaded:\nMuevalInclude\n"
05:08:34 <tdammers> also, not every day has the same length in hours
05:08:43 <Moggle> if there's any obvious things i'm supposed to do in my L.hs, i might be missing them?
05:08:44 <tdammers> and not every hour has the same length in seconds
05:14:15 <Moggle> oh i see you have to export the module
05:14:24 <Moggle> thank you tests.sh for reminding me that unit tests are the best way to comment code
05:14:30 <Moggle> you are the best gwern
05:14:40 <capisce> there is no better gwern
05:15:01 <capisce> https://medium.com/@Shapiro/how-to-correctly-use-punctuation-f8f0c4d44ea9
05:15:27 <capisce> Rule #1: Separate danglers with a comma
05:17:02 <tdammers> like this? "you are the best gw,ern"
05:17:22 <shlevy> capisce: Of course, you're forgetting rule #1 of grammar: The appropriate specific set of grammar rules to use is highly context dependent :P
05:18:16 <kuribas> @hoogle [a] -> (a -> a -> Ordering) -> Maybe a
05:18:19 <lambdabot> Data.List maximumBy :: (a -> a -> Ordering) -> [a] -> a
05:18:19 <lambdabot> Data.List minimumBy :: (a -> a -> Ordering) -> [a] -> a
05:18:19 <lambdabot> Data.Foldable maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
05:18:42 <kuribas> no safe maximum :(
05:19:58 <quchen2> :t let safeMax _ [] = Nothing; safeMax cmp xs = Just (maximumBy cmp xs) in safeMax
05:19:59 <lambdabot> (a -> a -> Ordering) -> [a] -> Maybe a
05:21:00 <kuribas> Shouldn't there be safe alternatives for base functions?
05:21:21 <pacak> kuribas: But there are
05:22:37 * frerich thinks it would have been nicer to have a 'NonEmpty a' in the base package instead of having all 'safe' functions return a Maybe.
05:22:58 <kuribas> frerich: how would that work?
05:23:16 <quchen2> safeMax :: NonEmpty a -> (a -> a -> Ordering) -> a
05:23:32 <frerich> Right.
05:23:45 <quchen2> where data NonEmpty a = a :| [a]
05:24:27 <kuribas> :t (:|)
05:24:28 <lambdabot>     Not in scope: data constructor ‘:|’
05:24:28 <lambdabot>     Perhaps you meant one of these:
05:24:28 <lambdabot>       ‘:+’ (imported from Data.Complex),
05:24:44 <pacak> There's safe version of head for example...
05:24:44 <pacak> Prelude Unsafe.Coerce> maybe "Nothing here" id (unsafeCoerce [])
05:24:44 <pacak> "Nothing here"
05:24:44 <pacak> Prelude Unsafe.Coerce> maybe "Nothing here" id (unsafeCoerce ["foo", "bar"])
05:24:44 <pacak> "foo"
05:25:14 <frerich> pacak: It is a little ironic to define a 'safe' function in terms of a function with 'unsafe' in the name.
05:25:52 <quchen2> In general that's not ironic, and the purpose of unsafe functions.
05:26:02 <quchen2> In the example it's not useful at all.
05:26:20 <pacak> frerich: Bbbbbuuuuttt.... It works. Also if you understand why exactly it works - it helps to write better code.
05:26:28 <quchen2> Unsafe functions allow you to cheat the type system if you really need to, in order to write safe wrappers.
05:26:56 <frerich> True, now that I think about it, if there's one point for the existence of unsafe functions, it's for them to be used for defining safe functions.
05:27:33 <kuribas> :t listToMaybe
05:27:34 <lambdabot> [a] -> Maybe a
05:27:45 <kuribas> listToMaybe == safe head
05:28:06 <pacak> Basically the same as unsafeCorece in my example. Just boring version.
05:28:09 <quchen2> pacak's example is a bad use of unsafeCoerce, since it relies on the order of list's data contructors.
05:28:11 <kuribas> > listToMaybe [1..]
05:28:13 <lambdabot>  Just 1
05:28:40 <kuribas> pacak: boring is good
05:28:54 <quchen2> You change the order of the constructors, code breaks magically. unsafeCoerce is safe to use if you know your data is represented the same way, not when it "happens to be" so.
05:29:54 <kuribas> :t unsafeCoerce
05:29:55 <lambdabot> Not in scope: ‘unsafeCoerce’
05:30:06 <quchen2> unsafeCoerce :: a -> b
05:30:07 <frerich> kuribas: It's basically a -> b
05:30:15 <pacak> a -> b
05:31:01 <exio4> I can only think of two reasons to use unsafeCoerce, breaking abstractions and weird type hackery 
05:31:17 <exio4> would there be any other reason to use it? 
05:31:26 <kuribas> Wouldn't it be possible to have a type of bottom that would give a warning by the compiler?
05:32:02 <pacak> Weird type hackery is fun. Also a while ago I think it was the only way to write safeCorce :: Coercible a b => a -> b
05:32:28 <c_wraith> exio4: well, before coerce was added, unsafeCoerce was sometimes significantly more efficient..  O(1) instead of O(n)
05:33:04 <quchen2> exio4: That "weird type hackery" is how GHC implemented typeclasses, SPJ talks about it in his umm talk about roles
05:33:37 <kuribas> For example (\a -> case a of {[] -> 0; a -> head a}) => no warning, but (\a -> head a) => warning ?
05:34:03 <tar_> Anyone know what library do & and .~ come from in https://obsidian.systems/reflex-nyhug/#/step-14 ?
05:34:17 <quchen2> Lens.
05:34:20 <tdammers> tar_: if in doubt, lens
05:34:24 <exio4> pacak: didn't say it wasn't fun!
05:34:27 <frerich> kuribas: You could have 'case a of (x:_) -> x' and exploit that the warning can detect incomplete pattern matches
05:34:30 <tar_> sweet, thanks
05:35:07 <tdammers> tar_: also, try hoogle and/or hayoo
05:35:18 <tar_> hoogle says "No results found" for .~
05:35:20 <pacak> tar_ & -- flip $, .~ -- a nice reason to hate lens.
05:35:28 <exio4> c_wraith: hm, which changes?
05:35:34 <tdammers> :t (.~)
05:35:35 <lambdabot> ASetter s t a b -> b -> s -> t
05:35:39 <kuribas> frerich: yes, but that's more verbose.
05:35:50 <tar_> Hayoo's got it!
05:35:54 <quchen2> tar_: And when lens operators confuse you, maybe this is helpful. https://github.com/quchen/articles/blob/master/lens-infix-operators.md
05:36:12 <c_wraith> exio4: when https://hackage.haskell.org/package/base-4.8.0.0/docs/Data-Coerce.html was added, it took care of a significant previous use case for unsafeCoerce
05:36:14 <frerich> kuribas: As soon as you use 'head', you're out of luck since the type of 'head' claims that any list (including empty ones) is fine.
05:36:15 <pacak> There's like 100500+ of those perl-like things...
05:36:48 <kuribas> What I mean is, that if you use a partial function, the compiler will give a warning if it figures the it may give a runtime error, but no warning if it proves it cannot.
05:36:49 <tar_> quchen2: thanks!
05:37:23 <kuribas> Basicly so that you can use partial functions like head, but with a static guarantee of correctness.
05:37:30 <tdammers> pacak: it is often said that Lens turns Haskell into a different language...
05:38:14 <exio4> c_wraith: but how did it change the current behavior of unsafeCoerce?
05:38:33 <c_wraith> exio4: it didn't.  It just meant there was a safe alternative for solving the same problem
05:39:53 <exio4> c_wraith: ah, thought it meant unsafeCoerce was even more magic now :P 
05:40:15 * hackagebot uulib 0.9.20 - Haskell Utrecht Tools Library  http://hackage.haskell.org/package/uulib-0.9.20 (PhilippHausmann)
05:40:39 <c_wraith> exio4: actualy, coerce is way more magical than unsafeCoerce.  The unsafe variety is just telling the compiler "trust me, I'm infallible".  The safe variety is actually checked. :)
05:40:42 <c_wraith> *actually
05:42:35 <exio4> c_wraith: yeah, that's what I thought heh, "unsafeCoerce now does what?" 
05:44:30 <frerich> Hm, is there a way (maybe some TH function) which takes care of creating Arbitrary instances, such that given e.g. 'data T = T Int Int' I could write 'makeArbitrary ''T' and get 'instance Arbitrary T where arbitrary = T <$> arbitrary <*> arbitrary'?
05:45:31 <frerich> I'd have thought there's a way to derive them somehow...
05:46:40 <frerich> Aha, http://hackage.haskell.org/package/derive-2.5.22/docs/Data-Derive-Arbitrary.html has it
05:47:51 <c_wraith> frerich: oh, I just tracked that down.  I was a bit slow, apparently
05:48:07 <frerich> c_wraith: The implementation of it is a bit scary. :)
06:20:17 * hackagebot pipes-p2p 0.4 - P2P network nodes with pipes  http://hackage.haskell.org/package/pipes-p2p-0.4 (jdnavarro)
06:25:19 <phaazon> hey
06:25:26 <phaazon> I've built a netwire like library
06:25:29 <phaazon> and I have a problem
06:25:40 <phaazon> I need to « copy » a reactive value
06:25:54 <phaazon> because otherwise, and getting back to the value, its time isn't reset
06:31:36 <phaazon> @index pseq
06:31:37 <lambdabot> GHC.Conc
06:32:04 <phaazon> @index seq
06:32:04 <lambdabot> Prelude, Control.Parallel
06:42:38 <SrPx> Hello, how do I implement an interval on IO? That is, some action that happens each n milliseconds?
06:45:53 <tdammers> SrPx: what kind of precision do you need?
06:46:26 <SrPx> ms precision, actually this just solved my problem: https://gist.github.com/saml/3640892
06:46:44 <SrPx> but if is an alternative without adding that code ... 
06:46:57 <SrPx> there is*
06:47:35 <tdammers> well, the thing is, with the thread delay based approach, you'll always get "specified delay plus however long it takes to run the action"
06:48:00 <rasen_> Hi!
06:48:01 <tdammers> if you need the thing to be accurate over a longer period, you'll have to sync against a RTC from time to time or something like that
06:48:20 <SrPx> ah I know, I don't at all :) just wanted to visualize the plot of a 2d function on the cartesian plane 
06:48:42 <SrPx> with time changing params
06:49:55 <tdammers> ah ok
06:49:56 <rasen_> If I use interact, will GHC make my program parallel? (one lightweight thread for reading input, second one for doing real work) Or application will be blocked for every I/O call?
06:50:08 <tdammers> in that case, thread delay is more than good enough
06:50:16 <SrPx> but that makes sense, thanks :) 
06:54:36 <bergmark> rasen_: you can run background threads in ghci
06:55:19 * hackagebot static-canvas 0.2.0.1 - DSL to generate HTML5 Canvas javascript.  http://hackage.haskell.org/package/static-canvas-0.2.0.1 (jeffreyrosenbluth)
06:58:16 <rasen_> bergmark: this? https://wiki.haskell.org/Background_thread_example
06:59:27 <c_wraith> rasen_: I don't see any benefit in making interact parallel.  It's better to delay an input reading from stdin than use arbitrary amounts of memory.
06:59:53 <pharpend> Morning, everyone
07:03:46 <c_wraith> rasen_: if you delay reading from stdin, it provides a sort of back pressure to whatever's writing to it.  It's an effective form of rate limiting for all but the most demanding of cases.
07:05:19 * hackagebot palette 0.1.0.2 - Utilities for choosing and creating color schemes.  http://hackage.haskell.org/package/palette-0.1.0.2 (jeffreyrosenbluth)
07:06:41 <rasen_> c_wraith: I see. I should do that myself then.
07:18:24 <k_bx> Hi! GHC trac wiki is down. I recall someone asked for volunteers to help with optimizing trac and similar work to help keeping it fast and working. Is this still needed? Who should I contact for that?
07:23:44 <Trubydoor> is it possible to catch segfaults in libraries called using the FFI and translate them into Maybes/some other error reporting mechanism?
07:25:20 * hackagebot binary-list 1.1.1.0 - Lists of length a power of two.  http://hackage.haskell.org/package/binary-list-1.1.1.0 (DanielDiaz)
07:27:25 <merijn> Trubydoor: Maybe
07:27:35 <merijn> Trubydoor: You can install a handler for the SIGSEGV signal on posix
07:28:42 <Trubydoor> hmm... probably easier to do the error checking on the haskell side before calling the function
07:28:59 <srhb> k_bx: Probably the infrastructure channel
07:29:14 <srhb> k_bx: It's also not down, just very slow. :)
07:29:54 <srhb> k_bx: Anyway, #haskell-ops
07:30:09 <k_bx> srhb: thanks, page with info is down also :)
07:30:15 <k_bx> I mean, slow
07:30:33 <fryguybob> k_bx:  #haskell-infrastructure
07:30:45 <srhb> Oh, yeah
07:30:48 <srhb> Sorry, wrong channel from me.
07:32:15 <stianhj> Does http://hackage.haskell.org/package/xss-sanitize-0.3.5.5/xss-sanitize-0.3.5.5.tar.gz work for anyone? I'm getting "Connection reset by peer"
07:32:35 <mpickering> k_bx: the main problem is bots hammering the registration page I thin
07:33:24 <srhb> stianhj: No problem here.
07:37:39 <k_bx> mpickering: if we’re sure this is the case I guess it would be quite easy to think of some solution
07:38:39 <k_bx> stianhj: works for me
07:54:15 <joyfulmantis> is there a way to pattern match on a value in haskell, instead of on function arguments. something maybe like scala's "match"?
07:54:29 <c_wraith> joyfulmantis: case expressions
07:55:06 <c_wraith> case blah of pattern1 -> foo ; pattern2 -> bar ; ...  (where semicolons can be inserted automatically via whitespace)
07:56:00 <tdammers> comprehensions would also introduce a pattern matching context
07:56:18 <joyfulmantis> ah, thanks c_wraith! 
07:56:46 <c_wraith> I always forget comprehensions exist - I never find them useful.
07:57:11 <kuribas> I hardly ever use comprehensions.
07:57:18 <zipper> c_wraith: They are useful.
07:57:27 <zipper> I hardly ever use them but I know they are
07:57:47 <zipper> Almost all the places I use recursion I should replace with comprehensions
07:58:10 <exio4> I normally prefer high order functions 
07:58:24 <exio4> the function application / anonymous function syntax is light enough to not be annoying 
07:58:40 <tdammers> matter of communicating intent, I'd say
07:59:27 <tdammers> also, if you're doing fmap-ish things anyway and want to pattern match without introducing an extra function, comprehensions are nice
07:59:45 <c_wraith> I was mildly hyperbolic there.  But I much prefer higher-order functions.
08:00:26 <tdammers> c_wraith: same here :D
08:00:33 <tdammers> less magic
08:01:12 <c_wraith> I will use a comprehension if I'm doing a product of multiple lists with some complex filtering.  That's about the only thing I've found in practice.
08:02:52 <hodapp> weird, that doesn't make much sense to me... looking at some Ivory source and module 'Foo' exports a function 'lnPragma' inside of #if __GLASGOW_HASKELL__ >= 709, then module 'Bar' imports 'Foo', then 'Baz' imports 'Bar' and makes use of 'lnPragma'
08:03:09 <hodapp> but when I try to build it complains in that last module that 'lnPragma' is out of scope
08:03:21 <hodapp> but, this seemingly only occurs on GHC 7.10, not 7.8
08:05:00 <c_wraith> hodapp: well, at the least, you can say that's really confusing
08:05:51 <MichielDC> Any good resources for beyond-basics-Haskell? I finished LYAH and did some small projects for school (doing Huffman encoding right now).
08:06:10 <hodapp> https://github.com/GaloisInc/ivory/blob/master/ivory/src/Ivory/Language/Syntax/Concrete/QQ/Common.hs#L37 is where it's defined, https://github.com/GaloisInc/ivory/blob/master/ivory/src/Ivory/Language/Syntax/Concrete/QQ/ProcQQ.hs#L32 is the offending block
08:06:45 <ryantrinkle> MichielDC: any interest in GUI stuff?
08:06:54 <bergmark> MichielDC: https://github.com/bitemyapp/learnhaskell
08:07:20 <MichielDC> Interested in everything :D
08:07:37 <hodapp> oh, so I misread that "#if __GLASGOW_HASKELL__ >= 709" include
08:07:45 <hodapp> I guess that's active for GHC >= 7.9
08:07:48 <ryantrinkle> MichielDC: i've got a GUI framework for web, https://github.com/ryantrinkle/try-reflex
08:07:57 <ryantrinkle> i've tried to make it as beginner-accessible as possible
08:08:24 <c_wraith> hodapp: yes, two-digit minor version
08:08:35 <hodapp> ah, so, this code path was simply never taken on GHC 7.8
08:08:40 <ryantrinkle> if you try it out, please send any questions my way (or run them by other people in #reflex-frp :))
08:08:41 <c_wraith> hodapp: correct
08:09:10 <ryantrinkle> MichielDC: there's also a talk at https://www.youtube.com/watch?v=mYvkcskJbc4 and slides at https://obsidian.systems/reflex-nyhug/
08:09:39 <hodapp> so I still don't get how imports work around #if... but I can make it build by importing 'Common' directly, even though it's imported indirectly
08:11:15 <MichielDC> Thanks! I'm in a Haskell User Group at my Uni, but I want to get more practical instead of just learning theory
08:11:28 <ryantrinkle> awesome :)
08:11:30 <ryantrinkle> which school is that?
08:12:19 <MichielDC> University of Leuven, Belgium :) We only have had 3 meetings (one on Isomorphism, one on expression problem, one on recursive data types)
08:15:23 * hackagebot pia-forward 0.1.0.0 - Set up port forwarding with the Private Internet Access  VPN service.  http://hackage.haskell.org/package/pia-forward-0.1.0.0 (EchoNolan)
08:25:23 * hackagebot pia-forward 0.1.0.1 - Set up port forwarding with the Private Internet Access  VPN service.  http://hackage.haskell.org/package/pia-forward-0.1.0.1 (EchoNolan)
08:26:13 <johnw> MichielDC: lots of awesome CS people at Leuven
08:30:59 <jessica_chin> is this the place to learn how to program?
08:32:20 <ski> this is possibly a place to start learning how to program in the programming language Haskell
08:32:27 <Cale> jessica_chin: If you're learning to program in Haskell, then yeah :)
08:32:53 <jessica_chin> ok cool. i want to know the difference between c+ and haskell
08:33:07 <tdammers> jessica_chin: they are different programming languages
08:33:28 <tdammers> jessica_chin: your question is a bit like asking "what is the difference between a tiger and an oak tree?"
08:33:34 <jessica_chin> whats the main pro and con of c+ over haskell?
08:33:38 <jessica_chin> so i can choose
08:33:47 <tdammers> (also, hope you mean "C++", not "C+")
08:34:00 <MichielDC> it's either C or C++ :D C+ is not (yet) existing
08:34:07 <tdammers> indeed
08:34:14 <jessica_chin> ok
08:34:14 <tdammers> and C+= is (thankfully) only satire
08:34:32 <jessica_chin> so c++ is the most advance of those?
08:34:52 <MichielDC> Do you have any history in programming?
08:35:20 <jessica_chin> ive made some levels in little big planet and that has programming
08:35:22 <ski> if you're going to learn programming, you really should realize that you should learn several programming languages. the more different, the better. programming languages based on different basic principles gives you useful different viewpoints on what programming can be, and an arsenal of different ways to attack problems
08:35:41 <jessica_chin> but really i want to learn real programming
08:35:47 <jessica_chin> c+
08:35:52 <jessica_chin> *+
08:36:01 <capisce> this being a Haskell channel, I think you'll find people will recommend Haskell
08:36:21 <slack1256> jessica_chin: http://learnyouahaskell.com/chapters
08:36:27 <jessica_chin> ok
08:36:35 <jessica_chin> in 3 words, whats the best thing about haskell?
08:36:37 <tdammers> jessica_chin: any programming language will do; if you're serious about it, you'll learn several eventually anyway
08:36:59 <Rembane> jessica_chin: Pure, Lazy, Strictlytyped
08:37:12 <jessica_chin> haha
08:37:32 <tdammers> those *are* the key features, really
08:37:54 <MichielDC> Is StrictlyTyped really one of haskell's best? Languages as Java or C++ are Strictly typed too, or am I wrong?
08:38:01 <jessica_chin> which is the one to learn if you want to learn to make something in a week or so?
08:38:11 <jessica_chin> this is important
08:38:25 <tdammers> jessica_chin: why the hurry?
08:38:37 <jessica_chin> i want to make a birthday card for my mom and its soon
08:38:41 <tdammers> ah
08:38:49 <johnw> jessica_chin: if you only have a week, I'd try Python
08:38:52 <tdammers> indeed
08:38:56 <jessica_chin> just a simple image and text under it to email to her
08:39:01 <capisce> jessica_chin: what kind of thing would you like to make?
08:39:01 <jessica_chin> should be easy enough
08:39:12 <ski> jessica_chin : see <http://www.norvig.com/21-days.html>
08:39:20 <tdammers> that doesn't really require any programming at all, does it?
08:39:44 <jessica_chin> well it'd have custom images
08:40:00 <jessica_chin> like of me and her
08:40:19 <jessica_chin> u cant put those into the ones online
08:40:43 <maurer> jessica_chin: Sounds like you just want HTML email.
08:40:46 <maurer> jessica_chin: no programming involved
08:40:48 <tdammers> haha yeah
08:40:57 <oconnore> jessica_chin: these are really good ways to get used to the sorts of problems you run into programming: https://scratch.mit.edu/ and http://processingjs.org/
08:40:59 <jessica_chin> i mean images and text with a border
08:41:00 <tdammers> HTML document, add image, add some CSS
08:41:08 <tdammers> no programming required
08:41:25 <jessica_chin> i dont want it to suck, i definitely want it to have some programming
08:41:30 <oconnore> jessica_chin: both of those, scratch and processing, allow you to do some basic programming tasks and build something quickly
08:41:41 <jessica_chin> ok
08:41:42 <tdammers> jessica_chin: "have programming" doesn't really say anything
08:41:58 <oconnore> jessica_chin: then, once you're comfortable with that, you will find it much easier to learn haskell or c++ (and also know which one you're intersted in)
08:42:00 <f1u77y>  i have problem with taffybar. i have line: `avolume = pollingLabelNew "[vol]" 0.2 (colorize "cyan" "" . show <$> getVolume`, where getVolume is IO Int. but when i add widget avolume to         │ bshelden
08:42:02 <f1u77y>                 | endWidgets, taffybar dosn't show it. what can be the problem
08:42:03 <jessica_chin> doesnt programming add something more?
08:42:19 <jessica_chin> like glitter effects
08:42:23 <oconnore> jessica_chin: sure, those tools are real programming
08:42:29 <jessica_chin> ok
08:42:32 <slack1256> f1u77y: use lpaste.net
08:42:34 <MichielDC> HTML is (sort of) a programming language
08:42:53 <slack1256> f1u77y: irc code of more than 2 lines get mungle up
08:42:56 <jessica_chin> i want the image to turn into a video of me
08:43:12 <jessica_chin> after she looks at it for 3 seconds
08:43:17 <tdammers> jessica_chin: javascript, then
08:43:20 <oconnore> jessica_chin: then come back here :) Haskell, C++, Python, etc is great for doing bigger projects, but scratch and processing are great tools for playing with graphics and learning the basics
08:43:48 <jessica_chin> how can it tell she was looking at it? if she opens it and gets distracted, i dont want the video to play
08:43:58 <jessica_chin> so some eyeball thing w her camera
08:44:17 <f1u77y> http://lpaste.net/130646 
08:44:21 <MichielDC> Don't think you can do that in a few days :p That requires PhD level programming
08:44:21 <oconnore> jessica_chin: you could make a button, "are you ready?"
08:44:30 <jessica_chin> hmm
08:44:35 <slack1256> jessica_chin: easy, easy, one thing at the time
08:44:37 <oconnore> then if she clicks, you play the scene
08:44:42 <jessica_chin> but thats not magical!
08:44:50 <jessica_chin> i want it to take over her computer
08:45:09 <jessica_chin> send emails out to everyone in her address book saying that its her birthday
08:45:14 <jessica_chin> or something like that
08:45:20 <slack1256> it wasn't your birthday?
08:45:28 <nyuszika7h> jessica_chin: that's the definition of spam
08:45:42 <srhb> Less judging, more staying on point.
08:45:46 <jessica_chin> she just doesnt talk about it and i know people care and would say happy bday
08:45:52 <oconnore> jessica_chin: it can be very magical: check some of these out http://processingjs.org/exhibition/
08:46:18 <jessica_chin> those are cool
08:46:24 <jessica_chin> im doing the fish one
08:46:59 <oconnore> nice
08:47:07 <jessica_chin> can you make it so anyone w a webcam from her address book would open a window to her so they could talk to her once she clicks "im ready"?
08:47:14 <jessica_chin> all at once
08:47:28 <oconnore> jessica_chin: yes, but that would be a very big project, longer than a week
08:47:36 <jessica_chin> shoot
08:48:19 <jessica_chin> im thinking way outside the box here
08:49:11 <capisce> jessica_chin: are you sure she would be happy if everyone in her address book was suddenly staring at her when she's at her computer? :D
08:49:26 <jessica_chin> i think it would be memorable
08:49:32 <capisce> definitely
08:49:50 <dfeuer> Wow, I didn't even realize I was disconnected. No wonder jessica_chin was not responding to me!
08:49:57 <jessica_chin> hey
08:50:21 <dfeuer> I saw (and answered) your initial question, but it seems that must have been overtaken by events.
08:50:54 <jessica_chin> my initial idea is to have her computer sing a song to her that she fills in the blanks, and it takes her words and sings it back to her in harmony
08:51:21 <jessica_chin> and have all her friends sing too, or at least take what theyre saying it and turning it into verses in the song as they say it
08:51:32 <jessica_chin> all at once
08:51:46 * dfeuer shakes his fist at the fact that containers is right about the bottom of the module hierarchy, and more strongly at the fact that Data.Sequence does not offer a Data.Sequence.Internals.
08:52:00 <capisce> that is a pretty huge project
08:52:00 <capisce> you might have to learn programming for several years to be able to do that
08:52:03 <capisce> but hey, there's a birthday each year
08:52:24 <jessica_chin> i definitely want it to be this year's
08:52:31 <jessica_chin> and ill pay to make it happen
08:52:44 <capisce> well, then you might want to lower expectations a bit
08:53:01 <jessica_chin> you dont turn 60 every year
08:53:32 <oconnore> jessica_chin: I think you should start small. Go build some projects and then improve it as much as you can
08:53:52 <jessica_chin> im serious: ill pay someone here to make this happen in 5 days
08:54:15 <Welkin> jessica_chin: that is likely way out of your budget
08:54:18 <oconnore> jessica_chin: but we all have jobs, and you wouldn't learn any programming :)
08:54:26 <capisce> yeah, but this about webcams and singing isn't something people could easily make happen in 5 days
08:54:40 <jessica_chin> $200
08:54:44 <jessica_chin> paypal
08:54:46 <Welkin> yeah...
08:54:51 <Welkin> you won't get anything for $200
08:54:54 <Ryanar> try $1,000,000
08:54:57 <Welkin> it would be more like $20,000
08:54:57 <jessica_chin> 50% now, 50% once its done
08:55:17 <Ryanar> given that its 5 days, it would be an exorbitant cost
08:55:20 <MichielDC> I know people at uni who work on smaller projects and they take a whole year
08:55:21 <capisce> $200 is one hour, this might require weeks of work
08:55:26 * oconnore was hopeful about this being productive...
08:55:35 <jessica_chin> hmm
08:55:36 <Ryanar> anyways I think we are being trolled
08:55:43 <jessica_chin> isnt 10,000 a little steep?
08:55:44 <MichielDC> +1
08:55:54 <jessica_chin> seriously
08:55:57 <capisce> depends how much work and expertise is involved
08:56:04 <Welkin> no
08:56:08 <capisce> many programming projects go for way more than that
08:56:12 <jessica_chin> i know u go to school for this, but it would also be a really creative project and a lot of fun
08:56:13 <Welkin> $200 per hour is low, actually
08:56:18 <Welkin> especially for an expert
08:56:26 <jessica_chin> and u would get a ton of experience doing it
08:56:39 <MichielDC> I'm still stuck at basic level
08:56:47 <jessica_chin> and be able to put it in your portfolio
08:56:51 <Welkin> anyway, there is a lot you can do on your own with the available tools
08:57:06 <Ryanar> jessica_chin, are you in Richmond?
08:57:17 <jessica_chin> yeah thats weird that u know tho
08:57:26 <MichielDC> Verizon ISP too
08:57:42 <jessica_chin> i guess i shouldnt put up a fireway before i went into a hacker chat haha
08:57:47 <jessica_chin> *firewall
08:57:48 <Ryanar> jessica_chin, im just seeing who you are
08:57:54 <Ryanar> jessica_chin, figure out if we are being trolled
08:58:01 <jessica_chin> well cut it out
08:58:06 <jessica_chin> i want to be anonymous
08:58:11 <Ryanar> too late
08:58:12 <oconnore> Ryanar: at this point I don't think you need to know the isp
08:58:17 <jessica_chin> well what do u know??
08:58:34 <osfameron> jessica_chin: you might find http://popcornjs.org/ useful?
08:58:43 <jessica_chin> this isnt my real name
08:58:45 <Xack> hackerchat lol
08:58:46 <Welkin> jessica_chin: you can do a lot of cool things with existing javascript libraries
08:58:48 <jessica_chin> at least real last name
08:58:50 <osfameron> colleague of mine had a video embedding project to do, thought it was going to be impossible, and found that pretty straight-forward
08:59:08 <capisce> Welkin: https://news.ycombinator.com/item?id=9350563
08:59:27 <capisce> Welkin: are Haskell engineers paid at a higher rate? :)
08:59:28 <jessica_chin> seriously, what did you look up?
08:59:51 <Welkin> capisce: not that I have seen
08:59:58 <Welkin> capisce: most programmers are not paid enough
09:00:09 <capisce> jessica_chin: people can easily find their own projects to work on, why should they work on yours practically for free?
09:00:17 <Welkin> you can easily make double or triple working as a freelancer/consultant
09:00:17 <jessica_chin> its not for free
09:00:31 <osfameron> wow, if I contract, I charge about 400GBP/day (so ~$75 an hour) but I guess it depends on your location and skills
09:00:32 <jessica_chin> it's $200-300 for a few days work
09:00:34 <ReinH> jessica_chin: $200 is so little it might as well be for free
09:00:42 <Welkin> osfameron: no, it depends on your clients
09:00:43 <capisce> I can certainly agree with that
09:00:54 <jessica_chin> well when i asked a reasonable price, i got thousands and thousands so
09:00:58 <jessica_chin> u arent getting any more
09:00:58 <Welkin> a $50/hour programmer is not any worse than a $500/hour one
09:01:02 <Welkin> the difference is in the client
09:01:23 <ReinH> jessica_chin: There's no way that you can know whether it would be a few days work or a few weeks work or impossible
09:01:27 <Welkin> also, contract work is not the same as a consultant
09:01:28 <osfameron> Welkin: to some extent, yes.  anyway, location is part of that.
09:01:32 <jessica_chin> well the deadline is a week, so
09:01:33 <slack1256> jessica_chin: I would learn by myself. It is more meaningful that wy
09:01:34 <ReinH> In the real world, jobs like this frequently cost thousands and thousands
09:01:35 <Xack> (175813)    jessica_chin │ u arent getting any more
09:01:39 <capisce> jessica_chin: then maybe you should put a bid out on freelancer.com and see if there are any takers
09:01:41 <srhb> This talk is drifting off Haskell topics very quickly.
09:01:43 <Xack> jessica_chin: then you have to do it yourself.
09:02:08 <Ryanar> Anyways guys -> I have a question about continuation passing style in Haskell, I am kind of confused as to how it would be implemented for different functions, like lets say I am trying to sum numbers through a list, I am struggling to conceptualize how that would work
09:02:09 <jessica_chin> xack, i can do it myself, but i'd rathera professional do it since i dont know how to access webcams from a email address book
09:02:13 <jessica_chin> at least not yet
09:02:24 <Xack> but that's like
09:02:25 <ReinH> :t flip ($)
09:02:26 <lambdabot> a -> (a -> c) -> c
09:02:34 <Xack> getting somebody else to get her flowers or something
09:02:48 <Xack> you should make it yourself, not get somebody else to do it
09:03:05 <jessica_chin> i have the idea, which is already a lot of work
09:03:10 <jessica_chin> i came up with this
09:03:50 <ReinH> "i have the idea, which is already a lot of work" surely this is a troll
09:03:54 <slack1256> @slap lambdabot
09:03:55 * lambdabot slaps lambdabot with a slab of concrete
09:03:57 <Xack> ReinH: yup
09:03:58 <slack1256> nice
09:04:05 <Xack> lol
09:04:05 <Ryanar> jessica_chin, can you please go somewhere else, you won't find anyone here to do what you want given the money you are offering, this isn't the place for what you are asking anyways, your arguments and logic are all pretty flawed (the idea is 90% of the work), please just stop
09:04:14 <johnw> Ryanar: continuation passing style is when, instead of returning a value, you take as an argument a function to call which accepts that valu
09:04:29 <Xack> hm.. i should really continue reading up on monads
09:04:36 <Xack> i've been in this chan for a while
09:04:38 <johnw> so, instead of a -> b, you have a -> (b -> c) -> c
09:04:42 <jessica_chin> well i guess this is what happens when a girl talks to programmers
09:04:52 <Ryanar> jessica_chin, gross inaccuracy
09:04:57 <ReinH> eww
09:04:58 <Xack> great now she's playing the sexism card
09:05:11 <lolisa> jessica_chin, I am just gonna say that this isn't the place specialized with image or webcam. Go to other channel or website.
09:05:12 <ReinH> I know lots of female programmers, none of whom are idiots
09:05:38 <Xack> my friend (exio4) introduced me to haskell, i've been too busy to read about it
09:05:41 <MichielDC> Xack: typeclassopdia with the articles it links too are really nice
09:05:47 <Xack> MichielDC: thanks :)
09:05:49 <jessica_chin> ok im just freaking out a little because i have so little time
09:05:58 <Xack> jessica_chin: hmm
09:06:00 <jessica_chin> and flowers suck
09:06:07 <johnw> Ryanar: i'd be happy to discuss on #haskell-overflow
09:06:08 <Xack> perhaps, you could try again another year? i know we're not a lot of help
09:06:20 <Xack> sorry, but, if you do it yourself it would be "extra special"
09:06:25 <slack1256> ^ this
09:06:27 <jessica_chin> i know i know
09:06:32 <dfeuer> jessica_chin, really, you only turn 65 once too...
09:06:36 <Xack> again, sorry for not being helpful
09:06:45 <Xack> MichielDC: heh, i like the name :)
09:06:52 <KaneTW> how does that quote go again
09:06:53 <MichielDC> What name? :)
09:06:57 <Xack> typeclassopdia
09:07:02 <jessica_chin> $200 for 1 webcam of her closest friend open when she looks at the image i send her for 5 seconds
09:07:04 <jessica_chin> is that reasonable?
09:07:04 <ReinH> Ryanar: flip ($) is a trivial CPS'd computation that accepts a continuation ;)
09:07:06 <MichielDC> Not my invention
09:07:13 <KaneTW> inability to plan on your end does not constitute an emergency of mine
09:07:17 <Xack> was jut saying :)
09:07:17 <johnw> jessica_chin: this isn't a job market, it's just for discussion of Haskell
09:07:20 <ReinH> jessica_chin: This is off topic for #haskell
09:07:24 <Xack> johnw: 
09:07:27 <Xack> oops, sorry, wrong button
09:07:35 <Xack> jessica_chin: you might want to think of something else
09:07:40 <jessica_chin> :(
09:07:40 <capisce> jessica_chin: try on freelancer, this problem likely won't require Haskell in any case
09:07:41 <capisce> jessica_chin: freelancer.com
09:07:54 <capisce> jessica_chin: or odesk
09:07:58 <jessica_chin> ok
09:08:03 <KaneTW> twago, too
09:08:05 <ffja> hello all
09:08:17 <ffja> how is everyone doing
09:08:45 <ffja> poop
09:09:01 <ReinH> It must be Monday.
09:09:11 <ffja> anyone else keep shitting themselves?
09:09:23 <ffja> i must have eaten something bad
09:09:24 <KaneTW> no, i think it's just you
09:09:26 --- mode: ChanServ set +o johnw
09:09:27 --- mode: johnw set +b *!~ffja@68-70-91-130.static.kc.surewest.net
09:09:27 --- kick: ffja was kicked by johnw (Kicked)
09:09:27 --- mode: johnw set -o johnw
09:09:34 <schell> ffja: o/
09:09:41 <slack1256> I think we are being posted on some forum or something
09:10:18 <Ryanar> yeah...
09:10:54 <Welkin> god damn it ashton kutcher!
09:10:58 <Welkin> who told him about #haskell?
09:11:07 <Welkin> first it was twitter, now us!
09:12:33 <jessica_chin> haha i feel like penny from the big bang theory
09:13:18 <Xack> jessica_chin: haha
09:13:25 <jessica_chin> you guys are awkward but lovable
09:13:30 <Xack> i felt kinda like that to 4 years ago
09:13:56 <Xack> aww thx :3
09:14:49 <zoug> haskell is driving me crazy
09:14:58 <zoug> just thought i'd share that with you guys
09:15:03 <jessica_chin> what kind of birthday themed program could i get for $200?
09:15:08 <jessica_chin> best case scenario
09:15:12 <srhb> jessica_chin: Still off-topic :)
09:15:14 <Rembane> zoug: No worries. Enjoy! :D
09:15:20 <srhb> jessica_chin: Take it elsewhere.
09:15:20 <Welkin> zoug: after learning haskell, every other language drives me mad, expect haskell
09:15:33 <SrPx> is there any monad with an operation that outputs a value, and an operation that halts, so in the end you have a list? i.e., runMonad :: m a -> [a]
09:15:33 <jessica_chin> i just want friendly advice since u guys have been so good about it so far
09:15:45 <srhb> jessica_chin: It muddles up the channel, so no.
09:15:50 <zoug> Welkin: well maybe it isn't a good idea to learn it then hahaha
09:15:58 <moghedrin> Welkin: That.
09:16:05 <jessica_chin> ITS NOT LIKE THERES A LOT GOING ON HERE ANYWAY
09:16:09 <slack1256> guys, guys remember the zen of /ignore
09:16:39 <capisce> jessica_chin: did you try google for existing birthday card programs you could pay for?
09:16:51 <srhb> capisce: Still off topic...
09:16:58 <Welkin> SrPx: you mean like sequence?
09:17:01 <jessica_chin> yeah capisce, this is a no birthday zone
09:17:05 <Welkin> :t sequence
09:17:06 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
09:17:07 <jessica_chin> no fun, no birthday talk
09:17:13 <johnw> yes, when there is no Haskell being discussed, we prefer things to remain quiet so that newcomers are free to ask questions
09:17:15 <jessica_chin> dont mention cake
09:17:27 <jessica_chin> AND dont be a woman
09:17:31 <slack1256> SrPx: that kind of sounds like a the logict monad or cont monad
09:17:32 <srhb> @ops
09:17:32 <lambdabot> Maybe you meant: pl oeis docs
09:17:32 <nshepperd_> jessica_chin: seriously, stop.
09:17:37 <johnw> no, it's just not a social channel, jessica_chin 
09:17:44 <johnw> despite our being sociable about Haskell-related questions
09:17:56 <geekosaur> there is #haskell-blah for offtopic stuff
09:18:25 <Welkin> damn it geekosaur, you are giving away our secrets
09:18:42 <SrPx> no, like, I write a random walking function such as "walk position = do { output position; walk (next position) }"and "runMonad (walk (0,0))" outputs the list of visited positions
09:19:21 <SrPx> (yea on this case I can write a simple recursive function but it is more complicated)
09:19:22 <srhb> SrPx: I'm not sure what you mean about halting, but the rest sounds like Writer.
09:19:39 <jessica_chin> nobody answered
09:19:42 <SrPx> let me see
09:20:40 <hodapp> jessica_chin: rarely does one answer 'hey guys'; say something more
09:20:50 <jessica_chin> ok
09:21:44 <Ryanar> this is a chat all about "Learn, Teach, or Get out of the Way!", you are falling into the latter category
09:21:53 <jessica_chin> wow
09:21:57 <jessica_chin> writing that one down
09:30:26 * hackagebot sr-extra 1.46.3 - A grab bag of modules.  http://hackage.haskell.org/package/sr-extra-1.46.3 (DavidFox)
09:35:26 * hackagebot sr-extra 1.46.3.1 - A grab bag of modules.  http://hackage.haskell.org/package/sr-extra-1.46.3.1 (DavidFox)
09:36:31 <Lis> hi everyone
09:37:23 <hodapp> hiya
09:46:57 <athan> Is leibnitz equality useful / possible in Haskell? Or Eq instances over functions?
09:47:52 <hodapp> "cabal: out of memory (requested 2097152 bytes)"
09:47:55 <hodapp> well that is not good.
09:48:37 <srhb> hodapp: What version is that?
09:48:53 <hodapp> 1.16.02... wow, I should update that.
09:48:57 <hodapp> this is a DigitalOcean droplet
09:50:10 <marsam> hodapp: iirc, you need to add a swap space
09:50:27 <hodapp> marsam: yeah, I'm in the process now. It's only a 512 MB RAM droplet.
09:50:30 <srhb> hodapp: There used to be a bad leak, and that might be it.
09:51:13 <johnw> sometimes when a Haskell app hasn't responded in a while and I look at memory usage, I realize that 96G and growing is a sign of a tiny leak
09:51:45 <hodapp> johnw: it's not a bug, you just need more RAM.
09:51:55 <hodapp> at least, that's what I learned from some professionals.
09:52:03 <srhb> "Kill it with iron"
09:52:17 <johnw> if only the "swap" function of my computer was to withdraw money from Apple's bank account and automatically order more RAM
09:52:18 <ReinH> hodapp: oh the joys of OOM errors!
09:52:33 <ReinH> johnw: See this is why I disable swap ;)
09:52:38 <petercommand> "you just need the oom killer"
09:53:09 <ReinH> athan: we use extensional equality to reason about programs, but it can't be represented within Haskell.
09:53:12 <hodapp> My favorite case: I was a young co-op, 2 weeks into a job. A coworker pointed me to some utility code to base something on. His function for listing files recursively had some bugs and it was O(2^n) where n is directory depth.
09:53:19 <ReinH> Except in some specific cases where the domain and image can be fully enumerated.
09:53:29 <hodapp> I pointed out this bug to him, and he said it was fine, he just wrapped the call in uniq(...) and it got rid of the dupes.
09:53:31 <athan> ReinH: That makes a lot of sense, thank you :)
09:53:36 <srhb> hodapp: :D
09:53:47 <kadoban> hodapp: XD
09:53:47 <c_wraith> athan: I'm pretty sure some package has done that.  But it's *slow* for general functions. :)
09:53:47 <petercommand> hodapp: it's apparently broken lol
09:54:00 <athan> c_wraith: I'm guessing some kind of serialization? :S
09:54:28 <tzaeru> welp, I've been recently looking into a program group that is composed of ~5 individual python scripts. they all run in their own processes, started by a "control" script. all of them iterate through same directory, composing a same list of files, several times a second.
09:54:32 <tzaeru> then they react to files with a specific name
09:54:42 <tzaeru> and do something with it, then rename it or move it to a subdirectory that is looked into by some other script
09:55:06 <tzaeru> all of this happens with the file names being the ONLY method of communication between the scripts. as you'd expect, with Windows, there are all kinds of permission handles left hanging now and then and stuff
09:55:08 <c_wraith> athan: well, it might be usable for that, but I just was thinking of an instance like (Enum a, Eq b) => Eq (a -> b) where ...
09:55:14 <tzaeru> so if a script fails, it's just rebooted and it tries again until it succeeds.
09:55:34 <athan> hmm... okay
09:57:46 <tzaeru> mmmh, the particular bunch of software would been a nice place to use haskell in..
09:57:50 <metzger> hello
09:58:00 <tzaeru> too bad it was also something that "lets get this done in a week!" so no really time to wrap my head around haskell for it <.<
09:58:06 <ReinH> athan: for instance, i could write an Eq instance for () -> () ;)
09:58:21 <metzger> does anyone have the quickcheck repository for before 2006? that's when it was converted from cvs. I need the cvs history.
09:59:14 <athan> ReinH: That makes a lot of sense, but alas I need something more powerful u_u
10:05:28 * hackagebot fasta 0.5.1.5 - A simple, mindless parser for fasta files.  http://hackage.haskell.org/package/fasta-0.5.1.5 (GregorySchwartz)
10:14:56 <athan> You guys wanna make your brain bleed?
10:14:58 <athan> http://lpaste.net/130647
10:15:31 <athan> I mean unless there's enough scar tissue to stop it
10:15:31 * hackagebot diversity 0.5.0.2 - Return the diversity at each position for all sequences in a fasta file  http://hackage.haskell.org/package/diversity-0.5.0.2 (GregorySchwartz)
10:17:29 <athan> Basically, it's a labelled rose tree where instead of doing literal lookups, you have a parser / predicate as the looking-up-function, and each child node is now indexed by the result of the parse for each node
10:20:31 * hackagebot friday 0.2.1.1 - A functional image processing library for Haskell.  http://hackage.haskell.org/package/friday-0.2.1.1 (RaphaelJavaux)
10:24:33 <anoe> Hello, there is an haskell orm that has typed jsonb array from PostgreSQL last (9.4) version ?
10:24:52 <anoe> do you have any feedback on it ?
10:26:17 <Ryanar> how do you sum Maybe Integer types?
10:26:30 <Ryanar> Like Just 3 + Just 4 ~> Just 7
10:26:54 <enolan> :t liftM2 (+)
10:26:54 <lambdabot> (Monad m, Num r) => m r -> m r -> m r
10:28:06 <Ryanar> >liftM2
10:28:18 <Ryanar> >>liftM2
10:28:23 <rola> > (+) <$> Just 3 <*> Just 4
10:28:25 <lambdabot>  Just 7
10:29:01 <Ryanar> what package are they using?
10:29:04 <rola> > lifA2 (+) (Just 3) (Just 4)
10:29:05 <lambdabot>      Not in scope: ‘lifA2’
10:29:06 <lambdabot>      Perhaps you meant ‘liftA2’ (imported from Control.Applicative)
10:29:15 <rola> > liftA2 (+) (Just 3) (Just 4)
10:29:16 <lambdabot>  Just 7
10:29:24 <rola> for what?
10:29:31 <Ryanar> Control.Applicative
10:29:41 <Ryanar> I was trying to do it in ghci's prelude
10:30:27 <Ryanar> > Just +3 <*> Just 4
10:30:28 <lambdabot>      Couldn't match expected type ‘Maybe (a0 -> b)’
10:30:28 <lambdabot>                  with actual type ‘a1 -> Maybe a1’
10:30:28 <lambdabot>      Probable cause: ‘Just’ is applied to too few arguments
10:30:38 <Ryanar> > Just (+3) <*> Just 4
10:30:39 <lambdabot>  Just 7
10:30:54 <rola> > do { n <- Just 3; m <- Just 4; pure $ n + m }
10:30:55 <lambdabot>  Just 7
10:31:26 <Ryanar> so that would be how you would do it without Control.Applicative, makes sense
10:31:56 <Ryanar> well im not sure where pure is from
10:32:13 <johnw> pure = Just for Maybe
10:32:24 <rola> applicative is now in the prelude for 7.10.1
10:32:51 <johnw> import Control.Applicative is almost always my first import in any module, I'm very happy about 7.10
10:33:08 <Ryanar> pure doesn't seem to be in prelude 7.8
10:33:24 <Ryanar> > pure $ 3 + 4
10:33:26 <lambdabot>      No instance for (Show (f0 r0))
10:33:26 <rola> pure is in Control.Applicative
10:33:26 <lambdabot>        arising from a use of ‘show_M41035615047349996001251’
10:33:26 <lambdabot>      The type variables ‘f0’, ‘r0’ are ambiguous
10:33:32 <Ryanar> > pure $ Just 3 + Just 4
10:33:33 <lambdabot>      No instance for (Show (f0 (Maybe a0)))
10:33:34 <lambdabot>        arising from a use of ‘show_M72989994143641939231274’
10:33:34 <lambdabot>      The type variables ‘f0’, ‘a0’ are ambiguous
10:33:55 <johnw> > pure 3 <*> pure 4 :: Maybe Int
10:33:57 <lambdabot>      No instance for (Num (a0 -> Int))
10:33:57 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
10:33:57 <lambdabot>        arising from the literal ‘3’
10:34:01 <johnw> > pure (+3) <*> pure 4 :: Maybe Int
10:34:02 <lambdabot>  Just 7
10:34:33 <Ryanar> so that is the exact same as
10:34:37 <rola> return
10:34:44 <Ryanar> > Just (+3) <*> Just 4
10:34:45 <lambdabot>  Just 7
10:35:14 <johnw> yep
10:35:20 <fizruk> :t fmap
10:35:21 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:35:24 <fizruk> :t fmap fmap fmap
10:35:25 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
10:35:32 <fizruk> :t fmap fmap fmap fmap fmap fmap fmap fmap
10:35:33 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
10:35:44 <Jaak> :t (.)(.)(.)(.)
10:35:45 <lambdabot> (a -> a1 -> b -> c) -> a -> a1 -> (a2 -> b) -> a2 -> c
10:36:30 <Jaak> oh... it's not from Category?
10:37:03 <fizruk> :t let f = (Control.Category..) in f f f f
10:37:03 <lambdabot> forall (k :: BOX) a a1 (cat :: k -> k -> *) (b :: k) (c :: k) (a2 :: k). Category cat => (a -> a1 -> cat b c) -> a -> a1 -> cat a2 b -> cat a2 c
10:38:05 <fizruk> interestingly, you can't get fmap for 4 nested functors just placing N fmaps together
10:38:23 <fizruk> :t fmap fmap fmap fmap fmap fmap fmap fmap   -- 8 fmaps
10:38:23 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
10:38:33 <fizruk> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap  -- 12 fmaps
10:38:34 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
10:39:19 <rola> too many fmaps spoils the lambdabot 
10:39:28 <benzrf> o_o
10:39:30 <fizruk> hehe :)
10:39:36 <benzrf> good lord
10:39:45 <benzrf> fmap fmap fmap = fmap . fmap
10:40:05 <fizruk> sure, I thought that one was well-known :)
10:40:17 <benzrf> jesus
10:40:22 <benzrf> X_X
10:40:25 <Jaak> :t fix fmap -- less go all the way??!
10:40:26 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ f a
10:40:26 <lambdabot>     Expected type: (f a -> f b) -> f a -> f b
10:40:26 <lambdabot>       Actual type: (a -> b) -> f a -> f b
10:40:29 <johnw> fmap = . for (->) r
10:40:34 <EvanR> that much fmapping is inappropriate
10:40:55 <benzrf> johnw: wrong
10:40:58 <benzrf> er, Jaak 
10:41:04 <benzrf> Jaak: fix is right-associative :>
10:41:23 <benzrf> Jaak: fmap fmap fmap fmap fmap fmap is left-ass
10:41:35 <benzrf> > fmap (fmap (fmap (fmap fmap)))
10:41:36 <lambdabot>      No instance for (Typeable f0)
10:41:36 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
10:41:36 <lambdabot>        arising from a use of ‘show_M9794674231972335251490’
10:41:38 <EvanR> :t fix fix
10:41:39 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ a -> a
10:41:39 <lambdabot>     Expected type: a -> a
10:41:39 <Jaak> dohh
10:41:40 <lambdabot>       Actual type: (a -> a) -> a
10:41:46 <quchen> benzrf teaches us the importance of not ending abbreviations too early today eh
10:41:52 <benzrf> :I
10:47:30 <metzger> guys does anyone have the quickcheck repository for before 2006? that's when it was converted from cvs. I need the cvs history.
10:48:20 <kadoban> metzger: Heh, out of curiosity, why do you need that?
10:49:15 <arkeet> fizbin: actually 6 fmaps = 10 fmaps
10:49:22 <arkeet> but 5 fmaps /= 9 fmaps
10:49:31 <arkeet> now why is this.
10:49:35 <fizbin> Huh?
10:49:44 <arkeet> sorry
10:49:45 <arkeet> fizruk: 
10:50:34 <metzger> kadoban: i am comparing quickcheck implementations in various languages.
10:50:57 <mjrosenb> arkeet: when you say fmaps, you mean fmap fmap fmap fmap fmap fmap == fmap fmap fmap fmap fmap fmap fmap fmap...?
10:51:06 <kadoban> metzger: Hmm, interesting.
10:51:08 <arkeet> yes
10:51:09 <johnw> you'd think by now that quickcheck could generate other quickheck implementations to verify its results
10:51:40 <fizruk> arkeet: it's just so happens that the cycle starts with 6 fmaps :)
10:51:49 <arkeet> yes
10:51:50 <Cale> instance Arbitrary QuickCheckImplementation where ...
10:52:24 <fizruk> arkeet: I still can't wrap my head around 8 fmaps being (fmap . fmap . fmap)
10:52:47 <fizruk> I guess I just need to write all the types down :)
10:54:07 <mjrosenb> blast, last week when I was in here, I had a bunch of reactive-banana questions
10:54:10 <lpaste> arkeet pasted “8 fmaps” at http://lpaste.net/130651
10:54:13 <arkeet> fizruk: 
10:54:14 <mjrosenb> and I don't remember them at all.
10:55:10 <caryatid> hello -- I'm a bit of a Haskell novice and was wondering about Show and Read typeclasses. Is `showing` something you cannot `read` considered bad form. I'm mostly asking about a data type that has a record of function type; so cannot be shown in a readable manner. Is there a convention for making such a type of the `Show` typeclass?
10:55:14 <SrPx> What is the fastest (performance-wise) way to get the first element of a value of [[[Int]]] ? i.e., it can be [[[]],[[],[]],[[],[],[]],[[],[1],[]],... 
10:55:36 * hackagebot pontarius-xmpp 0.4.1.0 - An XMPP client library  http://hackage.haskell.org/package/pontarius-xmpp-0.4.1.0 (PhilippBalzarek)
10:55:43 <SrPx> ex: `head . concat . concat`
10:56:37 <johnw> head . dropWhile null
10:56:49 <arkeet> head . head . head
10:56:49 <johnw> err, forgot about the second dimension there
10:56:52 <arkeet> ;)
10:57:02 <athan> Hey guys, can I get an opinion? For a Wai routing library, I'd like to let people declare routes with attoparsec parsers, so the syntax would look similar to `handle ("foo" </> parseBar </> "baz") (
10:57:05 <athan> erp
10:57:06 <slack1256> SrPx: that usually is performant enough
10:57:19 <arkeet> actually head . concat . concat seems fine.
10:57:28 <athan> `handle ("foo" </> parseBar </> "baz") (\bar :: Bar -> getToHandling)`
10:57:29 <arkeet> or listToMaybe . concat . concat
10:57:32 <SrPx> slack1256: my code is still 5x slower than it should :( I'm just wondering if that part specifically is a problem
10:57:46 <arkeet> if you're wondering, profile it
10:57:46 <athan> Does that look pleasing? :S
10:57:57 <slack1256> SrPx: did you profile?
10:58:10 <Philonous> caryatid, The convention is to make a Show instance that produces valid haskell code. It should also  be compatible with the Read instance. But those are soft requirements. Show and Read are mostly for debuggin anyway (don't use them for serialization!), so use whatever is most convenient for you.
10:58:41 <mpickering> caryatid: at this point the show typeclass has been overloaded with at least three different meanings
10:58:47 <SrPx> slack1256: I don't have libs installed for profiling :(
10:59:12 <arkeet> time to reinstall everything then ;)
10:59:21 <slack1256> SrPx: are you using your distribution packages?
10:59:21 <Philonous> caryatid, Personally, I newer write Read instance and only derive it when I'm also deriving the Show instance (and even then I usually don't)
10:59:28 <SrPx> arkeet: which I had it
10:59:34 <Philonous> never*
10:59:40 <SrPx> slack1256: pardon?
11:00:11 <slack1256> SrPx: are you on Windows/Mac OS X/Linux/BSD? 
11:00:19 <SrPx> osx
11:00:32 <slack1256> oh OK, how did you installed ghc?
11:00:35 <caryatid> Philonous: mpickering: thank you. Good to know. honestly this was just for easing playing around in ghci; but it raised the question, "what is show for"  
11:01:35 <SrPx> I think I compiled it IIRC slack1256 
11:01:36 <Philonous> caryatid, That's what show is for. Playing around with ghci and looking at values. Don't use it for any real work.
11:03:51 <mpickering> caryatid: I can dig out some mailing list threads where the semantics of Show are discussed if you like
11:04:05 <slack1256> SrPx: Nice, well bad news is, that you will have to compile it again to include the profiling versions of the libraries :-(
11:04:57 <slack1256> this is usually activated on the .cabal/config the line library-profilling should be uncommented and set to True
11:05:04 <caryatid> mpickering: Thanks, but I think no need. I was mostly interested as my instance def was lossy [ didn't represent the function record ]
11:06:42 <slack1256> and then recompile 
11:08:50 <SrPx> slack1256: :( okay
11:09:00 <onielfa> I have a problem installing http-conduit. Can anyone help me? http://lpaste.net/130637
11:10:03 <ProofTechnique> I was just talking about a generic zipWith last night, and now Oleg's published just such a thing. Of course.
11:10:36 <bergmark> onielfa: i have seen that error... but what was it
11:10:44 <srhb> ProofTechnique: Isn't that article oooold?
11:10:47 <srhb> I think it was just reposted.
11:11:07 <ProofTechnique> "The current version is December 2012 and April 2015."
11:11:10 <ProofTechnique> Updated, maybe?
11:11:14 <bergmark> onielfa: GHC 7.6?
11:11:14 <srhb> Oh. I guess so then
11:11:17 <onielfa> bergmark: :) lets hope you remember
11:11:18 <bergmark> onielfa: http://stackoverflow.com/questions/19597324/cabal-error-invalid-preprocessing-directive
11:11:26 <onielfa> bergmark: let me check the version
11:11:51 <onielfa> The Glorious Glasgow Haskell Compilation System, version 7.6.3
11:11:56 <bergmark> this was fixed in 7.8, i'd recommend upgrading. it's fixable with 7.6 with https://gist.github.com/mzero/7245290
11:12:46 <onielfa> bergmark: I will update, any hint how should I?
11:18:08 <lpaste> ryanar revised “CPS Style sumList (annotation)”: “not compiling, not sure why” at http://lpaste.net/7364949948552445952
11:19:57 <quchen> GHCi 7.10 doesn't print stuff like "Loading package ghc-prim ... linking ... done." on startup anymore. Did I miss something?
11:22:20 <mjrosenb> Ryanar: fwiw, usually the k in a CPS'ed version is foo -> a
11:22:21 <mpickering> Ryanar: Why is your type not f :: [Integer] -> (Int -> Int) -> Int?
11:24:07 <fizruk> arkeet: I just found that you need 2nd functor law to prove 10 fmaps = 6 fmaps, I guess that was a good exersize :)
11:24:17 * mjrosenb would argue for f :: [Integer] -> (Integer -> a) -> a
11:24:36 <Ryanar> why a though, why not be explicit since I dont want to return any type
11:24:42 <Ryanar> but specifically an integer
11:24:49 <mjrosenb> fizruk: *exercise
11:25:07 <Ryanar> and yes I can use Int instead of Integer, not really important to what I am trying to do
11:25:09 <fizruk> mjrosenb: I always misspell it, sorry :(
11:25:26 <mjrosenb> Ryanar: how do you know that every continuation that you want to pass in will always return an integer?
11:25:39 <mjrosenb> fizruk: I was attempting to be informative.
11:25:47 <Ryanar> Ryanar, because I am passing a list of integers
11:26:09 <fizruk> mjrosenb: I think you were, thanks :)
11:26:56 <slack1256> > maxBound :: Int
11:26:57 <lambdabot>  9223372036854775807
11:26:59 <mjrosenb> Ryanar: right.  but if you have the continuation's type be Integer -> a, then you can call sumListCPS [1..10] show, and get "55" as the result
11:27:34 <slack1256> I though 64 bit mean that pointer can adress 64 bit direction, not that Word sizes would be 64 bit
11:27:38 <mjrosenb> Ryanar: rather than needing to say show $ sumListCPS [1..10] id
11:27:39 <slack1256> *pointers
11:28:19 <mjrosenb> slack1256: it usually means that the registers are 64 bits wide, which *usually* means both things.
11:30:03 <mjrosenb> ok, now I remember by Reactive.Banana question: how do I get the current value of a Behavior inside of an event handler?
11:30:23 <fizruk> arkeet: https://gist.github.com/fizruk/02f0644c45c4b446435b
11:38:51 <Moggle> I'm trying to create a "log of last 1000 messages inputted" thing, I'm trying to figure out what the best data structure would be for that. Does anyone have suggestions? If this were something imperative, I'd do a linked list where I keep track of the last and first nodes and just delete the first node and append a new node to the end with every message.
11:39:28 <ReinH> Moggle: what are your access patterns?
11:39:37 <ReinH> front and back only? Maybe a Data.Sequence.
11:39:38 <arkeet> Moggle: so you want a queue.
11:39:44 <arkeet> Data.Sequence is a good choice.
11:40:04 <Moggle> ReinH: You can access any/all of the messages at any time, though reading will be rare and writing plentiful
11:40:06 <arkeet> (constant time access to front and back)
11:40:12 <Moggle> Data.Sequence? I'll look into it, thanks.
11:40:21 <arkeet> and constant time length I guess.
11:40:34 <ReinH> Moggle: Seq won't have good random access, but good random access will require other things to be less good
11:40:37 <ReinH> arkeet: Not really, no.
11:40:38 * hackagebot dataflow 0.5.0.0 - Generate Graphviz documents from a Haskell representation.  http://hackage.haskell.org/package/dataflow-0.5.0.0 (owickstrom)
11:40:45 <arkeet> ReinH: it says so.
11:40:59 <ReinH> arkeet: Oh you're saying it does have it, not Moggle needs it.
11:41:06 <arkeet> oh, yes.
11:41:09 <Moggle> arkeet: This is perfect.
11:41:18 <ReinH> Seq is pretty good.
11:41:28 <Moggle> Thanks again.
11:41:30 <arkeet> ReinH: well, I imagine Moggle could make use of it, if you only want to keep 1000 things.
11:41:33 <Cale> Seq has log time random access (log of the min distance to either end)
11:41:44 <Cale> But the constant factors aren't so great
11:41:46 <ReinH> arkeet: Sure, but you can always store it separately.
11:41:52 <arkeet> sure.
11:42:03 <mjrosenb> this sounds like it would be an *amazing* use for hooking some semantics into the garbage collector
11:42:05 <arkeet> Seq does that already.
11:42:14 <ReinH> arkeet: yep!
11:42:23 <mjrosenb> just keep appending to a list, and let the GC deal with removing older nodes.
11:42:37 <arkeet> (as a byproduct of log time random access.)
11:42:41 <Profpatsch> @pl \x, y -> compare (f x) (f y)
11:42:41 <lambdabot> uncurry ((. f) . compare . f)
11:42:43 <ReinH> mjrosenb: GC wont' collect elements of a list that is referenced.
11:42:47 <mjrosenb> kind of like a weak reference, but with a counter for N layers of indirection
11:42:48 <ReinH> *won't
11:44:14 <oconnore> Hi, I have a program that uses time to log some data with a timestamp. I want to write a test to check that I can call this code from C, and that it does the right thing.
11:44:16 <ReinH> It's easy enough to (|> x) . drop 1
11:44:32 <oconnore> Is it possible to somehow mock out the time module so that I can check the output?
11:44:39 <oconnore> or what is the best way to go about this?
11:45:47 <johnw> oconnore: do you already have some sort of global environment available?
11:45:54 <johnw> if so, then add a time action to it
11:46:15 <johnw> i did that once, so that I could accelerate time for testing purposes
11:46:46 <oconnore> johnw: not really. The C library has global state, but I would rather not have the haskell code rely on an additional FFI call
11:46:54 <oconnore> I guess I could create something
11:47:39 <ReinH> johnw: That's nice.
11:48:11 <arkeet> ReinH: it is, but you don't want to drop when the queue is short.
11:48:25 <ReinH> arkeet: Yeah, I was eliding a length check.
11:48:40 <arkeet> Moggle: if this were C I'd probably use a ring buffer.
11:49:31 <ReinH> arkeet: Welp, https://hackage.haskell.org/package/combobuffer-0.2/docs/Data-RingBuffer.html
11:49:37 <Moggle> arkeet: Looked it up, this is also perfect for my needs.
11:49:44 <Moggle> Probably even better than this Data.Sequence.
11:49:50 <ReinH> No warranties, express or implied, about the quality of that package.
11:49:53 <Moggle> Seems like it has O(1)... everything.
11:49:55 <arkeet> no, I wouldn't use it for haskell.
11:49:56 <Moggle> (that i need.)
11:50:21 <Moggle> O(1) add/remove, O(1) random access of any element
11:50:29 <Moggle> a lot to like
11:50:35 <arkeet> I don't think you get O(1) add/remove.
11:50:38 * hackagebot Concurrential 0.2.1.0 - Mix concurrent and sequential computation  http://hackage.haskell.org/package/Concurrential-0.2.1.0 (alexvieth)
11:50:40 * hackagebot TBit 0.4.2.1 - Utilities for condensed matter physics tight binding calculations.  http://hackage.haskell.org/package/TBit-0.4.2.1 (danielsmw)
11:50:53 <arkeet> because you have to copy the entire structure to modify it.
11:50:57 <ReinH> That shouldn't actually be possible
11:51:00 <Moggle> you should? just implement it is an array, keep track of an integer representing the start
11:51:07 <Moggle> modulo around when doing random access
11:51:13 <Moggle> i mean yeah not in haskell due to purity
11:51:14 <arkeet> every time you modify the array you have to copy the entire thing.
11:51:17 <arkeet> unless you're doing something impure.
11:51:18 <Moggle> but with mutable state
11:51:20 <arkeet> yeah.
11:51:25 <ReinH> You could do it in ST or IO
11:51:38 <Moggle> i could, but i suspect there is not such an implementation available in haskell
11:51:40 <Moggle> data.seq is fine
11:51:44 <ReinH> I suspect... yes.
11:51:45 <arkeet> I would stick with Seq
11:51:49 <Moggle> i don't need high performance.
11:51:55 <Moggle> this is just a basic chatbot.
11:52:22 <arkeet> Seq gives you persistence
11:52:24 <Moggle> either way yeah, ring buffer satisfies everything perfectly, i don't think there's a better data structure
11:52:34 <arkeet> ring buffers aren't persistent.
11:52:50 <ReinH> You can imitate a ring buffer reasonably well with Seq
11:53:07 <Moggle> oh yeah i guess for the case of multithreading
11:53:15 <arkeet> ReinH: you could but I don't see the point. :p
11:53:23 <ReinH> Me neither.
11:53:28 <ReinH> I'd probably just use a bounded queue
11:53:49 <ReinH> Since you probably *don't* want to drop chat messages on the floor.
11:54:03 <ReinH> e.g., https://hackage.haskell.org/package/stm-2.4.4/docs/Control-Concurrent-STM-TBQueue.html
11:54:28 <arkeet> yes good
11:55:07 <Moggle> the use case in this case is just having a command to retrieve n logs, up to 1000, from the channel
11:55:13 <Moggle> it doesn't have to store infinite amounts
11:55:47 <ReinH> Oh right it's for logs.
11:55:48 <arkeet> ReinH: you'd still need a wrapper around it to pop when it's full
11:56:12 <ReinH> arkeet: I forgot the use case is just for logs
11:56:27 <arkeet> well, fun to think about regardless.
11:56:41 <kqr> what's the community consensus on monadcomprehensions? it's kind of convenient to do something like name = ["jane" | show_name] :: Maybe String
11:56:53 <arkeet> go for it.
11:56:55 <johnw> container types really don't work in Haskell, do they
11:57:08 <arkeet> johnw: hm?
11:57:25 <johnw> arkeet: https://github.com/jwiegley/notes/blob/master/Container.hs
11:57:39 <johnw> I'm trying to model lists as a specific container type using a GADT
11:57:41 <arkeet> kqr: I don't think MonadComprehensions ends up getting used often but I don't think anyone has any problem with it.
11:57:51 <johnw> but I can't write the Applicative or Monad instances due to various restrictions
11:57:56 <ReinH> kqr: It can be useful in places, but I don't generally see it used.
11:58:09 <ReinH> johnw: I don't think you can write the Monad instance, full stop.
11:58:13 <arkeet> kqr: an alternative is "jane" <$ guard (show_name)
11:58:22 <johnw> ReinH: ?
11:58:24 <arkeet> (well, parentheses not really needed there)
11:58:46 <johnw> the logic for the monad instance is easy enough, it's the types that get in the way
11:58:53 <ReinH> johnw: Oh wait, you're encoding the shape into the type
11:58:55 <johnw> yeah
11:59:00 <kqr> arkeet, oh that's interesting. what's <$ mean?
11:59:01 <johnw> that's really the only way I can do it
11:59:05 <arkeet> :t (<$)
11:59:05 <lambdabot> Functor f => a -> f b -> f a
11:59:15 <johnw> I tried various ways of "generalized containers", but I like the machinery
11:59:22 <arkeet> a <$ m = fmap (const a) m
11:59:24 <Zemyla> (<$) = fmap . const.
11:59:28 <ski> @tell athan instance (Compact a,Overt a,Eq b) => Eq (a -> b)
11:59:28 <lambdabot> Consider it noted.
11:59:29 <Zemyla> :t fmap . const
11:59:30 <lambdabot> Functor f => b -> f a -> f b
11:59:33 <ReinH> johnw: Yeah, so join automatically is the hancock tensor
11:59:44 <ReinH> Well, maybe, I don't actually know what that is since it isn't published anywhere.
11:59:51 <ReinH> The point being it respects the "shape" and doesn't lose info.
11:59:51 <johnw> ReinH: haha
11:59:52 <arkeet> :t guard :: Bool -> Maybe ()
11:59:53 <lambdabot> Bool -> Maybe ()
11:59:57 <johnw> that's like a superior nerd-snipe
12:00:03 <kqr> arkeet, the parens around show_name are not necessary are they?
12:00:04 <johnw> reference a concept that isn't published anywhere
12:00:09 <arkeet> kqr: no
12:00:13 <arkeet> I just mentioned that, heh.
12:00:22 <kqr> oh sorry
12:00:24 <kqr> lots of text :D
12:00:26 <ReinH> johnw: References to Hancock's Tensor are always to "private communication with Peter Hancock" ;)
12:00:27 <arkeet> yes
12:00:35 <kqr> I'm still up at the original suggestion
12:00:41 <lpaste> ryanar revised “CPS Style sumList (annotation)”: “not sure why this doesnt compile” at http://lpaste.net/7364949948552445952
12:00:56 <ReinH> johnw: Closest I've come to an explanation of what it actually is is http://stackoverflow.com/questions/12963733/writing-cojoin-or-cobind-for-n-dimensional-grid-type
12:01:02 <EvanR> arkeet: putting (show_name) in parens creeps me out, like its executing show_name
12:01:17 <kqr> arkeet, ah thanks. I'll just get to grips with <$, but that solution looks much nicer in fact!
12:01:47 <arkeet> EvanR: well, in my head show_name was some more complicated expression.
12:01:51 <kqr> at least closer to what I intend
12:02:10 <ReinH> kqr: <$ is super useful for parsers, otherwise I haven't found too much use for it.
12:02:20 <fragamus> Can anyone explain the "deeply pathological" remark from "what i wish i knew learning haskell" about lens 
12:02:25 <ReinH> Foo <$ string "Foo", etc
12:02:35 <ReinH> fragamus: link?
12:02:40 <johnw> ReinH: have you studied this in relation to containers before, or is this a guess?
12:02:51 <ReinH> johnw: It is mostly a guess.
12:03:02 <Zemyla> :t maybe mzero return
12:03:03 <lambdabot> MonadPlus m => Maybe a -> m a
12:03:10 <arkeet> :t maybe empty pure
12:03:11 <lambdabot> Alternative f => Maybe a -> f a
12:03:12 <kqr> ReinH, ah that'd return Foo and discard the string parsed?
12:03:27 <ReinH> johnw: Well, I was just talking about Hancock's Tensor, which seems to relate to join for fixed-size containers.
12:03:31 <fragamus> http://dev.stephendiehl.com/hask/
12:03:35 <ReinH> kqr: It's return a Parser Foo
12:03:41 <ReinH> It'd*
12:03:43 <johnw> these containers are not fixed-size
12:03:54 <kqr> ReinH, ahh right, yeah. otherwise it'd just be const Foo
12:03:56 <ReinH> That would, yes, return Foo if the prser matched.
12:03:59 <ReinH> *parser
12:04:01 <ReinH> typing, how do I even
12:04:24 <arkeet> :t foldr (<|>) empty
12:04:25 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
12:04:28 <arkeet> uh.
12:04:34 <arkeet> :t foldr ((<|>) . pure) empty
12:04:35 <lambdabot> (Foldable t, Alternative f) => t a -> f a
12:04:49 <fragamus> I like lens and i like that it comes from the deep theoretical world
12:05:04 <arkeet> I like lens too.
12:05:05 <fragamus> i don't mind that it is seemingly heavy weight 
12:05:09 <ReinH> johnw: I could speak more intelligently on this if I could access that private communication from Peter Hancock ;)
12:05:12 <arkeet> some people don't like it.
12:05:22 <arkeet> I guess because they think it's some sort of complete new language embedded within haskell
12:05:24 <fragamus> BUT I need to know what "deeply pathological" means 
12:05:24 <kqr> I love lens
12:05:27 <kqr> lens is one of the best things
12:05:30 <arkeet> which makes it somehow not haskell.
12:05:32 <arkeet> which I don't understand
12:05:34 <monochrom> every opinion posted on the internet can be explained by the law of large numbers
12:05:47 <arkeet> but I think that's a minority opinion.
12:06:13 <fragamus> i like how most of the code evaporates at compile time
12:07:07 <ggVGc> Hi, I have this code that broke with ghc 7.10 and I found out I had to enable GADTs explicitly so it now works. I don't quite understand though, since I didn't write the code originally and am new to haskell. Does parsec itself rely on GADTs, or is it this code specifically that does so(i.e it could be rewritten to use depend on GADTs)
12:07:10 <kqr> fragamus, (computer science) Having properties that cause unusually bad behaviour, especially regarding correctness or performance.
12:07:13 <ggVGc> https://gist.github.com/b984179fbf65d4c31df3
12:07:16 <kqr> fragamus, (mathematics) Having properties which are counterintuitive or difficult to handle.
12:07:16 <ggVGc> that code ^
12:07:49 <fragamus> yeah i know what pathological means, but why are they saying that about lens
12:07:51 <ReinH> fragamus: I would consider "The lens library is considered by many Haskellers to be deeply pathological" to be an weaselly worded, unsupported assertion.
12:07:58 <ReinH> fragamus: http://en.wikipedia.org/wiki/Weasel_word
12:08:09 <EvanR> ggVGc: what happens if you dont have GADTs
12:08:10 <merijn> ggVGc: That doesn't require GADTs, unless your indent/pretty-printing package does
12:08:36 <kqr> fragamus, some people thinks lens is un-haskell-y
12:08:41 <kqr> fragamus, like arkeet said
12:08:45 <monochrom> wow, did that author even conducted a statistical survey?
12:08:58 <MP2E> I love lens
12:09:03 <monochrom> this is beyond weaselling. this is making things up.
12:09:03 <fragamus> I mean it is coming from ed kmett and tarmo ustaalu
12:09:08 <ReinH> monochrom: Yep.
12:09:13 <kqr> everyone who's ever had to deal with nested data loves lens
12:09:19 <Zemyla> So who the hell considers lens to be "deeply pathological"?
12:09:25 <ReinH> They're just couching their own assertion in a faux appearance of authority.
12:09:45 <ggVGc> merijn: then it's probably the indents package that needs it, because the code broke in GHC 7.10 before I added the top line
12:09:46 <Zemyla> I would think something that relies on large numbers of theoretical rules and properties would be the opposite of pathological.
12:09:51 <ReinH> Zemyla: Stephen, presumably.
12:10:00 <arkeet> fragamus: I guess the author just has some sort of moral opposition against lens.
12:10:02 <ggVGc> EvanR: just doesn't compile, with type errors that I don't understand
12:10:03 <Zemyla> Stephen? I don't know about him.
12:10:06 <arkeet> or maybe edward himself.
12:10:08 <ReinH> fragamus: Anyway, I would suggest that you ignore that statement as being entirely meaningless, since it is.
12:10:13 <arkeet> which I don't really want to get into.
12:10:15 <monochrom> the law of large numbers implies that the probability that someone makes a statistical statement without data tends to be 1
12:10:17 <EvanR> ggVGc: ... right like what
12:10:24 <Zemyla> Now lens isn't yet intuitive to me, but it's not pathological.
12:10:26 <ggVGc> EvanR: gimme a sec
12:10:35 <fragamus> roger, I shall go forth and lens
12:10:43 <MP2E> the noise created around the lens library is unmerited imo.. I avoided lens for a while because of that, but I'm really glad I checked it out. It's one of the most useful libraries the Haskell community has
12:11:02 <ReinH> It's mostly FUD.
12:11:27 <ReinH> Although some of it is actually inaccurate, like "lenses compose backwards".
12:11:29 <fragamus> I just want to try to chart my course well through these controversies lest the time i spend learning be wasted
12:11:32 <ggVGc> EvanR: https://gist.github.com/d566bca6769e4facb776
12:11:48 <ReinH> fragamus: Go forth and lens.
12:12:20 <fragamus> l love watching cabal install lens
12:12:29 <ReinH> monochrom: It's weird coming from sdeihl too, since he's a pretty smart, generally level-headed person in my experience.
12:12:37 <ReinH> *sdiehl
12:12:47 <monochrom> the worst part is that readers look at a statement without data evidence, then actually give it a benefit of doubt, and go on to ask around as if it has any merit
12:13:05 <ReinH> I do wish he'd update http://dev.stephendiehl.com/fun/, although I obviously understand why one might get behind on such a thing...
12:13:07 <fragamus> uhm
12:13:07 <fragamus> yeah
12:13:09 <EvanR> ggVGc: the error is "The type variable s0 is ambiguous"
12:13:12 <ReinH> monochrom: yep.
12:13:19 <monochrom> whereas the rational thing to do is "since this doesn't come with data, -> /dev/null"
12:13:21 <ReinH> monochrom: Maybe I'll bug him about removing it.
12:13:32 <EvanR> ggVGc: try adding top level type annotations
12:13:42 <ggVGc> EvanR: yeah, but why does GADTs solve it? And how can I find the type signatures for these functions that I didn't write?
12:13:45 <ReinH> It really detracts from the rest of it
12:14:01 <EvanR> ggVGc: well start with the functions you did write
12:14:19 <arkeet> ReinH: I was considering bugging him about the fact that he gets prisms and traversals all mixed up.
12:14:22 <ReinH> I mean, it's literally just "WARNING: <unsupported FUD about lens>", it's useless.
12:14:22 <EvanR> GADTs change things slightly im surprised that it "fixes" the problem
12:14:26 <ReinH> worse than useless.
12:14:29 <dolio> ggVGc: GADTs turns on things like MonoLocalBinds, which might fix some stuff there.
12:14:29 <arkeet> but I didn't feel like it was worth it given that message.
12:14:44 <hodapp> boo, cloudflare timeout page for https://ghc.haskell.org/trac/ghc/wiki/Migration/7.10
12:14:45 <ReinH> arkeet: I think both things are worth bugging him about. It's otherwise a very useful resource.
12:15:00 <dolio> ggVGc: I.E. lets don't get generalized in some circumstances.
12:15:07 <ReinH> I'd rather not have to recommend it with the caveat "but ignore the lens stuff", or worse still not recommend it at all.
12:15:10 <fragamus> its an amazing web page 
12:15:12 <johnw> ReinH: I was able to generalize containers using a type class with an associated type family: https://github.com/jwiegley/notes/blob/master/Container.hs
12:15:19 <johnw> so it's really just the Monad instance I can't write at the moment
12:16:02 <johnw> and the typical trick to make it work in my case (CPS transformation) is not available to me
12:16:04 <ReinH> johnw: An that's just because of the constraints?
12:16:14 <ReinH> Right.
12:16:17 <johnw> it's because >>= needs to return a new container
12:16:22 <johnw> whose type is variant on what was contained
12:16:26 <ReinH> Ah.
12:16:50 <johnw> given rank-2 CPS, type variance is just dandy
12:18:12 <dolio> ggVGc: Do the errors go away if you just turn on FlexibleContexts? Or are they still there?
12:18:41 <johnw> like, pure is a bit oddly behaving, becaues you're not just asking for "a list" ,but the default construction for a list with a particular shape, which would mean branching on the inferred type
12:19:27 <johnw> solve those two problems, though, and I think we'd have container types in Haskell...
12:20:15 <johnw> (well, at least CTs that could support Applicative and Monad; for just pure Functors we do have them)
12:20:45 <ggVGc> dolio: will try. But I'm working my way towards knowing the type signatures of these functions now. It's better learning anyway :) I shouldn't be using code I don't understand anyway
12:22:06 <dolio> ggVGc: One error there is because now GHC requires you to turn on extensions for all inferred signatures, which it previously didn't. You have one error about FlexibleContexts from that. My thought was that that could be causing the other errors. Maybe not, though.
12:22:36 <eacameron> I'm curious how GHC implements laziness efficiently without race conditions. With sharing, I'm imagining a race condition between two threads both trying to evaluate a thunk
12:22:52 <eacameron> and memoize the answer
12:23:24 <dolio> There is a race there. It's just so small that it doesn't matter much.
12:24:20 <dolio> Or maybe the race is actually smaller than you're thinking.
12:24:24 <monochrom> since the two threads compute the same answer, some redundancy and overlapping is safe
12:24:56 <ggVGc> oh, I added some type sigs and now it compiles fine
12:24:56 <ggVGc> without GADTs
12:25:01 <monochrom> at any rate, when a thread enters a thunk, it leaves a marker "work has begun on this"
12:25:17 <Zemyla> Yeah, isn't there a specific black hole thunk it's set to?
12:25:20 <Cale> When one thread first enters the thunk, the pointer gets rewritten to point at a grey hole which is a piece of code that when entered will wait for the result to be computed
12:25:59 <johnw> grey holes, cool
12:25:59 <Cale> (and that's the very first thing which happens)
12:27:21 <Cale> So if another thread comes along and needs the value, chances are it will enter the grey hole and wait, unless both threads enter it at essentially the same time, in which case they both compute the value and complete the write, which is idempotent and stateless anyway.
12:27:37 <EvanR> pointer writes are conveniently consistent on x86
12:27:47 <EvanR> you can do amazing things
12:28:05 <ggVGc> EvanR: thanks, it was due to forceEither being ambiguous in my code. Added a type sig and now it's fine
12:28:28 <EvanR> ggVGc: generally you put top level type sigs for real code
12:29:35 <ggVGc> EvanR: yeah, I put type sigs on all my code usually, but these 4 lines I took from the internet, because I don't understand parsec or parsec.indent yet, and I just wanted a quick indentation parser
12:29:36 <ggVGc> and it worked
12:29:36 <ggVGc> I plan to understand it at some point
12:32:04 <eacameron> Cale: monochrom: dolio: that is sweet
12:32:22 <Cale> Unless of course, it isn't. Originally, expressions involving unsafePerformIO would execute twice, causing all the effects, which could create problems. Now unsafePerformIO does an additional check to ensure that no other thread can be evaluating the thunk at the same time, and there's unsafeDupablePerformIO if you really want to skip that safety check.
12:33:04 <quchen> Cale: I've recently started reading SPJ's STM paper for no good reason and my god is it a good source for understanding Haskell semantics. Why hasn't anyone told me to *do* read that :-D
12:33:48 <Cale> I dunno, but I often recommend it when people are looking for more stuff to read after having completed various tutorials.
12:34:09 <quchen> STG, not STM. Woops
12:34:35 <Cale> ah, that one too :)
12:34:41 <Cale> I was thinking you meant http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf
12:34:45 <ReinH> quchen: or http://research.microsoft.com/pubs/74063/beautiful.pdf
12:34:51 <kadoban> WHich paper is this? The spineless, tagless G-machine one?
12:34:57 <quchen> Funny how the typo didn't make the sentence worse at all :-)
12:35:02 <ReinH> quchen: indeed!
12:35:08 <Cale> http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
12:35:15 <quchen> ST{,M,G}, what's the difference
12:35:25 <quchen> kadoban: Exactly.
12:35:26 <ReinH> Cale: is that the old one or the new one?
12:35:36 <quchen> There's a new one? I'm reading the 1992 one
12:35:41 * hackagebot pathfinding 0.1.0.0 - pathfinding in grid and graphs  http://hackage.haskell.org/package/pathfinding-0.1.0.0 (rvion)
12:35:42 <quchen> Version 2.5 it says
12:35:43 <arkeet> spineless tagless M-machine
12:35:55 <ReinH> Ah this is the old one http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/slpj-book-1987.pdf
12:36:11 <Cale> That's totally not even the same paper :)
12:36:25 <ReinH> Cale: CLOSE ENOUGH :p
12:36:26 <kadoban> I really should get around to reading it sometime
12:36:55 <ReinH> Anyway they're all good reads and I should read all of them again
12:37:07 <Cale> I always just google for "peytonjones92implementing" because I know it will find it :)
12:37:43 <quchen> kadoban: Several "woah" moments are in that paper. And it gives you plenty of good arguments for "Haskell isn't as close to the machine as Java" arguments.
12:37:57 <kuribas> If I want to find a maximum element, and then delete it, is there something better than using "maximum" and "delete"?
12:38:12 <ReinH> quchen: Isn't the response to "Haskell isn't as close to the machine as Java" arguments just "Thank goodness"?
12:38:17 <Cale> kuribas: Perhaps something involving this function:
12:38:33 <kadoban> Sounds like good motivation. I had a friend who tried to get me to read it more than a few times, but I wasn't very into haskell yet at that point.
12:38:33 <quchen> ReinH: That's correct, but not a good answer.
12:38:36 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
12:38:37 <lambdabot>  Defined.
12:38:39 <ReinH> quchen: heh
12:38:52 <Cale> > select [1,2,3,4,3,2,1]
12:38:53 <lambdabot>  [(1,[2,3,4,3,2,1]),(2,[1,3,4,3,2,1]),(3,[1,2,4,3,2,1]),(4,[1,2,3,3,2,1]),(3,...
12:38:56 <quchen> ReinH: I've been looking for the educated version of that for a long time though.
12:39:03 <ReinH> quchen: fair enough :)
12:39:12 <Cale> > maximumBy (comparing fst) . select $ [1,2,3,4,3,2,1]
12:39:14 <lambdabot>  (4,[1,2,3,3,2,1])
12:39:17 <Cale> > snd . maximumBy (comparing fst) . select $ [1,2,3,4,3,2,1]
12:39:18 <lambdabot>  [1,2,3,3,2,1]
12:39:36 <kuribas> Cale: hm, nice
12:39:37 <quchen> ReinH: "Your computer doesn't run loops, it doesn't run functions, it doesn't run classes. That stuff is as far away from ASM as lambdas are. Here's why."
12:39:47 <arkeet> > evalState (replicate 4 $ state select) [1..3]
12:39:49 <lambdabot>      Couldn't match type ‘[m0 a0]’ with ‘StateT [Integer] Identity a’
12:39:49 <lambdabot>      Expected type: State [Integer] a
12:39:49 <lambdabot>        Actual type: [m0 a0]
12:39:51 <arkeet> oh.
12:39:53 <arkeet> :t state
12:39:54 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
12:40:00 <arkeet> > evalState (replicate 4 $ stateT select) [1..3]
12:40:01 <lambdabot>      Not in scope: ‘stateT’
12:40:01 <lambdabot>      Perhaps you meant one of these:
12:40:01 <lambdabot>        data constructor ‘StateT’ (imported from Control.Monad.State),
12:40:05 <arkeet> I'll stop.
12:40:09 <ReinH> Cale: Hmm, I'm trying to reason about that operationally. Is it lazy enough to only traverse once?
12:40:17 <Cale> > select [1..]
12:40:19 <lambdabot>  [(1,[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
12:40:21 <Cale> heh
12:40:27 <ReinH> So yesish.
12:40:44 <Cale> > map (\(x,xs) -> (x, take 3 xs)) . select $ [1..]
12:40:45 <arkeet> > evalStateT (replicateM 3 $ StateT select) [1..3]
12:40:45 <lambdabot>  [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3]),(5,[1,2,3]),(6,[1,2,3]),(7,...
12:40:47 <lambdabot>  [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
12:40:51 <ReinH> nice
12:41:12 <ReinH> That's clever!
12:41:22 <arkeet> > runStateT (replicateM 2 $ StateT select) [1..4]
12:41:24 <lambdabot>  [([1,2],[3,4]),([1,3],[2,4]),([1,4],[2,3]),([2,1],[3,4]),([2,3],[1,4]),([2,4...
12:41:31 <Cale> select is one of the functions I'd really like to have in Data.List, but which will probably never get in because people don't like changing Data.List :(
12:41:51 <Cale> It's so useful for so many things
12:42:44 <johnw> Cale: propose it anyway, I'll upvote it
12:42:44 <ski> yes
12:43:01 <johnw> I think we imagined AMP would never happen too
12:43:27 <Cale> johnw: done. https://mail.haskell.org/pipermail/libraries/2010-July/013842.html
12:43:39 <johnw> haha
12:43:52 <kuribas> Cale: you have my vote :)
12:44:03 <johnw> wow, second reference to Hancock in as many hours
12:45:35 <roboguy_> @info select
12:45:36 <lambdabot> select
12:45:50 <roboguy_> the @info command is a bit lacking
12:46:01 <Cale> It doesn't... is that even a command?
12:46:07 <johnw> i wonder why Identity isn't just Id...
12:46:17 <Cale> I think maybe that command is meant to do something else entirely
12:46:23 <roboguy_> That's very possible
12:46:27 <Cale> Or it's lambdabot's spell corrector
12:46:32 <ReinH> johnw: where was the second?
12:46:33 <Cale> correcting to some other command
12:46:39 <johnw> https://mail.haskell.org/pipermail/libraries/2010-July/013843.html
12:46:41 <monochrom> @info do { x<-m; return (sin x) }
12:46:41 <lambdabot> m >>= \ x -> return (sin x)
12:46:42 <roboguy_> I was hoping it would work like :i
12:46:45 <ReinH> johnw: I wish he would just publish the damn thing...
12:46:49 <Cale> :t select
12:46:50 <lambdabot> [t] -> [(t, [t])]
12:46:52 <monochrom> that is the true meaning of @info
12:46:57 <quchen> johnw: There are a couple of "Id"s in GHC though
12:46:58 <Cale> roboguy_: I defined select above
12:46:59 <ReinH> johnw: And both from pigworker, so no surprise there... ;)
12:47:09 <Cale> <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
12:47:15 <ReinH> johnw: Conor was a recipient of this magical personal communication ;)
12:47:18 <roboguy_> Cale: oh, thanks
12:47:38 <johnw> "The question for library designers is at what level to engage with this structure. In doing so, we should of course take care to protect Joe Programmer from the Screaming Heebie-Jeebies."
12:47:53 <Cale> ReinH: Yeah, both times that I proposed this, he was enticed into giving that :)
12:47:54 <HeladoDeBrownie> it looks like @info corrects to @undo
12:48:06 <HeladoDeBrownie> @undo do { x<-m; return (sin x) }
12:48:06 <lambdabot> m >>= \ x -> return (sin x)
12:48:09 <roboguy_> HeladoDeBrownie: ha, that's a bit unintuitive
12:48:21 <ReinH> Cale: sorry, what are "this" and "that" referring to?
12:48:25 <HeladoDeBrownie> well, two out of four letters ain't bad :P
12:48:26 <Cale> ReinH: select
12:48:35 <Cale> ReinH: and the spiel about derivatives
12:48:37 <Cale> respectively
12:48:39 <ReinH> Cale: ah :)
12:48:41 <ReinH> heh
12:49:12 <roboguy_> haha
12:50:10 <Cale> ...and though I didn't bother to mention, I already knew, both times, because I'd read his paper and realised that somehow differentiating data structures was new, even though the very same operations were discussed in my combinatorics course and had been known for quite some years :D
12:50:40 <geekosaur> so the end was a bunch of +1s and then no action. sigh
12:50:50 <Cale> Pretty much
12:51:14 <johnw> learning how to differentiate data structures is like the Haskell equivalent of a thrill ride at a fun park
12:51:16 <ReinH> Cale: He is a big fan of Hancock's Tensor and differentiation, as I've noticed...
12:53:50 <nogod> <nogod> x+2=x - 90% of math majors can't solve this equation!
12:54:38 <ReinH> Here we go again.
12:55:23 <monochrom> should I ban?
12:56:13 <nogod> learn a real language like fortram
12:56:14 --- mode: ChanServ set +o monochrom
12:56:15 * mjrosenb still needs to read the differentiating regular expressions paper.
12:56:20 --- mode: monochrom set +b *!*@141.2.179.78
12:56:20 --- kick: nogod was kicked by monochrom (nogod)
12:56:27 <ReinH> At least they're easy to spot.
12:56:29 <kuribas> What did he do?
12:56:36 --- mode: monochrom set -o monochrom
12:57:05 <arkeet> kuribas: someone who is clearly here just to troll is not welcome.
12:57:54 <ReinH> mjrosenb: differentiating regular expressions, you say...
12:58:14 <ReinH> mjo: http://dl.acm.org/citation.cfm?id=321249 ?
12:58:16 <ReinH> woops
12:58:16 * cmsmcq wonders -- did nogod expect the answer x = aleph_0 ?  or ...
12:58:26 <monochrom> I wonder what x+2=x means as a Haskell definition when NPlusKPatterns is turned on again
12:58:26 <ReinH> No, just trolling.
12:58:43 <ReinH> monochrom: _|_, I expect.
12:58:47 <kuribas> Maybe he wanted to show that it is a divergent computation?
12:59:02 <mjo> ReinH: I was just googling for papers on conic programming and you scared the shit out of me
12:59:03 <arkeet> monochrom: I let x+2 = x, and now when I ask for x it says it's not in scope.
12:59:07 <mjrosenb> ReinH: yup.
12:59:13 <arkeet> in ghci anyway.
12:59:15 <ReinH> mjrosenb: thanks
12:59:20 <ReinH> mjo: Sorry!
12:59:37 <mjo> ReinH: I'm glad you can't see what I'm doing =P
12:59:39 * cmsmcq believes Brzozowski's paper is extremely beautiful and encourages mjrosenb -- and anyone else -- to read it
12:59:39 <HeladoDeBrownie> arkeet, congrats, you just defined (+) :)
12:59:41 <ReinH> mjo: hah
12:59:44 <monochrom> arkeet: that probably simply becomes a local definition of (+)
12:59:49 <ReinH> cmsmcq: :)
12:59:49 <arkeet> oh, yes.
12:59:53 <arkeet> haha
12:59:54 <trolling> somebody called?
13:00:00 <ReinH> cmsmcq, mjrosenb: Added to my list.
13:00:23 <ReinH> Oh hi prophile.
13:00:33 <trolling> hello
13:00:48 <arkeet> I guess I can actually do
13:00:49 <arkeet> let (x+2) = x
13:00:51 <arkeet> and it'll work.
13:00:52 <mjrosenb> cmsmcq: I read like 3/4 of it, but the copy I had was scanned like 40 years after the paper was published, and was basically unreadable.
13:00:53 <monochrom> hrm, even with NPlusKPatterns, "x + 2 = x" still defines (+) not x.
13:01:03 <ReinH> monochrom: Ah
13:01:14 <arkeet> well, work as in define x instead of (+)
13:01:18 <monochrom> ok! 100% of Haskell implementations can solve x+2=x. FSVO "solve" :)
13:01:21 <arkeet> haha
13:01:28 <ReinH> hah
13:01:30 <HeladoDeBrownie> x does indeed diverge defined that way
13:02:02 <monochrom> yeah, thanks arkeet and HeladoDeBrownie
13:02:03 <dolio> arkeet: How about (x + 2) = x?
13:02:14 <arkeet> dolio: yes, I tried that.
13:02:21 <dolio> Oh, right.
13:02:40 <Ralith> monochrom: NPlusKPatterns is getting turned on again?
13:02:46 <dolio> Boy, n+k patterns are great.
13:03:09 <monochrom> nice trick using parentheses to force "I really want this to be a pattern"
13:03:29 <monochrom> Ralith, I added a LANGUAGE pragma myself
13:04:13 <monochrom> it may be a bit mixed up, so, here it is again.
13:04:31 <monochrom> "x + 2 = x" (without parens) is valid Haskell code, always
13:04:56 <monochrom> "(x + 2) = x" (with parens) is valid Haskell code when you have n+k patterns
13:05:45 <kadoban> Wait, maybe I'm being dumb, but what does x + 2 = x mean without n+k patterns?
13:05:53 <arkeet> it defines (+)
13:05:55 <mjrosenb> kadoban: defining (+)
13:05:55 <arkeet> (+) x 2 = x
13:06:04 <kadoban> Oh, hah right.
13:06:05 <kuribas> @hoogle on
13:06:07 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:06:07 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
13:06:07 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
13:06:16 <kadoban> Thanks
13:06:26 <mjrosenb> wait, why does (x + 2) = x not also define (+)?
13:06:41 <dolio> mjrosenb: (x + 2) must be a pattern.
13:06:47 <HeladoDeBrownie> because parens can go around patterns but not whole left-hand sides
13:07:00 <ggVGc> the more I get into haskell, the more I feel I will want to use it for a lot of things
13:07:03 <mjrosenb> ahh.
13:07:10 <HeladoDeBrownie> or, i said that weird, but you probably get it
13:07:19 <arkeet> I think you said it fine.
13:07:24 <monochrom> :)
13:07:36 <ReinH> dolio: I basically only want n + 1 pattern and only when using induction on nats.
13:08:04 <monochrom> ah but, what if you teach fibonacci again :)
13:08:04 <arkeet> pattern Succ n <- (pred -> n) where Succ n = succ n
13:08:16 <arkeet> (if only we had a safe pred)
13:08:39 <Cale> c'mon guys, let's bring back c*n + k patterns :)
13:08:45 <ReinH> ((n + 1) + 1)
13:09:01 <arkeet> wait can we
13:09:02 <monochrom> darn
13:09:07 <ReinH> monochrom: :p
13:09:10 <arkeet> if we could give expression arguments to pattern synonyms we could do
13:09:25 <ReinH> monochrom: (In reality Z and S n are pretty good)
13:09:28 <HeladoDeBrownie> monochrom, what's a definition expressed more succinctly with than without?
13:09:35 <arkeet> pattern (+) n k <- (subtract k -> n) where (+) n k = n + k
13:09:41 <arkeet> where n is a pattern argument, k is an expression argument
13:10:14 <arkeet> well, n is a pattern and expression.
13:10:21 <ReinH> Cale: "[Statutory mathematics warning: differential calculus.]" I do love Conor's writing style though.
13:10:36 <Cale> ReinH: Yeah, it's always great
13:10:49 <HeladoDeBrownie> or, er, i think i highlighted the wrong person
13:11:00 <HeladoDeBrownie> i meant that for Cale
13:11:01 <dolio> arkeet: Kind of important that Succ can fail.
13:11:11 <arkeet> yes.
13:11:15 <arkeet> well
13:11:24 <arkeet> pattern PlusOne n <- (subtract 1 -> n)
13:11:31 <arkeet> seems fine to me.
13:11:39 <ReinH> Cale: Now I want to read about differential structures and comonads.
13:11:39 <monochrom> . o O ( Love is hate. Freedom is slavery. Success can fail. )
13:12:04 <HeladoDeBrownie> monochrom, in the end, all is _|_
13:12:11 <int-e> Cale: how about  f (a^2 + b^2 + c^2) = a+b+c...
13:14:03 <arkeet> we need expression arguments for pattern synonyms.
13:14:05 <arkeet> imo.
13:14:18 <arkeet> because I want to write pattern n :+ k = (subtract k -> n) etc.
13:14:24 <arkeet> er, <-, not =
13:14:41 <mniip> what extension are we discussing?
13:14:52 <arkeet> well, they were discussing NPlusKPatterns.
13:14:58 <arkeet> now I'm talking about PatternSynonyms
13:15:00 <mniip> no, the 'pattern' syntax
13:16:12 <monochrom> that is under the PatternSynonyms extension
13:16:27 <Cale> HeladoDeBrownie: I was mostly joking, but I have run into functions in number theory which were defined by cases essentially pattern matching on 2*n, and then 4*n+1 and 8*n+1 and 8*n+5
13:16:54 <arkeet> that's not exhaustive. you mean 4*n+3?
13:16:56 <HeladoDeBrownie> ah yeah, i've seen functions like that as well
13:16:57 <arkeet> or something
13:17:16 <Cale> er, yeah, something like that :)
13:17:48 <arkeet> something about quadratic residues.
13:18:07 * mjrosenb flails around with types
13:18:10 <Cale> Yeah, I forget which way was preferable in practice
13:18:27 <arkeet> well, I forget where the 8n+1 thing comes from.
13:20:14 <monochrom> yeah, square roots mod n, cube roots mod n, etc, all benefits from "if x = 8n+1, use this algorithm; if x=16n+5, use this other algorithm; ..."
13:20:58 <arkeet> well, square roots mod p^k are easy when p is an odd prime.
13:21:07 <arkeet> there's a bit more trickiness when p = 2
13:21:17 <arkeet> (because derivative of x^2 - a is zero)
13:21:35 <Cale> yeah, 16n + 5 haha
13:22:08 <Cale> I only vaguely remember how all that went. It was fairly traumatic
13:22:44 <ReinH> hah
13:22:55 <MichielDC> I had a course on that, not much left in my head of that
13:24:05 <ReinH> Cale: "and hurrah! D Bag = Bag." Sometimes he is also unintentionally funny.
13:24:58 <roboguy_> woah, I'm getting linker errors on GHC 7.10 for symbols that I define in my project that I'm trying to build
13:25:45 <Cale> ReinH: Even though I don't live there, I really enjoyed http://strictlypositive.org/aberpystoffwyth.html and http://strictlypositive.org/abermorepystoffwyth.html
13:25:57 <ClaudiusMaximus> roboguy_: listed in other-modules?
13:26:19 <ReinH> Cale: "My train from Shrewsbury to Aberystwyth is a bus." off to a wonderful start.
13:26:21 <roboguy_> ClaudiusMaximus: nope, no other-modules
13:27:06 <ClaudiusMaximus> roboguy_: all modules must be listed in the cabal file, whether exposed-modules, other-modules, or main-is (for executables)
13:27:55 <ClaudiusMaximus> roboguy_: there might be other causes of linker missing symbols, but the most common i've encountered is missing naming the module in the cabal file for a library
13:28:08 <roboguy_> ClaudiusMaximus: I built another project that doesn't list things like that just fine a couple minutes ago though...
13:28:24 <roboguy_> also, what do you mean by modules exactly?
13:28:35 <Cale> ReinH: If you've ever heard him talk, you hear the rant in his voice as you're reading it as well. :D
13:28:47 <roboguy_> every module in a project needs to be listed in the .cabal file?
13:28:52 <ReinH> Cale: I haven't, but I have a secret hope to get him on the Haskell Cast this year.
13:28:53 <ClaudiusMaximus> yes
13:29:02 <athan> ski: Where are Compact and Overt defined? :S
13:29:08 <roboguy_> ClaudiusMaximus: is that new in ghc 7.10? I've never run into that before
13:29:26 <Cale> He's given some lectures on dependently typed programming that are worth watching, though iirc, some parts seemed to be missing
13:29:40 <ClaudiusMaximus> roboguy_: no, but i think cabal-install changed how it builds things to make it fail sooner
13:30:06 <meoblast001> hi.. i want to verify something before i go forward beating my brains out debugging..... in Data.ByteString.Lazy.... if i do hSeek, hGet, hSeek, and hGet... this is all non-lazy, right? each of these should work, right?
13:30:07 <ClaudiusMaximus> roboguy_: of course, if you're not building with cabal, ignore me
13:30:24 <meoblast001> i seem to be seeking to some data after doing some hGets, then doing hGet again, and the data is not really what i expect
13:30:37 <meoblast001> i don't know if my seek arithmetic is wrong or if i'm misusing the haskell libs
13:30:43 * hackagebot midi 0.2.1.4 - Handling of MIDI messages and files  http://hackage.haskell.org/package/midi-0.2.1.4 (HenningThielemann)
13:30:50 <Cale> ReinH: https://www.youtube.com/watch?v=XGyJ519RY6Y
13:30:58 <geekosaur> meoblast001, hGet is not lazy. I hope what you are seeking onb is a file (though if it's not then hSeek should throw an exception, not silently fail)
13:31:13 <ReinH> Cale: regarding your point about changes to the Prelude, this is once again a good reason for a custom prelude pragma.
13:31:24 <Cale> oh and here: https://www.youtube.com/watch?v=08sPfcYbN1c
13:31:28 <meoblast001> hmm... so even after doing some hSeeks and hGets, i can safely hSeek and hGet again?
13:31:31 <tnks> hey, are there good papers to read to better explain the difference between Foldable and Traversable?
13:31:35 <ReinH> Cale: thanks!
13:31:42 <meoblast001> geekosaur: yes. i'm working with a file
13:31:49 <tnks> sometimes I feel I understand the difference in a very emperical way.
13:31:49 <Cale> ReinH: I actually just wanted it in Data.List
13:31:51 <roboguy_> ClaudiusMaximus: I am. Listing them in other-modules didn't seem to help. Do I use the file path or the module path?
13:32:10 <ReinH> Cale: The comonad instances from later in the thread
13:32:14 <MichielDC> tnks: Did you read the Typeclassopedia?
13:32:41 <Cale> ah, I forget exactly what I said in the rest of the thread :)
13:32:54 <ClaudiusMaximus> roboguy_: module name (like Foo.Bar, not Foo/Bar.hs)
13:32:59 <tnks> MichielDC: oh yeah, I should re-read that.
13:33:01 <roboguy_> ClaudiusMaximus: hmm, that's what I did
13:33:07 <tnks> just to see if that has what I'd want.
13:33:33 <MichielDC> tnks: There probably are links to articles to articles that will explain furthr
13:33:42 <tnks> MichielDC: yeah, looking now.
13:34:24 * frerich doesn't know why, but watching people giving talks barefooted is somewhat distracting bordering unsettling.
13:34:31 <ReinH> Cale: :)
13:34:56 <Welkin> frerich: like RMS?
13:35:08 <quchen> tnks: A fold reduces a data structure to a simpler value. In particular, there's no fold that, in general, leaves your data structure intact. Traversable allows you to visit each element, and perform actions on a structure without losing the structure.
13:35:20 <frerich> Welkin: Like RMS or Conor McBride, yes.
13:35:45 <roboguy_> frerich: I sort of got used to it because my economics teacher always taught barefoot
13:36:10 <quchen> tnks: And there *is* an "identity traversal", namely fmap. :-)
13:36:17 <meoblast001> geekosaur: okay.. interestingly my arithmetic is wrong :D
13:36:36 <meoblast001> i compared against a friend's implementation of the same thing in C (and his works) and the results we're getting for our seek location are different
13:37:13 <monochrom> meoblast001: I wonder if text mode vs binary mode matters. openBinaryFile ...
13:37:35 <meoblast001> monochrom: i think i'm just doing math wrong
13:39:41 <monochrom> :)
13:40:44 <orbifx> Hahahah... Guess what I have been told a forkIO needs :P
13:40:48 <orbifx> A knife :P
13:41:25 <Cale> orbifx: Are you sure it doesn't need a http://hackage.haskell.org/package/spoon ?
13:41:41 <orbifx> That is what my wife though..
13:44:03 <MichielDC> Is the "What I Wish I Knew While Learning Haskell" page good for learning a subject or more for "I learned this, let's resume and look for some extras"
13:44:39 <Cale> MichielDC: Which page?
13:44:51 <meoblast001> thanks geekosaur 
13:44:52 <frerich> MichielDC: You mean Stephen Diehl's page? I think it's a bit of both.
13:45:13 <MichielDC> yes, Stephen Diehl's
13:45:32 <MichielDC> http://dev.stephendiehl.com/hask/
13:45:46 <Cale> I honestly think a lot of that stuff is okay to save for later :P
13:46:05 <MichielDC> okay :) I did LYAH, now going to start with CIS 194
13:46:18 <Cale> A lot of it is good stuff to know
13:46:25 <Cale> Of course :)
13:46:48 <MichielDC> LYAH is just an appetizer I feel, I wanna get to the real stuff
13:47:26 <kadoban> MichielDC: cis194 is a good idea
13:47:45 <arkeet> @where learnhaskell - MichielDC: here is a list of a bunch of resources
13:47:45 <lambdabot> https://github.com/bitemyapp/learnhaskell
13:47:51 <arkeet> (and a suggested sequence)
13:48:13 <MichielDC> I got that link in my favorites. Going through all of it, bit by bit
13:48:20 <arkeet> :)
13:52:52 <orbifx> Cale: were you looking for info on the threepenny package?
13:53:14 <Cale> orbifx: wasn't me
14:07:19 <kadoban> byorgey: Would something in that old spring13 cis194 class that broke in GHC 7.10.1 be at all interesting to you, or is it pretty well unmaintained at this point? Someone brought one up in #haskell-beginners (homework 7, Editor.hs, the Editor newtype needs to derive Applicative in addition to Monad and the rest)
14:23:35 <ggVGc> I've been looking for a while now but it's not really googleable, what is the <$> function in haskell? or is it part of parsec?
14:24:01 <hpc> it's fmap
14:24:26 <hpc> @hoogle
14:24:28 <lambdabot> No query entered
14:24:28 <lambdabot> Try --help for command line options
14:24:29 <ggVGc> oh, damn
14:24:31 <hpc> :(
14:24:32 <ggVGc> silly me
14:24:33 <ggVGc> thanks
14:24:40 <hpc> use hoogle to look up identifiers
14:24:42 <hpc> or hayoo
14:24:47 <ggVGc> yeah, thanks
14:24:52 <ggVGc> I fogpot about that :)
14:24:54 <hpc> it knows not to ignore half of what you type
14:25:08 <ggVGc> also, it's 4am so I blame that
14:25:46 * hackagebot logic-classes 1.5.1 - Framework for propositional and first order logic, theorem proving  http://hackage.haskell.org/package/logic-classes-1.5.1 (DavidFox)
14:32:32 <byorgey> kadoban: it's pretty much unmaintained
14:32:58 <benzrf> hmm
14:33:09 <kadoban> Okay, thanks. No worries then.
14:33:13 <benzrf> is there a such thing as, like, a type record
14:33:13 <benzrf> or something
14:33:50 <benzrf> hmm nvm
14:35:46 * hackagebot fast-tags 1.0 - Fast incremental vi and emacs tags.  http://hackage.haskell.org/package/fast-tags-1.0 (EvanLaforge)
14:35:56 <quchen> I'm currently working on a one day long workshop to teach a group of interested novices (to Haskell and FP in general) the basics of Haskell. When preparing the slides/live coding, it became clear that I don't know how much one can learn in a minute, hour, day as a beginner. Does anyone here have experience with these kinds of workshops, and maybe pointers which parts I should care about especially?
14:36:48 <hodapp> how 'beginner' are these so-called beginners'
14:37:05 <quchen> Very able in OOP/imperative languages.
14:37:09 <bergmark> quchen: we've held a workshop a few times for professional programmers interested in haskell
14:37:57 <bergmark> quchen: https://github.com/sebastiaanvisser/hands-on-haskell that's took a ~3 hours incl exercises i think
14:38:46 <quchen> bergmark: Excellent, I'll have a look at it. (I wasn't able to find much material on Reddit and the internet in general, although I'm sure it does exist.)
14:39:45 <quchen> One thing I am going to spend quite a bit of time on is discussing how FP answers typical problems solved by OOP, e.g. how module exports serve to hide abstractions.
14:41:03 <quchen> Is there a particularly concise example of how to use typed holes (to demonstrate TyDD in general)? List.map might be a bit simple, Free/>>= a bit rough.
14:41:43 <merijn> quchen: "Everywhere you used to use "undefined""?
14:42:11 <quchen> merijn: undefined is a typechecker gagger, not a function growing helper
14:42:35 <merijn> quchen: It's also a "I wrote the type and will figure the implementation out later"
14:43:10 <merijn> That was like 80-90% of my use of undefined
14:43:12 <quchen> I guess you can sell it as that to unknowing beginners, but I think now that we have Proxy and holes it's mostly a bug waiting to happen
14:43:16 <ReinH> quchen: quick, but predates typed holes: https://www.youtube.com/watch?v=52VsgyexS8Q
14:43:20 <merijn> The typechecker gagger is usually "error"
14:43:20 <ReinH> quchen: less quick https://www.youtube.com/watch?v=DHH5mNaseis
14:43:29 <quchen> ReinH: Is that the data Hole = Hole trick?
14:43:36 <ReinH> quchen: It's in there too.
14:43:50 <ReinH> A couple nice tricks.
14:44:06 <emmruld> I have a type alias, 'type Domain = Set', and I'd like to define either a data declaration (or type alias, or w/e) 'Elem' such that Elem is a subset of some predeclared Domain of size 1.  How do I define 'Elem'?
14:44:07 <ReinH> Methodology can still be applied to typed holes.
14:44:27 <ReinH> emmruld: You want to defile Elem based on the values of Domain?
14:44:30 <ReinH> *define
14:44:35 <emmruld> yes
14:44:39 <ReinH> emmruld: You can't do that.
14:44:50 <ReinH> Unless I am misunderstanding you
14:44:52 <emmruld> I guess that's what a dependent type is?
14:44:59 <ReinH> Yep.
14:45:01 <emmruld> Ok
14:45:14 <EvanR> a type constructor that takes a value is a dependent type
14:45:46 <quchen> bergmark: The first 50 slides are what I already have, that's reassuring. :-D
14:48:04 <tempname11_> what are the news on the dependent types, btw? any active work going on?
14:48:14 <bergmark> quchen: :-)
14:48:55 <emmruld> ReinH: Here's my long-winded problem. I have some sentential sentence (A^B) that has a variety of atomic sentences ['A', 'B'].  I find that many of the functions I'm writing depend on the unique list of atomic sentences present in the given sentence.  Rather than constantly use the function that returns the set of atomic sentences, I'm trying to put it in the type.
14:48:58 <EvanR> tempname11_: see idris
14:49:38 <emmruld> Does it make sense to make a type that given a sentence returns a tuple, (the constructed sentence, the set of atomic sentences present within it)?
14:49:47 <emmruld> or is there a better way to do this?
14:49:47 <arkeet> acme-year is my new favourite silly package, I think.
14:51:06 <quchen> arkeet: The fastest memoization package, at the cost of some flexibility
14:51:19 <arkeet> https://github.com/joeyadams/hs-acme-year/issues/1
14:51:28 <arkeet> quchen: have a look at the implementation.
14:51:33 <EvanR> arkeet: sort of reminds me of copyright <? echo date("Y"); ?>
14:52:14 <quchen> arkeet: Oooh, I remember when it was a constant Int
14:52:39 <arkeet> it never was, it seems
14:53:03 <quchen> Well there was *some* package that did that
14:53:39 <arkeet> I'm sure.
14:55:36 <EvanR> acme-now which exploits zenos paradox
14:55:47 * hackagebot yesod-auth-oauth2 0.1.1 - OAuth 2.0 authentication plugins  http://hackage.haskell.org/package/yesod-auth-oauth2-0.1.1 (PatrickBrisbin)
14:56:20 <tempname11_> EvanR: I've seen Idris, but it's a bit too experimental + a different language. Ideally I wish I could gradually introduce some dependent typing in my existing Haskell programs. Looking forward to year 2035, I guess
14:56:50 <EvanR> tempname11_: well, haskell wasnt designed with dependent types in mind
14:57:09 <roboguy_> tempname11_: from the bit of Idris that I've done, it's pretty much what I'd imagine Haskell would be like if it had dependent types
14:57:12 <EvanR> so if that were to happen it might seem like a c++ism
14:57:22 <ion> https://youtu.be/OZWYohmLKuU “Dependent Types in Haskell: Present and Future”
14:58:04 <ion> https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell
14:58:46 <EvanR> you might think that dependent types implies that you can prove things, which would imply that you need to eliminate bottoms from certain types, but im not sure if thats practical ?
14:58:53 <roboguy_> tempname11_: there are singletons, in Haskell, which get you most of the way I believe
14:59:10 <ion> https://youtu.be/O805YjOsQjI “HIW 2014: Dependent Haskell”
14:59:14 <EvanR> seems like it would require an overhaul
15:00:06 <cygnus> howdy. I am generating haddock for a local cabal sandbox and haddock is generating HTML pages with links that use filesystem paths instead of relative URLs. Is there a way to control this behavior?
15:00:40 <tempname11_> ion, thanks for the links 
15:02:30 <roboguy_> tempname11_: here are a couple more that might be useful https://www.youtube.com/watch?v=rLJ_YyVRKzs and the corresponding website, http://www.cis.upenn.edu/~eir/packages/singletons/
15:05:13 <ion> roboguy: Thanks, hadn’t seen that video.
15:05:38 <roboguy_> ion: sure! Singletons always seemed interesting to me, but I haven't had too much of a chance to play with them yet
15:06:18 <ski> @tell athan see Martín Escardó's work. <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/> and also "Synthetic topology of data types and classical spaces" <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.(pdf|dvi|ps)>
15:06:18 <lambdabot> Consider it noted.
15:08:32 <quchen> bergmark: Is there anything the audience found particularly nice? One thing I always liked was edwardk's speculation function.
15:09:05 <quchen> It demonstrates quite a complicated functionality in a very short definition, and "par" isn't hard to understand as well.
15:09:11 <quchen> (on the surface, that is)
15:19:34 <ion> What’s a nice example of where speculation is useful?
15:19:49 <Pamelloes> I've been looking into making a GUI in Haskell and read some fascinating papers about FRP. However, all of the discussed projects have since been abandoned. What are the current options for FRP?
15:21:03 <ion> pamelloes: I saw a nice talk about a new library, Reflex: https://youtu.be/mYvkcskJbc4
15:21:13 <arkeet> ion: this speculation? http://comonad.com/reader/2010/introducing-speculation/
15:21:42 <ion> arkeet: yeah
15:22:21 <arkeet> hm I thought there were some examples in the talk
15:22:39 <arkeet> it mentions lexing I guess
15:22:44 <arkeet> and huffman decoding
15:23:12 <ion> I don’t suppose the talk is available online? I’ll look at the slides, thanks.
15:23:20 <arkeet> I meant the slides.
15:25:24 <ryantrinkle> Pamelloes, ion: I can assure you that Reflex is quite unabandoned :)
15:25:48 * hackagebot mbox 0.3.1 - Read and write standard mailbox files.  http://hackage.haskell.org/package/mbox-0.3.1 (GershomBazerman)
15:26:01 <hpc> oooooooh
15:26:08 <hpc> that's my kind of library
15:26:15 <EvanR> Pamelloes: for a desktop GUI thing, theres reactive-banana
15:26:56 <EvanR> but for the most part nobody will claim that anything is "really frp"
15:27:59 <Pamelloes> EvanR: good to know
15:35:10 <Pamelloes> ryantrinkle: So Reflex is primarily web-based?
15:35:32 <ryantrinkle> EvanR: I will claim that Reflex is really FRP :)
15:35:56 <ryantrinkle> Reflex itself is a generic FRP system
15:36:26 <ryantrinkle> I've also built a library, reflex-dom, which is for doing DOM manipulation
15:36:43 <ryantrinkle> it works in GHCJS (on the web) and in GHC, using webkit for rendering (but still running all your Haskell natively)
15:37:24 <EvanR> ryantrinkle: can i get a link to something authoritative on it
15:37:53 <EvanR> and informative
15:38:08 <ryantrinkle> EvanR: have you watched the talk?
15:38:18 <EvanR> did you post a link?
15:38:25 <EvanR> i didnt watch any talk
15:38:33 <ryantrinkle> https://www.youtube.com/watch?v=mYvkcskJbc4
15:38:37 <Cale> EvanR: I've posted the link to the talk several times over the past few days :)
15:38:52 <ryantrinkle> https://obsidian.systems/reflex-nyhug/
15:38:55 <ryantrinkle> that's the slides
15:38:57 <EvanR> i havent been paying attention
15:39:04 <EvanR> i found that page
15:39:11 <ryantrinkle> EvanR: I'll be happy to hear your feedback :)
15:39:13 <EvanR> but couldnt figure out how to advance
15:39:17 <Cale> Those slides are so cool :)
15:39:21 <ryantrinkle> EvanR: spacebar or arrow keys
15:39:22 <Cale> arrow keys
15:39:24 <EvanR> ah
15:39:40 <ion> The first time i saw that i tried to view the slides on my phone but failed.
15:39:48 <ryantrinkle> yeah :(
15:39:52 <ryantrinkle> impress.js doesn't support mobile
15:40:10 <ryantrinkle> i didn't build the actual presentation stuff
15:40:14 <ryantrinkle> that's just a js library i integrated
15:40:41 <Cale> It would be pretty interesting to see how well the equivalent written in reflex would run
15:41:00 <ryantrinkle> Cale: yeah, it would be a nice small project
15:41:08 <ryantrinkle> although i've gotta say, impress.js is pretty awesome
15:41:17 <ryantrinkle> it's not really full-featured, but the couple of things it does, it does really nicely
15:43:58 <EvanR> cool
15:45:49 * hackagebot fast-tags 1.0.1 - Fast incremental vi and emacs tags.  http://hackage.haskell.org/package/fast-tags-1.0.1 (EvanLaforge)
16:01:41 <shapr> Any idea if the ubuntu packages will work on debian/jesse ?
16:02:16 <ion> Probably depends on the package.
16:02:49 <shapr> I want to get ghc 7.8, and I'd like to use debian's package manager.
16:02:52 <shapr> ion: what would you recommend?
16:03:13 <ryantrinkle> shapr: hey man, long time no see :)
16:03:32 <ion> shapr: Why would you like to use the package manager? FWIW, this is what i always do: https://gist.github.com/ion1/2815423
16:04:25 <shapr> ryantrinkle: howdy!
16:04:34 <shapr> ion: ok, I'll try that
16:06:20 <octalsrc> has anyone used HDBC for database interaction?
16:06:27 <octalsrc> it seems to be really slow...
16:07:48 <octalsrc> in particular, profiling shows that 96% of time in my program is spent on th e "prepare" function
16:08:03 <octalsrc> that prepares queries
16:08:12 <octalsrc> even though I only call it three times
16:09:08 <octalsrc> actually executing the queries, which I do 2000+ times, apparently doesn't consume a significant amount of time
16:09:53 <seanhess> I'm having trouble with string encodings. I'm parsing an HTML tag with an entity in it: <option>&nbsp; stuff</option>. 
16:09:57 <seanhess> Parsing it as a lazy ByteString
16:10:17 <seanhess> and decodeUtf8 fails when I try to convert it to text
16:10:27 <seanhess> Cannot decode byte '\xa0'
16:10:34 <seanhess> Is there some way to just ignore bytes it doesn't understand when decoding?
16:12:52 <ReinH> Well, is it utf8?
16:13:01 <geekosaur> sounds like something converted it to iso8859-1
16:13:43 <seanhess> ReinH: I'm downloading the webpage with http://hackage.haskell.org/package/wreq
16:13:47 <Eduard_Munteanu> seanhess, if it's supposed to be UTF-8, look at decodeUtf8With. Otherwise perhapse decodeLatin1 is more appropriate.
16:14:02 <geekosaur> (that is, the entity &nbsp; was translated to iso8859-1 where it would indeed be \xa0)
16:14:27 <kadoban> seanhess: Are you use it's actually utf8 to begin with?
16:14:55 <seanhess> kadoban: no, I'm scraping a web page with Wreq
16:16:00 <c_wraith> seanhess: you could be brave and attempt to trust the content-type header. :)
16:16:19 <ReinH> decodeUtf8 probably won't work on something that isn't utf8.
16:16:26 <ReinH> c_wraith: will that tell you the encoding?
16:16:40 <c_wraith> sometimes!  and some fraction of the time it does, it's even correct
16:16:49 <ReinH> That's what I thought.
16:17:07 <seanhess> Content-Type: text/html; charset=UTF-8
16:17:13 <seanhess> well, that doesn't help :)
16:17:46 <seanhess> that's probably what Wreq does under the hood already right? Use Utf8 encoding?
16:18:22 <c_wraith> if it converts the body to Text, yes.  If it just gives you a ByteString, it does no conversion at all
16:19:16 <ReinH> wreq doesn't use any encoding. It provides you with the bytes in the response verbatim.
16:20:18 <seanhess> Gotcha. So, the site definitely *thinks* it's UTF8, but if I show it, I see lots of unicode escapes in it. 
16:21:39 <ReinH> You see literal "\uHHHH" or "\uHHHHHHHH" (where H is a hex digit)?
16:25:41 <seanhess> ReinH: no I see "\160"
16:26:06 <ReinH> Um.
16:26:08 <seanhess> but here's some more info. dumping out the body I get from Wreq looks good. It's when I pass it through TagSoup that it turns into the "\160"
16:27:31 <ReinH> Doesn't tagsoup use something stupid like Char8 for bytestrings?
16:27:37 <seanhess> that's weird because TagSoup is supposed to use the same string format you started with
16:27:46 <ReinH> I think so https://hackage.haskell.org/package/tagsoup-0.13.3/docs/Text-StringLike.html
16:27:55 <ReinH> Well, Char8 is the same format.
16:27:57 <ReinH> as ByteString
16:28:16 <seanhess> That's stupid? Why?
16:28:21 <ReinH> It's just a stupid interpretation that assumes all bytes are characters and all characters are bytes.
16:28:33 <ReinH> So that would explain why it's mangling multi-byte characters.
16:28:43 <ReinH> You might try encoding *before* passing to tagsoup.
16:28:43 <seanhess> Should I convert it to text before I pass it to tag soup?
16:39:12 <SrPx> What is the relationship between Enum and naturals? Aren't those the same idea basically? Why don't we have a "Nat" typeclass?
16:40:35 <seanhess> ReinH: encoding before passing still has some garbled content, but it doesn't crash, so I can just `dropWhile (not . isAlphaNum)` the values to get rid of it
16:40:35 <pavonia> We don't even have a Nat type
16:40:52 <ReinH> pavonia: What do you mean?
16:40:58 <seanhess> ReinH: so thanks! 
16:41:01 <ic2000> what is haskell for
16:41:04 <ReinH> seanhess: welp.
16:41:17 <ReinH> ic2000: Haskell is a general purpose functional programming language.
16:41:28 <SrPx> pavonia: that's the point... but can I just assume Enum == Nat or am I going nuts here
16:41:36 <pacak> > fromEnum (-1 :: Int)
16:41:37 <lambdabot>  -1
16:41:49 <ic2000> what is it compiled too?
16:41:58 <SrPx> pacak: o.o
16:42:02 <pavonia> ReinH: There's no type for natural numbers in the base modules, AFAIK
16:42:23 <SrPx> that... ah. I always assumed Enum had a zero element. Obviously it doesn't. Thanks
16:42:24 <exio4> ReinH: you should have said "a general purpose strongly typed, lazy, and pure, functional programming language" it sounds even cooler!
16:42:38 <exio4> ic2000: that is not a property of the programming language, but the implementation
16:42:51 <pavonia> SrPx: No, it's more for equivalences with Int
16:43:05 <pacak> > (toEnum -1) :: Int
16:43:07 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘Int -> a0’
16:43:07 <lambdabot>      Probable cause: ‘toEnum’ is applied to too few arguments
16:43:07 <lambdabot>      In the first argument of ‘(-)’, namely ‘toEnum’
16:43:16 <pacak> > (toEnum (-1)) :: Int
16:43:17 <lambdabot>  -1
16:43:37 <ReinH> ic2000: GHC compiles to assembly, llvm code, or C. The default is assembly.
16:43:47 <ReinH> (GHC is the de facto standard Haskell compiler)
16:43:54 <ic2000> i'm surprised its so popular, what makes haskell so good?
16:44:05 <pacak> > toEnum (-1 :: Int)
16:44:07 <lambdabot>  *Exception: Prelude.Enum.().toEnum: bad argument
16:44:22 <exio4> ReinH: it is also an interpreter!
16:44:30 <ReinH> Also true.
16:44:30 <arkeet> pacak: defaults to ()
16:44:47 <monochrom> https://docs.google.com/presentation/d/1a4GvI0dbL8sfAlnTUwVxhq4_j-QiDlz02_t0XZJXnzY/preview?sle=true&slide=id.p is why haskell is good
16:44:53 <arkeet> pacak: only because lambdabot/ghci have extended defaulting
16:45:07 <arkeet> monochrom: we should put that in a @where.
16:45:07 <pavonia> ic2000: Static type checking is one of the major features, IMO
16:45:34 <monochrom> and http://www.slideshare.net/ScottWlaschin/fp-patterns-buildstufflt slide 13
16:45:43 <arkeet> that one too.
16:47:40 <ReinH> And they're gone/
16:54:32 <pacak> I have this newtype Derp which exists only to avoid using UndecideableInstances because otherwise ghc complains on something beign no smaller than something. Is there any better ways to write derpMangle?
16:54:32 <pacak> newtype Derp a = Derp { unDerp :: a }
16:54:32 <pacak> derpMangle :: ConfigValue (Derp a) => a -> a
16:54:32 <pacak> derpMangle = unDerp . mangleValue . Derp
16:55:09 <ReinH> pacak: What's the error you get without it?
16:55:35 <arkeet> UndecidableInstances isn't necessarily bad.
16:55:51 <pacak> http://stackoverflow.com/questions/7198907/haskell-constraint-is-no-smaller-than-the-instance-head - this
16:55:56 <cfoch> hello, people
16:55:58 <cfoch> do you know
16:56:05 <cfoch> where can I find information about "IIModule" ?
16:56:10 <arkeet> ah, that one is bad.
16:56:14 <arkeet> because it will overlap with everything.
16:56:50 <cfoch> IIModule appears in some documentation page, but I can't find it now :S
16:57:03 <arkeet> (because when resolving instances it only looks at the instance head, not the context.)
16:57:04 <pacak> Mine probably won't overlap with everything:
16:57:05 <pacak> instance (Show a, Enum a, Eq a, Bounded a) => ConfigValue (Derp a)
16:57:15 <arkeet> no, yours is perfectly fine.
16:57:32 <cfoch> It doesn't appear neither in hoogle nor hayoo
16:57:36 <arkeet> oh yes, you'd need toe newtype.
16:57:46 <arkeet> the*
16:57:52 <dfeuer> No, undecidable is not real bad. Overlapping scares me away, and incoherent is insane.
16:58:34 <arkeet> undecidable instances just means instance resolution may not terminate. but that's a compile-time issue.
16:58:36 <dfeuer> (Undecidable is often only undecidable because FlexibleInstances and FlexibleContexts don't use proper termination checkers)
16:59:28 <arkeet> cfoch: well, ask again when you find it.
17:00:17 <cfoch> arkeet: that doesn't make sense :S I would like to have the link to the documentation of IIModule
17:00:24 <cfoch> or the module it belongs to
17:00:26 <__ryan> hi what is does this error means? - Couldn't match type ‘Entity record0’ with Images
17:00:26 <__ryan> Expected type: Images -> Value
17:00:34 <arkeet> cfoch: where do you see the reference to IIModule?
17:00:39 <roboguy_> __ryan: we'll need more context
17:00:49 <arkeet> __ryan: post your code and the full error message
17:00:53 <arkeet> @where lpaste
17:00:54 <lambdabot> http://lpaste.net/
17:01:19 <cfoch> I found it, I think
17:01:20 <cfoch> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc/GHC.html
17:01:31 <Eduard_Munteanu> Sounds like a 'persistent' error.
17:01:40 <arkeet> cfoch: that's just the name of a constructor for the InteractiveImport type.
17:01:42 <arkeet> it's defined right there.
17:04:10 <arcaed0x> Hi there , can somebody help my get some glfw code working ?
17:04:20 <__ryan> here is the code - http://lpaste.net/130662
17:05:11 <yukko> hi, is there any example code somewhere that will tell me how to use a function that returns a pointer to a struct in haskells ffi?
17:05:54 <enthropy> pacak: if you can rewrite class ConfigValue a b c d, you can avoid using UndecidableInstances (but you need a bunch of other extensions like TypeFamilies and MultiParamTypeClasses)
17:06:04 <__ryan> arkeet: http://lpaste.net/130662
17:06:12 <__ryan> roboguy: http://lpaste.net/130662
17:07:38 <enthropy> people actually do that trick in http://hackage.haskell.org/package/vinyl-0.5.1/docs/Data-Vinyl-Lens.html#t:RElem
17:08:02 <roboguy_> __ryan: it looks like entityIdToJSON converts an Entity a to a Value, not a Images
17:09:24 <mgsloan> __ryan: Yup, so this means that you probably want a "instance ToJSON (Entity Images)"
17:09:35 <pacak> enthropy: I can - I wrote this class. As for vinyl - I ended up removing it from the project because it was updated at least twice with "hey, we know how to do much better, but you'll have to rewrite all your code" approach.
17:10:57 <__ryan> mgsloan: i tried your suggestion but it say's No instance for (ToJSON Images)
17:10:57 <__ryan>   arising from a use of entityIdToJSON
17:12:09 <enthropy> pacak: I mean you can write  instance (Show a, Enum b, Eq c, Bounded d, a ~ b, a ~ c, a ~ d) => ConfigValue a b c d, but then what have you gained by having a class with just a single instance?
17:12:52 <pacak> enthropy: There are a bunch more instances all defined with generics  and some - manually.
17:12:55 <Eduard_Munteanu> __ryan, where does entityIdToJSON come from?
17:13:21 <__ryan> Eduard_munteanu: http://haddocks.fpcomplete.com/fp/7.8/20140916-162/persistent/Database-Persist-Class.html#v:entityIdToJSON
17:14:07 <Eduard_Munteanu> __ryan, oh, then you definitely don't want that... for Images, you define the instance as for any data type.
17:14:14 <mgsloan> __ryan: You probably want "instance ToJSON Images" without a where clause.  This will use the Generic instance to implement conversion to JSON.  In order to support that you'll need to add "Generic" to the deriving clause in your model
17:14:57 <Axman6> data Foo = ... deriving (Show, Generic); instance ToJSON;
17:16:50 <Eduard_Munteanu> (and import GHC.Generics)
17:17:10 <__ryan> mgsloan: how do i do that? can you edit my paste? http://lpaste.net/130662
17:18:41 <Eduard_Munteanu> Just replace 'deriving Show' by 'deriving (Show, Generic)'
17:18:41 <pharpend> Hey everyone. I have this file, trying to figure out how to make it not horrible and recursive http://lpaste.net/130663
17:18:44 <mgsloan> __ryan: edited it!
17:19:08 <mgsloan> Eduard_Munteanu: That would usually be the case, but persistent models have different syntax for that
17:19:09 <enthropy> pacak: I'm suggesting the trick RElem does is an option, but probably non-ghc compilers support undecidable instances before TypeFamilies
17:20:03 <pharpend> At the moment, if I run "louse --help", I get this infinite recursive string of help messages
17:20:29 <pacak> pharpend: It's trying to be very helpful I guess.
17:21:02 <pacak> pharpend: optparse-applicative?
17:22:17 <pharpend> I don't care for that library
17:22:22 <pharpend> I like console-program a lot
17:22:28 <pharpend> But it's quite verbose
17:22:36 <pharpend> My attempt to refactor it isn't panning out so well
17:22:43 <fragamus> why do you not like optparse
17:23:09 <fragamus> I was asking around recently which one to use and I ended up with optparse
17:25:09 <pharpend> fragamus: I have a pretty simple program. http://lpaste.net/130665
17:25:16 <pharpend> fragamus: I've tried using optparse
17:25:40 <pharpend> At this point, though, optparse is apparently the best option.
17:25:57 <pharpend> ruby has a really nice option-parsing library, maybe I should port that over
17:26:39 <pacak> pharpend:  https://hackage.haskell.org/package/optparse-applicative-0.11.0.2 
17:26:51 <pharpend> pacak:see my last paste
17:27:03 <Axman6> awhy don't you like about optparse-applicative? you've only said you don't care for it, not given any reasons. and the code needed to use it is a hell of a lot shorted and imo, clearer than your paste
17:27:12 <pharpend> Yeah
17:27:34 <pharpend> It's too verbose, but it's apparently the best option in Haskell
17:27:52 <Axman6> hmm, actually, your paste is optparse,... why is it so verbose? mine have never been'
17:27:57 <pharpend> Ruby has a very nice option parser: http://ruby-doc.org/stdlib-2.1.0/libdoc/optparse/rdoc/OptionParser.html
17:28:33 <pharpend> But it reeks of imperative programming
17:28:53 <arkeet> and haskell is the best imperative programming language
17:28:54 <arkeet> :-)
17:28:58 <EvanR> all the ruby dsls are imperative, and they are implemented with method missing hacks
17:28:59 <barrucadu> There's also docopt, although I don't know how actively mainteined the Haskell version is
17:29:13 <barrucadu> *maintained
17:29:15 <pharpend> well, someone managed to port RSpec to Haskell, I suppose I could port optparse to Haskell
17:29:25 <EvanR> rspec :(
17:29:40 <pharpend> HSpec is actually pretty nice
17:30:09 <barrucadu> https://hackage.haskell.org/package/docopt -- you write your help text and it uses that to parse the arguments
17:30:29 <pharpend> last updated a month ago
17:33:49 <solirc> pharpend, barrucadu: Personally, I don't think docopt is that nice of an approach.
17:34:12 <pharpend> ow
17:34:14 <pharpend> oops
17:34:17 <pharpend> wrong window
17:34:51 <solirc> I really liked scala's optional approach when I first saw it
17:35:14 <solirc> pharpend, barrucadu: There is something similar for Haskell under active development https://github.com/zalora/getopt-generics
17:37:13 <pharpend> ow
17:37:16 <pharpend> god dammit
17:37:56 <pacak> pharpend: ಠ_ಠ
17:38:01 <fragamus> WRONG CRETIN!!
17:38:47 <pharpend> pacak: I use a weird keyboard layout in which the o is in the place where the : usually is. So, I've configured Emacs such that ow is the same as :w
17:39:45 <__ryan> mgsloan: i updated the model together with the error - http://lpaste.net/130662
17:41:25 <__ryan> mgsloan: i updated the paste together with the error - http://lpaste.net/130662
17:42:00 <schell> what’s the profiling tool that has a nice web interface that displays ghc’s runtime statistics? 
17:42:40 <arkeet> ekg?
17:42:48 <schell> arkeet: yes! that’s it
17:42:49 <schell> thanks
17:42:58 <arkeet> np
17:42:58 <Eduard_Munteanu> __ryan, you can use your entityIdToJSON definition for the Entity Image instance
17:44:49 <__ryan> Eduard_Munteanu: how? :-) sorry very newbie
17:45:54 <yukko> how do i go from Ptr a -> IO a?
17:46:04 <Eduard_Munteanu> __ryan, add   instance FromJSON (Entity Images) where parseJSON = entityIdToJSON
17:46:33 <Eduard_Munteanu> Er.
17:46:47 <Eduard_Munteanu> __ryan, add   instance ToJSON (Entity Images) where toJSON = entityIdToJSON
17:48:20 <__ryan> Eduard_Munteanu: i have same error as before..
17:48:28 <Eduard_Munteanu> yukko, peek
17:48:30 <Eduard_Munteanu> :t peek
17:48:31 <lambdabot> Not in scope: ‘peek’
17:48:35 <Eduard_Munteanu> @hoogle peek
17:48:37 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
17:48:37 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
17:48:37 <lambdabot> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
17:48:43 <yukko> ah! thank you!
17:49:38 <Eduard_Munteanu> __ryan, did you add that, or replaced the instance? You should add it.
17:51:54 <Eduard_Munteanu> __ryan, I edited your paste to be clear
17:55:16 <__ryan> Eduard_Munteanu: thank you it works :)
17:55:20 <__ryan> thank you everyone :)
18:15:41 <byorgey> gfixler: https://github.com/byorgey/type-matrices/blob/master/type-matrices.pdf
18:17:51 <shachaf> byorgey: *Now* you have a PDF.
18:19:02 <shachaf> byorgey: Figures 10 and 11 seem to be invisible?
18:21:25 <shachaf> (And 6.)
18:21:48 <roboguy_> Figure 9 too
18:22:13 <fryguybob> Strange, I see all of them
18:22:51 <byorgey> it seems that if you view it in github's PDF viewer the figures disappear.  Just download it and view it in a real PDF viewer and they show up fine.
18:22:59 <arkeet> yeah, real pdf viewer works.
18:23:02 <byorgey> also, please don't give me a heart attack like that.
18:23:09 <fryguybob> hehe
18:23:21 <shachaf> Oh, each time I look at different figures are missing.
18:23:32 <shachaf> I guess it's a Github bug.
18:24:08 <arkeet> heh
18:27:22 <kadoban> github has their own pdf viewer? :-/
18:28:17 <kvda> it could be the pdf.js thing
18:32:49 <lpaste> ryanar pasted “Help with Cont monad” at http://lpaste.net/5300668784967680000
18:32:51 <Ryanar> Hey guys, I am having trouble implemeting the Cont Monad in my code
18:38:51 <Ryanar> to be clear, I understand the CPS style, I am not sure how to abstract it with the Cont Monad
18:40:36 <arkeet> well first of all
18:40:42 <arkeet> (Maybe Integer -> Maybe r) -> Maybe r is
18:40:48 <arkeet> ContT r Maybe (Maybe Integer)
18:41:12 <arkeet> Ryanar
18:41:14 <Ryanar> hm
18:41:23 <arkeet> ContT r m a = (a -> m r) -> m r
18:41:24 <Ryanar> haha sorry distracted by my roommates cheese cutter
18:41:57 <Ryanar> what is ContT?
18:42:11 <Ryanar> a different Monad?
18:43:32 <arkeet> ContT is not Cont.
18:43:40 <arkeet> Cont r a = (a -> r) -> r
18:43:55 <arkeet> (well, ContT r m a = Cont (m r) a
18:44:01 <arkeet> (but they're different monads)
18:44:06 <Ryanar> ah ok
18:50:58 * hackagebot monad-skeleton 0.1 - An undead monad  http://hackage.haskell.org/package/monad-skeleton-0.1 (FumiakiKinoshita)
18:51:23 <eacameron> crazy idea: Given an operator :: (m a, m b) -> m (a, b).  If it were overloaded for many tuple sizes, then calling multiple-argument monadic functions could look and feel much more like in imperative languages
18:51:51 <Axman6> :(
18:51:57 <eacameron> doSomething <#> (readLine, getLine, pure stuff)
18:53:04 <roboguy_> eacameron: which imperative language?
18:53:52 <eacameron> oh, pretty much most of the major ones; the idea is that you could call effectful functions and give their results to other effectful functions
18:54:15 <eacameron> it's the same as join $ doSomething <$> readLine <*> getLine <*> pure stuff
18:54:30 <eacameron> but that is a bit rough for an imperative coder
18:54:43 <eacameron> I'm trying to find ways to ease the transition for my colleagues
18:54:54 <roboguy_> ah
18:55:17 <roboguy_> (<#>) = =<< ?
18:55:29 <slack1256> Mmm I don't think that is more easy
18:55:36 <roboguy_> yeah...
18:55:40 <eacameron> probably plus uncurry
18:56:09 <srhb> I think hiding the distinction of applying to something "effectful" as you say, and something pure, might make it more confusing.
18:56:13 <srhb> Still, worth a try I guess.
18:56:17 <Axman6> instance (Num a, Monad m) => Num (m a) where ... why is this a bad idea (with simple liftM2 instances)
18:56:20 <roboguy_> it's slightly wordier, but at first using <- in do notation might be easiest
18:56:43 <eacameron> roboguy_: yes, simple <- is the easiest
18:56:48 <slack1256> Axman6: Num kind of assumes the operations on the objects are commutative
18:57:23 <srhb> slack1256: What operations?
18:57:28 <Axman6> hmm, yes that may be problematic
18:57:32 <glguy> Axman6: Right off the bat it would collide with the Num instance for stuff like base's Ratio and linear's types
18:57:44 <slack1256> srhb: (+), (-), (*)
18:57:52 <Axman6> glguy: how so? they aren't monads are they?
18:57:53 <glguy> (though it might work out for linear)
18:57:57 <eacameron> roboguy_: I mentioned it here primarily to tease out any already-existing idea or a better one
18:57:58 <glguy> Axman6: Ratio isn't
18:58:11 <roboguy_> eacameron: what about idiom brackets?
18:58:24 <eacameron> roboguy_: yeah, that would help I'll bet
18:58:35 <eacameron> still have to "join" at the end though I think
18:58:37 <srhb> Do we have idiom brackets?
18:58:39 <srhb> :o
18:58:44 <roboguy_> that's true
18:58:49 <eacameron> perhaps a simple alias would help "run = join"
19:00:05 <eacameron> that would be a bit simpler for newcomers: "run (doSomething <$> a <*> b <*> c)" or "run [i|doSomething a b c|]"
19:00:13 <roboguy_> srhb: well, there are quasiquoters for it. Actually, I think someone managed to do it without template haskell or quasiquoting too (!)
19:00:35 <srhb> roboguy_: Yeah, this https://gist.github.com/mpickering/99d62ccdb73f49840220
19:00:40 <srhb> Rather funky :P
19:00:40 <eacameron> roboguy_: I'd be interested in that...
19:00:57 <roboguy_> eacameron: well, while we're doing splices you could throw the run call into the [i| splice too
19:01:00 <roboguy_> let's see...
19:01:13 <roboguy_> srhb: oh, yep that's what I was thinking of
19:09:13 <siwica> Is there a function (2 arguments) that concatenates two lists? 
19:09:19 <arkeet> (++)
19:09:29 <siwica> (not concat :: [[a]] -> [a])
19:09:31 <siwica> ah ok
19:09:39 <slack1256> > [2,3] ++ [4,5]
19:09:40 <lambdabot>  [2,3,4,5]
19:10:21 <glguy> ++
19:10:54 <pacak> [2,3] <> [4,5]
19:10:56 <pacak> > [2,3] <> [4,5]
19:10:57 <lambdabot>  <no location info>: can't find file: L.hs
19:11:04 <pacak> > [2,3] `mappend` [4,5]
19:11:06 <lambdabot>  [2,3,4,5]
19:12:15 <slack1256> > [2,3] <
19:12:16 <lambdabot>  <hint>:1:8:
19:12:16 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
19:12:20 <slack1256> > [2,3] <> [4,5]
19:12:21 <lambdabot>  [2,3,4,5]
19:15:27 <dmj`> why can I not derive instances for MonadBaseControl IO, MonadBase IO ?
19:15:50 <dmj`> newtype A a = A a { runA :: StateT Int IO a } deriving (MonadBaseControl IO)
19:16:11 <dmj`> "Cannot make a derived instance even w/ cunning newtype deriving"
19:17:42 <roboguy_> dmj`: hmm. Well, sometimes you can write a newtype that can't borrow the "parent" type's instances
19:18:37 <slack1256> dmj`: I though not all classes had deriving mechanism
19:18:51 <arkeet> dmj`: GeneralizedNewtypeDeriving, right?
19:18:52 <roboguy_> slack1256: generalized newtype deriving works for any classes
19:18:54 <roboguy_> sort of
19:18:58 <arkeet> roboguy_: no it doesn't.
19:19:09 <roboguy_> yeah, I exaggerated
19:19:10 <arkeet> :p
19:19:23 <dmj`> arkeet: yes
19:19:33 <dmj`> arkeet: tried standalone deriving as well
19:20:27 <monochrom> "newtype A a = A a { runA :: StateT Int IO a }"?  "newtype A a = A { runA :: StateT Int IO a }"?
19:21:20 <arkeet> dmj`: it can't be derived because the types of the MonadBaseControl methods aren't coercible.
19:21:47 <roboguy_> slack1256: generalized newtype deriving just borrows the instances from the type you're wrapping (when that's possible)
19:21:58 <dmj`> monochrom: apologies, yes, that is a typo in IRC
19:21:58 <dmj`> monochrom: the latter is correct
19:22:25 <arkeet> dmj`: behind the scenes it uses 'coerce' to coerce a method on the base type to a method on the newtype.
19:22:30 <dmj`> arkeet: because of the type family?
19:22:30 <arkeet> when that doesn't typecheck it fails.
19:22:34 <arkeet> I don't know.
19:22:42 <arkeet> maybe.
19:22:52 <arkeet> actually it might be that, not a coerce thing.
19:23:48 <roboguy_> I actually remember trying to derive MonadBaseControl using generalized newtype deriving one time and running into that issue
19:23:58 <arkeet> on 7.8+?
19:24:00 <arkeet> or before
19:24:13 <arkeet> old GeneralizedNewtypeDeriving is unsafe.
19:24:20 <dmj`> I'm on 7.8
19:24:31 <arkeet> but if it didn't work there it would have been some problem other than coerce.
19:24:47 <arkeet> dmj`: what's the full error message?
19:27:12 <dmj`> -- src/Main.hs:23:55-73: Can't make a derived instance of ‘MonadBaseControl IO A’ …
19:27:13 <dmj`> --       (even with cunning newtype deriving):
19:27:13 <dmj`> --       the class has associated types
19:27:13 <dmj`> --     In the newtype declaration for ‘A’
19:27:13 <dmj`> -- Compilation failed.
19:27:13 <dmj`> arkeet: ^
19:27:20 <arkeet> well that's why.
19:27:25 <arkeet> you can't derive classes with associated types.
19:29:16 <dmj`> arkeet: so I guess this means I actually have to understand MonadBaseControl
19:29:30 <dmj`> arkeet: I just want to use lifted-async really
19:30:12 <arkeet> dmj`: nah, you just need to understand the types.
19:31:01 <arkeet> dmj`: you can define StT to be a newtype wrapper around the base StT.
19:31:14 <arkeet> and then you should be able to coerce the individual methods 
19:31:17 <arkeet> using Data.Coerce.coerce
19:31:24 <arkeet> or you can do the coercion yourself.
19:31:30 <arkeet> maybe you can't coerce them.
19:31:32 <arkeet> yeah you can't.
19:31:42 <dmj`> arkeet: I see what it's doing, the type synonym tells you which monad to reconstitute, control $ \st -> do print "hi"; x <- st get; st put (x + 1) 
19:32:01 <arkeet> like
19:32:36 <arkeet> oh you know why else it won't work.
19:32:39 <arkeet> you have a kind error.
19:33:00 <arkeet> MonadTransCntrol :: ((* -> *) -> (* -> *)) -> Constraint
19:33:17 <arkeet> while A has kind * -> *
19:33:20 <newsham> > plot (\n -> 4 + 2 * sin (0.2*n) + 1 * sin(0.3*n)) 0 80
19:33:22 <lambdabot>  ⣀⠤⠒⠒⠒⠤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⠤⠤⠤⠤⠤⣀⠀⠀⠀⠀⠀⠀⢀⡠⠔⠒⠒⠢⢄⡀⠀
19:33:22 <lambdabot>  ⠀⠀⠀⠀⠀⠀⠀⠉⠒⠒⠒⠒⠊⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠑⠢⠤⠤⠤⠒⠁⠀⠀⠀⠀⠀⠀⠈⠑
19:33:39 <arkeet> you might have to go newtype A m a = A { runA :: StateT Int m a }
19:33:40 <dmj`> arkeet: this is MonadBaseControl though
19:33:40 <dmj`> not Trans
19:33:40 <dmj`> pretty sure
19:33:44 <arkeet> oops.
19:34:04 <dmj`> (* -> *) -> (* -> *) -> Constraint
19:34:04 <arkeet> sorry I was reading the wrong docs.
19:34:37 <arkeet> anyway, just define like
19:35:02 <arkeet> newtype StM A a = MyStM (StM (StateT Int IO) a)
19:35:03 <arkeet> or something
19:35:08 <arkeet> in your instance definition
19:36:16 <ion> newsham: nice
19:36:33 <arkeet> ion: see -blah :-)
19:36:40 <arkeet> oh you're not there.
19:36:43 <monochrom> that looks like a maliciously recursive type
19:36:53 <arkeet> monochrom: it's an associated type.
19:39:12 <pavonia> arkeet: Where does that A come from?
19:39:53 <arkeet> pavonia: the point is he made a type A, and he needs some class instance for A.
19:40:00 <arkeet> the class has an associated data type called StM.
19:40:02 <arkeet> https://hackage.haskell.org/package/monad-control-0.3.1/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl
19:41:46 <pavonia> Oh well, that's over my head
19:43:43 <dmj`> monad-control is not intuitive
19:44:46 <rvxi> hi
19:46:51 <sydneyhacker> Hi can anyone help me with http://www.seas.upenn.edu/~cis194/spring13/hw/06-laziness.pdf ex6?
19:47:22 <sydneyhacker> I want to translate this into Haskell code: Q = (a0/b0) + x((1/b0)(A
19:47:22 <sydneyhacker> ' − QB'
19:47:23 <sydneyhacker> )).
19:47:54 <nisstyre> sydneyhacker: what have you tried so far? use the paste link in the topic
19:48:08 <slack1256> why don't you put the coefficient of the polinomial on a list
19:48:13 <sydneyhacker> But Q is described in terms of itself
19:48:13 <slack1256> and do something with zipWith?
19:48:44 <nisstyre> so you're supposed to calculate the expansion lazily
19:48:46 <nisstyre> I guess
19:49:56 <sydneyhacker> nisstyre: ok maybe it will work because we have already calculated the first element of Q, so Haskell remembers this when you refer to Q the second time?
19:50:24 <sydneyhacker> I'll just shut up and write the code see what happens in the REPL
19:50:32 <nisstyre> sydneyhacker: well, if you're using something likst a list then you can use the initial value to calculate the next one
19:50:35 <nisstyre> and so on
19:50:40 <nisstyre> *like
19:52:04 <rvxi> what's the preferred book between programming in haskell vs. RWH?
19:52:32 <nisstyre> do you mean LYAH?
19:52:39 <sydneyhacker> rvxi: have a read of http://bitemyapp.com/posts/2014-12-31-functional-education.html
19:53:16 <rvxi> proggramming in haskell by graham hutton
19:53:25 <rvxi> not lyah
19:53:34 <nisstyre> I know, I'm asking if that's what you want
19:53:40 <nisstyre> but I've never read Hutton
19:55:04 <rvxi> naw i've gone through some of a lyah
19:55:23 <rvxi> it was useful to get some basic commands but i'm not a huge fan of the teaching style
19:55:31 <monochrom> sydneyhacker: if you have seen "john = 0 : john", even "jon = 0 : map (+ 1) jon", you will see that Q is a similar idea, just more exaggerated
19:56:29 <sydneyhacker> monochrom - it has clicked it is like Fibonacci (which still seems magic to me) fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
19:56:47 <monochrom> yeah
20:00:49 <dmj``> arkeet: ping
20:05:19 <Cale> rvxi: Those two books are quite different. Hutton's book is very good at what it does, but it doesn't do a huge amount of real world stuff. It's a very nice introduction that for the most part restricts itself to very pretty examples in which to demonstrate the basic features of the language.
20:06:08 <rvxi> cale: thanks for the comment. that makes sense
20:06:59 <yukko> hi, i am having a problem with withCAString, i am passing it a valid String, but whne my c function sees it, its just \0
20:07:08 <yukko> i see lots of (null) memory exhausted!
20:07:25 <yukko> is it not being allocated? its a pretty long string...
20:08:04 <Cale> Wait, withCAString, not withCString? Which library is that from?
20:08:11 <Cale> oh, it is there
20:08:29 <yukko> yeah
20:08:45 <yukko> this is in ghci by the way, but -fobject-code isnt helping
20:09:16 <Xnuk> :t plot
20:09:48 <Cale> yukko: Could you put your program on lpaste.net? I could try to run it and see if I can see the same thing.
20:12:04 <rvxi> join #haskell-beginners
20:16:48 <Cale> rvxi: by the way, don't hesitate to ask beginner questions here
20:16:57 <lpaste> Martin pasted “cis194 spring 13 homework 6 ex 6” at http://lpaste.net/130673
20:17:20 <sydneyhacker> that is my solution seems to work
20:17:33 <Cale> rvxi: That channel's name kind of annoys me, because it might lead people to think that this channel is somehow inappropriate for beginner discussions, which is emphatically not the case.
20:18:46 <Cale> sydneyhacker: btw, there are tab characters in your code, you'll definitely want to configure your text editor to turn them into spaces for you.
20:19:38 <Cale> sydneyhacker: (this is because the compiler will treat tabs as aligning to the next multiple of 8 spaces, but people's editors are inconsistent about how they're treated, and it can affect the meaning of code)
20:19:50 <sydneyhacker> Cale: Thanks
20:19:53 <arkeet> fortunately -fwarn-tabs is the default in 7.10 now
20:20:51 <monochrom> \∩/
20:21:03 * hackagebot Xorshift128Plus 0.1.0.0 - Pure haskell implementation of xorshift128plus random number generator.  http://hackage.haskell.org/package/Xorshift128Plus-0.1.0.0 (hkanai)
20:39:57 <yukko> i think ive narrowed this down a bit, somehow \0's are being inserted instead of newlines
20:39:57 <yukko> i cant imagine why
20:40:53 <jsk> Hey all I'm having some issues with setting up emacs in haskell mode, boring I know, but any help would be appreciated. Specifically I either can't get interactive mode started and get this error in the minibuffer: https://www.dropbox.com/s/ebk3ku2465urnqg/Screenshot%202015-04-13%2020.29.45.png?dl=0 and AFAICT i'm enabling what needs to be enabled in my .emacs here: 
20:40:57 <jsk> https://gist.github.com/jskulski/55de3efaae2563c76836
20:43:17 <pharpend> Hey guys. I have this literate Haskell file: http://lpaste.net/130674, and it's generating this documentation: https://a.pomf.se/nnpbqk.png
20:43:31 <pharpend> You'll notice that there's no module description
20:43:38 <jsk> and when I can get it running hitting RET or ('haskell-interactive-mode-return) doesn't do anything
20:43:52 <pharpend> I have other files that are normal Haskell, where the documentation works as expected
20:44:08 <ReinH> pharpend: I accidentally went to http://lpaste.net/13067 (off by one error) and was very confnused
20:44:26 <pharpend> ReinH: heh
20:44:58 <monochrom> pharpend: haddock comments must be "--" comments or "{-" comments, not literate comments.
20:45:03 <ReinH> pharpend: I think haddock comments have to be in -- | and -- ^ etc haddoc blocks even in literate haskell
20:45:08 <pharpend> monochrom: well that's annoying
20:45:11 <ReinH> Oh, or {- -}
20:45:13 <ReinH> pharpend: Agree.
20:45:22 <pharpend> sort of defeats the point of literate haskell
20:45:30 <ReinH> And yet there it is.
20:45:30 <monochrom> therefore, for example, you have to write "> -- | don't use this function"
20:46:00 <pharpend> ReinH: I like your suggestion of {- (stuff) -}
20:46:19 <monochrom> I am not convinced that it defeats the point of literate haskell. in fact, I am inclined to think that it reinforces the point.
20:46:38 <monochrom> the point of literate programming, especially as Knuth invented it, is for *internal* documentation
20:47:02 <monochrom> explaining why you choose a particular algorithm and other implementational details likewise.
20:47:19 <ReinH> monochrom: well, literate haskell is a fair ways away from the way Knuth *originally*  intended literate programming to be...
20:47:36 <monochrom> this is, clearly, exclusive of haddock's purpose: external documentation, i.e., how to use this stuff, don't tell me what twists you use to implement it
20:48:25 <ReinH> oh cool, you *can* still get WEB http://www-cs-faculty.stanford.edu/~uno/cweb.html
20:48:40 <ReinH> Somehow I missed it last time I looked despite it being in the google resultss
20:49:10 <ReinH> The question, of course, is whether you can still get them to compile. Maybe I'll write a Haskell version.
20:49:28 <shachaf> And you have to use it, too, to compile any of his programs.
20:50:00 <ReinH> shachaf: Indeed.
20:50:20 <monochrom> I think I know why haddock does it.
20:50:41 <monochrom> suppose in a *.lhs file, there is a line "> f x = x"
20:51:12 <ReinH> shachaf: I do have a copy of the Stanford GraphBase somewhere though.
20:51:37 <monochrom> is this a Haskell definition? is this part of a haddock comment?
20:51:46 <yukko> why is newCString replacing my newlines with null bytes
20:51:51 <yukko> i cant understand this at all
20:52:11 <yukko> has anybody else ever had this problem
20:52:37 <monochrom> no, I have never had this problem
20:53:12 <yukko> im looking at it in a hex dump and its identical to the source file except every 0A byte is 00
20:56:21 <ReinH> It seems unlikely that a bug like that would go unnoticed until now...
20:57:58 <heatsink> yukko: Doesn't for me
21:01:55 <Moggle1> i would like to take this moment to reflect on how wonderful the STM monad is
21:02:00 <jle`> hear hear
21:02:00 <Moggle1> no deadlocks <3
21:04:49 <Jeanne-Kamikaze> way to go man, way to go
21:05:03 <yemibedu> this language intrigues me.
21:06:05 * hackagebot Xorshift128Plus 0.1.0.1 - Pure haskell implementation of xorshift128plus random number generator.  http://hackage.haskell.org/package/Xorshift128Plus-0.1.0.1 (hkanai)
21:06:09 <ReinH> yemibedu: excellent...
21:06:17 <Hijiri> it's a pretty fun lang
21:07:01 <yemibedu> i try to go back nad forth with Ocaml
21:07:07 <Hijiri> If you are interested in doing a few lessons you can check https://github.com/bitemyapp/learnhaskell
21:07:13 <yemibedu> mostly reading the ML variants
21:08:38 <yemibedu> cool. can cabal be easily isolated when it loads projects?
21:10:20 <oconnore> yemibedu: like sandboxes?
21:11:22 <yemibedu> i like to put projects into a single folder based on language and under an IDE workspace.
21:12:13 <yemibedu> i like the package management notion. i just like to control if it is third party style.
21:12:34 <srhb> Calling cabal-install a package manager is a bit much, but it does have sandboxes that are self-contained.
21:12:41 <yemibedu> oh and i am on open suse 12.3
21:13:41 <yemibedu> i will read up more on cabal to get comfortable. thank you.
21:14:04 <srhb> yemibedu: cabal sandbox init -- now any package installed from within that directory will go into that particular sandbox
21:14:28 <rasen_> Hi! What papers I can read to learn more of Haskell's type system?
21:14:40 <erikd> can someone remind me, what's the really really unsafe version of unsafePerformIO ?
21:14:52 <srhb> erikd: The interleave one?
21:15:12 <srhb> Or Dupable?
21:15:40 <srhb> unsafeDupablePerformIO might be executed more than once.
21:15:44 <erikd> srhb: there's one with a really hilarious comment in the docs. i need a cheap laugh :-)
21:16:08 <srhb> Hm, no idea.
21:17:04 <srhb> rasen_: There are some references here, but most are not about the type system: http://www.reddit.com/r/haskell/comments/2blsqa/papers_every_haskeller_should_read/
21:17:12 <ryantrinkle> accursedUnutterablePerformIO
21:17:47 <HeladoDeBrownie> unsafeCoerceUnsafelyPerformedIO :: IO a -> b
21:18:36 <srhb> ryantrinkle: Beautiful.
21:18:55 <srhb> "Safety by Scary Names" is totally a Haskell feature.
21:19:22 <heatsink> untypedApply :: forall a b. a -> a -> b -> (forall c. c)
21:19:29 <HeladoDeBrownie> invokeDreadPresence :: Sacrifice -> IO ()
21:19:31 <heatsink> untypedApply :: forall a b. a -> b -> (forall c. c)
21:19:51 <erikd> accursedUnutterablePerformIO actually exists -> https://github.com/haskell/bytestring/blob/master/Data/ByteString/Internal.hs#L617
21:21:24 <srhb> also known as unsafeInlineIO?
21:21:44 <jle`> also known as puppiesAndRainbowsIO
21:22:41 <srhb> unsafePrimToPrim looks fun, too!
21:25:00 <SrPx> Why can't I write `(@) a b = b` ? Is there a list of valid operator characters?
21:25:21 <cwraith> SrPx: @ is as-pattern syntax
21:26:03 <SrPx> Is there any single character that is not a letter that I can overload and will not collide with prelude?
21:26:03 <cwraith> SrPx: it is a valid operator character, but not by itself.  Just like -> isn't a valid operator character
21:26:05 * hackagebot dataflow 0.5.1.0 - Generate Graphviz documents from a Haskell representation.  http://hackage.haskell.org/package/dataflow-0.5.1.0 (owickstrom)
21:26:30 <HeladoDeBrownie> SrPx, varsym here https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4
21:26:46 <Maxdamantus> > let a @ b = 4 in a + b
21:26:47 <lambdabot>  8
21:27:26 <HeladoDeBrownie> SrPx, this contains a more complete listing. you can look up varsym and anything it references https://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17700010.2
21:28:02 <SrPx> alright, thank you!
21:34:18 <jle`> lol Maxdamantus 
21:35:12 <jle`> @ is valid but you can't use it alone
21:35:26 <HeladoDeBrownie> > let a@b@c@d@e = a:b:c:d:e in a
21:35:27 <jle`> > let a *@ b = a + b in 1 *@ 3
21:35:28 <lambdabot>      Occurs check: cannot construct the infinite type: a1 ~ [a1]
21:35:28 <lambdabot>      Relevant bindings include
21:35:28 <lambdabot>        a :: [a1] (bound at <interactive>:1:5)
21:35:29 <lambdabot>  4
21:36:00 <jle`> just like "--" can't be an operator, but "--&" can
21:36:24 <jle`> > let a -- b = a + b
21:36:25 <lambdabot>  <hint>:1:19:
21:36:25 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
21:36:31 <jle`> > let a -- b = a + b in 1 -- 3
21:36:33 <lambdabot>  <hint>:1:29:
21:36:33 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
21:36:38 <jle`> > let a --& b = a + b in 1 --& 3
21:36:39 <lambdabot>  4
21:36:49 <jle`> ...just in case you didn't believe me i guess >_>
21:41:06 * hackagebot dataflow 0.5.2.0 - Generate Graphviz documents from a Haskell representation.  http://hackage.haskell.org/package/dataflow-0.5.2.0 (owickstrom)
21:51:06 * hackagebot streaming-commons 0.1.12 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.12 (MichaelSnoyman)
21:56:06 * hackagebot dataflow 0.5.3.0 - Generate Graphviz documents from a Haskell representation.  http://hackage.haskell.org/package/dataflow-0.5.3.0 (owickstrom)
22:01:18 * hackagebot network-conduit-tls 1.1.1.1 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-1.1.1.1 (MichaelSnoyman)
22:02:59 <nshepperd_> SrPx: apparently, the monad you were looking for is 'data M b a = Done b | Step b a' with (Monoid b). supporting 'tell :: b -> M b ()' and 'halt :: M b x'
22:06:05 <srhb> https://hackage.haskell.org/package/acme-year -- This package is amazing.
22:06:09 <srhb> I can get the year without doing IO!
22:08:03 <ryantrinkle> srhb: lol
22:08:06 <ryantrinkle> that's an amazing package
22:08:14 <ryantrinkle> the source is even better than i was expecting
22:08:17 <srhb> Truly. It seems there was a bug in it until sometime in february...
22:08:22 <srhb> :-)
22:10:07 <heatsink> It needs a quickcheck test to verify that year always returns the same value.
22:10:27 <heatsink> Otherwise it's an impure function, which would be unsafe
22:10:50 <srhb> heatsink: Trust the types!
22:12:25 <heatsink> Hah, there's a benchmark to measure how fast currentYear is computed
22:12:45 <Axman6> srhb: it was out of date for like a week this year. pretty unacceptable imo
22:13:01 <Axman6> oh maybe it was until Feb
22:14:10 <srhb> Axman6: Granted, that's not so good. But people should expect breakage at certain points in software (or earth) cycles.
22:27:31 <Axman6> srhb: this is true
22:31:08 <mjrosenb> in Reactive.Banana, someone said that there is a way to perform an action ecery time an event fires, other than using reactimate.
22:31:17 <mjrosenb> how exactly can you do this?
22:35:15 <solatis> hmmm if i'm looking to write an API against a HTTP server that returns JSON responses, is WAI the library I'm looking for? it appears as if WAI clients can only talk with WAI servers?
22:37:02 <solatis> i think i might just use Network.HTTP.Conduit for this
22:40:11 <solatis> ah, wreq might be what i'm looking for
22:40:58 <Axman6> solatis: Servant is pretty nice for that (though possible a bit young)
22:41:28 <Axman6> it also lets you produce clients based on the type of the server you've defined
22:42:17 <solatis> hmmm seems like a little bit of overkill for my purpose though
22:42:48 <solatis> otoh, servant-client looks pretty nice
22:43:09 <Axman6> it's really simple if you're just making a JSON based REST API (the next version will support multiple return encodings)
22:45:07 <solatis> yeah it looks nice
22:46:52 <solatis> it looks almost like they're modelling a HTTP API as you would model a database
22:47:00 <solatis> in similar fashion to packages such as `persistent`
22:48:09 <Axman6> solatis: there was discussion of doing the same thing for databases last week in #servant
22:48:31 <solatis> interesting
22:49:30 <solatis> this is pretty sweet actually
22:49:41 <solatis> you only have to focus on writing what your API looks like
22:49:56 <solatis> and all the "cruft" of writing the boilerplate is done for you
22:50:08 <solatis> which not only makes for less code, but it makes what the API looks like a lot more clear
22:57:11 <Moggle1> I'm creating a number of child threads from a main thread, but the main thread ends after and this will kill the process. Is there a standard way to say "yeah just ignore this thread" better than forever $ return ()
22:57:11 <Moggle1> ?
22:57:36 <Moggle1> the program is intended to run permanently
22:57:48 <mniip> Moggle1, MVars
22:58:03 <edofic> you could newMVar () >>= readMVar 
22:58:20 <Moggle1> is that more efficient? will forever $ return () actually consume CPU?
22:58:20 <edofic> sorry: newEmptyMVar >>= readMVar
22:58:22 <mniip> pass an MVar into every thread you launch, and fill it when the thread ends
22:58:32 <mniip> and in the main thread just read all MVars
22:58:35 <Moggle1> mniip: the threads will never end themselves
22:58:49 <mniip> are they killed?
22:58:53 <Moggle1> they are never killed
22:58:57 <Moggle1> the threads will run forever
22:59:05 <Moggle1> i mean in theory there could be an exception
22:59:06 <mniip> well then the MVar will never be filled
22:59:26 <mniip> there's barely any other way
22:59:33 <Moggle1> then edofic's solution is the most efficient?
22:59:40 <Moggle1> forever $ return () actually consumes CPU cycles?
22:59:53 <mniip> I think last time I faced this issue someone suggested forever $ threadDelay 1000
23:00:08 <monochrom> 1000 is too small
23:00:18 <Moggle1> would that be more efficient, or no?
23:01:22 <edofic> dead locking a thread (reading from forever empty mvar) will never schedule the thread to consume any cpu
23:01:34 <Moggle1> ah, so that sounds better than threadDelay
23:01:36 <Moggle1> thanks!
23:01:46 <mniip> edofic, except for the deadlock resolution system
23:01:47 <SrPx> nshepperd_: looks like it... is that a subset of the writer monad? ON hackage?
23:02:04 <monochrom> you will run into: "thread blocked indefinitely in an MVar operation"
23:02:17 <monochrom> and more importantly, termination.
23:02:28 <mniip>  > newEmptyMVar >>= readMVar
23:02:28 <mniip> *** Exception: thread blocked indefinitely in an MVar operation
23:02:59 <edofic> so how is waiting for child thread to fill in mvars on completion better?
23:03:23 <Moggle1> oh, so that method doesn't work?
23:04:18 <mniip> edofic, that doesn't throw
23:04:43 <monochrom> you will have to give the MVar to some other thread, and that some other thread seems like it may do a writeMVar to it (but there is a non-obvious infinite loop before it), to trick the runtime system
23:05:00 <Moggle1> that's very annoying
23:05:06 <Moggle1> i think i'll stick to the threadDelay
23:05:26 <Moggle1> cleaner code trumps slightly more efficient code in this case
23:05:46 <mniip> who the hell even came op with this
23:06:08 <mniip> you can fix id, but you can't newEmptyMVar >>= readMVar
23:06:16 <monochrom> someone who was hurted by deadlocks
23:06:34 <mniip> but this is haskell
23:06:41 <mniip> a deadlock might be exactly what a person might want
23:07:01 <monochrom> be careful what you say about fix id. I think there is another thing in the runtime system for it.
23:07:39 <edofic> i'm still waiting for this to throw: do m <- newEmptyMVar; forkIO (readMVar m); readMVar m
23:08:32 <monochrom> indeed, "main = do { evaluate (fix id); putStrLn "hello" }" --> "<<loop>>" and termination
23:10:05 <Moggle1> according to old #haskell logs, you could read from something
23:10:09 <nshepperd_> SrPx: I don't know if it's on hackage. It has the same shape as MaybeT (Writer b), but different implementation since 'halt' stops the writer part as well
23:10:31 <Moggle1> that's still very hacky
23:11:44 <Moggle1> forever $ threadDelay maxBound will simply have to do.
23:12:01 <nshepperd_> SrPx: http://lpaste.net/130681
23:13:53 <HeladoDeBrownie> @hackage async
23:13:54 <lambdabot> http://hackage.haskell.org/package/async
23:13:59 <HeladoDeBrownie> Moggle1, you might find that package handy
23:15:11 <Moggle1> thank you HeladoDeBrownie, this is nice and straightforward.
23:16:08 <dmj_> Yea use async for everything, unless you are confident in your masking ability.
23:16:49 <monochrom> I am Zorro and I have masking skill, clearly
23:16:54 <SrPx> Ah awesome :) 
23:16:59 <mjrosenb> If I'm in a directory, and I have foo/bar/Baz.hs, why would import foo.bar.Baz not work?
23:16:59 <monochrom> oh wait, that blows my cover
23:17:38 <Moggle1> it is a pity this package is not core, it's always annoying having to add these things to cabal files
23:17:46 <dmj_> mjrosenb: what is your module name
23:18:05 <monochrom> mjrosenb: need capital case
23:18:23 <dmj_> Who wants to give me a monad-control tutorial
23:18:32 <mjrosenb> monochrom: oh yeah, they're capitals.
23:18:47 <SrPx> uhm so it works for any monoid? 
23:18:56 <mjrosenb> dmj_: Reactive/Banana/SDL2.hs is the file, and 
23:19:10 <mjrosenb> Reactive.Banana.SDL2 is the module.
23:19:30 <mjrosenb> ok, now I need to figure out how to use sandboxes
23:20:00 * mjrosenb has a local copy of SDL2, how do I ask cabal install within a sandbox to install that copy of it?
23:20:02 <dmj_> mjrosenb: if you import the module names found in the hackage docs you should have no issues
23:20:10 <HeladoDeBrownie> Moggle1, it's something to get used to. everything necessary being in base is probably an unattainable dream, even if it were desireable.
23:20:12 <mjrosenb> dmj_: this is not in hackage
23:20:19 <mjrosenb> dmj_: this is a module that I am working on.
23:20:56 <dmj_> mjrosenb: ok, do cabal sandbox init in the root directory (where your cabal file is)
23:21:07 <monochrom> mjrosenb: I have R/S.hs and its content "module R.S where x = ()". in ghci, ":load R.S" works.
23:21:21 <mjrosenb> dmj_: done.
23:21:50 <nshepperd_> SrPx: yeah
23:22:01 <dmj_> mjrosenb: Ok now cabal build
23:22:06 <dmj_> Voila
23:22:27 <mjrosenb> dmj_: errr...
23:22:40 <monochrom> "voila" is a safe thing to say.
23:22:55 <monochrom> if you run into success quickly, "voila"
23:23:03 <monochrom> if you run into failure quickly, "voila"
23:23:11 <glguy> Regarding threadDelay maxBound, there was a bug about that but the bug tracker is perpetually stalled
23:23:21 <mjrosenb> dmj_: I have /home/mjrosenb/projects/SDL2 and I want to use that in /home/mjrosenb/projects/RBS2
23:23:22 <dmj_> mjrosenb: still issues?
23:23:35 <mjrosenb> monochrom: violins are more apropriate.
23:23:36 <monochrom> if neither happens quickly, your computer works hard, "voila"
23:23:52 <dshad> guys, is there any way to save and restore type of data?
23:23:55 <petercommand> <<loop>>, "voila"
23:24:06 <glguy> Ticket 7325
23:24:14 <dmj_> mjrosenb: now you must cabal sandbox add-source /home/mjrosenb/projects/SDL2
23:24:17 <dshad> something like safeCast :: Typeable a => TypeRep -> b -> a
23:24:38 <monochrom> glguy: is it possible that the bug tracker is running threadDelay maxBound? :)
23:24:41 <dmj_> Then cabal install --dependencies-only
23:24:55 <dmj_> Then cabal build
23:25:11 <dmj_> Then voila
23:25:48 <dmj_> dshad: there is a safe way to coerce yes
23:25:51 <mjrosenb> dmj_: ahh. let me try that.
23:27:06 <mjrosenb> dmj_: oh, does /home/mjrosenb/projects/SDL2 need to have a sandbox in it?
23:27:24 <dmj_> No
23:28:58 <mjrosenb> dmj_: https://gist.github.com/6366b33f60f2de25cdb1
23:29:21 <dmj_> @typ cast
23:29:22 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
23:29:36 <dmj_> dshad: ^
23:29:41 <dshad> dmj: I know about it
23:30:03 <dshad> the problem is that I don't know types a and b beforehand
23:30:27 <dshad> so I need to save info about a type in TypeRep (or something) and then restore it
23:30:33 <dmj_> dshad: are you sure you're doing it right... Why no types
23:31:20 <dmj_> mjrosenb: you need to init the sbox in your project, then (while in your proj dir) add source to sdl2
23:31:36 <dmj_> I think you're in the wrong directory
23:32:28 <dmj_> dshad: what are you trying to do
23:32:32 <dshad> dmj_: I am trying to implement heterogenous list and want to map over it with polymorphic function
23:32:37 <dshad> for example id
23:32:39 <mjrosenb> dmj_: I am in ~/projects/reactive-banana-sdl2, and I ran cabal sandbox init; cabal install linear; cabal sandbox add-source /home/mjrosenb/projects/sdl2
23:33:18 <mjrosenb> dmj_: because reactive-banana-sdl2 depends on sdl2, not vice versa.
23:35:14 <mjrosenb> ahh, I ran the first few commands in src/, not src/..
23:35:14 <dmj_> mjrosenb: add source them both into your project then cabal will handle it
23:35:47 <Moggle1> System.FilePath is the standard for playing around with things, right?
23:35:51 <Moggle1> or is there a better standard package
23:35:52 <arkeet> if you could pass a TypeRep around separately and use it to cast, things would be Very Unsafe
23:36:03 <Moggle1> all i know is something has the </> operator to add file paths.
23:36:42 <arkeet> dshad: 
23:36:48 <dmj_> dshad: why not make a special type. data MyThing = MyInt Int | MyString String. Then myList :: [MyThing]
23:36:51 <arkeet> what other polymorphic functions would you want to map over it with?
23:37:15 <arkeet> heterogenous lists aren't widely useful.
23:37:28 <arkeet> chances are you can accomplish what you want to do without them.
23:38:17 * dmj_ thinks arkeet is right
23:39:20 <Moggle1> @hoogle [a] -> (a -> b) -> [b]
23:39:22 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
23:39:22 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
23:39:22 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
23:39:27 <arkeet> Moggle1: flip map
23:39:34 <Moggle1> i'd like it as an operator
23:39:37 <Moggle1> like <$>
23:39:40 <arkeet> (<&>)
23:39:45 <Moggle1> is that in the standard library
23:39:46 <Moggle1> ?
23:39:49 <arkeet> don't think so.
23:39:52 <dmj_> Not yet
23:39:56 <luzie> :)
23:39:59 <Moggle1> all i want is pretty code
23:40:05 <Moggle1> :(
23:40:08 <Moggle1> oh well thanks for the help
23:40:11 <arkeet> just define (<&>) = flip fmap
23:40:14 <dmj_> 😃
23:40:22 <arkeet> or import it from lens
23:40:31 <Moggle1> lens has it by default? sweet.
23:40:36 <Moggle1> import control.lens for everyone!
23:41:27 <mjrosenb> https://gist.github.com/5959f465c5a42a7143b5 *sigh*
23:41:52 <arkeet> maybe import pqueue qualified.
23:41:58 <Moggle1> quick sanity check: fp <- getAppUserDataDirectory <&> (</> "someFile.dat") is not an insane way to do things right?
23:42:14 <Moggle1> is there a better way to write it?
23:42:20 <arkeet> seems alright.
23:42:30 <arkeet> I'd personally flip it around and use <$>
23:42:54 <arkeet> or fmap
23:43:01 <Moggle1> since it's manipulating a directory i thought it made more sense in this order, but yeah that could work.
23:43:09 <arkeet> up to you.
23:43:16 <Moggle1> as long as it's not obviously insane.
23:46:56 <mjrosenb> arkeet: the problem is in the PQueue module.
23:49:07 <srid> now that I understand the details, but it is great to see ruby people using Haskell: https://blog.pusher.com/porting-the-pusher-integration-tests-to-haskell/
23:54:30 <hpd> hi! How can I show a float with _at most_ n digits after the decimal point? Eg for 2 digits: 0.1 -> "0.1", 0.123 -> "0.12". showFFloat from Numeric sounds like it does that, but it always prints n digits. Eg 0.1 -> "0.10"
23:55:00 <mjrosenb> ok, pqueue from hackage failed to build in a sandbox.
23:55:13 <mjrosenb> I made a local copy of it, and papered over the issue
23:55:32 <mjrosenb> how do I get cabal to discard the unpacked file that is won't build?
