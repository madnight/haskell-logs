00:06:40 <solatis> wasn't there some language extension to make pattern matching / case expressions easier with lambdas ?
00:06:55 <MP2E> LambdaCase?
00:07:28 <solatis> ah!
00:07:29 <solatis> yes
00:07:39 <solatis> apparently "pattern matching" wasn't the right term for this
00:08:16 <frerich_> I love LambdaCase :-)
00:08:25 <MP2E> yeah me too :)
00:13:02 <faorien> Hello. I'm using vim with ghc-mod and rely on the that plugin heavily. I have recently introduced a module with FFI bindings and now ghc-mod doesn't work. I found some threads where people ask how to solve it but haven't found anything yet. Has anyone been able to find a workaround how to make ghc-mod work (in vim if possible) when there is at least one module with foreign import?
00:14:41 <smoores> can someone help me wrap my head around the evaluation order of the expression (1-1) <= 0 || null
00:15:21 <mauke> that's a type error
00:15:45 <mauke> > (1-1) <= 0 || null
00:15:46 <lambdabot>      Couldn't match expected type ‘Bool’
00:15:46 <lambdabot>                  with actual type ‘t0 a0 -> Bool’
00:15:46 <lambdabot>      Probable cause: ‘null’ is applied to too few arguments
00:16:07 <smoores> i'm sorry, (1-1) <= 0 || null []
00:16:10 <mauke> > (1-1) <= 0 || null []
00:16:11 <lambdabot>  True
00:16:38 <monochrom> (1-1)<=0 is evaluated first because the definition of || asks about it first
00:16:40 <mauke> ok, so let's put everything in prefix form first: (||) ((<=) ((-) 1 1) 0) (null [])
00:16:48 <mauke> now the outermost thing is ||
00:16:56 <mauke> @src (||)
00:16:57 <lambdabot> True  || _ =  True
00:16:57 <lambdabot> False || x =  x
00:17:09 <mauke> || starts by examining its first argument
00:17:33 <mauke> so we have to do (<=) ((-) 1 1) 0 next
00:17:35 <smoores> pause
00:17:44 * mauke pauses
00:17:45 <smoores> how does the compiler conclude that (||) comes first
00:18:02 <mauke> standard precedence rules
00:18:18 <mauke> <= binds tighter than ||, and function application binds tighter than any operator
00:18:39 <frerich> mauke: Do you know whether there's a way to make ghci print the precedence of some function?
00:18:50 <mauke> frerich: :i should do it, I think
00:18:52 <smoores> :info
00:18:59 <frerich> Ah, indeed!
00:19:01 <smoores> i'm almost following what you're saying
00:19:04 <mauke> frerich: try :i elem
00:19:10 <frerich> mauke: Yeah, that works, thanks.
00:19:25 <mauke> smoores: it's like 1 + 2 * 3 means 1 + (2 * 3) because * binds tighter than +
00:19:29 <smoores> where is the hole in my logic, (<=) has a higher precedence than (||), why is it not evaluated first
00:19:40 <mauke> because precedence has nothing to do with evaluation order
00:20:15 <smoores> ok, gears turning now
00:20:28 <mauke> consider the following C expression: f() + g() * h()
00:20:37 <mauke> you don't know which order the functions will be called in
00:20:38 <monochrom> highschool conflates parsing and evaluation for simplicity. in haskell they are separate. precedence is for parsing only
00:20:56 <mauke> (C doesn't specify an evaluation order for most expressions)
00:21:53 <smoores> so is evaluation order determined left to right converting to prefix notation
00:22:18 * frerich notices that he's been using ':i' in ghci all along, but always only with classes because he thought it stood for ':instances' or so...
00:23:00 <mauke> evaluation order is outside in
00:23:17 <mauke> you start with the outermost function. the rest depends on what that function does
00:23:34 <mauke> e.g. || examines its first argument, so that's needed next
00:23:48 <mauke> if || examined its second argument, it would go the other way
00:23:58 <smoores> ok, i understand now
00:24:01 <mauke> > error "boom" || True
00:24:02 <lambdabot>  *Exception: boom
00:24:20 <mauke> > let _ || True = True; x || _ = x in error "boom" || True
00:24:21 <lambdabot>  True
00:24:37 <mauke> now it short-circuits "the wrong way"
00:25:31 <smoores> makes sense
00:26:03 <smoores> last remaining point of confusion, what is a thunk and how does it apply to the expression i mentioned (also am i correct in calling that entire loc an expression)
00:27:09 <monochrom> a thunk is an implementation detail for "expression not yet evaluated"
00:27:41 <mauke> if it has a value, it's an expression
00:28:37 <solatis> interesting, so what does it means if an exception is thrown at a THUNK ?
00:29:05 <mauke> when going into ||, we had unevaluated arguments ((<=) ((-) 1 1) 0) and (null [])
00:29:13 <mauke> those would be stored as a thunk
00:29:19 <solatis> ah right
00:29:37 <solatis> so "expression not yet fully evaluated" would be better
00:31:34 <shachaf> "fully evaluated" (in the sense of "normal form") is a tricky concept.
00:32:25 <mauke> (\x -> x x) (\x -> x x) -- "this isn't even my final form"
00:32:35 <opqdonut> or rather, it is
00:32:46 <opqdonut> (\x -> x x x) (\x -> x x x) -- "this isn't even my final form"
00:33:32 <monochrom> that is not true. here is an example: "(1+1) : []" i.e. "(:) (1+1) []", where (1+1) is not yet evaluated. because the outmost thing is data constructor (:), a haskell evaluator considers it "done" not "thunk". however, it has a child thunk.
00:35:09 <mauke> oh, right
00:35:56 <mauke> ... or is it?
00:37:53 <monochrom> since we are talking about thunks, which are an implementation detail, I can take liberty to choose a compiler and use the terminology and distinction used by its authors.
00:39:03 <monochrom> among GHC authors, (:) (1+1) [] is a saturated application of a data constructor, and distinct from thunks.
00:39:09 <mauke> the galaxy is at peace
00:42:01 <monochrom> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects#Typesofobject
00:42:30 <monochrom> the category headings "data constructors" and "thunks" are separate. there are others.
00:44:28 * hackagebot mtl-c 0 - Monad transformers using continuation passing style  http://hackage.haskell.org/package/mtl-c-0 (FumiakiKinoshita)
00:44:56 <monochrom> this is why I do not recommend talking about thunks. it is usually beside the point if you are not actually looking at low-level bytes and bits.
00:53:35 <Ferdirand> Hello #haskell. How much does it help to fully grok Traversable and Foldable before tackling lenses ?
00:54:03 <shachaf> Do you mean lenses or the package lens?
00:54:11 <Ferdirand> the package lens
00:54:15 <Ferdirand> well
00:54:17 <jle`> Ferdirand: it depends on what you actually want to do
00:54:22 <jle`> do you want to use lens practically?
00:54:24 <jle`> then, maybe.
00:54:28 <jle`> do you want to implement the lens library?
00:54:30 <jle`> then yes, it helps a lot.
00:54:52 <shachaf> I would say that it helps a lot (but also that they aren't very complicated classes, so it's not very hard).
00:55:01 <Taneb> Ferdirand, I think tackling lens could help you to grok Traversable and Foldable
00:55:05 <shachaf> Traversal is probably the core type of lens.
00:55:58 <shachaf> Well, at least it was a few years ago. :-)
00:56:03 <Ferdirand> actually, I have this secret project that aims to be a hachoir in haskell
00:56:13 <fumieval> understanding traversals (the essence of iterator patterns) is quite helpful to create your own lenses without depending on the lens package
00:56:59 <Ferdirand> so monadic parsing works well, i have a little DSL to describe file formats, all good
00:57:14 <Ferdirand> now I want it to not only do parsing but also building or edition
00:57:26 <Ferdirand> looked like lenses might be the way to go
00:57:35 <CMCDragonkai> [Roger Qiu] hachoir?
00:58:43 <Ferdirand> the python thing that is essentially wireshark for files instead of packets
01:00:21 <CMCDragonkai> [Roger Qiu] what can you do with it?
01:01:56 <Ferdirand> pretty-print binary data formats as hierarchical trees, possibly interactively edit some fields
01:02:36 <Ferdirand> but with the python thing, defining custom formats is a bit awkward
01:03:02 <CMCDragonkai> [Roger Qiu] like editing excel files?
01:03:17 <Ferdirand> could be an example
01:04:51 <Ferdirand> the format is quite messy, if i remember correctly ? mini-FAT inside a file
01:05:27 <CMCDragonkai> [Roger Qiu] basically helps reverse engineer binary files i guess
01:05:47 <CMCDragonkai> [Roger Qiu] like potentially inspecting msgpack messages
01:05:57 <Ferdirand> right
01:06:01 <mauke> what's up with this "[Roger Qiu]" thing?
01:06:12 <Ferdirand> it could be useful for fuzzing too
01:06:47 <Ferdirand> mauke: some weirdly configured IM to irc bridge, I presume ?
01:07:36 <CMCDragonkai> [Roger Qiu] yea
01:07:44 <CMCDragonkai> [Roger Qiu] kato sameroom.io irc
01:08:26 <Ferdirand> anyway, on a slightly unrelated topic, i just wrote this Traversable t => Foldable t instance, that was mind-blowing on two levels
01:08:53 <CMCDragonkai> [Roger Qiu] how mind blowing was it!?
01:09:01 <jle`> Ferdirand: congrats :)
01:09:15 <Ferdirand> i used a custom weird const functor
01:09:31 <jle`> how about implementing `fmap` in terms of Traversable/
01:09:33 <jle`> ?
01:09:58 <Ferdirand> so first, the realization that this weird const functor can be used to turn a chain of <*> into a chain of <>
01:10:36 <Ferdirand> and second, something i don't recall observing before, about constrained instances
01:11:02 <jle`> can you think of any other `f`s besides Const that will let you do it? :)
01:11:13 <Ferdirand> well Identity if i'm not mistaken
01:11:18 <jle`> (albeit more or less efficiently)
01:11:18 <Ferdirand> that's much easier
01:11:35 <jle`> i don't think you can do it with Identity (implement Foldable via Traversable)
01:11:48 <Ferdirand> you said fmap ?
01:11:54 <jle`> ah yea,h fmap with identity
01:12:06 <jle`> but in that sentence i was referring to other ways to implement Foldable via Traversable
01:12:10 <shachaf> Ferdirand: That's not unrelated to lens, it's one of the main ideas of lens.
01:12:20 <jle`> it all comes down to picking the right Applicative `f`, right?
01:12:32 <Ferdirand> so what was weird to me was
01:12:46 <Ferdirand> it was clear how using Identity turns traverse into fmap
01:12:47 <jle`> (see if there are any other f's you can imagine that will let you do toList, foldMap, etc.)
01:12:54 <Ferdirand> now to turn traverse into foldMap
01:13:28 <Ferdirand> i was looking for ideas of other applicatives
01:13:38 <jle`> Const is one a lot of people use, yeah
01:13:39 <Ferdirand> not realizing i was allowed to use the Monoid constraint in my applicative definition
01:14:09 <Ferdirand> well
01:14:12 <Ferdirand> :t foldMap
01:14:13 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
01:14:15 <Ferdirand> :t traverse
01:14:16 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
01:14:42 <Ferdirand> somehow, i am forced to have m ~ f (t b), no ?
01:14:53 <jle`> well
01:15:01 <jle`> you can get some f (t b), and then use a function to turn it into an m
01:15:13 <shachaf> Const m is the only one you need for various choices of m.
01:15:50 <jle`> you did this in the case with using Const.  you got a result that is Const m (t ()), and you used getConst to get an m
01:16:05 <Ferdirand> right
01:16:16 <Ferdirand> oh right
01:16:50 <Ferdirand> but
01:16:57 <Ferdirand> if i want this to work for any traversable t
01:17:29 <Ferdirand> i still need a generic way to get an m out of a f (t b)
01:17:41 <jle`> Ferdirand: that's what the argument of foldMap gives you
01:17:53 <jle`> oh
01:18:12 <jle`> you use traverse to traverse with some function on your `t a` to get a Const m (t ()).
01:18:21 <solatis> ok, this might be an extremely biased question, but: when is it appropriate to use lens?
01:18:35 <solatis> are there any disadvantages to exposing your data structures as lenses?
01:18:44 <jle`> you get to chose what f and b your `f (t b)` is.
01:18:56 <solatis> shouldn't lenses be kind of the default, since they're much more flexible than regular accessors ?
01:18:57 <jle`> this choice comes from the fact that you can use any (a -> f b).
01:19:32 * hackagebot persistent-postgresql 2.1.4 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-2.1.4 (MichaelSnoyman)
01:19:46 <jle`> so you just use the (a -> f b) that gives you a final f (t b) that you like.  in this case, you used something to get a final Const m (t ())....which you can get for any arbitrary Traversable t
01:20:15 <jle`> you just want something that works over any Traversable, right?  so this works over any Traversable t.
01:20:56 <jle`> solatis: there was a post a while ago that suggested that exposing record accessors instead of lenses was less future-proof
01:21:22 <solatis> jle`, in other words, using lenses is *more* future-proof?
01:21:34 <jle`> yes, because you might chose to change the underlying implementation
01:21:57 <solatis> ah, in that way
01:22:08 <solatis> in other words, it's easier to remain backwards compatible
01:22:20 <jle`> there was a similar argument about exporing prisms instead of constructors...but then GHC can't do completness checks on pattern matches unless you add some extra tricks
01:22:25 <solatis> heh, in a way, you can compare lenses as the VIEW of sql
01:22:26 <jle`> *exporting
01:22:56 <solatis> if you change the underlying data structure, you can still keep the format of your lens (VIEW) the same
01:23:29 <jle`> yeah.  and there's also the fact that you can use lenses to get first-class modifiers and setters too
01:23:54 <jle`> i wonder if it would be a meaningful thing to add monomorphic (->) forms of `over`, `view`, and `set` to base
01:24:23 <jle`> they seem generic enough to work well with other things besides lenses.
01:24:46 <rzetterberg> if `--datadir` is not given to `cabal install`, what dir will be used?
01:24:46 <shachaf> (x -> f y) optics are a hack anyway.
01:25:18 <jle`> i can imagine them being useful for things other than working with lenses
01:25:48 <jle`> actually i can't but i wish i could
01:27:23 <Ferdirand> jle`: i still don't get it. You say there is another applicative, different from Const, that can be used to implement foldMap with traverse ?
01:27:36 <jle`> yes
01:27:42 <jle`> but it's not very commonly used. just fun to think about :)
01:27:57 <jle`> there's more than one actually :O (if you count among the commonly used applicatives in haskell)
01:28:02 <shachaf> I'm not sure what jle` is getting at.
01:28:06 <Ferdirand> oh
01:28:14 <Ferdirand> the pair ?
01:28:20 <jle`> there is more than one Applicative f you can use to implement `foldMap` with traverse
01:28:37 <jle`> not many people would do it this way, but it's possible
01:28:41 <shachaf> Sure, there are lots of things you could add to Const if you wanted to.
01:28:41 <Ferdirand> like the writer applicative ?
01:29:03 <jle`> Writer is one
01:29:12 <solatis> jle`, yeah i especially like the availability of setters and getters and complex traversals etc
01:29:32 * hackagebot api-builder 0.7.0.1 - Library for easily building REST API wrappers in Haskell  http://hackage.haskell.org/package/api-builder-0.7.0.1 (Intolerable)
01:29:37 <solatis> since i'm building a bitcoin RPC API, which is essentially doing only CRUD with a HTTP-JSON api, i think lenses are appropriate here
01:29:50 <Ferdirand> in hinsight that should have been obvious given the presence of the monoid constraint
01:29:58 <Ferdirand> thanks
01:30:09 <jle`> don't stop there :3
01:31:36 <Ferdirand> jle`: okay, what's next ?
01:31:54 <jle`> oh, i'm just saying, you can think of one more commonly used Applicative besides Writer and Const if you want
01:32:34 <Ferdirand> i was trying List but that doesn't seem to work
01:32:49 <shachaf> I must be missing the point here.
01:33:02 <Ferdirand> oh well, Either, maybe
01:33:12 <jle`> Ferdirand was playing around with ways to implement foldMap with traverse
01:33:24 <jle`> just exploring different Applicatives in general
01:33:56 <shachaf> Yes, and they figured it out.
01:34:07 <Ferdirand> if i use Either and never use Right, it's equivalent to Const
01:34:29 <shachaf> Ferdirand: More like Identity.
01:34:33 * hackagebot api-builder 0.7.0.0 - Library for easily building REST API wrappers in Haskell  http://hackage.haskell.org/package/api-builder-0.7.0.0 (Intolerable)
01:34:35 * hackagebot uhc-util 0.1.5.4 - UHC utilities  http://hackage.haskell.org/package/uhc-util-0.1.5.4 (AtzeDijkstra)
01:34:53 <Ferdirand> Identity would be if i never use Left, no ?
01:35:02 <shachaf> Oh, never use Right.
01:35:03 <jle`> figured out one way...but...figuring out other ways and learning to use different Applicatives might be a way to familiarize onesself with how different Applicatives play with traverse.  and just maybe an appreciation of traverse
01:35:25 <shachaf> In that case it's still not like Const.
01:35:54 <Ferdirand> data Either a b = Left a | Right b
01:35:58 <shachaf> Figured out the optimal way.
01:36:04 <Ferdirand> if i pretend the right doesn't exist 
01:36:25 <Ferdirand> it's just like Const. where is the difference ? operational semantics ?
01:36:37 <Ferdirand> ah, if const is a newtype ok
01:36:38 <jle`> it's about exploration, not optimizing for something that they don't even care about :|
01:37:07 <shachaf> Ferdirand: The Applicative instance doesn't behave like Const.
01:37:08 <jle`> (i might be presuming a bit much about caring, sorry)
01:37:16 <shachaf> Optimizing for what?
01:37:23 <jle`> "figuring out the optimal way"
01:37:38 <jle`> "optimal" is nice, but when you're exploring, it's nice to just explore everything
01:37:55 <jle`> "optimal" only has value in some contexts anyway
01:38:48 <shachaf> What is the exploration? You can do it with IO and unsafePerformIO too, if you want, and that's a path you can use on the way to figuring out Const.
01:39:11 <shachaf> But once you've figured out Const, what's the point of being told "no, don't do that"?
01:39:33 * hackagebot text-manipulate 0.2.0 - Case conversion, word boundary manipulation, and textual subjugation.  http://hackage.haskell.org/package/text-manipulate-0.2.0 (BrendanHay)
01:39:35 * hackagebot family-tree 0.5.1 - A family tree library for the Haskell programming language.  http://hackage.haskell.org/package/family-tree-0.5.1 (NathanVanDoorn)
01:39:45 <jle`> exploring how different Applicatives interact with traverse. and i didn't quite say, "no, don't use const", i said something like it might be fun to explore what other Applicatives might be able to do this job too in different ways
01:39:51 <shachaf> You can make Const more complicated by turning it into Writer, and make Writer more complicated by turning it into State, and then you can turn that into Cont or Codensity State or whatever you like, but you're just adding complexity for its own sake.
01:40:50 <jle`> it was posited as a possible exercise that might be fun :3
01:41:55 <Ferdirand> shachaf: when you said the instance doesn't behave like const, did you mean with respect to strictness ?
01:42:36 <shachaf> Ferdirand: How would you write foldMap?
01:44:27 <Ferdirand> ah, no, okay, duh
01:47:50 <Ferdirand> well, that was enlightening, thanks, i'll go play with more of that stuff now
01:49:33 * hackagebot uu-cco 0.1.0.3 - Utilities for compiler construction: core functionality  http://hackage.haskell.org/package/uu-cco-0.1.0.3 (AtzeDijkstra)
01:50:11 <jle`> have fun :)
02:19:12 <ivanchuk> hi
02:21:31 <rasen_> Hi!
02:21:44 <ivanchuk> I'd like to know if the applicative functor has some mathematical notation ?
02:23:18 <fizruk> :t replicateA
02:23:20 <lambdabot>     Not in scope: ‘replicateA’
02:23:20 <lambdabot>     Perhaps you meant one of these:
02:23:20 <lambdabot>       ‘Seq.replicateA’ (imported from Data.Sequence),
02:23:34 <fizruk> :t \n -> sequenceA . replicate n
02:23:35 <lambdabot> Applicative f => Int -> f a -> f [a]
02:24:45 <edsko> does anyone know if it's easy to add other components to the MSYS/MinGW installation from MinGHC? in particular, ssh/scp?
02:25:30 <rasen_> @google idiom brackets
02:25:31 <lambdabot> https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/idiom.html
02:26:00 <rasen_> ivanchuk: ^ this is ok?
02:26:01 <ivanchuk> sorry got disconnected
02:26:19 <rasen_> ivanchuk: no problem
02:27:08 <rasen_> ivanchuk: try to google out "Idiom brackets"
02:27:24 <ivanchuk> \msg rasen_ ah ok
02:27:34 <ivanchuk> ok
02:28:32 <rasen_> @google applicative programming with effects
02:28:34 <lambdabot> http://strictlypositive.org/IdiomLite.pdf
02:28:34 <lambdabot> Title: FUNCTIONAL PEARL Applicative programming with effects
02:28:53 <rasen_> ivanchuk: you may be also interested in ^
02:29:30 <ivanchuk> thanks !
02:29:57 <rasen_> You're welcome
02:30:16 <yac> How do I pass my State monad which wraps IO into parMapIO ?
02:33:22 <Fuuzetsu> :t liftIO
02:33:23 <lambdabot> MonadIO m => IO a -> m a
02:33:34 <Fuuzetsu> if you have your stack right way around
02:34:06 <yac> that's the other way around
02:34:27 <kuribas> View patterns serve the same purpose as pattern guards, right?
02:34:47 <kuribas> Do view patterns have a performance penalty in GHC?
02:35:01 <jle`> view patterns and pattern guards are pretty different
02:35:21 <jle`> i would hope view patterns get desugared the obvious way in core
02:35:25 <kuribas> jle`: But you can do view patterns with pattern guards?
02:35:33 <yac> I've got runRemoteJob :: Job -> JobRquestListener JobResult and want to paralelize it over [Job]
02:35:59 <jle`> i wouldn't be surprised if you could mix and match different syntactic sugar upgrades on declaration syntax
02:36:22 <kuribas> jle`: Will the functions used in view patterns be inlined?
02:36:36 <kuribas> So that using a view pattern is equivalent to using a normal pattern?
02:36:45 <jle`> check the core :)
02:36:52 <kuribas> jle`: right :)
02:36:57 <jle`> my hope is that foo (bar->x) = ...
02:37:04 <jle`> would be equivalent to foo y = ... where x = bar y
02:37:28 <jle`> but it wouldn't be too hard to find out for sure
02:37:59 <pavonia> These are not equivalent, are they?
02:38:02 <jle`> it might also be in the ghc docs
02:38:17 <yac> I guess I can't just nest the monads this way as the State inner monad would break on forkIO
02:44:16 <tero-> why doesn't this http://lpaste.net/130785 print [[1]] ?
02:45:38 <tero-> the output is [[]]
02:53:54 <Athas> Is there a convenient solution (a la readthedocs.org) for having Haddock docs built and available whenever something is pushed to my repository on Github?
02:55:53 <dpwright> Athas: I don't know if there's something more convenient, but you could probably trick travis into doing it for you
02:56:31 <dpwright> I have travis build and check in my hakyll website whenever I commit a change to the source, so you could do something similar
02:57:45 <dpwright> (on which note, I have to go -- here's how I do that if you're interested https://github.com/dpwright/dpwright.github.com/blob/source/.travis.yml )
02:58:47 <pavonia> tero-: I guess gmapQ tries to match the types of B with [B] (the subtrees of A) which fails and so the default value [] is returned
03:04:19 <hexagoxel> tero-: because the structure below A is [], not B
03:04:38 * hackagebot nero 0.3.1 - Lens-based HTTP toolkit  http://hackage.haskell.org/package/nero-0.3.1 (jdnavarro)
03:04:40 * hackagebot toolshed 0.15.0.1 - Utilities used by other packages.  http://hackage.haskell.org/package/toolshed-0.15.0.1 (AlistairWard)
03:05:39 <hexagoxel> so your gmapQ works on [], so f does not match, and the mkQ default applies
03:06:57 * hexagoxel did not pay attention to the rest of chat :)
03:19:38 * hackagebot aeson-better-errors 0.1.0.0 - Better error messages when decoding JSON values.  http://hackage.haskell.org/package/aeson-better-errors-0.1.0.0 (hdgarrood)
03:33:32 <jdnavarro> anyone here can add me to the "package uploaders" group in hackage? https://github.com/haskell/hackage-server/issues/235#issuecomment-93702664
03:34:03 <jdnavarro> my username is jdnavarro
03:34:05 <mpickering> jdnavarro: #hackage
03:34:14 <jdnavarro> ooops
03:34:38 <jdnavarro> thanks mpickering and sorry
03:35:07 <mpickering> They are actually talking about your ticket in there as we speak :)
03:59:40 * hackagebot factory 0.2.1.1 - Rational arithmetic in an irrational world.  http://hackage.haskell.org/package/factory-0.2.1.1 (AlistairWard)
04:04:41 * hackagebot titlecase 0.1.0.1 - Convert English words to title case  http://hackage.haskell.org/package/titlecase-0.1.0.1 (NikitaKaretnikov)
04:09:41 * hackagebot regexdot 0.11.1.1 - A polymorphic, POSIX, extended regex-engine.  http://hackage.haskell.org/package/regexdot-0.11.1.1 (AlistairWard)
04:14:41 * hackagebot regexchar 0.9.0.12 - A POSIX, extended regex-engine.  http://hackage.haskell.org/package/regexchar-0.9.0.12 (AlistairWard)
04:19:41 * hackagebot squeeze 1.0.4.4 - A file-packing application.  http://hackage.haskell.org/package/squeeze-1.0.4.4 (AlistairWard)
04:19:43 * hackagebot fishfood 0.0.1.3 - Calculates file-size frequency-distribution.  http://hackage.haskell.org/package/fishfood-0.0.1.3 (AlistairWard)
04:33:03 <tero-> pavonia: hexagoxel: which function could I use to extract "interesting" elements in an AST??
04:35:15 <tero-> I think I got it working with everywhereM and mkM
04:37:16 <chpatrick> tero-: check out Control.Lens.Plated too :)
04:49:42 * hackagebot aeson-better-errors 0.1.0.1 - Better error messages when decoding JSON values.  http://hackage.haskell.org/package/aeson-better-errors-0.1.0.1 (hdgarrood)
04:49:53 <hvr> heh... funny pkg name
04:52:08 <frerich> That AlistairWard seems to be a fun guy. First sentence from his homepage: "Perhaps, in a frantic search for extra supplies of Viagra, you've just mistyped the above URL, but now you're here, perhaps the unprecedented dullness of this site will solve the lack of steam-pressure in your trouser-department, by quenching the desire too."
04:53:10 <tero-> chpatrick: thanks. now I just have to figure out how to use it :)
04:56:47 <safinaskar> how to check is some concrete pure type system ( https://en.wikipedia.org/wiki/Pure_type_system ) consistent?
04:58:16 <safinaskar> for example, i have PTS with sorts p, t, k, with axioms p:t, t:k and with rules ppp, tpp, ttt, ptt, kkk (using Barendregt terminology). is it consistent?
04:58:55 <safinaskar> yes, this is unrelated to haskell, but i hope there is some people here which know formal logic
05:04:46 <zennist> @djinn a -> (a -> b) -> b
05:04:46 <lambdabot> f a b = b a
05:05:26 <merijn> safinaskar: You'll have to prove it to be consistent
05:06:32 <zennist> how can I search for an existing function on hoogle with the given type signature?
05:06:56 <yac> just enter the signature?
05:07:02 <merijn> zennist: Type in the signature? :)
05:07:25 <yac> @hoogle Either a b -> Maybe b
05:07:27 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
05:07:27 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
05:07:27 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
05:07:48 <zennist> turns out I'm dumber than I thought I was :)
05:09:48 <safinaskar> merijn: yes. but maybe there is some info? Barendregt gives some examples of consistent and inconsistent PTSs. where can i get more examples?
05:10:14 <merijn> safinaskar: TaPL proves the consistency of the typesystems it discusses, I think
05:10:23 <merijn> Not sure how related this is to what you're asking
05:15:49 <safinaskar> merijn: thanks
05:29:43 * hackagebot uu-parsinglib 2.9.0 - Fast, online, error-correcting, monadic, applicative, merging, permuting, interleaving, idiomatic parser combinators.  http://hackage.haskell.org/package/uu-parsinglib-2.9.0 (DoaitseSwierstra)
05:29:45 * hackagebot uu-interleaved 0.2.0.0 - Providing an interleaving combinator for use with applicative/alternative style implementations.  http://hackage.haskell.org/package/uu-interleaved-0.2.0.0 (DoaitseSwierstra)
05:30:19 <RaceCondition> are there any libraries that would help me wrap a non-FRP UI library as an FRP one, such as Appcelerator Titanium (via Haste)
05:30:49 <RaceCondition> i.e. generic FRP with the ability to plug in an arbitrary imperative UI API
05:30:56 <merijn> reactive-banana is explicitly designed for that
05:31:11 <merijn> (i.e. map callback driven imperative GUI stuff to FRP)
05:31:18 <crymore> wow, what a coincidence, merijn
05:31:38 <RaceCondition> meretrix: awesome; I'll check it out straight away :)
05:31:54 <RaceCondition> and reactive-banana will also work on Haste?
05:34:18 <tero-> is there an example of using lenses to extract interesting parts of an AST? uniplate variables-example has only a simple Expr data type
05:35:59 <tero-> I want to do this http://lpaste.net/130790 but cleaner
05:37:20 <merijn> RaceCondition: No idea whether it works with haste
05:37:36 <merijn> RaceCondition: But you could always try using ghcjs, because I'm fairly sure it'll work with that
05:38:03 <RaceCondition> merijn: yes, but then again I'm a bit reluctant to use GHCJS in a real project...
05:38:26 <Xe> RaceCondition: how come?
05:38:49 <dbeacham> can I force the associated types of a closed type family to conform to a given constraint? I can with open type families: class (Show (AssocType a)) => TypeFamily a where type AssocType a 
05:39:03 <RaceCondition> Xe: for example, don't I need a VM to start using it?
05:39:39 <merijn> RaceCondition: You need to use it's runtime system, which is basically a library of JS functions and that's it
05:40:02 <merijn> RaceCondition: It just produces normal JS as output
05:40:22 <RaceCondition> merijn: I know that, but Haste is much more lightweight and seems more mature
05:40:37 <merijn> dbeacham: That question does not parse
05:40:58 <merijn> dbeacham: What are "the associated types of a closed type family"?
05:41:58 <tero-> ah. finally got it. universeBi does it . http://lpaste.net/130791
05:42:34 <RaceCondition> is anybody using GHCJS in production?
05:43:46 <tero-> RaceCondition: I'm using it with my clients
05:44:23 <tero-> RaceCondition: there's #ghcjs for more in-depth discussion 
05:44:26 <RaceCondition> tero-: have a blog about it by any chance? :)
05:46:01 <tero-> RaceCondition: sorry, no, but I can summarize my experiences. There has been one bug with threads being killed, but Luite has addressed it fast. The code size may be an issue for you as it generates easily megabytes of JS  
05:46:21 <dbeacham> I mean the type synonyms, e.g. the Double and () parts of: type family F a where type F Bool = Double, F a = ()
05:46:48 <tero-> RaceCondition: otherwise. I've been happier than ever to be insulated from the nasty JS world
05:47:00 <RaceCondition> tero-: I intend to build a mobile app using Appcelerator Titanium, so size is not much of an issue, unless it exceeeds 10-15MB
05:47:36 <RaceCondition> I'm more worried about the human readability of the generated JS, not so much about size
05:47:52 <RaceCondition> + ghcjs.org is almost empty
05:48:01 <merijn> RaceCondition: The runtime is big in web terms, but I think that's still only like 1-2 MB
05:48:26 <tero-> RaceCondition: github-page is where the action happens
05:48:38 <RaceCondition> how about performance?
05:48:44 <merijn> RaceCondition: That and luite's blog
05:49:24 <merijn> RaceCondition: All the compilation/optimisation of happens by GHC, so I'd expect it to be substantially better than haste and similar in terms of performance
05:49:45 <merijn> RaceCondition: Just because GHC has a ton more optimisations/work on that than smaller compilers projects like haste do
05:50:05 <RaceCondition> doesn't Haste also use the GHC API?
05:50:15 <RaceCondition> Fay doesn't but I heard Haste did
05:50:28 <merijn> RaceCondition: Other bonus, ghcjs supports all GHC extensions (well, not the C FFI), but stuff like STM and threading all work too
05:51:30 <RaceCondition> merijn: yeah, that I know;  I'm aware that GHCJS is a full implementation of Haskell and Haste is almost full
05:52:06 <yac> how can I make Control.Concurrent.Spawn.parMapIO non-strict?
05:53:19 <merijn> yac: Having a non-strict parallel map sounds rather useless
05:53:30 <merijn> yac: Why map in parallel if you're not gonna compute the result
05:54:11 <yac> I have void $ mapM_ handleConnection <$> (liftIO . parMapIO accept $ repeat sock)
05:54:19 <yac> maybe I'm misunderstanding where is the problem
05:54:47 <merijn> yac: You don't want parMap for that
05:54:52 <merijn> yac: Probably you want to use threads
05:55:28 <yac> I thought parMapIO is using threads
05:56:00 <merijn> yac: I expect parMapIO (I don't know this library) to use sparks
05:56:12 <yac> it's using Control.Concurrent.forkIO
05:56:42 <RaceCondition> the Haskell supported by Haste is a subset of that supported by GHCJS though, so I can always upgrade (probably same with Fay?)
05:57:05 <merijn> yac: ok, yeah it uses threads, but probably this still isn't the way you wanna go for handling concurrent connections
05:57:29 <yac> so what's the easiest way to make concurrent?
05:57:49 <merijn> yac: Since it will evaluate in parallel, but not return any intermediate results until all are finished
05:58:14 <yac> I don't need result. All effects will be produced by the handleConnection
05:58:15 <merijn> yac: I'm guessing you have like a server handling multiple connections style problem?
05:58:22 <merijn> yac: Oh, then it's even easier
05:58:51 <merijn> Just do like "forever $ do { sock <- accept sock; forkIO (handleConnection sock) }"
05:58:55 <yac> it's running inside ybsAccept :: Maybe Socket -> YBServer ()
05:58:56 <merijn> eh
05:59:09 <merijn> alpha rename the sock in there :p
05:59:15 <yac> oh, that looks cool
05:59:42 <merijn> yac: Since accept is blocking it just infinite loops accepting stuff and forking a new thread for every connection
06:00:07 <yac> I've definetly seen this pattern somewhere before but totaly forgot
06:00:10 <merijn> You should have some proper exception handling/freeing around the forever using bracket, but that's all you really need for such a simple case
06:00:29 <yac> that should be in place already
06:00:53 <yac> It's this thing btw https://github.com/yaccz/yac-build-server/tree/one-job-at-a-time-at-a-machine
06:02:29 <f-a> I am looking the type signature of buildG from Data.Graph (buildG :: Bounds -> [Edge] -> Graph). So they require edges (ok) and bounds. I wonder why they require bounds? Efficiency reason? It doesn't seem required.
06:03:05 <f-a> I mean, I could easily find minbound and maxbound from scanning the list
06:04:43 * hackagebot zlib 0.6.0.0 - Compression and decompression in the gzip and zlib formats  http://hackage.haskell.org/package/zlib-0.6.0.0 (DuncanCoutts)
06:05:42 <f-a> (this one: http://hackage.haskell.org/package/containers-0.2.0.1/docs/Data-Graph.html#v:buildG )
06:06:47 <yac> hm yeah, now I've got a problem with that handleConnection is :: YBServer (), not IO (). I've had this before and I've to rewrite the monads to "dependency inject" stuff from one to other wrapping IO instead of the other wrapping the one
06:07:20 <merijn> yac: if YBServer is a MonadIO instance (it presumably is) you can just liftIO
06:08:22 <merijn> yac: Right, it's just a synonym around StateT and IO, which means it has a MonadIO instance
06:09:28 <merijn> yac: oh, wait, you have the reverse problem
06:10:39 <merijn> yac: You'll have to wrap it with "runYBServer" or whatever inside every forkIO
06:15:00 <redneb> hi, I have never been able to upload a package to hackage with "cabal upload", or upload a package directly without uploading a candidate first
06:15:06 <redneb> I looked into the hackage-server issue tracker for similar issues and it appears to be related to fact that I am not in the uploaders group
06:15:09 <redneb> is there a hackage admin around here to help me fix that?
06:15:19 <dcoutts> redneb: yep, username?
06:15:29 <redneb> MariosTitas
06:15:43 <merijn> redneb: Did you create your account long ago?
06:15:52 <redneb> maybe a year or so
06:15:54 <merijn> Old accounts weren't automatically uploaders
06:16:15 <dcoutts> redneb: done, http://hackage.haskell.org/user/MariosTitas
06:16:22 <redneb> awesome, thanks
06:23:57 <sbidin> Let's say I have an IO action 'f' that accepts N>3 arguments and returns Int. I now want an 'f_' action that does the same as 'f', but returns () instead. Can I define 'f_' without explicitly mentioning its arguments and without chaining (.)?
06:24:42 <jerbome> is there a function equivalent to the lambda (\n -> [0..n]) ?
06:24:49 <Ferdirand> @hoogle Monad m => m a -> m ()
06:24:51 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
06:24:51 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
06:24:51 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
06:25:09 <tromp> :t enumFromTo 0
06:25:10 <lambdabot> (Enum a, Num a) => a -> [a]
06:25:20 <jerbome> tromp, thanks
06:27:46 <merijn> sbidin: An IO action by definition doesn't accept arguments
06:28:05 <merijn> sbidin: You probably mean a function of >3 arguments that returns an IO action?
06:28:10 <sbidin> merijn: Sorry, a function 'f' that accepts N>3 arguments and returns an IO action.
06:28:12 <Ferdirand> sbidin: apparently, some people define void f = f >> return ()
06:28:19 <jameseb> :t void
06:28:20 <lambdabot> Functor f => f a -> f ()
06:28:28 <merijn> Ferdirand: That doesn't apply arguments to 'f'
06:29:11 <merijn> sbidin: And no, not really, you have to write those arguments
06:29:35 <merijn> sbidin: But as jameseb points out you could opt not to provide f_ and just use void in combination with f
06:29:47 <merijn> sbidin: i.e. "void $ f foo bar baz"
06:31:03 <sbidin> Yes, thanks, that would work. However, apologies, I picked a poor example. What I really want is not f_, but rather g, where g is something like (liftIO . f).
06:31:24 <sbidin> And I suspect that isn't doable without mentioning the arguments, as you say.
06:31:32 <sbidin> Or using lots of (.).
06:31:49 <c_wraith> @pl \x y -> liftIO $ f x y
06:31:49 <lambdabot> (liftIO .) . f
06:31:55 <c_wraith> yep.  lots of (.)
06:32:17 <merijn> sbidin: Right
06:34:05 <sbidin> I'm writing bindings, and am exposing everything as (MonadIO m => ... -> m a) instead of (IO a), so it can get a bit tedious. I'm thinking about possibly using template Haskell here.
06:35:10 <merijn> sbidin: That shouldn't be too hard using TH
06:35:29 <sbidin> merijn: Yes, I hoped that would be the case. I'll try it out.
06:35:32 <sbidin> Thanks for the help!
06:35:36 <redneb> speaking of voiding the returned value of monadic actions
06:36:03 <redneb> rust has an interesting approach to when issuing warning if the returned value is ignored
06:36:25 <redneb> if you "mark" a type with the attribute #[must_use]
06:36:26 <crundar_> What does (,) mean? That's been difficult for me to google?
06:36:40 <KaneTW> tuple constructor
06:36:47 <merijn> redneb: GHC does that too with -Wall
06:36:49 <KaneTW> :t (,)
06:36:50 <lambdabot> a -> b -> (a, b)
06:36:55 <redneb> then whenever you have an action that returns that type, if is ignored you get an warning
06:36:59 <crundar_> Ah. Thank you!
06:37:07 <merijn> redneb: I recommend always compiling with -Wall and selectively disabling warnings you don't want
06:37:13 <redneb> but if you dont have that attribute, there is no warning
06:37:22 <redneb> merijn: I know, and I do that
06:37:39 <redneb> but I am tired of typing void $ char '(' in parsec
06:37:50 <merijn> redneb: I just disable that warning :)
06:38:07 <KaneTW> > (,) 1 2
06:38:08 <redneb> I don't want to do it on per module case though
06:38:09 <lambdabot>  (1,2)
06:38:23 <redneb> in rust, you can do it per returned type
06:38:46 <redneb> maybe we could do it per functions
06:39:02 <merijn> redneb: You could propose a pragma for that and try to hack it into GHC ;)
06:39:09 <redneb> imagine that 'char' in parsec is defined with {#- IGNORE_OK -#}
06:39:26 <merijn> redneb: But what if other people disagree with that idea?
06:39:51 <merijn> redneb: i.e. what if the parsec maintainers don't think it should silently be ignored?
06:40:16 <merijn> redneb: Actually, you know what I usually do for issues like this?
06:41:00 <merijn> "import qualified Parsec; import Parsec hiding (char); char :: Char -> Parser (); char c = void $ Parsec.char c"
06:41:22 <merijn> Then use your own 'char' in that module
06:41:44 <redneb> merijn: I have "skipChar = void . char" in almost all the places I use parsec
06:42:23 <redneb> I wonder, is the void completely optimized away by the compilers in those case
06:42:42 <merijn> redneb: void has a bunch of rules to optimise it away, afaik
06:49:48 * hackagebot csound-expression-dynamic 0.1.4 - dynamic core for csound-expression library  http://hackage.haskell.org/package/csound-expression-dynamic-0.1.4 (AntonKholomiov)
06:49:50 * hackagebot text-regex-replace 0.1.0.1 - Easy replacement when using text-icu regexes.  http://hackage.haskell.org/package/text-regex-replace-0.1.0.1 (EricRochester)
06:49:52 * hackagebot csound-expression-typed 0.0.7.3 - typed core for the library csound-expression  http://hackage.haskell.org/package/csound-expression-typed-0.0.7.3 (AntonKholomiov)
06:49:54 * hackagebot csound-expression 4.6 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-4.6 (AntonKholomiov)
07:03:16 <yac> merijn: cool, thanks
07:11:34 <zennist> so (sequence (repeat m)) is useless becomes sequence uses foldr
07:11:35 <zennist> what'
07:11:40 <zennist> what's the solution?
07:11:57 <zennist> /becomes/because
07:13:11 <zennist> sorry, I think I got the understanding wrong
07:14:53 <zennist> if I want to write a function Monad m => m a -> m [a], which contains an infinite list of repeated evaluation of m a, and then uses haskell's lazy approach to work with some initial values from that list. is that possible?
07:15:14 <chpatrick> depends on the monad
07:16:19 <zennist> chpatrick: can you elaborate it a bit?
07:16:49 <quchen2> :t sequence . repeat -- zennist: be careful, this will not terminate for all monads.
07:16:50 <lambdabot> Monad m => m a -> m [a]
07:16:50 <chpatrick> :t let rep m = (:) <$> m <*> rep m in rep
07:16:51 <lambdabot> Applicative f => f a -> f [a]
07:16:52 <dmj`> any tokyo haskell people here?
07:17:21 <chpatrick> zennist: IO for example won't give you the result until all the computations are finished, so you would hang forever
07:18:20 <chpatrick> but state or reader for example will have no problem
07:25:14 <exio4> chpatrick: State will have no problem as long as you don't ask for the state after that computation
07:26:13 <ion> There's lazy State and strict State.
07:29:48 <zennist> okay.. sounds complicated for a newbie like me. Is there an easy way to see if a monad supports this kind of lazy actions other than looking at how it's defined? 
07:29:48 * hackagebot yesod-dsl 0.1.1.23 - DSL for generating Yesod subsite to manage an RDBMS;  http://hackage.haskell.org/package/yesod-dsl-0.1.1.23 (TeroLaitinen)
07:31:18 <c_wraith> zennist: no. You just hope that it's actually documented.
07:31:48 <chpatrick> zennist: specifically if you'd like to do lazy IO I recommend conduit :)
07:34:55 * hackagebot network-transport-amqp 0.1.0.0 - AMQP-based transport layer for distributed-process (aka Cloud Haskell)  http://hackage.haskell.org/package/network-transport-amqp-0.1.0.0 (AlfredoDiNapoli)
07:35:45 <ion> > flip execState 0 $ do xs <- sequence (repeat (pure 'x')); s <- get; pure (take 5 xs, s)
07:35:48 <lambdabot>  mueval-core: Time limit exceeded
07:36:46 <ion> > flip execState 0 $ do xs <- sequence (repeat (pure 'x')); pure (take 5 xs)
07:36:51 <lambdabot>  mueval: ExitFailure 1
07:37:54 <ion> Wait. I always confuse execState and evalState.
07:38:19 <osa1> I'm looking for a quasi quoter for parsing strings to haskell-src-exts types, does anyone know a library for this?
07:39:07 <barrucadu> Why not just parse the string?
07:39:07 <chpatrick> @hackage haskell-src-exts-qq
07:39:07 <lambdabot> http://hackage.haskell.org/package/haskell-src-exts-qq
07:39:11 <chpatrick> first result on google
07:39:32 <chpatrick> I guess because then it's checked at compile-time
07:39:35 <osa1> barrucadu: I want it to fail in compile time if string is not well-formed
07:40:07 <osa1> chpatrick: I don't think it generates haskell-src-exts
07:40:34 <osa1> chpatrick: see quoter types, they're generating TemplateHaskell types
07:42:05 <chpatrick> osa1: quasiquoters always produce TH types
07:42:07 <ion> You can't tell what type the resulting expression will have based on the type of the quasiquoter (unfortunately).
07:42:15 <chpatrick> but presumably they reflect src exts values
07:42:21 <osa1> aw
07:42:30 <osa1> you're right
07:42:49 <osa1> ok, thanks
07:43:12 <merijn> ion: You can if you use typed TH :)
07:43:37 <merijn> Although I don't think there's a typed TH quasiquoter yet, so you'll have to rely on explicitly calling TH functions
07:46:04 <osa1> noo http://lpaste.net/130797
07:46:16 <chpatrick> hehehe
07:46:27 <chpatrick> actually I'm working on a lens traversal for the GHC AST right now
07:46:34 <chpatrick> that avoids those panics
07:46:49 <osa1> what's causing these?
07:46:57 <chpatrick> they have pure errors in the AST
07:47:03 <chpatrick> when values are missing
07:47:27 <chpatrick> oh actually
07:47:30 <chpatrick> how did this happen?
07:47:55 <osa1> [hs| \x -> case x of { 0 -> True; _ -> odd (x - 1) } |]
07:48:46 <osa1> noo, compilation also fails
07:48:51 <osa1> (this was cabal repl)
07:48:56 <chpatrick> oh wow
07:49:06 <chpatrick> that's probably a real ghc bug
07:49:39 <osa1> I'm going to try to produce a minimal example
07:54:09 <ion> Oh, nice. I haven't been paying enough attention to the Template Haskell land it seems.
07:56:25 <mpickering> chpatrick: There are no longer any "panics" in the GHC AST?
07:57:41 <osa1> chpatrick: https://gist.github.com/osa1/4fe6a09a473dcb72798e#file-output-txt-L62
07:59:46 <osa1> looks like it's known https://ghc.haskell.org/trac/ghc/ticket/10279
07:59:55 * hackagebot Weather 0.1.0.2 - Library for interacting with the Weather Underground JSON API.  http://hackage.haskell.org/package/Weather-0.1.0.2 (bstamour)
08:03:05 <chpatrick> mpickering: since 7.10?
08:04:06 <mpickering> yes
08:04:33 <chpatrick> oh cool
08:04:46 <chpatrick> still using 7.8 at work though
08:04:58 <mpickering> you can use ghc-syb-utils if you just want generic traversals
08:07:05 <chpatrick> well originally we wanted to use control.lens.plated
08:07:11 <chpatrick> but with a ghc-aware plate function
08:07:40 <edwardk> the buried bottoms in ghc's AST make me sad
08:09:24 <chpatrick> the current solution is a LensLike' (Compose (ReaderT SeenNodes IO) (Const m)) s a that avoids exceptions and cycles that you an unsafePerformIO into a Getting
08:09:33 <chpatrick> sorry if that's a dumb solution, edwardk ;)
08:09:52 <osa1> so what is this "errors in GHC AST" problem?
08:09:55 * hackagebot jsonschema-gen 0.2.0.0 - JSON Schema generator from Algebraic data type  http://hackage.haskell.org/package/jsonschema-gen-0.2.0.0 (yuga)
08:10:05 <lexir> If I'm ever at crossroads on whether to make an executable or a library from cabal init. What should I do to help me make a decision?
08:10:33 <chpatrick> osa1: there's stuff in the AST that's not filled in at a certain point in computation, and instead of it storing Nothings they're GHC panics which are just like error
08:10:36 <lexir> In this case I want to create something that will likely be depended on by others. A web server.
08:10:36 <chpatrick> *in compilation
08:11:04 <quchen> lexir: Doesn't matter. You have to edit the .cabal file later anyways.
08:11:39 <mpickering> chpatrick: Can you not just convince someone that it's better to upgrade to 7.10 than make you write these fiddly traversals :P ?
08:11:42 <SrPx> can I ask about xMonad here? I instaleed it with nix-env and don't understand how I'm supposed to open it :(
08:12:55 <lexir> quchen: It doesn't matter? I see no place in a cabal file where I chose between executable and library.
08:13:07 <chpatrick> not sure we can move to 7.10 yet because of BBP
08:13:28 <quchen> lexir: You can add multiple executables and a library to your .cabal file.
08:13:42 <mpickering> also i've never tried but is it possible to lift syb traversals to something that Control.Lens.Plated understands?
08:13:44 <lexir> mpickering: I'm on 7.10 and a lot of libraries broke.
08:14:05 <quchen> lexir: For example, here's Pandocs .cabal: http://hackage.haskell.org/package/pandoc-1.13.2.1/pandoc.cabal
08:14:17 <quchen> lexir: There's both a "library" and an "executable" section in there.
08:14:30 <quchen> Multiple executables, actually.
08:14:53 <lexir> quchen: WOW interesting.
08:14:57 * merijn always picks library
08:15:05 <lexir> merijn: Why so?
08:15:28 <merijn> Easier testing if you put allf functionality in a library than your executable and tests can both depend on the library and avoid listing dependencies multiple times
08:15:42 <merijn> Bonus, it becomes easier for people to reuse what you did in their own stuff
08:15:50 <osa1> so haskell-src-exts only allows getting a pretty-printed string and not Doc... any ideas why hide `a -> Doc` methods?
08:15:55 <merijn> i.e. what pandoc does, providing it's functionality as a library AND executable
08:24:55 * hackagebot ShellCheck 0.3.7 - Shell script analysis tool  http://hackage.haskell.org/package/ShellCheck-0.3.7 (vidarhol)
08:24:58 <drostie> Staring at the Confluently Persistent Tries paper feels like nothing so much as meditation. It feels like there is some big insight which will make the paper (resp. the world) make sense, which is just at the tip of my tongue but cannot be expressed. I, like, don't even have a foothold on where to begin implementing it so that I might understand it, but they say that two of their designs are functional so presumably...
08:26:27 <lpaste> jerbome pasted “Is memoization achieved ?” at http://lpaste.net/130800
08:27:14 <yac> https://github.com/yaccz/yac-build-server/blob/one-job-at-a-time-at-a-machine/library/YacBuildServer/Server.hs#L110
08:27:18 <yac> I still can't figure this out
08:27:42 <yac> I switched the YBServerState into TVar YBServerState but the server will stil handle only the ifrst connection
08:28:18 <yac> what is pretty weird is that it will accept one more connection when I press ctrl-c in the controlling terminal of the server
08:28:31 <yac> but it will only accept it, won't distribute the job
08:29:27 <lpaste> quchen revised “Is memoization achieved ?”: “No title” at http://lpaste.net/130800
08:29:55 <quchen> jerbome: ^ Try running that one. (Import Debug.Trace)
08:31:07 <hodapp> sigh. I successfully made a heterogeneous list over a typeclass... and now I can't manage to get the type back out of it. Perhaps this is part of the nature of data Foo_ = forall a . Foo a => MakeFoo a
08:31:44 <c_wraith> hodapp: definitely part of the nature of existentials.  You always lose knowledge of what the type was.
08:32:10 <quchen> hodapp: It guarantees that all you can do is whatever Foo provides. And id.
08:32:32 <hodapp> damn you Haskell, actually doing what I tell you >_>
08:32:32 <c_wraith> hodapp: if you want to make a heterogenous list and be able to recover the types, you need to record the types.
08:32:44 <c_wraith> hodapp: which is what things like HList do
08:32:51 <hodapp> hmmmm
08:33:14 <yac> oh yeah, it doesn't free the machines properly, sigh
08:33:29 <nshepperd> usually you don't want to make a heterogenous list though
08:33:47 <hodapp> in this case I'm not aware of any clean way around them
08:34:56 * hackagebot Weather 0.1.0.3 - Library for interacting with the Weather Underground JSON API.  http://hackage.haskell.org/package/Weather-0.1.0.3 (bstamour)
08:34:56 <saulzar> You can possibly include a cast function in your typeclass to get the type out. Or use something like Typeable
08:35:01 <hodapp> and I'm not sure I *need* the types; the problem is that the typeclass method I'm trying to call is like FooClass t => Proxy t -> FooType
08:35:17 <c_wraith> > let x -: xs = show x : xs ; infixr 4 -: in () -: 5 -: Just "foo" -: []
08:35:19 <lambdabot>  ["()","5","Just \"foo\""]
08:35:27 <c_wraith> hodapp: ^ that's always an alternative
08:35:55 <hodapp> c_wraith: I'm not sure what the general alternative is that you're giving there
08:35:55 <quchen> A safer alternative would be using Binary.
08:36:09 <quchen> Plus a tag for the type maybe.
08:36:23 <c_wraith> hodapp: if all you can do is apply typeclass functions, you might as well apply the typeclass function on the way in.
08:36:31 <saulzar> hodapp, What are you doing with this data type?
08:36:54 <c_wraith> hodapp: and creation of an infix helper makes that very lightweight to use.
08:37:35 <hodapp> https://chris-taylor.github.io/blog/2013/03/01/how-haskell-printf-works/ is what I'm following. I am modeling a printf function that Ivory uses, and I don't want to reimplement UPrintf for every single instance of IvoryType.
08:37:43 <jerbome> can someone tell me if memoization is achieved in this lpaste ? http://lpaste.net/130800
08:38:24 <quchen> jerbome: I edited your file to make it obvious.
08:38:46 <quchen> Run the edit and you'll see multiple duplicate prints if there's no memoization.
08:38:49 <hodapp> The only typeclass method of IvoryType I can see is ivoryType :: Proxy t -> Type - and that is the method where I cannot figure out how to recover 't' to actually be able to call ivoryType, and furthermore, I still *need* the value to pass to some Ivory calls that take IvoryType.
08:39:11 <lexir`> merijn: Thank you.
08:39:56 * hackagebot Weather 0.1.0.4 - Library for interacting with the Weather Underground JSON API.  http://hackage.haskell.org/package/Weather-0.1.0.4 (bstamour)
08:40:13 <hodapp> So, I don't know how to just pre-call the typeclass method, and I don't think it actually helps me to do so.
08:40:30 <jerbome> quchen, thanks
08:41:38 <RaceCondition> tero-: looks like your recommendation was indeed fruitful -- I just successfully ran a helloworld with GHCJS
08:41:56 <RaceCondition> and the journey went without a glitch
08:42:30 <jerbome> so, memoization is achieved, but it does not really help my problem
08:43:09 <saulzar> hodapp, You want to do without the UPrintf type?
08:43:13 <merijn> RaceCondition: \o/
08:43:22 <saulzar> hodapp, Excuse me for silly questions, just reading it myself :)
08:43:37 <RaceCondition> merijn: :)
08:43:47 <ion> How big is a ghcjs hello world, minified and gzipped?
08:44:17 <RaceCondition> now just have to figure out why C-c C-l doesn't accept `compiler: ghcjs` in my cabal.config
08:44:34 <RaceCondition> ion: the all.js inside the .jsexe is ~900kB
08:44:38 <Guest93178> Hey all.  I'm non-haskeller, but I have a more general question about composing a function.  I'm trying to compose a function that merges two lists where if there is a collision only the max is kept.  Example:  [1:{size:"Big"}, 2:{size:"Medium}, 3:{size:"Medium"}] =  SomeOperation([1:{size: "Big"}, 2:{size:"Small"}, 3:{size:"Medium"}], [1:{size: "Size"}, 2:{size:"Small"}])
08:44:57 <c_wraith> hodapp: Note that when you case match on a constructor that contains an existential, you can pretend to know what that type is in the scope of that match..  That may actually do what you need.
08:45:49 <ion> RaceCondition: Thanks. Is that minified?
08:45:51 <RaceCondition> ion: gzipped, it's ~160kB
08:45:55 <ion> alright
08:46:05 <RaceCondition> ion: not sure; it's GHCJS output; I didn't do anything else to it
08:46:21 <RaceCondition> I suspect it's not using e.g. the closure compiler or anything but I'm not sure
08:46:37 <saulzar> I don't think GHCJS minifies anything by default (I certainly don't have closure installed)
08:46:44 <c_wraith> hodapp: you can construct the proxy with something like toProxy :: a -> Proxy a ; toProxy _ = Proxy
08:47:13 <galderz> hi all
08:47:23 <galderz> having issues with emacs + haskell cabal version
08:47:25 <ion> > pure 42 :: Proxy Integer
08:47:26 <lambdabot>  Proxy
08:47:29 <galderz> command line it has version 22
08:47:40 <galderz> but in emacs, it keeps having an old version
08:47:42 <c_wraith> hodapp: that *should* let you call that function without knowing the concrete type, so long as you've got the fact that the type exists in scope
08:47:51 <c_wraith> ion: that pure is just obfuscated const. :P
08:47:58 <galderz> if I call up shell from emacs, the PATH does not contain an entry that the command line has
08:48:06 <galderz> how do you change Emac's PATH?
08:48:08 <c_wraith> ion: oh wait, it's not.  Ok. :)
08:48:34 <galderz> my init file already has: https://gist.github.com/galderz/0ef270a0e4519bb67653
08:48:36 <phaazon> hey, is there a less restrictive typeclass than Num to lift literals?
08:48:51 <RaceCondition> ion: closure got the file to 550749 bytes
08:48:59 <phaazon> for instance, in my 3D engine, I have a type for texture units
08:49:03 <phaazon> I’d love to be able to use it with literals
08:49:06 <RaceCondition> after which gzip got it down to 107k
08:49:09 <ion> racecondition: alright
08:49:09 <phaazon> like 0, 1, and so on and so forth
08:49:17 <phaazon> but a Num instance is ill here
08:49:32 <phaazon> (I don’t want people to do texture units arithmetic :D)
08:51:18 <RaceCondition> any idea why I'm getting "cabal: Unknown compiler" when doing haskell-process-load-or-reload on my GHCJS code?
08:51:27 <hodapp> saulzar: The reason why I'm doing without UPrintf there is because my printf operation is a different one, defined as N functions, printf1... printfN, which take 1 to N types, all different instances of IvoryType.
08:51:32 <RaceCondition> I've "compiler: ghcjs" inside my cabal.config
08:51:53 <RaceCondition> cabal build runs fine on the terminal
08:52:24 <hodapp> c_wraith: I'll see if that gets me anywhere.
08:52:49 <c_wraith> hodapp: as ion pointed out, pure does the same thing as my toProxy
08:53:47 <hodapp> c_wraith: is this specific to a form of Proxy? This is (for whatever reason) Ivory.Language.Proxy.Proxy.
08:54:22 <c_wraith> hodapp: oh.  It works if that Proxy has an Applicative instance.  If not, then use the toProxy I suggested.
08:54:58 <hodapp> c_wraith: thank you, your suggestion is working. Now I just need to understand why for myself...
08:55:31 <hodapp> I was trying to do some ugliness with scoped type variables and just wasn't getting anywhere
08:55:54 <hodapp> but I kind of see how that toProxy works
08:56:49 <ion> The type a -> Proxy a just dictates that the phantom type for Proxy equals the type of the parameter.
08:57:37 <c_wraith> The more important part is that when you pattern match a constructor containing an existential, it "locks" the existential type to something concrete, but unknown.
08:58:04 <c_wraith> (that's what's called a skolem type in some confusing GHC error messages)
08:58:20 <hodapp> c_wraith: so, how am I then able to reacquire that type?
08:58:39 <hodapp> c_wraith: because it looks to me like I am doing this in the form of a Proxy
08:59:00 <c_wraith> hodapp: it can't recover the exact type - but it doesn't need to in order to select the class instance, since the instance was also packed up in that constructor
08:59:16 <c_wraith> hodapp: the important part is that it can prove that the instance it packed up was the instance it needs
08:59:23 <hodapp> c_wraith: how does 'class instance' differ from 'type' here?
08:59:42 <c_wraith> hodapp: uh, implementation detail.  instances are implemented as dictionaries at run time
08:59:52 <c_wraith> hodapp: that dictionary is packed up in the constructor, too.
09:00:39 <hodapp> c_wraith: so it had specific forms of that typeclass function, but the actual type unknown?
09:01:14 <c_wraith> hodapp: correct.  It has no idea what the type is, but the compiler can prove to itself that it can pick the correct instance at runtime
09:01:53 <hodapp> alrighty.
09:04:17 <hodapp> next milestone: can I learn enough Template Haskell to generate (IvoryVar s0, IvoryVar s1, IvoryVar s2, IvoryVar s3, IvoryVar s4, IvoryVar s5) => LogLevel -> String -> s0 -> s1 -> s2 -> s3 -> s4 -> s5 -> Ivory eff () etc. without having to resort to some other wonkier code generation?
09:07:56 <mm_> Does repa have an 'elem' or 'any' function?
09:12:12 <c_wraith> mm_: Huh.  You can do it with toList, but that's kind of sad
09:12:23 * SamB_laptop tries to discern the difference between Data.Array.ST{,.Safe}
09:12:42 <c_wraith> mm_: as it obliterates the parallel execution model unnecessarily
09:13:08 <c_wraith> SamB_laptop: I assume .Safe has somewhat less things such that it can be imported when using safe haskell
09:13:33 <mm_> Yeah I guess you can't, but it's okay, I'm going to convert it to vector instead since it has O(1), and do that over that interface.
09:13:38 <SamB_laptop> is there some kind of "interface diff" that can tell me of any differences I've failed to spot?
09:13:50 <mm_> Thanks ^^
09:14:25 <c_wraith> mm_: I actually don't know why there's no foldMapP sort of operation in repa...  Or maybe there is and I'm looking at the wrong places
09:16:04 <c_wraith> mm_: yeah..  Weird.  Repa would support a foldMap-styled operation beautifully.  It's strange that it's absent.
09:16:33 <lexir> Can I get help with these failed builds whose dependency issues aren't getting fixed by adding the relevant dependencies to the cabal file http://lpaste.net/2275967152278208512
09:20:46 <mm_> c_wraith: Check Data.Array.Repa.Operators.Reduction ( http://hackage.haskell.org/package/repa-3.3.1.2/docs/Data-Array-Repa-Operators-Reduction.html )
09:21:01 <c_wraith> oh, hey.  That looks plausible as a location
09:21:06 <mm_> It does have folds which should suffice, although not really suitable for me.
09:21:23 <c_wraith> mm_: oh, no.  None of those folds are what you need nicely.
09:21:43 <c_wraith> mm_: none of them are equivalent to foldMap
09:21:45 <c_wraith> :t foldMap
09:21:46 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
09:22:46 <mm_> I've never seen it before but I suppose it maps and folds with mappend, yeah?
09:22:51 <c_wraith> yep
09:24:05 <c_wraith> :t \f -> getAny . foldMap (Any . f)
09:24:06 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
09:24:44 <c_wraith> And repa's fancy parallel implementations work really nicely with the guarantees monoids provide
09:24:56 <joneshf-laptop> anyone have experience with `coordinate`?
09:24:59 <c_wraith> well, with the laws that implementations *should* guarantee
09:25:06 <joneshf-laptop> in particular, how do you create longitude 180
09:25:43 <yac> can this work through forkIO (note the TVar there) or do I need to base YBServer on a different monad? https://github.com/yaccz/yac-build-server/blob/one-job-at-a-time-at-a-machine/library/YacBuildServer/Types.hs#L73
09:25:59 <mm_> Oh I wouldn't imagine repa being lazy with something like that, would it? Although I can't really say that because I haven't touched it before today :P.
09:26:33 <c_wraith> mm_: well, laziness and parallel can actually work together.
09:26:45 <elfeck> I can't get a .cabal to install. Can someone help me with this? http://lpaste.net/130807
09:27:46 <trolling> elfeck: error message?
09:28:12 <elfeck> cabal: The following packages are likely to be broken by the reinstalls:
09:28:13 <elfeck> ghc-7.10.1
09:28:13 <elfeck> Cabal-1.22.2.0
09:28:13 <elfeck> Use --force-reinstalls if you want to install anyway.
09:28:42 <trolling> ah
09:28:44 <trolling> cabal hell
09:28:57 <elfeck> I dont have any global packages installed 
09:29:02 <elfeck> only used sandboxes so far
09:29:13 <elfeck> At least I think so
09:29:18 <trolling> what version of GHC?
09:29:35 <elfeck> well I just updated to the new release. That broke everything
09:30:02 <elfeck> 7.10.1. How can I check to make sure?
09:30:08 * hackagebot effin 0.2.1.3 - A Typeable-free implementation of extensible effects  http://hackage.haskell.org/package/effin-0.2.1.3 (AnthonyVandikas)
09:30:12 <yac> rm -rf ~/.ghc ~/.cabal and start again
09:30:13 <mm_> elfeck: ghc --version
09:30:23 <elfeck> yac: I did that
09:30:33 <elfeck> yes 7.10.1
09:30:35 <yac> and sandboxes as well 
09:30:38 <trolling> ghc --version
09:30:42 <trolling> ah yes
09:30:46 <trolling> um
09:30:47 <trolling> hm
09:31:08 <mm_> I agree with yac, just delete every package you have and start from fresh.
09:31:12 <elfeck> should it work if I delete .ghc and .cabal and .sandbox?
09:31:32 <yac> you can also try cabal exec ghc-pkg list
09:31:56 <elfeck> quite a few
09:31:57 <yac> will show you what packages are visible and broken should be red if I get it right but I don't know how reliable it is
09:32:17 <elfeck> ghc-7.10.1 is blue
09:32:35 <elfeck> but it tells me /usr/lib/ghc-7.10.1
09:32:38 <elfeck> is that correct?
09:32:56 <elfeck> or does that mean those are system-wide packages?
09:33:27 <elfeck> sorry quit irc accidentally
09:35:22 <geekosaur> elfeck, they are system-wide packages, yes
09:35:31 <elfeck> how can I get rid of them?
09:35:48 <elfeck> or should they be there?
09:40:26 <elfeck> after deleting .cabal .ghc and .cabal-sandbox I still get an error for it
09:40:39 <elfeck> can someone try it out if there is a problem with the file itself?
09:41:08 <elfeck> http://lpaste.net/130807
09:41:11 <geekosaur> elfeck, the point is your cabal file wants to replace *parts of the compiler*
09:41:20 <elfeck> why would that be?
09:41:33 <geekosaur> can't tell without full debug output from cabal
09:41:40 <elfeck> how can I get that?
09:42:59 <elfeck> http://lpaste.net/130808
09:42:59 <elfeck> this is ouput for cabal install
09:43:11 <c_wraith> add the -v3 argument to get *full* output from cabal
09:44:06 <elfeck> should I post it all in a pastebin?
09:44:17 <hodapp> hmm, I made my variadic printf thingy, but now I have to call it in Ivory as... (printf "foo" arg1 arg2... :: Ivory eff ()) to resolve the ambiguity, which is a bit ugly
09:44:20 <c_wraith> elfeck: actually, I think there's enough info in what you pasted already
09:44:36 <hodapp> but I have no idea how I'd actually resolve that ambiguity in the definition when it's variadic like that
09:44:39 <c_wraith> elfeck: my guess is that the problem is that something wants to downgrade the filepath module
09:44:55 <harel_f> yes, to lambda paste
09:45:15 <hodapp> it seems to be a direct result of both (Ivory eff ()) and (a -> t) being instances of the typeclass
09:45:31 <elfeck> probably wai-middleware-static. If I remove the version requirement it does not fail but pulls a VERY old version of it
09:45:41 <elfeck> full debug: http://lpaste.net/130809
09:46:27 <c_wraith> elfeck: one of the *many* lines there includes "wai-middleware-static => filepath>=1.3.0.1 && <1.4"
09:46:35 <c_wraith> elfeck: so yes, that package is the problem
09:46:44 <yac> efm: oh, if it wants to replace base packages I suggest finding another way. I tried these and gave up
09:46:49 <yac> ^ elfeck 
09:46:51 <yac> sorry efm 
09:47:10 <elfeck> hm it worked before upgrading to the new ghc :|
09:47:15 <elfeck> so strange
09:47:20 <yac> first, I found out some packages accept flags to tell it for which ghc (bundles the base packages) it should compile
09:47:27 <c_wraith> elfeck: well, yes.  The new GHC comes with a new version of filepath
09:47:35 <elfeck> ah that makes sense
09:47:40 <lexir> Which package provides modules such as Build and GhcBuild?
09:47:43 <c_wraith> elfeck: and wai-middleware-static hasn't been updated to work with it yet
09:47:47 <harel_f> delete wai-middleware
09:47:47 <c_wraith> lexir: probably Cabal
09:47:48 <aidecoe> hello
09:48:03 <hodapp> I guess I can make (a -> Ivory eff ()) an instance, and enable OverlappingInstances...
09:48:11 <aidecoe> is there a function to take root n from x?
09:48:19 <aidecoe> somewhere in standard module
09:48:36 <yac> and second if there are no such flags, then good luck. I'd probably try upgrading/downgrading ghc, forgetting about that package or even start a distro with the appropriate version of ghc in virtual machine
09:49:08 <harel_f> @aidecoe just use fractional power
09:49:08 <lambdabot> Unknown command, try @list
09:49:19 <elfeck> yac: hm okay
09:49:24 <elfeck> thanks for your help guys!
09:49:30 <c_wraith> lexir: looks like it's not actually Cabal.  You should try hoogle, then!  https://www.haskell.org/hoogle/?hoogle=GhcBuild  Unfortunately, hoogle doesn't know either. 
09:49:37 <aidecoe>  harel_f ah, of course! thanks
09:50:22 <c_wraith> lexir: hayoo ( http://hayoo.fh-wedel.de/ ) doesn't know about GhcBuild either - so..  It's very likely those types aren't coming from a package on hackage
09:53:04 <lexir> hmmm
09:53:41 <lexir> c_wraith: By saying that they're not coming from a package on hackage you probably gave me an idea http://lpaste.net/3811353823851577344
09:53:53 <geekosaur> elfeck, Haskell isn't Linux, upgrading to the latest and greatest just because it's there is pretty much a guarantee of pain
09:54:28 <lexir> c_wraith: https://github.com/yesodweb/yesod/blob/master/yesod-bin/Devel.hs#L62
09:54:31 <hodapp> geekosaur: ...how is that unlike Linux?
09:54:32 <geekosaur> if you're on something like Arch that is convionced that you must always run the absolute latest everything, you may want to reconsider using Arch packages for anything Haskell-related
09:54:34 <c_wraith> lexir: hmm.  I think hayoo and hoogle only index libraries, and yesod-devel is an executable
09:54:58 <geekosaur> hodapp, Linux in general has "must live on the bleeding edge"-itis
09:55:03 <bennofs> hayoo indexes nearly everything I think, but it's type search is not so good
09:55:05 <lexir> c_wraith: Actually it's a module of yesod-bin
09:55:10 <geekosaur> it actively trains people to always run the absolute latest everything
09:55:46 <c_wraith> lexir: well, then..  That's a fascinating issue you're having.  Maybe ask the yesod folks about it more directly. :)
09:56:08 <lexir> c_wraith: I saw where the modules are coming from https://github.com/yesodweb/yesod/blob/master/yesod-bin/yesod-bin.cabal#L98
09:58:43 <hodapp> hmmmm. Wonder how I can make this annoying variadic function pick the right type constraint...
09:58:48 <elfeck> I indeed run arch :|
09:59:04 <elfeck> But now I know that I need to be more careful with haskell updates
10:02:31 <breadmonster> hodapp: Haskell has variadic functions?
10:03:30 <exio4> geekosaur: linux isn't that bleeding-edge-proof either!
10:03:41 <hodapp> breadmonster: Sort of.
10:03:43 <hodapp> breadmonster: https://chris-taylor.github.io/blog/2013/03/01/how-haskell-printf-works/
10:06:19 <monochrom> it uses a type class. subjectively, it is more "a family of same name, different-type functions" and less "one variadic function"
10:07:37 <nschoe> Hey guys, I'm trying to install 'gtksourceview' (because I'm trying to install Leksah) but it fails with: "Configuring gtksourceview2-0.13.1.3...
10:07:37 <nschoe> setup: The pkg-config package 'gtksourceview-2.0' version >=2.0.2 is required
10:07:37 <nschoe> but it could not be found.
10:07:37 <nschoe> "
10:07:57 <geekosaur> nschoe, use your system's package manager
10:07:57 <nschoe> This is weird because I'm trying to install gtksourceview and it seems that it needs... itself.
10:08:08 <nschoe> geekosaur, to install Leksah or gtksourceview ?
10:08:13 <geekosaur> to install the devel package for the gtksourceview C libraries
10:08:27 <elfeck> okay I fixed the source of wai-middleware-static myself and got it compiling. How should I proceed now to use it in my project?
10:08:38 <nschoe> geekosaur, ah okay.. I feel stupid. Thanks!
10:10:25 <hodapp> and I'm starting to wonder if, instead of a variadic function, I should have just made one argument a list.
10:10:29 <hodapp> bleah.
10:13:11 <nschoe> (geekosaur, thx it worked, of course. Thanks for the speed at which you responded, too!)
10:14:51 <geekosaur> the error message assumes you know what pkg-config is (a tool to report how to compile/link against C devel packages)
10:15:14 <geekosaur> in a certain sense, it's "cabal" for C
10:16:22 <geekosaur> (and the only reason you don't usually run into "cabal hell" with it is that system packages are vetted to make sure they all work with each other. start installing components from source and you WILL run into version conflicts at some point)
10:16:22 <nschoe> geekosaur, yes I know more or less what pkg-config does and is. It's just.. I don't know, for some reason I forgot. I saw that I was trying to install package xxx and that it complained that it did not have xxx, I thought it was weird. My mistake.
10:18:22 <nschoe> geekosaur, perhaps you can enlighten me further: how come, when I try to install leksah it fails on regex-tdfa (for several others, but it's always the same story), then I issue 'cabal install regex-tdfa', it works okay, then I can continue installing leksah? I mean it detected that it needed that package, but failed to install it, but I could install it manually, without changing anything else. Weird ?
10:18:33 <hodapp> wait, I can't make it a list, because the types vary. bleah.
10:19:06 <hodapp> maybe I'll just stick with ugly printf1... printf9 calls that explicitly declare how many arguments.
10:19:14 <geekosaur> nschoe, I would guess you are getting a different version with the manual install than cabal picked for the automatic one
10:19:21 <nschoe> ahem, I've just seen that leksah wanted 1.1.8 and I when I installed it it installed 1.2.
10:19:31 <geekosaur> and once installed, cabal considers it acceptable
10:19:40 <nschoe> geekosaur, indeed. We all fall back into the upper-bound problem I suppose/
10:19:46 <geekosaur> which would be a bug in cabal-install, really, abnd should be reported as such
10:19:47 <ivanchuk> can we make an applicative functor from a data type like this: data S a = S a + C a [S a] + End ?
10:20:00 <geekosaur> it's not ecactly the upper bound problem if cabal is accepting it once it's installed
10:20:18 <geekosaur> the upper bound problem would mean cabal tries to install the older version over the newer one
10:20:18 <ivanchuk> I'm having problems in following the applicative laws
10:20:25 <nschoe> geekosaur, indeed... this is weird then.
10:20:46 <geekosaur> yes. I'd capture a verbose session of that and file a bug against cabal-install
10:21:14 <nschoe> geekosaur, really ? Okay. But for information, it happens to me a lot. I've always had those kind of problems. It surely can't just be me.
10:21:51 <nschoe> I mean, when I know I'm going to install smth big with cabal, I'm always like 'okay, let's launch the command, come back every now and the to make sure it had not crashed on those weird dependcies problems, then installl by hand and loop'
10:22:22 <geekosaur> hm. what version of cabal-install? maybe you just need a newer one. they do fix things like this
10:23:14 <nschoe> cabal-install version 1.22.2.0
10:23:15 <nschoe> using version 1.22.2.0 of the Cabal library 
10:23:26 <nschoe> Freshly installed from cabal itself
10:23:52 <geekosaur> odd. still, these are bugs
10:24:10 <nschoe> (What I usually do is install cabal-install from pacman (I'm running Arch), then install cabal-install from cabal, in a sandbox, then remove the Archlinux's cabal, and add my sandbox into my PATH)
10:24:16 <nschoe> I'll fill in a bug report, then.
10:24:37 <geekosaur> any time this happens reflects a bug in cabal-install's solver
10:25:11 <nschoe> geekosaur, hat do you mean 'in cabal'install's solver?'
10:25:16 <geekosaur> mind, ghc's somewhat insane requirements make the solver's job rather difficult, but still
10:25:53 <ivanchuk> I made a functor of S and a foldable, but cannot figure out how to define a correct applicative instance
10:25:55 <geekosaur> the solver is the thing that looks at all the version constraints and picks a collection of versions that are compatible with each other, your compiler, and hopefully anything else in the sandbox or package database
10:26:11 <nschoe> I'm interested... but I feel like it's the kind of thing that makes brain melt.
10:26:19 <geekosaur> it does indeed.
10:26:49 <geekosaur> modern package systems increasingly use complex SAT solvers for this kind of thing
10:28:06 <nschoe> geekosaur, ho yeah, so *that's* a solver. I had worked briefly on a small program like this (abandonned since), in which for a given package X whose dependies were A, B and C. It would automatically try all possible versions of A, B and C, then keep a list of combinaisons that work. This way, I had "planned" it could be static: when you would want to isntall a package, it would merely be a check if your system were in 
10:28:06 <nschoe> one of the supported config.
10:28:32 <nschoe> But as I said: brain melting occured quite rapidly.
10:29:24 <geekosaur> yeh. and when package setups that are picked to work together in a release still need SAT solvers, you can imagine how nasty it is when picking arbitrary versions
10:31:04 <nschoe> Yeah...
10:31:30 <nschoe> I find it weird that this kind of problem has not yet foud "THE" solution. It's been around for... well as long as Linux was along I would presume.
10:32:27 <geekosaur> some problems don't have solutions. IIRC this one is NP-complete
10:35:30 <c_wraith> Not only is this one NP-complete, it has failure modes that the build system can't detect.
10:35:34 <nschoe> geekosaur, [from wiki] "SAT was the first known NP-complete problem" indeed
10:35:47 <nschoe> c_wraith, what do you mean?
10:35:58 <c_wraith> Like things that build successfully but have a buggy interaction in certain versions
10:36:31 <c_wraith> So even if dependency selection was magically successful, there would still be crazy issues at unexpected times.
10:37:03 <nschoe> c_wraith, ah ok. But that's not the solver's job IMO
10:37:32 <c_wraith> Well, it's certainly beyond the scope of the solver, but it's still a contributor to things not "just working"
10:37:52 <josephle> c_wraith, that sounds like a job for 'integration testing', but we can't expect people to test against every possible client of your library :\
10:38:18 <josephle> software development is hard, let's go shopping
10:39:16 <c_wraith> Can we stop at the food court? I'm hungry.
10:39:57 <nschoe> Hum, now that's weird: usually there's a hint why cabal failed, but here: http://lpaste.net/130812 I can't guess.
10:40:00 <nschoe> Any clue?
10:40:19 <nschoe> (coem to think of it, it seems I have never succeeded in building leksah from cabal :/)
10:45:54 <c_wraith> nschoe: I'm pretty sure that's the result of bitrot..  It appears to be depending on things that have been removed.
10:47:22 <nschoe> c_wraith, hum, actually I noticed it tried to install leksah 0.4.2 which seems ot be old. The newst version on hackage is 0.14.4 so I tried to install this one explicitly, but got: http://lpaste.net/130814
10:47:47 <nschoe> I do understand that the problem seems to come from haddock, but I fail to undersantd *what* the problem *is*
10:48:24 <c_wraith> nschoe: actually, the problem appears to be Leksah hasn't been updated to work with Cabal 1.22
10:48:41 <nschoe> really?
10:49:01 <nschoe> ho yeah, <1.22 indeed. This is strict.
10:49:44 <nschoe> What can I do here? Should I build the previous cabal version into a sandbox and use that version to install leksah? Seems... inappropriate
10:50:41 <c_wraith> nschoe: try installing with --ignore-upper-bounds
10:50:55 <nschoe> ho my... sound gory ^^
10:50:57 <nschoe> thx I'll try that
10:51:04 <c_wraith> nschoe: It's possible leksah doesn't depend on anything that changed in 1.22
10:51:08 <benzrf> is there a newtype or something to extend a type with a maximal element using Maybe
10:51:09 <benzrf> or even just an entirely new type i guess
10:51:33 <nschoe> yes, I'll hope so: this si why I was about to ask you if I could edit the dependy list just to remove cabal uppper boundand not all ofthem
10:52:17 <c_wraith> nschoe: you can certainly do that.  cabal get is handy for that process
10:53:21 <nschoe> c_wraith, how can I do that? I need the .cabal file, but how do I fetch it in my sandbox?
10:53:57 <c_wraith> nschoe: you can use cabal get to pull the entire source, then cabal sandbox add-source to point to your modified version
10:54:11 <nschoe> ok thx
10:54:16 <benzrf> oh wait i see nvm >.<
10:54:44 <nschoe> c_wraith, so I have to cabal get in *another* sandbox?
10:56:33 <c_wraith> nschoe: no, you don't need a sandbox for things you grab from source.  You just need to put them someplace and add-source them in the sandbox you're already using.  Though if you are building leksah and only changing it..  You could just cabal get it and then create a sandbox inside its source directory to work with.  No need for add source stuff
10:57:23 <nschoe> c_wraith, yeah, ok I see. But I'll do the add-source anyway, because I have alreayd spent time building every other dependencies. ^^
10:57:30 <nschoe> But thx for the clarirication.
10:57:37 <benzrf> argh
10:58:03 <benzrf> instance Ord a => Monoid (Maybe (Min a))
10:58:05 <benzrf> please
10:58:09 <benzrf> or something like this
10:58:47 <benzrf> maybe data Min a = Min a | MinMax; instance Ord a => Monoid (Min a)
10:59:59 * hexagoxel is pretty sure that installing leksah into clean sandbox with ghc-7.8.4 on arch works just fine, with latest cabal-install
11:00:08 * hackagebot twilio 0.1.2.0 - Twilio REST API library for Haskell  http://hackage.haskell.org/package/twilio-0.1.2.0 (andrus)
11:00:10 * hackagebot SciFlow 0.1.0 - Scientific workflow management system  http://hackage.haskell.org/package/SciFlow-0.1.0 (kaizhang)
11:04:09 <nschoe> hexagoxel, I have a clean sandbox
11:04:27 <nschoe> ah, but ghc 7.10.1
11:05:14 <hexagoxel> nschoe: i would recommend just using 7.8.4 to install executables, and not bother with 7.10. i even use 7.8.4 still for the project i am working on, because i am annoyed of add-source fixing dependencies
11:05:18 <schell> does this type already exist? data VarT m a b = VarT { runVarT :: a -> m (b, VarT m a b) }
11:05:28 <nschoe> but this is weird, they upper-bound on base <4.8
11:05:31 <schell> it’s a bit like StateT
11:05:58 <nschoe> hexagoxel, hum, okay. So how do you do that? You have a 7.8.4 and 7.10.1 installed at the same time?
11:06:40 <hexagoxel> nschoe: yes; i have 7.10 via pacman and 7.8.4 from the binary distribution
11:07:01 <nschoe> hexagoxel, how does that not conflict? How can I do that too?
11:07:02 <hexagoxel> and cabal install/configure -w path-to-7.8 where necessary
11:07:08 <nschoe> ah
11:07:15 <nschoe> ok, that's what I was looking for :-)
11:07:16 <nschoe> Thanks.
11:07:18 <nschoe> I'll try that, then
11:11:03 <hexagoxel> nschoe: the package databases are like `Map GHCVersion [Package]` internally, so no conflict there either
11:11:28 <hexagoxel> (including sandbox dbs)
11:11:52 <nschoe> hum I haven't quite understood what you said, but I undrstood there should be no conflict.
11:12:43 <hexagoxel> a sandbox contains a separate list of installed packages for each ghc version
11:15:19 <nschoe> ok
11:15:46 <hexagoxel> schell: it reminds of the the types in `machines` package
11:15:50 <benzrf> is there somethng like maybe's Ord instance but has Nothing as maximal instead of mnimal
11:15:57 <benzrf> 5~*minimal
11:16:42 <schell> hexagoxel: cool - i’ll check that out :)
11:17:53 <schell> hexagoxel: Philonous pointed out in haskell-game that “As a matter of fact, it's a special case of http://hackage.haskell.org/package/arrows-0.4.4.1/docs/Control-Arrow-Transformer-Automaton.html where a is just the Kleisli arrow over m”
11:18:11 <nschoe> ho my... now that's ghc 7.8.4 which fails to install :/ Damn it! :-)
11:20:47 <hexagoxel> ah, that is indeed closer to your type signature
11:23:08 <jlamothe> Suppose I have a typeclass named Foo, can anyone tell me what's wrong with the following?  instance (Num n) => Foo n where ...
11:23:27 <geekosaur> for just that, nothing is wrong
11:23:34 <geekosaur> @paste full code, full error message
11:23:34 <lambdabot> Haskell pastebin: http://lpaste.net/
11:24:04 <exio4> jlamothe: that'd overlap with any other instance
11:24:28 <jlamothe> Basically, I want to say that any instance of Num is also an instance of Foo.
11:24:39 <jlamothe> ... and then use Num's functions to define the ones for Foo.
11:25:18 <geekosaur> you "can say" that, but: the constraint is checked *after* picking an instance, not before.
11:25:52 <jlamothe> Here's the full code: http://lpaste.net/130816
11:26:04 <jlamothe> It's not necessarily useful, I'm just using it as a learning exercise.
11:26:15 <jlamothe> Something similar has quite possibly already been implemented.
11:28:40 <benzrf> is there somethng like maybe's Ord instance but has Nothing as maximal instead of minimal
11:29:26 <jlamothe> I'm effectively trying to monkey patch the Num typeclass.
11:30:16 <chpatrick> you can't do that I'm afraid
11:30:34 * wwwBUKOLAYcom hi
11:30:45 <chpatrick> the instance context has to be simpler than the instance head
11:30:57 <chpatrick> it's how haskell guarantees that typechecking terminates
11:31:15 <jlamothe> That's a little saddening, but not the end of the world.
11:31:24 <jlamothe> It was a silly thing to do anyways.  I just wanted to see if it was possible.
11:31:48 <chpatrick> you can do default instance signatures at least
11:31:50 <JordiGH> I want to translate this C++: http://codepad.org/sQTXhqC2 into Haskell. Someone offered me this, which doesn't even terminate for small inputs: http://codepad.org/we1B3woa
11:31:54 <JordiGH> Can anyone here do better?
11:32:14 <JordiGH> It's annoying because the Haskell looks superficially correct but does not produce the same algorithm as the C++ code.
11:32:45 <jlamothe> Wait... I just realized that (==) isn't a part of the Num typeclass in the first place.
11:33:08 <jlamothe> It's part of Eq.
11:33:36 * wwwBUKOLAYcom help me pls
11:34:04 <chpatrick> jlamothe: if you really want, you can do
11:34:04 <chpatrick> default isTruth :: (Eq a, Num a) => a -> Bool
11:34:04 <chpatrick> isTruth = (==0)
11:34:32 <chpatrick> and the all you have to write is instance Truthy Int etc
11:34:41 <chpatrick> for anything that's eq and num
11:34:49 <chpatrick> I don't think that's really elegant though
11:35:10 <chpatrick> sorry isTruth = (/=0)
11:35:12 <monochrom> there was a time (Haskell 98) when Eq was a superclass of Num
11:35:18 <jlamothe> Not really, but the whole concept of truthiness is silly in Haskell in the first place.
11:35:29 <chpatrick> yep
11:35:30 <jlamothe> It feels like cheating the typesystem.
11:35:43 <monochrom> oh interesting, Haskell2010 too.
11:36:55 <monochrom> but the @libraries people moved forward and changed it.
11:37:33 <iasoon> Does anyone know of a way to print a Netwire wire value, only when it changed?
11:37:42 <jlamothe> I guess I could build a TruthyNum type that wraps a Num/Eq type, and make it an instance of Truthy.
11:38:02 <jlamothe> ...but that's hacky too.
11:38:47 <monochrom> if you use existential types, you won't even be able to add. generally all binary operations.
11:38:55 <xplat> jlamothe: also, just as long as an explicit test for zeroness
11:39:12 <monochrom> the exact same difficult with "binary methods" in OOP
11:40:36 <xplat> well, with existential types you can wrap up two same-typed Nums in the same wrapper.  this is seldom convenient of course.
11:41:09 <jlamothe> Like I said though.  I'm not overly concerned about about it.  It was a silly thing to want to do in the first place.
11:42:27 <xplat> benzrf: isn't there some newtype that reverses the sense of Ord?  Backward or something?  then you canj just use Backward (Maybe (Backward a))
11:42:43 <benzrf> xplat: hmm
11:42:46 <benzrf> xplat: nice
11:42:51 <benzrf> (it's Down btw)
11:42:54 <monochrom> haha, that's contrived
11:43:05 <monochrom> or ingenious. it's conjugation
11:43:12 <benzrf> ooooooooooooooOOOOOOOOOOOOOOOOOOO
11:44:23 <monochrom> isn't conjugation exciting!
11:44:45 <monochrom> this is like XYX problem but in a good way :)
11:47:18 <benzrf> what is XYX problem
11:47:43 <monochrom> compose an XY problem with a YX problem
11:47:49 <benzrf> ha
11:48:22 <benzrf> whatevs ill just use semigroups and sconcat ;-;
11:49:25 <benzrf> Haskell> sconcat $ Nothing :| [Just (Min 2)]
11:49:27 <benzrf> Just (Min {getMin = 2})
11:49:29 <benzrf> :l
11:49:35 <JordiGH> I'm really distraught. Is it really so impossibly difficult to write down the correct algorithm in Haskell? I've been asking for two days and nobody has been able to do it so far. All the attempts I've seen so far are wrong.
11:49:59 <monochrom> perhaps you should start offering a bounty
11:50:10 <JordiGH> Alright, how does 20 USD sound?
11:50:14 <monochrom> the price reflects the demand.
11:50:24 <fragamus> whoah whats the problem
11:50:28 <JordiGH> We can negotiate the price.
11:50:35 <fragamus> i want those dollars
11:50:42 <monochrom> levenstein distance. (sp?)
11:51:18 <JordiGH> fragamus: Translate the following C++ algorithm as literally as possible into Haskell, with comparable speed. It must be O(n) in memory: http://codepad.org/sQTXhqC2
11:51:18 <benzrf> JordiGH: you could use ST if it's an ineherently mutating algo
11:51:29 <benzrf> *inherently
11:51:44 <JordiGH> benzrf: I don't care how you do it as long as it's the same algorithm. Ideally make it readable and use the same variable names as C++ inasmuch as possible.
11:52:21 <JordiGH> fragamus: This is an incorrect attempt, which makes my computer thrash: http://codepad.org/we1B3woa
11:53:29 <JordiGH> fragamus: Can you accept a bitcoin payment? If not, you might have to wait a couple of days for me to do a paypal transaction.
11:53:48 <fragamus> dude i dont want money i just want to help
11:54:02 <JordiGH> Alright, as you wish.
11:54:19 <fragamus> im reading the c++
11:54:46 <JordiGH> Let me know if it's difficult to read. I could write it in pseudocode, if that's clearer.
11:55:04 <frerich> JordiGH: A function to compute the Levenshtein distance between two strings is available in https://hackage.haskell.org/package/edit-distance-0.2.1.2/docs/Text-EditDistance.html
11:55:27 <JordiGH> frerich: Not the same algorithm. I want to see the same damn algorithm, mostly so I can see how to translate an algorithm I already understand.
11:55:44 <JordiGH> frerich: Also, what's in hackage is way slower than my C++ implementation.
11:56:18 <fragamus> ahhh so this is about your quest to learn haskell or is it homework
11:56:24 <JordiGH> My quest to learn Haskell.
11:56:39 <frerich> JordiGH: Are you interested in a solution which is 'idiomatic' in Haskell, or rather something which is as close to the C++ Version as possible, e.g. using mutable data structures, two nested loops etc.?
11:56:47 <chpatrick> hmm
11:57:20 <chpatrick> if you make the dynamic programming table an immutable array, won't haskell only compute each field once?
11:57:21 <exio4> JordiGH: you'd have better luck learning Haskell and using it like it was Haskell, than learning C++, and using Haskell as it was C++ 
11:57:22 <JordiGH> frerich: Idiomatic is fine as long as it's the same or almost the algorithm, i.e. results in comparable speed and comparable manipulation of data structures. I think it's probably okay to use lists instead of arrays, as that should not make a huge difference.
11:57:28 <JordiGH> chpatrick: No, that thrashes.
11:57:58 <chpatrick> have you tried it?
11:58:09 <JordiGH> exio4: Like I said, idiomatic is fine. I just want to see the same algorithm. The language shouldn't dictate what algorithm I use. I don't care if tail call recursion is the replacement for a loop or whatever. I care that the same amount of memory is used in the same or nearly the same data structures.
11:58:15 <exio4> JordiGH: "a huge difference"? linked lists vs arrays? considering that the complexity of most if not all operations in them is different? 
11:58:17 <JordiGH> chpatrick: Yes, I've tried it, it uses too much memory.
11:58:41 <monochrom> I disagree. the language always dictates what algorithm you use
11:58:54 <JordiGH> That's idiotic. A language shouldn't force me to write down an algorithm that thrashes.
11:59:06 <chpatrick> as in levenshtein = table ! ( 0, 0 )
11:59:06 <chpatrick>  where table = fromList [ ... table ! ( foo, bar )  ... ] 
11:59:07 <chpatrick> like that?
11:59:14 <monochrom> if you haven't experienced that, that's only because you have only seen a family of very similar languages
11:59:22 <chpatrick> listArray over fromList
11:59:23 <JordiGH> chpatrick: Oh, I'm not sure about that. But whatever, write down the same or a comparable algorithm and show it to me.
11:59:37 <monochrom> I am not talking about algorithms that thrash
11:59:50 <JordiGH> chpatrick: Do something that only uses two lists or two vectors or two whatevers of working space. O(n) in speed and memory.
12:00:14 <exio4> O(n) with what n? 
12:00:55 <exio4> considering that function takes two inputs, and it's O(a*b)   
12:00:56 <chpatrick> the two row solution is still O(m*n) no?
12:01:02 <chpatrick> in time
12:01:12 <JordiGH> exio4: n = max (length a) (length b)
12:01:46 <frerich> JordiGH: I think your C++ version is the O(m*n) algorithm which is also shown at https://wiki.haskell.org/Edit_distance -- the first function on that page. ,Note how similiar it is to your C++ code.
12:01:50 <JordiGH> chpatrick: Right, it's O(n^2) in time, sorry. O(n) in memory, though.
12:06:23 <k-u> JordiGH: https://en.wikipedia.org/wiki/Talk:Levenshtein_distance#An_O.28n.29_in_space.2C_faster.2C_stricter.2C_tail_recursive_version
12:06:43 <JordiGH> frerich: What are the imports necessary for that command?
12:06:51 <JordiGH> Oh, Data.Array
12:07:47 <JordiGH> frerich: Not the same algorithm as the C++ algorithm. It started using too much memory, but I managed to stop it before it brought my computer to a thrash.
12:07:51 <ReinH> monochrom: such Sapir Whorf wow... ;)
12:07:56 <JordiGH> k-u: I'm going to inspect your solution now.
12:08:09 <frerich> JordiGH: Are you sure it's an algorithmic issue?
12:08:49 <JordiGH> frerich: Yes, algorithms instruct my CPU how much memory to allocate. If one of these algorithms is telling my CPU to allocate too much memory, then it's not the same algorithm as the other. I think your proposal is storing the full table. I am not storing a table in C++.
12:09:26 <k-u> It looks like that code needs some cleaning up though
12:09:47 <mauke> CPUs don't allocate memory
12:09:57 <JordiGH> mauke: They run opcodes that do, whatever.
12:10:19 <fragamus> JordiGH: what is swap
12:10:55 <ReinH> I think there's some confusion about what an algorithm is.
12:10:55 <JordiGH> fragamus: Exchanges the names a and b. Not functional, I know. You might have to use a fold for a comparable effect.
12:11:01 <ReinH> An algorithm is not a list of opcodes.
12:11:58 <JordiGH> ReinH: Never mind the semantics. I want to see how to make Haskell do the same thing or almost the same thing as C++.
12:12:33 <ReinH> "Never mind the semantics" is a pretty dangerous statement when your goal is dependent on understanding semantics.
12:12:44 <JordiGH> fragamus: Still way too slow in ghci, let me try if ghc -O2 makes it work.
12:12:59 <geekosaur> ghci is interpreted and unoptimized
12:13:11 <geekosaur> it's going to be slow no matter what
12:13:15 <ReinH> Specifically, the operationl semantics of a particular implementation of a particular algorithm.
12:13:51 <frerich> JordiGH: ghci is an interactive interpreter applying no optimizations whatsoever, definately make sure to use ghc -O
12:14:08 <JordiGH> k-u: Hm, I wonder why it doesn't work in codepad: http://codepad.org/xTkMJxRG
12:14:17 <JordiGH> It manages to stop in my machine, though.
12:15:32 <JordiGH> ReinH: A full algorithm includes all details. This is why things like the so-called Risch algorithm are not really an algorithm. 
12:16:00 <JordiGH> ReinH: When the Risch algorithm has a step that says "check if this expression is zero", that's not an algorithm at all, it's just a translation of an intractable problem into another.
12:16:18 <ReinH> JordiGH: I'm not sure what you mean by "full" or "details", so I don't know what that statement means. But then, who cares about semantics, right?
12:16:40 <JordiGH> ReinH: Ultimately, a sequence of opcodes.
12:17:12 <ReinH> So your response to "an algorithm is not a list of opcodes" is to define an algorithm as a list of opcodes. Well then.
12:17:15 <JordiGH> Being like "lol i dunno what ghc does" is a crappy attitude for a programmer.
12:17:38 <JordiGH> ReinH: Yes. I need to tell the computer to do things. That's ultimately whey I'm writing down code.
12:17:59 <Freundlich> JordiGH: Thinking that semantics is a sequence of opcodes gets you in trouble in C++ as well.
12:18:30 <JordiGH> Freundlich: I have a pretty good understanding of how my C++ looks when disassembled, having looked at it frequently enough.
12:18:52 <monochrom> and me, GHC
12:18:56 <JordiGH> I know the compiler can do a bunch of crazy things like removing dead code and so forth, but these tricks are less mysterious for smaller snippets of code.
12:19:01 <ReinH> "lol i dunno what ghc does" ... no one saying this.
12:19:03 <JordiGH> lol
12:19:05 <ReinH> *is
12:19:31 <JordiGH> ReinH: I am seeing that attitude, by trying to weasel out of writing down the same C++ algorithm in Haskell by arguing about what "algorithm" means.
12:20:01 <JordiGH> Including how to allocate memory and how to traverse through it.
12:20:02 <ReinH> JordiGH: If you want "the same algorithm", it is necessary to know what you mean by "algorithm".
12:20:09 * hackagebot TTTAS 0.6.0 - Typed Transformations of Typed Abstract Syntax  http://hackage.haskell.org/package/TTTAS-0.6.0 (MarcosViera)
12:20:13 <ReinH> Since your definition is non-standard, it kind of matters.
12:20:20 <JordiGH> ReinH: A sequence of opcodes. I want the same or almost the same sequence of opcodes.
12:20:32 <ReinH> What a silly thing to want, but go ahead.
12:20:33 <Cale> What are you trying to compute here? Edit distance? Levenshtein distance?
12:20:36 <JordiGH> Fine, I don't want an algorithm. I want the same or almost the same sequence of opcodes.
12:20:53 <JordiGH> Cale: O(max(m,n)) memory Levenshtein distance in O(mn) time.
12:21:17 <kadoban> JordiGH: haskell isn't an imperative language, so … that's going to be annoying and non-idiomatic, isn't it? Not sure what the point will be.
12:21:23 <JordiGH> Cale: Everyone except one person so far has proposed an O(mn) in memory algorithm and argued about what "algorithm" means.
12:21:29 <benzrf> hm
12:21:31 <kadoban> Not to mention it doesn't let you work at the opcode level easily, usually.
12:21:42 <JordiGH> kadoban: The point is to do anything I want in Haskell, including having pretty fine-tuned control of opcode.s
12:21:51 <benzrf> > zip [1, 2, 3] (tail [1, 2, 3])
12:21:52 <lambdabot>  [(1,2),(2,3)]
12:21:55 <benzrf> cool
12:22:18 <mauke> JordiGH: allocate some memory, write opcodes to it, cast to function pointer, call
12:22:25 <ReinH> If you expect finely tuned control of opcodes in Haskell, I suppose you'll have to get used to disappointment.
12:22:30 <kadoban> JordiGH: So you essentially want assembly, encoded in haskell? :-/
12:22:44 <mniip> JordiGH, are you still seeking for a translation?
12:22:47 <ReinH> mauke: Or use one of the handy free assembly monads, I suppose.
12:22:52 <Cale> Wait, I don't understand what the trouble is with doing this
12:22:54 <JordiGH> kadoban: I want to have a good control of my computer. I don't want to be bound by the restrictions of ghc.
12:23:09 <ReinH> JordiGH: Then don't use GHC.
12:23:14 <mauke> these "restrictions" are usually called Haskell
12:23:16 <JordiGH> mniip: Well, I would like to see what you do with a translation, but I have found an algorithm that seems to be almost the same to my version.
12:23:17 <Cale> At least asymptotically, it should not be hard to get the same bounds
12:23:32 <mniip> http://codepad.org/efVzk2ut
12:23:34 <Cale> JordiGH: Can you explain the algorithm in English?
12:23:34 <JordiGH> Cale: Can you do it quickly, if it's not hard?
12:23:47 <mniip> more or less direct translation
12:23:49 <kadoban> JordiGH: I can't tell if you actually want what you're saying, or you just want a O(mn) time O(m + n) space implementation of edit distance, or you think one is required for the other.
12:23:59 <ReinH> I'm not sure why someone would come to a high-level function language and expect it to behave like a low-level procedural language.
12:24:03 <JordiGH> Cale: Not in a few sentences, but I can translate the C++ into pseudocdoe, if you wish: http://codepad.org/sQTXhqC2
12:24:07 <ReinH> If you want a low-level procedural language, just use one?
12:24:18 <int-e> how do you load a compiled module into ghci these days?
12:24:19 <JordiGH> mniip: Let me see...
12:24:21 <mniip> oops that extraneous return ()
12:24:24 <Cale> JordiGH: I can read that, let me have a look
12:24:51 <bernalex> I'm not braining properly. how do I write this less stupid: filterType t = filterM ((\_ -> fmap (maybe False (== t)) . flip getMetadataField "type" . itemIdentifier) t)
12:24:53 <monochrom> int-e: :load will do it automatically, under the right conditions (e.g., timestamps)
12:24:57 <JordiGH> mniip: Neat! I know this may not be idiomatic or whatever, but I can see it looks like a translation. Let me try it...
12:25:30 <ReinH> Cale: It wouldnt be too hard to write a reasonable translation with ST and Data.Vector, say, but be aware that JordiGH's definition of "algorithm" is "sequence of opcodes", so I doubt any reasonable translation is going to be satisfactory.
12:25:37 <monochrom> it is a bit brittle. :load may fall back to interpretation on fairly slight pretext
12:25:43 <mauke> bernalex: what's the \_ for?
12:25:44 <int-e> monochrom: oh I forgot -dynamic ... my bad.
12:25:53 <monochrom> oh! ha.. yeah
12:25:55 <mniip> JordiGH, how long does the C++ one take?
12:26:05 <Cale> I'm going to try translating it into a simple recursive function.
12:26:15 <Cale> Or, well, a bunch of mutually recursive ones
12:26:19 <Cale> using no mutation :)
12:26:33 <JordiGH> mniip: Dammit, it's way slower than the Wikipedia version: https://en.wikipedia.org/wiki/Talk:Levenshtein_distance#An_O.28n.29_in_space.2C_faster.2C_stricter.2C_tail_recursive_version
12:26:42 <JordiGH> mniip: It won't stop in under 3 seconds. :-(
12:26:54 <ReinH> Cale: Oh, but that won't be the same "algorithm" using their pet definition. :/
12:26:58 <JordiGH> mniip: The C++ version takes 0.1s on my machine and uses very little memory.
12:27:14 <bennofs> JordiGH: I got a Haskell version that is about 3 times slower
12:27:15 <Cale> JordiGH: If you want, you can just write it in C and FFI to it.
12:27:21 <JordiGH> bennofs: Im curious to see it.
12:27:27 <bernalex> mauke: filterM used to be outside the function. so like f x = x has become f x = g ((\x -> x) x), so \x might as well be \_ because well uh stupid.
12:27:35 <Cale> Or you can use the LLVM package to compile one dynamically and jump into that.
12:27:50 <quchen> Anyone else having trouble installing ghc-mod with Cabal 1.22.2 and GHC 7.10.1? "Not in scope: data constructor ‘ExposePackageId’" it says. There's a corresponding ticket in ghc-mods issue tracker, but people say it builds with those programs in the comments there.
12:27:51 <JordiGH> Cale: Well, the point of the exercise is to understand how to make Haskell do what I want. mniip's attempt will teach me a few things, even if it's way way slower than the C++ version.
12:27:59 <lpaste> bennofs pasted “Distance using vector and bytestring (translate C++ code literally)” at http://lpaste.net/130819
12:28:02 <bennofs> JordiGH: ^^^
12:28:06 <Cale> JordiGH: Okay, well, I'll write something which I think should be instructive.
12:28:18 <quchen> Full build log: http://lpaste.net/130820
12:28:23 <JordiGH> bennofs: I'm curious, please show me.
12:28:27 <Cale> JordiGH: It won't be anything remotely close to opcode identical to your C++ code :P
12:28:29 <bennofs> JordiGH: see the paste
12:28:46 * mniip tries -O3
12:28:55 <mauke> is there a -O3 now?
12:28:56 <monochrom> there is no -O3
12:29:00 <mauke> good
12:29:14 <ReinH> monochrom: patch to GHC that takes -O up to 11.
12:29:15 <k-u> I use -O11
12:29:19 <bennofs> GHC ignores everything > 2 and assumes 2
12:29:20 <mauke> I still remember when -O3 was worse than -O
12:29:27 <bennofs> I think
12:29:32 <JordiGH> bennofs: Yay! Your version is fastest! And does look like a direct translation!
12:29:40 <JordiGH> And probably everyone hates it because it's not functional enough.
12:29:41 <ReinH> mauke: Sometimes -O2 is too!
12:29:48 <JordiGH> But who cares, it's fast and it's in Haskell!
12:30:08 <mniip> well
12:30:10 <bennofs> JordiGH: and it doesn't handle unicode (just like the C++ version)
12:30:16 <JordiGH> bennofs: Thank you thank you thank you thank you.
12:30:19 <mniip> $ time ./levenshtein 
12:30:19 <mniip> 6 real 0m6.327s
12:30:32 <kadoban> JordiGH: Which version is it, out of curiosity? Missed the link
12:30:37 <JordiGH> kadoban: http://lpaste.net/130819
12:30:45 <lpaste> chpatrick pasted “Levenshtein with array knot tying” at http://lpaste.net/130821
12:30:51 <chpatrick> how about this
12:31:10 <JordiGH> bennofs: I like your version a lot.
12:32:23 <int-e> another one... http://lpaste.net/130822
12:33:02 <RyanGlScott> dcoutts: Were there any significant breaking changes from zlib-0.5.4.2 to zlib-0.6.0.0?
12:33:13 <int-e> (I did not aim for speed, obviously)
12:33:17 <ReinH> chpatrick: clever
12:33:21 <JordiGH> int-e: I've noticed that whenever people call this "dynamic programming" despite my protestations to not call it that, they end up writing an O(mn) in memory version.
12:33:37 <int-e> JordiGH: have you...
12:33:48 <JordiGH> int-e: Well, let's see how much memory your version takes.
12:34:07 <xplat> the O(m + n) version is still dynamic programming, though
12:34:09 <int-e> lots because it uses lists, but it'll be linear.
12:34:25 <chpatrick> jordigh: http://lpaste.net/130821
12:34:57 <JordiGH> int-e: Yeah, there's a bit of a slowdown because of the lists, but your version doesn't use a lot of memory.
12:35:15 <Cale> chpatrick: Right, that's the O(mn) space version he's talking about.
12:35:24 <Geekingfrog> JordiGH, how do you track the amount of memory used?
12:35:46 <JordiGH> Geekingfrog: top
12:36:14 <JordiGH> int-e: Actually, I don't know why your version is slower, but I assume the lists have something to do with it.
12:36:39 <frerich> JordiGH: Try writing the C++ version using std::list :-)
12:36:50 <JordiGH> frerich: Why make it slower?
12:36:59 <JordiGH> Oh, to compare with Haskell.
12:37:01 <JordiGH> Sure, let's see.
12:37:32 <frerich> JordiGH: To see *why* it becomes slower. I think the slow programs are quite instructive as well. For what it's worth, your particular implementation benefits a lot from locality of data, i.e. cache hits.
12:37:47 <ReinH> It turns out that measuring high-water memory usage is surprisingly difficult.
12:38:17 <ReinH> frerich: unboxed vectors should benefit somewhat as well
12:38:27 <Cale> +RTS -s should tell you max residency
12:38:42 * mniip rewrites it in the Nasty monad with MutableArray#
12:39:10 <Cale> (though if the program is quick, there might not be enough samples to get it perfect)
12:41:41 <bennofs> mniip: I'm not sure that that will make it any faster than the vector version
12:42:30 <mniip> I wonder if luajit can do better than C++
12:43:01 <ReinH> Cale: thus "surprisingly difficult" ;)
12:44:07 <Cale> ReinH: Perhaps set the master tick interval shorter?
12:44:24 <monochrom> what Heisenberg said. Δmemory * Δtime ≥ constant
12:44:26 <Cale> Or -i
12:44:35 <ReinH> monochrom: :)
12:44:55 <ReinH> You might be paraphrasing a bit.
12:45:10 * hackagebot Spock 0.7.8.0 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.7.8.0 (AlexanderThiemann)
12:45:29 <monochrom> yeah, we can forgive impreciseness in joke :)
12:47:20 <ReinH> luite__: ping
12:49:19 <frerich> JordiGH: Hm, the dynamic programming implememntation in http://lpaste.net/130823 actually seems to perform quite well.
12:49:35 <frerich> JordiGH: It would be interesting to see this version in C++.
12:50:45 <frerich> JordiGH: For me, it's about three times faster than the C++ version compiled with 'g++ -O2'
12:52:01 <ReinH> frerich: I bet you're getting a lot of fusion there?
12:53:20 <bennofs> frerich: oh nice
12:53:40 <frerich> ReinH, bennofs: For the record, I didn't write it - I just saw it on https://wiki.haskell.org/Edit_distance
12:53:42 <JordiGH> frerich: Hm, that's quite verbose.
12:53:59 <JordiGH> frerich: And from the variable names, it's doing something quite different.
12:54:20 <frerich> JordiGH: Yeah, I'd like to see how much code it would be in C++. Can you give it a try?
12:54:30 <mniip> JordiGH, lel
12:54:32 <lpaste> bennofs annotated “Distance using vector and bytestring (translate C++ code literally)” with “C++ code translated literally (now less than 2x slower!)” at http://lpaste.net/130819#a130824
12:54:33 <mniip> luajit beats your C++
12:54:35 <bennofs> JordiGH: ^^^
12:54:45 <ReinH> Heh, bitten by GCC bug on Yosemite while installing hfsevents. Maybe I should try switching back to clang?
12:54:46 <frerich> JordiGH: I wonder whether this is a particular case of an algorithm which really lends itself to a functional style.
12:55:09 <mniip> JordiGH, http://codepad.org/OyxOM2b7
12:55:21 <joe9> any users of yi here? Is it practical enough for daily use?
12:56:36 <JordiGH> frerich: Moment...
12:57:55 <JordiGH> frerich: Oh, yeah, that is quite fast. It would take me a while to understand it and write it in C++, though.
12:58:21 <frerich> JordiGH: Please give it a try! :-)
12:58:30 <Cale> This program doesn't really require mutation at all
12:58:34 <JordiGH> frerich: I guess it's just doing the diagonal of the Levenshtein matrix, so it really is... O(n log n)?
12:58:43 <JordiGH> In time?
12:58:49 <JordiGH> Or maybe O(n).
12:58:55 <Cale> The new row is always a function of the previous row and its own previous elements, so can be constructed by an unfoldrN
12:58:56 <JordiGH> Where n is the max length of the two strings.
12:59:15 <Cale> One sec, I have to reinstall packages to actually see if my version works :P
12:59:23 <frerich> JordiGH: It doesn't use a lot of Haskell-specific features except for layzness. It might be a good example of how a different language makes some algorithm practical or impractical
13:00:09 <JordiGH> frerich: This is cool, thanks.
13:01:45 <ReinH> Welp, time to run ghc in a container, I guess.
13:06:24 <kaiyin> how do you get the first element that satisfies a predicate in a sequence? e.g. (filter pos? [-1 -2 -3 0 1 -2 -3]), but without going through the whole sequence, i.e. return 1 immediately without checking -2 and -3. 
13:06:42 <arkeet> filter and then take the first element of the result.
13:06:47 <mauke> head .: filter
13:06:54 <mauke> :t find
13:06:55 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
13:06:56 <mauke> or find
13:06:59 <arkeet> or find
13:08:15 <Marshall> Hello guys. I'm having cabal problems. I am also completely new to Haskell
13:08:30 <Marshall> I'm trying to install Elm but I get dependencies errors
13:08:49 <arkeet> :t \p -> foldr (<|>) empty . fmap (\x -> x <$ guard (p x))
13:08:50 <lambdabot> (Functor t, Foldable t, Alternative f) => (a -> Bool) -> t a -> f a
13:09:02 <arkeet> :t \p -> foldr ((<|>) . (\x -> x <$ guard (p x))) empty
13:09:03 <lambdabot> (Foldable t, Alternative f) => (a -> Bool) -> t a -> f a
13:10:40 <lpaste> Cale pasted “Pretty immutable implementation. Slower due to all the allocation, larger residency due to slop, but theoretically the same asymptotic complexity as the C++.” at http://lpaste.net/130825
13:10:52 <Cale> JordiGH: ^^
13:11:14 <JordiGH> I like how y'all used my lol and omg variable names.
13:11:40 <JordiGH> Cale: My boss just rang me with something urgent, even though I'm vacation, I'll have to look at your implementation later, but thanks!
13:12:17 <uglemat> `Endofunctor: A functor that maps a category to itself.` "to itself" is kind of confusing. Would it be incorrect to think that all functors in Haskell are endofunctors, because 'types/functions` compromise the `objects/morphisms` of a category, and therefore any haskell code is "closed under" this overarching category?
13:13:18 <arkeet> all Functor instances in haskell are endofunctors on the category of haskell types.
13:13:29 <arkeet> they map types to types.
13:13:33 * frerich reads Cale's version and feels stupid for not realizing that his 'intercalat "," (map show [1..1000])' is the same as 'show [1..1000]'.
13:13:54 <arkeet> frerich: I was wondering why you didn't just show [1..1000] in your version :p
13:15:01 <frerich> arkeet: I don't know, not show'ing anything but numbers is somehow burned into my brain.
13:15:10 * hackagebot euler 0.9.2 - Mathematics utilities for Haskell  http://hackage.haskell.org/package/euler-0.9.2 (decomputed)
13:15:11 <arkeet> heh
13:15:24 <Cale> JordiGH: When you do, lev1 is the continuation of the C++ code at the top of the outer for loop, and lev2 is the continuation of a point just after the loop test
13:16:02 * JordiGH adds that as a comment.
13:18:05 <Cale> Maybe I should rewrite this using mutable vectors in the same way and see how that looks.
13:19:30 <uglemat> arkeet,  Ok, that makes more sense. I think the confusion arises because I can't come up with a concrete counterexample in haskell, so therefore when I read `endofunctor` in some tutorial on monads the uncertainty taints the clarity of the rest of the tutorial
13:19:44 <frerich> Cale: I like how you got it to be fairly efficient without sacrifying too much.
13:20:03 <frerich> Cale: Makes me wonder whether there's some low-hanging fruit (unboxed values?).
13:20:27 <arkeet> uglemat: there are lots of functors that aren't endofunctors, but no one really talks about them in haskell.
13:20:35 <Cale> frerich: Oh, there's no doubt things which could be done to improve that version if you wanted to cheat a bit by looking at the Core and tweaking things
13:20:50 <arkeet> I mean there are lots in mathematics in general.
13:21:45 <Marshall> Guys, can anyone help me with installing Elm using cabal?
13:21:46 <Cale> Unless you want to consider every Haskell type to be a preorder category based on the definedness ordering, and every (monomorphic) Haskell function to be a functor between those.
13:22:08 <Cale> A continuous functor no less :)
13:22:54 <Marshall> Guess not
13:23:14 <Cale> Marshall: uhhh, it might help if you provided information about what trouble you were having :)
13:23:35 <arkeet> what's a continuous functor?
13:23:44 <arkeet> I know what a continuous function is.
13:23:48 <Cale> arkeet: One which preserves all small limits.
13:23:55 <arkeet> right.
13:24:03 <Hijiri> I keep forgetting to ask this question
13:24:07 <arkeet> we don't really have any limits in haskell other than products though.
13:24:11 <Hijiri> it's about some notation in awodey, let me find it
13:24:28 <Cale> arkeet: You have to remember what the categories are here
13:24:41 <Cale> arkeet: I'm saying treat the values of each type as the objects of a category
13:24:45 <arkeet> oh you said the categories are the types.
13:24:46 <Marshall> Sure! I'm running "cabal install -j elm-compiler-0.14.1 elm-package-0.4 elm-make-0.1.1" to try and install elm and I get the following error: http://pastebin.com/pn0pqVmh
13:24:51 <arkeet> fine then.
13:24:57 <Cale> arkeet: where there's exactly one arrow a -> b whenever a <= b in the definedness ordering
13:25:00 <Cale> and no others
13:25:05 <arkeet> yeah.
13:25:13 <Cale> So there's always an initial object _|_
13:25:56 <Cale> and all functors from the preorder category on the natural numbers have limits
13:25:58 <arkeet> Marshall: so it depends on stuff that asks for an older version of ghc (base 4.8 is ghc 7.10)
13:26:07 <arkeet> Marshall: what if you try --allow-newer?
13:26:32 <Cale> e.g. the limit of the diagram _|_ -> 1 : _|_ -> 1 : 1 : _|_ -> ... will be the infinite list of 1s.
13:27:00 <arkeet> Marshall: (it might still fail if those packages don't build with 7.10)
13:27:24 <arkeet> otherwise you might want to try using 7.8 to build it
13:27:29 <Marshall> arkeet: Holy crap, that worked! Thank you so much!
13:27:49 <Cale> Good thing, I tried to open Marshall's pastebin and got a picture of a cat
13:28:00 <Marshall> Now it's installing a whole bunch of stuff, but It's looking good
13:28:10 <arkeet> it might fail partway through
13:28:31 <Marshall> I'm forever optimistic
13:28:48 <Marshall> Damn my CPU is maxed out :D
13:30:07 <Marshall> Is it really normal for it to be installing so many packages?
13:30:28 <Marshall> Elm seems to depened on everything in the universe
13:30:37 <Xe> yea
13:33:38 <Marshall> It failed :( ecmascript won't install http://pastebin.com/i8wx7PN5
13:35:22 <geekosaur> 7.10.1 claims another victim...
13:35:28 <Marshall> Tried it again and it failed again
13:35:34 <Marshall> What now?
13:35:54 <arkeet> fix ecmascript, or build it with 7.8
13:35:55 <geekosaur> [16 20:24] <arkeet> Marshall: (it might still fail if those packages don't build with 7.10)
13:36:09 <geekosaur> [16 20:24] <arkeet> otherwise you might want to try using 7.8 to build it
13:36:15 <monochrom> frerich: unboxing some data (the ones you will also make eager not lazy by other considerations) is a common thing for efficiency
13:36:40 <pavonia> (<$>) is in Prelude now?
13:36:47 <Marshall> How.. how do I build with 7.8? I'm not entierly sure what that even means
13:36:52 <geekosaur> as of 7.10.1, yes
13:36:53 <arkeet> install ghc 7.8
13:36:54 <arkeet> and use that instead
13:36:55 <arkeet> 7.8.4
13:37:13 <monochrom> Bytestring, Text, Map, and Set do this, for example, to their internal "length" and "size" fields
13:37:20 <Marshall> Install it with my package manager or cabal?
13:37:26 <arkeet> you can't install ghc with cabal
13:37:30 <Marshall> Okay
13:37:45 <bergmark> Marshall: easy to patch it locally if you want
13:37:48 <geekosaur> ghc 7.10.1 is still new and the ecosystem hasn't caught up with it yet, notably stuff liek that (Control.Applicative was merged into the Prelude, so its <$> is now in scope by default)
13:37:51 <bergmark> but yeah, safer to stick with 7.8 for now
13:37:52 <athan> pavonia: Not that I've seen, still in Control.Applicative
13:38:00 <athan> oh woah
13:38:16 <bergmark> i would recommend people who dislike issues to stick with 7.8 until https://github.com/fpco/stackage/issues/378 is closed, at least
13:38:38 <Marshall> How about 7.6, guys? That's what I've found in AUR
13:38:48 <orzo> Is there a rem function but for non integers?
13:38:48 <arkeet> 7.6 is pretty old
13:38:49 <bergmark> 7.8 is the safest i think
13:39:04 <bergmark> 7.6 probably works for most things, more things than 7.10 at least!
13:39:07 <arkeet> true.
13:39:42 <bergmark> geekosaur: well <$> was an entirely different proposal from Control.Applicative in prelude!
13:39:44 <Marshall> I'm affraid It's my only choice, unless there is a way to get older packages in arch
13:40:04 <bergmark> older than 7.6? O_o
13:40:07 <bergmark> don't do that :D
13:40:16 <arkeet> 7.8 is newer than 7.6/.
13:40:55 <Marshall> I understand that, but I can't find a package for 7.8, the earliest before 7.10. is 7.6
13:41:09 <Cale> I wonder why the mutable vector modules don't have equivalents of generate and such.
13:41:26 <bergmark> Marshall: maybe they skipped a version? for whatever reason
13:41:52 <bergmark> you can install from the bindist too, it's simple
13:41:58 <monochrom> the mutable modules receive less interest
13:42:07 <Marshall> Just out of curiosity, does Haskell break backwards compatability often?
13:42:31 <monochrom> all the coolness is in adding more fusion to the immutable modules. academically and practically.
13:42:32 <bergmark> Marshall: i think every release breaks *something*
13:42:42 <Cale> monochrom: I suppose that's true
13:42:48 <dolio> Doesn't break enough, really.
13:42:57 <bergmark> well :_)
13:43:03 <lexir> Marshall: You're on arch?
13:43:03 <lexir> Marshall: The repos have 7.10.1
13:43:12 <absence> amazing error message: "ghc.exe: unrecognised flag: -ddump-simple. did you mean one of: -ddump-simpl" it's like the people who invent names like flickr have taken over :)
13:43:22 <bergmark> Marshall: go with 7.6, i think that'll be fine
13:43:29 <Marshall> Isn't 7.10 too early?
13:43:34 <Marshall> Sorry, too late
13:43:40 <Marshall> That is, too new
13:43:44 <bergmark> too late or too early :D
13:44:02 <Marshall> Let's hope 7.6 works
13:44:39 <monochrom> absence: it was meant to be "simplifier" shortened
13:44:48 <bergmark> supporting 7.4 is a big leap (for us at least), but supporting 7.6 after moving to 7.8 was no problem
13:44:54 <monochrom> rather than "simple" shortened
13:45:16 <absence> monochrom: ok, that makes a bit more sense :)
13:45:31 <monochrom> however, etymology is not always useful. mnemonics such as "think flickr" are better!
13:45:43 <lexir> Marshall: What are you afraid to break?
13:46:28 <Marshall> ecmascript won't build from cabal with 7.10
13:46:55 <monochrom> you do not have to get ghc from AUR
13:47:14 <absence> what do i have to add to ghc-options to output core to a file rather than to the screen?
13:47:17 <monochrom> ok, maybe you do, I haven't asked.
13:47:31 <Marshall> where should I get it from?
13:47:41 <monochrom> www.haskell.org/ghc/
13:48:19 <monochrom> they have binaries. no need to choose between AUR and "build from source"
13:48:34 <monochrom> there is always a 3rd way out
13:49:00 <Marshall> But that's not an arch package
13:49:02 <Marshall> Kinda messy
13:49:33 <Marshall> Guess I could make it into one, but I've never done that before
13:49:42 <monochrom> use --prefix=/usr/local/ghc-7.8.4 and play with PATH
13:50:07 <monochrom> then next year you will just erase /usr/local/ghc-7.8.4
13:50:41 <Marshall> Uhh, I'll do that if 7.6 does not work
13:51:03 <monochrom> do not invoke the slippery slope "imagine doing that to all software I use". no one is implying that.
13:51:22 <Marshall> Of course not, wasn't going to :)
13:51:29 <Marshall> It's just messy, that's all
13:51:43 <Marshall> But if I have to, I'll do it
13:52:37 <Marshall> Is it the consensus that cabal is shit or am I just having a bad first impression?
13:53:00 <glguy> It's actually pretty good.
13:53:04 <monochrom> not shit
13:53:25 <Marshall> Really? Guess I'm just unlucky
13:53:38 <lexir> Marshall: A lot of work has gone into cabal.
13:54:10 <Marshall> I read on the wiki that It's "not a real package manager" and can lead to "cabal hell"
13:54:15 <athan> Marshall: Learn sandboxes
13:54:26 <Marshall> SO I got the wrong impression I guess
13:54:30 <lexir> More like use not learn.
13:54:30 <athan> Marshall: It doesn't do everything, but it does a lot
13:54:35 <glguy> It helps to have an idea of what you're trying to do. A lot of people try guessing how it works and get aggravated when they guessed wrong
13:54:38 <lexir> Marshall: Yes you can easily end up in cabal hell.
13:55:01 <Marshall> Don't think I need a sandbox yet since I only plan to use it for Elm
13:55:25 <Marshall> I'll probably learn Haskell during summer, I'll figure it out hen
13:55:28 <Marshall> *then
13:55:57 <tulcod> Marshall: i can really advice sandboxes
13:56:03 <Marshall> Either Haskell or Clojure, haven't decided yet
13:56:28 <tulcod> Marshall: run "cabal sandbox init" in your main development directory, and then every "cabal" command from then on in any subdirectory of that will act on the sandbox
13:56:37 <athan> Marshall: They basically eliminate cabal hell
13:56:40 <hodapp> Marshall: both nice languages
13:56:41 <tulcod> Marshall: it *will* save you trouble
13:56:51 <hexagoxel> no, _not_ in any subdirectory
13:56:57 <Marshall> I got the impression that sandboxes are only useful when you are working on more than one project
13:56:59 <glguy> cabal hell practically doesn't exist any more, cabal hell used to be actual issues in cabal
13:57:09 <Marshall> It says so here http://elm-lang.org/Install.elm
13:57:12 <glguy> current problems are just smashing packages together that actually have conflicts
13:57:22 <glguy> and cabal is just the bearer of bad news
13:57:29 <tulcod> Marshall: well yes, but sometimes you want to test something, or just start from scratch, or ...
13:57:30 <monochrom> no, "They basically eliminate cabal hell" is a dangerous thing to say. unreal expectation. cabal hell is possible in each sandbox.
13:57:55 <monochrom> the accurate position is "they decrease the probability"
13:58:06 <athan> Marshall: I do it all the time for standalone executables
13:58:09 <tulcod> Marshall: sandboxes are easy to make, and easy to dump. they might not solve all your problems, but they can help
13:58:10 <athan> web servers, hlint, hoogle, etc
13:58:41 <Marshall> Okay, okay. If using 7.6 doesn't work, I'm making a damn sandbox
13:58:44 <athan> monochrom: Can I say that it makes cabal hell more fun? :)
13:58:59 <monochrom> that's perverse
13:59:06 <athan> -_-
13:59:12 <athan> u_u
13:59:44 <monochrom> in fact, sandboxing eliminates the easy half of cabal hell, not the difficult half.
14:00:07 <lexir> hodapp: Which one do you prefer between clojure and haskell?
14:00:32 <hodapp> lexir: well, I definitely have more experience with Haskell
14:00:34 <monochrom> the easy half is: you have several projects, one wants wai-1.1, another wants wai-2.2. note that wai does not come with ghc.
14:00:49 <lexir> Marshall: You're making creating a soundbox sound hard. It's really easy. It's actually harder to not use a sandbox.
14:00:52 <lexir> Marshall: :)
14:00:58 <hodapp> lexir: so, not sure. Depends whether I'm stuck on JVM or not.
14:01:10 <monochrom> the difficult half is: your project depends on X and Y, X wants the bytestring that comes with your ghc, Y wants some other bytestring.
14:01:15 <lexir> hodapp: If you're not stuck to the JVM?
14:01:20 <int-e> Marshall: btw, rather than using ghc-7.6.3 how about http://seblu.net/a/arm/2015/04/01/extra/os/x86_64/ghc-7.8.4-1-x86_64.pkg.tar.xz
14:01:35 <hodapp> lexir: I don't really know for sure. I'd need more experience with Clojure
14:01:47 <monochrom> therefore, ironically, after sandboxing, P(can't solve the problem | a problem arises) is higher, not lower.
14:01:59 <lexir> Haskell is the only functional language I know.
14:02:13 <hodapp> I've worked with Scala, Clojure, Lisp, tiny bit of ML, and Coq.
14:02:14 <monochrom> this is a consequence of "what doesn't kill them makes them stronger"
14:02:17 <int-e> Marshall: see also https://wiki.archlinux.org/index.php/Arch_Rollback_Machine (since you probably need more packages than just ghc)
14:02:27 <Marshall> int-e: I already talked with monochrom about that, I'd rather use a package if I can
14:02:34 <lexir> It's also the only language I've actually written something deployable from scratch in.
14:03:29 <lexir> I'm new to programming as a whole.
14:03:54 <Marshall> Woah, you started with Haskell? Thatp's pretty hardcore
14:04:02 <lexir> and haskell makes it easy to contribute to major open source projects. I guess because it's not cluttered and guys are super friendly.
14:04:11 <ralu> starting any language is pretty hardcore
14:04:32 <Marshall> The community is really nice, as I have learned today
14:04:47 <lexir> Marshall: I didn't really start with haskell. I started with C++ in school then python then ruby. I was an intern writing ruby on rails at a point.
14:04:53 <hodapp> Marshall: by general standards, or compared with ##c++ and ##c?
14:04:57 <athan> Marshall: It's the dank, technically
14:05:26 <Marshall> Then you have not just starte
14:05:31 <Marshall> *You are not really new to programming then
14:05:36 <lexir> Marshall: Then the FP craze came and I tried haskell. I've never looked back.
14:05:45 <athan> Haskell also gives you high-level composability - not something I've found in C/JavaScript
14:06:21 <Marshall> hodapp: I never needed IRC help for c or c++, so I would not know
14:06:35 <athan> Marshall: For instance, a web server is just a higher-order function `Request -> (Response -> IO ()) -> IO ()`
14:06:35 <Marshall> Or do you mean as a starting language?
14:06:42 <lexir> Marshall: I'll take that as a compliment.
14:06:45 <Cale> lol, my Haskell version of Levenshtein distance is now faster than JordiGH's
14:06:51 <Cale> But it uses ST
14:07:03 <lpaste> Cale pasted “Quite fast version using mutable vectors” at http://lpaste.net/130827
14:07:13 <Cale> Runs faster than the C++ code on my machine
14:07:14 <lexir> athan: WOW that's helpful. I'm doing something like rewriting a web server right now.
14:07:23 <Cale> I suspect beacuse I don't actually swap the vectors
14:07:29 <Cale> I just swap references to them
14:07:35 <lexir> Marshall: I guess you could say Ruby really helped me.
14:07:35 <hodapp> Marshall: those two channels are cesspools, to put it loosely.
14:07:35 <athan> lexir: Check this out: https://github.com/athanclark/hi-basic-web-server :)
14:07:42 <athan> it uses scotty, but it still works
14:07:54 <hodapp> Marshall: having been in all of them and this, I find #haskell so much more helpful that it's ridiculous.
14:07:59 <athan> also https://github.com/athanclark/deconfigured is my website (also out of date :\)
14:08:24 <athan> lexir: I've almost got a pretty nice routing library done that should be "better" than scotty
14:08:37 <Marshall> This is actually the only time I really got help from IRC
14:08:40 <Marshall> It's awesome
14:09:05 <athan> Marshall: Just wait until you get into Functors
14:09:12 <Marshall> Can't wait to learn Haskell so I can hang in here
14:09:22 <absence> is there an option tha makes ghc report when a function is inlined?
14:09:49 <Marshall> Ok guys, ghc7.6 is ready. How do I make cabal use that?
14:10:03 <athan> Marshall: It should just be in your PATH
14:10:11 <athan> the `ghc` binary, I mean
14:10:19 <Cale> Marshall: Don't worry about hanging out in here even before you know Haskell. Beginner questions are always welcome here :)
14:10:28 <athan> If you've installed haskell-platform, you should be all set :)
14:11:04 <Marshall> The thing is I have two ghc-s now, 7.10 and 7.6
14:11:18 <Marshall> Should I hide one or something?
14:12:15 <Cale> It not only runs faster than the C++ code, it runs almost 5 times faster than the C++ code :D
14:12:43 <athan> Marshall: Yeah, I would hide 7.10 until you're familiar with the system
14:12:53 <athan> (honestly I don't think it really matters, actually)
14:13:14 <athan> the behaviour should be the same
14:13:31 <verement> Well done, Cale
14:13:35 <Marshall> Both binaries are in the path, how will cabal know which to use?
14:13:54 <Marshall> I tried running the install command again, same error
14:13:56 <athan> Cale: Don't they have awards for this kind of thing? :)
14:14:06 <josephle> Cale, shouldn't JordiGH's swap also be roughly constant since it's swapping vectors?
14:14:10 <athan> Marshall: What's the error?
14:14:19 <xplat> Marshall: in general, you end up with the one in the leftmost directory in the path
14:14:23 <Cale> josephle: I dunno
14:14:23 <athan> Also, what's the output of `cabal --version`?
14:14:27 <solrize_> join #cabal
14:14:29 <Cale> josephle: I'm not sure how it's implemented
14:14:51 <josephle> Cale, the c++ reference is telling me it involves a ctor and two assignments
14:14:57 <Marshall> http://pastebin.com/i8wx7PN5 when running "cabal install -j --allow-newer elm-compiler-0.14.1 elm-package-0.4 elm-make-0.1.1"
14:15:13 <Marshall> xplat: both are in /usr/bin
14:15:14 <Cale> josephle: Okay, well, if that's the case, I'm not sure what additional work the C++ code is doing
14:15:34 <Marshall> Should I just move one from bin?
14:15:37 <athan> oh woah haha
14:15:53 <Marshall> Or maybe I should uninstall ghc 7.10
14:15:55 <Marshall> for now
14:15:56 <athan> Marshall: I think the package language-ecmascript is a bit outdated
14:16:06 <athan> this is a namespace issue, not a low-level one
14:16:15 <Marshall> Ain't nothing I can do about that
14:16:19 <Marshall> Elm requires it
14:16:24 <xplat> Marshall: you can't have two executable in the same directory with the same name :-/
14:16:25 <athan> arg
14:16:27 <athan> here one sec
14:16:36 <Marshall> They don't have the same name
14:16:42 <xplat> Marshall: so it gets whichever one you type
14:16:55 <frerich> Cale: Are you sure? Alas, I removed JordiGH's C++ code but IIRC it had the same runtime as your mutable version for me.
14:17:08 <Cale> frerich: hmm
14:17:12 <Marshall> Here: http://pastebin.com/1hWf2Hbp
14:17:17 <Cale> frerich: Maybe my C++ compiler sucks more than yours
14:17:31 <frerich> Cale: I use 'Apple LLVM version 6.1.0 (clang-602.0.49) (based on LLVM 3.6.0svn)' with -O2
14:17:42 <Marshall> I have no clue which binary cabal is made to use, or what ghc points to
14:17:55 <frerich> Cale: Still on ghc 7.8.3 though.
14:17:55 <lexir> athan: Sorry my connection is terrible. I keep going offline.
14:17:58 <Marshall> I'll just uninstall 7.10
14:17:59 <koala_man> how do you know whether such a program actually does the algorithm, or whether it precomputes a lot of it since the inputs are known?
14:17:59 <lexir> athan: Have you used yesod or know how it works?
14:18:02 <athan> Marshall: My routine is usually `cabal unpack foo && cabal sandbox init && cabal install` for a sandboxed lib
14:18:13 <athan> lexir: I've used it a few times, but I don't think it's for me :\
14:18:23 <lexir> athan: Why so?
14:18:31 <athan> lexir: Too many type errors :x
14:18:42 <athan> also, the routes are pretty restrictive
14:18:53 <athan> idk, it's too monolithic imo
14:19:17 <lexir> athan: They save you from yourself. My only issue is with forms but mine is probably because I don't know enough.
14:19:39 <Cale> frerich: Oh! I just realised that I forgot to build the C++ code with optimisations. Now they run in identical time for me too. Well, that's all right I suppose :)
14:20:05 <lexir> athan: Anyhoo I am trying to decouple the yesod-devel server in a way right now.
14:20:14 <athan> Idk, I think it's design is interesting don't get me wrong, but I just don't think it's the way I'd imagine for a small web server
14:20:26 <athan> Oh that should be pretty easy
14:20:36 <athan> just `cabal sandbox init && cabal install && cabal exec foo` :)
14:20:39 <athan> no need to yesod-devel
14:21:14 <frerich> Cale: In a sense, I think it's more than all right, given what your levenshtein function can *not* do in comparison to the C++ Code. :o)
14:21:14 <athan> Marshall: I'm getting a build error with language-glsl too :\
14:21:38 <Cale> frerich: yeah
14:21:40 <athan> I'm not sure if elm is well maintained ._.
14:21:41 <lexir> athan: What do you mean? I'm making changes to the source.
14:21:48 <lexir> athan: I've forked it.
14:21:52 <athan> lexir: Oh... wait, wat :|
14:22:26 <Marshall> Ok, now nothing works :P
14:22:33 <athan> :D
14:22:42 <athan> Marshall: Just start with haskell-platform!
14:22:48 <athan> save you some pain :\
14:22:56 <newsham> hmm.. is there no std def for [minBound..maxBound]?
14:22:58 <Marshall> I've manually moved ghc to ghc_old and put ghc-7.6 in it's place
14:23:07 <Marshall> Did the same for ghc-pkg
14:23:14 <Marshall> cabal is going crazy
14:23:23 <athan> No doubt
14:23:27 <Cale> Okay, time to get try-reflex working...
14:23:28 <Marshall> So I'mma reverse that, remove ghc 7.6
14:23:35 <Cale> I want to write a board game :)
14:23:39 <Marshall> And I guess call it a day
14:23:56 <Marshall> Since it's 23:00 here and I have school tommorow morning :D
14:24:30 <Marshall> athan, isn't haskell-platform depracted? It says so on the wiki. Also, it porbably also has ghc 7.10
14:24:36 <athan> Cale: I want a turn-based board game with time warping o_O
14:24:54 <mniip> to the State monad!
14:24:55 <athan> Marshall: It kindof is... I think it uses 7.6
14:24:58 <Cale> athan: You might just be in luck, depending on what you mean by time warping?
14:25:01 <athan> but, it still gives you all the working bits
14:25:10 <lexir> Marshall: Waddup, have you tried using a sandbox?
14:25:14 <athan> Cale: Just reversing moves and stuff :)
14:25:21 <Cale> oh, okay
14:26:17 <athan> Time to mash my fingers like there's no tomorrow, see ya folks!
14:26:22 <Cale> athan: It's going to be a Chess-like game (2D board with pieces on it) with Prismata's resource system, and constructible/upgradeable units, as well as buildings that give you more movement/attacks per turn so long as certain conditions are met
14:26:31 <Marshall> lexir: No, not yet. I don't think it would help.
14:26:44 <Marshall> Will try it tommorow, have to sleep now
14:27:35 <Marshall> Cale: You are developing a game with Haskell?
14:27:48 <Cale> Marshall: Indeed
14:28:04 <frerich> Cale: A 'Battle Isle' clone would be great. A turn-based game on a board with hexagon fields and upgradeable units.
14:28:11 <Cale> Marshall: In fact, if all goes according to plan, it'll be mostly Haskell compiled to Javascript.
14:28:18 <hodapp> ghcjs?
14:28:21 <Cale> yeah
14:28:24 <Cale> and Reflex
14:28:28 <hodapp> Reflex?
14:28:36 <Cale> I want to learn Reflex and Reflex.Dom
14:28:37 <frerich> Cale: https://upload.wikimedia.org/wikipedia/en/1/1b/Battle_Isle_1_screenshot.png is how it looked.
14:28:41 <Marshall> I searched around for gamedev libs for Haskell, since that stuff is important to me in a language, but didn't find much
14:28:55 <Marshall> Are you using FPR?
14:29:21 <Cale> frerich: I think I'm going to have a square grid with octagonal pieces that have sockets into which you put drives (movement upgrades) and weapons.
14:29:38 <Cale> (which act in the direction according to which socket you put them in)
14:29:59 <Cale> Marshall: Yeah, Reflex is an FRP library
14:30:36 <Cale> Marshall: There's only so much in existence, you have to beat a path through the jungle most of the time.
14:31:08 <Marshall> I'm very happy to hear that gamedev in Haskell is feasable. It's a great excuse to learn it
14:31:23 <solrize_> anyone know how to deal with this?  http://lpaste.net/130829  it's from attempting cabal install gitit, which pulls in happstack and tries to compile it and gets that error, but unfortunately doesn't leave the source files around 
14:31:34 <Marshall> If you want FPR that compiles to javascript, why not use Elm?
14:31:38 <tulcod> Cale: i watched the presentation as per your recommendation. fun stuff.
14:31:53 <Cale> Marshall: Well, I worked on an action RPG in Haskell for a few years that never got released sadly, but was pretty convincing at least to me that game development is possible in Haskell.
14:32:15 <tulcod> Cale: the fact that it looks like a sane library with mathematical motives is quite exciting i'd say
14:32:16 <Cale> Marshall: (the startup I was working for ran out of funds to pay us)
14:33:03 <Marshall> It seems to me that gamedev in functional languages is mediocre everywhere
14:33:36 <Marshall> Which is really too bad, since games could use statless stuff the most
14:34:03 <Cale> Marshall: It had pretty fun combat against a handful of different AI types, and a big open dynamically loaded world with an editor, but it lacked most of the things required to actually make it the RPG we wanted, and the world was still mostly empty at the time we stopped.
14:34:03 <bob_twinkles> except garbage collecters have a pretty bad reputation in gamedev, especially for engine code
14:34:13 <Marshall> And component based systems end up being really complex really quickly
14:34:49 <Marshall> This was a 2D RPG, right?
14:34:54 <Cale> 3D overhead
14:34:59 <Marshall> This was a 2D RPG, right?
14:35:12 <solrize_> oh i see, it leaves the source in a .tgz file
14:35:25 <Marshall> Wow, so you can even do 3D?
14:35:28 <Cale> I guess it depends on how you measure the dimensionality of the game
14:35:42 <Cale> We were using OpenGL and drawing 3D models to the screen :P
14:35:57 <Cale> The actual game mechanics were all 2D
14:36:34 <Marshall> I was talking about rendering
14:36:36 <Cale> yeah
14:36:55 <Marshall> If you can render 3D, surely it's not much harder to actually use it in the mechanics if you need that
14:37:05 <tulcod> Marshall: haha
14:37:12 <Cale> Yeah, I mean, from a technical perspective, sure.
14:37:28 <Marshall> I just wasn't sure if it's fast enough for 3D game rendering
14:38:03 <Marshall> I thought C++ was the only viable thing for 3D engines, maybe Java and C#
14:38:21 <tulcod> Marshall: in 2d game mechanics you can get away with small hacks. in 3d you need a proper physics engine.
14:38:24 <Cale> Well, Haskell code can run just as fast as C++ code if you do it right.
14:38:37 <Cale> There is the garbage collector
14:38:43 <Marshall> Although I don't know how fast Haskell is
14:38:43 <hpc> C++ code can run just as slow as python if you do it right too ;)
14:38:51 <Marshall> Oh, really?
14:38:54 <bernalex> hpc: fsvo "right"
14:38:57 <Cale> On the oldest iPhones that we wanted to target, the GC would actually have been a significant problem
14:39:00 <bernalex> hpc: which mostly encompasses "wrong"
14:39:16 <Cale> and we had a plan to use a C++ shim for drawing animations through garbage collections to help with that
14:39:31 <bernalex> Cale: did you use opengl/sdl/openal?
14:39:31 <pchiusano> I am looking at Data.Bytes the MonadPut class: https://hackage.haskell.org/package/bytes-0.15/docs/Data-Bytes-Put.html
14:39:50 <pchiusano> somehow the minimum complete definition is nothing… how is that possible
14:40:00 <Cale> bernalex: OpenGL
14:40:03 <Cale> (ES)
14:40:08 <Marshall> Cale, was the RPG also FPR?
14:40:19 <Cale> Yeah, we had our own FRP system
14:40:24 <Marshall> Oh cool
14:40:25 <Cale> which was Arrow-y in style
14:40:44 <bernalex> Cale: did you make any useful high-ish-level library on top of that? I think that's what's keeping haskell from going big for games really. being able to construct graphical elements in a denotative manner rather than imperative.
14:40:47 <Cale> (though we also had our own Arrow class and proc/do-notation preprocessor
14:40:49 <Cale> )
14:41:01 <Marshall> Because just wrapping OpenGL in Haskell doesn't seem very useful
14:41:24 <Cale> bernalex: tbh, the rendering code was mostly entirely separate from the FRP system
14:41:39 <bernalex> Marshall: well, it's certainly useful in that you can do it and make things. but it's unpleasant.
14:41:43 <Cale> We were using FRP for the AIs and player control and game state
14:41:47 <bernalex> Cale: I don't understand what that means in relation to my question.
14:41:58 <EvanR> the bare bones gl wrapper is still easier to get right than C
14:42:05 <Cale> bernalex: On top of what exactly?
14:42:07 <Marshall> And that is  what most FP gamedev libs do, they just wrap, side effects and all
14:42:07 <EvanR> but still not the greatest
14:42:11 <Cale> bernalex: The FRP system?
14:42:20 <Cale> bernalex: The FRP system was pretty high level already :)
14:42:22 <bernalex> Cale: I meant if you made any libraries/whatever for programming graphical elements in a declarative manner rather than low-level-y opengl bindings by themselves.
14:42:39 <Cale> Oh, no, we hadn't done anything too special in that regard
14:43:40 <EvanR> a dsl for describing how to render a scene is one thing, programming a game is another
14:43:56 <Cale> In fact it was unclear as to whether we'd just keep using the Haskell reference implementation of our display stuff, or use the C++ version, but it was all pretty simple stuff -- we had a sum type of primitive things which could be rendered, and you hand it those and it drew them.
14:44:29 <Cale> I didn't really touch that code much, so I might be missing some of the complexity of it :)
14:44:57 <Cale> Stephen Blackheath had written it before I was even hired.
14:45:29 <Marshall> Okay, I really have to go to sleep. Goodbye everybody and thank you very much for the help.
14:45:50 <Cale> But it was intentionally quite simple, because the originally planned C++ version of the renderer was supposed to be kept as small as possible.
14:46:09 <Cale> As we went on, it became less clear that we'd even need it
14:46:17 <Cale> because phones were getting faster
14:47:20 <Cale> I think we originally wanted to be able to target the iPhone 2, and on that, a major GC (about once every 5 minutes) would take 300ms, which is very noticeable.
14:47:21 <EvanR> Cale: im curious what was the point of the c++, how was the haskell for rendering too slow ?
14:47:54 <Cale> So, the plan was just to have enough non-GCed C++ code to keep animations playing through that, even if control would get delayed.
14:48:25 <Cale> But like, on modern phones, I don't know if that sort of measure would even be required.
14:48:35 <EvanR> haskell code to control the c++ didnt have the gc issue?
14:49:07 <Cale> Well, the Haskell code might be garbage collecting, but the C++ would be able to continue playing whatever (3D) animations it was playing, along with basic motion.
14:49:45 <EvanR> oh it was async play animations
14:49:49 <EvanR> playing
14:49:51 <Cale> yeah
14:50:39 <Cale> There's some hairiness involved with doing that of course, but not as much hairiness as actually developing an FRP system with good performance :)
14:51:29 <EvanR> performance is one issue commonly cited when mentioning frp implementation in practice
14:51:52 <Cale> Some of the ideas in Reflex are based on the ideas from the work we did there
14:51:53 <EvanR> but another is how easy it is to actually use for stuff, like is it composable in the right way
14:52:12 <Cale> I'm excited to see what Ryan's done in the meantime. He's freed the system from Arrows, which is pretty cool :)
14:54:23 <EvanR> have you tried yampa?
14:56:15 <EvanR> im curious what people say about that one
15:00:11 * hackagebot dicom 0.1.0.0 - A library for reading and writing DICOM files in the Explicit VR Little Endian transfer syntax.  http://hackage.haskell.org/package/dicom-0.1.0.0 (PhilFreeman)
15:02:19 <Cale> EvanR: Yampa is what we started out with before we began writing our own FRP systems
15:03:08 <Cale> EvanR: It's okay for what it is, but I'd expect most modern FRP implementations to be an improvement.
15:03:31 <EvanR> so what needed improving
15:06:34 <Guest15710> hi there. Can i pattern match with composition operator?
15:06:41 <Cale> EvanR: Basically the key to success for an FRP system is avoiding recomputation of intermediate results whose inputs have not changed. It was still pretty easy in Yampa to write things which would waste a lot of work, and using the traditional Arrow means that you can't do a lot of the analysis which would be required to avoid them, because things would be littered with occurrences of 'arr'
15:07:00 <Cale> Guest15710: You can only pattern match against data constructors
15:07:08 <Cale> (and composition is not a data constructor)
15:07:26 <Guest15710> thanks!!
15:07:41 <Cale> Guest15710: At least, if I understand your question correctly :)
15:08:13 <Guest15710> Sure you did! :)
15:09:16 <Guest15710> I meant decompose thank to composition operator like f (g.h) = do something with g and something with h
15:09:19 <luzie> @source (.)
15:09:19 <lambdabot> Unknown command, try @list
15:09:38 <dibblego> (.) f g = \x -> f (g x)
15:10:03 <Guest15710> yep, but using it in pattern matching
15:10:30 <dibblego> it's a function, there is no pattern to match
15:10:40 <Guest15710> let's have myFunc :: (a->a) ->(b->b)
15:11:20 <Guest15710> then for example myFunc tail -> \x->x-1
15:11:41 <Guest15710> sorry myFunc tail = \x->x-1
15:12:02 <Guest15710> myFunc init = \x->x-1
15:12:15 <dibblego> do you want a list, minus the first element?
15:12:45 <Guest15710> myFunc maps endofunction on a to endofunction on b
15:13:16 <Guest15710> in myFunc implementation i do pattern matching
15:13:42 <Guest15710> but if you compose two endofunctions you get an endofunction
15:13:49 <Guest15710> the opposite is false
15:14:01 <absence> http://lpaste.net/130831 <- am i violating a performance rule of thumb here?
15:14:05 <ion> forall a b. (a -> a) -> (b -> b) can not use the (a -> a) parameter for anything.
15:14:24 <ion> All it can do is return the b parameter verbatim (ignoring bottom).
15:14:39 <pavonia> Guest15710: Do you want to pattern match on function names?
15:14:59 <ion> @djinn (a -> a) -> (b -> b)
15:14:59 <lambdabot> f _ a = a
15:15:11 * hackagebot dicom 0.1.1.0 - A library for reading and writing DICOM files in the Explicit VR Little Endian transfer syntax.  http://hackage.haskell.org/package/dicom-0.1.1.0 (PhilFreeman)
15:15:44 <Guest15710> i'd like to do myFunc (g.h) = (myFunc g) . (myFunc h)
15:17:51 <pavonia> You could introduce a new data type for function composition and match on its constructor
15:20:11 * hackagebot json-stream 0.1.0.0 - Incremental applicative JSON parser  http://hackage.haskell.org/package/json-stream-0.1.0.0 (ondrap)
15:20:46 <solrize_> Guest15710, fnuctions don't have an eq instance, you can't pattern match on them ?
15:20:49 <solrize_> functions
15:21:07 <Darwin226> Hey guys. There was a post on /r/haskell not too far back about something like recoverable exceptions in Haskell. It was inspired by a similar concept in another language. Anyone know what the original language was, and what that system is called?
15:22:22 <Guest15710> ok. Seems good!! Thanks!
15:22:32 <kadoban> Darwin226: Pretty ignorant guess: Can't you do something like that in haskell's Cont type/monad/whatever?
15:22:58 <ion> solrize: You don’t need an Eq instance for pattern matching, the inability to pattern match on functions is independent of Eq.
15:23:17 <Darwin226> kadoban: I'm guessing you could, and the post probably did something like that. But I'm interested in the original language it came from for other purposes
15:23:31 <kadoban> Ah okay.
15:23:34 <solrize_> resumable exceptions?
15:25:30 <solrize_> see some links here: http://www.c2.com/cgi/wiki?AbortRetryIgnore
15:25:40 <Guest15710> I will study on general pattern matching. Thanks to you all!! Night :)
15:26:31 <Darwin226> solrize_: Could be, coulde be. I'm pretty sure the language referenced was a list of some sort
15:27:34 <Darwin226> lisp*
15:27:49 <linman32> is it possible to conviniently update a value in a data type (using records)? 
15:28:38 <ion> linman32: Please specify what is the inconvenience you are thinking of. The answer to your underlying question may or may not be lens.
15:29:58 <linman32> the inconvenience is : data Dtype = Dtype {a::Int,b::Int,c::Int...} ... let data = Dtype 1 3 1 ...
15:30:11 * hackagebot haskintex 0.5.0.3 - Haskell Evaluation inside of LaTeX code.  http://hackage.haskell.org/package/haskintex-0.5.0.3 (DanielDiaz)
15:30:20 <linman32> such as updating c in this case, without recreating the "data" variable
15:30:32 <ion> data{ c = 42 }
15:30:48 <linman32> ion: thanks. that is what i was looking for!
15:38:04 <solrize_> i have ghc 7.4.1 on machine A and 7.6.3 on machine B, older vs newer version of haskell platform.  can i cross compile code from A to B?  B doesn't have enough memory to compile pandoc.  
15:38:34 <solrize_> it also seems kind of weird that when ghc compiles a package with a bunch of modules, it uses more and more memory as modules are compiled
15:38:46 <Cale> solrize_: You should be able to build a pandoc binary and transfer that over okay
15:38:55 <solrize_> thanks
15:38:58 <Cale> solrize_: The library itself, I have no idea.
15:39:01 <solrize_> i'm actually trying to install gitit
15:39:06 <solrize_> which uses pandoc
15:39:07 <Cale> Well, I do have an idea, the idea is probably not.
15:39:27 <Cale> (but you could update the GHC, since it's extremely old)
15:39:32 <kadoban> solrize_: You're doing -j1, right? I have to do that on some low-memory computers.
15:39:54 <solrize_> no i thought it was normally 1 core
15:40:08 <absence> http://lpaste.net/130831 <- am i violating a performance rule of thumb here, or is it a strange bug?
15:40:13 <solrize_> but, on the bigger machine i saw pandoc compilation climb up to 1gb when definitely one core
15:40:19 <solrize_> with cabal 1.14 which was before -j was added
15:40:45 <solrize_> i installed haskell-platform from debian apt repo but maybe i should figure out how to install a newer version on the big machine
15:40:47 <kadoban> Yeah, it's pretty hefty.
15:41:08 <solrize_> the small one uses 1.16.0.2
15:41:14 <_ryan> hi can i ask about yesod here - how do i get the data from my multiselect field and get it using runInpuPost?
15:41:26 <shachaf> @where yesod -- might be a better place to ask.
15:41:26 <lambdabot> Web Framework - #yesod - <http://yesodweb.com/>,<http://www.yesodweb.com/page/quickstart>,<http://www.yesodweb.com/book>
15:42:00 <Cale> absence: igen might be able to do some large fraction of its work when applied to its first argument
15:42:17 <solrize_> small machine runs out of memory with -j1
15:42:21 <newsham> is there a simple API to determine when there is data available on a socket?
15:42:23 <Cale> absence: er...
15:42:37 <Cale> absence: no, I misread :)
15:42:37 <quchen> Are lists of alternating element types a thing, as in `data FlipList a b = Nil | Cons a (FlipList b a)`?
15:42:38 <solrize_> newsham select
15:42:39 <newsham> the Netwokr.Socket isReadable call isnt quite what I thought it would be :)
15:42:46 <newsham> solrize: blah, nothing simpler?
15:43:10 <shachaf> newsham: Read from the socket?
15:43:18 <solrize_> erm, it wouldn't have occurred to me that select wasn't simple
15:43:23 <newsham> i only want to read if there is at least one byte there
15:43:26 <solrize_> you could try an async read and see if you get EAGAIN
15:43:37 <kirill`> How many times should "Hello" be printed in this example?
15:43:38 <kirill`> let b = array (1,1) [(1, trace "Hello" 0)] in do print (b!1); print (b!1)
15:43:49 <Cale> absence: hmm, I'd have to see what was going on in core. It seems plausible to me that mkFilter gets inlined and simplified in the definition of f in such a way that part of the computation of fx and fy can be shared as part of the definition of f
15:44:09 <shachaf> newsham: Why?
15:44:20 <kirill`> I get two, but I'm not sure why.
15:44:41 <newsham> because it indicates the server has sent me an error msg
15:44:53 <newsham> and i want to synchronously know if it doesnt like something i just sent it
15:45:28 <absence> Cale: does it help if i tell you that igen uses its first parameter quite trivially, and can easily be modified in such a way that "$" in the paste can be replaced by ".", and if i do, both cases are fast o_O
15:47:16 <Cale> absence: How much faster is "considerably"?
15:47:30 <absence> Cale: 8s runtime vs 12s
15:47:40 <absence> consistently
15:47:41 <Cale> okay, so not more than twice as fast at least
15:47:54 <Cale> It's consistent with the idea that some work is being profitably shared
15:49:03 <newsham> so there's no way to do this? gotta spin up some threads to do this?
15:49:29 <Cale> newsham: Threads are the normal way to do that
15:49:46 <Cale> Well, I dunno
15:50:39 <absence> Cale: true.. i don't understand how replacing $ with . improves the sharing situation though. "$-version" is igen filter i = Compose . Compose . fmap (sequenceA . first Product) $ filter i
15:51:01 <ttt_fff> how far or close is haskell to prolog?
15:51:08 <ttt_fff> what else do I need on top of generate+test ?
15:51:26 <absence> Cale: ".-version" which makes both cases equally fast (8s) is igen = Compose . Compose . fmap (sequenceA . first Product)
15:51:51 <aarontull> for those with ghc 7.10.3 on OS X, what process did you go through to install? build from source?
15:52:07 <newsham> except my code to read messages is stateful and i cant just forkio it :(
15:52:17 <Cale> absence: To understand why it works, you probably have to look at the Core.
15:52:37 <ion> 7.10.3?
15:53:44 <newsham> hmm hIsReadable ...
15:53:59 <Cale> aarontull: Well, first of all, I used an ansible relay to download GHC from the future ;)
15:54:03 <absence> Cale: i guess.. there's just so much of it :)
15:55:09 <Cale> aarontull: Yeah, it looks like the 7.10.1 binary for OSX is not yet constructed or at least not yet linked on the GHC download page...
15:55:23 <aarontull> absence: oh lol i think we are on 7.10.1 right?
15:55:44 <Cale> https://ghcformacosx.github.io/
15:55:55 <Cale> seems to have a binary
15:56:08 <Cale> but the text is so hard to read that it's hard to be sure
15:56:09 <Cale> lol
15:56:28 <aarontull> Cale: i saw that but wasnt sure if anyone else was using it
15:56:41 <Cale> (I'm kidding, I just hate low contrast text)
15:56:51 <newsham> ok, this blocking thing is really ruining my day..
15:56:53 <aarontull> Cale: rgr :)
15:56:54 <kadoban> #666
15:57:20 <kadoban> Even worse than #666 actually, nice.
15:59:15 <Cale> aarontull: you might also try http://permalink.gmane.org/gmane.comp.lang.haskell.ghc.devel/8502
15:59:37 <Cale> aarontull: I don't know why that isn't linked from the download page
15:59:48 <absence> aarontull: yes i'm on 7.10.1, why?
16:00:35 <aarontull> absence: i'm looking for the path of least resistance to getting 7.10.1 installed on my mac
16:02:54 <Cale> newsham: Perhaps  hGetNonBlocking :: Handle -> Int -> IO ByteString  would be useful?
16:03:16 <newsham> my code doesnt use Handles, and converting a socket to a handle and then using it again as a socket is unsafe
16:03:27 <Cale> right
16:03:37 <Cale> I honestly don't understand why Socket is a thing
16:03:40 <newsham> so i could do that if i rewrite all my socket code to use handles
16:03:51 <Cale> But I've never done much tricky network hacking :)
16:04:48 <newsham> internally the IO subsystem has to ask if a socket is ready for reading
16:04:55 <newsham> but for some reason thats not exposed externally?
16:05:30 <shachaf> newsham: Does it?
16:05:33 <JagaJaga> How to delete something from my structure with the help of lens? For example I've filtered smthing in structure, but I need to delete everything I've filtered/
16:05:33 <Cale> I don't think it does ask
16:05:49 <Cale> I think it uses select/epoll/kqueue
16:06:01 <newsham> yes, poll/select is exactly what i need
16:06:11 <newsham> it asks if the socket is available for reading
16:06:14 <EvanR> why not use a thread?
16:06:15 <absence> aarontull: ah, i'm on windows, sorry
16:06:27 <newsham> evanr: state.
16:06:29 <Cale> newsham: What operation do you want?
16:06:34 <EvanR> newsham: huh?
16:06:55 <newsham> I need to either ask "is this readable now" or even better "is this readable within the next 0.1msec"
16:07:09 <EvanR> you want to poll 
16:07:13 <newsham> yup.
16:07:17 <EvanR> but its easier to not poll
16:07:26 <newsham> *sigh*
16:07:30 <EvanR> just saying
16:07:33 <Cale> Well, okay
16:07:45 <newsham> evanr: ok, cool.  I have StateT MyState IO a.  please give me forkIO
16:07:56 <newsham> much easier than poll!
16:08:02 <EvanR> indeed
16:08:04 <shachaf> It doesn't use epoll in edge-triggered mode?
16:08:25 <newsham> i have a test program that just needs a 1 line poll to be finished.
16:08:38 <newsham> threading will NOT make it simpler
16:09:00 <EvanR> its possible to make a complicated program and say its would be more complicated to simplify it
16:09:57 <EvanR> to set up a polling situation the way you want, have the thread wait on the socket and write the event or message to a TChan, which you can poll from the other thread
16:10:16 <EvanR> again polling is more complex
16:10:59 <EvanR> could also blame the transformer
16:11:21 <Cale> Is using posix okay?
16:12:37 <Cale> hmm
16:12:55 <Cale> I thought perhaps the unix library would expose something
16:12:57 <EvanR> i havent seen a good way to poll a Handle directly
16:13:41 <Cale> So you definitely just want to know if there's data waiting, and not what that data is?
16:15:09 <Cale> At worst, you could FFI import poll, get the Fd and just pass that along :P
16:15:54 <Cale> http://hackage.haskell.org/package/poll-0.0/docs/System-Posix-Poll.html
16:15:59 <EvanR> theres also non-blocking mode, ffi import read
16:16:07 <EvanR> EWOULDBLOCK
16:16:17 <EvanR> but this is haskell
16:16:20 <Cale> oh, of course, that's a Henning library
16:16:31 <Cale> So you have to deal with at least one type named T, lol
16:17:49 <absence> Cale: looking at a fuzzy diff between core output for the slow and fast case, it looks like the slow case does less inlining and instead defines local functions that are called
16:18:32 <absence> Cale: is that something that could happen due to sharing differences?
16:19:02 <Cale> absence: Yeah, not having looked at it, I have no idea
16:20:01 <Cale> What does and doesn't get inlined is pretty hard to say :)
16:20:11 <kirill`> Can someone help me with trace? Say you have let x = trace "X" 1. Then evaluating x in ghci with print "X" every time. But if I use instead let x :: Int = trace "X" 1, then "X" is printed only the first time x is evaluated. Does anyone know how that happens? Is it type defaulting?
16:20:41 <absence> Cale: so it seems.. isn't there an option to make ghc tell what gets inlined, or do i remember wrong?
16:20:48 <Cale> kirill`: I'm assuming you have the monomorphism restriction turned off?
16:20:56 <absence> Cale: maybe i'm thinking of fusion rules instead
16:21:05 <Cale> kirill`: What's the type of x in the first case?
16:21:19 <Cale> absence: There are inline pragmas
16:21:30 <kirill`> Cale: Num a => a
16:21:50 <kirill`> I didn't turn anything on/off
16:22:07 <absence> Cale: i meant make ghc print to stdout whenever it inlines something
16:22:28 <Cale> kirill`: okay, well, in any case, the monomorphism restriction didn't apply
16:22:57 <Cale> kirill`: Things which are type class polymorphic are implemented by functions from the instance dictionary to the result
16:23:53 <Cale> kirill`: So, when you try to print x, numeric defaulting picks the instance for Integer, and supplies the appropriate dictionary. Functions are not memoised.
16:24:10 <Cale> kirill`: So this happens every time, and you see the trace each time.
16:24:16 <kirill`> Cale: Right, I see
16:25:07 <kirill`> Cale: I had an error in my memoization function that reevaluated everything every time.
16:25:19 <kirill`> Cale: Thanks
16:25:49 <absence> is there an easy way to run ghc-core on code in a cabal sandbox? i guess it won't find libs if i just point it to the hs files
16:27:47 <absence> ah, never mind. ghc-core seems to be non-trivial to compile on windows
16:28:56 <mpickering> absence: You can use -ddump-??? to dump different stages of the compilation process
16:30:38 <mpickering> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/options-debugging.html#dumping-output
16:31:01 <catsup> is there a word for (.).(.).(.) [...] ?
16:31:24 <ion> catsup: Probably in some library, but i wouldn’t use it.
16:31:31 <catsup> no i don't mean a definition
16:31:35 <catsup> i mean a way to talk about it
16:31:44 <ion> triboob
16:31:48 <catsup> kek
16:32:02 <absence> mpickering: yes, just saw a guide that suggested ghc-core might produce more readable output
16:32:02 <Cale> catsup: well, that's fmap . fmap . fmap
16:32:16 <Cale> catsup: specialised to the function instance for Functor
16:32:36 <Cale> catsup: But, you can't apply it to a list if you're using (.)
16:32:37 <absence> mpickering: but i'll stick to ddump for now :)
16:32:46 <Cale> (.) [...] is just a type error on its own
16:33:03 <Cale> at least, if you intended [...] to be a list
16:33:24 <catsup> heh, no, [...] was meant to indicate [and possibly more .(.)'s]
16:33:27 <Cale> I suppose you could call it iterated composition or something
16:34:19 <catsup> i think i'll just go with n-boob
16:35:12 <mpickering> absence: You could probably get it to work if you wanted, it just uses System.Process to call ghc with --dump-simpl and then post-processes the output
16:35:13 * hackagebot yet-another-logger 0.2.1 - Yet Another Logger  http://hackage.haskell.org/package/yet-another-logger-0.2.1 (larsk)
16:35:54 <mpickering> so instead you could extract the post processing part and use -dump-to-file to dump core to a file
16:53:32 <torstenkemps-ben> ?
16:53:36 <torstenkemps-ben> intro
16:57:24 <monochrom> the haskell-cafe thread on IO order depresses me. people are not satified that IO effects happen in order axiomatically. they have to bring out the GHC coding trick of passing around an unreal world.
17:00:22 * monochrom makes a feeble last attempt
17:01:14 <shachaf> monochrom: Maybe you should propose renaming RealWorld to something less suggestive.
17:01:22 <ReinH> FakeWorld?
17:01:28 <shachaf> No.
17:01:53 <ion> Token
17:02:03 <shachaf> Something with Token in its name is good.
17:02:14 <shachaf> State# can probably also be renamed to something less suggestive.
17:03:12 <k-u> ndmitchell's continuous integration server (https://github.com/ndmitchell/bake) looks exciting.  Has anyone tried it out yet?
17:06:55 <Hijiri> MissileBaton
17:07:45 <solrize_> i ran cabal install cabal to get an upgraded version, it built 1.22.0 and "registered" it but doesn't seem to install it.... "cabal --version" still says 1.14 and the reinstall doesn't seem to have made a new runnable binary ?
17:11:09 <enthropy> solrize_: which cabal # probably says /usr/bin/cabal ?
17:11:16 <solrize_> yes
17:11:53 <enthropy> the default isn't to install cabal there
17:11:54 <solrize_> i just ran cabal update which didn't help
17:12:16 <solrize_> yeah i couldn't find where it did install it though.  it seems to have just rebuilt the library
17:12:34 <enthropy> probably ~/.cabal/bin/cabal
17:13:03 <mpickering> you need to add ~/.cabal/bin/cabal to your path
17:13:04 <solrize_> it doesn't seem to have put it there
17:13:46 <solrize_> aha i have to say cabal install cabal-install
17:13:55 <solrize_> or at least that's doing something different
17:14:26 <solrize_> or at least that's building more stuff, though maybe the same stuff as before
17:16:30 <solrize_> yeah that worked   thanks
17:17:31 <samba1> getDataDir from Paths_my_module is the build-time path, a cabal sandbox. how can i get the runtime path of the executable to look for data files (like configurator files)
17:21:53 <victorsamuelmd> Newbi question: From programming in Haskell, Chapter 2. Exercise 2. Is this right? product [] = 1; product (x:xs) = x * product xs
17:23:24 <mpickering> looks right
17:23:44 <mpickering> assuming you are meant to multiply all the numbers in the list(!)
17:24:10 <ion> @check let product [] = 1; product (x:xs) = x * product xs in \xs -> product xs == Prelude.product (xs :: [Integer])
17:24:12 <lambdabot>  +++ OK, passed 100 tests.
17:24:23 <victorsamuelmd> yes
17:24:33 <victorsamuelmd> just multiplying
17:25:04 <victorsamuelmd> just it confuse me that the product of an emty list is 1
17:25:11 <victorsamuelmd> but it works
17:25:14 * hackagebot pandoc-crossref 0.1.0.1 - Pandoc filter for cross-references  http://hackage.haskell.org/package/pandoc-crossref-0.1.0.1 (lierdakil)
17:25:29 <shachaf> victorsamuelmd: That gives you the property that the product a * product b = product (a ++ b)
17:25:36 <shachaf> Where (++) is list append.
17:28:21 <sbidin> I'm using template Haskell to generate, among other things, a foreign import declaration. This function, liftF, is the simplest I could get it: http://is.gd/Ub7X5w
17:28:31 <sbidin> Is there a way to make calling liftF even simpler/shorter?
17:28:43 <sbidin> I dislike having to use the quasi-quoter, for instance.
17:30:31 <sbidin> This is the definition of liftF: http://is.gd/bp6dNA (But it shouldn't be important, I feel.)
17:30:49 <sbidin> My current goal is to get rid of the quasi-quotation if possible.
17:39:32 <newsham> cale: I ended up rewriting a bunch of code to use handles instead of Sockets, after which it was easy to use the existing handle actions which are nonblocking.. thanks for the tip.
17:40:15 <shachaf> newsham: What are you able to do with Handles and not Sockets?
17:40:41 <newsham> hWaitForInput, hGetNonBlocking, etc.
17:41:59 <newsham> basically poll the socket for readability.
17:42:44 <newsham> though some of the IO semantics are diff, had to compensate.
17:42:58 <newsham> for example hGet will guarantee to read the full amount you request, unless there is an EOF, in which case it can be short
17:43:12 <newsham> while recv will not provide any guarantees other than reading at least one byte
17:43:30 <newsham> and the EOF behavior is diff (empty read vs an exception)
17:55:23 <cribbage8> How come this parser doesn't work?: string "foo" >> (optionMaybe $ many1 space) >> many space
17:56:30 <pavonia> What means doesn't work?
17:57:07 <cribbage8> Oops, small typo. Let me try again.
17:57:12 * geekosaur wonders what they were expecting that to do
17:57:30 <cribbage8> How come this parser doesn't work?: string "foo" >> (optionMaybe $ many1 space >> int) >> many space.
17:57:36 <cribbage8> 'int' just parses an integer.
17:57:44 <cribbage8> The intention is to accept "foo" or "foo <integer>"
17:57:57 <cribbage8> But I'd like to allow for space-padding.
17:58:29 <geekosaur> the problem is after it's parsed the spaces, it's committed to seeing the following integer
17:58:38 <cribbage8> Right.
17:59:00 <cribbage8> And one way around that is to use 'try', but I'd really like to use optionMaybe if possible. Ideas?
17:59:08 <geekosaur> either you use `try` so it can backtrack, or you refactor so the spaces are not prefixed to both the conditional part and what follows
18:01:18 <cribbage8> geekosaur, could you spell your second idea out explicitly?
18:01:55 <geekosaur> both the "present" and "absent" versions start with spaces. parse those spaces *before* looking for the optional part
18:02:22 <cribbage8> Yeah, I got that. But I'd like a space to be mandatory only if the integer is present.
18:02:29 <cribbage8> And I'm not sure how to do that with optionMaybe.
18:02:32 <geekosaur> so you aren't in a situation where the optional part has to parse stuff and only then realize that it can't succeed, at which point Parsec has committed because it parsed something
18:04:10 <cribbage8> To be clear, I'd like to use optionMaybe to accept all of the following: "foo", "foo ", "foo  ", "foo <integer>", "foo <integer> ", "foo  <integer>  "
18:04:26 <cribbage8> and of course to reject "foo<integer>"
18:05:14 * hackagebot spline3 0.0.2 - A parallel implementation of the Sorokina/Zeilfelder spline scheme.  http://hackage.haskell.org/package/spline3-0.0.2 (MichaelOrlitzky)
18:05:16 * hackagebot wai-middleware-static 0.7.0.0 - WAI middleware that serves requests to static files.  http://hackage.haskell.org/package/wai-middleware-static-0.7.0.0 (ryanglscott)
18:05:23 <geekosaur> you cannot have a parser which parses something and then fails unless you wrap it in try, or parsec is modified to always backtrack (which is very expensive, which is why `try` must be specified when you need backtracking)
18:05:35 <geekosaur> you cannot do what you say you want without backtracking
18:06:05 <cribbage8> 'k, thanks for confirming that.
18:06:45 <nshepperd> string "foo" >> optionMaybe (many1 space >> optionMaybe (int <* many space))?
18:06:49 <geekosaur> well, there's also the refactor to reciognize end of string
18:07:01 <geekosaur> or, what nshepperd gotu out before I could
18:07:43 <geekosaur> but as I do not know if this is expectimng to be part of a larger parser, I don't know how well that will work; it might just bump the problem up to the user of this parse rule
18:07:47 <athan> Cale: That sounds really cool. I've never thought of a mutable board before
18:08:05 <nshepperd> oh, yeah probably
18:09:01 <nshepperd> well, as long as the next thing to parse is not a space i think it's okay?
18:09:23 <cribbage8> No, I'd like to allow optional trailing spaces.
18:09:39 <cribbage8> I think I'll just use 'try'.
18:10:03 <newsham> dcoutts: around?
18:10:06 <nshepperd> no i mean next after this parser
18:10:10 <cribbage8> It leads to a short solution.
18:10:33 <pavonia> Isn't that even a regular grammar? So there really should be a way without backtracking
18:11:24 <SamB_laptop> pavonia: ooh, is it lexing time?
18:11:53 <pavonia> What?
18:12:45 <nshepperd> string "foo" >> notFollowedBy digit >> many space >> int >> many space
18:12:47 <nshepperd> idk
18:17:08 <SamB_laptop> https://wiki.haskell.org/Regular_expressions might have something useful?
18:18:33 <shachaf> whoa, it's SamB
18:20:30 <SamB_laptop> yeah, I'm not really sure why I haven't been around... maybe I'm not smart enough for Haskell anymore?
18:44:21 <athan> gah, sorry, spotty internets
18:44:25 <athan> Anyone have a suggestion for building an undetermined nested fmap?
18:44:27 <athan> I've got a type-level list of Reader prefixes, basically (I convert the type level list of types into a function r -> r' -> r'' -> .. -> x), and I need to map a function into x :\
18:45:51 <jasmine45> Hi all, just starting out with learning Haskell using Learn You a Haskell, and was trying to define this function in ghci: doubleMe x = x + x but getting the following error: 42:12: parse error on input ‘=’ - what's going on here?
18:46:25 <jasmine45> from this url: http://learnyouahaskell.com/starting-out
18:46:34 <Fuuzetsu> use let doubleMe x = x + x
18:46:36 <glguy> You define values in GHCi with "let"
18:46:52 <athan> ):
18:47:05 <jasmine45> @Fuuzetsu - why doesn't the tutorial say to use let? :/
18:47:06 <lambdabot> Unknown command, try @list
18:47:25 <jasmine45> @list
18:47:25 <lambdabot> What module?  Try @listmodules for some ideas.
18:47:27 <glguy> It's generally better to write things in a file and load it with GHCi. You can reload the file as you write it with :r
18:47:38 <Fuuzetsu> jasmine45: it also doesn't tell you to put that function in GHCi
18:47:39 <athan> jasmine45: Well... writing a haskell script is different from being _inside_ an expression with ghci :\
18:48:12 <Fuuzetsu> in fact the two paragraphs around it specifically tell you to put it in a file
18:48:26 <enthropy> athan: it's better to do the fmap while you have a type level list. Otherwise you have an overlapping (probably incoherent) instance for what to do when you get to the end
18:48:34 <glguy> Jasmine45: on IRC you can just write names, @ is for bot commands
18:48:52 <athan> enthropy: Yeah, I'm getting an infinite type error :\ Thank you!!
18:48:59 <jasmine45> ah, you're write, that's my bad
18:49:14 <athan> @type foldl1 (.) . map (const fmap)
18:49:15 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ f0 a
18:49:16 <lambdabot>     Expected type: (a -> b1) -> a -> b1
18:49:16 <lambdabot>       Actual type: (a -> b1) -> f0 a -> f0 b1
18:49:23 <athan> er
18:49:28 <athan> @type foldl1 (.) . (map (const fmap))
18:49:29 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ f0 a
18:49:30 <lambdabot>     Expected type: (a -> b1) -> a -> b1
18:49:30 <lambdabot>       Actual type: (a -> b1) -> f0 a -> f0 b1
18:49:33 <athan> (I think that's right)
18:49:45 <athan> I was going to reflect the type level list down to a value, then mess with it like this
18:50:36 <enthropy>  class FmapN ff where fmapN :: (a -> b) -> (f a -> f b); instance FmapN ff => FmapN (Reader r ff) where fmapN = fmapN . fmap -- is what you're looking at doing?
18:51:20 <athan> enthropy: Probably! wow
18:51:41 <athan> that's actually the function I was going to write haha!
18:52:09 <enthropy> probably it actually has to be   instance FmapN (Reader s a) => FmapN (Reader r (Reader s a)); instance FmapN (Reader s a)
18:52:11 <athan> enthropy: Is that a standard definition anywhere?
18:52:20 <enthropy> not that I know of
18:52:37 <athan> hmm alright
18:52:57 <enthropy> you need -XOverlappingInstances, and people hate it
18:54:05 <athan> >:D
18:54:17 <athan> I'm tossing unsafeCoerce everywhere anyway
18:55:35 <smoores> if I have to enter :type (||) to see the type of the function ||, why don't I have to use parenthesis when doing :type null?
18:55:50 <saulzar> || is an operator
18:56:00 <smoores> i thought operators are functions like any other functions
18:56:06 <nshepperd> can you possibly put an 'Identity' at the end of the list, before doing this? then you could use that as the terminator, instead of having OverlappingInstances
18:56:28 <saulzar> They are - but if you want to use them as a normal prefix function you have to use the paranthesis
18:56:46 <saulzar> e.g.  (||) x y     instead of   x || y   
18:57:14 <nshepperd> ie. instance FmapN ff => FmapN (Reader r ff); instance FmapN (Identity a)
18:57:28 <smoores> so a function is an operator if haskell makes it infix by default?
18:57:50 <smoores> i know you can make any function infix with backticks, is it appropriate to call those operators as well?
19:00:31 <saulzar> smoores, Yeah operators  (functions with names given by certain characters)  are infix. I don't think you'd call `functions` operators.  
19:01:47 <smoores> is it possible for me to create my own infix functions that don't require backticks?
19:01:49 <glguy> It's fine to call `function` an operator
19:02:20 <glguy> The Haskell Report does it and also states "An operator is a function that can be applied using infix syntax"
19:02:49 <glguy> || is an "operator symbol"
19:03:01 <glguy> An operator is either an operator symbol, such as + or $$, or is an ordinary identifier enclosed in grave accents (backquotes), such as `op`. 
19:15:38 <cfoch> Hello folks
19:15:46 <cfoch> I am using Haskell Src Extensions
19:15:57 <cfoch> I want to get all the functions of a given module
19:16:10 <cfoch> So I am using 
19:16:27 <cfoch> the data type Decl from Language.Haskell.Exts.Syntax 
19:17:29 <Cale> cfoch: So yeah, you'll have to look for FunBind and PatBind constructors
19:18:13 <Cale> and you may also want to look for the field names in data declarations and methods in class declarations
19:18:26 <cfoch> The problem I think, it is that FunBind does not make difference between functions declared in the module or in the 'where' clause?
19:18:41 <cfoch> Cale: ^
19:19:31 <Cale> cfoch: Well, you'll find the Decls for the where clause inside the Binds which is the last argument to the Match constructor
19:20:17 <Cale> It'll be like  FunBind [Match ... (BDecls [FunBind ...]), ...]
19:21:11 <Cale> Does that make sense?
19:27:42 <cfoch> ah... it stores the declarations inside a function
19:28:00 <cfoch> thanks, Cale 
19:28:43 <h-core> if i define part of a function using where is there any way within ghci to use what i defined without taking it out of the where?
19:28:57 <arkeet> no
19:29:11 <arkeet> you have to define it separately.
19:29:17 <Cale> It may not even be trivial to lift it out of the where
19:29:31 <arkeet> indeed, it might capture some of the function arguments.
19:29:31 <Cale> Because it might refer to the values of the function parameters
19:29:34 <Cale> yeah
19:29:53 <h-core> hrmm, seems like it would help debugging to be able to use a part of a function
19:30:01 <h-core> but im sure there's complicated reasons to not
19:30:15 <h-core> thanks for the answer!
19:31:09 <Hijiri> I forget, are user packages usually visible in sandboxes?
19:31:16 <Hijiri> by default
19:40:15 * hackagebot angel 0.5.2 - Process management and supervision daemon  http://hackage.haskell.org/package/angel-0.5.2 (MichaelXavier)
19:51:02 <glguy> Hijiri: No, they aren't.
19:51:20 <Hijiri> ok, thanks
20:06:00 <cfoch> Cale, what would be the difference between PatBind and FunBind?
20:06:25 <Cale> PatBind is for pattern bindings, i.e. definitions which don't explicitly have function parameters
20:06:40 <Cale> If I were to write   concat = foldr (++) []
20:07:02 <Cale> then that would be considered a pattern binding, because it doesn't have an argument on the left hand side
20:07:26 <Cale> Or for instance, one might write  (xs, ys) = span f zs
20:07:39 <Cale> which matches the pattern in order to define xs and ys
20:14:42 <solrize_> bah, haskell-platform 2014-2 was built in ubuntu which uses a newer version of glibc than debian 7, so it's not possible to run the stuff under debian
20:15:19 * hackagebot aeson-better-errors 0.2.0.0 - Better error messages when decoding JSON values.  http://hackage.haskell.org/package/aeson-better-errors-0.2.0.0 (hdgarrood)
20:20:19 * hackagebot aeson-better-errors 0.3.0.0 - Better error messages when decoding JSON values.  http://hackage.haskell.org/package/aeson-better-errors-0.3.0.0 (hdgarrood)
20:23:53 <solrize_> https://www.haskell.org/ghc/dist/7.8.3/ghc-7.8.3-i386-unknown-linux-deb7.tar.xz
20:23:55 <solrize_> oops
20:24:02 <solrize_> src/GhcDist.hs:104:38:                                                          
20:24:02 <solrize_>     No instance for (CmdString t0) arising from a use of `command'              
20:24:02 <solrize_>     The type variable `t0' is ambiguous                                    
20:25:27 * hackagebot safecopy 0.8.5 - Binary serialization with version control.  http://hackage.haskell.org/package/safecopy-0.8.5 (DavidJohnson)
20:40:27 * hackagebot stackage-update 0.1.0.0 - Update your package index incrementally (requires git)  http://hackage.haskell.org/package/stackage-update-0.1.0.0 (MichaelSnoyman)
20:40:29 * hackagebot pandoc-citeproc 0.6.0.1 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.6.0.1 (JohnMacFarlane)
20:50:25 <heatsink> What is the semantics of loop fusion on unboxed vectors wrt strictness?
20:51:06 <heatsink> loop fusion can turn bottom into non-bottom expressions.
20:55:27 * hackagebot wai-middleware-static 0.7.0.1 - WAI middleware that serves requests to static files.  http://hackage.haskell.org/package/wai-middleware-static-0.7.0.1 (ryanglscott)
20:56:54 <sydneyhacker> Hi I would like some quick help
20:57:07 <sydneyhacker> I am doing http://www.seas.upenn.edu/~cis194/spring13/hw/10-applicative.pdf ex5
20:57:59 <lpaste> Martin pasted “intOrUppercase ” at http://lpaste.net/130839
20:58:34 <sydneyhacker> So for the intOrUppercase method at the bottom, I am adding a function that discards the result of each parser in turn
20:58:49 <sydneyhacker> But it looks a bit ugly - is there a more idomatic way of solving this?
20:59:33 <heatsink> :t void
20:59:34 <lambdabot> Functor f => f a -> f ()
20:59:37 <__ryan> is ther any yesod master here?
21:00:00 <heatsink> sydneyhacker: You can implement void instead of discard
21:00:14 <__ryan> i have a select tag in my hamlet how do i get the selected data in my handler using the runInputpost? thank you
21:00:28 <heatsink> sydneyhacker: Basically void m = discard <$> m
21:00:45 <monochrom> sydneyhacker: you can also use "pure ()"
21:01:22 <sydneyhacker> thanks heatsink, lambdabot, __ryan
21:01:40 <monochrom> hmm, it is less obvious how to use "pure ()".
21:02:02 <monochrom> discard and void are simplest for this
21:02:55 <rui2> What do you people think of ihaskell, is it worth using? (haven't used it yet)
21:04:29 <sydneyhacker> void is a nice solution, thanks
21:05:00 <heatsink> Is that parsley?  It looks like cilantro
21:05:53 <kadoban> My supermarket /sucks/ at labelling and/or correctly placing the cilantro. Every time I have to play the "parsley or cilantro" game
21:07:01 <heatsink> It might be one of those places where they think of cilantro as foreign food
21:18:18 <luite__> ReinH: ping
21:22:07 <sh1ken> Hey. Is there a book or website where I can look for basic Haskell exercises?
21:22:27 <HeladoDeBrownie> @g 99 haskell problems
21:22:27 <lambdabot> Maybe you meant: gazetteer get-shapr get-topic ghc girl19 google googleit gsite gwiki v @ ? .
21:22:32 <HeladoDeBrownie> @google 99 haskell problems
21:22:33 <lambdabot> https://wiki.haskell.org/H-99:_Ninety-Nine_Haskell_Problems
21:22:44 <glguy> The NICTA course and CIS194 course have exercises
21:23:00 <kadoban> sh1ken: https://github.com/bitemyapp/learnhaskell <-- the CIS194 class, yeah.
21:23:05 <sh1ken> Wow, thanks! That's actually really useful.
21:23:06 <sh1ken> Thanks!
21:26:35 <shapr> HeladoDeBrownie: you called?
21:26:40 <shapr> oh, false alarm
21:30:27 <__ryan> hi does anyone know how to check the "iopt" input? 
21:31:39 <__ryan> or how to check if the data is null?
21:32:27 <kadoban> __ryan: You really gotta start specifying context :) is this yesod still, or?
21:33:12 <__ryan> kadoba: yes - this my code - if newsUrl then "null" else "not null" - newsUrl is an iopt input.
21:33:19 <__ryan> kadoban: yes - this my code - if newsUrl then "null" else "not null" - newsUrl is an iopt input.
21:36:12 <glguy> 07case newsUrl 07of Nothing 07-> 04"was null"; Just url 07-> 04"was set"
21:37:32 <glguy> The "trick" is to look at the type of newsUrl. (iopt isn't a type)
21:38:20 <glguy> You can figure this out from the documentation: https://hackage.haskell.org/package/yesod-form-1.4.4.1/docs/Yesod-Form-Input.html
21:42:02 <__ryan> glguy: what does this error means? parse error on input -> - it occurs in this code - Nothing -> "was null"
21:43:20 <kadoban> __ryan: Parse errors are very dependent on context. You have to look at the code before that, probably. If you still can't figure it out, paste a decent amount of the code and the full error to lpaste.net
21:44:35 <__ryan> here is the code - http://lpaste.net/130843
21:44:49 <glguy> It means you forgot to indent the patterns
21:45:20 <glguy> The definition of url needs to be more indented than url
21:47:33 <arkeet> otherwise it thinks Nothing is starting a new let statement.
21:47:34 <__ryan> thank you it work.. - but another why is it that i need to indent it more than url?
21:47:39 <arkeet> layout rules.
21:47:40 <glguy> The reason that it reported the parse error on "->" was that the way it was lined up you were starting a new declaration which should have had an "=" next
21:48:00 <glguy> a single let expression supports multiple declarations
21:48:13 <__ryan> got it everyone - thank you for the tip.. and noted. :-)
21:50:38 <__ryan> ah everyon another question if you may - another question how do i get the selected data in a select tag?
21:51:32 <pacak> I need some kind of ordered queue - something like [(0, 'a'), (1, 'b'), (2, 'c')...]  with operations of insertions  and removals that will shift following elements: insert 1 'A' queue should give [(0, 'a'), (1, 'A'), (2, 'b')... ] and similar for removal. queue size - 100-10000 elements, access pattern - more frequent updates/removals at the front - similar to 1/n. Right now I'm using modified RedBlack tree. Is there anything better o
21:53:19 <glguy> pacak: It seems like Data.Sequence might be right http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Sequence.html
21:53:32 <kadoban> pacak: What kind of modified red-black? That sounds good or bad, depending on how modified XD
21:53:55 <pacak> kadoban: Well, it's modified to be faster than Data.Sequence
21:54:22 <pacak> Instead of key it stores number of items in subtree in a fancy way
21:54:53 <glguy> pacak: the keys are sparse, not just positions?
21:54:58 <kadoban> pacak: Okay, that sounds vaguely like what I was thinking of as the good way. I would think that's fine?
21:55:21 <arkeet> I don't think Data.Sequence would work there?
21:55:29 <pacak> glguy: Keys are sequential
21:55:40 <glguy> sequence has efficient splitting which you use to insert elements
21:55:48 <glguy> and fast access to the ends
21:56:00 <arkeet> it has efficient splitting by index
21:56:20 <arkeet> but if you want to insert and keep it sorted
21:56:21 <glguy> which as far as I see is what we need
21:56:55 <pacak> I've tried Data.Sequence, my modified RBTree is faster...
21:56:59 <arkeet> http://hackage.haskell.org/package/fingertree-0.1.0.2/docs/Data-PriorityQueue-FingerTree.html
21:57:20 <kadoban> Huh I didn't know sequence had that stuff.
21:57:36 <glguy> pacak: So you had a: Seq Char  (assuming your example above)?
21:57:58 <arkeet> I guess the doc right there says says it's slow (in constant factors).
21:58:00 <pacak> glguy: Well, the actual data is much more complicated
21:58:18 <glguy> pacak: the point is just that the indexes weren't stored in the sequence as data
21:59:23 <pacak> arkeet: Not quite. If I have a queue of 10 elements and I do fold with remove 1 8 times should end up with just first and last element at indices 0 and 1
21:59:43 <arkeet> not quite what?
21:59:59 <arkeet> oh you can remove at any index, not just the front.
22:00:10 <arkeet> and insert.
22:00:11 <arkeet> ok.
22:00:30 <arkeet> that doesn't sound much like a queue.
22:02:14 <pacak> insert :: Ord k => k -> v -> PQueue k v -> PQueue k v Source
22:02:15 <pacak> But as soon as I indert at position K - every other key at positions K+1, K+2 .. N should be increased by 1 as well.
22:03:38 <kadoban> pacak: Out of curiosity, is your modified-red-black not working as fast as you need it? Because to me that sounds like a pretty good solution.
22:03:57 <arkeet> sounds like it's essentially a random access list, except with fast access near the front.
22:04:01 <arkeet> to me anyway.
22:04:07 <kadoban> Maybe someone more clever could come up with something better, but … it sounds nice to me.
22:04:51 <arkeet> and some sort of balanced tree thing sounds like the thing to do then.
22:05:57 <pacak> kadoban: Well... Processing time with that and some operations inside take about 500us which is fast enough in most cases except when it's not - and when it's not fast enough it starts beign expensive in $$$$ terms :)
22:06:12 <kadoban> Ah :)
22:08:16 <kadoban> pacak: Is it … slower sometimes and that's screwing you over, or is it about the same speed but your constraints are sometimes harder and that's screwing you over? Hopefully that question made sense, heh.
22:09:26 <pacak> Sometimes constraints are harder :(
22:10:34 <kadoban> Ah, hmm. That's probably harder to deal with, unless the thing can be tuned or something. Which … I probably wouldn't really know how to help with.
22:11:46 <NateUni> Guys is there any function like map that I can use to map over a list where it doesnt have to return a list of the same type? Or do I need to just create my own?
22:12:27 <kadoban> NateUni: map is (a -> b) -> [a] -> [b]           [a] and [b] are different types, or do you mean you want [] and something else?
22:12:29 <NateUni> I want to map a extraction function over a [particles] and just get the vector (Float, Float) from each
22:12:51 <NateUni> from which I get a list back of [vectors]
22:13:08 <horny-sama> why do ppl insist on writing a type signature for functions when most of the time haskell is figure it out
22:13:24 <NateUni> readability
22:13:46 <horny-sama> NateUni: they are like factorial ::Integral a) => a-> a
22:13:47 <kadoban> NateUni: So you have a  Particle -> Vector (Float, Float)    and you want   [Particle] -> [Vector (Float, Float)]  ?  That's map.
22:13:52 <horny-sama> I was like fuck the type signature
22:14:07 <kadoban> horny-sama: It's helpful for both writing and reading, and sometimes necessary.
22:14:07 <heatsink> horny-sama: The type signature is useful documentation
22:14:28 <horny-sama> I mean writing a type signature usually screw me over
22:14:36 <kadoban> While you're writing, type annotations give you /much/ better error messages. Instead of getting an error in a random place, you'll get one where you actually made your mistake.
22:14:49 <kadoban> horny-sama: Then you just need to get better at it, probably with practice.
22:15:08 <horny-sama> final exam on sat
22:15:26 <horny-sama> so ... I need to make peace with whatever demons left
22:16:06 <NateUni> kadoban.. no Particle is comprised of Float, Vector, Vector
22:16:16 <NateUni> I just want the end one… 
22:16:25 <monochrom> if you never make type errors, you don't need to infer types yourself
22:16:48 <monochrom> the day you make a type error, you will have to go through an inference yourself to see where.
22:17:29 <monochrom> type inference is equivalent to unification, which is exponential time for computers, so nevermind humans
22:18:11 <horny-sama> Be me doing i/o in haskell. Feel like biting a chicken head off
22:18:13 <horny-sama> :<
22:19:34 <jedai> NateUni: So ? use pattern matching
22:19:46 <augur> horny-sama: why so?
22:20:24 <horny-sama> augur: I think oop is better with i/o then both logical and functional programming
22:20:46 <augur> horny-sama: what aspects of Haskell's IO do you find unappealing?
22:20:53 <augur> or hard
22:21:31 <jedai> horny-sama: if you have difficulty writing the type signature, maybe you should write the function then ask GHCi (or other facility included in your editor) to tell you the signature, and if you're okay with it, put it in the file to avoid runaway inference 
22:21:50 <horny-sama> jedai: that's what I have been doing
22:22:04 <horny-sama> but unfortunately for sat exam, I probably have to write type signature
22:22:43 <augur> horny-sama: what specifically is troubling you
22:22:44 <horny-sama> :\t (Ord)
22:22:54 <augur> Ord is a type class, not a type
22:22:58 <horny-sama> augur: nth particularly 
22:23:16 <jedai> horny-sama: Sure but they'll probably be pretty simple... If you have problems writing map type signature for instance, that's more of a problem of understanding it, to me
22:23:21 <augur> horny-sama: ok, then what unspecifically? :)
22:23:22 <horny-sama> augur: Some type signature is like (Ord)
22:23:30 <horny-sama> I need to understand (Ord)
22:23:43 <horny-sama> augur: nth much about the i/o coz my partner wrote it
22:23:44 <jedai> horny-sama: then you need to understand type-classes
22:23:46 <horny-sama> :P
22:24:07 <augur> horny-sama: rd is a type class, so lets discuss type classes
22:24:14 <jedai> they're not so hard (at least when you don't look at GHC extensions)
22:24:16 <monochrom> taking an exam under limitations is an economic optimization problem
22:24:41 <heatsink> horny-sama: Have you learned about ordered types?
22:24:47 <augur> horny-sama: here is a function:   wrap :: Int -> Maybe Int  ;  wrap x = Just x
22:24:52 <monochrom> how much time to spend reviewing which topic to increase how many marks
22:24:53 <horny-sama> heatsink: suppose to know but I don't know
22:25:23 <NateUni> do you guys write subroutines.. ? Or do you just write really hectic functions that I couldnt read?
22:25:23 <augur> horny-sama: this function, wrap, turns an Int into a Maybe Int, by wrapping the Int in Just, yes? simple enough
22:25:38 <horny-sama> augur: yes
22:25:40 <augur> horny-sama: now, consider this function:    singleton :: Int -> [Int]  ;  singleton x = [x]
22:25:42 * hackagebot aeson-better-errors 0.4.0.0 - Better error messages when decoding JSON values.  http://hackage.haskell.org/package/aeson-better-errors-0.4.0.0 (hdgarrood)
22:25:44 * hackagebot geoip2 0.1.0.1 - Pure haskell interface to MaxMind GeoIP database  http://hackage.haskell.org/package/geoip2-0.1.0.1 (ondrap)
22:25:52 <horny-sama> augur: turn int into a int list?
22:26:10 <horny-sama> but what does (Ord) means
22:26:11 <augur> horny-sama: this function turns an Int into a [Int] by putting the Int in a list of length 1
22:26:11 <heatsink> NateUni: What is a hectic function?
22:26:12 <jedai> NateUni: I don't really understand your question ? There's no "subroutines" in Haskell
22:26:20 <augur> horny-sama: with me so far?
22:26:26 <horny-sama> augur: yes
22:26:35 <horny-sama> so what is type class again?
22:26:40 <horny-sama> it is type signature?
22:26:46 <augur> horny-sama: these two functions are similar: they take a thing, and put them into some container thing
22:26:55 <augur> now, we could define a type class like so:
22:26:57 <heatsink> horny-sama: type classes are best learned through examples, that is what augur is doing.
22:27:37 <augur> class WrapAnInt f where wrapItUp :: Int -> f Int
22:27:42 <augur> horny-sama: and we can say:
22:27:53 <augur> instance WrapAnInt Maybe where wrapItUp x = Just x
22:28:02 <augur> instance WrapAnInt [] where wrapItUp x = [x]
22:28:08 <horny-sama> did not know haskell has class like java
22:28:14 <monochrom> jedai: I bend the word so that every definition in Haskell code defines a subroutine. but I doubt that it is important. the question is, clearly, loaded with a hidden agenda
22:28:18 <augur> not classes like java
22:28:41 <augur> horny-sama: sometime quite different, but serving vaguely similar functionality
22:28:58 <horny-sama> ok
22:29:33 <augur> horny-sama: now, what a type class like WrapAnInt does is quite simple:   when you say   WrapAnInt Maybe   what you're saying is "Maybe" has certain functionality associated with it
22:29:42 <horny-sama> been doing haskell, prolog and javas reflection all in one class so we did not go into the details of each languages
22:30:22 <horny-sama> augur: so type class is jsut a fancy word so what the function does?
22:30:32 <augur> type classes are a way to specify collections of behavior, and then declaring instances of type classes is a way of saying what things exhibit that behavior
22:30:52 <augur> horny-sama: well, you can have multiple methods in a type class. for instance, here's another type class:
22:31:29 <augur> class Numberly a where  add :: a -> a -> a  ;  subtract :: a -> a -> a  ;  round :: a -> Int
22:31:50 <augur> a Numberly type is a type that can do some "adding" and "subtracting" and can be "rounded" to an integer
22:31:57 <augur> for some notion of adding, subtracting, and rounding
22:32:06 <augur> now, of course, integers are numberly!
22:32:27 <augur> instance Numberly Int where   add x y = x + y   ;   subtract x y = x - y   ;   round x = x
22:32:51 <horny-sama> augur: basically type class is the initial type of the argument?
22:32:55 <augur> but many other things are numberly too, like floating points
22:33:25 <augur> no, a type class is just a specification of some behavior, and instances of a type class explain how things exhibit that behavior
22:34:27 <augur> another way to say it is, if I define that type class "Numberly", what I'm saying is this:  "a type is Numberly just in case I can define 'add' for that type, and 'subtract', and 'round'"
22:34:41 <augur> horny-sama: does that make sense? after a fashion, type classes are adjectives
22:34:53 <horny-sama> augur: got it
22:34:53 <augur> or predicates. they describe types
22:35:15 <horny-sama> but how does Ord type class behave?
22:35:15 <augur> horny-sama: now, to say that a type is Ord is to say its elements can be ordered
22:35:23 <augur> that is, there's some notion of before and after that we can define
22:35:41 <augur> the specifics you can find in the docs:
22:35:43 <augur> @hoogle Ord
22:35:46 <lambdabot> Prelude class Eq a => Ord a
22:35:46 <lambdabot> Data.Ord class Eq a => Ord a
22:35:46 <lambdabot> Data.Ord module Data.Ord
22:35:55 <augur> ugh no links, lambdabot? :(
22:36:02 <horny-sama> augur: I just need to have a rough idea on how haskell works in general
22:36:21 <augur> horny-sama: well, thats.. a far more complicated question
22:36:40 <augur> that i cant explain. you shouldve paid more attention in class, and/or done assigned reading, I suspect
22:36:54 <augur> http://hackage.haskell.org/package/base-4.8.0.0/docs/Prelude.html#t:Ord
22:37:21 <horny-sama> augur: The prof told us explicitly just learn the language all our own and his lecture slides are crap
22:37:41 <augur> and when did the prof tell you this
22:37:46 <Axman6> which university is this?
22:38:13 <horny-sama> augur: beginning in the sem
22:38:19 <horny-sama> Axman6: uni of calgary
22:38:20 <augur> horny-sama: how long ago was that
22:38:30 <horny-sama> augur: jan
22:38:39 <horny-sama> https://github.com/mr-fool/haskell <--- haskell code that I have wrote
22:38:54 <augur> horny-sama: and you're asking now, two days before a test?
22:39:19 <horny-sama> augur: I forgot all my haskell after the hw
22:39:21 <horny-sama> so...
22:39:38 <augur> welp.
22:39:48 <augur> good luck!
22:41:10 <harel_f> horny-sama is the question about type classes
22:41:28 <horny-sama> harel_f: I already got the answer
22:42:03 <augur> horny-sama: you might want to acquaint yourself with hoogle
22:42:24 <horny-sama> augur: the exam is composed off three major parts 
22:42:28 <horny-sama> haskell, prolog and java
22:42:39 <horny-sama> I already got prolog and java under control
22:42:43 <horny-sama> just haskell 
22:43:12 <harel_f> prolog is cool, haskell is beter
22:43:42 <horny-sama> prolog is pretty limited in a sense only good for a handful of things
22:43:53 <arkeet> oh, calgary is where I went for undergrad too. D:
22:43:54 <horny-sama> I think of it as a specialize language
22:44:06 <horny-sama> arkeet: it is a horrible skool
22:44:11 <arkeet> I dunno, I didn't take CS there.
22:44:19 <arkeet> I'm assuming that's what you're doing.
22:44:45 <horny-sama> arkeet: Be me apply to internship, career service apparently has no links to companies
22:45:06 <horny-sama> and none of the applications send thru career links actually reach employers 
22:45:17 <horny-sama> internship program is a scam
22:46:04 <horny-sama> all the interviews that I got is either by applying outside of skool or career fairs
22:46:30 <augur> this conversation is making more and more sense
22:46:41 <augur> i need to depart from it, however. bye
22:55:52 <horny-sama> when do you use where instead of is ?
22:56:30 <horny-sama> so no is operator in haskell
22:56:45 <horny-sama> I guess I must have mix up haskell with prolog
23:01:39 <mniip> horny-sama, where vs let-in?
23:02:05 <horny-sama> mniip: I don't think there is an "is" operator in haskell
23:02:11 <horny-sama> I got it mix up with prolog
23:02:11 <mniip> yes
23:02:21 <mniip> but did you mean let-in?
23:02:38 <horny-sama> mniip: I know let but I have never seen let in format
23:03:15 <mniip> > let z = 3 + 2 in z * z
23:03:17 <lambdabot>  25
23:03:32 <horny-sama> ok
23:06:24 <pacak> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
23:06:26 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
23:08:59 <AshyIsMe> random horrible brain noise from friday afternoon
23:09:10 <AshyIsMe> HELL: Haskel Enterprise Lovely Language
23:09:36 <harel_f> > [1..]
23:09:39 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:09:47 * AshyIsMe makes more coffee and desperately waits for the clock to say Beer O'Clock
23:10:33 <pacak> gym'o'clock actually. Quite soon.
23:11:00 <__ryan> hi how do i get the id only in a persistent query.. plzz help me..
23:12:10 <arkeet> lens has a function called 'is', but it's not exported by Control.Lens
23:12:16 <arkeet> probably because people like to write stuff like (i:is)
23:12:27 <arkeet> at least I think that was the reason.
23:25:43 * hackagebot bower-json 0.5.0.0 - Read bower.json from Haskell  http://hackage.haskell.org/package/bower-json-0.5.0.0 (hdgarrood)
23:41:59 <mjrosenb> gah
23:42:04 <mjrosenb> cabal repl is :-(
23:42:48 <mjrosenb> also, I can't get partial application of kinds?
23:44:39 <Cale> mjrosenb: Partially applied kinds?! I mean, it makes sense, but what are you doing? :)
23:44:39 <mjrosenb> e.g. data Foo a b c = ...; bar :: Baz (Foo Int Int) Char
23:45:17 <Cale> Ah, with DataKinds?
23:45:40 <mjrosenb> Cale: I don't know whata DataKinds are, so probably not.
23:45:54 <mjrosenb> ahh, I have an alias
23:46:19 <arkeet> yeah, can't partially apply type synonyms
23:46:24 <mjrosenb> type OpenPainter w t = w t -> Painter t
23:46:39 <mjrosenb> then data Button gs ls t = ...
23:46:47 <Cale> Okay, right, you can't partially apply *type* synonyms :)
23:46:51 <mjrosenb> and I want OpenPainter (Button gs ls) t
23:47:01 <arkeet> oh that should be doable.
23:47:04 <Cale> Kinds are the types of types, they're the things which look like * -> (* -> *) -> * and such
23:47:14 <Cale> :k StateT
23:47:15 <lambdabot> * -> (* -> *) -> * -> *
23:47:20 <Cale> :k Maybe
23:47:21 <lambdabot> * -> *
23:47:26 <Cale> :k Integer
23:47:29 <lambdabot> *
23:47:33 <Cale> :k Maybe Integer
23:47:34 <lambdabot> *
23:47:36 <arkeet> :k Monad
23:47:37 <lambdabot> (* -> *) -> Constraint
23:47:54 <mjrosenb> ... did I not look at the correct line when I decided what the problem is?
23:48:11 <Cale> There are rarely many things at the kind-level that you'd want to partially apply in the first place
23:49:07 <mjrosenb> Cale: well, I have one! (it is rather silly, but it gets the job done)
23:49:33 <Cale> mjrosenb: All your stuff is at the type level, not the kind level
23:50:58 <mjrosenb> Cale: well, the issue (I thought) was that it was complaining that Button gs ls had kind * -> *, but it needed to be *
23:51:41 <Cale> Okay, but that's still partially applying Button, which is a type constructor :)
23:53:25 <mjrosenb> ok, more pertinent question to avoid dumbness like this: can I get cabal repl to *not* exit immediately when it runs into an error with the library for the local cabal file?
23:58:13 <Cale> mjrosenb: What error are you getting?
23:59:40 <Cale> mjrosenb: Maybe try  cabal exec ghci
