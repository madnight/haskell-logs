00:00:43 <athan> tdammers: Are all IT bosses uninterested in programming? :(
00:00:50 <mercwithamouth> tdammers: i won't disagree with that
00:01:42 <tdammers> athan: probably. if they find programming interesting, then the better ones don't become bosses but keep programming, and the not-so-good-ones become bosses who wish they still had the time to program
00:02:02 <athan> ):
00:02:19 <tdammers> it can work for a small startup, but once stuff grows, people need to decide
00:19:04 * hackagebot binary-strict 0.4.8.2 - Binary deserialisation using strict ByteStrings  http://hackage.haskell.org/package/binary-strict-0.4.8.2 (DominicSteinitz)
00:23:31 <srhb> But yes, I had not seen deb.haskell.org/stable
00:23:37 <srhb> That looks a lot safer.
00:24:04 * hackagebot aws-ec2 0.3.2 - AWS EC2/VPC, ELB and CloudWatch client library for Haskell  http://hackage.haskell.org/package/aws-ec2-0.3.2 (VladimirKirillov)
00:25:00 <srhb> Er, wrong channel.
00:26:51 <ben0> hi, I have some problem with ghc-mod and cabal sandboxes that I can't seem to resolve. Can't seem to find anything on the web even after searching for half an hour.
00:27:19 <srhb> ben0: What's the issue?
00:27:52 <ben0> hi srhb. Basically, ghc-mod cannot find modules installed in the sandbox
00:28:09 <ben0> ghci works fine
00:28:26 <ben0> (ghci through cabal repl)
00:28:28 <funfunctor> Hi, anyone about that can help me with dealing with C pointers in Haskell. I am sort of very very stuck, I have a reduced case
00:28:57 <funfunctor> http://pastebin.com/gqKqyH0k
00:29:41 <srhb> ben0: Not sure, sorry.
00:30:13 <funfunctor> I am confused how to translate the struct passed as a reference in bladerf_version(&lib_version); to the Haskell way of looking at it
00:31:17 <srhb> funfunctor: You're going to have to write a Storable instance for it
00:32:51 <gfixler> how do folks here choose a license from the cabal init choices?
00:32:59 <funfunctor> srhb: hi, yes I have that done, should I paste that snip also with the peek/poke functions
00:33:06 <srhb> funfunctor: Please.
00:34:08 <funfunctor> srhb: http://pastebin.com/6nfws5ma
00:34:35 <funfunctor> srhb: i'm sort of stuck putting it all together to test it out
00:34:58 <jtanguy> ben0: can you configure your editor to use ghc-mod through `cabal exec ghc-mod` ?
00:37:02 <srhb> funfunctor: Ugh, your naming though.... :-)
00:37:43 <funfunctor> srhb: sorry, i'm using binding-DSL to generate the bindings
00:37:48 <srhb> Ah, I see.
00:37:56 <srhb> Then I can hardly blame you
00:38:10 <funfunctor> srhb: yea it has a little mangled internal naming
00:38:34 <funfunctor> srhb: i'm planning to write nice looking shim functions around it later once I get a simple example working
00:39:23 <srhb> funfunctor: So, aside from the mess, what I think you should be doing is create a Ptr in Haskell, then foreign call the bladerf_version function with that Ptr
00:39:48 <funfunctor> srhb: how do I do that?
00:39:58 <srhb> then peek at that Ptr should give you a C'bladerf_version value
00:40:17 <funfunctor> srhb: i'm not even clear how memory is getting handled across these bindings
00:40:27 <srhb> funfunctor: can I suggest writing this manually instead then?
00:40:35 <srhb> It'll be a lot clearer to understand
00:40:42 <srhb> Then you can go back to bindings when you get it.
00:41:15 <funfunctor> srhb: well that's where I originally started and was confused there.. the haskell wiki simply made me more confused
00:41:21 <funfunctor> https://www.haskell.org/haskellwiki/FFICookBook#Working_with_structs
00:41:57 <funfunctor> srhb: could you demonstrate this case, I think that would help me
00:42:15 <funfunctor> its easier to follow by example
00:42:34 <srhb> funfunctor: Let's do the actual binding instead. What is the relevant c library? bladerf?
00:42:59 <funfunctor> srhb: yes, 1sec i'll get the function prototype
00:44:31 <funfunctor> srhb: void CALL_CONV bladerf_version(struct bladerf_version *version);
00:45:15 <funfunctor> CALL_CONV is just defined as some __attribute__ for the linker so we can ignore that..
00:48:17 <srhb> funfunctor: I wrote you in privmsg, did you see?
00:50:17 <funfunctor> srhb: sorry let me disable OTR in pidgin..
00:50:24 <srhb> Sure
00:50:53 <jtanguy> gfixler: maybe this website can help you: http://choosealicense.com/
00:51:16 <jtanguy> there's not definite answer to that question
00:52:57 <jtanguy> I usually go with BSD3, but there can be some constraints, like a dependency using GPL which would be shipped
00:53:00 <gfixler> jtanguy: thanks - licenses seem to be something many care about, but I'm mostly opinionless
00:54:10 <jtanguy> for the dependency problem, the tool cabal-dependency-licenses is a great help https://hackage.haskell.org/package/cabal-dependency-licenses
00:55:22 <gfixler> wow, quite handy
00:55:39 <trap_exit> http://www.stephendiehl.com/posts/haskell_web.html .. says "cabal install postgres-simple"
00:55:54 <trap_exit> howeer, "cabal list postgers-simple" doesn't show it
00:55:56 <trap_exit> has it been renamed?
00:57:25 <jtanguy> i think the package name is postgresql-simple
00:57:39 <trap_exit> jtanguy: "cabal install postgres-simple" ... does it work for you?
00:58:33 <jtanguy> nope, I think it's a typo
01:01:01 <trap_exit> jtanguy: I thought you were being a smartass, but as it turns out, yes, it was a typo ... and you helped me fix it ... thanks :-)
01:03:22 <gfixler> elm wants me to run cabal install cabal-install
01:03:37 <gfixler> how can I cabal install without cabal-install?
01:04:13 <tdammers> wha?
01:04:29 <gfixler> also, don't I already have it if I installed the haskell-platform?
01:04:36 <tdammers> oh
01:04:48 <tdammers> well, yeah, you should have cabal if you have the platform
01:04:58 <tdammers> but you may have an older version
01:05:21 <tdammers> in which case cabal says something like "there is a new version of cabal available, run cabal install cabal-install to upgrade"
01:05:29 <tdammers> so maybe that's what's happening?
01:05:36 <gfixler> oh, it just updates cabal?
01:05:42 <tdammers> yes
01:06:01 <gfixler> that makes a bit more sense, in a weird, breaking-the-DAG, bootstrappy sort of way
01:06:02 <tdammers> if you don't have cabal at all, cabal can't say that, because it doesn't exist
01:06:09 <gfixler> right
01:06:15 <tdammers> instead, you'd get a message from your OS telling you that cabal cannot be run
01:06:25 <gfixler> but elm's install instructions said to download the haskell platform, then do cabal install cabal-install
01:06:41 <gfixler> and I was like "But... won't I already have cabal-install if I can cabal install?"
01:06:47 <tdammers> right, yes, they probably just want to make sure that you have an up-to-date cabal installed
01:06:55 <gfixler> well that's nice of them
01:07:20 <gfixler> they also have 2 install lines like this: cabal install -j elm-compiler-0.14.1 elm-package-0.4 elm-make-0.1.1
01:07:22 <tdammers> cabal has seen a bunch of really big features lately, and it's possible that elm relies on those, and that they haven't made it into platform yet
01:07:26 <tdammers> sandboxes come to mine
01:07:28 <tdammers> *d
01:07:29 <gfixler> seems awfully specific
01:07:40 <tdammers> hmm
01:07:46 <gfixler> like the web page could get out of date quickly
01:07:51 <gfixler> http://elm-lang.org/Install.elm
01:07:51 <tdammers> I'd assume that just cabal install elm should be enough, but huh
01:08:03 <gfixler> also: cabal install -j elm-repl-0.4 elm-reactor-0.3
01:08:41 <tdammers> ah right
01:09:10 <gfixler> I'm not sure what -j is; man cabal doesn't work
01:09:11 <tdammers> I think the purpose is to install exactly these versions, instead of whatever happens to be the latest release on hackage
01:09:26 <gfixler> yeah, I figured they listed a set that goes well together
01:10:31 <tdammers> it's probably "the latest stable release at the time of writing" for each
01:10:46 <gfixler> good enough to start playing, I suppose
01:11:59 <tdammers> ye
01:12:01 <tdammers> s
01:12:33 <tdammers> the risk of just installing the lastest version is that you may be installing things in a situation where one of the packages has been uploaded but the other hasn't
01:14:06 * hackagebot extensible 0.2.4 - Poly-kinded, extensible ADTs  http://hackage.haskell.org/package/extensible-0.2.4 (FumiakiKinoshita)
01:30:52 <biglama> hi guys, I am reading the tutorial about hxt on haskellwiki
01:31:14 <biglama> I find that rather complicated for a beginner, is it normal ? :)
01:32:52 <srhb> biglama: hxt is big and complex, yes.
01:33:48 <biglama> srhb: is it worth it ?
01:34:01 <srhb> biglama: Depends what you need to do.
01:34:07 * hackagebot htime 0.3.1 - Timing utility for the command line  http://hackage.haskell.org/package/htime-0.3.1 (JosePedroMagalhaes)
01:34:21 <biglama> srhb: I am looking to convert a xml file to json
01:35:02 <srhb> Yeah it's probably a good choice for that.
01:35:16 <biglama> srhb: okay, thanks
01:35:39 <biglama> i can see roughly how to read the .xml, but i have no idea how to output to json
01:35:50 <biglama> but I guess it will be clearer at the end of the tutorial
01:35:57 <srhb> biglama: Look at aeson for that
01:36:06 <srhb> biglama: If you can parse to a datatype with hxt at least
01:36:46 <biglama> srhb: i see, thanks !
01:36:48 <srhb> You could probably get away with the xml library too for this task, actually
01:36:56 <srhb> Might be simpler than hxt
01:37:18 <biglama> srhb: I'm not in a hurry and it could be good for improving my haskell-fu
01:37:25 <srhb> OK :) Go for hxt then
01:37:27 <srhb> It's cool.
02:20:11 <TonyMase> Hi.
02:20:40 <TonyMase> Hello.
02:32:53 <adas> Welcome
02:33:31 <mpickering> Is there an implementation of a kind polymorphic hlist anywhere?
02:34:59 <shachaf> Kind-polymorphic HList?
02:35:10 <mgsloan> What would that mean?  What would you store in such a list? :)
02:36:10 <shachaf> whoa, hi mgsloan
02:36:35 <mpickering> well, I have a promoted data type data Foo = A | B, I want to store the promoted As and Bs in a type level list but they are of kind "Foo" not *
02:36:42 <mgsloan> Hey shachaf!  How's it going?
02:37:32 <mgsloan> Ahh, type level list, gotcha.  Couldn't you define "data Cons a b" and use that?
02:38:08 <mgsloan> (and "data Nil" orso)
02:38:11 <shachaf> '[] is already polykinded
02:38:34 <shachaf> :k [False, True]
02:38:34 <lambdabot> [Bool]
02:38:40 <mgsloan> Even better!
02:38:54 <mpickering> ok great, I see my mistake thanks
02:38:58 <dramforever> wait a sec
02:39:10 <shachaf> Was your mistake testing with a one-element list? :-)
02:39:11 <dramforever> I thing mpickering need **polymorphic** listts
02:39:19 <dramforever> *lists
02:39:26 <dramforever> or did I misunderstand it??
02:39:43 <dramforever> also s/need/needs
02:40:13 <mpickering> we shall see
02:54:11 * hackagebot multirec 0.7.5 - Generic programming for families of recursive datatypes  http://hackage.haskell.org/package/multirec-0.7.5 (JosePedroMagalhaes)
02:57:55 <hiato_> Hey all, I was wondering if anyone has had any luck running ghc 7.6.3 (the default packaged) on OpenBSD 5.6 on i386, I cant seem to make it work
02:59:11 * hackagebot debian-build 0.5.0.0 - Debian package build sequence tools  http://hackage.haskell.org/package/debian-build-0.5.0.0 (KeiHibino)
03:04:11 * hackagebot structured-haskell-mode 1.0.9 - Structured editing Emacs mode for Haskell  http://hackage.haskell.org/package/structured-haskell-mode-1.0.9 (ChrisDone)
03:14:12 * hackagebot descriptive 0.3.0 - Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.  http://hackage.haskell.org/package/descriptive-0.3.0 (ChrisDone)
03:19:12 * hackagebot structured-haskell-mode 1.0.10 - Structured editing Emacs mode for Haskell  http://hackage.haskell.org/package/structured-haskell-mode-1.0.10 (ChrisDone)
03:19:14 * hackagebot hindent 4.2.4 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.2.4 (ChrisDone)
03:23:38 <sinelaw> Is there a way to customize stylish-haskell column width?
03:23:40 <sinelaw> in emacs
03:34:38 <sinelaw> got it. run:
03:34:39 <sinelaw> stylish-haskell -d > ~/.stylish-haskell.yaml
03:34:48 <sinelaw> and then edit that file (there's a "columns" setting)
03:53:54 <ironChicken> to compile a library with cabal that uses some C++, should i need to include "include-dirs: /usr/include/c++/4.9" in the configuration?
03:54:26 <ironChicken> i feel like there's something really basic that i'm missing here
03:59:02 <dramforever> Aww...does anyone know parsing libraries that are easier than parsec?
03:59:10 <dramforever> I mean, easier to debug
03:59:18 <mpickering> what is your problem
03:59:47 <dramforever> Whenever I write a parser, I end up getting "unexpected eof"
04:00:16 <dramforever> Now I'm going to try again, and I don't want that thing
04:01:05 <dramforever> (Not specific enough, right? sorry)
04:01:15 <ironChicken> if i add that include directory, then it can find <vector>, but then it can't find <bits/c++config.h>
04:01:19 <kvanb> dramforever: yeah I had that problem
04:01:31 <ironChicken> i really don't think chasing after all the STL include directories can be right, can it?
04:01:37 <kvanb> it basically just means you didn't think through your parser entry point enough
04:01:45 <kvanb> its completely avoidable if you think your parser through, top to bottom
04:01:58 <dramforever> kvanb: That's why I think parsec is hard
04:02:09 <kvanb> trifecta is nice
04:02:13 <kvanb> but its harder than parsec
04:02:48 <dramforever> In fact, I was looking at trifecta a minute ago because I saw "This package provides a parser that focuses on nice diagnostics."
04:03:00 <dramforever> Turns out that those diagnostics aren't for me
04:03:01 <dramforever> :(
04:04:30 <mpickering> a simple way to debug is .. getInput >>= traceShowM
04:04:37 <dramforever> Hmm...maybe they _are_, or could be
04:04:43 <dramforever> mpickering: wow I didn't know that
04:04:57 <dramforever> but now I'm afraid of parsec :(
04:05:15 <mpickering> an eof error sounds like one of your parsers is eating too much
04:05:30 <dramforever> mpickering: yes
04:05:41 <dramforever> ate all traces of bugs
04:05:56 <dramforever> luckily it won't bite me
04:08:02 <dramforever> I'm desperate. I'm going to try trifecta
04:08:38 <ironChicken> so how do i include the C++ standard library headers?
04:10:56 <dramforever> ironChicken: What if you don't include that?
04:11:08 <dramforever> can the compiler still find <vector>?
04:11:37 <mpickering> dramforever: If you ask a more specific question about what you want to parse then we might be able to help
04:12:07 <dramforever> mpickering: A markup language, like...a markdown/TeX hybrid
04:12:09 <ironChicken> dramforever: no
04:12:23 <ironChicken> that's why i put it in in the first place
04:12:38 <dramforever> can you find bits/c++config.h?
04:12:42 <mpickering> right.. markdown is very difficult to parse properly
04:12:58 <mpickering> can you show some code which doesnt work?
04:13:30 <dramforever> mpickering: it's not on my current box
04:13:32 <ironChicken> dramforever: yes, it's part of the STL implementation
04:13:45 <merijn> dramforever: Read this: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
04:13:47 <dramforever> ironChicken: weird...
04:14:06 <dramforever> merijn: yes, I totaly agree with the URL
04:14:16 <ironChicken> but it should be visible from I/usr/include/c++/4.9, because that's where it lives
04:14:25 <ironChicken> but i really don't think i should be doing this
04:14:38 <ironChicken> surely there's a proper way to compile c++ from cabal?
04:14:51 <merijn> ironChicken: Yes, add a hook to call your C++ build system
04:15:57 <dramforever> Okay, turns out that the computer god doesn't want me to use trifecta: https://github.com/ekmett/trifecta/issues/41
04:16:18 <dramforever> so he updated blaze
04:16:37 <merijn> ironChicken: Cabal doesn't support directly building C++ code and it only supports the bare minimum of C, but the Custom build type lets you add arbitrarily complex custom hooks to the build process
04:16:56 <merijn> ironChicken: There's already a set of default hooks to call autotools, if you want something else you'll have to do that yourself
04:17:01 <dramforever> because he doesn't want to mess up with E. Kmett
04:20:00 <ironChicken> merijn: ok, thanks. looks like this is going to take a long time
04:25:14 <profil> is it possible to combine record with several type constructors?
04:26:04 <tdammers> profil: you mean as in sum types
04:26:11 <dramforever> What do you mean by "combine", "record" and "type constructors"? Maybe you can be more specific
04:26:41 <profil> yeah sorry
04:26:53 <tdammers> yes, it's possible
04:27:31 <profil> right now I have "data Something = Somethings Stuff Something | NotSomething"
04:27:42 <profil> and I want to be able to access Stuff easily from that
04:28:08 <tdammers> yeah, you can have record syntax in every part of your sum type
04:28:10 <hpc> data Something = Somethings {stuff :: Stuff, something :: Something} | NotSomething
04:28:15 <profil> so I thought about using records like: "data Something = Something { stuff :: Stuff, rest :: Something } | NotSomething"
04:28:22 <dramforever> profil: easily...not if you are given a NotSomething
04:28:28 <profil> yeah, alright, thanks =)
04:28:30 <hpc> just be careful, because stuff NotSomething = undefined
04:28:38 <tdammers> ^^
04:28:46 <tdammers> this is why I generally avoid this
04:28:46 <profil> dramforever: no I will pattern match of that before I'll get there :)
04:28:59 <profil> how would you solve it?
04:29:06 <tdammers> I prefer having another level of indirection
04:29:20 <dramforever> profil: then why not blah (Something s r) = ...
04:29:25 <dramforever> and use s in that ...
04:29:45 <tdammers> data Something = Something { stuff :: blah }; data SomethingOrNothing = Something Something | NotSomething
04:30:04 <hpc> or Maybe Something
04:30:08 <profil> oh, okay
04:30:23 <dramforever> profil: how did you pattern match?
04:30:25 <profil> I guess pattern matching for Stuff would be most simple
04:30:30 <dramforever> yes
04:30:41 <dramforever> and I heard that you've already done that
04:31:16 <profil> yes :)
04:31:18 <profil> thanks guys
04:44:15 * hackagebot Treiber 0.0.2 - Lock free Treiber stack  http://hackage.haskell.org/package/Treiber-0.0.2 (julek)
04:50:14 <dramforever> I'm thinking...maybe if I make marcos have type [Token] -> [Token] I could be really close to that <del>stupid</del> smart but weird marco system
04:50:59 <tdammers> dramforever: needs more context :D
04:51:14 <dramforever> tdammers: yep
04:51:26 <dramforever> but maybe I should not do tha
04:51:29 <dramforever> *that
04:54:13 <tdammers> newtype Function m = Function [(Maybe ArgumentName, Value m)] -> m (Value m)
04:54:16 * hackagebot edentv 4.10.0 - A Tool to Visualize Parallel Functional Program Executions  http://hackage.haskell.org/package/edentv-4.10.0 (horstmeyer)
04:56:44 <dramforever> tdammers: how about data Piece = TokenPiece Token | Group [Piece]
04:56:45 <tdammers> (that's something I'm actually using ATM to implement a unityped template language on top of haskell)
04:57:25 <tdammers> dramforever: isn't that just a textbook branch/leaf tree structure?
04:57:38 <tdammers> data Tree a = Branch [Tree a] | Leaf a
04:57:43 <dramforever> tdammers: yes it is
04:58:07 <dramforever> we cound have marco :: [Piece] -> [Piece]
04:58:24 <tdammers> oh, hehe
04:58:26 <dramforever> If the top piece is not a command, we emit it
04:58:38 <tdammers> yeah, I get it
04:58:39 <dramforever> If it is, take it and run it on the rest
04:58:54 <tdammers> and I think I have a rough idea what the context is now
04:59:03 <tdammers> (are you writing yourself a scheme or something?)
04:59:18 <dramforever> tdammers: a markup language
04:59:27 <tdammers> heh, aren't we all :P
05:00:32 <dramforever> tdammers: actually, it looks turing complete now
05:00:38 <dramforever> (With enough marcos)
05:02:42 <tdammers> I know a guy named marcos
05:03:28 <dramforever> tdammers: it's very flexible, for example I could have \c that puts the next word in <code> and </code>
05:22:25 <dramforever> Haskell is powerful when you think correctly
05:22:40 <dramforever> sadly, that's not the case for C programmers
05:23:04 <dramforever> well, ex-C programmers
05:23:40 <dramforever> okay it's not very clear, forget about it
05:28:17 <tolln> hi, i want to use queue in a concurrent program. what library should i use?
05:28:41 <tdammers> tolln: what kind of queue? for what purpose?
05:28:54 <dramforever> Chan, maybe
05:28:56 <dramforever> :t Chan
05:28:57 <lambdabot> Not in scope: data constructor ‘Chan’
05:29:20 <tolln> tdammers: i want to collect logs from some threads.
05:29:44 <dramforever> tolln: Control.Concurrent.Chan
05:30:15 <tolln> tolln: thanks a lot. i'll try it.
05:30:30 <dramforever> lol you are talking to yourself
05:30:58 <grayling_> tolln: That happens to me all the time...
05:31:02 <tolln> tdammers: thanks a lot. i'll try it.
05:31:11 <tolln> sorry...lol
05:31:49 <dramforever> tolln: http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html
05:32:02 <dramforever> section "Communicating over channels"
05:34:18 <tolln> dramforever: thanks!
05:40:47 <prinsen> Has anyone used https://hackage.haskell.org/package/apis ? Im the developer and would like to hear feedback from users
05:45:19 <grayling_> prinsen: Well if you want my five cents, I'm thinking that a readme included at github would be nice. :-)
05:46:58 <merijn> The product of a poset is just partially ordered product right? i.e. lexicographical ordering. But then what'd the coproduct of a poset be?
05:50:04 <cryzed> I want to ask something potentially really dumb, but I'd like to prefix the question by firmly acknowledging that it might sound dumb. Isn't the main use-case of monads basically just a way to "silently" let an error in a (series) of computation(s) "bubble up" to the top as mzero/"Nothing"?
05:50:37 <Emre`> Why do they say that learning Haskell (or Lisp) makes you a better programmer? They never give specifics to this argument. How would my C skills benefit from learning Haskell?
05:50:53 <merijn> cryzed: That interpretation makes no sense for, for example, the list monad or tuple monad, though
05:50:56 <tdammers> Emre`: are you familiar with the Blub programmer?
05:50:57 <chpatrick> cryzed: only for certain monads
05:51:05 <tdammers> Emre`: if not, look it up
05:51:11 <cryzed> merijn, chpatrick: Thank you, I'll do some more reading and thinking then
05:51:24 <chpatrick> Emre: I think it's good for making you think about problems in the abstract, instead of how to solve them
05:51:24 <merijn> Emre`: Because haskell lets you expres ideas that are to complex to expres in, for example, C
05:51:43 <tdammers> Emre`: in a nutshell, languages like Lisp or Haskell are very expressive; they can express everything C can express, and then some
05:51:44 <merijn> Emre`: As a result, it becomes hard to identify and abstract out common patterns, because they're lost in the noise
05:52:23 <merijn> Emre`: Haskell's type system is much more amenable to identifying and using these abstractions. Yet once you know them you can see how they appear/apply in other languages too
05:52:27 <Chathurga> Emre`: From learning Haskell you learn how to explicitly model the relationship between values in your program. Using globals and implicit state lets you cheat and not really think how your data is linked
05:52:52 <chpatrick> Emre`: also good modern style in most languages is immutable/stateless anyway
05:52:56 <merijn> cryzed: FWIW, I don't believe "understanding" monads is a very useful thing in itself.
05:53:06 <Emre`> Chathurga: That's what I'm trying to say. I can 'cheat' when I'm back to C anyway.
05:53:08 <cryzed> merijn, more like understanding their possible application and usage?
05:53:23 <merijn> cryzed: The best I can do is: "Monads are applicatives where the result of a composite action can depend on the result of previous actions"
05:53:24 <chpatrick> I think it's useful to get the general idea too
05:53:29 <Chathurga> Yes but for me at least I didn't even know I was wrong. Now I do so I code in that style
05:53:34 <dramforever> http://lpaste.net/118996 Can someone help?
05:53:38 <merijn> cryzed: Whereas, with Applicative control flow can't depend on the result of earlier results
05:53:42 <Chathurga> Sure it isn't enforced but it helps that I think like that now
05:53:42 <chpatrick> that's how I think about it too
05:53:43 <tdammers> cryzed: probably more like understanding how they're not that big of a deal after all, and that they do not possess any of the magical properties people thing they have
05:53:46 <cryzed> merijn, I thought of monads for a whole of containers wrapping values with some extra metadata/functionality
05:53:50 <Emre`> Could you point me to an example?
05:53:51 <cryzed> but I'm not sure if that is any more accurate
05:53:53 <chpatrick> they're not containers
05:53:53 <dramforever> The problem is compilcated, so I put it in a paste
05:53:56 <cryzed> *while
05:53:58 <merijn> cryzed: Learning many applications and pondering the laws is the best, I think
05:54:06 <vanila> Emre`, You might be able to use some ideas which are easily expressed in haskell in C where they are harder to implement and less obvious
05:54:10 <cryzed> tdammers, merijn: Thank you
05:54:16 <clrnd> monads obviously
05:54:54 <dramforever> maybe I'm stupid, but I can't see why
05:54:55 <vanila> Emre`, it's just that having a wider breadth of knowledge to draw upon will enable you to solve problems more creatively
05:55:01 <Emre`> Let's say I now approach my problems utilizing pattern matching or list comprehensions or map/reduce or any of the FP constructs.
05:55:17 <vanila> you shouldnt limit your focus to those things
05:55:35 <cryzed> Emre`, for example I feel like writing in Haskell has rocketed my intuitive understanding of recursive functions
05:55:39 <Emre`> Without a language that does offer me a way to use this, I wouldn't agree that my skill is really improved
05:55:43 <merijn> Emre`: One example is the use case of Applicative and Monad abstractions. Parser combinators are based on these two abstractions. One example is that translating, for example, the HTTP header spec into a parser combinator parser is very straightforward
05:55:48 <chpatrick> cryzed: functors are where you can apply a pure function to some computation. applicatives are where you can combine computations with a pure function but the computations can't depend on previous ones. with monads you can make a new computation that depends on the result of a previous one.
05:55:49 <cryzed> Emre`, I feel now much more at ease using and implementing those
05:55:52 <dramforever> Maybe it's impolite to ask, but is anyone looking at my code?
05:55:53 <Chathurga> I don't have code on hand but it's just that my C code is pretty much stuctured like my haskell code. Pure functions mostly and a select few non-pure parts
05:56:01 <dramforever> sorry if it is
05:56:04 <Chathurga> I seperate concerns better now
05:56:16 <merijn> Emre`: At the same time bos wrote an attoparsec HTTP header parser that's faster than Ryan Dahl's hand written crazy optimised http-parser parser
05:56:48 <cryzed> chpatrick, I'll copy what you just wrote and note in down somewhere and try to really understand it when I'm looking over my Haskell texts/tutorials again, thank you
05:56:49 <dramforever> attoparsec **is** crazy
05:57:01 <dramforever> Why the continuation can't be called twice?
05:57:09 <dramforever> There must be something going on
05:57:19 <dramforever> something impure
05:58:07 <merijn> Emre`: Compare the 65 line haskell parser vs the 2400 line C monstrosity and then compare the performance results: http://www.serpentine.com/blog/2014/05/31/attoparsec/
05:59:08 <merijn> cryzed: One fun (for some value of fun) exercise is coming up with random types and trying whether you can make them law abiding instance of Functor, Applicative and Monad
05:59:18 * hackagebot Treiber 0.0.3 - Lock free Treiber stack  http://hackage.haskell.org/package/Treiber-0.0.3 (julek)
05:59:32 <merijn> cryzed: I usually tell people to implement the State monad by hand (exercise here: https://gist.github.com/merijn/098106abd45c940dab09)
05:59:39 <chpatrick> +1
05:59:52 <Emre`> merijn: But that is one area that Haskell is supposed to excel in.
06:00:10 <vanila> Emre`, I feel like I answered your question well
06:00:13 <Emre`> It is like comparing Fortran with other languages when it comes to number crunching.
06:00:27 <merijn> cryzed: Other examples are: "Can '(,) e' be made a Functor/Applicative/Monad?" if not, why not? Which laws does it violate?
06:00:30 <vanila> you don't seem happy with it though?
06:00:41 <dramforever> lol
06:00:47 <merijn> cryzed: And also "data Const a b = Const a" (this one is similar to the '(,) e' one
06:00:57 <Emre`> No I am. In fact I'm learning Haskell. It's just that I've been hearing that argument a lot and nobody seems to follow it with some concrete examples.
06:01:01 <dramforever> saw the rev thing at the end of the article
06:01:45 <merijn> Emre`: Parsers are just one example, my main point was: The higher level of abstraction and typing in haskell makes it easier to identify and use abstractions that go unnoticed in other languages.
06:01:49 <cryzed> merijn, thank you for the tips, I'll be taking a look at these
06:02:25 <dramforever> yzarc si cesrapotta
06:02:30 <merijn> Emre`: Even Applicative which has taken over large parts of the current haskell ecosystem was only discovered in 2004. Monads were only discovered and added to Haskell after the fact. No one was able to spot these patterns in other languages
06:03:07 <merijn> Anyway, coffee break :)
06:03:19 <Emre`> Thanks for the comments though
06:03:28 <Emre`> #haskell is so welcoming
06:03:55 <dramforever> I'll ask again: Can anyone help? I'm not understanding what's happening here: http://lpaste.net/118996
06:04:06 <dramforever> Thanks in advance
06:07:40 <Chathurga> That attoparsec article... wow
06:09:05 <Chathurga> dramforever: Which part specifically?
06:09:22 <dramforever> Chathurga: see the sample session
06:09:31 <dramforever> I think I'm not getting the right ts
06:09:47 <Chathurga> Oh right sorry!
06:10:57 <dramforever> Oh, I think I got it
06:11:13 <dramforever> Chathurga: the error happened when recursing down
06:11:22 <dramforever> It's okay. problem solved.
06:12:14 <jophish_> Yo yo yo
06:13:18 <jophish_> What's the reason behind length (and so many other functions) returning (or taking) an Int, when Word would be more appropriate (because the length is non-negative
06:13:28 <jophish_> I can only assume this is a historical mistake
06:14:19 * hackagebot conlogger 0.1.0.0 - A logger for a concurrent program.  http://hackage.haskell.org/package/conlogger-0.1.0.0 (tattsun)
06:14:44 <nshepperd> merijn: if I was to try define a partial ordering for a coproduct of posets, I imagine I would write something like 'Left _ < Right _'
06:15:00 <vanila> jophish_, i think its because more things use Int, if you used Word you'd need more explicit coercions to different types
06:15:03 <lieven> it would be more useful sometimes if length returned a generic Number
06:15:06 <vanila> over all this a problem in haskell
06:15:15 <vanila> there doesn't seem to be a good way to do numbers
06:15:18 <dramforever> :t genericLength
06:15:19 <lambdabot> Num i => [a] -> i
06:15:29 <nshepperd> which is really a lexicographic ordering over (tag, value)
06:15:30 <dramforever> lieven: that must be what you want
06:15:37 <lieven> yeah I know of it
06:15:50 <dramforever> and length is a special genericLength
06:16:03 <jophish_> vanila: yeah, just as I suspected. It's a shame, because haskell is very much about explicit conversions
06:16:06 <dramforever> historical mistake? performance reasons?
06:16:30 * dramforever often does "where fi = fromIntegral"
06:16:32 <jophish_> It isn't more performant to return an Int instead of a Word
06:19:19 * hackagebot conlogger 0.1.0.1 - A logger for a concurrent program.  http://hackage.haskell.org/package/conlogger-0.1.0.1 (tattsun)
06:20:10 <Chathurga> It's a pity the non-generic version of functions is the default a lot in Haskell
06:20:16 <hodapp> hrm?
06:20:19 <Chathurga> map, length, fold
06:21:26 <c_wraith> Chathurga: a lot of that is changing starting in ghc 7.10
06:22:04 <Chathurga> I've seen the holy grail Applicative change, it's good and I'm hoping for more. Idris has me spoiled
06:22:21 <dramforever> maybe change it to 8.0? it breaks lots of code
06:22:22 <c_wraith> Chathurga: due to a project called the "burning bridges proposal".  It's starting by moving Foldable and Traversable into the Prelude
06:22:50 <Chathurga> Oh I didn't know there was an actual proposal for that
06:22:59 <erisco> what about dem error messages?
06:23:17 <erisco> or are the bridges being burned to those people
06:23:19 <Chathurga> import Prelude.Simple
06:23:43 <Chathurga> or maybe import Prelude.Pro, I just want me some tasty genericness
06:24:21 <erisco> well you can just import Foldable and Traversable if you want to import something
06:25:01 <Chathurga> That only solves that, then there's everything else like fmap/map, length/gernicLength, etc
06:25:11 <Chathurga> *generic
06:26:06 <erisco> next you'll be wanting dependent types
06:26:21 * Chathurga blushes
06:26:56 <c_wraith> https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell
06:27:30 <erisco> "there's an extension for that"
06:27:42 <erisco> or I suppose "there's a proposal for that"
06:28:12 <indiagreen> or more like “there's a guy who's been slowly pushing it for several years by now”
06:28:17 <c_wraith> The fun thing about that proposal is that the guy who's behind it has been quite active in making small steps in that direction.
06:29:20 * hackagebot tpdb 1.1.1 - Data Type for Rewriting Systems  http://hackage.haskell.org/package/tpdb-1.1.1 (JohannesWaldmann)
06:29:30 <Chathurga> I do think dependent types are one of the futures of programming
06:29:47 <Chathurga> I really like it
06:29:52 <vanila> its nice to think that but aren't they too hard to use in practice?
06:30:17 <jophish_> I don't suppose that there are any s/Integer/Natural/ or s/Int/Word/ proposals under the BBP
06:30:22 <Chathurga> Depends I guess, I wrote a small web framework using constructs I could not have type checked before
06:30:25 <dramforever> I think the {-# CONTRACT #-} thing is better
06:30:28 <c_wraith> vanila: it...  depends...
06:30:29 <mr-> vanila: OCharles has a nice talk about that.
06:30:35 <Chathurga> First class type safe routing
06:30:37 <vanila> wow, sounds super cool!
06:30:38 <mr-> vanila: you don't have to go 'all in' at once
06:30:41 <vanila> is there a link?
06:30:43 <erisco> vanila, I dunno, but I don't care for types as values, I just want a sane type level programming language (i.e. identical to the value level language)
06:31:30 <mr-> vanila: it is not about dependent types really, but how they started with a "string based interface" and added more type-level stuff as they needed it.
06:32:13 <Chathurga> profilePage = route "/profile/:uid" [("uid", UserId)] loadProfile
06:32:13 <Chathurga> type of loadProfile : UserId -> Response
06:32:30 <Chathurga> Being able to type check that kinda stuff is crazy
06:32:57 <mr-> vanila: I think you can find it there: https://skillsmatter.com/skillscasts/5356-oliver-charles
06:34:20 * hackagebot webify 0.1.7.0 - webfont generator  http://hackage.haskell.org/package/webify-0.1.7.0 (ananthakumaran)
06:36:09 <tdammers> I'm kind of going the other direction with my web thing I'm building
06:36:23 <tdammers> controlled amounts of unityped contexts within a typesafe host application
06:36:48 <jophish_> https://hackage.haskell.org/package/acme-stringly-typed-1.0.0.0/docs/Acme-StringlyTyped.html seems appropriate to mention here
06:36:57 <erisco> I think I just need a bunch of functions... ((S a, S b) -> c) -> X (a, b) -> X c; ((S a, S b, S c) -> d) -> X (a, b, c) -> X d
06:36:58 <tdammers> e.g., my template system is dynamically-typed, but its value type is restricted into the TemplateM monad, which means it cannot access stuff that the template monad doesn't expose
06:37:02 <erisco> look familiar to anyone? =\
06:37:03 <vanila>  Please log in to view this content. :///////
06:37:04 <tdammers> and no, it's not stringly typed
06:37:34 <tdammers> erisco: btw, the "you've gone too far in the right direction" part is actually working, woop woop
06:37:57 <erisco> tdammers, that's great! I don't know what you're referring to though
06:38:00 <tdammers> https://bitbucket.org/tdammers/ginger <- totally not production ready yet, but hey
06:39:03 <tdammers> erisco: remember when I described how I was going from a sum type to represent template variable values, to a record type where each field is a function that returns Just the value cast to a particular representation, or Nothing if that doesn't make sense for this particular value?
06:39:06 <tdammers> that.
06:39:20 * hackagebot lord 2.20150122 - A command line interface to online radios.  http://hackage.haskell.org/package/lord-2.20150122 (rnons)
06:39:23 <Chathurga> My dream is having everything type checked from the URL to the database to the template, the last part is the one I have no answers for
06:39:42 <erisco> no I don't remember :( but I'm glad you are making progress
06:39:52 <Chathurga> Maybe Wyvern will answer some of the questions I have
06:39:53 <tdammers> so now my template variable type is data GVal m = GVal { asNumber :: Maybe Scientific, asList :: Maybe [GVal m], ... }
06:40:21 <tdammers> which means I can hook up any value I like on the host side, as long as I can provide a suitable set of casting functions
06:40:53 <Chathurga> Oh yeah, that's cool
06:41:01 <tdammers> I've hooked it up into the CMS I'm working on, too; I'm getting page response times under 2 ms, without any caching whatsoever
06:41:36 <tdammers> (that's using the builtin Warp server, and an in-memory database with occasional filesystem persistence though...)
06:42:25 <mr-> vanila: yeah.. just log in ;-)
06:43:35 <gcganley> is there a standard delimiter for marshalling c arrays in and out of haskell or do i just make one up
06:43:51 <gcganley> im marshalling (Ptr CString)'s
06:47:00 <Finalfire> hello!
06:49:21 * hackagebot iothread 0.1.0.0 - run IOs in a single thread  http://hackage.haskell.org/package/iothread-0.1.0.0 (tattsun)
06:50:20 <triptec> I'm getting Incompatible {errSQLType = "timestamp", errSQLTableOid = Nothing, errSQLField = "", errHaskellType = "UTCTime", errMessage = ""} from Database.PostgreSQL.Simple i believe, has anyone had this problem
06:51:59 <tdammers> I'd gamble that timestamp and UTCTime are incompatible, because a timestamp is implied to be in "some time zone" (i.e., it's a time value without a time zone), while UTCTime is an "absolute" time, or a time-with-timezone
06:52:28 <tdammers> postgres takes the distinction pretty seriously, and with good reason
06:53:15 <triptec> tdammers: yeah
06:54:06 <triptec> tdammers: so, I need to use another then.. thanks
06:55:06 <merijn> gcganley: C string's are generally nul terminated
06:55:07 <tdammers> triptec: I guess you either want to use a timezoned timestamp on the psql side, or map it to a local time on the haskell side
06:55:11 <tdammers> (and then guess the timezone)
06:55:18 <merijn> > '\0'
06:55:19 <lambdabot>  '\NUL'
06:55:59 <merijn> Actually, not even generally. If they're not, they're not strings :p
06:56:26 <tdammers> if they are, they're not really strings either :D
06:57:00 <gcganley> merijn: but what about arrays of strings...
06:57:05 <merijn> tdammers: I was talking about C strings and that's what C strings are defined to be
06:57:37 <gcganley> I know that strings are null terminated but are arrays of CStrings null terminated also
06:57:41 <merijn> gcganley: Arrays of pointers are either not terminated (i.e., you just "know" the size) or you terminate them with a NULL pointer as last element
06:58:23 <gcganley> merijn: cool, would i do that with the nullPtr constant from Foreign.Ptr of '\0'
06:58:29 <gcganley> s/of/or
06:59:20 <merijn> nullPtr
06:59:29 <gcganley> merijn: ok, thank you
07:01:06 <triptec> tdammers: using LocalTime gives a compile error: http://lpaste.net/119003
07:02:38 <tdammers> ugh
07:03:09 <guaraqe> -------------------------------------------------------------------------------
07:03:11 <guaraqe> -- This function changes the indexes inside the simplexes from row indices to
07:03:13 <guaraqe> -- cell labels based on genealogy
07:03:15 <guaraqe> :q
07:03:55 <IP92> is the infix vs prefix notation just a matter of preference or is there one way notation people generally use?
07:04:24 <osa1> do we have an up-to-date and complete version of http://packdeps.haskellers.com/reverse ?
07:04:37 <clrnd> IP92, some functions look really cool infix, also you have operators which are always infix
07:05:56 <IP92> clrnd: I mean something like div and mod, where I can use infix using backticks
07:06:02 <erisco> IP92, infix is a syntactic necessity to make some operators bearable to use. Examples include (.), (+), (-), (>>=)
07:06:20 <erisco> also (<*>) is a good one
07:06:22 <clrnd> erisco, lisp disagrees
07:06:55 <erisco> yeah well if you love parentheses then infix means little to you
07:07:12 <erisco> or if you like squinting through prefix or postfix notations
07:07:36 <erisco> 3 4 5 + *   its beautiful!
07:07:51 <clrnd> 0.o
07:11:03 <S11001001> clrnd: http://clojuredocs.org/clojure.core/-%3E :)
07:11:06 <mauke\> preflex would have parsed that as 3 + (4 * 5)
07:11:37 <merijn> IP92: It's totally up to taste and even context
07:11:55 <merijn> IP92: I will use `div` if I have two operands, but prefix if partially applying
07:12:27 <merijn> IP92: My criterium is: What looks easier to read?
07:13:32 <tdammers> my criterium is "which one reflects my intention better?"
07:13:41 <tdammers> guess that boils down to the same thing though
07:23:18 <tempname11> hi #haskell. I have the latest Haskell Platform installed on OS X, it comes with GHC 7.8.3. What would be the right way to upgrade to 7.8.4?
07:27:10 <Na> If I want to generate a video given a list of (bitmappy?) frames, what's the library that let's me do this in the most painless way?
07:28:15 <merijn> tempname11: You can simply download the binary release and install it wherever on your system
07:28:29 <merijn> tempname11: Although, unless you're affected by any of the bugs it fixes, it may not be worth the effort
07:28:49 <tempname11> it fixes a bug in a library I intend to use
07:29:18 <merijn> Ah
07:29:33 <tempname11> ok, thanks. I thought that getting just the new binary would break stuff
07:29:52 <merijn> tempname11: GHC uses a per version database, so different GHC versions never interfere
07:30:02 <merijn> tempname11: cabal just uses whichever GHC comes first in your PATH
07:30:33 <merijn> tempname11: So usually I'll have the Platform installed in it's standard location and then just install binary releases of different GHC versions into different directories in my home dir
07:30:48 <merijn> tempname11: I select which one to use by simply changing my PATH to make sure that version comes first
07:31:27 <NameIs_NoName> Anyone here can guide me in hacking?
07:31:38 <merijn> tempname11: So it's basically just "./configure --prefix=$HOME/ghc-version && make install" and you're done
07:44:24 * hackagebot yesod-fay 0.7.1 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.7.1 (ChrisDone)
07:47:47 <funfunctor> How can I get my package on hackage?
07:47:59 <meditans> hi, I'd like to know something about ihaskell, but it doesn't seem to be anyone on #ihaskell
07:48:27 <meditans> funfunctor: first of all, I think, do a cabal check to check that your package is ok
07:48:51 <tdammers> funfunctor: do you have a hackage account?
07:49:03 <tdammers> funfunctor: if not, arrange for one.
07:49:16 <tdammers> funfunctor: then cabalize your package (i.e., produce a .cabal file for it)
07:49:22 <tdammers> funfunctor: then cabal sdist
07:49:41 <tdammers> funfunctor: then cabal upload {filename that cabal sdist produced}
07:50:22 <merijn> Wait!
07:50:28 <merijn> Cabal has an upload command now?
07:50:50 <tdammers> uh... yeah?
07:51:13 <merijn> :D
07:51:52 <meditans> it's not about ihaskell installation, no worries ;)
07:52:39 <supki> merijn: it's been there for years
07:53:26 <dcoutts_> merijn: only since forever
08:01:07 <merijn> Oh, now I remember why I had a script do it using wget, because I used that to also build + upload haddocks. Unless cabal does that too
08:01:54 <tdammers> no, cabal doesn't do that
08:02:07 <tdammers> I think the assumption was that hackage would build the docs for you
08:14:25 * hackagebot lucid 2.6.1 - Clear to write, read and edit DSL for HTML  http://hackage.haskell.org/package/lucid-2.6.1 (ChrisDone)
08:19:55 <miguelnegrao> hi, does anyone know of a library to create video out of individual images where the images are some type of array or list ?
08:24:08 <sinelaw> miguelnegrao, you need to do it in haskell you just get it done?
08:25:08 <miguelnegrao> sinelaw: it would be nicer if I can do it in haskell... otherwise I could use openframeworks or something like that
08:25:44 <sinelaw> miguelnegrao, a long time ago I made this in C: https://github.com/sinelaw/enough/blob/master/tools/video_writer.c
08:26:32 <sinelaw> miguelnegrao, requires installing opencv's highgui lib (sudo apt-get install libopencv-highgui-dev)
08:27:24 <miguelnegrao> sinelaw: so if I generate the frames with haskell, I could use that to assemble the movie, correct ?
08:27:34 <sinelaw> miguelnegrao, yes
08:27:44 <sinelaw> I mean, you would have to save them to a file
08:27:47 <sinelaw> one per frame
08:28:04 <miguelnegrao> sinelaw: yes. I guess that's doable.
08:28:20 <miguelnegrao> sinelaw: for images is 'juicypixels' the best ?
08:28:51 <sinelaw> miguelnegrao, dunno, haven't done it
08:29:25 <miguelnegrao> sinelaw: ok, thanks.
08:35:11 <sinelaw> can I tell cabal to not complain about outdated repositories?
08:35:23 <sinelaw> it's warning about needing to run "cabal update" dirties my stderr
08:35:30 <sinelaw> *its
08:35:47 <dcoutts_> I don't think that's configurable, patch welcome
08:36:06 <sinelaw> dcoutts_, maybe -v0 ?
08:36:17 <dcoutts_> yeah, probably
08:36:17 <sgronblo> uh i must be doing some noob mistake now
08:36:21 <sinelaw> probably not. let me check.
08:36:40 <dcoutts_> sinelaw: it should silence it, along with everything else
08:36:47 <sinelaw> dcoutts_, yeah that does it
08:36:48 <sinelaw> thanks.
08:36:48 <dcoutts_> it's not individually configurable
08:36:53 <sinelaw> that's ok
08:36:56 <sinelaw> good enough
08:37:01 <sinelaw> error are still printed
08:38:35 <dfeuer> @tell carter I found something floating point is good for! It lets you represent nutrition information using just one unit. Everything is in milligrams, with the energy content represented via E=mc^2.
08:38:35 <lambdabot> Consider it noted.
08:39:02 <sgronblo> doh, i was trying to use :: for cons
08:39:12 <dfeuer> sgronblo, you must be an ML programmer.
08:39:12 <sgronblo> damn you scala
08:42:33 <hodapp> hey, I should use a notation that makes it clear what I'm parametrizing in Haskell, and what I'm using Haskell to express a later parametrization of in an EDSL!
08:42:47 <hodapp> ...oh, wait, I am, because that's what the type signatures are.
08:42:51 * hodapp facepalm
08:45:23 <sgronblo> how do you go from IO ProcessHandle to getting the standard output for that process?
08:45:40 <glguy> You probably don't
08:46:03 <glguy> In the System.Process module there are ways to make processes that give you access to or let you specify the stdout handle
08:46:08 <sgronblo> maybe im supposed to use createProcess . shell ?
08:47:30 <glguy> That's right. Make sure you do something with both of the output handles
08:48:09 <glguy> You'll want to consume both the stdout and stderr so that neither gets full and blocks your program
08:48:55 <glguy> (or make sure your CreateProcess doesn't create a handle for stderr)
08:53:48 <benzrf> :t flip . liftA2 . flip
08:53:49 <lambdabot> Applicative f => (b -> a -> c) -> f b -> f a -> f c
09:06:21 <Na> I'm trying to install ffmpeg-light but it currently fails with the following error. http://lpaste.net/6919674977985757184 Am I doing something dumb?
09:11:50 <Thulsadum> is there a way to dynamcly load code/shared objects? I'm thinking of a plugin structure and in C/C++ I'd use dl.
09:12:57 <mauke\> Na: do you have the ffmpeg library and headers?
09:17:27 <Na> mauke\: Yep, at least as far as I can tell
09:21:21 <geekosaur> I would wonder if it's recent enough
09:23:53 <Na> I've got 1.2.6 and ffmpeg-light doesn't seem to list a requirement wrt version
09:24:28 * hackagebot http-server 1.0.5 - A library for writing Haskell web servers.  http://hackage.haskell.org/package/http-server-1.0.5 (IavorDiatchki)
09:25:01 <Na> Ah, wait, it does! Looks like it's compatible with 2.3
09:52:54 <tomphreek> I have played around with Haskell. I have a positive outlook on it. It is good with data processing. However, what I don't quite understand is the GUI programming. Here I heard dividing opinions: FP is not good for GUI programming or people should use X (reactive pattern is a common one). However I find it hard to argue with that fact that GUI is not stateless. Every button, every item on a screen is a
09:53:00 <tomphreek> state: it is either shown/toggled. It has x and y coordinates. OOP seems to fit GUI design especially well with instances of classes where each class describes an item on a screen. It seems to me using FP in this problem domain is not as natural as OOP. Do you see it differently?
09:54:29 * hackagebot lucid-svg 0.2.0.0 - DSL for SVG using lucid for HTML  http://hackage.haskell.org/package/lucid-svg-0.2.0.0 (jeffreyrosenbluth)
09:56:59 <sbrg> The "embed_data_files" flag for building pandoc, does it embed all templates and such into the binary?
09:57:09 <funfunctor> hi
09:57:09 <levi> tomphreek: Functional programming is not about eschewing state. It just has a different way of managing state; i.e. the current state is a function of the previous state + new inputs.
09:57:47 <hodapp> I wonder how normal it is that I have 'import qualified' everywhere to assist with all the refactoring I'm having to do as I understand this code...
09:58:00 <funfunctor> so what is a half decent way to handle error return codes from binded C functions half way though a do block? http://pastebin.com/M4bAr9SJ
09:58:15 <mnngfltg> After uninstalling old versions of haskell, I just installed the latest haskell-platform on OSX. Now I tried `cabal install`, but that takes ages "Building Cabal-..". Many minutes
09:58:25 <mnngfltg> Am I doing something wrong?
09:58:34 <funfunctor> note lines 40 and 47
09:59:10 <tempname11> funfunctor, throwIO?
09:59:33 <quchen> tomphreek: Functional programming (at least in its Haskell incarnation) makes mutability *explicit*, not bad or advised against.
09:59:41 <levi> tomphreek: Even with that in mind, there are a lot of different ways you can approach UI from a functional perspective, so it doesn't have a lot to do with Haskell specifically. And Haskell gives you the option of doing stateful imperative programming if you feel it's appropriate, too.
09:59:55 <quchen> tomphreek: And as a consequence, mutability is not recommended when immutability is sufficient.
10:00:33 <funfunctor> tempname11: yea but note what I am doing in the paste
10:00:39 <quchen> funfunctor: I run those blocks in ExceptT+IO.
10:01:25 <levi> The main problem with GUI in haskell is that modern UI stuff tends to be hugely complex, and it's a large amount of work to maintain libraries that do it in a native Haskell way, and even a relatively big job just to maintain bindings to C libraries that aren't very native-feeling at all.
10:02:10 <quchen> funfunctor: I've got a function `:: Functor f => f CError -> ExceptT Error f Success` that can be applied to the IO actions of FFI calls embedding them into my block.
10:02:43 <tomphreek> I am somewhat not a fan of writing large chunks of imperative code in Haskell
10:02:58 <tomphreek> can't really pin point why
10:03:02 <funfunctor> quchen: sorry, have you got a more details example of that functor somewhere please?
10:03:13 <funfunctor> I find it easier to follow complete examples
10:03:26 <funfunctor> i'm just reading https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html at the moment
10:03:39 <quchen> My Functor is mostly IO. So what you need is a mapping "IO CErrorCode -> IO (Either Error Success)".
10:04:03 <quchen> That's easy, it's simply `fmap errorCode_to_EitherErrorSuccess`.
10:04:30 * hackagebot binary 0.7.3.0 - Binary serialisation for Haskell values using lazy ByteStrings  http://hackage.haskell.org/package/binary-0.7.3.0 (LennartKolmodin)
10:04:31 <quchen> Now note that IO (Either e s) is ExceptT e IO s
10:04:53 <quchen> So chaining them together gives you an `IO CErrorCode -> ExceptT e IO s`
10:05:15 <quchen> And now you can generalize this for any Functor because IO is never used in the function, giving you the type I posted above.
10:05:39 <quchen> Concrete example: http://lpaste.net/119008
10:07:19 <funfunctor> quchen: ah the example makes more sense thanks!
10:08:06 <levi> tomphreek: Anyway, I think the aspects of OOP that are actually useful for GUI are pretty easily modeled in a functional language. And I think that the way that OOP is used in GUIs today is typically a huge mess rather than being actuall a nice or comfortable model to program in.
10:09:11 <tomphreek> Perhaps what I was trying to say is button.move(50, 50); "feels" more natural then. newButton = move(button); NewScreenContents = makeNewScreenContents(newButton, screenContents). If you could see what I am getting at through this silly example code you could point me to wher I am going wrong.
10:09:30 <tomphreek> or rather, to what I am not seeig
10:10:22 <Welkin> what you are comparing is mutable vs immutable data
10:10:33 <quchen> tomphreek: You're right that that's painful to do, so there are abstractions to make it pleasant to use (without giving up the explicitness).
10:10:38 <tempname11> funfunctor, I don't understand the problem. do you want to halt IO execution on the negative status or simply return "Unknown" as a result?
10:10:58 <levi> tomphreek: It looks to me like you're trying to approach a method for building a GUI procedurally rather than functionally.
10:11:04 <quchen> The State type is an example of this. It hides passing the state, passing it on automatically.
10:11:16 <platz> does using an OO style in a FP language resolve some of the complexity?
10:11:26 <johnw> platz: I would say no, not at all
10:11:43 <johnw> trying to do whatever "OO" means in FP usually increases complexity
10:11:43 <quchen> OO style in Haskell is painful or impossible, depending on who you ask
10:11:56 <josephle> iirc, xmonad has some OO ideas in its design...
10:11:57 <platz> this is with regards to GUI programming
10:12:10 <johnw> platz: FRP is pretty promising wrt GUI prog
10:12:12 <josephle> namely message passing between core xmonad and the plugins
10:12:46 <johnw> josephle: what's OO about having a mailbox that multiple threads have access to?
10:12:55 <platz> I'm hopeful for FRP; there have been some outcries at this stage so far
10:13:05 <johnw> platz: talk to ryantrinkle if you see him on
10:13:27 <platz> johnw: will do, thanks
10:13:27 <josephle> johnw: it's smalltalk style OO in a sense. It's how people justify saying erlang is OO :)
10:13:56 <johnw> josephle: ah
10:14:09 <ryantrinkle> johnw, platz: i'm here :)
10:14:47 <johnw> to me OO means, "We acknowledge state is awfully complex, so we make the scope of state appear smaller, but it's still awfully complex"
10:14:59 <levi> I think FRP is great for a certain class of interactive programs, but it's probably not the only great way to build functional user interfaces.
10:15:08 <josephle> johnw: well, message passing does split state between multiple components
10:15:19 <platz> josephle: yeah not in the OO-subclassing sense: smalltalk sense.  I think people mostly derive benefit from the event style interacting with components?
10:15:31 <platz> events and message passing are roughtly similar
10:18:18 <funfunctor> quchen: is Error and Success coming from some import or is that just something you defined somewhere?
10:18:45 <quchen> funfunctor: Custom data types. data Success = Success, data Error = Error1 | Error2 | Error3 …
10:18:47 <levi> tomphreek: If you want to see an interesting approach to composing the graphical output of an interface in a functional manner, the Diagrams API is pretty nice. Just imagine that in addition to plain geometry, you have a library of "widgets" or whatever as well.
10:19:15 <quchen> funfunctor: The function to do the raw conversion is c2hs_EitherErrorSuccess :: C'lcb_error_t -> Either Error Success
10:19:27 <quchen> Where C'... is the raw C type as the FFI sees i
10:19:32 <quchen> t
10:20:18 <tomphreek> levi: https://www.haskell.org/haskellwiki/Diagrams? Thanks, I ll look into that
10:20:43 <ClaudiusMaximus> is there any trick to derive newtype instances for classes with associated type synonyms?  or should i just write the instance (it has 13 methods that will just be boilerplate newtype re-wrapping)
10:20:56 <levi> tomphreek: As for updates and composing small bits of state into the whole application's state, functional constructs like zippers and lenses are very helpful in that area.
10:21:05 <ClaudiusMaximus> GeneralizedNewtypeDeriving and StandaloneDeriving don't work
10:21:07 <josephle> platz: yeah, I think one of the ideas of OO is that some state is local, which seems to be true in most GUI models
10:21:22 <funfunctor> quchen: this is very nice and clean, libbladerf does not have a clean error_t though
10:21:32 <josephle> and message-passing is a relatively painless way of achieving local state in a functional language
10:21:35 <eazar001> hmmm if i'm getting "Unrecognized field executable-profiling", then what do i replace that with in my cabal config?
10:22:05 <StoneToad> josephle: what, OO isn't about having cast statements all over your code to convert from base to subclasses?
10:22:16 <quchen> funfunctor: In my library, the C error type is a simple enum. My C'lcb_error_t is a `type` synonym for Int I think.
10:22:58 <quchen> type C'lcb_error_t = CUInt
10:23:02 <josephle> StoneToad: since I advocate composition over inheritance in OO language wars, I think you can figure out my stance :P
10:23:03 <platz> josephle: I have some wild hope that Machines/Autos w/ arrows might be able to model some of the local state stuff nicely, ever since I read http://blog.jle.im/entry/auto-as-category-applicative-arrow-intro-to-machines#locally-stateful-composition
10:23:11 <platz> not sure how tractable that turns out to be
10:23:42 <dcoutts> eazar001: that's the right name, perhaps you've got some other syntactic error
10:23:54 <StoneToad> josephle: indeed, at least the system I was using had a way to look up actions by name on the base class, so I didn't have to cast too much, but writing stuff in C# is so brutal after doing haskell
10:24:07 <StoneToad> the type inference is SOOOO nice
10:24:23 <StoneToad> even when you have to give annotations for things it can't guess properly, you dont' have to repeat them everywhere
10:24:50 <shachaf> monochrom: https://ghc.haskell.org/trac/ghc/ticket/9858#comment:22 reminded me of something you said once.
10:25:09 <platz> i guess part of the thing with machines/autos is that it's not necessarily easy to get at the state inside.. arguably perhaps it should not be available
10:25:31 <StoneToad> josephle: incase you're wondering specifically, I was writing some scripts for Space Engineers, which decided that since the game engine was in C#, they'd make the in-game scripting in C#...
10:25:56 <eazar001> dcoutts: have you tried installing the new cabal-install?
10:26:02 <StoneToad> and... they're totally in the inheritance camp
10:26:47 <eazar001> dcoutts: all i have to do is uncommented this line ---> -- executable-profiling: False
10:27:09 <josephle> StoneToad: my condolences
10:27:18 <eazar001> dcoutts: https://github.com/haskell/cabal/issues/2313
10:27:27 <eazar001> hmmmm okay, i guess i'm not the only one having this problem
10:27:45 <ClaudiusMaximus> nevermind, just remembered my class has default implementations for almost everything, so i only need to define 5 things
10:28:46 <eazar001> so it shoould be : executable-profiling : True
10:28:56 <eazar001> errr i mean :
10:29:02 <eazar001> so it shoould be : profiling : True
10:29:15 <StoneToad> does it care about the whitespace?
10:29:19 <johnw> an extension I'd like: auto-derive every instance that can be auto-derived, for every type class in scope
10:29:40 <StoneToad> johnw: oh gads, no please, at the very least require a list of the ones you want
10:29:47 <johnw> sometimes when you have 100 types, making sure to plumb "Eq, Show, Data, Typeable" everywhere is a massive pain
10:29:53 <johnw> ok, I'll accept a list
10:29:57 <dcoutts> eazar001: ahh ok, so there was a specific bug about that field and breaking backwards compat
10:31:18 <dcoutts> johnw: I'd be happy if we could just use deriving for more of them, rather than having to use standalone deriving
10:31:34 <dcoutts> or for the ones that can be made instances trivially by default methods
10:31:41 <dcoutts> e.g. the generic ones
10:31:53 <johnw> are there things which cannot be Typeable?
10:33:50 <geekosaur> I think so but the extensions you need to create them keep changing. first it was polymorphics, most recently i think it was polykinds>?
10:34:04 <johnw> ah
10:34:20 <johnw> there's AutoDeriveTypeable now in 7.10 or something, isn't there?
10:34:31 * hackagebot matlab 0.2.0.0 - Matlab bindings and interface  http://hackage.haskell.org/package/matlab-0.2.0.0 (bmsherman)
10:41:01 <quchen> johnw: Yes
10:43:17 <johnw> yay
10:44:44 <Archi> ey guys how can i clear macros defined whit :def
10:44:52 <Archi> in ghci
10:47:37 <johnw> Archi: is there an :undef?
10:48:26 <Archi> im gonna se then
10:49:59 <quchen> johnw: Your git-monitor Github link is broken
10:50:06 <quchen> https://github.com/jwiegley/git-monitor ← 404
10:50:20 <johnw> thanks
10:50:39 <johnw> correction sent
10:51:03 <johnw> huh, haskell-cafe rejected me
10:51:24 <johnw> and then looks like it posted it anyway; did it?
10:51:50 <quchen> I don't read haskell-cafe
10:52:01 <quchen> No message on the other lists either though
10:52:11 <johnw> where did you see it?
10:52:21 <clrnd> what's git-monitor for?
10:52:35 <johnw> it monitors your git working tree and snapshots changes to a hidden branch every minute
10:52:40 <johnw> but it does it *really* efficiently
10:52:56 <clrnd> it makes commits?
10:52:58 <quchen> How's it different from manually committing in that respect?
10:53:06 <johnw> git-commit does a lot of work each time
10:53:07 <clrnd> to that branch, meaning 'how do I get that later?'
10:53:15 <johnw> I'm directly constructing Git objects in memory and writing them straight to disk
10:53:19 <Archi> i use :undef but did not worked  i just want to have clean the ghci inicial prompt
10:53:26 <johnw> and I update the Git object iteratively
10:53:27 <clrnd> so I can use them as commits then
10:53:28 <quchen> I think glasgow-haskell-users@ is where I received the mail. Could also be haskell@ though.
10:53:35 <johnw> clrnd: yes
10:53:39 <clrnd> sounds nice
10:53:42 <johnw> refs/snapshots/refs/heads/<branch>
10:53:53 <johnw> so the IOPS and disk bandwidth requirements are minimal
10:54:05 <quchen> johnw: What work does normal commit do?
10:54:06 <johnw> my main objective was "continual backup at little to no battery cost"
10:54:18 <clrnd> you messed up badly a 'git checkout .' and decided it would never happen again, huh?
10:54:19 <johnw> normal commit must reconstruct the whole Git tree object
10:54:29 <johnw> which if you have thousands of files can be expensive
10:54:35 <johnw> clrnd: hehe
10:54:46 <johnw> git-monitor maintains a separate snapshot for each branch, and notices when you change branches too
10:54:53 * quchen doesn't understand what git checkout . does
10:55:02 <johnw> quchen: wipes out your local changes
10:55:20 <quchen> like reset --hard?
10:55:31 <johnw> well, that would be checkout -f
10:55:39 <clrnd> checks out files from the tree, so your local uncommited or unstaged files get forgotten
10:55:39 <johnw> I'm not sure what just checkout . does
10:56:10 <clrnd> it checkouts your current dir, so if you at the root, everything
10:56:11 <johnw> anyway, git-monitor was originally written to showcase what kind of Git tooling you can build with gitlib that you can't do as well with shell scripts
10:58:10 <johnw> https://www.dropbox.com/s/9wa0t8u1h9ezldm/Screenshot%202015-01-22%2012.56.59.png?dl=0
10:58:15 <johnw> that's an example of what it looks like while running on my system
10:58:42 <johnw> (and yes, I am modifying all those files that often)
10:59:08 <clrnd> really nice
11:00:25 <quchen> Furious johnw checkouting
11:01:37 <augur> ok, question time
11:02:41 <trap_exit> so is there something like numHaskell (i.e. numPy) ?
11:03:06 <augur> suppose im building a cloud service with haskell as the backend, and users can set up various components as "theirs"
11:03:24 <Archi> i use :def and it cames whit no macros defined but i still see macros defined when i do ghci in the terminal
11:03:39 <Archi> how i clean  that ?
11:03:41 <augur> that is to say, they can add custom configs of stuff that the haskell bits use
11:03:41 <trap_exit> is there an IO Either monad ?
11:03:49 <trap_exit> the idea being ... I do a series of steps, each of which is an IO () ....
11:03:57 <trap_exit> we.. each of which is an IO Either ....
11:04:04 <trap_exit> and if any of them fails, I stop, but if they all scuceed, I go to the next once
11:04:31 <unknownloner> wouldnt that be like Maybe (IO ())
11:04:58 <unknownloner> or Either Something (IO ())
11:04:59 <augur> how would i set it up so that haskell can do this sort of stuff? would i maybe pipe the user's data into haskell for processing, but not keep it in haskell?
11:05:04 <quchen> There is ExceptT e m a = m (Either e a)
11:05:12 <augur> actually i bet jonsterling knows, he does cloud shit
11:05:22 <augur> jonsterling: i summon thee!
11:05:23 <quchen> Or MaybeT m a
11:05:39 <jle`> anyone here a mod for the haskell subreddit
11:05:44 <jle`> i think my post got caught in the spam filter v.v
11:05:50 <jle`> it's not spam tho i promise
11:06:21 <quchen> You can message the admins via reddit
11:06:27 <quchen> I know because it happened to me as well :-þ
11:06:29 <jle`> thanks :)
11:06:51 <bergey`> trap_exit: I'm not aware of a clear set of best-choice packages.  There are a couple of choices for lapack bindings; I haven't used any of them enough to recommend one.
11:06:53 <quchen> ctrl+f "message the moderators", jle`
11:07:56 <bergey`> trap_exit: dataframe options include http://hackage.haskell.org/package/tables and https://github.com/acowley/Frames ; again, things I want to try, not things I've used.
11:09:22 <jle`> ty quchen. found it :)
11:19:33 * hackagebot direct-sqlite 2.3.15 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  http://hackage.haskell.org/package/direct-sqlite-2.3.15 (JanneHellsten)
11:20:37 <Archi> no macros defined but i still have this output in ghci
11:20:41 <Archi> GHCi, version 7.8.3: http://www.haskell.org/ghc/  :? for help Loading package ghc-prim ... linking ... done. Loading package integer-gmp ... linking ... done. Loading package base ... linking ... done. macro 'hoogle' is already defined macro 'hoogle' is already defined macro 'doc' is already defined macro 'hoogle' is already defined macro '\x' is not defined macro '\x' is not defined
11:21:20 <Archi> i want to clean the part below loading package base
11:22:02 <Archi> how is that ?
11:22:34 <Archi> i was thinking in put lambda bot in ghci also
11:23:33 <jle`> Archi: what is in your ~/.ghci ?
11:24:26 <Archi> jle: how i get to that folder ?
11:24:44 <jle`> Archi: what OS are you on?
11:24:56 <jle`> oh, that's not a folder, it's a (text) file
11:24:56 <Archi> jle: linux mint
11:24:58 <jle`> in your home directory
11:25:04 <Archi> ooooh
11:25:31 <jle`> cat ~/.ghci
11:25:31 <Archi> jle: thanks men xD
11:25:42 <toblerone> Why doesn't the randomRs function in System.Random return a new generator?
11:25:57 <Archi> jle: problem solved
11:26:02 <jle`> toblerone: the generator is used to create the next item in the list
11:26:11 <jle`> lazily
11:26:12 <toblerone> ie: (a,a) -> g -> ([a],g)
11:26:20 <toblerone> ah
11:26:31 <glguy> toblerone: If you want you can split the generator before you give it to randomRs
11:26:34 <jle`> the list goes on forever, so you don't know the final `g` until the end of the infinte list
11:26:48 <jle`> because you need to go through all the items to get the final `g` at the end :)
11:27:21 <toblerone> hmm, okay so if I wanted a finite number and a new generator i would have implement chain calls to random myself
11:27:24 <toblerone> ok
11:27:40 <toblerone> glguy
11:27:52 <toblerone> i didn't see your message, that sounds like a good choice
11:27:53 <toblerone> thanks
11:27:55 <jle`> you can also use replicateM in State
11:28:35 <toblerone> yeah. its not a big deal, I just never noticed that it didn't return a new generator before
11:29:04 <toblerone> but it makes sense that it doesnt, would be nice if there were a function for the other case though
11:29:41 <jle`> > ([0.6718855184010674,0.8281647235427522,0.48742478736362627,0.34153956688525555,0.18934264950661284],1772499918 2118231989)
11:29:42 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> t))
11:29:42 <lambdabot>    arising from the ambiguity check for ‘e_1067188551840106740828164723542752...
11:29:42 <lambdabot>  from the context (GHC.Num.Num (a -> t),
11:29:43 <jle`> oops
11:29:53 <joelteon> > 123 123
11:29:53 <jle`> > runState (replicateM 5 (state random)) (mkStdGen 100) :: ([Double], StdGen)
11:29:54 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> t))
11:29:54 <lambdabot>    arising from the ambiguity check for ‘e_1123123’
11:29:54 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
11:29:55 <lambdabot>  ([0.6718855184010674,0.8281647235427522,0.48742478736362627,0.34153956688525...
11:30:11 <jle`> > runState (replicateM 5 (state randomR (0::Int, 9::Int))) (mkStdGen 100)
11:30:12 <lambdabot>  Couldn't match type ‘g0 -> (a0, g0)’
11:30:12 <lambdabot>                with ‘(Control.Monad.Trans.State.Lazy.StateT
11:30:12 <lambdabot>                         System.Random.StdGen Data.Functor.Identity.Identity a,
11:30:30 <jle`> > runState (replicateM 5 (state (randomR (0::Int, 9::Int)))) (mkStdGen 100)
11:30:31 <lambdabot>  ([3,0,6,0,0],942794516 652912057)
11:30:39 <jle`> > runState (replicateM 10 (state (randomR (0::Int, 9::Int)))) (mkStdGen 100)
11:30:41 <lambdabot>  ([3,0,6,0,0,1,7,4,4,1],1625107866 1336516156)
11:32:11 <jle`> it's a little less overhead if you stay in State for an extended amount of time
11:32:13 <ij> Prelude provides the same fold as Data.Foldable?
11:32:15 <jle`> and you have a lot of random operations to chain
11:32:23 <danilo2_> Hello! Could somebody just fast look at the 3-line code and tell me why the fdc2 function compiles well while fdc1 gives compilation error? They are supposed to do the same I though: http://lpaste.net/119012
11:33:47 <toblerone> jle`: yea, makes sense. thanks : )
11:33:49 <danilo2_> but it works when I enable PolyKinds. Hmm where this comes from ?
11:36:07 <mpickering> I think you might need to specify the kind of Nothing?
11:36:23 <mpickering> I had something similar today actually
11:36:31 <danilo2_> mpickering: hmm, but Nothing is a dataKind
11:37:01 <danilo2_> mpickering: you are right, but ekhmm, why?
11:37:13 <mpickering> In fact I had exactly the same and couldn't work it out either..
11:39:18 <hexagoxel> can somebody explain why ghc gives a warning when compiling: https://gist.github.com/lspitzner/a721d3b1e50b87ecf6cf
11:40:15 <jle`> what is the warning?
11:40:33 <mpickering> because the coverage checking for GADTs is not very good
11:40:38 <mpickering> incomplete pattern match I think?
11:42:03 <erisco> isn't it incomplete regardless?
11:43:09 <mpickering> no
11:44:39 <hexagoxel> mpickering: ah, so it is a known shortcoming; good to know.
11:45:10 * mjrosenb guesses if he wants to have a variable of type IO Int, whose value only depends on getArgs, and not parse it every time you execute it, I need to make it a Ref (or is it an IO Ref?), and store it early on (or at its first use)
11:45:37 <erisco> :t getArgs
11:45:38 <lambdabot> Not in scope: ‘getArgs’
11:45:54 <erisco> mpickering, suppose so, I was thinking of something else
11:46:06 <toblerone> also, whats an idiomatic way to map over nested functors? Is there any way to apply a function over the lowest level of an artibrarily nested functor?
11:46:09 <erisco> I was wondering how bottom fit into it
11:46:19 <jle`> hexagoxel: you can just use a `let` binding
11:46:28 <jle`> or pass it on as a parameter
11:46:42 <jle`> IORefs usually are for things you plan on mutating
11:46:46 <mjrosenb> :t System.getArgs
11:46:47 <lambdabot> Not in scope: ‘System.getArgs’
11:46:58 <mjrosenb> getArgs :: IO [String]Source
11:47:01 <mjrosenb> Computation getArgs returns a list of the program's command line arguments (not including the program name).
11:47:27 <jle`> do args <- getArgs; let thing = f args; ...
11:47:38 <jle`> and then from now on you can use `thing` without re-parsing
11:47:47 <jle`> and pass it into functions that need it
11:47:52 <mjrosenb> jle`: right, but I want this to be global
11:48:03 <mjrosenb> and not have to pass it through 5 layers of calls.
11:48:06 <jle`> IORefs won't help you there, you'd need to pass the ref
11:48:21 <erisco> heh, that problem
11:48:22 <mjrosenb> I can't have a global IORef?
11:48:29 <erisco> well, if it is that problem, a state monad might be of interest
11:48:37 <jle`> you can, but it's rarely the right choice :)
11:48:39 <jle`> it's a secret.
11:48:50 <jle`> if you are adverse to passing parameters, you can use Reader
11:48:59 <erisco> or a reader, a weaker version
11:49:12 <mjrosenb> ugh, this code does *not* need another monad transformer.
11:49:31 <erisco> I bet there is a monad transformer to fix your monad transformers
11:49:41 <jle`> passing parameters isn't all too bad :)  i usually prefer parameter passing over Reader
11:49:49 <jle`> it helps with understanding what your function actually needs
11:50:04 <jle`> anyways if you really know why you shouldn't do it, then there is a solution for a global variable accessible in IO
11:50:41 <jle`> keep in mind that global mutable variables are considered a bad idea even by imperative programming standards
11:50:41 <mjrosenb> jle`: why should I not do it?
11:51:19 * mjrosenb concurs, but I'm going to treat it like write-once value
11:51:31 <mjrosenb> and I can probably even write a write-once wrapper around it.
11:51:46 <erisco> well ask yourself how you will test your program then
11:51:49 <jle`> https://www.haskell.org/haskellwiki/Top_level_mutable_state
11:52:03 <jle`> don't tell anyone i gave that to you, i'm probably going to get in trouble :)
11:52:10 <mjrosenb> erisco: this is /for/ testing...
11:52:23 <erisco> hm
11:52:34 <jle`> if it's just for testing/debugging then i guess that'd be ok
11:52:44 <vanila> can we see the code?
11:52:46 <mjrosenb> not like rigirous testing
11:52:50 <erisco> well if you can view it as a form of deferred compilation, I suppose, or late compiler flags or something
11:52:54 <erisco> maybe in that context it works out alright
11:52:59 <jle`> honestly passing through parameters isn't all that bad
11:53:08 <jle`> and Reader isn't too bad either
11:54:06 * mjrosenb wants to add in a --verbose and a --dryrun flag, then replace all FS commands by a version that grabs either the real command, or a command that prints its arguments, or the sequence of these tw, depending on what is seen in getArtgs
11:54:12 <vanila> if you use unsafePerformIO you are doing somehing wrong
11:54:28 <mjrosenb> vanila: I wan't planning on using unsafePerfomIO
11:54:35 * hackagebot hindent 4.3.0 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.3.0 (ChrisDone)
11:54:49 <erisco> if you use unsafeInterleaveIO you probably wanted pipes :)
11:55:45 * mjrosenb was thinging of readFileWrapper :: String -> IO String; readFileWrapper file = do { f <- getReadFile; f file }
11:56:25 <mjrosenb> where getReadFile basically reads from a global IORef that was written to once at the start of main
11:56:28 <mjrosenb> *thinking
11:56:42 <vanila> how do you mkae this global IORef
11:57:33 <erisco> you have to be invited into the inner circle of Haskell dark magic practitioners and only then will the secret be revealed to you
11:57:44 <Lutin`> To me this seems like a good place for Reader
11:57:59 <mjrosenb> oh great, newIORef is *in* IO
11:58:22 <Lutin`> or pass it in
11:58:31 <vanila> that's a really good idea Lutin`
11:58:44 <Lutin`> like jle` said
11:59:24 <Lutin`> Alternatively and possibly more hacky you could have something of the type `Verbosity -> IO (String -> IO String)`
11:59:42 <Lutin`> Or minus the verbosity
11:59:55 <Lutin`> but I don't see why you need to use an IORef for a simple option
12:00:36 <mjrosenb> Lutin`: how would I implement this?
12:00:45 <Xe> I'm thinking about learning haskell by making a simple "diary" program that keeps markdown inside a sqlite database and launches vim to edit entries. What is the haskell equivalent of calling popen and having the child process temporarily take over STDIN/OUT like mutt or alpine do?
12:00:53 <vanila> if you show the code maybe we can hepl you do it in a good way
12:00:57 <vanila> its up to yo u
12:00:59 <Lutin`> ^
12:01:00 <mjrosenb> https://gist.github.com/2caef863e502f879070e
12:01:28 <mjrosenb> code^ (There are other modules used, but the interface is pretty minimal)
12:01:32 <Lutin`> putty why don't you have url detection :(
12:01:51 <mjrosenb> eww, putty :-p
12:02:06 <Lutin`> Well I'm stuck on windows atm
12:02:37 <Lutin`> And portable putty wfm
12:03:17 <Lutin`> mjrosenb: So where in this gist do you want to make a change
12:04:02 <levi> Xe: You'll probably want to have this link handy for GHC library documentation: https://downloads.haskell.org/~ghc/7.8-latest/docs/html/libraries/index.html
12:04:15 <Lutin`> Ah I see
12:04:20 <levi> Xe: Though you'll want to verify that your version of ghc matches.
12:04:29 <mjrosenb> Lutin`: line 108, renameFile, and line 98/99 doesDirectoryExist/createDirectory
12:04:31 <Xe> levi: yeah, this language is so different than anything I've worked with before
12:04:35 * hackagebot descriptive 0.3.1 - Self-describing consumers/parsers; forms, cmd-line args, JSON, etc.  http://hackage.haskell.org/package/descriptive-0.3.1 (ChrisDone)
12:04:45 <Xe> it's kinda breaking my brain in all sorts of ways I didn't know it needed breaking
12:06:07 <Lutin`> Xe: :s/break/fix/g
12:06:32 <Lutin`> ;)
12:06:32 <Xe> Lutin`: :P
12:06:32 <levi> Xe: Yes, it's a lot to learn! You might want to start with something a little less library-oriented.
12:06:42 <mjrosenb> ==levi
12:06:45 <Xe> levi: I'm one of those people that learns by doing
12:07:09 <mjrosenb> Xe: you can do plenty without making a small shim around a large library.
12:07:15 <levi> Oh, yes, you should definitely learn by doing. But maybe concentrate on some of the less I/O-oriented aspects of your project first.
12:08:37 <mjrosenb> Lutin`: also, any style changes are welcome :-p
12:08:56 <vanila> its hard to do anything with this code since it does not compile
12:09:02 <toblerone> If I had a type "Foo a" how would I declare instances of Foldable Foo while ensuring that 'a' is also Foldable
12:09:25 <mjrosenb> vanila: do you want the whole project?
12:09:26 <Xe> levi: what?
12:09:35 * hackagebot multistate 0.3.0.0 - like mtl's ReaderT/WriterT/StateT, but more than one contained  value/type.  http://hackage.haskell.org/package/multistate-0.3.0.0 (lspitzner)
12:09:53 <vanila> that or a stubbed out version of the parts needed to make this typecheck
12:10:08 <mjrosenb> vanila: that sounds like too much work.
12:10:37 <dino-_> Guys, I'm trying to use parsec (3.1.8 is installed) on Data.Text and am getting type errors when I try to use a parser comprised of `many anyChar`
12:11:05 <dino-_> Couldn't match type ‘[Char]’ with ‘T.Text’
12:11:35 <levi> Xe: Well, I just mean that although there are some nice libraries for interacting with databases and parsing markdown and communicating with processes, as a beginner you might find yourself having a hard time figuring out how to get them to play together the way you want.
12:11:42 <dino-_> I also tried `many anyToken` and am NOT importing any Text.ParserCombinators.*.Char, only these two imports: Text.Parsec, Text.Parsec.Text
12:11:52 <Lutin`> toblerone: This might help http://stackoverflow.com/questions/12497542/type-parameters-constraints-for-instances-of-typeclasses-with-kind
12:12:03 <dino-_> Is there some trick to getting it happy with Data.Text?
12:13:01 <int-e> dino-: are you using anyChar from  Text.Parsec.Char?
12:13:29 <int-e> hmm, that shouldn't matter; more relevantly, which version of Parsec are you using?
12:13:50 <dino-> int-e: Not sure, I'm definitely not importing that
12:13:58 <geekosaur> "(3.1.8 is installed)"
12:13:59 <dino-> Well, not explicitly
12:14:06 <levi> Xe: If you're really set on it, don't let me discourage you from it, though. Your idea is definitely something that can be done.
12:14:29 <mjrosenb> vanila: http://www.club.cc.cmu.edu/~mjrosenb/MusicRename.tar.bz2
12:14:48 <indiagreen> int-e: well, it won't work anyway since “many” explicitly returns a list and dino-_ probably wants it to return a Text
12:15:00 <dino-> int-e: This is in a bigger block of code, I will isolate a small set that reproduces this for a paste.
12:15:17 <int-e> indiagreen: ah good point
12:15:20 <mjrosenb> vanila: locally, it compiles with ghc --make Test.hs
12:16:01 <indiagreen> dino-: if you want many to return a Text, you'll have to wrap it yourself with Data.Text.pack. It won't be very efficient, but it'll work
12:16:04 <levi> Xe: See this library for starting an external process: https://downloads.haskell.org/~ghc/7.8-latest/docs/html/libraries/process-1.2.0.0/System-Process.html
12:16:39 <dino-> indiagreen: Hm, trying not to unpack/pack because this is unicode
12:16:52 <dino-> Which is why I'm here in the first place not using regex
12:17:00 <indiagreen> so? String and Text are both Unicode
12:17:55 <toblerone> Lutin`: Hmm, okay so it seems like I might need to look into ConstrainKinds...? Here is a paste to clarify what I'm asking about for anyone else to take a look at: http://lpaste.net/3377106551184556032
12:17:58 <indiagreen> moreover, there are Unicode-aware regexes in text-icu (but you should use parser combinators anyway, they are nicer)
12:18:21 <Lutin`> toblerone: I think it would be better to use GADTS to constrain Foo
12:18:23 <dino-> String is lossy for the data I'm using
12:18:33 <int-e> dino-: I don't think you can avoid this in Parsec; the main abstraction is that Stream class, which provides an 'uncons' function; essentially, the input is getting treated as a list of characters anyway.
12:18:33 <toblerone> ok, ill take a look at that
12:18:36 <dino-> And horribly inefficient anyway
12:18:40 <int-e> dino-: how is it lossy?
12:19:13 <dino-> int-e: Characters get mangled that aren't utf8
12:19:32 <dino-> If I'm describing that right.
12:19:35 <int-e> so it's *not* utf-8.
12:20:26 <dino-> int-e: But wait, can't avoid what in Parsec?
12:20:36 <dino-> It can't work with Data.Text directly as the steam?
12:20:40 <vanila> mjrosenb, ah great! So it is just that you don't want to pass "files" explicitly in various functions
12:20:42 <int-e> dino-: treating intermediate results as lists.
12:21:25 <int-e> dino-: but in any case if your input is not unicode/utf-8 then you're likely better off with ByteString than Text.
12:21:38 <mhl> Hi. I'm new to cabal and concept of sanboxing. If I do cabal install while in sandbox, will this install given package only in this sandbox, right?
12:21:58 <int-e> dino-: Well, technically you don't have to produce a list. But the parser will process input by consuming single characters or bytes.
12:22:14 <int-e> dino-: via the 'uncons' function from that Stream class.
12:22:22 <Lutin`> toblerone: Maybe something like this http://lpaste.net/3377106551184556032
12:22:29 <Lutin`> Woops..edited instead of annotated
12:22:30 <indiagreen> dino-: if you specified your requirements better (i.e. what exactly are you trying to do, why do you have data which isn't UTF-8 and what do you want to do with it, etc.), we'd be able to help you better
12:23:07 <dino-> The data is coming from JSON parsed by Aeson and also some web scraping
12:23:09 <hexagoxel> mhl: yes. note that "in sandbox" ~ "there is sandbox in current directory"
12:23:39 <dino-> I'll come up with a paste soon
12:25:39 <Hafydd> > sort ("uncons" ++ "ir") == sort "unicorns"
12:25:40 <lambdabot>  True
12:25:50 <int-e> dino-: (unless you invest extra work; you could certainly recall the current text (using getInput), then find a length of whatever you wanted to parse, then cut that part directly from the input.
12:26:29 <dino-> Or maybe ByteString
12:27:41 <mjrosenb> vanila: actually, that one, I'm pretty ok passing around.
12:28:01 <mjrosenb> vanila: I want to add new functionality, namely what I stated before about --verbose and --dryrun.
12:32:25 <toblerone> Lutin`: But would GADTs allow for Foo values that aren't foldable? I guess that wouldn't make sense huh?
12:32:54 <toblerone> ie: Foo Int
12:33:27 <Lutin`> toblerone: Well the way foldable is defined means it has to be agnostic of the element type
12:34:14 <Lutin`> Though that can be annoying if you only want Foo to be foldable sometimes
12:35:25 <Lutin`> alternatively question if Foo makes sense when a isn't foldable
12:40:23 <toblerone> Yeah, i'm looking for a way for Foo to be Foldable only when its "contents" are foldable as well. Not sure that makes sense though when I think about it, ha
12:40:40 <toblerone> is there any other types that behave similarly?
12:40:43 <toblerone> are there : )
12:41:51 <Lutin`> I can't think of any nested Foldable types
12:42:11 <Lutin`> But I'm probably not the one to ask about that
12:42:55 <toblerone> Well I mean, in the general sense. I can't think of any case where the parent type sometimes shares instances of the child type. For instance, I don't think a Foo that is sometimes a Num makes much sense...
12:43:39 <toblerone> A newtype would probably be the answer, right?
12:43:43 <glguy> well, a simple example is   instance Integral a => Num (Ratio a)
12:43:56 <glguy> (and Num is a transitive superclass of Integral)
12:44:23 <glguy> Your foldable example would be something like:     instance Foldable f => Foldable (T f), which would be fine
12:44:31 <glguy> for some sensible T
12:44:58 <shachaf> glguy: Are you sure? It sounds like toblerone wants a constraint on 'a', i.e. with T :: * -> *
12:45:27 <shachaf> I guess I should ask rather than talking about what it sounds like.
12:45:37 <shachaf> lens generalizes the idea of Foldable by making it explicit and first-class. That might be able to express what you're after.
12:45:50 <shachaf> glguy: Come to think of it, what I said didn't make much sense.
12:46:26 <glguy> Your interpretation makes sense to me, a bit like wanting to constraint the types such that Set could be a Monad instance
12:46:45 <toblerone> shachaf: Er, I think thats what I'm saying. I'm really just exploring the type system a bit and was wondering if you could implement a type that has class instances depending on a constraint.
12:47:09 <lpaste> dino- pasted “Parsec with Data.Text” at http://lpaste.net/119019
12:48:21 <dino-> And of course if you change line 11 to p :: String -> Either ParseError String it type checks
12:48:39 <toblerone> glguy: So taking your Ratio example, could you have a Ratio Char value?
12:48:54 <toblerone> that wouldnt have Num instances?
12:49:18 <glguy> You can have a Ratio Char, but it won't be an instance of Num (without additional, nonesensical, instances)
12:50:02 <dino-> This is a simplification of my problem, which is I want the digits plus ", " removed from the beginning of a string and want the rest back. But the type errors are the same for that code.
12:50:50 <toblerone> yeah, of course you can. I'm not sure what I was thinking. The difference with Foldable is because of its kind
12:51:53 <toblerone> So is it possible for a type to only sometimes have Foldable instances?
12:52:56 <glguy> Like this? instance (Foldable f, Foldable g) => Foldable (Product f g)
12:54:55 <lpaste> int-e pasted “sketching bytestring primitives for parsec” at http://lpaste.net/119020
12:55:04 <toblerone> yeah, but you can't do: "instance (Foldable f) => Foldable (Foo f)"
12:55:28 <int-e> dino-: that paste may give you some ideas. But manyTill is actually a bit tricky.
12:55:57 <Lutin`> dino-: oh
12:56:16 <glguy> toblerone: Sure you can
12:56:18 <Lutin`> wait nevermind
12:56:26 <toblerone> you can?
12:56:27 <glguy> toblerone: But that might not mean what you're thinking
12:56:27 <toblerone> how?
12:56:35 <Lutin`> toblerone: You can, but that would mean Foo is of kind * -> * -> *
12:56:38 <glguy> Foo :: (* -> *) -> * -> *
12:56:44 <Lutin`> err
12:56:48 <Lutin`> yeah what glguy said
12:56:57 <toblerone> yeah right. i would need another parameter
12:56:59 <int-e> is there a parser combinator library that's designed around Data.ByteString or Data.Text (chunk based) rather than lists (character based)?
12:57:40 <Lutin`> There's attoparsec
12:58:04 <dino-> int-e: Thank you, I could go with BS yeah
12:58:10 <kadoban> Even parsec can work with Data.ByteString, can't it?
12:58:34 <ij> I've a WD monadic action that I've just made, now I need to return it. But before returning it, I also want to chain some other monadic actions. I saw some cool trickery with Const from C.Applicative, would this be applicable here?
12:59:25 <int-e> Lutin`: thanks. https://hackage.haskell.org/package/attoparsec-0.12.1.2/docs/Data-Attoparsec-Text.html#g:11 looks good, actually.
13:00:09 <int-e> dino-: the point isn't so much ByteString vs. Text, the point is having combinators that do not treat the input as sequences of individual characters.
13:00:41 <indiagreen> int-e: attoparsec won't give you some nice things like e.g. telling you error positions; if you want that, use picoparsec instead
13:01:07 <Lutin`> oh that's new
13:01:58 <indiagreen> Lutin`: picoparsec is a fork of attoparsec with more input types (at the cost of performance, but it still should be better than parsec)
13:02:54 <orzo> is there a newbie friendly channel for dependent types programming?
13:03:21 <dino-> Fantastic, I should be able to get there with one of these ideas. Thank you
13:04:38 * hackagebot shakespeare 2.0.4 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-2.0.4 (MichaelSnoyman)
13:05:29 <orzo> I notice that in haskell with singletons, sometimes a proposition is a type class and sometimes a proposition is a type family that maps to kind Bool.  Is it arbitrary which i use?
13:17:00 <jophish> Ptr () or Ptr Void for void pointers?
13:17:12 <Peaker> C's "void" is really more like ()
13:17:16 <Peaker> and less like "Void"
13:17:58 <jophish> I'm not so convinced, void not being able to be dereferenced is akin to it not being inhabited
13:18:24 <jophish> Ptr () is more like a pointer to an empty struct
13:18:43 <Peaker> in C: void f() { .. }   f returns (), not Void.   Also:   void * is convertible to any other pointer type.
13:19:02 <Peaker> (well, any other data pointer type)
13:19:34 <Enigmagic> i use `Ptr ()` as well..
13:19:45 <jophish> Peaker: the returning () is a good argument
13:26:42 <Guest21847> Anybody familiar with the image magick ffi?
13:27:08 <eyebloom> Are their standard lift functions for arrows?
13:31:18 <johnw> eyebloom: how do you mean?
13:31:54 <Guest21847> eyebloom: Arrows are an instance of monad, so you've got the liftM family?
13:32:20 <Peaker> Guest21847: ? Only some
13:32:49 <geekosaur> any monad can be wrapped into an arrow, not all arrows are monads
13:33:20 <jackhill> win 21
13:33:26 <Guest21847> Peaker: geekosaur: oh right, fair point
13:34:18 <mjrosenb> what is a good name for \ first second arg -> do {first arg; second arg}?
13:34:29 <eyebloom> In the Hughes paper he defines standard lift operations for arrows but they aren’t in Control.Arrow
13:35:14 <eyebloom> http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf
13:35:26 <Peaker> mjrosenb: as in something like:  Applicative f => (a->f ()) -> (a->f ()) -> a -> f ()  ?
13:35:52 <mjrosenb> Peaker: is IO Applicative?
13:35:53 <Peaker> mjrosenb: mappend, if you have the right Monoid instance for "f ()" :)
13:36:01 <Peaker> mjrosenb: yeah, all "proper" Monads are Applicatives
13:36:09 <Peaker> (and soon, with AMP, all Monads will be Applicatives)
13:36:10 <shachaf> :t liftA2 (*>)
13:36:11 <lambdabot> (Applicative f1, Applicative f) => f (f1 a) -> f (f1 b) -> f (f1 b)
13:36:47 <mjrosenb> the type fo that function should be Monad m => (a -> IO ()) -> (a -> IO ()) -> a -> IO ()
13:37:47 <foozer> hi
13:37:52 <Peaker> mjrosenb: you mean s/IO/m ?
13:37:53 <foozer> I've got a problem with pattern matching
13:38:03 <mjrosenb> Peaker: derp, yes.
13:38:04 <Peaker> mjrosenb: you only need the Applicative constraint, no need for a full blown Monad constraint
13:38:16 <foozer> say, I've got the following data type :    data Foo = Bar Int
13:38:21 <foozer> I can match on Bar 0
13:38:29 <foozer> But I can't match on anything else
13:38:29 <Peaker> mjrosenb: There exists:   mappend :: Monoid b => (a -> b) -> (a -> b) -> a -> b
13:38:43 <foozer> Ideally, I'd like to recurse over that number
13:38:52 <mjrosenb> I only intend to use it with IO, but I guess there is no point in constraining it to IO unnecessarialy.
13:38:55 <kaeluka> does anyone have an example for how to set up a hunit testsuite to run via `cabal test`?
13:39:08 <foozer> but when I match on "Bar n", ghc tells me that n is not in scope
13:39:16 <Peaker> mjrosenb: and there can exist a Monoid instance for all applicative instances like:  instance (Monoid a, Applicative f) => Monoid (f a)    note the above (a->b) is just the standard (a->) monoid instance for all applicatives (a->) happens to be the applicative here
13:39:19 <mjrosenb> foozer: can you paste some code that doesn't work, with the error message?
13:39:26 <foozer> ok, give me a second
13:39:41 <benzrf> :t liftA2 . liftA2
13:39:41 <mjrosenb> s/paste/pastebin/
13:39:42 <lambdabot> (Applicative f1, Applicative f) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
13:39:46 <benzrf> oh
13:39:49 <athan> What's a skolem type variable, and why can't I have it? :(
13:40:26 <Peaker> mjrosenb: anyway your function is also: (liftA2 . liftA2) mappend
13:40:34 <Peaker> @type (liftA2 . liftA2) mappend
13:40:35 <lambdabot> (Monoid c, Applicative f1, Applicative f) => f (f1 c) -> f (f1 c) -> f (f1 c)
13:40:44 <Peaker> mjrosenb: in your case: f = (a->), f1 = IO
13:40:55 <Peaker> mjrosenb: and c=()
13:42:49 <foozer> mjrosenb: here's a minimal example: http://lpaste.net/2134393304941330432
13:43:06 <foozer> I don't quite get why I can't match on the number abstractly
13:43:22 <shachaf> Peaker: There can, but there doesn't.
13:43:31 <benzrf> athan: google says it means a free type variable in a type when that type is being used with that variable in scope
13:43:35 <shachaf> Peaker: And anyway do { a; b } doesn't mappend their results.
13:43:46 <mjrosenb> Peaker:     No instance for (Monoid (IO ())) arising from a use of ‘mappend’
13:43:52 <benzrf> athan: in value terms... in the expression "x + 1", `x' is a free variable
13:44:01 <shachaf> (And there only can exist such an instance if you're willing to give up on a whole bunch of other instances, so as a practical answer to a question it doesn't seem very useful.)
13:44:02 <benzrf> athan: then you can use the expression in a context where x is in scope
13:44:03 <athan> O.O
13:44:07 <benzrf> athan: like let x = 3 in x + 1
13:44:09 <Peaker> shachaf: well, he wants it for (), so it may as well?
13:44:23 <athan> ahh wow
13:44:24 <athan> okay
13:44:31 <Peaker> shachaf: well, all Applicatives should define such an instance, IO should be a Monoid instance like that
13:44:31 <benzrf> athan: then if you zoom in on the "x + 1" part, x is "skolem" in the sense that it means for the type
13:44:31 <shachaf> What, you want an instance Monoid [()] that multiplies list lengths?
13:44:35 <athan> benzrf: So existential quantification lets us use free variables?
13:44:35 <Peaker> shachaf: as (->) a  is
13:44:35 <benzrf> [that might be slightly wrong]
13:44:38 <mjrosenb> foozer: that is not how pattern matching is supposed to work.
13:44:40 * hackagebot HaXml 1.25.3 - Utilities for manipulating XML documents  http://hackage.haskell.org/package/HaXml-1.25.3 (MalcolmWallace)
13:44:41 <athan> free type variables i mean
13:44:42 <benzrf> athan: im not sure what you mean
13:44:45 <barrucadu> foozer: You're not pattern matching there, you're checking equality
13:44:57 <athan> hmm
13:44:58 <Peaker> shachaf: well, I guess there can be exceptions :)
13:45:06 <athan> thanks benzrf, I'll poke around
13:45:16 <benzrf> athan: well i can tell you what caused the error
13:45:16 <Peaker> shachaf: [] has a special Monoid instance not derived from its Applicative nature
13:45:23 <mjrosenb> foozer: you want foo (Bar 0:xs) = print "good"\nfoo (Bar n:xs) = print "huh?"
13:45:27 <athan> I just keep running into this issue with existentially quantified types - I can't pattern match on them
13:45:29 <shachaf> It's an interesting instance and a newtype for it would probably be appropriate.
13:45:33 <Peaker> shachaf: but Applicatives without a Monoid instance would probably be more useful with the "default" one declared
13:45:36 <foozer> mjrosenb: thank you!
13:45:44 <benzrf> athan: no, your pattern matching is just restricted
13:45:49 <athan> for instance soemthing like `data Foo = forall x. Foo (Proxy x)` can't be pattern matched
13:45:53 <athan> hmm
13:45:57 <danilo2_> Hello! Is it somehow possible to create instance, which does notsatify the liberal coverage condition, but returns a "forall function" ? I mean something like: class Foo a b | a -> b where foo :: a -> b; instance Foo A (forall a. a->a) where foo _ = id ?
13:46:02 <Peaker> shachaf: yeah, but going via MonoidApplicative newtype when no Monoid existed in the first place is a bit annoying
13:46:04 <athan> benzrf: Yeah idk
13:46:04 <baden> Hello! Does anybody have experience with object mashalling, or pickling in Haskell? I'd like to generate a bunch of ADts from an XSD description and pickle these with HXT.
13:46:05 <mjrosenb> foozer: when you use |
13:46:06 <shachaf> But at any rate declaring an orphan instance like this almost certainly isn't the right answer to mjrosenb's question.
13:46:14 <benzrf> athan: the problem is that you're trying to use a type variable outside of the expression it's quantified in
13:46:25 <mjrosenb> foozer: it is a guard, which is just an expression that doesn't bind anything new, but can use anything in scope
13:46:26 <benzrf> athan: er, rather, you're writing an expression whose type would look like that
13:46:30 <mjrosenb> foozer: for example
13:46:44 <Peaker> shachaf: in an application (not a library), it's probably fine to declare an orphan  Monoid a => Monoid (IO a)  instance
13:46:56 <Peaker> shachaf: and I gave him the (liftA2.liftA2)mappend  one too :)
13:47:11 <mjrosenb> foo (Bar x:xs) | isEven x = print((show x) ++ " is Even")
13:47:21 <shachaf> If you're writing it like that, isn't "liftA2 (*>)" exactly an answer to the question he asked?
13:47:34 <Peaker> :t liftA2 (>>)
13:47:34 <lambdabot> (Applicative f, Monad m) => f (m a) -> f (m b) -> f (m b)
13:47:39 <athan> benzrf: That makes a lot of sense actually
13:47:41 <athan> hmm
13:47:46 <benzrf> athan: you're trying to do something that would leak a value whose type is existentially quantified outside of the scope in which its elimination binds a type for it
13:47:49 <Peaker> shachaf: it is, but using liftA2 (*>) recently burned me with a hard bug!
13:47:54 <benzrf> sorry i probably just misused terminology
13:48:08 <Peaker> shachaf: let me dig it up
13:48:15 <shachaf> I would say to just write it non-point-free.
13:48:22 <athan> benzrf: Never give up, never surrender
13:48:25 <mjrosenb> shachaf: possibly?
13:48:27 <Peaker> shachaf: https://github.com/luqui/graphics-drawingcombinators/blob/master/src/Graphics/DrawingCombinators.hs#L125
13:48:35 <mjrosenb> I didn't actally ask for it point free
13:48:41 <mjrosenb> I asked what I should call it.
13:48:43 <benzrf> athan: to be precise
13:48:46 <benzrf> athan: consider this:
13:48:53 <Lutin`> baden: I know of the cereal library
13:48:53 <shachaf> Well, "liftA2 (*>)" is a name.
13:48:56 <Peaker> shachaf: also note line 119. These applicative pure/liftA2's are used to go into multiple function parameters
13:48:59 <mjrosenb> because I wanted to say "sequence", or "then", if it is infix
13:49:07 <benzrf> data BasicallyInt = forall a. BI a (a -> Int)
13:49:12 <mjrosenb> shachaf: it isn't a very good one, since it isn't a symbol.
13:49:18 <mjrosenb> err, token?
13:49:19 <Peaker> shachaf: when I added another parameter, I was forced to add another "pure." in 119
13:49:22 <baden> lutin': I'll have a look at it
13:49:22 <Lutin`> baden: Oh HXT I see
13:49:28 <Peaker> shachaf: but the code in 125 compiled, with the wrong meaning!
13:49:34 <Lutin`> It has its own pickler
13:49:38 <benzrf> athan: BI is basically (exists a. (a, a -> Int)), except 'exists' isnt a keyword in haskell
13:49:46 <shachaf> You mentioned it.
13:49:46 <benzrf> athan: erm, BasicallyInt, not BI
13:49:57 <Peaker> shachaf: the type checker let me down!  Changing that to (liftA2.liftA2.liftA2) mappend made it safe again
13:49:58 <athan> Yeah, I'm with you
13:50:04 <benzrf> athan: now suppose you try to pattern match on its first field and reutrn that as the result
13:50:12 <benzrf> athan: basically fst
13:50:15 <baden> pickling with HXT works ok. i'm more worried about generating the ADTs from the XSD. And the picklers.
13:50:19 <Peaker> shachaf: well, doing it point-fully is a lot of annoying boilerplate and giving names to stuff that have no useful names
13:50:25 <benzrf> athan: the type would have to look something like "(exists a. (a, a -> Int)) -> a"
13:50:34 <athan> ahhh wow
13:50:34 <benzrf> athan: except that that uses "a" outside of the scope it's bound in
13:50:42 <athan> benzrf: Crap, wow
13:50:45 <athan> okay
13:51:22 <Lutin`> baden: Oh I see what you mean
13:51:25 <benzrf> athan: you /could/ make something like "(exists a. (a, a -> Int)) -> (exists b. b)"
13:51:43 <benzrf> athan: but a value of type "exists b. b" is beyond useless
13:52:04 <Peaker> I think mappend between the two () is nice, shows no data is being thrown away
13:53:14 <arjanb> Peaker: imho it shows that making functions instances of common type classes is a dubious idea
13:53:54 <Lutin`> baden: I'm not sure I understand your problem
13:53:55 <athan> crap
13:54:04 <athan> benzrf: Have you played around much with TypeLits?
13:54:20 <Lutin`> baden: You want to serialize the XmlTree?
13:54:39 <benzrf> athan: a lil
13:55:25 <Peaker> arjanb: I disagree... It facilitates the beautiful stuff conal does with TCM
13:55:47 <athan> benzrf: There's some reflection / reification functions for type level strings, the `someSymbolVal` is the useless one :\
13:55:53 <athan> erm
13:56:07 <baden> Lutin': yes, i want to deserialize the XmlTree to the appropriate ADT and serialize the ADT to an XmlTree. This can be done by implementing the typeclass XmlPickler.
13:56:09 <athan> ...the one I don't knwo how to use yet.
13:56:24 <shachaf> I also think mappend between the two () is nice.
13:56:25 <baden> Lutin': But with a lot of classes the implementation get tedious
13:56:31 <benzrf> :t someSymbolVal
13:56:31 <lambdabot> Not in scope: ‘someSymbolVal’
13:56:35 <benzrf> bwuh?
13:56:49 <shachaf> You get several interesting instances to go with with the Applicative-Monoid one.
13:57:09 <Peaker> arjanb: I'd say the "dubious" thing is the use of (*>) which throws away information. In my case, I wanted to throw away a (), instead, it threw away: IO ().  Instead, it is better to use operators that do not throw away information
13:57:22 <Lutin`> baden: Have you looked at the example use of pickle?
13:57:25 <baden> Lutin': With JAXB in java it is possible to generate the code from the XSD out of the box. I want to know how complicated this gets with haskell.
13:57:30 <Lutin`> Disclaimer: I've never used hxt
13:58:05 <baden> Lutin': yes I know how HXT pickling works
13:58:37 <glguy> Peaker: The "right" solution there is to make a newtype for Renderer with the correct instances rather than to spread those instances to each use site
13:58:57 <Lutin`> baden: Ah I see what you're saying
13:59:29 <Lutin`> You mean something like the annotations in jaxb?
14:00:35 <arjanb> Peaker: i agree using *> is bad in most cases, but it is the combination with a function instance that hides the bug
14:00:54 <Lutin`> baden: Sorry if I don't follow, just trying to help
14:01:16 <Peaker> glguy: well, the "Image" type there *is* the type with the attached instances
14:01:31 <Peaker> glguy: I changed Renderer itself, if it was newtype'd I'd get the same mistake uncaught
14:01:39 <baden> Lutin': I mean something like the jaxb class generator: http://docs.oracle.com/cd/B19306_01/appdev.102/b14252/adx_j_jaxb.htm#CHDJABBG
14:01:45 <Lutin`> baden: Have you looked at HaXml?
14:02:02 <glguy> Peaker: then the code wouldn't be as obfuscated and the issue might be more evident
14:02:09 <Peaker> arjanb: yes, but too many positive things fall from instantiating things that abide by the laws to throw that away because in combination with a dubious feature, it could cause trouble
14:02:25 <baden> lutin': The description in the link is quite bad. But it's really simple. Take the XSD, run it through JAXB and you have the java POJOs
14:02:40 <Peaker> glguy: The code would just be moved a few lines above to a: instance Monoid Renderer where ...
14:02:41 <arjanb> Peaker: also mere the possibility of function instances is one major causes of hard to read type errors with type classes
14:02:54 <Peaker> glguy: I don't see how that would change things much?
14:03:18 <Lutin`> baden: Ah yeah look at HaXml
14:03:28 <Lutin`> I don't see anything that would do it at compile time with TH
14:03:31 <baden> Lutin': i'll have a look at XaXml
14:03:45 <Peaker> arjanb: I don't think it's that common..
14:04:36 <baden> Lutin': Text.XML.HaXml.Schema.XSDTypeModel sounds promising. Thanks!
14:05:08 <Lutin`> baden: There are also DtdToHaskell executables that it builds
14:05:39 <Lutin`> And XsdToHaskell
14:06:46 <baden> Lutin': cool, thanks
14:07:01 <Lutin`> http://code.haskell.org/HaXml/HaXml.cabal
14:10:10 <bricked> can you let a data in ghci?
14:10:18 <bricked> > 1+1
14:10:19 <lambdabot>  2
14:10:34 <bricked> > let data B = T | F in T
14:10:35 <lambdabot>  <hint>:1:5: parse error on input ‘data’
14:10:46 <geekosaur> lambdabot is not ghci
14:10:50 <baden> Lutin': i will generate the ADTs with HaXml and then derive the pickler with this method: http://engineering.silk.co/post/31921413529/haskell-data-types-and-xml
14:10:53 <c_wraith> @let data B = T | F
14:10:54 <bricked> well you cant in ghci either
14:10:55 <lambdabot>  Defined.
14:11:01 <geekosaur> if your ghci is recent enough then you can use data, I think
14:11:22 <bricked> what is recent enough?
14:11:34 <geekosaur> Prelude> data Mrfl = Goop | Meh
14:11:35 <geekosaur> Prelude>
14:11:55 <geekosaur> that was 7.8.3, I think data was added to ghci in 7.6?
14:14:26 <tasker> Is there a way to drop an underscore from record field names (there due to lens) when deriving FromJSON instnaces with aeson?
14:14:34 <bricked> 7.6.3 and i can define a data
14:14:37 <bricked> without let...
14:14:41 * hackagebot http-client 0.4.7 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.4.7 (MichaelSnoyman)
14:15:24 <quchen> jle`: I'm always skeptical about these "don't use that word" articles, but I'd welcome the term "monad" disappearting everywhere except when monads are involved too.
14:15:36 <glguy> tasker: the default implementation of a FromJSON.parseJSON is: parseJSON = genericParseJSON defaultOptions
14:15:41 <baden> Lutin': bye, thanks a lot!
14:15:55 <glguy> tasker: You can define your own options value and use that instead
14:15:59 <mniip> how would I go about having a variable size aggregation of MVar's/TVar's holding different types of data
14:16:10 <glguy> http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson-Types.html#v:defaultOptions
14:16:20 <jle`> quchen: agreed :)
14:16:26 <jle`> hopefully it was clear that the article was part tongue-in-cheek
14:16:36 <drewbert> I'm having trouble finding a way to convert an svg to a png.
14:16:46 <quchen> jle`: The Reddit link title is annoying and made me click it with hate
14:17:03 <jle`> ha ha
14:17:13 <jle`> you should be happy i didn't use the title i used when i posted it in twitter
14:17:28 <kadoban> drewbert: There isn't a direct conversion. You can only render/rasterize an SVG. I couldn't find a good way directly in haskell either, last I tried.
14:17:29 <jle`> IO Monad considered harmful.  What happens next will astound you
14:17:34 <quchen> You're not mstksg though, are you?
14:17:38 <jle`> i am he
14:17:44 <quchen> ლ(ಠ益ಠლ)
14:17:57 <jle`> :P
14:18:20 <jle`> fwiw i upvoted your link bait warning
14:18:29 <bricked> > flip (-) 3 7
14:18:31 <lambdabot>  4
14:18:33 <jle`> but by the time people read it, it's too late
14:18:42 * jle` cues evil laugh
14:18:47 <quchen> "Told ya" style.
14:18:50 <drewbert> kadoban: then a system.process calls to imagemagick approach is as good as any?
14:19:00 <quchen> Eh, "ContT Toldya" style
14:19:28 <jle`> :)
14:19:30 <kadoban> drewbert: Well, that's basically what I'm doing.
14:19:46 <kadoban> drewbert: Actually I use inkscape
14:20:21 <kadoban> drewbert: I don't know that imagemagick does very well with vector graphics, but it's possible it does.
14:20:30 <quchen> It's interesting that there are no other terms like "monad" around. Nobody calls Int "the Int monoid".
14:21:14 <geekosaur> "the"?
14:21:41 <Welkin> is there a good, standard implementation of a priority queue on hackage?
14:21:59 <kadoban> quchen: Bad example, hehe. There are several, so Int isn't even a Monoid.
14:22:02 <quchen> Implicit "one of", geekosaur. My point is that monadic types are always called monad
14:22:05 <c_wraith> I never call something "the X monad".  I talk about "in IO" rather than "in the IO monad".  monad isn't an important detail of a type most of the time, so why say it constantly?
14:22:13 <mniip> so uh
14:22:15 <mniip> http://hackage.haskell.org/package/ghc-prim-0.3.1.0/docs/GHC-Prim.html#v:unsafeCoerce-35-
14:22:19 <Cale> Welkin: There are a few decent ones. I've used the PSQueue package before with good results.
14:22:25 <jle`> quchen: people always say State monad
14:22:26 <mniip> this says I can unsafeCoerce stuff to Any and back
14:22:31 <mniip> how safe that actually is?
14:22:34 <c_wraith> jle`: not me!
14:22:37 <sinelaw> acowley, I've noticed you forked HOpenCV a while back, and done quite a bit of work
14:22:37 <jle`> oh you mean wrt to the "monad" part
14:22:41 <quchen> Yes.
14:22:41 <jle`> c_wraith: o/
14:22:51 <geekosaur> mniip, not safe at all in general
14:22:58 <mniip> hmm
14:23:01 <mniip> sounds good!
14:23:12 <quchen> "Maybe monad". Either is rarely a "monad" for some reason.
14:23:22 <geekosaur> it's provided because there are some cases where the compiler can't tell that two things that should be the same, are the same
14:23:30 <mniip> Either is not a monad iirc
14:23:31 <glguy> Mniip: perfectly safe as long as you don't make any mistakes. You shouldn't use it
14:23:35 <mniip> (Either a) though
14:24:15 <quchen> Then State is not a monad either and Cont and no transformer is and what not.
14:24:22 <jle`> :P
14:24:27 <jle`> and so list is not a monoid either huh
14:24:29 <Cale> Welkin: pqueue also looks good. I haven't had the chance to actually try it though.
14:24:54 <quchen> jle`: List is also never a monad. Probably because it doesn't fit the "holds one" picture of all the monad tutorials ;-)
14:25:03 <quchen> s/monad/"monad"/
14:25:16 <jle`> i said monoid heh, in order to find another pedantic kind error
14:25:26 <c_wraith> Oh, you need to return a list monad of values, not just one value.
14:25:27 <quchen> Woops
14:26:02 <sinelaw> monads are subjects for tutorials
14:26:03 <jle`> i'm trying to think of other things like "monad" in this sense but i can't think of any at the moment.
14:26:20 <jle`> what is up with monad then
14:26:39 <Cale> quchen: hm?
14:26:46 <c_wraith> jle`: if you go back in time, you can find them in all sorts of areas..  like, watch some episodes of the twilight zone and see how they talk about computers.
14:26:50 <Cale> What does "monad" mean relative to monad? :)
14:27:06 <Cale> I must have missed something here
14:27:08 <c_wraith> Cale: I think it just means using the term, rather than just the concept
14:27:19 <quchen> Cale: IO is usually called "IO monad", same for Maybe. But you never hear about the "Int monoid", the "List monad" etc.
14:27:19 <Cale> People don't talk about using the list monad?
14:27:35 <quchen> People call lists lists, but they call IO "IO monad".
14:27:37 <Cale> I've certainly said "list monad" before, a lot.
14:27:37 <jle`> Cale: an adjective/qualifier used in cases where it's irrelevant often
14:27:47 <jle`> we use list monad when we are talking about the monad instance of list
14:27:59 <jle`> but nobody says "list monoid" when they are talking about something unrelated to monoids
14:28:00 <c_wraith> Cale: only when they're actually treating it as a monad.  there are people who *never* say IO except as part of the phrase "IO monad"
14:28:12 * geekosaur usually only includes "monad" when it's relevant (or sometimes when emphasizing that it's *not* relevant...)
14:28:13 <Cale> Well, that's odd :)
14:28:23 <jle`> does haskell have containers? --> yes, the list MonadPlus
14:28:29 <quchen> :-D
14:28:38 <Cale> I would recommend for those people to be more careful about their use of terminology :)
14:28:50 <Cale> Int monoid is inherently ambiguous
14:29:01 <jle`> i can't think of any other word like "monad" that is abused in this way
14:29:01 <Cale> You would say something like "the additive monoid on Int"
14:29:09 <c_wraith> jle`: your post has a typo - "actaully" for "actually"
14:29:18 <jle`> thanks :)
14:29:24 <geekosaur> "the (0,+) monoid" is a trifle unwieldy, true :p
14:29:35 <josephle> Cale: then people would have to *gasp* use the full definition of a monoid? D:
14:29:40 <quchen> Stop telling me my shorthand is ambiguous :-|
14:29:42 * hackagebot control-monad-free 0.6.1 - Free monads and monad transformers  http://hackage.haskell.org/package/control-monad-free-0.6.1 (PepeIborra)
14:29:47 <c_wraith> geekosaur: still doesn't include the specific type!  it's ambiguous!
14:29:48 <josephle> i.e. actually define the operation over the set?
14:29:51 <danmane> I'm trying to develop a program that plays a game with a remote player, so I originally had a function of type Game -> IO (Maybe Game) that sends a gamestate to a remote player and gets back an updated gamestate (or failure). But I realized I could factor the program more nicely if I pulled out (Game -> Maybe Game) as a type and then wrap that in IO for IO
14:29:51 <danmane> (Game -> Maybe Game). This lets me take logic like combining gamestates from different players and handling failure out of the IO monad and into pure code. But I can't figure out how to transform or re-write my Game -> IO (Maybe Game) function into a IO (Game -> Maybe Game) type... any suggestions?
14:30:07 <geekosaur> quchen, in a room full of geeks? :p
14:30:16 <quchen> Touche
14:30:23 <quchen> THE LIST APPLICATIVE
14:30:24 * quchen hides
14:30:33 <c_wraith> danmane: you can't write a function of the type (a -> IO b) -> IO (a -> b)
14:30:42 <c_wraith> danmane: at least, not a useful one. :)
14:30:44 <Cale> danmane: It might be impossible
14:31:07 * geekosaur wonders if the correct idea here is something like Prompt
14:31:25 <geekosaur> or whatever the current instantiation of that concept is... been a while
14:31:27 <c_wraith> danmane: (a -> IO b) can do strictly more than IO (a -> b)
14:31:42 <CaptainNotSlow> Guys how do you deal with Haskell not being as fast as C?
14:31:44 <c_wraith> danmane: that's actually part of the key difference between Applicative and Monad as interfaces.
14:31:53 <c_wraith> CaptainNotSlow: 99% of the time, by just not caring.
14:31:59 <Cale> danmane: It all depends on what it is that your computation is doing. If the effect of the IO action constructed by the function Game -> IO (Maybe Game) doesn't depend at all on the input Game value, then it's conceivable that you could turn it into an IO (Game -> Maybe Game)
14:32:15 <danmane> what can IO (a->b) do? does my idea of having a function that takes a game, talks to remote player, gets back a new game beign typed IO (Game -> Maybe Game) make sense?
14:32:35 <Cale> CaptainNotSlow: Sometimes Haskell is faster than the C which I could write by hand.
14:32:42 <c_wraith> CaptainNotSlow: if the performance matters, make it faster.  (GHC can easily be coaxed to produce faster code by making the source more like C)
14:32:45 <mmachenry> CaptainNotSlow: By being 9 times faster than Python.
14:33:03 <CaptainNotSlow> But your code is abysmally slow compared to mine
14:33:06 <Peaker> danmane: IO (a->b)  can only have IO effects that do not depend on "a"
14:33:11 <CaptainNotSlow> Like seriously
14:33:24 <Peaker> CaptainNotSlow: well, it takes us a lot less time to write it :)
14:33:25 <Cale> CaptainNotSlow: Especially in cases involving lots of ByteString or Text fusion, where in order to get as good performance writing C, you have to do all kinds of awkward and careful buffer hackery.
14:33:26 <danmane> The IO action is giving the input game state to the remote player and getting back its computation on it. So it does depend on the input game, I think. So that implies to me that IO (a->b) is the wrong type for what I want to do.
14:33:29 <mmachenry> CaptainNotSlow: Yeah but we're just not as smart as you.
14:34:20 <danmane> Peaker / c_wraith / Cale can you recommend any reading that will help me understand the difference between IO (a->b) and a -> IO b?
14:34:25 <CaptainNotSlow> mmachenry: No way, isn't this #haskell? Or am I in the wrong channel
14:34:27 <mmachenry> CaptainNotSlow: The point of Haskell is not blazing performance at all costs like C. The point is safety and high-level constructs for programmer productivity.
14:34:46 <mmachenry> CaptainNotSlow: Is it possible for both to be true? :-P
14:34:51 <jle`> danmane: i'd recommend you separate out the giving-the-state and getting-it-back part from your game logic
14:35:01 <Cale> danmane: A value of type IO t is a description of a program which could be executed to produce a value of type t, and may have arbitrary I/O effects during that execution.
14:35:06 <josephle> mmachenry: rust claims it's possible. who knows?
14:35:10 <CaptainNotSlow> mmachenry: But then, there is Rust
14:35:14 <jle`> if all the IO action does is print something out and wait for a text, then you can make your functions (a -> b), and have a handler :: (a -> b) -> IO ()
14:35:14 <CaptainNotSlow> Yeah josephle the man
14:35:22 <jle`> er, (a -> (String, b))
14:35:26 <jle`> where String is what you want to print out
14:35:26 <Cale> danmane: It's important to realise that simply *evaluating* the value of type IO t does not cause it to execute
14:35:35 <mmachenry> josephle: Quite possible. I don't know Rust but I know people say great things.
14:35:41 <Cale> danmane: any more than opening up a binary in your hex editor would cause it to run
14:35:49 <josephle> CaptainNotSlow: I would have to say though that speed isn't everything, or else people would stop using java long ago
14:35:58 <platz> mmachenry: in python if they want to optimize a library they just write it in C (see numpy/numba etc..)
14:36:05 <danmane> Cale: what does cause it to execute, if not evaluating it?
14:36:05 <CaptainNotSlow> josephle: Even java is faster than haskell
14:36:16 <josephle> there is always demand for a statically typed GC language
14:36:30 <Cale> danmane: In a compiled Haskell program, main is really the only IO action which gets executed, but it may in turn be built up from simpler ones.
14:36:32 <mmachenry> platz: Yes, I know. That's what most languages do. What's your point?
14:36:47 <Cale> danmane: In GHCi, you can type an IO action at the prompt and GHCi will execute it for you immediately.
14:36:58 <Cale> (after evaluating which IO action it is)
14:36:59 <jle`> danmane: a runtime environment executes it
14:37:00 <shachaf> CaptainNotSlow: Your behavior is unacceptably hostile and inflammatory for this channel.
14:37:20 <CaptainNotSlow> shachaf: I'm sorry, I was not aware of that my dear friend.
14:37:23 <platz> mmachenry: I guess it's hard to evaluate a language unless you make the restriction that it's pure
14:37:56 <Cale> danmane: So, a value of type IO (a -> b) describes something (potentially effectful) which could be done in order to produce a function of type (a -> b), which may then be applied as many times as you like without any further effects.
14:38:46 <danmane> OK, I see. That's definitely not what I'm doing here, since the remote player may be stateful or arbitrary in any way, so e.g. giving it a game state to respond to might change its state and it might respond to the same game state with different moves if called multiple times
14:38:56 <Cale> danmane: On the other hand, a value of type a -> IO b is a function which given some value of type a, will construct an IO action that if executed, will produce as its result something of type b
14:39:30 <Cale> Given the same value of type a, it will always produce the same value of type IO b, because that's how functions work
14:39:58 <Cale> But then that IO b may cause different things to happen each time it's executed, because it can interact with the real world.
14:40:38 <danmane> Cale: Wait, really? What about a function of type String -> IO String that prints a string to the console and then returns user-typed response? Given the same string input I might type different things at the prompt
14:41:06 <Chousuke> danmane: the IO action that asks for the string is always the same
14:41:19 <jle`> the (IO String) is the same.  it's a program that gets user input.  the exact same program every time
14:41:28 <Cale> CaptainNotSlow: It's important to realise that languages don't have well defined "speeds" like you're implying. Language implementations, i.e. actual compilers, might do a better or worse job of generating machine code when given a reasonable program.
14:41:42 <jle`> but the String that your (IO String) produces when is executed is different
14:41:48 <jle`> but the `IO String` is the same.
14:41:55 <Cale> CaptainNotSlow: But it's really difficult to make the comparison, because a C compiler won't accept a Haskell program as input, and vice versa.
14:42:45 <jle`> to draw a rough analogy, you can think of a `String -> IO String` as a function that takes a string and produces a bash script that asks for a string with the given string as a prompt.  the function will produce the same bash script every single time.
14:42:58 <Cale> CaptainNotSlow: Individual programs in the same language might run more quickly or slowly of course. If you're having trouble making your Haskell program run more quickly, we might be able to provide some tips about how to improve it.
14:43:11 <Chousuke> danmane: Every time you run "ls", the program doesn't change (so the compiler that produced it is in effect a huge function) but the results do, depending on circumstances.
14:44:02 <Cale> danmane: Yeah, sorry for the distraction, these guys got it though. :)
14:44:21 <danmane> So if I wrote a program main = do
14:44:21 <danmane> a <- getString "type a string"
14:44:21 <danmane> b <- getString "type a string"
14:44:21 <danmane> print >>= a
14:44:21 <danmane> print >>= b
14:44:21 <danmane> a and b represent the same program.. but when i connect them into "print" then they execute and produce different strings?
14:44:35 <Cale> a and b are not programs
14:44:41 <Cale> a and b are presumably strings
14:44:54 <Cale> getString "type a string" is the same program as getString "type a string"
14:45:07 <cjenkin2> By reflexivity
14:45:12 <mniip> a and b are variables
14:45:19 <danmane> oh ok, the <- in this context effects execution of the program/function
14:45:28 <Cale> yes
14:45:34 <mniip> a <- b is syntactic sugar for b >>= \a ->
14:45:44 <Chousuke> not really. what actually causes the execution is binding it to main
14:45:44 <Cale> v <- x means "execute the action x, and call its result v"
14:45:49 <jle`> i like to think of <- like naming
14:45:50 <Cale> So if x :: IO String, then v :: String
14:45:50 <cjenkin2> >>= is pronounced "bind" usually
14:46:21 <sclv> "<-" is more than naming. its more analagous to evaluation and assignment
14:46:27 <Cale> mniip: That's beside the point
14:46:38 <Chousuke> you can define your program as foo = ... and if you don't say main=foo it will never actually execute, even though it exists as the value of "foo" (unless the compiler optimizes it away, which is likely)
14:46:39 <HeladoDeBrownie> there are lots of cooks in this kitchen
14:46:41 <jle`> given x :: IO a and y :: IO b, (do x; y;) produces a new `IO b`, a new program, that represents doing the two programs one after the other
14:46:42 <Cale> and please please don't mix up evaluation and execution
14:46:56 <jle`> but this is kind of not as useful because you can't use the result of x
14:47:12 <jle`> so (do a <- x; y; ...) is the same thing, but it lets you "name" the result of `x`
14:47:14 <Cale> "<-" has very little to do with evaluation
14:47:14 <sclv> like in a c-like language context, we can think of "a <- b" as having two different _types_ of things on the two sides, an 'lval' and an 'rval' (where here the lval is a pattern and the rval a regular old expression)
14:47:16 <jle`> so you can use it later in the do block
14:47:32 <Cale> and it has everything to do with execution
14:47:46 <shachaf> It's a big stretch to go to lvalues/rvalues there, I think.
14:48:02 <sclv> yeah its a tenuous analogy, maybe i'll just back off and let others explain more straightforwardly :-)
14:48:03 <Cale> Yeah, I don't think trying to make an analogy to C here is going to be helpful
14:48:09 <Cale> C doesn't have these concepts
14:48:30 <Cale> In particular, it doesn't have the distinction between evaluation and execution that we need to make sense of this
14:48:33 <danmane> so if i wanted i could translate every do block to one where instead of using `a <- f ` i could do `let a = f ` in which case a would be an IO type, and then i could bind / sequence it by hand
14:48:43 <Cale> NOPE
14:48:51 <Cale> let a = f  will define a and f to be the same thing
14:48:59 <Cale> So if f :: IO String, then a :: IO String
14:49:23 <Chousuke> it might be easier to understand if you ignore the syntactic sugar
14:49:27 <Cale> a <- f means "execute the action f and call its result a"
14:49:35 <Cale> which means that if f :: IO String, then a :: String
14:49:53 <Cale> Please just let me do the explaining for now :)
14:50:21 <Cale> We could explain bind and all that, but in the case of IO actions, I don't think it's really much more helpful, since they're abstract anyway
14:50:30 <mniip> Chousuke, that's my point too
14:50:52 <shachaf> It might be good to move the conversation to #haskell-overflow.
14:50:53 <Cale> So you can regard do-notation as a way of gluing together IO actions into larger IO actions
14:50:58 <danmane> yeah i think maybe what i should do is take some programs i've written with do notation and try translating them into binds and lambdas and so forth
14:51:09 <mniip> to me, understanding IO without do sugar is easier, although maybe it's just me
14:51:13 <shachaf> (It's a good conversation, just a long one.)
14:51:20 <cjenkin2> I'm guessing no one has used the "M" word yet?
14:51:42 <mniip> cjenkin2, http://i.imgur.com/IRkm7Hd.gif
14:52:04 <Cale> cjenkin2: It's pointless to talk about the monad abstraction if you're not talking about more than one monad.
14:52:08 <danmane> mniip: that is quite the gif
14:52:32 <mniip> I know
14:52:35 <cjenkin2> Cale, Agreed. I'm starting to teach Haskell to a co-worker, curious about how to approach such things, is all
14:52:35 <mniip> it's my first bookmark
14:52:46 <cjenkin2> I'll just watch though, and stop interrupting
14:53:17 <Cale> danmane: Anyway, so yeah, the difference between IO String and String is rather like the difference between /bin/ls and a list of files.
14:53:40 <mniip> or between (() -> String) and String
14:53:43 <Chousuke> Cale: I personally find it easier to understand programs as values without the syntactic sugar in the way, since you have regular functions (never mind that they are abstract), applied on values (programs)
14:53:44 <Cale> no!
14:53:52 <mniip> no?
14:53:53 <Cale> (() -> String) and String are essentially the same type
14:53:57 <danmane> Cale: yeah. thanks, i think this is making more sense to me than it was before
14:54:02 <mniip> ok substitute () with something meaningful
14:54:16 <Cale> IO String is nothing at all like a String
14:54:29 <Cale> If you're picturing it as like some kind of fancy string, you are wrong
14:55:06 <Cale> A value of type IO String is like a program which at the end of its execution (provided it terminates normally) will result in a String
14:55:08 <danmane> i think mniip is saying IO String is like (X -> String) where I guess X is "state of the world" (in ls example its the state of the directory). is that a reasonable metaphor?
14:55:13 <Cale> But that program may do a lot of things
14:55:18 <mniip> yeah more or less
14:55:39 <mniip> except you have to keep the X and pass it to further functions down the line
14:55:41 <Cale> You can *sort of* think of it as a function World -> (World, String), but this is a really unhelpful analogy later on
14:55:44 <dibblego> Cale: I will be writing about this soon, in a C# context (pointless to talk about the monad...)
14:56:08 <Cale> In particular, that analogy doesn't help you deal with concurrency
14:56:28 <geekosaur> not really, since it's a bit ridiculous to conceive of the state of the world being somehow encompassed by the program. what *may be* potentially helpful, and actually is rooted in truth in GHC, is that X is a baton of sorts that keeps IO actions in sequence
14:56:29 <Cale> and it's also really confusing, because the world actually changes in ways which are outside the control of that function
14:56:40 <jle`> it is not a reasonable metaphor
14:56:45 <geekosaur> and an IO action will at some point be executed if the baton can reach it
14:57:02 <geekosaur> but you have no say in *when* it will reach it
14:57:13 <geekosaur> which is why there is no real IO a -> a
14:57:27 <Cale> Yeah, if you've looked at what GHC does to implement IO, please be aware that it's an awful hack
14:57:31 <geekosaur> (and why the one that appears to be there if you poke around, doesn't quite do what you'd like to think)
14:57:41 <Cale> and not really to be taken too seriously as a good mental model of how things work
14:58:26 <danmane> geekosaur: what do you mean there is no real IO a -> a?
14:58:45 <geekosaur> otherwise phrased "you can't escape IO"
14:59:00 <danmane> ah ok
14:59:06 <danmane> I parsed as IO (a -> a) mistakenly
14:59:06 <Cale> danmane: There's by design no function which can tell you what the result of executing an IO action will be, because that might be different every time
14:59:26 <geekosaur> but I say "real" mostly because if you use bind or do notation <- you have something that looks like IO a -> a but isn't, quite
14:59:29 <Cale> and functions by definition produce the same result when given the same input
14:59:55 <monochrom> read my http://www.vex.net/~trebla/haskell/IO.xhtml
15:00:01 <Cale> (at least in Haskell and mathematics, they do)
15:01:08 <Cale> danmane: So, an important thing to realise about do-notation is that whenever we have a do-block that executes a bunch of IO actions and does things with their results, the do-block as a whole is itself an IO action, whose result is the same as the result of the last action in it.
15:01:45 <danmane> would anyone care to look at the refactor i'm trying to do that prompted my initial `a -> IO a -> IO (a -> a)` question and advise on a better way to do it?
15:01:50 <Cale> sure
15:02:18 <danmane> https://github.com/danmane/abalone/pull/4/files?diff=split
15:03:18 <Chousuke> danmane: it really boils down to programs as values, if you do say, ask = getLine "Number?", then x is a program that asks for a number. then if you have a double = \x -> print x ++ x whose type is String -> IO String ie. a function that returns a program that prints x twice. now you need something magic that allows you to take the x from  (which is IO String, not a String like
15:03:24 <Chousuke> double expects!) you you can do print_and_ask = getline `magic` double to concatenate the programs  ... and at this point you haven't actually executed anything yet.
15:03:37 <Chousuke> the only way to actually execute that program in haskell then is to say main = print_and_ask
15:03:42 <Chousuke> and the runtime does it for you
15:03:43 <Cale> danmane: What sort of game is this?
15:03:54 <danmane> its a 2 player turn-based game. think checkers
15:03:54 <Cale> oh, abalone
15:04:18 <platz> My take on this: the thing that makes an 'IO t' data structure different from some arbitrary java bytecode, is that bytecode is an opaque black box, and represents commands that will be executed immediately, whereas an 'IO t' just "describes" the intended action, remains composable and is a first-class value in your program.
15:04:24 <platz> It's necessary to draw a distinction between the "runtime" and "evaluation", but it's not ever necessary to draw this distinction in other languages, which I think is where the confusion comes from.
15:04:29 <platz> Evaluation is pure, the runtime is not, but evaluation is what allows you to reason about your program.
15:04:42 <danmane> i wanted to factor out concepts like "the players alternate taking turns" and "when the game is over declare the winner" away from the IO
15:05:10 <jophish> What would people use to store a fixed number of Vectors? Corresponding to the C type {size_t length; T* vectors[NUM_VECTORS];}?
15:05:12 <danmane> and add failure handling (hence moving into the Maybe monad). declaring the type Agent = Game -> Maybe Game let me factor all the logic out nicely but then i dont have any way to put the IO back in. on the right side, line 32 is the part where everything breaks down
15:05:44 <jophish> I don't think a list is quite right, and Vector itself seems an odd choice for something so small
15:05:58 <Cale> danmane: Yeah, okay, so the problem here is when you go from having an Agent which is simply an AI to having an Agent which needs to request that a real player make a move, yeah?
15:06:12 <danmane> Yes
15:07:48 <Cale> danmane: So yeah, this kind of gets into MonadPrompt or free monad sort of territory, where we want to abstractly represent some actions to be taken and then specify exactly how to implement them (e.g. with real I/O) later on.
15:08:13 <Cale> danmane: But there are a bunch of approaches to it... let me just have a closer look at what the program is doing.
15:08:49 <Cale> danmane: It might be as simple as just having some value which means "ask the player for input"
15:09:22 <Archi> 2 + 2
15:10:31 <Archi> 2+2
15:10:36 <Cale> > 2 + 2
15:10:37 <lambdabot>  4
15:10:47 <Archi> oh ok xd
15:11:18 <Cale> danmane: Or of course, you could just add IO to your definition of what an Agent can do, and then write a very simple function like  (Game -> Maybe Game) -> (Game -> IO (Maybe Game)) which can be applied to your pure agents to get impure ones.
15:11:41 <Cale> (That's just composition with return)
15:11:50 <Pamelloes> Is there a functor implementation for (a,a) that fmaps over both parts - not just the second?
15:11:56 <Cale> Pamelloes: nope
15:12:08 <hyPiRion> Pamelloes: you can use lenses
15:12:11 <Cale> Pamelloes: That can't happen without defining a new type
15:12:14 <hyPiRion> > over both (+1) (1,2)
15:12:16 <lambdabot>  (2,3)
15:12:33 <Cale> because
15:12:44 <Pamelloes> I guess I have to make a newtype
15:12:45 <Cale> fmap :: (Functor f) => (a -> b) -> f a -> f b
15:13:04 <danmane> Cale: Yeah, I will try that and see if the functions I have still wind up being elegant / clear
15:13:20 <Cale> So you sort of want f to be (\t -> (t,t)), but that's not directly possible because Haskell doesn't have type lambdas
15:13:36 <joness> I want to write a thread-safe putStrLn, that guarnatees that output from different threads won't be intermingled. is top-level MVar () used for locking the way to go? is there a better way? using a mutable top-level variable and unsafePerformIO makes me pause for a second or two
15:14:16 <Pamelloes> Cale: I only want to define it over (a,a) so fmap f (a,a) = (b,b). Doable with a newtype, right?
15:14:21 <mpickering> well.. an alternative is to thread the MVar as an argument
15:14:36 <Cale> joness: One way is just to have a Chan String with one thread pulling from the Chan and doing the putStrLns, and the other threads writing to it
15:14:40 <joness> mpickering yeah.. that is probably nastier from the user's poin of view
15:15:09 <levi> I'd recommend Cale's suggestion.
15:15:27 <Cale> Pamelloes: Yeah, newtype Pair a = P (a,a); instance Functor Pair where fmap f (P (x,y)) = P (f x, f y)
15:16:16 <Pamelloes> Cool :)
15:16:43 <Cale> joness: Another thing I could recommend is to pass the writing function around as an argument of type  String -> IO (), rather than passing the Chan String around
15:17:03 <Cale> joness: This lets you play lots of cool games later, like if you decide you'd also like to log that stuff to a file
15:17:37 <joness> Cale true.. but that requires planning.. I want to write a drop-in replacement for putStrLn as well when you just want to get things done
15:18:00 <joness> so global Chan String + unsafePerformIO, I guess :)
15:18:04 <Cale> Uhhhh
15:18:06 <Cale> don't do that
15:18:10 <Cale> That's so ugly
15:18:34 <joness> threading Chan String is uglier from the interface point of view though
15:18:53 <HeladoDeBrownie> the interface doesn't have to involve threads, just the implementation
15:19:03 <Cale> Well, threading Chan String might be, but passing in a (String -> IO ()) is pretty cool.
15:19:11 <joness> HeladoDeBrownie I don't understand
15:19:12 <Hijiri> You could just thread the String -> IO () and have it close around the Chan String instead
15:19:16 <sclv> when I did it in the past, I did passing a (String -> IO ()) around
15:19:21 <sclv> in a large production system -- it worked well
15:19:39 <sclv> everything was in a bolted-in reader monad that had that and other "ambient" functions
15:19:41 <Cale> Because that gives the users of your stuff the ability to decide how they want to receive the messages
15:19:57 <Cale> So if they want it going somewhere other than the terminal, that's easy then
15:20:06 <Cale> You can do something like
15:20:13 <HeladoDeBrownie> joness, you can write your own putStrLn with exactly the same type as the original, String -> IO (), so it's useable in all the same places, except that it avoids interleaving writes, using the method Cale described.
15:20:29 <sclv> exactly -- you could log to the terminal, you could throw it into a queue for another logging service, send it over the wire to a log listener, etc
15:21:10 <joness> HeladoDeBrownie I don't see how
15:22:30 <HeladoDeBrownie> joness, instead of the resulting IO action writing directly to stdout, it will throw the String into a Chan. Separately, there is a thread you will have spawned that waits on that Chan and writes what it gets from it.
15:22:56 <joness> Cale I understand that this is better from the program's design point of view. but I was thinking of ways to write a thread safe putStrLn, without global variable of some sort, and unsafePerformIO. that was pthe point of excercise. if that is the goal I think global var is the cleanest way to do it
15:23:53 <joness> from the users POV such a putStrLn equivalent is no nastier and not any less safe (in fact it is more safe if you care about correct output) than a regular putStrLn
15:23:55 <Cale> mkChannel :: IO (String -> IO ()); mkChannel = do c <- newChan; forkIO . forever $ do v <- readChan c; putStrLn v; return (writeChan c)
15:24:21 <Cale> You execute that action once somewhere high up in main or something
15:24:29 <Cale> and then pass the resulting String -> IO () around
15:24:47 <Cale> later, if you want to change the logging behaviour, you can replace writeChan there with something else
15:25:08 <Cale> Or maybe replace the Chan with an MVar or a BoundedChan if you find that the channel backs up
15:25:34 <Cale> Or replace the putStrLn v with something else
15:26:06 <joness> Cale what if I have a thousand lines sinle-threaded program that I want to make work on multiple threads? I have to redesign the whole program. with putStrLn replacement I just do s/putStrLn/putStrLnSynced
15:26:29 <Cale> Well, you add a handful of parameters to a few things
15:26:39 <Cale> It's never as big a deal as people seem to thing
15:26:41 <Cale> think*
15:26:56 <Cale> 1000 lines is not hard to go through
15:26:58 <HeladoDeBrownie> it occurs to me i misread a few things before i responded
15:27:08 <Cale> and add a parameter here and there
15:27:29 <Cale> and you end up with explicit dependency on this String -> IO () which later might turn out to be extremely useful
15:27:37 <Cale> (at least, it has in my experience)
15:27:39 <levi> Sweeping changes to my Haskell programs are way easier than in most other languages I use.
15:27:54 <Peaker> it's not a big deal to make these changes with the compiler's help.
15:28:09 <Cale> Usually if you're doing anything which is anything like logging, parameterising your programs over how that logging is done tends to be a good idea *anyway*
15:29:02 <levi> I've written a big chunk of a Haskell IRC server, so I've done a bunch of very similar sweeping changes.
15:29:20 <Cale> This is even more true if it's not just String -> IO () but some more structured data type which is being logged
15:29:35 <joness> I still think it would sometimes be convenient to have a putStrLn version that doesn't make a garbage when printing from multiple threads. in fact I am surprised that putStrLn itself isn't synced
15:29:51 <Cale> When I was working on an ARPG in Haskell before, I added a "save replay" feature for testing super-easily this way
15:30:33 <sclv> i do agree its sorta weird that putStrLn isn't synced actually
15:30:48 <Peaker> "synced" as in mutex-locked or what?
15:31:18 <sclv> Peaker: yeah. two threads writing to the console will step all over one another :-)
15:31:48 <Cale> Well, sure for String I/O that's true, you're not likely so interested in performance if you're using String
15:31:59 <joness> Cale with the argument you are makinis one could also argue that you should never use putStrLn, but always accept (String -> IO ()) everything. I think you will agree that this is not sensible. so why should things suddenly change just because we want to prin from multiple threads?
15:32:01 <Cale> But I suspect the original reason for that is a performance one
15:32:12 <joness> everywhere*
15:32:18 <joness> sorry for horrible typing
15:32:45 <sclv> eh, i feel like its just historical reasons. it doesn't matter to serious programs and it makes things easier for beginners
15:32:49 <Cale> joness: It actually might be sort of true that you ought to rarely use putStrLn directly :)
15:32:59 <sclv> arguably in fact we _should_ have a top level mutex available for stdin
15:33:07 <sclv> since stdin is magically top-level available anyway :-)
15:33:21 <sclv> erm stdout that is
15:34:07 <Cale> It's really awkward that there's no way to execute an arbitrary IO action while capturing its stdin/stdout
15:34:37 <Cale> (well, nothing too reliable anyway)
15:34:50 <sclv> haha or that's the other direction make _everything_ less top level
15:35:05 <sclv> but i agree -- its actually a good example of why magic top level things are nice until they're not
15:35:32 <danmane> How do I go from `[(IO a, b)]` to `IO [(a,b)]`?
15:35:48 <sclv> here's a first step:
15:35:51 <sclv> ?ty sequence
15:35:51 <lambdabot> Monad m => [m a] -> m [a]
15:36:02 <danmane> thanks!
15:36:06 <sclv> so that alone isn't enough, but it should get you close..
15:36:41 <HeladoDeBrownie> presumably that also leaves (IO a, b) -> IO (a, b) that you need
15:37:27 <bananagram> \(a,b) -> a >>=
15:37:30 <bananagram> wait
15:37:54 <bananagram> \(a,b) -> a >>= \x -> (a,b)
15:38:01 <bananagram> :t \(a,b) -> a >>= \x -> (a,b)
15:38:02 <lambdabot>     Occurs check: cannot construct the infinite type: t ~ (t, a)
15:38:02 <lambdabot>     Relevant bindings include
15:38:02 <lambdabot>       x :: a (bound at <interactive>:1:18)
15:38:06 <HeladoDeBrownie> bananagram, think you wrote a wrong variable
15:38:09 <monochrom> (x,b)
15:38:12 <bananagram> :t \(a,b) -> a >>= \x -> (x,b)
15:38:13 <lambdabot> Monad ((,) t) => ((t, t), b) -> (t, b)
15:38:18 <bananagram> hm
15:38:24 <monochrom> you need "return"
15:38:28 <bananagram> dammit
15:38:30 * bananagram quits
15:38:37 <n4x> isn't that (m a, b) -> m (a,b) called strength?
15:38:37 <bananagram> I can't think well right now
15:38:46 <joelteon> yes
15:38:49 <HeladoDeBrownie> bananagram, but you're almost there!
15:38:52 <joelteon> :t fmap (uncurry (,))
15:38:53 <lambdabot> Functor f => f (a, b) -> f (a, b)
15:38:56 <joelteon> whoops
15:39:00 <joelteon> :t uncurry (fmap (,))
15:39:01 <lambdabot> (b -> a, b) -> b1 -> (a, b1)
15:39:04 <joelteon> never mind
15:39:23 <HeladoDeBrownie> harder type to prove than it seems :P
15:39:28 <fizruk> :t _1
15:39:29 <lambdabot> (Field1 s t a b, Functor f) => (a -> f b) -> s -> f t
15:39:31 <Welkin> :t uncurry (,)
15:39:32 <lambdabot> (a, b) -> (a, b)
15:39:41 <Welkin> :t curry (,)
15:39:42 <lambdabot> a -> b -> b1 -> ((a, b), b1)
15:40:00 <Welkin> :t curry
15:40:01 <lambdabot> ((a, b) -> c) -> a -> b -> c
15:40:15 <n4x> @type (\(a,b) -> fmap (,b) a)
15:40:16 <lambdabot> Functor f => (f a, t) -> f (a, t)
15:40:22 <joness> bananagram how did you end up with [(IO a, b)] in the first place? I suspect avoiding it would be cleaner than trying to pull IO out of it
15:40:41 <bananagram> not me, danmane
15:40:41 <HeladoDeBrownie> joness, danmane was the asker
15:40:43 <monochrom> that's also true
15:40:52 <joness> sorry, I meant danmane
15:41:11 <joelteon> it's uncurry (fmap . (,))
15:41:38 <HeladoDeBrownie> @type uncurry (fmap . (,))
15:41:38 <lambdabot> Functor f => (a, f a1) -> f (a, a1)
15:41:45 <HeladoDeBrownie> checks out
15:41:50 <HeladoDeBrownie> wait no
15:41:51 <HeladoDeBrownie> wrong order
15:41:54 <danmane> so I have a type Game which represents a gamestate and Outcome which represents a winner. I have a type Agent which is Game -> IO Maybe Game, and I want to construct a GameStream :: IO [(Maybe Game, Outcome)] which is the infinite sequence of game states (applied by the different agents updating the board when its their move) as well as the outcome of who
15:41:54 <danmane> wins in the case that we get Nothing as the game state
15:42:07 <n4x> @type uncurry (flip (fmap . (,)))
15:42:08 <lambdabot> Functor f => (f a, b) -> f (b, a)
15:42:29 <Welkin> :t uncurry
15:42:30 <lambdabot> (a -> b -> c) -> (a, b) -> c
15:42:32 <danmane> Agent is Game -> IO (Maybe Game) with Maybe because the agent might timeout or return an invalid gamestate (in which case they lose)
15:42:40 <Welkin> :t uncurry (,)
15:42:41 <lambdabot> (a, b) -> (a, b)
15:42:58 <monochrom> function "sequence" will not work well for infinite sequence
15:43:07 <HeladoDeBrownie> IO [(Maybe Game, Outcome)] sounds wrong to me
15:43:20 <Welkin> > uncurry (,) $ (3,4)
15:43:21 <lambdabot>  (3,4)
15:43:33 <Welkin> > uncurry (,) . uncurry (,) $ (3,4)
15:43:35 <lambdabot>  (3,4)
15:43:41 <HeladoDeBrownie> if i understand correctly it sounds like ListT IO [(Maybe Game, Outcome)] would be more appropriate (for the correct ListT, as opposed to the wrong one), but i might be misunderstanding.
15:43:50 <reem_> :t uncurry (fmap . (,))
15:43:51 <lambdabot> Functor f => (a, f a1) -> f (a, a1)
15:44:11 <reem_> :t uncurry (fmap . flip .(,))
15:44:12 <lambdabot>     Couldn't match type ‘(a, a2)’ with ‘a1 -> c’
15:44:12 <lambdabot>     Expected type: a -> a2 -> a1 -> c
15:44:12 <lambdabot>       Actual type: a -> a2 -> (a, a2)
15:44:12 <danmane> i could do [(IO (Maybe Game), Outcome)] instead. but then I am stuck with my function processGameStream :: [(Maybe Game, Outcome)] -> Outcome without a good way to map it into IO
15:44:15 <Welkin> :t fix
15:44:15 <lambdabot> (a -> a) -> a
15:44:26 <HeladoDeBrownie> Welkin, mind going to pm?
15:44:40 <danmane> HeladoDeBrownie: what is correct ListT vs incorrect ListT?
15:44:42 <Welkin> > let f = fix . uncurry (,) in f (3,4)
15:44:44 <lambdabot>  Couldn't match type ‘(a, b)’ with ‘c1 -> c1’
15:44:44 <lambdabot>  Expected type: a -> b -> c1 -> c1
15:44:44 <lambdabot>    Actual type: a -> b -> (a, b)
15:45:14 <Welkin> I'm done with lambdabot
15:45:42 <HeladoDeBrownie> danmane, there is an incorrect implementation of ListT in the mtl package. there are correct ones in… a few places, i think, the main one i know of is in pipes, but you can probably find it elsewhere without the pipes baggage
15:46:43 <HeladoDeBrownie> trying to open an article on the haskell wiki but it's super slow as it has been for a while
15:47:11 <HeladoDeBrownie> danmane, wait, have you touched monad transformers yet?
15:47:24 <danmane> no, i havent encountered them
15:47:30 <HeladoDeBrownie> by the way, found one on hackage: http://hackage.haskell.org/package/list-t-0.4.0
15:48:27 <HeladoDeBrownie> okay, well you don't necessarily need to know monad transformers in general, but let me see if i can find a good source on ListT
15:48:40 <HeladoDeBrownie> in any case we can still explain it over irc
15:49:18 <HeladoDeBrownie> hmm, okay
15:49:29 <HeladoDeBrownie> i was sure there was a good article on this somewhere but i can't find it
15:50:18 <HeladoDeBrownie> the general idea though is ListT gives you effectful streaming. ListT IO is a stream wherein you can execute an IO action to get the next element, and execute another one to get the one after, and so on.
15:50:32 <HeladoDeBrownie> does that sound like what you need?
15:50:56 <danmane> basically i have an initial Game, a function of type (Game -> IO (Maybe Game)), and i want to keep applying this until it fails (in wihch case the player that caused the failure loses) or until gameover :: Game -> Bool evaluates true
15:51:12 <danmane> so ListT does sound like that, yes
15:51:36 <HeladoDeBrownie> hmm, that doesn't sound quite right actually
15:52:06 <HeladoDeBrownie> by which i mean ListT might not be quite what you're looking for here after all
15:52:29 <danmane> My initial approach was to use the Game -> IO Maybe Game to try to construct an infinite stream of IO [Maybe Game] essentially, (with the tuple to represent who wins in case of failure) which got us into the current discussion
15:54:05 <HeladoDeBrownie> well, IO [Game] sounds like it would be slightly more useful, since getting a Nothing signifies end of game, right?
15:54:52 <danmane> oh, that's a really good point. Then I can pattern match (gf : []) to figure out who made the last valid move (and won)
15:55:18 <danmane> So that does seem like a much less convoluted way of accomplishing this... let me try it
15:55:30 <Hijiri> the problem with making an infinite stream with IO is that IO has to fully evaluate all the IO actions that make it up
15:55:33 <HeladoDeBrownie> off the top of my head i think this might help
15:55:35 <HeladoDeBrownie> @type iterateM
15:55:36 <lambdabot>     Not in scope: ‘iterateM’
15:55:36 <lambdabot>     Perhaps you meant one of these:
15:55:36 <lambdabot>       ‘iterate’ (imported from Data.List),
15:55:48 <HeladoDeBrownie> hmm, thought that was a thing
15:55:58 <danmane> Hijiri: Wait, it won't lazily evaluate an infinite stream of IO?
15:55:59 <Hijiri> which is why there are a bunch of solutions to streaming IO
15:56:02 <HeladoDeBrownie> oh, that's not quite right actually
15:56:17 <Hijiri> danmane: no, unless you use unsafeInterleaveIO, which is unsafe
15:56:29 <Hijiri> it defers the execution of an IO action until you actually need the value
15:56:33 <HeladoDeBrownie> what was the function similar to iterate called but where Nothing signifies end of list?
15:56:45 <Hijiri> it's unsafe because the result could depend on when you evaluate it
15:56:53 <indiagreen> HeladoDeBrownie: unfoldr
15:57:16 <Hijiri> which breaks referential transparency
15:57:23 <danmane> ok... so then sadly instead of the elegant infinite stream, i can still generate a IO [Game], but I need to test for when the game is over and ensure that I terminate the list at that point?
15:57:54 <HeladoDeBrownie> indiagreen, that's almost what i was thinking of, i seemed to remember there was one (a -> Maybe) -> a -> [a], but it's possible i misremembered. thanks.
15:58:02 <Hijiri> an IO [Game] would mean you do the IO action, and then you have a complete list of Game afterwards
15:58:07 <Axman6> :t unfoldrM
15:58:08 <lambdabot>     Not in scope: ‘unfoldrM’
15:58:08 <lambdabot>     Perhaps you meant one of these:
15:58:08 <lambdabot>       ‘BS.unfoldr’ (imported from Data.ByteString),
15:58:12 <Axman6> :(
15:58:20 <Axman6> @hoodle unfold
15:58:22 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
15:58:22 <lambdabot> package unfoldable
15:58:22 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
15:58:27 <danmane> Ok maybe I really want [IO Game] then.
15:58:30 <Axman6> @more
15:58:46 <HeladoDeBrownie> danmane, [IO Game] is a list of procedures that may produce Games.
15:58:51 <Hijiri> [IO Game] doesn't quite work either, because you would need to know what IO Game you need before you have executed the previous IO actions
15:59:20 <Hijiri> For example, if I could either win or continue playing on turn 5, you don't know whether the game is over on turn 6 until you do that
16:00:01 <Pamelloes> Is there a way to make T a synonym for True?
16:00:14 <HeladoDeBrownie> typo, (a -> Maybe a) -> a -> [a]
16:00:30 <HeladoDeBrownie> Pamelloes, not really
16:00:42 <HeladoDeBrownie> Pamelloes, you can use t, but T would have to be a constructor
16:00:50 <glguy> Closest thing would be to use Pattern Synonyms
16:00:50 <HeladoDeBrownie> and two different constructors are always distinct
16:01:03 <Hijiri> If you want streaming IO, you will have to roll your own thing, or use ListT as suggested, or a more heavyweight IO streaming library like pipes or conduit
16:01:12 <danmane> Hijiri: So if I have initialGame :: Game and update :: Game -> IO Game, and I want a type to represent the sequence of games that happens if I execute this function on my updating game state repeatedly, what type should I use?
16:01:18 <danmane> ListT?
16:01:35 <Hijiri> I've never actually used ListT, but it looks like it would be the solution
16:01:44 <Hijiri> Game -> IO (Maybe Game) I think
16:02:13 <Pamelloes> Damn. I have a type that is identical to Bool (because of a constructor I just deleted) and I would like to replace it with Bool without changing any code...
16:02:35 <Pamelloes> Of course, if I can't define T = True, I'll have to hold out :/
16:03:05 <lpaste> glguy pasted “pattern synonyms for Pamelloes” at http://lpaste.net/119031
16:03:24 <HeladoDeBrownie> huh, didn't know that was a thing
16:03:28 <mniip> is it just me or does the haskell wiki lag a lot?
16:03:34 <HeladoDeBrownie> mniip, it's not just you
16:03:36 <Pamelloes> glguy: Awesome! Thanks :)
16:03:50 <glguy> Pamelloes: Also, your editor should be able to knock that out in no time, as well ^_^
16:03:57 <Hijiri> haskell wiki lags for me sometimes too
16:04:06 * HeladoDeBrownie should have already learned their lesson about making general statements in the presence of ghc extensions
16:04:33 <Pamelloes> glguy: It's not the replace that will take a while, it's reformatting everything back into 80 chars :P
16:14:47 * hackagebot record 0.1.5 - First class records implemented with quasi-quotation  http://hackage.haskell.org/package/record-0.1.5 (NikitaVolkov)
16:16:23 <lachenmayer> is there any resource on a similar level to learn you a haskell for great good, but with exercises?
16:17:30 <LordBrain> does typeclassopedia have exercises?
16:17:48 <kadoban> LordBrain: No…and it's very different than LYAH
16:17:49 <lachenmayer> or just a nice resource for various simple haskell exercises in general - there's 99 haskell problems on haskell.org but they seem a bit dry
16:18:00 <grq> there's the 99 problems in the haskell wiki
16:18:32 <grq> yes, they seem very general
16:18:39 <lachenmayer> :)
16:18:55 <haasn> LordBrain: There are exercises similar to it somewhere, let me find them
16:19:02 <kadoban> lachenmayer: https://github.com/bitemyapp/learnhaskell has some great resources. cis194 http://www.seas.upenn.edu/%7Ecis194/spring13/index.html is a great start to haskell, and there's homework/exercises, and then there's: https://github.com/NICTA/course/
16:19:24 <LordBrain> thats ok haasn, i was just advertising
16:19:33 <haasn> https://www.fpcomplete.com/user/DanBurton/20-intermediate-exercises
16:19:37 <grq> look if you can go inside the Functional Programming course on edx, the problems were interesting
16:19:39 <kadoban> Personally I thought the 99 problems were pretty awful…
16:19:52 <haasn> ^ me too
16:20:00 <haasn> They're not Haskell style at all
16:20:00 <LordBrain> hehe
16:20:06 <haasn> Seems more like lisp
16:20:06 <lachenmayer> kadoban: ah wow, that's a great resource, thanks
16:20:32 <kadoban> lachenmayer: 'welcome. The dude who wrote it hangs out here, and in #haskell-beginners
16:23:03 <lachenmayer> i'm trying to get a friend (who's only casually coded before) into haskell, was thinking LYAH + some nice exercises to bang his head against in the evenings could work out nicely ;)
16:23:50 <mjrosenb> Is there something like mapMaybe, but in a Monad?
16:23:54 <mniip> is it possible to somehow use functions in a module that the module doesn't export
16:24:26 * mjrosenb can almost certainly use mapM and catMaybes
16:24:39 <kadoban> Yeah, I've never been too big on LYAH personally. I didn't like the tone much, and the content is just so-so, plus no exercises.
16:25:08 <Welkin> @where bitemyapp
16:25:08 <lambdabot> I know nothing about bitemyapp.
16:25:12 <Welkin> @where learnhaskell
16:25:12 <lambdabot> https://github.com/bitemyapp/learnhaskell
16:25:19 <Welkin> go there
16:25:37 <Welkin> use the UPenn Haskell course
16:26:17 <benzrf> mniip: no
16:26:21 <mniip> sad
16:26:28 <benzrf> mniip: yep :|
16:26:51 <RustyShackleford> is there a shorthand for applying a function several times?
16:27:16 <RustyShackleford> like succ succ succ 1 for example
16:27:26 <mniip> benzrf, would make a nice debug flag
16:27:28 <RustyShackleford> but lets say I want to apply it 20 times
16:27:35 <Welkin> :t replicate
16:27:36 <lambdabot> Int -> a -> [a]
16:27:41 <Welkin> :t repeat
16:27:42 <lambdabot> a -> [a]
16:27:48 <Welkin> hm
16:27:54 <n4x> :t iterate -- Welkin
16:27:55 <lambdabot> (a -> a) -> a -> [a]
16:27:57 <Welkin> :t fix
16:27:57 <lambdabot> (a -> a) -> a
16:27:59 <benzrf> RustyShackleford: foldr (.) id (replicate 20 succ)
16:28:01 <Welkin> ah, iterate
16:28:13 <benzrf> RustyShackleford: or iterate !! 20 if you're a huge scrub
16:29:27 <lachenmayer> thanks Welkin, kadoban mentioned that too - excellent page
16:29:37 <Welkin> > take 20 $ iterate succ 1
16:29:38 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
16:31:16 <RustyShackleford> benzrf: thanks that should work
16:32:51 <grq> I don't know how ghc works in this case, but if you make your own function of type Int -> (a->b) -> a -> b it will be probably more efficient in terms of memory
16:33:52 <benzrf> grq: i think you mean a -> a
16:34:02 <benzrf> hmm
16:34:10 <benzrf> @hoogle Monoid m => Int -> m -> m
16:34:11 <lambdabot> Text.Regex.Base.RegexLike after :: Extract source => Int -> source -> source
16:34:11 <lambdabot> Text.Regex.Base.RegexLike before :: Extract source => Int -> source -> source
16:34:11 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
16:34:31 <grq> yes, my error, sorry
16:35:06 <benzrf> @let m.^n = mconcat (replicate n m)
16:35:08 <lambdabot>  Defined.
16:35:09 <dinnu93_> what is the best beginner book for haskell ? I tried learn you haskell for greater good but it is not appealing to me .
16:35:27 <benzrf> > runEndo (Endo succ.^20) 1
16:35:28 <lambdabot>  Not in scope: ‘runEndo’
16:35:34 <benzrf> > getEndo (Endo succ.^20) 1
16:35:35 <lambdabot>  Not in scope: ‘getEndo’
16:35:38 <benzrf> what's the Endo thing
16:35:39 <n4x> endomorphism power
16:35:42 <benzrf> is it not in scope?
16:35:50 <kadoban> dinnu93_: https://github.com/bitemyapp/learnhaskell  specifically scroll down to the cis194 link
16:36:16 <dinnu93_> kadoban: thanks
16:36:25 <benzrf> oh dangit
16:36:30 <benzrf> > appEndo (Endo succ.^20) 1
16:36:32 <lambdabot>  21
16:36:43 <benzrf> why ARENT monoid powers a default operator
16:38:17 <Welkin> know any good guides for functional programming in C++?
16:38:26 <lfairy> benzrf: appEndo?
16:38:37 <Welkin> I'm curious to see what it can do
16:39:25 <NemesisD> any haskell-mode users here?  i've had this weird issue with haskell-process where it will start refusing to reload. all that happens is the minibuffers says (No changes need to be saved) and the repl locks upo
16:40:29 <benmachine> benzrf: I think the semigroups package has times1p and might have something similar for monoids
16:40:45 <NemesisD> if i strace the repl process it seems like its hanging on a wait4
16:40:48 <mniip> > ((.) `foldr1` do [1..20]; [succ]) 5
16:40:49 <lambdabot>  25
16:40:50 <mniip> take that
16:40:52 <levi> Welkin: There's some stuff on bartozmilewski.com about functional programming in C++, but I'm not sure I'd call it "guides". Also a lot of Haskell content.
16:41:41 <shachaf> I,I newtype Foo a = Foo { unFoo :: a }; instance Monoid a => Num (Foo a) where Foo x * Foo y = Foo (x <> y); fromInteger 1 = Foo mempty; timesN n = unFoo . (^ n) . Foo
16:42:48 <benmachine> shachaf: that's pretty cool
16:42:52 <Welkin> levi: thanks
16:43:12 <Welkin> it's hard to find material that isn't focused on OOP, which I don't care about and never use
16:43:15 <benmachine> unclear what you want fromInteger 2 to be, though
16:44:02 <mniip> so, uh
16:44:14 <mniip> anyone here worked tiwh System.Plugins.Load?
16:44:24 <mniip> with
16:45:00 <chrisdotcode> :t liftM
16:45:01 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
16:45:26 <mniip> 'load' works fine, but I can't figure out the 'loadFunction' thing, it throws undefined when I try to evaluate the result
16:45:38 <lachenmayer> is real world haskell any good? seems like it would fit the bill for my friend - and potentially dinnu93_ too? http://book.realworldhaskell.org/
16:45:55 <Welkin> lachenmayer: it is outdated, but still somewhat useful
16:46:05 <lachenmayer> outdated in what sense?
16:46:10 <Welkin> lachenmayer: like I said, go through the UPenn HAskell course
16:46:25 <levi> It's a good book in a lot of ways, but some of the libraries it uses have changed.
16:46:35 <Welkin> lachenmayer: haskell changes very quickly
16:46:40 <shachaf> benmachine: _|_, presumably, the way I defined it.
16:46:55 <shachaf> (^) is a monoid operation.
16:47:10 <joness> Welkin did haskell really change that much since then? or the libraries?
16:47:24 <joness> I never did realworld hsakell because examples don't work
16:47:56 <Welkin> both
16:47:58 <levi> Haskell doesn't really change very much; GHC has added a bunch of extensions and lots of new libraries exist and existing ones have changed.
16:48:09 <benmachine> shachaf: that's a misleading phrase by itself, but yes I see what you mean
16:48:37 <benmachine> levi: "haskell doesn't really change very much"? I think I'd disagree
16:49:15 <benmachine> perhaps the core has remained more-or-less the same, but if you know enough Haskell to write serious programs in it, you've probably had to relearn some parts of that once or twice in the last few years
16:49:33 <benmachine> exceptions, for example
16:49:43 <joness> change as in "it adds extensions that you can enable" or change as in "it breaks compatibility with the old code a lot"
16:49:45 <shachaf> i,i no, Core changes more than Haskell itself
16:49:50 * hackagebot inflections 0.1.0.8 - Inflections library for Haskell  http://hackage.haskell.org/package/inflections-0.1.0.8 (jsl)
16:50:05 <benmachine> shachaf: I agree with all of that except for "no," :P
16:50:19 <enthropy> is there a trick with parser combinators (uu-parsinglib) to get fixities right?
16:50:21 <benmachine> shachaf: ohh, I see
16:50:42 <enthropy> ie. I have a parser that turns f x y into f (x y) not ((f x) y)
16:50:44 <levi> If you consider 'Haskell' to be 'the full language GHC implements', then it's changed quite a bit at least around the edges.
16:51:13 <enthropy> full example http://lpaste.net/119036
16:51:30 <shachaf> benmachine: "i,i" means "i have no point, i just want to say" or something along those lines.
16:51:38 <joness> now you have me worried.. can't i expect my current code to work years from now?
16:52:01 <shachaf> Probably not.
16:52:04 <Welkin> joness: it depends on how you specify the dependencies
16:52:09 <benmachine> shachaf: yes, I just didn't make the core/Core connection
16:52:33 <joness> Welkin what do you mean? I use cabal for anything non-trivial
16:52:38 <levi> joness: If you stick close to the language in The Haskell Report, then yes. If you use a whole lot of big libraries and GHC-specific stuff, then no.
16:53:07 <benmachine> Welkin: if someone specifies their dependencies imprecisely, they risk breakage, if they specify them precisely, they risk getting left behind
16:53:12 <Welkin> joness: specify yhe version of each library
16:53:14 <levi> But this is not very different from other languages with living ecosystems.
16:53:27 <benmachine> in the sense that no-one will bother to install GHC 6.8 just to run your program
16:53:47 <benmachine> levi: Haskell is particularly volatile I think, e.g. because it has basically zero binary compatibility
16:53:58 <benmachine> I mean, there's no stable ABI
16:54:10 <levi> benmachine: I didn't think we were talking about binary compatibility.
16:54:14 <benmachine> or is that even relevant, I'm not sure
16:54:20 <mgsloan> Even if you use a whole lot of big libraries, you have really good chances of it still working, if you specify version dependencies.  The issue is that the base library is tied to the ghc version, so if something changes there (which is done *very* carefully), then it can break this sort of backwards compatibility
16:55:13 <Welkin> as long as you cehck compatibility with new versions periodically, you can keep it up to date without much effort
16:56:25 <mgsloan> Usually when you need to make changes due to a new version of GHC, your code is better for it, as there was a reason not to do it the old way
16:56:28 <levi> My point is, the stuff that's standardized in The Haskell Report is very stable. The more you move out from there and into compiler- and platform-specific areas, or on fairly new and rapidly developing libraries, the less likely your code is to build without changes in the future.
16:56:55 <mgsloan> Right, where "in the future" means "with all the latest versions"
16:57:04 <mgsloan> it'll still build in the future, you just need to use old versions
16:58:32 <levi> I was assuming that's what "in the future" meant, yeah.
16:59:11 <Hijiri> I missed about 7 minutes of logs because of moving around, but the libraries changing is what matters for RWH
16:59:17 <mgsloan> Yup, it's pretty clear, I just wanted to emphasize the point :)
17:00:28 <levi> To be clear, libraries change over time. Your C programs will break when you attempt to build them against the libraries of the future without applying any changes.
17:00:52 <Hijiri> better libraries also come up
17:01:17 <Hijiri> popular idioms can change a bit too
17:01:48 <levi> When that ceases to happen, we will have either reached software nirvana or Haskell will be dead. :)
17:18:12 <EvanR> im annoyed that i use Integer when Int is practically fine... unless 32bit
17:18:41 <Cale> I'm annoyed that Int is in the Prelude when Integer is usually fine tbh
17:19:04 <EvanR> yeah or more stuff should use Integer
17:19:42 <Rotaerk> just use Integral a => a
17:19:43 <systemfault> Isn't Integer... slower?
17:19:44 <EvanR> its implement as Int for low end numbers isnt it
17:20:49 <Hijiri> but it has to check if it's a low end number
17:20:56 <Hijiri> at least, I think
17:20:59 <Hijiri> as far as I know
17:21:00 <EvanR> yeah
17:21:11 <EvanR> but then it avoids gmp
17:21:13 <benmachine> Integer can be slower, but not /crazy/ slow
17:21:47 <benmachine> I think one underrated danger with Integer is that someone does 2 ^ 2 ^ 2 ^ 10 and you run out of memory
17:22:07 <EvanR> thats if you dont validate untrusted user input
17:22:19 <EvanR> and realize wtf formulas you are using on it
17:22:34 <benmachine> well, there's a few ways you can end up accidentally doing it
17:22:49 <benmachine> I don't think it's that big a deal, to be clear :P
17:22:49 <EvanR> if you had that unchecked and you were using Int, it still seems back to me
17:22:51 <Hijiri> > 2 ^ 2 ^ 2 ^ 10 :: Integer
17:23:15 <Hijiri> > 2 :: Int
17:23:16 <lambdabot>  2
17:23:21 <EvanR> you just DDOSed lambdabot
17:23:21 <benmachine> but it can sometimes be surprising to have an integer vaue that takes hundreds of megabytes
17:23:40 <joness> > 2 ^ 2 ^ 2 ^ 10 :: Integer
17:23:49 <joness> why no timeout
17:23:50 <EvanR> how long would it take to get a hundred megabyte Integer that way?
17:23:54 <benmachine> > 2 ^ 2 ^ 10 :: Integer
17:23:58 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
17:24:16 <Rotaerk> I find the range of Int weird
17:24:21 <benmachine> EvanR: probably not too long. every time you square a number you approximately double its length
17:24:22 <AshyIsMe> lambdabot should have a timeout
17:24:30 <benmachine> AshyIsMe: it does, usually
17:24:34 <EvanR> benmachine: but it takes time to do the calculation
17:24:35 <AshyIsMe> the mueval lib supports timeouts and even memory size limits i think
17:24:44 <joness> is lambdabot restarted in a loop?  and 2 ^ 2 ^ 2 ^ 10 :: Integer did in fact kill it?
17:24:50 <benmachine> EvanR: right, but at most log n ^2 and possibly less
17:24:52 <Rotaerk> Int's range is (-2^29, 2^29-1)
17:24:55 <shachaf> lambdabot has a timeout but Integer arithmetic fails badly.
17:24:58 <AshyIsMe> > 42
17:24:59 <lambdabot>  42
17:25:03 <AshyIsMe> it's not dead
17:25:06 <shachaf> Rotaerk: At least that.
17:25:14 <shachaf> Usually more than that. For instance in GHC.
17:25:17 <Rotaerk> you can only count on that much though, if you're being portable
17:25:25 <AshyIsMe> the calculation is probably just hitting the limits and being cancelled
17:25:25 <benmachine> 2^29 is... not very large
17:25:33 <joness> @let iAmAlive = True
17:25:35 <lambdabot>  Defined.
17:25:36 <shachaf> It's pretty large.
17:25:36 <joness> > 2 ^ 2 ^ 2 ^ 10 :: Integer
17:25:40 <benmachine> > last [1..]
17:25:43 <joness> > iAmAlive
17:25:46 <lambdabot>  mueval-core: Time limit exceeded
17:25:46 <lambdabot>  mueval: signalProcess: permission denied (Operation not permitted)
17:25:46 <lambdabot>  True
17:25:47 <shachaf> Have you ever counted to 2^29?
17:25:51 <EvanR> oO
17:25:54 <benmachine> hah, weird
17:25:55 <Rotaerk> > (minBound :: Int, maxBound :: Int)
17:25:58 <lambdabot>  (-9223372036854775808,9223372036854775807)
17:25:59 <AshyIsMe> woah haha
17:26:01 <shachaf> Yes, lambdabot timeouts with big Integer operations fail badly.
17:26:17 <benmachine> shachaf: no, but it would not take super long for a computer to do so
17:27:13 <orzo> > (-2^29,2^29-1)
17:27:14 <lambdabot>  (-536870912,536870911)
17:27:41 <Rotaerk> > (logBase 2 (minBound :: Int), logBase 2 (maxBound :: Int))
17:27:43 <lambdabot>  No instance for (GHC.Float.Floating GHC.Types.Int)
17:27:43 <lambdabot>    arising from a use of ‘GHC.Float.logBase’
17:27:56 <benmachine> e.g. 2^29 milliseconds is 500k seconds is less than a week, I think
17:28:37 <shachaf> Sure. But milliseconds are tiny.
17:28:45 <Rotaerk> > (logBase 2 . fromIntegral $ (minBound :: Int), logBase 2 . fromIntegral $ (maxBound :: Int))
17:28:46 <lambdabot>  (NaN,63.0)
17:28:56 <benmachine> they're not /that/ tiny
17:29:06 <Rotaerk> so Int is 64-bit in GHC?
17:29:14 <shachaf> In 64-bit GHC Int is 64 bits.
17:29:17 <shachaf> Int is a machine word.
17:29:22 <Rotaerk> hmm k
17:30:01 <benmachine> you can do like a million clock cycles in a millisecond
17:30:27 <shachaf> Sure. But computers are fast.
17:30:35 <shachaf> (I'm not really saying anything useful here so I'll stop.)
17:30:40 <benmachine> shachaf: :P
17:30:41 <Rotaerk> lol
17:30:44 <orzo> it's not reserving a bit?  Did ghc ever reserve a bit as the standard seems suggest with the 2^29 number
17:30:58 <shachaf> The reason the Report only requires 2^30 is to allow for two tag bits.
17:31:09 <benmachine> I'm just bitter because I was testing a bignum library recently by comparing it with machine ints and all my tests broke on 32-bit because the numbers were too big
17:31:16 <shachaf> But GHC doesn't use tag bits that way.
17:31:25 <orzo> did it ever?
17:31:32 <shachaf> I doubt it.
17:31:35 <benmachine> ocaml uses tag bits
17:31:37 <levi> GHC has not always had the same level of dominance in the haskell implemenation scene.
17:31:46 <shachaf> GHC uses tag bits too. But for something else. :-)
17:31:53 <joness> > maxBound :: Int64
17:31:54 <lambdabot>  9223372036854775807
17:31:57 <joness> > maxBound :: Int32
17:31:58 <lambdabot>  2147483647
17:32:03 <benmachine> shachaf: you mean on pointers?
17:32:06 <levi> It used to be a lot of people ran Hugs or something else.
17:32:16 <shachaf> By the way, you can use /msg lambdabot to figure out things about lambdabot without sending them to the whole channel.
17:32:24 <shachaf> benmachine: Yes.
17:32:29 <benmachine> right
17:32:53 <shachaf> The paper on GHC's dynamic pointer tagging is good and readable.
17:33:00 <shachaf> @where ptr-tag
17:33:01 <lambdabot> http://research.microsoft.com/~simonpj/papers/ptr-tag/index.htm
17:33:44 <shachaf> (Not saying this to benmachine in particular, just to anyone interested in the topic.)
17:33:56 <levi> There are still alternate Haskell compilers that are in some state of active or semi-active development, though they tend to not support all the extensions GHC does.
17:34:34 <levi> Most of SPJ's papers (and books) on implementing Haskell and related languages are good and readable.
17:34:49 <shachaf> Yes.
17:35:42 <joness> wat.. simonpj works for microsoft?
17:35:52 <EvanR> microsoft research*
17:36:02 <joness> ah
17:36:30 <joness> somehow i missed that
17:37:01 <joness> still, technically works for microsoft. heh
17:37:13 <levi> Lots of cool folks who do cool stuff work for microsoft.
17:37:15 <EvanR> somehow we probably all technically work for microsoft
17:37:25 <orzo> he didn't when he started his haskell research i don't think
17:37:29 <EvanR> read the EULA
17:37:33 <orzo> heh
17:37:34 <sebastianrkg> In the Haskell XML Toolbox (HXT), I can't seem to write an XmlTree to a String and have the tags of an XML document display
17:37:58 <sebastianrkg> for the following tree: (XML.NTree (XML.XText "Hey what's up") [(XML.NTree (XML.XText "Hey what's upper") [])])
17:38:14 <sebastianrkg> my output with "withOutputXml" is only "Hey what's upper"
17:39:19 <sebastianrkg> does anyone have HXT experience? I'm really at a loss here
17:40:22 <orzo> i'm using package xml atm
17:41:35 <DerisiveLogic> Hey anyone up for coding a little simple project?
17:42:28 <Hijiri> will I be coding it for the lives of dying orphans?
17:42:36 <ClaudiusMaximus> awesome, ghci -interactive-print  -- shame i seem to need -XFlexibleInstances -XOverlappingInstances -XUndecidableInstances to avoid excessive boilerplate
17:43:03 <dfeuer> Hijiri, so if you *were* coding it for the lives of dying orphans, would that convince you to do it , or not?
17:43:30 <Hijiri> I'm not sure, maybe that was irrelevant
17:43:47 <Hijiri> probably not, since I have a class in a couple of hours
17:44:11 <orzo> is there a langauge extension that will let me write top level bindings and have it infer undefined values for them
17:44:25 <orzo> instead of having to write todo stubs
17:44:35 <Hijiri> you could just do banana = undefined
17:44:45 <Hijiri> I don't think there is something that will automatically do that
17:44:46 <levi> sebastianrkg: What's it do when you don't use withOutputXml and just 'print' your value?
17:44:52 <orzo> no imean, i want to specify the type, and not have to add the extra = undefined line
17:45:08 <Hijiri> then no, I don't know of anything like that
17:45:10 <DerisiveLogic> Hijiri: Close enough.
17:45:19 <HeladoDeBrownie> orzo, is the goal to proceed with compilation despite not having defined these values?
17:45:27 <orzo> yeah
17:45:32 <DerisiveLogic> Hijiri: So you up for it?
17:45:33 <joness> why? :(
17:45:47 <HeladoDeBrownie> orzo, i don't believe what you're asking for exists
17:46:08 <orzo> oh well
17:46:26 <joness> there is actually a defer-type-errors-to-runtime flag that I forgot the name of.. but i can't see why it would be useful
17:46:30 <DerisiveLogic> It's just a program I want to build with someone that basically flashes in huge words that says "Work Harder" or "Focus More" in like a split second, except at like 15-45 second intervals.
17:46:36 <joness> and when
17:46:37 <HeladoDeBrownie> this wouldn't be a type error though
17:46:40 <DerisiveLogic> Just to get into the language of Haskell.
17:47:35 <Hijiri> if you're doing it to get more familiar, then why not code it yourself?
17:47:40 <sebastianrkg> levi: I think I might have figured it out
17:47:57 <sebastianrkg> levi: HXT always tries to strip off the top level tree before printing
17:48:02 <Hijiri> although I don't think this would help get a feel for the language as much as some other things
17:48:03 <DerisiveLogic> Hijiri: Because I have no idea as to how Haskell syntax works lol. And I've only been programming for a few months.
17:48:08 <Hijiri> because it will heavily involve GUI libraries
17:48:09 <sebastianrkg> levi: so I was getting empty prints
17:48:20 <DerisiveLogic> Hijiri: Hmm, I guess.
17:48:20 <Hijiri> @where learnhaskell
17:48:20 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:48:26 <Hijiri> DerisiveLogic: have you taken a look at this?
17:48:29 <benmachine> -fdefer-something
17:48:40 <benmachine> -fdefer-type-errors
17:48:41 <Hijiri> -fdefer-coding
17:48:48 <HeladoDeBrownie> -fdefer-deference
17:48:50 <benmachine> well, I guess that would be the flag for deferring type errors
17:49:03 <benmachine> -fdefer-judgement
17:49:07 <DerisiveLogic> Hijiri: I haven't but thanks a lot!
17:49:19 <orzo> are yo uguys proposing names, or are any of those -f options operational?
17:49:29 <HeladoDeBrownie> orzo, we're messing around
17:49:29 <DerisiveLogic> Hijiri: But in any case, you wouldn't be up for it?
17:49:35 <HeladoDeBrownie> well, Hijiri and i are
17:49:41 <Hijiri> DerisiveLogic: no, sorry
17:49:42 <HeladoDeBrownie> also benmachine at the end there
17:49:50 <levi> sebastianrkg: The examples I've seen around for HXT don't seem to be stripping off outer tags, but I haven't used it myself. Sounds like odd behavior.
17:50:00 <benmachine> orzo: -fdefer-type-errors actually exists and is pretty cool
17:50:10 <benmachine> the rest are nonsense
17:50:13 <orzo> that may be, but i'm sure its not what i want
17:50:22 <HeladoDeBrownie> yeah, lacking a binding is not a type error
17:51:29 <athan> Has anyone here messed with TypeLits much? I'm trying to reify normal Strings to a KnownSymbol, but SomeSymbol quantifies out the possability of pattern matching :(
17:51:32 <sebastianrkg> levi: Do you use the IO-monad version? Because it's specifically the non-IO writeDocumenToString that may do it
17:51:40 <athan> I almost want to just TH-staple this together :\
17:51:43 <sebastianrkg> levi: according to this http://tiku.io/questions/689792/hxt-surprising-behavior-when-reading-and-writing-html-to-string-in-pure-code
17:51:43 <levi> Also, you can use _ in place of an identifier you haven't implemented yet and the compiler will tell you what type it is.  But since you already know the type, that's not what you want.
17:53:25 <levi> You could also just stick 'undefined' in place of the name you haven't defined yet instead of writing out the type elsewhere.
17:54:33 <joness> benmachine why is turning haskell into python cool?
17:54:53 * hackagebot utf8-string 1 - Support for reading and writing UTF8 Strings  http://hackage.haskell.org/package/utf8-string-1 (EricMertens)
17:55:13 <orzo> well, i want to specify an interface, and then code and check an algorithm based on that inteface and actually implement the interface later.  It's all very dooable, but everytime i decide i need a new interface i have to add also another line name = undefined, which is obnoxious
17:55:33 <orzo> or name = error "todo"
17:56:13 <sebastianrkg> levi: sure enough, that fixed it. What a powerfully dumb thing for HXT to do :/
17:56:41 <levi> Alas, programming still requires some typing.
17:56:42 <benmachine> joness: it's useful as a development tool to be able to try out bits of your code while writing other bits
17:56:54 <HeladoDeBrownie> sebastianrkg, fyi, the word "monad" in what you just said is superfluous; it's only relevant when talking about Monad operations
17:57:17 <benmachine> similar to how typed holes are useful, except you don't have to work out where to put the holes
17:57:24 <levi> joness: Deferring type errors doesn't make it dynamically typed. It just lets you run the well-typed bits.
17:57:25 <HeladoDeBrownie> although it's a common mistake
17:57:41 <Welkin> is there an easier way to see the results of bit operations? Perhaps printing in binary or hex
17:57:47 <Welkin> I know there is printf
17:58:01 <Welkin> > 0xa2 .&. 0x2a
17:58:02 <lambdabot>  34
17:58:13 <sebastianrkg> HeladoDeBrownie: would just calling it IO be more accurate?
17:58:14 <benmachine> Welkin: I believe the Numeric module has a showHex that might help
17:58:17 <levi> Printing in hex is the time-honored way of doing it.
17:58:19 <HeladoDeBrownie> sebastianrkg, yeah
17:58:33 <sebastianrkg> HeladoDeBrownie: okay, cool. Thanks!
17:58:39 <HeladoDeBrownie> no problem
17:58:47 <Welkin> > showHex $ 0xa2 .&. 0x2a
17:58:49 <lambdabot>  <[Char] -> [Char]>
17:59:03 <benmachine> > showHex (0xa2 .&. 0x2a) ""
17:59:03 <Welkin> :t showHex
17:59:04 <lambdabot> (Show a, Integral a) => a -> ShowS
17:59:04 <lambdabot>  "22"
17:59:24 <Welkin> what is ShowS?
17:59:37 <benmachine> Welkin: it's a trick to help build up large string values
17:59:44 <Welkin> and what is with the ""
17:59:58 <benmachine> Welkin: you may be aware that ++ is such that xs ++ ys is proportional to the length of xs
18:00:14 <HeladoDeBrownie> output from benmachine's evaluation
18:00:15 <BMeph_> Welkin: "type ShowS = String -> String"
18:00:27 <levi> Welkin: ShowS is an implementation detail of the Show type class mechanism for printing stuff.
18:00:33 <benmachine> and so that ((((as ++ bs) ++ cs) ++ ds) ++ es) is bad, because all the short strings go on the end of teh increasingly-long built up string
18:00:57 <benmachine> representing the string xs as the function (xs ++) allows you to avoid this problem
18:01:06 <Welkin> > showIntAtBase 2 intToDigit 0xa2 ""
18:01:09 <lambdabot>  "10100010"
18:01:29 <benmachine> by always building strings from the end to the beginning, as it were
18:01:49 <Welkin> benmachine: yes, I am aware of that behavior
18:01:53 <benmachine> (you're using how (xs ++) . (ys ++) = ((xs ++ ys) ++), but the association is different
18:01:56 <benmachine> )
18:01:57 <Welkin> but where are the strings being appended?
18:02:12 <benmachine> Welkin: well, suppose you're writing a Show instance for some recursive type
18:02:26 <benmachine> it'll basically be appending all the shows for all the leaves
18:02:30 <benmachine> plus some fluff
18:02:33 <ClaudiusMaximus> oh hm.  seems -interactive-print gets reset on :r, which makes it much less nice
18:02:39 <shachaf> A ShowS (or more generally a dlist :: [a] -> [a]) is like a list parameterized on the "nil" value.
18:02:58 <benmachine> Welkin: anyway I'm going to bed, but you should look up difference lists, or dlists, if you want to find out more
18:03:06 <Welkin> benmachine: thanks
18:03:14 <shachaf> I.e. instead of hard-wiring a [] at the end, as in (a:b:c:[]), you write (\nil -> a:b:c:nil)
18:03:54 <shachaf> (I'm not disagreeing with benmachine or anything, his explanation is great. Just mentioning another perspective.)
18:04:54 <shachaf> Since your "list" is parameterized on its nil value, you can just pass another list to the function to replace [] with.
18:05:21 <mniip> how do I ensure that my infinite loop doesn't consume stack or memory resources
18:05:30 <shachaf> The nice thing is that this trick works for all sorts of other things than lists (or monoids).
18:05:50 <glguy> introducing kan-extensions
18:06:04 <joness> mniip it shouldn't unlessw you're unintentionally building up thunks
18:06:08 <shachaf> Yes, for example:
18:06:21 <mniip> joness, yeah that's what I'm afraid of
18:06:27 <shachaf> Instead of using "return" directly in your monadic expressions, just parameterize your actions on a "return" value.
18:06:50 <shachaf> Then you can stick one it at the end, and everything gets right-associated, just like a list.
18:06:54 <joness> mniip show some code?
18:06:59 <shachaf> That's the Codensity trick.
18:07:49 <mniip> joness, hold on, need to make it syntactically correct first :P
18:10:34 <grq> shachaf: is there some reference about it?
18:11:06 <shachaf> grq: Perhaps http://www.janis-voigtlaender.eu/papers/AsymptoticImprovementOfComputationsOverFreeMonads.pdf
18:11:33 <shachaf> Codensity of Free vs. Free is the most direct analogy, probably.
18:12:13 <grq> shachaf: thanks, will have a look
18:12:35 <drewbert> kadoban: Graphics magick bindings exist, but they segfault for trivial programs
18:22:44 <mniip> joness, http://codepad.org/y1Oc7jE4
18:22:46 <mniip> this is the code
18:23:33 <mniip> (BS is ByteString.Char8)
18:24:42 <joness> is the program eating up all the memory?
18:25:10 <mniip> I haven't tested yet acutally
18:26:24 <mniip> ._.
18:29:41 <athan> .-.
18:30:33 <kadoban> drewbert: Well that sucks.
18:30:39 <Pamelloes> Is [] an Applicative?
18:30:48 <athan> Yes
18:30:54 <athan> Pamellos: Two instancew
18:30:56 <athan> instances*
18:31:00 <athan> parallel and cartesian
18:31:06 <athan> cartesian / non-determinism is the default
18:31:08 <joness> I see no issues with your code.  it will build up a string since that is what you're asking it to do (and it is what you want), but that isn't a problem unless you expect your string to be too big too fit your memory.. which would be unusual., someone else feel free to chim in though.. a bit hard to analyze the code you can't run
18:31:12 <trap_exit> is ther a easy way in haskell to check if two regexes are equivalent?
18:31:14 <trap_exit> if it's really slow, it's fine
18:31:18 <athan> to use the parallel instance, wrap every list in ZipList
18:31:21 <Lokathor> I read an article the other day saying that cabal files should always specify a maximum version on each dependency as well as a minimum version. Is this a usual perspective?
18:31:30 <mniip> is there a way to make a thread wait indefinitely
18:31:37 <mniip> GHC is too "smart" to accept 	newEmptyMVar >>= takeMVar
18:31:59 <athan> > [+1, +2, +3] <*> [1,2,3] -- Pamelloes
18:32:00 <lambdabot>  A section must be enclosed in parentheses thus: (+ 1)A section must be enclo...
18:32:04 <athan> :(
18:32:07 <Lokathor> mniip what are you wanting the thread to wait for that also isn't blocking?
18:32:20 <athan> > [(+) 1, (+) 2, +3] <*> [1,2,3] -- Pamelloes
18:32:21 <lambdabot>  A section must be enclosed in parentheses thus: (+ 3)
18:32:26 <athan> > [(+) 1, (+) 2, (+) 3] <*> [1,2,3] -- Pamelloes
18:32:27 <athan> gaa
18:32:28 <lambdabot>  [2,3,4,3,4,5,4,5,6]
18:32:38 <Pamelloes> Hm...
18:32:42 <athan> > ZipList [(+) 1, (+) 2, (+) 3] <*> ZipList [1,2,3] -- Pamelloes
18:32:43 <lambdabot>  ZipList {getZipList = [2,4,6]}
18:32:48 <athan> see?
18:33:02 <mniip> Lokathor, I'm trying to debug a thing here
18:33:13 <mniip> would be nice if the main thread didn't die prematurel
18:33:13 <mniip> y
18:33:22 <Lokathor> true, true
18:33:56 <joness> mniip async is a higher level abstraction over haskell threads
18:34:12 <joness> among the other things it has a way to wait for other threads to finish
18:34:29 <mniip> but
18:34:35 <Pamelloes> athan: Makes sense. I have a function that takes an input of the type ([Bool]->[Bool]->[Bool]). I want to lift (||) to work ZipList style. Is there a way to embed the ZipList wrapper within the l ift?
18:34:38 <mniip> I'm not waiting for the other thread to finish
18:34:48 <mniip> actually it never finishes either
18:35:00 <joness> but you said main thread died prematurely
18:35:10 <joness> dies*
18:36:25 <mniip> yeah
18:37:00 <athan> Pamelloes: Are you sure you don't just want ZipWith? Otherwise, you can do it with a repeat
18:37:09 <athan> because now an infinite list is identity
18:37:12 <athan> so like
18:37:34 <athan> ZipList (repeat (||)) <*> list1 <*> list2 would work
18:38:05 <athan> (identity for the applicative's scope, I mean
18:38:08 <athan> )*
18:38:30 <athan> :t pure :: ZipList [a]
18:38:31 <lambdabot>     Couldn't match expected type ‘ZipList [a1]’
18:38:31 <lambdabot>                 with actual type ‘a0 -> f0 a0’
18:38:31 <lambdabot>     Probable cause: ‘pure’ is applied to too few arguments
18:38:44 <athan> :t pure :: a -> ZipList [a]
18:38:45 <lambdabot>     Couldn't match type ‘a1’ with ‘[a1]’
18:38:45 <lambdabot>       ‘a1’ is a rigid type variable bound by
18:38:45 <lambdabot>            an expression type signature: a1 -> ZipList [a1]
18:38:53 <athan> mer
18:39:02 <mniip> joness, I figured it out by appending a putMVar to the thread that never finishes
18:39:07 <mniip> now, regarding my previous question,
18:39:12 <mniip> yes that code appears to consume ram
18:39:23 <athan> :t pure :: a -> ZipList a
18:39:24 <lambdabot> a -> ZipList a
18:39:30 <athan> erm
18:39:38 <athan> okay
18:39:54 <Hijiri> does it consume more ram the longer it runs?
18:39:55 <Pamelloes> athan: I forgot about zipWith. That will probably work perfectly. Your suggestion with repeat (||) is interesting though!
18:39:55 <athan> > pure 1 :: ZipList a -- Pomelloes
18:39:57 <lambdabot>  No instance for (GHC.Num.Num a1) arising from the literal ‘1’
18:39:57 <lambdabot>  Possible fix:
18:39:57 <lambdabot>    add (GHC.Num.Num a1) to the context of
18:40:04 <athan> :)
18:40:10 <athan> I want to see if it'
18:40:13 <athan> it's legit
18:40:46 <benzrf> yo athan
18:40:52 <benzrf> let me tell you about functors
18:40:57 <athan> Ayyyy
18:40:58 <mniip> Hijiri, yeah
18:40:58 <athan> please
18:41:00 <mniip> that's the point
18:41:06 <athan> Woo!
18:41:11 <athan> The instance is right Pomelloes
18:41:14 <benzrf> athan: first of all do you know bout monoid hoommomorphisms
18:41:20 <athan> pure ~ repeat
18:41:20 <benzrf> *homomorphisms
18:41:27 <benzrf> god that is an annoying word to type
18:41:30 <athan> benzrf: I thik so
18:41:33 <athan> haha
18:41:42 <athan> get a hotkey thing
18:41:51 <benzrf> im thinking i will
18:41:52 <benzrf> christ
18:41:56 <athan> lol
18:42:07 <benzrf> athan: anyway a functor is just a category homomorphism
18:42:21 <athan> ...holy shit. Wow
18:42:49 <athan> I'm gonna go... um
18:42:52 <athan> wow
18:42:52 <benzrf> athan: given categories C and D, a functor F : C -> D maps objects in C to objects in D, and morphisms in C to morphisms in D
18:42:54 <athan> my mind
18:43:24 <benzrf> athan: so if f : A -> B, where f is a morphism of C and A, B are objects of B
18:43:30 <benzrf> athan: then F f : F A -> F B
18:43:48 <benzrf> then you generalize the standard monoid homomorphism rules
18:43:49 <athan> Makes perfect sense
18:43:57 <benzrf> F f . F g = F (f . g)
18:43:57 <athan> hmm
18:44:08 <benzrf> F id_A = id_(F A)
18:44:20 <athan> It's linear
18:44:24 <benzrf> "linear"/
18:44:29 <athan> over composition..?!
18:44:32 <benzrf> oh
18:44:41 <benzrf> a linear function is just a homomorphism on vector spaces
18:44:46 <athan> benzrf: conal's explanation of linear
18:44:49 <benzrf> oh
18:44:50 <athan> HOLY
18:44:51 <athan> OKAY
18:44:52 <benzrf> i dont know what that is :b
18:44:52 <athan> WOW
18:45:01 <athan> I umm
18:45:06 <athan> benzrf: Rain check?
18:45:09 <benzrf> lol
18:45:11 <athan> Holy beans
18:45:30 * athan needs to dweel ._.
18:45:32 <benzrf> is that a serious request or what
18:45:34 <athan> dwell*
18:45:36 <athan> ><
18:45:41 <athan> benzrf: Yes it is
18:45:44 <benzrf> ok!
18:45:44 <athan> please :(
18:45:47 <athan> :D
18:45:58 <athan> Alright, I gotta run
18:46:03 <athan> it's apparently my birthday
18:46:07 <athan> pff, plebs
18:46:19 <benzrf> dang
18:46:21 <benzrf> happy birthday
18:46:29 <Rotaerk> what time of day is it there
18:46:36 <c_wraith> benzrf: no, a linear function need not be a homomorphism.  You can always lose dimensions
18:47:26 <Lokathor> when generating a cabal file, i'm working on a project that will be used to play games over the web. should I go with "game" or "web" as my category? or does it not matter too much?
18:47:30 <benzrf> c_wraith: oh
18:47:39 <orzo> is it possible to use a newer base with an older ghc?  and if not, is there any quick way to map between base version and ghc version?
18:47:42 <benzrf> c_wraith: is there a formal notion of a homomorphism between vec spaces
18:47:45 <c_wraith> Lokathor: category doesn't matter at all unless you upload to hackage.
18:47:48 <shachaf> c_wraith: Well, "homomorphism" can mean whatever you want it to, mostly.
18:47:53 <benzrf> c_wraith: i dont really know linear algebra :D
18:48:11 <Lokathor> c_wraith: I'll probably use github, so okay
18:48:20 <Hijiri> orzo: no, ghc comes with its base
18:48:30 <c_wraith> Lokathor: in general, it'd probably be filed under game, though
18:48:34 <Hijiri> or at least, it would be very difficult, I'm not sure if it would be possible
18:48:41 <shachaf> But I think the most usual meaning of "homomorphism between vector space" is a linear map.
18:48:41 <Hijiri> It would be much easier to just install newer ghc
18:49:04 <geekosaur> it's not really possible
18:49:07 <c_wraith> oh.  I thought homomorphism would imply reversible.  Silly me.
18:49:13 <benzrf> c_wraith: lol
18:49:16 <geekosaur> ghc is way too tightly tied to its runtime, which is part of base
18:49:21 <benzrf> c_wraith: i believe you mean isomorphism
18:49:37 <shachaf> Probably thinking of isomorphism. Or homeomorphism. All those words are terrible.
18:49:48 <Hijiri> isobolism
18:50:04 <c_wraith> fun things to learn in linear alg: homogenous and homogeneous have *nothing* in common!
18:50:25 <benzrf> c_wraith: a homeomorphism is a topological isomorphism!
18:50:51 <c_wraith> what's the "same" in a homomorphism?
18:50:58 <benzrf> c_wraith: hm?
18:51:03 <shachaf> c_wraith: "homogenous" is a thing?
18:51:18 <c_wraith> shachaf: not in math! but it is in other contexts.
18:51:22 <shachaf> Where?
18:51:40 <shachaf> The structure is the same, I suppose.
18:51:45 <shachaf> It's a silly word.
18:51:46 <sweetyams> zygohistomorphic prepromorphism
18:52:12 <c_wraith> http://grammarist.com/usage/homogenous-homogeneous/
18:52:31 <benzrf> theres anabolism and catabolism and metabolism
18:52:36 <benzrf> why not hylobolism!
18:52:46 <c_wraith> parabolism?
18:52:46 <benzrf> i tried asking ##biology but nobody knew =[
18:52:53 <Rotaerk> cannibalism?
18:53:01 <benzrf> cannimarphism
18:53:36 <benzrf> i decree that the new term for higher order function be "cannimarphism"
18:54:38 <c_wraith> Oh.  So the sameness (since the homo- prefix means "same") involved in making linear functions homomorphisms is...  that the spaces on each end of the arrow are linear spaces.
18:54:43 <geekosaur> there's actually a bunch of mechanisms like that all with their own names, modes of operation, and things that trigger them...
18:55:12 <shachaf> c_wraith: Well, I suspect "structure-preserving" comes into it.
18:55:15 <c_wraith> linear transformations preserve linear structure.
18:55:22 <shachaf> Right.
18:55:50 <c_wraith> I suppose mapping all points to the origin is a special case of preserving linear structure.
18:56:10 <tac> sometimes morphisms don't preserve structure. Sometimes they pull structure back.
18:56:22 <c_wraith> tac: those ones wouldn't be homomorphisms, then
18:56:32 <tac> sometimes they do both!
18:56:38 <shachaf> Anyway, that's all silly now that we've invented categories.
18:56:49 <shachaf> We know what homomorphism really means: An arrow in your favorite category.
18:56:59 <tac> a ring homomorphism preserves multiplication, addition, and identity, but it also pulls back ideals.
18:57:51 <shachaf> All this vocabulary pulls back people's ideals of learning maths.
18:58:09 <exio4> it's actually pretty cool that everything has a name
18:58:41 <Hijiri> is there an abstraction for things that always have a name
18:59:01 <ij> tac, Pulls back?
18:59:56 <tac> ij in many categories, the arrows are "structure-preserving maps", but they do allow you to take something to do with the codomain and find a similar one on the domain
19:00:25 <tac> For a continuous function f : A -> B, open subsets of B are "pulled back" to open subsets of A
19:00:46 <tac> meaning if U is an open subset of B, then f^{-1}(U) is an open subset of A (where f^{-1} means "the inverse image")
19:04:12 <ij> Sort of like a bijection? I'ven't read anything about CT.
19:04:43 <benzrf> ij: well no that's the definition of a continuous function
19:04:57 * hackagebot witty 0.0.4 - A network server to show bottlenecks of GHC  http://hackage.haskell.org/package/witty-0.0.4 (KazuYamamoto)
19:10:23 <mniip> finally doesn't consume ram http://codepad.org/Z3nsR5BN
19:10:42 <dfeuer> There are also definitions of continuous functions in terms of filters, and if you accept AC, nets work well too.
19:10:52 <Pamelloes> What happens if you take the length of something with a length larger than an Int?
19:11:00 <jle`> Pamelloes: overflow :O
19:11:16 <Pamelloes> jle`: Is there no length that uses Integer?
19:16:52 <HeladoDeBrownie> @type genericLength
19:16:53 <lambdabot> Num i => [a] -> i
19:17:12 <HeladoDeBrownie> though i've heard suggested that if you have a list whose length exceeds an Int's capacity, you probably shouldn't be using a list
19:17:29 <HeladoDeBrownie> (and if you need to compute its length)
19:18:40 <tac> what a terrible name for a function :(
19:19:11 <HeladoDeBrownie> those abound
19:19:20 <joness> I highly doubt you can allocate an array the size of a word.. nevermind a list
19:19:34 <joness> s/word/Int/
19:19:58 <Pamelloes> HeladoDeBrownie: Hehehe very true. If my program creates a list with a length larger than 2^63-1, I will be in trouble. However, I'm using Integer for extensibility in other places so I'm keeping it here for extensibility's sake.
19:20:04 <benzrf> > length (replicate maxBound 9))
19:20:05 <lambdabot>  <hint>:1:30: parse error on input ‘)’
19:20:06 <benzrf> > length (replicate maxBound ())
19:20:09 <joness> well you can malloc it, but it won't actually be allocated
19:20:10 <lambdabot>  mueval-core: Time limit exceeded
19:20:12 <benzrf> awh
19:20:34 <Rotaerk> Pamelloes, how does using Integer promote extensibility?
19:20:47 <Pamelloes> joness: If you're running a 32 bit program on a 64 bit os, you could do it ;)
19:21:06 <Pamelloes> Rotaerk: It doesn't impose a max or min bound.
19:21:48 <Rotaerk> Pamelloes, could you just use Integral i => i instead?
19:22:02 <Rotaerk> then if they actually need the large numbers, they can use Integer, but use Int otherwise
19:22:40 <HeladoDeBrownie> Int's size isn't strictly determined by the architecture, and may not be at all; however, it is guaranteed a certain range: http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html
19:24:05 <Pamelloes> Rotaerk: I'm creating an interpreter for a programming language so I chose to use Integer over Int to not have limits. Using (Integral i) would require I still use the generic forms and not really change anything since the functions generating the Integral generate an Integer.
19:24:36 <Rotaerk> I see
19:25:08 <Pamelloes> HeladoDeBrownie: Very true. If your ghc implementation chooses to use 30 bits (because f u logic), then you could definitely fit an array with a length larger than Int in a reasonable amount of memory.
19:25:52 <HeladoDeBrownie> i can definitely see there being a good reason for not using a power of 2, like using some bits to tag the value.
19:25:55 <Welkin> HeladoDeBrownie: how do you specify Int32, Int64, etc?
19:26:05 <HeladoDeBrownie> Welkin, using the types of those names defined in base.
19:26:08 <Welkin> I know GHC uses Int32, Int64
19:26:14 <Welkin> is that it?
19:26:17 <HeladoDeBrownie> yeah
19:26:19 <Welkin> or does it need some special syntax?
19:26:25 <HeladoDeBrownie> oh, in that very module i linked in fact :)
19:26:40 <Welkin> oh, here is a nice question
19:26:47 <HeladoDeBrownie> no, literal syntax is generic enough to include them
19:26:54 <HeladoDeBrownie> you just need to write the correct type where applicable
19:26:56 <Welkin> how does GHC pack the memory of a data instance?
19:26:57 <HeladoDeBrownie> @type 12
19:26:57 <lambdabot> Num a => a
19:27:08 <rjsalts> So the Integer type is not a base type?
19:27:11 <HeladoDeBrownie> about that, i have no idea
19:27:12 <HeladoDeBrownie> rjsalts, it is
19:27:18 <Pamelloes> Hm, never occured to me that you could use bits to tag the integer. I guess that's why I didn't write the specification....
19:27:25 <Welkin> data Node a = Node Int32 Char Bool
19:27:53 <Welkin> will that be packed as (4 bytes, 4 bytes, 4 bytes) 12 bytes?
19:27:56 <HeladoDeBrownie> rjsalts, even better, it's defined in the haskell language report, so it appears in all compliant haskell implementations.
19:28:14 <Welkin> er, ignore the a in Node a
19:28:17 <Hijiri> Welkin: maybe not for one-constructor data, but constructors are stored as ints I think?
19:28:23 <rjsalts> HeladoDeBrownie: but it's not in http://hackage.haskell.org/package/base-4.6.0.1/docs/?
19:28:26 <Hijiri> or some kind of unsafe numbery value
19:29:16 <Hijiri> and then it has an array(?) of untyped things, and by checking the constructor you know what's in there
19:29:19 <Welkin> I meant the whole structure, not the constuctor
19:29:23 <Hijiri> array of untyped pointers to things
19:29:23 <HeladoDeBrownie> rjsalts, i think it appears only in Prelude.
19:29:28 <Hijiri> I'm not sure it's an array
19:29:44 <Hijiri> maybe the ghc channel would know better
19:29:54 <Welkin> struct Node { int32_t a; char b, bool c }
19:30:09 <Hijiri> not char b, bool c
19:30:20 <Hijiri> I think something like void ** members
19:30:25 <Welkin> Hijiri: typo
19:30:40 <HeladoDeBrownie> for clarification, ghc is written in haskell, not c
19:30:44 <Welkin> yes
19:30:47 <HeladoDeBrownie> (for those who didn't know)
19:30:47 <Hijiri> The RTS isn't in haskell
19:30:53 <Welkin> I am using an example of how the c compiler packs data
19:31:02 <Welkin> I am wondering how ghc packs data
19:31:07 <HeladoDeBrownie> Hijiri, ah, is that the part that handles this representation?
19:31:13 <Hijiri> I think so
19:31:23 <Welkin> with padding to align to 32-bit (or 64 bit) boundaries
19:31:48 <Welkin> or with no padding
19:34:44 <luite> Welkin: that 'Node Int32 Char Bool' takes 4 words, one for the header (pointer to the entry function) and three for the fields
19:35:19 <luite> Welkin: strict fields can be unpacked, but GHC only uses whole words (i.e. 8 bytes on 64 bit) for those
19:36:02 <Welkin> so Node will take up 4x8 bytes?
19:36:07 <luite> Welkin: but normally this would be stored as four pointers
19:37:06 <luite> Welkin: yes, but then yu only have pointers to teh fields, an Int32 takes 2x8, the Bool 1x8 (although a statically allocated value can be used), Char 2x8
19:38:37 <Hijiri> I think this page is relevant https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects
19:41:02 <Welkin> thanks luite and Hijiri
19:41:30 <alpounet> Welkin: http://blog.johantibell.com/2011/06/computing-size-of-hashmap.html & http://blog.johantibell.com/2011/06/memory-footprints-of-some-common-data.html might help
19:46:43 <Welkin> alpounet: that does look helpful, thanks
19:47:48 <augur> any do haskell for cloudy things?
19:51:19 <tavoe> I'm trying to configure xmonad, and the spawnHere function doesn't work the way I would expect.
19:52:09 <tavoe> I expect it to produce a string containing the stdout of the code it called, but instead it always produces unit.
19:53:04 <geekosaur> none of the spawn* commands produce output. nor can they.
19:53:49 <geekosaur> XMonad.Util.Run has a few things that can produce stdout.
19:54:57 <tavoe> I'm able to use runProcess to get stdout, but the function I've written results in IO(), and I'm having trouble  coerce it into X()
19:55:00 * hackagebot HStringTemplate 0.8.1 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.8.1 (SterlingClover)
19:57:50 <tavoe> I think I just figured it out.
19:58:22 <tavoe> The trick is, the type of a monad is the first value it produces, which is something that has eluded me up until now
19:58:58 <geekosaur> runProcess will not work the way you want
19:59:09 <geekosaur> it will start the process, but it will die with an exception
20:02:08 <geekosaur> (I explained why in #xmonad but you seem to be ignoring that channel now)
20:05:01 * hackagebot sbv 4.0 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-4.0 (LeventErkok)
20:06:47 <bananagram> :t unzip
20:06:48 <lambdabot> [(a, b)] -> ([a], [b])
20:14:11 <htebalaka> is it not possible to have an unlifted type implement a typeclass?
20:15:13 <htebalaka> i'm trying to implement `Given (State# RealWorld)` from Data.Reflection
20:16:30 <jle`> :t uncurry id
20:16:31 <lambdabot> (b -> c, b) -> c
20:16:33 <jle`> :t curry id
20:16:34 <lambdabot> a -> b -> (a, b)
20:16:49 <htebalaka> well not really implement the instance itself, but i want to pass a RealWorld token around
20:30:03 * hackagebot maam 0.1.0.0 - A monadic framework for abstract interpretation.  http://hackage.haskell.org/package/maam-0.1.0.0 (DavidDarais)
21:00:25 <mniip> does `f x = case x of` optimize the same way an actual pattern matching on f would?
21:00:41 <c_wraith> mniip: they usually get turned into identical core
21:00:51 <c_wraith> mniip: (also, case is actual pattern matching)
21:01:20 <mniip> the reason I'm asking is because I have to use the same local function from multiple pattern maches
21:01:22 <c_wraith> mniip: in fact, case is the only pattern-matching construct in core
21:05:35 <mniip> hmm
21:06:01 <mniip> how would I go about converting String into a ByteString.Word8 while encoding utf-8
21:06:43 <Welkin> encodeUtf8
21:06:48 <Welkin> :t encodeUtf8
21:06:49 <lambdabot> Not in scope: ‘encodeUtf8’
21:07:00 <Welkin> :t Data.ByteString.Word8.encodeUtf8
21:07:01 <lambdabot> Not in scope: ‘Data.ByteString.Word8.encodeUtf8’
21:07:09 <mniip> ok found it
21:07:20 <Welkin> http://hackage.haskell.org/package/text-1.2.0.4/docs/Data-Text-Encoding.html#v:encodeUtf8
21:07:27 <Welkin> in Data.Text.Encoding actually
21:26:06 <sssilver_> Hey guys, would trying to learn haskell without a degree in math be a futile attempt?
21:26:35 <EvanR> no
21:26:46 <EvanR> but you may end up with one
21:27:09 <sssilver_> no or I may end up with one?
21:27:27 <EvanR> but means "and"
21:28:14 <sssilver_> ‘and’ with two expressions where one equals false is always false
21:28:40 <EvanR> both expressions have yet to be proven one way or the other
21:28:54 <sssilver_> one expression is just ‘no'
21:29:10 <EvanR> ... actually, no, you dont need a degree in math to learn haskell i can prove it
21:29:35 <platz> sssilver_: here's about all the math you need (it's stuff you learned in high school (or are learning)) http://www.vex.net/~trebla/haskell/prerequisite.xhtml
21:30:06 * hackagebot egison-tutorial 3.5.0 - A tutorial program for the Egison programming language  http://hackage.haskell.org/package/egison-tutorial-3.5.0 (SatoshiEgi)
21:30:26 <platz> in other words, you need to know how to "plug things in"
21:30:37 <EvanR> thats about it
21:30:37 <sssilver_> platz: I know that much math an even a bit more. But some of my colleagues tell me that I need really advanced math to ‘get’ Haskell
21:30:50 <sssilver_> like category theory or np-completeness or type theory
21:30:53 <sssilver_> or whatever there is
21:31:11 <sssilver_> of course by learning haskell I don’t imply its syntax
21:31:13 <levi> sssilver_: People sometimes use math jargon, but the concepts as they're used in haskell are very 'gettable' without getting into the jargon.
21:32:16 <jle`> you don't really need any advanced math to get haskell
21:32:19 <jle`> or any category theory
21:32:28 <jle`> or to do any practical real-world haskell
21:32:46 <jle`> i'm not sure where this misconception came about
21:32:52 <EvanR> "Monad"
21:33:15 <levi> You can also use the same jargon to describe just about *any* programming language, it's just that Haskell makes it a bit easier for people who understand the mathematical stuff to model it directly and write programs with it, rather than just using it to describe how a language works in abstract.
21:33:58 <platz> sssilver_: haskell is used to examine some of those things.  but you don't need any of that stuff to master writing programs
21:34:02 <levi> Which is a really cool thing, but not directly related to the typical practice of writing Haskell (or any other programming language).
21:35:04 <sssilver_> I see
21:35:08 <sssilver_> thanks for your input!
21:35:12 <sssilver_> super helpful
21:35:13 <EvanR> sssilver_: basically, stop worrying, and just try it
21:35:17 <levi> In the process of learning Haskell, you may become interested in and distracted by the math stuff that other people are talking about, because it's actually pretty interesting.
21:35:53 <sssilver_> fair enough
21:36:00 <levi> And not quite as daunting as the unfamiliarity of the jargon makes it seem.
21:36:12 <sgronblo> Haskell has definitely got me more interested in math
21:36:19 <EvanR> in fact, ignoring the math jargon is probably a good idea, just take haskell for what it is while youre learning it
21:36:38 <Welkin> jle`: there seems to be a widespread belief that haskell is an obscure academic language with no practical use
21:37:03 <sssilver_> my goal with haskell is to become a better programmer overall in the other languages I already know and use (C++/Python).
21:37:15 <sssilver_> I don’t intend at this point to use it for anything practical
21:37:19 <Welkin> people either seem to think "you need to be a math genius to use that" or "that's not useful"
21:37:32 <EvanR> i think you will end up being able to wrangle c++ and python better
21:37:35 <EvanR> despite those systems
21:37:41 <jle`> sssilver_: well then you don't need any advanced math :)
21:37:42 <sssilver_> it just seemed interesting because it seems to put so much emphasis on things that I feel I suck at
21:37:45 <Welkin> haskell has definitely made me a better programmer
21:37:50 <sssilver_> like recursions >.<
21:37:51 <sgronblo> if you wanna move slowly you might wanna try Rust first
21:38:05 <sssilver_> I tried Rust, I’m OK at it now
21:38:12 <sssilver_> “OK” as in, I implemented a tetris
21:38:17 <sssilver_> and it was super fun
21:38:21 <platz> It's not all translatable though.. imho there is a lot that isn't easily replicable in other langs
21:38:24 <levi> Haskell is *at the same time* a practical programming language that can be learned and used without having to engage with it as anything other than a programming language, and *also* an expression of some of the fundamental building blocks of programming languages in a very pure state.
21:38:49 <Welkin> I find that haskell is easier for me to use than any other language now
21:38:53 <EvanR> platz: youll have learned what difficulties are actually difficult with those other systems that dont act like haskell in certain ways
21:39:02 <levi> So you get a mix of people who are interested in abstract programming language theory stuff and people who are interested in leveraging a powerful language to write cool programs.
21:39:20 <platz> EvanR: yes that much is true
21:39:47 <sssilver_> is there any notable software written on haskell with a decent amount of SLOC?
21:40:00 <Welkin> sssilver_: GHC, pandoc
21:40:07 * hackagebot semigroups 0.16.1 - Anything that associates  http://hackage.haskell.org/package/semigroups-0.16.1 (EdwardKmett)
21:40:08 <Welkin> xmonad
21:40:24 <levi> git-annex
21:40:25 <sssilver_> I know xmonad
21:40:30 <Axman6> Facebook's Haxl
21:40:41 <Axman6> most of the code for that will not be public though
21:40:43 <Welkin> sssilver_: haskell is concise, so lines of code is not a good metric
21:40:46 <levi> darcs
21:40:47 <Astrocoder> psy: 강남 스타일!
21:41:44 <platz> FPComplete's website is probably pretty big by now
21:42:08 <platz> though it's closed source
21:43:17 <Welkin> yesod is quite a large library (with tons of dependencies)
21:43:20 <levi> There are a number of other reasonably-sized private Haskell code bases.
21:43:21 <Welkin> er, framework
21:43:28 <sssilver_> see what I struggle with conceptualizing is how can something like World of Warcraft be programmed statelessly. I guess I need to learn it before I can think about it.
21:43:46 <sssilver_> super interesting
21:43:54 <Welkin> sssilver_: the state exists, it just doesn't mutate
21:44:34 <EvanR> sssilver_: game programming is an interesting frontier in functional programming, one place to check out is #haskell-game
21:44:40 <platz> well, it mutates but in a model you build on top of the base, pure language
21:45:03 <sssilver_> yeah but the state changes right… you were alive and now you’re dead. You had 100 health, now someone attacked you and you have 70 health
21:45:05 <Welkin> platz: of course, the computer itself is a state machine that mutates data
21:45:07 <EvanR> it doesnt necessarily have to do with explicit mutable state
21:46:01 <EvanR> the interaction between state, mutation, IO, concurrency, its all up in the air, how its best to think of these things
21:46:52 <Welkin> sssilver_: a new copy of the state is created with the updated information
21:47:08 <platz> it's really hard to describe; becomes clearer after doing some exercises
21:47:35 <Welkin> sssilver_: so the old state still exists, but it is a different piece of memory
21:48:12 <sssilver_> Welkin: but isn’t that effectively what happens with imperative programming? You change this.health to be this.health = 70
21:48:14 <platz> and if you don't reference the old state at all the GC cleans it up
21:48:29 <Welkin> sssilver_: no, because that is changing  the existing data in-place
21:48:36 <sssilver_> anyway, this convo can’t have much substance to it because I’m totally ignorant
21:48:52 * EvanR throws in imperative programming as one of those things that need to be reconsidered along with state and etc
21:49:39 <EvanR> imperative isnt necessarily one to one correspondence with the C programming virtual machine
21:49:47 <levi> sssilver_: This ties in along with what I was saying earlier about how you can understand *all* programming languages in the same terms that Haskell is described in.
21:51:44 <EvanR>  stop worrying and try it out
21:51:58 <sssilver_> already!
21:52:01 <sssilver_> :)
21:52:06 <sssilver_> thanks guys, you’re great
21:54:52 <jle`> sssilver_: happy haskelling :)
21:55:07 <raydlor> :-)
22:09:34 <athan> hmm. How can I metaprogram with template haskell if type constructors aren't first class values?
22:10:40 <sclv> athan: what do you mean?
22:10:56 <athan> sclv: like...
22:11:05 <athan> > runQ [| "foo" |]
22:11:07 <lambdabot>  <hint>:1:7: parse error on input ‘|’
22:11:11 <athan> :(
22:11:23 <athan> no TH in lambdabot yet, aie see
22:11:55 <athan> sclv: I would like to be able to generate types, composed of other existing types
22:12:12 <athan> ContT takes in a value - a type constructor
22:12:13 <sclv> so yes, you can do that
22:12:22 <athan> ...which isn't a data constructor :\
22:12:34 <gamegoblin> jle`: lol@hacker news post title
22:12:43 <athan> @type ContT
22:12:44 <lambdabot> ((a -> m r) -> m r) -> ContT r m a
22:12:48 <athan> erm
22:12:49 <athan> shoot
22:13:00 <athan> derp
22:13:02 <athan> @type ConT
22:13:03 <lambdabot>     Not in scope: data constructor ‘ConT’
22:13:03 <lambdabot>     Perhaps you meant one of these:
22:13:03 <lambdabot>       ‘Cons’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
22:13:14 <athan> @type (Language.Haskell.TH.Syntax.ConT)
22:13:15 <lambdabot> Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Type
22:13:21 <athan> Ahh!
22:13:38 <athan> it's a Name! shoot... back to the drawing board, sorry sclv
22:14:02 <glguy> Athan:  there's a whole bunch of types for expressions and types and patterns and so on
22:14:15 <sclv> yeah -- the api is very complete. its just a maze, because haskell has a rich syntax
22:14:26 <athan> glguy: I spaced out about `''Foo` :\
22:14:33 <athan> Man...
22:14:37 <athan> that's awesome
22:14:51 <athan> this feels a lot more... possible... than type hackery
22:14:54 <sclv> i usually find my best bet is to turn a concrete instance of something I want to write into a syntax tree
22:15:10 <sclv> and then look at the generated tree to discover the correct constructors
22:15:27 <sclv> athan: well, what are you looking to write? by TH or type hackery?
22:15:28 <athan> ahh wow
22:15:52 <athan> sclv: Rgiht now it's pretty simple..
22:16:04 <athan> I want a legitimate string promotion function
22:16:14 <athan> to a GHC.TypeLits.Symbol type
22:16:40 <sclv> this approach won't work i think.
22:16:42 <athan> `someSymbolVal` just returns a (useless) existential :(
22:17:04 <athan> sclv: Can you tell me why? :)
22:17:10 <sclv> given a particular string you can write the symbol type for it by hand
22:17:22 <sclv> TH can automate that, but its easy enough that's not the problem
22:17:27 <sclv> you want to do it for _any_ string.
22:17:47 <sclv> so you want a function whose result type (a symbol type) depends on a value
22:18:09 <sclv> that's the sort of dependency we don't really have in haskell
22:18:28 <sclv> we have Value -> Value, Type -> Value, and Type -> Type, but not Value -> Type
22:18:55 <sclv> the thing is existentials aren't useless if you use them right -- its just a pain :-)
22:19:49 <jle`> gamegoblin: oh did someone post my article on hacker news
22:19:54 <jle`> why do people keep on doing that lol.
22:20:12 <gamegoblin> jle`: yes someone did
22:21:18 <sclv> athan: does that sort of make sense?
22:21:52 <sclv> now say I have a SomeSymbol
22:22:51 <athan> Oh hmm, okay
22:22:53 <sclv> I can write a function that says case (x : SomeSymbol) of (SomeSymbol _) -> ...
22:23:02 <athan> I think I've seen some constructive uses for them :\
22:23:17 <sclv> and anywhere in that ... I can use the concrete thing I've pattern matched out of SomeSymbol
22:23:26 <athan> ?
22:23:42 <athan> I get the "skolem" type variable error whenever I try :\
22:24:03 <sclv> you can't let the type of thing in that expression escape into what's returned _out_ of the case
22:24:14 <sclv> so it ends up forcing you to continuation pass more stuff as you go
22:24:29 <sclv> or wrap your result up in an existential too
22:24:52 <athan> oh wow
22:24:57 <sclv> like imagine that in the "..." it just said "hello"
22:25:01 <athan> that's awesome!
22:25:05 <sclv> you would always get back the string "hello" and no errors, right?
22:25:12 <sclv> so this is just an extension of that notion
22:25:28 <athan> hmm
22:25:30 <athan> man!
22:25:37 <athan> wow, thank you!
22:25:38 <yarou> jle`, cool post, i've had that intuition in the back of my mind for a very long time
22:26:35 <athan> I was wondering... why can't we automate TH splicing? Or splice around the content in a variable/term?
22:26:56 <athan> It would just be so nice to map a metaprogramming function over a list of terms
22:27:10 <sclv> i'm not sure what you mean
22:27:32 <athan> sclv: Something like `x -> $( [| x |] )`
22:28:19 <athan> oh wiat...
22:28:20 <athan> wtf
22:28:22 <athan> ><
22:28:36 <jle`> yarou: thanks :)
22:29:38 <sclv> haskell has a phase distinction. that works perfectly well, but it works on the quoted symbol x, not the value that symbol will refer to at runtime, which we can only discover when running the program.
22:30:02 <athan> Oh!!
22:30:03 <athan> crap!
22:30:06 <yarou> maybe it helps that i don't have a formal cs background, well...not entirely true since i took many CS courses but never declared it as a major
22:30:08 <athan> wow that makes a lot of sense
22:30:11 <athan> thank you sclv
22:30:32 <sclv> no prob -- the concepts take a while to sink in, and its always confusing at first
22:35:09 * hackagebot networked-game 0.1.0.1 - Networked-game support library  http://hackage.haskell.org/package/networked-game-0.1.0.1 (EricMertens)
22:42:28 <dramforever> now I have this function:
22:42:46 <dramforever> (>+-) :: Piece -> ([Piece], [Token]) -> ([Piece], [Token])
22:42:46 <dramforever> p >+- ~(ps, ts) = (p : ps, ts)
22:42:47 <dramforever>  
22:43:05 <dramforever> parseTokens' (Command c : ts) = CommandPiece c >+- parseTokens' ts
22:43:35 <dramforever> Now I have a problem. parseTokens (Command "blah" : undefined) = undefined
22:44:25 <dramforever> but I expect it to be (CommandPiece "blah" : _|_ , _|_)
22:44:58 <dramforever> Can anyone help me tweak the strictness in that? Thanks
22:49:19 <johnw> dramforever: parseTokens' evalautes 'ts' to whnf
22:49:55 <johnw> oh, hm
22:50:59 <dramforever> johnw: yes
22:52:11 <dramforever> johnw: but that shouldn't be the problem
22:52:16 <johnw> right
22:52:19 <johnw> I see it now
22:52:21 <johnw> dunno
22:53:21 <dramforever> johnw: actually CommandPiece "foo" >+- _|_ = (CommandPiece "foo" : _|_, _|_)
22:54:21 <trap_exit> jle`: how can I use the IO monad to print strings?
22:54:37 <johnw> trap_exit: do you mean putStrLn?
22:54:38 <trap_exit> jle`: congrats on https://news.ycombinator.com/item?id=8933528 hitting top story on news.yc
22:54:41 <dramforever> trap_exit: why not putStr or putStrLn
22:54:57 <jle`> heh. i didn't even realize it was there until recently
22:54:59 <jle`> who posts these v.v
22:55:10 * hackagebot warp 3.0.7 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.7 (KazuYamamoto)
22:55:15 <jle`> the post wasn't really intended for a general audience and i think it's pretty bad for people who don't use haskell >_>
22:55:22 <johnw> jle`: I had something get posted many years after the fact even
22:55:31 <trap_exit> jle` , johnw , dramforever: I like your argument on "separation of TYPE" from "the Monad class"
22:55:51 <trap_exit> jle`: yeah, there's some poor haskelll newb in the comments section talking about how he's all confused
22:57:54 <dramforever> Does anyone know some good articles on strictness?
23:04:57 <jle`> trap_exit: yeah i don't know how to address this
23:05:04 <jle`> i'll probably add an addendum
23:05:27 <trap_exit> jle`: here's what you need to do:
23:05:45 <trap_exit> jle`: when people load up that blog post, you ask them to implement the maybe monad, the state monad, the writer monad, and the reader monad from scratch
23:05:52 <trap_exit> if they succeed, they've earned the right to read your blog post
23:05:58 <trap_exit> otherwise, it's too advanced for them
23:06:59 <johnw> dramforever: for me, it is (CommandPiece "blah" : _|_ , _|_)
23:07:01 <johnw> how are you testing?
23:07:05 <jle`> trap_exit: i'll consider it :)
23:07:07 <johnw> https://gist.github.com/d778ef345a819dc990df
23:07:21 <jle`> it sounds kind of funny but i kind of do that over again all the time
23:07:22 <dramforever> johnw: I'll give you the full code
23:07:51 <jle`> when i load up ghc and i don't have mtl loaded
23:07:55 <jle`> i just write them out myself
23:08:07 <jle`> because i don't want to bother installing mtl globally >_>
23:08:08 <jle`> *ghci
23:08:27 <jle`> i've probably written those instances several dozen times at this point
23:09:04 <AshyIsMe> hmm, im starting to think the delays in lambdatwit responses have more to do with the way twitter distributes notifications than limitations in the code
23:09:05 <lpaste> dramforever pasted “johnw: here's parser.hs” at http://lpaste.net/119039
23:09:34 <lpaste> dramforever pasted “and here's Lexer.hs” at http://lpaste.net/119040
23:09:42 <AshyIsMe> just got an email from twitter to the lambdatwit bot saying "new mention from someone!" but it hasnt come through in the api yet and doesnt show up on the @lambdatwit page
23:10:12 <johnw> dramforever: won't the case match of parseTokens' toks cause the snd part of the tuple to be evaluated, in order to check whether it's []?
23:10:37 <dramforever> Ha!
23:11:39 <dramforever> johnw: Oh thanks
23:11:54 <johnw> sure thing
23:12:00 <dramforever> I thought the problem is in parseTokens, not the one with a prime
23:12:43 <dramforever> s/I thought/Oh.../
23:51:17 <triptec> hello, is there anyone who know how to use "timestamp without timezone" with yesod 2.0
