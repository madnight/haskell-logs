00:00:09 <johnw> ThreeOfEight: I think we're saying the same thing
00:00:12 <chrisdotcode> Can somebody help me with a really simple where clause problem? http://lpaste.net/117979
00:00:16 <ThreeOfEight> so if you have a very long list, foldr will give you a very long expression
00:00:23 <ThreeOfEight> so would foldl
00:00:35 <ThreeOfEight> but foldl' can enforce strictness in the accumulator, giving you a constant space evaluation
00:00:35 <calvinx> I see, so list comprehension is essentially just sugared map.
00:00:35 <breadmonster> calvinx, I think it's the more commonly used pattern, so it's easier to recognize.
00:00:56 <calvinx> breadmonster: ok.
00:00:59 <ThreeOfEight> johnw: it is similar, but there really isn't anything like tail-recursive optimisation in Haskell
00:01:10 <ThreeOfEight> it's just a very fundamental property of how evaluation works
00:01:16 <johnw> ThreeOfEight: yes, I know.  What I was really asking you about was this statement: you cannot have something like foldl' for foldr
00:01:22 <chrisdotcode> Basically, my problem is wanting to re-use a function in multiple where-clauses of the same function (but different patern matches). It seems like you currently need to duplicate the where body for each case.
00:01:29 <ThreeOfEight> johnw: oh, never mind then :)
00:01:31 <johnw> which I think is related to the fact that it's not tail recursive?
00:01:59 <ThreeOfEight> yes
00:02:06 <johnw> ok, just making sure!  thanks :)
00:02:44 <johnw> g'night
00:03:00 <shachaf> I think talking about tail recursion in Haskell is very often misleading.
00:05:07 <breadmonster> chrisdotcode, http://lpaste.net/117980
00:05:17 <breadmonster> That's the best I could do.
00:05:36 <chrisdotcode> breadmonster: thanks
00:06:04 <chrisdotcode> I thought of lets... but I much prefer wheres, if possible.
00:06:16 <breadmonster> chrisdotcode, They're really equivalent.
00:06:30 <chrisdotcode> I know - I just prefer where syntax.
00:07:28 <vanila> you can do what breadmonster showed, but where instead of let
00:08:03 <breadmonster> Oh yeah.
00:08:05 <breadmonster> :P
00:09:58 * hackagebot gitlib-test 3.1.0.2 - Test library for confirming gitlib backend compliance  http://hackage.haskell.org/package/gitlib-test-3.1.0.2 (JohnWiegley)
00:09:58 * hackagebot gitlib 3.1.0.1 - API library for working with Git repositories  http://hackage.haskell.org/package/gitlib-3.1.0.1 (JohnWiegley)
00:19:52 * hackagebot htoml 0.1.0.0 - A parser for TOML files.  http://hackage.haskell.org/package/htoml-0.1.0.0 (cies)
00:24:52 * hackagebot rest-types 1.12 - Silk Rest Framework Types  http://hackage.haskell.org/package/rest-types-1.12 (ErikHesselink)
00:24:54 * hackagebot rest-core 0.34 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.34 (ErikHesselink)
00:24:56 * hackagebot rest-gen 0.16.1.6 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.16.1.6 (ErikHesselink)
00:29:52 * hackagebot rest-client 0.4.0.3 - Utility library for use in generated API client libraries.  http://hackage.haskell.org/package/rest-client-0.4.0.3 (ErikHesselink)
00:29:54 * hackagebot rest-happstack 0.2.10.5 - Rest driver for Happstack.  http://hackage.haskell.org/package/rest-happstack-0.2.10.5 (ErikHesselink)
00:29:56 * hackagebot rest-snap 0.1.17.15 - Rest driver for Snap.  http://hackage.haskell.org/package/rest-snap-0.1.17.15 (ErikHesselink)
00:29:58 * hackagebot rest-wai 0.1.0.5 - Rest driver for WAI applications.  http://hackage.haskell.org/package/rest-wai-0.1.0.5 (ErikHesselink)
00:30:00 * hackagebot rest-example 0.1.2.2 - Example project for rest  http://hackage.haskell.org/package/rest-example-0.1.2.2 (ErikHesselink)
00:30:26 <predator217> since upgrading to cabal-1.22.0.0 cabal seems to write out garbage inside the 'dist/setup-config' file.  I guess it has something to do with encoding, but LANG is en_US.UTF-8 and the right cabal executable is picked from the PATH, any ideas?
00:37:50 <Ferdirand> hello #haskell, is there a reference implementation of modular arithmetic with a type-level modulus ?
00:39:24 <vanila> not sure but its not too difficult
00:39:36 <Ferdirand> i see too many possible leads out there that i'm not familiar with (datakinds, tagged values, proxies, ghc typerep)
00:39:47 <vanila> oh you don't need any of that stuff
00:40:06 <Ferdirand> good news
00:40:09 <vanila> I dont know why people make things so complex..
00:40:11 <shachaf> Ferdirand: I don't think there's a particular standard module for it.
00:40:18 <kazagistar> Ferdirand: Int :P
00:40:18 <Ferdirand> well i tried a little and i hit two specific problems
00:40:43 <Ferdirand> one was an issue of type variable scoping
00:41:00 <Peaker> why does cabal rebuild *everything* when flags change? Shouldn't it be roughly equivalent to changing the .cabal file manually, which doesn't rebuild everything?
00:41:06 <Ferdirand> i think i asked about it before here but i can't find it in my logs, i tried enabling ScopedTypeVariables and it didn't help
00:41:18 <shachaf> Ferdirand: If you want to make the type at runtime, this is the quintessential use of "reflection".
00:41:21 <Peaker> Or is it because the -D flags changed? I only have one module with {-# LANGUAGE CPP #-} enabled!
00:41:29 <vanila> Ferdirand, I could make an example code if you like
00:41:32 <Ferdirand> then i had to rely on passing some undefined parameter and that was ugly
00:41:34 <shachaf> Ferdirand: You have to tell GHC that you want your variables scoped with forall. See the documentation.
00:42:28 <Ferdirand> maybe i'm mistaking it for another extension, because last time I asked for the similar thing, i didn't have to change the code, just enable an extension, and poof, the problem was gone
00:42:48 <Ferdirand> unless i dreamed the whole thing
00:43:03 <shachaf> I didn't say you'd have to change your code. I said you'd have to use forall.
00:43:46 <Ferdirand> i thought the standard definition of code included the type definitions
00:44:18 <Ferdirand> well let me try again with forall and see what happens
00:44:29 <Ferdirand> i have no idea what i'm doing lulz :)
00:44:53 * hackagebot mutable-containers 0.2.0 - Abstactions and concrete implementations of mutable containers  http://hackage.haskell.org/package/mutable-containers-0.2.0 (MichaelSnoyman)
00:46:14 <Ferdirand> just to make it clear: i used empty datatypes as my type-level moduli, and made them instances of a typeclass with a single function that ignores its first argument of the phantom type and returns the appropriate value
00:46:57 <Twey> Sounds like you might want singletons
00:47:10 <Ferdirand> or proxies, i wasn't sure
00:47:12 <shachaf> That is the standard way to do it.
00:47:21 <shachaf> You might still want reflection.
00:47:34 <Ferdirand> i'm looking at Data.Reflection
00:47:45 <moop> are singletons even possible in haskell?
00:48:06 <grohne> is there an elongate way to write 'True without {-# LANGUAGE TemplateHaskell #-}?
00:48:41 <Twey> moop: Singletons as in types with precisely one value-level equivalent — not the OO anti-pattern
00:49:17 <Ferdirand> so you mean singletons would be less ugly than undefined ?
00:49:46 <vanila> there's no need to use any extensions or weird stuff
00:50:12 <Twey> Ferdirand: You can get rid of the undefined by using a proxy; singletons get rid of the whole class
00:51:44 <tdammers> Twey: you can define a data type with exactly one parameter-less constructor and have it implement Ord and Eq
00:52:18 <Twey> Ferdirand: There might be other things; you should probably post code if you want more specific advice
00:52:40 <Twey> tdammers: Aye
00:53:01 <Ferdirand> i'm at the stage where i scrapped everything to start from scratch
00:53:43 <Twey> tdammers: Wait, why Ord/Eq?
00:54:53 * hackagebot sdl2-ttf 0.2.0 - Binding to libSDL2-ttf  http://hackage.haskell.org/package/sdl2-ttf-0.2.0 (schalmers)
00:55:34 <hexagoxel> predator217: what kind of garbage? setup-config is not human readable, it seems. what is the exact problem? also, consider asking in #hackage
00:56:07 <predator217> hexagoxel: null bytes etc, instead of plain text as is normally the case
00:56:42 <predator217> downgrading to cabal 1.20.0.3 and running cabal congiure produces the correct file, but 1.22.0.0 has that problem it seems
00:57:05 <tdammers> Twey: not strictly required, but might as well
00:57:18 <tdammers> Twey: especially Ord
00:57:25 <tdammers> s/Ord/Eq/
00:57:46 <tdammers> such that the only possible value is always equal to itself
00:57:56 <tdammers> doesn't matter if you only ever pattern-match, but hey
01:02:31 <hexagoxel> predator217: binary does not mean incorrect
01:04:36 <predator217> hexagoxel: hGetContents etc fail with invalid byte sequence, even the linux utility 'iconv' fails on that file with an read error
01:04:48 <predator217> hexagoxel: http://imgur.com/dznymsw
01:04:54 * hackagebot rtlsdr 0.1.0.3 - Bindings to librtlsdr  http://hackage.haskell.org/package/rtlsdr-0.1.0.3 (adamwalker)
01:06:33 <predator217> hexagoxel: and with 1.20.0.3: http://lpaste.net/330038889186066432
01:08:49 <hexagoxel> predator217: i am not sure why hGetContents would fail on a binary
01:08:59 <hexagoxel> but iconv sure will not work
01:09:13 <predator217> hexagoxel: according to what I found it seems encoding related
01:12:59 <hexagoxel> i don't think so
01:13:12 <hexagoxel> it is binary and not supposed to be read by a human
01:14:42 <hexagoxel> predator217: what exactly is your problem other than "i cannot directly read that file anymore"?
01:14:55 <predator217> ghc-mod for example wants to read that file and fials
01:15:38 <predator217> with hGetContents: invalid argument (invalid byte sequence)
01:15:39 <predator217> on the setup-config file
01:15:48 <hexagoxel> ah, hmm
01:16:27 <hexagoxel> first question: is ghc-mod up to date? i figure if the used latest Cabal as dependency, stuff should work. but i have not tried.
01:17:10 <hexagoxel> oh, yes, my ghc-mod does not work either
01:17:33 <predator217> even the fixed version for 7.10 and cabal 1.22 fails unfortunately
01:17:44 <predator217> same error
01:21:00 <hexagoxel> predator217: see https://github.com/kazu-yamamoto/ghc-mod/issues/417
01:22:08 <hexagoxel> (and btw, the relevant change in cabal probably is https://github.com/haskell/cabal/commit/909e13ffea8935542b66d16f10816491a61ca0ff, not that it matters..)
01:23:49 <predator217> hexagoxel: awesome thanks for your time
01:29:39 <Twey> Ferdirand: http://lpaste.net/530706628907892736
01:29:55 * hackagebot histogram-fill 0.8.4.0 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-0.8.4.0 (AlexeyKhudyakov)
01:31:04 <Twey> Ferdirand: You're right, ScopedTypeVariables takes effect within a class definition without an explicit ∀ (I presume that's what you were thinking of)
01:34:26 <Twey> Ferdirand: Or more generally: http://lpaste.net/117982
01:37:45 <skatenerd> anybody awake?
01:38:08 <pantsman> barely
01:38:14 <skatenerd> ha
01:41:27 <merijn> Probably
01:41:39 <merijn> It's about time for the EU contigent to procrastinate at work :p
01:42:03 <skatenerd> ah
01:42:07 <skatenerd> well i am in Beijing, doing the same
01:42:56 <ChristianS> who say that you have to be awake to be at work? ;)
02:09:56 * hackagebot histogram-fill 0.8.4.1 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-0.8.4.1 (AlexeyKhudyakov)
02:18:23 <haasn> I'm procrastinating at home.
02:18:26 <haasn> Does that count?
02:23:16 <J_Arcane> i also am at home, slogging through a somewhat badly written but visually impressive Scala tutorial.
02:29:57 * hackagebot fclabels 2.0.2.2 - First class accessor labels implemented as lenses.  http://hackage.haskell.org/package/fclabels-2.0.2.2 (SebastiaanVisser)
02:38:34 <untseac> Hello
02:40:13 <untseac> After reading learn you a haskell is it worth reading another book?
02:40:34 <vanila> no thats the last book :P
02:41:00 <untseac> lol you know what I meant
02:41:41 <mmmm> how do you feel
02:41:45 <vanila> well there is more to learn about haskell thats not in the book
02:41:51 <vanila> butyou should be able to write some stuff already
02:41:58 <aloiscochard> so, I'm trying to add an application of mine in stackage
02:42:03 <aloiscochard> the problem is that I use a library
02:42:09 <aloiscochard> which is not in stackage and was not updated
02:42:15 <aloiscochard> so it rely on a outdated package
02:42:19 <aloiscochard> what should I do?
02:42:34 <bernalex> isn't there a #stackage chan?
02:42:35 <aloiscochard> trying to get in touch with the author to ask for put the stuff in stackage?
02:42:56 <aloiscochard> bernalex: no
02:42:58 <bernalex> t's certainly what I would do, for the benefit of all.
02:43:06 <aloiscochard> okay
02:43:07 <bernalex> *that's
02:43:15 <bernalex> (äeroplane wifi here)
02:43:24 <aloiscochard> :-)
02:43:25 <mmmm> Have you looked at the stackage repo to see what people usually do?
02:43:38 <bergmark> bernalex: there's a stackage mailing list
02:43:50 <aloiscochard> mmmm: how can I see that, I did a PR who went in, snoyman told me to ping if I needed more help but I thought about asking here first
02:43:52 <bernalex> aloiscochard: ^
02:44:08 <aloiscochard> mmmm: s/that,/that?/
02:44:16 <bergmark> aloiscochard: if that package is not already on stackage it's fine, i think
02:44:31 <untseac> I see. I like the pictures in learn you a haskell. Every programming language book should have pictures like those :p
02:44:31 <aloiscochard> bergmark: I see
02:44:33 <bergmark> but preferably get in touch with the maintainer
02:44:44 <aloiscochard> gotcha, thanks all for your help
02:45:33 <bergmark> aloiscochard: you can also add yourself as the stackage maintainer for that package if you want
02:45:46 <bernalex> untseac: I like the avril lavigne exercise
02:46:47 <untseac> bernalex, hum I'll have to check that after work
02:46:58 <aloiscochard> bergmark: good to know it's a possible solution
02:51:32 <bergmark> aloiscochard: oh i confused myself, i was thinking you used and old version of a package that wasn't on stackage, but it seems you are transitively pulling in a package that *is* in stackage already with a newer version, so then you need to contact the maintainer
02:52:18 <aloiscochard> bergmark: actually, I definitely need to do that, as he should bump the bounds (well, I should really do a PR on his repo), fyi: https://github.com/fpco/stackage/pull/404
02:52:43 <aloiscochard> is Don Stewart here by any chance? :-)
02:53:34 <bergmark> usually not i think, he's "dons"
02:53:44 <bergmark> or maybe donsbot
02:54:07 <aloiscochard> cool ty
02:57:52 <merijn> dons is fairly absent nowadays, busy at work and posting pictures of sunsets :p
02:58:57 <bergmark> haha i think i'm not following him on twitter anymore because of all the sunsets
03:02:09 <aloiscochard> seems like he don't work at Galois anymore, the email address on hackage is not working
03:02:42 <aloiscochard> (I found he's private email)
03:02:49 <aloiscochard> his*
03:03:01 <ThreeOfEight> I vaguely recall some installer that installs a nice combination of Haskell plugins for Vim automatically. Does anybody have a link to that?
03:05:35 <mmmm> vim2hs?
03:06:02 <bernalex> e are several.
03:06:11 <bernalex> there
03:06:35 <bernalex> either I need to be more patient, or mosh needs to get better. or the wifi.
03:07:32 <Dodek> hey, is there ghc option to check if a build has Main.main?
03:07:59 <Dodek> the usecase is this: user mistakenly declares main in module Foo, and ghc Foo.hs generates Foo.o, which is not executable
03:08:55 <Taneb> Dodek, you can do -main-is Foo.main
03:09:25 <Dodek> however, since this is expected behaviour, ghc returns success, while user is confused why Foo binary is not created
03:09:57 <Dodek> Taneb: that's not what i want. i want to be notified by ghc that Main.main is _not_ found
03:09:59 * hackagebot gimlh 0.1.2.0 - Haskell parser for GIML  http://hackage.haskell.org/package/gimlh-0.1.2.0 (gazay)
03:10:10 <Taneb> Oh, hmm
03:12:53 <mmmm> I think hlint checks for that
03:25:00 * hackagebot OpenAL 1.6.0.1 - A binding to the OpenAL cross-platform 3D audio API  http://hackage.haskell.org/package/OpenAL-1.6.0.1 (SvenPanne)
03:30:00 * hackagebot warp-tls 3.0.1.2 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-3.0.1.2 (MichaelSnoyman)
03:30:02 * hackagebot yesod-core 1.4.7.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.4.7.2 (MichaelSnoyman)
03:30:04 * hackagebot ALUT 2.3.0.2 - A binding for the OpenAL Utility Toolkit  http://hackage.haskell.org/package/ALUT-2.3.0.2 (SvenPanne)
03:40:00 <aisqwe> what is special about type with a # at the end of them?
03:41:41 <Axman6> aisqwe: they're usually primitive types
03:41:44 <Axman6> @src Int
03:41:45 <lambdabot> data Int = I# Int#
03:42:04 <aisqwe> where are they implemented?
03:42:09 <Axman6> Int# is a primitive int (a la C)
03:42:18 <Axman6> in the compiler
03:43:00 <aisqwe> why cant i view the information with :info raise# in ghci?
03:44:17 <aisqwe> are there any references as how to add your custom primitve types to haskell?
03:45:01 * hackagebot VKHS 0.5.2 - Provides access to Vkontakte social network via public API  http://hackage.haskell.org/package/VKHS-0.5.2 (SergeyMironov)
03:45:15 <Axman6> doing so would be quite an undertaking. what do you want to add?
03:46:30 <breadmonster> Axman6, does Haskell have freenode cloaks, btw?
03:46:57 <Axman6> no idea, probably not
03:47:04 <aisqwe> Axman6: something like raise# to notify me when called from haskell, just for hacking purposes
03:49:27 <booba> Greetings! I'm new to Haskell and am trying to figure out how type classes work. I can't understand why running parse "4" on http://lpaste.net/117986 in GHCI gives Just (4, "") but running parse "True" on http://lpaste.net/117985 gives an error.
03:50:59 <aisqwe> booba: i think you havent made an instance for Bool yet
03:51:33 <booba> aisqwe: isn't instance Parsable Bool the instance?
03:52:10 <aisqwe> booba: but it isnt implemented yet in your code
03:52:28 <alpounet> aisqwe: it is, in the second paste
03:52:29 <booba> aisqwe: and how is it get implemented for Integer?
03:52:40 <alpounet> booba: do you explicitly mention you want the string to be parsed as a boolean?
03:53:03 <alpounet> ghci has some defaulting rules for types
03:53:25 <alpounet> try: parse "True" :: Maybe (Bool, String)     for example
03:53:28 <booba> alpounet: no, I'm trying to run example code from an exercise
03:53:53 <aisqwe> booba: I guess the read class does the parsing
03:55:01 <booba> alpounet: your guess works. Thanks. Can this assume that GHCI tries Integer by default?
03:55:28 <Ferdirand> Twey: ah, awesome, thanks
03:55:44 <Ferdirand> indeed, for the thing i had tested it was within a class
03:56:18 <alpounet> booba: probably yeah :) since the 'a' in the typeclass is only used in the method's return type, ghc(i) can't just guess the type for which you want to call parse
03:56:46 <alpounet> by just seeing 'parse someString', it can't guess what you want to parse the string as
03:56:59 <alpounet> so you have to tell ghci explicitly
03:57:01 <booba> alpounet: aisqwe: Thanks for your help! Been struggling for the whole night on that!
03:58:00 <alpounet> if you were doing pretty printing instead of parsing, say like Show, then you have a function whose type looks like:  show :: a -> String
03:58:27 <alpounet> so if you say 'show True', the 'a' you want to use show with is easy to figure out, it's just the type of show's argument
03:58:43 <alpounet> Bool in this case
03:59:59 <booba> alpounet: I get it now. I feel like I had an enlightment =). Just got the feeling on both type classes and lazy evaluation. Thanks a lot!
04:00:13 <alpounet> cheers :)
04:01:40 <aisqwe> are there any resources on learning about ghc compiler ?
04:02:20 <merijn> aisqwe: The wiki has quite a lot of documentation
04:02:35 <merijn> aisqwe: The compiler is rather big, though, so it depends on what part(s) you're interested in
04:02:53 <aisqwe> how would i go about implementing something like raise# in the compiler?
04:03:17 <bergmark> aisqwe: this was published recently http://takenobu-hs.github.io/downloads/haskell_ghc_illustrated.pdf
04:03:21 <merijn> I don't know what "raise#" is?
04:03:49 <merijn> aisqwe: Important links: https://ghc.haskell.org/trac/ghc/wiki/Commentary
04:03:50 <aisqwe> i think it is what error calls to stop the program
04:03:59 <merijn> aisqwe: Also, there's #ghc
04:05:29 <aisqwe> merijn: the pdf is much good such comic sans wow :D
04:05:48 <merijn> aisqwe: There's also the ghc-devs mailing list, something like raise# would probably have to be implemented in the runtime system and then add a new Cmm primitive to call it and expose that
04:06:21 <aisqwe> merijn: exactly , i want to know more about the primitive types
04:07:10 <merijn> Most of the documentation is in the Commentary I linked and papers
04:07:29 <merijn> I don't know the details of adding primitive operations to GHC, but I would recommend asking on ghc-devs
04:18:09 <bollu> hey guys, I'm writing a small language of my own as a learning experience (writing an interpreter). unfortunately, I have __no idea__ as to how to type check. Since haskell has one of the most awesome type systems that I have ever used, I was hoping you guys could point me to resources to learn / things to google. Thanks! :)
04:20:02 * hackagebot OpenGLRaw 1.5.0.1 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGLRaw-1.5.0.1 (SvenPanne)
04:20:47 <alpounet> bollu: Stephen Diehl has just publishde http://dev.stephendiehl.com/fun/ -- which covers haskell's type system among other things
04:21:47 <bollu> alpounet: thank you :)
04:21:52 <bollu> alpounet: how simple are they to implement?
04:22:27 <alpounet> bollu: despite the fact that Stephen's article explains things quite well, i'm not sure i'd go as far as advising you to start with that
04:22:43 <alpounet> you may want to start with a dummy type system
04:23:06 <bollu> alpounet: how does one type check with a dummy type system? >_<
04:23:44 <alpounet> bollu: i rather meant that you may want to start by writing a type checker for a simpler setting
04:23:50 <bollu> alpounet: ahh
04:24:16 <bollu> alpounet: but.. the langugage doesn't have much as of now. just variables, conditionals and looping
04:24:24 <bollu> alpounet: would it really be that difficult?
04:25:13 <alpounet> bollu: ah well no it wouldn't be, you could even try without any tutorial at all i guess. fixed set of types, no polymorphism?
04:25:50 <bollu> alpounet: yupp
04:25:55 <bollu> alpounet: no polymorphism
04:26:39 <merijn> bollu: If you're willing to pay for a book, there's an EXCELLENT book on type checking
04:26:50 <bollu> merijn: do tell!
04:27:05 <merijn> bollu: Types and Programming Languages discusses a whole bunch of different type systems and how to implement type checkers for them and prove their correctness
04:27:09 <merijn> @where tapl
04:27:09 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
04:27:24 <merijn> bollu: It is the defacto intro to type theory/type checking/type inference
04:27:50 <merijn> The code samples are in ocaml, but they only use a basic subset of ocaml, so anyone with beginner haskell knowledge should be able to read it no problem
04:28:07 <alpounet> there's a port of the examples to haskell anyway :)
04:28:11 <merijn> That too
04:28:39 <merijn> bollu: It starts with just simply typed lambda calculus, but branches out to include stuff like exceptions, subtyping, etc.
04:29:19 <bollu> merijn: thanks!
04:30:02 * hackagebot slack-api 0.1 - Bindings to the Slack RTM API.  http://hackage.haskell.org/package/slack-api-0.1 (mpickering)
04:31:23 <gcganley> I'm linking a shared library and im getting "undefined symbol: stg_forkOnzh"
04:31:30 <bollu> guys, in the page http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system - Map^2, implies that Map has a kind * -> * -> * correct?
04:34:08 <merijn> bollu: afaict, yeah
04:34:32 <bollu> merijn: thanks :)
04:35:03 * hackagebot GLURaw 1.4.0.2 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/GLURaw-1.4.0.2 (SvenPanne)
04:35:04 <bollu> bollu: http://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system <- could someone give me an example of a polytype? like, even the Map^2 which is a HKT is a monotype, so what's a polytype?
04:36:29 <bollu> guys, some help ? :)
04:37:41 <merijn> :t id
04:37:42 <lambdabot> a -> a
04:38:31 <merijn> A monomorphic type "has" exactly one type (hence mono)
04:38:38 <merijn> A polymorphic type can "have" many types
04:38:57 <merijn> For example, "id :: a -> a" can be both "id :: Int -> Int" or "id :: Bool -> Bool"
04:39:16 <merijn> Haskell's "id :: a -> a" is actually shorthand for
04:39:17 <bollu> merijn: ah, so anything with a forall <T>  is a polymorphic type?
04:39:39 <merijn> "id :: forall a . a -> a" which translates "for all type 'a', 'id' has type 'a -> a'"
04:39:50 <bollu> merijn: then what about say, Monad?
04:40:00 <merijn> Monad is a typeclass, not a type :)
04:40:01 <bollu> merijn: doesn't Monad also implicity have a "forall" in it's definition?
04:40:14 <bollu> merijn: ah, right :) so they're different beasts from types?
04:40:37 <bollu> :t Functor
04:40:38 <lambdabot> Not in scope: data constructor ‘Functor’
04:40:43 <nkar> merijn: thanks for suggesting to read "fun with type functions".  it's well written, and I enjoy reading it
04:40:52 <merijn> Typeclass are constraint/requirements on types, but they are not themselves types (well, depending on your point of view, but certainly not in the same sense that 'Int' is a type)
04:41:03 <merijn> nkar: It's one of my favourite haskell papers :)
04:41:09 <bollu> merijn: hm, what about.. List? is list a polytype?
04:41:18 <merijn> Sometimes!
04:41:27 <merijn> [Int] is monomorphic
04:41:39 <merijn> "forall a . [a]" is polymorphic
04:41:51 <merijn> An example of a value of type "forall a . [a]", you ask?
04:41:53 <merijn> :t []
04:41:54 <lambdabot> [t]
04:41:58 <bollu> merijn: hmm
04:42:23 <bollu> merijn: State Int is still polymorphic since there's one more "hole" to fill correct?
04:42:35 <merijn> bollu: That just makes it partially applied
04:42:53 <merijn> Types are polymorphic if they contain type variables, not if they're "only" partially applied
04:42:53 <bollu> merijn: but is it polymorphic>
04:42:59 <bollu> merijn: hm..
04:43:00 <hpc> it's not polymorphic
04:43:10 <hpc> it's a monomorphic type function of kind * -> *
04:43:16 <bollu> merijn: a pure "State" is polymorphic?
04:43:22 <merijn> bollu: tbh, that wikipedia page is pretty unreadable and TaPL is far easier to read :)
04:43:25 <tdammers> State Int s -- is polymorphic
04:43:28 <tdammers> State Int -- is not
04:43:35 <merijn> "State" is monomorphic, "State s" is polymorphic
04:43:47 <merijn> Well, "forall s . State s" is
04:43:59 <bollu> tdammers: wait, what >_<? what's the difference between calling it "State" and "forall s. State s" ?
04:44:06 <merijn> bollu: The type variable
04:44:10 <sipa> Map is * -> * -> *
04:44:12 <merijn> :k State
04:44:13 <lambdabot> * -> * -> *
04:44:15 <sipa> Map a b is *
04:44:24 <bollu> merijn: but, but, in that case, when I say "State", what is it then?
04:44:35 <sipa> forall a b. Map a b is polymorphic *
04:44:39 <merijn> bollu: "State" is a monomorphic type of KIND "* -> * -> *", "State s" is a polymorphic type of KIND "* -> *"
04:45:09 <bollu> merijn: oh! so the kinds and the "morphism" if that's what I can call it are orthogonal?
04:45:19 <merijn> bollu: Correct
04:45:34 <bollu> merijn: so, forall s, a State s a is a *polymorphic* type of KIND * -> * -> * ?
04:45:44 <bollu> forall s . forall a *
04:45:45 <merijn> bollu: kind "*" :)
04:45:52 <bollu> merijn: ahh -_-
04:45:54 <bollu> merijn: yeah...
04:45:57 <merijn> Since "State :: * -> * -> *
04:46:00 <hpc> you're confusing forall with lambda
04:46:01 <bollu> merijn: because I applied both the types
04:46:05 <merijn> State with two arguments must be * :)
04:46:08 <merijn> Yup
04:46:12 <bollu> merijn: hmm
04:46:12 <tdammers> the similarity of type names and value constructors, and type variables and value-level variables is no coincidence in Haskell
04:46:27 <merijn> hpc: One might argue that's not confusion in other type systems :)
04:46:37 <bollu> merijn: so what's the "advantage" of this "forall" construct? when haskell automagically seems to fill it in?
04:47:11 <merijn> bollu: That's because that notation is borrowed from System F_omega, on which haskell's inner model is based
04:47:25 <merijn> bollu: In that type system you need to explicitly pass types as arguments to functions
04:47:39 <bollu> "second-order lambda calculus" I haven't even understood straight up lambda calculus. man..
04:47:46 <bollu> merijn: hm, examples? :)
04:47:56 <merijn> bollu: "id :: forall a . a -> a" would be called as "id @Bool True" instead of "id True"
04:48:14 <bollu> merijn: ah
04:48:18 <merijn> "id @Bool" would return a function of type "id @Bool :: Bool -> Bool"
04:48:32 <bollu> merijn: so you apply the type, and THEN the function?
04:48:35 <merijn> This is what happens in Core (GHC's internal language)
04:48:44 <bollu> merijn: GHC has an internal language? :O
04:48:53 <merijn> bollu: Well, more like "the type becomes an extra argument"
04:48:59 <bollu> merijn: hm
04:49:07 <merijn> bollu: Haskell is fairly high level, which you see here, for example
04:49:36 <merijn> bollu: There is a simpler internal language called Core. GHC first desugars haskell to Core (filling in type arguments automatically for things like id)
04:49:54 <bollu> merijn: I see..
04:50:05 <bollu> merijn: question - if I write a statement like forall a. Int -> String
04:50:09 <bollu> does it mean anything?
04:50:10 <clrnd> :t state
04:50:11 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
04:50:28 <merijn> Then it optimises the Core, which gets converted into STG (an even simpler language), some more optimisations, conversion to Cmm (a variation of C--) and eventually that's converted to assembler (either native or LLVM)
04:50:46 <bollu> merijn: that's .. awesome. so many levels
04:50:47 <merijn> bollu: In haskell that's rather nonsensical, in other languages that *could* be meaningful
04:51:04 <bollu> merijn: what kind of meaning could you attach to that?
04:51:29 <merijn> bollu: Core is pretty simple, it only has datatypes, let, case and function application :)
04:52:09 <merijn> bollu: In dependently typed languages there is no real distinction between types and values, so passing types as arguments to things can make sense (or even passing values to types...)
04:52:32 <bollu> merijn: Agda is "dependently typed" correct?
04:52:56 <bollu> merijn: question - is it possible to ever, like *increase* the number of kinds on a typeclass?
04:53:43 <merijn> What do you mean by "increase the number of kinds on a typeclass"?
04:53:45 <tdammers> increase the number of kinds?
04:54:07 <merijn> Usual examples of dependently typed languages are: Coq, Agda and Idris
04:54:16 <clrnd> get from * to * -> * I guess
04:54:21 <bollu> clrnd: yeah, that
04:54:29 <tdammers> oh, so "change the kind"
04:54:45 <bollu> tdammers: well, "increase" :) when you apply, you reduce it right?
04:54:45 <sipa> bollu: so that means you have a levels of types above kinds even
04:54:46 <clrnd> I got you because I still can't understand kinds very well :P
04:55:04 * hackagebot OpenGL 2.10.0.0 - A binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGL-2.10.0.0 (SvenPanne)
04:55:08 <bollu> sipa: hm. oh yeah, to do that I'll need to have structures that can generate kinds
04:55:16 <bollu> sipa: whoa, that's so interesting!
04:55:20 <bollu> sipa: does that exist even?
04:55:24 <merijn> bollu: Yes
04:55:32 <bollu> merijn: really? what are they called
04:55:45 <merijn> bollu: Many dependently typed language are based on the Calculus of Constructions which has an infinite number of "kinds of kinds"
04:55:53 <bollu> merijn: actually, I'm getting sidetracked.. I was reading about type inference and then this happened >_<
04:56:06 <bollu> merijn: that's so cool
04:56:08 <merijn> The kind of kinds is usually called "sort" and they're either "sorts" or "universes"
04:56:19 <bollu> merijn: hm. makes me think of cardinality :D
04:56:19 <tdammers> you basically just formalize and generalize the mechanism by which you go from values to types, and from types to kinds
04:56:31 <merijn> bollu: TaPL should provide a far easier intro to all of this stuff than that wikipedia page, though :)
04:56:37 <bollu> merijn: will do!
04:56:47 <bollu> merijn: I love haskell, gives me all sorts of cool ideas to play around with <3
05:01:33 <serses> what was the command for running a haskell file in console?
05:02:36 <augustss> merijn: Ummm, does CoC really have an infinite number of kinds?  They have * :: *, so they don't need that.
05:03:01 <clrnd> serses, runhaskell ?
05:04:01 <merijn> augustss: I may be thinking of the Extended CoC
05:04:27 <serses> clrnd: founded was runghc
05:04:42 <merijn> Luo's ECoC covers an infinite hierarchy of kinds at least, iirc
05:04:49 <augustss> merijn: Most others have a hierarchy of universes.
05:05:04 <clrnd> runhaskell seems to be a link to runghc so yeah
05:05:11 <augustss> Using * :: * is incredibly fragile.
05:05:12 <merijn> oh, maybe I'm mixing up terminology :)
05:05:13 <clrnd> and runghc is a link to runghc-7.8-4 :P
05:05:54 <augustss> kinds, universes, whatever you want to call them.
05:06:53 <augustss> Anyway, stratifying them makes it easier to avoid paradoxes (like Girard's oaradox).
05:07:13 <merijn> augustss: tbh it's been a while since I read this stuff and it's at the limit of my knowledge, so anything I say can be taken with a grain of salt :)
05:11:45 <pharpend> Morning, everyone!
05:11:49 <pharpend> or evening
05:11:59 <pharpend> or whatever time it is in your silly country
05:12:16 <skatenerd> 21:09
05:12:19 <skatenerd> dinner time
05:12:23 <serses> where i can post code?
05:13:37 <bollu> evening :)
05:13:42 <merijn> @where lpaste
05:13:42 <lambdabot> http://lpaste.net/
05:20:05 * hackagebot GLUT 2.6.0.0 - A binding for the OpenGL Utility Toolkit  http://hackage.haskell.org/package/GLUT-2.6.0.0 (SvenPanne)
05:21:56 <serses> why i can't print this function : http://lpaste.net/7802635303885209600?
05:23:12 <merijn> serses: You're defining a function that takes two arguments but calling it with a single argument (a tuple)
05:23:24 <merijn> serses: Haskell function calls don't use parentheses or comma's
05:23:36 <merijn> Try "main = print f(2,3)"
05:23:38 <merijn> eh
05:23:43 <merijn> damn copy paste
05:23:49 <merijn> Try: "main = print (f 2 3)"
05:24:16 <serses> so anything that looks like (x y) is a tuple?
05:24:54 <opqdonut> no, anything that looks like (x, y)
05:25:04 <serses> aha got it
05:25:29 <jle`> it sort of matches up with the syntax for declarations, btw
05:25:45 <jle`> f x y = x + y
05:25:57 <jle`> which is saying "everywhere you see `f x y`, replace with `x +  y`"
05:26:07 <jle`> so if you write `print (f 2 3)`
05:26:16 <jle`> you see "f 2 3", and replace it with "2+3"
05:26:21 <jle`> so it becomes print (2 + 3)
05:26:50 <jle`> it kind of looks like a substitution rule .... "substitute `f x y` for `x + y`"
05:26:56 <jle`> f x y = x + y
05:27:07 <serses> thanks
05:29:36 <gcganley> has anyone had trouble with "undefined symbol std_forkOnzh"? I've been having trouble trying to squash it for four days
05:30:52 <folsen> :q
05:31:17 <clrnd> :x
05:31:48 <tdammers> :cc
05:32:13 <tdammers> gcganley: looks like something C needs to be linked but isn't
05:33:22 <gcganley> tdammers: if you want to take a look at the project its for linux/mac right now. it runs haskell functions inside a C# environment through the fii. the URL is http://github.com/gcganley/subnet
05:34:53 <gcganley> and if this doesnt work than im pretty much forced to rewrite in C#
05:35:05 * hackagebot ersatz-toysat 0.2.0.0 - toysat driver as backend for ersatz  http://hackage.haskell.org/package/ersatz-toysat-0.2.0.0 (MasahiroSakai)
05:36:40 <gcganley> any help would be very much appreciated
05:37:53 <tzaeru> "std_forkOnzh" is kind of weird. far as I am aware, there are no fork functions in standard std namespace?
05:38:52 <merijn> stg, not std
05:38:57 <merijn> oh wait, std?
05:39:07 <merijn> That'd be odd...
05:39:19 <gcganley> stg thats right sorry
05:39:25 <tzaeru> stf does more sense :P
05:39:25 <gcganley> its haskell error
05:39:27 <tzaeru> *stg
05:39:36 <merijn> stg is a prefix of functions in the runtime
05:39:39 <gcganley> its having trouble with forkOn basically
05:39:48 <merijn> In other words, the linker is failing to find the runtime system
05:39:52 <merijn> gcganley: OS?
05:40:01 <gcganley> merijn: Arch Linux
05:40:12 <tzaeru> https://www.haskell.org/pipermail/haskell-cafe/2012-September/103227.html tried this?
05:40:15 <merijn> And you're trying to build a dynamic library?
05:40:35 <gcganley> merijn: yes, look it up on http://github.com/gcganley/subnet
05:40:37 <merijn> I'm putting 10 dollars on "Arch bollocksed your GHC and didn't install dynamic libraries"
05:41:00 <gcganley> merijn: ghc --info said it has GHC Dynamic enabled...
05:41:25 <merijn> gcganley: Sure, but did your install of GHC also install the dynamic versions of all the libraries like the runtime?
05:41:28 <gcganley> merijn: I could compile from head I just dont know how to enable dynamic libraries in build.mk
05:41:52 <gcganley> merijn: I thought thats what ghc --info told me lol
05:41:54 <merijn> I've seen linux package managers decide "oh, users don't need this, let's not ship it" and break GHC enough times that it's my default assumption until proven otherwise
05:42:41 <merijn> gcganley: afaik that just says whether GHC can build dynamic libraries, but if some libraries you depend on are missing it will fail to link (which is what this is)
05:43:12 <gcganley> merijn: alright I'm building from head, how do i compile all the libraries and runtime for dynamic usage?
05:43:36 <merijn> gcganley: I'm not entirely sure, tbh, try asking in #ghc?
05:44:08 <gcganley> before i ask over there does anyone here know?
05:45:03 <merijn> gcganley: Other option would be the mailing list, less likely to be missed by those who know the answer
05:45:06 * hackagebot StateVar 1.0.1.1 - State variables  http://hackage.haskell.org/package/StateVar-1.0.1.1 (SvenPanne)
05:47:29 <tzaeru> http://en.sfml-dev.org/forums/index.php?topic=9304.0 hm :D
05:49:50 <gcganley> merijn: no answer over there lol
05:50:06 * hackagebot htoml 0.1.0.1 - A parser for TOML files.  http://hackage.haskell.org/package/htoml-0.1.0.1 (cies)
05:50:27 <gcganley> merijn: anywhere else I could ask? is there anyone thats been handleing the dynamic linking of GHC recently?
05:51:20 <gcganley> merijn: what time is it in amsterdam anyway
05:51:58 <merijn> Dynamic linking is actively work on, 7.8 is the first version it shipped in, afaik?
05:52:18 <merijn> And like 15:00
05:52:45 <gcganley> merijn: i remember spj talking about how new it was on the Haskell Cast, not sure how old that episode is though
05:52:49 <gcganley> let me look it up
05:53:26 <gcganley> merijn: it has been around since at least 2013-10-28
05:54:44 <gcganley> maybe edward would edwardk would know... hes on usually later though
05:54:53 <gcganley> wow i botched that
05:55:07 <gcganley> maybe edwardk would know
05:55:12 <gcganley> much better
05:56:44 <hexagoxel> shouldn't the latest version be 7.8.4 on https://www.haskell.org/ghc/download ?
05:57:30 <hexagoxel> i know there is a link to the latest version on https://www.haskell.org/ghc/ , but still
05:57:36 <gcganley> hexagoxel: I have that version
05:57:47 <gcganley> hexagoxel: I use pacman for binaries
05:58:06 <hexagoxel> gcganley: that was not my question
05:58:19 <gcganley> hexagoxel: oh sorry lol
05:58:28 <gcganley> and yes 7.8.4 is the newest
05:58:55 <merijn> hexagoxel: 7.8.4 is still an RC, no?
05:59:01 <gcganley> and no it doesnt look to be there
05:59:14 <merijn> gcganley: "around since 2013-10-28" <- in HEAD or in a release...
05:59:33 <merijn> Keep in mind there was only like a single GHC release during 2014 due to the OSX gcc -> clang drama
05:59:39 <gcganley> merijn: i would suspect HEAD
05:59:56 <merijn> Right, so I think I was still right about that being 7.8 :p
06:00:07 * hackagebot ObjectName 1.0.1.1 - Explicitly handled object names  http://hackage.haskell.org/package/ObjectName-1.0.1.1 (SvenPanne)
06:00:11 <gcganley> merijn: is don stewart on this channel?
06:00:13 <hexagoxel> merijn: but the "latest news" on the latter link i posted says "23 December 2014  GHC 7.8.4 Released!"
06:00:19 <merijn> Not usually
06:00:20 <hexagoxel> nothing 'bout rc
06:00:30 <merijn> hexagoxel: ok, so it's just 7.10 that's still in RC
06:00:40 <gcganley> hexagoxel: it really should be up there
06:01:12 <gcganley> merijn: and i was just curious because he handles the Arch Linux GHC package
06:03:58 <hexagoxel> (i'll mail simon marlow)
06:40:08 * hackagebot slack-api 0.2 - Bindings to the Slack RTM API.  http://hackage.haskell.org/package/slack-api-0.2 (mpickering)
06:45:20 <brainacid> hello
06:45:38 <breadmonster> Hello brainacid
06:45:59 <brainacid> hi breadmonster
06:46:08 <brainacid> just installed arch and just started xmonad
06:46:15 <brainacid> loving it
06:46:27 <Lindrian> Could someone try to explain how this works "let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 10 fibs" ?
06:46:50 <Lindrian> I know its because haskell is lazy, but I just cant grasp how its executed
06:47:43 <flux> lindrian, maybe you can try make drawing of it to explain it to yourself?
06:48:25 <Lindrian> I did, and in my head the first call to fibs just ends in infinite recursion
06:48:47 <flux> draw a picture of the final result
06:48:52 <flux> not the steps it takes to get there
06:49:05 <Lindrian> huh?
06:49:06 <flux> the key thing here is that as 'fibs' has a name, it is evaluated only once
06:49:15 <merijn> Lindrian: Have a look at: http://www.vex.net/~trebla/haskell/lazy.xhtml
06:49:28 <Lindrian> thanks merijn
06:50:30 <flux> lindrian, when do you think it ends up to the infinite recursion? do you think it will be able to find out the value of the third element?
06:51:40 <Lindrian> i thought it would be more like zipWith (+) (0:1:zipWith (+) (0:1:zipWith(+) ....)) ...
06:51:48 <Lindrian> so that it would just go on and on and on
06:52:09 <flux> well no. as if refers to the name 'fibs' it refers to the very same instance of fibs
06:52:15 <flux> in your case it would create a new instance
06:52:43 <flux> "as it refers"
06:53:03 <Lindrian> okay.
06:53:13 <Lindrian> that was my impression of how recursion works, but perhaps thats incorrect
06:54:03 <Lindrian> merijn: that article makes no sense to me
06:56:21 <merijn> Lindrian: Can you be more specific about which part made no sense?
06:56:55 <Lindrian> First of all its aweful to read, and the examples are weird.
06:59:32 <merijn> "awful to read" is not really actionable criticism
06:59:43 <merijn> As for the examples, I don't see what's weird about them
07:00:01 <jameseb> Lindrian: think about it like this: the first element of fibs is 0, the second element is 1, the third element is the head of zipWith (+) fibs (tail fibs) which is the sum of the head of fibs and the head of (tail fibs) which is 0 + 1 = 1
07:00:30 <jameseb> it gets each element as it's needed and doesn't worry about elements it doesn't need
07:00:40 <Lindrian> merijn: add margins, limit width, make things clearer
07:00:45 <Lindrian> merijn: did you write it?
07:00:54 <merijn> No
07:01:20 <Lindrian> jameseb: right, but how does it actually recurse if thats the case?
07:01:40 <Lindrian> how does it move on to the next number so to speak
07:02:34 <tdammers> Lindrian: it doesn't. The recursion works the other way around.
07:03:05 <tdammers> you ask it "what is the 6th element of the fibonacci sequence", and in order to calculate that, it takes the 4th and 5th elements
07:03:15 <Lindrian> http://i.imgur.com/tOJKw.gif
07:03:26 <tdammers> and in order to calculate these, it calls itself, until it hits the base case
07:03:29 <tdammers> (i.e., 0(
07:03:43 <jameseb> Lindrian: you can think of it as recursing like you said (zipWith (+) (0:1:zipWith (+) (0:1:zipWith(+) ....)) ...) but at some stage it won't need more than the first or second elements so the recursion hits its base case
07:04:22 <Lindrian> jameseb: but it works without a base case
07:04:47 <Lindrian> I mean, I can type zipWith (+) [1..] [1..] and see it spit out numbers in ghci all day
07:04:57 <jameseb> Lindrian: the 0 and 1 at the start are the base case
07:04:58 <Lindrian> same with the fibs thing
07:05:02 <Lindrian> hm.
07:05:22 <tdammers> Lindrian: you are right in that *enumerating* the fib series has no base case
07:05:35 <tdammers> Lindrian: but *calculating* an individual element does
07:05:47 <jameseb> head (zipWith (+) [1..] [1..]) will give 2 as only the first element of each list is needed
07:06:29 <Lindrian> mind blown on so many levels
07:07:08 <tdammers> well, we are touching two concepts at the same time here that are both foreign to people coming from strict imperative languages
07:07:13 <clrnd> Lindrian, wellcome
07:07:14 <tdammers> recursion, and lazy evaluation
07:07:15 <exio4> the base case of corecursion?
07:15:10 * hackagebot satchmo-toysat 0.2.0.0 - toysat driver as backend for satchmo  http://hackage.haskell.org/package/satchmo-toysat-0.2.0.0 (MasahiroSakai)
07:25:10 * hackagebot Tensor 1.1.0.1 - Tensor data types  http://hackage.haskell.org/package/Tensor-1.1.0.1 (SvenPanne)
07:26:01 <JagaJaga> We do designate terms vars as big latin letters, type - little greek ones. Like `A : τ, B : γ` But what about kinds?
07:27:44 <vanila> hebrew
07:29:15 <tdammers> klingon
07:30:12 <JagaJaga> vanila: tdammers: you joking? :)
07:30:40 <tdammers> about 50%
07:31:36 <tdammers> I heard a story once about a math professor who, upon running out of symbols during a lecture, somewhat helplessly asked the students whether they were familiar with the cyrillic alphabet
07:32:51 <breadmonster> @src uncurry
07:32:51 <lambdabot> uncurry f p = f (fst p) (snd p)
07:33:07 <breadmonster> @src curry
07:33:08 <lambdabot> curry f x y = f (x, y)
07:33:49 <breadmonster> @src ap
07:33:49 <lambdabot> ap = liftM2 id
07:33:58 <breadmonster> how does that work?
07:34:29 <vanila> it's using the (->) e monad
07:34:36 <vanila> so just looking at types,
07:34:38 <vanila> :t liftM2
07:34:39 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
07:34:48 <breadmonster> :t ap
07:34:48 <lambdabot> Monad m => m (a -> b) -> m a -> m b
07:34:56 <vanila> (a1 -> a2 -> r) -> (e -> a1) -> (e -> a2) -> (e -> r)
07:35:00 <vanila> is what you get
07:35:03 <breadmonster> :t liftM3
07:35:04 <lambdabot> Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
07:35:16 <breadmonster> Oh okay, got it.
07:35:19 <vanila> i.e. liftM2 (*) f g e = f e * g e
07:35:24 <breadmonster> :t f `ap` x
07:35:25 <lambdabot>     Couldn't match expected type ‘m a0’ with actual type ‘Expr’
07:35:25 <lambdabot>     In the second argument of ‘ap’, namely ‘x’
07:35:25 <lambdabot>     In the expression: f `ap` x
07:35:27 <breadmonster> Argh.
07:35:47 * breadmonster eureka moment.
07:56:00 <mlen> anyone else using haskell on freebsd here?
07:56:35 <mlen> does it also happen to you that when you ^C any haskell program on freebsd it segfaults?
07:56:57 <EvanR-work> ouch
07:57:50 <mlen> not sure if my HC installation is broken (installed from port collection w/ llvm support) or it's a bug
08:00:11 * hackagebot leapseconds-announced 2015 - Leap seconds announced at library release time.  http://hackage.haskell.org/package/leapseconds-announced-2015 (BjornBuckwalter)
08:02:03 <EvanR-work> http://hpiers.obspm.fr/eoppc/bul/bulc/bulletinc.dat better mark your calendars
08:05:29 <drdo> How would one have a unary operators indexed by an integer using parsec's token and expression stuff?
08:08:18 <merijn> Depends on your grammar?
08:08:52 <drdo> merijn: It's just something like: op <integer> <expression>
08:10:07 <drdo> oh well i guess i can just ignore the reservedOp thing
08:10:13 <merijn> I mean "it depends on your *entire* grammar"
08:10:35 <merijn> If the same unary operator can be a binary operator (see haskell's '-') you need some way to distinguish between the two
08:11:37 <drdo> merijn: It can't, it's really a grammar for modal formulas, where that happens for box and diamond
08:12:23 <merijn> drdo: If your operator's are fixed, I would just hardcode them
08:12:41 <merijn> reservedOp is really for languages that allow arbitrary custom operators (like haskell)
08:13:03 <merijn> if you have a fixed, finite set of operators I'd just write a custom unary and binary operator parser
08:13:12 <drdo> merijn: I was mostly looking to use the expression stuff because doing precedence and associativity by hand is painful
08:13:27 <EvanR-work> chainl and friends, not too bad
08:14:42 <ChristianS> quick question re cabal project category: i have a program that shows how english is pronounced, should that be 11) Language or 17) Text ?
08:14:57 <drdo> Hmm, is it really not that painful? I might just do it by hand as a learning exercise then
08:15:04 <hodapp> ChristianS: I'd go with the latter, personally...
08:15:20 <hodapp> well, wait, does 'Language' apply to natural languages?
08:15:33 <ChristianS> hodapp: that's what i wonder too
08:15:38 <merijn> ChristianS: Doesn't really matter
08:15:45 <merijn> ChristianS: The categories are pretty arbitrary
08:15:57 <merijn> There's no category gestapo coming to arrest you
08:16:42 <ChristianS> merijn: thought so, just curious. i now picked 11) Language
08:17:03 <EvanR-work> drdo: look at the example for chainl1 in the doc, it shows addition and multiplication. its similar for unary, though you still need to worry about how to distinguish unary from binary if its the same symbol
08:25:12 * hackagebot HSmarty 0.2.0.3 - Small template engine  http://hackage.haskell.org/package/HSmarty-0.2.0.3 (AlexanderThiemann)
08:37:30 <brainacid> hey all
08:37:59 <vanila> hi
08:38:01 <brainacid> im on a fresh install and i have xmonad and xmobar running but i am having some trouble understanding why my bar is not displaying correctly
08:38:12 <brainacid> lol
08:38:16 <brainacid> just firgured it out
08:38:18 <brainacid> one sec
08:41:09 <shapr> brainacid: tried #xmonad ? You may get better answers on that channel?
08:42:34 <shock_one> In Template Haskell, why definitions can't be used in the same module they're built?
08:44:01 <eXeC64> Okay, this may be a strange question, but within a lambda, is there a way to refer to the lambda function itself? If you wanted a recursive lambda function for instance.
08:44:02 <latermuse> cd /Users/admin/s/flood
08:44:03 <latermuse> cd /Users/admin/s/flood
08:44:22 <shock_one> eXeC64: No.
08:44:23 <eXeC64> I'm trying to see if it's possible to implement fibonacci using a single lambda expression
08:44:43 <brainacid> oops shapr wrong channel
08:46:13 <raichoo> eXeC64: well, you could use `fix`.
08:46:33 <shock_one> eXeC64: http://rosettacode.org/wiki/Anonymous_recursion#Haskell
08:49:31 <eXeC64> Hmm, okay, I don't understand `fix`.
08:49:32 <EvanR-work> > fix (\self n -> if n == 0 then self (n-1) else 99) 13
08:49:33 <lambdabot>  99
08:50:20 <EvanR-work> oops
08:50:22 <EvanR-work> ok
08:50:34 <EvanR-work> > fix (\self n -> if n > 0 then self (n-1) else 99) 13
08:50:36 <lambdabot>  99
08:50:45 <EvanR-work> @src fix
08:50:45 <lambdabot> fix f = let x = f x in x
08:50:56 <Javran> @hoogle (Enum e, Bounded e) => [e]
08:50:59 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
08:50:59 <lambdabot> Prelude maxBound :: Bounded a => a
08:50:59 <lambdabot> Prelude minBound :: Bounded a => a
08:51:22 <Javran> :t [minBound..maxBound]
08:51:23 <lambdabot> (Enum t, Bounded t) => [t]
08:51:54 <EvanR-work> or more clearly, fix f x = f (f x)
08:52:15 <EvanR-work> oops
08:52:21 <EvanR-work> or more clearly, fix f x = f (fix f x)
08:53:10 <eXeC64> Nope. My head still hurts, and that looks like it disagrees with the type signature.
08:53:16 <eXeC64> (a -> a) -> a
08:53:29 <EvanR-work> yeah, the key in understanding to type signature is figuring out what a is
08:53:43 <shock_one> > fix (\self -> (\n -> if n /= 0 then n + self (n-1) else 0)) 3
08:53:44 <lambdabot>  6
08:53:50 <Javran> > let fib = fix (\f n -> if n < 2 then n else ((+) `on` f) (n-1) (n-2)) in map fib [1..10]
08:53:51 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
08:54:26 <nitrix> > fix id 42
08:54:30 <lambdabot>  mueval-core: Time limit exceeded
08:54:36 <hodapp> wow, my ability to ignore documentation is LEGENDARY
08:54:41 <hodapp> :t natVal
08:54:42 <lambdabot> Not in scope: ‘natVal’
08:54:51 <hodapp> :t GHC.TypeLits.natVal
08:54:52 <lambdabot> GHC.TypeLits.KnownNat n => proxy n -> Integer
09:00:13 * hackagebot vector-instances 3.3.0.1 - Orphan Instances for 'Data.Vector'  http://hackage.haskell.org/package/vector-instances-3.3.0.1 (EdwardKmett)
09:00:37 <EvanR-work> eXeC64: in any case its good practice to evaluate haskell expressions you dont understand by hand, step by step, and see what happens
09:01:28 <eXeC64> eXeC64: Yeah, I've figured out on, but not fix yet.
09:01:37 <eXeC64> I'll keep bashing away at it 'til I do, because it's strange.
09:01:44 <eXeC64> Anyway, I've got to run now.
09:05:13 * hackagebot markdown 0.1.13.1 - Convert Markdown to HTML, with XSS protection  http://hackage.haskell.org/package/markdown-0.1.13.1 (MichaelSnoyman)
09:05:15 * hackagebot mime-mail-ses 0.3.2.2 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.3.2.2 (MichaelSnoyman)
09:05:17 * hackagebot persistent 2.1.1.4 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-2.1.1.4 (MichaelSnoyman)
09:10:14 * hackagebot shakespeare 2.0.2.2 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-2.0.2.2 (MichaelSnoyman)
09:12:07 <structuralist> is there something like "failingWith m e = maybe (Left e) Right m" in a library somewhere?
09:13:04 <structuralist> for use like "someaction `failingWith` errormessage"
09:14:02 <EvanR-work> :t (<?>)
09:14:03 <lambdabot>     Not in scope: ‘<?>’
09:14:03 <lambdabot>     Perhaps you meant one of these:
09:14:03 <lambdabot>       ‘<*>’ (imported from Control.Applicative),
09:14:30 <k00mi> structuralist: "note" in Control.Error.Util from the errors package
09:14:49 <EvanR-work> structuralist: you can try hoogle, too, if you write the type out
09:15:47 <k00mi> hoogle doesn't find it because it doesn't search all packages, but hayoo does
09:22:05 <J_Arcane> Did GHCi ever get ported to ARM?
09:26:07 <xBlackyII>    /leave #haskell
09:26:24 <clrnd> bye
09:32:29 <EvanR-work> /part
10:00:15 * hackagebot cereal 0.4.1.1 - A binary serialization library  http://hackage.haskell.org/package/cereal-0.4.1.1 (TrevorElliott)
10:01:22 <gcganley> is #haskell dead or just quite
10:01:55 <n4x> the middle of the week
10:02:11 <gcganley> n4x: everyone at work? lol
10:02:54 <n4x> maybe
10:03:58 <EvanR-work> hell no
10:05:49 <J_Arcane> I've actually been too busy actually coding to pay attention to IRC for once. In Haskell too!
10:07:03 <gcganley> J_Arcane: Im not, I've been trying to figure out how to dynamically link haskell on windows
10:07:14 <J_Arcane> gcganley: Good luck with that.
10:07:29 <J_Arcane> You know that F# was started after a failed attempt to port Haskell to .NET`?
10:08:13 <hodapp> J_Arcane: wut?
10:08:30 <gcganley> J_Arcane: I know there was an effort for Haskell.NET
10:08:52 <hiptobecubic> Well SPJ was at MS Research wasn't he?
10:09:00 <J_Arcane> Yup.
10:09:11 <gcganley> J_Arcane: I have C# and Haskell talking to eachother on Linux but cant on windows due to the whole dynlib issue
10:09:31 <hiptobecubic> gcganley, have you consider just using a client-server model?
10:09:43 <hodapp> Isn't SPJ still there?
10:09:52 <hodapp> gcganley: that just seems a little backwards o_O
10:10:04 <hiptobecubic> Didn't he move to facebook? Or was that someone else. I can never remember.
10:10:19 <gcganley> hodapp, well the issue is I can dynamically link on linux but not windows
10:10:26 <hiptobecubic> If the data isn't enormous you'll probably have a much better time just serializing it and shipping it between the two over 0mq or whatever else.
10:10:32 <gcganley> hiptobecubic: that was simoon marlow i belive
10:10:40 <hiptobecubic> oh right. the other simon
10:11:06 <gcganley> the project is over at github.com/gcganley/subnet
10:11:50 <gcganley> hiptobecubic: I dont know how to do that, thats the only issue. I know how to use the ffi but not the client/server model
10:13:32 <gcganley> can anyone point me in the direction of using client/server model to help 2 languages interact
10:18:15 <aphorisme> edwardk, are you here?
10:20:16 * hackagebot VKHS 0.5.3 - Provides access to Vkontakte social network via public API  http://hackage.haskell.org/package/VKHS-0.5.3 (SergeyMironov)
10:22:43 <pharpend> hiptobecubic: gcganley both spj and marlow were at ms research, i don't know about spj, but marlow is now at facebook
10:22:46 <pharpend> (as is bos)
10:23:09 <gcganley> spj is still at msr
10:23:13 <breadmonster> Is there a book on computer verification of proofs?
10:25:12 <johnw> there are several
10:25:19 <johnw> what is it you are looking for exactly?
10:26:01 <athan> pharpend: I thought bos was at Stanford!
10:26:19 <hodapp> breadmonster: what about something like Software Foundations from Pierce?
10:26:28 <pharpend> athan: that's a side gig
10:27:03 <athan> holy beans
10:28:11 <breadmonster> hodapp, What's that?
10:28:28 <pharpend> breadmonster: I imagine it's a book
10:28:58 <Javran> http://www.cis.upenn.edu/~bcpierce/sf/current/index.html this one
10:29:11 <hodapp> breadmonster: what Javran said.
10:30:16 * hackagebot increments 0.1.0.4 - type classes for incremental updates to data  http://hackage.haskell.org/package/increments-0.1.0.4 (JohnLato)
10:30:18 * hackagebot shared-buffer 0.2.2 - A circular buffer built on shared memory  http://hackage.haskell.org/package/shared-buffer-0.2.2 (JohnLato)
10:30:29 <Javran> just learned few chapters, basically playing with coq to write some proofs so far
10:30:36 <levi> breadmonster: Are you thinking of verifying proofs about general math, or proofs related to programming language/software issues?
10:30:51 <breadmonster> levi, The former.
10:31:34 <levi> Software Foundations is good, but probably not the best for that particular topic.
10:32:25 <hodapp> hmm, ACL2 has a book I think
10:32:27 <hodapp> old though
10:32:40 <levi> Have you seen http://us.metamath.org/ ?
10:34:22 <levi> breadmonster: These sorts of purely formal proofs tend to be very different from the ones that traditional mathematics works with, even though you can eventually prove roughly the same things.
10:34:38 <breadmonster> levi
10:34:40 <breadmonster> What do you mean?
10:34:56 <breadmonster> I was more interested in proof verification, not theorem proving.
10:35:16 <johnw> breadmonster: is this the sort of thing you're looking for: https://hal.inria.fr/hal-00816699/file/main.pdf
10:36:38 <johnw> there are both books on formalizing specific theorems and/or areas of mathematics, and books on formalization of mathematical structures in general
10:37:09 <johnw> proof verification?
10:37:11 <levi> breadmonster: In order to bring a computer to bear on a proof, it has to be written in a language amenable to computer analysis, i.e. a formal language. Mathematicians are typically informal in their proofs, relying on common mathematical knowledge or intuition of the readers for some steps.
10:37:38 <breadmonster> johnw, that is EXACTLY what I'm looking for.
10:37:50 <breadmonster> levi, Yes, but you can encode set theory and so on into the proof, yeah?
10:40:01 <johnw> like they do here, yes: http://math.unice.fr/~carlos/preprints/sprout.pdf
10:40:18 <levi> breadmonster: Yes, in fact you have to do that for set-theoretical proofs.
10:40:35 <johnw> breadmonster: you may find more resources if you ask this in #coq or ##math
10:43:59 <tasker> How does using Vector (Vector a) compare to using Array (Int, Int) a ?
10:44:08 <breadmonster> levi, Is there a software for that?
10:46:17 <levi> There are a lot of software packages for it, but there's generally a steep learning curve. Coq and Isabelle are a couple of big ones. The metamath.org site has its own language and a book on using it.
10:47:06 <breadmonster> levi, Is it steeper than Haskell? ;)
10:48:21 <johnw> breadmonster: generally, yes, much steeper
10:48:29 <levi> Here's the metamath book: http://us.metamath.org/downloads/metamath.pdf
10:49:55 <sabbia> ciao
10:50:01 <sabbia> ! list
10:50:17 * hackagebot csound-expression 4.2.1 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-4.2.1 (AntonKholomiov)
10:50:19 * hackagebot csound-sampler 0.0.3.2 - A musical sampler based on Csound  http://hackage.haskell.org/package/csound-sampler-0.0.3.2 (AntonKholomiov)
10:51:50 <levi> Coq itself, for example, is a software package consisting of a couple of different languages; one is the object language, which is a pure logic core language, and the other is a "tactic" language with which you can automate the construction of logical objects in the core language. And there's an interactive shell over it all that you have to learn to interact with.  It's rather more complicated than getting
10:51:52 <levi> started with Haskell, there are even fewer resources, and they tend to be written assuming you're a grad student in mathematics or the more math-heavy parts of computer science.
10:52:56 <koala_man> how is Coq once you get used to it?
10:53:42 <c_wraith> It's designed as a proof system rather than a general-purpose software system.  You can write software with it, but that's not the main goal.
10:54:01 <levi> It's rather fun once you get used to it, actually. At least in the context of the Software Foundations text.
10:54:59 <ReinH> koala_man: pretty good
10:55:02 <levi> You don't have to fully understand what you're doing to make progress through the text, but if you don't you may not be equipped to do much useful with it outside of doing textbook exercises. :)
10:55:44 <josephle> levi: well, with proofgeneral you can have the typechecker handhold you for most of the programming :)
10:56:03 <Javran> what about idris? I heard it looks like coq in some sense?
10:56:13 <ReinH> proofgeneral is pretty great
10:56:46 <Chathurga> I really enjoy tinkering with Idris
10:57:25 <josephle> the important part is that tactics make proof writing much easier
10:57:37 <levi> Idris is similar in some ways to coq (in that they're both dependently-typed languages) but is more oriented towards writing software that happens to have embedded proofs rather than just writing proofs.
10:58:10 <rom1504> can you actually program anything with idris or coq ? I thought it was mainly to prove stuff
10:58:28 <exio4> Idris is meant to be general-purpose
10:58:36 <ReinH> Idris is a general purpose language. Coq is a proof assistant.
10:58:45 <Javran> I know there's a sudoku solver written in coq though
10:58:47 <rom1504> ok
10:58:47 <levi> If you want verified software via Coq, you typically have to set up some correspondence between the Coq proofs and an implementation in some other language; it's got a built-in "program extraction" mechanism to help with this.
10:59:06 <ReinH> Or an "interactive theorem prover". Or a "formal proof management system". Depending on who you ask.
11:00:31 <Javran> maybe I should give Idris a shot
11:02:36 <Chathurga> It's a really fun middle ground
11:02:51 <rom1504> oh idris looks like haskell, interesting
11:03:05 <Javran> it's actually written in haskell
11:03:24 <Javran> just like coq looks like ocaml =)
11:04:26 <johnw> yeah, some simple Idris code is almost character-for-character identical to the equivalent Haskell
11:04:31 <johnw> whenever that happens it feels weird :)
11:04:42 <EvanR-work> you might find it hard to use dependent types without first reading the vastly more extensive literature on coq
11:04:45 <c_wraith> johnw: not if you include type signatures!
11:04:51 <arknave> @pl (\f -> f d)
11:04:51 <lambdabot> ($ d)
11:04:54 <johnw> true, true
11:05:13 <EvanR-work> i dont know coq and i have a hard time figuring out wtf im doing in idris
11:05:16 <johnw> Coq does make dependent types fairly easy to work with
11:05:24 <arknave> @pl (\d -> f . g ($ d))
11:05:25 <lambdabot> (f .) . g . flip id
11:05:30 <johnw> except when you paint yourself into a corner and feel like you're playing Jenga all day long
11:05:36 <EvanR-work> theres not very much non-code written about idris
11:06:14 <EvanR-work> and its still a huge work in progress
11:07:19 <Chathurga> I like looking at cases where dependant types replace macros
11:08:29 <EvanR-work> seems like something that must be a macro, must be a custom syntax feature rather than normal code feature
11:08:39 <EvanR-work> which idris has
11:09:16 <Chathurga> I'm thinking of things like printf
11:10:18 * hackagebot yesod-auth-oauth2 0.0.12 - Library to authenticate with OAuth 2.0 for Yesod web applications.  http://hackage.haskell.org/package/yesod-auth-oauth2-0.0.12 (PatrickBrisbin)
11:12:27 <c_wraith> Chathurga: printf usually isn't a macro.  Maybe it is in lisps, but not in other languages I know of.
11:13:54 <Chathurga> Type safe ones that can be user implemented usually are, I think?
11:14:35 <J_Arcane> Does doing [x] as a pattern match on any list or a list with a single element?
11:14:48 <monochrom> list with single element
11:14:48 <EvanR-work> type safe user implemented printf?
11:15:11 <Chathurga> As in it's not baked into the compiler
11:15:20 <monochrom> [x] means x:[], both in expressions and in patterns
11:15:22 <erisco> is atto parsec reasonable for a computer language parser?
11:17:24 <Chathurga> I could implement a type safe printf in Rust using macros, and in C++ using variadic templates which I may be naughty in grouping with macros
11:18:02 <Javran> attoparsec for better performance, parsec for better error message IMHO
11:18:11 <hodapp> Is there any sane way to convert an Int to GHC.TypeLits.Nat?
11:18:18 <johnw> trifecta if you want good error messages
11:18:34 <vinit-ivar> @pl \f g -> concat $ map (\x -> replicate (snd x) (fst x)) g
11:18:34 <lambdabot> const (liftM2 replicate snd fst =<<)
11:18:44 <vinit-ivar> er
11:18:48 <vinit-ivar> never mind, thanks
11:19:00 <hodapp> or, I suppose, to do any sort of iteration over a Nat, which is the real goal
11:19:12 <erisco> Javran, I was actually looking for simplicity of use
11:19:56 <Javran> johnw: didn't know trifecta before, looks good =)
11:20:48 <arknave> !pl (\l i -> map (\f -> f i) l)
11:20:50 <Javran> erisco: I think parsec is simple to use
11:20:51 <arknave> @pl (\l i -> map (\f -> f i) l)
11:20:51 <lambdabot> flip (map . flip id)
11:21:36 <erisco> simple or simpler?
11:22:07 <Javran> you have to deal with bytestrings if you want to use attoparsec, that's a little confusing sometimes
11:22:22 <Javran> eristic: simpler
11:29:18 <EvanR-work> bytestrings are simple, char strings are simple
11:29:24 <EvanR-work> dont mix them ;)
11:30:19 * hodapp mutters something about dependent types in Haskell, and stomps away
11:31:21 <hrnz> kartoffel?
11:31:38 <hodapp> wonder if people only use dependent types in Haskell to convince them that you shouldn't use Haskell, but should use Idris or Agda or something instead.
11:31:47 <hodapp> or somethnig.
11:31:53 <hodapp> hrnz: I guess that's me
11:32:16 <Javran> not feeling good when I have to import qualified bytestring bytestring.char8 bytestring.lazy bytestring.lazy.char8 all kinds of stuff
11:33:10 <johnw> ByteString.Char8 should almost always be avoided
11:33:14 <johnw> what are you using it for?
11:33:51 <erisco> johnw, evidently that is what attoparsec is a fan of http://hackage.haskell.org/package/attoparsec-0.12.1.2/docs/Data-Attoparsec-ByteString-Char8.html
11:34:16 <johnw> ah
11:34:33 <johnw> well, if you're parsing just ASCII data, I suppose it's useful
11:34:40 <Rembane> Why should Char8 be avoided?
11:34:48 <johnw> because it ignores encoding issues
11:35:03 <johnw> ByteStrings are not strings of characters, but Char8 makes it look like they are
11:35:06 <johnw> unless, of course, they are
11:35:40 <Javran> johnw: I use bytestring.char8 mostly because it uses Char rather than Word8
11:36:07 <erisco> I will try out parsec then since I have no need for this specificity in encoding or performance
11:36:11 <johnw> so, Char is not the type of an 8-bit character
11:36:36 <johnw> so you have to *know*, for certain, that in every case that will be using it, that it fits within the type of a Word8, in order to use it safely
11:37:07 <johnw> in other words, Char8 can gloss over something that requires a conscious decision
11:37:08 <Rembane> johnw: Oh. Interesting. That's a very good reason.
11:37:33 <Javran> @hoogle ByteString -> String
11:37:35 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
11:37:35 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
11:37:35 <lambdabot> Data.ByteString.Char8 head :: ByteString -> Char
11:37:51 <johnw> in order to safely get from ByteString -> String, you need to go by way of Text
11:37:51 <athan> Anyone here have experience making template haskell stuff? I'm a bit confused. My goal is to generate some data types based on the parameter to my function - _ideally_ a haskell98 flat enumeration data type
11:39:18 <Javran> johnw: so that "unpack" function isn't actually taking care of unicode issue?
11:39:43 <clrnd> there is bytestring-utf8 I recall
11:39:48 <johnw> Javran: nope
11:39:59 <johnw> Javran: it is, in fact, blithely ignoring it :)
11:40:11 <clrnd> @hoogle Data.ByteString.UTF8
11:40:12 <lambdabot> package utf8-env
11:40:12 <lambdabot> package utf8-light
11:40:12 <lambdabot> package utf8-prelude
11:40:25 <johnw> to do it safely, you would use: Data.Text.unpack . Data.Text.Encoding.decodeUtf8
11:40:29 <haasn> The .Char8 interface doesn't make sense from a semantic point of view. What does a series of octets have to do with characters?
11:40:43 <Javran> johnw: I see
11:43:43 <J_Arcane> Wow. I don't even understand this one: http://www.codewars.com/kata/reviews/5418c2901d3bf380da00025c/groups/5423adab48306ff68700045f
11:44:02 <erisco> hodapp, until those languages are stable there is still reason to use Haskell even if you are dependently inclined
11:44:14 <Pamelloes> Is there a standard function along the lines of id' :: a -> b -> a; id' a _ = a ??
11:44:23 <erisco> :t const
11:44:23 <lambdabot> a -> b -> a
11:44:34 <Pamelloes> Thanks :)
11:44:53 <erisco> :t \x->x
11:44:54 <lambdabot> t -> t
11:45:01 <erisco> whoops
11:45:36 <ajcoppa> Pamelloes: have you used hoogle before? it's excellent for answering that kind of question the next time you have it
11:45:38 <erisco> iirc there is a lambda version of const which is either shorter or the same length
11:45:59 <Pamelloes> ajcoppa: Not really. I'll go check it out :)
11:46:06 <ajcoppa> Pamelloes: https://www.haskell.org/hoogle/?hoogle=a+-%3E+b+-%3E+a
11:46:14 <erisco> :t \x _->x
11:46:15 <lambdabot> t1 -> t -> t1
11:46:17 <erisco> that is not what I remember though
11:46:18 <hodapp> erisco: I had the impression that Idris, Agda, and Coq (for instance) all were fairly stable
11:47:23 <erisco> hodapp, well, I have not used those languages, but afaik Agda and Coq and Coq especially are leaned towards being proof assistants rather than general purpose programming languages, so the comparison to Haskell would be pointless
11:47:28 <erisco> Idris is not stable
11:47:30 <johnw> Idris is not terribly stable yet
11:47:38 <johnw> Agda is pretty solid, Coq very much so
11:47:56 <johnw> Agda does not lean toward being a proof assistant
11:48:12 <erisco> no? okay, why Idris
11:48:14 <johnw> it leans toward being a testbed for PL research
11:49:05 <johnw> Ulf even jokes during his Agda presentations that "We're not going to be doing any proofs here today, no, really"
11:50:00 <josephle> the lack of tactics in agda makes it less convenient as a proof assistant
11:50:34 <quchen> johnw: Curry-Howard says I wrote a proof in PHP today. Take that, Agda!
11:51:03 <johnw> not having dependent types and parametric polymorphism, proofs get really really easy to write :)
11:51:04 <hiptobecubic> isn't that only true for total functions?
11:51:23 <josephle> quchen: you proved the theorem of...Dynamic?
11:51:34 <hiptobecubic> object -> object!
11:51:43 <erisco> $y = (ProveAnything)$x;
11:52:52 <quchen> josephle: ∃ language.   ← That's the theorem it proved
11:53:24 <erisco> johnw, is Idris aimed at being a language you would want to write regular software with? is Agda not that?
11:53:37 <johnw> right
11:53:47 <johnw> Idris intends to be a language for getting things done, Agda is not that
11:54:23 <hodapp> but does it *intend* to be that?
11:54:41 <johnw> in fact, the authors of Idris are using it to build verified software for embedded devices, last I spoke to edwinb
11:54:58 <hodapp> that's sorta what I'm using Ivory for >_>
11:55:02 <johnw> no, I have no sense from the Agda developers that they ever intend that
11:55:06 <hodapp> minus the verified part
11:55:20 <johnw> Agda is great for PL research, which often needs to not care about engineering concerns
11:55:30 <kaiyin> I am struggling with exercise 1.14 of the haskell road to logic book. It asks me to write a function for converting a string abcd... to abbcccdddd...
11:55:45 <ReinH> kaiyin: what have you tried?
11:55:59 <kaiyin> for that I need to somehow track the index of the string.
11:56:25 <hodapp> hmm, I'm not sure you do.
11:56:43 <kaiyin> ReinH, I haven't tried anything yet.
11:56:53 <kaiyin> Just thinking.
11:57:38 <ReinH> kaiyin: why do you need to track the index?
11:58:08 <kaiyin> well, 1 copy for the 1st char, 2 copies for the 2nd char ...
11:58:34 <tasker> Is it possible to create Unbox (Unbox Double) ? Or does the fact that the vector is unboxed not allow it ?
11:58:42 <ReinH> kaiyin: well, you need to track how many copies.
11:58:46 <Javran> > zip [1..] "abcd"
11:58:48 <lambdabot>  [(1,'a'),(2,'b'),(3,'c'),(4,'d')]
11:58:56 <Javran> :t replicate
11:58:57 <lambdabot> Int -> a -> [a]
11:59:23 <kaiyin> Javran, cool.
11:59:27 <kaiyin> got it.
12:00:08 <ReinH> You can also use a recursive solution
12:00:28 <ReinH> Does haskell road to logic include answers btw?
12:00:51 <johnw> is the haskell road to logic paved with reasonable intentions?
12:01:13 <Pamelloes> If I have a function a::Type1->Type2->Type3 and a function b::Type3->Type4->Type5->Type5, how do I combine a and b to create c::Type1->Type2->Type4->Type5->Type5?
12:01:29 <ReinH> johnw: ha
12:01:35 <kaiyin> ReinH, that's what I was thinking, but didn't manage to work it out.
12:01:40 <johnw> Pamelloes: you can always do it with a well-place lambda
12:01:53 <kaiyin> No, no answers in the book.
12:02:21 <Pamelloes> johnw: So is there no easy way to do it in point free style?
12:02:41 <kaiyin> johnw, what do you mean reasonable intentions?
12:02:46 <zipper> What's the easiest way to develop anything GUI just a simple thing to give me the feel of progress that can work on various operating systems?
12:02:49 <johnw> kaiyin: just a joke
12:02:54 <phaazon> hm, if I have an expression that doesn’t use the parameters of a function, does it get computed only once, or per calls?
12:02:58 <johnw> Pamelloes: not in a way that would read better than a lambda
12:03:01 <phaazon> I guess only once, but I’d like to be sure
12:03:10 <ReinH> kaiyin: the recursive solution involves a worker/wrapper transform: blowup xs = go 1 xs where go _ [] = []; go (x:xs) n = ...
12:03:19 <Pamelloes> johnw: Alright, thanks :)
12:03:45 <ReinH> phaazon: can you give an example?
12:03:50 <phaazon> yeah, wait
12:04:38 <ReinH> @djinn (a -> b -> c) -> (c -> d -> e -> e) -> (a -> b -> d -> e -> e)
12:04:38 <lambdabot> f a b c d = b (a c d)
12:04:42 <ReinH> @. pl djinn (a -> b -> c) -> (c -> d -> e -> e) -> (a -> b -> d -> e -> e)
12:04:43 <lambdabot> f = flip ((.) . (.))
12:04:47 <ReinH> Well, there you go. ;)
12:05:25 <lpaste> phaazon pasted “ReinH, this” at http://lpaste.net/118020
12:06:08 <ReinH> phaazon: it will be computed multiple times, iinm
12:06:11 <ab9rf> heh, ((.) . (.))
12:06:15 <Javran> hmm, the flipped version of (.:), should we call it (:.) then
12:06:18 <zipper> Do you people do anything GUI related?
12:06:23 <ab9rf> what's a GUI?
12:06:24 <shachaf> No.
12:06:30 <phaazon> ReinH, ah
12:06:41 <phaazon> I don’t get why
12:06:45 <zipper> shachaf: You're serious?
12:06:48 <mdmkolbe> Is there a good way to check what packages on Hackage import Data.Data or Data.Typeable (they are in the "base" package)?  (Without just downloading the entire Hackage repo.)
12:06:55 <haasn> shachaf is always serious
12:06:56 <phaazon> mdmkolbe, yes
12:06:58 <phaazon> see:
12:07:10 <zipper> FML
12:07:19 <hiptobecubic> zipper, some of us do
12:07:35 <zipper> hiptobecubic: What GUI lib do you use?
12:07:36 <Javran> mdmkolbe: did you mean something like http://packdeps.haskellers.com/reverse ?
12:07:47 <phaazon> yeah, I thought about the reverse list
12:07:51 <hiptobecubic> zipper, hsqml seems most reasonable to me right now
12:07:52 <phaazon> but it’s not actually that
12:07:56 <zipper> hiptobecubic: Hopefully something that can work on different OSes
12:08:02 <shachaf> mdmkolbe: Not to check if things import specific modules, that I know of.
12:08:15 <phaazon> ReinH, that doesn’t make sense, since the expression is constant in the function
12:08:17 <ReinH> phaazon: values is redefined for every p
12:08:21 <phaazon> it should be computed only once :(
12:08:28 <mdmkolbe> Javran: that is dependancies on packages and I need dependencies on modules
12:08:29 <ab9rf> i should try to figure out the opengl bindings again
12:08:29 <kaiyin> ReinH, you mean something like this: http://lpaste.net/118021
12:08:33 <phaazon> ReinH, no?
12:08:36 <ab9rf> last time i tried i got fed up with them
12:08:36 <hiptobecubic> zipper, there's also threepenny if you're feeling really crazy. But i think Qt/QML is the way to go.
12:08:42 <ReinH> consider the difference between fib n = fibs !! n where fibs = ... and fib = (fibs !!) where fibs = ...
12:08:47 <phaazon> we don’t care about p, values will remain the same
12:09:02 <zipper> hiptobecubic: Yeah Qt/QML is cross platform. I think that's what I need. Thanks.
12:09:16 <ReinH> phaazon: well, you can test it out if you don't believe me
12:09:26 <phaazon> ReinH, I believe you
12:09:30 <phaazon> I just don’t understand why
12:09:33 <Javran> mdmkolbe: then that doesn't offer much help I guess
12:09:38 <phaazon> since the values is constant
12:09:44 <phaazon> well, the value*
12:09:45 <ReinH> phaazon: you know that. Does the compiler know that?
12:09:53 <phaazon> sure
12:10:01 <phaazon> since I don’t use any value that could change
12:10:12 <phaazon> no functions, no parameters
12:10:15 <ReinH> That doesn't mean the compiler knows that
12:10:28 <phaazon> it’s like writing values = sin pi + 3
12:10:34 <phaazon> why would ghc compute that again and again
12:10:37 <ReinH> phaazon: In fact, GHC may be able to optimize that with -O2
12:10:47 <shachaf> phaazon: Surprise, the answer isn't "yes" or "no" but "it depends on your optimizations".
12:10:47 <ReinH> since it's a monomorphic context
12:10:59 <phaazon> I see
12:11:11 <phaazon> so what would you recommend?
12:11:19 <phaazon> let it be that way
12:11:25 <phaazon> or pass the value as a parameter?
12:11:32 <ReinH> phaazon: well, you could define values as a CAF (top-level definition)
12:11:36 <phaazon> which leaves my example quite stupid…
12:11:37 <ReinH> or just depend on GHC optimization
12:11:45 <phaazon> CAF?
12:11:53 <ReinH> "constant applicative form"
12:11:54 <shachaf> CAF doesn't mean "top-level definition"
12:12:09 <phaazon> I don’t know that concept
12:12:11 <phaazon> interesting
12:12:45 <ReinH> shachaf: true. Since it is a CAF, you could make it a top-level definition and it should be computed once.
12:12:50 <ReinH> phaazon: http://webcache.googleusercontent.com/search?q=cache:AV70JlHUJHEJ:https://www.haskell.org/haskellwiki/Constant_applicative_form&hl=en&gl=us&strip=1
12:13:41 <Javran> can I make some value compile time constant avoiding computing it at runtime? for example a Data.Map.Strict.Map
12:14:03 <shachaf> Not easily.
12:14:07 <phaazon> ReinH, thank you
12:15:33 <zipper> How big is the cabal package list because it sure takes a while to download
12:17:12 <ReinH> zipper: mine is 8MB gzipped
12:17:45 <zipper> ReinH: Well that's unusual then but again my internet is super slow like it's from the stone age.
12:18:09 <zipper> Definitely needs to show progress.
12:18:40 <Javran> try "cabal -3
12:18:46 <Javran> cabal -v3 update
12:18:58 <Javran> that'll show some progress
12:20:03 <joe9> Any recommendations for a charting program wherein I can show the crosshair values on the charted line as I move the cursor? Does not have to be in haskell as long as it works on linux.
12:20:22 * hackagebot calculator 0.1.2.2 - A calculator that operates on string inputs  http://hackage.haskell.org/package/calculator-0.1.2.2 (sumitsahrawat)
12:22:36 <ReinH> Hmm, is there a nicer way to write case x of Nothing -> y; Just x' -> f x' <|> y? One that avoids the case statement?
12:23:01 <joe9> ReinH: using maybe?
12:24:02 <joe9> :t maybe
12:24:03 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:24:14 <ReinH> (x >>= f) <|> y ?
12:24:29 <supki> ReinH: maybe empty f <|> y ?
12:24:53 <ReinH> hmm, that's a bit nicer
12:26:39 <ReinH> (x >>= f) <|> y is short but not necessarily very readable...
12:28:40 <jfmueller> joe9: I'd recommend d3.js, it's in javascript but very flexible
12:28:55 <joe9> jfmueller: thanks, will check it out.
12:29:06 <joseph07> I think I remember reading a paper on denotational semantics where the first example was a Map interface in Haskell. Does that ring a bell to anyone?
12:29:22 <clrnd> joe9, I second d3.js
12:29:41 <clrnd> though that particular functionality will be more of a css/js thing than anything else
12:30:22 * hackagebot hourglass 0.2.7 - simple performant time related library  http://hackage.haskell.org/package/hourglass-0.2.7 (VincentHanquez)
12:30:33 <supki> joseph07: denotational design with typeclass morphisms, I think
12:31:06 <ReinH> joe9: I third d3.js
12:31:16 <joseph07> supki: That's the one! thanks
12:31:17 <ReinH> joseph07: great paper
12:32:44 <adamse_> are there lenses for the time package?
12:32:47 <hodapp> http://eb.host.cs.st-andrews.ac.uk/drafts/dsl-idris.pdf hmm, I wonder how Idris in this regard compares to Ivory
12:35:01 <LunarJetman> Je Suis Charlie
12:35:17 <hodapp> wha?
12:36:50 <platz> hodapp: it seems more general, I think Ivory has a lot of c-specific constructs in it
12:36:57 <platz> especially with regard to typing
12:37:18 <platz> no idea if it generates code as efficient though
12:37:35 <brainacid> haskell code is so nice in midnight commander
12:37:38 <brainacid> lol
12:38:17 <Welkin> midnight commander?
12:39:24 <ReinH> adamse_: not sure, but there are lenses for thyme
12:39:45 <Welkin> oh, a file manager
12:39:46 <hodapp> platz: I've been using it the past few weeks and its code looks to be hit-or-miss. A lot of it is fine, but some things like for-loops just look atrocious
12:39:50 <Welkin> it sounds liek a video game
12:41:07 <ab9rf> yeah, i've made that mistake several times
12:41:21 <platz> hodapp: I was interested to try and generate some code to put on some micros I have but yeah, not sure if it's worth it
12:41:27 <hodapp> platz: Ivory or Idris?
12:41:33 <platz> ivory
12:42:25 <platz> actually more of an issue would by trying to use libraries others have wrote
12:42:45 <hodapp> hmm, so if Ix has type role phantom, and newtype Ix { n :: Nat }... then Ix 0 is representationally equal to Ix 1 and so on for all type-level naturals?
12:42:49 <platz> there's no way I'm going to know to code up an LCD library from scratch
12:43:29 <hodapp> platz: the deal I ran into that I'm still trying to deal with is that I seem to have to model any external structs that I must make reference to, and it makes no good way to just pass along an opaque pointer
12:43:55 <hiptobecubic> joe9, you might check out vega first. it's a bit higher level and uses d3 under the hood. d3.js has quite a learning curve.
12:44:10 <hiptobecubic> it's also declarative :)
12:44:21 <c_wraith> hodapp: yes, but that really doesn't mean much except you can use coerce to convert between them as a no-op.
12:44:25 <joe9> hiptobecubic: thanks a lot. will check it out.
12:44:32 <c_wraith> hodapp: and that's rarely something you'd want to do
12:44:58 <hiptobecubic> joe9, sure. i don't know what all you can accomplish with it, but i'd start there.
12:45:08 <hodapp> c_wraith: I'm just trying to make sense of the nature of the type because documentation is scanty
12:45:14 <ReinH> hiptobecubic: d3.js is pretty declarative as well, fwiw
12:45:14 <brainacid> Welkin.. gnu mc, hex editor, vfs mounter, file mang, and nice haskell syntax with internal editor
12:45:23 * hackagebot hourglass 0.2.8 - simple performant time related library  http://hackage.haskell.org/package/hourglass-0.2.8 (VincentHanquez)
12:45:35 <brainacid> its really powerful
12:45:48 <brainacid> and it makes sys admin a breeze
12:46:32 <ab9rf> hm, i've neverf ound a gui tool that actually makes system administration easier
12:46:32 <platz> depends on how unique your needs are - if you just need time series http://metricsgraphicsjs.org/ is built on d3
12:47:04 <hodapp> ab9rf: sadly, it's that way for me too. I feel like it always devolves into mazes and really leaky abstractions
12:47:07 <platz> or http://c3js.org/
12:47:19 <hodapp> "hey, something gigantic is failing to work! BUT HERE'S A SMILEY FACE."
12:47:41 <ab9rf> hodapp: and the GUI makes it harder to actually get to what you need
12:47:41 <ab9rf> to fix
12:48:37 <joe9> platz: thanks.
12:49:10 <sleepomeno> is there a pretty printing library which makes it possible to 'skip' printing values of a specific type?
12:52:09 <brainacid> ab9rf.. mc is not GUI
12:52:11 <ReinH> sleepomeno: wouldn't they all let you do that?
12:52:36 <ReinH> by setting their pretty printed value to be empty?
12:52:49 <ReinH> s/setting/defining
12:54:18 <Zemyla> Okay, I jad a question about the Set monoid.
12:54:51 <Zemyla> Specifically, the "unions" function.
12:55:23 * hackagebot hoobuddy 0.1.0.1 - Simple tool for fetching and merging hoogle data  http://hackage.haskell.org/package/hoobuddy-0.1.0.1 (gilligan)
12:55:26 <ReinH> Zemyla: what is your question?
12:56:17 <sleepomeno> ReinH: I guess this works if you create the Doc s for your types yourself (not sure). i would like to have a pretty printing function which derives the doc s generically but allows some 'exceptions' in that automatic process
12:57:04 <Zemyla> It's implemented with a simple foldl. However, you would get much better performance if it were a pairwise fold.
12:57:22 <joe9> platz: c3js.org is cool.
12:57:46 <quchen> If your prettyprinter is a monoid you can use a holey monoid to aggregate your result, and decide what to print in the end (by supplying `id` or `const mempty`).
12:57:48 <dfeuer> Zemyla, why?
12:58:34 <ReinH> Zemyla: it actually uses a strict fold
12:58:36 <ab9rf> pairwise fold?  for union?  don't follow.
12:58:52 <Zemyla> Let's take the simplest example, unions $ map singleton ls.
12:59:05 <ReinH> Zemyla: the comment says it uses foldl, but the implementation uses a function called foldStrict from an internal module Data.Utils.StrictFold
12:59:49 <Zemyla> It's just an illustrative example, not something you should actually do, but suppose the list is n items long.
13:00:05 <platz> joe9: there are lots of charting libraries ontop of d3 - d3 is much more general though
13:00:24 <platz> http://ruoyusun.com/2014/05/26/what-d3js-is-not.html
13:00:35 <joe9> platz: oh, ok. thanks.
13:00:36 <ReinH> platz: it's like a cottage industry
13:00:51 <Zemyla> The kth fold unions a set of size k with a set of size 1, for time O(k) and a set of size k+1.
13:01:11 <Zemyla> If this is done n times, then the total runtime is O(n^2).
13:02:34 <ReinH> Zemyla: union is O(n+m)
13:02:35 <platz> ReinH: yep, with oodles of users
13:02:42 <Zemyla> However, if you were to call unions on the left half of the list, then the right half, and then union them together, it would be a merge sort, with run time O(n log n).
13:02:43 <ReinH> platz: Oh, I love D3
13:02:57 <Zemyla> ReinH: Yes, but O(k+1) is O(k).
13:04:01 <quchen> ReinH: I think he's saying that the union of a set with itself is O(2*n), so the n-times-self-union of a set of size n is O(n^2).
13:05:09 <ReinH> Zemyla: so you're suggesting that unions should use a tree fold rather than a foldl
13:05:14 <Zemyla> ReinH: Merging two sorted lists is O(n+m), too, so binary merging gives time O(n log n) there too.
13:05:28 <platz> ReinH: I thought the data transformation stuff was interesting, all the enter/exit business, but haven't really used it for anything yet
13:05:38 <ReinH> platz: I've used it a fair amount. It's really nice.
13:05:39 <platz> i wonder why I haven't seen that pattern elsewhere
13:07:27 <ReinH> Zemyla: seems reasonable. You could create an issue and get feedback from the maintainers. https://github.com/haskell/containers/issues
13:08:32 <augustss_> Indeed.  Please make a patch.  But make sure to include some benchmark numbers.
13:10:24 * hackagebot llvm-general 3.3.13.3 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.13.3 (BenjaminScarlet)
13:10:26 * hackagebot llvm-general 3.4.4.3 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.4.4.3 (BenjaminScarlet)
13:11:51 <platz> I guess .enter and .exit make sense when you are maintaining a mapping between two sets i.e. DOM and data
13:13:21 <platz> since a lot of server code is transformations on data, perhaps the paradigm makes sense there too of the target mapping is persistant
13:14:01 <ReinH> platz: http://bost.ocks.org/mike/join/ http://bost.ocks.org/mike/selection/
13:16:10 <platz> yeah, point being you needd to make a selection first to compare the data against
13:18:54 <EvanR-work> "if P implies Q, then either P is false or Q is true" ?
13:22:15 <Zemyla> platz: If I'm writing a benchmark with generated data, I should have a baseline loop that merely generates the data and puts it into rnf, to show how long that takes, correct?
13:25:22 <ReinH> Zemyla: you might look at the existing benchmarks https://github.com/haskell/containers/tree/master/benchmarks
13:25:25 * hackagebot hydrogen-prelude 0.12 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.12 (JulianFleischer)
13:25:27 * hackagebot hydrogen-parsing 0.12 - Hydrogen Parsing Utilities  http://hackage.haskell.org/package/hydrogen-parsing-0.12 (JulianFleischer)
13:26:06 <platz> I've understood that they question "am I doing benchmarks wrong?" is always 'yes'
13:26:23 <platz> at least for me
13:27:07 <EvanR-work> run the test. does it take long enough to run that you notice? its slow. otherwise its fast ;)
13:28:09 <johnw> "if P implies Q, then either P is false or Q is true" is only true if you admit the law of excluded middle
13:28:39 <johnw> or alternatively you can show that P is decidable
13:29:12 <EvanR-work> thats what i suspected
13:30:15 <EvanR-work> its in the footnote of metamath.pdf intro, as an example of a logical proposition... though it doesnt claim its true
13:30:25 * hackagebot hydrogen-cli-args 0.12 - Hydrogen Command Line Arguments Parser  http://hackage.haskell.org/package/hydrogen-cli-args-0.12 (JulianFleischer)
13:30:27 * hackagebot hydrogen-data 0.12 - Hydrogen Data  http://hackage.haskell.org/package/hydrogen-data-0.12 (JulianFleischer)
13:30:29 * hackagebot hydrogen-syntax 0.12 - Hydrogen Syntax  http://hackage.haskell.org/package/hydrogen-syntax-0.12 (JulianFleischer)
13:30:31 * hackagebot hydrogen-cli 0.12 - Hydrogen Data  http://hackage.haskell.org/package/hydrogen-cli-0.12 (JulianFleischer)
13:30:49 <johnw> it's trivial to prove in Coq if I admit LEM
13:30:56 <johnw> and impossible if I don't :)
13:31:27 <EvanR-work> can you prove its impossible to prove?
13:31:43 <johnw> what would the witness to such a proof be?
13:32:08 <EvanR-work>  a function from such a proof to _|_
13:32:15 <johnw> let me try
13:32:42 <EvanR-work> give that ... LEM is .. not given
13:33:00 <EvanR-work> maybe a conservative result is that its equivalent to LEM
13:34:12 <Peaker> GHC compile times are frustrating when you make changes to some deeply imported module!
13:34:30 <ab9rf> heh
13:34:31 <johnw> I cannot prove that it always results in ⊥
13:34:35 <Peaker> If the build system used by ghc/cabal had any form of old-build caching, it would be so much better
13:36:18 <johnw> with any kind of caching would come a huge increase in questions about subtle bugs in the way it had broken :)
13:38:43 <Peaker> johnw, that's why you make sure the cache is correctly created :) e.g: in buildsome, I use a "stat" call on the inputs before and after the build, to verify it didn't change during the build, so I don't get poisoned caches
13:39:27 <johnw> yeah, it would still always break :)  our new first answer to all cabal questions would be, "Have you cleared your build cache?"
13:41:00 <Peaker> johnw, why?
13:41:37 <johnw> because that's just the way programming is
13:41:42 <Peaker> johnw, we've extensively used buildsome at my company. While I had a few bugs in buildsome that required a handful of cleans, with a bit more development effort there would never be poisoned caches
13:41:56 <johnw> ok, but I'll believe it when I see it
13:42:06 <Peaker> ("cabal" has probably 4 orders of magnitude more effort behind it than buildsome)
13:42:20 <Peaker> johnw, notice that cabal already caches the most recent build (inside the working tree)
13:42:31 <Peaker> so there's already potential for a broken cache. it's just not caching previous builds
13:42:47 <johnw> yeah, I have to find . -name dist | xargs rm -fr more often than I'd like
13:43:30 <ReinH> Peaker: buildsome's README brought me to tup, which brought me to this page, which contains one of the most awesome initial paragraphs I have ever read http://gittup.org/tup/make_vs_tup.html
13:43:39 <Peaker> I use "cabal clean" maybe once every few weeks
13:44:05 <Peaker> ReinH, it's cheating, though :) It's using inotify with a daemon
13:44:16 <ReinH> :)
13:44:27 <Peaker> tup is great, but not great enough :)
13:44:52 <ReinH> Sure. I just like that paragraph.
13:44:58 <johnw> "Is it right to value the pursuit of science over life? Even if it's something that does not ever truly live? That is a question that even tup cannot answer."
13:45:33 <ReinH> I guess whoever made tup likes tup quite a bit.
13:45:37 <ahf> #c
13:45:47 <hodapp> hmmm, wonder what I can do with an "integer" that is in Num and Bounded
13:45:52 <hodapp> and I need to make it... a real integer
13:46:00 <johnw> "a real integer"
13:46:04 <johnw> that sounds like the start of a math joke
13:46:09 <hodapp> like, an Int
13:46:39 <johnw> so, not a Real, and not a Integer; check :)
13:46:44 <hodapp> Integer is fine too
13:47:04 <hodapp> actually Real is probably fine because I can just coerce that somehow
13:47:15 <johnw> ReinH: lol, did you see http://gittup.org/tup/tup_vs_mordor.html?
13:47:25 <johnw> "this page compares tup to the All-Seeing Eye of Mordor. Most people cannot harness the unfathomable power of the All-Seeing Eye of Mordor for their everyday build system, so you cannot expect to get the same build times that he achieves."
13:47:29 <hodapp> https://hackage.haskell.org/package/ivory-0.1.0.0/docs/Ivory-Language-Array.html#t:IxRep that guy
13:47:34 <ReinH> johnw: I literally can't even
13:47:36 <augustss_> Three Integers walked into bar...
13:47:47 <johnw> ah, augustss_ understands!
13:48:23 <ReinH> augustss_: A real number, a complex number, and a priest walk into a bar?
13:48:31 <johnw> they all tried to divide the same factor and wound up floored
13:49:03 <augustss_> I'm having a hard time fitting the priest into any numerical type class.
13:49:18 <hodapp> Ix parametrizes over GHC.TypeLits.Nat, and is explicitly an integer from 0 .. n-1, and I can easily turn a Nat into an Int, but I cannot find a way to turn Ix or IxRep into... anything
13:49:18 <ReinH> augustss_: imaginary number?
13:49:20 * ReinH ducks
13:49:25 <augustss_> Church numeral!
13:49:29 <ReinH> augustss_: bingo!
13:49:35 <ReinH> That was totally what I had in mind
13:50:48 <augustss_> I could make some terribly inappropriate joke about succ now.
13:50:52 <hodapp> And... it's boggling my mind it should be THIS DIFFICULT to extract an Integer out of an integer
13:51:12 <augustss_> hodapp: huh?
13:51:14 <johnw> hodapp: what is the type of the function you want?
13:51:29 <augustss_> hodApp: fromIntegral?
13:51:37 <johnw> or toInteger?
13:51:48 <hodapp> https://hackage.haskell.org/package/ivory-0.1.0.0/docs/Ivory-Language-Array.html#t:IxRep -  Ix n -> Int or IxRep -> Int
13:52:00 <hodapp> or to... basically any integral type
13:52:21 <Javran> I want to implement a simple model checker, any recommendation for starters?
13:52:22 <augustss_> fromIntegral is pretty versatile
13:53:09 <hodapp> augustss_: fromIntegral requires Integral which for whatever reason these lack
13:56:13 <platz> I'll probably go watch a video later, but off the top of anyone's head, for monoids why do we say there 'is only one object' in the cateogry; for example for nats we have <nats,+,0> with the set nats as the 'unique' object of the category, but the arrows are the 'elements' of nats.  I thought arrows could only be between objects which we defined as the whole set.  somehow we're able to 'open up ' the object and put more arrows in there?
13:56:17 <augustss_> Why can't you use fromIntegral . fromIx ?
13:56:40 <hodapp> augustss_: because Sint32 is not Integral either.
13:57:20 <platz> from http://www.cs.nott.ac.uk/~gmh/cat1.pdf
13:57:29 <erisco> if I write a parser in parsec, can I use that parser and TemplateHaskell to create an EDSL?
13:57:40 <ReinH> hodapp: well that just seems like they forgot to make it a member of Integral :(
13:57:44 <ReinH> since it is, in fact, an integer.
13:57:52 <augustss_> hodapp: Oh, these are symbolic expressions.  I think you're out of luck.
13:57:52 <erisco> if so, seems easier than figuring out the type level programming which would make me happy
13:57:59 <ReinH> This is also the first release of the package...
13:58:02 <ab9rf> so just make it an instance of Integral :)
13:58:14 <augustss_> How?
13:58:27 <ab9rf> instance Integral Sint32 where ....
13:58:45 <augustss_> yes, and then?
13:59:02 <ab9rf> i dunno, you'll have to look at Integral to see what instance functions have to be defined
13:59:13 <ab9rf> i dunno offhand what Integral requires
13:59:17 <augustss_> Just tell me how to do toInteger
13:59:28 <hodapp> augustss_: They're used throughout for representing constants, because it is the only way to index an array, so I'm trying to see what symbolic expression it could really express.
14:00:07 <qsuscs> i’m looking for a way to insert spaces in a string
14:00:13 <ReinH> augustss_: well, the Expr and Literal data constructors are exported
14:00:17 <qsuscs> i.e. "fnord" shall become "f n o r d "
14:00:20 <qsuscs> any ideas on that?
14:00:37 <hodapp> that is, I can do (5 :: Ix SomeNat) all I want
14:00:41 <augustss_> Expr contains all kinds of stuff that cannot be turned into an Integer.  Like symbols.
14:00:46 <ReinH> @hoogle intersperse or intercalate
14:00:48 <lambdabot> No results found
14:00:49 <ReinH> er
14:00:54 <ReinH> qsuscs: intersperse or intercalate
14:01:12 <ab9rf> :t intersperse
14:01:13 <ReinH> augustss_: but we're talking about the Sint32 newtype wrapper, which does not
14:01:14 <lambdabot> a -> [a] -> [a]
14:01:23 <ReinH> augustss_: I'm not suggesting we make Expr an instance of Integral
14:01:24 <ab9rf> > intersperse ' ' "fnord"
14:01:25 <lambdabot>  "f n o r d"
14:01:57 <qsuscs> ReinH: very well, thanks
14:01:59 <ReinH> Well, I suppose you could construct an invalid SInt32, which is a problem with the library design
14:02:03 <augustss_> ReinH: And how do we know the Sint32 doesn't contain anything bad?
14:02:29 <ReinH> augustss_: We don't, but it's already an instance of Nu, so in for a penny, in for a pound
14:02:31 <ReinH> *Num
14:02:43 <augustss_> Num is fine.
14:02:47 <ab9rf> i'm confused as to what a Sint32 is
14:02:59 <erisco> oh, if TH only works on Haskell ASTs then that aint no help to me
14:03:15 <hodapp> ab9rf: yeah, it'd be awesome if the docs explained it at all.
14:03:36 <augustss_> ReinH: Num only injects values into the type, it doesn't extract.
14:03:46 <ReinH> augustss_: fair enough.
14:04:01 <ReinH> augustss_: still, the problem is that SInt32 is a leaky abstraction
14:04:10 <augustss_> ReinH: A partial toInteger is possible.
14:04:30 <ReinH> Which makes me rather question the safety of this "safe low-level programming" package.
14:04:50 <ReinH> augustss_: I would guess that they will eventually use a smart constructor for these values
14:05:02 <augustss_> I don't know what the actual use case is.  But this looks like symbolic expressions, so I'd think it's very much on purpuse you cannot extract an Integer.
14:05:06 <hodapp> ReinH: The Galois devs seem to know what they're doing... they just have failed to document any of it sufficiently.
14:05:24 <ReinH> hodapp: They generally do know what they are doing, but this is an initial release.
14:05:28 * hackagebot sloane 2.0.1 - A command line interface to Sloane's On-Line Encyclopedia  of Integer Sequences  http://hackage.haskell.org/package/sloane-2.0.1 (AndersClaesson)
14:05:35 <erisco> I suppose you can grossly reuse the Haskell syntax but... yucky...
14:05:49 <ReinH> augustss_: I don't see how SInt Break is a valid value, period.
14:06:04 <augustss_> hodapp: you could always try read.show
14:06:07 <hodapp> perhaps I'll have to find a way to parametrize over Nat or something, and turn that to an Ix somehow.
14:06:17 <hodapp> augustss_: 'show' doesn't touch it.
14:06:18 <ab9rf> hodapp: well, i don't feel so bad about being confused then
14:07:15 <ReinH> augustss_: and it seems pretty clear that they do intend for these values to be extracted since they provide a typeclass for doing so
14:07:34 <ReinH> Well
14:07:38 <hodapp> ReinH: that may refer to abstraction that does not ever occur in Haskell.
14:07:41 <ReinH> Not quite.
14:07:43 <hodapp> s/abstraction/extraction/
14:07:54 <hodapp> ReinH: but rather is done 'sometime' in the C code, maybe.
14:08:04 <ReinH> I suppose the intent is for Expr to be evaluated via their own mechanisms, not pattern matched on
14:08:09 <ReinH> But they haven't restricted the exports yet
14:08:21 <hodapp> still I'm a little confuzzled why they parametrized over GHC.TypeLits.Nat.
14:08:23 <ReinH> So right now it's wide open to misuse
14:08:28 <augustss_> 1 + 2 :: Sint32 seems legal, and will need an evaluator to get a value out of.
14:08:54 <ReinH> augustss_: Yeah, that's clearly the intent, but right now they export everything, including Expr constructors
14:09:02 <ReinH> Like I said, it's an initial release
14:09:14 <hodapp> because they forced the bounds to be compile-time... for expressions that cannot even be evaluated at run-time.
14:10:37 <kaiyin> Is it a bad practice to make the module name different from filename?
14:10:51 <c_wraith> kaiyin: ghc only even allows it if the module name is Main
14:11:10 <c_wraith> kaiyin: otherwise, module names are mapped to code via filename
14:11:17 <ReinH> augustss_: So if you use the implicit contract to only use smart constructors and destructors, you get a safe EDSL. But it's wide open to misuse until they lock down the exports.
14:11:29 <kaiyin> c_wraith, ok, I see. Thanks!
14:11:41 <erisco> oh, I was reading from 2008, now there is quasiquoting
14:12:16 <tolt> Is there any TH function that will attempt to evaluate some expression in its current context? ie String - Q Exp?
14:12:19 <hodapp> erisco: what's this about?
14:12:27 <augustss_> ReinH: Yeah, I looked a little bit.  It's really not ready for users.  You need to lock down the APIs so internals cannot be misused.
14:12:32 <tolt> String -> Q Exp *
14:12:34 <ReinH> augustss_: exactly
14:12:42 <erisco> I am wondering if you can use TH + Parsec to implement an EDSL
14:12:47 <R0b0t1> How do I type something as either Int or String?
14:13:02 <HeladoDeBrownie> R0b0t1, Either Int String ?
14:13:15 * R0b0t1 smacks head
14:13:15 <hodapp> R0b0t1: "Either Int String"?
14:13:19 <HeladoDeBrownie> R0b0t1, you'll need the Left and Right constructors though
14:13:23 <ReinH> or something equivalent
14:13:31 <erisco> doing so might let me dodge a lot of complicated types by hiding away some unsafe operations
14:13:55 <tolt> erisco: using quasiquoting?
14:13:55 <hodapp> augustss_: it's compelling enough that I've been using it, but I suspect I'll be having to either write documentation myself or prodding them a bit to get any.
14:14:02 <ReinH> So I think the answer to hodapp's question is "you are not supposed to be able to do that, so by trying to do that you are probably doing something wrong"
14:14:03 <erisco> tolt, yeah
14:14:05 <Javran> > (,,) <$> ($ 1) <*> ($ 2) <*> ($ 3) $ show
14:14:06 <lambdabot>  ("1","2","3")
14:14:15 <HeladoDeBrownie> R0b0t1, i.e., if you want to construct values of that type. Left 10 :: Either Int String, Right "foo" :: Either Int String
14:14:18 <ReinH> Javran: such Cont, wow
14:14:24 <tolt> erisco: That's what I'm doing with something similar to hamlet (for html parsing)
14:14:28 <tolt> and templating
14:14:37 <erisco> did you invent hamlet?
14:14:46 <tolt> Nope.
14:15:00 <R0b0t1> HeladoDeBrownie: Well, no. I might not be able to use Either then. I will be parsing a line and there is an element which will either be text or a numeric. I need a variable to hold that portion of the line.
14:15:07 <tolt> But I'm using some of the ideas to write a templating engine
14:15:11 <erisco> ah, I know someone who worked at the same company as the inventor so I was curious
14:15:13 <Javran> ReinH: just thinking applying same function on all arguments before passing them into another function
14:15:14 <HeladoDeBrownie> R0b0t1, sure, what i just said would work for that.
14:15:20 <hodapp> ReinH: well, I was rather misled by how they portrayed Ix, and had thought that it was basically trying to enforce array indices bounds at compile-time or Haskell run-time where possible since it parametrizes it over Nat
14:15:20 <Zemyla> ReinH: Oh, I think I just figured out how to do a binary merge with just a left fold.
14:15:46 <R0b0t1> oh, I see what you said
14:15:56 <erisco> tolt, so how has it been working out? are you using Parsec?
14:16:37 <kaiyin> How can I load a symbolic link file into ghci? For example, I have a file m linked to TAMO.hs, and if I do :l m, ghci complains that m is not a module nor a source file.
14:16:43 <tolt> erisco: Great! I can show you what I've been working on. I'm pretty much done with the parsing portions. I'm not using Parsec though. I'm using trifecta and parsers (ekmett's library)
14:17:28 <tolt> erisco: The goal is to use it for building web pages with ghcjs and vdom
14:17:37 <ReinH> hodapp: right, but you aren't supposed to be coercing those values. You are supposed to be using them to build up a structure using the DSL and then evaluate it.
14:18:01 <erisco> tolt, part of the reason I want to use this approach, other than the clarity of the EDSL, is that an equivalent representation in Haskell would require complicated types
14:18:01 <HeladoDeBrownie> R0b0t1, feel free to ask here if you need help implementing it. also, have you read any introductory material? i ask because most i've seen covers Either
14:18:24 <tolt> erisco: You still need some type of backed for the parsing
14:18:34 <R0b0t1> HeladoDeBrownie: Yes, it hasn't stuck yet.
14:18:56 <HeladoDeBrownie> R0b0t1, fair enough, you'll get it with use
14:18:58 <hodapp> ReinH: Right now I'm building up code at run-time that involves array access, which explicitly must be done with Ix unless I want run-time checks inserted everywhere.
14:18:58 <tolt> Quasiquoting like that is mainly a function String -> Q Exp
14:19:03 <erisco> tolt, the EDSL will have to generate a typed interface that regular Haskell code can call
14:19:13 <ReinH> hodapp: but you can convert *to* Ix, right?
14:19:55 <erisco> tolt, have you run into a similar situation and perhaps had to use undesirable solutions such as Dynamic under the hood?
14:20:01 <tolt> erisco: I'm a little confused
14:20:27 <hodapp> ReinH: I can do, for instance, (3 :: Ix 8).
14:20:28 * hackagebot FontyFruity 0.4.1 - A true type file format loader  http://hackage.haskell.org/package/FontyFruity-0.4.1 (VincentBerthoux)
14:20:30 * hackagebot shake 0.14.3 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.14.3 (NeilMitchell)
14:20:39 <tolt> erisco: Everything I've done is typed pretty strongly.
14:21:33 <erisco> the EDSL I want is not merely a convenient way of writing equivalent Haskell programs, the reality is that there is no equivalent Haskell program (at least not one that is practical)
14:21:34 <ReinH> hodapp: right
14:21:52 <erisco> it is not practical because the necessary types are complicated
14:22:15 <tolt> erisco: How would you parse it then?
14:22:28 <erisco> parse the EDSL? I was presuming with Parsec
14:22:59 <tolt> Yeah. But the general idea is to parse it into some sort of structure
14:23:18 <hodapp> ReinH: converting at runtime - I really don't know. I think toIx does that.
14:23:31 <erisco> to generate Haskell definitions, yes, and what I am saying is that I don't have good Haskell definitions to generate
14:24:02 <erisco> it is probably easier for me to use facilities such as Dynamic, and I was just wondering if you encountered something similar
14:24:10 <hodapp> ReinH: I can do that conversion at runtime on Ivory expressions. When it's not Ivory expressions, then it gets hairy.
14:24:29 <tolt> erisco: ahh. I haven't. My types are fairly straitforward
14:24:53 <tolt> but, I can say that if you have to parse something I would definitely recomend parsec/parsers
14:25:04 <tolt> (parsers being the ekmett library)
14:26:03 <ReinH> +1
14:26:07 <erisco> okay. I can at least start down the road and see how it turns out
14:26:13 <ReinH> Trifecta is great for parsing PLs too
14:26:30 <ReinH> (using the parsers interface)
14:27:02 <tolt> I've had to parse things in other languages with other librarys and nothing really compares.
14:27:25 <tolt> I would say that I prefer trifecta and parsers but there isn't as much tutorial material for it.
14:27:35 <tolt> nobody write any posts about that. it's mine.
14:28:06 <qsuscs> i’m currently trying to rewrite one of my hackerys from C to haskell
14:28:16 <qsuscs> it prints a table of all printable ascii characters: https://gist.github.com/qsuscs/15347ba97c9c00c449ae
14:28:46 <qsuscs> that is, the output looks like this http://pastie.org/private/oyv0i6des6gwm35l8ksz7q
14:29:04 <erisco> tolt, how does reporting errors when compiling the EDSL work?
14:29:31 <qsuscs> [ (intersperse ' ' [chr x | x <- [0x00 + i .. 0x0f + i]]) | i <- [0x20, 0x30.. 0x70]] is how far i got (and it still contains \DEL aka 0x7f)
14:29:55 <tolt> erisco: Well, if you use parsers/trifecta and the parsing fails, because you're in the Q monad you can fail and print the doc that trifecta gives you and it shows line numbers and other things
14:30:07 <Axman6> @hoogle Data.Char.is
14:30:09 <lambdabot> Data.Char isAlpha :: Char -> Bool
14:30:09 <lambdabot> Data.Char isAlphaNum :: Char -> Bool
14:30:09 <lambdabot> Data.Char isAscii :: Char -> Bool
14:30:15 <Axman6> @more
14:30:24 <Axman6> :(
14:30:29 * hackagebot Rasterific 0.4.1 - A pure haskell drawing engine.  http://hackage.haskell.org/package/Rasterific-0.4.1 (VincentBerthoux)
14:30:33 <erisco> tolt, okay, so errors are represented in the Q monad, good to know
14:30:35 <hodapp> So right now I'm trying to figure out how I can go about turning an Int into an Ix. I can do it with a literal. I can do it with a bunch of ugly run-time checks in the C.
14:30:47 <tolt> erisco: fail is something in all monads
14:30:55 <Axman6> @hoogle isPrint
14:30:55 <lambdabot> Data.Char isPrint :: Char -> Bool
14:30:56 <ReinH> tolt: (sadly)
14:31:16 <hodapp> but anything I can do arithmetic on at runtime or compile-time... apparently not?
14:31:20 <hodapp> unless I make it an Ivory expression first
14:31:38 <erisco> I have never heard of this "fail" before... that is a scary design choice
14:32:12 <tolt> erisco: http://lpaste.net/1959785279287984128
14:33:16 <lemur> hi, I'm trying to focus on creating types and instances of them. I'm having trouble defining my type with the appropriate data constructor though.
14:34:02 <dgomez> hi, I'm trying to focus on creating types and instances of them. I'm having trouble defining my type with the appropriate data constructor though.
14:34:09 <dgomez> yes, the idiot is back...
14:34:21 <erisco> zzing I know who you are now!
14:34:23 <hodapp> dgomez: get your hands off the dunce cap, it's mine for now.
14:34:23 <dgomez> very rough : data stillHere a = Either String {getLine  a} Nothing
14:34:57 <qsuscs> good, unlines is what i searched.
14:35:00 <dgomez> if you can tell I want to create the type to either return the Input as a string or return nothing if there is no input
14:35:04 <hsk3> I think I came to a realization.
14:35:05 <hsk3> In many languages, you end up with this if-else jungle that stretches to the right of the screen.
14:35:05 <hsk3> Haskell monads (the do notation) solve this problem right??
14:35:26 <dgomez> I keep getting a parse error with either a type constructor from getLine to a
14:35:29 * hackagebot JuicyPixels 3.2.2 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.2.2 (VincentBerthoux)
14:35:31 <erisco> hsk3, it can help, yes
14:35:31 <hodapp> hsk3: In certain cases, they perhaps can.
14:35:39 <hodapp> hsk3: but so can a lot of other Haskell constructs
14:35:43 <dgomez> or I get a parse error bc I do not had e the app. data constructor
14:35:46 <hodapp> and a lot of things that aren't specific to Haskell, really
14:35:51 <HeladoDeBrownie> dgomez, i can't figure out what you're after from the pseudocode, but it sounds kinda like you want Maybe String
14:35:55 <hsk3> hodapp: like what?
14:35:58 <Axman6> dgomez: firstly, type names must start with a capital letter: data StillHere a
14:36:11 <shachaf> dgomez; It looks like you're making up syntax here. What is this code inspired by?
14:36:15 <HeladoDeBrownie> dgomez, what do you mean "no input" though? like, empty input? that's usually the empty string, ""
14:36:17 <Axman6> dgomez: after the equals sign, I can't tell what you're trying to do at all
14:36:50 <hodapp> hsk3: Simple things like the $ operator. The use of folds and maps rather than iteration.
14:37:01 <hodapp> hsk3: Pattern matching is a big one.
14:37:07 <hodapp> and pattern matching is surely not a Haskell thing.
14:37:07 <erisco> or using named functions
14:37:12 <qsuscs> how would you this more beautifully and not that one-line-ish? main = putStrLn $ unlines [ (intersperse ' ' [chr x | x <- [0x00 + i .. 0x0f + i], isPrint $ chr x]) | i <- [0x20, 0x30.. 0x70]]
14:37:14 <hodapp> it's more of a "languages that don't come from the stone age" thing
14:37:20 <hsk3> hodapp: thanks
14:37:29 <dgomez> schachaf: I want to be able to have this type check if there is an input or not and return the app string. It's a small do function meant to ask a question and return the input.
14:37:44 <hodapp> It boggles my mind the languages that pass as "modern" but have no good pattern matching.
14:37:56 <xificurC> I'm trying to get this https://github.com/sdiehl/kaleidoscope to work but running cabal configure leaves me with this log http://sprunge.us/ajJG
14:38:05 <dgomez> Axman6: I want it to be able to Either return the app. String or return nothing if an empty string.
14:38:16 <erisco> PHP has array pattern matching, so it is modern, and now JavaScript is getting object pattern matching so it can be modern too :)
14:38:19 <xificurC> I don't understand the log report though
14:38:26 <ReinH> dgomez: You need to actually use Haskell syntax, though. What you wrote is only vaguely similar to actual syntax.
14:39:20 <ReinH> dgomez: you might start with http://learnyouahaskell.com/making-our-own-types-and-typeclasses
14:40:25 <ReinH> dgomez: or http://en.wikibooks.org/wiki/Haskell/Type_declarations
14:40:35 <dgomez> ReinH: no i understand that. And I already read it for the most part. but I'm not sure what you mean by vague syntax. I know its incorrect. I'm trying to play around with making types. I'll look at the wiki link
14:40:43 <EvanR-work> erisco: well theres "destructing assignment"
14:40:48 <EvanR-work> which is not the same
14:40:50 <ab9rf> i'm not sure i want to live in an era where PHP can be considered "modern"
14:41:16 <ReinH> dgomez: I mean that you can't just put things together seemingly at random and end up with a valid Haskell statement.
14:41:27 <hodapp> ab9rf: oh, it's a "modern" language in that all problems are considered to be the programmer's fault for not being disciplined enough.
14:41:33 <ab9rf> ReinH: well, you can try.  monkeys and shakespeare, and all that
14:41:44 <ab9rf> hodapp: heh, indeed
14:41:45 <shachaf> ReinH: As a beginner, that's what you see everyone else doing. :-)
14:42:03 <erisco> EvanR-work, it is just a shorter form of  case x of pat -> y; _ -> error "whoops"   so there :)
14:42:13 <ab9rf> hodapp: as opposed to ancient languages like C and assembly, where all problems are the programmer's fault for not being disciplined enough :)
14:42:41 <EvanR-work> erisco: if only you got an error
14:42:47 <ReinH> shachaf: true enough, but when I tried things and they didn't work, I spent some time trying to figure out why.
14:42:49 <EvanR-work> instead of nulls in all the variables
14:42:57 <hodapp> ab9rf: yeah, pretty much.
14:43:03 <ab9rf> ReinH: a lot of my early haskell was basically randomly smashing crap together and seeing if it worked.
14:43:05 <erisco> hm, good point
14:43:12 <dgomez> ReinH: Ok let me try to modify it post-readin wiki. But maybe a better question is can you use implicit types in defininf a newtype?
14:43:12 <hodapp> ab9rf: It is ALWAYS the programmer's fault. Now you're getting it.
14:43:22 <dgomez> ReinH: not sure if that's understandable
14:43:24 <shachaf> What are implicit types?
14:43:24 <ab9rf> "Hm, what does this do?  Huh, weird.  I have no idea why it did that."
14:43:30 <ab9rf> "Hey, that worked!  yay!"
14:43:40 <ReinH> dgomez: what do you mean by implicit types?
14:43:51 <dgomez> :t either
14:43:52 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
14:43:58 <ReinH> dgomez: either is a value
14:44:03 <ab9rf> what's an implicit type?
14:44:13 <HeladoDeBrownie> dgomez, i'm not sure you need to be worrying about either right now, as opposed to Either
14:44:29 <erisco> :t Either
14:44:30 <lambdabot>     Not in scope: data constructor ‘Either’
14:44:30 <lambdabot>     Perhaps you meant ‘Other’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
14:44:33 <HeladoDeBrownie> :k Either
14:44:34 <lambdabot> * -> * -> *
14:44:36 <erisco> oh dur :)
14:44:36 <HeladoDeBrownie> :P
14:44:38 <ab9rf> hodapp: it's never my fault, because i am perfect.
14:44:45 <erisco> :t (Just, Nothing)
14:44:45 <lambdabot> (a -> Maybe a, Maybe a1)
14:44:46 <ReinH> Uh. Maybe we can wait for them to answer the question...
14:45:40 <hodapp> ab9rf: oh, I am too. It's all those other programmers who can't seem to do anything right.
14:45:58 <dgomez> ReinH: HeladoDeBrownie: ok I will focus on changing it. I mean I was but it seems everything that I'm writing atm is like you pointed out earlier ReinH: vague pseudocode.
14:46:33 <ReinH> dgomez: Convincing the compiler is going to be harder than convincing us anyway...
14:46:46 <HeladoDeBrownie> dgomez, i wasn't aware i suggested a change. it just seemed to be you might have been confusing the Either type with the either value, and the latter isn't nearly as important (it's just as good as pattern matching on Left and Right)
14:47:17 <ReinH> dgomez: I'm not sure what you mean by a type that would "check if there is an input or not"
14:48:01 <HeladoDeBrownie> dgomez, perhaps if you gave a fuller explanation of your problem
14:48:24 <ReinH> dgomez: earlier, you said "I want to create the type to either return the Input as a string or return nothing if there is no input"
14:48:33 <ReinH> Maybe String is an example of such a type
14:48:55 <HeladoDeBrownie> i did suggest Maybe String earlier, but also suggested that String itself might be your answer
14:48:55 <ReinH> Maybe is one of the examples in LYAH
14:49:23 <HeladoDeBrownie> (it depends on what the actual problem is)
14:49:54 <ab9rf> you can't "return nothing" unless you always return nothing
14:50:24 <erisco> but you can return Nothing :D
14:50:25 <ab9rf> () is the only value of type ()
14:50:27 <HeladoDeBrownie> ab9rf, even i'm confused by that statement
14:50:29 <EvanR-work> > (\x -> if even then Just Nothing else Nothing) 9
14:50:31 <lambdabot>  Couldn't match expected type ‘GHC.Types.Bool’
14:50:31 <lambdabot>              with actual type ‘a0 -> GHC.Types.Bool’
14:50:39 <EvanR-work> > (\x -> if even x then Just Nothing else Nothing) 9
14:50:40 <lambdabot>  Nothing
14:50:41 <ab9rf> yes, you can return Nothing sometimes
14:50:47 <EvanR-work> always returns Nothing of some sort ;)
14:50:54 <dgomez> ReinH: agreed, I'm taking it an error at a time: Checking LYAH for a refresher. I believe that types describe or transpose data to an element? So I was trying to get a type to match Input with a String. Or return nothing
14:50:59 <erisco> turns out, Nothing is something
14:51:01 <hodapp> EvanR-work: you speak a great deal of nothing.
14:51:02 <monochrom> @type (\x -> if even x then Just Nothing else Nothing)
14:51:03 <lambdabot> Integral a => a -> Maybe (Maybe a1)
14:51:10 <ReinH> dgomez: types don't perform computation
14:51:11 <HeladoDeBrownie> (granted, i'm not especially hard to confuse :P)
14:51:13 <ab9rf> > let f = \s -> case s of { "" -> Nothing; s -> Just s } in map f ["", "hello"] -- dgomex
14:51:14 <lambdabot>  [Nothing,Just "hello"]
14:51:14 <cow_2001> Someone organize a Haskell Hullabaloo like the Golang Gala!
14:51:16 <hodapp> ReinH: They can :P
14:51:22 <ReinH> hodapp: ... in Haskell
14:51:31 <EvanR-work> type Nothing = Fix Maybe
14:51:32 <hodapp> ReinH: ........ They can :P
14:51:32 <dgomez> HeladoDeBrownie: fmap ("Hello, " ++) a >>= putStrLn (++ "is still here.") this is what I have in the main do function .
14:51:35 <ReinH> hodapp: stahp :p
14:51:48 <hodapp> ReinH: come on, we were JUST talking about GHC.TypeLits.Nat
14:52:07 <ReinH> Fine. Types don't perform computation on values.
14:52:12 <ReinH> In Haskell.
14:52:18 <HeladoDeBrownie> dgomez, what are you *trying* to do?
14:52:28 <hodapp> ReinH: your penance is to go read the entire Hasochism paper.
14:52:31 <HeladoDeBrownie> dgomez, that doesn't type check and i don't know quite what you're after
14:52:46 <ReinH> hodapp: :p
14:52:53 <hodapp> maybe *I* should go read it again
14:52:57 <hodapp> now that I have had to deal with Nat
14:53:00 <monochrom> perhaps simply putStrLn "Hello, is still here."
14:53:18 <ab9rf> i think he's trying to say "Hello, $a is still here." with a substituted
14:53:32 <dgomez> ReinH: so if moving input data is a computation, then I am just confusing myself. I do understand I just seem to lose the right vocab when logging on
14:53:32 <erisco> in that case, use PHP, it is good at that ;)
14:53:37 <monochrom> ok, putStrLn ("Hello, " ++ a ++ " is still here.")
14:53:44 <ab9rf> so basically putStrLn ("Hello, " ++ a ++ " is still here.")
14:53:45 * hodapp locks erisco in the closet
14:53:53 <ab9rf> aw, snap
14:54:02 <EvanR-work> also try putStrLn ("Hello, " ++ a ++ " is still here.")
14:54:04 <hodapp> quick, someone give the point-free version just to confuse
14:54:05 <EvanR-work> now the chrous
14:54:12 <HeladoDeBrownie> @quote fugue
14:54:12 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
14:54:13 <monochrom> erisco knows how to turn PHP into Haskell :)
14:54:14 <ab9rf> putStrLn $ "Hello, " ++ a ++ " is still here."
14:55:06 <dgomez> HeladoDeBrownie: its simply asking a question at the prompt and answering it with a name or comment,. It will take that input and concatenate it with a predetermined sentence.
14:55:20 <EvanR-work> "Hello, " & (++ a) & (++ " is still here")
14:55:24 <HeladoDeBrownie> dgomez, did the contrapuntal fugue of responses give your answer?
14:55:35 <hodapp> EvanR-work: what is & again?
14:55:40 <EvanR-work> flip ($)
14:55:43 <monochrom> dgomez: perhaps you should read my http://www.vex.net/~trebla/haskell/IO.xhtml
14:55:48 <ReinH> dgomez: This is one of the first examples in http://learnyouahaskell.com/input-and-output#hello-world
14:56:09 <ReinH> Modulo the contents of the strings, it is *exactly* what you want.
14:56:28 <hodapp> :t (&)
14:56:29 <lambdabot> a -> (a -> b) -> b
14:56:45 <hodapp> huh, not available in GHCi for me
14:56:50 <ReinH> hodapp: lens defines it
14:57:00 <erisco> HeladoDeBrownie, I like the analogy
14:57:01 <hodapp> it's probably best that I not learn it
14:57:05 <hodapp> it'll just convolute my code further
14:57:18 <J_Arcane> I should re-read/finish LYAH ... I found it got a bit of a drag when it went into the whole 'detailing every single function in the standard library one at a time' thing.
14:57:41 <ReinH> J_Arcane: LYAH isn't very good, but it at least explains how to do this reasonably well
14:57:53 <tolt> better than not explaining it right?
14:58:04 <monochrom> my explanation is the best. :)
14:58:09 <HeladoDeBrownie> erisco, i just stole it from monochrom :)
14:58:10 <ReinH> tolt: I think it is possible for explanations to have negative utility, but these don't. Quite.
14:58:22 <hodapp> are you sure you didn't accidentally start reading http://hackage.haskell.org/package/base instead of LYAH?
14:58:30 <J_Arcane> ReinH: Yes. It explains things very clearly. IF you can slog through those parts, or just skim them, it's probably the best. I've been toying with porting it to an FPComplete tutorial.
14:58:35 <tolt> Yeah. I mean that they are explaining the functions (even though it might be overkill to explain them all)
14:58:45 <ReinH> Also yes, monochrom's is very good
14:58:47 <J_Arcane> I wish I could get the Haskell Koans to build ...
14:58:59 <ReinH> J_Arcane: it covers too little of Haskell to be useful too slowly to be enjoyable.
14:59:32 <dgomez> HeladoDeBrownie: its just given me an understanding that I am still trying to get an intuitive sense of writing out declarations. just bc I can read or follow along with some code at times doesn't make for good learning. I know I probably need to read over the IO page and start from scratch?
15:00:03 <ReinH> dgomez: do the exercises. DO THE EXERCISES.
15:00:14 <ReinH> That's another problem with LYAH, btw. No exercises :(
15:00:30 <EvanR-work> dont do the exercises!! </billyjean>
15:00:50 <hodapp> yes, exercises are very important.
15:00:53 <hodapp> even stupid ones.
15:00:55 <hodapp> to a point.
15:01:05 <dgomez> ReinH: yeah, I get that. This is me trying to complete another one. They have all been wrong so far, but I understand exercise makes better ...
15:01:36 <ReinH> dgomez: try to do things in small steps, and be willing to back up if something is confusing you and take smaller steps
15:02:19 <ReinH> It's much easier to learn a single thing or fix a single mistake at a time...
15:02:49 <eXeC64> :src fix
15:02:57 <HeladoDeBrownie> dgomez, you don't necessarily have to start from scratch, but be open to recognizing when you get things wrong and rereading or otherwise correcting yourself. and listen to ReinH: exercises are very handy :)
15:03:06 <eXeC64> >src fix
15:03:13 <eXeC64> :source fix
15:03:13 <J_Arcane> Yes. Always do the exercises. This is why I like exercise/test-driven interactive learning. No language is useful or likely to be learned deeply unless you use it.
15:03:20 <EvanR-work> @src fix
15:03:20 <lambdabot> fix f = let x = f x in x
15:03:24 <eXeC64> EvanR-work: thanks
15:03:39 <monochrom> fix f = let x = f x in x. read my http://www.vex.net/~trebla/haskell/fix.xhtml
15:03:42 <ab9rf> isn't let defined in terms of fix?
15:03:55 <monochrom> no, not in Haskell. perhaps in another language.
15:03:59 <EvanR-work> let is a primitive
15:04:06 <ab9rf> ah, fair point
15:04:16 <ab9rf> conceptually defined but not mechanically defined
15:04:17 <ReinH> ab9rf: dev.stephendiehl.com/fun/ mentions this a bit
15:04:45 <monochrom> alternatively, yes, let is defined in terms of fix, but not the fix I have just rewritten. some theoretical fix.
15:05:04 <EvanR-work> conceptually let makes more sense the way it is
15:05:05 <hodapp> theoretical fixes, the best kind.
15:05:08 <ab9rf> of course, defining something that implements recursion recursively seems appropriate
15:05:36 <EvanR-work> in let x = e1 in e2, all x in e2 will be replaced with e1
15:05:41 <eXeC64> monochrom: jdiez and I have been slowly figuring out fix in another channel
15:05:50 <EvanR-work> (unless shadowed)
15:06:12 <eXeC64> So far we've essentially found it to be a neat but seemingly useless way to get a named reference to a lambda from within the lambda
15:06:18 <erisco> this is twice that I cannot get a TH TLD past the parser
15:06:19 * dgpratt wishes there were a resource that explains how to translate mathematical formulas into Haskell
15:06:29 <ab9rf> eXeC64: it's a way to refer to a lambda without naming it
15:06:59 <monochrom> there cannot be such a resource. there exists math formulas inexpressible in Haskell
15:07:02 <EvanR-work> you still have to name it to refer to it, but the name is inside the lambda instead of outside ;)
15:07:03 <eXeC64> ab9rf: Which is cool, but it hurts the brain
15:07:13 <dgpratt> monochrom, I don't mean every such formula
15:07:32 <dgpratt> I mean the straightforward stuff
15:07:57 <monochrom> does "straighforward stuff" mean "translate x+y to x+y"?
15:07:59 <erisco> like, [math| 1 + 1 |] == [Haskell| 1 + 1|]
15:08:03 <ab9rf> EvanR-work: yeah, the main thing is that there's no need to reference an external binding to get a reference ot the lambda
15:08:27 <monochrom> an eye for an eye, a y for a y
15:08:29 <EvanR-work> ab9rf: well, you kind of are, due to the definition of fix ;)
15:08:38 <dgpratt> monochrom, making some simplifying assumptions, yes
15:09:11 <EvanR-work> and it might be clearer to put that binding outside, somewhere visible to the code for the function youre implementing, like in a inner where or let
15:09:28 <monochrom> learning how to translate math formulas (those translatable) into Haskell is reducible to learning how to program in Haskell
15:10:04 <dgpratt> well...I kinda think I know how to program in Haskell
15:10:16 <ab9rf> heh
15:10:18 <dgpratt> but there's a lot of math symbology I don't know
15:10:19 <erisco> ohhh you have to enable -XQuasiQuotes
15:10:24 <erisco> nice of them to miss that
15:10:48 <dgpratt> many examples here, for example: http://scienceworld.wolfram.com/physics/DoublePendulum.html
15:11:02 <eXeC64> ab9rf: You're still using fix though, which is an external dependency
15:11:02 <johnw> monochrom: hehe
15:11:34 <erisco> but must be in a different module.. hmm.. I suppose you cannot have two modules in one file
15:11:34 <eXeC64> I asked earlier if there was a built-in. I was hoping for a λ variable referring to the current lambda I guess
15:11:54 <vanila> dgpratt, what about that?
15:11:55 <yoytutyu>  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA
15:11:56 <yoytutyu> ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake
15:11:56 <yoytutyu> les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les
15:11:56 <yoytutyu> nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards
15:12:02 <eXeC64> I was trying to write fibonacci sequence using just a single lambda and essentially no names
15:12:02 <erisco> you don't say
15:12:07 <yoytutyu>  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA
15:12:08 <yoytutyu> ouaaaake les nibards  ALA ouaaaake les nibards
15:12:08 <yoytutyu> yo
15:12:10 <yoytutyu> yoooooooyuyoyuoyuy
15:12:14 <yoytutyu> tututu
15:12:18 <yoytutyu>  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA ouaaaake les nibards  ALA
15:12:18 <yoytutyu> ouaaaake les nibards  ALA ouaaaake les nibards
15:12:23 <EvanR-work> eXeC64: yeah haskell likes to factor out stuff like this when it can be made a library function, especially in the case of random keywords
15:12:23 <gienah> @where ops
15:12:23 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
15:12:25 --- mode: ChanServ set +o johnw
15:12:25 --- mode: ChanServ set +o monochrom
15:12:25 --- mode: ChanServ set +o johnw
15:12:25 --- mode: ChanServ set +o johnw
15:12:26 <ab9rf> > repeat "you you tu tu "
15:12:28 <lambdabot>  ["you you tu tu ","you you tu tu ","you you tu tu ","you you tu tu ","you yo...
15:12:32 <eXeC64> ab9rf: hahaha
15:12:32 <ReinH> too slow
15:12:37 --- mode: monochrom set -o monochrom
15:12:43 <dgpratt> vanila, that's just an example of something that I would understand much better if there were a translation of those formulas to Haskell
15:12:54 <vanila> I really doubt that
15:12:55 <dgpratt> since I understand Haskell expression syntax pretty well
15:13:08 <vanila> you need to learn physics for that,  not haskell
15:13:22 <ab9rf> physics?  does that involve the real worlds?
15:13:29 <EvanR-work> depends ;)
15:13:42 <dgpratt> vanila, to gain a certain level of understanding, yes :)
15:13:53 <monochrom> physics and pendulums? that's continuous analogue stuff, something not directly translatable into Haskell, or any digital computer.
15:14:02 <dgpratt> physics _is_ the math in some sense, isn't it? :)
15:14:07 --- mode: ChanServ set +o johnw
15:14:20 --- mode: ChanServ set +o johnw
15:14:22 <ReinH> johnw: have you sufficiently op'd yourself now?
15:14:30 <johnw> is my op hat on now?
15:14:32 <ab9rf> go chanserv go
15:14:42 --- mode: ChanServ set +o shapr
15:14:44 <dgpratt> monochrom, and yet somehow people create physics simulations in Haskell
15:14:44 <EvanR-work> ##physics
15:14:52 <johnw> sorry for the noise
15:14:52 <ReinH> johnw: about 5 of them
15:14:53 --- mode: johnw set -o johnw
15:14:57 --- mode: shapr set -o shapr
15:14:58 <ReinH> johnw: now 4 of them
15:15:01 <johnw> I was having difficulties banning that spammer
15:15:06 <ab9rf> dgpratt: which are incapable of actually modeling anything more complicated than two bodies swirling around in space.
15:15:11 <ReinH> johnw: It's fine, I'm just kidding.
15:15:17 <ReinH> I just thought it was funny.
15:15:18 <monochrom> when I issued the op-me command, there was significant lag. I think it's why johnw issued it multiple times and now get multiple effects.
15:15:33 <johnw> ah
15:15:36 <ab9rf> chanserv lag is always good for a lulz or two
15:15:37 <johnw> that makes perfect sense
15:15:41 <ReinH> luckily we have an ircop on board
15:15:54 <ReinH> or whatever idoru's freenode status is
15:16:25 <shachaf> idoru is a bot
15:17:56 <monochrom> dgpratt: do you want to learn how to do physics simulations? then look for "Euler's forward method", "Euler's backward method", "finite element method", and generally "numerical algorithms". all these are approximation methods, not exact translations (there can be none), and certainly not straightforward.
15:18:13 <dgpratt> monochrom, that would be an eventual goal, yes
15:18:18 <vanila> this is calculus of variations, not euler stuff
15:18:29 <ReinH> shachaf: oh.
15:18:34 <dgpratt> the near-term goal is simply to better understand certain mathematical notations
15:18:35 <vanila> well euler of course came up with the formulas..
15:18:37 <monochrom> you will find that a physics simulation algorithm for a digital computer looks nothing like the original physics formulas. far from it.
15:19:11 <ReinH> shachaf: oh right, a closed source bot managed with presumably some sense of irony by freenode.
15:19:41 <hodapp> wow, I stepped away for 5-10 minutes and missed... a bunch of spam?
15:19:56 <ab9rf> freenode is a great source of irony
15:20:21 <jdiez> @pl harm n = sum (take n (iterate (/2) 1))
15:20:21 <lambdabot> harm = sum . flip take (iterate (/ 2) 1)
15:20:33 <monochrom> this is a good time to find a despair.com poster that says the pitfalls of aiming high
15:20:35 <ab9rf> heh
15:20:59 <shachaf> It isn't unreasonable to keep spam detection heuristics secret (but that's a bit off-topic in here).
15:21:23 <hodapp> only poster I want right now is http://i0.wp.com/lolzombie.com/wp-content/uploads/2014/02/windchill.png
15:21:50 <monochrom> this: http://www.despair.com/ambition.html
15:23:30 <ReinH> shachaf: true enough
15:24:05 <ReinH> hodapp: that's awesome
15:25:30 <hodapp> ReinH: it's how it is outdoors right now o_O
15:25:35 <johnw> so true, windchill today is -17 here
15:25:41 <ab9rf> cozy warm
15:26:07 <monochrom> I'm in Toronto. -17 (Celcius) is just temperature. windchill is probably -30
15:26:08 <ab9rf> i'm wondering if the kids will be home again tomorrow
15:26:28 <ab9rf> probably not, NWS downgraded us from a wind chill warning to a wind chill advisory
15:26:32 <jdiez> @src flip
15:26:32 <lambdabot> flip f x y = f y x
15:26:36 <jdiez> duh
15:26:42 <monochrom> :)
15:27:12 <erisco> what am I doing wrong http://lpaste.net/118031
15:27:34 <erisco> my intent is to define the 'id' function with the name 'foo'
15:27:43 <ab9rf> erisco: "foo = id"
15:27:54 <erisco> you mean I don't need TH for that?
15:27:59 <monochrom> it's a good question why one lives in a place of bad weather. Brazil has no windchill, would you like to live in Brazil instead?
15:29:29 <ReinH> monochrom: false http://www.wunderground.com/cgi-bin/findweather/getForecast?query=47834&brand=iphone
15:29:34 <erisco> I start it up in ghci, and 'foo' is not defined
15:29:45 <Zemyla> I just looked at the set benchmarks, and seriously? Unions is only benchmarked with two members?
15:29:48 <EvanR-work> wind chill is weather marketing
15:29:58 <ab9rf> wind chill is a formula
15:30:19 <ab9rf> although i've no idea how they derived it
15:30:23 <EvanR-work> yeah percent diff from temperature is ad pricing on weather channel
15:30:37 <ab9rf> wind chill is FAR older than the weather channel
15:30:40 <monochrom> um, not that Brazil... :)
15:31:10 <ab9rf> i think it was developed in the 60s
15:31:32 <EvanR-work> weather channel invented wind, classic reporter getting blow away by hurricane
15:32:32 <ReinH> monochrom: you didn't specify :p
15:33:01 <ReinH> monochrom: Also today I learned that there is a city in Indiana named Brazil.
15:34:03 <ab9rf> and i'm wrong, it was developed in the 1940s, by a pair of antarctic explorers.
15:36:21 <erisco> "The thermometer says -60˚C, but I swear it feel more like -80˚C" -- the inventor of windchill
15:38:17 <sipa> -60 C sounds oretty freezy
15:38:20 <sipa> *pretty
15:41:39 <erisco> grrr why does it not worker
15:41:59 <erisco> does TH not work intuitively with ghci?
15:42:08 <hiptobecubic> does it work at all?
15:42:21 <erisco> I don't know
15:45:32 * hackagebot unagi-chan 0.3.0.1 - Fast concurrent queues with a Chan-like API, and more  http://hackage.haskell.org/package/unagi-chan-0.3.0.1 (BrandonSimmons)
15:46:40 <erisco> I don't get it... I turned on -ddump-splices and it seems to be splicing just fine... ?
15:46:48 <erisco> " foo " ======> [foo x = x]
15:46:50 <erisco> is that wrong?
15:55:32 * hackagebot hydrogen-syntax 0.12.0.1 - Hydrogen Syntax  http://hackage.haskell.org/package/hydrogen-syntax-0.12.0.1 (JulianFleischer)
15:55:33 <deconfigured> Does anyone know how to get pandoc to use latex code `$\foo$` inside a markdown code block?
15:59:30 <erisco> so compiling with GHC works, interactively with GHCi does not work
15:59:38 <erisco> but what is Haskell without ghci? I must have it
16:00:02 <tommd> ehc?
16:00:52 <tasker> Is it possible to have an Unbox (Unbox Double), from Data.Vector.Unboxed ? Or does the unboxed nature of it stop it working ?
16:00:54 <srruby> A non-haskell question about time complexity.  Which will is larger for large n: O(n squared) vs O(n(logn)(loglogn))   Thanks, John
16:01:56 <tromp_> n^2 of course
16:02:13 <monochrom> roughly, because n is larger than (log n)(log log n)
16:02:55 <monochrom> to prove: calculate lim_{n->oo} (n^2) / (n(logn)(loglogn))
16:03:40 <Axman6> tasker: it should be doable as a vector of Int offsets and a vector of Double. can't remember exactly what the Onbox class needs though
16:03:43 <monochrom> limits are a quick way to settle "which big-O is bigger"
16:04:03 <tasker> Axman6: Ah, good point.
16:04:48 <Axman6> Unbox even
16:05:16 <erisco> I will be back later
16:05:22 <J_Arcane> yaaaaay building cabal
16:05:49 <erisco> for reference this is still my program * theshadow (~theshadow@12.149.152.131) has joined
16:05:50 <giorgio> building ghc here ;-)
16:05:52 <erisco> uh
16:05:59 <erisco> this is still my program http://lpaste.net/118031
16:06:13 <J_Arcane> decided to try building the Haskell Koans in a Koding VM.
16:06:21 <erisco> though I discovered FunD vs funD so I am using the former now
16:06:31 <erisco> 'foo' still doesn't show up under ghci though
16:07:09 <erisco> message me with lambdabot kthxbai
16:11:18 <srruby> Thanks all.
16:12:06 <vanila> Koding VM?
16:15:33 * hackagebot hydrogen-syntax 0.12.0.2 - Hydrogen Syntax  http://hackage.haskell.org/package/hydrogen-syntax-0.12.0.2 (JulianFleischer)
16:15:45 <J_Arcane> yaaaay cabal failed to build.
16:16:03 <J_Arcane> Koding VM's don't have enough ram apparently.
16:24:03 <srruby> Last question:  How does O(n) compare with  (log n)(log log n)  ?  Thanks for your kind help.
16:25:58 <mseeks> http://www.wolframalpha.com/input/?i=plot+%28y+%3D+x%2C+y+%3D+%28log+x%29*%28log%28log%28x%29%29%29%29%2C+x%2C+0%2C+1e10%29
16:26:36 <vanila> srruby, one way to see it is that well,  (log n)^k is smaller than n for any k right?
16:35:34 * hackagebot hydrogen-prelude 0.14 - Hydrogen Prelude  http://hackage.haskell.org/package/hydrogen-prelude-0.14 (JulianFleischer)
16:35:36 * hackagebot plugins-multistage 0.5.1 - Dynamic linking for embedded DSLs with staged compilation  http://hackage.haskell.org/package/plugins-multistage-0.5.1 (AndersPersson)
16:35:38 * hackagebot hydrogen-parsing 0.14 - Hydrogen Parsing Utilities  http://hackage.haskell.org/package/hydrogen-parsing-0.14 (JulianFleischer)
16:39:52 <erisco> boo
16:40:34 * hackagebot hydrogen-cli-args 0.14 - Hydrogen Command Line Arguments Parser  http://hackage.haskell.org/package/hydrogen-cli-args-0.14 (JulianFleischer)
16:40:36 * hackagebot hydrogen-data 0.14 - Hydrogen Data  http://hackage.haskell.org/package/hydrogen-data-0.14 (JulianFleischer)
16:50:34 * hackagebot hydrogen-syntax 0.14 - Hydrogen Syntax  http://hackage.haskell.org/package/hydrogen-syntax-0.14 (JulianFleischer)
16:52:43 <zq>     hydrogen-peroxied 0.14 - Hydrogen Peroxide http://hackage.haskell.org/package/hydrogen-peroxide-0.14
16:55:35 * hackagebot hydrogen-cli 0.14 - Hydrogen Data  http://hackage.haskell.org/package/hydrogen-cli-0.14 (JulianFleischer)
17:17:46 <hrumph> hi
17:18:11 <cite-reader> greetings
17:20:20 <Pamelloes> Is there a startswith function for a list?
17:20:34 <shachaf> isPrefixOf
17:20:35 * hackagebot relational-postgresql8 0.1.0.0 - PostgreSQL v8.x driver for haskell-relational-record  http://hackage.haskell.org/package/relational-postgresql8-0.1.0.0 (yuga)
17:40:27 <Pamelloes> Is there a way to ensure that a list with an arbitrary length, maybe infinity, has a length of at least n?
17:40:50 <shachaf> Ensure?
17:40:50 <HeladoDeBrownie> Pamelloes, sure, length . take n
17:41:02 <vanila> Pamelloes, there's not really a good way except using a different type (a, (a, (a, [a])))
17:41:10 <vanila> if you meant ensuring that it h as at least 3 elements in the type system
17:41:44 <Pamelloes> HeladoDeBrownie: Thanks :)
17:41:45 * HeladoDeBrownie didn't read the question as being about a static guarantee
17:41:51 <charlie> xoh
17:42:30 <HeladoDeBrownie> Pamelloes, i left out only one step from that by the way, (== n) . length . take n
17:42:44 <HeladoDeBrownie> :t (== n) . length . take n
17:42:44 <lambdabot>     Couldn't match type ‘Int’ with ‘Expr’
17:42:45 <lambdabot>     Expected type: [a] -> Expr
17:42:45 <lambdabot>       Actual type: [a] -> Int
17:42:53 <HeladoDeBrownie> :t (== ?n) . length . take ?n
17:42:54 <lambdabot> (?n::Int) => [a] -> Bool
17:43:12 <Pamelloes> vanila: Is there a reason why HeladoDeBrownie's method won't work?
17:43:30 <HeladoDeBrownie> Pamelloes, vanila thought you wanted to enforce it with types
17:43:31 <vanila> what HeladoDeBrownie is good
17:43:40 <vanila> it works at runtime rather than compile time
17:43:54 <vanila> I think I misinterpreted your question! sorry
17:44:03 <Pamelloes> Ah, ok :) Yeah, it needs to work at runtime since the list being compared isn't available at compile time ;)
17:44:11 <vanila> haha sorry about that!
17:47:29 <Hijiri> well not necessarily
17:47:45 <Hijiri> you could have a function that gives you an Either List ListOfAtLeastNLength
17:52:05 <zq> what is this ?n
17:52:19 <zq> :t \y -> ?y
17:52:20 <lambdabot> (?y::t1) => t -> t1
17:52:28 <zq> wow
17:52:53 <Pamelloes> It appears to be a Typeclass! :D
17:53:07 <zq> unification constraint
17:53:09 <HeladoDeBrownie> zq, you can use it for when you don't have the variable actually on hand but want to have something there
17:53:22 <zq> HeladoDeBrownie: yeah but i wanna know if this is a new ghc(i) feature or a lambdabot doohickey
17:53:25 <exio4> zq, implicit parameter
17:53:27 <HeladoDeBrownie> Pamelloes, actually it's not, there are Constraints that don't come from a typeclass
17:53:34 <zq> i'm very very hopeful that it's the former
17:53:43 <Pamelloes> Well then. I spoke too soon :/
17:54:09 <HeladoDeBrownie> Pamelloes, it's okay, most of the constraints you run into at first are typeclass constraints, so it wasn't a bad guess
17:55:17 <Pamelloes> So what's a constraint that isn't a type class?
17:55:27 <HeladoDeBrownie> haskell.org is being so slow lately, i'm trying to look this thing up on it
17:55:31 <Hijiri> equivalence constraints like a ~ b
17:55:42 <HeladoDeBrownie> zq, https://www.haskell.org/haskellwiki/Implicit_parameters
17:55:43 <zq> unification is the proper term
17:55:46 <Hijiri> > 5 :: (Int ~ String) => Int
17:55:48 <lambdabot>  Couldn't match type ‘GHC.Types.Int’ with ‘[GHC.Types.Char]’
17:55:48 <lambdabot>  Inaccessible code in
17:55:48 <lambdabot>    an expression type signature:
17:56:06 <zq> damn it
17:56:12 <zq> i can't do it in ghci 7.8.4
17:56:39 <HeladoDeBrownie> zq, that'd be surprising. did you enable the correct extension?
17:56:56 <zq> HeladoDeBrownie: hagn on, i'm *still* waiting for your url to load
17:57:00 <Pamelloes> Hijiri: Could you elaborate further, I'm not quite sure what that means?
17:57:12 <HeladoDeBrownie> yeaaah, it was slow for me too :P
17:57:58 <Hijiri> a ~ b means a and b have to unify (I think)
17:58:07 <HeladoDeBrownie> sounds right to me
17:58:20 <HeladoDeBrownie> but the real challenge is explaining what "unify" means :)
17:58:24 <shachaf> It means they are equal.
17:58:38 <Pamelloes> So something like Int ~ Integer?
17:58:44 <shachaf> No, Int isn't equal to Integer.
17:58:57 <shachaf> You can't write id :: a -> b; id x = x, because b isn't (necessarily) equal to a, so it's a type error.
17:58:58 <HeladoDeBrownie> that's a legal constraint to write, but it is not satisfiable
17:59:01 <Hijiri> it's a valid constraint though
17:59:08 <shachaf> But you can write id :: (a ~ b) => a -> b; id x = x
17:59:11 <zq> HeladoDeBrownie: thanks for the url
17:59:17 <shachaf> Because now you know that a is equal to b.
17:59:52 <Pamelloes> That function would work Int to Integer since every Int is an Integer
18:00:01 <Pamelloes> * can be represented by
18:00:04 <HeladoDeBrownie> Pamelloes, Int and Integer are distinct types
18:00:16 <HeladoDeBrownie> you might be thinking of how both Int and Integer have instances of Integral
18:00:20 <HeladoDeBrownie> Integral being a typeclass
18:00:23 <shachaf> Pamelloes: Int has almost nothing to do with Integer as far as the type system is concerned.
18:00:24 <zq> Pamelloes: 2**128 :: Int != 2**128 :: Integer
18:00:40 <shachaf> You can write a function :: Int -> Integer, and it's injective. But they aren't equal types.
18:00:48 <Pamelloes> Ok.
18:01:02 <Pamelloes> So what are two types that are equal?
18:01:07 <HeladoDeBrownie> String and String :)
18:01:11 <zq> unified types
18:01:11 <HeladoDeBrownie> String ~ String
18:01:15 <shachaf> If f :: Integer -> ..., f (x :: Int) is a type error.
18:01:24 <shachaf> A type is only equal to itself.
18:02:19 <Pamelloes> So then what's the point of ~? When would you need that if the the only two unifiable types are a type and itself?
18:03:16 <shachaf> You can put a proof that two types are equal in one place and use it in another place.
18:03:53 <HeladoDeBrownie> in general you're going to use it where at least one argument includes type variables
18:03:56 <shachaf> Do you know about GADTs?
18:04:14 <Pamelloes> Probably not, what does GADT stand for?
18:04:33 <dfeuer> generalized algebraic data type.
18:04:52 <Pamelloes> Aren't those the things in abstract algebra?
18:05:07 <shachaf> They are things in Haskell.
18:05:31 <Pamelloes> Oh. Well, then I have no idea what they are :/
18:06:04 <vanila> GADT isn't from algebra
18:06:06 <HeladoDeBrownie> Pamelloes, for reference, usual haskell types defined as with data declarations are called ADTs
18:06:18 <shachaf> OK. Well, a lot of what makes GADTs interesting is type equality.
18:06:31 <Pamelloes> HeladoDeBrownie: Thanks :)
18:06:37 <hodapp> Do not, as well, that ADT here != abstract data type like in some silly C++ textbooks
18:06:57 <dfeuer> Wuuuut.
18:07:06 <Pamelloes> s/not/note
18:07:07 <shachaf> Don't confuse ADT ("Algebraic Data Type") with ADT ("Abstract Data Type"), which means roughly the opposite.
18:07:55 <shachaf> The rest of what makes GADTs interesting is existential quantification and the equivalent of existential quantification for constraints (does it have a name, other than "*>"?).
18:07:59 <shachaf> And some pedagogical value.
18:08:05 <hodapp> Pamelloes: Thank you.
18:08:26 <Pamelloes> np
18:08:56 <Pamelloes> shachaf: Is there any good example code I can look at?
18:09:08 <shachaf> I don't know. :-(
18:09:22 <Pamelloes> Fair enough.
18:09:45 <shachaf> You could try https://www.haskell.org/haskellwiki/Generalised_algebraic_datatype
18:09:55 <shachaf> There are a bunch of links there.
18:10:01 <Pamelloes> I clicked on that a link a few minutes ago. Still waiting for it to load :P
18:10:41 <lpaste> Lokathor pasted “minimal SDL program” at http://lpaste.net/118034
18:11:09 <zq> this extension kicks ass
18:12:07 <boser> hello, do you perfer english or german?
18:12:41 <shachaf> English in this channel.
18:13:00 <shachaf> There's #haskell.de but I think it's pretty small.
18:14:36 <boser> thx, let me see, if i get my solution there.
18:16:15 <boser> or let my ask here also, I try to activat hs-xmonad in freebsd 10.1. how can i do this? alle compunents are installed.
18:16:37 <shachaf> #xmonad might know more about xmonad.
18:16:58 <boser> thx, let try. cu
18:26:08 <marchelzo_> How could I use a lens to target a certain element of a list by its index?
18:26:26 <shachaf> There's no lens, but there's a traversal.
18:26:32 <shachaf> ix i
18:27:00 <marchelzo_> shachaf, how might I use that?
18:27:04 <shachaf> For what?
18:27:30 <shachaf> Also the usual caveats on operating on linked lists by index ("you probably shouldn't do it") apply.
18:27:41 <marchelzo_> Say there was a lens, called index. I want to do: "_2 . index k %= ...".
18:27:48 <shachaf> It's called ix
18:27:54 <marchelzo_> So it just works
18:27:55 <shachaf> It's not a lens.
18:28:19 <shachaf> A lens always has to find something, but your list might not be long enough for your index.
18:28:28 <marchelzo_> ah
18:28:32 <marchelzo_> Fair enough
18:28:44 <shachaf> > let l = [5..10] in (preview (ix 2) l, preview (ix 20) l)
18:28:45 <lambdabot>  (Just 7,Nothing)
18:29:02 <shachaf> preview is the equivalent of view for things that might fail.
18:30:05 <marchelzo_> hmm
18:30:39 * hackagebot sws 0.3.1.0 - A simple web server for serving directories, similar to weborf.  http://hackage.haskell.org/package/sws-0.3.1.0 (DerekElkins)
18:30:56 <shachaf> If you prefer (^.), the equivalent is (^?).
18:33:29 <marchelzo_> > ix 2 .~ 'l' $ "Heelo"
18:33:31 <lambdabot>  "Hello"
18:33:57 <marchelzo_> shachaf, thank you.
18:35:21 <marchelzo_> shachaf, is there an ideal way to use ix, but instead target every element except the one with specified index?
18:36:17 <calvinx> given a list containing an unknown number of ‘True’ and/or ‘False’, how can I return ‘True’ if any element is True?
18:36:18 <shachaf> > over (traversed . Lens.indices (/= 2)) toUpper "hello" -- perhaps this
18:36:19 <lambdabot>  "HElLO"
18:36:22 <Pamelloes> What would be the best way of turning (a, IO b) into IO (a,b)
18:36:22 <vanila> :t ix
18:36:23 <lambdabot> (Ixed m, Applicative f) => Index m -> (IxValue m -> f (IxValue m)) -> m -> f m
18:36:30 <vanila> :t (.~)
18:36:31 <lambdabot> ASetter s t a b -> b -> s -> t
18:36:52 <shachaf> calvinx: Searching Hoogle for [Bool] -> Bool will give you the answer. :-)
18:36:55 <shachaf> @where hoogle
18:36:55 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
18:38:52 <calvinx> cool. “or” in Prelude does that. thanks.
18:41:39 <dmj`> :t (-1)
18:41:40 <lambdabot> Num a => a
18:41:46 <dmj`> :t (1-)
18:41:48 <lambdabot> Num a => a -> a
18:44:29 <godel> dmj`: you can do that in ghci
18:44:55 <marchelzo_> shachaf, oh, thanks :) I didn't notice your answer until just now.
18:46:30 <Pamelloes> How does lazy evaluation work within a do statement?
18:46:53 <shachaf> Same way it works anywhere else.
18:47:10 <shachaf> (Alternatively: Lazy evaluation isn't a property of statements.)
18:48:10 <Pamelloes> So if I say do;let a=1;let b=undefined;return $ if True then a else b; it will evaluate to 1?
18:48:29 <Pamelloes> Well, I guess that obviously works.
18:48:38 <vanila> it might depend on the monad
18:48:40 <shachaf> No, it's a syntax error.
18:48:57 <vanila> although the lets aren't monadic
18:49:16 <roconnor> > flip runState 7 $ do { x <- get; undefined; put x }
18:49:17 <lambdabot>  ((),7)
18:49:33 <shachaf> But if you write "do { let { a = 1 }; let { b = undefined }; return $ if True then a else b }", it'll mean the same thing as "let { a = 1 } in let { b = undefined } in return $ if True then a else b"
18:49:34 <vanila> in the example you gave, you can reduce the if right away
18:49:44 <vanila> = do;let a=1;let b=undefined;return $ a
18:49:53 <vanila> and since they are just lets you can substitute the in too
18:49:58 <vanila> = return $ 1
18:50:14 <Pamelloes> hm... I'm in the IO monad and I have two statements that I set via <-. And then I return one of them via an if statement.
18:50:30 <Pamelloes> Only the used one will be calculated, correct?
18:50:33 <vanila> so IO is a bit different than the example roconnor showed
18:50:40 <vanila> it will actually evaluate/run every action
18:50:52 <shachaf> That doesn't have much to do with do.
18:51:01 <shachaf> You need to distinguish between evaluation and execution.
18:51:11 <vanila> do print "foo" ; undefined ; print "bar"
18:51:13 <shachaf> If you write do { x <- a; y <- b; ... }, a and b will always be executed.
18:51:14 <vanila> will not be able to print bar
18:51:25 <shachaf> x and y might not be evaluated.
18:51:41 <shachaf> (But there are no observable effects from evaluating them.)
18:51:59 <roconnor> do { x <- a; y <- b; ... }, a and b will always be executed for the IO monad.
18:52:34 <Pamelloes> So if I want a and b to only be loaded in their respective branches, I have to put them inside the if statement, not before?
18:53:40 * roconnor wonders if he pulled a "well, actually"
18:53:47 <shachaf> If I understand your question the answer is "yes".
18:53:56 <shachaf> roconnor: Oh, were you correcting me?
18:54:09 <shachaf> roconnor: I stand by my statement for appropriate meanings of "execution". :-)
18:54:12 <Cale> Of course, if a takes forever to execute, then b may not be executed
18:54:13 <Pamelloes> Alright.  Thanks :)
18:54:19 <Cale> Or if a throws an exception :P
18:54:26 <shachaf> (Executing an action in e.g. Maybe or [] might mean 0 times, but it still executes it.)
18:54:51 <shachaf> Cale: Yes. But those aren't observable effects from inside the program. :-)
18:55:15 <Cale> If by "the program" you mean that do block itself, then sure
18:55:28 <Cale> Exceptions can be caught in IO
18:55:40 <shachaf> IO can also read memory to see if a thunk is forced.
18:56:01 <Cale> (Probably not portably though)
18:56:17 <shachaf> True, maybe in Report Haskell exceptions are more special.
18:56:26 <shachaf> But I think exceptions are a bit beside the main point, which is already a bit subtle.
18:58:35 <johnw> "Report Haskell", I like that
18:59:43 <Cale> yeah
19:01:36 <Zemyla> @src NFData
19:01:36 <lambdabot> Source not found. Just what do you think you're doing Dave?
19:01:46 <Zemyla> @hoogle NFData
19:01:47 <lambdabot> Control.Parallel.Strategies class NFData a
19:01:48 <lambdabot> Control.DeepSeq class NFData a
19:09:04 <Zemyla> So I think I made a fast (if complicated) prime number sieve, which uses wheels to skip over more and more guaranteed composite numbers.
19:09:12 <erisco> :t optional
19:09:13 <lambdabot> Alternative f => f a -> f (Maybe a)
19:11:37 <Pamelloes> Can I use do in a lamda?
19:11:44 <vanila> yes
19:12:02 <vanila> Zemyla, I have something lik that - we could benchmark to see which runs faster if you want
19:14:01 <wolf_mozart> I'm wanting to know something, let's say I wrote a function in haskell(I don't know haskell btw) and it looked like this function(x,y); and it returned the sum of those, is it possible to reverse that function someone, by setting the sum  and x to some constant and making it return x instead? by simple measure, or would I need to rewrite a new function. (kinda like inversing a function)
19:14:11 <wolf_mozart> to solve for math
19:14:19 <wolf_mozart> MYeah
19:14:30 <vanila> wolf_mozart, you can't really do that in haskell, it's often possible in prolog languages though
19:14:37 <wolf_mozart> to solve for X
19:14:45 <wolf_mozart> i see
19:15:12 <jrc12> Is (=<<) a functor from the Kleisel category to the category of functions?
19:15:13 <vanila> there is Curry, which is like a logic language (that lets you run things backwards like that) based on haskell
19:15:20 <Zemyla> vanila: It is possible, but only if the values and function are written in the type system, Oleg-style.
19:15:37 <vanila> i don't think so Zemyla
19:16:19 <adu> does GHC use LLVM?
19:16:23 <Zemyla> class Sum a b ab | a b -> ab, a ab -> b
19:16:45 <Zemyla> Of course, this is very rarely useful, and never at runtime. :P
19:17:43 <wolf_mozart> like inverse_get(function(x,y),get(x,for_return(20),for_argument(x=2)))
19:17:49 <wolf_mozart> das crazy
19:18:41 <jrc12> (=<<) (s >=> s') = (=<<) s . (=<<) s'
19:18:47 <jrc12> Right?
19:18:47 <dmj`> adu: ghc can compile source code to llvm
19:19:16 <thoughtpolice> adu: optionally, yes. by default, no, it has its own code generator.
19:19:28 <wolf_mozart> I mean it could be useful if for example I had a very complicated function and I wanted to solve for Y instead of X. without having to rewrite
19:21:18 <adu> dmj`: thoughtpolice: I just installed the latest version with MacPorts, and I was surprised to see LLVM as a dependancy
19:21:52 <adu> it might just be the MacPorts version since LLVM/Clang is now the default compiler on Mac
19:23:17 <Pamelloes> Can I do (\IO a -> a+1)?
19:23:41 <vanila> oh you can run things backwards, but only deterministic things
19:24:08 <geekosaur> Pamelloes, no
19:24:13 <vanila> Pamelloes, not like that but you can do (\m -> do a <- m ; return (a + 1))
19:24:30 <Pamelloes> Oh! I see :)
19:24:36 <vanila> this has type IO Int -> IO Int
19:24:42 <thoughtpolice> adu: some other distros tend to make LLVM a dependency too AFAIK, so that GHC's LLVM support will work 'out of the box' for users.
19:25:23 <adu> thoughtpolice: that makes sense
19:25:41 * hackagebot relational-query 0.3.0.4 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.3.0.4 (KeiHibino)
19:29:21 <exio4> Pamelloes, that'd be basically fmap
19:29:32 <exio4> @type fmap (\a -> a + 1) :: IO Int -> IO Int
19:29:32 <lambdabot> IO Int -> IO Int
19:30:29 <Pamelloes> Interesting, I never thought about it that way.
19:30:49 <erisco> is there a way to implicitly initialize data using mempty if defined?
19:31:40 <erisco> for example,  data X = X { a :: [Int], b :: [String] };  foo = X { a = [1,2] }
19:39:36 <johnw> you create a function called newX
19:39:47 <johnw> then you say: foo = newX { a = [1,2] }
19:39:54 <johnw> where newX initializes everything to default values
19:44:09 <AshyIsMe> diagrams does that according to the docs, it might be worth looking into how they do it
19:46:54 <dfeuer> Does Oleg still maintain HList?
19:49:57 <Axman6> johnw: that's generally what the Default class is for
19:50:17 <Axman6> @hoogle Default
19:50:17 <lambdabot> System.Posix.DynamicLinker.Prim Default :: DL
19:50:18 <lambdabot> System.Posix.Signals Default :: Handler
19:50:18 <lambdabot> Codec.Compression.Zlib.Internal DefaultCompression :: CompressionLevel
19:50:20 <shachaf> newX isn't a function.
19:50:29 <johnw> I said to create a function named newX
19:50:47 <johnw> oh, I see what you mean
19:50:49 <johnw> right
19:50:49 <Maxdamantus> it can't be a function given your usage.
19:50:58 <johnw> create a value named newX
19:51:05 <johnw> or defaultX, or what have you
19:52:00 <shachaf> Calling things that aren't functions functions is a tradition. Even the Report does it.
19:52:13 <Axman6> class Default a where def :: a, can't remember which package defined that
19:52:35 <johnw> I appreciate the correction
19:52:45 <HeladoDeBrownie> spj does it too, and has referred to monads as a means of encapsulating side effects
19:53:17 <HeladoDeBrownie> (which even if technically wrong does tell of some of the motivation, i suppose)
19:53:24 <Axman6> well, that can be used for such, so it's not completely inaccurate
19:53:29 <Axman6> just not universal
19:54:45 <dfeuer> In SPJ's world, polymorphic values are functions that take types, or something.
19:54:49 <Zemyla> @hoogle Default
19:54:50 <lambdabot> System.Posix.DynamicLinker.Prim Default :: DL
19:54:50 <lambdabot> System.Posix.Signals Default :: Handler
19:54:50 <lambdabot> Codec.Compression.Zlib.Internal DefaultCompression :: CompressionLevel
19:55:03 <HeladoDeBrownie> dfeuer, the fun part is that in some languages that's how they'd be realized
19:55:20 <dfeuer> HeladoDeBrownie, that's how they're realized in GHC.
19:55:46 <HeladoDeBrownie> sure, but i'm referring to language semantics rather than implementation
20:05:43 * hackagebot relational-schemas 0.1.0.1 - RDBMSs' schema templates for relational-query  http://hackage.haskell.org/package/relational-schemas-0.1.0.1 (KeiHibino)
20:09:10 <homovitruvius> what is that can make ghci as an Emacs subprocess not finding certain modules when ghci and ghc from the command line have no problems?
20:10:01 <ab9rf> homovitruvius: wrong current working directory?  PATH wrong?  missing environment variables?
20:23:16 <octopuscabbage> why does my cabal not have sandbox
20:24:36 <octopuscabbage> i type cabal sandbox and it says that's not a recognized command
20:24:50 <carter> octopuscabbage: cabal --version
20:24:54 <carter> check you rpath
20:25:31 <octopuscabbage> cabal-install version 1.16.0.2 using version 1.16.0 of the Cabal library
20:25:32 <octopuscabbage> how do i check rpath
20:26:16 <Axman6> that's too old iirc
20:26:27 <Axman6> sand boxes came in 1.18 or 1.20 or something
20:26:49 <octopuscabbage> how do i upgrade? is there an apt repo that has it
20:27:07 <octopuscabbage> because, unless my upgrades are messed up, this is the newest version in the apt repos
20:32:00 <carter> octopuscabbage: cabal install cabal-install
20:32:03 <carter> after you cabal up date
20:32:11 <carter> and then make sure ~/.cabal/bin is in your path
20:37:08 <EvanR> in the truth table at the bottom of this modus ponens page http://en.wikipedia.org/wiki/Modus_ponens arent they missing a few cases?
20:37:26 <EvanR> 3 bools is a table of 8 rows, not 4
20:40:32 <glguy> Two input one output?
20:43:07 <EvanR> ok so its sampling some definition of the operation p -> q for all possible pairs of inputs. but then how are the bottom two cases for p -> q true?
20:43:36 <barrucadu> F -> anything is true
20:43:54 <EvanR> .. whats -> again?
20:43:58 <barrucadu> Implies
20:44:13 <barrucadu> p -> q == ¬p || q
20:44:32 <vanila> True implies True
20:44:36 <vanila> False implies anything
20:44:44 <Zemyla> vanila: I think I have my primes implementation optimized up, if you'd like to see it.
20:44:47 <EvanR> ok lots of axioms flying around. F implies anything. ok
20:44:50 <vanila> Zemyla, yeah!
20:46:06 <EvanR> so how do you explain p=T q=F p->q (computes to) F
20:46:21 <vanila> true does not imply false
20:46:32 <vanila> only false implies false
20:46:52 <EvanR> alright
20:47:28 <vanila> you can think of logical implication as the < comparison operation
20:47:30 <barrucadu> "p -> q" can be read as "if p is true, then q must be true". The only assignment of truth values we can come up with which falsifies that statement is p=T, q=F.
20:47:35 <vanila> sorry <=
20:47:42 <vanila> False <= False, False <= True, True <= True
20:48:12 <EvanR> > True <= False
20:48:14 <lambdabot>  False
20:48:22 <lpaste> Zemyla pasted “Prime Number Generator with a Growing Wheel” at http://lpaste.net/118042
20:49:28 <EvanR> well dont that beed all
20:49:38 <EvanR> er, beat all
20:50:22 <Zemyla> Why would False be greater than True?
20:50:48 <vanila> a <= b is the same as a -> b
20:51:03 <Zemyla> Ohhh, okay.
20:51:10 <barrucadu> zenBecause that's how the author of the Ord instance for Bool decided to do it :p
20:51:15 <barrucadu> * Zemyla:
20:51:40 <EvanR> traditional false is zero and true is one
20:51:40 <Zemyla> Anyway, vanila, that's my implementation.
20:51:41 <vanila> Zemyla, How do I get the L module?
20:52:23 <Zemyla> vanila: import qualified Data.List as L
20:53:25 <lpaste> Zemyla revised “Prime Number Generator with a Growing Wheel”: “No title” at http://lpaste.net/118042
20:53:38 <vanila> ok looks like our codes agree! that's good
20:54:24 <EvanR> T -> F, is false, is this the principle of non-contradiction
20:55:24 <EvanR> and F -> anything is reductio ad absurdum
20:56:17 <Zemyla> But yeah, vanila, do you see how it works?
20:56:26 <vanila> Zemyla, haha oh my god, well your takes < 1s and mine is ... still not finished :)
20:56:37 <EvanR> does all this still matter in intuitionistic logic
20:56:48 <vanila> seems like your code is very efficient
20:57:02 <vanila> I didn't try to understand how it works
20:57:36 <vanila> 6s vs 0.2s
20:58:37 <Zemyla> vanila: Okay, first off, splitAt takes the first two primes, 2 and 3. fmul = 2 * 3 = 6, and sfac is the initial wheel mod 6, [1, 5].
20:59:15 <vanila> oh! So you just make sure that it's in that set when reduced mod 6
21:00:05 <Zemyla> Yep. gen starts with plist being 5:..., and bm being 6.
21:00:28 <EvanR> another way to get TTT is by saying if p is true, then q -> p is true for any q
21:00:43 <EvanR> dunno what that is though
21:01:22 <Zemyla> It generates [7, 11] from [1, 5], and then [13, 17], [19, 23], and then skips 25 and produces 29. At this point, bm would become 30.
21:01:41 <vanila> I see
21:01:47 <vanila> pretty cool algorithm!
21:03:18 <Zemyla> It then clones the wheel 6 times, and strips out all the multiples of 5, to make [1,7,11,13,17,19,23,29]. fmul is now 30.
21:03:29 <Zemyla> And plist is 7:...
21:04:21 <Zemyla> It does the same thing until 210, then until 2310, and so on.
21:04:54 <Zemyla> Though each time, it prunes a smaller number of composite numbers.
21:06:00 <Zemyla> What was your algorithm?
21:06:42 <vanila> i did sieve of eratothesines
21:06:57 <vanila> so i just filter out each multiple of each prime that gets emitted
21:07:12 <vanila> its similar tying the knot - and I thought it wouldn't be so horribly inefficient so im a bit surprised :)
21:07:34 <vanila> i could optimize out a ++ from the code, might try to see how that compares
21:08:52 <bollu> could someone explain the type inference algorithm to me? I'm trying to understand it but.. I don't get it
21:09:10 <vanila> bollu, sure
21:09:16 <vanila> Do you know unification?
21:09:47 <bollu> vanila: that's where I'm stuck :) I'm trying to implement type unification for a toy language of mine, but I don't understand it
21:09:51 <vanila> alright!
21:09:59 <vanila> so unification is the most important piece of this puzzle
21:10:06 <vanila> once you get that the rest isn't too difficult
21:10:16 <bollu> vanila: okay. go on :)
21:10:59 <vanila> so you have variables a,b,c,s,t,u and terms/constructors like Bool, Int, _ -> _
21:11:27 <bollu> vanila: right..
21:11:38 <vanila> unifying a variable with a term will set it to that, so a = Bool will result in a being Bool everywhere
21:11:56 <bollu> vanila: okay.
21:12:07 <vanila> unifying x -> y = s -> t will unify both x = s, y = t
21:12:20 <bollu> vanila: how do you know when to unify what?
21:12:24 <vanila> and unifying variables together makes them equal everywhere
21:12:43 <bollu> vanila: okay.
21:13:07 <vanila> so an example would be  Bool -> s = s -> t  will result in s=Bool, t=Bool and the result term is  Bool -> Bool
21:13:11 <EvanR> Int -> y unify s -> Bool will result in y=Bool and s = Int
21:13:22 <bollu> ah
21:13:24 <vanila> yeah, that's a good example too
21:13:38 <vanila> so if that's clear we can look at where this comes up in type inference
21:13:58 <bollu> vanila: what about things like type heirarchies?
21:14:05 <vanila> what's that?
21:14:11 <EvanR> subtyping?
21:14:18 <bollu> vanila: like, Number => Float => Integer
21:14:21 <bollu> EvanR: yes
21:14:26 <bollu> that was the word I was looking for
21:15:05 <EvanR> instead of ranting about the utility of subtyping, ill rant about how Number Float and Integer dont act very much alike
21:15:19 <EvanR> i have a list here of 10 different number types, all with different behaviors
21:15:40 <EvanR> doesnt seem like a subtype situation to me
21:15:46 <bollu> EvanR: but, well, in general - if I *do* want subtyping
21:15:54 <bollu> EvanR: That was just a random example
21:17:13 <EvanR> i dont know how to incorporate some kind of subtyping into the system, but i think it makes it much more complex
21:17:54 <EvanR> and i havent wanted it in haskell
21:18:07 <vanila> yeah subtyping is a bit more of an advanced topic
21:18:16 <vanila> it'd be good to get the simple types down first, I think
21:18:39 <vanila> bollu, oh I forgot to say something about unification
21:19:13 <vanila> a very important thing is that unification can fail:  e.g.   Bool = Int  will fail to unify, and so will s -> s = Int -> Bool
21:19:32 <vanila> another type of failure called 'occurs check' is for situations like s = s -> s
21:19:46 <vanila> type errors are when unification fails
21:21:05 <EvanR> if you are unifying a variable and a non variable b, if a occurs somewhere in b, its an occurs failure?
21:21:33 <bollu> vanila: ah
21:21:43 <bollu> vanila: okay, so a unification failure is a type error?
21:21:47 <vanila> yeah
21:21:58 <bollu> vanila: that's how the type system works? interesting
21:22:04 <vanila> yep! it's pretty cool
21:22:09 <bollu> vanila: and the whole unify different number types thing?
21:22:30 <EvanR> and Int is incompatible with a Float
21:22:35 <EvanR> for good reason
21:22:59 <bollu> EvanR: okay, I want to have int64, int32 and int8 in the languga
21:23:01 <vanila> So would you like me to explain how to do inference for simple types? (using this unification)
21:23:07 <bollu> I'd like int8's to be promoted
21:23:13 <EvanR> yeah, int8 isnt a subtype of int16
21:23:14 <bollu> to a larger type if possible
21:23:22 <EvanR> it might be a subset
21:23:23 <bollu> EvanR: hm, okay. that's right.
21:23:46 <EvanR> you might want some auto conversion mechanism
21:23:49 <bollu> vanila: that's it isn't it? you just keep on recursively unifying until either a) you hit a type error, or b) you're done
21:24:03 <vanila> yeah it's that simple actually :) I guess i dont have to go into detail
21:24:21 <bollu> EvanR: is there a standard technique fort this? I assumed that the unification thing would have some hole where I could plug this in
21:24:36 <EvanR> bollu: its not necessary but seems unusual not to add polymorphic types
21:24:55 <vanila> okay well moving on to implicit coercion insertion
21:25:00 <bollu> vanila: right!
21:25:44 <vanila> you would get a type error in a context with x : int32, y : int64 trying to check  x + y
21:26:07 <bollu> vanila: in the default case with the algorithm you just described, yes
21:26:11 <vanila> so you could add a type rule that if x : int32 then x : int64
21:26:54 <bollu> vanila: ah. but that would create 2 cases for each pair of types wouldn't it? so that's nP2 if I have "n" integer types
21:26:59 <vanila> to make x + y work, you'd have to insert a coercion (use of that new rule) when checking x
21:27:24 <vanila> yeah - you never know whether to promote or not
21:27:27 <Zemyla> > (2::Integer) + 2.5
21:27:28 <lambdabot>  No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
21:27:28 <lambdabot>    arising from the literal ‘2.5’
21:27:42 <bollu> vanila: hm
21:27:44 <Zemyla> > 2 + 2.5
21:27:46 <lambdabot>  4.5
21:27:49 <bollu> vanila: is there a neat way to describe the rule?
21:27:49 <vanila> so maybe you could try inferring a whole list of types, x : [int32, int64, int128] and y : [int64, int128]
21:27:59 <EvanR> machine integer promotion is one thing, but for the user to control the process, something like type classes could help
21:28:01 <bollu> vanila: oh, that's slick
21:28:08 <vanila> but there are problems with this
21:28:12 <bollu> vanila: which are?
21:28:34 <vanila> that works in a positive context, but in a negative context you would need only the things it can be rasied from
21:28:46 <vanila> left of an arrow is negative, right is positive:  - -> +
21:29:04 <bollu> vanila: I don't follow. can I have a concrete example?
21:30:10 <bollu> vanila: what exactly do you mean by "in a negative context" ?
21:30:46 * hackagebot fit 0.5 - FIT file decoder  http://hackage.haskell.org/package/fit-0.5 (mgiles)
21:30:59 <jrc12> Is there a library for lazy maps?
21:31:01 <jrc12> It should support, inserting, looking up elements as well creating a map from a function (mapping chars to ascii value)
21:31:28 <jrc12> Or for example some sort of map on an infinite domain
21:31:50 <bollu> vanila: ?
21:32:05 <EvanR> Data.Map is lazy
21:32:16 <EvanR> in the values at least
21:32:34 <EvanR> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/containers/Data-Map-Lazy.html
21:32:39 <Zemyla> jrc12: Do you want a map with lazy values or a map with lazy insertion?
21:32:43 <vanila> if you have: f : int32 -> s,  x : int32   then f x : s is fine, but if x : int64 you can't raise the int32 in the type of f
21:32:48 <jrc12> Zemyla: Yep
21:33:02 <Zemyla> Yep which one?
21:33:06 <bollu> vanila: ahh
21:33:10 <bollu> vanila: hm, interesting
21:33:18 <bollu> vanila: so how does one represent that constraint?
21:33:38 <jrc12> Zemyla: Yeah I would like lazy insertion, that also enables an efficient lookup
21:33:48 <vanila> well it's called variance, like this: - -> +
21:33:58 <vanila> but for tuples and either, its just  Either + +,  (+, +)
21:34:06 <bollu> vanila: where (-) means don't raise, and (+) mean can raise correct?
21:34:11 <vanila> yeah
21:34:20 <bollu> yeah, makes sense
21:34:34 <bollu> and -(+) = +(-) = (-) correct?
21:34:43 <bollu> like, the non raising dominates over raising
21:34:57 <vanila> I think so!
21:35:13 <vanila> - - = +
21:35:23 <bollu> vanila: no, I don't think that's true
21:35:32 <vanila> oh yeah you'reright
21:35:36 <bollu> vanila: this is a *type system* :)
21:35:42 <EvanR> - -> (- -> +)
21:35:56 <EvanR> (+ -> -) -> +
21:36:01 <EvanR> ?
21:36:26 <Zemyla> jrc12: You can't really have it, because in order to look up a value you're either going to have to check against every single value (which is strict) or put the map into some kind of structure (which is also strict).
21:37:14 <bollu> EvanR: I's assume that becomes - -> -> ->
21:37:32 <EvanR> -> is binary, in haskell
21:37:39 <bollu> (- -> -) -> (- -> -) *
21:37:54 <jrc12> Let's we can make assumption about our keys like adding an ordering contraint and a bounded constraint , would that make it possible?
21:38:01 <EvanR> i dont think so
21:38:10 <bollu> EvanR: why not?
21:38:42 <EvanR> i think a function passed in in a negative position swaps its signs
21:39:08 <bollu> EvanR: :| damn, I was hoping for clarity, not more confusion
21:39:52 <bollu> vanila: any insight>
21:40:50 <EvanR> rather than jumping to subtypes maybe jump to polymorphic types first
21:41:06 <EvanR> map :: forall a . (a -> b) -> [a] -> [b]
21:41:11 <EvanR> map :: forall a b . (a -> b) -> [a] -> [b]
21:44:07 <EvanR> if you dont have this, then youll be in the C boat which is to either re-implement the map operation for every type of list, or have an "Any" (void*) type which must be runtime checked before use
21:44:41 <EvanR> not the case of map, but in the case of head/uncons
21:45:00 <EvanR> ... if youre assigning to typed variables
21:50:13 <bananagram> how soon might 7.10 be released?
21:56:09 <bollu> EvanR: ah
21:56:24 <bollu> EvanR: hm, how do polymorphic type restrictions work out?
21:56:26 <jle`> bananagram: i think i have heard plans for it coming out some time this year but don't quote me
21:56:58 <pdxleif> Is there a way to see the full set of transitive deps as resolved by cabal?
21:57:06 <pdxleif> for a project
21:57:22 <EvanR> bollu: the above type removes the restriction, a and b can be any type (for a given usage of map)
21:58:33 <EvanR> so when you use map somewhere, thats like having two new type variables to solve for
21:59:06 <EvanR> (at least)
21:59:57 <jle`> :t -(+)
21:59:58 <lambdabot> (Num (a -> a -> a), Num a) => a -> a -> a
22:01:38 <jle`> :t -(+)--(-)
22:01:39 <lambdabot> (Num (a -> a -> a), Num a) => a -> a -> a
22:01:46 <jle`> haskell is kinda silly
22:02:22 <jle`> oh you can make the middle thing arbitrarily long huh
22:02:30 <jle`> :t -(*)---------------------(-)
22:02:30 <lambdabot> (Num (a -> a -> a), Num a) => a -> a -> a
22:02:47 <Axman6> > ---1
22:02:50 <lambdabot>  not an expression: ‘---1’
22:03:09 <exio4> > --1
22:03:11 <lambdabot>  not an expression: ‘--1’
22:03:25 <benzrf> it's parsing (---------------) as an operator
22:03:28 <bananagram> > -(-(-1))
22:03:29 <lambdabot>  -1
22:03:34 <benzrf> -(*) is a numeric literal
22:03:38 <jle`> benzrf: but then how come it has a type?
22:03:44 <jle`> it is parsing it as something already defined
22:03:47 <jle`> > -2----------------------10
22:03:49 <lambdabot>  -2
22:03:54 <exio4> commentsd
22:03:55 <bananagram> :t (-)
22:03:55 <int-e> benzrf: --------------- introduces a comment
22:03:55 <lambdabot> Num a => a -> a -> a
22:03:59 <bananagram> :t (-1)
22:04:00 <lambdabot> Num a => a
22:04:06 <benzrf> oh. wait
22:04:08 <exio4> > 42 -- the answer
22:04:09 <bananagram> how confusing
22:04:10 <lambdabot>  42
22:04:15 <benzrf> > -3------------4
22:04:16 <lambdabot>  -3
22:04:18 <benzrf> welp
22:06:27 <jle`> but
22:06:30 <jle`> > -3+----------4
22:06:31 <lambdabot>  Not in scope: ‘+----------’
22:07:34 <jle`> > -3---------+4
22:07:35 <lambdabot>  Not in scope: ‘---------+’
22:07:46 <jle`> ok
22:09:07 <jrc12> Its a comment
22:09:32 <Axman6> no, it's a valid operator
22:11:18 <gfixler> what's my best bet in Haskell for emitting term escape codes in the shell?
22:11:29 <gfixler> i.e. for jumping to a cursor position, changing colors, etc
22:11:50 <gfixler> ncurses? shell calls? should I be using Text?
22:15:10 <ReinH> System.Console.ANSI in ansi-terminal
22:15:24 <ReinH> or ncurses
22:15:33 <ReinH> depending on, well, how much of curses you need
22:16:14 <gfixler> are there any clear pros/cons to each?
22:17:05 <ReinH> If you need a lot of cursor position changes, etc, curses might be more useful
22:17:17 <ReinH> if you just need colors and such, you only need ansi-terminal
22:17:31 <gfixler> cool, thanks
22:18:26 <ReinH> np
22:26:00 <lpaste> Lokathor pasted “ogl hello world” at http://lpaste.net/118049
22:30:49 * hackagebot Strafunski-StrategyLib 5.0.0.5 - Library for strategic programming  http://hackage.haskell.org/package/Strafunski-StrategyLib-5.0.0.5 (JamesKoppel)
22:34:55 <glguy> I just made a library for using GHC.Generics to derive efficient (no GHC.Generics overhead) traversals like you might write using syb's gmapM
22:35:13 <glguy> https://github.com/glguy/sysyb/blob/master/src/Generics/Transforms.hs   with an example use: https://github.com/glguy/dang/blob/7e77feb23595faa92dabb1528b177b0bb9e7f926/src/Dang/ModuleSystem/ScopeCheck.hs#L267
22:35:38 <glguy> (still figuring it out, but wanted to share)
22:38:12 <tzaeru> ungh, why do so many sample and example snippets and even full programs keep using single-letter arguments instead of something even slightly informative.. like "r x y" instead of "root left right" for a tree @_@
22:38:55 <glguy> Because once you get used to short variable names the long ones are just distracting
22:38:56 <sgronblo> because mathematics
22:39:18 <sgronblo> i prefer clear names
22:39:25 <glguy> in small definitions the short names can be easier to keep track of
22:39:30 <tzaeru> glguy, that's just so very untrue :P
22:39:37 <sgronblo> the less backtracking needed the better
22:39:40 <glguy> longer definitions benefit from longer names
22:39:43 <glguy> ?src foldr
22:39:44 <lambdabot> foldr f z []     = z
22:39:44 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:39:44 <tzaeru> well, yes, in smallest definitions, sure
22:39:56 <glguy> that wouldn't be clearer with longer names
22:39:58 <tzaeru> but there are decently long examples and full example programs spanning a few hundred lines that keep using single-letter arguments
22:40:20 <EvanR> moral of the story, program code should be even smaller and smaller
22:40:24 <tzaeru> it's especially confusing when same single letter arguments keep being used for different uses.
22:40:46 <EvanR> x@>#:'x
22:41:05 <glguy> I'm not saying that using single letter names automatically makes code better, just that it depends on context
22:41:39 <tzaeru> yeah, it's ok in some contexts.
22:42:32 <tzaeru> ..though what goes to tutorials aimed for people with no programming background at all (which I haven't looked into much), it could arguably not be a good practice :P
22:42:51 <glguy> Depends if those people are going to want to be able to read other people's code or not
22:43:27 <tzaeru> well erm.. yes.. I guess you could do separate tutorials who people who are not planning to ever write code with or for others, and for those who do..
22:43:42 <tzaeru> sorry about the sarcasm.
22:43:54 <glguy> No need ^_^
22:45:04 <danilo2_> Hello! Is there any way in Haskell to serialize a HMap?
22:45:58 <tzaeru> mh, is there a potential mismatch for using a 64bit MinGw and GHC and a 32bit cabal (on windows)?
22:46:19 <tzaeru> or is cabal completely separate tool from the rest with no linkable libraries coming with itself?
22:51:50 <Lokathor> i think cabal calls ghc, so it should be fine
22:59:53 <Zemyla> So who do I talk to on the Haskell wiki to see if my prime list example is notable enough to be included on the page on primes?
23:06:33 <bollu> :t `+`
23:06:34 <lambdabot> parse error on input ‘`’
23:07:14 <bollu> I'm trying to implement type inference in a toy language of mine, and I *really* don't get how to implement type inferencing for (+)
23:08:34 <bollu> so, like, could someone explain to me how the Hindley-Milner type unification algo works?
23:09:08 <KoreaPanda> hello
23:10:53 <bergmark> bollu: read Tying Haskell in Haskell
23:10:58 <bergmark> Typing*
23:11:19 <bollu> bergmark: thanks :)
23:13:43 <calvinx> I have learnt that we can use pattern matching to define a function in haskell and [] represents an empty list match, [x] represents a list-with-single-element-match and (x:xs) represents a list match (with x being the head and xs being the rest of the list.  Is there a way to represent a predicate in the context of this pattern matching?
23:14:01 <kosmikus> bollu, bergmark: I also quite like this paper as a tutorial for basic Hindley-Milner: http://www.cs.uu.nl/research/techreps/UU-CS-2002-031.html
23:14:52 <kosmikus> calvinx: you can always use guards
23:15:09 <johnw> hi kosmikus!
23:15:10 <kosmikus> calvinx: something like "xs | even (length xs) = ..."
23:15:17 <kosmikus> johnw: hi there
23:15:24 <calvinx> AH.....
23:15:50 * hackagebot tasty-kat 0.0.1 - Known Answer Tests (KAT) framework for tasty  http://hackage.haskell.org/package/tasty-kat-0.0.1 (VincentHanquez)
23:18:30 <osw> any haskell textbook that you would recommend to a beginner in functional programming?
23:19:03 <pavonia> @where lyah
23:19:03 <lambdabot> http://www.learnyouahaskell.com/
23:19:28 <osw> thank you
23:19:38 <CRM114> learn you a haskell was terrible
23:19:58 <johnw> do you use CRM114?
23:20:09 <CRM114> tried it
23:20:21 <johnw> I did too, long ago
23:21:11 <pavonia> osw: I think Hutton's Programming in Haskell is also good for beginners
23:23:13 <osw> I'll try both of them
23:23:29 <CRM114> pavonia: I'll check out Hutton
23:24:05 <CRM114> my background is mostly C, btw
23:24:14 <shachaf> Hutton's _Programming in Haskell_ is good.
23:25:51 <kosmikus> it's certainly a matter of personal taste, but for me Bird > LYAH > Hutton > Thompson; none of them bad, though
23:26:28 <Hijiri> osw: check out https://github.com/bitemyapp/learnhaskell too
23:28:34 <steffen> How can I patternmatch on Text and not on String? if I do case
23:28:34 <steffen> whaterver of and then I want to differentiate between the Text "200" "404"
23:28:34 <steffen> "500" and so on. But NOT String, I want to patternmatch on Text? :)
23:28:53 <osw> thanks Hijiri
23:29:47 <osw> that looks really organized
23:31:36 <shachaf> steffen: OverloadedStrings lets you do it.
23:32:22 <steffen> shachaf: Ahh yes, thank you :)
23:33:39 <ReinH> kosmikus: my list is similar except that LYAH isn't on it.
23:38:02 <kosmikus> ReinH: interesting. I guess it's a book you either love or hate ...
23:39:32 <tzaeru> it definitely is just that ;)
23:43:04 <bitemyapp> kosmikus: Bird covers so little of what people struggle with in Haskell.
23:43:42 <bitemyapp> kosmikus: and his explanation of IO in the 2ed and his newer book confuses it with Monad, worsening an extant pedagogical problem.
23:44:28 <bitemyapp> kosmikus: Bird relates recursion to induction and does an okay job of explaining non-strict evaluation.
23:44:41 <bitemyapp> the exercises are not terribly helpful.
23:45:04 <bitemyapp> kosmikus: there are better courses for learning Haskell than going through Bird's book now.
23:45:25 <bitemyapp> kosmikus: they're still profoundly incomplete, but they're an improvement.
23:45:33 <CRM114> Bird's book would be?
23:46:02 <bitemyapp> Introduction to Functional Programming 2ed is the main one he's known for, but he's respun it as a new book recently.
23:46:10 <bitemyapp> mostly the same material.
23:46:24 <bitemyapp> you can do better if you're learning Haskell.
23:46:40 <bitemyapp> CRM114: http://bitemyapp.com/posts/2014-12-31-functional-education.html https://github.com/bitemyapp/learnhaskell
23:46:47 <bitemyapp> off to bed for me now.
23:47:51 <kosmikus> bitemyapp: I'm referring to the new edition
23:48:01 <Navarth> I am reading the monad chapter now in Bird's new book and struggling a little with his explanation of State Monad. But other than that, its been really good so far. I loved the equational reasoning he uses in the earlier chapters.
23:48:05 <bitemyapp> kosmikus: yeah mostly the same problems.
23:48:23 <bitemyapp> kosmikus: I reviewed his new edition too. It fixed none of the primary problems.
23:48:26 <kosmikus> bitemyapp: I know. none of these books are perfect.
23:48:53 <bitemyapp> kosmikus: it reshuffled order a bit. Same IO/Monad confusion that explains nothing about IO.
23:48:54 <kosmikus> bitemyapp: that's why I specifically said that the order is *my personal* preference
23:49:15 <bitemyapp> kosmikus: mine isn't based on preference but on what has worked to get people through learning Haskell.
23:49:33 <kosmikus> bitemyapp: so what?
23:49:44 <bitemyapp> kosmikus: it burns my tail when people get sent on wild goose-chases.
23:49:57 <bitemyapp> kosmikus: a *lot* of people attempt to learn Haskell and give up. Too many.
23:50:08 <bitemyapp> kosmikus: for reasons that are utterly contingent on poor learning material.
23:50:18 <bitemyapp> kosmikus: not because there's anything wrong with them or with Haskell.
23:50:31 <bitemyapp> kosmikus: then people keep recommending material that doesn't work for most people as an introduction.
23:50:36 <kosmikus> bitemyapp: oh, but Bird isn't "poor learning material". it's not for everyone, clearly.
23:51:07 <bitemyapp> Bird is good to read after you already know Haskell.
23:51:25 <bitemyapp> so you can connect some dots and get a stronger intuition for non-strictness.
23:51:42 <Navarth> fwiw, I grokked monads only recently after reading the chapters in LYAH, I realized that the reason that I didn't understand earlier was due to a poor understanding of type classes
23:51:48 <kosmikus> bitemyapp: whatever works for you ;)
23:51:56 <bitemyapp> kosmikus: again, it's not about what works for me.
23:52:13 <CRM114> bitemyapp: thansk
23:52:15 <CRM114> *thanks
23:52:44 <kosmikus> bitemyapp: well, you seem to claim to speak for everyone, so ...
23:53:03 <bitemyapp> kosmikus: talk to the people who help me teach. Ask them.
23:53:27 <bitemyapp> kosmikus: or one of the people I've helped learn Haskell.
23:53:38 <kosmikus> bitemyapp: I don't want to ask anyone. You started a discussion with me, without any good reason.
23:54:02 <bitemyapp> without good reason. Indeed.
23:54:58 <CRM114> I've tried learning Haskell several times now, the material was either bad or old
23:55:20 <bitemyapp> CRM114: Or didn't cover enough of what's used in real Haskell code today.
23:55:33 <bitemyapp> and when you don't know what you don't know, that can be a serious issue.
23:55:49 <CRM114> bitemyapp: I didn't get far enough for that problem to be significant
23:55:51 <bitemyapp> CRM114: there's another IRC channel focused on helping beginners learn Haskell.
23:55:57 <bitemyapp> CRM114: #haskell-beginners
23:56:08 <bitemyapp> CRM114: all teacher-learners.
23:56:16 <Hijiri> neat, just noticed the PL class at my school covers liquid types
23:56:18 <bitemyapp> CRM114: give cis194 a shot, if you get stuck, ask for help.
23:56:31 <CRM114> I'll see
23:56:42 <bitemyapp> CRM114: up to you.
23:56:50 <CRM114> I'm juggling other projects so I'm giving it attention only occasionally
23:56:56 <bitemyapp> Hijiri: that's pretty cool, my impression was that it was very active research still.
23:57:00 <Hijiri> well
23:57:02 <bitemyapp> CRM114: we've all got our balls to juggle.
23:57:06 <tolt> bitemyapp, what is your book focused on?
23:57:12 <bitemyapp> tolt: learning Haskell
23:57:22 <bitemyapp> tolt: more or less from zero.
23:57:22 <Hijiri> it's UCSD, I think the professor is trying to work his work into the class
23:57:28 <bitemyapp> Hijiri: ohhhh, Ranjit?
23:57:30 <Hijiri> yeah
23:57:39 <bitemyapp> Hijiri: yeah I was wondering if you were taking his class.
23:57:42 <tolt> bitemyapp, beginning haskell?
23:57:45 <Hijiri> I'm not taking it
23:57:54 <tolt> lile from no haskell?
23:58:03 <Hijiri> but it doesn't have any prereqs, so I should be able to take it when I want to (if it's still there)
23:58:12 <bitemyapp> tolt: zero Haskell to...something further than any other books currently take you by themselves.
23:58:25 <tolt> alright. cool.
23:58:40 <bitemyapp> tolt: I'm not going to give you a specific endpoint because the TOC is still speculative, but we have a wishlist in mind.
23:59:02 <bitemyapp> tolt: put it this way, I do Haskell at home and for work. I'd like the book to get people at least to a place where they can learn everything else required to do the same themselves.
23:59:24 <tolt> Yeah. I wasn't hoping for that. I was just curious where you were aimimg.
23:59:30 <bitemyapp> tolt: the focus right now is on solid pedagogy.
23:59:38 <bitemyapp> tolt: what were you hoping for?
