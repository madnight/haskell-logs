00:00:06 <triptec> I'm new to haskell and I'm looking at persistent and wondering about the mkMigrate "migrateAll" in this part: share [mkPersist sqlSettings, mkMigrate "migrateAll"], the table and data already exist in the db I'm connecting to
00:08:15 * hackagebot Irc 0.1.0.2 - DSL for IRC bots  http://hackage.haskell.org/package/Irc-0.1.0.2 (yunxing)
00:08:15 * hackagebot language-c-inline 0.7.8.0 - Inline C & Objective-C code in Haskell for language interoperability  http://hackage.haskell.org/package/language-c-inline-0.7.8.0 (ManuelChakravarty)
00:12:07 <Lokathor> cabal-install-1.22, cabal-install-1.20, and cabal-install-1.18 have all failed to build on my device.
00:12:56 <Lokathor> the raspberry pi must have some special adjustments in the version that the repo provides (1.14) that cabal is not accounting for :/
00:13:10 * hackagebot enummapset-th 0.6.0.2 - TH-generated EnumSet/EnumMap wrappers around IntSet/IntMap.  http://hackage.haskell.org/package/enummapset-th-0.6.0.2 (LiyangHu)
00:14:33 <supki> Lokathor: do you have error logs?
00:15:49 <lpaste> Lokathor pasted “cabal-install 1.18 on ras pi error” at http://lpaste.net/118916
00:16:14 <Lokathor> not sure i have the history for the other errors
00:16:53 <Lokathor> it takes the poor pi about 2-3 hours to attempt a build of Cabal and Cabal-install... i'm trying 1.16 right now
00:20:31 <supki> I'd try to remove getNumberOfProcessors from cbits/getnumcores.c first
00:23:12 <Lokathor> I can probably go back and try that later, but i'm gonna let the 1.16 attempt finish out tonight
00:23:23 <Lokathor> i'm almost happy with 1.14, but no sandboxing is sad times
00:31:05 <Lokathor> the slightly confusing part is that i don't think that the other versions had the same build errors
00:31:10 <Lokathor> i'm just unlucky
00:46:47 <supki> IIRC 1.16 doesn't have sandboxes
00:48:23 <supki> yeah, they were introduced in 1.18
00:50:38 <starless> how does one enforce constraints on a user-defined datatype in Haskell? for example, is there a way to guarantee given this type:
00:50:46 <starless> data Stat = Stat Int
00:50:54 <starless> that the int is between 0 and 100?
00:52:51 <adas> i think dependent types is what you're looking for. But i'm afraid that's as much as I know
00:53:39 <vanila> no not dependent types
00:53:46 <vanila> you just can't do it in haskell
00:54:00 <vanila> use normal Int and makre sure the code only gives results in the right range
00:54:02 <mr-> starless: You can limit access to the Int by hiding the constructor and providing "smart" constructors
00:55:04 <adas> vanila: why not dependent types?
00:55:17 <vanila> that wont help
00:56:48 <Freundlich> You can either dynamically enforce the condition (by producing errors if it doesn't hold) or you can do so statically (using dependent types) but that will limit how you can use values of said type.
00:57:22 <Hijiri> refinement types with liquid haskell might help
00:59:03 <starless> adas, vanila, mr-, Freundlich, Hijiri: thanks. I'll look into your recommendations. Surprised it's not easier to do in Haskell!
00:59:28 <vanila> starless, its not possible in haskell
01:01:48 <dibblego> module Stat(Stat) where; newtype Stat = Stat Int; stat :: Prism' Stat Int; stat = prism' (\(Stat n) -> n) (\n -> bool Nothing (Stat n) (n >= 0 && n <= 100))
01:03:30 <shachaf> Are you sure your prism is going in the right direction?
01:06:30 <dibblego> sorry
01:06:35 <dibblego> stat :: Prism' Int Stat; stat = prism' (\(Stat n) -> n) (\n -> bool Nothing (Just (Stat n)) (n >= 0 && n <= 100))
01:07:18 <vanila> types are static and existing before runtime. You cannot make a data type that statically enforces a runtime predicate in haskell since the two worlds are separated.
01:09:01 <dibblego> any Stat value is now guaranteed to have an Int between 0 and 100
01:10:23 <tdammers> vanila: actually, you can, in a way, but it's not pretty
01:10:34 <tdammers> vanila: peano numbers, for example
01:11:15 <tdammers> or, data ConstrainedInt = Zero | One | Two | ... | NinetyNine | OneHundred
01:11:30 <tdammers> have fun writing those Num instances
01:11:40 <tdammers> s/instances/methods/
01:17:24 <starless> shachaf, dibblego: one last thank you. I'll be looking into all this. good night all.
01:17:44 <dibblego> no probably
01:18:13 * hackagebot aws-ec2 0.3.1 - AWS EC2/VPC, ELB and CloudWatch client library for Haskell  http://hackage.haskell.org/package/aws-ec2-0.3.1 (VladimirKirillov)
01:22:22 <mr-> tdammers: Yeah, Integer is weird. So many constructors..
01:23:38 <tdammers> :D
01:23:49 <tdammers> still working on finding them all
01:27:34 <grohne> is there a good reason that there is no instance Error ()?
01:27:56 <grohne> (e.g. noMsg = (); strMsg = const ())
01:31:26 <jle`> because even mtl maintainers gave up on Error
01:31:49 <jle`> :)
01:32:11 <jle`> also you might want to consider MaybeT or natural transformations between EitherT and MaybeT
01:50:41 <ClaudiusMaximus> vanila: so.. 13.13s with Rational, 7.26s with unsafeCoerce to avoid gcd checks, 7.50s with my own type (actually a data type together with a class abstracting over my implementation and Data.Ratio's implementation, with only the operations i need) - ie, I needn't unsafeCoerce any more
01:52:12 <vanila> it's a shame its (slightly) slower than rational, and that you had to create that type - thanks for doing the measurements though, that's really cool!
01:53:40 <ClaudiusMaximus> what's the ghc flag to dump specializations?  maybe the extra polymorphism isn't compiled away completely
01:59:54 <ClaudiusMaximus> vanila: well, adding a few {-# SPECIALIZE instance FooClass BarType #-} brings it to 7.25s, which I guess is good news
02:01:12 <koomi> you can look at the core
02:03:14 * hackagebot hindent 4.2.2 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.2.2 (ChrisDone)
02:08:15 * hackagebot postgresql-simple-sop 0.1.0.3 - Generic functions for postgresql-simple  http://hackage.haskell.org/package/postgresql-simple-sop-0.1.0.3 (glutamate)
02:08:17 * hackagebot postgresql-binary 0.5.1 - Encoders and decoders for the PostgreSQL's binary format  http://hackage.haskell.org/package/postgresql-binary-0.5.1 (NikitaVolkov)
02:29:05 <izohask> I do not get what is the point (advantage) of reader monad
02:29:20 <izohask> why would I need to say "asks bar"
02:29:42 <izohask> when I can have something with "let x = bar MyContext"
02:29:55 <keko_> you don't have to explicitly pass the options to any function you call
02:30:01 <tdammers> there is not a huge point in Reader
02:30:23 <izohask> I understand this huge pointer is wrapped by Reader
02:30:39 <tdammers> :P
02:30:51 <izohask> but I have to "use" something always, either Reader instance or my "huge" structure
02:31:00 <tdammers> point. not pointer.
02:31:18 <merijn> izohask: The point of Reader is that you don't have to explicitly pass an extra argument to every function
02:32:11 <izohask> aha.. so this point is not visible if I use e.g. "ex1 = runReader computation $ MyContext "hello" 1"
02:32:38 <izohask> as here I'm adding this "MyContext bla bla" (example from "http://www.stephendiehl.com/what/")
02:33:03 <izohask> and  I would do the same in "ex1 = computation $ MyContext bl bla"
02:33:23 <izohask> only diff is that in first example there is "runReader", so longer line :)
02:34:05 <izohask> seems I have to try to create some bigger app, in order to understand advantages of having a reader.. Is there any nice, short example somewhere ?
02:36:35 <izohask> merijn: you mean, if you have those functions chained by ">>=", THEN I do not have to pass the same argument in each one ?
02:37:16 <merijn> izohask: If you use do notation (reader is a monad!) it can make a lot of code cleaner
02:37:50 <aomm> Hello. I'm trying to get HGL (Haskell graphics library) working on windows, to no luck. When I run a sample program which creates a window, I recieve the error "Exception: DestroyWindow: permission denied (Access is denied.)"
02:39:10 <aomm> using HGL 3.2.0.5
02:39:52 <merijn> izohask: tbh, Reader becomes more useful when you start using transformers and layering multiple monad transformers
02:40:18 <merijn> izohask: There is the ReaderT transformer which basically "adds" reader behaviour to an existing monad.
02:42:24 <gfixler> should I be versioning Setup.hs?
02:42:49 <izohask> merijn: yes, I got it  now, tried to create new func and really, in DO notation I do not have to put config all arround
02:42:57 <gfixler> I'm pretty sure I don't want to version the sandbox or dist/ stuff
02:43:00 <izohask> merijn: yes, sounds much reasonable now, thnx
02:43:19 <merijn> gfixler: You should version Setup.hs, yes
02:43:30 <gfixler> merijn: okay, thanks
02:43:35 <merijn> gfixler: It's used to install packages on machines without cabal-install
02:43:39 <gfixler> ah
02:43:47 <merijn> gfixler: And used for "custom" setups if you hook into things like C, autotools, etc.
02:44:21 <merijn> gfixler: i.e. things like: https://github.com/merijn/SNet2.0/blob/master/Setup.hs
02:44:44 <gfixler> ah, so it can be arbitrarily complex
02:45:05 <merijn> gfixler: Right
02:45:18 <gfixler> and insidious
02:45:26 <gfixler> I'll have to check those from now on
02:45:34 <merijn> gfixler: So can any Template Haskell code :)
02:45:44 <merijn> gfixler: TH can run arbitrary IO
02:45:58 <gfixler> this is TH?
02:46:22 <merijn> No, but I mean that TH can run arbitrary IO during compilation too
02:46:37 <gfixler> oh, right
03:00:51 <Arahael> So, I've forgotten how to use cabal. :/
03:01:46 <Arahael> I have a .cabal file, with a dependency, one of which is 'http', but it won't install.  It somehow installs manually (via 'cabal install http'), but it doesn't install as a dependency of the current project (ie, 'cabal build .' isn't working)
03:02:08 <Arahael> Because it complains that the dependency I just installed is somehow missing!?
03:02:30 <Arahael> cabal: At least the following dependencies are missing:
03:02:30 <Arahael> http >=4000.2.19
03:02:32 <alpounet> Arahael: maybe it's a problem of versions? could you paste your cabal file and the error log somewhere? like http://lpaste.net
03:05:12 <Arahael> alpounet: Same version. http://lpaste.net/4141031824115630080
03:05:20 <Arahael> Oh, and error...
03:06:12 <Arahael> http://lpaste.net/4141031824115630080
03:06:25 <Arahael> Annotated there. (Should've probably just done an edit, actually, but anyway)
03:07:33 <Arahael> As you can see there, I have the exact same version as is required.
03:07:42 <Arahael> Yet it doesn't work.
03:15:39 <Arahael> alpounet: You must be stumped as well!
03:17:29 <alpounet> Arahael: sorry, was getting a coffe, looking now
03:18:00 <Arahael> alpounet: I'll be heading off to bed in about 5 minutes.
03:18:18 <alpounet> Arahael: i'm pretty sure it's not it but can you try writing HTTP instead of http in your cabal file?
03:18:58 <Arahael> alpounet: That's...  Stupid...
03:19:21 <Arahael> alpounet: That did appear to be the issue.
03:19:23 <alpounet> did it work?
03:19:28 <alpounet> wow
03:19:30 <Arahael> alpounet: Indeed.  Not impressed.
03:19:41 <MP2E> hah :P
03:19:41 <alpounet> that's pretty terrible :/
03:19:44 <Arahael> alpounet: Thanks. :)
03:19:54 <alpounet> anyway, at least your problem is solved
03:20:17 <Arahael> Indeed. Also I should've done 'cabal build' instead of 'cabal build .', but once fixing the case there, that was obvious.
03:21:00 <Arahael> In my defense, 'cabal install http' should have failed.
03:21:04 <Arahael> Anyway.
03:21:21 * Arahael mutters and gets ready for bed.  He'll probably have bad dreams, tonight.
03:43:46 <quantgeek> I have a very simple question regarding Monads... for this expression [1,2] >>= \n -> ['a','b'] >>= \ch -> return (n,ch)
03:43:52 <quantgeek> I understand that [1,2] is passed to n....as a parameter to a lambda function
03:43:57 <quantgeek> what we seem to be missing here is the actual function.
03:44:05 <quantgeek> ['a','b'] is not the function...and if we evaluate from left to right...it doen
03:44:09 <quantgeek> *doesn't make sense
03:44:13 <quantgeek> With do notation it seems like -> translates to chaining....
03:44:17 <quantgeek> but with treating -> as a function operator....it's a bit convoluted
03:45:38 <angerman> is there an "or" combinator for either? Say f :: Either a b, g :: Either a b, such that if f returns Left, g is called?
03:46:01 <vanila> the first function is (\n -> ['a','b'] >>= \ch -> return (n,ch))
03:46:07 <vanila> and the second is (\ch -> return (n,ch))
03:46:18 <vanila> \<varible> -> <body>  creates an anonymous function
03:52:22 <quantgeek> thanks for the explanation vanila. i agree with second function it's clear.
03:52:37 <quantgeek> the first function is a bit confusing
03:52:47 <quantgeek> coz i don't see how can it be the same as second one
03:53:00 <quantgeek> basically the overlap
03:53:29 <izohask> in monadTransformers page, at http://en.wikibooks.org/wiki/Haskell/Monad_transformers
03:53:38 <izohask> return is defined as
03:53:40 <izohask> return  = MaybeT . return . Just
03:54:02 <vanila> quantgeek, well a function can contain another one inside it
03:54:04 <izohask> how can be "return" on both sides.. It seems like it is different "return" (one for MaybeT, other for IO) ?
03:55:28 <jle`> izohask: do you know about typeclasses?
03:55:33 <jle`> :t return
03:55:34 <lambdabot> Monad m => a -> m a
03:56:10 <jle`> you can think of `return` as polymorphic; it is actually a different function for every Monad instance
03:56:16 <jle`> just like (+) is different for Int, Integer, Float, Double
03:56:38 <jle`> or `mempty` is different for [a], Maybe, Sum Int, etc.
03:57:00 <izohask> jle`: I understand it is differnet for list, maybe etc...
03:57:01 <jle`> or how minBound is different for Int, Bool, Char
03:57:26 <jle`> it's actually really like totally different functions
03:57:28 <jle`> values
03:57:38 <jle`> they just happen to have the same "name"
03:57:47 <jle`> so when haskell sees "minBound", it has to infer what type you are expecting
03:57:54 <jle`> and it pulls out the implementation for that type
03:57:54 <izohask> it is easy for me to figure our something like return x = Just x in Maybe monad...
03:58:10 <jle`> return = MaybeT . return . Just
03:58:20 * hackagebot hindent 4.2.3 - Extensible Haskell pretty printer  http://hackage.haskell.org/package/hindent-4.2.3 (ChrisDone)
03:58:27 <jle`> so this is a part of the declaration syntax for typeclass instance methods
03:58:40 <jle`> return (for MaybeT m) is defined as MaybeT . return . Just
03:58:55 <jle`> we know that the MaybeT m return is return :: Monad m => a -> MaybeT m a
03:59:17 <jle`> so haskell knows that (MaybeT . return . Just) has to have that type
03:59:43 <jle`> Just :: a -> Maybe a, so that means that (MaybeT . return) has to be of type Maybe a -> MaybeT m a
03:59:51 <jle`> er, Monad m => Maybe a -> MaybeT m a
04:00:32 <jle`> MaybeT :: m (Maybe a) -> MaybeT a, so that means that return has to be of type Monad m => Maybe a -> m (Maybe a)
04:01:09 <jle`> remember that `return`, like mempty, (+), minBound, succ, etc., is overloaded.  when it is actually eventually compiled, the proper one is put in
04:01:44 <jle`> in this case, when you actaully need to use `return` for MaybeT, the `return` on the right hand side will be the `return` for the m in `MaybeT m a`
04:02:08 <jle`> what exactly this is will be inferred through type inference :)
04:02:12 <quantgeek> Shouldn't it be \n -> (function)  And function is this (['a','b'] >>= \ch -> return (n,ch))  If it's left to right It can't evaluate the second \ch function without using the first part ['a','b'] which doesn't have to do anything with 'n' parameter.
04:02:18 <izohask> so, this part "return (Just x)" actualy creates "IO (Maybe a)"
04:02:27 <jle`> it depends
04:02:31 <izohask> (in case I use MaybeT IO String )
04:02:34 <jle`> ah yes
04:02:38 <vanila> quantgeek, thats true
04:02:39 <izohask> ah I see...
04:02:45 <jle`> if you have MaybeT IO String, return there is a -> IO a
04:02:55 <izohask> so compiler actually calculates types on the right side...
04:03:02 <izohask> and then finds out "which return I should use"
04:03:09 <jle`> yes, it's called type inference :) it's actaully pretty awesome
04:03:24 <jle`> like i mentioned earlier, the same thing happens for things like minBound, mempty, (+), etc.
04:03:24 <izohask> yes... but damn hard to understand
04:03:34 <izohask> (sometimes)
04:03:42 <jle`> yeah, it gets tricky when you have typeclasses
04:03:48 <jle`> but you get used io it
04:04:03 <izohask> it seems so...
04:04:22 <jle`> if you just have `minBound` or `mempty`, for example, ghc can't relaly know what you want
04:04:28 <jle`> but it infers what you *must* want, given the context
04:04:38 <jle`> > [minBound, 'a']
04:04:39 <lambdabot>  "\NULa"
04:04:51 <izohask> now I get this, I hope... later in "askPassword" function , I can do something like
04:04:52 <funfunctor> hi
04:05:01 <vanila> hey funfunctor!
04:05:03 <jle`> minBound appears in a list with 'a', a Char, so it knows that the minBound you want here is the minBound for Char
04:05:10 <funfunctor> hey vanila !!!
04:05:14 <vanila> :D
04:05:17 <funfunctor> hows things?
04:05:18 <vanila> I really enjoyed post on thesteam issue
04:05:18 <izohask> if (condition) return x else MaybeT (return Nothing)
04:05:20 <vanila> your post
04:05:26 <vanila> prety good, im a bit ill though
04:05:30 <izohask> and those two "return" are actually different ones, right ?
04:05:33 <vanila> whats up
04:05:36 <jle`> > (0 :: Int) + (1 :: Int)     -- (+) appears with Ints, so it infers that it must be the (+) for Int
04:05:38 <lambdabot>  1
04:05:40 <funfunctor> vanila: haha, you saw that?!
04:05:48 <jle`> izohask: yes, in that case
04:05:52 <vanila> yeah, I was like OH I know that guy!
04:05:56 <jle`> you forgot a `then`, btw
04:06:08 <jle`> izohask: the two branches must be of the same type
04:06:19 <jle`> so (return x) and (MaybeT (return Nothing)) have to be of the same type
04:06:22 <funfunctor> vanila: :) yea there is really no excuse for Valve to go delete peoples data...
04:06:33 <izohask> I see now.. hard to move to this way of thinking.. Thanks a lot!
04:06:44 <jle`> so Haskell has to find out exactly which `return` has to be put there in order to have boht sides be the same type
04:06:48 <jle`> this dance is called "unification"
04:06:50 <funfunctor> vanila: oh, I hope you feel better soon! I'm feeling a bit down also..
04:07:08 <jle`> izohask: no problem :)  sometimes it gets tricky, but you'll get used to it for the most part :)
04:07:10 <vanila> sorry to hear it
04:07:28 <funfunctor> vanila: it will pass
04:08:03 <izohask> jle`: Hopefully :) Sounds funny that haskell will get whici type to use.. once I will be able to abstract a lot of stuff easily :)
04:08:03 <jle`> return Nothing is Monad m => m (Just a), MaybeT is m (Maybe a) -> MaybeT m a, so MaybeT (return Nothing) is Monad m => MaybeT m a
04:08:09 <funfunctor> vanila: so i've been trying to understand the lower layer of GSM
04:08:46 <funfunctor> vanila: I have a SDR and i'm attempting to write the radio part of GSM to provide a network socket in Haskell
04:08:52 <jle`> return x is `Monad n => m a`, and we know that that has to be "equal" to Monad m => MaybeT m a
04:09:01 <jle`> er, Monad n => n a
04:09:05 <vanila> nice! I really wantedto get into SDR a little bit ago
04:09:08 <jle`> this is only equal if we let n ~ MaybeT m
04:09:21 <jle`> but yeah, you get the picture
04:09:35 <jle`> izohask: it's actually one of the "big deals" about haskell, i think :)  one of the selling points
04:09:57 <funfunctor> vanila: I essentially narrowed down the relevant bits of code that implement it in C++ from OpenBTS/YateBTS now I am stuck translating that into Haskell..
04:09:57 <jle`> you get the security of statically typed languages, without the productivity overhead of verbose type signatures
04:10:11 <jle`> the type signatures are inferred for you :D
04:10:13 <izohask> jle`:yes, and also is contantly being mentioned.. While I'm constantly being blocked by such stuff :)
04:10:23 <funfunctor> vanila: their code is horrible horrible C++
04:10:26 <vanila> that sounds like really serious work D:
04:10:40 <jle`> no worries.  it happens to everyone too at first :)
04:10:44 <vanila> is that part of osmocom?
04:11:07 <funfunctor> vanila: well the relevant code is only some 4-6kloc of C++ so it /should/ be possible to get it translated.
04:19:21 <funfunctor> vanila: https://github.com/victoredwardocallaghan/Congo
04:20:02 <funfunctor> vanila: at the moment I am just reading the bladeRF library which I need to make a Haskell binding too.
04:20:10 <funfunctor> I guess I can put that up on hackage
04:20:23 <vanila> how does it interface to hardware/
04:25:08 <phaazon> hi
04:26:05 <phaazon> https://www.reddit.com/r/haskell/comments/2t5xbf/cant_profile_an_application_on_windows_with
04:26:10 <phaazon> if you have an idea
04:26:20 <phaazon> I've been stuck on that for a few days now
04:27:53 <clrnd> phaazon, how did you install GHC?
04:28:36 <phaazon> clrnd: Haskell Platform
04:29:01 <phaazon> I made a clean install yesterday to see whether it'd have fixed the issue
04:29:10 <phaazon> but it's the same
04:29:15 <phaazon> I still miss the library
04:29:31 <phaazon> it sounds it's not shipped with the Haskell Platform :(
04:29:33 <dcoutts> phaazon: looks like you're using the -debug flag somewhere
04:29:39 <dcoutts> and you don't want that
04:29:42 <dcoutts> just profiling
04:29:43 <phaazon> yes I am
04:29:44 <phaazon> oh?
04:29:48 <phaazon> what is debug for then?
04:30:20 <dcoutts> phaazon: using the debugging version of the RTS, for debugging the RTS :-)
04:30:30 <dcoutts> (or sometimes debugging other nasty low level issues)
04:30:50 <dcoutts> phaazon: and there is no variant for debug+profiling
04:30:59 <dcoutts> hence the error
04:31:08 <phaazon> I see!
04:31:12 <phaazon> thank you very much
04:31:16 <phaazon> really <3
04:31:21 <dcoutts> np
04:31:27 <phaazon> I'll profile my 3D engine tonight then!
04:31:37 <dcoutts> phaazon: now you can fill in the answer on stack overflow and reddit ;-)
04:31:45 <phaazon> yep :)
04:31:47 <phaazon> I am
04:31:50 <dcoutts> cheers
04:32:38 <clrnd> wow I had no idea, this should issue a better warning in ghc
04:33:33 <dcoutts> clrnd: I agree, welcome to file a ghc ticket
04:33:43 <merijn> Can GHC really warn against that?
04:33:43 <dcoutts> people don't know that -debug isn't what they think
04:34:05 <dcoutts> merijn: it could know what combos of rts are installed and what abi combos make sense
04:34:07 <merijn> I didn't know about -debug at all and now I'm glad :>
04:34:25 <merijn> Because debugging the RTS was a pain :>
04:34:25 <phaazon> dcoutts: I've put debug because my application doesn't show up some important resources in CodeXL
04:34:33 <phaazon> I thought -debug would insert debugging symbols everywhere
04:34:56 <dcoutts> phaazon: it's not a totally unreasonable guess
04:35:13 <dcoutts> we actually use -g like gcc iirc, though that's a bit of a new feature
04:35:28 <dcoutts> phaazon: and currently Haskell symbols will not help you much
04:35:48 <merijn> GHC won't use DWARF until 7.10 is released, I think?
04:35:53 <phaazon> dcoutts: well, I think the issue is related to the calling convention
04:36:09 <phaazon> CodeXL doesn't see important caals
04:36:12 <phaazon> calls
04:36:18 <phaazon> like glDrawElementsInstanced
04:36:30 <phaazon> nor glGenTextures
04:36:35 <phaazon> which is pretty annoying :D
04:38:21 * hackagebot extensible 0.2.3 - Poly-kinded, extensible ADTs  http://hackage.haskell.org/package/extensible-0.2.3 (FumiakiKinoshita)
04:38:23 * hackagebot ruff 0.4 - relatively useful fractal functions  http://hackage.haskell.org/package/ruff-0.4 (ClaudeHeilandAllen)
04:38:34 <phaazon> anyways
04:38:40 <phaazon> thank you SO MUCH, dcoutts
04:38:42 <phaazon> :)
04:38:44 <phaazon> happy hacking
04:38:51 <phaazon> and have a good day
04:38:57 <phaazon> I'm at work, doing perl
04:38:59 <phaazon> dammit.
04:39:07 <leday> :(
04:43:47 <triptec> I'm trying to compile this gist: https://gist.github.com/konstantinwebarchitect/11231173, but I get an error I dont really understand(total noob) src/Main.hs:50:34: Not in scope: data constructor ‘Db.Key’
04:45:22 <shachaf> Well, do you know what a "data constructor" is?
04:46:07 <leday> That's using Db.Key for type inference
04:47:36 <triptec> shachaf: in a java sense yes
04:47:56 <triptec> leday: ok
04:48:28 <leday> Hang on, I'm looking at the import itself, I don't want to say anything daft
04:49:11 <merijn> triptec: FYI you can have type signature on separate lines in let blocks
04:50:05 <merijn> triptec: i.e.: http://lpaste.net/118920
04:51:31 <triptec> merijn: ok, thanks.. but the error, isn't that due to something missing in Database.Persist.Postgresql ?
04:53:07 <merijn> triptec: Well, on line 50 you're using Db.Key as data constructor (on the right of the '='), it's saying there's no data constructor with that name in scope
04:53:16 <merijn> So where did you get that constructor from?
04:53:31 <leday> The definition for Key that it's after appears to be imported into .Postgresql itself
04:53:42 <leday> [if you're sure that that's where it's from]
04:53:57 <leday> Because there's this line: import Database.Persist.GenericSql hiding (Key(..))
04:54:11 <triptec> merijn: from Database.Persist.Postgresql, no?
04:54:33 <triptec> leday: oh
04:54:54 <leday> It *may* be that the library's been changed since that code was written
04:55:05 <leday> i.e. there used to be a definition of Key there but it's since been shunted around
04:55:20 <triptec> leday: yeah I think you're right
04:55:30 <leday> That's pretty much where 99% of my woes lie with hackage stuff
04:55:49 <leday> In theory it's easy to fix
04:56:16 <leday> Just find where Key is defined in that import chain and point it to that instead
04:56:31 <triptec> it says something about this in http://www.yesodweb.com/book/persistent#persistent_closer_look_at_types, I think that is
04:57:25 <leday> If Key is just a newtype wrapper for an Int64 you could even just drag the definition into the source
04:58:21 <leday> Right, I've got to vanish for a bit, I'll be back later. Good luck! :)
04:58:22 <merijn> It's not, it looks like it's defined as associated datatype
04:58:48 <triptec> leday: sorry I think I might need some more basic skills to pull this off, but thanks for your time
05:00:34 <triptec> merijn: here Key is a constructor https://hackage.haskell.org/package/persistent-postgresql-1.3.1.3/docs/doc-index-All.html
05:00:50 <triptec> but here it's not https://hackage.haskell.org/package/persistent-postgresql-2.1.2.1/docs/doc-index-All.html
05:01:33 <merijn> Right, which is probably the move described in that book
05:02:12 <merijn> But I dunno enough about persistent to tell you what changed
05:02:17 <merijn> Try asking in #yesod too?
05:02:50 <triptec> merijn: yeah I'll try that, thanks!
05:05:56 <dfeuer> Dadgommit.
05:06:04 <dfeuer> STupid computer.
05:06:15 <Shogun> is there something like QuickCheck.Modifiers in SmallCheck?
05:08:22 * hackagebot minisat 0.1.1 - A Haskell bundle of the Minisat SAT solver  http://hackage.haskell.org/package/minisat-0.1.1 (JeroenBransen)
05:08:24 * hackagebot haroonga 0.1.6.0 - Low level bindings for Groonga.  http://hackage.haskell.org/package/haroonga-0.1.6.0 (cosmo0920)
05:09:42 <iLike> Say I have a list of tuples of type: "Monoid a, Monoid b => (a, b)", is there a nicer way to combine them than: "foldr (\(c, v) (c2, v2) -> (c `mappend` c2, v `mappend` v2)) (mempty, mempty)"?
05:10:15 <vanila> maybe ther is already a monoid instance for tuple?
05:10:21 <vanila> and then you could use mconcat
05:10:59 <iLike> well there is, but that's only for the second value iirc
05:11:05 <iLike> But let me check that...
05:12:09 <merijn> iLike: No it's not :p
05:12:12 <merijn> That'd make no sense
05:12:21 <merijn> What would it do with the first value? Throw it away?
05:12:41 <merijn> > ([1,2,3], Sum 3) `mappend` ([4,5,6], Sum 9)
05:12:43 <lambdabot>  ([1,2,3,4,5,6],Sum {getSum = 12})
05:12:48 <merijn> > ([1,2,3], Sum 3) `mappend` mempty
05:12:50 <lambdabot>  ([1,2,3],Sum {getSum = 3})
05:13:03 <iLike> merijn, all those typeclasses are boggling my mind :P
05:13:12 <merijn> In other words, just "foldr mappend mempty" is sufficient :)
05:13:25 <merijn> iLike: "instance (Monoid a, Monoid b) => Monoid (a,b)" :)
05:13:36 <iLike> There's so many, and some want * -> *, some want *, and others want * -> * -> *
05:13:43 <iLike> Yea, I just saw it :)
05:13:49 <iLike> mconcat seems perfect, thanks :)
05:13:49 <javk> I'd like to start contributing to haskell.
05:13:56 <javk> Would someone please tell me wheer to start?
05:14:06 <merijn> javk: https://gist.github.com/merijn/c01405e6c5a78a1c4ccb :)
05:14:16 <javk> Thanks merijn
05:14:44 <merijn> javk: See also the GHC wiki and Trac at https://ghc.haskell.org/trac/ghc/ the ghc-devs mailing list and #ghc
05:15:18 <merijn> iLike: Oh, yeah, I forgot about mconcat too >.<
05:15:52 <iLike> that's basically foldr mappend mempty?
05:16:08 <iLike> not basically, it actually is :P
05:16:49 <merijn> Yeah
05:17:06 <merijn> iLike: Foldable also has more general versions of this
05:17:13 <merijn> For datatypes other than list
05:17:51 <iLike> that requires the values held in the container to be an instance of monoid as well, correct?
05:19:20 <merijn> The most general one is
05:19:22 <merijn> :t foldMap
05:19:23 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
05:19:34 <merijn> And mconcat is basically
05:19:38 <merijn> :t foldMap id
05:19:39 <lambdabot> (Monoid m, Foldable t) => t m -> m
05:22:11 <iLike> ah, I see. Thanks :)
05:23:31 <iLike> Unrelated question, GHCI just broke when I reinstalled Haskell Platform (on windows 64-bit). It prints error messages with Unicode (I think) characters in them. Is there a ghci option I need to set/unset?
05:23:37 <Denommus> Can lenses be used to change the tree that represents the view in a GUI?
05:39:19 <dramforever> bytestring-0.10.0.2 -> 0.9.2.1,
05:39:22 <dramforever> mtl-2.1.2 -> 2.0.1.1
05:39:26 <dramforever> sorry...
05:40:23 <dramforever> I'm having problems with cabal again. When I cabal install http-proxy it wants to change bytestring from 0.10.0.2 to 0.9.2.1, and change mtl from 2.1.2 to 2.0.1.1
05:41:08 <lpaste> dramforever pasted “cabal install http-proxy” at http://lpaste.net/118922
05:42:11 <dramforever> this time even rm -rf ~/.ghc doesn't help
05:43:07 <merijn> dramforever: http-proxy doesn't work with modern GHC, apparently
05:43:20 <mr-> dramforever: did you 'cabal update'? Have you tried installing in a sandbox?
05:43:54 <dramforever> mr-: maybe global packages are causing this problem
05:43:59 <dramforever> merijn: perhaps
05:44:09 <merijn> GHC releases come with a specific mtl version, the solution is to fix http-proxy to work with newer versions of bytestring and mtl
05:44:32 <merijn> Actually, that's not it
05:44:41 <merijn> http-proxy should work with mtl-2.1.1
05:44:55 <mr-> I just checked its .cabal. http-proxy requires a bytestring < 0.10, apparently.
05:44:56 <merijn> It just doesn't work with newer ByteString
05:45:03 <dramforever> but I installed haskell-platform from yum
05:45:11 <dramforever> so it comes with some packages
05:45:14 <merijn> I dunno where the mtl downgrade comes from
05:45:33 <dramforever> merijn: you saw the full output message?
05:46:09 <mr-> I think I wouldn't want to use http-proxy ;-)
05:46:20 <tdammers> hmm, I wonder... are there any SASS bindings for haskell?
05:46:26 * dramforever keeps finding outdated packages
05:46:26 <merijn> dramforever: GHC itself, even without platform, comes with a set of core libraries (among which mtl)
05:46:35 <dramforever> merijn: okay
05:46:43 <tdammers> or, alternatively, a pure haskell implementation :x
05:46:46 <merijn> dramforever: Look into Stackage?
05:46:50 <dcoutts> dramforever: here's a tip, if you think it ought to work with that bytestring version then ask cabal install to use that version. Then look at the error message when it contradicts you.
05:46:53 <dramforever> merijn: what's that
05:47:01 <dramforever> dcoutts: I don't know
05:47:13 <dcoutts> dramforever: e.g. cabal install http-proxy --constraint='bytestring installed'
05:47:17 <dramforever> I'm not familiar with cabal, just those packages it gets for me
05:47:20 <reem> Is there documentation about how higher kinded types are implemented in GHC/Haskell?
05:47:34 <merijn> dcoutts: regex-posix and regex-base seem to contradict the bytestring version
05:47:36 <dramforever> *I'm only familiar with those packages
05:48:13 <dramforever> @hackage haxy
05:48:13 <lambdabot> http://hackage.haskell.org/package/haxy
05:48:24 <dramforever> merijn: that was updated in Jan 2, 2015
05:48:30 <dramforever> is that what you want me to do?
05:49:03 <dramforever> looks fine
05:50:20 <Dykam> > [0..5]
05:50:22 <lambdabot>  [0,1,2,3,4,5]
05:50:36 <Dykam> > [0...5]
05:50:38 <lambdabot>  Could not deduce (Control.Lens.Plated.Plated c0)
05:50:38 <lambdabot>    arising from the ambiguity check for ‘e_105’
05:50:38 <lambdabot>  from the context (Control.Lens.Plated.Plated c,
05:51:03 <tasker> So I'm looking to parallelise some code that generates IO. I was hoping there were something like parMapM_, but https://stackoverflow.com/questions/2233452/how-can-i-use-parmap-with-a-monadic-function indicates that there is not. Is this still true ?
05:51:05 <dramforever> ouch, http-server failed to install...
05:51:19 <benzrf> auugh
05:51:23 <benzrf> :t (...)
05:51:24 <lambdabot> (Plated c, Applicative f) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
05:51:28 <benzrf> what. whoa
05:52:01 <benzrf> what the heck is this
05:52:03 <Dykam> welp
05:52:06 <Dykam> :t (..)
05:52:07 <lambdabot> parse error on input ‘..’
05:52:13 <dramforever> lens?
05:52:20 <merijn> tasker: Look at the async library
05:52:22 <benzrf> dramforever: i know some lens
05:52:25 <iLike> .. is a language construct afaik
05:52:26 <benzrf> im squinting at the type
05:52:42 <dramforever> Dykam: if you are new to haskell you proabably won't want to do this
05:52:49 <Dykam> lol don't worry
05:52:53 <iLike> syntactic sugar for operations on enums
05:52:53 <dramforever> did you come from ruby?
05:53:14 <dramforever> Dykam: did you come from ruby?
05:53:29 <benzrf> oh i see
05:53:30 <tasker> merijn: That looks perfect. Thanks.
05:53:34 <Dykam> lol don't worry, was just toying with thoughts
05:53:43 <Dykam> coffeescript, which is ruby inspired
05:53:58 <Dykam> where ... is exclusive, yeah
05:54:22 <benzrf> :t (...) `asTypeOf` (.)
05:54:23 <lambdabot> (Plated c, Applicative f) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
05:54:26 <benzrf> o.O
05:54:28 <benzrf> wtf
05:54:57 <iLike> What's ... in coffeescript then?
05:55:04 <dramforever> [1;3C
05:55:09 <breadmonster> iLike: a bunch of macros for JS.
05:55:11 <dramforever> ouch sorry
05:55:14 <clrnd> tasker, I once googled something simillar and ended up copying some ConcurrentT code I found lying around
05:55:17 <breadmonster> Or something similar, they're syntactically equivalent.
05:55:26 <benzrf> iLike: exclusive range
05:55:59 <breadmonster> What exactly is a Lens?
05:56:08 <iLike> [1...4] in coffeescript is [2,3] ?
05:56:45 <benzrf> iLike: [1, 2, 3], i think
05:56:52 <benzrf> i dont recall off the tpo of my head
05:57:17 <benzrf> breadmonster: denotationally, data Lens s t a b = Lens {getter :: s -> a, setter :: s -> b -> t}
05:57:33 <tdammers> [1,2,3] would make sense
05:57:37 <dramforever> benzrf: yes you are right http://coffeescript.org/#try:alert%28%5B1...4%5D%29
05:57:38 <breadmonster> Umm, intuitionistically?
05:57:44 <benzrf> breadmonster: but they might be represented differently from that type, and the package `lens' has about 5000000 other things besides lenses
05:58:22 <clrnd> breadmonster, getters and accessors for complex data structures
05:58:33 <breadmonster> Interesting.
05:58:40 <dramforever> benzrf: but what the hell is the Functor
05:58:48 <tdammers> a lens, in a nutshell, is a two-way 'projection' into a nested data structure, a bit like properties in OOP
05:58:48 <benzrf> dramforever: it's complicated
05:58:49 <dramforever> and Foldable, etc.
05:59:20 <benzrf> breadmonster: what do you mean by "intuitionistically" exactly
05:59:37 <dramforever> there's nothing on lens between "Examples" and "Derivation"
05:59:38 <breadmonster> benzrf: it's a little too abstract, I can't grok the idea.
05:59:38 <benzrf> oh do mean intuitively
05:59:47 <benzrf> k
05:59:49 <breadmonster> benzrf: I apologize, I'm not a native speaker.
05:59:59 <benzrf> breadmonster: it's fine, i probably wouldve understood you in a different context
06:00:10 <benzrf> breadmonster: but "intuitionistically" has a separate meaning in the context of math and comp sci :p
06:00:35 <dramforever> intuitionistic logic?
06:00:38 <benzrf> yeah
06:00:49 <phaazon> hey, is there a way to attach a finalizer to a value without using ForeignPtr?
06:01:05 <benzrf> breadmonster: a "Lens s t a b" is basically a combination of a getter that pulls an `a' out of an `s' and a setter that updates an `s' into a `t' by replacing the `a' with a `b'
06:01:24 <benzrf> breadmonster: so for example, you could have a Lens (a, t) (b, t) a b
06:01:26 <merijn> phaazon: Not very reliably
06:01:36 <dramforever> phaazon: I don't thing you should do that. It breaks referential transparency
06:01:45 <dramforever> :t bracket
06:01:46 <benzrf> breadmonster: which you can use to pull an a out of an (a, t) and update an (a, t) into a (b, t) by giving a b to replace the a
06:01:47 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
06:01:51 <merijn> phaazon: You can attach them to MVars/IORefs, but otherwise not in ways that are very brittle
06:01:56 <dramforever> :t Control.Exception.bracket
06:01:57 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
06:02:05 <phaazon> I know bracket
06:02:17 <dramforever> say...why would you need that
06:02:38 <phaazon> the problem is that I'd like to expose types to the user that are generated via IO
06:02:43 <phaazon> and should be deleted by hand
06:02:46 <phaazon> with a specific function
06:03:49 <dramforever> phaazon: is the value used only in IO?
06:03:50 <breadmonster> How do you guys coe in Haskell, btw?
06:03:56 <breadmonster> Do you use ISEs r what?
06:04:00 <breadmonster> *IDEs
06:04:09 <mpickering> most people use emacs or vim
06:04:10 * merijn uses vim
06:04:20 <breadmonster> What about Leksah?
06:04:28 <merijn> But then I also use vim for 100k LOC C++ codebases, so your mileage may vary
06:04:32 <dramforever> W A R N I N G: possible flame war ahead
06:04:44 <tdammers> I use vim for everything
06:04:53 <merijn> breadmonster: I don't have the impression Leksah or Eclipse FP are used a lot
06:04:54 <tdammers> not because it's perfect, 'cause it's not
06:05:03 <merijn> breadmonster: Some people use them, but mostly it seems
06:05:05 <tdammers> but because it works on, quite literally, *anything*
06:05:21 <tdammers> I am willing to sacrifice quite a bit for that
06:05:27 <merijn> breadmonster: Two thirds use vim/emacs, the other third is split over everything from Eclipse FP, Leksah, Sublime, Notepad++, etc.
06:05:45 <merijn> I'd say, use whatever you're comfortable with
06:05:51 <tdammers> yeah
06:05:57 <merijn> tdammers: Also, because copying environment between machines is easy in vim :)
06:05:58 <breadmonster> merijn: I've primarily used Sublime Text.
06:06:06 <tdammers> if anything, Haskell doesn't *require* an IDE as much as, say, Java
06:06:13 <dramforever> huh?
06:06:17 <merijn> breadmonster: Then I'd just use that, unless you feel really compelled to learn a different editor
06:06:35 <tdammers> dramforever: Java without IDE support can be painful
06:06:37 <merijn> breadmonster: I basically split screen vim and a shell with ghci and use ":l" to load code in GHCI
06:06:41 <dramforever> actually most of my haskell coding is in ghci
06:06:51 <tdammers> huh
06:06:54 <dramforever> *is done in
06:06:54 <kranius> I used vim because I learned it, getting proefficient with *your* editor of choice is a good time investment
06:06:58 <zugz> what's the Correct way to cause cabal to reject certain combinations of flags as unsatisfiable, and have it continue to search for a satisfiable combination? The only way I've found is to put in a dependency on a non-existent package, which is rather an ugly hack!
06:07:51 <tdammers> dramforever: can ghci edit files?
06:08:16 <dramforever> tdammers: no
06:08:30 <dramforever> but to me, haskell is mostly a calculator....
06:08:40 <tdammers> right
06:08:41 <dramforever> power calc
06:08:50 <tdammers> ghci is my power calc, sure
06:08:54 <dramforever> yes
06:08:58 <tdammers> but I also build software in haskell
06:09:08 <tdammers> ghci kind of lacks the ability to persist code for that
06:09:18 <dramforever> I learn haskell for fun, so...
06:09:38 <dramforever> YMMV
06:09:48 <tomphreek> has anyone got haskell autocompletion working in vim?
06:10:40 <breadmonster> Man, I wish they had Haskell for social science majors -.-
06:11:03 <dramforever> why? is that a joke?
06:11:12 <tdammers> tomphreek: I use the same autocompletion for haskell as for everything else
06:11:20 <dcoutts> zugz: there isn't really any sensible way to do that, though as an alternative you can often nest your 'if's
06:11:27 <tomphreek> c-x c-o?
06:11:30 <tdammers> tomphreek: just the normal dumb word completion and tag file
06:11:34 <tdammers> C-n
06:11:42 <kranius> haskellmode-vim
06:11:42 <tdammers> also, hasktags
06:11:43 <dramforever> good ol' tag file
06:11:52 <breadmonster> dramforever: Nope.
06:12:15 <dramforever> okay
06:12:24 <tdammers> I could rig up vim to rebuild the tag file on save, but I've never been annoyed enough to take the 2 minutes that would take me
06:14:35 <zugz> dcoutts: would that help? My case is that I have two flags A and B, each with their own deps, and I want any of the three combinations such that A||B to be allowed, but not (not A && not B)
06:14:53 <breadmonster> dramforever: Haskell is really hard without a lot of CS backing.
06:15:32 <dramforever> breadmonster: it's not very much easier even if you have some backing
06:15:51 <breadmonster> dramforever: Even if you know category theory?
06:16:05 <dramforever> I mean, traditional CS
06:16:07 <kranius> nah you can hack your way into the language
06:16:14 <chpatrick> breadmonster: category theory only helps you at serious business haskell
06:16:57 <chpatrick> I don't think you really need CS for getting started
06:17:31 <chpatrick> you don't really need anything apart from a bit of mathematical thinking
06:17:41 <Taneb> I learnt Haskell before any formal education in CS
06:17:54 <tzaeru> is formal education in CS actually usable for anything at all?
06:17:57 <breadmonster> Hmm, okay.
06:18:08 <breadmonster> chpatrick: Yeah, that's how I've been getting by thus far.
06:18:13 <dcoutts> zugz: mm, yes not so easy to express.
06:18:13 <tzaeru> vast majority of great programmers I know of have not even a BsC
06:18:27 <chpatrick> tzaeru: if you're lucky enough to find something :)
06:18:31 <breadmonster> tzaeru: That's pretty cool.
06:18:44 <chpatrick> 99% of industry is just some kind of plumbing though unfortunately
06:18:54 <dcoutts> zugz: I would like to add more expressive support for this kind of thing, like multi-value flags, or simply allowing "error/fail" for impossible combos
06:19:23 <chpatrick> breadmonster: at my uni haskell was the first thing they teach you, no programming experience required
06:19:41 <tzaeru> in the uni I was in for a short time, it was Java \o/
06:19:43 <tomphreek> chpatrick: what uni is this?
06:19:49 <tzaeru> generally you'd then have C and C++ and that might be it.
06:20:00 <zugz> dcoutts: yes, precisely. "build-depends: Unsatisfiable >= 1337" works as a "fail", but it's not exactly elegant ;)
06:20:00 <chpatrick> tomphreek : imperial college london
06:20:14 <dcoutts> zugz: right right
06:20:16 <tzaeru> functional programming course used Haskell, but it was mandatory for only the other of the two main pre-master's CS routes to take
06:20:19 <tzaeru> and there was just one course.
06:20:25 <chpatrick> the order was haskell, java, x86 assembly, C, C++, prolog
06:20:33 <tomphreek> chpatrick: awesome. hi from ucl
06:20:39 <chpatrick> high five
06:20:43 <tasker> Is there a way to turn a tuple of say 8 elements into 8 curried arguments? E.g. to pass them to a function ?
06:20:48 <breadmonster> chpatrick: Hmm, Imperial is great.
06:20:50 <merijn> breadmonster, chpatrick: As a decent haskell programmer and someone studying Category Theory I'd like to go on record as saying that category theory is ESSENTIALLY useless for programming haskell
06:21:03 <breadmonster> chpatrick: Also expensive :P
06:21:08 <chpatrick> merijn: what if you're ekmett?
06:21:11 <breadmonster> merijn: Hmm, fair enough.
06:21:12 <chpatrick> breadmonster: it is now :(
06:21:15 <chpatrick> I've graduated though
06:21:16 <merijn> Really, the bits that are relevant are easily learned and don't resemble CT
06:21:20 <chpatrick> now I'm doing my exciting java day job
06:21:34 <breadmonster> merijn: Except to do something really worthwhile, you have to be a PhD.
06:21:34 <benzrf> breadmonster, chpatrick: for the record, knowing some CT helps unify concepts in haskell :)
06:21:37 <vanila> tasker, you would have to write a function that takes the tuple and function and applies it
06:21:40 <merijn> chpatrick: He's an android master hacker, not many people get that far :p
06:21:47 <benzrf> breadmonster, chpatrick: even if it doesnt necessarily make you a better programmer
06:21:48 <zugz> knowing some haskell is occasionally useful for building intuition in category theory, though
06:22:00 <benzrf> zugz++
06:22:02 <merijn> breadmonster: I'm not a phd and I manage fine so far? :)
06:22:13 <breadmonster> Fair enough.
06:22:17 <chpatrick> same
06:22:18 <benzrf> haskell is a GREAT language for expressing terms and stuff
06:22:21 <tasker> vanila: This is what I assumed, justh oped there were a shorter way :p
06:22:25 <tzaeru> as someone with virtually no math background, a poor memory and basically no motivation to learn any formal match concepts, I find Haskell quite difficult. though I suspect it's more about syntacical semantics that I am not used to.
06:22:36 <chpatrick> I think haskell's difficulty is really exaggerated
06:22:42 <chpatrick> it's just different from the imperative stuff people are used to
06:22:43 <merijn> breadmonster, chpatrick: The far more useful things to learn for Haskell (and in general programming!) is lambda calculus, type theory and algebra
06:22:57 <merijn> But I would argue those are good for programming in "not-haskell" too
06:23:08 <chpatrick> I got lucky because we had a super charismatic professor
06:23:17 <breadmonster> merijn: Algebra?
06:23:17 <chpatrick> and I got some functional intuition from C# before
06:23:20 <merijn> tzaeru: In my experience haskell is wildly different from other languages, which is the biggest obstacle
06:23:25 <merijn> breadmonster: Monoids everywhere!
06:23:30 <merijn> <3 monoids
06:23:31 <breadmonster> merijn: Like Artin's or Lang's books?
06:23:31 <tzaeru> chpatrick, the big difference really is that the major imperative languages map quite easily to how (a standard, regular, single-core) computer computes stuff :P
06:23:39 <tzaeru> haskell does not map easily to how computers actually work.
06:23:47 <chpatrick> tzaeru: who cares though
06:23:59 <merijn> tzaeru: Actually, it's not that hard to understand how that maps either
06:24:00 <chpatrick> PHP is still pretty abstracted from the metal
06:24:01 <tzaeru> because it's practical and relatively easy for human mind to map to?
06:24:11 <chpatrick> I don't know about that
06:24:21 <tzaeru> well, of course that depends on human in question
06:24:21 <vanila> chpatrick,  its important to understand how your program related to its execution
06:24:22 <chpatrick> I mean I'm not saying imperative isn't necessarily easier
06:24:27 <merijn> tzaeru: There's a great paper describing a "minimal, lazy, functional language" (STG) and how to compile it to C/ASM
06:24:29 <chpatrick> but I don't think it's because it's of how the computer works
06:24:38 <chpatrick> there's a huge amount of abstraction everywhere unless you're using C or asm
06:24:52 <hodapp> tzaeru: A standard, regular, single-core computer without any sort of pipelining, virtual memory, speculative execution, or operating system.
06:24:55 <merijn> tzaeru: It's certainly worth looking at for curiosities' sake although it may not help all that much for writing haskell
06:24:57 <chpatrick> I think it's just because they teach people programming in this algorithm/recipe-oriented way
06:25:05 <tdammers> hodapp: a PDP-11?
06:25:08 <chpatrick> instead of a this-is-what-this-means functional way
06:25:22 <merijn> tzaeru: Also, as someone who spent the summer doing HPC, it's nearly impossible to understand how C maps to how computers actually compute stuff :)
06:25:26 <tomphreek> coming fomr the other side: I actually studied maths at uni. Picking up basics cat theory was easy given that I took a few abstract algebra courses. The analogies between monads and cat theory helped me understand what monads are all about. However, I am not an experienced haskell programmer, so not sure it actually helps with practicing it.
06:25:27 <tzaeru> IMO that approach is immensively confusing when stuff happens to not work as you expected.
06:25:39 <tzaeru> imperative approach is very easy to reason with. you can take individual, tiny parts, and reason about them.
06:25:55 <hodapp> tzaeru: Yes, except for when you can't.
06:25:58 <chpatrick> tzaeru: I find that very true about functional
06:26:03 <chpatrick> except performance :P
06:26:12 <merijn> tzaeru: I would argue that reasoning about imperative code is really hard, because you can't reason about parts in seperation
06:26:34 <tzaeru> yes you can. you can very easily.
06:26:37 <merijn> There's a good free book on doing proofs/reasoning about programs now :)
06:26:44 <breadmonster> merijn: I'd argue that reasoning about performance in Haskell is a real skill.
06:26:48 <merijn> Which will also prove how hard it is to do in imperative languages
06:26:55 <breadmonster> Are you talking about Software Foundations?
06:26:56 <kranius> what would that book be ?
06:27:02 <merijn> breadmonster: Understanding how laziness/STG works is good start
06:27:04 <merijn> breadmonster: Yup
06:27:08 <merijn> @where sf
06:27:08 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
06:27:08 <lambdabot> assistant."
06:27:11 <merijn> kranius: That one
06:27:16 <chpatrick> tzaeru: with functional stuff you have a bunch of functions that only have access to their inputs instead of this big implicit state
06:27:28 <chpatrick> I think that's a lot easier to reason about
06:27:44 <dramforever> yep
06:27:47 <merijn> kranius: It starts with teaching Coq and how to do proofs for pure functions and then moves up to modeling imperative languages, etc.
06:28:05 <merijn> kranius: It's pretty neat! Coq proofs make a decent puzzle game too :p
06:28:05 <hodapp> tzaeru: There is a reason that most formal analysis, faced with imperative code, usually just ends up doing some kind of half-assed conversion to another, less imperative form.
06:28:06 <tzaeru> chpatrick, mh, dunno.
06:28:14 <tzaeru> surely it depends on the person in the end, whichever the average is.
06:28:15 * dramforever feels superior when he sees the phase "loop invariant"
06:28:30 <chpatrick> tzaeru: if you're doing formal reasoning it's way nicer to do it on pure functional stuff than anything imperative
06:28:35 <chpatrick> tzaeru: invariants are a pain in the ass
06:28:36 <dramforever> that thing is all about finding things that don't change
06:28:49 <dramforever> then why not get rid of them?
06:28:54 <tzaeru> hodapp, there's also a reason why Haskell is used as "production infrastructure aid" and "analysis tool" instead of "browser" or "game" or whatever :P
06:28:58 <hodapp> tzaeru: Yes, except that it *doesn't* depend on the person.
06:29:13 <tzaeru> well, whatever. I rest my case.
06:29:29 <cojy> merijn: but haskell code is riddled with side effects that make it impossible to reason about what's happening to memory because of laziness....
06:29:30 <dramforever> actually, I think haskell is better-adapted than scheme. I might be wrong
06:29:45 <merijn> tzaeru: Hey, Cale worked on an iOS game written in Haskell. They ran out of funding, but I heard the engine worked well
06:29:51 <merijn> cojy: Which side effects is it littered with?
06:29:57 <kranius> merijn: thanks
06:30:03 <dramforever> merijn: allocation
06:30:22 <merijn> dramforever: No, that's not how abstraction works
06:30:25 <hodapp> tzaeru: I'm sure that reason has nothing whatsoever to do with existing popularity, advertising budgets, and history.
06:30:44 <merijn> dramforever: Allocation doesn't effect the correctness of haskell code at all
06:30:47 <tzaeru> merijn, well, I did see an article about optimizing an iOS game written in Haskell
06:30:48 <dramforever> merijn: no, that *is* how reasoning about memory works
06:30:54 <dramforever> *memory*
06:30:58 <tdammers> tzaeru: the reason why Haskell isn't used for browsers or games is because those require a rather massive body of libraries from areas that Haskell isn't traditionally great in
06:31:05 <merijn> Also, there's a blog series about writing a browser in haskell
06:31:05 <Dev-Cod> is good this game ? http://www.desura.com/games/triblaster
06:31:06 <tzaeru> it was your standard Arkanoid. and ran on 5 FPS before optimization, which would be rather a feat to achieve if  you were writing it in Bash.
06:31:14 <tdammers> but that's more for political and environmental reasons than general suitability of the language itself
06:31:24 <merijn> tzaeru: No, Cale's company was working on a platforming hack n' slash, I thought
06:31:34 <merijn> But you'd have to ask him for details
06:31:37 <phaazon> dramforever: yes
06:31:38 <cojy> and then of course there is lazy IO too
06:31:40 <dramforever> actually, it may turn out that the arrows, continuation, etc. works better
06:31:41 <tzaeru> merijn, myeah, a different game I suppose ^^
06:31:42 <phaazon> the value is used in IO
06:31:50 <phaazon> and pass around to IO functions
06:31:55 <Dev-Cod> hey guys
06:32:11 <merijn> cojy: Lazy IO is a bit ugly, but also out of fashion nowadays
06:32:16 <chpatrick> tzaeru: I thought the arkanoid thing was pretty funny too
06:32:29 <dramforever> we use conduits
06:32:37 <chpatrick> look! we can do 1993 gaming that runs at 5 fps with parallelization
06:32:39 <Dev-Cod> hey guys -
06:32:45 <dramforever> that's also what http-proxy works
06:32:50 <chpatrick> hey
06:32:53 <kranius> so many books and papers... very little time :(
06:32:54 <dramforever> Dev-Cod: yes, we are listening
06:32:56 <merijn> pipes/conduits/iteratees/io-streams, etc.
06:32:59 <merijn> kranius: Word :)
06:33:01 <dramforever> just talking at the same time
06:33:03 <Dev-Cod> is good this game ? http://www.desura.com/games/triblaster
06:33:06 <tdammers> basically, if you want to build a browser, C++ offers better shoulders to stand on than Haskell atm, and that advantage usually beats the superiority of the language itself
06:33:18 <tzaeru> chpatrick, the parallelization part really cracked it for me D:
06:34:05 <tzaeru> I mean seriously, parallelizing Arkanoid clone because it didn't run fast enough on modern mobile phone that has many thousands of times of more processing power than the computer the original game was made for..
06:34:18 <tzaeru> as a game programmer, that blows my mind.
06:34:40 <vanila> tzaeru, hwat language was that in?
06:34:42 <tzaeru> Haskell
06:34:44 <kranius> merijn: word, as in, the m$ software ?
06:34:46 <vanila> damn
06:34:54 <vanila> lasttime I said haskell was slow in here all the trolls jumped on me
06:35:13 <merijn> kranius: As in, colloquial agreement :p
06:35:14 <vanila> but i think i was right
06:35:21 <tzaeru> I've never really had an issue with performance because my code didn't run lazily..
06:35:22 <dramforever> vanila: don't be that general
06:35:26 <tzaeru> actually it's rather the opposite.
06:35:47 <dramforever> if I say C is fast you could object too
06:35:52 <chpatrick> I don't think their problem was lack of parallelization
06:35:56 <chpatrick> they had something seriously wrong
06:36:00 <tzaeru> they did.
06:36:00 <chpatrick> or maybe FRP is really slow
06:36:09 <tdammers> haskell isn't slow in general, but there are some performance pitfalls that may not be obvious to the uninitiated
06:36:10 <tzaeru> and I'm sure it's not inheretently Haskell's fault
06:36:16 <merijn> tzaeru: I wouldn't say haskell is a great fit for "real-time" games, but also realise that many "game" programmers in haskell have never written games at all or have very good haskell skills
06:36:17 <tzaeru> but I do wonder why they didn't realize to just keep quiet about their abyssmal framerate.
06:36:19 <kranius> merijn: lol sorry, that confused me
06:36:24 <chpatrick> some stuff is really stupid though
06:36:33 <chpatrick> I made an emulator in haskell once and it was slow for no reason
06:36:37 <chpatrick> profiling didn't reveal anything
06:36:48 <chpatrick> took MonadRandom out of my transformer stack and FPS went up 10x
06:36:54 <chpatrick> it is a mystery~
06:37:18 <dramforever> I heard that mtl doesn't inline well
06:37:38 <vanila> there can be eficiency problems with tall monad stacks
06:37:53 <merijn> tzaeru: People are writing streaming data processing stuff in Haskell with innerloops that are measured in nanoseconds, but not a lot of performance people are looking at game programming in haskell
06:38:03 <chpatrick> I still don't get why though
06:38:05 <chpatrick> it's all newtypes
06:38:10 <dramforever> chpatrick: the @unmtl command could be your friend
06:38:11 <tdammers> well, one of those performance pitfalls is that abstractions are free in haskell, except when they aren't, and it's not usually trivial to tell the difference
06:38:11 <vanila> it's not just newtypes
06:38:26 <merijn> tzaeru: So most FRP libraries aren't optimised for that and the people using those FRP libraries end up writing "naive" code filled with accidental Schlemiel the Painter algorithms
06:38:30 <dramforever> chpatrick: it's not easy to know how they work together as a whole
06:38:43 <vanila> each monad is a level of indirection you ahve to lift things through
06:38:44 * hodapp . o O (Schlemiel the Painter?)
06:39:14 <chpatrick> vanila: sure but StateT is just s -> m ( a, s )
06:39:26 <tdammers> hodapp: https://en.wikipedia.org/wiki/Schlemiel_the_painter%27s_Algorithm
06:39:27 <merijn> hodapp: http://www.joelonsoftware.com/articles/fog0000000319.html
06:39:29 <chpatrick> vanila: why is it faster if you unroll the monad instance?
06:39:31 <dramforever> chpatrick: what do you have?
06:39:34 <tzaeru> merijn, yeah, I can understand that.
06:39:36 <chpatrick> vanila: can't the compiler do that?
06:39:42 <tzaeru> I don't exactly blame Haskell for those guys' perf issues.
06:40:08 <tzaeru> obviously they were doing something seriously wrong. even if you did a completely non-hardware accelerated, naive draw loops individually for every block of Arkanoid, you'd probably-.. okay, then you might have 5 FPS
06:40:12 <chpatrick> dramforever: back then I had RandT StateT IO and RandT made it incredibly slow, so I just put the generator state in my state and then it was fast
06:40:38 <dramforever> chpatrick: I think that means RandT is slow
06:40:42 <chpatrick> yeah :)
06:41:17 <chpatrick> but besides that I'm not sure what's up with people saying transformer stacks are slow
06:41:23 <chpatrick> if they are, why?
06:42:04 <merijn> tzaeru: The thing that attracts me to haskell is the ability to have nice high level abstractions that can still be optimised to good performance, like attoparsec, for example
06:42:40 <chpatrick> dramforever: I mean the usual advice I've seen is to unpack the newtypes and inline the monad instances, but I don't see why the compiler can't do that
06:42:53 <dramforever> chpatrick: I can't see either
06:43:16 <dramforever> Why can't C compilers do tail-calls?
06:43:27 * hackagebot record 0.1.4 - First class records implemented with quasi-quotation  http://hackage.haskell.org/package/record-0.1.4 (NikitaVolkov)
06:44:21 <merijn> dramforever: They can and do
06:44:35 <merijn> dramforever: http://ridiculousfish.com/blog/posts/will-it-optimize.html
06:44:59 <dramforever> merijn: that's gcc
06:45:16 <tdammers> chpatrick: I think it could do that, but it would require full-program optimization
06:45:31 <dramforever> some compilers don't
06:45:37 <merijn> dramforever: You asked "why can't C compilers do tail-calls" and I answer that they can by showing you they do
06:45:51 <tdammers> otherwise, because instances are open, the compiler can only optimize tothe point where it would break as-of-yet unknown instances
06:45:52 <merijn> All the compilers anyone cares about (gcc, clang, icc and suncc) do
06:45:54 <kranius> then your question is "why they don't"
06:46:00 <dramforever> okay
06:46:24 <chpatrick> tdammers: can't GHC just inline when it derives a monad instance for a stack?
06:47:04 <tdammers> chpatrick: not sure about the details - I guess it depends on the individual transformers and how (if) un-stacking the stack would change type constraints and such
06:48:10 <tdammers> my gut feeling says that it depends on whether the compiler has enough information at hand to determine whether a certain optimization would impact overall semantics or not
06:48:57 <arjanb> imho the techniques of optimizing pure functional language are still quite basic, and lots of research is still to be done to make stacking abstractions cost free
06:51:30 <merijn> arjanb: Well, besides all those billion techniques we already have that require complex analysis in imperative languages, you mean? :p
06:53:28 * hackagebot grid 7.6.8 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.6.8 (AmyDeBuitleir)
06:54:47 <tzaeru> merijn, I was purely attracted by the curiousity of languages that focus strictly on non-conventional paradigms and approaches D:
06:55:04 <tzaeru> I still haven't quite found a tutorial I'd bother to go through though
06:55:22 * dramforever is the same
06:56:23 <kranius> is it because you can't find a tutorial that fits you ?
06:56:50 <phaazon> holy hell
06:57:02 <phaazon> I've just understood the use for MonadResource
06:57:07 <phaazon> I actually **need** that!
06:57:19 <phaazon> it will let me decharge the GC
06:57:31 <tzaeru> kranius, ayep.
06:57:54 <dramforever> phaazon: I'm interested. which package is that in?
06:58:51 <phaazon> dramforever: it's in conduit
06:58:58 <phaazon> and in resource-simple, but not up to date
06:59:06 <dramforever> okay
06:59:09 <phaazon> I think I could be maintainer
06:59:13 <phaazon> I love maintaining.
06:59:33 <kranius> what are the main differences between conduit and pipes ?
06:59:43 <kranius> noob question
06:59:44 <phaazon> no idea
06:59:47 <phaazon> I just know pipes
06:59:50 <merijn> kranius: Almost nothing
07:00:10 <merijn> pipes and conduits are so interchangeable Snoyman and Tekmo are working on a library that allows you to connect them
07:00:31 <merijn> They have some conceptual disagreements on how early termination should be treated
07:00:55 <merijn> Also, pipes errs a little more to "conceptually beautiful" and conduit a little more to "sacrifices for pragmatism"
07:01:07 <phaazon> god
07:01:08 <dramforever> conduit is more real-world
07:01:20 <phaazon> it's a whole mess on hackagedb about resource
07:01:32 <kranius> hackage is a mess :p
07:01:38 <phaazon> I think I just should upload a package « resource » that only maps the semantics of _resources_
07:01:38 <merijn> dramforever: I disagree, I prefer pipes, it's just trickier to understand how pipes-parse works, but that's not a big deal
07:01:54 <dramforever> merijn: I didn't say I prefer one
07:02:14 <phaazon> I like the resource-simple package
07:02:21 <phaazon> I think I'll contribute
07:02:25 <kranius> stream processing is what motivates me to learm haskell
07:02:37 <phaazon> how could I be the maintainer?
07:02:43 <phaazon> the package seems to be abandonned :(
07:04:00 <chpatrick> phaazon: what's wrong with regular resourcet?
07:04:26 <hodapp> oh, maybe Shake is called Shake because Hake was already taken
07:04:28 <merijn> phaazon: Email maintainer and CC the hackage admins, if there is no response (or on "ok" response) the hackage admins can make you maintainer
07:05:02 <merijn> hodapp: It's called Shake because they use an internal tool called Bake for either testing/freezing dependencies or whatever it was
07:05:06 <phaazon> thanks
07:05:10 <merijn> hodapp: So they get a nice "Shake and Bake" pun :p
07:06:01 <hodapp> merijn: Oh. Pffffffft.
07:06:21 * hodapp goes back to poking his .cabal file with a stick
07:08:28 * hackagebot grid 7.6.9 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.6.9 (AmyDeBuitleir)
07:08:56 <phaazon> yeah
07:09:03 <phaazon> resourcet seems to be good as well
07:09:32 <phaazon> (the name is pretty bad though :D )
07:10:24 <phaazon> though
07:10:31 <phaazon> I don't like the MonadThrow introduced
07:10:36 <phaazon> I'd rather like MonadError
07:10:52 <ryantm> Is there currently a way to have both ghc and ghcjs builds in the same .cabal file?
07:11:08 <phaazon> MonadThrow seems not to expose a catch though
07:11:41 <ryantm> I was looking at https://hackage.haskell.org/package/ghcjs-dom-hello-1.2.0.0/ghcjs-dom-hello.cabal and I don't see anything in the .cabal file that indicates that the ghcjs compiler should be used.
07:12:39 <osa1> do we have a updated and complete version of this http://packdeps.haskellers.com/reverse ?
07:13:08 <bennofs> ryantm: that's because cabal files should be independent of the compiler used.
07:13:39 <chpatrick> phaazon: resourcet is what conduit-extra uses
07:13:41 <bennofs> ryantm: for example, ghcjs-dom can be compiled by GHC and by ghcjs
07:13:50 <phaazon> sounds good
07:14:20 <phaazon> omg
07:14:23 <phaazon> the ReleaseMap
07:14:32 <phaazon> is it efficient yet?
07:14:33 <ryantm> bennofs: Ok, how do I control what compiler `cabal build` uses?
07:14:39 <phaazon> it looks like a simple linked list
07:15:33 <ryantm> bennofs: Or, what do I use instead of that...
07:20:24 <tasker> merijn: Do you have any idea how much overhead is introduced by mapConcurrently in Control.Concurrent.Async ?
07:26:10 <nkar> how can I check whether a Double can be safely converted to Int64?  e.g., 3.0 is okay while 3.2 is not.
07:27:31 <merijn> tzaeru: Low
07:27:36 <kranius> take the integer part
07:27:41 <merijn> s/tzaeru/tasker
07:27:49 <merijn> tzaeru: microseconds?
07:27:53 <merijn> argh
07:27:59 <merijn> tab complete is failing me
07:28:40 <merijn> kranius: check whether "round -> fromIntegral == original"?
07:28:56 <merijn> > fromIntegral (round 3.2) == 3.2
07:28:57 <lambdabot>  False
07:29:02 <merijn> > fromIntegral (round 3.0) == 3.0
07:29:03 <lambdabot>  True
07:29:26 <merijn> Although that doesn't prevent under/overflow
07:31:08 <triptec> how do I fix this? Couldn't match expected type ‘GHC.Int.Int64’ with actual type ‘Int’
07:32:30 <kranius> merijn: hmm
07:32:34 <triptec> this is the line I use to get the Int: (uid :: Int) <- param "id", should I change it or should I cast it before using it where it should be a int64
07:32:36 <merijn> Those two are not the same type, so convert one to the other?
07:32:52 <triptec> merijn: how would I do that?
07:33:07 <merijn> fromIntegral, or just don't use Int to begin with?
07:33:26 <tzaeru> merijn, :P
07:35:41 <nkar> merijn: but isn't comparing doubles a bad idea?
07:37:42 <merijn> It depends, in this case no
07:38:16 <merijn> Because he wants to find if a double is exactly an integer
07:38:30 <merijn> Comparing doubles is only "bad", because usually that's not what you want at all
07:39:35 <SolitaryCipher> Hey, are there any (largish) open source projects in haskell, other than xmonad?
07:39:51 <nkar> lens?
07:40:32 <SolitaryCipher> nkar: this? https://github.com/ekmett/lens
07:40:45 <glguy>  Pandoc? Darcs though it's not as active
07:40:49 <merijn> SolitaryCipher: Pandoc and ghc?
07:40:59 <merijn> haxl (facebook's data language stuff)
07:41:23 <SolitaryCipher> Thanks!
07:41:29 <hodapp> Facebook seems to love OCaml.
07:41:32 <merijn> lpaste and ircbrowse are written in haskell too
07:41:48 <merijn> (lpaste.net and ircbrowse.net)
07:41:57 <nkar> SolitaryCipher: ah, you're asking about applications.  the ermine language maybe?
07:41:58 <kranius> ocaml is a pretty neat language
07:42:03 <nkar> idris, agda
07:42:10 <tdammers> actually, most of haskell's toolchain is written in haskell AFAIK
07:42:41 <merijn> That too, of course
07:42:47 <SolitaryCipher> nkar: I am looking for stuff I can contribute to. Just so I can practice haskell
07:42:49 <merijn> Isn't git-annex haskell too?
07:42:52 <kranius> yesod maybe ?
07:43:01 <merijn> SolitaryCipher: GHC is always looking for more contributors! ;)
07:43:31 <merijn> GHC doesn't use a lot of complex libraries like lens, so it's actually one of the more understandable codebases for beginners
07:43:39 <kranius> really
07:43:54 <merijn> Pandoc is very hackable if you restrict yourself to working on a single reader/writer at a time
07:44:01 <koomi> merijn: yes (re. git-annex)
07:44:02 <kranius> I kinda want to help but hacking ghc feels complex, given I've never tried
07:44:24 <merijn> kranius: https://gist.github.com/merijn/c01405e6c5a78a1c4ccb ;)
07:44:36 <nkar> merijn: ah, right.  comparing floats is only bad if you're comparing expressions.  since floating point operations are not always associative or distributive
07:44:55 <merijn> kranius: It depends, there's lots of small fixes/debugging work to do too
07:44:56 <SolitaryCipher> I feel like I could read SICP and do the exercises in LISP
07:45:00 <SolitaryCipher> I feel like I could read SICP and do the exercises in haskell*
07:45:17 <merijn> kranius: If you know C, the RTS is written in C for large parts, so that's an avenue too
07:45:22 <SolitaryCipher> ^ and then I would have a decent idea about how compiler design works
07:45:45 <merijn> kranius: Alternatively, start reviewing patches on phabricator and fixing typos in comments, etc.
07:46:24 <merijn> SolitaryCipher: There's "Write Yourself a Scheme in 48 Hours" which talks about implementing a Scheme in haskell
07:46:53 <nkar> kranius: there's been a call for volunteers to help implementing the recent record proposal, for instance
07:46:59 <merijn> SolitaryCipher: See also: http://www.stephendiehl.com/llvm/ and http://dev.stephendiehl.com/fun/
07:47:17 <merijn> nkar: That might be a bit ambitious as a starting point ;)
07:47:29 <merijn> Oh, and extra cabal contributors are always welcome :)
07:47:42 <nkar> and it's not even set in stone
07:48:18 <kranius> merijn: thx for the link and tips. I know quite some C but I'm only an advanced noob in Haskell
07:48:31 <kranius> is there a tool to eplore pakage hierarchy ?
07:48:56 <kranius> explore*
07:49:35 <koomi> most of the core infrastructure projects always welcome more contributers
07:49:49 <koomi> e.g. haddock
07:50:05 <merijn> kranius: The wiki has a LOT of design and explanation links
07:50:35 <merijn> kranius: Some of the GHC bits are certainly complex, but being all in haskell it's very easy to trace where state is coming from/going to in my experience
07:51:00 <merijn> kranius: So it's easier to work on separate bits without needing to understand what the rest of the ominuous ball of code is doing :)
07:51:24 <merijn> I think trac also has a bunch of "beginner" tickets
07:51:46 <kranius> yeah that's true :)
07:52:19 <merijn> Anyway, pandoc is one of the easier things I've contributed stuff too, modifying the rST parser was pretty easy :)
07:52:32 <merijn> Still have no clue how pandoc works, but who cares ;)
07:55:36 <kranius> is there a tool to explore package hierarchy ?
07:55:52 <kranius> hackage only sorts by category afaik
07:56:19 <kranius> can cabal do that ?
07:56:30 <merijn> I don't really know, tbh
07:57:05 <funfunctor> hi
07:57:08 <hiptobecubic> hierarchy meaning?
07:57:10 <hiptobecubic> reverse depends?
07:57:18 <funfunctor> does anyone have much experience in dealing with bindings-dsl for writing bindings?
07:58:04 <grohne> is there a sub class of MonadTrans with a method (m a -> n b) -> t m a -> t n b? (example instance: mapReaderT)
07:58:14 <tdammers> merijn: pandoc isn't magic at all
07:58:15 <kranius> no hierarchy as in "Module.Name.Foo.Bar", and explore everything interactivlt
07:58:46 <tdammers> merijn: some of the parsers are a bit crazy, what with all the contextual newline handling stuff and all that, but the overall architecture is pretty straightforward
07:59:39 <funfunctor> I'm a little stuck here http://pastebin.com/U0CckNxn  on line 66
07:59:57 <merijn> grohne: You want mmorphc
08:00:03 <merijn> grohne: eh mmorph
08:00:16 <merijn> @hackage mmorph
08:00:17 <lambdabot> http://hackage.haskell.org/package/mmorph
08:00:34 <merijn> hoist, to be exact
08:00:44 <_1_Iftikhar> hello
08:00:52 <grohne> merijn: thanks.
08:01:03 <_1_Iftikhar> hi grohne
08:01:39 <_1_Iftikhar> any body want chat
08:02:43 <grohne> merijn: it's slightly more specific than mapReaderT in that it forces a = b. is it unreasonable to assume distinct a and b (like mapReaderT does)?
08:06:43 <merijn> grohne: Ah, I missed that part
08:07:33 <grohne> merijn: my preferred application would be m = Either String and b = Either String a by passing return
08:07:50 <merijn> grohne: mmorph stands for monad morphism and hoist is guaranteed to preserve the monad laws, having a less flexible type I don't think preserving the laws is guaramteed
08:09:35 <grohne> (not sure whether that is reasonable, but it seems that I only need this for ReaderT
08:10:04 <merijn> grohne: What's the full type you're looking for?
08:10:32 <grohne> merijn: the actual problem is http://stackoverflow.com/q/28068091/3168666
08:11:15 <merijn> MonadError is from?
08:11:26 <grohne> merijn: mtl
08:11:38 <merijn> I mostly prefer to just use edwardk's exceptions for dealing with exceptions in monad stacks
08:11:51 <merijn> Or is this just for either?
08:12:06 <grohne> heh. people keep telling me that MonadError is bad, but this is an existing code base
08:12:42 <merijn> I think mtl is bad in general >.> (well, not entirely, but I always prefer concrete transformer stacks over these typeclasses)
08:13:13 <grohne> so at the moment the code is literally litered with MonadError instance requirements
08:13:30 <grohne> I was hoping that I could get rid of some of them by using the mentioned safeCatchError
08:14:02 <osa1> any ideas how to use Criterion's --match MATCH parameter?
08:14:31 <merijn> grohne: I don't think that's reasonably doable without a concrete transformer stack
08:15:12 <osa1> does it have a regexp matcher?
08:15:33 <grohne> merijn: oh you can have the full source. http://www.iai.uni-bonn.de/~grohne/darcs/igor2/ I have to say though that 1) I don't understand the transformer stack and 2) some transformers occur twice
08:16:23 <merijn> grohne: Oh, it's a standalone executable?
08:16:32 <grohne> merijn: it is.
08:16:55 <grohne> merijn: the purpose of the tool is to generate haskell functions from input/output examples in haskell notation.
08:17:12 <merijn> Then it should just be possible to replace the mtl classes with a concrete stack without too much problems, no? But I'd have to look into that closer than I have time for now :)
08:17:36 <grohne> merijn: it should, yes, but I lack the experience required for doing that.
08:22:47 <ryantm> I posted the question I asked earlier on Stack Overflow http://stackoverflow.com/questions/28071045/how-to-use-two-different-compilers-for-different-targets-in-a-cabal-file
08:25:22 <breadmonster> http://lpaste.net/118946
08:25:25 <breadmonster> Can someone help me out?
08:25:26 <merijn> ryantm: "cabal install --help" shows to specify the compiler using a flag, although the one on my system doesn't seem to support ghcjs?
08:25:50 <merijn> Or maybe "--with-compiler="
08:26:28 <breadmonster> merijn: I can't get ghci to infer the return type of a Parsec parser
08:26:28 <Lindrian> Is there something similar to supervisors in erlang in haskell?
08:26:48 <merijn> breadmonster: ghci doesn't like polymorphic definitions and since you have no type specification for 'p' it doesn't know which type to select
08:27:11 <breadmonster> merijn: Yeah, how do I specify identity?
08:27:17 <breadmonster> For the underlying monad?
08:27:30 <merijn> Lindrian: Not built in, but you can build it yourself using async exceptions, it's a bit of a hassle, though. Also take a look at the async library which partially does this
08:27:47 <merijn> Lindrian: Also: http://chimera.labs.oreilly.com/books/1230000000929
08:27:50 <ajcoppa> Lindrian: make it through your exam okay?
08:28:05 <Lindrian> ajcoppa: I hope so, no results posted yet. Felt solid though.
08:28:08 <merijn> breadmonster: That requires multiline syntax in ghci which I never use so I don't know :)
08:28:11 <Lindrian> ajcoppa: Lots of tricky/nasty questions
08:29:06 <ajcoppa> well, regardless of the exam outcome, you put a lot of effort into going deeper than the course material, and i think your knowledge reflects that
08:29:17 <ajcoppa> IMO don't stop just because you took the exam already :)
08:29:36 <Lindrian> Heh
08:29:41 <Lindrian> I'll find a neat project to do in Haskell
08:29:53 <ajcoppa> NICTA in particular is awesome, i recommend spending some time with it
08:31:13 <FCatalan> I have to pick up NICTA again. Best game I played last year :)
08:31:33 <mmachenry> Lindrian: Do you want to write a distributed phone dialing system? (my boss would appreciate it)
08:31:34 <mmachenry> ;)
08:31:51 <Lindrian> pay me lots and lots of monies and ill do it
08:32:03 <mmachenry> That's an option, actually.
08:32:49 <Lindrian> Does your boss want it in Haskell?
08:33:32 <FCatalan> because that project screams Erlang!
08:34:32 <sgronblo> so could someone explain how to limit the value of an int to a range with quickcheck?
08:34:35 <mmachenry> Lindrian: Yeah, it does scream Erlang. Erlang was my second recommendation when proposing a language for writing the project.
08:34:46 <mmachenry> I wanted to use STM for this, however, and I know Haskell a lot better.
08:35:12 <sgronblo> do i have to create a specific empty data type with hard coded max and min values in the arbitrary instance?
08:35:42 <mmachenry> And no, he didn't want it in Haskell, necessarily. And it wasn't just him deciding, but many of us. I was the only proponent for anything outside of the mainstream but I was able to make some good arguments and we're doing in in Haskell.
08:36:07 <mmachenry> I would have loved to, if I had time, implement this in both Erlang and Haskell.
08:36:12 <osa1> I'd be great to have a substring matcher in criterion
08:36:28 <osa1> like hspec
08:36:35 <mmachenry> I'm planning on dual implementing a smaller, personal project in Haskell and Erlang instead though.
08:36:52 <Lindrian> Interesting mmachenry
08:37:01 <Lindrian> I'm by no means a pro at Haskell, fyi.
08:37:23 <mmachenry> Eh, most of us aren't.
08:37:47 <mmachenry> Though I guess since I'm doing it professionally now, I technically am.
08:37:48 <Lindrian> Great haha
08:38:31 <mmachenry> I'm looking forward to ekmett's talk tonight at Boston Haskell meetup. Anyone going to be there?
08:38:41 <mmachenry> Speaking of actual Haskell pros.
08:39:27 <breadmonster> Are there FP meet ups in India?
08:39:28 <breadmonster> Argh.
08:39:31 <Lindrian> I'm going to listen to Peter Sunde tonight
08:40:49 <vin-ivar> breadmonster: I believe there was an Erlang meet up last year in my city
08:40:54 <vin-ivar> that's about it, though :(
08:41:03 <breadmonster> vin-ivar: What city is that?
08:41:06 <vin-ivar> Pune
08:41:37 <breadmonster> vin-ivar: Oh cool, okay.
08:42:28 <vin-ivar> what about yourself? Bangalore, I'm guessing?
08:46:08 <breadmonster> vin-ivar: Surprisingly, no :P
08:46:19 <breadmonster> vin-ivar: I'm at St. Stephen's in Delhi
08:58:27 <sleepomeno>  how can I make a "MaybeT (StateT x (Either String IO)) y" from a "StateT x (EitherT String IO) (Maybe y)"?
09:08:14 <merijn> :t MaybeT
09:08:15 <lambdabot> Not in scope: data constructor ‘MaybeT’
09:08:34 * hackagebot aws-kinesis-client 0.2.0.1 - A producer & consumer client library for AWS Kinesis  http://hackage.haskell.org/package/aws-kinesis-client-0.2.0.1 (JonSterling)
09:10:45 <glguy> sleepynate: The type you requested has a kind error, did you mean that you had a  "MaybeT (StateT x (EitherT String IO)) y"  (EitherT change)?
09:19:29 <joeyh> I was looking at Control.Exception.Extra this morning, and I wonder if it's a good idea to have things like its catch_ that catch every type of exception. I used to have code like that, but have been converting it to let async exceptions through (except for in rare cases where I'm intentionally throwing asyc)
09:21:43 <glguy> It's generally a bad idea to catch any more exceptions than you absolutely must, but there are cases when one might want to catch every exception
09:22:22 <hiptobecubic> if the thing you're calling into is a black box that either works or doesn't, you don't care what exception is thrown.
09:22:51 <hiptobecubic> You'd prefer a `Maybe a` instead, but that's not always up to you
09:22:52 <joeyh> sure, but async exceptions are often an er, exception to that rule
09:25:05 <joeyh> an async exception is not something in the black box throwing an exception, it's generally something unrelated blowing up
09:27:07 <koomi> it might even be intentional, like timeout
09:28:20 <joeyh> or someone clicking "stop" in your haskell web browser :)
09:35:04 <athan> Hiya everyboadey
09:37:51 <breadmonster> Hey athan
09:39:54 <athan> breadmonster: [:
09:40:18 <athan> Does anyone know how to put a GHC version constraint in a cabal package? Or is that shunned :<
09:41:00 <Clint> athan: you can fake it with constraints on base
09:41:43 <athan> Clint: I was faking it with a cabal-install constraint first :x base 4.8 ~ GHC 7.8.x... right?
09:41:55 <athan> thanks :)
09:42:57 <Clint> athan: base 4.7 ~ ghc 7.8
09:43:22 <athan> ahh derp. Thank you!
09:48:34 <foozer> hi
09:48:42 <tommd> hi
09:48:51 <delrik> hi guys, is there a definitive explanation of (.) and ($) lying around?
09:49:12 <foozer> is it possible to define a datatype for lists of a particular length, say lists of length 3
09:49:19 <delrik> I feel like I’m always “almost” getting these ops until I see some truly awesome point free stuff.
09:49:30 <foozer> of course I could have a check when calling a function that expects such input
09:49:39 <foozer> but is there a way to ensure this on the type level?
09:50:04 <foozer> delrik: look up "functors"
09:50:16 <levi> delrik: (.) is function composition, ($) is function application. The rest is understanding operator precedence and then grokking common idioms for combining them.
09:50:31 <quchen> foozer: This is possible with a couple of extensions. https://downloads.haskell.org/~ghc/7.6.1/docs/html/users_guide/promotion.html
09:51:07 <delrik> thx foozer , levi
09:51:09 <foozer> quchen: thanks! What I'm asking for are dependent types, right?
09:51:36 <levi> delrik: The most helpful thing for me was to really ingrain the precedence order of regular functional application vs. other operators.
09:52:21 <delrik> levi: by that you mean function application having the highest precedence?
09:52:42 <delrik> levi: what aspect of fa?
09:53:00 <levi> delrik: Basically, 'normal' function application in Haskell, signified by juxtaposing a function and an argument, is the *tightest-binding* operation.  The ($) version, however, is both right-associative and very low-precedence.
09:53:03 <quchen> foozer: Dependent types means that types can depend on values. That's not the case in the example in the GHC manual.
09:54:17 <delrik> levi: I’ve got that much, but I’m still struggling to understand its implications. specifically, I wrote this: toDigits n = map (read . (:[])) $ show n, i’m curios why I can’t write this: toDigits n = map . read . (:[]) $ show n
09:54:26 <quchen> foozer: Dependent types allow you to go further with the idea of length-containing vectors.
09:55:05 <quchen> In Haskell, you won't be able to create a "fromList :: [a] -> Vect len a" function, because this requires calculating the "len" from the length of the list.
09:55:24 <quchen> In other words, lengths have to be statically known
09:55:35 <levi> delrik: Well, start parsing manually from left to right, and look at the types of 'map' and 'read'.  Do they make sense to compose like that?
09:56:19 <delrik> levi: kk, one sec, I’m really slow at this =)
09:56:27 <delrik> :t map
09:56:28 <lambdabot> (a -> b) -> [a] -> [b]
09:56:30 <delrik> :t read
09:56:31 <lambdabot> Read a => String -> a
09:57:03 <delrik> doesn’t read satisfy that condition?
09:57:09 <delrik> it takes an a and returns a b
09:57:36 <delrik> I’m struggling to piece together funciton applicaiton in the context of wholemeal programming.
09:58:13 <delrik> or is it wrong for me to look at the intermediate funciton (map . read) as being a function that takes two arguments?
09:58:21 <levi> delrik: Well, if the first two when composed together make sense, then you have to look at the next thing you're composing and see if that makes sense as well.
09:58:31 <jackhill> delrik: map takes two arguments: a  function from a's to b's and a list of a's and returns a list of b's. In your first example above you create a new fucntion by composing read and :. That's good an works.
09:59:14 <delrik> ahhh
09:59:21 <jackhill> In your second example, you're pasing the value (non-funtion) returned by read to map, which doesn't work
09:59:54 <osa1> does anyone here has experience with Criterion command line parameters?
10:00:44 <delrik> jackhill: levi: I see!  I’ve been trying to treat (.) as a pipeline.
10:00:57 <delrik> that is right associative
10:01:03 <delrik> but thats obviously not the case.
10:01:37 <delrik> furthemore, I discounted the fact that my intermediary funcitons would have different behaviours from the innerfuncitons they wrap.
10:01:52 <jackhill> delrik: glad it's making more sense
10:01:56 <jackhill> when looking at the type of .
10:01:59 <jackhill> :t (.)
10:02:01 <lambdabot> (b -> c) -> (a -> b) -> a -> c
10:02:47 <jackhill> it's helpful to keep in mind partial application. As in, if you only provide two funciton to . (the usual case) you get one a funciton with type a -> c
10:03:36 * hackagebot hyphenation 0.4.1 - Configurable Knuth-Liang hyphenation  http://hackage.haskell.org/package/hyphenation-0.4.1 (EdwardKmett)
10:03:38 * hackagebot dag 0.0.2.1 - Basic type-safe directed acyclic graphs.  http://hackage.haskell.org/package/dag-0.0.2.1 (athanclark)
10:06:49 <delrik> jackhill:  thanks for the help!
10:07:30 <jackhill> delrik: you're welcome :)
10:12:40 <osa1> does that happen to anyone else here? I have a project that I work on and after a while cabal build works but when I run cabal install it fails with a compilation error(configuration parameters are same)
10:21:39 <SrPx> Hello, does anyone know any fast octree library in haskell with ray transversal? (Please say you do, man I don't wanna implement that myself.)
10:28:37 * hackagebot paypal-adaptive-hoops 0.5.1.0 - Client for a limited part of PayPal's Adaptive Payments API  http://hackage.haskell.org/package/paypal-adaptive-hoops-0.5.1.0 (fanjam)
10:37:11 <ben__> Hi folks. Can anyone help me with (Maybe a, Maybe b) -> Maybe (a, b)? Feels like I've forgotten something!
10:37:28 <Peaker> ben__: do you want the answer or a guidance towards the answer?
10:38:28 <ben__> Never mind, even just asking has shown me the way :-)  (,) <$> fst r <*> snd r I'm sure there's a better way to write this though...
10:38:38 * hackagebot bytestring-builder 0.10.4.0.2 - The new bytestring builder, packaged outside of GHC  http://hackage.haskell.org/package/bytestring-builder-0.10.4.0.2 (LeonSmith)
10:38:40 * hackagebot linear 1.16.1 - Linear Algebra  http://hackage.haskell.org/package/linear-1.16.1 (EdwardKmett)
10:42:47 <ben__> Peaker, I wouldn't mind a pointer to a more general solution to this? Is there a lensism for this?
10:43:38 * hackagebot bytestring-builder 0.10.4.1.0 - The new bytestring builder, packaged outside of GHC  http://hackage.haskell.org/package/bytestring-builder-0.10.4.1.0 (LeonSmith)
10:43:40 * hackagebot either 4.3.3 - An either monad transformer  http://hackage.haskell.org/package/either-4.3.3 (EdwardKmett)
10:43:57 <Peaker> ben__: if you just unpack it with pattern matching it doesn't look so bad
10:44:13 <Peaker> ben__: the lens-ism I can think of is too monomorphic:  foo ^? both . _Just
10:44:30 <ben__> Peaker, I have this: range = _ <$> CF.minimum <*> CF.maximum (where CF is Control.Foldl)
10:44:50 <ben__> both minimum and maximum are :: CF.Fold a (Maybe a)
10:45:01 <edwardk> lens can handle the case where both sides of the pair have the same type
10:45:16 <edwardk> :t both id
10:45:17 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => r (f b) (f b) -> f (r b b)
10:45:22 <quchen> Hmm, I've found a curious case of a potential monoid. ForeignPtr allows me to make a C pointer that is tracked by the GHC GC. Via `touchForeignPtr foo` I can ensure `foo` lives at least as long as that action. Furthermore, I can combine two "touch foreign pointer" actions via (>>), and `return ()` does nothing. Does this form a monoid?
10:45:24 <platz> it almost looks like sequence
10:45:28 <edwardk> > both id (Just 12, Just 34)
10:45:30 <lambdabot>  Just (12,34)
10:45:39 <edwardk> :t sequenceOf both (Just 12, Just 34)
10:45:39 <Peaker> ben__: (liftA2.liftA2) (,) CF.minimum CF.maximum ?
10:45:40 <lambdabot> Num b => Maybe (b, b)
10:46:00 <ben__> ^? both . _Just only gives me Maybe a
10:46:19 <ben__> edwardk, thank you kindly!
10:46:21 <edwardk> platz in lens basically if you know how to do something with a Foldable or Traversable, give me a Fold or a Traversal to find the stuff then bolt 'Of' on the end of the combinator
10:46:22 <ben__> :t both
10:46:23 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => (a -> f b) -> r a a -> f (r b b)
10:46:44 <edwardk> both is sneaky and also works on things like Either these days
10:47:08 <edwardk> both f = bitraverse f f
10:47:18 <Peaker> ben__: oops, yeah, need sequenceOf and not ^? there
10:47:52 <Thulsadum> aren't there character transformation for Char8?
10:48:41 <platz> edwardk: that's a good tip to remember, thanks
10:48:43 <Thulsadum> or do toLower,toUpper work on it?
10:49:06 <ben__> thanks Peaker :-) can I use this on the left of <$> somehow?
10:52:50 <edwardk> :t Data.ByteString.Strict.Lens.chars %~ toUpper
10:52:51 <lambdabot> BSC.ByteString -> BSC.ByteString
10:52:54 * edwardk leaves that there
10:53:07 <edwardk> of course you can just do that with map from Char8
10:53:18 <edwardk> :t Data.ByteString.Char8.map toUpper
10:53:20 <lambdabot> BSC.ByteString -> BSC.ByteString
10:53:46 <glguy> Hmm, that one doesn't have as many sweet operators...
10:54:05 <dkat>  /part
10:57:39 <eyebloom> Is it possible to construct a function f :: (a -> m b) -> m (a -> b) where m is a monad?
10:58:38 * hackagebot scientific 0.3.3.7 - Numbers represented using scientific notation  http://hackage.haskell.org/package/scientific-0.3.3.7 (BasVanDijk)
10:59:54 <glguy> eyebloom: no
11:00:21 <platz> djinn doesn't like it either
11:00:28 <eyebloom> If I’m in a situation where this is coming up what should I do?
11:00:50 <glguy> Fix the code so that it doesn't need to. Paste something to lpaste if you need help
11:03:00 <eyebloom> giguy: my code is pretty complex. Not sure if I should boil it down to a toy example.
11:06:55 <funfunctor> anyone awake?
11:07:17 <glguy> eyebloom: Imagine if you had that function. If you instantiated it to m~Maybe you'd get:  (a -> Maybe b) -> Maybe (a -> b)
11:08:06 <grncdr_> is this an ok place to ask a noobish category theory question?
11:08:24 <grncdr_> I was reading http://bartoszmilewski.com/2014/12/05/categories-great-and-small/ and there's a part that's kind of confused me
11:08:45 <raek_> Does this function have a name?
11:08:48 <raek_> foo :: Alternative f => [f a] -> f a
11:08:55 <raek_> foo fs = foldr (<|>) empty fs
11:09:04 <Zemyla> Does MonadPlus m => Monoid (m a) with mempty = mzero and mappend = mplus?
11:09:05 <sinelaw> grncdr_, you can also try #learnmath if no answer here
11:09:21 <supki> @hoogle Alternative f => [f a] -> f a
11:09:21 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
11:09:22 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
11:09:22 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
11:09:29 <grncdr_> sinelaw: thanks for the tip, I will try here first and see what happens ;)
11:09:46 <raek_> I'm making a lexer using Text.Regex.Applicative and want to turn a list of strings into a lexer accepting any of the strings.
11:10:21 <raek_> hm. maybe 'asum'?
11:10:28 <supki> yes
11:10:34 <eyebloom> giguy: I see what you are saying, that would not work.
11:10:44 <raek_> asum = foldr (<|>) empty
11:10:54 <Clint> correct
11:10:57 <raek_> yep, there it is! thanks supki!
11:11:07 <grncdr_> he's explaining monoids using natural numbers (& zero) with addition, and says that the "adders" (curried addition) are morphisms... then he transitions to treating the natural numbers as not a set, but a single "object" (in a category with one object)
11:11:22 <eyebloom> I’m in the situation I’m in because I’m messing with recursive functions that return monads.
11:11:34 <grncdr_> but it's implied that all of the morphisms are still part of this category (infinitely many morphisms going from this one object back to itself)
11:12:15 <grncdr_> the part I don't get is how the adders can remain distinct morphisms if we aren't allowed to look "inside" the object (the set of natural numbers & zero)
11:12:44 <eyebloom> It’s just a design pattern problem. Just looking around for solutions, is it posible that arrows could help me?
11:12:46 <glguy> Zemyla: yes. In fact in GHC 7.10 there will be a type Data.Monoid.Alt the provides a Monoid instance like this for an arbitrary wrapped type implementing Alternative
11:12:53 <quchen> grncdr_: The object is *not* the set of anything. The arrows correspond to the set elements, the object can be anything.
11:13:30 <quchen> grncdr_: Each morphism from the object to itself corresponds to an element of your set.
11:13:39 * hackagebot zip-archive 0.2.3.7 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.2.3.7 (JohnMacFarlane)
11:14:14 <quchen> In other words, <your set> is Hom(X,X), where X is the only object of your category.
11:18:19 <nbouscal_> grncdr_: the trick here is understanding that all of the structure of any object lives in its morphisms. objects *really are* just dots.
11:19:08 <RyanGlScott> Is there a library for Template Haskell derivation of data family typeclass instances à la ndmitchell's derive library?
11:19:09 <grncdr_> thanks nbouscal & quchen - I am digesting this and re-reading the confusing parts of the artical
11:19:19 <grncdr_> *article
11:20:38 <RyanGlScott> e.g., data family DatFam a; newtype instance DatFam Char = DatChar Char deriving Show, except replacing the "deriving" clause with a TH splice
11:20:41 <nbouscal> grncdr_: one thing that may help is working with a category small enough that you can enumerate the arrows and see how they encapsulate the structure. a small group, or something
11:22:42 <quchen> grncdr_: If it helps, this is what Awodey says about monoids: http://imgur.com/a/rNTO6
11:28:21 <joshcoug_> does anyone know if its possible to get all your test modules loaded via cabal repl  (im imagining something like cabal test-repl)
11:31:04 <quchen> Doesn't cabal repl load all exposed modules?
11:31:14 <quchen> Oh, *test* modules
11:31:34 <quchen> I think you can specify your testsuite with "test-NAME"
11:31:46 <quchen> so `cabal repl test-name` should work
11:32:07 <quchen> Where NAME is what you've got in your .cabal, e.g. "testsuite foo" gives you test-foo as a build target
11:32:11 <joshcoug_> by name, is that the test suite name?
11:32:22 <joshcoug_> yeah ok thanks. i'll try that.
11:32:25 <grncdr_> ok, so staying with this concrete example: I can pretty easily think of the object as "just a dot", and the arrows as all of the curried addition operations (+ 1), (+ 2), etc. Then it's pretty clear that all my arrows compose nicely and (+ 0) is the identity arrow...
11:32:48 <grncdr_> What's a reasonable expansion of this into a category with 2 objects?
11:33:09 <grncdr_> (or more I guess, but 2 is probably enough to start...)
11:34:06 <quchen> Hmm. Maybe involutions as arrows or something.
11:35:51 <quchen> On second thought, that doesn't make sense.
11:37:16 <yyttr3> How would I prevent sparks from being fizzled when using rpar? I understand what it means for a spark to be fizzled but I can't seem to make a program who's sparks are not GC'd or fizzled...
11:38:12 <grncdr_> hm, you mean having arrows like (* -1), (* -2) etc ?
11:38:59 <quchen> I meant to say "I don't know" up there :-þ
11:39:07 <grncdr_> :-D
11:39:30 <funfunctor> setup-Simple-Cabal-1.18.1.5-x86_64-linux-ghc-7.8.4: dist/package.conf.inplace: inappropriate type
11:39:38 <funfunctor> what is all that about!?
11:40:01 <shachaf> grncdr_: Arrows aren't functions, in general.
11:40:32 <grncdr_> shachaf: are (pure) functions arrows?
11:40:48 <funfunctor> happens if you do a cabal build && cabal install but not if you do a direct cabal install
11:40:56 <johnw> grncdr_: yes, functions are arrows, as evidenced by the "arr" function
11:41:01 <johnw> :t Control.Arrow.arr
11:41:03 <lambdabot> Arrow a => (b -> c) -> a b c
11:41:06 <shachaf> grncdr_: I walked into the middle of the conversation, but you're not talking about Haskell here, right?
11:41:13 <grncdr_> shachaf right
11:41:18 <johnw> ah
11:41:31 <quchen> shachaf: The question he asked was "a monoid is a category with one object, how does this generalize to two objects"
11:41:31 <grncdr_> I'm talking about Bartosz Milewski's articles on categories
11:41:36 <shachaf> grncdr_: "arrow" can mean almost whatever you want it to, as long as you specify your category.
11:41:56 <shachaf> grncdr_: So, sure, there's a category where the arrows are Haskell functions.
11:42:12 <shachaf> (Or something close enough to a category that we can ignore the details.)
11:42:52 <grncdr_> ok, what's a category where I can't (easily) analogize arrows to functions?
11:43:07 <grncdr_> (sorry if this is really dense and/or OT)
11:43:29 <shachaf> grncdr_: An example I like is a category where the objects are natural numbers, and an arrow : N -> M is an NxM matrix.
11:43:36 <shachaf> grncdr_: And composition is matrix multiplication.
11:44:03 <shachaf> (And sure, you can just talk about linear maps : R^n -> R^m and it'll be functions again. But hopefully that at least gives you an idea.)
11:44:14 <grncdr_> yeah actually that helps
11:44:36 <shachaf> In fact I like this example so much that I usually use it as motivation for the definition of a category.
11:44:40 <quchen> Poset has arrows that mean "is less than or equal to", which is also very un-funciony.
11:45:39 <shachaf> Matrices and matrix multiplication are almost like a monoid -- you have a multiplication operation which is associative and has an identity on both sides -- but it doesn't quite work, because you can't multiply any two old matrices.
11:46:00 <shachaf> The sizes have to match. And there isn't just one identity -- there's an identity for each size.
11:47:33 <yyttr3> Does anyone know anything about the Control.Parallel library?
11:48:55 <johnw> the real question is, do we know *and* we have an answer to your upcoming question
11:49:27 <grncdr_> but: don't arrows normally compose by "walking" between objects?
11:50:01 <quchen> Arrows compose. That's all they have to do, they don't have to compose "by" any scheme.
11:50:21 <quchen> What do you mean with "walking"?
11:50:28 <johnw> grncdr_: the composition must be equivalent to going directly from A to Z
11:50:56 <grncdr_> so in this category where arrows are matrices, I have the objects 3 and 4. There's an infinite number of arrows (3x4 matrices) between them... but they won't compose with arrows between 4 and 5 (or maybe I'm getting stuck on the "almost a monoid" bit)
11:51:18 <yyttr3> johnw: I was just trying to see if anyone could explain the exact conditions under which a spark fizzles. I'm trying to prevent GC'd and fizzled sparks but I can't seem to prevent them.
11:51:24 <shachaf> grncdr_: Sure they will. You can multiply a 3x4 matrix with a 4x5 matrix.
11:51:28 <shachaf> (You get a 3x5 matrix.)
11:52:02 <shachaf> You get to define how composition works in your category.
11:52:04 <grncdr_> ah!
11:52:40 <shachaf> You just need to show that it has an identity for each object (the identity matrix for each size) and that composition is associative (it is).
11:52:57 <shachaf> This example is only a good one if you're familiar with matrix multiplication, of course.
11:53:20 <grncdr_> I'm pretty sure I was at some point ;)
11:53:24 <shachaf> Here are two other examples of categories where the objects are natural numbers:
11:54:18 <shachaf> The category where objects are natural numbers, and there's a unique arrow from each number to each number greater than or equal to it.
11:54:37 <shachaf> So there's an arrow from 0 to every object, from 1 to every objects except 0, and so on.
11:55:12 <shachaf> This is a pretty simple category, because it's really just a total order in disguise.
11:56:02 <funfunctor> Software defined radio using Haskell !
11:56:04 <funfunctor> enjoy: http://victoredwardocallaghan.github.io/hlibBladeRF/
11:56:20 <shachaf> Here's a funny example: The category where the objects are natural numbers, and an arrow : N -> M is an N-tuple of natural numbers < M
11:56:39 <abadr> Hi, beginner question. I'm trying to check whether one String is a substring of another, case insensitively. Here's what I have right now, is there a better way?: (CI.foldCase s1) `Data.List.isInfixOf` (CI.foldCase s2) -- CI is Data.CaseInsensitive
11:56:44 <jophish> yo yo yo
11:56:46 <shachaf> Composition is pointwise indexing.
11:57:52 <jophish> I'm interfacing with a library which has a function which may free a pointer. Something like: T* perhapsFree(T* pointerToPerhapsFree); How can people suggest wrapping this?
11:59:33 <jophish> In C++ or Rust this would be easy, perhapsFree would consume the pointer, taking it as a unique_ptr and returning the same pointer or null
12:00:00 <jophish> is there a Haskell idiom which represents this?
12:00:35 <jophish> The monad Maybe springs to mind
12:00:50 <c_wraith> jophish: wrap the pointer in some structure that may be invalidated by certain calls.  MVar (Ptr a) or something
12:01:39 <jophish> I suppose I'm paranoid about users doing: do p <- allocateSomehthing; maybeFree p; use p;
12:03:41 * hackagebot postgresql-libpq 0.9.0.2 - low-level binding to libpq  http://hackage.haskell.org/package/postgresql-libpq-0.9.0.2 (LeonSmith)
12:04:34 <jophish> c_wraith: I'll probably do that, but it would certainly be nice to require a user to: do p <- allocateSomething; q <- maybeFree p; use q
12:06:05 <jophish> An unrelated question: Would people be surprised if 'poke = error "Unable to poke values of type xxx"' was used in an instance of Storable?
12:06:31 <jophish> because there exists no (user exposed) way to create these values
12:11:11 <clrnd> abadr, it looks good, try profiling it if anything
12:11:18 <quchen> jophish: You could do something similar to indexed monads, like in this pseudocode: http://lpaste.net/118953
12:11:45 <quchen> The idea is that you flick a switch that does not allow certain other functions to be applied from that point on
12:12:07 <abadr> clrnd: thanks. meaning profile for performance? i'd need an alternative to compare it to :)
12:12:25 <quchen> And no, "error" inside Storable (or any other class for that matter) is not a good thing to have
12:12:33 <abadr> have tried much googling but maybe i'm not searching for the right thing
12:13:30 <clrnd> @hoogle IsString a => a -> a -> Bool
12:13:32 <lambdabot> Prelude (<) :: Ord a => a -> a -> Bool
12:13:32 <lambdabot> Data.Ord (<) :: Ord a => a -> a -> Bool
12:13:32 <lambdabot> Prelude (<=) :: Ord a => a -> a -> Bool
12:13:42 * hackagebot amazonka-core 0.2.2 - Core functionality and data types for Amazonka libraries.  http://hackage.haskell.org/package/amazonka-core-0.2.2 (BrendanHay)
12:13:44 * hackagebot amazonka 0.2.2 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.2.2 (BrendanHay)
12:13:46 * hackagebot amazonka-autoscaling 0.2.2 - Amazon Auto Scaling SDK.  http://hackage.haskell.org/package/amazonka-autoscaling-0.2.2 (BrendanHay)
12:13:48 * hackagebot amazonka-cloudformation 0.2.2 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.2.2 (BrendanHay)
12:13:50 * hackagebot amazonka-cloudfront 0.2.2 - Amazon CloudFront SDK.  http://hackage.haskell.org/package/amazonka-cloudfront-0.2.2 (BrendanHay)
12:15:13 <jophish> quchen: that looks like exactly what I need, thanks!
12:15:56 <quchen> jophish: It assumes you know when the function has freed the pointer though
12:16:20 <quchen> Otherwise you might finalize a valid pointer (which doesn't hurt you, but it's too early and you might still need it)
12:16:38 <jophish> yeah, that's only known at runtime sadly
12:17:50 <jophish> perhaps a function: doSomethingWithMaybeFreedPointer :: (Ptr a -> IO b) -> Ptr a -> IO Maybe b
12:18:03 <phaazon> hey, what would you suggest to do to versions if I just add a MINIMAL pragma in my lib?
12:18:06 <phaazon> major increment?
12:18:52 * hackagebot amazonka-cloudhsm 0.2.2 - Amazon CloudHSM SDK.  http://hackage.haskell.org/package/amazonka-cloudhsm-0.2.2 (BrendanHay)
12:18:54 * hackagebot amazonka-cloudsearch 0.2.2 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.2.2 (BrendanHay)
12:18:56 * hackagebot amazonka-cloudsearch-domains 0.2.2 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.2.2 (BrendanHay)
12:18:58 * hackagebot amazonka-cloudtrail 0.2.2 - Amazon CloudTrail SDK.  http://hackage.haskell.org/package/amazonka-cloudtrail-0.2.2 (BrendanHay)
12:19:00 <clrnd> abadr, I guess the isInfixOf can be pretty unperformant, try this if you like ByteStrings: https://hackage.haskell.org/package/stringsearch-0.3.3/docs/Data-ByteString-Search.html
12:19:00 * hackagebot amazonka-cloudwatch 0.2.2 - Amazon CloudWatch SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-0.2.2 (BrendanHay)
12:19:25 <jophish> Regarding the Storable instance, what's the alternative? It's a shame instances can't be not exported
12:19:42 <jophish> otherwise I'd keep the error nastiness hidden
12:19:46 <clrnd> Data.Text has an isInfixOf that's O(n+m)
12:20:33 <quchen> jophish: Hmm yeah that's unfortunate. Another level of wrappers?
12:20:58 <abadr> thanks clrnd
12:21:14 <jophish> that's all I can think of
12:24:02 * hackagebot amazonka-cloudwatch-logs 0.2.2 - Amazon CloudWatch Logs SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-logs-0.2.2 (BrendanHay)
12:24:04 * hackagebot amazonka-codedeploy 0.2.2 - Amazon CodeDeploy SDK.  http://hackage.haskell.org/package/amazonka-codedeploy-0.2.2 (BrendanHay)
12:24:06 * hackagebot amazonka-cognito-identity 0.2.2 - Amazon Cognito Identity SDK.  http://hackage.haskell.org/package/amazonka-cognito-identity-0.2.2 (BrendanHay)
12:24:08 * hackagebot amazonka-cognito-sync 0.2.2 - Amazon Cognito Sync SDK.  http://hackage.haskell.org/package/amazonka-cognito-sync-0.2.2 (BrendanHay)
12:24:10 * hackagebot amazonka-config 0.2.2 - Amazon Config SDK.  http://hackage.haskell.org/package/amazonka-config-0.2.2 (BrendanHay)
12:29:12 * hackagebot amazonka-datapipeline 0.2.2 - Amazon Data Pipeline SDK.  http://hackage.haskell.org/package/amazonka-datapipeline-0.2.2 (BrendanHay)
12:29:14 * hackagebot amazonka-emr 0.2.2 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.2.2 (BrendanHay)
12:29:16 * hackagebot amazonka-iam 0.2.2 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.2.2 (BrendanHay)
12:29:18 * hackagebot amazonka-importexport 0.2.2 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.2.2 (BrendanHay)
12:29:20 * hackagebot amazonka-kinesis 0.2.2 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.2.2 (BrendanHay)
12:34:22 * hackagebot amazonka-kms 0.2.2 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.2.2 (BrendanHay)
12:34:24 * hackagebot amazonka-lambda 0.2.2 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.2.2 (BrendanHay)
12:34:26 * hackagebot amazonka-opsworks 0.2.2 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.2.2 (BrendanHay)
12:34:28 * hackagebot amazonka-rds 0.2.2 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.2.2 (BrendanHay)
12:34:30 * hackagebot amazonka-redshift 0.2.2 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.2.2 (BrendanHay)
12:36:48 <boothead> Is there any reason why Control.Foldl.Fold doesn't have a Profunctor instance?
12:37:32 <boothead> btw Peaker thanks for earlier - was on a train and not sure message got through over my crappy 3g tethered phone signal :-)
12:37:40 <boothead> (I was ben__)
12:38:56 <Peaker> boothead: sure thing :)
12:39:14 <shachaf> boothead: No, it's isomorphic to Data.Machine.Moore
12:39:32 * hackagebot amazonka-route53 0.2.2 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.2.2 (BrendanHay)
12:39:34 * hackagebot amazonka-route53-domains 0.2.2 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.2.2 (BrendanHay)
12:39:36 * hackagebot amazonka-s3 0.2.2 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.2.2 (BrendanHay)
12:39:38 * hackagebot amazonka-sdb 0.2.2 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.2.2 (BrendanHay)
12:39:40 * hackagebot amazonka-ses 0.2.2 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.2.2 (BrendanHay)
12:40:41 <Peaker> boothead: a nice property of Applicative, if you look at its formulation as (pure,liftA2), is that they compose nicely:  f . g (where f and g are type ctors) is an Applicative if f,g both are, via simple: pure.pure and liftA2.liftA2
12:40:56 <Peaker> (this property is lost with Monads, which is why sometimes it is said that "Monads don't compose")
12:41:32 <Peaker> boothead: the TypeCompose package has a type-level (.) operator defined, and then an automatic Applicative instance for it
12:44:42 * hackagebot amazonka-sns 0.2.2 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.2.2 (BrendanHay)
12:44:44 * hackagebot amazonka-sqs 0.2.2 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.2.2 (BrendanHay)
12:44:46 * hackagebot amazonka-storagegateway 0.2.2 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.2.2 (BrendanHay)
12:44:48 * hackagebot amazonka-sts 0.2.2 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.2.2 (BrendanHay)
12:44:50 * hackagebot amazonka-support 0.2.2 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.2.2 (BrendanHay)
12:49:52 * hackagebot amazonka-swf 0.2.2 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.2.2 (BrendanHay)
12:54:20 <boothead> Peaker, ok I can see how that works (and I caught a comment from ocharles yesterday that that somehow implys Profunctor) but I don't see exaclty what you're getting at?
12:55:08 <quchen> Peaker: Oh wow, I never realized it's liftA2.liftA2.
12:55:32 <Peaker> boothead: I'm getting at a slight generalization of the (liftA2.liftA2) idea.  add (pure.pure) and you get "penetration" of two Applicative layers, for any 2 Applicatives
12:55:42 <quchen> Oh wait I mixed that up.
12:57:26 <Peaker> consider this potential class hierarchy:  class Lift0 f where lift0 :: a -> f a ; class Lift1 f where lift1 :: (a -> b) -> f a -> f b ; class Lift2 f where lift2 :: (a -> b -> c) -> f a -> f b -> f c ; class Join f where join :: f (f a) -> f a ;  Functor=Lift1, Applicative=(Functor,Lift0,Lift2), Monad=(Applicative,Join)
12:57:47 <Peaker> might be easier pedagogically than Functor, Applicative, Monad?
12:58:17 <sinelaw> nice
12:58:29 <boothead> this is what purescript decided to use?
12:58:38 * hackagebot amazonka-support 0.2.2 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.2.2 (BrendanHay)
12:58:38 * hackagebot amazonka-swf 0.2.2 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.2.2 (BrendanHay)
12:58:39 <Peaker> no idea, I'd be surprised :)
12:59:15 <S11001001> no, purescript uses the normal names
13:01:11 <boothead> S11001001, but it does have Monad as just Apply and Pure I think?
13:02:13 <boothead> Peaker, so given those properties why might I not need Profunctor for Foldl.Fold?
13:02:31 <Peaker> boothead: Not sure, I'm not familiar with those
13:03:00 <S11001001> boothead: Applicative and Bind
13:04:05 <S11001001> boothead: basically this chart http://hackage.haskell.org/package/semigroupoids
13:04:51 <S11001001> boothead: Pointed is now considered bad
13:04:56 <S11001001> so is not included
13:05:02 <Peaker> I disagree with the Pointed-bad thing :(
13:05:08 <Peaker> And there can be laws!
13:05:51 <Peaker> for example: a law that says that iff an Applicative instance also exists, it must be consistent with <*> to form fmap
13:06:12 <NightRa> Is there a build in function for (Monad m) => (a -> m a) -> [a] -> m a?
13:06:14 <barrucadu> Why is Pointed now considered bad?
13:06:27 <Peaker> but sometimes a conditional Applicative instance exists, the condition isn't satisfied, so there is no Applicative instance, but the implementation of "pure" is still nicely constrained!
13:06:34 <NightRa> I currently do it with foldMap with Endomorphism . Kleisli
13:06:41 <Peaker> barrucadu: because it's hard to formulate laws to govern its behavior
13:07:07 <linman32> hi. have a test error in nicta course when testing seqOptional in List.hs:  http://lpaste.net/118956
13:07:21 <Peaker> NightRa: what does that function do? how do you combine the a's?
13:07:22 <linman32> using the answer, so it is supposed to pass
13:07:48 <S11001001> NightRa: that sounds reasonable
13:08:32 * hackagebot ascii-progress 0.1.0.0 - A simple progress bar for the console.  http://hackage.haskell.org/package/ascii-progress-0.1.0.0 (yamadapc)
13:08:44 <NightRa> [a,b,c,d] -> f a >>= f b >>= f c >>= f d, aka foldMap f list (but just so much wrapping and unwrapping boilerplate)
13:09:10 <NightRa> foldMap with the Kleisli endomorhism monoid, return and >=>
13:09:41 <S11001001> NightRa: where is Monoid Endomorphism defined?
13:09:43 <Peaker> NightRa: that doesn't seem to type-check? e.g: f d is not a function
13:10:01 <Peaker> NightRa: f d :: m a,  so cannot be an RHS argument to >>= ?
13:10:22 <Peaker> NightRa: assuming "f" is the: a -> m a   function ?
13:12:07 <Peaker> NightRa: you have multiple a's in a list, and a function to transform an a to another a. But no way to "combine" the a's from the list?
13:13:01 <EvanR> Peaker: you could apply the action to everything in the list, then sequence
13:13:03 <NightRa> Alright, I was wrong in how I presented it. f :: a -> (b -> m b), the overall function :: (Monad m) => (a -> (b -> m b)) -> [a] -> b -> m b
13:13:07 <EvanR> you dont need to get an a, just a m a
13:13:51 <EvanR> ah but the list might be empty and thered be no m a to pick
13:13:52 <linman32> ok, issue about seqOptional is resolved. never mind
13:13:53 <Peaker> EvanR: if you sequence you end up with m [a], not m a
13:14:21 <EvanR> oh right
13:14:24 <Peaker> EvanR: also choosing the first 'a' or such is error-prone and a bad idea, IMO
13:14:35 <Peaker> (even if you're guaranteed to have multiple a's)
13:14:37 <NightRa> And it would be implemented as: (foldMap f list) b
13:14:40 <EvanR> well it just doesnt work since there might not be any
13:14:55 <NightRa> But there's again all that instance selection boilerplate...
13:15:14 <Peaker> Haskellers all appreciate the importance of totality.  it sort-of corresponds to no-information-creation, but something almost as important is no-information-loss..
13:15:50 <EvanR> nah loss the information
13:15:57 <EvanR> who needs it
13:16:32 <NightRa> applyM f list = runKleisli . getEndomorphism $ foldMap (Endomorphism . Kleisli . f) list
13:18:05 <benzrf> NightRa: just Endo?
13:18:34 <NightRa> benzrf: Endo is only a -> a
13:18:47 <benzrf> :t Endomorphism
13:18:48 <lambdabot> Not in scope: data constructor ‘Endomorphism’
13:18:51 <NightRa> The monoid I want is (Monad m) => a -> m a
13:18:53 <benzrf> whats endomorphism then
13:19:05 <benzrf> NightRa: Kleisli then
13:19:16 <benzrf> NightRa: oh
13:19:22 <NightRa> Sure, but there's another monoid predefined for Kleisli
13:19:24 <NightRa> ...
13:19:28 <benzrf> NightRa: i meant "just Endo" as in instead of the whole word "Endomorphism"
13:19:38 <NightRa> Which I have never used.
13:19:53 <NightRa> (The other kleisli monoid instance)
13:20:02 <benzrf> oh, is Endomorphism generalized Endo
13:20:16 <NightRa> benzrf: Yes. It's in monoid-extras
13:20:25 <mr-fool> I need some help
13:20:39 <mr-fool> I know that a ,- getLine will take a user input
13:20:51 <mr-fool> but is there a way to restrict it to a list?
13:20:55 <NightRa> I wish this has been the default instance. Oh well.
13:21:06 <mr-fool> and after I import Data.List
13:21:12 <mr-fool> how do I use the reverse function
13:21:14 <benzrf> NightRa: something like
13:21:28 <benzrf> instance Category k => Monoid (Endomorphism k a) -- ?
13:22:06 <NightRa> benzrf: That's exactly the monoid instance for Endomorphism.
13:22:12 <shiona> mr-fool: getLine will always return a String, which is the same as a list of Chars
13:22:19 <S11001001> NightRa: for >=> to be the one, it would be (.) = flip (.)
13:22:47 <mr-fool> shiona: is there a way to take the user input as a list?
13:22:56 <S11001001> linman32: can you share your file on lpaste?
13:23:10 <shiona> mr-fool: technically getLine always does
13:23:32 * hackagebot file-embed 0.0.7.1 - Use Template Haskell to embed file contents directly.  http://hackage.haskell.org/package/file-embed-0.0.7.1 (MichaelSnoyman)
13:23:58 <shiona> but if you want to read things like "[1, 2, 3]" the user inputs, you can run the string you get from the getLine through function called read
13:23:59 <NightRa> S11001001: Ah, so <=<, wasn't critical for me here
13:24:35 <mr-fool> shiona: is there a way to set my user define function as the function defined in Data.List reverse?
13:24:38 <shiona> this is of course not a great way of doing it, because it's not runtime-safe, but should suffice for a test
13:24:48 <linman32> S11001001: hey, i got it figured out. thanks
13:25:06 <shiona> mr-fool: I can't understand that question
13:25:30 <linman32> S11001001: i deleted something in a file accidently
13:25:40 <mr-fool> shiona: you know there a function called reverse in the module
13:25:45 <mr-fool> Data.List?
13:25:48 <shiona> yes
13:26:06 <NightRa> Interesting how much I use this instance since I discovered it
13:26:14 <mr-fool> shiona: I am trying to create syn for that function
13:26:40 <shiona> in a file you can just write "aliasToReverse = reverse"
13:29:43 * hackagebot conduit-combinators 0.3.0.6 - Commonly used conduit functions, for both chunked and unchunked data  http://hackage.haskell.org/package/conduit-combinators-0.3.0.6 (MichaelSnoyman)
13:29:43 <mr-fool> shiona: https://github.com/mr-fool/haskell/blob/master/reverse/reverse.hs help?
13:30:25 <shiona> mr-fool: put the myLast as a top level definition (outside main function)
13:31:06 <mr-fool> shiona: you are right but why is that?
13:31:38 <shiona> a do block is magical
13:32:30 <shiona> if you really want to do it inside the do block "let myLast = reverse" before calling myLast might work
13:32:59 <mr-fool> shiona: https://github.com/mr-fool/haskell/blob/master/reverse/reverse.hs I don't understand why it is reversing [] symbol around as well
13:33:27 <shiona> because it's reversing your input
13:33:34 <shiona> the whole string
13:34:00 <mr-fool> shiona: is there a way to reverse the list
13:34:19 <mr-fool> and make it in a way that treat the input as list?
13:34:32 <shiona> you are reversing a list. What you want is to parse the input as a list
13:35:05 <shiona> and yes, as I already said, using a function called read you can get pretty much anything out of a string in an unsafe manner
13:35:19 <shiona> > read "[1,2,3]" :: [Int]
13:35:21 <lambdabot>  [1,2,3]
13:35:30 <barrucadu> There's also the much safer, readMaybe in Text.Read
13:35:37 <mr-fool> shiona: read or readLine?
13:36:00 <mr-fool> shiona: coz read blown up on me
13:36:07 <ajcoppa> > read "[1,'a',17.9]" :: [Int]
13:36:08 <lambdabot>  *Exception: Prelude.read: no parse
13:36:36 <shiona> read
13:37:23 <mr-fool> shiona: https://github.com/mr-fool/haskell/blob/master/reverse/reverse.hs
13:37:24 <ajcoppa> mr-fool: if you're trying to use it as a getLine replacement, it can't do that. you just call read on a string, and it tries to parse the string and turn it into a different type
13:37:26 <mr-fool> read is invalid
13:37:33 <ajcoppa> yeah
13:37:52 <ajcoppa> you still have to use getLine to get the user input as a string. then you call read on that string in order to try to parse it as a list
13:37:53 <mr-fool> ajcoppa: okay
13:38:04 <ajcoppa> :t read
13:38:26 <mr-fool> you guys mean readLine?
13:38:28 <ajcoppa> :t read
13:38:29 <lambdabot> Read a => String -> a
13:39:09 <ajcoppa> do you understand that type signature?
13:39:10 <mr-fool> what?
13:39:18 <Peaker> @let readMaybe s = case reads s of [(res, "")] -> Just res ; _ -> Nothing
13:39:20 <lambdabot>  Defined.
13:39:24 <Peaker> :t readMaybe
13:39:25 <lambdabot> Read a => String -> Maybe a
13:39:42 <Peaker> weird that this isn't in Prelude
13:39:57 <Peaker> read/reads are so hard to use correctly
13:39:58 <Welkin> Peaker: prelude is not well maintained and has a lot of problems
13:40:09 <Welkin> it needs to be updated, but it is not a top priority it seems
13:40:22 <ajcoppa> i agree that read is unsafe, just want to help mr-fool get over the initial hump before we also get into why read is unsafe
13:40:33 <boothead> Does anyone have any pointers for how I might combine Foldl.Fold with a traversal/prism? What I've after is folding over some sub parts of a traversable with different folds in one pass a la http://www.haskellforall.com/2013/08/composable-streaming-folds.html
13:40:43 <mr-fool> ajcoppa: I am just trying to figure out wtf are you guys talking about
13:40:54 <ajcoppa> mr-fool: i understand, we're trying to help
13:41:10 <ajcoppa> is there a specific thing we can help clear up?
13:41:20 <mr-fool> ajcoppa: I still have not figure out how to use read
13:41:35 <Welkin> mr-fool: do you understand the types?
13:41:47 <Welkin> :t getLine
13:41:48 <lambdabot> IO String
13:41:53 <Welkin> :t read
13:41:54 <lambdabot> Read a => String -> a
13:41:54 <ajcoppa> mr-fool: the type signature of read should help explain how to use it
13:42:12 <ajcoppa> it says it takes in a string, and can give you back any type that has an instance for the Read typeclass. if you didn't understand that, it's okay.
13:42:24 <Welkin> pull the string out of the IO String, then pass it in to read to get "a" (whatever type your specify)
13:42:33 <mr-fool> ajcoppa: can you give me an example
13:42:39 <mr-fool> instead of type signature
13:42:43 <ajcoppa> > read "[1,2,3]" :: [Int]
13:42:44 <lambdabot>  [1,2,3]
13:42:58 <Welkin> > read "3.14" :: Float
13:43:00 <lambdabot>  3.14
13:43:08 <ajcoppa> :t read "[1,2,3]" :: [Int]
13:43:09 <lambdabot> [Int]
13:43:13 <Welkin> > read "3.14" :: Int
13:43:14 <lambdabot>  *Exception: Prelude.read: no parse
13:43:20 <Welkin> > read "3" :: Int
13:43:21 <ajcoppa> it turned it into an actual [Int] instead of a String
13:43:21 <lambdabot>  3
13:43:28 <Welkin> > read "3" :: Float
13:43:29 <lambdabot>  3.0
13:43:40 <mr-fool> a <- getLine 	read a
13:43:40 <ajcoppa> i had to tell it what type i wanted it to try to turn that string into, hence the :: [Int] part
13:43:41 <mr-fool> no goal
13:44:01 <Welkin> mr-fool: getLine takes no arguments
13:44:10 <Welkin> it grabs input from stdin
13:46:58 <mr-fool> shit could not even solve the first question of 99 problems of haskell
13:53:37 <ajcoppa> well, we tried.
13:54:32 <Welkin> unfortunately, it seems like there have been a lot of newcomers who try to slap something together without understanding any of it
13:54:36 <Welkin> or even trying to
13:54:45 <mmachenry> I'm trying to figure out the best way to write my concurrent code with async to propagate errors properly. http://lpaste.net/118958
13:54:48 <Welkin> side-effect of dynamically typed languages?
13:55:10 <mmachenry> I'm having an issue with when to call wait for my async in a process that is infinitely spawning off threads.
13:55:31 <EvanR> Welkin: lets call it, "empirical software development"
13:58:34 * hackagebot authenticate-oauth 1.5.0.3 - Library to authenticate with OAuth for Haskell web applications.  http://hackage.haskell.org/package/authenticate-oauth-1.5.0.3 (MichaelSnoyman)
13:58:36 * hackagebot yesod-bin 1.4.3.4 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.4.3.4 (MichaelSnoyman)
13:58:38 * hackagebot yesod 1.4.1.4 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.4.1.4 (MichaelSnoyman)
14:02:46 <dysinger> any examples of Ord or sortBy with multiple record attributes? EG, sort Person by age, firstName & lastName ?
14:03:14 <dysinger> examples I see are sorting on 1 type/attribute
14:08:44 <quchen> dysinger: Monoids!
14:09:06 <quchen> ?let data Person = Person { getAge :: Int, getFirstName :: String, getLastName :: String }
14:09:08 <lambdabot>  Defined.
14:09:35 <quchen> :t comparing getAge <> comparing getFirstName <> comparing getLastName
14:09:35 <lambdabot> Person -> Person -> Ordering
14:09:43 <dysinger> thanks
14:09:50 <quchen> This compares by age first, then by first name, then by last name
14:28:53 <mmachenry> :t (<>)
14:28:54 <lambdabot> Monoid m => m -> m -> m
14:29:03 <mmachenry> Ah, monoids.
14:29:04 <quchen> <> = mappend
14:29:47 <Axman6> ClaudiusMaximus: any improvemnts on your code from yesterday?
14:30:39 <Hemlock> Hey
14:31:33 <Axman6> 'lo
14:35:29 <ClaudiusMaximus> Axman6: i can't remember when you left - i tried unsafeCoerce, and then switched to a custom type family for the optimized operations i needed and it was just as fast once i sprinkled {-# SPECIALIZE instance ... #-}
14:35:56 <Axman6> whaa, cae to share?
14:36:00 <Axman6> care*
14:36:12 <ClaudiusMaximus> Axman6: all in all, runtime in that night of coding went from 1min to 7.5s (i asked for help at around 30s)
14:37:38 <ClaudiusMaximus> Axman6: https://gitorious.org/ruff/ruff/source/f3f510dab1a20246f1f92662c14bc15f55af1bc6:Fractal/RUFF/Types/Ratio.hs is the module i wrote, the paste has everything up to the unsafeCoerce
14:37:49 <ClaudiusMaximus> Axman6: http://lpaste.net/118908
14:38:31 <jophish> in ByteString, why do the construction functions take an Int as the length, instead of something larger?
14:38:36 * hackagebot hsbencher-fusion 0.3.4 - Backend for uploading benchmark data to Google Fusion Tables.  http://hackage.haskell.org/package/hsbencher-fusion-0.3.4 (RyanNewton)
14:38:48 <shachaf> jophish: Lazy ByteString uses Int64
14:38:51 <glguy> jophish: Because bytestrings are completely allocated in memory
14:38:59 <glguy> and you don't have more memory than your Int
14:39:04 <shachaf> Strict ByteString uses Int, probably assuming that a strict ByteString's length will fit in a machine word. :-)
14:39:10 <shachaf> What glguy said.
14:39:10 <jophish> *my* computer can allocate more than 4GB at a time
14:39:24 <Axman6> but Int is 64 bits on a 64 bit machine
14:39:24 <glguy> Int on 64-bit is 64-bit
14:39:26 <kadoban> jophish: Then you probably have 64 bit Ints
14:39:34 <jophish> ah of course
14:39:45 <Axman6> Int is not necessarilly equal to C's int
14:39:56 <jophish> My head's still in C-land from work, thanks all
14:41:11 <Axman6> ClaudiusMaximus: why make UnsafeRatio parameterised on any type when it could be specialised to Integer and ... maybe... unboxed
14:41:17 <Axman6> no, Integer has two constructors
14:41:55 <ClaudiusMaximus> Axman6: to make it identical to Data.Ratio.Ratio so unsafeCoerce doesn't explode even more than usual
14:42:00 <Axman6> still, makes sense for it to be a pair of strict Integers anyway, no need to mess around with things potentially being slow using polymorphic functions
14:42:10 <Axman6> heh, fair enough
14:42:27 <boothead> is there a version lens's "to" function that I can use as a Traversal?
14:42:58 <shachaf> boothead: What do you have in mind?
14:43:01 <Axman6> :t to
14:43:03 <lambdabot> (Contravariant f, Conjoined p, Functor f) => (s -> a) -> p a (f a) -> p s (f s)
14:43:04 <shachaf> A lens is a traversal.
14:43:10 <shachaf> Er.
14:43:19 <shachaf> to isn't a lens, of course. But it's a getter, which is a fold.
14:43:19 <Axman6> not all?
14:43:39 <shachaf> If you want a true traversal, you'll have to be able to convert in more than one direction. :-)
14:43:49 <glguy> Lenses degrade to traversals
14:43:54 <Denommus> can I use lens to manipulate the DOM?
14:44:22 <Axman6> if someone's written a representation of the DOM and lenses to go with it, sure
14:44:46 <shachaf> But probably not an actual DOM, because lenses aren't so great on e.g. mutable structures.
14:44:50 <boothead> shachaf, I have :t pretraverse (measures.to M.keysSet) pretraverse from Foldl and measures is a Lens
14:45:02 <abayley> hello, looking for some help with ErrorT and Either (and IO)...
14:45:10 <Denommus> what I actually want is to have my DOM to be a reactive behavior
14:45:19 <boothead> Could not deduce (Contravariant f) arising from a use of to
14:46:15 <glguy> "to" gets you a Getter, which isn't as powerful as a traversal. It can't "put back"
14:46:38 <Denommus> so I was thinking about using lens to produce reactive *transformations* and having the only side-effect passed to reactive-banana to be the application of these transformations to my DOM
14:46:40 <shachaf> boothead: I don't know anything about pretraverse, but you can't traverse with "to f" because it's read-only.
14:47:24 <Denommus> I just want to know if that's feasible or if I'd waste my time if I tried
14:47:40 <boothead> Denommus, have a look at a little project I've been playing with: https://github.com/boothead/oHm trying to capture the nice bits of Om, clojurescript and core.async for use with ghcjs. Uses pipes, pipes-concurrent, vdom, lenses and MVC package
14:48:11 <shachaf> Sigh, this pretraverse thing is rank-2.
14:49:11 <boothead> shachaf, so is there an equivalent concept of lifting an a -> b into a Traversal? does that even make sense?
14:49:32 <shachaf> boothead: No, a traversal is a read-write thing, not a read-only thing.
14:49:55 <shachaf> A traversal tells you how to get a bunch of 'a's out of an s, and then, once you modify them, how to put them back in.
14:50:14 <boothead> shachaf, I thought a lens could be used as a traversal?
14:50:48 <shachaf> Yes, a lens is read-write too.
14:50:59 <shachaf> A lens is a traversal where "a bunch of" happens to be "exactly one".
14:51:43 <glguy> https://raw.githubusercontent.com/ekmett/lens/master/images/Hierarchy.png You can see that lenses are traversals and lenses are getters
14:51:46 <Denommus> boothead: hm, the idea is similar-ish, but why having only folds if you can have the entirety of FRP?
14:52:33 <abayley> I want to turn a list of IO actions returning Eithers into a list of Rights, or a single Left i.e. it bails on the first error and does not run subsequent IO actions.
14:52:53 <boothead> Denommus, you want https://github.com/ocharles/Francium then :-)
14:52:57 <Clint> abayley: EitherT
14:52:59 <Denommus> abayley: that's exactly what >>= should do
14:53:03 <quchen> abayley: ErrorT is deprecated (hooray!). ExceptT, the replacement, is a true "Either transformer".
14:53:17 <Denommus> abayley: ah, sorry, I misread you
14:53:29 <abayley> Was trying to use ErrorT - trying to avoid libraries not in HP
14:54:02 <quchen> ExceptT is relatively recent, so maybe it's not in the Platform yet. Anyway, apart from being annoying, it's pretty much the same as ExceptT.
14:54:24 <abayley> Can I do it with ErrorT? This pages seems to indicate so: http://evan-tech.livejournal.com/246130.html  (see the bottom of the article)
14:54:30 <rhovland> I have a bunch of functions like "f :: Map a (Maybe b,[b]) -> Map b (Maybe a,[a]) -> Int", and I'd like to use a type synonym like "type TS a b = Map a (Maybe b,[b])", but I'm having trouble making that work
14:54:50 <ryantrinkle> is there a library for doing (fairly simple) calculations where the inputs have precise uncertainty ranges?
14:55:12 <bramgg> Does Learn You a Haskell to always follow Haskell standards? For example is this the way multi-line data types should be declared? http://lpaste.net/118959
14:55:21 <boothead> shachaf, ah yes, I see I've got it backwards.so there's no way I can pop something onto the end of a Traversal' a (Map k v) to make a Traversal' a [k] then?
14:55:27 <quchen> abayley: So what you want is something like [IO a] -> ErrorT e IO [a]?
14:55:30 <ryantrinkle> e.g.: (9..11) * (1..2) = (9..22)
14:55:45 <abayley> i.e. a function: sequenceE :: [IO (Either a b)] -> IO [Either a b]
14:56:05 <shachaf> boothead: Traversing the keys of a Map is a whole other deal.
14:56:23 <quchen> :t sequence :: [IO (Either a b)] -> IO [Either a b] -- abayley
14:56:24 <lambdabot> [IO (Either a b)] -> IO [Either a b]
14:56:24 <ryantrinkle> bramgg: that's a style i've seen fairly frequently, but there are several indentation styles people use for records
14:56:38 <abayley> I tried this but not quite right: sequenceE s = runErrorT (sequence (map ErrorT s))
14:56:44 <ryantrinkle> bramgg: I usually put a couple more line breaks in so that it's less indented
14:57:23 <boothead> I don't really want to traverse over the keys, I just want to get a list of them (I recognise that it wouldn't make sense to be able to set the keys of a map)
14:57:23 <abayley> quchen: I think that will run the entire list of actions. I want to to stop on the first Left.
14:58:11 <bramgg> ryantrinkle: I would also typically do something like that, but if there's a strict standard I would like to follow it for others who may look at my code.
14:58:46 <quchen> abayley: Sounds like foldM might be worth a look then.
14:59:07 <ryantrinkle> bramgg: i don't think there's any consensus about the best way to do all of it; but people generally do line up the commas on the left like that
14:59:18 <bramgg> ryantrinkle: okay, thanks for the info
14:59:23 <ryantrinkle> personally, much of my style is dictated by what emacs's haskell-mode makes easy :P
14:59:40 <quchen> abayley: foldM f z [a,b,c,...] = return z >>= f a >>= f b >>= f c >>= …
14:59:52 <quchen> So when you've got chains of Eithers that should terminate on the first Left
15:00:14 <bramgg> I've always thought that way would make it hard to stay within the 80 column limit, but if most manage then I guess I'm wrong
15:00:30 <abayley> quchen: ahh, that does look promising, thanks.
15:01:01 <quchen> I think I flipped the "f" there, but you get the idea, abayley
15:01:03 <glguy> boothead: If you want a list of the keys you can just call: keys :: Map k a -> [k]
15:02:23 <abayley> quchen: I had written something by hand but suspected that there should be an appropriate monad transformer and traversal
15:03:25 <boothead> glguy, yeah I could, I'm trying to stick it at the end of a chain of traversals so I can Fold over multiple maps which are sub parts of a list of data types
15:03:54 <Fylwind> Given that I know very little about lenses, this is likely a really naive question: I've noticed there are a lot of "utility" operators like <<&&~ which are handy in some scenarios but it seems to add a huge amount of clutter to the operator namespace (and being foreign to new users); is there some way of breaking up the operators into "primitive" operators like << && ~ separately so that you can combine them as you see fit instead of including every
15:03:54 <Fylwind> possible combination of operators with the library itself?
15:04:31 <Fylwind> (just some naive thoughts about the lens library)
15:04:49 <quchen> Fylwind: I wrote this lens operator cheat sheet some months ago: https://github.com/quchen/articles/blob/master/lens-infix-operators.md
15:06:12 <glguy> boothead: That function is just buggy, it should have a different type
15:06:34 <glguy> at a minimum: pretraverse :: Lens.Fold a b -> Fold b r -> Fold a r
15:06:46 <glguy> in that case you'd be able to do what you're trying to do
15:06:51 <quchen> So (<<&&~ x) applies (&&) and gives you access the former value of the field (<<) before setting (~) it using an (&&) operation
15:07:20 <SrPx> I really need a space partitioning structure for my game... since there is no octree implemented on haskell, would you guys please suggest some substitute? I really don't know what to do now.
15:07:32 <boothead> glguy, what's the problem with is specifically? that traversal is the wrong thing?
15:07:43 <glguy> Yeah, Traversal' is more power than it needs
15:07:58 <shock_one> How would I check if STDOUT was redirected. With > that is.
15:08:26 <kuribas> Functional programming is worse than OOP for many real life applications because it takes you further away from thinking in the domain of the problem.
15:08:34 <boothead> glguy, perhaps something more like: https://hackage.haskell.org/package/mvc-1.0.3/docs/MVC.html#v:handles
15:08:37 <benmachine> shock_one: you can't do it perfectly, but there are some tricks you can use
15:08:48 <shock_one> benmachine: continue...
15:08:58 <Axman6> kuribas: quit trolling, and I and many others will completely disagree with you
15:09:13 <benmachine> shock_one: however, be aware that it's not recommended for programs to behave substantially differently according to where their output goes
15:09:19 <kuribas> Axman6: It's not my opinion, but reddit's: http://www.reddit.com/r/programming/comments/2t7a36/lets_hear_your_controversial_programming_opinions/
15:09:34 <kuribas> Axman6: The most upvoted comment actually.
15:09:40 <quchen> "Some guy on the internet said something" is not relevant here
15:09:41 <Axman6> so you're trolling without even having your own ideas?
15:09:42 <shock_one> benmachine: I want to make sure my input is not my output.
15:09:53 <kadoban> kuribas: So it's from a thread asking for trolly opinions…
15:10:07 <kuribas> Axman6: No, I am trolling with having my own ideas :)
15:10:09 <benmachine> shock_one: ah, so you want to know not only *if* you are being redirected, but *where*? I'm not sure I know about that :/
15:10:29 <benmachine> shock_one: also I'm not sure it saves you – the shell will truncate the output file before it even starts your program
15:10:37 <kuribas> Axman6: My opinion is that most redditors must be confused.
15:11:14 <benmachine> kuribas: your point might have gone down better if you had used quotation marks
15:11:32 <kuribas> I am not surprised that someone has such an opinion, I am surprised it gets 161 upvotes.
15:11:53 <bsmt> what controversial opinion is this?
15:12:03 <benmachine> reddit is a hive of scum and villainy, I'm not surprised by anything that happens there
15:12:19 <ryantrinkle> kuribas: when you're used to thinking in a particular paradigm, using an unfamiliar paradigm "takes you further away" from the problem domain, because you have to deal with learning the new paradigm, too
15:12:21 <kuribas> Though there is some truth in it...
15:12:51 <kuribas> Some problems are actually easier solved with mutable data.
15:13:00 <Axman6> kuribas: so, to acually discuss the point, OOP is great untill you need to model processes and transformations; Programming isn't about objects, it's about interaction and transformation of them, which is the key to FP
15:13:16 <Axman6> kuribas: mutability and OOP are not the same thing, those are different arguments
15:13:17 <shock_one> benmachine: are you sure? doing "cat file > file" doesn't erase it.
15:13:37 * hackagebot caramia 0.7.1.1 - High-level OpenGL bindings  http://hackage.haskell.org/package/caramia-0.7.1.1 (Adeon)
15:13:52 <kuribas> Axman6: True, OOP and FP aren't mutually exclusive.
15:14:13 <benmachine> shock_one: ah, interesting, honestly I don't know how it does that :P
15:14:37 <benmachine> shock_one: hmm. maybe fstat on stdout
15:14:48 <koala_man> shock_one: it should and it does for me
15:14:53 <shock_one> benmachine: in Haskell it always returns 1.
15:15:09 <benmachine> shock_one: ...what does?
15:15:09 <Fylwind> kuribas: The assumption of such a bold statement is that every domain is served well by OOP.  There are a lot of domains out there :)
15:15:12 <ryantrinkle> Axman6: i totally agree, but do you think OOP *requires* mutability? i have a hard time conceiving of an OOP system that is immutable
15:15:16 <shock_one> benmachine: I can see that it changed the modification date of the file, though.
15:15:19 <benmachine> koala_man: for me it says "cat: blah: input file is output file"
15:15:29 <koala_man> benmachine: yes. and the file is truncated
15:15:41 <benmachine> koala_man: oh. huh.
15:15:49 <benmachine> true
15:15:51 <benmachine> I didn't check
15:15:52 <Axman6> ryantrinkle: no idea, it's probably possible but how I don't know. It does lend itself better to mutability though
15:16:02 <koala_man> there's nothing cat can do about that because the redirection is performed by the shell before the execve
15:16:05 <shock_one> benmachine: file id of stdout is always 1.
15:16:10 <Fylwind> quchen: thanks for the link, that's a really helpful guide :)
15:16:11 <kuribas> ryantrinkle: Why? You can have an OOP system that only does copying.
15:16:22 <benmachine> shock_one: that's the file descriptor, that's not the result of fstat
15:16:33 <kuribas> Fylwind: I don't think OOP serves any domain well.
15:16:39 <benmachine> koala_man: oh, I even totally said that :P
15:16:44 <benmachine> and then later disbelieved myself
15:16:47 <benmachine> but I was right all along
15:17:08 <kuribas> OOP has some good ideas, but there better ways to implement them than OOP.
15:17:13 <ryantrinkle> kuribas: sure, but if you're always copying, then you can't have, e.g., objects refer to each other persistently despite the fact that their other fields are changing
15:17:22 <Fylwind> kuribas: hey now, I'm trying to not sound like a jerk to the OOPers :P
15:17:32 <benzrf> sOOPer
15:18:06 <ryantrinkle> kuribas: i've actually found one problem that seems less awkward to me in OOP than haskell
15:18:18 <kuribas> ryantrinkle: what's that?
15:18:20 <shock_one> koala_man: that's right. What's the point in having this check then?
15:18:22 <ryantrinkle> kuribas: specifically, manipulating heterogeneous graphs
15:18:37 * hackagebot multistate 0.2.0.0 - like mtl's ReaderT/StateT, but more than one contained value/type.  http://hackage.haskell.org/package/multistate-0.2.0.0 (lspitzner)
15:18:39 <kuribas> I have programmed in OOP, but it always felt unnatural.
15:18:44 <ryantrinkle> yeah, i agree
15:18:54 <ryantrinkle> i switched from C++ to Haskell 9 years ago and never looked back :P
15:19:20 <Fylwind> the idea of promoting one of the parameters in any function call to a special "this" status seemed really weird to me
15:19:23 <MP2E> 9 years ago? Wow nice :P I wish I had found Haskell that long ago :P
15:19:31 <ryantrinkle> in fact, even my heterogeneous graph stuff (optimizing data flows graphs, etc.) has been haskell, but i've had to use really gross GADT stuff, and unsafeCoerce for performance
15:19:43 <koala_man> shock_one: it means that cat *.txt > everything.txt will not result in an infinitely big file
15:19:54 <Fylwind> ryantrinkle: can you not use coerce now with the Coercible in 7.8?
15:20:19 <shock_one> koala_man: makes sense, thank you.
15:20:29 <ryantrinkle> Fylwind: i don't think it would apply; it's stuff like building an array of all the nodes in your graph... but they're all of completely different types
15:20:38 <kuribas> ryantrinkle: does that require OOP, or just mutability?
15:20:56 <ryantrinkle> kuribas: well, i wouldn't say it requires OOP, but it happens to be something OOP models well
15:21:00 <ryantrinkle> and haskell does not model well
15:21:34 <ryantrinkle> specifically, a traditional OOP system is a graph where the nodes are objects, which are labeled with whatever their non-object fields are
15:21:58 <ryantrinkle> and their outgoing edges are their object fields
15:21:59 <SrPx> :( guys? So...
15:22:03 <kuribas> ryantrinkle: You could always make a custom OOP system in haskell :)  And write a nice combinator library for it.
15:22:13 <ryantrinkle> i could, but i haven't!
15:22:21 <ryantrinkle> or, more precisely
15:22:28 <ryantrinkle> i'm not sure if i could, but i'm sure somebody (Oleg?) could
15:24:17 <kuribas> ryantrinkle: You could take for example the smalltalk model, which is not very complex.
15:24:47 <ryantrinkle> yeah; it would be an interesting problem to work on
15:25:18 <erisco> I am stumped right now
15:25:30 <Fylwind> ryantrinkle: it sounds very imperative, but I'm not convinced that it's necessarily OOP (whatever that acronym means ...)
15:26:14 <erisco> I want to somehow get  (S a, S b) -> S (a, b)  but S being Applicative is not possible because  fmap :: (a -> b) -> S a -> S b  exposes values of type 'a'
15:26:58 <ryantrinkle> Fylwind: yeah, that's true; but OOP is pretty good at modeling that kind of thing... so long as you don't care about the overall graph being persistent or bounded, and you mostly want to make small, local mutations rather than whole-graph transforms
15:27:02 <erisco> 'S a' indicates there is some value or values of type 'a' but we don't know what they are
15:27:14 <ryantrinkle> what i'm imagining is something like fgl, but with more dependent types
15:27:33 <ryantrinkle> and maybe mutable versions of things
15:27:38 <ryantrinkle> (optionally, of course)
15:28:20 <benmachine> erisco: it doesn't expose them as such... like, Const Void has fmap
15:28:26 <erisco> an idea I had was  (forall a. -> forall b. -> f a b) -> S a -> S b -> S (a, b)
15:28:31 <erisco> er
15:28:34 <erisco> ... -> S (f a b)
15:28:57 <erisco> but then if we want to coalesce S a, S b, and S c we are stuck
15:30:39 <erisco> benmachine, eventually there are values though, just not yet, and when they do come I need to use that function
15:32:04 <jophish> So, I have a ForeignPtr which points to an object A, a has a finalizer. A in turn points to an object B. B has an array of something storable. I'd very much like to use Data.Vector.Storable.unsafeFromForeignPtr to access this array but it seems to be a bit of a perversion to pass the ForeignPtr to A and the correct offset to access the array in B
15:32:55 <S11001001> erisco: seems that thatFun (,) twice would yield S a -> S b -> S c -> S ((a, b), c), and you say you have fmap?
15:32:58 <jophish> If this was an intended use, I'd imagine that the interface would be: unsafeFromForeignPtr :: ForeignPtr a -> Ptr b -> Int -> Vector a
15:33:12 <erisco> no I do not have fmap
15:33:24 <Fylwind> erisco: why not just \ x -> (,) <$> fst x <*> snd x
15:33:34 <erisco> because it is not applicative
15:33:57 <Fylwind> erisco: oh, sorry misread your question
15:34:10 <erisco> also
15:34:15 <erisco> :t liftA2 (,)
15:34:16 <lambdabot> Applicative f => f a -> f b -> f (a, b)
15:34:28 <erisco> and... hm
15:34:34 <erisco> :t pair
15:34:35 <lambdabot> Not in scope: ‘pair’
15:34:38 <erisco> :t pairA
15:34:39 <lambdabot> Not in scope: ‘pairA’
15:34:44 * erisco shrugs
15:34:51 <S11001001> erisco: not liftA2, your rank-2 fun
15:38:24 <erisco> I will just have to rethink then
15:38:38 * hackagebot debian-build 0.4.1.0 - Debian package build sequence tools  http://hackage.haskell.org/package/debian-build-0.4.1.0 (KeiHibino)
15:40:16 <Pamelloes> Is there an easy way to create a "mapping" between indices of one list and another? e.g. I have list [0,1,2,3,4,5,6,7,8,9] and then map indices 2,3,7,8 to a new list [2,3,7,8]. I now want to be able to fmap (+1) over this new list and then be able to apply the changes back to the original list: [0,1,3,4,4,5,6,8,9,9]
15:43:00 <Cale> > [if n `elem` [2,3,7,8] then x + 1 else x | (n,x) <- zip [0..] (replicate 10 10)]
15:43:02 <lambdabot>  [10,10,11,11,10,10,10,11,11,10]
15:44:12 <Pamelloes> That works for something simple like addition, but what if I want to perform something that affects all elements (like rotate).
15:44:26 <Cale> Well, you said fmap :)
15:44:40 <Cale> Rotation would be tricky
15:44:45 <Pamelloes> That's true, fmap was the first application that popped into my head.
15:45:05 <Cale> These are not natural operations on lists
15:45:32 <Cale> In general, anything which concerns itself with indices is not going to be very natural
15:45:44 <ReinH> Pamelloes: what do you need this for?
15:45:48 <Cale> and you'll want to ask yourself if a list is really appropriate
15:46:47 <Pamelloes> ReinH: I have a list of information with formatting elements in it. I want to rotate (among other things) all non-formatting bits while preserving the position of the formatting bits so the overall format is preserved.
15:47:30 <erisco> if you are concerned beyond index zero then maybe you don't want a list :)
15:47:56 <Cale> Pamelloes: Well, that has nothing to do with indices does it?
15:48:59 <kuribas> Pamelloes: So you could store the formatting bits separately.
15:49:10 <Pamelloes> I guess... the solution that I was thinking about was to try and mark all non formatting bits' indices and then apply the modifications to just those bits.
15:49:36 <ReinH> How do you rotate things?
15:49:41 <erisco> @let shiftl = \xs -> fromMaybe xs (\x -> xs ++ [x]) (safeHead xs)
15:49:42 <lambdabot>  .L.hs:155:51: Not in scope: ‘safeHead’
15:49:55 <Pamelloes> ^
15:50:03 <erisco> @let safeHead [] = Nothing; safeHead (x:_) = x;
15:50:05 <lambdabot>  Defined.
15:50:07 <erisco> @let shiftl = \xs -> fromMaybe xs (\x -> xs ++ [x]) (safeHead xs)
15:50:08 <lambdabot>  .L.hs:155:32:
15:50:08 <lambdabot>      Couldn't match expected type ‘a0 -> [a0]’
15:50:08 <lambdabot>                  with actual type ‘Maybe (Maybe a -> t)’
15:50:09 <Cale> That's... elaborate
15:50:14 * erisco shrugs
15:50:48 <Pamelloes> My definition doesn't have the safeHead and has a case for []
15:50:54 <Pamelloes> But same idea
15:50:58 <Axman6> ReinH: you apply tortion =)
15:51:43 <Cale> :t safeHead
15:51:45 <lambdabot> [Maybe a] -> Maybe a
15:51:52 <Cale> ^^ the problem :)
15:52:24 <Pamelloes> @let shiftl [] = []; shiftl (x:xs) = xs++x
15:52:25 <lambdabot>  .L.hs:166:25:
15:52:25 <lambdabot>      Occurs check: cannot construct the infinite type: t ~ [t]
15:52:25 <lambdabot>      Relevant bindings include
15:52:26 <erisco> yeah thanks lol
15:52:30 <erisco> @undefine
15:52:31 <lambdabot> Undefined.
15:52:31 <Pamelloes> @let shiftl [] = []; shiftl (x:xs) = xs++[x]
15:52:32 <lambdabot>  Defined.
15:52:47 <erisco> I wanted to get around to asking lambdabot to @pl it
15:52:53 <Pamelloes> > shiftl [1..10]
15:52:54 <lambdabot>  [2,3,4,5,6,7,8,9,10,1]
15:52:59 <Pamelloes> @pl shiftl
15:53:00 <lambdabot> shiftl
15:53:11 <Pamelloes> Oh....
15:53:13 <Pamelloes> right.
15:53:36 <shachaf> Please experiment with lambdabot in /msg, not in-channel, unless you're demonstrating something.
15:53:52 <ReinH> I mean, if you're going to do it that way, why now  shiftl xs = drop 1 xs ++ take 1 xs in f [1,2,3]
15:54:19 <ReinH> *not
15:54:37 <ReinH> It handles both cases.
15:54:43 <erisco> that works :) I have to uncons not safeHead anyways
15:55:03 <erisco> I don't like numbers though
15:55:47 <ginspritic> 23:59 *** NAMES @ChanServ 21WAA0RHZ 7GHAAMJLK [swift] \Harbinger\ ]OLI[ _1126 _5kg __main__ _ashbreeze_ _br_ _deepfire _ether_ _flow_ _ikke_ _jak _rgn _zxq9_ `0660 `^_^v `bps `DanZimm aaron8910 aaronweiss74 aartamonau ab9rf abayley abh absence acfoltzer acharles ad adamse adarc Adeon adimit Adios adlan adnap aerholt AfC aftershave agatam agrif agumonkey agundry ahammel ahf ahihi aivuk ajcoppa akahn akurilin AlainODe
15:55:47 <ReinH> SPJ showed a nice circular list zipper a while ago
15:55:47 <ginspritic> a alang alanz albel727 albertid aleator aleator_ alekst_ alem0lars alevy alinab alkoma aloiscochard alphonse23_ alpounet ambimorph1 amf amiller amiri_ amontez anachron anastas andbroby anders^^_ andjjj23 andreasrx andreass_ andrei andrew__n andrewsw andreypopp__ angelicstrike Angry angryzor_ annulus anry ansible AntiSpamMeta Antoine59 antoine`` Anton antoniy anttih apaku apo_ Apocalisp Aquana ar1416 Arahael araujo a
15:55:47 <ginspritic> rbelos arch_ aristid aristid_ arjanb arrdem arthur_honeynet Artpicre arun__ asabil aseidl ashnur AshyIsMe asjo asm89 asmyers assia_t astrofog Athas Atlanis Auctus augur aupiff aupo avdi Averell avocado Axman6 Azel bananagram banister banjiewen barquentine barrucadu bartavelle bastian__ Baughn bbastian- bcarrell bcoppens bdamos BeardedCoder beauby bel3atar Belgarion00 belst ben__ benbangert benmachine bennyklotz beno
15:55:47 <ginspritic> nsoftware benwf benzrf bergey bergmark bernalex betawaffle bgamari bgamari_ bgyss Bigcheese BillyIII_ billymeter_ bind Biohazard biscarch bitemyapp bitraten bjobjo bjorkintosh bjornars1 bkolera blast_hardcheese BlastHardcheese blenny blicero blicero_ blindscreen_ Blkt BMeph bms1 boegel|work bolmar_ Boney bonobo_ boothead Bor0 Boreeas boris`` brackets bramgg Brando753 brandonw brennie brent80_plow BrianHV brisbin bri
15:55:47 <ginspritic> xen brolin_empey bru`` brurasic brxs bshelden bsmt bsummer4 btc___ Buck buMPnet burp butyoudonot bvad Bwild bydo ByronJohnson c-rog C4Cypher c74d c9sould__ c_wraith caasihuang CADD Cale callumacrae canta capisce CARAM__ carter carter_cloud casual_ Cathy catsup cbaines cchalmers cdidd cdk_ ceii centrinia Cerise cfricke charlie chasecal1 Chathurga chidy chirpsalot ChongLi Chousuke chpatrick chridal chris2 chrisdotcode
15:55:55 <centrinia> What?
15:55:57 <Axman6> ...
15:55:58 <Pamelloes> what?
15:56:02 <Axman6> that was fun
15:56:08 <augur> hurk
15:56:08 <chrisdotcode> Someone crashed their bot?
15:56:20 <burp> more like failed copy & paste
15:56:21 <chrisdotcode> Oh maybe had the wrong thing in their paste buffer.
15:56:27 <chrisdotcode> Poor guy; RIP.
15:56:34 <bernalex> never forget
15:56:36 <bernalex> goodnight, sweet prince
15:56:43 <ReinH> Ah, someone made one https://hackage.haskell.org/package/pointedlist-0.3.5/docs/Data-List-PointedList-Circular.html
15:56:46 <bananagram> man
15:57:13 <erisco> copy & paste is the flame thrower of utilities
15:57:20 <ReinH> Glad they got flood kicked. With 1k+ names that could have taken a while...
15:57:35 <bernalex> erisco: most sane terminal emulators and most sane IRC clients actually make you verify that stuff
15:57:47 <gwywnddyllyd> quick question, slightly OT (maybe): how would you model interaction using algebraic data types? i thought about BNF-grammars but there are some cases where it wouldn't model consistently, at least not without a lot of duplication.
15:57:51 <bernalex> erisco: if I did that, urxvt would say "uhhh u sure u wanna post 3102455361 lines bro?", and then weechat says the same thing.
15:58:02 <ReinH> gwywnddyllyd: "interaction"?
15:58:04 <kadoban> Even my awful IRC client makes me verify.
15:58:05 <Pamelloes> erisco: I don't know, I think flame throwers can be elegant ....
15:58:45 <gwywnddyllyd> ReinH: a sequence of actions a user can undertake through a piece of software
15:59:06 <chrisdotcode> gwywnddyllyd: data Action = Click | Touch | Rub | Fsck | Unzip ....
15:59:10 <chrisdotcode> Er, you get the idea.
15:59:16 <ReinH> If I'm understanding you correctly, you could use a free monad.
15:59:20 <ReinH> @hackage operational
15:59:20 <lambdabot> http://hackage.haskell.org/package/operational
15:59:26 <ReinH> Like that.
15:59:34 <gwywnddyllyd> chrisdotcode: in a simple case - no recursion etc - then that works
15:59:53 <gwywnddyllyd> ReinH: let me take a look into it :)
16:01:13 <bitemyapp> ReinH: what do you use for crypto? I'm looking for AES/CBC/PKCS5Padding right now.
16:01:32 <chrisdotcode> do we not have a bcrypt package on hackage, bitemyapp?
16:01:44 <bitemyapp> chrisdotcode: that's not what I'm asking for.
16:01:45 <athan> cryptol ftw
16:02:07 <ReinH> bitemyapp: We use Vincent's stuff since he works with us.
16:02:11 <chrisdotcode> bitemyapp: What do you need?
16:02:11 <bitemyapp> athan: does that have an AES implementation?
16:02:20 <athan> bitemyapp: It sohuld, but slow :\
16:02:28 <athan> idk if it has a publicly available stdlib
16:02:38 <athan> but the guide teaches you basically everything you need
16:02:50 <ReinH> bitemyapp: e.g., http://hackage.haskell.org/package/cipher-aes
16:02:51 <bitemyapp> ReinH: which library(ies) should I be looking at then?
16:02:56 <bitemyapp> ah, there we go. Thank you.
16:03:38 <ReinH> bitemyapp: http://hackage.haskell.org/user/VincentHanquez
16:03:40 * hackagebot control-monad-free 0.6 - Free monads and monad transformers  http://hackage.haskell.org/package/control-monad-free-0.6 (PepeIborra)
16:03:42 * hackagebot control-monad-free 0.6.0.1 - Free monads and monad transformers  http://hackage.haskell.org/package/control-monad-free-0.6.0.1 (PepeIborra)
16:04:59 <ReinH> bitemyapp: He packages some things up in cryptocypher, cryptohash, etc as well
16:05:41 <Pamelloes> So apparently my client does not check if I paste several thousand lines...
16:05:43 <Pamelloes> Though I still have to press enter afterwords.
16:05:43 <Pamelloes> The more you know.
16:06:42 <dmj`> chrisdotcode: there's scrypt on hackage
16:07:49 <chrisdotcode> dmj`: Would you know offhand which encryption schemes the big frameworks happen to use?
16:11:02 <dmj`> chrisdotcode: snap uses pwstore-fast IIRC, based on cryptohash. It uses PBKDF1-SHA256, unsure about others
16:11:21 <chrisdotcode> Huh.
16:11:22 <chrisdotcode> Well thanks.
16:11:34 <timds> I have a problem when using Data.Text.Lazy.IO to read in a file lazily with hGetContents. I am then using `lines` and then folding over the list, then printing out a final datatype. This works fine if I have a `print txt` just after `txt <- hGetContents h` but if I remove the print statement then the text is never read. Does anyone know offhand what could be happening here? Some sort of laziness issue..
16:12:05 <glguy> timds: You aren't manually closing the handle, are you?
16:12:21 <glguy> or using hGetContents with a handle closed by withFile, etc?
16:12:35 <dmj`> chrisdotcode: does that help?
16:12:36 <timds> No, I'm using `withFile ... $ \h -> do ...`
16:12:54 <biscarch> dmj`: snap does use pwstore-fast
16:12:55 <glguy> timds: That's the bug, you shouldn't use withFile with hGetContents
16:13:04 <glguy> hGetContents is lazy and it closes the handle when it's done with it
16:13:10 <dmj`> biscarch: ah good
16:13:23 <timds> Ah, so the file is only lazily being read after the return from the function using withFile, by which time the handle is closed
16:13:29 <chrisdotcode> dmj`: Was just curious - and was likely ready to open issues on all of the ones using bad schemes.
16:13:36 <timds> Thanks very much
16:13:41 * hackagebot aws-kinesis-reshard 0.1.0.1 - Reshard AWS Kinesis streams in response to Cloud Watch metrics  http://hackage.haskell.org/package/aws-kinesis-reshard-0.1.0.1 (JonSterling)
16:13:45 <benmachine> it's important to be clear that hGetContents is lazy IO, which is different from normal laziness
16:14:08 <benmachine> lazy IO is weird and confusing, as you've just found out, normal laziness is generally much more consistent in its behaviour
16:14:15 <Cale> timds: That's what Data.Text.Lazy is all about: the file is only read as needed.
16:14:41 <Cale> timds: You should never explicitly close a file handle which has been given to hGetContents
16:14:46 <timds> Yes, I suppose I thought that the 'unsafe interleaving' would somehow keep the handle alive long enough
16:14:50 <Cale> So you shouldn't use withFile
16:15:22 <Cale> Instead, use openFile, and let hGetContents close the file when either the string is garbage collected or you reach the end of the file.
16:15:53 <timds> I see, I just reread the docs; woops!
16:18:13 <glguy> timds: and if you're just using openFile directly followed by hGetContents, there's a function you can use called "readFile" that wraps that all up into one
16:19:17 <dmj`> probably better to use a streaming library when doing any kind of I/O
16:19:48 <ReinH> dmj`: "any kind"? Nah.
16:20:10 <jophish> Why doesn't there exist a function in Data.Vector peekVector :: Ptr a -> Int -> IO (Vector a)
16:20:22 <timds> Thanks glguy, should just use that readFile. I played around with conduit but thought I should understand the basic ways first
16:20:40 <jophish> which does the obvious thing, copies that many a's into a new block of memory and hands that the a vector
16:21:21 <Axman6> so you can interract with data from C
16:21:38 <Axman6> oh, why doesn't there
16:22:09 <jophish> exactly this: https://github.com/basvandijk/usb/blob/master/Utils.hs#L76
16:23:47 <Axman6> I wouldn't call that exactly an obvious implementation btw. I'd imagine there are several possible implementations; using at least no copying, and copying, and ForeignPtr support could be useful too
16:24:15 <jophish> Axman6: there's already a function that takes a ForeignPtr
16:24:43 <jophish> How could you do it with no copying?
16:25:26 <Axman6> by referencing the pointer directly
16:26:38 <Axman6> but it's probably unsafe to do without using a ForeignPtr
16:26:53 <jophish> yeah, the Ptr could go out of scope at any time
16:27:03 <jophish> more unsafe than a function already marked unsafe
16:27:53 <Axman6> well, you could always suggest it to the maintainer. Is that still Roman?
16:28:27 <jophish> Vector is a very mature library, so I'm sure there's a good reason this isn't in there
16:28:41 * hackagebot olwrapper 0.3.8 - An OpenLayers JavaScript Wrapper and Webframework with snaplet-fay  http://hackage.haskell.org/package/olwrapper-0.3.8 (tomnobleman)
16:29:03 <Axman6> the reason is just as likely to be "Because no one ever suggested it"
16:29:20 <benmachine> very mature libraries can still have things missing
16:31:24 <dmj`> ReinH: maybe not the (liftIO . putStrLn) kind of I/O, but reading files maybe
16:32:35 <jophish> https://github.com/haskell/vector/issues/68
16:49:51 <Pamelloes> Is there a function ([a],[b]) -> [(a,b)]? Hoogle didn't turn up anything
16:50:14 <shachaf> uncurry zip
16:50:32 <BMeph> Pamelloes: ...what shachaf said.
16:50:40 <Pamelloes> Awesome!
16:50:55 <Pamelloes> How about going the opposite direction?
16:51:02 <Cale> unzip
16:51:21 <Pamelloes> thanks :)
16:56:28 <meditans> hi all, I have a question about cabal usage
16:56:36 <benzrf> meditans: go on
16:56:55 <horny-sama> meditans: what distro?
16:57:06 <meditans> I have cabal 1.22 installed, but for reasons of compatibility with ghc-mod, I want to use cabal 1.20
16:57:11 <benzrf> > sequenceA ("hi", "cool")
16:57:12 <lambdabot>  Not in scope: ‘sequenceA’
16:57:13 <lambdabot>  Perhaps you meant one of these:
16:57:13 <lambdabot>    ‘T.sequenceA’ (imported from Data.Traversable),
16:57:16 <benzrf> > T.sequenceA ("hi", "cool")
16:57:18 <lambdabot>  [("hi",'c'),("hi",'o'),("hi",'o'),("hi",'l')]
16:57:18 <meditans> horny-sama: nixOS, that's part of the problem xd
16:57:28 <meditans> so, I use the command cabal configure --cabal-lib-version=1.18.1.5
16:57:29 <benzrf> meditans: have you tried asking #nixos
16:57:38 <horny-sama> meditans: never heard of it before
16:57:52 <horny-sama> if you are not using major distros and chances of support is slim :<
16:57:53 <meditans> benzrf: yes, the nixos part is solved, I want to know something about cabal
16:57:54 <benzrf> meditans: i feel like managing versions of nix packages is their area of expertise :b
16:57:57 <benzrf> meditans: ah
16:58:01 <benzrf> ok, sorry
16:58:33 <meditans> benzrf: np, so I'm using that command to configure my package as if I'm using cabal 1.18
16:58:44 <meditans> benzrf: the command being cabal configure --cabal-lib-version=1.18.1.5
16:59:24 <meditans> benzrf: now, the question: is there a way to build or get a repl with cabal in the same way, id est, like in 1.18?
16:59:41 <meditans> benzrf: cabal build --cabal-lib-version=1.18.1.5 does not work
17:00:00 <benzrf> i have no clue, im shit at cabal :\
17:00:54 <meditans> benzrf: ok, thanks anyway. It's a pretty obscure question, in fact. I didn't know I could use cabal configure in that way before people showed me, so
17:01:53 <meditans> benzrf: is here any cabal dev I could ask, here (I'm not posting this question in a mailing list because I suspect that the answer is no, and would like a quick check)
17:01:57 <meditans> ?
17:02:31 <glguy> Meditans: I would try listing the version of cabal in your build depends if you want it to show up in cabal repl
17:03:08 <meditans> glguy: what do you mean?
17:03:58 <meditans> glguy: I mean, could you clarify better?
17:04:40 <meditans> glguy: in my .cabal file, I have cabal-version >=  1.10
17:05:22 <SrPx> why linear defines so many typeclasses? For example, https://hackage.haskell.org/package/linear-1.16.1/docs/Linear-Epsilon.html - what is the need for this?
17:05:34 <glguy> Cabal repl provides an environment with your library or executable loaded along with its dependencies
17:05:51 <Cale> SrPx: Well, have a look at the instances
17:06:04 <glguy> So if you want Cabal to show up there, add it to your build-depends: list
17:06:31 <glguy> The cabal-version field just tells cabal which features it should be using
17:06:34 <SrPx> Cale: I don't get it, the point is using different epsilons for double/float?
17:06:36 <Cale> SrPx: Whenever you're dealing with approximate quantities, it's generally important not to test for equality
17:06:46 <Pamelloes> So I wrote an unfilter method to integrate a filtered section of a list back into the original. Does this look right?
17:06:49 <lpaste> Pamelloes pasted “unfilter” at http://lpaste.net/118965
17:06:54 <Cale> So having a way to see whether the difference between things is close to zero is useful
17:07:26 <shachaf> When you're dealing with real numbers, it's not even possible!
17:07:29 <Cale> Of course, there are many different sorts of types on which such an operation might be provided, and this class handles it for many of them.
17:08:18 <Cale> It's not just Float and Double, but also various sorts of vectors and quaternions and other things.
17:08:43 <kirill_> SrPx: Linear.Epsilon seems like a thin wrapper around some magical values like 1e-6 and 1e-12
17:08:43 <kirill_> https://hackage.haskell.org/package/linear-1.16.1/docs/src/Linear-Epsilon.html#Epsilon
17:08:43 <kirill_> So I think the author just wants to use the same function name for Float, Double, CFloat, CDouble
17:08:49 <meditans> glguy: ok, so I can add Cabal == 1.18.1.5 in my build-depends list, and then invoke the repl just with cabal repl?
17:09:09 <glguy> Should work
17:09:12 <meditans> glguy: that invocation would work like in Cabal 1.18/
17:09:24 <meditans> glguy: thanks, I'll try that in a few minutes
17:10:25 <kirill_> SrPx: this makes the code cleaner, if you remember what the typeclasses are for, and what the defined instances are.
17:10:43 <Cale> inv33 :: (Epsilon a, Floating a) => M33 a -> Maybe (M33 a)
17:11:38 <Cale> So, for example, that'll even work for a 3x3 matrix of Quaternions built from Floats
17:12:56 <Cale> See also:
17:12:58 <Cale> normalize :: (Floating a, Metric f, Epsilon a) => f a -> f a
17:12:58 <Cale> normalize v = if nearZero l || nearZero (1-l) then v else fmap (/sqrt l) v
17:12:58 <Cale>   where l = quadrance v
17:13:59 <Cale> Other operations which use this also get Epsilon constraints
17:14:05 <Cale> axisAngle :: (Epsilon a, Floating a) => V3 a -> a -> Quaternion a
17:14:05 <Cale> axisAngle axis theta = Quaternion (cos half) (sin half *^ normalize axis)
17:14:05 <Cale>   where half = theta / 2
17:15:27 <SrPx> yes this makes sense for me, thanks. I'm stil a little worried that my types are growing to insane things like: "(Floating a, Enum a, Unbox a, Conjugate a, RealFloat a, Epsilon a)"
17:15:33 <SrPx> all that to express: "a is a number"
17:15:50 <horny-sama> after 1 week ish of learning haskell, I still feel like I know nth :<
17:15:59 <Cale> horny-sama: Completely normal
17:16:11 <Cale> horny-sama: It took me two months to feel like I could do useful things
17:16:14 <horny-sama> Cale: but I have a haskell hw due on feb 6
17:16:15 <horny-sama> :<
17:16:20 <horny-sama> so it is not normal :<
17:16:29 <Cale> Well, learn enough to do the homework :)
17:16:33 <glguy> SrPx: You can pick a concrete type if the constraints get unweildy
17:16:40 <horny-sama> Cale: trying
17:16:45 <SrPx> 1 week learning javascript I made a perfect working clone of megaman 3. A few years in Haskell and I'm still trying to make a circle on the screen C:
17:16:47 <Pamelloes> horny-sama: February 6 is relatively far away, you're in good shape :)
17:16:58 <Cale> What sort of stuff does the homework have you doing? If it's well designed, it shouldn't be anything too crazy :)
17:17:02 * SrPx is exagerating don't ban me
17:17:11 <horny-sama> SrPx: js is okay
17:17:12 <Cale> But yeah, that's a month, you have lots of time :)
17:17:27 <Cale> er, not quite :)
17:17:29 <horny-sama> Cale, Pamelloes: is not a month it is jan 21 atm
17:17:29 <SrPx> horny-sama: I don' think so :(
17:17:29 <shachaf> Feb 6 is very far away. Might as well wait until Feb 5 evening.
17:17:38 <Cale> yeah, heh
17:17:42 <horny-sama> SrPx: you have prior programming experience?
17:17:45 <liyang> +1 shachaf
17:17:45 <horny-sama> it is just like java
17:17:47 <horny-sama> +c
17:17:47 <glguy> shachaf: it's probably not due that morning
17:17:48 <kirill_> SrPx: if you need long lists of typeclasses, you can make an empty typeclass of your own:
17:17:49 <kirill_> class (Constraint1 a, ..., ConstraintN a) => YourRealNumber a where
17:17:50 <Cale> couple good weeks anyway :)
17:17:54 <SrPx> horny-sama: wow no it is not
17:18:07 <SrPx> kirill_: ah that is neat, thanks :D
17:18:17 <shachaf> whoa, hi liyang
17:18:29 <liyang> SrPx: I think we have constraint synonyms now too...
17:18:30 <kadoban> horny-sama: …Yeah JS is /very/ not like C/C++/Java. It just vaguely looks like them.
17:18:31 <horny-sama> Cale: plus I am not motivating recently, teaching erotica atm
17:18:32 <horny-sama> :P
17:18:45 <Pamelloes> kadoban: More than vaguely
17:19:01 <horny-sama> kadoban: I am reading off eloquent js and I found it just like java + c
17:19:03 <liyang> Hi shachaf. You seem surprised to see me. I haven't gone anywhere. :)
17:19:18 <systemfault> JavaScript is an C-ified, ugly version of Self. :/
17:19:53 <kadoban> horny-sama: Almost nothing translates, except what the syntax looks like.
17:19:58 <SrPx> I love JavaScript due to the fact I can make actual stuff that runs everywhere with it. I profundly hate the language, though. But it has first-class lambdas, so it is still above 90%... but you can't really abuse them in inner loops, it gets slow
17:19:59 <Cale> The creative process: http://i.imgur.com/CdQGyQO.jpg
17:20:20 <horny-sama> systemfault: knowing both c and java, I think js is not that bad
17:20:34 <kirill_> SrPx: also, see -fwarn-duplicate-constraints, helpful if some of you constraints might be duplicates
17:20:35 <kadoban> It's kind of a fun language. It's not exactly pretty though.
17:20:41 <horny-sama> SrPx: I hate oop in general
17:20:42 <horny-sama> so...
17:20:50 <SrPx> kirill_: duplicates?
17:21:10 <Pamelloes> Cale: so true. The best work is done after 18-20 hours of being awake and hopped up on caffeine.
17:21:36 <systemfault> Cale: Your image is pretty accurate.
17:22:08 <kadoban> It'd be more accurate if deadline was farther to the left…
17:22:19 <SrPx> anyone else has that feeling in Haskell that you know 10000 ways to do something, but you don't know which one to pick getting yourself into a decision paralysis spiral?
17:22:30 <horny-sama> Pamelloes: best work is done after watching porn + fap + nap
17:22:38 <SrPx> for example, seems like I have to write an octree type, since you guys didn't do it yet :(
17:23:12 <ReinH> SrPx: Find a quadtree package and do everything twice as much? ;)
17:24:24 <SrPx> and I got stuck at least several hours wondering how I'd represent the list of children... should it be a list? But vectors are faster. But if I chose a vector, then I have to settle for one of the 4 vector types...
17:24:33 <Zemyla> Who here knows how a Data instance would be derived from the GADT described here? http://okmij.org/ftp/Haskell/SetMonad.hs
17:24:43 <mmachenry> SrPx: We talked the other day about making a new prelude.
17:24:45 <SrPx> no, wait, maybe I can have some kind of generic structure that can allow the user to chose between using lists, or vectors, or..
17:24:58 <SrPx> mmachenry: yes why
17:25:03 <mmachenry> I found this after you left: https://hackage.haskell.org/package/classy-prelude
17:25:11 <mmachenry> So there you go.
17:25:12 <kadoban> SrPx: Usually you should just pick one…and try to leave it open so you can change it if you need to.
17:25:22 <Zemyla> SrPx: If you can't decide betweem a list and a vector, use a Seq.
17:25:50 <ReinH> Cale: That jpg is amazing. Who is that?
17:26:11 <mmachenry> SrPx: That's an example of a library that's totally redefining the prelude. To use it I image you need to use the language pragma to not include the normal prelude and then import that.
17:26:41 <SrPx> the point is, I don't feel like I should be using solid types like that, the ideal is using something generic with just the operations I need. But I get confused in how to do it properly in Haskell. kadoban Zemyla why seq?
17:26:51 <Cale> ReinH: That's Drew. He's responsible for a webcomic called Toothpaste For Dinner, as well as Married to the Sea and a bunch of other stuff.
17:26:57 <SrPx> mmachenry: sounds cool, trying to get it
17:26:59 <ReinH> Cale: cool.
17:27:59 <Zemyla> SrPx: Unlike List, Seq has efficient composition and lookup, and unlike vector, Seq has efficient mutation.
17:29:37 <SrPx> Zemyla: ah I see. But you mean using seq inside my own structure? That is: "data Quadtree a = Node { a,b,c,d,e,f,g,h :: Quadtree a } | Leaf { elements :: Seq a }"
17:29:51 <liyang> Are you serious? Seq might be faster in the asymptotic sense but it's got a pretty hefty constant factor...
17:30:07 <SrPx> but what if an user prefers a List, you know? Or a vector. So he can't use my Quadtree. That sounds like horrible code
17:30:37 <SrPx> and the "a,b,c,d,e,f,g,h :: Quadtree a" thing is horrible too, ideally it should be a dependent type on the dimension of the coordinates
17:30:43 <liyang> SrPx: you need to think about how long your `elements` typically are.
17:31:29 <athan> Does >> have to be forgetful?
17:31:53 <SrPx> what I am trying to say is: I want to define a function that create the type based on: 1. the type of the structure to hold the children. 2. the number of dimensions. from those, it would create a proper representation with functions accepting 2D, 3D, 4D vectors
17:31:59 <SrPx> I'd do that in Lisp with a macro. No idea in Haskell
17:32:08 <Zemyla> athan: >> knows at least something of what's on the left side.
17:32:17 <Zemyla> > Nothing >> undefined
17:32:18 <lambdabot>  Nothing
17:32:29 <SrPx> liyang: I don't think I can foresaw that for an all purpose structure
17:32:39 <Hijiri> athan: ma >> mb has to be equal to ma >>= const mb
17:32:40 <SrPx> creates*
17:32:52 <athan> hmm, alright thanks guys
17:33:09 <athan> I'm just wondering how libs like Blaze actually aggregate the expressions if it's forgetful
17:33:13 <athan> hmm
17:33:19 <athan> wait a tic
17:33:30 <athan> so >> is "forgetful" only in the parameter, and not the monad, right?
17:33:36 <Zemyla> > [1, 2] >> [3, 4, 5]
17:33:37 <lambdabot>  [3,4,5,3,4,5]
17:33:59 <athan> Zemyla, Hijiri : Beautiful :) Thank you dearly!!
17:33:59 <liyang> SrPx: there comes a point where you just have to pick something and worry about pleasing everyone else later.
17:34:46 <liyang> Try to make it easy to switch around, then benchmark, benchmark, benchmark. :)
17:35:44 <kadoban> Largely what you use won't even be visible to your users anyway, will it? I didn't look much at what data structure you're implementing, but in general…
17:35:50 <Zemyla> SrPx: Try to define what needs to be done to the parameters, and see if any existing classes (such as Foldable) satisfy the requirements.
17:41:28 <Zemyla> Also, if the number of dimensions is specifiable, then make it a type parameter using Peano numbers.
17:43:06 <athan> ...is there a school of thought where spatial dimensions (like 2d and 3d) aren't natural numbers, but rather continuous?
17:43:26 <Zemyla> Fractals? :P
17:43:44 <athan> Because I think it would be nice for realizing + ~ *
17:43:51 <athan> Zemyla: O-O
17:43:55 <Zemyla> And Peano numbers *are* natural numbers. Zero, Succ Zero, Succ (Succ Zero), and so on.
17:44:00 <athan> Doesn't `e` do something like this?
17:44:49 <athan> Because `integral(e ^ x) ~ e ^ x` or something
17:47:40 <davean> Exception already requires Typeable, would there be an issue with also having Data?
17:48:08 <shachaf> Hmm, why do you want Data?
17:49:46 <davean> shachaf: because I want to know the constructor
17:49:56 <davean> shachaf: So I can talk about what exception happened
17:50:19 <davean> Note if I show it, I don't necissarily get ANY information (see Assertion)
17:50:52 <davean> but, I want to talk about which classes of errors are occuring, not what data they contain
17:51:31 <trap_exit> is there a good tutoril on te following: (1) using Fay, write some data declarations that both Fay + Haskell uses (2) get Fay to talk to haskell (server0 bia websocket, and (3) have the above data types auto convert to json and auto decode form json ?
17:52:35 <EvanR> what are the prospects for being able to reload part of a haskell program after the code is changed
17:52:42 <EvanR> split up the program into different programs?
17:53:00 <shachaf> davean: How does that help you in general?
17:53:08 <zomg> trap_exit: iirc https://github.com/faylang/snaplet-fay has that stuff in it, I remember asking the same thing sometime last year and being directed at this by bergmark or someone
17:53:09 <shachaf> davean: If you know which specific type it is, you can just match on it.
17:53:20 <shachaf> But just knowing that it's Data doesn't tell you that much.
17:55:36 <davean> shachaf: But I don't
17:55:36 <davean> shachaf: Exceptions is an open universe
17:55:36 <shachaf> Right, so what do you do with the Data instance? Just show it to the user?
17:55:36 <davean> shachaf: Hum?
17:55:36 <shachaf> I mean, with the constructor.
17:55:37 <davean> shachaf: I have Typeable so I can get the type
17:55:37 <davean> type+constructor tells me a lot
17:55:37 <davean> No
17:55:37 <davean> I can use "Show" to show it to the user
17:55:37 <davean> I want Data so I can process it
17:55:37 <trap_exit> zomg: did you ever get it to work? or did you look at it, go WTF, and go do something else?
17:55:37 <trap_exit> zomg: Automatically encode/decode records shared between Snap and Fay by using the fayax functions.
17:55:37 <trap_exit> I like
17:56:04 <zomg> trap_exit: yeah I figured it out from it. The data thing is reasonably straighforward, then it's just a matter of calling the correct functions to convert
17:56:18 <shachaf> What processing are you doing?
17:56:29 <davean> shachaf: for one, processing how different the exceptions are
17:56:34 <shachaf> (I'm not saying it's a bad idea, just wondering.)
17:57:28 <trap_exit> zomg: this looks really nice
17:57:38 <davean> shachaf: one example is I auto-file tickets based on the trace throguh the code to the location the exception was thrown, and its type. The types of Exception are *terrible* for this, the *constructors* are the correct seperation.
17:57:38 <trap_exit> zomg: however, I don't see the websocket part of this -- does this also use websocket?
17:57:48 <zomg> don't think it does
17:57:52 <davean> shachaf: but, say, I have an Index exception on an array, I can't care WHICH location was over
17:58:03 <davean> not at the ticket level, though I might file those details
17:58:09 <davean> thats the easy to understand example
17:58:21 <benzrf> davean: arent you the xkcd sysadmin o.O
17:58:30 <benzrf> wait i feel like ive seen you and asked before
17:58:31 <davean> shachaf: but, in general, it is VERY useful for programs to understand how they went wrong
17:58:42 <shachaf> davean: Ah. OK.
17:59:05 <davean> shachaf: if exceptions were single-constructor, I'd not be asking mind you
17:59:10 <shachaf> Data is much more restrictive than Typeable, but maybe not in a way that's relevant for Exception.
17:59:51 <davean> shachaf: https://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Exception.html#t:ArrayException <-- Ruins the use of typable
18:00:02 <shachaf> You mean standard exception types like ArithException and ArrayException?
18:00:15 <davean> shachaf: yes, and https://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Exception.html#t:AsyncException
18:00:21 <davean> based on Typeable
18:00:29 <shachaf> As a hack you could just check for those specific types.
18:00:33 <shachaf> But I can see why you want it.
18:00:39 <davean> shachaf: no, they're infinite
18:00:52 <davean> I litterly do not know what I might get
18:01:43 <athan> Hmm... so I'm finding myself wanting a `return` that does a no-op. Is this legit, so long as
18:01:48 <athan> erm
18:01:50 <athan> scratch that
18:01:52 <shachaf> Sure, but the types in base would cover a lot, and for your own exception types you can use more fine-grained types or something.
18:02:06 <athan> would a monoid at the type level be a poly-oid?
18:02:07 <davean> shachaf: No, everyone defines their own exceptions
18:02:14 <davean> shachaf: There is no end of new excpetions one finds
18:02:23 <athan> or really
18:02:23 <davean> shachaf: base has almsot none of the exceptions
18:02:26 <athan> would a type-level list be a polyoid?
18:02:36 <shachaf> OK.
18:03:07 <benzrf> athan: probs not
18:03:10 <shachaf> As another hack, you could find a way to check the tag without a Data constraint. :-) But that's pretty awful.
18:03:17 <shachaf> I don't know whether anyone uses non-Data exceptions.
18:03:31 <benzrf> athan: a functor-level monoid under composition instead of pairs is a monad ;)
18:05:00 <horny-sama> https://github.com/kqr/kqr.github.com/tree/master/_posts <---I like learning haskell from it
18:05:07 <athan> benzrf: So the mon in monoid is just "central idea" or "tractible thing"?
18:05:13 <athan> benzrf: Also, holy crap
18:05:29 <benzrf> athan: heck if i know
18:05:39 <athan> benzrf: CMON
18:05:45 <benzrf> athan: a monad is just a monoid in a category of endofunctors ;)
18:05:53 <athan> :<
18:06:15 <benzrf> athan: i think the "mon" might refer to the identity element
18:06:21 <benzrf> like a single identity
18:06:23 <benzrf> or uh
18:06:27 <benzrf> i dunno
18:06:44 <athan> hrm
18:06:50 <athan> or single operation?
18:06:52 <benzrf> idk
18:06:57 <benzrf> google it
18:07:17 <athan> benzrf: I'm thinking like this: a type-level list might be a polyoid
18:07:21 <horny-sama> what happen?
18:07:35 <athan> horny-sama: Comcast
18:07:48 <horny-sama> athan: comcast is an isp
18:07:56 <horny-sama> it has nth to do with freenode?
18:08:20 <athan> horny-sama: ...I'm gonna keep my prejudice >:c
18:08:27 <athan> (idk though sorry :\)
18:09:12 <athan> Are there any *->*->* kinded monad-like things?
18:09:19 <athan> ...yet?
18:09:39 <kadoban> athan: What is a "monad-like thing"?
18:09:50 <athan> >_>
18:10:03 <davean> benzrf: you ask these things from time to time, yes
18:10:45 <benzrf> haha, sorry :p
18:10:55 <athan> davean: But not during the new moon phase.
18:11:11 <benzrf> athan: have you ever looked into the categorical definition of a monoid object
18:11:18 <benzrf> its a pretty nice generalization
18:12:50 <athan> benzrf: I'm pretty certain my structure forms a heterogeneously typed monoid
18:12:57 <athan> it's a directed acyclic graph
18:13:03 <athan> where the edges are encoded in the type
18:13:31 <athan> mempty is just an empty graph, and mappend is just the union of edges and overwritten nodes (if there are clashing keys)
18:26:04 <benzrf> athan: do you understand what a monoid is >.>
18:26:27 <athan> benzrf: It's a tractible main idea I'm tellin ya
18:26:33 <benzrf> whaa
18:26:46 <benzrf> a monoid is a structure with an associative binary operation and an identity element
18:26:58 <benzrf> nothing to do with main ideas
18:26:59 <ddellacosta> based on just that response I would assume athan is a bot
18:27:06 <ddellacosta> I rather enjoyed it
18:27:08 <benzrf> ddellacosta: haha
18:27:09 <athan> I'm not a BEEEP{
18:27:12 <ddellacosta> heh
18:27:52 <athan> benzrf: Do you know of any non-monoid instances that are conceptual monoids in haskell?
18:28:15 <athan> benzrf: What about single-object category?
18:28:38 <athan> don't the domain and codomain of the associative binary op need to be the same?
18:28:47 * hackagebot warp 3.0.6 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.6 (KazuYamamoto)
18:28:50 <benzrf> athan: in general yes
18:28:57 <athan> WOO
18:29:01 <benzrf> athan: what kind of monoid do you mean
18:29:12 <athan> *-kinded
18:29:22 <athan> er
18:29:22 <benzrf> athan: like monoids as in monoid objects from cat theor?
18:29:37 <athan> I think so :s
18:29:46 <benzrf> well, any monad is a monoid :p
18:31:07 <benzrf> athan: how much category Theory do you know
18:31:22 <athan> benzrf: All of it lol
18:31:29 <benzrf> seriously now
18:31:30 <athan> (I'm a dumbass :<)
18:31:44 <athan> I can't descript CT in terms of CT yet :\
18:31:47 <benzrf> not knowing something doesnt make you a dumbass, not knowing something and refusing to admit it makes you a dumbass
18:31:50 <athan> describe*
18:32:42 <athan> benzrf: Hold on, I'm gonna literally puke out my guts
18:33:49 <athan> benzrf: Wouldn't that destroy awareness in general?
18:33:49 <athan> or the soundness / tractability of awareness?
18:33:54 <benzrf> athan: well do you know what a category is
18:33:54 <benzrf> o.O
18:34:08 <athan> I think so!
18:35:06 <athan> It's a directed graph populated with reflexive edges, and colliding transitivity means diagrams commute?
18:35:16 <athan> (sometimes denoted by a smiley face?)
18:35:38 <benzrf> :-o
18:35:50 <benzrf> athan: that's wrong :[
18:35:53 <benzrf> athan: i had the same misconception
18:36:01 <athan> !!!
18:36:11 <benzrf> athan: i dont suppose you read something about category theory from wikibooks did you
18:36:14 <athan> benzrf: Rip the bandaid, MAKE IT BURN
18:36:25 <athan> :\
18:36:29 <Cale> A category C consists of the following:
18:36:45 <benzrf> Cale noo
18:36:54 <athan> :D
18:36:59 <benzrf> athan: first off
18:36:59 <Cale> Would you prefer to do the definition yourself?
18:37:08 <benzrf> Cale: i was gonna kind of lead up to the motivation
18:37:08 <benzrf> :p
18:37:34 <benzrf> athan: have you ever seen the Endo monoid
18:37:46 <athan> benzrf: Not yet!!
18:37:55 <benzrf> ah, well
18:37:58 <benzrf> it's fairly simple
18:38:06 <athan> so that's just a monoid where domain ~ codomain??
18:38:09 <benzrf> yeah
18:38:13 <athan> ahh okay
18:38:17 <athan> oh shit
18:38:21 <athan> sorry
18:38:23 <athan> umm
18:38:31 <benzrf> ?
18:38:58 <athan> hmm
18:39:02 <athan> sorry
18:39:07 <benzrf> go on
18:39:16 <athan> ...equivalence?
18:40:09 <athan> benzrf: Please continue :(
18:40:24 <benzrf> oh
18:40:25 <benzrf> soz
18:40:31 <benzrf> ok
18:40:35 <athan> haha
18:40:49 <benzrf> any given endo monoid has an obvious limitation
18:40:58 <benzrf> namely, that you're constrained to functions of a single type
18:41:06 <Cale> I really kind of feel like putting the whole definition on the table so that we can start to look at examples in a coherent way...
18:41:17 <benzrf> apart from that, Monoid is a pretty good abstraction for function composition
18:41:26 <benzrf> you have associativity, like in composition
18:41:37 <benzrf> and you have identity, like in composition
18:41:57 <benzrf> but every element must be able to be combined with every other element, UNLIKE compositoin
18:42:14 <shachaf> #haskell-overflow would be better for this conversation at this point, I think.
18:42:22 <shachaf> It's taking up a lot of vertical space.
18:42:30 <athan> benzrf: Makes perfect sense - monoid is a 1-object category, right?
18:42:35 <benzrf> pretty much
18:42:39 <athan> ahh nice
18:42:47 <benzrf> athan: categories are what you get if you assign each element of the monoid a type and then decree that you can only combine elements with the right types
18:42:53 <benzrf> objects dont matter
18:42:58 <benzrf> objects are just the types you assign morphisms
18:43:00 <athan> perfect
18:43:15 <benzrf> what you're interested in are the morphisms and the composition operator
18:43:18 <athan> benzrf: They are the method to distinguishability, though!
18:43:25 <benzrf> athan: wha?
18:43:35 <athan> benzrf: ...equivalence? :s
18:43:43 <benzrf> i am not sure what you mean
18:43:47 <platz> I've never quite understood the 1-object definition of monoid.  clearly inside the monoid there must be more objects, but then which category are we talking about
18:43:59 <benzrf> platz: clearly a sign of object obsession
18:44:03 <benzrf> forget the objects!
18:44:06 <benzrf> objects are just types
18:44:11 <Cale> Okay, let's do the definition already
18:44:12 <athan> But... but...
18:44:12 <benzrf> morphisms are the true elements of a category
18:44:17 <benzrf> Cale: indeed!
18:44:20 <benzrf> Cale: go ahead, if you like
18:44:24 <Cale> This is getting too vague and weird :)
18:44:25 <shachaf> platz: "object" is a misleading word. Where category theory says "object" you can often imagine that it says "type", or something very similar.
18:44:32 <shachaf> platz: The arrows are the concrete things in a category, not the objects.
18:44:38 <Cale> Okay, so in order to define a category, you must provide the following things:
18:44:40 <shachaf> But I really recommend taking this conversation to #haskell-overflow.
18:44:43 <athan> it's a reference!
18:44:45 <athan> the objects
18:44:58 <athan> I'm down
18:45:08 <Cale> First: a collection Ob(C) of "objects". These can be anything you'd like.
18:45:20 <benzrf> nothing contrains them to be types in a conventional senes
18:45:30 <benzrf> when i said they were types i just mean that they're used to coordinate how the morphisms compose
18:45:39 <athan> benzrf: Or even a kind
18:45:41 <benzrf> er, which morphisms are allowed to compose
18:46:06 <Cale> Secondly, for any objects X and Y in Ob(C), a collection C(X,Y) of arrows from X to Y. When a is in C(X,Y), we write a: X -> Y
18:46:45 <benzrf> an alternate way of thinking of it is that you have one giant collection of arrows and then rules that assign each arrow a source and a target
18:46:50 <athan> Cale: This isn't the HOM set, is it?
18:47:05 <Cale> Yes, this is also written Hom(X,Y)
18:47:13 <athan> benzrf: _rules_ - that's cray :O
18:47:13 <benzrf> athan: C(X, Y) is often denoted Hom(X, Y) (or Hom_C(X, Y) if it's unclear what category)
18:47:21 <athan> Cale: !!! Okay!
18:47:23 <benzrf> athan: well, look at haskell
18:47:28 <athan> okay
18:47:41 <athan> benzrf: that's homomorphism?
18:47:43 <benzrf> athan: on the one hand you can say that for any 2 types (like Int and String) there's a set of functions between them (all the functions Int -> String)
18:47:48 <benzrf> athan: no, dont worry about it
18:47:48 <athan> or does it have to be linear?
18:48:00 <athan> ahh okay
18:48:17 <benzrf> athan: on the other hand you can say that there's one giant set of haskell functions, plus for any given function you can identify it as having a type Thing -> OtherThing
18:48:20 <benzrf> athan: either one works
18:48:31 <Cale> Thirdly, for any three objects X, Y, Z in Ob(C), and arrows g: X -> Y and f: Y -> Z, a choice of composite arrow f . g: X -> Z
18:48:46 <benzrf> this is the category operation^
18:48:57 <athan> Perfect
18:48:58 <benzrf> it's like a monoid operation, except it only works when your arrows/morphisms have the right types
18:49:00 <Cale> These are subject to the following:
18:49:12 <horny-sama> https://github.com/mr-fool/haskell/blob/master/female/female.hs <---can someone give me a hand
18:49:31 <horny-sama> I don't know what I did wrong in the function calling part
18:49:34 <athan> benzrf: A heterogeneous monoid satisfying unification of objects for composition?
18:49:39 <athan> alright
18:49:43 <athan> you guys are badasses
18:49:49 <benzrf> athan: sort of
18:50:06 <Cale> The existence of identity arrows: For each object X, there is an arrow id_X: X -> X such that for any f: X -> Y we have f . id_X = f, and for any g: Y -> X, we have id_X . g = g
18:50:22 <benzrf> ^category identities, like monoid identity
18:50:29 <benzrf> read the law carefully
18:50:40 <horny-sama> Cale: help?
18:50:47 <benzrf> horny-sama: well
18:50:52 <Cale> Associativity of composition: For any four objects X, Y, Z, W, and arrows h: X -> Y, g: Y -> Z, f: Z -> W, we have that f . (g . h) = (f . g) . h
18:50:53 <athan> !! woah okay
18:51:13 <benzrf> horny-sama: what type does "uppercase guess" have?
18:51:37 <Pamelloes> horny-sama: It's imporant to understand in haskell that there are no variables like in an imperative language. "guess" is a constant after defined, so you can't change the value of "guess" directly.
18:51:40 <Cale> Any way of specifying the objects arrows and composition which satisfies these laws is a category.
18:51:48 <horny-sama> benzrf: guess is of string type?
18:51:55 <benzrf> horny-sama: yes
18:52:04 <horny-sama> Pamelloes: then how can I work on it?
18:52:11 <benzrf> athan: here's an example of a category that obeys those laws but isnt anything like Hask
18:52:20 <benzrf> athan: let the set of objects be the natural numbers
18:52:45 <benzrf> athan: let the set of morphisms between n and m be {(n, m)} if n <= m, or {} otherwise
18:53:01 <benzrf> athan: let (y, z) . (x, y) = (x, z)
18:53:15 <Pamelloes> horny-sama: Just like you have: via functions and operators. However, "uppercase guess" does not make the value in guess uppercase. It creates a new value that is the uppercase of guess
18:53:16 <athan> And it's reflexive!
18:53:21 <athan> ahh wow
18:53:23 <benzrf> athan: the identity morphism for any object n is (n, n) of course
18:53:37 <horny-sama> Pamelloes: how do I store the new output?
18:53:47 <benzrf> athan: in this case the category IS basically a graph
18:53:59 <EvanR> benzrf: what does or {} otherwise
18:53:59 <Cale> Recall that a monoid consists of a set of elements M together with a binary operation: *: M x M -> M called multiplication which is associative, i.e. a * (b * c) = (a * b) * c for any a, b, c in M and has an identity element: there is some e in M such that for any a in M, we have a * e = e * a = a.
18:54:00 <platz> the definition of category is well and good. no confusion there
18:54:01 <benzrf> athan: because morphisms dont have any information besides their type
18:54:05 <EvanR> mean
18:54:06 <Pamelloes> horny-sama: use a let satement "let myNewVar = value".
18:54:18 <benzrf> EvanR: it means that if n > m, then the set of morphisms from n to m is {}
18:54:21 <horny-sama> 	case uppercase guess of  works
18:54:26 <athan> benzrf: holy petunias, okay
18:54:31 <Pamelloes> horny-sama: Yep, that works as well.
18:54:35 <horny-sama> Pamelloes: is the let part require?
18:54:36 <athan> so this same concept would be a monoid if the object was Nat?
18:54:36 <benzrf> athan: so (2, 3) : 2 -> 3
18:54:36 <EvanR> benzrf: right sets... basically there arent any such morphisms
18:54:37 <Cale> If we have any monoid whatsoever, we can turn it into a category, by taking the collection of objects of the category to be any one element set we like
18:54:42 <benzrf> EvanR: righto
18:54:52 <Cale> Say that single object is X
18:54:57 <EvanR> it makes me theres more machinery going on than there is
18:55:06 <EvanR> liek theres a bunch of empty sets floating around ;)
18:55:07 <benzrf> EvanR: sorry! :p
18:55:12 <Cale> Then we pick the collection of arrows C(X,X) to be M
18:55:36 <athan> EvanR: It reminds me of my personality
18:55:38 <benzrf> hold up Cale
18:55:38 <athan> oh wait
18:55:41 <Cale> and if a: X -> X and b: X -> X, then we pick a . b = a * b, defining the composite according to the multiplication of the monoid
18:55:45 <benzrf> Cale: i think athan has a misunderstanding
18:55:45 <horny-sama> I don't understand why the let part is required in this case Pamelloes
18:55:50 <Pamelloes> horny-sama: within  a do statement, you can assign a variable a value in two ways. with "<-" and with "let". If you don't assign "uppercase guess" to a variable but instead use it directly in a "case" statement, there's no need to have a let case.
18:55:56 <Pamelloes> *let statement
18:56:07 <horny-sama> okay
18:56:07 <benzrf> 09:53 < athan> so this same concept would be a monoid if the object was Nat?
18:56:11 <benzrf> athan: what do you mean exactly?
18:56:11 <Cale> Let's actually move this to another channel, since it's only very tangentially related to Haskell
18:56:15 <benzrf> Cale: true
18:56:17 <Cale> Maybe ##categorytheory
18:56:37 <athan> Benzrf: HOLY CRAP okay
18:56:38 <benzrf> Cale: joined!
18:56:44 <athan> so composition of arrows is not first class
18:56:48 <athan> but rather implicit?
18:56:56 <athan> and assumed to always happen?
18:56:56 <benzrf> athan: nooo, it's very first class!
18:56:58 <Cale> athan: Wait, come to ##categorytheory
18:56:59 <shachaf> #haskell-overflow would be fine too.
18:57:06 <benzrf> athan: yes, come there
18:57:22 <horny-sama> Pamelloes: also I don't understand line 4-5 https://github.com/mr-fool/haskell/blob/master/female/female.hs can't be within the do block
18:58:54 <Pamelloes> horny-sama: lines 4 and 5 are assigning a value to "uppercase". Within a do statement, you can only assign values via "let" and "<-", so to have lines 4 and 5 in a do statement you'd need to use let.
18:59:19 <Pamelloes> e.g. "let uppercase :: String -> string \n  uppercase = map toUpper"
19:00:34 <horny-sama> Pamelloes: that does not work female.hs:11:19: parse error on input ‘=’
19:00:59 <geekosaur> indentation?
19:01:03 <Pamelloes> ^
19:01:24 <geekosaur> both instances of "uppercase" must be in the same column, to be specific
19:01:30 <horny-sama> https://github.com/mr-fool/haskell/blob/master/female/female.hs ?
19:01:55 <Pamelloes> horny-sama: geekosaur just explained it ;) You need to adjust indentation.
19:02:01 <geekosaur> yes, indent line 11 by four more spaces so that both instances of "uppercase" start in the same column
19:03:22 <horny-sama> https://github.com/mr-fool/haskell/blob/master/female/female.hs <--- like this ?
19:03:52 <Pamelloes> horny-sama: close. the start of "uppercase" needs to be in the same column
19:04:48 <geekosaur> "four more spaces". not a tab
19:05:10 <geekosaur> indentation with tab will mostly make you very unhappy
19:05:53 <geekosaur> if you're gooing to insist on it then I suggest you also tab immediately after "let" so other things inside the let block can be aligned using tabs
19:06:13 <Pamelloes> geekosaur: you can use tabs in Haskell? o.o
19:06:18 <Pamelloes> That sounds dangerous
19:06:25 <geekosaur> you can. as I said, it will mostly make you unhappy
19:06:41 <geekosaur> but if you're careful you can do it. leads to code creeping off to the right a lot though
19:07:01 <Pamelloes> Why would you even want to? What are the upsides?
19:07:09 <horny-sama> geekosaur: you are right
19:07:16 <horny-sama> gosh why can't tab works
19:07:17 <horny-sama> :<
19:07:25 <geekosaur> there aren't any upsides except maybe using dumb editors
19:07:34 <Pamelloes> makes sense
19:08:00 <horny-sama> 1 tab = 4 spaces?
19:08:09 <horny-sama> geekosaur: using geany
19:08:10 <geekosaur> horny-sama: indentation matters, as you just discovered. you do't really get to invent your own, or mix and match odd indentation like in your latest paste
19:08:29 <Pamelloes> horny-sama: accept that tabs are evil and move on. ;) Have your editor replace tabs with spaces automatically and you will live a better life.
19:08:35 <horny-sama> geekosaur: what editor do you use
19:09:00 <EvanR> that advice basically goes everything not just haskell
19:09:04 <geekosaur> emacs or nvi depending on what I am doing. most haskell work is in emacs unless it's a quick patch-up or using it as a smart pager
19:09:23 <geekosaur> the haskell modes for emacs and vim are pretty good
19:09:44 <Pamelloes> EvanR: Unless you're using a non-monospace font.
19:09:47 <geekosaur> there are also haskell environments for various other editors
19:09:48 <EvanR> lol
19:09:59 <EvanR> Pamelloes: epigram?
19:10:02 <horny-sama> time for a walk
19:10:45 <Pamelloes> EvanR: is that the technical term for non-monospace?
19:11:19 <geekosaur> "proportional" would be that term
19:11:34 <Pamelloes> Ah. Eww. What does epigram mean, then?
19:12:10 <geekosaur> I'm not sure what EvanR is referring to there
19:12:11 <EvanR> well i thought it was a language with fancy-looking syntax
19:12:19 <EvanR> but apparently theres an ascii version
19:12:35 <geekosaur> oh, dependently typed language I see
19:12:54 <Pamelloes> That sounds like an abomination.
19:12:54 <EvanR> in most languages you do *not* use a proportional font
19:13:14 <EvanR> for better or worse ;)
19:13:18 <Pamelloes> I avoid proportional fonts always. As a matter of course.
19:14:22 * geekosaur is sure someone somewhere has done an esolang where the program content is defined by font changes...
19:14:41 <lfairy> colorforth is close ;)
19:15:19 <Pamelloes> Is there an easy way to use an existing ParsecT to create a [Bool] where true means the token is kept by the parser and false means the token is deleted/ignored?
19:15:47 <Pamelloes> (where the [Bool] corresponds index-by-index to the input stream)
19:18:46 <pavonia> What are ignored tokens in that context?
19:20:44 <Pamelloes> pavonia: My Parsec takes an input consisting of "structural" tokens describing what the remaining tokens mean. The Parsec strips the structural tokens and wraps the remaining tokens in a data type that describes what they refer to (as denoted by the structural tokens).
19:21:04 <Pamelloes> Basically, I want a [bool] where false indicates a structural token and true equals everything else
19:22:07 <pavonia> Maybe you should paste some code
19:22:38 <ij> I'm trying to use the webdriver package and its WD monad. To run it, I use runSession :: config -> WD a -> IO a. I want to sleep inside of it, how do I make an IO action a WD action?
19:23:18 <Pamelloes> Eh, doesn't really matter. I'm just going to create a second set of ParsecT's to deal with this case—it won't be too complicated and will result in way cleaner code.
19:23:23 <lfairy> ij: does WD implement MonadIO?
19:24:02 <lfairy> ij: if so, you can use liftIO :: MonadIO m => IO a -> m a
19:24:45 <ij> It does. \o/
19:24:48 <geekosaur> looks like it, yes
19:26:18 <lfairy> ooh it does
19:31:00 <mjrosenb> what is the recommended way of getting from a module name (e.g. Data.Maybe) to its online docs (e.g. http://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Maybe.html)
19:32:31 <lwm> what the heck is an 'opaque type'?
19:32:33 <lfairy> mjrosenb: hoogle/hayoo work for me, but there might be better ways
19:34:04 <EvanR> a type which you dont get the implementation for?
19:34:15 <mjrosenb> hoogle always seems to give a result like 3/4 the way down the first page :-(
19:42:39 <Rotaerk> yay, hexchat can join this channel
19:42:56 <Rotaerk> (was using the YChat client and it crashed whenever I attempted it...)
19:43:33 <EvanR> you dont use emacs like everyone else? ;)
19:44:03 <Pamelloes> emacs has a built in irc client?
19:44:17 <Rotaerk> heh, I use vim for editing.  I've never tried emacs
19:44:43 <Pamelloes> Same here. I've heard good things but I'm too comfortable with vim to consider switching.
19:45:22 <benzrf> vimmmmmmmmmm
19:45:30 <EvanR> i need to look into haskell mode for vim
19:46:01 <EvanR> too used to structural editing of clojure
19:46:22 <Rotaerk> there are certain features of visual studio that I'd like with vim and haskell
19:46:35 <Rotaerk> for instance, refactoring tools... such as smart renaming
19:47:01 <EvanR> that might exist ...
19:47:04 <Rotaerk> (string replacement is not "smart", because you might be renaming two different identifiers)
19:47:47 <EvanR> visual studio does that for haskell code?
19:48:24 <Rotaerk> no it does it for other languages
19:48:37 <Rotaerk> though I think there's a VS plugin for haskell... I haven't tried it
19:48:52 <Pamelloes> Rotaerk: Definitely something I miss from using a full on IDE. Probably the only thing...
19:49:20 <Rotaerk> "go to definition" is also nice, and "find all references"
19:49:29 <Rotaerk> roughly achievable with string searches, but smarter
19:51:05 <RchrdB> "go to definition" may be doable with etags?
19:51:16 <Zemyla> Who was it here who wanted an array with a user-defined dimension?
19:51:39 <EvanR> yes goto definition works in vim various ways depending on the language
19:51:41 <lwm> Rotaerk: for find all references you can go over the word and hit Shift-8, that highlights all of them, then 'n' will go through them all.
19:52:13 <lwm> for go to def, check out ctrlp-funky, it is great
19:52:15 <Rotaerk> huh, didn't know about shift-8; I've always manually typed the search pattern
19:52:19 <RchrdB> Pamelloes: there are two, iirc. I used to use one called ERC and it's well-written, but I found it too distracting to have IRC *right there* in my editor, so I deliberately switched to an external IRC client with less-effective notifications. :)
19:52:41 <EvanR> lol
19:53:09 <Pamelloes> interesting. I have IRC open on a separate monitor (in a standalone client) and I find that works quite well.
19:53:24 <Pamelloes> Though I do tab away sometimes because, like you said, having IRC open can be distracting.
19:53:39 <RchrdB> Pamelloes: if I were still using vim at this point, I'd probably be looking into neovim, which is modernising while still aiming to keep vimscript compatibility.
19:54:02 <Pamelloes> RchrdB: What do you mean by modernising?
19:56:16 <RchrdB> Pamelloes: on the codebase front: making the code simpler, dropping lots of untested code that's supposed to support strange operating systems but isn't actually tested and doesn't really work (apparently the neovim people document having deleted huge rats-nests of #ifdefs for things like AmigaOS and EBCDIC support…
19:57:08 <Pamelloes> hehehehe that makes sense, since vi(m) is included with everything.
19:57:26 <EvanR> if only ...
19:57:51 <Pamelloes> EvanR: I've never used a linux-based system without vim.
19:57:57 <RchrdB> Pamelloes: on the features front, neovim are adding far, far better support for cooperative-multitasking+asynchronicity.
19:58:06 <EvanR> me neither, for very long, because i immediately install it
19:58:10 <ij> Package issue: Data.Text has two versions, ghc's using one in the file I'm compiling, webdriver is compiled with an earlier one. May I force ghc use the other Text version?
19:58:46 <Pamelloes> EvanR: Well vi(m). A minimal distro requires a text editor of some sort, so what would be included instead?
19:58:48 <Zemyla> Yeah, I think I've created a good demonstration program showing how it works.
19:59:30 <Pamelloes> RchrdB: Hm, I might look into it one day. Sounds interesting
19:59:57 <EvanR> Pamelloes: a minimumal distro would have a good reason to exclude it since vim is one of the largest-in-size packages of a core linux
20:00:10 <RchrdB> Pamelloes: instead of vim, use vi. Instead of vi, use ed. ;)
20:00:19 <EvanR> ed rox
20:01:49 <Pamelloes> EvanR: Well I said vi(m) to include vi. Vi has the same basic commands (minus a lot of features that make vim useful), so I consider it more or less the same.
20:02:10 <EvanR> theres no such thing as vi really
20:02:38 <ij> Never mind, solved w/ — ghc-pkg hide
20:02:49 <Pamelloes> EvanR: Yes there is. I've used it. It was depressingly minimal.
20:03:00 <EvanR> theres vim in vi mode
20:03:08 <EvanR> with a symlink
20:03:40 <Pamelloes> EvanR: I was working on an embedded system that couldn't have software installed in it. It had vi.
20:03:52 <Pamelloes> *working in an
20:04:03 <RchrdB> busybox has a (sawn-off, missing some features) vi implementation.
20:04:07 <mmachenry1> Pamelloes: Probably elvis or one of the other really minimal vi's.
20:04:40 <Pamelloes> mmachenry1: Maybe. Is there really not an original vi?
20:04:45 <EvanR> yeah theres clones
20:04:53 <RchrdB> There is. You can still find the sources for the original vi.
20:05:32 <RchrdB> Offhand I think it's not compilable unmodified on modern Unix-family OSes?
20:06:01 <mmachenry1> Pamelloes: There is, but I bet what you were running was not it. Just a guess.
20:06:52 <EvanR> the later history of the original vi program is kind of confusing
20:07:05 <EvanR> and essentially ends in the 80s ;)
20:07:23 <EvanR> open source clones being a better idea
20:07:30 <Pamelloes> Well I was working with the ESXi backbone, so I wouldn't be surprised if it was the original. Though if vim isn't compatible with unix it would probably be a clone.
20:09:29 <bramgg> Is there a simple explanation somewhere about what GHC "LANGUAGE" extensions are? I don't think it was covered in Learn You a Haskell and all I know is I need them to run Scotty (https://github.com/scotty-web/scotty)
20:09:39 <RchrdB> Pamelloes: I pretty much guarantee you that you weren't using the original vi, since the original vi was written on AT&T Unix and ESXi's service console is a little Linux distribution.
20:10:03 <Pamelloes> RchrdB: Yeah, that makes sense.
20:10:41 <bramgg> So far all documentation/info on them seems to assumes you already know everything.
20:11:06 <Pamelloes> Speaking of ancient OSs, I was at a friends house and stumbled upon a college textbook about designing OS's published in 87. It had a 200 page appendix that consisted of the entire source code of Minix. Printed out.
20:11:41 <Pamelloes> How things have changed.
20:12:07 <RchrdB> bramgg: okay, so standard Haskell changes quite slowly, but we all want to use crazy language extensions like multi-param typeclasses and whatever.
20:12:23 <EvanR> bramgg: yeah, "beginner" tutorials on the advanced extensions basically doesnt exist
20:12:53 <EvanR> people are still trying to learn/teach haskell level 1
20:13:13 <bramgg> EvanR: did you skip level 1?
20:13:18 <RchrdB> bramgg: if you put one or more LANGUAGE pragmas, written like {-# LANGUAGE MultiParamTypeClasses #-} at the top of a source file (one per line, before the "module Foo where ..."), your Haskell compiler will either turn on the extra extensions, or if it doesn't have that one, sit in the corner and cry.
20:14:21 <bramgg> RchrdB: so it's basically changing/adding to the language?
20:14:23 <lfairy> bramgg: I think ocharles covers them in his blog
20:14:24 <RchrdB> bramgg: there are a few other ways to turn on the language extensions, like you can pass "-XMultiParamTypeClasses" as an argument to ghc, or iirc you can put them somewhere in a .cabal file, but the {-# LANGUAGE ... #-} pragmas in individual files are, last I checked, broadly considered to be the nicest solution
20:14:31 <EvanR> bramgg: warp zone
20:14:42 <RchrdB> bramgg: right.
20:16:20 <RchrdB> bramgg: e.g. if I write ``"foo"`` in a standard Haskell program, it denotes a value of type [Char] with the value ['f', 'o', 'o']
20:17:47 <RchrdB> but if I turn on the OverloadedStrings language extension, the Haskell compiler will read "foo" to mean (Data.String.fromString ['f', 'o', 'o'])
20:17:53 <ij> In the package webdrive, how do I set a value of a select?
20:18:19 <Cale> Or even 'f':('o':('o':[])), if we're desugaring syntax :)
20:18:54 <bramgg> Thanks for all the help :)
20:20:08 <lpaste> Zemyla pasted “Binary tree with given dimensions.” at http://lpaste.net/118981
20:21:15 <RchrdB> bramgg: in this way, Haskell compilers can add weird things to the language without confusing you with them until you actually switch them on. :)
20:21:48 <Zemyla> There we go. Who was it who wanted the quadtree/octree/whatevertree?
20:21:53 <RchrdB> (I guess it probably helps backwards-compatibility a little too, but eh)
20:22:28 <RchrdB> Zemyla: you have a purely-functional octree? I wasn't the one asking about it before but I'm interested now. :)
20:23:57 <Zemyla> It's got n dimensions, where n can be as big as the compiler allows.
20:25:30 <EvanR> > (maxBound :: Int) + 1
20:25:31 <Zemyla> I suppose it could be indexed with an Int instead of a list of Bools, but I wanted to get something working quickly.
20:25:32 <lambdabot>  -9223372036854775808
20:25:49 <EvanR> > (fromIntegral (maxBound :: Int)) + 1
20:25:51 <lambdabot>  9223372036854775808
20:28:46 <Zemyla> It's not very space-efficient, because it's got roughly one extra pointer for every entry, but lookups are O(log n).
20:31:33 <vova> Hi, Could someone help me with tagsoup library. I'm trying to use function parseTags with argument that have  Bytestring type, but I'm getting the error
20:32:35 <vova> Couldn't match type `BS.ByteString' with `[Char]'
20:32:59 <vova> It's very strange. Could some one help me.
20:33:08 <horny-sama> http://www.fpaste.org/172837/19010701/ <--- :<
20:35:21 <horny-sama> can't import a package in ghci :<
20:35:43 <Cale> vova: Sure, could you paste your code at lpaste.net?
20:35:50 <horny-sama> import Data.Text
20:35:56 <horny-sama> > import Data.Text
20:35:57 <lambdabot>  <hint>:1:1: parse error on input ‘import’
20:36:04 <Zemyla> Don't paste it here.
20:36:06 <pavonia> horny-sama: Have you installed the text package?
20:36:25 <Cale> horny-sama: cabal install text
20:36:31 <vova> Cale: One moment please
20:36:39 <horny-sama> pavonia: if it comes with standard ghci then yes
20:36:44 <Cale> It does not.
20:36:51 <horny-sama> Cale: I thought text is the standard package
20:37:03 <Cale> If you have the Haskell Platform, it's likely part of that
20:37:09 <Cale> But it's not part of GHC
20:37:19 <pavonia> horny-sama: Check with "ghc-pkg list text"
20:37:19 <horny-sama> ok
20:37:44 <horny-sama> pavonia: ghc-pkg list text
20:37:44 <horny-sama> /usr/lib64/ghc-7.8.4/package.conf.d
20:38:14 <pavonia> If that is all output no version is installed
20:42:55 <horny-sama> pavonia: how come the channel does not have text installed either :<
20:43:25 <pavonia> You mean lambdabot?
20:43:28 <horny-sama> yes
20:43:34 <horny-sama> > import Data.Text
20:43:35 <lambdabot>  <hint>:1:1: parse error on input ‘import’
20:44:00 <pavonia> :t pack
20:44:01 <lambdabot>     Not in scope: ‘pack’
20:44:02 <lambdabot>     Perhaps you meant one of these:
20:44:02 <lambdabot>       ‘BS.pack’ (imported from Data.ByteString),
20:44:27 <pavonia> I don't think you can import arbitrary modules here
20:44:52 <pavonia> :t Data.Text.pack
20:44:53 <lambdabot> String -> Data.Text.Internal.Text
20:45:02 <horny-sama> import Data.Char (isSpace) <--- is the (isSpace) part necessary
20:45:02 <horny-sama> ?
20:45:08 <pavonia> > Data.Text.pack "foo"
20:45:09 <lambdabot>  Not in scope: ‘Data.Text.pack’
20:45:58 <pavonia> horny-sama: It's not necessary if you want to import all functions and datatypes of that module
20:48:28 <jle`> @let import qualified Data.Text as T
20:48:29 <lambdabot>  .L.hs:112:1:
20:48:29 <lambdabot>      Data.Text: Can't be safely imported!
20:48:29 <lambdabot>      The package (text-1.1.0.1) the module resides in isn't trusted.
20:48:33 <jle`> oh well
20:49:26 <Zemyla> Hmm, question.
20:51:11 <Zemyla> If SPair g = SPair {-# UNPACK #-} !g {-# UNPACK #-} !g, is SPair (SPair Int) four unpacked Ints?
20:51:19 <vova> Cale: seems I've found the root of the issue. Sorry.
20:51:32 <shachaf> Zemyla: No.
20:52:10 <Zemyla> shachaf: Shame.
20:53:04 <shachaf> Zemyla: SPair is parametric, which means you should be able to write f :: SPair a -> a; f (Spair x _) = x
20:53:11 <shachaf> parameterized
20:53:18 <shachaf> How can you do that if it's unpacked?
20:53:41 <Zemyla> shachaf: Shame.
20:53:48 <Zemyla> Ah, well.
20:54:52 <chrisdotcode> should helper functions go before they're used - or after?
20:55:27 <pavonia> Doesn't matter
20:55:42 <chrisdotcode> I know.
20:55:47 <chrisdotcode> But for aesthetics and style.
20:56:06 <horny-sama>     let trimPassword = trim password <---how come this is not considered an expression?
20:56:08 <Zemyla> There's no right answer.
20:56:51 <horny-sama> is trimPassword <- trim password the same as let trimPassword = trim password
20:56:53 <pavonia> horny-sama: Expressions have a value and type, this one doesn't, it's just a binding
20:57:09 <horny-sama> pavonia: okay
20:57:19 <horny-sama> what about my second question?
20:57:34 <pavonia> It's not the same
20:58:01 <pavonia> In "x <- foo" foo is a monadic action (in do-blocks)
20:58:27 <horny-sama> pavonia: monadic?
20:58:33 <jle`> horny-sama: in a do block, if `trim password` is of type `m a`
20:58:41 <jle`> then tp <- trim password, tp will be of type `a`
20:58:51 <jle`> then let tp = trim password, tp will be of type `m a`
20:59:08 <jle`> if you're in IO, then if `trim password` is `IO String`
20:59:11 <pavonia> horny-sama: If you are using do-notation your should be familiar to the Monad type class
20:59:17 <jle`> then tp <- trim password will get you `tp :: String`
20:59:25 <jle`> and let tp = trim password will get you `tp :: IO String`
20:59:58 <horny-sama> jle`: type m a?
21:00:06 <jle`> they're type variables
21:00:10 <jle`> put in whatever you want for m and a :P
21:00:14 <jle`> i gave a concrete example :)
21:00:34 <pavonia> Actually, Monad m => m a
21:01:18 <horny-sama> learning haskell reminds me first time programming
21:01:26 <horny-sama> much confuse wow scary
21:02:22 <Zemyla> Is there a way to write the type (Compose m n) such that (Compose m n) a = m (n a)?
21:02:23 <chrisdotcode> Many ROI.
21:02:55 <chrisdotcode> Zemyla: Compose seems like Identity there to me?
21:03:00 <jle`> horny-sama: so, say you have `getLine`, which is `IO String`
21:03:07 <jle`> horny-sama: if i did l <- getLine, the l :: String
21:03:15 <jle`> horny-sama: if i did let l = getLine, then l :: IO String
21:03:22 <pavonia> Zemyla: You can use type families for that, I think
21:03:48 <jle`> horny-sama: let's say you have `True`, which is `Bool`.  if i did `let b = True, then b :: Bool.  if i did b <- True, welll...that doesn't make any sense :)
21:04:08 <horny-sama> yesssss
21:04:23 <jle`> basically, if you have an `IO String`, <- lets you "name" the String
21:04:27 <jle`> for reference later
21:04:41 <horny-sama> I guess I have to familiarize with the fact that we have io string type
21:04:42 <jle`> if you have an `IO String`, `let ... = ...` lets you "name" the IO String
21:05:00 <jle`> if you have a `Bool`, `let ... = ...` lets you "name" the Bool
21:05:03 <jle`> and <- doesn't really have any meaning
21:05:10 <jle`> if you have `IO Bool`, then <- lets you name the Bool ofc.
21:06:18 <jle`> <- is nice because functions like `putStrLn` take a String, not an IO String.  so you can str <- getLine; putStrLn str, so `str` is a String that you can feed to putStrLn
21:06:25 <jle`> `putStrLn getLine` is a type error
21:07:10 <jle`> however, if you already have a string, you can `do let str = "my string"; putStrLn str`
21:07:12 <horny-sama> jle`: so basically <- takes the input and convert to the type of the left hand side?
21:07:25 <jle`> because "my string" is already a string, so you can already pass it to putStrLn
21:07:52 <jle`> horny-sama: so if you have `IO String`, `x <-` lets you name the `String` as x
21:08:05 <jle`> it's not really a conversion, it's more like a naming
21:08:11 <horny-sama> okay
21:08:11 <jle`> more technically, it is a "bind"
21:08:23 <horny-sama> enough haskell for today
21:08:30 <horny-sama> time for some boring automata studying
21:08:31 <horny-sama> :<
21:08:33 <jle`> woo hoo
21:08:42 <jle`> can't you automate that
21:09:18 <Zemyla> horny-sama: Would it confuse you to tell you <- isn't just for IO?
21:09:36 <horny-sama> Zemyla: yes
21:09:45 <horny-sama> jle`: automata is not automating stuff
21:09:52 <horny-sama> it is an abstract model of computer
21:09:55 <jle`> it's a joke :)
21:09:57 <horny-sama> aka theory shit
21:10:00 <horny-sama> jle`: ooo
21:10:06 * horny-sama is being austistic
21:10:34 <jle`> it's some new kind of science or something right
21:10:43 <jle`> ha ha ha
21:10:54 <horny-sama> lol
21:11:11 <jle`> it's ok i know it wasn't that funny
21:13:43 <Zemyla> Like DFAs and such?
21:13:46 <athan> jle`: Or really, can you automate the study of a DFA? NDA?
21:14:09 <athan> wait I think you can with a stack based one... can't you? As memory?
21:14:21 <athan> just to see the terminating & nonterminating behavior?
21:15:43 <athan> :O
21:23:03 <jTT> hey, don’t rip me apart if this is inane, but I have a question about my usage of $.
21:24:41 <jTT> I have a number of funcitons that together assemble a matrix according to some specifications. I end up doint something like:  assemleMatrix para = (5><5) $ doSomethindElse $ doSomeThing $ doSomethingToValues $ makeInitialValues
21:24:58 <jTT> my question is: this chained usage of $ seems off
21:25:09 <jTT> is there a better way?
21:25:18 <shachaf> It's usually considered nicer to write (f . g . h $ x) rather than (f $ g $ h $ x)
21:25:42 <jTT> somehow this doesnt work though, I suspect because “makeInitialValues” is lazy
21:25:44 <jTT> perhaps
21:25:56 <shachaf> Shouldn't make a difference.
21:26:09 <shachaf> But you're not using para in your code, so I suspect you're eliding something.
21:26:15 <jTT> kk, I’ll try to get to the root of what causes issues with ‘.’
21:26:33 <jTT> ah sorry, I am using para in my real code, but this was an example
21:27:34 <jle`> jTT: is it not compiling?
21:27:44 <jle`> or is it behaving differently than you expected?
21:28:40 <jTT> argh, apologies. This issue was I had “.” at  all positions of “$” …obvs then “make initialValues” was never evaluated
21:28:43 <jle`> `f . g . h $ x` is usually preferred over `f $ g $ h $ x`, cause of associativity and being easier to pull out and stuff.  there are some situations where it actually won't work
21:28:59 <jle`> but for the most part, it's preferred :)
21:29:06 <jTT> so i had f . g. h . x
21:29:09 <jle`> ah
21:29:11 <jle`> welp
21:29:12 <jTT> which is “curried”?
21:29:18 <jTT> yeah sorry … -.-
21:29:33 <jle`> not sure if curried is the right word
21:29:54 <jTT> well composed but never evaluated…smart me
21:30:02 <EvanR> or (f . g . h) x
21:30:34 <jTT> as we are on the topic, is there any performance/other effect on chained $ vs ‘.’? Or is it cosmetic?
21:32:15 <jle`> i would imagine they inline to be the same thing
21:32:24 <jle`> but i say that without any evidence
21:32:29 <jle`> @src (.)
21:32:29 <lambdabot> (f . g) x = f (g x)
21:32:31 <jle`> @src ($)
21:32:32 <lambdabot> f $ x = f x
21:32:54 <jTT> ah k, cheers
21:32:57 <jle`> let me see...
21:33:20 <jle`> f . (g . h) $ x
21:33:36 <jTT> (g x) = g $ x => f $ (g $ x) = (f. g) x
21:33:49 <jle`> (f . (g. h)) x = f ((g . h) x) = f (g (h x))
21:34:10 <jle`> f $ (g $ (h $ x)) = f $ (g $ (h x)) = f $ (g (h x)) = f (g (h x))
21:34:16 <jle`> so they evaluate to the same thing
21:34:20 <jTT> yeah cool
21:34:23 <jle`> ideally they'll both be inlined at compilation to f (g (h x))
21:34:55 <jle`> i'd check the core first before saying anything definite
21:35:00 <jTT> cheers friend :P
21:35:03 <jle`> np :)
21:38:46 <Zemyla> :t \f a -> liftM2 (+) f (const a)
21:38:47 <lambdabot> Num a => (b -> a) -> a -> b -> a
21:40:22 <Zemyla> Oh, fuck. Fuuuuck. I think I figured this problem my brain has been gnawing at for weeks out. and the answer is undiluted madness.
22:04:05 <Zemyla> So apparently, I need to make an infinitely wide, infinitely deep tree.
22:04:42 <shachaf> Sounds like fun.
22:07:26 <Zemyla> It also relies on Random.split. :O
22:13:59 <platz> i think lazy tree exploration is used in some property based testing frameworks in other languages
22:14:28 <platz> i think they do that so they can backtrack in certain cases
22:33:37 <vanila> hi guys
22:33:46 <vanila> does anyoen know about the social media problem?
22:34:35 <vanila> some group of trolls is 'defending' functional programming so viciously (e.g. bullying and swearing at anyone who speaks against it) that people are starting to really look down on haskell folk
22:36:17 <Zemyla> @let toRat x = approxRational (toRational x) (toRational $ (encodeFloat 1 $ -1 + (snd $ decodeFloat x)) `asTypeOf` x)
22:36:19 <lambdabot>  Defined.
22:36:31 <Zemyla> > toRat pi
22:36:32 <lambdabot>  245850922 % 78256779
22:36:41 <Zemyla> > toRational pi
22:36:42 <lambdabot>  884279719003555 % 281474976710656
22:36:58 <CindyLinz> > fromRational pi :: Double
22:36:59 <lambdabot>  No instance for (GHC.Float.Floating GHC.Real.Rational)
22:36:59 <lambdabot>    arising from a use of ‘GHC.Float.pi’
22:37:27 <Zemyla> > fromRational (toRat (pi::Double)) == (pi::Double)
22:37:28 <lambdabot>  True
22:37:40 <CindyLinz> > pi
22:37:42 <lambdabot>  3.141592653589793
22:38:08 <Zemyla> >toRat (1.7 :: Double)
22:38:17 <Zemyla> > toRat (1.7 :: Double)
22:38:18 <lambdabot>  17 % 10
22:38:57 <echo-area> > :t pi::Double
22:38:58 <lambdabot>  <hint>:1:1: parse error on input ‘:’
22:39:25 <echo-area> :t pi::Double
22:39:26 <lambdabot> Double
22:39:41 <echo-area> :t >
22:39:41 <lambdabot> parse error on input ‘>’
22:39:48 <Zemyla> > toRat ((1::Double) / 3)
22:39:49 <lambdabot>  1 % 3
22:40:17 <echo-area> :t (>)
22:40:18 <lambdabot> Ord a => a -> a -> Bool
22:40:19 <Zemyla> See? Floating-point numbers can be converted almost exactly to rationals.
22:40:58 <echo-area> > toRat (pi::Double)
22:40:59 <lambdabot>  245850922 % 78256779
22:43:59 * hackagebot reflection 1.5.1.1 - Reifies arbitrary terms into types that can be reflected back into terms  http://hackage.haskell.org/package/reflection-1.5.1.1 (EdwardKmett)
22:45:17 <srhb> vanila: Where? Who? Link?
22:49:04 <vanila> https://twitter.com/bitemyapp/status/557779884307918848
22:49:13 <vanila> https://twitter.com/jedws/status/557771614105128960
22:49:44 <glguy> Ugh, let's not do twitter drama in #haskell
22:50:06 <vanila> glguy, it's really important to call out bullies
22:50:12 <vanila> otherwise they will destory this community
22:50:33 <glguy> Twitter is not the community, and it's not #haskell
22:52:00 <vanila> wel of course im going to comply but I think you're censoring a really important issue
22:53:35 <srhb> glguy: I asked for the links. Complain to me instead. :)
22:53:48 <vanila> most people out there hate us becuase we use haskell, thinking we're the same as them
22:54:30 <zomg> I saw that convo as well, I just decided to unfollow
22:54:50 <zomg> I know bitemyapp does good work but he's not very.. diplomatic.. when it comes to things
22:55:08 <glguy> srhb: hte message was for everyone
22:55:51 <srhb> In that case, I too think it's important to consider and coordinate the community. :)
22:56:46 <glguy> You guys should make a #haskell-twitter and figure out how to save twitter from itself, then and get all the people who want to coordinate it together so you'll be able to have good communication
23:04:38 <lpaste> dramforever pasted “cabal install http-server” at http://lpaste.net/118988
23:05:01 <dramforever> ghc can't find Network.URI
23:05:34 <dramforever> it's in the hidden packages "network-uri-2.6.0.1" and "network-2.4.1.2"
23:06:03 <dramforever> but I think I see network(>=2.4.0.0 && < 3) here:
23:06:07 <dramforever> @hackage http-server
23:06:08 <lambdabot> http://hackage.haskell.org/package/http-server
23:06:28 <dramforever> Does anyone know why or can fix it? thanks
23:07:23 <glguy> Recently network split from network-uri
23:07:45 <dramforever> oh
23:07:53 <glguy> So your choices are to build that package with a constraint lowering network to < 2.6
23:08:00 <glguy> or fix the cabal file to add a network-uri dependency
23:08:19 <glguy> For what its worth we just use the snap-server now...
23:08:26 <dramforever> glguy: but I think network-2.4.1.2 satisfies >=2.4.0.0 && <2
23:08:27 <glguy> but that package is simpler
23:08:29 <dramforever> *<3
23:08:40 <dramforever> glguy: I'm trying to install haxy
23:08:51 <glguy> dramforever: Then try doing:   cabal install --constraint=network==2.4.1.2 http-server
23:09:05 <lfairy> scotty is a good alternative too
23:09:46 <dramforever> actually, I'm trying to write a http proxy to redirect requests to ajax.googleapis.com to a mirror
23:09:52 <dramforever> because google is blocked here
23:10:06 <dramforever> so...easy to use proxy library needed
23:10:27 <zomg> Scary.
23:10:45 <dramforever> ????
23:10:51 <dramforever> network-2.4.1.2 (latest: 2.6.0.2) (reinstall) changes: parsec-3.1.3 -> 3.1.8
23:11:00 <dramforever> huh?
23:11:31 <dramforever> that's scarier
23:11:34 <glguy> dramforever: Your best bet is going to be to edit the cabal file then :)
23:11:39 <glguy> cabal get http-server
23:11:43 <dramforever> glguy: okay
23:11:48 <lfairy> dramforever: can you try --constraint='network installed'
23:11:54 <lfairy> that'll choose the network that's already there
23:11:56 <glguy> lfairy: No, that won't work for this case
23:12:18 <funfunctor> hello?
23:12:30 <glguy> the specific issue is that the upper bound on http-server is too high but other packages are already using the higher version of network, Also it should be an easy fix to just have http-server use the new version
23:12:31 <dramforever> lfairy: apparently http-server didn't list network in their .cabal
23:12:35 <vanila> good morning :)
23:12:38 <dramforever> glguy: no
23:12:42 <funfunctor> hey vanila
23:12:53 <lfairy> glguy: ah ok
23:12:56 <dramforever> I think they forgot to list it
23:13:01 <glguy> dramforever: No, it's in ther
23:13:03 <glguy> there*
23:13:06 <dramforever> anyway, I'll check that
23:13:08 <glguy> line 37
23:13:10 <dramforever> funfunctor: Hello
23:13:12 <dramforever> glguy: okay
23:13:13 <funfunctor> vanila: did you see my libbladerf binding?
23:13:26 <funfunctor> hey dramforever :)
23:13:27 <vanila> bladerf? :D thats new to me
23:13:34 <vanila> ohh.. bladeRF
23:13:40 <vanila>  was reading it as bla-derf
23:13:55 <funfunctor> vanila: http://www.nuand.com/blog/product/bladerf-x40/
23:13:55 * dramforever didn't know why he said "Hello"
23:14:04 <dramforever> glguy: "hacky" solution: remove the constraint
23:14:26 <vanila> I'm just a little worried if haskell runtime will be able to keep up the pace with emitting these signals?
23:14:34 <vanila> if you're using it in a realtime way
23:14:39 <glguy> dramforever: that sounds like hacky and more like it won't work though
23:14:43 <glguy> less *
23:15:22 <dramforever> glguy: so do I add network-uri to it?
23:16:20 <glguy> dramforever: Under the line that says "network     >= 2.4.0.0  && < 3," add a line "network-uri"
23:16:28 <glguy> (with a trailing comma like the other ones)
23:16:30 <dramforever> glguy: okay, already did that
23:16:38 <glguy> and now from that directory type: cabal install
23:16:45 <dramforever> Great, it's compiling
23:17:33 <dramforever> glguy: thank you, I estimate that you saved me an hour searching for another library
23:17:48 <funfunctor> vanila: got any tips on how to improve this binding? https://github.com/victoredwardocallaghan/hlibBladeRF
23:19:16 <dramforever> glguy: Ha!, hacky...haxy...A pun here!
23:19:31 <shiona> @hoogle MonadPlus Bool -> Bool
23:19:33 <lambdabot> Warning: Unknown type MonadPlus
23:19:34 <lambdabot> Prelude not :: Bool -> Bool
23:19:34 <lambdabot> Data.Bool not :: Bool -> Bool
23:24:26 <Axman6> ClaudiusMaximus: so, one last idea to speed up that code, did you try using either x + x or x `shiftL` 1 (or unsafeShiftL) instead of 2 * x?
23:27:49 <shachaf> GHC will compile 2 * x to a left shift.
23:27:51 <shachaf> (For Ints.)
23:28:17 <Zemyla> What about for Integers?
23:28:57 <shachaf> For Integers it'll do Integery things.
23:29:19 <shachaf> I.e. check the tag and handle the Int and GMP integer cases separately, and check for overflow in the former.
23:29:39 <shachaf> If you're wondering whether it'll turn a GMP multiplication into a GMP left shift, almost certainly not.
23:31:02 <dramforever> @lambdabot
23:31:03 <lambdabot> Unknown command, try @list
23:31:12 <dramforever> ouch, that's not /query, sorry
23:31:25 <Zemyla> So I have to recognize and strength-reduce it myself.
23:32:40 <Axman6> shachaf: its being used on potentially very large Integers
23:34:24 <trap_exit> is there a nyway to control a browser (i.e. add/del dom elems + setup event handlers) from haskell?
23:34:27 <trap_exit> I'm not looking for fay / haste / ghcjs
23:34:35 <trap_exit> I want a library which lets me control Chrome / Safari / Firefox from haskell
23:41:20 <trap_exit_> why does fay not have type classes?
23:41:27 <trap_exit_> what is so complicated about type classes as opposed to type checking?
23:48:17 <mercwithamouth> does anyone here use clojure as well? if so which do you prefer..and for what tasks if you use both?
23:53:42 <f0rk> Why a am getting an error here http://lpaste.net/118991 ?
23:54:41 <trap_exit_> i used to use clojure
23:54:44 <trap_exit_> then I wanted error detected at compile time
23:54:48 <trap_exit_> now my code no longer compiles
23:55:35 <vanila> trap_exit_, what about just emitting an HTML page?
23:55:51 <trap_exit_> no, I want Fay
23:56:11 <f0rk> Hmm this works: join ([] :: [Integer])
23:56:23 <vanila> > join ([] :: [Integer])
23:56:24 <lambdabot>  Couldn't match type ‘[a]’ with ‘GHC.Integer.Type.Integer’
23:56:24 <lambdabot>  Expected type: [[a]]
23:56:24 <lambdabot>    Actual type: [GHC.Integer.Type.Integer]
23:56:30 <mercwithamouth> trap_exit_: lol
23:57:12 <mercwithamouth> trap_exit_: are you saying you're more likely to get shit done in clojure?
23:57:28 <trap_exit_> I'm more likely to get something that runs and dies during runtime
23:57:38 <koomi> f0rk: the typechecker has to know which concrete type to use for 'a'
23:57:55 <koomi> so it can look up that instance
23:58:12 <mercwithamouth> lol
23:58:18 <mercwithamouth> so no clear answer...
23:58:23 <mercwithamouth> which...is to be expected
23:59:19 <athan> ...looks like I'm going to have to make a type-safe unique list, too :\
23:59:22 <f0rk> ok then why this works in ghci http://lpaste.net/118992 ?
23:59:41 <tdammers> dynamically-"typed" languages get shit done faster, emphasis on "shit"
