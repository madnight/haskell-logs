00:37:21 <Twey> robbert: ‘Mostly’ — isn't this always the case?  To have a contravariant functor you need to have the mapped parameter in a negative position, and the only way you can do that in an intuitionistic logic is if it's on the left of an odd number of arrows
00:38:41 <shachaf> Twey: ?
00:39:21 <Twey> shachaf: 061401 <roboguy_> Zemyla: One way to look at it is that covariant functors map over "producers" (mostly) and contravariant functors map over "consumers" (mostly)
00:39:58 <Twey> (just realized I necro'd that a bit, but it seems like an interesting discussion)
00:40:02 <shachaf> Ah, not robbert.
00:40:06 <Twey> Oh!
00:40:09 <Twey> Sorry, robbert.
00:40:40 <glguy> Maybe phantoms are the non mostly
00:41:11 <shachaf> If you accept Maybe and [] you should accept Proxy as a special case which is always empty.
00:41:17 <Twey> glguy: Ah, right!
00:41:24 * Twey nods.
00:41:33 <shachaf> Proxy t -- a list of zero ts.
00:41:56 <Twey> Aye, I have no problem with Proxy as an example.
00:43:57 <shachaf> "produce" and "consume" are intuition words, not meaning words.
00:43:59 <Twey> Fuuzetsu: ↑ relevant to a discussion we had a long time ago
00:44:20 <shachaf> Probably good definitions of them would be "covariant" and "contravariant" respectively.
00:44:23 <Twey> shachaf: Well, I took ‘consumes’ to mean ‘contains in a negative position’
00:44:35 <Twey> Aye.
00:45:01 <shachaf> Well, in that case.
00:45:36 <shachaf> To answer the question properly you'd need to think of all sorts of cases like GADTs and things.
00:45:51 <shachaf> But the answer is probably yes.
00:46:05 <shachaf> Oh, is newtype DList a = DList ([a] -> [a]) a Functor?
00:46:20 <Twey> Can't be
00:46:25 <Twey> It's a, uh, Profunctor?
00:46:50 <shachaf> It has the wrong kind to be a Profunctor.
00:46:51 <Iceland_jack> Wrong kind
00:46:54 <shachaf> It has a Functor instance, though.
00:47:06 <Twey> Hm, not a Profunctor.
00:47:19 <Twey> Oh, it has Functor from Endo, I guess?
00:47:34 <Twey> Wait, no, that doesn't make sense either.
00:47:52 <shachaf> That type has an important invariant not enforced by the type system.
00:48:02 <Twey> To do the obvious map you have to provide both an (a → b) and a (b → a)
00:50:16 <LordBrain> hmm Proxy as an empty list, what library is being discussed here?
00:50:43 <LordBrain> i want to peek too
00:50:43 <shachaf> base
00:50:46 <LordBrain> just walked in
00:51:55 <LordBrain> i haven't got my bearing yet, Twey you have no problem with Proxy as an example of what?
00:52:12 <shachaf> A covariant functor (or a contravariant functor).
00:52:38 <shachaf> Alternatively, a type of kind * -> * which uses its parameter only in positive (or negative) position.
00:52:40 <cybercap> if i'm about to create a binary tree, where all nodes should be possible to hold a value. Would this datatype be enough?
00:52:41 <cybercap> data Tree a = Empty | Node a (Tree a) (Tree a)
00:52:54 <shachaf> There are logs in the channel topic if you want to see the previous discussion.
00:53:10 <shachaf> cybercap: Whether it's enough depends on what you want to do with it.
00:53:25 <shachaf> It's a tree.
00:54:05 <Twey> cybercap: Also, if it should only be *possible* for them to hold a value, you might want Node (Maybe a) (Tree a) (Tree a).
00:54:16 <Twey> Otherwise they *have* to hold a value.
00:54:44 <cybercap> okay, but if all nodes including the leafs must hold a value, then i guess it would be sufficient?
00:55:02 <shachaf> The leaves don't hold values. They are empty.
00:55:34 <shachaf> You invented that data type. You can probably work out how it works. :-)
00:55:43 <shachaf> Write out five sample trees.
00:56:37 <cybercap> :) True. But that's what i was wondering. I thought you could say that since the node is Empty, then it's not even a leaf. Its just empty, i.e. nothing
00:57:36 <shachaf> You can say anything you want.
00:57:40 <Twey> cybercap: It is a leaf of your tree.  But you can encode another tree whose leaves have values into your tree structure by replacing the leaves with branches whose children are both leaves.
00:57:40 <LordBrain> haha
00:57:59 <shachaf> There's no tree police, or even a tree working group that has a consensus on tree terminology.
00:58:03 <Twey> Heheh.
00:58:10 <cybercap> haha okay. well thanks for the input:)
00:58:18 <shachaf> You can find two people where one would say that Empty is a leaf and one would say that it isn't.
00:58:34 <LordBrain> there's a tree without leaves in my backyard
00:58:42 <Twey> Is that so?  I would say it's a leaf.  I'd be surprised if someone told me it isn't a leaf.
00:58:51 <shachaf> They're called leaves because they leave the trees in the fall. Which is why it's called fall.
00:59:43 <LordBrain> if you don't want them empty, just change Empty to Leaf a
00:59:48 <Twey> shachaf: That is actually why it's called fall.
01:00:39 <LordBrain> this conversation really deteriorated
01:01:18 <glguy> defoliated?
01:01:42 <Twey> Hah.
01:01:47 <cybercap> mm:) liek this Tree a = Leaf a | Node a (Tree a) (Tree a)
01:02:52 <shachaf> That's another possible tree type. It's less nice.
01:03:33 <LordBrain> well you could have empty as a 3rd term
01:03:33 <cybercap> what would be a more ncie type according to you?
01:03:57 <LordBrain> cybercap, what are you using it for?
01:04:16 <LordBrain> is it just a teaching yourself exercise?
01:04:19 <glguy> data Tree a = Node (Maybe (Tree a)) a (Maybe (Tree a)) -- let's keep 'em coming
01:04:20 <cybercap> nothing to be honest. Just trying to learn the language
01:05:17 <glguy> data Tree a = Leaf a | Node (Tree a) (Tree a) -- There are lots of ways to go, just depends on what you're doing at the moment
01:05:51 <LordBrain> cybercap, ok, well one apporach is to generalize, where it doesn't look recursive any more, instead of (Tree a) for the branches, you have a type variable corresponding to the branch
01:06:12 <Twey> That way lies Cofree
01:07:03 <LordBrain> haskellers usually call that style GADT
01:08:08 <Twey> LordBrain: ?
01:08:14 <glguy> They call which style gadt?
01:08:59 <erikd> should https://www.haskell.org/haskellwiki/Arrays mention the vector library?
01:09:07 <shachaf> Glguy Algebraic Data Type
01:09:12 <LordBrain> haha
01:09:14 <Twey> erikd: Maybe as a See Also?
01:11:07 <erikd> Twey: i woudl have thought it deserved its own section. eg a section for both ummutable and mutable unboxed vectors.
01:11:27 <Twey> Well, Repa is in there, so I suppose it does
01:13:31 <erikd> might see if i can do that after i figure out how to use MVector myself
01:15:54 <LordBrain> this is embarrassing i confused the words, gadts are something else, and now i cant remember the word for the technique i described. I don't know why they are connected in my mind, maybe i read a paper where one evolved out of the other, is that possible?
01:18:17 <LordBrain> perhaps the paper that introduced gadt syntax to haskell
01:41:07 * hackagebot xlsx 0.1.0.4 - Simple and incomplete Excel file parser/writer  http://hackage.haskell.org/package/xlsx-0.1.0.4 (KirillZaborsky)
01:41:09 * hackagebot seqloc 0.6.1 - Handle sequence locations for bioinformatics  http://hackage.haskell.org/package/seqloc-0.6.1 (NicholasIngolia)
01:44:33 <makalu> jaspervdj: here?
01:45:54 <ski> LordBrain : .. i'd call it IndirectComposite
01:46:27 <ski> @where DecoratingStructures
01:46:28 <lambdabot> <http://web.archive.org/web/20051126143527/http://haskell.org/hawiki/DecoratingStructures>
01:46:29 <ski> @where IndirectComposite
01:46:29 <lambdabot> <http://web.archive.org/web/20051126141834/http://haskell.org/hawiki/IndirectComposite>
01:54:12 <cybercap> At https://www.haskell.org/haskellwiki/Currying, there is an exercise: Simplify curry id. What shall be the answer?
01:54:57 <shachaf> It's an exercise.
01:55:38 <cybercap> yes i know. But I dont get it
01:56:13 <cybercap> okay
01:56:22 <cybercap> (,)
01:56:31 <shachaf> Yes, that's as simplified as it can get.
01:57:31 <cybercap> I derived the type and found it returned a pair but just didn't think that pair had such a constructor
01:58:25 <shachaf> @src curry
01:58:25 <lambdabot> curry f x y = f (x, y)
01:58:31 <shachaf> @src id
01:58:31 <lambdabot> id x = x
01:58:47 <shachaf> So curry id x y = id (x,y)
01:58:56 <shachaf> = (x,y)
01:59:03 * glguy becomes hungry
01:59:05 <shachaf> So curry id = \x y -> (x,y)
02:00:09 <noquarter> question
02:00:22 <noquarter> say i want to define a function that does addition of integers modulo 5
02:00:29 <noquarter> i want to do something like, (`mod` 5).(+)
02:00:43 <noquarter> but i keep getting a type error because ghci doesn't know that 5 is an integer
02:00:55 <shachaf> That's not the reason you're getting a type error.
02:01:03 <shachaf> (f . g) x = f (g x)
02:01:21 <shachaf> So ((`mod` 5).(+)) x = (`mod` 5) ((+) x)
02:01:38 <shachaf> But ((+) x) is a function, not an integer.
02:01:40 <cybercap> hm, then i guess the answer to the snd question: uncurry const is fst?
02:02:05 <shachaf> Looks like it.
02:02:08 <noquarter> shachaf: sure
02:02:10 <cybercap> nice=)
02:02:22 <shachaf> (I'd call that the fst question, not the snd question. But that's just me.)
02:02:25 <noquarter> shachaf: hm. so how do i do this then?
02:02:37 <shachaf> noquarter: The clearest way is to use named arguments.
02:02:46 <shachaf> You know, f x y = (x + y) `mod` 5
02:03:05 <shachaf> If you want it to be point-free, probably something like ((`mod` 5) .) . (+)
02:03:08 <noquarter> shachaf: sure, but i'm defining this specifically for an instance of a typeclass Ring
02:03:09 <shachaf> But that's pretty awful.
02:03:22 <shachaf> What does the fact that it's for an instance have to do with it?
02:03:34 <noquarter> shachaf: i'm new to this so i'm very likely wrong :P
02:03:45 <noquarter> shachaf: but i guess you're right
02:03:54 <noquarter> shachaf: Ring has a function add :: a -> a -> a
02:04:03 <noquarter> shachaf: the example, the ring of the integers, has add = (+)
02:04:09 <noquarter> shachaf: so i was trying to make this point free as well
02:04:13 <noquarter> shachaf: but i suppose there's no reason to
02:04:14 <shachaf> OK, so instance Ring Integer where add x y = (x + y) `mod` 5
02:04:20 <noquarter> shachaf: right
02:04:35 <shachaf> Use point-free when it makes your code better.
02:04:41 <saep> noquarter: Readibility and personal comfort is way more important than point-free style.
02:05:27 <ski> @type curry ((`mod` 5) . uncurry (+))  -- not really any better
02:05:28 <lambdabot> Integral c => c -> c -> c
02:05:43 * ski agrees with saep,shachaf
02:05:57 <noquarter> cool, thanks guys
02:06:02 <noquarter> okay, one more question
02:06:20 <noquarter> now say i have another typeclass, Parsable, which has a function parse :: String -> Maybe (a, String)
02:06:25 <glguy> I agree with ski et al
02:06:31 <noquarter> and i want to implement parse for various Ring's
02:06:48 <noquarter> (i'm working through CIS194 btw)
02:07:00 <noquarter> i've been provided a working parse function for Integers
02:07:01 <shachaf> I agree with ski but not with glguy.
02:07:15 * ski . o O ( "&al." )
02:07:18 <noquarter> and we are told that parse "3" = (Just 3, "")
02:07:51 <noquarter> but when you run parse "3", you get an error, because ghc doesn't know you want to parse it to an integer, unless you do parse "3" :: (Maybe Integer, String)
02:07:54 <noquarter> is there a way to avoid that?
02:08:13 <ski> often the context will determine what you wanted to parse
02:08:35 <ski> but when you test in the interactor, there's no context (if you don't add it yourself with a type ascription like that)
02:08:41 <noquarter> i see
02:08:56 <noquarter> so if you did (parse "3") + 2
02:09:11 <ski> in actual code, usually you wouldn't need a type ascription (or something to the same effect) -- in some cases you do, though
02:09:11 <noquarter> well that doesn't work either
02:09:50 <ski> noquarter : try `(fmap . first) (2 +) (parse "3")'
02:12:02 <glguy> Probably doesn't have first in scope
02:12:11 <ski> @index first
02:12:11 <lambdabot> Control.Arrow
02:12:57 <ski> noquarter : you could give a name `Parser a' for `String -> Maybe (a,String)' .. if you make `Parser' into a `Functor', then it'd be just `fmap (2 +) (parse "3")', or `(2 +) <*> parse "3"'
02:13:13 <ski> er, sorry, should be `<$>', not `<*>'
02:13:35 <noquarter> ski: don't know functors yet :O
02:13:48 <ski> ok
02:13:57 <J_Arcane> heh heh. @lp is fun.
02:13:59 <glguy> I feel like this is getting incrementally more complicated ^_^
02:14:03 <J_Arcane> *@pl
02:14:15 <ski> glguy : as usual ?
02:14:17 <bramgg> How can I run a function every 10 seconds in Haskell?
02:15:13 <ski> noquarter : do you want to learn them now ?
02:15:41 <ski> noquarter : do you know `Maybe',`Either',`[]' ?
02:15:54 <ski> noquarter : do you know how `data' works ?
02:16:01 <zipper> bramgg: How how interesting. I wish to know too.
02:16:13 <glguy> Probably a mix of forkIO and threadDelay or finding a scheduling package on hackage
02:16:44 <bramgg> thanks
02:16:58 <agocorona> You know that you are a haskeller when your fixpoint expression spans beyond the right corner of the screen
02:17:22 <ski> agocorona : long lines ?
02:17:40 <J_Arcane> agocorona: I ran into one of those last night, though in the end it turned out I just had some extra steps I didn't need.
02:20:52 <agocorona> I´m being ironic (of course)
02:21:31 <ski> well, i sometimes do something like
02:21:38 <ski>   fix $ \f x ->
02:21:41 <agocorona> ironic <|> sarcastic
02:21:41 <ski>     ..f..x..
02:22:28 <ski> (or did you mean s/fixpoint/pointless/ ?)
02:22:41 <bramgg> Does "(GHC only)" in a method description on Hackage mean it won't work in GHCi/runhaskell?
02:23:37 <saep> bramgg: It means it doesn't work (or is not known to work) with intrepreters/compilers other than GHC.
02:23:45 <bramgg> thanks
02:24:35 <saep> So it works in GHCi and in runhaskell if it is equivalent to runghc.
02:26:14 <agocorona> sky: I meant pointfree, sorry
02:27:56 <ski> ok
02:33:10 <d3lxa> hey what do you think of my CLI that runs sql queries on files/pipes? in haskell of course :D https://github.com/axel-angel/haxquery it's a prototype
02:56:10 * hackagebot compare-type 0.1.1 - compare types of any kinds in haskell  http://hackage.haskell.org/package/compare-type-0.1.1 (Kinokkory)
03:13:20 <benwf> why's got haskell no ternary operator, anyway? does someone know? i mean, it alwas requires an else, so it should fit well, shouldn't it
03:19:06 <jle`> benwf: maybe to help declutter the operator namespace?
03:19:24 <ahihi> benwf: what would be the benefit over the existing if-then-else expression?
03:19:31 <jle`> (:) is already in base and (?) is defined in a bunch of libraries i think
03:20:11 <rom1504> because "if then else" *is* the ternary operator
03:20:31 <phaazon> hey
03:20:36 <phaazon> I’d like to be able to write this:
03:20:50 <phaazon> foo :: [forall a. (AConstraint a) => (a,String)] -> …
03:20:55 <benwf> ahihi technically nothing, it's just fits at least me better for in place syntax
03:20:57 <phaazon> I thought it was RankNTypes
03:20:59 <phaazon> am I wrong?
03:21:04 <jle`> it's actually ImpredicativeTypes
03:21:10 <phaazon> oh, thanks :)
03:21:19 <jle`> because you use a forall inside a type parameter
03:21:23 <jle`> like Maybe (forall a. a)
03:21:31 <phaazon> yeah
03:21:36 <phaazon> but that’s wanted
03:21:53 <jle`> i hear that impredicative types is broken
03:22:03 <phaazon> ?
03:22:03 <jle`> something either about the implementation or the very idea of it...i'm not sure
03:22:12 <phaazon> well
03:22:14 <benwf> instead of something like x -> if a then b else c just x-> a ? b : c
03:22:21 <phaazon> I don’t want to do explicit quantification
03:22:31 <benwf> jle` well true on that :) (namespace clutter)
03:23:10 <rom1504> to me the main usefulness of the ternary operator is that it's a if-then-else that return a value
03:23:19 <rom1504> in other languages I mean
03:23:21 <jle`> phaazon: the traditional route is to use a newtype i think
03:23:28 <phaazon> jle`, ?
03:23:34 <phaazon> yeah
03:23:35 <ahihi> benwf: to me, that just looks like obfuscation :)
03:23:36 <phaazon> quantification
03:23:36 <jle`> if you want to avoid impredicative types
03:23:45 <phaazon> ExistentialQuantification
03:23:52 <phaazon> but I don’t want to use a newtype
03:23:56 <exio4> > let (?) = \x y z -> if x then y else z then True ? 42 $ 1337
03:23:57 <lambdabot>  <hint>:1:40: parse error on input ‘then’
03:24:08 <exio4> > let (?) = \x y z -> if x then y else z in True ? 42 $ 1337
03:24:10 <lambdabot>  42
03:24:15 <exio4> > let (?) = \x y z -> if x then y else z in False ? 42 $ 1337
03:24:16 <lambdabot>  1337
03:24:21 <phaazon> that would be adding more boiler code
03:24:38 <benwf> there's a solution, too: https://caffeinatedcode.wordpress.com/2008/04/11/haskell-the-ternary-operator/
03:24:54 <jle`> impredicative types has a reputation for being a bad ideafor something to put into ghc in the first place
03:24:55 <benwf> ski in #haskell-beginners also posted a nice solution
03:25:00 <benwf> but in fact i was just wondering, that's all :)
03:25:04 <jle`> or just broken in implementation
03:25:14 <jle`> maybe there is a cleaner way to express what you want to express?
03:25:32 <jle`> sometimes it's sufficient to just store the method itself
03:25:46 <jle`> instead of storing Show a => (a, Int), store (String, Int), for example
03:26:25 <jle`> or ([(a, Int)], a -> String)
03:29:23 <phaazon> jle`, well
03:29:27 <phaazon> I’m dealing with shaders
03:29:35 <phaazon> VertexShader, GeometryShader, FragmentShader, and so on
03:29:46 <phaazon> I have a function that takes a ShaderLike s (constraint) value
03:29:49 <phaazon> and compile it
03:30:00 <phaazon> very often, I don’t compile my shader one by one
03:30:07 <phaazon> I put them all in a list of pairs
03:30:08 <phaazon> like
03:30:17 <jle`> what can you do with a ShaderLike?
03:30:21 <phaazon> [(VertexShader,vsSrc),(FragmentShader,fsSrc)]
03:30:28 <phaazon> jle`, shaderID and compile
03:30:50 <phaazon> so that with ImpredictiveTypes, compileAll = mapM_ (uncurry compile)
03:30:57 <phaazon> +a
03:31:30 <jle`> can you store a list of [VertexShader vsSrc, FragmentShader fsSrc]?
03:31:41 <jle`> er
03:31:43 <jle`> compile
03:31:50 <jle`> [compile VertextShader vsSrc, ...]
03:32:13 <phaazon> jle`, I could
03:32:30 <jle`> it would be functionally identical to the impredicative version
03:32:36 <ski> phaazon : do you want `[forall a. AConstraint a => (a,String)]' or `[exists a. AConstraint a *> (a,String)]' ?
03:32:37 <phaazon> yeah
03:32:38 <jle`> except you lose shaderID
03:32:38 <phaazon> indeed
03:32:53 <phaazon> I don’t know “exists”
03:33:01 <phaazon> my current implementation uses forall
03:33:11 <ski> `exists' doesn't exists
03:33:21 <ski> i'm asking about what you want/intend
03:33:42 <phaazon> compileSeveral :: (MonadIO,MonadLogger m,MonadError Log m) => [forall s. (ShaderLike s) => (s,String)] -> m (); compileSeveral = mapM_ (uncurry compile)
03:34:16 <phaazon> I think it might be too much I guess
03:34:26 <jle`> if you passed in a list of [m ()]'s, then compileSeveral = sequence_
03:34:35 <phaazon> yes
03:34:42 <phaazon> but I’d like to provide a function buildProgram
03:34:51 <phaazon> that does all the compiling / attaching stuff for the user
03:35:00 <ski> phaazon> :t (VertexShader,vsSrc)
03:35:07 <ski> phaazon> :t (FragmentShader,fsSrc)
03:35:24 <phaazon> (VertexShader,String)
03:35:28 <phaazon> (FragmentShader,String)
03:35:38 <phaazon> I want type safety on shaders
03:35:42 <exio4> that sounds like an ADT would be better
03:35:45 <phaazon> I use a constraint to unify them
03:36:04 <ski> phaazon : looks to me you want existentials
03:36:12 <phaazon> nah
03:36:19 <phaazon> it’s boilercode on interface
03:36:24 <phaazon> I don’t want AnyShader
03:36:25 <ski> (so `[forall a. AConstraint a => (a,String)]' is not what you want, then)
03:36:45 <jle`> what is your intended type of buildProgram ?
03:37:11 <ski> (when i said "existentials", i didn't necessarily mean `ExistentialQuantification' (which is somewhat of a misnomer, imo))
03:37:16 <phaazon> jle`, (MonadIO m,Monadlogger m,MonadError Log m) => [forall s. (Shaderlike s) => (s,String)] -> m Program
03:39:13 <ski> phaazon : if `exists' (and `*>') did exist, then i think that you'd want `compileSeveral :: (MonadIO m,MonadLogger m,MonadError Log m) => [exists s. ShaderLike s *> (s,String)] -> m ()' .. wrapping in a new `AnyShader' (using `ExistentialQuantification') is one current way to effect this
03:39:42 <noquarter> say i have a method "parse" defined for two instances of a Ring class
03:39:53 <noquarter> one is the ring of integers, one is the ring of integers mod 5
03:39:56 <ski> .. it would alternatively be possible to CPS the list .. but i think that'll be ugly, here
03:40:03 <noquarter> so in the ring of integers, parse "3 + 6" should be 9
03:40:08 <phaazon> ski, the idea is to expose that as a user function
03:40:10 <ski> noquarter : it should ?
03:40:14 <noquarter> and in the ring of integers mod 5, parse "3 + 6" should be 4
03:40:15 <phaazon> exposing AnyShader is ugly to me
03:40:22 <noquarter> if i write parse "3 + 6", how do i specify which parse i intend?
03:40:28 <opqdonut> noquarter: type it
03:40:32 <opqdonut> just like when using read
03:40:34 <ski> phaazon : yes, i understand
03:40:35 <phaazon> why is ImpredicativeTypes so bad?
03:40:39 <opqdonut> > read "9" :: Float
03:40:39 <noquarter> ive never really used read
03:40:40 <lambdabot>  9.0
03:40:46 <opqdonut> > read "9" :: Integer
03:40:47 <lambdabot>  9
03:40:48 <phaazon> it sounds perfect for my wish
03:41:05 <phaazon> noquarter, I use read during contests :)
03:41:26 <ski> phaazon : even with `ImpredicativeTypes', i don't think you want `[forall s. Shaderlike s)=> (s,String)]'
03:41:28 <phaazon> > read "nine" :: Float
03:41:29 <lambdabot>  *Exception: Prelude.read: no parse
03:41:50 <phaazon> ski, yes I do
03:41:57 <phaazon> it’s the same thing than “exists”
03:41:59 <phaazon> right?
03:42:04 <phaazon> without the boilerplate of AnyShader
03:42:06 <ski> phaazon : not at all
03:42:09 <phaazon> ah
03:42:23 <phaazon> so “Existential”Quantification is a really poorly chosen name
03:42:42 <phaazon> it should be UniversalQuantification
03:42:49 <ski> phaazon : if you used `[forall s. Shaderlike s=> (s,String)]', then nothing similar to `[(VertexShader,vsSrc),(FragmentShader,fsSrc)]' would be of this type
03:43:02 <phaazon> what does that mean then?
03:43:09 <neuroserpens> Guys, is there a tool for design made with haskell? I'm looking for something like Blender which you can use for art but there's also a scripting interface. And I'm sorry if my question is stupid.
03:43:54 <ski> phaazon : `[forall s. Shaderlike s=> (s,String)]' means that the elements of the list are *polymorphic* in `s' .. `(VertexShader,vsSrc)' isn't polymorphic (it uses a specific type for `s', as opposed to working for all choices of `s' (satisfying `Shaderlike s')) .. likewise for `(FragmentShader,fsSrc)'
03:44:32 <phaazon> I see
03:44:34 <ski> phaazon : this is why i asked whether you meant `[forall s. Blah s => ..s..]' or `[exists s. Blah s *> ..s..]'
03:44:40 <phaazon> it requires the element of it to be polymorphic
03:44:44 <ski> right
03:44:45 <phaazon> which is not the case for VertexShader
03:44:51 <ski> which is not what you want here
03:44:54 <phaazon> so yeah
03:44:59 <phaazon> I’d rather like something like “exists”
03:45:07 <phaazon> would it be to exist
03:45:22 <ski> phaazon : "fusing" `Shaderlike s' with `s', has has been suggested above, may work
03:45:31 <phaazon> [m ()] ?
03:45:32 <phaazon> yeah
03:45:38 <phaazon> I shall do that then
03:46:00 <ski> phaazon : yes, `exists' would be quite nice -- there's some conceptual problems with it, but perhaps it could be possible to have an acceptable design
03:46:18 <phaazon> storing issues?
03:46:28 <phaazon> the aligment of such a list would be… weird
03:46:51 <ski> (LHC has `exists', but only in negative positions, which is easy, and only gives a little bit more convenience)
03:46:51 <phaazon> since I could make () an instance of ShaderLike, and the list allocation would be changed
03:47:32 <ski> phaazon : assuming a boxing implementation, that shouldn't be a problem (and if otherwise, you'd have the same problem with `[Maybe a]',&c.)
03:47:50 <phaazon> yeah
03:47:51 <ski> phaazon : what are the methods of `Shaderlike' (all of them, please, including superclasses) ?
03:48:42 <lpaste> phaazon pasted “ShaderLike -- ski” at http://lpaste.net/118184
03:49:07 <ski> ninedotnine : it's not stupid. i don't know the answer. perhaps try reasking again in a little while ?
03:49:11 <phaazon> I even think I could put compile out of there
03:50:24 <phaazon> well, actually, not really
03:52:59 <ski> phaazon : yes, so instead of `[exists s. ShaderLike s *> (s,String)]' (which you currently can't write exactly, but can still encode), you could then use `[(GLuint,forall m. (MonadIO m,MonadLogger m,MonadError Log m) => String -> m (),String)]' -- iow instead of `[(VertexShader,vsSrc),(FragmentShader,fsSrc)]' you'd have `[(shaderID VertexShader,compile VertexShader,vsSrc),(shaderID FragmentShader,compile FragmentShader,fsSrc)]'
03:53:06 <ski> hrm :
03:53:20 <ski> -- iow instead of `[(VertexShader,vsSrc),(FragmentShader,fsSrc)]' you'd have `[(shaderID VertexShader,compile VertexShader,vsSrc),(shaderID FragmentShader,compile FragmentShader,fsSrc)]'
03:53:45 <phaazon> yeah
03:53:47 <phaazon> but now
03:53:55 <ski> phaazon : that's what i meant by "fusing `Shaderlike s'" with `(s,String)' here .. it has the same expressivity
03:54:03 <phaazon> yeah
03:54:08 <phaazon> I do something similar :
03:54:18 <phaazon> sequence_ [compile vs,compile fs]
03:54:40 <ski> (if `s' had occured otherwhere than as a single argument type of a method in `Shaderlike' (or a superclass), then one couldn't do this)
03:55:27 <ski> phaazon : for your specific use case, it might be nicer to directly apply `compile' to the second argument directly, if it's available (perhaps it's `vsSrc' and `fsSrc' ?)
03:55:42 <ski> (and if you don't need the `shaderID', just skip that part)
03:56:21 <ski> also, if you already know (at least abstractly) at this point which `m' you're going to need, you can then avoid the `forall m. (MonadIO m,MonadLogger m,MonadError Log m) => ' part as well
03:56:51 <ski> phaazon : iow, then getting your `[m ()]'
03:57:22 * ski nods to phaazon
03:58:00 <phaazon> ski, I don’t
03:58:06 <phaazon> and that’s a part I need to work on
03:58:12 <ski> phaazon : i just wanted to explain the intermediate steps in more detail, so that you could more easily see what to try in another situation using existentials somehow similarly
03:58:17 <phaazon> I really don’t like transformers in signatures
03:58:20 <phaazon> it’s filthy to me
03:58:29 <phaazon> yep
03:58:32 <phaazon> thank you very much :)
03:58:35 <ski> phaazon : you don't what ?
03:58:49 <phaazon> I don’t like stacks in signatures
03:59:03 <phaazon> instead of (MonadIO m,MonadLogger m,MonadError Log m)
03:59:09 <phaazon> you coul use something like
03:59:22 <ski> phaazon : but do you or do you now (abstractly, at least) know the `m' you want to use, at the time you construct the list ?
03:59:27 <phaazon> MonadJournalT Log (EitherT Log) …
03:59:33 <phaazon> no
03:59:37 <ski> if you don't, then you need `[forall m. ..m..]'
04:00:19 <ski> if you do, then you can get by with `[..SpecificM..]' or `[..m..]' (the abstract version)
04:00:51 <alpounet> can't you just use 'm' in the return type? your shaders can be described by their source code + ID, can't they?
04:00:58 <ski> (in the latter case, you'll probably need constraints on `m', attached to the *whole* type signature -- as opposed to occuring *inside* the list type constructor)
04:02:08 <J_Arcane> Interesting. There's libtcod bindings for Haskell. I wonder how well they work.
04:02:14 <ski> phaazon : by "I really don’t like transformers in signatures" do you mean you don't like using `MonadJournalT Log (EitherT Log)' or you don't like using `(MonadIO m,MonadLogger m,MonadError Log m)' ?
04:02:33 <phaazon> the former
04:02:37 <ski> ok
04:02:38 <phaazon> the latter is the thing to do, to me
04:02:53 <phaazon> because it enable to write code without having to worry about the real types
04:03:02 <ski> then there's still the option between `forall' inside the list, and outside it
04:03:05 <phaazon> I often use MonadIO instead of IO
04:03:36 <ski> inside is more powerful. outside is easier the manage
04:03:49 <ski> you should probably go for outside, unless you need the inside one
04:04:20 <ski> s/the manage/to manage/
04:16:12 * hackagebot hpc-coveralls 0.8.1 - Coveralls.io support for Haskell.  http://hackage.haskell.org/package/hpc-coveralls-0.8.1 (killy971)
04:17:05 <Peaker> hmm.. record wild-cards let you access record fields, even if those aren't exported? woah
04:17:18 <Peaker> so the names of record fields are always exported, whether you export them or not
04:17:20 <ski> that must be a bug ?
04:17:52 <Peaker> oh, nope, export list does work
04:17:56 <Peaker> but the import list doesn't
04:18:10 <Peaker> (import list doesn't list fields, only data constructor, but with RecordWildCards they're still there)
04:18:42 <ski> but do you get all of them, or just the ones explicitly exported ?
04:19:06 <Peaker> just the ones explicitly exported
04:19:11 <Peaker> the export side is correct, the import side is.. surprising
04:20:36 <ski> i think i see
04:46:24 <giantoctopus> Hi folks, just learning Haskell and wondering if there is a shorter way of writing a lambda like (\x -> x) ?
04:47:03 <indiagreen> giantoctopus: do you mean “id”?
04:47:04 <indiagreen> :t id
04:47:05 <lambdabot> a -> a
04:47:08 <indiagreen> :t (\x -> x)
04:47:09 <lambdabot> t -> t
04:47:57 <giantoctopus> awesome, thanks indiagreen !
04:49:35 <noquarter> :q
04:49:35 <noquarter> quit
04:49:35 <noquarter> exit
04:55:02 <wacco> fresh install, quick question! oh, no irssi.. right.. compile.. no glib, ah, still needs xcode.. get from app store, 2.4GB & half an hour waiting time!
04:55:49 <wacco> webchat it is :)
04:55:49 <wacco> ANYWAYS HI
05:00:33 <wacco> playing with the run length encoding exercise question @ http://en.wikibooks.org/wiki/Haskell/More_about_lists
05:00:33 <wacco> and I have rlRead n = (a, head b): rlRead (tail b) where [(a, b)] = reads n
05:01:10 <wacco> wondering though, is there an "opposite" for reads? so I can replace head with "string up 'till next number"
05:04:41 <matematikaadit> wacco: what do you mean by "string up 'till next number"? could you give an example?
05:08:23 <wacco> sure; "3Foo4Bar" would result in [(3, "Foo"),(4, "Bar")], where reads gives [(3, "Foo4Bar")] and I'd need something to get "Foo" split as "head"/"tail"
05:10:12 <wacco> splitAt number or something
05:12:44 <matematikaadit> wacco: maybe you could use break and isDigit
05:12:45 <matematikaadit> :t break
05:12:45 <matematikaadit> :t isDigit
05:12:46 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
05:12:46 <lambdabot> Char -> Bool
05:13:31 <matematikaadit> > break isDigit "Foo4Bar"
05:13:32 <lambdabot>  ("Foo","4Bar")
05:13:40 <wacco> nice!
05:13:51 <wacco> see, I knew something like this would already exist
05:16:33 <matematikaadit> there also a groupBy
05:16:38 <matematikaadit> :t groupBy
05:16:39 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
05:17:47 <matematikaadit> so you could grouping a consecutive element
05:18:50 <wacco> I already used 'group' earlier, forgot that was a special case :)
05:21:11 <matematikaadit> there are a bunch of useful function for working with list in Data.List
05:32:31 <trunks1ace> why does lookUp :: Eq a => a -> [(a, b)] -> b /br lookUp item list = head ([ y | (x,y) <- list, item == x]) /br give an error of *** Exception: Prelude.undefined
05:33:12 <indiagreen> trunks1ace: when applied to what value?
05:33:39 <trunks1ace> lookUp 5 [(5,10)] for example gives that error
05:34:18 <indiagreen> it doesn't to me
05:34:49 <indiagreen> are you sure you are pasting the right code?
05:37:05 <trunks1ace> indiagreen: I took it out of the program file in which it was contained and applied it separately and it worked, seems to be a problem elsewhere. Thanks tho!
05:37:47 <sivteck> head errors on empty list
05:39:53 <trunks1ace> indiagreen: your right I was compiling another file with the same name :|
05:40:28 <kraljev10> Hey, I have a class A from library. Now I want to make function accept either A or B. I have made it like this data C = A | B, but it says A is ambiguous?
05:40:49 <kraljev10> would anybody be so kind to explain this?
05:41:44 <day> why do all haskell tutorials focus so badly on lists?
05:41:45 <kraljev10> How to achieve something like this?
05:42:13 <day> while other rlanguage tutorials show how to write stuff like functions/if/while/for etc...?
05:42:14 <tremon> kraljev10: you have created a new data type with type constructors A and B. The two A's refer to different concepts
05:42:58 <kraljev10> tremon: type A is coming from a library. I want my function to accept either type A or my own type B. What to do?
05:43:08 <matematikaadit> kraljev10: f :: A a => Maybe a -> ...
05:43:50 <exio4> day, lists in haskell (and functional programming) are used as data and control structures
05:44:41 <matematikaadit> is A a type or class?
05:44:49 <day> i see. i figured that they are powerful, but not that powerful
05:45:10 <tremon> kraljev10: create a wrapper type like WrappedType = HasA A | HasB B (indeed assuming A is a type, not a typeclass)
05:45:23 <matematikaadit> kraljev10: it it's a type, then you could do f :: Either A B -> ...
05:46:07 <ski> kraljev10 : there are no (nondisjoint) union types in Haskell
05:46:15 <kraljev10> tremon: function has to accept A in  a raw form, not constructed with HasA
05:46:22 <ski> kraljev10 : presumably your `A' from the library is a type, not a type class
05:46:37 <ski> kraljev10 : what's `HasA' ?
05:46:52 * ski notices what tremon said
05:47:39 <kraljev10> data A alpha beta  = A (alpha -> Maybe beta) (beta -> Maybe alpha)
05:47:44 <kraljev10> this comes from a library
05:47:44 <ski> kraljev10 : how will the function detect whether it's passed an `A' or a `B' ? possible the representation of some `A' value is equal to the repreentation of some `B' value. the function needs some extra information to distinguish between them
05:48:10 <ski> kraljev10 : tremon's `HasA' and `HasB' tagging gives this extra bit of information
05:48:19 <ski> kraljev10 : how is `B' defined ?
05:48:35 <kraljev10> Let's say it's an Int
05:48:39 <ski> ok
05:48:53 <ski> then you really need an extra distinguishing bit
05:49:21 <kraljev10> what if it's another data class
05:49:33 <ski> (if the intension was that some values could belong to both `A' and `B', the situation would have been different. but haskell doesn't have union types)
05:49:35 <wayne> does the wiki seem slow for anyone else?
05:49:43 <ski> kraljev10 : this `A' is not a class
05:49:48 <ski> it's a data type
05:50:03 <ski> type classes in Haskell are different from classes in Object-Oriented Programming
05:50:18 <kraljev10> yep, my mistake. Union types would be what I'm looking for
05:50:36 <ski> kraljev10 : .. in some cases you can factor out the common bits
05:51:45 <ski> (factor like `A = Common * ExtraA', `B = Common * ExtraB', then `A + B = Common * (ExtraA + ExtraB)' .. where `*' means "and", and `+' means "or")
05:52:08 <tremon> kraljev10: in haskell, a function can only have one type signature. So if you want to be able to pass in either an A or a B, you need some way to combine the types A and B into a common type
05:52:26 <ski> kraljev10 : what specific `B' did you intend ? did you intend overlap between `A' and `B' ?
05:53:15 <ski> kraljev10 : .. an alterative way to make the function being able to accept both an `A' and a `B' is to construct a type class, and make both `A' and `B' instances of it
05:54:55 <ski> kraljev10 : if the type class is called `C', then you could have `function :: C a => a -> ...', meaning it'll accept a value of any type `a' that's in type class `C' (so, types `A' and `B' and possibly other types that are later added to `C')
05:55:20 <foolie> http://lpaste.net/118185 i'm doing this poor mans tree structure and visiting the elements with the function at line 10. In my head the pattern at line 13 should stop the infinite structure, but this is not the case. Any tips or resources to read how should I fix my code?
05:55:32 <ski> kraljev10 : .. it's hard to tell whether this would be a good idea for your sitution, since you haven't provided much info on what you want to do
05:56:52 <ski> foolie : you can't have directly cyclic types (in Haskell). you need to indirect the recursion through making a new, named, type
05:58:12 <ski> foolie : e.g. `type Forest a = [Tree a]; data Tree a = Node a (Forest a)'
05:58:47 <ski> foolie : btw, you don't need the `dealBranch (a, []) = ...' case. the recursion will stop because `mapM' does nothing when the list is empty
05:59:46 <ski> foolie : .. if you just want to fix a typo (or something similar) in a paste. use "Edit". otherwise, it's good to use "Annotate"
06:00:02 <ski> foolie : so, you'll get then
06:00:13 <ski>   stringTree :: Forest String
06:00:58 <ski>   stringTree = [Node "string1"
06:01:20 <ski>                      [Node "string2"
06:01:24 <foolie> ski: ah, sweet thanks! yeah, the code paste was a bit of a disaster and the edits I did can't be seen unless it is expanded, ah well :P
06:01:38 <ski>                            [Node "string3" []
06:01:43 <ski>                            ,Node "string4" []
06:01:46 <ski>                            ,Node "string5" []
06:01:50 <ski>                            ]
06:01:55 <ski>                      ]
06:02:03 <ski>                ]
06:02:13 <ski> foolie : "expanded" ?
06:02:35 <ski> oh, i see you made some edits
06:02:56 <ski> i think the last edit is what is shown, if you don't ask to see another one
06:03:41 <ski> foolie : so, it would be more reasonable here to rename s/stringTree/stringForest/ (or remove the outermost list wrapping, changing the type signature)
06:03:57 <ski> foolie : the type signature for `dealBranch' now becomes
06:04:31 <random-jellyfish> does immutability have anything to do with functional purity? I mean you could have functions that use local mutable variables...they will be pure because they will return the same output for the same inputs and they will not depend on any external state or have any side effects
06:04:45 <ski>   dealBranch :: Tree a -> M T
06:05:01 <ski> where `M' is some monad and `M T' is the return type of `C.rectangle'
06:05:37 <ski> (btw, you (usually) don't need the type signatures, but i think it's usually clearer to put them in, at least on top-level definitions)
06:05:44 <Black-Heaven> Hi all, I'm trying to use the 'free' package, I have added it in the build-depends field of my .cabal, run cabal configure and cabal build, it seems fine until I run a cabal repl which throw me that I have to add 'free' to my cabal file because Control.Monad.Free is a module of the idden package free. Which step have I missed? Thanks by advance.
06:05:59 <ski> foolie : can you complete/update the definition of `dealBranch' now, using this `Tree' type
06:06:46 <ski> (oh right, `a' in the signature for `dealBranch' may need to be `String' or some other specific type, in case you want to do something with the node labels)
06:07:10 <foolie> ski: thanks a lot, I get into it
06:08:07 <ski> (if you really want to, you could write `Node (label,forest)' instead of `Node label forest' .. if you change the data type definition accordingly)
06:09:50 <ski> day : lists can be used for control because Haskell is non-strict. (normally) not all elements of a list has to be evaluated before you can do something with them
06:10:36 <ski> day : in a strict language, to get something similar, you'd need some kind of delayed streams, or perhaps generators or iterators
06:11:23 * ski stares at kraljev10
06:12:25 <ski> random-jellyfish : yes and yes
06:13:25 <random-jellyfish> ski so can we have functional programming without immutable data? would it still be called functional?
06:14:52 <ski> "functional programming" is, imho, perhaps somewhat of a misnomer (depending)
06:15:20 <ski> (also, "pure" is a bit vague)
06:15:25 <ski> @where purely-functional
06:15:26 <lambdabot> "What is a Purely Functional Language?" by Amr Sabry in 1993-01 at <https://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps>
06:16:31 <ski> random-jellyfish : one main complication with (shared) mutable data is that identity enters the picture
06:17:15 <ski> random-jellyfish : .. it's not clear if you're only talking about mutable variables, or also about mutable data structures
06:17:53 <ski> (.. you could have the latter without the former)
06:18:08 <random-jellyfish> "pure" doesn't seem at all vague to me...a pure funtion always return the same thing for the same arguments...are purity and immutability  two ortogonal concepts? or is there some connection between them?
06:18:41 <ski> see the above paper for five(?) subtly different meanings that "purely functional" have been assigned
06:19:12 <random-jellyfish> ok, thanks
06:19:33 <zwer> random-jellyfish what if you mutate a global variable that some function depends on?
06:19:51 <ski> zwer : what would fall under "depend on any external state"
06:20:03 <random-jellyfish> zwer: that has nothing to do with the issue that I brought up
06:20:17 <ski> random-jellyfish : no ?
06:20:37 <random-jellyfish> I was talking about the possibility of local mutable variables inside functions
06:20:58 <random-jellyfish> you only manipulate them while the function is evaluated
06:21:13 <ski> if you call the function with the same (or equal/equivalent) arguments, but some (more) global scope variable has been mutated inbetween, your function could give different results, if it inspects it
06:21:45 <ski> random-jellyfish : in Haskell, local mutable state is afforded by the `ST s' monad
06:22:17 * ski is still not clear on exactly what random-jellyfish is asking about
06:23:16 <random-jellyfish> take this C function : int f(int x) { int a; a=0; a=a+1; a=a+2; return x+a; }
06:23:23 <random-jellyfish> a is a mutable variable
06:23:29 <ski> (also, "without immutable data" sounds perhaps a bit strange. maybe you're thinking of something like Smalltalk, assuming every value in the language is a (mutable) object, including integers, and booleans (?))
06:23:31 <random-jellyfish> but the function f is still pure
06:23:36 <ski> sure
06:23:42 <random-jellyfish> because it returns the same result for the same x
06:23:44 <random-jellyfish> always
06:24:11 <ski> what is the question ?
06:24:52 <random-jellyfish> I thought that "pure functions" are main building blocks of a functional programming language...why is immutability imposed if you can have pure functions that can use local mutable variables inside of them?
06:25:11 <vanila> you can do that in haskell using ST monad
06:25:24 <ski> if you only have immutable data, then it's much easier to get purity
06:25:24 <vanila> it lets you program mutable state and localize to a pure function
06:25:36 <ski> but as vanila says, you can get mutability with `ST'
06:25:44 <Cale> > let f x = runST (do a <- newSTRef 0; modifySTRef a (+1); modifySTRef a (+2); v <- readSTRef a; return (x + v)) in map f [1..10]
06:25:46 <lambdabot>  [4,5,6,7,8,9,10,11,12,13]
06:26:09 <zwer> and unlike in C you are guaranteed to have a mutable local state with ST monad. in C you can just as easily mutate a global variable
06:26:34 <ski> Cale's example is a relatively faithful translation of your C
06:26:41 <vanila> th same is true of functional languages like scheme and ocaml
06:26:52 <vanila> haskell is much more pure
06:27:25 <random-jellyfish> ok but behind the courtains monads are modeled using immutable data too right? with the exception of the IO monad
06:27:39 <vanila> usually, this particuar monad is special
06:27:45 <vanila> ST and IO
06:27:49 <ski> behind the curtains, monads are modelled in category theory
06:28:26 <random-jellyfish> ok so ST and IO are "special", good to know, I'm not very familiar with the ST monad yet, I have to study it more
06:28:26 <Cale> random-jellyfish: ST's implementation in GHC does real mutation
06:28:31 <ski> in an implementation, `IO', and probably `ST', needs special support by the run-time system (just like `Double' and `Integer' and `Int' and `(->)' all does)
06:28:47 <vanila> its pretty rare to need to use ST monad though!
06:28:55 <ski> random-jellyfish : `Integer' is also "special"
06:29:14 <ski> (and `(->)' even more so)
06:29:30 <random-jellyfish> how is Integer special?
06:29:40 <ski> it is not defined in the language
06:29:52 <ski> it needs special support from the implementation
06:29:57 <mr-> And has a staggering number of constructors :-)
06:30:19 <vanila> oh yeah isn't Integer backed by libgmp?
06:31:53 <ski> (otoh, `Maybe',`Bool',`[]' are (or might as well have been) defined in the language, though the two latter has some special syntactic sugar support. `Bool's also figure in list comprehensions and guards)
06:31:53 <random-jellyfish> I still don't understand what kind of special support is needed for Integer :)
06:32:00 <random-jellyfish> support for what?
06:32:08 <ski> random-jellyfish : addition, multiplication, &c.
06:32:18 <ski> primitive operations on `Integer'
06:32:30 <ski> just like the implementation provides primitive operations on `IO' and `ST'
06:32:47 <ski> (and neither of these are defined in the language)
06:32:47 <random-jellyfish> well I guess all programming languages need that kind of support from a lower level
06:33:01 <ski> you don't need it for `Maybe',`Either' !
06:33:15 <ski> or `State' or `Reader' or `Writer' or `Cont' or ...
06:33:22 <random-jellyfish> yeah I know, maybe is easy to define
06:33:43 <zwer> ski what is stopping you from implementing Integer in haskell? a very naive and slow implementation: data Integer { digits :: [Word8] }
06:33:55 <ski> this is more or less the only way in which `IO' and `ST' are special
06:33:57 <exio4> and what is Word8?
06:34:05 <wayne> how can i use list comprehensions to form a list of functions?
06:34:11 <ski> zwer : nothing. but it's not defined that way in the standard
06:34:27 <randomclown> wayne: [ id | i <- [1..10] ]
06:34:35 * ski would have said `Bool' instead of `Word8'
06:34:42 <random-jellyfish> it might also be possible to define Integers through Church numerals
06:34:53 <ski> yes, it is
06:35:46 <random-jellyfish> but it would probably be very inefficient
06:36:27 <ski> aye
06:36:40 <exio4> you can theorically do anything, but I think sanity reasons would count there
06:36:45 <vanila> binary numbers are much more efficient than church numerals (which are unary)
06:36:57 <vanila> because a binary number takes up O(log(n)) space, but a unary takes up O(n)
06:37:23 * ski always cringes whenever someone calls it "unary"
06:37:32 <vanila> ski, what do you call it?
06:37:46 <ski> peano representation
06:38:13 <vanila> what is wrong with calling it unary? I don't like when people call it base 1 but unary seems fine
06:39:21 <ski> (to me, unary would be base `1' .. and you can only express `0' there, assuming a least residue system for the digits)
06:39:39 <vanila> but thats not the definition of unary!
06:39:44 <ski> unary, binary, ternary, &c.
06:40:09 <vanila> they arent in the same group
06:40:14 <vanila> {unary}, {binary, ternary, ...}
06:40:35 <ski> <https://en.wiktionary.org/wiki/unary> suggests they are
06:51:07 <giantoctopus> total n00b here - I am wondering why function composition works for functions of different arity
06:51:19 * hackagebot typedquery 0.1.0.2 - Parser for SQL augmented with types  http://hackage.haskell.org/package/typedquery-0.1.0.2 (tolysz)
06:51:42 <giantoctopus> ie - why something like this - `((+) . (*10)) 3 8` even works if (*10) takes one argument and (+) takes two
06:52:43 <zwer> (+) takes one argument too. all the functions do
06:52:58 <Cale> :t (+)
06:52:58 <lambdabot> Num a => a -> a -> a
06:53:12 <Cale> You can read that as Num a => a -> (a -> a)
06:53:16 <ski> giantoctopus : all functions take exactly one argument. we just sometimes pretend otherwise
06:53:45 <ski>      ((+) . (*10)) 3 8
06:53:50 <ski>   =  (((+) . (*10)) 3) 8
06:54:03 <ski>   =  ((+) ((*10) 3)) 8
06:54:07 <giantoctopus> oh, so that works because the composition is right associative?
06:54:12 <ski>   =  ((+) (3 * 10)) 8
06:54:23 <ski>   =  (3 * 10) + 8
06:54:32 <Cale> The associativity of the composition operator doesn't matter because there's only one occurrence of composition in the expression
06:54:54 <Cale> However, the fact that function application is left associative does matter here
06:55:10 <Cale> (that's what ski's first step used)
06:55:39 <Cale> i.e. f x y means (f x) y
06:56:24 <giantoctopus> my brain hurts
06:56:28 <giantoctopus> but thanks :)
06:57:08 <Cale> and to go along with that, the (->) in types is right associative, so the type A -> B -> C means A -> (B -> C)
06:57:13 <zwer> (+) takes one argument and returns a function that takes one argument
06:57:33 <ski> giantoctopus : so, since `(g . f) x' is `g (f x)', then `(g . f) x y' is `g (f x) y' -- now just plug in the particular values `(+)',`(*10)',`3',`8' in place of `g',`f',`x',`y', and resugar `(+) a b' into `a + b' and `(*10) c' into `c * 10'
06:57:40 <Cale> and whenever you have a function which appears to take more than one argument, it's really a function which takes the first argument and produces another function
06:58:07 <ski> (except if it's using tupled style to "appears to take more than one argument" :)
07:00:20 <matematikaadit> what they call data type that has kind * -> * , for example Maybe, [], etc.
07:00:44 <giantoctopus> oh, I think i'm getting it
07:00:53 <HeladoDeBrownie> matematikaadit, data type of kind * -> *, mostly
07:00:54 <giantoctopus> so function composition does not create a new function
07:01:21 <Cale> giantoctopus: Well, it does...
07:01:22 <giantoctopus> just left-folds its parts?
07:01:35 <Cale> It's just that (f . g) x = f (g x)
07:01:41 <ski> matematikaadit : a (first-order) type function. sometimes (more generally) a "non-concrete type"
07:01:48 <Cale> You can also write that equation as (f . g) = \x -> f (g x)
07:01:51 <Cale> if you prefer
07:02:22 <ski>      (f . g) a b
07:02:31 <ski>   =  (\x -> f (g x)) a b
07:02:40 <ski>   =  (f (g a)) b
07:02:43 <ski>   =  f (g a) b
07:02:57 <ski> giantoctopus : slightly longer derivation, but amounts to the same thing
07:03:27 <ski> (the last step there is just a resugaring step)
07:03:49 <Cale> We could also look at this at the type level. Let's assume that (+) :: Integer -> (Integer -> Integer) and (*2) :: Integer -> Integer
07:04:05 <Cale> We know that (.) :: (b -> c) -> (a -> b) -> (a -> c)
07:04:27 <Cale> So in order for (+) to be the first argument to (.), we must have b = Integer, and c = Integer -> Integer
07:04:53 <Cale> and then in order for (*2) to be the second argument, we must have a = Integer, and b = Integer
07:05:26 <ski> (and fortunately, those two equations for `b' doesn't contradict each other)
07:05:27 <Cale> and the result, (+) . (*2) will have type (a -> c), which is Integer -> (Integer -> Integer)
07:05:44 <wayne> is there something built-in that does this?
07:05:45 <wayne> let pick ps xs = map (\p -> xs !! p) ps
07:06:00 <wayne> > pick [0,2] [2,4,6]
07:06:00 <wayne> [2,6]
07:06:01 <lambdabot>  Not in scope: ‘pick’
07:06:01 <lambdabot>  Perhaps you meant one of these:
07:06:01 <lambdabot>    ‘BS.pack’ (imported from Data.ByteString),
07:06:16 <Cale> and then applying that to an Integer, ((+) . (*2)) 5 for instance, will have type Integer -> Integer
07:06:16 <matematikaadit> ah, thanks ski.
07:06:48 <Cale> and then we can apply it to another Integer, so ((+) . (*2)) 5 6  will have type Integer
07:07:10 <ski> wayne : unless you sort the indices, i think there's probably not much to gain by not spelling it out (except for having a known common name for it, in case you use it much)
07:07:25 <giantoctopus> Cale, I think I get it now, thanks!
07:07:26 <foolie> ski, your code worked like plug and play, thanks! Here's the updated & version: http://lpaste.net/118185
07:07:35 <ski> wayne : .. for other data structures, the answer could be different
07:07:36 <Cale> !! is usually an operation you want to avoid using very much
07:07:57 <Cale> For a couple reasons: one is that xs !! n takes O(n) steps to reduce
07:08:08 <wayne> yeah that's why i was wondering if there was a builtin
07:08:09 <Cale> and the other is that you can have bounds failures which kill your program
07:08:27 <Cale> This is a fundamental property, there's no more efficient way to do it
07:08:30 <wayne> it could use around O(n) to deliver all desired elements plus some sorting things
07:08:39 <ski> foolie : i'll suggest that if/when you make substantive changes, like this, you use "Annotate" instead of "Edit", so that one can easily see both the original and the new version at the same time
07:08:43 <wayne> as opposed to calling !! n times
07:08:47 <Cale> (It's just that lists do not support efficient random access, so if you need random access, you use some other structure)
07:08:48 <wayne> er p,
07:09:04 <Cale> Yeah, if you sort first, then it's possible to do better
07:09:24 <ski> foolie : also, i forgot to say before, it would probably be better to use `mapM_' rather than `mapM' here
07:09:59 <ski> foolie : .. and i would replace `Render()' with `Render ()' :)
07:10:13 <Cale> But it might be best just to make a Map and then do a bunch of lookups in it
07:10:38 <giantoctopus> wayne I think you could have a smart recursion
07:11:45 <foolie> ski: yup! may I ask what's the difference between mapM and mapM_
07:12:01 <srhb> :t mapM
07:12:01 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
07:12:02 <Cale> > let m = M.fromList (zip [0..] "hello") in map (\k -> M.lookup k m) [3,4,1,2]
07:12:03 <srhb> :t mapM_
07:12:05 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
07:12:06 <lambdabot>  [Just 'l',Just 'o',Just 'e',Just 'l']
07:12:16 <ski> foolie : `mapM' will construct a list of all the monadic results. `mapM_' will just drop them on the floor
07:12:30 <Cale> > let m = M.fromList (zip [0..] "hello") in map (m !) [3,4,1,2] -- or if you want to live dangerously
07:12:31 <lambdabot>  Couldn't match expected type ‘GHC.Arr.Array a0 b’
07:12:31 <lambdabot>              with actual type ‘Data.Map.Base.Map k0 GHC.Types.Char’
07:12:37 <Cale> oh, oops
07:12:40 <Cale> > let m = M.fromList (zip [0..] "hello") in map (m M.!) [3,4,1,2] -- or if you want to live dangerously
07:12:42 <lambdabot>  "loel"
07:12:50 <Adeon> there's also traverse and traverse_ that are more general than mapM and mapM_
07:13:00 <ski> wayne : *nod*
07:13:16 <ski> i'm not aware of any such existing operation for lists
07:13:16 <foolie> ski, srhb ah I see, thanks
07:13:50 <wayne> yeah looks like i'll have to write my own lookup util like Cale just did. thanks
07:14:14 <giantoctopus> pick :: Int -> [Int] -> [a] -> [a]
07:14:14 <giantoctopus> pick _ [] _ = []
07:14:15 <giantoctopus> pick pos positions@(x:xs) source@(y:ys) =
07:14:15 <giantoctopus>     | pos == x = y : pick(xs : ys)
07:14:17 <giantoctopus>     | otherwise = pick (pos + 1) postions source
07:14:42 <giantoctopus> or something to that effect
07:15:03 <Cale> I don't think that typechecks...
07:15:13 <exio4> xs : ys doesn't look right
07:15:39 <giantoctopus> sorry
07:15:56 <giantoctopus> | pos == x = y : pick (pos +1) xs  ys
07:16:51 <giantoctopus> theoretically something like that should work - and should be linear
07:16:54 <ski> foolie : you could also possibly make your `Tree' an instance of `Foldable' and then write
07:17:08 <ski>   dealBranch = mapM_ $ \name -> do
07:17:15 <ski>     C.textPath name
07:17:19 <ski>     C.fill
07:17:42 <ski> (assuming you make it an instance of `Foldable', corresponding to a postorder traversal of the tree)
07:17:57 <ski> where this `mapM_' is the one from `Data.Foldable'
07:18:02 <ski> @type Data.Foldable.mapM_
07:18:03 <lambdabot> (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
07:18:17 <ski> (which is a generalization of the usual one)
07:18:27 <ClockCat> is learning haskell a good way to learn functional thinking for someone that isn't getting it, or is another place better to start?
07:19:05 <ski> ClockCat : depends on whether you want or think you need to get thrown in the deep end, or alternatively take it more slowly
07:19:10 <matematikaadit> alternatively: pick ps xs = map snd $ filter (\(i, x) -> i `elem` ps) ([0..] `zip` xs)
07:19:23 <ClockCat> i figure immersing myself in something i don't understand is probably the best way for me
07:19:39 <ClockCat> i just don't know if haskell is the best place to do it
07:19:52 <foolie> ski: yeah, that looks neat
07:19:54 <Cale> ClockCat: Yeah, if you have no pressing need to produce something useful immediately, then learning Haskell is probably the quickest way to get to a state where you're comfortable with everything.
07:20:06 <wayne> ClockCat: yes, but lisp/scheme might be good too so you don't have to learn complicated things about types while trying to learn FP paradigms
07:20:24 <ClockCat> i'm coming from javascript
07:20:28 <ClockCat> so
07:21:20 * hackagebot cipher-aes 0.2.10 - Fast AES cipher implementation with advanced mode of operations  http://hackage.haskell.org/package/cipher-aes-0.2.10 (VincentHanquez)
07:21:21 <Cale> I don't know, I think types are actually a very useful help when you're starting out. If you make type errors in scheme, your programs just don't work correctly, rather than getting a message from the compiler with at least a line number explaining where to look for a mistake (even if you don't understand the message yet)
07:21:25 <wayne> javascript isn't a bad place to start either, but the other mentioned languages have functional programming as the norm instead of on occasion
07:21:40 <ski> foolie : though, if you're going to fix a postorder traversal on the `Foldable' (and `Traversable', if you also do that) instance, then i'd either rename it to emphasize that it's postorder, or i'd swap the order of the subforest and the label in the node -- an alternative is to first mirror the tree before using (preorder) traversal `mapM_'
07:21:54 <ClockCat> hmm, alright thanks
07:21:55 <giantoctopus> wayne - here's a solution I checked to be working: http://pastebin.com/Q0YhEHGb
07:22:15 <giantoctopus> then you call pick 0 [0,2] [2, 4, 6]
07:22:27 <Cale> Of course, it can be frustrating because your program doesn't run, but then once you solve the type errors, having it usually work is pretty cool :)
07:22:33 <giantoctopus> or you can create a partially applied function like pick0 = pick 0
07:22:46 <ski> ClockCat : you could try starting with LYAH or <https://github.com/bitemyapp/learnhaskell>
07:22:48 <wayne> what's the first parameter do?
07:22:50 <ski> @where LYAH
07:22:50 <lambdabot> http://www.learnyouahaskell.com/
07:23:03 <ski> also, you might initially first want to try
07:23:06 <ski> @where tryhaskell
07:23:06 <lambdabot> http://tryhaskell.org/
07:23:08 <giantoctopus> it starts iteration at the 1st element in position
07:23:12 <giantoctopus> *positions
07:23:20 <wayne> ah i see
07:23:35 <giantoctopus> once that is found it increments etc
07:23:52 <ClockCat> thanks :)
07:23:54 <wayne> yeah nice recursion
07:23:55 <giantoctopus> it's linear
07:24:16 <ski> ClockCat : as wayne said (or possibly implied, rather), reading SICP (and watching the videos), learning some Scheme on the way, would possibly also be good
07:24:20 <ski> @where SICP
07:24:20 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
07:24:28 <giantoctopus> and has a certain intimidating factor
07:24:35 <ski> (the first two links)
07:27:01 <Phillemann> Is there a library in hackage for building small gui applications in ncurses (like the dialog program)?
07:27:51 <ski> Cale : well, but see "Re: [mercury-users] Mercury in academic teaching?" by Richard A. O'Keefe in 2006-10-{09,10} at <http://www.mercurylang.org/list-archives/users/2006-October/004000.html>,<http://www.mercurylang.org/list-archives/users/2006-October/004011.html> (on whether types first is better or not)
07:28:08 <ski> ClockCat : if you're interested ^
07:28:39 <ClockCat> hmm thanks
07:29:16 <ski> (context : Mercury is a statically checked logic programming languegue. Prolog is a dynamically checked logic programming language)
07:29:57 <ski> (but those two posts are about more than Prolog vs. Mercury, not being restricted to logic programming)
07:36:49 <osa1> I'm playing with weak references in GHCi, is there a way to force a value to be garbage collected?
07:38:53 <osa1> so let's say I have "let key = []" and I used it as key of a weak reference
07:39:12 <osa1> then I do "let key = 1" and performMajorGC
07:39:21 <osa1> should I expect the weak reference to return Nothing now?
07:41:47 <day> the advantage of lazy functional programming is that the program can decided whether to do something or not, right? But doesnt gcc do something similar by telling me (this variable is defined but not used?)
07:43:55 <srhb> day: That's not really related to laziness. While gcc might point out that something is completely unnecessary and never used, many of such computations will still be executed and take up valuable resources
07:44:19 <srhb> day: eg. if you have foo = some long computation; in main() but never use the result (or its side effects)
07:44:22 <wayne> is there syntax to bind a parameter besides parens?
07:44:28 <osa1> do weak references even work in ghci?
07:44:33 <wayne> in J, i'd write somethine like addTwo=:2&+
07:44:39 <wayne> then i could addTwo 8
07:44:48 <srhb> day: Conversely, let foo = some long computation -- will not matter in main in ghchaskell if it is never used.
07:44:49 <day> srhb: well i would need to remove it manually
07:44:49 <vanila> \x -> 2 + x
07:45:01 <vanila> addTwo = \x -> 2 + x
07:45:06 <srhb> day: Yes, but that has nothing to do with laziness (or non-strictness)
07:45:10 <tzaeru> srhb, well, it's very likely that gcc optimizes the whole thing away if the result is never used :P
07:45:16 <srhb> Indeed
07:45:24 <srhb> That said, it still has nothing to do with laziness.
07:45:28 <tzaeru> yeah.
07:45:48 <day> why not? :X
07:45:52 <wayne> i was hoping for something short and sweet that i could use in expressions, but i guess that's not in the spirit of clarity
07:46:03 <wayne> something like $
07:46:06 <day> because the lines wont be removed in haskell, and the program decides itself?
07:46:29 <tzaeru> day, a lazy program generally only calls a function when it's return value is actually used by something else.
07:46:32 <srhb> day: The concept is just much more specific. Read the lazy evaluation article on Wikipedia for instance. :)
07:46:43 <day>  / it waits with the execution of something until it needs it. but due to the fact that it never needs it, it will never be executed?
07:46:45 <tzaeru> if gcc does not optimize away your function call, it will do it immediatelly and in order when the program reaches that part
07:47:31 <phooby> hey, just wondering what happens under the hood in the expression "pure (+) <*> pure 1 <*> pure 2" ? the applicative context remains polymorphic but it runs and yields 3 :)
07:47:53 <tzaeru> lazy evaluation is kinda runtime thing, too.
07:48:01 <SrPx> When you want to extend a standard library with a few functions (say, extending Data.Tree with scan), where is the recommended way to include your extensions, within a Haskell project? Should I create another file, Data/Tree.hs?
07:48:07 <srhb> phooby: Meaning it would work for IO, Lists, Maybe...
07:48:20 <tzaeru> day, if the return value is never actually needed on runtime, yes, it wont be executed.
07:48:21 <phooby> shrb, ah, so the interpreter instantiates the context to be IO?
07:48:36 <phooby> srhb even
07:48:37 <srhb> phooby: ghci might, yes. I'm not sure. Try annotating it.
07:49:19 <phooby> srhb, yeah, that must be it. should've thought about it. it's just that i pretty much never run stuff in ghci and this time did :D thanks!
07:49:25 <tzaeru> day, in practice, if you had "int my_value = my_function(); if (rand()%2 == 0) printf("%i", my_value);" gcc wouldn't optimize my_function away and it would be ran every time you run the program
07:49:31 <ski> wayne : brackets don't bind parameters
07:49:52 <tzaeru> day, but runtime lazy evaluation will only do "my_function()" if rand() returned a number that is divisable by two.
07:50:15 <tzaeru> or well, it's still technically possible that gcc optimized it away :P
07:50:15 <srhb> wayne: I don't actually understand what you mean by binding parameters anyway. Can you clarify?
07:50:32 <tzaeru> would really need even more complex example to reach a point where gcc definitely wont optimize it away and where lazy evaluation would be visible.
07:51:00 <wayne> srhb: currying
07:51:41 <srhb> :t curry
07:51:42 <lambdabot> ((a, b) -> c) -> a -> b -> c
07:51:54 <wayne> ski: and i see your point because "(5 +) . (2 *) 2" doesn't work
07:51:57 <srhb> wayne: So, you're talking about transforming a function of one argument into a function of two?
07:52:28 <wayne> srhb: other way around...
07:52:33 <srhb> wayne: So uncurrying.
07:52:41 <Black-Heaven> How to fix cabal repl when it doesn't find a module while cabal build find it?
07:52:50 <srhb> :t uncurry
07:52:51 <lambdabot> (a -> b -> c) -> (a, b) -> c
07:53:12 <ski> wayne : that presumably was meant to be `((5 +) . (2 *)) 2', which on desugaring is `(.) ((+) 5) ((*) 2) 2', or `(((.) ((+) 5)) ((*) 2)) 2' if you want more brackets
07:53:45 <srhb> > (uncurry (+) (1,2), (+) 1 2)
07:53:47 <lambdabot>  (3,3)
07:57:41 <wayne> srhb: sorry, i meant partial application.
07:58:17 <srhb> wayne: I don't really see how that relates to binding parameters, but I suppose you've got your question answered by ski. :)
07:58:23 <wayne> yes, i did.
07:58:59 <srhb> Anyway addTwo can be more succinctly expressed as (+2)
08:00:00 <ski> `(+ 2)' is called a "section" of `+'
08:00:02 <wayne> in the example of ((-) 2), i would say that 2 is "bonded" to the first argument of (-)
08:00:09 <ski> `(2 +)' is also a section
08:00:16 <srhb> Right and left sections, respectively
08:00:21 <srhb> wayne: Yes, that would make sense to me.
08:00:26 <ski> wayne : s/bonded/partially applieD/
08:00:35 <wayne> likewise ((flip (-)) 2) has 2 bonded to the second argument of (-)
08:00:36 <srhb> I think bound is fine.
08:00:38 <ski> srhb : i can't recall which is which of right and left :)
08:00:43 <kraljev10> I am defining a class, but its methods type should be polymorphic depending on the instance. What should I do?
08:00:50 <srhb> ski: The position of the argument. :)
08:01:08 <ski> wayne : `flip (-) 2' is more nicely written `subtract 2'
08:01:12 <srhb> So a left section of (/) is divWith and a right section is divBy
08:01:23 <kraljev10> *type polimorphic
08:01:24 <ski> srhb : which argument, the missing one or the supplied one ? :)
08:01:29 <srhb> The supplied one.
08:01:34 <ski> ok
08:01:52 <ski> because i possibly think it would be more natural to name it the other way around
08:02:04 <ski> (compare with left and right distributivity)
08:02:11 <wayne> cool didn't know that one
08:02:31 <srhb> ski: I suppose.
08:02:49 <kraljev10> anybody? When writing class definition, you have to specify types of functions. What if they are not known at this point?
08:03:08 <ski> kraljev10 : having polymorphic methods is no problem. having a polymorphic (and possibly constrained) class instance is also not a problem
08:03:43 <ski> kraljev10 : having a parameterized type is not a problem. having components/arguments of data structures be polymorphic can be done with an extension
08:03:51 <kraljev10> The class method ‘parseT’
08:03:53 <kraljev10>     mentions none of the type variables of the class Transform t
08:03:55 <kraljev10>     When checking the class method:
08:03:56 <wayne> could someone suggest how to rewrite this more idiomatically? http://pastebin.com/gcsb7cSP
08:03:57 <kraljev10>       parseT :: forall alpha beta. alpha -> Maybe beta
08:03:59 <kraljev10>     In the class declaration for ‘Transform’
08:04:04 <ski> kraljev10 : since you (presumably) are new, it's not clear to me which (if any) of these you'd like to do
08:05:06 <ski> kraljev10 : "they are not known" -- the types ?
08:05:07 <kraljev10> ski: The types of class methods are not known on class definition, but on instance definition
08:05:17 <srhb> wayne: Get rid of ; for one
08:06:04 <ski> kraljev10 : can you give an example of a specific type that you'd like to make an instance of `Transform' ?
08:06:21 <srhb> wayne: We would also use len `div` 2 as it's more natural to put the mathy binary operator between its arguments
08:06:38 <kraljev10> ski:
08:06:40 <kraljev10> class Transform t where
08:06:41 <ski> wayne : i'd use indix `div' .. as srhb said
08:06:42 <kraljev10>   parseT :: alpha -> Maybe beta
08:06:44 <kraljev10>   printT :: beta -> ReaderT Char Maybe alpha
08:07:03 <kraljev10> and then instance would be: parseT = (\x -> 2*x)
08:07:07 <ski> kraljev10 : you just stated the definition of the class. i'm asking about an intended *instance* type of the class
08:07:29 <kraljev10> parseT x = Some $ x+2
08:07:47 <ski> kraljev10 : a type class is not a type. there can't be such a thing as a value of a certain class (this isn't OOP classes. this is type classes, which is something else)
08:08:02 <srhb> wayne: Also the last line is completely unreadable to me. Is there not a more natural (mathy) way to write it?
08:08:35 <kraljev10> ski: thanks, I have to rethink everything
08:08:52 <ski> kraljev10 : and instance of a class consists of : a type (or types) that will replace the parameter(s) of the type class; and implementations of all the methods of the type class, for all these type(s)
08:08:54 <srhb> wayne: ie. is that a plus section in xs !! mid + -- scary!
08:09:23 <ski> kraljev10 : possibly you don't want/need to use type classes here at all, perhaps just an ordinary type suffices
08:09:33 <wayne> haha that was my fear. i like not using parentheses but that seems to have been my undoing
08:09:58 <wayne> not like i got rid of many at any rate
08:10:09 <ski> kraljev10 : you shouldn't use type classes unless you need to functionality (more or less ad-hoc overloading, and automatic instance construction, &c.) they provide
08:10:11 <srhb> wayne: If you can rewrite it with the parens, we can probably get rid of most of them.
08:10:20 <srhb> wayne: But right now I'm not even sure what it does. :-)
08:10:36 <wayne> ((xs !! mid) + (xs !! (mid-1))) / 2 -- how do we do this with less parens?
08:10:52 <ski> wayne : i'd not use `$'
08:11:15 <ski>   (xs !! mid + xs !! (mid - 1)) / 2
08:11:37 <ski> and i'd use `drop' here instead of `!!'
08:12:02 <foolie> [5~[5~[6~[6~
08:12:03 <foolie> [5~[6~±12
08:12:28 <wayne> ah, drop (mid-1) take 2
08:13:07 <srhb> wayne: http://lpaste.net/941673039936880640#a118202
08:13:10 <srhb> Something like that
08:14:04 <wayne> thanks srhb. i should learn more syntax before bothering everyone again.
08:14:25 <srhb> wayne: It's fine, no bother. You probably won't realize to use it before someone recommends it anyway. :-)
08:14:36 <ski>   medianOfSorted xs
08:14:46 <ski>     | odd len  = xs !! mid
08:14:57 <ski>     | otherwise = (prev + next) / 2
08:15:02 <ski>       where
08:15:10 <ski>       len = length xs
08:15:33 <ski>       mid = len `div` 2
08:15:37 <ski>       prev:next:_ = drop (mid - 1)
08:15:42 <ski> wayne : something like that, perhaps
08:15:49 <srhb> Yes, that's pretty clean.
08:15:57 <ski> er, the last line should of course be
08:15:59 <ski>       prev:next:_ = drop (mid - 1) xs
08:17:31 <ski> wayne : of course this will error out on the empty list, but there's no reasonable value then anyway. you might want to add a more informative error message for this cse
08:19:20 <wayne> thank you, that's really clean
08:19:23 <ski> kraljev10 : perhaps you mixed up the type signatures for `parseT' and `printT'
08:22:06 <ski> kraljev10 : perhaps you wanted `StateT [Char] Maybe' or possibly `SupplyT Char Maybe' (though you'll need to make a nicer wrapper around `supply',`exhausted' that calls `mzero' in case of no more input) .. see
08:22:10 <ski> @hackage monad-supply
08:22:10 <lambdabot> http://hackage.haskell.org/package/monad-supply
08:23:10 <ski> kraljev10 : *perhaps* you also wanted to say `class Transform alpha beta where ..alpha..beta..', i'm not sure
08:24:29 <EvanR_> not clean
08:24:31 <EvanR_> haskell
08:30:59 <haasn> In blaze-html: What's some function :: Text -> Html that will print the text with linebreaks preserved? Ie. \n -> <br /> in the resulting Html
08:34:33 <ski> EvanR_ ?
08:37:17 <rom1504> haasn: replace "\n" "<br />"
08:41:17 <EvanR_> ski: nevermind!
08:43:21 <rom1504> (in MissingH)
08:45:41 * ski . o O ( "Unclean! Unclean! or Purity Issues in Declarative Constraint Logic Programming." by Ralph Becket in 2006-03-28 at <https://mercurylang.org/information/papers.html#g12_unclean> )
08:46:10 <EvanR_> link broke
08:48:35 <ski> not here
08:49:04 <EvanR_> https://mercurylang.org/information/papers/g12_unclean.pdf.gz
08:49:12 <ski> yes
08:49:16 <EvanR_> 404
08:49:26 <ski> ah, i see
08:50:17 <EvanR_> mercury, interesting
08:53:53 <ski> try <https://web.archive.org/web/20130801074110/http:/www.mercurylang.org/information/papers/g12_unclean.pdf.gz> at <https://web.archive.org/web/20130801074110/http:/www.mercurylang.org/information/papers.html#g12_unclean>
09:02:08 <tegel2> is batman and superman not 2 different universes? seems wrong to have a gadgeteer and a superhuman in the same universe. I prefer Batman but clearly Superman would win.
09:02:32 * ski idly wonders how this is related to Haskell
09:02:50 <hpc> batman would be better at haskell
09:03:43 <Clint> yeah, superman doesn't understand functors
09:05:52 <tegel2> superman has his cryptonite though, batman could use it and win.
09:06:23 <hiptobecubic> no
09:06:54 <hiptobecubic> Superman's powers are completely insane. He can reverse time. There's really nothing batman could ever hope for.
09:07:14 <monochrom> superman and batman have complementary skills and make a great team.
09:07:26 <monochrom> even great marriage, some may say
09:07:50 <hiptobecubic> that also seems ridiculous. As interesting as batman is Superman is all you need. Ever.
09:07:54 <hiptobecubic> also not #haskell
09:08:23 <monochrom> superman lacks batman's intelligence
09:08:53 <hiptobecubic> who cares? He can literally blow up the entire city from space by shooting lazers from nipples?
09:09:07 <hiptobecubic> There's no need to think about it.
09:18:46 <rom1504> also he can code haskell at supraluminal speeds
09:20:26 <Hijiri> does he have a computer to accept keypresses at supraluminal speeds?
09:20:43 <EvanR_> yeah, its in the fortress of solitude
09:20:56 <EvanR_> batman made it for him
09:21:17 <benwf> but only batman does haskell at first try.
09:24:21 <EvanR_> (also frequency (of key presses for instance or lines of code) isnt a comparable measurement to speed (of light for instance))
09:31:09 <EvanR_> whats a good introductory book on type theory?
09:38:13 <dementorr> Can anyone tell me how can I install Control.Concurrent.Timer? I tried cabal install Control.Concurrent.Timer but it says that it doesn't exist...
09:38:49 <ReinH> @@ EvanR_ @google types and programming languages
09:38:50 <lambdabot>  EvanR_
09:38:50 <lambdabot>  http://www.cis.upenn.edu/~bcpierce/tapl/
09:38:50 <lambdabot>  Title: Types and Programming Languages
09:39:01 <geekosaur> cabal install timers
09:39:35 <ReinH> @hoogle Control.Concurrent.Timer
09:39:37 <lambdabot> package timerep
09:39:37 <lambdabot> package timers
09:39:37 <lambdabot> package timers-updatable
09:39:39 <geekosaur> (you can use hayoo or a full-hackage-indexing hoogle to get a package name from a module name. it would be nice if cabal could do that, though)
09:40:32 <dfeuer_> Ermargerd. Could someone please help whatever poor soul posted this question?     http://codereview.stackexchange.com/questions/75640/haskell-monads-sum-of-primes
09:41:09 <dementorr> Thx a lot... is there a way to install all packages from cabal? Because on windows when i install Haskell-Platform it installs all but on unix it doesnt ?
09:41:41 <Hijiri> on non-windows it's usually recommended to not use haskell platform
09:41:44 <Hijiri> and just use cabal + ghc
09:41:58 <dfeuer_> Dementorr, all of them? I don't know that it's possible to install all of them.
09:42:23 <Hijiri> I interpreted it as meaning that for any package installed, it's installed with cabal
09:44:34 <dementorr> Yeah.. nevermind, what I said was that when I am on Windows and I install Haskell-Platform, i dont need to manually install packages, it cames at default, but when I am on Linux I must do cabal install
09:46:19 <geekosaur> dementorr, that's basically what Hijiri told you, haskell platform is available for linux but some poeple believe it's evil and that nobody should install it
09:46:26 * hackagebot jailbreak-cabal 1.2 - Strip version restrictions from build dependencies in Cabal files.  http://hackage.haskell.org/package/jailbreak-cabal-1.2 (PeterSimons)
09:46:26 <geekosaur> but install packages at need manually
09:47:06 <geekosaur> (this is harder on windows because you often need C libraries that are bundled with the platform on windows)
09:51:20 <EvanR_> ReinH: thx didnt see the hightlight
09:51:26 * hackagebot lock-file 0.5.0.1 - Provide exclusive access to a resource using lock file.  http://hackage.haskell.org/package/lock-file-0.5.0.1 (PeterTrsko)
09:51:28 <ReinH> EvanR_: np
09:51:33 <EvanR_> tapl yeah i read a lot of this
09:51:46 <EvanR_> i found this book ttfp
09:52:56 <ReinH> EvanR_: Haven't read it but I've heard good things
09:53:57 <ReinH> EvanR_: if you're interested in a more pure math approach, http://www.paultaylor.eu/stable/Proofs+Types
09:54:42 <EvanR_> ill try that next
09:55:34 <ReinH> EvanR_: Pierce's Software Foundations would be nice, since using a theorem prover will really help you understand tt
09:55:55 <EvanR_> is that for coq
09:56:27 <ReinH> yep, by Pierce, the author of tapl
09:57:05 <ReinH> oh I mentioned that
09:57:33 <EvanR_> good
10:00:35 <quchen> Is there a way to install a binary using a sandbox in Cabal automaticall? I wrote a small script that does the "tmp -> sandbox -> cabal install -> mv-to-bindir" automatically since I've been needing this so much. Either I reinvented the wheel or I might as well post it to Reddit.
10:01:13 <dcoutts_> quchen: technically speaking this currently cannot be done in general, since we do not have relocatable installs
10:01:26 * hackagebot crypto-pubkey-types 0.4.3 - Generic cryptography Public keys algorithm types  http://hackage.haskell.org/package/crypto-pubkey-types-0.4.3 (VincentHanquez)
10:01:33 <quchen> dcoutts_: In what sense are installs not relocatable?
10:01:47 <dcoutts_> quchen: you cannot move them around and still have them work
10:01:51 <dcoutts_> in general
10:02:15 <quchen> dcoutts_: Oh, I did not know that. In what case can I not move binaries?
10:02:26 <dcoutts_> this is more obviously the case for dynamically linked binaries, but also for statically linked
10:02:37 <dcoutts_> exes with data files are one example
10:02:50 <dcoutts_> and in general, exes are configured knowing their own install location
10:03:05 <dcoutts_> in practice of course most simple exes when statically linked are relocatable
10:03:35 <dcoutts_> quchen: consider also libs that have data files
10:03:46 <dcoutts_> and also that libs know their install location
10:03:58 <quchen> That makes sense of course. Although I don't know any libs that have data files.
10:04:04 <dcoutts_> there are some
10:04:08 <quchen> But it's worth mentioning this in the readme.
10:05:05 <dcoutts_> quchen: so a more reliable approach (but still with some caveats) would be to make a sandbox with all the dependent libs, then configure the main exe package with the --prefix= final install location, and then install that (ie not into the sandbox)
10:05:33 <dcoutts_> it'd still fail for libs that care about their install location, but there's not so many of those
10:06:08 <ReinH> (It can't be done generally, but in practice it works for a large number of binaries)
10:09:25 <EvanR_> Either X (X -> _|_)
10:09:57 <EvanR_> it says "its easy to see why we cant have this for a general X"
10:10:06 <monochrom> Either B (B -> _|_), that's the question :)
10:10:17 <quchen> Is there a flag for Cabal to link everything statically? -disable-executable-dynamic sounds suggestive, but might be a red herring
10:10:31 <EvanR_> lol
10:10:59 <dcoutts_> quchen: that'd do, though it's also the default.
10:11:16 <EvanR_> is the justification simply that we dont know anything about X to make such a claim, or is it just philosophical
10:11:21 <monochrom> does "everything" include libc?
10:11:44 <quchen> monochrom: Stop that ;-)
10:12:20 <monochrom> no, I am serious. glibc imposes restrictions on statically linking glibc
10:13:11 <quchen> monochrom: My concern is more about moving things around on one computer.
10:13:19 <quchen> monochrom: (I want my executables linked so statically that when compiling the user gets a Raspi in the mail that can run it. It also comes with multiple different power plugs so it's relocatable around the world.) ;-)
10:18:30 <SrPx> I want to declare a type like this: "type Quad a = Quad (V4 (V3 a))". It is inconvenient, though, because I have to construct it like: `Quad (V4 a b c d)` instead of `Quad a b c d`. Is there any way to tell GHC that Quad and V4 are synonyms?
10:19:41 <glguy> When you declare a new type synonym with "type" you don't provide a new constructor on the right-hand side of the =, you're just naming a type. So   "type Quad a = V4 (V3 a)"
10:20:28 <glguy> and then you'll use a "Quad a" like a "V4 (V3 a)" because they're actually the same thing
10:26:27 * hackagebot relational-record-examples 0.2.0.0 - Examples of Haskell Relationa Record  http://hackage.haskell.org/package/relational-record-examples-0.2.0.0 (yuga)
10:28:09 <arboris> Is there a way to do dynamic code reloading in haskell?
10:30:21 <arboris> System.Plugins.Load seems to be the answer
10:32:56 <ReinH> SrPx: perhaps you meant newtype
10:33:29 <SrPx> Are you sure? I want Quad to work as a synonym for V4, the constructor, not just the type
10:33:46 <ReinH> SrPx: I'm not sure what meant, no
10:33:57 <SrPx> hmm I see
10:34:17 <ReinH> I was giving you an option to turn what you wrote into something that would work, but I'm not sure what you want
10:34:52 <glguy> You'd need to use an extension to have Quad be a synonym for the constructor called "Pattern Synonyms" see  https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/syntax-extns.html
10:34:59 <ReinH> You can't write data constructor synonyms.
10:35:24 <ReinH> Ah, pattern synonyms, I always forget those
10:35:27 <Cale> arboris: You might also be interested in the 'hint' package. Even though it looks like it's just using the GHC API for interpreting, if there are .o files available, it will load those.
10:36:28 * hackagebot lzma-conduit 1.1.2 - Conduit interface for lzma/xz compression.  http://hackage.haskell.org/package/lzma-conduit-1.1.2 (NathanHowell)
10:36:30 * hackagebot apiary 1.2.3 - Simple and type safe web framework that generate web API documentation.  http://hackage.haskell.org/package/apiary-1.2.3 (HirotomoMoriwaki)
10:36:47 <SrPx> glguy: ReinH I see thank you guys!
10:38:08 <ReinH> SrPx: linear already provides a type M43 fwiw
10:44:13 <neuroserpens> wtf how do i even run lambdacube?
10:44:22 <neuroserpens> oops wait nevermind
10:46:18 <ski> hmm, i wonder if parametricity yeilds `(forall x. Either x (x -> _|_)) -> _|_'
10:49:49 <Saizan> it should, yeah
10:51:21 <Saizan> it has to return the same constructor for both () and _|_, and either choice leads to a contradiction
10:59:01 <trunks1ace> I am running certain data through my program and it just completely blows up for some (ghc just fails and *main> is no longer shown and when I type weird symbols just show up) but the function works fine for other data, what does this mean?
11:00:05 <Thulsadum> trunks1ace: sounds like some ansi sequences screw up your terminal
11:00:54 <Thulsadum> trunks1ace: on linux/*nix: try Control + D to leave ghci and type (blindly) reset to restore your tty
11:00:56 <trunks1ace> Thulsadum: what does that mean and how do I solve it?
11:01:29 <yyttr3> Is there a reason that the language extension OverloadedStrings doesn't seem to work with Data.Text.Internal.Text? I can't figure out how to convert it to a string.
11:02:15 <srhb> yyttr3: The extension doesn't magically convert types
11:02:23 <srhb> yyttr3: It just makes string literals be polymorphic.
11:02:24 <Thulsadum> trunks1ace: if binary data is echoed to the terminal there might be some random so called escape sequences, which will irritate your terminal
11:02:58 <srhb> yyttr3: ie. it allows "foo" :: Data.Text.Internal.Text to be well typed
11:02:58 <J_Arcane> I am increasingly unimpressed with the quality of CodeWars' Haskell exercises.
11:03:03 <Thulsadum> trunks1ace: they are usaly used, for coloring, cursor positioning and such things.
11:03:52 <yyttr3> srhb: I was under the impression that if I passed a String to a function f: Data.Text.Internal.Text -> a, that Overloaded strings would allows this.
11:04:08 <srhb> yyttr3: Then you are under an incorrect impression.
11:04:19 <Thulsadum> trunks1ace: to fix the terminal, try ^D followed by `reset`; to prevent it, don't echo unescaped binary data. ;)
11:04:37 <srhb> yyttr3: You can however do f :: IsString a => a -> ... -- but that actually has nothing to do with the extension IIRC
11:05:16 <trunks1ace> Thulsadum: I reset outside of ghci as you said and it seemed to reset (flickered) and then tried again but the same problem occured, perhaps it is something to do with my code?
11:05:20 <srhb> yyttr3: The only thing the extension does is make literals mean IsString a => a instead of String
11:05:40 <yyttr3> srhb: I understand, thank you.
11:05:45 <srhb> Sure :)
11:05:53 <trunks1ace> Thulsadum: But i would expect some sort of error not a complete blow of up ghc if the code was erronous
11:06:58 <Thulsadum> trunks1ace: do you run or compile? it's sounds to me like a perfectly working code, but you are doing some output (putStr and friends) of binary data
11:08:54 <trunks1ace> Thulsadum: Ive been compiling as in: ghci file.hs
11:10:31 <Thulsadum> trunks1ace: i'm not sure, if ghci will run the main function automaticly or sth like that, maybe some else might help. ;) i'm afk for dinner now. :)
11:11:31 <trunks1ace> Thulsadum: okay, Thanks tho! much appreciated
11:12:39 <rom1504> is it me or is haskell.org slow ?
11:13:28 <anahumar> this is my first time hearing about haskell language
11:13:35 <anahumar> how long it's been out there/
11:13:40 <anahumar> ?
11:14:04 <tommd> anahumar: ~25 years
11:14:10 <anahumar> can anyone give me a youtube for a running application programmed by haskell?
11:14:23 <anahumar> tommd: :O
11:14:33 <anahumar> never ever heard about it
11:15:12 <anahumar> I wanna see something running using haskell
11:15:25 <tommd> Install the compiler then.
11:15:47 <tommd> darcs, ghc, gitit, haskellers.org, cryptol, bluespec...
11:16:31 <mimi_vx> git-annex
11:16:44 <mimi_vx> pandoc ..
11:16:49 <mimi_vx> hakyll
11:18:21 <anahumar> mimi_vx: are those apps names?
11:18:25 <anahumar> git-annex
11:18:37 <lucs> anahumar: https://www.haskell.org/haskellwiki/Haskell_in_industry
11:18:48 <tommd> @google gix-annex
11:18:49 <lambdabot> http://unix.stackexchange.com/questions/75557/init-gix-annex-additional-repo-with-existing-files
11:18:49 <lambdabot> Title: Init gix-annex additional repo with existing files - Unix & Linux Stack Exchange
11:18:53 <tommd> @google git-annex
11:18:53 <lambdabot> https://git-annex.branchable.com/
11:20:08 <anahumar> git-annex on youtube is just an animation
11:20:47 <tommd> What's with the youtube addiction?
11:21:19 <anahumar> https://www.youtube.com/watch?v=GySDvfRGb0A
11:22:22 <anahumar> tommd: what is your problem with youtube?
11:24:03 <tommd> It is just a single site - if the best resources are there then great but if not then find what you need wherever it is.
11:26:54 <systemfault> Cool, first time I see Microsoft release Haskell-based software. ( https://github.com/Microsoft/bond )
11:28:26 <Beardful> query ij
11:28:35 <Beardful> Ignore that ^
11:30:42 <Beardful> http://sprunge.us/BLUZ How do i put an exception on every other Char in otherwise ?
11:31:19 <ski> Saizan : .. but how to prove it :)
11:31:32 <anahumar> installing pandoc now
11:32:20 <mpickering> If you have any questions about pandoc feel free to ask me
11:33:12 <yyttr3> Does anyone know of a good book to read after "Types and programming languages" to understand the formal logical basis for type theory?
11:33:45 <chaosmasttter> hi, does anyone know why this paste http://lpaste.net/118205 does only working with kind annotations? (the commented out version does not work)
11:34:55 <John[Lisbeth]> I has some cabal troubles: http://lpaste.net/118206
11:35:15 <John[Lisbeth]> the only thing i have ever done in this container is install "haskell-platform"
11:36:23 <mpickering> chaosmasttter: What if (a :: *) (c :: * -> * -> *) and (b :: * -> *)
11:36:56 <John[Lisbeth]> any fedora users who are good with cabal?
11:37:43 <mpickering> Are you using a sandbox?
11:37:53 <John[Lisbeth]> yes this is fedora in a docker container
11:38:13 <John[Lisbeth]> all I've done is install haskell-platform through the package manager
11:38:41 <anahumar> pandoc: Cannot decode byte '\xe2': Data.Text.Encoding.Fusion.streamUtf8: Invalid UTF-8 stream
11:39:06 <mpickering> Your file needs to be UTF-8 encoded
11:39:17 <mpickering> used iconv to fix the bad characters
11:40:43 <anahumar> Is iconv another app or switch?
11:41:19 <mpickering> an app
11:41:31 <mpickering> or you can just save your source as UTF-8
11:41:51 <Saizan> ski: mh, do you believe in relational parametricity?
11:44:35 <anahumar> sounds cool .. I'll give it a try
11:44:38 <anahumar> thanks
11:46:05 <supki> John[Lisbeth]: could you rerun this with -v3 ?
11:46:18 <gilligan_> Anyone here using ghcmod-vim ? Just made a pull request for `ghcmod split` support : https://github.com/eagletmt/ghcmod-vim/pull/69
11:47:30 <eikke> gilligan_: cool! looking forward to get that in my editor!
11:48:08 <John[Lisbeth]> supki I don't know what you mean by -v3
11:48:13 <John[Lisbeth]> you have to be a little more specific
11:49:32 <mpickering> cabal install hell -v3
11:49:58 <supki> yeah, that
11:50:04 <supki> to get more useful logs
11:50:52 <John[Lisbeth]> no, that didn't work
11:50:53 <sleepynate> mpickering: hell: You need to re-run the 'configure' command. The version of Hell being used has changed (was Hell-1.22.0, now Hell-1.666.0.0).
11:51:02 <John[Lisbeth]> it did a little bit more but there were the same dependency issues
11:51:16 <John[Lisbeth]> as in cabal configure?
11:52:07 <sleepynate> oh sorry John[Lisbeth] i was just goofing around. didn't realize we were trying to get actual help here. i'll go back to being quiet :)
11:52:24 <mpickering> please post that log John[Lisbeth]
11:52:34 <mpickering> -v3 is the verbosity command
11:52:50 <John[Lisbeth]> hold on I already started another command
11:52:56 <John[Lisbeth]> let me open an identical container and try -v3
11:54:40 <Saizan> ski: got a bit mangled above, but here's my take using a shallow embedding of parametricity http://lpaste.net/118208#line38
11:55:02 <ski> Saizan : can you remind me how relational parametricity differs from other kinds ?
11:56:02 <John[Lisbeth]> http://lpaste.net/118209
11:56:44 <Saizan> ski: well, it's a specific framework where each type is also interpreted as a relation, and connectives transform those, pretty similar to reynolds original approach
11:57:13 <ski> that may be the variant i've looked most at (not that much)
11:59:29 <srhb> John[Lisbeth]: Did you grab the shell-conduit version from Github?
12:02:03 <John[Lisbeth]> no, I didn't
12:02:34 <quchen> Oh neat, I didn't know Control.Monad.Error was deprecated. I thought Except was just another error handling tool, not a replacement!
12:02:44 <supki> John[Lisbeth]: uh, that looks like you need to update GHC
12:02:44 <quchen> Thanks to whoever made that happen
12:03:01 <srhb> John[Lisbeth]: Ah I see you're on a much older system now
12:03:12 <srhb> John[Lisbeth]: Then you might not have to, although I'm not sure hell will work on it.
12:03:16 <supki> John[Lisbeth]: hell needs shell-conduit, shell-conduit needs unix-2.7 and you only have unix-2.6
12:03:34 <supki> John[Lisbeth]: unix comes bundled with GHC
12:03:46 <John[Lisbeth]> heh
12:03:59 <John[Lisbeth]> so you are saying not even fedora 21 isn fresh enough for this packages?
12:04:45 <srhb> Yes.
12:06:59 <John[Lisbeth]> thats crazy
12:07:06 <John[Lisbeth]> so do all haskellers just use arch then?
12:07:35 <Clint> i use debian
12:08:07 <John[Lisbeth]> I don't understand how one could get any of this to work if you always need beleeding edge software
12:08:09 <srhb> John[Lisbeth]: It's a very bleeding edge package you're trying to install.
12:08:28 <srhb> John[Lisbeth]: As I stated earlier, you can't even install it on the newest GHC without grabbing shell-conduit from github.
12:09:17 <Beardful> alsamixer
12:09:50 <srhb> And no one uses hell anyway. It's not like it's a package that matters to people. :)
12:10:14 <srhb> (Or they would pester the maintainer and/or patch it to make it more compatible)
12:11:10 <ij> :t error -- <-- Beardful
12:11:10 <lambdabot> [Char] -> a
12:12:26 <kaiyin> What do you think of stackage?
12:15:25 <hiptobecubic> It's lovely.
12:15:51 <ReinH> John[Lisbeth]: the GHC and cabal packages from official distro package managers are generally 6+ months out of date, like most of their packages.
12:17:12 <ReinH> Distro package managers have a relatively long package release cycle. This isn't always a bad thing, but it often means you'll be using an obsolete version of a compiler or PL package manager.
12:26:43 <endiruna> hi is there some tutorial to use graphs in haskel
12:26:50 <endiruna> *haskell
12:29:06 <hiptobecubic> endiruna, graphs?
12:29:38 <hiptobecubic> visual graphs as in plotting? Or graphs as in graph theory
12:31:35 * hackagebot vty 5.2.7 - A simple terminal UI library  http://hackage.haskell.org/package/vty-5.2.7 (CoreyOConnor)
12:32:00 <glguy> John[Lisbeth]: If you're going to use the packages provided by Fedora you should mostly stick to using the packaged libraries from Fedora. If you're going to want to build newer stuff than Fedora you should forget about using the packages provided by fedora altogether for the most part
12:33:15 <rom1504> endiruna: there's http://hackage.haskell.org/package/containers-0.2.0.1/docs/Data-Graph.html#t:Graph
12:34:48 <markson> Hello, I'm running OpenBSD [hostname] 5.6 GENERIC.MP#299 i386. ghci error: http://lpaste.net/5366006683627683840
12:35:59 <rom1504> probably has something to do with how you installed haskell
12:38:20 <kaiyin> how do you set the folder name of cabal unpack? For example, I want to cabal unpack alex, but I want the folder name to be just alex/ instead of alex-some-version-number/
12:39:01 <srhb> kaiyin: cabal help unpack
12:39:07 <markson> rom1504: Yes, thank you.
12:39:10 <srhb> kaiyin: Will show you information about -d
12:39:21 <kaiyin> srhb, cool, thanks.
12:40:59 <Luke> what's the benefit of using blaze over just the ByteString.Builder module?
12:41:35 * hackagebot graphs 0.6 - A simple monadic graph library  http://hackage.haskell.org/package/graphs-0.6 (EdwardKmett)
12:44:01 <agibiansky> Template-Haskell question: If I have a value of type DecsQ, is there any way to reliably convert it into a String (representing the generated code) in IO? (I am having issues with reify and IO and ghci, which are well documented but do not seem to have a workaround?)
12:50:00 <SrPx> Hello, is there any implementation of a convex hull on Haskell? Any suggestion so I can search for it? Nothing on Hoogle, 3 messy results on GitHub. Also, if I can't find it, any suggestion on what would be a well suited algorithm for Haskell?
12:53:48 <Luke> oh i see blaze is moved into bs.builder
12:55:02 <glguy> Well, it looks like agibiansky left, but the answer was
12:55:03 <glguy> Prelude Language.Haskell.TH> $(stringE . show =<< reify ''String)
12:55:03 <glguy> "TyConI (TySynD GHC.Base.String [] (AppT ListT (ConT GHC.Types.Char)))"
12:55:46 <glguy> You can use that sort of trick to see what's going on
12:55:49 <trunks1ace> my program runs for some data but ghc blows up for other data, It gives no error message and exits *main>, when I type random symbols are shown. Wht is going on?
12:57:51 <pavonia> trunks1ace: What program? What data?
12:58:42 <quchen> Roche just said "[Haskell 2014] is dead". What's up with this? Is there no new standard even on the horizon?
12:59:18 <StoneToad> quchen: well, given that it's not 2014 anymore...
12:59:26 <StoneToad> they should at least rename it to 2015 !
13:00:20 <trunks1ace> pavonia: It is a binary decision diagram program that takes a binary decision diagram and a boolean environment and returns wether the expression is true or false, its quite abstract and a function works when i give it all test variables except one. With this one ghc just blows up and I have no idea why
13:01:07 <dmj`> quchen: plot twist, Roche is dead and Haskell is alive... *eyebrows raise*
13:01:41 <StoneToad> lol dmj`
13:01:50 <StoneToad> that sounds like one of those Niche jokes
13:01:55 <systemfault> Who is Roche?
13:02:24 <systemfault> Is it "Rock" in french?
13:02:44 <StoneToad> Nietzsche*
13:02:57 <pavonia> trunks1ace: It's really difficult to give any advice without seeing some code. Maybe you can use GHCi debugging functions to see what's going on
13:04:16 <quchen> systemfault: Roman Cheplyaka aka Roche is a haskeller who's sometimes on IRC and maintains a number of popular packages.
13:04:23 <quchen> http://hackage.haskell.org/user/RomanCheplyaka
13:04:54 <systemfault> quchen: Thank you
13:04:55 <quchen> He also has an interesting blog. https://ro-che.info/articles/
13:06:18 <trunks1ace> pavonia: checkSat :: BDD -> Env -> Bool checkSat (root,list) environment = traverse (root,list) environment root --this function takes a binary decision tree and an environment and returns wether the expression is  true or false
13:07:02 <pavonia> Well, that's not helpful
13:07:32 <trunks1ace> pavonia: traverse :: BDD -> Env -> Int -> Bool traverse (root,[]) env currnode     | currnode == 1 = True       | otherwise = False traverse (root,list@((id,(i,l,r)):xs)) env currnode      | currnode == 1 = True     | currnode == 0 = False     | lookUp (lookUp' currnode list) env = traverse (root,list) env r
13:08:13 <trunks1ace> pavonia:   | otherwise = traverse (root,list) env l
13:08:23 <pavonia> Paste a complete/compiling program and the data you run it with
13:08:26 <pavonia> @lpaste
13:08:26 <lambdabot> Haskell pastebin: http://lpaste.net/
13:09:49 <trunks1ace>  oh okay, sorry im new >_<
13:10:41 <lpaste> trunks1ace pasted “bdd.hs” at http://lpaste.net/118210
13:11:16 <trunks1ace> pavonia: http://lpaste.net/118210
13:12:21 <trunks1ace> pavonia: parsing : checkSat bdd2 [(1,True),(2,False)] should return True and checkSat bdd7 [(3,True),(2,False),(9,True)] should return False
13:12:34 <SrPx> No geometry library in haskell? :(
13:13:29 <chaosmasttter> hi,
13:14:00 <trunks1ace> pavonia: http://www.doc.ic.ac.uk/~ajf/haskelltests/bdd/spec.pdf explains it in more detail
13:15:29 <chaosmasttter> is http://lpaste.net/118205 a feature of multiparam type classes (it compiles only with kind signatures in the class declaration)?
13:15:33 <ski> Saizan : .. so i suppose i probably believe in it
13:15:53 <pavonia> trunks1ace: And what happens when you run it in GHCi?
13:16:10 <chaosmasttter> Are there restrictions that the typevariables must have the same kind in any instance?
13:16:58 <Cale> chaosmasttter: You can have kind polymorphic classes
13:17:05 <Cale> Like the new Typeable
13:17:20 <chaosmasttter> with ghc 7.8?
13:17:50 <trunks1ace> pavonia: When i run checkSat bdd2 [(1,True),(2,False)] it return True (as expected) but checkSat bdd7 [(3,True),(2,False),(9,True)] returns nothing and exits *main> in the terminal leaving no prompt and gives gibberish when I type.
13:17:52 <Cale> yeah
13:17:57 <Cale> :k Typeable
13:17:57 <lambdabot> k -> Constraint
13:18:15 <Cale> k is a kind variable there
13:18:23 <Cale> :k Monad
13:18:24 <lambdabot> (* -> *) -> Constraint
13:18:33 <Cale> :k Proxy
13:18:34 <lambdabot> k -> *
13:18:39 <trunks1ace> pavonia: Try loading it and parsing: checkSat bdd7 [(3,True),(2,False),(9,True)] , it is pretty hard to explain
13:20:00 <willprice94> I'm writing a compiler with a three address code intermediate representation (IR), how should I write the types for the IR? My AST has lots of types with data constructors which has made working with it quite unpleasant (lots of redundant constructors). Should I have a single datatype for my IR?
13:21:04 <pavonia> trunks1ace: It crashes my GHCi because it goes out of space. There's seems to be an endless loop in your code
13:21:08 <mpickering> can you show us an example willprice94?
13:21:26 <willprice94> mpickering, an example of my AST? or of three address code?
13:21:54 <mpickering> some code which shows the problem
13:22:13 <trunks1ace> pavonia: can you spot the loop? ive gone over the code loads of times, cant seem to find any fault
13:22:16 <chaosmasttter> Cale: could the problem with the code in the paste be a ghc bug?
13:22:47 <Saizan> ski: were you able to follow the proof?
13:23:04 <Cale> @let newtype Flip a b = Flip { flip :: b a }
13:23:07 <Cale> :k Flip
13:23:08 <lambdabot>  Defined.
13:23:08 <lambdabot> Not in scope: type constructor or class ‘Flip’
13:23:10 <Cale> :k Flip
13:23:11 <lambdabot> k -> (k -> *) -> *
13:23:40 <willprice94> mpickering, Interestingly I came across your compilers stuff on github the other day, I've been searching to see how other have done IR in haskell
13:24:04 <pavonia> trunks1ace: Try to evaluate the expression by hand
13:24:27 <Cale> chaosmasttter: The code in your paste works for me
13:24:34 <mpickering> yes I saw, that repo is a direct translation from a practical we had to do in ocaml
13:24:41 <trunks1ace> pavonia: I have, thats what I find weird because it computes by hand but not in ghci
13:24:51 <mpickering> and was written when I was quite inexperienced so it might not be too great :P
13:25:05 <Cale> chaosmasttter: Oh, you want to remove the kind signatures?
13:25:09 <Cale> hmm
13:25:09 <chaosmasttter> yes
13:25:52 <Cale> chaosmasttter: Add the PolyKinds extension
13:26:05 <Cale> chaosmasttter: and it'll infer a better kind for Test
13:26:48 <lpaste> willprice94 pasted “AST” at http://lpaste.net/118212
13:26:55 <Cale> Normally the inferred kind of a typeclass isn't polymorphic, and is based entirely on the usage of the bound type variables in the types of the methods.
13:26:56 <chaosmasttter> Cale: many thanks, it works :)
13:27:04 <willprice94> mpickering, There's my AST type declaration
13:27:36 <mpickering> and the problem is?
13:28:47 <ski> Saizan : haven't been able to look enough at it yes, since i'm involved in conversation
13:28:56 <ski> s/yes/yet/
13:29:44 <lpaste> willprice94 revised “AST”: “AST + TAC + IR” at http://lpaste.net/118212
13:30:31 <willprice94> mpickering, as you can see it's quite indirect, I want to serialise it into three address code. I was thinking of having a monad based on state that keeps track of which label can be assigned next, temp vars etc. So I've started writing the code to translate AST to IR however I'm not sure whether I'm going down a sane route with this "Transalateable" type class, any thoughts?
13:30:59 <trunks1ace> pavonia: what does "goes out of space" mean? perhaps it is the same for me...
13:31:36 <pavonia> trunks1ace: It's allocating more and more memory
13:34:20 <mpickering> looks sane to me, I'm not sure there is a better way. you have to specify what happens for each constructor which is why there's a lot of code
13:34:25 <mpickering> what were you thinking?
13:35:15 <willprice94> mpickering, I'm unsure, it just felt like quite a verbose way of doing it, I was hoping I'd missed some obvious "Oh, do it this way, it'll make your life much easier" method ;)
13:38:32 <ezrios> I am having trouble using hspec discovery inside a cabal project
13:38:42 <ezrios> "Could not find module 'Test.Hspec.Discover'"
13:39:05 <mpickering> are you in a sandbox?
13:39:25 <ezrios> mpickering: yes
13:40:04 <pavonia> trunks1ace: This is what I get expanding it manually: http://lpaste.net/118214
13:40:18 <pavonia> The last line repeats infinitely
13:40:37 <ezrios> directory structure: http://lpaste.net/118216
13:41:30 <mpickering> do you have a test section to the cabal file?
13:44:47 <quchen> Anyone else got trouble installing anything that involves vector because of the "primitive" package? Apparently some .so cannot be found. http://lpaste.net/118217
13:44:58 <quchen> As a consequence, anything that depends on vector also fails to install.
13:48:07 <ezrios> mpickering: http://lpaste.net/118219
13:48:09 <ezrios> I do
13:48:22 <ezrios> I get the "could not find module error" when invoking `cabal repl spec`
13:52:13 <mpickering> ezrios: What happens when you do cabal test?
13:55:03 <lachenmayer> Hi, I'm having a bizarre issue with cabal - I'm trying to install the newest version of a package (0.14.1) inside a sandbox, but when installing it tells me "(global constraint requires ==0.14)". I've tried completely removing ~/.ghc and ~/.cabal and I really can't see where this global constraint could come from. Any ideas?
13:55:24 <trunks1ace> pavonia: Thanks! Ive realised the problem, the function only checks the head of the list but it shouldt do this, time to fix it, thankyou again, much appreciated!
13:55:39 <mpickering> can you run the install with the flag -v3 lachenmayer and post the log
13:58:26 <pavonia> trunks1ace: Btw, what system are you on? The behaviour you described sounds really weird
13:58:39 <lachenmayer> mpickering: ah thanks, that's a useful flag! Turns out those constraints are defined in the stackage cabal.config file. Renaming it seems to do the trick. Cheers!
13:59:58 <trunks1ace> pavonia: well I tried it on a mac and thats the behaviour I got but then I tried it on a windows PC and got the same behaviour but no gibberish, It seems weird that ghci wouldn't give me some error message informing me it was a space issue
14:04:23 <Haskellfant> How can I get from (Maybe a, Maybe b, Maybe c) to Maybe (a,b,c) ofc I can just manually write it out but I feel like there should be something like sequence for that, maybe some lens magic?
14:04:52 <Haskellfant> ofc Maybe could be any applicative here
14:04:58 <edwardk> the lens magic works if a = b = c, but not in general
14:05:13 <edwardk> :t sequenceOf each :: (Maybe a, Maybe a, Maybe a) -> Maybe (a,a,a)
14:05:14 <lambdabot> (Maybe a, Maybe a, Maybe a) -> Maybe (a, a, a)
14:05:20 <edwardk> :t each id :: (Maybe a, Maybe a, Maybe a) -> Maybe (a,a,a)
14:05:21 <lambdabot> (Maybe a, Maybe a, Maybe a) -> Maybe (a, a, a)
14:05:33 <edwardk> when the types differ that doesn't help though
14:05:58 <Haskellfant> edwardk: ah the types are equal here so that helps, thx!
14:06:21 <shachaf> :t liftA3 (,,) -- halfway there
14:06:22 <lambdabot> Applicative f => f a -> f b -> f c -> f (a, b, c)
14:06:37 <Haskellfant> :t uncurry (liftA3 (,,))
14:06:37 <lambdabot> Applicative f => (f a, f b) -> f c -> f (a, b, c)
14:09:25 <knz> hai
14:10:47 <knz> I have a quite simple function that generates a sequence, defined as follows: let f n m = if n == 0 then [m] else (f (n-1) (m/2)) ++ (f (n-1) (m*2)) ; how can I generalize this so it does not necessarily return a list?  (e.g. able to reuse it to print all values to stdout, without storing them in memory)
14:11:22 <knz> I tried applicative
14:11:22 <knz> let f n m = if n == 0 then pure m else (f ...) <*> (f ...)
14:11:32 <knz> but that doesnt' make sense
14:12:07 <knz> is monad the smallest class I can use?
14:12:49 <quchen> I don't understand the desired behaviour. What would you like it to do instead of generating a list? The definition of your "f" does one thing, and that's generate a list. How to "remove the list" is not obvious.
14:13:44 <knz> quchen: I'd like it to behave like a generator. The original code in python uses "yield". What happens with the values should be decided by the caller -- I don't want necessarily to have the values assembled into cons cells.
14:14:42 <quchen> What's the original code in Python?
14:14:49 <EvilTerran> knz, thanks to laziness, each element won't be generated until it's needed anyway (some elements may never be generated at all, if the caller never uses them)
14:15:10 <quchen> In Haskell land, the most basic version of a "python generator" is something you can write with unfoldr.
14:15:14 <knz> def f(n,m): if n == 0: yield m; else: yield from f(n-1,m/2); yield from f(n-1,m*2)
14:15:18 <EvilTerran> and if you compile with optimisation, the whole list structure may be optimised away entirely
14:15:45 <pavonia> knz: You could pass it a function that combines two values into something, and make that something the result value of your function
14:15:58 <knz> the other version I got working was with monadplus, that is f n m = if n == 0 then return m else (f (n-1) (m/2)) `mplus` (f (n-1) (m*2))
14:16:05 <knz> that works well
14:16:36 <knz> but I wonder if there isn't a smaller class than monadplus that achieves the same
14:16:39 * hackagebot ConcurrentUtils 0.3.0.0 - Concurrent utilities  http://hackage.haskell.org/package/ConcurrentUtils-0.3.0.0 (JamesCandy)
14:16:40 <EvilTerran> seems to me a list really is the idiomatic way of expressing that in haskell
14:16:41 * hackagebot graphs 0.6.0.1 - A simple monadic graph library  http://hackage.haskell.org/package/graphs-0.6.0.1 (EdwardKmett)
14:18:18 <quchen> Having a single yield is like a Haskell list. Having two (n) of them sounds more like a binary (n-ary) tree.
14:18:47 <knz> quchen: note the "yield from" -- in python this chains (flattens) the generators
14:19:01 <knz> hence the ++ in the list-based haskell code
14:19:05 <quchen> I'm not familiar with that keyword
14:19:56 <EvilTerran> quchen, in a generator, "yield from anotherGenerator()" is like "for x in anotherGenerator(): yield x"
14:20:38 <kaiyin> Here is the haskell implementation of Eratosthenes sieve from the road to logic book: http://lpaste.net/118220
14:20:54 <kaiyin> I am a little confused why this can work.
14:21:11 <quchen> EvilTerran: Oh, so it's like "go to this generator instead"
14:21:33 <jle`> knz: Alternative
14:21:54 <kaiyin> For example, mark 9.. 1 2 does not mark 9 as a number to be sieved at all, as far as I can see.
14:22:01 <jle`> but the list is probably the idiomatic way already
14:22:20 <EvilTerran> quchen, sort of - more like "splice the output of this generator into my output"
14:22:41 <ezrios> mpickering: src/Test/Spec.hs:6:8:
14:22:43 <ezrios>     Could not find module `Test.Hspec.Discover'
14:22:53 <ezrios> 5053 chesskell:master!? % cat src/Test/Spec.hs                                                                                                                       10-Jan-2015 17:19:28 ezrios pts/9
14:22:55 <ezrios> {-# OPTIONS_GHC -F -pgmF hspec-discover #-}
14:23:32 <knz> let's try alternative
14:23:47 <ezrios> that's all after `cabal test`
14:25:06 <Black-Heaven> alpounet: https://github.com/blackheaven/smoothmail
14:25:07 <mpickering> ezrios: I don't know sorry
14:25:08 <knz> yes
14:25:10 <knz> that works \o.
14:25:12 <Black-Heaven> ouch, sorry
14:25:18 <knz> jle`: thx
14:25:36 <quchen> Alternative and MonadPlus are pretty similar.
14:26:19 <quchen> MonadPlus = Alternative + Monad
14:26:39 * hackagebot Unique 0.3 - It provides the functionality like unix "uniq" utility  http://hackage.haskell.org/package/Unique-0.3 (kapral)
14:26:46 <Zemyla> Isn't Alternative = Monoid + Applicative?
14:26:47 <quchen> Plus two laws that everyone abides by, and one other law that nobody cares about
14:27:26 <quchen> Zemyla: Alternative feels similar to Monoid+Applicative. MonadPlus literally is Alternative+Monad.
14:27:35 <quchen> (As of 7.10, at least.)
14:27:35 <Zemyla> :t map head . group
14:27:36 <lambdabot> Eq b => [b] -> [b]
14:28:00 <Zemyla> > (map head . group) "Mississippi"
14:28:01 <lambdabot>  "Misisipi"
14:28:20 <Zemyla> So why do we need a Unique package?
14:29:05 <quchen> Why do we need packages at all?
14:29:22 <quchen> It's so we can use other code without having to rewrite it every time again
14:29:38 <ezrios> ugh
14:29:43 <ezrios> why is haskell debugging so complicated
14:30:09 <ezrios> all I want is a backtrace, or even just the ability to run trace statements ._.
14:30:10 <quchen> Because only hard bugs manage to escape the typechecker
14:30:24 <marcusbuffett> Hey guys, I have a problem with deriving, can anyone help? Code is here: http://lpaste.net/118222
14:30:37 <ezrios> maybe I should have used a dependently typed language
14:31:32 <ezrios> marcusbuffett: what is a Display
14:31:40 <ezrios> @hoogle Display
14:31:41 <lambdabot> Graphics.UI.GLUT.Initialization DisplayAcc :: DisplayCapability
14:31:42 <lambdabot> Graphics.UI.GLUT.Initialization DisplayAccA :: DisplayCapability
14:31:42 <lambdabot> Graphics.UI.GLUT.Initialization DisplayAlpha :: DisplayCapability
14:32:21 <dmj`> ezrios: Debug.Trace?
14:32:31 <dmj`> :t traceShow
14:32:32 <lambdabot> Not in scope: ‘traceShow’
14:32:53 <_um> Does Anyone recommend an approach to the twitter api? Am I safe just sticking with Web.Twitter.Conduit?
14:33:02 <ezrios> dmj`: I've used Debug.Trace, but I can't get it to work in the context of a sandboxed cabal project
14:33:05 <ezrios> only through runhaskell or ghci
14:33:16 <_um> dmj`: where you helping me yesterday with JSON and http stuff?
14:33:26 <_um> I forgot to take good note of the nick...
14:33:53 <marcusbuffett> ezrios: It's something I made, so that I could show stuff in a more readable way, here's one of the implementations for example : http://lpaste.net/118223
14:34:52 <_um> s/where/were
14:39:06 <kaiyin> how do you do cumulative sum/product ?
14:40:20 <kaiyin> for example, given [1, 2, 3, 4], I want [1, 3, 6, 10]
14:42:20 <quchen> > scanl (+) 0 [1,2,3,4] -- kaiyin
14:42:22 <lambdabot>  [0,1,3,6,10]
14:42:42 <kaiyin> quchen, thanks.
14:43:18 <ski> Saizan : line `36'-`37' ?
14:43:50 <ski> Saizan : also `72' and `78'
14:44:44 <Saizan> ski: ignore anything above 38, mispaste
14:45:23 <Saizan> ski: and yeah, that part got duplicated, sorry
14:45:58 <ezrios> marcusbuffett: so display :: (Display a) => a -> String ?
14:46:13 <ezrios> why not instance Display String where display = id
14:47:19 <ezrios> or why not just use Show
14:47:36 <ezrios> display = show really
14:51:05 <ski> ezrios,marcusbuffett : i would not suggest `Show' here
14:52:15 <ski> because this is a custom-format display thing, rather than, as used for debugging purposes, outputting a string representation of a haskell expression which (in the appropriate environment) will evaluate to an equal value
14:53:04 <ski> marcusbuffett : the simplest is to make a `newtype' (or `data', if you insist) wrapper around `String', that has a `Display' instance that behaves however you want it to
14:54:05 <dmj`> _um: yes
14:55:15 <_um> dmj`: Well thanks! I got it all worked out (functionally, if not elegantly). Your tips were maybe even more helpful emotionally than practically, but it was a big help nonetheless.
14:56:16 <ski> marcusbuffett : depending, you might later want to add some context arguments to a method in `Display'. like perhaps maximum line length, current indentation level (for tables and such), &c.
14:57:33 <_um> General question: If I just need to get some random elements from a list of data, should I use Data.Random.Extras or is that overkill and I should rather roll my own little choice function just using Random?
14:57:57 <StoneToad> _um: in what way is it overkill?
14:58:24 <Zemyla> _um: I would actually have Display be a Seq Char rather than a String, for easier appending.
14:59:02 <kaiyin> > accOp f (y:ys) x = (f y x) : y : ys
14:59:03 <lambdabot>  <hint>:1:18: parse error on input ‘=’
15:00:07 <kaiyin> Could anyone tell me what went wrong with this? http://lpaste.net/118225
15:00:25 <quchen> knz: I don't have Python to test what your generator is doing, but here is something that looks somewhat similar in Haskell. http://lpaste.net/118224
15:00:28 <kaiyin> I was trying to make a generic accumulative operator
15:01:38 <_um> StoneToad: Well, I don't know. I guess your rhetorical question answers mine. I guess I was just thinking that since using Data.Random.Extras looks like it requires importing three separate packages, which aren't included in the Platform, that maybe just importing randomRIO from Random (which is included, I think?) would be amore modest solution.
15:01:53 <_um> Zemyla: wrong addressee I think.
15:02:17 <_um> StoneToad: also "rhetorical question" isn't the right phrase there. Sorry.
15:06:29 <ski> marcusbuffett : also see what Zemyla said
15:06:50 <StoneToad> _um: remember, there's no such thing as overkill, only open fire and time to reload
15:07:03 <fread2282> is there a monad like ST but with a notion of blocking on a STRef? I'm not exactly sure what I want, but I think something like     block :: (a -> ST s a) -> STRef s a -> ST s a
15:07:38 <dmj`> _um: haskell is at times therapeutic, yes
15:07:48 <StoneToad> fread2282: so you want it to block until the STRef has a value?
15:08:03 <StoneToad> what was that package called...
15:08:09 <ski> kaiyin : maybe you also want to handle the empty case ..
15:09:16 <ski> fread2282 : something like an `MVar' for `ST' ?
15:09:21 <_um> dmj`: I do find it that way :)
15:10:28 <fread2282> StoneToad: yes, but I want to have the 'callback' modify a data structure that I'm modifing in the same thread /at the same time/
15:10:30 <ski> fread2282 : concurrency (including `unsafeInterleaveST') doesn't mix well with `ST' in general, because it introduce indeterminacy -- perhaps it could be ok in restricted subsets, though (like maybe `IVar's, dataflow variables, &c.)
15:10:50 <fread2282> ski: I don't want concurrency
15:11:10 <StoneToad> 'at the same time' isn't concurrency?
15:11:12 <ski> fread2282 : how can you block without several threads of control focus, at least cooperatively ?
15:12:25 <fread2282> StoneToad: I want to modify a  different part of the data structure (in ST) to get a value for the STRef and then have the callback run once I put one in
15:12:41 <quchen> There's TMVar, which is the STM version of an MVar.
15:12:43 <quchen> http://hackage.haskell.org/package/stm-2.4.4/docs/Control-Concurrent-STM-TMVar.html
15:12:50 <fread2282> ski: it doesn't block, but rather takes a callback
15:12:59 <StoneToad> why arn't you just compossing the 'callback' with the function taht writes to the STRef to start with?
15:13:24 <ski> fread2282 : perhaps all you want then is `unsafeInterleaveST' (which i'd classify under "concurrency", even though it's triggered in GHC by forcing thunks, not by separate threads in the sense of `fork') then -- however, beware, it's actually unsafe (in the sense that you can break purity)
15:15:13 <ski> fread2282 : another possibly related thing is `newCyclicSTRef :: (STRef s a -> a) -> ST s (STRef s a)', that initializes the new cell with a value `a', which is computed by passing the new reference to the argument function
15:15:16 <fread2282> StoneToad: the STRef might be written to later
15:15:48 <ski> fread2282 : any of those sounds close to what you want ?
15:15:58 <fread2282> (both in a temporal and in a control flow sense)
15:16:20 * ski reads "I want to modify a  different part ..."
15:16:42 <fread2282> ski: I might be able to build something with newCyclicSTRef, but...I don't think so
15:17:12 <ski> (`newCyclicSTRef' can easily be built using `mfix')
15:17:27 <StoneToad> so you ahve an STRef you want to be able to write to, and have some opaque operation happen to the value you write into it, that modifies more then one place in the ST monad's state
15:17:53 <jessicah> how can I debug an issue with "Bad interface file" when trying to build/install a package with cabal?
15:18:46 <StoneToad> something like having a table with totals in it for all the STRefs in your system that you want to update when the STRef gets written to
15:19:14 <StoneToad> jsut wraping the accesses of the stref with a function should let you do that
15:20:16 <jessicah> using --verbose=3 doesn't appear to offer any more hints as to what might be wrong...
15:20:22 <ski> fread2282 : do you want to built a network of `STRef's , where writing to one of then will trigger recomputation or update of some kind in other ones that depend on it (have installed their callbacks on it) ?
15:20:45 <mpickering> jessicah: Are you in a sandbox?
15:21:07 <jessicah> mpickering: no
15:21:11 <fread2282> ski: yep, but an AST
15:21:41 * hackagebot spacefill 0.1 - Generators for space-filling curves.  http://hackage.haskell.org/package/spacefill-0.1 (knz)
15:21:49 <knz> http://hackage.haskell.org/package/spacefill-0.1/docs/src/Data-SpaceFillingCurves.html <- there we go
15:22:10 <fread2282> so I want a monad that lifts a normal AST to a thing that can have parts of it computed once other parts get computed, in the mose general sense
15:22:42 <mpickering> jessicah: maybe try in a sandbox?
15:22:57 <mpickering> then paste the log here if there's still a problem
15:23:09 <ski> fread2282 : "but an AST" ?
15:23:23 <jessicah> mpickering: hmm, okay, I'll see if I can figure out how to do that :)
15:23:46 <ski> fread2282 : perhaps something like `data STRefWithCallback s a = STRWC { theRef :: STRef s a,onWrite :: a -> STRef s a }'
15:23:51 <fread2282> ski: I want to build an AST by depending on other parts of it that will get built in the future. I can do this with fix, but that's *way* to inefficient
15:23:59 <mpickering> what are you trying to buid?
15:24:48 <jessicah> pandoc
15:24:49 <ski> fread2282 : also, it might be interesting to check out adaptive/incremental computation
15:24:52 <ski> @where adaptive
15:24:52 <lambdabot> "Adaptive Functional Programming" by Umut Acar,Blelloch,Harper in 2002 (POPL) at <http://www.umut-acar.org/publications/popl2002.pdf> and in 2006 (TOPLAS) at <http://www.umut-acar.org/publications/toplas2006.pdf>
15:24:55 <ski> @where incremental
15:24:55 <lambdabot> "Monads for Incremental Computing" (Functional Pearl) by Magnus Carlsson in 2002 (ICFP) at <http://www.carlssonia.org/ogi/papers/icfp-2002.pdf>,<http://www.carlssonia.org/ogi/Adaptive/>,in Hackage at <http://hackage.haskell.org/package/Adaptive>
15:25:36 <jessicah> mm, sandbox isn't working; I get an error saying cannot satisfy -package-id Cabal-1.22.0.0-....
15:25:59 <mpickering> can you paste the result of cabal install pandoc -v3
15:25:59 <ski> fread2282 : i'm not sure if it matches your desire exactly, but it sounds like it might be close, at least
15:28:32 <jessicah`> https://gist.github.com/anonymous/5be75896ec8fb9cdfa92
15:30:50 <jessicah> mm, I think I need to edit the package-db in the sandbox config
15:31:04 <kakos> I have a `State s a` and I want to run it in a `State s IO a`. How do I do that?
15:31:38 <jessicah> hmm
15:31:55 <mpickering> why so?
15:32:04 <pavonia> kakos: Do you mean StateT s IO a?
15:32:15 <kakos> pavonia: Ys!
15:32:18 <kakos> pavonia: Yes!
15:32:21 <kakos> Typos are haunting me
15:32:24 <quchen> kakos: mmorph has something for that. "hoist generalize" I believe.
15:32:28 <jessicah> er, my package.conf.d isn't located in `ghc --print-libdir`
15:32:59 <jessicah> it's in another location; I'm guessing cabal sandbox init didn't copy the right package stuff
15:33:25 <mpickering> maybe "cabal sandbox hc-pkg recache"
15:33:33 <mpickering> oh ok
15:34:06 <pavonia> kakos: There's also mapStateT
15:34:43 <pavonia> :t mapStateT
15:34:44 <ski> @type state . runState :: MonadState s m => State s a -> StateT s m a
15:34:44 <lambdabot> (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
15:34:44 <lambdabot> MonadState s m => State s a -> StateT s m a
15:35:08 <jle`> omg
15:35:17 <jle`> thí whole time?
15:35:22 <jessicah`> mpickering: in the output I have using binary package database: /packages/ghc_x86-7.8.3-10/.self/lib/x86/ghc-7.8.3/package.conf.d/package.cache
15:35:22 <jle`> *this
15:35:36 <jessicah`> this should be /boot/system/settings/ghc/package.conf.d instead
15:35:44 <jle`> :t writer . runWriter
15:35:44 <kakos> pavonia: Oi. I must have looked at that a dozen times and for some reason it didn't catch my eye. Thanks.
15:35:45 <lambdabot> MonadWriter w m => Writer w a -> m a
15:35:56 <jle`> :t reader . runReader
15:35:57 <lambdabot> MonadReader r m => Reader r a -> m a
15:36:01 <jle`> :O
15:36:07 <jle`> my mind is blown
15:36:12 <jessicah`> mpickering: can the package-db setting in the config have more than one value?
15:36:17 <jessicah`> that would probably be sufficient
15:36:42 * hackagebot olwrapper 0.3.7 - An OpenLayers JavaScript Wrapper and Webframework with snaplet-fay  http://hackage.haskell.org/package/olwrapper-0.3.7 (thomas84)
15:36:58 <ski> @type cont . runCont  -- :)
15:36:59 <lambdabot> Cont r a -> Cont r a
15:37:23 <jle`> huh the exception
15:37:40 <mpickering> jessicah`: I don't know sorry, someone else might be able to help you out
15:38:20 <ski> @type cont  -- because
15:38:22 <lambdabot> ((a -> r) -> r) -> Cont r a
15:42:03 <danilo2> Hello! :) Is there any way to generate something and reify it in the same template haskell function, or i need to run separate functions for this behaviour? :)
15:44:00 <quchen> jle`: mmorph generalizes this behaviour as "hoist generalize"
15:44:59 <jessicah> guess I have some more work to do to get things like sandboxes working :(
15:45:40 <jessicah`> mpickering: this is the exact error I get when it's trying to compile pandoc:
15:45:43 <jessicah`>  Bad interface file: /boot/system/non-packaged/lib/Data/Attoparsec/ByteString/Char8.dyn_hi
15:45:44 <jessicah`>      Something is amiss; requested module  haddock-library-1.1.1:Data.Attoparsec.ByteString.Char8 differs from name found in the interface file attoparsec-0.12.1.2:Data.Attoparsec.ByteString.Char8
15:46:42 * hackagebot olwrapper 0.3.7.1 - An OpenLayers JavaScript Wrapper and Webframework with snaplet-fay  http://hackage.haskell.org/package/olwrapper-0.3.7.1 (thomas84)
15:46:59 <mpickering> usually I remove the dist/ folder when something like that happens but I always build in sandboxes.. you might want to try the classic rm -r ~/.ghc rm -r ~/.cabal
15:54:17 <SrPx> What is the right way to multiply a V3 from linear by a scalar? I'm using `fmap (* x) vec`, is there a better way?
15:56:43 * hackagebot olwrapper 0.3.7.2 - An OpenLayers JavaScript Wrapper and Webframework with snaplet-fay  http://hackage.haskell.org/package/olwrapper-0.3.7.2 (thomas84)
15:56:45 * hackagebot olwrapper 0.3.7.3 - An OpenLayers JavaScript Wrapper and Webframework with snaplet-fay  http://hackage.haskell.org/package/olwrapper-0.3.7.3 (thomas84)
15:59:54 <fread2282> jonsterling: what ideas do you have about providing equational theories for external code?
16:05:59 <erikd> Wat? Why does System.Posix.IO.ByteString.fdRead return String? https://hackage.haskell.org/package/unix-2.7.1.0/docs/System-Posix-IO-ByteString.html#v:fdRead
16:06:05 <davidthomas> anyone have an idea why my line numbers would be off in my error messages?
16:06:37 <davidthomas> (that is, error messages I am receiving from GHC, not error messages I am emitting)
16:06:38 <erikd> davidthomas: off by how much? are you using CPP?
16:06:43 * hackagebot olwrapper 0.3.7.4 - An OpenLayers JavaScript Wrapper and Webframework with snaplet-fay  http://hackage.haskell.org/package/olwrapper-0.3.7.4 (thomas84)
16:07:23 <davidthomas> erikd: 19 lines, apparently
16:07:42 <davidthomas> I don't think there are any CPP directives in the file, it might be enabled...
16:08:00 <davidthomas> yeah nothing matches ^#
16:08:17 <erikd> davidthomas: the # doesn't have to start a line to be valid
16:08:32 <davidthomas> true...
16:08:45 <archi> ey dudes
16:08:56 <archi> how i should set leksah
16:09:00 <archi> in a right way  ?
16:09:48 <davidthomas> erikd: it does have to only be whitespace before it, right?
16:10:26 <erikd> yes, i think so
16:10:59 <erikd> davidthomas: paste it on lpaste.org maybe?
16:11:44 * hackagebot olwrapper 0.3.7.5 - An OpenLayers JavaScript Wrapper and Webframework with snaplet-fay  http://hackage.haskell.org/package/olwrapper-0.3.7.5 (thomas84)
16:12:41 <davidthomas> well, it's definitely CPP
16:14:17 <davidthomas> disabling it got rid of the error
16:14:18 <davidthomas> oh!
16:14:20 <davidthomas> comment
16:14:42 <davidthomas> that's the issue
16:16:44 * hackagebot olwrapper 0.3.7.6 - An OpenLayers JavaScript Wrapper and Webframework with snaplet-fay  http://hackage.haskell.org/package/olwrapper-0.3.7.6 (thomas84)
16:17:19 <davidthomas> that file has a block JS comment in a quasiquote
16:19:58 <archi> What i need to do to install leksah in a manual way whit out using cabal trying to avoid some type of cabal-hell ?
16:20:50 <quchen> Lots of unnecessary patience is what you need. I suggest using a cabal sandbox instead.
16:21:13 <archi> ok
16:21:17 <archi> i will try that
16:21:35 <archi> D:
16:21:44 * hackagebot olwrapper 0.3.7.7 - An OpenLayers JavaScript Wrapper and Webframework with snaplet-fay  http://hackage.haskell.org/package/olwrapper-0.3.7.7 (thomas84)
16:23:55 <davidthomas> erikd: thanks :)
16:24:03 <_um_> I have a quite naive question: If I'm *only* trying to get random values out of a list, and need no other random features, what would motivate me to use one of the more substantial random packages as opposed to a simple hack into the OS environment like this: https://gist.github.com/aBathologist/aca7404caf48b9e6449e ?
16:26:23 <dmj`> _um_: the random package is pretty standard (System.Random)
16:26:40 <quchen> Hacks should be avoided whenever possible.
16:26:45 <benzrf> _um_: the same thing as in any other language
16:26:46 <quchen> That's my motivation, usually.
16:26:57 <benzrf> _um_: in python would you shell out instead if importing random
16:28:36 <dmj`> don't shell out for anyone or anything, ever
16:29:21 <_um_> benzrf: that might show the depths of my ignorance there. and, tbh, if getting random values where as much of a pain in python, I'd probably ask the same question in that context.
16:29:31 <Cale> _um_: Well, it should probably motivate you that randomRIO (0,high) would be easier than all that shenanigans :)
16:29:59 <_um_> Cale: that's a very good reason indeed.
16:30:13 <_um_> It sounds like it's just held to be a bad idea on principle, and that's good to know.
16:30:23 <dmj`> :t randomRIO ('a', 'z')
16:30:24 <lambdabot> IO Char
16:30:30 <dmj`> > randomRIO ('a', 'z')
16:30:32 <lambdabot>  <IO Char>
16:30:48 <_um_> > randomRIO (1,10)
16:30:49 <lambdabot>  <IO Integer>
16:30:51 <fread2282> _um_: that would also be really slow compared to System.Random
16:31:33 <_um_> fread2282, Cale: so it sounds like maybe using System.Random to create a custom "choice" function might be a good middle ground? For simplicity and speed?
16:31:44 * hackagebot olwrapper 0.3.7.8 - An OpenLayers JavaScript Wrapper and Webframework with snaplet-fay  http://hackage.haskell.org/package/olwrapper-0.3.7.8 (thomas84)
16:31:52 <Cale> _um_: yeah
16:32:11 <_um_> (fwiw, I wrote that hack because I was playing around in an environment that didn't have System.Random and I wasn't able to download it).
16:32:39 <_um_> Word. Thanks to all you helpful, patient people. :)
16:32:42 <Cale> I kind of feel like Gen from QuickCheck ought to be separated into its own library
16:33:04 <benzrf> :k Gen
16:33:04 <lambdabot> * -> *
16:33:06 <Cale> But in any case you can use QuickCheck to generate lots of random things easily.
16:33:10 <benzrf> @let data Urobuchi
16:33:13 <lambdabot>  Defined.
16:33:14 <benzrf> :k Gen Urobuchi
16:33:15 <lambdabot> *
16:33:22 <_um_> Cale: I'm looking forward to digging into QuickCheck.
16:33:36 <_um_> I hope set an afternoon or two aside for it before long.
16:34:26 <matematikaadit> :t randomR
16:34:27 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> (a, g)
16:35:19 <Cale> _um_: You can import Test.QuickCheck, and use  generate (elements [1,2,3,4]) :: IO Integer  for example
16:35:56 <Cale> http://hackage.haskell.org/package/QuickCheck-2.7.6/docs/Test-QuickCheck.html
16:36:13 <Cale> actually, scroll down to here :)  http://hackage.haskell.org/package/QuickCheck-2.7.6/docs/Test-QuickCheck.html#g:5
16:36:55 <Cale> So, one of these Gen a values encodes a way of producing random values of type a (with some probability distribution)
16:37:54 <Cale> There's a class Arbitrary a where arbitrary :: Gen a  for providing a canonical generator for various types
16:38:38 <Cale> and then  generate :: Gen a -> IO a  will provide an IO action which will run a given generator
16:39:45 <_um_> Cale: cool! Thanks!
16:39:53 <_um_> That's a quite tidy solution.
16:41:44 <_um_> (With the exception of the messiness of importing a testing library for the sole purpose of using it's randomization functions :)
16:41:45 * hackagebot olwrapper 0.3.7.9 - An OpenLayers JavaScript Wrapper and Webframework with snaplet-fay  http://hackage.haskell.org/package/olwrapper-0.3.7.9 (thomas84)
16:43:31 <e11> hello everybody, happy saturday!
16:43:37 <e11> @hoogle !!
16:43:38 <lambdabot> Prelude (!!) :: [a] -> Int -> a
16:43:38 <lambdabot> Data.List (!!) :: [a] -> Int -> a
16:43:38 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
16:46:45 * hackagebot olwrapper 0.3.7.10 - An OpenLayers JavaScript Wrapper and Webframework with snaplet-fay  http://hackage.haskell.org/package/olwrapper-0.3.7.10 (thomas84)
16:48:11 <schell> is there any reason why a computation in a thread created with forkIO in main would run waaaay slower than that same computation in main?
16:48:33 <_um_> Cale: turns out generate :: Gen a -> IO a is no longer in the QuickCheck package that's shipping with recent builds of the Platform? : http://stackoverflow.com/questions/4370465/function-variable-not-in-scope-haskell
16:49:58 <_um_> But I can accomplish what I need with `take n (sample' x)`, where x is some Gen a
16:51:20 <schell> it seems that running my IO function in forkIO from main takes around 2 minutes, while running it in main takes ~2 seconds
16:51:42 <Hijiri> whenever I run with multiple jobs and I get to the lens dependency of some project, my used memory inflates
16:51:56 <Cale> _um_: The docs that I linked are to the latest version of QuickCheck on hackage
16:52:12 <Cale> _um_: I have no idea which version of QuickCheck comes with Platform
16:56:30 <_um_> Cale: Huh... I thought I updated all my packages recently, but I seem to be a point behind on quickcheck... goes to show I don't know how to work Cabal.
16:58:29 <solirc> ezrios: May it be that the versions of hspec-discover and hspec do not match
16:59:22 <Cale> _um_: If you have 2.7.5, just import Test.QuickCheck.Gen
16:59:31 <Cale> and that'll have generate
17:00:20 <_um_> Cale: thanks! I just ran cabal install QuickCheck, to get 2.7.6,  and things seem to be working now.
17:00:31 <Cale> cool
17:01:20 <solirc> ezrios: If you still have this problem, ping me in #hspec and I can help you debug it
17:04:12 <danilo2> Hello! I've got very simple question, yet I think I never needed such functionality before. I've got a function (a,b) -> Maybe c  and list [(a,b)] I want to construct [c] by applying the function to the list and collecting only Just values. I know we can do this simply by fmap and filter isJust, but is there any "nicer" / "cleaner" / more efficient way?
17:04:13 <Hijiri> wow
17:04:15 <Hijiri> I just realized
17:04:24 <Hijiri> I could make symlinks to cabal sandboxes to use xmonad
17:04:32 <Hijiri> and not pollute my packages
17:04:37 <Hijiri> same with yi
17:04:45 <mpickering> danilo2: There's a mapMaybe function in Data.maybe
17:04:57 <danilo2> mpickering: great! Thank you very much1
17:05:17 <mpickering> @hoogle (a -> Maybe b) -> [a] -> [b]
17:05:18 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
17:05:18 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
17:05:18 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
17:06:32 <darkroom> in your opinion is fmap (function) (monad) or (monad) >>= return function more clear?
17:06:59 <HeladoDeBrownie> darkroom, i would generally not even consider doing the latter
17:07:17 <HeladoDeBrownie> (yes, clarity is part of the reason)
17:07:24 <darkroom> i think fmap is much clearer but I was just curious what other people thought
17:07:42 <darkroom> also do you use fmap or map when mapping over a list?
17:07:46 <darkroom> i stick to fmap
17:07:51 <shachaf> The latter is a type error if nothing else.
17:08:06 <darkroom> oh sorry
17:08:06 * HeladoDeBrownie assumed fmap f x versus x >>= return . f was meant
17:08:13 <darkroom> monad >>= return . function
17:08:35 <shachaf> Note that a value of type m a isn't a monad.
17:09:18 <darkroom> shachaf: in what context do you bring that up?
17:10:02 <shachaf> "monad >>= return . function"
17:13:18 <calvinx> What’s the difference between `forM_` in Data.Foldable versus `forM_` in Control.Monad? https://www.haskell.org/hoogle/?hoogle=forM_
17:13:58 <shachaf> The type.
17:14:05 <srhb> calvinx: One works over every Foldable, the other only on Lists
17:14:27 <calvinx> I see.
17:15:37 <lpaste> e11 pasted “parse error line 31?” at http://lpaste.net/118228
17:16:08 <geekosaur> indentation
17:16:28 <geekosaur> because line 30 has do lift ..., line 31 has to be indented as far as lift on line 30 to be part of the do
17:16:46 * hackagebot hledger-web 0.24.1 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.24.1 (SimonMichael)
17:17:13 <e11> you rock geekosaur. thank you
17:20:02 <e11> hey guys, I want a while loop construct, why cant I use this one: http://hackage.haskell.org/package/loop-while ? I seem to not be able to cabal install it
17:20:42 <srhb> e11: Use monad loops instead. That one is ancient
17:20:48 <srhb> e11: Or just roll your own, it's super easy.
17:21:46 * hackagebot UISF 0.3.0.0 - Library for Arrowized Graphical User Interfaces.  http://hackage.haskell.org/package/UISF-0.3.0.0 (dwincort)
17:21:59 <benzrf> :t until
17:22:00 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
17:22:03 <benzrf> hm
17:22:05 <benzrf> :t while
17:22:06 <lambdabot> Not in scope: ‘while’
17:22:08 <benzrf> ?
17:22:30 <srhb> whileM, untilM, usually.
17:23:00 <e11> whileM, ok
17:23:39 <e11> so, just for curiosity sake, I might see packages on hoogle that are way out of date? how do you tell if something is ancient?
17:23:50 <srhb> e11: Visit their hackage page.
17:25:20 <geekosaur> it would be nice if hackage could note, say, the ghc versions corresponding to various base dependencies
17:25:38 <srhb> Yes, I've missed that a few times.
17:26:00 <geekosaur> that said, it is possible to deprecate packages and indicate their replacements, but that requires the package uploader to do so and who knows...
17:26:03 <srhb> Thankfully, there's so much breakage between GHC versions that you can often assume things don't work if they're more than a year old. :-)
17:26:10 <Hijiri> can I make yi use a different ghc package prefix?
17:28:29 <e11> how would you guys do the simplest possible while loop --- while x < 4, do this
17:29:56 <_um_> do you reckon that the Haskell ecosystem is on the verge of a sweeping reorganization/rationalization?
17:30:50 <mpickering> e11: What program are you trying to write?
17:31:52 <e11> anything with a simple while loop right now
17:32:09 <srhb> e11: Usually loops such as while only really make sense in a monadic context.
17:32:48 <e11> ok
17:33:25 <srhb> e11: You can check the source of whileM' -- and make it less general if you want.
17:33:51 <_um_> e11: do you want to give a specific example of when you'd want to use a loop, then maybe see what kinds of idiomatic solutions are suggested here?
17:34:13 <_um_> e11: It might help to illustrate the functional approach.
17:35:16 <e11> apparently using recursion is relatively straightforward, so maybe I dont need a while? Just use a function that calls itself if a condition is or isnt met
17:35:44 <e11> (sorry I know the lack of specifics is hurting my line of questioning)
17:35:58 <srhb> e11: Yeah, it is, a bit. But you're right, usually some recursive combinator is the right answer.
17:36:04 <srhb> e11: Obviously it depends on the specifics.
17:36:48 <_um_> e11: that's right. But often using higher order functions and list-like structures is employed in place of explicit recursion.
17:36:48 <e11> yeah, I just saw something on stack overflow that makes recursion look dead simple, so I'm going to try that out. maybe no need for a while loop per se at all
17:38:10 <zwer> why not share what you're actually trying to do? the big picture
17:38:18 <_um_> e11: You can check out, for examples, these many different approaches to fizz buzz in Haskell: http://rosettacode.org/wiki/FizzBuzz#Haskell
17:39:11 <rhovland> @type map
17:39:12 <lambdabot> (a -> b) -> [a] -> [b]
17:40:15 <_um_> e11: in fact, rosettacode is a great resource in general for comparing imperative looping solutions to functional higher-order and recursive solutions to common tasks.
17:40:39 <e11> a nice
17:41:47 * hackagebot olwrapper 0.3.7.12 - An OpenLayers JavaScript Wrapper and Webframework with snaplet-fay  http://hackage.haskell.org/package/olwrapper-0.3.7.12 (thomas84)
17:42:42 <e11> ok thanks guys. sorry I was hoping to solve this without shifting my paradigm too much tonight. thanks all
17:46:47 * hackagebot olwrapper 0.3.7.13 - An OpenLayers JavaScript Wrapper and Webframework with snaplet-fay  http://hackage.haskell.org/package/olwrapper-0.3.7.13 (thomas84)
18:10:13 <Ghost-Initiative> Can someone help me out?
18:10:49 <pavonia> Out of what?
18:11:03 <Ghost-Initiative> I need some help with something.
18:11:15 <Taneb> Ghost-Initiative, I'd imagine someone can, just ask the question.
18:11:38 <Ghost-Initiative> First, is here a good IDE for Haskell?
18:12:20 <Taneb> Ghost-Initiative, FP Complete have an IDE purposebuilt for Haskell, some people use Eclipse. I personally am content with emacs, though
18:12:22 <OutlawStar> emacs isn't bad, tho its not really an ide
18:12:53 <Ghost-Initiative> Would it work on Kali Linux? And if so, how would I get it?
18:12:59 <_um> Ghost-Initiative: I also use Emacs with haskell-mode.
18:14:33 <_um> Ghost-Initiative: If you aren't already an emacs user, you might want to consider using one of the starter kits here: http://ergoemacs.org/misc/list_of_emacs_starter_kits.html
18:15:09 <Hijiri> I use emacs too
18:15:34 <Ghost-Initiative> Thanks.
18:17:06 <OutlawStar> Ghost-INitiative: this was really helpful for me: https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md
18:18:14 <_um> OutlawStar: Oh yes. I've used that resource too. Very helpful.
18:38:00 <gamegoblin> Can you guys think of a short way to write this: "Given a character C and a string S, replace groups of C with the integer size of that group" . e.g. f 'c' "aabbccdd" == "aabb2dd"
18:38:40 <OutlawStar> seem to recall a problem on hackerrank with that ...
18:38:59 <gamegoblin> I need it for a FEN notation thing for my chess program
18:39:23 <gamegoblin> in FEN notation, you specify the board in rows, like pp2pn2
18:39:33 <gamegoblin> would be "pawn pawn empty empty pawn knight empty empty"
18:40:04 <Lokathor> so ONLY the empty squares are numbers?
18:40:08 <gamegoblin> It’s easy to make something like pp??pn??
18:40:08 <gamegoblin> yes
18:40:16 <gamegoblin> but I then need to convert the ??? to 3
18:40:19 <gamegoblin> or the ? to 1
18:40:19 <gamegoblin> etc
18:41:05 <Lokathor> well the really dumb way to do it is to use regex, match against 1 through 9, and when you do get a match replace it with that many ? instead of the digit.
18:41:10 <_um> Cale: I posted the solution to the random element selection that you helped me work out as an SO answer: http://stackoverflow.com/a/27883428/1187277
18:41:17 <Lokathor> there's probably a better solution
18:41:43 <gamegoblin> Lokathor: I need to do the reverse, I need to map pp??pn?? to pp2pn2
18:41:58 <OutlawStar> something i did: http://pastebin.com/8nwR68TM
18:42:03 <OutlawStar> not sure if its the best
18:42:35 <Lokathor> Ohhhh, well that's fine, then just do the same thing, but backwards. Look for ???????? and replace with 8, look for ??????? and replace with 7, etc, down to 1.
18:42:48 <OutlawStar> tho its probably not  exactly what you want
18:43:26 <gamegoblin> I can make a dumb/simple solution, I was wondering if anyone could come up with anything clever using the "group" function or something
18:43:33 <enthropy> > group "aabbccdd"
18:43:34 <lambdabot>  ["aa","bb","cc","dd"]
18:43:37 <zwer> > let f c = concat . map (\xs@(x:_) -> if x == c then show (length xs) else xs) . group in f 'c' "aabbccdd"
18:43:38 <lambdabot>  "aabb2dd"
18:44:30 <gamegoblin> zwer: probably cleaner with a list comprehension than a lambda, but I think that’s a good way to do it
18:46:11 <zwer> yeah you're right
18:49:29 <perry2> how to write a version of length that continuously prints (using \r) the currently counted length?
18:50:25 <perry2> is it even possible
18:50:34 <gamegoblin> perry2: I don’t understand your question
18:50:46 <Hijiri> do you want it to literally print something, or give you a string?
18:50:47 <gamegoblin> Can you give an example?
18:50:56 <Hijiri> for the first one, it would need to work with IO
18:52:03 <perry2> mylengtg (repeat 5) should keep printing numbers, from 1 to infinite
18:52:13 <Hijiri> @let lenPrint' x [] = return x; lenPrint' x (x:xs) = putStrLn x >> lenPrint' (x+1) xs; lenPrint xs = lenPrint' 0 xs
18:52:14 <lambdabot>  .L.hs:197:11:
18:52:14 <lambdabot>      Conflicting definitions for ‘x’
18:52:14 <lambdabot>      Bound at: .L.hs:197:11
18:52:18 <Hijiri> @undefine
18:52:18 <lambdabot> Undefined.
18:52:20 <Hijiri> @let lenPrint' x [] = return x; lenPrint' x (x:xs) = putStrLn x >> lenPrint' (x+1) xs; lenPrint xs = lenPrint' 0 xs
18:52:21 <lambdabot>  .L.hs:157:11:
18:52:21 <lambdabot>      Conflicting definitions for ‘x’
18:52:21 <lambdabot>      Bound at: .L.hs:157:11
18:52:37 <Hijiri> @let lenPrint' x [] = return x; lenPrint' y (x:xs) = putStrLn y >> lenPrint' (y+1) xs; lenPrint xs = lenPrint' 0 xs
18:52:37 <lambdabot>  .L.hs:155:25:
18:52:38 <lambdabot>      No instance for (Num String) arising from the literal ‘0’
18:52:38 <lambdabot>      In the first argument of ‘lenPrint'’, namely ‘0’
18:52:40 <Hijiri> aa
18:52:52 <perry2> mylength "foo" should print 1\r2\r3\n then return 3
18:52:56 <Hijiri> @let lenPrint' x [] = return x; lenPrint' y (x:xs) = putStrLn y >> lenPrint' (y+1) xs; lenPrint xs = lenPrint' (0::Int) xs
18:52:56 <lambdabot>  .L.hs:155:26:
18:52:57 <lambdabot>      Couldn't match type ‘Int’ with ‘[Char]’
18:52:57 <lambdabot>      Expected type: String
18:52:59 <Hijiri> sorry
18:53:01 <gamegoblin> jesus
18:53:08 <Hijiri> but something like this
18:53:12 <Hijiri> except not broken
18:53:13 <pavonia> :t \x -> mapM_ [1 .. length x] print
18:53:14 <lambdabot>     Couldn't match expected type ‘a0 -> m b0’ with actual type ‘[Int]’
18:53:14 <lambdabot>     In the first argument of ‘mapM_’, namely ‘[1 .. length x]’
18:53:14 <lambdabot>     In the expression: mapM_ [1 .. length x] print
18:53:29 <gamegoblin> print comes first
18:53:33 <gamegoblin> mapM_ print
18:53:44 <pavonia> :t \x -> mapM_ print [1 .. length x]
18:53:44 <Hijiri> I was trying to make one that traverses once
18:53:45 <lambdabot> [a] -> IO ()
18:53:50 <pavonia> Ah, thanks
18:54:17 <gamegoblin> I am worried the asker doesn’t get the IO restrictions haskell has on functions, yet
18:54:59 <perry2> what IO restrictions you mean
18:55:08 <jle`> haskell functions can't execute IO
18:55:30 <bitemyapp> jle`: what a delightful distinction to make.
18:55:40 <gamegoblin> perry2: In haskell you can’t just put print statements wherever you want like most languages
18:56:06 <gamegoblin> perry2: Haskell uses the IO monad to control where IO can happen
18:56:12 <jle`> s/monad/type
18:56:19 <gamegoblin> that
18:56:20 <bitemyapp> jle`: ...beat me to the punch.
18:56:33 <bitemyapp> jle`: have to be careful though. Haskell functions can force `IO a`
18:56:42 <bitemyapp> jle`: some people are going to see that and think, "execute IO"
18:56:54 <bitemyapp> when it's more of a straight-forward thunk-sink
18:57:14 <gamegoblin> perry2: have you read Learn You a Haskell or anything yet?
18:57:21 <bitemyapp> gamegoblin: LYAH isn't very good.
18:57:26 <bitemyapp> no offense intended.
18:57:31 <gamegoblin> bitemyapp: It’s good enough if he hasn’t read anything
18:57:36 <bitemyapp> gamegoblin: what? no.
18:57:43 <bitemyapp> gamegoblin: http://bitemyapp.com/posts/2014-12-31-functional-education.html
18:57:50 <bitemyapp> gamegoblin: https://github.com/bitemyapp/learnhaskell
18:58:08 <jle`> :t foldM (\i _ -> let i' = i+1 in print i' >> return i) 0
18:58:09 <lambdabot> (Show a, Num a) => [b] -> IO a
18:58:16 <jle`> er that should be i'
18:58:35 <jle`> :t foldM (\i _ -> let i' = i+1 in i' <$ print i') (0 :: Int)
18:58:36 <lambdabot> [b] -> IO Int
18:58:48 <bitemyapp> jle`: it type-checks, ship it.
18:58:55 <jle`> yaaa
18:59:23 <jle`> 8D
18:59:27 <jle`> BD
18:59:33 <perry2> i am 6 chapters into LYAH
19:00:04 <bitemyapp> perry2: please consider looking at the two links I provided.
19:01:23 <rtpg> anyone know why parsec docs for 3.1.8 aren't built on hackage?
19:05:26 <StoneToad> bitemyapp: that's what I love about haskell (recently had to write some stuff in python)
19:25:28 <sbrg> bitemyapp: what do you feel LYAH lacks?
19:26:04 <_um> sbrg: bitemyapp has a pretty good write up with critiques at the first of the links given.
19:26:26 <sbrg> I'm reading it right now
19:26:38 <sbrg> wasn't sure it contained specific arguments for LYAH
19:26:39 <sbrg> but thanks
19:26:49 <sbrg> s/for/regarding
19:27:00 <bitemyapp> sbrg: you found the entry in the blog post?
19:27:53 <sbrg> aye
19:28:15 <bitemyapp> sbrg: don't get me wrong, we haven't made leaps & bounds in how we teach Haskell since LYAH was published, but there is better material for the vast majority of learners.
19:28:44 <bitemyapp> sbrg: the mistake if believing one is a special snowflake for whom a custom progression of material is needed. If you already know how to program in *any* language, my recommendations in the guide hold true.
19:28:50 <sbrg> I'll admit that I haven't really looked at stuff like the cis course or your material in detail, and it's been years since I really took a look at LYAH
19:29:10 <bitemyapp> sbrg: we (not just me) teach a bunch of people from zero in another IRC channel.
19:29:25 <bitemyapp> sbrg: and my guide is a reflection of not just my experience teaching people Haskell, but theirs as well.
19:29:26 <hrumph> what's wrong with lyah?
19:29:28 <hrumph> its a good book
19:29:38 <bitemyapp> sbrg: ^^ see why I wrote the blog post?
19:29:42 <bitemyapp> hrumph: for learning Haskell? No.
19:29:47 <bitemyapp> hrumph: http://bitemyapp.com/posts/2014-12-31-functional-education.html
19:29:51 <bitemyapp> hrumph: https://github.com/bitemyapp/learnhaskell
19:29:52 <sbrg> yeah -- I've been TAing for a haskell course this past quarter. It's gone rather fast, but some people have used LYAH and they somewhat liked it, but I also linked them to your material as well as the cis course.
19:30:04 <hrumph> there's no perfect book you basically have to learn stuff on your own from multiple sources then when you come back to something like lyah it all makes sense at that poin
19:30:13 <bitemyapp> hrumph: I've taught a lot of people Haskell.
19:30:17 <Hijiri> there is no perfect book but there are better books and worse books
19:30:28 <bitemyapp> hrumph: please don't make excuses for materials I've lived and breathed for the last couple years.
19:31:01 <bitemyapp> hrumph: my links explain 1. Why I do or don't recommend various materials/books for learning haskell 2. the progression I *do* recommend for learning Haskell
19:31:21 <bitemyapp> hrumph: it's not about "perfect", the recommended material is what's worked best given what we have available.
19:31:51 <bitemyapp> sbrg: It pains me (I'm talking salt in open wound here) to use LYAH with a student, but I do so if they have truly *zero* programming experience and even then I only use the first 3-4 chapters.
19:31:52 * hackagebot setenv 0.1.1.2 - A cross-platform library for setting environment variables  http://hackage.haskell.org/package/setenv-0.1.1.2 (SimonHengel)
19:32:17 <bitemyapp> sbrg: hard cutoff (as in, divert to something else immediately) is when the book starts talking about Functor.
19:32:57 <sbrg> bitemyapp: The people I was teaching are rather new. They are actually from my own class, and because you don't find Haskell people growing on trees I was TAing for the course while taking it at the same time.. anyway, some of my classmates are .. well, rather new to programming. They have experience that is 99% limited to the stuff they've been forced to do for assignments and projects.
19:33:12 <sbrg> bitemyapp: i see
19:33:12 <bitemyapp> sbrg: you may have misunderstood.
19:33:15 <bitemyapp> sbrg: misunderstood me*
19:33:21 <bitemyapp> sbrg: zero *programming* experience
19:33:26 <bitemyapp> sbrg: not zero *Haskell programming* experience.
19:33:38 <bitemyapp> if they did three exercises in codecademy, I'm not telling them to use LYAH.
19:33:43 <sbrg> yep -- these people had what I would almost call zero programming experience
19:33:47 <sbrg> ah.
19:34:08 <bitemyapp> sbrg: you'd be better off making some monkey-see monkey-do material (it wouldn't take long) with some reinforcing exercises to lead into cis194.
19:34:13 <sbrg> at any rate, I directed them to LYAH, cis and your github page. for some reason, most people looked at lyah. I don't know why.
19:34:20 <bitemyapp> sbrg: marketing / drawings
19:34:32 <bitemyapp> cis194 isn't obviously useful. That's why I have to be forceful about it.
19:34:44 <hrumph> there's no way to learn other than diving in and tinkering
19:34:45 <sbrg> bitemyapp: Unfortunately, there simply wasn't time. It was a rather superficial course. It was not as much a haskell course as it was a general programming languages course.
19:34:50 <bitemyapp> sbrg: I understand.
19:34:57 <sbrg> I wish, though.
19:35:00 <hrumph> ok i admit i'm not a super smart guy. if i was i could just read a book and know everything
19:35:02 <bitemyapp> sbrg: I'm working on a book.
19:35:10 <sbrg> bitemyapp: sweet
19:35:13 <bitemyapp> hrumph: what exactly are you arguing against?
19:35:26 <hrumph> i didn't understand the state monad by reading about the state monad. i had to play with it and make a variant for instance
19:35:40 <bitemyapp> sbrg: I'd like to make the book suitable for people teaching classes, could I solicit your advice/feedback on that later in the process?
19:37:06 <hrumph> i mean i could use the state monad but i didn't reall *understand* it until i messed around with it changing the bind function and what not
19:38:15 <hrumph> at first i made something without appreciating that it wasn't obeying the monad laws
19:38:16 <sbrg> bitemyapp: Haha, sure. I have rather limited teaching experience, however, but of course I'm interested in making Haskell more accessible. It's probably still Haskell's biggest problem.
19:38:29 <bitemyapp> sbrg: Agreed. would you be willing to /query me an email address?
19:38:42 <bitemyapp> sbrg: The (albeit spare) site for the book is at: http://haskellbook.com/
19:40:50 <sbrg> bitemyapp: sure, done.
19:41:18 <hrumph> anyway if there are excercises i would lean in the direction of having the students make variants of the existing things
19:42:23 <hrumph> there's bound to be quite a few interesting variants of the state and the writer monad that could go in an excercise book
19:44:01 <bitemyapp> hrumph: you just got done recounting why I tell people *not* to use LYAH and instead to use cis194 and the NICTA course
19:44:26 <bitemyapp> hrumph: because they're exercise-driven, they make the students write the code themselves, and in the case of the NICTA course, you recreate all the abstractions, datatypes, and instances from scratch so that they're unmistakable.
19:44:46 <bitemyapp> hrumph: if you'd read my post or heard me out about why I recommend the material that I recommend, you'd have known that.
19:45:12 <bitemyapp> I wrote the post on Haskell learning materials so I wouldn't have to keep explaining this over and over.
19:45:25 <hrumph> ok sorry i just butted in
19:45:35 <hrumph> i haven't been following the entire convo
19:46:14 <bitemyapp> hrumph: just please reconsider recommending LYAH to people who want to learn Haskell unless you're willing to at least take a look at the materials I recommend and my explanation of why I recommend them.
19:46:24 <hrumph> ok np
19:46:31 <bitemyapp> hrumph: it leads to people having more difficulty than is necessary and nothing pains me more than seeing people get frustrated and give up.
19:46:46 <bitemyapp> Haskell *isn't* that hard, we're just terrible at teaching it. Even really smart, talented people have a hard time teaching it.
19:46:53 * hackagebot setenv 0.1.1.3 - A cross-platform library for setting environment variables  http://hackage.haskell.org/package/setenv-0.1.1.3 (SimonHengel)
19:47:42 <bitemyapp> hrumph: it pains me because I had to re-attempt learning Haskell *several times* over the course of over five years before I got anywhere substantial with Haskell.
19:48:25 <hrumph> well haskell is something you never go back on.... you were hooked on the first attempt just like many others
19:53:53 <drbean_> How do I explicitly ignore an arg? I want to write a function abcde c = "abcde", but am getting the warning, Warning: Defined but not used: `c'
19:56:10 <bitemyapp> drbean_: _
20:22:24 <EvanR> i have a question about notation http://ibin.co/1njlCKLdIPpt what does the (^I) mean here
20:24:33 <ahihi> conjunction introduction, it just denotes which rule was used
20:24:47 <EvanR> oh
20:24:55 <EvanR> its the name of the rule
20:24:58 <ahihi> yep
20:25:46 <EvanR> and (^E1) and (^E2) stands for elimination
20:26:40 <_um> EvanR: yep. you can just read all those as as [name of sign] ++ "elimination/intro"
20:30:59 <darkroom> does anyone know of a safe indexing function? I couldnt find one on hoogle the type should be [a] -> Int -> Maybe a
20:31:28 <enthropy> @type \n -> listToMaybe . drop n
20:31:29 <lambdabot> Int -> [a] -> Maybe a
20:31:43 <darkroom> oh damn thats good
20:31:47 <darkroom> thanks
20:32:15 <enthropy> probably it's defined with a proper name in some library
20:32:39 <EvanR> :t listToMaybe .: drop
20:32:39 <lambdabot>     Not in scope: ‘.:’
20:32:39 <lambdabot>     Perhaps you meant one of these:
20:32:39 <lambdabot>       ‘.’ (imported from Data.Function),
20:32:43 <darkroom> most likely ;) but thats awesome because i already have listToMaybe imported
20:32:49 <EvanR> :t listToMaybe (.).(.) drop
20:32:49 <lambdabot>     Couldn't match expected type ‘(a -> [a2] -> [a2]) -> c’
20:32:50 <lambdabot>                 with actual type ‘Maybe a0’
20:32:50 <lambdabot>     Possible cause: ‘listToMaybe’ is applied to too many arguments
20:33:38 <ahihi> > (\n -> listToMaybe . drop n) (-1) "abc"
20:33:39 <lambdabot>  Just 'a'
20:33:54 <mjo> try atMay from https://hackage.haskell.org/package/safe
20:34:06 <petercommand> :t atMay
20:34:07 <lambdabot> Not in scope: ‘atMay’
20:34:10 <mjo> naturally there's NO DOCUMENTATION WHATSOEVER but the type signature looks good
20:51:15 <glguy> :t preview.ix :: Int -> [a] -> Maybe a
20:51:16 <lambdabot> Int -> [a] -> Maybe a
20:53:33 <gamegoblin> Does anyone here know template haskell?
20:55:08 <pavonia> Yes
20:55:34 <gamegoblin> OK, I’ve got this really stupid code that I am 99% sure can be templated much nicer. Let me lpaste it.
20:56:52 <gamegoblin> pavonia: context: I’m hacking on a chess engine, and I have a datatype for Rank (row on a chess board) like Rank = One | Two | Three | … | Eight
20:57:06 <gamegoblin> pavonia: It’s useful to be able to add an offset to square
20:57:12 <gamegoblin> But I want to do it safely
20:57:25 <gamegoblin> I can do some fromEnum toEnum with typical integer addition
20:57:35 <gamegoblin> with guards to make sure everything is within bounds
20:57:38 <gamegoblin> but that’s slow
20:57:42 <gamegoblin> so I did this: http://lpaste.net/118230
20:57:44 <EvanR> is it slow?
20:57:46 <gamegoblin> which is MUCH faster
20:57:54 <gamegoblin> EvanR: look at my solution that is a lot faster
20:58:00 <gamegoblin> I wrote a little script to generate all that code
20:58:13 <gamegoblin> So that’s fine and all
20:58:18 <EvanR> theres a benchmark?
20:58:24 <gamegoblin> EvanR: Yes
20:58:46 <gamegoblin> EvanR: to generate the game tree 4 moves deep with fromEnum toEnum stuff takes 8.2 seconds
20:58:53 <gamegoblin> EvanR: this solution takes 1.5 seconds
20:59:01 <EvanR> another way to represent squares is (Int,Int)
20:59:18 <gamegoblin> EvanR: I know, But it’s really nice to be able to type (E, Four)
20:59:31 <gamegoblin> And it’s marginally more type safe, I guess
20:59:45 <EvanR> or (e, 4) where e = 5
20:59:58 <gamegoblin> I know I know, I’ve thought of that
21:00:25 <gamegoblin> I may ditch the enums and switch to pure ints, we’ll see
21:00:32 <gamegoblin> But I’d still like to learn this bit of template haskell
21:00:44 <EvanR> the maybe is adding about as much safety as my ints which support negative but dont make sense
21:00:49 <EvanR> neither is adding correctness guarantees
21:09:32 <Archi> hey guys
21:09:44 <Archi> what it means this
21:10:01 <Archi> The pkg-config package gtksourceview-3.0 version >=3.0.0 is required but it could not be found.
21:11:12 <Archi> &  The pkg-config package webkitgtk-3.0 version >=1.8 is required but it could not be found.
21:11:25 <Archi> i need to do cabal install in  that specific version ?
21:11:49 <glguy> You probably need to install the development version of those libraries using your system's package manager
21:11:56 * hackagebot Deadpan-DDP 0.9.1.0 - Write clients for Meteor's DDP Protocol  http://hackage.haskell.org/package/Deadpan-DDP-0.9.1.0 (LyndonMaydwell)
21:12:47 <gienah> and like glguy means C/C++ libraries
21:15:13 <Archi> Ok
21:39:50 <gamegoblin> EvanR: I just switched the coordinates to Ints instead of my custom enums and it turns out it’s only ~10% faster, I actually expected a lot more
21:44:34 <EvanR> gamegoblin: well, maybe try data Square = Square !Int !Int
21:44:46 <gamegoblin> EvanR: trying...
21:45:19 <gamegoblin> do I have to do data or can I use a type synonym?
21:45:39 <EvanR> for what type
21:45:43 <gamegoblin> Square
21:45:52 <EvanR> whats a Square ;)
21:45:57 <gamegoblin> previously Square was just type Square = (File, Rank)
21:46:14 <EvanR> right, but tuples dont have !
21:46:19 <gamegoblin> didn’t know that
21:46:30 <EvanR> theres also unboxing
21:46:34 <EvanR> Int#
21:46:56 <EvanR> maybe ghc already does this for you with -O2
21:47:51 <EvanR> > snd (undefined, 0)
21:47:52 <lambdabot>  0
21:48:15 <EvanR> > imaginaryPart (undefined :+ 0)
21:48:17 <lambdabot>  Not in scope: ‘imaginaryPart’
21:48:24 <EvanR> > Data.Complex.imaginaryPart (undefined :+ 0)
21:48:25 <lambdabot>  Not in scope: ‘Data.Complex.imaginaryPart’
21:48:25 <lambdabot>  Perhaps you meant ‘Data.Complex.imagPart’ (imported from Data.Complex)
21:48:33 <EvanR> > Data.Complex.imagPart (undefined :+ 0)
21:48:34 <lambdabot>  *Exception: Prelude.undefined
21:50:23 <jessicah`> how do I match a tuple using a case statement?
21:50:49 <jessicah`> i tried "case buildOS, userInstall of" but that gives a syntax error
21:51:04 <bitemyapp> jessicah`: gotta match on the tuple constructor
21:51:06 <HeladoDeBrownie> jessicah`, case x of (a, b) -> ... -- for example
21:51:06 <mjo> case (x, y) of
21:51:15 <bitemyapp> jessicah`: tuples aren't just commas, you need those parens too.
21:51:29 <bitemyapp> jessicah`: which is why mjo's example should work
21:51:42 <EvanR> (+) (*) (,) ;)
21:51:57 <jessicah`> that applies to all the case statements too, then?
21:51:58 * hackagebot doctest 0.9.12 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.9.12 (SimonHengel)
21:52:05 <_um> > case (1, 2) of {(1, x) -> x ;  otherwise -> 0}
21:52:07 <lambdabot>  2
21:52:21 <HeladoDeBrownie> jessicah`, tuples in particular have parens, other patterns in general don't need them except for disambiguation
21:52:24 <_um> > case (3, 2) of {(1, x) -> x ;  otherwise -> 0}
21:52:25 <lambdabot>  0
21:52:46 <jessicah`> ah, am used to ocaml, which is a bit more lax syntax wise :p
21:52:47 <jessicah`> thanks!
21:53:26 <_um> jessicah`: I found that kind of refreshing about OCaml too.
21:53:31 <_um> I'd like to explore it more.
21:53:45 <_um> But I only dipped a toe in.
21:53:47 <monochrom> case (buildOS, userInstall) of (Winblows, Barely) -> ...
21:53:48 <mjo> jessicah`: you don't technically need to match tuples against tuples, something stupid like this will also work: case (1,2) of x -> error "uh oh"
21:54:05 <mjo> it just matches the whole tuple (1,2) to x
21:54:23 <_um> disjunctive matches in case expressions are *dope* in OCaml.
21:54:46 * _um immediately regrets silly way of emphasizing.
21:55:18 <EvanR> as in, on a rope
21:55:50 <Javran> would the compiler try to optimize "\x -> f x || not (f x)" if f is a function that returns Bool?
21:56:08 <Javran> I want to check quickly if this "f" can terminate on certain inputs by evaluating "print $ all (\x -> f x || not (f x)) xs"
21:57:08 <mjo> Javran: do you mean, would it simplify it to (const True)?
21:57:21 <Javran> mjo: yes
21:57:25 <mjo> Then no, it won't
21:57:52 <Javran> mjo: I see
21:57:54 <mjo> Our middle is not excluded generally
21:58:33 <mjo> The only tautology is (x || not x || who knows)
21:58:58 <mjo> But GHC is not very smart about optimizing such things anyway
21:59:37 <EvanR> f x || not (f x), heh thats not necessarily const True
21:59:52 <EvanR> or True
22:00:05 <gamegoblin> EvanR: under what circumstance? error being thrown?
22:00:12 <Javran> so another question, if I want to do this termination check, will "force (map f xs)" also work?
22:00:20 <gamegoblin> EvanR: or infinite loop?
22:00:22 <EvanR> bottom
22:00:28 <mjo> gamegoblin: We have a third option... right
22:00:48 <EvanR> as in, a pain in the
22:01:08 <Javran> i meant force from Control.DeepSeq
22:01:45 <mjo> Javran: maybe, I would try it with an f that loops indefinitely. I have a tendency to be wrong guessing about laziness.
22:02:06 <EvanR> if your NFData has no normal form, then its broken
22:02:13 <EvanR> but the compiler cant tell you that
22:02:40 <EvanR> if the NFData instance exists and is right, then it will always terminate
22:03:17 <Javran> yeah, that's what I meant check quickly
22:03:46 <Javran> I can confirm it terminates when it terminates
22:03:57 <jessicah`> weird, GHC doesn't list the missing patterns for non-exhaustive matches?
22:04:10 <Javran> but might not tell if it won't terminate
22:04:10 <jessicah`> is there a way to make it tell me what they are?
22:04:56 <Javran> if it runs too long, I'll just kill the process and guess it doesn't terminate :(
22:05:04 <EvanR> Javran: force only works on a list of something that has an NFData instance
22:05:10 <EvanR> does it?
22:05:19 <gamegoblin> EvanR: adding strictness to the fields of Square makes it about 2x faster than the enum method
22:05:29 <Javran> EvanR: sure, its a value of [Int]
22:05:41 <mjo> jessicah`: you need -fwarn-incomplete-patterns, it's included in -Wall
22:05:51 <EvanR> > force [1,2,3]
22:05:52 <lambdabot>  Not in scope: ‘force’
22:06:05 <EvanR> > Control.DeepSeq.force [1,2,3]
22:06:06 <lambdabot>  Not in scope: ‘Control.DeepSeq.force’
22:06:45 <jessicah`> so cabal install --ghc-options=-fwarn-incomplete-patterns?
22:06:53 <EvanR> Javran: well that seems silly. force [1..] never completes
22:07:01 <mjo> That looks right
22:07:06 <Javran> I found " NFData a => NFData [a] " and " NFData Int " in the document
22:07:06 <EvanR> are you trying to test to see if a list is infinite?
22:07:10 <mjo> Wait, no it doesn't =)
22:07:15 <mjo> You need to BUILD with that flag
22:07:40 <jessicah`> mjo: cabal does the build automatically...
22:08:00 <mjo> Ok, nevermind, I'm losing it
22:08:13 <Javran> EvanR: actually I'm trying to do a loop detection on some [Int], so if I've done something wrong that might not terminate.
22:08:52 <EvanR> ok yeah the list and the algorithm that generates a given Int may not terminate, theres no way to know in general
22:09:18 <mjo> Int is bounded, there's a way to tell =P
22:09:21 <jessicah`> mjo: it doesn't tell me what the constructors are =/
22:09:40 <jessicah`> all I get is: setup: Distribution/Simple/GHC.hs:(872,5)-(886,37): Non-exhaustive patterns in function supportRPaths
22:09:43 <EvanR> > undefined :: Int
22:09:44 <lambdabot>  *Exception: Prelude.undefined
22:09:54 <Javran> turns out at least my loop detection works for certain inputs.
22:10:24 <Javran> am working on a project euler problem, so I know the input space.
22:10:34 <mjo> jessicah`: which package are you installing? That doesn't seem right
22:10:46 <jessicah`> I'm installing cabal
22:11:19 <jessicah`> patching sources for Haiku support for the new version
22:12:12 <jessicah`> I'll try it without running via cabal...
22:13:13 <mjo> Is it just that one file you patched? Can you pastebin it somewhere? (Which cabal version does it apply on top of?)
22:13:59 <jessicah`> 1.22
22:14:02 <jessicah`> three files
22:14:21 <jessicah> https://github.com/jessicah/haiku-ghc/blob/bindist/haiku-fixes.patch
22:14:27 <jessicah> the Cabal parts from in there
22:14:37 <EvanR> Javran: if it freezes, it may have looped
22:14:40 <jessicah`> plus the added case to GHC.hs
22:17:18 <hexagonest> Hey I don't understand the $ function. Why does sum . replicate 2 . max 4 $ 6 work, doesn't it just do sum . replicate 2 . max 4 (6) ?
22:18:21 <jessicah`> bah; I have to go out now... be back in couple hours
22:18:47 <matematikaadit> hexagonest: f $ a = f a
22:19:14 <hexagonest> so it just equals to sum . replicate 2 . max 4 6?
22:19:26 <EvanR> it has lower precedence
22:19:35 <EvanR> (sum . replicate 2 . max 4) 6
22:19:39 <hexagonest> what does that mean? I don't get precendence
22:20:00 <hexagonest> I thought it was right associative so it took everything on its right
22:20:18 <EvanR> > (+) $ 2 $ 3
22:20:20 <lambdabot>  Could not deduce (GHC.Num.Num (s0 -> s))
22:20:20 <lambdabot>    arising from the ambiguity check for ‘e_123’
22:20:20 <lambdabot>  from the context (GHC.Num.Num (s1 -> s),
22:20:40 <EvanR> yeah it is, but theres only one $ so whether it left or gith assoc doesnt matter
22:20:48 <EvanR> right*
22:20:50 <matematikaadit> hexagonest: (.) is higher in precedence than ($), like saying multiplication (*) is higher than addition (+)
22:21:01 <hexagonest> Oh
22:21:06 <hexagonest> so it has like, higher priority?
22:21:28 <M-x> lower
22:21:32 <hexagonest> right
22:21:48 <hexagonest> someone should make a PEDMAS kind of thing for haskell lmao
22:21:50 <hexagonest> thanks guys.
22:22:21 <matematikaadit> hexagonest: actually, you can inspect it in ghci by typing :info ($)
22:23:27 <hexagonest> $ :: (a -> b) -> a -> b so it takes a function taking one parameter returning another, one parameter a and returns b
22:24:10 <matematikaadit> well, yes. all function in haskell just take one parameter after all.
22:24:45 <matematikaadit> what you interested maybe this line: infixr 0 $
22:25:02 <matematikaadit> compare that with :info (.)
22:25:05 <hexagonest> Yeah mate I've heard about currying, but it's easier to skip that and say 2 parameters
22:25:13 <hexagonest> Yeha I see now i did $ , . , + , *
22:25:17 <matematikaadit> infixr 9 .
22:25:18 <hexagonest> I can see all their infix
22:25:19 <mseeks> i'm trying to write something to do bayesian probability calculations, and i want to have a data type that can sort of be a combination of arbitrary numbers of itself
22:25:22 <hexagonest> it's pretty cool
22:26:34 <mseeks> e.g., if something can be Blue|Red and Furry|Slimy and Big|Small, I want to be able to take the cartesian product and come up with Blue & Red & Big, Blue & Red & Small, etc.
22:27:28 <mseeks> I've just started thinking about this so I don't have a great idea of how to proceed. I know SIGFPE has a good writeup of this but I want to figure it out for myself
22:28:10 <gamegoblin> mseeks: the list monad is great for cartesian products
22:28:25 <M-x> I can't wrap my head around how Scala's Try[t] would be expressed in Haskell, could you help me with that please? Doesn't it have to be parametrized by an error type as well?
22:28:39 <mseeks> yeah, I'm trying to figure out how to do the types as well
22:28:58 <gamegoblin> mseeks: [(a,b,c) | a <- someListOfValues, b <- otherList, c <- thirdList]
22:29:06 <gamegoblin> mseeks: will yield a list of all 3-tuples of those values
22:30:28 <mseeks> gamegoblin: thanks -- how would I do this for arbitrary numbers of attributes, though?
22:30:46 <mseeks> where an attribute is something like Color = Blue | Red; Size = Big | Small
22:31:24 <gamegoblin> well you can get a list of all possible values of your enum, assuming you do something like Color = Blue | Red deriving (Bounded, Enum)
22:31:33 <gamegoblin> mseeks: then you can do [minBound .. maxBound]
22:31:38 <gamegoblin> which will return [Red, Blue]
22:31:49 <gamegoblin> or [Big, Medium, Large, Giant] or whatever
22:32:32 <mseeks> I'm trying to do this at a higher level though -- I don't want to end up with [Color] but rather something like [Attribute], where an instance of this would be [Blue, Furry, Small]
22:33:02 <gamegoblin> mseeks: you’re thinking about this in an object oriented inheritance sort of way
22:33:22 <gamegoblin> mseeks: in that case, you should make one data type that has constructors corresponding to each of your attributes
22:33:52 <mseeks> attributes being what though?
22:34:04 <gamegoblin> mseeks: e.g. data Attribute = ColorAttribute Color | SizeAttribute Size | TallAttribute Tall
22:34:26 <mseeks> I'd like to be able to specify arbitrary additional attributes though
22:34:36 <gamegoblin> mseeks: at runtime?
22:35:26 <mseeks> well, I just want to make this general so you could specify attributes, if that makes sense
22:35:51 <gamegoblin> Can you pastebin and example of what you’d like your code to look like, in a pseudocodey sort of way?
22:36:02 <gamegoblin> The use-case, not the data definitions
22:36:07 <gamegoblin> just how you’d like to use this data type
22:36:09 <mseeks> yeah, sure
22:36:13 <EvanR> M-x: whats Try[t]
22:36:21 <mseeks> thanks for the help, by the way!
22:37:35 <M-x> EvanR: http://www.scala-lang.org/api/current/index.html#scala.util.Try
22:38:13 <M-x>  EvanR: I guess i figured it out already though
22:38:37 <EvanR> M-x: how is this different from any other expression? you cant throw exceptions from just anywhere?
22:40:45 <M-x> EvanR: I'm not sure I understand the question. It's like Either, but for intended specifically for signaling errors
22:40:58 <mseeks> gamegoblin: here you go -- http://lpaste.net/118233
22:42:09 <mseeks> gamegoblin: probably the Object type would be better named as a State or something; I just used Object because I had in mind something with a color, size, etc.
22:42:34 <EvanR> M-x: well im having a hard time understanding how the Try example there is functioning... but generally you can use Either or EitherT to deal with errors like this
22:42:42 <gamegoblin> mseeks: If you want to do it exactly like that, you’d be better off using an a language with inheritence, or dynamic typing (heterogenous lists)
22:43:01 <EvanR> M-x: Either e has a Monad instance which ends the computation early with a result of Left theError
22:43:02 <gamegoblin> mseeks: if you want to use haskell, you’ll probably have to do it the way I suggested with an data Attribute = … method
22:43:26 <gamegoblin> mseeks: Or for a super simple solution just use strings instead of proper enum types
22:43:52 <EvanR> M-x: integer division by zero is an edge case which you should avoid like the plague, either by proving that you will never divide by zero, or by doing a runtime check on the divisor before doing the division
22:44:13 <mseeks> gamegoblin: this is what I wanted to do: http://www.randomhacks.net/2007/02/22/bayes-rule-and-drug-tests/
22:45:04 <gamegoblin> mseeks: that’s totally possible, the difference is there are a *fixed* number of attributes, so the n-tuple always has the same n (2 in the heroin example)
22:45:30 <gamegoblin> mseeks: in that case, my very first comment about [(a,b,c) | a <- firstList, b <- secondList, c <- thirdList] is what you want
22:45:34 <mseeks> gamegoblin: right, that makes sense
22:46:03 <EvanR> M-x: alternatively if youre wondering how to deal with IO-errors when asking for user input, then you need to use one of the catch-like forms from Control.Error
22:46:08 <mseeks> I think my error was in where I wanted to draw the abstraction line
22:46:21 <M-x> EvanR: ah, I see. Try(<expr>) will catch exceptions throwed by expr and return Failure - was that the source of confusion for you?
22:46:37 <gamegoblin> mseeks: Indeed. If you want a dynamic number of attributes, you have to coalesce them into one big type with a data wrapper with various constructors for each attribute
22:46:49 <gamegoblin> mseeks: if you have a fixed number, you can just make all of your functions use the same n-tuple
22:46:51 <EvanR> M-x: in Try(readline(..)) ?
22:47:09 <M-x> EvanR: yeah
22:47:20 <gamegoblin> mseeks: otherwise you have to use the wrapper and pass in a variable length list that contains a bunch of your wrapper types
22:47:34 <mseeks> gamegoblin: I see. One thing I was considering was defining an Attribute typeclass and having the cartesian product have type Attribute a => [[a]]
22:47:38 <EvanR> M-x: the result of this might be a Failure? stored in that val?
22:47:51 <mseeks> but that seemed pretty strange because the typeclass wouldn't have any methods or anything
22:48:20 <mseeks> it seemed like a bad use of typeclasses to me
22:48:23 <gamegoblin> mseeks: another problem is that the As would still need to be the same type. For example, just because Int and Float are both members of the Show typeclass, I can’t really have a list that contains both Ints and Floats
22:48:38 <mseeks> ohh, I see
22:48:47 <gamegoblin> mseeks: there are ways to do heterogenous typeclass lists in haskell, but they are kind of ugly
22:48:59 <gamegoblin> mseeks: and wouldn’t do what you want
22:49:10 <mseeks> yeah, I was just thinking about it the wrong way
22:49:17 <mseeks> thanks for the help!
22:49:27 <gamegoblin> mseeks: tbh I think just using strings is the most pragmatic approach
22:49:41 <M-x> EvanR: yes, it's either Success with number or Failure with the exception thrown. That was what I was confused about: how to define Try so it's parametrized only by success type but can also return an exception. Then I realized that Try is not an adt, but a type class (correct me if I'm wrong)
22:50:15 <mseeks> yeah, most of my motivation for doing this is to learn more haskell so I figured doing things the right/clean way would be preferable
22:50:50 <gamegoblin> mseeks: in that case, the Attribute wrapper type is what you want
22:51:41 <mseeks> do you mean Attribute as a parametrized type?
22:51:50 <EvanR> M-x: bear with me... "with an exception thrown" means an actual exception is thrown, and you get no value?
22:52:15 <gamegoblin> mseeks: I mean something like data Attribute = AttributeColor Color | AttributeSize Size | AttributeHeight Height
22:52:29 <gamegoblin> then you *can* make a list of [Attribute]
22:52:49 <gamegoblin> each of your Attribute constructors contain within them a different type
22:52:59 <M-x> EvanR: yes, a JVM NumberFormatException or something like that
22:53:00 <mseeks> makes sense
22:53:14 <mseeks> that would give up the ability to add arbitrary attributes though
22:53:35 <gamegoblin> mseeks: what do you mean by add arbitrary attributes?
22:53:39 <EvanR> M-x: alright. so lets unwind basically everything about this scenario, since its heavily scala oriented.
22:54:03 <EvanR> M-x: you dont want to define this Try class in the first place, from what im hearing. you just want to be able to throw an exception
22:54:05 <mseeks> I basically wanted to make something like the Dist typeclass here -- http://www.randomhacks.net/2007/02/21/randomly-sampled-distributions/
22:54:32 <EvanR> M-x: you want to use this IO command:
22:54:34 <EvanR> :t getLine
22:54:34 <lambdabot> IO String
22:54:45 <EvanR> when you execute this, you will get a String
22:54:52 <mseeks> but didn't know what abstractions to use
22:54:53 <EvanR> OR there will be an exception
22:55:04 <EvanR> OR nothing will ever happen because no one types anything
22:55:13 <EvanR> so you dont need to do any of this to get what you asked for
22:55:31 <C-x> -c
22:55:39 <EvanR> line1 <- getLine
22:55:42 <EvanR> line2 <- getLine
22:55:48 <EvanR> return (f line1 line2)
22:56:01 <EvanR> M-x: does this make sense?
22:56:18 <gamegoblin> mseeks: that Dist will still only produce "   Dist a   " where if you wanted a [Dist a] your 'a’s would all still need to be the same type
22:57:05 <mseeks> gamegoblin: I wanted to eventually be able to take the cartesian product of Dist's
22:57:50 <gamegoblin> mseeks: I totally get you, but what I’m saying is those type 'a’s need to all be the same (i.e. a wrapper type around all your various attributes)
22:57:59 <mseeks> yeah I know
22:58:11 <mseeks> I was just thinking about it in the wrong way
22:58:28 <Archi> ey guys
22:58:30 <gamegoblin> mseeks: it’s definitely weird going from java/python/whatever to haskell
22:58:55 <gamegoblin> mseeks: Haskell definitely makes this particular use case slightly more tedious than a dynamic language. It might not be the right tool for the job.
22:59:51 <M-x> EvanR: yes, I understand Haskell handles the whole thing differently, but actually I was asking specifically about the Haskell type analogous to that of Try. I mean, not because of some practical considerations, but because of pure interest (honestly, I've never written any considerable amount of code in Haskell, but just love reading about it and learn its ideas)
22:59:51 <EvanR> gamegoblin: many things that dynamic languages make easy have better alternatives in haskell anyway
23:00:16 <gamegoblin> EvanR: for various definitions of better
23:00:38 <Archi> i just installed finally leksah what path under which haskell sources for packages may be found  should i add ?
23:01:18 <EvanR> M-x: well, you write Try(expr) here. from what i understand this either executes expr and returns the successful result, or throws an exception if executing expr would throw an exception. so it seems like it doesnt do anything?
23:02:11 <hamishmack> Archi: If you have a directory you would like it to search when looking for the source for installed pacakged (those ghc-pkg list) then add that
23:02:44 <hamishmack> You don’t have to add anything
23:02:54 <Archi> really ?
23:03:13 <Archi> i can leave it  in blank then ?
23:03:30 <hamishmack> Yes it will cabal unpack the sources it can
23:03:56 <hamishmack> and it will index the ones you add to your workspace
23:03:59 <Archi> ok
23:05:09 <Archi> about the 3 options below  what i must choose ?
23:06:17 <Archi> 1) try to  download and then build locally if that fails 2) try to build locally and then download if that fails 3 )never download  (just try to build locally)
23:06:29 <EvanR> M-x: i think i understand more now. none of this is throwing an exception. its just returning the Success or Failure at each step. and real exceptions are converted to Failure values. You can use Either directly to do this.
23:07:01 * hackagebot total 1.0.0 - Exhaustive pattern matching using lenses, traversals, and prisms  http://hackage.haskell.org/package/total-1.0.0 (GabrielGonzalez)
23:07:25 <M-x> EvanR: yes, I was searching for the source to demonstrate this: https://github.com/scala/scala/blob/v2.11.5/src/library/scala/util/Try.scala#L185
23:07:59 <EvanR> M-x: yeah, you have to do the same in haskell. catch every exception. which is probably a bad idea in any language
23:09:29 <M-x> EvanR: but Either is parametrized by both success and failure types, when Try only by Success type. So we have to define Try typeclass and two datatypes: Success a and Failure e, and somehow restrict from creation of other instances.
23:09:51 <EvanR> yes you would use Either Exception to pull this off
23:09:59 <EvanR> Try isnt a type class
23:10:16 <EvanR> in haskell classes mean something different from classes in object oriented languages
23:10:52 <EvanR> in haskell Success a and Failure e are not two types, but two constructors for the same data type, Either e a
23:12:26 <M-x> EvanR: hmm, then for example what would be the value of a in the Failure e constructor?
23:12:58 <EvanR> theres only one argument to either constructor
23:13:01 <EvanR> :t Left
23:13:02 <lambdabot> a -> Either a b
23:13:06 <EvanR> :t Right
23:13:07 <lambdabot> b -> Either a b
23:13:49 <EvanR> in case of Failure (Left) there would be no Right value, its a different constructor with different kind of parameters
23:13:58 <EvanR> > Left "ERRORRRR"
23:13:59 <lambdabot>  Left "ERRORRRR"
23:14:04 <EvanR> > Right 9
23:14:05 <lambdabot>  Right 9
23:14:50 <M-x> Ah, I think I got it. Silly me.
23:15:48 <EvanR> many haskell libraries give an api that, if something goes wrong, you get an Either e a for some e instead of an exception.
23:16:10 <EvanR> but anything doing IO might not, and has the possibility of throwing an IO exception
23:16:16 <jle`> data Either e a = Left e | Right a
23:16:24 <jle`> two constructors -- Left, and Right
23:16:27 <jle`> one or the other
23:16:34 <Archi> " url from  which to download pre built metadata"  ummmmm instead of leksah  web page  can i use hackage.haskell.org ?
23:18:48 <hamishmack> Archi: Leksah metadata is not on hackage and it is only present for a subset of packages
23:19:01 <gamegoblin> is mapM_ guard [a,b,c] the same as guard a; guard b; guard c
23:19:35 <Iceland_jack> Yes but it's not true for every function 'mapM_ f [a,b,c]'
23:19:37 <hamishmack> Leksah shoudl be able to build it localy for the packages that are not present on the server
23:19:54 <gamegoblin> Iceland_jack: just need it to be true for guard ;)
23:19:58 <M-x> EvanR: but there is a typeclass for errors, so I can chain together functions from different libraries, right?
23:20:23 <Archi> ok thanks
23:20:32 <EvanR> theres a data type for errors, Either
23:20:34 <jle`> i feel like i would probably rather guard (and [a,b,c])
23:20:38 <Archi> hamishmack: thanks
23:21:18 <gamegoblin> jle`: probably more intuitive, good call
23:21:28 <M-x> EvanR: no, no - I've got it. I'm asking now about that e in Left e. If I want to chain multiple functions together, their e has to unify, aren't they?
23:21:51 <EvanR> if you use the Either monad instance, the e all has to be the same
23:22:00 <Iceland_jack> For completeness...:
23:22:00 <Iceland_jack>       map_ guard             [a, b, c]
23:22:00 <Iceland_jack>     = sequence_              (map guard [a, b, c])
23:22:00 <Iceland_jack>     = sequence_              [guard a, guard b, guard c]
23:22:02 <EvanR> since its instance Monad (Either e) where
23:22:03 <Iceland_jack>     = foldr (>>) (return ()) [guard a, guard b, guard c]
23:22:08 <Iceland_jack>     = guard a >> guard b >> guard c >> return ()
23:22:11 <Iceland_jack>     = guard a >> guard b >> guard c
23:22:23 <gamegoblin> Iceland_jack: haha, I like it
23:22:33 <gamegoblin> dat referential transparency tho
23:22:38 <EvanR> M-x: but you would not do this for your entire application
23:23:10 <Iceland_jack> I should probably limit the number of lines for what I post
23:23:30 <Iceland_jack> It just gets out of control :)
23:23:50 <EvanR> M-x: another aspect of haskell is that you would prefer most of your code to not be able to error out, and this is accomplished by ensuring the data you are working with is correct sooner in the process
23:24:10 <EvanR> validation is a step that could return Either String a
23:24:15 <EvanR> and thats it
23:24:42 <matematikaadit> :t guard
23:24:43 <lambdabot> MonadPlus m => Bool -> m ()
23:25:06 <matematikaadit> :t guard (and [])
23:25:07 <lambdabot> MonadPlus m => m ()
23:25:51 <EvanR> M-x: im rewriting the Try example to demonstrate
23:29:46 <EvanR> M-x: http://lpaste.net/118234
23:32:24 <EvanR> M-x: since the dialog "always" returns a successful value, it doesnt use the Either type. this will make it easier to "chain" than if everything in the app had to use Try
23:32:43 <EvanR> division by zero hard exception never gets thrown due to validation
23:33:52 <M-x> EvanR: thank you, I see the idea, but still doesn't quite convinced about chaining
23:34:27 <EvanR> the dialog produces a valid int from a valid division. you dont even have to check it for errors ;)
23:34:38 <EvanR> (or null pointer)
23:35:37 <EvanR> its common to chain a bunch of things returning Maybe such that the first one that fails results in a Nothing for the whole thing, rather than continuing on nonsensically
23:35:46 <sgronblo> Is there some other version of Data.Graph that would allow you to define the graph through a function instead, like Data.Graph.AStar seems to do.
23:37:04 <M-x> EvanR: but I think the main point of the scala example is that you have two different possibly exeptional computations, and you chain them together via flatMap, and in the end you get the first "exception" thrown, no matter what other functions in the chain might throw
23:37:15 <EvanR> you actually dont
23:37:25 <M-x> EvanR: with Maybe you just get Nothing, thus lose the information
23:37:26 <EvanR> you have a very large number of possible exceptions all happening
23:37:39 <EvanR> in my example there would only be three possible problems
23:38:59 <M-x> EvanR: why a very large number? It's three two: any of inputs can be not integer or division by zero
23:39:06 <M-x> *three too
23:39:20 <EvanR> i read the documentation of Try
23:39:32 <EvanR> it converts *any exception* into a normal value
23:39:40 <EvanR> not just the ones you think you are going to get
23:40:07 <EvanR> this will mask bugs (like null pointer exception) io errors (like end of file on stdin) or out of memory
23:40:32 <EvanR> in all three the program probably shouldnt continue, at least, in a production setting
23:41:09 <M-x> Well e.g. toInt can only throw NumberFormatException
23:41:27 <glguy> The Try type looks like Either SomeException, and the Try constructor looks like Control.Exception.try
23:42:08 <EvanR> M-x: do you happen to know how many different things Console.readLine can throw?
23:42:48 <EvanR> and obviously the example doesnt have any bugs, thats not a good excuse for assuming your real code doesnt have bugs
23:44:09 <M-x> glguy: ah, so there is an Exception typeclass!
23:44:31 <EvanR> SomeException is a type
23:44:53 <EvanR> all exceptions implement the Exception class, which isnt what youre thinking of
23:45:42 <M-x> EvanR: I've talked about http://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Exception-Base.html#t:Exception
23:45:57 <M-x> Why it isn't what I'm thinking of?
23:47:20 <EvanR> because Either Exception a isnt a valid type
23:47:30 <EvanR> because Exception isnt a type
23:47:47 <M-x> Exception e => Either e is not valid either?
23:48:02 <EvanR> used where
23:48:41 <M-x> I guess in declaration of Monad instance
23:48:51 <EvanR> yeah its not
23:49:11 <EvanR> it overlaps with the existing Either e instance
23:49:55 <EvanR> you said you werent interested in actually using haskell, just curious, so im telling you dont want to structure your code like this
23:50:10 <EvanR> in case you change your mind ;)
23:50:46 <M-x> Ah, then let it be MyEither or something, we're talking about conceptual possibility after all
23:51:12 <M-x> EvanR: but I perfectly agree with the points about code structuring you've made
23:51:24 <Lokathor> I just installed a fresh system, and cabal update isn't actually connecting to hackage and getting the package list. Any ideas why this might be?
23:51:40 <M-x> EvanR: my only concern was that, e.g. in your example, validate is a single compound function
23:51:48 <EvanR> yeah you can do Either SomeException, and youd then have to catch all exceptions and put them in a Left like scala is doing, and also take any functions you use that fail another way and make an artificial exception
23:52:04 <EvanR> M-x: yeah, thats where the rules for validation go, as they change per requirements
23:52:26 <EvanR> without messing with IO
23:55:13 <M-x> EvanR: yeah, I'm not talking about IO, rather about composing several validations. It still seems better to me for all of them to return Exception e => Either e instead of Either FooException, Either BarException, etc
23:55:15 <EvanR> M-x: heres the use of Either String monad to check the input http://lpaste.net/118234
23:55:55 <EvanR> M-x: SomeException stands for any exceptions, the exceptions are weird
23:56:10 <EvanR> and mucking with them manually is annoying
23:56:30 <EvanR> and this doesnt involve IO so, its not haskelly to use them
23:58:23 <M-x> EvanR: why "manually"? I imagine instead of Left "entered zero" you could write error "entered zero", and that would be the only difference
23:58:34 <EvanR> you cant
23:58:48 <EvanR> because youd have to catch the result of error
23:59:24 <EvanR> > error "zero"
23:59:26 <lambdabot>  *Exception: zero
23:59:26 <M-x> Hmm, if there an `error` operator in Haskell, I didn't mean it
23:59:39 <joelteon> just a function
23:59:50 <EvanR> an evil one
23:59:56 <EvanR> :t error
23:59:57 <lambdabot> [Char] -> a
