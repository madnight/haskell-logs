00:00:13 <Welkin> State Game is m
00:00:18 <Welkin> so why not?
00:00:25 <benzrf> Welkin: well
00:00:31 <benzrf> Welkin: maybe the type of the do block you are using this in
00:00:36 <benzrf> is someting other than State Game
00:01:23 <Welkin> No instance for (Control.Monad.State.Class.MonadState
00:01:23 <Welkin>                        Game (MyState Game))
00:01:24 <Welkin>       arising from a use of ‘.=’
00:01:40 <Welkin> MyState = State
00:01:56 <benzrf> aaaaaaand there's your problem
00:02:17 <benzrf> Welkin: you have not written a MonadState instance for MyState
00:02:18 <benzrf> er, wait
00:02:22 <benzrf> Welkin: is MyState a type /synonym?
00:02:32 <Myrl> I heard that imperative haskell takes more resources, 'tis true?
00:04:35 <benzrf> Welkin: if MyState is a new type you have created then it needs a MonadState instance to work with lens's stuff
00:04:43 <benzrf> Welkin: if it is just a synonym, idk what's goin on
00:04:49 <benzrf> Welkin: anyway i need to sleep
00:04:52 <benzrf> good luck :)
00:04:56 <benzrf> night
00:05:12 <Welkin> okay, that was the problem
00:05:25 <Welkin> I should have used the existing State instead of my own toy version
00:05:37 <Welkin> thanks
00:05:40 <Hijiri> Myrl: what do you mean by "imperative haskell"?
00:07:07 <Myrl> Hijiri: Basically making everything using the do notation.
00:07:33 <Hijiri> not really
00:07:39 <Hijiri> do notation isn't inherently imperative either
00:07:50 <Hijiri> it's just syntactic sugar for the monad combinators
00:08:02 <Hijiri> so it means something different for every monad
00:08:21 <Hijiri> whether it's "efficient" or not would depend on what you are trying to do and what monad your do block is for
00:08:46 <Myrl> Hijiri: Ah, okay.
00:08:49 <Hijiri> it would be difficult to make absolutely everything use do notation
00:08:55 <Hijiri> I think it would come out to be a mess
00:09:54 <Myrl> Lol. :P
00:16:18 <hodapp> Myrl: if the notation suggests too much that isn't actually true, then it can cause one to use it to write more inefficient things.
00:21:38 <Myrl> hodapp: Ah.
00:22:32 <hodapp> Myrl: but you can look at the rules for how 'do' notation is translated, do it by hand, and verify it's the same
00:41:34 <alt_ern> Hi. How could I convert strict ByteString to lazy ByteString?
00:41:51 <Axman6> dcoutts: I was just rereading your slides on a Data.Binary replacement and wondering if there had been any progress
00:42:23 <Axman6> alt_ern: I think these days bytestring has a fromStrict function. if not, you can use fromChunks . (:[])
00:45:23 * hackagebot conduit-extra 1.1.6.1 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.6.1 (MichaelSnoyman)
01:10:59 <nuser> is lazy evaluation why null = [head[]] returns false?
01:11:11 <nuser> > null [head[]]
01:11:12 <lambdabot>  False
01:11:24 <Black-Heaven> Hi all, I'm trying to debug haskell code but I encounter some issues. I have to debug some code in a given package (HaskellNet) of which I'm not the owner but I need another package to run the the code that reproduce the bug (HaskellNet-SSL). I have tried to add HaskellNet-SSL to HaskellNet cabal file, but since HaskellNet-SSL depends on HaskellNet, cabal find a circular dependency and complains. I h
01:11:30 <Black-Heaven> ave try to debug with ghci/:break from HaskellNet-SSL but it requires a interpreted module to work. If you have any idea, thanks by advance to share them.
01:11:33 <EvanR> nuser: yes
01:11:36 <nuser> thanks
01:11:39 <EvanR> @src null
01:11:39 <lambdabot> null []     = True
01:11:39 <lambdabot> null (_:_)  = False
01:11:52 <EvanR> it does not care about the contents of the list, only the structure
01:12:01 <nuser> cool!
01:12:33 <nuser> so is it lazy evaluation or pattern matching?
01:12:44 <nuser> looks like the latter from the definition
01:13:11 <EvanR> its the lazy
01:13:33 <EvanR> imagine if it eagerly evaluated null [head []] or equivalently null [undefined]
01:13:50 <nuser> > null [undefined]
01:13:51 <lambdabot>  False
01:13:59 <EvanR> meaning it attempted to full construct the list first before calling null
01:14:03 <EvanR> fully*
01:14:09 <EvanR> > [undefined]
01:14:10 <lambdabot>  [*Exception: Prelude.undefined
01:14:19 <nuser> got ya
01:14:30 <EvanR> > [undefined] `seq` 9
01:14:31 <lambdabot>  9
01:14:35 <EvanR> heh
01:14:45 <nuser> thank you
01:15:01 <EvanR> > null [1..]
01:15:02 <lambdabot>  False
01:15:17 <nuser> yup
01:15:40 <ab9rf> > let x = 1:x in null x
01:15:41 <lambdabot>  False
01:18:18 <solatis> how does EitherT relate to ContT ? Is EitherT a specialization of ContT?
01:19:23 <Axman6> @unmtl EitherT e m a
01:19:24 <lambdabot> EitherT e m a
01:19:27 <Axman6> bleh
01:20:01 <solatis> let me rephrase the question
01:20:19 <solatis> is my understanding correct that EitherT allows for contuination-style programming ?
01:20:24 * hackagebot hydrogen 0.2.0.0 - An alternate Prelude  http://hackage.haskell.org/package/hydrogen-0.2.0.0 (KarlVoelker)
01:20:56 <solatis> or should i be using some more generic way than EitherT ?
01:21:24 <ab9rf> use whatever works :)
01:23:10 <solatis> right, because i almost feel like fmap + applicative could be doing the same, but more simple
01:24:20 <solatis> and that that would result in simpler code
01:24:35 <solatis> since i'm now hoisting Eithers to EitherTs and doing runEitherT
01:24:51 <solatis> which, i guess works, but i feel it's not as elegant as it could be
01:59:00 <solatis> @hoogle [(a,b)] -> [b]
01:59:02 <lambdabot> Prelude snd :: (a, b) -> b
01:59:03 <lambdabot> Data.Tuple snd :: (a, b) -> b
01:59:03 <lambdabot> Language.Haskell.TH.Syntax MultiIfE :: [(Guard, Exp)] -> Exp
01:59:27 <solatis> > map snd [(1,2),(3,4)]
01:59:29 <lambdabot>  [2,4]
02:03:55 <drdo> How come (..) isn't a valid identifier?
02:04:51 <shachaf> The syntx is used for ranges.
02:05:10 <drdo> oh right
02:05:26 * hackagebot extensible 0.1 - Poly-kinded, extensible ADTs  http://hackage.haskell.org/package/extensible-0.1 (FumiakiKinoshita)
02:15:40 <gamegoblin> Is there a function that repeats a certain function N times? Like repeatF 3 succ would be the same as succ . succ . succ
02:17:10 <gamegoblin> @hoogle (Maybe a, Maybe b) -> Maybe (a,b)
02:17:13 <lambdabot> No results found
02:17:25 <gamegoblin> @hoogle (m a, m b) -> m (a,b)
02:17:26 <lambdabot> No results found
02:18:01 <shachaf> uncurry (liftA2 (,)) has the type you want.
02:18:57 <solatis> > map snd [(1,2),(3,4)]
02:18:59 <lambdabot>  [2,4]
02:18:59 <solatis> whoops
02:19:26 <wz1000> I'm thinking of using Hakyll for a blog. Does anyone have any experience with it? Do you reccomend it?
02:20:39 <gamegoblin> shachaf: yeah ended up making sequencePair (a,b) = (,) <$> a <*> b
02:20:53 <gamegoblin> points for point-free, though
02:23:25 <gamegoblin> @pl \x -> f x >>= f
02:23:25 <lambdabot> (f =<<) . f
02:25:32 <Myrl> Ooohhh...
02:27:30 <predator117> gamegoblin: you can repeat function application using 'iterate' and '(!!)'
02:27:30 <predator117> > iterate succ 0 !! 2
02:27:31 <lambdabot>  2
02:27:52 <gamegoblin> predator117: clever
02:28:04 <gamegoblin> didn’t think about that
02:28:15 <predator117> so 'succN n = iterate succ 0 !! n'
02:29:19 <predator117> err 'succN n x = iterate succ 0 !! n x' of course if you want to have a succ funciton
02:29:47 <predator117> oops i mean 'succN n x = iterate succ x !! n'
02:44:06 <ReinH> You can also do fun things like
02:44:10 <ReinH> > foldr (.) id (replicate 10 succ) $ 0
02:44:12 <lambdabot>  10
02:45:31 <ReinH> > let repeatF n = foldr (.) id . replicate n in repeatF 10 succ 0
02:45:32 <lambdabot>  10
02:46:21 <ab9rf> that's much nicer than the pointfree version using iterate :)
02:46:33 <ReinH> monoids are useful
03:10:48 <Myrl> @src on
03:10:48 <lambdabot> (*) `on` f = \x y -> f x * f y
03:11:22 <Myrl> Hmmm... how do I find what module it's on?
03:13:19 <AlecTaylor> hi
03:13:30 * AlecTaylor is tempted to use Haskell for his RESTful API
03:15:21 <sivteck> Myrl, You would use hayoo or hoogle. If it's already in scope, use ```:i on''' in ghci
03:15:29 <sivteck> @hoogle on
03:15:31 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
03:15:31 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
03:15:31 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
03:15:33 * AlecTaylor is on https://www.haskell.org/haskellwiki/Web/Frameworks
03:19:28 <AlecTaylor> miku looks good
03:20:58 <Myrl> sivteck: Ah, okay.
03:21:24 <Myrl> sivteck: On another note, is there a way to install Haskell scripts(? Do people call them scripts?) without the use of cabal
03:30:46 <sivteck> you can create a binary with ghc
03:32:24 <sivteck> ghc <flags> <haskellscript>
03:33:18 <nbl_> plop !
03:33:20 <nbl_> Hello =)
03:37:59 <moop> hi hi
03:38:39 <hrnz> hi hi hi
03:38:57 <moop> don't outhi me bro
03:39:22 <Axman6> > fix ("hi "++)
03:39:23 <lambdabot>  "hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi hi ...
03:40:37 <moop> hax
03:40:39 <moop> i call hax
03:41:01 <hrnz> :)
03:43:11 <DrSkyLizard> What are the most common places where you search for Haskell research papers?
03:45:23 <sinelaw> google
03:45:34 <sinelaw> but haskell wiki has bunch of links, per topic
03:45:39 <sinelaw> *a bunch
04:06:19 <utdemir> hey. is there a comprehensive syntax recommendations for haskell, akin to pep-8 of python?
04:14:14 <yac> is it possible to do `map (\x -> if isAlphaNum x then x else '-') xs` in list comprehension?
04:16:15 <quchen> [ if isAlphaNum x then x else '-'  |  x <- xs ]
04:16:37 <Axman6> > [if isAlphaNum x then x else '-' | x <- "hello1234 ekb "]
04:16:39 <lambdabot>  "hello1234-ekb-"
04:17:42 <yac> oh interesting
04:17:52 <yac> can it be used with the syntax where condition is in the right part?
04:18:18 <Axman6> not really, conditions on the right work like filter
04:18:32 <Axman6> what you're doing is definitely mapping
04:18:36 <Axman6> nothing more
04:19:24 <quchen> > [ x | y <- "lorem ipsum dolor sit amet", let x = if isAlphaNum y then y else '-' ]
04:19:25 <lambdabot>  "lorem-ipsum-dolor-sit-amet"
04:19:49 <quchen> I don't think any of this makes the code much more readable though.
04:21:24 <yac> yeah seems so
04:25:12 <vin-ivar> can I pattern match inside guards?
04:25:24 <tasker> I'm trying to profile some code I've got, but it just tells me that 99% of the time was spent in main. Main is calling one function that I defined in a different module - why doesn't it show information about this ?
04:25:28 <vin-ivar> instead of using case
04:25:44 <nbl_> vin-ivar: I don't think so
04:25:52 <tasker> Isn't there a pattern-guards extension ?
04:25:59 <tasker> not sure if it actually does what you want though..
04:26:11 <vin-ivar> i didn't think i could, but then i read this
04:26:18 <vin-ivar> http://stackoverflow.com/questions/9345589/guards-vs-if-then-else-vs-cases-in-haskell
04:28:11 <nbl_> vin-ivar: guards are juste boolean matching
04:29:48 <vin-ivar> cheers, I thought as much
04:29:51 <vin-ivar> thanks
04:30:08 <k00mi> > let f x | Just n <- listToMaybe x = n | otherwise = 0 in f []
04:30:09 <lambdabot>  0
04:30:19 <k00mi> you can do pattern matching in guards
04:40:32 * hackagebot exp-pairs 0.1.0.0 - Linear programming over exponent pairs  http://hackage.haskell.org/package/exp-pairs-0.1.0.0 (Bodigrim)
04:54:07 <kraljev10> Hey, why is MonadPlus not defined for Reader monad?
04:54:21 <kraljev10> Does it even make sense what I am asking?
04:55:32 <breadmonster> @src MonadPlus
04:55:32 <lambdabot> Source not found. There are some things that I just don't know.
04:55:33 * hackagebot haskell-updater 1.2.8 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.2.8 (SergeiTrofimovich)
04:55:49 <quchen> :t mzero -- kraljev10, what would be the implementation for Reader?
04:55:49 <lambdabot> MonadPlus m => m a
04:55:51 <breadmonster> What's the difference between MonadPlus and MonadTimes?
04:56:43 <kraljev10> quchen: return, same as for Maybe or List
04:57:12 <quchen> kraljev10: Neither Maybe nor List have "return" in their "mzero" definitions.
04:57:30 <quchen> `mzero = Nothing` for Maybe, `mzero = []` for List.
04:57:43 <kraljev10> I better study this subject more and not waste your time. Thanks!
04:58:24 <quchen> kraljev10: mzero lets you create a value "out of thin air", which you cannot do for Reader.
04:58:54 <quchen> Maybe and List on the other hand always have a value for which you don't need anything else (namely Nothing and []).
04:59:08 <kraljev10> thanks, you expalined so I understand in just one sentence, thanks.
05:11:32 <tasker> What are the differences between Data.Map and Data.HashMap ?
05:14:22 <ChristianS> tasker: Data.Map is ordered, Data.HashMap isn't
05:14:47 <tasker> ChristianS: Ah, okay. Do you know what data structure Data.Map is based on ?
05:14:51 <ChristianS> tasker: i tend to always use Map and have found no downsize so far
05:14:52 <tasker> Some kind of tree I suppose
05:15:02 <ChristianS> tasker: yeah, check the docs
05:15:26 <tasker> I need something that allows me to do very many lookups from a large map.. should Data.Map suffice ?
05:15:31 <tasker> I guess I'll just try both :p
05:15:34 <ChristianS> tasker: in theory, HashMap could be faster, but in practice it isn't (in my experience)
05:15:44 <kraljev10> quchen: What if mzero would be fail for Reader?
05:15:56 <ChristianS> tasker: it should, probably
05:16:17 <quchen> kraljev10: There is no `fail` for Reader either. 'fail' should not exist in the Monad class to begin with.
05:16:25 <tasker> ChristianS: Cool, thanks!
05:16:58 <quchen> kraljev10: 'fail' for reader crashes your program.
05:18:56 <kraljev10> yes, but you could catch it, right?
05:19:17 <quchen> Not in pure code, no. You can catch it in IO somewhere outside.
05:19:23 <kraljev10> anyways, not a good candidate for mzero
05:20:34 * hackagebot conduit-extra 1.1.6.2 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.6.2 (MichaelSnoyman)
05:22:30 <ChristianS> tasker: incidentally, you should probably use Data.Map.Strict, not the lazy version. it evaluated keys at insertion time (values can still be lazy).
05:22:48 <tasker> ChristianS: Was already doing so :)
05:25:48 <quchen> ChristianS: Both lazy and strict Map are strict in the keys. The "strict Map" refers to the values.
05:30:02 <ChristianS> quchen: oh, right, must have misremembered that. anyway, i'm happy with the Strict version.
05:35:03 <kraljev10> How would I instantiate Alternative <|> for Reader? For Maybe it was just mplus.
05:35:11 <kraljev10> I'd like first non-failing entry
05:35:44 <numberten> is there a way to make (-1) a partial function
05:35:57 <numberten> having to put lambda everywhere gets annoying >>
05:36:41 <_rgn> subtract?
05:37:43 <zwer> > ((-)1) 5
05:37:45 <lambdabot>  -4
05:37:45 <quchen> numberten: Prelude.subtract exists for this reason
05:37:51 <zwer> meh
05:37:55 <quchen> > map (subtract 3) [1..10]
05:37:56 <lambdabot>  [-2,-1,0,1,2,3,4,5,6,7]
05:38:04 <numberten> (`subtract`3)
05:38:14 <quchen> No backticks!
05:38:19 <numberten> ah
05:38:22 <quchen> Common pitfall :-)
05:38:26 <numberten> i see
05:38:32 <numberten> subtract is like flip (-)
05:38:47 <numberten> thanks
05:39:01 <kraljev10> this is not a partial function
05:39:20 <quchen> And on terminology, (* 3) is a *section*. A *partially applied* function is something that has an argument left open in some sense. A *partial* function is one that maps non-bottom values to bottom.
05:39:23 <kraljev10> maybe partially applied function, but not partial function
05:39:24 <mauke> partially applied function
05:40:02 <mauke> > head ""  -- partial function, crashes on some inputs
05:40:03 <lambdabot>  *Exception: Prelude.head: empty list
05:40:35 * hackagebot graphviz 2999.17.0.2 - Bindings to Graphviz for graph visualisation.  http://hackage.haskell.org/package/graphviz-2999.17.0.2 (IvanMiljenovic)
05:41:26 <numberten> yeah sorry I meant partially applied function
05:41:37 <numberten> i'm pretty familiar with totality, it's just late :(
05:41:44 <kraljev10> hey, I have two reader monads
05:41:50 <kraljev10> how to get first one that is not failing
05:42:06 <mauke> kraljev10: your terminology is off, too
05:42:26 <mauke> a "reader monad" would be something like 'Reader e' or '(->) e'
05:42:31 <mauke> i.e. a type constructor
05:42:41 <mauke> kraljev10: what do you mean by failing?
05:43:12 <mauke> .oO( partially applied type? )
05:43:20 <kraljev10> constructed with fail, instead of return
05:43:42 <mauke> ah
05:43:50 <mauke> depends on the reader monad, then
05:43:56 <mauke> and how it defines fail
05:44:09 <mauke> for Reader, you can't
05:44:38 <mauke> > runReader (fail "hi") ()
05:44:39 <lambdabot>  *Exception: hi
05:44:47 <mauke> it's a hard error
05:44:57 <kraljev10> So I gotta have Reader Env (Maybe T)
05:45:05 <kraljev10> just to indicate failure
05:45:08 <kraljev10> or Either
05:45:29 <mauke> or ReaderT
05:45:44 <mauke> but really, it's just sugar for Env -> ...
06:04:02 <augustss> howdy
06:11:09 <pharpend> Morning everyone
06:11:11 <moop> i don't like how Either assumes that Right is the correct value and Left is the wrong one
06:11:31 <moop> as a leftie, i feel this is discriminatory and oppressive language should be banned from haskell
06:11:51 <mauke> take it up with English
06:12:14 <kraljev10> moop, it's just a guideline
06:12:27 <pharpend> moop: it's because being a lefty is immoral
06:12:27 <nbl_> moop: xD
06:12:38 * pharpend grabs his ruler
06:12:54 <moop> this is why haskell will never succeed as a language
06:12:57 <zwer> kraljev10 what do you mean just a guideline?
06:12:59 <pharpend> moop: present your knuckles
06:13:00 <augustss> Just check left in other languages.  It's even worse.
06:13:25 <augustss> E.g., Sinistra
06:13:42 <kraljev10> zwer: nobody forces you to use right as the correct value
06:13:42 <quchen> data EinsVonBeiden a b = Links a | Rechts b
06:14:20 <pharpend> kraljev10: oh yes they do. In libraries that return Either values, it's always Left Error, Right Value
06:14:32 <quchen> kraljev10: The default instances actually do. And even worse, you could not even write an Either instance that has Right on failure and Left otherwise.
06:14:45 <pharpend> because everyone would assume otherwise
06:14:46 <augustss> At some time before Haskell I had them named Right and Wrong.
06:14:48 <pharpend> then get mad at you
06:14:54 <pharpend> exactly
06:15:02 <kraljev10> Why are they not named Right and Wrong, yep? :)
06:15:04 <pharpend> "left" is just a term invented by the liberals
06:15:17 <pharpend> "left-handed" should be renamed wrong-handed
06:15:25 <nyuszika7h> moop: English is also an oppressive language, using your logic
06:15:29 <nyuszika7h> why are you even speaking it?
06:15:30 <moop> it is
06:15:39 <moop> because i'm oppressed into using it
06:15:41 <quchen> kraljev10: Not all Eithers are wrong/right choices. Either is a bit like the standard tuple: it's the "unnamed" default sum type.
06:16:23 <augustss> Mikael Rittri made the same observation and siggested Left and Right.  It also corresponds to inl and inr used long before that.
06:16:52 <pharpend> They have a similar construct in OCaml with different names
06:17:03 <pharpend> I cant remember what the names are, but they made a lot more sense
06:17:22 <augustss> And using Right for something that is Wrong is clearly silly. :)
06:17:32 <sinelaw> Socialist a | Capitalist b
06:17:32 <pharpend> Like Maybe, instead of Just x and Nothing, it's Some x, None
06:17:39 <augustss> So Left gets stuck with being wrong.
06:17:51 <pharpend> sinelaw: DamnCommie a | MURICA b
06:17:53 <kraljev10> I'd prefer Option = Some | None
06:17:55 <kraljev10> or Nothing
06:18:04 <pharpend> kraljev10: that's what they have in OCaml
06:18:43 <kraljev10> mutate haskell and ocaml, then
06:18:45 <kraljev10> ocaskell
06:18:52 <kraljev10> best of both
06:19:11 <pharpend> O'Caskell - from the University of Dublin
06:19:21 <kraljev10> :)
06:19:21 <moop> data Oppressive = Communism | Death
06:19:51 <bryanedds> nothing like arguing for the merits of FP with a bunch of OO programmers on the internet :)
06:19:59 <pharpend> bryanedds: logs plz
06:20:15 <pharpend> I love talking about it with Ruby programmers
06:20:17 <moop> bryanedds: well, can you mutate an object in haskell? oop wins again
06:20:36 * hackagebot gt-tools 0.2.1 - Console and GUI interface for Google Translate service  http://hackage.haskell.org/package/gt-tools-0.2.1 (SergeiTrofimovich)
06:20:36 <bryanedds> http://www.reddit.com/r/programming/comments/2raa40/functional_programming_should_be_your_1_priority/
06:20:37 <moop> fp limits your mind, bro
06:20:39 <pharpend> bryanedds: can you add a string to an int? oop wins again!
06:20:50 <bryanedds> not the most in-depth thread, but if you're bored...
06:21:18 <moop> bryanedds: posting this in /r/SubredditDrama, ty
06:21:20 <pharpend> >OOP is not incompatible with immutability.
06:21:25 <bryanedds> it never takes me long to remember why I last stopped using reddit
06:21:27 <pharpend> O_o
06:22:20 <mauke> moop: do you have anything to contribute?
06:22:28 <moop> mauke: nothing really
06:22:55 <pharpend> mauke: it's 6 in the morning, nobody has anything to contribute
06:22:56 <bryanedds> at least I got a chance to critique scala again, and amazingly, wasn't downvoted into oblivion for it
06:23:16 <mauke> <pharpend> what is a timezones
06:23:36 <moop> there is only 1 correct timezone
06:23:37 <pharpend> mauke: It's well known that every person lives in Pacific Time
06:23:48 <pharpend> mauke: check your privilege
06:24:08 <mauke> ok, you can go to #haskell-blah or whatever
06:25:17 <moop> why so negative
06:25:23 <pharpend> bryanedds: yeah, on Reddit, if you have any opinion differing from the hivemind, you can go f**k yourself
06:25:45 <mauke> this channel is about Haskell, not random trolling
06:26:04 <pharpend> mauke: wait, so there's a difference?
06:26:25 <pharpend> =p
06:26:49 <mauke> yes, Haskell doesn't support rand
06:26:56 <moop> yes it does
06:27:12 <pharpend> mauke: The americans are awake, all hope of civil discourse is now lost. You must understand this.
06:28:11 --- mode: ChanServ set +o mauke
06:28:22 <mauke> there's an easy solution
06:28:42 <moop> fine, you want this channel dead, let it be dead
06:29:00 <bryanedds> haskellers are dead
06:29:03 <pharpend> heh
06:31:19 <pharpend> mauke: haven't you seen that gist about trolling in #haskell? You are taking the wrong approach here
06:31:42 <glguy> That gist about trolling the channel has caused many problems for the channel
06:31:49 <pharpend> how so?
06:32:07 <RedNifre> Good day everyone!
06:32:15 <pharpend> hi RedNifre
06:32:39 <glguy> It has encouraged people to come and disrupt the channel. It's a bad example
06:33:11 <pharpend> glguy: the key word there is "disrupt" - nobody was disrupting anything
06:33:43 <RedNifre> I'm currently reading about cabal sandboxes. What is the scope of a sandbox? I have a folder full of related projects, can I create a sandbox for the whole folder, or just per project? Can sandboxes be nested? How would that work?
06:33:49 <ddellacosta> is it dangerous to call a C function on a pointer created with (Foreign.Marshal.Utils.) new without using with?  What is the appropriate way to pass a pointer to a struct created via Storable (that is, in Haskell) to a C fn?
06:34:08 <pharpend> RedNifre: you can think of ~ as a sandbox, so, I would think yes
06:34:08 <alpounet> RedNifre: you can have one sandbox for multiple projects
06:34:30 <alpounet> this is especially useful when you have several related projects, for which you want a single "package db"
06:34:59 <alpounet> RedNifre: see the "advanced usage" section at http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
06:35:06 <RedNifre> Hm... so when I build a project, cabal seeks up the directory tree to find a sandbox?
06:35:10 <alpounet> (and the whole article if you're not too familiar with them)
06:35:41 --- mode: mauke set -o mauke
06:36:00 <RedNifre> I'm currently reading exactly that article.
06:36:17 <mauke> ddellacosta: what does the C function do with the pointer, and what is the lifetime of the referenced object?
06:37:20 <ddellacosta> mauke: the C function uses it to set some configuration values, and I'm not positive but I think the lifetime of the referenced object is for the duration of the (short) program
06:37:58 <mauke> ddellacosta: what C library is this?
06:37:59 <ddellacosta> mauke: more to the point, the lifetime is certainly possibly and probably longer than from the point the function returns
06:38:22 <ddellacosta> mauke: libao (http://xiph.org/ao/)
06:38:49 <ddellacosta> mauke: more specifically, see the example code here, which is basically what I'm attempting to port: https://xiph.org/ao/doc/ao_example.c
06:39:35 <ddellacosta> mauke: what I'm asking about in particular is how to pass the &format into ao_open_live, about halfway down
06:40:38 <mauke> ddellacosta: "Pointer to a struct describing the sample format. The caller retains ownership of this structure."
06:40:50 <mauke> that sounds to me like you can free it right away
06:40:57 <RedNifre> What exactly is "cabal install --only-dependencies" and "cabal install --dependencies-only"?
06:41:57 <mauke> ddellacosta: why not use 'with'?
06:42:08 <ddellacosta> mauke: gotcha, thanks.  So I guess simply calling new and passing it in would be fine?
06:42:49 <ddellacosta> mauke: oh, I dunno, that's why I'm asking--I'm fuzzy on the right way to do it in Haskell. I've been calling it w/new as I described, and simply passing that in, but my code is still not working so I wanted to double-check all the points I'm not clear on.
06:43:19 <mauke> ddellacosta: using 'new' may lead to memory leaks
06:43:41 <mauke> if you can, prefer 'with'
06:44:13 <ddellacosta> mauke: okay, thanks for the advice.  But sounds like that's probably not my problem then...
06:44:18 <ddellacosta> in any case, thanks mauke
06:44:38 <alpounet> RedNifre: should be the same thing. it looks at the deps of your package and installs them all
06:44:39 <mauke> right
06:44:47 <mauke> a memory leak wouldn't cause your program to not work
06:44:55 <mauke> (unless it crashes because it runs out of memory :-)
06:44:59 <ddellacosta> mauke: right, haha
06:45:09 <alpounet> (in your "current package database", which is your sandbox if you have one, or the user package db in ~/.ghc otherwise)
06:45:15 <ddellacosta> mauke: well, just checking things off the list--that helps.  Thank you!
06:56:09 <quchen> Anyone familiar with writing bindings to tagged C unions? I'm trying to wrap my head around using c2hsc and hsc2hs, and it won't work like I want it to :-(
07:02:33 <quchen> Some more code to illustrate the issue: http://lpaste.net/117736
07:03:05 <quchen> Do I have to write the Storable instances for unions manually, or is there some way to automate them?
07:10:46 <AshyIsMe> what is the "V a ~ R2" syntax called here?  http://projects.haskell.org/diagrams/doc/manual.html#types-and-type-classes
07:11:21 <AshyIsMe> (in the definition of hcat in the code box)
07:16:08 <glguy> AshyIsMe: It sais that "V a" is equal to "R2"
07:24:38 <RedNifre> So I have two versions of bytestring installed, one is needed by aeson, uninstalling the other would break many packages. I now have a conflict between aeson and convertible because convertible seems to use the old bytestring... but when I check convertible with "cabal info" it says that the dependency is "bytestring -any", so why is there a conflict?
07:25:38 * hackagebot hpqtypes 1.2.5 - Haskell bindings to libpqtypes  http://hackage.haskell.org/package/hpqtypes-1.2.5 (GracjanPolak)
07:26:19 <geekosaur> RedNifre, because dependencies can only vary at build time
07:26:23 <luite> RedNifre: it has been built against one of the. use "ghc-pkg describe" to find out information about an installed package
07:26:44 <geekosaur> ghc has very, very hard *runtime* library version dependencies
07:27:13 <geekosaur> (exact version, currently exact *same build* although that is considered a bug that they're working on)
07:27:50 <wombawomba> I want to turn a function f :: [a] -> [[a]] (which partitions its input) into a function g :: [(a, b)] -> [[(a, b)]] in the natural way (i.e. map (map fst) g == f). How should I do this?
07:28:08 <AshyIsMe> glguy: where can i read about it?
07:28:37 <RedNifre> hm... so I would need to rebuild the "convertible" package then?
07:29:11 <glguy> AshyIsMe: https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/equality-constraints.html You can start here I suppose
07:30:17 <AshyIsMe> glguy: ah cheers
07:30:24 <luite> RedNifre: it might not lead to problems, if you always use 'cabal repl' and cabal can find a working config
07:32:56 <ddellacosta> so I'm getting behavior where if I run some FFI code that has an init/do thing/shutdown cycle without calling the shutdown, it works, but if I include the shutdown it doesn't and appears to just shutdown right away.  The C code it is based on is obviously blocking in the "do thing" step.  There must be something I'm not getting about how do/IO/laziness works in Haskell...can anyone point me in the right direction (a.k
07:32:56 <ddellacosta> .a. right thing to read up on)?
07:33:49 <luite> RedNifre: you can have multiple versions of a package (like you have with bytestring now). the thing that's not possible in 7.8.x and lower is two instances of the same version, built against different dependencies. so unfortunately reinstalling convertible, building against a different bytestring, breaks all the packages that depend on the existing instance
07:34:37 <mm_freak> hi there
07:34:55 <mm_freak> Feuerbach: as far as i see you uploaded the temporary-rc package
07:35:24 <mm_freak> i see no difference between temporary and temporary-rc…  which package should i use?
07:36:55 <RedNifre> luite that's odd, I mean if convertible doesn't care about the version of its dependency, why would reinstalling it break anything?
07:37:53 <gazay> Hello everyone! I noticed that there no such library in Haskell for generating fake data as in other languages (Ruby - faker, ffaker, Elixir - faker, etc). So I decided that it will be good start for me as beginner in Haskell world to make project like this. It is not finished yet but I will be really appreciated if you find a minute to take a look and tell what do you think and what I can improve (I know that there is a lot! :) ). Also I will be really apprec
07:37:54 <gazay> for any other help as PRs and ideas… Here is the link https://github.com/gazay/faker
07:38:17 <mm_freak> gazay: what is fake data?  as in for unit-testing?
07:38:40 <ddellacosta> gazay: have you investigated QuickCheck at all?
07:39:24 <luite> RedNifre: there is no binary compatibility between different versions. you can rebuild the source against a different bytestring version, but not link an already built convertible with a bytestring different form the one it was built with
07:40:13 <lpaste> RedNifre pasted “whatdoesthismean” at http://lpaste.net/117742
07:40:16 <gazay> I will answer with quote from Ruby faker gem as my English not so good: ‘It comes in very handy for taking screenshots (taking screenshots for my project, Catch the Best was the original impetus for the creation of this gem), having real-looking test data, and having your database populated with more than one or two records while you're doing development.’
07:40:44 <RedNifre> luite sure, but I guess it could just rebuild those, too? Anyways...
07:40:47 <mm_freak> gazay: that pretty much sounds like QuickCheck or smallcheck
07:41:03 <RedNifre> I might have fixed it, I'm not sure I understand the output though. Does what I pasted mean that everything went fine?
07:41:11 <mm_freak> gazay: the former will generate random data, while the latter generates data deterministically and is designed to find edge cases quickly
07:41:20 <kraljev10> Couldn't match type ‘Maybe’ with ‘ReaderT Char Maybe’
07:41:23 <kraljev10> any ideas?
07:41:29 <mm_freak> kraljev10: 'lift'
07:41:37 <mm_freak> :t lift
07:41:38 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
07:41:43 <luite> RedNifre: if you rebuild everything that depends on the replaced package, then it's ok
07:41:51 <mm_freak> kraljev10: read as:  Maybe a -> ReaderT Char Maybe a
07:42:36 <gazay> mm_freak: as I understood quickcheck - it will generate data of specific type, but not in specific format. As valid USA street address for example, or valid credit card numbers with luhn sum calculated
07:43:08 <mm_freak> gazay: it generates as defined in the corresponding Arbitrary instance…  a common way to generate data in a specific format is to use a newtype
07:43:21 <mm_freak> gazay: newtype Street = Street { street :: Text }
07:44:38 <Feuerbach> mm_freak: I uploaded it when 'temporary' was broken for a long time. Eventually it got fixed.
07:44:57 <mm_freak> Feuerbach: which one would you recommend then?  'temporary'?
07:45:16 <gazay> anyway it is not only for tests. It is also handy if you want to fill your applications with some user-like data, not some abracadabra
07:45:39 * hackagebot servant-server 0.2.3 - A family of combinators for defining webservices APIs and serving them  http://hackage.haskell.org/package/servant-server-0.2.3 (jkarni)
07:46:09 <mm_freak> gazay: there is nothing wrong with using QuickCheck only for its Arbitrary class, but you probably don't want to add instances to your library, so a better way may be to write a custom generator function
07:46:24 <mm_freak> gazay: the Random class is similar to Arbitrary, but designed for more generic random data
07:46:32 <mm_freak> it's from the 'random' package
07:46:55 <Feuerbach> mm_freak: the only difference between them is the maintainer. Who do you trust more to fix the package promptly when it breaks — me or Max? Or perhaps it's not an issue for you at all.
07:47:26 <mm_freak> Feuerbach: well, i can say that i trust you, but i don't know max at all =)
07:47:33 <mm_freak> so i'll go with temporary-rc =)
07:48:00 <Feuerbach> mm_freak: I eventually had to fork or take over every Max's package that I used (test-framework -> tasty, ansi-terminal, temporary -> temporary-rc)
07:48:28 <Feuerbach> @ops private message spam from cirnetus
07:48:29 <lambdabot> Maybe you meant: pl oeis docs
07:48:47 <Feuerbach> what's the command?
07:49:11 <alpounet> just @ops
07:49:16 <Feuerbach> @ops
07:49:16 <lambdabot> Maybe you meant: pl oeis docs
07:49:19 <alpounet> eh
07:49:21 <Feuerbach> whatever
07:49:59 <mm_freak> Feuerbach: i see
07:50:10 <Feuerbach> mm_freak: Max is a nice guy, but he mostly disappeared from the community, and didn't take any steps to make sure his packages stay maintained
07:50:16 <alpounet> @help
07:50:16 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:50:20 <alpounet> @list
07:50:20 <lambdabot> What module?  Try @listmodules for some ideas.
07:50:23 <alpounet> ...
07:50:36 <gazay> mm_freak: so you think it can’t be useful in Haskell?
07:51:28 <Feuerbach> mm_freak: I, on the other hand, try to have at least one backup maintainer for each of my popular packages: https://ro-che.info/articles/2014-02-08-my-haskell-will
07:52:10 <mm_freak> gazay: the thing is that we have such an infrastructure that there is really no need for a special package for that, so there isn't one i'm aware of (of course i don't know every package that exists)
07:52:33 <mm_freak> gazay: just combine the usual abstractions to get such a generator…  other than specifying the format you pretty much get it for free in haskell
07:52:57 <mm_freak> Feuerbach: i should do that as well
07:53:02 <wombawomba> Asked this earlier but didn't get any responses, so I'm trying with a rephrasing: Is is possible to `lift` a function that selects elements from a list (e.g. f :: [Int] -> Int) to a function that acts identically, but on a list of tuples (f' :: forall b [(Int, b)] -> (Int, b))?
07:53:07 <mm_freak> but at this point i don't even have a homepage
07:54:16 <mm_freak> @djinn ([a] -> a) -> ([(a, b)] -> (a, b))
07:54:16 <lambdabot> Error: Undefined type []
07:54:35 <mm_freak> @djinn (Comonad f) => (f a -> a) -> (f (a, b) -> (a, b))
07:54:35 <lambdabot> Error: Class not found: Comonad
07:54:45 <mm_freak> oh, [] isn't even one
07:54:49 <mm_freak> @djinn (Monad f) => (f a -> a) -> (f (a, b) -> (a, b))
07:54:49 <lambdabot> -- f cannot be realized.
07:54:59 <RedNifre> Hm. If I try "cabal build" it tells me that I need to do "cabal configure" first because I switched to a new version of cabal... but I already did "cabal configure" with that version, it told me that some dependencies are not installed (which I guess is fine, I mean it SHOULD install those when I try to build, right?)
07:55:10 <mm_freak> wombawomba: seems difficult to me at least, because the function is giving up any additional information
07:55:33 <mm_freak> wombawomba: it would require an isomorphism between Int and (Int, A) for whathever A you use, which is only possible if A = ()
07:55:39 <Narfinger> hiho, i have a function String -> (String -> IO ()) and now i want to return an empty function (a function that does nothing), how would i do that?
07:56:06 <wombawomba> okay
07:56:07 <mm_freak> Narfinger: an empty function is something specific, which is probably not what you want to return
07:56:17 <mm_freak> Narfinger: the 'return' function constructs IO actions that do nothing
07:56:32 <mm_freak> :t const (return ()) :: String -> IO ()
07:56:33 <lambdabot> String -> IO ()
07:57:03 <RedNifre> Narfinger, do you mean yourfunction = \s -> return ()
07:57:15 <Narfinger> yes, that looks right
07:57:26 <Narfinger> do i just type this in or do i need to tell haskell that i mean this function?
07:57:55 <mm_freak> Narfinger: look at the types:  myFunc :: String -> String -> IO ()
07:58:14 <mm_freak> Narfinger: if you write `myFunc x = _y`, then what is the type of _y?
07:58:48 <wombawomba> mm_freak: any idea how I could get around it? I want to design an API which takes a f :: [A] -> [[A]] and a [(A, B)], and constructs a [[(A, B)]]
07:59:04 <mm_freak> Narfinger: remember:  String -> String -> IO () = String -> (String -> IO ())
07:59:10 <Narfinger> oh ok
07:59:23 <Narfinger> then String -> IO () of course
07:59:30 <RedNifre> Hm. Could it be that sandboxes are NOT found by going up the directory tree?
07:59:58 <mm_freak> Narfinger: correct…  so _y must be a function itself:  myFunc x = \y -> _z
08:00:05 <mm_freak> (\y -> _z) :: String -> IO ()
08:00:05 <RedNifre> I mean, I added one of my projects to the sources, but I only can find it with "cabal info mypackage" from the root dir of the sandbox, not from within other projects.
08:00:07 <mm_freak> then _z :: ?
08:00:22 <wombawomba> I could probably create a Data.Map A B, apply f to (map fst input), and construct the [[(A, B)]] using the Data.Map, but that'd be annoyingly inefficient
08:00:43 <Narfinger> z_ :: IO ()
08:00:54 <mm_freak> wombawomba: if `f` is polymorphic in A then you can do it
08:01:10 <mm_freak> wombawomba: because then A can unify with (A', B)
08:01:26 <mm_freak> Narfinger: correct
08:01:33 <Narfinger> mhhhh i see
08:01:34 <mm_freak> Narfinger: return :: a -> IO a
08:01:36 <wombawomba> yeah, I want f to be able to inspect the A
08:01:41 <RedNifre> So what's the proper way to build my packages then? Should I have one sandbox per package?
08:01:43 <mm_freak> Narfinger: can you construct an IO action of type IO () using `return`?
08:02:08 <Narfinger> yeah of course with return ()
08:02:13 <wombawomba> eg f = Data.List.partition p
08:02:16 <mm_freak> wombawomba: that doesn't mean you need A to be monomorphic…  you can either use a type class or pass the inspection function as an argument
08:02:29 <mm_freak> wombawomba: similar to:  sortBy :: (a -> a -> Ordering) -> [a] -> [a]
08:02:37 <mm_freak> Narfinger: there you go =)
08:02:51 <mm_freak> Narfinger: always look at the types…  they usually tell you everything
08:03:01 <Narfinger> :)
08:03:06 <RedNifre> Thinking about it now, one sandbox per package might actually be cleaner anyways... hm... (Please correcty me if I'm wrong, this is the first time I try out sandboxes)
08:03:09 <Narfinger> still trying to handle my haskell project
08:03:19 <mm_freak> Narfinger: also make sure you use a recent GHC (≥ 7.8), because it actually allows you to use the underscore syntax =)
08:03:38 <mm_freak> Narfinger: if you type "f = _x", then GHC will produce a type error that tells you the type of _x and the types of all local variables in scope
08:03:40 <Narfinger> underscore syntax?
08:03:43 <panther__> hey
08:03:46 <Narfinger> oh
08:04:04 <panther__> i have a question
08:04:51 <panther__> and i am a haskell newbi
08:04:55 <wombawomba> mm_freak: do you mean f :: forall b. (b -> A) -> [b] -> [[b]]? if so: duh, why didn't I think of that?
08:04:58 <mm_freak> panther__: hello there, just ask
08:04:59 <panther__> with an e
08:05:07 <panther__> ok. hold on
08:05:20 <mm_freak> wombawomba: =)
08:05:26 <wombawomba> thanks :)
08:05:31 <mm_freak> you're welcome
08:05:52 <panther__> http://lpaste.net/3182275083607474176
08:06:25 <mm_freak> panther__: are you using tabs for indentation?
08:06:33 <panther__> yeah. i think
08:06:38 <panther__> sorry it's a bit crazy
08:06:46 <mm_freak> panther__: it's highly recommended to use spaces only with haskell
08:07:01 <panther__> ghc spits out terminalapplication.hs:11:33: parse error on input `if'
08:07:18 <mm_freak> panther__: you need to choose
08:07:26 <panther__> spaces
08:07:27 <mm_freak> panther__: either you use layout-do and write no {}
08:07:40 <mm_freak> panther__: or you use braces-do and write semicolons everywhere
08:07:45 <mm_freak> do { a; b; c }
08:07:52 <mm_freak> even if you put it on the next line
08:07:59 <mm_freak> the braces variant is indentation-insensitive
08:08:02 <panther__> but i prefer do { a; b; c }
08:08:14 <panther__> so wait, what are you trying to say
08:08:27 <mm_freak> panther__: while i recommend getting used to the layout style, it's up to you, but then you need to be consistent with your semicolons
08:08:46 <panther__> so you are saying i need to put a semicolon on ALL lines
08:08:48 <mm_freak> in other words:  args <- E.getArgs;  -- note the semicolon
08:08:53 <panther__> oh
08:09:02 <panther__> oh duh
08:09:02 <Narfinger> btw. is there a way for ghci do load as much of the file as it can and then give me the interactive prombt?
08:09:21 <mm_freak> Narfinger: you can turn type errors into run-time errors:  -fdefer-type-errors
08:09:27 <mm_freak> (i think that's the name)
08:09:41 <Narfinger> ah thanks
08:09:44 <geekosaur> Narfinger, not fully. defer type errors eists as just mentioned, there is some talk of being able to defer more errors in the future
08:09:53 <Narfinger> that is really helpful
08:10:06 <geekosaur> ugh spammer
08:10:08 --- mode: ChanServ set +o geekosaur
08:10:10 <mm_freak> Narfinger: of course it can only defer when it can parse the file, so syntax errors will still cause loading to fail
08:10:14 --- mode: geekosaur set +b *!*@77.Red-2-138-167.dynamicIP.rima-tde.net
08:10:14 --- kick: cirnetus was kicked by geekosaur (cirnetus)
08:10:31 --- mode: geekosaur set -o geekosaur
08:10:33 <babu`> On MacOS Yosemite, I un-installed haskell and reinstalled it. cabal update works fine. But cabal install alex or any cabal install says "cabal: No sandbox exists at /Users/babu/.cabal-sandbox". I am not using a sandbox and I have never encountered this error before. I tried the latest haskell-platforms as well as install via brew.
08:11:09 <mm_freak> babu`: just a guess, but it sounds like you have a sandbox configuration file lying around somewhere
08:11:13 <geekosaur> babu`, check for a shell alias or function, it sounds like something is forcing --require-sandbox
08:11:57 <geekosaur> "type cabal" might give you a hint (it should say the full path to cabal, or it will say that it's an alias or a function or something)
08:13:06 <babu`> which cabal => /usr/bin/cabal
08:13:09 <babu`> cabal ==> cabal: no command given (try --help)
08:13:48 <geekosaur> then I must agree with mm_freak that it's finding a sandbox config somewhere
08:14:24 <mm_freak> babu`: look for a cabal.sandbox.config file somewhere in the path to the current directory
08:14:55 <mm_freak> /Users/babu/x/y/z, /Users/babu/x/y, /Users/babu/x, etc.
08:15:19 <mm_freak> babu`: if it's there and you're sure you didn't edit it, you can simply delete it
08:15:48 <babu`> I did a find and found ~/cabal.sandbox.config. I will remove it.
08:16:37 <babu`> mm_freak, geekosaur, thanks.
08:19:05 <panther__> hey i am back
08:19:50 <panther__> i want to add an operation to my little application
08:20:04 <hexagoxel_> RedNifre: `cabal build` does not install dependencies; yes, sandbox is not searched for in parents; sharing sandboxes is only really necessary if you need to conserve space / want to avoid duplicate installs and make sense if the packages are closely related
08:20:30 <panther__> that lets you read the log
08:20:53 <lpaste> RedNifre pasted “How to run cabal configure?” at http://lpaste.net/117746
08:21:07 <panther__> so i have a function readLog. Should readLog :: IO String
08:21:43 <RedNifre> Why is cabal build telling me I need to run cabal configure first even though I just did?
08:22:05 <RedNifre> I mean this one, I don't understand what it wants me to do: http://lpaste.net/117746
08:22:16 <hexagoxel_> because `cabal configure` did not work without the dependencies installed
08:22:19 <geekosaur> you have two versions of the Cabal library installed and it's using a different one presumably because the cabal configure installed it
08:23:05 <hexagoxel_> RedNifre: `cabal install --only-dependencies`
08:23:15 <geekosaur> I think you're being bitten by cabal wanting the latest versions of things, which is actually a bad idea in general and a *realy* bad idea right now (the latest versions of many libraries will only work correctly with the upcoming ghc 7.10)
08:23:18 <RedNifre> Why did "cabal configure" not work without the dependencies? I thought the point of cabal configure was to create a build plan that is then used by cabal build?
08:23:56 <RedNifre> How can I check which versions of cabal I have? I know there's one in /usr... but I think I'm using the one in my home/.cabal/bin ... hm...
08:23:59 <hexagoxel_> build plan for the current pacakge, not the dependencies
08:24:40 <mm_freak> panther__: as a first approximation yes, since your log file is fixed
08:25:30 <panther__> but when i put it into my main do block, ghc tells me that it is expecting an IO ()
08:25:41 <panther__> i will copy my code again
08:25:41 * hackagebot servant-docs 0.3 - generate API docs for your servant webservice  http://hackage.haskell.org/package/servant-docs-0.3 (AlpMestanogullari)
08:25:46 <RedNifre> "which cabal" => "/home/michael/.cabal/bin/cabal", which is at the beginning of my path. So how could it switch back to the one in /usr... when doing cabal configure?
08:26:36 <panther__> http://lpaste.net/3182275083607474176
08:26:43 <RedNifre> hexagoxel_ What is a "build plan for the current package" if it doesn't include fetching the dependencies? What else is there to plan?
08:28:08 <panther__> so the solution must be to take the IO String from readFile and convert it into a string, then putStrLn the result
08:28:15 <hexagoxel_> what to build, in what order, what to link, what flags to give preprocessor, what to write in the paths module
08:29:11 <geekosaur> panther__, you should probably include the full error message, but my guess is that you are calling readLog without anything to receive the result and it's telling you that it's going to discard the result
08:29:30 <hexagoxel_> when you do cabal configure --enable-tests, it builds tests for current package, for example.
08:29:37 <geekosaur> because, being "readLog" and not "something <- readLog", you are calling a String -> IO String in a place that expects an IO ()
08:29:48 <hexagoxel_> also, you can configure to use different compiler (or compiler version)
08:30:11 <geekosaur> (note that simply swapping that in will *also* fail because it must be followed by something that produces an IO ())
08:30:17 <panther__> http://lpaste.net/3182275083607474176
08:30:59 <hexagoxel_> RedNifre: i doubt switching to older cabal version would improve your situation
08:31:10 <mm_freak> panther__: you're reading the log, but you're not actually doing anything with the result
08:31:20 <panther__> oh
08:31:33 <panther__> hold on. i think i might have gotten this
08:31:51 <RedNifre> hexagoxel_ I don't want to switch to an older cabal version, why did you assume that?
08:32:37 <hexagoxel_> RedNifre: the cabal installed in ~/.cabal/bin is usually newer than the one installed on the system
08:32:45 <mm_freak> panther__: btw, did you learn about the `case` construct?
08:32:59 <RedNifre> Yes, that's why I put that one at the beginning of the path.
08:33:02 <matematikaadit> panther__: you're readLog function was the problem.
08:33:13 <panther__> solved
08:33:36 <panther__> my fix: put readFile in a do block and on the next line putStrLn the result
08:33:44 <RedNifre> As I understand it, it wasn't really using the old system one, the "cabal build" complained about the old one because "cabal configure" did not succeed because I didn't install --only-dependencies first.
08:34:05 <mm_freak> panther__: yes, now learn 'case'…  it will make your code much simpler and a lot more beautiful =)
08:34:31 <panther__> you mean case expressions? i already know them
08:34:58 <hexagoxel_> "complained about the old one"?
08:35:13 <mm_freak> panther__: then use it =)
08:35:13 <RedNifre> hexagoxel_ yes, here: http://lpaste.net/117746
08:35:31 <mm_freak> panther__: task:  write the same program without using 'head' and (==)
08:35:41 * hackagebot hsdev 0.1.3.1 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  http://hackage.haskell.org/package/hsdev-0.1.3.1 (AlexandrRuchkin)
08:35:49 <panther__> sure
08:36:05 <panther__> i thought case expressions could only pattern match
08:36:26 <mm_freak> panther__: you pattern-match all the time in haskell
08:36:29 <RedNifre> panther__ there's a GHC extension that allows more complicated matches I think.
08:36:35 <mm_freak> panther__: in fact you're pattern-matching all the time
08:36:48 <mm_freak> uhm
08:36:51 <mm_freak> s/all the time/right now/
08:37:11 <mm_freak> it's just buried in the horrible 'head' function and the unfortunate (==) function =)
08:37:26 <hexagoxel_> RedNifre: again, i doubt using old cabal is the right path. just install dependencies. (but you could call configure with old one, by fully qualifying the executable, i.e. `/usr/cabal configure`)
08:37:28 <panther__> yeah i know that
08:37:40 <panther__> yes i hate head
08:38:06 <panther__> so you are saying i should embed case expressions
08:38:26 <lpaste> matematikaadit revised “envionment”: “changed if-then-else into case-of” at http://lpaste.net/3182275083607474176
08:38:37 <mm_freak> panther__: yes
08:38:38 <RedNifre> hexagoxel_ again, I don't want to use the old cabal and don't understand what makes you think I would want to. I'm already installing the dependencies already, using `cabal install --dependencies-only` as you suggested.
08:38:54 <mm_freak> panther__: just try it out…  also trust me:  try using layout style
08:39:20 <mm_freak> it makes your code far shorter and less noisy…  once you get used to it, it's easier to read
08:39:54 <matematikaadit> panther__: it should be something like http://lpaste.net/3182275083607474176
08:39:59 <hexagoxel_> RedNifre: oh indeed, i complete misread what you wrote, sorry
08:40:48 <mm_freak> matematikaadit: you're not helping by doing their homework
08:41:01 <mm_freak> panther__: please don't open matematikaadit's link, until you have tried yourself
08:41:32 <matematikaadit> I should put [spoiler] tag there :D
08:41:49 <hexagoxel_> RedNifre: you probably get the message because the cabal in ~/.cabal/bin is 1.20.0.3, and the system-installed one is 1.16.0. both are used when you use `build` or `configure`
08:41:57 <hexagoxel_> ..
08:42:01 <hexagoxel_> the former is used for both
08:42:24 <panther__> it's getting pissed off because of the catch-all pattern
08:44:07 <panther__> no
08:44:10 <panther__> not that
08:44:31 <panther__> ok. got it
08:44:33 <hexagoxel_> let me rephrase: for both `configure` and `build`, the 1.20.0.3 version was used, but only `build` complained.
08:45:27 <panther__> i haven't been introduced to the Monad type class so i do not know how to use the bind function
08:45:39 <hexagoxel_> because `build` depends on some intermediate files generated by old version, while `configure` does not
08:45:42 * hackagebot servant-jquery 0.2.2 - Automatically derive (jquery) javascript functions to query servant webservices  http://hackage.haskell.org/package/servant-jquery-0.2.2 (AlpMestanogullari)
08:45:48 <panther__> also, i didn't know you could pattern match with <-
08:45:51 <mm_freak> panther__: don't bother for now…  you're using it implicitly
08:45:56 <panther__> here's what i did
08:46:12 <mm_freak> panther__: the (<-) pattern matematikaadit is using is just 'head' in disguise
08:47:26 <panther__> http://lpaste.net/117750
08:47:37 <panther__> yes i know how to implement head!
08:47:52 <mm_freak> panther__: well done
08:47:55 <mm_freak> now merge the cases
08:48:01 <panther__> ?
08:48:04 <mm_freak> you don't need nested case statements there =)
08:48:22 <panther__> well i didn't know you could pattern match with <-
08:48:28 <mm_freak> panther__: don't
08:48:32 <RedNifre> hexagoxel_ why would both be used when using build or configure?
08:48:56 <mm_freak> panther__: your `<-` pattern match is fine (you're pattern-matching there, but your pattern is universal, which is correct in this case)
08:48:58 <hexagoxel_> they don't, ignore that sentence :D
08:49:19 <mm_freak> panther__: case args of "wlog":_ -> …
08:49:40 <panther__> oh
08:49:43 <mm_freak> you don't need to deconstruct layer by layer…  you can deconstruct as many layers as you like in one go
08:50:12 <panther__> right
08:50:42 * hackagebot servant-pandoc 0.1.0.2 - Use Pandoc to render servant API documentation  http://hackage.haskell.org/package/servant-pandoc-0.1.0.2 (mpickering)
08:50:53 <panther__> also, can appendlog initialize a file
08:50:55 <RedNifre> hexagoxel_ ah, I guess we agree then. Now that the dependencies finished installing, both configure and build just worked.
08:51:44 <mm_freak> panther__: "initialise" in what sense?
08:51:59 <panther__> can it create the file from scratch
08:52:25 <mm_freak> panther__: appendFile creates an empty file if it doesn't already exist
08:52:31 <panther__> oh
08:53:26 <RedNifre> What is a "hidden package"?
08:53:42 <mm_freak> RedNifre: literally an installed, but hidden from view package
08:53:53 <mm_freak> RedNifre: you can hide and unhide packages with ghc-pkg
08:54:05 <RedNifre> Why would a package be hidden?
08:54:36 <hexagoxel_> in the context of writing cabal packages, it is a dependency that is installed but not explicitly written in build-depends field
08:54:36 <mm_freak> RedNifre: when you build using cabal, you need to specify all dependencies
08:55:05 <mm_freak> all direct ones that is, i.e. those from which you import modules
08:55:57 <RedNifre> So "hidden" means "According to your cabal file, this package is completely unrelated to your project, but you might be wrong and might want to add it"?
08:56:37 <RedNifre> "... and I just so happen to already have it installed, aren't you lucky?"
08:56:45 <panther__> i am back. sorry to keep bothering you over and over again
08:56:47 <mm_freak> RedNifre: that's the usual interpretation =)
08:57:02 <mm_freak> panther__: no worries =)
08:57:17 <panther__> but when i read my log everything is smooshed into one line
08:57:41 <mm_freak> panther__: appendFile does not automatically add an '\n' at the end of the string
08:57:47 <panther__> so i am trying to figure out how to put the newline character and the end of the string that says "Log initialized"
08:57:51 <panther__> exactly
08:58:05 <mm_freak> panther__: strings are really lists of Char
08:58:08 <mm_freak> type String = [Char]
08:58:09 <panther__> Can i just put "Log initialized \n"
08:58:12 <panther__> i know that
08:58:14 <mm_freak> now see this function:
08:58:20 <mm_freak> :t (++)
08:58:21 <lambdabot> [a] -> [a] -> [a]
08:58:28 <mm_freak> > "abc" ++ "def"
08:58:29 <lambdabot>  "abcdef"
08:58:32 <panther__> i know that
08:58:47 <panther__> i tried "Log initialized" ++ '\n'
08:58:54 <mm_freak> '\n' :: Char
08:58:58 <mm_freak> "\n" :: [Char]
08:59:06 <panther__> o
08:59:14 <panther__> oops
08:59:34 <panther__> sorry that was a total douchebag move
08:59:43 <panther__> '\n' instead of "\n"
09:00:08 <mm_freak> i'm not sure why you keep apologising all the time…  you're a beginner =)
09:00:18 <nitrix> Hi. As much as I like haskell, I seem to always it portability issues when compiling my code on another machine (especially ubuntu or debian, that uses older GHC versions).
09:00:40 <panther__> i am actually not THAT much of a newbie
09:00:49 <nitrix> I find it surprising that the _compiler_ version creates so much problem. Isn't Haskell standardized a long time ago?
09:01:12 <panther__> i reached chapter 13 in Learn You a Haskell for Great Good
09:01:17 <panther__> i LOVE that book
09:01:18 <nitrix> I'm not using any external dependencies, it seems that I have problems with Prelude.
09:01:21 <mm_freak> nitrix: as a rule of thumb:  keep your GHC up to date, at least to the platform version, because this community quickly adopts new technologies in the form of extensions
09:01:35 <benzrf> panther__: lyah is pedagogically unsound!!!
09:01:36 <RedNifre> Doesn't GHC have all those nice language extensions that don't work in other compilers?
09:01:44 <panther__> what
09:01:51 <nitrix> I'm not using GHC extensions.
09:01:57 <panther__> sure, some of it is cut down
09:02:00 <mm_freak> nitrix: but the packages you use probably do =)
09:02:01 <benzrf> panther__: have you ever read the instruction manual for a board game and then been unable to see the big picture
09:02:11 <benzrf> panther__: and then you have to play it 5 times before it clicks
09:02:15 <EvanR> RedNifre: yeah, but who uses the other compilers? ;)
09:02:18 <panther__> no
09:02:24 <benzrf> panther__: inconceivabl
09:02:33 <RedNifre> nitrix How could you not use language extensions?
09:02:36 <panther__> wait i don't get your question
09:02:41 <panther__> i am not sure
09:02:45 <benzrf> panther__: well, not necessarily a board game
09:02:49 <panther__> yeah
09:02:52 <benzrf> any kind of game really
09:02:53 <panther__> sure..
09:02:59 <benzrf> panther__: that's the problem with lyah
09:03:12 <panther__> oh? it just shows you the "big picture"
09:03:13 <mm_freak> nitrix: if any package in your dependency tree uses, for example, the MonadComprehensions extension, then you will need a recent GHC
09:03:22 <RedNifre> OTOH, maybe I give in to GHC's "Your code doesn't work the way you wrote it, but if you would just add this little extension it would be fine ;)" too easily...
09:03:33 <benzrf> i read lyah and enjoyed it, too
09:03:47 <panther__> it's super light-hearted
09:03:48 <benzrf> its only in hindsight that i realize it wasnt very good at actually getting me to understand things
09:03:51 <nitrix> mm_freak: My only dependency is HFuse.
09:03:59 <benzrf> there's nothing wrong with its style
09:04:01 <panther__> sure, it is cut down
09:04:07 <benzrf> it's not about being cut down
09:04:12 <panther__> what is it then
09:04:30 <benzrf> it's just not effective at getting you to really grasp how to think about haskell
09:04:37 <panther__> oh!
09:04:40 <nitrix> HFuse >> Dependenciesbase (==4.*), bytestring, unix
09:04:45 <panther__> i can side with you on that
09:04:46 <nitrix> base, bytestring and unix.
09:04:57 <nitrix> That should be fairly portable... and yet :(
09:05:01 <mm_freak> nitrix: not sure, but that one seems to be fine with GHC 7.6 at least
09:05:13 <mm_freak> nitrix: but as soon as you get any older than that you're introducing yourself to a world of hurt
09:05:23 <nitrix> mm_freak: I think ubuntu had 7.3 or 7.4.
09:05:32 <nitrix> But still, I don't grasp how that's possible.
09:05:42 * hackagebot faker 0.0.0.1 - Pure Haskell library for generating fake data  http://hackage.haskell.org/package/faker-0.0.0.1 (gazay)
09:05:44 <mm_freak> i wouldn't expect much to build with those anymore
09:06:03 <panther__> ok, i see. nice talking with you, benzrf
09:06:03 <nitrix> So Haskell is essentially at the mercy of GHC?
09:06:05 <mm_freak> nitrix: it's the way this community works…  we adopt new and even experimental technologies very quickly
09:06:15 <mm_freak> nitrix: and GHC delivers them mostly
09:06:27 <mm_freak> so yes, we pretty much depend on GHC in practice
09:06:53 <nitrix> mm_freak: The problem is, I love haskell. I couldn't find anything close to it, but it's not stable. I want to write something that I can ship and will just work everywhere.
09:07:58 <nitrix> I wrote the application in C and the complexity was just overwhelming, and I'm kind of giving up. I miss functional programming.
09:08:33 <mm_freak> nitrix: don't worry about it too much…  one consequence of using haskell is that you will need to keep your GHC up to date, and from time to time you may have to do some minor API adjustments
09:08:37 <nitrix> Backwards compatibility should be #1 concern with any language design.
09:08:44 <mm_freak> nitrix: i disagree
09:08:46 <RedNifre> I disagree
09:09:00 <RedNifre> Do you want to have portable binaries or portable code? (or both)?
09:09:13 <nitrix> RedNifre: Portable code.
09:09:17 <RedNifre> Why?
09:09:23 <mm_freak> nitrix: backward-compatibility is what makes other languages carry legacy crap around for decades
09:09:43 <nitrix> The binaries are generated from the code, so as long as the code's portable, the translation can be performed however it wants for the target platform.
09:09:47 <benzrf> nitrix++
09:10:18 <SharpGAF> nitrix: It depends on the language.
09:10:21 <mm_freak> nitrix: what really helps with reproducibility is using nix along with your usual haskell toolchain
09:10:28 <mm_freak> that's what i do in production
09:10:34 <nitrix> mm_freak: The legacy crap is what ensures you write a program once and that it'll work forever.
09:10:52 <nitrix> I don't have time to maintain everything I write. If it works, it should keep working.
09:10:56 <creichert> I use plain Debian from ghc 7.4-7.8 and rarely see portability issues for the targeted platforms
09:11:00 <mm_freak> nitrix: i don't mind updating my code from time to time
09:11:09 <mm_freak> nitrix: on the bottom line i save time by having a clean environment
09:11:11 <SharpGAF> nitrix: Even C and Java have had minor backwards incompatible changes over the years.
09:11:18 <creichert> my experience is that my apps _do_ keep working
09:11:25 <SharpGAF> nitrix: Relational databases like PostgreSQL have support windows.
09:11:38 <panther__> thank you for your help, mm_freak, and whoever else helped me
09:11:38 <RedNifre> sharpgaf those are negligible though.
09:11:47 <mm_freak> panther__: you're welcome
09:11:59 <RedNifre> I agree that it is nice that, say, a Java jar works for all eternity
09:12:16 <SharpGAF> Sure, I'm just saying, taking a hard stance on backwards compatibility is counterproductive IMO.  What is important is having a supported upgrade plan.
09:12:23 <mm_freak> it really depends on the features you expect from your language and ecosystem
09:12:24 <SharpGAF> And making your intentions clear well in advance.
09:12:28 <RedNifre> But I don't think you can have backwards compatibility AND a fancy modern language at the same time.
09:12:32 <creichert> it's a cost/benefit issue. if i write in haskell I am much more productive and even if i have to tweak an extension or compile flag, I still spend significantly less time than writing the app in another language
09:12:37 <mm_freak> i give much higher priority to productivity and correctness
09:12:47 <nitrix> Is there something closely related to haskell that would be worth trying and wouldn't have the same portability/stability short-comings?
09:12:51 <creichert> mm_freak: exactly
09:12:59 <mm_freak> which is exactly what haskell gives me at the expense that i might have to remove legacy from my own code from time to time…  usually the result is nicer than before anyway
09:13:00 <RedNifre> I think it's one of the principles of Haskell that "fancy and modern" is valued over "doesn't break"
09:13:08 <creichert> nitrix: are you referencing any specific issue your having? didn't see one
09:13:09 <RedNifre> nitrix Erlang comes to mind
09:13:17 <SharpGAF> Erlang isn't very much like Haskell.
09:13:22 <nitrix> creichert: It's all in the backlog.
09:13:22 <mm_freak> nitrix: haskell-with-nix
09:13:36 <RedNifre> Erlang is as far as I know the only functional language that is considered production ready.
09:13:41 <RedNifre> (haven't tried it though)
09:14:04 <EvanR> functional*
09:14:09 <SharpGAF> That's a weird statement.
09:14:15 <mm_freak> RedNifre: it depends on who you ask…  haskell is now much more widely used in production that it was five years ago
09:14:17 <nitrix> Learn You Some Erlang For Great Good! AH!
09:14:18 <SharpGAF> What does production-ready mean?
09:14:22 <nitrix> They even have a tutorial :)
09:14:22 <sivteck> there's ocaml, F#, scala, clojure etc..
09:14:40 <RedNifre> There's also Scala, which is "every language combined into one" and runs on the JVM, interoperates with Java and even has advanced features like currying (haven't tried that one either, but I consider it at the moment)
09:14:58 <EvanR> production-ready often depends on peoples attitudes toward it, in addition to bug-free-ness, workflow-exists, etc
09:15:01 <SharpGAF> It's not clear to me that Scala has absolute backwards compatibility either.  e.g. inference changes.
09:15:19 <EvanR> RedNifre: i invite you to learn some haskell, then go try scala ;)
09:15:21 <mm_freak> scala is an ugly brown mixture of java syntax, haskell syntax and a haskell-like type system…  it combines all the bad features of said languages into one language =)
09:15:43 * hackagebot faker 0.0.0.2 - Pure Haskell library for generating fake data  http://hackage.haskell.org/package/faker-0.0.0.2 (gazay)
09:15:47 <benzrf> https://twitter.com/sellout/status/488713447748554754
09:15:59 <SharpGAF> Haha, saw that.
09:16:29 <mm_freak> anyway, erlang is a good language, but it doesn't quite reach haskell's elegance
09:16:43 <mm_freak> but it does have some run-time features that haskell lacks…  for example built-in replacement of components
09:17:18 <SharpGAF> Erlang is a different language that is extremely specialized for its niche.  I don't think it's really a general Haskell replacement.
09:17:37 <EvanR> theres cloud haskell which steals a lot from erlang
09:18:09 <SharpGAF> It's not enough to just steal from Erlang, you need to grab OTP along with it
09:18:16 <hiptobecubic> erlang doesn't even have arrays
09:18:21 <EvanR> otp?
09:18:37 <hiptobecubic> kind of a framework for building robust distributed apps
09:18:41 <nitrix> Arrays are a fractal of bad design, in my opinion.
09:18:56 <mm_freak> arrays are fine…  you're using them all the time
09:19:06 <mm_freak> they are just not appropriate for everything
09:19:09 <hiptobecubic> nitrix, sure. but some of us want our programs to eventually terminate.
09:19:26 <SharpGAF> Arrays are a concession that programs run on computers.
09:19:31 <nitrix> How does arrays relates to the halting problem?
09:19:32 <mm_freak> here is my favourite array type:  type Array = (->)
09:19:46 <quchen> :-)
09:19:46 <EvanR> haha
09:20:22 <hiptobecubic> nitrix, they greatly expand the class of problems that we can check before we die.
09:21:05 <nitrix> And without arrays, you don't even have to check for these problems. Woot.
09:21:26 <hiptobecubic> without computers, you don't even have to be aware of the problem at all!
09:22:08 <EvanR> for erlangs purpose and lack of type safety, arrays are probably a good idea to drop
09:22:10 <mm_freak> hiptobecubic: are you using [] and both foldr and unfoldr (and their derivatives)?
09:22:33 <hiptobecubic> mm_freak, in general? Sure. Who isn't?
09:22:36 <mm_freak> hiptobecubic: in a total language that would be a type error ;)
09:23:22 <EvanR> unfoldr can be encoded as a coinductive type
09:23:29 <mm_freak> you can express foldr only for List and unfoldr only for Colist
09:23:51 <mm_freak> EvanR: yes, but you can't define both on the same type
09:23:59 <EvanR> fine with me ;)
09:24:09 <mm_freak> the point is:  totality is a concept that bears many subtle surprises that you aren't exposed to in haskell
09:24:22 <mm_freak> so it's easy to say, "i like totality", but it's not actually that easy to /be/ total =)
09:24:49 <quchen> Does anyone know how to interface C unions with c2hsc/hsc2hs properly?
09:25:05 <quchen> Or C unions in general, regardless of tooling
09:25:20 <EvanR> alternatively, use a different unfoldr that takes a terminating program
09:25:46 <EvanR> good luck proving termination ;)
09:25:52 <mm_freak> EvanR: unfoldr always takes a total function in a total language, but it is itself coinductive
09:26:21 <mm_freak> EvanR: unfoldr (const Nothing) ()  -- invalid for List, because you can't define unfoldr in the first place
09:26:22 <EvanR> no, i meant one which, when iterated, eventually returns Nothing
09:26:31 <mm_freak> have fun proving that
09:26:33 <mm_freak> =)
09:26:36 <EvanR> well yeah
09:27:19 <EvanR> its easy once youre in, like if your unfold is over an existing inductive type
09:27:24 <mm_freak> in any case, there are always ways to encode it totally, but total code is very different in style from haskell code
09:28:00 <mm_freak> i'd go as far as to say that only a very small percentage of haskell code written even by experienced haskellers is actually total
09:28:08 <mm_freak> note for example that 'filter' is ill-typed for Colist
09:28:23 <mm_freak> and you can't make a total cofilter either
09:28:53 <EvanR> in practice, you may get away with saying informally that your code does not accept infinite lists
09:29:06 <EvanR> and no bottoms, etc
09:29:20 <mm_freak> EvanR: most lists aren't static
09:29:26 <mm_freak> consider 'getLine'
09:29:35 <EvanR> : getLine
09:29:38 <EvanR> :t getLine
09:29:38 <lambdabot> IO String
09:29:41 <EvanR> what about it
09:29:44 <mm_freak> getLine :: IO Costring
09:29:56 <mm_freak> in a total language that is
09:29:58 <EvanR> very skeptical mm_freak
09:30:14 <EvanR> in my total language i would not do that to you in a million years
09:30:20 <mm_freak> ./myprogram < /dev/zero
09:30:22 <EvanR> getContents isnt just a colist of chars
09:30:29 <EvanR> its lazy io
09:31:29 <EvanR> getLine, hGetLine is just a bad idea for security and error recovery IRL, so why support it with more complex types
09:31:38 <mm_freak> EvanR: write a program in a total language that reads a file until EOF and then tells you the size
09:31:46 <mm_freak> no lazy I/O there
09:32:01 <EvanR> you cant do that either, but thats a problem with IO
09:32:18 <mm_freak> is it?  /dev/zero seems like a completely reasonable file to me
09:33:04 <EvanR> yeah, you will never know if any IO command will ever return
09:33:23 <mm_freak> yet you need IO, otherwise you're just computing static values
09:33:24 <EvanR> freeze >> return "3"
09:33:33 <EvanR> its like asking for that to be "total"
09:33:43 <mm_freak> the point is that at any point where you interface with the outside world you're introducing codata
09:34:15 <EvanR> im saying codata might be a silly way to expose that, just like old haskells lazy list io
09:34:30 <EvanR> the real world isnt mathematical
09:34:34 <mm_freak> EvanR: either codata or co-IO
09:34:39 <RedNifre> Hm... when using sandboxes, will I ever use "ghci" again? Does "cabal repl" replace it completely?
09:34:55 <mm_freak> EvanR: on some level you will run into this issue, simply because the real world works that way
09:35:17 <mm_freak> RedNifre: cabal repl replaces it
09:35:26 <vour> Hey guys! I know it's kinda rude just to pop in for a question but I couldn't think of another place to get a quick and maybe even a logical ( :D) explanation. So, in the land of the wonderful IO, is it possible, to do a name<-getline in a guard?
09:35:32 <quchen> RedNifre: You mean the literal "ghci" command? I still use it for hacking around in projects sometimes, but most of the time cabal repl works better.
09:35:47 <sivteck> or cabal exec ghci
09:35:47 <mm_freak> vour: nope
09:35:54 <EvanR> yeah. heres one of my favorite attemps to dealing with this: http://lambda-the-ultimate.org/node/4525
09:35:57 <EvanR> mm_freak: ^
09:36:04 <sivteck> (if stuff is already installed in a sandbox)
09:36:10 <quchen> vour: There is no "popping in" here, you don't need to wait for silence to ask, we don't have a draw-a-number system. Just ask away :-)
09:36:18 <EvanR> in this paper, they use a total language to write the "IO code" but there is a layer which is not configured in the language, namely, how components are connected
09:37:13 <vour> hmm... but if I have a situation where I ask for some sort of input and regarding that input I have to decide if I need another one, how should I do that then?
09:37:22 <mm_freak> EvanR: sounds a lot like AFRP, except with richer types
09:37:49 <mm_freak> vour: then bind the input first and then use a guard
09:38:05 <mm_freak> vour: ln <- getLine;  case ln of …
09:38:05 <EvanR> im not familiar with afrp, but in there you have cycles between components?
09:38:18 <mm_freak> vour: in `…` you can use guards
09:38:27 <mm_freak> EvanR: yes
09:38:43 <EvanR> in a program using this "component based development" i think the idea is to not do that
09:38:50 <mm_freak> EvanR: it's basically generalised streaming…  a "signal function" in AFRP is a coinductive "time-framed" value
09:39:07 <EvanR> yeah this doesnt have any notion of time formalized
09:39:15 <vour> okey, kinda thought so, but couldn't really realise it, guess I'll have to look into it some more. Thanks alot :)
09:39:34 <mm_freak> EvanR: i'm just saying "time", because that's the common way you use it…  frames can be anything, as long as there is a sequence of them
09:39:52 <mm_freak> EvanR: in any case it is a way to move the coinductivity of the real world into one abstraction and leave it there
09:40:06 <quchen> vour: Something like this might be what you want. http://lpaste.net/117751
09:40:26 <mm_freak> EvanR: i didn't read it though…  i'm saying this because SFs form a category as well =)
09:41:33 <vour> okay but if I have several "if's", like in "if else" then I've been told to use guards but I really don't get how to give commands in them
09:42:05 <EvanR> seriously not seeing a good fit between coinductive data structure and "real world". maybe it is because in my mind you are guaranteed to produce the next piece.
09:42:24 <mm_freak> EvanR: that's what coinduction is about
09:42:39 <EvanR> in real world, you dont have any guarantee about anything
09:43:21 <mm_freak> true…  i guess that's a necessary evil you get by executing an IO program
09:43:57 <EvanR> by placing a suitable real-world-derived colist into an otherwise "provably terminating/producing" program you dont have any guarantee that anything will ever happen ever
09:47:05 <mm_freak> this is an interesting topic, but unfortunately IO is calling me right now, and that's guaranteed =)
09:47:12 <EvanR> this paper made me realize how total programming can be conceptually applied to interactive code which uses IO stuff. all the handlers definitely respond "eventually" to the caller, ideally instantly, which is the goal for web servers for example
09:47:44 <mm_freak> have a nice evening/day everybody
09:49:22 <benzrf> evnin
09:55:22 <siddhu> any way to do `takeWhile (/="") <$> (sequence . repeat) getLine` ?
09:55:44 * hackagebot repline 0.1.2.0 - Haskeline wrapper for GHCi-like REPL interfaces.  http://hackage.haskell.org/package/repline-0.1.2.0 (sdiehl)
09:56:25 <benzrf> siddhu: that way
09:56:32 <EvanR> in IO sequence . repeat will block forever
09:56:37 <benzrf> oh wait i see
09:56:50 <benzrf> siddhu: well, pipes
09:56:50 <benzrf> :)
09:57:34 <benzrf> siddhu: P.stdinLn >-> P.takeWhile (/="") :: Producer String IO () iirc
09:58:15 <hrumph> the compiler is complaining about   -->  deduces MP [a (.->.) b , a] b = True <-- with "Parse error in pattern: a". what am i doing wrong. Btw (.->.) is a constructor.
09:58:29 <siddhu> searching for pipes just led to this so answer: http://stackoverflow.com/questions/11650227/failure-to-produce-a-lazy-stream
09:58:41 <benzrf> hrumph: (.->.) cannot be a constructor
09:58:48 <siddhu> `sequence (takeWhile (/="") $ repeat getLine)`
09:58:51 <benzrf> hrumph: constructors must start with a :
09:59:08 <benzrf> siddhu:
09:59:10 <benzrf> @hackage pipes
09:59:11 <lambdabot> http://hackage.haskell.org/package/pipes
09:59:12 <hrumph> benzrf, that isn't correct....i used in an a data definition and it worked
09:59:18 <benzrf> hrumph: what the heck
09:59:31 <hrumph> ok anyway i'll swithc to : and see what happens
09:59:34 <benzrf> hrumph: paste your definition
10:00:36 <EvanR> siddhu: or you can create a combinator which means "take lines until a non-empty and do *this action* ... forever"
10:01:13 <geekosaur> in any case, [a (.->.) b , a] looks wrong to me, as (.->.) is in the wrong position to be a constructor given that it is parenthesized, and the first 'a' cannot be a variable
10:01:33 <EvanR> forever $ do x <- getLine; when (/= "" x) foo
10:01:36 <geekosaur> if you meant an infix constructor then leave off the parens; they convert it to prefix
10:02:15 <EvanR> foo :: IO ()
10:02:53 <benzrf> actually
10:03:36 <benzrf> does pipes have a combinator like `repeatP :: Monad m => m a -> Producer a m t'
10:03:57 <johnw> can't you just use forever + yield?
10:04:07 <EvanR> yield?
10:04:09 <EvanR> :t yield
10:04:10 <lambdabot> Not in scope: ‘yield’
10:04:11 <benzrf> repeatP m = forever $ lift m >>= yield
10:04:29 <johnw> ah
10:04:32 <EvanR> whats yield in ghc
10:04:41 <benzrf> EvanR: pipes
10:04:45 <EvanR> oh
10:04:50 <benzrf> 8D
10:04:50 <benzrf> EvanR: yield :: Monad m => a -> Producer a m ()
10:04:52 <johnw> it's not the yield from Control.Concurrent
10:04:56 <bgamari> johnw, John Wiegley I presume?
10:05:02 <johnw> yes, hi bgamari!
10:05:13 <bgamari> johnw, Hi!
10:05:19 <johnw> let's do a release for you
10:05:23 <bgamari> johnw, If it's not already too late, hold off for a bit
10:05:31 <johnw> ah, cool
10:05:33 <johnw> I haven't done it yet
10:05:38 <bgamari> johnw, there's actually another feature that should go in
10:05:41 <bgamari> johnw, great
10:06:06 <bgamari> johnw, I'll write up a patch now
10:06:31 <quchen> johnw: Sorry to bother you again, but unions are something I just can't understand. Are they not supported by bindings-dsl/hsc2hs? Do I have to write them manually? I've asked on StackOverflow as well, which provides a couple of examples of the issues I'm having. http://stackoverflow.com/questions/27767020/interfacing-c-unions-in-haskell-via-c2hsc-and-hsc2hs
10:06:43 <johnw> let me try
10:06:48 <benzrf> repeatP could be useful tho
10:07:15 <johnw> benzrf: PR it
10:07:58 <benzrf> stdinLn = repeatP getLine -- approximately!
10:08:33 <johnw> quchen: is <union foo> even legitimate syntax?
10:09:01 <quchen> johnw: I don't know, c2hsc gave me that
10:09:22 <johnw> ok, I see where c2hsc needs to be changed then
10:09:28 <siddhu> repeatP would be useful indeed.
10:09:31 <johnw> instead of just "getting the type name for the field"
10:09:44 <johnw> we should check to see if the type name needs to be recursed into, such as for member structs and unions
10:10:00 <johnw> quchen: do you want to make such a change yourself?  familiarity with c2hsc code might be a helpful thing for you
10:12:01 <quchen> johnw: I've got two problems then. A) is the one you mentioned: c2hsc doesn't support the proper translation. But B) how would I write the union manually in .hsc format?
10:12:19 <quchen> B) seems like a direct prerequisite for A).
10:12:21 <johnw> quchen: ok, on the second, let me check
10:12:40 <quchen> johnw: No hurries, I'm glad enough I caught you again live on IRC ;-)
10:12:40 <johnw> did you see https://github.com/jwiegley/bindings-dsl/wiki/TipsAndQuestions?
10:13:26 <quchen> johnw: Yes, but that example is struct-in-struct, which results in a longer product type in Haskell land. A union would be a (somewhat stupid) sum type, no?
10:13:49 <johnw> right
10:14:03 <quchen> When I applied this to a "union inside struct" I got a product data structure for the union, not a sum
10:14:18 <quchen> Basically the code didn't differentiate between "union" and "struct" there
10:14:28 <johnw> hmm.. this is odd
10:14:37 <johnw> so, I picked up maintenance of bindings-dsl after this was done
10:14:55 <quchen> Maybe I'm also misremembering things. I should probably double-check before wasting your time.
10:15:09 <johnw> even the example in this wiki page doesn't seem to be quite right as far as matching the memory layout of the original union
10:15:48 <quchen> Speaking of maintenance of bindings-dsl, do you know why #union_field is deprecated? It seems like it's doing something else than #field.
10:16:11 <quchen> (And the deprecation is hidden somewhere in the docs.)
10:16:23 <johnw> no
10:16:54 <johnw> you'd have to ask Maurício about that
10:17:04 <quchen> Is he on IRC?
10:17:05 <johnw> I'm pretty sure he'd be open to an email though
10:17:13 <johnw>  I don't think I've ever seen him here on IRC
10:17:39 <quchen> I've seen him answer StackOverflow questions, so maybe I should just wait a bit.
10:18:00 <johnw> he may not pay attention to questions about bindings-DSL anymore
10:18:10 <johnw>  since he told me he didn't really have time anymore to maintain it
10:20:14 <benzrf> siddhu: checkin out pipes? :3
10:20:35 <siddhu> benzrf: yes. pipes looks really flexible
10:20:44 <johnw> pipes is a very powerful abstraction
10:20:58 <johnw> benzrf will be happy that I don't use conduit anymore
10:21:06 <benzrf> u dont?
10:21:08 <benzrf> >:D
10:21:09 <johnw> nope
10:21:11 <johnw> i'm a pipes man now :)
10:21:15 <benzrf> mwahaha
10:23:27 <Welkin> why is that?
10:23:37 <Welkin> what is the difference between pipes and conduit?
10:23:42 <Welkin> they look identical to me
10:24:05 <johnw> there is a tradeoff to be made in both libraries, between simplicity of core structure and intuitiveness of the user interface
10:24:06 <benzrf> Welkin: they are...
10:24:06 <sivteck> Pipes.Internal breaks my head
10:24:10 <benzrf> ALTERNATIVES
10:24:21 <benzrf> so of course people get super up in arms about em
10:24:23 <benzrf> sivteck: aw
10:24:31 <benzrf> sivteck: it is really not that complicated actually
10:24:38 <benzrf> sivteck: do you grok the Proxy type
10:25:14 <sivteck> I haven't looked at pipes for some time. So no.
10:25:18 <johnw> sivteck: I wonder if this version of Proxy would help: https://github.com/jwiegley/notes/blob/master/PipesJ.hs
10:25:31 <johnw> it's isomorphic to the real pipes' Proxy, but it factors out the free monad
10:25:51 <sivteck> ok ty!
10:25:53 <benzrf> johnw: ooh neat
10:26:16 <johnw> gabriel says that such a simplification comes at a wrapping/unwrapping cost which is unfortunately not worth it
10:26:25 <benzrf> johnw: so what finally convinced you that pipes is Cleaner™
10:26:39 <johnw> benzrf: not working at fp complete anymore, mainly
10:26:53 <johnw> they use only conduit there, so getting excited about pipes would have been fruitless
10:26:59 <Welkin> Cleaner®
10:27:07 <Welkin> REGISTERED TRADEMARK
10:27:07 <benzrf> heh
10:27:16 <johnw> and I appreciate the mathematical clarity of pipes' abstraction more now, having written simple-conduit
10:27:25 <Welkin> I will sue you benzrf !
10:27:48 <quchen> Oh, you left FPComplete?
10:28:17 <Welkin> what does fpcomplete do?
10:28:24 <Welkin> what services do they provide?
10:28:25 <johnw> I did; they stopped putting as much effort into their IDE backend
10:28:27 <Welkin> besides the IDE
10:28:36 <johnw> it's really a backburner thing for them now
10:28:52 <benzrf> pfft
10:29:02 <johnw> and I was the "backend guy", so there wasn't much work for me suddenly
10:29:16 <quchen> That's unfortunate.
10:29:21 <johnw> now I do PL and systems research
10:29:27 <Welkin> johnw: I thought you wrote Coq in yur day job
10:29:29 <Welkin> your*
10:29:31 <johnw> I do now
10:29:31 <quchen> In academics?
10:29:33 <johnw> at my new job
10:29:38 <johnw> I work with academics, but I'm not in academia
10:29:47 <johnw> BAE Systems <-- DARPA contractor
10:29:48 <Welkin> *yet*
10:29:48 <vanila> could you talk a bit about how to use coq/what for?
10:29:52 <vanila> sounds very interesting
10:29:56 <johnw> vanila: https://github.com/jwiegley/linearscan
10:30:02 <benzrf> vanila: well, you can use it to verify programs, for one
10:30:02 <johnw> there's an experience report document in the 'doc' sub-directory now
10:30:13 <vanila> thanks :)
10:30:21 <johnw> coq is great for building verified libraries
10:30:22 <benzrf> vanila: have you seen seL4? it uses isabelle rather than coq but the idea is the same
10:30:42 <johnw> as for fully verified software systems, I'm not sold on it yet -- it's get too complex really fast
10:30:55 <johnw> but for a provably correct hashmap implementation, for example, it would be perfect
10:31:02 <vanila> cool!
10:32:08 <johnw> you can get some of this goodness for Haskell with liquidhaskell, which I'm very curious about now
10:33:30 <vanila> yeah I do wonder what the strengths/weakenesses are of dependent types vs the SMT approach
10:33:34 <benzrf> vanila: coq is also just fun 8D
10:33:53 <mzero> I'm looking for an FRP style lib that *doesn't* need to be run in IO... anyone know one?
10:33:58 <johnw> I've found that fully dependent types can sometimes tie you into knots
10:34:19 <benzrf> vanila: mathematical proofs + programming = something like a puzzle game
10:34:22 <johnw> hmm.. pure FRP... how would it handle time?
10:34:33 <benzrf> johnw: does it need to?
10:34:40 <johnw> benzrf: does it need to handle time?
10:34:44 <mzero> well - like Reactive Bannana - which donesn't deal in time
10:34:45 <johnw> or does it need to tie you into knots?
10:34:47 <agibiansky> johnw: I would be very interested in a similar writeup for liquidhaskell... I tried to get into it and write a largeish verified data structure, but found that the implementation was not quite up to par for larger work – a lot of user interface issues that made it hard to deal with things
10:35:02 <johnw> agibiansky: ah, that's very good to know!
10:35:09 <benzrf> mzero: why not just use the denotational semantics directly ( ͡° ͜ʖ ͡°)
10:35:19 <johnw> at work this month we're going to have a "formal methods summit", to talk about state of the art, so that's an interesting data point
10:35:27 <benzrf> type Behavior a = Time -> a
10:35:27 <Welkin> benzrf: you and your arabic faces
10:35:31 <mzero> well - I want to not have to roll my own - I'd like a nice set of combintors
10:35:48 <agibiansky> johnw: That said, it seemed very promising and they were actively taking bug reports and stuff, so please don't take my somewhat mediocre experience as a reason not to try it out :) It may have gotten a lot better on the UI front in the past few months, it seemed like it was a somewhat high priority for them
10:35:51 <Zemyla> I'm trying to write an extremely simple regex library for parsec, one that doesn't even have backreferences.
10:35:54 <benzrf> newtype Event a = Event [(Time, a)]
10:36:03 <benzrf> mzero: look, i can do it in 5 minutes
10:36:15 <benzrf> @let type Time = Float
10:36:16 <mzero> essentially I want to compose a network full of event streams and behaviors and functions on them... and get a minimal   Event in to Event out
10:36:18 <lambdabot>  Defined.
10:36:21 <benzrf> @let type Behavior a = Time -> a
10:36:22 <lambdabot>  Defined.
10:36:22 <mzero> benzrf: no Time, please
10:36:29 <benzrf> mzero: then what's a behavior
10:36:43 <Zemyla> Just something to grab, say, [A-Za-z][A-Za-z0-9]* .
10:36:44 <mzero> well - what I want is Time to be abstract, like Event - so just a sequence of points
10:36:49 <benzrf> mzero: ok then
10:36:49 <EvanR> its possible to drop the behavior and only have event reactions
10:36:49 <mzero> no actual Float
10:36:51 <benzrf> @undef
10:36:51 <lambdabot> Undefined.
10:36:58 <benzrf> @let Time = Integer -- :)
10:36:59 <lambdabot>  .L.hs:152:1: Not in scope: data constructor ‘Time’
10:36:59 <lambdabot>  
10:36:59 <lambdabot>  .L.hs:152:8: Not in scope: data constructor ‘Integer’
10:37:01 <benzrf> @let type Time = Integer -- :)
10:37:02 <lambdabot>  Defined.
10:37:10 <benzrf> @let type Behavior a = Time -> a
10:37:11 <lambdabot>  Defined.
10:37:29 <EvanR> i like the attitude "frp is so easy look" ;0
10:37:36 <benzrf> @let newtype Event a = Event {runEvent :: [(Time, a)]}
10:37:37 <lambdabot>  Defined.
10:37:58 <benzrf> @let instance Functor Event where fmap f = Event . map (second f) . runEvent
10:37:59 <lambdabot>  Defined.
10:38:07 <EvanR> you could have invented frp
10:38:21 <benzrf> mzero: then you can implement the combinators as literally the code snippets from reactive-banana :D
10:38:22 <EvanR> (unless you want it to actually work)
10:38:25 <drdo> Is there somewhere a function f to do this: f g [x,y,z,w] → [g x y, g y z, g z w]?
10:38:35 <mzero> hmmm... well.. there's a thought
10:38:47 <vanila> drdo: zipWith f list (tail list)
10:38:53 <benzrf> vanila++
10:38:55 <johnw> agibiansky: will keep that in mind
10:39:01 <drdo> vanila: oh, right :P
10:39:02 <benzrf> er, wait vanila
10:39:18 <benzrf> > zip [x, y, z, w] (tail [x, y, z, w])
10:39:19 <lambdabot>  [(x,y),(y,z),(z,w)]
10:39:24 <benzrf> oh nvm >.<
10:39:43 <mzero> hmmm... how does one deal with mapAccum?
10:40:12 <quchen> > let f g xs = zipWith g xs (tail xs) in f g [x,y,z,w] :: [Expr]
10:40:13 <lambdabot>  [g x y,g y z,g z w]
10:40:19 <mzero> I suppose I should read the source to Reacitve.Banana.Model
10:41:10 <Zemyla> Reactive Banana Model? The hell?
10:41:12 <benzrf> mzero: remind me the type?
10:41:51 <mzero> http://hackage.haskell.org/package/reactive-banana-0.8.0.4/docs/Reactive-Banana-Model.html
10:42:08 <mzero> acc -> Event t (acc -> (x, acc)) -> (Event t x, Behavior t acc)
10:43:23 <mzero> so - yes, I can see how to build it all up - I was hoping someone had a nice set of well thought out combinators for this sort of thing
10:44:36 <benzrf> mzero: ach
10:44:45 <jonsterling> carter: So am I doing the right thing if I set mtl >= 2 and transformers >= 3, and then require transformers-compat? Or something like that?
10:45:17 <siddhu> `:t P.stdinLn >-> P.takeWhile (/= "")` gives me `MonadIO m => Proxy a' a () String m ()`. I was expecting a producer instead.
10:46:06 <benzrf> siddhu: that /is/ a Producer
10:46:07 <benzrf> siddhu: well, a Producer'
10:46:41 <benzrf> siddhu: type Producer' a m r = forall x x'. Proxy x x' () a m r
10:47:01 <benzrf> siddhu: MonadIO m => Producer' String m () = MonadIO m => Proxy a' a () String m ()
10:47:10 <benzrf> siddhu: sorry :p
10:58:45 <eyebloom> Can anyone summarize what liquid types are?
10:59:59 <Ptival> ping gridaphobe
11:00:47 * hackagebot exp-pairs 0.1.1.0 - Linear programming over exponent pairs  http://hackage.haskell.org/package/exp-pairs-0.1.1.0 (Bodigrim)
11:01:00 <siddhu> With pipes, I'm guessing `P.stdinLn >-> P.takeWhile (/= "quit") >-> P.map (myFun . readFile)` gives me a list of objects. Any way to do `foldl (head x) `mappend` (tail x)`?
11:01:20 <siddhu> eyebloom: It's like dependent types, but uses a static type checker and is much simpler.
11:01:55 <siddhu> https://www.youtube.com/watch?v=vYh27zz9530 explains liquid types in haskell
11:02:20 <vanila> eyebloom, roughly I think that the type checking involves doing an interpretation of your program code to turn it into a logical formula - then it uses an SMT solver to try to prove the propositions you put in the types automatically
11:03:09 <siddhu> `types that adhere to certain predicates` is one way to think of it.
11:04:22 <eyebloom> I’ve always wondered why for example if I do a pattern match on a value of union type haskell doesn’t refine the type of the pattern matched value, to be one branch of the union (does this make sense?)
11:04:39 <vanila> union type?
11:05:09 <johnw> eyebloom:  what you're describing is almost exactly what GADTs do,  but I'm not clear because of the terminology you used
11:05:38 <eyebloom> A union type is like data myType = myType1 | myType2 | myType3
11:05:54 <eyebloom> So myType is the union of those three types
11:06:17 <eyebloom> this comes from the Pierce book.
11:07:07 <johnw> gotcha
11:07:10 <johnw> we call that a sum type, or an ADT
11:07:26 <eyebloom> Ah, my apologies
11:07:27 <johnw> now, what do you mean about "refine"?
11:07:44 <eyebloom> Say I do a case on a value : myType
11:07:55 <eyebloom> and I determine it to be myType1
11:08:26 <vanila> I thought of a union type like 'it's one of these types.. but you don't know which'
11:08:26 <eyebloom> the compiler should know that within that case, x can never be myType2
11:08:27 <vanila> sort of
11:08:42 <johnw> eyebloom: correct
11:08:47 <eyebloom> I think sum type is the correct term.
11:09:14 <johnw> in C++ we'd call it a tagged union or a variant type
11:09:29 <johnw> oh, no, we wouldn't
11:09:32 <johnw> it would just be an enum
11:09:37 <johnw> I'm thinking of something else by "union"
11:09:40 <quchen> johnw: Hmm, it seems that if I tread sum types as products "where I have to liberally insert 'undefined's on construction" the Storable instance makes sense. The pointer offsets seem correct (and overlap, as expected from a union). http://lpaste.net/117755
11:09:51 <eyebloom> johnw: I don’t think the compiler would complain if I tried to do another case on the same value I would get no complaint.
11:10:07 <johnw> eyebloom: well, myType2 is just a value, it's not a type
11:10:13 <johnw> so it would be a runtime thing, not a compile-time thing
11:10:18 <quchen> Although peek/poke are borked.
11:10:29 <johnw> eyebloom: try this instead... (one sec, writing code)
11:10:38 <vanila> but the sort of thing liquidhaskell will let you do is e.g.    if null list then "asdf" else bar list
11:10:49 <vanila> if bar has a special predicate saying it only takes non empty lists, this will typecheck ok
11:10:55 <vanila> whereas if you put bar in the other case it will fail
11:11:31 <eyebloom> vanilla: Right, that’s exactly what I want in haskell
11:11:50 <johnw> eyebloom: https://gist.github.com/84a153492d75b6d764e6
11:12:04 <johnw> that is doing what you expect, and happens at compile-time, because it involves types
11:12:19 <johnw> it gives an error on the use of "Baz" below
11:12:39 <johnw> at compile-time, that is
11:13:21 <eyebloom> But what if I pass x into another function
11:13:30 <johnw> quchen: I don't think you want to peek/poke twice for the second position
11:13:40 <johnw> just once should be sufficient, since the bit-patterns should be equal to C
11:13:51 <johnw> eyebloom: that function will need to accept either a Foo Int, or a Foo a
11:13:58 <johnw> but it cannot require a Foo Float
11:14:31 <johnw> basically, with GADTs, pattern matching yields information about type equalities
11:14:35 <quchen> johnw: Peeking twice should not be a problem though. Poking twice on the other hand is probably broken.
11:14:40 <johnw> right
11:15:35 <vanila> yeah but SMT is a pretty scary beast
11:15:54 <quchen> Going the "avoid peek/poke" route sounds a bit dangerous though.
11:16:00 <eyebloom> johnw: Ah
11:16:04 <quchen> I never expected unions to be this complicated haha
11:17:05 <vanila> you can't expect the computer to prove everything itself, and you don't really know how long itll takae etc..
11:17:14 <johnw> eyebloom: in yet other words: if you want to discriminate between values at compile-time using types, you'll need to use GADTs so that pattern matching yields information about your discriminee
11:17:34 <eyebloom> I see.
11:17:40 <vanila> so I guess that this stuff will be better for quite shallow properties about your programs, where you'd need full dependent types for deeper things?
11:17:40 <johnw> vanila: well, with liquidhaskell all predicates are decidable
11:17:58 <johnw> vanila: so it isn't quite the same as proving over an inductive proposition
11:18:15 <vanila> ah! I wonder how they keep it to decidable predicates
11:18:24 <johnw> that's just a requirement of liquidhaskell
11:18:28 <johnw> they mention it in their paper
11:18:35 <vanila> my main interest in this sort of stuff is array bounds checking :/
11:18:41 <vanila> which you can imagine the problems with
11:20:48 * hackagebot Cabal 1.18.1.6 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.18.1.6 (JohanTibell)
11:20:50 * hackagebot cabal-install 1.18.0.8 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.18.0.8 (JohanTibell)
11:21:50 <johnw> I imagine that for that to fully work, liquidhaskell would need to give you a function (for example, when reading arrays from a file) that would turn a runtime check into a compile-time verification.  That is, this function only lets arrays into the rest of your code which pass the check, and fails with an exception otherwise.  A "data cleaner".  That's just a guess though
11:31:20 <benzrf> johnw: a fun little module https://gist.github.com/5ee293561794d2db5c3a
11:35:01 <johnw> heh, cool!
11:45:32 <benzrf> sample usage https://gist.github.com/a1df2e80bcf2ab266c69
11:45:49 * hackagebot mwc-random 0.13.3.0 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.13.3.0 (AlexeyKhudyakov)
11:46:15 <sivteck> I am trying to understand the pythagoras_cps function <http://lpaste.net/2436494728947040256>
11:46:26 <sivteck> this is a continuation : (\k -> k 3)
11:46:33 <sivteck> :t (\k -> k 3)
11:46:34 <lambdabot> Num a => (a -> t) -> t
11:46:44 <sivteck> :t ($ print)
11:46:45 <lambdabot> Show a => ((a -> IO ()) -> b) -> b
11:46:55 <sivteck> :t ($ print) (\k -> k 3)
11:46:56 <lambdabot> IO ()
11:47:10 <sivteck> its supposed to return type b@#@!!@
11:47:22 <vanila> (\k -> k 3) is not a continuation
11:47:28 <sivteck> oh?
11:47:32 <vanila> k is the continuation
11:47:39 <Iceland_jack> "k" is the continuation ("k"ontinuation)
11:47:47 <vanila> :S
11:47:49 <sivteck> heh
11:48:56 <vanila> so can I help understanding it?
11:49:02 <sivteck> please
11:49:11 * sivteck begs for help before his brain breaks
11:49:16 <vanila> fro one thing I think the code is a little wrong
11:49:27 <vanila> oh actually it's ok
11:49:27 <sivteck> pythagora_cps function?
11:49:32 <vanila> you're defining add_cps using add
11:49:43 <sivteck> yes
11:49:58 <vanila> pythagoras_cps x y = \k ->
11:50:01 <vanila> you should take the continuation k here
11:50:11 <vanila> add_cps x_squared y_squared $ k
11:50:22 <vanila> then at the very end, give that continuation to add_cps
11:51:26 <sivteck> the thing I don't understand is how the Int in the result of square_cps x ((Int -> r) -> r)) gets binded to x_squared
11:51:59 <vanila> well first do you agree with my changes to the pythagoras_cps code?
11:52:05 <sivteck> yes
11:52:23 <vanila> http://lpaste.net/2436494728947040256
11:52:27 <vanila> i annotated it with them then
11:52:43 <sivteck> (yours was the original version from the wikibook)
11:52:43 <vanila> so square_cps x k squares x and throws the result into the continuation k
11:52:59 <vanila> in your code you have
11:53:00 <vanila> square_cps x $ \x_squared -> ...
11:53:12 <vanila> so that means it will put x squared into that lambda there
11:53:34 <sivteck> sec
11:53:55 <Zemyla> :t ($2)
11:53:56 <lambdabot> Num a => (a -> b) -> b
11:54:19 <sivteck> square_cps x :: (Int -> r) -> r and ($) :: (a -> b) -> a -> b
11:54:28 <marioxcc> Hi.
11:54:42 <sivteck> the second argument to $)
11:54:45 <sivteck> nvm
11:54:50 <marioxcc> I'm learning Haskell. I'm trying to define a function in GHCi
11:55:05 <breadmonster> marioxcc, have you prefaced it with let?
11:55:11 <marioxcc> Prelude> sayNum 1 = "One"
11:55:12 <marioxcc> <interactive>:4:10: parse error on input `='
11:55:19 <breadmonster> > let f x = x + 1; f 3
11:55:20 <lambdabot>  <hint>:1:21:
11:55:20 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
11:55:21 <marioxcc> hmm,  no breadmonster
11:55:42 <marioxcc> How should I define the function?
11:55:44 <Welkin> let ... in ...
11:55:44 <breadmonster> marioxcc, Yeah, well GHCi operates in the IO monad. You have to preface all function definitions with let.
11:56:10 <Welkin> breadmonster: all functions are a single expression
11:56:14 <marioxcc> breadmonster: Is there a way to avoid that behavior?.
11:56:14 <nitrix> I heard people talking about an alternative for `IO (Maybe X)`, the MaybeT transformer or something.
11:56:15 <Welkin> there are no statements
11:56:19 <nitrix> Could someone walk me through :( ?
11:56:26 <breadmonster> marioxcc, Nope.
11:56:33 <breadmonster> As far as I know.
11:56:58 <monochrom> put in a file, and tell ghci to :load
11:57:09 <monochrom> ghci is not an IDE
11:57:22 <vanila> nitrix, yes
11:57:25 <Zemyla> Okay, I find myself wondering about how Haskell would do a function for Brownian motion that takes previously generated values into account.
11:57:44 <vanila> nitrix, do you want to try MaybeT IO a
11:57:49 <marioxcc> monochrom: not an IDE, but it's a REPL or equivalent, so it's reasonable to expect it worked the way I was doing it.
11:58:09 <nitrix> vanila: Actually, I found this [1], is it a good resource? I could try asking questions along the way.   [1] http://en.wikibooks.org/wiki/Haskell/Monad_transformers
11:58:35 <vanila> I don't know, I would recommend monad transformers step by step
11:58:43 <Zemyla> Like, if it's already evaluated (brownian f 0) = a, and (brownian f 1) = b, then when you evaluate (brownian f 0.5), it should be normally distributed around (a+b)/2.
11:59:44 <Zemyla> And then if you call (brownian f 0.5) again, it should produce the same value.
11:59:45 <nitrix> Does every monads have a fail operation? I think they're only required to implement bind and return, right?
12:00:00 <vanila> fail shouldn't be part of monad
12:00:06 <Welkin> they all have fail by default I believe
12:00:10 <vanila> but they shoved it in there to make haskell more "pragmatic" or something
12:00:17 <vanila> but really it's not sound
12:00:18 <enthropy> Zemyla: the state then has to include a random number generator seed and all the previously generated values
12:00:34 <monochrom> the standard Haskell Monad has fail, and defaults to error. it's subjective what's "required".
12:01:21 <nitrix> monochrom: Ah I see. "This operation is not part of the mathematical definition of a monad, but is invoked on pattern-match failure in a do expression."
12:01:35 <Zemyla> Yes, and even though the state of f would change when called, the brownian function should be pure.
12:01:40 <enthropy> Zemyla: and that state can be passed in as another argument to your function (possibly "hidden" by using a state monad), stored in an IORef
12:01:45 <Zemyla> How is that possible?
12:02:40 <Welkin> I wonder how to structure my game so that I don't have to make every function include StateT Game IO
12:02:54 <Welkin> many of the functions need to modify or read from the state
12:03:30 <Welkin> is it better to do it that way, or to have pure functions that get passed values read from the calling function, and then pass everything back for an update?
12:04:04 <Welkin> or pass around a copy of the State and mappend it to the previous State?
12:04:11 <Welkin> that doesn't sound right either
12:05:45 <Welkin> https://github.com/ekmett/lens/blob/master/examples/Pong.hs
12:06:00 <Welkin> in that example, the `update` function is the main loop
12:06:08 <Welkin> or at least it looks that way
12:06:27 <edwardk> note: that code was pretty much dashed out by haasn as a one day project, and i don't think it has been touched up since
12:06:51 <edwardk> Welkin: we also have #haskell-game for game specific design stuff if you don't get an answer here
12:07:04 <edwardk> oh, you're in there.
12:07:21 <Welkin> I should probably have asked in there
12:07:30 <edwardk> anyways, i tend to like giving you the state and letting you tweak it
12:09:09 <breadmonster> edwardk, may I PM you for a minute?
12:10:50 * hackagebot react-haskell 1.3.0.0 - Haskell React bindings  http://hackage.haskell.org/package/react-haskell-1.3.0.0 (joelb)
12:18:21 <breadmonster> What exactly is the spineless, tagless g-machine?
12:18:44 <vanila> breadmonster, it's sort of a virtual instruction set that can be used to compile lazy langauges like haskel
12:18:55 <vanila> there's a good couple of books on it if you want
12:18:58 <breadmonster> Sure?
12:19:03 <breadmonster> So it's like ASM but lazy?
12:19:23 <vanila> its not very similar to asm or bytecode, but serves the same purpose
12:19:47 <breadmonster> tangential CS question: How do virtual machines work?
12:20:00 <vanila> these two: http://research.microsoft.com/en-us/um/people/simonpj/Papers/pj-lester-book/ http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
12:21:13 <vanila> what do you mean? you could try making a VM to learn about that
12:22:12 <c_wraith> a couple of the guys who started vmware pioneered treating VMs as compilers from ASM to inside-the-vm-ASM
12:22:12 <gilligan_> evening
12:22:28 <vanila> hello
12:22:35 <vanila> oh that kind of virtual machine...
12:22:54 <setpoint> > let fac n = let f x = if x <= 1 then 1 else n * f (n-1) in fac 5
12:22:55 <lambdabot>  not an expression: ‘let fac n = let f x = if x <= 1 then 1 else n * f (n-1) ...
12:22:57 <vanila> I thought it was more about vm intsruction sets used as compiler ILs
12:23:12 <setpoint> > let fac n = if x <= 1 then 1 else n * fac  (n-1) in fac 5
12:23:12 <vanila> setpoint, you have two lets but only one in
12:23:15 <lambdabot>  mueval-core: Time limit exceeded
12:23:34 <gilligan_> ngh.. why oh why does ghc-mod separate lines with a null byte instead of say newline ..
12:23:54 <ReinH> gilligan_: you could pipe it through tr
12:24:03 <setpoint> > let fac n = if n <= 1 then 1 else n * fac  (n-1) in fac 5
12:24:04 <lambdabot>  120
12:25:14 <gilligan_> ReinH, yeah but i'd rather not do that in a vim plugin
12:25:50 * hackagebot eventstore 0.5.0.1 - EventStore TCP Client  http://hackage.haskell.org/package/eventstore-0.5.0.1 (YorickLaupa)
12:27:23 <setpoint> > fix (\r x -> if x <= 1 then 1 else x * r (x-1)) 5
12:27:24 <lambdabot>  120
12:27:36 <vanila> setpoint, do you have a question?
12:28:12 <setpoint> do you actually need fix when you program? or fix is just there to let you do recursiona nd then you never really use it?
12:28:22 <vanila> you never need fix
12:28:25 <Iceland_jack> setpoint: You don't need it
12:28:26 <setpoint> I guess recursion in lambdas is not very common
12:28:30 <vanila> :S
12:28:40 <hpc> it's very occasionally useful
12:28:42 <Iceland_jack> Sometimes it can be useful
12:28:46 <setpoint> but without fix we could not do recursion?
12:28:56 <vanila> you can do recursion without fix
12:28:57 <Iceland_jack> setpoint:
12:28:57 <Iceland_jack>     recursion = 1 : recursion
12:29:01 <vanila> as you demonstrated earlier
12:29:02 <Iceland_jack> No 'fix' there
12:32:39 <YellPika> Does anyone know how to encode the following data type in System F/System F Omega (or if it's even possible)? data Evil a = Nil | Cons a (Evil (Evil a))
12:35:08 <vanila> YellPika, I think you can only encode regular datatypes but I don't have a reference for that claim
12:35:10 <quchen> Iceland_jack: Although "recursion = 1 : recursion" is probably inside a "let" statement, which is specified in terms of fix in the Report
12:35:19 <vanila> in system F
12:35:31 <vanila> in system F omega you can encode this
12:36:07 <ab9rf> the main value of 'fix' is to allow people to write recursive functions in a way that nobody who is not a total nerd can hope to understand them :)
12:36:13 <Zemyla> Hmm. In order to have the various generated Parsec objects reference each other, I think I would have to say pmap = fromList (... list of Parsec objects which reference pmap).
12:36:22 <vanila> forall a. forall f. f a -> (a -> f (f a) -> f a) -> f a   -- I think
12:36:47 <quchen> ab9rf: Fix isn't complicated. It's even very useful to know since it allows you to understand Fix on the type level.
12:37:05 <YellPika> vanila: Thanks, I'll give that a shot
12:37:25 <quchen> Turning non-recursive functions into recursive ones is a powerful concept, but I agree that fix is quite mysterious when you first see it.
12:37:52 <ab9rf> quchen: that captures what i was getting at.
12:37:56 <gilligan_> ReinH, iirc you've done some vim plugin yourself haven't you?
12:37:56 <Iceland_jack> quchen: Being specified in the Report doesn't dictate implementation though and I think setpoint was asking about actually using 'fix' in user code
12:38:03 <ReinH>  gilligan_ A bit.
12:38:14 <Iceland_jack> I could have chosen a better example though
12:38:28 <gilligan_> ReinH, fun to use, pain to write
12:38:50 <breadmonster> Can someone explain to me why (>>=) = concatMap in the list monad?
12:38:53 <ReinH> pretty much
12:39:03 <Iceland_jack> breadmonster: it's 'flip concatMap'
12:39:05 <gilligan_> ReinH, just realized i only get the ghc-mod response up to the first 0 byte. The rest is discarded. meh
12:39:06 <dfeuer> @tell edwardk "Cirdec" thinks they have accomplished the O(n) lazy breadth-first Tree unfold with a MonadFix context, using a path-compression technique I haven't yet had the chance to dig into: http://stackoverflow.com/questions/27748526/is-a-lazy-breadth-first-monadic-rose-tree-unfold-possible
12:39:06 <lambdabot> Consider it noted.
12:39:24 <Iceland_jack> breadmonster: Start by looking at the type of:
12:39:25 <Iceland_jack> @ty (=<<)
12:39:25 <lambdabot> Monad m => (a -> m b) -> m a -> m b
12:39:37 <breadmonster> Iceland_jack, Yeah, fair enough, why is it flip concatMap
12:39:47 <Iceland_jack> Then replace 'm a' by [a]:
12:39:47 <Iceland_jack> @ty :: (a -> [b]) -> [a] -> [b]
12:39:48 <lambdabot> parse error on input ‘::’
12:39:53 <Iceland_jack> Then replace 'm a' by [a]:
12:39:53 <Iceland_jack> @ty (=<<) :: (a -> [b]) -> [a] -> [b]
12:39:54 <lambdabot> (a -> [b]) -> [a] -> [b]
12:40:01 <Zemyla> > data SRWrapper = forall a. (Show a, Read a) => SRWrapper { innards :: a }
12:40:02 <lambdabot>  <hint>:1:1: parse error on input ‘data’
12:40:11 <edwardk> dfeuer: interesting
12:41:01 <Iceland_jack> breadmonster: Then compare that type to the type of 'concatMap'
12:41:03 <Iceland_jack> @ty concatMap
12:41:04 <lambdabot> (a -> [b]) -> [a] -> [b]
12:41:30 <Zemyla> > let data SRWrapper = forall a. (Show a, Read a) => SRWrapper { innards :: a }
12:41:31 <lambdabot>  <hint>:1:5: parse error on input ‘data’
12:41:38 <Iceland_jack> And you can verify that that definition satisfies the Monad laws, given:
12:41:38 <Iceland_jack>     return :: a -> [a]
12:41:38 <Iceland_jack>     return x = [x]
12:41:41 <breadmonster> Iceland_jack, That's great, but a slight question.
12:43:06 <breadmonster> Aren't there infinitely many functions of the type ([a] -> [b]) -> [a] -> [b]? Why do you choose flip concatMap?
12:43:16 <breadmonster> Is there any mathematical formalism behind it?
12:43:22 <vanila> yes
12:43:31 <breadmonster> Or is it the only one that satisfies the monad laws?
12:43:36 <Iceland_jack> breadmonster: The unsatisfactory reason is that it satisfies the Monad laws
12:43:37 <breadmonster> vanila, go on?
12:43:47 <dfeuer> edwardk, this Free monad Cirdec uses looks a lot like Fix, except that it can stop, right?
12:43:50 <vanila> join : [[a]] -> [a]
12:43:57 <vanila> this should just concatenate all the lists together
12:44:05 <vanila> fmap : (a -> b) -> ([a] -> [b])
12:44:06 <ReinH> breadmonster: Another way to define a monad is by fmap, return, and join
12:44:07 <vanila> ths should just map
12:44:19 <ReinH> breadmonster: There is exactly one fmap :: (a -> b) -> [a] -> [b]: map
12:45:05 <dfeuer> :t join
12:45:06 <lambdabot> Monad m => m (m a) -> m a
12:45:14 <Iceland_jack> :t join :: [[a]] -> [a]
12:45:15 <lambdabot> [[a]] -> [a]
12:45:15 <ReinH> There are multiple definitions of join, but only two are total: const [] and concat
12:45:17 <Iceland_jack> :t concat
12:45:17 <dfeuer> :t (id =<<)
12:45:18 <lambdabot> [[a]] -> [a]
12:45:18 <lambdabot> Monad m => m (m b) -> m b
12:46:00 <ReinH> Er, that's not true :/ const [], an infinite number of functions that choose an element of [[a]] and give [] if it doesn't exist, and concat
12:46:01 <quchen> breadmonster: Hey, I'm here now. Sorry for not responding earlier. In any case, it's probably better to ask straight on the channel rather than querying individual users.
12:46:10 <vanila> breadmonster, so putting those two together gives >>= as concat map
12:46:13 <vanila> does that help?
12:46:28 <dfeuer> ReinH, how's that? Isn't  concat . take 5  a total definition of join?
12:46:43 <ReinH> dfeuer: yeah, fair enough, so disregard that
12:47:04 <ReinH> So we're left with "the only definition of join that satisfies the laws"
12:47:17 <breadmonster> vanila, Fair enough, but my question was this: is there something unique about the List monad? Like can it be proven that no other definition of >>= satisfies the monad laws?
12:47:31 <vanila> breadmonster, it's not really unique, I have a different monad on List that I use for something else
12:47:40 <dfeuer> Yeah, there are lots of possibililities, but it's interesting how for many types (including that one), there is a clear-to-most-humans notion of the simplest useful function of that type.
12:47:50 <breadmonster> vanila, and if not, is there a reason we choose (>>=) = flip concatMap?
12:47:55 <quchen> dfeuer: >>= for Cont! :-D
12:47:59 <vanila> its the simplest
12:48:07 <dfeuer> :k Cont
12:48:08 <lambdabot> * -> * -> *
12:48:14 <quchen> :t Cont
12:48:14 <lambdabot>     Not in scope: data constructor ‘Cont’
12:48:15 <lambdabot>     Perhaps you meant one of these:
12:48:15 <lambdabot>       ‘Const’ (imported from Control.Lens),
12:48:17 <breadmonster> Because a lot of monads like Writer or Maybe have fairly easy to grasp definitions of >>=.
12:48:27 <breadmonster> ...List is a bit perplexing.
12:48:28 <dfeuer> :t Control.Monad.Cont.Cont
12:48:29 <lambdabot>     Not in scope: data constructor ‘Control.Monad.Cont.Cont’
12:48:29 <lambdabot>     Perhaps you meant ‘Control.Monad.Cont.ContT’ (imported from Control.Monad.Cont)
12:48:36 <dfeuer> :t Control.Monad.Cont.ContT
12:48:37 <Iceland_jack> breadmonster: Are you familiar with list comprehensions?
12:48:37 <lambdabot> ((a -> m r) -> m r) -> ContT r m a
12:48:40 <quchen> ?djinn ((a -> r) -> r) -> (a -> (b -> r) -> r) -> ((b -> r) -> r)
12:48:40 <lambdabot> f a b c = a (\ d -> b d c)
12:48:43 <breadmonster> Iceland_jack, Yup.
12:48:53 <Iceland_jack> breadmonster: Same thing
12:48:54 <vanila> breadmonster, it's just m >>= f = join (fmap f m)
12:48:54 <Iceland_jack> > [ x + y | x <- [1,2,3], y <- [10,20,30] ]
12:48:56 <lambdabot>  [11,21,31,12,22,32,13,23,33]
12:49:12 <Iceland_jack> > do x <- [1,2,3]; y <- [10,20,30]; return (x + y)
12:49:14 <lambdabot>  [11,21,31,12,22,32,13,23,33]
12:49:23 <vanila> breadmonster, and look at the types of join and fmap that I wrote above, concat and map seem natural
12:49:45 <dfeuer> quchen, is there any particular intuition behind which function djinn will choose? That will make sense to someone who knows not of theorem provers?
12:49:46 <Iceland_jack> Yes, (>>=) isn't nearly as intuitive for lists as 'fmap' and 'join' are
12:50:06 <barx> is it possible to import qualified in the interpreter?
12:50:12 <Iceland_jack>     fmap :: (a -> b) -> ([a] -> [b])
12:50:12 <Iceland_jack>     fmap = map
12:50:12 <Iceland_jack> and
12:50:12 <Iceland_jack>     join :: [[a]] -> [a]
12:50:14 <ReinH> vanila: at least map is unique
12:50:15 <Iceland_jack>     join = concat
12:50:29 <vanila> how is it unique?
12:50:35 <breadmonster> Okay, now it just makes a lot more sense to me.
12:50:42 <vanila> you can still do permutation of the elements
12:50:43 <breadmonster> Theoretically.
12:50:59 <ReinH> vanila: it's the only function that satisfies the laws
12:51:16 <quchen> dfeuer: I'm not sure whether there are more valid implementations for >>=. All I know is that Djinn seems to favour definitions using "more" of the input. For example if you let it define "maybe" via "?djinn a -> (b -> a) -> Maybe b -> a", it won't give you "f x _ _ = x".
12:51:19 <Iceland_jack> breadmonster: Intuitively you can think of join collapsing a structure, and you can define (>>=) using it and fmap as mentioned earlier
12:51:50 <dfeuer> quchen, ah, well, that would seem to make it match human intuition of usefulness better!
12:51:50 <Iceland_jack>     join :: Maybe (Maybe a) -> Maybe a
12:51:50 <Iceland_jack>     join Nothing         = Nothing
12:51:50 <Iceland_jack>     join (Just Nothing)  = Nothing
12:51:50 <Iceland_jack>     join (Just (Just x)) = Just x
12:52:04 <hexagoxel_> djinn can return more than one result
12:52:16 <ReinH> quchen: That's strange, djinn's search process should result in finding less defined members first...
12:52:18 <breadmonster> Iceland_jack, what about for the State monad?
12:52:20 <quchen> ReinH: That's because Functor instances are unique, were you referring to that?
12:52:25 <ReinH> quchen: yes
12:52:29 <breadmonster> I haven't looked up the definition of (>>=)
12:52:34 <quchen> ?djinn a -> (b -> a) -> Maybe b -> a
12:52:35 <lambdabot> f a b c =
12:52:35 <lambdabot>     case c of
12:52:35 <lambdabot>     Nothing -> a
12:52:35 <lambdabot>     Just d -> b d
12:52:43 <dfeuer> ReinH, less defined? Doesn't djinn work in a pretend-total world?
12:52:57 <ReinH> dfeuer: definedness in the denotational sense
12:52:59 <sbrg> Hey guys. I'm having a good deal of trouble implementing what is essentially a foldWhile, though the example is somewhat more complex. There is a somewhat lengthy explanation included regarding what seems to be wrong, and I would really appreciate any and all help: https://gist.github.com/c2db92c5f5f4121fd3d9
12:53:07 <dfeuer> ReinH, not sure what that means.
12:53:12 <Iceland_jack> breadmonster: You should do that and try to figure out what 'join' intuitively means for 'State s a'
12:53:13 <Iceland_jack> :t join :: State s (State s a) -> State s a
12:53:14 <lambdabot> State s (State s a) -> State s a
12:53:51 <Iceland_jack> breadmonster: Where 'join' is defined as:
12:53:52 <Iceland_jack> @src join
12:53:52 <lambdabot> join x = x >>= id
12:54:07 <Iceland_jack> So if you have the definition of (>>=) you can work out the definition of join
12:54:07 <dfeuer> sbrg, are you folding in the sense of lists or Data.Foldable or in some more general catamorphism sense?
12:54:20 <sbrg> dfeuer: lists
12:54:29 <sbrg> I'm folding over the children of a node in a tree
12:54:41 <breadmonster> Hmm, this stuff is really interesting, but I'd love to have a look at the underlying math.
12:54:43 <breadmonster> Any references?
12:55:00 <dfeuer> sbrg, you have a lot of code there. Can you narrow down to what sort of folding you're talking about? I can probably help construct a foldWhile if you give more details.
12:55:32 <Iceland_jack> breadmonster: You can get the main idea by looking at join, return and (>=>) together
12:55:41 <sbrg> dfeuer: The explanation included points to the actual code in question, which is, yes, rather verbose. Let me try to think of a better explanation
12:55:55 <breadmonster> Iceland_jack, Yeah, but I'd also like to learn category theory.
12:56:02 <dfeuer> sbrg, writing an abstract foldWhile is a *good* idea; you just have to test that foldWhile on *simple* things first.
12:56:19 <sinelaw> ReinH, when the next cast?! Can't wait.
12:56:35 <sinelaw> ReinH, btw, the type theory casts were also very enjoyable.
12:56:46 <Iceland_jack> I suggest getting the general idea first but there should be no lack of resources if you search for "monad (haskell) category theory intuition"
12:56:47 <ReinH> dfeuer: denotational semantics usually uses a domain with a bottom-complete partial order, so "less defined" is in relation to that ordering.
12:56:49 <RedNifre> Say, I have a number of type Nano, how can I convert it to a String with 5 decimal places (instead of the 9 that I get with show)?
12:56:54 <sbrg> dfeuer: I did write an abstract foldWhile, but as I said, the abstraction was making it hard to 'debug in my head' conceptually. My foldWhile used scanl + takeWhile
12:57:09 <ReinH> dfeuer: I *thought* that djinn's search procedure started with less defined members
12:57:41 <dfeuer> ReinH, that wouldn't make sense, I don't think, because =undefined is always valid, right?
12:58:09 <ReinH> dfeuer: Yes, but it would skip bottom for obvious reasons
12:58:19 <quchen> RedNifre: General advice, Show is not for prettyprinting. What you want is a "displayWithDigits n" function. cf https://github.com/quchen/articles/blob/master/fbut.md#show-is-not-for-prettyprinting
12:58:27 <dfeuer> sbrg, you might want to switch to just using foldr; it's a little weird to start with, but it ends up making sense eventually.
12:58:52 <ReinH> dfeuer: maybe augustss can tell us how djinn searches :)
12:58:59 <hexagoxel_> @djinn (a -> a -> a) -> a -> a -> a -> a
12:58:59 <lambdabot> f a b c _ = a b c
12:59:14 <tommd> augustss has previously claimed it's easy.
12:59:15 <breadmonster> Iceland_jack, Okay, cool.
12:59:23 <ReinH> tommd: many things are easy for augustss ;)
12:59:29 <breadmonster> Is there a code to pretty-fy haskell code, btw?
12:59:42 <ReinH> breadmonster: there is a project called hindent
12:59:52 <tommd> Also: http://stackoverflow.com/questions/10217931/how-does-djinn-work
12:59:54 <ReinH> it makes it prettier if you think that chrisdone's code style is pretty
13:00:06 <quchen> ReinH: WHICH IT IS
13:00:07 <quchen> :>
13:00:14 <setpoint> what does a haskell function prove? i get the sense that i prove something when i code haskell, but i do not prove the functions correctness according to the spec. but if i write a total function in haskell, what do i prove? i create a proof but i dont prove anything :)
13:00:15 <ReinH> quchen: I hew pretty closely to it
13:00:46 <setpoint> > let add1 = (+1) in map add1 [-5..5]
13:00:47 <lambdabot>  [-4,-3,-2,-1,0,1,2,3,4,5,6]
13:00:54 <ReinH>  setpoint types are theorems, inhabitants are proofs
13:01:08 <ReinH> setpoint: this is known as the Curry Howard correspondence
13:01:11 <Iceland_jack> setpoint: In Haskell, usually nothing interesting
13:01:15 <setpoint> inhabitants?
13:01:20 <ReinH> setpoint: values of that type
13:01:31 <ReinH> @djinn a -> a
13:01:32 <lambdabot> f a = a
13:01:43 <setpoint> how can the values be proofs?
13:01:45 <ReinH> f is a proof that given a value of type a, you can provide a value of type a
13:01:46 <sinelaw> setpoint, a -> a is the theorem, 'id' is the value (proof)
13:01:55 <setpoint> hmm
13:02:13 <setpoint> @djinn a -> b
13:02:13 <lambdabot> -- f cannot be realized.
13:02:20 <ab9rf> heh
13:02:20 <setpoint> @djinn Int -> Int
13:02:20 <lambdabot> Error: Undefined type Int
13:02:31 <setpoint> @djinn Integer -> Integer
13:02:31 <lambdabot> Error: Undefined type Integer
13:02:32 <ReinH> setpoint: you can think of  -> as meaning "implies"
13:02:33 <sinelaw> setpoint, djinn doesn't know about many types
13:02:39 <ab9rf> what does djinn do?
13:03:04 <quchen> ab9rf: Given a type, it generates a value of that type.
13:03:21 <ReinH> setpoint: you shuold check out Dan Piponi's article in https://www.haskell.org/wikiupload/1/14/TMR-Issue6.pdf
13:03:22 <ab9rf> quchen: ah
13:03:29 <quchen> ab9rf: Here's Data.Maybe.maybe for example.
13:03:30 <quchen> ?djinn a -> (b -> a) -> Maybe b -> a
13:03:30 <lambdabot> f a b c =
13:03:30 <lambdabot>     case c of
13:03:30 <lambdabot>     Nothing -> a
13:03:30 <lambdabot>     Just d -> b d
13:03:30 <ReinH> It's a very thorough exploration of this relationship between programs and proofs
13:03:58 <ab9rf> that's awesome
13:04:09 <sinelaw> @djinn (a->b) -> (a->c) -> (a,a) -> (b,c)
13:04:09 <lambdabot> f a b (c, _) = (a c, b c)
13:04:19 <ReinH> @djinn (a -> b -> c) -> (a -> b) -> (a -> c)
13:04:19 <lambdabot> f a b c = a c (b c)
13:04:31 <ReinH> Here's (<*>) for ((->) e)
13:04:38 <ReinH> @. pl djinn (a -> b -> c) -> (a -> b) -> (a -> c)
13:04:38 <lambdabot> f = ap
13:04:42 <quchen> AKA S from SKI
13:04:47 <ReinH> quchen: yep
13:05:25 <RedNifre> quchen fair enough... How do I pretty print a Fixed number rounded/truncated to a specific number of decimal places?
13:05:26 <quchen> ReinH: It's a bit scary that the Applicative instance of Reader is Turing-complete :-D
13:05:36 <setpoint> so whats the point of Djinn?
13:05:47 <quchen> RedNifre: There's Text.Printf in the standard libraries, for example.
13:05:57 <setpoint> @djinn a -> b -> Maybe b
13:05:57 <lambdabot> f _ a = Just a
13:06:22 <setpoint> @djinn a -> b -> Maybe (a,b)
13:06:22 <lambdabot> f a b = Just (a, b)
13:06:43 <quchen> > printf "%.2f" 1.2345678 :: String -- RedNifre
13:06:44 <lambdabot>  "1.23"
13:06:47 <ReinH> setpoint: function application is equivalent to modus ponens:
13:07:21 <ReinH> :t ($)
13:07:22 <lambdabot> (a -> b) -> a -> b
13:07:32 <ReinH> if a implies b and a then b
13:07:44 <rudi_s> Hi. I'm trying to implement an iterative algorithm with a while loop with a function f which takes ~5 parameters (i.e. i a b c d e), transforms them, and returns (a',b') : f (i - 1) a' b' c' d' e' where i is a counter and f 0 = [] . I thought I could factor out this by adding a new function g with: g h x = let (a,b) = h x in a : g h b (which takes care of the return value and calls the function itself with
13:07:50 <rudi_s>  the modified params) and take i (g f ...) to get ...
13:07:52 <RedNifre> quchen thank you, that looks like what I was looking for.
13:07:52 <rudi_s> ... only the first i elements (like the loop). Is this sane and not too inefficient compared to the direct recursion (still a haskell beginner)? Thanks.
13:08:18 <ReinH> rudi_s: this would be easier to explain with a code sample, I think. lpaste.net
13:09:48 <quchen> setpoint: The point of Djinn is that some things are hard for humans to write, but very easy for Djinn. I used the example of >>= for the Cont Monad instance before, which has a pretty scary type. Djinn gives you the correct answer in less than a second.
13:10:07 <setpoint> the answer to what?
13:10:28 <quchen> The answer to "Djinn, what's the implementation for >>= for Cont"
13:10:38 * quchen rubs Djinn's flask
13:10:39 <quchen> ?djinn ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r
13:10:39 <lambdabot> f a b c = a (\ d -> b d c)
13:10:44 <quchen> Djinn has spoken.
13:10:45 <setpoint> @djinn sweden .->
13:10:46 <lambdabot> Cannot parse command
13:10:50 <rudi_s> ReinH: http://paste.debian.net/139169/
13:10:51 <setpoint> @djinn sweden -> gold
13:10:51 <lambdabot> -- f cannot be realized.
13:10:54 <setpoint> pfft
13:11:07 <quchen> That's >>= for Cont. We still need return.
13:11:26 <quchen> ?djinn a -> (a -> r) -> r
13:11:26 <lambdabot> f a b = b a
13:11:31 <quchen> And we're done, Cont implemented
13:11:51 <quchen> (modulo newtype wrappers)
13:12:37 <carter> jonsterling: depends on what youre doing, but usually yeah
13:13:29 <anhar> hello all!
13:15:07 <fread2282> will ghc convert simple wrapper datas into newtypes?
13:15:16 <RedNifre> > printf "%.2f" (1.234567899 :: Nano) :: String
13:15:17 <lambdabot>  No instance for (Text.Printf.PrintfArg
13:15:18 <lambdabot>                     (Data.Fixed.Fixed Data.Fixed.E9))
13:15:18 <lambdabot>    arising from a use of ‘Text.Printf.printf’
13:15:52 * hackagebot helm 0.7.1 - A functionally reactive game engine.  http://hackage.haskell.org/package/helm-0.7.1 (ZackCorr)
13:16:28 <rudi_s> ReinH: I'm mostly curious if my second solution is sane (from a haskell-point-of-view) and if it has any (serious) performance issues and if there are better solutions.
13:18:59 <ReinH> fread2282: no
13:20:20 <Zemyla> I wish there were a set that supported the complement function.
13:20:28 <tolt> carter: I noticed you have the current issue https://github.com/bscarlet/llvm-general/issues/122 but do you have a fix for it anywhere?
13:21:15 <setpoint> you cant let a data?
13:21:20 <carter> tolt: not yet
13:21:21 <setpoint> cant create a data in ghci?
13:21:22 <carter> finite yak time
13:21:40 <tolt> carter: alright. I just wanted to make sure I wasn't going down a rabbit hole.
13:21:43 <ReinH> rudi_s: is this bresenham line drawing?
13:21:49 <carter> tolt: i know how to write the fix
13:21:52 <rudi_s> ReinH: Similar.
13:21:52 <tolt> (and I was)
13:22:08 <carter> tolt: what rabbit?
13:22:18 <rudi_s> (It's from "A fast and Simple All-Integer Parametric Line" from Barrera et.al).)
13:22:22 <tolt> your forked version
13:23:19 <carter> tolt: hehe
13:23:26 <carter> my forks are from different patches
13:23:30 <carter> tolt: that one is a bit different
13:23:41 <tolt> Yeah. I looked at the commit and took a chance
13:23:41 <ReinH> rudi_s: There are a few ways to simplify it a bit
13:23:48 <carter> tolt: i'm going to use $([|Just 123|] >>= stringE . show)  generalized
13:23:53 <carter> to generate teh TH needed
13:24:04 <ReinH> rudi_s: my only concern with performance is that tuples are lazy
13:24:13 <carter> the last time i did a TH setup.hs hack i didn't know about $([|Just 123|] >>= stringE . show)
13:24:34 <tolt> Well, I guess instead of playing with llvm I need to learn more abiout TH
13:24:53 <ReinH> > signum (-1) -- rudi_s
13:24:55 <lambdabot>  -1
13:24:58 <ReinH> > signum (-5) -- rudi_s
13:25:00 <lambdabot>  -1
13:25:16 <carter> tolt: i can help write the patch late tonight
13:25:18 <carter> or later this week
13:25:28 <carter> tolt: bit busy today and starting a new job tomrorow
13:25:34 <carter> later this week is probably better
13:25:48 <tolt> carter: I'm not too worried about it but alright but awesome!
13:25:56 <carter> tolt: :)
13:26:02 <yulate> hello, I am stuck trying to pass in 2 arguments in getArgs through the command line and don't know where in the code to change/look at. I have tried adding another getArgs functions and even adding apramenters to IO () but this doesn't work...
13:26:06 <carter> tolt: did you see my last big llvm general patch?
13:26:09 <tolt> I hope you enjoy the new job! (and that it doesn't take too much time away from the numeric lirbary)
13:26:20 <carter> tolt: if anythig, it'll mean i'll have more time for it!
13:26:26 <carter> doing consulting sucks and ate time
13:26:32 <tolt> Awesome!
13:27:39 <tolt> And no, I didn't see your patch
13:27:52 <benzrf> a thought.
13:28:05 <carter> tolt: notice how newest llvm-general allows transformers 0.3 again?
13:28:28 <tolt> (I didn't know it didn't before) but that's really cool.
13:28:29 <rudi_s> ReinH: Ah nice, thanks for the signum any. Do you have more suggestions - also regarding the while-"loop"?
13:29:40 <carter> tolt: that means you can use GHC 7.8 API + LLVM-General together in USERLAND
13:30:25 <tolt> That's insane.... I need a minute to think about that.
13:30:46 <Welkin> yulate: getArgs produces a list of the arguments
13:30:52 <benzrf> :k (m' (t n) a -> n' (t n) b -> c) -> m' (t Identity) a -> n' n b -> c
13:30:53 <lambdabot> Not in scope: type variable ‘m'’
13:30:53 <lambdabot> Not in scope: type variable ‘t’
13:30:53 <lambdabot> Not in scope: type variable ‘n’
13:30:55 <carter> tolt: that means you could use GHC as a frontend
13:30:58 <Welkin> well, IO [String]
13:31:04 <carter> then jsut focus on how you wanna compile optimzied core/cmm
13:31:06 <tolt> Yeah. I mean the things you could do.
13:31:15 <benzrf> :k forall m' t n a n' b c. (m' (t n) a -> n' (t n) b -> c) -> m' (t Identity) a -> n' n b -> c
13:31:17 <lambdabot> *
13:31:19 <benzrf> neat.
13:31:25 <Welkin> yulate: in your do-block use this: args <- getArgs
13:31:46 <Welkin> that executes the IO action to produce [String]
13:31:47 <benzrf> something like that, with monad morphismms...
13:31:52 <benzrf> Welkin: argh
13:31:56 <benzrf> Welkin: no, that's a lie!
13:32:06 <benzrf> <- does NO execution
13:32:25 <Welkin> how would you explain it?
13:32:25 <benzrf> it is only sugar for (>>=)
13:32:31 <Welkin> okay
13:32:32 <benzrf> and (>>=) definitely doesn't execute anything
13:32:39 <Welkin> you are correct
13:32:40 <eyebloom> johnw: Can I ask you some more questions about the examples we were discussing earier?
13:32:41 <benzrf> Welkin: it's like callback-based programming
13:32:44 <Welkin> it pulls [String] out of IO
13:32:51 <yulate> Welkin: that is how it currently is collecting one arguement. But I can't seem to pass another one through it via the command liine
13:33:02 <carter> tolt: i think its kinda neat because it means it should at some point be easier to try out optimization ideas in user land
13:33:08 <Welkin> yulate: what do you mean? args is a list of your arguments
13:33:19 <benzrf> Welkin: the bit after the  <- line is a callback, and the <- defines the value that you're async retreiving
13:33:26 <benzrf> er
13:33:27 <benzrf> the variable
13:33:47 <ReinH> rudi_s: the "loop" is a pretty standard construction, although often times we can use a higher order function rather than our own recursive definition
13:34:14 <ReinH> rudi_s: BTW when I was doing this sort of thing I found the linear library very useful: http://hackage.haskell.org/package/linear
13:34:28 <yulate> Welkin: If that is the case when I execute this program ./hello listen dumbo   it only returns, "hey, listen"
13:34:54 <Welkin> yulate: paste  your code on lpaste
13:34:56 <Welkin> @lpaste
13:34:56 <lambdabot> Haskell pastebin: http://lpaste.net/
13:35:14 <tolt> carter: ghc optimizations?
13:35:18 <carter> sure
13:35:19 <carter> whatever
13:35:25 <rudi_s> ReinH: Yeah, that's why I tried to add the asdf function to factor out the loop part, still not sure if that's a good idea or I should just use the explicit loop?
13:35:38 <lpaste> yulate pasted “hello” at http://lpaste.net/117759
13:35:38 <carter> tolt: or just prototyping a new haskell code gen compilation style
13:35:40 <tolt> or general things compiled to llvm?
13:35:43 <carter> or whatever
13:35:44 <tolt> Yeah
13:35:49 <tolt> that makes sense.
13:35:51 <carter> you could use llvm already
13:35:56 <rudi_s> Thanks, I'll keep linear in mind. Still trying to do most of the stuff on my own for now so I can learn more about Haskell.
13:35:59 <carter> its deping on GHC API + llvm
13:36:08 <tolt> yeah
13:36:09 <yulate> Welkin: ignore args2 ill delete it
13:36:10 <carter> because GHC 7.8 API you have to use baked in transformers
13:36:16 <ReinH> rudi_s: writing those sort of things is generally a good idea. That sort of "bottom up" approach to writing Haskell programs is often effective.
13:36:20 <tolt> yeah
13:36:35 <lpaste> yulate revised “hello”: “No title” at http://lpaste.net/117759
13:36:51 <ReinH> rudi_s: fwiw the linear library will make a *lot* of your handling of points/vectors easier
13:37:05 <Welkin> yulate: the problem is that you are using !! 0
13:37:12 <Welkin> that pulls out the first element of the list
13:37:30 <Welkin> you are receiving all of the arguments
13:37:36 <Welkin> but you are ignoring everything but the first one
13:38:14 <rudi_s> ReinH: Thanks, then I'll keep it with the "asdf". - Thanks, good to know, will have a look at the library.
13:38:23 <ReinH> rudi_s: it might be interesting to see if asdf can be expressed in terms of more familiar functions like folds, etc
13:38:38 <ReinH> rudi_s: but sometimes you just need your own recursive combinator thingy
13:38:46 <rudi_s> If you have an idea how, I am all ears.
13:38:59 <ReinH> rudi_s: I might suggest giving it a better name than asdf ofc ;)
13:39:53 <rudi_s> ReinH: Hehe. Yeah, I guess I'll call it iterateAccum.
13:40:28 <Welkin> yulate: http://lpaste.net/117759
13:40:44 <yulate> Welkin: is that somehow saying only return the first arg>
13:40:45 <yulate> ??
13:40:59 <Welkin> yes
13:41:06 <Welkin> :t (!!)
13:41:06 <lambdabot> [a] -> Int -> a
13:41:17 <Welkin> it produces only *one* element from the list
13:41:23 <Welkin> it is the list indexing function
13:42:05 <yulate> Welkin: thank you for that understanding. I didn't realize it was a type.
13:44:38 <ReinH> rudi_s: You can write a basic line drawing algorithm in one line of code with linear by using linear interpolation :)
13:45:06 <ReinH> rudi_s: would be interesting to see how that compares performance-wise
13:45:53 * hackagebot lens-action 0.1 - Monadic Getters and Folds  http://hackage.haskell.org/package/lens-action-0.1 (EdwardKmett)
13:48:43 <rudi_s> ReinH: Sounds nice, will try it when I have some time.
13:49:46 <Zemyla> Why is IntSet a tree of Ints instead of a Map of Words that with various bits set?
13:50:53 * hackagebot monoid-subclasses 0.4 - Subclasses of Monoid  http://hackage.haskell.org/package/monoid-subclasses-0.4 (MarioBlazevic)
13:52:39 <Cale> Zemyla: hm?
13:52:43 --- mode: Cale set -o Cale
13:53:09 <Cale> Zemyla: IntSet is internally a patricia tree
13:54:04 <Cale> It's not exactly a tree of the Ints that it stores, it's a tree of prefixes and masks.
13:55:22 <Zemyla> Oh, okay.
13:55:43 <Cale> http://hackage.haskell.org/package/containers-0.5.6.2/docs/src/Data-IntSet-Base.html#IntSet
13:56:20 <Zemyla> Also, why don't Set and IntSet both instance a common class?
13:56:44 <Cale> Because all the types are difficult to compare
13:57:05 <Cale> Note that these libraries have been around since long before type families and associated types existed.
13:57:31 <Zemyla> True.
13:58:04 <mettekou> Should the dist folder generated by Cabal be kept under version control? Because there doesn't seem to be a large Haskell project that has it in its repository.
13:59:45 <sinelaw> mettekou, why should it be under version control?
13:59:54 <sinelaw> it's the output of your build
14:00:11 <sinelaw> not source code
14:00:44 <Cale> (and even with associated types, when you actually start writing down the classes involved for which you'll have very few instances and even less code which will really be able to use the class in a polymorphic way, you start to wonder if it's really worth it)
14:00:46 <mettekou> sinelaw: Well, I thought it could be handy because it contained the Haddock documentation as well.
14:01:02 <sinelaw> mettekou, those can also be generated from your source
14:03:36 <mettekou> sinelaw: Yeah, I know. The article on the HaskellWiki describing an example structure for a Haskell project, included dist, which confused me.
14:04:41 <sinelaw> mettekou, yeah, that should be more clear. I never commit my dist into VCS
14:04:56 <mietek> Is conduit-extra-1.1.6 broken?
14:07:05 <ReinH>  mettekou no, it should not
14:08:04 <Hermit> I was about to grab Data.Conduit.Process.Unix from process-conduit but saw it's deprecated in favor of keter, but when I loaded keter I've found it's USELESS!! where the fuck is all the conduit-like functionality it's supposed to provide? Data.Conduit.Process.Unix from keter is almost empty
14:09:04 <Hermit> no sink, no source
14:09:09 <Hermit> anywhere
14:09:27 <johnw> eyebloom: sure!
14:09:35 <ReinH> johnw: o/
14:09:45 <ReinH> johnw: I've got my nixos + xmonad vm running again, yay
14:09:47 <johnw> ReinH: hello!
14:09:49 <johnw> oh, nice!
14:10:01 <ReinH> johnw: currently I'm trying to figure out what the ar program is, why it isn't installed, and how I install it! :D
14:10:16 <ReinH> oh, ar is for archives. Duh.
14:10:22 <ReinH> now how in the heck is it missing
14:11:43 <eyebloom> johnw: In the myType example I gave. Why wouldn’t the compiler automatically promote myType1 to a type.
14:11:53 <eyebloom> as well as a value
14:11:55 <johnw> it does, if you use DataKinds
14:12:33 <eyebloom> I see. If that’s the case then could you use that type information without explicitely declaring it with a GADT?
14:13:00 <johnw> use it how?
14:13:18 <johnw> myType1 would be a type whose value would be a singleton that I believe you don't have access to...
14:13:30 <eyebloom> I see.
14:13:50 <johnw> usually DataKinds are used with GADTs
14:14:01 <eyebloom> I think basically this is leading just to dependent types.
14:14:06 <johnw> so that you could say: data Foo :: myType -> * where Foo1 :: Foo myType1
14:14:34 <johnw> even with dependent types, pattern matching a value does not suddenly restrict further pattern matches on that same value
14:14:49 <johnw> unless you are using a dependent type like with the GADT example
14:14:57 <eyebloom> I see
14:15:05 <johnw> but, I mean a simple enumerated type like you gave, no
14:15:45 <johnw> now, if we did have dependent types
14:15:52 <johnw> then we could something fancy using CPS functions
14:15:54 * hackagebot bindings-DSL 1.0.22 - FFI domain specific language, on top of hsc2hs.  http://hackage.haskell.org/package/bindings-DSL-1.0.22 (JohnWiegley)
14:16:11 <eyebloom> I think what I’m essentially trying to do is avoid alot of boilerplate code. I’d like to be able to just define a sum type and then be able to say that function f only accepts values of say myType1
14:16:15 <Zemyla> There's no way for me to derive Ord a from Ord [a], right?
14:16:19 <johnw> destructMyType :: (forall x : myType, x == myType 1 -> c ) -> c
14:16:29 <johnw> then, if the pattern match succeeds, we also get evidence of exactly what value it was
14:16:36 <johnw> and we could use *that* knowledge
14:16:57 <johnw> eyebloom: you could use a Checked type
14:17:07 <johnw> http://hackage.haskell.org/package/data-checked
14:17:21 <johnw> it's a poor man's way to do it (i.e., not with types)
14:17:24 <Cale> Zemyla: You can go the other way around: if you know Ord a, then you know Ord [a], because there's an instance
14:17:37 <bernalex> I guess this isn't violently off-topic to ask here: any haskellers going to FOSDEM? :-]
14:17:39 <ReinH> johnw: oh. binutils. duh.
14:17:48 <ReinH> I forget what is in coreutils and what is in binutils :/
14:18:00 <johnw> ar is used to make programs
14:18:09 <johnw> so generally the dev-y stuff is in binutils
14:18:13 <johnw> ld, ldd, ar, nm, etc.
14:18:26 <eyebloom> johnw: I see. Can you explain a little more about that definition of destructMyType that you wrote. Is that valid Haskell?
14:18:33 <RedNifre> I have this data Thing = Thing {...} and somewhere else I declared newtype Stuff = Thing. But when I try to use Thing, the compiler complains that it is ambiguous and I could have meant Stuff. Why is that? I thought newtype introduced an incompatible synonym?
14:18:34 <johnw> eyebloom: no, that was Coq syntax
14:18:38 <eyebloom> I see.
14:18:51 <johnw> eyebloom: you can achieve something similar in GHC with singletons
14:19:02 <eyebloom> Ah, there’s the rub.
14:19:19 <johnw> yeah, it would involve using Sing
14:19:41 <ReinH> johnw: righto
14:19:41 <Cale> RedNifre: That's not a complete newtype declaration
14:20:08 <RedNifre> What's missing?
14:20:09 <Cale> RedNifre: It should complain that you're reusing a constructor name, and that there's no field.
14:20:30 <Cale> The syntax of newtypes is exactly like the syntax of data declarations
14:20:36 <Cale> only you must have exactly one constructor
14:20:42 <Cale> and it must have exactly one field
14:20:43 <eyebloom> I’ve been writing an interpreter for a simple term data structure, and you start to see some of the hoops you have to jump through in Haskell to write a function that for example only excepts a Var term.
14:20:54 * hackagebot reactive-banana-wx 0.8.0.4 - Examples for the reactive-banana library, using wxHaskell.  http://hackage.haskell.org/package/reactive-banana-wx-0.8.0.4 (HeinrichApfelmus)
14:20:57 <eyebloom> I’m not complaining, just hopeful for the future.
14:21:00 <RedNifre> Oh, then I guess it doesn't work in my case.
14:21:15 * Hermit sighs
14:21:22 <Hermit> RedNifre: check basic syntax please
14:21:32 <Cale> the usage of newtypes also works just like the usage of data declarations, only the semantics of pattern matching against a newtype data constructor are a little different
14:21:35 <Hermit> it will work once you make a proper declaration
14:22:07 <johnw> eyebloom: the http://hackage.haskell.org/package/singletons library is the next step along this path
14:22:42 <eyebloom> johnw: thanks for that.
14:22:46 <Cale> (to account for the fact that the newtype's data constructor doesn't actually exist at runtime, whereas the data constructors introduced by data will consist of a real datastructure in memory with an integer tag and a bunch of pointers for the fields.
14:22:48 <Cale> )
14:23:13 <johnw> not sure what the Sing-based syntax would be exactly
14:23:58 <eyebloom> johnw: have you encountered any good books or tutorials or template haskell. I definitely have a need for it in my current projects but I found it daunting on first approach.
14:24:10 <eyebloom> *on
14:24:12 <johnw> no, I really haven't
14:24:17 <johnw> it needs some
14:24:22 <eyebloom> agreed
14:25:17 <johnw> eyebloom: see http://www.cis.upenn.edu/~sweirich/talks/flops2012.pdf btw
14:25:20 <Zemyla> How is a Float an Enum?
14:25:21 <johnw>  that's a pretty good presentation
14:26:09 <Hermit> Zemyla: why wouldn't it?
14:26:14 <johnw> eyebloom: you can see in that presentation how she has an enumerated datatype for the color for example, and needs to restrict the algorithm by the color at compile time
14:26:20 <eyebloom> johnw: I watched the video a few days ago. I’m looking forward to her presentation at the Compose conference.
14:27:31 <johnw> ah, I'm hoping to come to that conference to!
14:27:38 <Zemyla> > fromEnum (3.5::Double)
14:27:39 <johnw> so maybe we might see each other there
14:27:39 <lambdabot>  3
14:27:53 <eyebloom> Cool, I’m in NYC so you can use my couch.
14:28:03 <johnw> the only thing I'm waiting on is to see exactly when my work trip that week will happen
14:28:09 <Zemyla> > succ (3.5::Double)
14:28:10 <lambdabot>  4.5
14:28:15 <johnw> ryantrinkle has already made a couch offer, but thanks! :)
14:28:32 <eyebloom> Sweet, well a beer then.
14:28:41 <johnw> hah, I don't drink alcohol!
14:28:44 <johnw> lol
14:28:55 <johnw> we'll figure something out
14:29:01 <eyebloom> Cool.
14:29:06 <RedNifre> I tried newtype Stuff = Stuff { thing :: Thing} , but It seems that I have to type Stuff (Thing foo bar) instead of Stuff foo bar now.
14:30:00 <Cale> RedNifre: Yes, that's right.
14:30:18 <eyebloom> Just pmed my info
14:31:21 <Cale> RedNifre: So  Stuff :: Thing -> Stuff   and  thing :: Stuff -> Thing  give you an isomorphism between the Thing and Stuff type.
14:32:39 <RedNifre> Is there a way that would allow me to type "Stuff foo bar" which would create something that is technically a "Thing foo bar", but counts as a separate type?
14:33:17 <Cale> You could define a function  stuff foo bar = Stuff (Thing foo bar)
14:34:26 <RedNifre> But that would look a bit odd... Hm...
14:35:13 <RedNifre> Well, maybe I can live with Stuff (Thing foo bar). It makes it clear that it is actually a Thing and it makes "Stuff" look like it's an annotation.
14:35:55 * hackagebot tomato-rubato-openal 0.1.0.3 - Easy to use library for audio programming.  http://hackage.haskell.org/package/tomato-rubato-openal-0.1.0.3 (HeinrichApfelmus)
14:40:21 <stevejb> join #haskell
14:44:00 <Axman6> stevejb: preaching to the quire :P
14:44:19 <Axman6> aoh, Choir even. wut
14:44:53 <hpc> you need to check your spilling ;)
14:50:09 <setpoint> can you access bits in haskell and do bitwise operations as well?
14:50:19 <Bor0> yes
14:50:26 <Iceland_jack> setpoint: Data.Bits
14:50:30 <mausch> hi, what do people here think about using "prime" (i.e. `'`) in public/exported names?
14:50:39 <Bor0> :t (.&.)
14:50:39 <lambdabot> Bits a => a -> a -> a
14:50:45 <Iceland_jack> setpoint: http://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Bits.html
14:50:50 <mausch> as in, export both foo and foo'
14:50:56 * hackagebot Cabal 1.22.0.0 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.22.0.0 (JohanTibell)
14:51:19 <bgamari> johnw, release?
14:51:26 <mausch> are there any examples of this other than strict/lazy folds?
14:52:19 <johnw> bgamari: done
14:52:24 <johnw> about an hour ago
14:52:50 <bgamari> johnw, hmm, odd
14:52:51 <bgamari> johnw, http://hackage.haskell.org/package/bindings-gpgme
14:53:07 <johnw> oh, I just released bindings-dsl, whoops
14:54:58 <bgamari> johnw, that would explain it
14:55:30 <zipper> Is there a way to encode non determinism? e.g so that I can see all the ways in which a list of chars can be combined?
14:55:50 <Iceland_jack> > replicateM 3 "hey"
14:55:52 <lambdabot>  ["hhh","hhe","hhy","heh","hee","hey","hyh","hye","hyy","ehh","ehe","ehy","ee...
14:55:52 <Iceland_jack> S
14:55:54 <Iceland_jack> Like that?
14:55:58 <hpc> that would be the [] monad
14:56:12 <hpc> (and applicative)
14:56:23 <zipper> Iceland_jack: Yeah I'm supposed to implement something similar for applicative though. Thanks.
14:56:33 <johnw> bgamari: I'm not a maintainer of bindings-gpgme on Hackage; I'll have to ask Mauricio
14:56:35 <Iceland_jack> Well, replicateA :)
14:56:36 <zipper> @src replicateM
14:56:36 <lambdabot> replicateM n x = sequence (replicate n x)
14:56:56 <hpc> > (++) <$> ["one ", "two "] ["1", "2"]
14:56:57 <lambdabot>  Couldn't match expected type ‘[[GHC.Types.Char]] -> f [a]’
14:56:57 <lambdabot>              with actual type ‘[[GHC.Types.Char]]’
14:57:04 <hpc> > (++) <$> ["one ", "two "] <*> ["1", "2"]
14:57:05 <lambdabot>  ["one 1","one 2","two 1","two 2"]
14:57:12 <bgamari> johnw, alright
14:57:15 <eikke> ocharles: I got Hadoom build issues, types `Linaer.Affine.Point V2 Float` differs from `V2 someTypeVar` in `TestWorld`. Any clues?
14:57:28 <zipper> Iceland_jack: Ha yes
14:57:31 <zipper> :t replicateA
14:57:31 <Iceland_jack> > T.sequence (replicate 3 "hey")
14:57:32 <lambdabot>     Not in scope: ‘replicateA’
14:57:32 <lambdabot>     Perhaps you meant one of these:
14:57:32 <lambdabot>       ‘Seq.replicateA’ (imported from Data.Sequence),
14:57:32 <lambdabot>  ["hhh","hhe","hhy","heh","hee","hey","hyh","hye","hyy","ehh","ehe","ehy","ee...
14:57:36 <Iceland_jack> > Seq.replicateA 3 "hey"
14:57:37 <lambdabot>  [fromList "hhh",fromList "hhe",fromList "hhy",fromList "heh",fromList "hee",...
14:58:14 <zipper> @src replicateA
14:58:15 <lambdabot> Source not found. The more you drive -- the dumber you get.
14:58:21 <Zemyla> Man, I was hoping Enum was a type which required a 1:1 mapping between its elements and Ints or Integers.
14:58:38 <zipper> @src Seq.replicateA
14:58:38 <lambdabot> Source not found. Just try something else.
14:58:39 <Iceland_jack> Sorry, 'T.sequenceA', not 'T.sequence': of course it doesn't matter for lists
14:59:13 <zipper> Iceland_jack: I want something for all functors. Right now I have no idea how to implement this.
14:59:27 <Zemyla> Basically, that Enum a meant for all x in a, toEnum (fromEnum x) == x.
14:59:33 <zipper> Iceland_jack: Mind pointing me in the right direction. It's sort of homework.
15:00:56 * hackagebot cabal-install 1.22.0.0 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.22.0.0 (JohanTibell)
15:01:00 <NemesisD> does anyone with optparse-applicative how to support the style of command foo -fooflag -- -flags -for -another -program
15:01:10 <benzrf> > replicateM 3 "hey"
15:01:12 <lambdabot>  ["hhh","hhe","hhy","heh","hee","hey","hyh","hye","hyy","ehh","ehe","ehy","ee...
15:01:26 <zipper> Iceland_jack: Will hoogle. Thanks though
15:01:37 <zipper> benzrf: Uh to write something that will do that
15:01:40 * zipper is out
15:03:00 <Zemyla> There is no class that is a 1:1 mapping to Int or Integer, is there?
15:04:10 <pavonia> How can a class be a mapping to a type?
15:04:32 <johnw> Zemyla: Integers are an infinitely large domain
15:05:10 <benzrf> fun task:
15:05:47 <benzrf> invent a set of types and type constructors such that you can write something like place-value numbers at the type level and get types with that many inhabitants
15:05:53 <benzrf> i.e.,
15:06:16 <benzrf> the type "One `B` Zero `B` One `B` Zero" has 10 elements
15:06:25 <benzrf> or rather, 1010 elements (in binary)
15:06:42 <Zemyla> johnw: I meant in the sense that there is a function eToInt :: e -> Integer, and a function intToE :: Integer -> e, such that for all x in e, intToE (eToInt x) == x.
15:07:04 <johnw> no
15:07:10 <johnw> because Integer is an infinitely large domain, and Int is limited
15:07:27 <benzrf> johnw: Int is not one of those
15:07:36 <benzrf> Zemyla: what e are you interested in
15:07:43 <johnw> ?
15:07:59 <benzrf> Zemyla: are you asking for any possible type that could fill in for e?
15:08:12 <benzrf> you are asking if such an e exists?
15:08:35 <johnw> what do you mean by "not one of those"?
15:08:36 <benzrf> @let data IntegerWrap = IW {unIW :: Integer}
15:08:39 <lambdabot>  Defined.
15:08:40 <benzrf> Zemyla:
15:08:41 <benzrf> :t IW
15:08:42 <lambdabot> Integer -> IntegerWrap
15:08:42 <Zemyla> I'm wondering why there isn't a class that specifies such a pair of functions and a constraint.
15:08:44 <benzrf> :t unIW
15:08:44 <lambdabot> IntegerWrap -> Integer
15:08:53 <benzrf> Zemyla: ohh
15:09:04 <benzrf> Zemyla: you mean, you want a class with eToInt and intToE as methods?
15:09:07 <benzrf> like
15:09:19 <benzrf> @let class IntBij e where eToInt :: e -> Integer, and a function intToE ::  Integer -> e,
15:09:19 <lambdabot>  Parse failed: Parse error: ,
15:09:26 <benzrf> @let class IntBij e where eToInt :: e -> Integer; intToE :: Integer -> e
15:09:28 <lambdabot>  Defined.
15:09:36 <Zemyla> Because, for instance, it would have all the discrete Enum instances as instances, but none of the floating-point ones.
15:09:51 <benzrf> uhh
15:09:58 <benzrf> that's not guaranteed surjective
15:10:32 <Zemyla> No, but it has at least a left inverse.
15:10:50 <Zemyla> > fromEnum (toEnum 3.5) == 3.5
15:10:51 <lambdabot>  No instance for (GHC.Enum.Enum a0)
15:10:51 <lambdabot>    arising from a use of ‘GHC.Enum.fromEnum’
15:10:51 <lambdabot>  The type variable ‘a0’ is ambiguous
15:10:58 <benzrf> lol
15:11:07 <Zemyla> > fromEnum (toEnum 3.5::Double) == 3.5::Double
15:11:08 <lambdabot>  Couldn't match expected type ‘GHC.Types.Double’
15:11:08 <lambdabot>              with actual type ‘GHC.Types.Bool’
15:11:16 <Zemyla> > fromEnum (toEnum 3.5::Double) == (3.5::Double)
15:11:17 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
15:11:17 <lambdabot>              with actual type ‘GHC.Types.Double’
15:11:24 <Zemyla> > fromEnum (toEnum (3.5::Double)) == (3.5::Double)
15:11:25 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
15:11:25 <lambdabot>              with actual type ‘GHC.Types.Double’Couldn't match expected type ...
15:11:25 <lambdabot>              with actual type ‘GHC.Types.Double’
15:11:52 <Zemyla> Oh, right. :V
15:11:52 <johnw> Zemyla: even if there were such a type class, how could it be total?  You can't constraint applications of intToE to expressions of the form eToInt
15:12:08 <Zemyla> > toEnum (fromEnum (3.5::Double)) == (3.5::Double)
15:12:09 <lambdabot>  False
15:12:24 <Zemyla> See, that's the thing I don't want.
15:13:56 <Zemyla> That is literally exactly the only thing I want, is for that equation tp always be True/
15:16:20 <johnw> > fromEnum (3.5 :: Double)
15:16:21 <lambdabot>  3
15:16:33 <johnw> this is impossible for the same reason
15:17:28 <johnw> oh, wait
15:17:40 <johnw> you're only going one way
15:18:06 <johnw> except that toEnum 3 will never be 3.5
15:21:14 <mitchty> anyone getting certificate expired errors when running hoogle data?
15:23:49 <Axman6> Zemyla: what are you expecting fromEnum (3.5 :: Double) to return which would allow toEnum to produce 3.5 again?
15:23:51 <Zemyla> johnw: That is why I want a separate class deriving from Enum that produces that guarantee.
15:24:16 <homovitruvius> Last time I went through RWH a couple of years ago, mtl was the thing for combining monads; now I have the feeling it is out of favor; what is the "modern" way for combining monads and what was wrong with mtl?
15:24:17 <Hijiri> what changes are in 7.8.4?
15:24:43 <geekosaur> homovitruvius, why do you have that feeling?
15:24:44 <Axman6> Hijiri: there will only be bug fixed for the features in 7.8
15:24:52 <Hijiri> oh
15:25:02 <Hijiri> what bugs were fixed? (or where can I find the changes)
15:25:07 <YellPika> See https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/release-7-8-4.html
15:25:09 <Axman6> 7.10 will have a bunch of new features though
15:25:13 <Hijiri> thanks yell
15:25:20 <geekosaur> there was an experiment with type families, which turned out to not be sufficient. mtl2 continues to use functional dependencies.
15:25:21 <Zemyla> Basically, I want the a guarantee that if eToInt a == eToInt b, then a == b.
15:25:26 <Hijiri> I know 7.10 has AMP and stuff
15:25:31 <Hijiri> and the bridge burning?
15:25:34 <Hijiri> was that 7.10?
15:25:51 <setpoint> > let f Just a = a; f Nothing = 0; in map f [Just 5, Nothing, Just 0]
15:25:52 <lambdabot>  Equations for ‘f’ have different numbers of arguments
15:25:52 <lambdabot>    <interactive>:1:5-16
15:25:52 <lambdabot>    <interactive>:1:19-31
15:26:01 <setpoint> > let f (Just a) = a; f Nothing = 0; in map f [Just 5, Nothing, Just 0]
15:26:03 <lambdabot>  [5,0,0]
15:26:05 <johnw> Zemyla: well, you could make such a class and state that it is one of the laws, but for totality you'll need to return a Maybe value from one of those functions, or raise an exception
15:26:09 <Axman6> Zemyla: so you want doubleAsInt64 :: Double -> Int64 and int64AsDouble :: Int64 -> Double?
15:26:43 <setpoint> can you have lesser sizes types than 32 bits?
15:26:57 <Iceland_jack> setpoint: Int8, Int16, Int32, ...
15:26:58 <Axman6> johnw: well, not if you did the equivalent of int ret = (int64_t)3.5
15:27:16 <Axman6> setpoint: yes, there are Int and Word 8, 16 32 and 64 types in Data.Word
15:27:25 <Iceland_jack> setpoint: the Ints are from Data.Int
15:27:36 <Axman6> (and Data.Int)
15:27:39 <setpoint> > let f (x::Int8) = (.&.) 1 x == 1 in f 1
15:27:40 <lambdabot>  True
15:27:52 <setpoint> > let f (x::Int8) = (.&.) 1 x == 1 in map f [0,1,2,3]
15:27:53 <lambdabot>  [False,True,False,True]
15:28:08 <homovitruvius> geekosaur: many places, but mainly http://stackoverflow.com/questions/2769487/mtl-transformers-monads-fd-monadlib-and-the-paradox-of-choice where it says that new project should use transformers and help to lay mtl to rest
15:28:39 <mitchty> specifically i'm seeing this, which is odd https://gist.github.com/mitchty/612cdbcd00941a75384b
15:29:24 <ReinH> The problem is that eToInteger is (hopefully) injective but can't be surjective for types with finite inhabitants
15:29:32 <geekosaur> homovitruvius, that is out of date. notably, mtl2 is *based* on transformers
15:29:48 <ReinH> while eToInt can only be surjective for types with the same number of inhabitants as Int, which isn't even portable...
15:30:03 <Zemyla> johnw: There are other ways besides Maybe or exceptions.
15:30:10 <Axman6> ReinH: it is with Int64 and Double no?
15:30:21 <Zemyla> For instance, it could wrap like a modulo.
15:30:23 <ReinH> Axman6: what is?
15:30:28 <geekosaur> the haskell ecosystem has enough major changes that cause thrashing. rather than transformers just replacing mtl, mtl more or less became transformers
15:30:30 <homovitruvius> geekosaur: thanks, so I take I'm good with mtl
15:30:35 <Axman6> nevermind
15:31:21 <geekosaur> so mtl1 is indeed dead and gone, and mtl2 is based on transformers,
15:31:38 <mitchty> nvm found this https://github.com/ndmitchell/hoogle/issues/92
15:31:48 <Zemyla> Axman6: No, I actually want it, since it's still derived from Enum, to have eToInt (succ x) = 1 + eToInt x.
15:31:48 <Axman6> mtl is dead, long live mtl!
15:31:58 <ReinH> you can't have a bijection without a surjection...
15:32:15 <Axman6> Zemyla: I don't believe that's possible
15:32:52 <Zemyla> Axman6: No shit it's not possible for Doubles, that's why Doubles wouldn't be in this class.
15:33:14 <Axman6> no need to be rude
15:33:19 <ReinH> Zemyla: what types *is* it possible for?
15:33:42 <Axman6> Integral a => a, for some a's at least
15:33:48 <ReinH> As far as I can tell, it is possible for types isomorphic to Int
15:33:49 <Axman6> >_>
15:33:55 <johnw> Zemyla: ah, true!
15:33:57 <Zemyla> Chars, Ints, classes with all-nullary constructors.
15:34:20 <ReinH> Zemyla: |Char| != |Int|
15:34:21 <Hijiri> succ of the biggest char will fail
15:34:29 <Hijiri> or be bottom
15:34:31 <ReinH> So there is no isomorphism
15:34:50 <Zemyla> Permutations would be a member of this class, because it's possible to convert a permutation to and from an integer.
15:34:51 <Axman6> > succ (maxBound :: Char) -- is Char Bounded...?
15:34:52 <lambdabot>  *Exception: Prelude.Enum.Char.succ: bad argument
15:35:16 <ReinH> Zemyla: Again, this only works for types with the same number of inhabitants as Int
15:35:23 <Zemyla> But I don't care about intToE being total.
15:35:44 <ReinH> if it isn't total then you don't have a bijection
15:35:48 <Hijiri> actually if succ is different from the real Enum succ, you could have it wrap around like Int does
15:35:53 <Hijiri> and then it would be true
15:36:01 <ReinH> since partial functions are not injective
15:36:06 <Zemyla> All I care about is that its domain is the same as the range of eToInt, and that if eToInt x == eToInt y, then x == y.
15:36:30 <ReinH> Zemyla: I thought you also wanted eToInt (succ x) = 1 + eToInt x
15:36:41 <ReinH> i.e. eToInt to be a homomorphism
15:37:20 <ReinH> as in eToInt (succ x) = succ (eToInt x)
15:38:46 <ReinH> if all you care about is eToInt x == eToInt y, then x == y then all you need is for eToInt to be injective, since that's the definition of injectivity
15:41:23 <Zemyla> Okay, what I want: (a) intToE (eToInt x) = x for all x. (b) eToInt x == eToInt y <=> x == y. (c) If succ x is defined, then eToInt (succ x) = 1 + eToInt x, and similarly for prec.
15:42:28 <ReinH> then you are restricted to types isomorphic to Int
15:42:45 <ReinH> since you are defining  exactly an isomorphism (a bijective homomorphism)
15:43:01 <Zemyla> Becaise right now, there are two categories of instances of Enum: Ones where toEnum and fromEnum work sensibly, and ones that just want enumFrom and enumFromTo.
15:43:26 <ReinH> right, but that's more useful than restricting Enum to types that are isomorphic to Int
15:43:55 <ReinH> which gives you maybe 2 default instances? Int and the equivalent unsigned int
15:44:05 <Zemyla> No, I'm saying the two sets of functions should be separated.
15:44:29 <ReinH> And I'm saying that your version of toEnum and fromEnum is basically useless in practice
15:44:44 <Zemyla> Also, there's lots of types where it works.
15:44:56 <ReinH> Yes, there are lots of types isomorphic to Int, but very few of them are interesting
15:45:11 <Zemyla> (Bounded a, Enum a, Enum b) => Enum (a, b), for instance.
15:45:20 <gdoteof> why does (_, Just stdOutHdel, _, _) <- createProcess (proc "tail -n 1 file" {std_out=CreatePipe}; and then reading from stdOUtHdel give me resource exhausted errors after a bunch of runs
15:45:32 <ReinH> Zemyla: That's just not true.
15:45:45 <ReinH> if a and b are isomorphic to Int, (a,b) is not isomorphic to Int
15:45:59 <gdoteof> but just doing `output <- readProcess "tail" ["-n", "1", "file"]` work fine?
15:46:05 <benzrf> ReinH: define iso
15:46:19 <ReinH> benzrf: I already did. An iso is a bijective homomorphism.
15:46:20 <geekosaur> gdoteof, are you ever reaping the created processes?
15:46:32 <Zemyla> ReinH: That's why I specified Bounded a.
15:46:34 <benzrf> ReinH: cause i'm pretty sure there's a bijection
15:46:41 <benzrf> ReinH: what kind of homomorphism, thne
15:46:50 <ReinH> Zemyla: There is only a bijection between sets/types with the same number of inhabitants
15:46:58 <ReinH> a bijects b <=> |a| = |b|
15:46:59 <gdoteof> geekosaur: I must not be; how does one reap a process?
15:47:32 <Zemyla> ReinH: There is definitely a bijection between ([0..n], Int) and Int.
15:47:40 <ReinH> Zemyla: no, there is not
15:48:00 <geekosaur> gdoteof, http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/process-1.1.0.2/System-Process.html#v:waitForProcess or http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/process-1.1.0.2/System-Process.html#v:getProcessExitCode
15:48:14 <ReinH> |a| * |b| = |b| iff |a| = 1
15:48:34 <Zemyla> toInt (a, b) = (n+1)*b + a, fromInt k = swap $ divMod k (n+1).
15:48:35 <gdoteof> geekosaur: oh okay, so i have to run one of those to consume the exit code or something?
15:48:36 <ReinH> (for finitary sets)
15:48:53 <geekosaur> (the latter is non-blocking. you should study the POSIX process model; processes "stick around" and count against your limit until you do something to accept the exit code)
15:48:55 <ReinH> and Int has a finite number of inhabitants
15:49:06 <gdoteof> it's not optional like i was assuming. "i don't care about the exit code" doesn't matter then
15:49:10 <geekosaur> and the OS will refuse to allow your uid to create new processes
15:49:27 <Zemyla> That's why I said Integer in my original definition, not Int.
15:49:30 <Hijiri> what's n
15:49:41 <Hijiri> oh
15:49:42 <ReinH> Zemyla: That is not a bijectino
15:49:43 <Hijiri> nevermind
15:49:50 <ReinH> It is literally impossible
15:49:56 <geekosaur> well, there is a way to do that; either double-fork or set the signal handler for SIGCHLD to SIG_IGN (the latter may also require some extra flags, e.g. on BSDish systems)
15:49:57 <ReinH> because of the pigeon-hole principle
15:50:32 <Hijiri> ReinH: are you still talking about the Int one or the Integer one?
15:50:35 <ReinH> |(a,b)| = |a| * |b|
15:50:40 <ReinH> Hijiri: he's saying Int so I am talking about Int
15:50:43 <Hijiri> ok
15:50:51 <gdoteof> geekosaur: okay, thanks a lot
15:51:01 <ReinH> (ignoring bottoms here, they don't change the result)
15:51:54 <ReinH> Zemyla: but right now you're talking about Int
15:51:59 <Zemyla> No, I was actually arguing about Integer.
15:52:11 <ReinH> Then why do you keep saying "Int"?
15:52:20 <geekosaur> also note that the SIGCHLD trick will break things like system/rawSystem, because they will wait for the process and then error out because the process was auto-reaped and therefore didn't return it an exit status
15:52:34 <geekosaur> the POSIX process model is a bit weird
15:52:46 <Zemyla> Because I'm typing on a screen keyboard and I'm avoiding extra keystrokes.
15:53:46 <ReinH> Zemyla: Uh. Int and Integer are pretty important to distinguish when they completely change your argument.
15:54:05 <ReinH> Either way you are limited to types of equivalent cardinality
15:54:28 <ReinH> whether that cardinality is machine word size or aleph_0
15:54:31 <Zemyla> ReinH: So what you're saying is that Bool can't be an Enum.
15:54:37 <ReinH> Correct.
15:54:49 <ReinH> There is no injection Int -> Bool or Integer -> Bool
15:55:00 <ReinH> Zemyla: using your definition of Enum
15:55:59 <Zemyla> (a) integerToE (eToInteger x) == x for all Bool. True.
15:56:20 <ReinH> True, but doesn't prove your point
15:56:23 <Zemyla> (b) eToInteger x == eToInteger y <=> x == y. True.
15:56:41 <ReinH> true
15:56:59 <ReinH> and (c)?
15:57:10 <Zemyla> (c) Where succ x is defined, eToInteger (succ x) = 1 + eToInteger x, and similarly for pred.
15:58:40 <ReinH> Ah, so you only want a homomorphism, not an isomorphism
15:59:09 <Zemyla> I said "where succ x" is defined when I defined (c) abovd.
15:59:09 <ReinH> a monomorphism, in fact
16:00:09 <ReinH> So you want Enum to be a unary algebra with a monomorphism to Integer
16:01:08 <Zemyla> Yes. We can separate out the enumFrom, enumFromTo, and such, perhaps have them be part od a superclass to Enum.
16:01:48 <ReinH> Zemyla: I seem to recall that you wanted a bijection, but this works
16:04:24 <Zemyla> Actually, pred and succ would be part of the superclass, too, because where succ x is defined, succ x = (enumFrom x) !! 1.
16:05:12 <Zemyla> [3..1]
16:05:20 <Zemyla> > [3..1]
16:05:22 <lambdabot>  []
16:08:05 <Axman6> @src enumFromTo
16:08:06 <lambdabot> Source not found. You type like i drive.
16:08:09 <Axman6> bleh
16:09:38 <Zemyla> take 10 [1e308..]
16:09:43 <Zemyla> > take 10 [1e308..]
16:09:44 <lambdabot>  [1.0e308,1.0e308,1.0e308,1.0e308,1.0e308,1.0e308,1.0e308,1.0e308,1.0e308,1.0...
16:10:26 <Zemyla> > (\(a:(b:_)) -> a == b) it
16:10:27 <lambdabot>  Not in scope: ‘it’
16:10:27 <lambdabot>  Perhaps you meant one of these:
16:10:27 <lambdabot>    ‘id’ (imported from Data.Function),
16:10:35 <Axman6> > let xs = [1e308 ..] in zipWith (<) xs (tail xs)
16:10:36 <lambdabot>  [False,False,False,False,False,False,False,False,False,False,False,False,Fal...
16:10:41 <Zemyla> > (\(a:(b:_)) -> a == b) [1e308..]
16:10:42 <lambdabot>  True
16:10:45 <Axman6> > let xs = [1e308 ..] in zipWith compare xs (tail xs)
16:10:46 <lambdabot>  [EQ,EQ,EQ,EQ,EQ,EQ,EQ,EQ,EQ,EQ,EQ,EQ,EQ,EQ,EQ,EQ,EQ,EQ,EQ,EQ,EQ,EQ,EQ,EQ,EQ,...
16:11:19 <benzrf> ouch
16:11:26 <benzrf> > [1e308..]
16:11:27 <lambdabot>  [1.0e308,1.0e308,1.0e308,1.0e308,1.0e308,1.0e308,1.0e308,1.0e308,1.0e308,1.0...
16:12:20 <Zemyla> Why are toEnum and fromEnum defined in terms of Int?
16:15:31 <u-ou> because Ints are good for enumerating? :P
16:16:14 <Axman6> because the Prelude isn't perfect
16:17:06 <geekosaur> because there's little point in enumerating something that doesn't fit in a machine word, especially when the Enum stuff includes list methods and a list's length must fit in a machine word?
16:17:12 <Axman6> a lot of it is pretty good, but there are plenty of things that would be done differently if it were written again today (some of which are slowly happening)
16:19:04 <Axman6> well, a list's length doesn't need to fit into a machine word really
16:20:17 <Zemyla> But yeah, it occurs to me that (EnumPlus a, EnumPlus b) => EnumPlus (a, b) and (Bounded a, EnumPlus a, EnumPlus b) => EnumPlus (a, b) would be enumerated differently, and the latter would probably be a newtype wrapper.
16:26:46 <jonsterling> carter: Thanks! :)
16:28:38 <hodapp> https://ghc.haskell.org/trac/ghc/wiki/DependentHaskell - what does "One says that compile-time arguments are elided in runtime code." mean, if anyone can shed some light?
16:29:16 <Zemyla> > [3..3.1]
16:29:17 <lambdabot>  [3.0]
16:29:35 <Zemyla> > [3,3.1..3.1]
16:29:36 <lambdabot>  [3.0,3.1]
16:30:55 <Zemyla> Hmm, why don't Enum and Eq together imply Ord?
16:31:47 <Zemyla> compare a b = if a == b then EQ else if null (enumFromTo a b) then GT else LT
16:34:23 <Cale> Zemyla: It's best not to think of Enum as meaning anything beyond "how the list sequence syntax works for this type"
16:34:58 <Cale> > [3 .. 2.9]
16:35:00 <lambdabot>  [3.0]
16:35:10 <Zemyla> ...
16:35:27 <enthropy> hodapp: I think it means the same thing as "type erasure"
16:35:32 <Cale> (because 2.9 is within a half step from 3.0)
16:35:42 <Cale> > [3 .. 2.4]
16:35:43 <lambdabot>  []
16:35:50 <Cale> > [3 .. 2.51]
16:35:52 <lambdabot>  [3.0]
16:35:55 <Cale> > [3 .. 2.49]
16:35:57 <lambdabot>  []
16:36:40 <enthropy> that things like "which dictonary to use for a Num instance" is decided at compile time (at least if you're not using -XRankNTypes or -XGADTs)
16:37:09 <Cale> I'm not sure that I agree with this precise feature of the Enum instance for Float/Double, but it's understandable why it works that way if you think about how these types are meant for approximate numbers.
16:37:23 <Axman6> Zemyla: there may be types which you with to be able to test for equality, and enumerate, but Ord doesn't really make sense for
16:38:01 <Axman6> (though I can't think of a great example off the top of my head; perhaps n dimensional coordinates?)
16:38:04 <hodapp> enthropy: I suppose then I should get a handle on what 'type erasure' means.
16:39:36 <geekosaur> any type representing more than one dimension; most commonly, Complex which is often taken as representing vectors
16:40:04 <Zemyla> How is Complex an Enum?
16:40:29 <Cale> It's not
16:40:32 <geekosaur> it could be, perhaps not usefully for the same reason
16:40:59 <Cale> But yeah, it definitely could be
16:41:00 <zer0veritas> what are some good Haskell compilers and references for a noob with exprience in java/ruby/py
16:41:12 <jle`> compilers written in haskell?
16:41:21 <jle`> or haskell compilers?
16:41:31 <zer0veritas> haskell compilers
16:41:34 <geekosaur> (tus it is not. for the same reason indeed; I am not sure that there are types for which Ord is not meaningful but which could usefuly be Enum.)
16:41:34 <jle`> the main player in town is ghc
16:41:40 <Cale> enumFromThenTo is weird when you might travel in the wrong direction to hit the target
16:41:57 <Cale> Though I guess you could define it using splines of some sort :)
16:42:05 <zer0veritas> ghc ok thanks I will check it out
16:42:28 <jle`> np, if you're new you might want to check out a course or something too :)
16:42:29 <geekosaur> more practically, what is succ for a given Complex and what does it mean? it fails the same sanity test as Ord
16:42:41 <Cale> Well, succ and pred don't really belong
16:42:48 <jle`> there's a nice one in the topic of #haskell-beginners
16:43:18 <Cale> (Personally, I wouldn't miss them if they were deleted from the definition of Enum)
16:44:01 <geekosaur> mm, how do you define enumerating from something without a notion of a successor to the thing being enumerated from?
16:44:29 <Axman6> zer0veritas: step one for java/ruby/python developers learning Haskell is: forgot everything you think you know about programming. Things you took for granted as The Way to Do It actually turn out to just be one of many
16:45:06 <Cale> Just think of enumFrom, enumFromTo, enumFromThen and enumFromThenTo as being definitions for the [a..], [a..b], [a,b..] and [a,b..c] syntaxes respectively.
16:45:26 <Cale> They're defined however you want to define them, in whatever way makes sense for the given type
16:46:40 <geekosaur> mm. on the one hand, there seems to be a lot of interest in maintaining mathematical relationships. on the other, that's not a battle I'm particularly interested in championing
16:46:43 <Cale> They're all pretty much law-free to begin with, so might as well just go all the way there.
16:47:04 <geekosaur> but yes, the current Enum is rather dubious in that area anyway...
16:47:06 <Cale> If we want a class for succ and pred, it should be a different one
16:47:42 <Cale> (maybe that should still be Enum, but then move all the other methods elsewhere, but personally, I think succ and pred are a bit silly... who honestly uses those polymorphically?)
16:48:47 <EvanR> safe enum package
16:48:57 <geekosaur> well, if we really wanted to fix the mess, we know pretty well how to go about it... but there seems to be no real interest in doing so
16:49:07 <EvanR> though just maybe-ifying something, however safe, doesnt make it "right"
16:49:10 <Zemyla> Cale: Like I said before, succ x = (enumFrom x) !! 1.
16:50:02 <Cale> Zemyla: Maybe, but is that really useful? I don't think that operation deserves a name.
16:50:29 <Cale> (nevermind the fact that it's really dangerous)
16:56:01 * hackagebot error-continuations 0.1.0.0 - Error Continuations  http://hackage.haskell.org/package/error-continuations-0.1.0.0 (echatav)
17:05:11 <hodapp> Homotopy type theory book is only... $21.83?
17:05:14 <hodapp> A new textbook?
17:05:19 <hodapp> What alternate universe am I in?
17:05:23 <vanila> its online free
17:05:39 <hodapp> yes, I know
17:05:55 <hodapp> but I'm used to seeing new textbooks with an extra digit in the price
17:06:20 <vanila> maybe grab a few copies before they notice :p
17:11:28 <hodapp> vanila: perhaps I should.
17:12:46 <Pamelloes> How much of a performance hit will I take for making large parts of a program IO?
17:15:34 <solatis> hmmm, this is quite a beginner question, but how do i 'lift' an EitherT String IO MyType to an EitherT String (ResourceT IO) MyType ?
17:16:54 <jle`> looks like hoist liftIO?
17:17:04 <jle`> solatis: from mmorph
17:17:12 <solatis> let me google that
17:17:31 <jle`> or hoist lift too
17:17:45 <jle`> but the former is probably more 'scalable"
17:18:12 <solatis> looks promising, let me try that out
17:18:51 <jle`> hoist :: (forall a. m a -> n a) -> EitherT String m b -> EitherT String n b
17:19:04 <jle`> so you use your (m a -> n a) as liftIO :: IO a -> ResourceT IO a
17:19:16 <jle`> if ResourceT is indeed MonadIO
17:21:04 <solatis> yeah
17:21:51 <Zemyla> Hmm, why isn't length defined in Data.Foldable?
17:22:54 <Zemyla> :t getSum
17:22:55 <lambdabot> Sum a -> a
17:23:41 <Zemyla> :t getSum . foldMap (const $ Sum $ 1::Int)
17:23:42 <lambdabot>     Couldn't match expected type ‘Int’ with actual type ‘b0 -> Sum s0’
17:23:42 <lambdabot>     In the first argument of ‘foldMap’, namely
17:23:42 <lambdabot>       ‘(const $ Sum $ 1 :: Int)’
17:23:52 <Zemyla> :t getSum . foldMap (const $ Sum $ (1::Int))
17:23:52 <lambdabot> Foldable t => t a -> Int
17:25:16 <solatis> hmmm
17:25:23 <solatis> jle`: i'm getting this error:
17:25:28 <solatis>     No instance for (MFunctor (EitherT String))
17:25:34 <solatis>       arising from a use of ‘hoist’
17:25:34 <solatis>     In a stmt of a 'do' block: ciphers <- hoist liftIO (phase2 sockets)
17:25:56 <jle`> oh huh.
17:26:17 <solatis> let me just create an lpaste for this
17:26:44 <jle`> no it makes sense
17:26:49 <jle`> i don't see an instnace anywhere
17:26:54 <jle`> i'm just confused as to why there isn't an instnace anywhere
17:26:58 <solatis> it does?
17:27:06 <jle`> yeah http://www.stackage.org/haddock/nightly-2015-01-04/resourcet-1.1.3.3/Control-Monad-Trans-Resource.html
17:27:12 <jle`> oh wrong link
17:27:14 <jle`> http://hackage.haskell.org/package/mmorph-1.0.4/docs/Control-Monad-Morph.html
17:27:30 <jle`> there is an obvious instance but it isn't there
17:27:34 <jle`> and it isn't in the `either` package either
17:27:37 <jle`> what gives
17:27:55 <solatis> maybe i should start using ErrorT instead ?
17:27:59 <jle`> nah
17:28:38 <jle`> this is weird.  any comments from the maintainer of the `either` package edwardk ?
17:28:55 <jle`> i guess would it belong in mmorph w/ Tekmo?
17:29:03 <solatis> edwardk: ^^
17:30:05 <solatis> so, what would the short-term solution to this be ? define the instance myself ?
17:30:13 <jle`> that's what I would do
17:30:36 <jle`> i tried writing it out here but i can't it to look too clean in one line for IRC
17:30:53 <jle`> but you can just look at the instance for ErrorT and it should pretty much be identical
17:31:10 <jle`> oh
17:31:13 <jle`> heh.
17:31:14 <solatis> ok, i'll work from that, thanks
17:31:34 <solatis> maybe i should be using ErrorT instead.. i'm using my strings as errors anyway
17:31:42 <jle`> instance MFunctor (EitherT e) where hoist f x = EitherT (f (runEitherT  x))
17:32:11 <benzrf> wagh
17:32:16 <Welkin> jle`: am I using `use` correctly here? http://lpaste.net/117764
17:32:34 <Welkin> the errors are at the bottom
17:32:44 <jle`> what is use?
17:32:47 <Welkin> from lens
17:32:48 <solatis> jle`: awesome, that works
17:33:13 <jle`> oh, i'm not sure, sorry.  not too familiar with those statey lens idioms
17:33:31 <benzrf> Welkin: ill have a look
17:38:01 <Welkin> benzrf: any luck?
17:38:05 <benzrf> oh crap
17:38:08 <benzrf> sorry i was distracted
17:38:13 * benzrf looks
17:38:16 <Welkin> or am I not doing what I think I am
17:39:23 <benzrf> you are not doing what you think you are
17:39:26 <benzrf> (.) is lens composition
17:39:29 <benzrf> actually
17:39:32 <benzrf> it's normal function composition
17:39:38 <benzrf> but lenses in the lens library are functions
17:39:46 <Welkin> okay
17:40:01 <Welkin> how do I read the value of something inside my state?
17:40:17 <benzrf> Welkin: use, if you're using a lens
17:40:30 <benzrf> src :: Int, right?
17:40:32 <hrumph> are lenses worth learning about?
17:40:37 <Welkin> well
17:40:43 <hrumph> are lenses a lot harder to understand than monads?
17:40:47 <Welkin> I have a class HasPlayers
17:40:56 <Welkin> player :: Int -> Lens' Game Player
17:41:01 <hrumph> i struggled quite a bit with monads before I got confortable with them
17:41:15 <hrumph> so lenses seem a bit daunting
17:42:12 <Axman6> the idea behind lenses is quite simple. their implementation in Haskell isn't as clear as the obvious implementation of them, but has many advantages
17:42:16 <Welkin> hrumph: just jump in and swim around; that's what I'm doing
17:42:32 <benzrf> Axman6: do you mean "their implementation in the lens package"
17:42:33 <EvanR> is there a "unsafe" way to pass a mutable array to something expecting a pure array, if you can prove its not going to be modified
17:42:33 <benzrf> :P
17:42:43 <Axman6> benzrf: well, yes
17:42:47 <Welkin> benzrf: so any feedback?
17:42:49 <EvanR> rather than making a copy of it
17:42:53 <benzrf> Welkin: you're doing a few things wrong >.>
17:42:59 <Welkin> please tell
17:43:11 <benzrf> Welkin: you seem to be randomly mixin and matchin operators and functions and lenses
17:43:16 <benzrf> based on what looks vaguely apropos
17:43:19 <benzrf> that's bad!
17:43:27 <benzrf> make sure you are comfortable with how each thing works
17:43:31 <Welkin> I thought lenses were just functions
17:43:42 <benzrf> yeah, but that's an implementation detail
17:43:44 <benzrf> Welkin: are you already good with the state monad
17:43:45 <Axman6> hrumph: edwardk has a set of videos discussing the more trivial implementation of them in scala which is quite good. he's also got one which is a bit more indepth and covers the lens library's implementation
17:43:45 <Welkin> well, everything is a function
17:43:59 <Welkin> I feel comfortable with State now, yes
17:44:15 <benzrf> ok!
17:44:18 <hrumph> i'm good with the state monad
17:44:24 <EvanR> :t Data.Array.Unsafe.unsafeFreeze
17:44:25 <lambdabot> (Data.Array.Base.MArray a e m, Data.Array.Base.IArray b e, Ix i) => a i e -> m (b i e)
17:44:28 <EvanR> nice
17:44:30 <benzrf> Welkin: are you comfortable with lenses /outside/ of the state monad?
17:44:33 <hrumph> i wrote an extension of the state monad just yesterday
17:44:47 <Welkin> benzrf: ^. is a getter, .~ is a setter
17:44:52 <Welkin> that's about all
17:45:04 <hrumph> if i have some ideas for submission to hackage what do i do?
17:45:04 <benzrf> yes you should probably be a bit more comfortable first!
17:45:10 <benzrf> hrumph: upload it
17:45:18 <benzrf> hrumph: anybody can make an account and then submit packages
17:45:22 <Axman6> @hoogle mapping
17:45:24 <lambdabot> Graphics.Rendering.OpenGL.GL.BufferObjects MappingFailed :: MappingFailure
17:45:24 <lambdabot> Graphics.Rendering.OpenGL.GL.BufferObjects data MappingFailure
17:45:24 <lambdabot> package bson-mapping
17:45:30 <hrumph> benbangert, how does it then get included in cabal?
17:45:30 <Axman6> bleh
17:45:34 <benzrf> hrumph: if you mean a specific library, then you can get in contact with the authors
17:45:43 <benzrf> hrumph: cabal-install syncs a package list from hackage
17:45:46 <benzrf> it's not hard coded
17:45:59 <hrumph> benzrf, i just made something which is pretty neat and might even be unusual
17:46:12 <benzrf> hrumph: build it & uplaod it!
17:46:18 <benzrf> (make a hackage acct first)
17:46:18 <Welkin> benzrf: all the tutorials are either too abstract (too much math) or too basic
17:46:27 <benzrf> Welkin: i can help!
17:46:29 <benzrf> probably!
17:46:36 <Welkin> where is a practical quickstart for using lens with state?
17:46:41 <marioxcc> Hi.
17:46:43 <Axman6> or, discuss it here first, then possible build it and upload it, if it's something useful
17:46:49 <Axman6> possibly*
17:46:49 <hrumph> benbangert, how do i get it listed as a cabal package after putting in hackage?
17:47:08 <benzrf> Welkin: try understandin lens outSIDE of state first
17:47:15 <Welkin> okay
17:47:18 <benzrf> Welkin: do you follow what a "Lens s t a b" is?
17:47:23 <hrumph> Axman6, i don't think i'll discuss it for a while....its *secret* heeh.....i know that generally means its crap but whatever i'm stuck in my ways
17:47:34 <Welkin> no
17:47:47 <Welkin> is it a function from a -> b ?
17:47:50 <hrumph> but onces its all done i've love to upload it
17:47:55 <benzrf> Welkin: therein lies the problem!
17:48:01 <Welkin> it reminds me of arrows a bit
17:48:02 <Axman6> hrumph: fair enough. you will probably find that there's already asomething that does it though (that's usually my experience when I think I've done something new)
17:48:08 <benzrf> Welkin: a lens can be thought of as a pointer to part of something
17:48:14 <zzing> If I wanted an intercalate for a sequence, does there exist an equivalent method?
17:48:15 <marioxcc> Hi. Is it possible to define in Haskell an infinite binary tree?
17:48:19 <Welkin> what is s t a b ?
17:48:23 <benzrf> type arguments
17:48:27 <EvanR> marioxcc: yes
17:48:29 <Welkin> I know
17:48:30 <Axman6> marioxcc: yes, trivially
17:48:30 <benzrf> Welkin: a "Lens s t a b" is a Lens that:
17:48:33 <Welkin> but what are they for?
17:48:36 <benzrf> Welkin: 1. operates on values of type s
17:48:48 <benzrf> Welkin: 2. focuses on a value of type a within a given s
17:48:50 <EvanR> marioxcc: or any tree
17:48:51 <Axman6> > let t = Node 1 [t,t] in t
17:48:52 <lambdabot>  Node {rootLabel = 1, subForest = [Node {rootLabel = 1, subForest = [Node {ro...
17:48:57 <enthropy> Welkin: (s -> a, b -> s -> t)
17:49:05 <marioxcc> I'm trying to define a function that evaluates to (1 (2, (4, 5, ...) (3 (6, 7, ...))))
17:49:05 <benzrf> Welkin: 3. can produce a t as an output, by 3. replacing an a with a b
17:49:11 <Axman6> there are more useful binary trees than that one though
17:49:16 <benzrf> Welkin: enthropy just pasted what it denotes
17:49:17 <enthropy> but defined in a better way
17:49:19 <marioxcc> but I get a type complain from GHC about the infinite data type.
17:49:45 <EvanR> dont try to infinitely nest t = (t,t)
17:49:45 <marioxcc> How should I define it? With lists?.
17:49:55 <EvanR> data Tree a = Tree a [Tree a]
17:49:56 <benzrf> Welkin: denotationally, data Lens s t a b = {getter :: s -> a, setter :: b -> s -> t}
17:50:03 <Axman6> marioxcc: then you've written something which doesn't make sense and you have a type error
17:50:14 <Axman6> marioxcc: want to share the code?
17:50:17 <benzrf> Welkin: so, _1 :: (x, t) (y, t) x y
17:50:30 <marioxcc> Axman6: Sure, I'm trying to do “dftree n = (n, dftree (n * 2), dftree (1 + (n * 2)))” (For “depth first”).
17:50:36 <benzrf> Welkin: because used as a getter it is (x, t) -> x, and as a setter it is y -> (x, t) -> (y, t)
17:50:59 <Welkin> okay
17:51:08 <Axman6> marioxcc: yeah you can'y do that because the type will be infinite. you probably want to define your own data type instead of using tuples
17:51:09 <marioxcc> and I want to get (1 (2, (4, 5, ...) (3 (6, 7, ...))))
17:51:19 <marioxcc> Axman6: ok, thanks.
17:51:28 <Axman6> marioxcc: what would the type of that expression be?
17:51:54 <marioxcc> Axman6: I thought it'd be a tuple.
17:52:07 <Axman6> but what are the types of the elements of the tuple?
17:52:08 <marioxcc> But now I recall that there isn't a single tuple type, right?.
17:52:25 <Welkin> benzrf: so what else?
17:52:27 <benzrf> Welkin: ok, so
17:52:30 <Welkin> that is the type
17:52:53 <benzrf> Welkin: (.) :: Lens s t a b -> Lens a b x y -> Lens s t x y
17:54:02 <marioxcc> I'm just learning Haskell. Is it possible to use types to assure a program formal correctness?.
17:54:39 <vanila> marioxcc, not really
17:54:41 <Welkin> benzrf: okay, it composes two lenses
17:54:46 <marioxcc> vanila: Ok.
17:54:47 <vanila> they do help a lot
17:54:55 <marioxcc> Ok.
17:55:00 <Axman6> marioxcc: well, if you have a look at the type, it would look something like: dftree :: Int -> (Int,(Int,(Int,(Int,(Int... (on forever),(Int,(Int,(Int,(Int...(on forever again)
17:55:12 <benzrf> Welkin: so it doesnt make sense to use (.) on 2 things that are not lenses
17:55:19 <marioxcc> Axman6: Ok, so is that invalid?.
17:55:24 <zzing> marioxcc, formal correctness is much harder, which is why it isn't seen a lot because of the work involved.
17:55:30 <Welkin> but I thought source :: Lens' Game Player
17:55:31 <benzrf> and in particular it doesn't make sense to use then on 2 lenses where the 2nd one doesnt focus on the thing the 1st one focuses on
17:55:40 <benzrf> Welkin: Lens' s a = Lens s s a a
17:55:41 <Welkin> source = player 0
17:55:48 <Welkin> player :: Int -> Len's Game Player
17:56:08 <benzrf> oooooh
17:56:12 <benzrf> that's what the ints are, derp
17:56:22 <Axman6> marioxcc: you can do a lot with the type system to make illegal state unrepresentable, but things like non-termination (infinite recursion, exceptions etc.) mean that you can make programs which aren't correct because they fail to give a result, for example
17:56:29 <marioxcc> zzing: Ok, thanks.
17:56:44 <Axman6> marioxcc: no, haskell doesn't allow infinite types (how would be be able to type check something with an infinite type?)
17:56:46 <Welkin> the Players are stored in a Map Int Player
17:57:32 <Welkin> so why doesn't this work?
17:57:49 <benzrf> Welkin: first off
17:57:53 <marioxcc> Axman6: Well, it's reasonable to expect that it would, even if it's not the case; for instance, some prolog implementations can do unification where the solution is recursive (and hence infinite)
17:57:56 <benzrf> Welkin: that should be use (source.strength)
17:58:06 <benzrf> Welkin: otherwise it parses as (use source).strength
17:58:15 <marioxcc> Like: the solution to b = (b) is b=(((...)))
17:58:27 <marioxcc> Though, I get that it doesn't, I was only asking :).
17:58:32 <vanila> ocaml has a flag to allow recursive types
17:58:37 <mgsloan> In order to do that, Haskell would need to make up recursive data types on the fly, which usually isn't what you want :)
17:58:45 <vanila> hsakell doesnt allow it though
17:58:47 <mgsloan> Better to be explicit about your data's recursion
17:59:22 <marioxcc> mgsloan: Ok.
17:59:51 <marioxcc> Well, thanks you (generic “you”) for the answers.
18:00:25 <benzrf> Welkin: second off
18:00:32 <benzrf> Welkin: do you know what use does?
18:01:23 <Welkin> it is a getter for state?
18:02:21 <benzrf> sort of
18:02:57 <benzrf> use :: Lens s t a b -> State s a -- actually, more general!
18:03:08 <Welkin> based on my error now, it expects Char, but is getting String
18:03:13 <benzrf> Welkin: so, use (source.strength) :: ?
18:03:16 <Welkin> it is, and should be, a String
18:03:21 <benzrf> wrong!
18:03:24 <Welkin> for source.name
18:03:25 <benzrf> Welkin: think it over!
18:04:27 <Welkin> use (source.strength) :: State Game Int ?
18:06:28 <Welkin> benzrf: are you still there?
18:07:16 <benzrf> yeah
18:07:20 <benzrf> and yes that is correct
18:08:17 <Welkin> so how do I use `use` then?
18:08:40 <Welkin> can I not just place it in a do-block with all the other stateful computations?
18:09:30 <Welkin> how do I get the result (Int)?
18:10:05 <Shellbee> ya i dont use godaddy, ridiculous fees and my pages load slow. I use these guys, lots of free bonuses and I never once had any issues for the past 3 yrs. My host is http://www.arvixe.com/9429.html
18:10:39 <vanila> ??????????????
18:11:03 <vanila> @where ops
18:11:04 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
18:11:04 <Welkin> benzrf: it's not helpful if you don't respond
18:11:05 <Zemyla> Are sequences actually just "lists but better", or is there some reason you would use a list over a sequence?
18:11:14 <benzrf> Welkin: sorry!
18:11:19 <EvanR> thanks shellbee ill check that out
18:11:21 --- mode: ChanServ set +o dibblego
18:11:22 <EvanR> NOT
18:11:23 <benzrf> i'm active in another window and dont realize you're talking to me >.>
18:11:32 --- mode: dibblego set -o dibblego
18:11:37 <lumo_e> hi
18:11:38 <benzrf> Welkin: the return value of use is a state action
18:11:43 <benzrf> you can use it just like any other state action
18:11:57 <lumo_e> is haskell.org going to be usable anytime soon?
18:12:10 <Welkin> what do you mean by state action?
18:12:18 <Welkin> get, put, modify?
18:12:35 <EvanR> Zemyla: Data.Sequence ? surely has more overhead than a basic list if you dont need it dont use it
18:12:56 <EvanR> and i dont think there is "sequence fusion"
18:13:01 <geekosaur> lumo_e, best asked in #haskell-infrastructure; but the problem is known, it's what to do about it that is proving difficult
18:13:10 <wabash> Holy crap, haskell is popular
18:13:59 <Zemyla> EvanR: What do you mean, sequence fusion?
18:14:14 <Zemyla> Oh, lists can be lazy, that is a plus of them.
18:14:16 <EvanR> theres an optimization called list fusion which is cool
18:14:19 <Axman6> wabash: ssh, don't tell anyone
18:14:29 <lumo_e> geekosaur, I see
18:14:31 <EvanR> Zemyla: also lists can be infinite
18:14:40 <lumo_e> I hope it gets back soon
18:14:53 <Welkin> benzrf: that is not the only problem
18:14:55 <lumo_e> is there any other resource I can use to replace hoogle?
18:15:15 <Welkin> `target,health -= damage` also gives me errors
18:15:23 <Welkin> target = player 0
18:15:36 <erikd> @google hayoo
18:15:37 <lambdabot> http://hayoo.fh-wedel.de/
18:15:37 <lambdabot> Title: Hayoo! Haskell API Search
18:15:40 <Welkin> target.health -= damage
18:15:53 <erikd> lumo_e: see hayoo
18:16:11 <benzrf> Welkin: what else?
18:16:24 <benzrf> Welkin: target.health -= damage should be fine...
18:16:26 <wabash> pinebanner: hello
18:16:27 <benzrf> as long as damage is an Int!
18:16:35 <lumo_e> erikd, omg I thought you were joking ahah
18:16:37 <lumo_e> thanks a lot
18:16:50 <Axman6> wabash: you told someone!
18:17:01 <wabash> hitori dake!!!!!!!
18:17:33 <Zemyla> EvanR: But for strict, finite lists, Sequence is almost always better?
18:17:36 <geekosaur> lumo_e: short version is haskell.org was transitioned to new infrastructure in a hurry when hardware backing the old one died, and some parts that need to communicate for the wiki to work are now poorly connected with no quick fix available.
18:17:37 <Welkin> benzrf: http://lpaste.net/117764
18:17:41 <Welkin> I updated it
18:17:45 <Welkin> those are my errors
18:17:54 <EvanR> Zemyla: i doubt it
18:17:56 <Welkin> it complains about target, health, damage, and many others
18:17:57 <geekosaur> and there area number of people annoyed (or worse) over it,,,
18:18:25 <Axman6> Zemyla: sequence is good for if you need access to the end of the list as well as the head, and also if you need to index particular elements in better than O(n) time
18:18:31 <lumo_e> geekosaur, what do you mean by poorly connected?
18:19:03 <EvanR> if you need a list for what lists are good at, and thats it, then Sequence takes up more memory and is slower
18:19:08 <geekosaur> "halfway across the world from each other" is what's usually mentioned over in #h-i; I don't know details, I'm not on the infrastructure team
18:19:17 <Romefeller> someone here has deployed a haskell app to heroku?? Im having trouble with the push. Can anyone help me?
18:19:26 <lumo_e> ok thanks
18:19:34 <Welkin> Romefeller: join #haskell-deployment
18:19:34 <geekosaur> lots of communication timeouts between the web server and the database, is what I am seeing
18:19:37 <marioxcc> Hi. What's the difference between “function [x:y]” and “function (x:y)”?.
18:19:41 <Romefeller> Welkin thx
18:19:41 <benzrf> Welkin: fyi:
18:19:51 <benzrf> Welkin: lenses are overkill for your attack' function
18:19:56 <lumo_e> indeed it's a major problem, as a beginner my primary instrument is searching on google
18:19:57 <vanila> marioxcc, [x:y] is (x:y):[]
18:19:58 <benzrf> you can just pattern match on the inputs
18:20:08 <vanila> its a list of lists
18:20:08 <lumo_e> and a lot of google top results point to haskell.org wiki
18:20:09 <Welkin> benzrf: that should be deleted
18:20:18 <Welkin> benzrf: I replaced it with attack, below
18:20:19 <lumo_e> not being able to read them is a pity
18:20:43 <Zemyla> Axman6: The other big thing is O(log n) append.
18:20:54 <Axman6> right
18:20:56 <marioxcc> vanila: Ok, I see.
18:21:26 <Axman6> though you can get O(1) append with lists using DList
18:21:39 * shapr reacts far too late
18:21:40 <Axman6> well, sort of
18:21:57 <platz> Romefeller: I haven't used this but might be of interest to you https://halcyon.sh
18:22:10 <benzrf> Welkin: ok
18:22:31 <benzrf> Welkin:       target.health -= damage is perfectly fine, once damage is defined
18:22:39 <benzrf> however, as it is, damage is meaningless
18:22:49 <benzrf> it's not well-typed
18:22:58 <Zemyla> Axman6: It's not really append, it's function composition, which has its own overhead.
18:23:42 <Axman6> sure, but you do get much better performance for append only workloads which would be O(n^2) for plain lists
18:24:11 <Welkin> benzrf: so what's the problem?
18:24:25 <EvanR> i think we should try to establish exactly what kind of overhead function composition has in ghc typical usage
18:24:31 <EvanR> before we become scared of it
18:24:51 <vanila> function composition should have zero overhead
18:24:55 <EvanR> good ;)
18:25:21 <vanila> oh you're talking about DLists
18:25:24 <benzrf> Welkin:
18:25:25 <benzrf>         damage = atk - def
18:25:34 <benzrf> Welkin: State Game Int <- this is not a Num
18:25:35 <vanila> it would be best to see the zseq paper
18:25:36 <Axman6> well, for something like DList there's some allocation, but the overhead is quite small
18:25:41 <vanila> this covers all that stuff very thoroughly
18:25:59 <Welkin> benzrf: I see that, but how do I fix it?
18:26:14 <Welkin> do I use evalState to pull it out?
18:26:19 <benzrf> Welkin: sounds silly to me
18:26:36 <EvanR> is there a way to map the elements of an array but allowing the function to know what index it is at?
18:26:37 <benzrf> personally i'd move anything that relies on atk and def's Int values inside of the State monad
18:27:18 <Axman6> @hoogle (i -> a -> b) -> Array i a -> Array i b
18:27:19 <lambdabot> Data.Array accum :: Ix i => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e
18:27:19 <lambdabot> Data.Array.IArray accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
18:27:31 <EvanR> accum might work but
18:27:39 <Welkin> benzrf: that doesn't explain very much
18:27:53 <Welkin> I need the atk and def value before I even enter the do-block
18:27:55 <Axman6> hmm. I think some of the array libraries supply a mapWithIndex function
18:28:00 <Axman6> @goofle mapWithIndex
18:28:02 <lambdabot> http://www.scala-lang.org/old/node/1569.html
18:28:02 <lambdabot> Title: mapWithindex | The Scala Programming Language
18:28:06 <EvanR> goofle
18:28:14 <Axman6> @suffle mapWithIndex
18:28:14 <lambdabot> Unknown command, try @list
18:28:17 <Axman6> :(
18:28:26 <Axman6> @hoogle mapWithIndex
18:28:26 <lambdabot> Data.Sequence mapWithIndex :: (Int -> a -> b) -> Seq a -> Seq b
18:28:29 <benzrf> Welkin: no, just make the decision from within it
18:28:48 <EvanR> :t amap
18:28:48 <lambdabot>     Not in scope: ‘amap’
18:28:48 <lambdabot>     Perhaps you meant one of these:
18:28:48 <lambdabot>       ‘fmap’ (imported from Control.Monad.Writer),
18:30:04 <benzrf> what is amap
18:33:13 <Welkin> benzrf: I still don't understand how you are proposing I do this
18:33:22 <Welkin> can you show me a concrete example?
18:33:34 <benzrf> do
18:33:37 <benzrf>   atk <- use (source.strength)
18:33:41 <benzrf>   def <- use (target.strength)
18:33:53 <Welkin> I did that
18:33:54 <benzrf>   if atk >= def
18:33:59 <Welkin> I get the same errors
18:34:01 <benzrf>     then
18:34:08 <benzrf> Welkin: paste code
18:35:09 <Welkin> http://lpaste.net/117764
18:36:06 * hackagebot helm 0.7.0 - A functionally reactive game engine.  http://hackage.haskell.org/package/helm-0.7.0 (ZackCorr)
18:37:00 <dmj`> given two UUID's what's the best way to generate (or blend) them into a new UUID
18:37:41 <johnw> XOR?
18:38:12 <Axman6> that might cause strange results if they come from the same source; isn't there some machine specific (or derived) info in a UUID?
18:38:19 <johnw> ah, true
18:39:41 <Axman6> dmj`: I'm not sure that doing that is a great idea to begin with, unless you need to be able to get the previous UUIDs from the new one some how (so you need some kind of reversible process)
18:41:08 <dmj`> Axman6: no need for a reversible process, I just need to blend them into a new one, w/o violating the properties of a uuid, I want UUIDs to be monoids
18:41:13 <EvanR> :t range
18:41:13 <lambdabot> Ix a => (a, a) -> [a]
18:41:50 <Axman6> seems like that might run counter to the purpose of UUIDs
18:41:55 <Axman6> but I could be wrong
18:45:49 <Welkin> benzrf: anything?
18:46:06 * hackagebot postgresql-typed 0.3.0 - A PostgreSQL access library with compile-time SQL type inference  http://hackage.haskell.org/package/postgresql-typed-0.3.0 (DylanSimon)
18:49:41 <benzrf> so
18:49:43 <benzrf> rry
18:49:51 <benzrf> ;-;
18:49:52 <benzrf> looking now
18:50:17 <Welkin> benzrf: I've been working at this for hours and am ready to give up soon
18:50:49 <benzrf> :t (-=)
18:50:50 <lambdabot> (MonadState s m, Num a) => ASetter' s a -> a -> m ()
18:50:57 <benzrf> p:
18:51:04 * zzing loves Debug.Trace
18:51:38 <Welkin> I know -= is a setter
18:52:37 <benzrf> Welkin: honestly lens seems entirely unnecessary here
18:52:43 <benzrf> you could just pattern match on the entire state
18:52:52 <Welkin> benzrf: it will be more complicated
18:52:55 <benzrf> ok
18:52:57 <Welkin> I am just getting started
18:53:10 <Welkin> I am trying to build a minimal example to build on
18:53:54 <benzrf> i cannot figure this out at all tbh
18:54:12 <benzrf> one error is that you are still using a `use' expression as the State return type
18:54:22 <benzrf> but i can't seem to work out what's wrong with the (-=) line
18:54:27 <glguy> What's the question?
18:55:06 <EvanR> :t accum
18:55:06 <lambdabot> Ix i => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e
18:55:37 <Welkin> the question is why am I getting these errors? http://lpaste.net/117764
18:56:00 <Welkin> it seems simple enough
18:56:10 <Welkin> read from the state, and use those values in a computation
18:56:14 <EvanR> :t (\f a -> accum f a (assocs a))
18:56:15 <lambdabot> Ix i => (a -> a -> a) -> Array i a -> Array i a
18:56:15 <Welkin> modify the state
18:57:06 <EvanR> :t (\f a -> accum f a ((\(x,y) -> (x,x))(assocs a)))
18:57:07 <lambdabot>     Couldn't match expected type ‘[(i, a)]’ with actual type ‘(t1, t1)’
18:57:07 <lambdabot>     Relevant bindings include
18:57:07 <lambdabot>       a :: Array i e (bound at <interactive>:1:5)
18:57:14 <glguy> Are the let bindings not polymorphic enough?
18:57:37 <glguy> What if you eta expand them so they appear to be functions?
18:58:06 <EvanR> :t (\f a -> accum f a (map (\(x,y) -> (x,x)) (assocs a)))
18:58:06 <lambdabot> Ix a => (t -> a -> t) -> Array a t -> Array a t
18:58:33 <EvanR> mapWithIndex -_-
18:58:46 <glguy> I'll look harder when I get back to my computer if you two don't figure it out. Looking at phone now. I'm thinking of the locally defined lenses
18:58:57 <yohanatan> hi, typelevel programming (a la Scalaz, TMP/boost in C++) has introduced two distinct phases where computation is possible. Agda, Idris et al integrate the two ‘phases’ into a single syntax. Has there been any thought devoted to having, instead of exactly 2 phases, N (or limitless) phases (either with or without an integrated syntax and with or without the reliance on types).
18:59:50 <EvanR> idris has unlimited hierarchy of type universes just for you!
18:59:53 <Axman6> EvanR: does it already exist?
18:59:58 <EvanR> Axman6: didnt find it
19:00:01 <Axman6> :(
19:00:08 <yohanatan> EvanR: sweet! how about Agda?
19:00:15 <geekosaur> yohanatan, perhaps Omega?
19:00:21 <Axman6> EvanR: should be trivial to write though
19:00:31 <EvanR> i think what i have above works
19:00:34 <vanila> yohanatan, it's called multistage programming
19:00:45 <Axman6> (and possible submit for the next version of the array package... but that might be more trouble than it's worth)
19:00:46 <vanila> it's like a more powerful/general version fo macros
19:00:53 <vanila> metaocaml has this
19:01:12 <EvanR> Axman6: it seems 1 version back in the array package fmap didnt exist and was "amap" instead... so .. evolution continues
19:01:17 <vanila> taha has written a lot of papers on this, there's some stuff on olegs site too
19:01:27 <Axman6> well, that's good to hear
19:01:27 <yohanatan> vanila: yes, MetaOCaml looks nice!
19:01:54 <yohanatan> vanila: I assume that the stages aren’t tied to types in MetaOCaml?
19:02:17 <vanila> yeah, it's different than type level computation
19:02:33 <glguy> Welkin: that was the problem
19:02:42 <glguy> Welkin: I just checked on my computer
19:04:19 <EvanR> actually its still amap, in the IArray module
19:05:18 <Welkin> glguy: what was the problem?
19:05:28 <lpaste> glguy annotated “RPG Battle System” with “RPG Battle System (annotation)” at http://lpaste.net/117764#a117781
19:05:53 <Welkin> okay
19:06:05 <Welkin> glguy: so is that a proper way to do what I am trying to accomplish?
19:06:17 <Welkin> or is there a better way to do this using lenses?
19:06:57 <Welkin> where I need to get the Lens from a Map, as with player :: Int -> Lens' Game Player
19:07:50 <glguy> This way seems fine, you just needed the type signature due to monomorphism restriction
19:08:29 <Welkin> glguy: thank you
19:08:35 <Welkin> benzrf: thank you for your help as well
19:08:59 <Welkin> isn't this monomorphism restriction being removed?
19:09:16 <geekosaur> no
19:09:29 <geekosaur> recent ghc disables it within ghci (only)
19:09:42 <glguy> It's not a bad thing just something you have to know about
19:16:07 * hackagebot intricacy 0.3.3 - A game of competitive puzzle-design  http://hackage.haskell.org/package/intricacy-0.3.3 (mbays)
19:19:46 <EvanR> do you guy use paredit or similar for haskell
19:25:56 <johnw> there's really only structured-haskell-mode, if you want the paredit philosophy
19:39:47 <ReinH> shm is pretty nice
19:39:57 <ReinH> if you write Haskell like chrisdone does, which I more or less do
19:42:01 <wabash> Is there a single way that haskell encourages you to write? E.G., there's many crappy Java ways, and then there's 4 or 5 different ways in Scala....
19:42:12 <wabash> Python thinks it's multiparadigm but it's not, etc.
19:42:18 <johnw> how would "haskell" encourage any style?
19:42:26 <wabash> Via the structure of the language?
19:42:29 <Cale> wabash: What do you mean by "way"?
19:42:32 <johnw> no, not really
19:42:37 <wabash> You know, programming is like sculpting etc.
19:42:39 <johnw> you can write lots of kinds of Haskell
19:42:39 <wabash> blub.
19:42:46 <wabash> johnw: Ok, thank you.
19:42:58 <wabash> Cale: kind
19:43:06 <Cale> that doesn't help me :)
19:43:10 <wabash> ok
19:43:14 <wabash> but johnw answered.
19:43:15 <vanila> haskell encourages a functional programming style
19:43:16 <wabash> style?
19:43:22 <wabash> vanila: hahaha thanks.
19:43:35 <wabash> vanila: So in an FP style, are there still many styles?
19:43:40 <vanila> no
19:43:41 <Cale> It's unreasonable to expect there to be a single program to perform any given computation.
19:43:53 <wabash> er....
19:44:02 <wabash> It was just a question to feel out the landscape.
19:44:12 <Cale> In general, if it's possible to compute something, there will be many ways to compute that thing.
19:44:15 <wabash> Neither a reasonable nor unreasonable expectation of mine.
19:44:25 <wabash> Cale: Sure, turing complete, etc.
19:44:43 <vanila> wabash, In haskell you have algebraic data types and use a lot of higher order functions, and programs can be structured with monads
19:44:50 <wabash> I just mean in terms of style of writing. And again, I think I used the word "encourage", yes?
19:45:01 <wabash> vanila: Yep, got that much already. Which is good!
19:45:03 <johnw> now, #haskell might encourage you in certain directions
19:45:10 <wabash> hahaha thanks johnw
19:45:33 <wabash> johnw:  like now, in which I'm forced to be anally-pedantic in order to ask a very broad and general question?
19:45:40 <Cale> heh
19:45:42 <wabash> :)
19:45:46 <johnw> we love to encourage precision of speech :)
19:45:53 <wabash> It's good!
19:45:56 <EvanR> monads are like burritos
19:46:04 <wabash> As long as nobody quotes Lewis Caroll, I'll be ok.
19:46:09 * hackagebot duplo 1.6.9 - Frontend development build tool  http://hackage.haskell.org/package/duplo-1.6.9 (kenhkan)
19:46:11 * hackagebot git-vogue 0.1.0.0 - A framework for pre-commit checks.  http://hackage.haskell.org/package/git-vogue-0.1.0.0 (ChristianMarie)
19:46:16 <wabash> Why does every book have to quote him every chapter?
19:46:23 <vanila> because he's great!
19:46:35 * wabash vanishes, leaving only smile.
19:46:36 <johnw> he didn't write books, but quote sources
19:46:54 <wabash> johnw: I'm ok with Jefferson Airplane though.
19:47:07 <zzing> "If you don't know where you are going, any road will get you there." - Lewis Carroll.
19:47:34 <wabash> If every highschool senior used that instead of the fucking Robert Frost quote, I'd be sooooo happy.
19:47:35 <aaronweiss74> EvanR: I'm waiting for the continuation of this analogy.
19:47:44 <Welkin> haha
19:47:54 <zzing> wabash, Robert Frost quote?
19:47:59 <Welkin> the Robert Frost poem about The Road Not Taken is misinterpreted
19:48:01 <wabash> zzing: You aren't in the US then are you.
19:48:12 <zzing> wabash, no
19:48:15 <wabash> Welkin: What's the right way?
19:48:27 <Welkin> lots of people think it means "be a rebel! Take the path others did not!"
19:48:28 <johnw> another thing we encourage is keeping our discussions to being about Haskell
19:48:35 <Welkin> but it says right in the poem that both paths were equally worn
19:48:40 <Welkin> so it doesn't matter which path you take
19:48:41 <wabash> zzing: So, in the US, every darn HS honors student writes their senior quote to be about the road less taken, thinking that they are being profound in thought.
19:48:44 <Welkin> it will end up the same
19:48:51 <wabash> Welkin: Nice!
19:48:52 <zzing> You can always replace it with a quote from Dr. Richard Frost.
19:49:00 <wabash> unknown
19:49:01 <zzing> If you like parser combinators at least.
19:49:04 <wabash> zzing: Where are you?
19:49:20 <johnw> wabash: what do you want to do with Haskell?
19:49:34 <zzing> wabash, University of Windsor. (where Richard Frost teaches)
19:50:01 <wabash> Program! Ideally, machine learning and numerical analysis --- but this will be heavy on a well-tuned BLAS anyhow. But also things like web services.
19:50:09 <wabash> Is there a haskell -to -js framework yet?
19:50:13 <Welkin> wabash: why not game programming?
19:50:14 <wabash> a la GWT for java.
19:50:15 <Welkin> or graphics
19:50:21 <wabash> Welkin: Because I never use those!
19:50:21 <zzing> wabash, 'several'
19:50:21 <johnw> wabash: yes, a few
19:50:21 <wabash> :)
19:50:28 <johnw> wabash: ghcjs, fay, haste, and others
19:50:31 <wabash> What about machine learning ?
19:50:34 <zzing> I like purescript
19:50:38 <wabash> johnw: Ah, thank you!!
19:50:42 <johnw> I don't know about machine learning
19:51:11 <johnw> I'm still working on human learning
19:51:16 <wabash> What are the chances of that?   <iterate>   What are the chances of that?   <iterate>  .....
19:51:49 <Cale> I'm never sure what people are asking for when they ask about machine learning libraries
19:51:50 <johnw> wabash: https://faculty.cs.byu.edu/~jay/conferences/2013-tfp/proceedings/tfp2013_submission_10.pdf
19:52:16 <srhb_> Cale: I just assume it's super domain specific and look the other way. :-)
19:52:24 <vanila> What sort of compiler projects would you recommend someone do in haskell, to learn more about compilation?
19:52:34 <vanila> (I already did register coloring)
19:52:38 <johnw> vanila: what do you mean by compilatino?
19:52:44 <johnw> producing machine executable binaries?
19:52:52 <tommd> Define a language, lex it, parse it, transform the AST, and compile it to some target langauge?
19:53:05 <vanila> sort of, it doesn't have to be machine executable - virtual machines are good too
19:53:24 <johnw> then make a compiler from some subset of Haskell 98 to java bytecode
19:54:12 <Cale> wabash: If you search for machine learning on hackage, then a bunch of assorted stuff comes up. I'm not sure whether any of it fits what you'd be looking for.
19:54:17 <Cale> http://hackage.haskell.org/packages/search?terms=machine+learning
19:54:55 <Cale> see also http://hackage.haskell.org/packages/search?terms=statistics
19:55:12 <Cale> The first result for statistics here is a very good library
19:55:26 <Cale> http://hackage.haskell.org/package/statistics
19:55:37 <johnw> Cale's full name is Cale Google
19:56:03 <Cale> heh
19:56:07 <vanila> I have been reading about JVM, and .class file format
19:56:22 <vanila> How would haskell programs (modules?) relate to that?
19:56:44 <johnw> all good questions
19:56:53 <vanila> maybe there could be a Java monad....
19:57:05 <johnw> you could at first assume a single global class, where every Haskell function is a method in that class
19:57:13 <johnw> and only support pure functions, that kind of thing
19:57:20 <johnw> then evolve the complexity as you go
19:57:51 <arrdem> vanila: The model that most functional langs for the JVM take is that each function is a class with some form of a .invoke method.
19:58:03 <arrdem> vanila: then functions as values are trivial.
19:58:40 <vanila> yeah I can see how that lets you hold a functions environment
19:58:46 <vanila> but i think there would be problems with lazyness
19:58:55 <vanila> maybe not..
19:59:21 <johnw> just implement laziness as more functions
19:59:48 <johnw> i.e., an object holding a bool, a function reference and a set of arguments
20:01:34 <vanila> I was thinking to compile to jvm via STG
20:02:32 <zzing> I keep typing map when I mean fmap. evil prelude.
20:08:55 <Axman6> > negate (1 :: Word)
20:08:56 <lambdabot>  18446744073709551615
20:09:15 <wabash> Cale thakn you. Looking now.
20:09:31 <wabash> Does Hackage have any security at all, such as gpg keys and signed packages?
20:09:43 <Axman6> no
20:09:59 <wabash> That sucks. NO BETTER THAN SONOTYPE
20:10:03 <Clint> wabash: someone's working on it
20:10:20 <vanila> wabash, there are much bigger problems than that with it..
20:10:22 <wabash> Cale: In my case, implementations of common algorithms like SVM and KNN and stuff.
20:10:28 <Axman6> thanks like Safe Haskell can give you some guarantees though
20:10:31 <wabash> vanila: I would like to learn. Name a few?
20:10:37 <wabash> Clint: Good to hear!!
20:10:57 <Clint> wabash: https://gitorious.org/hackage-server/hackage-server/commits/openpgp
20:11:05 <wabash> johnw: Thanks for the paper.
20:11:18 <wabash> It's off to a good start.
20:11:25 <wabash> He recognizes speed as important.
20:11:36 <wabash> (Wish Octave people were that smart)
20:22:35 <latermuse> Is there any way to automatically generate a data type from json that is compatible with derive generic in aeson?
20:23:07 <latermuse> like I can feed it some json data, and it writes the data type that I can use with aeson
20:24:14 <Axman6> such a tool would have some interesting constraints on the input JSON
20:24:34 <latermuse> correct
20:24:56 <latermuse> might be useful to have though. was curious if anybody built one already
20:25:22 <latermuse> some generated json is way too cumbersome to manually build data types for
20:26:22 <Axman6> could be a fun project for you to try =)
20:28:17 <latermuse> anyways I guess im back to grinding on this json until its ready to work with aeoson haha
20:40:02 <EvanR> perusing the opengl "high level" bindings and wondering how this is helpful given my already hazy understanding of the low level api
20:47:53 <Welkin> EvanR: you don't have to deal with pointers
20:48:42 <Welkin> but it has obvious problems, such as function names that differ from the standard OpenGL api
20:53:52 <EvanR> well for my use i need the pointers
20:55:41 <zzing> When I have a process that looks like    let (x1, y1) = f x y;  let (x2, y2) = f x1 y1; ... and so on until some end (specifically, the xs are being 'depleted', and the ys are being accumulated)  — is there a name for this kind of pattern (beyond simple recursion)
20:56:13 * hackagebot iter-stats 0.1.0.4 - iteratees for statistical processing  http://hackage.haskell.org/package/iter-stats-0.1.0.4 (JohnLato)
20:57:01 <EvanR> extraneous currying?
20:59:36 <zzing> EvanR, that might be possible
21:01:13 * hackagebot git-vogue 0.1.0.1 - A framework for pre-commit checks.  http://hackage.haskell.org/package/git-vogue-0.1.0.1 (ChristianMarie)
21:01:15 * hackagebot jsontsv 0.1.4.5 - JSON to TSV transformer  http://hackage.haskell.org/package/jsontsv-0.1.4.5 (DanielChoi)
21:06:10 <chrisdotcode> Can someone please tell me where the bitwise operators are?
21:06:14 * hackagebot git-vogue 0.1.0.2 - A framework for pre-commit checks.  http://hackage.haskell.org/package/git-vogue-0.1.0.2 (ChristianMarie)
21:06:26 <EvanR> in Data.Bits
21:06:40 <chrisdotcode> Thank you
21:10:43 <lpaste> dgomez pasted “next step” at http://lpaste.net/117791
21:10:51 <dgomez> anyone (thnx for ur support so far): I was trying to add onto some code earlier. but I feel my interpretation is probably still off at this point,  specifically on "|" I receive a parse error.
21:11:14 * hackagebot git-vogue 0.1.0.3 - A framework for pre-commit checks.  http://hackage.haskell.org/package/git-vogue-0.1.0.3 (ChristianMarie)
21:11:28 <mehorney> Woah
21:21:15 * hackagebot markup 0.0.5 - Abstraction for markup languages  http://hackage.haskell.org/package/markup-0.0.5 (athanclark)
21:22:34 <dgomez> HeladoDeBrownie or :welkin if you'd be willing to help me see why I'm wrong wouldn't mind. sorry fir bothering
21:24:45 <Axman6> > map (\n -> n** -n) [1..]
21:24:46 <lambdabot>  Precedence parsing error
21:24:47 <lambdabot>      cannot mix ‘GHC.Float.**’ [infixr 8] and prefix `-' [infixl 6] in the sa...
21:24:51 <Axman6> > map (\n -> n** (-n)) [1..]
21:24:53 <lambdabot>  [1.0,0.25,3.7037037037037035e-2,3.90625e-3,3.2e-4,2.143347050754458e-5,1.214...
21:24:54 <dgomez> sorry meant Welkin:
21:25:32 <Axman6> dgomez: you might do better if you just ask your question to the channel so anyone around can help answer
21:26:15 * hackagebot posix-paths 0.2.0.4 - POSIX filepath/directory functionality  http://hackage.haskell.org/package/posix-paths-0.2.0.4 (JohnLato)
21:26:26 <dgomez> Axman6: I wasn't able to parse through successfully past line 19 "|"  so I am not sure how wrong the rest of my code is.
21:26:26 <zzing> Could anyone give me pointers on how to improve this algorithm? https://gist.github.com/iaefai/42b8c4007acd789a92c8
21:26:41 <dgomez> But I do get where you are coming from Axman6
21:28:47 <dgomez> zzing: kudos.  first off, I hope you get the help you need. that seems a bit too complex for me atm. I'm sorry.
21:28:59 <Axman6> dgomez: what is line 19 supposed to be doing? it doesn't make any sense to me
21:29:30 <zzing> dgomez, the fun part is that I will be converting it to javascript soon (not transpiling - but by hand). ghc was so much easier to develop it in (and more fun)
21:31:17 <dgomez> Axman6: I thought it was supposed to "read" through the "args" convert them to INT passed and eval it to two lists [a] AND [b]
21:31:51 <Axman6> so, the function read has type:
21:31:54 <Axman6> :t read
21:31:54 <lambdabot> Read a => String -> a
21:32:03 <dgomez> zzing: not sure what transpiling is :p but could I ask why the conversion to javascript. I bet it was loads of fun...
21:32:08 <Axman6> you're currently applying read to a list of Strings
21:32:15 <Axman6> so that can't be right
21:32:27 <zzing> dgomez, transpiling means to translate one language to another.
21:32:38 <zzing> It is used a lot now because of all the converts to javascript there are
21:33:13 <raisin_> Haskell beginner here. I'm trying to make sense of parser combinators, but I keep getting stuck with type errors. Could anyone help me figure out why ghc doesn't like this? http://pastebin.com/PkivjCjS
21:33:21 <EvanR> > read "\"abc\"" :: String
21:33:22 <lambdabot>  "abc"
21:34:06 <dgomez> Axman6 ok I see that. I am not able to redefine it as I did above correct?
21:35:09 <srhb_> raisin_: You seem to be claiming that no matter what the type of x is, x : [] is a String
21:35:29 <dgomez> zzing: thanks for that. I hope to understand the functionality of your alg someday soon...
21:35:31 <Axman6> raisin_: well, you've said that display has to be able to accept ParseResults containing ANY type a. but your code assumes the type is a Char
21:35:32 <srhb_> raisin_: Surely, if x :: Int, x : [] is NOT a String
21:35:43 <raisin_> Ah, that is true
21:35:55 <zzing> dgomez, you may ask any questions you like. The algorithm itself can be explained really simply.
21:36:02 <Axman6> if it were ParseResult Char -> String it would work fine
21:36:03 <srhb_> raisin_: In other words, either It's ParseResult a -> [a] (and then the Nothing case won't work) or it's ParseResult Char -> String
21:36:04 <raisin_> Is there any way to pattern match based on type in the last case expression?
21:36:13 <srhb_> Not as such.
21:37:25 <raisin_> I'm really just trying to figure out a way to dump my data structures to stdout, which seems needlessly hard...
21:37:40 <vanila> raisin_, show??
21:37:43 <vanila> are you deriving show
21:37:46 <Axman6> only because you don't understand your types =)
21:38:14 <Axman6> all those types, except Parser should be Showable
21:38:23 <EvanR> showing a function results in "OMG WHY ARE YOU TRYING TO DISPLAY A FUNCTION (5 line error)"
21:38:25 <Axman6> (assuming a is showable)
21:38:34 <Axman6> > show (+)
21:38:35 <lambdabot>  "<Integer -> Integer -> Integer>"
21:38:38 <EvanR> in many languages this is something like <<func>>
21:38:46 <Axman6> and lambdabot
21:39:05 <Axman6> > show id
21:39:06 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
21:39:06 <lambdabot>    arising from a use of ‘GHC.Show.show’
21:39:06 <lambdabot>  The type variable ‘a0’ is ambiguous
21:39:17 <EvanR> > show (id :: Int -> Int)
21:39:19 <lambdabot>  "<Int -> Int>"
21:39:22 <EvanR> rofl
21:39:39 <Axman6> that would be a useful instance to have defined somewhere for use in ghci...
21:39:45 <EvanR> for real
21:40:07 <EvanR> it violates the "law" that shows output should be readable
21:40:23 <EvanR> so for crying out loud split up show into two needs
21:40:34 <dfeuer> @tell edwardk i have to wonder if there's something meaningful about the fact that Cirdec's solution seems to use both the free monad and the cofree comonad of []. I don't know remotely enough about what any of that means to say.
21:40:34 <lambdabot> Consider it noted.
21:41:17 * hackagebot ListLike 4.1.1 - Generic support for list-like structures  http://hackage.haskell.org/package/ListLike-4.1.1 (JohnLato)
21:41:20 <e11> hey guys
21:41:26 <srhb_> Hello.
21:42:01 <EvanR> would you say that a value of type forall a. IO a is an io action that never returns
21:42:04 <Axman6> EvanR: Show and Display seem like decent names, not sure which should be the reversable one though
21:43:05 <dgomez> zzing: well if you could explain it to me it'd be great. honestly, I got lost while reading it, particularly as you approached type distributeCell and how you used its parameter and splitAt to know where to end each cell
21:43:07 <raisin_> Sorry, my connection died.
21:43:26 <raisin_> Will research Showable
21:43:28 <srhb_> raisin_: derive show, print all the things was the conclusion.
21:43:33 <zzing> dgomez, go to #haskell-in-depth  it is quiet there right now
21:43:34 <srhb_> raisin_: not Showable, just Show
21:43:45 <pavonia> EvanR: Or it returns undefined
21:44:04 <cojy> zzing: i'm not sure but maybe this algorithm is better expressed with lenses?
21:44:17 <zzing> cojy, I don't know anything about lenses
21:44:45 <dgomez> zzing: joined!
21:45:50 <lpaste> e11 pasted “Cant do file I/O in Yesod handler function” at http://lpaste.net/117796
21:46:22 <pdxleif> Trying to load parts of a haskell project in ghci, but it blows up on the CPP directives
21:46:37 <srhb_> e11: Assuming there's some kind of runHandler, you probably need to stick liftIO on there
21:46:56 <srhb_> e11: ie. liftIO $ appendFile ...
21:46:58 <Axman6> liftIO $ appendFile...
21:47:04 <Axman6> bleh, beaten to it
21:47:06 <e11> sweeeeeet. what does liftIO do?
21:47:15 <srhb_> e11: Lifts an IO action into your transformer stack
21:47:19 <srhb_> e11: (Sweet lingo, innit)
21:47:22 <Cale> Yeah, liftIO turns IO actions into actions of some other monad (which has a way to interpret IO actions)
21:47:24 <e11> hmmm... haha yeah
21:47:28 <Cale> :t liftIO
21:47:28 <lambdabot> MonadIO m => IO a -> m a
21:47:40 <pdxleif> the -cpp flag doesn't seem to help - https://downloads.haskell.org/~ghc/7.8.1/docs/html/users_guide/ghci-dot-files.html
21:47:48 <e11> ok, I'm still too newb to fully get that, have to read more up on it. But thanx a ton guys
21:47:55 <srhb_> e11: Hang on two seconds
21:47:56 <e11> that was under 5 seconds before the first answer, btw
21:48:21 <Axman6> that's pretty standard in this channel
21:48:28 <e11> damn thats awesome
21:48:35 <pavonia> pdxleif: Do you have the corresponding language pragma in your Haskell file?
21:48:49 <platz> well, I almost made it though 'The essence of dataflow programming (2005)' and finally got lost near the end, but basically it seems comonads can make a nice stream interpreter - since apparently "monads do not cater for stream functions"
21:49:03 <srhb_> e11: http://lpaste.net/117796#a117797 -- formatting is nice!
21:49:08 <Axman6> EvanR: why are you teaching yourself haskell with trial and error when there are decent resources to teach you?
21:49:36 * EvanR scrolls up to see where i was doing that
21:49:46 <srhb_> Axman6: That's e11, not EvanR
21:49:58 <platz> but I don't think any of the stream libraries use comonads either
21:50:01 <Axman6> whoops, mistabbed
21:50:30 <e11> hey Axman, I can only read so long before I want to build something. how did you learn Haskell?
21:50:52 <Axman6> university and years of practice
21:50:53 <pdxleif> pavonia: There's a CPP pragma, yes. Looks like the issue is that cpp complains of invalid syntax.
21:51:07 <e11> nice
21:51:13 <pdxleif> Which is strange; the project builds from cabal, but when I just ghci an individual file cpp complains
21:51:18 <Axman6> LYAH has you writing code pretty quickly IIRC
21:51:37 <platz> i.e. it looks like io-streams uses monads all over the place, so not sure what the "monads don't do streams" issue is exactly
21:51:41 <HeladoDeBrownie> dgomez, i haven't read most of the scrollback, do you still need help?
21:51:44 <EvanR> platz: it would let you convert one stream into another stream 1-to-1 by letting you look ahead
21:51:46 <pdxleif> I guess I can just manually do what the CPP directives are doing for now.
21:51:49 <EvanR> and thats it
21:52:26 <EvanR> other stream operations would need to be stream specific
21:52:31 <dgomez> HeladoDeBrownie: still need help but I am in another conversation atm in haskell-in-depth. i will be back once done here!
21:52:41 <HeladoDeBrownie> okay, have fun
21:52:52 <platz> EvanR: ah, yeah they did mention the "anticipation" or look ahead issue in the paper
21:52:59 <pavonia> pdxleif: What are the macros you use?
21:53:33 <e11> holy shit this is where the elite people hang out, I have found it at last
21:53:38 <e11> :)
21:54:10 <EvanR> > product [1..1337]
21:54:11 <lambdabot>  8874663836657679616624106464181330095477201209934728179488259618265583472082...
21:54:31 <EvanR> did not expect that to work
21:54:39 <Axman6> > foldl lcm [1..1337]
21:54:40 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
21:54:41 <lambdabot>    arising from a use of ‘M343382558827237400521481.show_M3433825588272374005...
21:54:41 <lambdabot>  The type variable ‘t0’ is ambiguous
21:54:48 <Axman6> > foldl lcm 1 [1..1337]
21:54:49 <lambdabot>  2700422700896954992058722670541128023340028336708492034892593164199155818369...
21:54:51 <e11> did you think it would overflow the bot?
21:55:03 <EvanR> go over the time limit at least
21:55:11 <e11> yeah, where are these bots running?
21:55:45 <e11> product [1..100]
21:55:47 <EvanR> Cale's house
21:55:54 <e11> ahh
21:55:59 <e11> > product [1..10]
21:56:01 <lambdabot>  3628800
21:56:17 <e11> whose Cale?
21:56:52 <pdxleif> pavonia: MIN_VERSION_base is one - https://github.com/idris-lang/Idris-dev/blob/master/src/Pkg/PParser.hs#L2
21:56:54 <Axman6> Cale is Cale (also you probably meant who's)
21:57:31 <e11> ah, of course. very zen. :)
21:57:40 <EvanR> platz: io-streams, from the looks of it, looks really super imperative
21:58:49 <pavonia> pdxleif: My guess is this macro is not in scope
22:00:01 <Cale> huh?
22:00:02 <raisin_> Hey, it's working!
22:00:15 <Cale> No, I'm not running any bots at the moment
22:00:41 <e11> > [1..10]
22:00:42 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
22:00:43 <Cale> lambdabot is being run by int-e at the moment, I think
22:01:01 <platz> EvanR: that was probably the wrong example to invoke on my part, but I'm not going to dispute the claim :)  My understanding is it's supposed to be the simpleist thing that could possible work http://snapframework.com/blog/2013/03/05/announcing-io-streams
22:01:07 <Axman6> does lambdabot count as haskell infrastructure?
22:01:28 <Axman6> it'd be nice if it were being looked after by the same people as haskell.org etc.
22:01:28 <e11> wow, how does somebody run a bot on here? Is it a text scraping program that automatically runs 'eval' (or equivalent) into ghci and spits it out? what a great idea!
22:01:56 <Axman6> e11: welcome to IRC circa pre 1990... :P
22:02:09 <Cale> e11: Well, it uses the GHC api, and it responds to a lot more than just requests to evaluate expressions, but yeah.
22:02:12 <e11> sorry, yeah, I'm new to it
22:02:25 <e11> damn thats really cool
22:02:49 <Axman6> @hoogle (a -> -> b -> b) -> b -> [a] -> b
22:02:51 <lambdabot> Parse error:
22:02:51 <lambdabot>   (a -> -> b -> b) -> b -> [a] -> b
22:02:51 <lambdabot>         ^
22:02:58 <Axman6> @hoogle (a -> b -> b) -> b -> [a] -> b
22:02:59 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
22:02:59 <lambdabot> Data.List foldr :: (a -> b -> b) -> b -> [a] -> b
22:02:59 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
22:03:18 <e11> the internet is really just getting better every year, now we even have bots in chatrooms ..haha
22:03:52 <EvanR> that internet, at it again
22:03:55 <Axman6> this is not a new thing by any scale other than geological time  :P
22:04:05 <Axman6> timescales*
22:05:12 <e11> its a miracle!
22:07:20 <Cale> 2002-09-16 07:25:19 +0200	<lambdabot>	I live.
22:07:40 <e11> amazing
22:09:17 <e11> how would you guys convert strings into and out of JSON? and/or type which contains two string values into JSON?
22:09:32 <Cale> I'd use the aeson library
22:09:45 <Cale> http://hackage.haskell.org/package/aeson
22:09:55 <e11> ok, the json library is deprecated?
22:09:55 <Cale> http://hackage.haskell.org/package/aeson-0.8.0.2/docs/Data-Aeson.html
22:10:02 <e11> thanks!
22:10:04 <Cale> Oh, well, not exactly
22:10:10 <Axman6> aeson is super fast and used by everyone these days
22:10:16 <e11> ahhh good to know
22:10:20 <Cale> But yeah, aeson is quite good
22:10:35 <EvanR> :t Data.Aeson.encode ["two","strings"]
22:10:36 <lambdabot> BSLC.ByteString
22:10:44 <EvanR> Data.Aeson.encode ["two","strings"]
22:10:46 <EvanR> > Data.Aeson.encode ["two","strings"]
22:10:47 <lambdabot>  Not in scope: ‘Data.Aeson.encode’
22:10:50 <Cale> heh
22:10:52 <Axman6> :o
22:10:53 <EvanR> balony
22:10:53 <Axman6> :(
22:11:16 <EvanR> well good thing its already in json ;)
22:11:17 <Cale> @let import qualified Data.Aeson -- no way we're getting away with this...
22:11:18 <lambdabot>  .L.hs:61:1:
22:11:18 <lambdabot>      Data.Aeson: Can't be safely imported! The module itself isn't safe.
22:11:20 <Cale> hehe
22:11:33 <Axman6> :(
22:11:40 <EvanR> > show ["two","strings"]
22:11:41 <lambdabot>  "[\"two\",\"strings\"]"
22:11:44 <EvanR> goodnuf
22:11:47 <mjrosenb> Is there a resource that says what needs to be implemented in order to implement some typeclass Foo?
22:12:25 <Cale> mjrosenb: In the very newest versions of GHC, they're adding a formal way to express what the minimal complete definition is
22:12:26 <Axman6> depends on the type class, but the docs should tell you
22:12:31 <Cale> But yeah, docs
22:12:47 <Cale> Or looking at the definition and seeing what stuff has a default implementation provided
22:13:01 <Axman6> Cale: how's the minimal definition stuff look?
22:13:18 <jspha> Axman6 https://ghc.haskell.org/trac/ghc/ticket/7633
22:13:32 <Axman6> thanks
22:13:40 <jspha> Since I just looked that up, hah
22:14:56 <Axman6> heh, right =) looks like a decent syntax
22:15:49 <EvanR> so :t can see inside packages but > cannot
22:17:05 <Cale> Well, it's more that you're not necessarily allowed to import things into L.hs which is the module from which lambdabot evaluates your expression
22:17:50 <Cale> If you could, then you could do stuff like get hold of unsafePerformIO or unsafeCoerce and have an easier time messing around with lambdabot's account on int-e's machine.
22:18:06 <Zemyla> Hmm, would stream fusion be able to work on merge sort?
22:18:13 <Cale> So lambdabot's operator needs to explicitly import the modules you want.
22:18:58 <Axman6> it is possible to write a streaming merge function, but I'm not sure how useful it would be really
22:19:04 <solatis> other than writing my own recursive function, is there any generic way to find the offset of a certain element inside a list, providing my own predicate ?
22:19:04 <Cale> Zemyla: That's an interesting question. The answer is pretty close to no, but there might be some kind of margin for partial success.
22:19:14 <solatis> oh geez
22:19:15 <mjrosenb> Is it ok for Applicative to depend on Monad? e.g. a <*> b = do {a' <- a; b' <- b; return (a,b)}
22:19:16 * solatis rtfm
22:19:18 <solatis> Data.List.find
22:19:20 <Axman6> mergesort needs to traverse the entire input to produce the first result anyway
22:19:28 <Cale> Yeah, or findIndex
22:19:32 <shachaf> :t and > work very differently.
22:19:58 <EvanR> mjrosenb: yeah
22:20:14 <e11> hey guys, for concatenating strings is: let allDataString = "\n" ++ (show comm) ++ "\n"  good? or is there a better way?
22:20:22 <Zemyla> Yeah, any sort does, since the first result could be in the last entry.
22:20:39 <noone_> Question: Will running my applicative parsers in a ReaderT monad transformer have a discernible effect on performance (using attoparsec)?
22:20:53 <EvanR> hehe, any sort that finds a least element can bubble that to the top before continuing
22:20:58 <EvanR> in theory
22:21:10 <Axman6> e11: for short sequences that's fine, but you may also like: concat ["\n",show comm,"\n"]
22:21:27 <e11> sweet, thanks Axman!
22:21:38 <shachaf> e11: (shows x "\n") is more efficient than (show x ++ " \n")
22:21:44 <mjrosenb> oh, that doesn't work.  <*> doesn't have the type I expected it to
22:21:59 <e11> ahhaa... interesting
22:22:59 <shachaf> The same is true for concat etc., of course.
22:23:32 <e11> why more efficient? just wondering
22:23:57 <shachaf> The latter generates a string and immediately takes it apart to make a new string. Immutability and all.
22:24:26 <e11> ok
22:24:59 <EvanR> the endo builder trick
22:25:03 <EvanR> third time this week
22:25:26 <EvanR> :t shows "foo"
22:25:27 <lambdabot> ShowS
22:26:17 <e11> > shows True,False,True
22:26:18 <lambdabot>  <hint>:1:11: parse error on input ‘,’
22:26:42 <Axman6> @src ShowS
22:26:42 <lambdabot> type ShowS = String -> String
22:27:15 <e11> @src writeFile
22:27:15 <lambdabot> writeFile f txt = withFile f WriteMode (\ hdl -> hPutStr hdl txt)
22:27:20 <e11> wowza~!!!
22:27:56 <EvanR> > (shows "foo" . shows "bar") "baz"
22:27:57 <lambdabot>  "\"foo\"\"bar\"baz"
22:28:24 <EvanR> e11: power of the dot
22:29:57 <e11> the dot means a lot
22:30:34 <e11> the dot is all we've got
22:31:22 <Zemyla> I think the dollar is almost as important as the dot.
22:31:36 <Zemyla> :t ($).($)
22:31:37 <lambdabot> (a -> b) -> a -> b
22:31:55 <EvanR> meh at $
22:32:07 <EvanR> only in a pinch
22:32:16 <Cale> ($) is id, and id is probably as important as (.)
22:32:31 <EvanR> :t ($)
22:32:32 <lambdabot> (a -> b) -> a -> b
22:32:36 <Cale> :t id
22:32:36 <lambdabot> a -> a
22:32:44 <Cale> :t id :: (a -> b) -> a -> b
22:32:44 <lambdabot> (a -> b) -> a -> b
22:32:53 <EvanR> > (+7) `id` 1
22:32:55 <lambdabot>  8
22:32:57 <EvanR> head explode
22:38:10 <e11> anybody know how to get IP address from a Yesod request?
22:39:49 <dgomez> HeladoDeBrownie: if you are around I'd love to talk and try to understand my attempts at haskell a bit more...
22:40:14 <dgomez> :HeladoDeBrownie: sorry i was away for a bit
22:40:16 <Zemyla> :t join (+)
22:40:17 <lambdabot> Num a => a -> a
22:41:00 <Zemyla> > join (+) 5
22:41:02 <lambdabot>  10
22:42:46 <EvanR> function monad?
22:42:59 <johnw> yes
22:44:01 <dgomez> :t read
22:44:02 <lambdabot> Read a => String -> a
22:46:20 * hackagebot bindings-levmar 1.1.0.3 - Low level bindings to the C levmar (Levenberg-Marquardt) library  http://hackage.haskell.org/package/bindings-levmar-1.1.0.3 (BasVanDijk)
22:47:26 <Cale> dgomez: If you have any questions, don't hesitate to ask
22:49:43 <wz1000> :t id :: (forall a. a) -> (forall a. a)
22:49:44 <lambdabot>     Couldn't match type ‘a1’ with ‘forall a2. a2’
22:49:44 <lambdabot>       ‘a1’ is a rigid type variable bound by
22:49:44 <lambdabot>            an expression type signature: (forall a. a) -> a1
22:49:52 <wz1000> :t id :: (forall a. a) -> (forall a'. a')
22:49:53 <lambdabot>     Couldn't match type ‘a'1’ with ‘forall a. a’
22:49:53 <lambdabot>       ‘a'1’ is a rigid type variable bound by
22:49:53 <lambdabot>             an expression type signature: (forall a. a) -> a'1
22:50:17 <EvanR> it seems ironic that in haskell (lazy) the result of "loosely" calling a java method using the java bindings that results in a null immediately causes a crash. whereas in java, not lazy, waits until its least convenient to crash
22:50:36 <wz1000> :t id (undefined (forall a. a))
22:50:36 <lambdabot>     Not in scope: ‘forall’
22:50:37 <lambdabot>     Perhaps you meant ‘forAll’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
22:50:43 <wz1000> :t id (undefined :: (forall a. a))
22:50:43 <lambdabot> a
22:50:59 <wz1000> :t const 2 (undefined :: (forall a. a))
22:51:00 <lambdabot> Num a => a
22:51:51 <wz1000> @let f _ = 1 :: (forall a. a) -> Int
22:51:52 <lambdabot>  .L.hs:163:1:
22:51:52 <lambdabot>      Equations for ‘L.f’ have different numbers of arguments
22:51:52 <lambdabot>        .L.hs:163:1-26
22:52:04 <wz1000> @let g _ = 1 :: (forall a. a) -> Int
22:52:04 <lambdabot>  .L.hs:165:7:
22:52:04 <lambdabot>      Cannot instantiate unification variable ‘a0’
22:52:04 <lambdabot>      with a type involving foralls: (forall a. a) -> Int
22:52:09 <gibbers> hey, I've been thinking of trying to replace python with haskell for my personal projects. My biggest fears are how easy it is to program and haskell not having python's variety of libraries.
22:52:18 <wz1000> @let (g _ = 1) :: (forall a. a) -> Int
22:52:18 <lambdabot>  Parse failed: Parse error: =
22:52:39 <gibbers> I know that's a reeeealllly nooby question, but I'm kind of curious what the transition is like
22:52:43 <wz1000> @let g _ = 1 :: (forall a. a) -> Int
22:52:44 <lambdabot>  .L.hs:165:7:
22:52:44 <lambdabot>      Cannot instantiate unification variable ‘a0’
22:52:44 <lambdabot>      with a type involving foralls: (forall a. a) -> Int
22:52:58 <EvanR> gibbers: probably extremely different experiences on all fronts
22:53:24 <wz1000> @undefine
22:53:24 <lambdabot> Undefined.
22:53:31 <EvanR> which is good for you ;)
22:54:05 <wz1000> > let g :: (forall a. a) -> Int; g _ = 1 in g 1
22:54:06 <lambdabot>  No instance for (GHC.Num.Num a) arising from the literal ‘1’
22:54:06 <lambdabot>  Possible fix:
22:54:06 <lambdabot>    add (GHC.Num.Num a) to the context of
22:54:18 <wz1000> > let g :: (forall a. a) -> Int; g _ = 1 in g undefined
22:54:19 <lambdabot>  1
22:54:21 <dgomez> Cale: Yes I do. The problem, is I am not sure how to ask correctly. For example, this code [http://lpaste.net/117791], I used the type "Read" incorrectly but unsure on how to modify. I don't know what other errors I have bc when I parse through it all I get is an error on line 19. So I am stuck not knowing if my understanding is correct or not...
22:54:34 <gibbers> EvanR: my biggest fear is how long projects would take vs throwing something together in python
22:55:00 <EvanR> large project?
22:55:12 <EvanR> dont throw that together in python
22:55:23 <wz1000> Hah, I used _|_ like ()
22:56:20 * hackagebot debian-build 0.4.0.1 - Debian package build sequence tools  http://hackage.haskell.org/package/debian-build-0.4.0.1 (KeiHibino)
22:57:35 <HeladoDeBrownie> dgomez, sure, against all reason i'm awake still, so why not
22:57:47 <e11> hey guys, how can I do these two filter functions together :
22:57:49 <HeladoDeBrownie> dgomez, by the way, you can probably also ask the channel at large and someone who's here can help
22:57:49 <e11> let allDataString = filter (/='"') . filter(/='/') (concat ["\n", show comm, "\n"])
22:57:59 <e11> I want to filter for double quotes and slashes
22:58:09 <EvanR> (f . f) argument
22:58:16 <EvanR> not f . f argment
22:58:20 <EvanR> in this case
22:58:36 <dgomez> HeladoDeBrownie: no problem. I have also asked the channel as well. but any help would be welcome. :)
22:58:46 <HeladoDeBrownie> dgomez, so what is it you need specifically?
22:58:50 <Cale> dgomez: Okay, so... there are a few different problems with this, the syntax is a bit off in several respects.
22:59:10 <Cale> First of all, read is a function defined in the Prelude, so you don't need to declare its type signature
22:59:18 <Cale> (it's already in scope)
22:59:28 <dgomez> be welcome. :)
22:59:28 <dgomez> HeladoDeBrownie: http://lpaste.net/117791 continual misunderstading im afriad...
22:59:49 <e11> by (f . f) you mean I want to group one filter function with the concat function, or group two filter functions together?
22:59:51 <dgomez> Cale: I see. I wasn't aware of that
22:59:53 <Cale> Next, because it takes a single String argument, while args is a list of String values, read args will be a type error.
22:59:55 <HeladoDeBrownie> dgomez, hmm, i'm afraid i don't have much to add to what Cale is saying
23:00:09 <EvanR> e11: i meant (filter f . filter g) someList
23:00:18 <Cale> Thirdly, you seem to be using >>= to mean something which >>= definitely does not mean.
23:00:27 <Cale> (I have no idea what's going on there)
23:00:30 <dgomez> HeladoDeBrownie: no problem I'll listen to Cale -->
23:00:34 <HeladoDeBrownie> dgomez, you're in good hands with Cale anyway, you don't need me
23:00:35 <HeladoDeBrownie> good luck
23:00:38 <Cale> and then [a] | [b] is just... where did you get this? :)
23:00:41 <gibbers> so is the best way to learn haskell learn you a haskell?
23:01:00 <Cale> gibbers: A lot of people recommend it. There's also the CIS lectures
23:01:09 <e11> yes, ok. and can you tell me why the filter functions seem to be running against each other? (f . f) why would the filter function be executed on the other filter?
23:01:10 <Cale> http://www.seas.upenn.edu/~cis194/
23:01:13 <dgomez> Cale: yeah I see how its all accumulating to wtf basically...
23:01:34 <Cale> dgomez: So, what you might mean is  let [a,b] = map read args
23:01:40 <EvanR> e11: its not applied to the other filter, its composed with
23:01:40 <breadmonster_> hindent failed to install for some reason.
23:01:43 <HeladoDeBrownie> e11, what EvanR meant is: let allDataString = (filter (/='"') . filter(/='/')) (concat ["\n", show comm, "\n"])
23:02:05 <HeladoDeBrownie> e11, note the extra parens
23:02:09 <e11> ok, and its evaluated right to left, so first the string is built, then both filters are applied, one after the other?
23:02:24 <dgomez> Cale: I might, but I am not sure how to denote that I want two arguments passed specifically for this "program"...
23:02:28 <EvanR> its evaluated top to bottom
23:02:28 <HeladoDeBrownie> e11, nothing has been stated about evaluation order
23:02:48 <dgomez> Cale: based off just the input from IO ()
23:02:50 <e11> hmm. top to bottom?
23:02:55 <Cale> dgomez: This assumes that the program receives 2 arguments (and will die with a pattern match failure if it doesn't). map read args will apply the read function to each element of the list args, giving a list of the results.
23:03:22 <EvanR> first get the precedence right, thats what is causing your type errors
23:03:45 <Cale> dgomez: and then this is pattern matched against the pattern [a,b] so that if you treat a and b as Int values, that's what they'll be. (They have the same type, and can be any type which it's possible to read)
23:03:54 <e11> yes, ok, thanks EvanR!!
23:04:30 <dgomez> Cale: ok I see what you are saying and how map read args is appropriate syntax.
23:04:37 <EvanR> e11: another way to write it would be filter (/='"') (filter (/='/') (concat ["\n", show comm, "\n"]))
23:04:42 <Cale> dgomez: So, if you want to print out the sum of those then, you can write something like  putStrLn ("The sum is: " ++ show (a + b))
23:05:18 <EvanR> i.e. f a b c is not the same as f a (b c)
23:05:38 <EvanR> i had the same issue at first
23:06:10 <Cale> f a b c is the same as ((f a) b) c
23:07:15 <dgomez> Cale: by saying let [a, b] = map read args  --> how will haskell know what type each parameter a and b is? Does it know a and b will be individual args? Or is this a simpleton way of putting it?
23:07:33 <e11> I cant pretend to have grasped fully what you mean, although I think I understand algebra and the importance of evaluation, but I dont get how that fits into function evaluation. it will come with time surely
23:08:05 <e11> i want to say its like chained methods in javascript, each has to return a proper value for the next function, but there may be more going on here i guess.
23:08:11 <EvanR> e11: well, parsing precedence is an idependent thing from order of evaluation
23:08:12 <Cale> dgomez: Well, it won't -- there is still an ambiguity. But if we do more stuff with a and b later to help it discover what type we want a and b to be, then it will be able to infer which parser to use for 'read'
23:08:26 <e11> ok, thats a distinction I didnt know about
23:08:51 <Cale> dgomez: For example, if we add a and b, then it will know that a and b must be numbers, and a defaulting mechanism will kick in to default the type to Integer.
23:09:08 <e11> why is parsing precedence different from order of evaluation? how can those two be different?
23:09:38 <EvanR> 1 - 2 + 3 - 4 needs to be grouped into some tree of binary operations to make sense, and you were given rules for this in grade school
23:09:41 <Cale> Or if we use a as the argument to some function which requires a Double, then it will infer that a and b are both Doubles. So long as there's a single consistent choice which can be made, we'll be fine.
23:10:03 <Cale> e11: Consider something like double x = x + x
23:10:10 <e11> ok
23:10:16 <EvanR> 1 - (2 + (3 - 4))) is the rule, i think
23:10:19 <Cale> e11: If we have double (double 5), there are two ways that we can begin
23:10:26 <EvanR> er no
23:10:39 <Cale> We can evaluate the innermost double:  double (double 5) -> double (5 + 5)
23:10:48 <EvanR> (((1 - 2) + 3) - 4)
23:10:55 <Cale> Or we can evaluate the outer one first:  double (double 5) -> (double 5) + (double 5)
23:11:12 <Cale> e11: yes?
23:11:15 <e11> why would you ever evaluate the outer one first?
23:11:28 <Cale> In fact, in Haskell, we always evaluate the outer one first, that's what lazy evaluation does.
23:11:36 <dgomez> Cale: ok so i understand what you are saying. Im trying to understand how I should modify this to reflect your thoughts a bit more.
23:12:03 <e11> ok, i'll read what you wrote and think about it for a bit, thanks
23:12:12 <Cale> Only, it's a slight modification to this: whenever a variable is bound (e.g. the parameter to a function), any work done to evaluate the expression it's bound to is shared amongst the occurrences
23:12:33 <Cale> Actually, I'll write out the examples more fully:
23:12:40 <Cale> Innermost-first evaluation looks like:
23:12:44 <Cale> double (double 5)
23:12:47 <Cale> -> double (5 + 5)
23:12:48 <Cale> -> double 10
23:12:51 <Cale> -> 10 + 10
23:12:52 <Cale> -> 20
23:13:01 <Cale> That's also known as strict evaluation
23:13:05 <e11> ok
23:13:12 <e11> as opposed to lazy I take it
23:13:15 <Cale> Plain outermost-first evaluation would look like:
23:13:16 <Cale> yeah
23:13:20 <Cale> double (double 5)
23:13:25 <Cale> -> (double 5) + (double 5)
23:13:31 <Cale> -> (5 + 5) + (double 5)
23:13:35 <Cale> -> 10 + (double 5)
23:13:39 <Cale> -> 10 + (5 + 5)
23:13:41 <Cale> -> 10 + 10
23:13:43 <Cale> -> 20
23:13:55 <Cale> Now, we obviously duplicated a bunch of work there
23:14:07 <e11> in practice, these two orders of operation result in different outcomes sometimes?
23:14:25 <Cale> They always result in the same outcome, provided they both terminate
23:14:33 <Cale> (in fact, any order of evaluation will)
23:14:55 <e11> ok, so this is seperate from precedence .. e.g. 5 * 8 / 45 type grouping
23:14:56 <Cale> However, outermost-first evaluation has the nice property that if any order of evaluation terminates, then it will.
23:15:03 <Cale> Innermost-first evaluation does not have that property.
23:15:21 <Cale> With innermost-first evaluation, we evaluate each argument to a function exactly once
23:15:35 <Cale> With outermost-first evaluation, we evaluate each argument zero or more times
23:15:46 <breadmonster_> Cale, Have you read SICP?
23:15:51 <Cale> Lazy evaluation is a modification to outermost-first evaluation to try to get the best of both worlds.
23:15:59 <Cale> breadmonster_: sure
23:16:15 <breadmonster_> Cale, can you use Haskell to explain what applicative order and normal order evaluation is to me?
23:16:26 <Cale> That's exactly what I'm doing
23:16:28 <Cale> right now
23:16:29 <e11> *thinking*
23:16:36 <EvanR> e11: yeah your problem earlier was the precedence of . vs precedence of function application (juxtaposition)
23:16:38 <Cale> applicative order = innermost-first
23:16:44 <Cale> normal order = outermost-first
23:16:57 <earthy> Clean uses leftmost-outermost, but in a graph-reduction setting.
23:17:13 <Cale> Now, lazy evaluation is outermost-first evaluation with sharing
23:17:19 <earthy> rather than a term-reduction setting.
23:17:26 <Cale> So, in order to represent the sharing, I'll use let/in syntax:
23:17:29 <Cale> double (double 5)
23:17:51 <Cale> -> let x = double 5 in x + x -- note we still evaluated the outermost double first, but we gave the argument a name, and we'll evaluate it only once
23:17:58 <Cale> -> let x = 5 + 5 in x + x
23:18:02 <Cale> -> let x = 10 in x + x
23:18:05 <Cale> -> 10 + 10
23:18:06 <Cale> -> 20
23:18:25 <Cale> So that's lazy evaluation now
23:18:30 <e11> so some orders of evaluation dont terminate, but if any do, outermost-first will always work. Why wouldnt an order of evaluation terminate? (just curious)
23:18:49 <EvanR> > last [1..]
23:18:52 <lambdabot>  mueval-core: Time limit exceeded
23:19:06 <Cale> Well, that's not the best example...
23:19:12 <Cale> > head [1..] -- is better
23:19:14 <lambdabot>  1
23:19:14 <earthy> > take 1 [1..]
23:19:15 <lambdabot>  [1]
23:19:30 <e11> what did that demonstrate?
23:19:43 <earthy> [1..] is an infinite list. evaluating it does not terminate.
23:19:43 <Cale> Well, [1..] is an infinite list. Evaluating it takes forever.
23:19:46 <Cale> > [1..]
23:19:48 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:20:01 <Cale> But we can look at any finite portion of this list without worry.
23:20:17 <e11> wow, the bot can even handle infinity. nice!
23:20:42 <Cale> As a simpler example, consider the function  f x = 5
23:21:01 <Cale> This function doesn't really need to know the value of its argument to produce a result
23:21:12 <e11> what? no comprende?
23:21:22 <Cale> Well, what is the value of  f (factorial 100000) ?
23:21:41 <e11> hmmm..
23:21:43 <Cale> If you were computing this by hand, would you compute the factorial of 100000, or would you just tell me 5?
23:21:52 <e11> oh, I would say 5
23:21:59 <EvanR> you lazy bum
23:21:59 <e11> oh, now I see the =5 didnt notice before
23:22:02 <Cale> Right, so that's what lazy evaluation would do
23:22:14 <Cale> It would evaluate outermost first
23:22:17 <e11> but how often does it happen that functions are set via an = Integer
23:22:26 <Cale> f (factorial 100000) -> 5
23:22:29 <e11> I thought their outputs tended to depend on their inputs
23:22:48 <exio4> > False && undefined
23:22:48 <Cale> rather than f (factorial 100000) -> f (2824229...0000) -> 5
23:22:49 <lambdabot>  False
23:23:06 <Cale> e11: Well, it's true that most Integer functions are strict
23:23:18 <Cale> e11: But Integers are not the only type of data in the world :)
23:23:48 <e11> how would a list processing function for example, have an output before you had given it the input? I thought this all happened with pointers and symbolic linking and stuff...
23:24:11 <Cale> and for functions on most other sorts of data, you might be able to produce part of the result before even taking the input apart at all
23:25:08 <EvanR> > show (show (undefined, undefined)))
23:25:09 <lambdabot>  <hint>:1:35: parse error on input ‘)’
23:25:13 <EvanR> > show (show (undefined, undefined))
23:25:14 <lambdabot>  "\"(*Exception: Prelude.undefined
23:25:19 <Zemyla> What is the comonadic equivalent of the ((->) r) monad?
23:25:23 <Cale> So, consider something like  upFrom n = n : upFrom (n+1), and say we want to compute  take 3 (upFrom 0)
23:25:24 <EvanR> that produced a '"' before looking at the input
23:25:36 <vanila> Zemyla, Im not sure what you mean?
23:25:38 <Cale> Zemyla: The (,) r comonad?
23:25:39 <EvanR> Zemyla: Env
23:26:00 <Cale> @src take
23:26:00 <lambdabot> take n _      | n <= 0 = []
23:26:00 <lambdabot> take _ []              = []
23:26:00 <lambdabot> take n (x:xs)          = x : take (n-1) xs
23:26:16 <vanila> what's a comonadic equivalent?
23:26:31 <Cale> So, the first pattern fails here, because n is not <= 0
23:26:39 <EvanR> ((->) r) is dual to (,) r
23:26:42 <Cale> and then in order to see if the second pattern matches
23:26:57 <Cale> take 3 (upFrom 0) -> take 3 (0 : upFrom (0 + 1))
23:27:01 <spearman> it looks like there are a few sqlite packages, does anyone know what the easiest one to use is? i just have a small database (500 or so records) and want to do some queries and get the answers as lists to start with
23:27:09 <Cale> and no, it doesn't, but the third pattern in take matches
23:27:09 <vanila> what is meant by dual here?
23:27:34 <Cale> and we get the result  0 : take (3-1) (upFrom (0+1))
23:27:36 <e11> hey guys, thanks a lot for the help tonight @EvanR and @Cale, yall rock. have a good night and day everyone
23:27:44 <Cale> Now, if we were pattern matching this expression against (x:xs)
23:27:46 <Cale> we'd be done
23:27:52 <Cale> we'd bind x to 0
23:27:53 <EvanR> vanila: couldnt tell you ;)
23:27:59 <Cale> and we'd bind xs to take (3-1) (upFrom (0+1))
23:28:11 <Cale> and only if we needed to evaluate xs would we continue evaluating
23:28:50 <Cale> at which point, we'd compute the 3-1 = 2 in order to make sure it's positive, and that upFrom (0+1) = (0+1) : upFrom ((0+1)+1)
23:30:04 * gfixler is waiting for someone to mention :sprint
23:30:58 <EvanR> yes i heard Store and State somehow relate, and Env and Reader somehow relate
23:32:18 <johnw> they relate by duality
23:32:51 <Guest6> Hi, I am confused about one thing, if I am multiplying three numbers I can give type signature as multThree :: (Num a) => a -> a -> a -> a but not multThree :: (Int a) => a -> a -> a -> a, why is that ?
23:32:57 <Cale> Yeah, if you don't know a bunch of category theory already, it's probably not worth bothering to try to understand how they relate. It's not a very directly useful relationship :)
23:33:14 <Cale> Guest6: Because Int is not a class
23:33:21 <johnw> right, and the nature of the duality is not quite the same for each case
23:33:46 <vanila> I'm curious about it, is there an explanation i can read somewhere?
23:33:54 <Guest6> so we can define (Num a) for the classes only ?
23:33:54 <johnw> (or maybe it is, but not clear in Haskell)
23:34:26 <shachaf> Cale: I know some category theory and I'd like to know more about how they relate.
23:34:30 <Cale> Guest6: Num is a class, and the constraint Num a says that whichever type a is, it must implement the "methods" of that class, which in the case of Num include (+), (-), (*), fromInteger, and some other stuff.
23:34:56 <Cale> shachaf: There's an adjunction
23:35:14 <Guest6> Cale: thanks
23:35:28 <Cale> (,) r is left adjoint to (->) r
23:35:29 <shachaf> I know you can get State and Store from the same adjunction, and I know about newtype Co w a = Co (forall r. w (a -> r) -> r) such that Co (Store s) = State s and Co (s,) = (s ->) and Co (s ->) = (s,)
23:36:32 <shachaf> But none of that is exactly duality in the usual sense, and I'd like to know why I should be expecting that sort of thing, and maybe whether there's a symmetry (can we go from State to Store and so on?).
23:36:41 <Cale> Guest6: In order to make some new datatype an instance of that class, you'd write an instance declaration like  instance Num MyType where x + y = ...; ... other definitions ...
23:36:50 <dgomez> you understand a lot more than me shachaf. Im following along.
23:37:31 <johnw> for some background reading: http://www.stephendiehl.com/posts/adjunctions.html
23:37:57 <Cale> dgomez: Oh, I just noticed I missed something you said earlier. What I was suggesting you try was...
23:38:01 <johnw> which adjunction does Reader arise from?
23:38:37 <Cale> main = do args <- getArgs; let { [a,b] = map read args }; putStrLn ("The sum is: " ++ show (a + b))
23:38:44 <Cale> dgomez: ^^
23:39:20 <Cale> shachaf: I don't know if there's anything closer to usual duality...
23:39:51 <shachaf> Cale: Whatever it is, I want it to relate (r ->) and (r,), not just State and Store.
23:39:58 <dgomez> Cale : ok I get that. this is where I was starting to go   map read args >>= sum [a,b]
23:39:58 <dgomez>     zipWith (+) sum
23:40:25 <dgomez> I appreciate it Cale: my understanding for lack of abetter word is basic.
23:40:57 <shachaf> I think there must be something I don't appreciate about Co.
23:43:43 <Zemyla> Is NonEmpty Comonad the dual of Maybe Monad?
23:44:21 <EvanR> hehe cool
23:44:44 <EvanR> instance Adjust ((,) a) ((->) a) where
23:44:52 <EvanR> instance Adjoint ((,) a) ((->) a) where
23:44:57 <johnw> shachaf: have you seen this: http://www.cs.ox.ac.uk/ralf.hinze/WG2.8/28/slides/Comonad.pdf
23:45:09 <johnw> I haven't read it through yet
23:46:54 <dgomez> Zemyla: what do you mean by dual? I've enevr heard a question like yoursI'm sorry
23:47:51 <EvanR> youre getting sucked in!
