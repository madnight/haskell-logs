00:01:10 <Lokathor> when i install a package, do i need to use -O2 with that compilation? or does using -O2 in the final program make it optimize code from a package as well?
00:02:32 <MP2E> O2 only optimizes your program, with few exceptions
00:02:54 <MP2E> if the library has code that is inline'd it will often keep the original code in the module so that your program can use that to inline
00:03:07 <MP2E> in that case, that routine would get the boost of O2
00:03:13 <Lokathor> hmm, so might it run faster if you also recompile the libraries with -O2 as well then?
00:03:30 <MP2E> yep
00:03:56 <Lokathor> ..how would one do that? Seems like a thing i might want to run overnight some time
00:04:12 <MP2E> edit your cabal config
00:04:24 <MP2E> in linux it's ~/.cabal/config
00:04:41 <MP2E> look for optimization and uncommented, and change the value from True to 2
00:04:44 <MP2E> True means O1
00:04:51 <MP2E> uncomment*
00:05:16 <Lokathor> hmm, user-install is good right?
00:05:22 <Lokathor> most of these are commented out, but that one is not
00:06:04 <MP2E> yeah that's fine
00:06:42 <Javran> what about ghc-options in the .cabal file? will the global config overwrite it?
00:07:12 <Lokathor> and then i also uncomment "reinstall: False"?
00:07:19 <Lokathor> or how do i set the re-install spinning?
00:07:48 <Javran> I always have "ghc-options: -Wall -threaded -O2" in my cabal file, now I'm not sure if this is a good practice
00:07:50 <MP2E> Javran: It appends the optimization to the end, so yeah it overwrites whatever optimization was there
00:08:28 <Javran> MP2E: so it only overwrites O2 option?
00:08:54 <MP2E> Lokathor: not sure what you mean, I'm not sure what reinstall does so I wouldn't recommend uncommenting it
00:08:57 <MP2E> yeah
00:09:00 <MP2E> only overwrites the O2 option
00:09:05 <Lokathor> oh
00:09:06 <Javran> I see
00:09:21 <Lokathor> well how do i get it to rebuild the libraries now that optimization is on?
00:10:27 <MP2E> 'cabal install --reinstall --force-reinstalls world'
00:10:40 <Lokathor> very fancy
00:14:28 <Lokathor> weird note, ghc output is to stderr not stdout
00:32:45 <zipper> The best way to flip ord that is give the ascii number and get the related ascii value
00:32:55 <zipper> > ord 'a'
00:32:56 <lambdabot>  97
00:33:09 <zipper> Then what 97 to 'a'
00:33:25 <lattenwald> > chr 97
00:33:26 <lambdabot>  'a'
00:34:53 <lattenwald> q
00:34:56 <lattenwald> oops.
00:39:28 <zipper> lattenwald: Thanks
01:21:34 * hackagebot haskell-rules 0.1.0.0 - A DSL for expressing natural deduction rules in Haskell.  http://hackage.haskell.org/package/haskell-rules-0.1.0.0 (spacekitteh)
01:41:35 * hackagebot base-prelude 0.1.14 - The most complete prelude formed from only the "base" package  http://hackage.haskell.org/package/base-prelude-0.1.14 (NikitaVolkov)
01:50:11 <makalu> has anyone used C libraries compiled with address sanitizer in a GHC compiled program? I get an error "Shadow memory range interleaves with an existing memory mapping. ASan cannot proceed correctly."
01:52:59 <RustyShackleford> so i'm a little confused about the record syntax for datatype
01:53:29 <RustyShackleford> it automatically makes a function named after a field?
01:53:50 <RustyShackleford> the issue I see with that is function name clashes
01:54:07 <vanila> yeah, thats right
01:54:13 <RustyShackleford> what if two datatypes have a field with the same name?
02:00:42 <merijn> RustyShackleford: Pain and suffering >.>
02:00:57 <merijn> RustyShackleford: There's work on the OverloadedRecordFields extension, but it's not in GHC yet
02:01:19 <merijn> RustyShackleford: Although you can do it as longas you just have the records in different modules
02:01:35 * hackagebot tianbar 0.4.6.3 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.4.6.3 (AlexeyKotlyarov)
02:01:44 <u-ou> oh that sounds nice
02:01:56 <u-ou> the extension, i mean
02:02:15 <merijn> See https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
02:02:24 <u-ou> ty
02:03:43 <merijn> RustyShackleford: The short summary is: It's widely acknowledged to be annoying, but it's unclear what a good solution would be and it wasn't painful enough to get a lot of effort before
02:06:59 <tiki> re: Pipes, is there a canonical way to turn a pure function into a pipe? something like liftPipe :: (a -> b) -> Pipe a b m ()
02:07:13 <RustyShackleford> merijn: so is the use of the record syntax discouraged?
02:08:14 <zipper> Writing a function to convert a string of hex values to their ascii numbers but I am getting an empty sting. I assume my issue is in the pattern matching since it typechecks. I am always getting an empty string from the function.
02:08:39 <zipper> The code is at:
02:09:14 <Darwin226> Hey guys. Playing around with type families. Can someone explain why this gives False instead of True? http://lpaste.net/118563
02:09:19 <merijn> RustyShackleford: No, records are used in many places
02:09:52 <merijn> RustyShackleford: Picking field names just requires some thought, since they collide with other fields/functions
02:10:06 <merijn> RustyShackleford: Common solutions including prefixing all fields of a record with a short prefix
02:10:38 <merijn> Darwin226: :O
02:10:44 <merijn> Darwin226: I'm confused that compiles at all :)
02:11:01 <Darwin226> merijn: The (Show a=> part?
02:11:01 <merijn> Darwin226: Your type families kind signature is wrong :)
02:11:09 <Darwin226> merijn: Is it?
02:11:12 <zipper> hexToAscii :: String -> [(Int,String)]
02:11:19 <merijn> Darwin226: No, your definition claims the kind of "AllShowable l" is *
02:11:25 <merijn> Darwin226: But you're returning True
02:11:27 <zipper> hexToAscii [] = []
02:11:27 <zipper> hexToAscii (x:y:xs) = (readHex ((show x) ++ (show y))) ++ (hexToAscii xs)
02:11:30 <merijn> :k True
02:11:31 <lambdabot>     Not in scope: type constructor or class ‚ÄòTrue‚Äô
02:11:31 <lambdabot>     A data constructor of that name is in scope; did you mean DataKinds?
02:11:31 <lambdabot>     Perhaps you meant ‚ÄòTree‚Äô (imported from Data.Tree)
02:11:31 <zipper> There is the code. My internet isn't loading lpaste
02:11:40 <merijn> :k 'True
02:11:41 <lambdabot>     Data constructor ‚ÄòTrue‚Äô cannot be used here
02:11:41 <lambdabot>       (Perhaps you intended to use DataKinds)
02:11:41 <lambdabot>     In a type in a GHCi command: True
02:11:43 <Darwin226> merijn: True is a type in this case. data True
02:11:45 <merijn> awww, datakinds is off
02:11:55 <zipper> My issue is that I keep getting an empty string in retun and not [(Int,String)]
02:12:03 <merijn> Darwin226: Ugh, don't do that :(
02:12:09 <merijn> Darwin226: Use DataKinds
02:12:25 <Darwin226> merijn: Ok. But I'm guessing this isn't the problem here
02:12:34 <merijn> Also, the "data True" is not in the paste, so that's rather misleading
02:12:40 <vanila> > let foo (x:y:xs) = (readHex ((show x) ++ (show y))) in foo "3F"
02:12:41 <lambdabot>  []
02:12:53 <vanila> > let foo (x:y:xs) = readHex [x,y] in foo "3F"
02:12:54 <lambdabot>  [(63,"")]
02:13:09 <merijn> Darwin226: Anyway, I'm pretty sure the Show constraint in the pattern match is also not right
02:13:13 <vanila> you shouldn't use show like that, it's making readHex fail
02:13:29 <merijn> Darwin226: Lemme try my hand at an alternative formulation
02:13:38 <Darwin226> merijn: Ok. Thanks
02:14:44 <merijn> Darwin226: I'm assuming you plan to use this in the context of adding a constraint whether all types are a Show instance?
02:15:32 <Darwin226> merijn: Yes. And I know there are easiers ways to do with with just typeclasses. But I wanted to do it like this
02:16:59 <Geraldus> Hello everybody!
02:18:38 <Geraldus> I'm writing simple data validation library, there is ValidationResult data type, which have following constructors: NotValidated | ValidData | InvalidData Reason (https://github.com/geraldus/DataValidation/blob/master/src/Data/Validator/Internal.hs#L10)
02:19:29 <lpaste> merijn pasted ‚ÄúComposing constraints‚Äù at http://lpaste.net/118565
02:19:38 <merijn> Darwin226: That's the way to go :)
02:19:51 <merijn> Darwin226: You can have type families directly return Constraints :)
02:20:00 <Geraldus> And the Reason is type, which represents some message, which could be translated to any language (https://github.com/geraldus/DataValidation/blob/master/src/Data/Validator/Internal.hs#L16)
02:21:55 <Geraldus> I have two issues for now. First I want ValidationResult to have a Monoid instance. Thus, Reason should be Monoid too. Currently it's quite easy to make that instances.
02:22:18 <Darwin226> merijn: Looks great.But I don't get the Foo part. What's it for?
02:22:27 <merijn> Darwin226: Just to show an example :)
02:22:50 <merijn> Darwin226: I needed a datatype that had a type level list to pass to the constraint
02:23:00 <shachaf> <merijn> awww, datakinds is off
02:23:19 <shachaf> int-e: what's with that?
02:23:26 <Geraldus> Second issue, that I want users of library have a way to use custom messages with custom validations (there are few predefined validations in the lib). Currently it's impossible.
02:24:21 <Darwin226> merijn: Couldn't you have used the type level list directly?
02:24:36 <merijn> Darwin226: Maybe, but this was the simplest example that sprung to mind :)
02:24:55 <Geraldus> So, my Reason data type should be parametrised somehow to allow custom messages in Reason context. But in this case I don't know how to make a Monoid instance of Reason.
02:25:22 <Darwin226> merijn: I see. This is quite awesome.
02:26:46 <merijn> Darwin226: I have a bunch more fun examples on github: https://gist.github.com/merijn/39dc86e345e87276c523 and https://gist.github.com/merijn/6130082
02:27:03 <merijn> Darwin226: I also highly recommend the "Fun with Type Functions" paper if you haven't read it, it's very readable!
02:27:22 <Darwin226> merijn: Though I have to admit what's bothering me a bit is that this approach seems much less applicable in general. To other problems I mean. What if there's a situation where I actually DO want to do what I was originally doing?
02:27:36 <Darwin226> merijn: I'm actually reading that papers as we speak :D
02:28:18 <merijn> Darwin226: I'm not sure you can do what you want
02:28:52 <merijn> Darwin226: But that's a rather in-depth question. Maybe ask on glasgow-haskell-users/haskell-cafe if anyone knows?
02:29:07 <Darwin226> merijn: Well in any case. Thanks for the help!
02:29:23 <Darwin226> merijn: I'll look through your other examples and that paper
02:31:35 * hackagebot haskell-rules 0.1.0.1 - A DSL for expressing natural deduction rules in Haskell.  http://hackage.haskell.org/package/haskell-rules-0.1.0.1 (spacekitteh)
02:33:30 <SrPx> Does anyone know how I can install webkitgtk for osx, for ghcjs? When I run the official ./install-dependencies script, it shows: "Currently this script only works for distributions supporting apt-get and yum."
02:33:44 <SrPx> which is nonsense because I downloaded from an osx guide lol https://trac.webkit.org/wiki/BuildingGtk
02:34:31 <StevenJ> How would one go about calling C++ from Haskell and vice versa?
02:35:05 <StevenJ> Backstory: I'm planning on writing an application which would be split into two parts
02:35:28 <StevenJ> The backend: Haskell and the fronted/UI: C++
02:36:15 <vanila> StevenJ, you can do this through the CFFI, but it may also be worth considering using a socket instead
02:36:35 * hackagebot sloane 2.0.4 - A command line interface to Sloane's On-Line Encyclopedia  of Integer Sequences  http://hackage.haskell.org/package/sloane-2.0.4 (AndersClaesson)
02:36:40 <merijn> StevenJ: Through C is the only viable way to directly call C++
02:37:21 <merijn> StevenJ: The good news is that, as long as you don't intend to update structs from within Haskell, the FFI is pretty easy
02:38:03 <bernalex> achievement unlocked: write so much haskell code that it is now considered "legacy code", and can't be rewritten in another language!
02:38:45 <merijn> StevenJ: Here's a minimal example of calling haskell from a C main function. Integrating with C++ is left as an exercise for the reader :)
02:38:48 <merijn> StevenJ: https://gist.github.com/merijn/4a0fee2b3a5ef3476aa4
02:39:06 <StevenJ> Thanks
02:48:08 <cojy> StevenJ: there is https://github.com/NICTA/cplusplus-th
02:48:12 <cojy> i've not looked at it though
02:53:51 <Geraldus> Can I build tuples like lists, e.g. a:b:c:[]?
02:54:21 <vanila> yes
02:54:27 <vanila> (a, (b, (c, ())))
02:54:45 <sgronblo> arent those different types?
02:54:53 <vanila> yes
02:55:03 <sgronblo> (1, (2, 3)) /= (1, 2, 3)
02:55:55 <Geraldus> vanila: what if I want to build a tuple (a,b,c,..)?
02:56:15 <vanila> i dont understand what you mean
02:56:21 <CindyLinz> Geraldus: no
02:56:51 <kgadek> hi. how to build GHC with profiling options ( is it something like GhcProfiled = YES ?) ? where to add this option, or is it env var to set before configure/make?
02:58:07 <merijn> kgadek: Try #ghc :)
02:58:12 <pantsman> Geraldus: You might want to look at using HLists instead, though.
02:58:31 <pantsman> oops, before that, was supposed to be: it would be possible with some use of Generics
02:58:32 <kgadek> merijn: ok, thanks!
02:59:11 <Geraldus> hmm... I'm confused. I want to have some data type to represent failure reason: Reason = Reason [Msg], the problem with this, that I want to allow custom Msg data type. But in this case Reason should be parametrised
03:00:13 <Geraldus> and in case of parametrised Reason data type I can't make a Reason to be a Monoid.
03:00:29 <Geraldus> pantsman: thanks, I'll have a look
03:00:50 <vanila> you could pass in the type of error as a parameter
03:01:11 <vanila> same as how Either e monad works
03:02:57 <Geraldus> let me check Either and Monad
03:03:39 <booba> (:)
03:03:44 <booba> :t (:)
03:03:45 <lambdabot> a -> [a] -> [a]
03:03:47 <barrucadu> Or look at the [a] monoid
03:03:54 <Geraldus> pantsman: Unfortunately, I'm not familiar with Typeable :(
03:04:35 <rom1504> maybe with dependent types you could
03:04:51 <vanila> lets keep it simple
03:04:53 <rom1504> but well haskell doesn't really has them so I guess you can't
03:04:55 <rom1504> yeah sure
03:05:32 <Geraldus> let me explain my issue once again
03:05:46 <Geraldus> I'm writing simple data validation library, there is ValidationResult data type, which have following constructors: NotValidated | ValidData | InvalidData Reason (https://github.com/geraldus/DataValidation/blob/master/src/Data/Validator/Internal.hs#L10)
03:05:52 <Geraldus> And the Reason is type, which represents some message, which could be translated to any language (https://github.com/geraldus/DataValidation/blob/master/src/Data/Validator/Internal.hs#L16)
03:05:58 <Geraldus> I have two issues for now. First I want ValidationResult to have a Monoid instance. Thus, Reason should be Monoid too. Currently it's quite easy to make that instances.
03:06:07 <Geraldus> Second issue, that I want users of library have a way to use custom messages with custom validations (there are few predefined validations in the lib). Currently it's impossible.
03:06:14 <Geraldus> So, my Reason data type should be parametrised somehow to allow custom messages in Reason context. But in this case I don't know how to make a Monoid instance of Reason.
03:07:18 <vanila> http://lpaste.net/118566
03:07:24 <vanila> like this maybe? just waht you have but with type parameter
03:08:43 <Geraldus> vanila: I've already though, that this is my solution, I should check, how parametrised Reason data type will affect other code...
03:09:21 <barrucadu> Geraldus: You can write the Monoid instance like this: http://lpaste.net/6572238129766334464
03:09:51 <Geraldus> originally, I had Reason and ValidationResult both parametrised (because ValidData constructor was originally designed as ValidData validatedData)
03:10:16 <ironChicken> i'm creating a Storable instance for a type that wraps over a C union, but this union seems to be unflagged. any suggestions how, in my peek implementation, i might be able to tell what the union contains?
03:11:38 <Geraldus> barrucadu: surely, but this only works with the same `a` type, in my case there could be situations, when I want to `mappend` reasons parametrised by different messages.
03:11:49 <vanila> haskell-src-exts-1.16.0.1 which failed to install. :(((((((( whyyyy
03:12:06 <barrucadu> Well, you can't, because mappend requires both arguments to be of the same type
03:12:08 <vanila> cabal--
03:12:33 <barrucadu> Unless you have a further layer of wrapping going on
03:13:09 <Geraldus> barrucadu: thus, I have my own analogy of mappend for Reason, like (=+=) which I've already defined earlier, right?
03:13:23 <Geraldus> yeah, or to use some newtype
03:18:16 <SrPx> I think I installed webkitgrc correctly (at least the build script ran) but I still get this error when I try installing webkitgtk: http://lpaste.net/118567
03:18:17 <SrPx> why?
03:29:02 * ironChicken withdraws previous question
03:40:07 <Wizek> Hello. I have a bit of code here that I might want to reuse in GHCI sessions and code that I compile with GHC: https://gist.github.com/Wizek/015b24f334406d6e78a4 What is the easiest way to make this available for imports for myself?
03:58:06 <vpeurala> Hello everybody.
03:58:48 <vpeurala> Does somebody know if there is a way to fold over a data structure with an accumulator function which uses unboxed types?
03:59:14 <vpeurala> The error message is:
03:59:15 <vpeurala>     Kind incompatibility when matching types:       a0 :: *       (# Int#, Int# #) :: #
03:59:51 <vpeurala> from the following code:
03:59:52 <vpeurala> T.foldl' scoreCalculator (# 0#, 0# #) word
04:00:04 <vpeurala> where the type of scoreCalculator is
04:00:04 <vpeurala> scoreCalculator :: (# Int#, Int# #) -> Char -> (# Int#, Int# #)
04:06:42 <SrPx> does anyone please have any idea why this is happening? :/ http://lpaste.net/118570
04:07:24 <SrPx> webkitgtk compiled successfully but cabal still complains it doesn't exist...
04:11:55 <merijn> vpeurala: That's an unboxed tuple, unboxed tuples can't be passed as arguments
04:12:14 <merijn> unboxed tuples can only be return values and the only thing you can do with them is pattern matching
04:12:25 <merijn> Because they represent return values returned inside registes
04:12:35 <merijn> So the type you asked for is impossible
04:13:26 <merijn> Presumably you want "(Int#, Int#) -> Char -> (Int#, Int#)" or something similar
04:18:45 <mokasin> hi, I'm new to Haskell. Can somebody tell me, why I have to run cabal install multiple times? Sometimes it fails, then I just run it again and it worksÖ
04:23:02 <vanila> cabal is dodgy :S
04:23:08 <vpeurala> merijn: Yes, that's exactly the type I was looking for.
04:23:22 <vpeurala> But if that's impossible, then I'll have to find some other way.
04:23:25 <dcoutts> mokasin: you'd have to be more specific
04:23:25 <vpeurala> Thanks for your answer.
04:24:06 <Tehnix> If I were getting an error `Exception when trying to run compile-time code: static/css/bootstrap.min.css: openBinaryFile: does not exist`, would one not assume that simply placing a file there would solve that?
04:26:54 <mokasin> dcoutts, for instance, I've installed a freshly initialisesd Yesod project, and the first time I run cabal install I got "adjunctions-4.2 failed during the building phase. The exception was:ExitFailure (-11)". then I just ran again and this time it worked just fine
04:27:23 <mokasin> dcoutts, or I have to run cabal update sometimes also mutiple times, and nondeterministically it works
04:27:30 <zomg> mokasin: how much ram do you have?
04:27:43 <mokasin> zomg, 16 gig
04:28:01 <zomg> ok, I tended to have more random issues with cabal with low amount of ram but 16 is more than enough I think =)
04:28:14 <mokasin> zoglesby, I think so ;)
04:28:16 <merijn> mokasin: Hard to say without -v3 output
04:28:31 <mokasin> zomg, i meant you...
04:28:32 <merijn> mokasin: If this happens frequently, start using -v3 when installing and see what it reports when it fails
04:29:07 <mokasin> merijn, will do that
04:29:27 <mokasin> so thats propably not a normal cabal behaviour I have there?
04:29:57 <dcoutts> mokasin: ExitFailure (-11)  is a segfault
04:30:56 <dcoutts> ie the program cabal called to do the build failed with a segfault
04:31:05 <dcoutts> which is indeed unusual
04:33:16 <Freundlich> mokasin: Random segfaults often indicate faulty memory.
04:33:24 <Freundlich> mokasin: Just in case you should do a memtest.
04:33:54 <mokasin> Freundlich, hmm, will do that. Everything else is working fine though.
04:35:04 <qz> is it ok that foldM is 50 times slower than foldl' ? considering that only IO i'm doing is sometimes priting progress..
04:36:14 <merijn> qz: "only IO"
04:36:26 <merijn> qz: Printing to stdout is orders of magnitude slower than applying a function
04:38:13 <qz> merijn: well, it depends on function i guess. i need to insert large number of bytestrings into Set and just inserting vs inserting + priting progress sometimes (like on everty 10000th insert) differ in speed by a factor of 50
04:38:26 <mokasin> Just got: Failed to install shakespeare-2.0.3 \n Build log ( /tmp/test/.cabal-sandbox/logs/shakespeare-2.0.3.log ): \n cabal: /tmp/test/.cabal-sandbox/logs/shakespeare-2.0.3.log: does not exist
04:38:31 <mokasin> http://pastebin.com/LSks0puU
04:38:40 <mokasin> this also happens frequently
04:39:15 <mokasin> it just says, it failed, and nothing more, even with -v3...
04:39:47 <merijn> qz: Right, and like yesterday I'm saying that that is totally expected
04:39:52 <merijn> If you want to be fast, don't do IO
04:39:56 <Peaker> shachaf: before you asked what you could do with fundeps and not type families
04:40:30 <qz> merijn: but why? priting 100 times over the course of inserting 15M items slow everything THAT much?
04:40:37 <qz> *printing
04:40:38 <merijn> Yes
04:40:39 <Peaker> the equivalent of:  instance Foo Bar where type SomeType Bar = forall b. Moo b    is, I think, possible with fundeps
04:40:52 <merijn> Inserting things into data structures is cheap
04:40:54 <chpatrick1> how long does it take without printing?
04:40:58 <merijn> Printing things is slow
04:41:12 <Peaker> instance Foo Bar b where .. <-- allowed!
04:41:19 <Peaker> (but not the "forall" inside a family instance)
04:41:27 <qz> merijn: but if i insert all the stuff using foldl' and then do all printing after that -- its still fast
04:41:45 <chpatrick1> qz: could you calculate how long it takes "per print"?
04:41:59 <chpatrick1> qz: (with_print_time - without_print_time) / num_prints
04:42:14 <qz> chpatrick1: visually, difference is too big, sadly
04:42:41 <mokasin> hmm, seems indeed like ghc crashes regularly
04:42:49 <zwer> qz what flags are you using during compilation?
04:42:57 <chpatrick1> if you're using ghci try :set +s to get timing
04:42:58 <Peaker> qz: it can even be something like a terminal emulator slowing things down... gnome-terminal, for example, is *much* slower than urxvt (I recently switched because of this!)  so simple line prints to stdout can waste tons of CPU time
04:43:06 <qz> zwer: -O2 -threaded
04:43:39 <Peaker> so annoying, though, that urxvt like so much OSS comes with the worst imaginable defaults, and a terrible config format to override them
04:43:43 <qz> Peaker: nono, not to such degree. i understand that if i print on every insert that's gonna be slow
04:44:00 <Peaker> qz: gnome-terminal can cost dozens of milliseconds for just a pageful of prints!
04:44:10 <qz> here's code btw http://lpaste.net/118496 i suspect it has something to do with copying vs non-copying whole set between inserts
04:44:30 <qz> but i'm total haskell noob and cant figure out more
04:44:51 <merijn> qz: I also pointed out yesterday that foldl' is strict and foldM is not
04:45:17 <qz> merijn: i tried strict version of foldM also (found somewhere on stackoverflow)
04:45:50 <qz> merijn: also i did memory profiling and didn't see large amount of 'stack' thunks on graphs
04:47:19 <Peaker> qz: general feedback: don't use "return" in consume to make it IO  -- minimize use of IO
04:47:19 <Peaker> ditto for consumeOne
04:47:19 <Peaker> oh, consumeOne does IO, oops
04:47:19 <Peaker> qz: does HashSet have O(1) size?
04:48:06 <qz> Peaker: it better has.. let me check
04:48:24 <Peaker> qz: nope!
04:48:38 <Peaker> qz: the size isn't O(1) so every test you do for `mod` is expensive!
04:48:48 <Peaker> qz: and as merijn said, foldM isn't strict like foldl', so you're building tons of thunks
04:49:04 <qz> Peaker: oh... not having O(1) size is a shame
04:49:41 <Peaker> qz: well, you can keep the size outside, so why should everyone pay for it? I guess that's their reasoning. But I agree with you :)
04:50:14 <qz> Peaker: how can i see that building tons of thunks? i did memory profiling and it shows me something like https://www.dropbox.com/s/mg4mslc8qf582zh/Screenshot%202015-01-16%2015.46.53.png?dl=0
04:50:32 <Peaker> qz: also, I'm not sure how fast/slow lazy bytestrings are at doing things like split '\n'.  Conduits/Pipes/etc might be faster
04:50:35 <qz> i read somewhere that thunks show up as 'stack' items on these graphs
04:50:54 <qz> Peaker: bytestrings are not a problem, if i remove set/inserting stuff its blazing fast
04:51:27 <Peaker> qz: if you remove set/inserting stuff, does it not optimize into nothing? :)
04:51:41 * hackagebot gl 0.7 - Complete OpenGL raw bindings  http://hackage.haskell.org/package/gl-0.7 (EdwardKmett)
04:51:51 <chpatrick1> qz: I would use HS.fromList . map bs2hash anyway
04:51:54 <qz> Peaker: no, i still count processed lines for example =p
04:52:19 <qz> chpatrick1: but how do i print progress in this case?
04:53:10 <Peaker> qz: so the bytestring is consuming almost all your heap, which is weird because I'd expect it to be collected on the go? I'm non profiling expert myself
04:53:19 <mgore> anyone here who could answer a question related to persistent/yesod?
04:53:32 <chpatrick1> well I guess I wouldn't :P but then manual recursion with a counter instead of foldM I guess
04:53:36 <mgore> (yesod channel is silent)
04:53:38 <qz> Peaker: i keep hashes (bytestrings) into set, so its supposed to grow
04:54:21 <qz> chpatrick1: i'll try doing manual recursion. is it general rule to avoid foldM ?
04:54:54 <chpatrick1> qz: well it doesn't seem ideal in this case
04:55:09 <qz> its just sad that stupid ruby implementation using builtin sets beats haskell here =p both memory and speed-wise
04:55:12 <Peaker> qz: maybe you could use HS.fromList on chunks of 10000 each, concating them into your accumulator and printing progress?
04:55:40 <Peaker> qz: well, a trivial Ruby/Python program that is a very thin wrapper around optimized C code will beat a Haskell program using persistent/immutable data structures
04:55:52 <qz> Peaker: gonna try that
04:56:16 <chpatrick1> qz: fromList is just inserting with foldl' btw
04:56:29 <qz> and by the way -- is there any way to make it eat less memory? ruby version uses around 3G per 20M hashes while haskell is around 8G
04:57:27 <lachenmas> is there any way of wrapping a monadic function that does messy shell/io stuff in a "transaction" of sorts? ie, any other caller will block until the entire function has finished executing
04:57:35 <Peaker> qz: where does the 8G go, according to a heap profile?
04:58:05 <Peaker> lachenmas: isn't that the default behavior?  foo <- someYuckShellStuff -- blocks until someYuckShellStuff finishes?
04:58:15 <chpatrick1> lachenmas: you could use withMVar
04:58:36 <qz> Peaker: let me check..
04:58:54 <chpatrick1> and pass the same mvar for all the things you don't want to trample over each other
04:59:37 <Peaker> lachenmas: if you want it to happen asynchronously in the background and eventually block on it, you can use the excellent "async" library
05:00:23 <Peaker> lachenmas: it looks like: result <- async (background action to execute) ; (wait result {- blocks until a result is available, yields that result/exception, even multiple times -})
05:00:39 <lachenmas> Peaker: ah, that does look great!
05:00:55 <lachenmas> i'll try that, otherwise i'll use mvars, thanks chpatrick1
05:01:11 <Peaker> "async" library basically does the mvar stuff internally
05:02:15 <Peaker> lachenmas: also, if you don't want an exception in the parent to "leak" the background process, you should use:  "withAsync (action to run) $ \async -> ... this code is exception-protected to not leak the background action ..."
05:20:32 <jaboja> Does Maybe monad have any advantages compared to constructs used in other programming languages (like exceptions or nullable types)?
05:22:12 <shiona> jaboja: you are forced to check them
05:22:26 <Peaker> jaboja: The Maybe *type* is definitely advantageous for many scenarios over nullable types (and sometimess exceptions, but there's less overlap there)
05:22:33 <mauke|> you can represent Just Nothing
05:22:38 <vanila> jaboja, it's not so much advantage/disadvantage. Haskell puts all these sorts of things into a single framework: monads - other languages have other approaches
05:22:42 <Peaker> jaboja: the fact Maybe is a Monad is less important
05:23:46 <zomg> I think the benefits with Maybe come from the ability to easily chain them etc. in Haskell
05:23:47 <hyPiRion> jaboja: It's easier to avoid runtime exceptions because you are more or less forced to ensure the Maybe isn't Nothing (Null)
05:23:54 <Peaker> jaboja: The Either type's monad instance has more overlap with (checked) exceptions in other languages, but it is not really that great for that purpose
05:24:06 <zomg> You can implement a Maybe in any language, but it will be less convenient because they would still lack the useful facilities in Haskell
05:24:20 <Peaker> jaboja: so if you're looking for advantages, I'd focus on the nullability aspect, which is a huge advantage of Maybe over having "null" where you don't necessarily want it
05:24:24 <hyPiRion> zomg: yeah, agreed
05:28:54 <KaneTW> is there a way to make an instance Show (a -> b) print the types of a -> b like lambdabot or ghci does?
05:29:18 <KaneTW> a and b rather
05:31:40 <mauke|> sure, lambdabot isn't magic
05:32:47 <mauke|> instance (Typeable a, Typeable b) => Show (a -> b) where show f = show (typeOf (argOf f)) ++ " -> " ++ show (typeOf (resultOf f)) where argOf :: (a -> b) -> a; argOf = undefined; resultOf :: (a -> b) -> b; resultOf = undefined
05:32:53 <mauke|> or something like that
05:33:03 <RchrdB> It's this library: http://hackage.haskell.org/package/show
05:33:16 <qz> ok, it looks like HashSet.size is really-really slow and actually a source of all my pain =p
05:33:24 <mauke|> oh, of course
05:33:32 <mauke|> a -> b is typeable itself
05:33:47 <mauke|> show f = show (typeOf f)
05:34:18 <RchrdB> KaneTW: ‚Üë
05:35:05 <hrumph> hi
05:35:16 <hrumph> i don't understand the need for data families when you've got type families
05:36:01 <hrumph> cause you can always just define a data some where and then assign it to some type instance and use a type family... am i missing something?
05:37:19 <mauke|> maybe type families are too flexible
05:37:35 <mauke|> data families should be injective
05:42:58 <hrumph> http://stackoverflow.com/questions/20870432/type-family-vs-data-family-in-brief-haskell#
05:43:07 <hrumph> just found that...much to ponder
05:43:12 <KaneTW> thanks!
05:48:13 <hrumph> seems as though you will really only want to use data when "you're probably quite happy for the GMap k type to be abstract to you and just manipulate it via the generic map operations in the type class."
06:11:26 <braind> Hey
06:11:38 <Iceland_jack> Hey brackets
06:11:43 <Iceland_jack> *braind
06:11:53 <braind> I'm trying to install SDL on my MacOSX to use with reactive-banana-sdl
06:12:06 <braind> Actually Ive got SDL installed
06:12:20 <braind> but when I run cabal install reactive-banana-sdl
06:12:34 <braind> it terminates with:
06:12:35 <braind> Loading package SDL-0.6.5 ... <command line>: can't load .so/.DLL for: /usr/local/lib/x86_64-osx-ghc-7.8.3/SDL-0.6.5/libHSSDL-0.6.5-ghc7.8.3.dylib (dlopen(/usr/local/lib/x86_64-osx-ghc-7.8.3/SDL-0.6.5/libHSSDL-0.6.5-ghc7.8.3.dylib, 9): Symbol not found: _SDL_FreeRW
06:12:35 <braind>   Referenced from: /usr/local/lib/x86_64-osx-ghc-7.8.3/SDL-0.6.5/libHSSDL-0.6.5-ghc7.8.3.dylib
06:12:35 <braind>   Expected in: flat namespace
06:12:38 <braind>  in /usr/local/lib/x86_64-osx-ghc-7.8.3/SDL-0.6.5/libHSSDL-0.6.5-ghc7.8.3.dylib)
06:13:05 <braind> Any clue how to fix it?
06:13:58 <Iceland_jack> No idea, but you should use lpaste for output:
06:13:58 <Iceland_jack> @where lpaste
06:13:58 <lambdabot> http://lpaste.net/
06:16:59 <braind> ahh ok
06:19:03 <neuroserpens1> Guys... Noob question. What's wrong with this? f n x:l | x < n = x:f n l | otherwise = f n l
06:19:22 <ij> Maybe you can paste it somewhere without concatenation?
06:19:30 <braind> http://lpaste.net/118572
06:20:09 <Iceland_jack> neuroserpens1: You need parentheses around (x:l)
06:20:20 <neuroserpens1> Iceland_jack: o crap... thank you so much
06:21:12 <mauke|> this is why you should put spaces around your operators
06:21:16 <mauke|> f n x : l looks less misleading
06:21:32 <neuroserpens1> Iceland_jack: It worked. mauke| Thanks. I'll do that too.
06:22:00 <Iceland_jack> neuroserpens1: You usually don't put spaces around (:) when pattern matching though
06:22:16 <mauke|> I totally do
06:22:20 <mauke|> no exceptions
06:22:30 <Iceland_jack> Yes, it's just not standard
06:22:43 <neuroserpens1> I think I'll go with mauke| on this one Iceland_jack  :P
06:22:46 <Iceland_jack> @src map
06:22:46 <lambdabot> map _ []     = []
06:22:46 <lambdabot> map f (x:xs) = f x : map f xs
06:23:15 <Iceland_jack> Sure, pick what ever you feel comfortable using
06:25:40 <mauke|> map f(x:xs) = f x:map f xs  -- maximum awful
06:26:02 <ij> "when pattern matching"
06:26:03 <Iceland_jack> de gustibus
06:28:44 <ddellacosta> How does one split a CInt in half (take the first 8 bits) so that one can stuff it into a data structure expecting a CChar?
06:29:47 <Clint> ddellacosta: you have a 16-bit CInt somewhere?
06:29:49 <ddellacosta> or, is there some way to coerce a CInt into a CChar in Haskell?
06:30:17 <ddellacosta> Clint: yes, I'm trying to port some really basic C code
06:30:46 <Clint> from the '80s
06:30:48 <mauke|> does ghc even run on platforms with 16-bit ints?
06:31:03 <ddellacosta> Clint: I guess so...I don't know much about C I'm afraid. :-(
06:31:32 <ddellacosta> mauke|: I didn'
06:31:41 <ddellacosta> didn't think 16 bit ints were that uncommon
06:31:53 <mauke|> they are
06:32:06 <mauke|> nowadays ints are 64 bit (or 32 bit)
06:32:13 <ddellacosta> huh, didn't know that
06:32:26 <ddellacosta> maybe this is a short int?  Dunno
06:32:38 <mauke|> for example, I've written firmware code for barcode scanners
06:32:39 <ddellacosta> but it's being bit shifting by 8
06:32:44 <ddellacosta> shifted*
06:32:48 <mauke|> the compiler had 32-bit ints
06:33:02 <ddellacosta> ah
06:33:15 <ddellacosta> ah yeah, poking around online now, I see
06:33:46 <Clint> ddellacosta: once you get past the issues of wordsize and endianness, you might find Data.Bits useful
06:33:49 <mauke|> > fromIntegral (0x8080 :: CInt) :: CChar
06:33:50 <lambdabot>  Not in scope: type constructor or class ‚ÄòCChar‚Äô
06:33:50 <lambdabot>  Perhaps you meant ‚ÄòChar‚Äô (imported from Data.Char)Not in scope: type constru...
06:33:50 <lambdabot>  Perhaps you meant one of these:
06:33:58 <mauke|> :-(
06:34:21 <ddellacosta> Clint: I'm using that to do the bit shifting, but getting a bit lost on how to produce a CChar from a CInt.  Probably I'm trying too hard to mimic the original C code.
06:34:37 <nwalker> @undo do x<- [1, 2, 3]; y <- [4, 5, 6]; return (x+y)
06:34:37 <lambdabot> [1, 2, 3] >>= \ x -> [4, 5, 6] >>= \ y -> return (x + y)
06:34:38 <Iceland_jack> ghci> import Foreign.C.Types
06:34:38 <Iceland_jack> ghci> fromIntegral (0x8080 :: CInt) :: CChar
06:34:38 <Iceland_jack> -128
06:34:43 <ddellacosta> Clint: (see https://xiph.org/ao/doc/ao_example.c)
06:35:00 <ddellacosta> Iceland_jack: maybe that'll do it, thank you!
06:35:18 <Iceland_jack> Well it's mauke|'s code
06:35:51 <ddellacosta> ah, sorry mauke|! thanks
06:36:35 <Iceland_jack> ddellacosta: If you specifically want signed or unsigned chars use CSChar or CUChar
06:37:02 <ddellacosta> Iceland_jack: gotcha, thanks
06:41:12 <danilo2> Hello! What is called the feature of haskell that allows deifning something like c++ macros? I'm not tlaking about TH here - I've seen in the past something like just a fucntion that replaces its call with just a code
06:41:30 <Iceland_jack> danilo2: CPP?
06:41:42 * hackagebot haskell-generate 0.2.3 - Typesafe generation of haskell source code  http://hackage.haskell.org/package/haskell-generate-0.2.3 (BennoFuenfstueck)
06:41:56 <danilo2> Iceland_jack: ok, so -XCPP introduces it? ok. Ah right! the #define pragma i think!
06:41:57 <flux> danilo2, rewrite rules
06:42:04 <mauke|> inlining?
06:42:10 <danilo2> flux: no, I was thinking of somethingl ike #define
06:42:14 <Iceland_jack> that's right danilo2
06:42:20 <danilo2> Iceland_jack: thank you!
06:42:20 <flux> well then they probably just use the C preprocessor :-)
06:42:59 <mauke|> also, don't use the C preprocessor
06:51:19 <danilo2> Excause me, do anybody know where can I learn more about parametrized CPP macros in haskell to be able to use them "like functions" but they shoudl just generate haskell code (like normal cpp macros, but with parameters) ?
06:52:09 <int-e> danilo2: err the C preprocessor does have macros with parameters.
06:52:12 <EvilTerran> danilo2, it works exactly the same in Haskell as in C - I think GHC even uses the same preprocessor program as your C compiler
06:52:29 <merijn> danilo2: Those *are* normal CPP macro's :)
06:52:56 <EvilTerran> danilo2, but as mauke| said, "don't use the C preprocessor" - it's not very idiomatic in Haskell-land. what are you trying to use it for? there might be a better way
06:53:13 <danilo2> int-e, EvilTerran: oh, the rules are really very simmilar - you just cannot use whitespaces before the parenthesis. Great! :)))
06:53:23 <danilo2> merijn: ^^^ Thank you! :)
06:54:14 <danilo2> EvilTerran, mauke: I know, I know, don't worry - i know what I'm doing :) I use them in some fancy code replacement in generated haskell code. Instead of generating some snippets I can use macros - they will save al ot work for me :)
06:54:16 <merijn> I'm pretty sure you *can* use whitespace before parenthesis, or should be able to
06:54:44 <danilo2> merijn: according to: http://projects.haskell.org/cpphs/ I cannot
06:55:01 <danilo2> merijn: ". Previously, this was interpreted as a parametrised macro, with arguments in the parens, and no expansion. Now, the space indicates that this is a textual replacement, and the parenthesised expression is in fact the replacement."
06:55:17 <merijn> cpphs is not the one that GHC uses by default
06:55:18 <mauke|> that's just definition, though
06:55:22 <mauke|> not expansion
06:55:42 <danilo2> merijn: oh, cpphs is not the preprocessor? ah!
06:55:54 <merijn> And I spent some time implementing a CPP parser and iirc the C standard says you *can* use spaces before parentheses
06:56:04 <mauke|> merijn: no in the definition
06:56:07 <merijn> danilo2: cpphs is *a* preprocessor, but it's not the default one
06:56:10 <mauke|> er, *not
06:56:12 <merijn> mauke|: Sure
06:56:24 <mauke|> well, you *can*
06:56:29 <merijn> I was just referring to usage
06:56:43 <mauke|> no one was talking about usage
06:56:54 <danilo2> right, we cannot use spaces in definitions only :)
06:59:54 <danilo2> merijn: right - I understood your sentence exactly this way, sorry for being unclear :)
07:00:51 <EvilTerran> I guess it has to distinguish between "#define foo(bar) baz", where "foo(eek)" -> "baz"... and "#define foo (bar) baz", where "foo(eek)" -> "(bar) baz(eek)"
07:00:54 <jackhill> win 19
07:01:14 <mauke|> EvilTerran: right
07:06:40 <jonkri> How can I tell Cabal to do this in one go? "Install package X with the constraint that it should fulfill the dependencies of package Y in addition to the dependencies of package X." :)
07:06:55 <jonkri> s/fulfill/install
07:07:18 <jonkri> So that when package Y is installed, no dependencies will be need to be installed.
07:10:46 <bergmark> jonkri: do you mean `cabal install foo bar --only-dependencies' ?
07:11:00 <bergmark> i think that works as long foo and bar don't depend on each other
07:12:29 <jonkri> bergmark: Y depends on X in this case.
07:13:02 <jonkri> bergmark: I want to install package X and the dependencies of Y (and the dependencies of X, of course).
07:14:04 <fizbin> jonkri: So what you're saying is that you want to install the dependencies of Y, which includes X
07:14:51 <jonkri> fizbin: Oh - yes. :) But X is not on Hackage.
07:15:15 <Denommus> jonkri: are you inside a sandbox?
07:15:25 <Denommus> jonkri: if so, just add the source
07:15:49 <jonkri> Denommus: No. I'm using the Haskell Docker image, so I wasn't planning on using a sandbox. Is there another way?
07:16:55 <fizbin> Well, you can switch to the directory for X, do a "cabal install --dependencies-only" followed by "cabal install", then switch to Y and do  "cabal install --dependencies-only"
07:17:12 <fizbin> That should get you where you want to be.
07:17:23 <jonkri> fizbin: I think I did that, but I got a "Backjump limit reached" error.
07:17:32 <bergmark> increase the backjump limit :-)
07:17:38 <bergmark> and/or try --reorder-goals
07:17:45 <jonkri> bergmark: Oh, OK.
07:18:03 <jonkri> I thought my process was broken. :)
07:18:12 <jonkri> Thanks, everyone!
07:18:25 <bergmark> the default backjump limit is very low i think
07:26:07 * ironChicken has been working things out for himself all day
07:38:14 <timothyw> Anyone willing to pair to setup a haskell dev environment?
07:38:29 <jonkri> Has anyone here had problem with the Cabal, or the Haskell Docker image, where random packages "fails to install" followed with an error "cabal: /root/.cabal/logs/X.log: does not exist". Sometimes the build fails, and sometimes it doesn't. Different packages can cause the failure.
07:38:49 <timothyw> I‚Äôm having problems setting up haskell-platform on ubuntu 15.04 (vivid) and 14.10 (utopic)
07:39:57 <timothyw> jonkri: I‚Äôm having cabal update and install failures when trying ‚Äòcabal update‚Äô or ‚Äòcabal install purescript‚Äô
07:41:42 * hackagebot arrow-list 0.7 - List arrows for Haskell.  http://hackage.haskell.org/package/arrow-list-0.7 (AdamBergmark)
07:42:09 <jonkri> timothyw: You probably want to paste what's happening on something like <http://lpaste.net/>.
07:45:43 <timothyw> jonkri: indeed. here it is: http://lpaste.net/118579
07:46:27 <mroman> Help. My code has a "Hole".
07:47:12 <jonkri> timothyw: I've never experienced that. Do you have enough RAM on your machine?
07:47:30 <mroman> http://codepad.org/z0zDMhlL
07:47:52 <merijn> mroman: ick! :(
07:48:05 <timothyw> jonkri: dunno: I‚Äôm running it in a Vagrant VM : https://github.com/twashing/configurations/blob/master/vm/default/Vagrantfile
07:48:07 <mroman> it's generated code
07:48:08 <mroman> so...
07:48:13 <mroman> indentation is not so nice, yes
07:48:30 <merijn> mroman: Holes are identifiers starting with an underscore and that are not in scope (i.e. non-existent identifiers)
07:48:38 <merijn> GHC reports them as "typed holes" and prints their type
07:49:31 <mroman> oh
07:49:32 <mroman> ok
07:49:37 <mroman> That explains a lot :)
07:49:39 <merijn> mroman: i.e. your code generation is fucking up and generating identifiers that aren't in scope :p
07:49:46 <mroman> Yep :)
07:50:51 <mroman> Thanks :)
08:00:41 <timothyw> jonkri: it was indeed a memory issue
08:00:56 <timothyw> Thanks, there just wasn‚Äôt any indication of the failure
08:02:52 <jonkri> timothyw: Yeah, they can be a little sneakly like that. I'm glad you found the problem. :)
08:03:02 <timothyw> :)
08:03:31 <shachaf> @tell Peaker I'm not sure I understand your fundep example.
08:03:31 <lambdabot> Consider it noted.
08:17:25 <nitrix> How does one have a signature that looks like  `f (a -> b)` ?
08:17:35 <nitrix> I don't understand <*>
08:17:48 <shachaf> :t Just (+5)
08:17:49 <fizruk> :t fmap (+) (Just 2)
08:17:49 <lambdabot> Num a => Maybe (a -> a)
08:17:51 <lambdabot> Num a => Maybe (a -> a)
08:18:02 <nitrix> Partial application?
08:18:28 <shachaf> It's just regular application.
08:18:46 <nitrix> Oh you'r eright.
08:19:28 <nitrix> Fascinating.
08:19:48 <nitrix> So I'm much more likely to see <$> than <*>
08:20:50 <zipper> What does [_] mean in a pattern match?
08:21:03 <Iceland_jack>  
08:21:03 <Iceland_jack> match a list of length one
08:21:55 <zipper> Iceland_jack: Thanks
08:24:05 <chrisdone> is there an abstraction to use a local state of a differing type in the same monad? like (MonadState s m,MonadState s' m') => (s -> s') -> m' a -> m a
08:25:14 <johnw> chrisdone: ST?
08:25:37 <johnw> chrisdone: actually, the type you've written looks like an indexed state monad
08:25:57 <johnw> perhaps: IStateT i o m a -> IStateT o p m a?
08:27:45 <chrisdone> yeah, defining my own type is the alternative
08:28:11 <johnw> https://hackage.haskell.org/package/indexed-extras-0.1.1/docs/Control-Monad-Indexed-State.html
08:29:48 <mpickering> the new nixs haskellng stuff looks like stackage on steroids
08:29:53 <EvilTerran> and I believe you can use indexed monads in do-notation with -XNoImplicitPrelude and (>>=) = ibind; return = ireturn
08:30:00 <EvilTerran> (or is it -XRebindableSyntax nowadays)
08:30:09 <Iceland_jack> EvilTerran: latter
08:30:14 <Iceland_jack> it implies the former
08:30:23 <EvilTerran> good to know
08:30:41 <mpickering> indexed monads are still quite fiddly to work with as you can't have the same utility functions as Control.Monad
08:30:47 <mpickering> not really sure what could be done to make it better
08:31:31 <hop_> Hello all, I am a bit confused with bytestring append. The cost is O(n) on the doc with n equal to the sum of both source strings?
08:31:51 <mauke|> hop_: length of resulting string, yes
08:32:29 <EvilTerran> mpickering, what sort of utility functions do you mean?
08:33:06 <mpickering> mapM sequence etc..
08:33:10 <hop_> mauke|: argh. So, if I concat a list of bytestring, I end up with square complexity (saying list items have equal length) if I use concat on [ByteString]?
08:33:43 <mpickering> maybe use the builder?
08:33:47 <Iceland_jack> hop_: Data.ByteSTring.concat is O(n)
08:33:49 <mauke|> hop_: no, concat is also O(n)
08:33:56 <Iceland_jack> *ByteString
08:34:06 <EvilTerran> ?type sequence
08:34:07 <lambdabot> Monad m => [m a] -> m [a]
08:34:30 <hop_> mauke|: It does not use append?
08:34:39 <tremon> Isn't ByteString.Lazy exactly that, a list of ByteStrings?
08:35:01 <EvilTerran> mpickering, surely you could have something like isequence :: IxMonad m => [m i i a] -> m i i [a] ?
08:35:44 <mauke|> that is a good question, actually
08:35:59 <fizruk> hop_: why do you think append is a problem?
08:36:40 <fizruk> oh, I see
08:37:00 <EvilTerran> hop_, no, BS.concat isn't just fold/append under the hood - it does something clever to get better performance: http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/src/Data-ByteString-Internal.html#concat
08:37:04 <mauke|> hop_: http://hackage.haskell.org/package/bytestring-0.10.4.1/docs/src/Data-ByteString-Internal.html#concat
08:37:17 <hop_> fizruk: No it is not but I assumed (I guess wrongly) that O(lhs+rhs) for append implied O(n2) for concat where n is final length. But I want to use concat so this is great!!
08:37:23 <chrisdone> johnw: i made this little proof of concept consumers library https://github.com/chrisdone/descriptive
08:37:23 <chrisdone> johnw: it generalises a bunch of things and the state handling is deferred to a MonadState instance e.g. here http://chrisdone.com/descriptive/Descriptive.html#v:consume
08:37:23 <chrisdone> johnw: but a type-changing withState lets one write well-typed parsers for nested data structures better
08:37:27 <mauke|> slightly tricky to find because concat is defined as mconcat, which is defined as concat
08:37:30 <mauke|> (in different modules)
08:37:35 <mpickering> EvilTerran: You can but that's maybe not that useful :)
08:38:28 <chrisdone> johnw: i might just shift the `s' into the Consumer type. then i can have a Consumer d s a -> Consumer d s' a without issue
08:38:36 <hop_> EvilTerran: Makes sense! Allocate everything once and copy.
08:38:47 <johnw> chrisdone: Yes, ReinH was telling me about this.  I can't remember the name of the other bidirectional parsing library was that I saw recently‚Ä¶
08:39:13 <chrisdone> i already have a very similar type here in a separate but related project https://github.com/chrisdone/exercise/blob/master/src/Exercise/Types.hs#L20
08:39:28 <EvilTerran> mpickering, well... yeah, I suppose that necessitates using your indexed monad as a regular one
08:39:32 <chrisdone> might just go with that and then rewrite "exercise" to use this more general lib
08:39:34 <EvilTerran> effectively
08:40:09 <EvilTerran> mpickering, but isequence could still do more than sequence, because the element actions could use different-typed state internally
08:41:47 * hackagebot seqloc 0.6.1.1 - Handle sequence locations for bioinformatics  http://hackage.haskell.org/package/seqloc-0.6.1.1 (NicholasIngolia)
08:42:16 <chrisdone> ReinH: i think the descriptive lib can be used to parse ACE for a trivial MUD example. i was just fiddling with it. but it'll be far nicer with type-changeability so i'mma implement that before i make an ACE sample
08:43:25 <EvilTerran> mpickering, I'm now envisaging something dubious involving Rank2Types and TypeFamilies that might let you have a sequence-alike function with the full power of indexed monads
08:53:09 <xuinkrbin> Anyone know of what One might call a "visual debugger", similar to Xcode or Visual Studio, which allows One to step thru a GHC run, line by line and/or step into/out-of code?
08:53:24 <Babycaz2> .l Who need a bit of shit ?
08:53:31 --- mode: ChanServ set +o geekosaur
08:55:02 <geekosaur> xuinkrbin, there isn't one, because Haskell evaluation is not linear but data-driven graph reduction
08:55:45 --- mode: ChanServ set +o johnw
08:55:45 --- mode: johnw set +b *!~Babycaz@198.7.59.108
08:55:45 --- kick: Babycaz2 was kicked by johnw (Kicked)
08:55:45 --- mode: johnw set -o johnw
08:56:24 <geekosaur> I was going to wait and see if it did anything else...
08:56:25 --- mode: geekosaur set -o geekosaur
08:57:28 <geekosaur> xuinkrbin, you can surely "step into" something, but it will simply return immediately and won't execute until something, possibly car away from the apparent call site, demands the value
08:57:47 <xuinkrbin> That makes sense
08:57:49 <xuinkrbin> Thanks
08:58:49 <ClaudiusMaximus> there are some tools that show graph reduction graphically - maybe ghc-vis?
08:59:13 <ClaudiusMaximus> might be impractical for large programs though
08:59:30 <geekosaur> yes, and not useful for an IDE-style visual debugger
09:00:20 <geekosaur> I think ghc 7.10 (certainly 7.12, but 7.10 will have some part of it) will actually enough information to write such a thing... it just won't be comprehensible to humans
09:00:33 <geekosaur> (without requiring use of the bytecode backend)
09:08:13 * hodapp attempts to figure out how to use Haddock with funky quasiquoted types
09:09:00 <hodapp> I'm not sure if Haddock wants to touch these. I'm also not sure why I'm using quasiquoting here when it might be simpler not to, in terms of how things like Haddock and text editors handle it.
09:36:30 <eacameron> is there a an "Ansible"-like tool in Haskell? It seems shake + SSH could be pretty awesome in that department
09:44:33 <shachaf> https://ghc.haskell.org/trac/ghc/ticket/10000
09:46:37 <glguy> Now that you have the 10,000th ticket, it's time to start working toward the 100,000th commit
09:57:22 <cedricshock> Is type application injective? Does `f a ~ g b` imply `f ~ g` or `a ~ b`?
09:57:23 <NemesisD> woah wtf. t <- getCurrentTime; eitherDecode (encode t) :: Either String UTCTime #=> Left "Failed reading: satisfy"
09:58:14 <joe9> just read this  http://codepad.org/JORgscRE at http://alignedleft.com/tutorials/d3/chaining-methods . That got me wondering if a program written in haskell can compile to javascript?
09:58:54 <NemesisD> joe9: there's a few haskell-to-js compilers
09:59:03 <NemesisD> emscripten, haste, ghcjs
09:59:16 <joe9> a haskell or idris script that can be translated to javascript.
09:59:19 <shachaf> cedricshock: For regular data types and newtypes, yes.
09:59:25 <joe9> NemesisD: thanks.
09:59:41 <NemesisD> there's also purescript which is a haskell-like language
09:59:45 <shachaf> No for type families (but yes for data families, which is why they exist).
10:00:00 <cedricshock> shachaf: thanks, that was my intuition.
10:00:16 <joe9> NemesisD: thanks.
10:00:43 <shachaf> (And of course it's not true for type synonyms either.)
10:02:21 <NemesisD> does anyoe have a copy of aeson laying around. i'm really hoping i'm missing something here
10:03:12 <cedricshock> Is kind application injective? Does `f :: kf, g :: kg, a :: ka, b :: kb, f a :: k, g b :: k` imply that `g :: kf, f :: kg, a ::kb, b :: ka`?
10:03:32 <eacameron> NemesisD: why are you encoding a UTCTime into a UTCTime?
10:03:53 <eacameron> NemesisD: nvm
10:04:03 <eacameron> NemesisD: I see what's going on now
10:04:13 <joe9> NemesisD: same error:   http://codepad.org/mM9dn0eK
10:04:31 <NemesisD> wtf
10:07:27 <glguy> NemesisD: JSON doesn't allow you to decode a string directoy
10:07:31 <glguy> directly
10:07:46 <NemesisD> ohhhhh
10:07:54 <NemesisD> of course, it needs to be an object or array
10:08:04 <glguy> src/Idris/AbsSyntax.hs
10:08:08 <glguy> Prelude Data.Aeson Data.Time> eitherDecode (encode [t]) :: Either String [UTCTime]
10:08:09 <glguy> Right [2015-01-16 18:04:25.622 UTC]
10:08:19 <glguy> It's totally arbitrary
10:08:31 <NemesisD> of course! i always forget that
10:08:40 <NemesisD> thank you
10:10:48 <EvanR-work> hehe, just proved that there exists no counterexamples to the law of excluded middle
10:10:58 <EvanR-work> guess thats obvious
10:11:47 * hackagebot sloane 2.0.5 - A command line interface to Sloane's On-Line Encyclopedia  of Integer Sequences  http://hackage.haskell.org/package/sloane-2.0.5 (AndersClaesson)
10:25:27 <ReinH> EvanR-work: Well, it's obvious sometimes.
10:26:47 <ReinH> It's not obvious in systems where it isn't an a priori ;)
10:37:36 <jonazzzzzzzz> hi, if i'm in the list applicative and i do pure [], i get [[]], right?
10:37:59 <Iceland_jack> Yes
10:38:00 <Iceland_jack> > pure [] :: [[a]]
10:38:01 <lambdabot>  [[]]
10:38:16 <jonazzzzzzzz> then why can't i do [] [] in REPL to get [[]]
10:38:29 <Iceland_jack> Because [] is not a function
10:38:55 <jonazzzzzzzz> oh right :p
10:39:00 <Iceland_jack>     pure :: a   ->  [a]
10:39:00 <Iceland_jack>     pure :: [b] -> [[b]]
10:39:11 <jonazzzzzzzz> and the fact that pure x = [x]
10:39:15 <Iceland_jack> Eugh, they don't align
10:39:16 <jonazzzzzzzz> in list applicative
10:39:21 <Iceland_jack>     pure ::  a  ->  [a]
10:39:21 <Iceland_jack>     pure :: [b] -> [[b]]
10:39:22 <jonazzzzzzzz> i always think its [] x
10:39:22 <Iceland_jack> Yes
10:39:34 <jonazzzzzzzz> aight thanks :D
10:39:49 <Iceland_jack> jonazzzzzzzz: That is the case for the type of lists
10:40:13 <Iceland_jack> Where '[] a' is '[a]'
10:40:31 <Iceland_jack> :t [1,2,3] :: [] Int
10:40:32 <lambdabot> [Int]
10:40:44 <ReinH> The fact that [] is both a type constructor and a data constructor is a pretty frequent source of confusion.
10:41:00 <jonazzzzzzzz> yeah, but i can't do List 1?
10:41:03 <Iceland_jack> Yes, some languages just call it List to avoid the confusion
10:41:08 <jonazzzzzzzz> to get [1]
10:41:25 <Iceland_jack> You can make a function "list x = [x]" if you want
10:42:00 <jonazzzzzzzz> hmm ok :D
10:42:01 <Iceland_jack> or "singleton x = [x]", I'm not sure why you ask about "List 1"
10:42:04 <ReinH> And, well, it isn't even a data constructor. It's syntax.
10:42:19 <jonazzzzzzzz> because ReinH said it's a data constructor :D
10:42:44 <ReinH> jonazzzzzzzz: I didn't say that List is a data constructor.
10:42:58 <ReinH> I said [] is a data constructor and then I corrected myself.
10:42:59 <jonazzzzzzzz> oh sorry misread :D
10:43:07 <jonazzzzzzzz> but i thought [] is a list?
10:43:38 <ReinH> At the value level, list literals are syntax.
10:43:43 <ReinH> At the type level, [] is a type constructor.
10:44:01 <ReinH> List literal syntax spec: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-340003.7
10:44:18 <ReinH> The list *constructors* are : and []
10:44:44 <benzrf> [] is a data constructor
10:44:48 <ReinH> Where [], ofc, constructs the empty list
10:44:51 <benzrf> its also syntax a type constructor
10:45:13 <ReinH> [] is a data constructor. [e_1, ..., e_k] is syntax.
10:45:31 <ReinH> It's all rather confusing but you get used to it once you use it a bit.
10:49:21 <jonazzzzzzzz> ok thanks
10:55:45 <zipper> How to define a type synonym but give it a minbound and maxbound?
10:56:06 <zipper> e.g type Ascii = Int -- 0 to 255
10:56:40 <clrnd> zipper, there is no such thing afaik
10:56:41 <tremon> ASCII has values 0..127 only
10:56:42 <fizruk> zipper: use quotient types
10:56:59 <clrnd> quotient types?
10:57:09 <zipper> tremon: Really? 8 bits and all?
10:57:14 <Denommus> meh, I can't install blaze-react :-/
10:57:28 <zipper> clrnd: I don't know about quotient types.
10:57:39 <Iceland_jack> fizruk: This is #haskell
10:57:56 <zipper> clrnd: Let me google that.
10:58:08 <fizruk> zipper: ignore that, use smart constructors
10:58:10 <Iceland_jack> zipper: You can't express that in Haskell
10:58:47 <zipper> Iceland_jack: Oh
10:58:55 <zipper> fizruk: Smart constructors?
10:59:12 <fizruk> -XQuotientTypes would be kinda cool though
10:59:14 <tremon> zipper: the upper character range isn't defined for ascii. It's an extended page, used by many encodings but is undefined for plain ascii
10:59:57 <hiptobecubic> zipper, the joelonsoftware blog post about unicode explains it pretty well
11:00:14 <EvanR-work> zipper: i think we covered this yesterday, ascii characters are defined for 0 through 127 only
11:00:15 <RustyShackleford> what is wrong with this:
11:00:17 <RustyShackleford> instance Show Card where show (Card rank suit) = show rank ++ show suit
11:00:18 <fizruk> zipper: i.e. define newtype Ascii = Ascii Int, hide the internals from users and allow them only to use a function `ascii` to construct Ascii values
11:00:48 <zipper> EvanR-work: You were focused on teaching me how to ask questions instead :)
11:00:57 <EvanR-work> theres a package called text-latin1 which has a bunch of code for using the type system to deal with ascii-only data
11:01:06 <fizruk> zipper: `ascii` would check boundaries and since it is the only way to build an Ascii value, you can be sure values are in 0..127 range
11:01:07 <Iceland_jack> zipper: Do you only want values in the range 0-255?
11:01:11 <EvanR-work> latin1 being a super set of ascii
11:01:34 <zipper> Iceland_jack: Now I learn it's 0 - 127
11:01:37 <Iceland_jack> zipper: I have a feeling you're confusing ASCII with a byte
11:02:02 <hiptobecubic> zipper, did you actually want Word8?
11:02:09 <zipper> Ascii is 8 bits I don't see why it doesn't go to 155
11:02:12 <zipper> *255
11:02:19 <Iceland_jack> zipper: ASCII is not 8 bits
11:02:20 <hiptobecubic> Ascii is not 8 bits.
11:02:26 <EvanR-work> ascii is a character set, not a numeric data type
11:02:26 <zipper> hiptobecubic: I might lol
11:02:37 <Iceland_jack> zipper: But you're using this for cryptography if I recall correctly?
11:02:38 <zipper> hiptobecubic: 8 bit ascii isn't ascii?
11:02:45 <xplat> also ascii was defined as 7 bits
11:02:50 <zipper> Iceland_jack: Yes
11:03:03 <EvanR-work> there are many extended ascii standards which use the top half of the range in different ways
11:03:08 <EvanR-work> like latin1
11:03:11 <hiptobecubic> zipper, "8 bit ascii" is not ascii. no. "8 bit ascii" is a bad name people made up because ascii is usually represented as a stream of 8-bit bytes
11:03:14 <ReinH> There are some helper functions in https://hackage.haskell.org/package/text-latin1-0.1/docs/Text-Ascii.html
11:03:14 <xplat> or latin2
11:03:14 <Iceland_jack> zipper: Then I would guess that you're not looking for ASCII, you want unsigned bytes/chars
11:03:39 * EvanR-work sees latin2 and raises latin3
11:04:27 <zipper> Iceland_jack: AFAIK I want ASCII that is made up of 8 bits if ASCII is 8 bits I'll use it.
11:04:33 <zipper> I just want an easy way to xor
11:04:46 <EvanR-work> Word8 can be xored, and chars cant
11:04:49 <Iceland_jack> zipper: You definitely want Word8 (0-255) from Data.Word
11:05:04 <zipper> EvanR-work: Sweet
11:05:07 <zipper> Iceland_jack: Thanks
11:05:10 <Iceland_jack> ASCII is a character encoding, not a data type
11:05:34 <zipper> and Word8 is a data type that represents this charachter encoding.
11:05:47 <EvanR-work> Word7 would also ;)
11:06:02 <ReinH> zipper: Look at those helper functions I linked. They will help in converting from, e.g., Char -> Maybe Word8 based on whether the Char is valid ASCII
11:06:27 <Iceland_jack> zipper: There are extensions to ASCII that are 8-bit, ASCII is 7-bit
11:06:37 * chrisdone is tempted to order his type-variables so that they spell s a d
11:06:47 * hackagebot linearscan 0.1.0.0 - Linear scan register allocator, formally verified in Coq  http://hackage.haskell.org/package/linearscan-0.1.0.0 (JohnWiegley)
11:07:01 * chrisdone sticks with s d a
11:07:20 <geekosaur> chrisdone, just remember what happend to edwardk when he gave in to that temptation...
11:07:40 <zipper> ReinH: Looking at maybeASCII which has that type.
11:07:45 <zipper> Thanks everyone.
11:07:49 <ReinH> zipper: yep
11:07:50 <Iceland_jack> If zipper is working on cryptography they almost certainly don't want Char ‚Üí Maybe Word8 but rather ByteString (avoiding String altogether)
11:07:54 <zipper> I probably will use word8
11:08:25 <ReinH> Iceland_jack: True, although this is an actual use case for BS.Char8 as well ;)
11:08:29 <RustyShackleford> so I have: data Card = Card Rank Suit
11:08:32 <RustyShackleford> instance Show Card where show (Card rank suit) = show rank ++ show suit
11:08:40 <EvanR-work> Char8 is funny
11:08:46 <RustyShackleford> what is wrong with that instance declaration?
11:08:55 <EvanR-work> its mixing several assumptions together
11:09:07 <zipper> Iceland_jack: Well I will recieve some values in hex and will be giving some of the output e.g the Ciphertext in hex.
11:09:09 <EvanR-work> making it all taste good ;)
11:09:31 <ReinH> RustyShackleford: What happens when you try to use it?
11:09:32 <geekosaur> RustyShackleford, without more information and preferably a full error message, we can only guess
11:09:46 <EvanR-work> when you say you are getting values in hex, most people would assume you mean text like "3f02e6"
11:09:48 <RustyShackleford> ReinH: compile error
11:09:50 <chrisdone> the only thing i see wrong with that instance is that someone is defining one manually =p
11:09:52 <EvanR-work> rather than a binary string of bytes
11:09:54 <RustyShackleford> hold on, i'll paste it
11:10:07 <RustyShackleford>  No instance for (Show (Rank -> Suit -> Card))
11:10:08 <tremon> RustyShackleford: Rank and Suit aren't instances of Show?
11:10:09 <RustyShackleford>       arising from a use of `show'
11:10:10 * glguy votes for missing show instance on Raank/Suit...
11:10:11 <fizruk> @where paste
11:10:11 <lambdabot> Haskell pastebin: http://lpaste.net/
11:10:23 <SrPx> Hello, I'm trying to create a CSSRule from this library : https://hackage.haskell.org/package/ghcjs-dom-0.1.1.3/docs/GHCJS-DOM-CSSRule.html - but GHCJS says that the constructor CSSRule isn't on scope. Which is weird, I even checked the code and it is there. I imported "GHCJS.DOM.CSSRule". Am I missing something?
11:10:32 <ReinH> RustyShackleford: It's more helpful to describe the error rather than just telling us you got *an* error.
11:10:52 <RustyShackleford> tremon: they are instances of show
11:10:57 <xplat> EvanR-work: Char8 is an illiberal type, it others people who don't confine their spelling to latin1
11:10:57 <glguy> RustyShackleford: You should paste the whole code and the error to the pastebin
11:11:06 <RustyShackleford> okay. hold on
11:11:12 <ReinH> RustyShackleford: That code doesn't look like it would give that error.
11:11:12 <chrisdone> @paste -- checking something
11:11:13 <lambdabot> Haskell pastebin: http://lpaste.net/
11:11:14 <chrisdone> hmm
11:11:24 * geekosaur regularly
11:11:26 <EvanR-work> xplat: it whats people?
11:11:27 <geekosaur> @paste your code
11:11:27 <lambdabot> Haskell pastebin: http://lpaste.net/
11:11:27 <chrisdone> the url should be http://lpaste.net/haskell -- so it'll announce
11:11:36 <chrisdone> or what's it
11:11:43 <chrisdone> http://lpaste.net/new/haskell
11:11:47 <chrisdone> ^ that one. can someone change it?
11:12:07 <geekosaur> would have to be whoever runs the bot since it's a constant string
11:12:19 <RustyShackleford> http://pastebin.com/P9Vm6Ptc
11:12:26 <xplat> EvanR-work: not whats.  second whats people.  Char8 others.
11:12:28 * geekosaur while he ran an LB always had an itch to convert that to use @where
11:12:38 <geekosaur> instead of all the hardcoded string constants
11:12:49 <chrisdone> yeah, an alias for @where of 'paste' would be ticketyboo
11:12:49 <RustyShackleford> ReinH: see my like above
11:12:55 <ReinH> RustyShackleford: your error is at the line `show Card`.
11:13:00 <EvanR-work> xplat: sorry im trying to comprehend your grammar. it others people?
11:13:01 <ReinH> Not with the code you pasted originally.
11:13:16 <geekosaur> line 34
11:13:17 <ReinH> RustyShackleford: The compiler error tells you the line number, which you should check.
11:13:19 <geekosaur> not related to yoyr instance
11:13:34 <geekosaur> you are trying to show a data constructor, which is a function
11:13:35 <ReinH> Card is a function, not a value of type Card
11:13:42 <geekosaur> did you mean show c instead of show Card?
11:14:21 <RustyShackleford> oh crap i see
11:14:35 <xplat> EvanR-work: yes.  treats them as unimportant, abnormal, deviant, not part of the group.
11:14:36 <RustyShackleford> i'm a moron...
11:14:54 <ReinH> RustyShackleford: I doubt it. But you'd make things easier on yourself if you checked the error message more thoroughly. :)
11:14:56 <RustyShackleford> yeah it works
11:15:09 <EvanR-work> xplat: i see. yes
11:15:18 <RustyShackleford> i simply typed the wrong thing, and expected the compiler to know what I meant
11:15:33 <RustyShackleford> ReinH: is there anything in that code that you think is particularly dumb?
11:16:47 <ReinH> RustyShackleford: No, seems reasonable.
11:17:12 <RustyShackleford> thanks, I appreciate the help. I should have been able to figure that out myself :P
11:17:25 <ReinH> RustyShackleford: Probably, but no worries.
11:19:02 <chrisdone> RustyShackleford: have you ever seen Venture Bros.?
11:21:48 * hackagebot crypto-pubkey 0.2.8 - Public Key cryptography  http://hackage.haskell.org/package/crypto-pubkey-0.2.8 (VincentHanquez)
11:26:48 * hackagebot tls 1.2.14 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.2.14 (VincentHanquez)
11:33:07 <dhinojosa> Is there somewhere in the API that can return the kind the same way it works in the ghci?
11:33:38 <chrisdone> typeKind from InteractiveEval
11:36:22 <chrisdone> i like converting monadic code to pure code
11:36:31 <johnw> chrisdone++
11:36:32 <johnw> me too
11:36:41 <chrisdone> did you guys see conor mcbride's Frank?
11:37:00 <bsmt> the movie?
11:37:02 <chrisdone> pretty interesting stuff. that's like "everything's a monad"
11:37:22 <chrisdone> except s/monad/something more general
11:38:07 <zipper> You guys said one can xor word8? Turns out I can't.
11:38:18 <chrisdone>  let x = e in e‚Ä≤ as syntactic sugar for bind e {x ‚Ü¶ e‚Ä≤}
11:38:20 <chrisdone> ^ in frank
11:38:38 <Iceland_jack> zipper:
11:38:38 <Iceland_jack> > xor 5 1 :: Word8
11:38:39 <lambdabot>  4
11:38:41 <zipper>  No instance for (Bits [GHC.Word.Word8]) arising from a use of ‚Äòxor‚Äô
11:38:41 <chrisdone> it's literally like having the whole language be a free monad and then you have interpreters
11:38:57 <Iceland_jack> You're trying to xor a *list* of Word8
11:38:58 <ReinH> chrisdone: Huh.
11:39:14 <chrisdone> or everything be in implicit idiom brackets
11:39:18 <zipper> Iceland_jack: OMG I am SMH
11:39:21 <Iceland_jack> zipper:
11:39:21 <Iceland_jack> > zipWith xor [1,2,3] [20,4,3] :: [Word8]
11:39:22 <lambdabot>  [21,6,0]
11:39:37 <Iceland_jack> that's how you xor a list of Word8's elementwise
11:39:46 <zipper> Iceland_jack: liftA2 makes me feel smarter than zipWith
11:39:47 <chrisdone> ReinH: it seems pretty awesome, i'mma try it sometime http://homepages.inf.ed.ac.uk/slindley/papers/frankly-draft-march2014.pdf
11:39:51 <zipper> Iceland_jack: :)
11:40:11 <Iceland_jack> zipper: It's not the same function for [Word8]
11:40:19 <Iceland_jack> You'd have to use 'ZipList Word8'
11:40:46 <Iceland_jack> > getZipList (liftA2 xor (ZipList [1,2,3]) (ZipList [20,4,3])) :: [Word8]
11:40:47 <lambdabot>  [21,6,0]
11:41:39 <Iceland_jack> You can also use an extension called ParallelListComp but I'd use "zipWith":
11:41:39 <Iceland_jack> > [ xor x y | x <- [1,2,3] | y <- [20,4,3] ] :: [Word8]
11:41:40 <lambdabot>  [21,6,0]
11:41:51 <zipper> Iceland_jack: Yeah liftA2 is exposing it's non determinism
11:42:14 <zipper> Like when given a list of two elements to xor the result is 3 elements
11:42:26 <Iceland_jack> Not quite
11:42:49 <dhinojosa> thanks chrisdone
11:42:55 <zipper> Iceland_jack: I mean 4 elements
11:43:00 <Iceland_jack> Right
11:43:22 <zipper> Iceland_jack: :) Thanks man. You really from Iceland?
11:43:42 <Iceland_jack> No problem and yes I am
11:44:14 <chrisdone> the only Jack in Iceland
11:44:20 <chrisdone> the last of his kind
11:44:22 <Kenyan_zipper> lulz
11:44:27 <Iceland_jack> My name isn't actually Jack :)
11:44:40 <hiptobecubic> I don't think zipper's name is actually "Zipper"
11:44:40 <fizruk> wow
11:44:46 <hiptobecubic> could be wrong though
11:44:55 <Kenyan_zipper> hiptobecubic: lol it might be.
11:44:57 <hiptobecubic> Some people have some pretty sweet names
11:45:00 <ReinH> Iceland_jack: very clever of you all to name the warmer, greener one "Iceland" and the colder, icier one "Greenland", btw.
11:45:07 <johnw> Iceland_jack: did you write the book on Scala and functional programming?
11:45:11 <monochrom> when has Iceland become a kind? :)
11:45:20 <chrisdone> ReinH: high calibre geographical trolling
11:45:27 <hiptobecubic> Iceland :: * -> *
11:45:36 <ReinH> chrisdone: top kek
11:45:40 <Kenyan_zipper> Which encoding is used by Char?
11:45:45 <Kenyan_zipper> I shall assume UTF8
11:45:47 <johnw> Kenyan_zipper: Char isn't encoded
11:45:52 <Kenyan_zipper> going by my configs
11:45:55 <Iceland_jack> ReinH: The name is pretty accurate at the moment :)
11:45:57 <hiptobecubic> aren't they unicode codepoints or something?
11:45:59 <johnw> yes
11:46:07 <johnw> internally they might be UCS4 or something
11:46:08 <Iceland_jack> and no johnw I didn't
11:46:20 <Kenyan_zipper> johnw: Isn't utf8 encoding?
11:46:23 <monochrom> it's like saying "which encoding is used by Int"
11:46:24 <Iceland_jack> That was R√∫nar
11:46:29 <johnw> yeah
11:46:41 <Kenyan_zipper> Ok so how to convert a String of hex values to a string of utf8 values
11:46:55 <johnw> Kenyan_zipper: utf8 is, but a Char is the thing the utf8 encoding would represent
11:46:56 <Kenyan_zipper> Like without mapping readHex
11:47:00 <hiptobecubic> Kenyan_zipper, it sounds like you need to read about text encodings.
11:47:11 <Kenyan_zipper> hiptobecubic: I know :(
11:47:29 <hiptobecubic> Kenyan_zipper, have you this? http://www.joelonsoftware.com/articles/Unicode.html
11:47:30 <chrisdone> but first he needs to know about encodings to pick an encoding in which to read about encodings
11:47:31 <johnw> heh
11:47:34 <Kenyan_zipper> hiptobecubic: I need to start learning about charachter encoding from the bottom.
11:47:35 <chrisdone> it's a chicken and egg problem
11:47:43 <johnw> easy, use the chicken-and-egg encoding
11:47:47 <johnw> chicken for 0, egg for 1
11:47:50 <chrisdone> done!
11:48:04 <johnw> no, really 0 should be egg
11:48:05 <chrisdone> or is it 0 for egg, 1 for chicken?
11:48:06 <johnw> obviously
11:48:09 <chrisdone> oh lawdy
11:48:16 <johnw> 1 even has the beak in my font
11:48:24 <johnw> what was I thinking!
11:48:36 <chrisdone> back to square 0¬±1
11:48:46 <johnw> haha
11:48:59 <Kenyan_zipper> Wait so the question was converting a string of hex values to ascii utf8 values. I hope my question is clear.
11:49:32 <johnw> you mean, a string that's literally something like "0xfabe"
11:49:41 <Kenyan_zipper> and why is the cipher text and keys always hex if I will have to convert them to another encoding to xor them
11:49:45 <johnw> where those hex bytes represent a utf8 encoded string?
11:49:57 <Kenyan_zipper> johnw: Let me try that.
11:49:58 <Iceland_jack> Kenyan_zipper: Normally you wouldn't actually deal with hex encoded values
11:49:58 <johnw> i must ask, what would you need something like that for
11:50:23 <monochrom> what does "convert a String of hex values to a string of utf8 values" mean? I am serious, I seriously don't understand it. are there examples?
11:51:00 <johnw> I'm wondering if what he really has is a ByteString, and he just wants to decode it
11:51:05 <johnw> that would make sense, and almost fit his description
11:51:10 <Kenyan_zipper> johnw: Trying to convert hex values to word8 so that I can xor them
11:51:16 <chrisdone> ah
11:51:37 <johnw> if that's the code, you shouldn't need to deal with encodings at all
11:51:44 <johnw> just turn the hex into bytes and xor them
11:51:44 <chrisdone> to Word8 makes more sense. converting to ascii utf8 values makes less sense
11:51:47 <johnw> s/code/case
11:51:48 * hackagebot tls 1.2.15 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.2.15 (VincentHanquez)
11:51:59 <Iceland_jack> monochrom: They probably want to turn something like "6161" into BS.pack [97,98]
11:53:15 <Kenyan_zipper> Iceland_jack: Something like "6161" to [97, 97]
11:53:15 <chrisdone> i've been here for 8 years and haven't once asked if Iceland_jack is really from iceland
11:53:17 <glguy> https://hackage.haskell.org/package/base16-bytestring-0.1.1.6/docs/Data-ByteString-Base16.html
11:53:38 <chrisdone> it's like when someone comes to your house and points out a compartment in the cupboard that you never noticed
11:54:30 <chrisdone> glguy: is your nick glguy because you really like opengl?
11:54:38 <johnw> or hearing the phrase "every cloud has a silver lining" and not realizing what it means for more than 30 years
11:54:39 * chrisdone might as well ask those questions he always wanted to ask
11:54:54 <glguy> Nope, but I should have thought about that before I started using it ^_^
11:54:59 <chrisdone> heh
11:55:03 <hiptobecubic> johnw, I probably still don't know what it means.
11:55:17 <Kenyan_zipper> johnw: Turn the hex into bytes and xor them?
11:55:35 <johnw> when the sun is shining behind a cloud, it looks like it has a lining of silver around the edge;  so it means that every dark day has a good day behind it
11:55:53 <hiptobecubic> johnw, oh really?
11:55:57 <Denommus> ok, anything like React for GHCJS that actually works? blaze-react seems to have broken dependencies
11:55:57 <hiptobecubic> interesting
11:55:57 <chrisdone> nice =)
11:56:10 <hiptobecubic> Kenyan_zipper, what is the "hex" in this case? What is the datatype of the thing you're calling hex? Char?
11:56:25 <Kenyan_zipper> hiptobecubic: String
11:56:25 <chrisdone> Denommus: we have a WIP at fpco, but it's not ready for prime time
11:56:28 <johnw> for my whole life, I thought metallic silver was involved in away I could not figure out
11:56:39 <luite> Denommus: what's broken about them?
11:56:49 <Iceland_jack> chrisdone: Yes I'm like that compartment :)
11:56:53 <hiptobecubic> Kenyan_zipper, ok so you have a string of characters that look like hex and you want to get bytes out of it
11:57:04 <monochrom> a dark cloud usually has a bright border (if the border is within visual range) during day time. this is used to analogize that a bad thing likely has a bit of benefit.
11:57:20 <monochrom> next question you will ask: is "analogize" a real word? :)
11:57:26 <Iceland_jack> In Python it would be:
11:57:26 <Iceland_jack> >>> '6162'.decode('hex')
11:57:27 <Iceland_jack> 'ab'
11:57:48 <chrisdone> johnw: haha. i always vaguely thought it was related to some old silky fabric quality that made sense as a reference back in ye olde dayes
11:57:59 <hiptobecubic> interesting
11:58:17 <luite> Denommus: i probably bumped some deps in ghcjs-boot since the people at Better did the talk on it, and i'm not sure if they're actively maintaining it (or at least a public version)
11:58:41 <Kenyan_zipper> hiptobecubic: Wait. I haven't figured everything out it seems.
12:00:33 <knyon> Just a quick survey: Sometimes I'm in a do expression, and I'm not quite sure the type of a pattern given by expression (i.e. the type of pat in `pat <- exp`). I commonly give a type annotation to pat with a type it is clearly not, e.g. `(pat :: Int) <- exp`
12:00:51 <knyon> and then check the compiler error
12:00:54 <johnw> I use (), but yeah, that's a good technique
12:00:56 <knyon> is there a fancier way to do that?
12:01:05 <johnw> you could use typed holes
12:01:16 <knyon> Yeah, I use holes, but you can't use them in a pattern
12:01:17 <johnw> oh, hmm, _ has a different meaning here
12:01:20 <knyon> exactly
12:01:36 <ReptiLe> ..
12:01:45 <ReptiLe> ...
12:01:48 * hackagebot apiary-purescript 1.2.2 - purescript compiler for apiary web framework.  http://hackage.haskell.org/package/apiary-purescript-1.2.2 (HirotomoMoriwaki)
12:01:49 <Aytac> hi
12:01:52 <ReptiLe> hu
12:01:59 <Aytac> :D
12:02:03 <knyon> johnw: () is a good suggestion, thanks
12:02:04 <ReptiLe> t¸rk varm˝
12:02:14 <ReptiLe> knyon bald˝z˝˝n sikerim
12:02:21 <ReptiLe> para vermiyecem ama
12:02:29 <ReptiLe> tamam Kneiva :D
12:02:37 <ReptiLe> Aytac k¸f¸r serbes
12:02:39 <Aytac> :D
12:02:39 <ReptiLe> t¸rkÁe k¸f¸rler
12:02:45 <Aytac> ´´´ ô  Aytac ScripT  ô ªª ª [ 22:00 ] ª
12:02:46 <ReptiLe> go bunlar˝n bald˝zlar˝na
12:02:47 <ReptiLe> :D
12:02:47 <monochrom> can I ban now?
12:02:48 <lpaste> glguy pasted ‚Äúxoring hex encoded bytestrings‚Äù at http://lpaste.net/118591
12:02:58 <glguy> zipper: That?
12:03:03 <ReptiLe> yes amks olu
12:03:04 <ReptiLe> hee hu
12:03:07 <ReinH> knyon: If you want to check, you can expr >>= _whatisthis
12:03:13 --- mode: ChanServ set +o monochrom
12:03:18 <geekosaur> go for it
12:03:18 <zipper> glguy: WHat?
12:03:20 --- mode: monochrom set +b *!*@88.246.8.160
12:03:20 --- kick: ReptiLe was kicked by monochrom (ReptiLe)
12:03:23 <ReinH> Or just look at the type error generated by () <- expr, yeah
12:03:40 <knyon> () is cute, I like that
12:03:54 --- mode: monochrom set +b *!*@85.106.77.169
12:03:54 --- kick: Aytac was kicked by monochrom (Aytac)
12:04:03 --- mode: monochrom set -o monochrom
12:04:09 <johnw> monochrom: I also have a /kickbanip macro, for these cases
12:04:39 <knyon> usually I write my expression where I can reason able the types, but sometimes it's a nice sanity check
12:04:45 <Taneb> If I have a repa array of, say, Word64s, and I want to see which bit is set in the greatest number of the, what can I do?
12:05:20 <chrisdone> Unexpected end of sentence at "of the" on line 1, column 113
12:05:54 <chrisdone> (possibly incorrect indentation or mismatched brackets)
12:06:45 <ReinH> chrisdone: did... did you actually check the column?
12:06:53 <chrisdone> >_>
12:07:00 <jfischoff> I‚Äôm trying understand the nature of ‚Äúcannot find normal object file `.. Blah.dyn_o‚Äô‚Äù errors
12:07:17 <duygusalgenc7794> 7b3v177 monochrom g ˆ t¸n¸ si kerim p i cc jt9967
12:07:17 <yAkAmOz_341912> 7b3v177 monochrom g ˆ t¸n¸ si kerim p i cc jt9967
12:07:17 <BenAffleck7001> 7b3v177 monochrom g ˆ t¸n¸ si kerim p i cc jt9967
12:07:17 <sekerKiz1958> 7b3v177 monochrom g ˆ t¸n¸ si kerim p i cc jt9967
12:07:17 <leeveent--3248> 7b3v177 monochrom g ˆ t¸n¸ si kerim p i cc jt9967
12:07:17 <duygusalgenc7794> 0y1c288 monochrom g ˆ t¸n¸ si kerim p i cc av4505
12:07:17 <yAkAmOz_341912> 0y1c288 monochrom g ˆ t¸n¸ si kerim p i cc av4505
12:07:17 <yAkAmOz_341912> 0n4c944 monochrom g ˆ t¸n¸ si kerim p i cc hh7482
12:07:17 <yAkAmOz_341912> 1b9j368 monochrom g ˆ t¸n¸ si kerim p i cc ya5284
12:07:17 <yAkAmOz_341912> 3w4o482 monochrom g ˆ t¸n¸ si kerim p i cc sr5838
12:07:17 <yAkAmOz_341912> 1j5x615 monochrom g ˆ t¸n¸ si kerim p i cc lw5997
12:07:30 --- mode: ChanServ set +o johnw
12:07:30 --- mode: ChanServ set +o geekosaur
12:07:54 <sivteck> are we under attack?
12:07:55 * chrisdone makes Clint Eastwood eyes around the channel
12:08:09 --- mode: johnw set -o johnw
12:08:10 <knyon> Is that turkish?
12:08:16 <geekosaur> looks like it
12:08:32 <geekosaur> I considered feeding it to a translator but probably not worth it
12:09:03 <c_wraith> idoru killed it awfully fast.  That's an effective bot.
12:09:57 --- mode: geekosaur set -o geekosaur
12:16:59 <jfischoff> Alright, I‚Äôll ask my question again, anyone understand the nature cannot find normal object file `.. Blah.dyn_o‚Äô‚Äù errors?
12:17:14 <jfischoff> I see them when I try to cabal build -j8
12:17:37 <jfischoff> also when I try to build with make file generated from ghc -M
12:17:56 <chrisdone> missing -dynamic somewhere?
12:18:30 <jfischoff> maybe
12:18:41 <jfischoff> do I always need dynamic?
12:18:48 <jfischoff> do I need it for template haskell?
12:18:50 <jfischoff> for ghci?
12:19:35 <Denommus> luite: sorry, my connection is unstable
12:19:42 <chrisdone> that sounds like a familiar scenario
12:19:58 <Denommus> luite: blaze-react asks for lens and transformers-compat, but lens asks for another version of transformers-compat. I think this is what is happening
12:20:02 <chrisdone> i had trouble with ghci linking things due to a lack of -dynamic somewhere
12:20:08 * jfischoff nods
12:20:23 <jfischoff> I think I‚Äôm remembering see something on the net somewhere about it
12:20:46 <Denommus> luite: GHCJS itself is fine
12:21:44 <monochrom> -dynamic-too
12:22:08 <mlamari> What are the options, preferably with examples, for making types Foo s and Bar s and giving them some common class that refers to them commonly, along with a specific map function that lets you remap the 's'
12:22:39 <chrisdone> other than Functor?
12:22:39 <monochrom> but if you're using "cabal build", you are under a different situation
12:22:42 <glguy> Denommus: there is one version of transformers-compat per version of transformers. They need to match
12:22:45 <StoneToad> mlamari: you mean the Functor typeclass?
12:23:13 <mlamari> StoneToad: Uncertain - however I may be remapping these over different axes - was fishing for some type family stuff (I think)
12:23:26 <Denommus> glguy: yeah, but blaze-react and lens are not matching :-/
12:23:54 <StoneToad> Oh so they're actually of the form Foo s1 s2?
12:23:58 <luite> Denommus: ah i think ghcjs comes with transformers 0.4, i wonder if some package is trying to be helpful here, messing up the solver
12:24:10 <StoneToad> ther'es a typeclass for bifunctors on hackage I think
12:24:28 <Denommus> luite: I'll see
12:25:13 <Denommus> luite: wait, this just happens when trying to compile with GHC. GHCJS has other problem
12:25:15 <EvilTerran> mlamari, could you give us a concrete example?
12:25:53 <mlamari> EvilTerran: I'll go off and study functors - my question may be too ignorant at this stage.
12:26:48 * hackagebot wedged 0 - Wedged postcard generator.  http://hackage.haskell.org/package/wedged-0 (ClaudeHeilandAllen)
12:27:06 <luite> Denommus: ok let me know if i can change somethign in ghcjs-boot to improve the situation :)
12:36:47 <hodapp> does Haddock - or Cabal I guess - provide any mechanism to have some expression in the code inserted into the documentation?
12:40:09 <c_wraith> hodapp: nothing I'm aware of.
12:42:42 <mlamari> Imagine you were defining some language AST type thing where you had data Expression = | Foo | Funcall Expression Expression | etc.; but wanted Expression, at every level, to be qualified by an origin (say, a polymorphic variable as it would be transformed sometimes). Would you tend to make this a tuple/record of origin and (sum-type of the types)? or mix it in in some other manner?    data Expression o = <answer here>?
12:42:43 <hodapp> darn. I was hoping to make the docs more useful and avoid needless copying-and-pasting
12:44:27 <EvilTerran> hodapp, from the looks of https://www.haskell.org/haddock/doc/html/ch03s08.html#idm140354810780208 , it seems the only ways of embedding code are by wrapping them in @...@ or prefixing lines with "> "
12:45:48 <EvilTerran> hodapp, the latter makes me think you could write a Literate Haskell file, then generate from it a Haddock page with *all* the code from the file included
12:47:21 <hodapp> http://trac.haskell.org/haddock/ticket/140 this seems to be suggesting something similar...?
12:51:30 <hodapp> well, I guess doctest is something else, reading about it
13:02:09 <EvilTerran> mlamari, the GHC API does it (approximately) by having a "data Located a = Located YourOriginType a", then doing something analogous to "data Expr = NumConst (Located Int) | Name (Located String) | Apply (Located Expr) (Located Expr) | ..."
13:02:12 <johnw> is there a form of biplate that allow changing the type?  i.e., (("hello","world"),"!!!", 2 :: Int) & biplate %~ length  -->  ((5, 5), 3, 2)
13:02:43 <benzrf> johnw: what type would it b
13:02:46 <EvilTerran> mlamari, and then you pass around "Located Expr"s. so that's one way to do it.
13:03:13 <johnw> benzrf: I have no clue what it would be
13:03:19 <johnw> if I knew that, I could find it
13:03:27 <benzrf> johnw: i dont think thats an OK type
13:03:38 <benzrf> er, like
13:03:44 <benzrf> is there a Has multiparam class
13:03:52 <zipper> > 0x6161
13:03:54 <lambdabot>  24929
13:04:01 <zipper> 0x61
13:04:04 <benzrf> HasPolymorphic, even
13:04:12 <zipper> >0x61
13:04:21 <zipper> Why this difference?
13:04:25 <bennofs> johnw: the problem is that there is now way to know if it is even possible to change. Consider data T = T Int Int. I can apply biplate to it but there is no condition that would disallow applying your combinator to it
13:04:54 <johnw> I don't follow, bennofs
13:05:41 <bennofs> johnw: well, how could you change the type in data T = T Int Int? If you can't, what condition can separate types like T from types like (Int, Int)?
13:06:17 <johnw> bennofs: I see what you mean; I'm changing a member type which requires selection of another constructor which could be undecidable
13:06:25 <johnw> thanks!
13:06:50 <dgonyeo> I just got a "ghc: panic!" while installing the vector package on my raspberry pi, what are the chances that I just oom'd?
13:06:54 <johnw> what I have is a scenario where it is decidable
13:06:55 <dgonyeo> because this says to report the bug
13:07:13 <johnw> haha
13:07:21 <johnw> I just realized that what I want is a Functor :)
13:07:30 <bennofs> johnw: was about to say that :d
13:09:30 <hodapp> any standard way to turn a Word32 into an upper and lower Word16?
13:09:39 <hodapp> rather than using bitshifts & bitwise logic
13:10:05 <braind> amsg
13:10:28 <geekosaur> hodapp: I don't think so
13:12:43 <zipper> What exactly does 0x do?
13:12:56 <zipper> Other than say that the following is a hex value?
13:13:58 <EvanR> syntax for base 16 number literal
13:14:02 <EvanR> default is ten
13:14:20 <zipper> EvanR: There is this inconsistency issue I have.
13:14:48 <zipper> When converting say 6c73d5240a948c86981bc294814d to UTF8 chars
13:15:05 <EvanR> whats 6c73d5240a948c86981bc294814d, a string?
13:15:14 <EvanR> or byte string?
13:15:18 <zipper> When one runs 0x6c73d5240a948c86981bc294814d isn't the same as running 0x on each pair of values
13:15:27 <zipper> :t 0x6c73d5240a948c86981bc294814d
13:15:27 <lambdabot> Num a => a
13:15:46 <EvanR> we could be talking about three different things, so im just trying to understand what youre referring to
13:16:04 <Dykam> :t 5
13:16:04 <EvanR> String, ByteString, or Integer
13:16:05 <lambdabot> Num a => a
13:16:05 <zipper> EvanR: It's a string of hex values.
13:16:15 <zipper> EvanR: It's a string
13:16:37 <EvanR> right, "6c73d5240a948c86981bc294814d" and 0x6c73d5240a948c86981bc294814d denote two different things
13:16:39 <Dykam> 0x00... it a literal without quotations, "0x00..." is a string containing hexadecimal characters with a prefix
13:16:40 <zipper> A string that I shall convert to ByteString.
13:16:45 <EvilTerran> hodapp, Data.Binary would be one way of doing it, if you're converting sequences
13:17:32 <EvanR> zipper: so id be prudent to check that you understand what these objects are, somehow
13:17:35 <EvanR> itd*
13:18:01 <zipper> EvanR: It's a sequence of hex values that I want to xor with other hex values.
13:18:03 <Dykam> so you have a String object?
13:18:05 <EvanR> for example, when you convert "6c73d5240a948c86981bc294814d" to a ByteString, you might not be doing what you think youre doing
13:18:38 <EvanR> which is yet another thing from the integer 0x6c73d5240a948c86981bc294814d
13:19:26 <EvanR> confusing, but it does follow rules
13:19:29 <zipper> EvanR: It's not an integer it's a key that is to be xor-ed
13:20:01 <Iceland_jack> zipper: Yes, then you don't want numbers like you asked about
13:20:05 <zipper> EvanR: Are you being pedantic or am I being vague?
13:20:20 <zipper> Iceland_jack: I want letters.
13:20:25 <EvanR> youre confused
13:20:33 <zipper> but from the numers I can get letters.
13:20:47 <EvanR> so to get the sequence of bytes from this string "6c73d5240a948c86981bc294814d" you need to take the pairs of letters, and convert each pair into a Word8
13:20:52 <zipper> > chr$ 0x61
13:20:54 <lambdabot>  'a'
13:20:59 <zipper> See that
13:21:07 <zipper> > chr $ 0x6161
13:21:08 <lambdabot>  '\24929'
13:21:13 <EvanR> heh
13:21:31 <EvanR> > (ord 'a', ord 'a')
13:21:32 <lambdabot>  (97,97)
13:21:40 <EvanR> > 9797
13:21:41 <lambdabot>  9797
13:21:42 <zipper> EvanR: That's what I was thinking of doing. I thought there was a better way.
13:21:49 <EvanR> ^
13:22:06 <zipper> and then zip each word8 with an xor
13:22:26 <EvanR> you have to do it like that
13:22:27 <zipper> EvanR: Any way to move from hex to word8 right away without pack/unpack?
13:22:35 <zipper> EvanR: Thanks
13:23:37 <mlamari> EvilTerran: Thanks, yeah that's probably the ticket
13:24:07 <EvanR> > (ord 'e', ord '1')
13:24:08 <lambdabot>  (101,49)
13:24:12 <EvanR> > 0xe1
13:24:13 <lambdabot>  225
13:25:41 <zipper> > 0x('6':'1':[])
13:25:43 <lambdabot>  No instance for (GHC.Show.Show a0)
13:25:43 <lambdabot>    arising from a use of ‚ÄòM48345229601652211085293.show_M48345229601652211085...
13:25:43 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
13:26:10 <zipper> EvanR: Trying to pull two values from a stream of hex values and appending them to 0x
13:26:12 <EvanR> 0x1234 is syntax for numbers, '6':'1':[] is syntax to build a list of chars
13:26:22 <zipper> EvanR: I see that
13:26:46 <Cale> :t readHex
13:26:47 <lambdabot> (Num a, Eq a) => ReadS a
13:26:51 <zipper> :t snd
13:26:52 <lambdabot> (a, b) -> b
13:27:01 <Cale> :t showHex
13:27:02 <lambdabot> (Show a, Integral a) => a -> ShowS
13:27:04 <zipper> :t readHex
13:27:05 <lambdabot> (Num a, Eq a) => ReadS a
13:27:19 <EvanR> > readHex "e1" ""
13:27:20 <lambdabot>  Couldn't match expected type ‚Äò[GHC.Types.Char] -> t‚Äô
13:27:20 <lambdabot>              with actual type ‚Äò[(a0, GHC.Base.String)]‚Äô
13:27:23 <Iceland_jack> Cale: readHex reads it as a number
13:27:31 <Cale> yes
13:27:45 <Iceland_jack> > readHex "0102" :: [(Int, String)]
13:27:47 <lambdabot>  [(258,"")]
13:27:51 <zipper> > readHex "61"
13:27:53 <lambdabot>  [(97,"")]
13:28:09 <Cale> > readHex "e1xyz"
13:28:10 <lambdabot>  [(225,"xyz")]
13:28:12 <Iceland_jack> zipper: The solution was given earlier by glguy
13:28:15 <Iceland_jack> <lpaste> glguy pasted ‚Äúxoring hex encoded bytestrings‚Äù at http://lpaste.net/118591
13:30:49 <Dykam> readHex "afxaf"
13:30:52 <Dykam> ...
13:30:54 <Dykam> > readHex "afxaf"
13:30:55 <lambdabot>  [(175,"xaf")]
13:40:36 <knyon> Is there a way to find out which library brought in which hidden library as a dependency using cabal?
13:41:24 <bennofs> knyon: cabal -v2 will give you that information iirc
13:41:32 <hodapp> hmm, it does look like Data.Binary is what I need, but I am trying to find a sane way of accomplishing it with Data.Binary.Get and .Put... it looks like I can somehow combine these two monads to let me trivially edit a stream of bits, but I don't know
13:42:06 <knyon> bennofs: what subcommand? info, install, ...?
13:42:29 <dgomez> anyone heard of the halberd package?
13:42:29 <EvilTerran> hodapp, [Word32] -> ByteString is easy: "runPut . mapM_ putWord32be"; ByteString -> [Word16] would be a little more complicated, because you need to be careful to not read past the end of the ByteString
13:42:30 <hodapp> I can see easily how to extract the data out of the given binary type and edit it, and I can see easily how to use a Put to generate a bytestring I may convert back... but not how to combine them sanely
13:42:59 <hodapp> basically, I have a UUID, and I just need to return another UUID with two bytes changes
13:43:10 <dgomez> I've updated to cabal 1.22 ran my program and the imports statements that used to work now don't work. The error being:
13:43:21 <bennofs> knyon: well, I thought that you wanted to know which library brought in a dependency (so you're probably using install?). then just use cabal install -v2
13:43:29 <knyon> ahh, not quite
13:43:32 <dgomez> DiagramsTutorial.hs:10:8:
13:43:32 <dgomez>     Could not find module ëDiagrams.Preludeí
13:43:32 <dgomez>     Locations searched:
13:43:32 <dgomez>       Diagrams/Prelude.hs
13:43:32 <dgomez>       Diagrams/Prelude.lhs
13:43:33 <dgomez> DiagramsTutorial.hs:10:8:
13:43:35 <dgomez>     Could not find module ëDiagrams.Preludeí
13:43:37 <dgomez>     Locations searched:
13:43:39 <dgomez>       Diagrams/Prelude.hs
13:43:41 <dgomez>       Diagrams/Prelude.lhs
13:43:44 <dgomez> DiagramsTutorial.hs:10:8:
13:43:46 <dgomez>     Could not find module ëDiagrams.Preludeí
13:43:48 <dgomez>     Locations searched:
13:43:50 <dgomez>       Diagrams/Prelude.hs
13:43:52 <dgomez>       Diagrams/Prelude.lhs
13:43:54 <dgomez> Could not find module ëDiagrams.Preludeí
13:43:56 <dgomez>     Locations searched:
13:43:58 <dgomez>       Diagrams/Prelude.hs
13:44:00 <dgomez>       Diagrams/Prelude.lhs
13:44:00 <monochrom> perhaps row back to older cabal-install
13:44:02 --- mode: ChanServ set +o glguy
13:44:02 <dgomez> Sorry for that...
13:44:17 <dgomez> monochrom: i can't do that
13:44:20 <knyon> I know some already installed library brought in 'network-uri', but I can't figure out which :\
13:44:57 <hodapp> and I don't suppose I can just stuck 'putWord16be' etc. inside of a Get monad...
13:45:03 <knyon> I'd love a generated dependency graph
13:45:20 <monochrom> ghc-pkg dots
13:45:32 <monochrom> err, ghc-pkg dot
13:45:49 <EvanR> hodapp: you can update individual bytes of a bytestring directly
13:45:50 <Clint> hodapp: you can do a runPut inside
13:46:31 <monochrom> the output format of "ghc-pkg dot" is of graphviz's
13:46:47 <knyon> monochrom: thanks! That's wonderful
13:46:48 * hackagebot unagi-chan 0.3.0.2 - Fast concurrent queues with a Chan-like API, and more  http://hackage.haskell.org/package/unagi-chan-0.3.0.2 (BrandonSimmons)
13:47:01 <EvilTerran> hodapp, afraid not, you'd need something like (unpackW16s :: ByteString -> [Word16]) . (packW32s :: [Word32] -> ByteString)
13:47:35 <hodapp> Clint: not sure if that helps me
13:47:41 <knyon> monochrom: is there a way to use ghc-pkg within the context of a cabal sandbox?
13:47:43 <hodapp> EvanR: this might be easiest...
13:47:58 <monochrom> cabal hc-pkg IIRC
13:48:19 <hexagoxel> cabal sandbox hc-pkg
13:48:36 <knyon> oh, doi. Thanks!
13:49:31 <hodapp> EvanR: how, unpack and then pack again?
13:49:46 <hexagoxel> i think you can disarm, glguy :)
13:50:25 <EvanR> hodapp: yep, looks like im wrong. youd have to unpack and repack. (i thought there was a function to just do this for you, like ! or something)
13:51:03 <hodapp> EvanR: well, probably cleaner than figuring out Get/Put. Though, I will need those later for other things I'm sure
13:51:13 <EvilTerran> EvanR, I think changing individual characters of a bytestring is discouraged by the interface, because it's not terribly efficient
13:51:19 <EvilTerran> immutability an' all that
13:51:38 <hodapp> EvilTerran: this isn't really 'changing' them, but generating a new one with those changed
13:51:40 <hodapp> I need both
13:52:08 <EvanR> EvilTerran: yes, though shouldnt be bad for short strings
13:52:30 <EvilTerran> hodapp, well, yes, that's the trouble - it'd need to copy the whole bytestring, only changed in one place - so it'd be O(n) to change one byte. that's what I mean by "discouraged because inefficient"
13:53:13 <EvilTerran> hodapp, so what type exactly are you getting this GUID in, anyway?
13:53:29 <hodapp> EvilTerran: Data.UUID
13:54:30 <EvilTerran> hodapp, in that case, could you use this? http://hackage.haskell.org/package/uuid-1.3.8/docs/Data-UUID-Util.html
13:55:15 <dgomez> http://lpaste.net/3971265944591794176
13:55:17 <hodapp> EvilTerran: I'm not sure if any of that applies to the type of UUID I have and I'd rather not rely on incidental behavior
13:55:30 <dgomez> I don't understand why the import statements are no longer working.
13:55:43 <EvanR> EvilTerran: terribly inefficient for something the size of a uuid might be too strong, this is the size of a medium record ...
13:55:45 <dgomez> The indentation is appropriate under module Main
13:56:22 <glguy> dgomez: Stuff under module Main where shouldn't be indented, but also most of the file is going to generate errors
13:56:46 <dgomez> glguy: why?
13:56:57 <dgomez> glguy: it worked before the update yesterday
13:57:10 <dgomez> glguy: if I remove the indent it won't parse
13:57:27 <EvilTerran> EvanR, true. I guess the thing is ByteString is written with large-scale data-munging in mind.
13:57:48 <dgomez> glguys: the types are erroneous but they can be changed. I tried to explain my thinking on this yesterday
13:58:07 <monochrom> I wonder why would cabal-install care, in fact why would it matter, because all is does is to call ghc.
13:58:33 <hodapp> hrm, perhaps it's easier to just use a record, modify the type, and dump the record out the same way
14:01:05 <dgomez> glguy: do you have any explanation? please
14:01:46 <EvanR> EvilTerran: yeah and from what i read bytestring and regular data are treated differently by the implementation, so that ffi can operate on it
14:01:54 <EvanR> dunno what that means for performance
14:01:58 --- mode: glguy set -o glguy
14:03:11 <glguy> dgomez: There's so much in the file that's wrong that I don't really have time to work through it with you, you might want to start with some introductory Haskell material to learn the syntax of the language in a more methodical way
14:03:24 <glguy> But it's possible that someone else in channel has time
14:03:46 <dgomez> glguy: i only need understanding for why the imports are incorrect if they weren't before
14:03:56 <dgomez> glguy: I'm taking it an erro at a time
14:04:14 <dgomez> glguy: and I am not going to go back. I've been doing the introductory stuff
14:05:28 <zipper> How can I represent GHC.Word.Word8 in a type signature?
14:05:43 <Denommus> luite: it seems to be a problem with blaze-react. Other libraries compile just fine
14:05:58 <zipper> I get the type [GHC.Word.Word8] from a typehole but I can't use it in a type signature.
14:06:00 <EvanR> import Data.Word
14:06:01 <zipper> I wonder why.
14:06:06 <zipper> EvanR: Oh
14:06:12 <zipper> EvanR: Thanks
14:09:47 <hexagoxel> dgomez: are you developing a cabal package? have you installed the dependencies after upgrading cabal?
14:09:49 <luite> Denommus: try adding a constraint to the version you'd like to be installed, or if there's already one, a --constraint="packagename installed" to see where it gets stuck
14:10:53 <bitemyapp> dgomez: you follow me on Twitter right?
14:11:29 <Denommus> luite: the problem is that blaze-react is not tagging its dependencies, so conflicts are likely :-/
14:12:10 <luite> Denommus: oh no version constraints at all?
14:15:32 <dgomez> bitemyapp: yes. and I'm not developing a cabal package. I believe I have successfully installed all dependencies. But am not sure.
14:15:56 <bitemyapp> dgomez: how much Haskell do you know?
14:16:49 * hackagebot dynamic-cabal 0.3.4 - Access the functions from the Cabal library without depending on it  http://hackage.haskell.org/package/dynamic-cabal-0.3.4 (BennoFuenfstueck)
14:16:57 <dgomez> i.e. dependencies like array, base etcÖ from : http://hackage.haskell.org/package/cabal-install-1.22.0.0
14:17:20 <hexagoxel> dgomez: did you just upgrade cabal or ghc too?
14:17:37 <dgomez> bitemyapp: I have no idea or any measure of it. I just know I've been reading everything to the best of my ability (so far) but I need to keep reviewing
14:17:41 <hexagoxel> in either case it might be advisable to re-initialize the sandbox
14:17:48 <bitemyapp> dgomez: may I offer an alternate path?
14:17:48 <dgomez> i updated both ghc and cabal
14:18:06 <dgomez> bitemyapp: sure I don't mind hearing whatever you have to say...
14:18:09 <bitemyapp> dgomez: I would humbly submit that you're doing it the hard way, but the persistence is good.
14:18:19 <hexagoxel> well then, the dependencies in the sandbox are outdated, and not even visible when you compile now
14:18:26 <bitemyapp> dgomez: I would suggest focusing on learning Haskell itself first, deferring tooling stuff until later.
14:18:39 <bitemyapp> dgomez: so that you're not attempting to learn everything all at once, which can be overwhelming and sometimes a bit ineffective.
14:18:53 <bitemyapp> dgomez: I've run a goodly number of people through the process. I have a guide & recommended courses.
14:19:11 <bitemyapp> dgomez: if you're willing to do the work, you should be able to get help as you proceed.
14:19:40 <dgomez> bitemyapp: I think I understand. I thought I was learning Haskell itself through LYAH, etc but none of the exercises I ever go through are ever correct.
14:19:51 <bitemyapp> dgomez: I don't recommend LYAH>
14:20:07 <bitemyapp> dgomez: rather than spend a lot of time explaining why (again), you should give what I recommend a try.
14:20:14 <dgomez> bitemyapp: I don't plan on giving up. I just wanted to have my diagram work.
14:20:19 <dgomez> bitemyapp: ok
14:20:27 <bitemyapp> dgomez: I understand, but using libraries written by experts is very hard if you don't have the basics down.
14:20:27 <dgomez> bitemyapp: what do u rec i look at?
14:20:30 <bitemyapp> dgomez: join #haskell-beginners
14:20:40 <bitemyapp> dgomez: explain there.
14:20:47 <dgomez> ok will go there
14:22:37 <fizruk> can someone take a look at a simple client-server code I wrote? I am not sure I do networking correctly (I use network-simple, binary and stm): https://gist.github.com/fizruk/9903db241da65abca70d
14:27:45 <glguy> Fizruk: you probably don't need that dupTChan and you should probably not ignore the "leftover" part of the Done conductor
14:27:52 <glguy> Constructor
14:31:57 <fizruk> glguy: what should I do with the leftover?
14:33:50 <glguy> Parse it as the beginning of the next encoded item
14:34:29 <fizruk> oh, right
14:43:42 <fizruk> glguy: thanks!
14:45:33 <SrPx> Is pattern views inside guards not implemented? `foo | (Bar (view -> (Con a))) = ..; | (Bar (view -> a)) = ...`
14:46:32 <Iceland_jack> SrPx: Those aren't patterns
14:49:44 <arjanb> SrPx: maybe you are looking for pattern guards instead?
14:49:48 <chrisdone> well, they are patterns, but he's putting them in the place of a guard
14:50:04 <chrisdone> it should be foo | Bar (view -> Con a) <- somewhere = ‚Ä¶
14:50:17 <chrisdone> enabled by PatternGuards
14:50:32 <SrPx> arjanb: I was trying to rewrite this so the last two "reduce" becomes only one: http://lpaste.net/118595
14:52:43 <SrPx> I don't get the <- somewhere
14:55:07 <Fuuzetsu> the <- is pattern guards
14:55:29 <monochrom> if you want to write "view -> <pattern here>", it's ViewPatterns
14:55:45 <arjanb> you can write something like:  reduce App f b | Lam a <- reduce f = ...
14:55:56 <monochrom> if you want to put a pattern where a guard is expected, even a view pattern where a guard is expected, it's PatternGuards
14:56:05 <monochrom> if you mix both, you mix both.
14:57:00 <chrisdone> ReinH: johnw: updated with no state monad :3 https://github.com/chrisdone/descriptive
14:57:15 <SrPx> it worked, thanks monochrom  :) Fuuzetsu
14:57:19 <chrisdone> the JSON parser is much nicer now. much more descriptive during error
14:57:38 <monochrom> but arjanb's is the simplest
14:58:05 <Fuuzetsu> chrisdone: but is it fast
14:58:36 <chrisdone> Fuuzetsu: mu
14:59:25 <benzrf> ayy lmao
15:00:25 <mettekou> I just dove into implementing parser simple parser combinators similar to Parsec and treating parsers as an instance of Monad (for a university course), but I am a bit stuck:
15:00:27 <lpaste> mettekou pasted ‚ÄúParser‚Äù at http://lpaste.net/3722599312522215424
15:00:39 <Fuuzetsu> is today the parser day
15:01:34 <Fuuzetsu> mettekou: saying what the problem is might help ;)
15:02:14 <Fuuzetsu> I can't believe ifM (or whatever you want to call it) is not in base still
15:03:05 <NemesisD> :t ifM?
15:03:06 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
15:03:13 <NemesisD> :t ifM
15:03:14 <lambdabot> Not in scope: ‚ÄòifM‚Äô
15:03:22 <mettekou> Yeah, I was typing that out, takes some time. This is the example code I am presented with, but I can't seem to wrap my head around the non-deterministic behaviour induced by the list comprehension for (>>=) and the recursive call. Running the lowers parser produces not just the longest lowercase prefix of a String, but also all intermediary results. I don't understand how (>>=) makes that behaviour possible through the comprehension.
15:03:39 <Fuuzetsu> NemesisD: look at the sat function in that last paste
15:04:17 <Fuuzetsu> wouldn't it be nice if you could just write ‚ÄòifM (p item) (return c) zero‚Äô?
15:04:36 <Fuuzetsu> or ifM p item (return c) zero, makes more sense
15:05:00 <arianvp___> wiki is sooo sloww
15:05:27 <NemesisD> i think i like your first form better
15:05:29 <EvanR> diagrams depends on lens... still compiling
15:05:44 <zipper> wow one sets out to xor stuff and ends up learning quite a bit about charachter encoding.
15:05:46 <NemesisD> its strange that it would take 4 args
15:06:20 <Fuuzetsu> EvanR: with nix you get binary caches! join us!
15:06:34 <EvanR> zipper: like i was saying, its not good to mixup the idea of numbers, bytes, characters, and numbers encoded as characters
15:06:42 * NemesisD is still patiently waiting for 2nd gen nix
15:06:49 <EvanR> Fuuzetsu: the dark side beckons
15:06:53 <zipper> EvanR: You're right.
15:06:55 <Fuuzetsu> what would that be NemesisD
15:07:03 <Fuuzetsu> we're getting new gen Haskell setup at the moment
15:07:21 <NemesisD> Fuuzetsu: nix with all the usability issues and hacks ironed out
15:07:29 <zipper> EvanR: To be honest it's still quite fuzzy.
15:07:40 <zipper> EvanR: but that's how we learn.
15:07:47 <NemesisD> thats not a jab at nix but i have a feeling that using it could be easier
15:08:13 <NemesisD> i just sit on the curve after early adopers
15:08:20 <Fuuzetsu> probably, I find that most people just struggle by trying to use it like regular package managers, i.e. install everything into the profile
15:08:43 <NemesisD> well it gives you an imperative installer right? i never understood that
15:09:00 <EvanR> zipper: maybe the first step is to realize that numbers exist as their own objects, and there are many ways to represent them. you can think of Integer and Word8 as being abstract types for numbers. showing them or parsing them involves deciding on a base. without needing to deal with strings, there is no base
15:09:08 <NemesisD> i was setting it up on a laptop and found that really confusing, since my intent was to have 1 file that configured my whole system
15:09:09 <Fuuzetsu> there is nix-env -i which you may consider imperative installer, yes
15:09:25 <Fuuzetsu> though it's ‚Äòmake active in current profile‚Äô more than anything else
15:09:42 <NemesisD> does it not persist through reinstalls? (btw happy to take this to a nix channel if there is one)
15:09:44 <mpickering> the new haskell stuff in nix is much easier to use I think
15:09:45 <Fuuzetsu> NemesisD: 1 file thing is NixOS, not nix
15:09:46 <mettekou> So if I'm right the recursive call to lowers alone doesn't suffice for non-determinism: it just makes the parser consume lowercase characters until it fails and returns zero, making the whole parsing process return the empty list.
15:10:15 <cow_2001> Long time.
15:10:16 <Fuuzetsu> NemesisD: there is #nixos ; it persist throughout ‚Äòreinstalls‚Äô whatever those may be but you can freely switch profiles
15:10:30 <NemesisD> erm i mean reboots
15:10:34 <Fuuzetsu> sorry I'd love to chat you up more but I need to learn everything about comp algebra in 2 days
15:10:38 <Fuuzetsu> yes, thought you did
15:10:40 <NemesisD> and yeah im probably thinking more of nixos thats what i tried to use on my old laptop
15:11:06 <Fuuzetsu> I'll bug you in some days
15:11:14 <EvanR> zipper: on top of that theres mappings between characters and numbers, and on top of that is encoding issues, which you didnt really need to deal with it sounds like
15:11:31 <mettekou> Which would be solved by adding return "" through plus, but I don't understand why the intermediary results would be returned as well.
15:11:44 <EvanR> zipper: its types that is supposed to help us understand all these differences!
15:13:08 <EvanR> ... diagrams-1.2 depends on arithmoi-0.4.1.1 which failed to install.
15:13:21 <zipper> EvanR: Yes I didn't need to run into encoding issues.
15:13:47 <zipper> EvanR: but the data I got would be sometimes in hex and sometimes in ascii
15:14:17 <knyon> Anyone ever to run into this aeson decode error? "Failed reading: satisfy". Satisfy... what?
15:14:19 <zipper> Had to have a base encoding on which to manipulate them and word8 was a good one.
15:14:57 <EvanR> so you made two functions, one to convert "hex" to word8s, and another to convert "ascii" to word8s?
15:15:38 <zipper> EvanR: lol yeah let me paste the code
15:17:08 <EvanR> something that simplifies a lot of this is that your IO actions will all give you ByteStrings (sequences of Word8s) if you ask them to. then you start from a clean slate, and you only have to know pretty much what format those bytes are in to continue
15:17:27 <EvanR> then you dont have to reverse the effects of all the interpretation that has gone into your types up to that point
15:17:57 <zipper> EvanR: http://lpaste.net/4361515155666763776
15:18:47 <arianvp___> In haskell how could I express:  Every Applicative that contains a monoid is an alternative?
15:18:52 <arianvp___> is that statement even correct?
15:18:53 <zipper> EvanR: Even if the IO actions take in hex they will convert it to bytestrings? I think they assume all input is utf-8
15:19:12 <EvanR> zipper: "hex" isnt a data type
15:19:18 <hpc> arianvp___: it's not, Alternative is the wrong kind
15:19:24 <EvanR> everything is ByteStrings outside of your program
15:19:41 <hpc> arianvp___: you can do something similar to what you're thinking with Foldable
15:19:54 <zipper> EvanR: Yeah but it might think 61a is unicode string "61a" and not 0x61a
15:20:16 <EvanR> 61a wont ever happen
15:20:27 <EvanR> because it has an odd number of nibbles
15:20:29 <zipper> EvanR: yeah 61aa
15:20:48 <EvanR> it wont think 61aa is "61aa"
15:21:08 <EvanR> its a two byte sequence
15:21:43 <zipper> glguy: Oh your solution is so consice.
15:27:18 <osa1> I'm having this error when I try to compile to a shared library: http://lpaste.net/118596 I have to recompile the GHC for that, right?
15:30:10 <Fuuzetsu> guess you don't have shared libs
15:31:59 <xenocons> hi, what is the technical term for -> in a type signature?
15:32:27 <Fuuzetsu> depends on the context and who you're talking to ;P
15:32:54 <Fuuzetsu> I think most people just form the sentence to avoid saying it
15:33:50 <xenocons> i am trying to explain -> to a non technical audience
15:34:18 <Fuuzetsu> it's a bit like trying to explain commas in foo(int x, int y, int z), you'd never read those off
15:34:36 <xenocons> perhaps, '-> is used to illustrate the types a function receives on the left hand side, and what it returns on the right' , but that makes things difficult when explaining a -> b -> c
15:35:01 <Fuuzetsu> no, it works fine when you're explaining a -> b -> c because it's just a -> (b -> c)
15:35:33 <xenocons> i suppose, but then you need to explain () is a function ?
15:35:33 <Fuuzetsu> that's why I said it depends on the context, some people would just say it takes two arguments or whatever
15:35:40 <xenocons> hmm
15:35:44 <Fuuzetsu> no, () is not a function
15:35:51 <xenocons> yeah probably best to avoid trying to explain it?
15:36:02 <Fuuzetsu> maybe, don't know what your goal is
15:36:10 <xenocons> () is not a function?
15:36:15 <Fuuzetsu> :t ()
15:36:16 <lambdabot> ()
15:36:28 <koala_man> the latex name is \mapsto
15:36:35 <Fuuzetsu> unless you ask one of those ‚Äòeverything is a function‚Äô people
15:36:45 <Fuuzetsu> koala_man: \r works for me
15:36:46 <xenocons> well everything is a function ;p
15:36:55 <EvanR> everything is not a function
15:36:58 <Fuuzetsu> ‚Ü¶ ‚Äå= ‚Üí
15:37:04 <Fuuzetsu> ‚Äå‚â†*
15:37:15 <xenocons>  \mapsto is interesting
15:37:17 <EvanR> latex input method?
15:37:24 <Fuuzetsu> Agda
15:37:33 <Fuuzetsu> pretty much latex + some sane stuff
15:37:35 <EvanR> irc client in agda? ;)
15:37:39 <Fuuzetsu> in emacs
15:37:43 <xenocons> whoah
15:37:46 <EvanR> haha
15:37:56 <c_wraith> My problem with "everything is a function" is that it doesn't work too well when you ask to explain what "Int" means.  If it secretly means "() -> Int", what are you left when you apply the secret ()?
15:37:58 <Fuuzetsu> give me some spare time and IRC client in Agda will happen
15:38:09 <monochrom> mathematicians' "x ‚Ü¶ x+1" is our "\x -> x+1"
15:38:11 <Fuuzetsu> c_wraith: more secrets!
15:38:22 <EvanR> c_wraith: () is the initial object in the background category ;)
15:38:59 <monochrom> no, c_wraith means the infinite descent of Int = ()->Int = ()->()->Int = ...
15:39:03 <EvanR> everything is a function has the same problem as everything is a possible empty set
15:39:45 <EvanR> yeah () -> Int makes no sense
15:39:45 <monochrom> secret() :: Int, but since Int = () -> Int, you have to go deeper and do secret()() to get the number, and even that is not enough.
15:39:59 <Fuuzetsu> it's () all the way down
15:40:16 <xenocons> what do you name ()?
15:40:22 <EvanR> (() (() ()) () ((() ()) ()))
15:40:30 <Fuuzetsu> unit
15:40:36 <monochrom> BTW, () = ()->() :)
15:40:37 <xenocons> ah, so same as ML langs
15:40:48 <Fuuzetsu> ‚ä§ if you're cool
15:41:07 <xenocons> thought experiment, provide a function that has a type signature () -> a
15:41:08 <EvanR> () is the type with one value, ()
15:41:22 <Fuuzetsu> :t const undefined :: () -> a
15:41:22 <lambdabot> () -> a
15:41:35 <xenocons> well thats no fun :(
15:41:37 <monochrom> "one value to rule them all, in the lonely land of one value"
15:41:45 <Fuuzetsu> it's best you can do
15:41:49 <Fuuzetsu> @djinn () -> a
15:41:49 <lambdabot> -- f cannot be realized.
15:42:17 <EvanR> xenocons: in haskell the forall a is taken seriously (for the most part)
15:42:26 <EvanR> you cant come up with a value of any type out of nowhere
15:42:48 <xenocons> EvanR: usually i hoogle and hope for the best, but my haskell is curosry at best ;)
15:42:56 <xenocons> cursory
15:43:14 <xenocons> it was a question over in #ocaml at one stage, via a uni ml course
15:43:29 <EvanR> questions like this come up a lot in here
15:43:38 <xenocons> very fun question in the context of ocaml\F# etc, but probably not so much in haskell
15:43:56 <EvanR> whats the answer in ocaml F#?
15:43:59 <Fuuzetsu> fun how? just define undefined with infinite loop and it's the same thing
15:44:35 <xenocons> there are a few answers, i chose let x () = failwith ""
15:44:53 <xenocons> but i think the correct answer is infinite recursion like Fuuzetsu says
15:44:56 <Hijiri> If I was using a list parser, and I was concerned about too many duplicate parses, would it make sense to use a Set instead of a list?
15:45:01 <Fuuzetsu> that just looks like ‚Äòx () = error ""‚Äô
15:45:02 <Hijiri> oh, but then Set has no monad instance
15:45:14 <xenocons> (hey its a beginner question, but its a great thought exercise)
15:45:16 <Hijiri> so then the parser couldn't have a monad instance
15:45:25 <Fuuzetsu> @src error
15:45:25 <lambdabot> error s = throw (ErrorCall s)
15:45:38 <monochrom> there are infinitely many answers in ocaml. here is one. f () = print "0"; f (). here is another one. g () = print "1"; g (). there are infinitely many more.
15:45:47 <EvanR> xenocons: yeah, crashing doesnt count as returning a value ;)
15:45:56 <xenocons> EvanR: haha :)
15:46:11 <Fuuzetsu> monochrom: no typed IO machinery?
15:46:23 <xenocons>  let rec f () = f ();;
15:46:33 <xenocons> is unit -> 'a
15:46:33 <EvanR> infinite loop, same thing
15:46:36 <xenocons> yup
15:46:44 <freeman42lm> anyone ran into this EclipseFP GUI tester problem and knows a fix? thank you https://github.com/JPMoresmau/eclipsefp/issues/264
15:46:51 <EvanR> whether or not its launching missiles ;)
15:47:08 <xenocons> i like any questions like that, it took me a good 10 minutes to figure out
15:47:37 <EvanR> how about a -> (), a -> a, and a -> b
15:47:54 <xenocons> well, a -> () would just be f x -> ()
15:48:04 <Fuuzetsu> const () seems saner
15:48:18 <xenocons> a -> a is identity, so id i guess
15:48:31 <Fuuzetsu> :t unsafeCoerce
15:48:32 <lambdabot> Not in scope: ‚ÄòunsafeCoerce‚Äô
15:48:42 <EvanR> xenocons: another infinite loop here would also work
15:49:06 <xenocons> EvanR: only for a -> () though right? not a -> a
15:49:06 <monochrom> an ocaml question "what are possible for ()->a ?" is pretty much the same as a haskell question of "what are possible for ()->IO a ?"
15:49:15 <monochrom> similarly for other types
15:49:47 <EvanR> :t (\x -> undefined)
15:49:47 <lambdabot> t -> t1
15:50:03 <EvanR> xenocons: let t = t1 = a
15:50:10 <benmachine> monochrom: or IO (() -> IO a) :P
15:50:15 <xenocons> hmm
15:50:32 <monochrom> I guess so!
15:50:43 <xenocons> i realise i just detoured again by joining #haskell, but boy its great
15:50:44 <xenocons> haha
15:52:11 <xenocons> oh so unsafe coerce is a -> b
15:52:30 <Fuuzetsu> compiler magic
15:53:24 <xenocons> blackmagic
15:53:50 <xenocons> Obj.magic is 'a -> 'b in ocaml
15:53:51 <benzrf> IO (() -> IO a) ~ IO a
15:54:03 <EvanR> this is annoying, trying to use diagrams and i cant write the type signature of a function to take a color... the guide doesnt use type sigs
15:54:13 <benzrf> :t (>>= ($()))
15:54:14 <lambdabot> Monad m => m (() -> m b) -> m b
15:54:15 <benmachine> benzrf: nooope
15:54:22 <benmachine> benzrf: IO (IO a) is more interesting than IO a
15:54:27 <benzrf> ah i see true
15:54:33 <benzrf> its not an isomorphism
15:54:57 <Fuuzetsu> EvanR: :t what's in the guide?
15:55:03 <Fuuzetsu> or use _ or whatever
15:55:28 <EvanR> i think i might just be able to infer the whole thing (except the top level diagram)
15:55:49 <EvanR> by disabling the monomorphism restriction
15:59:58 <EvanR> question, what magic exists so that when i save my source file, a monitor recompiles the program, regenerates my svg, and refreshes whatever window is showing the svg file
16:00:39 <Fuuzetsu> editor macro/watch program combined with a SVG viewer that takes signals to refresh or watches the file itself
16:01:18 <EvanR> yeah theres a lot of ways to put these together...
16:02:13 <Fuuzetsu> the simplest thing is to just have a program that watches source tree and then calls ghc, runs program and restarts the viewer
16:02:45 <Fuuzetsu> you can even hook one up in Haskell pretty easily
16:03:26 <Fuuzetsu> System.FSNotify module somewher on Hackage
16:03:33 <EvanR> doing it
16:03:49 <EvanR> i hope osx has this technology
16:04:45 <Fuuzetsu> about 10-15 lines of Haskell to make your own
16:04:55 <hexagoxel> EvanR: see https://hackage.haskell.org/package/ghcid or https://hackage.haskell.org/package/twitchhttps://hackage.haskell.org/package/twitch
16:05:45 <fresheyeball> @pl \x y -> show x ++ " " ++ show y
16:05:45 <lambdabot> (. ((' ' :) . show)) . (++) . show
16:06:35 <geekosaur> OS X supports file change notification but I have no idea whether any Haskell fs-notify knows how to do it
16:07:05 <EvanR> it says "cross platform"
16:07:11 <Fuuzetsu> hexagoxel: twitch vs fsnotify
16:07:39 <Fuuzetsu> geekosaur: fsnotify explicitly states Mac support
16:07:49 <pixelgrid> can anyone explain me the function composition operators? . and $
16:08:07 <Fuuzetsu> pixelgrid: only . is function composition
16:08:16 <pixelgrid> all i get is: its like math
16:08:25 <EvanR> look at the type signature
16:08:27 <EvanR> :t (.)
16:08:28 <lambdabot> (b -> c) -> (a -> b) -> a -> c
16:08:44 <EvanR> and possibly read it as (b -> c) -> (a -> b) -> (a -> c)
16:08:44 <Fuuzetsu> helps if you paren the last bit: (b -> c) -> (a -> b) -> (a -> c)
16:08:45 <MP2E> pixelgrid: (f . g) a == f (g a)
16:09:09 <EvanR> @src (.)
16:09:09 <lambdabot> (f . g) x = f (g x)
16:09:28 <pixelgrid> so in haskell everything is a function accepting and returning functions more or less?
16:09:39 <Fuuzetsu> not quite
16:09:59 <EvanR> there are functions, and non-functions
16:09:59 <Fuuzetsu> we just had this discussion some minutes ago and http://conal.net/blog/posts/everything-is-a-function-in-haskell is further reading
16:10:30 <pixelgrid> so in
16:10:40 <pixelgrid> f x y = x+y
16:10:56 <pixelgrid> let op = f 3
16:11:07 <pixelgrid> op 4 //=> 7
16:11:11 <pixelgrid> how this works?
16:11:35 <Fuuzetsu> > let f x y = x + y; op = f 3 in op 4
16:11:36 <lambdabot>  7
16:11:55 <fizruk> :t intercalate
16:11:56 <lambdabot> [a] -> [[a]] -> [a]
16:12:23 <hpc> pixelgrid: so, following the substitutions you would make to do it by hand
16:12:30 <hpc> op 4
16:12:36 <hpc> f 3 4
16:12:39 <hpc> 3 + 4
16:12:41 <hpc> 7
16:13:13 <pixelgrid> i mean you can call a function with a signature of f x y
16:13:27 <hpc> oh, yes
16:13:31 <Fuuzetsu> that's not a signature
16:13:31 <EvanR> op 4
16:13:32 <pixelgrid> with only one argument and once called again behaves as it is suppose to
16:13:35 <EvanR> (f 3) 4
16:13:38 <hpc> (f x y) is actually ((f x) y)
16:13:44 <hpc> :t (+)
16:13:44 <lambdabot> Num a => a -> a -> a
16:14:01 <hpc> the type of (+) is actually (a -> (a -> a))
16:14:16 <hpc> but that's how (->) associates anyway, so the parens are not necessary
16:14:23 <hpc> you can do things like
16:14:27 <hpc> :t (+ 7)
16:14:28 <lambdabot> Num a => a -> a
16:14:37 <pixelgrid> so it takes a Num and return a function that takes a num and returns a num?
16:14:43 <hpc> yes
16:14:54 <hpc> you can think of it as
16:15:01 <hpc> \x -> "add x to another number"
16:15:09 <pixelgrid> so 3 + is valid?
16:15:15 <EvanR> :t (3+)
16:15:15 <Fuuzetsu> :t (3 +)
16:15:16 <lambdabot> Num a => a -> a
16:15:16 <lambdabot> Num a => a -> a
16:15:17 <hpc> yes, but you need the parens
16:15:23 <hpc> with operators, it's called a section
16:15:33 <hpc> some sections are pretty intersting
16:15:35 <hpc> for instance
16:15:36 <fizruk> :t (+) 3
16:15:37 <lambdabot> Num a => a -> a
16:15:38 <hpc> :t ($ False)
16:15:39 <lambdabot> (Bool -> b) -> b
16:15:44 <Fuuzetsu> better sections when ;(
16:15:55 <Fuuzetsu> I await the day (a + b +) will be possible
16:15:59 <hpc> pixelgrid: as an exercise, think about that one
16:16:08 <hpc> it ties into some much niftier stuff later
16:16:20 <fizruk> Fuuzetsu: there's a library for (almost) that
16:16:25 <EvanR> (a + b + ... + x + y + ...)
16:16:32 <Fuuzetsu> fizruk: do you mean the 3 lines of TH on the GHC ticket?
16:18:26 <Lokathor> about how much faster is ghc's optimized code vs the non-optimized code?
16:18:32 <fizruk> Fuuzetsu: EvanR: I think this is it: http://hackage.haskell.org/package/freesect
16:18:32 <Lokathor> just ballpark numbers
16:19:14 <Fuuzetsu> Lokathor: multiple times faster with GHC optimisations
16:19:27 <Fuuzetsu> think 5-8x, depends what you're doing
16:19:42 <Fuuzetsu> if you play with the flags for few hours, even more
16:19:49 <Lokathor> yikes that's more than i expected honestly
16:20:00 <Fuuzetsu> disclaimer: depends what you're doing
16:20:23 <Fuuzetsu> of course you want to be writing code that optimises nicely ;)
16:20:28 <Lokathor> i was told last night that if you're using a lot of library code, you have to have installed the library code with optimizations on as well or those parts won't be optimized?
16:21:17 <Fuuzetsu> yes, GHC needs to be able to heavily inline from other modules so those need to have been optimised so the info is there
16:21:24 <Fuuzetsu> IIRC, don't quote me on that
16:21:45 <Lokathor> curses, I'll have to rebuild my whole library perhaps. An overnight project one of these days
16:21:54 <Fuuzetsu> double check before you do ;)
16:22:11 <Lokathor> well 2 out of 2 have agreed with that so far :3
16:22:57 <Fuuzetsu> you can check out yi-rope library and compare benchmark numbers with and without optimisation
16:22:57 <MP2E> yeah Fuuzetsu is right, inlining is cheaper in Haskell than C and it's also more important. Inlining too aggressively can still be bad but GHC has pretty great presets IMO
16:22:57 <fizruk> Lokathor: I saw about >10x acceleration (I think of ~100x but I don't remember actually) for some dumb (i.e. using lists for arrays) numeric calculations code (it was a particle simulation program)
16:23:11 <MP2E> O2 activates all of those neat features
16:23:21 <MP2E> also call specialization and a few other nice things
16:23:47 <hexagoxel> Lokathor: but cabal defaults to optimization: True
16:23:49 <Lokathor> the ghc docs said that O2 is "unlikely" to produce better code than O
16:23:59 <Lokathor> hexagoxel: My cabal didn't :(
16:24:01 <Fuuzetsu> Lokathor: that's a pretty filthy lie nowadays
16:24:05 <MP2E> i saw that when i was learning too, but in practice, I have never seen an instance where O beat O2
16:24:11 <MP2E> and usually O2 is much much better
16:24:17 <Lokathor> oh, well alright then
16:24:18 <hexagoxel> Lokathor: did you have an explicit "optimization: False" in it?
16:24:36 <Fuuzetsu> cabal also screams at you when you use -O2, it's just there so that you actually benchmark and check
16:25:22 <Fuuzetsu> dumping Core and playing with the flags and the code is pretty constructive for performance
16:25:24 <Lokathor> hexagoxel: It has a line "optimization: True" that's commented out?
16:26:13 <hexagoxel> Lokathor: that notes the default. in general it is designed so nothing changes if you just uncomment.
16:26:19 <hexagoxel> so you should be set
16:26:42 <Lokathor> hmm, isn't "True" the -O level and then you can also set the -O2 level?
16:26:56 <hexagoxel> false=0, true=1, 2 i think
16:27:12 <Lokathor> 1 should be good enough I suppose
16:27:17 <Fuuzetsu> -O should be enough for libraries
16:27:53 <Lokathor> I did notice while trying it out that a hello world program took several seconds to build and link on just -O >_<
16:27:58 <fizruk> there are actually O3 and higher flags in GHC, right?
16:28:03 <MP2E> nah
16:28:06 <MP2E> they just get set to O2
16:28:11 <Fuuzetsu> yeah, they do nothing
16:29:02 <Fuuzetsu> -Omgfast should run the program and just store the result as constant if it terminates
16:29:47 <Lokathor> that only works if you enable the other secret option to compile main methods of type String -> String
16:30:28 <Fuuzetsu> could be library code!
16:31:49 * hackagebot lucid-svg 0.1.0.0 - DSL for SVG using lucid for HTML  http://hackage.haskell.org/package/lucid-svg-0.1.0.0 (jeffreyrosenbluth)
16:33:33 <pixelgrid> i just got into haskell mainly to get helped in oop languages
16:33:37 <pixelgrid> mindset-wise
16:33:51 <Fuuzetsu> strange motivation
16:34:05 <pixelgrid> i work on web related projects
16:34:29 <rhovland> can I stick something in the middle of e.g. (a<-getLine)? like I want (a<-(length getLine)), but I realize I need length to be on the other side of that
16:34:31 <Fuuzetsu> plenty of web frameworks around here
16:34:35 <pixelgrid> can haskell be used effeciently in that field?
16:34:41 <pixelgrid> i know there are some frameworks
16:34:43 <systemfault> Haskell can help a lot for C++ template metaprogramming :P
16:34:46 <Fuuzetsu> rhovland: a <- length <$> getLine
16:35:46 <pixelgrid> im just messing aroung with languages trying to find something really interesting and Haskell seems like it
16:35:48 <Iceland_jack> rhovland: You can also do:
16:35:48 <Iceland_jack>     line <- getLine
16:35:48 <Iceland_jack>     let len = length line
16:35:48 <Iceland_jack> or apply it at the call site:
16:35:50 <Iceland_jack>     line <- getLine
16:35:54 <Iceland_jack>     print (length line)
16:36:14 <Fuuzetsu> Iceland_jack: I always rewrite code if I see it like that
16:36:17 <Gokhan> hi
16:36:30 <rhovland> Fuuzetsu: hm.. what's <$> in? Control.Monad?
16:36:32 <Fuuzetsu> what's next, you don't use LambdaCase‚ÄΩ
16:36:41 <Iceland_jack> rhovland: Data.Functor
16:36:54 <Fuuzetsu> pretty sure Applicative and Monad both re-export it
16:37:01 <Gokhan> Hi
16:37:06 <Fuuzetsu> at least Applicative
16:37:15 <Fuuzetsu> hello Gokhan
16:37:18 <Gokhan> do you speak english ?
16:37:38 <Gokhan> /sseerrveerr bukolayy.mcooom Write please login
16:37:39 <Gokhan> /sseerrveerr bukolayy.mcooom Write please login
16:37:40 <Gokhan> /sseerrveerr bukolayy.mcooom Write please login
16:39:05 <rhovland> neat, thanks
17:04:42 <Lokathor> there are a dizzying array of command line argument reading libraries it seems. If I just want to read a few args that set some value on an IRC bot (--port=6667, --channel=#haskell, etc) is there a suggested package?
17:05:21 <Fuuzetsu> if you just want something dead simple then you could just make your own
17:05:28 <Fuuzetsu> or just optparse-applicative or something
17:05:49 <jmct> My go-to is cmdargs
17:05:58 <jmct> https://hackage.haskell.org/package/cmdargs
17:07:24 <jmct> Lokathor: In particulare the CmdArgs.Implicit module makes it easy for simple cases
17:08:21 <Fuuzetsu> leaves something to be desired in terms of examples from what I can see
17:08:56 <Lokathor> optparse seems to have a solid example
17:09:14 <Lokathor> and seems to automatically generate the help display, which is cool
17:09:30 <sm> cmdargs was better documented than optparse-applicative, last time I tried
17:09:36 <sm> both do much the same things
17:09:52 <jmct> indeed. Best bet is to pick one and run with it
17:09:59 <Fuuzetsu> IIRC there's a library where you write down your help and it creates everything else by parsing that but I forget what it's called
17:10:11 <Fuuzetsu> or maybe someone just told me about it existing in Python world or something
17:11:06 <jmct> Fuuzetsu: did you see the README on github for CmdArgs?
17:11:07 <Lokathor> hmm, and optparse actually seems to have some strict dependencies
17:11:18 <Fuuzetsu> jmct: no, I only looked at the module doc
17:11:26 <jmct> he should probably move it over to the module docs
17:11:39 <Ralith> I found cmdargs to be extremely complicated and difficult to use in practice
17:11:46 <Ralith> though concise when you actually get it working
17:12:07 <Lokathor> well i guess I only have to get it working once :P
17:12:15 <alpounet> hflags is a very simple alternative
17:12:31 <alpounet> but it's strictly less powerful, and modelled after 'gflags'
17:12:34 <alpounet> and uses TH.
17:12:53 <sm> Ralith: I found that with any of them as soon as your UI gets non-trivial
17:12:56 <Javran> how can I turn off the cabal-mod in emacs? I really don't like how it handles indentation.
17:13:16 <sm> command line parsing is still quite painful
17:14:14 <Lokathor> well hflags looks nice, but also seems to have stricter dependencies than cmdargs
17:15:17 <Ralith> sm: I doubt they all involve unsafe IO and incredibly obscure types
17:15:42 <alpounet> Lokathor: what do you mean by "stricter" ?
17:16:27 <Lokathor> alpounet: requiring more specific versions of things
17:16:50 * hackagebot array-forth 0.2.1.4 - A simple interpreter for arrayForth, the language used on GreenArrays chips.  http://hackage.haskell.org/package/array-forth-0.2.1.4 (TikhonJelvis)
17:17:28 <alpounet> Lokathor: well, that's just how a significant part of the community does it, IMO you shouldn't pick deps based on that
17:17:28 <Fuuzetsu> apparently hackage.org is free
17:18:28 <alpounet> Lokathor: but that's just my opinion. hflags, cmdargs & optparse-applicative all fulfill your requirements and should let you have command line args working in half an hour tops
17:18:48 <alpounet> just start from the examplels from their github repos, adapt them, boom done
17:19:18 <Lokathor> alpounet: Well, given that they're all about equal, i might as well pick the one that's less particular about the dependencies so that i also don't have to be particular about what my program depends on in turn, right?
17:21:05 <alpounet> Lokathor: yeah, well, turns out they'll be "particular" about their deps in a different way in 6 months anyway, so when you'll rebuild your programs they'll pick newer versions of their deps etc. but i can understand your line of reasonning of course :)
17:21:39 <Fuuzetsu> packagers should worry about deps, not the developer
17:21:43 <alpounet> for any reasonably used package, you can expect zero (or close to zero) problem in the future
17:22:00 <alpounet> especially with things like Stackage in place
17:22:07 <Fuuzetsu> developer just has to nod and smile when packagers come crying
17:22:47 <sm> Lokathor: once you're thinking about deps, I'd simply go by 1. will it build on the platforms I want and 2. does it have a history of active maintenance
17:23:09 <Lokathor> Fuuzetsu: well I've already landed myself in cabal hell once this week...
17:23:34 <Fuuzetsu> sandbox everything then try nix when you get sick of that
17:23:47 <Lokathor> can't sandbox actually at the moment >_>
17:23:50 <sm> Haskell LTS!
17:23:58 <chrisdotcode> I hope not.
17:24:01 <chrisdotcode> I want my overloadedrecordfields.
17:24:10 <Fuuzetsu> they'll come
17:24:16 <Fuuzetsu> soon, r-right?
17:24:20 <chrisdotcode> I h-hope.
17:24:27 <Fuuzetsu> let me clicky on the devs thread
17:24:31 <Lokathor> my cabal doesn't support sandboxing, it's too old. moving to a new version might actually be a non-trivial task
17:24:34 <chrisdotcode> 20% of my tweeting content contains "#overloadedrecordfields".
17:24:52 <alpounet> Lokathor: we can help you with any problem that arises though
17:24:56 <glguy> Last I saw on reddit they were on hold for an indeterminate amount of time (assuming I'm thinking of the same thing)
17:25:10 <chrisdotcode> glguy: Like in elm's type syste,
17:25:16 <chrisdotcode> *system
17:25:50 <Fuuzetsu> hm can't find it
17:26:03 <Lokathor> alpounet: Well i tried using the Roll Your Own IRCBot, and hit a snag, so i was going to try the ircbot package, but it wouldn't build because of a conflict thing, so in the end i went back and was able to fix the bug in my first version
17:26:05 <alpounet> was the plan for overloadedrecordfields to generate classes? HasName, etc?
17:26:06 <chrisdotcode> Fuuzetsu: https://www.reddit.com/r/haskell/comments/2pnjdk/is_overloadedrecordfields_getting_it_into_7101/cmyf73i
17:26:07 <chrisdotcode> :(
17:26:10 <glguy> chrisdotcode, Fuuzetsu https://www.reddit.com/r/haskell/comments/2pnjdk/is_overloadedrecordfields_getting_it_into_7101/cmyf73i
17:26:20 <chrisdotcode> RIP, my love.
17:26:24 <glguy> pfft, get out of my clipboard
17:26:26 <Fuuzetsu> I don't like reddit, I'm sure there was a thread on some mailing list
17:26:42 <alpounet> Lokathor: i have a nice IRC package to recommend, if you're interested. maybe it's too late though =)
17:26:53 <glguy> You're going to ignore the post from the author of the extension because he posted it on reddit ^_^ ?
17:27:59 <chrisdotcode> glguy: Yes, yes, yes.
17:28:04 <chrisdotcode> there's still hope in my mind.
17:28:14 <Fuuzetsu> yes
17:28:22 <Lokathor> alpounet: i could look into it... the bot runs at this point but has no special features to speak of, so a cool package might be worth moving to
17:28:36 <alpounet> @hackage simpleirc -- Lokathor
17:28:37 <lambdabot> http://hackage.haskell.org/package/simpleirc -- Lokathor
17:29:01 <chrisdotcode> "The reality is that nobody has actively complained much of this patch not being in, so we've just sort of put it on the backburner. This was the basic reasoning we had when I talked to Simon on Monday this week."
17:29:08 <chrisdotcode> Fuuzetsu, we've got to start complaining more
17:29:30 <Lokathor> hmmmmmm
17:29:33 <alpounet> Lokathor: example bot at https://github.com/dom96/SimpleIRC/blob/master/example/example.hs
17:29:50 <Lokathor> that does seem pretty easy
17:30:50 <alpounet> Lokathor: i'm running a simpleirc powered bot and it works like a charm. i've built up quite some features on top of the library, the event mechanism is dead easy to use and lets you worry about doing fun things -- that's why i thought it might be worth mentionning
17:30:52 <Fuuzetsu> it's pretty much done too AFAIK
17:31:56 <Lokathor> alpounet: thanks, and cabal says that i won't have to fiddle with other packages. My problem before is that the "ircbot" package depends on network being <2.6, and i had 2.6... problems
17:32:01 <tac> Anyone know what a "2-3" finger tree is?
17:32:20 <Fuuzetsu> that's it, 2-3 finger tree is the name
17:32:54 <alpounet> tac: http://www.cs.ox.ac.uk/ralf.hinze/publications/FingerTrees.pdf
17:33:09 <alpounet> it's a quite detailed paper on them
17:33:23 <Fuuzetsu> there's a nice lib
17:33:27 <alpounet> Lokathor: yeah ircbot seems to be lagging a bit behind then :)
17:33:49 <Lokathor> mmm, now to use my user account as my cabal sandbox :P
17:34:04 <alpounet> you really should update your cabal
17:34:07 <Fuuzetsu> why can't you sandbox?
17:34:20 <alpounet> sandboxes make everything more bearable... until you switch to nix, where all the problems are gone =)
17:34:34 <alpounet> "you've got 99 problems but nix ain't one"
17:34:53 <Fuuzetsu> mismatching ABI hashes are one though‚Ä¶
17:35:26 <Lokathor> i'm on debian wheezy, so i'd have to either put in a testing or unstable repo and update, or i'd have to have cabal compile itself (probably not an option, this is a single core 700Mhz machine, Text and Parsec took like an hour to install jsut on their own)
17:35:55 <alpounet> uh
17:35:59 <Lokathor> but even if cabal updates itself, then my repo based files and my actual files would be out of sync, which is itself a mortal sin
17:36:01 <Fuuzetsu> you should use a distro with binary caches if you're on 700Mhz
17:36:15 <Lokathor> yeah debian has binaries for all this stuff
17:36:38 <Fuuzetsu> get on unstable?
17:36:58 <Lokathor> ...well i could...
17:37:08 <Fuuzetsu> oh, but then you'll be mixing package manager with user packages if you want to use them
17:37:27 <Lokathor> yeah right now i just wanna mess with apt-get as little as possible
17:37:36 <Fuuzetsu> I hear alpounet has the answer
17:37:49 <Lokathor> nix?
17:37:57 <Fuuzetsu> perhaps!
17:38:06 <tac> So they are just like binary trees, but flexible in the "binary" bit?
17:38:32 <Fuuzetsu> tac: sounds like a description of any tree
17:40:15 <tac> A kid I'm mentoring asked about 2-3 finger trees (he wants to do a research paper on them), and I just want to make sure I'm not totally unsure of what they are.
17:41:15 <Fuuzetsu> sidetrack him into work on ropes and then work on Yi, somehow
17:41:17 <Fuuzetsu> onto*
17:41:38 <tac> surjective*
17:42:23 <dolio> Finger trees are quite different from normal binary trees.
17:42:37 <Lokathor> looks like nix doesn't support windows :(
17:42:41 <dolio> But 2-3 trees are like binary trees where there is flexibility in the number of children.
17:42:48 <tac> gotcha
17:42:59 <tac> and they are self-balancing, if I'm not mistaken, right?
17:42:59 <Fuuzetsu> Lokathor: it is rumoured that it is possible in cygwin but I don't know of anyone trying
17:43:05 <dolio> Which?
17:43:06 <Fuuzetsu> why would you want it on Windows?
17:43:24 <tac> 2-3 finger trees
17:44:15 <Lokathor> Fuuzetsu: well it says that you can reproduce an envrionment, which is what i'd want. the ability to setup an identical envrionment across windows and linux (well, as closely as possible)
17:44:38 <tac> They have a zipper-y aspect to them, if I'm not mistaken, right? Some part is more in focus for doing operations
17:44:58 <Fuuzetsu> can't help you with anything Windows; you can try asking in #nixos
17:45:27 <dolio> A finger tree is stored in a way that gives easy access to the first and last nodes in the tree.
17:45:30 <dolio> Rather than the root.
17:46:21 <tac> gotcha
17:46:32 <Lokathor> no one can ever help with developing on windows :P Steve Ballmer's dream is broken
17:46:41 <dolio> I think you could have a finger tree that wasn't balanced, but the papers about them maintain them in ways that keep them nice.
17:47:21 <Fuuzetsu> I think it's pointless to try, just dev on Linux and fight it out once you want to deploy
17:47:41 <Fuuzetsu> step #1 to developing on Windows is to ssh somewhere else
17:48:02 <Lokathor> the saddest true story
17:57:17 <bubbles_mission> whois abh
17:59:57 <mseeks> is there something like `(a -> c) -> Either a b -> Either c b`?
18:00:41 <mseeks> like fmap but with Either _ b as the functor
18:00:45 <twob> join #d3.js
18:00:48 <mseeks> not sure how to represent that
18:01:12 <Iceland_jack> @ty Data.Bifunctor.first :: (a -> b) -> Either a c -> Either b c
18:01:13 <lambdabot> (a -> b) -> Either a c -> Either b c
18:01:28 <mseeks> thanks!
18:03:03 <Fuuzetsu> hm, aren't bifunctors going to be in base soon?
18:03:37 <dolio> Yes, I think so.
18:03:39 <benzrf> i certainly hope so
18:03:56 <benzrf> mseeks = meeseeks
18:04:03 <n4x> @type (+++ id)
18:04:04 <lambdabot> (b -> c) -> Either b a -> Either c a
18:04:09 <mseeks> benzrf: yup
18:04:29 <n4x> this sounds like a cool version which is in base ^ :P
18:04:50 <mseeks> cool!
18:05:12 <Fuuzetsu> but you end up with something ugly like (f +++ id) foo
18:05:40 <n4x> then use "left"?
18:05:46 <Fuuzetsu> :t left
18:05:47 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
18:05:49 <noob2b> WHOIS abh
18:06:04 <Fuuzetsu> much better
18:06:12 <mseeks> are all functions also instances of arrow?
18:06:28 <Fuuzetsu> (->) is instance of Arrow
18:06:50 * hackagebot scalpel 0.1.1 - A high level web scraping library for Haskell.  http://hackage.haskell.org/package/scalpel-0.1.1 (fimad)
18:06:52 <mseeks> so yes
18:07:36 <mseeks> because of currying
18:12:18 <Lokathor> oh man, cmdargs didn't install properly because my cabal is too old i think
18:12:42 <Lokathor> it said: Template Haskell bracket illegal in a stage-1 compiler 'cmdArgs#
18:12:50 <Lokathor> er, my ghc is too old i guess i mean
18:13:09 <fizruk> @paste
18:13:09 <lambdabot> Haskell pastebin: http://lpaste.net/
18:15:01 <Lokathor> http://lpaste.net/118601
18:15:32 <Lokathor> every other file up to that point worked. also, simpleirc worked, which was the real winner
18:18:01 <mseeks> inside a do block of `ErrorT String IO Int`, if something returns a value `IO (Either SomeException Int)`, is it possible to lift that into the monad without case matching?
18:19:22 <Lokathor> oh, i don't have ghci, so i guess it can't do template haskell?
18:27:10 <mseeks> also, what's the reason for naming monad unwrapping functions "run*"?
18:27:58 <mseeks> it makes sense for things like State, Reader, Writer because "stuff" runs when you do runState m s
18:28:00 <Fuuzetsu> just convention I think, you compose with all those binds so in the end you run it all to get a result out
18:28:38 <mseeks> but for something like MaybeT, runMaybeT is literally just removing the MaybeT wrapper without "doing anything" in the monad and it seems weird to me
18:30:37 <mseeks> and when I see something like (runReaderT (runErrorT ...) r) it makes me pause for a second because errors might be thrown in runReaderT, and it seems like doing runErrorT first somehow finishes all the error-related computation
18:31:37 <glguy> They are all unwrappers
18:31:49 <glguy> Maybe isn't different in that respect
18:33:13 <mseeks> you're right and it makes sense; I guess i just have to get used to it
18:36:43 <zq> what open world structures does haskell have besides type classes?
18:37:57 <Fuuzetsu> class/family instances are the only parasites you can't hide properly I believe
18:38:40 <zq> that's a strange way to put it. could you explain a bit on how hiding ties to open world?
18:39:21 <Fuuzetsu> depends on what you mean by open world; I'm thinking you mean things that once defined somewhere then ominously are somehow accessible from every place in the program
18:39:41 <hpc> i think it was open as in open/closed sets
18:39:51 <zq> more like open-ended instances
18:40:11 <Fuuzetsu> ah, a different question but I think the answer is the same ;)
18:40:18 <hpc> hiding and openness are related, but tangentally to the question
18:40:35 <zq> my curiosity is known to pivot at 90-degree angles
18:40:37 <hpc> class/family instances i believe are the only things that are open
18:40:55 <zq> perfect hiding means not open
18:41:04 <zq> can't you hide it by simply not exporting?
18:41:11 <hpc> no
18:41:14 <Fuuzetsu> you can't not export an instance, sadly
18:41:20 <hpc> to give an example
18:41:22 <zq> or only exporting the type class name but not its members
18:41:35 <hpc> class Foo x where foo :: Int -- a terribly useless class
18:41:42 <mseeks> when you use enums (`data MyError = ErrorA | ErrorB`) but you want to be able to convert the errors to strings for display, what's the convention?
18:41:50 <hpc> you can define instance Foo Bool where foo = 2, in one module
18:41:52 <mseeks> implement Show for MyError?
18:42:01 <hpc> and you can define a separate instance where foo = 3 in another
18:42:20 <Fuuzetsu> mseeks: soon there will be a new method in Exception just for this purpose; currently people abuse Show
18:42:29 <Fuuzetsu> I encourage you define a separate pretty-printer
18:42:32 <zq> hpc: so, module HasClass (Foo()) where ...
18:42:36 <hpc> but if you import both of them at the same time, the instances overlap obviously
18:42:42 <mseeks> Fuuzetsu: thanks!
18:42:57 <hpc> if you import them separately
18:43:11 <hpc> say, have module Foo import 2 and module Bar import 3
18:43:14 <hpc> do their separate things
18:43:22 <hpc> then module Quux where import Foo; import Bar
18:43:26 <hpc> it's still very confusing
18:43:37 <hpc> and bad for reasoning about code
18:43:48 <hpc> (and probably theoretical reasons i wouldn't be able to explain properly)
18:44:02 <hpc> so there's a global list of instances
18:44:08 <hpc> and you can't ever hide them when you import
18:44:12 <hpc> if you did import Foo ()
18:44:17 <hpc> you're always getting that 2 instance
18:45:14 <zq> ocaml modules suffer the same
18:45:19 <zq> they're equivalent
18:45:22 <zq> they have to
18:45:42 <mseeks> another question -- i'm writing a program which reads some config and command-line arguments, does stuff in `ErrorT SomeError (ReaderT SomeConfig IO)`, and prints the result
18:46:49 <mseeks> I'm trying to figure out how to cleanly print error messages which may happen in reading config/arguments or in the body
18:47:09 <Fuuzetsu> maybe you want writer too?
18:47:33 <Welkin> :t trace
18:47:46 <Lokathor> :t zipWith
18:47:46 <Welkin> try using Debug.trace
18:48:04 <Fuuzetsu> I think he wants it for general purpose reporting, not as debug
18:48:05 <mseeks> well by error I mean quit the program and print the error -- not for debugging purposes
18:48:11 <Lokathor> oh no did lambdabot die?
18:48:15 <Welkin> okay
18:48:20 <zq> Welkin: i think he means reporting config errors for non-debugging purposes
18:49:10 <mseeks> right, I'd want to run something in ErrorT which gives back an IO ()
18:49:30 <mseeks> because ErrorT allows short-circuiting
18:52:10 <mseeks> oh I figured itout
18:58:43 <mseeks> by the way, is there any way to lift, for example, `Either String Int` into `EitherT String IO Int`?
18:59:29 <mseeks> I think applying return would just give `EitherT String IO (Either String Int)` which is too many Either's
18:59:46 <Hijiri> :t _1
18:59:55 <Cale> mseeks: hoistEither
19:00:06 <Hijiri> :t hi lambdabot
19:00:17 <Hijiri> deadbot?
19:00:21 <mseeks> awesome, thanks!
19:00:31 <Cale> Which is the same as EitherT . return
19:01:10 <mseeks> cool, didn't realize EitherT was available as a data constructor
19:01:53 <Cale> either left right  would also work :)
19:02:13 <mseeks> also is the only way to turn `IO (Either String Int)` into `EitherT String IO Int` just applying EitherT?
19:04:32 <benzrf> mseeks: you could also fmap (fmap (+1)) and THEN apply EitherT
19:04:33 <benzrf> :)
19:05:03 <mseeks> that's true
19:06:19 <benzrf> but
19:06:19 <Cale> But pretty much, yes.
19:06:42 <benzrf> if you are asking for more generally "m (Either a b) -> EitherT a m b"
19:06:52 <benzrf> im fairly sure EitherT is the only thing that meets the criteria
19:07:19 <mseeks> I see, thanks
19:24:15 <tolland> when it says "Cabal library version -any >=1.10 but no" what is it referring to by "cabal library"
19:24:29 <tolland> I mean.. which package is that?
19:25:23 <tolland> (I am on fedora and I have ghc-Cabal.x86_64 : Haskell Cabal library Version     : 1.16.0)
19:27:20 <pavonia> The package is called Cabal, it's a Haskell package
19:31:51 * hackagebot autonix-deps 0.1.0.1 - Library for Nix expression dependency generation  http://hackage.haskell.org/package/autonix-deps-0.1.0.1 (ThomasTuegel)
19:32:28 <k3DW> Would someone be able to help me out with a problem I'm having with my code? It's probably just that I don't know what I'm doing
19:32:45 <Fuuzetsu> paste the code somewhere and say what the problem is
19:34:45 <k3DW> I haven't written it out, just into the GHCI, I was testing things. Basically it tells me that 1000000 * 1.0e-6 is a valid expression, but when I have 2 other expressions that evaluate to those 2 numbers and multiply them together I'm met with an error. I could type it out if really needed
19:35:22 <tolland> pavonia: ok gotcha Thnx!
19:35:48 <Fuuzetsu> paste the session and the error somewhere
19:35:56 <k3DW> ok sure
19:36:01 <k3DW> I'll be a minute or so
19:39:32 <geekosaur> k3DW, you do know that all numeric literals in Haskell are polymorphic? but if you have expressions and one produces an Int and one produces a Double then you cannot multiply them directly; you need to convert one of them to the type of the other
19:39:54 <k3DW> No, actually I didn't know that
19:40:04 <_um> geekosaur: Is there something like Data.String.Conversions for numbers?
19:40:06 <geekosaur> :t 1.0e-6
19:40:14 <k3DW> I'm fairly new to Haskell, in fact I started learning a few days ago
19:40:18 <Fuuzetsu> bot is dead
19:40:18 <k3DW> What does that do?
19:40:23 <geekosaur> bah
19:40:48 <_um> k3DW: That should print out the type of the expression.
19:41:02 <geekosaur> _um, you can use read and show but there are also conversion functions. in this case fromIntegral on the Int (or more likely Integer) seems appropriate
19:41:03 <_um> k3DW: You can try it in ghci `:t [expression]`
19:42:10 <k3DW> I apologize for my ignorance on this matter currently. Let me just ask a few questions: Is there a difference between Int and Integer? What's an Integral? I keep seeing that everywhere
19:42:23 <vanila> Int is a finite type, Integer is unbounded
19:42:35 <geekosaur> Int is a machine word and has a bounded size. Integer uses gmp to produce arbitrary sized integers
19:43:02 <geekosaur> Integral is a type class which is more or less "things that look like integers of some variety"
19:43:54 <geekosaur> anyway a numeric literal 1000000 would be typed as Num a => a, so it can become any numeric type. 1.0e-6 will be Fractional a => a, and defaulting will make it a Doube
19:43:57 <geekosaur> *Double
19:44:12 <k3DW> Hmm, I don't think that helps. What is finite vs unbounded? What's gmp? What's a type class? As I said, I'm incredibly new to this. Although I do have experience in Java, but never a functional language before
19:44:30 <geekosaur> gmp is the GNU Multiple Precision math library
19:44:42 <k3DW> If you want to direct me to a different place to learn all this, go right ahead, I don't want to take up too much of your time
19:44:44 <geekosaur> we only use the arbitrary size integer support
19:45:01 <Iceland_jack> k3DW: You can think of Integral as {Int, Integer, Word8, Int8, Word16, ...} so functions like 'mod' have any of the following types:
19:45:01 <Iceland_jack>     mod :: Int     -> Int     -> Int
19:45:01 <Iceland_jack>     mod :: Integer -> Integer -> Integer
19:45:01 <Iceland_jack>     mod :: Word8   -> Word8   -> Word8 ...
19:45:11 <geekosaur> bounded: a machine word is typically 32 or 64 bits, so the size of a number storable in one is limited
19:45:11 <vanila> k3DW, well you know how numbers are represented as binary in a computer?
19:45:17 <k3DW> So essentially numbers in Haskell can be as big as required?
19:45:20 <k3DW> Yes, yes
19:45:28 <vanila> Int has only 64 bits in it, say
19:45:39 <vanila> but Integer grows to accomodate
19:45:42 <geekosaur> Prelude> maxBound :: Int
19:45:42 <geekosaur> 9223372036854775807
19:45:52 <k3DW> Oh ok, I get it
19:45:55 <geekosaur> that's on a 64-bit machine
19:45:56 <Iceland_jack> k3DW: Integer has arbitray-precision so it can be as big as your computer allows
19:46:07 <Iceland_jack> *arbitrary
19:46:08 <k3DW> so Integer and Int are different?
19:46:12 <geekosaur> yes
19:46:19 <Iceland_jack> Yes, Int is not arbitrary-precision
19:46:25 <k3DW> Why are they so similarly named?
19:46:36 <geekosaur> historical reasons
19:46:42 <k3DW> Hmm ok
19:46:48 <geekosaur> Int corresponds to C's (int)
19:46:59 <geekosaur> Integer is supposed to correspond to the mathematical integers, which are not bounded
19:47:01 <k3DW> I'm not familiar with C, but I know Java
19:47:13 <k3DW> Oh that makes sense
19:47:16 <Fuuzetsu> IIRC Java's int primitive is also C's
19:47:24 <geekosaur> Java has the same (int) type (and Int which is the same but an object instead of a [virtual] machine word)
19:47:31 <k3DW> it's a 32 bit signed integer
19:47:34 <k3DW> (int) is
19:47:45 <k3DW> not 64
19:48:04 <geekosaur> anyway, being an actual machine type, Int is much faster than Integer
19:48:14 <k3DW> Of course, makes sense
19:48:18 <geekosaur> but prone to errors because machine words don't typically catch overflow
19:48:33 <k3DW> huh
19:49:03 <k3DW> Another dumb question (they just keep coming) what do " -> " and " =>
19:49:09 <k3DW> " do?
19:49:13 <k3DW> I pressed enter too early
19:49:15 <geekosaur> Prelude> (maxBound :: Int) + 1
19:49:16 <geekosaur> -9223372036854775808
19:49:27 <k3DW> Ahh ok, so it's 64 bit
19:49:41 <k3DW> but signed..?
19:49:44 <Fuuzetsu> they are syntax, are you following any books or guides?
19:49:44 <k3DW> so it's 65 bit?
19:49:45 <geekosaur> yes, as I said earlier when I pasted the original maxBound one
19:49:53 <MP2E> k3DW: 'Int' is an example of a type. 'Int -> Int' is an example of a function taking an Int and returning an Int as the result
19:50:11 <k3DW> Ok, but what does it mean when there are two arrows?
19:50:11 <geekosaur> so Int is 64 bits on my machine. Int is always signed. there is a corresponding Word type which is unsigned
19:50:17 <mseeks> when would you use ErrorT vs EitherT?
19:50:21 <MP2E> k3DW: you can also do 'Int -> Int -> Int' which means this function takes 2 Ints and returns one Int
19:50:37 <k3DW> Oh, then I've been reading things really wrong
19:50:38 <mseeks> also I noticed there's no ErrorT data constructor while there is for EitherT
19:50:43 <Iceland_jack>     (+) :: Int -> Int -> Int
19:50:44 <geekosaur> -> is a function arrow. instead of saying a function type is, say, int foo(int). we say it's Int -> Int
19:51:01 <k3DW> I assumed it meant that it takes in an Int, returns an Int, and then returns another Int from that second Int
19:51:07 <mseeks> never mind there might be
19:51:37 <geekosaur> this is because of partial application, where we can build a function that only gets one of its parameters; (Int -> Int -> Int) is the same as (Int -> (Int -> Int)), so (1+) is of type (Int -> Int) and when provided with an argument tt adds 1 to it
19:51:38 <MP2E> k3DW: another way to read it is 'Int -> (Int -> Int)' aka this is a function taking an Int, returning a function that takes an Int which finally returns the result, Int.
19:52:06 <k3DW> That makes more sense actually MP2E and geekosaur
19:52:07 <Fuuzetsu> I suggest not using operator sections when explaining these things
19:52:28 <k3DW> What about the =>?
19:52:32 <geekosaur> the => arrow is different, it relates to typeclasses. they are distinct from types; you cannot have something of "type" Integral, but you can have a type Integral a => a
19:52:43 <geekosaur> or Integral a => a -> a -> a
19:52:46 <k3DW> And what does that mean?
19:52:53 <k3DW> "a" isn't a type, is it?
19:53:18 <geekosaur> which means that. given some type a (a type variable here) that is an instance of Integral, we have the type of a function that takes two a-s and produces an a
19:53:44 <geekosaur> in ghci, try:    :t (+)
19:54:08 <geekosaur> or more to the point for your earlier confusion, use (*) instead of (+)
19:54:18 <k3DW> An instance of Integral? Is a typeclass an actual "class"
19:54:25 <k3DW> ok I'll do that :)
19:54:28 <Fuuzetsu> there are no Java classes
19:54:33 <k3DW> I know that
19:54:33 <geekosaur> (the parentheses turn an operator into a normal function. you can, instead of saying 2 + 3, say (+) 2 3
19:54:35 <geekosaur> )
19:54:44 <Fuuzetsu> if anything, type classes are closer to interfaces though don't take this to heart
19:54:49 <k3DW> Ahh ok, that's cool geek :)
19:55:11 <k3DW> So what exactly IS a typeclass? Is it a superset of types?
19:55:15 <geekosaur> so, typeclasses have some similarity to OO classes, more of a similarity to Java interfaces, but are actually very different and trying to treat them as standard OO is a common way to lead a programmer to tears
19:55:34 <k3DW> I could see that happening
19:55:57 <k3DW> I've also noticed that there are a ridiculous number of types in this language
19:56:09 <geekosaur> sort of, yes. a typeclass comes with a number of methods; to make a type an instance of a typeclass you provide definitions of its methods.
19:56:15 <geekosaur> specific to that type
19:56:45 <k3DW> All of this isn't quite congealing in my brain, but I'll try some things out and see if I get it all
19:56:53 <k3DW> It might take a while, it's a lot different from Java
19:56:53 <geekosaur> this allows us to have operators like (+) or (==) that can operate on many different types, similar to overloading
19:57:08 <k3DW> Ahh ok
19:57:28 <k3DW> Which types are contained within the Num typeclass?
19:57:42 <geekosaur> http://www.seas.upenn.edu/~cis194/fall14/lectures.html
19:57:42 <k3DW> I should look that up, don't even answer
19:57:54 <k3DW> Thank you
19:57:55 <Fuuzetsu> try :i Num in GHCi, it will tell you which ones it knows about at that moment
19:57:57 <MP2E> anything that is defined as an instance of Num, since typeclasses are open in Haskell you could make a type yourself that is an instance of Num
19:58:08 <geekosaur> re Num: http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/haskell2010-1.1.1.0/Prelude.html#t:Num
19:58:15 <k3DW> Oh really? That must be why there are so many types
19:58:25 <Fuuzetsu> yes, we like types, make tons of them
19:58:38 <k3DW> It makes learning really confusing! ;)
19:58:46 <k3DW> I'll persist though
19:59:07 <Fuuzetsu> if you follow some guide or book it should take you through the mainly used ones and once you know what's what it should be a lot easier
19:59:17 <geekosaur> Haskell lets you encode quite a lot of information in types (and various ghc extensions let you encode even more) and Haskell's strict type checking can turn many classes of errors into compile-time type errors if you design your types properly
19:59:37 <k3DW> Hmm
19:59:51 <k3DW> I don't think I'm that advanced yet though
19:59:58 <kazagistar> k3DW: unlike Java, C#, etc, you can have all the parts of the abstraction in different places: typeclass definition in one file, data type in another, and implementation in a third, each compiled separate
20:00:14 <geekosaur> the cis194 URL I sent a couple of minutes back is a decent open introductory Haskell course
20:00:17 <k3DW> That's confusing, but very interesting
20:00:27 <k3DW> @kazagistar ^
20:00:40 <k3DW> I'll check it out geek, thank you
20:01:13 <geekosaur> we used to recommend other introductory materials but we found people didn't really pick up important concepts from them very well
20:01:27 <kazagistar> k3DW: it means that if some library consumes an interface, and another library provides some kind of data structure, you can hook the two up yourself without modifying the others
20:01:29 <geekosaur> and without the concepts, Haskell is just really confusing
20:01:53 <Fuuzetsu> my LYAH radar is picking something up
20:02:16 <k3DW> Yeah, I don't have too many functional concepts as of yet, other than normal calculus, which isn't programming
20:02:49 <MP2E> I learned through LYAH, but to be fair I've also taught myself a few other programming languages, and I read a few other books concurrently. Also I was asking questions here and experimenting with GHC/GHCi a *lot*
20:02:57 <MP2E> so it wasn't really all LYAH
20:03:11 <k3DW> I started with that, and I'm still doing it
20:03:16 <MP2E> more like, that was a push in the right direction and then I figured it out through hacking out concepts and asking questions :P
20:03:20 <geekosaur> I never did look very closely at LYAH
20:03:31 <k3DW> but I decided I wanted to get side tracked and do a few Project Euler problems
20:03:41 <geekosaur> I used the old "Gentle Introduction" but I'd already been exposed to J and SML
20:03:50 <geekosaur> (among *many* other languages...)
20:03:53 <k3DW> so here I am because I have a problem with my function to reverse an integer
20:04:14 <kazagistar> k3DW: "reverse an integer"?
20:04:14 <k3DW> This is only my second language
20:04:28 <k3DW> yes, as in 1285 becomes 5821
20:04:29 <geekosaur> Project Euler is actually one of the worse ways to learn Haskell, because it isn't about teaching programming, it's about teaching mathematical thinking
20:04:36 <k3DW> true, ture
20:04:39 <k3DW> *true
20:04:40 <kazagistar> k3DW: what was your previous one?
20:04:45 <k3DW> Java
20:04:45 <geekosaur> and mathematical teaching is much less useful to understanding Haskell than many people assume
20:04:56 <k3DW> oh, I thought it was very useful
20:04:57 <geekosaur> er, mathematical thinking
20:05:02 <k3DW> since it looks very similar to math itself
20:05:42 <MP2E> I mean, at the higher levels perhaps you could take a concept from abstract math and apply it to Haskell, but the point is that you don't need to know math to use the useful abstractions we've taken from math already
20:05:45 <geekosaur> some aspects of it can be helpful, but not much for general programming. it can be useful for understanding Haskell at a very deep level such as you'd want for, say, designing sensible Haskell extensions
20:06:16 <geekosaur> or useful new general typeclasses
20:06:16 <kazagistar> k3DW: I would say that often haskell is helps people get into math more then the other way around
20:06:20 <k3DW> Actually here's an important question: can everything be done in functional languages that can be done in OO languages?
20:06:25 <k3DW> Oh
20:06:41 <k3DW> I wanted to learn a functional language since I'm into math ;)
20:06:46 <geekosaur> (you need to know a fair amount of number theory to *design* monoids, but none at all to *use* them)
20:07:00 <k3DW> Sorry, what are monoids?
20:07:16 <Fuuzetsu> a cool thing you'll get to use later ;)
20:07:23 <k3DW> Sounds like fun!
20:07:28 <MP2E> typeclass in Haskell, also a concept borrowed from Math :P
20:07:43 <k3DW> This is really exciting actually. I'm glad I found this channel
20:07:48 <geekosaur> so, a monoid consists of some kind of "zero element" and a function that can combine elements.
20:07:52 <kazagistar> k3DW: http://en.wikipedia.org/wiki/Monoid :P
20:07:56 <MP2E> as for whether Haskell can be used to make anything Java can, they're both turing complete so yes
20:08:05 <kazagistar> "an algebraic structure with a single associative binary operation and an identity element."
20:08:11 <geekosaur> (addition and multiplication are monoids for numbers. for lists, the empty list and concatenation comprise a monoid
20:08:36 <geekosaur> it's a very general concept, and a remarkably useful one in programming; but you don't need to know the fancy theory to use them
20:08:41 <k3DW> Yeah I assumed so, but I wasn't sure, just because I've had so much trouble so far with this language
20:08:53 <k3DW> Sorry, that was to a comment above, I just took a long time to type
20:08:54 <geekosaur> to come up with them you need to get into number theory
20:09:18 <MP2E> There's a common misconception I see around non FP types that Haskell can't be used for anything useful :) Not sure where it originates
20:09:31 <kazagistar> k3DW: there are some subtle differences in how easy certain things are to express and extend between java and haskell, and the style of programming used is often very very different
20:09:31 <MP2E> I guess a misunderstanding of purely functional?
20:09:33 <Fuuzetsu> non FP non-types
20:09:37 <MP2E> hehe
20:09:54 <k3DW> So how exactly can it be done, though? I genuinely cannot think of a way to store values for later use without mutable datatypes
20:10:00 <geekosaur> well, set theory
20:10:05 <k3DW> Although obviously there's a way
20:10:12 <geekosaur> you pass intermediates around instead of storing them
20:10:16 <kazagistar> Haskell is 1 data type away from being useless, remove IO and you got nothing :P
20:10:27 <k3DW> what's IO?
20:10:30 <geekosaur> there are various things that help you do this automatically in one way or another
20:10:54 <kazagistar> :t print
20:11:06 <k3DW> I mean I did figure out a way from doing the first 3 Project Euler problems, but it seemed like too much work to do and very complex
20:11:21 <kazagistar> (wait, is lambdabot dead?)
20:11:26 <geekosaur> yes, sadly
20:11:37 <k3DW> I just didn't save anything and did everything with recursion
20:11:54 <k3DW> Which I guess is a way to do things, but I can't see how that can extend to complicated programs
20:12:00 <MP2E> k3DW: Mutability can still be encoded in Haskell :P It just has to be in opaque 'values' that Haskell itself does not execute (but the runtime at compilation does)
20:12:15 <k3DW> Can you explain further? I like this ;)
20:12:34 <Fuuzetsu> sure is getting ahead here
20:12:54 <k3DW> I jump all over the place, I learn things in fragments, it's awful at times
20:13:17 <kazagistar> k3DW: if you go to the "monads" part of LYAH, it will cover that there, its is quite a significant subject
20:13:18 <Fuuzetsu> check out the link geekosaur posted, it should become how things are done pretty quickly
20:13:37 <k3DW> Yeah I should probably do that instead of asking complicated questions
20:14:15 <k3DW> You can't start you learn about anything until you know that it exists in the first place, which I haven't really done too much yet
20:14:26 <k3DW> *"to" instead of "you"
20:15:18 <benzrf> k3DW: do cis194
20:15:50 <benzrf> it's good!
20:15:51 <k3DW> I have it opened in another tab, I'll look at it soon
20:15:57 <benzrf> k3DW: stop jumping around!!!!!
20:16:07 <benzrf> it's terrible for you
20:16:15 <Fuuzetsu> pulling out those exclamation marks out of the bag
20:16:38 <k3DW> It's the same way I learned Java
20:17:03 <k3DW> Started with some Youtube videos then went into Project Euler, then asked around some things that I had no idea existed, etc etc
20:17:38 <k3DW> And just last week I coded a Rubik's cube, which blows my mind I did, since I'm relatively awful
20:17:38 <kazagistar> I started haskell with this youtube video: https://www.youtube.com/watch?v=RqvCNb7fKsg :P
20:17:55 <k3DW> Yeah I saw that video, I laughed the whole time
20:18:09 <k3DW> Hfeflflfo :P
20:18:49 <kazagistar> "It has constants, which are like variables, only you cannot change them"... he has a great, dry humor
20:19:00 <systemfault> I'm still wondering if it's possible to do anything "complex" in Haskell without a background in proof/type/category theory :( I know the basics but I still can't follow most of the discussions on this channel.
20:19:23 <Fuuzetsu> yes, it is, code more
20:19:25 <k3DW> I can't follow almost everything I read on this language
20:19:39 <Fuuzetsu> come hack for some project of mine, I could use extra slaves^Wcontributors
20:19:43 <k3DW> Which makes sense, since I got to the 2nd second in LYAH before leaving it and coding on my own...
20:19:50 <k3DW> *section
20:19:51 <kadoban> systemfault: You don't have to be able to follow pretty much anything in this channel to be able to use haskell, I've found.
20:20:58 <systemfault> Also, one thing that still confuses me... it seems that nobody uses "Haskell", it's always "Haskell + a million GHC extensions"
20:21:05 <benzrf> systemfault: it's cause:
20:21:13 <systemfault> But seriously.. I LOVE the language.
20:21:22 <benzrf> > (\f -> (f ["foo"], f "foo")) id
20:21:30 <benzrf> ...crud
20:21:35 <MP2E> damnit lambdabot :P
20:21:41 <benzrf> systemfault: anyway that is not well-typed in vanilla Haskellfant
20:21:45 <benzrf> u wanna put up with that ?!
20:21:59 <Fuuzetsu> benzrf: didn't even pick a cool extension
20:22:08 <benzrf> rank n types is the best extn
20:22:14 <benzrf> its that simple
20:22:18 <MP2E> yeah rank n polymorphism is pretty cool :P
20:22:20 <systemfault> :D
20:22:27 <benzrf> well ok it ties with GADTs
20:22:32 <benzrf> maybe GADTs win. idk
20:22:34 <benzrf> both pls
20:22:55 <k3DW> If everyone uses extensions, why aren't these integrated into the language itself? Or at least very very popular ones
20:22:58 <systemfault> I _just_ started looking at GADTs, scary but powerful stuff
20:23:07 <MP2E> k3DW: they are
20:23:10 <MP2E> just the thing is
20:23:17 <MP2E> it's been since 2010 since we had a language standard :P
20:23:34 <benzrf> MP2E: more like its been since 1998
20:23:38 <k3DW> Oh yeah, that's true
20:23:39 <benzrf> haskell 2010 is barely a movement
20:23:39 <MP2E> also in 2010 I think there were more compilers contributing to it? So GHC couldn't just push GHC only extensions in there
20:23:47 <MP2E> yeah
20:23:57 <MP2E> that's fair to say, it didn't rehaul much
20:24:01 <MP2E> just a bit of minor changes
20:24:07 <systemfault> BTW, totally unrelated but.. has haskell.org been incredibly slow for anyone for the last 2-3 weeks
20:24:13 <k3DW> I started to read the 2010 publication of the language whachamacallit
20:24:16 <systemfault> (It has been for me)
20:24:19 <hiptobecubic> systemfault, they know.
20:24:27 <k3DW> It all went way over my head, but I look forward to the day I understand it xD
20:24:55 <hiptobecubic> systemfault, it was on /r/haskell today as well. Essentially a devops error resulted in the wiki and DB ending up in different physical datacenters. Lag ensues.
20:25:17 <kazagistar> k3DW: I never could read language standards... it seems they are more intended to be a reference for implementing the language then a guide to learn the language
20:25:27 <systemfault> hiptobecubic: Ha! Well, I hope they'll fix it soon...ish
20:25:45 <kadoban> kazagistar: Haskell's is /much/ more readable than the usual.
20:25:58 <k3DW> True, kadoban
20:26:10 <k3DW> Try reading the files on the Oracle website for Java
20:26:13 <k3DW> unintelligable
20:26:18 <k3DW> at least for me
20:26:26 <hiptobecubic> k3DW, garbage in, garbage out :)
20:26:31 <MP2E> I have a friend who likes to write compilers, he became interested in Haskell solely because the Language Standard was so small and clear :P
20:26:33 <k3DW> :P
20:26:47 <k3DW> It is very clear comparatively, I'm just very new
20:27:02 <k3DW> And I should stop talking about how new I am otherwise people will start calling me attention-seeking
20:27:23 <Fuuzetsu> less chatting more looking at the resources ;)
20:27:34 <k3DW> Ugh but that takes WORK ;)
20:27:50 <k3DW> Ok sure, I'll do that
20:28:02 <MP2E> wait for Haskell 2020, then the compiler will right it for you (I jest of course)
20:28:09 <MP2E> also s/right/write
20:28:19 <k3DW> I'll assume that you guys are all on Reddit under the same username...? Would I be right in assuming?
20:28:21 <k3DW> Just curious
20:28:30 <Fuuzetsu> I hope by 2030 GHC can optimise everything to constant time and we just wait for IO
20:29:50 <hiptobecubic> you can already do that. Just write your entire program at the type level :)
20:30:05 <Fuuzetsu> maybe it will compile by 2030
20:30:19 <Lokathor> I'm on reddit under the same username, but i have like 2 posts ever
20:30:24 <k3DW> Ahh ok
20:30:35 <MP2E> my reddit is rezb1t because someone took MP2E
20:30:43 <MP2E> I have no idea why or how because that name is pretty much never taken
20:30:46 <MP2E> had it for a decade now
20:30:50 <k3DW> such an odd thing to have already been taken
20:31:03 <k3DW> maybe it was you accidentally and you didn't know
20:31:08 <MP2E> haha maybe
20:31:19 <MP2E> my memory isn't amazing so i wouldn't be too surprised
20:31:21 <kadoban> I could never get into reddit. The commenting style is too weird.
20:31:31 <trap_exit> is there a way to hijmack the >>= and >> of Parsec Monad? so that it _automatically_ consumes "spaces" ?
20:31:46 <hiptobecubic> reddit is great as long as you don't ever look at the default front page
20:31:46 <MP2E> then it wouldn't follow monad laws though
20:31:48 <k3DW> The commenting style is what I love about it
20:31:48 <Fuuzetsu> let (>>=) = ‚Ä¶
20:31:56 <MP2E> m >>= id =/= m
20:31:58 <MP2E> if spaces are removed
20:32:14 <MP2E> er return *
20:32:17 <Fuuzetsu> that wouldn't typecheck ;)
20:32:19 <MP2E> right :P
20:32:34 <kadoban> trap_exit: Why don't you just write wrappers that do that?
20:32:56 <trap_exit> kadoban: how?
20:33:04 <trap_exit> literrally about 1/3rd of my Parsec code is "spaces"
20:33:06 <trap_exit> when measured in lines
20:33:25 <trap_exit> it's shit like a <- b; spaces; c <- some other parse; spaces; d <- some othe r parse; return $ Constructor a c d
20:33:30 <Fuuzetsu> define yourself some better combinators
20:33:51 <Fuuzetsu> a <- b <* spaces
20:33:53 <Fuuzetsu> bam, one line saved
20:34:02 <hiptobecubic> lol
20:34:14 <hiptobecubic> errors get worse though, no?
20:34:18 <_um> could I get a confirmation on this: I was just advised that `main :: IO ()` is not a function. That functions are only of the form `a -> b`. Is this correct? If so, what do we call things like main?
20:34:30 <Fuuzetsu> dunno, I use attoparsec so I'm always shafted on errors anyway
20:34:32 <hiptobecubic> values?
20:34:33 <MP2E> _um: This is correct, I call them IO actions
20:34:38 <ReinH> trap_exit: sounds like you need a "token" parser
20:34:40 <MP2E> values would also work
20:34:52 <kadoban> trap_exit: Well, it wouldn't work in do notation, so maybe that's not what you want.
20:34:54 <ReinH> basically token p = p <* spaces
20:34:57 <_um> Thanks.
20:35:17 <Fuuzetsu> it would if you use rebindable do
20:35:21 <trap_exit> ReinH, kadoban: thanks
20:35:34 <trap_exit> Fuuzetsu: when you switch careers from haskell to standup, let me know
20:35:39 <Fuuzetsu> RebindableSyntax*
20:35:48 <MP2E> heh
20:35:51 <ReinH> trap_exit: look at how the token-based combinators in the parsers library work
20:36:31 <ReinH> trap_exit: the idea is to always consume any whitespace so that the next parse starts on a non-whitespace character
20:36:33 <trap_exit> ReinH: I thought the whole point of parsec, or atleast one of it, is that "there's no lexing vs parsing - it's all one stage"
20:37:15 <Lokathor> _um, the main value in haskell is called the main function less because it's a function (actually it's a value) and more because it's called the main function (or method) in other languages
20:37:23 <ReinH> Not sure about that, but it doesn't really change my point anyway...
20:37:37 <_um> Lokathor: I see. Thank you.
20:38:06 <Fuuzetsu> I want to write some code ;(
20:38:18 <Lokathor> _um, honestly, before you brought it up just now, i never even thought about it >_<
20:38:31 <Fuuzetsu> my GitHub is crying
20:38:56 <_um> Lokathor: I could have sword I read somewhere that values are to be thought of as functions which take no arguments and return themselves...
20:38:56 <MP2E> lol
20:39:24 <trap_exit> ReinH: this idea of "consume all the white space after it is intruiging"
20:39:30 <MP2E> _um: http://conal.net/blog/posts/everything-is-a-function-in-haskell a good read on this topic!
20:39:35 <MP2E> it's a common misconception :)
20:39:35 <Welkin> how is it not a function that takes no arguments?
20:39:35 <_um> Lokathor: But I can't remember where I read that, and it certainly does make sense to just think of them as different.
20:39:54 <Fuuzetsu> this is the 4th time in like 6 hours this came up today
20:39:57 <_um> MP2E: Glad to know that I'm at least not the first to confused on this point.
20:40:09 <MP2E> Welkin: IO is not a function that takes no arguments because Haskell does not evaluate IO. IO is evaluated at runtime 'outside' of Haskell
20:40:25 <_um> Of course IO isn't a function.
20:40:25 <MP2E> also the blog post I just posted goes into the argument more generically :P
20:40:25 <ReinH> trap_exit: check out http://hackage.haskell.org/package/parsers-0.12.1.1/docs/Text-Parser-Token.html
20:40:28 <_um> But main.
20:40:42 <ReinH> trap_exit: the parsers stuff also understands comments
20:40:46 <ReinH> it's really nice
20:40:47 <_um> main "returns" a value of type IO a
20:40:51 <MP2E> _um: but main :: IO ()
20:40:53 <_um> sorry IO ()
20:40:57 <Welkin> what about something like this? gameState :: GameState
20:40:59 <MP2E> no, main is an IO object it doesn't return anything
20:41:00 <_um> I see.
20:41:18 <_um> So it's just value assignment.
20:41:19 <Lokathor> Welkin, i suppose you could call it a function of no arguments, but only in the sense that an Int would also become a function of no arguments, which most people don't really consider to be a function I think
20:42:21 <Fuuzetsu> mixfix in Haskell when
20:43:05 <Lokathor> MP2E, you can give main a type other than IO main actually... as long as it's IO (something) you can compile it. Usually the something is discarded anyway, but i guess runhaskell will print a non-() value at the end or something(?), i read about this just the other day
20:43:17 <Lokathor> seemed bizarre, but i guess it's allowed
20:43:27 <MP2E> Lokathor: still, in Haskell itself that isn't 'returned' :P
20:43:31 <Fuuzetsu> it looks for IO a
20:43:32 <MP2E> it's the runtime handling that
20:43:43 <Lokathor> yeah yeah
20:44:53 <MP2E> Welkin: that's a good question, still mulling it over myself
20:46:27 <kazagistar> calling everything a function is just a less useful definition then calling every definite (->) type a function
20:46:43 <ReinH> The usually definition of a function in haskell is a value of type a -> b for some a and b.
20:46:52 <MP2E> according to conal's blog post I guess 'no' because it has a section that says that the static type system makes it 'obvious' what is a function and what isn't
20:46:55 <MP2E> but what about fibs?
20:47:09 <MP2E> fibs is commonly shown as something to return the infinite list of fibonacci numbers but you don't use it all
20:47:16 <MP2E> and so in that sense it is calculated as needed..
20:47:16 <MP2E> hmm
20:47:31 <Fuuzetsu> how the value comes out is irrelevant
20:47:36 <ReinH> There are contexts where "nullary operation" is used, but it doesn't really add anything to think of values of type a as nullary functions that produce an a.
20:47:37 <MP2E> Ah
20:48:24 <Lokathor> fibs is cheating in haskell because of lazyness
20:48:49 <Lokathor> in any other language, you'd have an object that you'd need to call .getFib(x) on
20:49:06 <MP2E> Right I just considered that :P In any other language it would be a fully evaluated 'infinite' list (provided you could evaluate something infinite)
20:49:15 <MP2E> so it's not really a function anymore by the time it gets used
20:49:29 <Fuuzetsu> many languages offer streams
20:49:29 <MP2E> the value gets used *
20:51:14 <kazagistar> the concept "fully evaluated" isn't really part of the normal haskell semantics anyways... afaik, the standard merely defines "does not contain bottom", and everyone interprets that as fully evaluated, cause otherwise it is really hard?
20:51:24 <kazagistar> (might be totally wrong on that lol)
20:51:48 <enthropy> @hackage deepseq
20:52:15 <MP2E> You can fully evaluate something
20:52:20 <MP2E> deepseq provides that
20:52:21 <kazagistar> deepseq is still defined in terms of seq, right?
20:53:02 <trap_exit> is there a way to make the parsec state be a RWS monad rather than just a state monad?
20:53:32 <enthropy> kazagistar: you could just pattern match to define the instances
20:53:58 <enthropy>  data X = X; instance NFData X where rnf X = ()
20:54:12 <ElderFain> I'm having trouble figuring out how to parse statements, when I see something like ‚Äútake¬†10¬†$¬†iterate¬†(*2)¬†1¬†¬†‚Äù its not clear to me what is being 'applied' to what. I get that $ is a substitue for () so I can see that we call 10 on (iterate(*2)) but how are you supposed to know when the spaces are anotehr statement vs a value being passed into the last statement?
20:54:16 <enthropy> or you could have   rnf x = x `seq` ()
20:54:25 <ElderFain> surely there is a clear rule for how to parse/read them?
20:55:37 <glguy> Elderfain you can ask ghci for the precedence of an operator with :i
20:55:38 <enthropy> ElderFain: (take 10) ((iterate (*2)) 1)
20:56:14 <glguy> Function application binds tighter than operators and is left associative
20:56:56 <vanila> haskell-src-exts is broken!
20:57:05 <kazagistar> ElderFain: Normal function application means { a b c d } -> { (((a b) c) d) }, $ is function application but with a super low precedence, so it "wraps the sides" with parens like { a b $ c d } -> { (a b) (c d) }
20:57:08 <Fuuzetsu> when operators aren't involved, you can safely delete $ in favour of parenthesis stretching from where it was all the way right
20:57:26 <pavonia> vanila: Why do you think so?
20:57:31 <vanila> becaues it is
20:57:39 <Lokathor> i converted a do-notation block into a >>= by hand.
20:57:47 <Lokathor> what an annoying exercise
20:58:25 <ElderFain> enthropy: is that.. idiomatic haskell?
20:58:31 <ElderFain> (its easier for me to mentally parse anyway)
20:58:46 <ElderFain> kazagistar: so thats.. left to right?
20:58:46 <enthropy> no it's not idiomatic to have excess parentheses
20:58:59 <ElderFain> (aren't most imperitive langauges right to left?)
20:59:10 <SrPx> Is there any drawing library similar to processing? I was checking gloss, but it is much less complete than processing (ie, it doesn't have a "blit" function to paste an image in another)
20:59:43 <Lokathor> it has to bind like that so that "max 2 3" does what you'd think. It's actually parsed as ((max 2) 3)
21:00:26 <Lokathor> ElderFain, it's related to why function types have lots of -> in them instead of just one at the end like other languages tend to be
21:00:38 <Cale> Fuuzetsu: Don't forget also the parens extending all the way to the left
21:01:20 <Lokathor> I admit to often having more ( ) then I need instead of using $, but Lisp just sorta makes sense to me...
21:02:16 <kazagistar> ElderFain: different operators can have different associativity directions... but similar semantics to haskell in an imperative language will bind similarly... erm, lemme do an example
21:03:49 <ElderFain> Lokathor: I may have forgotten this (or maybe LYAH has not covered it yet), whats -> ?
21:04:12 <kazagistar> If I write (a)(b)(c)(d) in an imperative language, I'm pretty sure that means "take function a, pass in b, pass c into the result of that, and pass d into the result of that"
21:04:59 <Lokathor> ElderFain -> in a type signature is kinda like "goes to", so when (+) :: Int -> Int -> Int, that means you give it an int, and it becomes a fucntion that takes and int and returns an int, such as (+2), and then when you give it the other int it gives you the answer
21:05:29 <kazagistar> $ is good for chaining, but usually then you can make it . instead with eta reduction (or whatever it is called)
21:05:49 <kazagistar> #hlintwords
21:05:58 <Lokathor> use ghci to do :t (+) and then :t (+2) and then :t (+2) 2 and you can see what's happening
21:06:08 <Cale> Yeah, it's actually too bad that $ is right associative
21:06:14 <Lokathor> sadly, the channel's bot that would show this seems to be down at the moment
21:06:26 <Cale> It would have been much better to make it left associative, along with $!
21:07:08 <Lokathor> Cale, can you give an example? I don't use $ much
21:07:23 <Fuuzetsu> can you give an example where it makes more sense for it to be left assoc
21:07:28 <ElderFain> oh and the reason it becomes a function is so that it can be.. chained again into ?
21:07:51 <Cale> Instead of f $ g $ h $ x, you'd have to write f . g . h $ x, but in exchange, you'd get to remove parens from things like f (g x) (h y) (k z)
21:08:13 <Fuuzetsu> I like f . g . h $ x
21:08:17 <Cale> and instead of doing things like ((f $! x) $! y) $! z, you could write f $! x $! y $! z
21:08:39 <Fuuzetsu> that only holds for $! though
21:08:49 <ElderFain> Lokathor: in your particular example, It looks like its not saying anything different, Int -> Int -> Int, looks like takes int returns int, but you indicate that i guess the middle one, is a function that takes & returns an int ?
21:08:57 <Cale> Well, you'd mix and match with $ for the parameters where you need no additional strictness
21:09:17 <ElderFain> Cale: guess I'm just new to it, thats incredibly painful to read =) I'll solider on
21:09:27 <Cale> e.g. f $ x $! y $ z
21:09:40 <kadoban> ElderFain: It gets /much/ easier to read pretty quickly.
21:09:41 <Cale> If you only want y to be evaluated
21:09:46 <Fuuzetsu> guess I just don't use $! enough to ever get annoyed
21:09:50 <kazagistar> ElderFain: Cale is inventing syntax right now, don't pay too much attention :P
21:09:52 <ElderFain> kadoban: I'm on page 104 of LYAH =p
21:09:58 <Lokathor> ElderFain, (+) will need two Int values eventually passed into it before you get an Int back
21:10:08 <Cale> Well, "inventing"
21:10:08 <ElderFain> which i might add, introduces $ without saying a word about how it works, ahd to go look it up ;p
21:10:24 <shachaf> Cale isn't inventing syntax, just wishing for different definitions within the existing syntax.
21:10:25 <Fuuzetsu> I'm waiting for you proposal on libraries@
21:10:30 <Cale> yeah
21:10:33 <Fuuzetsu> maybe wait for April 1st
21:10:44 <glguy> and isn't even inventing, he's been campaigning for that for years :)
21:10:45 <Cale> Fuuzetsu: Everyone knows I want this already
21:11:00 <Fuuzetsu> guess I wasn't part of that set
21:11:00 <Cale> Yeah, I think I proposed this about a decade ago
21:11:13 <Cale> and I don't think I was the only one :P
21:11:59 <ElderFain> Lokathor: I tried that in ghci, I see what I believe are a bunch of method signatures , like  (+) :: Num a => a -> a -> a, (+2) 2 :: Num a => a
21:12:14 <Cale> I try not to ever make use of the fact that $ is right associative anyway
21:12:17 <ElderFain> Lokathor: guess I have not graduated yet to be able to understand that. I only know the a -> a -> a cause you just said it. =)
21:12:19 <kazagistar> ElderFain: right, those are the types of those expressions
21:12:50 <ElderFain> like, (+2) :: Num a => a -> a
21:12:51 <ElderFain> means its a... function that takes type a and returns type a?
21:13:02 <Lokathor> ElderFain, see how when you apply the first int, the signature gets shorter, but when you apply that value to the second int, it becomes the final value?
21:13:04 <kazagistar> ElderFain: yep, where a is "numeric"
21:13:15 <ElderFain> (Should I be reading smoething other than LYAH to get this stuff figured out?)
21:13:39 <Lokathor> ElderFain, LYAH is a solid book to start with, but just the scratchings at the surface :3
21:13:44 <trap_exit> I'v ealways wished
21:13:49 <Cale> ElderFain: Yeah, if f :: A -> (B -> C), and x :: A, and y :: B, then f x :: B -> C, and then (f x) y :: C
21:13:51 <kazagistar> ElderFain: try doing {let add2 = (+2)}, and then using that function
21:13:56 <ElderFain> Lokathor: let me think for a minute. using the concept of "apply" isn't how I mentally parse code, by "apply" you mean "call a function with some values" ?
21:14:00 <Fuuzetsu> I don't know how you made it to page 104 without being able to read type sig of (+), I thought that was like first few pages
21:14:04 <trap_exit> i want numHaskell
21:14:12 <Cale> ElderFain: yeah, with a single value
21:14:22 <Lokathor> ElderFain, yes that's basically what I mean here.
21:14:23 <trap_exit> I don't know how you can start haskell without being able ot read tyep sigs
21:14:27 <ElderFain> Fuuzetsu: well, I did provide the correct answer so maybe I learned something ;(
21:14:39 <Fuuzetsu> no offense, just curious
21:14:41 <Lokathor> trap_exit, anyone can write 3+2 into ghci :P
21:15:11 <ElderFain> Lokathor: yeah but they might not realize that + is an infix operator and all the complexity behind that
21:15:14 <ElderFain> knowing that its 5 is easy
21:15:15 <Cale> ElderFain: Every function really has exactly one parameter. The ones which appear to have more are just producing other functions as their result
21:15:17 <trap_exit> Lokathor: yeah, the next few lines of code of going from 3+2 to matlab is slightly harder
21:15:18 <ElderFain> knowing why its 5.. harder
21:15:24 <kazagistar> ElderFain: maybe this will make more sense? if you give less parameters to a function then it expects, then it returns a function that expects the remaining parameters
21:15:50 <Cale> ElderFain: So, for example, (+) will take a number like 2, and produce the function which adds 2 to whatever number it's given.
21:16:09 <Lokathor> trap_exit you just asked how you could start haskell. though to your desire for numHaskell... never used matlab, but probably doable
21:16:23 <Hijiri> ElderFain: https://github.com/bitemyapp/learnhaskell
21:16:42 <trap_exit> Lokathor: you missed the type signature on that comment, it wasn't :: String, it was :: Humor
21:16:43 <Cale> ElderFain: Of course, the compiler and runtime are designed to make this efficient -- it doesn't necessarily produce code for those intermediate functions if the function is always fully applied.
21:16:49 <Lokathor> ElderFain, try this in ghci: map (+2) [1..10]
21:17:01 <ElderFain> kazagistar: that makes it make sense, but I tried that out and it didnt' seem to do that? (+2)
21:17:01 <ElderFain> <interactive>:12:1:
21:17:02 <ElderFain>     No instance for (Show (a0 -> a0)) arising from a use of ‚Äòprint‚Äô
21:17:09 <Cale> (+2) is sort of a funny example, because it's not an example of partial application
21:17:11 <ElderFain> kazagistar: I expectd that to return a function, no? tht was waiting for my second value?
21:17:18 <Cale> (+2) is syntax sugar for (\x -> x + 2)
21:17:19 <Lokathor> trap_exit oh gosh! but really, want i want is hsTI-89 :33
21:17:38 <glguy> ElderFain: Notice that it did in fact return a function, the error is that it isn't something that one can print
21:17:44 <ElderFain> Fuuzetsu: hey, they also started using \blah and I don't recall it being explained, which reminds me now to go look it up!
21:17:48 <kazagistar> ElderFain: right, it did, and then it didnt have a way to print a function... you need to assign the function to something, then apply it on the remaining parameter
21:17:50 <Cale> (+) 2 would be a better example :)
21:17:57 <Cale> (even if it's the same function, really)
21:17:57 <shachaf> @quote ddarius partial
21:17:59 <ElderFain> also, let me scroll up I had a bunch of people saying stuff and I need to read it so hang on.
21:18:08 <shachaf> Oops, lambdanot.
21:18:11 <trap_exit> Lokathor: that's sad; a 20 year old graphing calculator has a better repl for interactive numeric mathematics than ghci
21:18:12 <glguy> shachaf: You're going ot have to pull that out of your logs
21:18:48 <glguy> trap_exit: I just checked typing "2+" into my TI-89, it says "Syntax Error"
21:18:55 <Hijiri> now if only my graphing calculator had a haskell interpreter
21:19:11 <shachaf> glguy: Works on my HP 48g
21:19:13 <Lokathor> trap_exit, the wonders of hyper specialization. You can get the ROM files for the 89 and 89titanium on the TI website for free, maybe a FFI could be built against them? There's an android app that does that
21:19:46 <shachaf> <ddarius> (f x) is a partial application iff f x == (curry (uncurry f) x)
21:20:03 <trap_exit> fuck, I bet the ti 89 hadbetter battery life than my mbp
21:20:09 <trap_exit> and I bet I can swap the batteries too
21:20:46 <trap_exit> this proves that for the purpose of being a graphing calculator; a graphing calculator beats a mbp + ghci
21:21:01 <trap_exit> but seriously, numeric math in haskell would be cool
21:22:50 <Lokathor> super
21:22:54 <Lokathor> sadly, i don't know math >_<
21:23:00 <glguy> shachaf: What do you type to get it to some something interesting, I installed an emulator and it just says: Error: Too Few Arguments
21:23:14 <shachaf> glguy: You need something on the stack, presumably.
21:23:32 <ElderFain> glguy: I guess I'll need to read up on how to parse errors, I don't see how it returned a function (but I believe you of course).  kazagistar I do actually like that way of thinking, that its 'functions all the way down'
21:24:24 <glguy> ElderFain: No instance for (Show (a0 -> a0)) arising from a use of ‚Äòprint‚Äô   Show is how you show a value as a string, a0 -> a0 is a function from some type to that same type
21:24:39 <glguy> It's telling you that it's trying to show you the result but that it can't be shown, because it's a function
21:24:49 <trap_exit> parsec is like super power
21:24:59 <trap_exit> i feel like can parse both APL and Perl6 now
21:26:33 <kazagistar> ElderFain: well, its functions all the way until it is a concrete value at the end
21:26:49 <ElderFain> unwrapped to reveal the gem inside
21:26:51 <ElderFain> got it.
21:27:24 <ElderFain> thank you. everyone has been so very polite & helpful.
21:27:34 <kazagistar> trap_exit: parsec spoiled me for parsing in other languages without it... I really need to figure out a way to reimplement it in Rust
21:28:11 <trap_exit> it's p[retty magical
21:28:14 <trap_exit> hyou describe what should happen
21:28:14 <Axman6> are Rust's trails powerful enough to have a Monad trait?
21:28:18 <trap_exit> and it gets parsed
21:28:41 <Hijiri> even without Monad trait, you could implement the monad combinators specifically for that parser type
21:28:43 <shachaf> Rust doesn't support higher-kinded types (among other things).
21:28:48 <shachaf> Polymorphism over HKTs, that is.
21:28:51 <Axman6> :(
21:28:52 <kazagistar> Axman6: no, but you can do something at least like Attoparsec by writing a non-generic bind
21:28:55 <shachaf> It's planned for the future, I hear.
21:29:08 <Axman6> good and good =)
21:30:51 <kazagistar> ElderFain: about the errors: ghci attempts to print the result of an expression you put in. That means the result of the expression must implement the Show interface, which allows for conversion to strings. The error is complaining that the expression was a function, for which there isn't a nice way to Show it
21:31:19 <trap_exit> of windows, osx, l;inux ... whaat is the best platform for writing haskell gui apps in?
21:31:23 <trap_exit> i don't need opengl; I just need basic vector graphics
21:31:26 <AndreasL> I'm currently reading Learn You a Haskell for Great Good! Quote from chapter 3: Functions also have types. "Functions also have types. When writing our own functions, we can choose to give them an explicit type declaration. This is generally considered to be good practice except when writing very short functions. " I can see why this may be beneficial, but why exactly is it good practice?
21:32:15 <trap_exit> because the cmpiler can check your work
21:32:19 <kazagistar> AndreasL: the purpose of types is to verify that the function is doing what you think you are doing
21:32:20 <shachaf> AndreasL: Makes it easier to read the code.
21:32:22 <trap_exit> becuase type checking goes faster due to less inference
21:32:29 <trap_exit> and it mnakes you think ahead of time
21:32:47 <kazagistar> tldr lotsa reasons :P
21:33:05 <Hijiri> trap_exit: I think GNU/Linux is the easiest platform to write most haskell apps in
21:33:27 <trap_exit> Hijiri: I've had good experiences on osx/surfacfe pro 3 ... but for GUI, it seems everything sucks if it' not on linux
21:33:35 <trap_exit> since Haste/Fay/GHCJS is not yet as good for producing gui stuff
21:33:38 <AndreasL> Can you overload functions in Haskell, by the way? Can I have two functions of the same name with different signatures? And if so, can I have one with explicit types and one version without type declarations?
21:34:22 <Lokathor> trap_exit: use SDL2 and it'll be really portable, but setting up SDL2 on windows can be difficult
21:34:33 <Hijiri> AndreasL: have you learned typeclasses yet?
21:34:46 <AndreasL> Hijiri, I haven't got to that part, no :)
21:34:50 <trap_exit> AndreasL: typeclass
21:35:06 <trap_exit> the basic philosophy of Haskell, is "ghc-compiler-flag JITTing"
21:35:19 <trap_exit> basically it means ... read the haskell books, start writing code, when you real the point of "gee, I wish Haskell could do XYZ"
21:35:20 <kazagistar> AndreasL: short answer, no, each name must have a unique type. But typeclasses basically let you do it, and better
21:35:21 <Hijiri> You can't in general have functions with the same name but different types, but typeclasses allow you to do it in some cases
21:35:28 <trap_exit> and turns out, you just do ghc --enable-XYZ
21:35:29 <trap_exit> and you have that feature
21:36:04 <trap_exit> basically lots of smart ppl hack on ghc, and as they need to extend the type system in various ways to do what they want to do,
21:36:05 <trap_exit> they extend the compiler
21:36:11 <AndreasL> OK, I see. Thanks guys.
21:37:16 <kazagistar> AndreasL: ... so what ends up happening really is a function can be basically arbitrarily generic on both input and return, if you are crazy enough
21:37:38 <trap_exit> basically, do NOT let "haskell alcks XYZ" prevent you from learning haskell
21:37:40 <AndreasL> kazagistar, so that is how you do generic programming in Haskell, then?
21:37:55 <trap_exit> wen you get to the point you really need XYZ, you'll find taht someone has already extendex the type system to solve your problem
21:38:04 <kazagistar> AndreasL: that, and passing functions as parameters
21:38:26 <Hijiri> There are also parameterized types
21:38:29 <Hijiri> like [a]
21:38:52 <AndreasL> I see. I'll get to that later, I suppose. Just had some questions as I was reading through :) Thanks again!
21:42:41 <trap_exit> are fay questions on topic here, or do they belong elsewhere?
21:43:33 <vanila> jhow do you read a file strictly?
21:44:14 <jle`> trap_exit: they tend to be ok :D
21:44:28 <trap_exit> jle`: the same for jmacro?
21:44:37 <jle`> not sure what that is :O
21:45:05 <trap_exit> http://www.stephendiehl.com/posts/haskell_web.html <0-- this guy is awesome; is he on irc, or is he so productive because he's not on irc ?
21:46:08 <vanila> is runST . unsafeCoerce :: IO a -> a the same as unsafePerformIO?
21:47:12 <glguy> Not quite, unsafePerformIO has more checks
21:47:36 <kazagistar> trap_exit: there are a lot of very productive people on IRC, and a lot of unproductive people not on IRC... I dont think the generalization holds either way
21:47:38 <Hijiri> vanila: for strict file reading, there is System.IO
21:47:53 <johnw> vanila: ST wraps an STArray
21:47:56 <Hijiri> There is openFile to get a file handle, and hGetLine, hGetContents etc
21:48:07 <glguy> johnwn: runSTArray?
21:48:09 <vanila> thanks all
21:48:27 <glguy> vanila: To read a file like you were trying to do you can do:  x <- readFile "file" ; length xs `seq` return xs, for example
21:48:32 <glguy> you have to force the output
21:48:47 <johnw> glguy: or just: evaluate (length xs)
21:48:56 <johnw> oh, I see, you want to return it
21:48:59 <johnw> then: return $! xs
21:49:08 <Iceland_jack> also evaluate is only to WHNF
21:49:11 <johnw> ah, no
21:49:11 <glguy> No, that's only whnf
21:49:12 <Hijiri> there is also Data.Text.IO if you want to use Text and not String
21:49:16 <johnw> right, forgot about the length
21:49:19 <johnw> too tired
21:49:39 <Iceland_jack> You can use 'force' from Control.DeepSeq along with evaluate if you don't want to install a libarary and you want to use String
21:51:10 <Iceland_jack> ghci> import Control.DeepSeq
21:51:10 <Iceland_jack> ghci> :t force
21:51:10 <Iceland_jack> force :: NFData a => a -> a
21:51:15 <Iceland_jack> ghci> import Control.Exception
21:51:16 <Iceland_jack> ghci> :t evaluate
21:51:19 <Iceland_jack> evaluate :: a -> IO a
21:51:22 <Iceland_jack> ghci> :t evaluate . force
21:51:25 <Iceland_jack> evaluate . force :: NFData b => b -> IO b
21:51:28 <Iceland_jack> Since lambdabot isn't here
21:51:48 <johnw> Iceland_jackbot
21:52:06 <Iceland_jack> Bite my shiny metal...
21:56:52 * hackagebot securemem 0.1.5 - abstraction to an auto scrubbing and const time eq, memory chunk.  http://hackage.haskell.org/package/securemem-0.1.5 (VincentHanquez)
22:17:27 <bitemyapp> dsantiago: hi
22:17:29 <bitemyapp> dgomez: you're fine :)
22:25:53 <matematikaadit> um... where is lambdabot?
22:26:30 * Iceland_jack looks at matematikaadit carrying a body bag
22:26:31 <Lokathor> he is dead
22:26:33 <shachaf> lambdabot is down due to https://ghc.haskell.org/trac/ghc/ticket/10000
22:26:33 <Iceland_jack> uh.
22:26:36 <Lokathor> and WE have killed him
22:26:48 <platz_> she's at the spa
22:29:24 <kazagistar> so lambdabot thought that was a nice even number of tickets, time to take a nice relaxing vacation?
22:29:56 <kazagistar> I guess she does deserve a break here and there
22:30:23 <Iceland_jack>  You're probably right
22:31:52 * hackagebot jwt 0.5.2 - JSON Web Token (JWT) decoding and encoding  http://hackage.haskell.org/package/jwt-0.5.2 (StefanSaasen)
22:35:04 <trap_exit> "gcc -g" <-- what is the closest ghc flag to this?
22:35:18 <trap_exit> when something goes wrong, like (head []), I want the closest thing to s stack trace as possible
22:41:52 * hackagebot jwt 0.4.3 - JSON Web Token (JWT) decoding and encoding  http://hackage.haskell.org/package/jwt-0.4.3 (StefanSaasen)
22:44:53 <SrPx> what version of llvm is gloss-raster using? http://lpaste.net/118613
22:45:37 <kazagistar> trap_exit: maybe -prof -auto-all -caf-all to compile and +RTS -xc to run, as per https://www.haskell.org/haskellwiki/Debugging?
22:46:00 <trap_exit> yeah
22:46:01 <trap_exit> -prof
22:46:07 <trap_exit> unfortunately, parsec is not compied with -prof
22:46:09 <trap_exit> :-(
22:46:28 <Axman6> reinstall it
22:48:28 <kazagistar> trap_exit: that would make it hard for sure
22:54:56 <AshyIsMe> hmm, could not find module ShowFun
23:19:38 <Lokathor> if i have an Int, how best to make it a Bytestring?
23:20:16 <Iceland_jack> What do you want to do?
23:20:22 <Axman6> you could use Data.Binary
23:21:13 <Lokathor> while using simpleirc, i've gotta use ByteString to send messages to irc. I want a bot to show a randomly generated int
23:21:49 <Axman6> oh, so you don't want the binary representation as a bytestring, just use show.pack
23:21:53 * hackagebot xmonad-entryhelper 0.1.0.0 - XMonad config entry point wrapper  http://hackage.haskell.org/package/xmonad-entryhelper-0.1.0.0 (javran)
23:22:09 <Iceland_jack> Yeah
23:22:14 <Axman6> probably from the Char8 version of whatever bytestring type you're using
23:22:45 <Iceland_jack> Using Char8 will lose anything over ASCII, if you don't want that use Data.ByteString.UTF8.fromString
23:23:14 <Axman6> but if it's an Int it's basically guaranteed to be fine
23:23:15 <Iceland_jack> (ah ignore that, just use pack)
23:25:00 <Lokathor> oh no a wild ambiguious type appears
23:26:38 <lpaste> Lokathor pasted ‚Äúit works now!‚Äù at http://lpaste.net/118614
23:27:35 <vanila> (invalid byte sequence)
23:27:38 <vanila> /tmp/pkgConf-vector-th-unbox-0.2.13869.0: hGetContents: invalid argument
23:27:49 <vanila> failed during the final install step
23:28:42 <AshyIsMe> https://github.com/gwern/mueval/blob/master/Mueval/Context.hs#L26
23:28:46 <AshyIsMe> where does ShowFun come from?
23:38:35 <Hijiri> how can I get ghc to precompute a value at compile-time?
23:39:00 <Iceland_jack> You'd use Template Haskell
23:39:26 <pavonia> What do you want to do with it after computing?
23:39:35 <Iceland_jack> You can search "haskell compute value at compile time" for how and forther information
23:39:48 <Hijiri> thanks
23:52:27 <shachaf> Is there a difference between data families and a newtype+type families?
23:53:46 <Iceland_jack> shachaf: Yes, type families are not generative
23:56:21 <Iceland_jack> When you define "data family Foo k" and "data instance Foo Bool = F | T" then 'Foo Bool' is a new data type that is introduced by the instance
23:57:05 <Iceland_jack> (you can define 'newtype' instances of data families: "newtype instance Foo Bool = MyBool Bool")
23:57:17 <glguy> Shachaf means a new type around a type family, together
23:57:58 <shachaf> I guess I should clarify.
23:58:27 <shachaf> I mean e.g. type family F a; type instance F X = A; type instance F Y = B; newtype RealF a = RealF (F a)
23:58:34 <shachaf> You get injectivity from the newtype.
23:59:18 <shachaf> (So even if F X ~ F Y, RealF X /~ RealF Y)
23:59:52 <glguy> The new type plus family is nicer to use in generics than an associated data family. I don't know of a difference.
