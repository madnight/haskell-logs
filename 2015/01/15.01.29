00:00:12 <matematikaadit> I'm clicking that link, and was redirected to that chinesse site.
00:00:25 <ab9rf> matematikaadit: not me, check your browser for malware.
00:01:17 <matematikaadit> I'll check in terminal using curl
00:01:31 <ab9rf> that, or check your ISP for malware :)
00:02:46 <Geekingfrog> noob here: I have a custom enum: data Letter = A | B | C deriving (Show, Read, Ord, Eq, Enum, Bounded) and I want to make it cyclic. That is: succ C = A. Is there a way to only override succ and pred for the boundaries of the enum? (my real usecase is more complex)
00:03:25 <Geekingfrog> I'd like to avoid having to redeclare all the function of the Enum typeclass
00:03:31 <shachaf> Not really.
00:03:39 <ab9rf> no, you have to write yuour own Enum instance
00:03:40 <Hijiri> that would be an incorrect Enum instance anyway, you're supposed to bottom on succ maxBound or pred minBound
00:03:45 <glguy> There isn't. If you want a non standard enum function like that you can write it separately
00:03:48 <Hijiri> I would use a different typeclass
00:03:51 <Geekingfrog> ok
00:03:55 <shachaf> You might derive Enum and then write your own function that uses the derived Enum instance.
00:04:03 <ab9rf> and you have to define all the required functiuons, and as hijiri says you really shouldn't do that :)
00:04:12 <Geekingfrog> yeah, it seems wrong
00:04:15 <Hijiri> If you use a separate typeclass you can use enum for every case except the edges
00:04:20 <Geekingfrog> anyway, I'll find a new way to do that
00:04:21 <Hijiri> to bootstrap
00:04:59 <matematikaadit> it seems that it's my ISP doing
00:05:27 <ab9rf> matematikaadit: that's more than a little disturbing.  maybe use a free VPN service?
00:08:58 * hackagebot language-javascript 0.5.13.1 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.5.13.1 (AlanZimmerman)
00:08:58 * hackagebot frp-arduino 0.1.0.0 - Arduino programming without the hassle of C.  http://hackage.haskell.org/package/frp-arduino-0.1.0.0 (RickardLindberg)
00:09:00 <otulp> matematikaadit: Based on your description, it could still be a local infection. Have you verified by using a separate device on the same network (phone, some other computer, ...)?
00:10:20 <otulp> Off-topic, I know. Sorry.
00:18:52 * hackagebot wl-pprint-extras 3.5.0.4 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-3.5.0.4 (EdwardKmett)
00:19:47 <georgew> @quote abstract.research
00:19:47 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatics, phone apps, and web services.
00:19:55 <matematikaadit> ab9rf, well, I think I'll let it pass for now. This is the first time and just that one page.
00:20:14 <ab9rf> matematikaadit: i envy your ability to be blase about that
00:20:21 <ab9rf> matematikaadit: i'd be ripping the network apart
00:20:32 <Geekingfrog> I have a list of enum values: [A, B, C], and I want to create a list of all "string" of enum of length n. For n = 2 I can do: (,) <$> [A,B,C] <*> [A,B,C] but I'm stuck for abitrary n. Any idea/pointers?
00:20:56 <matematikaadit> or maybe I'll check if it's a local infection.
00:21:46 <lfairy> matematikaadit: try https://hackage.haskell.org
00:22:31 <lfairy> > sequence $ replicate 3 ['a', 'b', 'c']
00:22:33 <lambdabot>  ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","bb...
00:22:43 <lfairy> Geekingfrog: :D
00:23:01 <Geekingfrog> oÔ
00:23:05 <Geekingfrog> thanks
00:23:16 <lfairy> no problem ;)
00:23:26 <matematikaadit> lfairy, hackage is working. It's just that one page I linked above that being redirected.
00:25:11 <mniip> [11:20:43] <lfairy> > sequence $ replicate 3 ['a', 'b', 'c']
00:25:20 <mniip> today I learned what sequence does to the list monad
00:26:31 <Geekingfrog> mniip, do you have any explanation? It seems a bit magical for me (even after reading what sequence do on hackage)
00:27:27 <ab9rf> heh
00:27:36 <ab9rf> read up on what the list monad "means"
00:28:01 <speak> > sequence $ replicate 3 ['a', 'b', 'c']
00:28:03 <lambdabot>  ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","bb...
00:35:33 <mniip> Geekingfrog, if you unwind the sequence definition into
00:35:38 <mniip> sequence [] = return []
00:35:38 <mniip> sequence (x:xs) = do { x' <- x; xs' <- sequence xs; return (x':xs') }
00:36:03 <mniip> you can kind of almost see that all it does is iterate over the head, and prepend it to all variants of the tail
00:36:35 <Geekingfrog> thanks mniip. I also re-read some stuff about the list monad. It's clearer now
00:38:18 * Geekingfrog still thinks haskell is weird
00:38:54 * hackagebot objective 0.6.5 - Extensible objects  http://hackage.haskell.org/package/objective-0.6.5 (FumiakiKinoshita)
00:39:05 <Arahael> Geekingfrog: if you tell Haskell that, I'm sure he'll be pleased.
00:42:00 <ab9rf> weird is good
00:52:13 <nuser> guys instance Monad Maybe for return is defined as; return = Just. However in ghci return Nothing gives Nothing. Which makes sense, but by definition shouldn't it be return Nothing?
00:52:53 <pavonia> The default instance in GHCi is IO
00:53:33 <silasm_> :t return Nothing
00:53:38 <lambdabot> Monad m => m (Maybe a)
00:54:06 <silasm_> notice it's not (:: Maybe a)
00:54:21 <nuser> ah yes
00:54:25 <nuser> silasm_: thanks :)
00:58:54 * hackagebot tttool 1.0 - Working with files for the Tiptoi® pen  http://hackage.haskell.org/package/tttool-1.0 (JoachimBreitner)
01:23:56 * hackagebot frp-arduino 0.1.0.1 - Arduino programming without the hassle of C.  http://hackage.haskell.org/package/frp-arduino-0.1.0.1 (RickardLindberg)
01:26:05 <sivteck> C is a hassle?!@#!
01:34:47 <adas> what is the free monad?
01:36:19 <raek> a "free X" is an instance of X that respects the law of X but does not implement anything that is not required by the type class
01:36:31 <raek> you can think of thee free monad as an AST for monads
01:37:09 <shachaf> Except respecting the laws.
01:37:20 <adas> can you give me an example?
01:38:05 <shachaf> What's the context of the question?
01:38:39 <adas> shachaf: no context. keep hearing about it here and in some tutorials about monads
01:38:56 * hackagebot pagerduty 0.0.1 - Client library for PagerDuty Integration and REST APIs.  http://hackage.haskell.org/package/pagerduty-0.0.1 (BrendanHay)
01:39:28 <shachaf> Well, it makes a difference whether you're already familiar with monads as an abstraction.
01:41:12 <adas> shachaf: oh that yes. i understand monads and transformers. just enough to have been able to write a toy brainfuck interpreter. but thats about it
01:42:42 <pacak> adas: That's all you'll ever need! You can implement everything else in brainfuck!
01:43:09 <MP2E> lol :P
01:46:48 <adas> pacak: maybe. but its very difficult to do anything useful in bf.
01:47:48 <pacak> adas: But that's not a problem! There's this nice BASIC to brainfuck compiler! http://brainfuck.cvs.sourceforge.net/brainfuck/
01:48:45 <MP2E> haha
01:48:52 <MP2E> compile basic to brainfuck then run brainfuck in haskell
01:48:56 <MP2E> hey it's functionally pure at some point right? :X
02:13:58 * hackagebot safe-access 0.2.1.1 - A simple environment to control access to data  http://hackage.haskell.org/package/safe-access-0.2.1.1 (thoferon)
02:17:19 <utdemir> Hey, assuming the bytestring is utf-8(ascii if easier), is there any (Data.ByteString.Lazy -> String) function?
02:18:25 <utdemir> Oh, .Char8.unpack . Ok
02:23:59 * hackagebot creatur 5.9.1 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.9.1 (AmyDeBuitleir)
02:24:01 * hackagebot rest-gen 0.16.1.8 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.16.1.8 (ErikHesselink)
02:38:59 * hackagebot grid 7.7.1 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.7.1 (AmyDeBuitleir)
02:44:58 <Zemyla> Okay, I had a very dumb idea I want to try and implement.
02:46:44 <Zemyla> A pseudo-Brainfuck written like a free monad, which changes to a form the Haskel; compiler can optimize with rewrite rules.
02:47:45 <Zemyla> compileBF $ do { inc; inc; right; input; loop ... }
02:48:24 <vanila> cool
02:48:41 <vanila> why not use a bracket like
02:48:56 <vanila> oh yo do
02:51:17 <Zemyla> inc will be a pretty name for tapeOp (t :: SomeType) where SomeType represents the operation of incrementing the current value.
02:52:32 <Zemyla> And then tapeOp ta >> tapeOp tb simplifies to tapeOp (tplus ta tb), where tplus is SomeType a -> SomeType b -> SomeType c.
02:53:51 <Zemyla> Similarly, you can optimize loops where the pointer ends in the same place as it began, and so on.
03:04:00 * hackagebot rawstring-qm 0.2.0 - Simple raw string quotation and dictionary interpolation  http://hackage.haskell.org/package/rawstring-qm-0.2.0 (tolysz)
03:09:00 * hackagebot amazonka 0.2.3 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.2.3 (BrendanHay)
03:09:02 * hackagebot amazonka-autoscaling 0.2.3 - Amazon Auto Scaling SDK.  http://hackage.haskell.org/package/amazonka-autoscaling-0.2.3 (BrendanHay)
03:09:04 * hackagebot amazonka-cloudformation 0.2.3 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.2.3 (BrendanHay)
03:09:06 * hackagebot amazonka-cloudfront 0.2.3 - Amazon CloudFront SDK.  http://hackage.haskell.org/package/amazonka-cloudfront-0.2.3 (BrendanHay)
03:09:08 * hackagebot amazonka-cloudhsm 0.2.3 - Amazon CloudHSM SDK.  http://hackage.haskell.org/package/amazonka-cloudhsm-0.2.3 (BrendanHay)
03:14:10 * hackagebot amazonka-cloudsearch 0.2.3 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.2.3 (BrendanHay)
03:14:12 * hackagebot amazonka-cloudsearch-domains 0.2.3 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.2.3 (BrendanHay)
03:14:14 * hackagebot amazonka-cloudtrail 0.2.3 - Amazon CloudTrail SDK.  http://hackage.haskell.org/package/amazonka-cloudtrail-0.2.3 (BrendanHay)
03:14:16 * hackagebot amazonka-cloudwatch 0.2.3 - Amazon CloudWatch SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-0.2.3 (BrendanHay)
03:14:18 * hackagebot amazonka-cloudwatch-logs 0.2.3 - Amazon CloudWatch Logs SDK.  http://hackage.haskell.org/package/amazonka-cloudwatch-logs-0.2.3 (BrendanHay)
03:14:23 <simg> Hi, I'm trying to use postgres-simple with the postgres Money data type. This must be a *really* common thing but I haven't been able to find any example code (that was even vaguely complete). Any ideas appreciated :).
03:18:19 <xxprismxx> hello
03:19:20 * hackagebot amazonka-codedeploy 0.2.3 - Amazon CodeDeploy SDK.  http://hackage.haskell.org/package/amazonka-codedeploy-0.2.3 (BrendanHay)
03:19:22 * hackagebot amazonka-cognito-identity 0.2.3 - Amazon Cognito Identity SDK.  http://hackage.haskell.org/package/amazonka-cognito-identity-0.2.3 (BrendanHay)
03:19:24 * hackagebot amazonka-cognito-sync 0.2.3 - Amazon Cognito Sync SDK.  http://hackage.haskell.org/package/amazonka-cognito-sync-0.2.3 (BrendanHay)
03:19:26 * hackagebot amazonka-config 0.2.3 - Amazon Config SDK.  http://hackage.haskell.org/package/amazonka-config-0.2.3 (BrendanHay)
03:19:29 * hackagebot amazonka-datapipeline 0.2.3 - Amazon Data Pipeline SDK.  http://hackage.haskell.org/package/amazonka-datapipeline-0.2.3 (BrendanHay)
03:20:15 <igniting> where can I read about file handling in haskell in detail? I have seen the documentation of Data.ByteString but it covers everything on a very high level
03:23:07 <Cale> igniting: Well, hmm, what sort of low level details are you looking for?
03:23:48 <Cale> There's a bunch more stuff in System.IO (https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.7.0.2/System-IO.html) related to Handles
03:24:31 * hackagebot amazonka-directconnect 0.2.3 - Amazon Direct Connect SDK.  http://hackage.haskell.org/package/amazonka-directconnect-0.2.3 (BrendanHay)
03:24:33 * hackagebot amazonka-dynamodb 0.2.3 - Amazon DynamoDB SDK.  http://hackage.haskell.org/package/amazonka-dynamodb-0.2.3 (BrendanHay)
03:24:35 * hackagebot amazonka-ec2 0.2.3 - Amazon Elastic Compute Cloud SDK.  http://hackage.haskell.org/package/amazonka-ec2-0.2.3 (BrendanHay)
03:24:37 * hackagebot amazonka-elasticache 0.2.3 - Amazon ElastiCache SDK.  http://hackage.haskell.org/package/amazonka-elasticache-0.2.3 (BrendanHay)
03:24:39 * hackagebot amazonka-elasticbeanstalk 0.2.3 - Amazon Elastic Beanstalk SDK.  http://hackage.haskell.org/package/amazonka-elasticbeanstalk-0.2.3 (BrendanHay)
03:25:02 <Cale> igniting: and then if you want lower level details than that, maybe dig into GHC.IO.*
03:25:03 <igniting> like caching, opening multiple file handles on same file, when to flush etc.
03:27:02 <igniting> Cale: System-IO page just gives documentation without any complex use case
03:27:27 <vanila> where can i learn about compiling lambda/closures?
03:27:29 <Cale> I guess it doesn't have any examples...
03:28:02 <igniting> I have Real World Haskell also, it also contains only few basic examples
03:28:48 <Cale> There shouldn't be anything special required to open multiple file handles on the same file. You just openFile multiple times.
03:29:41 * hackagebot amazonka-iam 0.2.3 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.2.3 (BrendanHay)
03:29:43 * hackagebot amazonka-importexport 0.2.3 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.2.3 (BrendanHay)
03:29:45 * hackagebot amazonka-kinesis 0.2.3 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.2.3 (BrendanHay)
03:29:47 * hackagebot amazonka-kms 0.2.3 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.2.3 (BrendanHay)
03:29:49 * hackagebot amazonka-lambda 0.2.3 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.2.3 (BrendanHay)
03:31:29 <Cale> As for when to flush, it's basically whenever the handle you're writing to is in LineBuffering or BlockBuffering mode, and you want to make sure that the buffers are empty (i.e. the file/terminal/socket is actually written)
03:32:28 <Cale> The only time I've ever needed to do that is basically when my terminal output was in LineBuffering mode and I wanted to display a prompt without a newline at the end of it.
03:32:58 <Cale> But I suppose you might also care about it if you wanted to be extra certain that things were written to disk in a timely fashion.
03:34:42 <Cale> You can get into lower and lower level details of what goes on with file access, but it'll only be pretty rare applications that actually care enough to do that.
03:34:51 * hackagebot amazonka-opsworks 0.2.3 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.2.3 (BrendanHay)
03:34:53 * hackagebot amazonka-rds 0.2.3 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.2.3 (BrendanHay)
03:34:55 * hackagebot amazonka-redshift 0.2.3 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.2.3 (BrendanHay)
03:34:57 * hackagebot amazonka-route53 0.2.3 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.2.3 (BrendanHay)
03:34:59 * hackagebot amazonka-route53-domains 0.2.3 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.2.3 (BrendanHay)
03:38:42 <Cale> Most of the time you can get away with just using readFile even. If you use readFile with a strict ByteString, it'll slurp the entire contents of the file into memory at once. If you do it with a lazy ByteString, it will read a chunk at a time, which if I recall correctly, is 32 KB.
03:39:05 <vanila> where could i ask my question?
03:39:08 <Cale> (It will do this as you evaluate the resulting lazy ByteString)
03:39:24 <Cale> vanila: Oh, right...
03:39:53 <dredozub-> http://stackoverflow.com/questions/28213785/trouble-refactoring-current-typespossibly-gadt-type-families-related can someone give it a look?
03:40:01 * hackagebot amazonka-s3 0.2.3 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.2.3 (BrendanHay)
03:40:03 * hackagebot amazonka-sdb 0.2.3 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.2.3 (BrendanHay)
03:40:05 * hackagebot amazonka-ses 0.2.3 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.2.3 (BrendanHay)
03:40:07 * hackagebot amazonka-sns 0.2.3 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.2.3 (BrendanHay)
03:40:09 * hackagebot amazonka-sqs 0.2.3 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.2.3 (BrendanHay)
03:40:25 <Cale> vanila: Well, you might have a look at http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf if you're interested in implementing a lazy functional programming language and want to understand the way that GHC does it. It talks about the representation of closures and thunks a bunch.
03:41:26 <merijn> Also, the STG paper is nice, imo :)
03:41:45 <vanila> I was thinking strict lambda could be simpler to start with?
03:41:51 <Cale> vanila: A closure is essentially a pair consisting of some code together with an environment of values of free variables which occur in that code. How that gets represented at a lower level is usually a pointer to code together with an array of pointers to the values.
03:42:00 <vanila> I have been loking at another book by SPJ but this seems newer i'll keep it around :D
03:42:34 <merijn> vanila: I depends, the STG paper explains how to implement a lazy language relatively easily :)
03:42:44 <merijn> It might not be as high performance as modern GHC, but still
03:42:54 <merijn> vanila: This one http://research.microsoft.com/apps/pubs/default.aspx?id=67083
03:43:15 <guhou> :t head.filter
03:43:17 <lambdabot>     Couldn't match type â€˜[a] -> [a]â€™ with â€˜[c]â€™
03:43:17 <lambdabot>     Expected type: (a -> Bool) -> [c]
03:43:17 <lambdabot>       Actual type: (a -> Bool) -> [a] -> [a]
03:43:25 <guhou> :t head.filter undefined
03:43:26 <lambdabot> [c] -> c
03:44:18 <guhou> @hoogle (a -> Bool) -> [a] -> a
03:44:21 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
03:44:21 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
03:44:21 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
03:45:11 * hackagebot amazonka-storagegateway 0.2.3 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.2.3 (BrendanHay)
03:45:13 * hackagebot amazonka-sts 0.2.3 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.2.3 (BrendanHay)
03:45:14 <Cale> Yeah, a lot has actually changed to make this out of date, but the basic concept is still valid. It's not really tagless anymore: http://research.microsoft.com/pubs/67969/ptr-tagging.pdf nor is it necessarily even spineless: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.411
03:45:15 * hackagebot amazonka-support 0.2.3 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.2.3 (BrendanHay)
03:45:17 * hackagebot amazonka-swf 0.2.3 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.2.3 (BrendanHay)
03:45:19 * hackagebot creatur 5.9.2 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-5.9.2 (AmyDeBuitleir)
03:45:47 <Cale> (but the tags and spines are used for a different reason than the ones which the STG machine removed)
03:49:23 <Cale> vanila: (those aren't relevant to your question but might make for interesting reading anyway)
03:49:44 <Cale> vanila: I take it you're actually *compiling* a language, and not just interpreting it?
03:50:05 <vanila> yeah I already did interpreters
03:50:21 * hackagebot tidal 0.4.23 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.23 (AlexMcLean)
03:50:23 * hackagebot heap 1.0.2 - Heaps in Haskell  http://hackage.haskell.org/package/heap-1.0.2 (eberlm)
03:50:25 * hackagebot tidal 0.4.24 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.24 (AlexMcLean)
03:50:27 * hackagebot rawstring-qm 0.2.1 - Simple raw string quotation and dictionary interpolation  http://hackage.haskell.org/package/rawstring-qm-0.2.1 (tolysz)
03:51:27 <vanila> is it true that STG can be used for non lazy languages? and that GHC doesn't useit any longer?
03:53:12 <Cale> vanila: Well, GHC is still using something quite similar to the STG machine as described by that paper, it's just extended and tweaked in various ways.
03:53:36 <Cale> I'm not sure you'd want to use the STG machine for languages which had no laziness
03:54:01 <Cale> But maybe if you wanted to support optional laziness reasonably well, it would be an option.
03:54:08 <vanila> interesting!
03:55:09 <merijn> vanila: STG is a very good intuition for things, although implementation details have shifted within GHC
03:55:42 <merijn> vanila: If the question is "I have no idea how you'd map a lazy language to assembler" then STG is a good starting point
03:56:10 <merijn> From there on you can move on to the GHC RTS description and "How to Make a Fast Curry" paper for more recent details
03:56:32 <merijn> And after that you're at the point where you'd really want to dive into the GHC source to learn more :p
03:56:49 <merijn> Unrelatedly
03:57:05 <merijn> Does anyone know if there's a video of dons' "Haskell in the Large" Google Tech Talk?
03:59:27 <Zemyla> merijn: Now I'm hungry for a fast curry.
04:03:47 <adas> I see this line in the spock source code .. "data Path as :: [*] -> *" any idea what that means? i only know the "data Foo = Foo" version
04:04:27 <adas> looks like a function on types
04:06:36 <John[Lisbeth]> This link is not meant at trolling but I think a few people in here might want to take a crack at this: https://boards.4chan.org/g/thread/46318086/explain-what-a-monad-is
04:06:48 <John[Lisbeth]> or just watch the results
04:11:45 <MagneticDuck> 4chan therefore trolling; Q.E.D.
04:13:29 <John[Lisbeth]> obviously the thread is a troll thread
04:13:35 <John[Lisbeth]> I simply mean I am not trying to troll this channel by posting it
04:19:03 * hackagebot tidal 0.4.26 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.26 (AlexMcLean)
04:26:44 <Geekingfrog> Question: I have a program which basically bruteforce a hash to find a given collision (for fun: see https://trello.com/jobs/developer). My code is there: https://gist.github.com/geekingfrog/9aba1a96b81eb1afcbd6  but the program eats up all my memory :'( Any idea?
04:27:26 <vanila> Geekingfrog, trello ?
04:27:42 <vanila> oh its where the problem is from
04:27:45 <Geekingfrog> yeah, but this is for javascript. I want to do that with haskell for learning purpose
04:27:56 <opqdonut> Geekingfrog: my guess is it's sequence
04:27:57 <Geekingfrog> yeah, it's an elaborate fizzbuzz
04:28:10 <Gx00-> fuck haskell. real programmers dont touch haskell
04:28:25 <Gx00-> LOL
04:28:30 <Cale> Geekingfrog: Are you compiling with -O2 ?
04:28:39 <Geekingfrog> uh? I'm using runhaskell
04:28:48 <Geekingfrog> note: I'm super noob
04:28:51 <Cale> then optimisations are off
04:28:56 <Cale> You may want to replace foldl with foldl' regardless
04:29:35 <Geekingfrog> anyway to run that with runhaskell?
04:29:43 <Geekingfrog> or do I need to compile then execute?
04:30:00 <opqdonut> yeah I think so
04:30:06 <Geekingfrog> (--help is rather unhelpful btw)
04:30:08 <Geekingfrog> ok, let me try
04:30:10 <Cale> uh, also, there's a type error in this
04:30:45 <Geekingfrog> yeah, I updated the gist
04:30:56 <ironChicken> is there a way of browsing the entire contents of Hackage as a namespace tree?
04:31:06 <Geekingfrog> there is a difference: it eats up memory **much** faster \o/
04:31:36 <Cale> heh
04:33:37 <Geekingfrog> opqdonut, what do you mean with "it's sequence"? It seems indeed that the line with sequence $ replicate is at fault
04:34:03 <opqdonut> Geekingfrog: I didn't think it through, but the result of sequence is probably not lazy enough
04:34:43 <Geekingfrog> ok, I'll dig this hole then.
04:37:26 <Cale> sequence' [] = [[]]
04:37:27 <Cale> sequence' ([]:xss) = []
04:37:27 <Cale> sequence' ((x:xs):xss) = map (x:) (sequence' xss) ++ sequence' (xs:xss)
04:37:42 <Cale> Geekingfrog: ^^ if you use that in place of sequence, it uses much less space
04:38:05 <Cale> oh, we could do even a bit better there...
04:38:55 <Cale> er, hmm
04:40:36 <Cale> Well, regardless, this is going to take a very long time
04:41:04 <Cale> You have 68.7 billion lists to generate and test
04:42:07 <Geekingfrog> I know it will take some time, but I would prefer to do it with regular memory
04:42:19 <Geekingfrog> I have a solution using node.js which does the job in around 20 min
04:42:27 <Cale> Geekingfrog: Well, that sequence' will fix your space issue
04:42:33 <Geekingfrog> ok, I'm trying it
04:43:09 <Geekingfrog> I'll digest it while it's running ;)
04:43:55 <Cale> It would probably be better to start from the desired result and figure out which letters are needed
04:44:42 <Geekingfrog> yeah, but the whole thing is just for me to practice haskell anyway
04:44:48 <Cale> > map (`mod` 37) . takeWhile (/= 0) . iterate (`div` 37) $ 956446786872726
04:44:50 <lambdabot>  [12,3,12,5,6,6,3,11,13,7]
04:44:52 <Cale> done
04:44:57 <Geekingfrog> wut?
04:45:41 * Geekingfrog feels *very* dumb
04:46:02 <Cale> ghci> hash [S,E,S,I,L,L,E,R,T]
04:46:02 <Cale> 952197874634094
04:46:09 <Cale> errrr
04:46:14 <Cale> oh, wrong order :)
04:46:30 <Cale> ghci> hash . reverse $ [S,E,S,I,L,L,E,R,T]
04:46:30 <Cale> 956446786872726
04:46:46 <aloiscochard> interesting, ThoughtWorks mention Haskell as a great tool for working with Hadoop in their TechRadar: http://assets.thoughtworks.com/assets/technology-radar-jan-2015-en.pdf
04:48:00 <thebnq> great am i stuck if i want an Vector unboxed 7-tuple
04:48:42 <Cale> Geekingfrog: The "hash" is treating the list as the digits of a number base 37, whose first digit is 7, and none of whose digits is any larger than 15, because of the limited alphabet.
04:49:09 <Cale> Geekingfrog: So we just need to work out the base 37 representation of the desired result
04:50:20 <Cale> (and hope that none of its digits are too large, and that the most significant digit is 7)
04:50:46 <Cale> > map (`mod` 37) . takeWhile (/= 0) . iterate (`div` 37) $ 956446786872726 -- That's what this code does
04:50:48 <lambdabot>  [12,3,12,5,6,6,3,11,13,7]
04:50:54 <Cale> > iterate (`div` 37) $ 956446786872726
04:50:55 <lambdabot>  [956446786872726,25849913158722,698646301587,18882332475,510333310,13792792,...
04:51:17 <pyon> HGe
04:51:20 <Cale> It would be easier to understand what's happening in base 10 I think
04:51:27 <Cale> > iterate (`div` 10) $ 95644678
04:51:29 <lambdabot>  [95644678,9564467,956446,95644,9564,956,95,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
04:51:36 <Cale> > takeWhile (/= 0) . iterate (`div` 10) $ 95644678
04:51:37 <lambdabot>  [95644678,9564467,956446,95644,9564,956,95,9]
04:51:44 <Cale> > map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 95644678
04:51:46 <lambdabot>  [8,7,6,4,4,6,5,9]
04:51:58 <Cale> So, there are the base 10 digits of our number
04:53:16 <Geekingfrog> nice, thanks for the explanation
04:55:30 <Geekingfrog> oh, there is also a remaining 7 at the end, because that's the initial value
04:57:08 <Cale> yeah
05:04:05 * hackagebot rawstring-qm 0.2.2 - Simple raw string quotation and dictionary interpolation  http://hackage.haskell.org/package/rawstring-qm-0.2.2 (tolysz)
05:09:06 * hackagebot rawstring-qm 0.2.2.1 - Simple raw string quotation and dictionary interpolation  http://hackage.haskell.org/package/rawstring-qm-0.2.2.1 (tolysz)
05:09:08 * hackagebot frp-arduino 0.1.0.2 - Arduino programming without the hassle of C.  http://hackage.haskell.org/package/frp-arduino-0.1.0.2 (RickardLindberg)
05:09:52 <aegis__> hello! I've got a bit of an algorithmic question. Given a tree-like structure, I need to access "higher" nodes in the tree from lower nodes, during a traversal
05:10:00 <aegis__> how would you represent that?
05:10:33 <piyush-kurur> zipper is that data structure to use
05:11:04 <nervkind> hey guys I am just working my way through the tutorial "you could have invented monads and maybe you already have" and there is this function i don't really understand. bind :: (Float -> (Float,String)) -> ((Float,String) -> (Float,String)) bind f' (gx,gs) = let (fx,fs) = f' gx in (fx,gs++fs) what confuses me is the ' f' (gx,gs) ' on the left side of the definition. is this pattern matching? but how can you pattern match if the inp
05:11:28 <piyush-kurur> aegis: you can checkout http://en.wikipedia.org/wiki/Zipper_%28data_structure%29
05:12:07 <hyPiRion> aegis__: It sort of depends, I think. I feel it's easier to just pass down a stack if you only need parents, for instance.
05:12:48 <aegis__> piyush-kurur: thanks! it seems to be what I am looking for. Basically I want to represent logic derivations, which consist of either lines or subderivations. However in a subderivation you might refer to lines from one of the parent derivations
05:13:37 <aegis__> hyPiRion: mmh that makes sense; at the moment I have everything linearly in one array, with a value "depth" on each line, but it doesn't follow the actual structure of a derivation
05:13:46 <aegis__> which makes it a bit painful to render properly for example
05:13:47 <Saizan> nervkind: you got cut off at "how can you pattern match"
05:13:48 <piyush-kurur> aeigs: for that you probably do not need zippers
05:13:49 <aegis__> or to handle scope
05:14:17 <piyush-kurur> a classical case is where you need say a doubly linked list
05:14:56 <aegis__> passing down a stack seems like the way to go
05:14:59 <piyush-kurur> the zipper associated with an ordinary list will give you (most of) the effects of a doubly linked list
05:15:30 <aegis__> piyush-kurur: interesting; I was just thinking about doubly linked lsits earlier and I thought they would be impossible to model in haskell
05:15:47 <nervkind> Saizan: oh, thank you. i just wanted to add, that i hope you can clarify this for me. is my question understandable? i get what the function does, but not why it works
05:16:01 <piyush-kurur> aegis: in fact xmonad uses it for its windows stack
05:18:02 <piyush-kurur> aegis: if you have not seen zippers before it is wort a read particularly the functional pearl due to Heut http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf
05:18:11 <piyush-kurur> s/wort/worth
05:19:43 <a3gis> piyush-kurur: thanks!
05:20:04 <a3gis> so for my particular problem you would pass down a stack?
05:20:50 <piyush-kurur> yes. I think in your case that should work
05:22:18 <Saizan> nervkind: well, you should tell me how the question ended :)
05:22:59 <Saizan> nervkind: anyhow f' is just a variable name, and (gx,gs) is pattern matching with the tuple constructor
05:23:44 <nervkind> Saizan: is this pattern matching? but how can you pattern match if the input is a function?? i hope you can clarify this for me
05:25:18 <nervkind> this is how it should have ended :) so f is the variable name for the input function? okay, i don't really get it. why can i pattern match for that?
05:26:58 <Saizan> nervkind: f' is the name for the input function (Float -> (Float,String)), then you have the pattern (gx,gs) for the second argument of type (Float,String)
05:27:31 <Saizan> nervkind: so, why shouldn't you be able to give a name to an argument?
05:28:25 <nervkind> ahh, okay i can match for ((Int,String), because it can be treated as an argument because of curryiing?
05:28:54 <nervkind> i didn't think of that as an argument
05:30:08 <danilo2> Hello! Is is somehow possible in haskell to unsafeCoerce a value with a non-primitive context? Here is small example what I mean - is it possible to somehow make the commented line to work? http://lpaste.net/119502
05:32:37 <barrucadu> Yes, give the return "a" a type annotation, so it knows what type it is
05:32:45 <barrucadu> But why are you doing this?
05:33:06 <Saizan> nervkind: yeah, A -> (B -> C) and A -> B -> C are the same type
05:37:45 <rtpg_> is there any good way in parsec to throw away non-matching input?
05:37:47 <danilo2> barrucadu: brb
05:38:07 <rtpg_> like "I just want the numbers in this input, ignore words"
05:38:32 <Cale> sepBy?
05:38:48 <rtpg_> ah, that's a good solution
05:39:14 <rtpg_> though you still have to figure out how to build a parser for the inverse
05:40:30 <breadmonster> Hey guys!
05:40:31 <Cale> Well, in that particular case, it'll be like satisfy (not . isDigit)
05:40:37 <Cale> or something
05:42:10 <rtpg_> yeah, was going through the libs and was kind of hoping for something of type Parsec s u -> Parsec s () that would fail if the input parser succeeds or the like
05:43:58 <vanila> hi breadmonster
05:44:28 <breadmonster> Hi vanila
05:44:30 <breadmonster> How are you?
05:44:56 <ClaudiusMaximus> rtpg_: maybe choice could work (returns the first successful parse) - i use it like  many $ choice [Right `fmap` whatIwant, Left `fmap` stuffToDiscard]  then you could probably use  rights  to just get the ones you want
05:45:00 <vanila> im ok bit stuck on code things
05:45:02 <vanila> how are you
05:45:16 <ClaudiusMaximus> rtpg_: here's my actual code https://gitorious.org/mandelbrot/mandelbrot-symbolics/source/c240f1708bada14ecc7e66651c87222be4a5041b:bin/m-beautify.hs#L129
05:45:50 <rtpg_> ah, nice
05:48:37 <danilo2> barrucadu: look at the example I provided - I didnt tell what exatly is this Num a - I want the same behaviour with Monad m. It is needed for some hacks simmilar to hmaps.
05:49:59 <jtanguy> rtpg_: maybe you could reuse the ideas in Text.Parsec.Token.lexeme
05:50:54 <jtanguy> (look at the haddock and not the source)
05:53:33 <vanila> danilo2, is it possible that writing this in a dynamic language could be better?
05:54:29 <simon> what's a good way to repeat a monadic action n times? (in particular, a parser)
05:54:58 <Fuuzetsu> :t replicateM
05:54:59 <lambdabot> Monad m => Int -> m a -> m [a]
05:55:01 <simon> mapM_ (const p) [1..n]?
05:55:03 <simon> Fuuzetsu, thanks.
06:01:19 <rtpg_> ah, figured out that manyTill anyChar digits can filter out any non-digits
06:01:52 <barrucadu> danilo2: Num defaults to Int, I believe. There isn't such a behaviour with Monad
06:04:08 * hackagebot gray-extended 1.5.1 - Gray encoding schemes  http://hackage.haskell.org/package/gray-extended-1.5.1 (AmyDeBuitleir)
06:07:22 <narendraj9> What is the difference between rem and mod in the Integral type class?
06:09:31 <simukis_> narendraj9: results are different if negative numbers are involved.
06:09:47 <simukis_> and rem is usually faster AFAIK
06:09:51 <narendraj9> I know that. I want to know how exactly.
06:10:10 <simukis_> > (rem (-1) 2, mod (-1) 2)
06:10:11 <hexagoxel> > (-1 `mod` (-4), -1 `rem` (-4))
06:10:12 <lambdabot>  (-1,1)
06:10:13 <lambdabot>  (3,-1)
06:11:11 <narendraj9> > rem (-1) (-2)
06:11:12 <lambdabot>  -1
06:11:17 <narendraj9> > rem (1) (-2)
06:11:18 <lambdabot>  1
06:11:51 <simukis_> narendraj9: these functions correspond to fmod and remainder functions from libm. These have extensive behaviour description in manpages
06:13:33 <narendraj9> Thanks. The manpages say they are *floating point* functions. Why?
06:13:50 <narendraj9> Oh. I never tried them with floats. :-D
06:14:09 <simukis_> because libm only implements functions for floating point. thereâ€™s no reason these canâ€™t work on regular integers.
06:14:56 <narendraj9> They don't work with floats. I never made sense to me. Thanks simukis_ :) Will read the manpages.
06:15:05 <narendraj9> *It
06:18:15 * hexagoxel notices how bad his example was, because of parsing traps. sry.
06:22:19 <quazimodo> anyone know a nice irc channel for crypto talk?
06:23:11 <Xe> quazimodo: lrf
06:24:08 <narendraj9> Okay. So rem always gives me a number which has the same sign as the dividend. mod gives me a positive number always. Both numbers are equal (modulo divisor). I don't see why I would need the one with a sign.
06:26:37 <cwraith> narendraj9: quot and rem are hardware instructions for Int.  That means they can be quite a lot faster when they're guaranteed to do what you want.
06:29:22 <merijn> Anyone know if dons' Haskell in the Large talk has video somewhere?
06:31:24 <lambda_q> what are the most important thing one should know about haskell and functional languages in general, and there a minimum of functions from which all could be derived, and if yes what is that minimum set of functions
06:31:44 <vanila> lambda_q, lambda is the most important thing
06:31:45 <merijn> lambda_q: Depends on how theoretical you wanna go?
06:31:50 <vanila> lambda is everything
06:31:52 <lambda_q> all the way
06:31:58 <lambda_q> but not enough time sadly
06:32:09 <lambda_q> but i'll pick up as i go
06:32:46 <merijn> lambda_q: Then start with the untyped lambda calculus (which has only functions and that's enough to be Turing complete), then you get the simply typed lambda calculus, which also contains types and from there you branch out in multiple directions, some of which lead to haskell
06:33:11 <merijn> i.e. you get to the lambda cube with dependent types, System F, etc. and then the Calculus of Constructions
06:33:15 <lambda_q> being turring complete doesn't always equal being easy to use
06:33:22 <merijn> Sure
06:33:45 <merijn> Actually, for Haskell Core/STG is probably the "minimal set"
06:51:21 * hackagebot frp-arduino 0.1.0.2 - Arduino programming without the hassle of C.  http://hackage.haskell.org/package/frp-arduino-0.1.0.2 (RickardLindberg)
06:51:21 * hackagebot gray-extended 1.5.1 - Gray encoding schemes  http://hackage.haskell.org/package/gray-extended-1.5.1 (AmyDeBuitleir)
06:56:07 <quazimodo> Xe: what's lrf?
06:56:16 * hackagebot rawstring-qm 0.2.2.2 - Simple raw string quotation and dictionary interpolation  http://hackage.haskell.org/package/rawstring-qm-0.2.2.2 (tolysz)
06:56:23 <Xe> quazimodo: encoded somehow :P
06:56:32 <quazimodo> damn you!
06:57:22 <quazimodo> get this, imagine a webapp storing an api key, secret And hash in one row, then showing the user the key, secret and hash, then allowing the user to use the key + secret OR the hash to authenticate
06:57:53 <quazimodo> that's right. Using a hash like a plain text password sans username
06:58:07 <fatlazycat> Hi, can anyone help with a nix expr / haskell project issue - have stuck it on stackoverflow http://stackoverflow.com/questions/28202394/nix-haskell-using-default-nix-from-cabal2nix-and-a-generic-shell-nix
06:58:07 <fatlazycat> 14:29
06:58:24 <quazimodo> i just thought "these guys kinda know that sha-1 has something to do with auth"
06:58:25 <vanila> quazimodo, that sounds like anyone could log in as anyone eles
06:58:28 <quazimodo> despite sha-1 being insane
06:59:20 <quazimodo> vanila: what it means is that either I'm a dumbass, or everything about that is wrong
07:00:46 <vanila> assuming its your program and you are free to experiment with it locally: try to create two accounts, see if you can log in as one from other
07:01:28 <quazimodo> vanila: you can't
07:02:56 <danilo2> Hello! Is it somehow possible in haskell to keep lambda in a newtype (for example, newtype Lam f = Lam {runLam :: f}, lam = Lam id) and be able to run it with different arguemnt types (like print (runLam lam 5) >> print (runLam lam "a")) ? Haskell monomrophises the types always and complains that int is not string :(
07:04:10 <mauke> newtype Lam = Lam (forall a. a -> a)
07:04:27 <danilo2> mauke: Wait! That was too simpplified example
07:04:53 <danilo2> mauke I want to compile function: foo lam = (runLamS lam 1, runLamS lam "a")
07:05:03 <danilo2> now it does not work
07:05:55 <mauke> @let newtype Lam = Lam{ runLam :: (forall a. a -> a) }
07:05:58 <lambdabot>  Defined.
07:06:15 <mauke> :t let foo lam = (runLam lam 1, runLam lam "a") in foo
07:06:16 <lambdabot> Num t => Lam -> (t, [Char])
07:06:27 <mauke> > let foo lam = (runLam lam 1, runLam lam "a") in foo (Lam id)
07:06:29 <lambdabot>  (1,"a")
07:06:59 <danilo2> mauke: Ok, but that borders the Lam newtype to only lambdas of form "a -> a"
07:07:37 <danilo2> mauke: And I woudl like to keep there any kind of lambda
07:08:39 <mauke> what for?
07:09:34 <danilo2> mauke: oh, I was afraid of that question, because its not easy to explain the whole idea. Anyway it is needed for a generated code. We need to pass lambdas to some functions and evaluate them if that makes any sense to you
07:09:42 <mauke> :t let foo :: Identity (forall a. a -> a) -> (Integer, String) in foo lam = (runIdentity lam 1, runIdentity lam "a")
07:09:43 <lambdabot> parse error on input â€˜=â€™
07:09:54 <mauke> :t let foo :: Identity (forall a. a -> a) -> (Integer, String); foo lam = (runIdentity lam 1, runIdentity lam "a") in foo
07:09:55 <lambdabot>     Illegal polymorphic or qualified type: forall a. a -> a
07:09:55 <lambdabot>     Perhaps you intended to use ImpredicativeTypes
07:09:55 <lambdabot>     In the type signature for â€˜fooâ€™:
07:10:39 <mpickering> How can I debug "<<loop>>"?
07:13:45 <nuser> shouldn't the type of 'Nothing >>= return' and 'return Nothing' be the same?
07:14:15 <cvkk> Hi, is this the place to ask a question about xmonad?
07:14:45 <geekosaur> #xmonad is usually better
07:14:56 <cvkk> thx geekosaur
07:15:00 <merijn> nuser: No
07:15:01 <danilo2> nuser: nope, because >>= :: m a -> (a -> m b) -> m b
07:15:06 <hyPiRion> :t (>>=)
07:15:07 <lambdabot> Monad m => m a -> (a -> m b) -> m b
07:15:19 <merijn> :t return `asAppliedTo` Nothing
07:15:20 <lambdabot> Monad m => Maybe a -> m (Maybe a)
07:15:25 <merijn> :t return
07:15:26 <lambdabot> Monad m => a -> m a
07:15:37 <danilo2> mauke: do you see any way to do it? I know you know some magic hacks in haskell so maybe you;ve got any idea? :)
07:16:12 <danilo2> nuser :: return <$> Nothing :)
07:16:15 <nuser> hmm
07:16:28 <danilo2> nuser: oh wait, return <$> pure Nothing
07:16:28 <merijn> danilo2: That's different still
07:16:40 <danilo2> return <*> pure Nothing -.- ehh, sry
07:16:53 <merijn> Probably still wrong
07:17:09 <merijn> :t (return <*>) `asAppliedTo` pure Nothing
07:17:10 <lambdabot> (a -> Maybe a1) -> a -> a
07:17:15 <breadmonster> merijn: What's the difference between pure and return?
07:17:33 <merijn> breadmonster: Conceptually? Nothing
07:17:49 <danilo2> merijn: right, sorry I'm thinking about something else and this is the reason. Of course. id <*> pure Nothing , which is not very exciting :)
07:17:53 <merijn> breadmonster: If a type is a Monad, then it's pure and return functions should be identical
07:18:07 <breadmonster> merijn: Why don't we use pure everywhere then?
07:18:30 <merijn> breadmonster: pure exists for historical reasons (i.e. Applicative was only invented in 2004 or so) and Applicative (until 7.10) is not a superclass of Monad
07:18:48 <merijn> Therefore not all Monad instances are forced to have Applicative instances and thus pure may not work
07:18:55 <merijn> Historical accident
07:19:23 <merijn> 7.10 will make Applicative a superclass of Monad and thus you can always use 'pure' although both will keep existing for backwards compatibility reasons
07:21:17 * hackagebot web-routing 0.1.0 - simple routing library  http://hackage.haskell.org/package/web-routing-0.1.0 (HirotomoMoriwaki)
07:23:23 <unknownloner> wow 7.10 is quite the update isnt it
07:23:48 <merijn> unknownloner: If you look at GHC release notes for most of the past few years you will see there's crazy improvements every year
07:24:15 <c_wraith> 7.10 changes the prelude more than anything before it, though.
07:24:21 <merijn> 7.8 had MIO, DataKinds and closed type families
07:24:32 <merijn> c_wraith: And I can't wait...
07:24:43 <merijn> Having to hide/qualified import Traversable/Foldable was a freaking pain
07:25:20 <vanila> cool more broken code!
07:25:44 <merijn> vanila: The BBP breakage is probably very minimal compared to AMP
07:25:50 <c_wraith> oh crap.  I just realized this code compiles only because it's on a 7.10 RC
07:26:00 <c_wraith> That's not ok...  *sigh*
07:26:02 <breadmonster> c_wraith: lol
07:26:03 <merijn> It's just that lots of people are upset by the idea of Prelude changing
07:26:15 <breadmonster> merijn: Can I PM for a second>
07:26:17 * hackagebot web-routing 0.1.1 - simple routing library  http://hackage.haskell.org/package/web-routing-0.1.1 (HirotomoMoriwaki)
07:26:21 <merijn> Well, SOME people
07:26:30 <merijn> breadmonster: Sure
07:28:33 <vanila> i wish I understood this desire to break back compatability all the time
07:28:50 <vanila> it's something to do with the pain of typing 'import MyPrelude' in every file yu make?
07:29:10 <c_wraith> there's very little breaking of backwards compatibility.  There's much more enabling writing backwards-incompatible code.
07:29:28 <c_wraith> vanila: there's no such thing as a prelude change that can fix what the AMP does, for instance.
07:29:29 <merijn> vanila: BBP only breaks a very small amount of code that relied on type inference
07:30:56 <c_wraith> merijn: and code that used names that collide now.
07:31:17 * hackagebot frp-arduino 0.1.0.3 - Arduino programming without the hassle of C.  http://hackage.haskell.org/package/frp-arduino-0.1.0.3 (RickardLindberg)
07:31:18 <merijn> c_wraith: Right
07:31:19 * hackagebot HGraphStorage 0.0.2 - Graph database stored on disk  http://hackage.haskell.org/package/HGraphStorage-0.0.2 (JeanPhilippeMoresmau)
07:31:37 <merijn> Although, strictly speaking that's still in accordance with the PVP
07:32:21 <k0ral> I can't find an "instance MonadBaseControl b m => MonadBaseControl b (FreeT a m)"; is there a reason for that ?
07:34:03 <merijn> Presumably because those are from different packages that don't depend on each other?
07:35:25 <lambda_q> is there such a function that outputs it's contents (with parameters) on every execution
07:36:04 <c_wraith> lambda_q: I'm not fully sure what you're asking, but..  maybe look at the Debug.Trace module?
07:36:15 <lambda_q> let's say you have a function
07:36:26 <lambda_q> you want to see what it really does (literally)
07:36:33 <lambda_q> as a trace/debug
07:37:04 <lambda_q> it could be already there in ghci or w/e
07:37:04 <c_wraith> so..  consider the Debug.Trace module
07:37:13 <lambda_q> thank you
07:37:45 <k0ral> merijn: if we have package A that defines some type, package B that defines some class, and we want them to be mutually independent, we need to create a third package C just to implement the instances of classes from B for types A ?
07:38:02 <k0ral> s/types A/types from A
07:38:35 <c_wraith> lambda_q: the results of tracing in haskell can be.. surprising.. until you're used to the evaluation model
07:39:51 <k0ral> it suggests that we have to create O(n*m) packages to properly separate types from typeclasses
07:40:18 <k0ral> isn't that bad ?
07:40:23 <c_wraith> Creating the third package is a poor idea, too.  It means orphan instances, which tend to create problems.
07:41:06 <c_wraith> ls
07:41:16 <c_wraith> grr.  really sorry I keep doing that. :(
07:41:51 <obb> hi, i want to do something like this: http://pastebin.com/79np9wUy . Any suggestions on how to change my code? need ad hoc polymorphism.
07:41:51 <merijn> k0ral: You can only do that using orphans and orphan instances are also considered bad
07:42:00 <merijn> k0ral: It's an open issue
07:42:12 <merijn> k0ral: If you have a brilliant idea, you could get it published ;)
07:42:20 <merijn> k0ral: Rust is having the exact problem right now
07:43:06 <geekosaur> er? RandomVariable is not what's being redefined
07:43:38 <geekosaur> your RandomVariable *does* need its own constructors though. data RandomVariable = RCat Category | RParm Parameter | RBranch Branch
07:43:54 <obb> ok
07:44:00 <obb> thats also what ghci says :D
07:44:37 <obb> i first tried data RandomVariable = Category String | Branch Integral Category
07:44:41 <obb> this wasn't possible too
07:44:54 <vanila> data RandomVariable = Category String | Parameter String | Branch Integral Category
07:44:58 <obb> is there any way to construct a similar statement?
07:45:10 <vanila> assuming Integral and Category are types?
07:45:47 <obb>     Not in scope: type constructor or class â€˜Categoryâ€™
07:46:09 <vanila> what exactly is it you want to define?
07:46:12 <obb> this means i first have to define category like data Category = Category String before using it?
07:46:20 <vanila> well lets forget about haskell for a sec
07:47:36 <geekosaur> Integral won't work as a type
07:47:39 <geekosaur> it's a typeclass
07:47:43 <obb> i want to create random variables
07:48:04 <geekosaur> otherwise I think we need to see more, or a better description of what you aere up to
07:48:44 <obb> ok let me try to explain this briefly
07:49:18 <obb> i want to create a function called 'p' which takes a random variable and assigns it a floating point value
07:49:55 <mightybyte> I think the answer to this is "no", but I thought I'd ask anyway.  Is there a type representing *only* haskell string literals?  i.e. a way for me to tag that something has to be a string literal and therefore known up front at compile time
07:50:02 <obb> but now i have a problem, because the underlying data structures aren't similar
07:50:23 <Taneb> mightybyte, IsString string => string?
07:50:27 <obb> eg 'category' is a string and a 'branch' is identified by an integral and a string
07:50:33 <Taneb> mightybyte, nevermind, that won't work
07:50:36 <mightybyte> Taneb: No, that's too general
07:50:59 <vanila> obb, sowhat possible things can 'p' be?
07:51:00 <Taneb> mightybyte, why do you want this?
07:51:18 * hackagebot language-javascript 0.5.13.2 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.5.13.2 (AlanZimmerman)
07:51:23 <obb> p is a function returning a double
07:51:37 <obb> ie assigning a value to a random variable
07:51:38 <vanila> oh sorry
07:51:44 <merijn> mightybyte: You could do it using TH
07:51:50 <vanila> I meant what possible thing scan the random variable you pass into p be
07:52:14 <mightybyte> Taneb: Well, I have a data type and a function :: String -> Maybe Foo to construct it from a string.
07:52:33 <mightybyte> But it would be kind of nice to have another function :: String -> Foo that only works for literals.
07:52:41 <merijn> mightybyte: Word
07:52:58 <obb> my random variables are categories, branches and parameters
07:53:02 <Taneb> merijn, Word doesn't work at all! :P
07:53:06 <mightybyte> ...because the compiler has the ability to check the thing at compile time.
07:53:21 <mightybyte> I guess a TH quasiquote can do it.
07:53:22 <vanila> alright well then it should be like geekosaur said:   data RandomVariable = RCat Category | RParm Parameter | RBranch Branch
07:53:24 <geekosaur> doesn't that violate referential transparency?
07:53:33 <obb> branches are identified by a category and some unique integer
07:53:36 <vanila> and for that you must define each of those 3 things as data types or types too
07:53:45 <merijn> mightybyte: Actually, right now I'm thinking of using TH to have "compile time validated" string literals for places where I only want to allow SOME values and I want the compiler to check what they want without this bothersome "fromMaybe" step that makes no sense for literals
07:53:48 <vanila> you could do  type Category = String  to make category synonymous with string
07:53:50 <geekosaur> and again it can't be Branch Integral Category because Integral is not a type
07:54:08 <merijn> mightybyte: I've been seriously considering whether I could build something like this into GHC so that it can be done without TH
07:54:09 <obb> yes vanila thats what im doing
07:54:13 <mightybyte> merijn: Yep, that's exactly what I'm talking about.
07:54:18 <obb> my problem is branch
07:54:28 <vanila> data Branch = Branch Category Integer
07:54:28 <merijn> mightybyte: Because TH seems a bit noisy. For now your only option is TH, tbh
07:54:31 <mightybyte> merijn: Yeah, that would be really nice.
07:54:37 <obb> because it consists of a category (which is also a random variable) and an integral
07:54:52 <geekosaur> an integral what?
07:55:00 <geekosaur> again, Integral is not a type
07:55:08 <obb> geekosaur: just a number
07:55:15 <geekosaur> then Integer
07:55:16 <obb> what then?
07:55:56 <merijn> mightybyte: Although, tbh, it might require TH anyway on account of needing to do arbitrary compile time validation
07:56:18 <mightybyte> merijn: Yeah, I could see that.
07:56:34 <kgadek> hi. code is more than thousand words: https://gist.github.com/be334e27f4a45c21ba92 how to make it work? I want `Lam id :: Lam (forall a. a->a)` to work :<
07:57:19 <merijn> mightybyte: Actually, screw this, I'm writing a library for this tonight...
07:57:22 <mightybyte> merijn: In that case, I guess the value would be reducing syntax noise a little.
07:58:21 <merijn> mightybyte: It shouldn't even be that hard...
07:59:13 <mightybyte> Hmm, dirpathQ in data-filepath is similar to what I'm thinking about
08:00:14 <merijn> It would be nice if I could avoid having to explicitly annotate the validation function
08:01:11 <merijn> mightybyte: I'm thinking "class IsString a => Validated a where validate :: String -> Maybe a" and then having TH determine the type, apply the function at compile time and replace it with the result in case of Just or compile error if Nothing
08:01:15 <c_wraith> what's the trick for writing imports of Foldable/Traversable so that you can compile on GHC 7.8 and 7.10 without warnings?  I remember there being one..
08:01:56 <merijn> c_wraith: Add "import Prelude" at the end? I think? That's a trick I saw edwardk mention with BBP, but I don't remember for what :p
08:01:59 <geekosaur> mm, is that the double Prelude import? import Prelude (); import Data.Foldable; import Prelude
08:02:21 <mightybyte> merijn: Yeah, that sounds about right.
08:02:31 <geekosaur> (the first suppresses the implicit import without dragging in the conflicting names)
08:02:48 <merijn> mightybyte: That way you'd only have to "instance Validated MyType" in libraries and users could write [validate| blah |] or whatever
08:03:03 <mightybyte> merijn: Yeah
08:03:07 <merijn> mightybyte: Actually, screw it, if you're quasiquoting anyway you don't even need the IsString superclass
08:03:08 <c_wraith> geekosaur: that looks right.  thanks.  (will test it out)
08:03:30 <mightybyte> merijn: In my case it would be nice to minimize the syntax.
08:03:36 <mightybyte> [vstr| blah |] or something
08:03:50 <mightybyte> But maybe that's too cryptic.
08:03:56 <merijn> mightybyte: Yeah, that's why I want a short quasiquoter name with no type annotations
08:04:02 <mightybyte> Right
08:04:05 <merijn> Maybe [valid| blah |] ?
08:04:15 <mightybyte> Ooh, that's pretty good
08:04:31 <sdegutis> Does Haskell have anything like __FILE__ and __LINE__ for reporting where a test failure occurred?
08:04:53 <c_wraith> sdegutis: if you enable CPP, it has exactly __FILE__ and __LINE__ :)
08:04:58 <merijn> Bollocks, "validate" is taken as package name >.>
08:04:59 <sdegutis> Cool.
08:05:06 <sdegutis> I hope that's what Hspec uses to tell me where errors are.
08:05:06 <merijn> sdegutis: Are you using "error"?
08:05:08 <mightybyte> merijn: Your plan fits exactly into what data-filepath is doing.
08:05:20 <sdegutis> I'm not using anything yet.
08:05:44 <merijn> sdegutis: I would expect hspec to report testing errors in some more useful way, tbh
08:06:27 <merijn> mightybyte: I'll let you brainstorm a package name while I try to hack this together :p
08:06:38 <mightybyte> Ok
08:07:29 <sdegutis> merijn: it doesn't seem to :(
08:08:13 <geekosaur> actually it looks likr the initial "import Prelude ()" is not needed
08:08:45 <mightybyte> merijn: How about string-th?
08:09:34 <sdegutis> Anyone in here use Hspec and know how to get it to report the file and line of an error?
08:10:40 <merijn> ugh
08:10:48 <alpounet> sdegutis: isn't the test label enough?
08:10:53 <merijn> We have typed template haskell, but no typed quasi quoters? :(
08:11:09 <sdegutis> alpounet: it saves me a little mental time at each failure to know what file and line to look at
08:11:17 <c_wraith> geekosaur: Hmm.  I'm still getting warnings.
08:11:19 <sdegutis> alpounet: when someone practices TDD, that adds up
08:11:33 <sdegutis> is Chris Done in here?
08:12:03 <lpaste> saep pasted â€œhspec failureâ€ at http://lpaste.net/119514
08:12:19 <saep> sdegutis: I get plenty of information.
08:12:20 <sdegutis> Oh, I was using "runhaskell Spec.hs"
08:12:24 <sdegutis> (per the readme)
08:12:44 <sdegutis> Thanks saep :)
08:12:58 <merijn> mightybyte: Actually, this might not be possible without compiler integration
08:13:24 <merijn> mightybyte: TH is run *before* compiling the resulting code, so no way to obtain the type of the value
08:14:52 <mightybyte> merijn: But data-filepath is using that approach.
08:15:51 <merijn> mightybyte: Because their quoter only ever returns one possible type
08:15:58 <mightybyte> Ahhh
08:16:00 <merijn> mightybyte: i.e. you'd have to write a custom quoter for every type
08:16:10 <merijn> Which is exactly what I'd want to avoid :)
08:16:50 <mpickering> What are the strictness properties of "maybe"?
08:16:55 <mpickering> how does it compare to a case statement?
08:17:37 <c_wraith> mpickering: its strictness properties are identical to the case statement, as far as I can see.
08:19:17 <mpickering> ok thanks
08:19:22 <koomi> > maybe undefined succ (Just 'a')
08:19:24 <lambdabot>  'b'
08:19:33 <koomi> >maybe 'b' undefined Nothing
08:19:36 <koomi> > maybe 'b' undefined Nothing
08:19:37 <lambdabot>  'b'
08:20:34 <mpickering> > maybe 'b' id (Just undefined)
08:20:35 <lambdabot>  *Exception: Prelude.undefined
08:20:40 <mpickering> that's the one I am worried about
08:21:05 <koomi> > maybe undefined (const 'a') (Just undefined)
08:21:06 <lambdabot>  'a'
08:21:59 <c_wraith> > case Just undefined of Nothing -> 'a' ; Just x -> x
08:22:00 <clrnd> @src const
08:22:00 <lambdabot>  *Exception: Prelude.undefined
08:22:00 <lambdabot> const x _ = x
08:22:10 <c_wraith> mpickering: same exception either way
08:22:30 <koomi> what else did you expect?
08:22:36 <koomi> the statement evaluates to undefined
08:23:04 <mpickering> I'm not worried about undefined, my program is circular so the pattern match was too strict and causing loops
08:24:02 <koomi> only the constructor is evaluated either way
08:51:21 * hackagebot wai-handler-launch 3.0.0.2 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-3.0.0.2 (MichaelSnoyman)
08:51:23 * hackagebot text-show 0.6.0.1 - Efficient conversion of values into Text  http://hackage.haskell.org/package/text-show-0.6.0.1 (ryanglscott)
08:51:38 <DerisiveLogic> For some reason lambdabot won't install on my mac, something about it having problems with regex-pcre-0.94.4 which failed to install.
08:53:53 <DerisiveLogic> Anyone have any idea on how to fix this?
08:54:05 <ocharles_> Does anyone know how to use hp2ps with the `-M` option?
08:54:13 <ocharles_> docs suggest I should get multiple pages, but I just get one page with no key at all
08:58:43 <BenKyr> Noobie question here. I have a StateT Either. Obviously, everything works as expected, and all my operations are biased to Right values. However, for one computation, I'd like to change a Left to a Right inside a (do).
08:58:49 <BenKyr> That may not make any sense. :(
08:59:13 <vanila> :t either Right Left
08:59:14 <lambdabot> Either a a1 -> Either a1 a
08:59:22 <vanila> I think you can just apply this to the action
08:59:49 <vanila> oh, StateT Either, then im not sure..
08:59:52 <BenKyr> Yeah.
08:59:55 <vanila> @unmtl StateT Either a
08:59:56 <lambdabot> Plugin `unmtl' failed with: `StateT Either a' is not applied to enough arguments, giving `/\A. Either -> a (A, Either)'
09:00:05 <vanila> @unmtl StateT (Either e) a
09:00:06 <lambdabot> Plugin `unmtl' failed with: `StateT (Either e) a' is not applied to enough arguments, giving `/\A. (Either e) -> a (A, (Either e))'
09:00:13 <BenKyr> Sorry, specifically..
09:00:28 <vanila> @unmtl StateT s (Either e) a
09:00:28 <lambdabot> s -> (Either e) (a, s)
09:00:38 <BenKyr> StateT s (Either e)
09:05:26 <joness> I am curious about the wording re seq function in Report. it seems that the only thing that is guaranteed is that `seq _|_ y' and that `seq x _|_' evaluate to bottom. is that correct?
09:07:03 <joness> seq (error "error a") (error "error b")  <- could either error be thrown?  could that even evaluate to undefine or infinite recursion? that would satisfy above requirement as well
09:07:34 <joness> undefined*
09:08:45 <grq> import Control.Monad
09:09:24 <joness> Control.Monad>
09:11:09 <enthropy> well you will get one of the two errors. They don't commit to giving one (I thinkthis is the paper http://research.microsoft.com/en-us/um/people/simonpj/Papers/imprecise-exn.htm)
09:12:38 <joness> entropy if "it evaluates to bottom" is all that is guaranteed, couldn't that evaluate to infinite recursion and still satisfy Report requirements?
09:12:54 <joness> or to undefined
09:13:30 <breadmonster> is mercurial written in Haskell?
09:14:00 <stepkut> breadmonster: python
09:14:06 <bennofs> breadmonster: it is written in python as far as I know
09:15:05 <ironChicken> breadmonster: are you thinking of darcs?
09:17:56 <HeladoDeBrownie> joness, yes. however, in practice, implementations usually evaluate the first argument first, and use reasonable error reporting.
09:18:09 <ClaudiusMaximus> joness: also compare with pseq
09:18:24 <HeladoDeBrownie> joness, if you need guarantees of that, seq may not be what you need.
09:19:57 <joness> why are seq's guarantees so weak?
09:20:24 <HeladoDeBrownie> joness, often that's all that's needed.
09:20:59 <joness> and often it isn't
09:21:30 <HeladoDeBrownie> right, and when it's not, there are other options like the aforementioned pseq
09:22:05 <joness> which is not part of the language
09:22:09 <HeladoDeBrownie> wait, does pseq have more guarantees? i might be confusing it with other things
09:22:18 <joness> so.. why does seq even exist. with such weak guarantees
09:22:24 <HeladoDeBrownie> because it's useful
09:22:25 <hk3380> was there a functional way to go through an iterable and compare 2 consecutive elements from it? something like (i don't know haskell)  `function(iterable, lambda a, b: a == b)`  and this would return 'ac' if `iterable` was 'aabccde' (sorry if i'm not very clear)
09:22:38 <joness> but not as useful as it could be
09:23:00 <c_wraith> HeladoDeBrownie: yes, pseq has more guarantees.
09:23:08 <hk3380> i.e. keep element if 2nd argument returns true
09:23:12 <HeladoDeBrownie> essentially, seq will have to evaluate the outermost constructor, and often that's all the strictness that's needed
09:23:42 <HeladoDeBrownie> giving seq more guarantees doesn't necessarily make it "more useful"; however, having things that give more guarantees wouldn't be a bad idea
09:23:55 <HeladoDeBrownie> in practice we use tons of things that aren't "part of the language", like ghc extensions
09:24:06 <HeladoDeBrownie> doing so is part of the haskell ecosystem
09:24:35 <HeladoDeBrownie> the language grows and evolves partly in response to people recognizing that such extensions are a good or bad idea
09:24:38 <c_wraith> > (\xs -> zipWith (\x y -> if x == y then x) xs (tail xs)) "aabccde"
09:24:39 <lambdabot>  <hint>:1:42: parse error on input â€˜)â€™
09:24:59 <joness> the point of seq is to force evaluation.. i am not sure what was the idea behind giving it such weak guarantees.. instead of going all the way out
09:25:25 <HeladoDeBrownie> it does force evaluation. but the question is how much evaluation do you need?
09:25:37 <HeladoDeBrownie> there aren't just two options, evaluated or not evaluated. there's a whole spectrum of evaluatedness
09:25:39 <ClaudiusMaximus> > let xs = "aabccde" in map fst . filter (uncurry (==)) . zip xs . tail $ xs
09:25:41 <lambdabot>  "ac"
09:26:06 <HeladoDeBrownie> anyway we have deepseq
09:26:22 <joness> deepseq uses seq so i am not sure how you consider that an alternative
09:26:40 <HeladoDeBrownie> in what sense do you mean that deepseq "uses" seq?
09:26:41 <joness> it has exactly the same issues
09:26:46 <n4x> which issues?
09:27:17 <n4x> one cool thing is that it lets the compiler have more freedom on the code
09:27:25 <ClaudiusMaximus> seq's weak guarantees give more freedom for compilers to optimize (or other things)
09:27:34 <joness> n4x zero guarantees about which bottom seq evaluates to if both arguments are bottom.. and even no guarantee that it evaluates to EITHER bottom
09:28:11 <joness> ClaudiusMaximus yeah.. but weak guarantees for the purpose of optimization feels more like C than haskell
09:28:12 <HeladoDeBrownie> there aren't distinct bottoms in the language semantics, there are only different compiler annotations on bottom
09:28:34 <HeladoDeBrownie> what error the compiler gives you is up to the compiler
09:28:51 <HeladoDeBrownie> so in a sense, i suppose you could say the language itself is "weak" there
09:28:54 <n4x> joness: '' a `seq` b = âŠ¥ if a is âŠ¥ ''
09:29:14 <n4x> that seems enough
09:29:25 <joness> HeladoDeBrownie default implementation for NFData instance is:  rnf a = seq a ()
09:29:34 <joness> (or was)
09:29:44 <HeladoDeBrownie> instances can override defaults
09:29:49 <joness> and all the instances I checked the source to used a combination of rnf and seq
09:30:08 <joness> so deepseq suffers from the same issue, in practice
09:31:20 <joness> n4x   (error "useful error message") `seq` y  could evaluate to infinite recursion
09:31:28 <joness> or to undefined
09:32:10 <n4x> I don't know what you are trying to do, but there is probably a better way than bottom
09:33:15 <joness> n4x I am not doing anything, I am discussing semantics of seq and wondering why it doesn't have stronger guarantees
09:33:27 <joness> answers doesn't seem convincing so far
09:33:56 <joness> don't*
09:34:51 <zelvosaur> Hello, GHC question here: why does GHC keep a .a and .so file for each installed library? Are both the files needed? (I am trying to work on a constrained VM and need to free some spaceâ€¦)
09:35:24 <joness> if all implementations in practice implement seq the obvious way (evaluate first argument , then second) why doesn't Report guarantee that?
09:36:25 <c_wraith> joness: all implementations don't, in practice.  For instance, GHC doesn't.
09:36:27 <geekosaur> you can configure it to build only static libraries, IIRC
09:36:50 <zelvosaur> geekosaur: how?
09:37:17 <exio4> joness, the order could be changed by optimizations, too
09:37:19 <joness> c_wraith are you sure? hackage documentation suggest otherwise
09:37:31 <joness> "Evaluates its first argument to head normal form, and then returns its second argument as the result. "
09:37:47 <exio4> that isn't seq
09:37:51 <joness> yes it is
09:37:53 <exio4> seq only evaluates to WHNF
09:38:00 <joness> http://hackage.haskell.org/package/base-4.7.0.2/docs/Prelude.html#v:seq
09:38:18 <joness> I copy pasted that from the above link
09:38:20 <vanila> isnt head normal form the same as weak head normal form
09:38:32 <ibid> no
09:38:37 <vanila> how do they differ?
09:38:54 <ibid> without the weak, even function bodies get reduced
09:39:16 <ibid> (\x -> (\y -> y) x) is in WHNF but not in HNF
09:39:23 <geekosaur> yug, I see the option for executables but not for libraries...
09:39:24 <vanila> so
09:39:33 <vanila> > seq (\_ -> undefined) ()
09:39:35 <lambdabot>  ()
09:39:38 <vanila> this should crash?
09:39:52 <exio4> no, a Î» is already in WHNF
09:39:55 <c_wraith> vanila: it would if it was head-normal form.
09:40:02 <c_wraith> vanila: but it's not.
09:40:05 <exio4> > seq (Just undefined) ()
09:40:06 <lambdabot>  ()
09:40:08 <vanila> but the doc said head normal form
09:40:17 <ibid> the doc is wrong
09:40:17 <c_wraith> we've already established the doc is wrong. :)
09:40:25 <vanila> ah!
09:40:26 <c_wraith> GHC also doesn't have the ordering guarantee it implies.
09:40:36 <geekosaur> ah. executable refers to it as dynamic, library refers to it as shared. sigh
09:41:07 <joness> c_wrait can you give an example where GHC doesn't evaluate first  argument 1st
09:41:21 <geekosaur> so you want to drop "shared: False" in ~/.cabal/config to disable building the shared library
09:41:29 <saep> joness: http://hackage.haskell.org/package/base-4.7.0.2/docs/src/Prelude.html#%24!
09:41:43 <zelvosaur> geekosaur: thanks, i will try that
09:42:03 <c_wraith> joness: I recall there being examples - not what they were.  I don't remember who had them..  maybe monochrom ?
09:42:35 <breadmonster> Umm, okay, so an important question that's not really answered anywhere.
09:42:37 <joness> saep what? that definition never evalutes first argument?
09:42:47 <breadmonster> Where do you pick up data structures for Haskell?
09:43:04 <breadmonster> Things like CLRS don't deal with laziness or immutability.
09:43:06 <saep> But the documentation is somehow not exported and something else is put there. ;-)
09:43:15 <joness> > seq (error "a") (error "b")
09:43:17 <lambdabot>  *Exception: a
09:43:28 <joness> > let seq _ y = y in seq (error "a") (error "b")
09:43:30 <lambdabot>  *Exception: b
09:43:32 <c_wraith> breadmonster: the only decent answer for that is Okasaki's thesis and/or book
09:43:40 <joness> clearly not the definition that is used
09:44:05 <c_wraith> breadmonster: other than that, things are just described individually in papers
09:44:06 <saep> joness: That's why there is a `#ifdef __HADDOCK__` block.
09:44:12 <joness> and that definition doesn't satisfy repots requirements, that seq _|_ y = _|_
09:44:15 <Welkin> breadmonster: it is fairly easy to translate most data structures into haskell
09:44:38 <breadmonster> c_wraith: Umm, I think we should collate these papers and so on.
09:44:44 <breadmonster> c_wraith: what journals do they appear in?
09:44:51 <Welkin> graphs are just an array of ajdacency lists
09:45:03 <geekosaur> joness, I don't recall the circumstances but seq in ghc does not guarantee evaluation order so there is a pseq that does
09:45:22 <joness> afk for a bit
09:45:27 <glguy> joness: With imprecise exceptions (like "error") there's no promise that you get any particular error when you get one
09:45:37 <Welkin> breadmonster: https://cstheory.stackexchange.com/questions/1539/whats-new-in-purely-functional-data-structures-since-okasaki/1550#1550
09:45:41 <glguy> GHC is free to collapse them into the same error
09:45:57 <Welkin> that is a collection of everything since okasaki's publication
09:46:14 <Welkin> hint: bookmark it
09:46:19 <geekosaur> I recall that this was discussed on -cafe some time back but probably won't be able to find it easily --- don't recall enough details
09:46:24 * hackagebot sdf2p1-parser 0.1.1 - A parser for SDF version 2.1 using Parsec  http://hackage.haskell.org/package/sdf2p1-parser-0.1.1 (kojung)
09:47:59 <geekosaur> joness: maybe http://comments.gmane.org/gmane.comp.lang.haskell.cafe/88112
09:49:59 <geekosaur> ah, yes, and there's an example at the bottom where seq's evaluation order depends on whether you compile with optimization or not
09:51:24 * hackagebot language-javascript 0.5.13.3 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.5.13.3 (AlanZimmerman)
09:58:38 <joe____> Hello
09:59:30 <joe____> is anyone there?
10:00:04 <Welkin> joe____: if you have a question, ask, and someone may answer
10:01:02 <joe____> Thanks
10:10:17 <marchelzo_> What is "Fraction.log"?
10:10:40 <unknownloner> logarithm maybe?
10:11:15 <marchelzo_> When I run my program it just prints "<ProgramName>: Fraction.log" like some sort of runtime exception.
10:11:57 <Welkin> :info Fraction.log
10:12:03 <Welkin> @info Fraction.log
10:12:03 <lambdabot> Fraction.log
10:12:27 <unknownloner> thats helpful
10:12:31 <joneshf-laptop> is there a type that represents unique values? Sort of like `Set` but you statically cannot insert two of the same value?
10:12:37 <Welkin> oh
10:12:47 <joneshf-laptop> rather than being idempotent to it, it's a compile time error
10:12:48 <Welkin> @info is the same as @undo
10:12:48 <lambdabot> <unknown>.hs: 1: 21:Parse error in expression: as@undo
10:13:03 <Welkin> `@undo` sugars do-notation
10:13:27 <Welkin> lambdabot thinks @info is a typo for @undo
10:15:42 <chpatrick> joneshf: I doubt it
10:15:47 <chpatrick> sounds like a dependent-typed thing
10:16:00 <chpatrick> the type would need to reflect what's in it but you would need to vary the type based on the values you insert
10:16:48 <josephle> it wouldn't be a very pleasant type to work with :/
10:16:56 <chpatrick> I mean maybe you could make it work if it only contained stuff that lives at the type-level like a promotable type or a typenat
10:17:17 <chpatrick> but I think it'd be way more of a pain in the ass than it's worth
10:17:53 <joneshf-laptop> I'm thinking of having a small domain to work with, but want to ensure that the values are unique
10:18:00 <joneshf-laptop> so like, to prevent typos
10:18:08 <joneshf-laptop> or copy/paste errors
10:18:54 <joneshf-laptop> as far as why I'd want such a thing
10:18:55 <chpatrick> I think the power to weight ratio doesn't make sense
10:19:13 <chpatrick> you could do something like that probably but it would waste more productivity than it would generate
10:19:14 <chpatrick> imho
10:19:14 <enthropy> HList has TIP
10:19:24 <josephle> in dependent types, you could require the insertion function to include a proof that the value is not already in the Set
10:19:33 <josephle> but that would be a huge pain to work with
10:19:49 <joneshf-laptop> josephle, yeah, I was afraid it might require dep types
10:20:54 <enthropy> but it doesn't let you have two Int in there with different values
10:22:20 <lf94> How could I improve this guys? https://github.com/lf94/g_challenges/blob/master/00/name_generator.hs
10:24:01 <joneshf-laptop> ah well, thanks anyway chpatrick josephle enthropy
10:24:06 <Hijiri> lf94: it looks like you're reusing generator, so your values aren't going to be as random as you want it to be
10:24:48 <ReinH> Hijiri: True, although in this case probably not a problem.
10:24:48 <bergmark> lf94: with `head' you bring the assumption that the lists are non-empty, you should verify that so your program doesn't crash
10:24:56 <ReinH> since it's running on two different lists
10:25:09 <ReinH> it won't be observably less random
10:25:48 <ReinH> You might pattern match instead of head: let (first:_) = shuffleS ...; let (last:_) = shuffleS ... print (first ++ " " ++ last)
10:25:55 <bergmark> lf94: i'd probably also make gen the first argument to shuffleS, typically functions that take an argument of a type and return it have that argument in the last position
10:26:16 <lf94> Hijiri, that's ok, better randomness isn't a concern
10:26:52 <lf94> (reading what you guys are saying)
10:26:58 <ReinH> you might also handle the empty list cases
10:27:25 <lf94> Yeah, ok that's a good point
10:27:31 <lf94> bergmark, said that too
10:27:47 <lf94> Why would I want to use pattern matching instead of head?
10:27:59 <lf94> I only want to take one element
10:28:13 <ReinH> in part because it makes it more obvious that there are cases you aren't handling
10:28:21 <ReinH> that's what the pattern does
10:28:24 <Hijiri> when you pattern match with empty and cons, you know for sure that you already have a head when you need it
10:28:25 <bergmark> you should just never use head :-), use headMay [] = Nothing; headMay (x:_) = Just x
10:28:53 <lf94> But it clearly shows what I'm doing with head
10:28:57 <ReinH> also head should generally be avoided because it is a partial function that will cause runtime errors
10:28:59 <lf94> OK I can live with headMay
10:29:23 <ReinH> honestly it would be better if head didn't exist at all
10:29:34 <ReinH> or at least not in the prelude
10:29:34 <lf94> I really like the Maybe class
10:29:40 <lf94> er, type/
10:29:51 <lf94> type class
10:29:53 <lf94> something
10:29:57 <lf94> flippin' terminology
10:29:58 <ReinH> type, typ constructor
10:30:13 <lf94> ok
10:30:27 <bergmark> Maybe is a type, Just and Nothing are its constructors
10:30:33 <lf94> Gotchya
10:31:34 <ReinH> *type constructor
10:32:54 <lf94> let (first:_) = shuffleS <- so what happens if first is nothing?
10:33:10 <lf94> if someone could finish that line maybe I'll understand it better
10:33:35 <lf94> er
10:33:40 <lf94> what if shuffleS returns nothing*
10:33:53 <HeladoDeBrownie> is that in a do block? then fail will be used
10:33:57 <ReinH> let (first:_) = shuffleS (lines firstNamesFile) generator
10:34:15 <ReinH> if the rhs is empty you will get a pattern match failure
10:34:47 <HeladoDeBrownie> my mistake, i was confusing let with <- for do blocks
10:35:29 <bergmark> unfortunately i think let (first:_) = ... also hides the inexhaustive pattern match warning
10:35:33 <bergmark> i'm not sure why
10:36:08 <ReinH> At least it's visually more apparent
10:37:40 <lf94> ReinH: what happens on a pattern match failure? crash?
10:38:06 <EvanR> > let (x:_) = [] in x
10:38:07 <lambdabot>  *Exception: <interactive>:3:5-14: Irrefutable pattern failed for pattern (x ...
10:38:12 <EvanR> > head []
10:38:14 <lambdabot>  *Exception: Prelude.head: empty list
10:38:27 <lf94> that second error sounds way more understandable
10:38:36 <EvanR> yeah
10:38:38 <EvanR> @src head
10:38:38 <lambdabot> head (x:_) = x
10:38:39 <lambdabot> head []    = undefined
10:38:47 <EvanR> well, irl, the second case has a specific error message
10:39:14 <lf94> > let (x:_) = [1] in x
10:39:16 <lambdabot>  1
10:39:22 <lf94> > let (x:_) = [1,2,3] in x
10:39:23 <lambdabot>  1
10:39:26 <bergmark> lf94: if there's a case where i know the list cannot be empty and i want the first element i'd do something like fromMaybe (error "YOWSA!") (headMay list)
10:39:27 <lf94> ok cool
10:39:31 <EvanR> lf94: if you write an incomplete pattern match, then youd better be able to prove that the missing cases cant happen. otherwise its going to be a bumpy ride
10:39:41 <c_wraith> That's my first upload to hackage in a long while...
10:39:49 <enthropy> bergmark: I think there's no warning because that pattern does actually match anything
10:40:00 <bergmark> enthropy: how do you mean?
10:40:04 <enthropy> it's an "Irrefutable pattern"
10:40:18 <bergmark> ah
10:40:39 <lf94> lol
10:40:48 <enthropy> > case [] of ~(_:_) -> "something"; _ -> "something you'll never get"
10:40:50 <lambdabot>  "something"
10:41:05 <lf94> I haven't had the pleasure of using case yet
10:41:18 <lf94> I try to stick to guards
10:41:26 * hackagebot lrucache 1.2.0.0 - a simple, pure LRU cache  http://hackage.haskell.org/package/lrucache-1.2.0.0 (CarlHowells)
10:41:27 <lf94> and pattern matching
10:41:35 <bergmark> lf94: case is pattern matching
10:41:52 <lf94> case [] of ~(_:_) <- what the heck does this mean
10:41:56 <EvanR> guards is harder to get right, in general
10:41:59 <enthropy> so even if you could add some more patterns to try there, they wouldn't match
10:42:18 <tommd> Lazily match a list of at least one element.
10:43:02 <lf94> i'm just using this as an example
10:43:22 <lf94> but is similar to switch [] { case ~(_:_) } ?
10:43:27 <lf94> is it*
10:43:30 <EvanR> the pattern ~(_:_) always succeeds, and will only deconstruct the list (and so evaluate the expression to see what kind of list it is) only when it is absolutely necessary, possibly crashing later
10:43:41 <ReinH> lf94: I wouldn't worry about irrefutable patterns right now
10:43:43 <lf94> (not valid syntax in any language, just using keywords)
10:44:11 <bergmark> lf94: i think you can safely ignore ~ in patterns for quite some time :) i've never used it
10:44:22 <lf94> isn't ~ not or something
10:44:39 <prophile> ~ is for irrefutable patterns
10:44:48 <tommd> lf94: No, it says "Always match, don't actually check the pattern"
10:44:49 * enthropy would read it as lazy
10:44:54 <lf94> i think i'll just stick to headMay, lol
10:45:06 <lf94> everythings getting overly complex
10:45:15 <lf94> tommd: ah
10:45:57 <EvanR> if it was ~(x:_) it might have to actually check that the pattern matches, at some point
10:46:06 <lf94> Well, I'm glad my code is right in some sense- I just have to make my programs use the type checker more
10:46:07 <ReinH> lf94: I might do something like this http://lpaste.net/4460793414908116992
10:46:49 <lf94> ReinH: nice ;_;
10:47:16 <lf94> Ok this I can understand
10:47:55 <lf94> ReinH is this something you figured out yourself (using pattern matching as an alternative to head) or did you pick it up from somewhere/one?
10:48:30 <bergmark> lf94: and you can use putStrLn since you have a string, unless you want to print the quotes
10:48:43 <bergmark> (instead of `print')
10:48:47 <lf94> Yeah I was wondering why print was printing quotes.
10:48:56 <EvanR> @src print
10:48:57 <lambdabot> print x = putStrLn (show x)
10:49:20 <lf94> Lol, you guys want to critic my heads/tails one?
10:49:52 <lf94> https://github.com/lf94/g_challenges/blob/master/01/headstails.hs
10:49:54 <lf94> B)
10:49:58 <lf94> I bet you can't beat that!
10:49:59 <ReinH> lf94: I annotated with a little refactor as well http://lpaste.net/4460793414908116992
10:50:06 <Ainieco> is -XOverloadedRecordFields there yet?
10:50:26 <ReinH> Woops, forgot an import: http://lpaste.net/8272638415514632192
10:50:54 <lf94> nice
10:51:07 <ReinH> lf94: And now you don't need that extra binding maybeName, refresh
10:51:31 <lf94> wow I didn't know you could do this: let shuffled xs = shuffleS (lines xs) gen
10:51:46 <glguy> Ainieco: OverloadedRecordFields as previously described isn't going into GHC (at least not in the near future). There is active discussion about what ORF should actually be
10:52:01 <lf94> Niiice
10:52:12 <Ainieco> glguy: previously?
10:52:17 <Ainieco> glguy: missed that
10:52:30 <lf94> ReinH: Seriously I think this is the only way to learn Haskell
10:52:40 <lf94> ReinH: Code Haskell, get it reviewed, learn from the reviewers
10:52:53 <MP2E> It's not the only way, but it's a good one
10:53:00 <Ainieco> glguy: too bad was hoping for ORF in 710...
10:53:43 <ReinH> lf94: And if you swap the arguments to shuffleS as mentioned before, it works better compositionally. http://lpaste.net/4003672671135989760
10:54:29 <lf94> ReinH: I was wondering why I couldn't do that.
10:54:46 <lf94> Definitely something to note about argument arrangement
10:56:50 <phaazon> hey
10:57:15 <phaazon> is there a way to sort cost centres by inherited %time?
10:57:35 <bergmark> lf94: i'd write the coin thing like this http://lpaste.net/119528
10:58:50 <bergmark> lf94: !! is bad for the same reason as head, and the typechecker doesn't know that your call to random will only result in 0 or 1 so if you make a mistake you'd get a crash
10:59:13 <bergmark> so better to randomize something (Bool) that can only have two values
10:59:14 <Welkin> indexing a list is a sign that you probably want an array
11:00:02 <Welkin> :t (!?)
11:00:03 <lambdabot>     Not in scope: â€˜!?â€™
11:00:04 <lambdabot>     Perhaps you meant one of these:
11:00:04 <lambdabot>       â€˜!!â€™ (imported from Data.List), â€˜!â€™ (imported from Data.Array),
11:00:09 <Welkin> :t (Data.Vector.!?)
11:00:10 <lambdabot> Data.Vector.Vector a -> Int -> Maybe a
11:01:44 <ReinH> lf94: I annotated with another option using Applicative http://lpaste.net/4003672671135989760
11:02:17 <ReinH> Oops, error in that one. Can I not edit annotations inline? Oh well, http://lpaste.net/6500968301449969664
11:02:32 <phaazon> hey, when I have, in a prof trace, both the inherited %time and individual time set to the same value (84%), does it mean Iâ€™ve found the bottleneck?
11:03:03 <benzrf> phaazon: probs
11:03:17 <phaazon> http://lpaste.net/7470460729326305280
11:03:39 <phaazon> so, that means that pretty _all_ %time of my application is spent in swapBuffers from GLFW
11:03:45 <phaazon> thatâ€™s interesting
11:04:04 <benzrf> wooo
11:04:41 <phaazon> I guess that means my programm is pretty okay, right?
11:04:44 <ReinH> phaazon: or it means that GHC didn't add cost centers to something
11:04:45 <phaazon> or I donâ€™t get it
11:04:55 <phaazon> ReinH: what do you mean?
11:05:11 <phaazon> ReinH: see the complete prof trace:
11:05:37 <ReinH> I mean that GHC might not be adding cost centers to expressions inside GLFW.swapBuffers
11:05:40 <ReinH> So you don't get to see it broken down
11:05:48 <phaazon> ReinH: http://lpaste.net/119530
11:05:49 <phaazon> oh yeah
11:05:53 <phaazon> but itâ€™s not my lib
11:06:02 <phaazon> I have pretty bad FPS
11:06:08 <phaazon> and Iâ€™m inquiring around
11:06:40 <jtanguy> bergmark lf94: pushing further into randomizing a Bool, why not `fmap coin randomIO >>= print` directly ?
11:06:58 <rasen> Is there non-blocking IO? Or I should use forkIO every time?
11:07:00 <lf94> no idea
11:07:08 <lf94> jtanguy, because I'm a noob
11:07:22 <phaazon> I get pretty bad FPS, I donâ€™t know why
11:07:26 <lf94> coin is a haskell function?
11:07:31 <phaazon> maybe I should inquire about shaders nowâ€¦
11:07:37 <rasen> I need non-blocking write to file
11:07:51 <jtanguy> no, the coin function defined in  http://lpaste.net/119528
11:09:48 <hiptobecubic> rasen, forkIO should be fine as long as you don't care about the result (or are willing to start passing around mvars)
11:11:36 <rasen> hiptobecubic: I just want to take piece out of TChan and write it to file.
11:12:27 <Craig_> Can someone give me advice in looping through a list?
11:13:03 <rasen> Craig_: It depends on what do you want to do with elemens
11:13:55 <rasen> In case you want perform some IO with each element there is forM_
11:13:58 <rasen> :t forM_
11:13:59 <Craig_> rasen: getValueForKey (x:xs) = [fst x | x <- xs, snd x == "key"]           I am looping through a list of tupples looking for the value for that key but it always skips the first tuple in the list
11:13:59 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
11:14:36 <rasen> :t lookup
11:14:38 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
11:14:52 <hiptobecubic> Craig_, you are matching against the list with (x:xs), but the right hand side ignores that 'x'
11:15:18 <hiptobecubic> because you immediately shadow that name with your (x <- xs) part, which then takes elements from xs, which is the tail of the original list
11:15:30 <jtanguy> lf94: i'm sorry if my answer sounded pretentious, I can explain my answer in detail if you want
11:15:41 <hiptobecubic> > let f (x:xs) = xs in [1,2,3]
11:15:42 <lambdabot>  [1,2,3]
11:16:00 <hiptobecubic> > let f (x:xs) = [x | x <- xs] in f [1,2,3]
11:16:02 <lambdabot>  [2,3]
11:16:13 <hiptobecubic> > let f (x:xs) = xs in f [1,2,3] -- oops, redoing the first one :)
11:16:14 <lambdabot>  [2,3]
11:16:58 <rasen> > let f xs = [x | x <- xs] in f [1,2,3] -- I bet you want this
11:17:00 <lambdabot>  [1,2,3]
11:17:06 <hiptobecubic> right.
11:17:27 <hiptobecubic> Craig_, ^
11:17:57 <Craig_> Thank you! I will see if I can get it to work now
11:19:05 <lf94> jtanguy, I guess I don't understand fmap
11:19:35 <rasen> lf94: you know what map does?
11:20:05 * pothepanda is looking for a good tavern name
11:20:19 <lf94> yea
11:20:21 <Ainieco> wow, it's crazy how many people that chan has now - ~1500, it was <1000 when i first joined
11:20:50 <rasen> lf94: fmap is a generalized map. map works for lists only, while fmap can work with other types too
11:21:13 <rasen> It applies function to values inside container.
11:22:18 <jtanguy> yep. in my example, randomIO has the type IO Bool
11:22:32 <sdegutis> What's the latest conclusion on whether we should specify main :: IO () ?
11:22:42 <sdegutis> Or is it just a matter of taste, and not a question of best-practice?
11:23:01 <EvanR> there is a taste that says dont put it? ;)
11:23:06 <EvanR> why
11:23:35 <rasen> Sometimes, it's not IO ()
11:23:54 <clrnd> seriously? -Wall says to put IO () specifically
11:24:00 <EvanR> it might as well be ()
11:24:05 <EvanR> or IO a
11:24:17 <clrnd> can it be Int?
11:24:26 <EvanR> it wont work like you think
11:24:36 <lf94> nice
11:24:37 <jtanguy> lf94: and since IO is an instance of Functor, which means we can fmap functions on it like on lists
11:25:35 <tac_> Maybe we should go around calling it the "IO functor"
11:25:39 <EvanR> main is an IO action executed only for its effects
11:25:40 <tac_> instead of the "IO monad"
11:26:32 <clrnd> i always say the IO lens
11:26:40 <sdjfio> Hi im getting an erro 'No instance for (ToJSON Text)' with aeson
11:26:47 <rasen> tac_: monad is more concrete
11:27:08 <sdjfio> what do?
11:27:09 <glguy> sdjfio: Do you have multiple versions of the text package installed? ghc-pkg list text
11:27:25 <sdjfio> glguy: yes sir
11:27:48 <sdjfio> what do?
11:27:51 <joseph__> hi
11:28:00 <jtanguy> IO can be many things. in lf94's example, we need it to be a functor because we want fmap and a monad because be sant (>>=)
11:28:02 <glguy> sdjfio: Your problem is that you have multiple versions of text installed and that your "aeson" package isn't using the same one as the one that defines the Text value you have
11:28:07 <benzrf> @google io monad considered harmful
11:28:09 <lambdabot> http://blog.jle.im/entry/io-monad-considered-harmful
11:28:09 <lambdabot> Title: IO Monad Considered Harmful Â· in Code
11:28:14 <glguy> sdjfio: You should compile your packages against the same version of text
11:28:27 <tac_> rasen: eh,,, I would not say I agree with that :)
11:28:32 <sdjfio> glguy: do i delete one of the packages?
11:28:32 <sdjfio> glguy: i am using runhaskell
11:28:51 <lf94> jtanguy: your example is just mind blowingly awesome.
11:29:01 <lf94> The fact you could improve my 4 lines is amazing to me.
11:29:30 <sdjfio> glguy: ok i use ghc-package unregister - it work
11:29:43 <rasen> tac_: every Monad is Functor, but not every Functor is Monad. Monad is subclass of Functor
11:29:56 <jtanguy> it also has some inconvenients: you need to understand how fmap and >>= works to understand my code
11:30:41 <clrnd> has anyone used Cloud Haskell to do something useful?
11:33:52 <jtanguy> benzrf: true. we should not say the IO monad. I try my best to say at most that IO implements Monad
11:33:54 <RyanGlScott> edwardk: Is your indexed library (https://github.com/ekmett/indexed) on Hackage?
11:34:41 <jtanguy> IO is a concrete type, and Monad is a Typeclass
11:34:50 <EvanR> functorial IO isnt enough of a model for the IO language, applicative IO is historically newer than monad IO
11:35:04 <EvanR> so "monadic IO" is still talking about something
11:35:55 <jtanguy> yes, but "monadic IO" is not the same as "the IO monad"
11:36:23 <EvanR> reactions to peoples confusion over IO vary wildly, sometimes i think it would be appreciated in this channel if haskell just had no IO anymore ;)
11:36:26 <EvanR> who needs it
11:36:27 <jtanguy> "the IO monad" has as much sense as "the IO show"
11:37:37 <EvanR> "the T C" is common usage for talking about the main instance of something in some class
11:37:58 <EvanR> like "the list monad"
11:38:04 <EvanR> theres not one list monad
11:38:25 <EvanR> but i dont think thats the gripe with IO
11:39:12 * jtanguy realizes that his last sentence is only confusing, and false
11:39:18 <enthropy> in what sense is there more than one list monad?
11:39:23 <MP2E> IO is a type, the fact that it is an instance of Monad is not really relevant to doing IO actions. The idea that to do anything useful you need to use the 'IO Monad' leads to confusion for new users and is generally seen as an issue. As I've seen put many times, "I need to know Category Theory just to print something to the screen?"
11:39:55 <pdxleif> a list monad could be a product, or a zip?
11:39:59 <MP2E> Obviously the concept is important, but I can see the objection to 'IO Monad'
11:40:19 * enthropy reads "the list monad" as the functions defined after "instance Monad []"
11:40:29 <rasen> Probably, we should say IO type?
11:40:33 <MP2E> ^
11:40:33 <MP2E> yes
11:40:37 <shachaf> I don't know any other possible Monad instance for []
11:40:55 <EvanR> maybe im wrong
11:41:45 <zwer> MP2E how is monad instance for IO not relevant when you can't do something as simple as taking a line and printing it without resorting to it?
11:41:56 <rasen> That makes sense because it's possible to do things without return and >>=. Not that much, but it's possible
11:42:14 <exio4> using what?
11:43:30 <EvanR> a function ioBind :: IO a -> (a -> IO b) -> IO b ;)
11:44:34 <[swift]> i dunno, i always thought the argument was that it's not necessary to understand monads in their generality to understand how to use do-notation with IO
11:44:37 <MP2E> EvanR: exactly. This implements bind for IO sure
11:44:46 <MP2E> but the user needn't know what a Monad is to use it
11:44:48 <MP2E> same with do notation
11:44:55 <[swift]> you may still be using the IO Monad, but you don't need to understand monads generally
11:45:16 <MP2E> understanding Monads is important to greater understanding of the language and the use of abstractions in libraries
11:45:22 <MP2E> but for IO? eh
11:45:23 <EvanR> i cant seem to find a proof or counterexample of the uniqueness of lists monad
11:45:36 <haasn> shachaf: There's at most one possible Monad instance per type, or something, right?
11:45:42 <MP2E> further reading, pardon the clickbait title : http://blog.jle.im/entry/io-monad-considered-harmful
11:45:42 <shachaf> haasn: No.
11:45:59 <EvanR> MP2E: kind of "unfortunate" though, to use some basic control structures in IO you must import Control.Monad (foo)
11:46:01 <shachaf> haasn: For instance there's a Monad instance for (w,) for each Monoid instance for w.
11:46:02 <[swift]> it's similar to how on your first day of writing java, "public static void main()" is just a bunch of boilerplate
11:47:41 <haasn> shachaf: Oh, of course
11:47:59 <haasn> Like Sum and Product, resulting in different Monad behavior
11:48:05 <EvanR> Monoid*
11:48:34 <merijn> zwer: If GHC simply exported "andThen :: IO a -> (a -> IO b) -> IO b" you could do IO without needing it's monadness at all
11:48:43 <MP2E> EvanR: actually they mean Monad here. The Monad uses the Monoid instance, so it's a different Monad per Monoid
11:48:47 <merijn> zwer: And then you'd just have "(>>=) = andThen"
11:48:55 <EvanR> oh
11:49:12 <jtanguy> you don't say "Use the (Either String) Monad to deal with functions that can fail with a message"
11:49:50 <zwer> merijn sure, but that is how things could have been, not how things are.
11:49:51 <EvanR> merijn: which makes sense to me how to set it up anyway, instead of having the instance never seen or incomprehensible, abstract
11:50:30 <ReinH> EvanR: It's still abstract. You're just adding indirection.
11:50:40 <EvanR> the IO type is
11:50:44 <EvanR> the Monad instance doesnt need to be
11:51:08 <EvanR> it might help understanding
11:51:25 <DerisiveLogic> Hey anyone knows how to fix this by any chance?
11:51:29 <DerisiveLogic> lambdabot-4.3.0.1 depends on regex-pcre-0.94.4 which failed to install.
11:51:41 <DerisiveLogic> I keep running into that, it won't let me install the rest for some reason.
11:52:51 <elzair> Is there an easy way to find the module wherein a given function is defined using only local tools (i.e. no hoogle)?
11:53:06 <Hijiri> [swift]: yes, public static void main doesn't compare to the real boilerplate java can give you
11:53:19 <jtanguy> elzair: you can use hoogle locally
11:53:35 <elzair> I am having trouble finding a function `bindir'
11:55:16 <Craig_> hiptobecubic: Is there a way to do   let f xs = [x | x <- xs] in f [1,2,3]   using recursion?
11:55:45 <Hijiri> that just looks like id
11:56:01 <jtanguy> DerisiveLogic: what `cabal install regex-pcre` gives you ?
11:56:30 <elzair> :t relDir
11:56:31 <lambdabot> Not in scope: â€˜relDirâ€™
11:56:40 <DerisiveLogic> jtanguy: cabal: Error: some packages failed to install:
11:56:40 <DerisiveLogic> regex-pcre-0.94.4 failed during the building phase. The exception was:
11:56:40 <DerisiveLogic> ExitFailure 1
11:57:05 <koala_man> Craig_: do you mean  let f (x:xs) = x : f xs; f [] = [] in f [1,2,3]  ?
11:57:35 <DerisiveLogic> jtanguy: I just manually downloaded, any idea as to what directory to put it in? Would that even help?
11:57:54 <jtanguy> hum. does anyone knows if regex-pcre depends on alex or happy ?
11:58:06 <elzair> This is weird. I know `bindir` is defined in Distribution.Simple.LocalBuildInfo in the Cabal package.
11:58:27 <elzair> However, I can only find one reference to it in the code: https://hackage.haskell.org/package/Cabal-1.22.0.0/docs/src/Distribution-Simple-LocalBuildInfo.html
11:58:28 <Clint> jtanguy: it doesn't
11:58:39 <elzair>         relDir | executable = bindir installDirs
11:58:39 <elzair>                | otherwise  = libdir installDirs
11:58:39 <elzair>  
11:59:03 <elzair> Can someone who knows Haskell better than I tell me what is going on?
12:00:46 <Clint> elzair: is relDir the name of your function?
12:01:36 <jtanguy> DerisiveLogic: you could just build your downloaded regex-pcre. It should give you more info on any error
12:01:37 <merijn> elzair: What exactly is the question?
12:02:05 <elzair> I just want to find where bindir is defined.
12:03:29 <elzair> the relDir stuff was the only place it was referenced.
12:04:53 <Craig_> koala_man: recursion key (x:xs)        | key == [x] = ["Found"]        | otherwise = applyToList key xs
12:07:26 <Craig_> Is there a way to use recursion to loop through a list to see if the element is found?
12:07:46 <indiagreen> elzair: http://hackage.haskell.org/package/Cabal-1.22.0.0/docs/src/Distribution-Simple-InstallDirs.html#InstallDirs
12:07:54 <indiagreen> bindir is a field of InstallDirs
12:08:10 <indiagreen> and, being a field, it's also automatically made a record selector function
12:08:53 <indiagreen> I found it by hayoo-ing â€œbindirâ€, which brought me directly to: http://hackage.haskell.org/package/Cabal-1.22.0.0/docs/Distribution-Simple-InstallDirs.html#v:bindir
12:14:19 <EvanR> Craig_: find
12:14:32 <EvanR> :t find
12:14:33 <lambdabot> (a -> Bool) -> [a] -> Maybe a
12:15:49 <MP2E> That's neat
12:15:58 <MP2E> Data.Foldable has a generalized version, too.
12:16:51 <obb> what is the most simple way of splitting a string?
12:17:28 <Clint> (x:xs)
12:17:55 <obb> do i really need to rewrite this?
12:18:05 <sdegutis> Is there a decently designed and reasonably performant ORM-type thing for using databases in Haskell which several people can vouch for?
12:18:10 <sdegutis> Thanks in advance, regards.
12:18:33 <vanila> how do I write a function given its able in haskell?
12:18:42 <vanila> rather than as a flat list of equations
12:18:47 <sdegutis> vanila: I don't comprehend your question.
12:21:18 <Craig_> EvenR: If I have a list of keys that I am checking against a list of values would that work?
12:24:00 <sdegutis> Hello. Anyone have an answer possibly?
12:24:05 <sdegutis> (Does)
12:24:55 <merijn> vanila: Nested cascade of case-of matches
12:25:02 <merijn> vanila: That's what it translates too
12:26:31 <koomi> sdegutis: esqueleto and persistent are popular
12:26:55 <clrnd> sdegutis, persistent by YesodÂ© is mainstream
12:27:10 <sdegutis> Thanks.
12:28:01 <sdegutis> It seems like monads would lend themselves very well to building SQL statements/queries.
12:28:48 <elzair> indiagreen: Thank you so much!
12:29:25 <exio4> sdegutis, I really liked HaskellDB (+ chrisdone's(?) template haskell)
12:31:15 <sdegutis> Are hashmaps/dictionaries difficult or awkward to use in Haskell?
12:31:18 <dfeuer> When (if ever) is it useful to make a zipper's type depend on its depth of unzippedness?
12:31:20 <sdegutis> exio4: thanks
12:32:21 <kadoban> sdegutis: They seem pretty painless to me.
12:33:26 <Craig_> :t quit
12:33:27 <lambdabot>     Not in scope: â€˜quitâ€™
12:33:27 <lambdabot>     Perhaps you meant â€˜quotâ€™ (imported from Prelude)
12:33:37 <clrnd> sdegutis, they are far better than maps in any language I've tried (but that's my oppinion)
12:33:39 <Craig_> :t :q
12:33:40 <lambdabot> parse error on input â€˜:â€™
12:35:11 <sdegutis> :q
12:35:12 <kadoban> The only complaint I have about them is that the function arguments in like Data.Map are often in the wrong order for convenient usage.
12:35:24 <sdegutis> kadoban: oh
12:36:11 <kadoban> But, a simple 'flip' fixes it all up *shrug*. It's not a big deal.
12:37:33 <sdegutis> I didn't realize Haskell was so big on virtue.
12:37:38 <sdegutis> pure = Just
12:39:21 <SrPx> I am trying to benchmark a function using criterion, but it complains "V3 Float" has no instance for NFData. How do I fix it? Do I need to write an instance for V3 myself, or can I somehow tell GHC to derive it?
12:40:04 <kadoban> sdegutis: Hah
12:40:08 <sdegutis> :)
12:40:26 <sdegutis> Is xmonad's source code an example of really high quality Haskell code?
12:41:12 <Clint> SrPx: you can probably tell ghc to derive it
12:41:19 <kadoban> I've heard it given as an example of good code before.
12:41:29 <SrPx> How?
12:41:44 <Clint> SrPx: what's V3?
12:43:02 <SrPx> Sorry, it is Linear's V3
12:43:46 <Clint> SrPx: instance NFData a => NFData (V3 a)
12:44:38 <SrPx> just add that line anywhere? It still says: No instance for (deepseq-1.3.0.2:Control.DeepSeq.NFData (V3 Float))
12:45:05 <Clint> SrPx: in your criterion benchmark source file, i'd think
12:47:02 <SrPx> it doesn't work... nevermind I give up of this test
12:47:28 <SrPx> even with the complete definition, "instance NFData a => NFData (V3 a) where rnf (V3 a b c) = rnf a `seq` rnf b `seq` rnf c", Haskell still complains
12:47:51 <Clint> SrPx: are you somehow not importing the NFData instance for Float?
12:48:02 <SrPx> how could I be doing that...
12:48:18 <Clint> i don't know
12:48:42 <SrPx> typeclasses are a great idea, they said
12:48:44 <geekosaur> wait, that instance with a fullly qualified complaint? I wonder if you have multiple versions of deepeq installed
12:48:58 <zwer> SrPx did you paste the code somewhere?
12:49:08 <geekosaur> and you're defining an instance in one but something is trying to use it from the other (mmm, diamond dependencies)
12:49:15 <Clint> good call
12:53:48 <sdegutis> Do a lot of people come here from Clojure to learn Haskell?
12:55:12 <SrPx> I have what? I'll paste the code
12:55:15 <SrPx> a sec
12:55:26 <mmachenry> sdegutis: I didn't but I came from Scheme, which is close in a way.
12:55:29 <merijn> sdegutis: Used to be a lot of python people, nowadays Scala (because Scala is hard!) and I expect lots of Swift in the near future :)
12:56:56 <SrPx> http://lpaste.net/119540
12:57:19 <SrPx> am I missing something obvious?
12:57:46 <kyclark> WRT http://lpaste.net/119539
12:57:54 <kyclark> i'm trying to understand partial application
12:58:03 <kyclark> my "d" works, but d' does not
12:58:12 <phaazon> is there a way to display little floats in a non-scientific way?
12:58:24 <kyclark> would love a point in the right direction
12:58:25 <Clint> SrPx: ghc-pkg list | grep deepseq-
12:58:27 <phaazon> i.e. not 7e-3, but 0.007
12:58:39 <glguy> kyclark: https://wiki.haskell.org/Monomorphism_restriction
12:59:35 <SrPx> I have "1.3.0.2" and "1.4.0.0", how do I remove one?
12:59:48 <kyclark> ah, so i add "d' :: [Int] -> IO ()" and it works then!
13:02:20 <lpsmith> @tell simg I don't know too much about postgresql's money type,  but see http://hackage.haskell.org/package/postgresql-simple-0.4.9.0/docs/Database-PostgreSQL-Simple-FromField.html
13:02:20 <lambdabot> Consider it noted.
13:02:23 <xyz`> I'm looking for a hand with how one can express something in the Haskell type system.
13:02:23 <xyz`>  
13:02:26 <xyz`> I have a class A. I have some function f which can be implemented for all instances of A. I want to be able to provide custom implementations for f per data type.
13:02:26 <xyz`> So far adding f to A would do. Except I might have many such functions. And I don't want to reflect which functions I used into the type.
13:02:32 <xyz`> How can I allow someone to provide specific f implementations when desired, while at the same time not reflect the fact that f is being used in the type of the call site?
13:04:49 <S11001001> xyz`: the fact that your argument is of type A (i.e. the type that the class gives rise to) or a subtype thereof reflects this fact that you wish to suppress, namely, "this might call f".
13:05:08 <S11001001> xyz`: So I'm afraid your request would violate safety quite severely.
13:05:53 <xyz`> S11001001: If I provide a default implementation for f forall As, why would it violate safety?
13:06:29 <vanila> why dont you jst make one typeclass per function
13:06:29 <S11001001> xyz`: because there is no way to figure out when you would use another implementation than the default one
13:06:50 <S11001001> xyz`: Now, if you are willing to give up on "the type can't say f might be used on this a type", the solution is straightforward, and I assume you are familiar with it.
13:06:52 <vanila> since you don't wantto put them all in one
13:07:02 <xyz`> S11001001: Sure, I can put in a typeclass
13:07:38 <S11001001> xyz`: But your request is more like "I want to create class A with method f, but have f appear on Object/Any/whatever, not just subtypes".
13:08:19 <xyz`> S11001001: Well, if I put f in A then I don't have an issue. It's more like, I have A which can implement f but sometimes I want to provde a better implementation
13:08:43 <xyz`> S11001001: And I want to hide the fact that this might use a better implementation
13:08:58 <S11001001> xyz`: then use a typeclass.  This satisfies your request.
13:09:06 <geekosaur> typeclasses do that automatically. but you need to specify class A being used, so it can pass through the information that tells it (internally) where to find type siecific implementations
13:09:18 <glguy> SrPx: Once the build passes I'll push linear-1.16.2 with NFData instances
13:09:23 <geekosaur> you cannot tell at the Haskell level whether a type specific or default implementation is used
13:09:27 <xyz`> S11001001: Except that if I use a typeclass the fact that f is used will be reflected in the type. Shouldn't it be sufficient that the type tells me that A is used?
13:09:45 <SrPx> thanks, I was going to actually do it
13:09:57 <SrPx> I managed to get it to compile but criterion results are obviously wrong
13:10:06 <xyz`> It would be too limiting to have a typeclass for every single function that I could provide a better implementation for if I knew something more about my type
13:10:22 <xyz`> And to have that constraint propagate outward through every caller
13:10:43 <vanila> athis seems awfully hypothetical
13:10:49 <xyz`> vanila: It's not
13:12:38 <xyz`> Imagine that you have a class Graph, and you realize that MST can be implemented extremely efficiently for a particular kind of graph
13:12:54 <xyz`> You don't want to update Graph to include mst as a function that you can provide a definition for
13:13:18 <xyz`> And the constraint Graph already appears in the type, that should be sufficient to say that some mst definition will be valid
13:14:06 <vanila> I would have two functions: normal mst and mst' that's fast for the special graph
13:14:36 <xyz`> vanila: Then my code will only work for particular datatypes. I'd like to keep it generic
13:15:18 <ReinH> What do you mean by "does not work"?
13:15:23 <ReinH> Woops, never mind
13:16:33 * hackagebot linear 1.16.2 - Linear Algebra  http://hackage.haskell.org/package/linear-1.16.2 (EricMertens)
13:16:56 <xyz`> S11001001: But I'm curios if you have a moment. Do you still think this violates some form of type safety?
13:17:01 <xyz`> S11001001: And can you explain why?
13:17:33 <merijn> xyz`: It violates parametricity, how can GHC know/show that your code requires that class if you don't mention it in the type?
13:19:22 <xyz`> merijn: Why would it violate parametricity? If I provide a default for f all As (which I can write)
13:19:24 <glguy> SrPx: linear-1.16.2 it out now
13:19:41 <SrPx> glguy: thanks <3
13:19:46 <merijn> xyz`: How is GHC supposed to "find" this default?
13:19:54 <SrPx> awesome
13:20:04 <merijn> xyz`: Also, typeclass instances can't overlap, so you can't write such a default without overlapping with everything else
13:21:17 <xyz`> merijn: Right, so that's why I'm asking how I might express this.
13:21:27 <sdegutis> Could it be said that the speed of a Haskell is generally comparable to Java but often closer to C, given a program roughly equivalent yet idiomatic for the language?
13:21:32 <SrPx> hmm to update a package I just do "cabal install package" again?
13:21:34 <sdegutis> *of a Haskell program
13:21:37 <xyz`> merijn: Overlap isn't the problem
13:21:55 <glguy> SrPx: You should unregister the old one, then you can "cabal update" to refresh your cache and then "cabal install linear"
13:22:05 <glguy> "ghc-pkg unregister linear-1.16.1" for example
13:22:13 <xyz`> merijn: You can actually express everything using typeclasses if you allow (the very nasty) undecidable instances. But it obviously does the wrong thing
13:22:31 <carter> i sometimes just rm ~/.ghc because its imspler :)
13:22:36 <SrPx> ah sure, forgot cabal update. thanks! :)
13:26:24 <merijn> xyz`: It "obviously does the wrong thing", because you can't really overlap in a sensible way.
13:27:29 <merijn> Anyway, the correct answer here is really "you shouldn't try to do that", your questions are a bit to vague to really answer, but it sounds like you're using to use typeclasses to, essentially, do OO, which won't work because they're not suited for that
13:27:49 <xyz`> merijn: I made my question more specific later on
13:28:03 <xyz`> merijn: I have a graph and want to provide mst for a particular graph implementation. This isn't OO-related
13:28:17 <dfeuer> Ping edwardk.
13:28:57 <geekosaur> then you should presimably have a Graph typeclass where you can provide a default implementation and allow instances to define their own
13:29:23 <xyz`> geekosaur: This only works for a small number of algorithms. You can't put every graph algorithm you might ever want into a graph typeclass
13:29:46 <vanila> I think you can make one typeclass per function
13:29:53 <merijn> I don't really see how any of thise necessitates typeclasses at all
13:30:00 <xyz`> vanila: But then it's reflected in the type of the caller
13:30:00 <geekosaur> haskell isnt ruby, you can't hide a default in some base class
13:30:19 <vanila> I don't really understand waht that means about 'reflected', could you explain a little?
13:30:25 <geekosaur> and if it's not reflected in the type of the caller, the code *can't get to it*
13:31:48 <glguy> xyz`: If the implementation of a function varies depending upon the choice of a type, that must be represented as a constraint on the type
13:31:48 <xyz`> vanila: If you make a typeclass MST and a typeclass BFS, and use mst and bfs in a function your constraints will contain (Graph a, MST a, BFS a)
13:31:57 <timpani_> Is there a handy implementation for a simple thread-safe queue? Data.Concurrent.Deque.Class doesn't seem to offer any (its one instance is "strawman"), and a web search doesn't seem to produce much else...
13:32:00 <vanila> do you mean like,  algorithm = .... use various functions ....,  will end up with  Mst graph, Dijkstra graph => ... etc in the type?
13:32:13 <glguy> when you have a type signature with out a constraint on a variable you know that the implementation does not vary by the choice of your type
13:32:23 <xyz`> glguy: Right, I totally accept that
13:32:34 <glguy> OK, cool :)
13:32:53 <vanila> xyz`, ok im with you - why is this bad? also you can just give it a concrete type and all the typeclass stuff will be reolved and not show up in the types
13:33:17 <xyz`> glguy: If I have something like that graph example, why can't I simply say (Graph a) if I can find a mechanism to say that all graphs will have an mst
13:33:48 <xyz`> glguy: This satisfies the requirement that all functions carry the typeclass
13:33:58 <vanila> Haskell doesn't have subclasses like that
13:34:01 <merijn> timpani: Just Control.Concurrent.Chan?
13:34:11 <merijn> timpani: Assuming you want something to read/write concurrently
13:34:18 <merijn> timpani: That or TQueue
13:34:34 <dfeuer> @Ask edwardk Some example uses of Data.Sequence.Lens.sliced seem likely to be a good bit slower than versions taking advantage of the finger tree structure. Can/should something be done about that, with support from containers? I'm thinking especially of that fromList [....] & sliced m n $~ f   example.
13:34:35 <lambdabot> Consider it noted.
13:34:49 <merijn> xyz`: Then you need to express your algorithm solely in terms of the abstractions provided by Graph
13:35:01 <timpani> merijn: thanks.
13:35:12 <merijn> xyz`: You say "I can find a mechanism to say that all graphs will have an mst" <- what mechanism would that be?
13:35:42 <EvanR> finite graphs?
13:35:45 <xyz`> merijn: Right. That's what I'm asking.
13:36:28 <vanila> my understanding is that you have a special implementation of mst for a specific kind of graph
13:36:44 <vanila> not that you want to use the general mst derived from basic graph operations
13:37:19 <merijn> xyz`: There is no such mechanism. Either you store it in a datatype as a first class function, or you look it up via a typeclass constraint
13:37:23 <merijn> xyz`: Those are your options
13:38:46 <EvanR> xyz`: you could define a "mst interface" such that types that can compute their mst implements this interface
13:38:51 <EvanR> including graphs, or whatever
13:39:38 <EvanR> T a -> Mst a
13:40:09 <edwardk> Pong dfeuer
13:40:25 <vanila> oh hey edwardk , I enjoyed your yow slides
13:40:39 <edwardk> dfeuer: sliced is pretty awful performance wise, its mostly a theoretical toy
13:40:43 <dfeuer> Ah.
13:40:48 <edwardk> vanila: thanks. they should have video up soon
13:40:59 <xyz`> merijn: That's unfortunate. It would be nice to have a better mechanism. I don't see conceptutally why this wouldn't work
13:41:26 <EvanR> your polymorphism has to make sense before it can be made a mechanism
13:41:28 <edwardk> dfeuer: you might be able to come up with a fancier implementation though
13:41:37 <edwardk> it does get to assume the slice is the same size or something i think?
13:41:40 <dfeuer> edwardk, I was just thinking that the bit when you map a function over part of a sequence could probably be made very fast for Seq. I don't know about the rest.
13:42:02 <dfeuer> I also don't know if thhat's useful.
13:42:29 <dfeuer> But the idea would be to refrain from copying the subtrees that don't change.
13:42:51 <edwardk> sure
13:43:03 <edwardk> we might be able to do that anyways
13:43:05 <edwardk> hrmm
13:43:07 <dfeuer> While also having an "fmap-like" descent.
13:43:39 <edwardk> well the 'traverse-like' descent also works
13:43:44 <edwardk> its the same kind of thing
13:43:46 <edwardk> shape doesn't change
13:44:03 <dfeuer> Ah, yes, I see.
13:44:06 <dfeuer> Sort of.
13:44:08 <dfeuer> :-)
13:44:22 * dfeuer kind of sort of understands traversals.
13:44:41 <edwardk> fmap doesn't change shapes, traverse doesn't either
13:44:49 <dfeuer> edwardk, but whatever your thingum does sometimes *extracts* a slice.
13:44:59 <edwardk> well, it walks a slice
13:45:02 <edwardk> it could be smarter
13:45:10 <dfeuer> Hmm?
13:45:25 <dfeuer> edwardk, I'm wondering if the documentation is buggy.
13:45:27 <edwardk> it could traverse using a custom applicative that tracked its position in the structure, and which lifted an action
13:45:43 <edwardk> sliced :: Int -> Int -> IndexedTraversal' Int (Seq a) a
13:45:56 <edwardk> it is a traversal of the elements that fall within the slice
13:46:07 <edwardk> it doesn't give a sub-sequence, it gives the elements in that sub-sequence
13:46:11 <edwardk> another version would be
13:46:36 <edwardk> sliced' :: Int -> Int -> IndexedTraversal' Int (Seq a) (Seq a) -- which would extract the subsequence as a Sequence itself
13:46:39 <edwardk> but that we don't have
13:46:41 <dfeuer> So what is that first example of slicedTo doing?
13:47:11 <dfeuer> Oh....
13:47:15 <dfeuer> I see now, that's a list!
13:47:17 <dfeuer> Duhhhh
13:47:19 <edwardk> all three of those are implemented pretty inefficiently
13:47:23 <edwardk> we could work smarter
13:47:34 <edwardk> e.g. see Taking and Dropping or whatever the data types are for taking and dropping
13:47:41 <edwardk> those could be applied to the normal traversal
13:48:09 <edwardk> alternately we might be able to use one of the generic combinators for manipulating them, hrmm
13:48:22 <dfeuer> What you talking about again?
13:48:57 <edwardk> let me see if the idea makes sense
13:49:35 <edwardk> eh replicateA doesn't quite work there
13:49:58 <edwardk> lessee
13:50:01 <edwardk> :t taking
13:50:02 <lambdabot> (Conjoined p, Applicative f) => Int -> Traversing p f s t a a -> Over p f s t a a
13:50:30 <edwardk> that manages to 'take' just a given number of elements from an arbitrary traversal
13:50:32 <dfeuer> OK, sure. My general thinking was that things like mapWithIndex (and I guess traverseWithIndex or whatever), when operating with a->a, can do a nice little "Do we touch anything in this subtree?" and if the answer is no, just reuse it.
13:50:38 <edwardk> :t dropping
13:50:39 <lambdabot> (Conjoined p, Applicative f) => Int -> Over p (Control.Lens.Internal.Indexed.Indexing f) s t a a -> Over p f s t a a
13:51:18 <edwardk> :t \ a b -> taking (b - a) . dropping a
13:51:19 <lambdabot> (Conjoined p, Applicative f) => Int -> Int -> Over p (Control.Lens.Internal.Indexed.Indexing (Control.Lens.Internal.Bazaar.BazaarT p f a a)) s t a a -> Over p f s t a a
13:51:34 <edwardk> :t \ a b -> taking (b - a) $ dropping a traverse
13:51:35 <lambdabot> (Traversable t, Applicative f) => Int -> Int -> Over (->) f (t b) (t b) b b
13:51:45 <edwardk> is that faster than sliced ?
13:52:11 <dfeuer> I do not even slightly understand what those types mean :-/
13:52:23 <edwardk> :t (\ a b -> taking (b - a) $ dropping a traverse) `asTypeOf sliced
13:52:24 <lambdabot> parse error on input â€˜slicedâ€™
13:52:28 <edwardk> :t (\ a b -> taking (b - a) $ dropping a traverse) `asTypeOf` Data.Sequence.Lens.sliced
13:52:29 <lambdabot> Applicative f => Int -> Int -> Over (->) f (Seq.Seq b) (Seq.Seq b) b b
13:52:48 <edwardk> same combinator much different implementation
13:52:57 <edwardk> should avoid a crap ton of intermediate copying
13:53:32 <edwardk> its taking 'traverse' for Data.Sequence, dropping the first 'a' results, then taking (b - a) of the ones that remain
13:53:46 <edwardk> not perfect, could be better
13:54:03 <dfeuer> The question is if I do something like blah & sliced 100000 1000010 %~ f, how much sharing will there be between the two trees?
13:54:28 <dfeuer> Pretend those numbers are close together, and in the middle of a huge sequence.
13:54:38 <edwardk> good question, hrm probably none
13:54:50 <edwardk> ok, yeah it'd need more access to Sequence internals
13:54:56 <edwardk> I don't see tibbe ever adding that though
13:54:57 <dfeuer> And I don't *think* Data.Sequence exports anything to accomplish it.
13:55:10 <dfeuer> So the question's whether it would be possible to expose something,
13:55:20 <dfeuer> without having to import your lensy classes.
14:00:51 <touchSpleen> > map even [1..5]
14:00:53 <lambdabot>  [False,True,False,True,False]
14:01:03 <touchSpleen> so cool...
14:02:09 <touchSpleen> :show imports
14:02:52 <aRISCfan> @help
14:02:52 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:02:58 <dfeuer> touchSpleen, lambdabot isn't GHCi.
14:03:26 <aRISCfan> @help list
14:03:26 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
14:05:23 <sdegutis> What IDE/editor/plugins do you use for Haskell?
14:06:23 <touchSpleen> dfeuer: interesting, I was curious how it knew the context for edwardk's lens :t commands
14:06:48 <ahammel> @sdegutis: Vim with a bunch of plugins
14:06:49 <lambdabot> Unknown command, try @list
14:07:05 <dfeuer> touchSpleen, I don't have a clue how to find out exactly what it offers.
14:07:12 <ahammel> d'oh! sorry lambdabot
14:07:18 <touchSpleen> sdegutis: vi with a repl plugin for ghci
14:09:02 <kadoban> sdegutis: vim with: syntastic, neocomplete, neosnippet, neco-ghc, vim2hs
14:09:16 <sdegutis> Wow lot of vim users here.
14:09:44 <kadoban> There's some emacs haskell mode thing too that people seem to like that I haven't tried so far.
14:09:51 <ahammel> specifically, these plugins: https://github.com/ahammel/dotconfig/blob/dnb/vim/package_list
14:11:08 <edwardk> touchSpleen: lambdabot has a specific set of commands it can run, but it doesn't have a way to see what imports are in scope, Control.Lens is one of them though.
14:13:16 <aRISCfan> @list
14:13:16 <lambdabot> What module?  Try @listmodules for some ideas.
14:13:30 <aRISCfan> @listmodules
14:13:31 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
14:14:05 <aRISCfan> @list help
14:14:06 <lambdabot> help provides: help
14:14:16 <aRISCfan> @help
14:14:16 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:14:27 <sdegutis> I installed haskell-mode for emacs and it gives an error every time I press enter lol.
14:14:38 <aRISCfan> @help help
14:14:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:16:41 <haskell-beginner> Hello, I tried implementing very simple code https://ideone.com/pdkS7d  on GHCi but I get parse error can anybody help me. I had made sure there are no extra spaces at the end of line also.
14:19:01 <geekosaur> ghci needs 'let' in front. as for the rest, selecting the whitespace tells me you used tabs to indent, which is a recipe for unhappiness
14:21:34 <haskell-beginner> thank you @geekosaur
14:21:37 <indiagreen> touchSpleen: I don't know where the actual file with lambdabot's imports is, but this is the most recent version I could find: http://lpaste.net/89790
14:22:03 <xandaros> I have a Maybe IO, is there an easy way to turn it into an IO Maybe?
14:23:19 <S11001001> xandaros: yeah, sequence from Data.Traversable
14:24:18 <hiptobecubic> how can you have a Maybe IO? Don't you need Maybe (IO a) ?
14:24:46 <xandaros> hiptobecubic: Yes, I was abbreviating
14:26:17 <S11001001> @ty Data.Traversable.sequence (undefined :: Maybe (IO Int))
14:26:19 <lambdabot> IO (Maybe Int)
14:26:36 * hackagebot satchmo 2.8.2 - SAT encoding monad  http://hackage.haskell.org/package/satchmo-2.8.2 (JohannesWaldmann)
14:27:03 <xandaros> Ah, thanks a lot. Why does it work?
14:31:36 * hackagebot obdd 0.3.2 - Ordered Reduced Binary Decision Diagrams  http://hackage.haskell.org/package/obdd-0.3.2 (JohannesWaldmann)
14:35:16 <erikd> anybody know what the story is with mtl vs transformers >= 0.4? a lot of packages won't build with transformers >= 0.4.
14:36:24 <dfeuer> Nice!
14:36:56 <S11001001> erikd: as a bridge you can use mtl 2.1.x with transformers-compat to get some of the 0.4 structures
14:37:32 <S11001001> erikd: but ghc pins transformers for users of doctests so we're probably sol until ghc 7.10
14:38:06 <cmccann> erikd: oh hey, are you "erikd" on reddit as well?
14:38:25 <erikd> cmccann: yes :-) why?
14:38:33 <erikd> S11001001: thanks!
14:39:55 <cmccann> erikd: are you aware that you appear to be shadowbanned? your user page isn't visible and it seems like 100% of your comments/submissions are removed by the spam filter.
14:40:08 <erikd> cmccann: WTF?
14:41:05 <cmccann> erikd: I dunno what it's all about but apparently it's a thing
14:41:40 <cmccann> anyway on /r/haskell the moderators have been approving all your comments/posts because there's obviously nothing wrong with them
14:43:07 <cmccann> erikd: shadowbanning is an admin-level thing and I really don't know what the details are, but I think that's what's going on. if you open a "private browsing" window or something and try to look at your user page you should get a "not found"
14:44:56 <erikd> cmccann: well, thanks! FFS i've been a reddit user for 7 years or something
14:45:17 <hiptobecubic> damn, that's rough
14:45:24 <cmccann> erikd: you can apparently appeal shadowbans and occasionally they're reversed
14:45:44 <cmccann> I think they're mostly automated to catch spammers and stuff
14:45:59 <cmccann> but I gather most people just make new accounts
14:46:37 * hackagebot aws-kinesis-client 0.2.0.2 - A producer & consumer client library for AWS Kinesis  http://hackage.haskell.org/package/aws-kinesis-client-0.2.0.2 (JonSterling)
14:48:31 <cmccann> erikd: anyway, figured I'd mention it. sadly us mere subreddit mods can't do anything about such things so I can't really help you beyond rescuing your comments from the spam filter.
14:53:08 <erikd> thanks cmccann. i've requested un-shadow-banning. lets see where that goes.
14:53:54 <jophish> Yo yo yo
14:54:16 <jophish> I'm having difficulty calling C in a dll from Haskell on windows
14:54:23 <cmccann> erikd: no need to thank me, having fewer false positives in the moderator queue would be reward enough ;P
14:54:32 <sssilver> hey guys, does haskell have a function calling convention using named parameters?
14:54:59 <sssilver> kinda like in Python we do foo(p1=1, p2=2, p3="3")
14:55:04 <indiagreen> no
14:55:21 <jophish> Is there anything obvious I should be looking out for. As soon as I make the foreign call the process jumps to 0x0000000000000000 and obviously crashes
14:55:51 <erikd> jophish: are you sure its a C function and not C++ ?
14:55:55 <sssilver> too bad, all function calls should always be called using named parameters :((
14:56:34 <indiagreen> why?
14:56:46 <erikd> sssilver: we have types for that
14:56:48 <sssilver> because sometimes your function signature changes
14:56:53 <jophish> erikd: yeah, declared in an extern C block, with dllexport
14:57:11 <indiagreen> when it changes, I usually get type errors everywhere it was used
14:57:16 <erikd> jophish: are you sure the DLL is loaded?
14:57:39 <sssilver> indiagreen: not if you had optional arguments
14:57:47 <indiagreen> and when I change it in such a way that there wouldn't be any type errors â€“ which happens really rarely â€“ I can grep
14:58:00 <indiagreen> well, no optional parameters in Haskell either
14:58:05 <indiagreen> or they are optional like Maybe
14:58:06 <erikd> jophish: i haven't used windows in a long time, but i do see to remeber something about LoadLibrary
14:58:12 <indiagreen> in which case it would change anyway
14:58:15 <jophish> erikd: oh, I assumed it was loaded automatically
14:58:50 <erikd> jophish: the NULL funciton pointer is the give away
14:59:16 <jophish> well, the odd thing is, if I get the same function as a FunPtr I get a valid address
14:59:25 <jophish> (although this could be a stub)
15:00:05 <erikd> sssilver: optional function parameters (like python) would not work with haskell' syntax or with haskell's partial function application.
15:00:09 <jophish> erikd: I'll give LoadLibrary a try
15:00:15 <jophish> thanks for the pointer
15:00:31 <sssilver> erikd: doesn't that create a lot of redundant/verbose code?
15:00:48 <erikd> sssilver: doesn't whay create ....
15:00:55 <erikd> s/whay/what/
15:00:56 <sssilver> erikd: lack of optional arguments
15:01:34 <indiagreen> sssilver: it does create redundant code (e.g. we have both sort and sortBy, and â€œByâ€ versions of many other functions, and also â€œsafeâ€ versions of many functions)
15:01:38 * hackagebot webpage 0.0.3 - Organized and simple web page scaffold for blaze and lucid  http://hackage.haskell.org/package/webpage-0.0.3 (athanclark)
15:02:03 <indiagreen> oh, and lazy/strict versions
15:02:18 <sssilver> well, doesn't that make everyone a sad panda?
15:02:20 <sssilver> kind of?
15:02:38 <erikd> sssilver: swings and roundabout. lack of optional args may be a small positive redundant code, but partial application (and other haskell features) results in less redundant code.
15:02:46 <cmccann> sssilver: for the most part, the Haskell approach is to have consistent argument types which may contain varying amounts of data
15:03:30 <vanila> you can define a function that takes some kind of mapping from keys to values, and fills in defaults when they aren'tsupplied
15:03:49 <sssilver> vanila: yeah, but that's redundant/unnecessary wrapping
15:03:57 <vanila> so you can buid your own optional/named args
15:04:00 <indiagreen> sssilver: well, sometimes it makes me sad, yes, but I know that getting this right while not accidentally destroying more important things is hard
15:04:54 <cmccann> sssilver: it doesn't really come up as often as you might expect.
15:05:35 <erikd> sssilver: i used to code quite a bit in python and i do not miss optional args. however my haskell code is very different to the code i used to write in python.
15:05:50 <cmccann> sssilver: worst-case scenario you can make a "FooParams" type that contains whatever combination of named/optional fields you want and/or provide a "default params" for people to use
15:06:07 <indiagreen> sssilver: the same way lots of things about Prelude make people sad pandas, but look at the current discussion of BBP on haskell-cafe to see how easy it is to break things by making things â€œmore rightâ€
15:06:32 <sssilver> interesting points
15:06:32 <indiagreen> and while you're there, read the thread about records proposals as well
15:06:38 * hackagebot keyword-args 0.1.0.4 - Extract data from a keyword-args config file format  http://hackage.haskell.org/package/keyword-args-0.1.0.4 (jsl)
15:09:43 * erikd really hopes we do get the BBP
15:09:46 * cmccann notes that if we end up with some sort of official anonymous records feature that basically gives us named parameters automatically
15:10:42 <cmccann> erikd: given that apparently a lot of library maintainers have already put in the work to make sure their code is ready for it I can't imagine total opposition to it will get very far
15:11:25 <SrPx> So, in Haskell, pretty much, anytime you write a new type using "data", you put yourself at "K * T" lines-of-code debt, where "K" is a constant and "C" is the number of typeclasses you actively use? Which, in other words, means that there is a quadratic code-size blowup in function of the number of types T and typeclasses C used... LOC > k * T * C
15:12:08 <cmccann> SrPx: most types don't need to be a member of every type class
15:12:23 <cmccann> very few types CAN be a member of a large number of type classes, really
15:12:34 <cmccann> and most of the nearly-universal ones are the ones you can derive automatically
15:12:42 <erikd> cmccann: that's my hope. the standard prelude has been painful for such a long time imo.
15:12:57 <mmachenry> SrPx: In fact many types won't need any non-derivable and most will only need a couple of type classes.
15:13:06 <cmccann> erikd: the AMP is a bigger deal imo.
15:13:23 <erikd> cmccann: hell yes, but we already have that :-)
15:13:33 <SrPx> cmccann: but they need of many of them. For example, "NFData" is required for any type I ever intend to use inside my Trees, if I want to benchmark them. So, for **each** new geometric datatype I add (such as: data Sphere = Sphere (V3 a) a), I already am in a debt of 2 lines of code to add the NFData instance.
15:13:47 <cmccann> I can use my own Prelude if I want (and in fact I do) but there was no workaround for lack of AMP
15:13:53 <erikd> cmccann: although its a pity we didn't get <$> and <*> as part of AMP
15:13:59 <jophish> erikd: It works from ghci using -lmylibrary, so I think you were spot on. Thanks so much
15:14:00 <SrPx> if it turns out that I have another similar dependency (which I will - things like toJSON, serializeBinary, etc), then I increase T even further. It is a quadratic code blowup.
15:14:10 <erikd> cmccann: i do that same, bit its a pain
15:14:31 <erikd> jophish: wow, i know more about haskell on windows than i thought i did :-P
15:14:36 <cmccann> erikd: I'll probably continue doing so, since my alternate Prelude has other idiosyncratic stuff I like
15:15:06 * indiagreen remembers how ne once had a brilliant idea to rename â€œ<$>â€ and â€œ=<<â€ in nir own Prelude to â€œ$/â€ and â€œ/$/â€
15:15:13 <erikd> cmccann: my problem is that i seem to have a different prelude for each project i work on
15:15:34 <erikd> that gets tiresome fast, but unifying them is a bunch of work as well
15:15:35 <cmccann> erikd: I made mine into a package and installed it. my .ghci file loads it automatically
15:16:01 <cmccann> so I just put "import Prelude ()" and "import Overture" in every file and I'm good
15:17:06 <deconfigured> shameless self-promo time: http://deconfigured.com/blog/dag
15:17:19 <cmccann> SrPx: but if you want that functionality, that's code you need to write one way or another. I'm not sure what you're getting at.
15:18:27 <SrPx> cmccann: in JavaScript, in 10 lines of code I can define a function "serializeBinary" that works for any non-bizarre type ever made, including the billions of line of JS code on GitHub.
15:18:37 <SrPx> lines
15:19:08 <indiagreen> SrPx: and in Haskell you can do something similar using generics
15:19:41 <cmccann> SrPx: then bother the maintainers of the libraries whose classes you want instances for to add a Generics-based instance
15:19:47 <SrPx> indiagreen: that is true and good - I guess the problem is when someone writes a typeclass on his own library for which he doesn't write a generic implementation for. Then you use that library and now you are locked.
15:20:12 <cmccann> for instance (ha, ha) binary and aeson both have generics support, I think
15:20:16 <jophish> erikd: I think I may have misdiagnosed things, LoadLibrary "mylib.dll" doesn't seem to help. How odd
15:20:56 <SrPx> Also, is that really solved by Generics? NFData has a generic and I still need an extra line of code for each type. That is: "instance (NFData f, NFData e) => NFData (Element f e) where rnf = genericRnf"
15:21:33 <SrPx> So I have this on my geometry library: http://lpaste.net/119560
15:21:38 * hackagebot http-conduit-downloader 1.0.23 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.23 (VladimirShabanov)
15:21:49 <SrPx> so now pretty much any time I have to add = 1 extra LOC... for the particular NFData dependency
15:21:59 <SrPx> add a type*
15:23:23 <indiagreen> it's not solved by generics, but it is mitigated
15:23:26 <cmccann> SrPx: I think as of recent GHCs you don't even need the last bit, an empty instance declaration will default to using generics
15:23:50 <SrPx> you still need an extra line of code...
15:23:58 <indiagreen> I agree it's a problem
15:24:00 <indiagreen> just not that big
15:24:30 <cmccann> to say you want an instance? yeah, but what's the alternative? magically creating instances for every type? I don't think that would be a popular idea.
15:25:08 <SrPx> I see... I disagree it is not that big, though. For me it is huge, I can't trust in any library I ever use from now, because I know adding something they use inside my own types can make them not be benchmarkeable anymore, for example.
15:25:19 <indiagreen> cmccann: currently e.g. a Binary instance is opt-in
15:25:43 <indiagreen> it'd be better to somehow have it opt-out
15:25:50 <cmccann> I dunno
15:25:52 <jophish> so to recap: I'm trying to call functions in a shared library on windows. Everything is great wen running in ghci, however I'm unable to run things from an executable
15:26:11 <SrPx> So next time I see a "Card" type on Hackage, and I think: "woa, it would be cool to include that Card inside my Player type." I will stop to think: "how much code it will break, though"?
15:26:34 <indiagreen> this creates its own problems, tho, because when the list of such opt-out instances grows, everyone would have to review their packages
15:26:56 <cmccann> people are wary enough of how instances are contagious and always imported, making instances be auto-generated when a class is in scope strikes me as dubious.
15:27:40 <indiagreen> cmccann: it's the same debate as with upper bounds
15:27:58 <SrPx> Seriously, I may be the stupidiest person on this room, but in my opinion the whole typeclass system is completely broken, toxic and is rendering Haskell an unusable, unpractical language.
15:28:03 <cmccann> I mean, I agree that a line for every instance isn't ideal, but I'm not convinced there's a viable alternative that doesn't have other problems
15:28:31 <SrPx> I think things would be much, much better if it was replaced by a simple function overloading system coupled with generic pattern matching.
15:29:12 * mgsloan thinks the typeclass system is great, just tooling around them (haddock, hoogle, ghci, etc) needs to catch up to clearly providing information about them
15:29:55 <indiagreen> with upper bounds packages break when maintainers stop updating upper bounds and a popular package like text gets a version bump, without upper bounds packages break when some obscure package they depend on suddenly gets a major rewrite
15:29:55 <cmccann> SrPx: I've spent enough time using other languages that have "simple function overloading" instead to know that type classes are better in almost every way :P
15:29:56 <SrPx> This community is awesome. glguy is awesome. I came here complain that his V3 types broke my benchmarks and he updated Linear in like, 5 minutes? But now, what should Bob who doesn't even know what IRC is do? If that doesn't reveal a serious underlying problem, I don't know what does.
15:30:08 <mgsloan> And even if it's not ideal, practicing with Haskell's typeclasses gives a great idea of the design space of type directed function overloading
15:30:33 <SrPx> cmccann: I don't know a single language with a good enough type system to judge what a good enough overloading would do... what are those languages??
15:30:43 <jfischoff> cmccann: Yeah no one has yet be able to point me to a better implementation
15:31:55 <jfischoff> Itâ€™s not that I donâ€™t buy there can be something better than typeclasses I just havenâ€™t seen anything in another language, or even heard of a better implementation. Therea are research papers that look promising though
15:31:58 <cmccann> SrPx: overloading vs. type classes is orthogonal to most other type system features, I don't see how that's relevant
15:32:52 <S11001001> SrPx: this talk by edwardk http://www.meetup.com/Boston-Haskell/events/219074467/ will be posted on https://www.youtube.com/channel/UCUCpgCWjaniUkX88wZrK_Ig at some point, I think; keep watch for it
15:32:56 <cmccann> I'm also skeptical that simple overloading would actually be simple in practice
15:35:20 <SrPx> cmccann: well IMO, it is inherently superior to typeclasses since it is just typeclasses without additional classifying bureaucracy
15:35:25 <SrPx> I.E. typeclasses - OOP
15:36:55 <dfeuer> SrPx, extraordinary claims require extraordinary evidence.
15:37:04 <ReinH> What does OOP have to do with typeclasses?
15:37:12 <cmccann> SrPx: and that's exactly what I think is a bad idea, for the same reason that I don't like structural typing as a default.
15:37:40 <SrPx> S11001001: noted, thank you!
15:39:34 <SrPx> ReinH: quoting an anonymous on the Scrap Your Boilerplate post.
15:39:41 <SrPx> "It took me a while but now I got something clear and found what I was looking for. And I made one surprising and amusing conclusion: type classes are inherently an object oriented thought. The say that a type *has a* function (or more) while your proposal is saying that there *is a* known function (or more) what is far more "functional" notion. Thanks for the discussion."
15:40:16 <SrPx> I don't claim to be right or wrong, but I agree with that thought. As many things I believe, time (and you) might prove me wrong...
15:41:14 <Cale> SrPx: Well, another option when you can't get in touch with the package maintainer is simply to "cabal get" the package and fix it yourself
15:41:15 <cmccann> OOP is a very nebulous concept, in the term's common use. I don't see any relation between type classes and any definition of OOP that I'd consider sensible.
15:41:46 <SrPx> ReinH: I ended up agreeing with your last argument on my design, by the way. I noticed it is much clear if I separate the logic of a partitioning tree of the logic of a "cartesian space". I made a few typeclasses and it is much nicer right now
15:42:50 <ReinH> That seems like a distinction without a difference to me
15:43:00 <SrPx> ReinH: I didn't came here to say that since I was working, so there it is, thank you :)
15:43:28 <ReinH> SrPx: yw :)
15:43:40 <SrPx> much more clear*
15:43:49 <ReinH> I don't think typeclasses are OOP at all.
15:44:49 <Cale> I guess making type class instances is sort of like creating values of some record type typically with function fields, which is basically "OOP". The instances give you less opportunity to have arguments that make up the private data for your "objects" though, relative to just having functions which construct records.
15:45:22 <Cale> So I think type classes are usually a bit of a red herring if you want to do an OO design in Haskell
15:45:29 <SrPx> cmccann: ReinH as I see anonymous's argument, it is not that typeclasses are OOP, but that typeclasses follow the same "OOP" philosophy that makes it use "foo.x" instead of "x foo", making the first argument somewhat special.
15:45:36 <SrPx> as I interpret *
15:46:03 <Cale> Wait, what? But they don't follow that.
15:46:08 <Cale> :t read
15:46:09 <lambdabot> Read a => String -> a
15:46:11 <cmccann> type classes don't make any particular argument special.
15:46:15 <ReinH> typeclasses just add a constraint to the type checker. They don't say anything about any particular argument.
15:47:16 <SrPx> At the type level, they do: they state that "a type has this and this function" (oop mindset) instead of "a function operates on this and this type" (fp mindset)
15:47:34 <ReinH> You can even write things like
15:47:36 <ReinH> :t let f :: Num a => b -> c -> b; f = const in f
15:47:36 <lambdabot> b -> c -> b
15:47:37 <ReinH> if you really want to
15:48:13 <ReinH> What's the difference between "a type has this function" and "this function operates on this type"?
15:48:20 <SrPx> Think at what happens on the type level, not the value level!
15:48:43 <ReinH> Ok. What in particular should I be thinking about?
15:48:53 <ReinH> They seem like equivalent statements to me.
15:49:05 <prophile> I like to think about kittens
15:49:06 <indiagreen> SrPx: typeclasses are a way to pass an implicit parameter
15:49:19 <dfeuer> @tell edwardk comonad.com seems to be down.
15:49:19 <lambdabot> Consider it noted.
15:49:31 <cmccann> dfeuer: he already knows
15:49:38 <edwardk> yep. traveling and can't get in touch w/ the systems guy at the moment
15:49:42 <cmccann> dfeuer: unless it went down again after being up, I guess
15:49:44 <edwardk> will probably be down through monday at least
15:50:12 <SrPx> Well, the difference, as I see it, is that it creates a direct relationship between a type and a function. You could, in OOP terms, say that a typeclass does this: "Maybe.bind = <monad instance for maybe>".
15:50:32 <ReinH> add :: Int -> Int -> Int; add = (+)
15:50:32 <edwardk> http://ekmett.github.io/ is a mirror that provides much of it
15:50:41 <ReinH> This also creates a direct relationship between a type and a function.
15:51:03 <ReinH> Would you also say Int.add ?
15:51:22 <mpickering> What's the suggested way to make case statements lazier?
15:51:25 <SrPx> No - you could say (Int â†’ Int â†’ Int).add, though.
15:51:31 <ReinH> What?
15:51:35 <dfeuer> edwardk, thanks. I got what I needed from archive.org.
15:51:38 <ReinH> That's not consistent with whaty ou just said about bind
15:51:41 <dfeuer> They have your lens slides.
15:52:24 <indiagreen> SrPx: this relationship isn't that strong because there are e.g. newtypes which let you transform typeclasses â€“ for instance, you can use the Down newtype to reverse â€œcompareâ€, or Sum/Product newtypes to choose what Monoid instance you want
15:52:27 <cmccann> mpickering: lazier in what sense? laziness and case selection are sort of inherently opposed.
15:53:07 <ReinH> mpickering: Maybe irrefutable patterns, but that depends on what you're doing.
15:53:18 <cmccann> mpickering: if you have a single case but want to be lazy about forcing things, irrefutable patterns or accessor functions
15:53:50 <ReinH> SrPx: Why is it Maybe.bind but (Int -> Int -> Int).add? That's inconsistent.
15:54:21 <mpickering> I'm not sure irrefutable patterns will work too well as there are a few clauses
15:54:25 <mpickering> maybe I need to refactor
15:54:26 <grom358> mmmm.. wondering if it safe to ask about comparison between ocaml compared to haskell in here? don't want to start any wars. But wondering if you don't necessarily want todo some functional piece of code.. say GUI. Is there much difference between using monad I/O compared to procedural code in ocaml. I never done any serious coding in either so was looking for advice
15:54:30 <SrPx> ReinH: hmm let me try this way: "foo :: Int â†’ Double â†’ Bool". This doesn't say "Int" has a function "foo". it says: "Int, Double and Bool have a function Int â†’ Double â†’ Bool". There is no direct relationship between a function and a single type, as far as FP goes.
15:54:31 <bramgg> Can anyone help with this error where it's expecting type "... IO String" and I'm only returning "IO String"? http://lpaste.net/119564
15:54:35 <mpickering> this is the problem with circular programs..
15:54:46 <ReinH> mpickering: perhaps you can show us what you're doing
15:55:11 <ReinH> SrPx: Ok, and there isn't a direct relationship between (>>=) and a single type, either.
15:55:15 <cmccann> mpickering: distinguishing cases is exactly what makes things be not lazy
15:55:31 <cmccann> mpickering: it can't tell which one matches without evaluating the argument, after all
15:55:37 <indiagreen> bramgg: you probably need to use liftIO on Â«fiz "foo"Â»
15:56:12 <cmccann> grom358: I don't think it'll start any wars, no
15:56:28 <bramgg> indiagreen: what does that do?
15:56:46 <jumper> Is it possible to use list comprehensions to print out a list of say numbers while ommitting the nth repetition of a specific number say 4
15:56:47 <cmccann> grom358: plenty of people here like ML-family languages. we will tend to be biased, of course :P
15:56:48 <jumper> ?
15:57:14 <SrPx> ReinH: there is a direct relationship between the "Monad Maybe a" class and Maybe's specific >>=
15:57:26 <indiagreen> it lets you use IO in monads which aren't exactly IO but support IO
15:57:28 <ReinH> There is no "Monad Maybe a" class.
15:57:35 <exio4> SrPx, "Monad Maybe *a*"?
15:57:43 <SrPx> Monad (Maybe a) instance*
15:57:55 <indiagreen> are you familiar with monad transformers?
15:57:55 <mpickering> cmccann: Well if you have f (if p x then y else z) then you are fine right?
15:58:04 <ReinH> That's still not right but anyway
15:58:05 <exio4> SrPx, still, "a"?
15:58:06 <mpickering> where you don't want to force x
15:58:12 <ReinH> Yes, it's a definition.
15:58:13 <monochrom> it can only be "instance Monad Maybe", not "instance Monad (Maybe a)".
15:58:13 <ReinH> Just like add.
15:58:44 <indiagreen> bramgg: sorry, haven't included nick in past 2 messages
15:59:01 <SrPx> woops my bad
15:59:06 <cmccann> mpickering: that expression itself will force f. if f inspects its argument at all then it will force (p x)
15:59:15 <grom358> cmccann: I guess I could just try both for myself. I have done a bunch of project euler in haskell. But I am looking to write some more stuff in ocaml/haskell (or insert some other language). I still very much think in procedural/OO :(
15:59:28 <jumper> Is it possible to use list comprehensions to print out a list of say numbers while ommitting the nth repetition of a specific number say 4?
15:59:46 <cmccann> grom358: writing imperative procedural code in Haskell is entirely possible and only slightly more awkward than any other language
16:00:06 <bramgg> indiagreen: ah thanks. No I'm not familiar with monad transformers
16:00:08 <cmccann> grom358: you just have to be explicit about mutability and side effects
16:00:17 <SrPx> so yea... that is clearly a direct relationship between a type and a function
16:00:25 <SrPx> or a type and a value...
16:00:29 <ReinH> SrPx: So is add.
16:00:39 <SrPx> :(
16:00:42 <cmccann> mpickering: forcing (p x) may or may not force x, depending on how p is implemented
16:01:01 <ReinH> SrPx: And what about return type polymorphism? How is class Foo a where foo :: Int -> a like OOP?
16:01:15 <SrPx> ReinH: not a *specific* type! "add" is tied to the tuple (Int,Int,Int), not to the type Int
16:01:25 <ReinH> SrPx: That's a specific type.
16:01:33 <cmccann> mpickering: but regardless, x will be forced if the result depends on its value. there's no way around that.
16:01:43 <ReinH> and actually it's tied to Int -> Int -> Int, ofc
16:01:48 <mpickering> cmccann: right
16:01:56 <Lokathor> how does one run ghci such that it uses the current cabal sandbox to load packages?
16:01:59 <ReinH> But that's no less "a function being tied to a type" than the definition of >>= for Maybe is
16:02:21 <cmccann> mpickering: and in general, if some part of the result doesn't depend on x, forcing that much of the result won't force x either
16:02:29 <hexagoxel> Lokathor: `cabal repl` or `cabal exec -- ghci`
16:02:34 <ReinH> :t (>>=) :: (Maybe a ) -> (a -> Maybe b) -> (Maybe b)
16:02:35 <lambdabot> Maybe a -> (a -> Maybe b) -> Maybe b
16:02:35 <indiagreen> bramgg: well, you can think about â€œScottyMâ€ as of a monad which wraps IO to provide some special Scotty-specific features in it â€“ you can't easily include ScottyM in an IO computation, but you can use any IO inside ScottyM, and â€œliftIOâ€ is a function which wraps ordinary IO to have the same type as other ScottyM things
16:03:03 <Lokathor> hexagoxel, many thanks
16:03:35 <hexagoxel> the latter form makes it easier to give params to ghci
16:03:48 <ReinH> The only thing I can see is that typeclasses are equivalent to storing a dictionary for each class keyed by instance, containing that instance's definitions
16:03:53 <Lokathor> yeah, I used that since I want to load a file as part of the invocation
16:03:56 <ReinH> But if that's all OOP is then I guess everyone has been doing OOP wrong.
16:04:01 <cmccann> mpickering: I think you'll need to show the actual code if you want more specific advice, as ReinH said
16:04:24 <cmccann> ReinH: imo almost everyone is doing OOP wrong, but for entirely unrelated reasons
16:04:35 <Hijiri> object methods are really functions, methods are fundamentally a functional notion
16:04:47 <ReinH> cmccann: I've heard a lot of definitions of OOP. None of them are "you can look up function definitions in a dictionary"
16:05:03 <Hijiri> banana.apple() is the same as let banana' = apple banana
16:05:11 <Hijiri> qed
16:05:30 <cmccann> ReinH: I never cease to be impressed by the creativity of people who try to define OOP. every definition is a unique and beautiful little snowflake.
16:05:36 <ReinH> Indeed.
16:05:38 <mpickering> cmccann: Thanks for your help, I'm going to try and work it out myself with some refactoring but might be back later if I can't figure it out
16:05:51 <cmccann> mpickering: fair enough, have fun and good luck
16:07:05 <ReinH> And just to preempt something, typeclasses are not a form of inheritance.
16:07:21 <AshyIsMe> i love alan kay's take on OOP too, basically "damnit, i should have called it message oriented programming"
16:07:23 <Bambi24>  Never Pay for Porn ever again. Click Here! http://bit.ly/1y2SGSo
16:07:34 <Hijiri> quick idoru
16:08:02 <bramgg> indiagreen: hmm okay, thanks. What makes you think liftIO would fix my problem? How do you think ScottyM is messing with my code?
16:08:12 <ReinH> BTW my point earlier is that you *can't do* return type polymorphism in OOP. You can with typeclasses.
16:08:41 <ReinH> AshyIsMe: Yeah, Erlang did well by not claiming to be an OOP language ;)
16:08:43 <SrPx> ReinH: well, maybe I don't have enought thought matter to dispute that right now, but on my perception, there is a very clear link between typeclasses and object systems. When I do "obj.foo()" in, say, JavaScript, I am calling "foo" on that particular object's dictionary. When I do "foo val" in haskell, I am just calling foo. Except if "foo" is on a typeclass. Then I'm calling "foo" of that particular type's dictionary ...
16:08:50 <indiagreen> bramgg: can I pm you?
16:09:08 <SrPx> ReinH: being more precise than this intuition wouldn't be possible for me right now and maybe there is no link at all. Maybe there is, I don't know...
16:09:19 <bramgg> indiagreen: go ahead :)
16:09:23 <ReinH> SrPx: There's a lot more to OOP than looking something up in a dictionary
16:09:53 <ReinH> But yes, you can implement typeclasses and method dispatch by looking things up in a dictionary. They have that in common.
16:10:26 <ReinH> objects are not just behavior though
16:10:26 <obiwahn> http://paste.debian.net/142993/
16:10:27 <rasen> You could build a lot of things using dictionaries. Proved by lua
16:10:29 <ReinH> objects are also state
16:10:31 <SrPx> ReinH: sure, but anonymous's point wasn't that "typeclass implements oop". It is that "typeclasses follow this particular oop mindset".
16:10:45 <Hijiri> it's not a particularly oop mindset
16:10:54 <ReinH> SrPx: That seems like an a priori fallacy
16:10:58 <Hijiri> just a common one among oop things
16:11:01 <SrPx> There is, indeed, a whole world of oop ideas (message passing, state machines and so on) that has nothing to do with this, particularly.
16:11:11 <Hijiri> the same way variable assignment isn't an oop mindset
16:11:30 <ReinH> I mean, I don't think OOP has a patent on looking things up in a dictionary
16:12:14 <ReinH> The problem is when people say "typeclasses are like OOP" and then go on to continue to equivocate the two in ways that are not warranted
16:12:32 <ReinH> I don't have a problem with "typeclasses and OOP both use dictionaries of functions"
16:12:52 <hexagoxel> while we are at defining elusive concepts, please define `mindset`
16:13:00 <ReinH> But you shouldn't draw any sort of deeper connection between the two based on this.
16:13:40 <SrPx> ReinH: so, "there is some evidence that typeclasses share strong similarities with this particular oop mindset" ?
16:13:52 <ReinH> I mean, it's just "using a dictionary"
16:14:01 <cmccann> hexagoxel: a mind data structure containing a mind collection of unordered mind elements with no duplicates
16:14:14 <ReinH> cmccann: +1
16:15:01 <cmccann> sometimes I look up words in a dictionary, does that make me object-oriented
16:15:05 <ReinH> cmccann: probably.
16:15:16 <ReinH> cmccann: do you have inheritance?
16:15:27 <Hijiri> the great success of OO is that it emulates real life
16:15:32 <Hijiri> my book is an object, you are an object
16:15:56 <Hijiri> my book has a behavior that causes it to shoot words at me
16:16:03 <ReinH> That's a weird book.
16:16:11 <SrPx> ReinH: I see your point. I guess I can explain to you why some people say that, then. Particularly, when I programmed OOP languages, I often had to decide wether to make some function a method of a class, and have this: "a.add(b)" or to make it independend, and have: "add(a,b)". Often we see "a.add(b)" to be considered the "object oriented approach" while "add(a,b)" is the "functional" approach.
16:16:30 <cmccann> ReinH: well, I take after my mom's side of the family, does that count
16:16:36 <ReinH> SrPx: Yeah, I can see how some people would make a connectoin there. I just think it leads to a false equivocation.
16:16:48 <ReinH> And I don't see any value in the analogy
16:17:00 <ReinH> cmccann: Yep, object-ness confirmed.
16:17:19 <hexagoxel> Hijiri is still using the old version of the `universe` package; new version breaks too much stuff.
16:17:19 <cmccann> ReinH: awesome, I should totally put that on my resume or something.
16:17:20 <ReinH> There's no need to bring any of the baggage of the term "object" into typeclasses.
16:17:22 <SrPx> Thus, many people, including me, made an association between oop and dictionaries, and FP and no dictionaries - although, maybe, indeed, this is an incorrect observation - there is no patent on that, as you would say.
16:17:39 <Hijiri> a.add(b) is just add(a,b), with an emphasis on the possibility that some state in a is involved
16:17:57 <ReinH> SrPx: typeclasses can be implemented via pure dictionary passing without any language support
16:18:08 <ReinH> It's just a "thing you can do in FP", not "a part of the FP mindset"
16:18:16 <ReinH> It's just a useful enough one that we decided to make it a language featre.
16:18:22 <cmccann> Hijiri: and also an emphasis on the possibility that what implementation of add is used can depend on a
16:18:48 <shachaf> You would need some extra features to implement type classes in Haskell2010-without-classes.
16:19:09 <ReinH> shachaf: fair enough, I haven't tried.
16:19:42 <SrPx> ReinH: classes can be implemented too... I guess the association is a matter of "oop prefers this since OOP languages often have syntax for it", and "fp doesn't since FP languages usually don't". I see your point, though - the whole argument is nonsensical
16:20:10 <shachaf> I'm just talking about Rank2Types, or maybe even something slightly weaker.
16:20:12 <ReinH> SrPx: I just don't think the analogy buys us anything, but I do think it often costs us something.
16:20:17 <ReinH> So it has negative utility to me.
16:20:30 <ReinH> shachaf: Ah. Right.
16:20:52 <ReinH> shachaf: If you want to understand the mindset behind typeclasses, you can just read Wadler http://people.csail.mit.edu/dnj/teaching/6898/papers/wadler88.pdf
16:21:00 <SrPx> ReinH: uh huh, I agree with you.
16:21:07 <erikd> does haskell have something like POSIX's atexit ?
16:21:10 <shachaf> ReinH: I'll keep that in mind. :-)
16:21:17 <ReinH> shachaf: hahaha sorry
16:21:22 <ReinH> SrPx: sorry, that was for you http://people.csail.mit.edu/dnj/teaching/6898/papers/wadler88.pdf
16:21:52 <ReinH> SrPx: Wadler even mentions a OOP in the abstract!
16:21:58 <ReinH> s/a //
16:22:23 <erikd> cmccann: apparently i'm un-shadowbanned. no explanation, just 'should be fixed now'. <sigh/>
16:22:37 <ReinH> SrPx: It might be more accurate to say "There's a problem shared by OOP and FP languages. OO has one solution, while typeclasses offer a different solution for FP."
16:22:43 <rasen> (02:02:43 AM) rasen: People just think "I can do polymorphism with typeclasses -> That's one of key OOP pronciples -> typeclasses are OOP"
16:22:44 <rasen> (02:02:53 AM) rasen: principles*
16:22:56 <ReinH> rasen: you can also do it without them :)
16:23:04 <ReinH> typeclasses get you *ad hoc* polymorphism.
16:23:07 <shachaf> Anyway, type classes are tricky. They're the only thing in Haskell where you figure out something's value from its type.
16:23:15 <cmccann> erikd: nice! probably just tripped some random auto-ban thing that's supposed to be catch spammers.
16:23:35 <SrPx> ReinH: (I am reading)
16:23:43 <cmccann> erikd: they might not even know why. especially since it would have been months ago.
16:23:50 <shachaf> Type class instances for your particular type are often made at runtime.
16:23:52 <Hijiri> what are multi param typeclasses in oop?
16:23:58 <erikd> cmccann: like logging in from three different continents in the space of 24 hours
16:24:01 <ReinH> SrPx: After all, it should be obvious that OOP and FP languages attempt to solve a lot of the same problems. ;)
16:24:03 <rasen> ReinH: what kind of polymorphism do you mean?
16:24:11 <cmccann> erikd: that's entirely possible
16:24:11 <shachaf> Type classes can sometimes hide some of the the trickiness of polymorphic recursion.
16:24:16 <ReinH> rasen: "ad hoc" polymorphism. See http://people.csail.mit.edu/dnj/teaching/6898/papers/wadler88.pdf
16:24:40 <erikd> cmccann: and fscked up. i travel and i log in from all over the place.
16:24:49 <ReinH> Hijiri: another thing OOP can't do :)
16:25:13 <cmccann> erikd: given how ineffable reddit's spam filter is I'm not surprised
16:25:21 <ReinH> Hijiri: Not only that, just having multiple constraints.
16:25:50 <enthropy> Hijiri: some languages have multiple dispatch
16:25:52 <erikd> cmccann: i sent a "thanks, but i'd really like to know why and when"
16:25:55 <SrPx> ReinH: sure, you convinced me about this point. I still have strong intuition towards typeclasses being bad, though, so I might instead concentrate on the points that make me feel this way when I approach the subject.
16:26:09 <cmccann> erikd: it does stuff like filter one post out of many from someone who regularly submits highly-upvoted posts
16:26:32 <ReinH> SrPx: Well, Wadler's explanations for the motivations behind typeclasses might help put your feelings in perspective.
16:26:43 <ReinH> s/feelings/intuition
16:26:45 <erikd> cmccann: and that's why they need active unpaid moderators
16:27:02 <SrPx> yes I'm reading...!
16:27:09 <SrPx> thanks
16:27:09 <cmccann> erikd: anyway, let me know if you get an answer. it'd be nice to know.
16:27:17 <erikd> cmccann: will do
16:27:25 * erikd gets back to haskell
16:27:26 <rasen> ReinH: thanks. forgot how other (non-parametric polymorphism) is called
16:27:44 <ReinH> rasen: "parametric"
16:27:56 <ReinH> rasen: woops. "ad hoc" and "parametric"
16:28:47 <rasen> yep. I got it
16:29:26 <toblerone> Anyone mind explaining to me how the second instance in this example works? I don't understand how this is possible: http://www.reddit.com/r/haskell/comments/2u01b0/finding_a_type_with_multiple_monad_instances_a/co4409p
16:29:36 <SrPx> okay, before I finish reading, since we are talking about this right now, could I ask your opinion on some other points?
16:30:14 <cmccann> toblerone: the reverse state monad?
16:30:19 <toblerone> yeah
16:30:42 <toblerone> the second let binding depends on the result of the first, which in turn depends on the result of the second
16:30:48 <rasen> toblerone: seems like it executes right action before left one
16:30:49 <mpickering> cmccann: I think I got it working.. it seems anything circular is very fragile though..
16:30:57 <ReinH> toblerone: https://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
16:31:30 <cmccann> mpickering: yeah, it can be. I usually avoid any non-trivial use of that kind of stuff...
16:31:41 * hackagebot git-vogue 0.2.0.1 - A framework for pre-commit checks.  http://hackage.haskell.org/package/git-vogue-0.2.0.1 (ChristianMarie)
16:32:22 <ReinH> SrPx: sure
16:34:36 <toblerone> ReinH: That doesn't seem to explain how it coud work though. I'm having difficulty understanding how it could evaluate either of those expressions as they both depend on the result of the other. Shouldn't that be an infinite loop?
16:35:22 <cmccann> toblerone: consider a function of type (a -> State s b), which is equivalent to a function of type (a, s) -> (b, s). binding in the state monad amounts to composing these functions
16:35:54 <shachaf> >=>ing is, at least.
16:36:12 <cmccann> toblerone: so you basically have two chains of functions with some crossing over between then when you modify the state value
16:37:51 <cmccann> toblerone: in the reverse state monad, instead of composing normally you compose the "s" part the other way around, if that makes sense
16:38:12 <cmccann> so you something like two chains of functions in opposite directions
16:38:36 <toblerone> well I understand the state monad, I'm just having trouble see how that definition is different from something like this: http://lpaste.net/119570
16:38:41 <toblerone> which wouldn't work
16:40:09 <SrPx> ReinH: actually, I'm confused about something
16:40:17 <cmccann> toblerone: because in the reverse state monad there's no inherent dependency between the two "chains" of functions
16:40:25 <lpaste> sveit pasted â€œSlow primesâ€ at http://lpaste.net/2450150964011728896
16:41:33 <sveit> I just pasted some code here: http://lpaste.net/2450150964011728896 that is confusing me. I have an identical algorithm implemented in python (albiet using scipy), and this code runs ~100 times slower (python version takes .4 seconds, this version takes 35 seconds), and I am not sure why
16:41:38 <cmccann> toblerone: I would imagine it's straightforward to write code in the reverse state monad that would create such a circular dependency though
16:41:45 <ReinH> SrPx: k
16:41:57 <sveit> i am aware of other prime number generators for haskell, but I am trying to understand why this technique fails here
16:42:37 <lpaste> sveit pasted â€œFast primesâ€ at http://lpaste.net/1157284379630764032
16:43:00 <sveit> for reference I have also pasted the fast primes
16:43:00 <Hijiri> sveit: maybe you're doing updates on an immutable vector?
16:43:48 <sveit> Hijiri: but shouldn't I be able to have quick "functional" updates on the vector?
16:44:00 <sveit> I am certainly making proper use of the unsafe bulk update feature
16:44:04 <toblerone> huh, I'm still not seeing how those two let bindings aren't forming a circular dependency... to get the value "a" we must run state function "sf" with state "s'". To get s' we must run RState obtained from applying function "f" to "a"
16:44:46 <sveit> Hijiri: so what data structure should I use instead?
16:44:51 <monochrom> MUV
16:44:55 <Hijiri> sveit: With a flat data structure like a vector, you would have to copy the whole thing
16:45:00 <cmccann> toblerone: try manually desugaring it and looking at the exact dependencies involved?
16:45:03 <Hijiri> to update one element
16:45:04 <monochrom> you have imported MUV. use it for real
16:45:30 <toblerone> desugaring the let bindings?
16:45:31 <sveit> monochrom: that was from an earlier test, where I tried to run UV.modify with MUV.write, but that ended up slower
16:45:38 <Hijiri> well not copy the values, but the spine
16:45:42 <sveit> monochrom: should I just put the whole functiion in the state monad?
16:45:42 <cmccann> toblerone: idk, the reverse state monad always seemed like a pointlessly confusing gimmick to me so I'm not used to thinking about how it works in practice :P
16:45:49 <sveit> sorry, not state, ST
16:45:57 <shachaf> State is obviously the right monad.
16:46:42 * hackagebot aig 0.2.1 - And-inverter graphs in Haskell.  http://hackage.haskell.org/package/aig-0.2.1 (RobertDockins)
16:46:44 * hackagebot abcBridge 0.12 - Bindings for ABC, A System for Sequential  Synthesis and Verification  http://hackage.haskell.org/package/abcBridge-0.12 (RobertDockins)
16:46:52 <Hijiri> for destructive mutation, don't you need ST?
16:48:36 <toblerone> huh okay, yeah I'm not thinking about using it, I just couldn't (and still can't) see how it's possible at all
16:49:37 <monochrom> you know, I'm just going to write my own vision of Eratosthenese's sieve the destructive, mutable way and see what happens
16:50:17 <cmccann> monochrom: something destructive will happen, clearly
16:51:54 <sveit> monochrom: could you please paste/time it if possible?
16:52:16 <hexagoxel_> eliminating all non-primes sounds pretty destructive to me
16:52:32 <monochrom> yes. but I have to write it first.
16:53:17 <sveit> monochrom: but in your case the whole function will live in the ST monad, correct? as I said I had tried to use "minimal" destruction by using "modify", but it was slower than just doing bulk updates
16:53:34 <monochrom> yes
16:53:55 <monochrom> well, yes to the first. neither confirm nor deny to the second.
17:02:47 <trap_exit> i have some ahskell data sztructures, which I want to serialize to postgresql
17:02:55 <trap_exit> but I feel like there si somsething similar about haskell data structures and git
17:03:02 <trap_exit> and I'm not sure how to store such a model in postgres
17:03:05 <trap_exit> i.e. I wnat to store the 'diffs'
17:03:12 <trap_exit> to be able to recover an 'old version' of the data, etc ...
17:03:22 <EvanR> well git stores the snapshots
17:03:27 <mmachenry1> trap_exit: There should be a "ToDatabaseRow" type class or something like that in the postgres lib
17:03:40 <trap_exit> yes
17:03:48 <trap_exit> EvanR: git does not store diffs?
17:03:53 <rasen> nope
17:03:56 <rasen> svn does
17:04:10 <trap_exit> well, for each file it stores a snapshot
17:04:10 <trap_exit> which is sorta like, for each data structure it stores a snapshot hmmm ....
17:04:30 <trap_exit> is there a way to use git as a backend to store haskell values ?
17:04:47 <ReinH> git stores objects (blobs of data, more or less corresponding to files).
17:04:56 <rasen> write value to file, make a commit?
17:06:14 <EvanR> trap_exit: theres this idea of a "immutable database" where for a given record, you update it by inserting a new version. in your case the versions can be serialized values
17:06:29 <trap_exit> EvanR: yes ... there is datomic for clojure
17:06:39 <trap_exit> EvanR: is there anything like this for haskel ?
17:06:44 * EvanR refrains from complaining about datomic
17:06:56 <EvanR> trap_exit: not exactly what i was getting at, but something much simpler
17:07:07 <trap_exit> EvanR: what are you getting at? enlgihten me :-)
17:07:47 <EvanR> trap_exit: thats it, in your relational database, your schema is made to log versions of records instead of replacing them
17:08:05 <EvanR> the latest version can be an index, or another table
17:08:08 <trap_exit> EvanR: hmmin this world,how do I do "efficient" querying?
17:08:09 <sveit> monochrom: I have to run, but I'll look through the logs here (or bother you later) to see your version. Thanks!
17:08:16 <EvanR> trap_exit: of what?
17:09:03 <Pamelloes> Does parsec use ffi?
17:09:37 <benzrf> Pamelloes: dunthinkso
17:09:49 <mr-mister> does haskell support any-order declarations?
17:09:54 <Pamelloes> Hm, I wonder why timeout isn't working then...
17:09:59 <benzrf> mr-mister: yeah
17:10:03 <benzrf> mr-mister: usuallu
17:10:20 <EvanR> Pamelloes: did you read the caveats related to timeout
17:10:40 <benzrf> mr-mister: : circular module deps break thing i think
17:11:04 <Pamelloes> EvanR: I did. It says It doesn't work for FFI. However, I'm not using FFI....
17:11:43 * hackagebot sequent-core 0.2.0.0 - Alternative Core language for GHC plugins  http://hackage.haskell.org/package/sequent-core-0.2.0.0 (lukemaurer)
17:11:55 <trap_exit> EvanR: so the problem with having a log of entries, is I need to construct "the most updated views" before querying it
17:12:15 <EvanR> Pamelloes: well, timeout is for IO actions, parsing is not IO
17:12:43 <Pamelloes> EvanR: mmmm, so it won't interrupt a pure function?
17:12:59 <EvanR> trap_exit: you dont, thats a basic technique related to this, you separate the log to get the latest versions depending on how youre going to use the data
17:13:45 <EvanR> trap_exit: if records have some identity, one table has the id and the pointer to the latest log record. alternatively you can "cache" the latest in that table to gain minor performance and sacrifice some consistency gaurantees
17:14:09 <EvanR> Pamelloes: im not sure
17:14:11 <trap_exit> EvanR: Hmm, so I have 1 table, which is "cur view", which is what I would get if I didn't care aobu thistroy, then I have a 2ndf table, which is just the log?
17:14:48 <Pamelloes> EvanR: A quick google reveals that my pure functions are producing an immediately returning thunk. I guess I need to add a seq of some kind.
17:14:49 <EvanR> trap_exit: if its just a log, and is for archives, that makes sense. if theres some other use, you can build indexes into the history
17:15:04 <EvanR> Pamelloes: evaluate maybe
17:15:07 <EvanR> :t evaluate
17:15:08 <lambdabot> a -> IO a
17:17:01 <rasen> evaluate evaluates to whnf?
17:17:03 <SrPx> Okay, I don't get something about the typeclass paper: http://people.csail.mit.edu/dnj/teaching/6898/papers/wadler88.pdf it complains that naive overloading causes an exponential explosion of types. But how is that a problem? You can always just select the types you are actually using.
17:17:38 <glguy> rasen: yes
17:18:01 <SrPx> Using his example, "squares (1 :: Int) (2 :: Int) (3 :: Double)" would just select "squares :: Int â†’ Int â†’ Double" at compile time. The resulting program wouldn't even have to deal with dictionaries at runtime so it is even faster...
17:18:40 <Hijiri> do you mean Int -> Int -> Double -> something?
17:19:25 <SrPx> I mean, the problem is that there is an "universe" of "8 candidate function types"? Because then you could say the same about dictionary passing. "squares :: (Num a, Num b, Num c) => a â†’ b â†’ c â†’ (a,b,c)" still has 8 possible ways to arrange the dictionaries when calling it. You are just delegating it to the runtime
17:19:45 <SrPx> Hijiri: yes, Int â†’ Int â†’ Double â†’ (Int,Int,Double) -- my bad
17:20:06 <rasen> I believe, if compiler knows all types at compile-time, it won't use dictionary with typeclasses
17:21:08 <SrPx> I see - but how that makes the "naive overloading" approach problematic?
17:22:02 <SrPx> I have finished reading the paper and I have a better opinion about typeclasses, but I still don't see the problem with naive overloading.
17:22:46 <rasen> I was asking the same question to myself when commuting home. But didn't came up with something valuable
17:22:47 <EvanR> whats naive overloading?
17:22:58 <Hijiri> one thing is that I don't know how I would write the type sig
17:23:12 <Hijiri> list every function that has to be defined?
17:23:35 <Hijiri> I can't see anything about the exponential types though
17:23:41 <glguy> SrPx: if you wanted to be able to call your function at each of the 8 possible variations where the first second and third arguments are allowed to be Double or Int you need 8 implementations
17:23:56 <glguy> Rather than writing it once where each argument is allowed to vary independently
17:25:08 <rasen> Why we can't have both?
17:25:48 <osa1> in Data.ByteString.Char8, unpack . pack /= id, right?
17:26:14 <Hijiri> nope
17:26:14 <nkar> is there a rawSystem but for Text?
17:26:17 <Hijiri> non-ascii will die
17:26:55 <glguy> osa1: That will only be true if all the values in the original string are < '\256'
17:28:17 <rasen> is Char fixed-width?
17:29:02 <Hijiri> nope
17:29:07 <shachaf> Char is (supposed to be) a Unicode character.
17:29:23 <shachaf> In GHC it's a value between 0 and 1114111. Is that fixed-width?
17:29:24 <glguy> Char is a value between 0-0x10ffff
17:30:17 <Hijiri> oh, I thought it sometimes omitted the second byte
17:30:31 <Hijiri> more bytes
17:30:33 <EvanR> typedef Uint21 Char;
17:30:34 <Hijiri> bytes not the first
17:30:35 <EvanR> ;)
17:31:03 <rasen> EvanR: thanks
17:31:15 <EvanR> that was a joke
17:31:19 <rasen> hah
17:32:59 <rasen> So... both ascii symbol and Chinese one took the same amount of memory?
17:33:16 <EvanR> its already a box so
17:33:42 <rasen> inside the box?
17:34:00 <glguy> rasen: If you're working with more than a small amount of text you should use the text package. It stores text in UTF-16 in packed arrays
17:34:20 <rasen> I know. Just wondering about Char
17:35:02 <EvanR> and Bools dont take 1 bit either
17:35:09 <chrizz_> hello, I am learning about free monads and I am wondering if it's possible to introduce some additional type safety into this simple example: http://lpaste.net/119573
17:35:11 <EvanR> sad really
17:35:21 <chrizz_> I would like to get rid of the "error", if possible
17:35:48 <shachaf> Bools take a pointer, just like anything else.
17:36:27 <HeladoDeBrownie> chrizz_, well, one way would be to return a Maybe Int and return Nothing there.
17:36:29 <rasen> EvanR: not really. Bit accessing is slower
17:36:31 <EvanR> even unboxed values have to be in something
17:36:56 <chrizz_> HeladoDeBrownie: I was thinking something along the lines of using peano numbers
17:37:07 <HeladoDeBrownie> chrizz_, how so?
17:37:08 <chrizz_> so that a program that pops an empty stack is a type error
17:37:12 <EvanR> rasen: yeah, figuring out how to access variable width Char values would have overhead... data Char = C1 Word8 | C2 Word16 | C4 Word32
17:37:13 <HeladoDeBrownie> ah
17:39:21 <HeladoDeBrownie> chrizz_, that would mean you would no longer be able to use monad operators to compose your dsl programs
17:39:42 <chrizz_> HeladoDeBrownie: why not? can you give an example?
17:40:14 <HeladoDeBrownie> let's suppose pop :: Program (Succ n) a.
17:40:18 <HeladoDeBrownie> @type (>>)
17:40:19 <lambdabot> Monad m => m a -> m b -> m b
17:40:37 <HeladoDeBrownie> the m of both arguments to (>>) must be the same
17:40:52 <HeladoDeBrownie> you would want pop composed with pop :: Program (Succ (Succ n)) a.
17:41:08 <chrizz_> oh, I see...
17:41:09 <HeladoDeBrownie> but that's impossible for the reason i just stated.
17:41:31 <chrizz_> hrm.
17:41:52 <HeladoDeBrownie> so you have at least two options: (1) have the interpreter return a Maybe (2) don't use monadic composition
17:43:37 <therealfakemoot> So I have a bit of an abstract question. I'm working my way throgh Learn You as Haskell and the typeclasses were very intriguing. I noticed that you can define certain truths about the typeclass (the example was Eq, I think) describing invariants about the operators. I was wondering...is it possible to implement a...derivation(?) of the typeclass such that those invariants are violated? Or can the compiler
17:43:40 <therealfakemoot> catch that?
17:44:26 <EvanR> therealfakemoot: can you provide a link to that please i wanna read it
17:44:26 <HeladoDeBrownie> depends, do you mean the laws associated with the class? haskell cannot check those, they must be verified by the instance writer.
17:44:43 <glguy> therealfakemoot: The compiler doesn't verify the laws
17:44:45 <chrizz_> HeladoDeBrownie: what about redefining (>>=) and return and using an indexed monad?
17:45:01 <chrizz_> HeladoDeBrownie: (re: type safe pop)
17:45:04 <therealfakemoot> Okay. Just wondering.
17:45:20 <HeladoDeBrownie> chrizz_, i don't think indexed monad is the answer either. you want a strict increment, rather than tracking source and destination
17:45:22 <therealfakemoot> I thought it was a really cool feature and I wanted to know if that was a compile teime check I could rely on or something
17:45:57 <HeladoDeBrownie> chrizz_, essentially you want a natural in your program type that is equal to the maximum number of pops that could possibly occur. that is non-trivial to encode
17:46:14 <HeladoDeBrownie> and, if your Program type ends up being turing-complete, impossible.
17:46:25 <HeladoDeBrownie> (i think?)
17:46:37 <HeladoDeBrownie> we'll suppose it isn't though
17:46:42 <HeladoDeBrownie> unless you plan to make it?
17:46:59 <chrizz_> nope
17:47:05 <chrizz_> I'm just messing around
17:47:14 <HeladoDeBrownie> actually, wait, you can already embed arbitrary haskell expressions in it
17:47:20 <EvanR> therealfakemoot: im wonder where it talks about laws for Eq
17:47:23 <SrPx> okay after reading the paper and thinking a lot, and trying to understand what was actually affecting my productivity, I came to the conclusion it is not really typeclasses, nor a type system themselves, specifically.
17:47:25 <chrizz_> can you give an example of a type safe pop then, forgetting about free monads?
17:47:29 <therealfakemoot> EvanR: Hang on, let me try to find it
17:47:37 <SrPx> it is really, more about the Haskell ecosystem being a mess :(
17:48:31 <HeladoDeBrownie> chrizz_, not off the top of my head, as i said it's non-trivial. i'm thinking even impossible, maybe
17:48:51 <HeladoDeBrownie> chrizz_, i think encoding failure in your interpreter is your best bet
17:49:03 <Kaidelong>  oh good timing
17:49:20 <Kaidelong> I'm here to ask about whether or not I should switch to Stackage
17:49:58 <chrizz_> HeladoDeBrownie: ok, thank you
17:50:00 <HeladoDeBrownie> chrizz_, on a side note, while it may or may not be impossible in haskell, you can make stronger guarantees in a language like agda
17:50:02 <therealfakemoot> EvanR: Okay. I found the section I was thinking of. http://learnyouahaskell.com/making-our-own-types-and-typeclasses it's here, search for "This is how the Eq class is defined in the standard prelude:"
17:50:02 <Kaidelong> my approach has been to use cabal sandboxes and apply the PVP but without automated tools to discover upper bounds this doesn't seem like the greatest idea
17:50:27 <HeladoDeBrownie> chrizz_, agda is dependently typed, you can have arbitrary expressions at type level
17:51:15 <systemfault> I found cabal + sandboxes to be "somewhat" okay
17:51:26 <EvanR> therealfakemoot: ok, thats a lot less interesting than laws being verified by the compiler. that syntax just defines default implementations for the class functions
17:51:35 <Kaidelong> but I was asking on reddit about if there was a "boost" for Haskell to get rid of the suck of the standard libraries
17:51:41 <therealfakemoot> EvanR: This is my first run at Haskell
17:51:45 * hackagebot sequent-core 0.2.0.1 - Alternative Core language for GHC plugins  http://hackage.haskell.org/package/sequent-core-0.2.0.1 (lukemaurer)
17:51:47 <Kaidelong> and I realized that if there is one it might well live in Stackage
17:51:51 <therealfakemoot> EvanR: I'm absolutely enthralled, but I know very little so far
17:51:58 <therealfakemoot> Coming from Python, it's a big change
17:52:01 <EvanR> therealfakemoot: you can choose not to implement either == or /=, they will default to be defined by the other (using not)
17:52:06 <Pamelloes> Is there a compilation flag to make a program aggressively release memory?
17:52:19 <therealfakemoot> EvanR: That makes sense
17:53:05 <Kaidelong> therealfakemoot: incidentally a python guy "complained" to me today about how I'm responsible for him using map, zip, and lambda everywhere now. So python borrows enough from Haskell that it may prove directly applicable, it seems
17:53:14 <Fuuzetsu> Pamelloes: you can make it garbage collect on demand if that's what you need
17:53:16 <therealfakemoot> EvanR: Thanks for the knowledge transfer
17:53:25 <therealfakemoot> Kaidelong: See, in Python, I'll never ever use map()
17:53:42 <therealfakemoot> Kaidelong: but after the first page of Learn You a Haskell, I very much see the utility. In Haskell
17:53:44 <Fuuzetsu> map zip lambda filter and friends are considered bad style in Python nowadays IIRC
17:53:44 <Pamelloes> Fuuzetsu: How does one do that?
17:54:04 <therealfakemoot> Yeah. List comprehensions provide the same functionality in a more unified syntax
17:54:11 <therealfakemoot> as sugar, instead of as function calls
17:54:14 <Kaidelong> I've heard that python's functional idioms have awful performance anyway
17:54:20 <therealfakemoot> Eh
17:54:26 <Kaidelong> because it has no system for fusion rules and such
17:54:34 <therealfakemoot> Python isn't a language you write in if you care about performance from the get-go
17:54:36 <EvanR> Kaidelong: i remember map zip etc being really inconvenient to use in python code, and non idiomatic
17:54:43 <EvanR> but that was old python
17:55:12 <therealfakemoot> I've got to go out and get drunk and high, but I very much look forward to more discussions with you gentlefolk in the future
17:55:14 <therealfakemoot> Thanks for the chat
17:55:19 <Kaidelong> when I was working in Python I found the whole thing a bit inconvenient and unidiomatic but I guess it's because I was expecting Java and Python is not Java
17:55:21 <Fuuzetsu> Pamelloes: I forget what function, somewhere in GHC package IIRC; it's not something you want to do often though, what's your actual problem?
17:55:26 <Kaidelong> stay classy moot
17:55:31 <EvanR> get high on haskell instead
17:56:02 <MP2E> tolerance doesn't exist in Haskell : it would break functional purity
17:56:04 <MP2E> :D
17:56:08 <Fuuzetsu> Haskell, keeping kids off drugs since 2015
17:56:26 <Kaidelong> also
17:56:36 <Pamelloes> Fuuzetsu: I'm running arbitrary code that occasionally explodes in memory usage. I have a timeout function to stop it from going overboard, but the compiled program's memory usage doesn't come back down after an interrupt.
17:56:40 <sgronblo> that reminds me of some SPJ line from some presentation: "we were high on lazy evaluation"
17:56:52 <MP2E> haha
17:57:08 <Kaidelong> does GHC have any utility to completely force the evaluation of a fully applied value
17:57:26 <hiptobecubic> compute it at compile time?
17:57:27 <EvanR> Pamelloes: wouldnt that be a better place for a "spaceout" instead of a timeout ;)
17:57:27 <Kaidelong> that doesn't introduce a context
17:57:42 <Pamelloes> EvanR: What's that?
17:57:49 <EvanR> its a timeout, but in space
17:57:52 <MP2E> Kaidelong: deepseq
17:57:54 <zwer> therealfakemoot curious why you would never use map in python?
17:57:59 <Kaidelong> @ty deepSeq
17:58:00 <lambdabot> Not in scope: â€˜deepSeqâ€™
17:58:10 <geekosaur> I don't think gc releases memory to the OS, if that's how you're tracking memory usage
17:58:10 <Kaidelong> didn't that require NFData
17:58:11 <Fuuzetsu> Pamelloes: you probably want to fix your program instead of forcing gc
17:58:12 <Pamelloes> EvanR: Is that a real thing, or are you screwing with me?
17:58:22 <joness> :t deepseq
17:58:23 <MP2E> Kaidelong: ah, yeah I believe it does
17:58:23 <lambdabot> Not in scope: â€˜deepseqâ€™
17:58:32 <joness> @hoogle deepseq
17:58:34 <lambdabot> Control.DeepSeq deepseq :: NFData a => a -> b -> b
17:58:34 <lambdabot> package deepseq
17:58:34 <lambdabot> package deepseq-generics
17:58:36 <hiptobecubic> zwer, the python community prefers list comps for various reasons
17:58:37 <EvanR> Pamelloes: it should be
17:58:43 <Kaidelong> so the problem is
17:58:53 <Pamelloes> EvanR: I completely agree.
17:59:15 <Kaidelong> I think the whole thing about "Haskell doesn't have inductive data types" is blind men touching an elephant
17:59:29 <Kaidelong> and I would like to show this by modelling ML as a Monad in Haskell
17:59:36 <Kaidelong> but the best I can do is Applicative
17:59:39 <Kaidelong> because of the NFData context
17:59:41 <Pamelloes> Fuuzetsu: I'm running genetic algorithms over randomly generated programs. The interpreter isn't broken, it's just that occasionally a memory hog program is generated. Hence the timeout ;)
18:00:22 <Kaidelong> (an indexed monad would not work because ML function results are still in a sense lazy)
18:00:35 <Kaidelong> (unless NFData already works on functions exactly that way)
18:00:47 <Kaidelong> basically the idea I had is that evaluating arguments is just a kind of side effect
18:00:47 <zwer> hiptobecubic  those reasons never seemed convincing to me, though. if you already have a function map(f, xs) is clearer and more concise than list comprehension equivalent. and even more so for filter.
18:01:11 <Kaidelong> and applicative functor would still demonstrate this
18:01:22 <Kaidelong> oh wait, no, I can't even use that
18:01:23 <zwer> [x for x in xs if f(x)] is a lot of boilerplate compared to filter(f, xs)
18:01:26 <Kaidelong> Applicative has pure
18:01:37 <Kaidelong> ...Arrow?
18:02:15 <hiptobecubic> zwer, the biggest problem is often 'f' is a method on the objects in xs
18:02:15 <Kaidelong> Category could work
18:02:57 <hiptobecubic> zwer, so you're actually doing [foo.id for foo in foos]
18:03:43 <zwer> hiptobecubic, it has been a while since I used python. won't this work?  map(Foo.id, foos)
18:03:54 <zwer> Foo being the type
18:04:19 <hiptobecubic> zwer, nope. Foo.id is an unbound method 'id' on Foo. You want the bound method on each class (which has to do with where 'self' comes from, etc)
18:04:57 <hiptobecubic> zwer, actually no, you might be right, assuming id is a method and not an attribute
18:05:07 <lpaste> monochrom annotated â€œSlow primesâ€ with â€œless slow primesâ€ at http://lpaste.net/2450150964011728896#a119575
18:05:09 <hiptobecubic> if id is an attr it obviously will not
18:05:43 <monochrom> @tell sveit http://lpaste.net/2450150964011728896#a119575
18:05:43 <lambdabot> Consider it noted.
18:06:00 <zwer> yeah, map(str.lower, ["HI", "THERE"]) works
18:06:04 <hiptobecubic> zwer, but really you're getting into shaky territory there concerning which is more easily comprehended by the readed (no pun intended)
18:07:05 <joness> didn't they remove map from python?
18:07:17 <hiptobecubic> joness, no.
18:07:23 <hiptobecubic> joness, it's an iterator now though
18:07:26 <hiptobecubic> in 3.x
18:07:49 <joness> ah ok. I recall Guido threatening to remove lambdas, map and a couple of other functions
18:08:17 <joness> a couple of years ago IIRC
18:08:44 <hiptobecubic> yeah, luckily no one listened.
18:08:53 <chirpsalot> joness: that was eventually dropped, and they left lambdas slightly crippled instead.
18:08:56 <joness> yup
18:09:02 <EvanR> a bunch of nested maps in something like python has got to be hard to read, write, and also be pretty bad performane
18:09:08 <EvanR> relative to some iterator based thing
18:10:00 <systemfault> Creators of dynamically-typed languages are crazy it seems :( (Brendan.... Rasmus... Guido)
18:10:12 <chirpsalot> Yeah, that's the other thing. "Functional programming" isn't the best in Python. It works, but it looks pretty ugly usually.
18:10:25 <Kaidelong> my dad met Guido
18:10:29 <Kaidelong> he's apparently a pretty nice guy
18:10:34 <hiptobecubic> I had lunch with him. Nice guy, yeah
18:10:39 <chirpsalot> systemfault: I don't think Guido is that crazy.
18:11:13 <hpc> taking just guido's language policies he seems rather hateful to an entire branch of programming though
18:11:22 <chirpsalot> hpc: that's changing.
18:11:29 <Kaidelong> it is less weird when you consider the origin of python
18:11:30 <joness> what branch?
18:11:54 <chirpsalot> For instance: https://mail.python.org/pipermail/python-ideas/2014-August/028618.html
18:11:55 <Kaidelong> it was derived from ABC which was meant for education, somewhat like Logo and BASIC
18:12:28 <Kaidelong> so simplicity had some degree of higher priority over good paradigms and implementation
18:12:30 <hpc> oh hey, type signatures
18:12:57 <monochrom> no, not simplicity. instant gratification
18:12:59 <chirpsalot> hpc: yeah, and there's now a PEP for it. It might not happen, but Guido seems to be trying.
18:13:31 <Kaidelong> instant gratification is really important for retaining language learners and getting them to use your platform to write their own applications and libraries
18:13:32 <hpc> larry wall has done well for himself though
18:13:41 <hpc> starting out with the goal of a bash-like language that's more pleasant than bash
18:13:46 <hpc> and ending up with... exactly that
18:13:46 <benzrf> wall for himself
18:13:47 <Kaidelong> this seems to be a lesson Haskell hasn't entirely learned, although Gloss is a good counterexample
18:14:24 <EvanR> making ghci colorful may help with that
18:14:35 <benzrf> just clone idris :^)
18:14:35 <systemfault> hehe
18:14:39 <EvanR> and giving a different error when you try to evaluate a function
18:14:44 <chirpsalot> EvanR: I am in favour of rainbows!
18:14:45 <hpc> i would put haskell in the same category as java in that regard
18:14:46 <monochrom> instant gratification is an anti-thesis to sustainable large structure
18:14:58 <Kaidelong> not neccessarily
18:15:06 <EvanR> > id
18:15:08 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
18:15:08 <lambdabot>    arising from a use of â€˜M577743107590444142415689.show_M5777431075904441424...
18:15:08 <lambdabot>  The type variable â€˜a0â€™ is ambiguous
18:15:13 <monochrom> for example, dynamic typing helps instant gratification and hurts sustainable large structure
18:15:19 <hpc> parts of it you spend years learning how to use properly, but when you do you're a much better programmer for it and can make some pretty great systems
18:15:20 <Kaidelong> you can get pretty good results out of Java, C++, and for that matter certain Haskell libraries, even writing pretty bad programs in them
18:15:43 <hpc> (for java, that thing is the tools - it makes you a better programmer at everything that isn't about writing code)
18:15:44 <Kaidelong> if a person is thinking
18:15:54 <Kaidelong> "I've already written a bunch of screensavers in this thing"
18:16:05 <Kaidelong> I think that will motivate them to stick around and learn how to do things properly
18:16:42 <hpc> if you go into haskell with "i wanna learn some theory" you do get that instant gratification back though
18:16:46 * hackagebot web-routing 0.1.2 - simple routing library  http://hackage.haskell.org/package/web-routing-0.1.2 (HirotomoMoriwaki)
18:16:57 <monochrom> :)
18:16:59 <hpc> much like going into java with "i wanna make some $$$"
18:17:17 <Kaidelong> I actually do like Java despite its verbosity
18:17:34 <Kaidelong> and I do think object oriented programming is a good paradigm, several of them
18:17:43 <Kaidelong> the lack of a good definition for the term is what annoys me about it
18:17:44 <hpc> yeah, some of java's rigidness is good for forcing certain programmers to do the right damn thing for once
18:18:04 <hpc> for all the things i love in perl, POD documentation is not one of those things
18:18:09 <hpc> it's ugly and nobody writes it well
18:18:12 <Kaidelong> that's also what annoys me about C++
18:18:34 <hpc> it's too freeform and doesn't force you to understand what parts of your code are documented
18:18:39 <rasen> I hate java
18:18:42 <EvanR> yeah the rigidness of java
18:18:53 <EvanR> Object simpleApi(Object)
18:19:18 <EvanR> the dynamic typing of java
18:19:34 <Kaidelong> it's very close to being a great OO paradigm language but then it messes up weird things like like using passing by value as the default, not having a good built in garbage collector, silently giving you null pointers when exceptions get thrown inside of constructors, etc
18:19:38 <hpc> that's just subverting the type system
18:19:43 <joness> EvanR, well, haskell has Dynamic :)
18:19:56 <EvanR> joness: what haskell library even uses Dynamic?
18:20:05 <joness> no clue
18:20:16 <Kaidelong> Having a root object is a good idea IMO, so long as you can actually recover type information somehow without an unsafe downcast
18:20:26 <monochrom> the way of Paul Hudak's book (Haskell School of Expression) provided instant gratification, or close enough. much graphics and music early on.
18:20:27 <Kaidelong> as far as I know OCaml is the only thing that has really managed this
18:20:57 <monochrom> unfortunately I only dare say "provided" because some of the necessary libraries are not quite up to date
18:20:58 <EvanR> still, its dynamic typing
18:20:58 <Hijiri> I know Eff uses something sort of like Dynamic, but it might not be the same Dynamic
18:21:02 <Kaidelong> monochrom: I've been wanting to buy that book but I'm scared of being stuck with a bunch of bitrotted libraries that don't work on windows
18:21:13 <Hijiri> but the interface is filled with type-safe goodness
18:21:15 <hpc> EvanR: it's not, it's cast-oriented typing
18:21:29 <Hijiri> well dynamic is type-safe too, but the interface has more guarantees about things
18:21:30 <hpc> you can do the same in C, but it's still a somewhat static type system
18:21:31 <Kaidelong> speaking of which
18:21:35 <Kaidelong> why doesn't OCaml rule the world
18:21:40 <hpc> (in most places, a sized type system but that's unrelated)
18:21:43 <Kaidelong> just its ugly syntax?
18:22:04 <SrPx> Kaidelong: because it is just Haskell without the main point
18:22:08 <monochrom> OCaml doesn't rule the world because Haskell stole my heart from it. :)
18:22:25 <Kaidelong> OCaml has structural typing and a familiar imperative paradigm
18:22:28 <geekosaur> (and is doing type alchemy on it :p )
18:22:32 <monochrom> yes, if Haskell didn't exist, I would be with OCaml.
18:22:52 <EvanR> im really glad haskell exists then
18:23:18 * hpc is still waiting for someone to come up with a type system to express perl's list flattening
18:23:21 <mmachenry> Yeah I think I'd be programming a lot more OCaml if not for Haskell.
18:23:30 <Kaidelong> I feel kind of left out. The main thing I like about Haskell are two things everyone else seems to hate
18:23:40 <hpc> which are?
18:23:41 <Kaidelong> the monadic API for side effects and the lazy evaluation
18:23:53 <hpc> i am ambivalent towards lazy evaluation
18:23:54 <MP2E> I love those things
18:23:55 <HeladoDeBrownie> liberal definition of "everyone else" ;)
18:23:59 <monochrom> I am on the same boat as yours.
18:23:59 <hpc> but i very much love Monad
18:24:06 <hpc> do-notation is my BFF
18:24:07 <MP2E> I mean, I think Monad is overrated because Applicative usually works
18:24:11 <MP2E> but it's not *bad* or anything
18:24:15 <EvanR> i like monad api for main-effects
18:24:17 <Kaidelong> well Frege is the only Haskell derivative I know of that hung onto both
18:24:29 <SrPx> I find it interesting, we have: strong typing, unityping, We have: impure, purity. We have: (impure,typed) languages (java, c++). We have: (impure,untyped) languages (python, javascript). We have: (pure,typed) languages (haskell, idris). We don't have any (pure, untyped) language...
18:24:31 <joness> applicative has no pwetty syntax sugar
18:25:07 <Kaidelong> SrPx: applicative common lisp
18:25:09 <ReinH>  joness banana brackets
18:25:18 <MP2E> SrPx: well most of the benefits of being pure don't really manifest until you have a strong type system
18:25:25 <Kaidelong> and early versions of REBOL, but they decided purity wasn't worth it pretty early on
18:25:29 <monochrom> see, I even wrote the extremist fundamentalist apologetic http://www.vex.net/~trebla/haskell/prerequisite.xhtml#leibniz
18:25:37 <hpc> SrPx: the combination of pure and untyped would be one confusing son of a bitch
18:25:45 <SrPx> is it a language? I thought it was some sort of theorem prover
18:25:51 <Hijiri> could be like the untyped lambda calc
18:25:55 <Hijiri> everything is functions
18:25:55 <Kaidelong> the big win for lazy evaluation for me is that mentally all you ever have to do in your head is one step at a time
18:25:57 <SrPx> MP2E: I strongly, strongly disagree with that.
18:26:02 <Kaidelong> and you already capture how your program actually works
18:26:03 <Hijiri> so functions can always apply things together
18:26:13 <hpc> Hijiri: and eschew IO entirely?
18:26:17 <mgsloan> I do believe that there's general consensus around applicative do-notation being a good idea now that AMP is in: https://ghc.haskell.org/trac/ghc/wiki/ApplicativeDo
18:26:18 <Kaidelong> if it does anything more involved, it's just an optomization
18:26:19 <hpc> might work as a DSL
18:26:22 <HeladoDeBrownie> Hijiri, why not have it untyped in the same sense python is untyped? everything is a case of one big type
18:26:33 <cmccann> @quote idiom.brackets
18:26:33 <lambdabot> cmccann says: Idiom brackets are where you consume a mixture of alcohol and Conor McBride papers until your vision gets blurry enough that you can't actually see the Applicative operators anymore.
18:26:37 <Hijiri> I guess that works too
18:26:53 <MP2E> SrPx: Oh? What benefit would being purely function give you without type safety?
18:26:57 <monochrom> haha
18:26:58 <MP2E> functional*
18:27:03 <Hijiri> I was wondering how hard total functions would be with untyped
18:27:16 <Kaidelong> type systems are one way to capture information about whether or not things are pure or impure
18:27:25 <Kaidelong> I don't agree with the assertion that they are the only way
18:27:27 <Hijiri> you could just have some member for failure, and use it for everything
18:27:34 <Hijiri> which would just be null I guess
18:27:35 <cmccann> if you want pure and untyped, does Lazy K count?
18:27:42 <joness> mgsloan interesting!
18:27:45 <Kaidelong> although you could argue that the kind of static checking you end up with is equivalent to a type system
18:27:57 <monochrom> yeah :)
18:28:09 <Kaidelong> also SrPx isn't Erlang frequently considered "purely functional" in as far as state is contained in a very rigorous way?
18:28:13 <ab9rf> is lazy k like special k?
18:28:18 * ab9rf hides
18:28:31 <SrPx> MP2E: all the benefits in the world? I.e., referential transparency; being able to inline/partially evaluate your whole program to normal form!...
18:28:45 <SrPx> Kaidelong: dunno!
18:29:09 <EvanR> erlang doesnt sound purely functional at all
18:29:25 <ab9rf> my impression of erlang does not intersect with functional
18:29:26 <ReinH> Kaidelong: No, Erlang is not purely functional.
18:29:27 <cmccann> ab9rf: there's probably some droll remark about comparing them but I'm too lazy to think of it
18:29:39 <SrPx> Also I think that impurity is just broken, it makes no sense. You can do absolutely anything impurity can do with pure functions, by just creating a function that receives the state of the program and returns the next state. Now what?
18:30:04 <EvanR> SrPx: how about a pure assembly language? ;)
18:30:11 <MP2E> Sure, but why bother if the compiler can't even find the errors for you? Just because something is pure does not mean it is easy to follow. Easier, sure
18:30:13 <SrPx> EvanR: in what meaning?
18:30:15 <ab9rf> SrPx: but that requires dragging around these fugly state objects everywhere!  and that makes my fingers tired.
18:30:17 <Kaidelong> also languages like Java could be considered to encourage a "pure" style in practice excepting anti-patterns like singletons and mutable static variable
18:30:17 <Hijiri> you could duplicate program state
18:30:23 <Kaidelong> state is tied to object lifetimes
18:30:25 <Hijiri> unless you do something like clean
18:30:28 <EvanR> SrPx: an assembly language, which is designed as you say
18:31:17 <Hijiri> are Java singletons classes with a single member?
18:31:27 <Hijiri> like those generated by lambda
18:31:36 <EvanR> a single instance
18:31:38 <Kaidelong> they're classes with only a single instance
18:31:52 <SrPx> MP2E: hmm I don't follow what you mean
18:31:56 <Kaidelong> there are some legitimate uses for them, but they generally indicate that you're not using OOP to constrain side effects
18:32:01 <systemfault> They're basically "glorified globals"
18:32:05 <systemfault> (Singletons)
18:32:07 <ab9rf> singletons are usually an indication of an attempt to implement a global without calling it a global
18:32:22 <Kaidelong> speaking of which, global top level mutable state is useful in Haskell too
18:32:32 <Kaidelong> and there probably should be some language support for it when it is needed
18:32:34 <Hijiri> so like
18:32:43 <SrPx> EvanR: what do you mean by an assembly language? I'm not sure what you are trying to do exactly
18:32:44 <Hijiri> GlobalMakingMoreThanOneWillBreakYourProgram
18:32:52 <ab9rf> Kaidelong: honestly i think the existing monads for such things are sufficient
18:32:55 <joness> lol
18:32:59 <SrPx> ab9rf: uhm... are you joking?
18:33:09 <ab9rf> SrPx: about what?
18:33:14 <EvanR> SrPx: ... its a language which an assembly translates to machine language
18:33:16 <jle`> in many cases global mutable variables in the runtime make a lot of sence, semantically
18:33:17 <SrPx> ab9rf: that dragging around the objects is boring
18:33:18 <EvanR> assembler
18:33:19 <ab9rf> SrPx: i'm only occasionally serious, but i might have bene recently
18:33:22 <ab9rf> SrPx: that was sarcastic
18:33:25 <dmwit> Kaidelong: Well, this "you can use (s -> (a, s)) as a model of impure languages" is not totally convincing. There are very real practical concerns about implementation that are being completely ignored by the semantics there.
18:33:50 <ab9rf> SrPx: i spent like three hours last night trying to convince a php programmer that dependency injection was not a waste of time
18:34:00 <jle`> sense, did i really type sence
18:34:12 <SrPx> EvanR: ... I don't get really, you are asking if it is possible to write a compiler to a pure untyped functional language? Or to write a pure language that looks like assembly, with instructions and stuff
18:34:18 <SrPx> sorry
18:34:42 <SrPx> ab9rf: ah okay :P
18:35:00 <Kaidelong> dmwit: the trick with OOP isn't to make some impenetrable barrier between "pure" and "impure" worlds but to ensure that "object a cannot do anything to object b unless I give it a reference to object b" and the associated property "if object c was never given a reference to object a then it can't give a reference to object a to an object b it can talk to"
18:35:06 <ab9rf> untyped functional language?
18:35:10 <monochrom> please don't spend too much time convincing anyone.
18:35:15 <Kaidelong> it's a different kind of separation of state but it's still useful
18:35:16 <MP2E> yeah
18:35:24 <MP2E> it's not really worthwhile to spend all your energy trying to convince others
18:35:29 <MP2E> it's a lesson i'm still learning :)
18:35:34 <EvanR> SrPx: assembly languages are usually considered "untyped", also they are essentially full of "impurity", often you see people changing the first one, but what if you changed the second one
18:35:37 * rasen imagine functional instruction set
18:35:41 <EvanR> just a thought experiment
18:36:17 <ab9rf> i wouldb;t cobnsder an assembly language untyped
18:36:18 <dmwit> Kaidelong: I have no idea where this comment about OOP came from. It seems completely unrelated to your previous claim to me.
18:36:29 <ab9rf> Kaidelong: your OOP commenty makes no sense to me
18:36:56 <shachaf> whoa, speaking of which, remember <ddarius> do r <- newIORef (return ()); writeIORef r (join (putStrLn "*" >> readIORef r)); join (readIORef r)
18:37:07 <Kaidelong> dmwit: object oriented programming is a way to prevent global state from infecting the rest of your program. State is contained in objects. Two objects that don't have a reference to each other cannot change each other in any way.
18:37:11 <ab9rf> shachaf: hah
18:37:34 <Kaidelong> so you can look at your source code and see
18:37:37 <SrPx> EvanR: uhm I'm not sure this is what you mean, but you can easily define assembly in lambda calculus (ie, add state x y = ...) and then use a syntax sugar so you can write it monadically and it will look exactly like assembly
18:37:45 <ab9rf> Kaidelong: object oriented programming languages don't really do much to control global state
18:37:49 <dmwit> Kaidelong: What does that have to do with "impurity is useless because it can be emulated in pure languages"?
18:37:57 <Kaidelong> ab9rf: yeah, they don't, it's true
18:38:05 <Kaidelong> dmwit: I did not say that
18:38:34 <SrPx> indeed you could probably reimplement assembly itself in lambda calculus and make syntax sugars so that it is perfectly homoiconic to x86 or something
18:38:35 <EvanR> SrPx: well if its untyped, monads dont really get you much
18:38:49 <EvanR> yes! homoiconic assembly !
18:38:50 <dmwit> Kaidelong: You're absolutely right. SrPx said it. I'm sorry.
18:38:57 <dmwit> SrPx: My complaint is now aimed at you. =P
18:39:02 <Lokathor> so, about how hard is it to build the newest versions of GHC and cabal (on linux)?
18:39:03 <ab9rf> Kaidelong: "two objects that don't have a reference to each other cannoyt change eath other in any way" that's true in any language, oo or not, exclusive of code that randomly scribbles on bits of memoryu that it doesn't own at least
18:39:15 <Kaidelong> ab9rf: strictly, it's not true of OO languages
18:39:18 <dmwit> ab9rf: C ain't like that.
18:39:21 <MP2E> Kaidelong: "speaking of which, global top level mutable state is useful in Haskell too" <- It is! this is why we have the Reader type :)
18:39:24 <HeladoDeBrownie> ab9rf, JAVAjustkiddingstaticclasses -_-
18:39:27 <MP2E> oh wait you said mutable
18:39:32 <MP2E> replace Reader with State then
18:39:33 <Kaidelong> in practice they allow singletons and mutable static members
18:39:33 <MP2E> :P
18:39:42 <Kaidelong> which allow objects to have spooky action at a distance
18:39:43 <dmwit> ab9rf: for(i = 0;; i++) *i = 0; /* write to everywhere */
18:39:48 <ab9rf> dmwit: you nede a pointer to scribble on something else, unless you're just going to randomly piss on memory
18:39:52 <Lokathor> i've got a fresh system, and the package manager could get me the haskell-platform 2013.2, but looking at the version numbers that won't be able to build me ghcjs
18:40:05 <SrPx> dmwit: you are asking if I agree that impurity is useless because it can be emulated?
18:40:10 <dmwit> ab9rf: People can and do write bugs in their C code.
18:40:13 <SrPx> EvanR: of course they do :)
18:40:15 <monochrom> dmwit: "write-once writes-everywhere"? :)
18:40:23 <[swift]> ab9rf: in fairness, buffer overflows and the like exist
18:40:43 <ab9rf> dmwit: ok, i get your poin in that regard.  c is indeed much easier towrite code that does random crap.
18:40:44 <glguy> You'd have to write legal C to say it's some thing C let's you do.
18:40:48 <[swift]> ab9rf: but this is really an irrelevant digression about memory safety
18:40:55 <ab9rf> glguy: that is legal c, that's dmwit's point
18:41:00 <EvanR> SrPx: then in what sense in normal assembly language impure
18:41:16 <ab9rf> [swift]: agreed.
18:41:21 <shachaf> (<ddarius> Exercise: Where is the recursion?)
18:41:27 <glguy> No, arbitrary pointer operations aren't automatically valid C
18:41:31 <ab9rf> EvanR: virtually all assembly instructions have side effects
18:41:54 <rasen> agree with glguy
18:42:11 <EvanR> ab9rf: the language has side effects? the syntax has side effects?
18:42:15 <rasen> referencing random memory is not valid C
18:42:16 <joness>  glguy not valid in the "it is undefined" sense. but they are valid in the "it compiles" sense
18:42:32 <EvanR> ab9rf: or does the resuling machine code have side effects when its executed
18:42:34 <ab9rf> define "valid"
18:42:51 <monochrom> is this going to be a huge legal battle fought to supreme courts and international courts? :)
18:42:52 <ab9rf> EvanR: i believe only the latter has any coherency to it
18:43:04 * ab9rf files for a writ of certiorari 
18:43:23 <EvanR> yeah so diffrernt subject
18:43:52 <[swift]> lol
18:44:30 <ab9rf> EvanR: this hinges on what a 'side effect' is.  mov.l ax, bx not so much; but anything that scribbles into a memory location is a potential side effect and certainly operations on ciscy architectures are full of side effects
18:45:27 <SrPx> C is actually a pure language, in case you don't know. It just happens that you can't opt-out the monadic syntax for IO.
18:46:13 <EvanR> so the pure language thing, outside haskell, has become very annoying ;)
18:46:22 <Kaidelong> well you use the C preprocessor to do that
18:46:47 * hackagebot snaplet-persistent 0.5 - persistent snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-persistent-0.5 (DougBeardsley)
18:46:58 <EvanR> all programming languages are pure
18:47:35 * monochrom thinks of something witty to say
18:47:56 <monochrom> cobol is not a pure programming language. it sometimes contains English. :)
18:47:57 <SrPx> couldn't be different, our universe is pure, after all
18:48:37 <SrPx> proof: einstein thinks so and we all are less intelligent than him. qed
18:48:54 <athan> SrPx++
18:49:03 <monochrom> if our universe is pure, then what is impure? or where can I find impure?
18:49:24 <athan> monochrom: You have to look beyond awareness
18:49:33 <rasen> in couniverse?
18:49:38 <SrPx> monochrom: depends on where you are buying the stuff
18:50:13 * monochrom godelizes godel
18:51:15 <athan> hmm... I could use both attoparsec and parsec in a single parser, can't I?
18:51:50 <MP2E> SrPx: http://conal.net/blog/posts/the-c-language-is-purely-functional fun reading
18:52:16 <dmwit> athan: Not easily.
18:52:38 <mniip> can I pattern-match a bottom if its type is a newtype?
18:52:52 <jle`> mniip: in what way do you mean?
18:53:02 <mniip> like `newtype Foo = Foo Int`
18:53:07 <mniip> f (Foo _) = ...
18:53:28 <geekosaur> you can't pattern match a bottom
18:53:35 <mniip> ok
18:53:37 <monochrom> > let godelize = product . zipWith ($) [(2^), (3^), (5^), (7^), (11^)] . map (subtract 96 . fromEnum) in godelize "godel"
18:53:38 <lambdabot>  60549593208080007397378320000
18:53:38 <geekosaur> bottom isn't a value; it's failure to produce a value
18:53:48 <mniip> is it common practice to write 'f ~(Foo _) = ...' then?
18:53:56 <jle`> do you mean, will doing that be bottom if `_` is bottom?
18:53:57 <geekosaur> (exception, infinite loop, crash, ...)
18:53:58 <dmwit> mniip: that will match all values, including bottom
18:54:05 <jle`> mniip: well because it's a newtype, why don't you just do f _ = ...?
18:54:11 <jle`> newtypes only have one constructor
18:54:13 <mniip> wait you can do that?
18:54:17 <mniip> oh
18:54:18 <mniip> nvm
18:54:25 <dmwit> mniip: your first one, i mean
18:54:32 <jle`> > let f _ = 5 in f (Identity 4)
18:54:34 <lambdabot>  5
18:54:40 <Kaidelong> WOULD YOU TELL THAT TO dR. hARPER
18:54:41 <jle`> > let f _ = 5 in f (Identity (sum [1..]))
18:54:42 <lambdabot>  5
18:54:46 <Kaidelong> oh
18:54:49 <jle`> > let f (Identity _) = 5 in f (Identity (sum [1..]))
18:54:50 <Kaidelong> didn't mean to capslock
18:54:51 <lambdabot>  5
18:54:51 <Kaidelong> sorry
18:55:23 <Kaidelong> it's a *syntactic* value in as far as the type system is concerned
18:55:41 <Kaidelong> but you can't store an infinite list in Haskell either like a regular value, it'll just loop infinitely
18:56:18 <EvanR> writeIORef [1..] foo
18:56:24 <Kaidelong> it's just a matter of how syntactic values are mapped to semantics at runtime
18:56:29 <EvanR> did the impossible
18:56:32 <Kaidelong> EvanR: IORefs are still lazy I think
18:56:34 <mniip> look
18:56:39 <Kaidelong> it doesn't store the entire list
18:56:44 <monochrom> you have the parameters swapped
18:56:44 <EvanR> hehe
18:56:47 <SrPx> "C programmersâ€ really program not in C, but in the purely functional language cpp (the â€œC Preprocessorâ€). As with any purely functional language, cpp consists only of (nestable) expressions, not statements. Now hereâ€™s the clever part: when evaluated (not executed), a cpp expression yields a (pure) value of type C, which is an ADT (abstract data type) that represents imperative programs.
18:56:50 <SrPx> Enough internet for today...
18:56:55 <mniip> @let data Identity a = Identity a deriving Show
18:56:56 <lambdabot>  .L.hs:135:37:
18:56:56 <lambdabot>      Ambiguous occurrence â€˜Identityâ€™
18:56:56 <lambdabot>      It could refer to either â€˜L.Identityâ€™, defined at .L.hs:159:1
18:56:59 <mniip> ugh
18:57:01 <EvanR> dammit i just checked it too
18:57:06 <MP2E> SrPx: hahah
18:57:06 <mniip> @let data Id a = Id a deriving Show
18:57:08 <lambdabot>  Defined.
18:57:09 <MP2E> yeah it's supposed to be ridiculous
18:57:14 <mniip> > fix (\(Id a) -> Id 0)
18:57:18 <lambdabot>  mueval-core: Time limit exceeded
18:57:22 <mniip> doesn't timeout with newtype
18:57:29 <Kaidelong> it rung true to me
18:57:31 <chirpsalot> SrPx: CPP isn't Turing complete, though :(?
18:57:42 <Kaidelong> I think it is chirpsalot
18:57:55 <EvanR> even if it were, all the better
18:57:58 <rasen> SrPx, I must say that to my colleges
18:57:58 <EvanR> dont want cpp looping
18:58:23 <rasen> they'll be surprised
18:58:49 <chirpsalot> Kaidelong: no it isn't.
18:58:56 <dibblego> that post makes an excellent point about "... is purely functional" and the parody is perfect
18:59:09 <MP2E> i agree :)
18:59:10 <chirpsalot> Kaidelong: it doesn't allow recursive replacements.
18:59:26 <n4x> can't you do recursive imports?
18:59:39 <dmwit> mniip: yes, the outermost constructor in a newtype pattern always matches immediately
18:59:41 <Kaidelong> alright
18:59:45 <johnw> n4x: you can, of a sort
18:59:59 <mniip> so yeah
19:00:20 <mniip> âŠ¥ can match (Foo a) if Foo is a newtype
19:00:35 <dmwit> mniip because it isn't really there ;-)
19:01:02 <monochrom> because âŠ¥ can match (a), too
19:01:27 <nkar> could anyone explain the idea behind regex-pcre-builtin version numbers?
19:01:35 <zq> shachaf: the knot is tied with the writeIORef, and then entered by join (readIORef r) which translates to do { ioaction <- readIORef r; ioaction; }
19:01:47 <dmwit> mniip: i told you that right when you first asked...
19:02:21 <mniip> I was distracted by '[05:51:34] <geekosaur> you can't pattern match a bottom'
19:03:03 <dmwit> you can't write a pattern that only matches bottom
19:03:48 <mniip> that would be against the halting problem
19:03:56 <dmwit> yes
19:04:28 <mniip> well obviously I mean "is matching âŠ¥ against (Foo a) a âŠ¥ or not"
19:04:29 <dmwit> but that doesn't stop people frem asking for it =)
19:04:55 <dmwit> it was not obvious at all
19:05:10 <EvanR> cant wait till that problem is solved
19:05:17 <mniip> it is solved?
19:05:45 <EvanR> ghc 7.10?
19:05:50 <mniip> oh
19:05:56 <mniip> which problem you mean then :S
19:06:05 <EvanR> halting problem
19:06:08 <mniip> ah
19:06:13 <EvanR> its quite inconveneint
19:06:29 <mniip> memcomputing, idk?
19:06:58 <monochrom> ghc 7.10 will solve the halting problem. ghc 7.12 will fix that bug.
19:07:02 <mniip> maybe if it can solve NP-hard problems in P, it can also solve infinite computations finitely?
19:07:23 <dmwit> ?remember EvanR I can't wait until the halting problem is solved.
19:07:23 <lambdabot> It is stored.
19:07:50 <SrPx> MP2E: just posted that on my programming group. Ridiculous.
19:07:55 <dmwit> a statement of both anticipation and fact.
19:08:45 <EvanR> lol
19:09:11 <HeladoDeBrownie> monochrom, oh no, they're breaking fix? and recursive definitions? andâ€¦ a whole mess of other stuff? atrocious!
19:09:20 <csd_> Hi could someone please explain why I'm receiving the following error message? http://pastebin.com/K9zWnEev
19:09:26 <HeladoDeBrownie> wait i've got it
19:09:29 <HeladoDeBrownie> > fix error
19:09:30 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
19:09:33 <HeladoDeBrownie> perfect.
19:10:03 <osa1> wow, I'm using GHC HEAD with Cabal 1.22 and something very weird is happening
19:10:23 <ab9rf> your dishes are being washed automatically?
19:10:23 <osa1> let's say I have an executable target in .cabal named my-exec, and main-is: MyExec
19:10:36 <HeladoDeBrownie> csd_, your type signature doesn't include the fact that values of type a can be compared for equality, but you are doing so. you need an Eq a constraint.
19:10:48 <osa1> cabal is failing with this: dist/build/my-exec/my-exec: does not exist
19:10:50 <HeladoDeBrownie> csd_, isPal :: (Eq a) => [a] -> Bool
19:10:55 <monochrom> csd_: are you happy if I say: it has to be "isPal :: Eq a => [a] -> Bool"?
19:10:56 <sgronblo> didnt that happen in that one disney movie with mickey mouse?
19:11:01 <osa1> but if I change module name to `Main` and install one time, then I can change module name back and it works
19:11:26 <csd_> , HeladoDeBrownie, thanks I get it now
19:11:33 <nkar> osa1: are you sure that dist/build exists?
19:11:39 <csd_> err monochrom @ HeladoDeBrownie
19:11:52 <nkar> osa1: the directory in dist might be called differently
19:11:53 <monochrom> :)
19:11:53 <ab9rf> osa1: module name has to match file name, unless the module is named "Main"
19:11:59 <HeladoDeBrownie> error: monochrome at line HeladoDeBrownie
19:12:20 <csd_> (good enough)
19:12:23 <HeladoDeBrownie> ;)
19:12:43 <ab9rf> osa1: it's probably worjing because there's a hjanging-about .hi file that obviates the compilation
19:12:43 <osa1> ab9rf: yeah what I'm saying is you can trick Cabal
19:13:46 <csd_> I actually do have a follow up question. How do I know when a type constraint is appropriate versus putting an explicit type in the type declaration
19:13:47 <drbean> what wrong with: isDummy :: String -> Bool
19:13:50 <drbean> isDummy ("dummy" ++ [d]) | isDigit d = True
19:14:16 <HeladoDeBrownie> csd_, constraints are usually for when you need an instance of a typeclass to be available for a given type variable.
19:14:35 <drbean> I'm getting the error: Parse error in pattern: "dummy" ++ ['1']
19:14:58 <csd_> ok got it
19:15:07 <csd_> haskell makes much more sense the second time around
19:15:12 <csd_> :-P
19:15:34 <HeladoDeBrownie> csd_, if by "explicit type" you mean a type that isn't quantified (not a variable), then the constraint isn't usually necessary, because if there is an appropriate instance the compiler will know to find it
19:16:14 <HeladoDeBrownie> essentially the error in using the type [a] -> Bool for that function is that you are saying *any* concrete type a can be used there, but not all have define equality
19:17:19 <csd_> My second question was asked because I was forgetting the distinction between type classes and types, and that Num a => a -> b is very different than Int -> b
19:17:45 <HeladoDeBrownie> yep. did i help clarify that?
19:17:58 <csd_> you did thank you
19:18:03 <HeladoDeBrownie> no problem
19:19:06 <drbean> what wrong with: isDummy :: String -> Bool
19:19:09 <drbean> isDummy ("dummy" ++ [d]) | isDigit d = True
19:19:34 <drbean> Parse error in pattern: "dummy" ++ [d]
19:19:43 <geekosaur> yes, you can't use that in a pattern
19:20:10 <mniip> you can only use a combination of constructors in a pattern
19:20:13 <geekosaur> and ++ can't be a constructor
19:20:41 <sgronblo> Well if you used those Ropes it could be?
19:21:01 <mniip> @let isDummy ('d':'u':'m':'m':'y':d:[]) | isDigit d = True
19:21:03 <lambdabot>  Defined.
19:21:05 <mniip> works
19:22:37 <geekosaur> well, aside from being partial :p
19:24:42 <HeladoDeBrownie> who needs False when you have bottom
19:25:23 <mniip> by bottom do you mean error "Non-exhaustive patterns in function isDummy"
19:25:42 <HeladoDeBrownie> no, i mean the value of the function in the case that that error is alluding to
19:25:57 <HeladoDeBrownie> e.g., isDummy [] gives bottom
19:28:17 <johnw> whoa, I just had a major "aha!" moment with edwardk's lens library
19:28:43 <johnw> it began with trying to make Hoopl graphs Traversable, which I suceeded at doing, but ended with me realizing what edwardk means when he talks about lens as a way of building interfaces
19:29:11 <Lokathor> woah woah woah, edwardk is actually Edward A. Kmett. this just clicked for me
19:29:18 <johnw> yep
19:29:37 <Lokathor> that guy is cool, he helped me out earlier with using lens to look into an arbitrarily nested json object
19:30:14 <johnw> i'm discovering how lenses can not only replace Traversable in a very facile way, but add dimensions of flexbility on top that Traversable can't give you
19:30:52 <johnw> meanwhile, the lenses I'm writing end up being identical code to what I write for a Traversable instance
19:30:55 <shachaf> Lokathor: Which guy is cool? edwardk or Edward A. Kmett?
19:31:29 <Lokathor> according to johnw they're the same person?
19:31:32 <monochrom> Prince Edward A. Kermit the Frog
19:31:37 <shachaf> Yes. But it was a funny phrasing.
19:31:39 <shachaf> johnw: I feel like I went over this as a motivation for lens in a conversation with you a long time ago.
19:31:47 <glguy> johnw: is a real programmer (not an actor) and was not paid for that statemetn
19:31:59 <johnw> shachaf: you did, but I was insufficiently clear to appreciate what you were saying then
19:32:01 * mgsloan starts wondering if ekmett's middle name actually starts with "A"
19:32:34 * johnw now wants to read through his past logs of conversations with shachaf!
19:32:41 <shachaf> Someone was insufficiently clear, at any rate. Oh well.
19:32:44 <alpounet> johnw: realized the same thing a couple of months ago too, yeah. this led me to embracing traversals even more
19:33:23 <johnw> i mean, I spent hours crafting newtype wrappears so that I could "focus" on a type variable, but since the type is abstract to Hoopl and is only known to the user of Hoopl, I was forced to use a type class and..... lens deleted ALL of it
19:33:40 <shachaf> Type classes aren't the solution to all problems.
19:33:45 <johnw> no, they certainly are not
19:34:08 <johnw> I seem to learn that fact in ever deeper measure
19:34:47 <shachaf> They're good for figuring out code from types, in a particular way. That's great if you happen to want to do things that way. But you can also just write the code you want.
19:36:58 <cmccann> shachaf: but are type classes the problem to all solutions?
19:39:25 <Lokathor> typeclasses help with libraries the most, it seems
19:41:18 <mniip> is there a way to read 8-bit data from a socket without a mess of bytestrings going on?
19:41:53 <ab9rf> mniip: not really, no
19:41:56 <mniip> sad
19:42:10 <ab9rf> mniip: that's because the data that comes off a socket is a bytestring
19:42:17 <glguy> You can just do it with bytestrings and leave the mess behind
19:42:28 <mniip> "leave the mess behind"?
19:42:37 <zwer> what mess are you talking about?
19:42:41 <ab9rf> trying to read it with anything else is kinda like trying to use a screwdriver to pound a nail
19:43:10 <glguy> I've done that before where I needed to drive a nail in a narrow space
19:43:11 <glguy> it worked out
19:43:14 <mniip> 'BS.pack "hello"' mess
19:43:24 <ab9rf> how is that messy?
19:43:51 <ab9rf> do yhou want haskell to pretend that characters fit in 8 bits?
19:43:59 <geekosaur> there is OverloadedStrings, at the price that you sometimes need to specify the type if it can
19:44:03 <geekosaur> t be inferred
19:44:18 <ab9rf> don't blame haskell, blame the idiot who thought that you could fit a string of characters into a string of bytes
19:44:47 <geekosaur> and that literals with characters outside what a ByteString can hold will see them quietly vanish if used in a context that wants a ByteString
19:44:52 <mniip> nah I'm fine with being unable to send "\x100"
19:45:25 <sdegutis> I think I understand monads now, but this next chapter on LyaH is confusing the heck out of me. Can anyone recommend a resource which explains the kind of cool things monads can do a lot less convolutedly?
19:45:27 <mniip> receiving (ByteString.singleton 255) as "\xFF" though
19:45:32 <monochrom> you're reading, not creating, a Bytestring. so how does BS.pack come into the picture?
19:45:53 <mniip> monochrom, the protocol is symmetric
19:46:07 <mniip> I can't provide String sending functions but ByteString reading functions
19:46:33 <Lokathor> sdegutis what do you mean?
19:46:42 <carter> mniip: if you can assuem some encoding, you can hide the bytestring like ness
19:46:46 <monochrom> does your protocol use a lot of human-readable things such as "hello"?
19:46:58 <mniip> yes
19:46:58 <sdegutis> I mean I understood everything up to http://learnyouahaskell.com/for-a-few-monads-more but this chapter makes no sense and seems completely irrelevant.
19:47:01 <carter> ascii?
19:47:09 <monochrom> well then too bad
19:47:31 <monochrom> but I would blame it on the protocol pretending to be human speech.
19:47:34 <Lokathor> mniip, consider readning and sending bytestring, but internally processing it as Text, and then just demanding that they send via some particular encoding
19:47:45 <mniip> the protocol in question is the IRC protocol
19:47:56 <monochrom> ah, darn, it is human speech.
19:48:04 <ab9rf> heh, why does everyone write an IRC client as their "first project"
19:48:06 <cmccann> mniip: sounds like a crappy protocol. who even uses IRC these days, anyway.
19:48:11 <mniip> the command name is a fixed ascii string
19:48:27 <mniip> arguments can contain nearly any octets
19:48:37 <ab9rf> octets are not characters
19:48:38 <monochrom> then, you know, I would just bite the bullet and have BS.pack appear here and there.
19:48:47 <ab9rf> if you're using octets, you're in bytestring, not string
19:48:50 <sdegutis> mniip: how long have you been into Haskell?
19:48:55 <monochrom> it's a sucky protocol, the code cannot be too nice
19:48:58 <shachaf> sdegutis: If this book doesn't work for you, maybe try a different book. Or maybe figure out why it doesn't work for you.
19:49:13 <shachaf> It could be that you need to slow down. Who knows.
19:49:13 <mniip> sdegutis, almost a year I think?
19:49:17 <sdegutis> mniip: oh cool
19:49:21 <sdegutis> mniip: I got into it this week.
19:49:44 <Lokathor> sdegutis well i don't remember all the details of this chapter the best, but you've use other languages before, yes?
19:49:47 <sdegutis> mniip: I tried the LyaH book a year ago or so but at the time I was like "why would I want this when it's basically identical to Clojure?"
19:49:48 <mniip> inb4 rewrites mjolnir in haskell
19:49:53 <cmccann> mniip: I recommend venting your frustrations with comments like "-- this code is full of BS"
19:49:53 <sdegutis> Lokathor: yeah
19:50:01 <ab9rf> haha
19:50:06 <sdegutis> mniip: what does inb4 mean? I see that a lot -- and yes, I'm rewriting it in Haskell
19:50:11 <mniip> "in before"
19:50:18 <sdegutis> yes but what's the context?
19:50:29 <Lokathor> well the first example is logging. But sometimes you're not using the IO type, and you want to log anyway, so that's how you keep a log in haskell (well, that's one of the most obvious ways)
19:50:34 <sdegutis> Does it mean "I'm gonna say this thing before it comes to pass hahaha"?
19:50:45 <HeladoDeBrownie> it's predicting someone else will mention that topic
19:50:46 <geekosaur> or "...before anyone else"
19:50:48 <cmccann> sdegutis: basically
19:50:50 <sdegutis> oh ok
19:50:51 <mniip> http://www.urbandictionary.com/define.php?term=inb4
19:50:51 <sdegutis> thanks
19:50:55 <sdegutis> mniip: blocked
19:50:58 <SrPx> Oh. The writer monad. You just realized me what I (knew) I was doing wrong when I computed a value using an ST monad with a single STRef.
19:51:07 <SrPx> Of course...
19:51:11 <geekosaur> s/anyone/EVERYone/
19:51:30 <sdegutis> What's a good tutorial for liftM and join etc?
19:51:30 <mniip> sdegutis, jokingly, or not jokingly implying that sooner or later it will happen
19:51:34 <sdegutis> mniip: got it
19:51:34 <cmccann> sdegutis: I think the original form was "inb4 lock/close/delete/something else that will end discussion forcibly"
19:51:43 <sdegutis> mniip: well yeah you're right about that, I am
19:51:53 <sdegutis> cmccann: ahh
19:51:54 <cmccann> in which case it makes slightly more sense to talk about getting in before it happens
19:51:58 <sdegutis> sure
19:52:27 <cmccann> then it metastasized into more shitty interwebs slang :P
19:52:38 <Lokathor> sdegutis also, the state monad can be important, it's like a generator sort of thing
19:52:57 <sdegutis> Lokathor: ok but is there a way less convoluted and shorter resource on it?
19:53:07 <sdegutis> this guy's style of examples is really awful
19:53:28 <mniip> sdegutis, the source :P
19:53:29 <Lokathor> well this chapter is basically running you though each type of thing really quickly. i'd just skim and remeber it for later
19:53:29 <ab9rf> generator sort of thing?
19:53:41 <Lokathor> then when you want to do a thing, you'll remember what you want to look up
19:53:54 <sdegutis> mniip: maybe, but I'd like to see *why* something is useful alongside how it works
19:54:07 <sdegutis> Lokathor: so then I'm done learning Haskell?
19:54:14 <mniip> woo!
19:54:28 <MP2E> sdegutis: finishing Learn You a Haskell is hardly finished learning Haskell :)
19:54:31 <sdegutis> Like, I feel like there's gotta be something more
19:54:32 <Lokathor> well, you're done learning the syntax. Now you're into stage 2: learning to actually use the standard library
19:54:35 <dmwit> sdegutis: If you're having trouble with monads, I always suggest the article that did it for me: You Could Have Invented Monads.
19:54:39 <benzrf> ach
19:54:42 <sdegutis> dmwit: thanks
19:54:45 <benzrf> sdegutis: if you're having trouble with monads, ask me
19:54:47 <mniip> sdegutis, bookmark this https://www.haskell.org/hoogle/
19:54:53 <benzrf> sdegutis: i am p good at yelling about how everyone gets monads all wrong
19:54:54 <benzrf> 8
19:54:56 <benzrf> 8D
19:55:02 <sdegutis> dmwit, benzrf: but no, I get monads just fine, it's just that chapter was so drawn out and weird
19:55:03 <MP2E> good
19:55:14 <dmwit> sdegutis: I don't know what "that chapter" was.
19:55:23 <Lokathor> http://learnyouahaskell.com/for-a-few-monads-more
19:55:24 <sdegutis> http://learnyouahaskell.com/for-a-few-monads-more
19:55:28 <dmwit> sdegutis: But if you can say what it is you want to learn about, there's a chance I can suggest something useful.
19:55:31 <sdegutis> /c dmwit
19:55:32 <mniip> benzrf, [] >> []
19:55:39 <ab9rf> i idn't really care for lyah's coverage of monads
19:55:42 <benzrf> > [] >> []
19:55:43 <dmwit> Oh, I can't stand LYAH.
19:55:43 <lambdabot>  []
19:55:49 <sdegutis> dmwit: inorite
19:56:01 <sdegutis> I had to skim most of it because he just went on and on and on
19:56:09 <mniip> it's a smiley-face-and-a-valid-expression sort of thing
19:56:10 <Lokathor> sdegutis there's also http://book.realworldhaskell.org/read/
19:56:20 <sdegutis> Lokathor: thanks I may try that one again now
19:56:33 <Lokathor> though.. i might suggest you never open the comment sections, because every time i do they distract me from the main book
19:56:38 <dmwit> sdegutis: Grab the Gentle Intro instead. I liked that one much better. No nonsense, just the good stuff.
19:56:50 <sdegutis> dmwit: nice thanks, I may try that one again
19:56:52 <dmwit> Though it is misnamed. It is only gentle for researchers in PL.
19:56:59 <benzrf> sdegutis: c i s 1 9 4
19:57:11 <sdegutis> benzrf: I finished that -- it doesn't even touch monads, am I mistaken?
19:57:12 <monochrom> it is gentle for me. not researcher in PL
19:57:19 <benzrf> sdegutis: doesnt it
19:57:22 <sdegutis> benzrf: like, it was just two things
19:57:28 <benzrf> erm, wha
19:57:41 <dmwit> monochrom: Okay. Do you have a suggestion of a better way to characterize the people it's gentle to?
19:57:41 <sccrstud92> @pl fx = x
19:57:41 <lambdabot> fx = x
19:57:43 <sccrstud92> @pl f x = x
19:57:44 <lambdabot> f = id
19:57:45 <sdegutis> benzrf: http://www.seas.upenn.edu/~cis194/lectures.html -- just two short html pages
19:58:06 <sccrstud92> @pl (a, b) (c, d) = (a, c + d)
19:58:06 <lambdabot> (line 1, column 16):
19:58:06 <lambdabot> unexpected " "
19:58:07 <lambdabot> expecting operator
19:58:12 <monochrom> "in the same equivalent class as monochrom"  no no just kidding
19:58:14 <dmwit> monochrom: Perhaps it is better to say, "It was intended to be gentle to PL researchers.".
19:58:14 <benzrf> o___o
19:58:15 <sccrstud92> @pl f (a, b) (c, d) = (a, c + d)
19:58:15 <lambdabot> f = (`ap` snd) . (. fst) . (. (+)) . (.) . (,) . fst
19:58:27 <benzrf> sdegutis: that's
19:58:29 <benzrf> sdegutis: that's this year's
19:58:33 <monochrom> I don't care about intentions. they're seldom relevant.
19:58:37 <benzrf> http://www.seas.upenn.edu/~cis194/spring13/lectures.html
19:58:37 <glguy> sccrstud92: You can play with ?pl in /msg
19:58:40 <benzrf> sdegutis: ^
19:58:51 <dmwit> ?pl \(a, b) (c, d) -> (a, c + d)
19:58:51 <lambdabot> (`ap` snd) . (. fst) . (. (+)) . (.) . (,) . fst
19:59:06 <monochrom> it's gentle to self-motivated, proactive students.
19:59:09 <sccrstud92> glguy: im not that familiar with irc. what does that mean?
19:59:24 <dmwit> monochrom: It was not gentle to me, and I am those. But I liked it a lot, and partly because it was not gentle to me.
19:59:41 <glguy> sccrstud92: It means you can type /msg lambdabot ?command
19:59:48 <glguy> and do it in your own private query window
19:59:52 <sccrstud92> ah okay
19:59:54 <sccrstud92> tvm
20:00:11 <dmwit> monochrom: Perhaps our disagreement is about what "gentle" means.
20:00:27 <monochrom> I guess you're right. "gentle" can be different from "likeable".
20:01:23 <monochrom> it's gentle to people who anticipate functional, equational programming.
20:01:46 <monochrom> but it's useful to more people than that. namely, it's useful to self-motivated, proactive people.
20:01:51 <mniip> btw the thing has always bugged me
20:02:14 <mniip> what is the minimal set of functions that can describe any function point-free
20:02:24 <HeladoDeBrownie> sk</sarcasm>
20:02:36 <HeladoDeBrownie> well, that's sort of true
20:02:38 <mniip> S and K are untyped though :P
20:02:50 <mniip> (you forgot about U)
20:02:52 <glguy> There's a single universal combinator I don't remember off the top of my head
20:03:00 <HeladoDeBrownie> i didn't, but fewer people would've got it :P
20:06:07 <sdegutis> cis194 is meant for people familiar with FP?
20:06:15 <benzrf> sdegutis: well
20:06:25 <benzrf> sdegutis: FP as far as javascript goes, probably
20:06:26 <mniip> back to my BS problem, is it common practice to alias 'b = BS.pack' or something
20:06:31 <sdegutis> benzrf: grr
20:06:41 <benzrf> mniip: thats just bs
20:06:53 <sdegutis> mniip: it sure is a BS problem, I'll say!
20:06:54 <sdegutis> or something
20:07:00 <sdegutis> aww, benzrf was inb4
20:07:04 <sdegutis> did i do it right?
20:07:06 <mniip> I can't be bothered to write BS everytime
20:07:08 <joness> mniip you can use OverloadedStrings if BS.pack annoys you. then it is just "hello"
20:07:43 <mniip> hold on
20:07:46 <joness> it allows you to use string literlas for ByteString (and Text), not just for String
20:07:48 <mniip> I can't pattern-match BS D:
20:08:31 <joness> BS is not a list
20:08:46 <joness> if you're trying to do (x:xs)
20:08:49 <mniip> no
20:08:55 <mniip> I'm trying to do full equality
20:09:01 <sdegutis> joness, mniip: yeah I've heard good things about overllaoedstriongs
20:09:21 <Adeon> you can pattern-match bytestrings with string literals, if you have OverloadedStrings
20:09:33 <mniip> hmm
20:09:50 <Adeon> even if you don't, with view patterns you could do it in an uglier way
20:12:24 <mniip> hmm I have a better idea
20:12:53 <mniip> I'll read with the bytestring interface, but convert to string immediately
20:13:11 <mniip> if the user needs, they can decode the utf8 or whatever later
20:13:40 <mniip> basically contain bytestring within a string
20:13:50 <simon> what's the weapon of choice for lightweight XML parsing? I tried looking at stackoverflow, but I can't decide if HXT is too complex and if so, if there are any maintained alternatives.
20:13:54 <Adeon> I can't recommend that
20:14:10 <monochrom> HXT is not lightweight.
20:14:21 <monochrom> tagsoup :)
20:14:34 <mniip> being unable to pattern-match bytestrings is a laaaaaaaarge drawback
20:14:44 <Adeon> but you can pattern-match bytestrings
20:15:00 <osa1> how do I unsafeCast Ptr types? e.g. Ptr a -> Ptr b ?
20:15:06 <simon> monochrom, is that 'cabal install tagsoup'?
20:15:10 <mniip> Adeon, elaborate?
20:15:12 <monochrom> yes
20:15:35 <monochrom> there is also a package called simply "xml"
20:15:51 <Adeon> are you trying to match the head of a bytestring? try ViewPatterns extension and write a utility function
20:16:05 <monochrom> its homepage is "code.galois.com" so it can't be all bad
20:16:06 <lpaste> Lokathor pasted â€œirc-snippitâ€ at http://lpaste.net/119577
20:16:29 <Lokathor> mniip, have a look at my message reading function there, that might be similar to what you're looking for
20:16:29 <pavonia> osa1: castPtr
20:16:43 <mniip> that's
20:16:45 <mniip> guards
20:16:51 <mniip> pretty close yeah
20:17:01 <Lokathor> that guard is just to check for which lines are commands or not
20:17:33 <Lokathor> the bulk of it is to convert to String, and then send it off to another function to decide what to do
20:18:23 <mniip> my lib isn't intended to be used with UTF8 only
20:19:01 <Adeon> to be fair, converting to String, if you do it correctly, will work
20:19:15 <Adeon> however, if I see a String in a type signature, Im going to assume it's a list of unicode code points
20:19:30 <Lokathor> "Warning: Use infix", don't tell me what to do lpaste
20:19:30 <mniip> makes sense
20:20:32 <Lokathor> mniip, ultimately you have to pick /some sort of encoding/ to convert the bytes into something else... but picking which encoding is correct can be tricky
20:20:57 <mniip> I'd prefer to let the user of the lib do that
20:22:00 <mniip> hmm, I should separate the string routines from the IO stuff
20:22:18 <monochrom> yes :)
20:22:40 <Lokathor> sounds solid
20:24:43 <mniip> is there a better way to strip trailing characters other than  fst . BS.spanEnd (== '\r')
20:27:16 <HeladoDeBrownie> mniip, if you want to take just one off the end, unsnoc could do
20:27:41 <monochrom> why is it not simply BS.takeWhile?
20:27:42 <sdegutis> Does anyone have the official Haskell tutorial with better styled HTML?
20:27:50 <unknownloner> what'd be a good way to interleave two arrays?
20:28:03 <sdegutis> I'm currently working on generating better HTML so it can be styled easier, but it's not going smoothly, and I'd hate to duplicate someone else's effort.
20:28:04 <HeladoDeBrownie> sdegutis, tutorial? you mean the report?
20:28:10 <sdegutis> I mean https://www.haskell.org/tutorial/
20:28:18 <HeladoDeBrownie> oh, i forgot that existed
20:28:22 <sdegutis> It's good so far.
20:28:26 <sdegutis> It's just ugly.
20:28:29 <mniip> HeladoDeBrownie, be lenient in what you accept
20:28:33 <mniip> there might be no \r there
20:28:33 <sdegutis> I tried adding some CSS, but even the HTML is ugly and hard to work with.
20:28:52 <sdegutis> So I'm trying to re-generate it but I don't know what -lfl is for in the Makefile -- I don't know where to get the "fl" lib.
20:29:01 <HeladoDeBrownie> mniip: sure; i left out the part where you check for equality against the desired character and use the original if it's not it
20:29:02 <monochrom> no, I haven't heard of anyone improving it
20:29:21 <mniip> aha
20:29:24 <mniip> makes sense
20:29:46 <HeladoDeBrownie> in fact i've written code that does exactly this before, and that's what i did. not saying it's the best way, but it worked fine
20:30:14 <sdegutis> Also, each chapter has both a .tex and a .verb file which are almost identical but not, and I don't know which one is the canonical source.
20:30:33 <HeladoDeBrownie> although i jumped over the problem in my latest project, where all control characters in input are undesirable, so i stripped them all :P
20:30:55 <glguy> Sounds like anarchy
20:31:13 <sdegutis> Hmm, the HTML generator uses runhugs -- what's that?
20:31:34 <benzrf> sdegutis: old, old, old, old, old, shit
20:31:44 <monochrom> runhugs is an interpreter. you could replace it by runghc
20:32:15 <HeladoDeBrownie> runhugs doesn't make sense to me, anyway; if there are hugs available, i wouldn't want to run from them.
20:32:16 <sdegutis> lol import Monad(foldM)
20:32:31 <sdegutis> HeladoDeBrownie: I get your joke
20:32:59 <HeladoDeBrownie> you know, i kinda wonder why they added the Control prefix anyway. did they have a specific meaning for it in mind, or was it as meaningless then as it is now?
20:33:47 <benzrf> HeladoDeBrownie: like flow control i think
20:34:07 <benzrf> HeladoDeBrownie: general structure stuff
20:34:35 <HeladoDeBrownie> it sounds like Control and Data should be non-overlapping though.
20:34:37 <HeladoDeBrownie> err
20:34:40 <HeladoDeBrownie> overlapping
20:34:54 <HeladoDeBrownie> should not in the obligatory sense :P
20:35:01 <HeladoDeBrownie> i'm good at english tonight
20:39:52 <sdegutis> http://sdegutis.github.io/goodies.html
20:41:41 <HeladoDeBrownie> up till now i've been reading your nick as sdegutils
20:42:45 <HeladoDeBrownie> nice formatting
20:45:10 <lpaste> mniip pasted â€œIRC.Syntaxâ€ at http://lpaste.net/119583
20:45:20 <mniip> seems good enough? :P
20:47:31 <pavonia> mniip: Why not using attoparsec?
20:47:41 <mniip> why bother
20:48:02 <mniip> the protocol is a matter of locating the ':' symbols and otherwise splitting by ' '
20:48:18 <pavonia> It would make your code look cleaner
20:48:38 <mniip> I really doubt it would
20:51:10 <sdegutis> HeladoDeBrownie: I have several times done /nick sed-utils just to avoid that
20:51:46 <sdegutis> mniip: your code is so deeply nested, that seems out of place in Haskell
20:51:48 <mniip> lol sed-utils
20:52:06 <mniip> 3 levels omg so deep
20:52:08 <sdegutis> mniip: maybe a big part of that is your horrific indentation
20:52:25 <sdegutis> mniip: I counted 5 levels of indentation at its deepest
20:52:34 <mniip> horrific indentation? you mean orthogonal indentation that makes sense?
20:53:36 <sdegutis> maybe
20:53:46 <sdegutis> just looked at first glance like 8-space indentatino
20:54:00 <mniip> ^I or die
20:54:02 <sdegutis> oh I see, tabs
20:54:05 <mniip> wait no that's perl
20:54:07 <sdegutis> ~guards
21:01:14 <glguy> GHC will warn about tabs in the next release
21:03:59 <mniip> what
21:05:53 <benzrf> i warned you about tabs man
21:05:54 <benzrf> i told you dog
21:06:31 <bergmark> yay!
21:07:15 <mniip> what is wrong with tabs
21:07:47 <glguy> Many editors don't know to show them at 8 space tabstops leading to confusing errors
21:08:16 <mniip> huh?
21:08:27 <mniip> oh you mean tab-space mixing?
21:08:43 <glguy> No, because indentation matters in Haskell you need a standardized interpretation of tabs
21:08:53 <glguy> that interpretation is 8 space tabstops
21:09:26 <mniip> uh
21:09:35 <mniip> what would be the case where the tab width is important
21:09:39 <mniip> other than mixing tabs with spaces
21:12:04 <lpaste> glguy pasted â€œindentationâ€ at http://lpaste.net/119584
21:12:18 <glguy> Maybe someone wrote that? Anyway, it can happen lots of ways
21:12:41 <mniip> ugh
21:12:56 <mniip> well I always write my code with tabs, in a way that doesn't depend on tabwidth
21:13:13 <mniip> in like, every langauge
21:13:15 <glguy> OK
21:13:28 <benzrf> mniip: ngh
21:14:36 <mniip> renounce your rabbit god and accept our duck god
21:14:46 <glguy> You'll be able to turn off the warning with a flag if you don't agree
21:16:07 <miles`> does anybody on here know about xmonad?
21:17:03 <grq> what about it?
21:17:50 <Lokathor> are cabal and cabal-install always global packages?
21:18:19 <Lokathor> or is adding the --global flag necessary if you want the whole system to use the newest cabal?
21:19:38 <Lokathor> sdegutis: that's a much better formatted version of Gentle Intro to Haskell, well done
21:21:54 * hackagebot turtle 1.0.0 - Shell programming, Haskell-style  http://hackage.haskell.org/package/turtle-1.0.0 (GabrielGonzalez)
21:29:59 <ctag> o/ shapr
21:32:43 <shlevy> Hey all. I'm in the design phases of a library that will do IO heavy stuff and be C at the interface. How should I design it so that it can integrate well with GHC's even manager?
21:33:26 <shlevy> My naive thought is "well for IO bound calls just return a nonblocking FD that triggers poll/select when the work is done"
21:33:44 <shlevy> But I have no idea how it's actually implemented and whether it's possible to integrate something like that in
21:33:52 <shlevy> johnw: ^ :)
21:35:46 <benzrf> night
21:39:13 <Geekingfrog> Lokathor, link? I joined the chan too late
21:49:56 <Lokathor> http://sdegutis.github.io/index.html
21:50:05 <Lokathor> geekingfrog: ^
21:50:29 <Geekingfrog> thanks
21:51:35 <mniip> btw
21:51:44 <mniip> til about guards in case
21:52:03 <mniip> are there any other sneaky places guards can be used in?
21:53:06 <Axman6> I think there's an extension to let you use them in if statements, somethingh like: if foo = bar | baz = quux | otherwise = wibble
21:54:13 <Axman6> s/=/-> apparently
21:55:00 <Axman6> https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/syntax-extns.html#multi-way-if
21:58:58 <erikd> cmccann: the response i got was "Pretty recently, looks like just a bad IP." FFS!
22:00:28 <Javran> I want some help with this code: http://lpaste.net/962518925701021696 my program has spent 84.0% run time doing GC, but I have no clue how to deal with it. profile result included in the source.
22:02:58 <glguy> Javran: First step is to not put thunks in your array:
22:02:59 <glguy>  24         let inc i = do x <- readArray mary i
22:02:59 <glguy>  25                        writeArray mary i $! x+1
22:03:52 <glguy> Javran: second step is to stop worry about putting boxed values in the array altogether and use an unboxed array (since you're storing Int)
22:04:48 <glguy> Javran: see http://lpaste.net/119585
22:05:12 <glguy> That codes runs in about 10% of the runtime
22:05:13 <Javran> glguy: so it is actually not "searchSpace" that has caused the problem? I saw from profile it takes most of the time.
22:05:50 <tommd> Third step is to use vectors... (ok, I'll hide now).
22:06:57 * hackagebot jammittools 0.3.2 - Export sheet music and audio from Windows/Mac app Jammit  http://hackage.haskell.org/package/jammittools-0.3.2 (mtolly)
22:07:10 <Javran> tommd: hmm, I don't like zero-based index..
22:07:51 <Melba24>  There is no such thing as Free Porn http://bitly.com/1nx3K4c
22:08:28 <lpaste> glguy annotated â€œNo titleâ€ with â€œdon't bother using STâ€ at http://lpaste.net/962518925701021696#a119586
22:08:36 <glguy> Javran: You don't even need to dive into ST
22:09:02 <glguy> accumArray will manage that for you
22:09:10 <mniip> fourth step is to rewrite the thing in assembly
22:09:20 <MP2E> lol
22:09:54 <mniip> fifth step is to abuse SIMD and AVX2
22:12:43 <Javran> glguy: but I heard previously when same index appears multiple times the result is impl-dependent?
22:13:00 <glguy> The point of accumArray is to handle repeat indexes
22:13:34 <glguy> "Unlike array, the same index is allowed to occur multiple times in the list of associations; an accumulating function is used to combine the values of elements with the same index."
22:13:51 <Javran> ah what I said was actually "array"
22:14:54 <Javran> seems like we can get rid of ST totally by using a Writer to generate pairs
22:16:10 <glguy> We were able to get rid of it because no decisions were being made considering the intermediate state of the array
22:17:42 <Lokathor> i think i did a thing wrong. I used cabal 1.20 to build and install cabal 1.22, but it put the new install in /usr/local/bin and not /usr/bin, so now i have two cabals
22:20:11 <Javran> reminds me of this xD https://ro-che.info/ccc/25
22:21:14 <Javran> previously I know if the old value isn't going to change, then "array" is enough, good to know there's an "accumArray"
22:23:39 <Lokathor> Javran, cool comic
23:10:27 <SrPx> how do I tell ghc to clean gyn_hi and dyn_o fiels
23:11:27 <glguy> Usually you'd use cabal clean
23:12:15 <adas> glguy: can cabal clean be used inside a sandbox
23:13:15 <glguy> Should work
23:13:19 <glguy> it won't delete the sandbox though
23:13:35 <adas> glguy: for that cabal sandbox delete is the command i think
23:13:44 <glguy> right
23:14:29 <SrPx> I see, thanks :( I don't have time to set cabal right now... I'd have to list every single dependency, I don't even know what they are, version numbers taking care not to do it wrong, etc etc
23:14:47 <glguy> "cabal init" tries to guess your dependencies
23:14:51 <adas> SrPx: cabal init should take care of version numbers
23:14:55 <adas> yup
23:15:40 <SrPx> glguy: I've done that but it didn't even ask me the file?
23:15:55 <glguy> I don't know what that means
23:16:21 <adas> SrPx: what file do you expect to be asked for?
23:16:51 <SrPx> ... how can cabal init know what files to look the dependencies for? I have 3 files, /tests.hs, /Data/lib1.hs, /Data.lib2.hs ...
23:17:56 <glguy> It searches for Haskell source files in the current directory structure
23:18:05 <adas> SrPx: you can tell cabal what files to include as part of your package in cabal.init. based on the imports in those files, cabal will guess the dependencies
23:18:34 <adas> yup .. you don't even need to specify the project files explicitly
23:19:24 <SrPx> in that case I think it couldn't guess my dependenciees since it only lists base
23:20:04 <adas> SrPx: what else have you imported?
23:20:45 <SrPx> those files have a lot of imports...
23:20:49 <SrPx> hm I'll make a repo
23:23:38 <adas> SrPx: if cabal is not able to auto-find them, then you could try explicitly mentioning the project files in cabal.init
23:28:30 <Quin> Hi
23:28:55 <jle`> hi Quin
23:28:56 <SrPx> https://github.com/viclib/rays this is how it is sorted, calling cabal init on it doesn't work :(
23:30:10 <jtanguy> maybe it's because cabal expects the file names to be capitalized ?
23:30:33 <jtanguy> e.g. Data/Geometry.hs
23:31:07 <SrPx> hi
23:31:17 <SrPx> Hmm let me see
23:32:14 <jtanguy> yup. it seems to be
23:32:19 <SrPx> "fatal: destination exists, source=benchmark.hs, destination=Benchmark.hs" well seems like git mv doesn't know that lol
23:32:29 <SrPx> guess if it recognizes if I just mv the files normally
23:32:33 <SrPx> wonder*
23:32:33 <Quin> Looks bad
23:33:03 <jtanguy> SrPx: which system are you on ?
23:33:10 <SrPx> osx
23:33:10 <glguy> SrPx: You might need to move them to new names, commit, and then move them back to the correct names
23:33:20 <glguy> since OS X is case insensitive by default
23:33:33 <glguy> and git isn't impressed with that feature
23:34:20 <SrPx> weird
23:37:34 <SrPx> seems to work now, thanks / neat
23:39:38 <jle`> Tekmo: no :|
23:40:41 <SrPx> Data/Space.hs:73:21: parse error (possibly incorrect indentation or mismatched brackets) -- that shows when trying "cabal build", but the file compiles normally with GHC... strange ?
23:41:20 <jle`> Tekmo: okay maybe
23:42:16 <SrPx> and it doesn't seem to be anything wrong with line 73 of space.hs
23:43:02 <SrPx> pushed
23:59:08 <glguy> Looks like you have your do block lined up with your let block
