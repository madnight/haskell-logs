00:02:29 <RedNifre> Interesting... the depth of the type signature would depend on the second parameter...
00:06:01 <chrisnc> composing the same function with itself multiple times forces the input and output types to be the same
00:07:10 <matematikaadit> :t \f n -> foldr (.) id (replicate n f)
00:07:10 <lambdabot> (b -> b) -> Int -> b -> b
00:08:18 <chrisnc> foldr on lists of functions is fun :)
00:09:31 * hackagebot copilot-sbv 2.1.2 - A compiler for CoPilot targeting SBV.  http://hackage.haskell.org/package/copilot-sbv-2.1.2 (LeePike)
00:09:31 * hackagebot copilot 2.1.2 - A stream DSL for writing embedded C programs.  http://hackage.haskell.org/package/copilot-2.1.2 (LeePike)
00:12:40 <Hijiri> the dual of pilot?
00:16:42 <Matto80> Hi folks just a super-newb lurking a bit here
00:18:42 <Matto80> quit
00:18:48 <Matto80> hehe oops
00:19:12 <haasn> That's not how you lurk.
00:19:34 <RedNifre> Maybe he has a secret second account that is still here?
00:33:55 <c_sahn> ./join #c
00:34:01 <c_sahn> well shit.
00:34:07 <c_sahn> hey guys
00:34:22 <c_sahn> anyone know the command to join a channel >.>
00:36:27 <matematikaadit> c_sahn: type "/JOIN #CHANNEL" without quotes
00:36:35 <matematikaadit> :t join
00:36:36 <lambdabot> Monad m => m (m a) -> m a
00:37:51 <haasn> :t join #c
00:37:52 <lambdabot>     Ambiguous occurrence ‘#’
00:37:52 <lambdabot>     It could refer to either ‘L.#’,
00:37:52 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:155:3
00:37:58 <haasn> :t join ##c
00:37:59 <lambdabot> IO ()
00:38:36 <matematikaadit> @botsnack
00:38:36 <lambdabot> :)
00:38:49 <matematikaadit> you're doing an IO when you join a channel
00:40:49 <c_sahn> thanks mate
00:41:13 <c_sahn> any of you start from a language like c before learning haskell?
00:47:17 <moop> does c# count as c?
00:47:32 <jedws> c_sahn most people I'd say, given the relatively wide reach of c-like languages…
00:48:13 <jedws> although, I started with Basic on a vic-20…
00:48:44 <texasmynsted> wow, I had a vic-20.
00:48:48 <texasmynsted> :-)
00:48:53 <moop> jews always start with basic
00:49:02 * moop lamejokeday
00:49:19 <c_sahn> just curious, what was the best resource for those of you who did?
00:49:23 <hmax> what's the best tutorial for monad transformers out in the wild?
00:49:33 <moop> @learning
00:49:34 <lambdabot> Unknown command, try @list
00:49:36 <moop> @learn
00:49:36 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
00:49:39 <moop> there we go
00:50:10 <c_sahn> jedws fair point, seeing as how most people start programming with a language at least based on c.
00:50:13 <hmax> I honestly doubt there will be any ranking in tutorials :)
00:50:21 <c_sahn> got my stupid question of the day out of the way.
00:50:32 <c_sahn> more coming soon*
00:50:59 <c_sahn> just wondering which resource would be a good place to start.
00:51:04 <c_sahn> thanks lambdabot
00:51:13 <moop> lambdabot best friend to have
00:51:20 <c_sahn> walking resource
00:51:56 <jedws> c_sahn :-) LYAHFGG is awesome for beginner programmers
01:13:25 <Hijiri> c_sahn: https://github.com/bitemyapp/learnhaskell
02:14:31 * hackagebot syb 0.4.4 - Scrap Your Boilerplate  http://hackage.haskell.org/package/syb-0.4.4 (JosePedroMagalhaes)
02:45:05 <Aruro> > sin pi
02:45:07 <lambdabot>  1.2246467991473532e-16
02:46:37 <aristid> > sin pi :: CReal
02:46:38 <lambdabot>  0.0
02:47:31 <Aruro> > cos pi
02:47:32 <lambdabot>  -1.0
02:50:14 <Aruro> no need in CReal in this case
02:50:43 <aristid> > cos pi == (-1.0)
02:50:45 <lambdabot>  True
02:50:57 <Aruro> yep :)
02:50:58 <aristid> interesting.
02:51:19 <Aruro> seems to be a happy bug :)
02:52:48 <wz1000> Aruro: I don't think it qualifies as a bug.
02:57:27 <Aruro> why compiler does not complain about expr like - [a,b]<-getArgs ? which crashes on 1 argument case for example
02:57:49 <Aruro> its list vs IO list
03:04:23 <zwer> Aruro add -fwarn-incomplete-patterns flag to ghci or ghc
03:04:37 <Aruro> wait
03:05:40 <rbocquet> ghc seems to have a problem compiling a parser generated by happy : it takes a long time to compile and uses up to ~ 5 GBs of memory. Running ghc with the option -v2 gives : Result size of Desugar (after optimization) = {terms: 70,462, types: 66,009,769, coercions: 23,260}.
03:07:15 <Aruro> no, sorry, -fwarn-incomplete-patterns does not catch it
03:07:29 <Aruro> neither does -Wall
03:08:45 <lpaste> Aruro pasted “GHC does not complain ” at http://lpaste.net/117675
03:13:00 <zwer> hmm you are correct, it is only caught if you do args <- getArgs; case args of [a,b] -> putStrLn (a++b)
03:13:18 <srhb_> Aruro: I'm guessing it's because it's in a do block, in which case it is relegated to fail
03:15:20 <Aruro> interesting, and it is not easy to overcome that?
03:16:09 <srhb_> Aruro: Depends what you mean by overcome. Some monads have very sensible fails
03:16:43 <zwer> I would guess he means not getting a runtime exception without a warning
03:17:08 <zwer> runtime is a redundant there
03:17:17 <Aruro> yes
03:17:22 <Aruro> i mean that
03:17:41 <srhb_> That's not generally possible (I think) since again it depends on the specific monad instance.
03:18:16 <srhb_> > do { [x] <- []; return x } -- should this yield an error?
03:18:18 <lambdabot>  []
03:18:28 <Cale> Of course, you could just write it as a case expression, and then you'll get a compile time error
03:18:30 <srhb_> As in, a compile time warning
03:18:35 <Cale> (er, warning rather)
03:20:41 <Aruro> srhb_ your case is similar to  [x,y,z]<-IO [a] ?
03:20:55 <srhb_> No, in that case you're using fail from IO
03:21:41 <Aruro> :t []
03:21:41 <lambdabot> [t]
03:22:27 <Aruro> perhaps more practical example?
03:22:54 <Aruro> which resembles our case of [a,a']<-IO [a]
03:22:55 <srhb_> Aruro: The important distinction is that the fail of IO uses error, while the fail of [] does not
03:24:02 <srhb_> (Well, it doesn't really, but something similar which generates an exception)
03:24:22 <Aruro> im having trouble to understand why it is not possible to warn about it :)
03:24:39 <Aruro> clearly list<-IO list
03:24:46 <srhb_> Oh, there's no technical reason not to be able to
03:24:47 <zwer> it is possible, ghc would have to (and should) make a special case when pattern matching  in IO monad
03:24:49 <Aruro> will be wrong since IO list length is not known
03:25:02 <srhb_> The point is that this is relevant for the IO monad, but not the list monad
03:25:11 <Aruro> ok
03:25:25 <Aruro> so perhaps in future it will be the warning case?
03:25:49 <srhb_> More likely fail will be moved somewhere else and the warning will be there iff there's no sensible fail instance.
03:25:53 <srhb_> Well, I'm guessing really.
03:26:17 <srhb_> But we could imagine [] being an instance of Fail and IO not being an instance of Fail, and IO generating a warning while [] does not.
03:28:04 <zwer> interesting
03:28:15 <zwer> no warning in here: do { [] >>= \[x] -> return x }
03:28:47 <zwer> but there is a warning in here: do getArgs >>= \[a] -> putStrLn a
03:30:10 <Aruro> \[x] is pattern match in anonymous function?
03:30:12 <zwer> no sorry, that was an exception
03:30:19 * zwer goes to bed
03:30:26 <zwer> Aruro yes
03:34:16 <srhb_> Oh, this is funny.
03:34:35 <srhb_> ghc test.hs where main = return () -- /usr/bin/ld: final link failed: Illegal seek
03:35:37 <srhb_> Hmm, no, that problem must be elsewhere..
03:40:19 <srhb_> baffling. It only occurs to that one file. Hardware error perhaps?
03:44:34 * hackagebot sai-shape-syb 0.3.4 - Obtain homogeneous values from arbitrary values, transforming or culling data  http://hackage.haskell.org/package/sai-shape-syb-0.3.4 (AndrewSeniuk)
04:09:03 <RedNifre> Oh well. Not sure if this information is useful to anybody, but the "cabal runs out of memory on a 1GB machine" problem was actually caused by OpenBSD's security policy: the default is that each user only gets 512M RAM/swap... once I changed that in the login.conf, cabal worked again.
04:11:37 <tasker> Is it possible to create a single executable that runs a threepenny-gui gui?
04:23:03 <loki_> Hi, can someone tell me the reason why haskell executables are so gigantic? 1,1MB for a terminal "Hello World" (GHC w.o. optimisations, LINUX) I have seen MirageOS(Written in Ocaml) using just a few dozen MB for the whole OS
04:23:40 <Cale> loki_: Because it's statically linked to everything.
04:23:51 <Cale> loki_: Also, the GHC runtime is almost an OS. :P
04:25:03 <RedNifre> tasker that's... interesting. I wonder if you could use that on iOS or Android... thanks!
04:25:04 <Cale> (this idea has been put to use, see House and HaLVM)
04:25:36 <mauke> can you 'strip' it?
04:29:36 * hackagebot eventstore 0.4.0.0 - EventStore Haskell TCP Client  http://hackage.haskell.org/package/eventstore-0.4.0.0 (YorickLaupa)
04:44:54 <iElectric> I'm trying to use Data.Configurator but it's giving me "ambiguous" errors: http://paste.ofcode.org/36ZNmcPtdDQH5mnipzFYmJf
04:55:01 <iElectric> ChongLi: any ideas? :/
04:57:17 <iElectric> aha got it, I need to convert it
05:23:47 <d34df00d> Hi!
05:23:56 <d34df00d> I have a somewhat simple function like this: https://bpaste.net/show/bb8377166c31
05:24:21 <d34df00d> Eventually it fails with the first (error) case, producing output like `Invalid indices in toBacktrack: ("s1",(1,1),1,"s2",(3,4),6)`
05:25:05 <d34df00d> If I replace True with False on the first line (effectively "commenting out" the first guard), it fails with another error during evaluation of c1 (according to the stacktrace of -xc option) `Data.ByteString.index: index too large: 11, length = 11`.
05:25:38 <d34df00d> The question is: why doesn't it fail with the n1r == n2r == 1, as in the error case?
05:25:57 <d34df00d> As far as I can judge, the c1 should also be evaluated in this case, triggering the error in ByteString.
05:36:04 <Cale> d34df00d: c1 doesn't seem to be used in the first guard or its right hand side
05:36:13 <Cale> So why would it be evaluated?
05:37:08 <d34df00d> Cale: I mean, it would be evaluated in the case I comment out the first guard, since n1r == n2r (both equal to 1), and the second guard would be used.
05:37:38 <d34df00d> And in this case n1r == n2r == BS.length s1 == 1 (as the error message used to tell), so evaluating c1 with these parameters should trigger an error in ByteString.
05:37:52 <d34df00d> But, well, seems like it is triggered later on with another parameters, and I don't get why.
05:38:25 <Cale> Oh, well, the error will be triggered when you evaluate the c1 field in the result in that case.
05:39:06 <d34df00d> Cale: like,e for example, when outputting the string?
05:39:14 <d34df00d> Or something.
05:39:20 <Cale> yeah, if you show the result here
05:39:30 <d34df00d> Yes, that makes sense.
05:39:31 <d34df00d> Thanks!
05:39:39 * hackagebot zmqat 0.2.0.0 - A socat-like tool for zeromq library  http://hackage.haskell.org/package/zmqat-0.2.0.0 (koral)
05:41:01 <bryanedds> Tail-recursive monadic bind in question (F#) - http://stackoverflow.com/questions/27755439/how-can-i-make-this-monadic-bind-tail-recursive
05:41:51 <bryanedds> (sorry, once again I need the Haskell community's help due to F# community's small knowledge base)
05:43:00 <Cale> Questions like this are a bit mindbending for me too, because F# evaluates everything backwards compared to Haskell :D
05:43:40 <bryanedds> ya, I was wondering how much the evaluation strategy would affect tail-rec'g
05:44:07 <Cale> Tail recursion optimisation is a bit meaningless in Haskell, since the stack isn't even a call stack
05:44:17 <bryanedds> btw, hello Cale :)
05:44:20 <Cale> (it's a stack of pattern matches)
05:44:41 <bryanedds> you helped me a lot with the original monad :)
05:44:48 <Cale> yeah, I seem to remember this a bit
05:45:04 <bryanedds> it works really REALLY good
05:45:16 <bryanedds> I wrote several dozens nice combinaors for it
05:45:34 <bryanedds> this tail-recursion thing is that only issue that remains
05:46:55 <Cale> hmm
05:47:42 <bryanedds> btw, I stripped the step function out to make the code a little clearer in the SO question
05:47:52 <bryanedds> er, inlined it, anyway
05:48:17 <bryanedds> I still have it and use it in the actual code
05:50:06 <Cale> Do you have a good example of something written using this bind that has the problem you're talking about? Is it something which is left-recursive?
05:50:28 <bryanedds> Sure
05:52:21 <lpaste> bryanedds pasted “Desync usage code with looping” at http://lpaste.net/117680
05:53:31 <bryanedds> hmm, I guess I can post the other primitive combinators as well
05:54:08 <lpaste> bryanedds revised “Desync usage code with looping”: “No title” at http://lpaste.net/117680
05:54:20 <bryanedds> usage code at the bottom\
05:56:53 <Cale> hmm, I'm not sure I understand how this desugars
05:58:53 <bryanedds> http://stackoverflow.com/questions/19586825/computation-expressions-for-a-haskell-programmer
05:59:26 <Cale> okay, that helps :)
06:00:09 <Cale> But this desync computation which is being defined isn't even recursive, is it?
06:00:31 <bryanedds> I'll add a couple more use cases
06:00:38 <Cale> oh, loop is though
06:01:15 <Cale> But not in a way which I'd expect to be problematic...
06:01:18 <lpaste> bryanedds revised “Desync usage code with looping”: “No title” at http://lpaste.net/117680
06:03:26 <Cale> let i = next i -- heh, this looked suspicious at first, but then I remembered that let isn't recursive by default
06:03:53 <bryanedds> heh
06:06:31 <Cale> It's a bit hard to understand why it would stack overflow when I'm pretty sure even F# doesn't evaluate under lambdas that haven't been applied
06:06:54 <Cale> So bind makes Desync values that are pretty much lazy anyway
06:07:13 <Cale> (since there's a lambda which is in the way of doing any evaluation)
06:09:27 <bryanedds> so, maybe what's misleading is that the inner bind call is not where the recursion in question happens
06:10:16 <bryanedds> it's the call to the inner match here -> match (match m with Desync f -> f s) with
06:10:17 <bryanedds> f s
06:10:27 <bryanedds> which evaluates to a call to bind
06:13:08 <lisbeth> I'm having trouble understanding the difference between foldl and foldr
06:14:14 <saep> @src foldl
06:14:14 <lambdabot> foldl f z []     = z
06:14:14 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:14:19 <saep> @src foldr
06:14:19 <lambdabot> foldr f z []     = z
06:14:19 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:14:22 <bryanedds> match (match m with Desync f -> f s)                                 ^---- unbounded recursion happening here
06:14:35 <bryanedds> match (match m with Desync f -> f s)
06:14:36 <bryanedds>                                  ^---- unbounded recursion happening here
06:16:13 <saep> lisbeth: They can generally calculate the same thing (if you flip the arguments of one), but the evaluation strategies are different.
06:16:40 <mauke> > foldl f z [a,b,c]
06:16:41 <lambdabot>  f (f (f z a) b) c
06:16:43 <mauke> > foldr f z [a,b,c]
06:16:45 <lambdabot>  f a (f b (f c z))
06:16:50 <Cale> bryanedds: yeah, hmm
06:17:10 <lisbeth> heh that makes my brain numb
06:18:12 <lisbeth> I think I am beginning to understand though
06:18:18 <Cale> bryanedds: hmm, yeah
06:20:47 <Cale> lisbeth: One important difference is that as you can see from the source, foldl just greedily calls itself with new arguments until it reaches the end of the list (and so will never work on an infinite list), while foldr will immediately pass control to f in the recursive case, and so if f can produce all or part of the result without needing to look at its second argument, the foldr might just stop there.
06:21:07 <Cale> This allows foldr to operate on infinite lists:
06:21:26 <Cale> > foldr (\x xs -> x : 10*x : xs) [] [1..]
06:21:27 <lambdabot>  [1,10,2,20,3,30,4,40,5,50,6,60,7,70,8,80,9,90,10,100,11,110,12,120,13,130,14...
06:21:37 <lpaste> bryanedds revised “Desync usage code with looping”: “Even more detail” at http://lpaste.net/117680
06:22:19 <lisbeth> what is the advantage to foldl th en?
06:23:41 <Cale> Well, the stricter version of foldl, which evaluates the 'z' argument on each step, can avoid building up large unevaluated expressions in memory
06:23:42 <tasker> What does the pipe symbol mean in this code: "[nEl "v" M.empty [NodeContent $ value cell] | isJust $ xlsxCellValue cell]" ?
06:24:01 <mauke> list comprehension
06:24:15 <tasker> ..doh
06:24:17 <Cale> tasker: That's a list comprehension, it's a somewhat trivial one since there's no generator with '<-'
06:24:17 <tasker> good point :P
06:24:37 <Cale> So it just makes the list empty if the condition fails, otherwise it's the singleton with just that element
06:24:50 <tasker> Cale, mauke: Thanks.
06:24:59 <Cale> lisbeth: So, for example...
06:25:07 <Cale> foldr (+) 0 [1,2,3]
06:25:20 <Cale> -> 1 + foldr (+) 0 [2,3]
06:25:56 <Cale> here, at least with integers, the outermost (+) can't do anything without knowing the value of its second argument, so it'll pattern match it, which will force the foldr to continue:
06:26:06 <Cale> -> 1 + (2 + foldr (+) 0 [3])
06:26:10 <Cale> and then again...
06:26:19 <Cale> -> 1 + (2 + (3 + foldr (+) 0 []))
06:26:27 <Cale> -> 1 + (2 + (3 + 0))
06:26:35 <Cale> and then finally addition can start to happen
06:27:11 <Cale> If we used foldl, we might have a similar problem at first:
06:27:17 <Cale> foldl (+) 0 [1,2,3]
06:27:25 <Cale> -> foldl (+) (0 + 1) [2,3]
06:27:31 <Cale> -> foldl (+) ((0 + 1) + 2) [3]
06:27:39 <Cale> -> foldl (+) (((0 + 1) + 2) + 3) []
06:27:45 <Cale> -> ((0 + 1) + 2) + 3
06:28:28 <Cale> If the list were a few million elements long in these cases, we'd be using a lot of memory holding these expressions with all the additions in them, rather than just storing the resulting integer
06:29:06 <Cale> But notice that in foldl's case, we have something which is a complete expression that ought to be an integer, where with foldr, the brackets are sort of going the wrong way for any simplification to occur
06:29:51 <Cale> So, there's a variant of foldl (or else the compiler is often smart enough to do this on its own with optimisations turned on) which evaluates the expression on each step:
06:29:54 <Cale> foldl (+) 0 [1,2,3]
06:29:56 <Cale> oops
06:29:58 <Cale> foldl' (+) 0 [1,2,3]
06:30:13 <Cale> -> foldl' (+) (0 + 1) [2,3]
06:30:20 <Cale> -> foldl' (+) 1 [2,3]
06:30:27 <Cale> -> foldl' (+) (1 + 2) [3]
06:30:30 <Cale> -> foldl' (+) 3 [3]
06:30:35 <Cale> -> foldl' (+) (3 + 3) []
06:30:53 <Cale> -> foldl' (+) 6 []
06:30:54 <Cale> -> 6
06:31:22 <Cale> So this keeps the expressions in memory small, saving space (and time spent allocating space).
06:31:53 <bryanedds> Cale: Hmm... can we even confirm that a transformation to tail-recursion is even possible?
06:33:01 <Cale> bryanedds: Well, hmm. Maybe it's time to do the continuation passing style transformation we mentioned before... ugh
06:33:46 <bryanedds> ah hmm
06:34:34 <lisbeth> I think I understand, now
06:35:30 <Cale> lisbeth: Yeah, my reduction sequence for foldl' there is a little sketchy, I basically hid the 'seq' things which help sequence the evaluation and just showed what was being evaluated, but that's the gist of it.
06:36:09 <Cale> bryanedds: Give me a sec, I'm going to make a coffee, we can have a look at doing a continuation based version of this in Haskell, and then translate to F# and see if it looks hopefuly
06:36:13 <Cale> hopeful*
06:36:20 <Cale> I think maybe it will...
06:36:21 <bryanedds> ok :)
06:36:28 <bryanedds> I'll go grab a coffee too
06:36:40 <bryanedds> BTW, would it be okay to credit you on my engine?
06:37:02 <wz1000> I think Monad m => m () forms a monoid for all m, though I cant seem to prove it
06:38:30 <wz1000> mappend a b = join $ liftM (const b/a) a/b
06:38:50 <wz1000> Two monoids actually
06:52:28 <kipri> :/
06:52:42 <Cale> hello
06:52:56 <Cale> bryanedds: Yeah, it's fine if you'd like to credit me :)
06:53:03 <bryanedds> awesome :)
06:53:33 <Cale> okay, so time to recall what this funny monad is :)
06:54:10 <bryanedds> I think I still have the haskell version somewhere...
06:54:12 <Cale> Before we ContT it and make it even more mindbending :)
06:55:26 <Cale> ah, right, it's a state monad which can pause
06:55:42 <Cale> requesting a value of type e to continue
06:55:47 <iElectric> where is defaultTimeLocale located in "new locale"
06:55:49 <bryanedds> ya
06:56:26 <bryanedds> it seems simple on the outside
06:57:29 <Cale> iElectric: *Is* there finally a new locale library?
06:58:06 <Cale> iElectric: For the longest time, everyone has just been using old-locale, which got renamed around the time we switched to a new time library, but the locale library didn't get rewritten.
06:59:01 <iElectric> ah I see, I was reading package description
06:59:10 <iElectric> from 1.0.0 version
07:02:25 <Cale> bryanedds: (sorry, just trying to decide what we ought to do to avoid having our brains explode and also still have something which makes sense in F#)
07:02:39 <bryanedds> heh, no problem
07:03:37 <bryanedds> out of curiousity, is this the type of problems that only a few programmers in the world can solve, or is this capability common among haskellers?
07:03:59 <bryanedds> or somewhere between?
07:04:09 <lisbeth> is there an equivelent of "continue" in c++ for an else statement in haskell
07:04:37 <deech> I have a Cabal question: I have some C->C++ bindings and Haskell->C bindings each sitting in their own ar archive. I'd like to combine them into one. Is Setup.hs the best way of doing that?
07:04:47 <bryanedds> lisbeth, not at all, I'm afraid
07:04:47 <lisbeth> here's the function I am working on: let fogger numfogs f x = if numfogs >= 0 then f (fogger (numfogs - 1) f x) else continue
07:05:01 <n4x> what'd "continue" do there?
07:05:14 <lisbeth> it would satisfy the need for an else clause
07:05:21 <Cale> bryanedds: Coming up with altogether new monads isn't something which is all that common, but it's something which an advanced Haskeller will probably stumble into doing every so often -- we have libraries in Haskell for gluing new monads together out of pieces.
07:05:32 <athan> lisbeth: is continue `id`?
07:05:34 <athan> erm
07:05:43 <lisbeth> not sure
07:05:44 <athan> what is continue's goal?
07:05:55 <athan> to not do anything on the `else` case?
07:06:09 <lisbeth> basically to stop fogger from continuing recursively
07:06:10 <bryanedds> lisbeth: consider this -
07:06:33 <lisbeth> lets say f = (+1)
07:06:37 <bryanedds> let v = if v = 0 then v + 1 else v
07:06:39 <deech> Also did something happen between Cabal 1.16 and Cabal 1.20 where it automatically tries to build a shared library?
07:07:01 <athan> you need the base case in else I'd think
07:07:02 <lisbeth> then fogger 3 (+1) 2 should result in 5
07:07:03 <bryanedds> the then clause gives a changed value, and the else clause gives the unchanged value, utually
07:07:10 <Cale> bryanedds: careful, that's recursive :D
07:07:22 <bryanedds> shit
07:07:24 <athan> like `if ... then ... else f x`
07:07:36 <bryanedds> out of my element here then
07:07:45 <Cale> (but hopefully everyone understands what you mean anyway)
07:08:04 <lisbeth> I am thinking maybe an if else statement is just not the type of logic I need to be using
07:08:16 <lisbeth> I think I need something like filter
07:08:20 <bryanedds> so in haskll, you would do -
07:08:20 <Cale> lisbeth: Every expression needs to have a value
07:08:24 <bryanedds> let v' = if v = 0 then v + 1 else v
07:09:02 <lisbeth> if I incorporate that into my function it will go on forever
07:09:05 <lisbeth> I want it to stop at zero
07:09:49 <Cale> lisbeth: Perhaps you want the 'else' to be x ?
07:09:51 <Rembane> takeWhile (/= 0) ...
07:09:53 <sivteck> (v == 0)
07:09:57 <lisbeth> numfogs 3 succ 10 becomes succ (succ (succ 10))
07:10:11 <lisbeth> takewhile could work
07:10:17 <Cale> numfogs 0 f x = x
07:10:32 <Cale> numfogs n f x = f (numfogs (n-1) f x)
07:11:06 <lisbeth> this is closer to what I want
07:11:08 <lisbeth> let fogger numfogs f x = takewhile (numfogs >= 0) ( f (fogger (numfogs - 1) f x)
07:11:39 <lisbeth> part of it is I want it to be 1 line and be able to work in ghci
07:11:56 <lisbeth> but I think I am pretty close, now
07:13:05 <lisbeth> here's what I have, now: let fogger n f x = takeWhile (n >= 0) ( f (fogger (n - 1) f x)
07:13:09 <n4x> > let fogget numfogs n f x = if n < 0 then x else fogget numfogs (n-1) f (f x) in fogget 5 (*2) 1
07:13:10 <lambdabot>  Could not deduce (GHC.Classes.Ord (a0 -> a0))
07:13:10 <lambdabot>    arising from a use of ‘fogget’
07:13:10 <lambdabot>  from the context (GHC.Num.Num (t -> t))
07:13:40 <lisbeth> on my end I am getting a parse error
07:14:02 <Cale> bryanedds: Does F# let you have type variables which stand for type constructors?
07:14:02 <n4x> > let fogget numfogs n f x = if n < 0 then x else f (fogget numfogs (n-1) f x) in fogget 5 (*2) 1
07:14:03 <lambdabot>  Could not deduce (GHC.Classes.Ord (a0 -> a0))
07:14:03 <lambdabot>    arising from a use of ‘fogget’
07:14:03 <lambdabot>  from the context (GHC.Num.Num (t -> t))
07:14:22 <n4x> writing stuff like that is hard
07:15:03 <bryanedds> Cale: Hmm. Could you give an example in Haskell?
07:15:12 <bryanedds> actually, I think not
07:15:30 <geekosaur> your initial call is missing a parameter
07:15:32 <Cale> Sure, like  data StateT s m a = StateT (s -> m (s, a))
07:15:40 <bryanedds> unfortunately, a type variable cannot carry any information other than interface constraints
07:15:48 <geekosaur> (either numfogs or n)
07:15:56 <Cale> bryanedds: So here, m can be another monad
07:16:08 <Cale> and StateT s m will be a monad whenever m is :)
07:16:08 <geekosaur> or you  have one too many thing there in "fogget numfogs n ..."?
07:16:34 <bryanedds> Ya, we cannot achieve that level of genericity, so we instead just inline stuff like that with code duplication
07:17:16 <bryanedds> so instead of monad transformers, for example, we duplicate all 'base' monad code into our custom monad
07:17:22 <Cale> right
07:17:25 <Cale> okay
07:17:35 <lisbeth> here's my function, now, and it complains that it is expecting a bool: let fogger n f x = takeWhile (n >= 0) ( f (fogger (n - 1) f x) )
07:17:50 <bryanedds> not a big deal as far as code duplication is concerned, but understandable frustrating for a haskell coder
07:17:54 <lisbeth> I don't know how to check for the typeclass it wants because I can't compile that line
07:19:27 <Cale> bryanedds: Yeah, the main problem is that it gets harder and harder to write the Monad instances, especially when the base monad is already so weird :)
07:19:36 <lisbeth> I think it is saying that (n >= 0) is not a bool
07:19:39 <lisbeth> what doesn't make sense to me
07:19:44 * hackagebot relational-query 0.3.0.2 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.3.0.2 (KeiHibino)
07:19:45 <lisbeth> > let fogger n f x = takeWhile (n >= 0) ( f (fogger (n - 1) f x) )
07:19:46 <lambdabot>  not an expression: ‘let fogger n f x = takeWhile (n >= 0) ( f (fogger (n - 1...
07:19:49 <Chathurga> lisbeth: What's the type of fogger?
07:19:55 <lisbeth> I don't know
07:19:59 <bryanedds> ah hmm
07:20:03 <lisbeth> I can't compile it so I can't use :t
07:20:05 <k00mi> :t takeWhile
07:20:05 <lambdabot> (a -> Bool) -> [a] -> [a]
07:20:39 <bryanedds> I think Don is contemplating Scala-style implicits, which might help with that type of generalization?
07:20:50 <bryanedds> (Don Syme - F# author)
07:20:51 <k00mi> lisbeth: (n >= 0) is a Bool, but takeWhile expects a function that returns a Bool
07:21:09 <lisbeth> oh I see
07:21:12 <lisbeth> so can I use a lambda?
07:21:18 <k00mi> yes
07:21:34 <bryanedds> although, implicits have a lot of god-awful semantic 'side-effects'
07:21:35 <Cale> I don't know Scala well enough to be able to say, but my first impression would be that this is kind of orthogonal to implicits...
07:21:50 <bryanedds> Scala implicits are super weird
07:22:06 <bryanedds> but, I don't know much about them either, so I could be up my ass on that statement
07:23:33 <aisqwe> where can i find the implementation of monad? i mean the source that has class Monad ... where?
07:23:59 <Cale> aisqwe: That's in the Prelude
07:24:48 <Cale> aisqwe: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.7.0.1/src/GHC-Base.html#Monad
07:25:01 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.7.0.1/Prelude.html#g:9 -- got there by clicking the source link here
07:25:11 <aisqwe> Cale: i cant find prelude in my sources
07:25:30 <aisqwe> Cale: thank you i will look at the link
07:25:53 <Cale> Well, it's in the base package, and actually in the module GHC.Base (at least in GHC)
07:26:08 <lisbeth> heh
07:26:17 <lisbeth> finally got it to compile but it doesn't work
07:26:21 <lisbeth> let fogger n f x = takeWhile (\ns -> if n >= 0 then True else False) ( f (fogger (n - 1) f x) )
07:26:25 <Cale> lisbeth: Did you try my version?
07:26:34 <lisbeth> which version?
07:26:40 <Cale> <Cale> numfogs 0 f x = x
07:26:41 <Cale> <Cale> numfogs n f x = f (numfogs (n-1) f x)
07:26:51 <lisbeth> It has to be one line
07:26:54 <n4x> lisbeth: write the type signature first
07:27:11 <Cale> okay, then  numfogs n f x = if n == 0 then x else f (numfogs (n-1) f x)
07:27:24 <Chathurga> Yeah I think you should write the type too, otherwise you're not really sure what you're implmenting
07:27:39 <lisbeth> parse error =
07:27:47 <Cale> Yeah, I'm not sure I understand what it is that you're trying to write
07:27:53 <lisbeth> I don't fully understand typeclasses at this point
07:27:59 <Cale> The name of the function certainly doesn't help
07:28:30 <lisbeth> fogger 5 succ 15 = succ (succ (succ (succ (succ 15))))
07:28:41 <Cale> yeah, in that case, just use what I wrote there
07:28:52 <lisbeth> parse error
07:29:00 <Cale> uh, where did you type it?
07:30:03 <lpaste> Exio4 pasted “repeatF ” at http://lpaste.net/2853071209078194176
07:30:09 <Chathurga> I'd call that iter or rep
07:30:13 <Chathurga> Or something similar
07:30:22 <Cale> yeah
07:30:41 <n4x> lisbeth: check the functions in that paste
07:36:13 <lisbeth> I think the problem is haskell doesn't expect f to be a function
07:36:45 <Cale> @let iter n f x = if n == 0 then x else f (iter (n-1) f x)
07:36:46 <lambdabot>  Defined.
07:36:53 <Cale> > iter 5 succ 0
07:36:54 <lambdabot>  5
07:36:57 <Cale> > iter 5 succ 6
07:36:59 <lambdabot>  11
07:37:02 <Cale> lisbeth: ^^
07:37:31 <Cale> lisbeth: My code is correct, trust me :)
07:37:59 <lisbeth> the last time you gave it to me there was a parse error
07:38:02 <lisbeth> if you check
07:38:14 <Cale> yeah, I don't understand why you got that parse error
07:38:24 <Cale> Where did you type my code? Did you put it in your source file?
07:38:35 <Cale> Or did you type it at the ghci prompt?
07:38:55 <Cale> If you want to give a declaration at the ghci prompt, you need to use let
07:38:56 <lisbeth> I have never gotten .hs files to work in ghci
07:39:04 <Cale> uhhhh
07:39:17 <Cale> Okay, let's get that straightened out first :)
07:39:21 <Cale> because it's pretty important
07:39:32 <Cale> Make a file called iter.hs
07:39:51 <Cale> and inside that file, put just the declaration:   iter n f x = if n == 0 then x else f (iter (n-1) f x)
07:40:03 <Cale> and then run  ghci iter.hs  on the commandline
07:40:14 <Cale> Or, load ghci and then :l iter.hs
07:40:21 <lisbeth> ok
07:41:25 <Cale> The usual thing to do when working on Haskell code is to keep (at least) two windows open: one for your text editor, and one for ghci
07:41:37 <Cale> Whenever you save the declarations in your file, you can use :r in ghci to reload
07:41:59 <faveteli_> Is metamorphic testing the same as property based testing in Haskell with QC?
07:43:05 <Cale> faveteli_: Based on Wikipedia's description it sounds very much like it
07:43:19 <Cale> faveteli_: But I'd never heard anyone use the term metamorphic testing before
07:43:43 <faveteli_> Cale: no i could not find any results googling QC and meta.. either
07:43:56 <Cale> I wonder what igneous testing is :D
07:44:45 <Cale> That's a real gneiss test you have there :D
07:50:22 <Cale> bryanedds: So like... jeez this is hard to follow, but maybe something like:  newtype Desync r e s a = Desync (s -> (s -> (e -> Desync r e s a) -> r) -> (s -> a -> r) -> r) -- I don't know if we're actually improving things or making them worse here :D
07:50:34 <bryanedds> oy
07:51:39 <Cale> The idea being that one of these things will take an input state and then a "wait" continuation, and a "done" continuation
07:52:01 <therp> are people here happy with hsenv? I am looking for a solution that my project-specific haskell installation doesn't bitrot, when I came after a couple of months. So I am thinking about just dumping a whole GHC environment into my project dirs.
07:52:12 <bryanedds> so, you're not sure if this will allow us to write bind in a tail-rec manner?
07:52:28 <Cale> I haven't written it yet
07:52:45 <Cale> But yeah, I'm not sure -- we're inverting control though, so maybe it'll help?
07:52:49 <bryanedds> hehe
07:52:57 <bryanedds> lemmas
07:53:09 <Cale> If in doubt, invert control again
07:53:39 <Cale> http://hackage.haskell.org/package/pipes-4.1.4/docs/src/Pipes-Internal.html#Proxy -- if you think this is bad, imagine doing the same with this :D
07:54:08 <bryanedds> *cries*
07:54:14 <Cale> bryanedds: pipes is like a vast generalisation of exactly what you want
07:54:29 <Cale> with altogether way too many type parameters :D
07:54:58 <narendraj9> What are some libraries available for Machine Learning in Haskell? I know there is HLearn. I want to do regression and classification.
07:55:23 <bryanedds> I think I can almost understand your type above
07:55:45 <bryanedds> it's like, surrounding my initial type with a continuation, ya?
07:55:51 <Cale> yeah
07:56:25 <bryanedds> so neat
07:56:27 <Cale> It's like instead of producing a pair, we produce a function which accepts a function of two arguments and applies that function appropriately :)
07:56:51 <Cale> and instead of producing an Either, we take two function arguments
07:56:56 <bryanedds> i dunno, maybe it will make it easier to understand bind, maybe?
07:57:03 <Cale> MAYBE
07:57:04 <bryanedds> seem like a separation of concenrs
07:57:07 <bryanedds> *concerns
07:57:23 <Cale> I wonder if djinn is smart enough
07:57:34 <Cale> Oh, right this is recursive so no.
07:58:10 <Cale> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
07:58:10 <lambdabot> f a b c = a (\ d -> b d c)
07:58:16 <Cale> It is pretty smart though
08:00:12 <Cale> return v = Desync (\s wait done -> done s v)
08:00:25 <Cale> now, the hard one
08:00:47 <bryanedds> heh
08:02:38 <Cale> I need to do this in Coq or something to have the interactive help with goals :D
08:04:00 <bryanedds> oh my
08:11:59 <haasn> http://edwardk.info/ huh
08:12:02 <haasn> Apparently no connection
08:19:09 <Cale> bryanedds: Well, this typechecks...
08:19:16 <bryanedds> hehe
08:19:35 <Cale> http://lpaste.net/117689
08:20:16 <Cale> I could have used run...
08:20:33 <bryanedds> holy sh...
08:21:03 <bryanedds> hmmmmmmmm
08:21:21 <bryanedds> well, I can try translating it into the engine and see what it does at least
08:21:24 <lpaste> Cale revised “No title”: “slightly improved” at http://lpaste.net/117689
08:22:56 <bryanedds> will take me a while to translate
08:23:01 <bryanedds> will you be around for a while?
08:23:03 <Cale> yeah
08:23:06 <bryanedds> cool
08:23:11 <bryanedds> thanks man :)
08:23:32 <bryanedds> Gabbard your last name, right?
08:23:35 <Cale> Gibbard
08:24:15 <bryanedds> ah right!
08:24:24 <Cale> With this representation, we should be able to have a wait combinator which is a bit nicer to use
08:24:58 <Cale> i.e. you won't have to pass it the continuation you want, you can just pull a result out of it like running anything else :)
08:25:24 <justinleitgeb> Hey folks, anyone know if it's possible to interpolate a value in a cabal file, specifically the ghc version? I need the correct HSrts, the filename changes based on the ghc version. In other words I want the cabal file to work with any version of ghc here: https://github.com/nh2/call-haskell-from-anything/pull/2/files
08:27:38 <bryanedds> interesting
08:28:07 <lpaste> Cale revised “No title”: “whoops, missed paren” at http://lpaste.net/117689
08:28:59 <justinleitgeb> Oh I guess a configure build script should be able to help based on the docs... trying that approach now.
08:29:09 <Cale> wait :: Desync r e s e
08:29:09 <Cale> wait = Desync (\s w d -> w s (\e -> return e))
08:30:30 <Cale> get :: Desync r e s s
08:30:30 <Cale> get = Desync (\s w d -> d s s)
08:30:31 <SrPx> Hello, deos anyone know what is this error with Cabal? http://lpaste.net/117693
08:31:11 <Cale> put :: s -> Desync r e s ()
08:31:11 <Cale> put s = Desync (\s' w d -> d s ())
08:32:41 <Cale> SrPx: hmm, maybe have a look at the complete log file?
08:33:45 <SrPx> it has only that single line, Cale
08:33:54 <luite> SrPx: use --disable-profiling nw
08:33:55 <luite> now
08:35:07 <SrPx> vh:cabal-install apple1$ cabal --enable-tests install --dependencies-only --disable-profiling ........ $ cabal: unrecognized option `--disable-profiling'
08:36:25 <luite> SrPx: can you try -j1 and not passing any profiling options?
08:37:24 <SrPx> luite: sorry what do you mean exactly?
08:37:45 <SrPx> cabal --enable-tests -j1 install --dependencies-only ?
08:38:32 <luite> SrPx: yes
08:38:51 <SrPx> http://lpaste.net/117694
08:41:02 <Cale> bryanedds: and the worst part is, I have no idea if this is going to help since we're still calling h -- my hope though is that since we're putting all the rest of the work under these lambdas in the continuations, maybe it'll be lazy enough.
08:41:16 <luite> SrPx: hm annoying. anyway, the --disable-executable-profiling / library-profiling options were combined into --disable-profiling in cabal 1.22, this must be some version conflict, make sure you have the Cabal 1.22 lib installed and visible if you use cabal-install 1.22
08:41:25 <monochrom> Cabal 1.22 is way too new
08:41:32 <bryanedds> Cale: hmm ok
08:42:04 <bryanedds> did you say control could be inverted yet again? :)
08:42:14 <Cale> Well, that's sort of what we've done here
08:42:28 <Cale> See, that's what allows the 'wait' that I implemented above
08:42:37 <Cale> wait :: Desync r e s e
08:42:37 <Cale> wait = Desync (\s w d -> w s (\e -> return e))
08:42:49 <Cale> I guess that could just be return instead of (\e -> return e)
08:43:28 <Cale> So, you can write  e <- wait
08:43:33 <Cale> instead of wait (\e -> ...)
08:43:45 <luite> SrPx: sandboxes typically hide the lib. and it will depend on what setup method (external / internal) is being used whether you actually need the lib
08:43:54 <luite> SrPx: that's why i asked about -j1
08:43:55 <SrPx> luite: nop I'll wait some time and try a clean reinstall
08:43:57 <SrPx> thank you! (:
08:44:00 <bryanedds> ok
08:44:10 <SrPx> I see
08:44:20 <Cale> I guess that would be  let! e = wait in your syntax :)
08:44:30 <Cale> or something like that
08:45:22 <drdo> Hmm, if i case on a GADT inside a do, i can't put anything after the case apparently. What's going on?
08:45:34 <Cale> drdo: uhhhh
08:45:36 <bryanedds> my crazy alien syntax :)
08:45:48 <hpc> you mean you can't continue writing as if you were in a do block?
08:46:18 <drdo> i'll give the actual example
08:46:23 <Cale> drdo: This only happens with the GADT? Or could it just be that something is weird with indentation?
08:48:45 <drdo> http://lpaste.net/117695
08:49:00 <drdo> If i remove the "solverFlush s", it compiles just fine
08:49:26 <eyebloom> drdo: check if you are mixing tabs with spaces?
08:49:37 <drdo> there are no tabs...
08:49:38 <hpc> wonky newline?
08:49:45 <hpc> solverFlush s isn't line-numbered
08:49:55 <drdo> huh?
08:50:49 <hpc> nvm, every line is CRLF
08:51:08 <drdo> It isn't a weird indentation error, it really doesn't work
08:51:28 <eyebloom> drdo: delete all the ends of lines and reenter them or copy and paste into another text editor.
08:51:29 <drdo> i'll give the errors
08:51:49 <eyebloom> suggestions…
08:51:49 <drdo> http://lpaste.net/117696
08:51:52 <hpc> eyebloom: all the newlines are correct
08:52:23 <hpc> oh, that's totally different
08:52:29 <eyebloom> I see. It thinks you are using a different monad.
08:52:57 <drdo> It's odd because if i put the "solverFlush s" in each case then it goes along just fine
08:53:16 <hpc> you have some weird type issues
08:53:30 <drdo> I really don't understand the problem
08:53:50 <eyebloom> Right your case statement returns a different monad than your solverFlush
08:54:08 <drdo> how so?
08:54:24 <drdo> everything in there is m ()
08:54:50 <eyebloom> I’m not sure but try adding some type annotations to make sure that it’s typechecking all of your returns to m ()
08:57:00 <eyebloom> Basically what its saying is that solverPutPPLn s (CmdSetOption $ OptPrintSuccess v) is not necessarily m ()
08:58:39 <drdo> eyebloom: Which is very odd
08:58:56 <eyebloom> Right, I get hung up on this all the time.
08:59:12 <drdo> I really declared the type of solverPutPPLn as is in the paste
09:00:23 <eyebloom> The compiler basically sees the first statement in the do (the case) as polymorphic over some type variable and the second as not.
09:01:10 <monochrom> could you reproduce the problem with only Prelude stuff? I don't want to know what Option is.
09:01:30 <monochrom> or PP, or CmdSetOption, all those distracting things
09:01:37 <neuroserpens> What would you guys say are both the best performing web server and nosql database management system for haskell?
09:01:59 <neuroserpens> I've been reading stuff about snap and acid-state and they seem the most promising combinations
09:02:03 <neuroserpens> combination*
09:02:44 <wz1000> neuroserpens: Mighty probably.
09:03:16 <neuroserpens> wz1000: Thanks for the input.
09:04:28 <monochrom> why do both "Option" and "Option a" have kind * ?
09:05:42 <drdo> monochrom: yes, will paste now
09:06:09 <drdo> http://lpaste.net/117697
09:06:43 <drdo> monochrom: It's another Option in another module, sorry for the confusion, but there's the problem reproduced there with only well known things
09:09:37 <EvanR> :t mapM
09:09:38 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
09:09:43 <EvanR> :t T.mapM
09:09:43 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
09:09:48 * hackagebot HGamer3D-CEGUI-Binding 0.5.0 - A Toolset for the Haskell Game Programmer - CEGUI Bindings  http://hackage.haskell.org/package/HGamer3D-CEGUI-Binding-0.5.0 (PeterAlthainz)
09:09:50 * hackagebot HGamer3D-Enet-Binding 0.5.0 - Enet Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Enet-Binding-0.5.0 (PeterAlthainz)
09:09:52 * hackagebot HGamer3D-Ogre-Binding 0.5.0 - Ogre Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Ogre-Binding-0.5.0 (PeterAlthainz)
09:09:54 * hackagebot HGamer3D-SDL2-Binding 0.5.0 - SDL2 Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-SDL2-Binding-0.5.0 (PeterAlthainz)
09:09:56 * hackagebot HGamer3D-SFML-Binding 0.5.0 - SFML Binding for HGamer3D  http://hackage.haskell.org/package/HGamer3D-SFML-Binding-0.5.0 (PeterAlthainz)
09:10:00 <monochrom> this is very odd indeed. there may be a bug.
09:11:30 <drdo> monochrom: Seems particularly weird since it's probably a common thing
09:12:52 <eyebloom> There are no bugs in ghc!
09:12:57 <kokut> >
09:13:02 <kokut> grep >
09:14:58 * hackagebot HGamer3D-Data 0.5.0 - Toolset for the Haskell Game Programmer - Data Definitions  http://hackage.haskell.org/package/HGamer3D-Data-0.5.0 (PeterAlthainz)
09:15:00 * hackagebot HGamer3D-Common 0.5.0 - Toolset for the Haskell Game Programmer - Game Engine and Utilities  http://hackage.haskell.org/package/HGamer3D-Common-0.5.0 (PeterAlthainz)
09:15:02 * hackagebot HGamer3D-Audio 0.5.0 - Toolset for the Haskell Game Programmer - Audio Functionality  http://hackage.haskell.org/package/HGamer3D-Audio-0.5.0 (PeterAlthainz)
09:15:04 * hackagebot HGamer3D-InputSystem 0.5.0 - Joystick, Mouse and Keyboard Functionality for HGamer3D  http://hackage.haskell.org/package/HGamer3D-InputSystem-0.5.0 (PeterAlthainz)
09:15:06 * hackagebot HGamer3D-Network 0.5.0 - Networking Functionality for HGamer3D  http://hackage.haskell.org/package/HGamer3D-Network-0.5.0 (PeterAlthainz)
09:15:38 <monochrom> oh, GHC 7.8.4 was out recently, we should try it
09:16:04 <drdo> monochrom: I did
09:16:08 <drdo> I'm using 7.8.4
09:16:18 <monochrom> I see
09:16:24 <int-e> it's the same in the 7.10.1 RC
09:20:08 * hackagebot HGamer3D-Graphics3D 0.5.0 - Toolset for the Haskell Game Programmer - 3D Graphics Functionality  http://hackage.haskell.org/package/HGamer3D-Graphics3D-0.5.0 (PeterAlthainz)
09:20:10 * hackagebot HGamer3D 0.5.0 - A Toolset for the Haskell Game Programmer  http://hackage.haskell.org/package/HGamer3D-0.5.0 (PeterAlthainz)
09:24:28 * HeladoDeBrownie perks up a bit
09:25:05 <HeladoDeBrownie> huh, this looks like it may be the game package i was looking for
09:27:52 <EvanR> :t foldMap
09:27:53 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
09:30:06 <quchen> johnw: What are the standard search paths of c2hsc, and can I change them via parameters? I've got my headers in a small temporary directory, and when I run "c2hsc --prefix=Foo bar/main.h" it complains the includes inside main.h cannot be found, e.g. #include <bar/baz.h>".
09:35:00 <augustss> Yo!
09:35:08 <ReinH> augustss: yo
09:42:25 <hnoob> hey I seem to remember something about the diamond dependency problem being solved somehow, or a solution was being considered, or something.
09:42:33 <hnoob> is that slated for 7.10??
09:43:09 <hnoob> IIRC that's the one where libraries rely on different versions of the same dependency, something like that
09:46:05 <mokkake> hey, i got this error when trying to build lambdabot: http://pastebin.archlinux.fr/764127
09:46:17 <mokkake> anyone already solved this issue
09:46:19 <mokkake> ?
09:46:19 <int-e> drdo: fascinating; http://lpaste.net/117699 simplifies the code further. The type checker invents type variables for the 'const' (const :: a0 -> b0 -> a0), and at some point, it needs to resolve  (case x of A -> ()) :: b0, and that gets pushed inside across the  a ~ Bool  constraint derived from the pattern match. It still looks like a bug.
09:49:23 <int-e> mokkake: you could try cabal install with --constraint='network<2.6', or apply a patch like  https://github.com/mokus0/lambdabot/pull/88
09:52:18 <sivteck> int-e, how to do `cabal sdist` with that repo? I can build lambdabot but cannot create sdist ;[
09:52:40 <augustss> int-e: Is that GADT problem really a bug?  Isn't it a fundamental problem with type checking GADTs?
09:53:45 <augustss> Basically, you cannot do type interence for GADTs, only type checking.  In the context inside that const, there is no type given for the GADT case expression.
09:54:12 <augustss> Which means ghc can't really figure things out.
09:54:20 <augustss> But the error message is poor.
09:54:33 <carter> yeah
09:54:38 <carter> i've spoken with richard about it
09:54:39 <int-e> augustss: The confusing thing is that  case x of A -> ()  type-checks just fine by itself.
09:55:03 <carter> it always looks like "data family" shaped gadts could have good inference, but they cant for some reason
09:55:38 <int-e> augustss: it's really about the unknown type variable being pushed across the pattern match, which makes it "untouchable" in ghc's view, and therefore it cannot be assigned the () type anymore.
09:56:06 <augustss> This doesn't type check for me: baz x = case x of A -> ()
09:56:19 <augustss> Note the absense of a type signature.
09:56:47 <int-e> right.
09:56:51 <drdo> That is very strange
09:56:56 <augustss> No, it's not.
09:57:15 <augustss> Type inference doesn't work for GADTs in general.
09:57:34 <drdo> Well i'm not very familiar with how type inference/checking works, I just mean that it seems obviously ok
09:57:41 <int-e> It's still an embarrassing example.
09:57:52 <carter> augustss: i've actually tried to talk iwth richard about how to do "closed data families"
09:58:17 <carter> roughly GADTS that satisfy a data family like injectivity condition
09:58:43 <augustss> The only embarressing part is the error message.  If the error message had said "Need a type signature for GADT case expressions" it would have been fine.
09:58:45 <carter> i've some pretty neat codes that I had to move from GADTs to a DataFam encoding to get good inference
09:58:47 <int-e> But augustss is right, this is about the boundary between the cases where ghc can work out types and where not.
09:59:06 <drdo> augustss: Which type signature exactly would one have to introduce?
09:59:32 <augustss> drdo: The type of the case expression has to be known.
09:59:47 <int-e> (I mean, surely it's possible to extend the type checker to deal with this particular case.)
10:00:16 <augustss> int-e: Yes, but every such extension would just be a hack since the general case is undeciable.
10:00:17 <drdo> augustss: What about my example?
10:00:24 <carter> int-e: injectivity + gadts is tricky
10:00:32 <carter> augustss: great to have you back on the IR Seas
10:00:45 <int-e> carter: I believe it.
10:00:46 <drdo> I still don't understand where GADTs even come in
10:01:03 <carter> int-e: i've some use cases where i'd love to have "closed data families"
10:01:03 <augustss> drdo: X is a GADT
10:01:06 <drdo> Surely if all the cases have the same type, the whole case has that type
10:01:14 <drdo> augustss: I know, i was the one to run into this problem
10:01:19 <augustss> This works: baz x = (case x of A -> ()) :: ()
10:01:43 <augustss> It's just the way the ghc type checker works.
10:02:06 <augustss> And in general there is nothing to do about it.
10:02:11 <drdo> Why doesn't (case x of A -> (() ∷ ())) work?
10:02:27 <drdo> What is it about GADTs that prevents the type of the case from being known?
10:02:28 <augustss> Because the type of the case is know to be ().
10:02:39 <augustss> So it's type checking rather than inference.
10:03:02 <drdo> augustss: But surely it's trivial to infer the type of the case if one knows the type of all the cases?
10:03:19 <int-e> not in general
10:03:25 <augustss> drdo: As I said, yes, you could make it work in special cases.
10:03:32 <Oded> Hello
10:03:32 <augustss> But not in general.
10:03:34 <drdo> I don't see what is special though
10:03:51 <drdo> If i really know that all cases have type τ, then the case has to have type τ
10:04:01 <drdo> I don't understand why you even need to known anything about τ
10:04:05 <Oded> Im new to Haskell, Im try to make a dictionary program and I dont understand why haskell wont evaluate some IO action I did
10:04:06 <augustss> But that is a special case
10:04:31 <drdo> augustss: How so, if τ is arbitrary?
10:04:52 <Oded> Can someone help me?
10:04:57 <augustss> drdo: Normally the types of the RHSs of the case will involve the type variables determined by the patterns.  Having all RHSs have the same monotype is an unusual special case.
10:05:12 <Oded> Hello
10:05:33 <Oded> Can someone please help me?
10:05:46 <drdo> Oded: Make an actual question
10:06:30 <Oded> okay. so here is my code: http://pastebin.com/kZ8PBH5Y . And when I call the function from the list (line 31), Haskell wont print "Not Implemented".
10:06:45 <Oded> I can figure out why haskell wont evaluate i
10:06:46 <Oded> it
10:09:03 <augustss> Becuase you never execute (f entries)
10:09:26 <augustss> You just pass it to programStart.
10:10:22 <Oded> Oh I'm such an idiot, haskell doesnt use have to evaluate it.. So how do I make haskell evaluate it?
10:10:59 <augustss> Well, you could change '_ -> programStart (f entries)' to be ' _ -> do f entries; return ()'
10:11:19 <augustss> Then something will happen, but not what you want, I'm sure.
10:11:27 <int-e> drdo: In general the type \tau is allowed to depend on the GADT type arguments; you could have  f :: X a -> a; f A = True, and a few more cases. That rules out the usual approach of deriving a common type for the case branches (namely, type unification). (In fact that example shows the lack of principal types: with only one case alternative, should the inferred type be  f :: X a -> a  or  f :: X a ->...
10:11:28 <Oded> Ill give it a try
10:11:33 <int-e> ...Bool?). It's not even trivial to characterise the special cases that work, and it actually soon becomes impossible in the presence of type families (there could be a type family Foo with Foo Bool = () and Foo Int = Bool; inferring  (case x of A -> ()) :: () will prevent later inferring that  f :: X a -> Foo a).
10:11:47 <augustss> I suspect you want this:  menuOptions :: [(Int,String,(Entries -> IO Entries))]
10:12:34 <int-e> carter: thanks for the reminder that GADT pattern matchin interacts non-trivially with type families.
10:16:20 <Oded> Thank you augustss
10:16:22 <Oded> it now works
10:17:14 <Oded> I'm still practicing the language, how can I understand when my function should receive Monadic value and when to return and vice-versa ?
10:17:37 <Oded> Im trying to understand it intuitively
10:20:41 <pavonio> There's probably no general answer to this question, it really depends on the function you're writing
10:21:53 <augustss> Oded: It's unusual to have arguments of monadic type.
10:22:27 <hpc> alternatively, it's extremely common to have arguments of monadic type ;)
10:22:35 <augustss> Oded: The monad describes the (side) effects the function has, so it appears in the return type.
10:23:14 <Oded> Hmm okay. Can you give me an example of a function that needs to take monadic argument?
10:23:17 <EvanR> :t sequenceM
10:23:18 <lambdabot>     Not in scope: ‘sequenceM’
10:23:18 <lambdabot>     Perhaps you meant one of these:
10:23:18 <lambdabot>       ‘sequence’ (imported from Control.Monad.Writer),
10:23:20 <augustss> hpc: Well, the monadic combinators have arguments of monadic type, of course.  But it's not something a beginner writes.
10:23:22 <EvanR> :t sequence
10:23:23 <lambdabot> Monad m => [m a] -> m [a]
10:23:39 <EvanR> i was a beginner and had to write untilM or whileM ;)
10:23:41 <hpc> Oded: a good example would be something like withFile
10:24:20 <hpc> for instance,
10:24:22 <hpc> withFile "/var/log/messages" ReadMode $ \h -> do
10:24:32 <pavonio> :t withFile
10:24:32 <hpc>   ...
10:24:33 <lambdabot>     Not in scope: ‘withFile’
10:24:33 <lambdabot>     Perhaps you meant one of these:
10:24:33 <lambdabot>       ‘writeFile’ (imported from Prelude),
10:24:49 <pavonio> :t System.IO.withFile
10:24:50 <lambdabot> FilePath -> GHC.IO.IOMode.IOMode -> (GHC.IO.Handle.Types.Handle -> IO r) -> IO r
10:25:03 <hpc> withFile's definition is "open the file in a specific way, then do something with it and close it"
10:25:33 <neuroserpens> Hey... This is highly offtopic but, do any of you guys know of any optical head mounted display gear that can be hooked up to a single board computer?
10:25:34 <Oded> what's the monadic argument here? I only see filepath, IOMode and function
10:25:34 <hpc> the function doesn't know what exactly should be done with the file, so it takes that action as a parameter
10:25:46 <hpc> neuroserpens: ask in -blah
10:25:55 <Oded> A function that returns monadic argument is considered an Action?
10:25:57 <neuroserpens> hpc: Thanks. Will do.
10:26:23 <Oded> A function that returns monadic value*
10:26:28 <ReinH> Oded: values of type m a for some Monad m are sometimes called "actions"
10:26:29 <hpc> Oded: almost
10:26:35 <EvanR> :t when
10:26:36 <lambdabot> Monad m => Bool -> m () -> m ()
10:26:40 <hpc> he left
10:26:45 <augustss> Oded: (>>=) has a monadic argument.
10:26:50 <EvanR> welp
10:26:57 <Oded> lol sorry I accidently logged of
10:27:01 <Oded> f
10:27:01 <hpc> Oded: basically, a thing of type (m a) is an action
10:27:10 <eyebloom> Oded: Here is what I did to “learn monads”: Initially did not use do notation its generally easier to understand at first without it because you see the lambdas that the do notation will create. I got some giant pieces of paper and reduced a bunch of terms involving monads by hand.
10:27:20 <hpc> :t getLine -- an action that does "read a line from stdin and return it"
10:27:22 <lambdabot> IO String
10:28:14 <eyebloom> Painful. But basically it comes down to you need some neural pathways that let you “speak monad”.
10:28:25 <Oded> okay
10:28:31 <hpc> Oded: the term is often used for "simple" functions too, because it doesn't have a terribly compelling reason to have a rigid definition
10:28:35 <Oded> I'll try to use only the bind notation for a while
10:28:39 <EvanR> its very useful when you need to understand a non-IO monad
10:28:40 <hpc> :t putStrLn -- sometimes also called an action
10:28:41 <lambdabot> String -> IO ()
10:28:47 <augustss> Don't worry about monads.  Thet'll seep into your brain eventually.
10:28:56 <eyebloom> Explanations involving metaphors are usually useless.
10:28:56 <Oded> From what I understood, the bind and lambdas are used to force Haskell into evaluating the arguments
10:29:25 <EvanR> bind is just a pure function, it doesnt force anything
10:30:00 <augustss> Oded: The bind and lambdas gives you certain data dependencies that might force evaluation.  It depends on the monad.
10:30:08 <hpc> Oded: no; some definitions force an /order/ of evaluation, if indeed they ever get evaluated
10:30:25 <hpc> Oded: the purpose of bind is different for every monad, the only commonality is the type
10:30:29 <hpc> :t (>>=)
10:30:30 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:30:36 <EvanR> and the laws
10:30:43 <hpc> and the laws
10:30:50 <Oded> So how do I grab the concept of a monad? Can you give me an example of monad that doesnt force order of evaluation?
10:30:55 <Oded> Maybe the Maybe monad?
10:32:04 <Oded> Im just try to practically understand monads, I understand the mathematical/formal notation.. But If Im gonna program in Haskell I need to capture the concept.. Maybe it will come up with the experience in the language..
10:32:06 <pavonio> The order is forced by the type of bind. You cannot evaluate m b when you haven't evaluated m a
10:32:09 <augustss> You can make this type into a monad:  data Trivial a = Trivial
10:32:19 <augustss> It's very boring.
10:32:23 <hpc> Oded: learn a few instances
10:32:24 <augustss> And forces nothing.
10:32:32 <shachaf> It's very useful in Haskell!
10:32:35 <shachaf> (By the name Proxy.)
10:32:39 <hpc> Maybe, [], IO, and the RWS trio
10:32:41 <shachaf> It's the type of lists that are always empty.
10:32:46 <hpc> (Reader, Writer, State)
10:32:51 <EvanR> (f >=> g) >=> h == f >=> (g >=> h)
10:32:55 <augustss> I know it's useful.  It's still boring. :)
10:33:02 <Oded> Is there a good source to learn about some Monads?
10:33:15 <Oded> I already familiar with IO and List
10:33:16 <augustss> Oh man...
10:33:20 <ChristianS> Oded: what specifically is your problem? monads are quite easy if you don't think about them too much.
10:33:29 <hpc> Oded: just play with them in ghci, avoid "good sources" ;)
10:33:42 <EvanR> first understand instances for Functor
10:34:15 <EvanR> which is a prerequisite for monads
10:34:30 <Iceland_jack> Oded: Learn Functors first, like EvanR said.
10:34:40 <Oded> How do I learn Functors?
10:34:51 <yac> typeclassopedia did it for me
10:34:55 <EvanR> theres typeclasso^
10:35:07 <Cale> Oded: Did you say you already know what these things are in category theory?
10:35:27 <Oded> More or less yes, but Its still doesn't fit naturaly
10:35:37 <quchen> Functor is a typeclass. Typeclasses unify things that act alike in a certain respect. Understanding a typeclass means understanding how its possible instances act alike. Learn how the instances work until enlightenment.
10:35:48 <quchen> Repeat for Applicative, Monad, and all the other classes.
10:36:01 <Iceland_jack> Oded: Do you know what type classes are?
10:36:08 <Oded> yes
10:36:17 <Cale> Oded: Okay, so the category we're working with in Haskell has Haskell types as objects, and Haskell-definable functions as the arrows (pretty much).
10:36:18 <Iceland_jack> Okay, do you know map?
10:36:22 <Oded> I just cant capture naturally the Monad typeclass
10:36:28 <monochrom> LYAH, typeclassopedia, and CIS 914 all talk about functor
10:36:39 <Cale> class Functor f where
10:36:39 <ReinH> Oded: this is the only source worth reading on monads imo http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
10:36:46 <Cale>   fmap :: (a -> b) -> f a -> f b
10:37:05 <Iceland_jack> I wouldn't mix the categorical concept of a functor with the Haskell type class Functor while learning
10:37:18 <EvanR> > fmap (+1) [1, 2, 3, 4, 5]
10:37:20 <yac> also http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf this is the only thing about monads that made sense to me
10:37:21 <lambdabot>  [2,3,4,5,6]
10:37:24 <Cale> This is a type class for (endo-)functors on the category of Haskell types -- with the type constructor f serving as the part of the functor which acts on objects
10:37:26 <EvanR> > fmap (+1) (Just 1)
10:37:28 <lambdabot>  Just 2
10:37:32 <Cale> and the function fmap giving the part which acts on arrows
10:38:16 <Cale> So, you'll recall that a monad consists of an endofunctor M together with natural transformations eta: 1 -> M and mu: M^2 -> M, yeah?
10:38:42 <Cale> (If this is all nonsense, just stop me and we'll go a completely different route to explaining :)
10:39:28 <Cale> (Understanding this category theory stuff is nice, but it's a large diversion if you're just interested in how to use monads in Haskell for programming)
10:39:36 <haroldcarr> an interactive paper that shows the "why/how to use monads" (not how they work): http://bit.ly/MH9zRD
10:40:12 <Cale> Iceland_jack: If you *already* know what a functor in category theory is, then it's obviously helpful
10:40:13 <Oded> yea. So fmap is just the thing that maps the functions as part of the Endofunctor?
10:40:18 <Cale> yeah
10:40:35 <Cale> You can see that fmap is taking a function of type (a -> b) to a function of type (f a -> f b)
10:40:43 <Oded> yea
10:40:49 <Cale> which is exactly what a functor is supposed to do on arrows
10:40:52 <Iceland_jack> Cale: There are too many discrepancies in my experience
10:40:52 <Oded> So fmap is the definition of the Functor typeclass in Haskell?
10:41:13 <hpc> fmap is part of the definition
10:41:22 <Oded> what's the other part?
10:41:24 <hpc> (the only part, but still...)
10:41:32 <hpc> ;)
10:41:44 <Cale> Oded: Well, you write an instance declaration which defines fmap while specifying what 'f' is.
10:41:46 <Iceland_jack> It's very simple, it's a single function and after seeing two instances you "get" it: then you cover the laws and you're done
10:41:47 <Cale> like
10:42:03 <Cale> instance Functor Maybe where fmap f Nothing = Nothing; fmap f (Just x) = Just (f x)
10:42:26 <mokkake> hey, i got another error when trying to build lambdabot: http://pastebin.archlinux.fr/764128 anyone already solved this ?
10:42:33 <Oded> Typeclassing in Haskell reminds me of function overloading for different Types.
10:42:37 <Cale> So here, fmap :: (a -> b) -> (Maybe a -> Maybe b)
10:42:44 <EvanR> Oded: Functor class implies some sensible laws for any instance to follow
10:42:54 <EvanR> fmap id = id
10:43:04 <Cale> Oded: Yeah, it's kind of like a more principled way of doing function overloading.
10:43:08 <Oded> yea
10:43:33 <Oded> The functor class should reserve the structure of a category, identity and composition , no?
10:43:51 <Cale> Yeah
10:44:12 <Cale> So we require (informally) that  fmap id = id  and that  fmap (f . g) = fmap f . fmap g
10:44:21 <Oded> ok
10:44:57 <Cale> There's no way in Haskell to get the compiler to check that for us, but if we were using a dependently typed language, we might require proofs of those equations.
10:44:59 <EvanR> but one implies the other for some reason
10:45:19 <EvanR> maybe only in haskell
10:45:22 <Cale> Yeah... that's because polymorphic functions are quite restrictive
10:45:28 <Oded> So... How is a monad different from a functor?
10:45:49 <Cale> A monad is an endofunctor together with some additional natural transformations (which again satisfy some equational laws)
10:46:08 <Oded> whats special about the natural transformations?
10:47:07 <Cale> In particular, it's a triple (M, eta, mu) where M: C -> C is an endofunctor, eta: 1 -> M is a natural transformation from the identity functor on C to M, and mu: M . M -> M is a natural transformation from the composite of M with itself to M.
10:48:03 <Cale> and the laws are easier to understand if you have a diagram http://en.wikipedia.org/wiki/Monad_(category_theory)#Formal_definition
10:48:24 <Oded> What's a natural transformation exactly? I think I forgot , lol.
10:48:53 <Cale> Ah, okay, so given functors F, G: C -> D
10:51:32 <Cale> Then a natural transformation eta: F -> G consists of for each object X in C, an arrow eta_X: FX -> GX in D, and for each arrow a: X -> Y in C, a commutative square in D involving FX, GX, FY, GY, which says that Ga . eta_X = eta_Y . Fa
10:51:54 <ReinH> EvanR: (fmap id = id implies fmap (f . g) = fmap f . fmap g by the free theorem for fmap)
10:51:56 <Cale> http://en.wikipedia.org/wiki/Natural_transformation#Definition -- again, it really helps to see the picture
10:52:19 <shachaf> ReinH: (If your type is a functor, at least.)
10:52:37 <ReinH> shachaf: (indeed)
10:53:16 <Oded> Can you give me a concrete example for a natural transformation?
10:53:20 <Oded> Its just very formal
10:53:21 <shachaf> It's almost circular reasoning -- you can make your type a functor more easily, but you have to already know that it's a functor to use the free theorem.
10:53:49 <shachaf> Oded: If the goal of this is just to figure out Monad in Haskell, I doubt the category theory is going to be particularly helpful.
10:54:10 <ReinH> shachaf: I thought it meant that you only need to check the id law
10:54:12 <Cale> So, if we think of the images of F and G as being like two "sketches" of the category C sitting inside the category D, the natural transformation eta: F -> G provides an arrow eta_X in D connecting the corresponding objects FX and GX for each X, and each arrow in C gets swept out into a commutative square in D (which if you're geometrically minded, you might picture as a 2D sheet)
10:54:27 <shachaf> ReinH: If you already know your type is a functor, yes.
10:54:42 <Iceland_jack> ..
10:54:52 <ReinH> shachaf: So there are types which admit an fmap where fmap id = id that are not functors?
10:54:52 * hackagebot uniform-pair 0.1.5 - Uniform pairs with class instances  http://hackage.haskell.org/package/uniform-pair-0.1.5 (ConalElliott)
10:54:58 <Cale> Yeah, I could provide some examples from mathematics, if you have a background in mathematics
10:55:05 <shachaf> I don't know.
10:55:15 <ReinH> Oded: here's one: listToMaybe
10:55:29 <ReinH> shachaf: but it doesn't necessarily follow? Interesting.
10:55:39 <quchen> ReinH: A strict Identity for example. fmap f x = f `seq` x `seq` (Id . f . runId) x
10:55:42 <Cale> But I agree with shachaf that if you're just trying to learn Haskell, this is a much more difficult and abstract route to understanding this stuff than you'll need :)
10:55:52 <ReinH> quchen: morally correct morally correct la la la can't hear you ;)
10:55:53 <shachaf> Have you read the proof you're referring to?
10:56:03 <ReinH> shachaf: Yes.
10:56:51 <Cale> So, you might recall from linear algebra, the double dual construction and the embedding into the double dual?
10:57:23 <ReinH> @free map
10:57:24 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
10:57:35 <ReinH> shachaf: you set k = (g  . h) and f = id
10:57:39 <ReinH> or vice versa
10:57:54 <shachaf> But that free theorem assumes that your type is already a functor.
10:57:59 <shachaf> It has $map right there.
10:58:18 <ReinH> Hmm
10:59:01 <shachaf> quchen: What's with that strict Identity fmap? Identity is already strict. fmap isn't strict in the function, but that's all you're doing there.
10:59:04 <ReinH> I'd have to look at the construction of the free theorem
10:59:25 <Oded> I know a little of mathematics, but I dont think my level is good enough for math examples
10:59:47 <Oded> Hmm.. I guess I'll have to practice the monads in Haskell to understand it
10:59:48 <Cale> For each vector space V over the field F, we have a dual vector space V* consisting of the linear maps V -> F, and then while getting a linear map V -> V* generally requires picking a basis for V, there's a linear map V -> V** which is "natural" and doesn't depend on a choice of basis, and the more precise sense in which it's natural is that it's actually a natural transformation from the identity functor on the catego
10:59:48 <Cale> ry of vector spaces over F to the double dual functor.
10:59:51 <ReinH> Oded: have you read Phil Wadler's paper yet?
10:59:52 * hackagebot cron 0.2.4 - Cron datatypes and Attoparsec parser  http://hackage.haskell.org/package/cron-0.2.4 (MichaelXavier)
11:00:06 <Oded> Not yet
11:00:10 <ReinH> Oded: you should go do that.
11:00:14 <quchen> shachaf: The "strict" referred to the function, yes. It's an instance for which the first law holds, but not the second. (It would still be possible to write a legitimate instance for the given type though.)
11:00:23 <Cale> Oded: Yeah, if you don't know a bunch of mathematics already, then probably starting out with the category theory definitions is going to be needlessly brutal :)
11:00:25 <ReinH> Every other monad tutorial/explanation is a pale imitation of the original
11:00:42 <Oded> Ok I'll try Phil's paper
11:00:57 <khyperia> Hmm... I'm failing to come up with this myself, is there a simpler way to write "left >>= \x -> right >>= \_ -> return x" (aka apply left, apply right, return result of left)?
11:01:03 <shachaf> quchen: Extra seqs in a context like that are just misleading.
11:01:07 <shachaf> Like http://hackage.haskell.org/package/strict-identity-0.1.0.0/docs/src/Control-Monad-StrictIdentity.html
11:01:10 <ReinH> Oded: Everything Cale is saying is correct... and probably not very useful to you right now ;)
11:01:34 <vanila> x <- left ; right ; return x
11:01:45 <Cale> Yeah, I like to provide this stuff if people want it, but for the average person learning Haskell, it's way far afield :)
11:01:47 <vanila> const <$> left <*> right
11:01:49 <ReinH> But the Wadler paper is probably very well suited for you, or vice versa
11:01:55 <ReinH> Cale: :)
11:02:01 <khyperia> ah, I like that, vanila
11:02:03 <Cale> I'm rather partial to my tutorial as well: https://www.haskell.org/haskellwiki/Monads_as_computation
11:02:03 <khyperia> the second one
11:02:10 <khyperia> thanks!
11:02:21 <Cale> I try to explain specifically why we care about these things from a functional programmer's perspective
11:02:28 <Cale> rather than a mathematician's perspective
11:02:38 <ReinH> vanila: not bad...
11:03:01 <EvanR> monad_tutorial.pdf
11:03:11 <Cale> It basically comes down to the fact that we write a lot of libraries that have a particular "shape" in their API, and so it's a good idea to give that shape a name and abstract over it.
11:03:18 <ReinH> why not just left <* right though? Assuming your Monad is also an Applicative?
11:03:35 <khyperia> oh, good point, ReinH
11:03:47 <Cale> and that lets us write code which will work with any of those libraries
11:04:20 <Oded> I think I jumped to Monads before I had enough time with Functors...
11:04:26 <ReinH> Cale: one value of mathematical abstractions is that they tend to not leak ;)
11:04:59 <khyperia> but to give some context, I'm using a parser combinator library in C# called Sprache, and I subconsiously wrote a helper method named "const" that returned the left one and I had no idea why I named it that. vanila helped... but unforunately the library doesn't include Applicative. Thanks, though, I like learning!
11:05:17 <vanila> you can make an applicative instance
11:05:26 <khyperia> true
11:10:36 <ReinH> vanila: btw (<*) = liftA2 const is a pretty nice use of applicative "syntax" :)
11:24:09 <Cale> bryanedds: having any luck?
11:24:36 <bryanedds> sorry, was got pulled into something else
11:24:55 <bryanedds> BTW, apparently there IS a trick to encode ContT in F# -
11:25:08 <bryanedds> http://stackoverflow.com/questions/27755439/how-can-i-make-this-monadic-bind-tail-recursive?noredirect=1#comment43923282_27755439
11:25:14 <bryanedds> see comments at the bottom
11:26:31 <Cale> hmm
11:26:55 <Cale> Well, it's good that they mention StateT over Cont
11:27:06 <SrPx> Is there any way to list a library contents other than hackage.haskell.org ?
11:27:17 <SrPx> i.e. a list of all symbols and functions
11:27:19 <bryanedds> do you think I should try that approach instead?
11:27:33 <Cale> bryanedds: Well, you sort of are :)
11:27:41 <pavonio> SrPx: :browse Module.Name in GHCi
11:27:50 <Cale> bryanedds: I just turned your thing into a continuation monad
11:27:53 <bryanedds> ah ok
11:28:24 <Cale> If you can somehow *really* do monad transformers, it might be worth trying an approach that goes that way
11:28:54 <bryanedds> hmm, would it simplify the code if I later tried to leverage their ContT lib, or would it be straight-forward enough to translte the code as-is
11:29:24 <Cale> You might be able to use your old monad along with their ContT library
11:29:29 <bryanedds> if it doesn't make it much more complex, I'd rather just use a translation of the current code
11:29:41 <bryanedds> the code you just made
11:31:19 <hodapp> I was making a small edit to something in Ivory (which presently I've installed in a Cabal sandbox), and now my project which depends on it cannot build or run a repl, because: cannot satisfy -package-id ivory-0.1.0.2-8fc08c7565aa029823152e637d405265
11:32:29 <hodapp> the Ivory makefile just does 'cabal sandbox add-source' and 'cabal install', but I could really use a hint on what I need to do to be able to work on a development version of this package
11:33:26 <hodapp> I am able to run 'cabal repl' right from the sandbox directory and test what I changed, but do I need to increase a version number someplace or something?
11:33:30 <bryanedds> that is, I'm hoping I can ignore the ContT stuff in their work and just translate your code and be done with it
11:38:57 <bryanedds> you know, I think I will do that any way
11:39:16 <bryanedds> honestly, I like the 'raw' approach
11:41:15 <ryantrinkle> when i've got a closed data kind, how do i demonstrate to the compiler that type class instances are complete?
11:42:08 <ryantrinkle> e.g.: if i have instance C '[] and instance C t => C (h ':t )
11:42:33 <ryantrinkle> is there a way to avoid including C constraints in functions that make calls to the class methods of C?
11:45:53 <absence> on reddit it was mentioned that free monads could be used to write endian-neutral binary.get instances how does that work? use an adt that represents the various binary operations with the free monad, and then "evaluate" it by matching the various adt operations, and either perform little endian or big endian version of each operation?
11:46:41 <lpaste> cdk pasted “Serializable Closures with -XStaticPointers” at http://lpaste.net/117703
11:50:40 <benzrf> ryantrinkle: why not just use a type family
11:50:45 <benzrf> ryantrinkle: oh are there actual methods
11:51:06 <ryantrinkle> benzrf: yeah; things like sequencing an HList, transforming HLists to and from DMaps
11:51:18 <benzrf> neato
11:51:26 <benzrf> ryantrinkle: you could make a dummy instance >.>
11:51:37 <benzrf> er, wait
11:51:45 <ryantrinkle> oh, with overlappinginstances?
11:51:51 <ryantrinkle> and then have it dispatch to the other two? :
11:51:52 <ryantrinkle> :P
11:51:55 <benzrf> i wasnt thinking hold on
11:51:56 <ryantrinkle> i wonder if that would work
11:51:56 <meoblast001> ugh. i feel like i'm forgetting something.. is there a function with this type signature? Hoogle's not giving me anything. (Functor f1, Functor f2) => f1 (f2 a) -> f2 (f1 a)
11:52:05 <benzrf> meoblast001: fmap . fmap
11:52:11 <benzrf> er, wait
11:52:17 <ryantrinkle> meoblast001: that looks like it'll only work with certain functors
11:52:17 <benzrf> meoblast001: i misread, sorry
11:52:18 <HeladoDeBrownie> there is not a general function for that
11:52:24 <benzrf> meoblast001: why do you want this
11:52:39 <meoblast001> well, more specifically i have a list of monads and need a monad of a list
11:52:42 <HeladoDeBrownie> i think someone might have written a commutative monad class though
11:52:46 <benzrf> meoblast001:
11:52:47 <HeladoDeBrownie> ah, that's easy
11:52:48 <benzrf> :t sequence
11:52:49 <lambdabot> Monad m => [m a] -> m [a]
11:52:54 <benzrf> meoblast001: general form:
11:52:58 <meoblast001> oh thanks. i feel like i've done that before
11:52:58 <benzrf> :t T.sequenceA
11:52:59 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
11:53:07 <ReinH> :t traverse
11:53:08 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
11:53:29 <benzrf> meoblast001: Traversable is a class for Functors that allow you to do the thing you described (when the other one is an Applicative)
11:53:40 <ReinH> sequenceA is the most general
11:53:50 <ReinH> At least, I don't think you can write a more general version
11:53:51 <meoblast001> ah, okay. that makes sense :)
11:53:51 <meoblast001> thanks
11:54:03 <benzrf> ryantrinkle: have you considered writing a parametrically polymorphic function :^)
11:54:20 <ryantrinkle> benzrf: lol, for what i'm doing?
11:54:30 <benzrf> yeh
11:54:45 <ryantrinkle> i'm essentially writing 'sequence' but for a record
11:54:51 <benzrf> ryantrinkle: hold on
11:54:56 <benzrf> ryantrinkle: you're working with an HList right
11:54:57 <meoblast001> wooo, compiles!
11:55:03 <ryantrinkle> yep
11:55:08 <ryantrinkle> i know it has sequence
11:55:17 <ryantrinkle> so i could just take that one
11:55:21 <benzrf> ryantrinkle: what are you writing, exactly
11:55:40 <ReinH> ryantrinkle: I usually bother jonsterling with my HList problems ;)
11:55:47 <meoblast001> Haskell's syntax always results in me getting more type errors than i should lol
11:56:11 <Lokathor> speaking of monads, is all monadic code "impure" or is it just the IO monad that's "impure"?
11:56:13 <ReinH> meoblast001: You are getting exactly the right number of type errors )
11:56:16 <ReinH> ;)
11:56:24 <EvanR> nothing is impure!
11:56:24 <ReinH> Lokathor: no monadic code is impure.
11:56:38 <meoblast001> reworded, i always forget precedence and my broken code won't compile
11:56:38 <ReinH> Lokathor: evaluation of the IO monad is impure, but construction of IO actions is pure.
11:56:54 <Cale> Execution* of the IO monad
11:57:01 <ReinH> Cale: yep ta
11:57:06 <Cale> The evaluation is the part that's pure :)
11:57:10 <Lokathor> ah, well then, rephrasing: does evaluation of other monads count as impure as well?
11:57:14 <ReinH> Lokathor: iow, everything that happens to create the IO () value in main is pure. Executing that action at runtime is impure.
11:57:21 <EvanR> > [getLine, getContents, return "bar"]
11:57:21 <Cale> not unless you think of it in a funny way
11:57:23 <lambdabot>  [<IO [Char]>,<IO [Char]>,<IO [Char]>]
11:57:24 <ReinH> Lokathor: No. Evaluation is pure. I used the wrong word.
11:57:53 <Lokathor> alright
11:58:02 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
11:58:04 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
11:58:10 <Cale> Evaluation of this list is pure
11:59:20 <EvanR> in the sentence "C has a natural number object N, with zero morphism 1 -> N and successor morphism succ : N -> N" does this mean there are many "instances" or "values" or such morphisms? or exactly two.
11:59:25 <meoblast001> hm. another thing i keep failing to find an answer to. if i have a testing file that is not managed by cabal (i am not checking it in), but i want to compile it with GHC under my cabal sandbox, is that possible?
11:59:28 <Cale> It's possible to think of it in a sort of sideways manner and picture that the computation is happening nondeterministically (which is a sort of "computational effect"), with x being picked in all possible ways from [1,2,3]
11:59:43 <drdo> Is there some way to include or exclude code based on the installed version of a package? (via the preprocessor or something)
12:00:23 <Cale> EvanR: errr, are you asking about whether once you have one NNO, that you must have many?
12:00:33 <Lokathor> Cale: Lean You A Haskell suggests exactly that interpritation of lists actually
12:00:55 <EvanR> no im trying to understand the cardinality of what its implying. that there is "one succ morphism" or something like "one for each N"
12:01:10 <Cale> There's just one succ being discussed there
12:01:13 <Cale> and just one N
12:01:23 <EvanR> ok
12:01:35 <hexagoxel> meoblast001: `cabal exec -- ghc`, perchance?
12:01:35 <Cale> In Set, the usual natural numbers are an NNO
12:01:41 <ReinH> Lokathor: which interpretation?
12:01:43 <Cale> and succ is the usual successor function
12:01:56 <EvanR> ok one N, one zero, and one succ
12:01:59 <meoblast001> hexagoxel: hm. you're right, it appears that does exist in newer versions of cabal
12:02:13 <meoblast001> i have two versions of cabal installed, and i don't think i saw that in my old one
12:02:17 <ReinH> Lokathor: And btw, as a general rule if LYAH and Cale disagree then LYAH is probably wrong. ;)
12:02:40 <Cale> Well, I don't disagree about that being a helpful way to think about things when it comes to the list monad
12:02:47 <Lokathor> ReinH: that a list can be viewed as a single non-deterministic value rather than a collection of individual deterministic values.
12:03:07 <Cale> But when you get right down to it, all the evaluation which is taking place is deterministic and pure.
12:03:41 <EvanR> Lokathor: including empty value?
12:03:42 <Lokathor> true true, you're more like filtering for the correct solution space given constraints... or something like that
12:04:54 <Lokathor> EvanR: under the non-deterministic view, each element in the list was described as "possible solution", so an empty list was described as being no possible solution
12:06:27 <EvanR> Lokathor: but (exluding bottom) under what circumstances can a computation resulting in type a have no result?
12:06:49 <Lokathor> filtering
12:07:08 <SrPx> I've found a few linear algebra libraries... what you recommend for use in graphics? I need only 3d vectors and quaternions, but fast
12:07:20 <EvanR> filtering is an operation on a collection, its not a non deterministic operation
12:07:58 <EvanR> including empty seems like a nondeterministic computation involving Maybe Int rather than Int
12:08:02 <vanila> Are there other possible monads for []?
12:08:22 <vanila> I implemented a monad on [] which has a "fair" join
12:08:53 <vanila> so >>= isn't just concatMap, but a kind of interleaving version
12:09:37 <Lokathor> EvanR: Yeah pretty much. I'm not saying it's a perfect way to think of the problem, that's just what the book said. It makes "enough" sense that it lets you more easily imagine when you might use a list monadically
12:09:52 <Lokathor> well, if you read the book's examples instead of my poorly reconveyed ones at least :P
12:10:03 <ReinH> vanila: I think you can make a ZipList monad? But it's inefficient since it has to recompute the diagonal...
12:10:54 <pavonio> vanila: Does it still satisfy the monad laws?
12:11:00 <dgomez> hi, been trying to prep last night for today, been busy learning to fix all other aspects of my life too. I am not sure i know what I am mssing in terms of approaching how to learn haskell if I am reading the "books" online. what exercises should I be doing?
12:11:02 <dgomez>  I have attempted some problems and hope that I could get some help. I wasn't able to execute them properly in ghci
12:11:18 <vanila> I think it satisfies monad laws if "==" doesn't care about order of list elements
12:11:24 <dgomez> http://lpaste.net/117704
12:11:42 <Welkin> dgomez: start a project
12:11:46 <Welkin> make a web app or a game
12:11:51 <Welkin> you'll learn a lot very quickly
12:12:01 <Lokathor> dgomez: I'm also very new, but some of those type signatures look a little off
12:12:28 <dgomez> Welkin: I don't think that something I can just finish on my own.
12:12:29 <Welkin> there is also https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
12:12:40 <dgomez> I could definitely try to start it though...
12:12:42 <Welkin> that is the first project I did
12:12:47 <Welkin> it taught me a lot
12:13:19 <Welkin> start with a small project and work up to larger, more complex ones where you can incorporate more advanced concepts
12:13:21 <dgomez> Welkin: hmm thank you I'll take a look at it
12:13:41 <Welkin> it could be as simple as a text-based game of higher-lower
12:13:53 <Welkin> choose a random number within a range
12:13:57 <Welkin> and guess what it is
12:14:00 <Lokathor> dgomez: if that won't compile try taking away the type signatures and see what the compiler thinks the type of each expression is, and maybe you'll see where you went wrong
12:14:30 <dgomez> Welkin: I see. I do need to start working up. reading on the daily with small exercises isn't helping as much  don't think. case in point the exercises I posted
12:15:05 <Welkin> the only way to get comfortable is to work on real projects
12:15:13 <Welkin> not solving project euler exercises
12:15:27 <Lokathor> speaking of which...
12:15:36 <Welkin> you get good at those pretty fast and then there is nothing else to learn
12:15:58 <Lokathor> say you've got a complicated data object, such as a game state with enemies, level data, items, etc. what would be the "haskell way" to arrange such a large thing and interact with it?
12:16:03 <dgomez> Lokathor: for one of the exercises, using the function stutter, I did remove the type signatures before compiling. My error was "naked expression at top level" iirc
12:16:06 <Welkin> making games is a great way to move forward
12:16:09 <Welkin> as long as it is fun
12:16:39 <rofer> I was working on a Haskell game a few weeks ago. Definitely learned a lot from it.
12:17:06 <Rembane> Is there a nice Haskell library for manipulating pixels in realtime?
12:17:24 <Welkin> Rembane: OpenGL?
12:17:33 <Lokathor> dgomez: well, as an example, sample doesn't have type Int it has type [Int]
12:18:16 <dgomez> Welkin: I think that would be fun to try out. I'll look into the 48hr scheme first. And trying to rectify the problems in the current code i sent out.
12:18:32 <OutlawStar> how can i test for an empty map in a case of expression ie (case Map.filtewrWithKey ... of Map.empty -> ...) or is that even correct?
12:19:00 <HeladoDeBrownie> OutlawStar, you generally don't pattern match on Maps
12:19:10 <HeladoDeBrownie> actually i'm not sure you can (without extensions)
12:19:20 <OutlawStar> ok, but how can i test for results?
12:19:53 <Rembane> Welkin: Yes it's very competent, but not as easy to get started with just placing pixels as PyGame or Javascript.
12:19:56 <Lokathor> test for if it has the key you're looking for?
12:20:10 <OutlawStar> well any keys that meet the filter condition
12:20:35 <HeladoDeBrownie> OutlawStar, to test for an empty Map use null
12:20:45 <HeladoDeBrownie> if null myMap then … else …
12:21:11 <dgomez> Lokathor: I see, I tend to still make very dumb mistakes.
12:21:36 <HeladoDeBrownie> OutlawStar, oh, make sure you use Data.Map.null rather than Prelude.null. many of the names in Data.Map overlap with Prelude.
12:21:56 <HeladoDeBrownie> easy mistake to make, i make it often :P
12:23:09 <Lokathor> dgomez: it's fine that's what being a beginner is all about. Your other expressions should also have their types checked, because same3 also needs a differnt type signature, and i'm not sure what you're trying to do there
12:24:14 <OutlawStar> HeladoDeBrownie: thanks that worked
12:26:46 <dgomez> are there any people just beginning to learn haskell anywhere from sf to sj, CA?
12:27:11 <Lokathor> ID for me
12:29:16 <eyebloom> dgomez: check meetup.com
12:29:38 <eyebloom> most cities have haskell meetups.
12:29:53 <eyebloom> I know that’s not an exact solution to what you need.
12:31:42 <lesmon> « write a heuristic to have haskell meetups in your city. »
12:35:40 <hexagonest> hello I have a quick question
12:35:57 <vanila> hi
12:36:01 <srhb_> hexagonest: Ask. :)
12:36:40 <SrPx> could anyone recommend me a library for linear algebra with 3D vectors, quaternions and multiplication? About the one called "Vect", I couldn't find an operation to apply a quat to a vec3... did I miss it?
12:36:49 <hexagonest> for list comprehension, where do the variables come from and what do they mean. So if I type [x | x <- [1..5]] where does x come from, and what does <- mean?
12:36:59 <hexagonest> if i type it in ghci that is
12:37:07 <shachaf> x comes from [1..5]. <- means "comes from"
12:37:29 <vanila> its similar to when you make a function  f x = ... use x here ...
12:37:29 <hexagonest> but why does it come from 1..5
12:37:31 <shachaf> [x | x <- [1..5]] is the same as [y | y <- [1..5]]
12:37:44 <vanila> it introduces the name x to use in some scope
12:37:59 <hexagonest> does it set it to 1..5 automatically then?
12:38:20 <hexagonest> i thought <- meant "is part of"
12:38:25 <shachaf> x is 1, then 2, then 3, then 4, then 5
12:38:31 <shachaf> For appropriate values of "then".
12:38:43 <hexagonest> Oh, so it loops
12:38:45 <hexagonest> kinda?
12:38:48 <vanila> yes
12:38:50 <Lokathor> "kinda"
12:38:52 <hexagonest> sweet
12:38:56 <vanila> in list comprehension, x <- list means run through the elements of the list binding x to each one
12:39:04 <shachaf> hexagonest: Do you know map?
12:39:06 <n4x> hexagonest: do you know "map"?
12:39:11 <hexagonest> no i dont
12:39:17 <hexagonest> oh wait yes
12:39:30 <hexagonest> map goes through each of the list yes?
12:39:42 <hexagonest> like map +1 [1..5] would give [2,3,4,5,6]?
12:39:46 <n4x> yes
12:39:46 <shachaf> Do you know "map (\x -> x + 1) [1..5]"?
12:39:53 <shachaf> Where does x come from?
12:39:56 <vanila> map (+1) [1..5]
12:40:08 <hexagonest> I dont know that shachaf
12:40:19 <hexagonest> I am begginning to learn haskell. Thanks for all yourhelp guys
12:41:49 <pharpend> Hmm
12:41:54 <pharpend> So, interesting issue
12:42:01 <hexagonest> So can someone explain like im 5 why "[x*y | x <- [2,5,10], y <- [8,10,11]]" gives "[16,20,22,40,50,55,80,100,110]"
12:42:02 <pharpend> I'm trying to compile the source for my site
12:42:38 <pharpend> (in Hakyll)
12:42:44 <Lokathor> hexagonest: it goes through each possible x, and then each possible y for that, and then the result is all the results. Like a nested for loop in other languages
12:42:45 <pharpend> Here's the haskell script
12:42:48 <pharpend> http://lpaste.net/117705
12:43:09 <pharpend> The error is
12:43:11 <pharpend> site.hs:7:14:
12:43:12 <hpc> hexagonest: in plain english, your expression is "for each x in [2,5,10] and each y in [8,10,11], produce a list of x * y"
12:43:13 <pharpend>     Could not find module ‘Hakyll’
12:43:21 <hexagonest> WAIT. is what's on the left of the | what variable is being returned, so it loops through x and y and returns x*y?
12:43:44 <hpc> hexagonest: and the order it operates in is [x1 * y1, x1 * y2, x1 * y3, x2 * y1, ...]
12:43:50 <Lokathor> yes, the left of | is the result in the result list, and the right describes how to get the variables needed to make the left side
12:43:50 <hexagonest> Woohoo i get it
12:43:56 <hexagonest> Thanks everyone :)
12:44:08 <hexagonest> haskell is awesome
12:44:12 <absence> on reddit it was mentioned that free monads could be used to write endian-neutral binary.get instances how does that work? use an adt that represents the various binary operations with the free monad, and then "evaluate" it by matching the various adt operations, and either perform little endian or big endian version of each operation?
12:44:18 <srhb_> pharpend: How did you install Hakyll? cabal install hakyll?
12:44:23 <pharpend> srhb_: yes
12:44:32 <Lokathor> hexagonest: in this context the | can be pronounced as "with" when reading it out loud
12:44:46 <hexagonest> Oh sweet Lokathor.
12:44:53 <pharpend> hexagonest: Lokathor I usually think of it as "such that"
12:44:54 <hodapp> Hakyll?
12:44:55 * hodapp looks at this
12:44:56 <pharpend> (as we do in math)
12:45:13 <pharpend> hodapp: it's sort of like, er, what's the ruby thing the github pages people use
12:45:14 <hpc> hexagonest: you've barely even touched the awesome; you'll be revisiting list comprehensions eventually in a way that blows your mind
12:45:15 <hodapp> I am already familiar with Jekyll, and with Hyde, its Python cousin...
12:45:15 <srhb_> pharpend: "where" personally :-)
12:45:17 <pharpend> sort of like that, but it's haskell
12:45:21 <hodapp> pharpend: Jekyll is pretty nice
12:45:33 <hexagonest> I always just thought of it as a weird noise in my head. | makes "hmm" or something
12:45:49 <pharpend> hodapp: Hakyll uses Pandoc, which is its main attraction
12:45:54 <srhb_> x times y where x is drawn from ... and y is drawn from ...
12:45:57 <srhb_> Or something similar.
12:45:59 <Lokathor> pharpend: my calc professor always used "with", but he was a german native using english as a second  language so that might explain things
12:46:59 <hpc> a more common reading is "such that"
12:47:12 <pharpend> yayy hpc
12:47:25 <hpc> yay me?
12:47:26 <hpc> i mean...
12:47:28 <hpc> YAY ME!
12:47:33 <Lokathor> yay hpc!
12:47:36 <pharpend> hpc: I had said that earlier
12:47:42 <pharpend> hpc: the thing about such that
12:47:44 <hpc> oh, so you did
12:47:46 <Lokathor> it's true, he did
12:47:46 <pharpend> hpc: you were agreeing with me
12:47:51 <hpc> i forgot how fast this channel scrolls
12:48:00 <pharpend> hpc: or maybe you were copying me pretending to be me
12:48:07 <pharpend> hpc: Imposter!
12:48:11 <hpc> i am almost that clever
12:48:15 <wgreenberg> hi, I'm a little confused about the build-from-source process for haskell-platform. The README says I need a GHC bindist (installing now), haddock, cabal and hscolour. But I thought most of those were included in haskell-platform?
12:48:19 <hexagonest> sweet thanks guys i just wrote this [x*y | x <- [1,3,9], y <- [10,12,15], x*y < 50] and i understand it
12:49:02 <wgreenberg> basically me end goal is I'd like to have the entire haskell platform on my machine, but my apt repos don't carry it
12:49:15 <pharpend> wgreenberg: apt-get install ghc cabal-install
12:49:26 <pharpend> wgreenberg: cabal update; cabal install cabal-install alex happy hscolour
12:49:28 <pharpend> done
12:49:30 <Lokathor> can you add another repo that works with your linux?
12:49:31 <EvanR> what is this notation A⇉B
12:49:41 <wgreenberg> pharpend, my linux distro doesn't carry it
12:49:45 <pharpend> EvanR: it's apparently unicode, because my font is freaking out
12:49:48 <pharpend> wgreenberg: which distro
12:49:52 <Hijiri> A has a secret crush on B
12:50:03 <hpc> i tried to copy it out of my terminal and got "A?B"
12:50:16 <EvanR> A two arrows, one on top of the other, pointing right, B
12:50:19 <wgreenberg> pharpend, the one my company developed :P we've got our own debian repo which lacks haskell, so I'm forced to build haskell from source
12:50:24 <pharpend> EvanR: "A implies B"
12:50:28 <pharpend> wgreenberg: oh
12:50:36 <wgreenberg> Lokathor, not without some difficulty I'd imagine :(
12:50:41 <pharpend> wgreenberg: good luck then. I had to do that on Gentoo once. It was not fun
12:50:46 <wgreenberg> heh
12:50:47 <EvanR> not sure that makes sense
12:50:51 <aisqwe> I have associated a meaning like java 8 streams to Monads in my mind, is there anything that I'm missing out by this assumption?
12:51:03 <pharpend> EvanR: if A then B
12:51:08 <wgreenberg> I'll see where the README takes me
12:51:08 <wgreenberg> ty anyhow
12:51:15 <EvanR> A and B are objects and this expression is apparently talking about two morphisms
12:51:30 <hpc> aisqwe: quite a bit
12:51:54 <aisqwe> hpc: what is it exactly?
12:52:02 <hpc> java 8 streams don't seem to be very much like Monad at all
12:52:04 <Lokathor> aisqwe: a Java 8 stream, from what i've read, doesn't carry background data as much as it transforms data as you layer them. a monad carries some sort of background data
12:52:06 * EvanR is now interested in what java 8 streams are
12:52:24 <hpc> they seem to be just collections that you "don't have all of yet"
12:52:29 <pharpend> Apparently #hackage doesn't deal with hackage
12:52:43 <pharpend> the topic starts with
12:52:45 <pharpend> Issues with Hackage? #haskell-infrastructure
12:52:51 <Lokathor> ouch
12:53:16 <hpc> aisqwe: i would compare streams to haskell's []
12:53:26 <aisqwe> do you mean like if monads fail they will backtrack and return the failure?
12:53:35 <cosban> indeed
12:53:45 <EvanR> > fail
12:53:47 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
12:53:47 <lambdabot>    arising from a use of ‘M782024846638791726422197.show_M7820248466387917264...
12:53:47 <lambdabot>  The type variable ‘a0’ is ambiguous
12:53:48 <Lokathor> if a moand fails the failure is carried forward, yes
12:53:50 <EvanR> > fail "noooo"
12:53:52 <lambdabot>  No instance for (GHC.Show.Show (m0 a0))
12:53:52 <lambdabot>    arising from a use of ‘M463662307010211344622210.show_M4636623070102113446...
12:53:52 <lambdabot>  The type variables ‘m0’, ‘a0’ are ambiguous
12:54:04 <EvanR> > fail "noooo" :: [Int]
12:54:05 <aisqwe> then is it all that is to monads by this analogy?
12:54:06 <lambdabot>  []
12:54:23 <EvanR> dont think of fail as having much to do with monads
12:54:48 <Lokathor> well, "a value with a special context" is a very short summary of what a moand is... failure or not is one possible context
12:55:19 <EvanR> > Nothing >> Just 2 >> Just 3
12:55:21 <lambdabot>  Nothing
12:57:37 <EvanR> "context" is both too vague and not specific enough for some monads
12:57:57 <EvanR> Maybe and Either dont seem like context to me
12:58:01 <Lokathor> looking at oracle's tutorial, it seems like a java 8 stream is mostly what haskell considers to be normal function composition with the . operator
12:58:27 <SrPx> nobody? :(
12:59:01 <hodapp> Lokathor: but is it web-scale?
12:59:27 <aisqwe> Lokathor: so for example if you add the return functionality to java 8 streams is it considered a monad?
12:59:27 <EvanR> aisqwe: first understand polymorphic data types, then check out Functor instances, then check out either Applicative or Monad instances
12:59:28 <Lokathor> what does web scale mean?
13:00:27 <Lokathor> aisqwe: No, adding the bind and return operators to stream functionality wouldn't make it a monad just like that
13:01:13 <hodapp> Lokathor: web scale means... well, basically nothing.
13:01:30 <Lokathor> >_>
13:01:41 <hpc> it's a joke
13:01:52 <hpc> https://www.youtube.com/watch?v=b2F-DItXtZs
13:02:01 <EvanR> data Stream a = Stream a (Stream a) can be a monad but i doubt the result would be something java thinks is a good idea
13:02:02 <cosban> webscale is why I use mongoDB
13:02:05 <hpc> someone linked that video in -blah and it took off
13:02:12 <Lokathor> i see now
13:02:49 <aisqwe> EvanR: how did you do the "is now interested in ..." trick?
13:02:59 <aisqwe> EvanR: how did you do the "is now interested in ..." trick?
13:03:24 <EvanR> /me x y z w
13:03:50 <Lokathor> aisqwe: In the same way that a java interface has javadoc that declares laws about interface functions beyond just the type signature, monads also have to follow some rules beyond simply implementing the right functions to count as real monads
13:04:25 <hodapp> cosban: https://web.archive.org/web/20130510194721/http://browsertoolkit.com/fault-tolerance.png
13:04:46 <EvanR> you mean rules like Object BasicallyJustTheMethodsName(Object x, Object y)
13:04:54 <cosban> hodapp: +1
13:04:56 * hackagebot fixed-vector 0.7.0.1 - Generic vectors with statically known size.  http://hackage.haskell.org/package/fixed-vector-0.7.0.1 (AlexeyKhudyakov)
13:05:27 <hpc> hodapp: i don't even have to open that image to know what it is
13:05:28 <hpc> :D
13:06:02 <hodapp> hpc: :D
13:06:05 <hodapp> hpc: too bad the original seems to be down
13:08:21 <Lokathor> EvanR: Java has a *few* more rules than that :P
13:08:31 <EvanR> not many, ive seen so far
13:09:32 <et09> is ubuntu stuck on 1.16 for cabal
13:09:35 <et09> ubuntu 14.04
13:11:11 <absence> et09: http://packages.ubuntu.com/trusty/cabal-install
13:12:05 <et09> bleh
13:14:27 <absence> et09: i think ghc 7.8 came too late for the 14.04 release
13:14:56 <et09> that's odd because there doesn't seem to be really any haskell dependency through the whole repos
13:15:02 <et09> trying the hvr ppa
13:18:40 <brainacid> hey anyone on Arch?
13:20:05 <oleo> noah
13:20:09 <oleo> lol
13:20:45 <EvanR> does the natural number object in the category of sets automatically satisfy the peano axioms
13:21:57 <FreakyPenguin> Assuming I have a type `data m Foo = Foo (m Bar)', is there some way to provide an `m' so that I basically get `Foo Bar'?
13:22:00 <FreakyPenguin> I mean I can of course just use the identity functor/monad, but then I still have to wrap/unwrap. Any way to avoid that?
13:22:48 <vanila> no
13:23:55 <agibiansky> Perhaps if we had partially applied type families... Is there a fundamental reason why partially applied type families are not allowed?
13:24:07 <sbrg> brainacid: sure
13:24:31 <EvanR> you mean data Foo m = Foo (m Bar) ?
13:24:33 <brainacid> hello sbrg
13:24:45 <FreakyPenguin> EvanR: Yep, sorry
13:25:12 <vanila> they are basically combinators, if you can partially apply them you have a turing complete language
13:25:37 <EvanR> just use a totality check ;)
13:25:41 <vanila> that you must fully apply them makes sure they always terminate
13:25:50 <vanila> EvanR, Is there a way to do that?
13:26:34 <EvanR> use idris
13:26:45 <vanila> :/
13:27:06 <sbrg> brainacid: hey there
13:27:12 <sbrg> what did you need wrt arch?
13:27:24 <FreakyPenguin> vanila, EvanR: Thanks :)
13:27:39 <brainacid> sbrg, having fun installing it
13:27:51 <sbrg> arch linux?
13:28:02 <sbrg> or ghc on arch linux?
13:28:55 <srhb_> So, what might be causing this? http://lpaste.net/117706
13:29:45 <sbrg> srhb_: uh
13:29:48 <srhb_> I've never seen anything like this before.. :-)
13:29:53 <srhb_> Weird hardware error?
13:29:55 <sbrg> I first instinct is a harddrive failure?
13:29:57 * hackagebot network-bitcoin 1.7.0 - An interface to bitcoind.  http://hackage.haskell.org/package/network-bitcoin-1.7.0 (ClarkGaebel)
13:29:59 <sbrg> my*
13:30:00 <srhb_> Indeed..
13:30:02 <sbrg> but I'm not sure
13:30:04 <srhb_> Curious.
13:30:42 <wsirc_1953> hi guys
13:30:48 <wsirc_1953> hi guys
13:30:51 <wsirc_1953> hi guys
13:30:53 <Lokathor> hey
13:30:58 <vanila> hi :)
13:30:58 <wsirc_1953> hi guys
13:31:00 <srhb_> If I delete test.hs and cp test2.hs test.hs -- it fails again
13:31:00 <wsirc_1953> hi guys
13:31:00 <cosban> hey, listen
13:31:01 <brainacid> sbrg, lol had trouble typing your name
13:31:01 <wsirc_1953> hi guys
13:31:02 <srhb_> @ops
13:31:02 <lambdabot> Maybe you meant: pl oeis docs
13:31:04 <MisaMisa> oops
13:31:05 <srhb_> @where ops
13:31:05 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
13:31:05 <cosban> hi
13:31:12 <wsirc_1953> hi guys
13:31:15 <vanila> lol
13:31:15 <brainacid> im installing arch for the first time...didnt know about it
13:31:15 <wsirc_1953> dsaf
13:31:24 <vanila> wsirc_1953, he hear you !
13:31:33 <sbrg> brainacid: ah
13:31:40 <sbrg> probably offtopic for #haskell, though
13:31:43 <wsirc_1953> hi
13:31:48 --- mode: ChanServ set +oo dolio Cale
13:31:57 <brainacid> sbrg indeed it is
13:32:04 <brainacid> sorry to have bothered anyone
13:32:57 <dolio> wsirc_1953: Are you done making noise?
13:34:07 <Youpinadi> hi
13:34:15 <MisaMisa> anyone has experience manipulating raw data buffers (framebuffers in my case) through C FFI? how do you keep it efficient?
13:34:29 <sedcf> regarding cabal hell, i wonder if it were better to specify dependency on a hackage snapshot instead of individual packages and version constraints
13:34:57 * hackagebot fixed-vector 0.7.0.2 - Generic vectors with statically known size.  http://hackage.haskell.org/package/fixed-vector-0.7.0.2 (AlexeyKhudyakov)
13:35:18 <Youpinadi> hi
13:35:37 <srhb_> Even if I delete the file and create a new one, the name test.hs seems cursed. :|
13:35:40 <srhb_> So weird.
13:35:49 <Youpinadi> i'm a complete beginner and stuck, can somebody help?
13:35:54 <vanila> sure
13:35:55 <Lokathor> stuck on what?
13:35:55 <srhb_> Youpinadi: Sure, what's the problem?
13:36:25 <Youpinadi> trying to implement a startwith function
13:36:34 <Youpinadi> syntax issues :/
13:36:54 --- mode: ChanServ set -o dolio
13:36:59 <srhb_> Youpinadi: What's the issue?
13:37:09 <srhb_> Youpinadi: You can use lpaste.net if you need to paste the code and error.
13:37:09 <Youpinadi> https://www.dropbox.com/s/ybq5c43a1t3buf9/Screenshot%202015-01-03%2022.34.45.png?dl=0
13:37:16 <Youpinadi> ok
13:37:23 <sbrg> srhb_: I'm going to guess that it may depend on the filesystem implementation and possibly underlying hardware, but since not a lot of stuff has changed on your hard drive between renmaing/deleting the file, the file "test.hs" might be getting the same sector/whatever on the harddrive which is bad every time.
13:37:36 <srhb_> sbrg: Indeed. Hum...
13:37:57 <Youpinadi> http://lpaste.net/117707
13:38:02 <srhb_> sbrg: But it's odd that I can read the file just fine, isn't it.
13:38:16 <srhb_> Or maybe the problem is actually an intermediary file. I guess it is, since it's the linker.
13:38:34 <Lokathor> Youpinadi: i think your indentaiton is off?
13:38:35 <sbrg> srhb_: oh, that might be as well yes
13:38:37 <srhb_> Youpinadi: startswith needs to be aligned
13:38:58 <sbrg> srhb_: have you contacted your local catholic priest and performed an exorcism? your harddrive may be haunted
13:39:14 <srhb_> sbrg: We only have a single exorcist in Denmark, but I'll try to get a hold of him.
13:39:15 <Lokathor> Youpinadi: also the second line should probably be = False not : False
13:39:26 <sedcf> colon instead of equal on second line
13:39:51 <Youpinadi> thx guys!
13:40:26 <vanila> anyone know a good channel/forum/list for compilers, programming language design/development?
13:40:35 <Youpinadi> thx Lokathor it was th :
13:40:52 <Youpinadi> :)
13:40:55 <Youpinadi> :)
13:40:58 <sbrg> srhb_: hah, jamen dav.
13:41:02 <srhb_> sbrg: o/
13:42:41 <sbrg> srhb_: try strace on it
13:42:46 <sbrg> see what it gives you, where it fails etc
13:42:49 <srhb_> sbrg: Good call.
13:49:58 * hackagebot hlint 1.9.15 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9.15 (NeilMitchell)
13:51:51 <srhb_> Is it possible to make GHC dump the ld command? There's too much noice in a full ghc strace
13:52:41 <sbrg> I'd personally probably just write it all to file and then sort through it, but there might be a verbosity flag for ghc
13:53:15 <srhb_> Myeah..
13:55:35 <srbgh> maybe try grep?
13:56:39 <Lokathor> so what's the precedence of a function that isn't an operator?
13:57:11 <srhb_> Comparing the output from the failure to a working one makes it looks like it is some kind of futex error... So either a bug or more likely a memory error. But then, why should it persist for that same file. Hmm.
13:57:33 <hpc> Lokathor: you mean when you use backticks?
13:57:41 <hpc> iirc it's infix 5
13:57:48 <Lokathor> Write Yourself a Scheme in 48 Hours puts `elem` as prescendence 4, but I'm not sure if that's a special case because of the infix notation or if non-operator functions are always 4
13:58:34 <srbgh> srhb_: what does copying everything somewhere else do?
13:59:02 <srhb_> srbgh: Works fine then.
13:59:19 <srhb_> There's no obvious read error on the hard drive in strace, though.
13:59:29 <shachaf> Lokathor: The default precedence is "infixl 9", I think.
13:59:48 <shachaf> `elem` is "infix 4" -- not infixl or infixr
13:59:54 <shachaf> You can find out precedence using :i in ghci
14:00:50 <tasker> Is there a way I can create a type that applies only to a sub range of Int ? I presume a data definition and some constructors would be the way to go?
14:01:45 <srhb_> tasker: You'll have to use smart constructors for that. There's no subtyping.
14:01:53 <Lokathor> hmm, :i doesn't list a presednece for either map or `map`
14:02:10 <bitemyapp> Prelude> :info `elem`
14:02:10 <bitemyapp> elem :: Eq a => a -> [a] -> Bool 	-- Defined in ‘GHC.List’
14:02:10 <bitemyapp> infix 4 `elem`
14:02:11 <shachaf> So it's the default.
14:02:45 <Lokathor> is the default 9?
14:03:25 <tasker> srhb_: What exactly do smart constructors entail ?
14:03:31 <Lokathor> tasker: by sub range do you mean less bits? because there's Int8 if that's what you want
14:04:01 <srbgh> take: what you were describing
14:04:02 <tasker> Lokathor: I mean, I need to constrain it to a range of Int, that correspond to some coordinates.
14:04:14 <srbgh> er, tasker
14:04:16 <srhb_> tasker: data MyInt = MyInt Int -- then you don't export MyInt but instead create smart functions that can create these values using your constraints
14:04:30 <srhb_> MyInt the value constructor, that is
14:04:36 <tasker> srhb_: Right, that is what I had in mind.
14:07:21 <liyang> Lokathor: https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-820061 --just above the table
14:09:51 <Lokathor> okay cool
14:12:03 <t4nk928> hello all, uvector package is deprecated and vector is the one to use now. Stream fusion optimizations are available for all data.vector.* or just for unboxed?
14:14:58 * hackagebot fixed-vector 0.7.0.3 - Generic vectors with statically known size.  http://hackage.haskell.org/package/fixed-vector-0.7.0.3 (AlexeyKhudyakov)
14:15:35 <EvanR> a subtype can be emulated similarly, if you want A to be a subtype of B, implement A as a function A -> B which converts the subtype value to the supertype value in a way to satisfies the subsitutability criteria. for functions that use a B ...
14:15:50 <EvanR> instead take a typeclass constrained parameter which means "converts to B"
14:16:23 <EvanR> if Word8 is a subtype of Word16 in your system, then the conversion function is just fromIntegral
14:17:00 <EvanR> except that its not, because Word8 and Word16 dont act the same way at all
14:17:11 <EvanR> so bad example
14:19:16 <Welkin> > succ $ maxBound Word8
14:19:17 <lambdabot>  Not in scope: data constructor ‘Word8’
14:19:17 <lambdabot>  Perhaps you meant ‘Word’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
14:19:23 <Welkin> > succ $ maxBound Data.ByteString.Word8
14:19:25 <lambdabot>  Not in scope: data constructor ‘Data.ByteString.Word8’
14:19:36 <Welkin> > succ $ maxBound Data.ByteString.Lazy.Word8
14:19:37 <lambdabot>  Not in scope: data constructor ‘Data.ByteString.Lazy.Word8’
14:19:41 <srhb_> Well, I've posted my question to Reddit if anyone has any insight. :-) http://www.reddit.com/r/haskell/comments/2r8psi/curious_linking_error/
14:19:49 <Clint> > succ $ maxBound :: Word8
14:19:51 <lambdabot>  *Exception: Enum.succ{Word8}: tried to take `succ' of maxBound
14:19:59 * hackagebot fixed-vector-hetero 0.3.0.0 - Generic heterogeneous vectors  http://hackage.haskell.org/package/fixed-vector-hetero-0.3.0.0 (AlexeyKhudyakov)
14:20:31 <Welkin> :t maxBound
14:20:32 <lambdabot> Bounded a => a
14:20:34 <Welkin> ah yes
14:20:37 <pavonia> > (maxBound :: Word8) + 1
14:20:38 <lambdabot>  0
14:20:55 <EvanR> > 255 + 1 :: Word8
14:20:56 <lambdabot>  0
14:20:58 <EvanR> > 255 + 1 :: Word16
14:20:59 <lambdabot>  256
14:21:30 <Welkin> > succ 255 :: Word8
14:21:31 <lambdabot>  *Exception: Enum.succ{Word8}: tried to take `succ' of maxBound
14:21:44 <Welkin> > succ 255 + 1) :: Word8
14:21:45 <lambdabot>  <hint>:1:13: parse error on input ‘)’
14:21:47 <Welkin> > succ (255 + 1) :: Word8
14:21:48 <lambdabot>  1
14:22:06 <EvanR> a better example would be nonempty lists <: regular lists. you can define a mapping from non-empty lists to lists such that all the list operations on the image still make sense
14:26:06 <SrPx> is there any way to force GHC to consider a numeric literal is a specific type when it can't infer ?
14:26:13 <srhb_> 1 :: Int
14:26:21 <srhb_> Oh, you mean change the defaulting rules?
14:28:20 <Welkin> 1 defaults to Integer
14:28:25 <Welkin> 1.0 would default to Double I believe
14:28:59 <Welkin> :t 1.0
14:29:00 <lambdabot> Fractional a => a
14:29:04 <Welkin> :t 1.0 + 2.0
14:29:05 <lambdabot> Fractional a => a
14:29:24 <haasn> SrPx: A type signature is the only correct way to “force” something to have some type.
14:29:42 <SrPx> okay thanks
14:29:44 <Welkin> :t (^)
14:29:45 <lambdabot> (Num a, Integral b) => a -> b -> a
14:29:48 <Welkin> :t (^^)
14:29:49 <lambdabot> (Integral b, Fractional a) => a -> b -> a
14:29:51 <Welkin> :t (**)
14:29:52 <lambdabot> Floating a => a -> a -> a
14:29:53 <haasn> You can change the defaulting rules, but I don't think that's relevant (because if something was defaulted, that means GHC can infer the type)
14:30:33 <SrPx> would be nice to have a numeric literal for floating point numbers, I guess.. but okay
14:30:38 <SrPx> maybe not
14:30:55 <srhb_> Huh? Like 1.3?
14:31:25 <SrPx> I mean a literal specifically for the Float type, like 1.3f
14:31:33 <srhb_> I see.
14:31:35 <Welkin> 1.3 :: Float
14:31:48 <SrPx> yes I see the point I'm not complaining ^^
14:31:57 <Welkin> as far as I know, Floats are slow in haskell compared to Double
14:32:00 <srhb_> You COULD use default (Float) if all you did in a module was use Float.
14:32:15 <SrPx> I didn't know that, thanks for alerting me
14:32:24 <SrPx> warning me? I don't know what is the right word
14:32:59 <ReinH> Welkin: No, float is single precision. It is usually faster but not significantly so for most applications
14:33:00 <EvanR> if you have Float in some of your type signatures, 1.3 would be a float
14:33:13 <Welkin> supposedly a lot of work has gone into optimizing operations on Double, but not much on Float
14:33:22 <Welkin> at least, that is what I read concerning GHC
14:33:27 <haasn> Welkin: Source?
14:33:31 <SrPx> nice to know about default, too, but if it is a bad practice I will avoid
14:33:36 <ReinH> https://www.haskell.org/haskellwiki/Performance/Floating_point
14:33:36 <Welkin> I don't have it on hand
14:33:39 <EvanR> Double is ridiculously overpowered for audio synthesis stuff
14:34:40 <EvanR> and since backends want 32bit-float, converting from Double, no matter how fast they are, would be silly
14:35:04 <ReinH> Welkin is incorrect
14:35:27 <ReinH> At best, double will have equivalent performance
14:35:38 <breadmonster> Hey guys!
14:35:56 <breadmonster> Umm, I'm having a slight issue. I'm TOTALLY new to programming, and I've been reading LYAH.
14:36:12 <breadmonster> Any ideas for some small Haskell projects?
14:36:50 <SrPx> gtg thanks ! :)
14:37:08 <Welkin> breadmonster: write a text-based game
14:37:23 <breadmonster> Welkin, What's that?
14:37:32 <SrPx> Welkin: I was going to say that. breadmonster if you are into RPGs that might be a fun experience
14:37:33 <SrPx> see you
14:37:34 <Welkin> a game you play in the terminal
14:38:37 <Welkin> "Guess the number" is a good start
14:38:47 <breadmonster> Is there a library with which I can tell what keyboard key is pressed?
14:38:50 <EvanR> one player turn based mud ;)
14:38:50 <Welkin> you can use the Random module to generate a random value within a given range
14:38:52 <breadmonster> That would make things a lot easire.
14:38:53 <Welkin> then you guess the number
14:39:03 <Welkin> and the game tells you "Higher" or "Lower" until you get it
14:39:06 <raichoo> Hi, I'm observing a rather curious behaviour with the FFI http://lpaste.net/117709 sleep only seems to have an effect after some time in the given example the program just prints "got 25" a couple of time and exits, no sleep there.
14:39:32 <Welkin> breadmonster: that is not necessary for a text-based game
14:39:34 <raichoo> If I pass 100 to block the effect happens after a couple of iterations.
14:39:39 <Welkin> all you do is send text to the program directly
14:40:20 <Welkin> capturing keyboard input is more complicated and requires something like SDL, which you should not use until you are comfortable with the language itself
14:40:37 <acidjnk> Welkin from The Old Republic?
14:40:45 <Welkin> ?
14:40:53 <Welkin> Simple DirectMedia Layer
14:41:04 <hpc> breadmonster: you could write an rss reader
14:41:26 <hpc> it doesn't have to be a good one, but it'll introduce the basics of a lot of network-related stuff
14:41:50 <breadmonster> hpc: okay, that's a great idea.
14:41:57 <breadmonster> Any modules I should look at?
14:42:32 <hpc> there's a lot for parsing xml, which you might want for the rss format itself
14:42:56 <hpc> as well as an http library
14:43:06 <hpc> i like http-client, but there's many
14:43:11 <breadmonster> hpc, and how long should this project take me?
14:43:32 <hpc> depends
14:43:49 <hpc> it could be a day if you make it as basic as possible
14:44:08 <hpc> or you can do your own http, make a nice output window, make it handle malformed rss, etc
14:44:35 <breadmonster> hpc, Yeah, that sounds like a really good project.
14:44:41 <breadmonster> Welkin, thanks a lot as well.
14:45:22 <Welkin> breadmonster: this may also be helpful https://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
14:45:44 <Welkin> it is outdated, but it's a good place to start
14:45:46 <pavonia> breadmonster: For learning purposes it probably more important to get it done at all than to do it quickly
14:45:49 <breadmonster> Welkin, Okay, perfect, I'll have a look at that.
14:49:06 <EvanR> keyboard / mouse inputs plus basic graphics is pretty easy with glfw-b and drawing-combinators
14:49:14 <EvanR> (if that still works)
14:49:39 <Lokathor> I've heard that gtk is a good graphics library for haskell, is that accurate?
14:50:07 <EvanR> gtk is a toolkit for desktop app
14:50:14 <EvanR> so more than just graphics
14:51:00 <MisaMisa> you might want to take a look at something like sdl2
14:51:18 <breadmonster> Okay, cool, thanks guys!
14:51:19 <Lokathor> er, yeah, GUI i meant, not raw graphical rendering
14:53:22 <octopuscabbage> is there a constant in ghc which is the "maximum" number (something like an inf) for algorithms that need to find a minimum number (such as djikstras (spelling lol))
14:53:56 <EvanR> maxBound ?
14:53:56 <Lokathor> maxBound might be what you want
14:54:03 <octopuscabbage> i'll look into that
14:54:43 <EvanR> for types that dont have a Bounded instance, you can add one. for types that dont make sense for Bounded, you can make sum type that adds an "artificial" upper bound
14:55:43 <octopuscabbage> that'll be fine enough for my use case
14:55:53 <Lokathor> note that maxBound isn't a constant exactly. It changes depending on the type you use it with
14:56:25 <Iceland_jack> '{min,max}Bound' are polymorphic constants
14:56:35 <breadmonster> > True > False
14:56:36 <lambdabot>  True
14:56:41 <breadmonster> That's interesting.
14:56:45 <breadmonster> > True + True
14:56:46 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Bool)
14:56:47 <lambdabot>    arising from a use of ‘GHC.Num.+’
14:56:51 <Iceland_jack> @src Bool
14:56:51 <lambdabot> data Bool = False | True deriving (Eq, Ord)
14:57:23 <breadmonster> @src length
14:57:23 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:57:34 <breadmonster> @src Prelude.length
14:57:34 <lambdabot> Source not found. My brain just exploded
14:57:39 <breadmonster> @src Data.Base.length
14:57:40 <lambdabot> Source not found.
14:57:42 <EvanR> False + True -> True. True + True -> 2. ;)
14:57:44 <breadmonster> That's interestting.
14:59:12 <Welkin> is that erlang?
14:59:25 <EvanR> i hope not
14:59:35 <Welkin> what's with the periods?
14:59:47 <EvanR> not haskell
15:01:47 <Lokathor> alright I asked earlier but didn't get an answer: if you have a very complex pile of data (using Nethack as an example: dungeon layouts, enemy info, item info, etc) how does one normally organize it in a "haskell" way?
15:02:22 <Welkin> Item.hs Enemy.hs Dungeon.hs Types.hs
15:02:31 <octopuscabbage> Do you mean in src or in structure
15:02:38 <Lokathor> structure
15:02:52 <octopuscabbage> in structure (unfortunately) usually i've seen it as one big record
15:02:53 <EvanR> a database
15:03:01 <Lokathor> do you try to use one large data value and then access down into what you need, or juggle it all separately, or what?
15:03:02 <octopuscabbage> which keeps the smaller structures as members
15:03:08 <octopuscabbage> kind of a heirarchal record
15:03:34 <EvanR> Lokathor: you dont have to, and if you did youd probably find it hard to manage
15:03:58 <EvanR> keep it flatter
15:04:11 <Lokathor> hmm, could you give an example of your database idea?
15:04:20 <EvanR> indexed sets
15:04:35 <EvanR> you can have many indexes into the same set or sets
15:04:42 <EvanR> to facilitate different views of the data
15:05:28 <Lokathor> hmm
15:06:00 <EvanR> enemy positions for instance, youd want to lookup enemies by their position or a range of positions (spatial index)
15:06:44 <EvanR> enemy hit points youd probably want to index by their id or ids
15:07:17 <Lokathor> So... you'd keep it in a Data.Set?
15:07:29 <EvanR> the package ixset has a structure for defining an arbitrary number of indexes on a set
15:07:57 <EvanR> but i dont think id have one set
15:08:10 <Lokathor> I don't mean to be dense but basically I understand how to write nethack in C/Java/Python, and I'm totally lost imagining how you'd do it in Haskell is all.
15:08:19 <EvanR> think of a database, you dont keep everything in one table
15:08:58 <EvanR> in C, you would have everything in a big tree and search it every time?
15:09:00 <octopuscabbage> Lokathor the "easy" way is to have a record with all of the stuff (tiles, enemy records, hero record) and just apply a "turn" function to that record until something happens
15:09:12 <octopuscabbage> i.e. player wins or dies
15:10:11 <EvanR> "hero record" is a bad idea for example, im assuming this means all his held items and stats are recorded in here
15:10:25 <EvanR> when enemies have the same needs
15:10:53 <octopuscabbage> EvanR, Not necessarily, it could contain things like health, hungriness, but his inventory could be another structure
15:11:00 <EvanR> also, items may be held or on the floor, but you still will want to access items uniformly
15:11:05 <Lokathor> ha, well, in C you just have a pile of global variables all over the floor that you pick up and put down like you need, but in java/python/c++ you'd keep an object which holds other objects and so on. Which i'm less clear on how to do effectively in haskell's type system
15:11:14 <EvanR> right, splitting all these into different structures is what im suggesting
15:11:17 <EvanR> not just the inventory
15:11:50 <octopuscabbage> Lokathor Instead of a big object with variables and methods just use a record which has functions which accept it
15:12:01 <EvanR> Lokathor: what youre saying about global variables, if i understand right, is more along the lines of what im saying, though not necessarily "global"
15:12:11 <srhb_> raichoo: http://stackoverflow.com/questions/15226806/importing-c-delay-function-into-haskell-using-ffi -- maybe this is relevant
15:12:42 <EvanR> the java python c++ way has serious problems at some scale
15:12:44 <raichoo> srhb_: Thanks, I already got some help in #ghc but I will certainly read that. :)
15:13:11 <srhb_> Oh, I'd love to read that. Is there a #ghc log somewhere?
15:15:07 <srhb_> Found it.
15:15:54 <raichoo> srhb_: Ok :)
15:16:07 <srhb_> But yes, as expected, interrupts. :)
15:20:01 * hackagebot hspec-snap 0.3.2.2 - A library for testing with Hspec and the Snap Web Framework  http://hackage.haskell.org/package/hspec-snap-0.3.2.2 (DanielPatterson)
15:23:46 <EvanR> Lokathor: heres my idea for a nethack game (which has no output except for graphics, once per turn) http://lpaste.net/117710
15:25:16 <Lokathor> hmmm, so ObjID would be shared across all data types? That is, if a creature was ObjID 1 then an item couldn't also be ObjID 1?
15:25:26 <Lokathor> seems simple enough when you put it that way I guess
15:25:31 <EvanR> well, across whatever things tend to move around and be stored inside each other
15:25:41 <EvanR> which is not the dungeon
15:26:05 <EvanR> yeah 1 means 1
15:26:28 <EvanR> through bugs (or features!) you may confuse the functionality of enemies and items this way
15:26:37 <Lokathor> Why does Dungeon have [Level] Level [Level]
15:26:51 <EvanR> so you zipper down into the dungeon and come back
15:26:53 <mauke> looks like a zipper
15:27:00 <Lokathor> oh oh
15:27:09 <Lokathor> i read about those yesterday, seemed handy
15:28:07 <Lokathor> also, confusing items and creatures via over generalization would totally be the nethack thing to do in any sitaution :D
15:28:17 <EvanR> right
15:31:21 <EvanR> Lokathor: i added the forward index for object positions, and a "player is object id foo",  so you can get the players position to do rules, and switch who the player controls ;)
15:31:34 <EvanR> etc
15:32:49 <EvanR> to get new ids youd need a generator
15:43:35 <Lokathor> all seems workable.
15:43:57 <Lokathor> you could even make the input and display swappable as well
15:44:57 <hop_> Hello all, where is defined foldM' ?
15:45:26 <Feuerbach> hop_: I haven't seen it defined anywhere in the standard libraries
15:45:53 <hop_> Feuerbach: from here: http://lambda.jstolarek.com/2013/04/haskell-as-fast-as-c-a-case-study/
15:46:01 <hop_> It compiles for me
15:46:18 <Feuerbach> @hoogle foldM'
15:46:21 <lambdabot> No results found
15:46:22 <hop_> I was just trying to locate it. I am just looking with ghci
15:46:32 <Feuerbach> hop_: what does :i tell you?
15:46:39 <hop_> one sec :-)
15:47:12 <hop_> I have the type
15:47:24 <hop_> Do you know how to ask to get the definition location?
15:47:46 <Feuerbach> :i
15:48:00 <hop_> looks like it is coming from data.vector.unboxed somehow but it is not documented
15:48:18 <hop_> yes, data.vector.unboxed
15:49:29 <EvanR> Lokathor: heh. obviously the depths of the dungeon could be infinite, if they were procedurally generated. but also, you could make it infinite in both directions. down is earth, up is heaven (perhaps you cant go up until after some event)
15:49:47 <EvanR> also theres #haskell-game
15:50:43 <princearthur> Can anyone help me? I'm very much a beginner, so pardon me.
15:51:06 <princearthur> I just can't seem to get a function given in LYAGG to work
15:51:24 <princearthur> it is the calcbmi function
15:51:40 <Iceland_jack> princearthur: Paste your code here:
15:51:41 <Iceland_jack> @where lpaste
15:51:41 <lambdabot> http://lpaste.net/
15:52:19 <lpaste> princearthur pasted “bmi” at http://lpaste.net/117712
15:52:43 <hop_> Feuerback: Why is it not documented in Hoogle? I can see the hoogle comments in vector source code but Hoogle reports nothing as you said
15:52:56 <hop_> Feuerbach: Why is it not documented in Hoogle? I can see the hoogle comments in vector source code but Hoogle reports nothing as you said
15:52:59 <princearthur> the input is something like "[(80, 190)]
15:53:05 <Iceland_jack> princearthur: It works here if you don't indent it
15:53:16 <Iceland_jack> ghci> calcBmis [(80, 190)]
15:53:16 <Iceland_jack> [2.21606648199446e-3]
15:53:34 <Iceland_jack> Or rather, doesn't fail
15:53:51 <princearthur> yeah that's what i get back
15:54:16 <Iceland_jack> It's the same as:
15:54:17 <Iceland_jack> > 80 / 190^2
15:54:18 <lambdabot>  2.21606648199446e-3
15:55:00 <princearthur> maybe 1.9 then
15:55:02 * hackagebot eventstore 0.5.0.0 - EventStore TCP Client  http://hackage.haskell.org/package/eventstore-0.5.0.0 (YorickLaupa)
15:55:19 <Iceland_jack> ghci> calcBmis [(80, 1.9)]
15:55:19 <Iceland_jack> [22.1606648199446]
15:56:13 <princearthur> ah yeah, thanks!
15:56:15 <princearthur> :)
15:57:03 <Iceland_jack> No prob
15:57:24 <Yawar> Lokathor: this article may be useful: http://www.gamedev.net/page/resources/_/technical/game-programming/haskell-game-object-design-or-how-functions-can-get-you-apples-r3204
15:58:00 <Lokathor> I will read this indeed
15:58:16 <Lokathor> but first i will ask: is it even possible to build the cabal unix package on a windows machine?
15:58:26 <hpc> no
15:58:27 <gamegoblin> @pl \(a,b) -> (a+1,b+2)
15:58:27 <lambdabot> (1 +) *** (2 +)
15:58:30 <hpc> it's the unix package ;)
15:59:12 <Lokathor> i tried through cygwin as well. I guess that means there's no haskell curses programs on windows?
16:00:56 <EvanR> curses on windows
16:01:15 <nuser> :t map compare 20
16:01:16 <hpc> a curse on your windows!
16:01:16 <lambdabot> (Ord a, Num [a]) => [a -> Ordering]
16:01:29 <Iceland_jack> :t map (compare 20)
16:01:29 <lambdabot> (Ord a, Num a) => [a] -> [Ordering]
16:01:36 <Iceland_jack> > map (compare 20) [1,4,20,25]
16:01:37 <lambdabot>  [GT,GT,EQ,LT]
16:01:47 <nuser> Thanks Iceland_jack
16:02:11 <nuser> but what does [a -> Ordering] really mean?
16:02:17 <Iceland_jack> It means a list of functions
16:02:27 <nuser> ahhhhhh
16:02:36 <Iceland_jack> But what you got is definitely not what you want
16:02:42 <Iceland_jack> since it also means that the list has to be a number
16:02:55 <Iceland_jack> (that's the “Num [a]” constraint)
16:02:57 <bryanedds> Cale, you still about?
16:03:00 <nuser> You right about the correction, but I felt if there was a type it probably did something
16:03:02 <Welkin> > runState get 9
16:03:04 <lambdabot>  (9,9)
16:03:19 <bryanedds> Cale: I mean
16:03:20 <Welkin> > runState (return 1) 9
16:03:23 <lambdabot>  (1,9)
16:03:31 <Iceland_jack> Something like this won't type check nuser:
16:03:31 <Iceland_jack> :t map compare (20 :: Int)
16:03:32 <lambdabot>     Couldn't match expected type ‘[a]’ with actual type ‘Int’
16:03:32 <lambdabot>     In the second argument of ‘map’, namely ‘(20 :: Int)’
16:03:32 <lambdabot>     In the expression: map compare (20 :: Int)
16:03:41 <Iceland_jack> 'map f xs' means that 'xs' *must* be a list
16:03:55 <nuser> yes
16:04:08 <Iceland_jack> So GHC saw the '20' you wrote earlier and thought "huh that's an odd list, but I guess I'll go along with it"
16:04:45 <nuser> thanks it's clear now
16:05:50 <Iceland_jack> GHC doesn't actually place value judgments on your code though
16:06:17 <Iceland_jack> You can define '20' to be a list
16:06:33 <EvanR> :t '20'
16:06:34 <lambdabot> parse error on input ‘20’
16:06:54 <tsani> > let 20 = [1,2,3,4] in 20
16:06:55 <lambdabot>  Could not deduce (GHC.Num.Num [t0]) arising from the literal ‘20’
16:06:55 <lambdabot>  from the context (GHC.Num.Num a)
16:06:55 <lambdabot>    bound by the inferred type of it :: GHC.Num.Num a => a at Top level
16:07:27 <Iceland_jack> *You can write a Num instance for lists of numbers, you pedants :-)
16:07:29 <EvanR> instance Num [Int] of
16:07:31 <tsani> ;)
16:07:51 <EvanR> instance Num a => [a] of
16:08:06 <EvanR> instance Num a => Num [a] of
16:08:50 <tsani> Is that actually okay without FlexibleInstances ?
16:09:02 <EvanR> guess not
16:09:54 <nuser> i'm green with envy at what you guys know
16:10:12 <Hijiri> @define instance Num a => Num [a] where {fromInteger = pure . fromInteger; (+) = liftA2 (+); (*) = liftA2 (*); negate = fmap negate; signum = fmap signum}
16:10:13 <lambdabot>  .L.hs:154:10: Warning:
16:10:13 <lambdabot>      No explicit implementation for
16:10:13 <lambdabot>        ‘abs’
16:10:23 <Hijiri> 6 :: [Int[
16:10:26 <Hijiri> > 6 :: [Int]
16:10:28 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Int])
16:10:28 <lambdabot>    arising from the literal ‘6’
16:10:45 <Hijiri> > 6 :: [Integer]
16:10:46 <lambdabot>  No instance for (GHC.Num.Num [GHC.Integer.Type.Integer])
16:10:46 <lambdabot>    arising from the literal ‘6’
16:10:57 <EvanR> let the weird ass instances begin
16:11:07 <Hijiri> did it fail because of the warning?
16:11:11 <Iceland_jack> nuser: Channel it into motivation to learn more!
16:11:15 <Hijiri> @define instance Num a => Num [a] where {fromInteger = pure . fromInteger; (+) = liftA2 (+); (*) = liftA2 (*); negate = fmap negate; signum = fmap signum; abs = fmap abs}
16:11:17 <lambdabot>  Defined.
16:11:25 <Hijiri> > 5 :: [Int]
16:11:26 <lambdabot>  [5]
16:11:45 <Hijiri> [1,2,3,4,5] + [1,1,2,3,5,7,11]
16:11:50 <Hijiri> > [1,2,3,4,5] + [1,1,2,3,5,7,11]
16:11:52 <lambdabot>  [2,2,3,4,6,8,12,3,3,4,5,7,9,13,4,4,5,6,8,10,14,5,5,6,7,9,11,15,6,6,7,8,10,12...
16:11:52 <EvanR> i was thinking 20 :: [Int] would be [2, 0] ;)
16:12:50 <bryanedds> Could someone show me how to write 'update' using the do syntax for this monad? - http://lpaste.net/117689
16:13:15 <Iceland_jack>     instance IsString [Int] where
16:13:15 <Iceland_jack>       fromString :: String -> [Int]
16:13:15 <Iceland_jack>       fromString = map digitToInt . show
16:13:22 <nuser> Iceland_jack: I am, maybe I'm not fast enough :(
16:13:24 <Iceland_jack> without the '. show' gets you close
16:14:11 <Iceland_jack> Fast enough for what?
16:14:20 <dmwit> bryanedds: What is 'update'?
16:14:38 <nuser> as I'd like
16:15:05 <Iceland_jack> What are you comparing your progress too?
16:15:08 <Iceland_jack> *to
16:15:21 <bryanedds> basically, it pulls out state, transforms it, then puts it back
16:15:40 <nuser> good question.  Anyone that wows me with their knowledge
16:15:45 <dmwit> Can you show me how to write update without using do syntax?
16:16:02 <Iceland_jack> If you only compare yourself to the best in the world and don't appreciate the progress you've made
16:16:15 <bryanedds> I'll try
16:16:38 <Iceland_jack> Then don't get surprised if you're left with a feeling of dissatisfaction
16:16:45 <bryanedds> let update expr = Desync (\ s w d -> d (expr s) ())
16:16:50 <bryanedds> I think that's it
16:17:01 <dmwit> Why do you want to use do syntax?
16:17:16 <bryanedds> it will help me to understand how to use the syntax elsewhere
16:17:17 <dmwit> There's no Monad operations in that code.
16:17:21 <nuser> I have moments when I appreciate how far I've come.
16:17:36 <nuser> agree with your point too
16:18:03 <Iceland_jack> Don't get me wrong, there is nothing wrong with lofty goals
16:18:05 <bryanedds> what code?
16:18:30 <nuser> oh I know what you mean. You just don't want me to be down on myself :)
16:18:32 <dmwit> bryanedds: "let update expr = Desync (\s w d -> d (expr s) ())" <- this code uses no Monad methods
16:18:42 <nuser> and stop improving ...
16:18:51 <Iceland_jack> Yes :)
16:18:53 <dmwit> bryanedds: Therefore, using do syntax with it will not really help you understand how to use do syntax elsewhere.
16:19:09 <bryanedds> hmm, I probably am asking for the wrong thing
16:19:20 <dmwit> I believe so, yes.
16:19:28 <bryanedds> so, how can I get the current state with the do syntax?
16:19:41 <bryanedds> I have get defined as -
16:19:59 <bryanedds> let get = Desync (\s w d -> d s s)
16:20:31 <bryanedds> set is -
16:20:39 <dmwit> do { s <- get; {- do something with s here -} }
16:20:44 <bryanedds> let set = Desync (\_ w d -> d s ())
16:20:59 <bryanedds> so could I do this -
16:21:46 <bryanedds> do { s <- get; let s' = s + 1; set s' }
16:22:09 <dmwit> For questions of the form "Does this code work?", you might as well ask the compiler.
16:22:30 <bryanedds> I'm not using Haskell
16:22:52 <bryanedds> hmm... I guess I could use it
16:23:09 <EvanR> you should probably use haskell
16:23:10 <dmwit> If you're not using Haskell, then your questions are off-topic for this channel...
16:24:04 <bryanedds> depends on who you ask
16:24:43 <bryanedds> *digs out leksah*
16:25:01 <Welkin> I don't understand the implementation of get
16:25:03 * hackagebot caramia 0.7.0.0 - High-level OpenGL bindings  http://hackage.haskell.org/package/caramia-0.7.0.0 (Adeon)
16:25:05 * hackagebot caramia 0.7.0.1 - High-level OpenGL bindings  http://hackage.haskell.org/package/caramia-0.7.0.1 (Adeon)
16:25:14 <Welkin> get = state $ \s -> (s,s)
16:25:23 <Welkin> so the state must be the same type as the result?
16:25:29 <dmwit> For sure.
16:25:31 <Welkin> that's not right
16:25:46 <geekosaur> Welkin, it's producing the state value, of course that will have the same type as the state value
16:25:47 <dmwit> You're asking "What's the current state?".
16:25:49 <Welkin> I know State Int Char works
16:25:54 <dmwit> Don't you expect to get something as the same type as the current state?
16:26:06 <dmwit> Welkin: "get" is certainly not the *only* operation offered by State.
16:26:33 <Welkin> so you cannot use get with State Int Char ?
16:26:43 <geekosaur> ?
16:26:44 <dmwit> No, get does not have type State Int Char.
16:26:57 <Welkin> get :: m s
16:27:04 <Welkin> I know that
16:27:06 <dmwit> No, get :: MonadState s m => m s
16:27:14 <Welkin> but when you have an initial state that is State Int Char
16:27:16 <Iceland_jack> :t get :: State s s
16:27:17 <lambdabot> State s s
16:27:29 <n4x> @type fmap show get
16:27:30 <lambdabot> (MonadState a f, Show a, Functor f) => f String
16:27:40 <Iceland_jack> :t gets intToDigit :: State Int Char
16:27:41 <lambdabot> State Int Char
16:27:46 <dmwit> Welkin: It would be very unusual to have an initial state of type State Int Char. I suspect you are confused about something fundamental here, but I'm not sure exactly what.
16:28:07 <ReinH> :t read . show :: Int
16:28:08 <lambdabot>     Couldn't match expected type ‘Int’ with actual type ‘a0 -> c0’
16:28:09 <lambdabot>     In the expression: read . show :: Int
16:28:11 <Welkin> I am asking about having a result type different than the state type
16:28:17 <ReinH> :t (read . show) :: Int
16:28:18 <lambdabot>     Couldn't match expected type ‘Int’ with actual type ‘a0 -> c0’
16:28:18 <lambdabot>     In the expression: (read . show) :: Int
16:28:28 <Welkin> \s -> (a,s) with a not the same as s
16:28:42 <dmwit> Welkin: Okay. But what's your question?
16:29:01 <Welkin> how does that work with get
16:29:06 <ReinH> Welkin: how can read . show be of type Int -> Int if show is of type Int -> String?
16:29:11 <geekosaur> a is an intermediate value; its type can change, else State would be kinda useless. for the specific case of get, a is the same as s. you generally would use that in an expression whose type has a different a
16:29:11 <dmwit> Welkin: That isn't get.
16:29:40 <shachaf> dmwit: Obviously I want a dependent state monad, where I can change the state as well as the value.
16:29:50 <dmwit> :t intToDigit <$> get
16:29:50 <shachaf> I guess that's just regular State of a dependent pair.
16:29:51 <lambdabot> (MonadState Int f, Functor f) => f Char
16:30:01 <dmwit> :t intToDigit <$> get :: State Int Char
16:30:02 <lambdabot> State Int Char
16:30:46 <Welkin> I'm trying to understand the concept behind the State monad and how it works
16:30:54 <dmwit> Aha, now we're getting somewhere.
16:31:21 <Welkin> > runState (get >> put 4 >> modify (+9) >> return 1) 9
16:31:22 <dmwit> I can recommend the "All About Monads" section on State, as well as sigfpe's "You Could Have Invented Monads" section about State.
16:31:23 <lambdabot>  (1,13)
16:31:45 <Welkin> > runState (get >> put 4 >> modify (+9) >> return 'a') 9
16:31:46 <lambdabot>  ('a',13)
16:31:51 <dmwit> There was another article that made it click for me, but it was not well written. I can try to dig it up if you're interested anyway.
16:32:18 <vanila> Welkin, well basically a state monadic action is a function that takes start state and returns output state & result
16:32:22 <Welkin> I've read sigfpe's article
16:32:37 <vanila> so with that in mind you could try to reimplement the monad
16:32:46 <EvanR> @unmtl State
16:32:46 <lambdabot> Plugin `unmtl' failed with: `State' is not applied to enough arguments, giving `/\A B. A -> (B, A)'
16:32:49 <vanila> data MyState s a = MyState (s -> (s,a))
16:32:52 <vanila> for a type like that
16:32:52 <dmwit> ?unmtl State s a
16:32:52 <lambdabot> s -> (a, s)
16:33:02 <Welkin> I've been looking at the source for get, put, state, instance Monad (State s), etc.
16:33:42 <Welkin> State is just a wrapper around a function that takes a state and produces a result and a new state
16:33:47 <dmwit> right
16:34:09 <EvanR> its StateT Identity now isnt it
16:34:11 <Welkin> I understand that part conceptually
16:34:16 <Welkin> but the implementation is not so clear
16:34:20 <dreams> wth, (1/0) == 0, evaluates to False, is it really comparing infinity with 0?
16:34:25 <vanila> W
16:34:36 <vanila> Welkin, why don' you try to implement it fromscratch for the data type I gave
16:34:40 <EvanR> > (1/0) == (1/0) -- it gets worse
16:34:40 <dmwit> dreams: ...yes, isn't that what the spec says it should do?
16:34:41 <lambdabot>  True
16:34:45 <vanila> I think that will help
16:34:46 <geekosaur> dreams: IEEE floating pont defines Inf as a value (with some odd rules)\
16:34:46 <EvanR> -- nevermind
16:35:00 <dmwit> EvanR: You're thinking of NaN. =)
16:35:04 <EvanR> yeah
16:35:06 <geekosaur> you're thinking of NaN
16:35:17 <geekosaur> heh, /me slow
16:35:22 <dmwit> > 0/0 == 0/0
16:35:23 <Iceland_jack> > (0/0) == 0/0
16:35:23 <lambdabot>  False
16:35:25 <lambdabot>  False
16:35:27 <EvanR> > maxBound :: Double
16:35:28 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Types.Double)
16:35:28 <lambdabot>    arising from a use of ‘GHC.Enum.maxBound’
16:35:29 <dreams> geekosaur: what's the value of infinity?
16:35:43 <benzrf> > Infinity
16:35:44 <lambdabot>  Not in scope: data constructor ‘Infinity’
16:35:45 <EvanR> > (1/0) < (1/0)
16:35:46 <dmwit> dreams: There's a handful of bit patterns that represent infinity.
16:35:47 <lambdabot>  False
16:35:48 <benzrf> hmm
16:35:51 <dmwit> > read "Infinity" :: Double
16:35:51 <benzrf> @src Float
16:35:52 <lambdabot> data Float = F# Float#
16:35:52 <lambdabot>  Infinity
16:35:56 <benzrf> :t F#
16:35:57 <lambdabot> Not in scope: data constructor ‘F#’
16:36:02 <benzrf> awh
16:36:07 <dreams> > 1/0 == 1/0
16:36:09 <lambdabot>  True
16:36:14 <geekosaur> that's kinda a wrong question, becuase it conflates things that are quite distinct
16:36:15 <dmwit> dreams: Or, to ask another way: what is the value of 1?
16:36:29 <Iceland_jack> :t GHC.Types.F#
16:36:30 <lambdabot> GHC.Prim.Float# -> Float
16:36:45 <dreams> dmwit: maybe I'm confusing infinity with bottom?
16:36:47 <benzrf> @let GHC.Types.F# wat = (1 / 0)
16:36:48 <lambdabot>  .L.hs:161:1: Not in scope: data constructor ‘GHC.Types.F#’
16:36:55 <dmwit> dreams: Yes, infinity and bottom are quite distinct.
16:36:56 <shachaf> infinity is more like top hth
16:36:57 <benzrf> @let import GHC.Types
16:36:58 <lambdabot>  .L.hs:119:1:
16:36:58 <lambdabot>      GHC.Types: Can't be safely imported! The module itself isn't safe.
16:37:00 <benzrf> aww
16:37:03 <dmwit> > undefined == 0
16:37:05 <lambdabot>  *Exception: Prelude.undefined
16:37:15 <dreams> I see.
16:37:29 <EvanR> ieee floating point is a model of some subset of rational numbers, extended with infinities, and "non-value" NaN, and distinguishably signed zeros
16:37:30 <geekosaur> dreams: IEEE754 is available, you could read it. it has a number of odd things, and reasons (or at least justifications) for them.
16:37:57 <dreams> geekosaur: alright thanks.
16:37:58 <dmwit> dreams: It's possible that you can set a mode to ask for 1/0 to be an exception rather than Infinity. I'm not sure about that.
16:38:13 <dmwit> I seem to recall GHC supports setting some (but not all?) of the IEEE754 flags.
16:38:30 <dmwit> Which interplays with referential transparency in a weird way, of course.
16:38:46 <dreams> dmwit: well this is mostly the case for imperative languages. I guess its an implementation choice.
16:39:02 <geekosaur> I seem to recalls ome things on hackage which can set more of the flags, with significant caveats
16:39:28 <shachaf> In most computer languages, dividing a positive floating point number by 0 yields Infinity.
16:39:34 <dmwit> dreams: There's not a *whole* lot of implementation choices to make if you follow the IEEE754 spec.
16:39:46 <shachaf> Haskell isn't particularly different from other imperative languages in this respect.
16:39:52 <EvanR> unsafeRaiseExceptions :: [FloatException] -> IO ()
16:41:09 <EvanR> Data.Floating.Environment, all the goodness
16:41:33 <dmwit> dreams: Quick test on my machine: C, ruby, and Haskell use infinity; Python throws an exception.
16:41:59 <dmwit> dreams: So I'm not sure your claim about "most imperative languages" is necessarily true. =)
16:42:19 <EvanR> surprised at python
16:42:29 <dmwit> m etoo
16:42:33 <EvanR> (as usual)
16:43:22 <dreams> dmwit: well lots of them raise division by zero exception.
16:43:22 <dmwit> According to Internet, Java uses infinity, too.
16:43:32 <dmwit> dreams: Such as?
16:43:52 <EvanR> integer division by zero exception is common
16:43:55 <EvanR> even in C
16:44:05 <EvanR> but python is throwing float division by zero
16:45:26 <Aruro> > sin pi
16:45:27 <lambdabot>  1.2246467991473532e-16
16:45:35 <dmwit> > sin pi :: CReal
16:45:36 <lambdabot>  0.0
16:45:40 <Aruro> > cos pi
16:45:41 <lambdabot>  -1.0
16:46:18 <n4x> > let f = \x -> cos x ** 2 + sin x ** 2 in map f [1..]
16:46:20 <lambdabot>  [1.0,1.0,0.9999999999999999,1.0,0.9999999999999999,0.9999999999999999,0.9999...
16:46:20 <geekosaur> why do I feel like we're about to have the same discussion from a slightly different angle?
16:46:36 <shachaf> > 1e-50 :: CReal
16:46:37 <lambdabot>  0.0
16:46:48 <Aruro> i like it
16:46:54 <EvanR> seems legit
16:46:58 <Aruro> everybody has different answers
16:46:59 <dmwit> Computable reals... but not computable strings and bools. ;-)
16:47:16 <shachaf> Presumably CReal's Show instance could generate an infinite string.
16:47:20 <shachaf> Oh, no, of course it couldn't.
16:47:38 <Aruro> on a side note, what is a wise way to repeat an IO () action n times ?
16:47:44 <dmwit> :t replicateM_
16:47:45 <lambdabot> Monad m => Int -> m a -> m ()
16:47:56 <shachaf> Sometimes I forget how bizarre the reals are.
16:47:58 <Iceland_jack> :t replicateM_ :: Int -> IO () -> IO ()
16:47:59 <lambdabot> Int -> IO () -> IO ()
16:48:18 <EvanR> CSurreals
16:48:20 <Aruro> ok replicateM_ ty
16:48:34 <EvanR> COrdinals
16:48:55 <Aruro> somebody understood why cos pi is ok?
16:49:03 <dmwit> Perhaps the Show instance should put "+- 1e-50" or something.
16:49:10 <dmwit> And the Eq instance should just not exist.
16:49:18 <dmwit> approxRational is enough.
16:49:28 <EvanR> also Ord
16:49:30 <Aruro> @src replicateM_
16:49:30 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
16:49:34 <dmwit> Ord is semi-okay.
16:49:38 <EvanR> nop
16:49:45 <dmwit> Sometimes you get a real answer!
16:49:49 <EvanR> Ord requires Eq, and is just as partial as eq
16:49:51 <dmwit> Sometimes it loops forever.
16:50:14 <geekosaur> Aruro: possibly an Intel engineer could tell you
16:50:26 <Zemyla> Why does Enum a not imply Ord a?
16:50:27 <geekosaur> otherwise, welcome to IEEE754
16:50:29 <dmwit> Oh, right, technical pain points. Okay, I'd be okay with an Eq instance which looped for equal values.
16:51:02 <Aruro> is there a fast way to turn list into a tuple? [a,b,...c] -> (a,b,...c)
16:51:18 <dmwit> Zemyla: Practically, it seems reasonable; though theoretically I'm happy defending those two being distinct.
16:51:22 <EvanR> > 1 == 1 :: CReal
16:51:23 <lambdabot>  Couldn't match expected type ‘Data.Number.CReal.CReal’
16:51:23 <lambdabot>              with actual type ‘GHC.Types.Bool’
16:51:28 <dmwit> Aruro: What type would that operation have?
16:51:28 <EvanR> > 1 == (1 :: CReal)
16:51:29 <lambdabot>  True
16:51:38 <dmwit> Aruro: (Careful how you answer. This is a trick question. ;-)
16:51:44 <Aruro> :D
16:52:00 <Aruro> :t (a,b)
16:52:01 <lambdabot> (Expr, Expr)
16:52:05 <Aruro> mm
16:52:07 <shachaf> dmwit: It's 40 digits, I think.
16:52:10 <dmwit> Aruro: If you have a reason to believe you know the length of the list, something like (\[a, b, c] -> (a, b, c)) works fine.
16:52:28 <ReinH> Aruro: taking a step back, you probably shouldn't want to do this in the first place
16:52:38 <Aruro> actually what is tuple constructor?
16:52:47 <dmwit> Aruro: There's one for each size of tuple.
16:52:50 <Zemyla> dmwit: (EqualTuple a) => [Elem a] -> a
16:52:52 <Zemyla> :D
16:52:54 <dmwit> Aruro: (,) (,,) (,,,) etc.
16:53:14 <Aruro> ah ok, why that? not just same as (:) ?
16:53:34 <geekosaur> because tuples are not lists
16:53:34 <ReinH> Aruro: there isn't one tuple constructor because there isn't one tuple type
16:53:35 <hpc> tuples are fixed-length
16:53:40 <ReinH> there are n tuple types
16:53:44 <mmmm> and can have different types
16:53:49 <mmmm> :t ("a",1)
16:53:50 <lambdabot> Num t => ([Char], t)
16:53:53 <Aruro> interesting
16:53:57 <dmwit> Aruro: In that representation, getting the n'th position in a tuple would require n pointer dereferences.
16:53:57 <Lokathor> a tuple's size is part of its type
16:54:01 <ReinH> each tuple size is a different type
16:54:14 <ReinH> :t (,)
16:54:15 <lambdabot> a -> b -> (a, b)
16:54:16 <ReinH> :t (,,)
16:54:16 <lambdabot> a -> b -> c -> (a, b, c)
16:54:18 <ReinH> etc
16:54:28 <Welkin> okay
16:54:30 <Zemyla> Aruro: What would (toTuple [1, 2, 3])::(Int, String) do?
16:54:35 <Welkin> I implemented MyState with get, put and modify
16:54:54 <Welkin> for the bind definition, what is a good example?
16:55:08 <Welkin> it seems there is no use for get, put, modify with >>=
16:55:14 <EvanR> Welkin: alternatively, the join definition
16:55:16 <Welkin> they all work with >>
16:55:27 <ReinH> Welkin: get certainly doesn't work with >>
16:55:34 <ReinH> get with >> would be useless
16:55:39 <vanila> Welkin, good job
16:55:49 <vanila> Welkin, have you not defined >>= though?
16:55:51 <Welkin> > runState (get >> put 5) 9
16:55:52 <lambdabot>  ((),5)
16:56:01 <Welkin> I didn't say it was useful
16:56:01 <vanila> or just want a way to test it?
16:56:08 <n4x> @type \f -> get >>= \x -> put (f x)
16:56:09 <Welkin> I defined >>=
16:56:09 <lambdabot> MonadState a m => (a -> a) -> m ()
16:56:14 <vanila> because of the types, if you managed to implement it - you did it correctly
16:56:14 <n4x> @type modify
16:56:15 <lambdabot> MonadState s m => (s -> s) -> m ()
16:56:21 <dmwit> > runState (get >>= put . (+1)) 9
16:56:22 <lambdabot>  ((),10)
16:56:37 <ReinH> vanila: are you sure? I think state is ambiguous.
16:56:43 <vanila> so did that help to understand how state works? Do you have any more questions
16:56:48 <ReinH> @unmtl State s a
16:56:48 <lambdabot> s -> (a, s)
16:57:07 <vanila> ReinH, oh yeah, you're right
16:57:11 <EvanR> satisfy the types, the laws, and general sanity
16:57:20 <Zemyla> Actually, hmm. class EqualTuple a b | a -> b where { tupleToList :: a -> b; listToTuple :: b -> a }
16:57:22 <dmwit> satisfy the laws == general sanity
16:57:27 <EvanR> with state?
16:57:40 <Zemyla> a -> [b] and [b] -> a, even.
16:58:16 <EvanR> the laws cant know how state is supposed to work, for all it knows it could be like writer
16:58:34 <dmwit> There's no monoid constraint.
16:58:53 <EvanR> it could be like writer that just replaces instead of accumulate
16:59:06 <dmwit> It is like a writer that just replaces instead of accumulating.
16:59:15 <EvanR> that you cant get the value back from
16:59:28 <EvanR> secret state
16:59:45 <dmwit> MonadState includes get.
16:59:53 <ReinH> vanila: (>>) is ambiguous, I'm not sure if (>>=) is...
17:00:09 <ReinH> Djinn finds the correct version, but that doesn't prove anything
17:00:17 <dmwit> (>>=) is ambiguous, too.
17:00:22 <Aruro> so basically most list functions get translated to IO () monad? like map -> mapM_ replicate -> replicateM_
17:00:23 <ReinH> dmwit: ok I thought so
17:00:38 <dmwit> Just run m twice, for example. ;-)
17:00:43 <dmwit> (in "m >>= f")
17:00:52 <Welkin> oh, I was thinking the result was passed around
17:00:56 <ReinH> dmwit: indeed, that's what I assumed, but it's hard for me to reason about
17:01:01 <Welkin> it's the state that gets passed around
17:01:02 <EvanR> mapM is really a traversable function, rather than specifically a list
17:01:09 <Aruro> :t mapM
17:01:10 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
17:01:13 <EvanR> :t T.mapM
17:01:14 <lambdabot> (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
17:01:36 <ReinH> Aruro: there are monadic versions of lots of list functions, yes
17:01:37 <Welkin> and it happens inside of bind, so >> doesn't make a difference
17:01:50 <ReinH> Then we found ways to generalize lists to thinkgs like Traversable, which gives us T.mapM
17:02:06 <EvanR> :t T.sequenceA
17:02:07 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
17:02:08 <Aruro> so basically all imperative functinos like repeat for and so, are variations of functions on lists?
17:02:23 <ReinH> Aruro: you can think of a list as a loop that hasn't happened yet. ;)
17:02:39 <Aruro> :)
17:02:44 <ReinH> it's one reason lists are so prevalent in functional programming
17:03:08 <Aruro> so basically there is no imperative construction which does not have pure list equivalent?
17:03:10 <ReinH> you can treat them like a control structure as well as a data structure
17:03:27 <EvanR> depending on what you are using the list for, theres a more general version which exploits some aspect of lists which exist in other forms
17:03:32 <EvanR> Foldable, or Applicative
17:03:48 <EvanR> Functor
17:03:48 <Aruro> yes, control structure is good conception
17:04:04 <n4x> it being both is what makes it really "cool" though
17:04:13 <Aruro> yes :)
17:04:18 <ReinH> Aruro: there are imperative constructions that can't be formulated as lists. The things we represent using the Monad interface, for example.
17:04:29 <EvanR> :t when
17:04:30 <lambdabot> Monad m => Bool -> m () -> m ()
17:04:34 <Lokathor> so is >> what it uses in do notation when there'a a line that doesn't have <- in it?
17:04:36 <ReinH> Many computations have a treelike structure.
17:04:48 <ReinH> Lokathor: yes
17:05:04 <Aruro> ReinH can you give simple example which does not have list analogy?
17:05:25 <ReinH> Sure: if a then b else c
17:05:26 <Aruro> im did not hear yet of interfaces and such
17:05:41 <Aruro> a
17:05:43 <Aruro> i see
17:05:51 <Aruro> you say it does not have list analogy?
17:06:01 <ReinH> You need a tree structure, not a list
17:06:03 <rom1504> it's a tree
17:06:04 <rom1504> yeah
17:06:06 <ReinH> This is why we call it "branching" ;)
17:06:18 <Aruro> ok tree is conceptually close to list
17:06:25 <Aruro> not big deal in my naive opinion
17:06:28 <EvanR> a list is a subtype of tree ;)
17:06:34 <Aruro> yes :)
17:06:40 <ReinH> lists are degenerate trees ;)
17:06:49 <Aruro> :)
17:06:55 * dmwit mumbles something about polymorphic recursion
17:06:55 <ReinH> or lists are trees with more structure, depending on how you look at it
17:06:56 <Aruro> tree is just 2 or more lists :)
17:07:00 <ReinH> Aruro: no
17:07:10 <rom1504> well also tree are graph, but it's getting more complicated ;)
17:07:14 <EvanR> data Tree a = Tree a [Tree a]
17:07:22 <dmwit> Trees are nested lists.
17:07:28 <ReinH> yes
17:07:29 <EvanR> data Tree a = Leaf a | Tree [Tree a]
17:07:35 <dmwit> But one level of nesting is enough. =)
17:08:14 <EvanR> type Forest a = [Tree a] to confuse people
17:08:33 <ReinH> Where's the thing that describes monads by starting with lists and adding branching?
17:09:08 <ReinH>  The point is that monads give you a treelike model of computation, which is why they are more powerful than functor or applicative.
17:09:32 <Aruro> i dont know what functor model of computation is
17:09:35 <Aruro> but i like list one
17:09:46 <EvanR> functor is simpler than all of the above
17:09:47 <ReinH> computations that are like lists are pretty boring
17:09:47 <Aruro> very close to Turing machine
17:10:01 <ReinH> Aruro: a Turing machine is not a list-like model of computation
17:10:08 <Aruro> why not?
17:10:14 <Aruro> its one dimensional
17:10:20 <Aruro> i see a list there
17:10:22 <ReinH> No, it is not
17:10:23 <rom1504> it goes both way
17:10:30 <Aruro> why not?
17:10:32 <ReinH> It is superficially using a list
17:10:35 <ReinH> but it also has branching
17:10:41 <ReinH> so the *computation* cannot be modeled as a list
17:10:41 <EvanR> turing machine has a table of where to go next, it has to make decisions which let it go anywhere
17:10:57 <Aruro> yes that you covered with if then else
17:11:03 <Aruro> not big deal
17:11:10 <Aruro> data structure is onedimensional
17:11:18 <ReinH> Aruro: The data structure is not what we're talking about
17:11:33 <ReinH> In fact, turing completeness implies that it can't use a list-like model of computation
17:11:50 <vanila> i dont understand what a list-like or tree-like model of computation is?
17:12:03 <n4x> ReinH: "are lists turing-complete?"
17:12:03 <Aruro> he means it should have if's
17:12:05 <vanila> is this just an intuitive notion?
17:12:17 <godel> n4x: you mean list comprehension?
17:12:17 <ReinH> vanila: it can be made more precise
17:12:23 <Aruro> in list model there is not if, thats what he is saying
17:12:38 <ReinH> vanila: for example, applicative vs monad
17:12:38 <EvanR> yeah, what is list model anyway
17:12:43 <Aruro> read above ReinH mentioned it,
17:12:53 <Aruro> list model is when you can have pure function
17:12:58 <ReinH> Aruro: no
17:13:00 <Aruro> with map, foldr and such
17:13:02 <ReinH> :t (>>=)
17:13:03 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:13:05 <Aruro> and turn it into IO ()
17:13:10 <ReinH> The type of (>>=) allows branching computations
17:13:13 <ReinH> :t (<*>)
17:13:14 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:13:15 <EvanR> map and foldr work fine on trees
17:13:18 <EvanR> (fmap)
17:13:18 <ReinH> The type of (<*>) does not
17:13:30 <ReinH> (>>=) allows you to make a choice of m
17:13:35 <vanila> ok I see what you mean
17:13:38 <ReinH> In fact, requires you to
17:13:52 <Aruro> he is just being precise, somebody mentioned graph
17:13:59 <Aruro> he was most general i guess
17:14:06 <ReinH> This has nothing to do with purity.
17:14:13 <Welkin> what do you mean "a choice of m"?
17:14:22 <Welkin> you cannot switch to another monad in them iddle of a computation
17:14:23 <Aruro> you forgot initial question
17:14:24 <ReinH> Welkin: (a -> m b) is a function that "chooses an m"
17:14:33 <EvanR> chooses an m b
17:14:41 <Aruro> there was analogy map to mapM_ , replicate to replicateM_
17:14:53 <ReinH> Aruro: no, there isn't
17:15:05 * hackagebot set-monad 0.2.0.0 - Set monad  http://hackage.haskell.org/package/set-monad-0.2.0.0 (GeorgeGiorgidze)
17:15:07 <ReinH> previous computations in mapM can't effect future computations
17:15:07 * hackagebot servant-pandoc 0.1 - Use Pandoc to render servant API documentation  http://hackage.haskell.org/package/servant-pandoc-0.1 (mpickering)
17:15:22 <Aruro> and question was if EVERY imperative algorithm could be deconstructed from mapM_ to map
17:15:43 <EvanR> mapM_ cant be represented as map
17:15:44 <Aruro> then you mentioned if then else
17:15:49 <ReinH> No. mapM can't represent all computations.
17:15:53 <ReinH> It doesn't allow branching.
17:15:56 <Aruro> and question turned to trees
17:18:05 <Aruro> which set of list commands represend all computations?
17:18:07 <ReinH> A familiar example might be applicative and monadic parsing
17:18:18 <Aruro> sorry tree commands
17:19:22 <phaazon> Aruro, what are you talking about?
17:20:34 <Welkin> data Player = Player { health :: Int, strength :: Int, defense :: Int } deriving Show
17:20:38 <Welkin> runState (modify (\p -> p { health = health p + 4 })) $ Player 10 17 12
17:20:42 <Welkin> I got that working
17:20:59 <Welkin> using record syntax seems clumsy in this case
17:20:59 <ReinH> Turing machines can be represented as (labelled) graphs
17:21:44 <ReinH> If you restrict yourself to acyclic graphs where all nodes are connected by a single path, you get a formalization of "list-like computations".
17:21:55 <EvanR> Welkin: yeah. you could try lenses here. or make some helpers which wrap the relevant setting you will want to do on this particular state
17:22:00 <ReinH> That's what I'm referring to as "list-like and tree-like computation"
17:22:01 <Welkin> how is State typically used when modifying a data structure like that?
17:22:30 <vanila> you can'tmodify a data structure
17:22:35 <vanila> state monad just gives you a single mutable cell
17:22:43 <vanila> or should I say, the illusion of one
17:22:44 <Welkin> well, I mean create a new one based on the old one
17:22:53 <EvanR> lenses
17:23:21 <ReinH> So turing completeness implies the ability to construct computations with a "graph-like" structure, since otherwise there would be machines that you can't simulate.
17:23:22 <EvanR> or a different kind of monad that gives you the fields as separate variables
17:23:29 <EvanR> extensible effects?
17:23:54 <Aruro> silly question by why mapM_ and replicateM_ are not in prelude?
17:24:01 <Aruro> pretty basic functions though
17:24:07 <Welkin> Aruro: lots of stuff is not in Prelude
17:24:12 <Aruro> so?
17:24:17 <Aruro> why not?
17:24:19 <EvanR> its part of the monad library
17:24:20 <Welkin> Prelude is a mess anyway
17:24:24 <ReinH> vanila: another way to look at it is in terms of chomsky grammars, which is where I was going with the parsing thing...
17:25:12 <vanila> how do we know what grammars applicative can parse and which monad can parse?
17:25:37 <Aruro> is there some list of most basic haskell functions through which all other functions are defined?
17:25:44 <Aruro> like @src map
17:25:48 <ReinH> vanila: well, applicative can't use previous results to choose future parses
17:25:50 <Aruro> @src map
17:25:50 <lambdabot> map _ []     = []
17:25:50 <lambdabot> map f (x:xs) = f x : map f xs
17:26:08 <Aruro> map is on top of recursion and pattern matching
17:26:15 <nuser> @src null
17:26:16 <lambdabot> null []     = True
17:26:16 <lambdabot> null (_:_)  = False
17:26:16 <Aruro> not fundamental then
17:26:36 <nuser> why isn't null defined as null = (==[]) ?
17:26:37 <Aruro> in other words what is axiomatic basis of haskell?
17:26:45 <vanila> nuser, that would require Eq
17:26:47 <Welkin> Aruro: map = fmap
17:26:49 <ReinH> vanila: but monadic parses *can* parse context-sensitive grammars
17:26:50 <Welkin> for lists
17:26:53 <Aruro> @src fmap
17:26:53 <lambdabot> Source not found.
17:26:56 <Aruro> ups
17:27:06 <vanila> ReinH, I see!
17:27:07 <Welkin> look at the source directly
17:27:19 <EvanR> nuser: alternatively, (== 0) . length
17:27:23 <Welkin> http://hackage.haskell.org/package/base-4.7.0.2/docs/src/GHC-Base.html
17:27:36 <ReinH> vanila: that's what I was getting at with the "a -> m b" lets you make a choice of m, although "choice of m" is poorly phrased
17:27:48 <EvanR> nuser: but length is defined by pattern matching, and its generally easier to use pattern matching than boolean tests
17:27:50 <srhb_> Aruro: Pattern matching is perhaps one of the most fundamental concepts in Haskell.
17:28:02 <Aruro> i see , yes
17:28:06 <nuser> EvanR: thanks
17:28:10 <ReinH> vanila: applicative gets you at most contest-free, while monadic allows context-sensitive.
17:28:13 <srhb_> Aruro: It even allows us to define lazy logical or, if-then-else, etc.
17:28:16 <tsani> Can't Applicative parse context-sensitive grammars by cheating? Specifically, using an infinite number of production rules.
17:28:21 <ReinH> vanila: this is described in http://research.microsoft.com/en-us/um/people/daan/download/papers/parsec-paper.pdf btw
17:28:28 <nuser> vanila: what's wrong bad about requireing Eq
17:28:30 <Aruro> so pattern matching and recursion on lists give me most of stuff?
17:28:34 <srhb_> Aruro: The access to this means a lot of the functions that must be "fundamental" in other languages really aren't in Haskell. We can define them.
17:28:38 <vanila> nuser, it's an extra requirement that you can do without
17:28:43 <Welkin> Aruro: lists are not so fundamental
17:28:45 <ReinH> tsani: I'm not sure about that!
17:28:47 <nuser> :) thanks
17:28:48 <Welkin> it's just another data structure
17:28:50 <srhb_> Aruro: Lists aren't even fundamental.
17:28:52 <srhb_> Ah.. Too slow.
17:28:59 <Aruro> not?
17:29:05 <ReinH> tsani: I guess I wouldn't be surprised... do you happen to have a source?
17:29:06 <srhb_> Aruro: data List a = Nil | Cons a
17:29:10 <Aruro> yes
17:29:14 <srhb_> Aruro: [] is just fancy sugar for that.
17:29:15 <geekosaur> almost
17:29:19 <srhb_> Derp
17:29:20 <EvanR> produces and sums, all the way down
17:29:21 <nuser> @src length
17:29:21 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:29:22 <pavonia> nuser: Note that (== 0) . length fails for infinite lists, while null doesn't
17:29:23 <srhb_> Nil | Cons a (list a)
17:29:26 <Aruro> then its patterns plus data types
17:29:32 <tsani> ReinH: https://byorgey.wordpress.com/2012/01/05/parsing-context-sensitive-languages-with-applicative/
17:29:35 <srhb_> Aruro: Right. And laziness to some degree. :)
17:29:44 <srhb_> Well, actually a larger degree, I've come to believe lately.
17:29:53 <ReinH> tsani: damn it byorgey... ;)
17:29:54 <nuser> pavonia: good point
17:30:07 <Aruro> actually what is this data definition line
17:30:15 <nuser> pavonia: how do you guys see these things? Experience or something else?
17:30:22 <Aruro> it seems to be as important as pattern matching
17:30:23 <Welkin> recursion is fundamental as well
17:30:28 <Welkin> there are no loops
17:30:30 <ReinH> tsani: that's quite clever! thanks
17:30:31 <pavonia> nuser: See what?
17:30:33 <srhb_> Aruro: Algebraic data types? They're definitely a fundamental concept of Haskell.
17:31:03 <Aruro> so haskell is matching on data "strings" ?
17:31:05 <EvanR> Aruro: algebraic data types consist of nested product types and sum types, and the unit type ().
17:31:08 <Welkin> Aruro: have you read any books on haskell yet?
17:31:19 <srhb_> Aruro: I don't know why one would call it a string.
17:31:26 <Welkin> Aruro: I think you are asking the wrong questions
17:31:28 <Aruro> call it then
17:31:29 <nuser> pavonia: how'd you know it fails on infinite lists
17:31:45 <Welkin> it will become clear if you read some basic resources on haskell
17:31:48 <EvanR> length of infinite list is bottom
17:31:50 <Aruro> how do you call this sentence data List a = .. ?
17:31:55 <ReinH> tsani: Ah! You encode the graph in the production rules, which you can only do with an infinite number... magic!
17:32:03 <srhb_> Aruro: A data type definition.
17:32:05 <srhb_> Or something like that.
17:32:07 <Welkin> Aruro: that is explained in Learn You a Haskell
17:32:18 <Aruro> i read that Welkin ty
17:32:37 <tsani> ReinH: I thought it was pretty clever as well :)
17:32:43 <nuser> EvanR: Cool
17:32:45 <Aruro> so, we are down to two conceptions  pattern matching, recursion, and data type definitions
17:32:46 <tsani> Although I still don't fully understand the idea.
17:32:49 <Aruro> three
17:32:57 <Welkin> Aruro: I don't understand your goal
17:33:01 <tsani> I'm not enough of a parsing pro... yet :)
17:33:17 <Aruro> basis is my goal
17:33:19 <Welkin> you cannot simplify everything down to a tidy label
17:33:20 <EvanR> nuser: you can test specific questions about infinite data and bottom by using [1..] and undefined in the console
17:33:24 <Iceland_jack> Aruro: Have you looked at Core
17:33:27 <EvanR> > length [1..]
17:33:30 <lambdabot>  mueval-core: Time limit exceeded
17:33:38 <pavonia> nuser: Hhm, you usually check how a function acts on several cases of input
17:33:40 <Aruro> i dont know what core is
17:34:01 <Welkin> I mean, if we really want to get down to it, everything in the computer is just high and low voltages
17:34:01 <Aruro> but i already like that there seems not be nothing but patterns over data types
17:34:12 <Aruro> not=to
17:34:17 <Iceland_jack> Aruro: Core is what internally what GHC compiles Haskell to
17:34:19 <pavonia> nuser: and as infinite things are pretty common in Haskell you have to check these too
17:34:32 <Aruro> ty Iceland_jack
17:34:33 <Iceland_jack> there is an image discription of Core here Aruro http://stackoverflow.com/questions/6121146/reading-ghc-core
17:34:41 <EvanR> Welkin: well theres off, on, high impedance ;)
17:34:46 <Aruro> ty!
17:34:56 <nuser> EvanR: how do I get "mueval-core" to show up on ghci, It usually have to ctrl + c to stop it
17:35:01 <EvanR> True, False, FileNotFound
17:35:06 * hackagebot servant-pandoc 0.1.0.1 - Use Pandoc to render servant API documentation  http://hackage.haskell.org/package/servant-pandoc-0.1.0.1 (mpickering)
17:35:07 <Iceland_jack> That describes the syntax, which fits on a somewhat-more-than-moderately sized napkin
17:35:11 <ReinH> tsani: the article has a nice explanation in the paragraph starting with "For any given predicate p"
17:35:13 <nuser> pavonia: nice tip
17:35:46 <shachaf> Unnecessary nontermination in the infinite case often corresponds to unnecessary inefficiency in the finite case.
17:36:00 <Aruro> ty Iceland_jack
17:36:09 <Aruro> that answers my question
17:36:10 <ReinH> basically you construct an infinite tree of parsers, where each node has n children where n is the size of your alphabet, and it is infinitely deep. Each node remembers the full path taken to reach it, so you end up with a parser for every possible input
17:36:22 <Aruro> though i was more looking into user side of story
17:36:35 <Aruro> what is basic haskell for me as a user
17:36:46 <Aruro> i already know there is no map in haskell
17:36:57 <Iceland_jack> Aruro: Defining functions by equations, in these equations you can pattern match on data types
17:37:15 <EvanR> :t map
17:37:16 <lambdabot> (a -> b) -> [a] -> [b]
17:37:37 <Iceland_jack> You need to be more explicit what you're actually looking for if you want more details, I have a feeling you're looking for something you haven't fully described
17:37:49 <hnoob> :t fmap
17:37:49 <ReinH> Aruro: you might be interested in looking at the source of the Prelude module, since that module starts with the very basic constructions provided by the language and builds up from there
17:37:49 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:38:10 <Iceland_jack> Aruro: "True" and "False" are not built in to the language if that helps
17:38:16 <Aruro> yes ty Iceland_jack, nice summary
17:38:41 <Aruro> ReinH, i have feeling prelude source is best book to learn haskell :)
17:39:21 <bernalex> Aruro: haskell report is also nice
17:39:31 <Aruro> yes i was having in mind to read it
17:40:05 <bernalex> Iceland_jack: yet if-then-else is grrrrrrrr (ok rant over)
17:40:06 * hackagebot shelly 1.6.0 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.6.0 (GregWeber)
17:41:59 <Aruro> so core is believed to be Sistem.F language
17:42:12 <Aruro> which as far as i understand is purely theoretical construction
17:42:36 <Aruro> are there any tricks done on it to make it "real" programming language?
17:42:42 <ReinH> tsani: also the comments are very interesting
17:43:10 <ReinH> Aruro: Core is a real langauge. It's actually used by GHC.
17:43:18 <n4x> Aruro: I would guess making a compiler for it makes it a real language!
17:43:31 <Aruro> ok :)
17:43:55 <ReinH> You could write core directly and have GHC compile it if you were so inclined.
17:45:20 <Aruro> i guess for now im pretty happy with it :)
17:46:53 <Lokathor> i assume that, like with modern assembler, writing in Core will usually produce slower code than having the compiler do it for you?
17:47:26 <EvanR> i dont know about that rule
17:47:31 <srhb_> Lokathor: Actually, a lot of the transformations and optimizations occur on Core.
17:47:36 <Iceland_jack> Lokathor: The GHC optimization passes are from Core -> Core
17:47:53 <Iceland_jack> and the later ones you'd benefit from anyway
17:48:04 <srhb_> Lokathor: It's part of the reason for the whole Core construct. A small language that can be reasoned about very systematically, afaik.
17:48:35 <Iceland_jack> Lokathor: If you look at the GHC compiler pipeline you can see that the process from Haskell -> Core is desugaring
17:48:43 <Iceland_jack> ( http://i.stack.imgur.com/PtsCf.png )
17:48:48 <srhb_> Iceland_jack: Well, rewrite rules come first, don't they?
17:49:01 <Iceland_jack> Yes, there are some optimizations you wouldn't benefit from
17:49:30 <Lokathor> that image says that you can configure haskell onto the JVM?
17:49:30 <Iceland_jack> but it doesn't get compiled by a backend as simply as many assemblers work
17:50:06 <Aruro> so it looks like  Standard Chartered Bank reaaaallly likes Haskell, or Hakellers :)
17:50:06 <Iceland_jack> Lokathor: If you have a specific backend (stg2jvm) which isn't actually used
17:50:43 <Lokathor> shame, seems like it'd be nice if that were a more supported option
17:51:00 <Iceland_jack> Lokathor: But you can also see that the stg2jvm backend is *outside* the GHC box
17:51:07 <Iceland_jack> as is the "Core src"
17:51:22 <Iceland_jack> So you can write a backend for Core or for STG and compile it to your preferred backend
17:51:31 <Iceland_jack> *with your
17:51:50 <srhb_> Writing STG is even more sad than Core though, type safety is all gone.
17:52:06 <Lokathor> the JVM doesn't have tail-call optimization though so i'm not sure how well it'd work out really
17:52:09 <Iceland_jack> Yes you wouldn't manually muck about writing STG
17:57:43 <sbrg> srhb_: did you figure anything out?
17:57:59 <srhb_> sbrg: No, and it doesn't seem like Reddit has any idea either. It is quite puzzling. :)
17:58:09 <sbrg> I just saw your post on reddit, yeah
17:58:24 <srhb_> I guess I'll live with my crazy magical unusable test.hs file.
17:58:26 <sbrg> In your strace output, I acn't seem to see any syscall that prints the error message you described
17:58:54 <srhb_> Well, that's odd.
17:59:25 <srhb_> write(2, "collect2: error: ld returned 1 e"..., 43) = 43
17:59:30 <sbrg> ah
17:59:31 <sbrg> of course
17:59:46 <srhb_> Had to check to make sure. :P
18:00:08 <absence> on reddit it was mentioned that free monads could be used to write endian-neutral Binary.Get instances. how does that work? use an adt that represents the various binary operations with the free monad, and then "evaluate" it by matching the various adt operations, and either perform little endian or big endian version of each operation?
18:01:05 <shachaf> absence: That sounds like the sort of thing someone who says that might have in mind.
18:02:27 <geekosaur> the error is happening inside ld, and this strace doesn't include subprocesses for ld or collect2. that said, I see some debug info in here... what version of ghc is this?
18:02:45 <sbrg> srhb_: following the ld error, there are a few unlinks of some temporary files(such as object files) inside some temp directory.. those might be the culprits
18:03:09 <Twey> What would the derivative (type of one-hole contexts) be of the cofree comonad?  I have: data Cofree' f f' a = Cofree' a (Cofree' f f' a) (f' (Cofree f a)) but I'm not sure where that extra (Cofree' f f' a) came from, so I feel I may have done it wrong
18:03:23 <geekosaur> (afaik the debuginfo stuff is only in HEAD. and this could be a bug in the debug output stuff...)
18:03:23 <srhb_> sbrg: Any particular line number?
18:03:34 <sbrg> but yes, like geekosaur suggests, strace -f might give better information(well, assuming that catches the call to ld and collect2)
18:03:36 <sbrg> srhb_: sec
18:03:37 <srhb_> geekosaur: 7.8.5
18:03:39 <srhb_> Er
18:03:41 <srhb_> 7.8.4
18:03:43 <sbrg> 2247+
18:03:46 <srhb_> No time travel involved. :-)
18:03:55 <sbrg> 2247-50
18:04:07 <srhb_> sbrg: But that's the functioning one, isn't it?
18:04:18 <geekosaur> in any case, seek error inside ld makes me think malformed object file somehow
18:04:21 <Twey> I expect to get: data Cofree' f f' a = Cofree' a (f' (Cofree f a)) but differentiating by the product rule doesn't seem to give me that
18:04:23 <sbrg> nope
18:04:58 <absence> shachaf: thanks
18:05:04 <srhb_> geekosaur: Hmm, so that would be the temporary object file that ghc creates? ie test.o
18:05:11 <srhb_> sbrg: Ah yes. Though that seems to happen after the fact.
18:05:17 <geekosaur> yes
18:05:53 <srhb_> geekosaur: So if it is a file system error, my OS is persistently allocating that file in the very same spot. I don't know if that's realistic, but I guess it may be?
18:06:06 <geekosaur> mm, except that doesn't match an error of illegal seek; *that* implies it tried to seek on a pipe or a socket, which is weird
18:06:06 <shachaf> Twey: What sort of derivative are you talking about here? Of Cofree itself, not of Cofree f for a given f?
18:06:14 <srhb_> Ah.
18:07:01 <sbrg> geekosaur: man pages say that would be ESPIPE
18:07:05 <sbrg> is that the error?
18:07:17 <geekosaur> except that ld internally could be using that error code to indicate an invalid seek from the standpoint of, say. libbfd
18:07:32 <Twey> shachaf: Of (Cofree f), where f' is the derivative of f
18:07:37 <geekosaur> because nothing stops error numbers from being reused for their own purposes by libraries
18:07:42 <sbrg> srhb_: can you run it again on the bad example with strace -f?
18:07:48 <sbrg> geekosaur: true
18:07:59 <srhb_> sbrg: Yes, looking now.
18:08:07 <srhb_> 22k lines though. Hurgh!
18:09:05 <sbrg> lol, wow
18:09:23 <geekosaur> not surprising. strace is a farly blunt tool
18:09:27 <srhb_> Indeed.
18:09:43 <srhb_> There's a lot of ENOENT going on, but I see that in the working one, too.
18:09:52 <Twey> shachaf: Oh!  I think I just screwed up my working.
18:10:06 <geekosaur> something like 80% of those are searches of the library path for shared objects, of course
18:10:11 <srhb_> Yeah.
18:10:16 <Twey> Trying to derive with respect to (f, a) instead of Cofree f a, or something silly.
18:10:50 <srhb_> So in lseek the first argument would be the fd, right?
18:11:09 <geekosaur> (fd, offset, whence), yes
18:11:10 <sbrg> yes
18:11:18 <srhb_> Right, now I just have to figure out what "3" is :-)
18:11:58 <sbrg> srhb_: search for open
18:12:01 <sbrg> that returns 3
18:12:02 <Twey> (as usual, writing it out in Euler notation makes everything significantly clearer…)
18:12:30 <sbrg> maybe just search for = 3$
18:12:33 <sbrg> $ = end of line
18:16:32 <shachaf> Twey: What did you end up with?
18:18:32 <shachaf> Foo f a = A (f (Cofree f a)) | B a (f' (Cofree f a)) (Foo f a) ?
18:18:33 <Twey> shachaf: Cofree' f f' a = Cofree' a (f' (Cofree f a)
18:18:36 <Twey> )
18:18:46 <sbrg> now I want coffee..
18:19:04 <Twey> As expected
18:19:22 <shachaf> Hmm, is that the same as what I wrote or did I mess it up?
18:19:55 <srhb_> Is there some other way that fd can be constructed? Other than open, that is
18:20:09 <Twey> shachaf: You included a hole for the element; I'm only interested in the substructure
18:20:22 <shachaf> ?
18:20:42 <dmwit> srhb_: I think sockets use fds?
18:20:59 <srhb_> Hmm, I don't think the linker uses sockets for anything.
18:21:30 <sbrg> srhb_: yeah, pipe etc
18:21:38 <dmwit> srhb_: And of course you can just use any int as an fd.
18:21:47 <sbrg> i don't know my linux syscalls well enough
18:22:07 <Twey> shachaf: Your case ‘A’ is where you have all subtrees and the hole is where the element is, i.e. you differentiated with respect to a *and* with respect to Cofree f a and summed them
18:22:10 <dmwit> srhb_: http://en.wikipedia.org/wiki/File_descriptor has a complete list of syscalls that create fds.
18:22:22 <srhb_> dmwit: Thanks.
18:22:34 <sbrg> srhb_: wanna upload the output?
18:22:35 <Twey> shachaf: Whereas mine is only the subtree case (your B), i.e. I only differentiated with respect to Cofree f a
18:22:41 <sbrg> i'm curious and bored
18:22:41 <srhb_> sbrg: Yeah, might as well
18:23:16 <srhb_> ow, not on lpaste apparently. :-)
18:23:23 <dmwit> too big?
18:23:27 <dmwit> strace has that effect...
18:23:36 <Twey> shachaf: You didn't screw it up *and* they're not the same ☺
18:23:39 <srhb_> https://gist.githubusercontent.com/srhb/d89757fef9cc99eb1ca9/raw/gistfile1.txt
18:23:48 <srhb_> dmwit: Indeed :)
18:24:14 <srhb_> It's probably pipe() then
18:24:27 <srhb_> Hm, nope.
18:24:49 <sbrg> srhb_:
18:24:55 <sbrg> 22124 open("/tmp/ccRzVk9T.ld", O_RDONLY) = 3
18:25:05 <sbrg> oh, wait
18:25:08 <sbrg> it closes it again
18:25:32 <srhb_> sbrg: The illegal seek is on 35439
18:26:39 <sbrg> aye
18:26:58 <srhb_> Oh and it IS ESPIPE
18:27:04 <srhb_> So I just can't find where it's constructed...
18:27:48 <srhb_> DOH.
18:28:13 <srhb_> Of course it was something stupid like this. There was a FIFO named test.
18:28:24 <srhb_> So the problem was actually not linking from an object file but TO the executable
18:28:57 <sbrg> oh, haha
18:29:08 <Welkin> how does record update syntax work?
18:29:16 <sbrg> well, that was fun anyway
18:29:29 <srhb_> Never name anything test ever.
18:29:32 <srhb_> :|
18:29:33 <sbrg> good thing it wasn't a harddrive error
18:29:40 <srhb_> Yes, definitely! I feel much better now. :-)
18:29:42 <sbrg> /failure
18:29:45 <sbrg> yeah
18:29:53 <Welkin> game { player2 = 10 }
18:29:56 <Welkin> I know that works
18:30:12 <Welkin> but can I pass that record update as a function into modify for the State monad?
18:30:23 <Welkin> modify { player2 = 10 }
18:31:07 <Welkin> it would be applied as { player2 = 10 } game
18:31:13 <Welkin> backward
18:31:28 <Welkin> I suppose & would work
18:31:37 <Welkin> & = flip ($)
18:32:15 <ReinH> Welkin: eh?
18:32:34 <ReinH> that's not how record syntax works
18:32:49 <ReinH> game { player2 = 10 } is not the same as game $ { player2 = 10 }
18:33:16 <Welkin> well, how does it work?
18:33:32 <Welkin> I'm looking for a clean way to update my game state
18:33:47 <Welkin> is modify a good option?
18:33:50 <ReinH> Lenses?
18:33:52 <Twey> Welkin: I'm afraid you want lenses
18:34:11 <Welkin> yes, but how does it work?
18:34:12 <Twey> Or: modify $ \x → x { player2 = 10 }
18:34:26 <Welkin> lens has a lot of magic
18:34:30 <Twey> Lenses let you say: player2 .= 10
18:34:37 <Twey> But yes, with some conceptual overhead ☺
18:34:58 <ReinH> A lot of *sufficiently advanced technology* ;)
18:35:01 <Welkin> I haven't been able to find any good examples of what I am trying to do
18:35:15 <Welkin> I think I want to use the State monad
18:35:40 <Welkin> I would like to have two players battle each other until one has health <= 0
18:35:58 <Welkin> with input from the player, of course
18:36:25 <ReinH> > (1,2) &~ _2 .= 3 -- &~ is just a shortcut for flip execState
18:36:27 <lambdabot>  (1,3)
18:36:58 <ReinH> Welkin: https://github.com/ekmett/lens/blob/master/examples/Pong.hs
18:37:04 <Welkin> heh
18:37:10 <Welkin> I have looked at that Pong example quite a bit
18:37:20 <Welkin> but I mostly ignored the lens parts
18:37:23 <ReinH> Welkin: http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html
18:37:28 <Welkin> since I was trying to undertsand how State works
18:41:41 <Welkin> ReinH: I was looking for that guide
18:41:42 <Welkin> thanks
18:42:56 <Welkin> I have avoided learning lens for a while, but I suppose now is a good time
18:46:59 <gamegoblin> Is there a simple composition that is equivalent to f Nothing = []; f (Just x) = [x]
18:47:58 <khyperia> gamegoblin, https://www.haskell.org/hoogle/?hoogle=Maybe+a+-%3E+%5Ba%5D
18:48:06 <khyperia> basically "maybeToList"
18:48:20 <gamegoblin> khyperia: thanks
18:51:03 <EvanR> :t fmap (:[]) Nothing
18:51:04 <lambdabot> Maybe [a]
18:51:54 <dmwit> Welkin: You can pass such an update like this:
18:52:05 <dmwit> Welkin: Ignore me, I was scrolled back and didn't notice, sorry.
18:53:24 <EvanR> :t fromMaybe [] (:[]) Nothing
18:53:25 <lambdabot>     Couldn't match expected type ‘Maybe a1 -> t’
18:53:25 <lambdabot>                 with actual type ‘[t0]’
18:53:25 <lambdabot>     In the first argument of ‘fromMaybe’, namely ‘[]’
18:54:09 <EvanR> :t maybe [] (:[]) Nothing
18:54:10 <lambdabot> [t]
18:54:23 <Welkin> is it safe to install lens globally?
18:54:35 <Welkin> or will it have conflicts
18:55:06 <Welkin> I've got yesod/hakyll installed globally
18:55:14 <srhb_> Good luck then! :-)
18:58:13 <Welkin> is that a yes?
18:58:43 <vanila> with cabal nothing is safe
19:06:18 <Welkin> oh, only 10 packages need to be installed for lens on my system
19:06:36 <Welkin> I did cabal install lens --dry-run and it did not complain
19:06:40 <Welkin> does that mean it's safe?
19:06:45 <EvanR> hahaha
19:06:50 <EvanR> scared?
19:07:10 <Welkin> well, I don't want to spend hours re-installing all of my packages
19:08:01 <srhb_> Copy .ghc and .cabal then
19:11:06 <Welkin> I probably should have installed yesod in a sandbox anyway
19:11:11 <Welkin> I'll probably do that at some point
19:19:55 <EvanR> f ∘ g is there some way to read this when talking about math IRL. easier to say than "f composed with g"
19:20:01 <calvinx> Is there an environment variable I can set if I don’t want to keep typing `runhaskell -package-db=$HOME/myproject/.cabal-sandbox/x86_64-osx-ghc-7.8.3-packages.conf.d helloworld.hs` when using a particular cabal sandbox ? (I runhaskell or ghc to know that it is using “$HOME/myproject/.cabal-sandbox/x86_64-osx-ghc-7.8.3-packages.conf.d”
19:20:25 <calvinx> *I would like runhaskell or ghc to know that it is using “$HOME/myproject/.cabal-sandbox/x86_64-osx-ghc-7.8.3-packages.conf.d
19:20:50 <hexagoxel_> `cabal exec -- runhaskell helloworld.hs` ?
19:20:54 <hexagoxel_> calvinx: ^
19:21:08 <hexagoxel_> or am i missing something special you wanna do?
19:21:46 <calvinx> o that works. nice.
19:22:12 <calvinx> how does “cabal exec” work? how does it know I am using “$HOME/myproject/.cabal-sandbox/x86_64-osx-ghc-7.8.3-packages.conf.d"
19:22:26 <Welkin> EvanR: f compose g; f dot g
19:22:46 <hexagoxel_> calvinx: it looks for .cabal-sandbox in the current dir
19:23:15 <calvinx> I see.
19:23:26 <calvinx> Thanks!
19:23:29 <michaelt> calvinx: but you can always tell ghc --pkg-db xyz
19:24:15 <calvinx> michaelt: that’s what I don’t want to do. It’s bothersome to be typing a long string specifying where the ghc packages are.
19:24:51 <Lokathor> I have a [(Double,Double)] representing points in a path. How do I find the total distance of the path? doesn't quite seem like a fold works here
19:24:52 <hexagoxel_> calvinx: and to answer the initial question: yes, cabal exec simple sets GHC_PACKAGE_PATH
19:24:54 <michaelt> calvinx: yeah of course. in a couple sandboxes i have an 'examples' sub directory and use alias ghc-sandbox="ghc  -package-db ../.cabal-sandbox/x86_64-osx-ghc-7.8.3-packages.conf.d"
19:25:10 <calvinx> AH… So GHC_PACKAGE_PATH is the key. gotcha.
19:25:15 <hexagoxel_> as you can see with `cabal exec -- sh -c set`
19:25:23 <hexagoxel_> (might be linux-specific, no idea)
19:25:43 <michaelt> Lokathor: why isn't it a fold? starting with 0
19:26:09 <dmwit> calvinx: There is also an environment variable you can set if your cabal sandbox is elsewhere.
19:26:18 <michaelt> Lokathor: you mean the distance traveled by someone who takes the whole path?
19:26:25 <Lokathor> yes
19:26:33 <Welkin> Lokathor: keep track of the previous point and subtract it from the current point, then update the su
19:26:36 <Welkin> sum*
19:27:09 <Lokathor> sounds like.. a job for manual recurion instead of a fold? or can a fold with a fancy lambda still do it?
19:27:15 <michaelt> foldr distance-function 0 mypoints
19:28:08 <michaelt> where distance_function (x,y) (x',y') = ...
19:28:12 <dmwit> I wouldn't even go as low-level as a fold.
19:28:13 <Lokathor> well the distance function takes 2 tuples and produces a double which would go into the total, and fold doesn't really do that
19:28:25 <Welkin> foldr (\x (previous, acc) -> (x, (x - previous) + acc)) ((Double,Double), Total) [(Double, Double)]
19:28:28 <dmwit> sum . map distance . ap zip tail
19:28:36 <michaelt> no wait,up too late..
19:28:42 <dmwit> :t \distance -> sum . map distance . ap zip tail
19:28:43 <lambdabot> Num c => ((b, b) -> c) -> [b] -> c
19:28:44 <michaelt> there we are...
19:29:33 <michaelt> yes a zip `ap` tail is very desirable here
19:30:02 <calvinx> dmwit: what’s that environment variable?
19:30:17 <hexagoxel_> ...
19:30:21 <calvinx> hexagoxel_: cabal: Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible with Cabal. Use the flag --package-db to specify a package database (it can be used multiple times).
19:30:32 <dmwit> calvinx: I don't know off-hand. The cabal manual will say; I always look it up there if I need it.
19:30:44 <glguy> path xs = sum (zipWith distance xs (tail xs))
19:30:46 <Lokathor> my ghci says Integer instead of Num c, is that normal?
19:30:59 <michaelt> it is defaultiing
19:31:10 <dmwit> glguy: nice
19:31:30 <dmwit> :t \distance -> sum . ap (zipWith distance) tail
19:31:30 <lambdabot> Num c => (b -> b -> c) -> [b] -> c
19:31:40 <Rufflewind> Is data-default used frequently in practice?
19:31:46 <dmwit> I use it a lot.
19:32:43 <michaelt> Rufflewind: to judge from random things I've cabal-installed, I'd say it turns up all the tim e
19:32:43 <glguy> I rearranged a dependency the other day to avoid data-default
19:32:47 <calvinx> so it looks like GHC_PACKAGE_PATH does not work. We either use —package-db or we use `cabal exec`.
19:33:02 <Rufflewind> dmwit, michaelt: thanks!
19:33:43 <michaelt> Rufflewind: some people object that it's sort of a hack, I think. But I think it doesn't make any great theoretical claims for itself.
19:34:18 <hexagoxel_> calvinx: can you paste in what way GHC_PACKAGE_PATH does not work?
19:34:23 <Rufflewind> michaelt: it seems convenient to have a common name for such a thing "def", instead of "defFoo", "defBar", etc
19:34:43 <michaelt> Convenient it certainly is.
19:35:04 <Rufflewind> I was thinking of using it for a complicated function with a large set of arguments (wrapped in a record data type)
19:35:18 <glguy> Leads to hard to read code and memorizing what the various def values are
19:35:36 <dmwit> Rufflewind: See also byorgey's post on the solution to the ad-hoc parameterization anti-pattern.
19:36:08 <michaelt> glguy, but even without 'data.default' people often define defaultMyGiantRecord
19:36:35 <Lokathor> I can't get these types to resolve as anything but integer
19:36:49 <dmwit> There's nothing stopping you from giving monomorphic names to def if there's a better name for it than defType.
19:36:58 <dmwit> Otherwise (def :: Type) reads just as nicely.
19:37:09 <dmwit> Lokathor: paste
19:37:12 <dmwit> ?lpaste
19:37:12 <lambdabot> Haskell pastebin: http://lpaste.net/
19:37:47 <Rufflewind> dmwit: that sounds like exactly what I was thinking!
19:38:12 <gamegoblin> Could one make Set a monad the same way List is a monad?
19:38:18 <gamegoblin> Or is there some issue I’m not seeing there
19:38:28 <EvanR> nope
19:38:30 <Welkin> gamegoblin: what do you mean?
19:38:44 <dmwit> gamegoblin: There is an annoying technical issue.
19:38:53 <n4x> how can you see all possible rules that could "match" some function? (
19:38:57 <dmwit> gamegoblin: Set requires an Ord instance to keep a balanced tree.
19:39:05 <dmwit> gamegoblin: Which isn't compatible with Monad's unconstrained method types.
19:39:06 <michaelt> Rufflewind: I was going to mention https://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/Options.hs#L329 as an example of someone just exporting defaultMyBigRecord, but I see it uses data.default not 'defaultWriterOptions'
19:39:19 <lpaste> Lokathor pasted “pathing problem” at http://lpaste.net/117722
19:39:19 <michaelt> I mean, now it does
19:39:23 <EvanR> alternatively the unordered version of Set requires elements to be hashable
19:39:24 <dmwit> gamegoblin: There's some stuff for "RMonad" on Hackage that attempts to deal with that problem.
19:39:27 <gamegoblin> dmwit: gotcha
19:39:32 <dmwit> gamegoblin: Though with a modern compiler you can do something much prettier.
19:39:42 <gamegoblin> dmwit: such as?
19:39:43 <Rufflewind> michaelt: I've seen libraries that do it w/out data-default
19:39:52 <dmwit> gamegoblin: Using constraint kinds, associated families, and default values for the associated families.
19:40:04 <michaelt> Rufflewind: yes, Pandoc used to.
19:40:18 <Rufflewind> michaelt: data-default saves a little bit of typing, "frobincate def" instead of "frobnicate defaultFrobincateArgs"
19:40:22 <gamegoblin> I guess I’ll just do a toList and fromList around my list do-notation voodoo
19:40:45 <dmwit> gamegoblin: Yep, that's a nice option.
19:41:02 <dmwit> gamegoblin: Especially since, in many cases, you don't want to coalesce options after *every* bind anyway, for the sake of streaming.
19:41:17 <dmwit> (There's a classic time/space tradeoff around where you put coalescing steps.)
19:41:27 <geekosaur> Lokathor, did you disable the monomorphism restriction? because with it enabled, pathA, pathBnorth, and pathBsouth will all end up with Integer defaulting
19:42:14 <benzrf>     
19:42:28 <Lokathor> well i had [(Double,Double)] on them, but took it off to see if that'd help by being less strict about the types
19:42:37 <michaelt> Lokathor: in recent ghci's it it turned off already
19:43:09 <Lokathor> my ghci is from the 2014.2 platform package
19:43:56 <augur_> btw if anyone's interested, the alpha version of Language Engine is now on github (it's built in Haskell underlying an Obj-C wrapper). more info in the tweet https://twitter.com/psygnisfive/status/551564619513626624
19:44:10 <vanila> oh augur_ I found a good example code that might be useful to you
19:44:14 <michaelt> Lokathor: anyway, you can do :set -XNoMonomorphismRestriction inside ghci
19:44:29 <augur_> vanila: oh?
19:44:34 <vanila> https://github.com/andrejbauer/plzoo/blob/master/src/calc/syntax.ml
19:44:42 <vanila> this is the trick I was meaning, about passing the precidence level
19:45:12 <geekosaur> I will note that this appears to be something you'd have in a file, and afaik ghci only disables the DMR for interactive code (that is, :seti -XNoMonomorphismRestriction)
19:45:20 <geekosaur> in recent ghc
19:45:25 <augur_> vanila: aha, ill give it a look
19:46:25 <Lokathor> still says it's (b -> b -> Integer) -> [b] -> Integer instead of using Num c
19:47:22 <michaelt> Lokathor: my ghci says dmwitPlan :: Num c => (b -> b -> c) -> [b] -> c
19:47:33 <Lokathor> yeah that's the problem :/
19:48:20 <michaelt> Lokathor: you can put :set -XNoMonomorphismRestriction in your .ghci file
19:48:27 <michaelt> if you like.
19:48:32 <Lokathor> i used that command and nothing changed
19:50:07 <michaelt> Lokathor: hm, I used the opposite :set -XMonomorphismRestriction and nothing changed... it's a little confusing...
19:50:16 <vanila> Congrats releasing Language ENgine!
19:50:19 <EvanR> what does a dashed arrow mean in a commuting diagram?
19:50:36 <EvanR> http://en.wikipedia.org/wiki/Coproduct like scroll down to diagram of X + Y
19:50:49 <EvanR> X1+X2
19:50:54 <dmwit> Think of that like an "output".
19:51:02 <dmwit> If you have all the solid lines, you get a unique dashed line.
19:51:34 <Lokathor> well this is highly puzzling, but for now using Integer will suffice i suppose
19:51:55 <EvanR> > succ (-1)
19:51:56 <lambdabot>  0
19:52:10 <EvanR> i guess Integer is not the natural number object in Hask ;)
19:53:13 <michaelt> Lokathor: put :set -XNoMonomorphismRestriction in $HOME/.ghci , I'd say.
19:53:55 <Lokathor> where... would that be on windows?
19:53:56 <michaelt> EvanR: the arrow for f in the preceding more general diagram is not dashed
19:54:09 <EvanR> i know, confusing
19:56:37 <dmwit> The meaning of a dashed line is established by convention or by mention.
19:56:56 <ReinH> EvanR: The dashed line represents the claim that the arrow exists given the rest of the diagram
19:57:07 <dmwit> ...and is unique
19:57:12 <dmwit> (As I said above.)
19:57:20 <ReinH> Which is similar to what dmwit said, but might help clarify why the previous f is not dashed
19:57:24 <EvanR> and is optional, as shown in the more general diagram
19:57:40 <ReinH> I'm not sure if the dash implies uniqueness
19:57:52 <EvanR> well in both cases the text says that that f is therefore unique
19:58:08 <ReinH> The dash basically means "exists"
19:58:11 <EvanR> and exists
19:58:13 <shachaf> Diagram like that hide a lot of information.
19:58:24 <ReinH> Sometimes \exists or !\exists are used instead
19:58:26 <michaelt> EvanR: I think ReinH 's theory can't explain the difference between the diagrams, but I suspect it's the reason the second diagram is so.
19:58:27 <shachaf> The dashed line means "exists unique", but there are a bunch of other quantifiers that people just don't write.
19:58:42 <ReinH> shachaf: Ah.
19:58:45 <ReinH> Fair enough.
19:59:07 <ReinH> shachaf: Hmm, that contradicts http://en.wikipedia.org/wiki/Commutative_diagram
19:59:21 <ReinH> Not that wikipedia is necessarily a normative source
19:59:24 <shachaf> nwf writes the quantifiers in http://www.cs.jhu.edu/~nwf/ctcheat/ctcheat.pdf
19:59:58 <michaelt> I see, trying to do it with the more general diagram would cause trouble, since it might be read as, for each such index there is a unique ...
19:59:58 <ReinH> also that cheat sheet is new to me, thanks
20:00:06 <shachaf> I wanted to write it with colors to distinguish the different parts of a diagram, e.g. http://slbkbs.org/cat.pdf
20:00:25 <ReinH> Well, that certainly is colorful
20:00:27 <michaelt> rather than, there is a unique arrow, such that for each index, etc.
20:00:51 <EvanR> nice sheet
20:01:00 <ReinH> The colors are helpful though.
20:01:08 <EvanR> the colors are hurting my head
20:01:16 <ReinH>  Helping and hurting.
20:01:24 <ReinH> Hurping.
20:01:47 <StoneCypher> ReinH: if you read jerkcity that's suddenly much worse btw
20:02:04 <shachaf> The point is: The product of two objects (green) is defined as: an object and a pair of projections (blue); such that for every other object and pair of "projections" (red); there exists a unique arrow h making the diagram commute.
20:03:09 <shachaf> When you're watching someone drawing the diagram, it's obvious, because you draw it in a particular order and you say what you mean as you draw it.
20:03:29 <shachaf> But when it's just written on paper, a lot of information isn't in the diagram itself.
20:04:48 <EvanR> somehow the coproduct was easier for me to understand than this one
20:05:23 <ReinH> shachaf: I like it
20:06:37 <EvanR> f:E->A g:E->B, basically this is talking about liftA2 (,) f g ?
20:06:53 <EvanR> 3..
20:07:27 <shachaf> liftA2?
20:07:28 <EvanR> something like (f,g)
20:07:40 <EvanR> as its own arrow
20:07:54 <shachaf> Oh, liftA2.
20:08:24 <shachaf> Yes.
20:09:04 <jonsterling> ReinH / shachaf : Regarding previous conversation on diagrams leaving quantifiers implicit, lest I become too snarky about it, I am reminded of how type theorists also leave the quantifiers implicit in judgements. (i.e. which part of a judgment is to be synthesized, which part is to be analyzed). Bob Harper in PFPL describes judgments as having a "mode",
20:09:05 <jonsterling> like (forall, forall, exists) where each quantifier corresponds to a slot in the judgement...
20:09:21 <EvanR> and by reversing this colorful diagram, the h would be a function that has a case for each possible case of a sum
20:09:38 <EvanR> which would be essentially the red arrows
20:09:42 <ReinH> jonsterling: that was snarky? I guess I don't understand TT snark? ;)
20:10:05 <shachaf> This definition of a product is equivalent to a natural bijection between a pair of arrows : E -> A and : E -> B and an arrow : E -> A×B
20:10:31 <shachaf> Of course, you have to have a meaning for "a pair of arrows" to do that. But that's not in the category you're defining a product in.
20:10:43 <jonsterling> ReinH: :) Well, I often complain about how category theorists seem to think that the proof is evident from a diagram when not even a single proposition can be decoded from the diagram without already knowing what it is meant to say, but I am a hypocrite... :
20:10:58 <ReinH> jonsterling: there it is
20:11:02 <jonsterling> hahaha
20:11:08 <shachaf> jonsterling: I think your complaint is pretty similar to mine.
20:11:17 <jonsterling> shachaf: yay, then I am in good company! :)
20:11:30 <ReinH> jonsterling: I believe the term of art is "obvious"...
20:11:38 <shachaf> But I complain about all sorts of things. Kids on my lawn and all that.
20:11:50 <ReinH> as in "squiggle squiggle squiggle squiggle naturality obvious"
20:12:02 <EvanR> armed with this then, how am i to understand an axiomatically defined category which "has products and coproducts". in particular what is the nature of the indexes used to form coproducts
20:12:08 <jonsterling> Without sufficient annotation, the diagram does not serve as a proof; it is a "reminder", so far as I can tell :)
20:12:08 <jonsterling> Sort of like the difference between a witness and a proof in type theory... (maybe)
20:12:20 <glguy> shachaf: The kids are back on your lawn??
20:12:30 <vanila> I think all proofs in math are just reminders in that sense
20:12:33 <ReinH> jonsterling: the shachaf-sterling equivalence?
20:12:48 <EvanR> so far ive only seen diagrams as part of a definition
20:12:55 <EvanR> not even a whole definition or a proof
20:13:03 <jonsterling> vanila: Probably so.
20:13:32 <jonsterling> EvanR: I don't know enough CT to even talk about it, so I should hush my mouth—but I often see people just draw a diagram and say, "Therefore blah is justified".
20:13:39 <EvanR> to answer my own question i guess its the same as the nature of the projection functions
20:14:03 <shachaf> jonsterling: It's a reasonable shorthand. There are lots of conventions in writing those sorts of diagrams.
20:14:30 <jonsterling> shachaf: Oh yes, I'm sure it's quite reasonable; I feel kind of left out when I don't get it, but I am sure that is more my fault than anything else :)
20:14:34 <shachaf> But I think it's not helpful as an introduction.
20:15:29 <EvanR> its half of almost all the definitions ive seen
20:15:46 <EvanR> even to the point of something like "blah blah blah" image( 1 -> A -> A )
20:15:52 <EvanR> on the line
20:16:13 <EvanR> i assume implying the diagram commutes
20:16:31 <EvanR> (1 -> A) o (A -> A) = (1 -> A)
20:16:44 <EvanR> or other way around
20:17:03 <vanila> There are different types of "just look at the diagram" proofs in category theory: (A) a claim that some composition is equal to another, to prove this you just check each square commutes - then since all the squares join up the whole thing commutes (B) this diagram has some specific shape that fits an earlier lemma which proves some property about the arrows in it
20:17:49 <vanila> I think you could turn (A) into a formal proof automatically, and (B) just given the hint which lemma to look for
20:18:13 <jonsterling> vanila: Good point. In (A), can you clarify what "all the squares join up" means?
20:19:50 <vanila> a simple case would be something like this: http://www.abstractmath.org/MM/Mathematica/Diagram%20Chasing/DC3.jpg - where you get alpha eta alpha = alpha Falpha Feta by joining the two squares into one square (after verifying each one commutes)
20:22:23 <calvinx> hexagoxel_: full explanation here - http://dpaste.com/38X63SD
20:23:09 <Javran> is it safe to build binaries inside a sandbox and move it somewhere else to use?
20:23:30 <Welkin> why not? it's just a binary
20:23:32 <EvanR> any idea what a "finite root" is?
20:23:51 <Welkin> a root that is not infinity?
20:24:47 <Javran> Welkin: not sure if the binary depends on some other libraries I don't have outside of the sandbox
20:25:08 <Welkin> it would only depend on system libraries, would it not?
20:25:16 <Welkin> all of the haskell code is gone once it's a binary
20:25:27 <Javran> Welkin: I see, thanks
20:25:46 <EvanR> on linux any libraries it needs to link will be in /lib or /usr/lib unless some shenanigans are going on
20:26:01 <EvanR> most things are statically linked by ghc but not really basic things
20:26:43 <Javran> just noticed the compiled pandoc binary takes 69M lol
20:28:33 <Javran> I previously have haskell packages installed as system packages, and ran into dependency hell tons of time.
20:29:11 <Javran> currently I decide to keep most of things inside a sandbox and just wondering whether it's safe
20:29:24 <Welkin> what do you mean by system packages?
20:29:40 <Welkin> you mean installed locally/globally rather than inside a sandbox?
20:29:46 <Javran> likes those provided by package manager
20:29:50 <Welkin> oh
20:30:04 <Welkin> don't use your package manager to install haskell libraries...
20:30:06 <Welkin> use cabal
20:30:13 <Javran> I use gentoo and have a haskell overlay
20:30:52 <Javran> yeah, I'm getting used to cabal
20:31:23 <Twey> Well, the Gentoo overlay uses Cabal anyway, it just wraps it so Portage knows about it
20:31:39 <Twey> But it does so with global packages, and Cabal can be a bit funny about those sometimes
20:33:37 <Javran> Twey: I guess the package manager messed up occasionally, sometime I have to remove a package and reinstall the exact version back to resolve some dependency issue.
20:34:09 <Twey> Javran: Is that after running haskell-updater?
20:34:32 <Twey> Javran: (see also #gentoo-haskell, by the way)
20:34:40 <Javran> Twey: no, some packages even block haskell-updater from running
20:34:49 <Twey> Ah, odd
20:35:12 * hackagebot amazonka-core 0.1.3 - Core functionality and data types for Amazonka libraries.  http://hackage.haskell.org/package/amazonka-core-0.1.3 (BrendanHay)
20:35:14 * hackagebot amazonka 0.1.3 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.1.3 (BrendanHay)
20:35:16 * hackagebot amazonka-autoscaling 0.1.3 - Amazon Auto Scaling SDK.  http://hackage.haskell.org/package/amazonka-autoscaling-0.1.3 (BrendanHay)
20:35:18 * hackagebot amazonka-cloudformation 0.1.3 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.1.3 (BrendanHay)
20:35:20 * hackagebot amazonka-cloudfront 0.1.3 - Amazon CloudFront SDK.  http://hackage.haskell.org/package/amazonka-cloudfront-0.1.3 (BrendanHay)
20:35:25 <Javran> Twey: https://github.com/gentoo-haskell/haskell-updater/issues/3 this one for example
20:35:46 <Welkin> success!
20:35:54 <Twey> I currently have no DNS lookup capabilities
20:35:56 <Welkin> lens installed
20:35:57 <Javran> Twey: seems broken packages are supposed to be installed in some order
20:36:02 <Welkin> alongside yesod
20:36:06 <Twey> But yes, that happens sometimes with Gentoo
20:36:47 <ezyang> I want to write a list comprehension like [ x | x <- xs, Just _ <- Map.lookup x m ]
20:36:53 <ezyang> but this doesn't type-check. Is there a way to do this?
20:37:10 <glguy> Just _ <- [Map.lookup x m]
20:37:17 <ezyang> ouch
20:37:21 <Javran> now I just have ghc and cabal in system, common stuff using cabal, others kept in sandboxes
20:37:30 <texasmynsted> anybody know of a library to access the Mac notification center?  I did not see anything in hackage
20:37:31 <Twey> Also: let Just _ = Map.lookup x m
20:37:32 <glguy> , Map.member x m
20:37:39 <shachaf> Twey: Not the same.
20:37:42 <Twey> Or that one
20:37:47 <EvanR> apparently, a diagram is a functor ;)
20:37:53 <Twey> shachaf: Oh, does that bottom?
20:38:08 <shachaf> I would hope so.
20:38:27 <Twey> Guess it does.
20:38:38 <ezyang> glguy: Well, it's not /actually/ a Map, I just thought that was an illustrative example
20:39:03 <glguy> ezyang: Well, I can only work with what you give me :-p but I think those are your two options
20:39:36 <Twey> I've never actually used the let syntax for list comprehensions… I think I'd rather expand it into something else if it gets complex enough that I feel the need to use lets.
20:40:22 * hackagebot amazonka-cloudsearch 0.1.3 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.1.3 (BrendanHay)
20:40:24 * hackagebot amazonka-cloudsearch-domains 0.1.3 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.1.3 (BrendanHay)
20:40:26 * hackagebot amazonka-directconnect 0.1.3 - Amazon Direct Connect SDK.  http://hackage.haskell.org/package/amazonka-directconnect-0.1.3 (BrendanHay)
20:40:28 * hackagebot amazonka-dynamodb 0.1.3 - Amazon DynamoDB SDK.  http://hackage.haskell.org/package/amazonka-dynamodb-0.1.3 (BrendanHay)
20:40:31 * hackagebot amazonka-ec2 0.1.3 - Amazon Elastic Compute Cloud SDK.  http://hackage.haskell.org/package/amazonka-ec2-0.1.3 (BrendanHay)
20:40:54 <w4pm> im reading 'learn you a haskell for great good' and this bit on foldl vs foldr doesnt quite make sense to me: "One big difference is that right folds work on infinite lists, whereas left ones don't! To put it plainly, if you take an infinite list at some point and you fold it up from the right, you'll eventually reach the beginning of the list. However, if you take an infinite list at a point and you try to fold it up from the left, you'll nev
20:41:11 <w4pm> doesnt foldr begin from the end of the list, and if so, how can an infinite list have an end
20:41:42 <vanila> foldr starts at the start of the list
20:41:56 <vanila> what it does is replace the cons (:) constructor with a function
20:42:03 <glguy> foldr f z (a:b:...) = f a (foldr z (b:...)
20:42:18 <glguy> foldr f z (a:b:...) = f a (foldr f z (b:...)) -- oops
20:42:27 <w4pm> oh i see
20:43:02 <Twey> > foldl f z [w, x, y] ∷ Expr
20:43:03 <lambdabot>  f (f (f z w) x) y
20:43:05 <Twey> > foldr f z [w, x, y] ∷ Expr
20:43:06 <w4pm> ive read some confusing descriptions of foldr then
20:43:06 <lambdabot>  f w (f x (f y z))
20:43:12 <w4pm> like this "it takes the second argument and the last item of the list and applies the function, then it takes the penultimate item from the end and the result, and so on"
20:43:17 <w4pm> but what you wrote makes sense, thanks
20:43:21 <Welkin> haha
20:43:39 <Welkin> foldr starts folding the list from the right
20:43:43 <Welkin> foldl folds from the left
20:43:49 <texasmynsted> recursive
20:43:54 <Twey> w4pm: Both foldl and foldr ‘start at the beginning of the list’, but the function is applied differently
20:43:56 <Welkin> it *folds* as in it applies the function to the element and the accumulator
20:44:15 <w4pm> they both start from the left of the list provided, thats what i was trying to understand
20:44:19 <w4pm> how they construct the output list is different
20:44:21 <w4pm> that makes sense
20:44:50 <texasmynsted> I believe it applies from the left but recursively so it would not be possible to unwind an infinite list with foldr
20:44:51 <w4pm> yeah im not thinking of the word fold properly
20:45:17 <Welkin> foldl begins folding right away
20:45:24 <Welkin> foldr doesn't start folding until it reaches the end
20:45:33 * hackagebot amazonka-elasticache 0.1.3 - Amazon ElastiCache SDK.  http://hackage.haskell.org/package/amazonka-elasticache-0.1.3 (BrendanHay)
20:45:35 * hackagebot amazonka-elasticbeanstalk 0.1.3 - Amazon Elastic Beanstalk SDK.  http://hackage.haskell.org/package/amazonka-elasticbeanstalk-0.1.3 (BrendanHay)
20:45:35 <texasmynsted> because it is recursive
20:45:37 * hackagebot amazonka-elastictranscoder 0.1.3 - Amazon Elastic Transcoder SDK.  http://hackage.haskell.org/package/amazonka-elastictranscoder-0.1.3 (BrendanHay)
20:45:39 * hackagebot amazonka-elb 0.1.3 - Amazon Elastic Load Balancing SDK.  http://hackage.haskell.org/package/amazonka-elb-0.1.3 (BrendanHay)
20:45:41 * hackagebot amazonka-emr 0.1.3 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.1.3 (BrendanHay)
20:46:16 <w4pm> yeah, so its like depth vs breadth first
20:46:18 <w4pm> foldl vs foldr
20:46:20 <w4pm> in some sense
20:47:00 <w4pm> Welkin: err isnt that reversed?
20:47:06 <w4pm> foldl doesnt start folding until it reaches the end
20:47:33 <ReinH> > foldl f z [a,b,c] :: Expr
20:47:34 <lambdabot>  f (f (f z a) b) c
20:47:38 <w4pm> yeah
20:47:42 <ReinH> > foldr f z [a,b,c] :: Expr
20:47:43 <lambdabot>  f a (f b (f c z))
20:47:46 <geekosaur> foldl builds up a list of incomplete thunks as it goes, and can only start reducing those when it hits the end. foldr, with a sufficiently lazy function, can produce results as it goes
20:47:48 <Twey> ReinH: Beat you to it :þ
20:47:54 <ReinH> Twey: damn
20:48:01 <texasmynsted> heh
20:48:08 <texasmynsted> :-)
20:48:09 <w4pm> yeah that make sense, folding from the 'right or left' is a little abstract/confusing
20:48:22 <w4pm> ok thanks
20:48:31 <ReinH> w4pm: but a bit easier to write than foldThatBuildsUpThunksAsItGoes
20:48:31 <Twey> w4pm: See how in the foldl expression, the *first* (outermost) call of the function needs the *last* (rightmost) argument?
20:48:41 <w4pm> ReinH: yeah :P
20:49:09 <ReinH> foldThatWithASufficientlyLazyFunctionCanProduceResultsAsItGoes (:) [] [1,2,3]
20:49:11 <EvanR> i always thought of foldr folding from the left, but 1) this probably doesnt help in actual usage and 2) depends how whether you read right to left or left to right ;)
20:49:39 <ReinH> EvanR: I suppose it also depends whether "left" means "right" or not.
20:49:39 <w4pm> i could just as easily see fold up or down
20:49:43 <w4pm> it makes about as much sense as that
20:49:57 <EvanR> ReinH: well thats just obvious.
20:49:59 <Welkin> I see it as where the folding function is first applied
20:50:03 <EvanR> joking
20:50:05 <solatis> @hoogle [[a]] -> [a]
20:50:06 <Welkin> with foldr it start with the last element
20:50:07 <lambdabot> Prelude concat :: [[a]] -> [a]
20:50:08 <Twey> w4pm, EvanR: The ‘left vs right’ terminology becomes clear if you look at it with an infix operator
20:50:08 <lambdabot> Data.List concat :: [[a]] -> [a]
20:50:08 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
20:50:13 <Welkin> with foldl it starts with the first element
20:50:20 <ReinH> Welkin: Um. The opposite?
20:50:29 <EvanR> Welkin: well it starts at the beginning because laziness
20:50:32 <Twey> > foldr (+) z [a, b, c]
20:50:32 <ReinH> foldr applies f to a immediately
20:50:34 <lambdabot>  a + (b + (c + z))
20:50:38 <Twey> > foldl (+) z [a, b, c]
20:50:39 <lambdabot>  z + a + b + c
20:50:43 * hackagebot amazonka-iam 0.1.3 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.1.3 (BrendanHay)
20:50:45 * hackagebot amazonka-importexport 0.1.3 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.1.3 (BrendanHay)
20:50:46 <ReinH> (+) is not a good example :(
20:50:47 * hackagebot amazonka-kinesis 0.1.3 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.1.3 (BrendanHay)
20:50:48 <Twey> Bah, Expr
20:50:49 * hackagebot amazonka-kms 0.1.3 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.1.3 (BrendanHay)
20:50:51 * hackagebot amazonka-lambda 0.1.3 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.1.3 (BrendanHay)
20:51:04 <EvanR> it would start reducing the expression if it was an eagerly evaluated language
20:51:05 <ReinH> foldr can't possibly start with the last element
20:51:08 <Welkin> > foldr f z [a,b,c] :: Expr
20:51:09 <EvanR> at the end
20:51:09 <lambdabot>  f a (f b (f c z))
20:51:18 <ReinH> > take 5 . foldr (:) [] $ [1..]
20:51:19 <lambdabot>  [1,2,3,4,5]
20:51:20 <ReinH> There is no last element
20:51:20 <Welkin> f c z is the first to be fully applied
20:51:23 <EvanR> ReinH: using seq in the f...
20:51:34 <w4pm> Welkin: in foldl yes
20:51:40 <Twey> Welkin, w4pm, EvanR: Anyway — if you imagine the brackets associating to the left for foldl, you have your -l vs. -r distinction
20:51:42 <Welkin> no, in foldr
20:51:56 <w4pm> no youre whats confusing me
20:51:59 <ReinH>  Welkin you've got them mixed up
20:52:00 <w4pm> f a is the firs tthing computed in foldr
20:52:04 <EvanR> Welkin: in f a (f b (f c z)), f a _ is getting evaluated first
20:52:11 <Welkin> w4pm: but it is a thunk
20:52:26 <Welkin> the first concrete value produced is fro the last element
20:52:27 <ReinH> everything is a thunk until it is evaluated
20:52:28 <texasmynsted> not according to lambdabot
20:52:35 <ReinH> Welkin: with foldr?
20:52:37 <w4pm> Twey: ok bracket association makes some sense
20:52:39 <EvanR> Welkin: there might not be a last element
20:52:49 <ReinH> Welkin: that's exactly wrong as I just showed you
20:52:55 <Twey> Welkin: No: GHC Haskell has lazy evaluation, so the ‘f a’ will be evaluated before the next argument
20:52:58 <EvanR> > take 4 (foldr (:) [] [1..])
20:53:00 <lambdabot>  [1,2,3,4]
20:53:09 <glguy> Welkin: The point is that  "f a _" can start producing a result without forcing that second argument
20:53:32 <texasmynsted> hm
20:54:05 <ReinH> This might be a bit more obvious:
20:54:07 <Welkin> if foldr started at the left, then foldr (:) [] [1..5] would be the same as reverse
20:54:07 <ReinH> > foldr const undefined [1,undefined]
20:54:09 <lambdabot>  1
20:54:09 <Twey> Welkin: In Haskell, an expression like ‘f x y’ evaluates ‘f x’ before it evaluates ‘y’ (if indeed it ever does)
20:54:31 <EvanR> 1 : (2 : (3 : ...
20:54:54 <EvanR> @src foldr
20:54:54 <lambdabot> foldr f z []     = z
20:54:54 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:55:00 <glguy> It isn't even important what the order of the arguments is:  f a _ vs f _ a
20:55:05 <texasmynsted> ok, so this is rather confusing
20:55:08 <Welkin> I know the definition
20:55:08 <ReinH> > foldl const undefined [1,undefined]
20:55:09 <lambdabot>  *Exception: Prelude.undefined
20:55:19 <Welkin> I am talking about the intuition of "right" vs "left"
20:55:24 <ReinH> Welkin: these have exactly the opposite of the behavior you are describing for them
20:55:29 <EvanR> well the order f is applied to the two arguments inside foldr is important
20:55:42 <EvanR> unless its typed to the same thing and commutative
20:55:53 * hackagebot amazonka-opsworks 0.1.3 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.1.3 (BrendanHay)
20:55:55 * hackagebot amazonka-rds 0.1.3 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.1.3 (BrendanHay)
20:55:55 <Twey> Welkin: You're thinking inside-out.  It does start at the left — but because the expression is evaluated from the outside in, it doesn't necessarily need to evaluate the right (inner) expression
20:55:57 * hackagebot amazonka-redshift 0.1.3 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.1.3 (BrendanHay)
20:55:59 * hackagebot amazonka-route53 0.1.3 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.1.3 (BrendanHay)
20:56:01 * hackagebot amazonka-route53-domains 0.1.3 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.1.3 (BrendanHay)
20:56:19 <Twey> Welkin: The innermost thing in the expression is not what is evaluated *first*, it is what is evaluated *last*
20:56:28 <glguy> EvanR: No, my point is that in general the order isn't what matters here
20:56:43 <Welkin> yes
20:56:58 <Welkin> I am not talking about the technical order of evaluation in the implementation
20:57:09 <Welkin> I am talking about "right" vs "left" conceptually
20:57:09 <EvanR> glguy: ok right. using a _ might be inappropriate
20:57:28 <EvanR> Welkin: ah, so precendence
20:57:31 <EvanR> thats different
20:57:37 <EvanR> precedence
20:57:47 <EvanR> different from evaluation order
20:57:57 <ReinH>  precedence?
20:58:15 <EvanR> in a finite expression f a (f b (f c d))) the f c d "is first"
20:58:23 <EvanR> but its not evaluated first, and of course might not even exist
20:58:33 <ReinH> in what way is it "first"?
20:58:41 <EvanR> i guess an extension of grade school arithmetic rules
20:58:47 <w4pm> without currying maybe
20:58:48 <ReinH> right/left are just a mnemonic device to help remember which way the subexpressions are grouped
20:58:58 <EvanR> i wasnt talking about left right
20:59:07 <EvanR> just "parentheses are first"
20:59:41 <EvanR> but nevermind this is totally backwards from school. which would be f(a,f(b,f(c,d)))
20:59:55 <EvanR> and students probably would lazily evaluated it ;)
21:00:14 <ReinH> if Haskell had different evaluation semantics it would be evaluated first
21:00:29 <ReinH> But it doesn't so it isn't ;)
21:00:36 <Welkin> ReinH: I am not talking at all about the implementation details of foldl/foldr
21:00:37 <EvanR> i was just trying to find some interpretation where its first
21:01:02 <Hafydd> As my Haskell teacher said, "Haskell uses laziness, which you as students will of course be familiar with."
21:01:03 * hackagebot amazonka-s3 0.1.3 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.1.3 (BrendanHay)
21:01:05 * hackagebot amazonka-sdb 0.1.3 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.1.3 (BrendanHay)
21:01:07 * hackagebot amazonka-ses 0.1.3 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.1.3 (BrendanHay)
21:01:09 * hackagebot amazonka-sns 0.1.3 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.1.3 (BrendanHay)
21:01:09 <ReinH> Welkin: but you are saying things that are untrue in any context
21:01:11 * hackagebot amazonka-sqs 0.1.3 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.1.3 (BrendanHay)
21:01:13 <Welkin> I am talking about a conceptual understanding of the difference between a left fold and a right fold, completely separate from haskell
21:01:39 <EvanR> i noticed this while attempting to understand this question
21:01:45 <EvanR> > scanr (+) 0 [1..5]
21:01:46 <lambdabot>  [15,14,12,9,5,0]
21:01:53 <EvanR> hope it confuses us even more ;)
21:02:02 <ReinH> When you said "the first concrete value produced is fro the last element", were you referring to foldl or foldr?
21:02:08 <Twey> > scanr (+) z [a, b, c]
21:02:10 <lambdabot>  [a + (b + (c + z)),b + (c + z),c + z,z]
21:02:17 <Welkin> foldr
21:02:20 <Twey> > foldr (+) z [a, b, c]
21:02:23 <lambdabot>  a + (b + (c + z))
21:02:38 <ReinH> Welkin: because that is not true of foldr for any definition of "concrete", "value", produced", or "last" that I can think of.
21:02:39 <EvanR> so scanr indeed "starts at the end" ;0
21:02:57 <w4pm> ..
21:02:59 <solatis> hmmm, i have a little question about something that, i think, can be solved using fmap
21:02:59 <Twey> EvanR: That *is* confusing.  Never noticed that before.
21:03:03 <EvanR> heh
21:03:05 <solatis> consider these two lines of code:
21:03:07 <solatis>     ciphers <- phase2 sockets
21:03:09 <ReinH> > foldr const undefined [1,undefined]
21:03:10 <solatis>     _       <- phase3 ciphers
21:03:11 <lambdabot>  1
21:03:16 <solatis> phase2 returns IO [Either a b]
21:03:23 <Welkin> ReinH: that is missing my point
21:03:23 <solatis> phase3 accepts [b]
21:03:35 <solatis> i know that in pure functions, i can use fmap for this
21:03:37 <ReinH> Welkin: then I have no idea what your point is since you are using words in a way I don't understand
21:03:39 <Welkin> I already said I am not talking about the implementation in haskell
21:04:00 <EvanR> Welkin: what right fold are you thinking of?
21:04:09 <Twey> solatis: phase2 sockets >>= phase3 . rights
21:04:13 <Twey> Err
21:04:18 <Twey> Yes
21:04:20 <SrPx> Browsing the official packages I've realized something about the lines of "pro" haskell code. It is 1/3 types signatures, 1/3 actual code and 1/3 {#- INLINE everythingPlx -#}
21:04:21 <texasmynsted> processing a list always has to start at the head and work to the tail right?
21:04:23 <solatis> Twey: that just discards the lefts :)
21:04:36 <solatis> i want to keep the lefts
21:04:45 <Twey> solatis: Oh.  What do you want to do with them?
21:04:48 <Welkin> a generic right fold, independent of any programming language or implementation details
21:04:57 <solatis> well, similar in how you propagate errors using fmap
21:05:00 <EvanR> texasmynsted: thats the only way to traverse a list, but you dont have to process it immediately that way
21:05:02 <ReinH> Welkin: how can you talk about evaluation order independent of evaluation semantics?
21:05:06 <texasmynsted> right
21:05:16 <EvanR> Welkin: yeah whats that
21:05:39 <texasmynsted> so you can process them in the order you pull them out or you can process them recursively.  Right?
21:05:39 <Welkin> > foldr f z [a,b,c] :: Expr
21:05:41 <lambdabot>  f a (f b (f c z))
21:05:42 <Welkin> just look
21:05:53 <EvanR> its folding from the left :\
21:05:53 <Welkin> where do you begin reducing the expression?
21:05:59 <EvanR> at the top
21:06:00 <shachaf> solatis: (ls,rs) <- partitionEithers <$> phase2 sockets
21:06:12 <ReinH> Welkin: Why are you using a Haskell example to describe something you have repeatedly said has nothing to do with Haskell?
21:06:13 * hackagebot amazonka-storagegateway 0.1.3 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.1.3 (BrendanHay)
21:06:14 <solatis> schlumpi: ah!
21:06:15 * hackagebot amazonka-sts 0.1.3 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.1.3 (BrendanHay)
21:06:16 <solatis> shachaf:
21:06:17 * hackagebot amazonka-support 0.1.3 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.1.3 (BrendanHay)
21:06:19 * hackagebot amazonka-swf 0.1.3 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.1.3 (BrendanHay)
21:06:40 <texasmynsted> So if you process in order left to right the final order will be reversed.
21:06:44 <Welkin> so then tell me
21:06:45 <Twey> solatis: So you want your entire computation to return an Either?  Left if there was a Left in the list, and Right otherwise?
21:06:52 <ReinH> Welkin: *In Haskell* you begin reducing it from the leftmost outermost  redex, which is f
21:06:53 <Welkin> what is the difference between a right fold and a left fold?
21:06:59 <Romefeller> Hello all!
21:07:09 <EvanR> texasmynsted: no. think about foldr (:) [] [1,2,3]
21:07:12 <ReinH> That's because this is how evaluation is defined for Haskell.
21:07:13 <solatis> Twey: the solution shachaf provided works in my case
21:07:14 <shachaf> I think this fold conversation is better suited to #haskell-overflow.
21:07:38 <ReinH> shachaf: or perhaps for /dev/null
21:07:50 <Twey> solatis: Ah, okay.  ☺
21:07:52 <EvanR> > foldl f z [a,b,c]
21:07:53 <lambdabot>  f (f (f z a) b) c
21:08:18 <EvanR> applies the f on the first arg instead of the second
21:08:29 <texasmynsted> why #haskell-overflow?
21:08:55 <shachaf> Because it's taking over this channel and interfering with other conversations.
21:09:00 <shachaf> Alternatively, other conversations are interfering with it.
21:09:04 <texasmynsted> hehheh ok
21:09:40 <EvanR> at and the main difference is it starts at the end of the list
21:09:42 <EvanR> ah*
21:10:11 <EvanR> so it .. folds left
21:10:23 <EvanR> all is right in the world
21:10:27 <texasmynsted> north wind comes from the north
21:10:48 <texasmynsted> fold left folds from the left
21:11:01 <EvanR> left folds on an infinite list therefore must fail to terminate
21:11:17 * ReinH sighs
21:11:22 <texasmynsted> lol
21:11:22 <EvanR> am i wrong?
21:11:29 <ReinH> EvanR: #haskell-overflow?
21:11:34 <EvanR> oh, have fun ;)
21:11:55 <texasmynsted> nobody else is there.  It is ready for the fun
21:12:21 <Welkin> I understand what you are saying
21:12:59 <Welkin> and yes, that makes sense
21:13:11 <Welkin> but I was trying to explain an alternative intuition
21:14:08 <Welkin> based on the first location where the original accumulator value is applied
21:14:13 <w4pm> so whats the summary? fold -left- -right-?
21:14:19 <w4pm> so foldl means all the action happens at the -left- position?
21:14:29 <glguy> the discussion continues in -overflow
21:24:04 <solatis> @hoogle [Either a b] -> Either a [b]
21:24:04 <lambdabot> No results found
21:24:16 <shachaf> sequence
21:24:17 <solatis> sounds like i maybe want to use the EitherT monad for that ?
21:24:26 <shachaf> Just regular Either
21:24:37 <solatis> i thought sequence was monadic?
21:24:40 <solatis> :t sequence
21:24:41 <lambdabot> Monad m => [m a] -> m [a]
21:24:43 <Iceland_jack> > sequence [Left a, Left b, Right c, Left d, Right e]
21:24:45 <lambdabot>  Left a
21:24:54 <solatis> thanks!
21:24:55 <Iceland_jack> > sequence [Right c, Right e]
21:24:56 <lambdabot>  Right [c,e]
21:25:10 <shachaf> "Either e" is a monad
21:25:23 <solatis> yeah stupid
21:25:29 <solatis> once i said it i realised my mistake
21:30:14 * hackagebot bencode 0.5.0.1 - Parser and printer for bencoded data.  http://hackage.haskell.org/package/bencode-0.5.0.1 (ChristopherReichert)
21:30:55 <mjrosenb> is a Data.ByteString.UTF8.ByteString the same thing as a Data.ByteString.ByteString?
21:31:20 <shachaf> It's the same type with different operations.
21:32:41 <mjrosenb> good.  that means that I can still pass the buffer from code that just uses Data.ByteString to something that wants to speak utf8, and I don't need to upgrade everything do Data.ByteString.UTF8.
21:33:00 <shachaf> (It's also a different package.)
21:35:09 <ostinato> hi, I'm working on some really basic haskell bindings for libao, but I'm doing something wrong as I can't get the example to work: https://github.com/basso-ostinato/hs-libao/blob/master/AOExample.hs  It's meant to imitate this: https://xiph.org/ao/doc/ao_example.c
21:35:50 <ostinato> I'm guessing it's because I'm crap at C :-(
21:37:01 <ostinato> pretty new at haskell too.  Anyone see anything I'm doing obviously wrong?
22:26:23 <jonasis> WattI do I now here
22:32:53 <Javran> wouldn't it be nice if DeriveTraversable implies DeriveFoldable and DeriveFunctor or something likewise?
22:35:03 <Javran> might be sometimes one need to implement some of them rather than deriving?
22:36:46 <shachaf> I think it wouldn't be unreasonable for the extension too imply the other extensions.
22:37:05 <shachaf> I'm not sure in what cases you'd want to derive Traversable and not Functor or Foldable.
22:37:17 <shachaf> Well, before that one bug was fixed I can think of a case.
22:37:36 <shachaf> But certainly it shouldn't be magically derived when you just write "deriving Traversable"
22:37:38 <agibiansky> shachaf: You can still use your own implementation instead of deriving one if you have Derive* on, right?
22:37:44 <shachaf> Yes.
22:37:56 <agibiansky> So what would be the issue with those extensions being on?
22:38:10 <shachaf> Not much.
22:38:19 <agibiansky> Actually, would there be any downside to just having all the Derive* extensions be always on, save "haskell 2010 compatibility"?
22:38:50 <agibiansky> (Not that I am necessarily suggesting that should be done, just wondering...)
22:39:09 <SharpGAF> Is there a Haskell 2010?
22:39:11 <shachaf> You could ask that about any extension.
22:39:52 <agibiansky> Fair enough. Most extensions tend to add more than "derive some more classes", but yeah.
22:39:59 <SharpGAF> Oh neat, there is.
22:40:32 <agibiansky> Is there a Haskell 2015 or Haskell 2016 planned?
22:43:07 <svercer> so I wanted to use +container Data.Map maps in a Writer, and I wondered if the sensible (Ord k, Monoid v) => Monoid (Map k v) was implemented... and it turns out instead it's "Ord k =>", and that mappend = union, which is left-biased. isn't this broken, not satisfying the monoid laws?
22:43:57 <agibiansky> svercer: How does it break the monoid laws?
22:44:22 <mzero> mempty = empty ... and so it is an identity no matter which side
22:44:29 <shachaf> svercer: It's not particularly broken -- it's like the First monoid.
22:44:48 <shachaf> svercer: A lot of people would prefer it to be the thing you said, but even those people don't want to silently break backwards compatibility like that.
22:44:54 <svercer> oh... well, I suppose that's right. maybe I'm just upset it's not the instance I would find useful =/
22:45:03 <svercer> is the best way to "fix" it to make a newtype wrapper?
22:45:08 <mzero> what you want is only a newtype away.....  :-)
22:45:17 * hackagebot mutable-containers 0.1.0.0 - Abstactions and concrete implementations of mutable containers  http://hackage.haskell.org/package/mutable-containers-0.1.0.0 (MichaelSnoyman)
22:45:18 <shachaf> newtype wrappers are scow
22:45:21 <mzero> yes -
22:45:26 <shachaf> But there isn't much better.
22:45:33 <mzero> (I'm not sure what a "scow" is...)
22:45:34 <svercer> is there a nice way to retain all of the functions, though?
22:45:45 <mzero> newtype wrappers are the way to go here
22:45:51 <shachaf> A sort of boat, but also an unpleasant thing.
22:46:33 <mzero> svercer: alas, not really - but if using it with writer... just wrap it just before writing it
22:46:44 <shachaf> You could make wrapper functions to make it convenient to use Writer (YourNewtype ...).
22:47:03 <shachaf> hi mzero
22:47:10 <mzero> hiho
22:47:18 <svercer> also, I just read that Data.Map.Strict.Map isn't actually strict in its traversable/functor instance... is that true?
22:48:33 <platz> are "extensible-effects" and "indexed monads" essentially the same thing?
22:48:57 <shachaf> The other day I was talking to someone about bayhac this year. Do you know anything about plans?
22:49:34 <mzero> shachaf: no - jonathan and I haven't started up -- but should soon
22:49:55 <ReinH> mzero: hi
22:50:13 <mzero> hi
22:51:07 <mjrosenb> It looks like there isn't a monad dfinition for Either String (possibly because one cannot be written
22:51:09 <platz> or is it they just share some overlap that allows them both to model effect systems but with different machinery
22:51:21 <mjrosenb> Is there a monad definition for anything equivalent?
22:53:26 <mzero> isn't there an Monad instance for Either String in Control.Monad.Error?
22:53:32 <mzero> or some such place?
22:53:50 <Hijiri> there is a Monad instance for Either a
22:54:06 <pingu> mzero: yes, there is
22:54:09 <pingu> somewhere
22:54:23 <mzero> well, there ya go, mjrosenb
22:54:39 <Hijiri> are you looking for a monad instance for Either String separate from the one for Either a?
22:54:46 <pingu> Hijiri: that wasn't always there, I swear.
22:54:50 <pingu> I think it's new.
22:54:54 <mzero> well, there can't be, eh?
22:55:10 <EvanR> :k Either String
22:55:11 <lambdabot> * -> *
22:55:17 <Hijiri> if there was a separate Either String monad instance it would overlap with the prelude
22:55:22 <mzero> ah, there it is... in Data.Either
22:55:43 <Hijiri> it's in the prelude too
22:56:15 <mzero> now, if I recall, it didn't use to be in the Prelude... but
22:56:22 <mzero> we digress...
22:56:28 <Hijiri> maybe it was added at some point
22:56:32 <mzero> mjrosenb: did we get you what you needed?
22:58:51 <mjrosenb> ahh, Control.Monad.Error is almost certainly what I want.
22:59:11 <benzrf> :k MonadTrans
22:59:12 <lambdabot> ((* -> *) -> * -> *) -> Constraint
22:59:21 <benzrf> :t lift
22:59:22 <lambdabot> (MonadTrans t, Monad m) => m a -> t m a
23:02:50 <solatis> :t hoistEither
23:02:51 <lambdabot> Not in scope: ‘hoistEither’
23:03:00 <solatis> :t EitherT
23:03:01 <lambdabot> Not in scope: data constructor ‘EitherT’
23:03:08 <solatis> ok anyway
23:03:14 <solatis> EitherT is EitherT e m a
23:03:20 <solatis> can anyone enlighten me what m is ?
23:03:31 <tac_> m is the inner monad in the stack
23:03:36 <solatis> so that can be IO ?
23:03:38 <tac_> Yes
23:03:42 <tac_> It can be any monad you please
23:03:57 <solatis> ok
23:04:19 <tac_> @type runEitherT
23:04:20 <lambdabot>     Not in scope: ‘runEitherT’
23:04:20 <lambdabot>     Perhaps you meant ‘runWriterT’ (imported from Control.Monad.Writer)
23:04:23 <tac_> I think is what it's called
23:04:25 <tac_> f. it
23:04:50 <tac_> http://hackage.haskell.org/package/EitherT-0.2.0/docs/Control-Monad-Trans-Either.html
23:04:54 <tac_> runEitherT :: m (Either l a)
23:05:22 <tac_> So EitherT e IO a would be an IO action which could return an error
23:05:33 <solatis> ahhh good
23:05:38 <solatis> then that is what i'm looking for
23:06:13 <solatis> and runEitherT makes sure i 'exit' my control flow if one of the functions returns a Left, right ?
23:06:35 <solatis> (sorry, i'm still trying to grasp how to elegantly handle errors in a continuation style)
23:06:57 <solatis> i probably should rather say 'the rest of the functions are not executed'
23:07:11 <tac_> Yeah. Further actions would not be run
23:07:30 <Javran> that's might be what MonadPlus does?
23:09:40 <Javran> not seeing "Either a" being an instance of MonadPlus though, is there any reason?
23:10:34 <tac_> > Left "hello" <> Right "world"
23:10:35 <lambdabot>  No instance for (Data.Monoid.Monoid
23:10:35 <lambdabot>                     (Data.Either.Either [GHC.Types.Char] [GHC.Types.Char]))
23:10:35 <lambdabot>    arising from a use of ‘Data.Monoid.<>’
23:10:47 <Javran> ah I see, no way to implement mzero?
23:11:18 <solatis> hmmm
23:11:20 <solatis> ok
23:11:25 <solatis> so, i have a large chain of actions
23:11:27 <EvanR> in the monomorphism restriction, what monomorphism is it referring to?
23:11:36 <solatis> all actions can return an Either
23:11:41 <tac_> It's the not-actually-a-monomostrphism kind
23:11:48 <EvanR> cool
23:11:50 <solatis> is this something that EitherT solves, or should i look at applicative?
23:11:55 <tac_> EvanR: There are things called "monomorphisms" in category theory. They are unrelated
23:12:06 <Hijiri> Javran: maybe you could do mzero with a monoid restriction on e
23:12:11 <tac_> The Monomorphism restriction refers to the fact that your types are monomorphic (not polymorphic)
23:12:16 <mzero> EvanR: the monomorphism restriction is that top level declarations that have no arguments must be monomorphic
23:12:17 <Hijiri> and mzero would be Left mempty
23:12:19 <tac_> at the top level*
23:12:23 <EvanR> tac_: ok thats what i was wondering
23:12:25 <tac_> Unless explicitly typed
23:12:26 <mzero> so it refers to the top level thing
23:12:47 <SrPx> Is there a "scanl" for trees? It should follow different paths and generate a tree too...
23:12:48 <mzero> increment = (+1)
23:13:07 <shachaf> mzero: OK.
23:13:08 <mzero> that runs afoul of the monomorphism restriction - as (+1) isn't monomorphic
23:13:15 <tac_> The monomorphism restriction is one of the worst design mistakes in the original language
23:14:07 <shachaf> The monomorphism restriction is a reasonable decision given a tricky trade-off.
23:14:10 <tac_> It's best to turn it off in your .ghc file, and lock it away forever
23:14:16 <tac_> except for that one day you work in an unfamiliar dev env
23:14:22 <Javran> Hijiri: i see, or otherwise we need a default value or something like that
23:14:32 <tac_> and you realize after half an hour of pain and suffering that it's the monomorphism restriction causing your pain
23:15:14 <shachaf> With the MR on, problems manifest themselves as compile-time errors. You learn what it is once and then you recognize it easily wherever it comes up. It's mildly annoying.
23:15:28 <EvanR> in other words, top level CAFs are monomorphic?
23:15:39 <shachaf> With the MR off, problems manifest themselves as silent runtime (asymptotic) inefficiencies.
23:15:54 <MP2E> yeah, i'd much rather have it on >_>
23:15:59 <shachaf> Debugging lack of sharing which looks like it should obviously be happening is much less fun.
23:16:28 <tac_> shachaf likely understands the issue deeper than I do here
23:16:47 <fugyk> How to fix this: can't load .so/.DLL for: libHSvector-0.10.12.2.dylib (dlopen(libHSvector-0.10.12.2.dylib, 9): image not found)
23:16:48 <shachaf> Which isn't to say that the MR *should* be on by default, but it's a trade-off and thought was put into it.
23:16:50 <mzero> EvanR: I don't think the MR applies to top level CAFs that the compiler hoisted on it's own
23:17:17 <EvanR> like what?
23:17:47 <mzero> just saying that if you are profiling, the compiler might have lifted something out to a top-level CAF, and it might not be monomorphic
23:17:52 <shachaf> The MR is a language/report-level concept. CAFs aren't.
23:18:09 <mzero> what shachaf said
23:18:17 <shachaf> By the way, "not monomorphic" isn't quite right. It's "not monomorphic with a type class constraint".
23:21:03 <mbuf> I downloaded HSH-2.1.2.tar.gz, extracted and did "cabal configure; cabal build; cabal install". It installed in ~/.cabal. I am able to run ghci> :m + HSH, but, doing runIO "date" returns not in scope; what am I missing?
23:21:04 <Welkin> how do you update records with lens?
23:21:45 <pavonia> fugyk: Do you modfy DYLD_FALLBACK_LIBRARY_PATH in your .bash_profile or elsewhere?
23:22:08 <EvanR> does this notation mean anything in category theory (), ()^A, 1 -> (), the () part
23:23:05 <fugyk> No, thanks but I have solved it by `cabal install --reinstall --enable-shared vector`
23:23:08 <tac_> () is usually a terminal element
23:23:20 <EvanR> well, thats 1
23:23:26 <tac_> Yeah
23:23:41 <EvanR> k nevermind
23:24:30 <tac_> Did you think you saw it elsewhere?
23:25:09 <EvanR> in this paper it uses ()^A in only one place without explanation
23:25:20 * hackagebot mutable-containers 0.1.1.0 - Abstactions and concrete implementations of mutable containers  http://hackage.haskell.org/package/mutable-containers-0.1.1.0 (MichaelSnoyman)
23:25:25 <tac_> Odd. Do you have a link?
23:25:37 <tac_> Naively, I would think it means "functions A -> ()"
23:25:42 <EvanR> http://www.tac.mta.ca/tac/reprints/articles/11/tr11.pdf you know, maybe its just missing the content of the big parentheses
23:26:17 <EvanR> axiom 2 on page 8
23:26:33 <tac_> ah
23:26:42 <EvanR> maybe that means - (dash) which i also dont know
23:26:46 <tac_> That is the (-)^A
23:26:47 <tac_> yep
23:26:59 <tac_> You might write it Hom(A, -)
23:27:28 <EvanR> wth is -
23:27:58 <tac_> It's effectively a lambda
23:28:06 <tac_> \b -> Hom(A, b)
23:28:23 <tac_> It is a placeholder for the parameter you'd plug in
23:28:36 <EvanR> any object?
23:28:43 <tac_> namely, it is the function (or functor) that takes an object in your category to the exponential object
23:28:54 <tac_> Yes
23:28:54 <Welkin> it's ((->) e)
23:29:10 <tac_> The important part of the axiom is that exponential objects exist
23:29:17 <pavonia> mbuf: Is runIO listed when you do :browse HSH?
23:29:40 <benzrf> internal hom?
23:29:43 <tac_> Yes
23:29:44 <EvanR> tricky busines
23:29:53 <tac_> It is essentially the topos axioms
23:29:56 <tac_> I believe
23:30:12 <tac_> In category theory, objects and morphisms live "at different levels"
23:30:18 <Welkin> benzrf: how do I shot lens?
23:30:29 <benzrf> Welkin: press z or r twice
23:30:31 <Welkin> I mean, update records
23:30:38 <Welkin> using lens
23:30:42 <tac_> Exponentials give you a way to take a Homset and get a Hom-"objet" out of it
23:30:44 <tac_> or vice versa
23:30:50 <benzrf> an objet
23:30:54 <benzrf> is that like an oejet
23:31:06 <tac_> Probably an example would help.... Do you know the basics of linear algebra? Matrices and vectors?
23:31:10 <benzrf> 02:25 <%ruukasu> >half of disk is burned
23:31:10 <benzrf> 02:25 <%ruukasu> >mfw
23:31:14 <benzrf> crap, mispaste
23:31:36 <Welkin> data Game = Game { player1 :: Player, player2 :: Player }
23:31:43 <benzrf> Welkin: look are you asking me to give you a tutorial on lens. there are lots
23:31:55 <Welkin> data Player = Player { health :: Int, strength :: Int }
23:31:56 <benzrf> do u want an intro to the denotational semantics, of lenses
23:32:03 <Welkin> for those data structures
23:32:18 <Welkin> I want to update the value of player1^.health -= damage
23:32:29 <benzrf> your doing it wrong
23:32:32 <benzrf> :t (-=)
23:32:33 <lambdabot> (MonadState s m, Num a) => ASetter' s a -> a -> m ()
23:32:35 <Welkin> or, -~ damage
23:32:38 <benzrf> the first should be a lens
23:32:39 <Welkin> :t (-~)
23:32:40 <lambdabot> Num a => ASetter s t a a -> a -> s -> t
23:32:55 <benzrf> ASetter' or w/e but you probably intend to pass it a lens
23:32:56 <Welkin> how do I update that nested value?
23:33:03 <benzrf> Welkin: gib lens]
23:33:07 <Welkin> this is a pure function
23:33:12 <benzrf> Welkin: gib lens
23:33:20 <Welkin> what is gib lens?
23:33:27 <benzrf> gib is terrible internet speak for "give"
23:33:32 <Welkin> I assumed
23:33:38 <Welkin> I already made them lenses
23:33:38 <tac_> EvanR: btw, ##categorytheory and ##math are also good for asking those kinds of quesitons
23:33:39 <benzrf> Welkin: give me a lens that points at what you are interested in
23:33:54 <mbuf> pavonia, yes in HSH.Command.runIO
23:33:58 <EvanR> i asked a question in ##math earlier ...
23:34:14 <EvanR> but good to know
23:34:34 <benzrf> Welkin: (-=) wants a lens on the left hand side
23:34:43 <benzrf> Welkin: what is a lens that points to the thing you are updating
23:34:46 <Welkin> > ((1,2),3)^._1._1 -~ 1
23:34:48 <lambdabot>  Could not deduce (GHC.Num.Num
23:34:48 <lambdabot>                      (Control.Lens.Setter.ASetter s t a0 a0))
23:34:48 <lambdabot>    arising from the ambiguity check for ‘e_1123111’
23:35:03 <benzrf> :t _1._1 -~ 1
23:35:04 <lambdabot> (Field1 a1 b a a, Field1 s t a1 b, Num a) => s -> t
23:35:05 <Welkin> > ((1,2),3)^._1._1 .~ 0
23:35:06 <lambdabot>  Could not deduce (GHC.Num.Num
23:35:07 <lambdabot>                      (Control.Lens.Setter.ASetter s t a0 b0))
23:35:07 <lambdabot>    arising from the ambiguity check for ‘e_1123110’
23:35:20 <benzrf> Welkin: do you know what (^.) does
23:35:29 <Welkin> it is a getter
23:35:30 <benzrf> Welkin: you can't just blindly mix and math :v
23:35:33 <benzrf> Welkin: ok, so
23:35:42 <benzrf> Welkin: what is ((1,2),3)^._1._1
23:35:46 <Welkin> 1
23:35:55 <benzrf> Welkin: so why are you trying to -~ that
23:36:04 <Welkin> how do I update the value?
23:36:39 <Taneb> > ((1,2),3) & _.1._1 -~ 1
23:36:40 <lambdabot>  Found hole ‘_’
23:36:40 <lambdabot>    with type: b0 -> ((t1, t2), t0) -> Data.Functor.Identity.Identity b
23:36:40 <lambdabot>  Where: ‘t0’ is an ambiguous type variable
23:36:42 <mbuf> pavonia, if I now do, :m + HSH, it tells me attempting to use module `HSH' (./HSH.hs) which is not loaded
23:36:45 <Taneb> > ((1,2),3) & _1._1 -~ 1
23:36:46 <lambdabot>  ((0,2),3)
23:37:28 <benzrf> Welkin: (-~) takes a lens and a value and produces an updating function
23:37:30 <pavonia> mbuf: Did you restart GHCi after installing the package?
23:37:45 <benzrf> > let update = _1._1 -~ 1 in update ((1, 2), 3)
23:37:47 <lambdabot>  ((0,2),3)
23:37:54 <benzrf> Welkin: (&) is just flip ($)
23:37:59 <benzrf> hence, Taneb's example
23:38:22 <mbuf> pavonia, yes; I am removing my ~/.cabal and ~/.ghc//x86_64-linux-7.6.3/package.conf.d/HSH-* and trying again
23:38:31 <ruukasu> benzrf: nice meme
23:38:44 <Welkin> okay
23:38:48 <Welkin> I got that working now
23:38:57 <Welkin> so how about inside the State monad?
23:39:04 <benzrf> ruukasu: :(
23:39:08 <benzrf> Welkin: use (-=)
23:39:12 <benzrf> :t (-=)
23:39:13 <lambdabot> (MonadState s m, Num a) => ASetter' s a -> a -> m ()
23:39:16 <pavonia> mbuf: Not sure if this is a good idea
23:39:22 <Welkin> well yes, I tried that
23:39:26 <Welkin> but I must be missing something
23:39:31 <benzrf> Welkin: takes a setter (lens works for that) and a decrement value
23:39:41 <benzrf> and returns a m (), for any MonadState <the num type> m
23:39:52 <benzrf> Welkin: what are you doing curently
23:39:53 <Welkin> for my data structure above Game (Player ...) (Player ...)
23:40:10 <mbuf> pavonia, yes, you are right; broken lot of packages
23:40:25 <Welkin> game^.player2 .= newPlayer
23:40:32 <Welkin> something like that
23:40:43 <pavonia> :S
23:40:46 <Welkin> game is the state s
23:41:05 <benzrf> Welkin: so
23:41:14 <benzrf> Welkin: what types should arguments of (.=) have?
23:41:32 <Welkin> :t (.=)
23:41:33 <lambdabot> MonadState s m => ASetter s s a b -> b -> m ()
23:41:46 <Welkin> I don't understand the lens types at all
23:42:08 <benzrf> Welkin: ASetter s s a b is something that can be used to set some b in an s
23:42:20 <benzrf> Welkin: a "Lens' s b" works for this
23:42:36 <Myrl> Guys, what are good Haskell exercieses?
23:42:38 <benzrf> Welkin: the 2nd arg should be a "b"
23:42:39 <Myrl> exercises*
23:42:43 <benzrf> Welkin: i.e., the value to set it to
23:42:47 <benzrf> Welkin: then the result is a state action
23:42:53 <Welkin> okay, I get that part
23:43:18 <benzrf> Welkin: so what types should the args have
23:43:22 <benzrf> Welkin: and what types /do/ they have
23:43:31 <Welkin> :t (^.)
23:43:32 <lambdabot> s -> Getting a s a -> a
23:43:49 <Welkin> that is type a
23:44:03 <benzrf> Welkin: ??
23:44:21 <benzrf> Welkin: a is some variable that is instantiated when you call (^.)
23:44:29 <benzrf> Welkin: (^.) does not return a value of type "a"
23:44:32 <Welkin> yes
23:44:36 <Welkin> in my case it is Player
23:44:39 <benzrf> kk
23:44:50 <benzrf> so the 1st arg has type Player
23:44:54 <benzrf> that is already a problem :|
23:44:58 <Welkin> I see
23:45:18 <Welkin> how do I use it properly then?
23:45:21 * hackagebot relational-query 0.3.0.3 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.3.0.3 (KeiHibino)
23:45:28 <benzrf> Welkin: what type /should/ the first arg have?
23:45:29 <Welkin> just player2?
23:45:33 <Welkin> that should be a lens
23:45:37 <benzrf> Welkin: from what to what?
23:46:21 <Welkin> Lens' s Player -> Player -> State s ()
23:46:22 <Welkin> ?
23:46:43 <benzrf> yeh, that's one valid specialized type for (.=)
23:47:10 <Welkin> how do I access values that are nested deeper though?
23:47:16 <benzrf> use a stronger lens
23:47:20 <mbuf> pavonia, okay, I removed ~/.ghc and ~/.cabal, and re-built, re-installed HSH again, running ">:m + HSH" gives attempting to use module `HSH' (./HSH.hs) which is not loaded
23:47:23 <Welkin> what if I want to update the health of the player inside the game
23:47:29 <Welkin> game.player.health
23:47:44 <Welkin> how do I get that lens when there are two possible players?
23:47:50 <mbuf> pavonia, :browse HSH lists the functions though
23:48:04 <benzrf> Welkin: huh?
23:48:38 <pavonia> mbuf: Oh, are you running GHCi from that package's source directory?
23:48:39 <Welkin> hm
23:48:49 <Welkin> player2 .= newVal
23:48:52 <Welkin> that doesn't work either
23:49:04 <mbuf> pavonia, yes; if I write a program and run it from /tmp, it works though
23:49:46 <mbuf> pavonia, okay, ghci>:m + HSH and ghci> runIO "date" works from a different directory
23:49:48 <pavonia> Okay, then you need to :load the module first
23:50:04 <mbuf> pavonia, why doesn't it work from the source directory?
23:50:38 <benzrf> Welkin: what type is player2?
23:50:41 <benzrf> Welkin: what type is newVal
23:51:13 <Welkin> player2 is my lens
23:51:15 <Welkin> or it should be
23:51:20 <Welkin> newVal :: Player
23:51:24 <pavonia> mbuf: Because it sees that there is a module with that name in the directory and uses this one, but as it is source code, you need to load the code before you can use it
23:52:12 <Welkin> can't I compose lenses together?
23:52:21 <Welkin> player2.health ?
23:52:31 <mbuf> pavonia, thanks for your help! appreciate it
23:52:59 <Welkin> :t ((1,2),3)._1._1
23:53:00 <lambdabot>     Couldn't match expected type ‘(s0 -> f t3) -> c’
23:53:00 <lambdabot>                 with actual type ‘((t1, t2), t0)’
23:53:00 <lambdabot>     In the first argument of ‘(.)’, namely ‘((1, 2), 3)’
23:55:21 * hackagebot mutable-containers 0.1.2.0 - Abstactions and concrete implementations of mutable containers  http://hackage.haskell.org/package/mutable-containers-0.1.2.0 (MichaelSnoyman)
23:56:12 <Welkin> I guess I don't understand how makeLenses works
23:56:33 <Welkin> player2 :: Functor f => (Player -> f Player) -> Game -> f Game
23:56:40 <Welkin> is what ghci tells me
23:56:48 <benzrf> Welkin: player2 :: Lens' Game Player
23:57:12 <benzrf> Welkin: type Lens' s a = Functor f => (a -> f a) -> s -> f s
23:57:23 <Welkin> okay
23:57:33 <Welkin> so why doesn't it work?
23:57:44 <benzrf> Welkin: well, what's the type of player2 .= newVal
23:58:08 <Welkin> player2 .= Player 20 32 30 :: Control.Monad.State.Class.MonadState Game m => m ()
23:58:28 <benzrf> Welkin: i'd recommend making that a little more monomorphic
23:58:33 <benzrf> Welkin: do you have a MonadState instance in mind
23:58:47 <mbuf> I have cabal version 1.16.0.2 installed. Which version of cabal provides the sandbox feature?
23:59:03 <Welkin> well, this is outside of the State Game Game I made
23:59:11 <Welkin> this is just from ghci
23:59:16 <hrnz> 1.18!
23:59:23 <Welkin> I would normally execute this inside of State Game Game
23:59:31 <Welkin> or, State Game ()
23:59:41 <benzrf> Welkin: ok
23:59:56 <benzrf> Welkin: and is State Game () a valid type to use where you are putting this expression
