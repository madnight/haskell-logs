00:31:35 <ph88> anyone know this error?? https://github.com/Peaker/lamdu/issues/27  https://github.com/Peaker/lamdu/blob/master/Lamdu/Sugar/Types.hs#L491
01:29:36 <sgronblo> http://hackage.haskell.org/package/QuickCheck-2.7.6/docs/Test-QuickCheck-Monadic.html what sad documentation
01:33:22 <Cale> You don't like the paper? :)
01:34:22 <SrPx> I have a type like that : " data Tree a = Node [Tree a] | Leaf [a] " -- Does anyone know a quick way to pretty print that, with identation, other than creating the print function myself?
01:34:58 <Cale> You could transform it somehow to a Data.Tree sort of tree
01:35:41 <SrPx> I have tought that, but the form is kinda different... hmm... the transformation to a free monad is straighforward but I guess nobody made a printer for them, right
01:36:10 <Cale> That module is mostly useless apart from the fact that it has drawTree
01:36:19 <ab9rf> a generalized printer for a multibranch tree?  fun.
01:37:55 <Cale> If you were going to write one by hand, you could use a pretty printing library like http://hackage.haskell.org/package/wl-pprint
01:39:52 <mr-> Cale: there is zipper module using Data.Tree, though, making it somewhat more useful
01:43:41 <sgronblo> Cale: i think last time i tried the link was broken
01:44:03 <sgronblo> and i am not sure i have a ps2pdf available even
01:44:17 <Cale> I just clicked the link and it opened
01:44:36 <sgronblo> in what?
01:44:40 <Cale> Evince
01:45:16 <sgronblo> ok os x preview could actually open it too
01:46:02 <sgronblo> but the user experience sucks
01:46:14 <sgronblo> these methods could just have been properly documented
01:46:17 <Arahael> And .ps doesn't work on android or ios.
01:46:32 <sgronblo> of course id rather have this than nothing
01:49:03 <tasker> Is there some easy way to get multiline strings working?
01:49:24 <ab9rf> what doesn't wokr about multiline strings?
01:50:27 <tasker> I have just copied a largeish string that I want to use for testing, and it complains about newlines.
01:50:40 <tasker> I wondered what the easiest way to get this working was.
01:50:45 <ab9rf> "it"?
01:50:50 <tasker> compiler
01:51:28 <ab9rf> so you opened a string constant on one line and closed it on another?
01:51:32 <tasker> yes
01:51:46 <ab9rf> replcae the hard newline with \n
01:52:00 <ab9rf> "hello,\nworld"
01:52:47 <sgronblo> I tried to use forAllM but am getting a parse error on run
01:53:56 <tasker> ab9rf: Yep, that worked. Cheers.
02:00:30 <sgronblo> cool, it was just a mistake with indentation
02:00:46 <sgronblo> it seems i was able to make sense of how to do it just by looking at the type
02:01:10 <Cale> Yeah, most of the stuff in that module is pretty obvious just from the type :)
02:01:29 <Cale> (It would be good to have short descriptions though)
02:04:34 * hackagebot statsd-datadog 0.2.0.0 - DataDog-flavored StatsD client.  http://hackage.haskell.org/package/statsd-datadog-0.2.0.0 (AlexanderBondarenko)
02:09:34 * hackagebot pgdl 6.2 - pgdl  http://hackage.haskell.org/package/pgdl-6.2 (sifmelcara)
02:11:42 <SrPx> very interesting lib Cale
02:13:04 <tasker> I have some json that looks like { 'type' : 'sometype', 'data' : {..thedata..}}. I want to parse data using aeson, conditional on the value of sometype. How can I do this?
02:18:11 <akuhlens> Any ideas on why I might be getting undefined symbol _iconv at the final stage of building idris with FFI and GMP? -- http://pastebin.com/kGthHxKz
02:46:18 <SrPx> that library is epic.
02:49:15 <temoto> Hello, wonderful people.
02:54:58 <ph88> anyone know this error?? https://github.com/Peaker/lamdu/issues/27  https://github.com/Peaker/lamdu/blob/master/Lamdu/Sugar/Types.hs#L491
02:59:16 <temoto> ph88: does this help? https://www.haskell.org/haskellwiki/Kind
02:59:36 * hackagebot quoridor-hs 0.1.1.2 - A Quoridor implementation in Haskell  http://hackage.haskell.org/package/quoridor-hs-0.1.1.2 (talw)
02:59:46 <ph88> temoto: ill have a look
03:00:48 <ph88> temoto: its not related to the package
03:04:36 * hackagebot extensible 0.2.5 - Extensible, efficient, lens-friendly data types  http://hackage.haskell.org/package/extensible-0.2.5 (FumiakiKinoshita)
03:06:19 <temoto> ph88: speaking with example, you are trying to pass `Maybe Bool` where just `Maybe` is expected, to derive makeMonoid.
03:06:54 <ph88> temoto: no no, this is not my software. im just a user
03:11:32 <temoto> ph88: ah ok, I'm not good with this but it seems that code is actually correct, so maybe you could try with another version of GHC.
03:11:33 <tasker> Is there a way to hide an instance from a package?
03:11:52 <tasker> Specifically, can I hide FromJSON UTCTime from Aeson somehow ?
03:12:55 <ph88> temoto: yes i think it works with an older version of ghc, but i just uninstall that one because another package need a newer version :(  however i did backup my .cabal folder  ... can i find the compiled binary in there ?
03:14:59 <ph88> hhmm nope nothing in there
03:15:04 <ph88> i guess it wasn t compiled before
03:15:31 <ph88> why is the compiler not backwards compatible ?
03:17:00 <barrucadu> It mostly is, but sometimes bugs get fixed
03:17:44 <temoto> ph88: compiled binary is usually in dist/build/{package}/
03:17:58 <quchen> tasker: No, you cannot hide instances. It's related to the "open world assumption".
03:18:02 <temoto> in package directory
03:18:16 <quchen> tasker: If you want a different instance for a type, you'll have to newtype-wrap it.
03:18:19 <tasker> quchen: Dang. I guess I could create a type synonym or something ;S
03:18:25 <tasker> Right
03:18:33 <temoto> ph88: however, you can also look for precompiled package.
03:18:50 <temoto> ph88: are you on linux/amd64 by chance?
03:19:20 <ph88> unbuntu 14.10  not sure if 64bits
03:19:36 <tomphreek> uname -a
03:19:39 <ph88> i think so actually because i installed that new haskell platform with 64bits
03:20:04 <quchen> tasker: The reason for this is that typeclasses are open, i.e. you can never say "these are the only instances of this class". When you define one instance in one module and another one in another, *all* uses of the typeclass become ambiguous.
03:20:12 <ph88> yes its 64bits
03:20:39 <ph88> i thought the compiled binary gets moved into the .cabal folder
03:21:06 <ph88> it was just a temporary directory i was using so i deleted it after
03:24:37 * hackagebot pgdl 6.3 - pgdl  http://hackage.haskell.org/package/pgdl-6.3 (sifmelcara)
03:25:49 <tasker> quchen: Hm, okay. So is this why people tend to say orphan instances are bad ?
03:26:06 <quchen> tasker: Exactly.
03:26:36 <quchen> Orphan instances mean that types may behave differently depending on what (unrelated!) package you import.
03:29:37 * hackagebot cgrep 6.4.10 - Command line tool  http://hackage.haskell.org/package/cgrep-6.4.10 (NicolaBonelli)
03:44:38 * hackagebot pgdl 6.4 - pgdl  http://hackage.haskell.org/package/pgdl-6.4 (sifmelcara)
03:59:38 * hackagebot pgdl 6.5 - pgdl  http://hackage.haskell.org/package/pgdl-6.5 (sifmelcara)
04:03:44 <akuhlens> Any ideas on why I might be getting undefined symbol _iconv at the final stage of building Idris with FFI and GMP? -- http://pastebin.com/kGthHxKz
04:09:39 * hackagebot cgrep 6.4.11 - Command line tool  http://hackage.haskell.org/package/cgrep-6.4.11 (NicolaBonelli)
04:29:39 * hackagebot hxt 9.3.1.12 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.3.1.12 (UweSchmidt)
04:44:40 * hackagebot cgrep 6.4.12 - Command line tool  http://hackage.haskell.org/package/cgrep-6.4.12 (NicolaBonelli)
04:55:35 <untseac> Hey
04:55:45 <quchen> Hello sir.
04:55:50 <untseac> How do I know the precedence of haskell operators?
04:55:58 <quchen> :i in GHCi shows the precedence
04:56:02 <untseac> thanks
04:56:19 <quchen> Or you can look at the Haddock documentation, "infixl 3" stands for "left-associative with precedence 3" for example
04:57:02 <untseac> ok, I like the :i method, simple and efficient
05:05:00 <narendraj9> We are starting a local Haskell group. So, I want to know about application areas that we can show people to make them interested in Haskell. What are the must-have things on the list?
05:05:55 <narendraj9> Please provide links to resources that will be helpful.
05:10:01 <untseac> I'm just starting out but I guess one of the advantages is that you can reuse a lot of code without worrying with side effects. At least to me that's a big advantage.
05:13:26 <narendraj9> Yes, Haskell lets us build abstraction layers within the language and it's great to see it happening. It's a nice thing but it is mainly about the language itself.
05:15:45 <mpickering> https://www.fpcomplete.com/business/resources/case-studies/
05:15:50 <narendraj9> Euterpea is cool. But that requires us to know Music, maybe. I am looking for things like Euterpea. Maybe, examples that use some Machine Learning.
05:17:42 <mpickering> http://dreixel.net/research/pdf/fmmhaia_pres_ifip14.pdf
05:27:24 <narendraj9> Sorry, I got disconnected.
05:27:27 <Norfair> :t id
05:27:28 <lambdabot> a -> a
05:27:32 <Norfair> :t id . id
05:27:32 <lambdabot> c -> c
05:27:42 <Norfair> :t id ( id )
05:27:42 <lambdabot> a -> a
05:27:45 <Norfair> hm :p
05:28:06 <Norfair> :t (id) id (id)
05:28:07 <lambdabot> a -> a
05:28:13 <Norfair> :t id.id.id
05:28:14 <lambdabot> c -> c
05:28:18 <Norfair> wierd
05:28:24 <barrucadu> What's weird?
05:28:44 <Norfair> I expected something like (a->a) -> (a->a)
05:28:54 <Norfair> but now I can't remember why
05:29:24 <vanila> :t ($) . ($)
05:29:25 <lambdabot> (a -> b) -> a -> b
05:29:47 <Norfair> :t (.) . (.)
05:29:48 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
05:29:58 <Norfair> :t ($).($).($)
05:29:59 <lambdabot> (a -> b) -> a -> b
05:30:08 <Norfair> :t $$$
05:30:09 <lambdabot> parse error on input ‚Äò$$$‚Äô
05:30:11 <Norfair> :t $ $ $
05:30:11 <lambdabot>     parse error on input ‚Äò$‚Äô
05:30:11 <lambdabot>     Perhaps you intended to use TemplateHaskell
05:30:25 <Norfair> I saw someone run into a memory error
05:30:35 <Norfair> because of an exponentially growing type signature
05:30:37 <Norfair> at compile time
05:30:43 <Norfair> but now I can't seem to reproduce it
05:31:17 <n4x> :t id id
05:31:19 <lambdabot> a -> a
05:31:28 <n4x> heh
05:31:37 <Norfair> :t id id id
05:31:38 <lambdabot> a -> a
05:32:57 <narendraj9> id x can be replaced with x for all x. Function application associates to the left.
05:32:59 <Norfair> :t let f= id id id in f 8
05:33:00 <lambdabot> Num a => a
05:34:03 <Norfair> http://stackoverflow.com/questions/23746852/why-does-haskells-do-nothing-function-id-consume-tons-of-memory
05:34:08 <Norfair> this is what I was talking about :)
05:34:53 <Norfair> but now I also know why I can't reproduce it with lambdabot :D
05:35:26 <Norfair> or is there a way to find the type of a _part_ of an expression?
05:37:35 <narendraj9> > ((iterate id id) !! 100) 12
05:37:37 <lambdabot>  12
05:38:22 <Norfair> :t (iterate id id) !! 5
05:38:23 <lambdabot> a -> a
05:38:39 <Norfair> :t ((iterate id id) !! 5) 12
05:38:40 <lambdabot> Num a => a
05:38:45 <Norfair> :t ((iterate id id) !! 15) 12
05:38:46 <lambdabot> Num a => a
05:38:50 <Norfair> stil goes fast :-
05:39:42 * hackagebot cake3 0.6.0 - Third cake the Makefile EDSL  http://hackage.haskell.org/package/cake3-0.6.0 (SergeyMironov)
05:39:44 * hackagebot quickcheck-assertions 0.2.0 - HUnit like assertions for QuickCheck  http://hackage.haskell.org/package/quickcheck-assertions-0.2.0 (AlekseyUymanov)
05:40:06 <narendraj9> This is interesting.
05:40:29 <narendraj9> What exactly happens when we compile the code? Why isn't it happening in ghci?
05:41:58 <Norfair> it does happen in ghci
05:42:11 <Norfair> let f = id id id id id id id
05:42:14 <Norfair> pint f 8
05:42:25 <Norfair> print f 8 (of course)
05:43:05 <Norfair> print $ f 8 (damn)
05:43:34 <Norfair> it hangs, as expected
05:43:53 <narendraj9> (f 8) prints he value for me. It doesn't hang.
05:44:01 <Norfair> use more id's :p
05:44:28 <narendraj9> I used around 15.
05:44:43 <Norfair> 2^15 is still pretty small ...
05:44:46 <Norfair> > 2^15
05:44:48 <lambdabot>  32768
05:44:49 <Norfair> :p
05:45:22 <Norfair> and it will hang on the let f = id ...
05:45:25 <Norfair> not on the print :)
05:46:29 <narendraj9> I just composed my f with fifteen ids five times. It hangs on a call.
05:46:58 <narendraj9> Okay. Let's wait for someone to explain this properly. :-D
05:47:00 <Norfair> aha, but composition is not the same as just putting id's behind eachother
05:47:27 <Norfair> what you did can be (not) be evaluated lazily
05:47:31 <narendraj9> Yes. but that makes 15 * 4 ids.
05:47:40 <narendraj9> 15 * 5 ids.
05:47:46 <Norfair> did you do
05:47:48 <Norfair> f f f f
05:47:52 <Norfair> or f . f . f . f?
05:47:56 <narendraj9> 2 ^ 75
05:48:02 <narendraj9> f . f . f . f
05:48:09 <Norfair> well that's just the same as one
05:48:13 <Norfair> try let g = f f f f
05:48:53 <narendraj9> This would make the ids grow exponentially. I get it.
05:48:59 <felixsch> is there a function like !! which returns a maybe instead of raising an error?
05:49:25 <Norfair> in the safe package
05:49:36 <Norfair> it's called indexMay, I think
05:49:41 <vanila> @free (a,b) -> b
05:49:42 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
05:49:43 * hackagebot unsafeperformst 0.9 - Like unsafeperformIO, but for the ST monad.  http://hackage.haskell.org/package/unsafeperformst-0.9 (AtzeVanDerPloeg)
05:49:45 * hackagebot unsafeperformst 0.9.1 - Like unsafeperformIO, but for the ST monad.  http://hackage.haskell.org/package/unsafeperformst-0.9.1 (AtzeVanDerPloeg)
05:49:54 <vanila> @free snd :: (a,b) -> b
05:49:54 <lambdabot> g . snd = snd . $map_Pair f g
05:49:58 <Norfair> https://hackage.haskell.org/package/safe-0.3/docs/src/Safe.html
05:49:59 <Norfair> atmay
05:50:58 <felixsch> Norfair: ah nice! thank you :)
05:51:25 <Norfair> you're welcome, this is the first time that I've been able to help anyone instead of being helped :p
06:17:03 <bmuk> Hey everyone, I have a Maybe ([a] -> a) that I need to map over a [[a]]. How do I do this?
06:17:50 <shachaf> What is it that you want to do?
06:18:33 <fjolsvidr> Hello #haskell, can somebody using Vim please share what plugin they use to do indentation properly?
06:19:51 <emre_> Use Emacs for Haskell maybe?
06:19:59 <bmuk> I have a Table data structure, which is comprised of a list of Strings (the headers), and a list of lists of a (the rows in the table). I'm trying to write a readColumn function, which would find all the rows which match a query ([a] -> Bool) and return a list of all of the values of those rows under a particular header
06:21:46 <kranius> fjolsvidr: here is a list of various vim plugins for haskell work : https://gist.github.com/kranius/08e9ca0ae6b9d4100d7f
06:22:50 <bmuk> shachaf: I already have a readRow function, which returns a list of rows which match a query (i.e. select *), and I'm trying to map over that
06:23:18 <bmuk> so far I have > fmap (flip (!!)) $ elemIndex headerName headers
06:23:35 <notdan> bmuk: are you trying to write something like this: http://paste.hskll.org/get/2003 ?
06:23:40 <Norfair> @bmuk, can you pastebinit?
06:23:40 <lambdabot> Unknown command, try @list
06:24:00 <fjolsvidr> kranius: Are you using any of them at the moment? I've tried vim2hs and haskellmode-vim, neither managed to indent as good as emacs does and I don't want to learn emacs just because of haskell
06:24:15 <Norfair> you should learn emacs anyway :p
06:24:16 <shachaf> bmuk: I guess I didn't ask the right question.
06:24:44 * hackagebot handsy 0.0.4 - A DSL to describe common shell operations and interpeters for running them locally and remotely.  http://hackage.haskell.org/package/handsy-0.0.4 (utdemir)
06:24:59 <bmuk> shachaf: what do you mean?
06:25:01 <shachaf> No editor wars in this channel, please.
06:25:12 <Norfair> I didn't mean to start an editor war
06:25:14 <bmuk> and I'll just push what I have to github
06:25:16 <Dodek> hey, how to generate lenses for a library record type? i usually use $(makeLenses ''Foo) for my types, but the library ones doesn't have their names underscored
06:25:27 <shachaf> bmuk: Is ([a] -> Bool) the ([a] -> a) function you were talking about?
06:25:28 <Dodek> i mean, the record fields
06:25:31 <fjolsvidr> I don't want to start a war either, but this feels like the best place to ask such a question
06:25:37 <Norfair> true
06:25:40 <Norfair> I use stylish
06:25:46 <Norfair> but that only fixed import indents
06:25:47 <bmuk> shachaf: no, that's the query which is handled by readRow
06:25:49 <kranius> fjolsvidr: I use 'haskell-vim-now'
06:25:51 <bmuk> hang on
06:26:03 <kranius> fjolsvidr: can't compare with emacs as I don't use it
06:26:17 <shachaf> bmuk: You should give an example, e.g. of a particular f :: Maybe ([a] -> a) and x :: [[a]] of what you're after.
06:26:20 <fjolsvidr> kranius: Haven't tried that one yet, thanks
06:26:32 <bmuk> https://github.com/bmuk/PipeDBHs
06:26:35 <shachaf> Or enough examples to figure out the behavior, because it's not obvious from the types.
06:27:04 <bmuk> shachaf: the fmap (flip (!!)) $ elemIndex... is the Maybe ([a] -> a)
06:27:35 <shachaf> That sounds dreadfully inefficient on linked lists, but OK.
06:27:53 <JagaJaga> Guys, what is going to be return and >>= for ((->) r)?
06:28:10 <shachaf> Your first question was self-contained, which is fine, you just need to clarify it a bit more for people to figure out what you want.
06:28:17 <jophish> Is it appropriate to allocate memory in Storable poke?
06:28:35 <shachaf> What if the Maybe ([a] -> a) is Nothing?
06:28:38 <jophish> for example if I were saving to a struct like struct S {unsigned length; int* data;}
06:28:44 <bmuk> shachaf: OK. I realize it's inefficient for large lists; is there a better way to do what I'm trying to do
06:28:53 <bmuk> shachaf: then it should return Nothing
06:29:28 <shachaf> OK, so a good first step is to say what the type of the thing you want to end up with is.
06:29:41 <bmuk> I realize it
06:29:48 <shachaf> Let's say you have (Just sum) and [[1,2,3],[4,5,6],[7,8,9]]. What do you want to end up with?
06:29:55 <shachaf> And Nothing for the same list?
06:29:59 <bmuk> it's [a] now, maybe it should be Maybe [a]?
06:29:59 <notdan> JagaJaga: return = const; f >>= g = \x -> g (f x)
06:30:29 <shachaf> Oh well, I can't help you.
06:30:43 <JagaJaga> notdan: yeah! thank you, helped a lot.
06:31:17 <bmuk> shachaf: I'm sorry. Did I do something wrong?
06:31:44 <shachaf> I don't think so?
06:31:58 <bmuk> oh; you said you couldn't help me
06:32:19 <bmuk> I interpreted that as my question was unclear or something
06:32:47 <panda__> is it a woman's intelligence relative to a man's could be seen as - or a woman's intelligence relative to a mans could be seen as?
06:36:09 <JagaJaga> Oh, may be someone knows the cps transform of Either?
06:40:49 <notdan> JagaJaga: what do you mean exactly?
06:41:09 <bmuk> maybe I am going about this the wrong way - would it be better for me to describe the functionality I want and someone can help me get there?
06:41:16 <notdan> CPS of the Either datatype?
06:41:22 <JagaJaga> notdan: yep
06:41:35 <notdan> It's (a -> r) -> (b -> r) -> r
06:41:37 <notdan> for Either a b
06:42:46 <funfunctor> what would give me CUInt -> Word32 ?
06:44:15 <JagaJaga> notdan: nooooo, that can't be so easy :(( Thank you! And maybe you can help me to get monad instance for it?
06:44:57 <jophish> What's the reason why Storable a => Storable [a], with peekArray and pokeArray
06:45:37 <jophish> I suppose there isn't a single choice for sizeOf
06:47:48 <supki> funfunctor: fromIntegral
06:48:55 <funfunctor> supki: thx! will that return Word32 or Int ?
06:49:24 <funfunctor> oh its polymorphic I guess
07:01:35 <funfunctor> supki: I have a monadic binding to a C library I wrote that controls hardware. In order to print results I need to have liftIO . putStrLn everywhere in my program which is fairly annoying. Any suggestions on how that is usually dealt with?
07:02:00 <funfunctor> I guess I could put printBladeRF = liftIO . putStrLn into the library
07:02:45 <funfunctor> everything becomes a big fat io monad :'(
07:09:05 <notdan> JagaJaga: you want a monad instance for a CPS version of Either?
07:09:22 <notdan> JagaJaga: I think you can get it from the monad of plain old Either
07:09:46 * hackagebot ghc-exactprint 0.1.0.0 - ExactPrint for GHC  http://hackage.haskell.org/package/ghc-exactprint-0.1.0.0 (AlanZimmerman)
07:13:23 <Beardful> I have functions with IO magic, if they take too long, is it possible that they don't get executed ?
07:16:05 <notdan> JagaJaga: I think it should look like this: http://paste.hskll.org/get/2005
07:17:28 <Beardful> This happens when using OpenGL binding. And the functions work individually.
07:17:39 <notdan> JagaJaga: this illustrates the usage: http://paste.hskll.org/get/2006
07:18:14 <notdan> Beardful: maybe there is an issue of blocking?
07:18:19 <notdan> or some underlying opengl issues
07:19:43 <Beardful> notdan: That would be weird, because the functions are just comparing numbers.
07:23:42 <NightRa> I need a function like Map.unionWith, which doesn't constrain all the values to the same type.
07:23:44 <NightRa> unionWith :: Ord k => (a -> a -> a) -> Map k a -> Map k a -> Map k a
07:23:54 <NightRa> unionWith' :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
07:23:59 <NightRa> ^ This is what I need
07:24:04 <NightRa> Is there such a function?
07:24:38 <dfeuer> I'm dealing with a module that exports a (<>) function. This strikes me as rather obnoxious, since it clashes with Data.Monoid. It seems to make sense to make the type a Monoid instance to clear that up, but then do I DEPRECATE that function, or do I re-export Data.Monoid.<> ?  Either way can potentially break code.
07:25:58 <benmachine> dfeuer: is its <> a monoidal operation?
07:26:23 <dfeuer> benmachine, yes, it is.
07:27:04 <dfeuer> benmachine, there are actually two monoidal operations; the other is named <+>, which may or may not clash with anything, but doesn't clash with anything so obnoxiously important.
07:27:15 <dfeuer> ER ...
07:27:23 <dfeuer> sorry, that's not the other monoidal on.
07:27:24 <dfeuer> one.
07:27:53 <geekosaur> only in xmonad >.>
07:28:29 <dfeuer> The other monoidal one has a weird name, (//)
07:29:09 <dfeuer> geekosaur, that's an unlikely conflict here :-P
07:30:35 <Geraldus> Hi, folks!
07:31:47 <Geraldus> Finally, I can't understand, is there some way to make GHC-MOD working with GHC 7.8.3 and cabal-1.22?
07:32:03 <benmachine> dfeuer: I think re-exporting <> seems like a reasonable way forward, although it is indeed a breaking change
07:33:24 <dfeuer> benmachine, the main problem I envision with that approach is that some people will get redundant import warnings.
07:34:21 <dfeuer> (I'm not worried about the risk of type inference trouble; things are very, very concrete in this neck of the woods.]
07:34:56 <NightRa> Geraldus: I have lost so much time today because of it
07:34:58 <NightRa> Isn't there a (Monoid Double) instance?!
07:35:03 <bg__> if you have an intermediate function in a where clause, is it possible to get the type signature for it with :t ?
07:35:05 <dfeuer> I hope not.
07:35:20 <dfeuer> > 3.5 `mappend` 4
07:35:22 <lambdabot>  No instance for (GHC.Show.Show a0)
07:35:22 <lambdabot>    arising from a use of ‚ÄòM656225721058290530614830.show_M6562257210582905306...
07:35:22 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
07:35:32 <dfeuer> > 3.5 `mappend` (4::Double)
07:35:33 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Double)
07:35:33 <lambdabot>    arising from a use of ‚ÄòData.Monoid.mappend‚Äô
07:35:35 <Geraldus> it's pity
07:36:04 <geekosaur> which Monoid did you want?
07:36:10 <NightRa> Sum
07:36:19 <dfeuer> Yes, there is that one!
07:36:19 <NightRa> So there's the Sum newtype
07:36:24 <benmachine> there's also product and max and min
07:36:29 <NightRa> > 1 <> 2
07:36:30 <dfeuer> > Sum 3.5 <> Sum 4
07:36:31 <lambdabot>  No instance for (GHC.Show.Show a0)
07:36:31 <lambdabot>    arising from a use of ‚ÄòM263242146188019541814880.show_M2632421461880195418...
07:36:31 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
07:36:32 <lambdabot>  Sum {getSum = 7.5}
07:36:39 <hop__> Hello, I was looking at codegen with llvm. I put the code here: https://gist.github.com/anonymous/a4b82687ed5985d22bcb
07:37:44 <hop__> Hello, I was looking at codegen with llvm. I put the code here: https://gist.github.com/anonymous/a4b82687ed5985d22bcb LLVM backend is used and as you can see two routines are generated. One seemingly uses AVX and the other one not. Debugging the code with gdb I can see that the one wiht no avx saupport is used while my processor supports AVX. Are you aware of this?
07:38:18 <hop__> This is llvm backend specific. Is there some dynamic dispatching based on proc type with llvm backend?
07:38:47 <dfeuer> hop__, everything to do with the instruction level is totally separate for LLVM.
07:39:21 <dfeuer> hop__, I *think* you can tell GHC what options to pass to LLVM.
07:39:33 <dfeuer> But I'm not sure.
07:40:09 <hop__> dfeuer: There is a problem here clearly. Code bloat is OK but clearly the code is unused and I think it should.
07:45:10 <alpounet> dfeuer: yeah it's possible, https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/options-phases.html -- ctrl+f "-optlo" and "-optlc"
07:45:50 <dfeuer> hop__, ^^
07:50:02 <ezrios> So I am reading John Hughes' "Why Functional Programming matters"
07:50:16 <NightRa> ezrios: I love this paper!
07:50:22 <ezrios> on page 18, he covers alpha-beta pruning, but I feel that there is a typo in what he has written
07:50:34 <ezrios> minimize (Node n Nil ) = n
07:50:36 <ezrios> minimize (Node n sub) = max (map maximize sub)
07:50:47 <ezrios> shouldn't it be `minimize (Node n sub) = min (map maximize sub)`? Or do I misunderstand
07:50:53 <anti-freeze> Does any one know of any good presentation on the practical applications of haskell for beginners? On youtube or something?
07:51:13 <ezrios> anti-freeze: try "Haskell in the Newsroom" maybe?
07:51:28 <temoto> How to define quickcheck Gen String to construct a combination from predefined words? Say I have [prefix1, prefix2], [middle1, middle2], [suffix1, s2, s3] and want {any prefix} ++ {any middle zero or more times} ++ {any suffix zero or one time}.
07:51:30 <NightRa> ezrios: yeah, probably
07:51:51 <ezrios> NightRa: ok, so it's not just me
07:51:55 <ezrios> thanks! it's a great paper
07:52:14 <temoto> ignore space intercalation from term `words`
07:53:21 <hop__> dfeuer: both functions appear in the LLVM file. So, ghc seems to be the one to output them both. I am reading the code to see how the dispatch is done. I may just be confused. Let's see :-)
07:53:44 <dfeuer> Good luck.
08:07:34 <stepkut> is there a program that will analyze a cabal package and find all the unreachable/dead code?
08:11:54 <dramforever> Weird thing: I just found out that some people think . and $ like separators, not operators
08:12:04 <dramforever> they think it's part of the syntax
08:14:34 <dramforever> Example 1: (possible misunderstanding) http://www.reddit.com/r/haskell/comments/2tgeh1/putstrln_show_x_vs_putstrln_show_x/
08:15:24 <dramforever> Example 2: (Chinese) Title means "What does the separators $ and . mean in haskell?", link here for referencehttp://tieba.baidu.com/p/3109047649
08:16:24 <hop__> dfeuer: there is nothing to do with avx. avx code is executed and some test is done and the slightly slower routine is run instead of the other one. Not sure why. There is some kind of dispatch based on one of the arguments which does not exist in the legacy backend. Would you know who can show me where to look in GHC? I am just curious to understand more codegen and in particular llvm one. I am going to reread the paper first. Maybe s
08:16:45 <dfeuer> hmmm
08:17:07 <dfeuer> No, hop__, I would not. Your best bet might be to ask in #ghc if you're looking into those kinds of internals.
08:17:35 <hop__> dfeuer: OK. I'll try again. The channel seems less active than this one though :-) Thanks for your help!
08:18:35 <dfeuer> hop__, you can also email glasgow-haskell-users or ghc-devs, or perhaps file a bug report.
08:22:47 <osa1> any ideas how to connect to "unix domain sockets"? I guess I can't do that using `network`, right?
08:23:03 <dramforever> osa1: Network.Socket
08:23:04 <dramforever> maybe
08:23:18 <osa1> I can't see any relevant function in Network.Socket
08:23:27 <osa1> dramforever: you mean the `network` package, right?
08:23:48 <mniip> osa1, there's no any relevant functions
08:23:51 <dramforever> osa1: yep
08:23:52 <mniip> there's a relevant constructor though
08:24:02 <dramforever> I think PortID has UnixSocket
08:24:06 * quchen recommends network-simple over directly using network.
08:24:12 <dramforever> :t Network.UnixSocket
08:24:13 <lambdabot> String -> Network.PortID
08:24:29 <mniip> osa1, http://hackage.haskell.org/package/network-2.6.0.2/docs/Network-Socket.html#t:SockAddr
08:24:33 <dramforever> osa1: you can use that when you need a PortID
08:25:10 <osa1> mniip, dramforever: many thanks
08:25:27 <dramforever> osa1: Are you using Network or Network.Socket?
08:26:03 <osa1> dramforever: I'm writing the code right now but they're both in same package...
08:26:23 <dramforever> anyway...ask if you have more problems
08:26:58 <osa1> dramforever: I think I'll use Netowkr.Socket, I don't think I need PortID at least for now
08:27:32 <dramforever> osa1: how about this:
08:27:37 <dramforever> :t Network.Socket.socket
08:27:37 <lambdabot> network-2.4.2.2:Network.Socket.Types.Family -> network-2.4.2.2:Network.Socket.Types.SocketType -> network-2.4.2.2:Network.Socket.Types.ProtocolNumber -> IO network-2.4.2.2:Network.Socket.Types.Socket
08:28:36 <dramforever> you use Family = AF_UNIX, SocketType and ProtocolNumber = just like you do in other languages
08:29:15 <dramforever> osa1: and when you bind or connect, you'd need a SockAddr
08:29:19 <dramforever> so you use this:
08:29:27 <dramforever> :t Network.Socket.SockAddrUnix
08:29:28 <lambdabot> String -> network-2.4.2.2:Network.Socket.Types.SockAddr
08:32:17 <osa1> dramforever: this works http://lpaste.net/119132 ?
08:32:57 <dramforever> osa1 seems good
08:33:02 <dramforever> *it seems
08:37:56 <dramforever> Why doesn't this program stream? (I mean, output as early as possible)
08:38:04 <dramforever> http://github.com/dramforever/kspl
08:40:47 <dramforever> My best guess: it's because the use of State
08:40:59 <dramforever> but I'm not sure what to do to fix it
09:00:51 <Wizek> Good Morning!
09:01:15 <Wizek> Anyone knows about a simpler (toy?) alternative to acid-state?
09:03:21 <quchen> You could easily implement that yourself if you want to. Updating a file means writing a new file, checking whether the write was correct, and then deleting the old file.
09:04:53 <quchen> The only atomic operation you need is how to tell the program while file is the most current, e.g. by checking file creation times and hashing.
09:12:52 <anti-freeze> ezrios, Thanks for that by the way
09:13:17 <temoto> How to define quickcheck Gen String to construct a combination from predefined words? Say I have [prefix1, prefix2], [middle1, middle2], [suffix1, s2, s3] and want {any prefix} ++ {any middle zero or more times} ++ {any suffix zero or one time}. No space intercalation needed.
09:13:50 <JagaJaga> notdan: oh, thank you, man.
09:15:58 <glguy> Temoto: use Gen Int to make list indexes and then pick the words with them
09:18:29 <temoto> glguy, something like genString = do { return $ (prefixByIndex $ Q.elements [1, 2, 3]) ++ ... ?
09:20:16 <temoto> I'm not sure how to implement one-or-more and zero-or-more. I mean I could throw dice with Q.elements and place `if` inside do, but it seems it could be written 10 times shorter.
09:22:51 <Wizek> quchen: Thanks, I'll consider that
09:23:07 <Wizek> quchen: Would you then just show/read for serialization?
09:23:20 <quchen> Hell no!
09:23:26 <quchen> Binary is a good serialization library
09:23:27 <Wizek> or is there a binary show/read ?
09:23:53 <quchen> :t Data.Binary.encode
09:23:53 <lambdabot> binary-0.7.1.0:Data.Binary.Class.Binary a => a -> BSLC.ByteString
09:24:17 <quchen> Well that looks a bit scary.
09:24:28 <quchen> encode :: Binara a => a -> ByteString   ‚Üê that's more like it
09:25:38 <Wizek> thanks, I might make friends with acid-state or roll something simpler for myself :)
09:25:59 <tokinaka> Hey everyone.
09:26:03 <quchen> Hello.
09:26:32 <tokinaka> Does it make sense to learn Elixar before Haskell? I am new to functional languages.
09:26:32 <quchen> Wizek: There's a 24days post about ACID State. It might be a good starting point.
09:27:02 <quchen> I think that if you want to learn French, it's better to learn French directly rather than first learning Latin and then French.
09:27:09 <tokinaka> So, want a gentler introduction and learn how to think functional before getting into Haskell ...
09:27:28 <tokinaka> quchen: Point taken.
09:27:32 <glguy> Temoto: pick xs = fmap (\i -> xs !! mod i (length xs)) arbitrary
09:27:50 <glguy> Something like that. I'm on my phone; can't test
09:27:51 <quchen> I don't know much about Elixir, but none of the languages I've ever encountered before would have made good primers for Haskell.
09:27:55 <tokinaka> Haskell just seems so intimidating ...
09:28:00 <wayne> tokinaka: you can learn lisp if the syntax is scary to you
09:28:06 <notdan> JagaJaga: np :)
09:28:06 <wayne> it would help you wrap your head around functional concepts
09:28:14 <quchen> Lisp does not have much to do with Haskell either.
09:28:26 <wayne> quchen: but if you're not familiar with map/reduce/fold/etc
09:28:31 <wayne> i think lisp is a great way to ramp up
09:28:37 <wayne> and then you can worry about the haskell type system
09:28:56 <n4x> if by lisp you mean scheme/racket, maybe
09:29:01 <tokinaka> Are there any good video tutorials on haskell?
09:29:37 <quchen> The Haskell type system is not something to worry about. It's the best feature of the language. :-C
09:30:04 <rcharles> tokinaka: it's intimidating at first but as you spend more time learning the language it then starts to make sense
09:30:15 <tokinaka> quchen: I don't know anything about Haskell, just that it is purely functional and that it has many practical uses.
09:30:21 <quchen> And it forces you to do things the functional way. There's no way to go around it. In Lisp you can always `set!` or whatever.
09:30:46 <wayne> tokinaka: then maybe you should dive in before knocking it
09:30:49 <tokinaka> It's good a good community and so will make practical projects that much easier.
09:31:02 <tokinaka> wayne: I didn't knock it ...
09:31:12 <tokinaka> I just said I am intimidated ...
09:31:38 <rcharles> tokinaka: you can check out learn you a haskell - http://learnyouahaskell.com
09:31:46 <temoto> glguy, thanks a lot.
09:32:09 <tokinaka> rcharles: Thanks will check it out.
09:32:58 <quchen> When you want to learn functional programming specifically, I think Haskell is your best choice right now. There are many other good functional languages, e.g. Erlang, the Lisps, maybe even parts of Javascript. But none of the aim at being functional languages. Erlang aims at being good for distributed, fault-tolerant systems. Lisp aims at being awesome by being in your own syntax tree. Javascript ‚Ä¶ runs in the browser. Haskell
09:32:58 <quchen> on the other hand was created to be a functional language; it then turned out that this is practically helpful as well.
09:33:53 <rcharles> quchen: and as you said it forces you to think and code functionally
09:33:56 <quchen> I second LYAH, it's an excellent and entertaining starting point. There's also "Programming in Haskell" by Hutton.
09:35:39 <kuribas> scheme is good also, but it doesn't have algebraic datatypes
09:36:21 <kuribas> scheme is more functional that lisp.  Lisp is rather imperative actually.
09:36:33 <arw> scheme and lisp are quite fine for learning functional programming as long as you pick the right book imho.
09:36:53 <tokinaka> arw:  and which one is the right book for scheme ?
09:37:18 <kuribas> If you like math, then SICP is a great book.
09:37:31 <kuribas> https://mitpress.mit.edu/sicp/full-text/book/book.html
09:37:34 <tokinaka> little schemer ?
09:37:36 <arw> jup.
09:37:49 <arw> abelson sussman (SICP) would also be my suggestion.
09:37:53 <quchen> SICP is a book about concepts in programming, not about Scheme. Scheme just happens to be the best language to express the ideas in.
09:38:29 <tokinaka> I have seen the videos on SICP a long time ago. But I don't remember any of it now. It was like six years ago.
09:38:40 <arw> quchen: yes, thats the beauty of it. it shows that the language doesn't really get in the way and its just "natural" to express those ideas in that language.
09:38:43 <quchen> There is also SICP using Javascript, if you want the same book with an unsuitable language. >:-(
09:40:30 <tokinaka> Does anyone here use Elixar? Why is there a buzz around it now?
09:41:51 <temoto> buzz is easy to create
09:43:01 <arw> the interesting part is always after the buzz.
09:43:33 <arw> after people have noticed the possible problems and separated the "what works" from "what was promised".
09:44:02 <tokinaka> ah k.
09:44:16 <tokinaka> Then Haskell it is!
09:44:19 <temoto> Also, it seems that Elixir is just different syntax for Erlang.
09:44:30 <temoto> or are we talking about other elixir?
09:44:47 <tokinaka> It is Erlang in new syntax ...
09:44:55 <arw> i think so. or at least google corrected it that way :)
09:45:09 <tokinaka> Yes elixir
09:46:15 <arw> tokinaka: if its your furst language or your first functional one, just pick one with a good book , or a number of good books.
09:46:26 <temoto> Well, BEAM is uhm... ok runtime, I mean it really works for a lot of people. And original (Prolog) syntax was so terrible you don't know where to start. So they fixed the biggest issue, it's an uhm.. ok choice now. What else to buzz about.
09:47:17 <quchen> tokinaka: Keep in mind that this is a Haskell channel. Ask the Elixir people what they think you should learn as well.
09:47:22 <tokinaka> arw:  I ordered a copy of LYAH.
09:47:32 <quchen> Excellent! :-)
09:47:34 <arw> tokinaka: after you know the concepts, learning other languages is usually much simpler.
09:48:10 <tokinaka> I am looking at other suggestions on Amazon to see if I should order some more books.
09:48:34 <temoto> Yeah, just be ready to invest your time and attention and you'll quickly find which works for you best.
09:48:41 <arw> tokinaka: and when you know multiple languages you have a basis for comparison and can evaluate the buzz for yourself
09:49:34 <quchen> tokinaka: There aren't tremendously many books on Haskell. LYAH/Hutton are excellent starting points, after that comes RWH, and then you're out in the ocean of blog posts about things, discovering libraries and so on.
09:50:05 <quchen> And there's this channel of course.
09:50:36 <temoto> One final pitch, I promise. It often turns out, what other languages/runtimes propose as a distinct feature (lightweight processes, scalable IO, promises, contracts, fill in your favorite) -- in Haskell it's done by a library.
09:50:40 <tokinaka> arw, makes sense. Just wasn't sure if I was going too deep into the ocean. Didn't want to get discouraged and give up on haskell.
09:50:51 <tokinaka> temoto:  :)
09:51:29 <monochrom> learn everything
09:51:37 <arw> tokinaka: for me it was always a matter of learning bits and pieces. haskell is a hard language to learn, and I didn't get it all in my first try.
09:51:58 <arw> tokinaka: but it was always very interesting, so I came back after a time to learn more
09:52:10 <quchen> monochrom: A+ advice, would consult again
09:52:22 <monochrom> :)
09:52:27 <tokinaka> monochrom:  :)
09:52:42 <arw> tokinaka: there definitely won't be a "haskell in 30 days", ever. thats just not possible imho.
09:53:14 <tokinaka> yes, if only real life didn't have to come in the way, I would lock myself in a room with a computer and books and just program or learn to ...
09:53:19 <quchen> There aren't any other "X in 30 days either", but somehow there are still books named that.
09:53:38 <tokinaka> arw: How long before you were doing practical things?
09:53:42 <Hijiri> no one has interjected with learnhaskell yet?
09:53:47 <Hijiri> @where learnhaskell
09:53:47 <lambdabot> https://github.com/bitemyapp/learnhaskell
09:53:56 <tokinaka> Hijiri:  no.
09:54:11 <n4x> quchen: well, "learn X in 30 days (if you know Y)" could be possible for some X and Y..
09:54:19 <bernalex> tokinaka: depending on what you consider practical, it may be anything from a couple of weeks to a couple of months depending on your background.
09:54:47 <quchen> I don't know any useful skill you can learn in 30 days.
09:54:47 <arw> tokinaka: that happens quite quickly, I've always been using haskell as a quick calculator, just like people use perl for one-liners, from the start.
09:55:17 <Hijiri> learn X in 30 days (if you know X) is trivially possible
09:55:25 <Hijiri> or maybe impossible if you can't learn something you already know
09:55:57 <Pamelloes> Is there a way to embed an existing cabal project within a new one?
09:56:12 <Hijiri> copy and paste the library/executable entry for it?
09:56:14 <Hijiri> and all the deps
09:56:15 <Xe> dependencies?
09:56:20 <dcoutts_> Pamelloes: main approach is for one to depend on the other
09:57:12 <Pamelloes> dcoutts_: That's what I'd like, but how do I go about making that happen? How do I make a local project a dependency of another local project?
09:57:12 <monochrom> http://www.vex.net/~trebla/humour/programming_books.html
09:57:15 <tokinaka> bernalex: true. I just want to be able to scrap things from the web, do calculations produce output that I like. At least to begin with. The other practical thing I want is to make an application that replicates https://www.followupthen.com
09:57:48 <tokinaka> On my own domain. Just some projects, I want done, and done using Haskell for no specific reason ...
09:57:50 <dcoutts_> Pamelloes: same way as normal, by listing it by name in the build-depends
09:58:00 <quchen> Is there a way to hide certain exposed modules from "cabal haddock"? The "Internal" modules clutter up the index a lot.
09:58:03 <tokinaka> arw: That sounds promising.
09:58:06 <Pamelloes> dcoutts: And cabal will just find it?
09:58:34 <dcoutts_> Pamelloes: if you tell cabal where it is, yes. e.g. cabal install ./foo ./bar
09:58:43 <dcoutts_> Pamelloes: or add both to a single sandbox
09:59:04 <dcoutts_> quchen: yep, see haddock user guide
09:59:26 <Pamelloes> dcoutts_: Alright, I'll look into it. Thanks for letting me know it's possible :)
10:01:32 <monochrom> quchen: I think there is, but I'm too lazy to look it up. find the haddock manual. it comes down to adding something in the file you want to hide.
10:01:41 <tokinaka> THank you all for the inputs and feeback will start with the stuff online and wait for my book, to use during my commute.
10:02:34 <quchen> monochrom: OPTIONS_HADDOCK hide. But it would be nice if I could specify a whole hierarchy when invoking haddock, e.g. `cabal haddock --haddock-options="-hide=Internal*"` or something
10:03:15 <quchen> Such a flag would allow me to write different "generate docs" commands. One for public API, and one that includes all the "Internal" things, which is useful for development.
10:04:11 <glguy> quchen: It'd be even more verbose, but you can probably guard that hide pragma with CPP :-/
10:04:20 <monochrom> :)
10:04:36 <quchen> Eww.
10:05:02 <monochrom> hide-by-name lambda calculus
10:13:10 <temoto> glguy, turns out, your pick :: [a] -> QuickCheck.Gen a  already exists and is dubbed `elements`.
10:13:40 <glguy> Ah, cool.
10:14:56 <temoto> Again, most of real world code can be written as few symbols in J and few lines in Haskell.
10:15:22 <tokinaka> temoto: I like that :)
10:15:47 <temoto> hm. now my praise of this language seems far more silly than 4 years ago
10:15:53 <temoto> something has changed
10:16:12 <monochrom> most of real world code can be written by hiring someone else to do it for you
10:16:29 * monochrom is a tautological capitalist!
10:16:35 <tokinaka> I should hire someone to teach me haskell.
10:16:41 <monochrom> :)
10:16:42 <arw> or it has already been written and you just need to find it
10:16:57 <temoto> Yeah I meant the already written part.
10:17:45 <temoto> and that real complex tasks could be expressed by carefully choosing functions someone already wrote
10:18:06 <tokinaka> Make someone work through LYAH on a screencast :) just grab chips and sit and watch ...
10:19:11 <temoto> Oh I prefer watching Kerbal Space Program casts. Some people are pumping a lot more fun from it than I could imagine.
10:20:05 <temoto> And it's one of those delightfully  rare occasions you could be sure a lot of people know KSP.
10:24:30 <tokinaka> https://www.youtube.com/user/LazyCasts/videos
10:24:37 <tokinaka> aSomeone did :)
10:26:37 <tokinaka> Bye everyone, until I see you next time. Good morning good evening and good night!
10:26:46 <[mad]> cool tokinaka
10:26:48 <[mad]> cya
10:26:55 <[mad]> :D
10:30:55 <UberLambda> Hello everyone
10:31:35 <[mad]> hi
10:32:20 <UberLambda> Does anybody know when llvm-general will target LLVM 3.5?
10:34:40 <ReinH> temoto: Scott Manley?
10:36:28 <WarzoneCommand> question for the lens people: is there a 'fmap-like' getter somewhere? I.e. if I have a lens myLens that yields a Maybe a, and I have an other lens fooLens that, given an a focusses on a b, applies uses the second lens in the first one, i.e. something like: myThing ^. myLens . unknownThingHere . fooLens , which would yield something of type Maybe b ?
10:37:11 <benzrf> WarzoneCommand: perhaps you are asking about prisms?
10:37:23 <benzrf> :t _Just
10:37:24 <lambdabot> (Choice p, Applicative f) => p a (f b) -> p (Maybe a) (f (Maybe b))
10:37:27 <benzrf> eek
10:37:39 <benzrf> _Just :: Prism (Maybe a) (Maybe b) a b
10:38:35 <benzrf> > ("foo", Just (1, 2)) ^? _2._Just._1
10:38:36 <lambdabot>  Just 1
10:38:50 <benzrf> > over (_2._Just._1) (+3) ("foo", Just (1, 2))
10:38:51 <lambdabot>  ("foo",Just (4,2))
10:38:57 <Pamelloes> How does making a module export functions from other modules work?
10:39:11 <WarzoneCommand> ah that seems to do what I want
10:39:23 <benzrf> WarzoneCommand: Prisms may fail and they can be "rolled back"
10:39:29 <benzrf> > review _Just 3
10:39:30 <lambdabot>  Just 3
10:39:49 <benzrf> WarzoneCommand: obviously lenses cannot be rolled back in that way since that would require extra data you aren't giving
10:39:56 * hackagebot base58-bytestring 0.0.1 - Implementation of BASE58 transcoding for ByteStrings  http://hackage.haskell.org/package/base58-bytestring-0.0.1 (AlekseyUymanov)
10:40:43 <WarzoneCommand> hmm yes I read some stuff about Prisms
10:41:10 <WarzoneCommand> reading about them and using them in real code are still two different things though ;)
10:41:19 <benzrf> indeed
10:41:30 <benzrf> FYI: composing a lens with a prism gives you a traversal
10:41:41 <bramgg> What are the main pros/cons to Fay VS Haste?
10:41:42 <benzrf> "affine traversal" is the term for a traversal with either 0 or 1 targets
10:41:51 <benzrf> so prisms are basically affine traversals that can be rolled bac
10:41:52 <ReinH> benzrf: it is? source?
10:41:53 <benzrf> *back
10:42:03 <benzrf> ReinH: i dunno, i've just seen it used :\
10:42:08 <benzrf> in irc
10:42:19 <ReinH> Ah. Right there in the lens docs.
10:42:22 <benzrf> haha
10:42:27 <ReinH> First time for me.
10:44:56 * hackagebot base58-bytestring 0.0.2 - Implementation of BASE58 transcoding for ByteStrings  http://hackage.haskell.org/package/base58-bytestring-0.0.2 (AlekseyUymanov)
10:46:29 <tasker> Is it possible to use parse json using aeson such that it has the same behaviour as <|> in attoparsec?
10:48:19 <indiagreen_> tasker: what do you mean?
10:49:46 <tasker> Hm I guess try parsing something, then if it fails parsing something else. Although thinking about it, that doesn't really make much sense..
10:49:58 <tasker> Probably would have to have a wrapper class, I suppose
11:00:26 <lpaste> temoto pasted ‚Äúquickcheck regex generator‚Äù at http://lpaste.net/119138
11:02:31 <temoto> Please help to debug errors like expected type ëQ.Gen [Char]í with actual type ë[Char]í in expression group. It's probably very obvious, but I'm bad at things inside/outside monads.
11:03:08 <temoto> I've tried putting fmap in random places but it doesn't help and a bad approach anyway.
11:03:18 <quchen> glguy, monochrom: Running a bash script from within the makefile that aggregates a couple of "--hide MODULE" and then passes them to `cabal haddock` did the trick. It's a truly beautiful...well it works somehow
11:05:53 <temoto> I can help with something imperative and impure in return.
11:06:20 <temoto> like bash/linux/docker/HTTP etc
11:09:57 * hackagebot base58-bytestring 0.0.3 - Implementation of BASE58 transcoding for ByteStrings  http://hackage.haskell.org/package/base58-bytestring-0.0.3 (AlekseyUymanov)
11:13:38 <quchen> temoto: Could you add the error message to the end of your paste?
11:15:25 <lpaste> temoto revised ‚Äúquickcheck regex generator‚Äù: ‚Äúquickcheck generator of regexes‚Äù at http://lpaste.net/119138
11:17:05 <quchen> temoto: That's the same paste, isn't it?
11:17:11 <quchen> I don't see the error
11:17:19 <quchen> Ah, now it's working.
11:17:52 <vanila> temoto try        group = undefined -- "(" ++ (Q.listOf1 $ anyBut ')') ++ ")"
11:18:03 <temoto> wow
11:18:25 <quchen> Or even better,   group = _hole
11:18:30 <benzrf> > 1530 / 206.0
11:18:32 <lambdabot>  7.427184466019417
11:18:32 <quchen> And see what type it expects when you compile
11:19:51 <vanila>         group = do m <- (Q.listOf1 $ anyBut ')')
11:19:51 <vanila> 	      	   return ("(" ++ concat m ++ ")")
11:20:40 <temoto> vanila, that undefined helped to find type problem in another function, thank you.
11:24:16 <temoto> Alright, it works! Thank you very much. I knew it's a simple fix, but hard to get without specific intuition required here.
11:24:43 <vanila> a lot of people mix  up monadic actions with their values
11:24:44 <temoto> i even understand what's wrong and how you fixed it, but couldn't make it myself
11:25:10 <vanila> there's a thing that lets you mix them more freely called applicative
11:25:35 <temoto> Yeah, when I can, I always prefer Applicative, it's easier to understand.
11:34:44 <temoto> Is there in-expression equivalent of <- ?
11:34:58 <EvanR> :t (>>=)
11:34:59 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:35:26 <EvanR> @undo do { x <- foo; return x }
11:35:26 <lambdabot> foo >>= \ x -> return x
11:37:54 <temoto> How about do { x <- foo ; y <- bar ; return $ concat ["before", x, y] }  ? I'd really like to use foo and bar in place of x, y but there is no second argument to >>=
11:38:09 <geekosaur> chain them
11:38:27 <geekosaur> @undo do { x <- foo ; y <- bar ; return $ concat ["before", x, y] }
11:38:27 <lambdabot> foo >>= \ x -> bar >>= \ y -> return $ concat ["before", x, y]
11:38:44 <EvanR> also , liftM2 and liftA2
11:38:48 <temoto> :t (->)
11:38:49 <lambdabot> parse error on input ‚Äò->‚Äô
11:38:56 <EvanR> :t liftM2
11:38:57 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:39:18 <EvanR> i got your second argument right here
11:39:29 <barrucadu> temoto: The -> there is just regular lambda syntax
11:39:35 <barrucadu> \args -> expression
11:39:40 <temoto> ah
11:39:45 <temoto> right
11:39:47 <EvanR> @src liftM2
11:39:47 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
11:40:03 <temoto> Yeah, that looks like it.
11:40:35 <EvanR> sometimes its more clear to just write it out though
11:40:40 <horny-sama> https://github.com/mr-fool/haskell/blob/master/empty/empty.hs <---how do you concatnete io string?
11:40:44 <horny-sama> I try ++
11:41:10 <temoto> I haven't looked at Haskell for years really, but now I recall that lift is the thing I'm looking for quite often.
11:41:45 <EvanR> you can also use this
11:41:48 <EvanR> :t liftA2
11:41:49 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
11:41:58 <EvanR> if your monad is an applicative, which it should be
11:41:58 <barrucadu> horny-sama: Read the error message, it's not complaining about the use of ++
11:42:14 <horny-sama> ooo
11:42:24 <horny-sama> got it
11:42:26 <horny-sama> typo
11:42:26 <temoto> horny-sama, just in case you didn't know, Github has this thing https://gist.github.com/ to paste pieces of code without creating empty repository.
11:42:26 <horny-sama> :<
11:42:39 <triliyn> temoto: you might also find (=<<) occasionally useful. It's like (>>=) with its arguments reversed; like normal function application, it lets you keep the function on the left
11:42:51 <horny-sama> temoto: I am using github so employers can see I am programming everyday
11:43:34 <temoto> that's a bit sad
11:43:36 <EvanR> you might also want to use `liftM1` which is actually fmap
11:44:08 <Norfair>   /part
11:44:10 <Norfair> woops
11:44:31 <SrPx> How do you deal with conflicting imports? Do you always import everything qualified?
11:44:52 <EvanR> depends
11:45:03 <temoto> I'm qualified import fundamentalist. I really thing there should be no other kind of import.
11:45:10 <temoto> think(
11:45:22 <enthropy> Prelude.+
11:45:44 <SrPx> temoto: what is your "as"? import qualified Data.Vector as ... ?
11:45:53 <EvanR> SrPx: for libraries you probably use together, like String ByteString Text, or Map Set List, you commonly put a single letter qualified import
11:45:58 <benmachine> some modules like to be imported qualified, others are ok to be not so
11:46:09 <temoto> For cases when you actually have to import Prelude, yes, ugly Prelude.+ to be.
11:46:24 <SrPx> so it is kinda a experience thing
11:46:47 <temoto> SrPx, import qualified Test.QuickCheck as Q
11:46:59 <SrPx> butwhat if you import a queue too?
11:47:10 <EvanR> do you?
11:47:42 <benmachine> I think it's worth saying that the module system, along with the records, is one of the least well-developed parts of Haskell
11:47:47 <temoto> SrPx, if there's ambiguity, I prefer full long names.
11:47:54 <benmachine> I believe there's work on a new module system happening somewhere
11:48:05 <temoto> in parallel universe?
11:48:44 <benmachine> https://ghc.haskell.org/trac/ghc/wiki/Backpack
11:49:55 <ReinH> SrPx: Also you can be more explicit about which functions you are importing by using import Foo (foo, bar)
11:50:04 <ReinH> This is also useful later for documenting where a certain thing came from.
11:50:18 <temoto> also very useful, yes
11:51:20 <SrPx> I see
11:52:27 <EvanR> theres a lot of complaining about haskells module system, but comparing it to all the crap systems i use in real life, they are all worse
11:52:33 <temoto> @which-package liftA2
11:52:33 <lambdabot> Unknown command, try @list
11:52:37 <temoto> @list
11:52:37 <lambdabot> What module?  Try @listmodules for some ideas.
11:52:45 <ReinH> @hoogle liftA2
11:52:46 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
11:52:47 <EvanR> it has a no-nonsense aspect to it
11:52:55 <ReinH> Will tell the modole.
11:53:07 <ReinH> Actual hoogle will also tell you the package
11:53:37 <EvanR> maybe there is some amazing thing better, but it seems like an oasis to me
11:53:42 <arw> btw, modules. can i mark a function non-exportable by a module?
11:53:51 <EvanR> yes
11:54:03 <EvanR> each module can have an export list
11:54:42 <ReinH> arw: The export list is a white list, so you have to list the functions you *do* export. It's a good practice to do so btw.
11:55:05 <EvanR> but if you dont export something someone wants to use or test, then they will hate you
11:55:15 <EvanR> so an Internal module might be better
11:55:57 <EvanR> not exporting the data type themselves lets people use your code but doesnt let them write type sigs
11:56:49 <ReinH> Well yes, I don't think anyone is arguing against being considerate about how you exporting things
11:56:58 <ReinH> s/exporting/export
11:57:41 <arw> I just thought about hiding a few helper functions that didn't fit into a let/where. nothing so fancy as angering users via broken data types :)
11:57:46 <SrPx> Honestly guys, how do you say Haskell types aren't like C++... they are just here to help you? http://lpaste.net/119143 --- I don't get it. What the heck is that...
11:58:08 <arw> anyway, thanks, ReinH, EvanR
11:59:16 <ReinH> Uh, because they aren't like C++ types.
11:59:19 <temoto> SrPx, and in "aren't like C++" do you mean "aren't better than C++" ?
11:59:46 <ReinH> SrPx: what is the type of V.freeze?
12:00:08 <SrPx> ReinH: freeze :: PrimMonad m => MVector (PrimState m) a -> m (Vector a)
12:00:34 <ReinH> freeze has a constraint while fn does not
12:00:54 <temoto> SrPx, error message size indeed looks a lot like wrong < with C++ templates.
12:02:11 <Hijiri> uh
12:02:22 <Hijiri> SrPx: what type annotations do those functions you changed have?
12:02:30 <SrPx> ReinH: I see, but what do I do, then?
12:02:36 <ReinH> What is the actual code on line 56?
12:03:04 <SrPx> the annotation when it worked fine was: freeze :: (PrimMonad m) => MSpaceTree (PrimState m) p a -> m (SpaceTree p a)
12:03:05 <ReinH> The answer is probably to explicitly annotate the type of applyFreeze
12:03:24 <SrPx> I'll just paste the whole if you want, a second
12:03:26 <Hijiri> what was the annotation when it stopped working?
12:03:27 <quchen> That's at most 100 lines of Haskel errors, i.e. an order of magnitude less than your average boost template error
12:03:32 <horny-sama> anyone know how I can take an argu from command line like this runhaskell programName.hs argu
12:03:40 <SrPx> ReinH: I tried a few things but didn't match it :(
12:03:46 <indiagreen> SrPx: can you paste them both on some online diff site? it'd be rather convenient
12:03:50 <barrucadu> horny-sama: getArgs
12:03:57 <SrPx> which site?
12:04:10 <quchen> SrPx: "No instance Num" most likely means you're adding two things, and forgot an argument on one of the operands.
12:04:19 <indiagreen> http://www.quickdiff.com/
12:04:25 <quchen> Or one too many. Anyway, check around your "+".
12:04:29 <SrPx> quchen: but it was working before? :/
12:04:33 <indiagreen> no, wait
12:04:38 <indiagreen> don't know
12:04:55 <ReinH> SrPx: I suppose it should be applyFreeze :: (PrimMonad m => MVector (PrimState m) a -> m (Vector a)) -> MSpaceTree (PrimState m) p a -> m (SpaceTree p a)
12:05:00 <barrucadu> SrPx: I'd guess the correct type should be something like :: PrimMonad m => (MVector (PrimState m) a -> m (Vector a)) -> MSpaceTree (PrimState m) p a -> m (SpaceTree p a)
12:05:20 <ReinH> er, extra () there
12:05:43 <ReinH> applyFreeze :: PrimMonad m => (MVector (PrimState m) a -> m (Vector a)) -> MSpaceTree (PrimState m) p a -> m (SpaceTree p a)
12:05:49 <SrPx> indiagreen: uh...
12:05:55 <quchen> Oh, there's code above the error. I missed that.
12:06:07 <horny-sama> okay I will give it a try
12:06:11 <bramgg> How can I use two modules that break eachother when installing with Cabal?
12:06:17 <SrPx> a second, too many things. that diff site don't have a publish link
12:06:22 <ReinH> bramgg: what do you mean?
12:06:22 <indiagreen> SrPx: sorry, thought such a site would be easier to find
12:06:24 <indiagreen> yes, no link
12:06:25 <indiagreen> nevermind
12:07:01 <dcoutts_> bramgg: ask cabal to install them simultaneously
12:07:09 <bramgg> ReinH: I'm trying to use Scotty and Fay but installing them each requires "--force-reinstalls" and breaks the other
12:07:23 <ReinH> bramgg: Use a cabal file.
12:07:32 <bramgg> dcoutts_: will that fix the above problem?
12:07:32 <ReinH> Or install them at the same time
12:07:39 <bramgg> hm okay thanks
12:07:41 <ReinH> That will force cabal to try to find a plan that will work for both.
12:08:09 <uberwach> I am struggling to understand the typeclass definition of FreeMonad in Control.Monad.Free
12:08:11 <dcoutts_> bramgg: and if it cannot, then it's (probably) impossible to install them simultaneously in one environment, in which case you'd need to install them in separate environments (e.g. two sandboxes)
12:08:12 <ReinH> (You should probably use a cabal file anyway)
12:08:12 <bramgg> And with a cabal file I would specify that "plan"?
12:08:20 <ReinH> bramgg: You would specify any version constraints
12:08:29 <dcoutts_> bramgg: sorry, I didn't see the details of the problem you're referring to
12:08:30 <ReinH> Cabal will create the plan as it resolves the dependencies
12:08:33 <uberwach> in "class Monad m => MonadFree f m | m -> f where" what does the pipe notation mean?
12:08:49 <barrucadu> uberwach: Functional dependencies. It means that the type f is determined by m
12:08:50 <bramgg> by "plan" you mean the versions of each package to use, correct?
12:08:54 <Hijiri> MonadFree f m such that m determines f
12:08:54 <ReinH> e.g. it will attempt to find compatible versions of the two libraries based on *their* constraints.
12:09:22 <bramgg> okay, thanks all. I guess I should look into these cabal files.
12:09:23 <uberwach> barrucadu, does it somehow imply that Functor f => f holds?
12:09:28 <ReinH> uberwach: see "Functional Dependencies", a.k.a. fundeps
12:09:34 <uberwach> I will read it up thanks
12:09:49 <Hijiri> It means that the only instance for MonadFree something m is when something is f
12:10:06 <quchen> ReinH: Every couple of days I see that textfile on my desktop and it makes me smile. It contains "ReinH: Type operators are fun. data (.) f g = Compose f g; data (~>) f g = Nat { runNat :: forall a. f a -> g a }; join :: Monad m => m . m ~> m"
12:10:08 <Hijiri> so for each m, you have a unique f
12:10:10 <ReinH> uberwach: It does not. It says that m uniquely determines f.
12:10:35 <ReinH> So that rather than trying to find both m and f, it can find m and then look up f.
12:11:00 <uberwach> ReinH, like in Maybe t -> t?
12:11:05 <ReinH> No.
12:11:13 <SrPx> indiagreen: no problems
12:11:22 <ReinH> Maybe t -> t is the type of a function that takes a value of type Maybe t and produces a value of type t
12:11:31 <uberwach> ReinH, well I meant some kind of isomorphism
12:11:53 <ReinH> No, there is no isomorphism here.
12:11:56 <Hijiri> Maybe t -> t isn't an isomorphism either
12:13:00 <uberwach> Hijiri, sry didnt mean that... it ofc cannot exist for types with finitely many values as the map never can be injective (pidgeonhole principle)
12:13:12 <benmachine> quchen: surely data (.) f g a = Compose (f (g a))
12:13:36 <untseac> Are there any style conventions in haskell or is it free for all kind of thing? I'm referring to space vs tabs and such
12:13:39 <SrPx> ReinH: barrucadu none worked, here is the code http://lpaste.net/119147
12:13:52 <BasDirks> Hai. I've installed the Haskell platform for Mac OSX, and cabal --version gives 1.18.something. When I cabal update, and cabal install cabal-install, it does install cabal 1.22.something, but cabal --version still gives the same old 1.18.something
12:13:55 <ReinH> uberwach: It can't exist at all. There is nowhere to send Nothing.
12:14:07 <uberwach> ReinH, a value?
12:14:16 <uberwach> take any c :: T and send Nothing to c
12:14:25 <ReinH> But you can't take any c :: t
12:14:29 <ReinH> t is polymorphic
12:14:34 <SrPx> (updated pastebin so lines match)
12:14:35 <uberwach> ahh good catch
12:14:42 <horny-sama> need some getArgs help
12:14:52 <ReinH> Maybe Nat -> Nat is isomoprhic.
12:15:03 <horny-sama> how do I check if the user has indeed enter an argu?
12:15:08 <horny-sama> I mean two arguments
12:15:17 <ReinH> you send Nothing to Zero and Just to Succ n
12:15:24 <ReinH> s/Just/Just n
12:15:26 <uberwach> ReinH, nothing to 0 and apply succ to other nats
12:15:27 <horny-sama> [f,g] <- getArgs takes two argument
12:15:42 <horny-sama> but if the argument is 0 then I want it to do something else
12:15:47 <ReinH> but you can't choose a member of forall a. a
12:15:51 <uberwach> I just try to understand in which sense f gets determined by m in the FreeMonad f m case
12:16:02 <ReinH> uberwach: Right, it means that when you have an instance
12:16:12 <ReinH> that the instance will uniquely define the choice of f for m
12:16:46 <ReinH> so if I have instance MonadFree Foo Bar, the type inferrer doesn't have to figure out both Foo and Bar, it just finds the instance with m ~ Bar and then looks up its f, in this case Foo
12:16:56 <uberwach> ReinH, ah so you are supposed to only construct one FreeMonad for reach f?
12:17:01 <ReinH> for each m
12:17:06 <ReinH> each m uniquely determines its f
12:17:16 <horny-sama> afk for food before I die
12:17:52 <ReinH> uberwach: see https://www.haskell.org/haskellwiki/Functional_dependencies
12:17:53 <uberwach> ReinH, this seems weird to me
12:18:06 <temoto> EvanR, if you recall that do/liftM thing... I can't write something like   f :: M String  f = liftM $ concat ["prefix1", foo, "fixed2", bar]   maybe it's one of those cases where writing things out is better than smart tricks?
12:18:19 <ReinH> This makes type inferrence more efficient and sometimes makes it possible to infer types that would otherwise be impossible.
12:18:26 <ReinH> The wiki page presents a good motivating example.
12:18:51 <uberwach> okay thank you
12:18:59 <ReinH> np
12:19:29 <ReinH> horny-sama: if the argument is "0" or if there are zero arguments?
12:19:54 <EvanR> temoto: you mean liftM2 ?
12:20:11 <horny-sama> ReinH: zero arguments
12:20:12 <ReinH> temoto: liftM is fmap btw
12:20:13 <quchen> benmachine: I can't make it compile (parse, even) with "(.)" in there
12:20:16 <ReinH> horny-sama: you can pattern match.
12:20:17 <quchen> But it looks pretty.
12:20:22 <horny-sama> ReinH: example?
12:20:24 <temoto> EvanR, well I figured I need liftM since concat actually takes one argument.
12:20:27 <ReinH> args <- getArgs; case args of [] -> handleZeroArgs
12:20:45 <EvanR> temoto: the "arguments" we were talking about was foo and bar, rather than the last arg to concat
12:20:50 <benmachine> quchen: it wasn't (.) I was taking issue with
12:20:52 <horny-sama> ReinH: what about if the user enters 1 args instead of 2?
12:21:02 <benmachine> well, it was in a sense, but the kind of it
12:21:04 <ReinH> horny-sama: then add that case to your pattern match
12:21:20 <quchen> benmachine: Trying to understand your issue was making the code complain about something related, so I put it into a file and started trying to compile it
12:21:28 <barrucadu> SrPx: Ok, so the error message for line 84 is telling you what's wrong there. The type I and ReinH gave you is a bit too general, as we didn't know what your MSpaceTree type is, so freeze :: PrimMonad m => (MV.MVector (PrimState m) (MSpaceTree (PrimState m) p a) -> m (V.Vector a)) -> MSpaceTree (PrimState m) p a -> m (SpaceTree p a), I think
12:21:33 <quchen> So I can't reproduce your objection because it breaks beforehand :-)
12:21:38 <temoto> horny-sama, you can write almost imperative style `if` inside do {} block.
12:21:38 <SrPx> also, is there any way to run my haskell file as fast as possible (probably without compiling) for debug purposes? ("ghci" alone will open the repo with the file loaded, I want it to just run it)
12:21:44 <ReinH> temoto: nah
12:21:49 <benmachine> quchen: oh, I misread "can't" as "can"
12:21:49 <ReinH> pattern match
12:21:52 <horny-sama> ReinH: If you take two args it has to be like this [arg1,arg2] <- getArgs?
12:21:58 <SrPx> barrucadu: uh.... let me see the error
12:22:07 <geekosaur> SrPx: runhaskell / runghc
12:22:16 <ReinH> horny-sama: the thing on the left hand side of the <- will be a list. So you can pattern match on the list, yes.
12:22:20 <horny-sama> temoto: really
12:22:22 <quchen> benmachine: This is my file, http://lpaste.net/119150
12:22:22 <geekosaur> but interpreted is not fast, certainly not as fast as possible
12:22:35 <benmachine> quchen: interesting. I can make it work with data (...) but not data (.)
12:22:44 <horny-sama> ReinH: what if I want it to be two io string?
12:22:50 <ReinH> horny-sama: What do you mean?
12:23:01 <quchen> Right, I've tried (+.) as well. Apparently "." has very special meaning in types. Maybe because of "forall."?
12:23:09 <benmachine> yeah, I was just thinking that
12:23:13 <favonia> johnw: yes. "junk" may match what "match" does, so "many junk *> match" won't work.
12:23:20 <benmachine> that's too bad
12:24:01 <SrPx> barrucadu: nope :(
12:24:10 <SrPx> seems like it is a complicated problem, nevermind :(
12:24:13 <barrucadu> Hang on, let me play with it in ghci
12:24:16 <hexagoxel> BasDirks: reason being that cabal install cabal-install will not overwrite your existing (global) installation; but simply install user-locally to ~/Library/Haskell/...
12:24:17 <horny-sama> ReinH: runhaskell programName.hs geany cool
12:24:17 <SrPx> I'll just create 2 functions
12:24:32 <BasDirks> cheers hexagoxel
12:24:41 <horny-sama> and I want the argu geany and cool to be store in two different variable name
12:24:45 <SrPx> barrucadu: don't worry please... it is more about knowing what to do, than fixing this particular program (since creating 2 functions just solves it anyway)
12:25:07 <SrPx> geekosaur: thanks :)
12:25:21 <hexagoxel> BasDirks: you can either modify your PATH to prepend the "new" version's path or copy the executable
12:25:24 <ReinH> horny-sama: [foo, bar] <- getArgs will bind the first arg to foo and the second arg to bar
12:25:42 <horny-sama> ooo
12:25:44 <horny-sama> okay got it
12:25:46 <horny-sama> I think
12:25:46 <BasDirks> hexagoxel: that explains a while lot
12:25:47 <temoto> EvanR, yes, I'm mixing things. But then pure strings would require `return` or something else to be "lifted" too?
12:25:57 <BasDirks> whole*
12:26:03 <hexagoxel> BasDirks: see.., the suggest the latter: http://stackoverflow.com/questions/14918251/have-i-upgraded-my-cabal-install
12:26:06 <hexagoxel> *they
12:27:21 <vanila> is there a shorthand for  r <- m ; case r of ...
12:27:23 * hexagoxel is not an osx user and does not know which approach is more advisable
12:27:47 <enthropy> vanila: m >>= \case -- possibly?
12:28:02 <vanila> thanks :)
12:28:05 <enthropy> with the -XLambdaCase
12:29:19 <EvanR> temoto: im not sure what youre doing anymore.
12:29:31 <ReinH> vanila: yep, LambdaCase is nice :)
12:29:33 <temoto> EvanR, f = do { x <- foo; y <- bar; return $ concat ["pre", x, "mid", y] }
12:30:00 * hackagebot wai-cors 0.2.1 - CORS for WAI  http://hackage.haskell.org/package/wai-cors-0.2.1 (larsk)
12:30:25 <temoto> EvanR, this is pretty much it and I wonder if it's possible to get rid of "excess" x <- aliasing while staying sane and readable.
12:30:55 <temoto> f :: M String
12:30:58 <ReinH> temoto: applicative: concat <$> pure "pre" <*> foo <*> pure "mid" <*> y
12:31:06 <ReinH> er, no, not quite, sorry
12:31:34 <EvanR> temoto: yeah so thats one liftM2
12:31:39 <ReinH> you can use sequence though, one sec
12:31:40 <EvanR> compare to
12:31:48 <EvanR> @src liftM2
12:31:48 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:32:08 <EvanR> temoto: f is a constant right
12:32:17 <EvanR> not a function
12:32:28 <temoto> EvanR, yes it seems to have much in common
12:32:42 <ReinH> :t let foo = undefined :: IO String in fmap concat . sequence $ [pure "pre", foo, pure "post"] -- temoto
12:32:43 <lambdabot> IO [Char]
12:32:47 <temoto> zero arguments, yes
12:33:32 <EvanR> liftM2 (\x y -> concat ["pre", x, "mid", y]) foo bar
12:34:08 <ReinH> maybe a bit nicer written as concat <$> sequence [pure "pre", foo, pure "post"]
12:34:16 <EvanR> yeah i dunno
12:34:30 <temoto> oh I couldn't imagine to put it into lambda, right
12:34:35 <EvanR> you could also replace all the pure code in monadic code with stuff wrapped in returns
12:35:11 <EvanR> x < return 3
12:35:14 <EvanR> x <- return 3
12:35:14 <temoto> return is monadic equivalent of applicative pure, isn't it?
12:35:18 <EvanR> yeah
12:35:49 <temoto> I don't get what sequence does there.
12:36:04 <temoto> List seems pretty ordered already.
12:36:54 <EvanR> :t sequence
12:36:55 <lambdabot> Monad m => [m a] -> m [a]
12:37:05 <ReinH> Oh wait, that's msum, isn't it
12:37:16 <EvanR> :t msum
12:37:17 <ReinH> > msum [pure "a", pure "b"]
12:37:18 <lambdabot> MonadPlus m => [m a] -> m a
12:37:19 <lambdabot>  No instance for (GHC.Show.Show (m0 [GHC.Types.Char]))
12:37:19 <lambdabot>    arising from a use of ‚ÄòM137012944145565589719742.show_M1370129441455655897...
12:37:19 <lambdabot>  The type variable ‚Äòm0‚Äô is ambiguous
12:37:27 <benmachine> no
12:37:42 <ReinH> No, it isn't.
12:37:49 <ReinH> msum is for "summable" monads
12:37:52 <ReinH> woops
12:37:58 <Zemyla> > msum [["a"], ["b"]]
12:37:59 <lambdabot>  ["a","b"]
12:38:17 <vanila> > mconcat [["a"], ["b"]]
12:38:19 <lambdabot>  ["a","b"]
12:38:39 <Zemyla> > msum [Just 1, Just 2]
12:38:40 <lambdabot>  Just 1
12:38:44 <ReinH> yep
12:38:52 <benmachine> > sequence [Just 1, Just 2]
12:38:53 <lambdabot>  Just [1,2]
12:38:57 <benmachine> > sequence [Just 1, Just 2, Just 5]
12:38:59 <lambdabot>  Just [1,2,5]
12:39:01 <benmachine> > sequence [Just 1, Just 2, Just 5, Nothing]
12:39:02 <lambdabot>  Nothing
12:39:06 <ReinH> yep
12:39:12 <temoto> oh god
12:39:31 <Zemyla> > mzero :: IO a
12:39:32 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
12:39:32 <lambdabot>    arising from a use of ‚ÄòM147245704947220378819895.show_M1472457049472203788...
12:39:32 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
12:39:32 <benmachine> sequence turns a list-of-monad-things into a monad-list-of-things
12:39:36 <temoto> It had sense until Nothing.
12:39:46 <Zemyla> :t mzero :: IO a
12:39:47 <lambdabot> IO a
12:39:51 <quchen> temoto: Maybe this helps: https://github.com/quchen/articles/blob/master/functions_comprehensible.md#sequencemapm
12:39:56 <benmachine> so for example for Maybe, you have a list of possibly-failing results, which you can turn into a possibly-failing list of results
12:40:13 <temoto> That also makes sense.
12:40:49 <benmachine> for IO you have a list of operations-that-return-results and you turn it into an operation which returns a list of results
12:40:57 <temoto> oh quchen there's precisely my task in that sequence example
12:42:07 <horny-sama> Sometimes I feel like I am a bad haskell learning coz I think I know what I am doing coz I program :<
12:42:41 <temoto> > sequence xs where xs = [Just 1]
12:42:42 <lambdabot>  <hint>:1:13: parse error on input ‚Äòwhere‚Äô
12:42:49 <rcharles> @src sequence
12:42:49 <lambdabot> sequence []     = return []
12:42:49 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:42:49 <lambdabot> --OR
12:42:49 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:43:06 <temoto> > let xs = [Just 1] in sequence xs
12:43:07 <lambdabot>  Just [1]
12:43:43 <Pamelloes> Is there a way to execute a function with a time limit?
12:44:06 <temoto> Pamelloes, run it in thread (forkIO)
12:44:11 <benmachine> you can imagine sequence [m1, m2, ..., mn] as do x1 <- m1; x2 <- m2; ... xn <- mn; return [x1,x2, ..., xn]
12:44:16 <barrucadu> SrPx: Got it, it was so simple when I actually figured it out: http://lpaste.net/2712100306430197760
12:44:28 <temoto> Pamelloes, there will be all kinds of gotchas.
12:44:38 <benmachine> Pamelloes: consider using the System.Timeout module
12:44:43 <Pamelloes> Yeah... I've worked with threads in other languages :/
12:44:50 <Pamelloes> benmachine: I'll look into it
12:45:01 <benmachine> threads in Haskell are overwhelmingly easier than they are in almost any other language ever
12:45:05 <benmachine> benefits of purity
12:45:14 <benmachine> and good libraries
12:45:17 <benmachine> and a good runtime system
12:45:42 <quchen> Pamelloes: http://hackage.haskell.org/package/base-4.7.0.2/docs/System-Timeout.html
12:45:57 <benmachine> like, threads are the standard way to multiplex IO in Haskell, they're lightweight and easy enough that that's feasible
12:46:26 <benmachine> (a Haskell thread is not an operating system thread, but something much smaller and cheaper instead)
12:47:17 <Pamelloes> That's good to hear :)
12:47:44 <Pamelloes> Using timeout looks like exactly what I'm looking for, but I'll check out threads in the future.
12:48:43 <horny-sama> gosh the not in scope error of haskell is killing e
12:49:01 <EvanR> i so wish i had a not-in-scope error in ruby
12:49:21 <EvanR> a misspelled variable in ruby is a runtime error
12:49:26 <horny-sama> EvanR: not in scope error in haskell is kinda meaningless to me
12:49:37 <temoto> > let xs = [Just 1, Nothing, Just 3]; f = filter isJust xs in sequence f
12:49:38 <lambdabot>  Just [1,3]
12:49:45 <benmachine> Pamelloes: be careful about laziness if you're trying to timeout a pure function
12:49:46 <temoto> yes!
12:49:48 <EvanR> horny-sama: you used a name that doesnt mean anything
12:49:58 <horny-sama> do you have to import some mod before using getArgs?
12:49:58 <EvanR> so youre code doesnt mean anything to anything ;)
12:50:11 <EvanR> @hoogle getArgs
12:50:12 <benmachine> horny-sama: System.Environment, yes
12:50:13 <horny-sama> EvanR: the matrix is telling me to program
12:50:13 <lambdabot> System.Environment getArgs :: IO [String]
12:50:13 <lambdabot> System.Posix.Env.ByteString getArgs :: IO [ByteString]
12:50:13 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
12:50:14 <horny-sama> ooo
12:50:41 <EvanR> thats the first time @hoogle actually worked for me in this channel
12:50:46 <temoto> horny-sama, "foo not in scope" == "symbol foo is undefined" in any other language
12:51:05 <horny-sama> lol
12:51:20 <Pamelloes> benmachine: mmm. That's a good point. Does this mean I should wrap the call in deepseq?
12:51:28 <temoto> Which is the same as "there is no such word in your code".
12:51:51 <EvanR> "on line 34, the word 'foo' does not exist in your code" ;)
12:51:53 <benmachine> Pamelloes: potentially something like that, and perhaps use Control.Exception.evaluate
12:52:15 <EvanR> temoto should write the error messages
12:52:21 <Pamelloes> benmachine: Alright :)
12:52:28 <benmachine> Pamelloes: these things may or may not be necessary depending on what you do, just something to be aware of
12:52:36 <temoto> Yeah you could actually change GHC and recompile it with new messages.
12:52:43 <temoto> horny-sama, ^
12:52:47 <EvanR> haha
12:52:51 <Pamelloes> I'm going to go play around with timeout right now. I'll report back if I run into issues :)
12:53:10 <benmachine> horny-sama: there's an online version of hoogle as well https://www.haskell.org/hoogle/
12:53:11 <SrPx> barrucadu: (just letting you know that I'm here still trying to figure what you did)
12:53:21 <SrPx> barrucadu: also, thank you
12:53:33 <benmachine> horny-sama: and this http://hayoo.fh-wedel.de/ which I think searches more stuff, but isn't as clever
12:53:49 <SrPx> (it still deosn't answer why haskell is blaming completely unrelated lines of code that are probably correct, though... wtf?)
12:54:14 <barrucadu> Well, I didn't actually try the rest of the code, but freeze at least typechecks now
12:55:25 <SrPx> The rest works! It is a total mystery why GHC complains about them when they work by just removing "freeze" from the source.
12:55:37 <SrPx> weird, no?
12:55:46 <horny-sama> https://github.com/mr-fool/haskell/blob/master/argument/arguments.hs <---I don't know why it is blowing up on me :<
12:56:02 <horny-sama> after two weeks of learning ghc still blow up in my face
12:56:22 <barrucadu> I guess the type error cascaded upwards and broke a bunch of inference
12:56:54 <barrucadu> horny-sama: Because you're trying to match a two-element list, and you're not giving it two arguments some of the time
12:57:41 <horny-sama> barrucadu: I am testing whether or not we have two inputs or not
12:57:43 <SrPx> Anyway, I guess I see the problem now - at least, I understand why my code shouldn't check and why forall makes sense there. I hope I'll be able to solve the same kind of issue if I face it again. Thank you :)
12:58:03 <horny-sama> if I got 0 args do x else if 1 args do y
12:58:21 <barrucadu> horny-sama: No you're not, empty arguments don't get filled in with empty strings
12:58:40 <horny-sama> barrucadu: then what do you fill it in with?
12:58:47 <barrucadu> You could do: do { args <- getArgs; putStrLn $ "You gave " ++ length args ++ " arguments" }
12:58:56 <barrucadu> Nothing, it's like any other finite-length list
12:59:33 <horny-sama> barrucadu: is length I predefined function?
12:59:38 <barrucadu> Yes
12:59:40 <barrucadu> :t length
12:59:41 <lambdabot> [a] -> Int
13:01:11 <temoto> Pamelloes, things to check: long calls finishing, number of OS threads used, file descriptor and memory leak, performance regression with many concurrent timeouts. All of which in 3 cases: when call under timeout is actually long but finishes before limited time, when it timeouts and when it exits fast.
13:03:02 <horny-sama> barrucadu: is there a reason why you have the $ sign?
13:03:49 <temoto> horny-sama, read it as parens for code to the right of $.
13:04:12 <temoto> horny-sama, putStrLn $ x y z = putStrLn (x y z)
13:04:46 <utdemir> Hey. Suppose we got `type Foo = FreeT FooF IO` (from E. Kmett's `free`). Now I want to write the function `bar :: Foo a -> Foo a` which processes some steps of that monad(in my case, it prints the individiual actions). But I couldn't find a way to get indiviudal steps from a free monad transformer independent from base functor. The closest thing is `runFreeT` which yields an IO, and I couldn't get a Foo back from it.
13:04:55 <horny-sama> temoto: okay
13:04:55 <temoto> horny-sama, does it make sense?
13:05:43 <horny-sama> temoto: yes
13:06:18 <temoto> $ is one of scarsely few things in Haskell that I understand. :)
13:07:35 <horny-sama> https://github.com/mr-fool/haskell/blob/master/argument/arguments.hs <--- gosh you can't concat to print it as a long ass string?
13:07:46 <horny-sama> temoto: haskell in general is scary
13:08:45 <chaosmasttter> utdemir: what do you mean by "prints the individual actions"?
13:09:18 <temoto> :t (++) -- horny-sama
13:09:19 <lambdabot> [a] -> [a] -> [a]
13:09:32 <temoto> :t length
13:09:33 <lambdabot> [a] -> Int
13:09:42 <temoto> Int != [a]
13:10:06 <temoto> Int != String in your case
13:10:09 <horny-sama> then I need a way to convert length args into a string :<
13:10:15 <temoto> Right.
13:10:34 <temoto> You could use `show $ length xs`
13:12:36 <horny-sama> ok
13:13:05 <utdemir> chaosmasttter: Sorry, I'll try to be more clear. Suppose user written a program using a DSL made with free. And he can run it like `runFoo (action1 >>= action2)`. Now I want to provide a function that prepends (`liftIO $ putStrLn "doing stuff"`) in front of every action, now she can run it like `runFoo $ log $ action1 >>= action2`.
13:13:54 <temoto> horny-sama, on scary in general, I'd say there are 3 parts: lovely pure functional language (fold, filter, Maybe a), complicated but understandable Applicative part, and really scary mathematician Ph.D stuff.
13:14:21 <horny-sama> I am no math guy so I found haskell to be scary in general
13:15:00 <ChristianS> horny-sama: do don't need math for haskell
13:18:23 <temoto> I'm no math guy either so faced with certain code I say ok it's too much, #haskell is full of people who understands it and I could make something useful in other task.
13:19:43 <temoto> But, but, but. Below that crazy math stuff, in general Haskell is a very lovely language and most of it really makes sense even for ordinary man.
13:20:23 <horny-sama> ChristianS: I found haskell notation to be math ish
13:20:44 <temoto> Maybe Computer Science term is better fit than math.
13:21:09 <horny-sama> I guess
13:21:55 <chaosmasttter> utdemir: so you want to map over the actions?
13:22:10 <chaosmasttter> :t hoistFreeT
13:22:11 <lambdabot> Not in scope: ‚ÄòhoistFreeT‚Äô
13:22:12 <utdemir> chaosmasttter: Yes, you're right
13:22:23 <joshcough> hello. i just looked here: https://www.haskell.org/ghc/download_ghc_7_8_4#binaries, and i see that there are no binaries for OSX, but there are for 7.8.3. anyone know why that is?
13:22:30 <benzrf> computer science is math
13:23:11 <ChristianS> computer science is engineering!
13:23:19 <utdemir> chaosmasttter: hoistFreeT :: (forall a. m a -> n a) -> FreeT f m b -> FreeT f n b
13:23:25 <ChristianS> uh, maybe not. actually it's something else altogether.
13:23:46 <utdemir> everything is physics.
13:23:48 <glguy> joshcough: Because the guy that usually makes them hasn't
13:23:49 <chaosmasttter> maybe hoistFreeT (putStrLn "doing stuff" >>) could work.
13:24:11 <utdemir> chaosmasttter: Looking to it
13:24:18 <temoto> utdemir, and physics is a small part of math that deals with this particular universe :)
13:25:12 <joshcough> glguy: ok. thanks. i think. is there anything i can do to help that person?
13:25:28 <glguy> joshcough: I'd imagine not
13:26:01 <temoto> Can I disable Top-level binding warning for one particular definition?
13:26:19 <temoto> (Top-level binding with no type signature)
13:27:24 <utdemir> chaosmasttter: That was just pure black magic. It compiled. Now trying.
13:27:26 <Hijiri> computer science is math engineering
13:28:48 <jophish> What's the name for this data structure: data SomeKindOfLabeledTree a = T a [SomeKindOfLabeledTree a]
13:28:56 <vanila> jophish, Rose
13:29:11 <vanila> data Rose a = a :- [Rose a]
13:29:13 <jophish> vanila: Do rose trees label the nodes?
13:30:09 <jophish> hmm, for some reason I had a complete blank. Of course they do
13:30:12 <edwardk> who is the person who usually does the osx builds, anyways?
13:30:15 <jophish> thanks vanila :)
13:31:04 <temoto> and where he lives...
13:31:04 <sanjoy> So I have fromIntegral that I can use to get Int8 to Int16 (say) with sign extension.  How do I zero-extend an Int8 to an Int16?
13:31:52 <dfeuer> I wonder if it would be possible to use some newer GHC features and libraries like HList to make http://ryani.freeshell.org/haskell/systemf.hs more better (e.g., get rid of the non-exhaustive matches).
13:32:07 <temoto> > (fromIntegral 255::Int8) ::Int16
13:32:09 <lambdabot>  Couldn't match expected type ‚ÄòGHC.Int.Int16‚Äô
13:32:09 <lambdabot>              with actual type ‚ÄòGHC.Int.Int8‚Äô
13:32:16 <utdemir> chaosmasttter: Yes, it worked, thank you very much. Do you also happen to know can I dispatch using the exact action? I mean, I want to get "doing get", "doing put" depends on the action now.
13:32:19 <sanjoy> Ugh, should have RTFM
13:32:25 <sanjoy> Coercing to adn from word8 will give me what I need.
13:32:47 <geekosaur> temoto, move the open paren from before fromIntegral to before 255
13:33:21 <temoto> > let i8 = 255::Int8 in (fromIntegral i8)::Int16
13:33:23 <lambdabot>  -1
13:33:39 <temoto> > let i8 = 255::Word8 in (fromIntegral i8)::Int16
13:33:40 <lambdabot>  255
13:34:11 <benzrf> hmm
13:34:13 <temoto> horny-sama, see that's the lovely functional language part that totally makes sense to ordinary man.
13:34:25 <temoto> geekosaur, thanks
13:34:27 <benzrf> just realized that any kind of tree can be realized with the appropriate parameters to Free
13:34:38 <benzrf> @src Tree
13:34:38 <lambdabot> Source not found. My brain just exploded
13:34:42 <benzrf> huh
13:34:45 <horny-sama> install ghc-7.8.4 on fedora = hard
13:35:03 * hackagebot playlists 0.3.0.0 - Library and executable for working with playlist files.  http://hackage.haskell.org/package/playlists-0.3.0.0 (PeterJones)
13:35:05 <horny-sama> = impossible to install SYstem.Random
13:35:58 <benzrf> hmm, actually even just Mu
13:36:04 <benzrf> bleh!
13:36:06 <temoto> horny-sama, super easy: docker run -i -t dock0/arch /bin/bash   pacman -Sy ghc
13:36:19 <horny-sama> temoto: let's not fedora
13:37:04 <temoto> horny-sama, that's a container inside fedora. I mean it solves the task of "having ghc"
13:37:55 <horny-sama> temoto: I have ghc-7.8.4 installed but the problem is it is missing the System.Random module and I have to figure out how to install it
13:38:22 <temoto> Without that, installing any new software into release based (frozen version) distributions is always hard, yes.
13:38:47 <temoto> horny-sama, pro
13:39:04 <horny-sama> temoto: newest version of ghc
13:39:15 <temoto> horny-sama, probably missing some kind of --enable-random-source flag to configure
13:39:35 <horny-sama> temoto: you are probably right ghc-pkg list random
13:39:36 <horny-sama> /usr/lib64/ghc-7.8.4/package.conf.d
13:40:26 <chaosmasttter> utdemir: how would you get the action name if you had a plain action?
13:41:19 <utdemir> case x of { Free (Get x next) -> ..; Free (Set x next) } ? Or am I completely lost?
13:42:06 <temoto> horny-sama, that's interesting, I don't have System.Random either. Turns out, you need to cabal install it.
13:42:27 <horny-sama> temoto: are you using fedora?
13:42:33 <temoto> horny-sama, nope, arch
13:42:33 <horny-sama> yum install cabal?
13:42:45 <temoto> yum search cabal is what i'd do
13:42:53 <chaosmasttter> so the action is encoded in your functor?
13:42:59 <Hijiri> temoto: you can't usethe official ghc binary distribution?
13:43:38 <Hijiri> it's just configure -> make like a source distribution
13:43:39 <temoto> Hijiri, I installed official Archlinux binary ghc package.
13:43:52 <utdemir> chaosmasttter: Yeah, you can look at it: https://github.com/utdemir/handsy/blob/master/src/System/Handsy/Internal.hs
13:43:54 <temoto> it doesn't have System.Random out there
13:44:00 <horny-sama> Package ghc-Cabal-1.18.1.5-38.1.fc21.x86_64 already installed and latest version <---but I don't call it
13:44:01 <horny-sama> :<
13:44:12 <Hijiri> I guess you would need to install cabal too
13:44:22 <horny-sama> Hijiri: it is installed
13:44:24 <Hijiri> @temoto
13:44:25 <lambdabot> Unknown command, try @list
13:44:34 <horny-sama> ghc-Cabal is installed
13:44:35 <temoto> Hijiri, I have cabal and it works Just "wonderful"
13:44:46 <barrucadu> There is a difference between Cabal and cabal-install
13:44:46 <geekosaur> Cabal is the library, cabal-install is the cabal binary
13:44:58 <temoto> yeah, i have cabal binary and all
13:45:00 <geekosaur> (historical reasons)
13:45:20 <horny-sama> so i need cabal and cabal-install?
13:45:22 <temoto> just didn't expect System.Random not to be immediately available (like battery included)
13:45:30 <Hijiri> cabal works fine for me, with the caveat of aggressive sandboxing
13:45:41 <temoto> horny-sama, which cabal || yum install cabal-install
13:46:01 <horny-sama>  which cabal || yum install cabal-install
13:46:01 <horny-sama> /usr/bin/cabal
13:46:21 <temoto> horny-sama, so you have it and don't need to install anything else. cabal install random
13:46:36 <temoto> Yeah one thing Python taught me is that everything must be done in sandboxes.
13:46:40 <horny-sama> temoto: I jsut installed it
13:46:56 <temoto> horny-sama, so import System.Random must work then.
13:47:09 <horny-sama> temoto: cabal install random atm
13:48:44 <horny-sama> temoto: http://www.fpaste.org/174072/21359661/ but still can't run code with import System.Random
13:50:21 <temoto> horny-sama, but do you also "run code" as root?
13:50:27 <horny-sama> no
13:50:33 <horny-sama> I don't run code as root
13:50:54 <horny-sama> i installed as root not for my user
13:50:56 <temoto> horny-sama, then you either need to `cabal install random` as user or `cabal install --global random`
13:50:58 <Hijiri> cabal installs packages to your user directory
13:51:02 <Cale> Why were you root when you installed random?
13:51:04 <Hijiri> by default
13:51:04 <horny-sama> got it
13:51:11 <Hijiri> if you install it as root it will install it to root's home directory
13:51:25 <temoto> Cale, we're new
13:51:47 <temoto> to haskell but not new to other installation schemes
13:51:50 <Cale> Okay, yeah, I would recommend to just install as your own user.
13:52:18 <Cale> It has the nice property that if you screw up, you can just delete ~/.ghc and start over.
13:52:19 <orzo> Is there any easy way to recurse a polymorphic function deep into an algebriac data type without having to write a lot of trival cases?
13:52:32 <Cale> without having to reinstall GHC
13:53:19 <barrucadu> orzo: You can possibly use the generic programming functionality in Data.Data
13:53:42 <Cale> orzo: I'm not sure what that means, but yeah, there are lots of schemes for "generics" now.
13:54:03 <trap_exit> in haskell, is it possible to create recursive values? imagine this: I'm impelemnting an "env" and a "variable" ... the "env" has a [var] which is a list of all vars in the env, the "var" has a "parent=env" filed which lists it's parent env
13:54:21 <trap_exit> thus, the env needs ot refer to the value and the value needs to refer to the env, without using modification, only using purity, is it possible ot create this?
13:54:35 <Arahael> trap_exit: You mean, as an infinite list?
13:54:52 <trap_exit> no, the env only has a finite # of vars
13:54:56 <trap_exit> but each var needs to have a 'pointer' back to the env
13:55:08 <trap_exit> the question is: is it posisble to create this in haskell
13:55:10 <glguy> trap_exit: Yes, you can do that as a consequence of laziness
13:55:15 <Cale> There's no way to tell if a structure is infinite or cyclic, but yes.
13:55:18 <trap_exit> glguy: how ?
13:55:32 <exio> env = [("parent", env)] -- something like this?
13:55:40 <Cale> > let x = 1 : y; y = 2 : z; z = 3 : x in x
13:55:41 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
13:56:11 <Cale> ^^ this is a cyclic structure in memory
13:56:17 <glguy> trap_exit: let env = Env [Var 1 env, Var 2 env]    -- given a data Var = Var Int Env
13:56:18 <glguy> You just do it
13:56:44 <glguy> Search around for "tying the knot"
13:56:46 <Cale> It's important that 'env' there is a variable
13:57:15 <Cale> let f x = Env [Var 1 (f x), Var 2 (f x)] will not result in a cyclic structure, just an infinite one
13:58:17 <Cale> trap_exit: It's really hard to work with such values without destroying the cycles
13:58:57 <Pamelloes> How can I make a cabal project in one sandbox depend on another cabal project in a different sandbox?
13:59:29 <jmcarthur> Pamelloes: i would just put both projects into the same sandbox
14:00:02 <glguy> Pamelloes: try "cabal help sandbox" and read about "add-source"
14:00:16 <Pamelloes> glguy: Thanks :)
14:00:19 <jmcarthur> that answer is probably more helpful than mine :)
14:01:16 <chaosmasttter> utdemir: what u want does not seem possible ...
14:01:24 <Pamelloes> jmcarthur: I would add them to the same sandbox in normal circumstances, but they're in separate git repositories so they are located such that a common sandbox would be very annoying
14:02:05 <jmcarthur> Pamelloes: ah. i normally just put them in subdirectories of the same parent directory
14:03:21 <orzo> I want to traverse a tree with the following rules: types will be preserved for all nodes, compound nodes will recurse into each of their children according to fiity, simple nodes of type (Ident String) will apply a given (f :: String -> String) to modify the value, and other simple nodes will pass through unaltered.
14:03:30 <orzo> Can i do that easily with Data.Data ?
14:03:48 <orzo> s/fiity/fixity/
14:05:56 <Pamelloes> Is there an easy way to uninstall all packages installed with cabal?
14:06:07 <Pamelloes> (except for base)
14:08:02 <Hijiri> Pamelloes: rm -rf ~/.ghc/<architecture_name>
14:08:11 <Pamelloes> Thanks
14:08:12 <Hijiri> rm -rf ~/.ghc is ok too if you haven't changed any config files in there
14:08:13 <jmcarthur> Pamelloes: you can remove all locally (to your user) installed packages by just removing $HOME/.ghc. this will not remove globally installed packages, such as base. it will also leave alone any local executables you installed with cabal (which live under $HOME/.cabal/bin)
14:10:41 <horny-sama> kqr guide on haskell is awesome
14:10:42 <horny-sama> :P
14:11:50 <chaosmasttter> utdemir: seems that i was wrong ...
14:12:52 <utdemir> chaosmasttter: about hoistFreeT?
14:13:01 <chaosmasttter> i could construct a function of type transformFreeT :: (Functor f, Functor g, Functor m) => (forall a . f (m a) -> g (m a)) -> FreeT f m b -> FreeT g m b
14:13:22 <chaosmasttter> this function should be able to do what you want
14:13:40 <utdemir> chaosmasttter: transFreeT :: (Monad m, Functor g) => (forall a. f a -> g a) -> FreeT f m b -> FreeT g m b Source
14:14:34 <lpaste> chaosmasttter pasted ‚ÄútransformFreeT‚Äù at http://lpaste.net/119154
14:15:44 <chaosmasttter> utdemir: with transFreeT you can only change the functor but not the monad
14:16:13 <utdemir> chaosmasttter: I should read a lot more to understand this. Thank you very much. (Btw thanks for LambdaCase extension!)
14:16:30 <utdemir> chaosmasttter: I'll try to understand and use your solution
14:21:01 <Majmun> https://www.youtube.com/watch?v=hv_ChWx1zn0
14:29:06 <Dodek> that's weird: i get linker errors when trying to use lens' template haskell helpers
14:29:50 <Dodek> i created some cabal package with a library, installed it, and use it in my cabal package with executable
14:30:09 <Dodek> and as long as i don't do $(makeLenses ''Foo), it compiles fine
14:31:07 <Dodek> but when i do this, i get "can't load .so, undefined symbol"
14:31:14 <Dodek> in my library i just created
14:32:15 <FMcC> Is a Trie the best way to map strings to values with Haskell? Or is there something more efficient? (new to haskell...)
14:32:33 <glguy> Dodek: if you replace $(makeLenses ''Foo) with  $(return []) , do you still get the error?
14:32:59 <Dodek> glguy: yeah, the same
14:33:03 <utdemir> FMcC: If most of your strings share a common prefix and memory usage is important, yeah, tries are pretty good.
14:33:39 <utdemir> FMcC: Depends on your data, but I'd go with a simple Data.Map
14:34:10 <glguy> Dodek: So it's just a template haskell problem, then
14:34:35 <Dodek> seems so, yeah.
14:34:42 <glguy> Dodek: .so files are shared objects. It might be that you need to have compiled your packages with --enable-shared to use them with template haskell
14:34:47 <Hijiri> you probably don't want Data.Map for Strings
14:34:54 <Hijiri> because it's a tree
14:34:59 <Hijiri> it will have to do comparisons at each branch
14:35:07 <glguy> (I've always had that enabled by default, so I'm not actually sure if that's the requirement)
14:35:12 <Hijiri> Trie or HashMap is pro
14:35:17 <Hijiri> bably better for strings
14:35:30 <Hijiri> but you don't really need to worry about it unless it turns out to be a problem
14:35:32 <FMcC> utdemir: I guess it's only actually a subset that have a common prefix
14:36:25 <FMcC> it's all stuff like: ")/a" -> value
14:37:31 <utdemir> FMcC: Well, the only true answer would come from benchmarking...
14:37:39 <Dodek> glguy: it doesn't help
14:38:00 <glguy> Dodek: You reinstalled the library associated with the missing .so file?
14:38:12 <glguy> Which was the .so file?
14:38:24 <FMcC> sweet, I'll try the trie first of all and see how it goes.
14:38:33 <Dodek> glguy: i reinstalled it, yeah
14:38:36 <Dodek> https://ghc.haskell.org/trac/ghc/ticket/8060
14:38:41 <Dodek> this looks a bit similar to my situation
14:41:22 <RyanGlScott> I need a function which detects if a string represents a valid Haskell infix function. Has a library like haskell-src implemented this?
14:44:19 <pecanpy> hey. i just posted some ideas to /r/haskell. wondering if anyone would like to discuss? http://www.reddit.com/r/haskell/comments/2tjwij/uniform_access_to_data_in_haskell_exploring_the/
14:50:07 * hackagebot haskell-src 1.0.2.0 - Support for manipulating Haskell source code  http://hackage.haskell.org/package/haskell-src-1.0.2.0 (HerbertValerioRiedel)
14:50:15 <Dodek> glguy: exporting all modules from library solved this problem
14:50:24 <Dodek> glguy: but i don't want to export them all :(
14:50:38 <glguy> OK, glad you figured it out :)
14:51:34 <hpc> RyanGlScott: Data.Read has a function called lex, which is a valid standard haskell lexer
14:51:47 <hpc> it's implemented in ghc in terms of hsLex, which is here:
14:51:48 <hpc> http://hackage.haskell.org/package/base-4.7.0.2/docs/src/Text-Read-Lex.html#hsLex
14:53:04 <zachk> how do I update the base-x.x.x.x package using cabal?
14:53:23 <mpickering> you can't
14:53:32 <hvr> zachk: you'd need to update GHC
14:53:34 <mpickering> it's linked to your version of ghc
14:53:59 <Zemyla> What is the default definition of Alternative on a MonadPlus?
14:54:12 <mjrosenb>     Module ‚ÄòData.Typeable‚Äô does not export ‚ÄòTypeable(typeOf)‚Äô
14:54:15 <mjrosenb> :-(
14:54:21 <glguy> (<|>) = mplus   empty = mzero
14:54:39 <zachk> hvr: I updated the haskell platform ghc to the latest ghc I believe
14:54:52 <hvr> zachk: but why do you want to update base?
14:54:58 <glguy> mjrosenb: import Data.Typeable (Typeable, typeOf)
14:54:59 <zachk> oops guess I didnt
14:55:22 <shachaf> mjrosenb: Typeable uses typeRep now.
14:59:17 <Hijiri> haskell platform doesn't have the newest ghc
14:59:23 <Hijiri> or can it
14:59:25 <Hijiri> I don't know
15:00:00 <geekosaur> it does not, and it's usually not a good idea to try to switch it to a newer one (although in the current case it might well work since it's just bug fixes)
15:02:41 <tejas-manohar> yo
15:02:57 <tejas-manohar> if im learning haskell, what are some cool things to try to write as a play project?
15:03:05 <tejas-manohar> awesome if it still has meaning to others ;)
15:11:56 <jophish> Yo yo yo
15:13:31 <zachk> hi hi :D
15:15:22 <quchen> tejas-manohar: In no particular order: IRC bot, webserver, Brainfuck interpreter, Scheme interpreter, table prettyprinter
15:15:50 <shelf> agh. anyone know a better time formatting library than Data.Time.Format?
15:15:59 <Pamelloes> quchen: Brainfuck interpreter! :D
15:16:33 <tejas-manohar> and what do you guys deem as the holy grail of haskell tutorials/books/learning resources
15:16:37 <shelf> I'm trying to render HH:MM:SS:ms but cannot figure out how to round it to the ms
15:17:02 <tejas-manohar> im a hands-on, lets go for it kinda learner-- reading a book can sometimes bore me but watching tutorials or reading short tutorials and running some stuff in console, that's different
15:17:35 <Hijiri> I don't know about holy grail, but the main guide this guide recommends has good exercises
15:17:37 <jle`> tejas-manohar: what do you usually do for a toy project in other languages?
15:17:37 <Hijiri> @where learnhaskell
15:17:38 <lambdabot> https://github.com/bitemyapp/learnhaskell
15:18:00 <quchen> We only have three holy grails for beginners: LYAH, Hutton, RWH. LYAH and Hutton are beginner books. LYAH is funnier, Hutton is maybe more practical. RWH is very practical, but I'd recommend reading a bit in the other two books before going for it.
15:18:04 <Pamelloes> Hijiri: Beat me to it, I was going to say the exact same thing :)
15:18:16 <Hijiri> RWH is outdated
15:18:17 <bananagram> so was I
15:18:29 <Hijiri> LYAH has no exercises
15:18:34 <tejas-manohar> jle`: usually real quick beginning of codecademy, then go on to dev'ing a web backend or something for a random project of mine
15:18:46 <quchen> Newtonian physics is outdated too. Doesn't mean it's not still useful.
15:18:52 <jophish> Is there much of a difference between Data.Vector.Unboxed and Data.Vector.Storable?
15:18:59 <quchen> Yes.
15:19:02 <tejas-manohar> jle`: tbh, i usually don't learn new software to learn new software-- i have an idea and im like ohh ill try this thing now that i have something to build so not too good of thinking of test projects
15:19:17 <jle`> tejas-manohar: ah, so you haven't really gone through test projects in other languages?
15:19:36 <jle`> usually the best toy projects in haskell for me was to re-do what i did in my previous languages :)
15:19:49 <quchen> jophish: Storable means "can be written so C can work with it". Unboxed means "the values will be unboxed".
15:20:12 <jophish> I've been assuming that under the hood these are essentially the same thing
15:20:22 <tejas-manohar> jle`: im only trying haskell for its awesome functionalness -- no, not really i havent much
15:20:28 <tejas-manohar> jle`: ah
15:20:38 <Hijiri> tejas-manohar: If you start with a toy project, make sure you understand everything you're typing
15:20:41 <tejas-manohar> jle`: hmm, so a web backend in haskell as my first project, fun
15:20:48 <tejas-manohar> Hijiri: yeah, for sure
15:20:54 <jle`> this is an unrelated note, but haskell's functional aspects ended up not being the thing that kept me with haskell :D
15:20:57 <jle`> tejas-manohar: heh, maybe not web then :P
15:21:06 <jle`> how about a command line hangman game?
15:21:13 <tejas-manohar> jle`: haha yeah
15:21:17 <tejas-manohar> hmmm
15:21:22 <tejas-manohar> that'd be legit
15:21:30 <jle`> it's actually a project taht you can do at every stage of haskell learning
15:21:35 <jophish> What I'm doing at the moment is reading a bunch of arrays from C and I'm trying to see how easily I can tie them to the lifetime of their container object
15:21:45 <jle`> and at every stage, they'll do it in a different way
15:21:50 <Pamelloes> jle`: Ooh, I did one of those to learn C++! That program was so boss.
15:21:53 <jle`> every month you could probably re-write a hangman game in a new way, heh
15:22:21 <Pamelloes> After completing it I realized I didn't like C++ though, so I think that's my only C++ program.
15:22:37 <tejas-manohar> ah
15:22:53 <jle`> the beginning steps is just to make your whole game a (GameState -> String -> GameState) function.  it takes a game state, a string, and outputs a new gamestate that you can print out and use for the next round
15:23:01 <jle`> and wrap it all together with a recursive io loop
15:23:09 <jle`> (the string is the input from the user)
15:23:28 <tejas-manohar> yeah
15:23:47 <jle`> if you wanted your game function to also determine the string to print it can be `GameState -> String -> (GameState, String)`.  but your recursive loop can be the one to generate the string too if you can make it from the output gamestate
15:23:48 <temoto> Warning: shameless narcissism. https://github.com/temoto/herdis-server I still think doing web backend in Haskell even for a first project is actually a good idea.
15:23:58 <jophish> Data.Vector.Storable unsafeFromForeignPtr seemed like a good fit if not for the fact that the block of memory with the vector data is not pointed to directly by the ForeignPtr I need to free
15:24:00 <tejas-manohar> i'm confident i can write this in js, ruby, or java w/o trouble -- so logic is down pat
15:24:37 <tejas-manohar> temoto: i wouldnt say herdis is the standard "web dev"
15:24:39 <jophish> I'm thinking that the easiest way around this is to implement some kind of reference counting on the ForeignPtr that holds onto the vector data in C-land
15:24:47 <Pamelloes> tejas-manohar: None of those are functional. Don't be overconfident :P
15:24:49 <jophish> although this does seem a little nasty
15:25:13 <temoto> tejas-manohar, it's not exactly HTTP backend, but pretty close.
15:25:33 <jle`> my blog engine was my third or so haskell project
15:25:34 <jophish> It would certainly be nice to be able to express dependencies between foreign pointers
15:25:48 <jle`> and at that time i was able to know enough to be able to learn a lot from it
15:25:53 <jle`> i couldn't imagine doing it any earlier though
15:25:55 <Pamelloes> I have a function a -> (b,a). Is there an easy way to turn this into a -> Int -> ([b],a) where the int is how many times the function gets chained?
15:26:00 <temoto> tejas-manohar, stateless client connections, simple commands.
15:26:12 <temoto> text syntax
15:26:19 <tejas-manohar> temoto: ah ok, ill take a deeper look
15:26:20 <jle`> Pamelloes: you can use take and unfoldr
15:26:42 <jle`> or take and iterate
15:26:44 <Hijiri> Pamelloes: use swap and replicateM ?
15:27:03 <Hijiri> oh, does (,) a even have Monad
15:27:04 <Pamelloes> Huh, I've never heard of unfoldr. Sounds like it could be what I need.
15:27:08 <Hijiri> (or Applicative)
15:27:13 <Pamelloes> Hijiri: I think so...
15:27:13 <jle`> Hijiri: it does; it's Writer
15:27:23 <Hijiri> oh yeah, but then a has to be monoid
15:27:36 <Hijiri> You could use First or something
15:27:38 <jle`> Pamelloes: it's a little inconvenient because as it is, it needs a -> (b, Just a)
15:27:40 <jle`> *Maybe
15:27:55 <Hijiri> a -> (b, First a)
15:27:58 <jle`> oh, Monad instance for Writer might work there actually.  but you'd need that iterateM, which is not found in any library
15:27:59 <Hijiri> Maybe still needs monoid
15:28:03 <jle`> *found in base
15:28:07 <jle`> the Monoid would be [b]
15:28:19 <Hijiri> oh, I was still thinking in terms of swapping it
15:28:28 <jle`> the point is to iterate the (a -> (b, a)) several times, and aggregate all of the [b]'s
15:28:36 <Hijiri> where do we get the a?
15:28:37 <temoto> Pamelloes, how did timeout thing go?
15:28:52 <jle`> Hijiri: the initial `a` is a parameter in the final function
15:29:02 <Hijiri> oh, I thought it was just a constant a
15:29:05 <quchen> jophish: To be honest I have no idea how Storable vectors work, but the code looks dramatically different than Unboxed. I'm really surprised indexing a Storable is not in IO, for example.
15:29:10 <Hijiri> ok, I was misinterpreting the whole thing
15:29:28 <Pamelloes> temoto: From my tests it seems to have worked, but I've only wrote a proof of concept so far. I'm working on a larger project and haven't gotten to the point where I need timeout yet.
15:29:28 <jle`> yeah this is a nice iterateM in Writer.  but too bad there's no iterateM in base
15:29:56 <jophish> quchen: As far as I understand, a storable vector holds onto a ForeignPtr where the memory is, and the garbage collector is used to run the cleanup IO action
15:30:03 <jle`> if you wanted to avoid Writer you can use iterate i think too...
15:30:13 <jophish> I guess the actual indexing is done with unsafePerformIO
15:31:01 <quchen> jophish: Sure, but Storable means you can give it to C, which happily mutates your data
15:31:10 <Pamelloes> Is there an easy way to turn a-> b into a->Maybe b?
15:31:19 <jle`> Pamelloes: fmap Just
15:31:29 <jle`> or fmap (const Nothing)
15:31:36 <jle`> :P
15:31:41 <quchen> or (Just .)
15:31:44 <Pamelloes> I always forget (->) is a Functor....
15:32:08 <jle`> oh that reminds me to write down all the ways to do (.) in base and common libraries
15:32:09 <quchen> :t \f -> Just . f -- there is no tax for pointful style
15:32:10 <lambdabot> (a -> b) -> a -> Maybe b
15:32:30 <quchen> jle`: While you're at it, find out how many functions unify with `id`
15:32:32 <jle`> :t rmap Just
15:32:33 <lambdabot> Profunctor p => p a b -> p a (Maybe b)
15:32:42 <jle`> :t (Just <<^)
15:32:43 <lambdabot> (b -> a) -> b -> Maybe a
15:32:49 <quchen> Eww.
15:32:53 <Pamelloes> wut
15:33:00 <jle`> :t (^>> Just)
15:33:01 <lambdabot> (b -> a) -> b -> Maybe a
15:33:24 <jle`> :t (Just ^<<)
15:33:25 <lambdabot> Arrow a => a b c -> a b (Maybe c)
15:33:28 <jle`> heh.
15:33:45 <jle`> there's a hundred in Control.Arrow alone
15:33:48 <jle`> not literally a hundred, but close
15:33:48 <Pamelloes> If I want to use Writer, do I have to add mtl, or is defined elsewhere?
15:33:53 <temoto> I'm in wut state 99% time reading this channel.
15:34:00 <glguy> Writer is defined in transformers
15:34:01 <jle`> Pamelloes: it should be in transformers
15:34:15 <jle`> but...
15:34:16 <Pamelloes> mm, so basically nowhere in Prelude
15:34:30 <jle`> i wonder why there is no Monad instance for Monoid m => (,) w
15:34:41 <jle`> er, Monad w
15:34:43 <jle`> Monoid w
15:34:50 <glguy> jle`: there's an Applicative instance, at least
15:34:55 <jle`> there is, but...
15:35:09 <quchen> jle`: Suggest it on the mailing lists and see them burn
15:35:10 <jle`> Pamelloes's usage needs the Monad instance
15:35:20 <jle`> quchen: heh.  burn with anger?
15:35:27 <Pamelloes> it does?
15:35:32 <jle`> yeah for iterateM
15:35:37 <jle`> which also is not in base
15:35:38 <quchen> "(,) are stupid and should be replaced with an expressive custom type" vs "but it's a correct instance"
15:35:38 <Pamelloes> :t iterateM
15:35:39 <lambdabot>     Not in scope: ‚ÄòiterateM‚Äô
15:35:39 <lambdabot>     Perhaps you meant one of these:
15:35:39 <lambdabot>       ‚Äòiterate‚Äô (imported from Data.List),
15:35:40 <zachk> i broke my haskell install bad installing the new version, should i reinstall cabal as well?
15:35:49 <Pamelloes> Alright, what's iterateM?
15:35:51 <jle`> it's in johnw's library tho
15:36:08 <jle`> :src iterate
15:36:12 <jle`> @src iterate
15:36:13 <lambdabot> iterate f x = x : iterate f (f x)
15:36:23 <jle`> um
15:36:52 <jle`> just repeatedly re-appling an (a -> m a) to an `m a`
15:37:00 <temoto> I'm still enhancing quickcheck regex generator and I wonder if it's possible to stop QuickCheck.listOf upon meeting certain Gen a.
15:37:18 <jle`> i've needed to do this a few dozen times already but every time i had to re-write it v.v
15:37:37 <quchen> jle`: monad-loops?
15:37:45 <jle`> monad-loops doesn't have it i think
15:37:56 <quchen> Wow, that's a first
15:38:38 <quchen> It has two such functions even! iterateM_ and iterateWhile
15:38:39 <temoto> So I have say f :: Gen a   f = Q.listOf1 "abc"    and it successfully generates random strings of these 3 chars, now I want to make sure that if c is present, there is no other character after it.
15:38:42 <jle`> it's in johnw's utility library but i always forget the name
15:39:12 <temoto> But in reality it's not listOf1 "abc", it's listOf1 g  and g is very complicated.
15:39:33 <jle`> oh, monad-extras
15:39:38 <jle`> wait, is that really it?
15:39:49 <temoto> I think maybe some kind of monadic   fail   could help?
15:39:59 <temoto> or was it error
15:40:18 <quchen> jle`: om and nom, oh my goodness. acme-monad or what
15:40:31 <jle`> lol
15:40:46 <jle`> apparently these are things they've used often.
15:40:57 <quchen> Hahaha and it has goto
15:41:06 <quchen> (called "label"
15:41:06 <quchen> )
15:41:47 <jle`> haha
15:42:28 <jle`> they have some interesting aliases
15:42:34 <quchen> And the infamous "om" function
15:42:57 <quchen> Defined as "(m >>=) . flip f" for readability purposes
15:43:09 <jle`> "subsumes the need for whenM, unlessM, etc."
15:43:13 <jle`> huh.
15:43:23 <quchen> It's also "Combinator for working with monadic values"
15:43:27 <jle`> i guess that's true
15:43:46 <quchen> I remember when om was suggested on the mailing lists and I was just sitting in front of it wondering what the point of it was :-D
15:43:49 <jle`> still seems a bit too specialized/esoteric though, despite its generalizedness
15:43:59 <jle`> i've needed to have such a function more than once
15:44:02 <zachk> whats the channel for haskell game dev
15:44:06 <HeladoDeBrownie> #haskell-game
15:44:08 <jle`> but then i just realized that things like this are exactly what do notation was invented for
15:46:26 <jle`> okay so i tested it Pamelloes, your thing does work with iterateM on a Monad instance for Monoid w => (,) w
15:46:31 <jle`> it turns out pretty nicely too
15:47:11 <jle`> take n . fst $ iterateM (first (:[]) . f) x0
15:47:37 <jle`> if f :: a -> ([b], a), then it's just `iterateM f x0`
15:48:01 <Pamelloes> Awesome :)
15:48:14 <jle`> too bad there is no such Monad instance in base and iterateM is in a utility library
15:48:51 <Pamelloes> I realized my program already depends on mtl/transformers so I just defined iterateM myself
15:49:14 <jle`> oh
15:49:17 <jle`> it's even easier with unfoldr
15:49:27 <jle`> unfoldr (Just . f) x0
15:49:39 <Pamelloes> jle`: The issue is I need to access both elements
15:49:42 <jle`> take 10 . unfoldr (Just . f) $ x0
15:49:46 <Pamelloes> So unfoldr doesn't work for me ;)
15:50:21 <jle`> ah, yes
15:50:43 <jle`> you could do it, it is just a little dirtier :)
15:52:30 <Pamelloes> what's (,)'s functor definition?
15:53:05 <jle`> i don't want to rob you of the fun :)
15:53:16 <jle`> fmap :: (a -> b) -> (w, a) -> (w, b)
15:53:29 <Pamelloes> Thanks, that was what I was wondering :)
15:54:16 <jle`> :t second `asAppliedTo` unsafeCoerce
15:54:17 <lambdabot> (a -> b) -> (d, a) -> (d, b)
15:56:47 <benmachine> Pamelloes: I feel like one of scanl/scanr/mapAccumR might help you, but I can never quite remember how they work
15:59:14 <benmachine> Pamelloes: this is highly silly, but:
15:59:16 <benmachine> :t \f x n -> mapAccumR (\y () -> f y) x (replicate n ())
15:59:17 <lambdabot> (acc -> (acc, y)) -> acc -> Int -> (acc, [y])
15:59:42 <Xe> I have a cabal package that is stuck as hidden
15:59:58 <Pamelloes> Hm, maybe. I've currently got an ostensibly working implementation based on writer and iterateM.
16:03:08 <quchen> jophish: After looking some more at Vector.Storable I'm completely lost.
16:03:39 <jophish> quchen: I'd be interested to know what interesting things you've found
16:03:41 <quchen> I don't see the point of these things anymore. They don't have a Storable instance.
16:03:59 <dmwit> :t replicateM
16:03:59 <lambdabot> Monad m => Int -> m a -> m [a]
16:04:05 <quchen> So is the only way to use them by making a copy and then unsafe*-giving them to C?
16:04:09 <benmachine> Pamelloes: I think you want State and replicateM, actually
16:04:11 <dmwit> :t replicateM :: Int -> State a b -> State a [b]
16:04:11 <lambdabot> Int -> State a b -> State a [b]
16:04:20 * dmwit high fives benmachine 
16:04:23 <benmachine> :)
16:04:28 * benmachine high fives dmwit 
16:04:30 <glguy> Storable vectors can't have a Storable instance because they have variable size
16:04:59 <dmwit> ?unmtl Int -> State a b -> State a [b]
16:04:59 <lambdabot> Int -> State a b -> State a [b]
16:04:59 <jle`> h
16:05:01 <dmwit> lame
16:05:02 <jle`> oh
16:05:14 <dmwit> unmtl--
16:05:20 <quchen> glguy: Oh right, Storable has constant sizes for its instances, the "sizeof" argument is just a dummy
16:05:37 <jophish> there is a StorableM class for that though
16:05:38 <jle`> i guess that does work pretty well :)
16:05:43 <jophish> where sizeOf does use the argument
16:05:47 <jle`> that's an even better idea >_____________>
16:05:48 <quchen> hmm.
16:05:52 <Pamelloes> Huh, that works a lot better.
16:05:56 <jle`> haha
16:06:09 <Shockk> hello, I'm having an issue with a project I've been developing that requires transformers 0.3 to build due to a certain instance breaking with transformers 0.4
16:06:17 <jophish> quchen: I'm using Storable to take data from C, and associate it with a finalizer for that data
16:06:28 <Shockk> right now my solution is to not install transformers 0.4 on my system but this seems less than ideal
16:06:30 <jle`> replicateM n (state f)
16:06:49 <quchen> I've got a problem related to this actually, I want to have ForeignPtr-based arrays. Foreign.Marshal.Array.newArray gives me a standard "Ptr" array though.
16:06:50 <jle`> benmachine++
16:06:53 <jophish> I figured out how to do it, there's a nice function called touchPtr which touches a foreignPtr. I'm using that as the finalizer for the Vectors
16:06:54 <Shockk> I wondered if there's some way to build explicitly with transformers 0.3
16:06:59 <quchen> And I can't find one that works with ForeignPtr.
16:07:01 <benmachine> dmwit++
16:07:09 <quchen> I feel like I'm missing something.
16:07:25 * benmachine feels that that really ought to be 'modify succ dmwit'
16:07:27 <benmachine> owtte
16:07:33 <dmwit> =)
16:07:36 <jophish> quchen: you can always make a foreignPtr from a Ptr
16:07:38 <Hijiri> Shockk: specify transformers version in your .cabal file
16:07:45 <jophish> in Foreign.Concurrent
16:08:16 <quchen> jophish: Sure, but doesn't "newForeignPtr finalizerFree =<< newArray xs" only free the first element of newArray when GC happens?
16:08:29 <quchen> The foreign pointer doesn't know that an array was passed, after all. Or does it
16:08:30 <Hijiri> If your project doesn't already have a .cabal file you can make one with cabal init (and then manually change the deps with an editor)
16:08:37 <Shockk> Hijiri: ah right, thanks
16:08:44 <jophish> quchen: depends what you have in finalizerFree
16:08:54 <quchen> finalizerFree is a built-in
16:08:59 <hexagoxel> Xe: you probably need to add that package as a dependency
16:09:24 <jophish> quchen: I'd be surprised if it were to free only the first element
16:09:29 <jophish> if it's anything like malloc/free in C
16:10:11 <quchen> Well, I'm not sure, that's my problem
16:10:13 <quchen> The definition is
16:10:13 <quchen> foreign import ccall unsafe "stdlib.h &free" finalizerFree :: FinalizerPtr a
16:10:43 <quchen> I guess I just don't know much about "free" i NC
16:10:48 <quchen> in C*
16:10:57 <Pamelloes> can I fmap [] or do I have to fmap (:[])?
16:11:01 <jophish> quchen: free will deallocate a block created with malloc
16:11:13 <shachaf> Pamelloes: What happened when you tried it?
16:11:16 <jophish> what's the definition for newArray
16:11:32 <jophish> It must be just one call to malloc
16:11:38 <Pamelloes> shachaf: Lots of complicated errors and I can't tell if that's the issue or the issue is somewhere else...
16:11:40 <jophish> so you're safe using finalizerFree
16:12:00 <quchen> jophish: Uses mallocBytes
16:12:09 <shachaf> Pamelloes: What happened when you made a simple test case like "fmap [] (Just True)" and "fmap (:[]) (Just True)" and tried it? :-)
16:12:24 <jle`> am i missing something, or is there a reason why (->) is not a Bifunctor?
16:12:26 <Pamelloes> Hm... I should probably do that...
16:12:34 <shachaf> jle`: There is a reason.
16:12:44 <dmwit> jle`: It's contravariant in its first argument.
16:12:45 <jophish> quchen: perfect then
16:12:46 <quchen> jle`: It's a bifunctor, but not a Bifunctor :-)
16:12:46 <shachaf> If you write an instance for it you'll find out the reason.
16:12:53 <shachaf> Which is what dmwit said.
16:13:09 <jle`> oh, the type signatre for `first` is backwards
16:13:23 <jle`> i mean, the function it would take
16:13:26 <jle`> :t first
16:13:27 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
16:13:45 <jle`> er i won't bother
16:13:54 <dmwit> Your language is a bit wonky, but it's clear your head is in the right place.
16:14:00 <jle`> yeah, heh
16:14:14 <shachaf> dmwit: Yes, I agree about Haskell.
16:14:24 <dmwit> =)
16:14:31 <Lokathor> any yesod experts about?
16:14:38 <dmwit> ?where justask
16:14:39 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
16:15:35 <Lokathor> Using the yesod tutorial here: http://yannesposito.com/Scratch/en/blog/Yesod-tutorial-for-newbies/ I've setup the mirror example, but when i post the input, the page it directs to is localhost
16:15:59 <Lokathor> however, i'm viewing the page remotely, not via localhost
16:16:12 <Lokathor> so how do i get it to use the same URL i'm already connecting on?
16:16:39 <Lokathor> specifically, http://direct.cosban.net:3000/mirror is where my example is running
16:16:49 <cosban> wat
16:18:23 <Pamelloes> Alright, so now I have a function (a -> m a). Is there a way I can sequence this function n times?
16:18:39 <benzrf> :t (>=>)
16:18:40 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
16:18:46 <benzrf> :t foldr (>=>)
16:18:47 <lambdabot> Monad m => (b -> m c) -> [b -> m b] -> b -> m c
16:18:59 <benzrf> :t foldr (<=<) -- or this
16:19:00 <lambdabot> Monad m => (a -> m b) -> [b -> m b] -> a -> m b
16:19:37 <Lokathor> :t replicateM
16:19:38 <lambdabot> Monad m => Int -> m a -> m [a]
16:20:03 <Lokathor> little different than what you want i guess, depending on if you want the same arg to the func each time
16:21:54 <jle`> okay, anyone know if i'm missing any? -- http://blog.jle.im/entry/an-open-list-of-was-to-compose-functions
16:22:39 <jle`> oh yeah, liftM, liftA
16:23:47 <dmwit> :t \f -> iterate (f >=>)
16:23:48 <lambdabot> Monad m => (b -> m b) -> (b -> m c) -> [b -> m c]
16:23:54 <Zemyla> I think I figured out a point-free definition for if'.
16:24:02 <dmwit> :t \f -> iterate (f >=>) return
16:24:02 <lambdabot> Monad m => (c -> m c) -> [c -> m c]
16:24:28 <Zemyla> :t head . (++ [const id]) . (`replicate` const) . fromEnum
16:24:29 <lambdabot> Enum a => a -> a1 -> a1 -> a1
16:25:01 <Zemyla> :t head . (++ [const id]) . (`replicate` const) . (fromEnum :: Bool -> Int)
16:25:02 <lambdabot> Bool -> a -> a -> a
16:27:01 <shachaf> What's the point? GHC just derives the pattern-matching code for you.
16:27:09 <jophish> Is there a naming convention for bindings to C libraries
16:27:47 <jophish> If I were writing bindings for libcool, I've seen people use cool, hs-cool, cool-haskell
16:27:50 <glguy> shachaf: The obfuscation is a form of DRM
16:28:08 <SrPx> Is there anything similar to gloss, except for 3d polygons, curves, etc? (Nothing epic, just trying to visualize 3d stuff.)
16:28:16 <jophish> whats in vogue at the moment
16:28:57 <Zemyla> shachaf: There is no point. That's why I said it was point-free.
16:29:19 <shachaf> Zemyla: You have bested me.
16:29:22 <dmwit> SrPx: fieldtrip, maybe
16:29:27 <dmwit> fieldtrip-reactive
16:30:31 <SrPx> ty :]
16:32:07 <jle`> cute
16:41:20 <jle`> augur: you are psygnisfive? how come i never knew this
16:41:39 <augur> jle`: who knows :)
16:42:20 <augur> jle`: how'd you discover this?
16:42:57 <jle`> oh i read your post on your startup.  wishing you the best of fortune :)
16:46:40 <jmcarthur> there's a bit of knowledge i'm sure to forget by tomorrow anyway
16:46:58 <jmcarthur> too hard to keep track of a million names for half a million people
16:52:54 <augur> jle`: ahh cool. thanks :)
16:57:34 <mjrosenb> s/win 16
16:57:43 <dmwit> jle`: If you count type-restricted versions, mappend `on` Endo
16:57:59 <dmwit> :t (Endo .) . mappend `on` Endo
16:58:00 <lambdabot>     Couldn't match type ‚ÄòEndo a1‚Äô with ‚Äòa -> a‚Äô
16:58:00 <lambdabot>     Expected type: (a1 -> a1) -> a -> a
16:58:00 <lambdabot>       Actual type: (a1 -> a1) -> Endo a1
16:58:05 <dmwit> :t (Endo .) . (mappend `on` Endo)
16:58:06 <lambdabot>     Couldn't match type ‚ÄòEndo a1‚Äô with ‚Äòa -> a‚Äô
16:58:06 <lambdabot>     Expected type: (a1 -> a1) -> a -> a
16:58:06 <lambdabot>       Actual type: (a1 -> a1) -> Endo a1
16:58:15 <dmwit> oh, right
16:58:16 <dmwit> :t runEndo
16:58:17 <lambdabot> Not in scope: ‚ÄòrunEndo‚Äô
16:58:20 <dmwit> :t getEndo
16:58:21 <lambdabot> Not in scope: ‚ÄògetEndo‚Äô
16:58:26 <dmwit> :t (appEndo .) . (mappend `on` Endo)
16:58:27 <lambdabot> (a -> a) -> (a -> a) -> a -> a
16:58:46 <jle`> oh neat. i might add that as an extra category
16:58:50 <jle`> i always liked the nape appendo
16:58:53 <jle`> *name
16:58:55 <shachaf> If you count complicated expressions then there are infinitely many ways to write (.).
16:58:55 <jle`> "presto, appendo!"
16:59:08 <dmwit> yeah
16:59:18 <kranius> sounds spelly
16:59:26 <dmwit> But notionally it's just "mappend". All the rest is newtype nonsense.
16:59:27 <jle`> yeah that's a bit too complex.  "flip (>>>)" is as complex as i'm willing to go
16:59:38 <jle`> maybe you can safeCoerce it away
16:59:49 <dmwit> heh
17:00:37 <dmwit> unsafeCoerce @(Endo a) @(a -> a) mappend
17:00:53 <dmwit> err
17:00:58 <dmwit> Not quite. Anyway.
17:01:13 <Zemyla> :t Endo
17:01:14 <lambdabot> (a -> a) -> Endo a
17:01:15 <shachaf> (GHC.Exts.coerce :: Endo a -> a -> a) can do it too.
17:01:33 <shachaf> Did GHC grow explicit type application when I wasn't looking?
17:02:14 <dmwit> no
17:02:19 <shachaf> Shame.
17:02:20 <dmwit> Also, neat, I didn't know about coerce.
17:02:47 <dmwit> I mean, I knew the idea was out there, but I didn't know the implementation had been released.
17:03:07 <shachaf> Obviously the most natural implementation of (.) is s (s (k s) (s (k k) (s (k s) k))) (k i)
17:03:34 <dmwit> :t ap (ap (const ap) (ap (const const) (ap (const ap) const))) (const id)
17:03:35 <lambdabot> (a -> b) -> (b1 -> a) -> b1 -> b
17:03:41 <benzrf> good lord
17:03:44 <dmwit> yikes
17:03:48 <jle`> ha
17:03:54 <mjrosenb> shachaf: last time I checked, s isn't in prelude (with that name)
17:03:59 <jle`> that's really the only implementation i am comfortable with
17:04:05 <shachaf> It's called ap or (<*>)
17:04:17 <mjrosenb> shachaf: still not in prelude.
17:04:23 <benzrf> :t ala Endo mappend
17:04:24 <lambdabot>     Couldn't match type ‚ÄòEndo a‚Äô with ‚ÄòUnwrapped (Endo a) -> Endo a‚Äô
17:04:24 <lambdabot>     Expected type: (Unwrapped (Endo a) -> Endo a) -> Endo a -> Endo a
17:04:24 <lambdabot>       Actual type: Endo a -> Endo a -> Endo a
17:04:26 <dmwit> mjrosenb: Why restrict yourself to Prelude?
17:04:30 <benzrf> oh not what ala does
17:04:40 <benzrf> :t safeCoerce
17:04:41 <lambdabot>     Not in scope: ‚ÄòsafeCoerce‚Äô
17:04:41 <lambdabot>     Perhaps you meant ‚ÄòunsafeCoerce‚Äô (line 182)
17:04:45 <benzrf> ayy
17:04:52 <benzrf> :t unsafeCoerce
17:04:52 <mjrosenb> dmwit: because I want my implementation of (.) to not pull in 15 libraries?
17:04:53 <lambdabot> a -> b
17:05:06 <dmwit> mjrosenb: lame
17:05:07 <benzrf> > unsafeCoerce (Sum 3) :: Int
17:05:08 <lambdabot>  *Exception: what did you think was going to happen?
17:05:11 <jle`> mjrosenb: ap and (<*>) are both in base
17:05:12 <benzrf> huehuehue
17:05:26 <jle`> benzrf: i defie unsafeCoerce every once in a while to be able to have something nice for `asAppliedTo`
17:05:32 <jle`> :t first `asAppliedTo unsafeCoerce
17:05:33 <lambdabot> parse error on input ‚ÄòunsafeCoerce‚Äô
17:05:36 <jle`> :t first `asAppliedTo` unsafeCoerce
17:05:37 <lambdabot> (a -> b) -> (a, d) -> (b, d)
17:05:42 <benzrf> nice
17:05:55 <benzrf> > unsafeCoerce
17:05:56 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
17:05:57 <lambdabot>    arising from a use of ‚ÄòM528185221833446166024518.show_M5281852218334461660...
17:05:57 <lambdabot>  The type variable ‚Äòb0‚Äô is ambiguous
17:06:01 <benzrf> pfft
17:06:05 <dmwit> jle`: um
17:06:07 <benzrf> > unsafeCoerce :: Int -> String
17:06:08 <mjrosenb> jle`: but still, that requires importing an extra library?
17:06:08 <lambdabot>  <Int -> [Char]>
17:06:15 <benzrf> oh its an actual function
17:06:19 <benzrf> no wait no it isnt derp
17:06:32 <jle`> mjrosenb: nah, only a module :)
17:07:13 <shachaf> s and k are so natural, it's great
17:07:30 <jle`> anyways the game was to find as many definitons of (.) as possible in commonly used libraries, with only actual functions or simple modifications (like flip (>>>))
17:07:34 <jle`> i have 17 so far yay
17:07:37 <mjrosenb> jle`: err, I guess that I what I meant.
17:07:41 <shachaf> I used to think they were complicated but now I think they're the most obvious combinatory basis.
17:08:18 <mjrosenb> shachaf: after the card-game based ICFP  contest, I understood them like 900x better.
17:08:50 <shachaf> mjrosenb: I wasn't part of that.
17:12:09 <shachaf> But it's pretty straightforward: The body of a lambda (\x -> ...) either uses x or it doesn't. If it doesn't use x you replace it with (k ...). If it uses x, it must either be x -- replace it with (i) -- or it's an application (U V) -- which is the same as (s (\x -> u) (\x -> v)).
17:12:44 <shachaf> (Or it's a lambda, in which case convert the inside first.)
17:13:15 <jle`> it is all clear to me now
17:13:59 <shachaf> You just push lambdas further and further inside until they aren't necessary anymore.
17:16:38 <Javran> @hoogle Unfoldable
17:16:40 <lambdabot> package unfoldable
17:17:11 <mjrosenb> un-foldable, or unfold-able?
17:17:17 * mjrosenb grumbles at english.
17:17:24 * mjrosenb hopes the latter
17:17:29 <mjrosenb> but the former would be more amusing.
17:17:31 <Javran> mjrosenb: snd
17:18:40 <Javran> I got it wrong first time I saw it, and have no idea what it will do if it's un-foldable
17:19:37 <jle`> un-foldable would be interesting
17:19:54 <quazimodo> I have a monad related question. We use these things to compose functions in a way that makes them behave monoidally, is that a fair statement?
17:20:12 <quazimodo> because the functios that map from say a -> Ma arent strictly in a monoid, are they
17:20:34 <shachaf> Are you using the word "monoid" because of the whole "monoid in the category of endofunctors" business?
17:20:46 <dmwit> It is not a fair statement unless you give some more technical description of what "makes them behave monoidally" means.
17:20:47 <shachaf> Because that's not what people mean when they say that.
17:20:58 <Dodek> hmm, is there a function that converts Char -> Word8, assuming char is ASCII?
17:21:06 <dmwit> :t ord
17:21:07 <lambdabot> Char -> Int
17:21:24 <Javran> :t (<=<)
17:21:25 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
17:21:29 <dmwit> There is also Data.ByteString.Char8.pack
17:21:39 <dmwit> But... don't use either of them.
17:21:40 <Dodek> dmwit: and then fromIntegral?
17:21:48 <quazimodo> dmwit: yes you are right of course, functions that are a -> a can be in a monoid, the ones that map from a -> Ma aren't yes?
17:21:54 <dmwit> Sure, if Word8 is a hard requirement.
17:22:05 <dmwit> quazimodo: What does "in a monoid" mean?
17:22:12 <Dodek> dmwit: it's for Data.Attoparsec.ByteString
17:22:24 <shachaf> quazimodo: Functions :: (a -> M a) aren't the relevant thing when talking about monads anyway. You could talk about function :: (a -> M b).
17:22:24 <quazimodo> a monoid is a category that has certain rules, they are elements within a monoid?
17:22:33 <Javran> :t Control.Category.(.)
17:22:34 <lambdabot>     Not in scope: data constructor ‚ÄòControl.Category‚Äô
17:22:50 <dmwit> Dodek: ByteString's are for binary data.
17:22:53 <dmwit> Dodek: Not text.
17:23:01 <shachaf> quazimodo: Yes, for a monad M, and a type A, there's a monoid whose elements are functions :: (A -> M A).
17:23:08 <dmwit> Dodek: If you want text, use Text.
17:23:08 <shachaf> But that's not what a monad is.
17:23:15 <quazimodo> I'm going back to me references, bbl
17:23:30 <Dodek> dmwit: hm, okay.
17:23:43 <Javran> :t Kleisli
17:23:44 <lambdabot> (a -> m b) -> Kleisli m a b
17:23:53 <jle`> quazimodo: so (a -> a)'s form a monoid with (.) as the binary operator, and id as the identity.  they're a set with a closed associative binary operator and an identity element
17:24:15 <jle`> quazimodo: Monad m => (a -> m a)'s also for a monoid with (<=<) as the binary operator, and return as the identity
17:24:20 <jle`> *form
17:24:31 <quazimodo> jle`: yes i get that
17:24:50 <quazimodo> jle`: i didn't know about <=<, but yes it's some composition operator
17:25:10 <quazimodo> that makes sense, a -> m a functions dont form a monoid without that monad do they
17:25:25 <jle`> well, depending on what m is
17:25:42 <quazimodo> ok, so we have an uncertainty, here m is some function that operates on a, though, yes?
17:25:47 <jle`> it doesn't work for all (m :: * -> *) in general
17:25:48 <shachaf> The question is why you're bringing up monoids in the first place.
17:26:05 <shachaf> There's a relationship between monad and monoids, but the monoid you can make for functions :: (A -> M A) isn't it.
17:26:06 <quazimodo> shachaf: because it's very important
17:26:41 <dmwit> This whole discussion seems to be founded on shifting sand.
17:27:00 <dmwit> I wonder what quazimodo's real goals are here.
17:27:07 <shachaf> dmwit: That's why I'm asking!
17:27:07 <quazimodo> dmwit: well i only just learn't anything at all about monads this morning so yeah, i'm trying to understand them
17:27:19 <quazimodo> learnt, rather
17:27:46 <dmwit> quazimodo: I don't think your current line of questioning is a helpful one given that goal.
17:27:50 <dmwit> personally
17:27:57 <quazimodo> and they seem to be particularly important as a binary operator (with it's own meta rules) in order to keep a collection of functions composable in a form that makes them form a monoid
17:28:02 <jle`> if m is a monad then you get a monoid "for free" on (a -> m a).  but there are other m's for which (a -> m a) is a monoid but m is not a monad.  but yes, this line doesn't really help you "understand monads"
17:28:03 <dmwit> Though there are many fine resources available which we will be happy to point you at if you like.
17:28:30 <dmwit> The monad laws and the monoid laws look a lot alike. But they're not, quite, because of their types.
17:28:32 <jle`> if your goal is to understand monads then this is probably going to be a dead end :)
17:28:45 <quazimodo> jle`: really?
17:29:01 <quazimodo> as far as I understand it, we're using monads to keep our functions in a monoid?
17:29:06 <dmwit> Monad laws: (a >=> b) >=> c = a >=> (b >=> c) and a >=> return = return >=> a = a
17:29:13 <jle`> quazimodo: no, that's not why we use monads
17:29:21 <jle`> "in a monoid" doesn't really make sense either, heh
17:29:22 <dmwit> Monoid laws: (a <> b) <> c = a <> (b <> c) and a <> mempty = mempty <> a = a
17:29:23 <zq> :t (>=>)
17:29:23 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
17:29:27 <dmwit> So they look alike superficially.
17:29:30 <exio> dmwit: those sound like the laws of a category
17:29:31 <quazimodo> the brian bechman lecture seems to imply this
17:29:48 <dmwit> exio: And they damn well should!
17:31:13 <quazimodo> dmwit: the things you wrote there mean nothing to me, i'm not very good at haskell syntax
17:31:25 <jle`> it implies that we use monads to keep our functions in a monoid?
17:31:35 <Javran> speak of monoid, I start to wonder why not "type Endo a = a -> a", instead we have a wrapper and an unwrapper?
17:31:38 <jug1> do folds make sense on bounded structures? Like a circular buffer
17:31:41 <shachaf> quazimodo: If your goal is to understand Monad, I think you should read the FAQ, then. :-)
17:31:44 <shachaf> @where faq
17:31:44 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
17:32:02 <jle`> Javran: you can't define typeclass instances on type aliases, unfortunately
17:32:12 <shachaf> Ah, but the wiki is having issues.
17:32:21 <Javran> jle`: ah, I see
17:32:22 <quazimodo> jle`: no it implies that monoids are somehow central to the purpose of monads
17:32:28 <jle`> hm
17:32:47 <jle`> purpose in what sense? haskell, functional programming? or mathematics/abstract algebra/cat theo?
17:32:51 <shachaf> quazimodo: In particular https://www.haskell.org/haskellwiki/FAQ#What_should_I_know_before_trying_to_understand_monads.3F
17:33:01 <quazimodo> hrmmmmm
17:34:16 <jle`> monoids aren't really relevant to how or why we use monads in functional programming.  in category theory, the monoidal nature of monads is a big point of use, but this monoid isn't the one you are thinking about, and it isn't related to (a -> m a)'s.  and in any case, this application won't help you at all with haskell :P
17:34:24 <jle`> s/at all/not a single bit
17:35:29 <unknownloner> What would be a good way to add the elements of an arbitrary amount of lists together? So like result !! x = (list1 !! x) + (list2 !! x) .. (listn !! x)
17:35:44 <jle`> i wish to emphasize how uncorrelated this is to practical haskell or understanding the usage of monads in haskell to any useful degree
17:35:45 <unknownloner> (I have a list of lists as input)
17:36:04 <xnil> jle`: that sentence was more correct before you did the sed operation
17:36:08 <mzero> unknownloner:   map sum . transpose
17:36:12 <jle`> xnil: yes, i thought about that v.v
17:36:15 <Javran> > appEndo (foldMap Endo [(+ 1), (* 5)]) 2
17:36:16 <lambdabot>  11
17:36:17 <xnil> :P
17:36:18 <jle`> i saw that, heh.
17:36:19 <shachaf> I don't think overemphasizing it is useful either. There's no need to be on one extreme just because you don't like the other.
17:36:31 <Javran> looks like Endo compose functions in a reversed way?
17:36:43 <jle`> Javran: that looks like the normal way to me?
17:36:51 <jle`> > (+1) . (*5) $ 2
17:36:52 <lambdabot>  11
17:37:15 <Javran> yeah, but you usually read list elements from left to right
17:37:35 <shachaf> Thinking about the "monoid in the whatever" perspective isn't the most useful way to learn about Monad in Haskell. That's especially true when you're not familiar with Haskell syntax, like quazimodo. But that's not to say is isn't valuable.
17:37:36 <bananagram> unknownloner: maybe zipWith?
17:37:40 <Javran> if (<>) = (.), Endo works as expected
17:37:44 <unknownloner> thanks mzero
17:38:14 <bananagram> > zipWith (+) [1..5] [2,4..10]
17:38:15 <jle`> well if you imagine foldr as replacing all (:)'s with (f), then foldr (.) id [f,g,h] = f . g . h . id
17:38:16 <lambdabot>  [3,6,9,12,15]
17:39:01 <jle`> (<>) is (.) for Endo
17:39:14 <dmwit> > appEndo (Endo (+1) <> Endo (*5)) 2
17:39:14 <Javran> hmm, right
17:39:15 <lambdabot>  11
17:39:19 <jle`> so foldMap [f,g,h] = f <> g <> h <> id = f . g . h . id
17:39:25 <dmwit> > ((+1) . (*5)) 2
17:39:26 <lambdabot>  11
17:39:29 <dmwit> checks out!
17:39:31 <jle`> look at me being all fancy and not using parentheses
17:40:09 <jle`> shachaf: i'll take that into consideration :)  i tend to go on extremes a lot.
17:40:44 <dmwit> Well, you go to extremes sometimes.
17:40:47 <dmwit> *badum tsh*
17:40:53 <jle`> i go to extremes every single time :/
17:41:02 <quazimodo> simply put, my current understanding of monads is that they are constructs used to keep a group of functions in the form of a monoid, ie they obey the rules of a monoid when we use a binary operator like bind to compose them, when without that monad they were not composable in the form of a monoid
17:41:23 <shachaf> Where are you getting all this understanding?
17:41:31 <quazimodo> shachaf: brian bechman lecture
17:41:37 <quazimodo> https://www.youtube.com/watch?v=ZhuHCtR3xq8
17:41:38 <dmwit> I worry that you say "monoid" when you mean "binary operator".
17:41:50 <dmwit> Or... something.
17:42:02 <xnil_> can somebody just put up a simple explanation of monoids and monads and how they're used in haskell
17:42:03 <shachaf> quazimodo: Did you read the FAQ entry I linked to?
17:42:07 <xnil_> and make it /simple/
17:42:13 <quazimodo> dmwit: a monoid is a collection of things that obey a set of rules, we can have a collection of functions that obey those rules
17:42:26 <quazimodo> shachaf: yes
17:42:41 <dmwit> quazimodo: That is not correct.
17:43:03 <quazimodo> dmwit: sure seems correct to me
17:43:19 <dmwit> quazimodo: In particular, in a monoid, all pairs of monoid elements can be composed. In monads, not.
17:43:34 <dmwit> Some compositions of monad functions are ill-typed.
17:43:45 <jle`> xnil_: the original paper on monads is very effective at this
17:44:08 <jle`> xnil_: "You could have invented monads!"
17:44:34 <shachaf> quazimodo: You're probably better off listening to dmwit when he says something you're asking questions about isn't correct.
17:44:50 <jle`> xnil_: as for monoids there's that functional pearls paper
17:45:20 * hackagebot Deadpan-DDP 0.9.3.0 - Write clients for Meteor's DDP Protocol  http://hackage.haskell.org/package/Deadpan-DDP-0.9.3.0 (LyndonMaydwell)
17:46:30 <exio> quazimodo: "collection of things that follow some axioms" is pretty much a big part of abstract algebra
17:48:42 <quazimodo> exio: yeah I need to be more precise in my usage of language in mathematics
17:49:04 <Javran> is there a problem if "f" is expensive in "sortBy (compare `on` f)"? I mean does (compare `on` f) do memoization?
17:49:25 <shachaf> Javran: It does not.
17:49:33 <benzrf> @src sortBy
17:49:33 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
17:49:41 <benzrf> @src insertBy
17:49:41 <lambdabot> insertBy _   x [] = [x]
17:49:41 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
17:49:41 <lambdabot>                                  GT -> y : insertBy cmp x ys'
17:49:41 <lambdabot>                                  _  -> x : ys
17:50:02 <jle`> haskell doesn't do any implicit memoization of functions
17:50:07 <dmwit> It would be nice if there were *On versions of all the functions that have *By functions.
17:50:09 <Javran> then I guess I should keep "(x,f x)" pairs before sorting
17:50:16 <Javran> jle`: I see
17:50:17 <benzrf> dmwit: overkill
17:50:26 <dmwit> benzrf: Why?
17:50:40 <benzrf> dmwit: comparing is not so long to type, and it would cause clutter
17:50:44 <jle`> you know, i am not sure why, but i feel like everyone seems to come in with this idea that (at least some) haskell functions are implicitly memoized
17:50:53 <jle`> i thought i was the only one, at first
17:50:55 <benzrf> jle`: it seems like an obvious optimization
17:50:58 <dmwit> benzrf: But the *On versions would have different operational semantics.
17:51:05 <benzrf> dmwit: bah
17:51:15 <jle`> i guess it's more "obvious" in haskell because of purity?
17:51:16 <benzrf> :t comparing -- btw, Javran
17:51:17 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
17:51:19 <benzrf> jle`: yeah
17:51:22 <dmwit> benzrf: Specifically, decorate-undecorate semantics, which can be more efficient than the "comparing" versions.
17:51:23 <jle`> and "referential transparency"?
17:51:28 <jle`> i see
17:51:30 <Javran> :t comparing
17:51:31 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
17:51:43 <Javran> :t on
17:51:44 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
17:52:04 <dmwit> :t let sortOn f xs = map snd . sortBy (comparing fst) . map (\x -> (f x, x)) in sortOn
17:52:05 <lambdabot> Ord a => (b -> a) -> t -> [b] -> [b]
17:52:07 <dmwit> benzrf: Like this.
17:52:10 <benzrf> :t (comparing, (compare `on`)) -- Javran
17:52:11 <lambdabot> (Ord b1, Ord a) => ((b -> a) -> b -> b -> Ordering, (a1 -> b1) -> a1 -> a1 -> Ordering)
17:52:20 <dmwit> :t let sortOn f = map snd . sortBy (comparing fst) . map (\x -> (f x, x)) in sortOn -- derp
17:52:20 <jle`> i don't really see it as *too* obvious...how does it just pop into people's heads?
17:52:21 <lambdabot> Ord a => (b -> a) -> [b] -> [b]
17:52:54 <jle`> universal subconscious?
17:53:07 <benzrf> collective unconscious
17:53:07 <Javran> I know "comparing" before, just that "on" gives me a feeling of using contravariant functors xD
17:53:40 <benzrf> whaa
17:53:41 <jle`> ah that's the term
17:54:36 <Javran> @src comparing
17:54:36 <lambdabot> Source not found. There are some things that I just don't know.
17:54:49 <dmwit> comparing = on compare
17:55:18 <Javran> dmwit: I see
17:56:30 <benzrf> Javran: well that may not be how it is actually defined
17:56:55 <Javran> benzrf: http://hackage.haskell.org/package/base-4.7.0.2/docs/src/Data-Ord.html#comparing
17:57:09 <Javran> yeah they doesn't use "on"
17:57:26 <dmwit> They use on. They just inlined it prematurely.
17:57:40 <Javran> dmwit: you're right xD
18:01:18 <Javran> @djinn (a -> b) -> a -> (a,b)
18:01:19 <lambdabot> f a b = (b, a b)
18:01:33 <Javran> @pl f a b = (b, a b)
18:01:33 <lambdabot> f = ap (,)
18:01:39 <dmwit> :t \f -> id &&& f
18:01:40 <lambdabot> (a -> c') -> a -> (a, c')
18:01:55 <dmwit> :t (id&&&) -- if you prefer point-free for some reason
18:01:56 <lambdabot> (a -> c') -> a -> (a, c')
18:02:25 <dmwit> ap (,) is unbearably cute
18:03:02 <Javran> reader applicative
18:03:12 <jle`> (id&&&) is probably close to one of the more aesthetically disagreeable things i've seen
18:04:18 <Javran> I'll just write "keepInput f x = (x, f x)" for sake of readability
18:04:18 <Javran> just curious what would other versions look like
18:04:41 <jle`> i usually prefer `liftA2 f id` over the `ap f` counterpart
18:04:55 <jle`> if we had idiom brackets then we might have an even cleaner way :)
18:05:38 <dmwit> Javran++ for sanity
18:05:49 <Javran> I didn't know idiom brackets before
18:06:04 <Javran> btw haskell.org seems slow these days
18:06:53 <benzrf> @. pl djinn (a -> b) -> a -> (a,b)
18:06:53 <lambdabot> f = ap (,)
18:07:00 <benzrf> :-)
18:07:13 <benzrf> @. type djinn (a -> b) -> a -> (a,b)
18:07:23 <benzrf> er hm
18:07:32 <Javran> what? lambdabot commands are composable?
18:07:48 <geekosaur> yep
18:07:55 <geekosaur> with some limitations
18:08:19 <dmwit> \bot command :: String -> String
18:08:35 <Javran> fun to know that
18:13:13 <benzrf> @. type pl djinn a -> a
18:13:20 <benzrf> durn
18:13:29 <benzrf> @fu
18:14:23 <geekosaur> b0rked it, you did
18:15:56 <benzrf> @gtfo
18:16:11 <benzrf> :k "Please Respond"
18:16:22 <benzrf> mfw i broke lambada but
18:16:55 <dmwit> "lambada but"
18:17:01 <jle`> :t "lambda but"
18:17:01 <Javran> LOL
18:17:51 <horny-sama> net split = nsa attack
18:22:00 <halvorg> JSON or YAML or <something else> for json configs?
18:22:05 <halvorg> for haskell configs**
18:22:10 <halvorg> what has the best library support?
18:25:11 <zomg> halvorg: I've just used Show and Read for that when feeling lazy =)
18:25:25 <halvorg> : )
18:25:37 <jle`> blasphemy :|
18:25:42 <zomg> Beyond that, probably up to personal preference
18:25:44 <halvorg> ConfigFile looks promising
18:30:11 <haasn> Haskell syntax for Haskell configs!
18:30:14 <haasn> dyre
18:31:31 <geekosaur> but not the way xmobar does it. please.
18:31:36 <Lokathor_> i have had more problems with cabal hell than i have ever had with the haskell language itself
18:34:36 <haasn> yes, xmobar is a good counter-example
18:35:44 <zomg> Lokathor: yep :P
18:36:04 <zomg> literally the only thing I find nicer in nodejs
18:36:22 <zomg> the package management just works so easily there
18:36:47 <Lokathor> in java, maven is also a "just works" situation
18:36:57 <Lokathor> it gets you your .jar files, off you go
18:37:40 <zomg> too bad setting up maven is like stepping on legos
18:38:05 <Lokathor> i just use the eclipse plugin for it
18:38:06 <zomg> or at least that was my experience with it the last time I tried it, which admittedly was a while ago
18:39:33 <Lokathor> i mostly use it for quickcheck, which is about as handy in java as it is in haskell
18:41:03 <trap_exit> so I just started using ipython ... and it's amazing
18:41:07 <trap_exit> why do we not have ihaskell ?
18:41:21 <Lokathor> is that the interactave web page thing?
18:42:05 <dmwit> trap_exit: Sounds like you just volunteered to write it!
18:42:47 <Hijiri> why do we not have a comprehensive mahjong library
18:43:40 <trap_exit> dmwit: congrats on your PhD
18:43:44 <Lokathor> because we don't yet know how to make haskell always achieve +/- 0
18:43:47 <trap_exit> dmwit: you hav elots of free time now ... right? :-)
18:43:59 <zomg> wonder if you can compile GHCJS to JS and then compile Haskell in the browser with JS?
18:44:02 <zomg> :p
18:44:12 <dmwit> trap_exit: Thanks, and yeah! Pile on the feature requests
18:44:31 <Lokathor> there's tryhaskell.org
18:44:49 <trap_exit> dmwit: ghci + edcent editor + numeric computing ... would be good enough for me, I'm not too greedy
18:44:58 <trap_exit> Lokathor: have you tried iPython?
18:45:01 <trap_exit> it's magical
18:45:47 <glguy> We do have iHaskell
18:45:58 <Lokathor> >> We ship the official IPython kernel, but kernels for other languages such as Julia and Haskell are actively developed and used.
18:46:03 <darkroom> if i have a data type like data Tree a = Leaf a | Bin (Tree a) (Tree a) how can i make sure that a has a type constraint of show or num
18:46:03 <Lokathor> from the webpage
18:46:18 <dmwit> trap_exit: Someday when I'm independently wealthy I'm going to design my awesome elastic tabstops+proportional fonts text editor.
18:46:29 <glguy> Darkroom: generally you don't
18:46:42 <dmwit> darkroom: Put the constraint on the functions that use it.
18:47:01 <dmwit> My client can't handle all these joins and quits. =(
18:47:18 <Lokathor> why does yesod ignore my settings.yml
18:47:31 <Lokathor> and always use port 3000 instead of 8008 like i tell it to
18:48:03 <darkroom> dmwit: why couldnt you make a global constraint?
18:48:19 <EvanR> client should have a feature, ignore any joins or quits unless the person satisfies a heuristic criteria like you were just talking to them
18:50:19 <dmwit> darkroom: You can, but it doesn't do what you want it to do with the current implementation.
18:50:24 <dolio> Weechat has a mode that hides joins/parts unless the person spoke recently.
18:50:56 <EvanR> need that mode right now
18:50:58 <EvanR> well that counted as a netsplit right there
18:53:51 <EvanR> irssi has this plugin called crapbuster.pl apparently, /set crapbuster_levels CRAP
18:53:59 <EvanR> literally
18:55:10 <mseeks> has anyone read http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html ?
18:55:44 <EvanR> you could have invented foo, why foo matters
18:55:53 <EvanR> foo considered harmful
18:56:06 <bitemyapp> foo ate my dog and ran over my homework.
18:56:43 <shachaf> mseeks: I'm sure people have read it.
19:02:36 * hackagebot wai-middleware-hmac-client 0.1.0.0 - Wai HMAC Authentication Middleware Client  http://hackage.haskell.org/package/wai-middleware-hmac-client-0.1.0.0 (ChristopherReichert)
19:02:36 * hackagebot xss-sanitize 0.3.5.5 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.3.5.5 (GregWeber)
19:06:16 <Shockk_> hello, I'm having a problem with the cabal file for my project; I've added a dependency on mtl >= 2.2 && < 2.3 but when I attempt to build, I'm getting this error:
19:06:24 <Shockk_> cabal: At least the following dependencies are missing:
19:06:25 <Shockk_> mtl ==2.2.*
19:07:04 <glguy> You'll need to install mtl. A quick way to do that from your project is: cabal install --only-dependencies
19:07:08 <glguy> or just: cabal install mtl
19:07:11 <Shockk_> I realize what the error means, but I'm unsure why the dependency isn't automatically being retrieved
19:07:31 <Shockk_> ah, let me try --only-dependencies
19:08:09 <kranius> you may want to 'cabal sandbox init
19:09:18 <glguy> Before you start turning on sandboxes you should read about them so you know what they do and how to use them
19:17:05 <Shockk_> kranius: glguy: thanks, I think my thing is building properly now
19:28:56 <ezrios> I have a State action
19:29:02 <ezrios> how can I convert this into a StateT action?
19:29:30 <EvanR> you can simply nest the runState and the runStateT
19:30:57 <ezrios> EvanR: I don't understand
19:33:21 <EvanR> you can write a function that converts a State into a StateT
19:33:26 <EvanR> which isnt big
19:33:33 <enthropy> f :: Monad m => State s a -> StateT s m a -- right?
19:33:46 <EvanR> yeah you got the type
19:33:48 <enthropy>  \action -> StateT $ \s -> return (runState action s)
19:33:55 <enthropy> (spoiler)
19:33:57 <EvanR> that wont totally work
19:34:06 <ihatehex> are you guys dead?
19:34:20 <exio> pretty much
19:34:33 <EvanR> enthropy: im guessing you also want the State to modify the corresponding state in the StateT
19:34:52 <EvanR> make your function do that
19:34:52 <enthropy> that doesn't do such a thing?
19:34:58 <EvanR> nah
19:35:18 <EvanR> your think makes a "pure" StateT action
19:35:24 <EvanR> thing*
19:36:18 <EvanR> you got the type signature right tho
19:38:01 <pavonia> EvanR: What do you mean by pure here?
19:38:13 <EvanR> its the result of using return
19:38:58 <jle`> er
19:39:05 <pavonia> What else could it be?
19:39:12 <EvanR> the result of using put
19:39:14 <jle`> enthropy's solution does modify the state
19:39:17 <joness> unsafeCoerce function :: Int   <- does this give a function pointer value? can you rely on it being the same during the runtime of the program?
19:39:28 <enthropy> EvanR: you're saying http://lpaste.net/119164 n stays at 0?
19:39:31 <EvanR> ah
19:39:41 <jle`> it's return of the trasnformed monad
19:39:43 <EvanR> i got confused by the explicit StateT
19:39:44 <jle`> not of state
19:40:50 <jle`> `StateT $ \s -> return (f s)` is `state f`, btw
19:41:10 <EvanR> State within a state within a...
19:41:29 <glguy> Joness: no it doesn't guarantee that. You should plan on things crashing most of the time using unsafeCoerce
19:41:37 <jle`> for `Monad m => StateT s m a`, the `return` there is for the `m`
19:42:04 <EvanR> i dont get that... yet
19:42:14 <jle`> :t StateT
19:42:26 <joness> glguy it did not crash a single time the few dozen times i ran it
19:42:40 <jle`> StateT :: (s -> m (a, s)) -> StateT s m a
19:43:04 <EvanR> s -> m (a, s) ok
19:43:18 <jle`> so `\s -> return (f s)`
19:43:21 <jle`> the return there is for the `m`
19:43:29 <jle`> if `f s :: (a, s)`
19:44:13 <jle`> which runState returns after being given a `State s a` and an `s`
19:44:16 <EvanR> ok but, if you used the wrapped action in a StateT context youd get a (a,s) rather than a a
19:44:25 <EvanR> oh, runStateT
19:45:00 <jle`> runState takes a `State s a` and an `s` and returns `(a, s)`, which is the output and the modified state
19:45:16 <EvanR> yeah i got the runState
19:45:44 <joeyh> I typoed foo :: (stuff) => Foo => Bar => Baz and was suprised that ghc compiled it without complaint as if it were foo :: (stuff) => Foo -> Bar -> Baz. (older ghc fell over "Type of kind * used as a constraint")
19:45:46 <jle`> so (\s -> return (runState foo s)), you'll run foo with the initial state `s` to get (a, s), the result and the modified state
19:46:07 <jle`> joeyh: i wish that was the established conventiom sometimes, it's a lot more smooth to write for me :)
19:46:25 <jle`> EvanR: and your (\s -> ...) function shouldn't really "do anything" with the underlying Monad at all
19:46:33 <joeyh> yeah, it's easy to get them mixed up.
19:46:50 <EvanR> yeah that makes sense
19:46:57 <jle`> you just need an `m (a, s)`, which is a, the result, and s, the modified state, in the context of m
19:47:05 <jle`> so you can use `return` for that
19:48:13 <EvanR> i was thinking of this code \act -> do { s <- get; let (x,s') = runState s act; put s'; return x }
19:49:14 <shachaf> joeyh: That syntax has worked for quite a while.
19:50:36 <shachaf> joeyh: Even without extensions, I remember, because it's not in the Report.
19:50:58 <jle`> my personal favorite is
19:51:03 <jle`> `StateT . runState`
19:51:13 <jle`> but also `hoist generalize` from mmoprhs works too
19:51:33 * shachaf tries to figure out what tthis StateT thing is about.
19:51:55 <EvanR> haskell priate says "ahoist!"
19:52:44 <joeyh> shachaf: since ghc 7.6 it seems
19:52:54 <shachaf> joeyh: Oh, that's possible.
19:53:33 <shachaf> joeyh: But ... -> (... => ...) -> ... is valid in GHC.
19:53:33 <jle`> shachaf: it was a question about a `State s a -> StateT s m a`
19:54:11 <jle`> oh sorry, that was supposed to be `state . runState`
19:54:20 <EvanR> is it idiomatic to use that raw implementation of StateT
19:54:33 <EvanR> i thought there were several versions
19:54:40 <shachaf> There's always state . runState
19:54:43 <jle`> which one do you mean?
19:54:45 <shachaf> Yes.
19:55:05 <EvanR> StateT :: (s -> m (a, s)) -> StateT s m a
19:55:05 <enthropy> :t mapStateT (return . runIdentity)
19:55:22 <enthropy> that's another option (mtl-1 excluded)
19:58:48 <jle`> i feel like (return . runIdentity) is used enough to be able to justify it going into Data.Functor.Identity.  or maybe not
20:01:43 <dmwit> joness: You want a StablePtr
20:01:44 <nshepperd_> isn't that "generalize :: Monad m => Identity a -> m a" from mmorph
20:02:38 <dmwit> joness: Which has in particular an instance Eq (StablePtr a) with no constraint on a.
20:02:55 <dmwit> err, sorry
20:03:07 <dmwit> joness: You want StableName.
20:04:13 <dmwit> https://hackage.haskell.org/package/base-4.7.0.2/docs/System-Mem-StableName.html
20:07:02 <dmwit> jle`, EvanR: Normally the solution is to just make your `State s a` thing more polymorphic in the first place, so that it also has type `StateT s m a`.
20:07:18 <dmwit> Without any state/runState nonsense to change its type.
20:08:29 <dmwit> ezrios: You, too, I guess.
20:10:45 <enthropy> anybody know an official "class Defunctionalize fToken f where apply :: fToken -> f"?
20:11:37 <enthropy> in HList we have one that has applyAB :: fToken -> a -> b, but I'm thinking there's no benefit in having 3 parameters instead of 2 parameters
20:31:49 <monochrom> @type return . runIdentity
20:32:02 <monochrom> eh, lambdabot is awy
20:32:23 <dmwit> Monad m => Identity a -> m a
20:32:29 <gcganley> lambdabot is dead?
20:32:29 <monochrom> :)
20:32:40 <dmwit> Who's in charge of \bot these days?
20:32:44 <monochrom> int-e
20:32:51 <dmwit> int-e: ping
20:34:24 <horny-sama> https://github.com/mr-fool/haskell/blob/master/calculator/calculator.hs <---need some help
20:34:40 <horny-sama> I want to map the char to + operation
20:34:53 <horny-sama> if the input is a then map it to the + operation for adding
20:35:24 <dmwit> case operation of "a" -> (+); "s" -> (-); "m" -> (*)
20:35:49 <Shockk> I have some code that uses the GHC API to dynamically compile/load a module but I'm having an issue in that I'm using a cabal sandbox for the dependencies required for my project, and I require those dependencies for the modules to be dynamically loaded as well;
20:35:58 <horny-sama> dmwit: cool
20:35:59 <dmwit> > let operation = "a" in (case operation of "a" -> (+); "s" -> (-); "m" -> (*)) 7 10
20:36:32 <dmwit> Hard to remember that \bot isn't around. =P
20:36:37 <Shockk> I figured out that I can set the path to the package db, but my issue is that the cabal sandbox package db is named like:
20:36:47 <Shockk> x86_64-linux-ghc-7.6.3-packages.conf.d
20:36:52 <horny-sama> dmwit: fpaste or gist please?
20:37:54 <Shockk> I'm unsure if there's a way to get that path using something in the GHC API or whatever, or if I have to get it some other way like the equivalent of getting *-packages.conf.d
20:38:12 <dmwit> horny-sama: I posted a complete code snippet here (prefaced by ">"). Try it in ghci.
20:38:53 <dmwit> Shockk: cabal exec will set up the right environment variables for you
20:39:22 <horny-sama> dmwit: how does it actually work?
20:39:56 <horny-sama> the in notation is throwing me off
20:40:45 <Shockk> dmwit: ah I see
20:40:49 <horny-sama> 's up with the semi colon :<
20:40:49 <dmwit> "let var = val in expr" binds the value "val" to variable "var" in the expression that follows.
20:40:56 <horny-sama> https://github.com/mr-fool/haskell/blob/master/calculator/calculator.hs <---still same error
20:41:04 <Shockk> hmm, I'm getting an ExitFailure 127 from that, and no output
20:41:12 <Shockk> (I used --verbose=3)
20:41:57 <dmwit> horny-sama: You don't need to bind a new operation. You already have one. I just bound one as an example to avoid having to use getLine.
20:42:17 <horny-sama> dmwit: ?
20:42:22 <dmwit> horny-sama: Also, you don't have anything named "operator" in scope, so I'm not sure what you're hoping it's going to do a case split on.
20:42:23 <Shockk> ooh wait, there we go
20:42:35 <horny-sama> oooo
20:42:38 <Shockk> I was doing cabal exec name rather than cabal exec ./name
20:42:57 <glguy> Horny: the case expression isn't part of do notation, so you can't use let inside like that
20:43:08 <dmwit> Shockk: If your package builds an executable, that executable should appear in the PATH that cabal exec sets up.
20:43:53 <glguy> If you want you can use let outside of the case to name the value the case evaluates to
20:44:01 <Shockk> I'm using cabal build but not cabal install as I've got custom behaviour set up
20:44:18 <horny-sama> dmwit: https://github.com/mr-fool/haskell/blob/master/calculator/calculator.hs
20:44:19 <horny-sama> :<
20:44:37 <wyager> Anyone have an intuitive explanation for why `d/da (t a) + a` yields the zipper for `t a`?
20:45:42 <wyager> Sorry, that should be `d/da (t a) * a`
20:46:36 <wyager> Or, alternatively, why is the derivative of a type its one-whole context?
20:46:45 <dmwit> horny-sama: You've got other problems, but... pull-request sent.
20:46:52 <wyager> s/whole/hole
20:46:54 <dmwit> horny-sama: I trust you can address some of the other problems yourself.
20:47:23 <horny-sama> dmwit: one sec
20:47:43 <horny-sama> gonna confirm the pull request
20:47:56 <lpaste> orzo pasted ‚ÄúSingletons-based toggle on type‚Äù at http://lpaste.net/119165
20:48:26 <orzo> I pasted a question, i'm wondering if there's a better way to do that
20:48:48 <horny-sama> dmwit: thx
20:48:57 <orzo> using singleton's boolean type equality to create a polymorphic function
20:49:10 <orzo> i resorted to unsafeCoerce
20:50:07 <horny-sama> dmwit: "a" -> (+) Compilation failed.
20:50:15 <horny-sama> calculator.hs:12:13: parse error on input ‚Äò->‚Äô
20:51:30 <dmwit> Oy, I didn't adhere to my own rules.
20:51:41 <dmwit> Indent the "a"/"s"/"m" lines one more level.
20:51:51 <horny-sama> ok
20:52:48 <horny-sama> dmwit: how come you need to indent one more level
20:53:12 <dmwit> Because let is a block herald.
20:53:20 <dmwit> So "operator = " starts a block.
20:53:33 <dmwit> And they align with the beginning of that block, so are treated as if they're in that block.
20:54:41 <orzo> jstolarek, goldfire1: Can I interest you in my singletons question? http://lpaste.net/119165
20:59:30 <horny-sama> dmwit: https://github.com/mr-fool/haskell/blob/master/calculator/calculator.hs <---one more question how come the let statement with read is blowing up in my face
21:00:48 <pacak> horny-sama:                                     let answer =  newNum1 `operator` newNum2
21:01:10 <horny-sama> pacak: I need to solve the let newNum1 = read num1 first
21:01:46 <horny-sama> pacak: if I don't fix those two lines first of coz it will be error with the answer line
21:02:12 <pacak> horny-sama: Try first.
21:02:48 <horny-sama> pacak: are you right
21:02:55 <horny-sama> but how does the operator `` means?
21:03:10 <pacak> horny-sama: infix notation
21:03:21 <horny-sama> ok
21:03:55 <pacak> horny-sama: If you see errors you can't understand - add type signatures everywhere.
21:04:08 <horny-sama> pacak: ?
21:04:24 <horny-sama> like typeOf a?
21:04:39 <pacak> let newNum1 = read num1 :: Int
21:05:59 <Pamelloes> Is (->) an instance of Eq?
21:06:17 <shachaf> Pamelloes: "What happened when you tried it?"
21:06:37 <horny-sama> i guess is mcdonald icecream time for me
21:06:38 <horny-sama> :P
21:06:40 <jle`> there's also :i in ghci
21:07:22 <Pamelloes> shachaf: Sorry :( jle` : Thanks :)
21:07:30 <horny-sama> geany is a shitty ide for haskell :<
21:07:59 <horny-sama> maybe leafpad is better for haskell
21:08:16 <Pamelloes> horny-sama: Sometimes no IDE is the best option ;)
21:08:23 <athan> horny-sama: (psst- check out atom & haskell-ide package ;])
21:08:31 <horny-sama> leafpad is not an ide
21:09:00 <shachaf> Pamelloes: It just seems odd to me because it sounds like less work to ask ghci than to ask this channel.
21:09:30 <horny-sama> athan: DE is the best option ;)
21:09:31 <horny-sama> <athan> horny-sama: (psst- check o
21:09:34 <pacak> le vim
21:09:36 <horny-sama> no matches found
21:09:54 <horny-sama> vim is my nemesis
21:10:00 <horny-sama> it is on the same level as gdb
21:11:11 <pacak> horny-sama: http://www.funniestmemes.com/wp-content/uploads/2014/06/Funniest_Memes_i-must-not-fear-fear-is-the-mind-killer_12546.jpeg
21:12:01 <Pamelloes> shachaf: Yeah... :/
21:12:41 <horny-sama> my learning haskell plan is to read then program then more reading
21:13:18 <Pamelloes> What do you do fi someone is PM'ing you ads?
21:13:36 <Pamelloes> Is there a freenode op channel?
21:14:28 <glguy> tell #haskell-ops
21:14:32 <joelteon> how do I make cabal keep temp files, like the "haddock prologue"?
21:14:41 <horny-sama> Pamelloes: you gox them like mt gox
21:15:03 <Pamelloes> o.o
21:15:23 <Pamelloes> glguy: Really? There isn't a network wide place?
21:15:31 <horny-sama> Pamelloes: torture them with gdb debugging
21:15:38 <glguy> You can try #freenode if you want network support
21:15:39 <horny-sama> or force them to use gdb as a reverse engineer tool
21:15:40 <horny-sama> :P
21:15:51 <Pamelloes> horny-sama: It's a bot.
21:16:09 <horny-sama> lol
21:16:25 <horny-sama> devil may cry if they use gdb
21:17:18 <mjrosenb> right, so has anyone build the SDL that is currently on hackage?
21:21:57 <tommd> mjrosenb: I have 0.6.5 installed, it appears.
21:22:25 <tommd> (GHC 7.8)
21:22:43 <mjrosenb> tommd: 7.8.4?
21:22:54 <tommd> 7.8.3
21:23:36 <glguy> tommd: 2014 called, it wants its compiler back
21:24:09 <MP2E> `lol
21:24:55 <mjrosenb> glguy: that being said, SDL-0.6.5 doesn't compile with ghc 7.8.4
21:26:42 <Pamelloes> Is there a way to get a type signature for a type's instances? e.g. (,)'s fmap?
21:27:25 <glguy> mjrosenb: The Typeable(typeOf) error?
21:27:57 <mjrosenb> glguy: da.
21:28:17 <MP2E> hm i get that as well
21:28:21 <glguy> mjrosenb: That's not new to 7.8.4, just edit that file, 56,  import Data.Typeable (Typeable,typeOf,TypeRep)
21:28:47 <enthropy> Pamelloes: substitute f = (,) x by hand?
21:28:58 <mjrosenb> glguy: uh, how do I do that with cabal install?
21:29:05 <glguy> mjrosenb: cabal get SDL
21:29:11 <enthropy> (I don't know of any plugin / tool that'll automate such a thing)
21:29:23 <glguy> that will unpack the package into SDL-0.6.5, go in there and edit the source
21:29:25 <glguy> and then type cabal install
21:30:05 <enthropy> :t \f x -> fmap f (x `asTypeOf` (undefined,undefined))
21:30:51 <Pamelloes> enthropy: Your first comment actually helped a lot. I realize now that fmap obviously applies to the second element in (,) since a functor is of type (*->*)
21:30:55 <Pamelloes> *of kind
21:31:13 <jle`> :t fmap
21:31:28 <jle`> fmap :: Functor f => (a -> b) -> f a -> f b
21:31:33 <jle`> so yeah just substitution is probably the best way
21:31:37 <int-e> > 1
21:31:44 <enthropy> well I guess it could apply to the first element if "(,) x y" was another way to write "(y,x)"
21:31:48 <lambdabot>  1
21:32:05 <enthropy> (in a crazy backwards hypothetical world)
21:32:21 <jle`> hooray int-e
21:32:25 <jle`> saving the day
21:32:46 <mjrosenb> glguy: ahh, many thanks!
21:33:10 <int-e> I'm not sure how that happened. Oh well.
21:33:36 <jle`> i think there was a netsplit earlier today? but i don't think that would do it
21:34:42 <int-e> jle`: there was a netsplit, it detected being disconnected but failed to terminate (and get restarted). I've not seen this before (and I don't really expect to figure this out, I killed the process rather than investigate further.)
21:52:31 <dmwit> Pamelloes: Yes! See the universe-reverse-instances package.
21:52:45 <Pamelloes> wut
21:52:51 <Pamelloes> is that a thing?
21:53:09 <dmwit> Eq, Ord, Read, Show, Traversable instances for (->)
21:53:13 <dmwit> It's a thing.
21:53:28 <Pamelloes> Oh, we're talking about different things
21:53:49 <Pamelloes> I was confused by the package name. That's actually good to hear!
21:54:50 <Pamelloes> On an unrelated note: what should I use for a RandomGen instance? Is StdGen good enough?
21:55:04 <haasn> Depends on what ‚Äúgood enough‚Äù means.
21:55:18 <dmwit> I think people generally recommend the mersenne twister implementation that's on Hackage for casual use.
21:55:29 <haasn> There are two broad criteria of RNGs, speed and cryptographic security. StdGen has neither, afaik
21:55:34 <dmwit> For uses that need cryptographic strength, there's DRBG, I think?
21:55:56 <haasn> But it's good enough for, say, generating a few random numbers for a game
21:56:11 <Pamelloes> I need speed over strength in this case. A good distribution is also important.
21:56:30 <dmwit> What does "strength" mean if not "a good distribution"?
21:56:55 <Pamelloes> Unpredictableness?
21:57:20 <Pamelloes> Though I guess that correlates to a good distribution now that I think about it.
21:57:22 <Pamelloes> L.
21:57:24 <Pamelloes> *:/
21:57:50 <Pamelloes> Anyways, speed is more important than security since I'm using a lot of random numbers.
21:58:21 <haasn> Mersenne twister is pretty fast, isn't it?
21:58:38 <Pamelloes> Would StdGen be able to give a couple of thousand a second, or should I get mersenne twister?
21:59:05 <haasn> Only one way to find out
21:59:42 <Pamelloes> .... I don't really know how to program that in Haskell....
21:59:46 <dmwit> Let's put the "science" in computer science!
21:59:59 <enthropy> any way to fake having "default implementations" for type families?
22:00:10 <dmwit> Pamelloes: replicateM_ 1000 randomIO
22:00:21 <Pamelloes> dmwit: good idea :)
22:00:29 <Pamelloes> Does that use StdGen?
22:00:33 <haasn> Pamelloes: ‚Äúcriterion‚Äù is useful
22:00:37 <dmwit> yes
22:00:42 <haasn> Perhaps in combination with what dmwit suggested
22:00:43 <enthropy> for example "class C a where T a :: Maybe *"
22:01:02 <enthropy> for example "class C a where type T a :: Maybe *"
22:01:23 <dmwit> I need some help figuring out how to answer a StackOverflow question. The setup is some guy wrote a program to test Fermat's Last Theorem and was surprised when it didn't finish. Then he asked this in a comment:
22:01:26 <enthropy> where instances that forget to define T, get  type T a = Nothing
22:01:35 <dmwit> "Does that mean in Haskell if the program specifies a value which does not exist it will hang forever?"
22:01:41 <dmwit> ...how do you even respond to that?
22:02:03 <haasn> dmwit: You let somebody else get the SO cred
22:02:26 <dmwit> enthropy: I don't think there's a way. Type families aren't really tied to the class system except in error messages.
22:02:34 <Pamelloes> dmwit: I would answer his question and then point out that his comment is unrelated to his question. Or follow haasn's excellent advice.
22:02:44 <Pamelloes> *answer his comment
22:02:59 <dmwit> Pamelloes: How would you answer his comment, though? That's the question here.
22:03:22 <dmwit> Like, there's something fundamentally weird about what he's thinking. How do you make that clear, and have a chance at correcting the fundamental weirdness?
22:03:26 <Pamelloes> If you specify a value that does not exist (1/0) you get an error.
22:03:54 <haasn> I like asking questions until I figure out what the fundamental misunderstanding is
22:04:02 <haasn> But that's not something tailored to the SO format, I think
22:04:48 <dmwit> Yeah, that works in an interactive setting like IRC.
22:04:57 <dmwit> But not so well when the turnaround time is ~12 hours.
22:05:18 * dmwit shrugs
22:05:56 <Pamelloes> Looks like StdGen is fast enough...
22:06:25 <dmwit> Pamelloes: Come to think of it, you might want to use replicateM instead of replicateM_.
22:06:38 <dmwit> Just to make sure it's not merely *pretending* to compute 1000 random numbers.
22:06:52 <Pamelloes> dmwit: Yeah... it was just pretending
22:07:13 <Pamelloes> using randomM_ I was able to do 100,000 without a noticable amount of time passing.
22:07:28 <Pamelloes> Now 1000 is taking around 30 seconds
22:07:51 <jle`> heh
22:07:51 <Pamelloes> Is there a "timeit" function in Haskell?
22:07:54 <dmwit> Are you sure that's not just from printing?
22:08:12 <dmwit> When I :set +s in ghci and run last <$> replicateM 1000 randomIO I get 0.07s.
22:08:20 <Pamelloes> dmwit It didn't print anything for about 30 seconds and then printed it all roughly instantly
22:08:21 <enthropy> dmwit: I can sort of see something happening with an overlapping instance/class: "class GetT a ta; instance GetT a Nothing", but I am trying to actually use this (T a) in a superclass constraint
22:08:50 <enthropy> in which case introducing another type variable means adding more parameters to a class
22:09:52 <dmwit> Pamelloes: Your computer is slow. =P
22:10:03 <Pamelloes> 0.01 seconds when I liftM last
22:10:22 <Pamelloes> Are you sure haskell isn't skipping 999 computations because it doesn't need them?
22:10:23 <dmwit> I get about the same amount of time whether I use last or not.
22:10:39 <dmwit> Yes, random number generation with StdGen is very serial.
22:10:43 <Pamelloes> Huh, now it took 0.10 seconds
22:10:51 <Pamelloes> I wonder what changed
22:11:08 <monochrom> dmwit: after much deliberation on the meaning of "specify, in a programming language, a value that does not exist", my answer is "yes".
22:11:38 <Pamelloes> monochrom: let yes = True
22:11:40 <dmwit> monochrom: Yeah, I have the same problem. =)
22:12:18 <monochrom> I don't think there is any problem with answering "yes".
22:12:44 <tommd> > sqrt (-1)
22:12:45 <lambdabot>  NaN
22:12:56 <Pamelloes> > 1/0
22:12:58 <lambdabot>  Infinity
22:13:02 <Pamelloes> wut
22:13:11 <Pamelloes> That's not right
22:13:21 <tommd> Pamelloes: Not right by what measure of right?
22:13:43 <Pamelloes> 1/0 is undefined. lim (x->0+) 1/x = Infinity
22:13:57 <Pamelloes> lim (x->0-) 1/x = -Infinity
22:14:04 <haasn> > 1/0 -- clearly defined
22:14:05 <Pamelloes> Other limits produce different things
22:14:05 <tommd> Pamelloes: Not in IEEE 754
22:14:06 <lambdabot>  Infinity
22:14:10 <monochrom> there is only one pseudo-problem of worrying that irrational people see that answer and assume that only Haskell does this. rational people do not jump to that conclusion. if you want to help irrational people, you only need add "this is also true of all programming languages".
22:14:15 <Pamelloes> tommd: Oh
22:14:35 <monochrom> but I have no sympathy on irrational people
22:14:55 <monochrom> s/ on / for /
22:15:05 <adu> irrational people suck
22:15:28 <dmwit> Well, saying everybody sucks isn't very productive.
22:15:46 <dmwit> > 1/0 :: Rational
22:15:48 <lambdabot>  *Exception: Ratio has zero denominator
22:16:00 <haasn> > 1/0 :: CReal
22:16:01 <tommd> I could rationalize that result.
22:16:04 <lambdabot>  mueval-core: Time limit exceeded
22:16:13 <Pamelloes> wut
22:16:13 <haasn> There; three different results to the same expression, all of which make sense
22:16:17 <dmwit> hahaha
22:16:26 <dmwit> That last one, though...
22:16:29 <Pamelloes> haasn: How does the last one make sense?
22:16:39 <Pamelloes> what's taking so long to compute about 1/0?
22:16:49 <EvanR> none of which make sense?
22:16:53 <monochrom> no, it's taking so long printing the digits of 1/0
22:16:55 <EvanR> dont try to divide by zero
22:17:05 <dmwit> Pamelloes: Maybe it's trying to check whether it really is zero.
22:17:22 <dmwit> Pamelloes: It keeps hoping it'll find a digit that isn't zero. And just keeps hoping and hoping.
22:17:24 <haasn> the last two are pretty much the same
22:17:35 <haasn> _|_ is _|_, one just shows an error message while the other fails to terminate
22:17:59 <EvanR> the type of the division operation is bad
22:18:03 <EvanR> naughty
22:18:07 <dmwit> monochrom: In case you want to see what I settled on: http://stackoverflow.com/a/28127677/791604
22:18:28 <Pamelloes> *throws up arms* 0 as a denominator is just bad.
22:18:37 <Pamelloes> Avoid at all costs
22:18:43 <Pamelloes> -2/10. Do not recommend.
22:18:52 <EvanR> > -2/10
22:18:54 <lambdabot>  -0.2
22:18:56 <EvanR> seems legit
22:19:04 <monochrom> heh ok dmwit
22:19:08 <Pamelloes> Sorry, that was a type.
22:19:12 <Pamelloes> *typo
22:19:16 * Pamelloes sighsd
22:19:23 <haasn> In general, you need to accept ‚Äúinfinite loop‚Äù being a result of division by zero
22:19:30 <haasn> Because the constant problem is undecidable
22:19:43 <Pamelloes> Constant problem?
22:19:47 <dmwit> Basically division by anything can be an infinite loop if your types are stupid enough.
22:19:48 <EvanR> or omit division by zero from consideration
22:19:57 <haasn> Pamelloes: Figuring out if an expression is zero
22:20:01 <Pamelloes> ok
22:20:07 <Pamelloes> dmwit
22:20:11 <haasn> (Or any other number, by virtue of f(x) - y)
22:20:22 <Pamelloes> gah. I'm going to "Bed" since I can't type anymroe
22:20:25 <Pamelloes> bed=lurking
22:20:43 <EvanR> old IRCers dont go to bed, they just lurk
22:21:01 <Pamelloes> old as in age or as in experience?
22:21:11 <EvanR> old
22:22:06 <Pamelloes> Yo, I've been using IRC since '10. I was practically there for the 20th anniversity.
22:22:13 <EvanR> "O ten"
22:22:17 <haasn> EvanR: But then you lose the ability to express sufficiently interesting expressions in your type system
22:22:34 <haasn> We're now in the same ballpark as trying to design a type system that prevents infinite loops
22:22:39 <EvanR> division by zero under normal arithmetic isnt sufficiently interesting
22:23:07 <Pamelloes> That's what limits are for!
22:23:16 <dmwit> > 1/0 :: Expr
22:23:18 <lambdabot>  1 / 0
22:23:18 <EvanR> you gain the ability to express the fact that you cant divide by zero
22:23:20 <haasn> Can't do it without losing the ability to express some programs that *do* terminate
22:23:32 <dmwit> Now you have four answers that all make sense.
22:23:38 <haasn> (Or in this case, result in a result)
22:23:39 <EvanR> that has nothing to do with division by zero
22:23:53 <Pamelloes> dmwit: 3 have a result. 1 doesn't terminate.
22:23:55 <EvanR> if you try to stop anything whatsoever from looping, then you lose stuff
22:24:05 <monochrom> Rice's theorem is pervasive
22:24:08 <EvanR> if you just want to stop division by zero...
22:24:24 <Pamelloes> Outlaw division?
22:24:39 <haasn> EvanR: let x = 1 / f(x)  -- where f is a sufficiently complicated function involving trigonometric functions
22:24:41 <tommd> Use liquid haskell
22:24:44 <haasn> Is this a type error?
22:25:05 <EvanR> its a type error if and only if some x causes your thing to crash ;)
22:25:06 <haasn> oh, bad variables
22:25:10 <haasn> the last X is a metavariable
22:25:44 <Pamelloes> haasn: Well, if you're using a floating point number with trig the odds are you'll get a very large/small number if f(X) should = 0.
22:25:49 <EvanR> or you could just put in a stupid dummy value for the result of dividing by zero, and be damned!
22:25:53 <shachaf> Rice's theorem is the best. Or worst, or something.
22:26:00 <dmwit> I've just checked ircbrowse. Apparently I've been doing #haskell for ten years now. Scary.
22:26:30 <tommd> dmwit: Scarier still is to see how many people you now know whom you first talked with on IRC.
22:26:52 <dmwit> hehe
22:27:20 <Pamelloes> o.o 10 years is a long time.
22:27:33 <dmwit> Also, I'm pretty sure I didn't say most of these things ircbrowse says I said.
22:27:41 <Pamelloes> I couldn't multiply 10 years ago...
22:27:43 <monochrom> :)
22:27:59 <Pamelloes> Now I know calculus.
22:28:07 <Pamelloes> And dmwit has been here the whole time.
22:28:11 <Pamelloes> o.o
22:28:13 <tommd> Pamelloes: Don't worry, most of us feel old already but thanks for trying.
22:28:19 * dmwit waves vaguely
22:28:36 <dmwit> I mean, even when I got here #haskell was old.
22:28:48 <Pamelloes> #haskell is older than me.
22:28:59 <Pamelloes> (well, probably)
22:29:01 * EvanR gives Pamelloes a baby rattle
22:29:04 <tommd> Is debian?
22:29:26 <dmwit> Wait, debian isn't older than #haskell?
22:29:35 * Pamelloes breaks it open and starts playing checkers with the beads
22:30:17 <monochrom> just don't eat the beads. or put in your nose. or any hole.
22:30:17 <Pamelloes> Debian was created in 1993.
22:30:44 <Pamelloes> Haskell was created in 1990.
22:31:21 <monochrom> but #haskell, this channel, is younger
22:31:36 <Pamelloes> True. I have no idea how to look up when the IRC channel was created
22:31:49 <dmwit> chanserv claims #haskell was founded in 2001.
22:32:25 <dmwit> I'm not sure I 100% believe that.
22:32:54 <tommd> Freenode traces its start back to 1994
22:33:04 <tommd> So I'd argue #haskell is not older than 1993...
22:33:17 <tejas-manohar> how do you make hangman in haskell
22:33:18 <tejas-manohar> im new
22:33:25 <tejas-manohar> haskell doesnt store state or have traditional vars?
22:33:42 <dmwit> tommd: pretty convincing argument
22:33:55 <tommd> tejas-manohar: I suggest you learn the language via a tutorial, such as Learn You a Haskell.  picking an arbitrary and somewhat large task probably won't be as productive.
22:34:03 <zomg> tejas-manohar: haskell can store state, but what he said.
22:34:25 <bitemyapp> tejas-manohar: https://github.com/bitemyapp/learnhaskell
22:34:33 <dmwit> ?wiki tutorials
22:34:33 <lambdabot> http://www.haskell.org/haskellwiki/tutorials
22:34:40 <bitemyapp> tejas-manohar: you can learn Haskell with "Learn you a Haskell", but there are better resources.
22:34:53 <tejas-manohar> sure but just wondering whats the term for what ill need in hangman
22:34:58 <tejas-manohar> they have state in haskell?
22:35:16 <zomg> Yes, pretty much all nontrivial apps require some state I think
22:35:30 <pacak> tejas-manohar: Several kinds of state actually.
22:35:35 <zomg> the difference is in haskell you are explicit about state / mutability
22:35:51 <jle`> tejas-manohar: you can write a function like GameState -> String -> GameState
22:35:55 <zomg> and ideally you localize it to a smaller portion of the code which reduces the likelihood of problems
22:36:05 <jle`> which takes a state, an input string, and returns a new gamestate from applying that input
22:37:24 <tejas-manohar> ok ah ok
22:37:42 <jle`> and then you can recurse
22:38:18 <dmwit> curse and curse again
22:38:54 <EvanR> everything is a state, or nothing is!
22:41:39 <EvanR> "state" seems like a bad generic term for what people usually want: mutable variables
22:42:24 <Hafydd> smash the state
22:42:54 <dmwit> Everybody talks about the state but nobody talks about the transition function.
22:43:03 <monochrom> united mutable variables of america
22:44:12 <SharpGAF> I'm just talkin' bout state
22:46:31 <Pamelloes> How can I apply a function to a writer's value from a do statement?
22:47:07 <Pamelloes> Nevermind, I figured it out.
22:49:38 <dmwit> This is like, the stuff of legendary rage elsewhere on the Internet.
22:49:54 <Pamelloes> oh?
22:50:22 <Pamelloes> Is there a pure version of timeout?
22:50:30 <dmwit> Definitely not.
22:50:40 <Pamelloes> I guess that makes sense
22:50:42 <Pamelloes> damn
22:50:42 <EvanR> whats wrong with timeout?
22:51:35 <Pamelloes> EvanR: Well I'm working with a genetic algorithm library and requires the fitness function to be pure. But I need to use timeout which means an impure function.
22:51:45 <Pamelloes> I guess I need to change my library...
22:52:06 <SharpGAF> EvanR: My personal experience has been that if your code relies on a timeout for correctness, your code is wrong.
22:52:06 <EvanR> yeah pure functions dont depend on real time
22:52:21 <SharpGAF> Regardless of language or task (unless you're writing a realtime OS).
22:52:52 <EvanR> SharpGAF: it makes sense for an IO action that is blocked waiting for an fd or a mvar
22:52:59 <EvanR> you gave up waiting
22:53:04 <Pamelloes> SharpGAF: I'm executing arbitrary (pure) code... timeout seems like a perfect solution unless you can solve the halting problem.
22:53:24 <EvanR> timeout doesnt seem like a perfect solution for pure code
22:53:38 <Pamelloes> EvanR: What would be a better solution?
22:54:04 <EvanR> your problem is that your algorithm might take too long? or it might be infinitly looping
22:54:05 <SharpGAF> EvanR: Even there, I would argue that the code would be "correct" without the timeout
22:54:38 <Pamelloes> I'm using genetic algorithms to synthesize a function. A timeout is useful incase an intermediate function infinitely loops.
22:54:52 <Pamelloes> I also need to time the functions as a part of the fitness score.
22:55:14 <EvanR> SharpGAF: eh, if i have a GUI app and i press "connect to server" and begin waiting for that finish (and it doesnt timeout on its own) ... what wait for the user to decide to stop waiting?
22:55:26 <EvanR> just trying to give a counter example to "timeout never good"
22:55:49 <dmwit> Pamelloes: What if you don't allow arbitrary functions.
22:55:53 <EvanR> (in which case the user would send an async exception)
22:55:56 <SharpGAF> EvanR: You can usually send signals to break the connection, which the user could invoke.
22:56:11 <dmwit> Write an interpreter for a simple lambda calculus, instead. Supply the interpreter with a maximum number of steps.
22:56:14 <SharpGAF> EvanR: That's actually a good example of where a timeout is *not* the right solution even though it seems like one.
22:56:20 <EvanR> SharpGAF: right, any concurrent system can replace automatic parts with user having to press buttons to make it go
22:56:28 <dmwit> Turing completenes + a pure, clean denotational semantics. What's not to love?
22:56:39 <SharpGAF> EvanR: (Which isn't to say you might still not use a timeout, but at least your program should be correct without it).
22:56:41 <EvanR> but theres the automatic aspect that computers are supposed to be doing
22:56:49 <EvanR> "correct"
22:56:59 <Pamelloes> dmwit: That's actually a really good idea....
22:57:00 <SharpGAF> EvanR: Correct in the sense that it would be fully functional without the timeout.
22:57:09 <EvanR> this android app here is incorrect since its harder to use than apple ;)
22:57:11 <SharpGAF> You're not *relying* on the timeout for functionality to work.
22:57:24 * dmwit preens
22:58:07 <EvanR> SharpGAF: well as business requirements get to a certain point, correctness can boil down to whims of sales people
22:58:25 <SharpGAF> EvanR: Well, it is not my fault that sales people do not understand schedulers :(
22:58:44 <EvanR> thats where a timeout would be correct, and something getting stuck until someone if forced to go fix something manually
22:58:45 <SharpGAF> I'm not saying "don't add timeouts" just make sure your program works if the timeout fails.
22:59:32 <SharpGAF> With rare exceptions, writing a program that relies on timeouts requires you to have hardware that most users do not have.
22:59:45 <SharpGAF> Well, writing it doesn't, but making sure it works correctly.
23:00:00 <EvanR> timing out certain IO actions is ok
23:00:14 <EvanR> according to ghc
23:00:25 <SharpGAF> GHC isn't the ultimate arbiter of program correctness :P
23:00:28 <EvanR> whichever ones can be async exceptioned
23:01:04 <dmwit> This fight seems like it's going good places.
23:01:05 <EvanR> all your asertions have been of the negative variety!
23:01:39 <SharpGAF> Positive assertion: one should ensure that one's programs work in the absence of timeouts :)
23:01:52 <SharpGAF> Ways to accomplish this are varied and depend on the task at hand.
23:02:03 <EvanR> a big concurrent system getting stuck may or may not be correct, seems like
23:02:26 <SharpGAF> Quite true; however, timeout-based problems are a major source of errors in concurrent system implementations.
23:02:52 <bramgg> Does ">>=" pass the produced value as the first or last argument?
23:03:06 <glguy> Whether or not you should use timeouts or not, you *can*... System.Timeout.timeout and Control.Exception.evaluate can be used together to give a pure value a certain amount of time to try to complete evaluation
23:04:47 <Pamelloes> Can you split a function's type declaration over multiple lines?
23:05:09 <jle`> mhm
23:05:14 <Pamelloes> bramgg: last
23:05:16 <jle`> you can do it for a value, too
23:05:20 <jle`> er, a non-function value
23:05:34 <EvanR> Pamelloes: also first. all functions have one parameter
23:05:52 <bramgg> thanks
23:06:03 <EvanR> so bramgg is probably confused
23:06:27 <Pamelloes> EvanR: technically. But when you are simplifying the understanding of a->a->a as a two parameter function, >>= will pass the produced value as the second value.
23:06:30 <dmwit> Pamelloes: What happened when you tried it? =)
23:06:37 <EvanR> Pamelloes: eh?
23:07:13 <Pamelloes> EvanR: Sorry for my incoherence. My thoughts are cohenerent but my tiredness makes expressing them challenging
23:07:23 <EvanR> > return 3 >>= (\x y -> return y)
23:07:25 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
23:07:25 <lambdabot>    arising from a use of ‚ÄòM346592303850797628430007.show_M3465923038507976284...
23:07:25 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
23:07:30 <shachaf> dmwit: It's not all that pathological for liftA2 to be asymptotically better than liftM2, is it?
23:07:45 <Pamelloes> EvanR: return 3 >>= (-) 19
23:07:50 <Pamelloes> oops
23:08:00 <EvanR> > return 3 >>= (\x y -> return y) :: Identity Int
23:08:01 <lambdabot>  Couldn't match expected type ‚Äòa1 -> m0 a1‚Äô
23:08:01 <lambdabot>              with actual type ‚ÄòData.Functor.Identity.Identity GHC.Types.Int‚Äô
23:08:03 <Pamelloes> > return 3 >>= $ (-) 19
23:08:05 <lambdabot>  <hint>:1:14:
23:08:05 <lambdabot>      parse error on input ‚Äò$‚Äô
23:08:05 <lambdabot>      Perhaps you intended to use TemplateHaskell
23:08:11 <Pamelloes> > return 3 >>= (-) 19
23:08:12 <lambdabot>  No instance for (GHC.Show.Show (m0 b0))
23:08:12 <lambdabot>    arising from a use of ‚ÄòM466318690300619678030056.show_M4663186903006196780...
23:08:13 <lambdabot>  The type variables ‚Äòm0‚Äô, ‚Äòb0‚Äô are ambiguous
23:08:27 <EvanR> >>= doesnt take a "two argument" function
23:08:31 <Pamelloes> hm
23:08:34 <Pamelloes> I see your point
23:08:40 <dmwit> shachaf: I don't know what you're complaining about. (reload)
23:08:43 <glguy>  Also don't flood
23:08:48 <Pamelloes> Sorry!
23:08:50 <nshepperd_> all functions "have one parameter", but something of type (a -> m b) especially has one parameter
23:09:15 <shachaf> Double especially when m isn't (e ->).
23:09:21 <EvanR> lol
23:09:38 <EvanR> argument counting is hard
23:09:40 <nshepperd_> or when m is unknown, really
23:10:23 <shachaf> When m is unknown you don't know.
23:11:06 <EvanR> there known knowns, and there known unknowns
23:11:16 <shachaf> So an odd thing between monads and comonads is that with (=>>) :: w a -> (w a -> b) -> w b, when you write x >>= (\y -> ...), you have x, y :: w a in scope.
23:11:42 <shachaf> So you can't just take whatever is of the right type for what you're doing; you actually have to think and realize that you want y, not x.
23:12:05 <shachaf> (For monads you sort of have the same thing for the return value of the lambda vs. the whole expression, but it's not really an issue.)
23:13:11 <EvanR> you mean x =>> (\y -> ...
23:13:24 <shachaf> I mean =>>, yes.
23:14:10 <EvanR> you dont necessarily have x in scope
23:14:30 <shachaf> Yes you do, you just wrote x =>>
23:14:45 <EvanR> ah yes, when you write x =>>
23:15:38 <EvanR> same as x >>= (\y -> ...
23:16:04 <EvanR> if the types match up
23:17:09 <Pamelloes> is there a way to define type MyType = (Int,(Bool,MyType->MyType))? And yes I've tried it and it won't work in that form.
23:17:36 <EvanR> with a newtype
23:17:37 <dmwit> newtype MyType = MyType (Int,(Bool,(MyType->MyType)))
23:17:53 <Pamelloes> damn.
23:18:10 <Pamelloes> Now for an hour of refactoring! woohoo
23:18:11 <dmwit> Now ask yourself what newtype Huh = Huh Huh does.
23:18:20 <jle`> Pamelloes: the problem is tht type aliases are resolved at compile time
23:18:37 <funfunctor> simple question, how to get haddock to ignore a sub directory from being looked at for doc comments?
23:18:41 <jle`> Pamelloes: tehy're just lexical aliases, basically
23:18:51 <jle`> Pamelloes: so how would you 'fully expand that' at compile time? :p
23:18:59 <Pamelloes> jle`: lazily?
23:19:14 <EvanR>  :t fix Huh
23:19:32 <dmwit> fix Huh :: Huh
23:19:32 <enthropy> some languages don't have that occurs check / an option to disable it IIRC
23:19:36 <funfunctor> I have this as my test case http://pastebin.com/xp4Mwwr2
23:19:56 <Pamelloes> My issue is I don't like wrapping things so I try use type aliases and then when I start adding features the decision screws me over
23:19:59 <shachaf> It's possible to support infinite types.
23:20:02 <shachaf> GHC just doesn't.
23:20:18 <dmwit> Oh, hold on, I have a wonderful explanation of why sitting around in my bookmarks.
23:20:20 <EvanR> Pamelloes: well, use newtypes specifically when wrapping and unwrapping is helpful
23:20:42 <dmwit> http://article.gmane.org/gmane.comp.lang.haskell.cafe/17105
23:20:43 <EvanR> one reason is using type would cause an infinite type
23:21:06 <EvanR> or you might get two synonymous but "different" types confused
23:21:13 <enthropy> http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora209.html
23:21:15 <dmwit> "I for one took that as a challenge, and have implemented a type inference engine for infinite types."
23:21:23 <shachaf> dmwit: I was thinking of that same thread.
23:21:52 <EvanR> or you want to swap out type class instances
23:21:54 <Pamelloes> 358 lines of errors after refactoring from type to newtype. It's gonna be a long[er] night.
23:22:16 <EvanR> thank ghc 358 times, once for each of those pieces of advice
23:23:03 <funfunctor> basically to ask my question better. I have src/{Binding,LibBladeRF}/ I would like Haddock to ignore the Binding subdirectory and only look for documentation coverage in LibBaldeRF
23:23:07 <EvanR> also you could make sure your data types make sense before continuing
23:25:07 <dmwit> funfunctor: I think there is a pragma you can stick in a file to ask haddock to ignore it.
23:25:15 <dmwit> funfunctor: Have you looked through the haddock documentation yet?
23:25:54 <dmwit> let's see here...
23:26:13 <dmwit> https://www.haskell.org/haddock/doc/html/module-attributes.html
23:26:48 <Hijiri> haskell is just a crazy language for bottoms who like being bound by types
23:33:00 <funfunctor> dmwit: yes I have, I didn't see said pramga but is there a way to do it directory wide?
23:33:51 <funfunctor> dmwit: I only saw comments about ignoring explicit exports so I would be interested to hear about the pragma
23:34:29 <dmwit> funfunctor: I linked you right to the pragma documentation.
23:34:47 <Zefphex> ?
23:34:50 <dmwit> I don't know of a way to do it directory-wide off-hand, but I haven't looked for one before.
23:35:05 <funfunctor> dmwit: woops, sorry missed that.. sorry irssi is broken again locally so I am using this shitty client
23:39:02 <SrPx> hmm
23:39:17 <SrPx> in order to have a faster fps in something, I pre-calculed a few arrays
23:39:30 <SrPx> it seems like ghc is garbage collecting my pre-calculations and doing it all over again!
23:39:39 <SrPx> how do I tell it to stawp collecting a specific value
23:40:06 <dmwit> Are you sure?
23:40:25 <dmwit> Is your array typeclass polymorphic?
23:41:57 <Pamelloes> Do you have to be in IO to catch an error?
23:41:59 <SrPx> Yea I'm sure, I've put a "trace" on the inner loop of the array and it keeps rebuilding
23:42:26 <SrPx> dmwit: I guess it is because i'm using gloss's "animateArray"... it seems like GHC clears everything between frames. I don't know for sure
23:42:41 <EvanR> Pamelloes: normally yes
23:42:49 <SrPx> this is the function that produces the value that I want to be kept: xRayImages :: V.Vector (Array D DIM2 (V.Vector (V3 Float))); xRayImages = xRay (atoms 0)
23:43:01 <SrPx> I mean... xRay is the function. xRayImages is the value
23:44:11 <funfunctor> dmwit: I guess i'm looking for a way to pass those haddock options in the cabal file via something like how default-extensions:  ForeignFunctionInterface works
23:44:20 <EvanR> Pamelloes: i dug up a black magic library to do otherwise, but id be suspicious https://hackage.haskell.org/package/spoon-0.3.1/docs/Control-Spoon.html
23:44:40 <dmwit> SrPx: Well, if your trace is in xRay or atoms, I guess that doesn't *necessarily* mean that xRayImages is getting garbage collected.
23:44:47 <dmwit> SrPx: Could also be that something else is calling those.
23:45:06 <dmwit> SrPx: Though I'm sure you thought of that, and then we're deep into territory I don't understand. =P
23:45:13 <Pamelloes> EvanR: I'm just subtly throwing in a Maybe, I might look at that if I get desparate.
23:45:29 <EvanR> yes, use Maybe or Either
23:45:30 <dmwit> Pamelloes: Maybe or Either is the recommended way, anyway.
23:45:55 <jle`> EvanR: that library uses unsafePerformIO
23:46:00 <jle`> the semantics are fairly sound though
23:46:05 <SrPx> It is 4am and I'm really really confused
23:46:29 <funfunctor> SrPx: haha, I so know that feeling !
23:46:36 <EvanR> jle`: if an error besides the ones they list happen, it acts normally?
23:46:46 <funfunctor> SrPx: ..and you just /have to/ know or you can't sleep?
23:47:08 <SrPx> funfunctor: right? I kinda know it can't be right but I'm not sober enough to dispute it.
23:47:16 <SrPx> funfunctor: of course I do
23:47:24 <jle`> EvanR: i'm not sure i understand your question
23:47:54 <EvanR> it will convert "prelude.undefined" division by zero and some other things to a Nothing
23:48:05 <EvanR> but what about ...
23:48:24 <EvanR> an async exception
23:48:48 <EvanR> or another unsafePerformIO which causes an IOError
23:49:05 <jle`> it'll catch any runtime errors that arise from evaluation
23:49:14 <EvanR> :S
23:49:30 <jle`> i'm not 100% about async errors but that wouldn't be too tricky to test :)
23:49:43 <jle`> just make it evaluate something really expensive and use a well-timed Ctrl+C
23:50:27 <jle`> i think that might break the sematnics a bit if it worked like that
23:50:56 <EvanR> id hope that it ignores "impure" errors
23:51:04 <EvanR> but i dont want to test it right now
23:51:51 <SrPx> ah I guess... hmm
23:51:52 <jle`> if the thing you are evaluating uses unsafePerformIO and leaks IO errors then it's sort of taken for granted that questions of semantics are sort of out the window
23:52:51 <EvanR> yes by that point you are definitely in the looney bin
23:53:10 <dmwit> but can it turn my proof of fermat's last theorem into a Nothing for me
23:53:18 <mauke> semantics more liek semtex ayy lmao
23:54:15 * HeladoDeBrownie puts a child-safe lid on the looney bin
23:59:29 <SrPx> ah
23:59:35 <SrPx> found the problem
23:59:43 <SrPx> you guys knew it, didnt you? it was stupid
23:59:50 <SrPx> :(
