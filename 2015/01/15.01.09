00:03:32 <cwl> I see "~>" in the type signature, what does it mean ?
00:03:47 <cwl> It hard to google this symbol
00:03:54 <joneshf-laptop> ThreeOfEight, thanks
00:06:56 * hackagebot Deadpan-DDP 0.8.0.0 - Write clients for Meteor's DDP Protocol  http://hackage.haskell.org/package/Deadpan-DDP-0.8.0.0 (LyndonMaydwell)
00:10:09 * hackagebot hi 1.1.0.0 - Generate scaffold for cabal project  http://hackage.haskell.org/package/hi-1.1.0.0 (DaisukeFujimura)
00:10:09 * hackagebot Deadpan-DDP 0.8.0.0 - Write clients for Meteor's DDP Protocol  http://hackage.haskell.org/package/Deadpan-DDP-0.8.0.0 (LyndonMaydwell)
00:11:06 <int-e> cwl: well, where are you seeing that?
00:11:28 <cwl> int-e, http://dev.stephendiehl.com/hask/#categories-1
00:12:02 <int-e> cwl: it's defined just above: type (a ~> b) c = c a b
00:12:55 <cwl> int-e, aha, thanks!
00:18:11 <albertov> Hi. I’m trying to build my library (https://github.com/meteogrid/sigym4-geometry) with ghc-7.10.0.20141222 but it crashes with “ghc: out of memory (requested 1048576 bytes)”. I guess it’s a ghc bug since it compiled fine with 7.8.3. I have no idea how to boil it down to a simple case or if it’s related to a known bug from https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-7.10.1. Never filed a ghc bug before or sure if it
00:18:12 <albertov> even is… Any help appreciated :)
00:31:04 <Javran> I'm developing a local cabal project, how can I install it into another sandbox?
00:31:12 <KoreaPanda> hello everyone
00:31:22 <KoreaPanda> 한국말 하시는분 있나요?
00:31:52 <KoreaPanda> Can you speak korean in this room
00:31:54 <KoreaPanda> ?
00:32:00 <Javran> I don't think so
00:32:04 <ski> perhaps you just did
00:32:08 <KoreaPanda> yeah
00:32:20 <KoreaPanda> except me.. other?
00:32:24 <Javran> I can confirm it's korean though
00:32:30 * ski doesn't know
00:32:49 <KoreaPanda> 모나드는 어떻게 사용합니까?
00:33:05 <KoreaPanda> how to use 'monad' in haskell paragraph?
00:33:25 <ski> which monad ?
00:33:27 <KoreaPanda> I'm so confused...
00:33:45 <KoreaPanda> I can't understand monad 's rule..
00:33:56 <sipa> don't
00:34:00 <KoreaPanda> ok
00:34:11 <KoreaPanda> i don't understand monad..
00:34:15 <sipa> just learn how to do interesting things with haskell
00:34:26 <sipa> at some point you'll just get it
00:34:40 <sipa> monads are known to be something that cannot be explained
00:35:05 <KoreaPanda> i studied already haskell.. but don't understand monad
00:35:11 <CindyLinz> Every monad learner said monads are hard; every monad teacher said monads are easy..
00:35:21 <KoreaPanda> haha..
00:35:25 <KoreaPanda> irony...
00:35:53 <frawgie_> KoreaPanda: try to use monads a bit more, play around with it and you will eventually "get it" :)
00:36:09 <KoreaPanda> teacher is human equal me & other learner, isn't you?
00:36:43 <albertov> javran: cabal sandbox init --sandbox-config-file=<path to the other sandbox’s config file>
00:37:08 <KoreaPanda> but, teacher saids "monad is easy" ...??
00:38:20 <frawgie_> maybe you are not ready to teach it yet? :)
00:38:30 <Javran> albertov: so if that sandbox is already initialized, I can install to it by cabal install --sandbox-config-file=<config> ?
00:39:54 <KoreaPanda> i'm studying haskell right now... but monads are hard.. reading reading reading.. but don't understand..
00:40:02 <albertov> Javran: no need to, just initialize it in your local project with the command I told you and then it will just use that sandbox
00:40:02 <CindyLinz> KoreaPanda: In my experience, I was eager to know what are the concrete imagination of monads. And I lost for a long time.
00:40:43 <albertov> Javran: I mean, the sandbox you pointed to with the —sandbox-config-file flag
00:40:51 <frawgie_> KoreaPanda: write more code :)
00:41:00 <KoreaPanda> CindyLinz, hm... I'll have a long time with concrete imagination..
00:41:12 <Javran> albertov: I see, will try.
00:41:25 <frawgie_> KoreaPanda: monads are tough to learn so dont worry about that, getting some hands on experience by playing around with them can help to get a better understanding
00:43:22 <CindyLinz> KoreaPanda: Until one day. I realize that there're none. Monads are just monads.. I can't find a proper metaphore for them.. There's always counterexample breaking my imagination @@"
00:48:48 <KoreaPanda> hm.... ok... T.T
00:54:08 <Javran> albertov: gotcha! now there're actually sharing the same sandbox :) thanks
00:55:05 * hackagebot haskell-packages 0.2.4.4 - Haskell suite library for package management and integration with Cabal  http://hackage.haskell.org/package/haskell-packages-0.2.4.4 (RomanCheplyaka)
00:55:34 <albertov> Javran: no problem, glad to help (for the first time in this channel :)
00:58:38 <Javran> albertov: good for you! btw in my cabal (1.20.0.6) its "cabal sandbox init --sandbox=<sandbox directory>"
01:04:47 <Plastefuchs> looking at http://stackoverflow.com/questions/44965/what-is-a-monad What is "<|>"? Looking for Haskell operators it either is a collection of several of those or something on its own? ._.
01:05:18 <Iceland_jack> From Alternative?
01:05:21 <Iceland_jack> @ty (<|>)
01:05:22 <lambdabot> Alternative f => f a -> f a -> f a
01:05:42 <Plastefuchs> aha ._.
01:05:45 <Iceland_jack> In module Control.Applicative.
01:06:03 <Iceland_jack> > Just 5 <|> Just 2004
01:06:05 <lambdabot>  Just 5
01:06:06 <Iceland_jack> > Nothing <|> Just 2004
01:06:07 <lambdabot>  Just 2004
01:06:13 <Iceland_jack> > Nothing <|> Nothing
01:06:14 <lambdabot>  Nothing
01:07:13 <Plastefuchs> arg
01:07:19 <Plastefuchs> So many weird things :D
01:07:35 <Plastefuchs> It is like relearning programming once over in a way.
01:07:38 <Iceland_jack> (<|>) is not nearly as important as Functor/Applicative/...
01:08:10 <Iceland_jack> Not knowing (<|>) isn't really a big deal
01:08:25 <Plastefuchs> I just saw it in the explanation of monads and while the others where sort of intuitive, this one was a bit muddy.
01:15:05 * hackagebot yesod-auth 1.4.1.3 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.4.1.3 (MichaelSnoyman)
01:16:34 <yoeight> Anyone having experience using netwire on a concurrent setting ?
01:20:31 <adamse_> is there a document.querySelector/jQuery like interface for html data extraction in haskell?
01:28:36 <d12frosted> hm, I was wondering, why ghc versions are incremented using (+ 0.2). Does anyone know the reason?
01:31:43 <averell> even are stable versions, odd are devel. like the linux kernel used to do at some point
01:35:00 <lpaste> simg pasted “Simple type inference problem?” at http://lpaste.net/118111
01:35:06 * hackagebot data-filepath 2.1.0.0 - A type safe file path data structure  http://hackage.haskell.org/package/data-filepath-2.1.0.0 (domdere)
01:36:05 <simg> hi all. still struggling (but moving forward!!) with creating a simple haskell (snap) web app. if anyone could take a look at my link from lpaste  it would be greatly appreciated.
01:37:44 <augustss> > [1,2] <|> [3,4,5]
01:37:45 <lambdabot>  [1,2,3,4,5]
01:39:28 <jameseb> simg: a Maybe Customer is either Just Customer or Nothing, you have to use the Just type constructor for putting something in a Maybe
01:39:39 <SoupEvil> is there a way to measure the individual compile times for modules in a cabal project?
01:40:06 * hackagebot data-filepath 2.1.0.1 - A type safe file path data structure  http://hackage.haskell.org/package/data-filepath-2.1.0.1 (domdere)
01:40:45 <SoupEvil> my build is getting extreme slow, and I want to know why und where
01:41:43 <SoupEvil> my last card to draw would be git bisect, but this would take some serious efford
01:45:14 <adamse> SoupEvil: I think there is some flag that can be passed to ghc to get compile time metrics
01:45:54 <adamse> SoupEvil: -Rghc-timing
01:46:03 <adamse> at the bottom: https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/options-help.html
01:46:08 <adamse> will perhaps work
01:47:02 <SoupEvil> adamse: many thanks, i will give it a try
01:50:07 * hackagebot hi 1.1.0.1 - Generate scaffold for cabal project  http://hackage.haskell.org/package/hi-1.1.0.1 (DaisukeFujimura)
01:54:23 <adamse> d12frosted: only even stable releases makes it easy to refer to unstable versions as the odd versions
01:55:02 <d12frosted> adamse: oh, thanks for explaining it to me :D
02:17:46 <LysergicDreams> Anyone use reform + blaze-html + happstack?
02:18:59 <adamse> adamse: I guess taggy-lens is a reasonable answer to querySelector/jQuery like interface to html extraction in haskell
02:29:24 <Qfwfq> People are using taggy-lens? :-D
02:34:24 <adamse> Qfwfq: I dunno, but I might try to use it
02:36:29 <Qfwfq> adamse: Don't hesitate to open issues should you run into any. <3
03:05:10 * hackagebot hpqtypes 1.3.0 - Haskell bindings to libpqtypes  http://hackage.haskell.org/package/hpqtypes-1.3.0 (arybczak)
03:20:10 * hackagebot sloane 2.0.3 - A command line interface to Sloane's On-Line Encyclopedia  of Integer Sequences  http://hackage.haskell.org/package/sloane-2.0.3 (AndersClaesson)
03:22:32 <echo-area> lol, this entry is so funny: Please write comments in English. Especially avoid Klingon.
03:29:15 <alpounet> Qfwfq: we even have an (yet) unsolved issue, on some very nasty corner case of the html spec, reported by a user =)
03:29:36 <aisqwe> how does the :i command work in ghci?
03:29:51 <bernalex> aisqwe: what do you mean
03:30:30 <aisqwe> how does it extract this much of information about a function? where does it find this information?
03:31:05 <ski> the information is associated with the identifier, not the function
03:31:33 <Qfwfq> alpounet: Oh, damn me for overzealous disabling of notifications.
03:33:35 <ski> aisqwe : it's part of the information collected for the loaded modules
03:33:53 <alpounet> Qfwfq: i've released an update for taggy a few days ago because i needed it to accept <? and ?>, for parsing sitemaps (thus xml)
03:37:05 <tasker> I'm trying to use cabal for the first time on a new install, on linux. I get an error about not being able to load libgmp.so.10. ldd cabal shows that it is correctly knows where libgmp.so.10 is. Any ideas why it fails?
03:38:33 <dcoutts_> tasker: this is a ghc install issue, where did you get your ghc, from haskell platform download or direct ghc download?
03:38:45 <tasker> direct download
03:38:55 <tasker> uh, let me find the exact link
03:38:56 <dcoutts_> ok, then you probably want the "other" one
03:39:01 <dcoutts_> there's two binary builds
03:39:08 <tasker> https://downloads.haskell.org/~ghc/7.8.4/ghc-7.8.4-x86_64-unknown-linux-deb7.tar.bz2
03:39:09 <dcoutts_> for the differences between distros wrt gmp
03:39:14 <tasker> ohh
03:39:17 <tasker> okay then.
03:39:22 <tasker> thanks :)
03:39:30 <dcoutts_> some distros have libgmp.so.3, some .so.10
03:39:49 <dcoutts_> tasker: and of course make sure you do have your distro's gmp installed ok
03:40:11 * hackagebot slack-api 0.2.1 - Bindings to the Slack RTM API.  http://hackage.haskell.org/package/slack-api-0.2.1 (mpickering)
03:40:17 <tasker> dcoutts_: How can I check? I did sudo apt-get install libgmp-dev on ubuntu..
03:40:23 <tasker> and it seems to be where it says it is
03:40:26 <dcoutts_> should be ok then
03:40:42 <dcoutts_> iirc the download page mentions which one is appropriate for which system
03:41:08 <tasker> so I should get the file ending in .xz ?
03:41:16 <tasker> I actually didn't see the downloads pages..
03:42:24 <tasker> ah, I see
03:46:32 <adamse> in cabal, how can I pass a flag to a dependency?
03:47:28 <jaspervdj> Hmm, does anyone know if there's a way to get the remote IP/port in wai/warp?
03:47:30 <dcoutts_> adamse: on the command line you can just use the normal -f  option. It's (deliberately) not possible in a .cabal file.
03:48:01 <adamse> dcoutts_: will cabal install pass flags to dependencies?
03:48:48 <dcoutts_> adamse: I believe it behaves that way, though perhaps we changed it. If so, use --constraint='pkg +/-flag'
03:49:02 <adamse> dcoutts_: thanks
03:54:39 <ocharles> Could anyone do me a favor and run `cabal install -v --haskell-suite hs-gen-iface base-prelude` and paste the log? I'm trying to run `hs-gen-iface` by hand but I don't know the correct flags to use it
03:54:47 <ocharles> and cabal install isn't playing well in my NixOS setup
03:55:04 <ocharles> (you don't have to use base-prelude, I just picked something that has no deps)
03:57:26 <mpickering> I get an error trying to run that command
03:57:42 <ocharles> do you have hs-gen-iface installed?
03:57:47 <ocharles> you'd need to cabal install that first
04:00:12 * hackagebot relational-query 0.4.0.1 - Typeful, Modular, Relational, algebraic query engine  http://hackage.haskell.org/package/relational-query-0.4.0.1 (KeiHibino)
04:04:09 <mpickering> What is your nix workflow ollie? Do you not nix-shell, cabal repl?
04:04:28 <ocharles> mpickering: that's right, but I'd like to try and do something `haskell-names`
04:04:46 <ocharles> and that requires me to generate names interface files, which is traditionally done with `cabal install` it seems
04:04:48 <ocharles> but I don't use that :)
04:05:12 * hackagebot elm-compiler 0.14.1 - Values to help with elm-package, elm-make, and elm-lang.org.  http://hackage.haskell.org/package/elm-compiler-0.14.1 (EvanCzaplicki)
04:05:14 * hackagebot elm-package 0.4 - Package manager for Elm libraries  http://hackage.haskell.org/package/elm-package-0.4 (EvanCzaplicki)
04:05:44 <mpickering> "cabal: You have to provide name or path of a haskell-suite tool (-w PATH)"
04:07:15 <SrPx> Does this look like normal code? "ang = (fromIntegral i) / (fromIntegral (length curve)) * 2 * pi" . I'm find it weird that I use "fromIntegral" too much. Am I doing something wrong, or is this normal?
04:07:32 <ocharles> mpickering: oh, I missed the -w
04:07:44 <ocharles> mpickering: how about cabal install -v --haskell-suite -w hs-gen-iface base-prelude
04:07:59 <ocharles> SrPx: what are the types of `i` and `curve`?
04:08:12 <ocharles> i guess the type of curve is irrelevant, because length chooses `Int`
04:08:17 <ocharles> :t length
04:08:18 <lambdabot> [a] -> Int
04:08:35 <SrPx> "i" is an Integral coming from `map f [0..lim]`, curve is a list of a predefined type...
04:09:08 <bergmark> :t genericLength
04:09:09 <lambdabot> Num i => [a] -> i
04:09:32 <mpickering> cabal: The program 'haskell-suite' is required but it could not be found. ocharles
04:09:39 <ocharles> ok, then you're going to have to convert both of those integrals to something that's Fractional - so there's not much more you can do...
04:10:12 * hackagebot elm-reactor 0.3 - Interactive development tool for Elm programs  http://hackage.haskell.org/package/elm-reactor-0.3 (EvanCzaplicki)
04:10:12 <SrPx> bergmark: interesting, thanks! That solves the second fromIntegral, but what about the "i" coming from (map f [0..]) ? Why can't Haskell understand it is not an Int?
04:10:14 * hackagebot elm-make 0.1.1 - A build tool for Elm projects  http://hackage.haskell.org/package/elm-make-0.1.1 (EvanCzaplicki)
04:10:15 <ocharles> mpickering: ok, no idea then. Sorry :( thanks for trying!
04:10:23 <ocharles> bergmark: maybe you can help me know how to call hs-gen-iface :)
04:10:32 <ski> (could remove a few redundent brackets)
04:10:42 <ocharles> SrPx: haskell probably does know it's an Int, but you can't use / on Int
04:11:04 <ski> > 12 / 3 * 2
04:11:05 <lambdabot>  8.0
04:11:08 <ski> > 12 / (3 * 2)
04:11:10 <lambdabot>  2.0
04:11:37 <ski> SrPx : ^ ?
04:12:43 <bergmark> ocharles: i haven't used it...
04:12:45 <ski> SrPx : re `i', could be DMR
04:12:52 <ocharles> bergmark: oh, you're listed as a backup maintainer
04:13:12 <ocharles> i thought that meant you might know how it works ;)
04:13:31 <bergmark> ocharles: that could have been the case!
04:13:35 <bergmark> but now: lunch
04:13:38 <ocharles> enjoy
04:14:56 <SrPx> > map (\x -> x / 2) [0..5]
04:14:58 <lambdabot>  [0.0,0.5,1.0,1.5,2.0,2.5]
04:15:11 <SrPx> weird!
04:15:15 <SrPx> Hmm...
04:15:22 <ski> why is that weird ?
04:15:33 <int-e> > [0..5.5]
04:15:34 <lambdabot>  [0.0,1.0,2.0,3.0,4.0,5.0,6.0]
04:15:37 <SrPx> My code won't compile without "fromIntegral" before that x... hmm
04:15:54 <ski> SrPx : try adding a type signature for `i'
04:15:55 <int-e> Double and Float have Enum instances (though rather strange ones)
04:16:24 <int-e> (Rational, too)
04:16:26 <clrnd> > succ 6.7
04:16:28 <lambdabot>  7.7
04:16:36 <clrnd> > succ (1/3)
04:16:38 * ski was just about to ask about `Rational' :)
04:16:38 <lambdabot>  1.3333333333333333
04:16:52 <int-e> > fromEnum 1.3
04:16:54 <lambdabot>  1
04:18:43 <aisqwe> what is this strange code in the definition of words function? {-partain:Char.-}isSpace ?
04:20:04 <tappaa> hi, i have a type which is (data Object = A (H P) | B (H Q)) and, want to make such a function (apply :: (C a) => Object -> (H a -> b) -> b), but it causes an type error. how to define such a function?
04:20:12 * hackagebot hakyll 4.6.4.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.6.4.0 (JasperVanDerJeugt)
04:21:40 <ski> SrPx : any response ?
04:23:06 <ski> tappaa : perhaps you really intended `apply :: Object -> (forall a. C a => H a -> b) -> b' (which, unCPSified, would correspond to `extract :: Object -> exists a. C a *> H a') ?
04:24:48 <ocharles> ski: was *> a typo for =>?
04:25:00 <ski> presumably you want an operation that lets you access the contents of type `H a' (where `a' here must actually be either `P' or `Q') in an `Object', knowing only that `a' is some type about which you know nothing except `C a'
04:25:01 <ocharles> or are you just inventing syntax for constraint capture?
04:25:08 <ski> ocharles : no
04:25:56 <ski> `*>' is to `(,)' as `=>' is to `->'
04:26:06 <ocharles> ah ok, I haven't seen anyone write that before
04:26:27 * ski has been using that syntax figuratively in here for years, to talk about stuff like this
04:26:36 <ocharles> i see :)
04:27:15 <ski> (i don't care that much about the particular concrete syntax, i just need some way to talk about it)
04:27:21 <ocharles> sure
04:27:25 <int-e> aisqwe: it's just a comment. I guess the code said  Char.isSpace  at some point and somebody called partain commented it out. I can't verify this.
04:28:55 <ski> hmm ..
04:28:57 <tappaa> ski : yes!! it resolve my problem! thanks a lot!
04:29:24 <ski> i wonder if you can have `SomeClass :: SomeType -> Constraint' ..
04:30:10 <ocharles> ski: Constraint isn't the right kind for that, so that seems like a small problem
04:30:42 <ski> tappaa : it would also be possible to have `apply :: Object -> (forall a. Either (Equal a P) (Equal a Q) -> H a -> b) -> b', e.g.
04:31:08 <ski> perhaps it should say
04:31:11 <ski>   SomeClass :: 'SomeType -> Constraint
04:31:17 <ski> or whatever the syntax would be
04:31:34 <ocharles> I meant that Constraint is the wrong kind to be returned from a function
04:31:45 <ocharles> wait, ignore
04:31:47 <ocharles> me*
04:31:56 <ocharles> Constraint is a kind, but you're presumably talking about a type
04:32:01 <ski> `SomeClass' would be a class that (at least seemingly) classifies values rather than types
04:34:29 <ski> (just like we can have stuff like `data Tag = TP | TQ; data Object :: Tag -> * where A :: HP -> Object TP; B :: HQ -> Object TQ')
04:39:25 <adamse> in emacs haskell-mode is there some way of running a executable specified in the .cabal file?
04:44:41 <int-e> aisqwe: Apparently the code never said Char.isSpace at all. That comment has been in the definition of 'words' since 1996. Apparently it was added while refactoring the library to conform with Haskell 1.3.
04:55:25 <mpickering> If I defined data R = R { unR :: Int } then how can I stop GHC warning about unused unR if I don't export R nor use unR?
05:11:32 <ski> mpickering : hm .. perhaps `-fno-warn-unused-binds' ?
05:11:45 <bitonic> mpickering: add a `_dummy = unR' to your module
05:23:46 <deni> when installing ghc-mod in a sandbox why is it automatically selecing an ancient version (0.3.0)?
05:25:15 * hackagebot derive 2.5.19 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.5.19 (NeilMitchell)
05:45:17 * hackagebot binary-bits 0.4 - Bit parsing/writing on top of binary.  http://hackage.haskell.org/package/binary-bits-0.4 (LennartKolmodin)
06:14:39 <bennofs> deni: probably because you have packages in your sandbox such that installing a newer version would cause you to have an inconsistent (like multiple versions of the same package) package set
06:17:46 <deni> bennofs: how come when i force the package version then everything installs fine?
06:18:29 <bennofs> deni: oh hmm. Did forcing the package version cause reinstalls?
06:19:12 <deni> bennofs: I don't have the history any more...not sure if it did...didn't prompt me for anything
06:19:31 <deni> bennofs: i just did cabal install ghc-mod==5.2.1.2 and it finished
06:20:18 * hackagebot extra 1.0.1 - Extra functions I use.  http://hackage.haskell.org/package/extra-1.0.1 (NeilMitchell)
06:20:20 * hackagebot vinyl-utils 0.1.0.0 - Utilities for vinyl  http://hackage.haskell.org/package/vinyl-utils-0.1.0.0 (mjmrotek)
06:21:31 <bennofs> deni: ok, then idk why :)
06:22:20 <deni> bennofs: tnx anyway :)
06:26:15 <poi_> :t {..}
06:26:16 <lambdabot> parse error on input ‘{’
06:27:13 <deni> does anyone use oh-my-zsh and the cabal plugin? does higlighting a sandbox fail for you or am i the only one?
06:29:16 <poi_> I know [1..8] but I don't undestand {..}
06:29:55 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#record-wildcards
06:32:13 <srhb> poi_: In what context did you see that?
06:36:15 <deni> poi_: srhb probably RecordWildCards
06:36:28 <tasker> When is it appropriate to use -fflvm ?
06:36:39 <srhb> Yeah, I was just wondering where it was used without mentioning the extension.
06:37:56 <deni> srhb: that took me a long time to find when i initially stumbled upon it. was mostly used with some json examples.
06:38:06 <srhb> Aha.
06:39:59 <poi_> tanks geeks....
06:43:44 <poi_> srhb: Today i see source of threadscope in there, some where used {..} . now i ok
06:45:47 <chpatrick1> http://lpaste.net/118127
06:45:52 <chpatrick1> any idea if this already exists?
06:50:19 * hackagebot hlint 1.9.16 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.9.16 (NeilMitchell)
06:52:19 <mpickering> Is there a Control.IxMonad with utility functions?
06:56:37 <lisbeth> so when I type "hello"
06:56:57 <lisbeth> that roughly expands to ['h','e','l','l','o',]
06:57:17 <lisbeth> which expands to 'h':'e':'l':'l':'o'
06:57:22 <geekosaur> almost
06:57:24 <lisbeth> isn't that correct?
06:57:26 <chpatrick1> :[]
06:57:38 <geekosaur> as chpatrick1 just said there is a :[] at the end
06:57:40 <lisbeth> ok so my question is
06:57:54 <lisbeth> is there a command to take an expression in haskell and see what it expands to?
06:57:58 <lisbeth> at it's fullest?
06:59:06 <lisbeth> I feel like that would be really useful for understanding the smaller details in haskell logic
06:59:14 <maukem> no, because the "expansion" is theoretical
06:59:26 <maukem> i.e. it's in the spec, but not necessarily implemented that way
06:59:43 <lisbeth> there must be a logic behind it though which can be repeated
07:00:00 <lisbeth> for example x `mod`y expands to a function with x and y in it
07:00:09 <maukem> huh?
07:00:15 <lisbeth> mod is a function
07:00:42 <lisbeth> so if you recursively printed the `mod` function showing all the steps it took to preform it using x an dy
07:00:50 <lisbeth> then you could understand exactly what it is doing
07:01:11 <geekosaur> -ddump-ds parameter to ghc might be interesting
07:01:51 <geekosaur> but, if you are looking for the output of things like inlining and rule firings, you will be unhappy because those do not happen at the level of haskell code, but ghc core
07:02:06 <lisbeth> oh I see what you mean
07:02:25 <lisbeth> I guess for my idea you would have to write a program that expands it on a theoretical level
07:02:36 <lisbeth> and not actually by compiling it
07:02:39 <maukem> wasn't there someone working on it?
07:02:44 <maukem> step by step evaluation
07:03:14 <danilo2_> Hello! In lenses we've got "makeClassy" which generates a type class to access a field of a partoicular type. Is there anything like makeClassyM, which will create type class which allows us to access the field in a monad? for example it would generate type class method "getFoo" which could be implemented for any monad like State
07:03:33 <geekosaur> there have been several implementations of that, one of which is in ghci (:trace)
07:03:42 <matematikaadit> > foldr (⊕) 0 [1..10]
07:03:44 <lambdabot>  Ambiguous occurrence ‘foldr’
07:03:44 <lambdabot>  It could refer to either ‘GHC.Base.foldr’,
07:03:44 <lambdabot>                           imported from ‘Data.List’ at L.hs:102:1-16
07:04:03 <geekosaur> hat (obsolete), hood, ghood, otherrs more recent that I can never remember
07:04:09 <matematikaadit> > Data.List.foldr (⊕) 0 [1..10]
07:04:10 <lambdabot>  1 ⊕ (2 ⊕ (3 ⊕ (4 ⊕ (5 ⊕ (6 ⊕ (7 ⊕ (8 ⊕ (9 ⊕ (10 ⊕ 0)))))))))
07:04:22 <maukem> > foldr (⊕) 0 [1..10]
07:04:23 <lambdabot>  1 ⊕ (2 ⊕ (3 ⊕ (4 ⊕ (5 ⊕ (6 ⊕ (7 ⊕ (8 ⊕ (9 ⊕ (10 ⊕ 0)))))))))
07:04:51 <lisbeth> maukem what is that symbol?
07:05:06 <maukem> https://dl.dropboxusercontent.com/u/41152078/unicode.html?q=%E2%8A%95
07:05:32 <matematikaadit> > foldl (⊕) 0 [1..10]
07:05:33 <lambdabot>  (((((((((0 ⊕ 1) ⊕ 2) ⊕ 3) ⊕ 4) ⊕ 5) ⊕ 6) ⊕ 7) ⊕ 8) ⊕ 9) ⊕ 10
07:05:52 <geekosaur> yes, the simple-reflect package too (which is what ghci is using there)
07:06:57 <maukem> https://dl.dropboxusercontent.com/u/41152078/unicode.html?q=circled <- fun :-)
07:08:37 <gcganley> @pl (\(x,y,z) -> x == y && x == z)
07:08:37 <lambdabot> (line 1, column 8):
07:08:37 <lambdabot> unexpected "z"
07:08:37 <lambdabot> ambiguous use of a non associative operator
07:08:54 <maukem> no triples allowed
07:09:00 <gcganley> damn
07:09:18 <gcganley> @pl (\(x,y) -> x == y)
07:09:19 <lambdabot> uncurry (==)
07:09:22 <maukem> you can't pointlessly destruct arbitrary values
07:09:34 <maukem> pairs happen to work because lambdabot rewrites to fst/snd first
07:16:34 <lisbeth> so I am considering using piping in bash to connect haskell programs
07:16:43 <lisbeth> using this format: shopt -s dotglob;  printf '%s\0' * | otherprogram
07:17:26 <lisbeth> and my question is, is it safe to take nullbyte delimited strings and turn them into haskell?
07:17:44 <ocharles> kosmikus, edsko: Does anything in generics-sop give me a product of lifted functions corresponding to each constructor of a data type?
07:18:14 <srenatus> lisbeth: how about "find . -print0" or something? feels more robust than relying on shell expansion (but I could be wrong)
07:18:21 <edsko> ocharles: yes
07:18:33 <ocharles> For context, I'm trying to build something that forces the user to build a parser for every constructor in a data type, but I can't really generically construct those functions. I was hoping that I could build a product of constructor functions, and with parametricity force the user to apply that function
07:18:42 <edsko> yup, absolutely
07:19:04 <srenatus> lisbeth: I don't see why you shouldn't be able to make sense of that input in a haskell program... you'd just read from stdin and split at the \0s?
07:19:17 <edsko> ocharles: just trying to find the definition, hold on
07:19:21 * edsko forgot what he called it
07:19:53 <lisbeth> is that what it is called is \0 in a string?
07:20:46 <edsko> ocharles: I think what you're looking for it http://hackage.haskell.org/package/generics-sop-0.1.1/docs/Generics-SOP.html#v:injections
07:22:06 <tdammers> lisbeth: \0 is treated specially in C when strings are concerned, but most other languages represent strings in a safer way
07:22:40 <tdammers> \0 is perfectly safe to have in a Haskell string (although actually, I would argue that ByteString would be a more appropriate type for reading from stdin)
07:23:15 <matematikaadit> > '\0'
07:23:16 <lambdabot>  '\NUL'
07:24:15 <kosmikus> ocharles, edsko: yes, injections should be it; I think I should add an example to the documentation there, though.
07:24:49 <edsko> kosmikus, ocharles : yes, maybe. generics-json is a "full" example that makes essential use of injections
07:25:02 <edsko> but of course not useful as documentation per se :)
07:25:02 <lisbeth> the main thing is I am considering replacing bash with a haskell shell as my shell and environment
07:25:17 <edsko> ocharles: it's described in the paper, too
07:25:25 <edsko> with a simpler example, I believe
07:25:55 <kosmikus> yes, I was going to suggest generics-json or the paper; most generic "builders" will use injections
07:26:07 <edsko> aye
07:27:42 <chpatrick1> @pl \fm -> FreeState $ StateT $ \s -> wrap $ AndState (fmap (\(FreeState (StateT fs)) -> fs s) fm)
07:27:42 <lambdabot> (line 1, column 70):
07:27:42 <lambdabot> unexpected "("
07:27:42 <lambdabot> expecting operator or ")"
07:28:18 <chpatrick1> @pl \fm = FreeState $ StateT $ \s -> wrap $ AndState (fmap (\(FreeState (StateT fs)) -> fs s) fm) s
07:28:18 <lambdabot> (line 1, column 5):
07:28:18 <lambdabot> unexpected "="
07:28:18 <lambdabot> expecting operator, pattern or "->"
07:28:22 <chpatrick1> fff
07:28:27 <chpatrick1> @pl \fm -> FreeState $ StateT $ \s -> wrap $ AndState (fmap (\(FreeState (StateT fs)) -> fs s) fm) s
07:28:27 <lambdabot> (line 1, column 70):
07:28:27 <lambdabot> unexpected "("
07:28:27 <lambdabot> expecting operator or ")"
07:29:46 <adamse> Qfwfq: can I ask some taggy-lens questions?
07:30:21 <chpatrick1> @pl \fm -> FreeState $ StateT $ \s -> wrap $ AndState (fmap (\fs -> runStateT (runFreeState (fs)) s) fm) s
07:30:21 <lambdabot> FreeState . StateT . (wrap .) . join . (AndState .) . flip (fmap . flip (runStateT . runFreeState))
07:32:48 <ocharles> kosmikus, edsko: thanks! internet died but I just got those messages :)
07:33:21 <ocharles> I did see injections in the paper, but haven't quite figured out how to use it - i'll muse over it some more
07:38:05 <kosmikus> ocharles: it essentially gives you [Z, S Z, S (S Z), ...] as an NP, where each of the "numbers" is a constructor for the NS, encoding a constructor of the original datatype
07:38:33 <ocharles> and by a constructor, we are talking about a  a -.-> b  lifted function?
07:38:50 <ocharles> is b ~ NP - a product of each value in the respective constructor?
07:42:34 <ocharles> kosmikus: ohhh, I think I see now. injections is a product, so therefore each element is indexed by all the fields of that constructor - it's up to me to choose what functor I want.
08:16:22 <lisbeth> can anyone help me actually get this running in a terminal: https://github.com/chrisdone/hell
08:16:37 <lisbeth> I am confused as to what file I actually need to execute
08:17:40 <maukem> 'hell', presumably
08:17:45 <maukem> https://github.com/chrisdone/hell/blob/master/hell.cabal#L47
08:18:55 <lisbeth> oh I guess I need to learn cabal
08:20:59 <lisbeth> so I would just do "cabal install hell"?
08:21:24 <srhb> lisbeth: If you download from github, just sit in the hell directory and do cabal install
08:21:36 <srhb> If you're grabbing it from Hackage, cabal install hell
08:21:45 <lisbeth> ok I'll do the latter
08:22:04 <lisbeth> do you know the packagename for cabal in ubuntu if it is not just "cabal"
08:22:14 <srhb> lisbeth: cabal or cabal install?
08:22:42 <srhb> lisbeth: You're probably thinking of the command line tool, which is cabal-install
08:22:46 <srhb> And its package name is the same.
08:22:51 <lisbeth> thank you
08:23:14 <srhb> (Cabal is a Haskell library)
08:23:35 <srhb> Hence the super confusing naming.
08:24:26 <lisbeth> wow this is so easy. Probably even easier than apt
08:24:45 <srhb> lisbeth: Sadly no. Cabal-install is not a package manager, only a package installer.
08:25:37 <lisbeth> eh it says I have some dependency issues
08:25:48 <srhb> lisbeth: Funtimes, paste them.
08:26:50 <lisbeth> http://lpaste.net/118136
08:27:56 <lisbeth> is ubuntu stable too old for it?
08:30:20 <srhb> It.. Might be. I'm not actually sure about that conflict. It seems like you might be able to fix it by grabbing a newer version of time
08:30:57 <lisbeth> is that a linux package or a haskell package?
08:31:09 <srhb> Haskell
08:31:13 <lisbeth> oh
08:31:22 <lisbeth> well I don't have any haskell packages installed so that may be why lol
08:31:33 <lisbeth> I guess I assumed cabal would resolve dependencies
08:32:39 <maukem> you do have time installed
08:32:45 <lisbeth> I just installed it hold on
08:32:51 <lisbeth> I am trying to install all of the dependencies
08:33:08 <maukem> the problem is that pdfinfo requires an older time than what you had
08:33:42 <lisbeth> eh I am pretty sure I didn't have time installed
08:33:44 <lisbeth> but I could be wrong
08:35:07 <lisbeth> here is my most up-to-date predicamnet: http://lpaste.net/118137
08:35:43 <maukem> looks like you have multiple mtl versions now
08:36:06 <maukem> and still the same problem with time
08:37:07 <lisbeth> dernit
08:37:22 <lisbeth> this doesn't seem very intuitive
08:37:33 <lisbeth> i think I will try the thign you said before and run cabal on the folder
08:41:01 <lisbeth> is it going to conflict because I have different versions of haskell programs installed?
08:41:13 <lisbeth> or does it just pick the most appropriate version?
08:45:28 * hackagebot ekg-rrd 0.2.1.69 - Passes ekg statistics to rrdtool  http://hackage.haskell.org/package/ekg-rrd-0.2.1.69 (dcturner)
08:52:51 <srhb> lisbeth: Try this: cabal unpack hell && cd hell-* ^^En genoptrykning ville være en reaktion, der igen kan skabe en reaktion fra fundamentalister. At lade verden gå sin gang og på et tidspunkt trykke noget, der måske kan støde nogen, hvis det ellers giver mening i situationen, er ægte journalistisk frihed, men ikke en hævnakt.
08:52:54 <srhb> Woops
08:52:58 <srhb> Random paste mistake
08:53:11 <srhb> lisbeth: cabal unpack hell, cd hell-*, cabal sandbox init, cabal install
08:54:55 <lisbeth> srhb I will try that next but let me show you guys this first and see if we are on the same page: http://lpaste.net/118140
08:55:41 <srhb> lisbeth: Yeah, try cabal sandbox init in git/hell and then cabal install
08:55:41 <lisbeth> also sandbox is unrecognized
08:55:48 <srhb> Oh, your cabal version is old then
08:55:52 <srhb> cabal install cabal-install
08:55:57 <lisbeth> oh good idea
08:57:15 <lisbeth> seems to me like cabal is both a blessing and a curse to the haskell world
08:57:48 <geekosaur> mostly ghc's library handling is the curse; cabal tries to soften it, not always successfully
08:58:05 <geekosaur> but it is a time-honored tradition to always blame the messenger
08:58:06 <srhb> Indeed, there's no easy solution.
08:58:28 <lisbeth> excuse me cause I am still new but by library handling are you refering to modules?
08:58:58 <srhb> Package versions in general, actually.
08:59:33 <lisbeth> it seems to me that what a "package" is or rather has the potential to be is rather different than what a "library" is
08:59:49 <lisbeth> there are an infinite number of ways one could "package" a haskell program
09:00:21 <EvanR-work> most packages arent full programs but the library
09:01:01 <EvanR-work> theres an infinite number of ways you could package a library ;)
09:01:12 <lisbeth> doing cabal install cabal-install failed
09:01:45 <srhb> lisbeth: How?
09:01:48 <lisbeth> hold on
09:02:38 <lisbeth> http://lpaste.net/118142
09:04:02 <srhb> lisbeth: zlib might requre an external dependecy
09:04:41 <lisbeth> so cabal install zlib and see what happens?
09:05:17 <srhb> lisbeth: No, not Haskell, C. So you should install zlib in Ubuntu. If that's what it's called
09:05:41 <srhb> zlib1g-dev probably
09:06:17 <lisbeth> if this gets much worse I am just going to work inside of docker instead of on my own machine
09:07:05 <lisbeth> what about zlib1g-dbg?
09:07:19 <lisbeth> oh nvm I found dev
09:07:33 <srhb> lisbeth: It's actually not terrible as long as you stick to using sandboxes always.
09:07:39 <lisbeth> sorry to bother you guys so much. Thank you for your time
09:07:43 <srhb> lisbeth: I find no need to use docker etc.
09:07:47 <srhb> lisbeth: No problem. :)
09:07:52 <lisbeth> I think what I will do is have a docker instance of nixos
09:08:07 <lisbeth> cause nixos seems more compatible with having multiple versions of filesystem structures
09:08:11 <EvanR-work> ive heard of sandboxes
09:08:15 <EvanR-work> usually people complaining
09:08:19 <EvanR-work> should i be using them? ;0
09:08:33 <lachenmayer> sandboxes are great
09:08:45 <srhb> EvanR-work: I think so. :-)
09:09:03 <srhb> Fucking up a sandbox is much nicer than fucking up ~/.ghc and ~/.cabal
09:09:08 <lisbeth> so do you think I should now  do "cabal install zlib" or do you think I should go straight to "cabal install cabal-install" ?
09:09:14 <lachenmayer> though you do have to make sure that your global packages don't conflict with the sandbox ones
09:09:14 <srhb> lisbeth: The latter
09:09:38 <lisbeth> cross your fingers ladies and gents
09:10:09 <lisbeth> yeah immediately after I get hell working I am going to set up some docker instances for this
09:10:32 <lisbeth> probably in arch or debian sid
09:11:25 <srhb> lisbeth: Full disclosure: Hell does not compile in unmodified form for me. :)
09:12:17 <lisbeth> srhb noted
09:12:29 <srhb> Or rather, shell-conduit does not.
09:12:31 <lisbeth> sorry guys this is a big one but that was just for full reference. Feel free to start at the bottom. http://lpaste.net/118144
09:13:12 <srhb> lisbeth: Looks fine so far?
09:13:22 <lisbeth> oh
09:13:26 <lisbeth> If forgot the last line
09:13:36 <lisbeth> cabal: unrecognised command: sandbox (try --help)
09:13:36 <lisbeth> lisbeth@beast:~/git/hell/hell-2.1$
09:14:03 <srhb> lisbeth: Your $PATH is pointing to the wrong cabal command
09:14:17 <srhb> lisbeth: The new one should be in ~/.cabal/bin
09:14:18 <lisbeth> good thinking
09:15:42 <lisbeth> what distro would you guys recommend for haskell development using cabal?
09:15:48 <lisbeth> in terms of maximum compatibility?
09:16:32 <doctorin1> Is there a library for working with absolute time? Data.Time.Clock has DiffTime, but no way to do UTCTime -> UTCTime -> DiffTime.
09:17:03 <S11001001> I'd like to install transformers 0.4, but [my build of] ghc came with transformers 0.3.  What incantation of cabal install should I use?  Or will this yield a broken install anyhow?
09:17:47 <srhb> lisbeth: I don't really care about the distro. As long as I have my sandboxes. What you might care about is the latest ghc version unless you're fine installing the binary distribution (which I've done)
09:17:54 <lisbeth> so I just add the directory to my path or do I have to tell path that that command goes to that specific package?
09:18:50 <srhb> lisbeth: If that directory is in the front of the $PATH variable, binaries therein will be prioritized over later entries.
09:20:14 <srhb> S11001001: Ie. the difference between those two UTCTimes?
09:20:29 * hackagebot text-regex-replace 0.1.0.0 - Easy replacement when using text-icu regexes.  http://hackage.haskell.org/package/text-regex-replace-0.1.0.0 (EricRochester)
09:20:53 <S11001001> redirect doctorin1
09:21:06 <srhb> Sorry
09:21:12 <srhb> doctorin1: Ie. the difference between those two UTCTimes?
09:21:49 <ab9rf> @hoogle UTCTime -> UTCTime -> a
09:21:50 <lambdabot> Prelude asTypeOf :: a -> a -> a
09:21:50 <lambdabot> Data.Time.Clock diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime
09:21:50 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
09:21:53 <srhb> S11001001: I don't remember if transformers is fixed with ghc version. I don't think so. If you do cabal install transformers, worst case is you will have to nuke ~/.ghc to get back to a working state
09:22:00 <ab9rf> diffUTCTime doesn't do what you want?
09:23:13 <ab9rf> i admit having no idea what the difference between a NominalDiffTime and a DiffTime is
09:23:13 <doctorin1> srhb: say I'd want to call a function exactly every x seconds, you need to be able to add absolute lengths in time to UTCTime or something similar to make that happen
09:23:33 <srhb> doctorin1: addUTCTime?
09:23:36 <srhb> @hoogle addUTCTime
09:23:36 <lambdabot> Data.Time.Clock addUTCTime :: NominalDiffTime -> UTCTime -> UTCTime
09:23:49 <Taneb> ab9rf, in principle DiffTime includes leap seconds
09:23:50 <doctorin1> ab9rf: nominal time is say 'one day', but one day isn't always 24*60*60 seconds, it might differ due to leap seconds
09:23:58 <doctorin1> srhb: nope
09:24:13 <srhb> If you want leap seconds you may have to roll your own.
09:24:23 <srhb> Ie. if you want addUTCTime :: DiffTime -> UTCTime -> UTCTime
09:24:24 <ab9rf> Taneb: so NominalDiffTime allows you to say "3 months" and get the erxpected behavior?
09:24:27 <Taneb> However that can be impossible without IO (they might announce leap seconds after the program was executed)
09:24:37 <srhb> True.
09:24:42 <Taneb> So NominalDiffTime does not include leap seconds
09:24:54 <Taneb> ab9rf, I think so
09:24:55 <ab9rf> leap seconds were a mistake
09:24:55 <doctorin1> ab9rf: when you want to work with human-relevant dates you usually use nominal time
09:25:00 <ab9rf> there will be no more leap seaconds
09:25:02 <ab9rf> seconds
09:25:13 <srhb> ab9rf: Huh?
09:25:16 <S11001001> srhb: thanks
09:25:24 <ab9rf> they announced about a year ago that there will be no more leap seconds
09:25:30 <doctorin1> I'm implementing a seconds counter for a game, which needs some sort of absolute time to be correct
09:25:49 <doctorin1> but I'll just ignore leap seconds if there's no ready made solution
09:25:53 <srhb> doctorin1: NominalDiffTime should surely suffice for that.
09:25:56 <doctorin1> only a school assignment after all
09:26:01 <doctorin1> srhb: yep :)
09:26:03 <ab9rf> for a game i'm sure nominal difftime is adquaite
09:26:06 <srhb> doctorin1: As Taneb stated, you cannot possibly know when leap seconds will be added in advance.
09:26:22 <ab9rf> srhb: you do now, as all leap seconds that will ever occur have already occurred.
09:26:24 <srhb> doctorin1: You have to ask some time service whether a leap second has been announced at any given time.
09:26:30 <ttuegel> ab9rf: they announced last year there would be no more leap seconds, and announced this week there will be one on june 30, 2015 :/
09:26:32 <srhb> ab9rf: Huh, what?
09:26:44 <ab9rf> ttuegel: i guess they changed their mind?  shrug, i dunno.
09:26:49 <ttuegel> ab9rf: apparently
09:27:07 <ttuegel> you would think a time keeping service would want to have a reputation for trustworthiness
09:27:33 <geekosaur> the problem is, it hs to keep time for multiple uses and it's juggling the needs of multiple users
09:27:58 <ttuegel> geekosaur: who are those multiple users?
09:27:59 <ab9rf> they were a stupid idea
09:28:17 <geekosaur> atronomy, computer time sync, ...
09:28:29 <ttuegel> astronomy doesn't observe leap seconds
09:28:35 <ttuegel> they have their own time system
09:28:54 <ab9rf> it's civil authorities that seem to care about clock times corresponding to sun position
09:29:10 <hodapp> ttuegel: Star date?
09:29:22 <ttuegel> hodapp: nah, just UTC from before leap seconds
09:29:24 <ttuegel> iirc
09:29:33 <hodapp> hmmmm
09:29:37 <ab9rf> the astronomical star epoch is defined as seconds since an epoch date
09:29:42 <ab9rf> leap seconds don't matter for that purpose
09:29:59 <ab9rf> although they do for converting an epoch time to a civil time
09:30:10 <srhb> lisbeth: For the record, I succeeded by using the git version of shell-conduit
09:30:32 <srhb> lisbeth: it git clone shell-conduit, cd hell-2.1, cabal sandbox add-source ../shell-conduit, cabal install
09:30:35 <srhb> ie*
09:30:54 <srhb> (Of course, you need to grab the actual URL)
09:30:55 <ab9rf> there is an agenda item on WRC-15 that moves to abolish leap seconds
09:31:21 <ab9rf> but that won't be held until february 27
09:31:30 <lisbeth> srhb I am still figuring out how to edit my path
09:31:33 <lisbeth> so one step at a time
09:31:37 <ab9rf> if WRC-15 votes to abolish leap seconds, the fate of the june 2015 leap second may be uncertain
09:32:43 <ab9rf> oh, wait, i misread, that won't happen until november
09:32:45 <srhb> lisbeth: PATH = "$HOME/.cabal/bin:$PATH" in some file that is loaded by your shell
09:33:18 <lisbeth> and I don't need to put in my full existing path?
09:33:21 <lisbeth> just that line?
09:33:24 <maukem> without spaces
09:33:29 <srhb> lisbeth: That's what $PATH is
09:33:32 <srhb> Oh right, no spaces
09:33:58 <ab9rf> the april 2014 recommendation from the IAU working group on UTC recommended abolishing leap seconds
09:34:05 <ab9rf> but that recommendation has not been acted upon
09:34:17 <ab9rf> the ITU first needs to redefine "day"
09:35:20 <ab9rf> because at the moment "one day" is defined by the rotation of the earth, rather than a fixed number of seconds
09:35:59 <Javran> is there a canonical gitignore file for shake? or I guess simply put _build and _shake on the ignore list will be fine?
09:36:04 <ab9rf> such redefinition has been proposed in revisions to the relevant standards but those recommendations have not yet been adopted :)
09:36:24 <barrucadu> But if "day" is redefined to be a fixed number of seconds, then it'll gradually drift, I don't see how that solves the same problem as leap seconds
09:36:36 <ab9rf> in part because a number of internatnaional agreements depend on the defintion of a day as a single rotation of the earth
09:36:45 <ab9rf> barrucadu: yes, it will.
09:36:56 <ab9rf> barrucadu: but at a rate slow enough as to not matter for a very long time
09:37:27 <barrucadu> So rather than pre-emptively solving the problem, which is what leap seconds are for, the decision is to just ignore the problem until the future?
09:38:01 <ab9rf> barrucadu: what will probably happen is that there will be civil adjustments on a larger scale (e.g. "adjustment hours") done at century scale
09:38:17 <srhb> Or people might just not care about the drift.
09:38:28 <ab9rf> there's onlyt been 25 leap seconds in the 43 years they'vbe existed
09:38:32 <lisbeth> ok none of this seems to be going anywhere so I am taking a break. Later guys and thanks for your help
09:38:55 <ab9rf> at that rate, the accumulktaed error is 10 minutes per MILLENIUM
09:39:02 <barrucadu> I guess the drift is slow enough such that it won't effect individual people, unless the human lifespan increases massively
09:39:13 <SharpGAF> But why accept any errors?
09:39:23 <ab9rf> it's about two hours over the entire history of man
09:39:40 <SharpGAF> The history of man isn't actually that long compared to many computations you do
09:39:45 <SharpGAF> This is a common fallacy when talking about time.
09:40:10 <ab9rf> SharpGAF: and for such computations you just use raw seconds
09:40:21 <ab9rf> leap seconds only come into play when you try to convert a raw time into a civil time
09:40:21 <SharpGAF> ab9rf: Currently, sure
09:40:38 <ab9rf> a raw time is an absolute number of seconds sionce an epoch date
09:40:47 <ab9rf> leap seconds just mean that some years are longer than others
09:41:05 <ab9rf> they make converting epoch times into civil times more difficult, even more so because they're not predictable.
09:41:44 <SharpGAF> Well, it's much more difficult if people continue to assume that nobody wants to write programs that deal with extremely distant dates (civil dates).
09:42:05 <ab9rf> you cannot compute the exact epoch time of a future civil time beyond the next possible leap second insertion point because the authorities could determine that a leap seconds is to be inserted after today, but ebfore that future time
09:42:14 <SharpGAF> Sure, you can't predict the future.
09:42:35 <EvanR-work> leap seconds :(
09:43:06 <SharpGAF> For that matter, there have been much larger calendar system changes than that in the past and there probably will be at least one more in the future.
09:43:24 * EvanR-work looks at his lunar calendar
09:43:40 <SharpGAF> That still isn't a reason to throw up your hands and say "well, the system can't be perfect so we shouldn't even try" though.
09:43:43 <ab9rf> lepa seconds will likely be abolished within the next few years
09:44:00 <ab9rf> SharpGAF: leap seconds make the system less perfect
09:44:11 <ab9rf> it's not like solar noon occurs at civil noon anyway
09:44:29 <SharpGAF> ab9rf: No, but I think it's unrealistic to expect that a future society will have a notion of a day that isn't tied to the solar day.
09:45:15 <EvanR-work> day counting is a perfectly valid abstract system, the silly part is to insist that it be tied to a linear time scale
09:45:25 <Forgetaboutit> what's the fixity of infix function application (e.g. `elem`)?
09:45:26 <ab9rf> SharpGAF: why? future society will likely have colonizations on mars (solar day 24 hours 39 minutes and change), the moon (solar day ~ 29 days), and in orbit (solar day not meaningful)
09:45:29 <EvanR-work> both are uniform systems in different universes
09:45:30 * hackagebot binary-bits 0.5 - Bit parsing/writing on top of binary.  http://hackage.haskell.org/package/binary-bits-0.5 (LennartKolmodin)
09:45:43 <glguy> Forgetaboutit: Type this into your GHCI:   :i `elem`
09:46:08 <SharpGAF> ab9rf: I think it is *quite* unlikely that we will have significant colonizations on either Mars or the moon, but that's a separate topic that I don't really want to go into right now.
09:46:22 <maukem> Forgetaboutit: same as operators
09:46:32 <Forgetaboutit> glguy: Ahhh, thank you!  I couldn't figure out how to make GHCI output the fixity
09:47:34 <SharpGAF> Indeed, if you assume that humans will not be Earthbound, it makes more sense to consider some other daylike unit and keep the current notion of days as a timezone-like thing.
09:47:39 <Forgetaboutit> And just to be sure: higher fixity means tighter binding, right?
09:47:46 <SharpGAF> Anyway, sorry for the off topicness.
09:47:49 <Iceland_jack> Forgetaboutit: Yes
09:48:11 <Iceland_jack> Forgetaboutit: If you ever forget, compare ':i (+)' and ':i (*)'
09:48:24 <Iceland_jack>     infixl 6 +
09:48:24 <Iceland_jack>     infixl 7 *
09:48:43 <Iceland_jack> And you know (*) binds tighter since:
09:48:43 <Iceland_jack>       a + b * c
09:48:43 <Iceland_jack>     = a + (b * c)
09:49:12 <Forgetaboutit> Iceland_jack: neat, thank you!
09:55:31 * hackagebot hashtables 1.2.0.2 - Mutable hash tables in the ST monad  http://hackage.haskell.org/package/hashtables-1.2.0.2 (GregoryCollins)
10:02:20 <ski> Forgetaboutit : you can declare fixity and precedence for infixed identifiers, like e.g.
10:02:24 <ski>   infix 4 `elem`
10:02:47 <ski> i'm not sure why GHCi (here at least), with `:i elem', reports that without the backquotes
10:03:25 <znn> has anyone create forward and backward function application using with |> and <|
10:03:31 <Forgetaboutit> ski: Interesting, I didn't know that
10:03:46 <znn> http://package.elm-lang.org/packages/elm-lang/core/1.1.0/Basics#<|
10:03:54 <Iceland_jack> znn: We basically have that only with ($) and (&)
10:04:35 <Iceland_jack> But you can define them as such:
10:04:36 <Iceland_jack> > let (|>) = (&) in "hello world" |> words |> (\x -> x ++ x) |> unwords
10:04:37 <lambdabot>  "hello world hello world"
10:05:01 <Iceland_jack> Clearer indenting:
10:05:02 <Iceland_jack>        "hello world"
10:05:02 <Iceland_jack>     |> words
10:05:02 <Iceland_jack>     |> (\x -> x ++ x)
10:05:05 <Iceland_jack>     |> unwords
10:05:22 <Iceland_jack> If you want to code golf (\x -> x ++ x) one could also write 'join (++)'
10:06:22 <maukem> > (words >>> (\x -> x ++ x) >>> unwords) "hello world"
10:06:24 <lambdabot>  "hello world hello world"
10:06:56 <znn> i need to figure out how & works
10:07:07 <Iceland_jack> znn: Quite simple:
10:07:07 <Iceland_jack>     x & f = f x
10:07:22 <Iceland_jack> When you have:
10:07:23 <Iceland_jack>     "hello" & putStrLn
10:07:23 <Iceland_jack> it's the same as:
10:07:23 <Iceland_jack>     putStrLn "hello"
10:07:24 <znn> Iceland_jack: nice
10:07:37 <znn> thank you Iceland_jack
10:07:49 <ski> Forgetaboutit : if you don't declare a fixity and precedence for an operator, or an infixed identifier, then i think it behaves as if it's got `infixr 9'
10:10:25 <znn> Iceland_jack: the lambda function is helpful
10:10:46 <znn> the golf is helpful after i realize what's going on
10:11:06 <znn> > words $ "hello world"
10:11:07 <lambdabot>  ["hello","world"]
10:11:08 <Iceland_jack> Yes I usually try to make my code as clear as possible
10:12:58 <Iceland_jack> Now that I think of it I think I mentiond 'join (++)' as a form of procatalepsis because #haskell tends towards one-upmanship
10:13:09 <Iceland_jack> It's probably unwarranted.
10:14:01 <znn> > unwords $ (\x -> x ++ x) $ words $ "hello world"
10:14:03 <lambdabot>  "hello world hello world"
10:14:06 <znn> > "hello world" & words & (\x -> x ++ x) & unwords
10:14:07 <lambdabot>  "hello world hello world"
10:14:42 <ski> @wn procatalepsis
10:14:44 <lambdabot> No match for "procatalepsis".
10:15:02 <znn> whic lib is (&) located?
10:15:28 <CindyLinz> there's one in lens
10:15:42 <znn> i'm gettting this: <interactive>:12:15: Not in scope: `&'
10:15:43 <HeladoDeBrownie> you probably don't want to include lens if all you want is (&) - it's massive
10:15:50 <znn> is that the one lambdabot is using?
10:16:02 <CindyLinz> https://hackage.haskell.org/package/lens-4.7/docs/Control-Lens-Operators.html
10:16:06 <maukem> znn: yes
10:16:07 <CindyLinz> XDD
10:16:19 <znn> how long has & been around
10:16:21 <edwardk> ghc 7.10 brings in (&) in Data.Function
10:16:32 <CindyLinz> I'll define      (&) a f = f a     myself.. ^^|
10:16:48 <CindyLinz> edwardk: thank you :D
10:17:08 <znn> i.e. did f# take from it and transform the syntax into |>
10:17:25 <edwardk> znn: the f# version predates the use in lens
10:17:28 <S11001001> HeladoDeBrownie: you don't assume that lens is already in znn's deps? :)
10:17:48 <srhb> CindyLinz: Calling it syntax is a bit much. It's just an operator, at least in Haskell. I don't know about F# but I assume the same is true there.
10:17:54 <Iceland_jack> Some libraries also define '(#) = flip ($)'
10:17:57 <edwardk> lens didnt adopt |> because morphologically, |> is a pretty odd syntax in the ecosystem of haskell.
10:18:01 <Iceland_jack> (and languages)
10:18:17 <znn> why?
10:18:31 <edwardk> Lens likes to use operator= and <operator= for various things
10:18:34 <znn> haskell has <|> right?
10:18:38 <edwardk> so what does <|>= read to you as?
10:18:43 <CindyLinz> srhb: ?? I've never wrote F#
10:18:59 <maukem> mistab, probably
10:19:02 <Iceland_jack> edwardk: I'm interested that you say that, people I've talked to find (|>) more intuitive since it is reminiscent of piping
10:19:03 <znn> edwardk: honestly i don't know
10:19:05 <srhb> CindyLinz: Urgh, I keep mistabbing, sorry. That was for znn
10:19:12 <CindyLinz> ^^|
10:19:32 <edwardk> We have (<|>) but its completely unrelated to that (|>). also we tend to use (|>) in other contexts for snoc-like operations, with an associated (<|)
10:19:44 <edwardk> so its already syntax we're using with other connotations elsewhere
10:20:01 <ski> iirc, in O'Caml, the first character of the operator determines fixity and precedence (or was it only one of them ?) .. perhaps likewise in F# ?
10:20:08 <znn> http://hackage.haskell.org/package/base-4.7.0.2/docs/Control-Applicative.html#v:-60--124--62-
10:20:38 <edwardk> (&) and (|) have some associations for folks, but (|) is taken by syntax, so that connotation isn't available, so we don't have to worry about the and/or usecase. and 'x & f & g'   can be read as 'x and then f and then g...'
10:20:45 <edwardk> the and gives some hint as to how to read it
10:20:56 <edwardk> (|>) is symbolic noise
10:21:09 <edwardk> so I picked a symbol that was otherwise dormant, and lighter weight to use in lens.
10:21:16 <hodapp> hmm, if I have a -> a -> a -> ... -> m b, is there any notation - besides 'do' - that would let me take several 'm a' and bind them in order?
10:21:31 <shachaf> edwardk: That reading would make a lot more sense if (&) was composition.
10:21:47 <edwardk> shachaf: perhaps
10:21:48 <hodapp> I'm tripped up trying to do it with >>= or =<< but perhaps it's doable
10:22:22 <edwardk> hodapp: you can always do a join after building up the whole applicative chain
10:22:30 <hodapp> join?
10:22:41 <edwardk> join $ f <$> mw <*> mx <*> my <*> mz
10:22:42 <maukem> hodapp: 'do' is just syntactic sugar for >>=
10:22:46 <shachaf> Also, I think pink polkadots would stop bikes from rusting.
10:23:06 <maukem> I don't understand how you can do it with 'do' but not >>=
10:23:18 <hodapp> maukem: it's not just syntactic sugar for >>=, it's syntactic sugar for >>= and a bunch of lambdas.
10:23:27 <maukem> yes
10:23:41 <ski> hodapp : sometimes i define `(<*>>) :: Monad m => m (a -> m b) -> (m a -> m b)' to help with that
10:24:13 <ski> hodapp : `f <$> mw <*> mx <*> my <*>> mz'
10:25:02 <CindyLinz> ski: and also (<$>>) ?
10:25:25 <ski> CindyLinz : that's just `(=<<)'
10:25:41 <CindyLinz> oh... XD
10:25:51 <hodapp> maukem: http://lpaste.net/2849520752888119296 is what I'm looking at
10:26:06 <HeladoDeBrownie> S11001001, i didn't assume that or its negation; notice the "if" part ;)
10:26:45 <maukem> hodapp: ok, what's wrong with that?
10:27:13 <CindyLinz> call_ printf7 "..." <$> deref (temp ! 5) <*> deref (temp ! 4) <*> deref (temp ! 3) <*> ...
10:27:42 <hodapp> maukem: it seems a bit silly for me to assign those in order, and then repeate the order, when pretty much the only thing I'm concerned with is the order
10:27:45 * ski takes to opportunity to complain about the name of `(<*>)' (which would be better if it was named `(<$>)', imho)
10:28:01 <johnw> ski: as Idris does, eternally confusing Haskellers?
10:28:03 <Iceland_jack> Idris changes that at least
10:28:21 <ski> johnw : what does Idris do here ?
10:28:25 <porFavor> hi there, i was wondering, how low friction is haskell on windows in terms of me just starting to code
10:28:29 <johnw> defines <$> to be what you think
10:28:35 <maukem> hodapp: then see what CindyLinz said, plus join
10:28:58 <tolt> why not `liftM (call_ printf7 "....") (deref (temp ! 0)) ...( deref (temp ! 5))
10:29:17 <maukem> tolt: because that's several type errors
10:29:17 <gganley> :t map
10:29:18 <lambdabot> (a -> b) -> [a] -> [b]
10:29:30 <HeladoDeBrownie> porFavor, okayish, from what i recall in my attempt. you can install the haskell platform and then use ghc and ghci from a command line
10:29:31 <ski> tolt : sometimes i use infix `liftM'
10:29:39 <hodapp> maukem: thought you said that just >>= should be able to do it?
10:29:45 <tolt> maukem: how?
10:29:49 <maukem> hodapp: yes, but it still makes you repeat the variables
10:29:55 <porFavor> HeladoDeBrownie: oh no command line that is beyond me. also, is haskell interpreted?
10:30:20 <maukem> hodapp: deref (temp ! 0) >>= \hh -> deref (temp ! 1) >>= \s -> deref ( ...
10:30:29 <HeladoDeBrownie> porFavor, it's actually not too hard, we can help you get started with it and you'll be fine in no time. haskell can be compiled or interpreted; both are available in the platform.
10:30:36 <ski> tolt : i assume you still have `<*>' inbetween the `(deref ...)'s ?
10:30:52 <hodapp> maukem: hmmm, I consider adding in lots of lambdas to no longer be "just" >>=
10:30:55 <tolt> Nope?
10:30:58 <tolt> :t liftM
10:30:58 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
10:31:18 <maukem> tolt: we're doing liftM6
10:31:23 <tolt> yeah.
10:31:26 <ski> porFavor : istr there's some kind of more gui GHCi interface on windows
10:31:56 <tolt> I would prefer the applicative and then join at the end but liftM is another option
10:32:03 <tolt> (even though you still have to join at the end)
10:32:10 <porFavor> ok cool i see. also questoin, how similar is haskell to somehting like scheme? they are both FP, right, but is that where the similarities end? i dont mean like syntax
10:32:36 <HeladoDeBrownie> porFavor, haskell is statically typed and non-strictly evaluated, among other major differences
10:32:48 <Iceland_jack> porFavor: Laziness/non-strictness, the type system and algebraic data type (+ pattern matching) are the most glaring differences
10:32:59 <hodapp> porFavor: they're probably about as different as Scheme is from... most other languages that are not Lisps.
10:33:08 <porFavor> oh, well static typing a good thing, so thats nice
10:33:24 <hodapp> porFavor: if you want a statically-typed Lisp, I think some folks want the same
10:33:25 <ski> porFavor : Scheme is eager, has side-effects (partiality, state, continuations, I/O, exceptions/conditions). also has macro systems and staged/meta programming
10:33:25 <HeladoDeBrownie> porFavor, for reference, some people who consider haskell fp do not consider scheme to be
10:33:31 <maukem> tolt: how would liftM help?
10:33:45 <porFavor> fucking b8ed nerds i hate haskell
10:33:47 <tolt> maukem: you would use liftM6?
10:33:52 <hodapp> ...
10:33:53 <HeladoDeBrownie> so they're different enough in many aspects for there to be differences in opinion there
10:33:58 <maukem> tolt: liftM6 doesn't exist
10:34:02 <hodapp> ummm... I guess that was trolling?
10:34:11 <lenin> hey
10:34:33 <hodapp> lenin: hey porFavor
10:34:52 <lenin> oh fuck what are you a detective
10:35:15 <porFavor> hah,
10:35:19 <lenin> hah
10:35:23 <HeladoDeBrownie> probably your host string was the same
10:35:24 <athan> Can I make ...partial functions from Hask -> Hask (if that even makes sense), such that I give a method to metaprogram on a data type, so long as the data type fits a certain specification, otherwise throw a compile time error? Can this be done with pattern matching on `Exp` values, and doing something to cause a compile-time error?
10:35:30 <HeladoDeBrownie> (i say probably because i have join/part hidden)
10:35:30 <Iceland_jack> porFavor: If you are interested, check this out http://www.cs.kent.ac.uk/people/staff/dat/miranda/wadler87.pdf
10:35:32 <hodapp> lenin, porFavor: are you here to troll, or to ask actual questions?
10:35:52 <tommd> Can we ban 38.116.192.94?
10:35:54 <athan> if that makes sense? ><
10:36:00 <lenin> i was actually gonna ask some questions
10:36:08 <lenin> are any backends writted in haskell
10:36:08 <porFavor> i was here for real, but then the comedic value overwhelmed me
10:36:27 <hodapp> Was that before or after saying "fucking b8ed nerds i hate haskell" and quitting?
10:36:29 <Iceland_jack> Yes so much comedy here
10:36:36 <porFavor> is learn you a haskell a good book? its the most popular book ive seen  but I duno. I dont have much FP or real programming experience
10:36:43 <porFavor> hodapp:
10:36:52 <johnw> porFavor: many like it
10:36:53 <Iceland_jack> It's a fine book to start with
10:37:00 <porFavor> Iceland_jack: thanks for the link
10:37:02 <Adeon> it's a good book if you have no functional programming experience
10:37:13 <Adeon> actually it's a good book anyway
10:37:32 <athan> lenin: What do you mean by "backend"?
10:37:43 <geekosaur> there are arguments over it, actually; some claim it does not do a good job of teaching how to "think Haskell"
10:37:59 <lenin> athan: like webservice backends, web apps, etc
10:38:08 <Iceland_jack> porFavor: Highlighting the differences a bit:
10:38:08 <Iceland_jack>     sum []     = 0
10:38:08 <Iceland_jack>     sum (x:xs) = x + sum xs
10:38:08 <Iceland_jack> ad:
10:38:09 <levi> If you mean web backend, then yes, there are a few libraries/frameworks written in Haskell for it.
10:38:10 <Adeon> is there a better LYAH alternative
10:38:11 <Iceland_jack>     (define (sum f xs)
10:38:14 <Iceland_jack>       (if (null? xs)
10:38:18 <Iceland_jack>           0
10:38:19 <athan> lenin: Check out scotty
10:38:19 <lenin> levi: cool
10:38:20 <athan> ad yesod
10:38:21 <Iceland_jack>           (+ (car xs) (sum (cdr xs)))))
10:38:24 <athan> and*
10:38:45 <levi> See Snap, Yesod, Happstack, Scotty, and probably a couple more that I've forgotten.
10:38:55 <johnw> scotty and yesod are at almost opposite ends of the spectrum
10:39:03 <athan> Spock now :P
10:39:11 <lenin> cool im looking at scotty now
10:39:22 <lenin> i tried ruby, and really didnt like it
10:39:24 <HeladoDeBrownie> many people are citing https://github.com/bitemyapp/learnhaskell instead of lyah, which as far as i can tell may be less objectionable
10:39:29 <porFavor> Iceland_jack: was that the haskell or the scheme
10:39:37 <lenin> looking at go now, haskell looks cool to but seems to be much higher learning curve
10:39:42 <Iceland_jack> porFavor: The first example is Haskell, the second Scheme
10:39:51 <geekosaur> sorry, I had to scan my logs and HeladoDeBrownie just beat me to it >.>
10:39:55 <maukem> Iceland_jack: more like sum = foldl (+) 0
10:40:06 <geekosaur> (also I am on a work concall and should pribably poof)
10:40:19 <Iceland_jack> <Iceland_jack> Now that I think of it I think I mentiond 'join (++)' as a form of procatalepsis because #haskell tends towards one-upmanship
10:40:20 <Javran> weird thing, I mistyped "cabal configure --bindir=<dir>" as "cabal configure -bindir=<dir>", not a single warning, but "cabal copy" will still copy binaries to the default location.
10:40:40 <maukem> Iceland_jack: no, I mean in the sense that that is how sum is actually defined
10:40:43 <porFavor> well haskell sertainly seems more concise.
10:40:43 <levi> There are also a bunch of front-end options: ghcjs and haste are proably the most mature "compile full Haskell to javascript" implementations, and then there are languages like Fay, Purescript, and Elm that are Haskell-like languages to varying degree.
10:40:44 <Iceland_jack> Yes
10:40:50 <Iceland_jack> The example is the one used by Wadler in the paper
10:40:58 <maukem> Iceland_jack: and also because in many cases we don't do manual recursion in haskell
10:41:00 <Iceland_jack> Mostly to highlight pattern matching and equational style
10:41:24 <maukem> does scheme have a similar emphasis on higher-order combinators?
10:41:31 <Iceland_jack> Yes
10:41:50 <levi> I think it depends a bit on the Schemer's style.
10:42:00 <Iceland_jack> But it depends a lot on the person
10:42:27 <maukem> (define (sum xs) (apply + xs)) ; how cromulent is this?
10:42:41 <Iceland_jack> It's harder to talk about a singular style for Common Lispers and Schemers than Haskellers
10:42:53 <levi> Being a strict language, though, you have to think a bit more (or at least a bit differently) about the correctness of composition in languages like Scheme and ML.
10:43:08 <lenin> alright guys i have math class now
10:43:13 <lenin> see you later thanks for the help
10:43:13 <EvanR-work> can you get keyword args that are required
10:43:16 <EvanR-work> like in ruby
10:43:32 <EvanR-work> oops wrong channel
10:43:48 <porFavor> lenin grade 3 must be hard
10:43:55 <maukem> yes, oleg can do that :-)
10:45:32 <levi> Iceland_jack: I dunno, there are quite a lot of Haskell programming styles as well.
10:45:57 <Iceland_jack> Yes, but Haskell is more opinionated than say Common Lisp
10:46:35 <hodapp> :t join
10:46:35 <lambdabot> Monad m => m (m a) -> m a
10:46:39 <HeladoDeBrownie> ((>>=) ((+) 1 y) (fmap g x)) -- scheme-style haskell :)
10:46:51 <HeladoDeBrownie> (ignore the actual expression, it's nonsense)
10:46:51 <hodapp> :i join
10:47:11 <Iceland_jack> There are people that program very imperatively in Lisp and others that program very functionally, nobody writes:
10:47:11 <Iceland_jack>     sum xs = runST $ do
10:47:11 <Iceland_jack>       ref <- newSTRef 0
10:47:11 <Iceland_jack>       for_ xs (\x -> modifySTRef (+ x))
10:47:14 <Iceland_jack>       readSTRef ref
10:47:18 <Iceland_jack> in Haskell ;)
10:47:20 <hodapp> where is join?
10:47:35 <HeladoDeBrownie> hodapp, Control.Monad
10:47:47 <Iceland_jack> There are other differences in Haskell style, I just don't find them substantially different
10:47:59 <hodapp> ack, somehow I'd not imported that
10:48:01 <hodapp> thanks
10:48:17 <levi> Iceland_jack: Nobody? I would't be so sure. :) I see your point, but I think Haskell style varies a lot in different ways. It's hard to quantify, either way.
10:49:03 <maukem> @index join
10:49:03 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
10:49:09 <Iceland_jack> Maybe it's a matter of terminology but I wouldn't really consider:
10:49:09 <J_Arcane> I see a lot of asscovering code in CodeWars solutions.
10:49:09 <Iceland_jack> =    sum₀    = foldr (+) 0
10:49:09 <Iceland_jack>     sum₁ xs = foldr (+) 0 xs
10:49:09 <Iceland_jack>     sum₂ [] = 0
10:49:12 <Iceland_jack>     sum₂ (x:xs) =
10:49:17 <Iceland_jack> Oops.....
10:49:32 <Iceland_jack> Maybe it's a matter of terminology but I wouldn't really consider:
10:49:32 <Iceland_jack>     sum₀	= foldr (+) 0
10:49:32 <Iceland_jack>     sum₁ xs	= foldr (+) 0 xs
10:49:32 <Iceland_jack>     sum₂ []	= 0
10:49:35 <Iceland_jack>     sum₂ (x:xs) = x + sum₂ xs
10:49:39 <Iceland_jack> different styles
10:50:02 <Iceland_jack> I was going to indent the equals signs nicely, oh well
10:50:13 <maukem> ew, tabs
10:50:23 <Guest48959> hi, i want to complie my project with profiling option. i set "ghc-options: -threaded -prof -fprof-auto -osuf p_o", and i completed installing my library profiled. but, "cabal install" then i found an error "Failed to load interface for ‘GHC.Integer.Type’, Perhaps you haven't installed the "p_dyn" libraries for package ‘integer-gmp’?" how can i resolve this error?
10:50:23 <Iceland_jack> Yes, Emacs inserts them automatically
10:50:29 <maukem> punch it
10:51:01 <J_Arcane> I do have a tendency sometimes to fall back into Scheme-ish cond-like blocks for functions, but with Haskell I find I eventually start playing more with function composition very quickly because it's just so much more fun.
10:53:04 <clrnd> i just fold everything
10:53:05 <makalu> when I run this example from Hakyll.Core.Routes: "runRoutes (setExtension "html") "foo/bar"" I get "No instance for (Data.String.IsString Hakyll.Core.Provider.Internal.Provider) arising from the literal ‘"foo/bar"’"
10:54:11 <jaspervdj> makalu: which example?
10:54:37 <makalu> the setExtension one
10:54:52 <makalu> runRoutes (setExtension "html") "foo/bar"
10:55:19 <jaspervdj> makalu: Oh that's an out-of-date example, the signature for runRoutes changed I think
10:55:22 <jaspervdj> I'll have to fix that
10:55:48 <makalu> did Hackage just change? It looks different today
11:00:56 <hodapp> CindyLinz: having some trouble making your <*> example work; it appears to just be sticking more and more stuff inside the monad type
11:00:57 <clrnd> hackage needs a graphic overhaul, it looks so 90s
11:01:10 <hodapp> CindyLinz: cannot even get it to function on a variant that takes only a single argument
11:03:26 <hodapp> edwardk: in the example you gave here, join $ f <$> mw <*> mx <*> my <*> mz, were mw... mz expected to be values already bound via <-?
11:03:39 <edwardk> hodapp: no, they were monadic actions themselves
11:03:53 <edwardk> you asked how you could run a bunch of monadic actions and pass the inputs into that thing
11:04:11 <edwardk> you can of course just do x <- mx; y <- my; z <- mz; f x y z
11:04:32 <edwardk> but it sounded like you were looking for a fancier way
11:04:55 <clrnd> hodapp, look at the types
11:05:00 <clrnd> :t (<*>)
11:05:01 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:05:04 <clrnd> I love applicatives
11:05:38 <hodapp> clrnd: the types are things like (Ivory.Language.Proc.IvoryCall_ ('[s00] ':-> Sint32) eff0 (Ivory (ProcEffects s ()) (Uint8 -> Ivory (ProcEffects s ()) b0))) here
11:06:02 <clrnd> still working in ivory I see, xD, thats awful
11:06:44 <Iceland_jack>  
11:06:44 <Iceland_jack> hodapp: I figured it was some kind of EDSL from the question :)
11:06:53 <hodapp> edwardk: even "join $ (call_ printf2 "...") <*> deref (temp ! 0)" is not type-checking
11:07:10 <Iceland_jack> Or from 'call_ printf7 "..." <$> deref (temp ! 5) <*> deref (temp ! 4) <*> deref (temp ! 3) <*> ...' actually, not sure if you wrote that
11:07:12 <edwardk> the first <*> was a <$>
11:07:17 <hodapp> ohhh
11:08:06 <hodapp> okay, I think that was likely the issue
11:08:49 <hodapp> clrnd: yeah, I suspect that most EDSLs that have to model the type system of something else get ugly like this...
11:17:26 <bramgg> Is hosting a website in Haskell a doable task for a novice?
11:17:37 <srhb> bramgg: Absoliutely
11:17:42 <srhb> bramgg: Check out Scotty for instance.
11:17:53 <bramgg> srhb: thanks, will do
11:18:14 <srhb> bramgg: http://hackage.haskell.org/package/scotty -- the example at the top is sufficient to serve a page.
11:20:10 <clrnd> bramgg, what do you mean by hosting?
11:20:32 <bramgg> clrnd: I suppose I used the wrong term there, I meant writing an application that could serve files over http requests
11:21:20 <clrnd> bramgg, oh, in any case the answer is yes :D
11:21:39 <clrnd> IIRC haskell's webservers are around the fastests
11:22:13 <bramgg> To give context I've completed maybe half of "Learn You a Haskell..", got bored and want to make something real.
11:22:22 <bramgg> ^ What I meant by novice
11:23:07 <clrnd> bramgg, there is an excelent tutorial on using yesod, which is more like a web framework
11:23:27 <bramgg> clrnd: http://www.yesodweb.com/page/quickstart ?
11:23:34 <Welkin> yesod *is* a framework
11:23:36 <Welkin> it runs on Warp
11:24:00 <clrnd> bramgg, http://www.yesodweb.com/book
11:24:03 <erisco> if lookupTypeName has type String -> Q (Maybe Name) and Q is not a monad transformer, is there any convenient monadic way to work with the types?
11:24:03 <bramgg> thanks
11:24:06 <Welkin> if you want to use yesod, read the yesod book (available for free on yesodweb.com)
11:24:21 <Welkin> it explains the basics quite well
11:24:38 <erisco> do I just have to define my own transformer then?
11:26:12 <bramgg> This may be opinionated, but which is easer for a beginner, Yesod or Scotty?
11:26:48 <clrnd> bramgg, it may depend on what you wanna do
11:28:02 <johnw> erisco: Q as mentioned wouldn't have the type of a monad transformer; but you could make a wrapper to get the behavior you wanted, if Q were a monad
11:28:14 <erisco> johnw, Q is a monad
11:28:35 <johnw> in that case, you should be able to simply wrap such values with MaybeT
11:28:40 <johnw> to turn them into MaybeT Q Name
11:28:45 <johnw> you wouldn't have to write anything
11:28:48 <johnw> @src MaybeT
11:28:48 <lambdabot> Source not found.
11:28:56 <johnw> newtype MaybeT m a = MaybeT (m (Maybe a))
11:29:01 <lisbeth> ok so I am trying to install hell shell using cabal install in the gitclone
11:29:34 <erisco> johnw, oh of course, thanks
11:29:39 <lisbeth> has far as I know hell is installed
11:29:41 <erisco> been a while since I used transformers
11:29:43 <lisbeth> but I can't launch it from my shell
11:30:47 <lisbeth> nevermind hell is not installed
11:35:17 <J_Arcane> Woo. I learned how to typecast read.
11:35:34 * hackagebot hybrid-vectors 0.1.2.1 - Hybrid vectors e.g. Mixed Boxed/Unboxed vectors  http://hackage.haskell.org/package/hybrid-vectors-0.1.2.1 (EdwardKmett)
11:35:36 * hackagebot zlib-lens 0.1.1 - Lenses for zlib  http://hackage.haskell.org/package/zlib-lens-0.1.1 (EdwardKmett)
11:35:38 * hackagebot zlib-lens 0.1.1.1 - Lenses for zlib  http://hackage.haskell.org/package/zlib-lens-0.1.1.1 (EdwardKmett)
11:35:40 * hackagebot ChasingBottoms 1.3.0.10 - For testing partial and infinite values.  http://hackage.haskell.org/package/ChasingBottoms-1.3.0.10 (NilsAndersDanielsson)
11:37:17 <johnw> edwardk: on http://hackage.haskell.org/package/zlib-lens-0.1.1, the Home Page link does not click through to where it's supposed to
11:37:32 <johnw> plus, it claims no maintainer
11:37:33 <edwardk> see 0.1.1.1
11:37:36 <johnw> oh
11:37:41 <erisco> any ideas why haskell.org is so darn slow sometimes?
11:37:44 <johnw> doh, thanks
11:37:53 <johnw> erisco: they recently split up servers
11:37:57 <edwardk> erisco: #haskell-infrastructure can better answer that sort of question
11:37:59 <johnw> and it's wreaking havoc with CDN caching
11:38:05 <ski> @where Yesod
11:38:05 <lambdabot> #yesod - http://yesodweb.com/
11:38:08 <johnw> yeah, they've been discussing this for a few days now
11:38:15 <ski> @where+ Yesod Web Framework - #yesod - <http://yesodweb.com/>,<http://www.yesodweb.com/page/quickstart>,<http://www.yesodweb.com/book>
11:38:15 <lambdabot> I will never forget.
11:38:18 <edwardk> just in case you can't get a good answer here.
11:38:19 <erisco> edwardk, there is a separate channel just for that?
11:38:22 <ski> @where Scotty
11:38:22 <lambdabot> I know nothing about scotty.
11:38:44 <edwardk> erisco: yeah. we actually have a rather alarmingly large number of folks moving around behind the scenes to keep things running
11:38:58 <edwardk> they coordinate over there
11:39:49 <shlevy> Anyone know if github user brendanhay hangs out here/under what nick?
11:41:30 <erisco> so which is the transformers library to use? transformers, mtl, monads-fd or monads-tf?
11:41:34 <Welkin> edwardk: like disneyland?
11:41:45 <tolt> So I'm currently having a problem with waking up a thread with STM, is there a different way to go about using stm that I'm not aware of?
11:41:57 <tolt> OR is there a structure that allows you to watch it for changes?
11:42:05 <Welkin> erisco: for what?
11:42:09 <edwardk> erisco: transformers is 'just the transformers', 'mtl' repackages 'transformers' and adds instances. they are compatible
11:42:15 <athan> erisco: Depends, do you need an actual type or a generic interface?
11:42:17 <edwardk> monads-fd became 'mtl' as of mtl 2.0
11:42:30 <erisco> okay, so mtl then
11:42:32 <edwardk> monads-tf is a historical curiosity that plays well with nothing at all
11:42:50 <erisco> I remember trying to get transformers working a while ago and all sorts of clashes happened
11:43:27 <edwardk> transformers ships with ghc. there are some problems with using versions of transformers that aren't what your compiler ships with
11:44:12 <edwardk> my little transformers-compat shim can be used to get almost all of the latest transformers features regardless of what version of transformers your app has to link with for platform reasons
11:48:19 <erisco> nope needed transformers
11:49:19 <Welkin> erisco: cabal will tell you what package you need based on your imports
11:49:28 <tolt> What would be the most efficient structure that you can watch for changes on?
11:50:06 <monochrom> one single bit :)
11:50:23 <monochrom> err, that is only the second most efficient.
11:50:36 <monochrom> the most efficient is the unit type, 0 bits. :)
11:50:54 <tolt> Well, I mean something that I can watch for modifications
11:51:03 <duga> hi, I'd like to ask, whether I can create in haskell two subtypes of float/real which cannot be assigned each other?
11:51:16 <shachaf> Haskell doesn't have subtypes.
11:51:17 <Welkin> subtypes?
11:51:18 <shachaf> (Nor assignment.)
11:51:25 <Welkin> just create a type synonym
11:51:30 <glguy> Wow, that's two problems avoided in a row
11:51:35 <Welkin> type MyFloat = Float
11:52:02 <glguy> duga: You can use a "newtype" to create two incompatible types that both are represented by Float
11:52:08 <duga> ala sth
11:52:27 <duga> convert(euro x) i convert(double x)
11:52:52 <duga> euro "var" cannot be assigned with content with dollar "var"
11:53:08 <duga> effect like in ada
11:53:17 <shachaf> What glguy said is probably the best answer to your question.
11:53:20 <duga> ok
11:53:29 <shachaf> Of course, you shouldn't be using floating points to represent money in the first place.
11:53:38 <duga> shachaf: thanks
11:54:08 <monochrom> x87 has binary-coded decimal for money
11:54:09 <glguy> tolt: Without more detail you probably can't get a better answer to your question
11:54:13 <Welkin> does it not work the same way for type synonyms?
11:55:00 <tolt> glguy: I'm currently using STM and retrys to watch for updates but waking up the thread seems to take a while
11:55:27 <Welkin> I suppose not
11:57:44 <monochrom> my answer about 0 bits and 1 bit began as a degenerate case, but like all degenerate answers I give, there is deep wisdom behind it.
11:58:30 <monochrom> if you expect there to be n bits that could change indepedently, then the most efficient data structure to watch for is exactly n bits. this is basic information theory.
11:58:41 <shachaf> I suppose Bool has 1 bit and () has 0 bits and Void has -∞ bits.
11:59:07 <monochrom> so first you have to ask yourself: what is your n?
12:00:07 <joebobjoe> Are all type systems with dependent types undecidable?
12:00:21 <shachaf> No.
12:00:35 <erisco> if I have one module which defines quasi quoters, and another which uses the quasi quoters, and I load both into GHCi I can see the splices being done correctly but GHCi does not see the spliced definitions
12:00:37 <erisco> any ideas?
12:01:01 <joebobjoe> What is an example of a language that has depdent types with decidable type checking
12:01:22 <erisco> it is incredibly tedious to compile the quasi quoter over and over just to test it
12:02:02 <shachaf> Most of them, I think.
12:02:06 <shachaf> Let's say Agda.
12:02:50 <tolt> monochrom, glguy this is where I currently am http://lpaste.net/4569410427699593216
12:05:36 * hackagebot text 1.2.0.4 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-1.2.0.4 (BryanOSullivan)
12:10:26 <erisco> @pl \x -> f x >> return y
12:10:26 <lambdabot> (>> return y) . f
12:10:57 <erisco> bleh
12:11:02 <monochrom> if you're just waiting for a Nothing to change to a Just, or the other way, then that's as good as it gets, as far as high-level programming is concerned.
12:11:38 <tolt> The cpu usage isn't great when I update it a lot
12:11:54 <mm_freak_> erisco: see (<$)
12:13:31 <clrnd> hey I wanna try nix for a haskell project, how do I start?
12:13:39 <erisco> mm_freak_, not sure if that helps me much
12:13:45 <erisco> :t (<$)
12:13:45 <lambdabot> Functor f => a -> f b -> f a
12:13:56 <mm_freak_> erisco: (y <$) . f
12:14:04 <mm_freak_> not that that's any less ugly, though
12:14:26 <mm_freak_> clrnd: https://nixos.org/wiki/Haskell
12:15:36 * hackagebot constraints 0.4.1.3 - Constraint manipulation  http://hackage.haskell.org/package/constraints-0.4.1.3 (EdwardKmett)
12:15:55 <erisco> ah whoops, watch out for optional . try vs try . optional
12:16:21 <EvanR-work> not a commutative monoid
12:16:22 <clrnd> mm_freak_, well I don't have nixOS
12:16:29 <mm_freak_> clrnd: you don't need to have it
12:17:10 <clrnd> first line says 'If you just want to get a running Haskell environment on NixOS quickly'
12:17:14 <Gama11> what's the simplest way to get the first element in a list for which a condition is met? basically a filter that stops after the first match
12:17:26 <clrnd> I guess this tutorial doesn't touch on getting nix installed, I can google that myself
12:17:31 <clrnd> mm_freak_, thanks anyway
12:17:38 <EvanR-work> Gama11: find?
12:17:41 <EvanR-work> :t find
12:17:42 <lambdabot> (a -> Bool) -> [a] -> Maybe a
12:17:51 <EvanR-work> @src find
12:17:52 <lambdabot> find p = listToMaybe . filter p
12:18:28 <mm_freak_> clrnd: http://nixos.org/nix/manual/#ch-installing-binary
12:18:43 <monochrom> I like to play graphic-intensive games. when I play such a game, it updates things a lot, and CPU usage shoots up to 50%. some people say, that's a lot of CPU usage, this is bad. some other people say, that's a lot of CPU available for other uses, this is great. at this point, this looks like just the "half-full cup" vs "half-empty cup" philosophy. which kind of person are you, half-full or half-empty?
12:18:48 <mm_freak_> clrnd: i assumed you already have nix installed, but the manual above explains how to install it
12:18:57 <clrnd> thanks!
12:19:21 <EvanR-work> monochrom: thats a lot of cpu usage for a game, thats good!
12:19:30 <monochrom> :)
12:19:36 <Gama11> EvanR-work: perfect, thanks. ironic that I couldn't "find" that
12:19:40 <EvanR-work> you dont want the cpu to just be dormant do you
12:20:13 <tolt> hahah monochrom I had it implemented a different way with pipes and it was a lot nicer so I guess I could just go back to that.
12:20:14 <HeladoDeBrownie> cpus like to feel they're being useful
12:20:18 <Gama11> I was looking at this, https://www.haskell.org/haskellwiki/How_to_work_on_lists, but I guesss it isn't complete
12:20:29 <mm_freak_> if the CPU usage is exactly at 50% it suggests that you have two cores and the game ignores all but one core, which is probably bad
12:20:29 <EvanR-work> more cpu means better game ;)
12:20:58 <mm_freak_> for graphics-intensive real-time games i tend to assume that for the duration of the game you would want it to make use of your hardware as best as it can
12:22:06 <mm_freak_> Gama11: from time to time you will write a function just to find that it is already provided in some form by the base library…  that's fine, it's an important step towards mastery =)
12:22:54 <Gama11> oh, definitely. this just seemed like something common enough that there had to be something built-in :)
12:23:45 <Zemyla> Hey everyone.
12:24:09 <mm_freak_> :t \p -> foldr (\x _ -> Just x) Nothing . filter p
12:24:10 <lambdabot> (a -> Bool) -> [a] -> Maybe a
12:26:18 <Zemyla> :t \p -> foldr (\x r -> if p x then Just x else r) Nothing
12:26:19 <lambdabot> (a -> Bool) -> [a] -> Maybe a
12:27:01 <Zemyla> mm_freak_: That should work better.
12:28:15 <EvanR-work> :t find (= "mastery")
12:28:16 <lambdabot> parse error on input ‘=’
12:28:16 <mm_freak_> Zemyla: they both work the same way
12:28:19 <EvanR-work> :t find (== "mastery")
12:28:20 <lambdabot> [[Char]] -> Maybe [Char]
12:29:02 <mm_freak_> Zemyla: except that compositions are often easier to understand than monolithic functions
12:29:35 <erisco> dem mysteries when your code doesn't run
12:33:22 <jasonkuhrt> Where can I find a beginner-level introduction to haskell project workflow with cabal etc.
12:33:37 <jasonkuhrt> I'm diving into Haskell for a blog using Haykll for now
12:33:47 <jasonkuhrt> and I want to try especially the workflow
12:34:03 <erisco> > void . runMaybeT $ MaybeT (Right (fail "error" :: Maybe Int))
12:34:05 <lambdabot>  Not in scope: ‘runMaybeT’Not in scope: data constructor ‘MaybeT’
12:34:09 <jasonkuhrt> from package discovery installation local development deploying etc
12:34:18 <erisco> that returns Right (), so that is the mistake
12:34:21 <erisco> I intended it to fail
12:34:30 <mm_freak_> jasonkuhrt: if you have basic knowledge about haskell, i recommend reading the cabal user guide
12:35:30 <jasonkuhrt> mm_freak_: Ok, and I've investigated backpack a little bit, is anything there ready for use yet?
12:35:43 <mm_freak_> never heard of it
12:35:50 <erisco> ... == void (Right (fail "error" :: Maybe Int)) == void (Right undefined) == (\_ -> return ()) (Right undefined) == Right ()
12:36:00 <erisco> never is strict on the failure
12:36:18 <jasonkuhrt> mm_freak_: https://www.google.ca/search?client=safari&rls=en&q=haskell+cabal+backpack&ie=UTF-8&oe=UTF-8&gfe_rd=cr&ei=_TqwVPbUDIXeggSouIToBg#rls=en&q=haskell+cabal+backpack
12:36:47 <mm_freak_> i don't open search links by principle =)
12:36:55 <ReinH> monochrom: if my computer is doing other processor-intensive things while I am gaming I generally want it to stop doing that
12:37:00 <jasonkuhrt> mm_freak_: I guess https://ghc.haskell.org/trac/ghc/wiki/Backpack
12:37:57 <enthropy> dfeuer: any particular reason for your interest in HList?
12:38:02 <mm_freak_> still not quite sure what it is, but nevermind
12:38:31 <dfeuer> enthropy, nothing in particular. Just been looking around at interesting things.
12:39:18 <mm_freak_> dfeuer: if you found HList interesting, you should find 'singletons' interesting as well
12:39:35 <dfeuer> enthropy, one vague idea I had was that maybe GHC could offer an OverloadedTuples extension based around HList.
12:39:38 <dfeuer> (or similar)
12:39:51 <dfeuer> mm_freak_, what is that about?
12:40:01 <enthropy> that's something carter was after I think
12:40:28 <dfeuer> Sort of. I think he was thinking about it initially in terms of lists, but I think tuples makes more sense for it.
12:40:29 <mm_freak_> dfeuer: singleton types…  the glue between values, types and kinds
12:40:33 <enthropy> but I think it was for overloading list literals
12:40:41 <mm_freak_> dfeuer: our substitute for dependent types
12:40:53 <dfeuer> mm_freak_, sounds well over my head! I'm still just barely starting to understand *parts* of HList.
12:41:01 <c74d> Where ought I file issue reports about <https://try.haskell.org>?
12:41:01 <mm_freak_> ok
12:41:27 <dfeuer> As a learning project, I'm trying to see if it's possible to remove the UndecidableInstances extension from it :P
12:42:02 <dfeuer> GHC's extremely primitive termination checking is getting in the way a lot.
12:42:38 <monochrom> c74d: when you see chrisdone, you can tell him. speaking of which, I have something to tell him about emacs haskell-mode, too
12:42:38 * enthropy doesn't think that learning project can get very far
12:42:52 <tolt> c74d: probably here https://github.com/chrisdone/tryhaskell
12:43:03 <c74d> monochrom: does chrisdone not read GitHub issue reports?
12:43:18 <mm_freak_> dfeuer: after a few weeks of research you can write your conclusion
12:43:24 <dfeuer> ?
12:43:25 <mm_freak_> it will read along the lines of:  "No."
12:43:32 <c74d> tolt, thanks.
12:43:38 <dfeuer> mm_freak_, could be...
12:44:16 <monochrom> I don't know
12:44:40 <dfeuer> mm_freak_, some uses seem to be easily removable. Others are like pulling teeth.
12:44:42 <ReinH> monochrom: he's often in #haskell-emacs
12:45:00 <monochrom> oh! I should join that channel. I love haskell-mode.
12:45:03 <johnw> ReinH: o/
12:45:09 <ReinH> johnw: o/
12:45:17 <hvr> monochrom: I was worried for a second... it sounded like "we need to talk"
12:45:18 <ReinH> monochrom: you should
12:45:37 * hackagebot hdocs 0.4.1.1 - Haskell docs tool  http://hackage.haskell.org/package/hdocs-0.4.1.1 (AlexandrRuchkin)
12:45:55 <monochrom> gosh now I'm in so many channels. 8 of them.
12:46:42 <mm_freak_> i'm in two, and i won't be here for long =)
12:46:57 <c74d> monochrom: not that I'd be surprised, given the state of this one-letter pull-request I filed... <https://github.com/chrisdone/lpaste/pull/22>.
12:47:53 <c74d> I vaguely remember when I was in 8 channels... I'm in >150 now.
12:47:54 <mmachenry> I'm about to write a utility to schedule events. Basically "schedule :: IO (Maybe Int) -> IO ()" will fork off, call the IO action, and if it returns a number, that action will be called again in that many seconds. If Nothing is returned it terminates.
12:48:16 <mmachenry> Does something like this already exist in some kind of async-extras-like package anywhere?
12:48:19 <Hijiri> how do you manage >150 channels?
12:48:23 <c74d> I think I was in 200 at one point.
12:49:57 <clrnd> mm_freak_, finally, I run the first command and it says attribute ‘nixos’ not found
12:50:02 <clrnd> sorry to bother you btw
12:50:07 <mm_freak_> mmachenry: that's a pretty small combinator as far as i see
12:50:17 <mm_freak_> mmachenry: not sure if that really needs a whole package
12:51:00 <mm_freak_> clrnd: the attribute set may be different in non-NixOS…  where it says "nixos.pkgs" try just "pkgs"
12:51:15 <mm_freak_> clrnd: if that doesn't work, enter this:  nix-env -qaP
12:51:32 <clrnd> i will since 'pkgs' is not found either
12:51:49 <johnw> try just "nixpkgs"
12:52:00 <clrnd> yeah thats the prefix
12:52:17 <clrnd> but now it doesnt finde haskellPlatform, I dont even know what that's supposed to do, I'm just following the tutorial
12:52:24 <clrnd> I dont want the platform, I wan like a sandbox or smthng
12:52:44 <mmachenry> mm_freak_: Definitely doesn't need a whole package. I was hoping it was in some utility package
12:53:28 <mm_freak_> mmachenry: i doubt that
12:54:05 <mm_freak_> clrnd: it's very uncommon to use the haskell platform on NixOS
12:54:11 <mm_freak_> uhm…  when you use nixpkgs
12:54:27 <mm_freak_> clrnd: learn about ghcWithPackages
12:55:28 <clrnd> okay
12:56:28 <mm_freak_> clrnd: for creating/building/deploying your own package, cabal2nix and cabal.mkDerivation are useful…  this is my project skeleton:  http://hub.darcs.net/ertes/skel
12:56:41 <mm_freak_> clrnd: the default.nix, shell.nix and Makefile should be helpful for you
12:57:15 <clrnd> mm_freak_, I just want to avoid cabal compilie times
12:57:39 <clrnd> but it seems it's not so simple
12:58:05 <clrnd> I wan under the impression that it was as easy as firing up a sandbox and installing stuff
12:58:31 <mm_freak_> clrnd: it is once you understand it, but it has a learning curve of its own
12:58:36 <mm_freak_> also it won't improve your compilation times
12:59:00 <clrnd> mm_freak_, well it will when compiling dependencies
12:59:00 <mm_freak_> if your compile times are too long, try compiling with --disable-optimization during development
12:59:06 <clrnd> since it won't, right?
12:59:07 <mm_freak_> ah
12:59:12 <mm_freak_> yeah, that's true
12:59:32 <clrnd> yeah, I will learn nix then, but I need to find me some time
12:59:39 <mm_freak_> usually dependencies aren't compiled at all, because they come prebuilt from hydra
12:59:52 <clrnd> what is hydra?
13:00:05 <mm_freak_> hydra is the CI build farm (and the software that runs on it)
13:00:19 <clrnd> oh
13:00:34 <Iceland_jack> Hail Hydra!
13:03:34 <erisco> y <- f x; case y of ...;  is there a shorter version of this?
13:03:57 <wyager> I'm trying to port my website to Snap. It's a dead-simple static content serving site. However, it appears to fail to garbage collect properly. Every time I serve a page, the ByteString that represents that page appears to be duplicated in memory and then never cleaned up. So if I serve a 556KB image 10,000 times, the memory usage goes up to about 5.56 GB. How should I profile/try to fix this?
13:04:00 <erisco> feels noisy because 'y' is superfluous
13:04:06 <mm_freak_> erisco: no
13:04:07 <srhb> erisco: lambda case?
13:04:12 <Iceland_jack> erisco: You can write: f x >>= \case ...
13:04:17 <wyager> erisco: I wish. I've run into that a lot :(
13:04:21 <mm_freak_> erisco: unless you have a fold for the type of 'y'
13:04:26 <wyager> and Iceland_jack's suggestion works, but it's ugly
13:04:32 <Iceland_jack> Using LambdaCase as srhb mentioned, I don't like it myself
13:04:37 <ski> erisco : if there's just one case, you can say `<pat> <- <expr>' .. and what Iceland_jack said
13:04:39 <HeladoDeBrownie> LambdaCase is my favorite way to handle that
13:04:57 <Iceland_jack> In Idris you can do:
13:04:57 <Iceland_jack>     case !f x of
13:04:57 <Iceland_jack>       ... -> ...
13:05:07 <mm_freak_> Iceland_jack: that's terrifying…
13:05:08 <srhb> That would be a very nice addition.
13:05:12 <srhb> Haha
13:05:16 <srhb> Some disagreement. :-)
13:05:39 <mm_freak_> if you find that syntax is too noisy, it usually just means that you're missing a combinator
13:05:47 <Zemyla> Why doesn't Data.Fixed round properly on multiplication and division?
13:05:48 <Iceland_jack> I can't recall if you had to write: 'case !(f x) of'
13:05:56 <mm_freak_> f x >>= fold
13:06:04 <ski> (in "reflective syntax", one would be able to write something that looks similar to that Idris)
13:06:11 <Iceland_jack> mm_freak_: Sometimes, but it's not a new thing that operating on monadic values can be awkward
13:06:11 <Zemyla> :t fold
13:06:12 <lambdabot> (Monoid m, Foldable t) => t m -> m
13:06:22 <mm_freak_> Iceland_jack: for some reason it doesn't happen to me
13:06:38 <mm_freak_> Zemyla: for some "fold", not for the Data.Foldable fold
13:07:09 <Zemyla> :t (>>= fold)
13:07:10 <lambdabot> (Monoid (m b), Foldable t, Monad m) => m (t (m b)) -> m b
13:08:13 <Iceland_jack> If you're dealing with large data structures that don't have a sensical elimination function then you can run into that issue. A common case is also having to needlessly name something:
13:08:13 <Iceland_jack>     fileExists <- doesFileExist "..."
13:08:13 <Iceland_jack>     if fileExists then ... else ...
13:08:13 <Iceland_jack> Which would look less clear with a combinator like "bool"
13:08:26 <wyager> Iceland_jack: I've had that exact problem
13:08:37 <Iceland_jack> Especially when you are used to 'if doesFileExist("...") { ... } else { ... }' in other languages
13:08:42 <erisco> yuppers
13:08:47 <wyager> doesFileExist file >>= \exists -> if exists ...
13:08:49 <wyager> blech
13:08:52 <erisco> time for a paper and an extension
13:08:53 <mm_freak_> Iceland_jack: the mistake there is to produce the Bool in the first place
13:08:59 <monochrom> yeah, I just dread having to invent a temp name for it.
13:09:14 <Iceland_jack> mm_freak_: Sure you can argue that, but this is how a lot of code looks
13:09:26 <mm_freak_> Iceland_jack: and 99% of that code is broken
13:09:35 <wyager> anyone got any tips for my Snap issue? This is frustrating; I'd like to use Haskell as my web language
13:09:38 <ski> wyager : `doesFileExist file >>= \case True -> ...; False -> ...'
13:09:40 <HeladoDeBrownie> mm_freak_, what would you do instead of producing the Bool?
13:09:46 <mm_freak_> HeladoDeBrownie: open the file
13:10:11 <HeladoDeBrownie> mm_freak_, even if you didn't need the file contents?
13:10:28 <mm_freak_> HeladoDeBrownie: it depends on the application, but doesFileExist is really wrong 99% of the time
13:10:30 <ski> @where boolean-blindness might perhaps be relevant here
13:10:31 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
13:10:33 <erisco> mm_freak_, it is okay, I run in real mode and don't believe in cooperative multitasking
13:10:45 <Iceland_jack> Don't get too caught up in the example
13:11:06 <mm_freak_> HeladoDeBrownie: not exactly related to boolean blindness, but the trouble is that at the point where you pattern-match on the boolean, it might not be relevant anymore
13:11:11 <Zemyla> :t \mb mt mf -> mb >>= (\b -> if b then mt else mf)
13:11:12 <lambdabot> Monad m => m Bool -> m b -> m b -> m b
13:11:44 <mm_freak_> HeladoDeBrownie: that makes many applications fail mysteriously in rare circumstances
13:11:50 <clrnd> wyager, did you try profiling memory?
13:11:57 <clrnd> RWH has a nice writeup
13:12:08 <wyager> clrnd: I'll look, thanks
13:12:15 <wyager> But I already know exactly what it is
13:12:26 <wyager> It's the image ByteString, copied every time I send a response
13:12:28 <clrnd> wyager, but this can help you find where in the code
13:12:35 <clrnd> oh, then why not paste some code?
13:12:40 <wyager> OK, sure
13:12:51 <dolio> mm_freak_: There's no atomically-open-file-if-it-exists, right?
13:13:00 <mm_freak_> perhaps some day in the far future we will get filesystem transactions, but right now i see no hope that we can make doesFileExist an operation you would want to use =)
13:13:06 <HeladoDeBrownie> mm_freak_, not sure i understand. you mean like they keep using the Bool result after it may have expired?
13:13:20 <wyager> clrnd: http://pastebin.com/XdBgDhMz
13:13:27 <mm_freak_> dolio: just open it and handle the exception if it doesn't exist
13:13:42 <dolio> Oh, okay.
13:14:04 <mm_freak_> HeladoDeBrownie: consider: doesFileExist "blah.txt" >>= f
13:14:15 <ph88> is there a library to parse haskell and get an AST ?
13:14:19 <mm_freak_> HeladoDeBrownie: at the point when the IO action that f produces is evaluated, the file may no longer exist
13:14:25 <clrnd> huh...
13:14:27 <HeladoDeBrownie> mm_freak_, oh, i see.
13:15:23 <ski> (s/evaluated/executed/)
13:15:30 <mm_freak_> ski: s/executed/evaluated/
13:15:33 <mpickering> ph88: haskell-src-exts
13:15:38 * hackagebot seqid 0.1.0 - Sequence ID production and consumption  http://hackage.haskell.org/package/seqid-0.1.0 (LukeHoersten)
13:15:40 * hackagebot seqid-streams 0.1.0 - Sequence ID IO-Streams  http://hackage.haskell.org/package/seqid-streams-0.1.0 (LukeHoersten)
13:16:03 <mm_freak_> ski: first it's evaluated, then executed…  and the file may cease to exist before the boolean is actually pattern-matched on, which is evaluation
13:16:25 <Iceland_jack> In any case I would like to be able to write the following in Haskell:
13:16:25 <Iceland_jack>     case (!serverAlive server₁, !serverAlive server₂) of
13:16:25 <Iceland_jack>       (Alive con₁, Alive con₂) -> ...
13:16:25 <Iceland_jack> the Boolean, file systems is missing the point
13:16:26 <mm_freak_> but that's really superficial…  the effect would be the same:  a program that dies through bad assumptions =)
13:16:32 <ph88> thx mpickering
13:16:57 <mm_freak_> Iceland_jack: liftM2 (,)
13:17:04 <clrnd> Data.ByteString exports lazy or strict ones?
13:17:05 <mm_freak_> do-notation supports pattern-matching
13:17:09 <mm_freak_> clrnd: strict
13:17:14 <Iceland_jack> mm_freak_: Assume a second cae
13:17:21 <Iceland_jack> Sometimes there are nice combinators that do what you want, generally you should define them in your program but sometimes you don't
13:17:50 <ChristianS> clrnd: Data.ByteString is strict
13:17:52 <mm_freak_> Iceland_jack: in those few remaining cases i'm happy to give them a name
13:17:54 <ski> mm_freak_ : the evaluation doesn't really matter. what matters is whether the effects that `f b' will perform when executed will occur at a time when the assumptions about the world leading to believe those effects were appropriate have been invalidated, no ?
13:18:02 <clrnd> wyager, try using lazy bytestrings, I'm trying not to look in snap internals
13:18:07 <clrnd> thanks mm_freak_ ChristianS
13:18:09 <wyager> clrnd: Ok, will try that
13:18:14 <ski> in a sense, the evaluation is timeless, but the execution is located in time
13:18:21 <Iceland_jack> I'd rather not
13:18:34 <mm_freak_> ski: the effect would be the same…  somewhere between producing the boolean and resuming the program the file is deleted
13:18:48 <mm_freak_> it doesn't really matter whether it's eval or exec
13:19:42 <mm_freak_> Iceland_jack: let me put it this way:  i'd rather not introduce new special syntax into the language just for some edge cases…  one selling point of haskell is its simple syntax
13:19:51 <mm_freak_> i failed to learn go because of its horribly complicated syntax
13:20:10 <mm_freak_> (it's seemed like a horrible language anyway, for other reasons as well)
13:20:38 * hackagebot hans-pcap 0.1.0.1 - Driver for real ethernet devices for HaNS  http://hackage.haskell.org/package/hans-pcap-0.1.0.1 (tolysz)
13:20:42 <wyager> clrnd: That may have fixed it
13:20:49 <mm_freak_> rust has the same problem…  i will never learn it, because…  special syntax, special syntax, special syntax, …
13:20:57 <wyager> clrnd: Any idea why that might be?
13:21:04 <wyager> Actually, it didn't *fix* it
13:21:18 <wyager> but the memory leak is no longer directly proportional to data transferred
13:21:46 <clrnd> wyager, sorry, no. I don't know how snap works internally ...
13:21:55 <wyager> Super annoying
13:21:56 <Iceland_jack> mm_freak_: It feels like a step backwards from normal languages. It would of course be best to have syntax that makes this a non-issue
13:21:57 <clrnd> wyager, it still elaks though?
13:22:00 <clrnd> leaks*
13:22:03 <wyager> yeah, seems that way
13:22:10 <wyager> could just be due to socket retention or something
13:22:22 <wyager> Might get collected eventually
13:22:26 <ski> mm_freak_ : hm, you may be right
13:23:09 <ski> (mm_freak_ : anyway, i agree about attempting to open, and handling the inexistence condition)
13:23:17 <Zemyla> Hmm. Should there be special syntax for if and case statements inside do-blocks?
13:23:26 <Iceland_jack> People have proposed those
13:23:46 <ski> Iceland_jack : what in what Idris example goes beyond the eariler one ?
13:23:51 <wyager> LambdaCase is pretty elegant
13:23:51 <mm_freak_> Iceland_jack: i really believe in the power of combinator style…  that's why we get away with simple syntax, and i like it that way…  there are some edge cases, and there will always be — forever
13:24:11 <mm_freak_> the more special cases you cover by special syntax, the less readable your code will be
13:24:20 <Iceland_jack> mm_freak_: I think you think I'm arguing something I'm not
13:24:23 * ski has pondered such syntax .. as instances more or less of a general idea
13:24:48 <Iceland_jack> ski: the (!)-notation is Idris's way of dealing with this
13:25:06 <ski> mm_freak_ : sometimes there's virtue in avoiding indirections, like not naming things
13:25:10 <mm_freak_> Iceland_jack: i assume that you argue that the '!'-syntax that idris uses is a good idea
13:25:18 <Iceland_jack> Not really
13:25:21 <mm_freak_> ski: i agree
13:25:41 <ski> Iceland_jack : yes. i should look into it, to see how it compares with my ideas
13:25:42 <mm_freak_> Iceland_jack: then remove the "Iceland_jack: " from my message =)
13:25:50 <Iceland_jack> :-)
13:26:20 <mm_freak_> Iceland_jack: ah, i think now i understood
13:26:21 <Zemyla> I think if <- whatever then whatever else whatever works.
13:26:40 <ski> i suspect that `!' corresponds in some way to my reflection operation, but that it's missing an explicit delimiter
13:26:58 <mm_freak_> to me the (!) reads like a poor version of idiom brackets
13:27:12 <Zemyla> Because ! refers to strictness, not monads.
13:27:15 <dolio> Lack of delimiter is the big problem with such syntax.
13:27:21 <Iceland_jack> Zemyla: (not talking Haskell)
13:27:25 <ski> (my idea grew out of idiom brackets)
13:27:25 <Zemyla> Oh.
13:27:25 <dolio> When people propose things like it.
13:27:35 <ski> Zemyla : that's concrete syntax. we're talking abstract syntax
13:27:53 <clrnd> wyager, I guess relying so much in lazyness is complicated, why not write a handler that looks the files up?
13:27:59 <dolio> Same problem with, "I want to be able to write _ in an expression and have the lambda written for me."
13:28:07 * ski nods
13:28:14 <dolio> Where _ is take an argument somewhere.
13:28:15 <wyager> clrnd: Why read from disk every time? That's a waste of syscalls
13:28:16 <ski> it's not composable
13:28:18 <agocorona> Hi haskell-src-exts : what constructor store a function definition?
13:28:31 <Iceland_jack>     _₁ ++ _₂ ++ _₁
13:28:31 <Iceland_jack>     ≡
13:28:31 <Iceland_jack>     \x y -> x ++ y ++ x
13:28:41 <johnw> dolio: I do know one context where that is done well (not Haskell though)
13:28:51 <clrnd> wyager, choosing between that or a waste of memory ;)
13:28:53 <dolio> Oh yeah?
13:28:58 <wyager> clrnd: It's all small files, might as well keep them in memory. That also *should* help prevent de-duplication, although for some reason exascerbated it...
13:29:03 <mm_freak_> Iceland_jack: we have a special case of that:  -XTupleSections
13:29:09 <mm_freak_> > (3,, 5) 4
13:29:11 <lambdabot>  (3,4,5)
13:29:12 <wyager> clrnd: If I loaded a file for every request, I'd *guarantee* duplication
13:29:17 <Iceland_jack> Yes, sections in general
13:29:18 <johnw> yeah, in Coq/ssreflect you can say: have f := _  + 1, and it's the same as pose f := forall x : nat, x + 1
13:29:24 <mm_freak_> i wouldn't mind having the general case for sections
13:29:34 <ski> Iceland_jack : why not `\x -> x ++ (\x y -> y ++ x)' ?
13:29:40 <dolio> forall?
13:29:54 <Iceland_jack> Why not indead, that's the issue with these things
13:29:56 <johnw> oh, no, fun x : nat =>
13:29:58 <johnw> good catch
13:30:00 <dolio> Okay.
13:30:13 <dolio> What does it do in the middle of a complex expression, though?
13:30:19 <johnw> nothing
13:30:25 <dolio> f := map (_ + 1)
13:30:32 <johnw> ah, should work the same
13:30:34 <johnw> let me try it
13:30:48 <ski> mm_freak_ : yes .. sections are a sortof suspicious case here, that appears to be relatively benign
13:30:49 <dolio> The same? :)
13:30:50 <Iceland_jack> ski: Except one requires it to be surrounded by parentheses, similar to post-fix operators
13:31:01 <johnw> have f := map (fun x => _ + x).
13:31:04 <johnw> that worked as oxpected
13:31:05 <ski> mm_freak_ : operator sections more so than tuple sections, imho
13:31:16 <johnw> but not map (_ + 1)
13:31:22 <johnw> the _ is only for 'f', not for the lambda being passed to map
13:31:23 <mm_freak_> ski: to be honest i haven't really missed it in practice
13:31:41 <mm_freak_> even tuple sections i use only for the usual (x,) and (, x) cases
13:31:47 <mm_freak_> when i use them at all
13:31:52 <dolio> Okay, so it binds to the nearest :=?
13:32:01 <wyager> What's the point of _ selection when we have partial application and inlining?
13:32:02 <ski> johnw : yes, that actively hinders automatic refactoring, like the cut in Prolog, and like `break',`continue',`return' in C
13:32:09 <chrisdone> hey ski
13:32:10 <wyager> s/inlining/infixing
13:32:12 <mm_freak_> also that's for constructing…  i'm getting a feeling that this topic is rather about pattern-matching
13:32:13 <johnw> I think it only works to define arguments for the entity being defined by "have"
13:32:29 <mm_freak_> haskell could probably derive scott encodings for us
13:32:41 <johnw> ski: refactoring in Coq.  ho ho ho
13:32:50 <mm_freak_> i think that's the cleaner way to get lightweight pattern-matchers
13:32:55 <ski> johnw :)
13:33:11 <dolio> johnw: Anyhow, that's more sensible than, "goes to the nearest enclosing paren except not always."
13:33:19 <johnw> yeah, much
13:33:57 <ski> dolio : i'd have to agree
13:34:28 <dolio> The latter is what people normally come up with.
13:34:30 <Thulsadum> is there a cheat sheet for the several laws of data classes? (monadic laws, functor laws, ...)?
13:34:35 <xificurC> rust reached 1.0 alpha today, how does it compare to haskell?
13:34:55 <jle`> *typeclasses
13:34:56 <mm_freak_> Thulsadum: the haddocks should state the laws
13:35:03 <mm_freak_> Thulsadum: if not, i'd call that a documentation bug
13:35:09 <ski> Iceland_jack : "post-fix operators" are really just right (or is it called left ?) sections (as i'm sure you know)
13:35:18 <johnw> xificurC: compare in terms of what metric?
13:35:30 <Iceland_jack> Yeah, (sadly?) they're hardly used
13:35:45 <dolio> I don't think it's that sad. :)
13:35:52 <Thulsadum> jle`: of course type classes. ty. ;)
13:36:05 <Iceland_jack> They have their uses but I don't think people bother with them much
13:36:10 <xificurC> johnw: line of usage, expressiveness, speed
13:36:30 <johnw> xificurC: I feel like the comparison is a bit apple-and-orangey
13:36:47 <mm_freak_> xificurC: we compare by different measures…  my first question would be whether it has type constructor polymorphism now
13:36:58 <mm_freak_> forall (f :: * -> *)
13:37:00 <ski> (is `(3 +)' called a "left section" or a "right section" .. i suppose i would probably be inclined to call it a "right section". cf. how if `a * (b + c) = (a * b) + (a * c)', then `*' would be called (in similar convention) "right distributive (over `+')")
13:37:06 <dolio> No, from what I've heard.
13:37:11 <dolio> That's pending.
13:37:15 <xificurC> johnw: care to elaborate a little
13:37:21 <xificurC> johnw: why do you feel that way
13:37:38 <johnw> xificurC: I can see rust being compared to C++ or D
13:37:46 <johnw> but they sort of address different communities, different needs
13:37:52 <ski> Thulsadum : functor laws : `fmap id = id' and `forall f g. fmap (g . f) = fmap g . fmap f'
13:38:09 <johnw> we care a lot about types, rust cares a lot about memory usage
13:38:51 <mm_freak_> to such an extent that it actually has one particular type system feature i would like to have in haskell
13:38:52 <Thulsadum> ski: i know them now, but if i pause haskell for some time, i'll have forgotten them. that's the way i keep my brain organized. ;)
13:39:00 <johnw> maybe the two camps could be called denotationally-focused and operationally-focused...
13:39:01 <xificurC> johnw: I see
13:39:10 <xificurC> mm_freak_: what is that
13:39:18 <dolio> ski: Is 'f x' applying f to x or x to f?
13:39:29 <mm_freak_> i think it has affine types (or linear types or uniqueness types…  not sure which one exactly, but they all sort of address the same issue)
13:39:29 <johnw> dolio: good one
13:39:42 <mm_freak_> i would love to have any of that in haskell
13:39:45 <johnw> in Coq you'd say "apply f in x", which confuses me to no end
13:40:05 <dolio> In sounds weird.
13:40:08 <ski> mm_freak_ : it's presumably some variant/extension of uniqueness types
13:40:10 <johnw> it always does
13:40:25 <ski> (Clean has uniqueness types)
13:40:51 <johnw> you're applying 'f' as a mapping "in" the context of an hypothesized x
13:41:12 <ski> dolio : there's no preferred view
13:41:28 <agocorona> anyone has used haskell-src-exts?
13:41:42 <johnw> agocorona: better to just go ahead and ask the followup question
13:41:46 <dolio> Oh, I see.
13:42:03 <ski> dolio : by convention, i've heard it phrased "`f', applied to `x'", but syntactically, it's just a binary node with two subexpressions
13:42:05 <enthropy> agocorona: sure
13:42:06 <xificurC> thanks for your thoughts johnw and mm_freak_
13:42:18 <davidfetter_fbn> !help
13:42:20 <dolio> ski: I've heard it phrased both ways, I think.
13:42:22 <davidfetter_fbn> hrm
13:42:28 <dolio> I think the way you mentioned is more common.
13:42:31 <agocorona> and the followup questions is as follows: which constructor stores a function definition in haskell-src-exts?
13:42:40 <mm_freak_> anyway, not having type constructor polymorphism kills any language for me
13:42:52 <ski> (as opposed to applying a predicate symbol or function symbol to a list of terms in (usual formulations of) first-order predicate logic)
13:42:53 <c74d> mm_freak_: I've seen Haskell people say that Rust has linear typing, and I've seen Rust people say that no, it has affine typing.
13:42:56 <johnw> mm_freak_: I guess it's good to know what you want :)
13:43:32 <enthropy> agocorona: depends on whether it's defined like "f = \x -> ..." or "f x = ..."
13:43:32 <mm_freak_> c74d: i have no idea what exactly it has, but it has one of them
13:43:34 <ski> davidfetter_fbn : try `!list'
13:43:39 <mm_freak_> johnw: as said, we use different measures =)
13:43:44 <davidfetter_fbn> !list
13:43:44 <monochrom> davidfetter_fbn: http://hackage.haskell.org/packages/archive/pkg-list.html
13:43:46 <davidfetter_fbn> hrm
13:43:55 <davidfetter_fbn> !fedora
13:43:56 <agocorona> enthropy:  both
13:43:58 <c74d> @help
13:43:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:44:07 <c74d> davidfetter_fbn: ^
13:44:11 <ski> (at different times, that command gives different results)
13:44:25 <johnw> agocorona, enthropy: is it Rhs?
13:44:49 <osa1> since there's no way for cabal to pick libraries with nix prefixed(or suffixed) names, if I use nix I have to install every library using nix commands, right? what happens when I try to "cabal build" or "cabal install" the library/program I'm currently developing? how does cabal find libraries? do I need to manually create an environment, symlink libraries etc. for this?
13:44:52 <enthropy> I was thinking FunBind or PatBind
13:45:12 <johnw> well, Rhs says it's for function and pattern bindings
13:45:21 <johnw> I remember something in this area changing recently, which broke some code of mine
13:45:36 <agocorona> johnw:  maybe. Tanks
13:45:51 <enthropy> those two contain a Rhs
13:45:55 <dolio> c74d, mm_freak_: From what little I've seen, it seemed more complicated than what I'd think of as linear or affine typing.
13:45:55 <c74d> osa1: I think `nix-shell` may be related, though I've not used it myself.
13:46:00 <johnw> ah
13:46:01 <agocorona> enthropy: thanks
13:46:25 <dolio> Like, you'd pass something to a function, consuming your linear use of it, but then eventually get it back without being passed back a 'new' linear/affine value.
13:46:34 <dolio> But not always, there are several modes.
13:46:35 <osa1> c74d: yeah that's related but how does it symlink dependencies to right places? I guess I'll need to write the config manually for that, right?
13:47:12 <ski> Thulsadum : `fmap' must "respect" function composition, and it's identity / unit / neutral element
13:48:03 <ski> Thulsadum : `return' and `(>=>)' must satisfy laws that looks like monoid laws (but where the types are more general)
13:48:13 <mm_freak_> interestingly haskell type classes usually represent the "computable" versions of the algebraic structures
13:48:17 <mm_freak_> for example Monoid has mempty
13:48:29 <mm_freak_> which assumes that mempty is known and can be computed =)
13:49:00 <c74d> osa1: I don't know... I think you'd need to write a Nix package definition for your project? johnw might know.
13:49:29 <johnw> osa1: better to ask in #nixos
13:49:40 <osa1> ok, thanks
13:49:52 <wyager> mm_freak_: if it isn't, isn't it more appropriate to use Semigroup?
13:50:13 <mm_freak_> wyager: a semigroup is a monoid if it has an identity, not if we /know/ the identity
13:50:30 <ski> Thulsadum : `pure' and `(<*>)' must similarly satisfy laws that are reminiscent of the monoid laws .. it can conceptualy be clearer to phrase these in terms of `liftA2 (,) :: Applicative i => i a -> i b -> i (a,b)' and `pure () :: Applicative i => i a'
13:50:51 <osa1> I think I want a cabal that basically works like nix, but doesn't require any config files other than the .cabal files we use right now
13:51:01 <johnw> mm_freak_: like the monoid of types where (+) is Either and ∅ is Void?
13:51:14 <wyager> mm_freak_: Right, but you're writing a computer program. What's the point of having a monoid if its distinguishing feature from a Semigroup (mempty) is not computable?
13:51:18 <ski> Thulsadum : `Num' and the other related numberic classes are a mess
13:51:24 <johnw> well no, because Void can be mentioned...
13:51:26 <mm_freak_> wyager: but that's a delicate topic…  in type theory proof of existence implies knowledge, but proof of non-non-existence does not imply knowledge
13:51:45 <c74d> osa1: I think there is a `cabal2nix` program for generating Nix package definitions from Cabal package definitions.
13:51:54 <johnw> c74d: that's the old way of doing it
13:52:01 <johnw> very very soon to be obsolete
13:52:05 <c74d> johnw: oh?
13:52:12 <mm_freak_> johnw: as far as i see we know that Void is the identity there =)
13:52:55 <johnw> c74d: http://lists.science.uu.nl/pipermail/nix-dev/2015-January/015591.html
13:53:22 <c74d> johnw: thanks.
13:53:33 <johnw> especially: "Privately generated cabal2nix expressions will cease to compile."
13:53:37 <ski> Thulsadum : `Eq' should be an equivalence relation (arguably the finest one, upto observational equivalence), so reflexivity, symmetry, transitivity. `Ord' should be a total ordering, so reflexivity, antisymmetry/asymmetry, transitivity, and dichotomy/trichotomy
13:53:39 <osa1> c74d: wow that looks amazing
13:53:51 <c74d> osa1: what does?
13:54:05 <osa1> c74d: cabal2nix
13:54:24 <osa1> c74d: so let's say I have a package and I want to test and profile it on 4 different GHC versions.
13:54:32 <osa1> c74d: how do I create different nix configs using this tool?
13:54:46 <johnw> you only need one Nix config
13:54:51 <ski> Thulsadum : all this ignores the problem of infinite data and partiality. if one wants to take account of that, i think it may be someone more complex (not sure whether it's worth it)
13:54:52 <johnw> osa1: this is better for #nixos
13:54:58 <osa1> ok
13:55:11 <c74d> osa1: I don't know, I've never used it. And johnw says it'll stop working soon.
13:55:37 <johnw> I currently use it all the time, and would be happy to discuss it in... #nixos :)
13:56:07 <ski> Thulsadum : if you want to, you can instead express the monad laws in terms of `return' and `join', which (when squinted at from the right direction) looks like the monoid laws, in *another* way
13:56:44 <mm_freak_> ski: too many cases fail when you consider bottom
13:56:52 <mm_freak_> even the [a] monoid is no longer a monoid
13:57:21 <ski> Thulsadum : in terms of `do'-notation, the monad laws express that "reasonable" refactorings will work
13:58:45 <ski> mm_freak_ : hm, i can't see it atm
13:58:53 <benzrf> mm_freak_: example?
14:00:01 <dolio> I think [a] is fine as a monoid.
14:00:21 <dolio> The Eq stuff is more dubious.
14:00:43 <dolio> But I think you just have to say that you're semi-deciding the equivalence relation.
14:01:44 <ski> yes, obviously we don't get `forall x. x == x = True' with infinite data. we could still expect `forall x y. x == y == True => x = y' and `forall x y. x == y = False => x =/= y', though
14:02:48 <ski> dolio : could you automatically derive laws like the latter from ones like the former, using some kind of non-standard interpretation perhaps ?
14:03:47 <mm_freak_> hmm…  i remember some foundational issue with proving that Colist forms a monoid
14:04:01 <mm_freak_> even without bottoms
14:04:13 <mm_freak_> but i might have been wrong
14:04:29 <dolio> If you want to prove it, you need extensional equality. So if you were attempting it in Agda, you wouldn't be able to use the typical propositional equality.
14:05:19 <mm_freak_> dolio: i believe i abstracted over equality
14:07:01 <ski> dolio : do you mean equality with rules like function extensionality ?
14:07:29 <dolio> I mean coinduction, in particular.
14:07:32 <gregnwosu> hello if i have a f :: a -> b -> c -> d can i define type args = a -> b -> c and then define f`=args -> d
14:07:49 <ski> ok
14:07:58 <johnw> gregnwosu: those don't mean the same things
14:07:59 <ski> gregnwosu : you can't
14:08:00 <dolio> But coinduction is rather like extensional equality of functions if you squint.
14:08:06 <johnw> a -> b -> c -> d isn't the same as (a -> b -> c) -> d
14:08:08 * ski nods
14:08:29 <ski> functions behave quite a bit like coinductive stuff
14:08:36 <dolio> Yes.
14:09:05 <mm_freak_> gregnwosu: also note that 'a' is a type variable, which means that you couldn't define the type alias in the first place
14:09:06 <gregnwosu> johnw is that because the first on has 3 args and the second has 1
14:09:27 <ski> mm_freak_ : they might have intended those as meta-variables ..
14:09:31 <Hermit> I'm having problems with conduit
14:09:36 <mm_freak_> gregnwosu: let f :: A -> B -> C -> D
14:09:39 <johnw> Hermit: speak
14:09:40 <gregnwosu> mm_freak_: yeah i see that, i was just trying to make my example terse
14:09:47 <Hermit> so far the story goes like this: I need to interact with a telnet session
14:09:48 <mm_freak_> gregnwosu: type X = A -> B -> C
14:10:00 <mm_freak_> gregnwosu: X -> D = (X) -> D = (A -> B -> C) -> D
14:10:05 <Hermit> I've made a line-based buffering and yield on prompt recognition
14:10:09 <mm_freak_> now you have a function that takes a function as its first and only argument
14:10:13 <Hermit> works perfectly... on my laptop
14:10:29 <Hermit> when I run it on the server where it's to be deployed, fails miserably, it just hangs
14:10:34 <ski>   A -> B -> C -> D  =  A -> (B -> C -> D)  =  A -> (B -> (C -> D))
14:10:36 <Hermit> I inserted debug messages everywhere
14:10:42 <Hermit> and it hangs when I call await
14:10:48 <Hermit> it just doesn't receive anything
14:10:49 <gregnwosu> ski aha
14:11:01 <Hermit> I suspect it may be using bigger blocks for buffering
14:11:10 <Hermit> the code is the same, the libs versions is the same too
14:11:24 <Hermit> it should just work, but it hangs, I have logs of these sessions
14:11:30 <gregnwosu> thanks , ski i was just about to ask how to shorten long function signatures
14:11:36 <ski> gregnwosu : you could possibly tuple the arguments, or define a new datatype (possibly using records), to bundle them together. they you could make such an abbreviation
14:11:47 <Hermit> I'm about to use a proxy process or something to log into it with full detail of the traffic
14:11:57 <Hermit> but maybe this is a known issue?
14:12:06 <Hermit> so far google hasn't been of a lot of help regarding this
14:12:26 <mm_freak_> Hermit: note that buffering defaults differ between platforms and types of file descriptors
14:12:28 <gregnwosu> i can just define a type for the tail of the argument list
14:12:34 <mm_freak_> Hermit: see hSetBuffering
14:12:36 <gregnwosu> that should be equiv no?
14:12:57 <Hermit> mm_freak_: yeah, but when handles are wrapped in conduits..., is it ok to dig them out and set IOMode?
14:13:13 <ski> gregnwosu : tupled : `tupledF :: (A,B,C) -> D'. new data type : `data ABC = MkABC A B C' or `data ABC = MkABC {a :: A,b :: B,c :: C}', and `bundledF :: ABC -> D'
14:13:26 <mm_freak_> Hermit: changing the buffering should not change /what/ you read, only /when/ you read it
14:13:35 <ski> gregnwosu : i'm not sure how what i said helps with "how to shorten long function signatures" ..
14:13:41 <mm_freak_> Hermit: and i would assume that any stream processing abstraction works best with buffering turned off
14:13:57 <Hermit> I'll try that, hope it works
14:14:19 <gregnwosu> lol ski, i can just define type tailargs = B -> C -> D
14:14:40 <gregnwosu> then have f' :: A -> tailargs
14:14:42 <gregnwosu> no?
14:14:42 <ski> gregnwosu : yes, that would be possibly (you'll need to parameterize on any (free) type variables, though)
14:15:05 <ski> s/tailargs/TailArgs/ (it has to start with an upper case letter)
14:15:13 <mm_freak_> gregnwosu: although i'd ask you to think twice before doing that =)
14:15:39 <mm_freak_> a short signature doesn't help, if the complexity is changed from "reading much" to "looking up much" =)
14:16:05 <ski> gregnwosu : .. however, i think it would perhaps not as often be useful to invent a name `TailArgs' for the "tail" here .. sometimes, it can be useful, though (even making it into a, possibly opaque, data type, e.g.)
14:16:37 <ski> (and what mm_freak_ said is very true)
14:17:36 <gregnwosu> ski: can your rephrase the line begininng "however, i think...."
14:19:12 <mm_freak_> have a nice day/evening
14:20:23 <ocharles> kosmikus: I finished what I wanted to do - https://gist.github.com/ocharles/4054a20ced6ad9f7cf5b. I think I'm going to release it as `exhaustive` on Hackage, with a bit more documentation
14:20:32 <ocharles> but there's a little example there of how it's intended to be used
14:20:40 * hackagebot aws-kinesis-client 0.1.0.2 - A producer & consumer client library for AWS Kinesis  http://hackage.haskell.org/package/aws-kinesis-client-0.1.0.2 (JonSterling)
14:21:07 <ocharles> I think the surface API came out quite nicely... shame about the types :)
14:23:16 <johnw> ocharles: is there an example motivating this code?
14:23:44 <ocharles> johnw: it's in that paste
14:23:50 <ocharles> search "Example" :)
14:24:10 <johnw> yeah, it didn't do it for me
14:24:13 <ocharles> The problem I want to solve is that I am forced to consider all constructors in a data type when parsing something
14:24:28 <johnw> is that input and generated output in that example?
14:24:44 <ocharles> oh, no, that's just bad markup
14:24:45 <ocharles> that's all input
14:24:58 <johnw> so what is this code doing for me?
14:25:12 <ocharles> Making sure you consider all constructors in Expr, at compile time, when you build your parser
14:25:21 <ski> gregnwosu : hm. consider `readsPrec :: Read a => Int -> String -> [(a,String)]' -- this takes a precedence level, an input string to parse a value of type `a', consuming a prefix of the input, and returning the list of all possibly ways to do that, returning pairs of possible successfully parsed values, coupled with the remaining input (to pass on to further parsing)
14:25:27 <ocharles> otherwise, you just have to hope you got it right - but that's not exactly invariant under refactoring
14:26:14 <ocharles> I never really found a nice answer to exhaustivity checks on production, obviously it's easy for consumption - it's a compiler flag
14:26:31 <ski> gregnwosu : here we can define `type ReadS a = String -> [(a,String)]', so that we can now abbreviate the above type signature as `readsPrec :: Read a => Int -> ReadS a' -- which we now read simply as : given a precedence level, a reader/parser that can parse `a' values is returned
14:28:41 <johnw> ocharles: ah, I see
14:28:46 <Hermit> any idea how can I change a conduit Source's internal buffering?
14:28:48 <johnw> ocharles: better type checking for hand-written parsers
14:28:50 <johnw> very nice
14:30:10 <ocharles> johnw: right - sometimes every case really is radically different
14:30:17 <ocharles> but i still want to be checked that I'm at least exhaustive
14:30:37 <johnw> actually, I think during our webcast we forgot some constructors after editing the data type
14:31:19 <kaiyin> I am having some trouble figuring out exercise 2.32.4 in the haskell road to logic book, how do you translate "some birds don't fly" into a formula?
14:32:09 <ocharles> johnw: ha, there we go :)
14:32:43 <shachaf> kaiyin: What sort of formula?
14:33:01 <kaiyin> shachaf, like this: ∃x(∀y(x · y = y) ∧ ∀z(∀y(z · y = y) ⇒ z = x)).
14:33:18 <shachaf> How do you talk about birds and flying?
14:33:24 <johnw> ocharles: that's actually rather brilliant; I'd like to use this in hnix
14:33:25 <shachaf> And what does the English sentence mean?
14:33:34 <ski> kaiyin : can you rephrase it in a more "rigid" way. using "there exists an x such that ..x..","for all x, ..x..","it is not the case that : ...", and so on ?
14:34:03 <dfeuer> I seem to remember that Okasaki's paper about RPN embedded in Haskell (which I can no longer find on the free Internet) used a function called like   start blah blah blah stop, with a variable number of args between start and stop. Can someone remind me of the general trick behind this?
14:34:04 <johnw> ∃ bird, not (canfly bird)?
14:34:16 <ocharles> johnw: glad i could help change your mind ;)
14:34:18 <ocharles> I should go into sales
14:34:26 <dfeuer> Like how to do   start 1 2 3 4 stop ==> [1,2,3,4] ?
14:34:26 <kaiyin> johnw, cool.
14:35:03 <geekosaur> dfeuer, wouldn't that be the same trick used by Text.Printf?
14:35:17 <dfeuer> geekosaur, I think it's related. I'm not sure if it's quite the same.
14:35:17 <ski> kaiyin : you need to decide on a universe / domain of discourse (or several)
14:35:25 <Iceland_jack> dfeuer: http://www.usma.edu/eecs/SiteAssets/SitePages/Faculty%20Publication%20Documents/Okasaki/hw02postfix.pdf
14:35:38 <Iceland_jack> Techniques for Embedding Postfix Languages in Haskell
14:35:49 <johnw> ocharles: here's a sentence to begin your example with: "The purpose of this library is to ensure that the parser for a given type exhaustively provides coverage of each of its data constructor.  Thing of it like pattern coverage but for parsers."  Edit as you see fit.
14:35:53 <ski> kaiyin : are you only talking about birds here, so that a variable could only possibly stand for a bird ?
14:36:06 <dfeuer> Iceland_jack, BOO-YAH. That side was completely broken for ages and ages.
14:36:08 <dfeuer> Thanks.
14:36:09 <hrumph> hi
14:36:14 <hrumph> having cabal hell
14:36:16 <ocharles> johnw: thanks! I am plannig to expand that section, but I burnt out at that point
14:36:23 <Iceland_jack> :) it's a fun paper
14:36:24 <ski> kaiyin : or, do you want to be able to talk about other things (perhaps animals) in the same context. in that case, it might make sense to have a `isBird' predicate
14:36:25 <ocharles> going to do some dishes and have dinner, then I'll doc it more and blog post :)
14:36:42 <ocharles> thanks for that sentence though, i'll be sure steal that
14:37:05 <kaiyin> ski, I think it's something like johnw has said. There exists some birds that cannot fly.
14:37:20 <ski> kaiyin : or, you could just make "bird" one domain of discourse / "sort", and e.g. "mammal" another, disjoint, one -- but then you can't directly compare birds to mammals
14:37:24 <johnw> kaiyin: at the very least I needed to have said: ∃ x : bird, not (canfly x)
14:37:41 <ski> kaiyin : it's a trade-off, depending on what kinds of things you'd like to be able to express concisely
14:38:14 <kaiyin> ski, I am not following what you mean, sounds quite complicated to me.
14:39:19 <ski> kaiyin : sometimes you're only talking about things of a particular kind, e.g. humans, and then it gets tiresome to have to say all the time "for all x, if x is a human, then ..x.." and "there exists an x, such that x is human and ..x.."
14:39:28 <hrumph> is the explicit exception package a good package to use?
14:39:40 <hrumph> explicit-exception
14:40:04 <johnw> hrumph: I've yet to see anyone use it
14:40:13 <johnw> (in the code that I've come across)
14:40:16 <hrumph> johnw i should just be using either?
14:40:17 <ski> kaiyin : those two would correspond formally to `forall x. (isHuman x => ..x..)' and `exists x. (isHuman x /\ ..x..)'
14:40:32 <johnw> hrumph: use http://hackage.haskell.org/package/exceptions and Either/EitherT
14:40:33 <hrumph> its giving me grief with cabal and.....it as though its no longer maintained...
14:40:44 <johnw> (from the either package, yes)
14:40:55 <hrumph> its using deprecated stuff now
14:41:05 <hrumph> complains about deprecated stuff even when i compile the latest
14:41:22 <kaiyin> ski, ok, I want to say, exists x in Birds (x cannot fly)
14:41:33 <johnw> I like using either for making functions total, and exceptions for indicating that truly unexpected things have happened during an IO actions
14:41:39 <StoneToad> hrumph: how old is the latest version?
14:41:51 <hrumph> StoneToad, let me see
14:42:01 <ski> kaiyin : e.g., to express "Every human has a human mother.", you could formalize it as `forall x. (isHuman x => exists y. (isHuman y /\ isMotherOf x y))'
14:42:33 <ski> kaiyin : if you just decided that you're only going to talk about humans, then you could instead simply formalize this as `forall x. exists y. isMotherOf x y'
14:42:58 <hrumph> StoneToad, well in the source there was a .cabal file modified in 2014
14:43:15 <kaiyin> ski, very cool. I intended to set Birds as the scope.
14:43:45 <ski> kaiyin : where this is taken as an abbreviation of `forall x : Human. exists y : Human. isMotherOf x y', but since we're only having one universe / domain of discourse / sort here, `Human', we can decide to skip the `: Human' parts
14:43:54 <hrumph> StoneToad, it looks like the primary content hasn't been touched since approx 2010
14:44:27 <hrumph> StoneToad, i'm looking at http://code.haskell.org/explicit-exception/
14:44:52 <srhb> hrumph: The newest version from Hackage compiles without a hitch for me.
14:44:57 <srhb> 0.1.7.3
14:45:16 <hrumph> srhb, yes it compiled for me too but i had to take lines out of the stackage file to get it to go
14:45:16 <ski> kaiyin : note that, in the former case, using `isHuman', we can *ask* whether `isMotherOf x y' is true or not, even in cases where we might informally think it makes no sense. e.g. `x' could be a rock', and `y' could be the color "red"
14:45:28 <srhb> Oh, Stackage.
14:45:58 <kaiyin> ski, nice.
14:45:59 <ski> kaiyin : by restricting the domain of discourse from `Thing' (including persons and animals) to `Human', we've now restricted `isMotherOf' to only being applicable to humans
14:47:19 <ski> kaiyin : it would also be possible to have multiple distinct domains of discourse, sorts, e.g. if we're talking about gemoetry, we might have `Line' and `Point', and a predicate `liesOn p l', which only makes sense (is only a correctly formed formula) when `p' is a `Point' and `l' a `Line'
14:47:36 <hrumph> srhb, there was a hitch for me....there was a deprecation warning
14:48:07 <srhb> hrumph: I don't know exactly what you were doing or what the problem was. If you want feedback on it, you can paste the warnings.
14:48:12 <kaiyin> ski, are you a mathematician?
14:48:23 <ski> kaiyin : in terms of Haskell, you could think of these situations as being `isMotherOf :: Human -> Human -> TruthValue' and `liesOn :: Point -> Line -> TruthValue'
14:48:32 <ski> kaiyin : i've read some math and logic
14:48:36 <deech> Hi all, I'm trying to find an element in type-level list that has more than the `context-stack` number of elements. Is there a some way to iterate in chunks at the type level?
14:49:02 <kaiyin> ski,  very nice explanation.
14:49:11 <kaiyin> thanks.
14:49:11 <shachaf> augustss: Since Text.Printf has given up on Haskell 98 compatibility (instance (a ~ ()) => PrintfType (IO a)), is there a reason IsChar is still around?
14:49:11 <ski> kaiyin : in type theory literatue, it's more common to write `value : Type' rather than the Haskellish `value :: Type', which was why i used that syntax above
14:49:54 <Iceland_jack> shachaf: (isn't that guarded by a pragma?)
14:50:00 <hrumph> srhb see http://lpaste.net/118158
14:51:11 <srhb> hrumph: Right, okay.
14:51:26 <ski> kaiyin : if we're only talking about humans (and perhaps also some inanimate objects), it might be ok to have `isMotherOf : Human -> Human -> TruthValue' .. but if we're talking about mammals, say, as well, we might want it to also be validly applicable to other mammals (regardless of the formed logical formula / proposition is true or not. the question is whether it's *meaningful* (allowed) or not, in the system)
14:52:42 <ski> kaiyin : btw, i say `TruthValue' here, rather than `Bool' (boolean value), to emphasize that it might not always be computable whether a formula is true or otherwise
14:52:48 <srhb> hrumph: Since manySynchronousT is defined in the package itself, presumably the offending code in getContentsAsynchronous will be changed once manySynchronousT is really removed.
14:53:26 <aisqwe> there is no Prim in my GHC sources, i want to see seq implementation?
14:53:38 <shachaf> There is no implementation. It's built in.
14:53:41 <kaiyin> ski, you mean Maybe.
14:53:43 <shachaf> That's what Prim means -- primitive.
14:54:01 <shachaf> You can implement it as "seq !x y = y", if you want.
14:54:25 <aisqwe> why have not GHC done it this way?
14:54:27 <ski> kaiyin : boolean algebra deals mainly with "and","(inclusive) or","true","false","not" (you can also define "exclusive or") -- predicate logic adds the quantifiers, `forall' and `exists' above .. in case the domain of discourse that they quantify over is infinite, it might not be possible to always compute a definite truth value, "true" or "false"
14:54:41 <ski> kaiyin : i didn't mean `Maybe'
14:55:29 <aisqwe> shachaf: thank you, then do you know where can i find the seq implementation in the compiler sources?
14:55:30 <kaiyin> ski, interesting.
14:55:55 <kalloc> are you recomend haskell as production language?
14:56:05 <kaiyin> Is TruthValue a valid type in Haskell?
14:56:05 <kalloc> after some month of learn :D
14:56:12 <shachaf> aisqwe: I doubt there's any one place that you can point to and say "that's where the seq implementation is".
14:56:41 <shachaf> aisqwe: You can probably implement it in Cmm (or Core) easily enough. But really what seq does is tell the compiler that something should be forced.
14:56:49 <ski> kaiyin : e.g. Golbachs conjecture says that every even integer greater than two is the sum of two prime numbers. we don't know whether it's true or not
14:57:17 <kaiyin> ski, how does haskell deal with this kind of situation then?
14:57:31 <aisqwe> shachaf: why have not GHC implement seq the way you wrote it with the !x ?
14:57:51 <ski> kaiyin : there's infinitely many integers, so we can't try them all. we *could* start checking them one after the other, and intuitively, it would seem that if there is some exception, then we'll find it. but if there's no exception, then we'll never know by trial checking, we'll never be done
14:58:05 <ski> (because we can't perform infinitely many computations in finite time)
14:58:13 <jfischoff> aisqwe: bang patterns are implemented with seq, so the definition would be circular
14:58:32 <shachaf> aisqwe: You can implement seq that way, but now you need to ask how ! is implemented.
14:58:57 <ski> kaiyin : it just goes ahead and tries. if it finds an answer, all's good. if not, then the process hangs until you interrupt it (or it runs out of memory or something)
14:59:00 <shachaf> I don't think it's "implemented with seq", but it doesn't make your problem any simpler.
14:59:06 <jfischoff> or bang patterns are thought of as expanding with seq
14:59:14 <monochrom> that uses bang patterns. bang patterns are a recent invention.
14:59:16 <jfischoff> yeah they can implement it any way they want
14:59:41 <monochrom> but then you're going to ask "why not invent bang patterns earlier"
14:59:44 <ski> > takeWhile (< 10) [0 ..]  -- this doesn't terminate, even though we might expect the answer `[0,1,2,3,4,5,6,7,8,9]'
14:59:45 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
15:00:03 <ski> er, actually i screwed that example up :)
15:00:14 <monochrom> at the end it's going to be equivalent to "why don't people use big endian" and "why don't people use small endian"
15:00:17 <Lokathor> :P
15:00:19 <ski> > filter (< 10) [0 ..] -- this is the one i had in mind
15:00:23 <lambdabot>  mueval-core: Time limit exceeded
15:01:06 <monochrom> this is why I am cynic to "curious minds want to know". not all curious minds ask important questions.
15:01:13 <ski> > [n | n <- [0 ..],n < 10]  -- this is just another way to write the same thing. compare with the math set notation `{n | n \in |N,n < 10}'
15:01:17 <lambdabot>  mueval-core: Time limit exceeded
15:01:48 <ski> (apparently my subconscious automatically "corrected" the example above to use `takeWhile', which is what you'd do in practice in this situation, to avoid this problem here)
15:02:12 <ski> > take 10 [n | n <- [0 ..],n < 10]  -- now, this still works
15:02:13 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
15:02:43 <ski> it can compute the first ten elements of the list. it's when it's trying to determine whether the list ends there, or whether there's at least one other element that it hangs
15:03:40 <ski> conceptually, `[n | n <- [0 ..],n < 10]' computes to `0 : 1 : 2 : 3 : 4 : 5 : 6 : 7 : 8 : 9 : _|_' where `_|_' can be read as "no information (yet)" (and in this case, no information ever)
15:03:48 <ski> kaiyin : makes any sense ?
15:04:03 <kaiyin> ski, yes, makes a lot of sense.
15:04:07 <kaiyin> thank you!
15:04:32 <ski> kaiyin : any more query ?
15:04:52 <monochrom> GHC's Prelude's source code probably defines seq in terms of seq#. then, in GHC's source code, seq# is probably represented by various parts scattered various places and mingled with other concerns.
15:05:39 <Peaker> cabal run runs the optimized binary from dist/build/foo/foo ?
15:05:52 <Peaker> I only learned of its existence today, after years of using "cabal build && dist/build/foo/foo", heh
15:07:02 <jfischoff> I actually like the second version, run always checks the deps, takes too long
15:07:19 <monochrom> it likely goes like this: one part notices mention of seq# (while also noticing other things) and attaches a strictness flag to some parent expression (while also doing other things). another part later notices this strictness flag (while also noticing other flags) and generate code a certain way, and suppresses some optimizations, and enables some other optimizations, etc. those optimizations are, at the same time, also suppressed or enabled by other
15:07:19 <monochrom> factors.
15:07:37 <kaiyin> How do you guys set up emacs for haskell development? What plugins do you find most helpful?
15:07:45 <ReinH> Peaker: yup...
15:07:58 <ReinH> kaiyin: https://github.com/chrisdone/emacs-haskell-config
15:08:09 <kadoban> kaiyin: I think there's a haskell-mode or something that does it pretty decent IIRC.
15:08:13 <monochrom> it's going to be a big melting pot. you really can't point one finger at one place. you can, however, try to use all your hair to point at all the places. how many straws of hair do you have? they may be just enough...
15:08:16 <Peaker> jfischoff, "cabal build" is way too slow, yeah
15:08:27 <Peaker> jfischoff, I think most of the slowness is in "ghc --make" that it runs
15:08:36 * jfischoff nods
15:08:48 <Peaker> If someone fixes "cabal build"/"ghc --make" performance, the entire Haskell community will become more productive by a few percents, probably :P
15:08:49 <dcoutts_> of course ideally we'd not be using ghc --make
15:08:57 <kalloc> haskell is production ready?
15:09:04 <Peaker> dcoutts_, what would you use?
15:09:06 <ReinH> kalloc: yes
15:09:09 <Peaker> dcoutts_, Shake?
15:09:10 <kaiyin> ski, I am still working the haskell road to logic book, will post here if I have more questions. :-)
15:09:17 <jfischoff> kalloc: yep
15:09:18 <dcoutts_> Peaker: my imaginary dep-based build lib
15:09:39 <dcoutts_> Peaker: shake isn't bad, but I don't like it academically :-)
15:09:59 * dcoutts_ has discussed this issue at great length with ndm
15:10:09 <ReinH> dcoutts_: interesting
15:10:19 <ReinH> dcoutts_: my experience is that all build systems are terrible, but some are worse than others
15:10:28 <Peaker> dcoutts_, academically?? :)
15:10:35 <jackhill> ReinH: ha!
15:10:49 <jackhill> dcoutts_: can I read these conversations anywhere?
15:10:58 <monochrom> kaiyin: on http://freecomputerbooks.com/The-Haskell-Road-to-Logic-Maths-and-Programming.html , there is a link to solutions. this is evil advice.
15:11:02 <kalloc> cabal has freeze?
15:11:05 <kalloc> for version
15:11:13 <dcoutts_> ReinH: yeah pretty much. I wrote about this some time ago... http://www.well-typed.com/blog/13/
15:11:13 <ski> kaiyin : btw, one thing about formalizations. if you can't do, formally, what you inuitively wanted to do, that might be not because it's impossible (which happens), but because your formalization isn't good enough
15:11:22 <Peaker> A good build system ought to enforce the rules, give correctness guarantees and be fast -- and currently none do all 3 (I'm working on buildsome, which aims to give all 3)
15:11:27 <dcoutts_> jackhill: sorry, not written down.
15:11:43 <Peaker> dcoutts_, do you like "ghc --make" academically? :)
15:11:44 <jackhill> dcoutts_: ah, that's okay. I'll read your blog post
15:11:56 <dcoutts_> Peaker: right, I'm not satisfied with a build language in which one needs to specify deps separately
15:12:08 <ReinH> dcoutts_: "insane use of tabs" heh
15:12:21 <dcoutts_> ReinH: that's just cosmetic
15:12:30 <Peaker> dcoutts_, buildsome auto-detects dependencies with file system hooks
15:12:41 <Peaker> dcoutts_, though if you specify the dependencies explicitly, you gain a bit of performance
15:12:47 <monochrom> wait, Applicative build rules?! :)
15:12:54 <dcoutts_> Peaker: shake is sort-of there because (I think, if you limit yourself to a certain part of the lib) it's not possible to have untracked dependencies
15:12:58 <Peaker> AFAIK, buildsome is the only build system that lets you not specify input dependencies
15:13:08 <dcoutts_> Peaker: but in practice you still need to specify many deps up front
15:13:16 <dcoutts_> and it's too name/file based imho
15:13:41 <Peaker> dcoutts_, I don't think shake does it correctly in its lib either.. e.g: C compilation #include tracking isn't correctly tracking the dependence on *missing* headers in the previously searched dirs, and it also cannot track changes in the build rules themselves
15:13:46 <jfischoff> dcoutts_: “ They should be specified together so that there is simply no way to express an untracked dependency.” agreed!
15:14:04 <Peaker> dcoutts_, you might like the premise of buildsome (though I admit that in practice, buildsome needs to mature some)
15:14:07 <dcoutts_> Peaker: ok, fair enough. That should be impossible to write in a way that it's wrong.
15:14:38 <dcoutts_> Peaker: if you read my blog post you'll probably find we agree on the problem
15:14:45 <Peaker> dcoutts_, that's what buildsome is all about: You write a Makefile with full output spec, but partial input spec. The output spec is verified correct with file system hooks. The input spec is completed with the same fs hooks
15:14:59 <Peaker> https://github.com/Elastilotem/buildsome
15:15:00 <jfischoff> I would love to see a lazy language that operated on streams and used an incrementalization optimization strategy to achieve a build language
15:15:23 <Peaker> dcoutts_, the file system hooks are unfortunately linux-specific at the moment
15:15:35 <dcoutts_> my ideal approach is very much a language approach
15:15:43 <Peaker> (and using LD_PRELOAD, they're not 100% reliable, either). Need to switch to fuse-based hooks or maybe even kernel modules
15:15:56 <Peaker> dcoutts_, but don't you want to run external tools in your build?
15:16:02 <dcoutts_> so one starts from a pure incremental computation calculus
15:16:11 <Peaker> dcoutts_, Various code generators, "ghc", Python scripts, gcc, etc?
15:16:16 <dcoutts_> and then extends it to files and processes etc
15:16:42 <dcoutts_> compilers are just pure functions that happen to take their input and output in the form of files
15:16:55 <ReinH> dcoutts_: I know, I just like your characterization.
15:16:57 <Peaker> dcoutts_, but if exposed as tools, you want file system hooks to give guarantees
15:17:07 <Peaker> dcoutts_, otherwise your spec will be violated
15:17:10 <dcoutts_> and build systems are "just" complicated combinations of pure functions, with incremental (and parallel) recalculation
15:17:16 <c74d> Peaker: have you seen Tup?
15:17:20 <Peaker> c74d, yeah
15:17:30 <Peaker> dcoutts_, that's why you want file system hooks -- to make sure your build tools actually *are* pure functions
15:17:34 <c74d> how does that compare?
15:17:53 <dcoutts_> Peaker: yes, you need to enforce things
15:17:54 <Peaker> c74d, it doesn't let you partially specify inputs. It doesn't seem to track file system dependencies on directories.
15:18:20 <Peaker> c74d, It has(had?) weird arbitrary limits, such as line length, that I encountered in practice when running a command with many files as input
15:18:36 <dcoutts_> Peaker: obviously there's a bit of a hole when you have an external process, and that bit needs dynamic checking/enforcement of the primitives where you declare what an external process can do
15:19:06 <Peaker> dcoutts_, but why not have only external tools, and use file system hooks to recover pure functions on file system subsets from your tools? that's what I do in buildsome
15:19:22 <dcoutts_> there's lots of bits of build systems that are not files
15:19:32 <Peaker> dcoutts_, that cannot be reified as files?
15:19:35 <dcoutts_> but still want incremental computation
15:19:42 <dcoutts_> e.g. individual fields within a .cabal file
15:19:45 <jfischoff> Peaker: what do file hooks do?
15:20:00 <Peaker> dcoutts_, you can extract the .cabal files to a file, and then use that file as input
15:20:04 <c74d> Peaker: I've heard of `sh` having a command length limit... maybe Tup is running things through `sh` and hitting that?
15:20:09 <Peaker> dcoutts_, buildsome will see the file did not change, and will not rebuild if that field did not change
15:20:33 <Peaker> jfischoff, in buildsome, they guarantee you fully specified your outputs correctly, and are used to allow you not to specify all your inputs, but still be fully correct
15:20:49 <Peaker> jfischoff, i.e: if you access an input that has a build rule, the process is paused, and the input is built, and only then does your access resume
15:21:07 <Peaker> c74d, I remember a "tup" error, and when I ran the command directly, it did work
15:21:12 <Peaker> c74d, but it was years ago
15:21:16 <dcoutts_> Peaker: so you need one file per field of a .cabal file, that gets a bit silly. So I'd prefer to start with a general notion of an intermediate value, and then make files a particular (common) special case.
15:21:29 <ReinH> dcoutts_: what is the denotation of a build system? ;)
15:21:36 <dcoutts_> Peaker: which also fits with the idea of starting with just a pure core language
15:21:49 <Peaker> dcoutts_, but that means you access the fields via opaque Haskell code that's loaded inside the build process like in Shake?
15:21:56 <dcoutts_> ReinH: simple, the value it produces at the end. The rules define a pure computation.
15:22:10 <Peaker> dcoutts_, that has a *huge* disadvantage: Haskell code is a black box -- you cannot compare it to know if it changed and incrementally rebuild only if it changed, and according to the exact change
15:22:15 <ReinH> dcoutts_: just thinking about what a denotationally designed build system would look like
15:22:30 <ReinH> I suppose a build system is a function [FilePath] -> [(FilePath,ByteString)] or so
15:22:38 <Peaker> dcoutts_, that's why in Shake, you're supposed to force a big clean every time you change the build rules themselves, by updating a global version number
15:23:07 * c74d would like a build system that doesn't know what a "file" is.
15:23:13 <ReinH> c74d: good point
15:23:20 <Peaker> ReinH, A build system is like an FRP system, with every rule defining a dynamic arrow that depends on inputs (which may be used to determine, monadically, more inputs needed) and generates outputs
15:23:28 <karshan> lm
15:23:32 <Peaker> c74d, what does it use instead?
15:23:33 <ReinH> unfortunately we live with these things called filesystems :(
15:23:57 <ReinH> Peaker: right, a build system is a system for constructing a function of the type I mentioned ;)
15:24:12 <Peaker> ReinH, well, your function is missing the input content
15:24:19 <dcoutts_> Peaker: I don't think there's anything special about files in that respect.
15:24:30 <ReinH> Peaker: fair enough, [(FilePath,ByteString)] -> [(FilePath,ByteString)]
15:24:39 <c74d> Peaker: I don't know... it could delegate that sordid knowledge to plug-in functions.
15:24:46 <Peaker> dcoutts_, the nice thing about files is that you can compare them, and there is quick way to track when they changed, and they are persistent
15:25:26 <ReinH> I mean, operating systems have spent a fair amount of time developing tools for working with files...
15:25:32 <Peaker> c74d, the entities in your build graph need to: A) persist/cache B) be computed by processes that are *not* black boxes (i.e: not Haskell functions) C) Quickly determine if they changed
15:25:43 * hackagebot Deadpan-DDP 0.9.0.0 - Write clients for Meteor's DDP Protocol  http://hackage.haskell.org/package/Deadpan-DDP-0.9.0.0 (LyndonMaydwell)
15:25:44 <ReinH> It'd be a shame to throw that away, especially when I can't think of any obviously better solution
15:25:52 <ReinH> maybe a content-addressable system
15:26:15 <Peaker> build systems will have to deal with external tools, and those communicate via files. Why add *more* notions? You're not making things simpler
15:26:27 <dcoutts_> Peaker: yes, but that's not unique to files.
15:26:37 <dcoutts_> Peaker: files are clearly a very important special case.
15:27:08 <Peaker> dcoutts_, do you intend to build a computation on whatever entity replaces files - from inspectable components, via some deep EDSL to let you compare the computations?
15:27:33 <dcoutts_> Peaker: yes, see the blog post for a general idea. Applicative and that ilk.
15:27:50 <Peaker> dcoutts_, Applicative gives you white-box effects, but black-box computation
15:27:51 <dcoutts_> (though it turns out to be more complicated)
15:28:46 <Peaker> dcoutts_, I don't think your idea will work - as in let you incrementally rebuild when the rules change
15:28:56 <c74d> Peaker: for the avoidance of doubt -- my desire to eschew files is not intended to be pragmatic.
15:29:10 <jfischoff> incremental computation is surprisingly deep
15:29:14 <jfischoff> lot’s of papers
15:29:18 <jfischoff> lots
15:29:22 <Peaker> btw, buildsome is used by my company at work, and it works well (for us!) it needs a lot more work to be generally usable though
15:29:41 <Peaker> but it's far better than any other build system I've ever used (and better than tup which is great too)
15:29:42 <jfischoff> Peaker: it looks really cool
15:30:13 <dcoutts_> Peaker: right, I don't think one can do anything about that unless you have a full deep embedding for the computation language, and that's just too much imho.
15:30:14 <Peaker> jfischoff, :-)  My parsec parser for Makefiles takes ~5 sec to parse our makefiles! :(  tons of stuff takes seconds instead of sub-millis
15:30:23 <c74d> "when the rules change" being like "when I edit the Makefile"?
15:30:32 <hop_> hello all, is there any way to update a field of a struct but choosing the field dynamically rather by name? Getting fields can be done dynamically if they have the same type (since it is just a function) but is there a way to set them dynamically?
15:30:38 <Peaker> dcoutts_, It's not too much -- just use files. You called it "silly" but the gain is exactly this: an enormous gain
15:30:43 <dcoutts_> Peaker: I'm interested in this for Cabal, and there we're going to be writing the build rules up front, not user written.
15:30:43 <hop_> struct -> record :-)
15:30:50 <ReinH> Peaker: what sort of things do you build with buildsome?
15:30:59 <Peaker> dcoutts_, if you use files and external tools -- you do get white-box computations
15:31:11 <dcoutts_> Peaker: we're talking about different things. You're talking about putting the build rules themselves in files.
15:31:18 <ReinH> hop_: lens, I suppose
15:31:22 <Peaker> ReinH, A medium-sized (& growing) C project -- a distributed high reliability/high-performance file system
15:31:39 <Peaker> dcoutts_, Or otherwise make the build language fully embedded
15:31:50 <ReinH> Peaker: neat
15:32:24 <ReinH> hop_: basically you need setters, whether you write them yourself or use lens
15:32:38 <Peaker> dcoutts_, So for "cabal" it is good enough to just clean everything every time cabal is upgraded, because most rebuilds will not change the computations?
15:32:42 <glguy> hop_: You just write a function that decides to update one field of the record or another
15:32:59 <dcoutts_> Peaker: probably
15:33:37 <c74d> What is "white-box computation" vs. "black-box computation" here?
15:34:08 <Peaker> dcoutts_, I still think that's an unnecessary compromise, and also that you will want to run external tools anyway, so may as well use file system hooking and just express everything via external tools to get a build system that never needs clean, even upon cabal upgrades
15:34:09 <ski> c74d : you can analyze the former, not the latter (except by running it)
15:34:20 <c74d> ah, thanks
15:34:21 <hop_> ReinH, glguy: unfortunately, this is exactly what I want to make more automatic. I am dealing with a state monad and I wanted to write a family of setters (with some runtime error checking) for similar fields (all are Maybe ByteString)
15:34:37 <ski> c74d : cf. "deep embedding" vs. "shallow embedding"
15:35:02 <Peaker> c74d, "white-box computation" is a computation that supports an Eq instance or better, in this context :)
15:35:28 <hop_> ReinH, glguy: in C I would use a macro basically
15:35:32 <c74d> How is `gcc` more easily analyzable than a Haskell function?
15:35:39 <Peaker> c74d, in buildsome, the computation itself is a build rule string (commands) + the input files being read, so it's possible to compare
15:35:47 <dcoutts_> Peaker: I *think* you're talking about two different uses of files. One is whether the build rules language itself is stored as part of the system so you can see when rules change. The other is whether for the intermediate values that one gets in an incremental computation one should always use a file or not.
15:35:50 <ski> hop_ : you can possibly do what you said
15:35:51 <c74d> (Or whatever external tool.)
15:36:09 <hop_> ski: a macro?
15:36:16 <Peaker> c74d, If you use Shake, for example, and change the Haskell program that imports shake, there's no way to know how to incrementally rebuild, because there's no way to compare the new rules to the old rules
15:36:33 <ski> hop_ : no. "I wanted to write a family of setters (with some runtime error checking) for similar fields"
15:37:15 <Peaker> dcoutts_, well, for intermediate computations you'll be forced to use files since you invoke external tools. You can avoid files for some intermediate computations if that's important (I'm not sure why) - but then it would be really nice if you have a deep EDSL that you can Eq that does the computation
15:37:28 <hop_> ski: problem is the functional update of the struct: modify $ \s -> s { bla = .... }
15:37:37 <hop_> How can I make bla generic?
15:38:03 <Peaker> dcoutts_, normally, the Eq instance is trivial (same version of "cabal", same computation) but this generalizes it not to be, and makes the same system usable in more versatile contexts
15:38:07 <glguy> hop_: What would that have looked like with a CPP macro?
15:38:11 <Peaker> dcoutts_, perhaps such a system can even be expressed on top of Shake
15:38:53 <c74d> Peaker: I don't know Shake. :) Why is "shell commands + input files" more easily comparable than "Haskell function + input files"?
15:39:10 <hop_> glguy: the function is about 4 lines (unpacking the Maybe and see if this is consistent) and then setting. The macro will just have two paremeters: the type and the field name
15:39:12 <Peaker> hop_, This problem (and many others) is solved by the "lens" library.  but you can simply do:  updateBla f x = x { bla = f (bla x) } ; updateFoo f x = x { foo ... }
15:39:25 <dcoutts_> Peaker: so for Cabal, I'm more interested in reusing existing Haskell code than in making it a deep DSL where we can compare build rules themselves
15:39:27 <Peaker> hop_, and then:  modify . updateBla ...    vs:  modify . updateFoo ...
15:39:49 <Peaker> c74d, because: "Shell commands :: ByteString, input files :: ByteString", i.e: instances of Eq
15:40:00 <Peaker> c74d, and a Haskell function like: (a -> IO b) is not an instance of Eq
15:40:23 <dcoutts_> Peaker: and then for all intermediate values are files or not, as I said, I think it makes sense to start from an abstract notion and then make files fit within that framework.
15:40:43 * hackagebot duplo 1.6.18 - Frontend development build tool  http://hackage.haskell.org/package/duplo-1.6.18 (kenhkan)
15:41:24 <Peaker> dcoutts_, I see, but I'm not sure why you are placing so much importance on generalizing the notion of file, for one, and ignoring the ability to incrementally rebuild upon change of the computation for another.  I think the latter generalizes the solution beyond cabal and is more important than the forme
15:41:37 <glguy> hop_: paste the 4 lines in question on lpaste.net , there's no "dynamic" way to manipulate records, but there are lots of ways to structure your Haskell
15:41:54 <glguy> let's see if what we can come up with
15:42:00 <dcoutts_> Peaker: because I'm starting from something that's completely pure, with no effects at all. Like an incremental lambda calculus.
15:42:10 <c74d> Peaker: ah, I suppose I was thinking of the "Haskell function" as the source text, more equivalent to the shell commands.
15:42:10 <hop_> Peaker: composition approach looks ok actually! If this is a one-line I am happy.
15:42:34 <Peaker> dcoutts_, by the time you're done, you'll have much more. So why not meet in the middle? :)
15:42:58 <Peaker> c74d, well, that could work, if your build system loads Haskell text to execute, and can track all imports/etc
15:43:11 <Peaker> c74d, but that's just using Haskell in a white-box manner, as a deep EDSL
15:43:15 <Peaker> c74d, (which is fine)
15:43:47 <hop_> glguy: I am going for Peaker approach composing the runtime error check with the update. If I am struggling to make it terse and nice, I'll post the code. Thanks for your time!
15:43:56 <Peaker> hop_, well, you need to define an updater for each of your fields (with -Wall -Werror that's 2 lines per field), which is annoying.  The lens library has TH to do that for you with 1 extra line per record
15:44:15 <hrumph> ok i'm having the same problem with stackage i'm getting errors for a lot of stuff
15:44:15 <dcoutts_> Peaker: because starting with something small like that guides one to a good design.
15:44:26 <dcoutts_> it highlights the tricky issues in a simpler and general context
15:44:35 <dcoutts_> and avoids the tendency to go for hacks
15:44:48 <Peaker> dcoutts_, I think you can readily map the external tool approach to a simple calculus too (i.e: work from the end).
15:45:12 <hop_> Peaker: lens seems massive. I will try something a bit more basic since I am still learning. I'll start to look at lens at the same time. It looks quite interesting!
15:45:19 <Peaker> dcoutts_, I don't think having a general notion of "intermediate" that is special-cased to "file" is any simpler than just having "files"
15:45:26 <lpaste> Hrumph pasted “cabal hell” at http://lpaste.net/4156251332786782208
15:45:32 <lpaste> Hrumph pasted “cabal hell” at http://lpaste.net/118161
15:45:51 <monochrom> so many cabal hells :)
15:46:00 <glguy> That looks like yesod hell
15:46:04 <hrumph> i added the constraints from the reccommended stackage file
15:46:28 <dcoutts_> Peaker: yes, I think you can map the external tool + files world into the simple calculus, and that's exactly the approach I've been following.
15:46:45 <dcoutts_> but one starts with something with simple semantics
15:46:50 <Peaker> hop_, the "lens" library, just for record field "lenses", builds upon CPS & Functor (you can probably ignore the Profunctor stuff for that purpose), so if you feel comfortable with what CPS&Functor are, you can probably learn how "lenses" specifically work in the lens library
15:46:52 <monochrom> on the bright side, "cannot resolve dependencies, cannot continue" is safer than "let's just try"
15:46:52 <dcoutts_> or semantics at all
15:47:29 <Peaker> dcoutts_, but your approach seems to "start simple & extend", and you end up with duplicate notions, the "simple" ones, and the "extended" ones. Whereas if you map the existing tool approach to a calculus, you get only the existing tools' notions (of files)
15:47:35 <Peaker> dcoutts_, so I believe your approach ends up more complex
15:47:38 <monochrom> but some people say, "I'd rather have tried and crashed, than never have tried"
15:47:41 <lpaste> Hrumph pasted “constraints don't make sense” at http://lpaste.net/118162
15:48:24 <hrumph> those are the contraints from the file from stackage......i don't understand how this can be a valid constraint....
15:48:36 <Peaker> dcoutts_, we have "files" which are pure intermediate values. We have "external tools" which are pure functions from some dynamic subset of these values to a fixed disjoint subset of these values
15:48:40 <hrumph> how can you ask for multiple versions at once?
15:49:07 <dcoutts_> hrumph: indeed those constraints make no sense if used in an install invocation.
15:49:11 <c74d> The external tools are pure?
15:49:25 <dcoutts_> Peaker: yep, that's the intuition.
15:49:26 <monochrom> no, you can't ask for multiple versions at once
15:49:30 <Peaker> c74d, Yes, you can treat them as pure, assuming they only access the file system, and you enforce their file system access patterns
15:49:47 <Peaker> dcoutts_, and the approach buildsome enforces with its file system hooks :P
15:49:57 <dcoutts_> c74d: typically mostly.
15:50:16 <Peaker> I think it's "academically pleasing" enough :)
15:50:38 <ocharles> johnw: still around?
15:50:53 <dcoutts_> c74d: some build tools do evil things like modifying input files (see latex)
15:50:56 <c74d> "assuming they only access the file system" seems to me a significant assumption, if one's not on Plan 9.
15:51:02 <dcoutts_> and others use the time
15:51:10 <Peaker> dcoutts_, buildsome detects that and fails the build
15:51:18 <Peaker> (can't detect the latter)
15:51:20 <dcoutts_> Peaker: good
15:51:24 <ocharles> If anyone has a moment, I could do with a quick once-over of https://ocharles.org.uk/tmp/exhaustive/Control-Exhaustive.html before I publish that to hackage
15:51:37 <dcoutts_> c74d: but most are actually pure, if abstracted over their input and output files
15:52:21 <c74d> Peaker: Have you looked into Nix? I think they purify time access, among other things you might be able to use.
15:52:56 <Peaker> c74d, I thought Nix did not include an alternate kernel? :)
15:53:18 <dcoutts_> probably just a LD_PRELOAD trick
15:53:33 <Peaker> well, I use LD_PRELOAD and it sucks :( Can't guarantee much
15:54:11 <Peaker> A kernel module could be better, but blocking time access is harder, you need to ban RDTSC and remove existing kernel exposing of time to user-space
15:55:14 <Peaker> Ah, I see Intel's CR4 register lets you make RDTSC a priveleged operation
15:55:23 <dcoutts_> Peaker: is your tool available anywhere?
15:55:24 <Peaker> so with some kernel work you can make time access harder
15:55:39 <Peaker> dcoutts_, https://github.com/Elastilotem/buildsome <-- currently Linux-only
15:55:45 <Peaker> (due to the file system hooks)
15:55:56 <dcoutts_> ta
15:56:00 * dcoutts_ disappears
15:56:04 <Peaker> night!
16:00:44 * hackagebot exhaustive 1.0.0 - Compile time checks that a computation considers producing data through all possible constructors  http://hackage.haskell.org/package/exhaustive-1.0.0 (OliverCharles)
16:02:13 <ski> hop_ : pass around values of the shape `\s -> s { bla = .... }' (cf. pointers to members in C++), and make combinators for such values
16:02:19 <ski> dcoutts_ : .. i suppose you've seen the adaptive/incremental papers by Acar,Blelloch,Harper, and by Magnus Carlsson ?
16:02:36 <hop_> ski: yes! I was just doing that!
16:02:51 <ski> (doing what ?)
16:03:05 <irrequietus> https://twitter.com/hausdorff_space/status/553679470553358336
16:03:28 <ski> hop_ : this leads to functional references. lenses is an outgrowth of one approach to this
16:03:32 <ski> @where lens
16:03:32 <lambdabot> #haskell-lens | http://lens.github.io/ | https://github.com/ekmett/lens | http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
16:03:35 <ski> @where lenses
16:03:35 <lambdabot> <http://twanvl.nl/blog/haskell/overloading-functional-references>,<http://cdsmith.wordpress.com/2011/04/26/composing-state-with-functions-and-lenses/>,<http://patternsinfp.wordpress.com/2011/01/31/lenses-are-the-coalgebras-for-the-costate-comonad/>,<http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-
16:03:35 <lambdabot> structure-access-and-mutation>
16:03:54 <ski> hop_ : see those latter links for some more info
16:05:08 <ocharles> kosmikus: https://ocharles.org.uk/tmp/exhaustive/Control-Exhaustive.html - thanks for the help! :)
16:05:22 <ocharles> doh, wrong link - but never mind. it's on hackage now
16:05:59 <ski> @where adaptive
16:05:59 <lambdabot> "Adaptive Functional Programming" by Umut Acar,Blelloch,Harper in 2002 (POPL) at <http://www.umut-acar.org/publications/popl2002.pdf> and in 2006 (TOPLAS) at <http://www.umut-acar.org/publications/toplas2006.pdf>
16:06:02 <ski> @where incremental
16:06:02 <lambdabot> "Monads for Incremental Computing" (Functional Pearl) by Magnus Carlsson in 2002 (ICFP) at <http://www.carlssonia.org/ogi/papers/icfp-2002.pdf>,<http://www.carlssonia.org/ogi/Adaptive/>,in Hackage at <http://hackage.haskell.org/package/Adaptive>
16:06:53 <ski> dcoutts : those ^ were what i had in mind .. i'm not sure how relevant it's to the problems you're tackling, but i thought i'd mention it
16:10:25 <Lokathor> so I installed PDcurses, and I can use gcc to compile a .c file and all, but hscurses won't install. It keeps saying that the setup.exe made during configuration doesn't exist
16:10:49 <Lokathor> so does the setup.exe not exist because it doesn't build because i don't pass it the right directories to link against or something?
16:26:12 <ad> Hey, I have a little hard time understanding the difference between abstract data type and algebraic data type. I think I get the overall picture (my prof defined the set of natural numbers using an algebraic data type) but I don't really understand the *difference* i.e what are the limits of an abstract data type vs an algebraic. (I have used google but no resource that I could understand)
16:26:44 <Aruro> @src zipWith4
16:26:44 <lambdabot> Source not found. I feel much better now.
16:26:44 <day> im clicking my way thorugh tryhaskell.org. is the 'in' only needed in 'oneliners'? let square x=x*x in map [1..10]?
16:27:24 <day> could i write it in two lines like: let square x=x*x; map square [1..10]; ?
16:29:09 <Aruro> @src zipWithM_
16:29:09 <lambdabot> zipWithM_ f xs ys = sequence_ (zipWith f xs ys)
16:29:11 <koala_man> day: I'm trying the interpretter and it doesn't look like it lets you set global variables
16:30:04 <Aruro> i dont get this zipWithM_ source, zip does not dig into the list
16:30:06 <Peaker> I once wished GHC was smart enough not to need all the _ variants of functions. Now that I think of it, if you generalize them, you realize the _ variants usually have weaker constraints (Foldable instead of Traversable)
16:30:24 <Peaker> Aruro, "dig into" ?
16:30:37 <Peaker> so maybe the _ variants are justified
16:30:40 <Aruro> like it does not access each list element
16:30:49 <Aruro> using this pattern x:xs
16:30:59 <Aruro> @src zipWithM_
16:30:59 <lambdabot> zipWithM_ f xs ys = sequence_ (zipWith f xs ys)
16:31:08 <koala_man> day: compiled haskell and ghci lets you set them separately similarly to how you describe though
16:31:11 <Peaker> Aruro, you mean, you expect the source of zipWithM_ to pattern-match on the given args?
16:31:18 <Aruro> yes
16:31:25 <Peaker> Aruro, it does so indirectly by applying "zipWith" which pattern matches for it
16:31:28 <Aruro> @src zipWith
16:31:28 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
16:31:28 <lambdabot> zipWith _ _      _      = []
16:31:38 <Aruro> ah
16:31:39 <Aruro> sorry
16:32:00 <Aruro> my fault, did not notice that inside it is just zipWith :)
16:32:24 <Aruro> @src zipWith4
16:32:24 <lambdabot> Source not found. stty: unknown mode: doofus
16:32:41 <Peaker> Aruro, instead of infinite zipWithN functions, you can use the ZipList applicative instance
16:32:53 <Aruro> really?
16:33:29 <Peaker> > (,,,) <$> ZipList [1..3] <*> ZipList [100,200,300] <*> ZipList [4,5,6] <*> ZipList [7,8,9]
16:33:30 <lambdabot>  ZipList {getZipList = [(1,100,4,7),(2,200,5,8),(3,300,6,9)]}
16:33:33 <Aruro> i want to do this zipWithM4_ myfun list1 list2 list3 list4
16:34:17 <Aruro> does it have an M_ version? :)
16:34:31 <Aruro> to put it in main?
16:34:31 <Peaker> > let f <**> xs = f <*> ZipList xs in  pure (,,,) <**> [1..3] <**> [100,200,300] <**> [4,5,6] <**> [7,8,9]
16:34:32 <lambdabot>  ZipList {getZipList = [(1,100,4,7),(2,200,5,8),(3,300,6,9)]}
16:34:45 <Peaker> Aruro, you can use sequence_ on the result
16:35:21 <Aruro> interesting, like in here ? @src ZipWithM_
16:35:32 <Aruro> @src ZipWithM_
16:35:32 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
16:35:39 <Aruro> @src zipWithM_
16:35:40 <lambdabot> zipWithM_ f xs ys = sequence_ (zipWith f xs ys)
16:36:47 <Peaker> Aruro, yeah
16:37:11 <Aruro> ok i see how you did it but im not that familiar with applicative combinators :)
16:37:18 <Aruro> yet
16:38:17 <Peaker> Aruro, great time to learn as any :)
16:39:32 <EvanR> :t (<**>)
16:39:33 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
16:42:09 <ski> ad : an abstract data type doesn't expose the particular way it's been implemented
16:43:29 <Peaker> EvanR, thanks for confusing everyone :)
16:43:31 <ski> ad : the interface of the module just says that some abstract data type(s) exist(s), and that there's some operations avilable for manipulating values of them -- you can use no other knowledge about values of the type except the one you can get by calling the exported operations
16:43:48 <Aruro> ty for the help Peaker
16:44:43 <ski> ad : an algebraic data type is a particular primitive way in which you can define new types in Haskell, and it comes with a specific kind of implementation
16:44:43 <mikeplus64> > (,,) <$> [1,2,3] <*> [100,200,300] <*> [5,6,7]
16:44:45 <lambdabot>  [(1,100,5),(1,100,6),(1,100,7),(1,200,5),(1,200,6),(1,200,7),(1,300,5),(1,30...
16:44:48 <EvanR> Peaker: you picked <**>!
16:45:07 <Peaker> EvanR, Haskell has too many useless operators! the namespace is too polluted to have a nice local symbol
16:45:53 <Peaker> :t flip (flip ?f <$> ?x <*> ?y)
16:45:54 <lambdabot> (?y::a -> a1, ?x::a -> a2, ?f::a1 -> a2 -> b -> c) => b -> a -> c
16:45:57 <EvanR> you could do like GRE and use ♠ ♥ ♦ ♣
16:46:13 <Peaker> oops
16:46:18 <ski> ad : if you say `data Natural = Zero | Successor Natural', then you get for free some reasoning laws : disjointness `forall n. Zero =/= Successor n', injectivity `forall n0 n1. Successor n0 = Successor n1 => n0 = n1' -- both these are implicitly used by pattern-matching
16:47:21 <ski> ad : otoh, if you just abstractly export a type `Natural', and operations `zero :: Natural' and `successor :: Natural -> Natural', then you don't get these automatically (also you don't get any kind of pattern-matching / case-distinguishing operation automatically)
16:47:37 <Peaker> :t flip ($) <$> ?f <*> ?x
16:47:38 <lambdabot> (?x::f (a -> b), ?f::f a, Applicative f) => f b
16:48:24 <ski> ad : an abstract data type can be *implemented* in terms of a (concrete/representation) type, e.g. (in Haskell) defined as an algebraic data type (or alternatively as a `newtype')
16:48:29 <EvanR> export zero :: Nat, succ :: Nat -> Nat, and some kind of primitive recursion operation
16:48:58 <ski> EvanR : still doesn't guarantee the laws automatically
16:49:13 <EvanR> no?
16:50:01 <EvanR> im still trying to grok natural number objects
16:50:04 <systemfault> Haskell must be a Math gateway drug or something.... I just wanted to learn a language but now I'm learning proof theory, type theory, category theory... :/
16:50:11 <ski> you could implement `newtype Natural = N ()' and `zero = N (); successor (N ()) = N (); primrec base step (N ()) = base', e.g.
16:50:35 <ski> (where `primrec :: forall a. a -> (Natural -> a -> a) -> (Natural -> a)')
16:51:03 <ski> EvanR : that's a natural number object in `Hask'
16:52:13 <EvanR> ski: hrm. thats boring
16:52:17 <ski> yes
16:52:32 <ski>   newtype Natural = N Bool
16:52:39 <ski>   zero = N False
16:52:44 <EvanR> you mean "the" natural number object because they are all unique up to isomorphism?
16:52:53 <ski>   successor (N b) = N (not b)
16:53:37 <ski>   primrec base step (N False) = base
16:53:54 <ski>   primrec base step (N True ) = step (N False) base
16:53:57 * ski ponders that
16:54:54 <ski> EvanR : hm .. sorry, actually i realize i mean something like "natural number algebra"
16:55:25 <ski> hm, yes, i was a bit confused here
16:55:45 <EvanR> yes im still gathering these examples, this is the first one ive seen where theres only one number, zero, and succ zero is zero
16:56:25 <ski> a "natural number algebra" (really, an `NaturalF'-algebra, where `NaturalF a = 1 + a') consists of a carrier type, say `X', and two operations, of types `X' and `X -> X'
16:57:56 <ski> an *initial* `NaturalF'-algebra, say `(Natural,Zero,Succsssor)' also has a `foldNatural :: forall x. (x,x -> x) -> (Natural -> x)' operation
16:58:47 <ski> that in this case turns out to be equivalent to `primrec' (i'm pretty sure. at least assuming some background structure in the category), iow this is a "natural number object"
16:59:16 <EvanR> iow?
16:59:24 <ski> (however, for some reason, i think i was above pondering an algebra with three operations instead of two)
16:59:27 <hiptobecubic> EvanR, "in other words"
16:59:33 <ski> "iow" being short for .. what hiptobecubic said
17:01:14 <ski> EvanR : so. if you ignore `primrec' above, then those `newtype Natural = N (); ...' and `newtype Natural = N Bool; ...' would be examples of (non-initial) `NaturalF'-algebras
17:02:10 <EvanR> "by the universal property, the natural numbers object is unique up to isomorphism" (in a given category i guess)
17:02:19 <hop_> hello again. I tried to factor my code but with no success. I have a type error that overcomes my fairly limited skills. I made a self contained example from my bigger code here: https://gist.github.com/anonymous/abb36395ba0866a54075 Basically, I am writing a setter that I can then reuse for all fields. It fails to type check
17:02:20 <ski> (to avoid confusion, i'll just ignore the `newtype' wrapping here. using `()' and `Bool' to refer to these types, instead of defining new types)
17:02:21 <EvanR> so N () and N Bool seem different
17:02:42 <ski> EvanR : yes. *initial* objects (if they exist) are unique
17:02:48 <EvanR> oh
17:02:55 <EvanR> initial natural f algebra
17:03:00 <ski> EvanR : the above `()' and `Bool' examples are not initial
17:03:18 * EvanR reviews the difference
17:03:22 <ski> EvanR : being initial means that there's a map from it to any other algebra ("respecting the operations")
17:05:14 <hop_> Basically, I do not know what I am doing :P
17:05:25 <ski> so, `type Natural; Zero :: Natural; Successor :: Natural -> Natural' being initial means that for any other `NaturalF'-algebra `type X; zeroX :: X; successorX :: X -> X', there's a map `foldX :: Natural -> X', such that `foldX . Zero = zeroX' and `foldX . Successor = successorX . foldX'
17:05:26 <ReinH> an initial algebra is an initial object in the factory of blah blah blah
17:05:51 <ski> ReinH : s/factory of blah blah blah/category of algebras/ :)
17:06:00 <ReinH> Uh. Factory? Where did that come from.
17:06:02 <hop_> Sorry
17:06:13 <ReinH> ski: well, in this case NaturalF-algebras.
17:06:13 <hop_> I made another version dealing with document directly. I just works.
17:06:15 <EvanR> AbstractFunctorCategryFactory
17:06:18 <ski> ReinH : yes
17:06:30 <phaazon> dammit
17:06:33 <phaazon> where is it from
17:06:38 <hop_> Please forget about it. I was just confused :) I need to sleep! Sorry for the noise again
17:06:39 <phaazon> @index peekArray
17:06:39 <lambdabot> Foreign.Marshal.Array, Foreign.Marshal, Foreign
17:06:43 <phaazon> yeah.
17:06:47 <hiptobecubic> EvanR, doesn't sound very portable. You should wrap it up as a netbean.
17:08:15 <EvanR> ski: got it
17:08:42 <EvanR> so in our case, the initial one is data Nat = Z | S Nat ?
17:09:20 <ski> EvanR : another familiar example. consider the algebra signature `(List,Nil,Cons)', or i'll write it `forall a. {type List a; Nil :: List a; Cons :: a -> List a -> List a}' (the functor `ListF a' here is defined by `forall r. ListF a r = 1 + a * r') -- iow, for each type/object `a' do we get a distinct kind of `ListF a'-algebras
17:09:26 <ski> EvanR : yes
17:10:46 <EvanR> 1 + a * r means Maybe (a,r) ?
17:11:03 <ski> EvanR : here's one example of a `ListF Natural'-algebra : `type Natural; nilN = Zero; consN = (+)' -- the corresponding initial map from the initial `ListF Natural'-algebra (iow `List Natural') is the `sum' function
17:11:07 <ski> EvanR : yes
17:11:39 <ski> `sum' is in Haskell terms defined as `sum = foldr (+) Zero'
17:11:56 <ski> (assuming of course that we have defined `(+) :: Natural -> Natural -> Natural')
17:12:48 <EvanR> hold on, whats the r
17:13:40 <ski> so, `foldr' is a "higher-order" operation that is polymorphic in the carrier type `X' of the chosen `ListF a'-algebra, and which takes as input the "zero" and "successor" operations belonging to this `X' `ListF a'-algebra. given this, it computes the initial map from `List a' to `X'
17:14:33 <ski> EvanR : the functor `NaturalF' describes one "recursive layer" of the initial algebra `Natural'
17:14:44 <ski> EvanR : the functor `ListF a' describes one "recursive layer" of the initial algebra `List a'
17:14:56 <ski> consider
17:15:13 <ski>   foldr :: (a -> r -> r) -> r -> (List a -> r)
17:15:21 <ski> with some refactorings, we get
17:15:29 <ski>   foldr :: r -> (a -> r -> r) -> (List a -> r)
17:15:36 <ski>   foldr :: (r,a -> r -> r) -> (List a -> r)
17:15:45 <ski>   foldr :: (() -> r,(a,r) -> r) -> (List a -> r)
17:15:54 <ski>   foldr :: (Either () (a,r) -> r) -> (List a -> r)
17:16:03 <ski>   foldr :: (Maybe (a,r) -> r) -> (List a -> r)  -- if you want to
17:16:04 <ski> iow
17:16:24 <omosoj> hey guys, dumb question. what's haskell good for? i'm a relatively new ruby developer but i want to learn everything else. someone recommended that i might like haskell because i like philosophy. idk if that makes sense. but if i wanted a small project to play with haskell, what would you all recommend?
17:16:35 <ski>   foldr :: (ListF a r -> r) -> (List a -> r)
17:17:31 <EvanR> r is the X?
17:17:35 <ski> yes
17:17:37 <Hijiri> chatbots, text games, web applications, libraries
17:17:50 <Hijiri> other stuff
17:18:06 <ski> EvanR : the input value of type `ListF a r -> r' is a neat way to summarize/abbreviate the `nilX :: r; consX :: a -> r -> r' operations on the `ListF a'-algebra with carrier `X'/`r'
17:18:47 <day>  is haskell compiled like C or is it a scripting language like perl which gets compiled on execution? I thought the first, but all the interactive consoles suggest otherwise
17:18:55 <ski> EvanR : in general, givan an arbitrary functor `F', and the initial `F'-algebra, say `T', in the category of all `F'-algebras, we can express :
17:18:59 <EvanR> ListF is a family of functors from the initial list algebra to any other list algebra?
17:19:10 <omosoj> Hijiri, say i'm building a web app with rails. what sorts of functions or services would it be good to break off and use haskell for?
17:19:11 <EvanR> and the initial list algebra is just... lists
17:19:13 <ski>   fold :: (F r -> r) -> (T -> r)
17:19:13 <dnkndnts> day: it has a repl, yes, but it's a compiled language
17:19:31 <ski> EvanR : i used `r' for "recursive result/layer" here
17:19:35 <Hijiri> Well if you want to maximize the playing with haskell, you could just write the entire thing in haskell
17:20:16 <Hijiri> a couple good minimal web frameworks are Scotty or Snap
17:20:24 <Hijiri> (Scotty is smaller)
17:20:43 <ski> EvanR : `fold' describes how, if you know how to "flatten" the last (top) `F'-layer to a value of type `r' (after all the "children" has been recusively flattened to `f'), then you know how to flatten a full recursive `T' (built up out of `F' layers) to a final `r' result
17:20:57 <EvanR> whats the role of the fold operation, this is the defining characteristic of a natural number algebra...
17:21:00 <day> ghc needs 800MiB? o0
17:21:14 <Hijiri> I'm not sure what's required for interfacing between ruby and haskell
17:21:31 <Hijiri> The FFI lets you export C functions
17:21:32 <ski> EvanR : in the `Natural' case, note that this type is essentially the same as `Maybe (Maybe (Maybe (Maybe (....))))' (`forall r. Maybe r = 1 + r')
17:21:47 <Hijiri> so you could do Ruby <- C <- Haskell if you really needed to
17:21:52 <ski> EvanR : `fold' is the initial morphism from the initial object in this category
17:22:29 <Hijiri> I don't know if there is an existing way to interface directly with Ruby
17:23:11 <EvanR> fold :: (F r -> r) -> (T -> r)
17:23:35 <ski> EvanR : an initial object `I', together with a specified initial map `i' construction, in a category, is an object `I', such that for every object `X' in the category, there exists a unique morphism `i_X :: I -> X' (you could think of `i' as `i :: forall x. I -> x' if you want to)
17:24:39 <EvanR> yeah i got that
17:24:41 <ski> EvanR : an `F'-algebra consists of a carrier object `X', and a "constructor" morphism `conX :: F X -> X'
17:25:25 <EvanR> yeah
17:25:54 <ski> when we write `fold conX' in Haskell, using `fold' for the specific carrier `X', with constructor/operation `conX', then this corresponds to what i called `i_X' above
17:26:03 <EvanR> F and conX are like the rules to evaluate an expression somehow
17:26:11 <ski> (the `X' in `i_X' there incorporates both this type `X', and the operation `conX')
17:26:29 <ski> we could write
17:26:59 <ski>   i_(X,conX) : (I,ConI) >---> (X,conX)
17:27:01 <ski> if you like
17:27:15 <EvanR> i dont know >--->
17:27:26 <ski> it's just a morphism arrow
17:27:59 <EvanR> alright
17:28:05 <oleo> the arrow of the goddess....
17:28:06 <oleo> lol
17:28:19 <ab9rf> minerva's arrow?
17:28:44 <ski> EvanR : yes, `F' determines what we think of as a "layer" of the expression, and `conX' (for a given chosen "result type" `X' for some kind of "evaluation") corresponds to evaluating that layer
17:28:55 <omosoj> k, thanks, Hijiri
17:29:07 <EvanR> so initial objects are like the pure form of something from which you can derive any specialization, like stem cells ;)
17:29:18 <EvanR> using one of the initial maps
17:29:23 <ski> so `i_(X,conX)' is just another notation for the Haskell `fold conX'
17:29:44 <Hijiri> omosoj: np
17:30:06 <Hijiri> omosoj: If you're still looking around for tutorials, I'd recommend https://github.com/bitemyapp/learnhaskell
17:30:13 <ski> EvanR : well, terminal/final objects have a similar "specialization", but with the morphism arrow pointing in the other direction
17:30:45 <EvanR> ok
17:31:02 <EvanR> so its more like generalization
17:31:11 <EvanR> and theres a limit
17:31:14 <omosoj> Hijiri, awesome, thanks
17:32:11 <ski> EvanR : initial and terminal objects are two of the most basic kinds of constructions in CT
17:32:36 <ski> many other concepts can be thought of as initial or terminal objects, in an appropriate category
17:33:59 <dnkndnts> i'm trying netwire, and even just using the initial example of displaying time in the console consumes 50% of my cpu. is there any way for me to specify a frame rate or something?
17:34:32 <dnkndnts> it makes me nervous when my cpu fan turns on full speed :x
17:35:05 <oleo> maybe it's longing for air ?
17:35:12 <oleo> out of oxygen....
17:35:13 <oleo> lol
17:35:20 <Hijiri> maybe one of the countSessions?
17:35:22 <Hijiri> I'm not sure
17:35:28 <Hijiri> some kind of session
17:35:33 <itsME_> Can someone help me identify which Haskell idiom would be most appropriate here (http://lpaste.net/118165). Essentially, I have one function (which returns IO () ), which I want to execute multiple times,
17:35:37 <Hijiri> if it doesn't exist you can make a session that sleeps
17:35:55 <Hijiri> itsME_: replicateM_
17:35:58 <Hijiri> :t replicateM_
17:35:59 <lambdabot> Monad m => Int -> m a -> m ()
17:36:13 <dnkndnts> ya, i mean it feels like in C, when you just do while(true){...} with no thread sleep
17:36:15 <Hijiri> (I haven't looked at the code yet)
17:37:04 <EvanR> ski: what were we talking about, any F-algebras or natural numbers algebras
17:37:21 <itsME_> Hijiri: thanks, I'll have a look at that. It sounds about right
17:37:23 <Hijiri> :t sequence
17:37:23 <lambdabot> Monad m => [m a] -> m [a]
17:37:33 <Hijiri> This will let you just combine a list of monads into one
17:37:36 <EvanR> did we generalize past the NN situation at some point
17:37:38 <Hijiri> :t sequence_
17:37:38 <lambdabot> Monad m => [m a] -> m ()
17:37:43 <Hijiri> for when you don't care about the output
17:38:03 <ski> EvanR : any `F'-algebras (aka anarchic algebras)
17:38:31 <itsME_> Hijiri: so, use replicateM_ when I care about the output, and sequence when I dont?
17:38:46 <Hijiri> no
17:38:51 <Hijiri> the _ at the end discards it
17:39:00 <Hijiri> replicateM_ just takes an int, and then does the action that many times
17:39:05 <ab9rf> sequence and replicate are quite different
17:39:09 <Hijiri> replicateM is the same, but saves the results in the list
17:39:21 <Hijiri> sequence just takes a list of monadic values and sticks them together
17:39:33 <Hijiri> The versions with "_" at the end discard the results
17:39:45 <Hijiri> replicateM is just replicate and sequence together
17:39:49 <Hijiri> @src replicateM
17:39:49 <lambdabot> replicateM n x = sequence (replicate n x)
17:45:48 * hackagebot hans-pcap 0.1.0.2 - Driver for real ethernet devices for HaNS  http://hackage.haskell.org/package/hans-pcap-0.1.0.2 (tolysz)
17:59:01 <EvanR> (() -> r, (a,r) -> r) becomes (Either () (a,r) -> r) ?
17:59:37 <EvanR> hows this
18:00:14 <shachaf> What does it mean to become?
18:00:25 <EvanR> ski: used in as a step above
18:00:29 <EvanR> used it
18:01:21 <EvanR> not sure how its justified
18:01:30 <shachaf> Oh. Well, they're equivalent.
18:01:36 <EvanR> how?
18:02:01 <shachaf> More generally, (a -> r, b -> r) is equivalent to (Either a b -> r)
18:02:06 <shachaf> Is it easier to see that way?
18:02:25 <EvanR> ok you can recover the pair if you want by using Left a and Right b
18:02:45 <shachaf> Right. Both of them are a way to turn an a into an r and a b into an r.
18:02:57 <shachaf> You should write functions going back and forth.
18:04:19 <EvanR> f (g,h) = either g h
18:05:48 * hackagebot amazonka-core 0.2.0 - Core functionality and data types for Amazonka libraries.  http://hackage.haskell.org/package/amazonka-core-0.2.0 (BrendanHay)
18:05:50 * hackagebot amazonka 0.2.0 - Comprehensive Amazon Web Services SDK  http://hackage.haskell.org/package/amazonka-0.2.0 (BrendanHay)
18:05:52 * hackagebot amazonka-autoscaling 0.2.0 - Amazon Auto Scaling SDK.  http://hackage.haskell.org/package/amazonka-autoscaling-0.2.0 (BrendanHay)
18:05:54 * hackagebot amazonka-cloudformation 0.2.0 - Amazon CloudFormation SDK.  http://hackage.haskell.org/package/amazonka-cloudformation-0.2.0 (BrendanHay)
18:05:56 * hackagebot amazonka-cloudfront 0.2.0 - Amazon CloudFront SDK.  http://hackage.haskell.org/package/amazonka-cloudfront-0.2.0 (BrendanHay)
18:07:08 <EvanR> f' e = (\x -> e (Left x), \y -> e (Right y))
18:07:43 <EvanR> (e . Left, e . Right)
18:07:43 <shachaf> Looks reasonable.
18:07:57 <shachaf> Now prove that f . f' = id and f' . f = id :-)
18:08:04 <shachaf> (It's pretty straightforward.)
18:10:16 <EvanR> (\(g,h) -> either g h) . (\e -> (e . Left, e . Right))
18:10:55 * EvanR throws in a dummy function f
18:10:58 * hackagebot amazonka-cloudsearch 0.2.0 - Amazon CloudSearch SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-0.2.0 (BrendanHay)
18:11:00 * hackagebot amazonka-cloudsearch-domains 0.2.0 - Amazon CloudSearch Domain SDK.  http://hackage.haskell.org/package/amazonka-cloudsearch-domains-0.2.0 (BrendanHay)
18:11:02 * hackagebot amazonka-cloudtrail 0.2.0 - Amazon CloudTrail SDK.  http://hackage.haskell.org/package/amazonka-cloudtrail-0.2.0 (BrendanHay)
18:11:04 * hackagebot amazonka-datapipeline 0.2.0 - Amazon Data Pipeline SDK.  http://hackage.haskell.org/package/amazonka-datapipeline-0.2.0 (BrendanHay)
18:11:06 * hackagebot amazonka-directconnect 0.2.0 - Amazon Direct Connect SDK.  http://hackage.haskell.org/package/amazonka-directconnect-0.2.0 (BrendanHay)
18:11:32 <EvanR> either (f . Left) (f . Right)
18:11:53 <EvanR> the hell
18:12:14 <EvanR> @src (.)
18:12:15 <lambdabot> (f . g) x = f (g x)
18:16:08 * hackagebot amazonka-dynamodb 0.2.0 - Amazon DynamoDB SDK.  http://hackage.haskell.org/package/amazonka-dynamodb-0.2.0 (BrendanHay)
18:16:10 * hackagebot amazonka-ec2 0.2.0 - Amazon Elastic Compute Cloud SDK.  http://hackage.haskell.org/package/amazonka-ec2-0.2.0 (BrendanHay)
18:16:12 * hackagebot amazonka-elasticache 0.2.0 - Amazon ElastiCache SDK.  http://hackage.haskell.org/package/amazonka-elasticache-0.2.0 (BrendanHay)
18:16:14 * hackagebot amazonka-elasticbeanstalk 0.2.0 - Amazon Elastic Beanstalk SDK.  http://hackage.haskell.org/package/amazonka-elasticbeanstalk-0.2.0 (BrendanHay)
18:16:16 * hackagebot amazonka-elastictranscoder 0.2.0 - Amazon Elastic Transcoder SDK.  http://hackage.haskell.org/package/amazonka-elastictranscoder-0.2.0 (BrendanHay)
18:17:01 <EvanR> f :: Either a b -> r, the argument to the f' e is a Either a b
18:17:20 <EvanR> either (f . Left) (f . Right) is a r
18:17:54 <EvanR> so its just f
18:19:59 <EvanR> (\e -> (e . Left, e . Right)) . (\(g,h) -> either g h) $ ff where ff :: (a -> r, b -> r)
18:21:04 <EvanR> either (ffa . Left) (ffb . Right)
18:21:18 * hackagebot amazonka-elb 0.2.0 - Amazon Elastic Load Balancing SDK.  http://hackage.haskell.org/package/amazonka-elb-0.2.0 (BrendanHay)
18:21:20 * hackagebot amazonka-emr 0.2.0 - Amazon Elastic MapReduce SDK.  http://hackage.haskell.org/package/amazonka-emr-0.2.0 (BrendanHay)
18:21:22 * hackagebot amazonka-iam 0.2.0 - Amazon Identity and Access Management SDK.  http://hackage.haskell.org/package/amazonka-iam-0.2.0 (BrendanHay)
18:21:25 * hackagebot amazonka-importexport 0.2.0 - Amazon Import/Export SDK.  http://hackage.haskell.org/package/amazonka-importexport-0.2.0 (BrendanHay)
18:21:26 * hackagebot amazonka-kinesis 0.2.0 - Amazon Kinesis SDK.  http://hackage.haskell.org/package/amazonka-kinesis-0.2.0 (BrendanHay)
18:21:34 <EvanR> which is ff
18:21:50 <EvanR> funny it ends up being either in either case
18:23:56 <calvinx> can I know what is the problem with my `if-then-else` syntax in the list comprehension as follows - http://lpaste.net/118167 ?
18:25:49 <EvanR> did it wrong. it simplifies to... ((either ffa ffb) . Left, (either ffa ffb) . Right)
18:25:57 <EvanR> (ffa, ffb)
18:25:58 <EvanR> ff
18:26:28 * hackagebot amazonka-kms 0.2.0 - Amazon Key Management Service SDK.  http://hackage.haskell.org/package/amazonka-kms-0.2.0 (BrendanHay)
18:26:30 <EvanR> calvinx: '' isnt a Char
18:26:30 * hackagebot amazonka-lambda 0.2.0 - Amazon Lambda SDK.  http://hackage.haskell.org/package/amazonka-lambda-0.2.0 (BrendanHay)
18:26:33 * hackagebot amazonka-opsworks 0.2.0 - Amazon OpsWorks SDK.  http://hackage.haskell.org/package/amazonka-opsworks-0.2.0 (BrendanHay)
18:26:33 <EvanR> > ''
18:26:35 * hackagebot amazonka-rds 0.2.0 - Amazon Relational Database Service SDK.  http://hackage.haskell.org/package/amazonka-rds-0.2.0 (BrendanHay)
18:26:35 <lambdabot>  <hint>:1:3:
18:26:35 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
18:26:37 * hackagebot amazonka-redshift 0.2.0 - Amazon Redshift SDK.  http://hackage.haskell.org/package/amazonka-redshift-0.2.0 (BrendanHay)
18:26:54 <calvinx> O......
18:27:03 <glguy> Calvinx: put something between your '' like 'x'
18:27:40 <calvinx> I see.....
18:27:43 <calvinx> Thanks!
18:31:39 * hackagebot amazonka-route53 0.2.0 - Amazon Route 53 SDK.  http://hackage.haskell.org/package/amazonka-route53-0.2.0 (BrendanHay)
18:31:41 * hackagebot amazonka-route53-domains 0.2.0 - Amazon Route 53 Domains SDK.  http://hackage.haskell.org/package/amazonka-route53-domains-0.2.0 (BrendanHay)
18:31:43 * hackagebot amazonka-s3 0.2.0 - Amazon Simple Storage Service SDK.  http://hackage.haskell.org/package/amazonka-s3-0.2.0 (BrendanHay)
18:31:45 * hackagebot amazonka-sdb 0.2.0 - Amazon SimpleDB SDK.  http://hackage.haskell.org/package/amazonka-sdb-0.2.0 (BrendanHay)
18:31:47 * hackagebot amazonka-ses 0.2.0 - Amazon Simple Email Service SDK.  http://hackage.haskell.org/package/amazonka-ses-0.2.0 (BrendanHay)
18:32:05 <srhb> Such spam. Many packages.
18:32:09 <pharaun> wow
18:32:10 <ski> EvanR : "so its just f" -- that's eta reduction
18:32:16 <bananagram> much updates
18:32:27 <pharaun> productive night eh?
18:32:33 <latermuse> q
18:32:35 <latermuse> cd /Users/admin/s/force
18:33:22 <EvanR> ski: what, either (f . Left) (g . Right) ?
18:33:34 <EvanR> either (f . Left) (f . Right)
18:33:38 <ski> yes
18:34:10 <EvanR> Left x -> (f . Left) x
18:34:19 <EvanR> Right x -> (f . Right) x
18:34:30 <EvanR> f x
18:34:59 <EvanR> whats the eta rule
18:35:06 <ski> `case ... of Left x -> ..(Left x)..; Right y -> ..(Right y)..', where the two branches are the same, except one mentiones `Left x', where the other mentions `Right y', is equal to `..(...)..'
18:35:44 <EvanR> \x -> f x
18:35:44 <EvanR> f
18:35:46 <EvanR> ok
18:35:59 <bananagram> is it unperformant to have a list as an intermediate type, such as parsing a ByteString into a list of Word16's then creating a Repa array of that list?
18:36:07 <bananagram> since lists are unperformant on their own
18:36:17 <ski> that's an example of "first eliminate" (the `case'), then introduce (use the constructors in the branches)
18:36:33 <EvanR> lists can only be unperformant when you use them in some unperformant way
18:36:45 <ski> eta for functions is `\x -> f x  =  f', yes. here elimination is application of `f', and introduction is the lambda abstraction
18:36:49 * hackagebot amazonka-sns 0.2.0 - Amazon Simple Notification Service SDK.  http://hackage.haskell.org/package/amazonka-sns-0.2.0 (BrendanHay)
18:36:51 * hackagebot amazonka-sqs 0.2.0 - Amazon Simple Queue Service SDK.  http://hackage.haskell.org/package/amazonka-sqs-0.2.0 (BrendanHay)
18:36:53 * hackagebot amazonka-storagegateway 0.2.0 - Amazon Storage Gateway SDK.  http://hackage.haskell.org/package/amazonka-storagegateway-0.2.0 (BrendanHay)
18:36:55 * hackagebot amazonka-sts 0.2.0 - Amazon Security Token Service SDK.  http://hackage.haskell.org/package/amazonka-sts-0.2.0 (BrendanHay)
18:36:57 * hackagebot amazonka-support 0.2.0 - Amazon Support SDK.  http://hackage.haskell.org/package/amazonka-support-0.2.0 (BrendanHay)
18:37:05 <ski> for pairs, we have `(fst p,snd p) = p' as the eta conversion
18:37:29 <EvanR> this is an optimization ghc makes?
18:37:41 <ski> no
18:37:48 <shachaf> They aren't equal in Haskell.
18:37:54 <EvanR> bottoms
18:38:01 <ski> right, when you strictly count bottoms
18:38:15 <EvanR> haskell strikes again
18:41:59 * hackagebot amazonka-swf 0.2.0 - Amazon Simple Workflow Service SDK.  http://hackage.haskell.org/package/amazonka-swf-0.2.0 (BrendanHay)
18:42:01 * hackagebot caramia 0.7.1.0 - High-level OpenGL bindings  http://hackage.haskell.org/package/caramia-0.7.1.0 (Adeon)
18:43:17 <srid> i'm not sure how suitable Haskell is for writing server-side backends or web apps, but I have been using Go which is quite suitable for that. but Go is lacking in the type system. is there a language that is great type system but well suited for backends?
18:43:37 <Adeon> yes, it's haskell
18:43:41 <EvanR> haskell can do that
18:45:50 * hackagebot parsec 3.1.8 - Monadic parser combinators  http://hackage.haskell.org/package/parsec-3.1.8 (AntoineLatter)
18:45:53 <srid> any startups or popular web apps that use Haskell?
18:45:59 <srid> or even for backend services
18:50:23 <srid> answering my question using http://www.quora.com/What-startups-use-Haskell-for-production-work
19:05:15 <ReinH> srid: We're a startup and we use Haskell
19:05:39 <ReinH> we use it to write server-side backends
19:15:51 * hackagebot shell-monad 0.6.2 - shell monad  http://hackage.haskell.org/package/shell-monad-0.6.2 (JoeyHess)
19:20:03 <benzrf> does parametricity imply naturality
19:20:17 <benzrf> are all appropriately-typed functions natural transformations
19:24:12 <Pamelloes> Any good methods for mapping over a list in groups of four elements?
19:24:17 <roboguy_> benzrf: I think parametricity is stronger than naturality
19:24:28 <benzrf> dang
19:25:12 <srhb> Pamelloes: group then fold?
19:25:13 <roboguy_> benzrf: I don't think naturality needs to behave uniformly on everything, it just needs to make that naturality square commute. With parametric polymorphism, it must behave the same for all types
19:25:31 <srhb> Actually something other than fold might be easier (to keep track of the number you're at)
19:26:00 <benzrf> man. wow
19:26:18 <lpaste> Lokathor pasted “No title” at http://lpaste.net/118168
19:26:35 <Lokathor> ghc says there is a parse error in the pattern, but i'm not seeing it
19:26:37 <Pamelloes> srhb: I take it there are no good functions for splitting a list every n elements then?
19:26:54 <roboguy_> Lokathor: you need parentheses around x:xs
19:27:00 <Lokathor> ohhhh
19:27:21 <roboguy_> Lokathor: as it is, it groups it like this: (divByAll i x) : xs =
19:27:40 <Lokathor> well that's not what i was looking for
19:27:48 <Lokathor> okay it works now, thanks
19:27:52 <roboguy_> np
19:27:59 <srhb> @hoogle splitEvery -- Pamelloes
19:28:02 <lambdabot> Parse error:
19:28:02 <lambdabot>   splitEvery -- Pamelloes
19:28:02 <lambdabot>                ^
19:28:05 <srhb> Ergh
19:28:08 <srhb> @hoogle splitEvery
19:28:08 <lambdabot> No results found
19:28:18 <srhb> Harumpf. It's in the split package.
19:28:32 <Zemyla> roboguy_: It would be nice if Haskell could work that way, but it can't.
19:28:41 <srhb> @hoogle chunksOf
19:28:41 <lambdabot> Data.Text chunksOf :: Int -> Text -> [Text]
19:28:42 <lambdabot> Data.Text.Lazy chunksOf :: Int64 -> Text -> [Text]
19:28:46 <srhb> Oh well.
19:28:54 <roboguy_> Zemyla: hmm, would it? We might get less guarantees from type signatures
19:29:03 <Zemyla> > toRational 3
19:29:04 <lambdabot>  3 % 1
19:29:14 <Zemyla> roboguy_: True.
19:29:27 <Pamelloes> srhb: I'll look into it, thanks :)
19:30:23 <srhb> Pamelloes: Sure thing. And for the record, what I was thinking with foldr was something like holding the number in the accumulator, so the second parameter becomes ([],0) or something like that. Then your folding function can behave differently depending on the number of the group you're on
19:30:56 <srhb> (A simpler solution might be to simply tag the groups with zip)
19:30:58 <Pamelloes> I'm thinking I'm probably going to do a foldr over splitEvery
19:31:34 <srhb> map (\list groupnum) . zip
19:31:36 <srhb> er
19:31:45 <srhb> zip [1..] . chunksOf 4
19:39:27 <roboguy_> Lokathor: you could also write than in pl form if you wanted: all ((== 0) . (5 `div`))
19:40:34 <Lokathor> actually what i wrote is wildly off from what i want :P I confused the use of div and mod yet again, and also it didn't seem to return the correct values even then
19:40:56 <roboguy_> what do you want it to do?
19:41:35 <Lokathor> working on the project euler problems. prob5 is the lowest int that's evenly divisible by all ints 1-20
19:42:04 <roboguy_> oh, yeah you do want either mod or rem for that
19:43:31 <roboguy_> you should make sure you have the arguments in the right order
19:45:04 <Lokathor> yeah that's important too
19:48:48 <Lokathor> okay say i have a list of functions, how do i apply the same argument to all functions in the list
19:48:51 <Lokathor> like, a reverse map
19:49:06 <Iceland_jack> Lokathor: map ($ x)
19:49:08 <ReinH> Lokathor: map ($ a)
19:49:11 <ReinH> doh
19:49:21 <Iceland_jack> or [ f x | f <- fs ]
19:49:31 <Lokathor> ah that dollar sign
19:49:42 <ReinH> Iceland_jack: you win
19:49:57 <Iceland_jack> Do I get a prize?
19:50:05 <ReinH> not really
19:50:14 <shachaf> Or sequence!
19:51:40 <ReinH>  ah indeed!
19:51:50 <ReinH> that one is maybe less obvious but nice
19:52:30 <ReinH> :t sequence `asAppliedto` [id]
19:52:31 <lambdabot>     Not in scope: ‘asAppliedto’
19:52:31 <lambdabot>     Perhaps you meant ‘asAppliedTo’ (line 165)
19:52:35 <ReinH> :t sequence `asAppliedTo` [id]
19:52:35 <lambdabot> [a -> a] -> a -> [a]
19:59:19 <Pamelloes> Would the following function definition work? myfunc::Int->String; myFunc 1 = "Yay!"; myFunc = show
19:59:32 <shachaf> No.
20:00:06 <shachaf> (You can usually find out the answer to that sort of question quickly with ghci.)
20:00:30 <Pamelloes> .... That's actually a really good idea.
20:00:59 <zq> :t let f 1 = "yay"; f x = show x in f
20:01:01 <lambdabot> (Show a, Num a, Eq a) => a -> [Char]
20:01:02 <Pamelloes> How would I put that into ghci? I always struggle at defining functions interactively
20:01:19 <shachaf> Write let in front of it, and then type exactly what you typed here.
20:01:52 <Pamelloes> So semicolons as statements delimeters are actually valid?
20:02:02 <Pamelloes> It's a brave new world...
20:02:12 <Lokathor> i'm having some trouble with takeWhile and dropWhile... i can map a function over a list and get all False and a single True at the end, but using dropWhile with the same function over the same list returns the entire input list.
20:02:38 <Lokathor> but takeWhile returns an empty list
20:02:56 <zq> @src takeWhile
20:02:56 <lambdabot> takeWhile _ []                 = []
20:02:56 <lambdabot> takeWhile p (x:xs) | p x       = x : takeWhile p xs
20:02:56 <lambdabot>                    | otherwise = []
20:03:06 <zq> Lokathor: ^
20:03:56 <Lokathor> takeWhile f list is all empty, dropWhile f list is all there, and map f list returns almost all false, and a single true at the end. that doen't seem like it should be the case
20:04:50 <dibblego> Lokathor: do you have example code that we could look at?
20:05:07 <Lokathor> i will make an lpaste, 1 moment
20:05:35 <Pamelloes> If I set an IO value in a where clause and then use that value inside a do, will the value be recalculated or reused?
20:06:04 <zq> Lokathor: did you read the @src above?
20:06:54 <Pamelloes> On a completely unrelated note, can I get @src in ghci?
20:07:07 <Lokathor> hmm
20:07:13 <Lokathor> @src dropWhile
20:07:14 <lambdabot> Source not found.
20:07:34 <dibblego> Pamelloes: if the value is used twice, as in: let x = print "hi" in x >> x, then the IO value won't be calculated twice. Note that this is different to *performing IO* twice, which doesn't really occur in haskell; instead we assemble IO values and assign them to main
20:07:36 <Lokathor> bummer, it's only really dropWhile that i'm worried about working..
20:07:52 <kylerisse1010> Somebody out there??
20:08:15 <srobert> :q
20:09:01 <kylerisse1010> Can a fall from a nine floor kill me?? I want to suicide me easily.
20:10:11 <lpaste> Lokathor pasted “No title” at http://lpaste.net/118169
20:10:29 <mjo> kylerisse1010: you'll probably get better advice in #javascript
20:11:08 <MP2E> lol..
20:12:13 <Lokathor> okay, i think i know what's going on, i don't want "dropWhile", i want a theoretical "drop until"
20:12:16 <kylerisse1010> Please, tell me a success way to kill me.
20:12:31 <Pamelloes> mjo: Cruel and unusual?
20:12:38 <zq> Lokathor: so, invert  your predicate?
20:12:44 <kylerisse1010> No. Normal.
20:12:46 <dibblego> Lokathor: dropWhile means "drop elemenst while this predicate holds", but the predicate doesn't hold for the entire list, except the last element.
20:13:03 <dibblego> Lokathor: dropWhile (not . f) -- try tha
20:13:03 <dibblego> t
20:13:08 <kylerisse1010> I just want to die in peace. God sucks!!
20:13:42 <mjo> Pamelloes: I figure most people there have at least looked into the matter
20:13:49 <Pamelloes> Touché
20:14:10 <Pamelloes> Is there a way to use guards within a do statement?
20:14:38 <brainacid> Hello to everyone!
20:14:44 <Pamelloes> Hello!
20:14:48 <mjo> Pamelloes: what do you have in mind?
20:15:38 <kylerisse1010> My life is useless. Please, help me to commit suicide. Give me links or methods
20:15:54 * hackagebot hoauth2 0.4.5 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.4.5 (HaishengWu)
20:17:02 <Pamelloes> I have a function like myfunc a;| a==1=...;|a==2=.... and so forth. However, I need to get a constant value from an IO function that will be used in every branch.
20:17:08 <_um> Hi, all. Confession: I've been studying Haskell for a while now. Not super intensely, but steady. It's been fun and illuminating. But I'm now trying to dabble with a few simple practical things, like parsing JSON data and getting data from https get requests.... I am feeling quite dismayed and dispirited.
20:17:44 <_um> Even just saying that is kind of relieving. No replies needed. Sorry to clutter the channel.
20:17:52 <Pamelloes> Ideally I would have myfunc a = do {myval<-complicatedIOFunc;|a==1=....;|a==2=...}
20:18:44 <MP2E> _um: have you looked into the HTTP and parsec libraries? I felt similarly overwhelmed until I stopped thinking about it and started hacking a bit :)
20:18:52 <MP2E> the type system leads the way well for such things
20:18:59 <MP2E> err
20:19:00 <MP2E> not parsec
20:19:02 <MP2E> aeson *
20:19:05 <MP2E> sorry about that :P
20:19:17 <_um> MP2E: yes, that's what I've been struggling with.
20:19:45 <_um> Couldn't get the HTTP package to play nice with my https requests, so I ended up using Network.Curl
20:20:01 <_um> I'm at least pulling down data now.
20:20:35 <_um> MP2E: I'm just coming to grips with the Aeson package...
20:20:55 <MP2E> oh you're right HTTP doesn't support HTTPS
20:23:28 <mjo> Pamelloes: https://bpaste.net/show/52bb8ca07547
20:23:47 <_um> MP2E: I do hope the type system will lead the way, but I'm starting to feel the oppressiveness of the static typing now. It is going to be *much* more difficult to get data out of the JSON that it would in a dynamic system. It looks like you basically just have to write your own parser, unless you can count on the incoming JSON being completely reliable and uniform.
20:23:55 <mjo> It's a little ugly, but pretty wasn't one of your requirements =)
20:24:18 <dmj`> _um: if you use a better http library you can perform stream parsing on your json body, one that uses a streaming library with attoparsec support underneath
20:24:45 <_um> dmj`: That sounds nice. What do you suggest?
20:24:57 <dmj`> _um: http-client-streams, http://hackage.haskell.org/package/http-client-streams
20:25:22 <Pamelloes> mjo: That's basically what I'm looking for. Google also suggesting using "case". Thoughts on your solution vs that?
20:25:32 <dmj`> _um: you get the optional choice of haskell tls or openssl, io-streams is also the fastest streaming lib and very simple compared to the rest
20:25:33 <_um> dmj`: Cool. I
20:25:45 <_um> *'ll give that a shot. Thanks for the recommendation!
20:26:10 <mjo> Pamelloes: They're the same thing. I thought you had some secret reason for preferring guards.
20:26:15 <zaphix> if I'm in ExceptT String m, run a computation which produces a value of type (Either String a), and then I apply (either throwE return) to it, is there a name for that last operation? It feels vaguely lift-ish but it's not
20:26:27 <_um> dmj`: Maybe I should have just asked for recommendations here instead of trying to puzzle out which package to use on my own. That one didn't even pop up in my searches.
20:26:32 <Pamelloes> mjo: hehe no, I just didn't know the case function existed. :)
20:26:36 <mjo> I would use a case statement if I were you. The syntax is a little cleaner.
20:26:37 <Pamelloes> Thanks for your help
20:27:09 <_um> I think that I also just needed to vent though. There
20:27:22 <_um> 's lots I'm appreciating about the type system, but there are some real growing paints too.
20:27:30 <_um> s/paints/pains
20:27:38 <vanila> like what?
20:27:49 <vanila> mostly if you have type errors it means there was a bug in the code
20:28:11 <dmj`> using haskell to interface with other systems makes you keenly aware of their inconsistencies
20:30:41 <_um> vanila: Like, in other languages I've used I could so something like `jsonData = getData("domain/request") ; x = fromJson(jsonData) ;  v = x.get("key")`, and just have the value I wanted.
20:30:54 <_um> I should say, in *some* other languages.
20:30:58 <dmj`> _um: if you're afraid the json body will change, using bos's generic json' parser will parse it correctly (per RFC2616) as long as the return value is a list or an object, otherwise he has written a json value parser too (if the return body is just a json value). parseFromStream is the function you'd want though
20:31:56 <vanila> I havne't work with JSON but hopefully there is a good way to do a similar thing here
20:32:36 <_um> dmj`:  That makes sense what you say about revealing inconsistencies. So my frustration may well be caused by the inconsistency of the other systems I'm trying to interact with but then reflected back on Haskell, because I'm used to using other systems which are similarly inconsistent, so that the problems don't show up until way down the line, when it's too late to recognize the real cause.
20:33:18 <_um> word, dmj`. That's very helpful.
20:33:26 <Jello_Raptor> hmm, has there been any update on the "category theory for programmers" coursera course that was talked about a while back?
20:34:06 <_um> dmj`, vanila: I'm going to start fresh and come at the program again with the tools dmj` mentioned in hand.  Thanks a lot for the tips.
20:34:17 <vanila> good idea!
20:38:06 <dmj`> _um: np
20:39:10 <dmj`> Jello_Raptor: unsure about coursera... but Bartosz Milewski is writing a book with that title, http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
20:39:46 <Jello_Raptor> dmj`: oh, I hadn't heard of this. Thank you.
20:40:26 <dmj`> Jello_Raptor: np
20:42:48 <danielszmulewicz> howdy
20:43:55 <lisbeth> hey any fedora users who can help me out?
20:44:23 <bernalex> lisbeth: it took me a few minutes to realise you did not mean the type of hat
20:44:24 <glguy> You'll have the best luck just asking the question you need help with
20:44:42 <lisbeth> glguy I am still typing :p
20:44:48 <bernalex> "I have a question that only someone who wears a fedora would be able to answer, others need not even try"
20:45:03 <lisbeth> I need the fedora equivelent of zlib1g-dev in ubuntu, so that I can cabal install cabal-install
20:45:35 <dmj`> _um: it's actually RFC4627 :)
20:45:38 <lisbeth> hehe lets not make fun of fedora for the name fellaz
20:45:43 <lisbeth> its just a name
20:45:56 <_um> Shucks, Cabal tells me installing http-client-streams will probably break a dozen (much more essential) packages... so I'm already facing the prospect of Cabal hell? I've already been banging my head against the wall for the last 3 hours..
20:46:16 <lisbeth> I don't know what that package would be called is the issue
20:46:19 <_um> I think I'm going to admit defeat for the time being. Very frustrating...
20:46:21 <dmj`> _um: are you using sandboxes?
20:46:22 <lisbeth> and I am in a docker instance, not in an actual fedora desktop
20:46:35 <_um> dmj`: apparently I need to be.
20:46:38 <dmj`> _um: yes
20:47:03 <glguy> It's something like zlib-devel . have you tried that?
20:47:39 <danielszmulewicz> Why is flycheck marking/underlining "import           System.Environment"
20:47:43 <danielszmulewicz> ?
20:47:50 <_um> I think I might just pull in and sanitize the data in a more manageable ecosystem and then pipe the clean data into Haskell. This is driving me a bit crazy. But, if I'm feeling ambition tomorrow, I'll maybe read up on Sandboxes and start over.
20:48:01 <_um> s/pull in/give up
20:48:37 <dmj`> _um: are you just trying to get json from a server?
20:48:40 <_um> Thanks again for the help, dmj`.
20:49:06 <_um> dmj`: Yeah, get it and then parse it out.
20:49:12 <_um> Pull out the data I need.
20:49:13 <dmj`> _um: what's the url?
20:49:24 <dmj`> _um: or is it internal?
20:49:38 <_um> I'll be working with wordsapi.
20:49:48 <_um> https://www.wordsapi.com/docs
20:51:18 <dmj`> _um: it seems straight forward enough
20:51:32 <dmj`> _um: have you written the FromJSON instances?
20:51:40 <danielszmulewicz> flycheck doesn't like this neither: import qualified System.Environment as SV
20:51:42 <dramforever> lisbeth: I'm a fedora user, but I did "yum install haskell-platform" to install my environment
20:52:09 <_um> dmj`: Nope. But the returned JSON will vary depending on which fields are available in the wordsApi database.
20:52:11 <lisbeth> I will try that out as well
20:52:17 <_um> dmj`: (I may just be being dense)
20:52:28 <dramforever> lisbeth: you know what is haskell platform?
20:52:31 <lisbeth> dramaforever do you think zlib-devel is the package I am looking for?
20:52:40 <lisbeth> dramaforever I am about to find out :)
20:52:47 <_um> dmj`: So I was going to take your advice on  "bos's generic json' parser"
20:52:48 <levi> danielszmulewicz: Flycheck usually provides some hints as to why it's underlining things; what do those say?
20:52:53 <dramforever> lisbeth: not really
20:53:05 <dramforever> and look at my nick again
20:53:51 <_um> But, I can pull in the data I need and clean it up with a couple lines of Prolog or Python, and than just pass that to Haskell. It'll be so much easier. I think I might go that rout. Figuring out how to interface Haskell with third party api's and https isn't an interesting problem to me--it's just tedious. But maybe I'm just burnt out tonight too. I'l try tomorrow again with a fresh mind.
20:54:58 <danielszmulewicz> levi: It gives the syntax form it expects for import, namely import [qualified] modid [as modid] [impspec]
20:55:00 <dmj`> _um: it doesn't seem like they drop fields, but even if they do, you can just make them Maybe's and use the (.:?) function in your parser
20:55:13 <danielszmulewicz> levi: I adhere to that as far as I can see.
20:55:22 <dmj`> _um: sounds good
20:55:49 <lisbeth> dramaforever zlib-devel seemed to do it
20:56:20 <_um> dmj`: Thanks again! You've been very helpful. I'll take the time to set stuff up in sandboxes before long, and keep my fingers crossed the package/module system gets fixed before I'm ever at the point to be doing serious work in Haskell.
20:56:23 <dramforever> lisbeth: glad you solved it, but you still spelt my nick incorrectly
20:56:34 <_um> good night all.
20:56:54 <dramforever> dram[no "a" here"]forever
20:57:03 <dramforever> s/here"/here/
20:57:05 <danielszmulewicz> flycheck does a great job on the buffer altogether
20:57:23 <danielszmulewicz> But it always highlights the first line
20:57:31 <danielszmulewicz> whether I define a module or use an import
20:58:25 <levi> danielszmulewicz: I think that's some other emacs thing (eldoc mode, maybe?) giving you a hint rather than flycheck. Try mousing over the underlined import?
21:00:42 <danielszmulewicz> BTW, haskell.org is extremely slow on my end.
21:00:43 <levi> If you M-x flycheck-list-errors you should get a buffer that lists all the issues flycheck found.
21:02:28 <danielszmulewicz> levi: Yes, you are correct. But it does not indicate any error for import. The error list is empty. It just underlines the line with the import.
21:04:52 <danielszmulewicz> levi: (and puts an exclamation mark in the margin)
21:05:32 <danielszmulewicz> C-c ! n says no error
21:05:54 <levi> Do you have something else like flymake-mode also active?
21:07:50 <danielszmulewicz> levi: Not flymake, but I do use SHM (Structured Haskell mode)
21:09:12 <Pamelloes> How do I divide two integers rounding towards -infinity?
21:09:59 <levi> danielszmulewicz: I don't recall SHM making any underlines... try C-h m and look through the list of active minor modes to see what might be doing underlines.
21:10:50 <Lokathor> as I do more of these project euler problems, haskell is not able to cope so well compared to an imperative langauge because they do things like asking for the 10,001st prime and such, so the "simple" way ends up being very very slow
21:11:56 <Lokathor> or adding up all primes below 2mil
21:13:27 <levi> Lokathor: There is generally a way to do things efficiently in Haskell, though it may not be the obvious way. I'm afraid I can't help much with numerical problems, though.
21:13:53 <Lokathor> yes I imagine there's much more efficient ways to do it that are nonobvious
21:14:04 <roboguy_> Lokathor: adding some strictness can help sometimes
21:14:54 <roboguy_> the performance of that kind fo thing depends pretty heavily on the algorithm you use to generate primes
21:15:04 <Lokathor> for example, the "add up the first 2 million primes" is trivial, sum $ takeWhile (<2000000) primes, but generating that list of primes in an efficient way isn't obvious to me
21:15:44 <Lokathor> there's a primes package apparently, but my cabal is messed up hard right now so i couldn't install it to try that instead >_<
21:16:49 <thebnq> you can make an infinite prime sieve in about 20 lines that gets those primes pretty quickly
21:17:16 <lpaste> Lokathor pasted “No title” at http://lpaste.net/118172
21:17:20 <danielszmulewicz> levi: Maybe it's not flycheck, like you say. Here's the c-h m output: https://www.refheap.com/95931
21:17:21 <kadoban> Lokathor: A cool paper on it, if you're interested: http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
21:17:22 <Lokathor> is what i'm using
21:20:18 <Lokathor> hmm
21:20:34 <roboguy_> Lokathor: that trial division algorithm is a bit slow. it can be sped up a bit at least by realizing that you only need to check up to sqrt(p) where p is the number being tested for primality
21:20:36 <Lokathor> this does look much more complicated, but probably much faster
21:20:57 <danielszmulewicz> levi: Here's a screenshot: https://www.dropbox.com/s/73svj98m3zs0p4w/Screenshot%202015-01-10%2007.17.22.png?dl=0
21:22:10 <hrumph> how come fedora 21 is still on ghc 7.6 (instead of 7.8)
21:22:36 <hrumph> ?
21:22:52 <thebnq> Lokathor: might be more copyable code here :P https://www.haskell.org/haskellwiki/Prime_numbers
21:23:32 <levi> danielszmulewicz: Hmm, maybe it's flycheck after all. Does it disappear if you turn flycheck mode off?
21:23:47 <dmj`> does anyone have recommendations for a genetic programming library on hackage? It seems there are a few
21:31:01 <danielszmulewicz> levi: Ha, nice one! It doesn't disappear after I turn flycheck-mode off. So it's not flycheck. I noticed that in the modeline something says "failed". I wonder what that is.
21:31:15 <Lokathor> it was mostly disheartening when my friend, doing the same problems, would take twice as long to write the answers but get the output 10 times as fast
21:31:37 <Lokathor> in javascript, of all langauges
21:32:47 <roboguy_> Lokathor: this is how I'd go about it http://lpaste.net/118173
21:33:20 <danielszmulewicz> levi: Maybe I forgot to install hdevtools... Checking...
21:36:41 <Lokathor> that is much much faster
21:37:06 <roboguy_> it checks only up to sqrt(p)
21:38:00 <roboguy_> also, it throws out composites altogether. I don't think the other version does that
21:38:40 <Lokathor> yeah the first version was unacceptably slow, your version runs in a useful time period even if it' not the fastest possible
21:40:17 <danielszmulewicz> levi: Can't find the culprit. Here is my emacs haskell configuration: https://github.com/danielsz/.emacs.d#haskell
21:40:58 * hackagebot rawstring-qm 0.1.6 - Simple raw string quotation and dictionary interpolation  http://hackage.haskell.org/package/rawstring-qm-0.1.6 (tolysz)
21:46:39 <drbean_> 2 modules have the same named functions, one of which I want to import by exporting it, but this results in 'Ambiguous occurrence..'
21:47:10 <drbean_> How do I export it under a different name?
21:49:13 <mjo> drbean_: import one of the modules qualified, like: import qualified Data.ByteString.Char8 as BS
21:49:32 <mjo> then refer to the function with the "BS" prefix, e.g. BS.length
21:49:55 <mjo> If you only want to import one function qualified and the rest unqualified, it'll take two import statements
21:50:41 <mjo> import Data.ByteString.Char8 hiding ( length ); import qualified Data.ByteString.Char8 as BS ( length );
21:51:04 <mjo> Now BS.length needs the qualified name, the rest of the functions in that module don't
21:51:22 <drbean_> The 2 modules are upstream and the Ambiguous Occurrence is coming from upstream. I want to avoid touching them as much as possible.
21:51:39 <mjo> You don't have to touch them at all
21:51:46 <mjo> When you import them into your code, you do it qualified
21:51:56 <drbean_> You can't change the name when you export it?
21:52:23 <mjo> I mean, you can do foo = bar and then export foo instead
21:52:34 <mjo> Which modules and which function are the problem?
21:52:59 <drbean_> I will go with foo = bar
21:53:38 <mjo> Are you trying to RE export two functions of the same name? That won't work, because when someone imports YourModule (foo), foo can only refer to one thing
21:54:17 <mjo> No matter where they came from, you can't export two things of the same exact name. In that case foo = bar is the only option I know of.
22:05:59 * hackagebot hspec-wai 0.6.3 - Experimental Hspec support for testing WAI applications  http://hackage.haskell.org/package/hspec-wai-0.6.3 (SimonHengel)
22:06:03 <drbean_> A library upstream has 2 functions in 2 different modules with the same name, neither of which it exports. I want one of the functions. When I put it in the module's export list, I get a Ambiguous Occurrence from the other module, which imports the first one.
22:06:36 <drbean_> I guess I could hide it in the other module, but that means touching 2 library modules, instead of one.
22:13:35 <mjo> drbean_: oh, ok. If the second upstream module imports the first, there's no problem, because the problem function isn't imported from the first module. But then when you export that function, it introduces a name collision.
22:14:44 <mjo> For a long-term solution, I would ask upstream if they'd consider exporting the one that you need. You might have to wait a while though.
22:15:12 <mjo> If you're patching the upstream code in your project, doing foo = bar and then exporting foo is probably the least intrusive
22:16:05 <Zemyla> What the heck are contravariant functors?
22:16:40 <roboguy_> Zemyla: type-wise, they map "backwards" from a covariant functor
22:16:48 <roboguy_> :t contramap
22:16:49 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
22:16:55 <roboguy_> :t fmap
22:16:55 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:17:16 <Zemyla> How do you get a-values from f b and a -> b>
22:17:45 <roboguy_> Zemyla: One way to look at it is that covariant functors map over "producers" (mostly) and contravariant functors map over "consumers" (mostly)
22:17:57 <roboguy_> the best way to understand any type class like this is to look at the instances
22:18:30 <roboguy_> Now, ((->) r) has a covariant functor instance (this instance maps over the return type)
22:18:53 <Zemyla> Oh, okay.
22:18:57 <roboguy_> There is a contravariant instance for a type that is like (->) but flipped (data Op a b = Op (b -> a)) that maps over the *input* type
22:19:17 <Zemyla> When I saw Predicate, it kind of made sense.
22:19:55 <roboguy_> There are also instances for Proxy and Const
22:20:14 <roboguy_> it definitely looks weird the first time you see it though
22:22:18 <Zemyla> Is there a monoid on the category of contravariant endofunctors?
22:24:14 <roboguy_> the category of contravariant endofunctors would be a subcategory of the category of endofunctors. Categorically, a contravariant functor is just a functor to the opposite category of its codomain
22:24:23 <roboguy_> I'm not sure though
22:24:45 <roboguy_> there are comonads though, which you might be interested in
22:26:55 <Zemyla> Yes, but a contramonad would have contrabind :: c b -> (a -> c b) -> c a.
22:27:57 <roboguy_> :t flip extend
22:27:58 <lambdabot> Not in scope: ‘extend’
22:28:13 <roboguy_> flip extend :: Comonad w => w a -> (w a -> b) -> w b
22:28:20 <roboguy_> close
22:28:29 <Zemyla> Like, how ((->) e) is a monad, (Op e) would be a contramonad.
22:29:13 <Zemyla> @djinn (b -> e) -> (a -> b -> e) -> (a -> e)
22:29:13 <lambdabot> -- f cannot be realized.
22:30:04 <roboguy_> There is something like Applicative for Contravariant called Divisible
22:31:50 <roboguy_> Zemyla: actually, as I understand it, "presheaf" pretty much means "contravariant functor", so it looks like the answer to your question is yes based on this: https://hackage.haskell.org/package/contravariant-1.2.0.1/docs/Data-Functor-Contravariant-Divisible.html
22:33:47 <Zemyla> @djinn (Monoid e) => (e -> a) -> a
22:33:47 <lambdabot> Error: Class not found: Monoid
22:34:16 <Axman6> djinn has many limitations
22:34:46 <Axman6> though, I guess you could equivalently ask:
22:35:05 <Axman6> @djinn (e, e -> e -> e) -> (e -> a) -> a
22:35:05 <lambdabot> f (a, b) c = c (b a a)
22:36:10 <Axman6> (with the tuple representing the Monoid instance; djinn will try to use everything it can to come up with the answer, hence the use of b)
22:37:04 <Zemyla> @djinn (e -> e -> e) -> (e -> a) -> (e -> e -> a)
22:37:05 <lambdabot> f _ a b _ = a b
22:37:58 <ridecar2> Hi all
22:38:07 <Axman6> 'lo
22:38:17 <ridecar2> How are you?
22:39:13 <Axman6> good. do you have a question we can help you with?
22:39:54 <ridecar2> Not at the moment, just starting to learn Haskell and dropped by
22:49:02 <Zemyla> :t All
22:49:02 <lambdabot> Bool -> All
23:01:13 <Zemyla> > mempty :: All
23:01:14 <lambdabot>  All {getAll = True}
23:02:07 <Lokathor> There didn't appear to be an SDL2 tutorial specific for haskell, so I have written the first in what I hope to be a complete set of tutorials, based upon the lazyfoo SDL2 tutorials for C++, https://sites.google.com/site/haskellsdl2tutorial/lesson-01
23:02:21 <Lokathor> just translating the C++ stuff straight over into haskell, nothing complex
23:32:55 <relrod> Is there an easy way to `cabal test --test-option="foo"` but only have the --test-option apply to one test suite instead of all of them? Or is it best to just write something to run each test suite individually at that point?
23:33:51 <pingu> bbbbbbbbbbbb
23:54:11 <jessicah> I'm trying to build parsec-3.1.7 with cabal, but I'm specifying a custom package-db location, and am invoking cabal via runghc...
23:54:15 <Zemyla> :t lift . lift
23:54:16 <lambdabot> (MonadTrans t1, MonadTrans t, Monad (t1 m), Monad m) => m a -> t (t1 m) a
23:54:33 <jessicah> but I get an error that the package-id for mtl can't be resolved
23:54:49 <jessicah> although this package is already installed, and listed in the custom package-db cache file
